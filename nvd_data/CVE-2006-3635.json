{
  "cve_id": "CVE-2006-3635",
  "github_data": {
    "repository": "torvalds/linux",
    "fix_commit": "4dcc29e1574d88f4465ba865ed82800032f76418",
    "related_commits": [
      "4dcc29e1574d88f4465ba865ed82800032f76418",
      "4dcc29e1574d88f4465ba865ed82800032f76418"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "4dcc29e1574d88f4465ba865ed82800032f76418",
      "commit_date": "2008-05-27T20:23:16Z",
      "author": {
        "login": "aegl",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "[IA64] Workaround for RSE issue",
        "length": 1560,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 175,
        "additions": 128,
        "deletions": 47
      },
      "files": [
        {
          "filename": "arch/ia64/kernel/ivt.S",
          "status": "modified",
          "additions": 42,
          "deletions": 42,
          "patch": "@@ -1076,48 +1076,6 @@ END(ia64_syscall_setup)\n \tDBG_FAULT(15)\n \tFAULT(15)\n \n-\t/*\n-\t * Squatting in this space ...\n-\t *\n-\t * This special case dispatcher for illegal operation faults allows preserved\n-\t * registers to be modified through a callback function (asm only) that is handed\n-\t * back from the fault handler in r8. Up to three arguments can be passed to the\n-\t * callback function by returning an aggregate with the callback as its first\n-\t * element, followed by the arguments.\n-\t */\n-ENTRY(dispatch_illegal_op_fault)\n-\t.prologue\n-\t.body\n-\tSAVE_MIN_WITH_COVER\n-\tssm psr.ic | PSR_DEFAULT_BITS\n-\t;;\n-\tsrlz.i\t\t// guarantee that interruption collection is on\n-\t;;\n-(p15)\tssm psr.i\t// restore psr.i\n-\tadds r3=8,r2\t// set up second base pointer for SAVE_REST\n-\t;;\n-\talloc r14=ar.pfs,0,0,1,0\t// must be first in insn group\n-\tmov out0=ar.ec\n-\t;;\n-\tSAVE_REST\n-\tPT_REGS_UNWIND_INFO(0)\n-\t;;\n-\tbr.call.sptk.many rp=ia64_illegal_op_fault\n-.ret0:\t;;\n-\talloc r14=ar.pfs,0,0,3,0\t// must be first in insn group\n-\tmov out0=r9\n-\tmov out1=r10\n-\tmov out2=r11\n-\tmovl r15=ia64_leave_kernel\n-\t;;\n-\tmov rp=r15\n-\tmov b6=r8\n-\t;;\n-\tcmp.ne p6,p0=0,r8\n-(p6)\tbr.call.dpnt.many b6=b6\t\t// call returns to ia64_leave_kernel\n-\tbr.sptk.many ia64_leave_kernel\n-END(dispatch_illegal_op_fault)\n-\n \t.org ia64_ivt+0x4000\n /////////////////////////////////////////////////////////////////////////////////////////\n // 0x4000 Entry 16 (size 64 bundles) Reserved\n@@ -1715,6 +1673,48 @@ END(ia32_interrupt)\n \tDBG_FAULT(67)\n \tFAULT(67)\n \n+\t/*\n+\t * Squatting in this space ...\n+\t *\n+\t * This special case dispatcher for illegal operation faults allows preserved\n+\t * registers to be modified through a callback function (asm only) that is handed\n+\t * back from the fault handler in r8. Up to three arguments can be passed to the\n+\t * callback function by returning an aggregate with the callback as its first\n+\t * element, followed by the arguments.\n+\t */\n+ENTRY(dispatch_illegal_op_fault)\n+\t.prologue\n+\t.body\n+\tSAVE_MIN_WITH_COVER\n+\tssm psr.ic | PSR_DEFAULT_BITS\n+\t;;\n+\tsrlz.i\t\t// guarantee that interruption collection is on\n+\t;;\n+(p15)\tssm psr.i\t// restore psr.i\n+\tadds r3=8,r2\t// set up second base pointer for SAVE_REST\n+\t;;\n+\talloc r14=ar.pfs,0,0,1,0\t// must be first in insn group\n+\tmov out0=ar.ec\n+\t;;\n+\tSAVE_REST\n+\tPT_REGS_UNWIND_INFO(0)\n+\t;;\n+\tbr.call.sptk.many rp=ia64_illegal_op_fault\n+.ret0:\t;;\n+\talloc r14=ar.pfs,0,0,3,0\t// must be first in insn group\n+\tmov out0=r9\n+\tmov out1=r10\n+\tmov out2=r11\n+\tmovl r15=ia64_leave_kernel\n+\t;;\n+\tmov rp=r15\n+\tmov b6=r8\n+\t;;\n+\tcmp.ne p6,p0=0,r8\n+(p6)\tbr.call.dpnt.many b6=b6\t\t// call returns to ia64_leave_kernel\n+\tbr.sptk.many ia64_leave_kernel\n+END(dispatch_illegal_op_fault)\n+\n #ifdef CONFIG_IA32_SUPPORT\n \n \t/*"
        },
        {
          "filename": "arch/ia64/kernel/minstate.h",
          "status": "modified",
          "additions": 42,
          "deletions": 4,
          "patch": "@@ -15,6 +15,9 @@\n #define ACCOUNT_SYS_ENTER\n #endif\n \n+.section \".data.patch.rse\", \"a\"\n+.previous\n+\n /*\n  * DO_SAVE_MIN switches to the kernel stacks (if necessary) and saves\n  * the minimum state necessary that allows us to turn psr.ic back\n@@ -40,7 +43,7 @@\n  * Note that psr.ic is NOT turned on by this macro.  This is so that\n  * we can pass interruption state as arguments to a handler.\n  */\n-#define DO_SAVE_MIN(COVER,SAVE_IFS,EXTRA)\t\t\t\t\t\t\t\\\n+#define DO_SAVE_MIN(COVER,SAVE_IFS,EXTRA,WORKAROUND)\t\t\t\t\t\t\\\n \tmov r16=IA64_KR(CURRENT);\t/* M */\t\t\t\t\t\t\t\\\n \tmov r27=ar.rsc;\t\t\t/* M */\t\t\t\t\t\t\t\\\n \tmov r20=r1;\t\t\t/* A */\t\t\t\t\t\t\t\\\n@@ -87,6 +90,7 @@\n \ttbit.nz p15,p0=r29,IA64_PSR_I_BIT;\t\t\t\t\t\t\t\\\n \tmov r29=b0\t\t\t\t\t\t\t\t\t\t\\\n \t;;\t\t\t\t\t\t\t\t\t\t\t\\\n+\tWORKAROUND;\t\t\t\t\t\t\t\t\t\t\\\n \tadds r16=PT(R8),r1;\t/* initialize first base pointer */\t\t\t\t\\\n \tadds r17=PT(R9),r1;\t/* initialize second base pointer */\t\t\t\t\\\n (pKStk)\tmov r18=r0;\t\t/* make sure r18 isn't NaT */\t\t\t\t\t\\\n@@ -206,6 +210,40 @@\n \tst8 [r25]=r10;      \t/* ar.ssd */\t\\\n \t;;\n \n-#define SAVE_MIN_WITH_COVER\tDO_SAVE_MIN(cover, mov r30=cr.ifs,)\n-#define SAVE_MIN_WITH_COVER_R19\tDO_SAVE_MIN(cover, mov r30=cr.ifs, mov r15=r19)\n-#define SAVE_MIN\t\tDO_SAVE_MIN(     , mov r30=r0, )\n+#define RSE_WORKAROUND\t\t\t\t\\\n+(pUStk) extr.u r17=r18,3,6;\t\t\t\\\n+(pUStk)\tsub r16=r18,r22;\t\t\t\\\n+[1:](pKStk)\tbr.cond.sptk.many 1f;\t\t\\\n+\t.xdata4 \".data.patch.rse\",1b-.\t\t\\\n+\t;;\t\t\t\t\t\\\n+\tcmp.ge p6,p7 = 33,r17;\t\t\t\\\n+\t;;\t\t\t\t\t\\\n+(p6)\tmov r17=0x310;\t\t\t\t\\\n+(p7)\tmov r17=0x308;\t\t\t\t\\\n+\t;;\t\t\t\t\t\\\n+\tcmp.leu p1,p0=r16,r17;\t\t\t\\\n+(p1)\tbr.cond.sptk.many 1f;\t\t\t\\\n+\tdep.z r17=r26,0,62;\t\t\t\\\n+\tmovl r16=2f;\t\t\t\t\\\n+\t;;\t\t\t\t\t\\\n+\tmov ar.pfs=r17;\t\t\t\t\\\n+\tdep r27=r0,r27,16,14;\t\t\t\\\n+\tmov b0=r16;\t\t\t\t\\\n+\t;;\t\t\t\t\t\\\n+\tbr.ret.sptk b0;\t\t\t\t\\\n+\t;;\t\t\t\t\t\\\n+2:\t\t\t\t\t\t\\\n+\tmov ar.rsc=r0\t\t\t\t\\\n+\t;;\t\t\t\t\t\\\n+\tflushrs;\t\t\t\t\\\n+\t;;\t\t\t\t\t\\\n+\tmov ar.bspstore=r22\t\t\t\\\n+\t;;\t\t\t\t\t\\\n+\tmov r18=ar.bsp;\t\t\t\t\\\n+\t;;\t\t\t\t\t\\\n+1:\t\t\t\t\t\t\\\n+\t.pred.rel \"mutex\", pKStk, pUStk\n+\n+#define SAVE_MIN_WITH_COVER\tDO_SAVE_MIN(cover, mov r30=cr.ifs, , RSE_WORKAROUND)\n+#define SAVE_MIN_WITH_COVER_R19\tDO_SAVE_MIN(cover, mov r30=cr.ifs, mov r15=r19, RSE_WORKAROUND)\n+#define SAVE_MIN\t\t\tDO_SAVE_MIN(     , mov r30=r0, , )"
        },
        {
          "filename": "arch/ia64/kernel/patch.c",
          "status": "modified",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -115,6 +115,29 @@ ia64_patch_vtop (unsigned long start, unsigned long end)\n \tia64_srlz_i();\n }\n \n+/*\n+ * Disable the RSE workaround by turning the conditional branch\n+ * that we tagged in each place the workaround was used into an\n+ * unconditional branch.\n+ */\n+void __init\n+ia64_patch_rse (unsigned long start, unsigned long end)\n+{\n+\ts32 *offp = (s32 *) start;\n+\tu64 ip, *b;\n+\n+\twhile (offp < (s32 *) end) {\n+\t\tip = (u64) offp + *offp;\n+\n+\t\tb = (u64 *)(ip & -16);\n+\t\tb[1] &= ~0xf800000L;\n+\t\tia64_fc((void *) ip);\n+\t\t++offp;\n+\t}\n+\tia64_sync_i();\n+\tia64_srlz_i();\n+}\n+\n void __init\n ia64_patch_mckinley_e9 (unsigned long start, unsigned long end)\n {"
        },
        {
          "filename": "arch/ia64/kernel/setup.c",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -560,6 +560,17 @@ setup_arch (char **cmdline_p)\n \t/* process SAL system table: */\n \tia64_sal_init(__va(efi.sal_systab));\n \n+#ifdef CONFIG_ITANIUM\n+\tia64_patch_rse((u64) __start___rse_patchlist, (u64) __end___rse_patchlist);\n+#else\n+\t{\n+\t\tu64 num_phys_stacked;\n+\n+\t\tif (ia64_pal_rse_info(&num_phys_stacked, 0) == 0 && num_phys_stacked > 96)\n+\t\t\tia64_patch_rse((u64) __start___rse_patchlist, (u64) __end___rse_patchlist);\n+\t}\n+#endif\n+\n #ifdef CONFIG_SMP\n \tcpu_physical_id(0) = hard_smp_processor_id();\n #endif"
        },
        {
          "filename": "arch/ia64/kernel/vmlinux.lds.S",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -156,6 +156,13 @@ SECTIONS\n \t  __end___vtop_patchlist = .;\n \t}\n \n+  .data.patch.rse : AT(ADDR(.data.patch.rse) - LOAD_OFFSET)\n+\t{\n+\t  __start___rse_patchlist = .;\n+\t  *(.data.patch.rse)\n+\t  __end___rse_patchlist = .;\n+\t}\n+\n   .data.patch.mckinley_e9 : AT(ADDR(.data.patch.mckinley_e9) - LOAD_OFFSET)\n \t{\n \t  __start___mckinley_e9_bundles = .;"
        },
        {
          "filename": "include/asm-ia64/patch.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -21,6 +21,7 @@ extern void ia64_patch_imm60 (u64 insn_addr, u64 val);\t\t/* patch \"brl\" w/ip-rel\n extern void ia64_patch_mckinley_e9 (unsigned long start, unsigned long end);\n extern void ia64_patch_vtop (unsigned long start, unsigned long end);\n extern void ia64_patch_phys_stack_reg(unsigned long val);\n+extern void ia64_patch_rse (unsigned long start, unsigned long end);\n extern void ia64_patch_gate (void);\n \n #endif /* _ASM_IA64_PATCH_H */"
        },
        {
          "filename": "include/asm-ia64/ptrace.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -76,7 +76,7 @@\n # define KERNEL_STACK_SIZE_ORDER\t\t0\n #endif\n \n-#define IA64_RBS_OFFSET\t\t\t((IA64_TASK_SIZE + IA64_THREAD_INFO_SIZE + 15) & ~15)\n+#define IA64_RBS_OFFSET\t\t\t((IA64_TASK_SIZE + IA64_THREAD_INFO_SIZE + 31) & ~31)\n #define IA64_STK_OFFSET\t\t\t((1 << KERNEL_STACK_SIZE_ORDER)*PAGE_SIZE)\n \n #define KERNEL_STACK_SIZE\t\tIA64_STK_OFFSET"
        },
        {
          "filename": "include/asm-ia64/sections.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -10,6 +10,7 @@\n \n extern char __per_cpu_start[], __per_cpu_end[], __phys_per_cpu_start[];\n extern char __start___vtop_patchlist[], __end___vtop_patchlist[];\n+extern char __start___rse_patchlist[], __end___rse_patchlist[];\n extern char __start___mckinley_e9_bundles[], __end___mckinley_e9_bundles[];\n extern char __start___phys_stack_reg_patchlist[], __end___phys_stack_reg_patchlist[];\n extern char __start_gate_section[];"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "aa22f4da2a46b484a257d167c67a2adc1b7aaf68",
            "date": "2025-01-26T00:23:38Z",
            "author_login": "torvalds"
          },
          {
            "sha": "eda061cccd146fcbe71051bb4aa5a8672b71216e",
            "date": "2025-01-26T00:19:10Z",
            "author_login": "torvalds"
          },
          {
            "sha": "08de7f9d4d39fd9aa5e747a13acc891214fa2d5f",
            "date": "2025-01-26T00:12:07Z",
            "author_login": "torvalds"
          },
          {
            "sha": "647d69605c70368d54fc012fce8a43e8e5955b04",
            "date": "2025-01-26T00:03:40Z",
            "author_login": "torvalds"
          },
          {
            "sha": "184a0997fb77f4a9527fc867fcd16806776c27ce",
            "date": "2025-01-25T23:59:46Z",
            "author_login": "torvalds"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-119",
    "description": "The ia64 subsystem in the Linux kernel before 2.6.26 allows local users to cause a denial of service (stack consumption and system crash) via a crafted application that leverages the mishandling of invalid Register Stack Engine (RSE) state.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-08-07T03:29:00.197",
    "last_modified": "2024-11-21T00:14:04.857",
    "fix_date": "2008-05-27T20:23:16Z"
  },
  "references": [
    {
      "url": "http://ftp.naist.jp/pub/linux/kernel/v2.6/ChangeLog-2.6.26",
      "source": "secalert@redhat.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=4dcc29e1574d88f4465ba865ed82800032f76418",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://bugzilla.suse.com/show_bug.cgi?id=199440",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/4dcc29e1574d88f4465ba865ed82800032f76418",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://ftp.naist.jp/pub/linux/kernel/v2.6/ChangeLog-2.6.26",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=4dcc29e1574d88f4465ba865ed82800032f76418",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://bugzilla.suse.com/show_bug.cgi?id=199440",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/4dcc29e1574d88f4465ba865ed82800032f76418",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:05.090739",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "linux",
    "owner": "torvalds",
    "created_at": "2011-09-04T22:48:12Z",
    "updated_at": "2025-01-26T06:54:23Z",
    "pushed_at": "2025-01-26T01:00:03Z",
    "size": 5386838,
    "stars": 186472,
    "forks": 54875,
    "open_issues": 441,
    "watchers": 186472,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1331921668,
      "Assembly": 9611819,
      "Shell": 5108035,
      "Python": 2992085,
      "Makefile": 2706967,
      "Perl": 1253833,
      "Rust": 816450,
      "Roff": 202277,
      "C++": 173994,
      "SmPL": 165946,
      "Yacc": 127472,
      "Lex": 71397,
      "Awk": 69555,
      "Jinja": 30138,
      "UnrealScript": 16848,
      "Gherkin": 10902,
      "M4": 3329,
      "MATLAB": 2482,
      "Clojure": 2442,
      "sed": 2433,
      "XS": 1239,
      "RPC": 962
    },
    "commit_activity": {
      "total_commits_last_year": 48379,
      "avg_commits_per_week": 930.3653846153846,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T07:34:00.817711"
  }
}