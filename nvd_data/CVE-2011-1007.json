{
  "cve_id": "CVE-2011-1007",
  "github_data": {
    "repository": "bestpractical/rt",
    "fix_commit": "057552287159e801535e59b8fbd5bd98d1322069",
    "related_commits": [
      "057552287159e801535e59b8fbd5bd98d1322069",
      "917c211820590950f7eb0521f7f43b31aeed44c4",
      "057552287159e801535e59b8fbd5bd98d1322069",
      "917c211820590950f7eb0521f7f43b31aeed44c4"
    ],
    "patch_url": "https://github.com/bestpractical/rt/commit/057552287159e801535e59b8fbd5bd98d1322069.patch",
    "fix_commit_details": {
      "sha": "057552287159e801535e59b8fbd5bd98d1322069",
      "commit_date": "2010-10-27T14:42:35Z",
      "author": {
        "login": "tsibley",
        "type": "User",
        "stats": {
          "total_commits": 1682,
          "average_weekly_commits": 1.1886925795053003,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 164
        }
      },
      "commit_message": {
        "title": "Merge branch 'redirect-after-login' into 3.8-trunk",
        "length": 50,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 570,
        "additions": 484,
        "deletions": 86
      },
      "files": [
        {
          "filename": "lib/RT/Interface/Web.pm",
          "status": "modified",
          "additions": 172,
          "deletions": 21,
          "patch": "@@ -207,13 +207,29 @@ sub HandleRequest {\n     unless ( _UserLoggedIn() ) {\n         _ForceLogout();\n \n-        # If the user is logging in, let's authenticate\n-        if ( defined $ARGS->{user} && defined $ARGS->{pass} ) {\n-            AttemptPasswordAuthentication($ARGS);\n-        } else {\n-            # if no credentials then show him login page\n-            $HTML::Mason::Commands::m->comp( '/Elements/Login', %$ARGS );\n-            $HTML::Mason::Commands::m->abort;\n+        # Authenticate if the user is trying to login via user/pass query args\n+        my ($authed, $msg) = AttemptPasswordAuthentication($ARGS);\n+\n+        unless ($authed) {\n+            my $m = $HTML::Mason::Commands::m;\n+\n+            # REST urls get a special 401 response\n+            if ($m->request_comp->path =~ '^/REST/\\d+\\.\\d+/') {\n+                $HTML::Mason::Commands::r->content_type(\"text/plain\");\n+                $m->error_format(\"text\");\n+                $m->out(\"RT/$RT::VERSION 401 Credentials required\\n\");\n+                $m->out(\"\\n$msg\\n\") if $msg;\n+                $m->abort;\n+            }\n+            # Specially handle /index.html so that we get a nicer URL\n+            elsif ( $m->request_comp->path eq '/index.html' ) {\n+                my $next = SetNextPage(RT->Config->Get('WebURL'));\n+                $m->comp('/NoAuth/Login.html', next => $next, actions => [$msg]);\n+                $m->abort;\n+            }\n+            else {\n+                TangentForLogin(results => ($msg ? LoginError($msg) : undef));\n+            }\n         }\n     }\n \n@@ -245,6 +261,108 @@ sub _UserLoggedIn {\n \n }\n \n+=head2 LoginError ERROR\n+\n+Pushes a login error into the Actions session store and returns the hash key.\n+\n+=cut\n+\n+sub LoginError {\n+    my $new = shift;\n+    my $key = Digest::MD5::md5_hex( rand(1024) );\n+    push @{ $HTML::Mason::Commands::session{\"Actions\"}->{$key} ||= [] }, $new;\n+    $HTML::Mason::Commands::session{'i'}++;\n+    return $key;\n+}\n+\n+=head2 SetNextPage [PATH]\n+\n+Intuits and stashes the next page in the sesssion hash.  If PATH is\n+specified, uses that instead of the value of L<IntuitNextPage()>.  Returns\n+the hash value.\n+\n+=cut\n+\n+sub SetNextPage {\n+    my $next = shift || IntuitNextPage();\n+    my $hash = Digest::MD5::md5_hex($next . $$ . rand(1024));\n+\n+    $HTML::Mason::Commands::session{'NextPage'}->{$hash} = $next;\n+    $HTML::Mason::Commands::session{'i'}++;\n+    \n+    SendSessionCookie();\n+    return $hash;\n+}\n+\n+\n+=head2 TangentForLogin [HASH]\n+\n+Redirects to C</NoAuth/Login.html>, setting the value of L<IntuitNextPage> as\n+the next page.  Optionally takes a hash which is dumped into query params.\n+\n+=cut\n+\n+sub TangentForLogin {\n+    my $hash  = SetNextPage();\n+    my %query = (@_, next => $hash);\n+    my $login = RT->Config->Get('WebURL') . 'NoAuth/Login.html?';\n+    $login .= $HTML::Mason::Commands::m->comp('/Elements/QueryString', %query);\n+    Redirect($login);\n+}\n+\n+=head2 TangentForLoginWithError ERROR\n+\n+Localizes the passed error message, stashes it with L<LoginError> and then\n+calls L<TangentForLogin> with the appropriate results key.\n+\n+=cut\n+\n+sub TangentForLoginWithError {\n+    my $key = LoginError(HTML::Mason::Commands::loc(@_));\n+    TangentForLogin( results => $key );\n+}\n+\n+=head2 IntuitNextPage\n+\n+Attempt to figure out the path to which we should return the user after a\n+tangent.  The current request URL is used, or failing that, the C<WebURL>\n+configuration variable.\n+\n+=cut\n+\n+sub IntuitNextPage {\n+    my $req_uri;\n+\n+    # This includes any query parameters.  Redirect will take care of making\n+    # it an absolute URL.\n+    if ($ENV{'REQUEST_URI'}) {\n+        $req_uri = $ENV{'REQUEST_URI'};\n+\n+        # collapse multiple leading slashes so the first part doesn't look like\n+        # a hostname of a schema-less URI\n+        $req_uri =~ s{^/+}{/};\n+    }\n+\n+    my $next = defined $req_uri ? $req_uri : RT->Config->Get('WebURL');\n+\n+    # sanitize $next\n+    my $uri = URI->new($next);\n+\n+    # You get undef scheme with a relative uri like \"/Search/Build.html\"\n+    unless (!defined($uri->scheme) || $uri->scheme eq 'http' || $uri->scheme eq 'https') {\n+        $next = RT->Config->Get('WebURL');\n+    }\n+\n+    # Make sure we're logging in to the same domain\n+    # You can get an undef authority with a relative uri like \"index.html\"\n+    my $uri_base_url = URI->new(RT->Config->Get('WebBaseURL'));\n+    unless (!defined($uri->authority) || $uri->authority eq $uri_base_url->authority) {\n+        $next = RT->Config->Get('WebURL');\n+    }\n+\n+    return $next;\n+}\n+\n =head2 MaybeShowInstallModePage \n \n This function, called exclusively by RT's autohandler, dispatches\n@@ -284,6 +402,10 @@ sub MaybeShowNoAuthPage {\n \n     return unless $m->base_comp->path =~ RT->Config->Get('WebNoAuthRegex');\n \n+    # Don't show the login page to logged in users\n+    Redirect(RT->Config->Get('WebURL'))\n+        if $m->base_comp->path eq '/NoAuth/Login.html' and _UserLoggedIn();\n+\n     # If it's a noauth file, don't ask for auth.\n     SendSessionCookie();\n     $m->comp( { base_comp => $m->request_comp }, $m->fetch_next, %$ARGS );\n@@ -386,9 +508,12 @@ sub AttemptExternalAuth {\n \n                 # we failed to successfully create the user. abort abort abort.\n                 delete $HTML::Mason::Commands::session{'CurrentUser'};\n-                $m->comp( '/Elements/Login', %$ARGS, Error => HTML::Mason::Commands::loc( 'Cannot create user: [_1]', $msg ) )\n-                    if RT->Config->Get('WebFallbackToInternalAuth');;\n-                $m->abort();\n+\n+                if (RT->Config->Get('WebFallbackToInternalAuth')) {\n+                    TangentForLoginWithError('Cannot create user: [_1]', $msg);\n+                } else {\n+                    $m->abort();\n+                }\n             }\n         }\n \n@@ -399,15 +524,13 @@ sub AttemptExternalAuth {\n             $user = $orig_user;\n \n             if ( RT->Config->Get('WebExternalOnly') ) {\n-                $m->comp( '/Elements/Login', %$ARGS, Error => HTML::Mason::Commands::loc('You are not an authorized user') );\n-                $m->abort();\n+                TangentForLoginWithError('You are not an authorized user');\n             }\n         }\n     } elsif ( RT->Config->Get('WebFallbackToInternalAuth') ) {\n         unless ( defined $HTML::Mason::Commands::session{'CurrentUser'} ) {\n             # XXX unreachable due to prior defaulting in HandleRequest (check c34d108)\n-            $m->comp( '/Elements/Login', %$ARGS, Error => HTML::Mason::Commands::loc('You are not an authorized user') );\n-            $m->abort();\n+            TangentForLoginWithError('You are not an authorized user');\n         }\n     } else {\n \n@@ -420,23 +543,44 @@ sub AttemptExternalAuth {\n }\n \n sub AttemptPasswordAuthentication {\n-    my $ARGS     = shift;\n+    my $ARGS = shift;\n+    return unless defined $ARGS->{user} && defined $ARGS->{pass};\n+\n     my $user_obj = RT::CurrentUser->new();\n     $user_obj->Load( $ARGS->{user} );\n \n     my $m = $HTML::Mason::Commands::m;\n \n     unless ( $user_obj->id && $user_obj->IsPassword( $ARGS->{pass} ) ) {\n         $RT::Logger->error(\"FAILED LOGIN for @{[$ARGS->{user}]} from $ENV{'REMOTE_ADDR'}\");\n-        $m->comp( '/Elements/Login', %$ARGS, Error => HTML::Mason::Commands::loc('Your username or password is incorrect'), );\n         $m->callback( %$ARGS, CallbackName => 'FailedLogin', CallbackPage => '/autohandler' );\n-        $m->abort;\n+        return (0, HTML::Mason::Commands::loc('Your username or password is incorrect'));\n     }\n+    else {\n+        $RT::Logger->info(\"Successful login for @{[$ARGS->{user}]} from $ENV{'REMOTE_ADDR'}\");\n+\n+        # It's important to nab the next page from the session before we blow\n+        # the session away\n+        my $next = delete $HTML::Mason::Commands::session{'NextPage'}->{$ARGS->{'next'} || ''};\n \n-    $RT::Logger->info(\"Successful login for @{[$ARGS->{user}]} from $ENV{'REMOTE_ADDR'}\");\n-    InstantiateNewSession();\n-    $HTML::Mason::Commands::session{'CurrentUser'} = $user_obj;\n-    $m->callback( %$ARGS, CallbackName => 'SuccessfulLogin', CallbackPage => '/autohandler' );\n+        InstantiateNewSession();\n+        $HTML::Mason::Commands::session{'CurrentUser'} = $user_obj;\n+        SendSessionCookie();\n+\n+        $m->callback( %$ARGS, CallbackName => 'SuccessfulLogin', CallbackPage => '/autohandler' );\n+\n+        # Really the only time we don't want to redirect here is if we were\n+        # passed user and pass as query params in the URL.\n+        if ($next) {\n+            Redirect($next);\n+        }\n+        elsif ($ARGS->{'next'}) {\n+            # Invalid hash, but still wants to go somewhere, take them to /\n+            Redirect(RT->Config->Get('WebURL'));\n+        }\n+\n+        return (1, HTML::Mason::Commands::loc('Logged in'));\n+    }\n }\n \n =head2 LoadSessionFromCookie\n@@ -503,6 +647,13 @@ sub Redirect {\n     untie $HTML::Mason::Commands::session;\n     my $uri        = URI->new($redir_to);\n     my $server_uri = URI->new( RT->Config->Get('WebURL') );\n+    \n+    # Make relative URIs absolute from the server host and scheme\n+    $uri->scheme($server_uri->scheme) if not defined $uri->scheme;\n+    if (not defined $uri->host) {\n+        $uri->host($server_uri->host);\n+        $uri->port($server_uri->port);\n+    }\n \n     # If the user is coming in via a non-canonical\n     # hostname, don't redirect them to the canonical host,"
        },
        {
          "filename": "share/html/Elements/ListActions",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -46,7 +46,7 @@\n %# \n %# END BPS TAGGED BLOCK }}}\n <div class=\"results\">\n-<&| /Widgets/TitleBox, title => loc('Results') &>\n+<&| /Widgets/TitleBox, title => loc('Results'), %{$titlebox || {}} &>\n   <ul class=\"action-results\">\n % foreach my $action (@actions) {\n     <li><%$action%></li>\n@@ -90,5 +90,6 @@ return unless @actions;\n \n </%init>\n <%ARGS>\n+$titlebox => {}\n @actions => undef\n </%ARGS>"
        },
        {
          "filename": "share/html/Elements/Login",
          "status": "modified",
          "additions": 11,
          "deletions": 64,
          "patch": "@@ -45,42 +45,6 @@\n %# those contributions and any derivatives thereof.\n %# \n %# END BPS TAGGED BLOCK }}}\n-<%INIT>\n-if ($m->request_comp->path =~ '^/REST/\\d+\\.\\d+/') {\n-    $r->content_type(\"text/plain\");\n-    $m->error_format(\"text\");\n-    $m->out(\"RT/$RT::VERSION 401 Credentials required\\n\");\n-    $m->out(\"\\n$Error\\n\") if $Error;\n-    $m->abort;\n-}\n-\n-my $req_uri;\n-\n-if (UNIVERSAL::can($r, 'uri') and $r->uri =~ m{.*/(.*)}) {\n-    $req_uri = $1;\n-}\n-\n-my $form_action = defined $goto             ? $goto\n-                : defined $req_uri          ? $req_uri\n-                :                             RT->Config->Get('WebPath')\n-                ;\n-\n-# sanitize $form_action\n-my $uri = URI->new($form_action);\n-\n-# You get undef scheme with a relative uri like \"/Search/Build.html\"\n-unless (!defined($uri->scheme) || $uri->scheme eq 'http' || $uri->scheme eq 'https') {\n-    $form_action = RT->Config->Get('WebPath');\n-}\n-\n-# Make sure we're logging in to the same domain\n-# You can get an undef authority with a relative uri like \"index.html\"\n-my $uri_base_url = URI->new(RT->Config->Get('WebBaseURL'));\n-unless (!defined($uri->authority) || $uri->authority eq $uri_base_url->authority) {\n-    $form_action = RT->Config->Get('WebPath');\n-}\n-</%INIT>\n-\n % $m->callback( %ARGS, CallbackName => 'Header' );\n <& /Elements/Header, Title => loc('Login'), Focus => 'user' &>\n \n@@ -89,19 +53,20 @@ unless (!defined($uri->authority) || $uri->authority eq $uri_base_url->authority\n </div>\n \n <div id=\"body\" class=\"login-body\">\n-% if ($Error) {\n-<&| \"/Widgets/TitleBox\", title => loc('Error'), hideable => 0, class => 'error'  &>\n-<% $Error %>\n-</&>\n-% }\n+\n+<& /Elements/ListActions,\n+    title       => loc('Error'),\n+    titlebox    => { class => 'error', hideable => 0 },\n+    actions     => $actions\n+&>\n \n % $m->callback( %ARGS, CallbackName => 'BeforeForm' );\n \n <div id=\"login-box\">\n <&| /Widgets/TitleBox, title => loc('Login'), titleright => $RT::VERSION, hideable => 0 &>\n \n % unless (RT->Config->Get('WebExternalAuth') and !RT->Config->Get('WebFallbackToInternalAuth')) {\n-<form id=\"login\" name=\"login\" method=\"post\" action=\"<% $form_action %>\">\n+<form id=\"login\" name=\"login\" method=\"post\" action=\"<% RT->Config->Get('WebPath') %>/NoAuth/Login.html\">\n \n <div class=\"input-row\">\n     <span class=\"label\"><&|/l&>Username</&>:</span>\n@@ -113,32 +78,15 @@ unless (!defined($uri->authority) || $uri->authority eq $uri_base_url->authority\n     <span class=\"input\"><input type=\"password\" name=\"pass\" autocomplete=\"off\" /></span>\n </div>\n \n+<input type=\"hidden\" name=\"next\" value=\"<% $next %>\" />\n+\n <div class=\"button-row\">\n     <span class=\"input\"><input type=\"submit\" class=\"button\" value=\"<&|/l&>Login</&>\" /></span>\n </div>\n \n %# Give callbacks a chance to add more control elements\n % $m->callback( %ARGS );\n \n-% # From mason 1.0.1 forward, this doesn't work. in fact, it breaks things.\n-% # But on Mason 1.15 it's fixed again, so we still use it.\n-% # The code below iterates through everything in the passed in arguments\n-% # Preserving all the old parameters\n-% # This would be easier, except mason is 'smart' and calls multiple values\n-% # arrays rather than multiple hash keys\n-% my $key; my $val;\n-% foreach $key (keys %ARGS) {\n-%  if (($key ne 'user') and ($key ne 'pass')) {\n-% \tif (ref($ARGS{$key}) =~ /ARRAY/) {\n-% \t\tforeach $val (@{$ARGS{$key}}) {\n-<input type=\"hidden\" class=\"hidden\" name=\"<%$key %>\" value=\"<% $val %>\" />\n-% \t\t}\n-% \t}\n-%\telse {\n-<input type=\"hidden\" class=\"hidden\" name=\"<% $key %>\" value=\"<% $ARGS{$key} %>\" />\n-% \t}\n-%  }\n-% }\n </form>\n % }\n </&>\n@@ -147,8 +95,7 @@ unless (!defined($uri->authority) || $uri->authority eq $uri_base_url->authority\n </div><!-- #login-body -->\n <& /Elements/Footer, Menu => 0 &>\n <%ARGS>\n+$next => ''\n $user => \"\"\n-$pass => undef\n-$goto => undef\n-$Error => undef\n+$actions => undef\n </%ARGS>"
        },
        {
          "filename": "share/html/NoAuth/Login.html",
          "status": "added",
          "additions": 52,
          "deletions": 0,
          "patch": "@@ -0,0 +1,52 @@\n+%# BEGIN BPS TAGGED BLOCK {{{\n+%# \n+%# COPYRIGHT:\n+%# \n+%# This software is Copyright (c) 1996-2010 Best Practical Solutions, LLC\n+%#                                          <jesse@bestpractical.com>\n+%# \n+%# (Except where explicitly superseded by other copyright notices)\n+%# \n+%# \n+%# LICENSE:\n+%# \n+%# This work is made available to you under the terms of Version 2 of\n+%# the GNU General Public License. A copy of that license should have\n+%# been provided with this software, but in any event can be snarfed\n+%# from www.gnu.org.\n+%# \n+%# This work is distributed in the hope that it will be useful, but\n+%# WITHOUT ANY WARRANTY; without even the implied warranty of\n+%# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+%# General Public License for more details.\n+%# \n+%# You should have received a copy of the GNU General Public License\n+%# along with this program; if not, write to the Free Software\n+%# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+%# 02110-1301 or visit their web page on the internet at\n+%# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html.\n+%# \n+%# \n+%# CONTRIBUTION SUBMISSION POLICY:\n+%# \n+%# (The following paragraph is not intended to limit the rights granted\n+%# to you to modify and distribute this software under the terms of\n+%# the GNU General Public License and is only of importance to you if\n+%# you choose to contribute your changes and enhancements to the\n+%# community by submitting them to Best Practical Solutions, LLC.)\n+%# \n+%# By intentionally submitting any modifications, corrections or\n+%# derivatives to this work, or any other work intended for use with\n+%# Request Tracker, to Best Practical Solutions, LLC, you confirm that\n+%# you are the copyright holder for those contributions and you grant\n+%# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,\n+%# royalty-free, perpetual, license to use, copy, create derivative\n+%# works based on those contributions, and sublicense and distribute\n+%# those contributions and any derivatives thereof.\n+%# \n+%# END BPS TAGGED BLOCK }}}\n+<%init>\n+my ($good, $msg) = RT::Interface::Web::AttemptPasswordAuthentication(\\%ARGS);\n+$ARGS{'actions'} = [$msg] if not $good and $msg;\n+</%init>\n+<& /Elements/Login, %ARGS &>"
        },
        {
          "filename": "share/html/NoAuth/css/web2/login.css",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -45,6 +45,10 @@\n %# those contributions and any derivatives thereof.\n %# \n %# END BPS TAGGED BLOCK }}}\n+.login-body .action-results {\n+    list-style: none;\n+}\n+\n #login-box hr {\n  display: none;\n }"
        },
        {
          "filename": "t/web/redirect-after-login.t",
          "status": "added",
          "additions": 243,
          "deletions": 0,
          "patch": "@@ -0,0 +1,243 @@\n+#!/usr/bin/perl\n+\n+use strict;\n+use warnings;\n+\n+use RT::Test tests => 120;\n+\n+my ($baseurl, $agent) = RT::Test->started_ok;\n+\n+my $url = $agent->rt_base_url;\n+diag $url if $ENV{TEST_VERBOSE};\n+\n+# test a login from the main page\n+{\n+    $agent->get_ok($url);\n+    is($agent->{'status'}, 200, \"Loaded a page\");\n+    is($agent->uri, $url, \"didn't redirect to /NoAuth/Login.html for base URL\");\n+    ok($agent->current_form->find_input('user'));\n+    ok($agent->current_form->find_input('pass'));\n+    like($agent->current_form->action, qr{/NoAuth/Login\\.html$}, \"login form action is correct\");\n+\n+    ok($agent->content =~ /username:/i);\n+    $agent->field( 'user' => 'root' );\n+    $agent->field( 'pass' => 'password' );\n+\n+    # the field isn't named, so we have to click link 0\n+    $agent->click(0);\n+    is( $agent->status, 200, \"Fetched the page ok\");\n+    ok( $agent->content =~ /Logout/i, \"Found a logout link\");\n+    is( $agent->uri, $url, \"right URL\" );\n+    like( $agent->{redirected_uri}, qr{/NoAuth/Login\\.html$}, \"We redirected from login\");\n+    $agent->logout();\n+}\n+\n+# test a bogus login from the main page\n+{\n+    $agent->get_ok($url);\n+    is($agent->{'status'}, 200, \"Loaded a page\");\n+    is($agent->uri, $url, \"didn't redirect to /NoAuth/Login.html for base URL\");\n+    ok($agent->current_form->find_input('user'));\n+    ok($agent->current_form->find_input('pass'));\n+    like($agent->current_form->action, qr{/NoAuth/Login\\.html$}, \"login form action is correct\");\n+\n+    ok($agent->content =~ /username:/i);\n+    $agent->field( 'user' => 'root' );\n+    $agent->field( 'pass' => 'wrongpass' );\n+\n+    # the field isn't named, so we have to click link 0\n+    $agent->click(0);\n+    is( $agent->status, 200, \"Fetched the page ok\");\n+\n+    ok( $agent->content =~ /Your username or password is incorrect/i, \"Found the error message\");\n+    like( $agent->uri, qr{/NoAuth/Login\\.html$}, \"now on /NoAuth/Login.html\" );\n+    $agent->logout();\n+\n+    # Handle the warning after we're done with the page, since this leaves us\n+    # with a completely different $mech\n+    $agent->warning_like(qr/FAILED LOGIN for root/, \"got failed login warning\");\n+}\n+\n+# test a login from a non-front page, both with a double leading slash and without\n+for my $path (qw(Prefs/Other.html /Prefs/Other.html)) {\n+    my $requested = $url.$path;\n+    $agent->get_ok($requested);\n+    is($agent->status, 200, \"Loaded a page\");\n+    like($agent->uri, qr'/NoAuth/Login\\.html\\?next=[a-z0-9]{32}', \"on login page, with next page hash\");\n+    is($agent->{redirected_uri}, $requested, \"redirected from our requested page\");\n+\n+    ok($agent->current_form->find_input('user'));\n+    ok($agent->current_form->find_input('pass'));\n+    ok($agent->current_form->find_input('next'));\n+    like($agent->value('next'), qr/^[a-z0-9]{32}$/i, \"next page argument is a hash\");\n+    like($agent->current_form->action, qr{/NoAuth/Login\\.html$}, \"login form action is correct\");\n+\n+    ok($agent->content =~ /username:/i);\n+    $agent->field( 'user' => 'root' );\n+    $agent->field( 'pass' => 'password' );\n+\n+    # the field isn't named, so we have to click link 0\n+    $agent->click(0);\n+    is( $agent->status, 200, \"Fetched the page ok\");\n+    ok( $agent->content =~ /Logout/i, \"Found a logout link\");\n+\n+    if ($path =~ m{/}) {\n+        (my $collapsed = $path) =~ s{^/}{};\n+        is( $agent->uri, $url.$collapsed, \"right URL, with leading slashes in path collapsed\" );\n+    } else {\n+        is( $agent->uri, $requested, \"right URL\" );\n+    }\n+\n+    like( $agent->{redirected_uri}, qr{/NoAuth/Login\\.html}, \"We redirected from login\");\n+    $agent->logout();\n+}\n+\n+# test a bogus login from a non-front page\n+{\n+    my $requested = $url.'Prefs/Other.html';\n+    $agent->get_ok($requested);\n+    is($agent->status, 200, \"Loaded a page\");\n+    like($agent->uri, qr'/NoAuth/Login\\.html\\?next=[a-z0-9]{32}', \"on login page, with next page hash\");\n+    is($agent->{redirected_uri}, $requested, \"redirected from our requested page\");\n+\n+    ok($agent->current_form->find_input('user'));\n+    ok($agent->current_form->find_input('pass'));\n+    ok($agent->current_form->find_input('next'));\n+    like($agent->value('next'), qr/^[a-z0-9]{32}$/i, \"next page argument is a hash\");\n+    like($agent->current_form->action, qr{/NoAuth/Login\\.html$}, \"login form action is correct\");\n+\n+    ok($agent->content =~ /username:/i);\n+    $agent->field( 'user' => 'root' );\n+    $agent->field( 'pass' => 'wrongpass' );\n+\n+    # the field isn't named, so we have to click link 0\n+    $agent->click(0);\n+    is( $agent->status, 200, \"Fetched the page ok\");\n+\n+    ok( $agent->content =~ /Your username or password is incorrect/i, \"Found the error message\");\n+    like( $agent->uri, qr{/NoAuth/Login\\.html$}, \"still on /NoAuth/Login.html\" );\n+\n+    # try to login again\n+    ok($agent->current_form->find_input('user'));\n+    ok($agent->current_form->find_input('pass'));\n+    ok($agent->current_form->find_input('next'));\n+    like($agent->value('next'), qr/^[a-z0-9]{32}$/i, \"next page argument is a hash\");\n+    like($agent->current_form->action, qr{/NoAuth/Login\\.html$}, \"login form action is correct\");\n+\n+    ok($agent->content =~ /username:/i);\n+    $agent->field( 'user' => 'root' );\n+    $agent->field( 'pass' => 'password' );\n+\n+    # the field isn't named, so we have to click link 0\n+    $agent->click(0);\n+    is( $agent->status, 200, \"Fetched the page ok\");\n+\n+    # check out where we got to\n+    is( $agent->uri, $requested, \"right URL\" );\n+    like( $agent->{redirected_uri}, qr{/NoAuth/Login\\.html}, \"We redirected from login\");\n+    $agent->logout();\n+\n+    # Handle the warning after we're done with the page, since this leaves us\n+    # with a completely different $mech\n+    $agent->warning_like(qr/FAILED LOGIN for root/, \"got failed login warning\");\n+}\n+\n+# test a login from the main page with query params\n+{\n+    my $requested = $url.\"?user=root;pass=password\";\n+    $agent->get_ok($requested);\n+    is($agent->{'status'}, 200, \"Loaded a page\");\n+    is($agent->uri, $requested, \"didn't redirect to /NoAuth/Login.html for base URL\");\n+    ok($agent->content =~ /Logout/i, \"Found a logout link - we're logged in\");\n+    $agent->logout();\n+}\n+\n+# test a bogus login from the main page with query params\n+{\n+    my $requested = $url.\"?user=root;pass=wrongpass\";\n+    $agent->get_ok($requested);\n+    is($agent->{'status'}, 200, \"Loaded a page\");\n+    is($agent->uri, $requested, \"didn't redirect to /NoAuth/Login.html for base URL\");\n+    \n+    ok($agent->content =~ /Your username or password is incorrect/i, \"Found the error message\");\n+    ok($agent->current_form->find_input('user'));\n+    ok($agent->current_form->find_input('pass'));\n+    like($agent->current_form->action, qr{/NoAuth/Login\\.html$}, \"login form action is correct\");\n+    \n+    # Handle the warning after we're done with the page, since this leaves us\n+    # with a completely different $mech\n+    $agent->warning_like(qr/FAILED LOGIN for root/, \"got failed login warning\");\n+}\n+\n+# test a bogus login from a non-front page with query params\n+{\n+    my $requested = $url.\"Prefs/Other.html?user=root;pass=wrongpass\";\n+    $agent->get_ok($requested);\n+    is($agent->status, 200, \"Loaded a page\");\n+    like($agent->uri, qr'/NoAuth/Login\\.html\\?next=[a-z0-9]{32}', \"on login page, with next page hash\");\n+    is($agent->{redirected_uri}, $requested, \"redirected from our requested page\");\n+    ok( $agent->content =~ /Your username or password is incorrect/i, \"Found the error message\");\n+\n+    ok($agent->current_form->find_input('user'));\n+    ok($agent->current_form->find_input('pass'));\n+    ok($agent->current_form->find_input('next'));\n+    like($agent->value('next'), qr/^[a-z0-9]{32}$/i, \"next page argument is a hash\");\n+    like($agent->current_form->action, qr{/NoAuth/Login\\.html$}, \"login form action is correct\");\n+\n+    # Try to login again\n+    ok($agent->content =~ /username:/i);\n+    $agent->field( 'user' => 'root' );\n+    $agent->field( 'pass' => 'password' );\n+\n+    # the field isn't named, so we have to click link 0\n+    $agent->click(0);\n+    is( $agent->status, 200, \"Fetched the page ok\");\n+\n+    # check out where we got to\n+    is( $agent->uri, $requested, \"right URL\" );\n+    like( $agent->{redirected_uri}, qr{/NoAuth/Login\\.html}, \"We redirected from login\");\n+    $agent->logout();\n+\n+    # Handle the warning after we're done with the page, since this leaves us\n+    # with a completely different $mech\n+    $agent->warning_like(qr/FAILED LOGIN for root/, \"got failed login warning\");\n+}\n+\n+# test REST login response\n+{\n+    my $requested = $url.\"REST/1.0/?user=root;pass=password\";\n+    $agent->get($requested);\n+    is($agent->status, 200, \"Loaded a page\");\n+    is($agent->uri, $requested, \"didn't redirect to /NoAuth/Login.html for REST\");\n+    $agent->get_ok($url);\n+    $agent->logout();\n+}\n+\n+# test REST login response for wrong pass\n+{\n+    my $requested = $url.\"REST/1.0/?user=root;pass=passwrong\";\n+    $agent->get_ok($requested);\n+    is($agent->status, 200, \"Loaded a page\");\n+    is($agent->uri, $requested, \"didn't redirect to /NoAuth/Login.html for REST\");\n+    like($agent->content, qr/401 Credentials required/i, \"got error status\");\n+    like($agent->content, qr/Your username or password is incorrect/, \"got error message\");\n+    \n+    # Handle the warning after we're done with the page, since this leaves us\n+    # with a completely different $mech\n+    $agent->warning_like(qr/FAILED LOGIN for root/, \"got failed login warning\");\n+}\n+\n+# test REST login response for no creds\n+{\n+    my $requested = $url.\"REST/1.0/\";\n+    $agent->get_ok($requested);\n+    is($agent->status, 200, \"Loaded a page\");\n+    is($agent->uri, $requested, \"didn't redirect to /NoAuth/Login.html for REST\");\n+    like($agent->content, qr/401 Credentials required/i, \"got error status\");\n+    unlike($agent->content, qr/Your username or password is incorrect/, \"didn't get any error message\");\n+}\n+\n+# XXX TODO: we should also be testing WebExternalAuth here, but we don't have\n+# the framework for dealing with that\n+\n+1;"
        }
      ],
      "file_patterns": {
        "security_files": 2,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 5,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "30355a8f862e8ebe50f0276c8889f3048cbd0ec3",
            "date": "2024-12-30T21:30:14Z",
            "author_login": "sunnavy"
          },
          {
            "sha": "9bf0c0cdb738ca59edd2bec43df2fa0935af3d67",
            "date": "2024-12-30T20:32:12Z",
            "author_login": "sunnavy"
          },
          {
            "sha": "d18adc562072957a9381d7fb914dd7c8c70266d4",
            "date": "2024-12-17T20:24:35Z",
            "author_login": "mzagrabe"
          },
          {
            "sha": "aa29fd19b1e722f90c611861a7f611ff5d07ccf2",
            "date": "2024-12-11T15:30:03Z",
            "author_login": "sunnavy"
          },
          {
            "sha": "309c8fa94302d0bf2c26f2d16052f5483353ff19",
            "date": "2024-12-10T22:31:18Z",
            "author_login": "sunnavy"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-255",
    "description": "Best Practical Solutions RT before 3.8.9 does not perform certain redirect actions upon a login, which allows physically proximate attackers to obtain credentials by resubmitting the login form via the back button of a web browser on an unattended workstation after an RT logout.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2011-02-28T16:00:01.603",
    "last_modified": "2024-11-21T01:25:18.983",
    "fix_date": "2010-10-27T14:42:35Z"
  },
  "references": [
    {
      "url": "http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=614575",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://issues.bestpractical.com/Ticket/Display.html?id=15804",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://lists.bestpractical.com/pipermail/rt-announce/2011-February/000186.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://openwall.com/lists/oss-security/2011/02/22/12",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://openwall.com/lists/oss-security/2011/02/22/16",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://openwall.com/lists/oss-security/2011/02/22/6",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://openwall.com/lists/oss-security/2011/02/23/22",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://openwall.com/lists/oss-security/2011/02/24/7",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://openwall.com/lists/oss-security/2011/02/24/8",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://openwall.com/lists/oss-security/2011/02/24/9",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://osvdb.org/71012",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://secunia.com/advisories/43438",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.vupen.com/english/advisories/2011/0475",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/65771",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://github.com/bestpractical/rt/commit/057552287159e801535e59b8fbd5bd98d1322069",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/bestpractical/rt/commit/917c211820590950f7eb0521f7f43b31aeed44c4",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://lists.apache.org/thread.html/rf9fa47ab66495c78bb4120b0754dd9531ca2ff0430f6685ac9b07772%40%3Cdev.mina.apache.org%3E",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=614575",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://issues.bestpractical.com/Ticket/Display.html?id=15804",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.bestpractical.com/pipermail/rt-announce/2011-February/000186.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://openwall.com/lists/oss-security/2011/02/22/12",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://openwall.com/lists/oss-security/2011/02/22/16",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://openwall.com/lists/oss-security/2011/02/22/6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://openwall.com/lists/oss-security/2011/02/23/22",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://openwall.com/lists/oss-security/2011/02/24/7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://openwall.com/lists/oss-security/2011/02/24/8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://openwall.com/lists/oss-security/2011/02/24/9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://osvdb.org/71012",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://secunia.com/advisories/43438",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.vupen.com/english/advisories/2011/0475",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/65771",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/bestpractical/rt/commit/057552287159e801535e59b8fbd5bd98d1322069",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/bestpractical/rt/commit/917c211820590950f7eb0521f7f43b31aeed44c4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://lists.apache.org/thread.html/rf9fa47ab66495c78bb4120b0754dd9531ca2ff0430f6685ac9b07772%40%3Cdev.mina.apache.org%3E",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:57:57.485661",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "rt",
    "owner": "bestpractical",
    "created_at": "2009-07-07T19:57:15Z",
    "updated_at": "2025-01-12T12:18:23Z",
    "pushed_at": "2025-01-14T13:45:07Z",
    "size": 185702,
    "stars": 972,
    "forks": 263,
    "open_issues": 106,
    "watchers": 972,
    "has_security_policy": false,
    "default_branch": "stable",
    "protected_branches": [],
    "languages": {
      "Perl": 6752414,
      "HTML": 1102188,
      "CSS": 175980,
      "JavaScript": 158500,
      "SCSS": 75563,
      "Shell": 22302,
      "Makefile": 20169,
      "M4": 18470,
      "Roff": 5095,
      "Dockerfile": 383
    },
    "commit_activity": {
      "total_commits_last_year": 221,
      "avg_commits_per_week": 4.25,
      "days_active_last_year": 104
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T14:47:38.690001"
  }
}