{
  "cve_id": "CVE-2011-3177",
  "github_data": {
    "repository": "yast/yast-core",
    "fix_commit": "7fe2e3df308b8b6a901cb2cfd60f398df53219de",
    "related_commits": [
      "7fe2e3df308b8b6a901cb2cfd60f398df53219de",
      "7fe2e3df308b8b6a901cb2cfd60f398df53219de"
    ],
    "patch_url": "https://github.com/yast/yast-core/commit/7fe2e3df308b8b6a901cb2cfd60f398df53219de.patch",
    "fix_commit_details": {
      "sha": "7fe2e3df308b8b6a901cb2cfd60f398df53219de",
      "commit_date": "2012-01-05T17:03:40Z",
      "author": {
        "login": "mvidner",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "- ini-agent: added Write(.section_private.SECTION, BOOLEAN) (bnc#713661, CVE-2011-3177)",
        "length": 295,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 281,
        "additions": 239,
        "deletions": 42
      },
      "files": [
        {
          "filename": "VERSION",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1 +1 @@\n-2.22.0\n+2.22.1"
        },
        {
          "filename": "agent-ini/doc/ag_ini.html",
          "status": "modified",
          "additions": 10,
          "deletions": 3,
          "patch": "@@ -280,7 +280,7 @@ <h4 id=\"params\">Params:</h4>\n <p>Then begin regexp is: ([^=]+)=\"([^\"]*) and end regexp is\n ([^\"]\"). These are compared at the end so they are the last\n possibility. But once we get into this \"divided line\" by accident,\n-it becomes greedy, so be carefull to forgotten \". If \"multiline\" is\n+it becomes greedy, so be carefull to forgotten &quot;. If \"multiline\" is\n not present, this mechanism does not take in effect of course.</p>\n \n <p>See also the option <a\n@@ -473,7 +473,7 @@ <h3 id=\"sysconfig\">Configuration file for sysconfig files (former rc files)</h3>\n         \"comments\": [ \"^[ \\t]*#.*$\", \"#.*\", \"^[ \\t]*$\", ],\n         \"params\" : [\n             $[\n-                \"match\" : [ \"([a-zA-Z0-9_]+)[ \\t]*=[ \\t]*\\\"([^\\\"]*)\\\"\", \"%s=\\\"%s\\\"\" ],\n+                \"match\" : [ \"([a-zA-Z0-9_]+)[ \\t]*=[ \\t]*\\\"([^\\&quot;]*)\\\"\", \"%s=\\\"%s\\\"\" ],\n                 \"multiline\" : [ \"([a-zA-Z0-9_]+)[ \\t]*=[ \\t]*\\\"([^\\\"]*)\", \"([^\\\"]*)\\\"\", ],\n             ],\n             $[\n@@ -533,6 +533,13 @@ <h3 id=\"access\">Accessing keys</h3>\n section was read by.</td>\n </tr>\n \n+<tr>\n+<td>\n+<tt>.ini.section_private.<i>sectionname</i></tt></td>\n+<td>a boolean write-only property for sections corresponding to files.\n+If true, the file will not be readable by group and others.</td>\n+</tr>\n+\n <tr class=\"notimpl\">\n <td>\n <tt>.ini.section_file.<i>sectionname</i>.<i>sectionname</i></tt></td>\n@@ -694,7 +701,7 @@ <h3 id=\"ex.providers\">Dialup providers (package providers)</h3>\n       ],\n       \"params\" : [\n         $[\n-        \"match\" : [ \"^[ \\t]*([^=]*[^ \\t=])[ \\t]*=[ \\t]*(.*[^ \\t]|)[ \\t]*$\" , \"%s =       ],\n+        \"match\" : [ \"^[ \\t]*([^=]*[^ \\t=])[ \\t]*=[ \\t]*(.*[^ \\t]|)[ \\t]*$\" , \"%s = %s\"   ],\n     ],\n     ]\n   )"
        },
        {
          "filename": "agent-ini/src/IniAgent.cc",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -98,7 +98,7 @@ YCPBoolean IniAgent::Write(const YCPPath &path, const YCPValue& value, const YCP\n     else\n     {\n \tif (( parser.repeatNames () && value->isList ()) ||\n-\t    (!parser.repeatNames () &&  (value->isString () || value->isInteger())) ||\n+\t    (!parser.repeatNames () &&  (value->isString () || value->isBoolean() || value->isInteger())) ||\n \t    path->component_str(0) == \"all\"\n \t    )\n \t    {"
        },
        {
          "filename": "agent-ini/src/IniFile.cc",
          "status": "modified",
          "additions": 23,
          "deletions": 1,
          "patch": "@@ -75,6 +75,19 @@ YCPInteger as_integer (const YCPValue& v, const char * context)\n     return YCPNull ();\n }\n \n+/**\n+ * Return the YCPBoolean or YCPNull if it is not one. Log an error.\n+ */\n+static\n+YCPBoolean as_boolean (const YCPValue& v, const char * context)\n+{\n+    if (v->isBoolean ())\n+\treturn v->asBoolean ();\n+    ycp2error (\"Expected a boolean for %s, got %s %s\",\n+\t       context, v->valuetype_str(), v->toString().c_str());\n+    return YCPNull ();\n+}\n+\n void IniSection::initValue (const string&key,const string&val,const string&comment,int rb)\n {\n     string k = ip->changeCase (key);\n@@ -486,6 +499,9 @@ int IniSection::Write (const YCPPath&p, const YCPValue&v, bool rewrite)\n       return setSectionProp (p, v, 0, 1);\n     if (s == \"st\" || s == \"section_type\" || s == \"sectiontype\")\n       return setSectionProp (p, v, rewrite? 1:2, 1);\n+    if (s == \"section_private\")\n+      return setSectionProp (p, v, 3, 1);\n+\n     return -1;\n }\n \n@@ -591,12 +607,18 @@ int IniSection::setSectionProp (const YCPPath&p,const YCPValue&in, int what, int\n \t\t\treturn -1;\n \t\t    s.setRewriteBy (i->value());\n \t\t}\n-\t\telse {\n+\t\telse if (what == 2) {\n \t\t    YCPInteger i = as_integer (prop, \"section_type\");\n \t\t    if (i.isNull())\n \t\t\treturn -1;\n \t\t    s.setReadBy (i->value());\n \t\t}\n+\t\telse if (what == 3) {\n+\t\t    YCPBoolean b = as_boolean (prop, \"section_private\");\n+\t\t    if (b.isNull())\n+\t\t\treturn -1;\n+\t\t    s.setPrivate (b->value());\n+\t\t}\n \n \t\tif (xi != xe)\n \t\t{"
        },
        {
          "filename": "agent-ini/src/IniFile.h",
          "status": "modified",
          "additions": 16,
          "deletions": 4,
          "patch": "@@ -241,6 +241,13 @@ class IniSection : public IniBase\n      */\n     string end_comment;\n \n+    /**\n+     * It is effective only when the section corresponds to a file.\n+     * The file will not be readable by group and others.\n+     * bnc#713661\n+     */\n+    bool is_private;\n+\n     /** index to IniParser::rewrites for filename - section name mapping\n      * It appears that read_by was used for both purposes,\n      * causing bug (#19066).\n@@ -435,7 +442,7 @@ class IniSection : public IniBase\n     IniSection (const IniParser *p)\n \t: IniBase (-1),\n \t  ip (p),\n-\t  end_comment (), rewrite_by(-1),\n+\t  end_comment (), is_private(false), rewrite_by(-1),\n \t  container (), ivalues (), isections ()\n \t    {}\n \n@@ -446,7 +453,7 @@ class IniSection : public IniBase\n     IniSection (const IniSection &s) :\n \tIniBase (s),\n \t  ip (s.ip),\n-\t  end_comment (s.end_comment), rewrite_by (s.rewrite_by),\n+          end_comment (s.end_comment), is_private(s.is_private), rewrite_by (s.rewrite_by),\n \t  container (s.container)\n \t{ reindex (); }\n \n@@ -458,7 +465,9 @@ class IniSection : public IniBase\n \t    } \n \t    IniBase::operator = (s);\n \t    ip = s.ip;\n-\t    end_comment = s.end_comment; rewrite_by = s.rewrite_by;\n+\t    end_comment = s.end_comment;\n+            is_private = s.is_private;\n+            rewrite_by = s.rewrite_by;\n \t    container = s.container;\n \n \t    reindex ();\n@@ -474,7 +483,7 @@ class IniSection : public IniBase\n     IniSection (const IniParser *p, string n)\n \t: IniBase (n),\n \t  ip (p),\n-\t  end_comment (), rewrite_by(0),\n+\t  end_comment (), is_private(false), rewrite_by(0),\n \t  container(), ivalues (), isections ()\n \t    {}\n     /**\n@@ -511,6 +520,9 @@ class IniSection : public IniBase\n      */\n     int getSubSectionRewriteBy (const char*name);\n \n+    void setPrivate(bool p) { is_private = p; }\n+    bool isPrivate() const { return is_private; }\n+\n     /** \n      * If there is no comment at the beginning and no values and no\n      * sections, it is better to set is as comment at the beginning."
        },
        {
          "filename": "agent-ini/src/IniParser.cc",
          "status": "modified",
          "additions": 28,
          "deletions": 27,
          "patch": "@@ -965,19 +965,7 @@ int IniParser::write()\n \t\t\t    continue;\n \t\t\t}\n \t\t\ts.initReadBy ();\n-\t\t\t// ensure that the directories exist\n-\t\t\tPathname pn (filename);\n-\t\t\tPathInfo::assert_dir (pn.dirname ());\n-\t\t\tofstream of(filename.c_str());\n-\t\t\tif (!of.good())\n-\t\t\t{\n-\t\t\t    bugs++;\n-\t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n-\t\t\t    continue;\n-\t\t\t}\n-\t\t\twrite_helper (s, of, 0);\n-\t\t\ts.clean();\n-\t\t\tof.close ();\n+                        bugs += write_file(filename, s);\n \t\t    }\n \t\telse\n \t\t    {\n@@ -997,24 +985,37 @@ int IniParser::write()\n     }\n     else\n     {\n-\t// ensure that the directories exist\n-\tPathname pn (file);\n-\tPathInfo::assert_dir (pn.dirname ());\n-\tofstream of(file.c_str());\n-\tif (!of.good())\n-\t{\n-\t    y2error (\"Can not open file %s for write\", file.c_str());\n-\t    return -1;\n-\t}\n-\n-\twrite_helper (inifile, of, 0);\n-\n-\tof.close();\n+        bugs += write_file(file, inifile);\n \ttimestamp = getTimeStamp ();\n     }\n-    inifile.clean ();\n     return bugs ? -1 : 0;\n }\n+\n+// return 0 on success, like write\n+int IniParser::write_file(const string & filename, IniSection & section)\n+{\n+    // ensure that the directories exist\n+    Pathname pn(filename);\n+    PathInfo::assert_dir (pn.dirname ());\n+\n+    mode_t file_umask = section.isPrivate()? 0077: 0022;\n+    mode_t orig_umask = umask(file_umask);\n+    // rewriting an existing file wouldnt change its mode\n+    unlink(filename.c_str());\n+\n+    ofstream of(filename.c_str());\n+    if (!of.good()) {\n+        y2error (\"Can not open file %s for write\", filename.c_str());\n+        return -1;\n+    }\n+\n+    write_helper (section, of, 0);\n+\n+    of.close();\n+    umask(orig_umask);\n+    return 0;\n+}\n+\n int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n {\n     char * out_buffer;"
        },
        {
          "filename": "agent-ini/src/IniParser.h",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -369,6 +369,10 @@ class IniParser\n      * Parse one ini file and build a structure of IniSection.\n      */\n     int parse_helper(IniSection&ini);\n+    /**\n+     * Write one ini file.\n+     */\n+    int write_file(const string & filename, IniSection & section);\n     /**\n      * Write one ini file.\n      */"
        },
        {
          "filename": "agent-ini/testsuite/multi/private.err",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+[agent-ini] IniParser.cc(parse):XXX Rewriting multi/private.in.1.test to 1\n+[agent-ini] IniParser.cc(parse):XXX Rewriting multi/private.in.2.test to 2\n+[agent-ini] IniFile.cc(setMyValue):XXX Adding value .v.\"1\".\"Totalise\".\"Password\" = \"Secret password\"\n+[agent-ini] IniFile.cc(setMyValue):XXX Adding value .v.\"2\".\"arcor\".\"Password\" = \"Public password\"\n+[agent-ini] IniParser.cc(parse):XXX Rewriting multi/private.in.1.test to 1\n+[agent-ini] IniParser.cc(parse):XXX Rewriting multi/private.in.2.test to 2\n+[agent-ini] IniParser.cc(getFileName):XXX Rewriting 1 to multi/private.in.1.test\n+[agent-ini] IniParser.cc(getFileName):XXX Rewriting 2 to multi/private.in.2.test\n+[YCP] multi/private.ycp:XXX secret file mode: $[\"exit\":0, \"stderr\":\"\", \"stdout\":\"600\\n\"]\n+[YCP] multi/private.ycp:XXX public file mode: $[\"exit\":0, \"stderr\":\"\", \"stdout\":\"644\\n\"]\n+[agent-ini] IniParser.cc(write):XXX File multi/private.in.*.test did not change. Not saving."
        },
        {
          "filename": "agent-ini/testsuite/multi/private.in.1",
          "status": "added",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -0,0 +1,10 @@\n+[Dialer Totalise]\n+Compuserve = 0\n+Provider = Totalise\n+Phone = 08453001470\n+[End]\n+\n+[Dialer force9]\n+Provider = Force9\n+Phone = 08451424000\n+[End]"
        },
        {
          "filename": "agent-ini/testsuite/multi/private.in.2",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+[Dialer arcor]\n+Compuserve = 0\n+Provider = Arcor\n+[End]\n+\n+[Dialer mobilcom]\n+Compuserve = 0\n+Provider = Mobilcom\n+Phone = 0101901929\n+[End]\n+"
        },
        {
          "filename": "agent-ini/testsuite/multi/private.out",
          "status": "added",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -0,0 +1,25 @@\n+(nil)\n+multi/private.in.1.test  -------------------------------\n+[Dialer Totalise]\n+  Compuserve = 0\n+  Provider = Totalise\n+  Phone = 08453001470\n+  Password = Secret password\n+[End]\n+\n+[Dialer force9]\n+  Provider = Force9\n+  Phone = 08451424000\n+[End]\n+multi/private.in.2.test  -------------------------------\n+[Dialer arcor]\n+  Compuserve = 0\n+  Provider = Arcor\n+  Password = Public password\n+[End]\n+\n+[Dialer mobilcom]\n+  Compuserve = 0\n+  Provider = Mobilcom\n+  Phone = 0101901929\n+[End]"
        },
        {
          "filename": "agent-ini/testsuite/multi/private.scr",
          "status": "added",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -0,0 +1,24 @@\n+.\n+\n+`ag_ini(\n+  `IniAgent( [ \"multi/private.in.*.test\" ],\n+    $[\n+      \"rewrite\" : [\n+\t[ \"multi/private\\.in\\.(.)\\.test$\", \"multi/private.in.%s.test\"],\n+      ],\n+      \"subindent\" : \"  \",\n+      \"comments\": [ \"^[ \\t]*#.*\", \"^[ \\t]*$\" ],\n+      \"sections\" : [\n+        $[\n+        \"begin\" : [ \"[ \\t]*\\\\[Dialer[ \\t]+(.*[^ \\t])[ \\t]*\\\\][ \\t]*\", \"[Dialer %s]\" ],\n+\t\"end\" : [ \"^[ \\t]*\\\\[End\\\\][ \\t]*$\", \"[End]\", ],\n+        ],\n+      ],\n+      \"params\" : [\n+        $[\n+        \"match\" : [ \"^[ \\t]*([^=]*[^ \\t=])[ \\t]*=[ \\t]*(.*[^ \\t]|)[ \\t]*$\" , \"%s = %s\"],\n+      ],\n+    ],\n+    ]\n+  )\n+)"
        },
        {
          "filename": "agent-ini/testsuite/multi/private.ycp",
          "status": "added",
          "additions": 26,
          "deletions": 0,
          "patch": "@@ -0,0 +1,26 @@\n+//\n+// Multiple files test\n+//\n+// providers.rpm\n+//\n+\n+\n+{\n+    SCR::RegisterAgent (.target, `ag_system ());\n+    any out = nil;\n+\n+    SCR::Write (.v.\"1\".\"Totalise\".\"Password\", \"Secret password\");\n+    SCR::Write (.section_private.\"1\", true);\n+\n+    SCR::Write (.v.\"2\".\"arcor\".\"Password\", \"Public password\");\n+\n+    SCR::Write (., nil); //flush\n+\n+    out = SCR::Execute (.target.bash_output, \"stat -c %a multi/private.in.1.test\");\n+    y2milestone(\"secret file mode: %1\", out);\n+\n+    out = SCR::Execute (.target.bash_output, \"stat -c %a multi/private.in.2.test\");\n+    y2milestone(\"public file mode: %1\", out);\n+\n+    return nil;\n+}"
        },
        {
          "filename": "agent-system/src/SystemAgent.cc",
          "status": "modified",
          "additions": 30,
          "deletions": 5,
          "patch": "@@ -709,25 +709,50 @@ SystemAgent::Write (const YCPPath& path, const YCPValue& value,\n     {\n \t/**\n \t * @builtin Write (.target.string, string filename, string value) -> boolean\n+\t * @builtin Write (.target.string, [string filename, integer filemode] , string value) -> boolean\n \t * Writes the string <tt>value</tt> into a file. If the file already\n \t * exists, the existing file is overwritten. The return value is\n \t * true, if the file has been written successfully.\n+         *\n+         * @example Write(.target.string, \"/etc/papersize\", \"a4\") -> true\n+         * @example Write(.target.string, [\"/etc/rsyncd.secrets\", 0600], \"user:passwd\") -> true\n \t */\n \n-\tif (value.isNull() || !value->isString())\n+\tif (value.isNull() || !(value->isString() || value->isList()))\n \t{\n \t    ycp2error (\"Bad filename arg for Write (.string ...)\");\n \t    return YCPBoolean (false);\n \t}\n \n+\tstring filename;\n+\tmode_t filemode = 0644;\n+\n+\tif (value->isString())\n+\t{\n+\t    filename = value->asString()->value();\n+\t}\n+\telse\n+\t{\t\t\t// value is list\n+\t    YCPList flist = value->asList();\n+\t    if ((flist->size() != 2)\n+\t\t|| (!flist->value(0)->isString())\n+\t\t|| (!flist->value(1)->isInteger()))\n+\t    {\n+\t\tycp2error (\"Bad [filename, mode] list in call to Write (%s, [ string filename, integer mode ], ...)\",\n+\t\t    cmd.c_str ());\n+\t\treturn YCPBoolean (false);\n+\t    }\n+\t    filename = flist->value(0)->asString()->value();\n+\t    filemode = (int)(flist->value(1)->asInteger()->value());\n+\t}\n+\n \tif (arg.isNull() || !arg->isString())\n \t{\n \t    ycp2error (\"Bad string value for Write (.string ...)\");\n \t    return YCPBoolean (false);\n \t}\n \n-\tstring filename = value->asString()->value();\n-\tint fd = open(filename.c_str(), O_WRONLY | O_CREAT | O_TRUNC, 0644);\n+\tint fd = open(filename.c_str(), O_WRONLY | O_CREAT | O_TRUNC, filemode);\n \tif (fd >= 0)\n \t{\n \t    string cont = arg->asString()->value();\n@@ -1039,8 +1064,8 @@ SystemAgent::Execute (const YCPPath& path, const YCPValue& value,\n \t * Creates a symbolic link named newpath which contains the\n \t * string oldpath.\n \t *\n-\t * Symbolic links are interpreted at run-time as if the  con\ufffd\n-\t * tents of the link had been substituted into the path being\n+\t * Symbolic links are interpreted at run-time as if the contents\n+\t * of the link had been substituted into the path being\n \t * followed to find a file or directory.\n \t *\n \t * The return value is true or false, depending of the success."
        },
        {
          "filename": "agent-system/testsuite/tests/string.out",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -3,3 +3,4 @@\n (true)\n (nil)\n (\"never mind\")\n+(\"secret file mode: 600\\n\")"
        },
        {
          "filename": "agent-system/testsuite/tests/string.ycp",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -24,3 +24,13 @@\n     // this must not produce a error in the log\n     return SCR::Read (.string, [\"not-here.txt\", \"never mind\"]);\n }\n+\n+{\n+    map out = nil;\n+    string filename = \"tmp.secret.string\";\n+\n+    SCR::Write (.string, [filename, 0600], \"This is secret\\n\");\n+\n+    out = (map) SCR::Execute (.bash_output, \"stat -c %a \" + filename);\n+    return \"secret file mode: \" + out[\"stdout\"]:\"\";\n+}"
        },
        {
          "filename": "package/yast2-core.changes",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -1,3 +1,11 @@\n+-------------------------------------------------------------------\n+Mon Nov  7 18:19:27 CET 2011 - mvidner@suse.cz\n+\n+- ini-agent: added Write(.section_private.SECTION, BOOLEAN)\n+  (bnc#713661, CVE-2011-3177)\n+- system agent: added  Write(.target.string, [filename, mode], content)\n+- 2.22.1\n+\n -------------------------------------------------------------------\n Fri Dec  2 11:49:56 UTC 2011 - lslezak@suse.cz\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 8,
        "unique_directories": 7,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "a16fc0bb0271d7067790e76d6962ab826a05f4f3",
            "date": "2024-09-13T08:11:33Z",
            "author_login": "lslezak"
          },
          {
            "sha": "edb75ec66e2e85e8f607ecec4c81613da8f21b53",
            "date": "2024-09-13T08:11:31Z",
            "author_login": "lslezak"
          },
          {
            "sha": "e9f082f29b7c2b1502a0ba7cab195580cbda84f7",
            "date": "2024-09-12T11:52:41Z",
            "author_login": "lslezak"
          },
          {
            "sha": "5590151d414abd48f3b44e0b7dbadb949344d827",
            "date": "2024-09-05T13:56:44Z",
            "author_login": "lslezak"
          },
          {
            "sha": "1395929d71f25dfec3eddcd4940e3c42350ed946",
            "date": "2024-09-05T13:56:34Z",
            "author_login": "lslezak"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-200",
    "description": "The YaST2 network created files with world readable permissions which could have allowed local users to read sensitive material out of network configuration files, like passwords for wireless networks.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-09-08T18:29:00.220",
    "last_modified": "2024-11-21T01:29:54.690",
    "fix_date": "2012-01-05T17:03:40Z"
  },
  "references": [
    {
      "url": "https://bugzilla.suse.com/show_bug.cgi?id=713661",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/yast/yast-core/commit/7fe2e3df308b8b6a901cb2cfd60f398df53219de",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.suse.com/show_bug.cgi?id=713661",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/yast/yast-core/commit/7fe2e3df308b8b6a901cb2cfd60f398df53219de",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:07.347778",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "yast-core",
    "owner": "yast",
    "created_at": "2012-05-18T10:23:03Z",
    "updated_at": "2024-09-13T08:11:38Z",
    "pushed_at": "2024-09-13T08:11:46Z",
    "size": 24919,
    "stars": 22,
    "forks": 18,
    "open_issues": 2,
    "watchers": 22,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "Code-11-SP1",
      "Code-11-SP2",
      "Code-11-SP3",
      "Code-11",
      "SLE-10-SP1",
      "SLE-10-SP2",
      "SLE-10-SP3",
      "SLE-10-SP4",
      "SLE-12-GA",
      "SLE-12-SP1",
      "SLE-12-SP2",
      "SLE-12-SP3",
      "SLE-12-SP4",
      "SLE-12-SP5",
      "SLE-15-GA",
      "SLE-15-SP1",
      "SLE-15-SP2",
      "SLE-15-SP3",
      "SLE-15-SP4",
      "SLE-15-SP5",
      "SLE-15-SP6",
      "SLE-15-SP7",
      "master",
      "openSUSE-9_3",
      "openSUSE-10_0"
    ],
    "languages": {
      "C++": 1755537,
      "HTML": 130684,
      "Perl": 75482,
      "Makefile": 41691,
      "Ruby": 21982,
      "C": 14621,
      "Roff": 13637,
      "Shell": 12596,
      "CSS": 3924,
      "XSLT": 3864,
      "Emacs Lisp": 185,
      "NASL": 133
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T15:03:54.688508"
  }
}