{
  "cve_id": "CVE-2011-3188",
  "github_data": {
    "repository": "torvalds/linux",
    "fix_commit": "6e5714eaf77d79ae1c8b47e3e040ff5411b717ec",
    "related_commits": [
      "6e5714eaf77d79ae1c8b47e3e040ff5411b717ec",
      "bc0b96b54a21246e377122d54569eef71cec535f",
      "6e5714eaf77d79ae1c8b47e3e040ff5411b717ec",
      "bc0b96b54a21246e377122d54569eef71cec535f"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "6e5714eaf77d79ae1c8b47e3e040ff5411b717ec",
      "commit_date": "2011-08-04T03:50:44Z",
      "author": {
        "login": "davem330",
        "type": "User",
        "stats": {
          "total_commits": 14689,
          "average_weekly_commits": 12.333333333333334,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 940
        }
      },
      "commit_message": {
        "title": "net: Compute protocol sequence numbers and fragment IDs using MD5.",
        "length": 795,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 584,
        "additions": 223,
        "deletions": 361
      },
      "files": [
        {
          "filename": "drivers/char/random.c",
          "status": "modified",
          "additions": 8,
          "deletions": 341,
          "patch": "@@ -1300,363 +1300,30 @@ ctl_table random_table[] = {\n };\n #endif \t/* CONFIG_SYSCTL */\n \n-/********************************************************************\n- *\n- * Random functions for networking\n- *\n- ********************************************************************/\n-\n-/*\n- * TCP initial sequence number picking.  This uses the random number\n- * generator to pick an initial secret value.  This value is hashed\n- * along with the TCP endpoint information to provide a unique\n- * starting point for each pair of TCP endpoints.  This defeats\n- * attacks which rely on guessing the initial TCP sequence number.\n- * This algorithm was suggested by Steve Bellovin.\n- *\n- * Using a very strong hash was taking an appreciable amount of the total\n- * TCP connection establishment time, so this is a weaker hash,\n- * compensated for by changing the secret periodically.\n- */\n-\n-/* F, G and H are basic MD4 functions: selection, majority, parity */\n-#define F(x, y, z) ((z) ^ ((x) & ((y) ^ (z))))\n-#define G(x, y, z) (((x) & (y)) + (((x) ^ (y)) & (z)))\n-#define H(x, y, z) ((x) ^ (y) ^ (z))\n-\n-/*\n- * The generic round function.  The application is so specific that\n- * we don't bother protecting all the arguments with parens, as is generally\n- * good macro practice, in favor of extra legibility.\n- * Rotation is separate from addition to prevent recomputation\n- */\n-#define ROUND(f, a, b, c, d, x, s)\t\\\n-\t(a += f(b, c, d) + x, a = (a << s) | (a >> (32 - s)))\n-#define K1 0\n-#define K2 013240474631UL\n-#define K3 015666365641UL\n-\n-#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n-\n-static __u32 twothirdsMD4Transform(__u32 const buf[4], __u32 const in[12])\n-{\n-\t__u32 a = buf[0], b = buf[1], c = buf[2], d = buf[3];\n-\n-\t/* Round 1 */\n-\tROUND(F, a, b, c, d, in[ 0] + K1,  3);\n-\tROUND(F, d, a, b, c, in[ 1] + K1,  7);\n-\tROUND(F, c, d, a, b, in[ 2] + K1, 11);\n-\tROUND(F, b, c, d, a, in[ 3] + K1, 19);\n-\tROUND(F, a, b, c, d, in[ 4] + K1,  3);\n-\tROUND(F, d, a, b, c, in[ 5] + K1,  7);\n-\tROUND(F, c, d, a, b, in[ 6] + K1, 11);\n-\tROUND(F, b, c, d, a, in[ 7] + K1, 19);\n-\tROUND(F, a, b, c, d, in[ 8] + K1,  3);\n-\tROUND(F, d, a, b, c, in[ 9] + K1,  7);\n-\tROUND(F, c, d, a, b, in[10] + K1, 11);\n-\tROUND(F, b, c, d, a, in[11] + K1, 19);\n-\n-\t/* Round 2 */\n-\tROUND(G, a, b, c, d, in[ 1] + K2,  3);\n-\tROUND(G, d, a, b, c, in[ 3] + K2,  5);\n-\tROUND(G, c, d, a, b, in[ 5] + K2,  9);\n-\tROUND(G, b, c, d, a, in[ 7] + K2, 13);\n-\tROUND(G, a, b, c, d, in[ 9] + K2,  3);\n-\tROUND(G, d, a, b, c, in[11] + K2,  5);\n-\tROUND(G, c, d, a, b, in[ 0] + K2,  9);\n-\tROUND(G, b, c, d, a, in[ 2] + K2, 13);\n-\tROUND(G, a, b, c, d, in[ 4] + K2,  3);\n-\tROUND(G, d, a, b, c, in[ 6] + K2,  5);\n-\tROUND(G, c, d, a, b, in[ 8] + K2,  9);\n-\tROUND(G, b, c, d, a, in[10] + K2, 13);\n-\n-\t/* Round 3 */\n-\tROUND(H, a, b, c, d, in[ 3] + K3,  3);\n-\tROUND(H, d, a, b, c, in[ 7] + K3,  9);\n-\tROUND(H, c, d, a, b, in[11] + K3, 11);\n-\tROUND(H, b, c, d, a, in[ 2] + K3, 15);\n-\tROUND(H, a, b, c, d, in[ 6] + K3,  3);\n-\tROUND(H, d, a, b, c, in[10] + K3,  9);\n-\tROUND(H, c, d, a, b, in[ 1] + K3, 11);\n-\tROUND(H, b, c, d, a, in[ 5] + K3, 15);\n-\tROUND(H, a, b, c, d, in[ 9] + K3,  3);\n-\tROUND(H, d, a, b, c, in[ 0] + K3,  9);\n-\tROUND(H, c, d, a, b, in[ 4] + K3, 11);\n-\tROUND(H, b, c, d, a, in[ 8] + K3, 15);\n-\n-\treturn buf[1] + b; /* \"most hashed\" word */\n-\t/* Alternative: return sum of all words? */\n-}\n-#endif\n-\n-#undef ROUND\n-#undef F\n-#undef G\n-#undef H\n-#undef K1\n-#undef K2\n-#undef K3\n-\n-/* This should not be decreased so low that ISNs wrap too fast. */\n-#define REKEY_INTERVAL (300 * HZ)\n-/*\n- * Bit layout of the tcp sequence numbers (before adding current time):\n- * bit 24-31: increased after every key exchange\n- * bit 0-23: hash(source,dest)\n- *\n- * The implementation is similar to the algorithm described\n- * in the Appendix of RFC 1185, except that\n- * - it uses a 1 MHz clock instead of a 250 kHz clock\n- * - it performs a rekey every 5 minutes, which is equivalent\n- * \tto a (source,dest) tulple dependent forward jump of the\n- * \tclock by 0..2^(HASH_BITS+1)\n- *\n- * Thus the average ISN wraparound time is 68 minutes instead of\n- * 4.55 hours.\n- *\n- * SMP cleanup and lock avoidance with poor man's RCU.\n- * \t\t\tManfred Spraul <manfred@colorfullife.com>\n- *\n- */\n-#define COUNT_BITS 8\n-#define COUNT_MASK ((1 << COUNT_BITS) - 1)\n-#define HASH_BITS 24\n-#define HASH_MASK ((1 << HASH_BITS) - 1)\n+static u32 random_int_secret[MD5_MESSAGE_BYTES / 4] ____cacheline_aligned;\n \n-static struct keydata {\n-\t__u32 count; /* already shifted to the final position */\n-\t__u32 secret[12];\n-} ____cacheline_aligned ip_keydata[2];\n-\n-static unsigned int ip_cnt;\n-\n-static void rekey_seq_generator(struct work_struct *work);\n-\n-static DECLARE_DELAYED_WORK(rekey_work, rekey_seq_generator);\n-\n-/*\n- * Lock avoidance:\n- * The ISN generation runs lockless - it's just a hash over random data.\n- * State changes happen every 5 minutes when the random key is replaced.\n- * Synchronization is performed by having two copies of the hash function\n- * state and rekey_seq_generator always updates the inactive copy.\n- * The copy is then activated by updating ip_cnt.\n- * The implementation breaks down if someone blocks the thread\n- * that processes SYN requests for more than 5 minutes. Should never\n- * happen, and even if that happens only a not perfectly compliant\n- * ISN is generated, nothing fatal.\n- */\n-static void rekey_seq_generator(struct work_struct *work)\n+static int __init random_int_secret_init(void)\n {\n-\tstruct keydata *keyptr = &ip_keydata[1 ^ (ip_cnt & 1)];\n-\n-\tget_random_bytes(keyptr->secret, sizeof(keyptr->secret));\n-\tkeyptr->count = (ip_cnt & COUNT_MASK) << HASH_BITS;\n-\tsmp_wmb();\n-\tip_cnt++;\n-\tschedule_delayed_work(&rekey_work,\n-\t\t\t      round_jiffies_relative(REKEY_INTERVAL));\n-}\n-\n-static inline struct keydata *get_keyptr(void)\n-{\n-\tstruct keydata *keyptr = &ip_keydata[ip_cnt & 1];\n-\n-\tsmp_rmb();\n-\n-\treturn keyptr;\n-}\n-\n-static __init int seqgen_init(void)\n-{\n-\trekey_seq_generator(NULL);\n+\tget_random_bytes(random_int_secret, sizeof(random_int_secret));\n \treturn 0;\n }\n-late_initcall(seqgen_init);\n-\n-#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n-__u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n-\t\t\t\t   __be16 sport, __be16 dport)\n-{\n-\t__u32 seq;\n-\t__u32 hash[12];\n-\tstruct keydata *keyptr = get_keyptr();\n-\n-\t/* The procedure is the same as for IPv4, but addresses are longer.\n-\t * Thus we must use twothirdsMD4Transform.\n-\t */\n-\n-\tmemcpy(hash, saddr, 16);\n-\thash[4] = ((__force u16)sport << 16) + (__force u16)dport;\n-\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n-\n-\tseq = twothirdsMD4Transform((const __u32 *)daddr, hash) & HASH_MASK;\n-\tseq += keyptr->count;\n-\n-\tseq += ktime_to_ns(ktime_get_real());\n-\n-\treturn seq;\n-}\n-EXPORT_SYMBOL(secure_tcpv6_sequence_number);\n-#endif\n-\n-/*  The code below is shamelessly stolen from secure_tcp_sequence_number().\n- *  All blames to Andrey V. Savochkin <saw@msu.ru>.\n- */\n-__u32 secure_ip_id(__be32 daddr)\n-{\n-\tstruct keydata *keyptr;\n-\t__u32 hash[4];\n-\n-\tkeyptr = get_keyptr();\n-\n-\t/*\n-\t *  Pick a unique starting offset for each IP destination.\n-\t *  The dest ip address is placed in the starting vector,\n-\t *  which is then hashed with random data.\n-\t */\n-\thash[0] = (__force __u32)daddr;\n-\thash[1] = keyptr->secret[9];\n-\thash[2] = keyptr->secret[10];\n-\thash[3] = keyptr->secret[11];\n-\n-\treturn half_md4_transform(hash, keyptr->secret);\n-}\n-\n-__u32 secure_ipv6_id(const __be32 daddr[4])\n-{\n-\tconst struct keydata *keyptr;\n-\t__u32 hash[4];\n-\n-\tkeyptr = get_keyptr();\n-\n-\thash[0] = (__force __u32)daddr[0];\n-\thash[1] = (__force __u32)daddr[1];\n-\thash[2] = (__force __u32)daddr[2];\n-\thash[3] = (__force __u32)daddr[3];\n-\n-\treturn half_md4_transform(hash, keyptr->secret);\n-}\n-\n-#ifdef CONFIG_INET\n-\n-__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,\n-\t\t\t\t __be16 sport, __be16 dport)\n-{\n-\t__u32 seq;\n-\t__u32 hash[4];\n-\tstruct keydata *keyptr = get_keyptr();\n-\n-\t/*\n-\t *  Pick a unique starting offset for each TCP connection endpoints\n-\t *  (saddr, daddr, sport, dport).\n-\t *  Note that the words are placed into the starting vector, which is\n-\t *  then mixed with a partial MD4 over random data.\n-\t */\n-\thash[0] = (__force u32)saddr;\n-\thash[1] = (__force u32)daddr;\n-\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n-\thash[3] = keyptr->secret[11];\n-\n-\tseq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;\n-\tseq += keyptr->count;\n-\t/*\n-\t *\tAs close as possible to RFC 793, which\n-\t *\tsuggests using a 250 kHz clock.\n-\t *\tFurther reading shows this assumes 2 Mb/s networks.\n-\t *\tFor 10 Mb/s Ethernet, a 1 MHz clock is appropriate.\n-\t *\tFor 10 Gb/s Ethernet, a 1 GHz clock should be ok, but\n-\t *\twe also need to limit the resolution so that the u32 seq\n-\t *\toverlaps less than one time per MSL (2 minutes).\n-\t *\tChoosing a clock of 64 ns period is OK. (period of 274 s)\n-\t */\n-\tseq += ktime_to_ns(ktime_get_real()) >> 6;\n-\n-\treturn seq;\n-}\n-\n-/* Generate secure starting point for ephemeral IPV4 transport port search */\n-u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)\n-{\n-\tstruct keydata *keyptr = get_keyptr();\n-\tu32 hash[4];\n-\n-\t/*\n-\t *  Pick a unique starting offset for each ephemeral port search\n-\t *  (saddr, daddr, dport) and 48bits of random data.\n-\t */\n-\thash[0] = (__force u32)saddr;\n-\thash[1] = (__force u32)daddr;\n-\thash[2] = (__force u32)dport ^ keyptr->secret[10];\n-\thash[3] = keyptr->secret[11];\n-\n-\treturn half_md4_transform(hash, keyptr->secret);\n-}\n-EXPORT_SYMBOL_GPL(secure_ipv4_port_ephemeral);\n-\n-#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n-u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n-\t\t\t       __be16 dport)\n-{\n-\tstruct keydata *keyptr = get_keyptr();\n-\tu32 hash[12];\n-\n-\tmemcpy(hash, saddr, 16);\n-\thash[4] = (__force u32)dport;\n-\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n-\n-\treturn twothirdsMD4Transform((const __u32 *)daddr, hash);\n-}\n-#endif\n-\n-#if defined(CONFIG_IP_DCCP) || defined(CONFIG_IP_DCCP_MODULE)\n-/* Similar to secure_tcp_sequence_number but generate a 48 bit value\n- * bit's 32-47 increase every key exchange\n- *       0-31  hash(source, dest)\n- */\n-u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n-\t\t\t\t__be16 sport, __be16 dport)\n-{\n-\tu64 seq;\n-\t__u32 hash[4];\n-\tstruct keydata *keyptr = get_keyptr();\n-\n-\thash[0] = (__force u32)saddr;\n-\thash[1] = (__force u32)daddr;\n-\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n-\thash[3] = keyptr->secret[11];\n-\n-\tseq = half_md4_transform(hash, keyptr->secret);\n-\tseq |= ((u64)keyptr->count) << (32 - HASH_BITS);\n-\n-\tseq += ktime_to_ns(ktime_get_real());\n-\tseq &= (1ull << 48) - 1;\n-\n-\treturn seq;\n-}\n-EXPORT_SYMBOL(secure_dccp_sequence_number);\n-#endif\n-\n-#endif /* CONFIG_INET */\n-\n+late_initcall(random_int_secret_init);\n \n /*\n  * Get a random word for internal kernel use only. Similar to urandom but\n  * with the goal of minimal entropy pool depletion. As a result, the random\n  * value is not cryptographically secure but for several uses the cost of\n  * depleting entropy is too high\n  */\n-DEFINE_PER_CPU(__u32 [4], get_random_int_hash);\n+DEFINE_PER_CPU(__u32 [MD5_DIGEST_WORDS], get_random_int_hash);\n unsigned int get_random_int(void)\n {\n-\tstruct keydata *keyptr;\n \t__u32 *hash = get_cpu_var(get_random_int_hash);\n-\tint ret;\n+\tunsigned int ret;\n \n-\tkeyptr = get_keyptr();\n \thash[0] += current->pid + jiffies + get_cycles();\n-\n-\tret = half_md4_transform(hash, keyptr->secret);\n+\tmd5_transform(hash, random_int_secret);\n+\tret = hash[0];\n \tput_cpu_var(get_random_int_hash);\n \n \treturn ret;"
        },
        {
          "filename": "include/linux/random.h",
          "status": "modified",
          "additions": 0,
          "deletions": 12,
          "patch": "@@ -57,18 +57,6 @@ extern void add_interrupt_randomness(int irq);\n extern void get_random_bytes(void *buf, int nbytes);\n void generate_random_uuid(unsigned char uuid_out[16]);\n \n-extern __u32 secure_ip_id(__be32 daddr);\n-extern __u32 secure_ipv6_id(const __be32 daddr[4]);\n-extern u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport);\n-extern u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n-\t\t\t\t      __be16 dport);\n-extern __u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,\n-\t\t\t\t\t__be16 sport, __be16 dport);\n-extern __u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n-\t\t\t\t\t  __be16 sport, __be16 dport);\n-extern u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n-\t\t\t\t       __be16 sport, __be16 dport);\n-\n #ifndef MODULE\n extern const struct file_operations random_fops, urandom_fops;\n #endif"
        },
        {
          "filename": "include/net/secure_seq.h",
          "status": "added",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -0,0 +1,20 @@\n+#ifndef _NET_SECURE_SEQ\n+#define _NET_SECURE_SEQ\n+\n+#include <linux/types.h>\n+\n+extern __u32 secure_ip_id(__be32 daddr);\n+extern __u32 secure_ipv6_id(const __be32 daddr[4]);\n+extern u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport);\n+extern u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n+\t\t\t\t      __be16 dport);\n+extern __u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,\n+\t\t\t\t\t__be16 sport, __be16 dport);\n+extern __u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n+\t\t\t\t\t  __be16 sport, __be16 dport);\n+extern u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n+\t\t\t\t       __be16 sport, __be16 dport);\n+extern u64 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n+\t\t\t\t\t __be16 sport, __be16 dport);\n+\n+#endif /* _NET_SECURE_SEQ */"
        },
        {
          "filename": "net/core/Makefile",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -3,7 +3,7 @@\n #\n \n obj-y := sock.o request_sock.o skbuff.o iovec.o datagram.o stream.o scm.o \\\n-\t gen_stats.o gen_estimator.o net_namespace.o\n+\t gen_stats.o gen_estimator.o net_namespace.o secure_seq.o\n \n obj-$(CONFIG_SYSCTL) += sysctl_net_core.o\n "
        },
        {
          "filename": "net/core/secure_seq.c",
          "status": "added",
          "additions": 184,
          "deletions": 0,
          "patch": "@@ -0,0 +1,184 @@\n+#include <linux/kernel.h>\n+#include <linux/init.h>\n+#include <linux/cryptohash.h>\n+#include <linux/module.h>\n+#include <linux/cache.h>\n+#include <linux/random.h>\n+#include <linux/hrtimer.h>\n+#include <linux/ktime.h>\n+#include <linux/string.h>\n+\n+#include <net/secure_seq.h>\n+\n+static u32 net_secret[MD5_MESSAGE_BYTES / 4] ____cacheline_aligned;\n+\n+static int __init net_secret_init(void)\n+{\n+\tget_random_bytes(net_secret, sizeof(net_secret));\n+\treturn 0;\n+}\n+late_initcall(net_secret_init);\n+\n+static u32 seq_scale(u32 seq)\n+{\n+\t/*\n+\t *\tAs close as possible to RFC 793, which\n+\t *\tsuggests using a 250 kHz clock.\n+\t *\tFurther reading shows this assumes 2 Mb/s networks.\n+\t *\tFor 10 Mb/s Ethernet, a 1 MHz clock is appropriate.\n+\t *\tFor 10 Gb/s Ethernet, a 1 GHz clock should be ok, but\n+\t *\twe also need to limit the resolution so that the u32 seq\n+\t *\toverlaps less than one time per MSL (2 minutes).\n+\t *\tChoosing a clock of 64 ns period is OK. (period of 274 s)\n+\t */\n+\treturn seq + (ktime_to_ns(ktime_get_real()) >> 6);\n+}\n+\n+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n+__u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n+\t\t\t\t   __be16 sport, __be16 dport)\n+{\n+\tu32 secret[MD5_MESSAGE_BYTES / 4];\n+\tu32 hash[MD5_DIGEST_WORDS];\n+\tu32 i;\n+\n+\tmemcpy(hash, saddr, 16);\n+\tfor (i = 0; i < 4; i++)\n+\t\tsecret[i] = net_secret[i] + daddr[i];\n+\tsecret[4] = net_secret[4] +\n+\t\t(((__force u16)sport << 16) + (__force u16)dport);\n+\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n+\t\tsecret[i] = net_secret[i];\n+\n+\tmd5_transform(hash, secret);\n+\n+\treturn seq_scale(hash[0]);\n+}\n+EXPORT_SYMBOL(secure_tcpv6_sequence_number);\n+\n+u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n+\t\t\t       __be16 dport)\n+{\n+\tu32 secret[MD5_MESSAGE_BYTES / 4];\n+\tu32 hash[MD5_DIGEST_WORDS];\n+\tu32 i;\n+\n+\tmemcpy(hash, saddr, 16);\n+\tfor (i = 0; i < 4; i++)\n+\t\tsecret[i] = net_secret[i] + (__force u32) daddr[i];\n+\tsecret[4] = net_secret[4] + (__force u32)dport;\n+\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n+\t\tsecret[i] = net_secret[i];\n+\n+\tmd5_transform(hash, secret);\n+\n+\treturn hash[0];\n+}\n+#endif\n+\n+#ifdef CONFIG_INET\n+__u32 secure_ip_id(__be32 daddr)\n+{\n+\tu32 hash[MD5_DIGEST_WORDS];\n+\n+\thash[0] = (__force __u32) daddr;\n+\thash[1] = net_secret[13];\n+\thash[2] = net_secret[14];\n+\thash[3] = net_secret[15];\n+\n+\tmd5_transform(hash, net_secret);\n+\n+\treturn hash[0];\n+}\n+\n+__u32 secure_ipv6_id(const __be32 daddr[4])\n+{\n+\t__u32 hash[4];\n+\n+\tmemcpy(hash, daddr, 16);\n+\tmd5_transform(hash, net_secret);\n+\n+\treturn hash[0];\n+}\n+\n+__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,\n+\t\t\t\t __be16 sport, __be16 dport)\n+{\n+\tu32 hash[MD5_DIGEST_WORDS];\n+\n+\thash[0] = (__force u32)saddr;\n+\thash[1] = (__force u32)daddr;\n+\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n+\thash[3] = net_secret[15];\n+\n+\tmd5_transform(hash, net_secret);\n+\n+\treturn seq_scale(hash[0]);\n+}\n+\n+u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)\n+{\n+\tu32 hash[MD5_DIGEST_WORDS];\n+\n+\thash[0] = (__force u32)saddr;\n+\thash[1] = (__force u32)daddr;\n+\thash[2] = (__force u32)dport ^ net_secret[14];\n+\thash[3] = net_secret[15];\n+\n+\tmd5_transform(hash, net_secret);\n+\n+\treturn hash[0];\n+}\n+EXPORT_SYMBOL_GPL(secure_ipv4_port_ephemeral);\n+#endif\n+\n+#if defined(CONFIG_IP_DCCP) || defined(CONFIG_IP_DCCP_MODULE)\n+u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n+\t\t\t\t__be16 sport, __be16 dport)\n+{\n+\tu32 hash[MD5_DIGEST_WORDS];\n+\tu64 seq;\n+\n+\thash[0] = (__force u32)saddr;\n+\thash[1] = (__force u32)daddr;\n+\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n+\thash[3] = net_secret[15];\n+\n+\tmd5_transform(hash, net_secret);\n+\n+\tseq = hash[0] | (((u64)hash[1]) << 32);\n+\tseq += ktime_to_ns(ktime_get_real());\n+\tseq &= (1ull << 48) - 1;\n+\n+\treturn seq;\n+}\n+EXPORT_SYMBOL(secure_dccp_sequence_number);\n+\n+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n+u64 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n+\t\t\t\t  __be16 sport, __be16 dport)\n+{\n+\tu32 secret[MD5_MESSAGE_BYTES / 4];\n+\tu32 hash[MD5_DIGEST_WORDS];\n+\tu64 seq;\n+\tu32 i;\n+\n+\tmemcpy(hash, saddr, 16);\n+\tfor (i = 0; i < 4; i++)\n+\t\tsecret[i] = net_secret[i] + daddr[i];\n+\tsecret[4] = net_secret[4] +\n+\t\t(((__force u16)sport << 16) + (__force u16)dport);\n+\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n+\t\tsecret[i] = net_secret[i];\n+\n+\tmd5_transform(hash, secret);\n+\n+\tseq = hash[0] | (((u64)hash[1]) << 32);\n+\tseq += ktime_to_ns(ktime_get_real());\n+\tseq &= (1ull << 48) - 1;\n+\n+\treturn seq;\n+}\n+EXPORT_SYMBOL(secure_dccpv6_sequence_number);\n+#endif\n+#endif"
        },
        {
          "filename": "net/dccp/ipv4.c",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -26,6 +26,7 @@\n #include <net/timewait_sock.h>\n #include <net/tcp_states.h>\n #include <net/xfrm.h>\n+#include <net/secure_seq.h>\n \n #include \"ackvec.h\"\n #include \"ccid.h\""
        },
        {
          "filename": "net/dccp/ipv6.c",
          "status": "modified",
          "additions": 2,
          "deletions": 7,
          "patch": "@@ -29,6 +29,7 @@\n #include <net/transp_v6.h>\n #include <net/ip6_checksum.h>\n #include <net/xfrm.h>\n+#include <net/secure_seq.h>\n \n #include \"dccp.h\"\n #include \"ipv6.h\"\n@@ -69,13 +70,7 @@ static inline void dccp_v6_send_check(struct sock *sk, struct sk_buff *skb)\n \tdh->dccph_checksum = dccp_v6_csum_finish(skb, &np->saddr, &np->daddr);\n }\n \n-static inline __u32 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n-\t\t\t\t\t\t  __be16 sport, __be16 dport   )\n-{\n-\treturn secure_tcpv6_sequence_number(saddr, daddr, sport, dport);\n-}\n-\n-static inline __u32 dccp_v6_init_sequence(struct sk_buff *skb)\n+static inline __u64 dccp_v6_init_sequence(struct sk_buff *skb)\n {\n \treturn secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n \t\t\t\t\t     ipv6_hdr(skb)->saddr.s6_addr32,"
        },
        {
          "filename": "net/ipv4/inet_hashtables.c",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -21,6 +21,7 @@\n \n #include <net/inet_connection_sock.h>\n #include <net/inet_hashtables.h>\n+#include <net/secure_seq.h>\n #include <net/ip.h>\n \n /*"
        },
        {
          "filename": "net/ipv4/inetpeer.c",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -19,6 +19,7 @@\n #include <linux/net.h>\n #include <net/ip.h>\n #include <net/inetpeer.h>\n+#include <net/secure_seq.h>\n \n /*\n  *  Theory of operations."
        },
        {
          "filename": "net/ipv4/netfilter/nf_nat_proto_common.c",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -12,6 +12,7 @@\n #include <linux/ip.h>\n \n #include <linux/netfilter.h>\n+#include <net/secure_seq.h>\n #include <net/netfilter/nf_nat.h>\n #include <net/netfilter/nf_nat_core.h>\n #include <net/netfilter/nf_nat_rule.h>"
        },
        {
          "filename": "net/ipv4/route.c",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -109,6 +109,7 @@\n #include <linux/sysctl.h>\n #endif\n #include <net/atmclip.h>\n+#include <net/secure_seq.h>\n \n #define RT_FL_TOS(oldflp4) \\\n     ((u32)(oldflp4->flowi4_tos & (IPTOS_RT_MASK | RTO_ONLINK)))"
        },
        {
          "filename": "net/ipv4/tcp_ipv4.c",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -72,6 +72,7 @@\n #include <net/timewait_sock.h>\n #include <net/xfrm.h>\n #include <net/netdma.h>\n+#include <net/secure_seq.h>\n \n #include <linux/inet.h>\n #include <linux/ipv6.h>"
        },
        {
          "filename": "net/ipv6/inet6_hashtables.c",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -20,6 +20,7 @@\n #include <net/inet_connection_sock.h>\n #include <net/inet_hashtables.h>\n #include <net/inet6_hashtables.h>\n+#include <net/secure_seq.h>\n #include <net/ip.h>\n \n int __inet6_hash(struct sock *sk, struct inet_timewait_sock *tw)"
        },
        {
          "filename": "net/ipv6/tcp_ipv6.c",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -61,6 +61,7 @@\n #include <net/timewait_sock.h>\n #include <net/netdma.h>\n #include <net/inet_common.h>\n+#include <net/secure_seq.h>\n \n #include <asm/uaccess.h>\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 8,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "aa22f4da2a46b484a257d167c67a2adc1b7aaf68",
            "date": "2025-01-26T00:23:38Z",
            "author_login": "torvalds"
          },
          {
            "sha": "eda061cccd146fcbe71051bb4aa5a8672b71216e",
            "date": "2025-01-26T00:19:10Z",
            "author_login": "torvalds"
          },
          {
            "sha": "08de7f9d4d39fd9aa5e747a13acc891214fa2d5f",
            "date": "2025-01-26T00:12:07Z",
            "author_login": "torvalds"
          },
          {
            "sha": "647d69605c70368d54fc012fce8a43e8e5955b04",
            "date": "2025-01-26T00:03:40Z",
            "author_login": "torvalds"
          },
          {
            "sha": "184a0997fb77f4a9527fc867fcd16806776c27ce",
            "date": "2025-01-25T23:59:46Z",
            "author_login": "torvalds"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H",
    "cwe_id": null,
    "description": "The (1) IPv4 and (2) IPv6 implementations in the Linux kernel before 3.1 use a modified MD4 algorithm to generate sequence numbers and Fragment Identification values, which makes it easier for remote attackers to cause a denial of service (disrupted networking) or hijack network sessions by predicting these values and sending crafted packets.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2012-05-24T23:55:02.213",
    "last_modified": "2024-11-21T01:29:56.183",
    "fix_date": "2011-08-04T03:50:44Z"
  },
  "references": [
    {
      "url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=6e5714eaf77d79ae1c8b47e3e040ff5411b717ec",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=bc0b96b54a21246e377122d54569eef71cec535f",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://marc.info/?l=bugtraq&m=139447903326211&w=2",
      "source": "secalert@redhat.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.1",
      "source": "secalert@redhat.com",
      "tags": [
        "Mailing List",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2011/08/23/2",
      "source": "secalert@redhat.com",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=732658",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/6e5714eaf77d79ae1c8b47e3e040ff5411b717ec",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/bc0b96b54a21246e377122d54569eef71cec535f",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://support.f5.com/csp/article/K15301?utm_source=f5support&amp%3Butm_medium=RSS",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=6e5714eaf77d79ae1c8b47e3e040ff5411b717ec",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=bc0b96b54a21246e377122d54569eef71cec535f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://marc.info/?l=bugtraq&m=139447903326211&w=2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2011/08/23/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=732658",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/6e5714eaf77d79ae1c8b47e3e040ff5411b717ec",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/bc0b96b54a21246e377122d54569eef71cec535f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://support.f5.com/csp/article/K15301?utm_source=f5support&amp%3Butm_medium=RSS",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:07.266751",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "linux",
    "owner": "torvalds",
    "created_at": "2011-09-04T22:48:12Z",
    "updated_at": "2025-01-14T12:39:03Z",
    "pushed_at": "2025-01-13T17:27:04Z",
    "size": 5361369,
    "stars": 185823,
    "forks": 54743,
    "open_issues": 437,
    "watchers": 185823,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1326937103,
      "Assembly": 9568292,
      "Shell": 5072004,
      "Python": 2974128,
      "Makefile": 2713905,
      "Perl": 1253637,
      "Rust": 807711,
      "Roff": 202277,
      "C++": 173382,
      "SmPL": 165946,
      "Yacc": 127472,
      "Lex": 71321,
      "Awk": 69539,
      "Jinja": 30138,
      "UnrealScript": 16848,
      "Gherkin": 10172,
      "M4": 3329,
      "MATLAB": 2482,
      "sed": 2433,
      "Clojure": 2411,
      "XS": 1239,
      "RPC": 962
    },
    "commit_activity": {
      "total_commits_last_year": 46007,
      "avg_commits_per_week": 884.75,
      "days_active_last_year": 359
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T12:53:59.486675"
  }
}