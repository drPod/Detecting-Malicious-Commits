{
  "cve_id": "CVE-2011-3638",
  "github_data": {
    "repository": "torvalds/linux",
    "fix_commit": "667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3",
    "related_commits": [
      "667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3",
      "667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3",
      "commit_date": "2011-05-03T16:25:07Z",
      "author": {
        "login": "xiaoqiangnk",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "ext4: reimplement convert and split_unwritten",
        "length": 314,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 480,
        "additions": 72,
        "deletions": 408
      },
      "files": [
        {
          "filename": "fs/ext4/extents.c",
          "status": "modified",
          "additions": 72,
          "deletions": 408,
          "patch": "@@ -2757,17 +2757,13 @@ static int ext4_ext_convert_to_initialized(handle_t *handle,\n \t\t\t\t\t   struct ext4_map_blocks *map,\n \t\t\t\t\t   struct ext4_ext_path *path)\n {\n-\tstruct ext4_extent *ex, newex, orig_ex;\n-\tstruct ext4_extent *ex1 = NULL;\n-\tstruct ext4_extent *ex2 = NULL;\n-\tstruct ext4_extent *ex3 = NULL;\n-\tstruct ext4_extent_header *eh;\n+\tstruct ext4_map_blocks split_map;\n+\tstruct ext4_extent zero_ex;\n+\tstruct ext4_extent *ex;\n \text4_lblk_t ee_block, eof_block;\n \tunsigned int allocated, ee_len, depth;\n-\text4_fsblk_t newblock;\n \tint err = 0;\n-\tint ret = 0;\n-\tint may_zeroout;\n+\tint split_flag = 0;\n \n \text_debug(\"ext4_ext_convert_to_initialized: inode %lu, logical\"\n \t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n@@ -2779,280 +2775,87 @@ static int ext4_ext_convert_to_initialized(handle_t *handle,\n \t\teof_block = map->m_lblk + map->m_len;\n \n \tdepth = ext_depth(inode);\n-\teh = path[depth].p_hdr;\n \tex = path[depth].p_ext;\n \tee_block = le32_to_cpu(ex->ee_block);\n \tee_len = ext4_ext_get_actual_len(ex);\n \tallocated = ee_len - (map->m_lblk - ee_block);\n-\tnewblock = map->m_lblk - ee_block + ext4_ext_pblock(ex);\n-\n-\tex2 = ex;\n-\torig_ex.ee_block = ex->ee_block;\n-\torig_ex.ee_len   = cpu_to_le16(ee_len);\n-\text4_ext_store_pblock(&orig_ex, ext4_ext_pblock(ex));\n \n+\tWARN_ON(map->m_lblk < ee_block);\n \t/*\n \t * It is safe to convert extent to initialized via explicit\n \t * zeroout only if extent is fully insde i_size or new_size.\n \t */\n-\tmay_zeroout = ee_block + ee_len <= eof_block;\n+\tsplit_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;\n \n-\terr = ext4_ext_get_access(handle, inode, path + depth);\n-\tif (err)\n-\t\tgoto out;\n \t/* If extent has less than 2*EXT4_EXT_ZERO_LEN zerout directly */\n-\tif (ee_len <= 2*EXT4_EXT_ZERO_LEN && may_zeroout) {\n-\t\terr =  ext4_ext_zeroout(inode, &orig_ex);\n+\tif (ee_len <= 2*EXT4_EXT_ZERO_LEN &&\n+\t    (EXT4_EXT_MAY_ZEROOUT & split_flag)) {\n+\t\terr = ext4_ext_zeroout(inode, ex);\n \t\tif (err)\n-\t\t\tgoto fix_extent_len;\n-\t\t/* update the extent length and mark as initialized */\n-\t\tex->ee_block = orig_ex.ee_block;\n-\t\tex->ee_len   = orig_ex.ee_len;\n-\t\text4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));\n-\t\text4_ext_dirty(handle, inode, path + depth);\n-\t\t/* zeroed the full extent */\n-\t\treturn allocated;\n-\t}\n-\n-\t/* ex1: ee_block to map->m_lblk - 1 : uninitialized */\n-\tif (map->m_lblk > ee_block) {\n-\t\tex1 = ex;\n-\t\tex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);\n-\t\text4_ext_mark_uninitialized(ex1);\n-\t\tex2 = &newex;\n-\t}\n-\t/*\n-\t * for sanity, update the length of the ex2 extent before\n-\t * we insert ex3, if ex1 is NULL. This is to avoid temporary\n-\t * overlap of blocks.\n-\t */\n-\tif (!ex1 && allocated > map->m_len)\n-\t\tex2->ee_len = cpu_to_le16(map->m_len);\n-\t/* ex3: to ee_block + ee_len : uninitialised */\n-\tif (allocated > map->m_len) {\n-\t\tunsigned int newdepth;\n-\t\t/* If extent has less than EXT4_EXT_ZERO_LEN zerout directly */\n-\t\tif (allocated <= EXT4_EXT_ZERO_LEN && may_zeroout) {\n-\t\t\t/*\n-\t\t\t * map->m_lblk == ee_block is handled by the zerouout\n-\t\t\t * at the beginning.\n-\t\t\t * Mark first half uninitialized.\n-\t\t\t * Mark second half initialized and zero out the\n-\t\t\t * initialized extent\n-\t\t\t */\n-\t\t\tex->ee_block = orig_ex.ee_block;\n-\t\t\tex->ee_len   = cpu_to_le16(ee_len - allocated);\n-\t\t\text4_ext_mark_uninitialized(ex);\n-\t\t\text4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));\n-\t\t\text4_ext_dirty(handle, inode, path + depth);\n-\n-\t\t\tex3 = &newex;\n-\t\t\tex3->ee_block = cpu_to_le32(map->m_lblk);\n-\t\t\text4_ext_store_pblock(ex3, newblock);\n-\t\t\tex3->ee_len = cpu_to_le16(allocated);\n-\t\t\terr = ext4_ext_insert_extent(handle, inode, path,\n-\t\t\t\t\t\t\tex3, 0);\n-\t\t\tif (err == -ENOSPC) {\n-\t\t\t\terr =  ext4_ext_zeroout(inode, &orig_ex);\n-\t\t\t\tif (err)\n-\t\t\t\t\tgoto fix_extent_len;\n-\t\t\t\tex->ee_block = orig_ex.ee_block;\n-\t\t\t\tex->ee_len   = orig_ex.ee_len;\n-\t\t\t\text4_ext_store_pblock(ex,\n-\t\t\t\t\text4_ext_pblock(&orig_ex));\n-\t\t\t\text4_ext_dirty(handle, inode, path + depth);\n-\t\t\t\t/* blocks available from map->m_lblk */\n-\t\t\t\treturn allocated;\n-\n-\t\t\t} else if (err)\n-\t\t\t\tgoto fix_extent_len;\n-\n-\t\t\t/*\n-\t\t\t * We need to zero out the second half because\n-\t\t\t * an fallocate request can update file size and\n-\t\t\t * converting the second half to initialized extent\n-\t\t\t * implies that we can leak some junk data to user\n-\t\t\t * space.\n-\t\t\t */\n-\t\t\terr =  ext4_ext_zeroout(inode, ex3);\n-\t\t\tif (err) {\n-\t\t\t\t/*\n-\t\t\t\t * We should actually mark the\n-\t\t\t\t * second half as uninit and return error\n-\t\t\t\t * Insert would have changed the extent\n-\t\t\t\t */\n-\t\t\t\tdepth = ext_depth(inode);\n-\t\t\t\text4_ext_drop_refs(path);\n-\t\t\t\tpath = ext4_ext_find_extent(inode, map->m_lblk,\n-\t\t\t\t\t\t\t    path);\n-\t\t\t\tif (IS_ERR(path)) {\n-\t\t\t\t\terr = PTR_ERR(path);\n-\t\t\t\t\treturn err;\n-\t\t\t\t}\n-\t\t\t\t/* get the second half extent details */\n-\t\t\t\tex = path[depth].p_ext;\n-\t\t\t\terr = ext4_ext_get_access(handle, inode,\n-\t\t\t\t\t\t\t\tpath + depth);\n-\t\t\t\tif (err)\n-\t\t\t\t\treturn err;\n-\t\t\t\text4_ext_mark_uninitialized(ex);\n-\t\t\t\text4_ext_dirty(handle, inode, path + depth);\n-\t\t\t\treturn err;\n-\t\t\t}\n-\n-\t\t\t/* zeroed the second half */\n-\t\t\treturn allocated;\n-\t\t}\n-\t\tex3 = &newex;\n-\t\tex3->ee_block = cpu_to_le32(map->m_lblk + map->m_len);\n-\t\text4_ext_store_pblock(ex3, newblock + map->m_len);\n-\t\tex3->ee_len = cpu_to_le16(allocated - map->m_len);\n-\t\text4_ext_mark_uninitialized(ex3);\n-\t\terr = ext4_ext_insert_extent(handle, inode, path, ex3, 0);\n-\t\tif (err == -ENOSPC && may_zeroout) {\n-\t\t\terr =  ext4_ext_zeroout(inode, &orig_ex);\n-\t\t\tif (err)\n-\t\t\t\tgoto fix_extent_len;\n-\t\t\t/* update the extent length and mark as initialized */\n-\t\t\tex->ee_block = orig_ex.ee_block;\n-\t\t\tex->ee_len   = orig_ex.ee_len;\n-\t\t\text4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));\n-\t\t\text4_ext_dirty(handle, inode, path + depth);\n-\t\t\t/* zeroed the full extent */\n-\t\t\t/* blocks available from map->m_lblk */\n-\t\t\treturn allocated;\n-\n-\t\t} else if (err)\n-\t\t\tgoto fix_extent_len;\n-\t\t/*\n-\t\t * The depth, and hence eh & ex might change\n-\t\t * as part of the insert above.\n-\t\t */\n-\t\tnewdepth = ext_depth(inode);\n-\t\t/*\n-\t\t * update the extent length after successful insert of the\n-\t\t * split extent\n-\t\t */\n-\t\tee_len -= ext4_ext_get_actual_len(ex3);\n-\t\torig_ex.ee_len = cpu_to_le16(ee_len);\n-\t\tmay_zeroout = ee_block + ee_len <= eof_block;\n-\n-\t\tdepth = newdepth;\n-\t\text4_ext_drop_refs(path);\n-\t\tpath = ext4_ext_find_extent(inode, map->m_lblk, path);\n-\t\tif (IS_ERR(path)) {\n-\t\t\terr = PTR_ERR(path);\n \t\t\tgoto out;\n-\t\t}\n-\t\teh = path[depth].p_hdr;\n-\t\tex = path[depth].p_ext;\n-\t\tif (ex2 != &newex)\n-\t\t\tex2 = ex;\n \n \t\terr = ext4_ext_get_access(handle, inode, path + depth);\n \t\tif (err)\n \t\t\tgoto out;\n-\n-\t\tallocated = map->m_len;\n-\n-\t\t/* If extent has less than EXT4_EXT_ZERO_LEN and we are trying\n-\t\t * to insert a extent in the middle zerout directly\n-\t\t * otherwise give the extent a chance to merge to left\n-\t\t */\n-\t\tif (le16_to_cpu(orig_ex.ee_len) <= EXT4_EXT_ZERO_LEN &&\n-\t\t\tmap->m_lblk != ee_block && may_zeroout) {\n-\t\t\terr =  ext4_ext_zeroout(inode, &orig_ex);\n-\t\t\tif (err)\n-\t\t\t\tgoto fix_extent_len;\n-\t\t\t/* update the extent length and mark as initialized */\n-\t\t\tex->ee_block = orig_ex.ee_block;\n-\t\t\tex->ee_len   = orig_ex.ee_len;\n-\t\t\text4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));\n-\t\t\text4_ext_dirty(handle, inode, path + depth);\n-\t\t\t/* zero out the first half */\n-\t\t\t/* blocks available from map->m_lblk */\n-\t\t\treturn allocated;\n-\t\t}\n-\t}\n-\t/*\n-\t * If there was a change of depth as part of the\n-\t * insertion of ex3 above, we need to update the length\n-\t * of the ex1 extent again here\n-\t */\n-\tif (ex1 && ex1 != ex) {\n-\t\tex1 = ex;\n-\t\tex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);\n-\t\text4_ext_mark_uninitialized(ex1);\n-\t\tex2 = &newex;\n-\t}\n-\t/* ex2: map->m_lblk to map->m_lblk + maxblocks-1 : initialised */\n-\tex2->ee_block = cpu_to_le32(map->m_lblk);\n-\text4_ext_store_pblock(ex2, newblock);\n-\tex2->ee_len = cpu_to_le16(allocated);\n-\tif (ex2 != ex)\n-\t\tgoto insert;\n-\t/*\n-\t * New (initialized) extent starts from the first block\n-\t * in the current extent. i.e., ex2 == ex\n-\t * We have to see if it can be merged with the extent\n-\t * on the left.\n-\t */\n-\tif (ex2 > EXT_FIRST_EXTENT(eh)) {\n-\t\t/*\n-\t\t * To merge left, pass \"ex2 - 1\" to try_to_merge(),\n-\t\t * since it merges towards right _only_.\n-\t\t */\n-\t\tret = ext4_ext_try_to_merge(inode, path, ex2 - 1);\n-\t\tif (ret) {\n-\t\t\terr = ext4_ext_correct_indexes(handle, inode, path);\n-\t\t\tif (err)\n-\t\t\t\tgoto out;\n-\t\t\tdepth = ext_depth(inode);\n-\t\t\tex2--;\n-\t\t}\n+\t\text4_ext_mark_initialized(ex);\n+\t\text4_ext_try_to_merge(inode, path, ex);\n+\t\terr = ext4_ext_dirty(handle, inode, path + depth);\n+\t\tgoto out;\n \t}\n+\n \t/*\n-\t * Try to Merge towards right. This might be required\n-\t * only when the whole extent is being written to.\n-\t * i.e. ex2 == ex and ex3 == NULL.\n+\t * four cases:\n+\t * 1. split the extent into three extents.\n+\t * 2. split the extent into two extents, zeroout the first half.\n+\t * 3. split the extent into two extents, zeroout the second half.\n+\t * 4. split the extent into two extents with out zeroout.\n \t */\n-\tif (!ex3) {\n-\t\tret = ext4_ext_try_to_merge(inode, path, ex2);\n-\t\tif (ret) {\n-\t\t\terr = ext4_ext_correct_indexes(handle, inode, path);\n+\tsplit_map.m_lblk = map->m_lblk;\n+\tsplit_map.m_len = map->m_len;\n+\n+\tif (allocated > map->m_len) {\n+\t\tif (allocated <= EXT4_EXT_ZERO_LEN &&\n+\t\t    (EXT4_EXT_MAY_ZEROOUT & split_flag)) {\n+\t\t\t/* case 3 */\n+\t\t\tzero_ex.ee_block =\n+\t\t\t\t\t cpu_to_le32(map->m_lblk + map->m_len);\n+\t\t\tzero_ex.ee_len = cpu_to_le16(allocated - map->m_len);\n+\t\t\text4_ext_store_pblock(&zero_ex,\n+\t\t\t\text4_ext_pblock(ex) + map->m_lblk - ee_block);\n+\t\t\terr = ext4_ext_zeroout(inode, &zero_ex);\n \t\t\tif (err)\n \t\t\t\tgoto out;\n+\t\t\tsplit_map.m_lblk = map->m_lblk;\n+\t\t\tsplit_map.m_len = allocated;\n+\t\t} else if ((map->m_lblk - ee_block + map->m_len <\n+\t\t\t   EXT4_EXT_ZERO_LEN) &&\n+\t\t\t   (EXT4_EXT_MAY_ZEROOUT & split_flag)) {\n+\t\t\t/* case 2 */\n+\t\t\tif (map->m_lblk != ee_block) {\n+\t\t\t\tzero_ex.ee_block = ex->ee_block;\n+\t\t\t\tzero_ex.ee_len = cpu_to_le16(map->m_lblk -\n+\t\t\t\t\t\t\tee_block);\n+\t\t\t\text4_ext_store_pblock(&zero_ex,\n+\t\t\t\t\t\t      ext4_ext_pblock(ex));\n+\t\t\t\terr = ext4_ext_zeroout(inode, &zero_ex);\n+\t\t\t\tif (err)\n+\t\t\t\t\tgoto out;\n+\t\t\t}\n+\n+\t\t\tallocated = map->m_lblk - ee_block + map->m_len;\n+\n+\t\t\tsplit_map.m_lblk = ee_block;\n+\t\t\tsplit_map.m_len = allocated;\n \t\t}\n \t}\n-\t/* Mark modified extent as dirty */\n-\terr = ext4_ext_dirty(handle, inode, path + depth);\n-\tgoto out;\n-insert:\n-\terr = ext4_ext_insert_extent(handle, inode, path, &newex, 0);\n-\tif (err == -ENOSPC && may_zeroout) {\n-\t\terr =  ext4_ext_zeroout(inode, &orig_ex);\n-\t\tif (err)\n-\t\t\tgoto fix_extent_len;\n-\t\t/* update the extent length and mark as initialized */\n-\t\tex->ee_block = orig_ex.ee_block;\n-\t\tex->ee_len   = orig_ex.ee_len;\n-\t\text4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));\n-\t\text4_ext_dirty(handle, inode, path + depth);\n-\t\t/* zero out the first half */\n-\t\treturn allocated;\n-\t} else if (err)\n-\t\tgoto fix_extent_len;\n+\n+\tallocated = ext4_split_extent(handle, inode, path,\n+\t\t\t\t       &split_map, split_flag, 0);\n+\tif (allocated < 0)\n+\t\terr = allocated;\n+\n out:\n-\text4_ext_show_leaf(inode, path);\n \treturn err ? err : allocated;\n-\n-fix_extent_len:\n-\tex->ee_block = orig_ex.ee_block;\n-\tex->ee_len   = orig_ex.ee_len;\n-\text4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));\n-\text4_ext_mark_uninitialized(ex);\n-\text4_ext_dirty(handle, inode, path + depth);\n-\treturn err;\n }\n \n /*\n@@ -3083,15 +2886,11 @@ static int ext4_split_unwritten_extents(handle_t *handle,\n \t\t\t\t\tstruct ext4_ext_path *path,\n \t\t\t\t\tint flags)\n {\n-\tstruct ext4_extent *ex, newex, orig_ex;\n-\tstruct ext4_extent *ex1 = NULL;\n-\tstruct ext4_extent *ex2 = NULL;\n-\tstruct ext4_extent *ex3 = NULL;\n-\text4_lblk_t ee_block, eof_block;\n-\tunsigned int allocated, ee_len, depth;\n-\text4_fsblk_t newblock;\n-\tint err = 0;\n-\tint may_zeroout;\n+\text4_lblk_t eof_block;\n+\text4_lblk_t ee_block;\n+\tstruct ext4_extent *ex;\n+\tunsigned int ee_len;\n+\tint split_flag = 0, depth;\n \n \text_debug(\"ext4_split_unwritten_extents: inode %lu, logical\"\n \t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n@@ -3101,155 +2900,20 @@ static int ext4_split_unwritten_extents(handle_t *handle,\n \t\tinode->i_sb->s_blocksize_bits;\n \tif (eof_block < map->m_lblk + map->m_len)\n \t\teof_block = map->m_lblk + map->m_len;\n-\n-\tdepth = ext_depth(inode);\n-\tex = path[depth].p_ext;\n-\tee_block = le32_to_cpu(ex->ee_block);\n-\tee_len = ext4_ext_get_actual_len(ex);\n-\tallocated = ee_len - (map->m_lblk - ee_block);\n-\tnewblock = map->m_lblk - ee_block + ext4_ext_pblock(ex);\n-\n-\tex2 = ex;\n-\torig_ex.ee_block = ex->ee_block;\n-\torig_ex.ee_len   = cpu_to_le16(ee_len);\n-\text4_ext_store_pblock(&orig_ex, ext4_ext_pblock(ex));\n-\n \t/*\n \t * It is safe to convert extent to initialized via explicit\n \t * zeroout only if extent is fully insde i_size or new_size.\n \t */\n-\tmay_zeroout = ee_block + ee_len <= eof_block;\n-\n-\t/*\n- \t * If the uninitialized extent begins at the same logical\n- \t * block where the write begins, and the write completely\n- \t * covers the extent, then we don't need to split it.\n- \t */\n-\tif ((map->m_lblk == ee_block) && (allocated <= map->m_len))\n-\t\treturn allocated;\n-\n-\terr = ext4_ext_get_access(handle, inode, path + depth);\n-\tif (err)\n-\t\tgoto out;\n-\t/* ex1: ee_block to map->m_lblk - 1 : uninitialized */\n-\tif (map->m_lblk > ee_block) {\n-\t\tex1 = ex;\n-\t\tex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);\n-\t\text4_ext_mark_uninitialized(ex1);\n-\t\tex2 = &newex;\n-\t}\n-\t/*\n-\t * for sanity, update the length of the ex2 extent before\n-\t * we insert ex3, if ex1 is NULL. This is to avoid temporary\n-\t * overlap of blocks.\n-\t */\n-\tif (!ex1 && allocated > map->m_len)\n-\t\tex2->ee_len = cpu_to_le16(map->m_len);\n-\t/* ex3: to ee_block + ee_len : uninitialised */\n-\tif (allocated > map->m_len) {\n-\t\tunsigned int newdepth;\n-\t\tex3 = &newex;\n-\t\tex3->ee_block = cpu_to_le32(map->m_lblk + map->m_len);\n-\t\text4_ext_store_pblock(ex3, newblock + map->m_len);\n-\t\tex3->ee_len = cpu_to_le16(allocated - map->m_len);\n-\t\text4_ext_mark_uninitialized(ex3);\n-\t\terr = ext4_ext_insert_extent(handle, inode, path, ex3, flags);\n-\t\tif (err == -ENOSPC && may_zeroout) {\n-\t\t\terr =  ext4_ext_zeroout(inode, &orig_ex);\n-\t\t\tif (err)\n-\t\t\t\tgoto fix_extent_len;\n-\t\t\t/* update the extent length and mark as initialized */\n-\t\t\tex->ee_block = orig_ex.ee_block;\n-\t\t\tex->ee_len   = orig_ex.ee_len;\n-\t\t\text4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));\n-\t\t\text4_ext_dirty(handle, inode, path + depth);\n-\t\t\t/* zeroed the full extent */\n-\t\t\t/* blocks available from map->m_lblk */\n-\t\t\treturn allocated;\n-\n-\t\t} else if (err)\n-\t\t\tgoto fix_extent_len;\n-\t\t/*\n-\t\t * The depth, and hence eh & ex might change\n-\t\t * as part of the insert above.\n-\t\t */\n-\t\tnewdepth = ext_depth(inode);\n-\t\t/*\n-\t\t * update the extent length after successful insert of the\n-\t\t * split extent\n-\t\t */\n-\t\tee_len -= ext4_ext_get_actual_len(ex3);\n-\t\torig_ex.ee_len = cpu_to_le16(ee_len);\n-\t\tmay_zeroout = ee_block + ee_len <= eof_block;\n-\n-\t\tdepth = newdepth;\n-\t\text4_ext_drop_refs(path);\n-\t\tpath = ext4_ext_find_extent(inode, map->m_lblk, path);\n-\t\tif (IS_ERR(path)) {\n-\t\t\terr = PTR_ERR(path);\n-\t\t\tgoto out;\n-\t\t}\n-\t\tex = path[depth].p_ext;\n-\t\tif (ex2 != &newex)\n-\t\t\tex2 = ex;\n+\tdepth = ext_depth(inode);\n+\tex = path[depth].p_ext;\n+\tee_block = le32_to_cpu(ex->ee_block);\n+\tee_len = ext4_ext_get_actual_len(ex);\n \n-\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n-\t\tif (err)\n-\t\t\tgoto out;\n+\tsplit_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;\n+\tsplit_flag |= EXT4_EXT_MARK_UNINIT2;\n \n-\t\tallocated = map->m_len;\n-\t}\n-\t/*\n-\t * If there was a change of depth as part of the\n-\t * insertion of ex3 above, we need to update the length\n-\t * of the ex1 extent again here\n-\t */\n-\tif (ex1 && ex1 != ex) {\n-\t\tex1 = ex;\n-\t\tex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);\n-\t\text4_ext_mark_uninitialized(ex1);\n-\t\tex2 = &newex;\n-\t}\n-\t/*\n-\t * ex2: map->m_lblk to map->m_lblk + map->m_len-1 : to be written\n-\t * using direct I/O, uninitialised still.\n-\t */\n-\tex2->ee_block = cpu_to_le32(map->m_lblk);\n-\text4_ext_store_pblock(ex2, newblock);\n-\tex2->ee_len = cpu_to_le16(allocated);\n-\text4_ext_mark_uninitialized(ex2);\n-\tif (ex2 != ex)\n-\t\tgoto insert;\n-\t/* Mark modified extent as dirty */\n-\terr = ext4_ext_dirty(handle, inode, path + depth);\n-\text_debug(\"out here\\n\");\n-\tgoto out;\n-insert:\n-\terr = ext4_ext_insert_extent(handle, inode, path, &newex, flags);\n-\tif (err == -ENOSPC && may_zeroout) {\n-\t\terr =  ext4_ext_zeroout(inode, &orig_ex);\n-\t\tif (err)\n-\t\t\tgoto fix_extent_len;\n-\t\t/* update the extent length and mark as initialized */\n-\t\tex->ee_block = orig_ex.ee_block;\n-\t\tex->ee_len   = orig_ex.ee_len;\n-\t\text4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));\n-\t\text4_ext_dirty(handle, inode, path + depth);\n-\t\t/* zero out the first half */\n-\t\treturn allocated;\n-\t} else if (err)\n-\t\tgoto fix_extent_len;\n-out:\n-\text4_ext_show_leaf(inode, path);\n-\treturn err ? err : allocated;\n-\n-fix_extent_len:\n-\tex->ee_block = orig_ex.ee_block;\n-\tex->ee_len   = orig_ex.ee_len;\n-\text4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));\n-\text4_ext_mark_uninitialized(ex);\n-\text4_ext_dirty(handle, inode, path + depth);\n-\treturn err;\n+\tflags |= EXT4_GET_BLOCKS_PRE_IO;\n+\treturn ext4_split_extent(handle, inode, path, map, split_flag, flags);\n }\n \n static int ext4_convert_unwritten_extents_endio(handle_t *handle,"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "aa22f4da2a46b484a257d167c67a2adc1b7aaf68",
            "date": "2025-01-26T00:23:38Z",
            "author_login": "torvalds"
          },
          {
            "sha": "eda061cccd146fcbe71051bb4aa5a8672b71216e",
            "date": "2025-01-26T00:19:10Z",
            "author_login": "torvalds"
          },
          {
            "sha": "08de7f9d4d39fd9aa5e747a13acc891214fa2d5f",
            "date": "2025-01-26T00:12:07Z",
            "author_login": "torvalds"
          },
          {
            "sha": "647d69605c70368d54fc012fce8a43e8e5955b04",
            "date": "2025-01-26T00:03:40Z",
            "author_login": "torvalds"
          },
          {
            "sha": "184a0997fb77f4a9527fc867fcd16806776c27ce",
            "date": "2025-01-25T23:59:46Z",
            "author_login": "torvalds"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": null,
    "description": "fs/ext4/extents.c in the Linux kernel before 3.0 does not mark a modified extent as dirty in certain cases of extent splitting, which allows local users to cause a denial of service (system crash) via vectors involving ext4 umount and mount operations.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2013-03-01T12:37:54.053",
    "last_modified": "2024-11-21T01:30:53.923",
    "fix_date": "2011-05-03T16:25:07Z"
  },
  "references": [
    {
      "url": "http://ftp.osuosl.org/pub/linux/kernel/v3.0/ChangeLog-3.0",
      "source": "secalert@redhat.com",
      "tags": [
        "Broken Link"
      ]
    },
    {
      "url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2011/10/24/2",
      "source": "secalert@redhat.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=747942",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://ftp.osuosl.org/pub/linux/kernel/v3.0/ChangeLog-3.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Broken Link"
      ]
    },
    {
      "url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2011/10/24/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=747942",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:13.492437",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "linux",
    "owner": "torvalds",
    "created_at": "2011-09-04T22:48:12Z",
    "updated_at": "2025-01-14T12:39:03Z",
    "pushed_at": "2025-01-13T17:27:04Z",
    "size": 5361369,
    "stars": 185823,
    "forks": 54743,
    "open_issues": 437,
    "watchers": 185823,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1326937103,
      "Assembly": 9568292,
      "Shell": 5072004,
      "Python": 2974128,
      "Makefile": 2713905,
      "Perl": 1253637,
      "Rust": 807711,
      "Roff": 202277,
      "C++": 173382,
      "SmPL": 165946,
      "Yacc": 127472,
      "Lex": 71321,
      "Awk": 69539,
      "Jinja": 30138,
      "UnrealScript": 16848,
      "Gherkin": 10172,
      "M4": 3329,
      "MATLAB": 2482,
      "sed": 2433,
      "Clojure": 2411,
      "XS": 1239,
      "RPC": 962
    },
    "commit_activity": {
      "total_commits_last_year": 46007,
      "avg_commits_per_week": 884.75,
      "days_active_last_year": 359
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T12:53:59.486675"
  }
}