{
  "cve_id": "CVE-2011-4098",
  "github_data": {
    "repository": "torvalds/linux",
    "fix_commit": "64dd153c83743af81f20924c6343652d731eeecb",
    "related_commits": [
      "64dd153c83743af81f20924c6343652d731eeecb",
      "64dd153c83743af81f20924c6343652d731eeecb"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "64dd153c83743af81f20924c6343652d731eeecb",
      "commit_date": "2011-09-12T23:15:24Z",
      "author": {
        "login": "bmarzins",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "GFS2: rewrite fallocate code to write blocks directly",
        "length": 605,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 186,
        "additions": 39,
        "deletions": 147
      },
      "files": [
        {
          "filename": "fs/gfs2/bmap.c",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -10,6 +10,7 @@\n #include <linux/spinlock.h>\n #include <linux/completion.h>\n #include <linux/buffer_head.h>\n+#include <linux/blkdev.h>\n #include <linux/gfs2_ondisk.h>\n #include <linux/crc32.h>\n \n@@ -427,12 +428,14 @@ static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,\n {\n \tstruct gfs2_inode *ip = GFS2_I(inode);\n \tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n+\tstruct super_block *sb = sdp->sd_vfs;\n \tstruct buffer_head *dibh = mp->mp_bh[0];\n \tu64 bn, dblock = 0;\n \tunsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;\n \tunsigned dblks = 0;\n \tunsigned ptrs_per_blk;\n \tconst unsigned end_of_metadata = height - 1;\n+\tint ret;\n \tint eob = 0;\n \tenum alloc_state state;\n \t__be64 *ptr;\n@@ -535,6 +538,15 @@ static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,\n \t\t\tdblock = bn;\n \t\t\twhile (n-- > 0)\n \t\t\t\t*ptr++ = cpu_to_be64(bn++);\n+\t\t\tif (buffer_zeronew(bh_map)) {\n+\t\t\t\tret = sb_issue_zeroout(sb, dblock, dblks,\n+\t\t\t\t\t\t       GFP_NOFS);\n+\t\t\t\tif (ret) {\n+\t\t\t\t\tfs_err(sdp,\n+\t\t\t\t\t       \"Failed to zero data buffers\\n\");\n+\t\t\t\t\tclear_buffer_zeronew(bh_map);\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tbreak;\n \t\t}\n \t} while ((state != ALLOC_DATA) || !dblock);"
        },
        {
          "filename": "fs/gfs2/file.c",
          "status": "modified",
          "additions": 24,
          "deletions": 147,
          "patch": "@@ -669,135 +669,18 @@ static ssize_t gfs2_file_aio_write(struct kiocb *iocb, const struct iovec *iov,\n \treturn generic_file_aio_write(iocb, iov, nr_segs, pos);\n }\n \n-static int empty_write_end(struct page *page, unsigned from,\n-\t\t\t   unsigned to, int mode)\n-{\n-\tstruct inode *inode = page->mapping->host;\n-\tstruct gfs2_inode *ip = GFS2_I(inode);\n-\tstruct buffer_head *bh;\n-\tunsigned offset, blksize = 1 << inode->i_blkbits;\n-\tpgoff_t end_index = i_size_read(inode) >> PAGE_CACHE_SHIFT;\n-\n-\tzero_user(page, from, to-from);\n-\tmark_page_accessed(page);\n-\n-\tif (page->index < end_index || !(mode & FALLOC_FL_KEEP_SIZE)) {\n-\t\tif (!gfs2_is_writeback(ip))\n-\t\t\tgfs2_page_add_databufs(ip, page, from, to);\n-\n-\t\tblock_commit_write(page, from, to);\n-\t\treturn 0;\n-\t}\n-\n-\toffset = 0;\n-\tbh = page_buffers(page);\n-\twhile (offset < to) {\n-\t\tif (offset >= from) {\n-\t\t\tset_buffer_uptodate(bh);\n-\t\t\tmark_buffer_dirty(bh);\n-\t\t\tclear_buffer_new(bh);\n-\t\t\twrite_dirty_buffer(bh, WRITE);\n-\t\t}\n-\t\toffset += blksize;\n-\t\tbh = bh->b_this_page;\n-\t}\n-\n-\toffset = 0;\n-\tbh = page_buffers(page);\n-\twhile (offset < to) {\n-\t\tif (offset >= from) {\n-\t\t\twait_on_buffer(bh);\n-\t\t\tif (!buffer_uptodate(bh))\n-\t\t\t\treturn -EIO;\n-\t\t}\n-\t\toffset += blksize;\n-\t\tbh = bh->b_this_page;\n-\t}\n-\treturn 0;\n-}\n-\n-static int needs_empty_write(sector_t block, struct inode *inode)\n-{\n-\tint error;\n-\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n-\n-\tbh_map.b_size = 1 << inode->i_blkbits;\n-\terror = gfs2_block_map(inode, block, &bh_map, 0);\n-\tif (unlikely(error))\n-\t\treturn error;\n-\treturn !buffer_mapped(&bh_map);\n-}\n-\n-static int write_empty_blocks(struct page *page, unsigned from, unsigned to,\n-\t\t\t      int mode)\n-{\n-\tstruct inode *inode = page->mapping->host;\n-\tunsigned start, end, next, blksize;\n-\tsector_t block = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n-\tint ret;\n-\n-\tblksize = 1 << inode->i_blkbits;\n-\tnext = end = 0;\n-\twhile (next < from) {\n-\t\tnext += blksize;\n-\t\tblock++;\n-\t}\n-\tstart = next;\n-\tdo {\n-\t\tnext += blksize;\n-\t\tret = needs_empty_write(block, inode);\n-\t\tif (unlikely(ret < 0))\n-\t\t\treturn ret;\n-\t\tif (ret == 0) {\n-\t\t\tif (end) {\n-\t\t\t\tret = __block_write_begin(page, start, end - start,\n-\t\t\t\t\t\t\t  gfs2_block_map);\n-\t\t\t\tif (unlikely(ret))\n-\t\t\t\t\treturn ret;\n-\t\t\t\tret = empty_write_end(page, start, end, mode);\n-\t\t\t\tif (unlikely(ret))\n-\t\t\t\t\treturn ret;\n-\t\t\t\tend = 0;\n-\t\t\t}\n-\t\t\tstart = next;\n-\t\t}\n-\t\telse\n-\t\t\tend = next;\n-\t\tblock++;\n-\t} while (next < to);\n-\n-\tif (end) {\n-\t\tret = __block_write_begin(page, start, end - start, gfs2_block_map);\n-\t\tif (unlikely(ret))\n-\t\t\treturn ret;\n-\t\tret = empty_write_end(page, start, end, mode);\n-\t\tif (unlikely(ret))\n-\t\t\treturn ret;\n-\t}\n-\n-\treturn 0;\n-}\n-\n static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n \t\t\t   int mode)\n {\n \tstruct gfs2_inode *ip = GFS2_I(inode);\n \tstruct buffer_head *dibh;\n \tint error;\n-\tu64 start = offset >> PAGE_CACHE_SHIFT;\n-\tunsigned int start_offset = offset & ~PAGE_CACHE_MASK;\n-\tu64 end = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n-\tpgoff_t curr;\n-\tstruct page *page;\n-\tunsigned int end_offset = (offset + len) & ~PAGE_CACHE_MASK;\n-\tunsigned int from, to;\n-\n-\tif (!end_offset)\n-\t\tend_offset = PAGE_CACHE_SIZE;\n+\tunsigned int nr_blks;\n+\tsector_t lblock = offset >> inode->i_blkbits;\n \n \terror = gfs2_meta_inode_buffer(ip, &dibh);\n \tif (unlikely(error))\n-\t\tgoto out;\n+\t\treturn error;\n \n \tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n \n@@ -807,39 +690,31 @@ static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n \t\t\tgoto out;\n \t}\n \n-\tcurr = start;\n-\toffset = start << PAGE_CACHE_SHIFT;\n-\tfrom = start_offset;\n-\tto = PAGE_CACHE_SIZE;\n-\twhile (curr <= end) {\n-\t\tpage = grab_cache_page_write_begin(inode->i_mapping, curr,\n-\t\t\t\t\t\t   AOP_FLAG_NOFS);\n-\t\tif (unlikely(!page)) {\n-\t\t\terror = -ENOMEM;\n-\t\t\tgoto out;\n-\t\t}\n+\twhile (len) {\n+\t\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n+\t\tbh_map.b_size = len;\n+\t\tset_buffer_zeronew(&bh_map);\n \n-\t\tif (curr == end)\n-\t\t\tto = end_offset;\n-\t\terror = write_empty_blocks(page, from, to, mode);\n-\t\tif (!error && offset + to > inode->i_size &&\n-\t\t    !(mode & FALLOC_FL_KEEP_SIZE)) {\n-\t\t\ti_size_write(inode, offset + to);\n-\t\t}\n-\t\tunlock_page(page);\n-\t\tpage_cache_release(page);\n-\t\tif (error)\n+\t\terror = gfs2_block_map(inode, lblock, &bh_map, 1);\n+\t\tif (unlikely(error))\n \t\t\tgoto out;\n-\t\tcurr++;\n-\t\toffset += PAGE_CACHE_SIZE;\n-\t\tfrom = 0;\n+\t\tlen -= bh_map.b_size;\n+\t\tnr_blks = bh_map.b_size >> inode->i_blkbits;\n+\t\tlblock += nr_blks;\n+\t\tif (!buffer_new(&bh_map))\n+\t\t\tcontinue;\n+\t\tif (unlikely(!buffer_zeronew(&bh_map))) {\n+\t\t\terror = -EIO;\n+\t\t\tgoto out;\n+\t\t}\n \t}\n+\tif (offset + len > inode->i_size && !(mode & FALLOC_FL_KEEP_SIZE))\n+\t\ti_size_write(inode, offset + len);\n \n \tmark_inode_dirty(inode);\n \n-\tbrelse(dibh);\n-\n out:\n+\tbrelse(dibh);\n \treturn error;\n }\n \n@@ -879,6 +754,7 @@ static long gfs2_fallocate(struct file *file, int mode, loff_t offset,\n \tint error;\n \tloff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);\n \tloff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;\n+\tloff_t max_chunk_size = UINT_MAX & bsize_mask;\n \tnext = (next + 1) << sdp->sd_sb.sb_bsize_shift;\n \n \t/* We only support the FALLOC_FL_KEEP_SIZE mode */\n@@ -932,7 +808,8 @@ static long gfs2_fallocate(struct file *file, int mode, loff_t offset,\n \t\t\tgoto out_qunlock;\n \t\t}\n \t\tmax_bytes = bytes;\n-\t\tcalc_max_reserv(ip, len, &max_bytes, &data_blocks, &ind_blocks);\n+\t\tcalc_max_reserv(ip, (len > max_chunk_size)? max_chunk_size: len,\n+\t\t\t\t&max_bytes, &data_blocks, &ind_blocks);\n \t\tal->al_requested = data_blocks + ind_blocks;\n \n \t\trblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +"
        },
        {
          "filename": "fs/gfs2/incore.h",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -103,12 +103,15 @@ struct gfs2_rgrpd {\n enum gfs2_state_bits {\n \tBH_Pinned = BH_PrivateStart,\n \tBH_Escaped = BH_PrivateStart + 1,\n+\tBH_Zeronew = BH_PrivateStart + 2,\n };\n \n BUFFER_FNS(Pinned, pinned)\n TAS_BUFFER_FNS(Pinned, pinned)\n BUFFER_FNS(Escaped, escaped)\n TAS_BUFFER_FNS(Escaped, escaped)\n+BUFFER_FNS(Zeronew, zeronew)\n+TAS_BUFFER_FNS(Zeronew, zeronew)\n \n struct gfs2_bufdata {\n \tstruct buffer_head *bd_bh;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "aa22f4da2a46b484a257d167c67a2adc1b7aaf68",
            "date": "2025-01-26T00:23:38Z",
            "author_login": "torvalds"
          },
          {
            "sha": "eda061cccd146fcbe71051bb4aa5a8672b71216e",
            "date": "2025-01-26T00:19:10Z",
            "author_login": "torvalds"
          },
          {
            "sha": "08de7f9d4d39fd9aa5e747a13acc891214fa2d5f",
            "date": "2025-01-26T00:12:07Z",
            "author_login": "torvalds"
          },
          {
            "sha": "647d69605c70368d54fc012fce8a43e8e5955b04",
            "date": "2025-01-26T00:03:40Z",
            "author_login": "torvalds"
          },
          {
            "sha": "184a0997fb77f4a9527fc867fcd16806776c27ce",
            "date": "2025-01-25T23:59:46Z",
            "author_login": "torvalds"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-119",
    "description": "The fallocate implementation in the GFS2 filesystem in the Linux kernel before 3.2 relies on the page cache, which might allow local users to cause a denial of service by preallocating blocks in certain situations involving insufficient memory.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2013-06-08T13:05:55.490",
    "last_modified": "2024-11-21T01:31:50.520",
    "fix_date": "2011-09-12T23:15:24Z"
  },
  "references": [
    {
      "url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=64dd153c83743af81f20924c6343652d731eeecb",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.kernel.org/pub/linux/kernel/v3.x/patch-3.2.bz2",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/64dd153c83743af81f20924c6343652d731eeecb",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://oss.oracle.com/git/?p=redpatch.git%3Ba=commit%3Bh=fadca7bdc43b02f518585d9547019966415cadfd",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://www.redhat.com/archives/cluster-devel/2011-September/msg00064.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=64dd153c83743af81f20924c6343652d731eeecb",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.kernel.org/pub/linux/kernel/v3.x/patch-3.2.bz2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/64dd153c83743af81f20924c6343652d731eeecb",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://oss.oracle.com/git/?p=redpatch.git%3Ba=commit%3Bh=fadca7bdc43b02f518585d9547019966415cadfd",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://www.redhat.com/archives/cluster-devel/2011-September/msg00064.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:16.771622",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "linux",
    "owner": "torvalds",
    "created_at": "2011-09-04T22:48:12Z",
    "updated_at": "2025-01-14T12:39:03Z",
    "pushed_at": "2025-01-13T17:27:04Z",
    "size": 5361369,
    "stars": 185823,
    "forks": 54743,
    "open_issues": 437,
    "watchers": 185823,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1326937103,
      "Assembly": 9568292,
      "Shell": 5072004,
      "Python": 2974128,
      "Makefile": 2713905,
      "Perl": 1253637,
      "Rust": 807711,
      "Roff": 202277,
      "C++": 173382,
      "SmPL": 165946,
      "Yacc": 127472,
      "Lex": 71321,
      "Awk": 69539,
      "Jinja": 30138,
      "UnrealScript": 16848,
      "Gherkin": 10172,
      "M4": 3329,
      "MATLAB": 2482,
      "sed": 2433,
      "Clojure": 2411,
      "XS": 1239,
      "RPC": 962
    },
    "commit_activity": {
      "total_commits_last_year": 46007,
      "avg_commits_per_week": 884.75,
      "days_active_last_year": 359
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T12:53:59.486675"
  }
}