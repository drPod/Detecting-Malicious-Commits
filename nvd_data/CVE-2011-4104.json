{
  "cve_id": "CVE-2011-4104",
  "github_data": {
    "repository": "toastdriven/django-tastypie",
    "fix_commit": "e8af315211b07c8f48f32a063233cc3f76dd5bc2",
    "related_commits": [
      "e8af315211b07c8f48f32a063233cc3f76dd5bc2",
      "e8af315211b07c8f48f32a063233cc3f76dd5bc2"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "e8af315211b07c8f48f32a063233cc3f76dd5bc2",
      "commit_date": "2011-10-28T06:36:57Z",
      "author": {
        "login": "toastdriven",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Safer loading of YAML. Thanks to daveyss for the report!",
        "length": 56,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 102,
        "additions": 51,
        "deletions": 51
      },
      "files": [
        {
          "filename": "tastypie/serializers.py",
          "status": "modified",
          "additions": 51,
          "deletions": 51,
          "patch": "@@ -28,16 +28,16 @@\n class Serializer(object):\n     \"\"\"\n     A swappable class for serialization.\n-    \n+\n     This handles most types of data as well as the following output formats::\n-    \n+\n         * json\n         * jsonp\n         * xml\n         * yaml\n         * html\n         * plist (see http://explorapp.com/biplist/)\n-    \n+\n     It was designed to make changing behavior easy, either by overridding the\n     various format methods (i.e. ``to_json``), by changing the\n     ``formats/content_types`` options or by altering the other hook methods.\n@@ -51,99 +51,99 @@ class Serializer(object):\n         'html': 'text/html',\n         'plist': 'application/x-plist',\n     }\n-    \n+\n     def __init__(self, formats=None, content_types=None, datetime_formatting=None):\n         self.supported_formats = []\n         self.datetime_formatting = getattr(settings, 'TASTYPIE_DATETIME_FORMATTING', 'iso-8601')\n-        \n+\n         if formats is not None:\n             self.formats = formats\n-        \n+\n         if content_types is not None:\n             self.content_types = content_types\n-        \n+\n         if datetime_formatting is not None:\n             self.datetime_formatting = datetime_formatting\n-        \n+\n         for format in self.formats:\n             try:\n                 self.supported_formats.append(self.content_types[format])\n             except KeyError:\n                 raise ImproperlyConfigured(\"Content type for specified type '%s' not found. Please provide it at either the class level or via the arguments.\" % format)\n-    \n+\n     def get_mime_for_format(self, format):\n         \"\"\"\n         Given a format, attempts to determine the correct MIME type.\n-        \n+\n         If not available on the current ``Serializer``, returns\n         ``application/json`` by default.\n         \"\"\"\n         try:\n             return self.content_types[format]\n         except KeyError:\n             return 'application/json'\n-    \n+\n     def format_datetime(self, data):\n         \"\"\"\n         A hook to control how datetimes are formatted.\n-        \n+\n         Can be overridden at the ``Serializer`` level (``datetime_formatting``)\n         or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``).\n-        \n+\n         Default is ``iso-8601``, which looks like \"2010-12-16T03:02:14\".\n         \"\"\"\n         if self.datetime_formatting == 'rfc-2822':\n             return format_datetime(data)\n-        \n+\n         return data.isoformat()\n-    \n+\n     def format_date(self, data):\n         \"\"\"\n         A hook to control how dates are formatted.\n-        \n+\n         Can be overridden at the ``Serializer`` level (``datetime_formatting``)\n         or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``).\n-        \n+\n         Default is ``iso-8601``, which looks like \"2010-12-16\".\n         \"\"\"\n         if self.datetime_formatting == 'rfc-2822':\n             return format_date(data)\n-        \n+\n         return data.isoformat()\n-    \n+\n     def format_time(self, data):\n         \"\"\"\n         A hook to control how times are formatted.\n-        \n+\n         Can be overridden at the ``Serializer`` level (``datetime_formatting``)\n         or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``).\n-        \n+\n         Default is ``iso-8601``, which looks like \"03:02:14\".\n         \"\"\"\n         if self.datetime_formatting == 'rfc-2822':\n             return format_time(data)\n-        \n+\n         return data.isoformat()\n-    \n+\n     def serialize(self, bundle, format='application/json', options={}):\n         \"\"\"\n         Given some data and a format, calls the correct method to serialize\n         the data and returns the result.\n         \"\"\"\n         desired_format = None\n-        \n+\n         for short_format, long_format in self.content_types.items():\n             if format == long_format:\n                 if hasattr(self, \"to_%s\" % short_format):\n                     desired_format = short_format\n                     break\n-        \n+\n         if desired_format is None:\n             raise UnsupportedFormat(\"The format indicated '%s' had no available serialization method. Please check your ``formats`` and ``content_types`` on your Serializer.\" % format)\n-        \n+\n         serialized = getattr(self, \"to_%s\" % desired_format)(bundle, options)\n         return serialized\n-    \n+\n     def deserialize(self, content, format='application/json'):\n         \"\"\"\n         Given some data and a format, calls the correct method to deserialize\n@@ -158,18 +158,18 @@ def deserialize(self, content, format='application/json'):\n                 if hasattr(self, \"from_%s\" % short_format):\n                     desired_format = short_format\n                     break\n-        \n+\n         if desired_format is None:\n             raise UnsupportedFormat(\"The format indicated '%s' had no available deserialization method. Please check your ``formats`` and ``content_types`` on your Serializer.\" % format)\n-        \n+\n         deserialized = getattr(self, \"from_%s\" % desired_format)(content)\n         return deserialized\n \n     def to_simple(self, data, options):\n         \"\"\"\n         For a piece of data, attempts to recognize it and provide a simplified\n         form of something complex.\n-        \n+\n         This brings complex Python data structures down to native types of the\n         serialization format(s).\n         \"\"\"\n@@ -293,7 +293,7 @@ def from_etree(self, data):\n                     return False\n             else:\n                 return None\n-            \n+\n     def to_json(self, data, options=None):\n         \"\"\"\n         Given some Python data, produces JSON output.\n@@ -321,76 +321,76 @@ def to_xml(self, data, options=None):\n         Given some Python data, produces XML output.\n         \"\"\"\n         options = options or {}\n-        \n+\n         if lxml is None:\n             raise ImproperlyConfigured(\"Usage of the XML aspects requires lxml.\")\n-        \n+\n         return tostring(self.to_etree(data, options), xml_declaration=True, encoding='utf-8')\n-    \n+\n     def from_xml(self, content):\n         \"\"\"\n         Given some XML data, returns a Python dictionary of the decoded data.\n         \"\"\"\n         if lxml is None:\n             raise ImproperlyConfigured(\"Usage of the XML aspects requires lxml.\")\n-        \n+\n         return self.from_etree(parse_xml(StringIO(content)).getroot())\n-    \n+\n     def to_yaml(self, data, options=None):\n         \"\"\"\n         Given some Python data, produces YAML output.\n         \"\"\"\n         options = options or {}\n-        \n+\n         if yaml is None:\n             raise ImproperlyConfigured(\"Usage of the YAML aspects requires yaml.\")\n-        \n+\n         return yaml.dump(self.to_simple(data, options))\n-    \n+\n     def from_yaml(self, content):\n         \"\"\"\n         Given some YAML data, returns a Python dictionary of the decoded data.\n         \"\"\"\n         if yaml is None:\n             raise ImproperlyConfigured(\"Usage of the YAML aspects requires yaml.\")\n-        \n-        return yaml.load(content)\n-    \n+\n+        return yaml.safe_load(content)\n+\n     def to_plist(self, data, options=None):\n         \"\"\"\n         Given some Python data, produces binary plist output.\n         \"\"\"\n         options = options or {}\n-        \n+\n         if biplist is None:\n             raise ImproperlyConfigured(\"Usage of the plist aspects requires biplist.\")\n-        \n+\n         return biplist.writePlistToString(self.to_simple(data, options))\n-    \n+\n     def from_plist(self, content):\n         \"\"\"\n         Given some binary plist data, returns a Python dictionary of the decoded data.\n         \"\"\"\n         if biplist is None:\n             raise ImproperlyConfigured(\"Usage of the plist aspects requires biplist.\")\n-        \n+\n         return biplist.readPlistFromString(content)\n-    \n+\n     def to_html(self, data, options=None):\n         \"\"\"\n         Reserved for future usage.\n-        \n+\n         The desire is to provide HTML output of a resource, making an API\n         available to a browser. This is on the TODO list but not currently\n         implemented.\n         \"\"\"\n         options = options or {}\n         return 'Sorry, not implemented yet. Please append \"?format=json\" to your URL.'\n-    \n+\n     def from_html(self, content):\n         \"\"\"\n         Reserved for future usage.\n-        \n+\n         The desire is to handle form-based (maybe Javascript?) input, making an\n         API available to a browser. This is on the TODO list but not currently\n         implemented.\n@@ -402,7 +402,7 @@ def get_type_string(data):\n     Translates a Python data type into a string format.\n     \"\"\"\n     data_type = type(data)\n-    \n+\n     if data_type in (int, long):\n         return 'integer'\n     elif data_type == float:"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "ac18543860a1deb88ed83c6d2eecad02a525419d",
            "date": "2021-06-03T20:14:03Z",
            "author_login": "TDaulat"
          },
          {
            "sha": "3b435be55871f467b9f599b59821c1faa182742f",
            "date": "2021-06-03T17:28:26Z",
            "author_login": "georgedorn"
          },
          {
            "sha": "2700cdc31bfab886149727b2f8a737309e6b27ec",
            "date": "2020-01-06T14:43:54Z",
            "author_login": "georgedorn"
          },
          {
            "sha": "b78417e2799bb2ee90e3540592c6fc632ea61be0",
            "date": "2019-12-09T15:32:54Z",
            "author_login": "nikolas"
          },
          {
            "sha": "60d4cfbbb4002de5733a4a57cf5077f86cae5a69",
            "date": "2019-09-23T14:34:55Z",
            "author_login": "nikolas"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-20",
    "description": "The from_yaml method in serializers.py in Django Tastypie before 0.9.10 does not properly deserialize YAML data, which allows remote attackers to execute arbitrary Python code via vectors related to the yaml.load method.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2014-10-27T01:55:23.407",
    "last_modified": "2024-11-21T01:31:51.253",
    "fix_date": "2011-10-28T06:36:57Z"
  },
  "references": [
    {
      "url": "http://www.openwall.com/lists/oss-security/2011/11/02/1",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2011/11/02/7",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://github.com/toastdriven/django-tastypie/commit/e8af315211b07c8f48f32a063233cc3f76dd5bc2",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://groups.google.com/forum/#%21topic/django-tastypie/i2aNGDHTUBI",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://www.djangoproject.com/weblog/2011/nov/01/piston-and-tastypie-security-releases/",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2011/11/02/1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2011/11/02/7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/toastdriven/django-tastypie/commit/e8af315211b07c8f48f32a063233cc3f76dd5bc2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://groups.google.com/forum/#%21topic/django-tastypie/i2aNGDHTUBI",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://www.djangoproject.com/weblog/2011/nov/01/piston-and-tastypie-security-releases/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:30.029486",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "django-tastypie",
    "owner": "toastdriven",
    "created_at": "2021-06-09T18:07:17Z",
    "updated_at": "2024-10-16T03:38:49Z",
    "pushed_at": "2021-06-03T20:14:03Z",
    "size": 2998,
    "stars": 6,
    "forks": 4,
    "open_issues": 0,
    "watchers": 6,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Python": 866602,
      "Shell": 1253,
      "HTML": 988
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T08:04:15.501324"
  }
}