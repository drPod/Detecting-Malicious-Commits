{
  "cve_id": "CVE-2011-4914",
  "github_data": {
    "repository": "torvalds/linux",
    "fix_commit": "e0bccd315db0c2f919e7fcf9cb60db21d9986f52",
    "related_commits": [
      "e0bccd315db0c2f919e7fcf9cb60db21d9986f52",
      "e0bccd315db0c2f919e7fcf9cb60db21d9986f52"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "e0bccd315db0c2f919e7fcf9cb60db21d9986f52",
      "commit_date": "2011-03-20T06:48:05Z",
      "author": {
        "login": "bwhacks",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "rose: Add length checks to CALL_REQUEST parsing",
        "length": 508,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 140,
        "additions": 93,
        "deletions": 47
      },
      "files": [
        {
          "filename": "include/net/rose.h",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -14,6 +14,12 @@\n \n #define\tROSE_MIN_LEN\t\t\t3\n \n+#define\tROSE_CALL_REQ_ADDR_LEN_OFF\t3\n+#define\tROSE_CALL_REQ_ADDR_LEN_VAL\t0xAA\t/* each address is 10 digits */\n+#define\tROSE_CALL_REQ_DEST_ADDR_OFF\t4\n+#define\tROSE_CALL_REQ_SRC_ADDR_OFF\t9\n+#define\tROSE_CALL_REQ_FACILITIES_OFF\t14\n+\n #define\tROSE_GFI\t\t\t0x10\n #define\tROSE_Q_BIT\t\t\t0x80\n #define\tROSE_D_BIT\t\t\t0x40\n@@ -214,7 +220,7 @@ extern void rose_requeue_frames(struct sock *);\n extern int  rose_validate_nr(struct sock *, unsigned short);\n extern void rose_write_internal(struct sock *, int);\n extern int  rose_decode(struct sk_buff *, int *, int *, int *, int *, int *);\n-extern int  rose_parse_facilities(unsigned char *, struct rose_facilities_struct *);\n+extern int  rose_parse_facilities(unsigned char *, unsigned int, struct rose_facilities_struct *);\n extern void rose_disconnect(struct sock *, int, int, int);\n \n /* rose_timer.c */"
        },
        {
          "filename": "net/rose/af_rose.c",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -978,7 +978,7 @@ int rose_rx_call_request(struct sk_buff *skb, struct net_device *dev, struct ros\n \tstruct sock *make;\n \tstruct rose_sock *make_rose;\n \tstruct rose_facilities_struct facilities;\n-\tint n, len;\n+\tint n;\n \n \tskb->sk = NULL;\t\t/* Initially we don't know who it's for */\n \n@@ -987,9 +987,9 @@ int rose_rx_call_request(struct sk_buff *skb, struct net_device *dev, struct ros\n \t */\n \tmemset(&facilities, 0x00, sizeof(struct rose_facilities_struct));\n \n-\tlen  = (((skb->data[3] >> 4) & 0x0F) + 1) >> 1;\n-\tlen += (((skb->data[3] >> 0) & 0x0F) + 1) >> 1;\n-\tif (!rose_parse_facilities(skb->data + len + 4, &facilities)) {\n+\tif (!rose_parse_facilities(skb->data + ROSE_CALL_REQ_FACILITIES_OFF,\n+\t\t\t\t   skb->len - ROSE_CALL_REQ_FACILITIES_OFF,\n+\t\t\t\t   &facilities)) {\n \t\trose_transmit_clear_request(neigh, lci, ROSE_INVALID_FACILITY, 76);\n \t\treturn 0;\n \t}"
        },
        {
          "filename": "net/rose/rose_loopback.c",
          "status": "modified",
          "additions": 12,
          "deletions": 1,
          "patch": "@@ -73,9 +73,20 @@ static void rose_loopback_timer(unsigned long param)\n \tunsigned int lci_i, lci_o;\n \n \twhile ((skb = skb_dequeue(&loopback_queue)) != NULL) {\n+\t\tif (skb->len < ROSE_MIN_LEN) {\n+\t\t\tkfree_skb(skb);\n+\t\t\tcontinue;\n+\t\t}\n \t\tlci_i     = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n \t\tframetype = skb->data[2];\n-\t\tdest      = (rose_address *)(skb->data + 4);\n+\t\tif (frametype == ROSE_CALL_REQUEST &&\n+\t\t    (skb->len <= ROSE_CALL_REQ_FACILITIES_OFF ||\n+\t\t     skb->data[ROSE_CALL_REQ_ADDR_LEN_OFF] !=\n+\t\t     ROSE_CALL_REQ_ADDR_LEN_VAL)) {\n+\t\t\tkfree_skb(skb);\n+\t\t\tcontinue;\n+\t\t}\n+\t\tdest      = (rose_address *)(skb->data + ROSE_CALL_REQ_DEST_ADDR_OFF);\n \t\tlci_o     = ROSE_DEFAULT_MAXVC + 1 - lci_i;\n \n \t\tskb_reset_transport_header(skb);"
        },
        {
          "filename": "net/rose/rose_route.c",
          "status": "modified",
          "additions": 13,
          "deletions": 7,
          "patch": "@@ -861,18 +861,25 @@ int rose_route_frame(struct sk_buff *skb, ax25_cb *ax25)\n \tunsigned int lci, new_lci;\n \tunsigned char cause, diagnostic;\n \tstruct net_device *dev;\n-\tint len, res = 0;\n+\tint res = 0;\n \tchar buf[11];\n \n #if 0\n \tif (call_in_firewall(PF_ROSE, skb->dev, skb->data, NULL, &skb) != FW_ACCEPT)\n \t\treturn res;\n #endif\n \n+\tif (skb->len < ROSE_MIN_LEN)\n+\t\treturn res;\n \tframetype = skb->data[2];\n \tlci = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n-\tsrc_addr  = (rose_address *)(skb->data + 9);\n-\tdest_addr = (rose_address *)(skb->data + 4);\n+\tif (frametype == ROSE_CALL_REQUEST &&\n+\t    (skb->len <= ROSE_CALL_REQ_FACILITIES_OFF ||\n+\t     skb->data[ROSE_CALL_REQ_ADDR_LEN_OFF] !=\n+\t     ROSE_CALL_REQ_ADDR_LEN_VAL))\n+\t\treturn res;\n+\tsrc_addr  = (rose_address *)(skb->data + ROSE_CALL_REQ_SRC_ADDR_OFF);\n+\tdest_addr = (rose_address *)(skb->data + ROSE_CALL_REQ_DEST_ADDR_OFF);\n \n \tspin_lock_bh(&rose_neigh_list_lock);\n \tspin_lock_bh(&rose_route_list_lock);\n@@ -1010,12 +1017,11 @@ int rose_route_frame(struct sk_buff *skb, ax25_cb *ax25)\n \t\tgoto out;\n \t}\n \n-\tlen  = (((skb->data[3] >> 4) & 0x0F) + 1) >> 1;\n-\tlen += (((skb->data[3] >> 0) & 0x0F) + 1) >> 1;\n-\n \tmemset(&facilities, 0x00, sizeof(struct rose_facilities_struct));\n \n-\tif (!rose_parse_facilities(skb->data + len + 4, &facilities)) {\n+\tif (!rose_parse_facilities(skb->data + ROSE_CALL_REQ_FACILITIES_OFF,\n+\t\t\t\t   skb->len - ROSE_CALL_REQ_FACILITIES_OFF,\n+\t\t\t\t   &facilities)) {\n \t\trose_transmit_clear_request(rose_neigh, lci, ROSE_INVALID_FACILITY, 76);\n \t\tgoto out;\n \t}"
        },
        {
          "filename": "net/rose/rose_subr.c",
          "status": "modified",
          "additions": 57,
          "deletions": 34,
          "patch": "@@ -142,7 +142,7 @@ void rose_write_internal(struct sock *sk, int frametype)\n \t\t*dptr++ = ROSE_GFI | lci1;\n \t\t*dptr++ = lci2;\n \t\t*dptr++ = frametype;\n-\t\t*dptr++ = 0xAA;\n+\t\t*dptr++ = ROSE_CALL_REQ_ADDR_LEN_VAL;\n \t\tmemcpy(dptr, &rose->dest_addr,  ROSE_ADDR_LEN);\n \t\tdptr   += ROSE_ADDR_LEN;\n \t\tmemcpy(dptr, &rose->source_addr, ROSE_ADDR_LEN);\n@@ -246,12 +246,16 @@ static int rose_parse_national(unsigned char *p, struct rose_facilities_struct *\n \tdo {\n \t\tswitch (*p & 0xC0) {\n \t\tcase 0x00:\n+\t\t\tif (len < 2)\n+\t\t\t\treturn -1;\n \t\t\tp   += 2;\n \t\t\tn   += 2;\n \t\t\tlen -= 2;\n \t\t\tbreak;\n \n \t\tcase 0x40:\n+\t\t\tif (len < 3)\n+\t\t\t\treturn -1;\n \t\t\tif (*p == FAC_NATIONAL_RAND)\n \t\t\t\tfacilities->rand = ((p[1] << 8) & 0xFF00) + ((p[2] << 0) & 0x00FF);\n \t\t\tp   += 3;\n@@ -260,32 +264,48 @@ static int rose_parse_national(unsigned char *p, struct rose_facilities_struct *\n \t\t\tbreak;\n \n \t\tcase 0x80:\n+\t\t\tif (len < 4)\n+\t\t\t\treturn -1;\n \t\t\tp   += 4;\n \t\t\tn   += 4;\n \t\t\tlen -= 4;\n \t\t\tbreak;\n \n \t\tcase 0xC0:\n+\t\t\tif (len < 2)\n+\t\t\t\treturn -1;\n \t\t\tl = p[1];\n+\t\t\tif (len < 2 + l)\n+\t\t\t\treturn -1;\n \t\t\tif (*p == FAC_NATIONAL_DEST_DIGI) {\n \t\t\t\tif (!fac_national_digis_received) {\n+\t\t\t\t\tif (l < AX25_ADDR_LEN)\n+\t\t\t\t\t\treturn -1;\n \t\t\t\t\tmemcpy(&facilities->source_digis[0], p + 2, AX25_ADDR_LEN);\n \t\t\t\t\tfacilities->source_ndigis = 1;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (*p == FAC_NATIONAL_SRC_DIGI) {\n \t\t\t\tif (!fac_national_digis_received) {\n+\t\t\t\t\tif (l < AX25_ADDR_LEN)\n+\t\t\t\t\t\treturn -1;\n \t\t\t\t\tmemcpy(&facilities->dest_digis[0], p + 2, AX25_ADDR_LEN);\n \t\t\t\t\tfacilities->dest_ndigis = 1;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (*p == FAC_NATIONAL_FAIL_CALL) {\n+\t\t\t\tif (l < AX25_ADDR_LEN)\n+\t\t\t\t\treturn -1;\n \t\t\t\tmemcpy(&facilities->fail_call, p + 2, AX25_ADDR_LEN);\n \t\t\t}\n \t\t\telse if (*p == FAC_NATIONAL_FAIL_ADD) {\n+\t\t\t\tif (l < 1 + ROSE_ADDR_LEN)\n+\t\t\t\t\treturn -1;\n \t\t\t\tmemcpy(&facilities->fail_addr, p + 3, ROSE_ADDR_LEN);\n \t\t\t}\n \t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n+\t\t\t\tif (l % AX25_ADDR_LEN)\n+\t\t\t\t\treturn -1;\n \t\t\t\tfac_national_digis_received = 1;\n \t\t\t\tfacilities->source_ndigis = 0;\n \t\t\t\tfacilities->dest_ndigis   = 0;\n@@ -319,24 +339,32 @@ static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *fac\n \tdo {\n \t\tswitch (*p & 0xC0) {\n \t\tcase 0x00:\n+\t\t\tif (len < 2)\n+\t\t\t\treturn -1;\n \t\t\tp   += 2;\n \t\t\tn   += 2;\n \t\t\tlen -= 2;\n \t\t\tbreak;\n \n \t\tcase 0x40:\n+\t\t\tif (len < 3)\n+\t\t\t\treturn -1;\n \t\t\tp   += 3;\n \t\t\tn   += 3;\n \t\t\tlen -= 3;\n \t\t\tbreak;\n \n \t\tcase 0x80:\n+\t\t\tif (len < 4)\n+\t\t\t\treturn -1;\n \t\t\tp   += 4;\n \t\t\tn   += 4;\n \t\t\tlen -= 4;\n \t\t\tbreak;\n \n \t\tcase 0xC0:\n+\t\t\tif (len < 2)\n+\t\t\t\treturn -1;\n \t\t\tl = p[1];\n \n \t\t\t/* Prevent overflows*/\n@@ -365,49 +393,44 @@ static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *fac\n \treturn n;\n }\n \n-int rose_parse_facilities(unsigned char *p,\n+int rose_parse_facilities(unsigned char *p, unsigned packet_len,\n \tstruct rose_facilities_struct *facilities)\n {\n \tint facilities_len, len;\n \n \tfacilities_len = *p++;\n \n-\tif (facilities_len == 0)\n+\tif (facilities_len == 0 || (unsigned)facilities_len > packet_len)\n \t\treturn 0;\n \n-\twhile (facilities_len > 0) {\n-\t\tif (*p == 0x00) {\n-\t\t\tfacilities_len--;\n-\t\t\tp++;\n-\n-\t\t\tswitch (*p) {\n-\t\t\tcase FAC_NATIONAL:\t\t/* National */\n-\t\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n-\t\t\t\tif (len < 0)\n-\t\t\t\t\treturn 0;\n-\t\t\t\tfacilities_len -= len + 1;\n-\t\t\t\tp += len + 1;\n-\t\t\t\tbreak;\n-\n-\t\t\tcase FAC_CCITT:\t\t/* CCITT */\n-\t\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n-\t\t\t\tif (len < 0)\n-\t\t\t\t\treturn 0;\n-\t\t\t\tfacilities_len -= len + 1;\n-\t\t\t\tp += len + 1;\n-\t\t\t\tbreak;\n-\n-\t\t\tdefault:\n-\t\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n-\t\t\t\tfacilities_len--;\n-\t\t\t\tp++;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t} else\n-\t\t\tbreak;\t/* Error in facilities format */\n+\twhile (facilities_len >= 3 && *p == 0x00) {\n+\t\tfacilities_len--;\n+\t\tp++;\n+\n+\t\tswitch (*p) {\n+\t\tcase FAC_NATIONAL:\t\t/* National */\n+\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n+\t\t\tbreak;\n+\n+\t\tcase FAC_CCITT:\t\t/* CCITT */\n+\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n+\t\t\tbreak;\n+\n+\t\tdefault:\n+\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n+\t\t\tlen = 1;\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tif (len < 0)\n+\t\t\treturn 0;\n+\t\tif (WARN_ON(len >= facilities_len))\n+\t\t\treturn 0;\n+\t\tfacilities_len -= len + 1;\n+\t\tp += len + 1;\n \t}\n \n-\treturn 1;\n+\treturn facilities_len == 0;\n }\n \n static int rose_create_facilities(unsigned char *buffer, struct rose_sock *rose)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "aa22f4da2a46b484a257d167c67a2adc1b7aaf68",
            "date": "2025-01-26T00:23:38Z",
            "author_login": "torvalds"
          },
          {
            "sha": "eda061cccd146fcbe71051bb4aa5a8672b71216e",
            "date": "2025-01-26T00:19:10Z",
            "author_login": "torvalds"
          },
          {
            "sha": "08de7f9d4d39fd9aa5e747a13acc891214fa2d5f",
            "date": "2025-01-26T00:12:07Z",
            "author_login": "torvalds"
          },
          {
            "sha": "647d69605c70368d54fc012fce8a43e8e5955b04",
            "date": "2025-01-26T00:03:40Z",
            "author_login": "torvalds"
          },
          {
            "sha": "184a0997fb77f4a9527fc867fcd16806776c27ce",
            "date": "2025-01-25T23:59:46Z",
            "author_login": "torvalds"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-20",
    "description": "The ROSE protocol implementation in the Linux kernel before 2.6.39 does not verify that certain data-length values are consistent with the amount of data sent, which might allow remote attackers to obtain sensitive information from kernel memory or cause a denial of service (out-of-bounds read) via crafted data to a ROSE socket.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2012-06-21T23:55:02.457",
    "last_modified": "2024-11-21T01:33:17.430",
    "fix_date": "2011-03-20T06:48:05Z"
  },
  "references": [
    {
      "url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39",
      "source": "secalert@redhat.com",
      "tags": [
        "Broken Link"
      ]
    },
    {
      "url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=e0bccd315db0c2f919e7fcf9cb60db21d9986f52",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00020.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2011/12/28/2",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=770777",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52",
      "source": "secalert@redhat.com",
      "tags": [
        "Exploit",
        "Patch"
      ]
    },
    {
      "url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Broken Link"
      ]
    },
    {
      "url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=e0bccd315db0c2f919e7fcf9cb60db21d9986f52",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00020.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2011/12/28/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=770777",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:07.281112",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "linux",
    "owner": "torvalds",
    "created_at": "2011-09-04T22:48:12Z",
    "updated_at": "2025-01-14T12:39:03Z",
    "pushed_at": "2025-01-13T17:27:04Z",
    "size": 5361369,
    "stars": 185823,
    "forks": 54743,
    "open_issues": 437,
    "watchers": 185823,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1326937103,
      "Assembly": 9568292,
      "Shell": 5072004,
      "Python": 2974128,
      "Makefile": 2713905,
      "Perl": 1253637,
      "Rust": 807711,
      "Roff": 202277,
      "C++": 173382,
      "SmPL": 165946,
      "Yacc": 127472,
      "Lex": 71321,
      "Awk": 69539,
      "Jinja": 30138,
      "UnrealScript": 16848,
      "Gherkin": 10172,
      "M4": 3329,
      "MATLAB": 2482,
      "sed": 2433,
      "Clojure": 2411,
      "XS": 1239,
      "RPC": 962
    },
    "commit_activity": {
      "total_commits_last_year": 46007,
      "avg_commits_per_week": 884.75,
      "days_active_last_year": 359
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T12:53:59.486675"
  }
}