{
  "cve_id": "CVE-2012-1179",
  "github_data": {
    "repository": "torvalds/linux",
    "fix_commit": "4a1d704194a441bf83c636004a479e01360ec850",
    "related_commits": [
      "4a1d704194a441bf83c636004a479e01360ec850",
      "4a1d704194a441bf83c636004a479e01360ec850"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "4a1d704194a441bf83c636004a479e01360ec850",
      "commit_date": "2012-03-21T23:33:42Z",
      "author": {
        "login": "aagit",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "mm: thp: fix pmd_bad() triggering in code paths holding mmap_sem read mode",
        "length": 9279,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 102,
        "additions": 92,
        "deletions": 10
      },
      "files": [
        {
          "filename": "arch/x86/kernel/vm86_32.c",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -172,6 +172,7 @@ static void mark_screen_rdonly(struct mm_struct *mm)\n \tspinlock_t *ptl;\n \tint i;\n \n+\tdown_write(&mm->mmap_sem);\n \tpgd = pgd_offset(mm, 0xA0000);\n \tif (pgd_none_or_clear_bad(pgd))\n \t\tgoto out;\n@@ -190,6 +191,7 @@ static void mark_screen_rdonly(struct mm_struct *mm)\n \t}\n \tpte_unmap_unlock(pte, ptl);\n out:\n+\tup_write(&mm->mmap_sem);\n \tflush_tlb();\n }\n "
        },
        {
          "filename": "fs/proc/task_mmu.c",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -409,6 +409,9 @@ static int smaps_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n \t} else {\n \t\tspin_unlock(&walk->mm->page_table_lock);\n \t}\n+\n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n \t/*\n \t * The mmap_sem held all the way back in m_start() is what\n \t * keeps khugepaged out of here and from collapsing things\n@@ -507,6 +510,8 @@ static int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,\n \tstruct page *page;\n \n \tsplit_huge_page_pmd(walk->mm, pmd);\n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n \n \tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n \tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n@@ -670,6 +675,8 @@ static int pagemap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n \tint err = 0;\n \n \tsplit_huge_page_pmd(walk->mm, pmd);\n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n \n \t/* find the first VMA at or above 'addr' */\n \tvma = find_vma(walk->mm, addr);\n@@ -961,6 +968,8 @@ static int gather_pte_stats(pmd_t *pmd, unsigned long addr,\n \t\tspin_unlock(&walk->mm->page_table_lock);\n \t}\n \n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n \torig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n \tdo {\n \t\tstruct page *page = can_gather_numa_stats(*pte, md->vma, addr);"
        },
        {
          "filename": "include/asm-generic/pgtable.h",
          "status": "modified",
          "additions": 61,
          "deletions": 0,
          "patch": "@@ -425,6 +425,8 @@ extern void untrack_pfn_vma(struct vm_area_struct *vma, unsigned long pfn,\n \t\t\t\tunsigned long size);\n #endif\n \n+#ifdef CONFIG_MMU\n+\n #ifndef CONFIG_TRANSPARENT_HUGEPAGE\n static inline int pmd_trans_huge(pmd_t pmd)\n {\n@@ -441,7 +443,66 @@ static inline int pmd_write(pmd_t pmd)\n \treturn 0;\n }\n #endif /* __HAVE_ARCH_PMD_WRITE */\n+#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n+\n+/*\n+ * This function is meant to be used by sites walking pagetables with\n+ * the mmap_sem hold in read mode to protect against MADV_DONTNEED and\n+ * transhuge page faults. MADV_DONTNEED can convert a transhuge pmd\n+ * into a null pmd and the transhuge page fault can convert a null pmd\n+ * into an hugepmd or into a regular pmd (if the hugepage allocation\n+ * fails). While holding the mmap_sem in read mode the pmd becomes\n+ * stable and stops changing under us only if it's not null and not a\n+ * transhuge pmd. When those races occurs and this function makes a\n+ * difference vs the standard pmd_none_or_clear_bad, the result is\n+ * undefined so behaving like if the pmd was none is safe (because it\n+ * can return none anyway). The compiler level barrier() is critically\n+ * important to compute the two checks atomically on the same pmdval.\n+ */\n+static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n+{\n+\t/* depend on compiler for an atomic pmd read */\n+\tpmd_t pmdval = *pmd;\n+\t/*\n+\t * The barrier will stabilize the pmdval in a register or on\n+\t * the stack so that it will stop changing under the code.\n+\t */\n+#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n+\tbarrier();\n+#endif\n+\tif (pmd_none(pmdval))\n+\t\treturn 1;\n+\tif (unlikely(pmd_bad(pmdval))) {\n+\t\tif (!pmd_trans_huge(pmdval))\n+\t\t\tpmd_clear_bad(pmd);\n+\t\treturn 1;\n+\t}\n+\treturn 0;\n+}\n+\n+/*\n+ * This is a noop if Transparent Hugepage Support is not built into\n+ * the kernel. Otherwise it is equivalent to\n+ * pmd_none_or_trans_huge_or_clear_bad(), and shall only be called in\n+ * places that already verified the pmd is not none and they want to\n+ * walk ptes while holding the mmap sem in read mode (write mode don't\n+ * need this). If THP is not enabled, the pmd can't go away under the\n+ * code even if MADV_DONTNEED runs, but if THP is enabled we need to\n+ * run a pmd_trans_unstable before walking the ptes after\n+ * split_huge_page_pmd returns (because it may have run when the pmd\n+ * become null, but then a page fault can map in a THP and not a\n+ * regular page).\n+ */\n+static inline int pmd_trans_unstable(pmd_t *pmd)\n+{\n+#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n+\treturn pmd_none_or_trans_huge_or_clear_bad(pmd);\n+#else\n+\treturn 0;\n #endif\n+}\n+\n+#endif /* CONFIG_MMU */\n \n #endif /* !__ASSEMBLY__ */\n "
        },
        {
          "filename": "mm/memcontrol.c",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -5234,6 +5234,8 @@ static int mem_cgroup_count_precharge_pte_range(pmd_t *pmd,\n \tspinlock_t *ptl;\n \n \tsplit_huge_page_pmd(walk->mm, pmd);\n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n \n \tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n \tfor (; addr != end; pte++, addr += PAGE_SIZE)\n@@ -5396,6 +5398,8 @@ static int mem_cgroup_move_charge_pte_range(pmd_t *pmd,\n \tspinlock_t *ptl;\n \n \tsplit_huge_page_pmd(walk->mm, pmd);\n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n retry:\n \tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n \tfor (; addr != end; addr += PAGE_SIZE) {"
        },
        {
          "filename": "mm/memory.c",
          "status": "modified",
          "additions": 12,
          "deletions": 4,
          "patch": "@@ -1247,16 +1247,24 @@ static inline unsigned long zap_pmd_range(struct mmu_gather *tlb,\n \tdo {\n \t\tnext = pmd_addr_end(addr, end);\n \t\tif (pmd_trans_huge(*pmd)) {\n-\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n+\t\t\tif (next - addr != HPAGE_PMD_SIZE) {\n \t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n \t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n \t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n-\t\t\t\tcontinue;\n+\t\t\t\tgoto next;\n \t\t\t/* fall through */\n \t\t}\n-\t\tif (pmd_none_or_clear_bad(pmd))\n-\t\t\tcontinue;\n+\t\t/*\n+\t\t * Here there can be other concurrent MADV_DONTNEED or\n+\t\t * trans huge page faults running, and if the pmd is\n+\t\t * none or trans huge it can change under us. This is\n+\t\t * because MADV_DONTNEED holds the mmap_sem in read\n+\t\t * mode.\n+\t\t */\n+\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n+\t\t\tgoto next;\n \t\tnext = zap_pte_range(tlb, vma, pmd, addr, next, details);\n+next:\n \t\tcond_resched();\n \t} while (pmd++, addr = next, addr != end);\n "
        },
        {
          "filename": "mm/mempolicy.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -512,7 +512,7 @@ static inline int check_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n \tdo {\n \t\tnext = pmd_addr_end(addr, end);\n \t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n-\t\tif (pmd_none_or_clear_bad(pmd))\n+\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n \t\t\tcontinue;\n \t\tif (check_pte_range(vma, pmd, addr, next, nodes,\n \t\t\t\t    flags, private))"
        },
        {
          "filename": "mm/mincore.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -164,7 +164,7 @@ static void mincore_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n \t\t\t}\n \t\t\t/* fall through */\n \t\t}\n-\t\tif (pmd_none_or_clear_bad(pmd))\n+\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n \t\t\tmincore_unmapped_range(vma, addr, next, vec);\n \t\telse\n \t\t\tmincore_pte_range(vma, pmd, addr, next, vec);"
        },
        {
          "filename": "mm/pagewalk.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -59,7 +59,7 @@ static int walk_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,\n \t\t\tcontinue;\n \n \t\tsplit_huge_page_pmd(walk->mm, pmd);\n-\t\tif (pmd_none_or_clear_bad(pmd))\n+\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n \t\t\tgoto again;\n \t\terr = walk_pte_range(pmd, addr, next, walk);\n \t\tif (err)"
        },
        {
          "filename": "mm/swapfile.c",
          "status": "modified",
          "additions": 1,
          "deletions": 3,
          "patch": "@@ -932,9 +932,7 @@ static inline int unuse_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n \tpmd = pmd_offset(pud, addr);\n \tdo {\n \t\tnext = pmd_addr_end(addr, end);\n-\t\tif (unlikely(pmd_trans_huge(*pmd)))\n-\t\t\tcontinue;\n-\t\tif (pmd_none_or_clear_bad(pmd))\n+\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n \t\t\tcontinue;\n \t\tret = unuse_pte_range(vma, pmd, addr, next, entry, page);\n \t\tif (ret)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "aa22f4da2a46b484a257d167c67a2adc1b7aaf68",
            "date": "2025-01-26T00:23:38Z",
            "author_login": "torvalds"
          },
          {
            "sha": "eda061cccd146fcbe71051bb4aa5a8672b71216e",
            "date": "2025-01-26T00:19:10Z",
            "author_login": "torvalds"
          },
          {
            "sha": "08de7f9d4d39fd9aa5e747a13acc891214fa2d5f",
            "date": "2025-01-26T00:12:07Z",
            "author_login": "torvalds"
          },
          {
            "sha": "647d69605c70368d54fc012fce8a43e8e5955b04",
            "date": "2025-01-26T00:03:40Z",
            "author_login": "torvalds"
          },
          {
            "sha": "184a0997fb77f4a9527fc867fcd16806776c27ce",
            "date": "2025-01-25T23:59:46Z",
            "author_login": "torvalds"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-264",
    "description": "The Linux kernel before 3.3.1, when KVM is used, allows guest OS users to cause a denial of service (host OS crash) by leveraging administrative access to the guest OS, related to the pmd_none_or_clear_bad function and page faults for huge pages.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2012-05-17T11:00:37.587",
    "last_modified": "2024-11-21T01:36:36.260",
    "fix_date": "2012-03-21T23:33:42Z"
  },
  "references": [
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-March/075781.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2012-04/msg00021.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://marc.info/?l=bugtraq&m=139447903326211&w=2",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2012-0743.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://secunia.com/advisories/48404",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://secunia.com/advisories/48898",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.3.1",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2012/03/15/7",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.securitytracker.com/id?1027084",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=803793",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-March/075781.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2012-04/msg00021.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://marc.info/?l=bugtraq&m=139447903326211&w=2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2012-0743.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://secunia.com/advisories/48404",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://secunia.com/advisories/48898",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.3.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2012/03/15/7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securitytracker.com/id?1027084",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=803793",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:07.263802",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "linux",
    "owner": "torvalds",
    "created_at": "2011-09-04T22:48:12Z",
    "updated_at": "2025-01-26T06:54:23Z",
    "pushed_at": "2025-01-26T01:00:03Z",
    "size": 5386838,
    "stars": 186472,
    "forks": 54875,
    "open_issues": 441,
    "watchers": 186472,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1331921668,
      "Assembly": 9611819,
      "Shell": 5108035,
      "Python": 2992085,
      "Makefile": 2706967,
      "Perl": 1253833,
      "Rust": 816450,
      "Roff": 202277,
      "C++": 173994,
      "SmPL": 165946,
      "Yacc": 127472,
      "Lex": 71397,
      "Awk": 69555,
      "Jinja": 30138,
      "UnrealScript": 16848,
      "Gherkin": 10902,
      "M4": 3329,
      "MATLAB": 2482,
      "Clojure": 2442,
      "sed": 2433,
      "XS": 1239,
      "RPC": 962
    },
    "commit_activity": {
      "total_commits_last_year": 48379,
      "avg_commits_per_week": 930.3653846153846,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T07:34:00.817711"
  }
}