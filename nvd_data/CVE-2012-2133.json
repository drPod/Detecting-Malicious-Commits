{
  "cve_id": "CVE-2012-2133",
  "github_data": {
    "repository": "torvalds/linux",
    "fix_commit": "90481622d75715bfcb68501280a917dbfe516029",
    "related_commits": [
      "90481622d75715bfcb68501280a917dbfe516029",
      "90481622d75715bfcb68501280a917dbfe516029"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "90481622d75715bfcb68501280a917dbfe516029",
      "commit_date": "2012-03-21T23:34:12Z",
      "author": {
        "login": "dgibson",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "hugepages: fix use after free bug in \"quota\" handling",
        "length": 2866,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 203,
        "additions": 139,
        "deletions": 64
      },
      "files": [
        {
          "filename": "fs/hugetlbfs/inode.c",
          "status": "modified",
          "additions": 21,
          "deletions": 33,
          "patch": "@@ -626,9 +626,15 @@ static int hugetlbfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n \t\tspin_lock(&sbinfo->stat_lock);\n \t\t/* If no limits set, just report 0 for max/free/used\n \t\t * blocks, like simple_statfs() */\n-\t\tif (sbinfo->max_blocks >= 0) {\n-\t\t\tbuf->f_blocks = sbinfo->max_blocks;\n-\t\t\tbuf->f_bavail = buf->f_bfree = sbinfo->free_blocks;\n+\t\tif (sbinfo->spool) {\n+\t\t\tlong free_pages;\n+\n+\t\t\tspin_lock(&sbinfo->spool->lock);\n+\t\t\tbuf->f_blocks = sbinfo->spool->max_hpages;\n+\t\t\tfree_pages = sbinfo->spool->max_hpages\n+\t\t\t\t- sbinfo->spool->used_hpages;\n+\t\t\tbuf->f_bavail = buf->f_bfree = free_pages;\n+\t\t\tspin_unlock(&sbinfo->spool->lock);\n \t\t\tbuf->f_files = sbinfo->max_inodes;\n \t\t\tbuf->f_ffree = sbinfo->free_inodes;\n \t\t}\n@@ -644,6 +650,10 @@ static void hugetlbfs_put_super(struct super_block *sb)\n \n \tif (sbi) {\n \t\tsb->s_fs_info = NULL;\n+\n+\t\tif (sbi->spool)\n+\t\t\thugepage_put_subpool(sbi->spool);\n+\n \t\tkfree(sbi);\n \t}\n }\n@@ -874,10 +884,14 @@ hugetlbfs_fill_super(struct super_block *sb, void *data, int silent)\n \tsb->s_fs_info = sbinfo;\n \tsbinfo->hstate = config.hstate;\n \tspin_lock_init(&sbinfo->stat_lock);\n-\tsbinfo->max_blocks = config.nr_blocks;\n-\tsbinfo->free_blocks = config.nr_blocks;\n \tsbinfo->max_inodes = config.nr_inodes;\n \tsbinfo->free_inodes = config.nr_inodes;\n+\tsbinfo->spool = NULL;\n+\tif (config.nr_blocks != -1) {\n+\t\tsbinfo->spool = hugepage_new_subpool(config.nr_blocks);\n+\t\tif (!sbinfo->spool)\n+\t\t\tgoto out_free;\n+\t}\n \tsb->s_maxbytes = MAX_LFS_FILESIZE;\n \tsb->s_blocksize = huge_page_size(config.hstate);\n \tsb->s_blocksize_bits = huge_page_shift(config.hstate);\n@@ -896,38 +910,12 @@ hugetlbfs_fill_super(struct super_block *sb, void *data, int silent)\n \tsb->s_root = root;\n \treturn 0;\n out_free:\n+\tif (sbinfo->spool)\n+\t\tkfree(sbinfo->spool);\n \tkfree(sbinfo);\n \treturn -ENOMEM;\n }\n \n-int hugetlb_get_quota(struct address_space *mapping, long delta)\n-{\n-\tint ret = 0;\n-\tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);\n-\n-\tif (sbinfo->free_blocks > -1) {\n-\t\tspin_lock(&sbinfo->stat_lock);\n-\t\tif (sbinfo->free_blocks - delta >= 0)\n-\t\t\tsbinfo->free_blocks -= delta;\n-\t\telse\n-\t\t\tret = -ENOMEM;\n-\t\tspin_unlock(&sbinfo->stat_lock);\n-\t}\n-\n-\treturn ret;\n-}\n-\n-void hugetlb_put_quota(struct address_space *mapping, long delta)\n-{\n-\tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);\n-\n-\tif (sbinfo->free_blocks > -1) {\n-\t\tspin_lock(&sbinfo->stat_lock);\n-\t\tsbinfo->free_blocks += delta;\n-\t\tspin_unlock(&sbinfo->stat_lock);\n-\t}\n-}\n-\n static struct dentry *hugetlbfs_mount(struct file_system_type *fs_type,\n \tint flags, const char *dev_name, void *data)\n {"
        },
        {
          "filename": "include/linux/hugetlb.h",
          "status": "modified",
          "additions": 10,
          "deletions": 4,
          "patch": "@@ -14,6 +14,15 @@ struct user_struct;\n #include <linux/shm.h>\n #include <asm/tlbflush.h>\n \n+struct hugepage_subpool {\n+\tspinlock_t lock;\n+\tlong count;\n+\tlong max_hpages, used_hpages;\n+};\n+\n+struct hugepage_subpool *hugepage_new_subpool(long nr_blocks);\n+void hugepage_put_subpool(struct hugepage_subpool *spool);\n+\n int PageHuge(struct page *page);\n \n void reset_vma_resv_huge_pages(struct vm_area_struct *vma);\n@@ -129,12 +138,11 @@ enum {\n \n #ifdef CONFIG_HUGETLBFS\n struct hugetlbfs_sb_info {\n-\tlong\tmax_blocks;   /* blocks allowed */\n-\tlong\tfree_blocks;  /* blocks free */\n \tlong\tmax_inodes;   /* inodes allowed */\n \tlong\tfree_inodes;  /* inodes free */\n \tspinlock_t\tstat_lock;\n \tstruct hstate *hstate;\n+\tstruct hugepage_subpool *spool;\n };\n \n static inline struct hugetlbfs_sb_info *HUGETLBFS_SB(struct super_block *sb)\n@@ -146,8 +154,6 @@ extern const struct file_operations hugetlbfs_file_operations;\n extern const struct vm_operations_struct hugetlb_vm_ops;\n struct file *hugetlb_file_setup(const char *name, size_t size, vm_flags_t acct,\n \t\t\t\tstruct user_struct **user, int creat_flags);\n-int hugetlb_get_quota(struct address_space *mapping, long delta);\n-void hugetlb_put_quota(struct address_space *mapping, long delta);\n \n static inline int is_file_hugepages(struct file *file)\n {"
        },
        {
          "filename": "mm/hugetlb.c",
          "status": "modified",
          "additions": 108,
          "deletions": 27,
          "patch": "@@ -53,6 +53,84 @@ static unsigned long __initdata default_hstate_size;\n  */\n static DEFINE_SPINLOCK(hugetlb_lock);\n \n+static inline void unlock_or_release_subpool(struct hugepage_subpool *spool)\n+{\n+\tbool free = (spool->count == 0) && (spool->used_hpages == 0);\n+\n+\tspin_unlock(&spool->lock);\n+\n+\t/* If no pages are used, and no other handles to the subpool\n+\t * remain, free the subpool the subpool remain */\n+\tif (free)\n+\t\tkfree(spool);\n+}\n+\n+struct hugepage_subpool *hugepage_new_subpool(long nr_blocks)\n+{\n+\tstruct hugepage_subpool *spool;\n+\n+\tspool = kmalloc(sizeof(*spool), GFP_KERNEL);\n+\tif (!spool)\n+\t\treturn NULL;\n+\n+\tspin_lock_init(&spool->lock);\n+\tspool->count = 1;\n+\tspool->max_hpages = nr_blocks;\n+\tspool->used_hpages = 0;\n+\n+\treturn spool;\n+}\n+\n+void hugepage_put_subpool(struct hugepage_subpool *spool)\n+{\n+\tspin_lock(&spool->lock);\n+\tBUG_ON(!spool->count);\n+\tspool->count--;\n+\tunlock_or_release_subpool(spool);\n+}\n+\n+static int hugepage_subpool_get_pages(struct hugepage_subpool *spool,\n+\t\t\t\t      long delta)\n+{\n+\tint ret = 0;\n+\n+\tif (!spool)\n+\t\treturn 0;\n+\n+\tspin_lock(&spool->lock);\n+\tif ((spool->used_hpages + delta) <= spool->max_hpages) {\n+\t\tspool->used_hpages += delta;\n+\t} else {\n+\t\tret = -ENOMEM;\n+\t}\n+\tspin_unlock(&spool->lock);\n+\n+\treturn ret;\n+}\n+\n+static void hugepage_subpool_put_pages(struct hugepage_subpool *spool,\n+\t\t\t\t       long delta)\n+{\n+\tif (!spool)\n+\t\treturn;\n+\n+\tspin_lock(&spool->lock);\n+\tspool->used_hpages -= delta;\n+\t/* If hugetlbfs_put_super couldn't free spool due to\n+\t* an outstanding quota reference, free it now. */\n+\tunlock_or_release_subpool(spool);\n+}\n+\n+static inline struct hugepage_subpool *subpool_inode(struct inode *inode)\n+{\n+\treturn HUGETLBFS_SB(inode->i_sb)->spool;\n+}\n+\n+static inline struct hugepage_subpool *subpool_vma(struct vm_area_struct *vma)\n+{\n+\treturn subpool_inode(vma->vm_file->f_dentry->d_inode);\n+}\n+\n /*\n  * Region tracking -- allows tracking of reservations and instantiated pages\n  *                    across the pages in a mapping.\n@@ -540,9 +618,9 @@ static void free_huge_page(struct page *page)\n \t */\n \tstruct hstate *h = page_hstate(page);\n \tint nid = page_to_nid(page);\n-\tstruct address_space *mapping;\n+\tstruct hugepage_subpool *spool =\n+\t\t(struct hugepage_subpool *)page_private(page);\n \n-\tmapping = (struct address_space *) page_private(page);\n \tset_page_private(page, 0);\n \tpage->mapping = NULL;\n \tBUG_ON(page_count(page));\n@@ -558,8 +636,7 @@ static void free_huge_page(struct page *page)\n \t\tenqueue_huge_page(h, page);\n \t}\n \tspin_unlock(&hugetlb_lock);\n-\tif (mapping)\n-\t\thugetlb_put_quota(mapping, 1);\n+\thugepage_subpool_put_pages(spool, 1);\n }\n \n static void prep_new_huge_page(struct hstate *h, struct page *page, int nid)\n@@ -977,11 +1054,12 @@ static void return_unused_surplus_pages(struct hstate *h,\n /*\n  * Determine if the huge page at addr within the vma has an associated\n  * reservation.  Where it does not we will need to logically increase\n- * reservation and actually increase quota before an allocation can occur.\n- * Where any new reservation would be required the reservation change is\n- * prepared, but not committed.  Once the page has been quota'd allocated\n- * an instantiated the change should be committed via vma_commit_reservation.\n- * No action is required on failure.\n+ * reservation and actually increase subpool usage before an allocation\n+ * can occur.  Where any new reservation would be required the\n+ * reservation change is prepared, but not committed.  Once the page\n+ * has been allocated from the subpool and instantiated the change should\n+ * be committed via vma_commit_reservation.  No action is required on\n+ * failure.\n  */\n static long vma_needs_reservation(struct hstate *h,\n \t\t\tstruct vm_area_struct *vma, unsigned long addr)\n@@ -1030,24 +1108,24 @@ static void vma_commit_reservation(struct hstate *h,\n static struct page *alloc_huge_page(struct vm_area_struct *vma,\n \t\t\t\t    unsigned long addr, int avoid_reserve)\n {\n+\tstruct hugepage_subpool *spool = subpool_vma(vma);\n \tstruct hstate *h = hstate_vma(vma);\n \tstruct page *page;\n-\tstruct address_space *mapping = vma->vm_file->f_mapping;\n-\tstruct inode *inode = mapping->host;\n \tlong chg;\n \n \t/*\n-\t * Processes that did not create the mapping will have no reserves and\n-\t * will not have accounted against quota. Check that the quota can be\n-\t * made before satisfying the allocation\n-\t * MAP_NORESERVE mappings may also need pages and quota allocated\n-\t * if no reserve mapping overlaps.\n+\t * Processes that did not create the mapping will have no\n+\t * reserves and will not have accounted against subpool\n+\t * limit. Check that the subpool limit can be made before\n+\t * satisfying the allocation MAP_NORESERVE mappings may also\n+\t * need pages and subpool limit allocated allocated if no reserve\n+\t * mapping overlaps.\n \t */\n \tchg = vma_needs_reservation(h, vma, addr);\n \tif (chg < 0)\n \t\treturn ERR_PTR(-VM_FAULT_OOM);\n \tif (chg)\n-\t\tif (hugetlb_get_quota(inode->i_mapping, chg))\n+\t\tif (hugepage_subpool_get_pages(spool, chg))\n \t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n \n \tspin_lock(&hugetlb_lock);\n@@ -1057,12 +1135,12 @@ static struct page *alloc_huge_page(struct vm_area_struct *vma,\n \tif (!page) {\n \t\tpage = alloc_buddy_huge_page(h, NUMA_NO_NODE);\n \t\tif (!page) {\n-\t\t\thugetlb_put_quota(inode->i_mapping, chg);\n+\t\t\thugepage_subpool_put_pages(spool, chg);\n \t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n \t\t}\n \t}\n \n-\tset_page_private(page, (unsigned long) mapping);\n+\tset_page_private(page, (unsigned long)spool);\n \n \tvma_commit_reservation(h, vma, addr);\n \n@@ -2083,6 +2161,7 @@ static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n {\n \tstruct hstate *h = hstate_vma(vma);\n \tstruct resv_map *reservations = vma_resv_map(vma);\n+\tstruct hugepage_subpool *spool = subpool_vma(vma);\n \tunsigned long reserve;\n \tunsigned long start;\n \tunsigned long end;\n@@ -2098,7 +2177,7 @@ static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n \n \t\tif (reserve) {\n \t\t\thugetlb_acct_memory(h, -reserve);\n-\t\t\thugetlb_put_quota(vma->vm_file->f_mapping, reserve);\n+\t\t\thugepage_subpool_put_pages(spool, reserve);\n \t\t}\n \t}\n }\n@@ -2331,7 +2410,7 @@ static int unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,\n \t */\n \taddress = address & huge_page_mask(h);\n \tpgoff = vma_hugecache_offset(h, vma, address);\n-\tmapping = (struct address_space *)page_private(page);\n+\tmapping = vma->vm_file->f_dentry->d_inode->i_mapping;\n \n \t/*\n \t * Take the mapping lock for the duration of the table walk. As\n@@ -2884,11 +2963,12 @@ int hugetlb_reserve_pages(struct inode *inode,\n {\n \tlong ret, chg;\n \tstruct hstate *h = hstate_inode(inode);\n+\tstruct hugepage_subpool *spool = subpool_inode(inode);\n \n \t/*\n \t * Only apply hugepage reservation if asked. At fault time, an\n \t * attempt will be made for VM_NORESERVE to allocate a page\n-\t * and filesystem quota without using reserves\n+\t * without using reserves\n \t */\n \tif (vm_flags & VM_NORESERVE)\n \t\treturn 0;\n@@ -2915,17 +2995,17 @@ int hugetlb_reserve_pages(struct inode *inode,\n \tif (chg < 0)\n \t\treturn chg;\n \n-\t/* There must be enough filesystem quota for the mapping */\n-\tif (hugetlb_get_quota(inode->i_mapping, chg))\n+\t/* There must be enough pages in the subpool for the mapping */\n+\tif (hugepage_subpool_get_pages(spool, chg))\n \t\treturn -ENOSPC;\n \n \t/*\n \t * Check enough hugepages are available for the reservation.\n-\t * Hand back the quota if there are not\n+\t * Hand the pages back to the subpool if there are not\n \t */\n \tret = hugetlb_acct_memory(h, chg);\n \tif (ret < 0) {\n-\t\thugetlb_put_quota(inode->i_mapping, chg);\n+\t\thugepage_subpool_put_pages(spool, chg);\n \t\treturn ret;\n \t}\n \n@@ -2949,12 +3029,13 @@ void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed)\n {\n \tstruct hstate *h = hstate_inode(inode);\n \tlong chg = region_truncate(&inode->i_mapping->private_list, offset);\n+\tstruct hugepage_subpool *spool = subpool_inode(inode);\n \n \tspin_lock(&inode->i_lock);\n \tinode->i_blocks -= (blocks_per_huge_page(h) * freed);\n \tspin_unlock(&inode->i_lock);\n \n-\thugetlb_put_quota(inode->i_mapping, (chg - freed));\n+\thugepage_subpool_put_pages(spool, (chg - freed));\n \thugetlb_acct_memory(h, -(chg - freed));\n }\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "aa22f4da2a46b484a257d167c67a2adc1b7aaf68",
            "date": "2025-01-26T00:23:38Z",
            "author_login": "torvalds"
          },
          {
            "sha": "eda061cccd146fcbe71051bb4aa5a8672b71216e",
            "date": "2025-01-26T00:19:10Z",
            "author_login": "torvalds"
          },
          {
            "sha": "08de7f9d4d39fd9aa5e747a13acc891214fa2d5f",
            "date": "2025-01-26T00:12:07Z",
            "author_login": "torvalds"
          },
          {
            "sha": "647d69605c70368d54fc012fce8a43e8e5955b04",
            "date": "2025-01-26T00:03:40Z",
            "author_login": "torvalds"
          },
          {
            "sha": "184a0997fb77f4a9527fc867fcd16806776c27ce",
            "date": "2025-01-25T23:59:46Z",
            "author_login": "torvalds"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-399",
    "description": "Use-after-free vulnerability in the Linux kernel before 3.3.6, when huge pages are enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges by interacting with a hugetlbfs filesystem, as demonstrated by a umount operation that triggers improper handling of quota data.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2012-07-03T16:40:32.117",
    "last_modified": "2024-11-21T01:38:34.043",
    "fix_date": "2012-03-21T23:34:12Z"
  },
  "references": [
    {
      "url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=90481622d75715bfcb68501280a917dbfe516029",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2012-05/msg00013.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2012/dsa-2469",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.3.6",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2012/04/24/12",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/53233",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=817430",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/75168",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=90481622d75715bfcb68501280a917dbfe516029",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2012-05/msg00013.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2012/dsa-2469",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.3.6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2012/04/24/12",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/53233",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=817430",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/75168",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:07.284763",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "linux",
    "owner": "torvalds",
    "created_at": "2011-09-04T22:48:12Z",
    "updated_at": "2025-01-26T06:54:23Z",
    "pushed_at": "2025-01-26T01:00:03Z",
    "size": 5386838,
    "stars": 186472,
    "forks": 54875,
    "open_issues": 441,
    "watchers": 186472,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1331921668,
      "Assembly": 9611819,
      "Shell": 5108035,
      "Python": 2992085,
      "Makefile": 2706967,
      "Perl": 1253833,
      "Rust": 816450,
      "Roff": 202277,
      "C++": 173994,
      "SmPL": 165946,
      "Yacc": 127472,
      "Lex": 71397,
      "Awk": 69555,
      "Jinja": 30138,
      "UnrealScript": 16848,
      "Gherkin": 10902,
      "M4": 3329,
      "MATLAB": 2482,
      "Clojure": 2442,
      "sed": 2433,
      "XS": 1239,
      "RPC": 962
    },
    "commit_activity": {
      "total_commits_last_year": 48379,
      "avg_commits_per_week": 930.3653846153846,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T07:34:00.817711"
  }
}