{
  "cve_id": "CVE-2012-3864",
  "github_data": {
    "repository": "puppetlabs/puppet",
    "fix_commit": "10f6cb8969b4d5a933b333ecb01ce3696b1d57d4",
    "related_commits": [
      "10f6cb8969b4d5a933b333ecb01ce3696b1d57d4",
      "c3c7462e4066bf3a563987a402bf3ddf278bcd87",
      "10f6cb8969b4d5a933b333ecb01ce3696b1d57d4",
      "c3c7462e4066bf3a563987a402bf3ddf278bcd87"
    ],
    "patch_url": "https://github.com/puppetlabs/puppet/commit/10f6cb8969b4d5a933b333ecb01ce3696b1d57d4.patch",
    "fix_commit_details": {
      "sha": "10f6cb8969b4d5a933b333ecb01ce3696b1d57d4",
      "commit_date": "2012-06-21T22:52:58Z",
      "author": {
        "login": "pcarlisle",
        "type": "User",
        "stats": {
          "total_commits": 636,
          "average_weekly_commits": 0.6162790697674418,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 119
        }
      },
      "commit_message": {
        "title": "Add Selector terminus for file_content/file_metadata",
        "length": 507,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 113,
        "additions": 79,
        "deletions": 34
      },
      "files": [
        {
          "filename": "lib/puppet/application/master.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -231,6 +231,9 @@ def setup\n     # Cache our nodes in yaml.  Currently not configurable.\n     Puppet::Node.indirection.cache_class = :yaml\n \n+    Puppet::FileServing::Content.indirection.terminus_class = :file_server\n+    Puppet::FileServing::Metadata.indirection.terminus_class = :file_server\n+\n     # Configure all of the SSL stuff.\n     if Puppet::SSL::CertificateAuthority.ca?\n       Puppet::SSL::Host.ca_location = :local"
        },
        {
          "filename": "lib/puppet/file_serving/configuration.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -64,7 +64,7 @@ def split_path(request)\n \n     mount_name, path = request.key.split(File::Separator, 2)\n \n-    raise(ArgumentError, \"Cannot find file: Invalid path '#{mount_name}'\") unless mount_name =~ %r{^[-\\w]+$}\n+    raise(ArgumentError, \"Cannot find file: Invalid mount '#{mount_name}'\") unless mount_name =~ %r{^[-\\w]+$}\n \n     return nil unless mount = find_mount(mount_name, request.environment)\n     if mount.name == \"modules\" and mount_name != \"modules\""
        },
        {
          "filename": "lib/puppet/file_serving/content.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -1,14 +1,13 @@\n require 'puppet/indirector'\n require 'puppet/file_serving'\n require 'puppet/file_serving/base'\n-require 'puppet/file_serving/indirection_hooks'\n \n # A class that handles retrieving file contents.\n # It only reads the file when its content is specifically\n # asked for.\n class Puppet::FileServing::Content < Puppet::FileServing::Base\n   extend Puppet::Indirector\n-  indirects :file_content, :extend => Puppet::FileServing::IndirectionHooks\n+  indirects :file_content, :terminus_class => :selector\n \n   attr_writer :content\n "
        },
        {
          "filename": "lib/puppet/file_serving/metadata.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -3,15 +3,14 @@\n require 'puppet/file_serving'\n require 'puppet/file_serving/base'\n require 'puppet/util/checksums'\n-require 'puppet/file_serving/indirection_hooks'\n \n # A class that handles retrieving file metadata.\n class Puppet::FileServing::Metadata < Puppet::FileServing::Base\n \n   include Puppet::Util::Checksums\n \n   extend Puppet::Indirector\n-  indirects :file_metadata, :extend => Puppet::FileServing::IndirectionHooks\n+  indirects :file_metadata, :terminus_class => :selector\n \n   attr_reader :path, :owner, :group, :mode, :checksum_type, :checksum, :ftype, :destination\n "
        },
        {
          "filename": "lib/puppet/file_serving/terminus_selector.rb",
          "status": "renamed",
          "additions": 2,
          "deletions": 5,
          "patch": "@@ -1,15 +1,12 @@\n-require 'uri'\n require 'puppet/file_serving'\n-require 'puppet/util'\n \n # This module is used to pick the appropriate terminus\n # in file-serving indirections.  This is necessary because\n # the terminus varies based on the URI asked for.\n-module Puppet::FileServing::IndirectionHooks\n+module Puppet::FileServing::TerminusSelector\n   PROTOCOL_MAP = {\"puppet\" => :rest, \"file\" => :file}\n \n-  # Pick an appropriate terminus based on the protocol.\n-  def select_terminus(request)\n+  def select(request)\n     # We rely on the request's parsing of the URI.\n \n     # Short-circuit to :file if it's a fully-qualified path or specifies a 'file' protocol."
        },
        {
          "filename": "lib/puppet/indirector/file_content/selector.rb",
          "status": "added",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -0,0 +1,29 @@\n+require 'puppet/indirector/file_content'\n+require 'puppet/indirector/code'\n+require 'puppet/file_serving/terminus_selector'\n+\n+class Puppet::Indirector::FileContent::Selector < Puppet::Indirector::Code\n+  desc \"Select the terminus based on the request\"\n+  include Puppet::FileServing::TerminusSelector\n+\n+  def get_terminus(request)\n+    indirection.terminus(select(request))\n+  end\n+\n+  def find(request)\n+    get_terminus(request).find(request)\n+  end\n+\n+  def search(request)\n+    get_terminus(request).search(request)\n+  end\n+\n+  def authorized?(request)\n+    terminus = get_terminus(request)\n+    if terminus.respond_to?(:authorized?)\n+      terminus.authorized?(request)\n+    else\n+      true\n+    end\n+  end\n+end"
        },
        {
          "filename": "lib/puppet/indirector/file_metadata/selector.rb",
          "status": "added",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -0,0 +1,29 @@\n+require 'puppet/indirector/file_metadata'\n+require 'puppet/indirector/code'\n+require 'puppet/file_serving/terminus_selector'\n+\n+class Puppet::Indirector::FileMetadata::Selector < Puppet::Indirector::Code\n+  desc \"Select the terminus based on the request\"\n+  include Puppet::FileServing::TerminusSelector\n+\n+  def get_terminus(request)\n+    indirection.terminus(select(request))\n+  end\n+\n+  def find(request)\n+    get_terminus(request).find(request)\n+  end\n+\n+  def search(request)\n+    get_terminus(request).search(request)\n+  end\n+\n+  def authorized?(request)\n+    terminus = get_terminus(request)\n+    if terminus.respond_to?(:authorized?)\n+      terminus.authorized?(request)\n+    else\n+      true\n+    end\n+  end\n+end"
        },
        {
          "filename": "spec/shared_behaviours/file_serving.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 3,
          "patch": "@@ -5,9 +5,7 @@\n \n     # It appears that the mocking somehow interferes with the caching subsystem.\n     # This mock somehow causes another terminus to get generated.\n-    term = @indirection.terminus(:rest)\n-    @indirection.stubs(:terminus).with(:rest).returns term\n-    term.expects(:find)\n+    @indirection.terminus(:rest).expects(:find)\n     @indirection.find(uri)\n   end\n "
        },
        {
          "filename": "spec/unit/file_serving/content_spec.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 5,
          "patch": "@@ -6,18 +6,14 @@\n describe Puppet::FileServing::Content do\n   let(:path) { File.expand_path('/path') }\n \n-  it \"should should be a subclass of Base\" do\n+  it \"should be a subclass of Base\" do\n     Puppet::FileServing::Content.superclass.should equal(Puppet::FileServing::Base)\n   end\n \n   it \"should indirect file_content\" do\n     Puppet::FileServing::Content.indirection.name.should == :file_content\n   end\n \n-  it \"should should include the IndirectionHooks module in its indirection\" do\n-    Puppet::FileServing::Content.indirection.singleton_class.included_modules.should include(Puppet::FileServing::IndirectionHooks)\n-  end\n-\n   it \"should only support the raw format\" do\n     Puppet::FileServing::Content.supported_formats.should == [:raw]\n   end"
        },
        {
          "filename": "spec/unit/file_serving/metadata_spec.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 5,
          "patch": "@@ -6,18 +6,14 @@\n describe Puppet::FileServing::Metadata do\n   let(:foobar) { File.expand_path('/foo/bar') }\n \n-  it \"should should be a subclass of Base\" do\n+  it \"should be a subclass of Base\" do\n     Puppet::FileServing::Metadata.superclass.should equal(Puppet::FileServing::Base)\n   end\n \n   it \"should indirect file_metadata\" do\n     Puppet::FileServing::Metadata.indirection.name.should == :file_metadata\n   end\n \n-  it \"should should include the IndirectionHooks module in its indirection\" do\n-    Puppet::FileServing::Metadata.indirection.singleton_class.included_modules.should include(Puppet::FileServing::IndirectionHooks)\n-  end\n-\n   it \"should have a method that triggers attribute collection\" do\n     Puppet::FileServing::Metadata.new(foobar).should respond_to(:collect)\n   end"
        },
        {
          "filename": "spec/unit/file_serving/terminus_selector_spec.rb",
          "status": "renamed",
          "additions": 10,
          "deletions": 11,
          "patch": "@@ -1,30 +1,30 @@\n #!/usr/bin/env rspec\n require 'spec_helper'\n \n-require 'puppet/file_serving/indirection_hooks'\n+require 'puppet/file_serving/terminus_selector'\n \n-describe Puppet::FileServing::IndirectionHooks do\n+describe Puppet::FileServing::TerminusSelector do\n   before do\n     @object = Object.new\n-    @object.extend(Puppet::FileServing::IndirectionHooks)\n+    @object.extend(Puppet::FileServing::TerminusSelector)\n \n     @request = stub 'request', :key => \"mymod/myfile\", :options => {:node => \"whatever\"}, :server => nil, :protocol => nil\n   end\n \n   describe \"when being used to select termini\" do\n     it \"should return :file if the request key is fully qualified\" do\n       @request.expects(:key).returns File.expand_path('/foo')\n-      @object.select_terminus(@request).should == :file\n+      @object.select(@request).should == :file\n     end\n \n     it \"should return :file if the URI protocol is set to 'file'\" do\n       @request.expects(:protocol).returns \"file\"\n-      @object.select_terminus(@request).should == :file\n+      @object.select(@request).should == :file\n     end\n \n     it \"should fail when a protocol other than :puppet or :file is used\" do\n       @request.stubs(:protocol).returns \"http\"\n-      proc { @object.select_terminus(@request) }.should raise_error(ArgumentError)\n+      proc { @object.select(@request) }.should raise_error(ArgumentError)\n     end\n \n     describe \"and the protocol is 'puppet'\" do\n@@ -35,24 +35,23 @@\n       it \"should choose :rest when a server is specified\" do\n         @request.stubs(:protocol).returns \"puppet\"\n         @request.expects(:server).returns \"foo\"\n-        @object.select_terminus(@request).should == :rest\n+        @object.select(@request).should == :rest\n       end\n \n       # This is so a given file location works when bootstrapping with no server.\n       it \"should choose :rest when the Settings name isn't 'puppet'\" do\n         @request.stubs(:protocol).returns \"puppet\"\n-        @request.stubs(:server).returns \"foo\"\n+        # We have to stub this because we can't set name\n         Puppet.settings.stubs(:value).with(:name).returns \"foo\"\n-        @object.select_terminus(@request).should == :rest\n+        @object.select(@request).should == :rest\n       end\n \n       it \"should choose :file_server when the settings name is 'puppet' and no server is specified\" do\n         modules = mock 'modules'\n \n         @request.expects(:protocol).returns \"puppet\"\n         @request.expects(:server).returns nil\n-        Puppet.settings.expects(:value).with(:name).returns \"puppet\"\n-        @object.select_terminus(@request).should == :file_server\n+        @object.select(@request).should == :file_server\n       end\n     end\n   end"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 6,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e227c27540975c25aa22d533a52424a9d2fc886a",
            "date": "2024-12-11T04:01:36Z",
            "author_login": "joshcooper"
          },
          {
            "sha": "68f8b7da048c9f0275c36e3551a749b97023be33",
            "date": "2024-12-10T23:25:31Z",
            "author_login": "mhashizume"
          },
          {
            "sha": "603c0d4cea997f3680fb5d51fa3a7e41e4426038",
            "date": "2024-12-10T23:21:26Z",
            "author_login": "puppetlabs-jenkins"
          },
          {
            "sha": "e9671155fea02a3ec18d336cf57b3c057711ca32",
            "date": "2024-11-26T00:39:13Z",
            "author_login": "cthorn42"
          },
          {
            "sha": "295d2f9071a46d82f73947963f761471bd011d88",
            "date": "2024-11-25T23:41:34Z",
            "author_login": "mhashizume"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-200",
    "description": "Puppet before 2.6.17 and 2.7.x before 2.7.18, and Puppet Enterprise before 2.5.2, allows remote authenticated users to read arbitrary files on the puppet master server by leveraging an arbitrary user's certificate and private key in a GET request.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2012-08-06T16:55:06.040",
    "last_modified": "2024-11-21T01:41:45.597",
    "fix_date": "2012-06-21T22:52:58Z"
  },
  "references": [
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2012-08/msg00006.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2012-07/msg00036.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://puppetlabs.com/security/cve/cve-2012-3864/",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://secunia.com/advisories/50014",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2012/dsa-2511",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-1506-1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=839130",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/puppetlabs/puppet/commit/10f6cb8969b4d5a933b333ecb01ce3696b1d57d4",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Patch"
      ]
    },
    {
      "url": "https://github.com/puppetlabs/puppet/commit/c3c7462e4066bf3a563987a402bf3ddf278bcd87",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Patch"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2012-08/msg00006.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2012-07/msg00036.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://puppetlabs.com/security/cve/cve-2012-3864/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://secunia.com/advisories/50014",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2012/dsa-2511",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-1506-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=839130",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/puppetlabs/puppet/commit/10f6cb8969b4d5a933b333ecb01ce3696b1d57d4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch"
      ]
    },
    {
      "url": "https://github.com/puppetlabs/puppet/commit/c3c7462e4066bf3a563987a402bf3ddf278bcd87",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:07.293113",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "puppet",
    "owner": "puppetlabs",
    "created_at": "2010-09-14T19:26:44Z",
    "updated_at": "2025-01-13T14:35:03Z",
    "pushed_at": "2024-12-11T04:01:36Z",
    "size": 90565,
    "stars": 7496,
    "forks": 2192,
    "open_issues": 73,
    "watchers": 7496,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "6.x",
      "7.x",
      "main"
    ],
    "languages": {
      "Ruby": 12928684,
      "HTML": 48622,
      "Puppet": 20259,
      "Shell": 12321,
      "C#": 5195,
      "Pascal": 858,
      "Batchfile": 594
    },
    "commit_activity": {
      "total_commits_last_year": 506,
      "avg_commits_per_week": 9.73076923076923,
      "days_active_last_year": 146
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:10:48.445221"
  }
}