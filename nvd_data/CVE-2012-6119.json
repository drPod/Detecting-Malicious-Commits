{
  "cve_id": "CVE-2012-6119",
  "github_data": {
    "repository": "candlepin/candlepin",
    "fix_commit": "f4d93230e58b969c506b4c9778e04482a059b08c",
    "related_commits": [
      "f4d93230e58b969c506b4c9778e04482a059b08c",
      "f4d93230e58b969c506b4c9778e04482a059b08c"
    ],
    "patch_url": "https://github.com/candlepin/candlepin/commit/f4d93230e58b969c506b4c9778e04482a059b08c.patch",
    "fix_commit_details": {
      "sha": "f4d93230e58b969c506b4c9778e04482a059b08c",
      "commit_date": "2012-12-19T19:19:14Z",
      "author": {
        "login": "dgoodwin",
        "type": "User",
        "stats": {
          "total_commits": 1850,
          "average_weekly_commits": 2.275522755227552,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 248
        }
      },
      "commit_message": {
        "title": "835977: Re-enable manifest signature checking.",
        "length": 490,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 167,
        "additions": 122,
        "deletions": 45
      },
      "files": [
        {
          "filename": "candlepin.spec",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -197,6 +197,7 @@ rm -rf $RPM_BUILD_ROOT\n # Create the directory structure required to lay down our files\n # common\n install -d -m 755 $RPM_BUILD_ROOT/%{_sysconfdir}/%{name}/certs/\n+install -m 644 conf/candlepin-upstream-ca.crt %{buildroot}%{_sysconfdir}/%{name}/certs\n install -d -m 755 $RPM_BUILD_ROOT/%{_sysconfdir}/%{name}/\n install -d -m 755 $RPM_BUILD_ROOT/%{_datadir}/%{name}/\n install -m 755 code/setup/cpsetup $RPM_BUILD_ROOT/%{_datadir}/%{name}/cpsetup\n@@ -283,6 +284,10 @@ fi\n %{_datadir}/%{name}/cpdb\n %{_sysconfdir}/%{name}/certs/\n %ghost %attr(644, root, root) %{_sysconfdir}/%{name}/certs/candlepin-ca.crt\n+# Default is to track the rpm version of this cert for manifest signatures.\n+# If a deployment is managing their own, they will need to restore from the\n+# .rpmsave backup after upgrading the candlepin rpm.\n+%config %attr(644, root, root) %{_sysconfdir}/%{name}/certs/candlepin-upstream-ca.crt\n %doc LICENSE\n %doc README\n "
        },
        {
          "filename": "code/setup/cpsetup",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -129,7 +129,6 @@ class CertSetup(object):\n         self.cert_home = '/etc/candlepin/certs'\n         self.ca_key_passwd = self.cert_home + '/candlepin-ca-password.txt'\n         self.ca_key = self.cert_home + '/candlepin-ca.key'\n-        self.ca_upstream_cert = self.cert_home + '/candlepin-upstream-ca.crt'\n         self.ca_pub_key = self.cert_home + '/candlepin-ca-pub.key'\n         self.ca_cert = self.cert_home + '/candlepin-ca.crt'\n         self.keystore = self.cert_home + '/keystore'\n@@ -151,7 +150,6 @@ class CertSetup(object):\n         print(\"Creating CA certificate\")\n         run_command_with_sudo('openssl req -new -x509 -days 365 -key %s -out %s -subj \"/CN=%s/C=US/L=Raleigh/\"' % (self.ca_key, self.ca_cert, socket.gethostname()))\n         run_command_with_sudo('openssl pkcs12 -export -in %s -inkey %s -out %s -name tomcat -CAfile %s -caname root -chain -password pass:password' % (self.ca_cert, self.ca_key, self.keystore, self.ca_cert))\n-        run_command_with_sudo('cp %s %s' % (self.ca_cert, self.ca_upstream_cert))\n         run_command_with_sudo('chmod a+r %s' % self.keystore)\n \n "
        },
        {
          "filename": "conf/candlepin-upstream-ca.crt",
          "status": "added",
          "additions": 40,
          "deletions": 0,
          "patch": "@@ -0,0 +1,40 @@\n+-----BEGIN CERTIFICATE-----\n+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\n+g6EHdPrR+A==\n+-----END CERTIFICATE-----"
        },
        {
          "filename": "src/main/java/org/candlepin/sync/Importer.java",
          "status": "modified",
          "additions": 31,
          "deletions": 32,
          "patch": "@@ -22,6 +22,7 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.Reader;\n+import java.security.cert.CertificateException;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.LinkedList;\n@@ -211,40 +212,37 @@ public Map<String, Object> loadExport(Owner owner, File exportFile,\n             tmpDir = new SyncUtils(config).makeTempDir(\"import\");\n             extractArchive(tmpDir, exportFile);\n \n-//           only need this call when sig file is verified\n-//            exportStream = new FileInputStream(new File(tmpDir, \"consumer_export.zip\"));\n-\n-            /*\n-             * Disabling this once again for a little bit longer. Dependent projects\n-             * are not yet ready for it, and we're having some difficulty with the actual\n-             * upstream cert to use.\n-             *\n-             * When we bring this back, we should probably report this conflict\n-             * immediately, rather than continuing to extract and trying to find any\n-             * other conflicts to pass back.\n-             */\n-//            boolean verifiedSignature = pki.verifySHA256WithRSAHashWithUpstreamCACert(\n-//                exportStream,\n-//                loadSignature(new File(tmpDir, \"signature\")));\n-//            if (!verifiedSignature) {\n-//                log.warn(\"Manifest signature check failed.\");\n-//                if (!forcedConflicts\n-//                    .isForced(ImportConflicts.Conflict.SIGNATURE_CONFLICT)) {\n-//                    conflicts.addConflict(\n-//                        i18n.tr(\"Failed import file hash check.\"),\n-//                        ImportConflicts.Conflict.SIGNATURE_CONFLICT);\n-//                }\n-//                else {\n-//                    log.warn(\"Ignoring signature check failure.\");\n-//                }\n-//            }\n-\n             File signature = new File(tmpDir, \"signature\");\n             if (signature.length() == 0) {\n                 throw new ImportExtractionException(i18n.tr(\"The archive does not \" +\n                                           \"contain the required signature file\"));\n             }\n \n+            exportStream = new FileInputStream(new File(tmpDir, \"consumer_export.zip\"));\n+            boolean verifiedSignature = pki.verifySHA256WithRSAHashWithUpstreamCACert(\n+                exportStream,\n+                loadSignature(new File(tmpDir, \"signature\")));\n+            if (!verifiedSignature) {\n+                log.warn(\"Archive signature check failed.\");\n+                if (!overrides\n+                    .isForced(Conflict.SIGNATURE_CONFLICT)) {\n+\n+                    /*\n+                     * Normally for import conflicts that can be overridden, we try to\n+                     * report them all the first time so if the user intends to override,\n+                     * they can do so with just one more request. However in the case of\n+                     * a bad signature, we're going to report immediately due to the nature\n+                     * of what this might mean.\n+                     */\n+                    throw new ImportConflictException(\n+                        i18n.tr(\"Archive failed signature check\"),\n+                        Conflict.SIGNATURE_CONFLICT);\n+                }\n+                else {\n+                    log.warn(\"Ignoring signature check failure.\");\n+                }\n+            }\n+\n             File consumerExport = new File(tmpDir, \"consumer_export.zip\");\n             File exportDir = extractArchive(tmpDir, consumerExport);\n \n@@ -265,10 +263,6 @@ public Map<String, Object> loadExport(Owner owner, File exportFile,\n             result.put(\"meta\", m);\n             return result;\n         }\n-//        catch (CertificateException e) {\n-//            log.error(\"Exception caught importing archive\", e);\n-//            throw new ImportExtractionException(\"unable to extract export archive\", e);\n-//        }\n         catch (FileNotFoundException fnfe) {\n             log.error(\"Archive file does not contain consumer_export.zip\", fnfe);\n             throw new ImportExtractionException(i18n.tr(\"The archive does not contain \" +\n@@ -288,6 +282,11 @@ public Map<String, Object> loadExport(Owner owner, File exportFile,\n             log.error(\"Exception caught importing archive\", e);\n             throw new ImportExtractionException(\"unable to extract export archive\", e);\n         }\n+        catch (CertificateException e) {\n+            log.error(\"Certificate exception checking archive signature\", e);\n+            throw new ImportExtractionException(\n+                \"Certificate exception checking archive signature\", e);\n+        }\n         finally {\n             if (tmpDir != null) {\n                 try {"
        },
        {
          "filename": "src/test/java/org/candlepin/sync/ImporterTest.java",
          "status": "modified",
          "additions": 46,
          "deletions": 11,
          "patch": "@@ -31,6 +31,7 @@\n import java.io.FileOutputStream;\n import java.io.FileWriter;\n import java.io.IOException;\n+import java.io.InputStream;\n import java.io.PrintStream;\n import java.io.Reader;\n import java.net.URISyntaxException;\n@@ -49,6 +50,7 @@\n import org.candlepin.model.ExporterMetadata;\n import org.candlepin.model.ExporterMetadataCurator;\n import org.candlepin.model.Owner;\n+import org.candlepin.pki.PKIUtility;\n import org.candlepin.sync.Importer.ImportFile;\n import org.codehaus.jackson.JsonGenerationException;\n import org.codehaus.jackson.map.JsonMappingException;\n@@ -353,15 +355,43 @@ public void testImportZipArchiveNoContent()\n         assertTrue(false);\n     }\n \n-    @Test\n-    public void testImportZipSigConsumerNotZip()\n+    @Test(expected = ImportConflictException.class)\n+    public void testImportBadSignature()\n         throws IOException, ImporterException {\n+        PKIUtility pki = mock(PKIUtility.class);\n         Importer i = new Importer(null, null, null, null, null, null, null,\n-            null, config, null, null, null, i18n);\n+            pki, config, null, null, null, i18n);\n+\n+        Owner owner = mock(Owner.class);\n+        ConflictOverrides co = mock(ConflictOverrides.class);\n+\n+        File archive = new File(\"/tmp/file.zip\");\n+        ZipOutputStream out = new ZipOutputStream(new FileOutputStream(archive));\n+        out.putNextEntry(new ZipEntry(\"signature\"));\n+        out.write(\"This is the placeholder for the signature file\".getBytes());\n+        File ceArchive = new File(\"/tmp/consumer_export.zip\");\n+        FileOutputStream fos = new FileOutputStream(ceArchive);\n+        fos.write(\"This is just a flat file\".getBytes());\n+        fos.close();\n+        addFileToArchive(out, ceArchive);\n+        out.close();\n+\n+        i.loadExport(owner, archive, co);\n+    }\n+\n+    @Test\n+    public void testImportBadConsumerZip() throws Exception {\n+        PKIUtility pki = mock(PKIUtility.class);\n+        Importer i = new Importer(null, null, null, null, null, null, null,\n+            pki, config, null, null, null, i18n);\n \n         Owner owner = mock(Owner.class);\n         ConflictOverrides co = mock(ConflictOverrides.class);\n \n+        // Mock a passed signature check:\n+        when(pki.verifySHA256WithRSAHashWithUpstreamCACert(any(InputStream.class),\n+            any(byte [].class))).thenReturn(true);\n+\n         File archive = new File(\"/tmp/file.zip\");\n         ZipOutputStream out = new ZipOutputStream(new FileOutputStream(archive));\n         out.putNextEntry(new ZipEntry(\"signature\"));\n@@ -377,22 +407,28 @@ public void testImportZipSigConsumerNotZip()\n             i.loadExport(owner, archive, co);\n         }\n         catch (ImportExtractionException e) {\n-            assertEquals(e.getMessage(), i18n.tr(\"The archive {0} is \" +\n-                \"not a properly compressed file or is empty\", \"consumer_export.zip\"));\n+            System.out.println(e.getMessage());\n+            assertTrue(e.getMessage().contains(\n+                \"not a properly compressed file or is empty\"));\n             return;\n         }\n-        assertTrue(false);\n+        fail();\n     }\n \n     @Test\n     public void testImportZipSigAndEmptyConsumerZip()\n-        throws IOException, ImporterException {\n+        throws Exception {\n+        PKIUtility pki = mock(PKIUtility.class);\n         Importer i = new Importer(null, null, null, null, null, null, null,\n-            null, config, null, null, null, i18n);\n+            pki, config, null, null, null, i18n);\n \n         Owner owner = mock(Owner.class);\n         ConflictOverrides co = mock(ConflictOverrides.class);\n \n+        // Mock a passed signature check:\n+        when(pki.verifySHA256WithRSAHashWithUpstreamCACert(any(InputStream.class),\n+            any(byte [].class))).thenReturn(true);\n+\n         File archive = new File(\"/tmp/file.zip\");\n         ZipOutputStream out = new ZipOutputStream(new FileOutputStream(archive));\n         out.putNextEntry(new ZipEntry(\"signature\"));\n@@ -408,11 +444,10 @@ public void testImportZipSigAndEmptyConsumerZip()\n             i.loadExport(owner, archive, co);\n         }\n         catch (ImportExtractionException e) {\n-            assertEquals(e.getMessage(), i18n.tr(\"The consumer_export \" +\n-                \"archive has no contents\"));\n+            assertTrue(e.getMessage().contains(\"consumer_export archive has no contents\"));\n             return;\n         }\n-        assertTrue(false);\n+        fail();\n     }\n \n     @Test"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 5,
        "max_directory_depth": 6
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "573fb3fa2f0e5c55ece724cf2ecb24c63a2f6ec2",
            "date": "2025-01-14T14:00:34Z",
            "author_login": "joshmalbrecht"
          },
          {
            "sha": "4d50cdd48107c29feb9189a2408467bbdb024beb",
            "date": "2025-01-14T13:05:31Z",
            "author_login": "bakajstep"
          },
          {
            "sha": "9838331112355425db05d03834a08718b07e8a91",
            "date": "2025-01-09T10:02:48Z",
            "author_login": "candlepin-bot"
          },
          {
            "sha": "4ed3ee9127675c2b1a0851a6ed576ba06285f141",
            "date": "2025-01-07T16:07:45Z",
            "author_login": "Ceiu"
          },
          {
            "sha": "457a1aed67295deb17b05439878d1005387dae35",
            "date": "2024-11-13T13:05:09Z",
            "author_login": "bakajstep"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-264",
    "description": "Candlepin before 0.7.24, as used in Red Hat Subscription Asset Manager before 1.2.1, does not properly check manifest signatures, which allows local users to modify manifests.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2013-04-02T22:55:01.237",
    "last_modified": "2024-11-21T01:45:51.760",
    "fix_date": "2012-12-19T19:19:14Z"
  },
  "references": [
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2013-0686.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://secunia.com/advisories/52774",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.osvdb.org/91719",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=908613",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://github.com/candlepin/candlepin/blob/master/candlepin.spec",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://github.com/candlepin/candlepin/commit/f4d93230e58b969c506b4c9778e04482a059b08c",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2013-0686.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://secunia.com/advisories/52774",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.osvdb.org/91719",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=908613",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/candlepin/candlepin/blob/master/candlepin.spec",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/candlepin/candlepin/commit/f4d93230e58b969c506b4c9778e04482a059b08c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:13.503783",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "candlepin",
    "owner": "candlepin",
    "created_at": "2012-06-07T14:58:35Z",
    "updated_at": "2025-01-14T14:00:38Z",
    "pushed_at": "2025-01-14T17:20:14Z",
    "size": 89397,
    "stars": 96,
    "forks": 70,
    "open_issues": 13,
    "watchers": 96,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "candlepin-0.9.49-HOTFIX",
      "candlepin-0.9.54-HOTFIX",
      "candlepin-2.0-HOTFIX",
      "candlepin-2.1-HOTFIX",
      "candlepin-2.2-HOTFIX",
      "candlepin-2.3-HOTFIX",
      "candlepin-2.4-HOTFIX",
      "candlepin-2.4.8-HOTFIX",
      "candlepin-2.5-HOTFIX",
      "candlepin-2.6-HOTFIX",
      "candlepin-2.7-HOTFIX",
      "candlepin-2.8-HOTFIX",
      "candlepin-2.9-HOTFIX",
      "candlepin-2.10-HOTFIX",
      "candlepin-2.12-HOTFIX",
      "candlepin-3.0-HOTFIX",
      "candlepin-3.1-1972501-HOTFIX",
      "candlepin-3.1-HOTFIX",
      "candlepin-3.1.28-4-HOTFIX",
      "candlepin-3.1.28-HOTFIX",
      "candlepin-3.2-HOTFIX",
      "candlepin-4.0-HOTFIX",
      "candlepin-4.1-HOTFIX",
      "candlepin-4.1.19-HOTFIX",
      "candlepin-4.2-HOTFIX",
      "candlepin-4.3-HOTFIX",
      "candlepin-4.3.7-HOTFIX"
    ],
    "languages": {
      "Java": 12878647,
      "Python": 224806,
      "JavaScript": 216103,
      "Shell": 30975,
      "Groovy": 11168,
      "HTML": 6968,
      "Dockerfile": 4820,
      "Mustache": 1896
    },
    "commit_activity": {
      "total_commits_last_year": 802,
      "avg_commits_per_week": 15.423076923076923,
      "days_active_last_year": 234
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T21:50:17.648969"
  }
}