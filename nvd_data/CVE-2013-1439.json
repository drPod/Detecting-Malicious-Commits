{
  "cve_id": "CVE-2013-1439",
  "github_data": {
    "repository": "LibRaw/LibRaw",
    "fix_commit": "11909cc59e712e09b508dda729b99aeaac2b29ad",
    "related_commits": [
      "11909cc59e712e09b508dda729b99aeaac2b29ad",
      "11909cc59e712e09b508dda729b99aeaac2b29ad"
    ],
    "patch_url": "https://github.com/LibRaw/LibRaw/commit/11909cc59e712e09b508dda729b99aeaac2b29ad.patch",
    "fix_commit_details": {
      "sha": "11909cc59e712e09b508dda729b99aeaac2b29ad",
      "commit_date": "2013-08-22T19:37:36Z",
      "author": {
        "login": "alextutubalin",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "cumulated data checks patch",
        "length": 27,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 157,
        "additions": 124,
        "deletions": 33
      },
      "files": [
        {
          "filename": "Changelog.txt",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -1,11 +1,13 @@\n-2013-08-07 Alex Tutubalin <lexa@lexa.ru>\n+2013-08-28 Alex Tutubalin <lexa@lexa.ru>\n+  * Additional checks to data to prevent broken file opening\n   * New camera/format support:\n      Richon GR\n      Panasonic LF1\n      Canon EOS 70D\n      Sony RX100II, RX1R\n      Olympus E-P5\n   * Generalized size copy from RawSpeed data\n+  * LibRaw 0.15.4\n \n 2013-07-04 Alex Tutubalin <lexa@lexa.ru>\n   * New camera/format support:"
        },
        {
          "filename": "Makefile.devel",
          "status": "modified",
          "additions": 7,
          "deletions": 6,
          "patch": "@@ -4,16 +4,17 @@ PP=./internal/preprocess.pl\n \n CC=gcc\n CXX=g++\n+CFLAGS+= -O -g -I.\n \n # RawSpeed Support\n-CFLAGS+=-DUSE_RAWSPEED -I../RawSpeed -I/usr/local/include/libxml2\n-LDADD+=-L../RawSpeed/RawSpeed/release -lrawspeed -L/usr/local/include -ljpeg -lxml2\n-RAWSPEED_DATA=../RawSpeed/data/cameras.xml\n+#CFLAGS+=-DUSE_RAWSPEED -I../RawSpeed -I/usr/local/include/libxml2\n+#LDADD+=-L../RawSpeed/RawSpeed/release -lrawspeed -L/usr/local/include -ljpeg -lxml2\n+#RAWSPEED_DATA=../RawSpeed/data/cameras.xml\n \n \n-CC=gcc48\n-CXX=g++48\n-CFLAGS+= -O4 -g -march=corei7 -mtune=corei7 -I. -pedantic  -Wno-long-long -Wno-overflow -msse4.2 -mfpmath=sse  -fopenmp \n+#CC=gcc48\n+#CXX=g++48\n+#CFLAGS+= -O -g -I. -march=corei7 -mtune=corei7 -I. -pedantic  -Wno-long-long -Wno-overflow -msse4.2 -mfpmath=sse  -fopenmp \n \n \n # LCMS support"
        },
        {
          "filename": "dcraw/dcraw.c",
          "status": "modified",
          "additions": 45,
          "deletions": 6,
          "patch": "@@ -877,6 +877,11 @@ int CLASS ljpeg_diff (ushort *huff)\n {\n   int len, diff;\n \n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!huff)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   len = gethuff(huff);\n   if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n     return -32768;\n@@ -891,6 +896,9 @@ int CLASS ljpeg_diff_new (LibRaw_bit_buffer& bits, LibRaw_byte_buffer* buf,ushor\n {\n   int len, diff;\n \n+  if(!huff || !buf)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n   len = bits._gethuff_lj(buf,*huff,huff+1);\n   if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n     return -32768;\n@@ -1010,8 +1018,11 @@ void CLASS lossless_jpeg_load_raw()\n   }\n #endif\n \n-\n   if (!ljpeg_start (&jh, 0)) return;\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(jh.wide<1 || jh.high<1 || jh.clrs<1 || jh.bits <1)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   jwide = jh.wide * jh.clrs;\n \n #ifdef LIBRAW_LIBRARY_BUILD\n@@ -1028,13 +1039,19 @@ void CLASS lossless_jpeg_load_raw()\n       }\n        \n   slices = slicesWcnt * jh.high;\n+  if(!slices)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n   offset = (unsigned*)calloc(slices+1,sizeof(offset[0]));\n \n   for(slice=0;slice<slices;slice++)\n       {\n           offset[slice] = (t_x + t_y * raw_width)| (t_s<<28);\n           if((offset[slice] & 0x0fffffff) >= raw_width * raw_height)\n+            {\n+              free(offset);\n               throw LIBRAW_EXCEPTION_IO_BADFILE; \n+            }\n           t_y++;\n           if(t_y == jh.high)\n               {\n@@ -1087,12 +1104,27 @@ void CLASS lossless_jpeg_load_raw()\n               pixno++;\n               if (0 == --pixelsInSlice)\n                   {\n+                    if(slice > slices)\n+                      {\n+                        free(offset);\n+                        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+                      }\n                       unsigned o = offset[slice++];\n                       pixno = o & 0x0fffffff;\n                       pixelsInSlice = slicesW[o>>28];\n                   }\n           }\n #endif\n+\n+      if(row>raw_height)\n+#ifdef LIBRAW_LIBRARY_BUILD\n+      {\n+        free(offset);\n+        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+      }\n+#else\n+        longjmp (failure, 3);\n+#endif\n       if (raw_width == 3984 && (col -= 2) < 0)\n \tcol += (row--,raw_width);\n       if (row >= 0) RAW(row,col) = val;\n@@ -6295,6 +6327,7 @@ int CLASS parse_tiff_ifd (int base)\n \t  data_offset = get4()+base;\n \t  ifd++;  break;\n \t}\n+        if(len > 1000) len=1000; /* 1000 SubIFDs is enough */\n \twhile (len--) {\n \t  i = ftell(ifp);\n \t  fseek (ifp, get4()+base, SEEK_SET);\n@@ -6513,7 +6546,7 @@ int CLASS parse_tiff_ifd (int base)\n \tbreak;\n       case 50715:\t\t\t/* BlackLevelDeltaH */\n       case 50716:\t\t\t/* BlackLevelDeltaV */\n-\tfor (num=i=0; i < len; i++)\n+\tfor (num=i=0; i < len && i < 65536; i++)\n \t  num += getreal(type);\n \tblack += num/len + 0.5;\n \tbreak;\n@@ -6646,17 +6679,21 @@ void CLASS apply_tiff()\n   if (thumb_offset) {\n     fseek (ifp, thumb_offset, SEEK_SET);\n     if (ljpeg_start (&jh, 1)) {\n-      thumb_misc   = jh.bits;\n-      thumb_width  = jh.wide;\n-      thumb_height = jh.high;\n+      if((unsigned)jh.bits<17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)\n+        {\n+          thumb_misc   = jh.bits;\n+          thumb_width  = jh.wide;\n+          thumb_height = jh.high;\n+        }\n     }\n   }\n   for (i=0; i < tiff_nifds; i++) {\n     if (max_samp < tiff_ifd[i].samples)\n \tmax_samp = tiff_ifd[i].samples;\n     if (max_samp > 3) max_samp = 3;\n     if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&\n-\t(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n+        unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n+        (unsigned)tiff_ifd[i].bps < 33 && (unsigned)tiff_ifd[i].samples < 13 &&\n \ttiff_ifd[i].t_width*tiff_ifd[i].t_height > raw_width*raw_height) {\n       raw_width     = tiff_ifd[i].t_width;\n       raw_height    = tiff_ifd[i].t_height;\n@@ -6743,6 +6780,8 @@ void CLASS apply_tiff()\n       is_raw = 0;\n   for (i=0; i < tiff_nifds; i++)\n     if (i != raw && tiff_ifd[i].samples == max_samp &&\n+        tiff_ifd[i].bps>0 && tiff_ifd[i].bps < 33 &&\n+       unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n \ttiff_ifd[i].t_width * tiff_ifd[i].t_height / SQR(tiff_ifd[i].bps+1) >\n \t      thumb_width *       thumb_height / SQR(thumb_misc+1)\n \t&& tiff_ifd[i].comp != 34892) {"
        },
        {
          "filename": "internal/dcraw_common.cpp",
          "status": "modified",
          "additions": 54,
          "deletions": 15,
          "patch": "@@ -611,6 +611,11 @@ int CLASS ljpeg_diff (ushort *huff)\n {\n   int len, diff;\n \n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!huff)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   len = gethuff(huff);\n   if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n     return -32768;\n@@ -625,6 +630,9 @@ int CLASS ljpeg_diff_new (LibRaw_bit_buffer& bits, LibRaw_byte_buffer* buf,ushor\n {\n   int len, diff;\n \n+  if(!huff || !buf)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n   len = bits._gethuff_lj(buf,*huff,huff+1);\n   if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n     return -32768;\n@@ -744,8 +752,11 @@ void CLASS lossless_jpeg_load_raw()\n   }\n #endif\n \n-\n   if (!ljpeg_start (&jh, 0)) return;\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(jh.wide<1 || jh.high<1 || jh.clrs<1 || jh.bits <1)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   jwide = jh.wide * jh.clrs;\n \n #ifdef LIBRAW_LIBRARY_BUILD\n@@ -762,13 +773,19 @@ void CLASS lossless_jpeg_load_raw()\n       }\n        \n   slices = slicesWcnt * jh.high;\n+  if(!slices)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n   offset = (unsigned*)calloc(slices+1,sizeof(offset[0]));\n \n   for(slice=0;slice<slices;slice++)\n       {\n           offset[slice] = (t_x + t_y * raw_width)| (t_s<<28);\n           if((offset[slice] & 0x0fffffff) >= raw_width * raw_height)\n+            {\n+              free(offset);\n               throw LIBRAW_EXCEPTION_IO_BADFILE; \n+            }\n           t_y++;\n           if(t_y == jh.high)\n               {\n@@ -821,12 +838,27 @@ void CLASS lossless_jpeg_load_raw()\n               pixno++;\n               if (0 == --pixelsInSlice)\n                   {\n+                    if(slice > slices)\n+                      {\n+                        free(offset);\n+                        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+                      }\n                       unsigned o = offset[slice++];\n                       pixno = o & 0x0fffffff;\n                       pixelsInSlice = slicesW[o>>28];\n                   }\n           }\n #endif\n+\n+      if(row>raw_height)\n+#ifdef LIBRAW_LIBRARY_BUILD\n+      {\n+        free(offset);\n+        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+      }\n+#else\n+        longjmp (failure, 3);\n+#endif\n       if (raw_width == 3984 && (col -= 2) < 0)\n \tcol += (row--,raw_width);\n       if (row >= 0) RAW(row,col) = val;\n@@ -1283,7 +1315,7 @@ int CLASS minolta_z2()\n     if (tail[i]) nz++;\n   return nz > 20;\n }\n-#line 1557 \"dcraw/dcraw.c\"\n+#line 1589 \"dcraw/dcraw.c\"\n void CLASS ppm_thumb()\n {\n   char *thumb;\n@@ -2865,7 +2897,7 @@ void CLASS redcine_load_raw()\n   jas_stream_close (in);\n #endif\n }\n-#line 3846 \"dcraw/dcraw.c\"\n+#line 3878 \"dcraw/dcraw.c\"\n void CLASS crop_masked_pixels()\n {\n   int row, col;\n@@ -2965,7 +2997,7 @@ void CLASS remove_zeroes()\n   RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);\n #endif\n }\n-#line 4111 \"dcraw/dcraw.c\"\n+#line 4143 \"dcraw/dcraw.c\"\n void CLASS gamma_curve (double pwr, double ts, int mode, int imax)\n {\n   int i;\n@@ -4460,7 +4492,7 @@ void CLASS parse_thumb_note (int base, unsigned toff, unsigned tlen)\n     fseek (ifp, save, SEEK_SET);\n   }\n }\n-#line 5610 \"dcraw/dcraw.c\"\n+#line 5642 \"dcraw/dcraw.c\"\n void CLASS parse_makernote (int base, int uptag)\n {\n   static const uchar xlat[2][256] = {\n@@ -4975,7 +5007,7 @@ void CLASS parse_kodak_ifd (int base)\n     fseek (ifp, save, SEEK_SET);\n   }\n }\n-#line 6130 \"dcraw/dcraw.c\"\n+#line 6162 \"dcraw/dcraw.c\"\n int CLASS parse_tiff_ifd (int base)\n {\n   unsigned entries, tag, type, len, plen=16, save;\n@@ -5144,6 +5176,7 @@ int CLASS parse_tiff_ifd (int base)\n \t  data_offset = get4()+base;\n \t  ifd++;  break;\n \t}\n+        if(len > 1000) len=1000; /* 1000 SubIFDs is enough */\n \twhile (len--) {\n \t  i = ftell(ifp);\n \t  fseek (ifp, get4()+base, SEEK_SET);\n@@ -5362,7 +5395,7 @@ int CLASS parse_tiff_ifd (int base)\n \tbreak;\n       case 50715:\t\t\t/* BlackLevelDeltaH */\n       case 50716:\t\t\t/* BlackLevelDeltaV */\n-\tfor (num=i=0; i < len; i++)\n+\tfor (num=i=0; i < len && i < 65536; i++)\n \t  num += getreal(type);\n \tblack += num/len + 0.5;\n \tbreak;\n@@ -5495,17 +5528,21 @@ void CLASS apply_tiff()\n   if (thumb_offset) {\n     fseek (ifp, thumb_offset, SEEK_SET);\n     if (ljpeg_start (&jh, 1)) {\n-      thumb_misc   = jh.bits;\n-      thumb_width  = jh.wide;\n-      thumb_height = jh.high;\n+      if((unsigned)jh.bits<17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)\n+        {\n+          thumb_misc   = jh.bits;\n+          thumb_width  = jh.wide;\n+          thumb_height = jh.high;\n+        }\n     }\n   }\n   for (i=0; i < tiff_nifds; i++) {\n     if (max_samp < tiff_ifd[i].samples)\n \tmax_samp = tiff_ifd[i].samples;\n     if (max_samp > 3) max_samp = 3;\n     if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&\n-\t(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n+        unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n+        (unsigned)tiff_ifd[i].bps < 33 && (unsigned)tiff_ifd[i].samples < 13 &&\n \ttiff_ifd[i].t_width*tiff_ifd[i].t_height > raw_width*raw_height) {\n       raw_width     = tiff_ifd[i].t_width;\n       raw_height    = tiff_ifd[i].t_height;\n@@ -5592,6 +5629,8 @@ void CLASS apply_tiff()\n       is_raw = 0;\n   for (i=0; i < tiff_nifds; i++)\n     if (i != raw && tiff_ifd[i].samples == max_samp &&\n+        tiff_ifd[i].bps>0 && tiff_ifd[i].bps < 33 &&\n+       unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n \ttiff_ifd[i].t_width * tiff_ifd[i].t_height / SQR(tiff_ifd[i].bps+1) >\n \t      thumb_width *       thumb_height / SQR(thumb_misc+1)\n \t&& tiff_ifd[i].comp != 34892) {\n@@ -6233,7 +6272,7 @@ void CLASS parse_redcine()\n     data_offset = get4();\n   }\n }\n-#line 7390 \"dcraw/dcraw.c\"\n+#line 7429 \"dcraw/dcraw.c\"\n char * CLASS foveon_gets (int offset, char *str, int len)\n {\n   int i;\n@@ -6334,7 +6373,7 @@ void CLASS parse_foveon()\n   }\n   is_foveon = 1;\n }\n-#line 7493 \"dcraw/dcraw.c\"\n+#line 7532 \"dcraw/dcraw.c\"\n /*\n    All matrices are from Adobe DNG Converter unless otherwise noted.\n  */\n@@ -8981,7 +9020,7 @@ void CLASS identify2(unsigned fsize, unsigned flen, char *head)\n }\n \n \n-#line 10231 \"dcraw/dcraw.c\"\n+#line 10270 \"dcraw/dcraw.c\"\n void CLASS convert_to_rgb()\n {\n #ifndef LIBRAW_LIBRARY_BUILD\n@@ -9212,7 +9251,7 @@ int CLASS flip_index (int row, int col)\n   if (flip & 1) col = iwidth  - 1 - col;\n   return row * iwidth + col;\n }\n-#line 10487 \"dcraw/dcraw.c\"\n+#line 10526 \"dcraw/dcraw.c\"\n void CLASS tiff_set (ushort *ntag,\n \tushort tag, ushort type, int count, int val)\n {"
        },
        {
          "filename": "internal/dcraw_fileio.cpp",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -21,15 +21,15 @@ it under the terms of the one of three licenses as you choose:\n    for more information\n */\n \n-#line 3948 \"dcraw/dcraw.c\"\n+#line 3980 \"dcraw/dcraw.c\"\n #include <math.h>\n #define CLASS LibRaw::\n #include \"libraw/libraw_types.h\"\n #define LIBRAW_LIBRARY_BUILD\n #include \"libraw/libraw.h\"\n #include \"internal/defines.h\"\n #include \"internal/var_defines.h\"\n-#line 3959 \"dcraw/dcraw.c\"\n+#line 3991 \"dcraw/dcraw.c\"\n /*\n    Seach from the current directory up to the root looking for\n    a \".badpixels\" file, and fix those pixels now.\n@@ -54,7 +54,7 @@ void CLASS bad_pixels (const char *cfname)\n #endif\n   if (cfname)\n     fp = fopen (cfname, \"r\");\n-#line 4009 \"dcraw/dcraw.c\"\n+#line 4041 \"dcraw/dcraw.c\"\n   if (!fp)\n       {\n #ifdef LIBRAW_LIBRARY_BUILD\n@@ -154,7 +154,7 @@ void CLASS subtract (const char *fname)\n   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);\n #endif\n }\n-#line 10142 \"dcraw/dcraw.c\"\n+#line 10181 \"dcraw/dcraw.c\"\n #ifndef NO_LCMS\n void CLASS apply_profile (const char *input, const char *output)\n {"
        },
        {
          "filename": "libraw/libraw_version.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -25,7 +25,7 @@ it under the terms of the one of three licenses as you choose:\n \n #define LIBRAW_MAJOR_VERSION  0\n #define LIBRAW_MINOR_VERSION  15\n-#define LIBRAW_PATCH_VERSION  3\n+#define LIBRAW_PATCH_VERSION  4\n #define LIBRAW_VERSION_TAIL   Release\n \n #define LIBRAW_SHLIB_CURRENT  \t9"
        },
        {
          "filename": "src/libraw_datastream.cpp",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -64,7 +64,12 @@ LibRaw_byte_buffer::~LibRaw_byte_buffer()\n \n LibRaw_byte_buffer *LibRaw_abstract_datastream::make_byte_buffer(unsigned int sz)\n {\n+  if(INT64(sz)>size())\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n     LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(sz);\n+    if(!ret) // failed new should throw std::exception\n+      throw LIBRAW_EXCEPTION_ALLOC;\n     read(ret->get_buffer(),sz,1);\n     return ret;\n }\n@@ -441,7 +446,12 @@ int LibRaw_buffer_datastream::scanf_one(const char *fmt, void* val)\n \n LibRaw_byte_buffer *LibRaw_buffer_datastream::make_byte_buffer(unsigned int sz)\n {\n+  if(INT64(sz)>size())\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n     LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(0);\n+    if(!ret) // failed new should throw std::exception\n+      throw LIBRAW_EXCEPTION_ALLOC;\n     if(streampos + sz > streamsize)\n         sz = streamsize - streampos;\n     ret->set_buffer(buf+streampos,sz);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 5,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "cc118c1c1869e2559dbd0c7639d219154cc46e40",
            "date": "2024-11-30T15:36:46Z",
            "author_login": "alextutubalin"
          },
          {
            "sha": "9bcb8a1d9593ba67e4eb67fed716efc5e1353d5c",
            "date": "2024-09-18T09:07:43Z",
            "author_login": "alextutubalin"
          },
          {
            "sha": "bf1a9140e0d032c0f3d5eccbe2b7aa4e7167e287",
            "date": "2024-09-16T08:49:24Z",
            "author_login": "alextutubalin"
          },
          {
            "sha": "77a46b31978a2381e61df524dc9b6670a1f22321",
            "date": "2024-09-16T08:45:25Z",
            "author_login": "alextutubalin"
          },
          {
            "sha": "4f5a4cfb3724eb57386efad362b998b68a10eba7",
            "date": "2024-09-14T17:32:15Z",
            "author_login": "alextutubalin"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": null,
    "description": "The \"faster LJPEG decoder\" in libraw 0.13.x, 0.14.x, and 0.15.x before 0.15.4 allows context-dependent attackers to cause a denial of service (NULL pointer dereference) via a crafted photo file.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2013-09-16T19:14:37.693",
    "last_modified": "2024-11-21T01:49:35.077",
    "fix_date": "2013-08-22T19:37:36Z"
  },
  "references": [
    {
      "url": "http://www.debian.org/security/2013/dsa-2748",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2013/08/29/3",
      "source": "security@debian.org",
      "tags": [
        "Exploit",
        "Patch"
      ]
    },
    {
      "url": "https://github.com/LibRaw/LibRaw/commit/11909cc59e712e09b508dda729b99aeaac2b29ad",
      "source": "security@debian.org",
      "tags": [
        "Exploit",
        "Patch"
      ]
    },
    {
      "url": "http://www.debian.org/security/2013/dsa-2748",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2013/08/29/3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch"
      ]
    },
    {
      "url": "https://github.com/LibRaw/LibRaw/commit/11909cc59e712e09b508dda729b99aeaac2b29ad",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:16.788230",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "LibRaw",
    "owner": "LibRaw",
    "created_at": "2010-10-11T18:01:13Z",
    "updated_at": "2025-01-14T03:39:50Z",
    "pushed_at": "2024-11-30T15:42:21Z",
    "size": 14433,
    "stars": 1172,
    "forks": 287,
    "open_issues": 2,
    "watchers": 1172,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 2012970,
      "C": 18819,
      "M4": 8267,
      "QMake": 6245,
      "Makefile": 5329,
      "Shell": 1869,
      "Perl": 1289
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:49:33.251436"
  }
}