{
  "cve_id": "CVE-2013-1445",
  "github_data": {
    "repository": "dlitz/pycrypto",
    "fix_commit": "19dcf7b15d61b7dc1a125a367151de40df6ef175",
    "related_commits": [
      "19dcf7b15d61b7dc1a125a367151de40df6ef175",
      "19dcf7b15d61b7dc1a125a367151de40df6ef175"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "19dcf7b15d61b7dc1a125a367151de40df6ef175",
      "commit_date": "2013-10-14T21:37:35Z",
      "author": {
        "login": "dlitz",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Random: Make Crypto.Random.atfork() set last_reseed=None (CVE-2013-1445)",
        "length": 4103,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 196,
        "additions": 196,
        "deletions": 0
      },
      "files": [
        {
          "filename": "lib/Crypto/Random/Fortuna/FortunaAccumulator.py",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -109,6 +109,15 @@ def __init__(self):\n         self.pools = [FortunaPool() for i in range(32)]     # 32 pools\n         assert(self.pools[0] is not self.pools[1])\n \n+    def _forget_last_reseed(self):\n+        # This is not part of the standard Fortuna definition, and using this\n+        # function frequently can weaken Fortuna's ability to resist a state\n+        # compromise extension attack, but we need this in order to properly\n+        # implement Crypto.Random.atfork().  Otherwise, forked child processes\n+        # might continue to use their parent's PRNG state for up to 100ms in\n+        # some cases. (e.g. CVE-2013-1445)\n+        self.last_reseed = None\n+\n     def random_data(self, bytes):\n         current_time = time.time()\n         if (self.last_reseed is not None and self.last_reseed > current_time): # Avoid float comparison to None to make Py3k happy"
        },
        {
          "filename": "lib/Crypto/Random/_UserFriendlyRNG.py",
          "status": "modified",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -90,9 +90,24 @@ def reinit(self):\n         \"\"\"Initialize the random number generator and seed it with entropy from\n         the operating system.\n         \"\"\"\n+\n+        # Save the pid (helps ensure that Crypto.Random.atfork() gets called)\n         self._pid = os.getpid()\n+\n+        # Collect entropy from the operating system and feed it to\n+        # FortunaAccumulator\n         self._ec.reinit()\n \n+        # Override FortunaAccumulator's 100ms minimum re-seed interval.  This\n+        # is necessary to avoid a race condition between this function and\n+        # self.read(), which that can otherwise cause forked child processes to\n+        # produce identical output.  (e.g. CVE-2013-1445)\n+        #\n+        # Note that if this function can be called frequently by an attacker,\n+        # (and if the bits from OSRNG are insufficiently random) it will weaken\n+        # Fortuna's ability to resist a state compromise extension attack.\n+        self._fa._forget_last_reseed()\n+\n     def close(self):\n         self.closed = True\n         self._osrng = None"
        },
        {
          "filename": "lib/Crypto/SelfTest/Random/__init__.py",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -32,6 +32,7 @@ def get_tests(config={}):\n     from Crypto.SelfTest.Random import OSRNG;               tests += OSRNG.get_tests(config=config)\n     from Crypto.SelfTest.Random import test_random;         tests += test_random.get_tests(config=config)\n     from Crypto.SelfTest.Random import test_rpoolcompat;    tests += test_rpoolcompat.get_tests(config=config)\n+    from Crypto.SelfTest.Random import test__UserFriendlyRNG; tests += test__UserFriendlyRNG.get_tests(config=config)\n     return tests\n \n if __name__ == '__main__':"
        },
        {
          "filename": "lib/Crypto/SelfTest/Random/test__UserFriendlyRNG.py",
          "status": "added",
          "additions": 171,
          "deletions": 0,
          "patch": "@@ -0,0 +1,171 @@\n+# -*- coding: utf-8 -*-\n+# Self-tests for the user-friendly Crypto.Random interface\n+#\n+# Written in 2013 by Dwayne C. Litzenberger <dlitz@dlitz.net>\n+#\n+# ===================================================================\n+# The contents of this file are dedicated to the public domain.  To\n+# the extent that dedication to the public domain is not available,\n+# everyone is granted a worldwide, perpetual, royalty-free,\n+# non-exclusive license to exercise all rights associated with the\n+# contents of this file for any purpose whatsoever.\n+# No rights are reserved.\n+#\n+# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n+# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n+# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n+# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+# SOFTWARE.\n+# ===================================================================\n+\n+\"\"\"Self-test suite for generic Crypto.Random stuff \"\"\"\n+\n+from __future__ import nested_scopes\n+\n+__revision__ = \"$Id$\"\n+\n+import binascii\n+import pprint\n+import unittest\n+import os\n+import time\n+import sys\n+if sys.version_info[0] == 2 and sys.version_info[1] == 1:\n+    from Crypto.Util.py21compat import *\n+from Crypto.Util.py3compat import *\n+\n+try:\n+    import multiprocessing\n+except ImportError:\n+    multiprocessing = None\n+\n+import Crypto.Random._UserFriendlyRNG\n+import Crypto.Random.random\n+\n+class RNGForkTest(unittest.TestCase):\n+\n+    def _get_reseed_count(self):\n+        \"\"\"\n+        Get `FortunaAccumulator.reseed_count`, the global count of the\n+        number of times that the PRNG has been reseeded.\n+        \"\"\"\n+        rng_singleton = Crypto.Random._UserFriendlyRNG._get_singleton()\n+        rng_singleton._lock.acquire()\n+        try:\n+            return rng_singleton._fa.reseed_count\n+        finally:\n+            rng_singleton._lock.release()\n+\n+    def runTest(self):\n+        # Regression test for CVE-2013-1445.  We had a bug where, under the\n+        # right conditions, two processes might see the same random sequence.\n+\n+        if sys.platform.startswith('win'):  # windows can't fork\n+            assert not hasattr(os, 'fork')    # ... right?\n+            return\n+\n+        # Wait 150 ms so that we don't trigger the rate-limit prematurely.\n+        time.sleep(0.15)\n+\n+        reseed_count_before = self._get_reseed_count()\n+\n+        # One or both of these calls together should trigger a reseed right here.\n+        Crypto.Random._UserFriendlyRNG._get_singleton().reinit()\n+        Crypto.Random.get_random_bytes(1)\n+\n+        reseed_count_after = self._get_reseed_count()\n+        self.assertNotEqual(reseed_count_before, reseed_count_after)  # sanity check: test should reseed parent before forking\n+\n+        rfiles = []\n+        for i in range(10):\n+            rfd, wfd = os.pipe()\n+            if os.fork() == 0:\n+                # child\n+                os.close(rfd)\n+                f = os.fdopen(wfd, \"wb\")\n+\n+                Crypto.Random.atfork()\n+\n+                data = Crypto.Random.get_random_bytes(16)\n+\n+                f.write(data)\n+                f.close()\n+                os._exit(0)\n+            # parent\n+            os.close(wfd)\n+            rfiles.append(os.fdopen(rfd, \"rb\"))\n+\n+        results = []\n+        results_dict = {}\n+        for f in rfiles:\n+            data = binascii.hexlify(f.read())\n+            results.append(data)\n+            results_dict[data] = 1\n+            f.close()\n+\n+        if len(results) != len(results_dict.keys()):\n+            raise AssertionError(\"RNG output duplicated across fork():\\n%s\" %\n+                                 (pprint.pformat(results)))\n+\n+\n+# For RNGMultiprocessingForkTest\n+def _task_main(q):\n+    a = Crypto.Random.get_random_bytes(16)\n+    time.sleep(0.1)     # wait 100 ms\n+    b = Crypto.Random.get_random_bytes(16)\n+    q.put(binascii.b2a_hex(a))\n+    q.put(binascii.b2a_hex(b))\n+    q.put(None)      # Wait for acknowledgment\n+\n+\n+class RNGMultiprocessingForkTest(unittest.TestCase):\n+\n+    def runTest(self):\n+        # Another regression test for CVE-2013-1445.  This is basically the\n+        # same as RNGForkTest, but less compatible with old versions of Python,\n+        # and a little easier to read.\n+\n+        n_procs = 5\n+        manager = multiprocessing.Manager()\n+        queues = [manager.Queue(1) for i in range(n_procs)]\n+\n+        # Reseed the pool\n+        time.sleep(0.15)\n+        Crypto.Random._UserFriendlyRNG._get_singleton().reinit()\n+        Crypto.Random.get_random_bytes(1)\n+\n+        # Start the child processes\n+        pool = multiprocessing.Pool(processes=n_procs, initializer=Crypto.Random.atfork)\n+        map_result = pool.map_async(_task_main, queues)\n+\n+        # Get the results, ensuring that no pool processes are reused.\n+        aa = [queues[i].get(30) for i in range(n_procs)]\n+        bb = [queues[i].get(30) for i in range(n_procs)]\n+        res = list(zip(aa, bb))\n+\n+        # Shut down the pool\n+        map_result.get(30)\n+        pool.close()\n+        pool.join()\n+\n+        # Check that the results are unique\n+        if len(set(aa)) != len(aa) or len(set(res)) != len(res):\n+            raise AssertionError(\"RNG output duplicated across fork():\\n%s\" %\n+                                 (pprint.pformat(res),))\n+\n+\n+def get_tests(config={}):\n+    tests = []\n+    tests += [RNGForkTest()]\n+    if multiprocessing is not None:\n+        tests += [RNGMultiprocessingForkTest()]\n+    return tests\n+\n+if __name__ == '__main__':\n+    suite = lambda: unittest.TestSuite(get_tests())\n+    unittest.main(defaultTest='suite')\n+\n+# vim:set ts=4 sw=4 sts=4 expandtab:"
        }
      ],
      "file_patterns": {
        "security_files": 4,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 3,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "65b43bd4ffe2a48bdedae986b1a291f5a2cc7df7",
            "date": "2022-01-25T06:57:52Z",
            "author_login": "dlitz"
          },
          {
            "sha": "c2ebfaca998691bc4386f237cde351e926ca3cdb",
            "date": "2022-01-25T06:29:04Z",
            "author_login": "dlitz"
          },
          {
            "sha": "d5782d87af27db8cc5776a3f476c11f8bb6e41a3",
            "date": "2022-01-25T05:40:09Z",
            "author_login": "dlitz"
          },
          {
            "sha": "9b0a52449b4b4e0afb691f6206e4b59b534965d5",
            "date": "2022-01-25T05:14:47Z",
            "author_login": "dlitz"
          },
          {
            "sha": "4d75f91e18799a99bbd476b345c558d3ec457762",
            "date": "2022-01-23T03:53:27Z",
            "author_login": "dlitz"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-310",
    "description": "The Crypto.Random.atfork function in PyCrypto before 2.6.1 does not properly reseed the pseudo-random number generator (PRNG) before allowing a child process to access it, which makes it easier for context-dependent attackers to obtain sensitive information by leveraging a race condition in which a child process is created and accesses the PRNG within the same rate-limit period as another process.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2013-10-26T17:55:03.027",
    "last_modified": "2024-11-21T01:49:36.460",
    "fix_date": "2013-10-14T21:37:35Z"
  },
  "references": [
    {
      "url": "http://www.debian.org/security/2013/dsa-2781",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2013/10/17/3",
      "source": "security@debian.org",
      "tags": [
        "Exploit",
        "Patch"
      ]
    },
    {
      "url": "https://github.com/dlitz/pycrypto/commit/19dcf7b15d61b7dc1a125a367151de40df6ef175",
      "source": "security@debian.org",
      "tags": [
        "Exploit"
      ]
    },
    {
      "url": "http://www.debian.org/security/2013/dsa-2781",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2013/10/17/3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch"
      ]
    },
    {
      "url": "https://github.com/dlitz/pycrypto/commit/19dcf7b15d61b7dc1a125a367151de40df6ef175",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:20.035620",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "pycrypto",
    "owner": "dlitz",
    "created_at": "2010-11-30T02:10:21Z",
    "updated_at": "2025-01-24T08:31:55Z",
    "pushed_at": "2022-01-26T16:04:12Z",
    "size": 12155,
    "stars": 2454,
    "forks": 635,
    "open_issues": 212,
    "watchers": 2454,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Python": 1109420,
      "C": 711411,
      "Shell": 43068,
      "M4": 15692
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T07:53:56.188184"
  }
}