{
  "cve_id": "CVE-2013-4251",
  "github_data": {
    "repository": "scipy/scipy",
    "fix_commit": "bd296e0336420b840fcd2faabb97084fd252a973",
    "related_commits": [
      "bd296e0336420b840fcd2faabb97084fd252a973",
      "bd296e0336420b840fcd2faabb97084fd252a973"
    ],
    "patch_url": "https://github.com/scipy/scipy/commit/bd296e0336420b840fcd2faabb97084fd252a973.patch",
    "fix_commit_details": {
      "sha": "bd296e0336420b840fcd2faabb97084fd252a973",
      "commit_date": "2013-09-01T13:40:18Z",
      "author": {
        "login": "TomasTomecek",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "BUG: weave: fix issues with temporary directory usage",
        "length": 53,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 485,
        "additions": 436,
        "deletions": 49
      },
      "files": [
        {
          "filename": "scipy/weave/catalog.py",
          "status": "modified",
          "additions": 216,
          "deletions": 43,
          "patch": "@@ -34,6 +34,7 @@\n \n import os\n import sys\n+import stat\n import pickle\n import socket\n import tempfile\n@@ -133,7 +134,7 @@ def is_writable(dir):\n \n     # Do NOT use a hardcoded name here due to the danger from race conditions\n     # on NFS when multiple processes are accessing the same base directory in\n-    # parallel.  We use both hostname and pocess id for the prefix in an\n+    # parallel.  We use both hostname and process id for the prefix in an\n     # attempt to ensure that there can really be no name collisions (tempfile\n     # appends 6 random chars to this prefix).\n     prefix = 'dummy_%s_%s_' % (socket.gethostname(),os.getpid())\n@@ -150,6 +151,88 @@ def whoami():\n     \"\"\"return a string identifying the user.\"\"\"\n     return os.environ.get(\"USER\") or os.environ.get(\"USERNAME\") or \"unknown\"\n \n+\n+def _create_dirs(path):\n+    \"\"\" create provided path, ignore errors \"\"\"\n+    try:\n+        os.makedirs(path, mode=0o700)\n+    except OSError:\n+        pass\n+\n+\n+def default_dir_posix(tmp_dir=None):\n+    \"\"\"\n+    Create or find default catalog store for posix systems\n+\n+    purpose of 'tmp_dir' is to enable way how to test this function easily\n+    \"\"\"\n+    path_candidates = []\n+    python_name = \"python%d%d_compiled\" % tuple(sys.version_info[:2])\n+\n+    if tmp_dir:\n+        home_dir = tmp_dir\n+    else:\n+        home_dir = os.path.expanduser('~')\n+    tmp_dir = tmp_dir or tempfile.gettempdir()\n+\n+    home_temp_dir_name = '.' + python_name\n+    home_temp_dir = os.path.join(home_dir, home_temp_dir_name)\n+    path_candidates.append(home_temp_dir)\n+\n+    temp_dir_name = repr(os.getuid()) + '_' + python_name\n+    temp_dir_path = os.path.join(tmp_dir, temp_dir_name)\n+    path_candidates.append(temp_dir_path)\n+\n+    for path in path_candidates:\n+        _create_dirs(path)\n+        if check_dir(path):\n+            return path\n+\n+    # since we got here, both dirs are not useful\n+    tmp_dir_path = find_valid_temp_dir(temp_dir_name, tmp_dir)\n+    if not tmp_dir_path:\n+        tmp_dir_path = create_temp_dir(temp_dir_name, tmp_dir=tmp_dir)\n+    return tmp_dir_path\n+\n+\n+def default_dir_win(tmp_dir=None):\n+    \"\"\"\n+    Create or find default catalog store for Windows systems\n+\n+    purpose of 'tmp_dir' is to enable way how to test this function easily\n+    \"\"\"\n+    def create_win_temp_dir(prefix, inner_dir=None, tmp_dir=None):\n+        \"\"\"\n+        create temp dir starting with 'prefix' in 'tmp_dir' or\n+        'tempfile.gettempdir'; if 'inner_dir' is specified, it should be\n+        created inside\n+        \"\"\"\n+        tmp_dir_path = find_valid_temp_dir(prefix, tmp_dir)\n+        if tmp_dir_path:\n+            if inner_dir:\n+                tmp_dir_path = os.path.join(tmp_dir_path, inner_dir)\n+                if not os.path.isdir(tmp_dir_path):\n+                    os.mkdir(tmp_dir_path, 0o700)\n+        else:\n+            tmp_dir_path = create_temp_dir(prefix, inner_dir, tmp_dir)\n+        return tmp_dir_path\n+\n+    python_name = \"python%d%d_compiled\" % tuple(sys.version_info[:2])\n+    tmp_dir = tmp_dir or tempfile.gettempdir()\n+\n+    temp_dir_name = \"%s\" % whoami()\n+    temp_root_dir = os.path.join(tmp_dir, temp_dir_name)\n+    temp_dir_path = os.path.join(temp_root_dir, python_name)\n+    _create_dirs(temp_dir_path)\n+    if check_dir(temp_dir_path) and check_dir(temp_root_dir):\n+        return temp_dir_path\n+    else:\n+        if check_dir(temp_root_dir):\n+            return create_win_temp_dir(python_name, tmp_dir=temp_root_dir)\n+        else:\n+            return create_win_temp_dir(temp_dir_name, python_name, tmp_dir)\n+\n+\n def default_dir():\n     \"\"\" Return a default location to store compiled files and catalogs.\n \n@@ -164,61 +247,151 @@ def default_dir():\n         in the user's home, /tmp/<uid>_pythonXX_compiled is used.  If it\n         doesn't exist, it is created.  The directory is marked rwx------\n         to try and keep people from being able to sneak a bad module\n-        in on you.\n-\n+        in on you. If the directory already exists in /tmp/ and is not\n+        secure, new one is created.\n     \"\"\"\n-\n     # Use a cached value for fast return if possible\n-    if hasattr(default_dir,\"cached_path\") and \\\n-       os.path.exists(default_dir.cached_path) and \\\n-       os.access(default_dir.cached_path, os.W_OK):\n+    if hasattr(default_dir, \"cached_path\") and \\\n+       check_dir(default_dir.cached_path):\n         return default_dir.cached_path\n \n-    python_name = \"python%d%d_compiled\" % tuple(sys.version_info[:2])\n-    path_candidates = []\n-    if sys.platform != 'win32':\n-        try:\n-            path_candidates.append(os.path.join(os.environ['HOME'],\n-                                                '.' + python_name))\n-        except KeyError:\n-            pass\n-\n-        temp_dir = repr(os.getuid()) + '_' + python_name\n-        path_candidates.append(os.path.join(tempfile.gettempdir(), temp_dir))\n+    if sys.platform == 'win32':\n+        path = default_dir_win()\n     else:\n-        path_candidates.append(os.path.join(tempfile.gettempdir(),\n-                                           \"%s\" % whoami(), python_name))\n-\n-    writable = False\n-    for path in path_candidates:\n-        if not os.path.exists(path):\n-            try:\n-                os.makedirs(path, mode=0o700)\n-            except OSError:\n-                continue\n-        if is_writable(path):\n-            writable = True\n-            break\n-\n-    if not writable:\n-        print('warning: default directory is not write accessible.')\n-        print('default:', path)\n+        path = default_dir_posix()\n \n     # Cache the default dir path so that this function returns quickly after\n     # being called once (nothing in it should change after the first call)\n     default_dir.cached_path = path\n \n     return path\n \n-def intermediate_dir():\n-    \"\"\" Location in temp dir for storing .cpp and .o  files during\n-        builds.\n+\n+def check_dir(im_dir):\n     \"\"\"\n-    python_name = \"python%d%d_intermediate\" % tuple(sys.version_info[:2])\n-    path = os.path.join(tempfile.gettempdir(),\"%s\"%whoami(),python_name)\n-    if not os.path.exists(path):\n-        os.makedirs(path, mode=0o700)\n-    return path\n+    Check if dir is safe; if it is, return True.\n+    These checks make sense only on posix:\n+     * directory has correct owner\n+     * directory has correct permissions (0700)\n+     * directory is not a symlink\n+    \"\"\"\n+    def check_is_dir():\n+        return os.path.isdir(im_dir)\n+\n+    def check_permissions():\n+        \"\"\" If on posix, permissions should be 0700. \"\"\"\n+        writable = is_writable(im_dir)\n+        if sys.platform != 'win32':\n+            try:\n+                im_dir_stat = os.stat(im_dir)\n+            except OSError:\n+                return False\n+            writable &= stat.S_IMODE(im_dir_stat.st_mode) == 0o0700\n+        return writable\n+\n+    def check_ownership():\n+        \"\"\" Intermediate dir owner should be same as owner of process. \"\"\"\n+        if sys.platform != 'win32':\n+            try:\n+                im_dir_stat = os.stat(im_dir)\n+            except OSError:\n+                return False\n+            proc_uid = os.getuid()\n+            return proc_uid == im_dir_stat.st_uid\n+        return True\n+\n+    def check_is_symlink():\n+        \"\"\" Check if intermediate dir is symlink. \"\"\"\n+        try:\n+            return not os.path.islink(im_dir)\n+        except OSError:\n+            return False\n+\n+    checks = [check_is_dir, check_permissions,\n+              check_ownership, check_is_symlink]\n+\n+    for check in checks:\n+        if not check():\n+            return False\n+\n+    return True\n+\n+\n+def create_temp_dir(prefix, inner_dir=None, tmp_dir=None):\n+    \"\"\"\n+    Create intermediate dirs <tmp>/<prefix+random suffix>/<inner_dir>/\n+\n+    argument 'tmp_dir' is used in unit tests\n+    \"\"\"\n+    if not tmp_dir:\n+        tmp_dir_path = tempfile.mkdtemp(prefix=prefix)\n+    else:\n+        tmp_dir_path = tempfile.mkdtemp(prefix=prefix, dir=tmp_dir)\n+    if inner_dir:\n+        tmp_dir_path = os.path.join(tmp_dir_path, inner_dir)\n+        os.mkdir(tmp_dir_path, 0o700)\n+    return tmp_dir_path\n+\n+\n+def intermediate_dir_prefix():\n+    \"\"\" Prefix of root intermediate dir (<tmp>/<root_im_dir>). \"\"\"\n+    return \"%s-%s-\" % (\"scipy\", whoami())\n+\n+\n+def find_temp_dir(prefix, tmp_dir=None):\n+    \"\"\" Find temp dirs in 'tmp_dir' starting with 'prefix'\"\"\"\n+    matches = []\n+    tmp_dir = tmp_dir or tempfile.gettempdir()\n+    for tmp_file in os.listdir(tmp_dir):\n+        if tmp_file.startswith(prefix):\n+            matches.append(os.path.join(tmp_dir, tmp_file))\n+    return matches\n+\n+\n+def find_valid_temp_dir(prefix, tmp_dir=None):\n+    \"\"\"\n+    Try to look for existing temp dirs.\n+    If there is one suitable found, return it, otherwise return None.\n+    \"\"\"\n+    matches = find_temp_dir(prefix, tmp_dir)\n+    for match in matches:\n+        if check_dir(match):\n+            # as soon as we find correct dir, we can stop searching\n+            return match\n+\n+\n+def py_intermediate_dir():\n+    \"\"\"\n+    Name of intermediate dir for current python interpreter:\n+    <temp dir>/<name>/pythonXY_intermediate/\n+    \"\"\"\n+    name = \"python%d%d_intermediate\" % tuple(sys.version_info[:2])\n+    return name\n+\n+\n+def create_intermediate_dir(tmp_dir=None):\n+    py_im_dir = py_intermediate_dir()\n+    return create_temp_dir(intermediate_dir_prefix(), py_im_dir, tmp_dir)\n+\n+\n+def intermediate_dir(tmp_dir=None):\n+    \"\"\"\n+    Temporary directory for storing .cpp and .o files during builds.\n+\n+    First, try to find the dir and if it exists, verify it is safe.\n+    Otherwise, create it.\n+    \"\"\"\n+    im_dir = find_valid_temp_dir(intermediate_dir_prefix(), tmp_dir)\n+    py_im_dir = py_intermediate_dir()\n+    if im_dir is None:\n+        py_im_dir = py_intermediate_dir()\n+        im_dir = create_intermediate_dir(tmp_dir)\n+    else:\n+        im_dir = os.path.join(im_dir, py_im_dir)\n+        if not os.path.isdir(im_dir):\n+            os.mkdir(im_dir, 0o700)\n+    return im_dir\n+\n \n def default_temp_dir():\n     path = os.path.join(default_dir(),'temp')"
        },
        {
          "filename": "scipy/weave/tests/test_catalog.py",
          "status": "modified",
          "additions": 220,
          "deletions": 6,
          "patch": "@@ -2,16 +2,234 @@\n \n import sys\n import os\n+import stat\n+import tempfile\n+\n+from distutils.dir_util import remove_tree\n \n from numpy.testing import TestCase, assert_\n+from numpy.testing.noseclasses import KnownFailureTest\n \n from scipy.weave import catalog\n from weave_test_utils import clear_temp_catalog, restore_temp_catalog, \\\n         empty_temp_dir, cleanup_temp_dir\n \n \n+class TestIntermediateDir(TestCase):\n+    \"\"\"\n+    Tests for intermediate dir (store of .cpp and .o during builds).\n+    These tests test whether intermediate dir is safe. If it's not,\n+    new one should be created.\n+    \"\"\"\n+    def dirs_are_valid(self, wrong_dir, tmpdir):\n+        \"\"\" test if new dir is created and is consistent \"\"\"\n+        new_im_dir = catalog.intermediate_dir(tmpdir)\n+        assert_(not os.path.samefile(new_im_dir, wrong_dir))\n+        new_im_dir2 = catalog.intermediate_dir(tmpdir)\n+        assert_(os.path.samefile(new_im_dir, new_im_dir2))\n+\n+    def test_ownership(self):\n+        \"\"\" test if intermediate dir is owned by correct user \"\"\"\n+        if sys.platform != 'win32':\n+            im_dir = catalog.intermediate_dir()\n+            im_dir_stat = os.stat(im_dir)\n+            proc_uid = os.getuid()\n+            assert_(proc_uid == im_dir_stat.st_uid)\n+            r_im_dir_stat = os.stat(os.path.dirname(im_dir))\n+            assert_(proc_uid == r_im_dir_stat.st_uid)\n+\n+    def test_incorrect_ownership(self):\n+        \"\"\"\n+        test if new intermediate dir is created when there is only one\n+        im dir owned by improper user\n+        \"\"\"\n+        if sys.platform != 'win32':\n+            import pwd\n+            tmpdir = tempfile.mkdtemp()\n+            try:\n+                im_dir = catalog.create_intermediate_dir(tmpdir)\n+                root_im_dir = os.path.dirname(im_dir)\n+                nobody = pwd.getpwnam('nobody')[2]\n+                nobody_g = pwd.getpwnam('nobody')[3]\n+                try:\n+                    os.chown(root_im_dir, nobody, nobody_g)\n+                except OSError:\n+                    raise KnownFailureTest(\"Can't change owner.\")\n+                else:\n+                    self.dirs_are_valid(im_dir, tmpdir)\n+            finally:\n+                remove_tree(tmpdir)\n+\n+    def test_permissions(self):\n+        \"\"\" im dir should have permissions 0700 \"\"\"\n+        if sys.platform != 'win32':\n+            im_dir = catalog.intermediate_dir()\n+            im_dir_stat = os.stat(im_dir)\n+            assert_(stat.S_IMODE(im_dir_stat.st_mode) == 0o0700)\n+            r_im_dir_stat = os.stat(os.path.dirname(im_dir))\n+            assert_(stat.S_IMODE(r_im_dir_stat.st_mode) == 0o0700)\n+\n+    def test_incorrect_permissions(self):\n+        \"\"\"\n+        if permissions on existing im dir are not correct,\n+        new one should be created\n+        \"\"\"\n+        if sys.platform != 'win32':\n+            tmpdir = tempfile.mkdtemp()\n+            try:\n+                im_dir = catalog.create_intermediate_dir(tmpdir)\n+                root_im_dir = os.path.dirname(im_dir)\n+                try:\n+                    os.chmod(root_im_dir, 0o777)\n+                except OSError:\n+                    raise KnownFailureTest(\"Can't set file permissions.\")\n+                else:\n+                    self.dirs_are_valid(im_dir, tmpdir)\n+            finally:\n+                remove_tree(tmpdir)\n+\n+    def test_symlink(self):\n+        \"\"\" im dir shouldn't be a symlink \"\"\"\n+        if sys.platform != 'win32':\n+            r_im_dir = os.path.dirname(catalog.intermediate_dir())\n+            assert_(os.path.islink(r_im_dir) is False)\n+\n+    def test_symlink_raise(self):\n+        \"\"\" if existing im dir is a symlink, new one should be created \"\"\"\n+        if sys.platform != 'win32':\n+            tmpdir = tempfile.mkdtemp()\n+            try:\n+                im_dir = catalog.create_intermediate_dir(tmpdir)\n+                root_im_dir = os.path.dirname(im_dir)\n+\n+                tempdir = tempfile.mkdtemp(prefix='scipy-test', dir=tmpdir)\n+                try:\n+                    os.rename(root_im_dir, tempdir)\n+                except OSError:\n+                    raise KnownFailureTest(\"Can't move intermediate dir.\")\n+\n+                try:\n+                    os.symlink(tempdir, root_im_dir)\n+                except OSError:\n+                    raise KnownFailureTest(\n+                        \"Can't create symlink to intermediate dir.\")\n+                else:\n+                    self.dirs_are_valid(im_dir, tmpdir)\n+            finally:\n+                remove_tree(tmpdir)\n+\n+\n class TestDefaultDir(TestCase):\n+    \"\"\"\n+    Tests for 'catalog.default_dir()'.\n+    These should verified posix and win default_dir function.\n+    \"\"\"\n+    def test_win(self):\n+        \"\"\"\n+        test if default_dir for Windows platform is accessible\n+\n+        since default_dir_win() does not have any Windows specific code,\n+        let's test it everywhere\n+        \"\"\"\n+        d = catalog.default_dir_win()\n+        assert_(catalog.is_writable(d))\n+\n+    def test_win_inaccessible_root(self):\n+        \"\"\"\n+        there should be a new root dir created if existing one is not accessible\n+        \"\"\"\n+        tmpdir = tempfile.mkdtemp()\n+        try:\n+            d_dir = catalog.default_dir_win(tmpdir)\n+            root_ddir = os.path.dirname(d_dir)\n+\n+            try:\n+                os.chmod(root_ddir, stat.S_IREAD | stat.S_IEXEC)\n+            except OSError:\n+                raise KnownFailureTest(\"Can't change permissions of root default_dir.\")\n+\n+            new_ddir = catalog.default_dir_win(tmpdir)\n+            assert_(not os.path.samefile(new_ddir, d_dir))\n+            new_ddir2 = catalog.default_dir_win(tmpdir)\n+            assert_(os.path.samefile(new_ddir, new_ddir2))\n+        finally:\n+            os.chmod(root_ddir, 0o700)\n+            remove_tree(tmpdir)\n+\n+    def test_win_inaccessible_ddir(self):\n+        \"\"\"\n+        create new defualt_dir if current one is not accessible\n+        \"\"\"\n+        tmpdir = tempfile.mkdtemp()\n+        try:\n+            d_dir = catalog.default_dir_win(tmpdir)\n+\n+            try:\n+                os.chmod(d_dir, stat.S_IREAD | stat.S_IEXEC)\n+            except OSError:\n+                raise KnownFailureTest(\"Can't change permissions of default_dir.\")\n+\n+            new_ddir = catalog.default_dir_win(tmpdir)\n+            assert_(not os.path.samefile(new_ddir, d_dir))\n+            new_ddir2 = catalog.default_dir_win(tmpdir)\n+            assert_(os.path.samefile(new_ddir, new_ddir2))\n+        finally:\n+            os.chmod(d_dir, 0o700)\n+            remove_tree(tmpdir)\n+\n+    def test_posix(self):\n+        \"\"\" test if posix default_dir is writable \"\"\"\n+        d = catalog.default_dir_posix()\n+        assert_(catalog.is_writable(d))\n+\n+    def test_posix_home_inaccessible(self):\n+        \"\"\" what happens when home catalog dir is innaccessible \"\"\"\n+        tmpdir = tempfile.mkdtemp()\n+        try:\n+            d_dir = catalog.default_dir_posix(tmpdir)\n+\n+            try:\n+                os.chmod(d_dir, 0o000)\n+            except OSError:\n+                raise KnownFailureTest(\"Can't change permissions of default_dir.\")\n+\n+            new_ddir = catalog.default_dir_posix(tmpdir)\n+            assert_(not os.path.samefile(new_ddir, d_dir))\n+            new_ddir2 = catalog.default_dir_posix(tmpdir)\n+            assert_(os.path.samefile(new_ddir, new_ddir2))\n+        finally:\n+            os.chmod(d_dir, 0o700)\n+            remove_tree(tmpdir)\n+\n+    def test_posix_dirs_inaccessible(self):\n+        \"\"\" test if new dir is created if both implicit dirs are not valid\"\"\"\n+        tmpdir = tempfile.mkdtemp()\n+        try:\n+            d_dir = catalog.default_dir_posix(tmpdir)\n+\n+            try:\n+                os.chmod(d_dir, 0o000)\n+            except OSError:\n+                raise KnownFailureTest(\"Can't change permissions of default_dir.\")\n+\n+            d_dir2 = catalog.default_dir_posix(tmpdir)\n+\n+            try:\n+                os.chmod(d_dir2, 0o000)\n+            except OSError:\n+                raise KnownFailureTest(\"Can't change permissions of default_dir.\")\n+\n+            new_ddir = catalog.default_dir_posix(tmpdir)\n+            assert_(not (os.path.samefile(new_ddir, d_dir) or os.path.samefile(new_ddir, d_dir2)))\n+            new_ddir2 = catalog.default_dir_posix(tmpdir)\n+            assert_(os.path.samefile(new_ddir, new_ddir2))\n+        finally:\n+            os.chmod(d_dir, 0o700)\n+            os.chmod(d_dir2, 0o700)\n+            remove_tree(tmpdir)\n+\n     def test_is_writable(self):\n+        \"\"\" default_dir has to be writable \"\"\"\n         path = catalog.default_dir()\n         name = os.path.join(path,'dummy_catalog')\n         test_file = open(name,'w')\n@@ -93,22 +311,18 @@ def get_test_dir(self,erase = 0):\n                 os.remove(cat_file)\n         return pardir\n \n-    def remove_dir(self,d):\n-        import distutils.dir_util\n-        distutils.dir_util.remove_tree(d)\n-\n     def test_nonexistent_catalog_is_none(self):\n         pardir = self.get_test_dir(erase=1)\n         cat = catalog.get_catalog(pardir,'r')\n-        self.remove_dir(pardir)\n+        remove_tree(pardir)\n         assert_(cat is None)\n \n     def test_create_catalog(self):\n         pardir = self.get_test_dir(erase=1)\n         cat = catalog.get_catalog(pardir,'c')\n         assert_(cat is not None)\n         cat.close()\n-        self.remove_dir(pardir)\n+        remove_tree(pardir)\n \n \n class TestCatalog(TestCase):"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "564da7926ac0900259bf62898f847b27252b6a49",
            "date": "2025-01-14T17:51:32Z",
            "author_login": "crusaderky"
          },
          {
            "sha": "4cc4d140efde4a33a77cd602c0d2f8698cf9b800",
            "date": "2025-01-14T08:05:11Z",
            "author_login": "tupui"
          },
          {
            "sha": "9856b797fc6a7952e1bd8e3ba5dd06ac5554ba6e",
            "date": "2025-01-14T05:17:40Z",
            "author_login": "mdhaber"
          },
          {
            "sha": "7b21d32ecacf9d049dad1d5c21ad98a3686d2c9b",
            "date": "2025-01-13T21:19:30Z",
            "author_login": "lithomas1"
          },
          {
            "sha": "90ad156fdbbd6971c5f62d84f2e68b58be210623",
            "date": "2025-01-13T20:57:23Z",
            "author_login": "andfoy"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.8,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-269",
    "description": "The scipy.weave component in SciPy before 0.12.1 creates insecure temporary directories.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2019-11-04T20:15:09.887",
    "last_modified": "2024-11-21T01:55:13.090",
    "fix_date": "2013-09-01T13:40:18Z"
  },
  "references": [
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-November/120696.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-October/119759.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-October/119771.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/63008",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://access.redhat.com/security/cve/cve-2013-4251",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2013-4251",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.suse.com/show_bug.cgi?id=CVE-2013-4251",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/88052",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/scipy/scipy/commit/bd296e0336420b840fcd2faabb97084fd252a973",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security-tracker.debian.org/tracker/CVE-2013-4251",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-November/120696.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-October/119759.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-October/119771.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/63008",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://access.redhat.com/security/cve/cve-2013-4251",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2013-4251",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.suse.com/show_bug.cgi?id=CVE-2013-4251",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/88052",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/scipy/scipy/commit/bd296e0336420b840fcd2faabb97084fd252a973",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security-tracker.debian.org/tracker/CVE-2013-4251",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:09.180276",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "scipy",
    "owner": "scipy",
    "created_at": "2011-03-09T18:52:03Z",
    "updated_at": "2025-01-14T17:51:39Z",
    "pushed_at": "2025-01-14T17:51:33Z",
    "size": 174262,
    "stars": 13284,
    "forks": 5230,
    "open_issues": 1730,
    "watchers": 13284,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "maintenance/0.5.2.x",
      "maintenance/0.6.x",
      "maintenance/0.7.x",
      "maintenance/0.8.x",
      "maintenance/0.9.x",
      "maintenance/0.10.x",
      "maintenance/0.11.x",
      "maintenance/0.12.x",
      "maintenance/0.13.x",
      "maintenance/0.14.x",
      "maintenance/0.15.x",
      "maintenance/0.16.x",
      "maintenance/0.17.x",
      "maintenance/0.18.x",
      "maintenance/0.19.x",
      "maintenance/1.0.x",
      "maintenance/1.1.x",
      "maintenance/1.2.x",
      "maintenance/1.3.x",
      "maintenance/1.4.x",
      "maintenance/1.5.x",
      "maintenance/1.6.x",
      "maintenance/1.7.x",
      "maintenance/1.8.x",
      "maintenance/1.9.x",
      "maintenance/1.10.x",
      "maintenance/1.11.x",
      "maintenance/1.12.x"
    ],
    "languages": {
      "Python": 19582506,
      "C": 5502974,
      "Fortran": 3064531,
      "C++": 2919258,
      "Cython": 1389067,
      "Meson": 150006,
      "Shell": 18291,
      "MATLAB": 4346,
      "R": 3059,
      "Starlark": 1900,
      "Batchfile": 888,
      "Makefile": 778
    },
    "commit_activity": {
      "total_commits_last_year": 3096,
      "avg_commits_per_week": 59.53846153846154,
      "days_active_last_year": 355
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T19:20:29.805560"
  }
}