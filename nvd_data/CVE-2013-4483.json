{
  "cve_id": "CVE-2013-4483",
  "github_data": {
    "repository": "torvalds/linux",
    "fix_commit": "6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
    "related_commits": [
      "6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
      "6062a8dc0517bce23e3c2f7d2fea5e22411269a3"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
      "commit_date": "2013-05-01T02:15:44Z",
      "author": {
        "login": "rikvanriel",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "ipc,sem: fine grained locking for semtimedop",
        "length": 1841,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 328,
        "additions": 203,
        "deletions": 125
      },
      "files": [
        {
          "filename": "ipc/msg.c",
          "status": "modified",
          "additions": 6,
          "deletions": 1,
          "patch": "@@ -687,7 +687,12 @@ long do_msgsnd(int msqid, long mtype, void __user *mtext,\n \t\t\tgoto out_unlock_free;\n \t\t}\n \t\tss_add(msq, &s);\n-\t\tipc_rcu_getref(msq);\n+\n+\t\tif (!ipc_rcu_getref(msq)) {\n+\t\t\terr = -EIDRM;\n+\t\t\tgoto out_unlock_free;\n+\t\t}\n+\n \t\tmsg_unlock(msq);\n \t\tschedule();\n "
        },
        {
          "filename": "ipc/sem.c",
          "status": "modified",
          "additions": 171,
          "deletions": 100,
          "patch": "@@ -94,6 +94,7 @@\n struct sem {\n \tint\tsemval;\t\t/* current value */\n \tint\tsempid;\t\t/* pid of last operation */\n+\tspinlock_t\tlock;\t/* spinlock for fine-grained semtimedop */\n \tstruct list_head sem_pending; /* pending single-sop operations */\n };\n \n@@ -137,7 +138,6 @@ struct sem_undo_list {\n \n #define sem_ids(ns)\t((ns)->ids[IPC_SEM_IDS])\n \n-#define sem_unlock(sma)\t\tipc_unlock(&(sma)->sem_perm)\n #define sem_checkid(sma, semid)\tipc_checkid(&sma->sem_perm, semid)\n \n static int newary(struct ipc_namespace *, struct ipc_params *);\n@@ -189,11 +189,90 @@ void __init sem_init (void)\n \t\t\t\tIPC_SEM_IDS, sysvipc_sem_proc_show);\n }\n \n+/*\n+ * If the request contains only one semaphore operation, and there are\n+ * no complex transactions pending, lock only the semaphore involved.\n+ * Otherwise, lock the entire semaphore array, since we either have\n+ * multiple semaphores in our own semops, or we need to look at\n+ * semaphores from other pending complex operations.\n+ *\n+ * Carefully guard against sma->complex_count changing between zero\n+ * and non-zero while we are spinning for the lock. The value of\n+ * sma->complex_count cannot change while we are holding the lock,\n+ * so sem_unlock should be fine.\n+ *\n+ * The global lock path checks that all the local locks have been released,\n+ * checking each local lock once. This means that the local lock paths\n+ * cannot start their critical sections while the global lock is held.\n+ */\n+static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,\n+\t\t\t      int nsops)\n+{\n+\tint locknum;\n+ again:\n+\tif (nsops == 1 && !sma->complex_count) {\n+\t\tstruct sem *sem = sma->sem_base + sops->sem_num;\n+\n+\t\t/* Lock just the semaphore we are interested in. */\n+\t\tspin_lock(&sem->lock);\n+\n+\t\t/*\n+\t\t * If sma->complex_count was set while we were spinning,\n+\t\t * we may need to look at things we did not lock here.\n+\t\t */\n+\t\tif (unlikely(sma->complex_count)) {\n+\t\t\tspin_unlock(&sem->lock);\n+\t\t\tgoto lock_array;\n+\t\t}\n+\n+\t\t/*\n+\t\t * Another process is holding the global lock on the\n+\t\t * sem_array; we cannot enter our critical section,\n+\t\t * but have to wait for the global lock to be released.\n+\t\t */\n+\t\tif (unlikely(spin_is_locked(&sma->sem_perm.lock))) {\n+\t\t\tspin_unlock(&sem->lock);\n+\t\t\tspin_unlock_wait(&sma->sem_perm.lock);\n+\t\t\tgoto again;\n+\t\t}\n+\n+\t\tlocknum = sops->sem_num;\n+\t} else {\n+\t\tint i;\n+\t\t/*\n+\t\t * Lock the semaphore array, and wait for all of the\n+\t\t * individual semaphore locks to go away.  The code\n+\t\t * above ensures no new single-lock holders will enter\n+\t\t * their critical section while the array lock is held.\n+\t\t */\n+ lock_array:\n+\t\tspin_lock(&sma->sem_perm.lock);\n+\t\tfor (i = 0; i < sma->sem_nsems; i++) {\n+\t\t\tstruct sem *sem = sma->sem_base + i;\n+\t\t\tspin_unlock_wait(&sem->lock);\n+\t\t}\n+\t\tlocknum = -1;\n+\t}\n+\treturn locknum;\n+}\n+\n+static inline void sem_unlock(struct sem_array *sma, int locknum)\n+{\n+\tif (locknum == -1) {\n+\t\tspin_unlock(&sma->sem_perm.lock);\n+\t} else {\n+\t\tstruct sem *sem = sma->sem_base + locknum;\n+\t\tspin_unlock(&sem->lock);\n+\t}\n+\trcu_read_unlock();\n+}\n+\n /*\n  * sem_lock_(check_) routines are called in the paths where the rw_mutex\n  * is not held.\n  */\n-static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns, int id)\n+static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns,\n+\t\t\tint id, struct sembuf *sops, int nsops, int *locknum)\n {\n \tstruct kern_ipc_perm *ipcp;\n \tstruct sem_array *sma;\n@@ -205,15 +284,16 @@ static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns, int id\n \t\tgoto err;\n \t}\n \n-\tspin_lock(&ipcp->lock);\n+\tsma = container_of(ipcp, struct sem_array, sem_perm);\n+\t*locknum = sem_lock(sma, sops, nsops);\n \n \t/* ipc_rmid() may have already freed the ID while sem_lock\n \t * was spinning: verify that the structure is still valid\n \t */\n \tif (!ipcp->deleted)\n \t\treturn container_of(ipcp, struct sem_array, sem_perm);\n \n-\tspin_unlock(&ipcp->lock);\n+\tsem_unlock(sma, *locknum);\n \tsma = ERR_PTR(-EINVAL);\n err:\n \trcu_read_unlock();\n@@ -230,17 +310,6 @@ static inline struct sem_array *sem_obtain_object(struct ipc_namespace *ns, int\n \treturn container_of(ipcp, struct sem_array, sem_perm);\n }\n \n-static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,\n-\t\t\t\t\t\tint id)\n-{\n-\tstruct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);\n-\n-\tif (IS_ERR(ipcp))\n-\t\treturn ERR_CAST(ipcp);\n-\n-\treturn container_of(ipcp, struct sem_array, sem_perm);\n-}\n-\n static inline struct sem_array *sem_obtain_object_check(struct ipc_namespace *ns,\n \t\t\t\t\t\t\tint id)\n {\n@@ -254,31 +323,31 @@ static inline struct sem_array *sem_obtain_object_check(struct ipc_namespace *ns\n \n static inline void sem_lock_and_putref(struct sem_array *sma)\n {\n-\tipc_lock_by_ptr(&sma->sem_perm);\n+\trcu_read_lock();\n+\tsem_lock(sma, NULL, -1);\n \tipc_rcu_putref(sma);\n }\n \n static inline void sem_getref_and_unlock(struct sem_array *sma)\n {\n-\tipc_rcu_getref(sma);\n-\tipc_unlock(&(sma)->sem_perm);\n+\tWARN_ON_ONCE(!ipc_rcu_getref(sma));\n+\tsem_unlock(sma, -1);\n }\n \n static inline void sem_putref(struct sem_array *sma)\n {\n-\tipc_lock_by_ptr(&sma->sem_perm);\n-\tipc_rcu_putref(sma);\n-\tipc_unlock(&(sma)->sem_perm);\n+\tsem_lock_and_putref(sma);\n+\tsem_unlock(sma, -1);\n }\n \n /*\n  * Call inside the rcu read section.\n  */\n static inline void sem_getref(struct sem_array *sma)\n {\n-\tspin_lock(&(sma)->sem_perm.lock);\n-\tipc_rcu_getref(sma);\n-\tipc_unlock(&(sma)->sem_perm);\n+\tsem_lock(sma, NULL, -1);\n+\tWARN_ON_ONCE(!ipc_rcu_getref(sma));\n+\tsem_unlock(sma, -1);\n }\n \n static inline void sem_rmid(struct ipc_namespace *ns, struct sem_array *s)\n@@ -371,15 +440,17 @@ static int newary(struct ipc_namespace *ns, struct ipc_params *params)\n \n \tsma->sem_base = (struct sem *) &sma[1];\n \n-\tfor (i = 0; i < nsems; i++)\n+\tfor (i = 0; i < nsems; i++) {\n \t\tINIT_LIST_HEAD(&sma->sem_base[i].sem_pending);\n+\t\tspin_lock_init(&sma->sem_base[i].lock);\n+\t}\n \n \tsma->complex_count = 0;\n \tINIT_LIST_HEAD(&sma->sem_pending);\n \tINIT_LIST_HEAD(&sma->list_id);\n \tsma->sem_nsems = nsems;\n \tsma->sem_ctime = get_seconds();\n-\tsem_unlock(sma);\n+\tsem_unlock(sma, -1);\n \n \treturn sma->sem_perm.id;\n }\n@@ -818,7 +889,7 @@ static void freeary(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\n \n \t/* Remove the semaphore set from the IDR */\n \tsem_rmid(ns, sma);\n-\tsem_unlock(sma);\n+\tsem_unlock(sma, -1);\n \n \twake_up_sem_queue_do(&tasks);\n \tns->used_sems -= sma->sem_nsems;\n@@ -947,7 +1018,6 @@ static int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,\n \tstruct sem_array *sma;\n \tstruct sem* curr;\n \tint err;\n-\tint nsems;\n \tstruct list_head tasks;\n \tint val;\n #if defined(CONFIG_64BIT) && defined(__BIG_ENDIAN)\n@@ -958,31 +1028,39 @@ static int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,\n \tval = arg;\n #endif\n \n-\tsma = sem_lock_check(ns, semid);\n-\tif (IS_ERR(sma))\n-\t\treturn PTR_ERR(sma);\n+\tif (val > SEMVMX || val < 0)\n+\t\treturn -ERANGE;\n \n \tINIT_LIST_HEAD(&tasks);\n-\tnsems = sma->sem_nsems;\n \n-\terr = -EACCES;\n-\tif (ipcperms(ns, &sma->sem_perm, S_IWUGO))\n-\t\tgoto out_unlock;\n+\trcu_read_lock();\n+\tsma = sem_obtain_object_check(ns, semid);\n+\tif (IS_ERR(sma)) {\n+\t\trcu_read_unlock();\n+\t\treturn PTR_ERR(sma);\n+\t}\n+\n+\tif (semnum < 0 || semnum >= sma->sem_nsems) {\n+\t\trcu_read_unlock();\n+\t\treturn -EINVAL;\n+\t}\n+\n+\n+\tif (ipcperms(ns, &sma->sem_perm, S_IWUGO)) {\n+\t\trcu_read_unlock();\n+\t\treturn -EACCES;\n+\t}\n \n \terr = security_sem_semctl(sma, SETVAL);\n-\tif (err)\n-\t\tgoto out_unlock;\n+\tif (err) {\n+\t\trcu_read_unlock();\n+\t\treturn -EACCES;\n+\t}\n \n-\terr = -EINVAL;\n-\tif(semnum < 0 || semnum >= nsems)\n-\t\tgoto out_unlock;\n+\tsem_lock(sma, NULL, -1);\n \n \tcurr = &sma->sem_base[semnum];\n \n-\terr = -ERANGE;\n-\tif (val > SEMVMX || val < 0)\n-\t\tgoto out_unlock;\n-\n \tassert_spin_locked(&sma->sem_perm.lock);\n \tlist_for_each_entry(un, &sma->list_id, list_id)\n \t\tun->semadj[semnum] = 0;\n@@ -992,11 +1070,9 @@ static int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,\n \tsma->sem_ctime = get_seconds();\n \t/* maybe some queued-up processes were waiting for this */\n \tdo_smart_update(sma, NULL, 0, 0, &tasks);\n-\terr = 0;\n-out_unlock:\n-\tsem_unlock(sma);\n+\tsem_unlock(sma, -1);\n \twake_up_sem_queue_do(&tasks);\n-\treturn err;\n+\treturn 0;\n }\n \n static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,\n@@ -1051,16 +1127,16 @@ static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,\n \n \t\t\tsem_lock_and_putref(sma);\n \t\t\tif (sma->sem_perm.deleted) {\n-\t\t\t\tsem_unlock(sma);\n+\t\t\t\tsem_unlock(sma, -1);\n \t\t\t\terr = -EIDRM;\n \t\t\t\tgoto out_free;\n \t\t\t}\n-\t\t}\n+\t\t} else\n+\t\t\tsem_lock(sma, NULL, -1);\n \n-\t\tspin_lock(&sma->sem_perm.lock);\n \t\tfor (i = 0; i < sma->sem_nsems; i++)\n \t\t\tsem_io[i] = sma->sem_base[i].semval;\n-\t\tsem_unlock(sma);\n+\t\tsem_unlock(sma, -1);\n \t\terr = 0;\n \t\tif(copy_to_user(array, sem_io, nsems*sizeof(ushort)))\n \t\t\terr = -EFAULT;\n@@ -1071,7 +1147,10 @@ static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,\n \t\tint i;\n \t\tstruct sem_undo *un;\n \n-\t\tipc_rcu_getref(sma);\n+\t\tif (!ipc_rcu_getref(sma)) {\n+\t\t\trcu_read_unlock();\n+\t\t\treturn -EIDRM;\n+\t\t}\n \t\trcu_read_unlock();\n \n \t\tif(nsems > SEMMSL_FAST) {\n@@ -1097,7 +1176,7 @@ static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,\n \t\t}\n \t\tsem_lock_and_putref(sma);\n \t\tif (sma->sem_perm.deleted) {\n-\t\t\tsem_unlock(sma);\n+\t\t\tsem_unlock(sma, -1);\n \t\t\terr = -EIDRM;\n \t\t\tgoto out_free;\n \t\t}\n@@ -1124,7 +1203,7 @@ static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,\n \t\tgoto out_wakeup;\n \t}\n \n-\tspin_lock(&sma->sem_perm.lock);\n+\tsem_lock(sma, NULL, -1);\n \tcurr = &sma->sem_base[semnum];\n \n \tswitch (cmd) {\n@@ -1143,7 +1222,7 @@ static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,\n \t}\n \n out_unlock:\n-\tsem_unlock(sma);\n+\tsem_unlock(sma, -1);\n out_wakeup:\n \twake_up_sem_queue_do(&tasks);\n out_free:\n@@ -1211,11 +1290,11 @@ static int semctl_down(struct ipc_namespace *ns, int semid,\n \n \tswitch(cmd){\n \tcase IPC_RMID:\n-\t\tipc_lock_object(&sma->sem_perm);\n+\t\tsem_lock(sma, NULL, -1);\n \t\tfreeary(ns, ipcp);\n \t\tgoto out_up;\n \tcase IPC_SET:\n-\t\tipc_lock_object(&sma->sem_perm);\n+\t\tsem_lock(sma, NULL, -1);\n \t\terr = ipc_update_perm(&semid64.sem_perm, ipcp);\n \t\tif (err)\n \t\t\tgoto out_unlock;\n@@ -1228,7 +1307,7 @@ static int semctl_down(struct ipc_namespace *ns, int semid,\n \t}\n \n out_unlock:\n-\tsem_unlock(sma);\n+\tsem_unlock(sma, -1);\n out_up:\n \tup_write(&sem_ids(ns).rw_mutex);\n \treturn err;\n@@ -1340,8 +1419,7 @@ static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n \tstruct sem_array *sma;\n \tstruct sem_undo_list *ulp;\n \tstruct sem_undo *un, *new;\n-\tint nsems;\n-\tint error;\n+\tint nsems, error;\n \n \terror = get_undo_list(&ulp);\n \tif (error)\n@@ -1363,7 +1441,11 @@ static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n \t}\n \n \tnsems = sma->sem_nsems;\n-\tipc_rcu_getref(sma);\n+\tif (!ipc_rcu_getref(sma)) {\n+\t\trcu_read_unlock();\n+\t\tun = ERR_PTR(-EIDRM);\n+\t\tgoto out;\n+\t}\n \trcu_read_unlock();\n \n \t/* step 2: allocate new undo structure */\n@@ -1376,7 +1458,7 @@ static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n \t/* step 3: Acquire the lock on semaphore array */\n \tsem_lock_and_putref(sma);\n \tif (sma->sem_perm.deleted) {\n-\t\tsem_unlock(sma);\n+\t\tsem_unlock(sma, -1);\n \t\tkfree(new);\n \t\tun = ERR_PTR(-EIDRM);\n \t\tgoto out;\n@@ -1404,7 +1486,7 @@ static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n success:\n \tspin_unlock(&ulp->lock);\n \trcu_read_lock();\n-\tsem_unlock(sma);\n+\tsem_unlock(sma, -1);\n out:\n \treturn un;\n }\n@@ -1444,7 +1526,7 @@ SYSCALL_DEFINE4(semtimedop, int, semid, struct sembuf __user *, tsops,\n \tstruct sembuf fast_sops[SEMOPM_FAST];\n \tstruct sembuf* sops = fast_sops, *sop;\n \tstruct sem_undo *un;\n-\tint undos = 0, alter = 0, max;\n+\tint undos = 0, alter = 0, max, locknum;\n \tstruct sem_queue queue;\n \tunsigned long jiffies_left = 0;\n \tstruct ipc_namespace *ns;\n@@ -1488,22 +1570,23 @@ SYSCALL_DEFINE4(semtimedop, int, semid, struct sembuf __user *, tsops,\n \t\t\talter = 1;\n \t}\n \n+\tINIT_LIST_HEAD(&tasks);\n+\n \tif (undos) {\n+\t\t/* On success, find_alloc_undo takes the rcu_read_lock */\n \t\tun = find_alloc_undo(ns, semid);\n \t\tif (IS_ERR(un)) {\n \t\t\terror = PTR_ERR(un);\n \t\t\tgoto out_free;\n \t\t}\n-\t} else\n+\t} else {\n \t\tun = NULL;\n+\t\trcu_read_lock();\n+\t}\n \n-\tINIT_LIST_HEAD(&tasks);\n-\n-\trcu_read_lock();\n \tsma = sem_obtain_object_check(ns, semid);\n \tif (IS_ERR(sma)) {\n-\t\tif (un)\n-\t\t\trcu_read_unlock();\n+\t\trcu_read_unlock();\n \t\terror = PTR_ERR(sma);\n \t\tgoto out_free;\n \t}\n@@ -1534,23 +1617,9 @@ SYSCALL_DEFINE4(semtimedop, int, semid, struct sembuf __user *, tsops,\n \t * \"un\" itself is guaranteed by rcu.\n \t */\n \terror = -EIDRM;\n-\tipc_lock_object(&sma->sem_perm);\n-\tif (un) {\n-\t\tif (un->semid == -1) {\n-\t\t\trcu_read_unlock();\n-\t\t\tgoto out_unlock_free;\n-\t\t} else {\n-\t\t\t/*\n-\t\t\t * rcu lock can be released, \"un\" cannot disappear:\n-\t\t\t * - sem_lock is acquired, thus IPC_RMID is\n-\t\t\t *   impossible.\n-\t\t\t * - exit_sem is impossible, it always operates on\n-\t\t\t *   current (or a dead task).\n-\t\t\t */\n-\n-\t\t\trcu_read_unlock();\n-\t\t}\n-\t}\n+\tlocknum = sem_lock(sma, sops, nsops);\n+\tif (un && un->semid == -1)\n+\t\tgoto out_unlock_free;\n \n \terror = try_atomic_semop (sma, sops, nsops, un, task_tgid_vnr(current));\n \tif (error <= 0) {\n@@ -1591,7 +1660,7 @@ SYSCALL_DEFINE4(semtimedop, int, semid, struct sembuf __user *, tsops,\n \n sleep_again:\n \tcurrent->state = TASK_INTERRUPTIBLE;\n-\tsem_unlock(sma);\n+\tsem_unlock(sma, locknum);\n \n \tif (timeout)\n \t\tjiffies_left = schedule_timeout(jiffies_left);\n@@ -1613,7 +1682,7 @@ SYSCALL_DEFINE4(semtimedop, int, semid, struct sembuf __user *, tsops,\n \t\tgoto out_free;\n \t}\n \n-\tsma = sem_obtain_lock(ns, semid);\n+\tsma = sem_obtain_lock(ns, semid, sops, nsops, &locknum);\n \n \t/*\n \t * Wait until it's guaranteed that no wakeup_sem_queue_do() is ongoing.\n@@ -1652,7 +1721,7 @@ SYSCALL_DEFINE4(semtimedop, int, semid, struct sembuf __user *, tsops,\n \tunlink_queue(sma, &queue);\n \n out_unlock_free:\n-\tsem_unlock(sma);\n+\tsem_unlock(sma, locknum);\n out_wakeup:\n \twake_up_sem_queue_do(&tasks);\n out_free:\n@@ -1716,8 +1785,7 @@ void exit_sem(struct task_struct *tsk)\n \t\tstruct sem_array *sma;\n \t\tstruct sem_undo *un;\n \t\tstruct list_head tasks;\n-\t\tint semid;\n-\t\tint i;\n+\t\tint semid, i;\n \n \t\trcu_read_lock();\n \t\tun = list_entry_rcu(ulp->list_proc.next,\n@@ -1726,23 +1794,26 @@ void exit_sem(struct task_struct *tsk)\n \t\t\tsemid = -1;\n \t\t else\n \t\t\tsemid = un->semid;\n-\t\trcu_read_unlock();\n \n-\t\tif (semid == -1)\n+\t\tif (semid == -1) {\n+\t\t\trcu_read_unlock();\n \t\t\tbreak;\n+\t\t}\n \n-\t\tsma = sem_lock_check(tsk->nsproxy->ipc_ns, un->semid);\n-\n+\t\tsma = sem_obtain_object_check(tsk->nsproxy->ipc_ns, un->semid);\n \t\t/* exit_sem raced with IPC_RMID, nothing to do */\n-\t\tif (IS_ERR(sma))\n+\t\tif (IS_ERR(sma)) {\n+\t\t\trcu_read_unlock();\n \t\t\tcontinue;\n+\t\t}\n \n+\t\tsem_lock(sma, NULL, -1);\n \t\tun = __lookup_undo(ulp, semid);\n \t\tif (un == NULL) {\n \t\t\t/* exit_sem raced with IPC_RMID+semget() that created\n \t\t\t * exactly the same semid. Nothing to do.\n \t\t\t */\n-\t\t\tsem_unlock(sma);\n+\t\t\tsem_unlock(sma, -1);\n \t\t\tcontinue;\n \t\t}\n \n@@ -1782,7 +1853,7 @@ void exit_sem(struct task_struct *tsk)\n \t\t/* maybe some queued-up processes were waiting for this */\n \t\tINIT_LIST_HEAD(&tasks);\n \t\tdo_smart_update(sma, NULL, 0, 1, &tasks);\n-\t\tsem_unlock(sma);\n+\t\tsem_unlock(sma, -1);\n \t\twake_up_sem_queue_do(&tasks);\n \n \t\tkfree_rcu(un, rcu);"
        },
        {
          "filename": "ipc/util.c",
          "status": "modified",
          "additions": 25,
          "deletions": 23,
          "patch": "@@ -439,9 +439,9 @@ void ipc_rmid(struct ipc_ids *ids, struct kern_ipc_perm *ipcp)\n  *\tNULL is returned if the allocation fails\n  */\n  \n-void* ipc_alloc(int size)\n+void *ipc_alloc(int size)\n {\n-\tvoid* out;\n+\tvoid *out;\n \tif(size > PAGE_SIZE)\n \t\tout = vmalloc(size);\n \telse\n@@ -478,7 +478,7 @@ void ipc_free(void* ptr, int size)\n  */\n struct ipc_rcu_hdr\n {\n-\tint refcount;\n+\tatomic_t refcount;\n \tint is_vmalloc;\n \tvoid *data[0];\n };\n@@ -516,39 +516,41 @@ static inline int rcu_use_vmalloc(int size)\n  *\t@size: size desired\n  *\n  *\tAllocate memory for the rcu header structure +  the object.\n- *\tReturns the pointer to the object.\n- *\tNULL is returned if the allocation fails. \n+ *\tReturns the pointer to the object or NULL upon failure.\n  */\n- \n-void* ipc_rcu_alloc(int size)\n+void *ipc_rcu_alloc(int size)\n {\n-\tvoid* out;\n-\t/* \n+\tvoid *out;\n+\n+\t/*\n \t * We prepend the allocation with the rcu struct, and\n-\t * workqueue if necessary (for vmalloc). \n+\t * workqueue if necessary (for vmalloc).\n \t */\n \tif (rcu_use_vmalloc(size)) {\n \t\tout = vmalloc(HDRLEN_VMALLOC + size);\n-\t\tif (out) {\n-\t\t\tout += HDRLEN_VMALLOC;\n-\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;\n-\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n-\t\t}\n+\t\tif (!out)\n+\t\t\tgoto done;\n+\n+\t\tout += HDRLEN_VMALLOC;\n+\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;\n \t} else {\n \t\tout = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);\n-\t\tif (out) {\n-\t\t\tout += HDRLEN_KMALLOC;\n-\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;\n-\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n-\t\t}\n+\t\tif (!out)\n+\t\t\tgoto done;\n+\n+\t\tout += HDRLEN_KMALLOC;\n+\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;\n \t}\n \n+\t/* set reference counter no matter what kind of allocation was done */\n+\tatomic_set(&container_of(out, struct ipc_rcu_hdr, data)->refcount, 1);\n+done:\n \treturn out;\n }\n \n-void ipc_rcu_getref(void *ptr)\n+int ipc_rcu_getref(void *ptr)\n {\n-\tcontainer_of(ptr, struct ipc_rcu_hdr, data)->refcount++;\n+\treturn atomic_inc_not_zero(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount);\n }\n \n static void ipc_do_vfree(struct work_struct *work)\n@@ -578,7 +580,7 @@ static void ipc_schedule_free(struct rcu_head *head)\n \n void ipc_rcu_putref(void *ptr)\n {\n-\tif (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)\n+\tif (!atomic_dec_and_test(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount))\n \t\treturn;\n \n \tif (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {"
        },
        {
          "filename": "ipc/util.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -119,7 +119,7 @@ void ipc_free(void* ptr, int size);\n  * to 0 schedules the rcu destruction. Caller must guarantee locking.\n  */\n void* ipc_rcu_alloc(int size);\n-void ipc_rcu_getref(void *ptr);\n+int ipc_rcu_getref(void *ptr);\n void ipc_rcu_putref(void *ptr);\n \n struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "aa22f4da2a46b484a257d167c67a2adc1b7aaf68",
            "date": "2025-01-26T00:23:38Z",
            "author_login": "torvalds"
          },
          {
            "sha": "eda061cccd146fcbe71051bb4aa5a8672b71216e",
            "date": "2025-01-26T00:19:10Z",
            "author_login": "torvalds"
          },
          {
            "sha": "08de7f9d4d39fd9aa5e747a13acc891214fa2d5f",
            "date": "2025-01-26T00:12:07Z",
            "author_login": "torvalds"
          },
          {
            "sha": "647d69605c70368d54fc012fce8a43e8e5955b04",
            "date": "2025-01-26T00:03:40Z",
            "author_login": "torvalds"
          },
          {
            "sha": "184a0997fb77f4a9527fc867fcd16806776c27ce",
            "date": "2025-01-25T23:59:46Z",
            "author_login": "torvalds"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-189",
    "description": "The ipc_rcu_putref function in ipc/util.c in the Linux kernel before 3.10 does not properly manage a reference count, which allows local users to cause a denial of service (memory consumption or system crash) via a crafted application.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2013-11-04T15:55:05.537",
    "last_modified": "2024-11-21T01:55:39.570",
    "fix_date": "2013-05-01T02:15:44Z"
  },
  "references": [
    {
      "url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2014-02/msg00045.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2014-0285.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2015-0284.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2013/10/30/4",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1024854",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
      "source": "secalert@redhat.com",
      "tags": [
        "Exploit",
        "Patch"
      ]
    },
    {
      "url": "https://www.kernel.org/pub/linux/kernel/v3.x/patch-3.10.bz2",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2014-02/msg00045.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2014-0285.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2015-0284.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2013/10/30/4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1024854",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch"
      ]
    },
    {
      "url": "https://www.kernel.org/pub/linux/kernel/v3.x/patch-3.10.bz2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:20.037269",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "linux",
    "owner": "torvalds",
    "created_at": "2011-09-04T22:48:12Z",
    "updated_at": "2025-01-26T06:54:23Z",
    "pushed_at": "2025-01-26T01:00:03Z",
    "size": 5386838,
    "stars": 186472,
    "forks": 54875,
    "open_issues": 441,
    "watchers": 186472,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1331921668,
      "Assembly": 9611819,
      "Shell": 5108035,
      "Python": 2992085,
      "Makefile": 2706967,
      "Perl": 1253833,
      "Rust": 816450,
      "Roff": 202277,
      "C++": 173994,
      "SmPL": 165946,
      "Yacc": 127472,
      "Lex": 71397,
      "Awk": 69555,
      "Jinja": 30138,
      "UnrealScript": 16848,
      "Gherkin": 10902,
      "M4": 3329,
      "MATLAB": 2482,
      "Clojure": 2442,
      "sed": 2433,
      "XS": 1239,
      "RPC": 962
    },
    "commit_activity": {
      "total_commits_last_year": 48379,
      "avg_commits_per_week": 930.3653846153846,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T07:34:00.817711"
  }
}