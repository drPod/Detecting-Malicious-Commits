{
  "cve_id": "CVE-2013-6371",
  "github_data": {
    "repository": "json-c/json-c",
    "fix_commit": "64e36901a0614bf64a19bc3396469c66dcd0b015",
    "related_commits": [
      "64e36901a0614bf64a19bc3396469c66dcd0b015",
      "64e36901a0614bf64a19bc3396469c66dcd0b015"
    ],
    "patch_url": "https://github.com/json-c/json-c/commit/64e36901a0614bf64a19bc3396469c66dcd0b015.patch",
    "fix_commit_details": {
      "sha": "64e36901a0614bf64a19bc3396469c66dcd0b015",
      "commit_date": "2014-04-09T05:48:21Z",
      "author": {
        "login": "michaeljclark",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Patch to address the following issues:",
        "length": 151,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 704,
        "additions": 691,
        "deletions": 13
      },
      "files": [
        {
          "filename": "Makefile.am",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -23,7 +23,8 @@ libjson_cinclude_HEADERS = \\\n \tjson_tokener.h \\\n \tjson_util.h \\\n \tlinkhash.h \\\n-\tprintbuf.h\n+\tprintbuf.h \\\n+\trandom_seed.h\n \n #libjsonx_includedir = $(libdir)/json-c-@VERSION@\n #\n@@ -41,7 +42,8 @@ libjson_c_la_SOURCES = \\\n \tjson_tokener.c \\\n \tjson_util.c \\\n \tlinkhash.c \\\n-\tprintbuf.c\n+\tprintbuf.c \\\n+\trandom_seed.c\n \n \n distclean-local:"
        },
        {
          "filename": "Makefile.am.inc",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,2 +1,2 @@\n-AM_CFLAGS = -Wall -Werror -Wextra -Wwrite-strings -Wno-unused-parameter -std=gnu99 -D_GNU_SOURCE -D_REENTRANT\n+AM_CFLAGS = -Wall -Werror -Wno-error=deprecated-declarations -Wextra -Wwrite-strings -Wno-unused-parameter -std=gnu99 -D_GNU_SOURCE -D_REENTRANT\n "
        },
        {
          "filename": "config.h.in",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -1,5 +1,8 @@\n /* config.h.in.  Generated from configure.ac by autoheader.  */\n \n+/* Enable RDRANR Hardware RNG Hash Seed */\n+#undef ENABLE_RDRAND\n+\n /* Define if .gnu.warning accepts long strings. */\n #undef HAS_GNU_WARNING_LONG\n \n@@ -32,6 +35,9 @@\n /* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */\n #undef HAVE_DOPRNT\n \n+/* Define to 1 if you have the <endian.h> header file. */\n+#undef HAVE_ENDIAN_H\n+\n /* Define to 1 if you have the <fcntl.h> header file. */\n #undef HAVE_FCNTL_H\n "
        },
        {
          "filename": "configure.ac",
          "status": "modified",
          "additions": 15,
          "deletions": 1,
          "patch": "@@ -7,6 +7,20 @@ AM_INIT_AUTOMAKE\n \n AC_PROG_MAKE_SET\n \n+AC_ARG_ENABLE(rdrand,\n+ AS_HELP_STRING([--enable-rdrand],\n+   [Enable RDRAND Hardware RNG Hash Seed generation on supported x86/x64 platforms.]),\n+[if test x$enableval = xyes; then\n+  enable_rdrand=yes\n+  AC_DEFINE(ENABLE_RDRAND, 1, [Enable RDRANR Hardware RNG Hash Seed])\n+fi])\n+\n+if test \"x$enable_rdrand\" = \"xyes\"; then\n+  AC_MSG_RESULT([RDRAND Hardware RNG Hash Seed enabled on supported x86/x64 platforms])\n+else\n+  AC_MSG_RESULT([RDRAND Hardware RNG Hash Seed disabled. Use --enable-rdrand to enable])\n+fi\n+\n # Checks for programs.\n \n # Checks for libraries.\n@@ -16,7 +30,7 @@ AM_PROG_CC_C_O\n AC_CONFIG_HEADER(config.h)\n AC_CONFIG_HEADER(json_config.h)\n AC_HEADER_STDC\n-AC_CHECK_HEADERS(fcntl.h limits.h strings.h syslog.h unistd.h [sys/cdefs.h] [sys/param.h] stdarg.h locale.h)\n+AC_CHECK_HEADERS(fcntl.h limits.h strings.h syslog.h unistd.h [sys/cdefs.h] [sys/param.h] stdarg.h locale.h endian.h)\n AC_CHECK_HEADER(inttypes.h,[AC_DEFINE([JSON_C_HAVE_INTTYPES_H],[1],[Public define for json_inttypes.h])])\n \n # Checks for typedefs, structures, and compiler characteristics."
        },
        {
          "filename": "json_object.h",
          "status": "modified",
          "additions": 10,
          "deletions": 2,
          "patch": "@@ -13,6 +13,14 @@\n #ifndef _json_object_h_\n #define _json_object_h_\n \n+#ifdef __GNUC__\n+#define THIS_FUNCTION_IS_DEPRECATED(func) func __attribute__ ((deprecated))\n+#elif defined(_MSC_VER)\n+#define THIS_FUNCTION_IS_DEPRECATED(func) __declspec(deprecated) func\n+#else\n+#define THIS_FUNCTION_IS_DEPRECATED(func) func\n+#endif\n+\n #include \"json_inttypes.h\"\n \n #ifdef __cplusplus\n@@ -279,8 +287,8 @@ extern void json_object_object_add(struct json_object* obj, const char *key,\n  * @returns the json_object associated with the given field name\n  * @deprecated Please use json_object_object_get_ex\n  */\n-extern struct json_object* json_object_object_get(struct json_object* obj,\n-\t\t\t\t\t\t  const char *key);\n+THIS_FUNCTION_IS_DEPRECATED(extern struct json_object* json_object_object_get(struct json_object* obj,\n+\t\t\t\t\t\t  const char *key));\n \n /** Get the json_object associated with a given object field.  \n  *"
        },
        {
          "filename": "json_tokener.c",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -81,6 +81,7 @@ static const char* json_tokener_errors[] = {\n   \"object value separator ',' expected\",\n   \"invalid string sequence\",\n   \"expected comment\",\n+  \"buffer size overflow\"\n };\n \n const char *json_tokener_error_desc(enum json_tokener_error jerr)\n@@ -243,6 +244,16 @@ struct json_object* json_tokener_parse_ex(struct json_tokener *tok,\n   tok->char_offset = 0;\n   tok->err = json_tokener_success;\n \n+  /* this interface is presently not 64-bit clean due to the int len argument\n+     and the internal printbuf interface that takes 32-bit int len arguments\n+     so the function limits the maximum string size to INT32_MAX (2GB).\n+     If the function is called with len == -1 then strlen is called to check\n+     the string length is less than INT32_MAX (2GB) */\n+  if ((len < -1) || (len == -1 && strlen(str) > INT32_MAX)) {\n+    tok->err = json_tokener_error_size;\n+    return NULL;\n+  }\n+\n   while (PEEK_CHAR(c, tok)) {\n \n   redo_char:"
        },
        {
          "filename": "json_tokener.h",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -33,7 +33,8 @@ enum json_tokener_error {\n   json_tokener_error_parse_object_key_sep,\n   json_tokener_error_parse_object_value_sep,\n   json_tokener_error_parse_string,\n-  json_tokener_error_parse_comment\n+  json_tokener_error_parse_comment,\n+  json_tokener_error_size\n };\n \n enum json_tokener_state {\n@@ -163,6 +164,11 @@ extern void json_tokener_set_flags(struct json_tokener *tok, int flags);\n  * responsible for calling json_tokener_parse_ex with an appropriate str\n  * parameter starting with the extra characters.\n  *\n+ * This interface is presently not 64-bit clean due to the int len argument\n+ * so the function limits the maximum string size to INT32_MAX (2GB).\n+ * If the function is called with len == -1 then strlen is called to check\n+ * the string length is less than INT32_MAX (2GB)\n+ *\n  * Example:\n  * @code\n json_object *jobj = NULL;"
        },
        {
          "filename": "linkhash.c",
          "status": "modified",
          "additions": 374,
          "deletions": 5,
          "patch": "@@ -17,6 +17,11 @@\n #include <stddef.h>\n #include <limits.h>\n \n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+#include \"random_seed.h\"\n #include \"linkhash.h\"\n \n void lh_abort(const char *msg, ...)\n@@ -39,14 +44,378 @@ int lh_ptr_equal(const void *k1, const void *k2)\n \treturn (k1 == k2);\n }\n \n+/* \n+ * hashlittle from lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+ * http://burtleburtle.net/bob/c/lookup3.c\n+ * minor modifications to make functions static so no symbols are exported\n+ * minor mofifications to compile with -Werror\n+ */\n+\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \"a-=c; a^=rot(c,k); c+=b;\" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \"9 15 3 18 27 15\" didn't quite get 32 bits diffing\n+for \"differ\" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle( const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \"k[2]&0xffffff\" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    const uint8_t  *k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}\n+\n unsigned long lh_char_hash(const void *k)\n {\n-\tunsigned int h = 0;\n-\tconst char* data = (const char*)k;\n- \n-\twhile( *data!=0 ) h = h*129 + (unsigned int)(*data++) + LH_PRIME;\n+\tstatic volatile int random_seed = -1;\n+\n+\tif (random_seed == -1) {\n+\t\tint seed;\n+\t\t/* we can't use -1 as it is the unitialized sentinel */\n+\t\twhile ((seed = json_c_get_random_seed()) == -1);\n+#if defined __GNUC__\n+\t\t__sync_val_compare_and_swap(&random_seed, -1, seed);\n+#elif defined _MSC_VER\n+\t\tInterlockedCompareExchange(&random_seed, seed, -1);\n+#else\n+#warning \"racy random seed initializtion if used by multiple threads\"\n+\t\trandom_seed = seed; /* potentially racy */\n+#endif\n+\t}\n \n-\treturn h;\n+\treturn hashlittle((const char*)k, strlen((const char*)k), random_seed); \n }\n \n int lh_char_equal(const void *k1, const void *k2)"
        },
        {
          "filename": "linkhash.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -246,7 +246,7 @@ extern struct lh_entry* lh_table_lookup_entry(struct lh_table *t, const void *k)\n  * @return a pointer to the found value or NULL if it does not exist.\n  * @deprecated Use lh_table_lookup_ex instead.\n  */\n-extern const void* lh_table_lookup(struct lh_table *t, const void *k);\n+THIS_FUNCTION_IS_DEPRECATED(extern const void* lh_table_lookup(struct lh_table *t, const void *k));\n \n /**\n  * Lookup a record in the table"
        },
        {
          "filename": "random_seed.c",
          "status": "added",
          "additions": 237,
          "deletions": 0,
          "patch": "@@ -0,0 +1,237 @@\n+/*\n+ * random_seed.c\n+ *\n+ * Copyright (c) 2013 Metaparadigm Pte. Ltd.\n+ * Michael Clark <michael@metaparadigm.com>\n+ *\n+ * This library is free software; you can redistribute it and/or modify\n+ * it under the terms of the MIT license. See COPYING for details.\n+ *\n+ */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+\n+#define DEBUG_SEED(s)\n+\n+\n+#if defined ENABLE_RDRAND\n+\n+/* cpuid */\n+\n+#if defined __GNUC__ && (defined __i386__ || defined __x86_64__)\n+#define HAS_X86_CPUID 1\n+\n+static void do_cpuid(int regs[], int h)\n+{\n+    __asm__ __volatile__(\n+#if defined __x86_64__\n+                         \"pushq %%rbx;\\n\"\n+#else\n+                         \"pushl %%ebx;\\n\"\n+#endif\n+                         \"cpuid;\\n\"\n+#if defined __x86_64__\n+                         \"popq %%rbx;\\n\"\n+#else\n+                         \"popl %%ebx;\\n\"\n+#endif\n+                         : \"=a\"(regs[0]), [ebx] \"=r\"(regs[1]), \"=c\"(regs[2]), \"=d\"(regs[3])\n+                         : \"a\"(h));\n+}\n+\n+#elif defined _MSC_VER\n+\n+#define HAS_X86_CPUID 1\n+#define do_cpuid __cpuid\n+\n+#endif\n+\n+/* has_rdrand */\n+\n+#if HAS_X86_CPUID\n+\n+static int has_rdrand()\n+{\n+    // CPUID.01H:ECX.RDRAND[bit 30] == 1\n+    int regs[4];\n+    do_cpuid(regs, 1);\n+    return (regs[2] & (1 << 30)) != 0;\n+}\n+\n+#endif\n+\n+/* get_rdrand_seed - GCC x86 and X64 */\n+\n+#if defined __GNUC__ && (defined __i386__ || defined __x86_64__)\n+\n+#define HAVE_RDRAND 1\n+\n+static int get_rdrand_seed()\n+{\n+    DEBUG_SEED(\"get_rdrand_seed\");\n+    int _eax;\n+    // rdrand eax\n+    __asm__ __volatile__(\"1: .byte 0x0F\\n\"\n+                         \"   .byte 0xC7\\n\"\n+                         \"   .byte 0xF0\\n\"\n+                         \"   jnc 1b;\\n\"\n+                         : \"=a\" (_eax));\n+    return _eax;\n+}\n+\n+#endif\n+\n+#if defined _MSC_VER\n+\n+#if _MSC_VER >= 1700\n+#define HAVE_RDRAND 1\n+\n+/* get_rdrand_seed - Visual Studio 2012 and above */\n+\n+static int get_rdrand_seed()\n+{\n+    DEBUG_SEED(\"get_rdrand_seed\");\n+    int r;\n+    while (_rdrand32_step(&r) == 0);\n+    return r;\n+}\n+\n+#elif defined _M_IX86\n+#define HAVE_RDRAND 1\n+\n+/* get_rdrand_seed - Visual Studio 2010 and below - x86 only */\n+\n+static int get_rdrand_seed()\n+{\n+\tDEBUG_SEED(\"get_rdrand_seed\");\n+\tint _eax;\n+retry:\n+\t// rdrand eax\n+\t__asm _emit 0x0F __asm _emit 0xC7 __asm _emit 0xF0\n+\t__asm jnc retry\n+\t__asm mov _eax, eax\n+\treturn _eax;\n+}\n+\n+#endif\n+#endif\n+\n+#endif /* defined ENABLE_RDRAND */\n+\n+\n+/* has_dev_urandom */\n+\n+#if defined (__APPLE__) || defined(__unix__) || defined(__linux__)\n+\n+#include <string.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <sys/stat.h>\n+\n+#define HAVE_DEV_RANDOM 1\n+\n+static const char *dev_random_file = \"/dev/urandom\";\n+\n+static int has_dev_urandom()\n+{\n+    struct stat buf;\n+    if (stat(dev_random_file, &buf)) {\n+        return 0;\n+    }\n+    return ((buf.st_mode & S_IFCHR) != 0);\n+}\n+\n+\n+/* get_dev_random_seed */\n+\n+static int get_dev_random_seed()\n+{\n+    DEBUG_SEED(\"get_dev_random_seed\");\n+    \n+    int fd = open(dev_random_file, O_RDONLY);\n+    if (fd < 0) {\n+        fprintf(stderr, \"error opening %s: %s\", dev_random_file, strerror(errno));\n+        exit(1);\n+    }\n+    \n+    int r;\n+    ssize_t nread = read(fd, &r, sizeof(r));\n+    if (nread != sizeof(r)) {\n+        fprintf(stderr, \"error read %s: %s\", dev_random_file, strerror(errno));\n+        exit(1);\n+    }\n+    else if (nread != sizeof(r)) {\n+        fprintf(stderr, \"error short read %s\", dev_random_file);\n+        exit(1);\n+    }\n+    close(fd);\n+    return r;\n+}\n+\n+#endif\n+\n+\n+/* get_cryptgenrandom_seed */\n+\n+#ifdef WIN32\n+\n+#define HAVE_CRYPTGENRANDOM 1\n+\n+#include <windows.h>\n+#pragma comment(lib, \"advapi32.lib\")\n+\n+static int get_cryptgenrandom_seed()\n+{\n+    DEBUG_SEED(\"get_cryptgenrandom_seed\");\n+    \n+    HCRYPTPROV hProvider = 0;\n+    int r;\n+    \n+    if (!CryptAcquireContextW(&hProvider, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {\n+        fprintf(stderr, \"error CryptAcquireContextW\");\n+        exit(1);\n+    }\n+    \n+    if (!CryptGenRandom(hProvider, sizeof(r), (BYTE*)&r)) {\n+        fprintf(stderr, \"error CryptGenRandom\");\n+        exit(1);\n+    }\n+    \n+    CryptReleaseContext(hProvider, 0);\n+    \n+    return r;\n+}\n+\n+#endif\n+\n+\n+/* get_time_seed */\n+\n+#include <time.h>\n+\n+static int get_time_seed()\n+{\n+    DEBUG_SEED(\"get_time_seed\");\n+    \n+    return (int)time(NULL) * 433494437;\n+}\n+\n+\n+/* json_c_get_random_seed */\n+\n+int json_c_get_random_seed()\n+{\n+#if HAVE_RDRAND\n+    if (has_rdrand()) return get_rdrand_seed();\n+#endif\n+#if HAVE_DEV_RANDOM\n+    if (has_dev_urandom()) return get_dev_random_seed();\n+#endif\n+#if HAVE_CRYPTGENRANDOM\n+    return get_cryptgenrandom_seed();\n+#endif\n+    return get_time_seed();\n+}"
        },
        {
          "filename": "random_seed.h",
          "status": "added",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -0,0 +1,25 @@\n+/*\n+ * random_seed.h\n+ *\n+ * Copyright (c) 2013 Metaparadigm Pte. Ltd.\n+ * Michael Clark <michael@metaparadigm.com>\n+ *\n+ * This library is free software; you can redistribute it and/or modify\n+ * it under the terms of the MIT license. See COPYING for details.\n+ *\n+ */\n+\n+#ifndef seed_h\n+#define seed_h\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+extern int json_c_get_random_seed();\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7bca694b4721cb1dd6fbee234f2d7d4139c854c8",
            "date": "2025-01-09T05:12:09Z",
            "author_login": "hawicz"
          },
          {
            "sha": "51bcdd0000263d6e768911d1ac5f5733dbc344d9",
            "date": "2025-01-06T02:56:53Z",
            "author_login": "careles"
          },
          {
            "sha": "a3044648077b5e05b7e43ddfc55c407904f47827",
            "date": "2024-12-29T18:34:38Z",
            "author_login": "hawicz"
          },
          {
            "sha": "7b73916815e168e1d29f883f26d82b54646380b4",
            "date": "2024-12-29T18:26:11Z",
            "author_login": "hawicz"
          },
          {
            "sha": "ee83daa4093dfbc4bfd63468dcf2bd7c636d7a0e",
            "date": "2024-12-27T00:07:07Z",
            "author_login": "hawicz"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-310",
    "description": "The hash functionality in json-c before 0.12 allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted JSON data, involving collisions.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2014-04-22T13:06:26.710",
    "last_modified": "2024-11-21T01:59:05.647",
    "fix_date": "2014-04-09T05:48:21Z"
  },
  "references": [
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-April/131845.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://secunia.com/advisories/57791",
      "source": "secalert@redhat.com",
      "tags": [
        "Permissions Required",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.mandriva.com/security/advisories?name=MDVSA-2014:079",
      "source": "secalert@redhat.com",
      "tags": [
        "Broken Link"
      ]
    },
    {
      "url": "http://www.oracle.com/technetwork/topics/security/bulletinoct2015-2511968.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/66715",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1032311",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/92541",
      "source": "secalert@redhat.com",
      "tags": [
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/json-c/json-c/commit/64e36901a0614bf64a19bc3396469c66dcd0b015",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-April/131845.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://secunia.com/advisories/57791",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Permissions Required",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.mandriva.com/security/advisories?name=MDVSA-2014:079",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Broken Link"
      ]
    },
    {
      "url": "http://www.oracle.com/technetwork/topics/security/bulletinoct2015-2511968.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/66715",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1032311",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/92541",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/json-c/json-c/commit/64e36901a0614bf64a19bc3396469c66dcd0b015",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:22.588193",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "json-c",
    "owner": "json-c",
    "created_at": "2010-12-04T22:17:02Z",
    "updated_at": "2025-01-14T01:19:19Z",
    "pushed_at": "2025-01-09T05:12:09Z",
    "size": 4348,
    "stars": 3008,
    "forks": 1065,
    "open_issues": 17,
    "watchers": 3008,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "C": 414853,
      "CMake": 29764,
      "Shell": 16847,
      "C++": 4781,
      "Makefile": 1485
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T17:03:54.130815"
  }
}