{
  "cve_id": "CVE-2013-6401",
  "github_data": {
    "repository": "akheron/jansson",
    "fix_commit": "8f80c2d83808150724d31793e6ade92749b1faa4",
    "related_commits": [
      "8f80c2d83808150724d31793e6ade92749b1faa4",
      "8f80c2d83808150724d31793e6ade92749b1faa4"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "8f80c2d83808150724d31793e6ade92749b1faa4",
      "commit_date": "2014-01-14T09:16:39Z",
      "author": {
        "login": "akheron",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "CVE-2013-6401: Change hash function, randomize hashes",
        "length": 137,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 995,
        "additions": 873,
        "deletions": 122
      },
      "files": [
        {
          "filename": "CMakeLists.txt",
          "status": "modified",
          "additions": 39,
          "deletions": 10,
          "patch": "@@ -52,6 +52,8 @@ project (jansson C)\n \n # Options\n OPTION (BUILD_SHARED_LIBS \"Build shared libraries.\" OFF)\n+OPTION (USE_URANDOM \"Use /dev/urandom to seed the hash function.\" ON)\n+OPTION (USE_WINDOWS_CRYPTOAPI \"Use CryptGenRandom to seed the hash function.\" ON)\n \n if (MSVC)\n    # This option must match the settings used in your program, in particular if you\n@@ -85,12 +87,12 @@ set (JANSSON_SOVERSION 4)\n # for CheckFunctionKeywords\n set(CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/cmake\")\n \n+INCLUDE (CheckCSourceCompiles)\n include (CheckFunctionExists)\n include (CheckFunctionKeywords)\n include (CheckIncludeFiles)\n include (CheckTypeSize)\n \n-\n if (MSVC)\n    # Turn off Microsofts \"security\" warnings.\n    add_definitions( \"/W3 /D_CRT_SECURE_NO_WARNINGS /wd4005 /wd4996 /nologo\" )\n@@ -106,14 +108,25 @@ if (CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)\n    set(CMAKE_C_FLAGS \"-fPIC\")\n endif()\n \n-   \n+check_include_files (endian.h HAVE_ENDIAN_H)\n+check_include_files (fcntl.h HAVE_FCNTL_H)\n+check_include_files (sched.h HAVE_SCHED_H)\n+check_include_files (unistd.h HAVE_UNISTD_H)\n+check_include_files (sys/param.h HAVE_SYS_PARAM_H)\n+check_include_files (sys/stat.h HAVE_SYS_STAT_H)\n+check_include_files (sys/time.h HAVE_SYS_TIME_H)\n+check_include_files (sys/time.h HAVE_SYS_TYPES_H)\n+\n+check_function_exists (close HAVE_CLOSE)\n+check_function_exists (getpid HAVE_GETPID)\n+check_function_exists (gettimeofday HAVE_GETTIMEOFDAY)\n+check_function_exists (open HAVE_OPEN)\n+check_function_exists (read HAVE_READ)\n+check_function_exists (sched_yield HAVE_SCHED_YIELD)\n \n # Check for the int-type includes\n-check_include_files (sys/types.h HAVE_SYS_TYPES_H)\n-check_include_files (inttypes.h HAVE_INTTYPES_H)\n check_include_files (stdint.h HAVE_STDINT_H)\n \n-\n # Check our 64 bit integer sizes\n check_type_size (__int64 __INT64)\n check_type_size (int64_t INT64_T)\n@@ -124,17 +137,32 @@ check_type_size (int32_t INT32_T)\n check_type_size (__int32 __INT32)\n check_type_size (\"long\" LONG_INT)\n check_type_size (\"int\" INT)\n-\n if (HAVE_INT32_T)\n    set (JSON_INT32 int32_t)\n elseif (HAVE___INT32)\n    set (JSON_INT32 __int32)\n-elseif (HAVE_LONG AND (${LONG_INT} EQUAL 4))\n+elseif (HAVE_LONG_INT AND (${LONG_INT} EQUAL 4))\n    set (JSON_INT32 long)\n elseif (HAVE_INT AND (${INT} EQUAL 4))\n    set (JSON_INT32 int)\n else ()\n-   message (FATAL_ERROR \"Could not detect a valid 32 bit integer type\")\n+   message (FATAL_ERROR \"Could not detect a valid 32-bit integer type\")\n+endif ()\n+\n+check_type_size (uint32_t UINT32_T)\n+check_type_size (__uint32 __UINT32)\n+check_type_size (\"unsigned long\" UNSIGNED_LONG_INT)\n+check_type_size (\"unsigned int\" UNSIGNED_INT)\n+if (HAVE_UINT32_T)\n+   set (JSON_UINT32 uint32_t)\n+elseif (HAVE___UINT32)\n+   set (JSON_UINT32 __uint32)\n+elseif (HAVE_UNSIGNED_LONG_INT AND (${UNSIGNED_LONG_INT} EQUAL 4))\n+   set (JSON_UINT32 \"unsigned long\")\n+elseif (HAVE_UNSIGNED_INT AND (${UNSIGNED_INT} EQUAL 4))\n+   set (JSON_UINT32 \"unsigned int\")\n+else ()\n+   message (FATAL_ERROR \"Could not detect a valid unsigned 32-bit integer type\")\n endif ()\n \n # Check for ssize_t and SSIZE_T existance.\n@@ -206,11 +234,9 @@ else ()\n    set (JSON_HAVE_LOCALECONV 0)\n endif ()\n \n-\n # check if we have setlocale\n check_function_exists (setlocale HAVE_SETLOCALE)\n \n-\n # Check what the inline keyword is.\n # Note that the original JSON_INLINE was always set to just 'inline', so this goes further.\n check_function_keywords(\"inline\")\n@@ -238,6 +264,9 @@ elseif (HAVE__SNPRINTF)\n    set (JSON_SNPRINTF _snprintf)\n endif ()\n \n+check_c_source_compiles (\"int main() { unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1); return 0; } \" HAVE_SYNC_BUILTINS)\n+check_c_source_compiles (\"int main() { char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE); return 0; }\" HAVE_ATOMIC_BUILTINS)\n+\n # Create pkg-conf file.\n # (We use the same files as ./configure does, so we\n #  have to defined the same variables used there)."
        },
        {
          "filename": "cmake/config.h.cmake",
          "status": "modified",
          "additions": 25,
          "deletions": 21,
          "patch": "@@ -1,35 +1,36 @@\n-/* Reduced down to the defines that are actually used in the code */\n-\n-/* Define to 1 if you have the <inttypes.h> (and friends) header file. */\n-#cmakedefine HAVE_INTTYPES_H 1\n-#cmakedefine HAVE_STDINT_H 1\n+#cmakedefine HAVE_ENDIAN_H 1\n+#cmakedefine HAVE_FCNTL_H 1\n+#cmakedefine HAVE_SCHED_H 1\n+#cmakedefine HAVE_UNISTD_H 1\n+#cmakedefine HAVE_SYS_PARAM_H 1\n+#cmakedefine HAVE_SYS_STAT_H 1\n+#cmakedefine HAVE_SYS_TIME_H 1\n #cmakedefine HAVE_SYS_TYPES_H 1\n+#cmakedefine HAVE_STDINT_H 1\n \n-/* We must include this here, as in (eg) utf.h it will want to use\n-   the integer type, which in MSVC2010 will be in stdint.h\n-   (there is no inttypes.h in MSVC2010) */\n-#if defined(HAVE_STDINT_H)\n-#  include <stdint.h>\n-#elif defined(HAVE_INTTYPES_H)\n-#  include <inttypes.h>\n-#elif defined(HAVE_SYS_TYPES_H)\n-#  include <sys/types.h>\n-#endif\n+#cmakedefine HAVE_CLOSE 1\n+#cmakedefine HAVE_GETPID 1\n+#cmakedefine HAVE_GETTIMEOFDAY 1\n+#cmakedefine HAVE_OPEN 1\n+#cmakedefine HAVE_READ 1\n+#cmakedefine HAVE_SCHED_YIELD 1\n \n-/* Define to 1 if you have the <locale.h> header file. */\n-#cmakedefine HAVE_LOCALE_H 1\n+#cmakedefine HAVE_SYNC_BUILTINS 1\n+#cmakedefine HAVE_ATOMIC_BUILTINS 1\n \n-/* Define to 1 if you have the 'setlocale' function. */\n+#cmakedefine HAVE_LOCALE_H 1\n #cmakedefine HAVE_SETLOCALE 1\n \n-/* Define to the type of a signed integer type of width exactly 32 bits if\n-   such a type exists and the standard includes do not define it. */\n #cmakedefine HAVE_INT32_T 1\n-\n #ifndef HAVE_INT32_T\n #  define int32_t @JSON_INT32@\n #endif\n \n+#cmakedefine HAVE_UINT32_T 1\n+#ifndef HAVE_UINT32_T\n+#  define uint32_t @JSON_UINT32@\n+#endif\n+\n #cmakedefine HAVE_SSIZE_T 1\n \n #ifndef HAVE_SSIZE_T\n@@ -43,3 +44,6 @@\n #endif\n \n #cmakedefine HAVE_VSNPRINTF\n+\n+#cmakedefine USE_URANDOM 1\n+#cmakedefine USE_WINDOWS_CRYPTOAPI 1"
        },
        {
          "filename": "configure.ac",
          "status": "modified",
          "additions": 48,
          "deletions": 2,
          "patch": "@@ -14,10 +14,11 @@ AM_CONDITIONAL([GCC], [test x$GCC = xyes])\n # Checks for libraries.\n \n # Checks for header files.\n-AC_CHECK_HEADERS([locale.h])\n+AC_CHECK_HEADERS([endian.h fcntl.h locale.h sched.h unistd.h sys/param.h sys/stat.h sys/time.h sys/types.h])\n \n # Checks for typedefs, structures, and compiler characteristics.\n AC_TYPE_INT32_T\n+AC_TYPE_UINT32_T\n AC_TYPE_LONG_LONG_INT\n \n AC_C_INLINE\n@@ -29,7 +30,31 @@ esac\n AC_SUBST([json_inline])\n \n # Checks for library functions.\n-AC_CHECK_FUNCS([strtoll localeconv])\n+AC_CHECK_FUNCS([close getpid gettimeofday localeconv open read sched_yield strtoll])\n+\n+AC_MSG_CHECKING([for gcc __sync builtins])\n+have_sync_builtins=no\n+AC_TRY_LINK(\n+  [], [unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1);],\n+  [have_sync_builtins=yes],\n+)\n+if test \"x$have_sync_builtins\" = \"xyes\"; then\n+  AC_DEFINE([HAVE_SYNC_BUILTINS], [1],\n+    [Define to 1 if gcc's __sync builtins are available])\n+fi\n+AC_MSG_RESULT([$have_sync_builtins])\n+\n+AC_MSG_CHECKING([for gcc __atomic builtins])\n+have_atomic_builtins=no\n+AC_TRY_LINK(\n+  [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],\n+  [have_atomic_builtins=yes],\n+)\n+if test \"x$have_atomic_builtins\" = \"xyes\"; then\n+  AC_DEFINE([HAVE_ATOMIC_BUILTINS], [1],\n+    [Define to 1 if gcc's __atomic builtins are available])\n+fi\n+AC_MSG_RESULT([$have_atomic_builtins])\n \n case \"$ac_cv_type_long_long_int$ac_cv_func_strtoll\" in\n      yesyes) json_have_long_long=1;;\n@@ -43,6 +68,27 @@ case \"$ac_cv_header_locale_h$ac_cv_func_localeconv\" in\n esac\n AC_SUBST([json_have_localeconv])\n \n+# Features\n+AC_ARG_ENABLE([urandom],\n+  [AS_HELP_STRING([--disable-urandom],\n+    [Don't use /dev/urandom to seed the hash function])],\n+  [use_urandom=$enableval], [use_urandom=yes])\n+\n+if test \"x$use_urandom\" = xyes; then\n+AC_DEFINE([USE_URANDOM], [1],\n+  [Define to 1 if /dev/urandom should be used for seeding the hash function])\n+fi\n+\n+AC_ARG_ENABLE([windows-cryptoapi],\n+  [AS_HELP_STRING([--disable-windows-cryptoapi],\n+    [Don't use CryptGenRandom to seed the hash function])],\n+  [use_windows_cryptoapi=$enableval], [use_windows_cryptoapi=yes])\n+\n+if test \"x$use_windows_cryptoapi\" = xyes; then\n+AC_DEFINE([USE_WINDOWS_CRYPTOAPI], [1],\n+  [Define to 1 if CryptGenRandom should be used for seeding the hash function])\n+fi\n+\n AC_CONFIG_FILES([\n         jansson.pc\n         Makefile"
        },
        {
          "filename": "src/Makefile.am",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -8,6 +8,7 @@ libjansson_la_SOURCES = \\\n \terror.c \\\n \thashtable.c \\\n \thashtable.h \\\n+\thashtable_seed.c \\\n \tjansson_private.h \\\n \tload.c \\\n \tmemory.c \\"
        },
        {
          "filename": "src/hashtable.c",
          "status": "modified",
          "additions": 26,
          "deletions": 41,
          "patch": "@@ -5,8 +5,17 @@\n  * it under the terms of the MIT license. See LICENSE for details.\n  */\n \n+#if HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stdlib.h>\n #include <string.h>\n+\n+#if HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include <jansson_config.h>   /* for JSON_INLINE */\n #include \"jansson_private.h\"  /* for container_of() */\n #include \"hashtable.h\"\n@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;\n typedef struct hashtable_pair pair_t;\n typedef struct hashtable_bucket bucket_t;\n \n-#define list_to_pair(list_)  container_of(list_, pair_t, list)\n-\n-/* From http://www.cse.yorku.ca/~oz/hash.html */\n-static size_t hash_str(const void *ptr)\n-{\n-    const char *str = (const char *)ptr;\n-\n-    size_t hash = 5381;\n-    size_t c;\n+extern volatile uint32_t hashtable_seed;\n \n-    while((c = (size_t)*str))\n-    {\n-        hash = ((hash << 5) + hash) + c;\n-        str++;\n-    }\n+/* Implementation of the hash function */\n+#include \"lookup3.h\"\n \n-    return hash;\n-}\n+#define list_to_pair(list_)  container_of(list_, pair_t, list)\n+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))\n \n static JSON_INLINE void list_init(list_t *list)\n {\n@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,\n     }\n }\n \n-static const size_t primes[] = {\n-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,\n-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,\n-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,\n-    805306457, 1610612741\n-};\n-\n-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n-{\n-    return primes[hashtable->num_buckets];\n-}\n-\n-\n static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,\n                                    const char *key, size_t hash)\n {\n@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,\n     bucket_t *bucket;\n     size_t index;\n \n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)\n \n     jsonp_free(hashtable->buckets);\n \n-    hashtable->num_buckets++;\n-    new_size = num_buckets(hashtable);\n+    hashtable->order++;\n+    new_size = hashsize(hashtable->order);\n \n     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)\n     size_t i;\n \n     hashtable->size = 0;\n-    hashtable->num_buckets = 0;  /* index to primes[] */\n-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n+    hashtable->order = 3;\n+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n     list_init(&hashtable->list);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n-    if(hashtable->size >= num_buckets(hashtable))\n+    if(hashtable->size >= hashsize(hashtable->order))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n \n@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)\n@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)\n \n     hashtable_do_clear(hashtable);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)"
        },
        {
          "filename": "src/hashtable.h",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -32,14 +32,15 @@ struct hashtable_bucket {\n typedef struct hashtable {\n     size_t size;\n     struct hashtable_bucket *buckets;\n-    size_t num_buckets;  /* index to primes[] */\n+    size_t order;  /* hashtable has pow(2, order) buckets */\n     struct hashtable_list list;\n } hashtable_t;\n \n \n #define hashtable_key_to_iter(key_) \\\n     (&(container_of(key_, struct hashtable_pair, key)->list))\n \n+\n /**\n  * hashtable_init - Initialize a hashtable object\n  *"
        },
        {
          "filename": "src/hashtable_seed.c",
          "status": "added",
          "additions": 278,
          "deletions": 0,
          "patch": "@@ -0,0 +1,278 @@\n+/* Generate sizeof(uint32_t) bytes of as random data as possible to seed\n+   the hash function.\n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <time.h>\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_SCHED_H\n+#include <sched.h>\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+\n+#if defined(_WIN32)\n+/* For _getpid() */\n+#include <process.h>\n+#endif\n+\n+#include \"jansson.h\"\n+\n+\n+static uint32_t buf_to_uint32(char *data) {\n+    size_t i;\n+    uint32_t result = 0;\n+\n+    for (i = 0; i < sizeof(uint32_t); i++)\n+        result = (result << 8) | (unsigned char)data[i];\n+\n+    return result;\n+}\n+\n+\n+\n+/* /dev/urandom */\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+static int seed_from_urandom(uint32_t *seed) {\n+    /* Use unbuffered I/O if we have open(), close() and read(). Otherwise\n+       fall back to fopen() */\n+\n+    char data[sizeof(uint32_t)];\n+    int ok;\n+\n+#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n+    int urandom;\n+    urandom = open(\"/dev/urandom\", O_RDONLY);\n+    if (urandom == -1)\n+        return 1;\n+\n+    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n+    close(urandom);\n+#else\n+    FILE *urandom;\n+\n+    urandom = fopen(\"/dev/urandom\", \"rb\");\n+    if (!urandom)\n+        return 1;\n+\n+    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n+    fclose(urandom);\n+#endif\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32(data);\n+    return 0;\n+}\n+#endif\n+\n+/* Windows Crypto API */\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+#include <windows.h>\n+#include <wincrypt.h>\n+\n+typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTA)(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags);\n+typedef BOOL (WINAPI *CRYPTGENRANDOM)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);\n+typedef BOOL (WINAPI *CRYPTRELEASECONTEXT)(HCRYPTPROV hProv, DWORD dwFlags);\n+\n+static int seed_from_windows_cryptoapi(uint32_t *seed)\n+{\n+    HINSTANCE hAdvAPI32 = NULL;\n+    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n+    CRYPTGENRANDOM pCryptGenRandom = NULL;\n+    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n+    HCRYPTPROV hCryptProv = 0;\n+    BYTE data[sizeof(uint32_t)];\n+    int ok;\n+\n+    hAdvAPI32 = GetModuleHandle(\"advapi32.dll\");\n+    if(hAdvAPI32 == NULL)\n+        return 1;\n+\n+    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \"CryptAcquireContextA\");\n+    if (!pCryptAcquireContext)\n+        return 1;\n+\n+    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \"CryptGenRandom\");\n+    if (!pCryptGenRandom)\n+        return 1;\n+\n+    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \"CryptReleaseContext\");\n+    if (!pCryptReleaseContext)\n+        return 1;\n+\n+    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n+        return 1;\n+\n+    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n+    pCryptReleaseContext(hCryptProv, 0);\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32((char *)data);\n+    return 0;\n+}\n+#endif\n+\n+/* gettimeofday() and getpid() */\n+static int seed_from_timestamp_and_pid(uint32_t *seed) {\n+#ifdef HAVE_GETTIMEOFDAY\n+    /* XOR of seconds and microseconds */\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n+#else\n+    /* Seconds only */\n+    *seed = (uint32_t)time(NULL);\n+#endif\n+\n+    /* XOR with PID for more randomness */\n+#if defined(_WIN32)\n+    *seed ^= (uint32_t)_getpid();\n+#elif defined(HAVE_GETPID)\n+    *seed ^= (uint32_t)getpid();\n+#endif\n+\n+    return 0;\n+}\n+\n+static uint32_t generate_seed() {\n+    uint32_t seed;\n+    int done = 0;\n+\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+    if (!done && seed_from_urandom(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+    if (!done) {\n+        /* Fall back to timestamp and PID if no better randomness is\n+           available */\n+        seed_from_timestamp_and_pid(&seed);\n+    }\n+\n+    /* Make sure the seed is never zero */\n+    if (seed == 0)\n+        seed = 1;\n+\n+    return seed;\n+}\n+\n+\n+volatile uint32_t hashtable_seed = 0;\n+\n+#if defined(HAVE_ATOMIC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+static volatile char seed_initialized = 0;\n+\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n+        }\n+    }\n+}\n+#elif defined(HAVE_SYNC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0) {\n+            /* Explicit synchronization fences are not supported by the\n+               __sync builtins, so every thread getting here has to\n+               generate the seed value.\n+            */\n+            new_seed = generate_seed();\n+        }\n+\n+        do {\n+            if (__sync_bool_compare_and_swap(&hashtable_seed, 0, new_seed)) {\n+                /* We were the first to seed */\n+                break;\n+            } else {\n+                /* Wait for another thread to do the seeding */\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            }\n+        } while(hashtable_seed == 0);\n+    }\n+}\n+#elif defined(_WIN32)\n+static long seed_initialized = 0;\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (InterlockedIncrement(&seed_initialized) == 1) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            hashtable_seed = new_seed;\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+                SwitchToThread();\n+            } while (hashtable_seed == 0);\n+        }\n+    }\n+}\n+#else\n+/* Fall back to a thread-unsafe version */\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0)\n+            new_seed = generate_seed();\n+\n+        hashtable_seed = new_seed;\n+    }\n+}\n+#endif"
        },
        {
          "filename": "src/jansson.def",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -41,6 +41,7 @@ EXPORTS\n     json_object_iter_value\n     json_object_iter_set_new\n     json_object_key_to_iter\n+    json_object_seed\n     json_dumps\n     json_dumpf\n     json_dump_file"
        },
        {
          "filename": "src/jansson.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -126,6 +126,7 @@ typedef struct {\n \n /* getters, setters, manipulation */\n \n+void json_object_seed(size_t seed);\n size_t json_object_size(const json_t *object);\n json_t *json_object_get(const json_t *object, const char *key);\n int json_object_set_new(json_t *object, const char *key, json_t *value);"
        },
        {
          "filename": "src/lookup3.h",
          "status": "added",
          "additions": 366,
          "deletions": 0,
          "patch": "@@ -0,0 +1,366 @@\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+#include <stdlib.h>\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>     /* defines uint32_t etc */\n+#endif\n+\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>  /* attempt to define endianness */\n+#endif\n+\n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \"a-=c; a^=rot(c,k); c+=b;\" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \"9 15 3 18 27 15\" didn't quite get 32 bits diffing\n+for \"differ\" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle(const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+#ifdef VALGRIND\n+    const uint8_t  *k8;\n+#endif\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \"k[2]&0xffffff\" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}"
        },
        {
          "filename": "src/utf.h",
          "status": "modified",
          "additions": 4,
          "deletions": 16,
          "patch": "@@ -10,23 +10,11 @@\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n+#endif\n \n-#ifdef HAVE_INTTYPES_H\n-/* inttypes.h includes stdint.h in a standard environment, so there's\n-no need to include stdint.h separately. If inttypes.h doesn't define\n-int32_t, it's defined in config.h. */\n-#include <inttypes.h>\n-#endif /* HAVE_INTTYPES_H */\n-\n-#else /* !HAVE_CONFIG_H */\n-#ifdef _WIN32\n-typedef int int32_t;\n-#else /* !_WIN32 */\n-/* Assume a standard environment */\n-#include <inttypes.h>\n-#endif /* _WIN32 */\n-\n-#endif /* HAVE_CONFIG_H */\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n \n int utf8_encode(int codepoint, char *buffer, int *size);\n "
        },
        {
          "filename": "src/value.c",
          "status": "modified",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -9,11 +9,19 @@\n #define _GNU_SOURCE\n #endif\n \n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stddef.h>\n #include <stdlib.h>\n #include <string.h>\n #include <math.h>\n \n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include \"jansson.h\"\n #include \"hashtable.h\"\n #include \"jansson_private.h\"\n@@ -36,11 +44,19 @@ static JSON_INLINE void json_init(json_t *json, json_type type)\n \n /*** object ***/\n \n+extern volatile uint32_t hashtable_seed;\n+\n json_t *json_object(void)\n {\n     json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n     if(!object)\n         return NULL;\n+\n+    if (!hashtable_seed) {\n+        /* Autoseed */\n+        json_object_seed(0);\n+    }\n+\n     json_init(&object->json, JSON_OBJECT);\n \n     if(hashtable_init(&object->hashtable))"
        },
        {
          "filename": "test/bin/json_process.c",
          "status": "modified",
          "additions": 15,
          "deletions": 1,
          "patch": "@@ -37,6 +37,8 @@ struct config {\n     int sort_keys;\n     int strip;\n     int use_env;\n+    int have_hashseed;\n+    int hashseed;\n } conf;\n \n #define l_isspace(c) ((c) == ' ' || (c) == '\\n' || (c) == '\\r' || (c) == '\\t')\n@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)\n             conf.sort_keys = atoi(val);\n         if (!strcmp(line, \"STRIP\"))\n             conf.strip = atoi(val);\n+        if (!strcmp(line, \"HASHSEED\")) {\n+            conf.have_hashseed = 1;\n+            conf.hashseed = atoi(val);\n+        } else {\n+            conf.have_hashseed = 0;\n+        }\n     }\n \n     free(buffer);\n@@ -188,6 +196,9 @@ int use_conf(char *test_path)\n     if (conf.sort_keys)\n         flags |= JSON_SORT_KEYS;\n \n+    if (conf.have_hashseed)\n+        json_object_seed(conf.hashseed);\n+\n     if (conf.strip) {\n         /* Load to memory, strip leading and trailing whitespace */\n         buffer = loadfile(infile);\n@@ -265,7 +276,10 @@ int use_env()\n         flags |= JSON_PRESERVE_ORDER;\n \n     if(getenv_int(\"JSON_SORT_KEYS\"))\n-         flags |= JSON_SORT_KEYS;\n+        flags |= JSON_SORT_KEYS;\n+\n+    if(getenv(\"HASHSEED\"))\n+        json_object_seed(getenv_int(\"HASHSEED\"));\n \n     if(getenv_int(\"STRIP\")) {\n         /* Load to memory, strip leading and trailing whitespace */"
        },
        {
          "filename": "test/suites/api/test_memory_funcs.c",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -24,13 +24,13 @@ static void create_and_free_complex_object()\n \n static void *my_malloc(size_t size)\n {\n-    malloc_called += 1;\n+    malloc_called = 1;\n     return malloc(size);\n }\n \n static void my_free(void *ptr)\n {\n-    free_called += 1;\n+    free_called = 1;\n     free(ptr);\n }\n \n@@ -39,7 +39,7 @@ static void test_simple()\n     json_set_alloc_funcs(my_malloc, my_free);\n     create_and_free_complex_object();\n \n-    if(malloc_called != 20 || free_called != 20)\n+    if(malloc_called != 1 || free_called != 1)\n         fail(\"Custom allocation failed\");\n }\n "
        },
        {
          "filename": "test/suites/api/test_object.c",
          "status": "modified",
          "additions": 40,
          "deletions": 24,
          "patch": "@@ -249,7 +249,11 @@ static void test_set_nocheck()\n \n static void test_iterators()\n {\n+    int i;\n     json_t *object, *foo, *bar, *baz;\n+    const char *iter_keys[3];\n+    int have_key[3] = { 0, 0, 0 };\n+    json_t *iter_values[3];\n     void *iter;\n \n     if(json_object_iter(NULL))\n@@ -276,30 +280,50 @@ static void test_iterators()\n     iter = json_object_iter(object);\n     if(!iter)\n         fail(\"unable to get iterator\");\n-    if(strcmp(json_object_iter_key(iter), \"a\"))\n-        fail(\"iterating failed: wrong key\");\n-    if(json_object_iter_value(iter) != foo)\n-        fail(\"iterating failed: wrong value\");\n+    iter_keys[0] = json_object_iter_key(iter);\n+    iter_values[0] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\"unable to increment iterator\");\n-    if(strcmp(json_object_iter_key(iter), \"b\"))\n-        fail(\"iterating failed: wrong key\");\n-    if(json_object_iter_value(iter) != bar)\n-        fail(\"iterating failed: wrong value\");\n+    iter_keys[1] = json_object_iter_key(iter);\n+    iter_values[1] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\"unable to increment iterator\");\n-    if(strcmp(json_object_iter_key(iter), \"c\"))\n-        fail(\"iterating failed: wrong key\");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\"iterating failed: wrong value\");\n+    iter_keys[2] = json_object_iter_key(iter);\n+    iter_values[2] = json_object_iter_value(iter);\n \n     if(json_object_iter_next(object, iter) != NULL)\n         fail(\"able to iterate over the end\");\n \n+    /* Check that keys have correct values */\n+    for (i = 0; i < 3; i++) {\n+        if (strcmp(iter_keys[i], \"a\") == 0) {\n+            if (iter_values[i] != foo)\n+                fail(\"wrong value for iter key a\");\n+            else\n+                have_key[0] = 1;\n+        } else if (strcmp(iter_keys[i], \"b\") == 0) {\n+            if (iter_values[i] != bar)\n+                fail(\"wrong value for iter key b\");\n+            else\n+                have_key[1] = 1;\n+        } else if (strcmp(iter_keys[i], \"c\") == 0) {\n+            if (iter_values[i] != baz)\n+                fail(\"wrong value for iter key c\");\n+            else\n+                have_key[2] = 1;\n+        }\n+    }\n+\n+    /* Check that we got all keys */\n+    for(i = 0; i < 3; i++) {\n+        if(!have_key[i])\n+            fail(\"a key wasn't iterated over\");\n+    }\n+\n     if(json_object_iter_at(object, \"foo\"))\n         fail(\"json_object_iter_at() succeeds for non-existent key\");\n \n@@ -312,22 +336,14 @@ static void test_iterators()\n     if(json_object_iter_value(iter) != bar)\n         fail(\"iterating failed: wrong value\");\n \n-    iter = json_object_iter_next(object, iter);\n-    if(!iter)\n-        fail(\"unable to increment iterator\");\n-    if(strcmp(json_object_iter_key(iter), \"c\"))\n-        fail(\"iterating failed: wrong key\");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\"iterating failed: wrong value\");\n-\n-    if(json_object_iter_set(object, iter, bar))\n+    if(json_object_iter_set(object, iter, baz))\n         fail(\"unable to set value at iterator\");\n \n-    if(strcmp(json_object_iter_key(iter), \"c\"))\n+    if(strcmp(json_object_iter_key(iter), \"b\"))\n         fail(\"json_object_iter_key() fails after json_object_iter_set()\");\n-    if(json_object_iter_value(iter) != bar)\n+    if(json_object_iter_value(iter) != baz)\n         fail(\"json_object_iter_value() fails after json_object_iter_set()\");\n-    if(json_object_get(object, \"c\") != bar)\n+    if(json_object_get(object, \"b\") != baz)\n         fail(\"json_object_get() fails after json_object_iter_set()\");\n \n     json_decref(object);"
        },
        {
          "filename": "test/suites/encoding-flags/compact-object/env",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,2 +1,3 @@\n JSON_COMPACT=1\n-export JSON_COMPACT\n+HASHSEED=1\n+export JSON_COMPACT HASHSEED"
        },
        {
          "filename": "test/suites/encoding-flags/indent-compact-object/env",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,3 +1,4 @@\n JSON_INDENT=4\n JSON_COMPACT=1\n-export JSON_INDENT JSON_COMPACT\n+HASHSEED=1\n+export JSON_INDENT JSON_COMPACT HASHSEED"
        },
        {
          "filename": "test/suites/encoding-flags/indent-object/env",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,2 +1,3 @@\n JSON_INDENT=4\n-export JSON_INDENT\n+HASHSEED=1\n+export JSON_INDENT HASHSEED"
        },
        {
          "filename": "test/suites/encoding-flags/object/env",
          "status": "added",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -0,0 +1,2 @@\n+HASHSEED=1\n+export HASHSEED"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 7,
        "unique_directories": 9,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "61fc3d0e28e1a35410af42e329cd977095ec32d2",
            "date": "2024-03-31T19:09:15Z",
            "author_login": "akheron"
          },
          {
            "sha": "cce8caba26b6749e4912621c2860aea589256591",
            "date": "2024-03-31T19:08:10Z",
            "author_login": "akheron"
          },
          {
            "sha": "50953fb1faccced4d80c02c17b076d5b06910f84",
            "date": "2024-03-31T19:02:09Z",
            "author_login": "akheron"
          },
          {
            "sha": "c780171cf3a923e0cfbf4cda9b065570a1762015",
            "date": "2024-03-25T18:19:41Z",
            "author_login": "akheron"
          },
          {
            "sha": "2297a2e320ebecc6dc98f7034a2f38509ad1d7f5",
            "date": "2024-03-25T18:19:23Z",
            "author_login": "akheron"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-310",
    "description": "Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2014-03-21T01:04:00.623",
    "last_modified": "2024-11-21T01:59:09.293",
    "fix_date": "2014-01-14T09:16:39Z"
  },
  "references": [
    {
      "url": "http://comments.gmane.org/gmane.comp.security.oss.general/12099",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2014-03/msg00057.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1035538",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://comments.gmane.org/gmane.comp.security.oss.general/12099",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2014-03/msg00057.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1035538",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:22.574549",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "jansson",
    "owner": "akheron",
    "created_at": "2009-04-23T06:35:33Z",
    "updated_at": "2025-01-22T19:06:23Z",
    "pushed_at": "2024-08-20T20:40:34Z",
    "size": 1831,
    "stars": 3125,
    "forks": 823,
    "open_issues": 125,
    "watchers": 3125,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 486522,
      "CMake": 47748,
      "Shell": 12130,
      "M4": 6146,
      "Makefile": 6089,
      "C++": 5740
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T08:11:33.414951"
  }
}