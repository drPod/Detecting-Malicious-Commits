{
  "cve_id": "CVE-2013-7271",
  "github_data": {
    "repository": "torvalds/linux",
    "fix_commit": "f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
    "related_commits": [
      "f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
      "f3d3342602f8bcbf37d7c46641cb9bca7618eb1c"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
      "commit_date": "2013-11-21T02:14:22Z",
      "author": {
        "login": "strssndktn",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "net: rework recvmsg handler msg_name and msg_namelen logic",
        "length": 1624,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 182,
        "additions": 67,
        "deletions": 115
      },
      "files": [
        {
          "filename": "crypto/algif_hash.c",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -161,8 +161,6 @@ static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n \telse if (len < ds)\n \t\tmsg->msg_flags |= MSG_TRUNC;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \tif (ctx->more) {\n \t\tctx->more = 0;"
        },
        {
          "filename": "crypto/algif_skcipher.c",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -432,7 +432,6 @@ static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n \tlong copied = 0;\n \n \tlock_sock(sk);\n-\tmsg->msg_namelen = 0;\n \tfor (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;\n \t     iovlen--, iov++) {\n \t\tunsigned long seglen = iov->iov_len;"
        },
        {
          "filename": "drivers/isdn/mISDN/socket.c",
          "status": "modified",
          "additions": 4,
          "deletions": 9,
          "patch": "@@ -117,7 +117,6 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n {\n \tstruct sk_buff\t\t*skb;\n \tstruct sock\t\t*sk = sock->sk;\n-\tstruct sockaddr_mISDN\t*maddr;\n \n \tint\t\tcopied, err;\n \n@@ -135,9 +134,9 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn err;\n \n-\tif (msg->msg_namelen >= sizeof(struct sockaddr_mISDN)) {\n-\t\tmsg->msg_namelen = sizeof(struct sockaddr_mISDN);\n-\t\tmaddr = (struct sockaddr_mISDN *)msg->msg_name;\n+\tif (msg->msg_name) {\n+\t\tstruct sockaddr_mISDN *maddr = msg->msg_name;\n+\n \t\tmaddr->family = AF_ISDN;\n \t\tmaddr->dev = _pms(sk)->dev->id;\n \t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n@@ -150,11 +149,7 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\t\tmaddr->sapi = _pms(sk)->ch.addr & 0xFF;\n \t\t\tmaddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;\n \t\t}\n-\t} else {\n-\t\tif (msg->msg_namelen)\n-\t\t\tprintk(KERN_WARNING \"%s: too small namelen %d\\n\",\n-\t\t\t       __func__, msg->msg_namelen);\n-\t\tmsg->msg_namelen = 0;\n+\t\tmsg->msg_namelen = sizeof(*maddr);\n \t}\n \n \tcopied = skb->len + MISDN_HEADER_LEN;"
        },
        {
          "filename": "drivers/net/ppp/pppoe.c",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -979,8 +979,6 @@ static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (error < 0)\n \t\tgoto end;\n \n-\tm->msg_namelen = 0;\n-\n \tif (skb) {\n \t\ttotal_len = min_t(size_t, total_len, skb->len);\n \t\terror = skb_copy_datagram_iovec(skb, 0, m->msg_iov, total_len);"
        },
        {
          "filename": "include/linux/net.h",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -164,6 +164,14 @@ struct proto_ops {\n #endif\n \tint\t\t(*sendmsg)   (struct kiocb *iocb, struct socket *sock,\n \t\t\t\t      struct msghdr *m, size_t total_len);\n+\t/* Notes for implementing recvmsg:\n+\t * ===============================\n+\t * msg->msg_namelen should get updated by the recvmsg handlers\n+\t * iff msg_name != NULL. It is by default 0 to prevent\n+\t * returning uninitialized memory to user space.  The recvfrom\n+\t * handlers can assume that msg.msg_name is either NULL or has\n+\t * a minimum size of sizeof(struct sockaddr_storage).\n+\t */\n \tint\t\t(*recvmsg)   (struct kiocb *iocb, struct socket *sock,\n \t\t\t\t      struct msghdr *m, size_t total_len,\n \t\t\t\t      int flags);"
        },
        {
          "filename": "net/appletalk/ddp.c",
          "status": "modified",
          "additions": 7,
          "deletions": 9,
          "patch": "@@ -1735,7 +1735,6 @@ static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr\n \t\t\t size_t size, int flags)\n {\n \tstruct sock *sk = sock->sk;\n-\tstruct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;\n \tstruct ddpehdr *ddp;\n \tint copied = 0;\n \tint offset = 0;\n@@ -1764,14 +1763,13 @@ static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr\n \t}\n \terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n \n-\tif (!err) {\n-\t\tif (sat) {\n-\t\t\tsat->sat_family      = AF_APPLETALK;\n-\t\t\tsat->sat_port        = ddp->deh_sport;\n-\t\t\tsat->sat_addr.s_node = ddp->deh_snode;\n-\t\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n-\t\t}\n-\t\tmsg->msg_namelen = sizeof(*sat);\n+\tif (!err && msg->msg_name) {\n+\t\tstruct sockaddr_at *sat = msg->msg_name;\n+\t\tsat->sat_family      = AF_APPLETALK;\n+\t\tsat->sat_port        = ddp->deh_sport;\n+\t\tsat->sat_addr.s_node = ddp->deh_snode;\n+\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n+\t\tmsg->msg_namelen     = sizeof(*sat);\n \t}\n \n \tskb_free_datagram(sk, skb);\t/* Free the datagram. */"
        },
        {
          "filename": "net/atm/common.c",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -531,8 +531,6 @@ int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \tstruct sk_buff *skb;\n \tint copied, error = -EINVAL;\n \n-\tmsg->msg_namelen = 0;\n-\n \tif (sock->state != SS_CONNECTED)\n \t\treturn -ENOTCONN;\n "
        },
        {
          "filename": "net/ax25/af_ax25.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -1636,11 +1636,11 @@ static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n \n-\tif (msg->msg_namelen != 0) {\n-\t\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n+\tif (msg->msg_name) {\n \t\tax25_digi digi;\n \t\tax25_address src;\n \t\tconst unsigned char *mac = skb_mac_header(skb);\n+\t\tstruct sockaddr_ax25 *sax = msg->msg_name;\n \n \t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n \t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,"
        },
        {
          "filename": "net/bluetooth/af_bluetooth.c",
          "status": "modified",
          "additions": 2,
          "deletions": 7,
          "patch": "@@ -224,10 +224,9 @@ int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb) {\n-\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n-\t\t\tmsg->msg_namelen = 0;\n+\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n \t\t\treturn 0;\n-\t\t}\n+\n \t\treturn err;\n \t}\n \n@@ -245,8 +244,6 @@ int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tif (bt_sk(sk)->skb_msg_name)\n \t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n \t\t\t\t\t\t&msg->msg_namelen);\n-\t\telse\n-\t\t\tmsg->msg_namelen = 0;\n \t}\n \n \tskb_free_datagram(sk, skb);\n@@ -295,8 +292,6 @@ int bt_sock_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags & MSG_OOB)\n \t\treturn -EOPNOTSUPP;\n \n-\tmsg->msg_namelen = 0;\n-\n \tBT_DBG(\"sk %p size %zu\", sk, size);\n \n \tlock_sock(sk);"
        },
        {
          "filename": "net/bluetooth/hci_sock.c",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -856,8 +856,6 @@ static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn err;\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;"
        },
        {
          "filename": "net/bluetooth/rfcomm/sock.c",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -615,7 +615,6 @@ static int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n \t\trfcomm_dlc_accept(d);\n-\t\tmsg->msg_namelen = 0;\n \t\treturn 0;\n \t}\n "
        },
        {
          "filename": "net/bluetooth/sco.c",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -711,7 +711,6 @@ static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n \t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n \t\tsk->sk_state = BT_CONFIG;\n-\t\tmsg->msg_namelen = 0;\n \n \t\trelease_sock(sk);\n \t\treturn 0;"
        },
        {
          "filename": "net/caif/caif_socket.c",
          "status": "modified",
          "additions": 0,
          "deletions": 4,
          "patch": "@@ -286,8 +286,6 @@ static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (m->msg_flags&MSG_OOB)\n \t\tgoto read_error;\n \n-\tm->msg_namelen = 0;\n-\n \tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n \tif (!skb)\n \t\tgoto read_error;\n@@ -361,8 +359,6 @@ static int caif_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n-\n \t/*\n \t * Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg"
        },
        {
          "filename": "net/compat.c",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -93,7 +93,8 @@ int verify_compat_iovec(struct msghdr *kern_msg, struct iovec *kern_iov,\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n \t\t}\n-\t\tkern_msg->msg_name = kern_address;\n+\t\tif (kern_msg->msg_name)\n+\t\t\tkern_msg->msg_name = kern_address;\n \t} else\n \t\tkern_msg->msg_name = NULL;\n "
        },
        {
          "filename": "net/core/iovec.c",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -48,7 +48,8 @@ int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *a\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n \t\t}\n-\t\tm->msg_name = address;\n+\t\tif (m->msg_name)\n+\t\t\tm->msg_name = address;\n \t} else {\n \t\tm->msg_name = NULL;\n \t}"
        },
        {
          "filename": "net/ipx/af_ipx.c",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -1823,15 +1823,14 @@ static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (skb->tstamp.tv64)\n \t\tsk->sk_stamp = skb->tstamp;\n \n-\tmsg->msg_namelen = sizeof(*sipx);\n-\n \tif (sipx) {\n \t\tsipx->sipx_family\t= AF_IPX;\n \t\tsipx->sipx_port\t\t= ipx->ipx_source.sock;\n \t\tmemcpy(sipx->sipx_node, ipx->ipx_source.node, IPX_NODE_LEN);\n \t\tsipx->sipx_network\t= IPX_SKB_CB(skb)->ipx_source_net;\n \t\tsipx->sipx_type \t= ipx->ipx_type;\n \t\tsipx->sipx_zero\t\t= 0;\n+\t\tmsg->msg_namelen\t= sizeof(*sipx);\n \t}\n \trc = copied;\n "
        },
        {
          "filename": "net/irda/af_irda.c",
          "status": "modified",
          "additions": 0,
          "deletions": 4,
          "patch": "@@ -1385,8 +1385,6 @@ static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,\n \n \tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n \n-\tmsg->msg_namelen = 0;\n-\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\n \tif (!skb)\n@@ -1451,8 +1449,6 @@ static int irda_recvmsg_stream(struct kiocb *iocb, struct socket *sock,\n \ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, size);\n \ttimeo = sock_rcvtimeo(sk, noblock);\n \n-\tmsg->msg_namelen = 0;\n-\n \tdo {\n \t\tint chunk;\n \t\tstruct sk_buff *skb = skb_dequeue(&sk->sk_receive_queue);"
        },
        {
          "filename": "net/iucv/af_iucv.c",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -1324,8 +1324,6 @@ static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tint err = 0;\n \tu32 offset;\n \n-\tmsg->msg_namelen = 0;\n-\n \tif ((sk->sk_state == IUCV_DISCONN) &&\n \t    skb_queue_empty(&iucv->backlog_skb_q) &&\n \t    skb_queue_empty(&sk->sk_receive_queue) &&"
        },
        {
          "filename": "net/key/af_key.c",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -3616,7 +3616,6 @@ static int pfkey_recvmsg(struct kiocb *kiocb,\n \tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n \tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n \tif (skb == NULL)\n \t\tgoto out;"
        },
        {
          "filename": "net/l2tp/l2tp_ppp.c",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -197,8 +197,6 @@ static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (sk->sk_state & PPPOX_BOUND)\n \t\tgoto end;\n \n-\tmsg->msg_namelen = 0;\n-\n \terr = 0;\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);"
        },
        {
          "filename": "net/llc/af_llc.c",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -720,8 +720,6 @@ static int llc_ui_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tint target;\t/* Read at least this many bytes */\n \tlong timeo;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \tcopied = -ENOTCONN;\n \tif (unlikely(sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN))"
        },
        {
          "filename": "net/netlink/af_netlink.c",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -2335,8 +2335,6 @@ static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,\n \t}\n #endif\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = data_skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;"
        },
        {
          "filename": "net/netrom/af_netrom.c",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -1179,10 +1179,9 @@ static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tsax->sax25_family = AF_NETROM;\n \t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n \t\t\t      AX25_ADDR_LEN);\n+\t\tmsg->msg_namelen = sizeof(*sax);\n \t}\n \n-\tmsg->msg_namelen = sizeof(*sax);\n-\n \tskb_free_datagram(sk, skb);\n \n \trelease_sock(sk);"
        },
        {
          "filename": "net/nfc/llcp_sock.c",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -807,8 +807,6 @@ static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tpr_debug(\"%p %zu\\n\", sk, len);\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \n \tif (sk->sk_state == LLCP_CLOSED &&"
        },
        {
          "filename": "net/nfc/rawsock.c",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -244,8 +244,6 @@ static int rawsock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn rc;\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;"
        },
        {
          "filename": "net/packet/af_packet.c",
          "status": "modified",
          "additions": 15,
          "deletions": 17,
          "patch": "@@ -2660,7 +2660,6 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tstruct sock *sk = sock->sk;\n \tstruct sk_buff *skb;\n \tint copied, err;\n-\tstruct sockaddr_ll *sll;\n \tint vnet_hdr_len = 0;\n \n \terr = -EINVAL;\n@@ -2744,22 +2743,10 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\t\tgoto out_free;\n \t}\n \n-\t/*\n-\t *\tIf the address length field is there to be filled in, we fill\n-\t *\tit in now.\n-\t */\n-\n-\tsll = &PACKET_SKB_CB(skb)->sa.ll;\n-\tif (sock->type == SOCK_PACKET)\n-\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n-\telse\n-\t\tmsg->msg_namelen = sll->sll_halen + offsetof(struct sockaddr_ll, sll_addr);\n-\n-\t/*\n-\t *\tYou lose any data beyond the buffer you gave. If it worries a\n-\t *\tuser program they can ask the device for its MTU anyway.\n+\t/* You lose any data beyond the buffer you gave. If it worries\n+\t * a user program they can ask the device for its MTU\n+\t * anyway.\n \t */\n-\n \tcopied = skb->len;\n \tif (copied > len) {\n \t\tcopied = len;\n@@ -2772,9 +2759,20 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tsock_recv_ts_and_drops(msg, sk, skb);\n \n-\tif (msg->msg_name)\n+\tif (msg->msg_name) {\n+\t\t/* If the address length field is there to be filled\n+\t\t * in, we fill it in now.\n+\t\t */\n+\t\tif (sock->type == SOCK_PACKET) {\n+\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n+\t\t} else {\n+\t\t\tstruct sockaddr_ll *sll = &PACKET_SKB_CB(skb)->sa.ll;\n+\t\t\tmsg->msg_namelen = sll->sll_halen +\n+\t\t\t\toffsetof(struct sockaddr_ll, sll_addr);\n+\t\t}\n \t\tmemcpy(msg->msg_name, &PACKET_SKB_CB(skb)->sa,\n \t\t       msg->msg_namelen);\n+\t}\n \n \tif (pkt_sk(sk)->auxdata) {\n \t\tstruct tpacket_auxdata aux;"
        },
        {
          "filename": "net/rds/recv.c",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -410,8 +410,6 @@ int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \n \trdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\n \n-\tmsg->msg_namelen = 0;\n-\n \tif (msg_flags & MSG_OOB)\n \t\tgoto out;\n "
        },
        {
          "filename": "net/rose/af_rose.c",
          "status": "modified",
          "additions": 5,
          "deletions": 3,
          "patch": "@@ -1216,7 +1216,6 @@ static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n {\n \tstruct sock *sk = sock->sk;\n \tstruct rose_sock *rose = rose_sk(sk);\n-\tstruct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;\n \tsize_t copied;\n \tunsigned char *asmptr;\n \tstruct sk_buff *skb;\n@@ -1252,8 +1251,11 @@ static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n \n-\tif (srose != NULL) {\n-\t\tmemset(srose, 0, msg->msg_namelen);\n+\tif (msg->msg_name) {\n+\t\tstruct sockaddr_rose *srose;\n+\n+\t\tmemset(msg->msg_name, 0, sizeof(struct full_sockaddr_rose));\n+\t\tsrose = msg->msg_name;\n \t\tsrose->srose_family = AF_ROSE;\n \t\tsrose->srose_addr   = rose->dest_addr;\n \t\tsrose->srose_call   = rose->dest_call;"
        },
        {
          "filename": "net/rxrpc/ar-recvmsg.c",
          "status": "modified",
          "additions": 6,
          "deletions": 3,
          "patch": "@@ -143,10 +143,13 @@ int rxrpc_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \t\t/* copy the peer address and timestamp */\n \t\tif (!continue_call) {\n-\t\t\tif (msg->msg_name && msg->msg_namelen > 0)\n+\t\t\tif (msg->msg_name) {\n+\t\t\t\tsize_t len =\n+\t\t\t\t\tsizeof(call->conn->trans->peer->srx);\n \t\t\t\tmemcpy(msg->msg_name,\n-\t\t\t\t       &call->conn->trans->peer->srx,\n-\t\t\t\t       sizeof(call->conn->trans->peer->srx));\n+\t\t\t\t       &call->conn->trans->peer->srx, len);\n+\t\t\t\tmsg->msg_namelen = len;\n+\t\t\t}\n \t\t\tsock_recv_ts_and_drops(msg, &rx->sk, skb);\n \t\t}\n "
        },
        {
          "filename": "net/socket.c",
          "status": "modified",
          "additions": 11,
          "deletions": 8,
          "patch": "@@ -1840,8 +1840,10 @@ SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n \tmsg.msg_iov = &iov;\n \tiov.iov_len = size;\n \tiov.iov_base = ubuf;\n-\tmsg.msg_name = (struct sockaddr *)&address;\n-\tmsg.msg_namelen = sizeof(address);\n+\t/* Save some cycles and don't copy the address if not needed */\n+\tmsg.msg_name = addr ? (struct sockaddr *)&address : NULL;\n+\t/* We assume all kernel code knows the size of sockaddr_storage */\n+\tmsg.msg_namelen = 0;\n \tif (sock->file->f_flags & O_NONBLOCK)\n \t\tflags |= MSG_DONTWAIT;\n \terr = sock_recvmsg(sock, &msg, size, flags);\n@@ -2221,16 +2223,14 @@ static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,\n \t\t\tgoto out;\n \t}\n \n-\t/*\n-\t *      Save the user-mode address (verify_iovec will change the\n-\t *      kernel msghdr to use the kernel address space)\n+\t/* Save the user-mode address (verify_iovec will change the\n+\t * kernel msghdr to use the kernel address space)\n \t */\n-\n \tuaddr = (__force void __user *)msg_sys->msg_name;\n \tuaddr_len = COMPAT_NAMELEN(msg);\n-\tif (MSG_CMSG_COMPAT & flags) {\n+\tif (MSG_CMSG_COMPAT & flags)\n \t\terr = verify_compat_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n-\t} else\n+\telse\n \t\terr = verify_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n \tif (err < 0)\n \t\tgoto out_freeiov;\n@@ -2239,6 +2239,9 @@ static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,\n \tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n \tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n \n+\t/* We assume all kernel code knows the size of sockaddr_storage */\n+\tmsg_sys->msg_namelen = 0;\n+\n \tif (sock->file->f_flags & O_NONBLOCK)\n \t\tflags |= MSG_DONTWAIT;\n \terr = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,"
        },
        {
          "filename": "net/tipc/socket.c",
          "status": "modified",
          "additions": 0,
          "deletions": 6,
          "patch": "@@ -980,9 +980,6 @@ static int recv_msg(struct kiocb *iocb, struct socket *sock,\n \t\tgoto exit;\n \t}\n \n-\t/* will be updated in set_orig_addr() if needed */\n-\tm->msg_namelen = 0;\n-\n \ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n restart:\n \n@@ -1091,9 +1088,6 @@ static int recv_stream(struct kiocb *iocb, struct socket *sock,\n \t\tgoto exit;\n \t}\n \n-\t/* will be updated in set_orig_addr() if needed */\n-\tm->msg_namelen = 0;\n-\n \ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, buf_len);\n \ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n "
        },
        {
          "filename": "net/unix/af_unix.c",
          "status": "modified",
          "additions": 0,
          "deletions": 5,
          "patch": "@@ -1754,7 +1754,6 @@ static void unix_copy_addr(struct msghdr *msg, struct sock *sk)\n {\n \tstruct unix_sock *u = unix_sk(sk);\n \n-\tmsg->msg_namelen = 0;\n \tif (u->addr) {\n \t\tmsg->msg_namelen = u->addr->len;\n \t\tmemcpy(msg->msg_name, u->addr->name, u->addr->len);\n@@ -1778,8 +1777,6 @@ static int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n-\n \terr = mutex_lock_interruptible(&u->readlock);\n \tif (err) {\n \t\terr = sock_intr_errno(sock_rcvtimeo(sk, noblock));\n@@ -1924,8 +1921,6 @@ static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \ttarget = sock_rcvlowat(sk, flags&MSG_WAITALL, size);\n \ttimeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);\n \n-\tmsg->msg_namelen = 0;\n-\n \t/* Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg\n \t */"
        },
        {
          "filename": "net/vmw_vsock/af_vsock.c",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -1662,8 +1662,6 @@ vsock_stream_recvmsg(struct kiocb *kiocb,\n \tvsk = vsock_sk(sk);\n \terr = 0;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \n \tif (sk->sk_state != SS_CONNECTED) {"
        },
        {
          "filename": "net/vmw_vsock/vmci_transport.c",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -1746,8 +1746,6 @@ static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,\n \tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n \t\treturn -EOPNOTSUPP;\n \n-\tmsg->msg_namelen = 0;\n-\n \t/* Retrieve the head sk_buff from the socket's receive queue. */\n \terr = 0;\n \tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);"
        },
        {
          "filename": "net/x25/af_x25.c",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -1340,10 +1340,9 @@ static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (sx25) {\n \t\tsx25->sx25_family = AF_X25;\n \t\tsx25->sx25_addr   = x25->dest_addr;\n+\t\tmsg->msg_namelen = sizeof(*sx25);\n \t}\n \n-\tmsg->msg_namelen = sizeof(struct sockaddr_x25);\n-\n \tx25_check_rbuf(sk);\n \trc = copied;\n out_free_dgram:"
        }
      ],
      "file_patterns": {
        "security_files": 3,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 29,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "aa22f4da2a46b484a257d167c67a2adc1b7aaf68",
            "date": "2025-01-26T00:23:38Z",
            "author_login": "torvalds"
          },
          {
            "sha": "eda061cccd146fcbe71051bb4aa5a8672b71216e",
            "date": "2025-01-26T00:19:10Z",
            "author_login": "torvalds"
          },
          {
            "sha": "08de7f9d4d39fd9aa5e747a13acc891214fa2d5f",
            "date": "2025-01-26T00:12:07Z",
            "author_login": "torvalds"
          },
          {
            "sha": "647d69605c70368d54fc012fce8a43e8e5955b04",
            "date": "2025-01-26T00:03:40Z",
            "author_login": "torvalds"
          },
          {
            "sha": "184a0997fb77f4a9527fc867fcd16806776c27ce",
            "date": "2025-01-25T23:59:46Z",
            "author_login": "torvalds"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-20",
    "description": "The x25_recvmsg function in net/x25/af_x25.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2014-01-06T16:55:09.397",
    "last_modified": "2024-11-21T02:00:37.297",
    "fix_date": "2013-11-21T02:14:22Z"
  },
  "references": [
    {
      "url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://secunia.com/advisories/55882",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://secunia.com/advisories/56036",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.12.4",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2013/12/31/7",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/64746",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2109-1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2110-1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2113-1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2117-1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2128-1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2129-1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2135-1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2136-1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2138-1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2139-1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2141-1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1039845",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/90132",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://secunia.com/advisories/55882",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://secunia.com/advisories/56036",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.12.4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2013/12/31/7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/64746",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2109-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2110-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2113-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2117-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2128-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2129-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2135-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2136-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2138-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2139-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2141-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1039845",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/90132",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:20.060458",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "linux",
    "owner": "torvalds",
    "created_at": "2011-09-04T22:48:12Z",
    "updated_at": "2025-01-14T12:39:03Z",
    "pushed_at": "2025-01-13T17:27:04Z",
    "size": 5361369,
    "stars": 185823,
    "forks": 54743,
    "open_issues": 437,
    "watchers": 185823,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1326937103,
      "Assembly": 9568292,
      "Shell": 5072004,
      "Python": 2974128,
      "Makefile": 2713905,
      "Perl": 1253637,
      "Rust": 807711,
      "Roff": 202277,
      "C++": 173382,
      "SmPL": 165946,
      "Yacc": 127472,
      "Lex": 71321,
      "Awk": 69539,
      "Jinja": 30138,
      "UnrealScript": 16848,
      "Gherkin": 10172,
      "M4": 3329,
      "MATLAB": 2482,
      "sed": 2433,
      "Clojure": 2411,
      "XS": 1239,
      "RPC": 962
    },
    "commit_activity": {
      "total_commits_last_year": 46007,
      "avg_commits_per_week": 884.75,
      "days_active_last_year": 359
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T12:53:59.486675"
  }
}