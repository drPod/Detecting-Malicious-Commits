{
  "cve_id": "CVE-2013-7441",
  "github_data": {
    "repository": "yoe/nbd",
    "fix_commit": "741495cb08503fd32a9d22648e63b64390c601f4",
    "related_commits": [
      "741495cb08503fd32a9d22648e63b64390c601f4",
      "741495cb08503fd32a9d22648e63b64390c601f4"
    ],
    "patch_url": "https://github.com/yoe/nbd/commit/741495cb08503fd32a9d22648e63b64390c601f4.patch",
    "fix_commit_details": {
      "sha": "741495cb08503fd32a9d22648e63b64390c601f4",
      "commit_date": "2013-06-05T17:42:31Z",
      "author": {
        "login": "tuomasjjrasanen",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "nbd-server: handle modern-style negotiation in a child process",
        "length": 681,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 169,
        "additions": 157,
        "deletions": 12
      },
      "files": [
        {
          "filename": "nbd-server.c",
          "status": "modified",
          "additions": 157,
          "deletions": 12,
          "patch": "@@ -2198,6 +2198,161 @@ void destroy_pid_t(gpointer data) {\n \tg_free(data);\n }\n \n+static pid_t\n+spawn_child()\n+{\n+        pid_t pid;\n+        sigset_t newset;\n+        sigset_t oldset;\n+\n+        sigemptyset(&newset);\n+        sigaddset(&newset, SIGCHLD);\n+        sigaddset(&newset, SIGTERM);\n+        sigprocmask(SIG_BLOCK, &newset, &oldset);\n+        pid = fork();\n+        if (pid < 0) {\n+                msg(LOG_ERR, \"Could not fork (%s)\", strerror(errno));\n+                goto out;\n+        }\n+        if (pid > 0) { /* Parent */\n+                pid_t *pidp;\n+\n+                pidp = g_malloc(sizeof(pid_t));\n+                *pidp = pid;\n+                g_hash_table_insert(children, pidp, pidp);\n+                goto out;\n+        }\n+        /* Child */\n+        signal(SIGCHLD, SIG_DFL);\n+        signal(SIGTERM, SIG_DFL);\n+        signal(SIGHUP, SIG_DFL);\n+out:\n+        sigprocmask(SIG_SETMASK, &oldset, NULL);\n+        return pid;\n+}\n+\n+static int\n+socket_accept(const int sock)\n+{\n+        struct sockaddr_storage addrin;\n+        socklen_t addrinlen = sizeof(addrin);\n+        int net;\n+\n+        net = accept(sock, (struct sockaddr *) &addrin, &addrinlen);\n+        if (net < 0) {\n+                err_nonfatal(\"Failed to accept socket connection: %m\");\n+        }\n+\n+        return net;\n+}\n+\n+static void\n+handle_modern_connection(GArray *const servers, const int sock)\n+{\n+        int net;\n+        pid_t pid;\n+        CLIENT *client = NULL;\n+        int sock_flags_old;\n+        int sock_flags_new;\n+\n+        net = socket_accept(sock);\n+        if (net < 0)\n+                return;\n+\n+        if (!dontfork) {\n+                pid = spawn_child();\n+                if (pid) {\n+                        if (pid > 0)\n+                                msg(LOG_INFO, \"Spawned a child process\");\n+                        if (pid < 0)\n+                                msg(LOG_ERR, \"Failed to spawn a child process\");\n+                        close(net);\n+                        return;\n+                }\n+                /* Child just continues. */\n+        }\n+\n+        client = negotiate(net, NULL, servers, NEG_INIT | NEG_MODERN);\n+        if (!client) {\n+                msg(LOG_ERR, \"Modern initial negotiation failed\");\n+                goto handler_err;\n+        }\n+\n+        if (client->server->max_connections > 0 &&\n+           g_hash_table_size(children) >= client->server->max_connections) {\n+                msg(LOG_ERR, \"Max connections (%d) reached\",\n+                    client->server->max_connections);\n+                goto handler_err;\n+        }\n+\n+        sock_flags_old = fcntl(net, F_GETFL, 0);\n+        if (sock_flags_old == -1) {\n+                msg(LOG_ERR, \"Failed to get socket flags\");\n+                goto handler_err;\n+        }\n+\n+        sock_flags_new = sock_flags_old & ~O_NONBLOCK;\n+        if (sock_flags_new != sock_flags_old &&\n+            fcntl(net, F_SETFL, sock_flags_new) == -1) {\n+                msg(LOG_ERR, \"Failed to set socket to blocking mode\");\n+                goto handler_err;\n+        }\n+\n+        if (set_peername(net, client)) {\n+                msg(LOG_ERR, \"Failed to set peername\");\n+                goto handler_err;\n+        }\n+\n+        if (!authorized_client(client)) {\n+                msg(LOG_INFO, \"Client '%s' is not authorized to access\",\n+                    client->clientname);\n+                goto handler_err;\n+        }\n+\n+        if (!dontfork) {\n+                int i;\n+\n+                /* Free all root server resources here, because we are\n+                 * currently in the child process serving one specific\n+                 * connection. These are not simply needed anymore. */\n+                g_hash_table_destroy(children);\n+                children = NULL;\n+                for (i = 0; i < modernsocks->len; i++) {\n+                        close(g_array_index(modernsocks, int, i));\n+                }\n+                g_array_free(modernsocks, TRUE);\n+\n+                /* Now that we are in the child process after a\n+                 * succesful negotiation, we do not need the list of\n+                 * servers anymore, get rid of it.*/\n+\n+                for (i = 0; i < servers->len; i++) {\n+                        const SERVER *const server = &g_array_index(servers, SERVER, i);\n+                        close(server->socket);\n+                }\n+\n+                /* FALSE does not free the\n+                   actual data. This is required,\n+                   because the client has a\n+                   direct reference into that\n+                   data, and otherwise we get a\n+                   segfault... */\n+                g_array_free(servers, FALSE);\n+        }\n+\n+        msg(LOG_INFO, \"Starting to serve\");\n+        serveconnection(client);\n+        exit(EXIT_SUCCESS);\n+\n+handler_err:\n+        g_free(client);\n+        close(net);\n+\n+        if (!dontfork) {\n+                exit(EXIT_FAILURE);\n+        }\n+}\n+\n static void\n handle_connection(GArray *servers, int net, SERVER *serve, CLIENT *client)\n {\n@@ -2425,28 +2580,18 @@ void serveloop(GArray* servers) {\n \n \t\tmemcpy(&rset, &mset, sizeof(fd_set));\n \t\tif(select(max+1, &rset, NULL, NULL, NULL)>0) {\n-\t\t\tint net;\n \n \t\t\tDEBUG(\"accept, \");\n \t\t\tfor(i=0; i < modernsocks->len; i++) {\n \t\t\t\tint sock = g_array_index(modernsocks, int, i);\n \t\t\t\tif(!FD_ISSET(sock, &rset)) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n-\t\t\t\tCLIENT *client;\n \n-\t\t\t\tif((net=accept(sock, (struct sockaddr *) &addrin, &addrinlen)) < 0) {\n-\t\t\t\t\terr_nonfatal(\"accept: %m\");\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tclient = negotiate(net, NULL, servers, NEG_INIT | NEG_MODERN);\n-\t\t\t\tif(!client) {\n-\t\t\t\t\tclose(net);\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\thandle_connection(servers, net, client->server, client);\n+\t\t\t\thandle_modern_connection(servers, sock);\n \t\t\t}\n \t\t\tfor(i=0; i < servers->len; i++) {\n+\t\t\t\tint net;\n \t\t\t\tSERVER *serve;\n \n \t\t\t\tserve=&(g_array_index(servers, SERVER, i));"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "87c5318abfa2049b37505d498414c2c1fef6f23a",
            "date": "2024-11-19T22:56:00Z",
            "author_login": "ebblake"
          },
          {
            "sha": "a78ea37b389dd20a91970eee181d906b1c46f68f",
            "date": "2024-11-19T23:12:49Z",
            "author_login": "ebblake"
          },
          {
            "sha": "cf5a77437c8df03074755d2e819e3cc47aa6495c",
            "date": "2024-09-29T02:33:12Z",
            "author_login": "liulinC"
          },
          {
            "sha": "7a64238499823456bb83cdbfe6811f5db468b35b",
            "date": "2024-10-01T10:21:25Z",
            "author_login": "kalofoli"
          },
          {
            "sha": "17043b068f4323078637314258158aebbfff0a6c",
            "date": "2024-09-28T11:24:44Z",
            "author_login": "yoe"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-399",
    "description": "The modern style negotiation in Network Block Device (nbd-server) 2.9.22 through 3.3 allows remote attackers to cause a denial of service (root process termination) by (1) closing the connection during negotiation or (2) specifying a name for a non-existent export.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2015-05-29T15:59:00.077",
    "last_modified": "2024-11-21T02:01:00.290",
    "fix_date": "2013-06-05T17:42:31Z"
  },
  "references": [
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2015-06/msg00003.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://sourceforge.net/p/nbd/mailman/message/30410146/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2015/dsa-3271",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/05/19/6",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/05/21/5",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/74808",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2676-1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=781547",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/yoe/nbd/commit/741495cb08503fd32a9d22648e63b64390c601f4",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2015-06/msg00003.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://sourceforge.net/p/nbd/mailman/message/30410146/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2015/dsa-3271",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/05/19/6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/05/21/5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/74808",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2676-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=781547",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/yoe/nbd/commit/741495cb08503fd32a9d22648e63b64390c601f4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:35.778471",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "nbd",
    "owner": "yoe",
    "created_at": "2008-12-22T10:17:20Z",
    "updated_at": "2025-01-03T21:42:14Z",
    "pushed_at": "2024-12-21T18:56:08Z",
    "size": 5493,
    "stars": 462,
    "forks": 122,
    "open_issues": 20,
    "watchers": 462,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 290878,
      "M4": 11393,
      "Shell": 10362,
      "Makefile": 5058,
      "Yacc": 538,
      "Lex": 302,
      "Emacs Lisp": 68
    },
    "commit_activity": {
      "total_commits_last_year": 35,
      "avg_commits_per_week": 0.6730769230769231,
      "days_active_last_year": 22
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T12:59:29.730971"
  }
}