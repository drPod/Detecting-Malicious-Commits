{
  "cve_id": "CVE-2013-7449",
  "github_data": {
    "repository": "hexchat/hexchat",
    "fix_commit": "c9b63f7f9be01692b03fa15275135a4910a7e02d",
    "related_commits": [
      "c9b63f7f9be01692b03fa15275135a4910a7e02d",
      "c9b63f7f9be01692b03fa15275135a4910a7e02d"
    ],
    "patch_url": "https://github.com/hexchat/hexchat/commit/c9b63f7f9be01692b03fa15275135a4910a7e02d.patch",
    "fix_commit_details": {
      "sha": "c9b63f7f9be01692b03fa15275135a4910a7e02d",
      "commit_date": "2014-11-20T02:43:01Z",
      "author": {
        "login": "TingPing",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "ssl: Validate hostnames",
        "length": 36,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 221,
        "additions": 219,
        "deletions": 2
      },
      "files": [
        {
          "filename": "src/common/server.c",
          "status": "modified",
          "additions": 15,
          "deletions": 1,
          "patch": "@@ -723,9 +723,22 @@ ssl_do_connect (server * serv)\n \t\tswitch (verify_error)\n \t\t{\n \t\tcase X509_V_OK:\n+\t\t\t{\n+\t\t\t\tX509 *cert = SSL_get_peer_certificate (serv->ssl);\n+\t\t\t\tint hostname_err;\n+\t\t\t\tif ((hostname_err = _SSL_check_hostname(cert, serv->hostname)) != 0)\n+\t\t\t\t{\n+\t\t\t\t\tsnprintf (buf, sizeof (buf), \"* Verify E: Failed to validate hostname? (%d)%s\",\n+\t\t\t\t\t\t\t hostname_err, serv->accept_invalid_cert ? \" -- Ignored\" : \"\");\n+\t\t\t\t\tif (serv->accept_invalid_cert)\n+\t\t\t\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0);\n+\t\t\t\t\telse\n+\t\t\t\t\t\tgoto conn_fail;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t\t/* snprintf (buf, sizeof (buf), \"* Verify OK (?)\"); */\n \t\t\t/* EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0); */\n-\t\t\tbreak;\n \t\tcase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\n \t\tcase X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:\n \t\tcase X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\n@@ -744,6 +757,7 @@ ssl_do_connect (server * serv)\n \t\t\tsnprintf (buf, sizeof (buf), \"%s.? (%d)\",\n \t\t\t\t\t\t X509_verify_cert_error_string (verify_error),\n \t\t\t\t\t\t verify_error);\n+conn_fail:\n \t\t\tEMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL, NULL,\n \t\t\t\t\t\t\t NULL, 0);\n "
        },
        {
          "filename": "src/common/ssl.c",
          "status": "modified",
          "additions": 203,
          "deletions": 0,
          "patch": "@@ -25,6 +25,7 @@\n #include \"inet.h\"\t\t\t\t  /* make it first to avoid macro redefinitions */\n #include <openssl/ssl.h>\t\t  /* SSL_() */\n #include <openssl/err.h>\t\t  /* ERR_() */\n+#include <openssl/x509v3.h>\n #ifdef WIN32\n #include <openssl/rand.h>\t\t  /* RAND_seed() */\n #endif\n@@ -35,6 +36,7 @@\n \n #include <glib.h>\n #include <glib/gprintf.h>\n+#include <gio/gio.h>\n #include \"util.h\"\n \n /* If openssl was built without ec */\n@@ -339,3 +341,204 @@ _SSL_close (SSL * ssl)\n \tSSL_free (ssl);\n \tERR_remove_state (0);\t\t  /* free state buffer */\n }\n+\n+/* Hostname validation code based on OpenBSD's libtls. */\n+\n+static int\n+_SSL_match_hostname (const char *cert_hostname, const char *hostname)\n+{\n+\tconst char *cert_domain, *domain, *next_dot;\n+\n+\tif (g_ascii_strcasecmp (cert_hostname, hostname) == 0)\n+\t\treturn 0;\n+\n+\t/* Wildcard match? */\n+\tif (cert_hostname[0] == '*')\n+\t{\n+\t\t/*\n+\t\t * Valid wildcards:\n+\t\t * - \"*.domain.tld\"\n+\t\t * - \"*.sub.domain.tld\"\n+\t\t * - etc.\n+\t\t * Reject \"*.tld\".\n+\t\t * No attempt to prevent the use of eg. \"*.co.uk\".\n+\t\t */\n+\t\tcert_domain = &cert_hostname[1];\n+\t\t/* Disallow \"*\"  */\n+\t\tif (cert_domain[0] == '\\0')\n+\t\t\treturn -1;\n+\t\t/* Disallow \"*foo\" */\n+\t\tif (cert_domain[0] != '.')\n+\t\t\treturn -1;\n+\t\t/* Disallow \"*..\" */\n+\t\tif (cert_domain[1] == '.')\n+\t\t\treturn -1;\n+\t\tnext_dot = strchr (&cert_domain[1], '.');\n+\t\t/* Disallow \"*.bar\" */\n+\t\tif (next_dot == NULL)\n+\t\t\treturn -1;\n+\t\t/* Disallow \"*.bar..\" */\n+\t\tif (next_dot[1] == '.')\n+\t\t\treturn -1;\n+\n+\t\tdomain = strchr (hostname, '.');\n+\n+\t\t/* No wildcard match against a hostname with no domain part. */\n+\t\tif (domain == NULL || strlen(domain) == 1)\n+\t\t\treturn -1;\n+\n+\t\tif (g_ascii_strcasecmp (cert_domain, domain) == 0)\n+\t\t\treturn 0;\n+\t}\n+\n+\treturn -1;\n+}\n+\n+static int\n+_SSL_check_subject_altname (X509 *cert, const char *host)\n+{\n+\tSTACK_OF(GENERAL_NAME) *altname_stack = NULL;\n+\tGInetAddress *addr;\n+\tGSocketFamily family;\n+\tint type = GEN_DNS;\n+\tint count, i;\n+\tint rv = -1;\n+\n+\taltname_stack = X509_get_ext_d2i (cert, NID_subject_alt_name, NULL, NULL);\n+\tif (altname_stack == NULL)\n+\t\treturn -1;\n+\n+\taddr = g_inet_address_new_from_string (host);\n+\tif (addr != NULL)\n+\t{\n+\t\tfamily = g_inet_address_get_family (addr);\n+\t\tif (family == G_SOCKET_FAMILY_IPV4 || family == G_SOCKET_FAMILY_IPV6)\n+\t\t\ttype = GEN_IPADD;\n+\t}\n+\n+\tcount = sk_GENERAL_NAME_num(altname_stack);\n+\tfor (i = 0; i < count; i++)\n+\t{\n+\t\tGENERAL_NAME *altname;\n+\n+\t\taltname = sk_GENERAL_NAME_value (altname_stack, i);\n+\n+\t\tif (altname->type != type)\n+\t\t\tcontinue;\n+\n+\t\tif (type == GEN_DNS)\n+\t\t{\n+\t\t\tunsigned char *data;\n+\t\t\tint format;\n+\n+\t\t\tformat = ASN1_STRING_type (altname->d.dNSName);\n+\t\t\tif (format == V_ASN1_IA5STRING)\n+\t\t\t{\n+\t\t\t\tdata = ASN1_STRING_data (altname->d.dNSName);\n+\n+\t\t\t\tif (ASN1_STRING_length (altname->d.dNSName) != (int)strlen(data))\n+\t\t\t\t{\n+\t\t\t\t\tg_warning(\"NUL byte in subjectAltName, probably a malicious certificate.\\n\");\n+\t\t\t\t\trv = -2;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tif (_SSL_match_hostname (data, host) == 0)\n+\t\t\t\t{\n+\t\t\t\t\trv = 0;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse\n+\t\t\t\tg_warning (\"unhandled subjectAltName dNSName encoding (%d)\\n\", format);\n+\n+\t\t}\n+\t\telse if (type == GEN_IPADD)\n+\t\t{\n+\t\t\tunsigned char *data;\n+\t\t\tconst guint8 *addr_bytes;\n+\t\t\tint datalen, addr_len;\n+\n+\t\t\tdatalen = ASN1_STRING_length (altname->d.iPAddress);\n+\t\t\tdata = ASN1_STRING_data (altname->d.iPAddress);\n+\n+\t\t\taddr_bytes = g_inet_address_to_bytes (addr);\n+\t\t\taddr_len = (int)g_inet_address_get_native_size (addr);\n+\n+\t\t\tif (datalen == addr_len && memcmp (data, addr_bytes, addr_len) == 0)\n+\t\t\t{\n+\t\t\t\trv = 0;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif (addr != NULL)\n+\t\tg_object_unref (addr);\n+\tsk_GENERAL_NAME_free (altname_stack);\n+\treturn rv;\n+}\n+\n+static int\n+_SSL_check_common_name (X509 *cert, const char *host)\n+{\n+\tX509_NAME *name;\n+\tchar *common_name = NULL;\n+\tint common_name_len;\n+\tint rv = -1;\n+\tGInetAddress *addr;\n+\n+\tname = X509_get_subject_name (cert);\n+\tif (name == NULL)\n+\t\treturn -1;\n+\n+\tcommon_name_len = X509_NAME_get_text_by_NID (name, NID_commonName, NULL, 0);\n+\tif (common_name_len < 0)\n+\t\treturn -1;\n+\n+\tcommon_name = calloc (common_name_len + 1, 1);\n+\tif (common_name == NULL)\n+\t\treturn -1;\n+\n+\tX509_NAME_get_text_by_NID (name, NID_commonName, common_name, common_name_len + 1);\n+\n+\t/* NUL bytes in CN? */\n+\tif (common_name_len != (int)strlen(common_name))\n+\t{\n+\t\tg_warning (\"NUL byte in Common Name field, probably a malicious certificate.\\n\");\n+\t\trv = -2;\n+\t\tgoto out;\n+\t}\n+\n+\tif ((addr = g_inet_address_new_from_string (host)) != NULL)\n+\t{\n+\t\t/*\n+\t\t * We don't want to attempt wildcard matching against IP\n+\t\t * addresses, so perform a simple comparison here.\n+\t\t */\n+\t\tif (g_strcmp0 (common_name, host) == 0)\n+\t\t\trv = 0;\n+\t\telse\n+\t\t\trv = -1;\n+\n+\t\tg_object_unref (addr);\n+\t}\n+\telse if (_SSL_match_hostname (common_name, host) == 0)\n+\t\trv = 0;\n+\n+out:\n+\tfree(common_name);\n+\treturn rv;\n+}\n+\n+int\n+_SSL_check_hostname (X509 *cert, const char *host)\n+{\n+\tint rv;\n+\n+\trv = _SSL_check_subject_altname (cert, host);\n+\tif (rv == 0 || rv == -2)\n+\t\treturn rv;\n+\n+\treturn _SSL_check_common_name (cert, host);\n+}\n\\ No newline at end of file"
        },
        {
          "filename": "src/common/ssl.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -52,7 +52,7 @@ char *_SSL_set_verify (SSL_CTX *ctx, void *(verify_callback), char *cacert);\n     int SSL_get_fd(SSL *);\n */\n void _SSL_close (SSL * ssl);\n-\n+int _SSL_check_hostname(X509 *cert, const char *host);\n int _SSL_get_cert_info (struct cert_info *cert_info, SSL * ssl);\n struct chiper_info *_SSL_get_cipher_info (SSL * ssl);\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b544ac3350e85d4cc41fe3414cbdb82d75ce5d7a",
            "date": "2024-02-10T00:32:55Z",
            "author_login": "TingPing"
          },
          {
            "sha": "cc60ad275a56126904df0b5e37cfd20db22cb359",
            "date": "2024-02-10T00:29:15Z",
            "author_login": "TingPing"
          },
          {
            "sha": "70069cd50eb07e8a40ac9b0efbb83fcb91a78b99",
            "date": "2024-02-09T20:20:48Z",
            "author_login": "TingPing"
          },
          {
            "sha": "434a210ef79241cd650dd074b66a9ce87e8450a1",
            "date": "2024-02-07T12:01:12Z",
            "author_login": "TingPing"
          },
          {
            "sha": "180ce9f4fde4f87150b69e0cf40873226dbb9455",
            "date": "2024-01-29T03:33:45Z",
            "author_login": "collinfunk"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-310",
    "description": "The ssl_do_connect function in common/server.c in HexChat before 2.10.2, XChat, and XChat-GNOME does not verify that the server hostname matches a domain name in the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2016-04-21T14:59:00.107",
    "last_modified": "2024-11-21T02:01:01.733",
    "fix_date": "2014-11-20T02:43:01Z"
  },
  "references": [
    {
      "url": "http://hexchat.readthedocs.org/en/latest/changelog.html",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2945-1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1081839",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/hexchat/hexchat/commit/c9b63f7f9be01692b03fa15275135a4910a7e02d",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/hexchat/hexchat/issues/524",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://hexchat.readthedocs.org/en/latest/changelog.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2945-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1081839",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/hexchat/hexchat/commit/c9b63f7f9be01692b03fa15275135a4910a7e02d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/hexchat/hexchat/issues/524",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:42.528159",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "hexchat",
    "owner": "hexchat",
    "created_at": "2012-07-11T20:42:10Z",
    "updated_at": "2025-01-12T16:34:01Z",
    "pushed_at": "2024-08-19T02:29:21Z",
    "size": 24318,
    "stars": 3101,
    "forks": 537,
    "open_issues": 769,
    "watchers": 3101,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "C": 1990128,
      "Python": 35791,
      "Perl": 32965,
      "Meson": 26999,
      "C#": 18809,
      "C++": 10906,
      "Objective-C": 8085,
      "Shell": 6216,
      "Roff": 1226,
      "Inno Setup": 894,
      "Batchfile": 883,
      "PowerShell": 495
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T15:49:02.206353"
  }
}