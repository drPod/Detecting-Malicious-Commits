{
  "cve_id": "CVE-2014-0064",
  "github_data": {
    "repository": "postgres/postgres",
    "fix_commit": "31400a673325147e1205326008e32135a78b4d8a",
    "related_commits": [
      "31400a673325147e1205326008e32135a78b4d8a",
      "31400a673325147e1205326008e32135a78b4d8a"
    ],
    "patch_url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a.patch",
    "fix_commit_details": {
      "sha": "31400a673325147e1205326008e32135a78b4d8a",
      "commit_date": "2014-02-17T14:33:31Z",
      "author": {
        "login": "nmisch",
        "type": "User",
        "stats": {
          "total_commits": 495,
          "average_weekly_commits": 0.33243787777031564,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 232
        }
      },
      "commit_message": {
        "title": "Predict integer overflow to avoid buffer overruns.",
        "length": 724,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 196,
        "additions": 177,
        "deletions": 19
      },
      "files": [
        {
          "filename": "contrib/hstore/hstore.h",
          "status": "modified",
          "additions": 12,
          "deletions": 3,
          "patch": "@@ -49,16 +49,25 @@ typedef struct\n } HStore;\n \n /*\n- * it's not possible to get more than 2^28 items into an hstore,\n- * so we reserve the top few bits of the size field. See hstore_compat.c\n- * for one reason why.\tSome bits are left for future use here.\n+ * It's not possible to get more than 2^28 items into an hstore, so we reserve\n+ * the top few bits of the size field.  See hstore_compat.c for one reason\n+ * why.  Some bits are left for future use here.  MaxAllocSize makes the\n+ * practical count limit slightly more than 2^28 / 3, or INT_MAX / 24, the\n+ * limit for an hstore full of 4-byte keys and null values.  Therefore, we\n+ * don't explicitly check the format-imposed limit.\n  */\n #define HS_FLAG_NEWVERSION 0x80000000\n \n #define HS_COUNT(hsp_) ((hsp_)->size_ & 0x0FFFFFFF)\n #define HS_SETCOUNT(hsp_,c_) ((hsp_)->size_ = (c_) | HS_FLAG_NEWVERSION)\n \n \n+/*\n+ * \"x\" comes from an existing HS_COUNT() (as discussed, <= INT_MAX/24) or a\n+ * Pairs array length (due to MaxAllocSize, <= INT_MAX/40).  \"lenstr\" is no\n+ * more than INT_MAX, that extreme case arising in hstore_from_arrays().\n+ * Therefore, this calculation is limited to about INT_MAX / 5 + INT_MAX.\n+ */\n #define HSHRDSIZE\t(sizeof(HStore))\n #define CALCDATASIZE(x, lenstr) ( (x) * 2 * sizeof(HEntry) + HSHRDSIZE + (lenstr) )\n "
        },
        {
          "filename": "contrib/hstore/hstore_io.c",
          "status": "modified",
          "additions": 21,
          "deletions": 0,
          "patch": "@@ -13,6 +13,7 @@\n #include \"utils/builtins.h\"\n #include \"utils/json.h\"\n #include \"utils/lsyscache.h\"\n+#include \"utils/memutils.h\"\n #include \"utils/typcache.h\"\n \n #include \"hstore.h\"\n@@ -439,6 +440,11 @@ hstore_recv(PG_FUNCTION_ARGS)\n \t\tPG_RETURN_POINTER(out);\n \t}\n \n+\tif (pcount < 0 || pcount > MaxAllocSize / sizeof(Pairs))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t pcount, (int) (MaxAllocSize / sizeof(Pairs)))));\n \tpairs = palloc(pcount * sizeof(Pairs));\n \n \tfor (i = 0; i < pcount; ++i)\n@@ -554,6 +560,13 @@ hstore_from_arrays(PG_FUNCTION_ARGS)\n \t\t\t\t\t  TEXTOID, -1, false, 'i',\n \t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n \n+\t/* see discussion in hstoreArrayToPairs() */\n+\tif (key_count > MaxAllocSize / sizeof(Pairs))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t key_count, (int) (MaxAllocSize / sizeof(Pairs)))));\n+\n \t/* value_array might be NULL */\n \n \tif (PG_ARGISNULL(1))\n@@ -676,6 +689,13 @@ hstore_from_array(PG_FUNCTION_ARGS)\n \n \tcount = in_count / 2;\n \n+\t/* see discussion in hstoreArrayToPairs() */\n+\tif (count > MaxAllocSize / sizeof(Pairs))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t count, (int) (MaxAllocSize / sizeof(Pairs)))));\n+\n \tpairs = palloc(count * sizeof(Pairs));\n \n \tfor (i = 0; i < count; ++i)\n@@ -807,6 +827,7 @@ hstore_from_record(PG_FUNCTION_ARGS)\n \t\tmy_extra->ncolumns = ncolumns;\n \t}\n \n+\tAssert(ncolumns <= MaxTupleAttributeNumber);\t\t/* thus, no overflow */\n \tpairs = palloc(ncolumns * sizeof(Pairs));\n \n \tif (rec)"
        },
        {
          "filename": "contrib/hstore/hstore_op.c",
          "status": "modified",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -8,6 +8,7 @@\n #include \"catalog/pg_type.h\"\n #include \"funcapi.h\"\n #include \"utils/builtins.h\"\n+#include \"utils/memutils.h\"\n \n #include \"hstore.h\"\n \n@@ -90,6 +91,19 @@ hstoreArrayToPairs(ArrayType *a, int *npairs)\n \t\treturn NULL;\n \t}\n \n+\t/*\n+\t * A text array uses at least eight bytes per element, so any overflow in\n+\t * \"key_count * sizeof(Pairs)\" is small enough for palloc() to catch.\n+\t * However, credible improvements to the array format could invalidate\n+\t * that assumption.  Therefore, use an explicit check rather than relying\n+\t * on palloc() to complain.\n+\t */\n+\tif (key_count > MaxAllocSize / sizeof(Pairs))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t key_count, (int) (MaxAllocSize / sizeof(Pairs)))));\n+\n \tkey_pairs = palloc(sizeof(Pairs) * key_count);\n \n \tfor (i = 0, j = 0; i < key_count; i++)\n@@ -648,6 +662,7 @@ hstore_slice_to_hstore(PG_FUNCTION_ARGS)\n \t\tPG_RETURN_POINTER(out);\n \t}\n \n+\t/* hstoreArrayToPairs() checked overflow */\n \tout_pairs = palloc(sizeof(Pairs) * nkeys);\n \tbufsiz = 0;\n "
        },
        {
          "filename": "contrib/intarray/_int.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -5,6 +5,7 @@\n #define ___INT_H__\n \n #include \"utils/array.h\"\n+#include \"utils/memutils.h\"\n \n /* number ranges for compression */\n #define MAXNUMRANGE 100\n@@ -137,6 +138,7 @@ typedef struct QUERYTYPE\n \n #define HDRSIZEQT\toffsetof(QUERYTYPE, items)\n #define COMPUTESIZE(size)\t( HDRSIZEQT + (size) * sizeof(ITEM) )\n+#define QUERYTYPEMAXITEMS\t((MaxAllocSize - HDRSIZEQT) / sizeof(ITEM))\n #define GETQUERY(x)  ( (x)->items )\n \n /* \"type\" codes for ITEM */"
        },
        {
          "filename": "contrib/intarray/_int_bool.c",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -448,6 +448,9 @@ boolop(PG_FUNCTION_ARGS)\n static void\n findoprnd(ITEM *ptr, int32 *pos)\n {\n+\t/* since this function recurses, it could be driven to stack overflow. */\n+\tcheck_stack_depth();\n+\n #ifdef BS_DEBUG\n \telog(DEBUG3, (ptr[*pos].type == OPR) ?\n \t\t \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);\n@@ -508,7 +511,13 @@ bqarr_in(PG_FUNCTION_ARGS)\n \t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n \t\t\t\t errmsg(\"empty query\")));\n \n+\tif (state.num > QUERYTYPEMAXITEMS)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\terrmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t   state.num, (int) QUERYTYPEMAXITEMS)));\n \tcommonlen = COMPUTESIZE(state.num);\n+\n \tquery = (QUERYTYPE *) palloc(commonlen);\n \tSET_VARSIZE(query, commonlen);\n \tquery->size = state.num;"
        },
        {
          "filename": "contrib/ltree/ltree.h",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -5,6 +5,7 @@\n \n #include \"fmgr.h\"\n #include \"tsearch/ts_locale.h\"\n+#include \"utils/memutils.h\"\n \n typedef struct\n {\n@@ -111,6 +112,8 @@ typedef struct\n \n #define HDRSIZEQT\t\tMAXALIGN(VARHDRSZ + sizeof(int32))\n #define COMPUTESIZE(size,lenofoperand)\t( HDRSIZEQT + (size) * sizeof(ITEM) + (lenofoperand) )\n+#define LTXTQUERY_TOO_BIG(size,lenofoperand) \\\n+\t((size) > (MaxAllocSize - HDRSIZEQT - (lenofoperand)) / sizeof(ITEM))\n #define GETQUERY(x)  (ITEM*)( (char*)(x)+HDRSIZEQT )\n #define GETOPERAND(x)\t( (char*)GETQUERY(x) + ((ltxtquery*)x)->size * sizeof(ITEM) )\n "
        },
        {
          "filename": "contrib/ltree/ltree_io.c",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -8,6 +8,7 @@\n #include <ctype.h>\n \n #include \"ltree.h\"\n+#include \"utils/memutils.h\"\n #include \"crc32.h\"\n \n PG_FUNCTION_INFO_V1(ltree_in);\n@@ -64,6 +65,11 @@ ltree_in(PG_FUNCTION_ARGS)\n \t\tptr += charlen;\n \t}\n \n+\tif (num + 1 > MaxAllocSize / sizeof(nodeitem))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\tnum + 1, (int) (MaxAllocSize / sizeof(nodeitem)))));\n \tlist = lptr = (nodeitem *) palloc(sizeof(nodeitem) * (num + 1));\n \tptr = buf;\n \twhile (*ptr)\n@@ -228,6 +234,11 @@ lquery_in(PG_FUNCTION_ARGS)\n \t}\n \n \tnum++;\n+\tif (num > MaxAllocSize / ITEMSIZE)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\tnum, (int) (MaxAllocSize / ITEMSIZE))));\n \tcurqlevel = tmpql = (lquery_level *) palloc0(ITEMSIZE * num);\n \tptr = buf;\n \twhile (*ptr)"
        },
        {
          "filename": "contrib/ltree/ltxtquery_io.c",
          "status": "modified",
          "additions": 12,
          "deletions": 1,
          "patch": "@@ -9,6 +9,7 @@\n \n #include \"crc32.h\"\n #include \"ltree.h\"\n+#include \"miscadmin.h\"\n \n PG_FUNCTION_INFO_V1(ltxtq_in);\n Datum\t\tltxtq_in(PG_FUNCTION_ARGS);\n@@ -212,6 +213,9 @@ makepol(QPRS_STATE *state)\n \tint32\t\tlenstack = 0;\n \tuint16\t\tflag = 0;\n \n+\t/* since this function recurses, it could be driven to stack overflow */\n+\tcheck_stack_depth();\n+\n \twhile ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)\n \t{\n \t\tswitch (type)\n@@ -276,6 +280,9 @@ makepol(QPRS_STATE *state)\n static void\n findoprnd(ITEM *ptr, int32 *pos)\n {\n+\t/* since this function recurses, it could be driven to stack overflow. */\n+\tcheck_stack_depth();\n+\n \tif (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)\n \t{\n \t\tptr[*pos].left = 0;\n@@ -340,8 +347,12 @@ queryin(char *buf)\n \t\t\t\t errmsg(\"syntax error\"),\n \t\t\t\t errdetail(\"Empty query.\")));\n \n-\t/* make finish struct */\n+\tif (LTXTQUERY_TOO_BIG(state.num, state.sumlen))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"ltxtquery is too large\")));\n \tcommonlen = COMPUTESIZE(state.num, state.sumlen);\n+\n \tquery = (ltxtquery *) palloc(commonlen);\n \tSET_VARSIZE(query, commonlen);\n \tquery->size = state.num;"
        },
        {
          "filename": "src/backend/utils/adt/geo_ops.c",
          "status": "modified",
          "additions": 28,
          "deletions": 2,
          "patch": "@@ -1366,6 +1366,7 @@ path_in(PG_FUNCTION_ARGS)\n \tchar\t   *s;\n \tint\t\t\tnpts;\n \tint\t\t\tsize;\n+\tint\t\t\tbase_size;\n \tint\t\t\tdepth = 0;\n \n \tif ((npts = pair_count(str, ',')) <= 0)\n@@ -1384,7 +1385,15 @@ path_in(PG_FUNCTION_ARGS)\n \t\tdepth++;\n \t}\n \n-\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;\n+\tbase_size = sizeof(path->p[0]) * npts;\n+\tsize = offsetof(PATH, p[0]) + base_size;\n+\n+\t/* Check for integer overflow */\n+\tif (base_size / npts != sizeof(path->p[0]) || size <= base_size)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"too many points requested\")));\n+\n \tpath = (PATH *) palloc(size);\n \n \tSET_VARSIZE(path, size);\n@@ -3429,6 +3438,7 @@ poly_in(PG_FUNCTION_ARGS)\n \tPOLYGON    *poly;\n \tint\t\t\tnpts;\n \tint\t\t\tsize;\n+\tint\t\t\tbase_size;\n \tint\t\t\tisopen;\n \tchar\t   *s;\n \n@@ -3437,7 +3447,15 @@ poly_in(PG_FUNCTION_ARGS)\n \t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n \t\t\t  errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));\n \n-\tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;\n+\tbase_size = sizeof(poly->p[0]) * npts;\n+\tsize = offsetof(POLYGON, p[0]) + base_size;\n+\n+\t/* Check for integer overflow */\n+\tif (base_size / npts != sizeof(poly->p[0]) || size <= base_size)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"too many points requested\")));\n+\n \tpoly = (POLYGON *) palloc0(size);\t/* zero any holes */\n \n \tSET_VARSIZE(poly, size);\n@@ -4343,6 +4361,10 @@ path_poly(PG_FUNCTION_ARGS)\n \t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n \t\t\t\t errmsg(\"open path cannot be converted to polygon\")));\n \n+\t/*\n+\t * Never overflows: the old size fit in MaxAllocSize, and the new size is\n+\t * just a small constant larger.\n+\t */\n \tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * path->npts;\n \tpoly = (POLYGON *) palloc(size);\n \n@@ -4448,6 +4470,10 @@ poly_path(PG_FUNCTION_ARGS)\n \tint\t\t\tsize;\n \tint\t\t\ti;\n \n+\t/*\n+\t * Never overflows: the old size fit in MaxAllocSize, and the new size is\n+\t * smaller by a small constant.\n+\t */\n \tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * poly->npts;\n \tpath = (PATH *) palloc(size);\n "
        },
        {
          "filename": "src/backend/utils/adt/tsquery.c",
          "status": "modified",
          "additions": 6,
          "deletions": 1,
          "patch": "@@ -514,8 +514,13 @@ parse_tsquery(char *buf,\n \t\treturn query;\n \t}\n \n-\t/* Pack the QueryItems in the final TSQuery struct to return to caller */\n+\tif (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"tsquery is too large\")));\n \tcommonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);\n+\n+\t/* Pack the QueryItems in the final TSQuery struct to return to caller */\n \tquery = (TSQuery) palloc0(commonlen);\n \tSET_VARSIZE(query, commonlen);\n \tquery->size = list_length(state.polstr);"
        },
        {
          "filename": "src/backend/utils/adt/tsquery_util.c",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -333,6 +333,11 @@ QTN2QT(QTNode *in)\n \tQTN2QTState state;\n \n \tcntsize(in, &sumlen, &nnode);\n+\n+\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"tsquery is too large\")));\n \tlen = COMPUTESIZE(nnode, sumlen);\n \n \tout = (TSQuery) palloc0(len);"
        },
        {
          "filename": "src/backend/utils/adt/txid.c",
          "status": "modified",
          "additions": 13,
          "deletions": 10,
          "patch": "@@ -26,7 +26,9 @@\n #include \"funcapi.h\"\n #include \"miscadmin.h\"\n #include \"libpq/pqformat.h\"\n+#include \"postmaster/postmaster.h\"\n #include \"utils/builtins.h\"\n+#include \"utils/memutils.h\"\n #include \"utils/snapmgr.h\"\n \n \n@@ -66,6 +68,8 @@ typedef struct\n \n #define TXID_SNAPSHOT_SIZE(nxip) \\\n \t(offsetof(TxidSnapshot, xip) + sizeof(txid) * (nxip))\n+#define TXID_SNAPSHOT_MAX_NXIP \\\n+\t((MaxAllocSize - offsetof(TxidSnapshot, xip)) / sizeof(txid))\n \n /*\n  * Epoch values from xact.c\n@@ -368,6 +372,13 @@ txid_current_snapshot(PG_FUNCTION_ARGS)\n \n \tload_xid_epoch(&state);\n \n+\t/*\n+\t * Compile-time limits on the procarray (MAX_BACKENDS processes plus\n+\t * MAX_BACKENDS prepared transactions) guarantee nxip won't be too large.\n+\t */\n+\tStaticAssertStmt(MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP,\n+\t\t\t\t\t \"possible overflow in txid_current_snapshot()\");\n+\n \t/* allocate */\n \tnxip = cur->xcnt;\n \tsize = TXID_SNAPSHOT_SIZE(nxip);\n@@ -445,20 +456,12 @@ txid_snapshot_recv(PG_FUNCTION_ARGS)\n \ttxid\t\tlast = 0;\n \tint\t\t\tnxip;\n \tint\t\t\ti;\n-\tint\t\t\tavail;\n-\tint\t\t\texpect;\n \ttxid\t\txmin,\n \t\t\t\txmax;\n \n-\t/*\n-\t * load nxip and check for nonsense.\n-\t *\n-\t * (nxip > avail) check is against int overflows in 'expect'.\n-\t */\n+\t/* load and validate nxip */\n \tnxip = pq_getmsgint(buf, 4);\n-\tavail = buf->len - buf->cursor;\n-\texpect = 8 + 8 + nxip * 8;\n-\tif (nxip < 0 || nxip > avail || expect > avail)\n+\tif (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)\n \t\tgoto bad_format;\n \n \txmin = pq_getmsgint64(buf);"
        },
        {
          "filename": "src/backend/utils/adt/varbit.c",
          "status": "modified",
          "additions": 30,
          "deletions": 2,
          "patch": "@@ -148,12 +148,22 @@ bit_in(PG_FUNCTION_ARGS)\n \t\tsp = input_string;\n \t}\n \n+\t/*\n+\t * Determine bitlength from input string.  MaxAllocSize ensures a regular\n+\t * input is small enough, but we must check hex input.\n+\t */\n \tslen = strlen(sp);\n-\t/* Determine bitlength from input string */\n \tif (bit_not_hex)\n \t\tbitlen = slen;\n \telse\n+\t{\n+\t\tif (slen > VARBITMAXLEN / 4)\n+\t\t\tereport(ERROR,\n+\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t\tVARBITMAXLEN)));\n \t\tbitlen = slen * 4;\n+\t}\n \n \t/*\n \t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n@@ -450,12 +460,22 @@ varbit_in(PG_FUNCTION_ARGS)\n \t\tsp = input_string;\n \t}\n \n+\t/*\n+\t * Determine bitlength from input string.  MaxAllocSize ensures a regular\n+\t * input is small enough, but we must check hex input.\n+\t */\n \tslen = strlen(sp);\n-\t/* Determine bitlength from input string */\n \tif (bit_not_hex)\n \t\tbitlen = slen;\n \telse\n+\t{\n+\t\tif (slen > VARBITMAXLEN / 4)\n+\t\t\tereport(ERROR,\n+\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t\tVARBITMAXLEN)));\n \t\tbitlen = slen * 4;\n+\t}\n \n \t/*\n \t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n@@ -535,6 +555,9 @@ varbit_in(PG_FUNCTION_ARGS)\n /*\n  * varbit_out -\n  *\t  Prints the string as bits to preserve length accurately\n+ *\n+ * XXX varbit_recv() and hex input to varbit_in() can load a value that this\n+ * cannot emit.  Consider using hex output for such values.\n  */\n Datum\n varbit_out(PG_FUNCTION_ARGS)\n@@ -944,6 +967,11 @@ bit_catenate(VarBit *arg1, VarBit *arg2)\n \tbitlen1 = VARBITLEN(arg1);\n \tbitlen2 = VARBITLEN(arg2);\n \n+\tif (bitlen1 > VARBITMAXLEN - bitlen2)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t\tVARBITMAXLEN)));\n \tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);\n \n \tresult = (VarBit *) palloc(bytelen);"
        },
        {
          "filename": "src/include/tsearch/ts_type.h",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -13,6 +13,7 @@\n #define _PG_TSTYPE_H_\n \n #include \"fmgr.h\"\n+#include \"utils/memutils.h\"\n #include \"utils/pg_crc.h\"\n \n \n@@ -244,6 +245,8 @@ typedef TSQueryData *TSQuery;\n  * QueryItems, and lenofoperand is the total length of all operands\n  */\n #define COMPUTESIZE(size, lenofoperand) ( HDRSIZETQ + (size) * sizeof(QueryItem) + (lenofoperand) )\n+#define TSQUERY_TOO_BIG(size, lenofoperand) \\\n+\t((size) > (MaxAllocSize - HDRSIZETQ - (lenofoperand)) / sizeof(QueryItem))\n \n /* Returns a pointer to the first QueryItem in a TSQuery */\n #define GETQUERY(x)  ((QueryItem*)( (char*)(x)+HDRSIZETQ ))"
        },
        {
          "filename": "src/include/utils/varbit.h",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -15,6 +15,8 @@\n #ifndef VARBIT_H\n #define VARBIT_H\n \n+#include <limits.h>\n+\n #include \"fmgr.h\"\n \n /*\n@@ -53,6 +55,11 @@ typedef struct\n /* Number of bytes needed to store a bit string of a given length */\n #define VARBITTOTALLEN(BITLEN)\t(((BITLEN) + BITS_PER_BYTE-1)/BITS_PER_BYTE + \\\n \t\t\t\t\t\t\t\t VARHDRSZ + VARBITHDRSZ)\n+/*\n+ * Maximum number of bits.  Several code sites assume no overflow from\n+ * computing bitlen + X; VARBITTOTALLEN() has the largest such X.\n+ */\n+#define VARBITMAXLEN\t\t(INT_MAX - BITS_PER_BYTE + 1)\n /* pointer beyond the end of the bit string (like end() in STL containers) */\n #define VARBITEND(PTR)\t\t(((bits8 *) (PTR)) + VARSIZE(PTR))\n /* Mask that will cover exactly one byte, i.e. BITS_PER_BYTE bits */"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 6,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "ce9a74707d4cf7768cff06298d09c7f7e823341d",
            "date": "2025-01-14T06:17:22Z",
            "author_login": "michaelpq"
          },
          {
            "sha": "720e529840d5a1087a34db445f624c5ece46eb38",
            "date": "2025-01-14T06:12:56Z",
            "author_login": "michaelpq"
          },
          {
            "sha": "d35ea27e51c05cbe3575d50a6b99d64f20a3a742",
            "date": "2025-01-14T03:43:07Z",
            "author_login": "michaelpq"
          },
          {
            "sha": "d2181b321852d4dbea8a909d2f039ebdcbf0e009",
            "date": "2025-01-14T03:19:51Z",
            "author_login": "michaelpq"
          },
          {
            "sha": "f92c854cf406a5ad34c9aa92416d578819704aa2",
            "date": "2025-01-14T03:14:29Z",
            "author_login": "michaelpq"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-189",
    "description": "Multiple integer overflows in the path_in and other unspecified functions in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact and attack vectors, which trigger a buffer overflow.  NOTE: this identifier has been SPLIT due to different affected versions; use CVE-2014-2669 for the hstore vector.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2014-03-31T14:58:15.740",
    "last_modified": "2024-11-21T02:01:16.980",
    "fix_date": "2014-02-17T14:33:31Z"
  },
  "references": [
    {
      "url": "http://archives.neohapsis.com/archives/bugtraq/2014-10/0103.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://kb.juniper.net/InfoCenter/index?page=content&id=JSA10705",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2014-03/msg00018.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2014-03/msg00038.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2014-0211.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2014-0221.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2014-0249.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2014-0469.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://secunia.com/advisories/61307",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://support.apple.com/kb/HT6448",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://wiki.postgresql.org/wiki/20140220securityrelease",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2014/dsa-2864",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2014/dsa-2865",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.oracle.com/technetwork/security-advisory/cpuoct2017-3236626.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.postgresql.org/about/news/1506/",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.postgresql.org/support/security/",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/65725",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2120-1",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1065230",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://support.apple.com/kb/HT6536",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://archives.neohapsis.com/archives/bugtraq/2014-10/0103.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://kb.juniper.net/InfoCenter/index?page=content&id=JSA10705",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2014-03/msg00018.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2014-03/msg00038.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2014-0211.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2014-0221.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2014-0249.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2014-0469.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://secunia.com/advisories/61307",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://support.apple.com/kb/HT6448",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://wiki.postgresql.org/wiki/20140220securityrelease",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2014/dsa-2864",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2014/dsa-2865",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.oracle.com/technetwork/security-advisory/cpuoct2017-3236626.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.postgresql.org/about/news/1506/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.postgresql.org/support/security/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/65725",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2120-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1065230",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://support.apple.com/kb/HT6536",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:22.577609",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "postgres",
    "owner": "postgres",
    "created_at": "2010-09-21T11:35:45Z",
    "updated_at": "2025-01-14T12:23:23Z",
    "pushed_at": "2025-01-14T06:28:38Z",
    "size": 608320,
    "stars": 16634,
    "forks": 4693,
    "open_issues": 1,
    "watchers": 16634,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 47031174,
      "PLpgSQL": 3927896,
      "Perl": 2290426,
      "Yacc": 697711,
      "Makefile": 362302,
      "Meson": 359391,
      "Python": 270469,
      "Lex": 229520,
      "M4": 185355,
      "Ruby": 164128,
      "Shell": 75722,
      "C++": 55705,
      "PLSQL": 55013,
      "Roff": 17748,
      "XS": 6998,
      "Emacs Lisp": 4164,
      "DTrace": 3452,
      "Assembly": 2468,
      "Starlark": 1640,
      "sed": 581
    },
    "commit_activity": {
      "total_commits_last_year": 2526,
      "avg_commits_per_week": 48.57692307692308,
      "days_active_last_year": 333
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:07:40.608433"
  }
}