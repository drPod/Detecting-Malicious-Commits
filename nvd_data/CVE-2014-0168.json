{
  "cve_id": "CVE-2014-0168",
  "github_data": {
    "repository": "rhuss/jolokia",
    "fix_commit": "2d9b168cfbbf5a6d16fa6e8a5b34503e3dc42364",
    "related_commits": [
      "2d9b168cfbbf5a6d16fa6e8a5b34503e3dc42364",
      "2d9b168cfbbf5a6d16fa6e8a5b34503e3dc42364"
    ],
    "patch_url": "https://github.com/rhuss/jolokia/commit/2d9b168cfbbf5a6d16fa6e8a5b34503e3dc42364.patch",
    "fix_commit_details": {
      "sha": "2d9b168cfbbf5a6d16fa6e8a5b34503e3dc42364",
      "commit_date": "2014-04-10T08:22:57Z",
      "author": {
        "login": "rhuss",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Enchanced policy wr to origin handling. The Origin: can now be checked on the server side, too.",
        "length": 95,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 220,
        "additions": 166,
        "deletions": 54
      },
      "files": [
        {
          "filename": "agent/core/src/main/java/org/jolokia/backend/BackendManager.java",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -223,10 +223,11 @@ public boolean isRemoteAccessAllowed(String pRemoteHost, String pRemoteAddr) {\n      * Check whether CORS access is allowed for the given origin.\n      *\n      * @param pOrigin origin URL which needs to be checked\n-     * @return true if icors access is allowed\n+     * @param pStrictChecking whether to a strict check (i.e. server side check)\n+     * @return true if if cors access is allowed\n      */\n-    public boolean isCorsAccessAllowed(String pOrigin) {\n-        return restrictor.isCorsAccessAllowed(pOrigin);\n+    public boolean isOriginAllowed(String pOrigin,boolean pStrictChecking) {\n+        return restrictor.isOriginAllowed(pOrigin, pStrictChecking);\n     }\n \n     /**"
        },
        {
          "filename": "agent/core/src/main/java/org/jolokia/http/AgentServlet.java",
          "status": "modified",
          "additions": 11,
          "deletions": 1,
          "patch": "@@ -278,7 +278,8 @@ private void handle(ServletRequestHandler pReqHandler,HttpServletRequest pReq, H\n         JSONAware json = null;\n         try {\n             // Check access policy\n-            requestHandler.checkClientIPAccess(pReq.getRemoteHost(),pReq.getRemoteAddr());\n+            requestHandler.checkAccess(pReq.getRemoteHost(), pReq.getRemoteAddr(),\n+                                       getOriginOrReferer(pReq));\n \n             // Remember the agent URL upon the first request. Needed for discovery\n             updateAgentUrlIfNeeded(pReq);\n@@ -304,6 +305,15 @@ private void handle(ServletRequestHandler pReqHandler,HttpServletRequest pReq, H\n         }\n     }\n \n+    private String getOriginOrReferer(HttpServletRequest pReq) {\n+        String origin = pReq.getHeader(\"Origin\");\n+        if (origin == null) {\n+            origin = pReq.getHeader(\"Referer\");\n+        }\n+        return origin != null ? origin.replaceAll(\"[\\\\n\\\\r]*\",\"\") : null;\n+    }\n+\n+\n     // Update the agent URL in the agent details if not already done\n     private void updateAgentUrlIfNeeded(HttpServletRequest pReq) {\n         // Lookup the Agent URL if needed"
        },
        {
          "filename": "agent/core/src/main/java/org/jolokia/http/HttpRequestHandler.java",
          "status": "modified",
          "additions": 8,
          "deletions": 4,
          "patch": "@@ -153,7 +153,7 @@ public JSONAware handlePostRequest(String pUri, InputStream pInputStream, String\n      */\n     public Map<String, String> handleCorsPreflightRequest(String pOrigin, String pRequestHeaders) {\n         Map<String,String> ret = new HashMap<String, String>();\n-        if (pOrigin != null && backendManager.isCorsAccessAllowed(pOrigin)) {\n+        if (pOrigin != null && backendManager.isOriginAllowed(pOrigin,false)) {\n             // CORS is allowed, we set exactly the origin in the header, so there are no problems with authentication\n             ret.put(\"Access-Control-Allow-Origin\",\"null\".equals(pOrigin) ? \"*\" : pOrigin);\n             if (pRequestHeaders != null) {\n@@ -277,15 +277,19 @@ public JSONObject getErrorJSON(int pErrorCode, Throwable pExp, JmxRequest pJmxRe\n      *\n      * @param pHost host to check\n      * @param pAddress address to check\n+     * @param pOrigin (optional) origin header to check also.\n      */\n-    public void checkClientIPAccess(String pHost, String pAddress) {\n+    public void checkAccess(String pHost, String pAddress, String pOrigin) {\n         if (!backendManager.isRemoteAccessAllowed(pHost,pAddress)) {\n             throw new SecurityException(\"No access from client \" + pAddress + \" allowed\");\n         }\n+        if (pOrigin != null && !backendManager.isOriginAllowed(pOrigin,true)) {\n+            throw new SecurityException(\"Origin \" + pOrigin + \" is not allowed to call this agent\");\n+        }\n     }\n \n     /**\n-     * Check whether for the given host is a cross-browser request allowed. This check is deligated to the\n+     * Check whether for the given host is a cross-browser request allowed. This check is delegated to the\n      * backendmanager which is responsible for the security configuration.\n      * Also, some sanity checks are applied.\n      *\n@@ -296,7 +300,7 @@ public String extractCorsOrigin(String pOrigin) {\n         if (pOrigin != null) {\n             // Prevent HTTP response splitting attacks\n             String origin  = pOrigin.replaceAll(\"[\\\\n\\\\r]*\",\"\");\n-            if (backendManager.isCorsAccessAllowed(origin)) {\n+            if (backendManager.isOriginAllowed(origin,false)) {\n                 return \"null\".equals(origin) ? \"*\" : origin;\n             } else {\n                 return null;"
        },
        {
          "filename": "agent/core/src/main/java/org/jolokia/restrictor/AbstractConstantRestrictor.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -73,7 +73,7 @@ public final boolean isRemoteAccessAllowed(String... pHostOrAddress) {\n     }\n \n     /** {@inheritDoc} */\n-    public boolean isCorsAccessAllowed(String pOrigin) {\n+    public boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck) {\n         return isAllowed;\n     }\n }"
        },
        {
          "filename": "agent/core/src/main/java/org/jolokia/restrictor/PolicyRestrictor.java",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -99,8 +99,8 @@ public boolean isRemoteAccessAllowed(String ... pHostOrAddress) {\n     }\n \n     /** {@inheritDoc} */\n-    public boolean isCorsAccessAllowed(String pOrigin) {\n-        return corsChecker.check(pOrigin);\n+    public boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck) {\n+        return corsChecker.check(pOrigin,pIsStrictCheck);\n     }\n \n     /** {@inheritDoc} */"
        },
        {
          "filename": "agent/core/src/main/java/org/jolokia/restrictor/Restrictor.java",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -90,8 +90,9 @@ public interface Restrictor {\n      * <a href=\"https://developer.mozilla.org/en/http_access_control\">CORS</a> specification\n      * for details\n      *\n-     * @param pOrigin the \"Origin:\" URL provided within the request\n+     * @param pOrigin the \"Origin:\" header provided within the request\n+     * @param pIsStrictCheck whether doing a strict check\n      * @return true if this cross browser request allowed, false otherwise\n      */\n-    boolean isCorsAccessAllowed(String pOrigin);\n+    boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck);\n }"
        },
        {
          "filename": "agent/core/src/main/java/org/jolokia/restrictor/policy/CorsChecker.java",
          "status": "modified",
          "additions": 23,
          "deletions": 5,
          "patch": "@@ -30,6 +30,8 @@\n  */\n public class CorsChecker extends AbstractChecker<String> {\n \n+    private boolean strictChecking = false;\n+\n     private List<Pattern> patterns;\n \n     /**\n@@ -39,6 +41,8 @@ public class CorsChecker extends AbstractChecker<String> {\n      *     &lt;cors&gt;\n      *       &lt;allow-origin&gt;http://jolokia.org&lt;allow-origin&gt;\n      *       &lt;allow-origin&gt;*://*.jmx4perl.org&gt;\n+     *\n+     *       &lt;strict-checking/&gt;\n      *     &lt;/cors&gt;\n      * </pre>\n      *\n@@ -56,10 +60,14 @@ public CorsChecker(Document pDoc) {\n                     if (node.getNodeType() != Node.ELEMENT_NODE) {\n                         continue;\n                     }\n-                    assertNodeName(node,\"allow-origin\");\n-                    String p = node.getTextContent().trim().toLowerCase();\n-                    p = Pattern.quote(p).replace(\"*\",\"\\\\E.*\\\\Q\");\n-                    patterns.add(Pattern.compile(\"^\" + p + \"$\"));\n+                    assertNodeName(node,\"allow-origin\",\"strict-checking\");\n+                    if (node.getNodeName().equals(\"allow-origin\")) {\n+                        String p = node.getTextContent().trim().toLowerCase();\n+                        p = Pattern.quote(p).replace(\"*\", \"\\\\E.*\\\\Q\");\n+                        patterns.add(Pattern.compile(\"^\" + p + \"$\"));\n+                    } else if (node.getNodeName().equals(\"strict-checking\")) {\n+                        strictChecking = true;\n+                    }\n                 }\n             }\n         }\n@@ -68,11 +76,21 @@ public CorsChecker(Document pDoc) {\n     /** {@inheritDoc} */\n     @Override\n     public boolean check(String pArg) {\n+        return check(pArg,false);\n+    }\n+\n+    public boolean check(String pOrigin, boolean pIsStrictCheck) {\n+        // Method called during strict checking but we have not configured that\n+        // So the check passes always.\n+        if (pIsStrictCheck && !strictChecking) {\n+            return true;\n+        }\n+\n         if (patterns == null || patterns.size() == 0) {\n             return true;\n         }\n         for (Pattern pattern : patterns) {\n-            if (pattern.matcher(pArg).matches()) {\n+            if (pattern.matcher(pOrigin).matches()) {\n                 return true;\n             }\n         }"
        },
        {
          "filename": "agent/core/src/test/java/org/jolokia/backend/BackendManagerTest.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -150,7 +150,7 @@ public void remoteAccessCheck() {\n     @Test\n     public void corsAccessCheck() {\n         BackendManager backendManager = new BackendManager(config,log);\n-        assertTrue(backendManager.isCorsAccessAllowed(\"http://bla.com\"));\n+        assertTrue(backendManager.isOriginAllowed(\"http://bla.com\",false));\n         backendManager.destroy();\n     }\n "
        },
        {
          "filename": "agent/core/src/test/java/org/jolokia/http/AgentServletTest.java",
          "status": "modified",
          "additions": 13,
          "deletions": 10,
          "patch": "@@ -125,8 +125,8 @@ public void initWithCustomLogHandler() throws Exception {\n         HttpTestUtil.prepareServletConfigMock(config, new String[]{ConfigKey.LOGHANDLER_CLASS.getKeyValue(), CustomLogHandler.class.getName()});\n         HttpTestUtil.prepareServletContextMock(context,null);\n \n-        expect(config.getServletContext()).andReturn(context).anyTimes();\n-        expect(config.getServletName()).andReturn(\"jolokia\").anyTimes();\n+        expect(config.getServletContext()).andStubReturn(context);\n+        expect(config.getServletName()).andStubReturn(\"jolokia\");\n         replay(config, context);\n \n         servlet.init(config);\n@@ -191,7 +191,7 @@ public void initWithAgentDiscoveryAndUrlCreationAfterGet() throws ServletExcepti\n             StringWriter sw = initRequestResponseMocks();\n             expect(request.getPathInfo()).andReturn(HttpTestUtil.HEAP_MEMORY_GET_REQUEST);\n             expect(request.getParameter(ConfigKey.MIME_TYPE.getKeyValue())).andReturn(\"text/plain\");\n-            String url = \"http://pirx:9876/jolokia\";\n+            String url = \"http://10.9.11.1:9876/jolokia\";\n             StringBuffer buf = new StringBuffer();\n             buf.append(url).append(HttpTestUtil.HEAP_MEMORY_GET_REQUEST);\n             expect(request.getRequestURL()).andReturn(buf);\n@@ -259,7 +259,8 @@ public void simpleGetWithUnsupportedGetParameterMapCall() throws ServletExceptio\n         StringWriter sw = initRequestResponseMocks(\n                 new Runnable() {\n                     public void run() {\n-                        expect(request.getHeader(\"Origin\")).andReturn(null);\n+                        expect(request.getHeader(\"Origin\")).andStubReturn(null);\n+                        expect(request.getHeader(\"Referer\")).andStubReturn(null);\n                         expect(request.getRemoteHost()).andReturn(\"localhost\");\n                         expect(request.getRemoteAddr()).andReturn(\"127.0.0.1\");\n                         expect(request.getRequestURI()).andReturn(\"/jolokia/\");\n@@ -368,7 +369,7 @@ private void checkCorsGetOrigin(final String in, final String out) throws Servle\n         StringWriter sw = initRequestResponseMocks(\n                 new Runnable() {\n                     public void run() {\n-                        expect(request.getHeader(\"Origin\")).andReturn(in);\n+                        expect(request.getHeader(\"Origin\")).andStubReturn(in);\n                         expect(request.getRemoteHost()).andReturn(\"localhost\");\n                         expect(request.getRemoteAddr()).andReturn(\"127.0.0.1\");\n                         expect(request.getRequestURI()).andReturn(\"/jolokia/\");\n@@ -464,8 +465,9 @@ public void debug() throws IOException, ServletException {\n         context.log(find(\"time:\"));\n         context.log(find(\"Response:\"));\n         context.log(find(\"TestDetector\"),isA(RuntimeException.class));\n-        expectLastCall().anyTimes();\n+        expectLastCall().asStub();\n         replay(config, context);\n+\n         servlet.init(config);\n \n         StringWriter sw = initRequestResponseMocks();\n@@ -503,8 +505,8 @@ private void initConfigMocks(String[] pInitParams, String[] pContextParams,Strin\n         HttpTestUtil.prepareServletContextMock(context, pContextParams);\n \n \n-        expect(config.getServletContext()).andReturn(context).anyTimes();\n-        expect(config.getServletName()).andReturn(\"jolokia\").anyTimes();\n+        expect(config.getServletContext()).andStubReturn(context);\n+        expect(config.getServletName()).andStubReturn(\"jolokia\");\n         if (pExceptionClass != null) {\n             context.log(find(pLogRegexp),isA(pExceptionClass));\n         } else {\n@@ -515,7 +517,7 @@ private void initConfigMocks(String[] pInitParams, String[] pContextParams,Strin\n             }\n         }\n         context.log((String) anyObject());\n-        expectLastCall().anyTimes();\n+        expectLastCall().asStub();\n         context.log(find(\"TestDetector\"),isA(RuntimeException.class));\n     }\n \n@@ -569,7 +571,8 @@ public void run() {\n     private Runnable getStandardRequestSetup() {\n         return new Runnable() {\n             public void run() {\n-                expect(request.getHeader(\"Origin\")).andReturn(null);\n+                expect(request.getHeader(\"Origin\")).andStubReturn(null);\n+                expect(request.getHeader(\"Referer\")).andStubReturn(null);\n                 expect(request.getRemoteHost()).andReturn(\"localhost\");\n                 expect(request.getRemoteAddr()).andReturn(\"127.0.0.1\");\n                 expect(request.getRequestURI()).andReturn(\"/jolokia/\");"
        },
        {
          "filename": "agent/core/src/test/java/org/jolokia/http/HttpRequestHandlerTest.java",
          "status": "modified",
          "additions": 14,
          "deletions": 4,
          "patch": "@@ -65,17 +65,27 @@ public void accessAllowed() {\n         expect(backend.isRemoteAccessAllowed(\"localhost\",\"127.0.0.1\")).andReturn(true);\n         replay(backend);\n \n-        handler.checkClientIPAccess(\"localhost\",\"127.0.0.1\");\n+        handler.checkAccess(\"localhost\", \"127.0.0.1\",null);\n     }\n \n     @Test(expectedExceptions = { SecurityException.class })\n     public void accessDenied() {\n         expect(backend.isRemoteAccessAllowed(\"localhost\",\"127.0.0.1\")).andReturn(false);\n         replay(backend);\n \n-        handler.checkClientIPAccess(\"localhost\",\"127.0.0.1\");\n+        handler.checkAccess(\"localhost\", \"127.0.0.1\",null);\n     }\n \n+    @Test(expectedExceptions = { SecurityException.class })\n+    public void accessDeniedViaOrigin() {\n+        expect(backend.isRemoteAccessAllowed(\"localhost\",\"127.0.0.1\")).andReturn(true);\n+        expect(backend.isOriginAllowed(\"www.jolokia.org\",true)).andReturn(false);\n+        replay(backend);\n+\n+        handler.checkAccess(\"localhost\", \"127.0.0.1\",\"www.jolokia.org\");\n+    }\n+\n+\n     @Test\n     public void get() throws InstanceNotFoundException, IOException, ReflectionException, AttributeNotFoundException, MBeanException {\n         JSONObject resp = new JSONObject();\n@@ -152,7 +162,7 @@ public void doublePost() throws IOException, InstanceNotFoundException, Reflecti\n     public void preflightCheck() {\n         String origin = \"http://bla.com\";\n         String headers =\"X-Data: Test\";\n-        expect(backend.isCorsAccessAllowed(origin)).andReturn(true);\n+        expect(backend.isOriginAllowed(origin,false)).andReturn(true);\n         replay(backend);\n \n         Map<String,String> ret =  handler.handleCorsPreflightRequest(origin, headers);\n@@ -163,7 +173,7 @@ public void preflightCheck() {\n     public void preflightCheckNegative() {\n         String origin = \"http://bla.com\";\n         String headers =\"X-Data: Test\";\n-        expect(backend.isCorsAccessAllowed(origin)).andReturn(false);\n+        expect(backend.isOriginAllowed(origin,false)).andReturn(false);\n         replay(backend);\n \n         Map<String,String> ret =  handler.handleCorsPreflightRequest(origin, headers);"
        },
        {
          "filename": "agent/core/src/test/java/org/jolokia/restrictor/PolicyBasedRestrictorTest.java",
          "status": "modified",
          "additions": 25,
          "deletions": 12,
          "patch": "@@ -222,42 +222,55 @@ public void illegalHttpMethodTag() {\n \n     @Test\n     public void cors() {\n+        InputStream is = getClass().getResourceAsStream(\"/allow-origin4.xml\");\n+        PolicyRestrictor restrictor = new PolicyRestrictor(is);\n+\n+        for (boolean strict : new boolean[] {true, false}) {\n+            assertTrue(restrictor.isOriginAllowed(\"http://bla.com\", strict));\n+            assertFalse(restrictor.isOriginAllowed(\"http://www.jolokia.org\", strict));\n+            assertTrue(restrictor.isOriginAllowed(\"https://www.consol.de\", strict));\n+        }\n+    }\n+\n+    @Test\n+    public void corsStrictCheckingOff() {\n         InputStream is = getClass().getResourceAsStream(\"/allow-origin1.xml\");\n         PolicyRestrictor restrictor = new PolicyRestrictor(is);\n \n-        assertTrue(restrictor.isCorsAccessAllowed(\"http://bla.com\"));\n-        assertFalse(restrictor.isCorsAccessAllowed(\"http://www.jolokia.org\"));\n-        assertTrue(restrictor.isCorsAccessAllowed(\"https://www.consol.de\"));\n+        // Allways true since we want a strict check but strict checking is off.\n+        assertTrue(restrictor.isOriginAllowed(\"http://bla.com\", true));\n+        assertTrue(restrictor.isOriginAllowed(\"http://www.jolokia.org\", true));\n+        assertTrue(restrictor.isOriginAllowed(\"https://www.consol.de\", true));\n     }\n \n     @Test\n     public void corsWildCard() {\n         InputStream is = getClass().getResourceAsStream(\"/allow-origin2.xml\");\n         PolicyRestrictor restrictor = new PolicyRestrictor(is);\n \n-        assertTrue(restrictor.isCorsAccessAllowed(\"http://bla.com\"));\n-        assertTrue(restrictor.isCorsAccessAllowed(\"http://www.jolokia.org\"));\n-        assertTrue(restrictor.isCorsAccessAllowed(\"http://www.consol.de\"));\n+        assertTrue(restrictor.isOriginAllowed(\"http://bla.com\", false));\n+        assertTrue(restrictor.isOriginAllowed(\"http://www.jolokia.org\", false));\n+        assertTrue(restrictor.isOriginAllowed(\"http://www.consol.de\", false));\n     }\n \n     @Test\n     public void corsEmpty() {\n         InputStream is = getClass().getResourceAsStream(\"/allow-origin3.xml\");\n         PolicyRestrictor restrictor = new PolicyRestrictor(is);\n \n-        assertTrue(restrictor.isCorsAccessAllowed(\"http://bla.com\"));\n-        assertTrue(restrictor.isCorsAccessAllowed(\"http://www.jolokia.org\"));\n-        assertTrue(restrictor.isCorsAccessAllowed(\"http://www.consol.de\"));\n+        assertTrue(restrictor.isOriginAllowed(\"http://bla.com\", false));\n+        assertTrue(restrictor.isOriginAllowed(\"http://www.jolokia.org\", false));\n+        assertTrue(restrictor.isOriginAllowed(\"http://www.consol.de\", false));\n     }\n \n     @Test\n     public void corsNoTags() {\n         InputStream is = getClass().getResourceAsStream(\"/access-sample1.xml\");\n         PolicyRestrictor restrictor = new PolicyRestrictor(is);\n \n-        assertTrue(restrictor.isCorsAccessAllowed(\"http://bla.com\"));\n-        assertTrue(restrictor.isCorsAccessAllowed(\"http://www.jolokia.org\"));\n-        assertTrue(restrictor.isCorsAccessAllowed(\"https://www.consol.de\"));\n+        assertTrue(restrictor.isOriginAllowed(\"http://bla.com\", false));\n+        assertTrue(restrictor.isOriginAllowed(\"http://www.jolokia.org\", false));\n+        assertTrue(restrictor.isOriginAllowed(\"https://www.consol.de\", false));\n     }\n \n "
        },
        {
          "filename": "agent/core/src/test/resources/allow-origin2.xml",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -20,6 +20,7 @@\n \n   <cors>\n     <allow-origin>*</allow-origin>\n+\n   </cors>\n \n </restrict>"
        },
        {
          "filename": "agent/core/src/test/resources/allow-origin4.xml",
          "status": "added",
          "additions": 27,
          "deletions": 0,
          "patch": "@@ -0,0 +1,27 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  ~ Copyright 2009-2013 Roland Huss\n+  ~\n+  ~ Licensed under the Apache License, Version 2.0 (the \"License\");\n+  ~ you may not use this file except in compliance with the License.\n+  ~ You may obtain a copy of the License at\n+  ~\n+  ~       http://www.apache.org/licenses/LICENSE-2.0\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing, software\n+  ~ distributed under the License is distributed on an \"AS IS\" BASIS,\n+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  ~ See the License for the specific language governing permissions and\n+  ~ limitations under the License.\n+  -->\n+\n+<restrict>\n+\n+  <cors>\n+    <allow-origin>http://bla.com</allow-origin>\n+    <allow-origin>http://blub.com</allow-origin>\n+    <allow-origin>*://*.consol.de</allow-origin>\n+    <strict-checking/>\n+  </cors>\n+</restrict>"
        },
        {
          "filename": "agent/jvm/src/main/java/org/jolokia/jvmagent/JolokiaHttpHandler.java",
          "status": "modified",
          "additions": 13,
          "deletions": 2,
          "patch": "@@ -165,7 +165,8 @@ public void handle(HttpExchange pExchange) throws IOException {\n         try {\n             // Check access policy\n             InetSocketAddress address = pExchange.getRemoteAddress();\n-            requestHandler.checkClientIPAccess(address.getHostName(),address.getAddress().getHostAddress());\n+            requestHandler.checkAccess(address.getHostName(), address.getAddress().getHostAddress(),\n+                                       extractOriginOrReferer(pExchange));\n             String method = pExchange.getRequestMethod();\n \n             // Dispatch for the proper HTTP request method\n@@ -190,7 +191,6 @@ public void handle(HttpExchange pExchange) throws IOException {\n \n     // ========================================================================\n \n-\n     private Restrictor createRestrictor(Configuration pConfig) {\n         String location = pConfig.get(ConfigKey.POLICY_LOCATION);\n         try {\n@@ -209,6 +209,17 @@ private Restrictor createRestrictor(Configuration pConfig) {\n         }\n     }\n \n+\n+    // Used for checking origin or referer is an origin policy is enabled\n+    private String extractOriginOrReferer(HttpExchange pExchange) {\n+        Headers headers = pExchange.getRequestHeaders();\n+        String origin = headers.getFirst(\"Origin\");\n+        if (origin == null) {\n+            origin = headers.getFirst(\"Referer\");\n+        }\n+        return origin != null ? origin.replaceAll(\"[\\\\n\\\\r]*\",\"\") : null;\n+    }\n+\n     private JSONAware executeGetRequest(ParsedUri parsedUri) {\n         return requestHandler.handleGetRequest(parsedUri.getUri().toString(),parsedUri.getPathInfo(), parsedUri.getParameterMap());\n     }"
        },
        {
          "filename": "agent/osgi/src/main/java/org/jolokia/osgi/DelegatingRestrictor.java",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -166,13 +166,13 @@ public boolean isRemoteAccessAllowed(String... pHostOrAddress) {\n     private static final RestrictorCheck CORS_CHECK = new RestrictorCheck() {\n         /** {@inheritDoc} */\n         public boolean check(Restrictor restrictor, Object... args) {\n-            return restrictor.isCorsAccessAllowed((String) args[0]);\n+            return restrictor.isOriginAllowed((String) args[0], (Boolean) args[1]);\n         }\n     };\n \n     /** {@inheritDoc} */\n-    public boolean isCorsAccessAllowed(String pOrigin) {\n-        return checkRestrictorService(CORS_CHECK,pOrigin);\n+    public boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck) {\n+        return checkRestrictorService(CORS_CHECK,pOrigin,pIsStrictCheck);\n     }\n \n     // ======================================================================================================="
        },
        {
          "filename": "agent/osgi/src/test/java/org/jolokia/osgi/DelegatingRestrictorTest.java",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -83,7 +83,7 @@ public void withRestrictor() throws InvalidSyntaxException, MalformedObjectNameE\n         assertFalse(restrictor.isAttributeWriteAllowed(new ObjectName(\"java.lang:type=Memory\"), \"HeapMemoryUsage\"));\n         assertTrue(restrictor.isOperationAllowed(new ObjectName(\"java.lang:type=Memory\"), \"gc\"));\n         assertFalse(restrictor.isRemoteAccessAllowed(\"localhost\", \"127.0.0.1\"));\n-        assertTrue(restrictor.isCorsAccessAllowed(\"http://bla.com\"));\n+        assertTrue(restrictor.isOriginAllowed(\"http://bla.com\", false));\n     }\n \n     @Test(expectedExceptions = IllegalArgumentException.class,expectedExceptionsMessageRegExp = \".*Impossible.*\")\n@@ -132,7 +132,7 @@ public boolean isRemoteAccessAllowed(String... pHostOrAddress) {\n             return remote;\n         }\n \n-        public boolean isCorsAccessAllowed(String pOrigin) {\n+        public boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck) {\n             return cors;\n         }\n     }"
        },
        {
          "filename": "src/changes/changes.xml",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -24,6 +24,10 @@\n   </properties>\n   <body>\n     <release version=\"1.2.1\" description=\"Release 1.2.1\" date=\"2014-02-24\">\n+      <action dev=\"roland\" type=\"add\" date=\"2014-04-24\">\n+        Added \"strict-checking\" for jolokia-access.xml in the CORS\n+        section in order to enable server side origin checking, too.\n+      </action>\n       <action dev=\"roland\" type=\"fix\" date=\"2014-04-10\" issue=\"123\">\n         Fixed issue with JBoss 4.2.3 and JNDI lookups\n       </action>"
        },
        {
          "filename": "src/docbkx/security.xml",
          "status": "modified",
          "additions": 11,
          "deletions": 2,
          "patch": "@@ -212,16 +212,25 @@\n           <literal>Origin:</literal> header literally or a\n           wildcard specification with <literal>*</literal>.          \n         </para>\n-      </section>\n-      <programlisting language=\"xml\"><![CDATA[\n+        <programlisting language=\"xml\"><![CDATA[\n <cors>\n    <!-- Allow cross origin access from www.jolokia.org ... -->\n    <allow-origin>http://www.jolokia.org</allow-origin>\n \n    <!-- ... and all servers from jmx4perl.org with any protocol ->\n    <allow-origin>*://*.jmx4perl.org</allow-origin>\n+\n+   <!-- Check for the proper origin on the server side, too -->\n+   <strict-checking/>\n </cors>\n ]]></programlisting>\n+        <para>\n+          If the option <literal>&lt;strict-checking/&gt;</literal> is given in this section, too, then the given pattern\n+          are not only used for CORS checking but also every request ist checked on th server side whether the\n+          <literal>Origin:</literal> or <literal>Referer:</literal> header matches one of the given patterns.\n+          This useful for protecting against Cross-Site Request Forgery.\n+        </para>\n+      </section>\n       <section>\n         <title>Example for a security policy</title>\n         <para>"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 7,
        "unique_directories": 13,
        "max_directory_depth": 9
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "83f090377798aefec3773a6e4e9a18c73b674438",
            "date": "2025-01-14T10:54:56Z",
            "author_login": "grgrzybek"
          },
          {
            "sha": "f368d58475462731416df929abd9b44f06b20fcb",
            "date": "2025-01-14T09:23:12Z",
            "author_login": "grgrzybek"
          },
          {
            "sha": "86f1ed453c3e559a410b6587cf3d084eaf758a22",
            "date": "2025-01-14T08:44:11Z",
            "author_login": "grgrzybek"
          },
          {
            "sha": "4e62afe34cd8c5c6d17ec542cc4fe5199eee2476",
            "date": "2025-01-13T13:37:06Z",
            "author_login": "grgrzybek"
          },
          {
            "sha": "b456e7657caf1bcb26b59061409cabdc25356bd3",
            "date": "2025-01-13T09:19:44Z",
            "author_login": "grgrzybek"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-352",
    "description": "Cross-site request forgery (CSRF) vulnerability in Jolokia before 1.2.1 allows remote attackers to hijack the authentication of users for requests that execute MBeans methods via a crafted web page.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2014-10-06T14:55:08.250",
    "last_modified": "2024-11-21T02:01:32.430",
    "fix_date": "2014-04-10T08:22:57Z"
  },
  "references": [
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2014-1351.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/rhuss/jolokia/commit/2d9b168cfbbf5a6d16fa6e8a5b34503e3dc42364",
      "source": "secalert@redhat.com",
      "tags": [
        "Exploit"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2014-1351.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/rhuss/jolokia/commit/2d9b168cfbbf5a6d16fa6e8a5b34503e3dc42364",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:27.931796",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "jolokia",
    "owner": "rhuss",
    "created_at": "2010-07-15T20:08:44Z",
    "updated_at": "2025-01-14T10:55:07Z",
    "pushed_at": "2025-01-14T10:55:03Z",
    "size": 28805,
    "stars": 820,
    "forks": 226,
    "open_issues": 83,
    "watchers": 820,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Java": 2710256,
      "TypeScript": 144067,
      "JavaScript": 121554,
      "CSS": 21160,
      "Shell": 7649,
      "Lex": 5787
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T20:14:22.286822"
  }
}