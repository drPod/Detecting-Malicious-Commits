{
  "cve_id": "CVE-2014-125071",
  "github_data": {
    "repository": "lukehutch/gribbit",
    "fix_commit": "620418df247aebda3dd4be1dda10fe229ea505dd",
    "related_commits": [
      "620418df247aebda3dd4be1dda10fe229ea505dd",
      "620418df247aebda3dd4be1dda10fe229ea505dd"
    ],
    "patch_url": "https://github.com/lukehutch/gribbit/commit/620418df247aebda3dd4be1dda10fe229ea505dd.patch",
    "fix_commit_details": {
      "sha": "620418df247aebda3dd4be1dda10fe229ea505dd",
      "commit_date": "2014-12-31T16:17:34Z",
      "author": {
        "login": "lukehutch",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Protect against CSWSH: (Cross-Site WebSocket Hijacking)",
        "length": 55,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 103,
        "additions": 91,
        "deletions": 12
      },
      "files": [
        {
          "filename": "src/gribbit/auth/Cookie.java",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -167,7 +167,9 @@ public io.netty.handler.codec.http.Cookie toNettyCookie() {\n         nettyCookie.setDiscard(discardAtEndOfBrowserSession);\n         nettyCookie.setHttpOnly(true);  // TODO\n         if (GribbitProperties.SSL) {\n-            nettyCookie.setSecure(true);  // TODO\n+            // If SSL is enabled, force cookies to only be delivered over SSL, to prevent cookie hijacking\n+            // on public wifi networks\n+            nettyCookie.setSecure(true);\n         }\n         return nettyCookie;\n     }"
        },
        {
          "filename": "src/gribbit/auth/User.java",
          "status": "modified",
          "additions": 6,
          "deletions": 1,
          "patch": "@@ -398,14 +398,19 @@ public void logIn(Response response) throws UnauthorizedException {\n \n             // Create new session token\n             sessionTok = new Token(TokenType.SESSION, Cookie.SESSION_COOKIE_MAX_AGE_SECONDS);\n+            \n+            // Create new random CSRF token every time user logs in\n             csrfTok = CSRF.generateRandomCSRFToken();\n-            save();\n+            \n             if (sessionTokHasExpired()) {\n                 // Shouldn't happen, since we just created session tok, but just in case\n                 clearSessionTok();\n                 throw new UnauthorizedException(\"Couldn't create auth session\");\n             }\n \n+            // Save tokens in database\n+            save();\n+\n             // Save login cookies in result\n             response.setCookie(new Cookie(Cookie.SESSION_COOKIE_NAME, \"/\", sessionTok.token,\n                     Cookie.SESSION_COOKIE_MAX_AGE_SECONDS));"
        },
        {
          "filename": "src/gribbit/request/HttpRequestHandler.java",
          "status": "modified",
          "additions": 78,
          "deletions": 8,
          "patch": "@@ -25,11 +25,10 @@\n  */\n package gribbit.request;\n \n-import static io.netty.handler.codec.http.HttpHeaderNames.CACHE_CONTROL;\n import static io.netty.handler.codec.http.HttpHeaderNames.ACCEPT_ENCODING;\n+import static io.netty.handler.codec.http.HttpHeaderNames.CACHE_CONTROL;\n import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;\n import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_ENCODING;\n-import static io.netty.handler.codec.http.HttpHeaderNames.SERVER;\n import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;\n import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;\n import static io.netty.handler.codec.http.HttpHeaderNames.DATE;\n@@ -38,9 +37,11 @@\n import static io.netty.handler.codec.http.HttpHeaderNames.EXPIRES;\n import static io.netty.handler.codec.http.HttpHeaderNames.LAST_MODIFIED;\n import static io.netty.handler.codec.http.HttpHeaderNames.PRAGMA;\n+import static io.netty.handler.codec.http.HttpHeaderNames.SERVER;\n import static io.netty.handler.codec.http.HttpHeaderNames.SET_COOKIE;\n import static io.netty.handler.codec.http.HttpHeaderValues.GZIP;\n import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\n+import gribbit.auth.CSRF;\n import gribbit.auth.Cookie;\n import gribbit.auth.User;\n import gribbit.response.ErrorResponse;\n@@ -109,6 +110,7 @@\n import java.io.RandomAccessFile;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n+import java.net.URI;\n import java.nio.charset.Charset;\n import java.time.Instant;\n import java.time.ZoneId;\n@@ -826,15 +828,83 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except\n             // Complete websocket handshake if requested\n             // ------------------------------------------------------------------------------\n \n+            // FIXME: Make these into class annotations\n+            String websocketPath = \"/websocket\";\n+            boolean isAuthenticatedWebsocket = true;\n+\n             if (response == null && authorizedRoute == null && msg instanceof HttpRequest\n-            // TODO: Read WS routes from class annotations\n-                    && reqURI.endsWith(\"/websocket\")) {\n+            // TODO: Read WS routes from class annotations, rather than using hardcoded \"/websocket\"\n+                    && reqURI.endsWith(websocketPath)) {\n                 HttpRequest httpReq = (HttpRequest) msg;\n \n-                // Record which user was authenticated (if any) when websocket upgrade request was made.\n-                // TODO: Reject WS upgrade request for websockets that require authentication.\n-                // TODO: Also provide a means for revoking WS login.\n-                wsAuthenticatedUser = User.getLoggedInUser(request);\n+                // Protect against CSWSH: (Cross-Site WebSocket Hijacking)\n+                // http://www.christian-schneider.net/CrossSiteWebSocketHijacking.html\n+                // http://tools.ietf.org/html/rfc6455#page-7\n+                CharSequence origin = request.getOrigin();\n+                URI originUri = null;\n+                if (origin != null && origin.length() > 0) {\n+                    try {\n+                        // Try parsing origin URI\n+                        originUri = new URI(origin.toString());\n+                    } catch (Exception e) {\n+                    }\n+                }\n+                // If port number is set but it is the default for the URI scheme, revert the port number\n+                // back to -1 (which means unspecified), so that it matches the server port number, \n+                // which is unspecified when serving http on port 80 and https on port 443\n+                int originPort = originUri == null ? -1 //\n+                        : originUri.getPort() == 80 && \"http\".equals(originUri.getScheme()) ? -1 //\n+                                : originUri.getPort() == 443 && \"https\".equals(originUri.getScheme()) ? -1 //\n+                                        : originUri.getPort();\n+                // Scheme, host and port all must match to forbid cross-origin requests\n+                if (originUri == null //\n+                        || !GribbitServer.uri.getScheme().equals(originUri.getScheme()) //\n+                        || !GribbitServer.uri.getHost().equals(originUri.getHost()) //\n+                        || GribbitServer.uri.getPort() != originPort) { //\n+                    // Reject scripted requests to open this websocket from a different domain\n+                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n+                            HttpResponseStatus.FORBIDDEN));\n+                    return;\n+                }\n+                // Log.info(\"Origin: \" + origin.toString());\n+\n+                if (isAuthenticatedWebsocket) {\n+                    // For authenticated websockets, check if the user is logged in\n+                    User loggedInUser = User.getLoggedInUser(request);\n+                    if (loggedInUser == null) {\n+                        // Not logged in, so can't connect to this websocket\n+                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n+                                HttpResponseStatus.FORBIDDEN));\n+                        return;\n+                    }\n+\n+                    // To further mitigate CSWSH attacks: check for the CSRF token in the URL parameter \"_csrf\";\n+                    // the passed token must match the user's CSRF token. This means the websocket URL has to\n+                    // be dynamically generated and inserted into the webpage that opened the websocket.\n+                    // TODO: generate this URL an insert into the page somehow\n+                    String csrfTok = loggedInUser.csrfTok;\n+                    if (csrfTok == null || csrfTok.isEmpty() || csrfTok.equals(CSRF.CSRF_TOKEN_UNKNOWN)\n+                            || csrfTok.equals(CSRF.CSRF_TOKEN_PLACEHOLDER)) {\n+                        // No valid CSRF token in User object\n+                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n+                                HttpResponseStatus.FORBIDDEN));\n+                        return;\n+                    }\n+                    String csrfParam = request.getQueryParam(\"_csrf\");\n+                    if (csrfParam == null || csrfParam.isEmpty() || !csrfParam.equals(csrfTok)) {\n+                        // The CSRF URL query parameter is missing, or doesn't match the user's token \n+                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n+                                HttpResponseStatus.FORBIDDEN));\n+                        return;                        \n+                    }\n+\n+                    // Record which user was authenticated when the websocket upgrade request was made.\n+                    // TODO: Also provide a means for revoking user's session while WS is still open,\n+                    // e.g. poll the user table every few seconds to see if user's session token has\n+                    // changed in the database? (Although this would mean that logging in on a new\n+                    // device would log you out of all other sessions...)\n+                    wsAuthenticatedUser = loggedInUser;\n+                }\n \n                 WebSocketServerHandshakerFactory wsFactory =\n                         new WebSocketServerHandshakerFactory(GribbitServer.wsUri.toString(), null, true);"
        },
        {
          "filename": "src/gribbit/request/Request.java",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -75,9 +75,11 @@ public class Request {\n     private Map<String, List<String>> queryParamToVals;\n \n     /**\n-     * Header for CORS.\n+     * Header for CORS, and for protecting against CSWSH. See:\n      * \n-     * See http://en.wikipedia.org/wiki/Cross-origin_resource_sharing\n+     * http://en.wikipedia.org/wiki/Cross-origin_resource_sharing\n+     * \n+     * http://www.christian-schneider.net/CrossSiteWebSocketHijacking.html\n      **/\n     private CharSequence origin;\n "
        }
      ],
      "file_patterns": {
        "security_files": 2,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "ceb56aacfa4115f8f4fdb2de63b01c0be2481fce",
            "date": "2016-03-08T10:46:39Z",
            "author_login": "lukehutch"
          },
          {
            "sha": "a18a69c50d0925f8cb07cefe4da066dc33059e27",
            "date": "2016-03-08T10:30:53Z",
            "author_login": "lukehutch"
          },
          {
            "sha": "8711703040c419f27e42c0526ccbea09f4428494",
            "date": "2016-03-08T10:30:04Z",
            "author_login": "lukehutch"
          },
          {
            "sha": "c51bc45d1990019eea6e94137f695074db5d7058",
            "date": "2016-03-08T10:07:30Z",
            "author_login": "lukehutch"
          },
          {
            "sha": "bba6781d2ea30a634c2dd9db069a938ddfc01d68",
            "date": "2016-03-08T09:05:04Z",
            "author_login": "lukehutch"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L",
    "cwe_id": "CWE-1385",
    "description": "A vulnerability was found in lukehutch Gribbit. It has been classified as problematic. Affected is the function messageReceived of the file src/gribbit/request/HttpRequestHandler.java. The manipulation leads to missing origin validation in websockets. The name of the patch is 620418df247aebda3dd4be1dda10fe229ea505dd. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-217716.",
    "attack_vector": "ADJACENT_NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-01-09T21:15:10.093",
    "last_modified": "2024-11-21T02:03:43.890",
    "fix_date": "2014-12-31T16:17:34Z"
  },
  "references": [
    {
      "url": "https://github.com/lukehutch/gribbit/commit/620418df247aebda3dd4be1dda10fe229ea505dd",
      "source": "cna@vuldb.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?ctiid.217716",
      "source": "cna@vuldb.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?id.217716",
      "source": "cna@vuldb.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/lukehutch/gribbit/commit/620418df247aebda3dd4be1dda10fe229ea505dd",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?ctiid.217716",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?id.217716",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:43.534555",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "gribbit",
    "owner": "lukehutch",
    "created_at": "2014-12-13T08:56:01Z",
    "updated_at": "2016-03-08T06:36:59Z",
    "pushed_at": "2016-03-08T10:46:41Z",
    "size": 1120,
    "stars": 0,
    "forks": 0,
    "open_issues": 0,
    "watchers": 0,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Java": 519045
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T17:53:21.566484"
  }
}