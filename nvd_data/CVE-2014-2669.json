{
  "cve_id": "CVE-2014-2669",
  "github_data": {
    "repository": "postgres/postgres",
    "fix_commit": "31400a673325147e1205326008e32135a78b4d8a",
    "related_commits": [
      "31400a673325147e1205326008e32135a78b4d8a",
      "31400a673325147e1205326008e32135a78b4d8a"
    ],
    "patch_url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a.patch",
    "fix_commit_details": {
      "sha": "31400a673325147e1205326008e32135a78b4d8a",
      "commit_date": "2014-02-17T14:33:31Z",
      "author": {
        "login": "nmisch",
        "type": "User",
        "stats": {
          "total_commits": 495,
          "average_weekly_commits": 0.33243787777031564,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 232
        }
      },
      "commit_message": {
        "title": "Predict integer overflow to avoid buffer overruns.",
        "length": 724,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 196,
        "additions": 177,
        "deletions": 19
      },
      "files": [
        {
          "filename": "contrib/hstore/hstore.h",
          "status": "modified",
          "additions": 12,
          "deletions": 3,
          "patch": "@@ -49,16 +49,25 @@ typedef struct\n } HStore;\n \n /*\n- * it's not possible to get more than 2^28 items into an hstore,\n- * so we reserve the top few bits of the size field. See hstore_compat.c\n- * for one reason why.\tSome bits are left for future use here.\n+ * It's not possible to get more than 2^28 items into an hstore, so we reserve\n+ * the top few bits of the size field.  See hstore_compat.c for one reason\n+ * why.  Some bits are left for future use here.  MaxAllocSize makes the\n+ * practical count limit slightly more than 2^28 / 3, or INT_MAX / 24, the\n+ * limit for an hstore full of 4-byte keys and null values.  Therefore, we\n+ * don't explicitly check the format-imposed limit.\n  */\n #define HS_FLAG_NEWVERSION 0x80000000\n \n #define HS_COUNT(hsp_) ((hsp_)->size_ & 0x0FFFFFFF)\n #define HS_SETCOUNT(hsp_,c_) ((hsp_)->size_ = (c_) | HS_FLAG_NEWVERSION)\n \n \n+/*\n+ * \"x\" comes from an existing HS_COUNT() (as discussed, <= INT_MAX/24) or a\n+ * Pairs array length (due to MaxAllocSize, <= INT_MAX/40).  \"lenstr\" is no\n+ * more than INT_MAX, that extreme case arising in hstore_from_arrays().\n+ * Therefore, this calculation is limited to about INT_MAX / 5 + INT_MAX.\n+ */\n #define HSHRDSIZE\t(sizeof(HStore))\n #define CALCDATASIZE(x, lenstr) ( (x) * 2 * sizeof(HEntry) + HSHRDSIZE + (lenstr) )\n "
        },
        {
          "filename": "contrib/hstore/hstore_io.c",
          "status": "modified",
          "additions": 21,
          "deletions": 0,
          "patch": "@@ -13,6 +13,7 @@\n #include \"utils/builtins.h\"\n #include \"utils/json.h\"\n #include \"utils/lsyscache.h\"\n+#include \"utils/memutils.h\"\n #include \"utils/typcache.h\"\n \n #include \"hstore.h\"\n@@ -439,6 +440,11 @@ hstore_recv(PG_FUNCTION_ARGS)\n \t\tPG_RETURN_POINTER(out);\n \t}\n \n+\tif (pcount < 0 || pcount > MaxAllocSize / sizeof(Pairs))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t pcount, (int) (MaxAllocSize / sizeof(Pairs)))));\n \tpairs = palloc(pcount * sizeof(Pairs));\n \n \tfor (i = 0; i < pcount; ++i)\n@@ -554,6 +560,13 @@ hstore_from_arrays(PG_FUNCTION_ARGS)\n \t\t\t\t\t  TEXTOID, -1, false, 'i',\n \t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n \n+\t/* see discussion in hstoreArrayToPairs() */\n+\tif (key_count > MaxAllocSize / sizeof(Pairs))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t key_count, (int) (MaxAllocSize / sizeof(Pairs)))));\n+\n \t/* value_array might be NULL */\n \n \tif (PG_ARGISNULL(1))\n@@ -676,6 +689,13 @@ hstore_from_array(PG_FUNCTION_ARGS)\n \n \tcount = in_count / 2;\n \n+\t/* see discussion in hstoreArrayToPairs() */\n+\tif (count > MaxAllocSize / sizeof(Pairs))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t count, (int) (MaxAllocSize / sizeof(Pairs)))));\n+\n \tpairs = palloc(count * sizeof(Pairs));\n \n \tfor (i = 0; i < count; ++i)\n@@ -807,6 +827,7 @@ hstore_from_record(PG_FUNCTION_ARGS)\n \t\tmy_extra->ncolumns = ncolumns;\n \t}\n \n+\tAssert(ncolumns <= MaxTupleAttributeNumber);\t\t/* thus, no overflow */\n \tpairs = palloc(ncolumns * sizeof(Pairs));\n \n \tif (rec)"
        },
        {
          "filename": "contrib/hstore/hstore_op.c",
          "status": "modified",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -8,6 +8,7 @@\n #include \"catalog/pg_type.h\"\n #include \"funcapi.h\"\n #include \"utils/builtins.h\"\n+#include \"utils/memutils.h\"\n \n #include \"hstore.h\"\n \n@@ -90,6 +91,19 @@ hstoreArrayToPairs(ArrayType *a, int *npairs)\n \t\treturn NULL;\n \t}\n \n+\t/*\n+\t * A text array uses at least eight bytes per element, so any overflow in\n+\t * \"key_count * sizeof(Pairs)\" is small enough for palloc() to catch.\n+\t * However, credible improvements to the array format could invalidate\n+\t * that assumption.  Therefore, use an explicit check rather than relying\n+\t * on palloc() to complain.\n+\t */\n+\tif (key_count > MaxAllocSize / sizeof(Pairs))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t key_count, (int) (MaxAllocSize / sizeof(Pairs)))));\n+\n \tkey_pairs = palloc(sizeof(Pairs) * key_count);\n \n \tfor (i = 0, j = 0; i < key_count; i++)\n@@ -648,6 +662,7 @@ hstore_slice_to_hstore(PG_FUNCTION_ARGS)\n \t\tPG_RETURN_POINTER(out);\n \t}\n \n+\t/* hstoreArrayToPairs() checked overflow */\n \tout_pairs = palloc(sizeof(Pairs) * nkeys);\n \tbufsiz = 0;\n "
        },
        {
          "filename": "contrib/intarray/_int.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -5,6 +5,7 @@\n #define ___INT_H__\n \n #include \"utils/array.h\"\n+#include \"utils/memutils.h\"\n \n /* number ranges for compression */\n #define MAXNUMRANGE 100\n@@ -137,6 +138,7 @@ typedef struct QUERYTYPE\n \n #define HDRSIZEQT\toffsetof(QUERYTYPE, items)\n #define COMPUTESIZE(size)\t( HDRSIZEQT + (size) * sizeof(ITEM) )\n+#define QUERYTYPEMAXITEMS\t((MaxAllocSize - HDRSIZEQT) / sizeof(ITEM))\n #define GETQUERY(x)  ( (x)->items )\n \n /* \"type\" codes for ITEM */"
        },
        {
          "filename": "contrib/intarray/_int_bool.c",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -448,6 +448,9 @@ boolop(PG_FUNCTION_ARGS)\n static void\n findoprnd(ITEM *ptr, int32 *pos)\n {\n+\t/* since this function recurses, it could be driven to stack overflow. */\n+\tcheck_stack_depth();\n+\n #ifdef BS_DEBUG\n \telog(DEBUG3, (ptr[*pos].type == OPR) ?\n \t\t \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);\n@@ -508,7 +511,13 @@ bqarr_in(PG_FUNCTION_ARGS)\n \t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n \t\t\t\t errmsg(\"empty query\")));\n \n+\tif (state.num > QUERYTYPEMAXITEMS)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\terrmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t   state.num, (int) QUERYTYPEMAXITEMS)));\n \tcommonlen = COMPUTESIZE(state.num);\n+\n \tquery = (QUERYTYPE *) palloc(commonlen);\n \tSET_VARSIZE(query, commonlen);\n \tquery->size = state.num;"
        },
        {
          "filename": "contrib/ltree/ltree.h",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -5,6 +5,7 @@\n \n #include \"fmgr.h\"\n #include \"tsearch/ts_locale.h\"\n+#include \"utils/memutils.h\"\n \n typedef struct\n {\n@@ -111,6 +112,8 @@ typedef struct\n \n #define HDRSIZEQT\t\tMAXALIGN(VARHDRSZ + sizeof(int32))\n #define COMPUTESIZE(size,lenofoperand)\t( HDRSIZEQT + (size) * sizeof(ITEM) + (lenofoperand) )\n+#define LTXTQUERY_TOO_BIG(size,lenofoperand) \\\n+\t((size) > (MaxAllocSize - HDRSIZEQT - (lenofoperand)) / sizeof(ITEM))\n #define GETQUERY(x)  (ITEM*)( (char*)(x)+HDRSIZEQT )\n #define GETOPERAND(x)\t( (char*)GETQUERY(x) + ((ltxtquery*)x)->size * sizeof(ITEM) )\n "
        },
        {
          "filename": "contrib/ltree/ltree_io.c",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -8,6 +8,7 @@\n #include <ctype.h>\n \n #include \"ltree.h\"\n+#include \"utils/memutils.h\"\n #include \"crc32.h\"\n \n PG_FUNCTION_INFO_V1(ltree_in);\n@@ -64,6 +65,11 @@ ltree_in(PG_FUNCTION_ARGS)\n \t\tptr += charlen;\n \t}\n \n+\tif (num + 1 > MaxAllocSize / sizeof(nodeitem))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\tnum + 1, (int) (MaxAllocSize / sizeof(nodeitem)))));\n \tlist = lptr = (nodeitem *) palloc(sizeof(nodeitem) * (num + 1));\n \tptr = buf;\n \twhile (*ptr)\n@@ -228,6 +234,11 @@ lquery_in(PG_FUNCTION_ARGS)\n \t}\n \n \tnum++;\n+\tif (num > MaxAllocSize / ITEMSIZE)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\tnum, (int) (MaxAllocSize / ITEMSIZE))));\n \tcurqlevel = tmpql = (lquery_level *) palloc0(ITEMSIZE * num);\n \tptr = buf;\n \twhile (*ptr)"
        },
        {
          "filename": "contrib/ltree/ltxtquery_io.c",
          "status": "modified",
          "additions": 12,
          "deletions": 1,
          "patch": "@@ -9,6 +9,7 @@\n \n #include \"crc32.h\"\n #include \"ltree.h\"\n+#include \"miscadmin.h\"\n \n PG_FUNCTION_INFO_V1(ltxtq_in);\n Datum\t\tltxtq_in(PG_FUNCTION_ARGS);\n@@ -212,6 +213,9 @@ makepol(QPRS_STATE *state)\n \tint32\t\tlenstack = 0;\n \tuint16\t\tflag = 0;\n \n+\t/* since this function recurses, it could be driven to stack overflow */\n+\tcheck_stack_depth();\n+\n \twhile ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)\n \t{\n \t\tswitch (type)\n@@ -276,6 +280,9 @@ makepol(QPRS_STATE *state)\n static void\n findoprnd(ITEM *ptr, int32 *pos)\n {\n+\t/* since this function recurses, it could be driven to stack overflow. */\n+\tcheck_stack_depth();\n+\n \tif (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)\n \t{\n \t\tptr[*pos].left = 0;\n@@ -340,8 +347,12 @@ queryin(char *buf)\n \t\t\t\t errmsg(\"syntax error\"),\n \t\t\t\t errdetail(\"Empty query.\")));\n \n-\t/* make finish struct */\n+\tif (LTXTQUERY_TOO_BIG(state.num, state.sumlen))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"ltxtquery is too large\")));\n \tcommonlen = COMPUTESIZE(state.num, state.sumlen);\n+\n \tquery = (ltxtquery *) palloc(commonlen);\n \tSET_VARSIZE(query, commonlen);\n \tquery->size = state.num;"
        },
        {
          "filename": "src/backend/utils/adt/geo_ops.c",
          "status": "modified",
          "additions": 28,
          "deletions": 2,
          "patch": "@@ -1366,6 +1366,7 @@ path_in(PG_FUNCTION_ARGS)\n \tchar\t   *s;\n \tint\t\t\tnpts;\n \tint\t\t\tsize;\n+\tint\t\t\tbase_size;\n \tint\t\t\tdepth = 0;\n \n \tif ((npts = pair_count(str, ',')) <= 0)\n@@ -1384,7 +1385,15 @@ path_in(PG_FUNCTION_ARGS)\n \t\tdepth++;\n \t}\n \n-\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;\n+\tbase_size = sizeof(path->p[0]) * npts;\n+\tsize = offsetof(PATH, p[0]) + base_size;\n+\n+\t/* Check for integer overflow */\n+\tif (base_size / npts != sizeof(path->p[0]) || size <= base_size)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"too many points requested\")));\n+\n \tpath = (PATH *) palloc(size);\n \n \tSET_VARSIZE(path, size);\n@@ -3429,6 +3438,7 @@ poly_in(PG_FUNCTION_ARGS)\n \tPOLYGON    *poly;\n \tint\t\t\tnpts;\n \tint\t\t\tsize;\n+\tint\t\t\tbase_size;\n \tint\t\t\tisopen;\n \tchar\t   *s;\n \n@@ -3437,7 +3447,15 @@ poly_in(PG_FUNCTION_ARGS)\n \t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n \t\t\t  errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));\n \n-\tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;\n+\tbase_size = sizeof(poly->p[0]) * npts;\n+\tsize = offsetof(POLYGON, p[0]) + base_size;\n+\n+\t/* Check for integer overflow */\n+\tif (base_size / npts != sizeof(poly->p[0]) || size <= base_size)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"too many points requested\")));\n+\n \tpoly = (POLYGON *) palloc0(size);\t/* zero any holes */\n \n \tSET_VARSIZE(poly, size);\n@@ -4343,6 +4361,10 @@ path_poly(PG_FUNCTION_ARGS)\n \t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n \t\t\t\t errmsg(\"open path cannot be converted to polygon\")));\n \n+\t/*\n+\t * Never overflows: the old size fit in MaxAllocSize, and the new size is\n+\t * just a small constant larger.\n+\t */\n \tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * path->npts;\n \tpoly = (POLYGON *) palloc(size);\n \n@@ -4448,6 +4470,10 @@ poly_path(PG_FUNCTION_ARGS)\n \tint\t\t\tsize;\n \tint\t\t\ti;\n \n+\t/*\n+\t * Never overflows: the old size fit in MaxAllocSize, and the new size is\n+\t * smaller by a small constant.\n+\t */\n \tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * poly->npts;\n \tpath = (PATH *) palloc(size);\n "
        },
        {
          "filename": "src/backend/utils/adt/tsquery.c",
          "status": "modified",
          "additions": 6,
          "deletions": 1,
          "patch": "@@ -514,8 +514,13 @@ parse_tsquery(char *buf,\n \t\treturn query;\n \t}\n \n-\t/* Pack the QueryItems in the final TSQuery struct to return to caller */\n+\tif (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"tsquery is too large\")));\n \tcommonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);\n+\n+\t/* Pack the QueryItems in the final TSQuery struct to return to caller */\n \tquery = (TSQuery) palloc0(commonlen);\n \tSET_VARSIZE(query, commonlen);\n \tquery->size = list_length(state.polstr);"
        },
        {
          "filename": "src/backend/utils/adt/tsquery_util.c",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -333,6 +333,11 @@ QTN2QT(QTNode *in)\n \tQTN2QTState state;\n \n \tcntsize(in, &sumlen, &nnode);\n+\n+\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"tsquery is too large\")));\n \tlen = COMPUTESIZE(nnode, sumlen);\n \n \tout = (TSQuery) palloc0(len);"
        },
        {
          "filename": "src/backend/utils/adt/txid.c",
          "status": "modified",
          "additions": 13,
          "deletions": 10,
          "patch": "@@ -26,7 +26,9 @@\n #include \"funcapi.h\"\n #include \"miscadmin.h\"\n #include \"libpq/pqformat.h\"\n+#include \"postmaster/postmaster.h\"\n #include \"utils/builtins.h\"\n+#include \"utils/memutils.h\"\n #include \"utils/snapmgr.h\"\n \n \n@@ -66,6 +68,8 @@ typedef struct\n \n #define TXID_SNAPSHOT_SIZE(nxip) \\\n \t(offsetof(TxidSnapshot, xip) + sizeof(txid) * (nxip))\n+#define TXID_SNAPSHOT_MAX_NXIP \\\n+\t((MaxAllocSize - offsetof(TxidSnapshot, xip)) / sizeof(txid))\n \n /*\n  * Epoch values from xact.c\n@@ -368,6 +372,13 @@ txid_current_snapshot(PG_FUNCTION_ARGS)\n \n \tload_xid_epoch(&state);\n \n+\t/*\n+\t * Compile-time limits on the procarray (MAX_BACKENDS processes plus\n+\t * MAX_BACKENDS prepared transactions) guarantee nxip won't be too large.\n+\t */\n+\tStaticAssertStmt(MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP,\n+\t\t\t\t\t \"possible overflow in txid_current_snapshot()\");\n+\n \t/* allocate */\n \tnxip = cur->xcnt;\n \tsize = TXID_SNAPSHOT_SIZE(nxip);\n@@ -445,20 +456,12 @@ txid_snapshot_recv(PG_FUNCTION_ARGS)\n \ttxid\t\tlast = 0;\n \tint\t\t\tnxip;\n \tint\t\t\ti;\n-\tint\t\t\tavail;\n-\tint\t\t\texpect;\n \ttxid\t\txmin,\n \t\t\t\txmax;\n \n-\t/*\n-\t * load nxip and check for nonsense.\n-\t *\n-\t * (nxip > avail) check is against int overflows in 'expect'.\n-\t */\n+\t/* load and validate nxip */\n \tnxip = pq_getmsgint(buf, 4);\n-\tavail = buf->len - buf->cursor;\n-\texpect = 8 + 8 + nxip * 8;\n-\tif (nxip < 0 || nxip > avail || expect > avail)\n+\tif (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)\n \t\tgoto bad_format;\n \n \txmin = pq_getmsgint64(buf);"
        },
        {
          "filename": "src/backend/utils/adt/varbit.c",
          "status": "modified",
          "additions": 30,
          "deletions": 2,
          "patch": "@@ -148,12 +148,22 @@ bit_in(PG_FUNCTION_ARGS)\n \t\tsp = input_string;\n \t}\n \n+\t/*\n+\t * Determine bitlength from input string.  MaxAllocSize ensures a regular\n+\t * input is small enough, but we must check hex input.\n+\t */\n \tslen = strlen(sp);\n-\t/* Determine bitlength from input string */\n \tif (bit_not_hex)\n \t\tbitlen = slen;\n \telse\n+\t{\n+\t\tif (slen > VARBITMAXLEN / 4)\n+\t\t\tereport(ERROR,\n+\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t\tVARBITMAXLEN)));\n \t\tbitlen = slen * 4;\n+\t}\n \n \t/*\n \t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n@@ -450,12 +460,22 @@ varbit_in(PG_FUNCTION_ARGS)\n \t\tsp = input_string;\n \t}\n \n+\t/*\n+\t * Determine bitlength from input string.  MaxAllocSize ensures a regular\n+\t * input is small enough, but we must check hex input.\n+\t */\n \tslen = strlen(sp);\n-\t/* Determine bitlength from input string */\n \tif (bit_not_hex)\n \t\tbitlen = slen;\n \telse\n+\t{\n+\t\tif (slen > VARBITMAXLEN / 4)\n+\t\t\tereport(ERROR,\n+\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t\tVARBITMAXLEN)));\n \t\tbitlen = slen * 4;\n+\t}\n \n \t/*\n \t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n@@ -535,6 +555,9 @@ varbit_in(PG_FUNCTION_ARGS)\n /*\n  * varbit_out -\n  *\t  Prints the string as bits to preserve length accurately\n+ *\n+ * XXX varbit_recv() and hex input to varbit_in() can load a value that this\n+ * cannot emit.  Consider using hex output for such values.\n  */\n Datum\n varbit_out(PG_FUNCTION_ARGS)\n@@ -944,6 +967,11 @@ bit_catenate(VarBit *arg1, VarBit *arg2)\n \tbitlen1 = VARBITLEN(arg1);\n \tbitlen2 = VARBITLEN(arg2);\n \n+\tif (bitlen1 > VARBITMAXLEN - bitlen2)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t\tVARBITMAXLEN)));\n \tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);\n \n \tresult = (VarBit *) palloc(bytelen);"
        },
        {
          "filename": "src/include/tsearch/ts_type.h",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -13,6 +13,7 @@\n #define _PG_TSTYPE_H_\n \n #include \"fmgr.h\"\n+#include \"utils/memutils.h\"\n #include \"utils/pg_crc.h\"\n \n \n@@ -244,6 +245,8 @@ typedef TSQueryData *TSQuery;\n  * QueryItems, and lenofoperand is the total length of all operands\n  */\n #define COMPUTESIZE(size, lenofoperand) ( HDRSIZETQ + (size) * sizeof(QueryItem) + (lenofoperand) )\n+#define TSQUERY_TOO_BIG(size, lenofoperand) \\\n+\t((size) > (MaxAllocSize - HDRSIZETQ - (lenofoperand)) / sizeof(QueryItem))\n \n /* Returns a pointer to the first QueryItem in a TSQuery */\n #define GETQUERY(x)  ((QueryItem*)( (char*)(x)+HDRSIZETQ ))"
        },
        {
          "filename": "src/include/utils/varbit.h",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -15,6 +15,8 @@\n #ifndef VARBIT_H\n #define VARBIT_H\n \n+#include <limits.h>\n+\n #include \"fmgr.h\"\n \n /*\n@@ -53,6 +55,11 @@ typedef struct\n /* Number of bytes needed to store a bit string of a given length */\n #define VARBITTOTALLEN(BITLEN)\t(((BITLEN) + BITS_PER_BYTE-1)/BITS_PER_BYTE + \\\n \t\t\t\t\t\t\t\t VARHDRSZ + VARBITHDRSZ)\n+/*\n+ * Maximum number of bits.  Several code sites assume no overflow from\n+ * computing bitlen + X; VARBITTOTALLEN() has the largest such X.\n+ */\n+#define VARBITMAXLEN\t\t(INT_MAX - BITS_PER_BYTE + 1)\n /* pointer beyond the end of the bit string (like end() in STL containers) */\n #define VARBITEND(PTR)\t\t(((bits8 *) (PTR)) + VARSIZE(PTR))\n /* Mask that will cover exactly one byte, i.e. BITS_PER_BYTE bits */"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 6,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "00f4c2959d631c7851da21a512885d1deab28649",
            "date": "2025-01-14T16:29:15Z",
            "author_login": "deanrasheed"
          },
          {
            "sha": "94b914f601bd15829df6f83c0246342ca92630b1",
            "date": "2025-01-14T16:23:02Z",
            "author_login": "MasaoFujii"
          },
          {
            "sha": "4cb560b53f8f9e9a94d593f9416c107ed8202110",
            "date": "2025-01-14T13:50:54Z",
            "author_login": "deanrasheed"
          },
          {
            "sha": "2355e51110e7c687c125a5958f12a462931de996",
            "date": "2025-01-14T13:23:24Z",
            "author_login": "deanrasheed"
          },
          {
            "sha": "af8cd1639ab298ba8fae62cd9583f1c10a5068e1",
            "date": "2025-01-14T12:28:49Z",
            "author_login": "hlinnaka"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-189",
    "description": "Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2014-03-31T14:58:19.600",
    "last_modified": "2024-11-21T02:06:45.403",
    "fix_date": "2014-02-17T14:33:31Z"
  },
  "references": [
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2014-0221.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2014-0469.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://wiki.postgresql.org/wiki/20140220securityrelease",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.debian.org/security/2014/dsa-2864",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2014/dsa-2865",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.postgresql.org/about/news/1506/",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.postgresql.org/support/security/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2014-0221.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2014-0469.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://wiki.postgresql.org/wiki/20140220securityrelease",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.debian.org/security/2014/dsa-2864",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2014/dsa-2865",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.postgresql.org/about/news/1506/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.postgresql.org/support/security/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:22.578028",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "postgres",
    "owner": "postgres",
    "created_at": "2010-09-21T11:35:45Z",
    "updated_at": "2025-01-14T12:23:23Z",
    "pushed_at": "2025-01-14T06:28:38Z",
    "size": 608320,
    "stars": 16634,
    "forks": 4693,
    "open_issues": 1,
    "watchers": 16634,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 47031174,
      "PLpgSQL": 3927896,
      "Perl": 2290426,
      "Yacc": 697711,
      "Makefile": 362302,
      "Meson": 359391,
      "Python": 270469,
      "Lex": 229520,
      "M4": 185355,
      "Ruby": 164128,
      "Shell": 75722,
      "C++": 55705,
      "PLSQL": 55013,
      "Roff": 17748,
      "XS": 6998,
      "Emacs Lisp": 4164,
      "DTrace": 3452,
      "Assembly": 2468,
      "Starlark": 1640,
      "sed": 581
    },
    "commit_activity": {
      "total_commits_last_year": 2526,
      "avg_commits_per_week": 48.57692307692308,
      "days_active_last_year": 333
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:07:40.608433"
  }
}