{
  "cve_id": "CVE-2014-2829",
  "github_data": {
    "repository": "esl/MongooseIM",
    "fix_commit": "586d96cc12ef218243a3466354b4d208b5472a6c",
    "related_commits": [
      "586d96cc12ef218243a3466354b4d208b5472a6c",
      "586d96cc12ef218243a3466354b4d208b5472a6c"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "586d96cc12ef218243a3466354b4d208b5472a6c",
      "commit_date": "2014-04-09T13:05:37Z",
      "author": {
        "login": "michalwski",
        "type": "User",
        "stats": {
          "total_commits": 2381,
          "average_weekly_commits": 2.0543572044866263,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 250
        }
      },
      "commit_message": {
        "title": "Merge pull request #167 from esl/zlib_cwe400_fix",
        "length": 83,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 252,
        "additions": 141,
        "deletions": 111
      },
      "files": [
        {
          "filename": "apps/ejabberd/c_src/ejabberd_zlib_drv.c",
          "status": "modified",
          "additions": 79,
          "deletions": 72,
          "patch": "@@ -109,79 +109,86 @@ static void ejabberd_zlib_drv_stop(ErlDrvData handle)\n \n \n static ErlDrvSSizeT ejabberd_zlib_drv_control(ErlDrvData handle,\n-\t\t\t\t     unsigned int command,\n-\t\t\t\t     char *buf, ErlDrvSizeT len,\n-\t\t\t\t     char **rbuf, ErlDrvSizeT rlen)\n+        unsigned int command,\n+        char *buf, ErlDrvSizeT len,\n+        char **rbuf, ErlDrvSizeT rlen)\n {\n-   ejabberd_zlib_data *d = (ejabberd_zlib_data *)handle;\n-   int err;\n-   int size;\n-   ErlDrvBinary *b;\n-\n-   switch (command)\n-   {\n-      case DEFLATE:\n-\t size = BUF_SIZE + 1;\n-\t rlen = 1;\n-\t b = driver_alloc_binary(size);\n-\t b->orig_bytes[0] = 0;\n-\n-\t d->d_stream->next_in = (unsigned char *)buf;\n-\t d->d_stream->avail_in = len;\n-\t d->d_stream->avail_out = 0;\n-\t err = Z_OK;\n-\n-\t while (err == Z_OK && d->d_stream->avail_out == 0)\n-\t {\n-\t    d->d_stream->next_out = (unsigned char *)b->orig_bytes + rlen;\n-\t    d->d_stream->avail_out = BUF_SIZE;\n-\n-\t    err = deflate(d->d_stream, Z_SYNC_FLUSH);\n-\t    die_unless((err == Z_OK) || (err == Z_STREAM_END),\n-\t\t       \"Deflate error\");\n-\n-\t    rlen += (BUF_SIZE - d->d_stream->avail_out);\n-\t    size += (BUF_SIZE - d->d_stream->avail_out);\n-\t    b = driver_realloc_binary(b, size);\n-\t }\n-\t b = driver_realloc_binary(b, rlen);\n-\t *rbuf = (char *)b;\n-\t return rlen;\n-      case INFLATE:\n-\t size = BUF_SIZE + 1;\n-\t rlen = 1;\n-\t b = driver_alloc_binary(size);\n-\t b->orig_bytes[0] = 0;\n-\n-\t if (len > 0) {\n-\t    d->i_stream->next_in = (unsigned char *)buf;\n-\t    d->i_stream->avail_in = len;\n-\t    d->i_stream->avail_out = 0;\n-\t    err = Z_OK;\n-\n-\t    while (err == Z_OK && d->i_stream->avail_out == 0)\n-\t    {\n-\t       d->i_stream->next_out = (unsigned char *)b->orig_bytes + rlen;\n-\t       d->i_stream->avail_out = BUF_SIZE;\n-\n-\t       err = inflate(d->i_stream, Z_SYNC_FLUSH);\n-\t       die_unless((err == Z_OK) || (err == Z_STREAM_END),\n-\t\t\t  \"Inflate error\");\n-\n-\t       rlen += (BUF_SIZE - d->i_stream->avail_out);\n-\t       size += (BUF_SIZE - d->i_stream->avail_out);\n-\t       b = driver_realloc_binary(b, size);\n-\t    }\n-\t }\n-\t b = driver_realloc_binary(b, rlen);\n-\t *rbuf = (char *)b;\n-\t return rlen;\n-   }\n-\n-   b = driver_alloc_binary(1);\n-   b->orig_bytes[0] = 0;\n-   *rbuf = (char *)b;\n-   return 1;\n+    ejabberd_zlib_data *d = (ejabberd_zlib_data *)handle;\n+    int err;\n+    int size;\n+    int size_limit;\n+    ErlDrvBinary *b;\n+\n+    // operation is in command's 2 lower bits and size_limit is in bits higher than 1\n+    size_limit = command >> 2; // applies only to inflation\n+    command = command & 3;\n+    switch (command)\n+    {\n+        case DEFLATE:\n+            size = BUF_SIZE + 1;\n+            rlen = 1;\n+            b = driver_alloc_binary(size);\n+            b->orig_bytes[0] = 0;\n+\n+            d->d_stream->next_in = (unsigned char *)buf;\n+            d->d_stream->avail_in = len;\n+            d->d_stream->avail_out = 0;\n+            err = Z_OK;\n+\n+            while (err == Z_OK && d->d_stream->avail_out == 0)\n+            {\n+                d->d_stream->next_out = (unsigned char *)b->orig_bytes + rlen;\n+                d->d_stream->avail_out = BUF_SIZE;\n+\n+                err = deflate(d->d_stream, Z_SYNC_FLUSH);\n+                die_unless((err == Z_OK) || (err == Z_STREAM_END),\n+                        \"deflate_error\");\n+\n+                rlen += (BUF_SIZE - d->d_stream->avail_out);\n+                size += (BUF_SIZE - d->d_stream->avail_out);\n+                b = driver_realloc_binary(b, size);\n+            }\n+            b = driver_realloc_binary(b, rlen);\n+            *rbuf = (char *)b;\n+            return rlen;\n+        case INFLATE:\n+            size = BUF_SIZE + 1;\n+            rlen = 1;\n+            b = driver_alloc_binary(size);\n+            b->orig_bytes[0] = 0;\n+\n+            if (len > 0) {\n+                d->i_stream->next_in = (unsigned char *)buf;\n+                d->i_stream->avail_in = len;\n+                d->i_stream->avail_out = 0;\n+                err = Z_OK;\n+\n+                while (err == Z_OK && d->i_stream->avail_out == 0)\n+                {\n+                    d->i_stream->next_out = (unsigned char *)b->orig_bytes + rlen;\n+                    d->i_stream->avail_out = BUF_SIZE;\n+\n+                    err = inflate(d->i_stream, Z_SYNC_FLUSH);\n+                    die_unless((err == Z_OK) || (err == Z_STREAM_END),\n+                            \"inflate_error\");\n+\n+                    rlen += (BUF_SIZE - d->i_stream->avail_out);\n+                    die_unless((rlen < size_limit) || (size_limit == 0),\n+                            \"inflate_size_exceeded\");\n+\n+                    size += (BUF_SIZE - d->i_stream->avail_out);\n+                    b = driver_realloc_binary(b, size);\n+                }\n+            }\n+            b = driver_realloc_binary(b, rlen);\n+            *rbuf = (char *)b;\n+            return rlen;\n+    }\n+\n+    b = driver_alloc_binary(1);\n+    b->orig_bytes[0] = 0;\n+    *rbuf = (char *)b;\n+    return 1;\n }\n \n "
        },
        {
          "filename": "apps/ejabberd/src/ejabberd_c2s.erl",
          "status": "modified",
          "additions": 20,
          "deletions": 18,
          "patch": "@@ -80,7 +80,7 @@\n \t\tsasl_state,\n \t\taccess,\n \t\tshaper,\n-\t\tzlib = false,\n+\t\tzlib = {false, 0},\n \t\ttls = false,\n \t\ttls_required = false,\n \t\ttls_enabled = false,\n@@ -161,8 +161,8 @@ get_presence(FsmRef) ->\n     ?GEN_FSM:sync_send_all_state_event(FsmRef, get_presence, 1000).\n \n get_aux_field(Key, #state{aux_fields = Opts}) ->\n-    case lists:keysearch(Key, 1, Opts) of\n-\t{value, {_, Val}} ->\n+    case lists:keyfind(Key, 1, Opts) of\n+\t{_, Val} ->\n \t    {ok, Val};\n \t_ ->\n \t    error\n@@ -208,20 +208,23 @@ stop(FsmRef) ->\n %%          {stop, StopReason}\n %%----------------------------------------------------------------------\n init([{SockMod, Socket}, Opts]) ->\n-    Access = case lists:keysearch(access, 1, Opts) of\n-\t\t {value, {_, A}} -> A;\n+    Access = case lists:keyfind(access, 1, Opts) of\n+\t\t {_, A} -> A;\n \t\t _ -> all\n \t     end,\n-    Shaper = case lists:keysearch(shaper, 1, Opts) of\n-\t\t {value, {_, S}} -> S;\n+    Shaper = case lists:keyfind(shaper, 1, Opts) of\n+\t\t {_, S} -> S;\n \t\t _ -> none\n \t     end,\n     XMLSocket =\n-\tcase lists:keysearch(xml_socket, 1, Opts) of\n-\t    {value, {_, XS}} -> XS;\n+\tcase lists:keyfind(xml_socket, 1, Opts) of\n+\t    {_, XS} -> XS;\n \t    _ -> false\n \tend,\n-    Zlib = lists:member(zlib, Opts),\n+    Zlib = case lists:keyfind(zlib, 1, Opts) of\n+               {_, ZlibLimit} -> {true, ZlibLimit};\n+               _ -> {false, 0}\n+           end,\n     StartTLS = lists:member(starttls, Opts),\n     StartTLSRequired = lists:member(starttls_required, Opts),\n     TLSEnabled = lists:member(tls, Opts),\n@@ -328,7 +331,7 @@ wait_for_stream({xmlstreamstart, _Name, Attrs}, StateData) ->\n \t\t    SockMod =\n \t\t\t (StateData#state.sockmod):get_sockmod(\n \t\t\t   StateData#state.socket),\n-\t\t    Zlib = StateData#state.zlib,\n+\t\t    {Zlib, _} = StateData#state.zlib,\n \t\t    CompressFeature =\n \t\t\tcase Zlib andalso\n \t\t\t      ((SockMod == gen_tcp) orelse\n@@ -469,8 +472,7 @@ wait_for_stream(closed, StateData) ->\n wait_for_auth({xmlstreamelement, El}, StateData) ->\n     case is_auth_packet(El) of\n \t{auth, _ID, get, {U, _, _, _}} ->\n-\t    XE = #xmlel{name = Name,\n-                        attrs = Attrs} = jlib:make_result_iq_reply(El),\n+\t    XE = jlib:make_result_iq_reply(El),\n \t    case U of\n \t\t<<>> ->\n \t\t    UCdata = [];\n@@ -613,7 +615,7 @@ wait_for_auth(closed, StateData) ->\n \n wait_for_feature_request({xmlstreamelement, El}, StateData) ->\n     #xmlel{name = Name, attrs = Attrs, children = Els} = El,\n-    Zlib = StateData#state.zlib,\n+    {Zlib, ZlibLimit} = StateData#state.zlib,\n     TLS = StateData#state.tls,\n     TLSEnabled = StateData#state.tls_enabled,\n     TLSRequired = StateData#state.tls_required,\n@@ -705,7 +707,7 @@ wait_for_feature_request({xmlstreamelement, El}, StateData) ->\n \t\t\t<<\"zlib\">> ->\n \t\t\t    Socket = StateData#state.socket,\n \t\t\t    ZlibSocket = (StateData#state.sockmod):compress(\n-\t\t\t\t\t   Socket,\n+\t\t\t\t\t   Socket, ZlibLimit,\n \t\t\t\t\t   xml:element_to_binary(\n \t\t\t\t\t      #xmlel{name = <<\"compressed\">>,\n \t\t\t\t\t             attrs = [{<<\"xmlns\">>, ?NS_COMPRESS}]})),\n@@ -979,7 +981,7 @@ session_established({xmlstreamend, _Name}, StateData) ->\n     send_trailer(StateData),\n     {stop, normal, StateData};\n \n-session_established({xmlstreamerror, \"XML stanza is too big\" = E}, StateData) ->\n+session_established({xmlstreamerror, <<\"XML stanza is too big\">> = E}, StateData) ->\n     send_element(StateData, ?POLICY_VIOLATION_ERR(StateData#state.lang, E)),\n     send_trailer(StateData),\n     {stop, normal, StateData};\n@@ -2217,8 +2219,8 @@ check_from(El, FromJID) ->\n     end.\n \n fsm_limit_opts(Opts) ->\n-    case lists:keysearch(max_fsm_queue, 1, Opts) of\n-\t{value, {_, N}} when is_integer(N) ->\n+    case lists:keyfind(max_fsm_queue, 1, Opts) of\n+\t{_, N} when is_integer(N) ->\n \t    [{max_queue, N}];\n \t_ ->\n \t    case ejabberd_config:get_local_option(max_fsm_queue) of"
        },
        {
          "filename": "apps/ejabberd/src/ejabberd_receiver.erl",
          "status": "modified",
          "additions": 10,
          "deletions": 2,
          "patch": "@@ -56,6 +56,7 @@\n \t\ttimeout}).\n \n -define(HIBERNATE_TIMEOUT, 90000).\n+-define(GEN_FSM, p1_fsm).\n \n %%====================================================================\n %% API\n@@ -160,7 +161,10 @@ handle_call({compress, ZlibSocket}, _From,\n     case ejabberd_zlib:recv_data(ZlibSocket, \"\") of\n \t{ok, ZlibData} ->\n \t    {reply, ok, process_data(ZlibData, NewState), ?HIBERNATE_TIMEOUT};\n-\t{error, _Reason} ->\n+\t{error, inflate_size_exceeded} ->\n+\t    ?GEN_FSM:send_event(C2SPid, {xmlstreamerror, <<\"XML stanza is too big\">>}),\n+\t    {reply, ok, NewState, ?HIBERNATE_TIMEOUT};\n+\t{error, inflate_error} ->\n \t    {stop, normal, ok, NewState}\n     end;\n handle_call(reset_stream, _From,\n@@ -205,6 +209,7 @@ handle_cast(_Msg, State) ->\n %%--------------------------------------------------------------------\n handle_info({Tag, _TCPSocket, Data},\n \t    #state{socket = Socket,\n+\t\t   c2s_pid = C2SPid,\n \t\t   sock_mod = SockMod} = State)\n   when (Tag == tcp) or (Tag == ssl) or (Tag == ejabberd_xml) ->\n     case SockMod of\n@@ -221,7 +226,10 @@ handle_info({Tag, _TCPSocket, Data},\n \t\t{ok, ZlibData} ->\n \t\t    {noreply, process_data(ZlibData, State),\n \t\t     ?HIBERNATE_TIMEOUT};\n-\t\t{error, _Reason} ->\n+\t\t{error, inflate_size_exceeded} ->\n+\t\t    ?GEN_FSM:send_event(C2SPid, {xmlstreamerror, <<\"XML stanza is too big\">>}),\n+\t\t    {noreply, State, ?HIBERNATE_TIMEOUT};\n+\t\t{error, inflate_error} ->\n \t\t    {stop, normal, State}\n \t    end;\n \t_ ->"
        },
        {
          "filename": "apps/ejabberd/src/ejabberd_socket.erl",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -34,7 +34,7 @@\n \t starttls/2,\n \t starttls/3,\n \t compress/1,\n-\t compress/2,\n+\t compress/3,\n \t reset_stream/1,\n \t send/2,\n \t send_xml/2,\n@@ -152,10 +152,11 @@ compress(SocketData) ->\n     ejabberd_receiver:compress(SocketData#socket_state.receiver, ZlibSocket),\n     SocketData#socket_state{socket = ZlibSocket, sockmod = ejabberd_zlib}.\n \n-compress(SocketData, Data) ->\n+compress(SocketData, InflateSizeLimit, Data) ->\n     {ok, ZlibSocket} = ejabberd_zlib:enable_zlib(\n \t\t\t SocketData#socket_state.sockmod,\n-\t\t\t SocketData#socket_state.socket),\n+\t\t\t SocketData#socket_state.socket,\n+\t\t\t InflateSizeLimit),\n     ejabberd_receiver:compress(SocketData#socket_state.receiver, ZlibSocket),\n     send(SocketData, Data),\n     SocketData#socket_state{socket = ZlibSocket, sockmod = ejabberd_zlib}."
        },
        {
          "filename": "apps/ejabberd/src/ejabberd_zlib.erl",
          "status": "modified",
          "additions": 11,
          "deletions": 8,
          "patch": "@@ -30,7 +30,7 @@\n -behaviour(gen_server).\n \n -export([start/0, start_link/0,\n-\t enable_zlib/2, disable_zlib/1,\n+\t enable_zlib/3, disable_zlib/1,\n \t send/2,\n \t recv/2, recv/3, recv_data/2,\n \t setopts/2,\n@@ -50,7 +50,7 @@\n -define(DEFLATE, 1).\n -define(INFLATE, 2).\n \n--record(zlibsock, {sockmod, socket, zlibport}).\n+-record(zlibsock, {sockmod, socket, zlibport, inflate_size_limit = 0}).\n \n start() ->\n     gen_server:start({local, ?MODULE}, ?MODULE, [], []).\n@@ -94,13 +94,14 @@ terminate(_Reason, Port) ->\n     ok.\n \n \n-enable_zlib(SockMod, Socket) ->\n+enable_zlib(SockMod, Socket, InflateSizeLimit) ->\n     case erl_ddll:load_driver(ejabberd:get_so_path(), ejabberd_zlib_drv) of\n \tok -> ok;\n \t{error, already_loaded} -> ok\n     end,\n     Port = open_port({spawn, ejabberd_zlib_drv}, [binary]),\n-    {ok, #zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port}}.\n+    {ok, #zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port,\n+                   inflate_size_limit = InflateSizeLimit}}.\n \n disable_zlib(#zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port}) ->\n     port_close(Port),\n@@ -138,12 +139,12 @@ recv_data2(ZlibSock, Packet) ->\n \t    Res\n     end.\n \n-recv_data1(#zlibsock{zlibport = Port} = _ZlibSock, Packet) ->\n-    case port_control(Port, ?INFLATE, Packet) of\n+recv_data1(#zlibsock{zlibport = Port, inflate_size_limit = SizeLimit} = _ZlibSock, Packet) ->\n+    case port_control(Port, SizeLimit bsl 2 + ?INFLATE, Packet) of\n \t<<0, In/binary>> ->\n \t    {ok, In};\n \t<<1, Error/binary>> ->\n-\t    {error, binary_to_list(Error)}\n+\t    {error, erlang:binary_to_existing_atom(Error, utf8)}\n     end.\n \n send(#zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port},\n@@ -152,7 +153,9 @@ send(#zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port},\n \t<<0, Out/binary>> ->\n \t    SockMod:send(Socket, Out);\n \t<<1, Error/binary>> ->\n-\t    {error, binary_to_list(Error)}\n+\t    {error, erlang:binary_to_existing_atom(Error, utf8)};\n+\t_ ->\n+\t    {error, deflate_error}\n     end.\n \n "
        },
        {
          "filename": "apps/ejabberd/src/mod_bosh_socket.erl",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -18,7 +18,7 @@\n \n %% ejabberd_socket compatibility\n -export([starttls/2, starttls/3,\n-         compress/1, compress/2,\n+         compress/1, compress/3,\n          reset_stream/1,\n          send/2,\n          send_xml/2,\n@@ -823,9 +823,9 @@ starttls(_SocketData, _TLSOpts, _Data) ->\n \n %% Should be negotiated on HTTP level.\n compress(SocketData) ->\n-    compress(SocketData, <<>>).\n+    compress(SocketData, <<>>, 0).\n \n-compress(_SocketData, _Data) ->\n+compress(_SocketData, _Data, _InflateSizeLimit) ->\n     throw({error, negotiate_compression_on_http_level}).\n \n %% TODO: adjust for BOSH"
        },
        {
          "filename": "apps/ejabberd/src/mod_websockets.erl",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -25,7 +25,7 @@\n \n %% ejabberd_socket compatibility\n -export([starttls/2, starttls/3,\n-         compress/1, compress/2,\n+         compress/1, compress/3,\n          reset_stream/1,\n          send/2,\n          send_xml/2,\n@@ -229,9 +229,9 @@ starttls(_SocketData, _TLSOpts, _Data) ->\n     throw({error, tls_not_allowed_on_websockets}).\n \n compress(SocketData) ->\n-    compress(SocketData, <<>>).\n+    compress(SocketData, <<>>, 0).\n \n-compress(_SocketData, _Data) ->\n+compress(_SocketData, _Data, _InflateSizeLimit) ->\n     throw({error, compression_not_allowed_on_websockets}).\n \n reset_stream(#websocket{pid = Pid} = SocketData) ->"
        },
        {
          "filename": "apps/ejabberd/src/xml_stream.erl",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -126,7 +126,7 @@ parse(#xml_stream_state{callback_pid = CallbackPid,\n     if\n \tNewSize > MaxSize ->\n \t    catch gen_fsm:send_event(CallbackPid,\n-\t\t\t\t     {xmlstreamerror, \"XML stanza is too big\"});\n+\t\t\t\t     {xmlstreamerror, <<\"XML stanza is too big\">>});\n \ttrue ->\n \t    ok\n     end,"
        },
        {
          "filename": "rel/files/ejabberd.cfg",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -167,6 +167,8 @@\n \t\t\t{max_stanza_size, 65536}\n \t\t       ]},\n \n+  {{secondary_c2s}}\n+\n   %%\n   %% To enable the old SSL connection method on port 5223:\n   %%"
        },
        {
          "filename": "rel/reltool_vars/node1_vars.config",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -13,6 +13,13 @@\n {s2s_default_policy, allow}.\n {node_name, \"ejabberd@localhost\"}.\n {ejabberd_c2s_port, 5222}.\n+{secondary_c2s,\n+    \"{ 5223, ejabberd_c2s, [\n+    {zlib, 4096},\n+    {access, c2s},\n+        {shaper, c2s_shaper},\n+        {max_stanza_size, 65536}\n+    ]},\"}.\n {ejabberd_s2s_in_port, 5269}.\n {mod_last, \"{mod_last, []},\"}.\n {mod_offline, \"{mod_offline, [{access_max_user_messages, max_user_offline_messages}]},\"}."
        },
        {
          "filename": "rel/vars.config",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -31,4 +31,4 @@\n {ext_auth_script, \"%%{extauth_program, \\\"/path/to/authentication/script\\\"}.\"}.\n {tls_config, \"%%{certfile, \\\"/path/to/ssl.pem\\\"}, starttls,\"}.\n {wss_config, \"%%,{cert, \\\"priv/server.crt\\\"}, {key, \\\"priv/server.key\\\"}, {key_pass, \\\"\\\"}\"}. %% PEM format\n-{zlib, \"\"}.\n+{zlib, \"%%{zlib, 10000},\"}. %% Second element of a tuple is inflated data size limit; 0 for no limit"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 5,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "ce1b5f6e02195168c5bfa3f3907a153d9b6d8151",
            "date": "2025-01-22T15:14:39Z",
            "author_login": "telezynski"
          },
          {
            "sha": "45aeea3f6a8057b6f7268ba5f12fd8b674392901",
            "date": "2025-01-22T07:13:38Z",
            "author_login": "NelsonVides"
          },
          {
            "sha": "6acae7b42bc3400e0ea66ab634344fc9d779f18d",
            "date": "2025-01-21T19:12:24Z",
            "author_login": "NelsonVides"
          },
          {
            "sha": "83eb36ab42a92f200c6bc2c5f3d0345cf3263164",
            "date": "2025-01-21T09:43:33Z",
            "author_login": "DenysGonchar"
          },
          {
            "sha": "a48bb5105c1faec0788dc938ff122be528c73ca4",
            "date": "2025-01-21T05:17:49Z",
            "author_login": "arcusfelis"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-264",
    "description": "Erlang Solutions MongooseIM through 1.3.1 rev. 2 does not properly restrict the processing of compressed XML elements, which allows remote attackers to cause a denial of service (resource consumption) via a crafted XMPP stream, aka an \"xmppbomb\" attack.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2014-04-11T01:55:07.083",
    "last_modified": "2024-11-21T02:07:01.403",
    "fix_date": "2014-04-09T13:05:37Z"
  },
  "references": [
    {
      "url": "http://xmpp.org/resources/security-notices/uncontrolled-resource-consumption-with-highly-compressed-xmpp-stanzas/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/esl/MongooseIM/commit/586d96cc12ef218243a3466354b4d208b5472a6c",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Patch"
      ]
    },
    {
      "url": "http://xmpp.org/resources/security-notices/uncontrolled-resource-consumption-with-highly-compressed-xmpp-stanzas/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/esl/MongooseIM/commit/586d96cc12ef218243a3466354b4d208b5472a6c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:22.583463",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "MongooseIM",
    "owner": "esl",
    "created_at": "2011-09-09T08:19:18Z",
    "updated_at": "2025-01-24T05:49:52Z",
    "pushed_at": "2025-01-24T13:55:44Z",
    "size": 70180,
    "stars": 1676,
    "forks": 428,
    "open_issues": 76,
    "watchers": 1676,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Erlang": 8880874,
      "Shell": 173139,
      "TSQL": 23977,
      "JavaScript": 16877,
      "Python": 14808,
      "Makefile": 9638,
      "HTML": 5139,
      "Dockerfile": 4877,
      "Mustache": 2180,
      "PLpgSQL": 1300
    },
    "commit_activity": {
      "total_commits_last_year": 984,
      "avg_commits_per_week": 18.923076923076923,
      "days_active_last_year": 190
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T08:12:13.458475"
  }
}