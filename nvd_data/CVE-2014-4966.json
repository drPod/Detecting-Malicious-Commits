{
  "cve_id": "CVE-2014-4966",
  "github_data": {
    "repository": "ansible/ansible",
    "fix_commit": "62a1295a3e08cb6c3e9f1b2a1e6e5dcaeab32527",
    "related_commits": [
      "62a1295a3e08cb6c3e9f1b2a1e6e5dcaeab32527",
      "62a1295a3e08cb6c3e9f1b2a1e6e5dcaeab32527"
    ],
    "patch_url": "https://github.com/ansible/ansible/commit/62a1295a3e08cb6c3e9f1b2a1e6e5dcaeab32527.patch",
    "fix_commit_details": {
      "sha": "62a1295a3e08cb6c3e9f1b2a1e6e5dcaeab32527",
      "commit_date": "2014-07-21T02:48:31Z",
      "author": {
        "login": "jimi-c",
        "type": "User",
        "stats": {
          "total_commits": 2825,
          "average_weekly_commits": 4.178994082840236,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 212
        }
      },
      "commit_message": {
        "title": "Security fixes:",
        "length": 277,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 243,
        "additions": 178,
        "deletions": 65
      },
      "files": [
        {
          "filename": "lib/ansible/module_utils/basic.py",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -772,6 +772,8 @@ def _load_params(self):\n                 (k, v) = x.split(\"=\",1)\n             except Exception, e:\n                 self.fail_json(msg=\"this module requires key=value arguments (%s)\" % (items))\n+            if k in params:\n+                self.fail_json(msg=\"duplicate parameter: %s (value=%s)\" % (k, v))\n             params[k] = v\n         params2 = json.loads(MODULE_COMPLEX_ARGS)\n         params2.update(params)"
        },
        {
          "filename": "lib/ansible/runner/__init__.py",
          "status": "modified",
          "additions": 46,
          "deletions": 0,
          "patch": "@@ -31,6 +31,7 @@\n import pipes\n import jinja2\n import subprocess\n+import shlex\n import getpass\n \n import ansible.constants as C\n@@ -394,6 +395,35 @@ def _compute_delegate_user(self, host, inject):\n \n         return actual_user\n \n+    def _count_module_args(self, args):\n+        '''\n+        Count the number of k=v pairs in the supplied module args. This is\n+        basically a specialized version of parse_kv() from utils with a few\n+        minor changes.\n+        '''\n+        options = {}\n+        if args is not None:\n+            args = args.encode('utf-8')\n+            try:\n+                lexer = shlex.shlex(args, posix=True)\n+                lexer.whitespace_split = True\n+                lexer.quotes = '\"'\n+                lexer.ignore_quotes = \"'\"\n+                vargs = list(lexer)\n+            except ValueError, ve:\n+                if 'no closing quotation' in str(ve).lower():\n+                    raise errors.AnsibleError(\"error parsing argument string '%s', try quoting the entire line.\" % args)\n+                else:\n+                    raise\n+            vargs = [x.decode('utf-8') for x in vargs]\n+            for x in vargs:\n+                if \"=\" in x:\n+                    k, v = x.split(\"=\",1)\n+                    if k in options:\n+                        raise errors.AnsibleError(\"a duplicate parameter was found in the argument string (%s)\" % k)\n+                    options[k] = v\n+        return len(options)\n+\n \n     # *****************************************************\n \n@@ -612,6 +642,9 @@ def _executor_internal(self, host, new_stdin):\n             items_terms = self.module_vars.get('items_lookup_terms', '')\n             items_terms = template.template(basedir, items_terms, inject)\n             items = utils.plugins.lookup_loader.get(items_plugin, runner=self, basedir=basedir).run(items_terms, inject=inject)\n+            # strip out any jinja2 template syntax within\n+            # the data returned by the lookup plugin\n+            items = utils._clean_data_struct(items, from_remote=True)\n             if type(items) != list:\n                 raise errors.AnsibleError(\"lookup plugins have to return a list: %r\" % items)\n \n@@ -823,7 +856,20 @@ def _executor_internal_inner(self, host, module_name, module_args, inject, port,\n \n         # render module_args and complex_args templates\n         try:\n+            # When templating module_args, we need to be careful to ensure\n+            # that no variables inadvertantly (or maliciously) add params\n+            # to the list of args. We do this by counting the number of k=v\n+            # pairs before and after templating.\n+            num_args_pre = self._count_module_args(module_args)\n             module_args = template.template(self.basedir, module_args, inject, fail_on_undefined=self.error_on_undefined_vars)\n+            num_args_post = self._count_module_args(module_args)\n+            if num_args_pre != num_args_post:\n+                raise errors.AnsibleError(\"A variable inserted a new parameter into the module args. \" + \\\n+                                          \"Be sure to quote variables if they contain equal signs (for example: \\\"{{var}}\\\").\")\n+            # And we also make sure nothing added in special flags for things\n+            # like the command/shell module (ie. #USE_SHELL)\n+            if '#USE_SHELL' in module_args:\n+                raise errors.AnsibleError(\"A variable tried to add #USE_SHELL to the module arguments.\")\n             complex_args = template.template(self.basedir, complex_args, inject, fail_on_undefined=self.error_on_undefined_vars)\n         except jinja2.exceptions.UndefinedError, e:\n             raise errors.AnsibleUndefinedVariable(\"One or more undefined variables: %s\" % str(e))"
        },
        {
          "filename": "lib/ansible/runner/action_plugins/assemble.py",
          "status": "modified",
          "additions": 15,
          "deletions": 4,
          "patch": "@@ -122,14 +122,25 @@ def run(self, conn, tmp, module_name, module_args, inject, complex_args=None, **\n                 self.runner._low_level_exec_command(conn, \"chmod a+r %s\" % xfered, tmp)\n \n             # run the copy module\n-            module_args = \"%s src=%s dest=%s original_basename=%s\" % (module_args, pipes.quote(xfered), pipes.quote(dest), pipes.quote(os.path.basename(src)))\n+            new_module_args = dict(\n+                src=xfered,\n+                dest=dest,\n+                original_basename=os.path.basename(src),\n+            )\n+            module_args_tmp = utils.merge_module_args(module_args, new_module_args)\n \n             if self.runner.noop_on_check(inject):\n                 return ReturnData(conn=conn, comm_ok=True, result=dict(changed=True), diff=dict(before_header=dest, after_header=src, after=resultant))\n             else:\n-                res = self.runner._execute_module(conn, tmp, 'copy', module_args, inject=inject)\n+                res = self.runner._execute_module(conn, tmp, 'copy', module_args_tmp, inject=inject)\n                 res.diff = dict(after=resultant)\n                 return res\n         else:\n-            module_args = \"%s src=%s dest=%s original_basename=%s\" % (module_args, pipes.quote(xfered), pipes.quote(dest), pipes.quote(os.path.basename(src)))\n-            return self.runner._execute_module(conn, tmp, 'file', module_args, inject=inject)\n+            new_module_args = dict(\n+                src=xfered,\n+                dest=dest,\n+                original_basename=os.path.basename(src),\n+            )\n+            module_args_tmp = utils.merge_module_args(module_args, new_module_args)\n+\n+            return self.runner._execute_module(conn, tmp, 'file', module_args_tmp, inject=inject)"
        },
        {
          "filename": "lib/ansible/runner/action_plugins/copy.py",
          "status": "modified",
          "additions": 16,
          "deletions": 7,
          "patch": "@@ -238,11 +238,16 @@ def run(self, conn, tmp_path, module_name, module_args, inject, complex_args=Non\n \n                 # src and dest here come after original and override them\n                 # we pass dest only to make sure it includes trailing slash in case of recursive copy\n-                module_args_tmp = \"%s src=%s dest=%s original_basename=%s\" % (module_args,\n-                                  pipes.quote(tmp_src), pipes.quote(dest), pipes.quote(source_rel))\n+                new_module_args = dict(\n+                    src=tmp_src,\n+                    dest=dest,\n+                    original_basename=source_rel\n+                )\n \n                 if self.runner.no_log:\n-                    module_args_tmp = \"%s NO_LOG=True\" % module_args_tmp\n+                    new_module_args['NO_LOG'] = True\n+\n+                module_args_tmp = utils.merge_module_args(module_args, new_module_args)\n \n                 module_return = self.runner._execute_module(conn, tmp_path, 'copy', module_args_tmp, inject=inject, complex_args=complex_args, delete_remote_tmp=delete_remote_tmp)\n                 module_executed = True\n@@ -260,12 +265,16 @@ def run(self, conn, tmp_path, module_name, module_args, inject, complex_args=Non\n                 tmp_src = tmp_path + source_rel\n \n                 # Build temporary module_args.\n-                module_args_tmp = \"%s src=%s original_basename=%s\" % (module_args,\n-                                  pipes.quote(tmp_src), pipes.quote(source_rel))\n+                new_module_args = dict(\n+                    src=tmp_src,\n+                    dest=dest,\n+                )\n                 if self.runner.noop_on_check(inject):\n-                    module_args_tmp = \"%s CHECKMODE=True\" % module_args_tmp\n+                    new_module_args['CHECKMODE'] = True\n                 if self.runner.no_log:\n-                    module_args_tmp = \"%s NO_LOG=True\" % module_args_tmp\n+                    new_module_args['NO_LOG'] = True\n+\n+                module_args_tmp = utils.merge_module_args(module_args, new_module_args)\n \n                 # Execute the file module.\n                 module_return = self.runner._execute_module(conn, tmp_path, 'file', module_args_tmp, inject=inject, complex_args=complex_args, delete_remote_tmp=delete_remote_tmp)"
        },
        {
          "filename": "lib/ansible/runner/action_plugins/template.py",
          "status": "modified",
          "additions": 7,
          "deletions": 2,
          "patch": "@@ -117,12 +117,17 @@ def run(self, conn, tmp, module_name, module_args, inject, complex_args=None, **\n                 self.runner._low_level_exec_command(conn, \"chmod a+r %s\" % xfered, tmp)\n \n             # run the copy module\n-            module_args = \"%s src=%s dest=%s original_basename=%s\" % (module_args, pipes.quote(xfered), pipes.quote(dest), pipes.quote(os.path.basename(source)))\n+            new_module_args = dict(\n+               src=xfered,\n+               dest=dest,\n+               original_basename=os.path.basename(source),\n+            )\n+            module_args_tmp = utils.merge_module_args(module_args, new_module_args)\n \n             if self.runner.noop_on_check(inject):\n                 return ReturnData(conn=conn, comm_ok=True, result=dict(changed=True), diff=dict(before_header=dest, after_header=source, before=dest_contents, after=resultant))\n             else:\n-                res = self.runner._execute_module(conn, tmp, 'copy', module_args, inject=inject, complex_args=complex_args)\n+                res = self.runner._execute_module(conn, tmp, 'copy', module_args_tmp, inject=inject, complex_args=complex_args)\n                 if res.result.get('changed', False):\n                     res.diff = dict(before=dest_contents, after=resultant)\n                 return res"
        },
        {
          "filename": "lib/ansible/utils/__init__.py",
          "status": "modified",
          "additions": 48,
          "deletions": 14,
          "patch": "@@ -51,6 +51,10 @@\n \n MAX_FILE_SIZE_FOR_DIFF=1*1024*1024\n \n+# caching the compilation of the regex used\n+# to check for lookup calls within data\n+LOOKUP_REGEX=re.compile(r'lookup\\s*\\(')\n+\n try:\n     import json\n except ImportError:\n@@ -313,38 +317,44 @@ def json_loads(data):\n \n     return json.loads(data)\n \n-def _clean_data(orig_data):\n+def _clean_data(orig_data, from_remote=False, from_inventory=False):\n     ''' remove template tags from a string '''\n     data = orig_data\n     if isinstance(orig_data, basestring):\n-        for pattern,replacement in (('{{','{#'), ('}}','#}'), ('{%','{#'), ('%}','#}')):\n+        sub_list = [('{%','{#'), ('%}','#}')]\n+        if from_remote or (from_inventory and '{{' in data and LOOKUP_REGEX.search(data)):\n+            # if from a remote, we completely disable any jinja2 blocks\n+            sub_list.extend([('{{','{#'), ('}}','#}')])\n+        for pattern,replacement in sub_list:\n             data = data.replace(pattern, replacement)\n     return data\n \n-def _clean_data_struct(orig_data):\n+def _clean_data_struct(orig_data, from_remote=False, from_inventory=False):\n     '''\n     walk a complex data structure, and use _clean_data() to\n     remove any template tags that may exist\n     '''\n+    if not from_remote and not from_inventory:\n+        raise errors.AnsibleErrors(\"when cleaning data, you must specify either from_remote or from_inventory\")\n     if isinstance(orig_data, dict):\n         data = orig_data.copy()\n         for key in data:\n-            new_key = _clean_data_struct(key)\n-            new_val = _clean_data_struct(data[key])\n+            new_key = _clean_data_struct(key, from_remote, from_inventory)\n+            new_val = _clean_data_struct(data[key], from_remote, from_inventory)\n             if key != new_key:\n                 del data[key]\n             data[new_key] = new_val\n     elif isinstance(orig_data, list):\n         data = orig_data[:]\n         for i in range(0, len(data)):\n-            data[i] = _clean_data_struct(data[i])\n+            data[i] = _clean_data_struct(data[i], from_remote, from_inventory)\n     elif isinstance(orig_data, basestring):\n-        data = _clean_data(orig_data)\n+        data = _clean_data(orig_data, from_remote, from_inventory)\n     else:\n         data = orig_data\n     return data\n \n-def parse_json(raw_data, from_remote=False):\n+def parse_json(raw_data, from_remote=False, from_inventory=False):\n     ''' this version for module return data only '''\n \n     orig_data = raw_data\n@@ -379,10 +389,31 @@ def parse_json(raw_data, from_remote=False):\n             return { \"failed\" : True, \"parsed\" : False, \"msg\" : orig_data }\n \n     if from_remote:\n-        results = _clean_data_struct(results)\n+        results = _clean_data_struct(results, from_remote, from_inventory)\n \n     return results\n \n+def merge_module_args(current_args, new_args):\n+    '''\n+    merges either a dictionary or string of k=v pairs with another string of k=v pairs,\n+    and returns a new k=v string without duplicates.\n+    '''\n+    if not isinstance(current_args, basestring):\n+        raise errors.AnsibleError(\"expected current_args to be a basestring\")\n+    # we use parse_kv to split up the current args into a dictionary\n+    final_args = parse_kv(current_args)\n+    if isinstance(new_args, dict):\n+        final_args.update(new_args)\n+    elif isinstance(new_args, basestring):\n+        new_args_kv = parse_kv(new_args)\n+        final_args.update(new_args_kv)\n+    # then we re-assemble into a string\n+    module_args = \"\"\n+    for (k,v) in final_args.iteritems():\n+        if isinstance(v, basestring):\n+            module_args = \"%s=%s %s\" % (k, pipes.quote(v), module_args)\n+    return module_args.strip()\n+\n def smush_braces(data):\n     ''' smush Jinaj2 braces so unresolved templates like {{ foo }} don't get parsed weird by key=value code '''\n     while '{{ ' in data:\n@@ -615,7 +646,7 @@ def parse_kv(args):\n         for x in vargs:\n             if \"=\" in x:\n                 k, v = x.split(\"=\",1)\n-                options[k]=v\n+                options[k] = v\n     return options\n \n def merge_hash(a, b):\n@@ -1062,11 +1093,14 @@ def list_intersection(a, b):\n \n def safe_eval(expr, locals={}, include_exceptions=False):\n     '''\n-    this is intended for allowing things like:\n+    This is intended for allowing things like:\n     with_items: a_list_variable\n-    where Jinja2 would return a string\n-    but we do not want to allow it to call functions (outside of Jinja2, where\n-    the env is constrained)\n+\n+    Where Jinja2 would return a string but we do not want to allow it to\n+    call functions (outside of Jinja2, where the env is constrained). If\n+    the input data to this function came from an untrusted (remote) source,\n+    it should first be run through _clean_data_struct() to ensure the data\n+    is further sanitized prior to evaluation.\n \n     Based on:\n     http://stackoverflow.com/questions/12523516/using-ast-and-whitelists-to-make-pythons-eval-safe"
        },
        {
          "filename": "library/commands/command",
          "status": "modified",
          "additions": 34,
          "deletions": 27,
          "patch": "@@ -176,38 +176,45 @@ class CommandModule(AnsibleModule):\n         ''' read the input and return a dictionary and the arguments string '''\n         args = MODULE_ARGS\n         params = {}\n-        params['chdir'] = None\n-        params['creates'] = None\n-        params['removes'] = None\n-        params['shell'] = False\n+        params['chdir']      = None\n+        params['creates']    = None\n+        params['removes']    = None\n+        params['shell']      = False\n         params['executable'] = None\n         if \"#USE_SHELL\" in args:\n             args = args.replace(\"#USE_SHELL\", \"\")\n             params['shell'] = True\n \n-        r = re.compile(r'(^|\\s)(creates|removes|chdir|executable|NO_LOG)=(?P<quote>[\\'\"])?(.*?)(?(quote)(?<!\\\\)(?P=quote))((?<!\\\\)(?=\\s)|$)')\n-        for m in r.finditer(args):\n-            v = m.group(4).replace(\"\\\\\", \"\")\n-            if m.group(2) == \"creates\":\n-                params['creates'] = v\n-            elif m.group(2) == \"removes\":\n-                params['removes'] = v\n-            elif m.group(2) == \"chdir\":\n-                v = os.path.expanduser(v)\n-                v = os.path.abspath(v)\n-                if not (os.path.exists(v) and os.path.isdir(v)):\n-                    self.fail_json(rc=258, msg=\"cannot change to directory '%s': path does not exist\" % v)\n-                params['chdir'] = v\n-            elif m.group(2) == \"executable\":\n-                v = os.path.expanduser(v)\n-                v = os.path.abspath(v)\n-                if not (os.path.exists(v)):\n-                    self.fail_json(rc=258, msg=\"cannot use executable '%s': file does not exist\" % v)\n-                params['executable'] = v\n-            elif m.group(2) == \"NO_LOG\":\n-                params['NO_LOG'] = self.boolean(v)\n-        args = r.sub(\"\", args)\n-        params['args'] = args\n+        # use shlex to split up the args, while being careful to preserve\n+        # single quotes so they're not removed accidentally\n+        lexer = shlex.shlex(args, posix=True)\n+        lexer.whitespace_split = True\n+        lexer.quotes = '\"'\n+        lexer.ignore_quotes = \"'\"\n+        items = list(lexer)\n+\n+        command_args = ''\n+        for x in items:\n+            if '=' in x:\n+                # check to see if this is a special parameter for the command\n+                k, v = x.split('=', 1)\n+                if k in ('creates', 'removes', 'chdir', 'executable', 'NO_LOG'):\n+                    if k == \"chdir\":\n+                        v = os.path.abspath(os.path.expanduser(v))\n+                        if not (os.path.exists(v) and os.path.isdir(v)):\n+                            self.fail_json(rc=258, msg=\"cannot change to directory '%s': path does not exist\" % v)\n+                    elif k == \"executable\":\n+                        v = os.path.abspath(os.path.expanduser(v))\n+                        if not (os.path.exists(v)):\n+                            self.fail_json(rc=258, msg=\"cannot use executable '%s': file does not exist\" % v)\n+                    params[k] = v\n+                else:\n+                    # this isn't a valid parameter, so just append it back to the list of arguments\n+                    command_args = \"%s %s\" % (command_args, x)\n+            else:\n+                # not a param, so just append it to the list of arguments\n+                command_args = \"%s %s\" % (command_args, x)\n+        params['args'] = command_args.strip()\n         return (params, params['args'])\n \n main()"
        },
        {
          "filename": "test/integration/roles/test_iterators/tasks/main.yml",
          "status": "modified",
          "additions": 10,
          "deletions": 11,
          "patch": "@@ -19,7 +19,7 @@\n # WITH_ITEMS\n \n - name: test with_items\n-  set_fact: \"{{ item + '=moo' }}\"\n+  set_fact: \"{{ item }}=moo\"\n   with_items:\n     - 'foo'\n     - 'bar'\n@@ -36,7 +36,7 @@\n # WITH_NESTED\n \n - name: test with_nested\n-  set_fact: \"{{ item.0 + item.1 + '=x' }}\"\n+  set_fact: \"{{ item.0 + item.1 }}=x\"\n   with_nested:\n     - [ 'a', 'b' ]\n     - [ 'c', 'd' ]        \n@@ -57,7 +57,7 @@\n # WITH_SEQUENCE\n \n - name: test with_sequence\n-  set_fact: \"{{ 'x' + item + '=' + item }}\"\n+  set_fact: \"{{ 'x' + item }}={{ item }}\"\n   with_sequence: start=0 end=3\n \n - name: verify with_sequence\n@@ -71,7 +71,7 @@\n # WITH_RANDOM_CHOICE\n \n - name: test with_random_choice\n-  set_fact: \"{{ 'random=' + item }}\"\n+  set_fact: \"random={{ item }}\"\n   with_random_choice:\n     - \"foo\"\n     - \"bar\" \n@@ -84,7 +84,7 @@\n # WITH_SUBELEMENTS\n \n - name: test with_subelements\n-  set_fact: \"{{ '_'+ item.0.id + item.1 + '=' + item.1 }}\"\n+  set_fact: \"{{ '_'+ item.0.id + item.1 }}={{ item.1 }}\"\n   with_subelements:\n     - element_data\n     - the_list\n@@ -101,7 +101,7 @@\n \n - name: test with_together\n   #shell: echo {{ item }}\n-  set_fact: \"{{ item.0 + '=' + item.1 }}\"\n+  set_fact: \"{{ item.0 }}={{ item.1 }}\"\n   with_together:\n     - [ 'a', 'b', 'c', 'd' ]\n     - [ '1', '2', '3', '4' ]\n@@ -124,7 +124,7 @@\n \n - name: test with_first_found\n   #shell: echo {{ item }}\n-  set_fact: \"{{ 'first_found=' + item }}\"\n+  set_fact: \"first_found={{ item }}\"\n   with_first_found:\n     - \"{{ output_dir + '/does_not_exist' }}\"\n     - \"{{ output_dir + '/foo1' }}\"\n@@ -146,7 +146,7 @@\n \n - name: test with_lines\n   #shell: echo \"{{ item }}\"\n-  set_fact: \"{{ item + '=set' }}\" \n+  set_fact: \"{{ item }}=set\" \n   with_lines: for i in $(seq 1 5); do echo \"l$i\" ; done;\n \n - name: verify with_lines results\n@@ -164,7 +164,7 @@\n   register: list_data\n \n - name: create indexed list\n-  set_fact: \"{{ item[1] + item[0]|string + '=set' }}\"\n+  set_fact: \"{{ item[1] + item[0]|string }}=set\"\n   with_indexed_items: list_data.stdout_lines  \n \n - name: verify with_indexed_items result\n@@ -179,8 +179,7 @@\n # WITH_FLATTENED\n \n - name: test with_flattened\n-  #shell: echo {{ item + \"test\" }}\n-  set_fact: \"{{ item + '=flattened' }}\"\n+  set_fact: \"{{ item }}=flattened\"\n   with_flattened:\n     - [ 'a__' ]\n     - [ 'b__', ['c__', 'd__'] ]        "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 6,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "ae55f874a09730589bf697fda411de42d36916ec",
            "date": "2025-01-13T22:24:09Z",
            "author_login": "felixfontein"
          },
          {
            "sha": "508c4dc93ee8dcad4addf20ecb385f1496ebc5fe",
            "date": "2025-01-13T20:04:50Z",
            "author_login": "Akasurde"
          },
          {
            "sha": "60e2135c2b942aad45afeed7a0fbeba2783edbaa",
            "date": "2025-01-13T19:24:56Z",
            "author_login": "felixfontein"
          },
          {
            "sha": "40d364985dee5d4afecc478547f765574b3e41d6",
            "date": "2025-01-13T16:51:49Z",
            "author_login": "xzeck"
          },
          {
            "sha": "eb475e23f74d30f470e841ddf0a65f031081cad5",
            "date": "2025-01-11T01:09:48Z",
            "author_login": "mattclay"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-74",
    "description": "Ansible before 1.6.7 does not prevent inventory data with \"{{\" and \"lookup\" substrings, and does not prevent remote data with \"{{\" substrings, which allows remote attackers to execute arbitrary code via (1) crafted lookup('pipe') calls or (2) crafted Jinja2 data.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-02-18T15:15:11.863",
    "last_modified": "2024-11-21T02:11:11.273",
    "fix_date": "2014-07-21T02:48:31Z"
  },
  "references": [
    {
      "url": "http://www.ocert.org/advisories/ocert-2014-004.html",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ansible/ansible/commit/62a1295a3e08cb6c3e9f1b2a1e6e5dcaeab32527",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.ocert.org/advisories/ocert-2014-004.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ansible/ansible/commit/62a1295a3e08cb6c3e9f1b2a1e6e5dcaeab32527",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:39.853695",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "ansible",
    "owner": "ansible",
    "created_at": "2012-03-06T14:58:02Z",
    "updated_at": "2025-01-14T10:49:14Z",
    "pushed_at": "2025-01-13T22:24:09Z",
    "size": 256540,
    "stars": 63659,
    "forks": 23941,
    "open_issues": 910,
    "watchers": 63659,
    "has_security_policy": false,
    "default_branch": "devel",
    "protected_branches": [
      "devel",
      "mazer_role_loader",
      "milestone",
      "release1.5.0",
      "release1.5.1",
      "release1.5.2",
      "release1.5.3",
      "release1.5.4",
      "release1.5.5",
      "release1.6.0",
      "release1.6.1",
      "release1.6.2",
      "release1.6.3",
      "release1.6.4",
      "release1.6.5",
      "release1.6.6",
      "release1.6.7",
      "release1.6.8",
      "release1.6.9",
      "release1.6.10",
      "release1.7.0",
      "release1.7.1",
      "release1.7.2",
      "release1.8.0",
      "release1.8.1",
      "release1.8.2",
      "release1.8.3",
      "release1.8.4",
      "stable-1.9",
      "stable-2.0-network"
    ],
    "languages": {
      "Python": 8959137,
      "PowerShell": 728026,
      "Shell": 293660,
      "C#": 221744,
      "Jinja": 45945,
      "Go": 2010,
      "Roff": 555,
      "Batchfile": 144
    },
    "commit_activity": {
      "total_commits_last_year": 609,
      "avg_commits_per_week": 11.711538461538462,
      "days_active_last_year": 201
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-14T13:02:42.286063"
  }
}