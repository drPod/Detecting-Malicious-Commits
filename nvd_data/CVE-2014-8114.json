{
  "cve_id": "CVE-2014-8114",
  "github_data": {
    "repository": "uberfire/uberfire",
    "fix_commit": "21ec50eb15",
    "related_commits": [
      "21ec50eb15",
      "21ec50eb15"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "21ec50eb15",
      "commit_date": "2014-12-23T14:35:18Z",
      "author": {
        "login": "porcelli",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "BZ(1169544,1169556, 1169557,1169559,1169560): improvements on security related to file access",
        "length": 93,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 743,
        "additions": 578,
        "deletions": 165
      },
      "files": [
        {
          "filename": "uberfire-commons/src/main/java/org/uberfire/commons/regex/util/AntPathMatcher.java",
          "status": "renamed",
          "additions": 110,
          "deletions": 119,
          "patch": "@@ -1,20 +1,4 @@\n-/*\n- * Copyright 2012 JBoss Inc\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *       http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.uberfire.security.server.util;\n+package org.uberfire.commons.regex.util;\n \n import java.util.ArrayList;\n import java.util.List;\n@@ -39,20 +23,22 @@ public class AntPathMatcher {\n      * Set the path separator to use for pattern parsing. Default is \"/\", as in\n      * Ant.\n      */\n-    public void setPathSeparator(final String pathSeparator) {\n+    public void setPathSeparator( final String pathSeparator ) {\n         this.pathSeparator = pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR;\n     }\n \n-    public boolean isPattern(final String path) {\n-        return path.indexOf('*') != -1 || path.indexOf('?') != -1;\n+    public boolean isPattern( final String path ) {\n+        return path.indexOf( '*' ) != -1 || path.indexOf( '?' ) != -1;\n     }\n \n-    public boolean match(final String pattern, final String path) {\n-        return doMatch(pattern, path, true);\n+    public boolean match( final String pattern,\n+                          final String path ) {\n+        return doMatch( pattern, path, true );\n     }\n \n-    public boolean matchStart(final String pattern, final String path) {\n-        return doMatch(pattern, path, false);\n+    public boolean matchStart( final String pattern,\n+                               final String path ) {\n+        return doMatch( pattern, path, false );\n     }\n \n     /**\n@@ -63,92 +49,94 @@ public boolean matchStart(final String pattern, final String path) {\n      * @param fullMatch whether a full pattern match is required (else a pattern\n      * match as far as the given base path goes is sufficient)\n      * @return <code>true</code> if the supplied <code>path</code> matched,\n-     *         <code>false</code> if it didn't\n+     * <code>false</code> if it didn't\n      */\n-    protected boolean doMatch(String pattern, String path, boolean fullMatch) {\n-        if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {\n+    protected boolean doMatch( String pattern,\n+                               String path,\n+                               boolean fullMatch ) {\n+        if ( path.startsWith( this.pathSeparator ) != pattern.startsWith( this.pathSeparator ) ) {\n             return false;\n         }\n \n-        String[] pattDirs = tokenizeToStringArray(pattern, this.pathSeparator);\n-        String[] pathDirs = tokenizeToStringArray(path, this.pathSeparator);\n+        String[] pattDirs = tokenizeToStringArray( pattern, this.pathSeparator );\n+        String[] pathDirs = tokenizeToStringArray( path, this.pathSeparator );\n \n         int pattIdxStart = 0;\n         int pattIdxEnd = pattDirs.length - 1;\n         int pathIdxStart = 0;\n         int pathIdxEnd = pathDirs.length - 1;\n \n         // Match all elements up to the first **\n-        while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n-            String patDir = pattDirs[pattIdxStart];\n-            if (\"**\".equals(patDir)) {\n+        while ( pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd ) {\n+            String patDir = pattDirs[ pattIdxStart ];\n+            if ( \"**\".equals( patDir ) ) {\n                 break;\n             }\n-            if (!matchStrings(patDir, pathDirs[pathIdxStart])) {\n+            if ( !matchStrings( patDir, pathDirs[ pathIdxStart ] ) ) {\n                 return false;\n             }\n             pattIdxStart++;\n             pathIdxStart++;\n         }\n \n-        if (pathIdxStart > pathIdxEnd) {\n+        if ( pathIdxStart > pathIdxEnd ) {\n             // Path is exhausted, only match if rest of pattern is * or **'s\n-            if (pattIdxStart > pattIdxEnd) {\n-                return pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) : !path\n-                        .endsWith(this.pathSeparator);\n+            if ( pattIdxStart > pattIdxEnd ) {\n+                return pattern.endsWith( this.pathSeparator ) ? path.endsWith( this.pathSeparator ) : !path\n+                        .endsWith( this.pathSeparator );\n             }\n-            if (!fullMatch) {\n+            if ( !fullMatch ) {\n                 return true;\n             }\n-            if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals(\"*\")\n-                    && path.endsWith(this.pathSeparator)) {\n+            if ( pattIdxStart == pattIdxEnd && pattDirs[ pattIdxStart ].equals( \"*\" )\n+                    && path.endsWith( this.pathSeparator ) ) {\n                 return true;\n             }\n-            for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n-                if (!pattDirs[i].equals(\"**\")) {\n+            for ( int i = pattIdxStart; i <= pattIdxEnd; i++ ) {\n+                if ( !pattDirs[ i ].equals( \"**\" ) ) {\n                     return false;\n                 }\n             }\n             return true;\n-        } else if (pattIdxStart > pattIdxEnd) {\n+        } else if ( pattIdxStart > pattIdxEnd ) {\n             // String not exhausted, but pattern is. Failure.\n             return false;\n-        } else if (!fullMatch && \"**\".equals(pattDirs[pattIdxStart])) {\n+        } else if ( !fullMatch && \"**\".equals( pattDirs[ pattIdxStart ] ) ) {\n             // Path start definitely matches due to \"**\" part in pattern.\n             return true;\n         }\n \n         // up to last '**'\n-        while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n-            String patDir = pattDirs[pattIdxEnd];\n-            if (patDir.equals(\"**\")) {\n+        while ( pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd ) {\n+            String patDir = pattDirs[ pattIdxEnd ];\n+            if ( patDir.equals( \"**\" ) ) {\n                 break;\n             }\n-            if (!matchStrings(patDir, pathDirs[pathIdxEnd])) {\n+            if ( !matchStrings( patDir, pathDirs[ pathIdxEnd ] ) ) {\n                 return false;\n             }\n             pattIdxEnd--;\n             pathIdxEnd--;\n         }\n-        if (pathIdxStart > pathIdxEnd) {\n+        if ( pathIdxStart > pathIdxEnd ) {\n             // String is exhausted\n-            for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n-                if (!pattDirs[i].equals(\"**\")) {\n+            for ( int i = pattIdxStart; i <= pattIdxEnd; i++ ) {\n+                if ( !pattDirs[ i ].equals( \"**\" ) ) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n \n-        while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n+        while ( pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd ) {\n             int patIdxTmp = -1;\n-            for (int i = pattIdxStart + 1; i <= pattIdxEnd; i++) {\n-                if (pattDirs[i].equals(\"**\")) {\n+            for ( int i = pattIdxStart + 1; i <= pattIdxEnd; i++ ) {\n+                if ( pattDirs[ i ].equals( \"**\" ) ) {\n                     patIdxTmp = i;\n                     break;\n                 }\n             }\n-            if (patIdxTmp == pattIdxStart + 1) {\n+            if ( patIdxTmp == pattIdxStart + 1 ) {\n                 // '**/**' situation, so skip one\n                 pattIdxStart++;\n                 continue;\n@@ -160,28 +148,28 @@ protected boolean doMatch(String pattern, String path, boolean fullMatch) {\n             int foundIdx = -1;\n \n             strLoop:\n-            for (int i = 0; i <= strLength - patLength; i++) {\n-                for (int j = 0; j < patLength; j++) {\n-                    String subPat = pattDirs[pattIdxStart + j + 1];\n-                    String subStr = pathDirs[pathIdxStart + i + j];\n-                    if (!matchStrings(subPat, subStr)) {\n+            for ( int i = 0; i <= strLength - patLength; i++ ) {\n+                for ( int j = 0; j < patLength; j++ ) {\n+                    String subPat = pattDirs[ pattIdxStart + j + 1 ];\n+                    String subStr = pathDirs[ pathIdxStart + i + j ];\n+                    if ( !matchStrings( subPat, subStr ) ) {\n                         continue strLoop;\n                     }\n                 }\n                 foundIdx = pathIdxStart + i;\n                 break;\n             }\n \n-            if (foundIdx == -1) {\n+            if ( foundIdx == -1 ) {\n                 return false;\n             }\n \n             pattIdxStart = patIdxTmp;\n             pathIdxStart = foundIdx + patLength;\n         }\n \n-        for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n-            if (!pattDirs[i].equals(\"**\")) {\n+        for ( int i = pattIdxStart; i <= pattIdxEnd; i++ ) {\n+            if ( !pattDirs[ i ].equals( \"**\" ) ) {\n                 return false;\n             }\n         }\n@@ -198,9 +186,10 @@ protected boolean doMatch(String pattern, String path, boolean fullMatch) {\n      * @param str string which must be matched against the pattern. Must not be\n      * <code>null</code>.\n      * @return <code>true</code> if the string matches against the pattern, or\n-     *         <code>false</code> otherwise.\n+     * <code>false</code> otherwise.\n      */\n-    private boolean matchStrings(String pattern, String str) {\n+    private boolean matchStrings( String pattern,\n+                                  String str ) {\n         char[] patArr = pattern.toCharArray();\n         char[] strArr = str.toCharArray();\n         int patIdxStart = 0;\n@@ -210,22 +199,22 @@ private boolean matchStrings(String pattern, String str) {\n         char ch;\n \n         boolean containsStar = false;\n-        for (char c : patArr) {\n-            if (c == '*') {\n+        for ( char c : patArr ) {\n+            if ( c == '*' ) {\n                 containsStar = true;\n                 break;\n             }\n         }\n \n-        if (!containsStar) {\n+        if ( !containsStar ) {\n             // No '*'s, so we make a shortcut\n-            if (patIdxEnd != strIdxEnd) {\n+            if ( patIdxEnd != strIdxEnd ) {\n                 return false; // Pattern and string do not have the same size\n             }\n-            for (int i = 0; i <= patIdxEnd; i++) {\n-                ch = patArr[i];\n-                if (ch != '?') {\n-                    if (ch != strArr[i]) {\n+            for ( int i = 0; i <= patIdxEnd; i++ ) {\n+                ch = patArr[ i ];\n+                if ( ch != '?' ) {\n+                    if ( ch != strArr[ i ] ) {\n                         return false;\n                         // Character mismatch\n                     }\n@@ -234,48 +223,48 @@ private boolean matchStrings(String pattern, String str) {\n             return true; // String matches against pattern\n         }\n \n-        if (patIdxEnd == 0) {\n+        if ( patIdxEnd == 0 ) {\n             return true; // Pattern contains only '*', which matches anything\n         }\n \n         // Process characters before first star\n-        while ((ch = patArr[patIdxStart]) != '*' && strIdxStart <= strIdxEnd) {\n-            if (ch != '?') {\n-                if (ch != strArr[strIdxStart]) {\n+        while ( ( ch = patArr[ patIdxStart ] ) != '*' && strIdxStart <= strIdxEnd ) {\n+            if ( ch != '?' ) {\n+                if ( ch != strArr[ strIdxStart ] ) {\n                     return false;\n                     // Character mismatch\n                 }\n             }\n             patIdxStart++;\n             strIdxStart++;\n         }\n-        if (strIdxStart > strIdxEnd) {\n+        if ( strIdxStart > strIdxEnd ) {\n             // All characters in the string are used. Check if only '*'s are\n             // left in the pattern. If so, we succeeded. Otherwise failure.\n-            for (int i = patIdxStart; i <= patIdxEnd; i++) {\n-                if (patArr[i] != '*') {\n+            for ( int i = patIdxStart; i <= patIdxEnd; i++ ) {\n+                if ( patArr[ i ] != '*' ) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n \n         // Process characters after last star\n-        while ((ch = patArr[patIdxEnd]) != '*' && strIdxStart <= strIdxEnd) {\n-            if (ch != '?') {\n-                if (ch != strArr[strIdxEnd]) {\n+        while ( ( ch = patArr[ patIdxEnd ] ) != '*' && strIdxStart <= strIdxEnd ) {\n+            if ( ch != '?' ) {\n+                if ( ch != strArr[ strIdxEnd ] ) {\n                     return false;\n                     // Character mismatch\n                 }\n             }\n             patIdxEnd--;\n             strIdxEnd--;\n         }\n-        if (strIdxStart > strIdxEnd) {\n+        if ( strIdxStart > strIdxEnd ) {\n             // All characters in the string are used. Check if only '*'s are\n             // left in the pattern. If so, we succeeded. Otherwise failure.\n-            for (int i = patIdxStart; i <= patIdxEnd; i++) {\n-                if (patArr[i] != '*') {\n+            for ( int i = patIdxStart; i <= patIdxEnd; i++ ) {\n+                if ( patArr[ i ] != '*' ) {\n                     return false;\n                 }\n             }\n@@ -284,15 +273,15 @@ private boolean matchStrings(String pattern, String str) {\n \n         // process pattern between stars. padIdxStart and patIdxEnd point\n         // always to a '*'.\n-        while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {\n+        while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) {\n             int patIdxTmp = -1;\n-            for (int i = patIdxStart + 1; i <= patIdxEnd; i++) {\n-                if (patArr[i] == '*') {\n+            for ( int i = patIdxStart + 1; i <= patIdxEnd; i++ ) {\n+                if ( patArr[ i ] == '*' ) {\n                     patIdxTmp = i;\n                     break;\n                 }\n             }\n-            if (patIdxTmp == patIdxStart + 1) {\n+            if ( patIdxTmp == patIdxStart + 1 ) {\n                 // Two stars next to each other, skip the first one.\n                 patIdxStart++;\n                 continue;\n@@ -303,11 +292,11 @@ private boolean matchStrings(String pattern, String str) {\n             int strLength = strIdxEnd - strIdxStart + 1;\n             int foundIdx = -1;\n             strLoop:\n-            for (int i = 0; i <= strLength - patLength; i++) {\n-                for (int j = 0; j < patLength; j++) {\n-                    ch = patArr[patIdxStart + j + 1];\n-                    if (ch != '?') {\n-                        if (ch != strArr[strIdxStart + i + j]) {\n+            for ( int i = 0; i <= strLength - patLength; i++ ) {\n+                for ( int j = 0; j < patLength; j++ ) {\n+                    ch = patArr[ patIdxStart + j + 1 ];\n+                    if ( ch != '?' ) {\n+                        if ( ch != strArr[ strIdxStart + i + j ] ) {\n                             continue strLoop;\n                         }\n                     }\n@@ -317,7 +306,7 @@ private boolean matchStrings(String pattern, String str) {\n                 break;\n             }\n \n-            if (foundIdx == -1) {\n+            if ( foundIdx == -1 ) {\n                 return false;\n             }\n \n@@ -327,8 +316,8 @@ private boolean matchStrings(String pattern, String str) {\n \n         // All characters in the string are used. Check if only '*'s are left\n         // in the pattern. If so, we succeeded. Otherwise failure.\n-        for (int i = patIdxStart; i <= patIdxEnd; i++) {\n-            if (patArr[i] != '*') {\n+        for ( int i = patIdxStart; i <= patIdxEnd; i++ ) {\n+            if ( patArr[ i ] != '*' ) {\n                 return false;\n             }\n         }\n@@ -363,31 +352,32 @@ private boolean matchStrings(String pattern, String str) {\n      * <code>pattern</code>' and '<code>path</code>', but does\n      * <strong>not</strong> enforce this.\n      */\n-    public String extractPathWithinPattern(String pattern, String path) {\n-        final String[] patternParts = tokenizeToStringArray(pattern, this.pathSeparator);\n-        final String[] pathParts = tokenizeToStringArray(path, this.pathSeparator);\n+    public String extractPathWithinPattern( String pattern,\n+                                            String path ) {\n+        final String[] patternParts = tokenizeToStringArray( pattern, this.pathSeparator );\n+        final String[] pathParts = tokenizeToStringArray( path, this.pathSeparator );\n \n         final StringBuilder buffer = new StringBuilder();\n \n         // Add any path parts that have a wildcarded pattern part.\n         int puts = 0;\n-        for (int i = 0; i < patternParts.length; i++) {\n-            final String patternPart = patternParts[i];\n-            if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {\n-                if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {\n-                    buffer.append(this.pathSeparator);\n+        for ( int i = 0; i < patternParts.length; i++ ) {\n+            final String patternPart = patternParts[ i ];\n+            if ( ( patternPart.indexOf( '*' ) > -1 || patternPart.indexOf( '?' ) > -1 ) && pathParts.length >= i + 1 ) {\n+                if ( puts > 0 || ( i == 0 && !pattern.startsWith( this.pathSeparator ) ) ) {\n+                    buffer.append( this.pathSeparator );\n                 }\n-                buffer.append(pathParts[i]);\n+                buffer.append( pathParts[ i ] );\n                 puts++;\n             }\n         }\n \n         // Append any trailing path parts.\n-        for (int i = patternParts.length; i < pathParts.length; i++) {\n-            if (puts > 0 || i > 0) {\n-                buffer.append(this.pathSeparator);\n+        for ( int i = patternParts.length; i < pathParts.length; i++ ) {\n+            if ( puts > 0 || i > 0 ) {\n+                buffer.append( this.pathSeparator );\n             }\n-            buffer.append(pathParts[i]);\n+            buffer.append( pathParts[ i ] );\n         }\n \n         return buffer.toString();\n@@ -408,19 +398,20 @@ public String extractPathWithinPattern(String pattern, String path) {\n      * @see java.util.StringTokenizer\n      * @see java.lang.String#trim()\n      */\n-    public static String[] tokenizeToStringArray(String str, String delimiters) {\n-        if (str == null) {\n+    public static String[] tokenizeToStringArray( String str,\n+                                                  String delimiters ) {\n+        if ( str == null ) {\n             return null;\n         }\n-        final StringTokenizer st = new StringTokenizer(str, delimiters);\n+        final StringTokenizer st = new StringTokenizer( str, delimiters );\n         final List<String> tokens = new ArrayList<String>();\n-        while (st.hasMoreTokens()) {\n+        while ( st.hasMoreTokens() ) {\n             final String token = st.nextToken().trim();\n-            if (token.length() > 0) {\n-                tokens.add(token);\n+            if ( token.length() > 0 ) {\n+                tokens.add( token );\n             }\n         }\n-        return tokens.toArray(new String[tokens.size()]);\n+        return tokens.toArray( new String[ tokens.size() ] );\n     }\n \n-}\n+}\n\\ No newline at end of file"
        },
        {
          "filename": "uberfire-io/src/main/java/org/uberfire/io/regex/AntPathMatcher.java",
          "status": "added",
          "additions": 89,
          "deletions": 0,
          "patch": "@@ -0,0 +1,89 @@\n+package org.uberfire.io.regex;\n+\n+import java.net.URI;\n+import java.util.Collection;\n+\n+import org.uberfire.java.nio.file.Path;\n+\n+import static org.uberfire.commons.validation.Preconditions.*;\n+\n+public final class AntPathMatcher {\n+\n+    private static org.uberfire.commons.regex.util.AntPathMatcher matcher = new org.uberfire.commons.regex.util.AntPathMatcher();\n+\n+    public static boolean filter( final Collection<String> includes,\n+                                  final Collection<String> excludes,\n+                                  final Path path ) {\n+        checkNotNull( \"includes\", includes );\n+        checkNotNull( \"excludes\", excludes );\n+        checkNotNull( \"path\", path );\n+        if ( includes.isEmpty() && excludes.isEmpty() ) {\n+            return true;\n+        } else if ( includes.isEmpty() ) {\n+            return !( excludes( excludes, path ) );\n+        } else if ( excludes.isEmpty() ) {\n+            return includes( includes, path );\n+        }\n+        return includes( includes, path ) && !( excludes( excludes, path ) );\n+    }\n+\n+    public static boolean filter( final Collection<String> includes,\n+                                  final Collection<String> excludes,\n+                                  final URI uri ) {\n+        checkNotNull( \"includes\", includes );\n+        checkNotNull( \"excludes\", excludes );\n+        checkNotNull( \"uri\", uri );\n+        if ( includes.isEmpty() && excludes.isEmpty() ) {\n+            return true;\n+        } else if ( includes.isEmpty() ) {\n+            return !( excludes( excludes, uri ) );\n+        } else if ( excludes.isEmpty() ) {\n+            return includes( includes, uri );\n+        }\n+        return includes( includes, uri ) && !( excludes( excludes, uri ) );\n+    }\n+\n+    public static boolean includes( final Collection<String> patterns,\n+                                    final Path path ) {\n+        checkNotNull( \"patterns\", patterns );\n+        checkNotNull( \"path\", path );\n+        return matches( patterns, path );\n+    }\n+\n+    public static boolean includes( final Collection<String> patterns,\n+                                    final URI uri ) {\n+        checkNotNull( \"patterns\", patterns );\n+        checkNotNull( \"uri\", uri );\n+        return matches( patterns, uri );\n+    }\n+\n+    public static boolean excludes( final Collection<String> patterns,\n+                                    final URI uri ) {\n+        checkNotNull( \"patterns\", patterns );\n+        checkNotNull( \"uri\", uri );\n+        return matches( patterns, uri );\n+    }\n+\n+    public static boolean excludes( final Collection<String> patterns,\n+                                    final Path path ) {\n+        checkNotNull( \"patterns\", patterns );\n+        checkNotNull( \"path\", path );\n+        return matches( patterns, path );\n+    }\n+\n+    private static boolean matches( final Collection<String> patterns,\n+                                    final Path path ) {\n+        return matches( patterns, path.toUri() );\n+    }\n+\n+    private static boolean matches( final Collection<String> patterns,\n+                                    final URI uri ) {\n+        for ( final String pattern : patterns ) {\n+            if ( matcher.match( pattern, uri.toString() ) ) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+}"
        },
        {
          "filename": "uberfire-io/src/test/java/org/uberfire/io/regex/AntPathMatcherTest.java",
          "status": "added",
          "additions": 244,
          "deletions": 0,
          "patch": "@@ -0,0 +1,244 @@\n+package org.uberfire.io.regex;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.uberfire.io.CommonIOServiceDotFileTest;\n+import org.uberfire.io.IOService;\n+import org.uberfire.io.impl.IOServiceDotFileImpl;\n+import org.uberfire.java.nio.file.Path;\n+import org.uberfire.java.nio.file.Paths;\n+\n+import static org.uberfire.io.regex.AntPathMatcher.*;\n+\n+public class AntPathMatcherTest {\n+\n+    final static IOService ioService = new IOServiceDotFileImpl();\n+    private static File path = null;\n+\n+    @BeforeClass\n+    public static void setup() throws IOException {\n+        path = CommonIOServiceDotFileTest.createTempDirectory();\n+        System.setProperty( \"org.uberfire.nio.git.dir\", path.getAbsolutePath() );\n+        System.out.println( \".niogit: \" + path.getAbsolutePath() );\n+\n+        final URI newRepo = URI.create( \"git://antpathmatcher\" );\n+\n+        ioService.newFileSystem( newRepo, new HashMap<String, Object>() );\n+    }\n+\n+    @AfterClass\n+    @BeforeClass\n+    public static void cleanup() {\n+        if ( path != null ) {\n+            FileUtils.deleteQuietly( path );\n+        }\n+    }\n+\n+    @Test\n+    public void testIncludes() {\n+        final Collection<String> patterns = new ArrayList<String>() {{\n+            add( \"git://**\" );\n+            add( \"**/repo/**\" );\n+        }};\n+\n+        {\n+            final Path path = Paths.get( URI.create( \"file:///Users/home\" ) );\n+            Assert.assertFalse( includes( patterns, path ) );\n+        }\n+\n+        {\n+            final Path path = Paths.get( URI.create( \"git://antpathmatcher\" ) );\n+            Assert.assertTrue( includes( patterns, path ) );\n+        }\n+\n+        {\n+            final Path path = Paths.get( URI.create( \"git://master@antpathmatcher\" ) );\n+            Assert.assertTrue( includes( patterns, path ) );\n+        }\n+    }\n+\n+    @Test\n+    public void testIncludesMid() {\n+        final Collection<String> patterns = new ArrayList<String>() {{\n+            add( \"default://**\" );\n+            add( \"**/repo/**\" );\n+        }};\n+\n+        {\n+            final Path path = Paths.get( URI.create( \"file:///Users/home\" ) );\n+            Assert.assertTrue( includes( patterns, path ) );\n+        }\n+\n+        {\n+            final Path path = Paths.get( URI.create( \"git://antpathmatcher\" ) );\n+            Assert.assertFalse( includes( patterns, path ) );\n+        }\n+\n+        {\n+            final Path path = Paths.get( URI.create( \"git://master@antpathmatcher/repo/sss\" ) );\n+            Assert.assertTrue( includes( patterns, path ) );\n+        }\n+    }\n+\n+    @Test\n+    public void testExcludes() {\n+        final Collection<String> patterns = new ArrayList<String>() {{\n+            add( \"git://**\" );\n+            add( \"**/repo/**\" );\n+        }};\n+\n+        {\n+            final Path path = Paths.get( URI.create( \"file:///Users/home\" ) );\n+            Assert.assertFalse( excludes( patterns, path ) );\n+        }\n+\n+        {\n+            final Path path = Paths.get( URI.create( \"git://antpathmatcher\" ) );\n+            Assert.assertTrue( excludes( patterns, path ) );\n+        }\n+\n+        {\n+            final Path path = Paths.get( URI.create( \"git://master@antpathmatcher\" ) );\n+            Assert.assertTrue( excludes( patterns, path ) );\n+        }\n+    }\n+\n+    @Test\n+    public void testExcludesMid() {\n+        final Collection<String> patterns = new ArrayList<String>() {{\n+            add( \"default://**\" );\n+            add( \"**/repo/**\" );\n+        }};\n+\n+        {\n+            final Path path = Paths.get( URI.create( \"file:///Users/home\" ) );\n+            Assert.assertTrue( excludes( patterns, path ) );\n+        }\n+\n+        {\n+            final Path path = Paths.get( URI.create( \"git://antpathmatcher\" ) );\n+            Assert.assertFalse( excludes( patterns, path ) );\n+        }\n+\n+        {\n+            final Path path = Paths.get( URI.create( \"git://master@antpathmatcher/repo/sss\" ) );\n+            Assert.assertTrue( excludes( patterns, path ) );\n+        }\n+    }\n+\n+    @Test\n+    public void testFilter() {\n+        final Collection<String> includes = new ArrayList<String>() {{\n+            add( \"git://**\" );\n+        }};\n+        final Collection<String> excludes = new ArrayList<String>() {{\n+            add( \"default://**\" );\n+        }};\n+\n+        {\n+            final Path path = Paths.get( URI.create( \"file:///Users/home\" ) );\n+            Assert.assertFalse( filter( includes, excludes, path ) );\n+        }\n+\n+        {\n+            final Path path = Paths.get( URI.create( \"git://antpathmatcher\" ) );\n+            Assert.assertTrue( filter( includes, excludes, path ) );\n+        }\n+\n+        {\n+            final Path path = Paths.get( URI.create( \"git://master@antpathmatcher/repo/sss\" ) );\n+            Assert.assertTrue( filter( includes, excludes, path ) );\n+        }\n+\n+        Assert.assertTrue( filter( Collections.<String>emptyList(), Collections.<String>emptyList(), Paths.get( URI.create( \"git://master@antpathmatcher/repo/sss\" ) ) ) );\n+        Assert.assertTrue( filter( Collections.<String>emptyList(), Collections.<String>emptyList(), Paths.get( URI.create( \"git://antpathmatcher\" ) ) ) );\n+    }\n+\n+    @Test\n+    public void testIncludesUri() {\n+        final Collection<String> patterns = new ArrayList<String>() {{\n+            add( \"git://**\" );\n+            add( \"**/repo/**\" );\n+        }};\n+\n+        Assert.assertFalse( includes( patterns, URI.create( \"file:///Users/home\" ) ) );\n+\n+        Assert.assertTrue( includes( patterns, URI.create( \"git://antpathmatcher\" ) ) );\n+\n+        Assert.assertTrue( includes( patterns, URI.create( \"git://master@antpathmatcher\" ) ) );\n+    }\n+\n+    @Test\n+    public void testIncludesMidUri() {\n+        final Collection<String> patterns = new ArrayList<String>() {{\n+            add( \"file://**\" );\n+            add( \"**/repo/**\" );\n+        }};\n+\n+        Assert.assertTrue( includes( patterns, URI.create( \"file:///Users/home\" ) ) );\n+\n+        Assert.assertFalse( includes( patterns, URI.create( \"git://antpathmatcher\" ) ) );\n+\n+        Assert.assertTrue( includes( patterns, URI.create( \"git://master@antpathmatcher/repo/sss\" ) ) );\n+    }\n+\n+    @Test\n+    public void testExcludesUri() {\n+        final Collection<String> patterns = new ArrayList<String>() {{\n+            add( \"git://**\" );\n+            add( \"**/repo/**\" );\n+        }};\n+\n+        Assert.assertFalse( excludes( patterns, URI.create( \"file:///Users/home\" ) ) );\n+\n+        Assert.assertTrue( excludes( patterns, URI.create( \"git://antpathmatcher\" ) ) );\n+\n+        Assert.assertTrue( excludes( patterns, URI.create( \"git://master@antpathmatcher\" ) ) );\n+    }\n+\n+    @Test\n+    public void testExcludesMidUri() {\n+        final Collection<String> patterns = new ArrayList<String>() {{\n+            add( \"file://**\" );\n+            add( \"**/repo/**\" );\n+        }};\n+\n+        Assert.assertTrue( excludes( patterns, URI.create( \"file:///Users/home\" ) ) );\n+\n+        Assert.assertFalse( excludes( patterns, URI.create( \"git://antpathmatcher\" ) ) );\n+\n+        Assert.assertTrue( excludes( patterns, URI.create( \"git://master@antpathmatcher/repo/sss\" ) ) );\n+    }\n+\n+    @Test\n+    public void testFilterUri() {\n+        final Collection<String> includes = new ArrayList<String>() {{\n+            add( \"git://**\" );\n+        }};\n+        final Collection<String> excludes = new ArrayList<String>() {{\n+            add( \"file://**\" );\n+        }};\n+\n+        Assert.assertFalse( filter( includes, excludes, URI.create( \"file:///Users/home\" ) ) );\n+\n+        Assert.assertTrue( filter( includes, excludes, URI.create( \"git://antpathmatcher\" ) ) );\n+\n+        Assert.assertTrue( filter( includes, excludes, URI.create( \"git://master@antpathmatcher/repo/sss\" ) ) );\n+\n+        Assert.assertTrue( filter( Collections.<String>emptyList(), Collections.<String>emptyList(), URI.create( \"file:///Users/home\" ) ) );\n+\n+        Assert.assertTrue( filter( Collections.<String>emptyList(), Collections.<String>emptyList(), URI.create( \"git://master@antpathmatcher/repo/sss\" ) ) );\n+\n+    }\n+}"
        },
        {
          "filename": "uberfire-security/uberfire-security-server/src/main/java/org/uberfire/security/server/URLResourceManager.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -31,7 +31,7 @@\n import org.uberfire.security.ResourceManager;\n import org.uberfire.security.Role;\n import org.uberfire.security.impl.RoleImpl;\n-import org.uberfire.security.server.util.AntPathMatcher;\n+import org.uberfire.commons.regex.util.AntPathMatcher;\n import org.yaml.snakeyaml.Yaml;\n \n import static java.util.Collections.*;"
        },
        {
          "filename": "uberfire-server/src/main/java/org/uberfire/server/BaseFilteredServlet.java",
          "status": "added",
          "additions": 66,
          "deletions": 0,
          "patch": "@@ -0,0 +1,66 @@\n+package org.uberfire.server;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.uberfire.io.regex.AntPathMatcher;\n+import org.uberfire.java.nio.file.Path;\n+\n+import static javax.servlet.http.HttpServletResponse.*;\n+\n+public abstract class BaseFilteredServlet extends HttpServlet {\n+\n+    private static final Logger logger = LoggerFactory.getLogger( BaseFilteredServlet.class );\n+\n+    protected Collection<String> includes = new ArrayList<String>();\n+    protected Collection<String> excludes = new ArrayList<String>();\n+\n+    @Override\n+    public void init( final ServletConfig config ) throws ServletException {\n+        final String _includes = config.getInitParameter( \"includes-path\" );\n+        if ( _includes != null && !_includes.trim().isEmpty() ) {\n+            includes.addAll( Arrays.asList( _includes.split( \",\" ) ) );\n+        }\n+        final String _excludes = config.getInitParameter( \"excludes-path\" );\n+        if ( _excludes != null && !_excludes.trim().isEmpty() ) {\n+            excludes.addAll( Arrays.asList( _excludes.split( \",\" ) ) );\n+        }\n+    }\n+\n+    protected boolean validateAccess( final URI uri,\n+                                      final HttpServletResponse response ) {\n+        if ( !AntPathMatcher.filter( includes, excludes, uri ) ) {\n+            logger.error( \"Invalid credentials to path.\" );\n+            try {\n+                response.sendError( SC_FORBIDDEN );\n+            } catch ( Exception ex ) {\n+                logger.error( ex.getMessage() );\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    protected boolean validateAccess( final Path path,\n+                                      final HttpServletResponse response ) {\n+        if ( !AntPathMatcher.filter( includes, excludes, path ) ) {\n+            logger.error( \"Invalid credentials to path.\" );\n+            try {\n+                response.sendError( SC_FORBIDDEN );\n+            } catch ( Exception ex ) {\n+                logger.error( ex.getMessage() );\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+}"
        },
        {
          "filename": "uberfire-server/src/main/java/org/uberfire/server/FileDownloadServlet.java",
          "status": "modified",
          "additions": 20,
          "deletions": 13,
          "patch": "@@ -2,11 +2,9 @@\n \n import java.io.IOException;\n import java.net.URI;\n-import java.net.URISyntaxException;\n import javax.inject.Inject;\n import javax.inject.Named;\n import javax.servlet.ServletException;\n-import javax.servlet.http.HttpServlet;\n import javax.servlet.http.HttpServletRequest;\n import javax.servlet.http.HttpServletResponse;\n \n@@ -15,37 +13,46 @@\n import org.uberfire.io.IOService;\n import org.uberfire.java.nio.file.Path;\n \n+import static java.lang.String.*;\n+\n public class FileDownloadServlet\n-        extends HttpServlet {\n+        extends BaseFilteredServlet {\n \n-    private static final Logger logger = LoggerFactory.getLogger(FileDownloadServlet.class);\n+    private static final Logger logger = LoggerFactory.getLogger( FileDownloadServlet.class );\n \n     @Inject\n     @Named(\"ioStrategy\")\n     private IOService ioService;\n \n     @Override\n-    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n+    protected void doGet( HttpServletRequest request,\n+                          HttpServletResponse response )\n             throws ServletException, IOException {\n \n         try {\n \n-            Path path = ioService.get(new URI(request.getParameter(\"path\")));\n+            final URI uri = new URI( request.getParameter( \"path\" ) );\n+\n+            if ( !validateAccess( uri, response ) ) {\n+                return;\n+            }\n+\n+            final Path path = ioService.get( uri );\n \n-            byte[] bytes = ioService.readAllBytes(path);\n+            byte[] bytes = ioService.readAllBytes( path );\n \n-            response.setHeader(\"Content-Disposition\",\n-                    String.format(\"attachment; filename=%s;\", path.getFileName().toString()));\n+            response.setHeader( \"Content-Disposition\",\n+                                format( \"attachment; filename=%s;\", path.getFileName().toString() ) );\n \n-            response.setContentType(\"application/octet-stream\");\n+            response.setContentType( \"application/octet-stream\" );\n \n             response.getOutputStream().write(\n                     bytes,\n                     0,\n-                    bytes.length);\n+                    bytes.length );\n \n-        } catch (URISyntaxException e) {\n-            logger.error(\"Failed to download a file.\", e);\n+        } catch ( final Exception e ) {\n+            logger.error( \"Failed to download a file.\", e );\n         }\n \n     }"
        },
        {
          "filename": "uberfire-server/src/main/java/org/uberfire/server/FileUploadServlet.java",
          "status": "modified",
          "additions": 48,
          "deletions": 32,
          "patch": "@@ -7,7 +7,6 @@\n import javax.inject.Inject;\n import javax.inject.Named;\n import javax.servlet.ServletException;\n-import javax.servlet.http.HttpServlet;\n import javax.servlet.http.HttpServletRequest;\n import javax.servlet.http.HttpServletResponse;\n \n@@ -23,73 +22,90 @@\n import org.uberfire.java.nio.file.Path;\n \n public class FileUploadServlet\n-        extends HttpServlet {\n+        extends BaseFilteredServlet {\n \n-    private static final Logger logger = LoggerFactory.getLogger(FileUploadServlet.class);\n+    private static final Logger logger = LoggerFactory.getLogger( FileUploadServlet.class );\n \n     @Inject\n     @Named(\"ioStrategy\")\n     private IOService ioService;\n \n     @Override\n-    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n+    protected void doPost( HttpServletRequest request,\n+                           HttpServletResponse response ) throws ServletException, IOException {\n \n         try {\n-            if (request.getParameter(\"path\") != null) {\n-                writeFile(ioService.get(new URI(request.getParameter(\"path\"))), getFileItem(request));\n+            if ( request.getParameter( \"path\" ) != null ) {\n+\n+                final URI uri = new URI( request.getParameter( \"path\" ) );\n+\n+                if ( !validateAccess( uri, response ) ) {\n+                    return;\n+                }\n+\n+                writeFile( ioService.get( uri ), getFileItem( request ) );\n+\n+                writeResponse( response, \"OK\" );\n+            } else if ( request.getParameter( \"folder\" ) != null ) {\n+\n+                final URI uri = new URI( request.getParameter( \"folder\" ) + \"/\" + request.getParameter( \"fileName\" ) );\n+\n+                if ( !validateAccess( uri, response ) ) {\n+                    return;\n+                }\n \n-                writeResponse(response, \"OK\");\n-            } else if (request.getParameter(\"folder\") != null) {\n                 writeFile(\n-                        ioService.get(new URI(request.getParameter(\"folder\") + \"/\" + request.getParameter(\"fileName\"))),\n-                        getFileItem(request));\n+                        ioService.get( uri ),\n+                        getFileItem( request ) );\n \n-                writeResponse(response, \"OK\");\n+                writeResponse( response, \"OK\" );\n             }\n \n-        } catch (FileUploadException e) {\n-            logError(e);\n-            writeResponse(response, \"FAIL\");\n-        } catch (URISyntaxException e) {\n-            logError(e);\n-            writeResponse(response, \"FAIL\");\n+        } catch ( FileUploadException e ) {\n+            logError( e );\n+            writeResponse( response, \"FAIL\" );\n+        } catch ( URISyntaxException e ) {\n+            logError( e );\n+            writeResponse( response, \"FAIL\" );\n         }\n     }\n \n-    private FileItem getFileItem(HttpServletRequest request) throws FileUploadException {\n-        Iterator iterator = getServletFileUpload().parseRequest(request).iterator();\n-        while (iterator.hasNext()) {\n+    private FileItem getFileItem( HttpServletRequest request ) throws FileUploadException {\n+        Iterator iterator = getServletFileUpload().parseRequest( request ).iterator();\n+        while ( iterator.hasNext() ) {\n             FileItem item = (FileItem) iterator.next();\n-            if (!item.isFormField()) {\n+            if ( !item.isFormField() ) {\n                 return item;\n             }\n         }\n         return null;\n     }\n \n-    private void writeResponse(HttpServletResponse response, String ok) throws IOException {\n-        response.setContentType(\"text/html\");\n-        response.getWriter().write(ok);\n+    private void writeResponse( HttpServletResponse response,\n+                                String ok ) throws IOException {\n+        response.setContentType( \"text/html\" );\n+        response.getWriter().write( ok );\n     }\n \n     private ServletFileUpload getServletFileUpload() {\n         FileItemFactory factory = new DiskFileItemFactory();\n-        ServletFileUpload upload = new ServletFileUpload(factory);\n-        upload.setHeaderEncoding(\"UTF-8\");\n+        ServletFileUpload upload = new ServletFileUpload( factory );\n+        upload.setHeaderEncoding( \"UTF-8\" );\n         return upload;\n     }\n \n-    private void writeFile(Path path, FileItem uploadedItem) throws IOException {\n-        if (!ioService.exists(path)) {\n-            ioService.createFile(path);\n+    private void writeFile( Path path,\n+                            FileItem uploadedItem ) throws IOException {\n+        if ( !ioService.exists( path ) ) {\n+            ioService.createFile( path );\n         }\n \n-        ioService.write(path, IOUtils.toByteArray(uploadedItem.getInputStream()));\n+        ioService.write( path, IOUtils.toByteArray( uploadedItem.getInputStream() ) );\n \n         uploadedItem.getInputStream().close();\n     }\n \n-    private void logError(Throwable e) {\n-        logger.error(\"Failed to upload a file.\", e);\n+    private void logError( Throwable e ) {\n+        logger.error( \"Failed to upload a file.\", e );\n     }\n }"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 5,
        "max_directory_depth": 9
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d06e040fc83a0d3da2df19cddd4d9302054607da",
            "date": "2017-11-29T11:33:24Z",
            "author_login": "mbarkley"
          },
          {
            "sha": "1abaecac7d175438c574ab99f780239a4e643cde",
            "date": "2017-11-28T21:03:41Z",
            "author_login": "ederign"
          },
          {
            "sha": "bcec76d7204f2f5ae0a13c286a666c3818ecccf7",
            "date": "2017-11-28T17:29:18Z",
            "author_login": "mbarkley"
          },
          {
            "sha": "6f6c5d6d081a9693cbb0f7e704609c9224c76889",
            "date": "2017-11-25T18:29:03Z",
            "author_login": "mbarkley"
          },
          {
            "sha": "e8480099df5979b0010c04d63b9fc79eb7b89db9",
            "date": "2017-11-24T21:10:53Z",
            "author_login": "mareknovotny"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-264",
    "description": "The UberFire Framework 0.3.x does not properly restrict paths, which allows remote attackers to (1) execute arbitrary code by uploading crafted content to FileUploadServlet or (2) read arbitrary files via vectors involving FileDownloadServlet.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2015-02-20T16:59:02.430",
    "last_modified": "2024-11-21T02:18:35.133",
    "fix_date": "2014-12-23T14:35:18Z"
  },
  "references": [
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2015-0234.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2015-0235.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/88199",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://github.com/uberfire/uberfire/commit/21ec50eb15",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2015-0234.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2015-0235.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/88199",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/uberfire/uberfire/commit/21ec50eb15",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:32.417880",
    "processing_status": "enhanced"
  }
}