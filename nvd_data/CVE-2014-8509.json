{
  "cve_id": "CVE-2014-8509",
  "github_data": {
    "repository": "bittorrent/bootstrap-dht",
    "fix_commit": "bbc0b7191e3f48461ca6e5b1b34bdf4b3f1e79a9",
    "related_commits": [
      "bbc0b7191e3f48461ca6e5b1b34bdf4b3f1e79a9",
      "bbc0b7191e3f48461ca6e5b1b34bdf4b3f1e79a9"
    ],
    "patch_url": "https://github.com/bittorrent/bootstrap-dht/commit/bbc0b7191e3f48461ca6e5b1b34bdf4b3f1e79a9.patch",
    "fix_commit_details": {
      "sha": "bbc0b7191e3f48461ca6e5b1b34bdf4b3f1e79a9",
      "commit_date": "2014-10-23T23:23:01Z",
      "author": {
        "login": "arvidn",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "update version of lazy_bdecode from libtorrent",
        "length": 46,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 219,
        "additions": 175,
        "deletions": 44
      },
      "files": [
        {
          "filename": "lazy_bdecode.cpp",
          "status": "modified",
          "additions": 132,
          "deletions": 33,
          "patch": "@@ -1,6 +1,6 @@\n /*\n \n-Copyright (c) 2008-2012, Arvid Norberg\n+Copyright (c) 2008-2014, Arvid Norberg\n All rights reserved.\n \n Redistribution and use in source and binary forms, with or without\n@@ -45,35 +45,62 @@ namespace\n namespace libtorrent\n {\n \n-#define TORRENT_FAIL_BDECODE(code) \\\n-\t{ \\\n-\t\tec = make_error_code(code); \\\n-\t\twhile (!stack.empty()) { \\\n-\t\t\ttop = stack.back(); \\\n-\t\t\tif (top->type() == lazy_entry::dict_t || top->type() == lazy_entry::list_t) top->pop(); \\\n-\t\t\tstack.pop_back(); \\\n-\t\t} \\\n-\t\tif (error_pos) *error_pos = start - orig_start; \\\n-\t\treturn -1; \\\n+\tnamespace\n+\t{\n+\t\tint fail(int* error_pos\n+\t\t\t, std::vector<lazy_entry*>& stack\n+\t\t\t, char const* start\n+\t\t\t, char const* orig_start)\n+\t\t{\n+\t\t\twhile (!stack.empty()) {\n+\t\t\t\tlazy_entry* top = stack.back();\n+\t\t\t\tif (top->type() == lazy_entry::dict_t || top->type() == lazy_entry::list_t)\n+\t\t\t\t{\n+\t\t\t\t\ttop->pop();\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tstack.pop_back();\n+\t\t\t}\n+\t\t\tif (error_pos) *error_pos = start - orig_start;\n+\t\t\treturn -1;\n+\t\t}\n \t}\n \n-\tbool is_digit(char c) { return c >= '0' && c <= '9'; }\n+#define TORRENT_FAIL_BDECODE(code) do { ec = make_error_code(code); return fail(error_pos, stack, start, orig_start); } while (false)\n \n-\tbool is_print(char c) { return c >= 32 && c < 127; }\n+\tnamespace { bool numeric(char c) { return c >= '0' && c <= '9'; } }\n \n \t// fills in 'val' with what the string between start and the\n \t// first occurance of the delimiter is interpreted as an int.\n \t// return the pointer to the delimiter, or 0 if there is a\n \t// parse error. val should be initialized to zero\n-\tchar const* parse_int(char const* start, char const* end, char delimiter, boost::int64_t& val)\n+\tchar const* parse_int(char const* start, char const* end, char delimiter\n+\t\t, boost::int64_t& val, bdecode_errors::error_code_enum& ec)\n \t{\n \t\twhile (start < end && *start != delimiter)\n \t\t{\n-\t\t\tif (!is_digit(*start)) { return 0; }\n+\t\t\tif (!numeric(*start))\n+\t\t\t{\n+\t\t\t\tec = bdecode_errors::expected_string;\n+\t\t\t\treturn start;\n+\t\t\t}\n+\t\t\tif (val > INT64_MAX / 10)\n+\t\t\t{\n+\t\t\t\tec = bdecode_errors::overflow;\n+\t\t\t\treturn start;\n+\t\t\t}\n \t\t\tval *= 10;\n-\t\t\tval += *start - '0';\n+\t\t\tint digit = *start - '0';\n+\t\t\tif (val > INT64_MAX - digit)\n+\t\t\t{\n+\t\t\t\tec = bdecode_errors::overflow;\n+\t\t\t\treturn start;\n+\t\t\t}\n+\t\t\tval += digit;\n \t\t\t++start;\n \t\t}\n+\t\tif (*start != delimiter)\n+\t\t\tec = bdecode_errors::expected_colon;\n \t\treturn start;\n \t}\n \n@@ -94,7 +121,7 @@ namespace libtorrent\n \t\tstd::vector<lazy_entry*> stack;\n \n \t\tstack.push_back(&ret);\n-\t\twhile (start < end)\n+\t\twhile (start <= end)\n \t\t{\n \t\t\tif (stack.empty()) break; // done!\n \n@@ -116,11 +143,19 @@ namespace libtorrent\n \t\t\t\t\t\tstack.pop_back();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n-\t\t\t\t\tif (!is_digit(t)) TORRENT_FAIL_BDECODE(bdecode_errors::expected_string);\n+\t\t\t\t\tif (!numeric(t)) TORRENT_FAIL_BDECODE(bdecode_errors::expected_string);\n \t\t\t\t\tboost::int64_t len = t - '0';\n-\t\t\t\t\tstart = parse_int(start, end, ':', len);\n-\t\t\t\t\tif (start == 0 || start + len + 3 > end || *start != ':')\n-\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::expected_colon);\n+\t\t\t\t\tbdecode_errors::error_code_enum e = bdecode_errors::no_error;\n+\t\t\t\t\tstart = parse_int(start, end, ':', len, e);\n+\t\t\t\t\tif (e)\n+\t\t\t\t\t\tTORRENT_FAIL_BDECODE(e);\n+\n+\t\t\t\t\tif (start + len + 1 > end)\n+\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n+\n+\t\t\t\t\tif (len < 0)\n+\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::overflow);\n+\n \t\t\t\t\t++start;\n \t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n \t\t\t\t\tlazy_entry* ent = top->dict_append(start);\n@@ -173,13 +208,19 @@ namespace libtorrent\n \t\t\t\t}\n \t\t\t\tdefault:\n \t\t\t\t{\n-\t\t\t\t\tif (!is_digit(t))\n+\t\t\t\t\tif (!numeric(t))\n \t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::expected_value);\n \n \t\t\t\t\tboost::int64_t len = t - '0';\n-\t\t\t\t\tstart = parse_int(start, end, ':', len);\n-\t\t\t\t\tif (start == 0 || start + len + 1 > end || *start != ':')\n-\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::expected_colon);\n+\t\t\t\t\tbdecode_errors::error_code_enum e = bdecode_errors::no_error;\n+\t\t\t\t\tstart = parse_int(start, end, ':', len, e);\n+\t\t\t\t\tif (e)\n+\t\t\t\t\t\tTORRENT_FAIL_BDECODE(e);\n+\t\t\t\t\tif (start + len + 1 > end)\n+\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n+\t\t\t\t\tif (len < 0)\n+\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::overflow);\n+\n \t\t\t\t\t++start;\n \t\t\t\t\ttop->construct_string(start, int(len));\n \t\t\t\t\tstack.pop_back();\n@@ -198,7 +239,10 @@ namespace libtorrent\n \t\tboost::int64_t val = 0;\n \t\tbool negative = false;\n \t\tif (*m_data.start == '-') negative = true;\n-\t\tparse_int(negative?m_data.start+1:m_data.start, m_data.start + m_size, 'e', val);\n+\t\tbdecode_errors::error_code_enum ec = bdecode_errors::no_error;\n+\t\tparse_int(m_data.start + negative\n+\t\t\t, m_data.start + m_size, 'e', val, ec);\n+\t\tif (ec) return 0;\n \t\tif (negative) val = -val;\n \t\treturn val;\n \t}\n@@ -331,6 +375,13 @@ namespace libtorrent\n \t\treturn e;\n \t}\n \n+\tlazy_entry const* lazy_entry::dict_find_dict(std::string const& name) const\n+\t{\n+\t\tlazy_entry const* e = dict_find(name);\n+\t\tif (e == 0 || e->type() != lazy_entry::dict_t) return 0;\n+\t\treturn e;\n+\t}\n+\n \tlazy_entry const* lazy_entry::dict_find_list(char const* name) const\n \t{\n \t\tlazy_entry const* e = dict_find(name);\n@@ -350,6 +401,19 @@ namespace libtorrent\n \t\treturn 0;\n \t}\n \n+\tlazy_entry* lazy_entry::dict_find(std::string const& name)\n+\t{\n+\t\tTORRENT_ASSERT(m_type == dict_t);\n+\t\tfor (int i = 0; i < int(m_size); ++i)\n+\t\t{\n+\t\t\tlazy_dict_entry& e = m_data.dict[i];\n+\t\t\tif (name.size() != e.val.m_begin - e.name) continue;\n+\t\t\tif (std::equal(name.begin(), name.end(), e.name))\n+\t\t\t\treturn &e.val;\n+\t\t}\n+\t\treturn 0;\n+\t}\n+\n \tlazy_entry* lazy_entry::list_append()\n \t{\n \t\tTORRENT_ASSERT(m_type == list_t);\n@@ -492,23 +556,50 @@ namespace libtorrent\n \t\t\t\tchar const* str = e.string_ptr();\n \t\t\t\tfor (int i = 0; i < e.string_length(); ++i)\n \t\t\t\t{\n-\t\t\t\t\tusing namespace std;\n-\t\t\t\t\tif (is_print((unsigned char)str[i])) continue;\n+\t\t\t\t\tchar c = str[i];\n+\t\t\t\t\tif (c >= 32 && c < 127) continue;\n \t\t\t\t\tprintable = false;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tret += \"'\";\n \t\t\t\tif (printable)\n \t\t\t\t{\n-\t\t\t\t\tret += e.string_value();\n+\t\t\t\t\tif (single_line && e.string_length() > 30)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tret.append(e.string_ptr(), 14);\n+\t\t\t\t\t\tret += \"...\";\n+\t\t\t\t\t\tret.append(e.string_ptr() + e.string_length()-14, 14);\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n+\t\t\t\t\t\tret.append(e.string_ptr(), e.string_length());\n \t\t\t\t\tret += \"'\";\n \t\t\t\t\treturn ret;\n \t\t\t\t}\n-\t\t\t\tfor (int i = 0; i < e.string_length(); ++i)\n+\t\t\t\tif (single_line && e.string_length() > 20)\n \t\t\t\t{\n-\t\t\t\t\tchar tmp[5];\n-\t\t\t\t\tsnprintf(tmp, sizeof(tmp), \"%02x\", (unsigned char)str[i]);\n-\t\t\t\t\tret += tmp;\n+\t\t\t\t\tfor (int i = 0; i < 9; ++i)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tchar tmp[5];\n+\t\t\t\t\t\tsnprintf(tmp, sizeof(tmp), \"%02x\", (unsigned char)str[i]);\n+\t\t\t\t\t\tret += tmp;\n+\t\t\t\t\t}\n+\t\t\t\t\tret += \"...\";\n+\t\t\t\t\tfor (int i = e.string_length() - 9\n+\t\t\t\t\t\t, len(e.string_length()); i < len; ++i)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tchar tmp[5];\n+\t\t\t\t\t\tsnprintf(tmp, sizeof(tmp), \"%02x\", (unsigned char)str[i]);\n+\t\t\t\t\t\tret += tmp;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tfor (int i = 0; i < e.string_length(); ++i)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tchar tmp[5];\n+\t\t\t\t\t\tsnprintf(tmp, sizeof(tmp), \"%02x\", (unsigned char)str[i]);\n+\t\t\t\t\t\tret += tmp;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tret += \"'\";\n \t\t\t\treturn ret;\n@@ -577,6 +668,7 @@ namespace libtorrent\n \t\t\t\"expected value (list, dict, int or string) in bencoded string\",\n \t\t\t\"bencoded nesting depth exceeded\",\n \t\t\t\"bencoded item count limit exceeded\",\n+\t\t\t\"integer overflow\",\n \t\t};\n \t\tif (ev < 0 || ev >= int(sizeof(msgs)/sizeof(msgs[0])))\n \t\t\treturn \"Unknown error\";\n@@ -589,5 +681,12 @@ namespace libtorrent\n \t\treturn bdecode_category;\n \t}\n \n+\tnamespace bdecode_errors\n+\t{\n+\t\tboost::system::error_code make_error_code(error_code_enum e)\n+\t\t{\n+\t\t\treturn boost::system::error_code(e, get_bdecode_category());\n+\t\t}\n+\t}\n };\n "
        },
        {
          "filename": "lazy_entry.hpp",
          "status": "modified",
          "additions": 43,
          "deletions": 11,
          "patch": "@@ -1,6 +1,6 @@\n /*\n \n-Copyright (c) 2003-2012, Arvid Norberg\n+Copyright (c) 2003-2014, Arvid Norberg\n All rights reserved.\n \n Redistribution and use in source and binary forms, with or without\n@@ -37,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.\n #include <vector>\n #include <string>\n #include <cstring>\n+#include <algorithm>\n #include <boost/system/error_code.hpp>\n \n #define TORRENT_EXPORT\n@@ -136,6 +137,7 @@ namespace libtorrent\n \t\t\tnone_t, dict_t, list_t, string_t, int_t\n \t\t};\n \n+\t\t// internal\n \t\tlazy_entry() : m_begin(0), m_len(0), m_size(0), m_capacity(0), m_type(none_t)\n \t\t{ m_data.start = 0; }\n \n@@ -156,7 +158,7 @@ namespace libtorrent\n \t\t\tm_len = length + 2; // include 'e'\n \t\t}\n \n-\t\t// if this is an integer, return the integer value\n+\t\t// requires the type to be an integer. return the integer value\n \t\tboost::int64_t int_value() const;\n \n \t\t// internal\n@@ -221,6 +223,9 @@ namespace libtorrent\n \t\tlazy_entry* dict_find(char const* name);\n \t\tlazy_entry const* dict_find(char const* name) const\n \t\t{ return const_cast<lazy_entry*>(this)->dict_find(name); }\n+\t\tlazy_entry* dict_find(std::string const& name);\n+\t\tlazy_entry const* dict_find(std::string const& name) const\n+\t\t{ return const_cast<lazy_entry*>(this)->dict_find(name); }\n \t\tlazy_entry const* dict_find_string(char const* name) const;\n \n \t\t// if this is a dictionary, look for a key ``name`` whose value\n@@ -235,14 +240,22 @@ namespace libtorrent\n \t\tboost::int64_t dict_find_int_value(char const* name, boost::int64_t default_val = 0) const;\n \t\tlazy_entry const* dict_find_int(char const* name) const;\n \n+\t\t// these functions require that ``this`` is a dictionary.\n+\t\t// (this->type() == dict_t). They look for an element with the\n+\t\t// specified name in the dictionary. ``dict_find_dict`` only\n+\t\t// finds dictionaries and ``dict_find_list`` only finds lists.\n+\t\t// if no key with the corresponding value of the right type is\n+\t\t// found, NULL is returned.\n \t\tlazy_entry const* dict_find_dict(char const* name) const;\n+\t\tlazy_entry const* dict_find_dict(std::string const& name) const;\n \t\tlazy_entry const* dict_find_list(char const* name) const;\n \n \t\t// if this is a dictionary, return the key value pair at\n \t\t// position ``i`` from the dictionary.\n \t\tstd::pair<std::string, lazy_entry const*> dict_at(int i) const;\n \n-\t\t// if this is a dictionary, return the number of items in it\n+\t\t// requires that ``this`` is a dictionary. return the\n+\t\t// number of items in it\n \t\tint dict_size() const\n \t\t{\n \t\t\tTORRENT_ASSERT(m_type == dict_t);\n@@ -262,7 +275,8 @@ namespace libtorrent\n \t\t// internal\n \t\tlazy_entry* list_append();\n \n-\t\t// if this is a list, return the item at index ``i``.\n+\t\t// requires that ``this`` is a list. return\n+\t\t// the item at index ``i``.\n \t\tlazy_entry* list_at(int i)\n \t\t{\n \t\t\tTORRENT_ASSERT(m_type == list_t);\n@@ -272,8 +286,19 @@ namespace libtorrent\n \t\tlazy_entry const* list_at(int i) const\n \t\t{ return const_cast<lazy_entry*>(this)->list_at(i); }\n \n+\t\t// these functions require ``this`` to have the type list.\n+\t\t// (this->type() == list_t). ``list_string_value_at`` returns\n+\t\t// the string at index ``i``. ``list_pstr_at``\n+\t\t// returns a pascal_string of the string value at index ``i``.\n+\t\t// if the element at ``i`` is not a string, an empty string\n+\t\t// is returned.\n \t\tstd::string list_string_value_at(int i) const;\n \t\tpascal_string list_pstr_at(int i) const;\n+\n+\t\t// this function require ``this`` to have the type list.\n+\t\t// (this->type() == list_t). returns the integer value at\n+\t\t// index ``i``. If the element at ``i`` is not an integer\n+\t\t// ``default_val`` is returned, which defaults to 0.\n \t\tboost::int64_t list_int_value_at(int i, boost::int64_t default_val = 0) const;\n \n \t\t// if this is a list, return the number of items in it.\n@@ -283,7 +308,7 @@ namespace libtorrent\n \t\t\treturn int(m_size);\n \t\t}\n \n-\t\t// end points one byte passed last byte in the source\n+\t\t// internal: end points one byte passed last byte in the source\n \t\t// buffer backing the bencoded structure.\n \t\tvoid set_end(char const* end)\n \t\t{\n@@ -294,7 +319,7 @@ namespace libtorrent\n \t\t// internal\n \t\tvoid clear();\n \n-\t\t// releases ownership of any memory allocated\n+\t\t// internal: releases ownership of any memory allocated\n \t\tvoid release()\n \t\t{\n \t\t\tm_data.start = 0;\n@@ -361,9 +386,12 @@ namespace libtorrent\n \t\tlazy_entry val;\n \t};\n \n-\tTORRENT_EXTRA_EXPORT std::string print_entry(lazy_entry const& e\n+\t// print the bencoded structure in a human-readable format to a stting\n+\t// that's returned.\n+\tTORRENT_EXPORT std::string print_entry(lazy_entry const& e\n \t\t, bool single_line = false, int indent = 0);\n \n+\t// get the ``error_category`` for bdecode errors\n \tTORRENT_EXPORT boost::system::error_category& get_bdecode_category();\n \n \tnamespace bdecode_errors\n@@ -386,17 +414,21 @@ namespace libtorrent\n \t\t\tdepth_exceeded,\n \t\t\t// bencoded item count limit exceeded\n \t\t\tlimit_exceeded,\n+\t\t\t// integer overflow\n+\t\t\toverflow,\n \n \t\t\t// the number of error codes\n \t\t\terror_code_max\n \t\t};\n \n \t\t// hidden\n-\t\tinline boost::system::error_code make_error_code(error_code_enum e)\n-\t\t{\n-\t\t\treturn boost::system::error_code(e, get_bdecode_category());\n-\t\t}\n+\t\tTORRENT_EXPORT boost::system::error_code make_error_code(error_code_enum e);\n \t}\n+\n+\tTORRENT_EXTRA_EXPORT char const* parse_int(char const* start\n+\t\t, char const* end, char delimiter, boost::int64_t& val\n+\t\t, bdecode_errors::error_code_enum& ec);\n+\n }\n \n #endif"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "679c661463c3b7e43a34cbdf63dfda3e35ed8888",
            "date": "2017-02-21T17:24:29Z",
            "author_login": "ssiloti"
          },
          {
            "sha": "c770997ad47930421b8d8f7065c350ab0850b74c",
            "date": "2017-02-21T16:16:06Z",
            "author_login": "invalid-email-address"
          },
          {
            "sha": "5118bc0319df2c48249a183037ff7ebe435b486e",
            "date": "2016-09-20T21:05:09Z",
            "author_login": "ssiloti"
          },
          {
            "sha": "d0abbc80f4358a23fa0bb9c6e5efa4bd0ded9645",
            "date": "2016-09-18T13:15:30Z",
            "author_login": "arvidn"
          },
          {
            "sha": "c447bd7628aef370268cf3a1dff90c2e35feef4a",
            "date": "2016-09-19T16:57:32Z",
            "author_login": "ssiloti"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-119",
    "description": "The lazy_bdecode function in BitTorrent bootstrap-dht (aka Bootstrap) allows remote attackers to execute arbitrary code via a crafted packet, which triggers an out-of-bounds read, related to \"Improper Indexing.\"",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2014-10-31T14:55:11.143",
    "last_modified": "2024-11-21T02:19:13.140",
    "fix_date": "2014-10-23T23:23:01Z"
  },
  "references": [
    {
      "url": "http://www.securityfocus.com/bid/70812",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.zerodayinitiative.com/advisories/ZDI-14-370/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/bittorrent/bootstrap-dht/commit/bbc0b7191e3f48461ca6e5b1b34bdf4b3f1e79a9",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/70812",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.zerodayinitiative.com/advisories/ZDI-14-370/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/bittorrent/bootstrap-dht/commit/bbc0b7191e3f48461ca6e5b1b34bdf4b3f1e79a9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:30.030482",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "bootstrap-dht",
    "owner": "bittorrent",
    "created_at": "2013-11-01T22:51:57Z",
    "updated_at": "2025-01-13T23:03:27Z",
    "pushed_at": "2020-06-25T14:47:51Z",
    "size": 236,
    "stars": 415,
    "forks": 70,
    "open_issues": 8,
    "watchers": 415,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 537357,
      "Python": 8723
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:02:20.528762"
  }
}