{
  "cve_id": "CVE-2014-9620",
  "github_data": {
    "repository": "file/file",
    "fix_commit": "ce90e05774dd77d86cfc8dfa6da57b32816841c4",
    "related_commits": [
      "ce90e05774dd77d86cfc8dfa6da57b32816841c4",
      "ce90e05774dd77d86cfc8dfa6da57b32816841c4"
    ],
    "patch_url": "https://github.com/file/file/commit/ce90e05774dd77d86cfc8dfa6da57b32816841c4.patch",
    "fix_commit_details": {
      "sha": "ce90e05774dd77d86cfc8dfa6da57b32816841c4",
      "commit_date": "2014-12-16T23:18:40Z",
      "author": {
        "login": "zoulasc",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "- Add a limit to the number of ELF notes processed (Suggested by Alexander",
        "length": 213,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 490,
        "additions": 292,
        "deletions": 198
      },
      "files": [
        {
          "filename": "ChangeLog",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -1,3 +1,8 @@\n+2014-12-16  18:10  Christos Zoulas <christos@zoulas.com>\n+\t\n+\t* restructure elf note printing to avoid repeated messages\n+\t* add note limit, suggested by Alexander Cherepanov\n+\n 2014-12-16  16:53  Christos Zoulas <christos@zoulas.com>\n \t\n \t* Bail out on partial pread()'s (Alexander Cherepanov)"
        },
        {
          "filename": "doc/file.man",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -1,5 +1,5 @@\n-.\\\" $File: file.man,v 1.109 2014/11/28 02:35:05 christos Exp $\n-.Dd November 27, 2014\n+.\\\" $File: file.man,v 1.110 2014/11/28 02:46:39 christos Exp $\n+.Dd December 16, 2014\n .Dt FILE __CSECTION__\n .Os\n .Sh NAME\n@@ -310,6 +310,7 @@ Set various parameter limits.\n .It Sy \"Name\" Ta Sy \"Default\" Ta Sy \"Explanation\"\n .It Li indir Ta 15 Ta recursion limit for indirect magic\n .It Li name Ta 30 Ta use count limit for name/use magic\n+.It Li elf_notes Ta 256 Ta max ELF notes processed\n .It Li elf_phnum Ta 128 Ta max ELF program sections processed\n .It Li elf_shnum Ta 32768 Ta max ELF sections processed\n .El"
        },
        {
          "filename": "doc/libmagic.man",
          "status": "modified",
          "additions": 9,
          "deletions": 4,
          "patch": "@@ -1,4 +1,4 @@\n-.\\\" $File: libmagic.man,v 1.32 2014/11/28 02:35:05 christos Exp $\n+.\\\" $File: libmagic.man,v 1.33 2014/11/28 02:46:39 christos Exp $\n .\\\"\n .\\\" Copyright (c) Christos Zoulas 2003.\n .\\\" All Rights Reserved.\n@@ -25,7 +25,7 @@\n .\\\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n .\\\" SUCH DAMAGE.\n .\\\"\n-.Dd November 27, 2014\n+.Dd December 16, 2014\n .Dt LIBMAGIC 3\n .Os\n .Sh NAME\n@@ -284,6 +284,7 @@ library.\n .It Sy \"Parameter\" Ta Sy \"Type\" Ta Sy \"Default\"\n .It Li MAGIC_PARAM_INDIR_MAX Ta size_t Ta 15\n .It Li MAGIC_PARAM_NAME_MAX Ta size_t Ta 30\n+.It Li MAGIC_PARAM_ELF_NOTES_MAX Ta size_t Ta 256\n .It Li MAGIC_PARAM_ELF_PHNUM_MAX Ta size_t Ta 128\n .It Li MAGIC_PARAM_ELF_SHNUM_MAX Ta size_t Ta 32768\n .El\n@@ -303,12 +304,16 @@ The\n parameter controls the maximum number of calls for name/use.\n .Pp\n The\n+.Dv MAGIC_PARAM_NOTES_MAX\n+parameter controls how many ELF notes will be processed.\n+.Pp\n+The\n .Dv MAGIC_PARAM_PHNUM_MAX\n-parameter controls how many elf program sections will be processed.\n+parameter controls how many ELF program sections will be processed.\n .Pp\n The\n .Dv MAGIC_PARAM_SHNUM_MAX\n-parameter controls how many elf sections will be processed.\n+parameter controls how many ELF sections will be processed.\n .Pp\n The\n .Fn magic_version"
        },
        {
          "filename": "src/apprentice.c",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -32,7 +32,7 @@\n #include \"file.h\"\n \n #ifndef\tlint\n-FILE_RCSID(\"@(#)$File: apprentice.c,v 1.226 2014/11/28 02:35:05 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: apprentice.c,v 1.227 2014/11/28 02:46:39 christos Exp $\")\n #endif\t/* lint */\n \n #include \"magic.h\"\n@@ -528,6 +528,7 @@ file_ms_alloc(int flags)\n \tms->name_max = FILE_NAME_MAX;\n \tms->elf_shnum_max = FILE_ELF_SHNUM_MAX;\n \tms->elf_phnum_max = FILE_ELF_PHNUM_MAX;\n+\tms->elf_notes_max = FILE_ELF_NOTES_MAX;\n \treturn ms;\n free:\n \tfree(ms);"
        },
        {
          "filename": "src/elfclass.h",
          "status": "modified",
          "additions": 10,
          "deletions": 6,
          "patch": "@@ -32,17 +32,18 @@\n \tswap = (u.c[sizeof(int32_t) - 1] + 1) != elfhdr.e_ident[EI_DATA];\n \n \ttype = elf_getu16(swap, elfhdr.e_type);\n+\tnotecount = ms->elf_notes_max;\n \tswitch (type) {\n #ifdef ELFCORE\n \tcase ET_CORE:\n \t\tphnum = elf_getu16(swap, elfhdr.e_phnum);\n \t\tif (phnum > ms->elf_phnum_max)\n-\t\t\treturn toomany(ms, \"program\", phnum);\n+\t\t\treturn toomany(ms, \"program headers\", phnum);\n \t\tflags |= FLAGS_IS_CORE;\n \t\tif (dophn_core(ms, clazz, swap, fd,\n \t\t    (off_t)elf_getu(swap, elfhdr.e_phoff), phnum,\n \t\t    (size_t)elf_getu16(swap, elfhdr.e_phentsize),\n-\t\t    fsize, &flags) == -1)\n+\t\t    fsize, &flags, &notecount) == -1)\n \t\t\treturn -1;\n \t\tbreak;\n #endif\n@@ -57,22 +58,25 @@\n \t\tif (dophn_exec(ms, clazz, swap, fd,\n \t\t    (off_t)elf_getu(swap, elfhdr.e_phoff), phnum,\n \t\t    (size_t)elf_getu16(swap, elfhdr.e_phentsize),\n-\t\t    fsize, &flags, shnum) == -1)\n+\t\t    fsize, shnum, &flags, &notecount) == -1)\n \t\t\treturn -1;\n \t\t/*FALLTHROUGH*/\n \tcase ET_REL:\n \t\tshnum = elf_getu16(swap, elfhdr.e_shnum);\n \t\tif (shnum > ms->elf_shnum_max)\n-\t\t\treturn toomany(ms, \"section\", shnum);\n+\t\t\treturn toomany(ms, \"section headers\", shnum);\n \t\tif (doshn(ms, clazz, swap, fd,\n \t\t    (off_t)elf_getu(swap, elfhdr.e_shoff), shnum,\n \t\t    (size_t)elf_getu16(swap, elfhdr.e_shentsize),\n-\t\t    fsize, &flags, elf_getu16(swap, elfhdr.e_machine),\n-\t\t    (int)elf_getu16(swap, elfhdr.e_shstrndx)) == -1)\n+\t\t    fsize, elf_getu16(swap, elfhdr.e_machine),\n+\t\t    (int)elf_getu16(swap, elfhdr.e_shstrndx),\n+\t\t    &flags, &notecount) == -1)\n \t\t\treturn -1;\n \t\tbreak;\n \n \tdefault:\n \t\tbreak;\n \t}\n+\tif (notecount == 0)\n+\t\treturn toomany(ms, \"notes\", ms->elf_notes_max);\n \treturn 1;"
        },
        {
          "filename": "src/file.c",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -32,7 +32,7 @@\n #include \"file.h\"\n \n #ifndef\tlint\n-FILE_RCSID(\"@(#)$File: file.c,v 1.158 2014/11/28 02:35:05 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: file.c,v 1.159 2014/11/28 02:46:39 christos Exp $\")\n #endif\t/* lint */\n \n #include \"magic.h\"\n@@ -125,6 +125,7 @@ private struct {\n \t{ \"name\",\tMAGIC_PARAM_NAME_MAX, 0 },\n \t{ \"elf_phnum\",\tMAGIC_PARAM_ELF_PHNUM_MAX, 0 },\n \t{ \"elf_shnum\",\tMAGIC_PARAM_ELF_SHNUM_MAX, 0 },\n+\t{ \"elf_notes\",\tMAGIC_PARAM_ELF_NOTES_MAX, 0 },\n };\n \n private char *progname;\t\t/* used throughout \t\t*/"
        },
        {
          "filename": "src/file.h",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -27,7 +27,7 @@\n  */\n /*\n  * file.h - definitions for file(1) program\n- * @(#)$File: file.h,v 1.161 2014/12/04 15:56:46 christos Exp $\n+ * @(#)$File: file.h,v 1.162 2014/12/11 12:34:24 christos Exp $\n  */\n \n #ifndef __file_h__\n@@ -407,10 +407,12 @@ struct magic_set {\n \tuint16_t name_max;\n \tuint16_t elf_shnum_max;\n \tuint16_t elf_phnum_max;\n+\tuint16_t elf_notes_max;\n #define\tFILE_INDIR_MAX\t\t\t15\n #define\tFILE_NAME_MAX\t\t\t30\n #define\tFILE_ELF_SHNUM_MAX\t\t32768\n #define\tFILE_ELF_PHNUM_MAX\t\t128\n+#define\tFILE_ELF_NOTES_MAX\t\t256\n };\n \n /* Type for Unicode characters */"
        },
        {
          "filename": "src/file_opts.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -46,6 +46,7 @@ OPT('p', \"preserve-date\", 0, \"        preserve access times on files\\n\")\n OPT('P', \"parameter\", 0, \"            set file engine parameter limits\\n\"\n     \"                               indir        15 recursion limit for indirection\\n\"\n     \"                               name         30 use limit for name/use magic\\n\"\n+    \"                               elf_notes   256 max ELF notes processed\\n\"\n     \"                               elf_phnum   128 max ELF prog sections processed\\n\"\n     \"                               elf_shnum 32768 max ELF sections processed\\n\")\n OPT('r', \"raw\", 0, \"                  don't translate unprintable chars to \\\\ooo\\n\")"
        },
        {
          "filename": "src/magic.c",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -33,7 +33,7 @@\n #include \"file.h\"\n \n #ifndef\tlint\n-FILE_RCSID(\"@(#)$File: magic.c,v 1.89 2014/11/28 02:46:39 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: magic.c,v 1.90 2014/12/04 15:56:46 christos Exp $\")\n #endif\t/* lint */\n \n #include \"magic.h\"\n@@ -554,6 +554,9 @@ magic_setparam(struct magic_set *ms, int param, const void *val)\n \tcase MAGIC_PARAM_ELF_SHNUM_MAX:\n \t\tms->elf_shnum_max = *(const size_t *)val;\n \t\treturn 0;\n+\tcase MAGIC_PARAM_ELF_NOTES_MAX:\n+\t\tms->elf_notes_max = *(const size_t *)val;\n+\t\treturn 0;\n \tdefault:\n \t\terrno = EINVAL;\n \t\treturn -1;\n@@ -576,6 +579,9 @@ magic_getparam(struct magic_set *ms, int param, void *val)\n \tcase MAGIC_PARAM_ELF_SHNUM_MAX:\n \t\t*(size_t *)val = ms->elf_shnum_max;\n \t\treturn 0;\n+\tcase MAGIC_PARAM_ELF_NOTES_MAX:\n+\t\t*(size_t *)val = ms->elf_notes_max;\n+\t\treturn 0;\n \tdefault:\n \t\terrno = EINVAL;\n \t\treturn -1;"
        },
        {
          "filename": "src/magic.h.in",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -107,6 +107,7 @@ int magic_errno(magic_t);\n #define MAGIC_PARAM_NAME_MAX\t\t1\n #define MAGIC_PARAM_ELF_PHNUM_MAX\t2\n #define MAGIC_PARAM_ELF_SHNUM_MAX\t3\n+#define MAGIC_PARAM_ELF_NOTES_MAX\t4\n \n int magic_setparam(magic_t, int, const void *);\n int magic_getparam(magic_t, int, void *);"
        },
        {
          "filename": "src/readelf.c",
          "status": "modified",
          "additions": 249,
          "deletions": 182,
          "patch": "@@ -27,7 +27,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: readelf.c,v 1.114 2014/12/11 14:19:36 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: readelf.c,v 1.115 2014/12/16 20:53:05 christos Exp $\")\n #endif\n \n #ifdef BUILTIN_ELF\n@@ -43,14 +43,14 @@ FILE_RCSID(\"@(#)$File: readelf.c,v 1.114 2014/12/11 14:19:36 christos Exp $\")\n \n #ifdef\tELFCORE\n private int dophn_core(struct magic_set *, int, int, int, off_t, int, size_t,\n-    off_t, int *);\n+    off_t, int *, uint16_t *);\n #endif\n private int dophn_exec(struct magic_set *, int, int, int, off_t, int, size_t,\n-    off_t, int *, int);\n+    off_t, int, int *, uint16_t *);\n private int doshn(struct magic_set *, int, int, int, off_t, int, size_t,\n-    off_t, int *, int, int);\n+    off_t, int, int, int *, uint16_t *);\n private size_t donote(struct magic_set *, void *, size_t, size_t, int,\n-    int, size_t, int *);\n+    int, size_t, int *, uint16_t *);\n \n #define\tELF_ALIGN(a)\t((((a) + align - 1) / align) * align)\n \n@@ -67,7 +67,7 @@ private uint64_t getu64(int, uint64_t);\n private int\n toomany(struct magic_set *ms, const char *name, uint16_t num)\n {\n-\tif (file_printf(ms, \", too many %s header sections (%u)\", name, num\n+\tif (file_printf(ms, \", too many %s (%u)\", name, num\n \t    ) == -1)\n \t\treturn -1;\n \treturn 0;\n@@ -293,15 +293,19 @@ private const char os_style_names[][8] = {\n \t\"NetBSD\",\n };\n \n-#define FLAGS_DID_CORE\t\t0x01\n-#define FLAGS_DID_NOTE\t\t0x02\n-#define FLAGS_DID_BUILD_ID\t0x04\n-#define FLAGS_DID_CORE_STYLE\t0x08\n-#define FLAGS_IS_CORE\t\t0x10\n+#define FLAGS_DID_CORE\t\t\t0x001\n+#define FLAGS_DID_OS_NOTE\t\t0x002\n+#define FLAGS_DID_BUILD_ID\t\t0x004\n+#define FLAGS_DID_CORE_STYLE\t\t0x008\n+#define FLAGS_DID_NETBSD_PAX\t\t0x010\n+#define FLAGS_DID_NETBSD_MARCH\t\t0x020\n+#define FLAGS_DID_NETBSD_CMODEL\t\t0x040\n+#define FLAGS_DID_NETBSD_UNKNOWN\t0x080\n+#define FLAGS_IS_CORE\t\t\t0x100\n \n private int\n dophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n-    int num, size_t size, off_t fsize, int *flags)\n+    int num, size_t size, off_t fsize, int *flags, uint16_t *notecount)\n {\n \tElf32_Phdr ph32;\n \tElf64_Phdr ph64;\n@@ -347,7 +351,7 @@ dophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n \t\t\tif (offset >= (size_t)bufsize)\n \t\t\t\tbreak;\n \t\t\toffset = donote(ms, nbuf, offset, (size_t)bufsize,\n-\t\t\t    clazz, swap, 4, flags);\n+\t\t\t    clazz, swap, 4, flags, notecount);\n \t\t\tif (offset == 0)\n \t\t\t\tbreak;\n \n@@ -477,133 +481,127 @@ do_note_freebsd_version(struct magic_set *ms, int swap, void *v)\n \t}\n }\n \n-private size_t\n-donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n-    int clazz, int swap, size_t align, int *flags)\n+private int\n+do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n+    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n+    size_t noff, size_t doff, int *flags)\n {\n-\tElf32_Nhdr nh32;\n-\tElf64_Nhdr nh64;\n-\tsize_t noff, doff;\n-#ifdef ELFCORE\n-\tint os_style = -1;\n-#endif\n-\tuint32_t namesz, descsz;\n-\tunsigned char *nbuf = CAST(unsigned char *, vbuf);\n-\tchar sbuf[512];\n-\n-\tif (xnh_sizeof + offset > size) {\n-\t\t/*\n-\t\t * We're out of note headers.\n-\t\t */\n-\t\treturn xnh_sizeof + offset;\n-\t}\n-\n-\t(void)memcpy(xnh_addr, &nbuf[offset], xnh_sizeof);\n-\toffset += xnh_sizeof;\n-\n-\tnamesz = xnh_namesz;\n-\tdescsz = xnh_descsz;\n-\tif ((namesz == 0) && (descsz == 0)) {\n-\t\t/*\n-\t\t * We're out of note headers.\n-\t\t */\n-\t\treturn (offset >= size) ? offset : size;\n-\t}\n-\n-\tif (namesz & 0x80000000) {\n-\t    (void)file_printf(ms, \", bad note name size 0x%lx\",\n-\t\t(unsigned long)namesz);\n-\t    return 0;\n-\t}\n-\n-\tif (descsz & 0x80000000) {\n-\t    (void)file_printf(ms, \", bad note description size 0x%lx\",\n-\t\t(unsigned long)descsz);\n-\t    return 0;\n-\t}\n-\n-\n-\tnoff = offset;\n-\tdoff = ELF_ALIGN(offset + namesz);\n-\n-\tif (offset + namesz > size) {\n-\t\t/*\n-\t\t * We're past the end of the buffer.\n-\t\t */\n-\t\treturn doff;\n-\t}\n-\n-\toffset = ELF_ALIGN(doff + descsz);\n-\tif (doff + descsz > size) {\n-\t\t/*\n-\t\t * We're past the end of the buffer.\n-\t\t */\n-\t\treturn (offset >= size) ? offset : size;\n+\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n+\t    type == NT_GNU_BUILD_ID && (descsz == 16 || descsz == 20)) {\n+\t\tuint8_t desc[20];\n+\t\tuint32_t i;\n+\t\t*flags |= FLAGS_DID_BUILD_ID;\n+\t\tif (file_printf(ms, \", BuildID[%s]=\", descsz == 16 ? \"md5/uuid\" :\n+\t\t    \"sha1\") == -1)\n+\t\t\treturn 1;\n+\t\t(void)memcpy(desc, &nbuf[doff], descsz);\n+\t\tfor (i = 0; i < descsz; i++)\n+\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n+\t\t\treturn 1;\n+\t\treturn 1;\n \t}\n+\treturn 0;\n+}\n \n-\tif ((*flags & (FLAGS_DID_NOTE|FLAGS_DID_BUILD_ID)) ==\n-\t    (FLAGS_DID_NOTE|FLAGS_DID_BUILD_ID))\n-\t\tgoto core;\n-\n+private int\n+do_os_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n+    int swap, uint32_t namesz, uint32_t descsz,\n+    size_t noff, size_t doff, int *flags)\n+{\n \tif (namesz == 5 && strcmp((char *)&nbuf[noff], \"SuSE\") == 0 &&\n-\t    xnh_type == NT_GNU_VERSION && descsz == 2) {\n+\t    type == NT_GNU_VERSION && descsz == 2) {\n+\t    *flags |= FLAGS_DID_OS_NOTE;\n \t    file_printf(ms, \", for SuSE %d.%d\", nbuf[doff], nbuf[doff + 1]);\n+\t    return 1;\n \t}\n+\n \tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n-\t    xnh_type == NT_GNU_VERSION && descsz == 16) {\n+\t    type == NT_GNU_VERSION && descsz == 16) {\n \t\tuint32_t desc[4];\n \t\t(void)memcpy(desc, &nbuf[doff], sizeof(desc));\n \n+\t\t*flags |= FLAGS_DID_OS_NOTE;\n \t\tif (file_printf(ms, \", for GNU/\") == -1)\n-\t\t\treturn size;\n+\t\t\treturn 1;\n \t\tswitch (elf_getu32(swap, desc[0])) {\n \t\tcase GNU_OS_LINUX:\n \t\t\tif (file_printf(ms, \"Linux\") == -1)\n-\t\t\t\treturn size;\n+\t\t\t\treturn 1;\n \t\t\tbreak;\n \t\tcase GNU_OS_HURD:\n \t\t\tif (file_printf(ms, \"Hurd\") == -1)\n-\t\t\t\treturn size;\n+\t\t\t\treturn 1;\n \t\t\tbreak;\n \t\tcase GNU_OS_SOLARIS:\n \t\t\tif (file_printf(ms, \"Solaris\") == -1)\n-\t\t\t\treturn size;\n+\t\t\t\treturn 1;\n \t\t\tbreak;\n \t\tcase GNU_OS_KFREEBSD:\n \t\t\tif (file_printf(ms, \"kFreeBSD\") == -1)\n-\t\t\t\treturn size;\n+\t\t\t\treturn 1;\n \t\t\tbreak;\n \t\tcase GNU_OS_KNETBSD:\n \t\t\tif (file_printf(ms, \"kNetBSD\") == -1)\n-\t\t\t\treturn size;\n+\t\t\t\treturn 1;\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tif (file_printf(ms, \"<unknown>\") == -1)\n-\t\t\t\treturn size; \n+\t\t\t\treturn 1; \n \t\t}\n \t\tif (file_printf(ms, \" %d.%d.%d\", elf_getu32(swap, desc[1]),\n \t\t    elf_getu32(swap, desc[2]), elf_getu32(swap, desc[3])) == -1)\n-\t\t\treturn size;\n-\t\t*flags |= FLAGS_DID_NOTE;\n-\t\treturn size;\n+\t\t\treturn 1;\n+\t\treturn 1;\n \t}\n \n-\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n-\t    xnh_type == NT_GNU_BUILD_ID && (descsz == 16 || descsz == 20)) {\n-\t    uint8_t desc[20];\n-\t    uint32_t i;\n-\t    if (file_printf(ms, \", BuildID[%s]=\", descsz == 16 ? \"md5/uuid\" :\n-\t\t\"sha1\") == -1)\n-\t\t    return size;\n-\t    (void)memcpy(desc, &nbuf[doff], descsz);\n-\t    for (i = 0; i < descsz; i++)\n-\t\tif (file_printf(ms, \"%02x\", desc[i]) == -1)\n-\t\t    return size;\n-\t    *flags |= FLAGS_DID_BUILD_ID;\n+\tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n+\t    \tif (type == NT_NETBSD_VERSION && descsz == 4) {\n+\t\t\t*flags |= FLAGS_DID_OS_NOTE;\n+\t\t\tdo_note_netbsd_version(ms, swap, &nbuf[doff]);\n+\t\t\treturn 1;\n+\t\t}\n+\t}\n+\n+\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0) {\n+\t    \tif (type == NT_FREEBSD_VERSION && descsz == 4) {\n+\t\t\t*flags |= FLAGS_DID_OS_NOTE;\n+\t\t\tdo_note_freebsd_version(ms, swap, &nbuf[doff]);\n+\t\t\treturn 1;\n+\t\t}\n \t}\n \n+\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"OpenBSD\") == 0 &&\n+\t    type == NT_OPENBSD_VERSION && descsz == 4) {\n+\t\t*flags |= FLAGS_DID_OS_NOTE;\n+\t\tif (file_printf(ms, \", for OpenBSD\") == -1)\n+\t\t\treturn 1;\n+\t\t/* Content of note is always 0 */\n+\t\treturn 1;\n+\t}\n+\n+\tif (namesz == 10 && strcmp((char *)&nbuf[noff], \"DragonFly\") == 0 &&\n+\t    type == NT_DRAGONFLY_VERSION && descsz == 4) {\n+\t\tuint32_t desc;\n+\t\t*flags |= FLAGS_DID_OS_NOTE;\n+\t\tif (file_printf(ms, \", for DragonFly\") == -1)\n+\t\t\treturn 1;\n+\t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));\n+\t\tdesc = elf_getu32(swap, desc);\n+\t\tif (file_printf(ms, \" %d.%d.%d\", desc / 100000,\n+\t\t    desc / 10000 % 10, desc % 10000) == -1)\n+\t\t\treturn 1;\n+\t\treturn 1;\n+\t}\n+\treturn 0;\n+}\n+\n+private int\n+do_pax_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n+    int swap, uint32_t namesz, uint32_t descsz,\n+    size_t noff, size_t doff, int *flags)\n+{\n \tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"PaX\") == 0 &&\n-\t    xnh_type == NT_NETBSD_PAX && descsz == 4) {\n+\t    type == NT_NETBSD_PAX && descsz == 4) {\n \t\tstatic const char *pax[] = {\n \t\t    \"+mprotect\",\n \t\t    \"-mprotect\",\n@@ -616,80 +614,32 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t\tsize_t i;\n \t\tint did = 0;\n \n+\t\t*flags |= FLAGS_DID_NETBSD_PAX;\n \t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));\n \t\tdesc = elf_getu32(swap, desc);\n \n \t\tif (desc && file_printf(ms, \", PaX: \") == -1)\n-\t\t\treturn size;\n+\t\t\treturn 1;\n \n \t\tfor (i = 0; i < __arraycount(pax); i++) {\n \t\t\tif (((1 << i) & desc) == 0)\n \t\t\t\tcontinue;\n \t\t\tif (file_printf(ms, \"%s%s\", did++ ? \",\" : \"\",\n \t\t\t    pax[i]) == -1)\n-\t\t\t\treturn size;\n-\t\t}\n-\t}\n-\n-\tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n-\t\tswitch (xnh_type) {\n-\t\tcase NT_NETBSD_VERSION:\n-\t\t\tif (descsz == 4) {\n-\t\t\t\tdo_note_netbsd_version(ms, swap, &nbuf[doff]);\n-\t\t\t\t*flags |= FLAGS_DID_NOTE;\n-\t\t\t\treturn size;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tcase NT_NETBSD_MARCH:\n-\t\t\tif (file_printf(ms, \", compiled for: %.*s\", (int)descsz,\n-\t\t\t    (const char *)&nbuf[doff]) == -1)\n-\t\t\t\treturn size;\n-\t\t\tbreak;\n-\t\tcase NT_NETBSD_CMODEL:\n-\t\t\tif (file_printf(ms, \", compiler model: %.*s\",\n-\t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n-\t\t\t\treturn size;\n-\t\t\tbreak;\n-\t\tdefault:\n-\t\t\tif (file_printf(ms, \", note=%u\", xnh_type) == -1)\n-\t\t\t\treturn size;\n-\t\t\tbreak;\n-\t\t}\n-\t\treturn size;\n-\t}\n-\n-\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0) {\n-\t    \tif (xnh_type == NT_FREEBSD_VERSION && descsz == 4) {\n-\t\t\tdo_note_freebsd_version(ms, swap, &nbuf[doff]);\n-\t\t\t*flags |= FLAGS_DID_NOTE;\n-\t\t\treturn size;\n+\t\t\t\treturn 1;\n \t\t}\n+\t\treturn 1;\n \t}\n+\treturn 0;\n+}\n \n-\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"OpenBSD\") == 0 &&\n-\t    xnh_type == NT_OPENBSD_VERSION && descsz == 4) {\n-\t\tif (file_printf(ms, \", for OpenBSD\") == -1)\n-\t\t\treturn size;\n-\t\t/* Content of note is always 0 */\n-\t\t*flags |= FLAGS_DID_NOTE;\n-\t\treturn size;\n-\t}\n-\n-\tif (namesz == 10 && strcmp((char *)&nbuf[noff], \"DragonFly\") == 0 &&\n-\t    xnh_type == NT_DRAGONFLY_VERSION && descsz == 4) {\n-\t\tuint32_t desc;\n-\t\tif (file_printf(ms, \", for DragonFly\") == -1)\n-\t\t\treturn size;\n-\t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));\n-\t\tdesc = elf_getu32(swap, desc);\n-\t\tif (file_printf(ms, \" %d.%d.%d\", desc / 100000,\n-\t\t    desc / 10000 % 10, desc % 10000) == -1)\n-\t\t\treturn size;\n-\t\t*flags |= FLAGS_DID_NOTE;\n-\t\treturn size;\n-\t}\n-\n-core:\n+private int\n+do_core_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n+    int swap, uint32_t namesz, uint32_t descsz,\n+    size_t noff, size_t doff, int *flags, size_t size, int clazz)\n+{\n+#ifdef ELFCORE\n+\tint os_style = -1;\n \t/*\n \t * Sigh.  The 2.0.36 kernel in Debian 2.1, at\n \t * least, doesn't correctly implement name\n@@ -718,20 +668,17 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t\tos_style = OS_STYLE_NETBSD;\n \t}\n \n-#ifdef ELFCORE\n-\tif ((*flags & FLAGS_DID_CORE) != 0)\n-\t\treturn size;\n-\n \tif (os_style != -1 && (*flags & FLAGS_DID_CORE_STYLE) == 0) {\n \t\tif (file_printf(ms, \", %s-style\", os_style_names[os_style])\n \t\t    == -1)\n-\t\t\treturn size;\n+\t\t\treturn 1;\n \t\t*flags |= FLAGS_DID_CORE_STYLE;\n \t}\n \n \tswitch (os_style) {\n \tcase OS_STYLE_NETBSD:\n-\t\tif (xnh_type == NT_NETBSD_CORE_PROCINFO) {\n+\t\tif (type == NT_NETBSD_CORE_PROCINFO) {\n+\t\t\tchar sbuf[512];\n \t\t\tuint32_t signo;\n \t\t\t/*\n \t\t\t * Extract the program name.  It is at\n@@ -741,7 +688,7 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t\t\tif (file_printf(ms, \", from '%.31s'\",\n \t\t\t    file_printable(sbuf, sizeof(sbuf),\n \t\t\t    (const char *)&nbuf[doff + 0x7c])) == -1)\n-\t\t\t\treturn size;\n+\t\t\t\treturn 1;\n \t\t\t\n \t\t\t/*\n \t\t\t * Extract the signal number.  It is at\n@@ -751,14 +698,14 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t\t\t    sizeof(signo));\n \t\t\tif (file_printf(ms, \" (signal %u)\",\n \t\t\t    elf_getu32(swap, signo)) == -1)\n-\t\t\t\treturn size;\n+\t\t\t\treturn 1;\n \t\t\t*flags |= FLAGS_DID_CORE;\n-\t\t\treturn size;\n+\t\t\treturn 1;\n \t\t}\n \t\tbreak;\n \n \tdefault:\n-\t\tif (xnh_type == NT_PRPSINFO && *flags & FLAGS_IS_CORE) {\n+\t\tif (type == NT_PRPSINFO && *flags & FLAGS_IS_CORE) {\n \t\t\tsize_t i, j;\n \t\t\tunsigned char c;\n \t\t\t/*\n@@ -826,7 +773,7 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t\t\t\t * Try next offsets, in case this match is\n \t\t\t\t * in the middle of a string.\n \t\t\t\t */\n-\t\t\t\tfor (k = i + 1 ; k < NOFFSETS ; k++) {\n+\t\t\t\tfor (k = i + 1 ; k < NOFFSETS; k++) {\n \t\t\t\t\tsize_t no;\n \t\t\t\t\tint adjust = 1;\n \t\t\t\t\tif (prpsoffsets(k) >= prpsoffsets(i))\n@@ -851,9 +798,9 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t\t\t\t\tcp--;\n \t\t\t\tif (file_printf(ms, \", from '%.*s'\",\n \t\t\t\t    (int)(cp - cname), cname) == -1)\n-\t\t\t\t\treturn size;\n+\t\t\t\t\treturn 1;\n \t\t\t\t*flags |= FLAGS_DID_CORE;\n-\t\t\t\treturn size;\n+\t\t\t\treturn 1;\n \n \t\t\ttryanother:\n \t\t\t\t;\n@@ -862,6 +809,124 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t\tbreak;\n \t}\n #endif\n+\treturn 0;\n+}\n+\n+private size_t\n+donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n+    int clazz, int swap, size_t align, int *flags, uint16_t *notecount)\n+{\n+\tElf32_Nhdr nh32;\n+\tElf64_Nhdr nh64;\n+\tsize_t noff, doff;\n+\tuint32_t namesz, descsz;\n+\tunsigned char *nbuf = CAST(unsigned char *, vbuf);\n+\n+\tif (*notecount == 0)\n+\t\treturn 0;\n+\t--*notecount;\n+\n+\tif (xnh_sizeof + offset > size) {\n+\t\t/*\n+\t\t * We're out of note headers.\n+\t\t */\n+\t\treturn xnh_sizeof + offset;\n+\t}\n+\n+\t(void)memcpy(xnh_addr, &nbuf[offset], xnh_sizeof);\n+\toffset += xnh_sizeof;\n+\n+\tnamesz = xnh_namesz;\n+\tdescsz = xnh_descsz;\n+\tif ((namesz == 0) && (descsz == 0)) {\n+\t\t/*\n+\t\t * We're out of note headers.\n+\t\t */\n+\t\treturn (offset >= size) ? offset : size;\n+\t}\n+\n+\tif (namesz & 0x80000000) {\n+\t    (void)file_printf(ms, \", bad note name size 0x%lx\",\n+\t\t(unsigned long)namesz);\n+\t    return 0;\n+\t}\n+\n+\tif (descsz & 0x80000000) {\n+\t    (void)file_printf(ms, \", bad note description size 0x%lx\",\n+\t\t(unsigned long)descsz);\n+\t    return 0;\n+\t}\n+\n+\tnoff = offset;\n+\tdoff = ELF_ALIGN(offset + namesz);\n+\n+\tif (offset + namesz > size) {\n+\t\t/*\n+\t\t * We're past the end of the buffer.\n+\t\t */\n+\t\treturn doff;\n+\t}\n+\n+\toffset = ELF_ALIGN(doff + descsz);\n+\tif (doff + descsz > size) {\n+\t\t/*\n+\t\t * We're past the end of the buffer.\n+\t\t */\n+\t\treturn (offset >= size) ? offset : size;\n+\t}\n+\n+\tif ((*flags & FLAGS_DID_OS_NOTE) == 0) {\n+\t\tif (do_os_note(ms, nbuf, xnh_type, swap,\n+\t\t    namesz, descsz, noff, doff, flags))\n+\t\t\treturn size;\n+\t}\n+\n+\tif ((*flags & FLAGS_DID_BUILD_ID) == 0) {\n+\t\tif (do_bid_note(ms, nbuf, xnh_type, swap,\n+\t\t    namesz, descsz, noff, doff, flags))\n+\t\t\treturn size;\n+\t}\n+\t\t\n+\tif ((*flags & FLAGS_DID_NETBSD_PAX) == 0) {\n+\t\tif (do_pax_note(ms, nbuf, xnh_type, swap,\n+\t\t    namesz, descsz, noff, doff, flags))\n+\t\t\treturn size;\n+\t}\n+\n+\tif ((*flags & FLAGS_DID_CORE) == 0) {\n+\t\tif (do_core_note(ms, nbuf, xnh_type, swap,\n+\t\t    namesz, descsz, noff, doff, flags, size, clazz))\n+\t\t\treturn size;\n+\t}\n+\n+\tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n+\t\tswitch (xnh_type) {\n+\t    \tcase NT_NETBSD_VERSION:\n+\t\t\treturn size;\n+\t\tcase NT_NETBSD_MARCH:\n+\t\t\tif (*flags & FLAGS_DID_NETBSD_MARCH)\n+\t\t\t\treturn size;\n+\t\t\tif (file_printf(ms, \", compiled for: %.*s\", (int)descsz,\n+\t\t\t    (const char *)&nbuf[doff]) == -1)\n+\t\t\t\treturn size;\n+\t\t\tbreak;\n+\t\tcase NT_NETBSD_CMODEL:\n+\t\t\tif (*flags & FLAGS_DID_NETBSD_CMODEL)\n+\t\t\t\treturn size;\n+\t\t\tif (file_printf(ms, \", compiler model: %.*s\",\n+\t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n+\t\t\t\treturn size;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tif (*flags & FLAGS_DID_NETBSD_UNKNOWN)\n+\t\t\t\treturn size;\n+\t\t\tif (file_printf(ms, \", note=%u\", xnh_type) == -1)\n+\t\t\t\treturn size;\n+\t\t\tbreak;\n+\t\t}\n+\t\treturn size;\n+\t}\n+\n \treturn offset;\n }\n \n@@ -917,7 +982,8 @@ static const cap_desc_t cap_desc_386[] = {\n \n private int\n doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n-    size_t size, off_t fsize, int *flags, int mach, int strtab)\n+    size_t size, off_t fsize, int mach, int strtab, int *flags,\n+    uint16_t *notecount)\n {\n \tElf32_Shdr sh32;\n \tElf64_Shdr sh64;\n@@ -994,7 +1060,7 @@ doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n \t\t\t\tif (noff >= (off_t)xsh_size)\n \t\t\t\t\tbreak;\n \t\t\t\tnoff = donote(ms, nbuf, (size_t)noff,\n-\t\t\t\t    xsh_size, clazz, swap, 4, flags);\n+\t\t\t\t    xsh_size, clazz, swap, 4, flags, notecount);\n \t\t\t\tif (noff == 0)\n \t\t\t\t\tbreak;\n \t\t\t}\n@@ -1161,7 +1227,8 @@ doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n  */\n private int\n dophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n-    int num, size_t size, off_t fsize, int *flags, int sh_num)\n+    int num, size_t size, off_t fsize, int sh_num, int *flags,\n+    uint16_t *notecount)\n {\n \tElf32_Phdr ph32;\n \tElf64_Phdr ph64;\n@@ -1242,7 +1309,7 @@ dophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n \t\t\t\t\tbreak;\n \t\t\t\toffset = donote(ms, nbuf, offset,\n \t\t\t\t    (size_t)bufsize, clazz, swap, align,\n-\t\t\t\t    flags);\n+\t\t\t\t    flags, notecount);\n \t\t\t\tif (offset == 0)\n \t\t\t\t\tbreak;\n \t\t\t}\n@@ -1277,7 +1344,7 @@ file_tryelf(struct magic_set *ms, int fd, const unsigned char *buf,\n \tint flags = 0;\n \tElf32_Ehdr elf32hdr;\n \tElf64_Ehdr elf64hdr;\n-\tuint16_t type, phnum, shnum;\n+\tuint16_t type, phnum, shnum, notecount;\n \n \tif (ms->flags & (MAGIC_MIME|MAGIC_APPLE))\n \t\treturn 0;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "1778642b8ba3d947a779a36fcd81f8e807220a19",
            "date": "2024-12-31T19:57:14Z",
            "author_login": "zoulasc"
          },
          {
            "sha": "3dc6947b16641458a600bdfb7a23db5064887019",
            "date": "2024-12-31T19:50:33Z",
            "author_login": "zoulasc"
          },
          {
            "sha": "54b98feb13b49ec3a66cb151c4321629424a5e74",
            "date": "2024-12-31T19:41:08Z",
            "author_login": "zoulasc"
          },
          {
            "sha": "81e3eb0ca228239f5f2edccb2196da8e430f44bf",
            "date": "2024-12-31T19:38:03Z",
            "author_login": "zoulasc"
          },
          {
            "sha": "48b38ab6e30d113b68a200d29c237b97fdd531e8",
            "date": "2024-12-31T19:02:48Z",
            "author_login": "zoulasc"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-399",
    "description": "The ELF parser in file 5.08 through 5.21 allows remote attackers to cause a denial of service via a large number of notes.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2015-01-21T18:59:05.937",
    "last_modified": "2024-11-21T02:21:15.837",
    "fix_date": "2014-12-16T23:18:40Z"
  },
  "references": [
    {
      "url": "http://advisories.mageia.org/MGASA-2015-0040.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://mx.gw.com/pipermail/file/2014/001653.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://mx.gw.com/pipermail/file/2015/001660.html",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-0760.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2015/dsa-3121",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/01/17/9",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinapr2016-2952096.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/71715",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/file/file/commit/ce90e05774dd77d86cfc8dfa6da57b32816841c4",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/201503-08",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://usn.ubuntu.com/3686-1/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://advisories.mageia.org/MGASA-2015-0040.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://mx.gw.com/pipermail/file/2014/001653.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://mx.gw.com/pipermail/file/2015/001660.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-0760.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2015/dsa-3121",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/01/17/9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinapr2016-2952096.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/71715",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/file/file/commit/ce90e05774dd77d86cfc8dfa6da57b32816841c4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/201503-08",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://usn.ubuntu.com/3686-1/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:32.407078",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "file",
    "owner": "file",
    "created_at": "2011-01-28T15:20:14Z",
    "updated_at": "2025-01-14T07:46:32Z",
    "pushed_at": "2024-12-31T20:00:10Z",
    "size": 10253,
    "stars": 1318,
    "forks": 380,
    "open_issues": 0,
    "watchers": 1318,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 578279,
      "Makefile": 18126,
      "Python": 15517,
      "M4": 14679,
      "Shell": 3261,
      "Dockerfile": 870
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:14:52.128425"
  }
}