{
  "cve_id": "CVE-2014-9720",
  "github_data": {
    "repository": "tornadoweb/tornado",
    "fix_commit": "1c36307463b1e8affae100bf9386948e6c1b2308",
    "related_commits": [
      "1c36307463b1e8affae100bf9386948e6c1b2308",
      "1c36307463b1e8affae100bf9386948e6c1b2308"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "1c36307463b1e8affae100bf9386948e6c1b2308",
      "commit_date": "2014-05-26T19:44:58Z",
      "author": {
        "login": "bdarnell",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Change the xsrf cookie format to be masked with a random salt.",
        "length": 104,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 154,
        "additions": 101,
        "deletions": 53
      },
      "files": [
        {
          "filename": "tornado/test/web_test.py",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -2004,16 +2004,18 @@ def test_cross_user(self):\n \n     def test_refresh_token(self):\n         token = self.xsrf_token\n+        tokens_seen = set([token])\n         # A user's token is stable over time.  Refreshing the page in one tab\n         # might update the cookie while an older tab still has the old cookie\n         # in its DOM.  Simulate this scenario by passing a constant token\n         # in the body and re-querying for the token.\n         for i in range(5):\n             token = self.get_token(token)\n-            # Implementation detail: the same token is returned each time\n-            self.assertEqual(token, self.xsrf_token)\n+            # Tokens are encoded uniquely each time\n+            tokens_seen.add(token)\n             response = self.fetch(\n                 \"/\", method=\"POST\",\n                 body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)),\n                 headers=self.cookie_headers(token))\n             self.assertEqual(response.code, 200)\n+        self.assertEqual(len(tokens_seen), 6)"
        },
        {
          "filename": "tornado/test/websocket_test.py",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -11,6 +11,7 @@\n \n try:\n     import tornado.websocket\n+    from tornado.util import _websocket_mask_python\n except ImportError:\n     # The unittest module presents misleading errors on ImportError\n     # (it acts as if websocket_test could not be found, hiding the underlying\n@@ -19,7 +20,7 @@\n     traceback.print_exc()\n     raise\n \n-from tornado.websocket import WebSocketHandler, websocket_connect, WebSocketError, _websocket_mask_python\n+from tornado.websocket import WebSocketHandler, websocket_connect, WebSocketError\n \n try:\n     from tornado import speedups"
        },
        {
          "filename": "tornado/util.py",
          "status": "modified",
          "additions": 43,
          "deletions": 0,
          "patch": "@@ -12,11 +12,19 @@\n \n from __future__ import absolute_import, division, print_function, with_statement\n \n+import array\n import inspect\n+import os\n import sys\n import zlib\n \n \n+try:\n+    xrange  # py2\n+except NameError:\n+    xrange = range  # py3\n+\n+\n class ObjectDict(dict):\n     \"\"\"Makes a dictionary behave like an object, with attribute-style access.\n     \"\"\"\n@@ -265,6 +273,41 @@ def replace(self, new_value, args, kwargs):\n         return old_value, args, kwargs\n \n \n+def _websocket_mask_python(mask, data):\n+    \"\"\"Websocket masking function.\n+\n+    `mask` is a `bytes` object of length 4; `data` is a `bytes` object of any length.\n+    Returns a `bytes` object of the same length as `data` with the mask applied\n+    as specified in section 5.3 of RFC 6455.\n+\n+    This pure-python implementation may be replaced by an optimized version when available.\n+    \"\"\"\n+    mask = array.array(\"B\", mask)\n+    unmasked = array.array(\"B\", data)\n+    for i in xrange(len(data)):\n+        unmasked[i] = unmasked[i] ^ mask[i % 4]\n+    if hasattr(unmasked, 'tobytes'):\n+        # tostring was deprecated in py32.  It hasn't been removed,\n+        # but since we turn on deprecation warnings in our tests\n+        # we need to use the right one.\n+        return unmasked.tobytes()\n+    else:\n+        return unmasked.tostring()\n+\n+if (os.environ.get('TORNADO_NO_EXTENSION') or\n+    os.environ.get('TORNADO_EXTENSION') == '0'):\n+    # These environment variables exist to make it easier to do performance\n+    # comparisons; they are not guaranteed to remain supported in the future.\n+    _websocket_mask = _websocket_mask_python\n+else:\n+    try:\n+        from tornado.speedups import websocket_mask as _websocket_mask\n+    except ImportError:\n+        if os.environ.get('TORNADO_EXTENSION') == '1':\n+            raise\n+        _websocket_mask = _websocket_mask_python\n+\n+\n def doctests():\n     import doctest\n     return doctest.DocTestSuite()"
        },
        {
          "filename": "tornado/web.py",
          "status": "modified",
          "additions": 51,
          "deletions": 8,
          "patch": "@@ -72,7 +72,6 @@ def get(self):\n import tornado\n import traceback\n import types\n-import uuid\n \n from tornado.concurrent import Future\n from tornado import escape\n@@ -82,7 +81,7 @@ def get(self):\n from tornado import stack_context\n from tornado import template\n from tornado.escape import utf8, _unicode\n-from tornado.util import bytes_type, import_object, ObjectDict, raise_exc_info, unicode_type\n+from tornado.util import bytes_type, import_object, ObjectDict, raise_exc_info, unicode_type, _websocket_mask\n \n try:\n     from io import BytesIO  # python 3\n@@ -1071,14 +1070,56 @@ def xsrf_token(self):\n         See http://en.wikipedia.org/wiki/Cross-site_request_forgery\n         \"\"\"\n         if not hasattr(self, \"_xsrf_token\"):\n-            token = self.get_cookie(\"_xsrf\")\n-            if not token:\n-                token = binascii.b2a_hex(os.urandom(16))\n+            version, token, timestamp = self._get_raw_xsrf_token()\n+            mask = os.urandom(4)\n+            self._xsrf_token = b\"|\".join([\n+                b\"2\",\n+                binascii.b2a_hex(mask),\n+                binascii.b2a_hex(_websocket_mask(mask, token)),\n+                utf8(str(int(timestamp)))])\n+            if version is None or version != 2:\n                 expires_days = 30 if self.current_user else None\n-                self.set_cookie(\"_xsrf\", token, expires_days=expires_days)\n-            self._xsrf_token = token\n+                self.set_cookie(\"_xsrf\", self._xsrf_token,\n+                                expires_days=expires_days)\n         return self._xsrf_token\n \n+    def _get_raw_xsrf_token(self):\n+        if not hasattr(self, '_raw_xsrf_token'):\n+            cookie = self.get_cookie(\"_xsrf\")\n+            if cookie:\n+                version, token, timestamp = self._decode_xsrf_token(cookie)\n+            else:\n+                version, token, timestamp = None, None, None\n+            if token is None:\n+                version = None\n+                token = os.urandom(16)\n+                timestamp = time.time()\n+            self._raw_xsrf_token = (version, token, timestamp)\n+        return self._raw_xsrf_token\n+\n+    def _decode_xsrf_token(self, cookie):\n+        m = _signed_value_version_re.match(utf8(cookie))\n+        if m:\n+            version = int(m.group(1))\n+            if version == 2:\n+                _, mask, masked_token, timestamp = cookie.split(\"|\")\n+                mask = binascii.a2b_hex(utf8(mask))\n+                token = _websocket_mask(\n+                    mask, binascii.a2b_hex(utf8(masked_token)))\n+                timestamp = int(timestamp)\n+                return version, token, timestamp\n+            else:\n+                # Treat unknown versions as not present instead of failing.\n+                return None, None, None\n+        elif len(cookie) == 32:\n+            version = 1\n+            token = binascii.a2b_hex(cookie)\n+            # We don't have a usable timestamp in older versions.\n+            timestamp = int(time.time())\n+            return (version, token, timestamp)\n+        else:\n+            return None, None, None\n+\n     def check_xsrf_cookie(self):\n         \"\"\"Verifies that the ``_xsrf`` cookie matches the ``_xsrf`` argument.\n \n@@ -1105,7 +1146,9 @@ def check_xsrf_cookie(self):\n                  self.request.headers.get(\"X-Csrftoken\"))\n         if not token:\n             raise HTTPError(403, \"'_xsrf' argument missing from POST\")\n-        if not _time_independent_equals(utf8(self.xsrf_token), utf8(token)):\n+        _, token, _ = self._decode_xsrf_token(token)\n+        _, expected_token, _ = self._get_raw_xsrf_token()\n+        if not _time_independent_equals(utf8(token), utf8(expected_token)):\n             raise HTTPError(403, \"XSRF cookie does not match POST argument\")\n \n     def xsrf_form_html(self):"
        },
        {
          "filename": "tornado/websocket.py",
          "status": "modified",
          "additions": 1,
          "deletions": 42,
          "patch": "@@ -20,7 +20,6 @@\n from __future__ import absolute_import, division, print_function, with_statement\n # Author: Jacob Kristhammar, 2010\n \n-import array\n import base64\n import collections\n import functools\n@@ -39,12 +38,7 @@\n from tornado.log import gen_log, app_log\n from tornado.netutil import Resolver\n from tornado import simple_httpclient\n-from tornado.util import bytes_type, unicode_type\n-\n-try:\n-    xrange  # py2\n-except NameError:\n-    xrange = range  # py3\n+from tornado.util import bytes_type, unicode_type, _websocket_mask\n \n \n class WebSocketError(Exception):\n@@ -890,38 +884,3 @@ def websocket_connect(url, io_loop=None, callback=None, connect_timeout=None):\n     if callback is not None:\n         io_loop.add_future(conn.connect_future, callback)\n     return conn.connect_future\n-\n-\n-def _websocket_mask_python(mask, data):\n-    \"\"\"Websocket masking function.\n-\n-    `mask` is a `bytes` object of length 4; `data` is a `bytes` object of any length.\n-    Returns a `bytes` object of the same length as `data` with the mask applied\n-    as specified in section 5.3 of RFC 6455.\n-\n-    This pure-python implementation may be replaced by an optimized version when available.\n-    \"\"\"\n-    mask = array.array(\"B\", mask)\n-    unmasked = array.array(\"B\", data)\n-    for i in xrange(len(data)):\n-        unmasked[i] = unmasked[i] ^ mask[i % 4]\n-    if hasattr(unmasked, 'tobytes'):\n-        # tostring was deprecated in py32.  It hasn't been removed,\n-        # but since we turn on deprecation warnings in our tests\n-        # we need to use the right one.\n-        return unmasked.tobytes()\n-    else:\n-        return unmasked.tostring()\n-\n-if (os.environ.get('TORNADO_NO_EXTENSION') or\n-    os.environ.get('TORNADO_EXTENSION') == '0'):\n-    # These environment variables exist to make it easier to do performance\n-    # comparisons; they are not guaranteed to remain supported in the future.\n-    _websocket_mask = _websocket_mask_python\n-else:\n-    try:\n-        from tornado.speedups import websocket_mask as _websocket_mask\n-    except ImportError:\n-        if os.environ.get('TORNADO_EXTENSION') == '1':\n-            raise\n-        _websocket_mask = _websocket_mask_python"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "73a87a546229625a2c801847b182f447154c157d",
            "date": "2025-01-06T14:51:06Z",
            "author_login": "bdarnell"
          },
          {
            "sha": "c47d7d1fef86be7232d3f41386079465e3e244f5",
            "date": "2024-12-24T00:24:14Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "0a39ba8b6ac0beb48a3244098cfa72ce1f59f215",
            "date": "2024-12-05T21:34:29Z",
            "author_login": "bdarnell"
          },
          {
            "sha": "f4b3e9600e925ab57fc7b6ce250af175aa3e1356",
            "date": "2024-11-21T19:48:05Z",
            "author_login": "bdarnell"
          },
          {
            "sha": "f62afc31bc8908a2c9d0c21f74bc1447781e4782",
            "date": "2024-11-21T20:31:17Z",
            "author_login": "bdarnell"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-203",
    "description": "Tornado before 3.2.2 sends arbitrary responses that contain a fixed CSRF token and may be sent with HTTP compression, which makes it easier for remote attackers to conduct a BREACH attack and determine this token via a series of crafted requests.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-01-24T18:15:12.053",
    "last_modified": "2024-11-21T02:21:31.390",
    "fix_date": "2014-05-26T19:44:58Z"
  },
  "references": [
    {
      "url": "http://openwall.com/lists/oss-security/2015/05/19/4",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.tornadoweb.org/en/stable/releases/v3.2.2.html",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://bugzilla.novell.com/show_bug.cgi?id=930362",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1222816",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tornadoweb/tornado/commit/1c36307463b1e8affae100bf9386948e6c1b2308",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://openwall.com/lists/oss-security/2015/05/19/4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.tornadoweb.org/en/stable/releases/v3.2.2.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://bugzilla.novell.com/show_bug.cgi?id=930362",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1222816",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tornadoweb/tornado/commit/1c36307463b1e8affae100bf9386948e6c1b2308",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:37.486517",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "tornado",
    "owner": "tornadoweb",
    "created_at": "2009-09-09T04:55:16Z",
    "updated_at": "2025-01-25T20:34:14Z",
    "pushed_at": "2025-01-13T18:30:52Z",
    "size": 10446,
    "stars": 21808,
    "forks": 5520,
    "open_issues": 228,
    "watchers": 21808,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Python": 1600155,
      "Shell": 4070,
      "C": 1524,
      "Cython": 780,
      "HTML": 25
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:35:08.395947"
  }
}