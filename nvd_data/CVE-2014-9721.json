{
  "cve_id": "CVE-2014-9721",
  "github_data": {
    "repository": "zeromq/zeromq4-x",
    "fix_commit": "b6e3e0f601e2c1ec1f3aac880ed6a3fe63043e51",
    "related_commits": [
      "b6e3e0f601e2c1ec1f3aac880ed6a3fe63043e51",
      "b6e3e0f601e2c1ec1f3aac880ed6a3fe63043e51"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "b6e3e0f601e2c1ec1f3aac880ed6a3fe63043e51",
      "commit_date": "2014-12-05T08:08:38Z",
      "author": {
        "login": "hintjens",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #101 from hintjens/master",
        "length": 93,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 254,
        "additions": 197,
        "deletions": 57
      },
      "files": [
        {
          "filename": "NEWS",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -1,6 +1,8 @@\n-0MQ version 4.0.6 stable, released on 2015/xx/xx\n+0MQ version 4.0.6 stable, released on 2015/12/xx\n ================================================\n \n+* Fixed #1273 - V3 protocol handler vulnerable to downgrade attacks.\n+\n \n 0MQ version 4.0.5 stable, released on 2014/10/14\n ================================================"
        },
        {
          "filename": "src/session_base.cpp",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -323,6 +323,14 @@ int zmq::session_base_t::zap_connect ()\n     return 0;\n }\n \n+bool zmq::session_base_t::zap_enabled ()\n+{\n+    return (\n+         options.mechanism != ZMQ_NULL ||\n+        (options.mechanism == ZMQ_NULL && options.zap_domain.length() > 0)\n+    );\n+}\n+\n void zmq::session_base_t::process_attach (i_engine *engine_)\n {\n     zmq_assert (engine_ != NULL);"
        },
        {
          "filename": "src/session_base.hpp",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -68,7 +68,8 @@ namespace zmq\n         int push_msg (msg_t *msg_);\n \n         int zap_connect ();\n-\n+        bool zap_enabled ();\n+        \n         //  Fetches a message. Returns 0 if successful; -1 otherwise.\n         //  The caller is responsible for freeing the message when no\n         //  longer used."
        },
        {
          "filename": "src/stream_engine.cpp",
          "status": "modified",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -464,6 +464,11 @@ bool zmq::stream_engine_t::handshake ()\n     //  Is the peer using ZMTP/1.0 with no revision number?\n     //  If so, we send and receive rest of identity message\n     if (greeting_recv [0] != 0xff || !(greeting_recv [9] & 0x01)) {\n+        if (session->zap_enabled ()) {\n+            //  Reject ZMTP 1.0 connections if ZAP is enabled\n+            error ();\n+            return false;\n+        }\n         encoder = new (std::nothrow) v1_encoder_t (out_batch_size);\n         alloc_assert (encoder);\n \n@@ -505,6 +510,11 @@ bool zmq::stream_engine_t::handshake ()\n     }\n     else\n     if (greeting_recv [revision_pos] == ZMTP_1_0) {\n+        if (session->zap_enabled ()) {\n+            //  Reject ZMTP 1.0 connections if ZAP is enabled\n+            error ();\n+            return false;\n+        }\n         encoder = new (std::nothrow) v1_encoder_t (\n             out_batch_size);\n         alloc_assert (encoder);\n@@ -515,6 +525,11 @@ bool zmq::stream_engine_t::handshake ()\n     }\n     else\n     if (greeting_recv [revision_pos] == ZMTP_2_0) {\n+        if (session->zap_enabled ()) {\n+            //  Reject ZMTP 1.0 connections if ZAP is enabled\n+            error ();\n+            return false;\n+        }\n         encoder = new (std::nothrow) v2_encoder_t (out_batch_size);\n         alloc_assert (encoder);\n "
        },
        {
          "filename": "tests/test_security_curve.cpp",
          "status": "modified",
          "additions": 58,
          "deletions": 8,
          "patch": "@@ -18,12 +18,23 @@\n */\n \n #include \"testutil.hpp\"\n+#if defined (ZMQ_HAVE_WINDOWS)\n+#   include <winsock2.h>\n+#   include <ws2tcpip.h>\n+#   include <stdexcept>\n+#   define close closesocket\n+#else\n+#   include <sys/socket.h>\n+#   include <netinet/in.h>\n+#   include <arpa/inet.h>\n+#   include <unistd.h>\n+#endif\n \n //  We'll generate random test keys at startup\n-static char client_public [40];\n-static char client_secret [40];\n-static char server_public [40];\n-static char server_secret [40];\n+static char client_public [41];\n+static char client_secret [41];\n+static char server_public [41];\n+static char server_secret [41];\n \n //  --------------------------------------------------------------------------\n //  This methods receives and validates ZAP requestes (allowing or denying\n@@ -46,7 +57,7 @@ static void zap_handler (void *handler)\n         int size = zmq_recv (handler, client_key, 32, 0);\n         assert (size == 32);\n \n-        char client_key_text [40];\n+        char client_key_text [41];\n         zmq_z85_encode (client_key_text, client_key, 32);\n \n         assert (streq (version, \"1.0\"));\n@@ -181,8 +192,8 @@ int main (void)\n \n     //  Check CURVE security with bogus client credentials\n     //  This must be caught by the ZAP handler\n-    char bogus_public [40];\n-    char bogus_secret [40];\n+    char bogus_public [41];\n+    char bogus_secret [41];\n     zmq_curve_keypair (bogus_public, bogus_secret);\n \n     client = zmq_socket (ctx, ZMQ_DEALER);\n@@ -217,7 +228,46 @@ int main (void)\n     assert (rc == 0);\n     expect_bounce_fail (server, client);\n     close_zero_linger (client);\n-    \n+\n+    // Unauthenticated messages from a vanilla socket shouldn't be received\n+    struct sockaddr_in ip4addr;\n+    int s;\n+\n+    ip4addr.sin_family = AF_INET;\n+    ip4addr.sin_port = htons (9998);\n+    inet_pton (AF_INET, \"127.0.0.1\", &ip4addr.sin_addr);\n+\n+    s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);\n+    rc = connect (s, (struct sockaddr*) &ip4addr, sizeof (ip4addr));\n+    assert (rc > -1);\n+    // send anonymous ZMTP/1.0 greeting\n+    send (s, \"\\x01\\x00\", 2, 0);\n+    // send sneaky message that shouldn't be received\n+    send (s, \"\\x08\\x00sneaky\\0\", 9, 0);\n+    int timeout = 150;\n+    zmq_setsockopt (server, ZMQ_RCVTIMEO, &timeout, sizeof (timeout));\n+    char *buf = s_recv (server);\n+    if (buf != NULL) {\n+        printf (\"Received unauthenticated message: %s\\n\", buf);\n+        assert (buf == NULL);\n+    }\n+    close (s);\n+\n+    //  Check return codes for invalid buffer sizes\n+    client = zmq_socket (ctx, ZMQ_DEALER);\n+    assert (client);\n+    errno = 0;\n+    rc = zmq_setsockopt (client, ZMQ_CURVE_SERVERKEY, server_public, 123);\n+    assert (rc == -1 && errno == EINVAL);\n+    errno = 0;\n+    rc = zmq_setsockopt (client, ZMQ_CURVE_PUBLICKEY, client_public, 123);\n+    assert (rc == -1 && errno == EINVAL);\n+    errno = 0;\n+    rc = zmq_setsockopt (client, ZMQ_CURVE_SECRETKEY, client_secret, 123);\n+    assert (rc == -1 && errno == EINVAL);\n+    rc = zmq_close (client);\n+    assert (rc == 0);\n+\n     //  Shutdown\n     rc = zmq_close (server);\n     assert (rc == 0);"
        },
        {
          "filename": "tests/test_security_null.cpp",
          "status": "modified",
          "additions": 75,
          "deletions": 46,
          "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2007-2013 Contributors as noted in the AUTHORS file\n+    Copyright (c) 2007-2014 Contributors as noted in the AUTHORS file\n \n     This file is part of 0MQ.\n \n@@ -18,6 +18,17 @@\n */\n \n #include \"testutil.hpp\"\n+#if defined (ZMQ_HAVE_WINDOWS)\n+#   include <winsock2.h>\n+#   include <ws2tcpip.h>\n+#   include <stdexcept>\n+#   define close closesocket\n+#else\n+#   include <sys/socket.h>\n+#   include <netinet/in.h>\n+#   include <arpa/inet.h>\n+#   include <unistd.h>\n+#endif\n \n static void\n zap_handler (void *handler)\n@@ -27,6 +38,7 @@ zap_handler (void *handler)\n         char *version = s_recv (handler);\n         if (!version)\n             break;          //  Terminating\n+\n         char *sequence = s_recv (handler);\n         char *domain = s_recv (handler);\n         char *address = s_recv (handler);\n@@ -57,7 +69,7 @@ zap_handler (void *handler)\n         free (identity);\n         free (mechanism);\n     }\n-    zmq_close (handler);\n+    close_zero_linger (handler);\n }\n \n int main (void)\n@@ -76,72 +88,89 @@ int main (void)\n     void *zap_thread = zmq_threadstart (&zap_handler, handler);\n \n     //  We bounce between a binding server and a connecting client\n+    \n+    //  We first test client/server with no ZAP domain\n+    //  Libzmq does not call our ZAP handler, the connect must succeed\n     void *server = zmq_socket (ctx, ZMQ_DEALER);\n     assert (server);\n     void *client = zmq_socket (ctx, ZMQ_DEALER);\n     assert (client);\n-    \n-    //  We first test client/server with no ZAP domain\n-    //  Libzmq does not call our ZAP handler, the connect must succeed\n     rc = zmq_bind (server, \"tcp://127.0.0.1:9000\");\n     assert (rc == 0);\n-    rc = zmq_connect (client, \"tcp://localhost:9000\");\n+    rc = zmq_connect (client, \"tcp://127.0.0.1:9000\");\n     assert (rc == 0);\n     bounce (server, client);\n-    zmq_unbind (server, \"tcp://127.0.0.1:9000\");\n-    zmq_disconnect (client, \"tcp://localhost:9000\");\n-    \n+    close_zero_linger (client);\n+    close_zero_linger (server);\n+\n     //  Now define a ZAP domain for the server; this enables \n     //  authentication. We're using the wrong domain so this test\n     //  must fail.\n-    //  **************************************************************\n-    //  PH: the following causes libzmq to get confused, so that the\n-    //  next step fails. To reproduce, uncomment this block. Note that\n-    //  even creating a new client/server socket pair, the behaviour\n-    //  does not change.\n-    //  **************************************************************\n-    //  Destroying the old sockets and creating new ones isn't needed,\n-    //  but it shows that the problem isn't related to specific sockets.\n-    //close_zero_linger (client);\n-    //close_zero_linger (server);\n-    //server = zmq_socket (ctx, ZMQ_DEALER);\n-    //assert (server);\n-    //client = zmq_socket (ctx, ZMQ_DEALER);\n-    //assert (client);\n-    ////  The above code should not be required\n-    //rc = zmq_setsockopt (server, ZMQ_ZAP_DOMAIN, \"WRONG\", 5);\n-    //assert (rc == 0);\n-    //rc = zmq_bind (server, \"tcp://127.0.0.1:9001\");\n-    //assert (rc == 0);\n-    //rc = zmq_connect (client, \"tcp://localhost:9001\");\n-    //assert (rc == 0);\n-    //expect_bounce_fail (server, client);\n-    //zmq_unbind (server, \"tcp://127.0.0.1:9001\");\n-    //zmq_disconnect (client, \"tcp://localhost:9001\");\n-    \n+    server = zmq_socket (ctx, ZMQ_DEALER);\n+    assert (server);\n+    client = zmq_socket (ctx, ZMQ_DEALER);\n+    assert (client);\n+    rc = zmq_setsockopt (server, ZMQ_ZAP_DOMAIN, \"WRONG\", 5);\n+    assert (rc == 0);\n+    rc = zmq_bind (server, \"tcp://127.0.0.1:9001\");\n+    assert (rc == 0);\n+    rc = zmq_connect (client, \"tcp://127.0.0.1:9001\");\n+    assert (rc == 0);\n+    expect_bounce_fail (server, client);\n+    close_zero_linger (client);\n+    close_zero_linger (server);\n+\n     //  Now use the right domain, the test must pass\n+    server = zmq_socket (ctx, ZMQ_DEALER);\n+    assert (server);\n+    client = zmq_socket (ctx, ZMQ_DEALER);\n+    assert (client);\n     rc = zmq_setsockopt (server, ZMQ_ZAP_DOMAIN, \"TEST\", 4);\n     assert (rc == 0);\n     rc = zmq_bind (server, \"tcp://127.0.0.1:9002\");\n     assert (rc == 0);\n-    rc = zmq_connect (client, \"tcp://localhost:9002\");\n+    rc = zmq_connect (client, \"tcp://127.0.0.1:9002\");\n     assert (rc == 0);\n-    //  **************************************************************\n-    //  PH: it fails here; though the ZAP reply is 200 OK, and\n-    //  null_mechanism.cpp correctly parses that, the connection\n-    //  never succeeds and the test hangs.\n-    //  **************************************************************\n     bounce (server, client);\n-    zmq_unbind (server, \"tcp://127.0.0.1:9002\");\n-    zmq_disconnect (client, \"tcp://localhost:9002\");\n-    \n-    //  Shutdown\n     close_zero_linger (client);\n     close_zero_linger (server);\n-    rc = zmq_ctx_term (ctx);\n+\n+    // Unauthenticated messages from a vanilla socket shouldn't be received\n+    server = zmq_socket (ctx, ZMQ_DEALER);\n+    assert (server);\n+    rc = zmq_setsockopt (server, ZMQ_ZAP_DOMAIN, \"WRONG\", 5);\n     assert (rc == 0);\n+    rc = zmq_bind (server, \"tcp://127.0.0.1:9003\");\n+    assert (rc == 0);\n+\n+    struct sockaddr_in ip4addr;\n+    int s;\n+\n+    ip4addr.sin_family = AF_INET;\n+    ip4addr.sin_port = htons(9003);\n+    inet_pton(AF_INET, \"127.0.0.1\", &ip4addr.sin_addr);\n \n-    //  Wait until ZAP handler terminates.\n+    s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);\n+    rc = connect (s, (struct sockaddr*) &ip4addr, sizeof ip4addr);\n+    assert (rc > -1);\n+    // send anonymous ZMTP/1.0 greeting\n+    send (s, \"\\x01\\x00\", 2, 0);\n+    // send sneaky message that shouldn't be received\n+    send (s, \"\\x08\\x00sneaky\\0\", 9, 0);\n+    int timeout = 150;\n+    zmq_setsockopt (server, ZMQ_RCVTIMEO, &timeout, sizeof (timeout));\n+    char *buf = s_recv (server);\n+    if (buf != NULL) {\n+        printf (\"Received unauthenticated message: %s\\n\", buf);\n+        assert (buf == NULL);\n+    }\n+    close (s);\n+    close_zero_linger (server);\n+\n+    //  Shutdown\n+    rc = zmq_ctx_term (ctx);\n+    assert (rc == 0);\n+    //  Wait until ZAP handler terminates\n     zmq_threadclose (zap_thread);\n \n     return 0;"
        },
        {
          "filename": "tests/test_security_plain.cpp",
          "status": "modified",
          "additions": 36,
          "deletions": 1,
          "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2007-2013 Contributors as noted in the AUTHORS file\n+    Copyright (c) 2007-2014 Contributors as noted in the AUTHORS file\n \n     This file is part of 0MQ.\n \n@@ -18,6 +18,17 @@\n */\n \n #include \"testutil.hpp\"\n+#if defined (ZMQ_HAVE_WINDOWS)\n+#   include <winsock2.h>\n+#   include <ws2tcpip.h>\n+#   include <stdexcept>\n+#   define close closesocket\n+#else\n+#   include <sys/socket.h>\n+#   include <netinet/in.h>\n+#   include <arpa/inet.h>\n+#   include <unistd.h>\n+#endif\n \n static void\n zap_handler (void *ctx)\n@@ -137,6 +148,30 @@ int main (void)\n     expect_bounce_fail (server, client);\n     close_zero_linger (client);\n \n+    // Unauthenticated messages from a vanilla socket shouldn't be received\n+    struct sockaddr_in ip4addr;\n+    int s;\n+\n+    ip4addr.sin_family = AF_INET;\n+    ip4addr.sin_port = htons (9998);\n+    inet_pton (AF_INET, \"127.0.0.1\", &ip4addr.sin_addr);\n+\n+    s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);\n+    rc = connect (s, (struct sockaddr*) &ip4addr, sizeof (ip4addr));\n+    assert (rc > -1);\n+    // send anonymous ZMTP/1.0 greeting\n+    send (s, \"\\x01\\x00\", 2, 0);\n+    // send sneaky message that shouldn't be received\n+    send (s, \"\\x08\\x00sneaky\\0\", 9, 0);\n+    int timeout = 150;\n+    zmq_setsockopt (server, ZMQ_RCVTIMEO, &timeout, sizeof (timeout));\n+    char *buf = s_recv (server);\n+    if (buf != NULL) {\n+        printf (\"Received unauthenticated message: %s\\n\", buf);\n+        assert (buf == NULL);\n+    }\n+    close (s);\n+\n     //  Shutdown\n     rc = zmq_close (server);\n     assert (rc == 0);"
        }
      ],
      "file_patterns": {
        "security_files": 3,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 3,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "267699b1ce7791bb360a794b9230b21676129612",
            "date": "2020-09-02T13:32:55Z",
            "author_login": "bluca"
          },
          {
            "sha": "da570361b30077f4821a3c7872cd6f4d056d3484",
            "date": "2020-09-02T13:31:46Z",
            "author_login": "bluca"
          },
          {
            "sha": "d82117f95a3d36fcd90c78270b9bda2c806de33c",
            "date": "2020-08-31T21:13:16Z",
            "author_login": "bluca"
          },
          {
            "sha": "05a28644b2f164481bf400916248b4936fd5dd6d",
            "date": "2020-06-13T14:09:39Z",
            "author_login": "bluca"
          },
          {
            "sha": "6e5f33579d4258609d30150b61c6ff634d3344d7",
            "date": "2020-05-15T16:07:48Z",
            "author_login": "bluca"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-20",
    "description": "libzmq before 4.0.6 and 4.1.x before 4.1.1 allows remote attackers to conduct downgrade attacks and bypass ZMTP v3 protocol security mechanisms via a ZMTP v2 or earlier header.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2015-06-03T20:59:00.090",
    "last_modified": "2024-11-21T02:21:31.570",
    "fix_date": "2014-12-05T08:08:38Z"
  },
  "references": [
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-May/159176.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2015-06/msg00018.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2015/dsa-3255",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/zeromq/libzmq/issues/1273",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/zeromq/zeromq4-x/commit/b6e3e0f601e2c1ec1f3aac880ed6a3fe63043e51",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-May/159176.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2015-06/msg00018.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2015/dsa-3255",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/zeromq/libzmq/issues/1273",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/zeromq/zeromq4-x/commit/b6e3e0f601e2c1ec1f3aac880ed6a3fe63043e51",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:35.778984",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "zeromq4-x",
    "owner": "zeromq",
    "created_at": "2013-09-20T07:20:39Z",
    "updated_at": "2025-01-10T04:36:10Z",
    "pushed_at": "2020-09-07T16:01:26Z",
    "size": 11344,
    "stars": 460,
    "forks": 195,
    "open_issues": 12,
    "watchers": 460,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 1041440,
      "M4": 53561,
      "CMake": 29852,
      "C": 20018,
      "Shell": 17401,
      "Makefile": 12039
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-26T08:27:15.626843"
  }
}