{
  "cve_id": "CVE-2014-9765",
  "github_data": {
    "repository": "jmacd/xdelta-devel",
    "fix_commit": "ef93ff74203e030073b898c05e8b4860b5d09ef2",
    "related_commits": [
      "ef93ff74203e030073b898c05e8b4860b5d09ef2",
      "ef93ff74203e030073b898c05e8b4860b5d09ef2"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "ef93ff74203e030073b898c05e8b4860b5d09ef2",
      "commit_date": "2014-10-12T05:24:22Z",
      "author": {
        "login": "jmacd",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Add appheader tests; fix buffer overflow in main_get_appheader",
        "length": 62,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 136,
        "additions": 108,
        "deletions": 28
      },
      "files": [
        {
          "filename": "xdelta3/xdelta3-main.h",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -2810,14 +2810,15 @@ main_get_appheader (xd3_stream *stream, main_file *ifile,\n \n   if (appheadsz > 0)\n     {\n+      const int kMaxArgs = 4;\n       char *start = (char*)apphead;\n       char *slash;\n       int   place = 0;\n-      char *parsed[4];\n+      char *parsed[kMaxArgs];\n \n       memset (parsed, 0, sizeof (parsed));\n \n-      while ((slash = strchr (start, '/')) != NULL)\n+      while ((slash = strchr (start, '/')) != NULL && place < (kMaxArgs-1))\n \t{\n \t  *slash = 0;\n \t  parsed[place++] = start;"
        },
        {
          "filename": "xdelta3/xdelta3-test.h",
          "status": "modified",
          "additions": 105,
          "deletions": 26,
          "patch": "@@ -1,5 +1,5 @@\n /* xdelta 3 - delta compression tools and library Copyright (C) 2001,\n- * 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012.  \n+ * 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012.\n  * Joshua P. MacDonald\n  *\n  *  This program is free software; you can redistribute it and/or modify\n@@ -54,7 +54,7 @@ void mt_init(mtrand *mt, uint32_t seed) {\n     /* only MSBs of the array mt[].                        */\n     /* 2002/01/09 modified by Makoto Matsumoto             */\n     mt->mt_buffer_[i] =\n-\t(1812433253UL * (mt->mt_buffer_[i-1] ^ \n+\t(1812433253UL * (mt->mt_buffer_[i-1] ^\n \t\t\t (mt->mt_buffer_[i-1] >> 30)) + i);\n   }\n }\n@@ -69,20 +69,20 @@ uint32_t mt_random (mtrand *mt) {\n     int kk;\n \n     for (kk = 0; kk < MT_LEN - MT_IA; kk++) {\n-      y = (mt->mt_buffer_[kk] & UPPER_MASK) | \n+      y = (mt->mt_buffer_[kk] & UPPER_MASK) |\n \t(mt->mt_buffer_[kk + 1] & LOWER_MASK);\n-      mt->mt_buffer_[kk] = mt->mt_buffer_[kk + MT_IA] ^ \n+      mt->mt_buffer_[kk] = mt->mt_buffer_[kk + MT_IA] ^\n \t(y >> 1) ^ mag01[y & 0x1UL];\n     }\n     for (;kk < MT_LEN - 1; kk++) {\n-      y = (mt->mt_buffer_[kk] & UPPER_MASK) | \n+      y = (mt->mt_buffer_[kk] & UPPER_MASK) |\n \t(mt->mt_buffer_[kk + 1] & LOWER_MASK);\n-      mt->mt_buffer_[kk] = mt->mt_buffer_[kk + (MT_IA - MT_LEN)] ^ \n+      mt->mt_buffer_[kk] = mt->mt_buffer_[kk + (MT_IA - MT_LEN)] ^\n \t(y >> 1) ^ mag01[y & 0x1UL];\n     }\n-    y = (mt->mt_buffer_[MT_LEN - 1] & UPPER_MASK) | \n+    y = (mt->mt_buffer_[MT_LEN - 1] & UPPER_MASK) |\n       (mt->mt_buffer_[0] & LOWER_MASK);\n-    mt->mt_buffer_[MT_LEN - 1] = mt->mt_buffer_[MT_IA - 1] ^ \n+    mt->mt_buffer_[MT_LEN - 1] = mt->mt_buffer_[MT_IA - 1] ^\n       (y >> 1) ^ mag01[y & 0x1UL];\n     mt->mt_index_ = 0;\n   }\n@@ -166,7 +166,7 @@ static int do_cmd (xd3_stream *stream, const char *buf)\n \t{\n \t  stream->msg = \"abnormal command termination\";\n \t}\n-      return XD3_INTERNAL;\n+      return ret;\n     }\n   return 0;\n }\n@@ -257,8 +257,10 @@ int test_setup (void)\n static int\n test_make_inputs (xd3_stream *stream, xoff_t *ss_out, xoff_t *ts_out)\n {\n-  usize_t ts = (mt_random (&static_mtrand) % TEST_FILE_MEAN) + TEST_FILE_MEAN / 2;\n-  usize_t ss = (mt_random (&static_mtrand) % TEST_FILE_MEAN) + TEST_FILE_MEAN / 2;\n+  usize_t ts = (mt_random (&static_mtrand) % TEST_FILE_MEAN) +\n+    TEST_FILE_MEAN / 2;\n+  usize_t ss = (mt_random (&static_mtrand) % TEST_FILE_MEAN) +\n+    TEST_FILE_MEAN / 2;\n   uint8_t *buf = (uint8_t*) malloc (ts + ss), *sbuf = buf, *tbuf = buf + ss;\n   usize_t sadd = 0, sadd_max = (usize_t)(ss * TEST_ADD_RATIO);\n   FILE  *tf = NULL, *sf = NULL;\n@@ -409,7 +411,7 @@ test_compare_files (const char* tgt, const char *rec)\n \t{\n \t  if (obuf[i] != rbuf[i])\n  \t    {\n-\t      XPR(NT \"byte %u (read %u @ %\"Q\"u) %d != %d\\n\", \n+\t      XPR(NT \"byte %u (read %u @ %\"Q\"u) %d != %d\\n\",\n \t\t  (int)i, (int)oc, offset, obuf[i], rbuf[i]);\n \t      diffs++;\n \t      return XD3_INTERNAL;\n@@ -421,20 +423,20 @@ test_compare_files (const char* tgt, const char *rec)\n \n     fclose (orig);\n     fclose (recons);\n-    if (diffs != 0) \n+    if (diffs != 0)\n       {\n \treturn XD3_INTERNAL;\n       }\n     return 0;\n }\n \n static int\n-test_save_copy (const char *origname)\n+test_copy_to (const char *from, const char *to)\n {\n   char buf[TESTBUFSIZE];\n   int ret;\n \n-  snprintf_func (buf, TESTBUFSIZE, \"cp -f %s %s\", origname, TEST_COPY_FILE);\n+  snprintf_func (buf, TESTBUFSIZE, \"cp -f %s %s\", from, to);\n \n   if ((ret = system (buf)) != 0)\n     {\n@@ -444,6 +446,12 @@ test_save_copy (const char *origname)\n   return 0;\n }\n \n+static int\n+test_save_copy (const char *origname)\n+{\n+  return test_copy_to(origname, TEST_COPY_FILE);\n+}\n+\n static int\n test_file_size (const char* file, xoff_t *size)\n {\n@@ -499,7 +507,7 @@ test_read_integer_error (xd3_stream *stream, usize_t trunto, const char *msg)\n   inp = buf->base;\n   max = buf->base + buf->next - trunto;\n \n-  if ((ret = xd3_read_uint32_t (stream, & inp, max, & rval)) != \n+  if ((ret = xd3_read_uint32_t (stream, & inp, max, & rval)) !=\n       XD3_INVALID_INPUT ||\n       !MSG_IS (msg))\n     {\n@@ -1654,11 +1662,11 @@ test_compressed_stream_overflow (xd3_stream *stream, int ignore)\n   if ((buf = (uint8_t*) malloc (TWO_MEGS_AND_DELTA)) == NULL) { return ENOMEM; }\n \n   memset (buf, 0, TWO_MEGS_AND_DELTA);\n-  for (i = 0; i < (2 << 20); i += 256) \n+  for (i = 0; i < (2 << 20); i += 256)\n     {\n       int j;\n       int off = mt_random(& static_mtrand) % 10;\n-      for (j = 0; j < 256; j++) \n+      for (j = 0; j < 256; j++)\n \t{\n \t  buf[i + j] = j + off;\n \t}\n@@ -1683,11 +1691,11 @@ test_compressed_stream_overflow (xd3_stream *stream, int ignore)\n     }\n \n   /* Test transfer of exactly 32bits worth of data. */\n-  if ((ret = test_streaming (stream, \n-\t\t\t     buf, \n-\t\t\t     buf + (1 << 20), \n-\t\t\t     buf + (2 << 20), \n-\t\t\t     1 << 12))) \n+  if ((ret = test_streaming (stream,\n+\t\t\t     buf,\n+\t\t\t     buf + (1 << 20),\n+\t\t\t     buf + (2 << 20),\n+\t\t\t     1 << 12)))\n     {\n       goto fail;\n     }\n@@ -1889,7 +1897,7 @@ test_recode_command2 (xd3_stream *stream, int has_source,\n     }\n \n   /* First encode */\n-  snprintf_func (ecmd, TESTBUFSIZE, \"%s %s -f %s %s %s %s %s %s %s\", \n+  snprintf_func (ecmd, TESTBUFSIZE, \"%s %s -f %s %s %s %s %s %s %s\",\n \t    program_name, test_softcfg_str,\n \t    has_adler32 ? \"\" : \"-n \",\n \t    has_apphead ? \"-A=encode_apphead \" : \"-A= \",\n@@ -1910,7 +1918,7 @@ test_recode_command2 (xd3_stream *stream, int has_source,\n   snprintf_func (recmd, TESTBUFSIZE,\n \t    \"%s recode %s -f %s %s %s %s %s\", program_name, test_softcfg_str,\n \t    recoded_adler32 ? \"\" : \"-n \",\n-\t    !change_apphead ? \"\" : \n+\t    !change_apphead ? \"\" :\n \t        (recoded_apphead ? \"-A=recode_apphead \" : \"-A= \"),\n \t    recoded_secondary ? \"-S djw \" : \"-S none \",\n \t    TEST_DELTA_FILE,\n@@ -2361,6 +2369,76 @@ test_no_output (xd3_stream *stream, int ignore)\n   return 0;\n }\n \n+/* This tests that the default appheader works */\n+static int\n+test_appheader (xd3_stream *stream, int ignore)\n+{\n+  int i;\n+  int ret;\n+  char buf[TESTBUFSIZE];\n+  char bogus[TESTBUFSIZE];\n+  xoff_t ssize, tsize;\n+  test_setup ();\n+\n+  if ((ret = test_make_inputs (stream, &ssize, &tsize))) { return ret; }\n+\n+  snprintf_func (buf, TESTBUFSIZE, \"%s -q -f -e -s %s %s %s\", program_name,\n+\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n+  if ((ret = do_cmd (stream, buf))) { return ret; }\n+\n+  if ((ret = test_copy_to (program_name, TEST_RECON2_FILE))) { return ret; }\n+\n+  snprintf_func (buf, TESTBUFSIZE, \"chmod 0700 %s\", TEST_RECON2_FILE);\n+  if ((ret = do_cmd (stream, buf))) { return ret; }\n+\n+  if ((ret = test_save_copy (TEST_TARGET_FILE))) { return ret; }\n+  if ((ret = test_copy_to (TEST_SOURCE_FILE, TEST_TARGET_FILE))) { return ret; }\n+\n+  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) == 0)\n+    {\n+      return XD3_INVALID;  // I.e., files are different!\n+    }\n+\n+  // Test that the target file is restored.\n+  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n+\t\t TEST_RECON2_FILE,\n+\t\t TEST_DELTA_FILE);\n+  if ((ret = do_cmd (stream, buf))) { return ret; }\n+\n+  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) != 0)\n+    {\n+      return ret;\n+    }\n+\n+  // Test a malicious string w/ entries > 4 in the appheader by having\n+  // the encoder write it:\n+  for (i = 0; i < TESTBUFSIZE / 4; ++i)\n+    {\n+      bogus[2*i] = 'G';\n+      bogus[2*i+1] = '/';\n+    }\n+  bogus[TESTBUFSIZE/2-1] = 0;\n+\n+  snprintf_func (buf, TESTBUFSIZE, \n+\t\t \"%s -q -f -A=%s -e -s %s %s %s\", program_name, bogus,\n+\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n+  if ((ret = do_cmd (stream, buf))) { return ret; }\n+  // Then read it:\n+  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n+\t\t TEST_RECON2_FILE,\n+\t\t TEST_DELTA_FILE);\n+  if ((ret = do_cmd (stream, buf)) == 0) \n+    { \n+      return XD3_INVALID;  // Impossible\n+    }\n+  if (!WIFEXITED(ret))\n+    {\n+      return XD3_INVALID;  // Must have crashed!\n+    }\n+\n+  return 0;\n+}\n+\n /***********************************************************************\n  Source identical optimization\n  ***********************************************************************/\n@@ -2603,7 +2681,7 @@ test_string_matching (xd3_stream *stream, int ignore)\n \t    default: CHECK(0);\n \t    }\n \n-\t  snprintf_func (rptr, rbuf+TESTBUFSIZE-rptr, \"%d/%d\", \n+\t  snprintf_func (rptr, rbuf+TESTBUFSIZE-rptr, \"%d/%d\",\n \t\t\t inst->pos, inst->size);\n \t  rptr += strlen (rptr);\n \n@@ -2848,6 +2926,7 @@ xd3_selftest (void)\n   DO_TEST (force_behavior, 0, 0);\n   DO_TEST (stdout_behavior, 0, 0);\n   DO_TEST (no_output, 0, 0);\n+  DO_TEST (appheader, 0, 0);\n   DO_TEST (command_line_arguments, 0, 0);\n \n #if EXTERNAL_COMPRESSION"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d16652b02a590804b486f15e66f4115ddfd84760",
            "date": "2016-04-24T06:26:44Z",
            "author_login": "jmacd"
          },
          {
            "sha": "4b4aed71a959fe11852e45242bb6524be85d3709",
            "date": "2016-01-08T07:58:54Z",
            "author_login": "jmacd"
          },
          {
            "sha": "566b1a968889cb1a9b2c9f2d8c13b3064d0c9b27",
            "date": "2016-01-08T06:49:10Z",
            "author_login": "jmacd"
          },
          {
            "sha": "81aebf78ae67c29f528088d65743643e5355e3d3",
            "date": "2016-01-08T06:48:42Z",
            "author_login": "jmacd"
          },
          {
            "sha": "54b3937e71a6c3a186c38993300908019b1cb335",
            "date": "2016-01-08T06:43:21Z",
            "author_login": "jmacd"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-119",
    "description": "Buffer overflow in the main_get_appheader function in xdelta3-main.h in xdelta3 before 3.0.9 allows remote attackers to execute arbitrary code via a crafted input file.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2016-04-19T21:59:01.100",
    "last_modified": "2024-11-21T02:21:37.587",
    "fix_date": "2014-10-12T05:24:22Z"
  },
  "references": [
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2016-02/msg00125.html",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2016-02/msg00131.html",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2016/dsa-3484",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/02/08/1",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/02/08/2",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/83109",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2901-1",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "https://github.com/jmacd/xdelta-devel/commit/ef93ff74203e030073b898c05e8b4860b5d09ef2",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/201701-40",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2016-02/msg00125.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2016-02/msg00131.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2016/dsa-3484",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/02/08/1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/02/08/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/83109",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2901-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/jmacd/xdelta-devel/commit/ef93ff74203e030073b898c05e8b4860b5d09ef2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/201701-40",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:42.527054",
    "processing_status": "enhanced"
  }
}