{
  "cve_id": "CVE-2015-10024",
  "github_data": {
    "repository": "hoffie/larasync",
    "fix_commit": "776bad422f4bd4930d09491711246bbeb1be9ba5",
    "related_commits": [
      "776bad422f4bd4930d09491711246bbeb1be9ba5",
      "776bad422f4bd4930d09491711246bbeb1be9ba5"
    ],
    "patch_url": "https://github.com/hoffie/larasync/commit/776bad422f4bd4930d09491711246bbeb1be9ba5.patch",
    "fix_commit_details": {
      "sha": "776bad422f4bd4930d09491711246bbeb1be9ba5",
      "commit_date": "2015-01-20T22:21:00Z",
      "author": {
        "login": "hoffie",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "repository/content: fix potential (authenticated) path traversal (#195)",
        "length": 71,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 66,
        "additions": 58,
        "deletions": 8
      },
      "files": [
        {
          "filename": "repository/content/file_storage.go",
          "status": "modified",
          "additions": 41,
          "deletions": 8,
          "patch": "@@ -1,9 +1,12 @@\n package content\n \n import (\n+\t\"errors\"\n \t\"io\"\n \t\"os\"\n \t\"path\"\n+\t\"path/filepath\"\n+\t\"strings\"\n \n \t\"github.com/hoffie/larasync/helpers/atomic\"\n )\n@@ -14,6 +17,10 @@ const (\n \tdefaultDirPerms  = 0700\n )\n \n+// ErrInvalidPath is returned if storage at a path not rooted at the FileStorage's\n+// root path is attempted.\n+var ErrInvalidPath = errors.New(\"invalid path\")\n+\n // FileStorage is the basic implementation of the Storage\n // implementation which stores the data into the file system.\n type FileStorage struct {\n@@ -39,23 +46,40 @@ func (f *FileStorage) CreateDir() error {\n }\n \n // storagePathFor returns the storage path for the data entry.\n-func (f *FileStorage) storagePathFor(contentID string) string {\n-\treturn path.Join(f.path, contentID)\n+func (f *FileStorage) storagePathFor(contentID string) (string, error) {\n+\tp := path.Join(f.path, contentID)\n+\tp = filepath.Clean(p)\n+\troot := f.path\n+\t/*if len(root) > 1 && root[len(root)-1] != filepath.Separator {\n+\t\troot += filepath.Separator\n+\t}*/\n+\tif !strings.HasPrefix(p, root) {\n+\t\treturn \"\", ErrInvalidPath\n+\t}\n+\treturn p, nil\n }\n \n // Get returns the file handle for the given contentID.\n // If there is no data stored for the Id it should return a\n // os.ErrNotExists error.\n func (f *FileStorage) Get(contentID string) (io.ReadCloser, error) {\n-\tif f.Exists(contentID) {\n-\t\treturn os.Open(f.storagePathFor(contentID))\n+\tif !f.Exists(contentID) {\n+\t\treturn nil, os.ErrNotExist\n+\t}\n+\t// FIXME TOCTU race\n+\tp, err := f.storagePathFor(contentID)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n-\treturn nil, os.ErrNotExist\n+\treturn os.Open(p)\n }\n \n // Set sets the data of the given contentID in the blob storage.\n func (f *FileStorage) Set(contentID string, reader io.Reader) error {\n-\tblobStoragePath := f.storagePathFor(contentID)\n+\tblobStoragePath, err := f.storagePathFor(contentID)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \n \twriter, err := atomic.NewStandardWriter(blobStoragePath, defaultFilePerms)\n \tif err != nil {\n@@ -79,7 +103,12 @@ func (f *FileStorage) Set(contentID string, reader io.Reader) error {\n \n // Exists checks if the given entry is stored in the database.\n func (f *FileStorage) Exists(contentID string) bool {\n-\t_, err := os.Stat(f.storagePathFor(contentID))\n+\tp, err := f.storagePathFor(contentID)\n+\tif err != nil {\n+\t\t// FIXME maybe return error instead?\n+\t\treturn false\n+\t}\n+\t_, err = os.Stat(p)\n \tif err != nil {\n \t\treturn !os.IsNotExist(err)\n \t}\n@@ -88,5 +117,9 @@ func (f *FileStorage) Exists(contentID string) bool {\n \n // Delete removes the data with the given contentID from the store.\n func (f *FileStorage) Delete(contentID string) error {\n-\treturn os.Remove(f.storagePathFor(contentID))\n+\tp, err := f.storagePathFor(contentID)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn os.Remove(p)\n }"
        },
        {
          "filename": "repository/content/file_storage_test.go",
          "status": "modified",
          "additions": 17,
          "deletions": 0,
          "patch": "@@ -20,6 +20,8 @@ type FileStorageTests struct {\n \n var _ = Suite(&FileStorageTests{})\n \n+var dangerousNames = []string{\"..\", \"../xyz\"}\n+\n func (t *FileStorageTests) SetUpTest(c *C) {\n \tt.dir = c.MkDir()\n \tt.storage = NewFileStorage(t.dir)\n@@ -43,6 +45,14 @@ func (t *FileStorageTests) setData() error {\n \treturn t.storage.Set(t.blobID(), t.testReader())\n }\n \n+func (t *FileStorageTests) TestSetDangerousName(c *C) {\n+\tr := t.testReader()\n+\tfor _, id := range dangerousNames {\n+\t\terr := t.storage.Set(id, r)\n+\t\tc.Assert(err, NotNil)\n+\t}\n+}\n+\n func (t *FileStorageTests) TestSet(c *C) {\n \terr := t.setData()\n \tc.Assert(err, IsNil)\n@@ -72,6 +82,13 @@ func (t *FileStorageTests) TestGet(c *C) {\n \tc.Assert(err, IsNil)\n }\n \n+func (t *FileStorageTests) TestGetDangerousName(c *C) {\n+\tfor _, id := range dangerousNames {\n+\t\t_, err := t.storage.Get(id)\n+\t\tc.Assert(err, NotNil)\n+\t}\n+}\n+\n func (t *FileStorageTests) TestGetData(c *C) {\n \tt.setData()\n \tfile, _ := t.storage.Get(t.blobID())"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "0384d2bddcefc0f01c488cd7dcd60bd2dac1a1c8",
            "date": "2015-10-25T22:19:40Z",
            "author_login": "cbrand"
          },
          {
            "sha": "2f79563421055f1ca12b478af1901d26b2be321e",
            "date": "2015-10-25T21:50:31Z",
            "author_login": "cbrand"
          },
          {
            "sha": "fbcf6b45d7082559f25c6f34c9d05a9fc265d9db",
            "date": "2015-10-25T21:50:17Z",
            "author_login": "cbrand"
          },
          {
            "sha": "86d45d1070ee51f551da15d136fe2dfc4d04c3a0",
            "date": "2015-07-28T19:22:00Z",
            "author_login": "hoffie"
          },
          {
            "sha": "9a2ec96db764ca84f895761da2c3ceb547e1dc08",
            "date": "2015-04-07T13:19:15Z",
            "author_login": "cbrand"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L",
    "cwe_id": "CWE-22",
    "description": "A vulnerability classified as critical was found in hoffie larasync. This vulnerability affects unknown code of the file repository/content/file_storage.go. The manipulation leads to path traversal. The name of the patch is 776bad422f4bd4930d09491711246bbeb1be9ba5. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-217612.",
    "attack_vector": "ADJACENT_NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-01-07T13:15:09.293",
    "last_modified": "2024-11-21T02:24:12.047",
    "fix_date": "2015-01-20T22:21:00Z"
  },
  "references": [
    {
      "url": "https://github.com/hoffie/larasync/commit/776bad422f4bd4930d09491711246bbeb1be9ba5",
      "source": "cna@vuldb.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?ctiid.217612",
      "source": "cna@vuldb.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?id.217612",
      "source": "cna@vuldb.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/hoffie/larasync/commit/776bad422f4bd4930d09491711246bbeb1be9ba5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?ctiid.217612",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?id.217612",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:43.525693",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "larasync",
    "owner": "hoffie",
    "created_at": "2014-11-25T13:41:03Z",
    "updated_at": "2022-08-29T04:35:03Z",
    "pushed_at": "2015-10-25T22:19:41Z",
    "size": 2060,
    "stars": 1,
    "forks": 0,
    "open_issues": 1,
    "watchers": 1,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Go": 376924,
      "Protocol Buffer": 799
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "agpl-3.0"
    },
    "collected_at": "2025-01-14T21:49:27.884546"
  }
}