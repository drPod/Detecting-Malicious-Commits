{
  "cve_id": "CVE-2015-10027",
  "github_data": {
    "repository": "hydrian/TTRSS-Auth-LDAP",
    "fix_commit": "a7f7a5a82d9202a5c40d606a5c519ba61b224eb8",
    "related_commits": [
      "a7f7a5a82d9202a5c40d606a5c519ba61b224eb8",
      "a7f7a5a82d9202a5c40d606a5c519ba61b224eb8"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "a7f7a5a82d9202a5c40d606a5c519ba61b224eb8",
      "commit_date": "2015-11-02T15:30:48Z",
      "author": {
        "login": "hydrian",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #14 from tsmgeek/master",
        "length": 105,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 691,
        "additions": 367,
        "deletions": 324
      },
      "files": [
        {
          "filename": "plugins/auth_ldap/init.php",
          "status": "modified",
          "additions": 367,
          "deletions": 324,
          "patch": "@@ -1,32 +1,28 @@\n <?php\n-/** \n+\n+/**\n  * Tiny Tiny RSS plugin for LDAP authentication \n- * @author hydrian (ben.tyger@tygerclan.net)\n+ * @author tsmgeek (tsmgeek@gmail.com)\n+ * @originalauthor hydrian (ben.tyger@tygerclan.net)\n  * @copyright GPL2\n- *  Requires php-ldap and PEAR Net::LDAP2\n- * @version 0.05\n+ *  Requires php-ldap \n+ * @version 1.00\n  */\n-\n /**\n  *  Configuration\n  *  Put the following options in config.php and customize them for your environment\n  *\n  * \tdefine('LDAP_AUTH_SERVER_URI', 'ldaps://LDAPServerHostname:port/');\n- *\tdefine('LDAP_AUTH_USETLS', FALSE); // Enable TLS Support for ldaps://\n- *\tdefine('LDAP_AUTH_ALLOW_UNTRUSTED_CERT', TRUE); // Allows untrusted certificate\n- *\tdefine('LDAP_AUTH_BASEDN', 'dc=example,dc=com');\n+ * \tdefine('LDAP_AUTH_USETLS', FALSE); // Enable TLS Support for ldaps://\n+ * \tdefine('LDAP_AUTH_ALLOW_UNTRUSTED_CERT', TRUE); // Allows untrusted certificate\n+ * \tdefine('LDAP_AUTH_BASEDN', 'dc=example,dc=com');\n  * \tdefine('LDAP_AUTH_ANONYMOUSBEFOREBIND', FALSE);\n- *\t// ??? will be replaced with the entered username(escaped) at login \n- *\tdefine('LDAP_AUTH_SEARCHFILTER', '(&(objectClass=person)(uid=???))');\n- *\t// Optional configuration\n+ * \t// ??? will be replaced with the entered username(escaped) at login \n+ * \tdefine('LDAP_AUTH_SEARCHFILTER', '(&(objectClass=person)(uid=???))');\n+ * \t// Optional configuration\n  *      define('LDAP_AUTH_BINDDN', 'cn=serviceaccount,dc=example,dc=com');\n  *      define('LDAP_AUTH_BINDPW', 'ServiceAccountsPassword');\n  *      define('LDAP_AUTH_LOGIN_ATTRIB', 'uid');\n- *\t  \n- *  define('LDAP_AUTH_SCHEMA_CACHE_ENABLE', TRUE);\n- *    Enables Schema Caching (Recommended) \n- *  define('LDAP_AUTH_SCHEMA_CACHE_TIMEOUT', 86400);\n- *    Max time a schema cache is kept (seconds) \n  *  define('LDAP_AUTH_LOG_ATTEMPTS', FALSE);\n  *    Enable Debug Logging\n  *  define('LDAP_AUTH_DEBUG', FALSE);\n@@ -36,326 +32,373 @@\n  */\n \n /**\n- *\tNotes -\n- *\tLDAP search does not support follow ldap referals. Referals are disabled to \n- *\tallow proper login.  This is particular to Active Directory.  \n+ * \tNotes -\n+ * \tLDAP search does not support follow ldap referals. Referals are disabled to \n+ * \tallow proper login.  This is particular to Active Directory.  \n  * \n- *\tAlso group membership can be supported if the user object contains the\n- *\tthe group membership via attributes.  The following LDAP servers can \n- *\tsupport this.   \n+ * \tAlso group membership can be supported if the user object contains the\n+ * \tthe group membership via attributes.  The following LDAP servers can \n+ * \tsupport this.   \n  * \t * Active Directory\n  *   * OpenLDAP support with MemberOf Overlay\n  *\n  */\n class Auth_Ldap extends Plugin implements IAuthModule {\n \n-\tprivate $link;\n-\tprivate $host;\n-\tprivate $base;\n-\tprivate $logClass;\n-\tprivate $ldapObj = NULL;\n-\n-  private $_debugMode;\n-  private $_serviceBindDN;\n-  private $_serviceBindPass;\n-  private $_baseDN;\n-  private $_useTLS;\n-  private $_host;\n-  private $_port;\n-  private $_scheme;\n-  private $_schemaCacheEnabled;\n-  private $_anonBeforeBind;\n-  private $_allowUntrustedCerts;\n-  private $_ldapLoginAttrib;\n-\n-\tfunction about() {\n-\t\treturn array(0.05,\n-\t\t\t\"Authenticates against an LDAP server (configured in config.php)\",\n-\t\t\t\"hydrian\",\n-\t\t\ttrue);\n-\t}\n-\n-\tfunction init($host) {\n-\t\t$this->link = $host->get_link();\n-\t\t$this->host = $host;\n-\t\t$this->base = new Auth_Base($this->link);\n-\n-\t\t$host->add_hook($host::HOOK_AUTH_USER, $this);\n-\t}\n-\t\n-\tprivate function _log($msg, $level = E_USER_NOTICE,$file='',$line='',$context='') {\n-\t\t$loggerFunction = Logger::get();\n-\t\tif (is_object($loggerFunction)) {\n-\t\t\t$loggerFunction->log_error($level, $msg,$file,$line,$context);\n-\t\t} else {\n-\t\t\ttrigger_error($msg, $level);\n-\t\t}\n-\t\t\n-\t}\n-\t\n-\t/**\n-\t * Logs login attempts\n-\t * @param string $username Given username that attempts to log in to TTRSS\n-\t * @param string $result \"Logging message for type of result. (Success / Fail)\"\n-\t * @return boolean\n-\t * @deprecated\n-\t * \n-\t * Now that _log support syslog and log levels and graceful fallback user.  \n-\t */\n-\tprivate function _logAttempt($username, $result) {\n-\t\t\n-\t\t\n-\t\treturn trigger_error('TT-RSS Login Attempt: user '.(string)$username.\n-\t\t\t' attempted to login ('.(string)$result.') from '.(string)$ip,\n-\t\t\tE_USER_NOTICE\n-\t\t);\t\n-\t}\n-\t\n-\t/**\n-\t * Finds client's IP address\n-\t * @return string\n-\t */\n-\tprivate function _getClientIP () {\n-\t\tif (!empty($_SERVER['HTTP_CLIENT_IP'])) {\n-\t\t\t//check ip from share internet\n-\t\t\n-\t\t\t$ip=$_SERVER['HTTP_CLIENT_IP'];\n-\t\t}\n-\t\telseif (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) {\n-\t\t\t//to check ip is pass from proxy\n-\t\t\t$ip=$_SERVER['HTTP_X_FORWARDED_FOR'];\n-\t\t}\n-\t\telse {\n-\t\t\t$ip=$_SERVER['REMOTE_ADDR'];\n-\t\t}\n-\t\t\n-\t\treturn $ip;\n-\t}\n-\n-  private function _getBindDNWord () {\n-    return (strlen($this->_serviceBindDN) > 0 ) ?  $this->_serviceBindDN : 'anonymous DN';\n-  }\n-\n-  private function _getTempDir () {\n-    if (!sys_get_temp_dir()) {\n-      $tmpFile=tempnam();\n-      $tmpDir=dirname($tmpFile);\n-      unlink($tmpFile);\n-      unset($tmpFile);\n-      return $tmpDir;\n-    } else {\n-      return sys_get_temp_dir();\n+    private $link;\n+    private $host;\n+    private $base;\n+    private $logClass;\n+    private $ldapObj = NULL;\n+    private $_debugMode;\n+    private $_serviceBindDN;\n+    private $_serviceBindPass;\n+    private $_baseDN;\n+    private $_useTLS;\n+    private $_host;\n+    private $_port;\n+    private $_scheme;\n+    private $_schemaCacheEnabled;\n+    private $_anonBeforeBind;\n+    private $_allowUntrustedCerts;\n+    private $_ldapLoginAttrib;\n+\n+    function about() {\n+        return array(0.05,\n+            \"Authenticates against an LDAP server (configured in config.php)\",\n+            \"hydrian\",\n+            true);\n+    }\n+\n+    function init($host) {\n+        $this->link = $host->get_link();\n+        $this->host = $host;\n+        $this->base = new Auth_Base($this->link);\n+\n+        $host->add_hook($host::HOOK_AUTH_USER, $this);\n     }\n-  }\n-\n-  private function _getSchemaCache () {\n-        $cacheFileLoc=$this->_getTempDir().'/ttrss-ldapCache-'.$this->_host.':'.$this->_port.'.cache';\n-        if ($this->_debugMode) $this->_log('Schema Cache File: '.$cacheFileLoc);\n-        $schemaCacheConf=array(\n-            'path'=>$cacheFileLoc,\n-            'max_age'=>$this->_schemaCacheTimeout\n+\n+    private function _log($msg, $level = E_USER_NOTICE, $file = '', $line = '', $context = '') {\n+        $loggerFunction = Logger::get();\n+        if (is_object($loggerFunction)) {\n+            $loggerFunction->log_error($level, $msg, $file, $line, $context);\n+        } else {\n+            trigger_error($msg, $level);\n+        }\n+    }\n+\n+    /**\n+     * Logs login attempts\n+     * @param string $username Given username that attempts to log in to TTRSS\n+     * @param string $result \"Logging message for type of result. (Success / Fail)\"\n+     * @return boolean\n+     * @deprecated\n+     * \n+     * Now that _log support syslog and log levels and graceful fallback user.  \n+     */\n+    private function _logAttempt($username, $result) {\n+\n+\n+        return trigger_error('TT-RSS Login Attempt: user ' . (string) $username .\n+                ' attempted to login (' . (string) $result . ') from ' . (string) $ip, E_USER_NOTICE\n         );\n-        $schemaCacheObj= new Net_LDAP2_SimpleFileSchemaCache($schemaCacheConf);\n-        $this->ldapObj->registerSchemaCache($schemaCacheObj);\n-        $schemaCacheObj->storeSchema($this->ldapObj->schema());\n-        return TRUE;\n-  }\n-\n-\t/**\n-\t * Main Authentication method\n-\t * Required for plugin interface \n-\t * @param unknown $login  User's username\n-\t * @param unknown $password User's password\n-\t * @return boolean\n-\t */\n-\tfunction authenticate($login, $password) {\n-\t\tif ($login && $password) {\n-\t\t\t\n-\t\t\tif (!function_exists('ldap_connect')) {\n-\t\t\t\ttrigger_error('auth_ldap requires PHP\\'s PECL LDAP package installed.');\n-\t\t\t\treturn FALSE;\n-\t\t\t}\n-\t\t\tif (!require_once('Net/LDAP2.php')) { \n-\t\t\t\ttrigger_error('auth_ldap requires the PEAR package Net::LDAP2');\n-\t\t\t\treturn FALSE;\n-\t\t\t}\n-\t\t\t\n-      /**\n-      Loading configuration \n-      **/\n-\n-\t\t\t$this->_debugMode = defined('LDAP_AUTH_DEBUG') ?\n-\t\t\t\tLDAP_AUTH_DEBUG : FALSE;\n-\t\t\t\n-\t\t\t$this->_anonBeforeBind =defined('LDAP_AUTH_ANONYMOUSBEFOREBIND') ?\n-\t\t\t\tLDAP_AUTH_ANONYMOUSBEFOREBIND : FALSE;\n-\t\t\t\n-\t\t\t$this->_serviceBindDN = defined('LDAP_AUTH_BINDDN') ? LDAP_AUTH_BINDDN : null;\n-\t\t\t$this->_serviceBindPass = defined('LDAP_AUTH_BINDPW') ? LDAP_AUTH_BINDPW : null;\n-      $this->_baseDN = defined('LDAP_AUTH_BASEDN') ? LDAP_AUTH_BASEDN : null;\n-      if (!defined('LDAP_AUTH_BASEDN')) {\n-        $this->_log('LDAP_AUTH_BASEDN is required and not defined.',E_USER_ERROR);\n-  \t\t  return FALSE;\n-      } else {\n-        $this->_baseDN = LDAP_AUTH_BASEDN;\n-      }\n-\n-\t\t\t$parsedURI=parse_url(LDAP_AUTH_SERVER_URI);\n-\t\t\tif ($parsedURI === FALSE) {\n-\t\t\t\t$this->_log('Could not parse LDAP_AUTH_SERVER_URI in config.php',E_USER_ERROR);\n-\t\t\t\treturn FALSE;\n-\t\t\t}\n-      $this->_host = $parsedURI['host'];\n-      $this->_scheme = $parsedURI['scheme'];\n-\n-      if (is_int($parsedURI['port'])) {\n-        $this->_port = $parsedURI['port'];\n-      } else {\n-        $this->_port = ($this->_scheme === 'ldaps') ? 636 : 389 ;\n-      }   \n-\n-      $this->_useTLS = defined('LDAP_AUTH_USETLS') ? LDAP_AUTH_USETLS : FALSE;\n-\n-      $this->_allowUntrustedCerts = defined('LDAP_AUTH_ALLOW_UNTRUSTED_CERT') ?\n-        LDAP_AUTH_ALLOW_UNTRUSTED_CERT : FALSE;\n-\n-      $this->_schemaCacheEnable= defined('LDAP_AUTH_SCHEMA_CACHE_ENABLE') ?\n-        LDAP_AUTH_SCHEMA_CACHE_ENABLE : TRUE;\n-\n-      $this->_schemaCacheTimeout= defined('LDAP_AUTH_SCHEMA_CACHE_TIMEOUT') ?\n-        LDAP_AUTH_SCHEMA_CACHE_TIMEOUT : 86400;\n-\n-      $this->_logAttempts= defined('LDAP_AUTH_LOG_ATTEMPTS') ?\n-        LDAP_AUTH_LOG_ATTEMPTS : FALSE;\n-\n-      $this->_ldapLoginAttrib = defined('LDAP_AUTH_LOGIN_ATTRIB') ?\n-        LDAP_AUTH_LOGIN_ATTRIB : null;\n-\n-\t\t\t\n-      /**\n-      Building LDAP connection\n-      **/\n-\n-      $ldapConnParams=array(\n-\t\t'host'=> $this->_scheme.'://'.$this->_host,\n-\t\t'options' => array('LDAP_OPT_REFERRALS' => 0),\n-      \t'basedn'=> $this->_baseDN,\n-        'port' => $this->_port,\n-        'starttls' => $this->_useTLS\n-\t\t\t);\n-\n-\t\t\tif (!$this->_anonBeforeBind) {\n-\t\t\t\t$ldapConnParams['binddn']= $this->_serviceBindDN;\n-\t\t\t\t$ldapConnParams['bindpw']= $this->_serviceBindPass;\n-\t\t\t}\n-\t\t\t\n-\t\t\tif ($this->_allowUntrustedCerts) {\n-\t\t\t\tputenv('LDAPTLS_REQCERT=never');\n-\t\t\t}\n-\n-      if ($this->_debugMode) $this->_log(print_r($ldapConnParams,TRUE), E_USER_NOTICE);\n-\t\t\t$ldapConn=Net_LDAP2::connect($ldapConnParams);\n- \t\t\t\n-      if (get_class($ldapConn) !== 'Net_LDAP2') {\n-\t\t\t\t$this->_log(\n-\t\t\t\t\t'Could not connect to LDAP Server: '.$ldapConn->getMessage().' with '.$this->_getBindDNWord(), \n-\t\t\t\t\tE_USER_ERROR\n-\t\t\t\t);\n-\t\t\t\treturn FALSE;\n-\t\t\t} else {\n-        $this->ldapObj = $ldapConn;\n-        $this->_log(\n-          'Connected to LDAP Server: '.LDAP_AUTH_SERVER_URI. ' with '.$this->_getBindDNWord());\n-      }\n-    \n-\t\t\t// Bind with service account if orignal connexion was anonymous\n-\t\t\tif (($this->_anonBeforeBind) && (strlen($this->_bindDN > 0))) {\n-\t\t\t\t$binding=$this->ldapObj->bind($this->_serviceBindDN, $this->_serviceBindPass);\n-\t\t\t\tif (get_class($binding) !== 'Net_LDAP2') {\n-\t\t\t\t\t$this->_log(\n-\t\t\t\t\t\t'Cound not bind service account: '.$binding->getMessage(),E_USER_ERROR);\n-\t\t\t\t\treturn FALSE;\n-\t\t\t\t} else {\n-          $this->_log('Bind with '.$this->_serviceBindDN.' successful.',E_USER_NOTICE);\n+    }\n+\n+    /**\n+     * @param string $subject The subject string\n+     * @param string $ignore Set of characters to leave untouched\n+     * @param int $flags Any combination of LDAP_ESCAPE_* flags to indicate the\n+     *                   set(s) of characters to escape.\n+     * @return string\n+     */\n+    function ldap_escape($subject, $ignore = '', $flags = 0)\n+    {\n+        if (!function_exists('ldap_escape')) {\n+            define('LDAP_ESCAPE_FILTER', 0x01);\n+            define('LDAP_ESCAPE_DN',     0x02);\n+            \n+            static $charMaps = array(\n+                LDAP_ESCAPE_FILTER => array('\\\\', '*', '(', ')', \"\\x00\"),\n+                LDAP_ESCAPE_DN     => array('\\\\', ',', '=', '+', '<', '>', ';', '\"', '#'),\n+            );\n+\n+            // Pre-process the char maps on first call\n+            if (!isset($charMaps[0])) {\n+                $charMaps[0] = array();\n+                for ($i = 0; $i < 256; $i++) {\n+                    $charMaps[0][chr($i)] = sprintf('\\\\%02x', $i);;\n+                }\n+\n+                for ($i = 0, $l = count($charMaps[LDAP_ESCAPE_FILTER]); $i < $l; $i++) {\n+                    $chr = $charMaps[LDAP_ESCAPE_FILTER][$i];\n+                    unset($charMaps[LDAP_ESCAPE_FILTER][$i]);\n+                    $charMaps[LDAP_ESCAPE_FILTER][$chr] = $charMaps[0][$chr];\n+                }\n+\n+                for ($i = 0, $l = count($charMaps[LDAP_ESCAPE_DN]); $i < $l; $i++) {\n+                    $chr = $charMaps[LDAP_ESCAPE_DN][$i];\n+                    unset($charMaps[LDAP_ESCAPE_DN][$i]);\n+                    $charMaps[LDAP_ESCAPE_DN][$chr] = $charMaps[0][$chr];\n+                }\n+            }\n+\n+            // Create the base char map to escape\n+            $flags = (int)$flags;\n+            $charMap = array();\n+            if ($flags & LDAP_ESCAPE_FILTER) {\n+                $charMap += $charMaps[LDAP_ESCAPE_FILTER];\n+            }\n+            if ($flags & LDAP_ESCAPE_DN) {\n+                $charMap += $charMaps[LDAP_ESCAPE_DN];\n+            }\n+            if (!$charMap) {\n+                $charMap = $charMaps[0];\n+            }\n+\n+            // Remove any chars to ignore from the list\n+            $ignore = (string)$ignore;\n+            for ($i = 0, $l = strlen($ignore); $i < $l; $i++) {\n+                unset($charMap[$ignore[$i]]);\n+            }\n+\n+            // Do the main replacement\n+            $result = strtr($subject, $charMap);\n+\n+            // Encode leading/trailing spaces if LDAP_ESCAPE_DN is passed\n+            if ($flags & LDAP_ESCAPE_DN) {\n+                if ($result[0] === ' ') {\n+                    $result = '\\\\20' . substr($result, 1);\n+                }\n+                if ($result[strlen($result) - 1] === ' ') {\n+                    $result = substr($result, 0, -1) . '\\\\20';\n+                }\n+            }\n+\n+            return $result;\n+        }else{\n+            return ldap_escape($subject, $ignore, $flags);\n+        }    \n+    }\n+        \n+    /**\n+     * Finds client's IP address\n+     * @return string\n+     */\n+    private function _getClientIP() {\n+        if (!empty($_SERVER['HTTP_CLIENT_IP'])) {\n+            //check ip from share internet\n+\n+            $ip = $_SERVER['HTTP_CLIENT_IP'];\n+        } elseif (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) {\n+            //to check ip is pass from proxy\n+            $ip = $_SERVER['HTTP_X_FORWARDED_FOR'];\n+        } else {\n+            $ip = $_SERVER['REMOTE_ADDR'];\n         }\n-\t\t\t} \n-\t\t\t\n-\t\t\t//Cache LDAP Schema\n-\t\t\tif ($ldapSchemaCacheEnable) {\n-        $this->_getSchemaCache();\n-\t\t\t}\n-\n-      //Validate BaseDN \n-      $baseDNObj=$this->ldapObj->getEntry($this->_baseDN);\n-      if (get_class($baseDNObj) !== 'Net_LDAP2_Entry') {\n-        $this->_log('Cound not get LDAP_AUTH_BASEDN.  Please check config.php',E_USER_ERROR);\n-        //return FALSE;\n-      }\n-\t\t\t\n-\t\t\t//Searching for user\n-\t\t\t$escapedUserName=Net_LDAP2_Util::escape_filter_value(array($login));\n-\t\t\t$completedSearchFilter=str_replace('???',$escapedUserName[0],LDAP_AUTH_SEARCHFILTER);\n-\t\t\t$filterObj=Net_LDAP2_Filter::parse($completedSearchFilter);\n-\t\t\tif (get_class($filterObj) !== 'Net_LDAP2_Filter') {\n-\t\t\t\t$this->_log( 'Could not parse LDAP Search filter', E_USER_ERROR);\n-\t\t\t\treturn FALSE;\n-\t\t\t}\n-      if ($this->_debugMode) $this->_log(\n-        \"Seaching for user $login with this query \".$filterObj->asString().' within '.$this->_baseDN);\n-\t\t\t$searchResults=$this->ldapObj->search($this->_baseDN, $filterObj);\n-\t\t\tif (get_class($searchResults) !== 'Net_LDAP2_Search') {\n-\t\t\t\t$this->_log('LDAP Search Failed: '.$searchResults->getMessage(),E_USER_ERROR);\n-\t\t\t\treturn FALSE;\n-\t\t\t} elseif ($searchResults->count() === 0) {\n-\t\t\t\t$this->_log((string)$login, 'Unknown User',\tE_USER_NOTICE);\n-\t\t\t\treturn FALSE;\n-\t\t\t} elseif ($searchResults->count() > 1 ) {\n-\t\t\t\t$this->_log('Multiple DNs found for username '.(string)$login, E_USER_WARNING);\n-\t\t\t\treturn FALSE;\n-\t\t\t}\n-\t\t\t//Getting user's DN from search\n-\t\t\t$userEntry=$searchResults->shiftEntry();\n-\t\t\t$userDN=$userEntry->dn();\n-\t\t\t//Binding with user's DN. \n-\t\t\tif ($this->_debugMode) $this->_log('Try to bind with user\\'s DN: '.$userDN);\n-\t\t\t$loginAttempt=$this->ldapObj->bind($userDN, $password);\n-\t\t\tif ($loginAttempt === TRUE) {\n-\t\t\t\t$this->_log('User: '.(string)$login.' authentication successful');\n-\t\t\t\tif (strlen($this->_ldapLoginAttrib) > 0) {\n-          if ($this->_debugMode) $this->_log('Looking up TT-RSS username attribute in '.$this->_ldapLoginAttrib);\n-          $ttrssUsername=$userEntry->getValue($this->_ldapLoginAttrib,'single');\n-          $this->ldapObj->disconnect();\n-          if (!is_string($ttrssUsername)) {\n-            $this->_log('Could not find user name attribute '.$this->_ldapLoginAttrib.' in LDAP entry', E_USER_WARNING);\n-            return FALSE;\n-          } \n-          return $this->base->auto_create_user($ttrssUsername);\n+\n+        return $ip;\n+    }\n+\n+    private function _getBindDNWord() {\n+        return (strlen($this->_serviceBindDN) > 0 ) ? $this->_serviceBindDN : 'anonymous DN';\n+    }\n+\n+    private function _getTempDir() {\n+        if (!sys_get_temp_dir()) {\n+            $tmpFile = tempnam();\n+            $tmpDir = dirname($tmpFile);\n+            unlink($tmpFile);\n+            unset($tmpFile);\n+            return $tmpDir;\n         } else {\n-          $this->ldapObj->disconnect();\n-          return $this->base->auto_create_user($login);\n+            return sys_get_temp_dir();\n+        }\n+    }\n+\n+    /**\n+     * Main Authentication method\n+     * Required for plugin interface \n+     * @param unknown $login  User's username\n+     * @param unknown $password User's password\n+     * @return boolean\n+     */\n+    function authenticate($login, $password) {\n+        if ($login && $password) {\n+\n+            if (!function_exists('ldap_connect')) {\n+                trigger_error('auth_ldap requires PHP\\'s PECL LDAP package installed.');\n+                return FALSE;\n+            }\n+\n+            /**\n+              Loading configuration\n+             * */\n+            $this->_debugMode = defined('LDAP_AUTH_DEBUG') ?\n+                    LDAP_AUTH_DEBUG : FALSE;\n+\n+            $this->_anonBeforeBind = defined('LDAP_AUTH_ANONYMOUSBEFOREBIND') ?\n+                    LDAP_AUTH_ANONYMOUSBEFOREBIND : FALSE;\n+\n+            $this->_serviceBindDN = defined('LDAP_AUTH_BINDDN') ? LDAP_AUTH_BINDDN : null;\n+            $this->_serviceBindPass = defined('LDAP_AUTH_BINDPW') ? LDAP_AUTH_BINDPW : null;\n+            $this->_baseDN = defined('LDAP_AUTH_BASEDN') ? LDAP_AUTH_BASEDN : null;\n+            if (!defined('LDAP_AUTH_BASEDN')) {\n+                $this->_log('LDAP_AUTH_BASEDN is required and not defined.', E_USER_ERROR);\n+                return FALSE;\n+            } else {\n+                $this->_baseDN = LDAP_AUTH_BASEDN;\n+            }\n+\n+            $parsedURI = parse_url(LDAP_AUTH_SERVER_URI);\n+            if ($parsedURI === FALSE) {\n+                $this->_log('Could not parse LDAP_AUTH_SERVER_URI in config.php', E_USER_ERROR);\n+                return FALSE;\n+            }\n+            $this->_host = $parsedURI['host'];\n+            $this->_scheme = $parsedURI['scheme'];\n+\n+            if (is_int($parsedURI['port'])) {\n+                $this->_port = $parsedURI['port'];\n+            } else {\n+                $this->_port = ($this->_scheme === 'ldaps') ? 636 : 389;\n+            }\n+\n+            $this->_useTLS = defined('LDAP_AUTH_USETLS') ? LDAP_AUTH_USETLS : FALSE;\n+\n+            $this->_logAttempts = defined('LDAP_AUTH_LOG_ATTEMPTS') ?\n+                    LDAP_AUTH_LOG_ATTEMPTS : FALSE;\n+\n+            $this->_ldapLoginAttrib = defined('LDAP_AUTH_LOGIN_ATTRIB') ?\n+                    LDAP_AUTH_LOGIN_ATTRIB : null;\n+\n+\n+            /**\n+              Building LDAP connection\n+             * */\n+            $ldapConnParams = array(\n+                'host' => $this->_host,\n+                'basedn' => $this->_baseDN,\n+                'port' => $this->_port,\n+                'starttls' => $this->_useTLS\n+            );\n+\n+            if ($this->_debugMode)\n+                $this->_log(print_r($ldapConnParams, TRUE), E_USER_NOTICE);\n+            $ldapConn = @ldap_connect($this->_host, $this->_port);\n+            if ($ldapConn === FALSE) {\n+                $this->_log('Could not connect to LDAP Server: \\'' . $this->_host . '\\'', E_USER_ERROR);\n+                return false;\n+            }\n+\n+            /* Enable LDAP protocol version 3. */\n+            if (!@ldap_set_option($ldapConn, LDAP_OPT_PROTOCOL_VERSION, 3)) {\n+                $this->_log('Failed to set LDAP Protocol version (LDAP_OPT_PROTOCOL_VERSION) to 3', E_USER_ERROR);\n+                return false;\n+            }\n+\n+            /* Set referral option */\n+            if (!@ldap_set_option($ldapConn, LDAP_OPT_REFERRALS, FALSE)) {\n+                $this->_log('Failed to set LDAP Referrals (LDAP_OPT_REFERRALS) to TRUE', E_USER_ERROR);\n+                return false;\n+            }\n+\n+            if (stripos($this->_host, \"ldaps:\") === FALSE and $this->_useTLS) {\n+                if (!@ldap_start_tls($ldapConn)) {\n+                    $this->_log('Unable to force TLS', E_USER_ERROR);\n+                    return false;\n+                }\n+            }\n+            $error = @ldap_bind($ldapConn, $this->_serviceBindDN, $this->_serviceBindPass);\n+            if ($error === FALSE) {\n+                $this->_log(\n+                        'LDAP bind(): Bind failed (' . $error . ')with DN ' . $this->_serviceBindDN, E_USER_ERROR\n+                );\n+                return FALSE;\n+            } else {\n+                $this->_log(\n+                        'Connected to LDAP Server: ' . LDAP_AUTH_SERVER_URI . ' with ' . $this->_getBindDNWord());\n+            }\n+\n+            // Bind with service account if orignal connexion was anonymous\n+            /* if (($this->_anonBeforeBind) && (strlen($this->_bindDN > 0))) {\n+              $binding=$this->ldapObj->bind($this->_serviceBindDN, $this->_serviceBindPass);\n+              if (get_class($binding) !== 'Net_LDAP2') {\n+              $this->_log(\n+              'Cound not bind service account: '.$binding->getMessage(),E_USER_ERROR);\n+              return FALSE;\n+              } else {\n+              $this->_log('Bind with '.$this->_serviceBindDN.' successful.',E_USER_NOTICE);\n+              }\n+              } */\n+\n+            //Searching for user\n+            $filterObj = str_replace('???', ldap_escape($login), LDAP_AUTH_SEARCHFILTER);\n+            $searchResults = @ldap_search($ldapConn, $this->_baseDN, $filterObj, array('displayName', 'title', 'sAMAccountName'), 0, 0, 0);\n+            if ($searchResults === FALSE) {\n+                $this->_log('LDAP Search Failed on base \\'' . $this->_baseDN . '\\' for \\'' . $filterObj . '\\'', E_USER_ERROR);\n+                return FALSE;\n+            }\n+            $count = @ldap_count_entries($ldapConn, $searchResults);\n+            if ($count === FALSE) {\n+                \n+            } elseif ($count > 1) {\n+                $this->_log('Multiple DNs found for username ' . (string) $login, E_USER_WARNING);\n+                return FALSE;\n+            } elseif ($count === 0) {\n+                $this->_log((string) $login, 'Unknown User', E_USER_NOTICE);\n+                return FALSE;\n+            }\n+\n+            //Getting user's DN from search\n+            $userEntry = @ldap_first_entry($ldapConn, $searchResults);\n+            if ($userEntry === FALSE) {\n+                $this->_log('LDAP search(): Unable to retrieve result after searching base \\'' . $this->_baseDN . '\\' for \\'' . $filterObj . '\\'', E_USER_WARNING);\n+                return false;\n+            }\n+            $userAttributes = @ldap_get_attributes($ldapConn, $userEntry);\n+            $userDN = @ldap_get_dn($ldapConn, $userEntry);\n+            if ($userDN == FALSE) {\n+                $this->_log('LDAP search(): Unable to get DN after searching base \\'' . $this->_baseDN . '\\' for \\'' . $filterObj . '\\'', E_USER_WARNING);\n+                return false;\n+            }\n+            //Binding with user's DN. \n+            if ($this->_debugMode)\n+                $this->_log('Try to bind with user\\'s DN: ' . $userDN);\n+            $loginAttempt = @ldap_bind($ldapConn, $userDN, $password);\n+            if ($loginAttempt === TRUE) {\n+                $this->_log('User: ' . (string) $login . ' authentication successful');\n+                if (strlen(userAttributes) > 0) {\n+                    if ($this->_debugMode)\n+                        $this->_log('Looking up TT-RSS username attribute in ' . $this->_ldapLoginAttrib);\n+                    $ttrssUsername = $userAttributes['sAMAccountName'][0];\n+                    ;\n+                    @ldap_close($ldapConn);\n+                    if (!is_string($ttrssUsername)) {\n+                        $this->_log('Could not find user name attribute ' . $this->_ldapLoginAttrib . ' in LDAP entry', E_USER_WARNING);\n+                        return FALSE;\n+                    }\n+                    return $this->base->auto_create_user($ttrssUsername);\n+                } else {\n+                    @ldap_close($ldapConn);\n+                    return $this->base->auto_create_user($login);\n+                }\n+            } else {\n+                @ldap_close($ldapConn);\n+                $this->_log('User: ' . (string) $login . ' authentication failed');\n+                return FALSE;\n+            }\n         }\n-\t\t\t} elseif ($loginAttempt->getCode() == 49) {\n-        $this->ldapObj->disconnect();\n-\t\t\t\t$this->_log('User: '.(string)$login.' authentication failed');\n-\t\t\t\treturn FALSE;\n-\t\t\t} else {\n-        $this->ldapObj->disconnect();\n-\t\t\t\t$this->_log('Unknown Error: Code: '.$loginAttempt->getCode().\n-\t\t\t\t\t' Message: '.$loginAttempt->getMessage().' user('.(string)$login.')',E_USER_WARNING);\n-\t\t\t\treturn FALSE;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-\t\n-\t/**\n-\t * Returns plugin API version\n-\t * Required for plugin interface\n-\t * @return number\n-\t */\n-\tfunction api_version() {\n-\t\treturn 2;\n-\t}\n+        return false;\n+    }\n+\n+    /**\n+     * Returns plugin API version\n+     * Required for plugin interface\n+     * @return number\n+     */\n+    function api_version() {\n+        return 2;\n+    }\n \n }\n "
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "582ade49fd433a30b403caa1d0689fca5f3c99e1",
            "date": "2022-11-30T20:17:31Z",
            "author_login": "hydrian"
          },
          {
            "sha": "50e1d7b54ff60d0508cff90c1b3a51d64207c19f",
            "date": "2022-11-30T20:16:16Z",
            "author_login": "hydrian"
          },
          {
            "sha": "751f27bfbc672c77ab8aa0c6389936d116b530c2",
            "date": "2022-11-30T20:14:53Z",
            "author_login": "hydrian"
          },
          {
            "sha": "58e9431a0d39e308af1d74f0a6fc91fbab3f73c7",
            "date": "2022-11-30T20:13:27Z",
            "author_login": "hydrian"
          },
          {
            "sha": "003ca55bbd6e0a87fb729383e51eb269d918313d",
            "date": "2022-10-30T06:45:06Z",
            "author_login": "Mic92"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L",
    "cwe_id": "CWE-90",
    "description": "A vulnerability, which was classified as problematic, has been found in hydrian TTRSS-Auth-LDAP. Affected by this issue is some unknown functionality of the component Username Handler. The manipulation leads to ldap injection. Upgrading to version 2.0b1 is able to address this issue. The patch is identified as a7f7a5a82d9202a5c40d606a5c519ba61b224eb8. It is recommended to upgrade the affected component. VDB-217622 is the identifier assigned to this vulnerability.",
    "attack_vector": "ADJACENT_NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-01-07T17:15:09.430",
    "last_modified": "2024-11-21T02:24:12.460",
    "fix_date": "2015-11-02T15:30:48Z"
  },
  "references": [
    {
      "url": "https://github.com/hydrian/TTRSS-Auth-LDAP/commit/a7f7a5a82d9202a5c40d606a5c519ba61b224eb8",
      "source": "cna@vuldb.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/hydrian/TTRSS-Auth-LDAP/pull/14",
      "source": "cna@vuldb.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/hydrian/TTRSS-Auth-LDAP/releases/tag/2.0b1",
      "source": "cna@vuldb.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?ctiid.217622",
      "source": "cna@vuldb.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?id.217622",
      "source": "cna@vuldb.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/hydrian/TTRSS-Auth-LDAP/commit/a7f7a5a82d9202a5c40d606a5c519ba61b224eb8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/hydrian/TTRSS-Auth-LDAP/pull/14",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/hydrian/TTRSS-Auth-LDAP/releases/tag/2.0b1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?ctiid.217622",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?id.217622",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:43.526732",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "TTRSS-Auth-LDAP",
    "owner": "hydrian",
    "created_at": "2013-04-07T22:21:18Z",
    "updated_at": "2024-06-23T06:25:29Z",
    "pushed_at": "2024-01-02T14:29:35Z",
    "size": 101,
    "stars": 28,
    "forks": 21,
    "open_issues": 12,
    "watchers": 28,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "PHP": 15147
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T07:49:55.594030"
  }
}