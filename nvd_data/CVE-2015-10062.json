{
  "cve_id": "CVE-2015-10062",
  "github_data": {
    "repository": "blankenberg/galaxy-data-resource",
    "fix_commit": "50d65f45d3f5be5d1fbff2e45ac5cec075f07d42",
    "related_commits": [
      "50d65f45d3f5be5d1fbff2e45ac5cec075f07d42",
      "50d65f45d3f5be5d1fbff2e45ac5cec075f07d42"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "50d65f45d3f5be5d1fbff2e45ac5cec075f07d42",
      "commit_date": "2015-01-13T15:27:49Z",
      "author": {
        "login": "blankenberg",
        "type": "User",
        "stats": {
          "total_commits": 1583,
          "average_weekly_commits": 1.6645636172450053,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 299
        }
      },
      "commit_message": {
        "title": "Fix a critical security vulnerability where unsanitized user-modifiable values could be included in a command line template.",
        "length": 124,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 538,
        "additions": 515,
        "deletions": 23
      },
      "files": [
        {
          "filename": "lib/galaxy/datatypes/metadata.py",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -20,6 +20,7 @@\n \n import galaxy.model\n from galaxy.util import listify\n+from galaxy.util.object_wrapper import sanitize_lists_to_string\n from galaxy.util import stringify_dictionary_keys\n from galaxy.util import string_as_bool\n from galaxy.util import in_directory\n@@ -232,6 +233,9 @@ def get_html( self, value, context=None, other_values=None, **kwd ):\n     def to_string( self, value ):\n         return str( value )\n \n+    def to_safe_string( self, value ):\n+        return sanitize_lists_to_string( self.to_string( value ) )\n+\n     def make_copy( self, value, target_context = None, source_context = None ):\n         return copy.deepcopy( value )\n \n@@ -480,6 +484,10 @@ class DictParameter( MetadataParameter ):\n     def to_string( self, value ):\n         return  json.dumps( value )\n \n+    def to_safe_string( self, value ):\n+        # We do not sanitize json dicts\n+        return json.safe_dumps( value )\n+\n \n class PythonObjectParameter( MetadataParameter ):\n \n@@ -510,6 +518,10 @@ def to_string( self, value ):\n             return str( self.spec.no_value )\n         return value.file_name\n \n+    def to_safe_string( self, value ):\n+        # We do not sanitize file names\n+        return self.to_string( value )\n+\n     def get_html_field( self, value=None, context=None, other_values=None, **kwd ):\n         context = context or {}\n         other_values = other_values or {}"
        },
        {
          "filename": "lib/galaxy/tools/evaluation.py",
          "status": "modified",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -2,10 +2,12 @@\n import tempfile\n \n from galaxy import model\n+from galaxy.util.object_wrapper import wrap_with_safe_string\n from galaxy.util.bunch import Bunch\n from galaxy.util.none_like import NoneDataset\n from galaxy.util.template import fill_template\n from galaxy.tools.wrappers import (\n+    ToolParameterValueWrapper,\n     DatasetFilenameWrapper,\n     DatasetListWrapper,\n     DatasetCollectionWrapper,\n@@ -114,6 +116,9 @@ def build_param_dict( self, incoming, input_datasets, output_datasets, output_pa\n         self.__populate_input_dataset_wrappers(param_dict, input_datasets, input_dataset_paths)\n         self.__populate_output_dataset_wrappers(param_dict, output_datasets, output_paths, job_working_directory)\n         self.__populate_unstructured_path_rewrites(param_dict)\n+        # Call param dict sanitizer, before non-job params are added, as we don't want to sanitize filenames.\n+        self.__sanitize_param_dict( param_dict )\n+        # Parameters added after this line are not sanitized\n         self.__populate_non_job_params(param_dict)\n \n         # Return the dictionary of parameters\n@@ -334,6 +339,24 @@ def rewrite_unstructured_paths( input_values, input ):\n             #the paths rewritten.\n             self.__walk_inputs( self.tool.inputs, param_dict, rewrite_unstructured_paths )\n \n+    def __sanitize_param_dict( self, param_dict ):\n+        \"\"\"\n+        Sanitize all values that will be substituted on the command line, with the exception of ToolParameterValueWrappers,\n+        which already have their own specific sanitization rules and also exclude special-cased named values.\n+        We will only examine the first level for values to skip; the wrapping function will recurse as necessary.\n+        \n+        Note: this method follows the style of the similar populate calls, in that param_dict is modified in-place.\n+        \"\"\"\n+        # chromInfo is a filename, do not sanitize it.\n+        skip = [ 'chromInfo' ]\n+        if not self.tool or not self.tool.options or self.tool.options.sanitize:\n+            for key, value in param_dict.items():\n+                if key not in skip:\n+                    # Remove key so that new wrapped object will occupy key slot\n+                    del param_dict[key]\n+                    # And replace with new wrapped key\n+                    param_dict[ wrap_with_safe_string( key, no_wrap_classes=ToolParameterValueWrapper ) ] = wrap_with_safe_string( value, no_wrap_classes=ToolParameterValueWrapper )\n+\n     def build( self ):\n         \"\"\"\n         Build runtime description of job to execute, evaluate command and"
        },
        {
          "filename": "lib/galaxy/tools/wrappers.py",
          "status": "modified",
          "additions": 13,
          "deletions": 5,
          "patch": "@@ -2,6 +2,7 @@\n from galaxy import exceptions\n from galaxy.util.none_like import NoneDataset\n from galaxy.util import odict\n+from galaxy.util.object_wrapper import wrap_with_safe_string\n \n from logging import getLogger\n log = getLogger( __name__ )\n@@ -162,10 +163,13 @@ def __getattr__( self, name ):\n             if name in self.metadata.spec:\n                 if rval is None:\n                     rval = self.metadata.spec[name].no_value\n-                rval = self.metadata.spec[name].param.to_string( rval )\n+                rval = self.metadata.spec[ name ].param.to_safe_string( rval )\n                 # Store this value, so we don't need to recalculate if needed\n                 # again\n                 setattr( self, name, rval )\n+            else:\n+                #escape string value of non-defined metadata value\n+                rval = wrap_with_safe_string( rval )\n             return rval\n \n         def __nonzero__( self ):\n@@ -190,9 +194,13 @@ def __init__( self, dataset, datatypes_registry=None, tool=None, name=None, data\n                 ext = tool.inputs[name].extensions[0]\n             except:\n                 ext = 'data'\n-            self.dataset = NoneDataset( datatypes_registry=datatypes_registry, ext=ext )\n+            self.dataset = wrap_with_safe_string( NoneDataset( datatypes_registry=datatypes_registry, ext=ext ), no_wrap_classes=ToolParameterValueWrapper )\n         else:\n-            self.dataset = dataset\n+            # Tool wrappers should not normally be accessing .dataset directly, \n+            # so we will wrap it and keep the original around for file paths\n+            # Should we name this .value to maintain consistency with most other ToolParameterValueWrapper?\n+            self.unsanitized = dataset\n+            self.dataset = wrap_with_safe_string( dataset, no_wrap_classes=ToolParameterValueWrapper )\n             self.metadata = self.MetadataWrapper( dataset.metadata )\n         self.datatypes_registry = datatypes_registry\n         self.false_path = getattr( dataset_path, \"false_path\", None )\n@@ -210,7 +218,7 @@ def __str__( self ):\n         if self.false_path is not None:\n             return self.false_path\n         else:\n-            return self.dataset.file_name\n+            return self.unsanitized.file_name\n \n     def __getattr__( self, key ):\n         if self.false_path is not None and key == 'file_name':\n@@ -230,7 +238,7 @@ def __getattr__( self, key ):\n                 # object store to find the static location of this\n                 # directory.\n                 try:\n-                    return self.dataset.extra_files_path\n+                    return self.unsanitized.extra_files_path\n                 except exceptions.ObjectNotFound:\n                     # NestedObjectstore raises an error here\n                     # instead of just returning a non-existent"
        },
        {
          "filename": "lib/galaxy/util/__init__.py",
          "status": "modified",
          "additions": 28,
          "deletions": 17,
          "patch": "@@ -360,46 +360,57 @@ def pretty_print_json(json_data, is_json_string=False):\n                  '#': '__pd__'}\n \n \n-def restore_text(text):\n+def restore_text( text, character_map=mapped_chars ):\n     \"\"\"Restores sanitized text\"\"\"\n     if not text:\n         return text\n-    for key, value in mapped_chars.items():\n+    for key, value in character_map.items():\n         text = text.replace(value, key)\n     return text\n \n \n-def sanitize_text(text):\n+def sanitize_text( text, valid_characters=valid_chars, character_map=mapped_chars, invalid_character='X' ):\n     \"\"\"\n     Restricts the characters that are allowed in text; accepts both strings\n-    and lists of strings.\n+    and lists of strings; non-string entities will be cast to strings.\n     \"\"\"\n-    if isinstance( text, basestring ):\n-        return _sanitize_text_helper(text)\n-    elif isinstance( text, list ):\n-        return [ _sanitize_text_helper(t) for t in text ]\n+    if isinstance( text, list ):\n+        return map( lambda x: sanitize_text( x, valid_characters=valid_characters, character_map=character_map, invalid_character=invalid_character ), text )\n+    if not isinstance( text, basestring ):\n+        text = smart_str( text )\n+    return _sanitize_text_helper( text, valid_characters=valid_characters, character_map=character_map )\n \n-\n-def _sanitize_text_helper(text):\n+def _sanitize_text_helper( text, valid_characters=valid_chars, character_map=mapped_chars, invalid_character='X' ):\n     \"\"\"Restricts the characters that are allowed in a string\"\"\"\n \n     out = []\n     for c in text:\n-        if c in valid_chars:\n+        if c in valid_characters:\n             out.append(c)\n-        elif c in mapped_chars:\n-            out.append(mapped_chars[c])\n+        elif c in character_map:\n+            out.append( character_map[c] )\n         else:\n-            out.append('X')  # makes debugging easier\n+            out.append( invalid_character )  # makes debugging easier\n     return ''.join(out)\n \n \n-def sanitize_param(value):\n+def sanitize_lists_to_string( values, valid_characters=valid_chars, character_map=mapped_chars, invalid_character='X'  ):\n+    if isinstance( values, list ):\n+        rval = []\n+        for value in values:\n+            rval.append( sanitize_lists_to_string( value, valid_characters=valid_characters, character_map=character_map, invalid_character=invalid_character ) )\n+        values = \",\".join( rval )\n+    else:\n+        values = sanitize_text( values, valid_characters=valid_characters, character_map=character_map, invalid_character=invalid_character )\n+    return values\n+\n+\n+def sanitize_param( value, valid_characters=valid_chars, character_map=mapped_chars, invalid_character='X' ):\n     \"\"\"Clean incoming parameters (strings or lists)\"\"\"\n     if isinstance( value, basestring ):\n-        return sanitize_text(value)\n+        return sanitize_text( value, valid_characters=valid_characters, character_map=character_map, invalid_character=invalid_character )\n     elif isinstance( value, list ):\n-        return map(sanitize_text, value)\n+        return map( lambda x: sanitize_text( x, valid_characters=valid_characters, character_map=character_map, invalid_character=invalid_character ), value )\n     else:\n         raise Exception('Unknown parameter type (%s)' % ( type( value ) ))\n "
        },
        {
          "filename": "lib/galaxy/util/dbkeys.py",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -4,6 +4,7 @@\n #dbkeys read from disk using builds.txt\n from galaxy.util import read_dbnames\n from galaxy.util.json import loads\n+from galaxy.util.object_wrapper import sanitize_lists_to_string\n import os.path\n \n \n@@ -84,6 +85,7 @@ def get_chrom_info( self, dbkey, trans=None, custom_build_hack_get_len_from_fast\n         # use configured server len path\n         if not chrom_info:\n             # Default to built-in build.\n-            chrom_info = os.path.join( self._static_chrom_info_path, \"%s.len\" % dbkey )\n+            # Since we are using an unverified dbkey, we will sanitize the dbkey before use\n+            chrom_info = os.path.join( self._static_chrom_info_path, \"%s.len\" % sanitize_lists_to_string( dbkey ) )\n         chrom_info = os.path.abspath( chrom_info )\n         return ( chrom_info, db_dataset )"
        },
        {
          "filename": "lib/galaxy/util/object_wrapper.py",
          "status": "added",
          "additions": 436,
          "deletions": 0,
          "patch": "@@ -0,0 +1,436 @@\n+\"\"\"\n+Classes for wrapping Objects and Sanitizing string output.\n+\"\"\"\n+\n+import inspect\n+import copy_reg\n+import logging\n+import string\n+from numbers import Number\n+from types import ( NoneType, NotImplementedType, EllipsisType, FunctionType, MethodType, GeneratorType, CodeType,\n+                    BuiltinFunctionType, BuiltinMethodType, ModuleType, XRangeType, SliceType, TracebackType, FrameType,\n+                    BufferType, DictProxyType, GetSetDescriptorType, MemberDescriptorType )\n+from UserDict import UserDict\n+\n+from galaxy.util import sanitize_lists_to_string as _sanitize_lists_to_string\n+\n+log = logging.getLogger( __name__ )\n+\n+# Define different behaviors for different types, see also: https://docs.python.org/2/library/types.html\n+\n+# Known Callable types\n+__CALLABLE_TYPES__ = ( FunctionType, MethodType, GeneratorType, CodeType, BuiltinFunctionType, BuiltinMethodType, )\n+\n+# Always wrap these types without attempting to subclass\n+__WRAP_NO_SUBCLASS__ =  ( ModuleType, XRangeType, SliceType, BufferType, TracebackType, FrameType, DictProxyType,\n+                          GetSetDescriptorType, MemberDescriptorType ) + __CALLABLE_TYPES__\n+\n+# Don't wrap or sanitize.\n+__DONT_SANITIZE_TYPES__ = ( Number, bool, NoneType, NotImplementedType, EllipsisType, bytearray, )\n+\n+# Don't wrap, but do sanitize.\n+__DONT_WRAP_TYPES__ = tuple() #( basestring, ) so that we can get the unsanitized string, we will now wrap basestring instances\n+\n+# Wrap contents, but not the container\n+__WRAP_SEQUENCES__ = ( tuple, list, )\n+__WRAP_SETS__ = ( set, frozenset, )\n+__WRAP_MAPPINGS__ = ( dict, UserDict, )\n+\n+\n+# Define the set of characters that are not sanitized, and define a set of mappings for those that are.\n+# characters that are valid\n+VALID_CHARACTERS = set( string.letters + string.digits + \" -=_.()/+*^,:?!@\" )\n+\n+# characters that are allowed but need to be escaped\n+CHARACTER_MAP = { '>': '__gt__',\n+                 '<': '__lt__',\n+                 \"'\": '__sq__',\n+                 '\"': '__dq__',\n+                 '[': '__ob__',\n+                 ']': '__cb__',\n+                 '{': '__oc__',\n+                 '}': '__cc__',\n+                 '\\n': '__cn__',\n+                 '\\r': '__cr__',\n+                 '\\t': '__tc__',\n+                 '#': '__pd__'}\n+\n+INVALID_CHARACTER = \"X\"\n+\n+def sanitize_lists_to_string( values, valid_characters=VALID_CHARACTERS, character_map=CHARACTER_MAP, invalid_character=INVALID_CHARACTER  ):\n+    return _sanitize_lists_to_string( values, valid_characters=valid_characters, character_map=character_map, invalid_character=invalid_character  )\n+\n+\n+def wrap_with_safe_string( value, no_wrap_classes = None ):\n+    \"\"\"\n+    Recursively wrap values that should be wrapped.\n+    \"\"\"\n+\n+    def __do_wrap( value ):\n+        if isinstance( value, SafeStringWrapper ):\n+            # Only ever wrap one-layer\n+            return value\n+        if callable( value ):\n+            safe_class = CallableSafeStringWrapper\n+        else:\n+            safe_class = SafeStringWrapper\n+        if isinstance( value, no_wrap_classes ):\n+            return value\n+        if isinstance( value, __DONT_WRAP_TYPES__ ):\n+            return sanitize_lists_to_string( value, valid_characters=VALID_CHARACTERS, character_map=CHARACTER_MAP )\n+        if isinstance( value, __WRAP_NO_SUBCLASS__ ):\n+            return safe_class( value, safe_string_wrapper_function = __do_wrap )\n+        for this_type in __WRAP_SEQUENCES__ + __WRAP_SETS__:\n+            if isinstance( value, this_type ):\n+                return this_type( map( __do_wrap, value ) )\n+        for this_type in __WRAP_MAPPINGS__:\n+            if isinstance( value, this_type ):\n+                # Wrap both key and value\n+                return this_type( map( lambda x: ( __do_wrap( x[0] ), __do_wrap( x[1] ) ), value.items() ) )\n+        # Create a dynamic class that joins SafeStringWrapper with the object being wrapped.\n+        # This allows e.g. isinstance to continue to work.\n+        try:\n+            wrapped_class_name = value.__name__\n+            wrapped_class = value\n+        except:\n+            wrapped_class_name = value.__class__.__name__\n+            wrapped_class = value.__class__\n+        value_mod = inspect.getmodule( value )\n+        if value_mod:\n+            wrapped_class_name = \"%s.%s\" % ( value_mod.__name__, wrapped_class_name )\n+        wrapped_class_name = \"SafeStringWrapper(%s:%s)\" % ( wrapped_class_name, \",\".join( sorted( map( str, no_wrap_classes ) ) ) )\n+        do_wrap_func_name = \"__do_wrap_%s\" % ( wrapped_class_name )\n+        do_wrap_func = __do_wrap\n+        global_dict = globals()\n+        if wrapped_class_name in global_dict:\n+            # Check to see if we have created a wrapper for this class yet, if so, reuse\n+            wrapped_class = global_dict.get( wrapped_class_name )\n+            do_wrap_func = global_dict.get( do_wrap_func_name, __do_wrap )\n+        else:\n+            try:\n+                wrapped_class = type( wrapped_class_name, ( safe_class, wrapped_class, ), {} )\n+            except TypeError, e:\n+                 # Fail-safe for when a class cannot be dynamically subclassed.\n+                 log.warning( \"Unable to create dynamic subclass for %s, %s: %s\", type( value), value, e )\n+                 wrapped_class = type( wrapped_class_name, ( safe_class, ), {} )\n+            if wrapped_class not in ( SafeStringWrapper, CallableSafeStringWrapper ):\n+                # Save this wrapper for reuse and pickling/copying\n+                global_dict[ wrapped_class_name ] = wrapped_class\n+                do_wrap_func.__name__ = do_wrap_func_name\n+                global_dict[ do_wrap_func_name ] = do_wrap_func\n+                def pickle_safe_object( safe_object ):\n+                    return ( wrapped_class, ( safe_object.unsanitized, do_wrap_func, ) )\n+                # Set pickle and copy properties\n+                copy_reg.pickle( wrapped_class, pickle_safe_object, do_wrap_func )\n+        return wrapped_class( value, safe_string_wrapper_function = do_wrap_func )\n+    # Determine classes not to wrap\n+    if no_wrap_classes:\n+        if not isinstance( no_wrap_classes, ( tuple, list ) ):\n+            no_wrap_classes = [ no_wrap_classes ]\n+        no_wrap_classes = list( no_wrap_classes ) + list( __DONT_SANITIZE_TYPES__ ) + [ SafeStringWrapper ]\n+    else:\n+        no_wrap_classes = list( __DONT_SANITIZE_TYPES__ ) + [ SafeStringWrapper ]\n+    no_wrap_classes = tuple( set( sorted( no_wrap_classes, key=str ) ) )\n+    return __do_wrap( value )\n+\n+\n+# N.B. refer to e.g. https://docs.python.org/2/reference/datamodel.html for information on Python's Data Model.\n+\n+\n+class SafeStringWrapper( object ):\n+    \"\"\"\n+    Class that wraps and sanitizes any provided value's attributes \n+    that will attempt to be cast into a string.\n+    \n+    Attempts to mimic behavior of original class, including operands.\n+    \n+    To ensure proper handling of e.g. subclass checks, the *wrap_with_safe_string()*\n+    method should be used.\n+    \n+    This wrapping occurs in a recursive/parasitic fashion, as all called attributes of \n+    the originally wrapped object will also be wrapped and sanitized, unless the attribute\n+    is of a type found in __DONT_SANITIZE_TYPES__ + __DONT_WRAP_TYPES__, where e.g. ~(strings\n+    will still be sanitized, but not wrapped), and e.g. integers will have neither.\n+    \"\"\"\n+    __UNSANITIZED_ATTRIBUTE_NAME__ = 'unsanitized' \n+    __NO_WRAP_NAMES__ = [ '__safe_string_wrapper_function__', __UNSANITIZED_ATTRIBUTE_NAME__]\n+\n+\n+    def __new__( cls, *arg, **kwd ):\n+        # We need to define a __new__ since, we are subclassing from e.g. immutable str, which internally sets data \n+        # that will be used when other + this (this + other is handled by __add__)\n+        safe_string_wrapper_function = kwd.get( 'safe_string_wrapper_function', None) or wrap_with_safe_string\n+        try:\n+            return super( SafeStringWrapper, cls ).__new__( cls, sanitize_lists_to_string( arg[0], valid_characters=VALID_CHARACTERS, character_map=CHARACTER_MAP ) )\n+        except Exception, e:\n+            log.warning( \"Could not provide an argument to %s.__new__: %s; will try without arguments.\", cls, e )\n+            return super( SafeStringWrapper, cls ).__new__( cls )\n+\n+    def __init__( self, value, safe_string_wrapper_function = wrap_with_safe_string ):\n+        self.unsanitized = value\n+        self.__safe_string_wrapper_function__ = safe_string_wrapper_function\n+\n+    def __str__( self ):\n+        return sanitize_lists_to_string( self.unsanitized, valid_characters=VALID_CHARACTERS, character_map=CHARACTER_MAP )\n+\n+    def __repr__( self ):\n+        return \"%s object at %x on: %s\" % ( sanitize_lists_to_string( self.__class__.__name__, valid_characters=VALID_CHARACTERS, character_map=CHARACTER_MAP ), id( self ), sanitize_lists_to_string( repr( self.unsanitized ), valid_characters=VALID_CHARACTERS, character_map=CHARACTER_MAP ) )\n+\n+    def __lt__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.unsanitized < other\n+\n+    def __le__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.unsanitized <= other\n+\n+    def __eq__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.unsanitized == other\n+\n+    def __ne__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.unsanitized != other\n+\n+    def __gt__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.unsanitized > other\n+\n+    def __ge__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.unsanitized >= other\n+\n+    def __lt__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.unsanitized < other\n+\n+    def __cmp__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return cmp( self.unsanitized, other )\n+\n+    # Do not implement __rcmp__, python 2.2 < 2.6\n+\n+    def __hash__( self ):\n+        return hash( self.unsanitized )\n+\n+    def __nonzero__( self ):\n+        return bool( self.unsanitized )\n+\n+    # Do not implement __unicode__, we will rely on __str__\n+\n+    def __getattr__( self, name ):\n+        if name in SafeStringWrapper.__NO_WRAP_NAMES__:\n+            #FIXME: is this ever reached?\n+            return object.__getattr__( self, name )\n+        return self.__safe_string_wrapper_function__( getattr( self.unsanitized, name ) )\n+\n+    def __setattr__( self, name, value ):\n+        if name in SafeStringWrapper.__NO_WRAP_NAMES__:\n+            return object.__setattr__( self, name, value )\n+        return setattr( self.unsanitized, name, value )\n+\n+    def __delattr__( self, name ):\n+        if name in SafeStringWrapper.__NO_WRAP_NAMES__:\n+            return object.__delattr__( self, name )\n+        return delattr( self.unsanitized, name )\n+\n+    def __getattribute__( self, name ):\n+        if name in SafeStringWrapper.__NO_WRAP_NAMES__:\n+            return object.__getattribute__( self, name )\n+        return self.__safe_string_wrapper_function__( getattr( object.__getattribute__( self, 'unsanitized' ), name ) )\n+\n+    # Skip Descriptors\n+\n+    # Skip __slots__\n+    \n+    # Don't need __metaclass__, we'll use the helper function to handle with subclassing for e.g. isinstance()\n+\n+    # Revisit:\n+    # __instancecheck__\n+    # __subclasscheck__\n+    # We are using a helper class to create dynamic subclasses to handle class checks\n+\n+    # We address __call__ as needed based upon unsanitized, through the use of a CallableSafeStringWrapper class\n+\n+    def __len__( self ):\n+        original_value = self.unsanitized\n+        while isinstance( original_value, SafeStringWrapper ):\n+            original_value = self.unsanitized\n+        return len( self.unsanitized )\n+\n+    def __getitem__( self, key ):\n+        return self.__safe_string_wrapper_function__( self.unsanitized[ key ] )\n+\n+    def __setitem__( self, key, value ):\n+        while isinstance( value, SafeStringWrapper ):\n+            value = value.unsanitized\n+        self.unsanitized[ key ] = value\n+\n+    def __delitem__( self, key ):\n+        del self.unsanitized[ key ]\n+\n+    def __iter__( self ):\n+        return iter( map( self.__safe_string_wrapper_function__, iter( self.unsanitized ) ) )\n+\n+    # Do not implement __reversed__\n+\n+    def __contains__( self, item ):\n+        # FIXME: Do we need to consider if item is/isn't or does/doesn't contain SafeStringWrapper?\n+        # When considering e.g. nested lists/dicts/etc, this gets complicated\n+        while isinstance( item, SafeStringWrapper ):\n+            item = item.unsanitized\n+        return item in self.unsanitized\n+\n+    # Not sure that we need these slice methods, but will provide anyway\n+    def __getslice__( self, i, j ):\n+        return self.__safe_string_wrapper_function__( self.unsanitized[ i:j ] )\n+\n+    def __setslice__( self, i, j, value ):\n+        self.unsanitized[ i:j ] = value\n+\n+    def __delslice__( self, i, j ):\n+        del self.unsanitized[ i:j ]\n+\n+    def __add__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.__safe_string_wrapper_function__( self.unsanitized + other )\n+\n+    def __sub__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.__safe_string_wrapper_function__( self.unsanitized - other )\n+\n+    def __mul__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.__safe_string_wrapper_function__( self.unsanitized * other )\n+\n+    def __floordiv__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.__safe_string_wrapper_function__( self.unsanitized // other )\n+\n+    def __mod__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.__safe_string_wrapper_function__( self.unsanitized % other )\n+\n+    def __divmod__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.__safe_string_wrapper_function__( divmod( self.unsanitized, other ) )\n+\n+    def __pow__( self, *other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.__safe_string_wrapper_function__( pow( self.unsanitized, *other ) )\n+\n+    def __lshift__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.__safe_string_wrapper_function__( self.unsanitized << other )\n+\n+    def __rshift__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.__safe_string_wrapper_function__( self.unsanitized >> other )\n+\n+    def __and__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.__safe_string_wrapper_function__( self.unsanitized & other )\n+\n+    def __xor__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.__safe_string_wrapper_function__( self.unsanitized ^ other )\n+\n+    def __or__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.__safe_string_wrapper_function__( self.unsanitized | other )\n+\n+    def __div__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.__safe_string_wrapper_function__( self.unsanitized / other )\n+\n+    def __truediv__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.__safe_string_wrapper_function__( self.unsanitized / other )\n+\n+    # The only reflected operand that we will define is __rpow__, due to coercion rules complications as per docs\n+    def __rpow__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return self.__safe_string_wrapper_function__( pow( other, self.unsanitized ) )\n+\n+    # Do not implement in-place operands\n+\n+    def __neg__( self ):\n+        return __safe_string_wrapper_function__( -self.unsanitized )\n+\n+    def __pos__( self ):\n+        return __safe_string_wrapper_function__( +self.unsanitized )\n+\n+    def __abs__( self ):\n+        return __safe_string_wrapper_function__( abs( self.unsanitized ) )\n+\n+    def __invert__( self ):\n+        return __safe_string_wrapper_function__( ~self.unsanitized )\n+\n+    def __complex__( self ):\n+        return __safe_string_wrapper_function__( complex( self.unsanitized ) )\n+\n+    def __int__( self ):\n+        return int( self.unsanitized )\n+\n+    def __float__( self ):\n+        return float( self.unsanitized )\n+\n+    def __oct__( self ):\n+        return oct( self.unsanitized )\n+\n+    def __hex__( self ):\n+        return hex( self.unsanitized )\n+\n+    def __index__( self ):\n+        return self.unsanitized.index()\n+\n+    def __coerce__( self, other ):\n+        while isinstance( other, SafeStringWrapper ):\n+            other = other.unsanitized\n+        return coerce( self.unsanitized, other )\n+\n+    def __enter__( self ):\n+        return self.unsanitized.__enter__()\n+\n+    def __exit__( self, *args ):\n+        return self.unsanitized.__exit__( *args )\n+\n+class CallableSafeStringWrapper( SafeStringWrapper ):\n+    \n+    def __call__( self, *args, **kwds ):\n+        return self.__safe_string_wrapper_function__( self.unsanitized( *args, **kwds ) )\n+\n+\n+# Enable pickling/deepcopy\n+def pickle_SafeStringWrapper( safe_object ):\n+    args = ( safe_object.unsanitized, )\n+    cls = SafeStringWrapper\n+    if isinstance( safe_object, CallableSafeStringWrapper ):\n+        cls = CallableSafeStringWrapper\n+    return ( cls, args )\n+copy_reg.pickle( SafeStringWrapper, pickle_SafeStringWrapper, wrap_with_safe_string )\n+copy_reg.pickle( CallableSafeStringWrapper, pickle_SafeStringWrapper, wrap_with_safe_string )\n+"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "ca32a1aafd64948f489a4e5cf88096f32391b1d9",
            "date": "2015-02-23T16:09:13Z",
            "author_login": "dannon"
          },
          {
            "sha": "13043546dc643400c36d73d0b570b3910ac252f3",
            "date": "2015-02-16T19:00:52Z",
            "author_login": "martenson"
          },
          {
            "sha": "d35aa1e14f5d1044d5eda1b14ba9bc65d128f6a3",
            "date": "2015-02-16T18:56:59Z",
            "author_login": "martenson"
          },
          {
            "sha": "f852463acc56e4cc80e36dfc02f1a28a7616cd4f",
            "date": "2015-02-13T14:00:30Z",
            "author_login": "natefoo"
          },
          {
            "sha": "212b1f9cb97f05e01510239bbd816f1f5663a553",
            "date": "2015-02-12T18:20:29Z",
            "author_login": "natefoo"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L",
    "cwe_id": "CWE-74",
    "description": "A vulnerability, which was classified as problematic, was found in galaxy-data-resource up to 14.10.0. This affects an unknown part of the component Command Line Template. The manipulation leads to injection. Upgrading to version 14.10.1 is able to address this issue. The patch is named 50d65f45d3f5be5d1fbff2e45ac5cec075f07d42. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-218451.",
    "attack_vector": "ADJACENT_NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-01-17T19:15:10.953",
    "last_modified": "2024-11-21T02:24:17.257",
    "fix_date": "2015-01-13T15:27:49Z"
  },
  "references": [
    {
      "url": "https://github.com/blankenberg/galaxy-data-resource/commit/50d65f45d3f5be5d1fbff2e45ac5cec075f07d42",
      "source": "cna@vuldb.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/blankenberg/galaxy-data-resource/releases/tag/v14.10.1",
      "source": "cna@vuldb.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?ctiid.218451",
      "source": "cna@vuldb.com",
      "tags": [
        "Permissions Required",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://vuldb.com/?id.218451",
      "source": "cna@vuldb.com",
      "tags": [
        "Permissions Required",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/blankenberg/galaxy-data-resource/commit/50d65f45d3f5be5d1fbff2e45ac5cec075f07d42",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/blankenberg/galaxy-data-resource/releases/tag/v14.10.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?ctiid.218451",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Permissions Required",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://vuldb.com/?id.218451",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Permissions Required",
        "Third Party Advisory",
        "VDB Entry"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:43.566176",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "galaxy-data-resource",
    "owner": "blankenberg",
    "created_at": "2015-03-03T20:05:51Z",
    "updated_at": "2015-03-03T20:06:34Z",
    "pushed_at": "2015-03-03T20:06:26Z",
    "size": 64868,
    "stars": 0,
    "forks": 0,
    "open_issues": 0,
    "watchers": 0,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Python": 11137427,
      "JavaScript": 7224156,
      "CSS": 576374,
      "HTML": 164357,
      "Shell": 51597,
      "Handlebars": 7421,
      "Perl": 5328,
      "Makefile": 44
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0.0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T08:03:20.577531"
  }
}