{
  "cve_id": "CVE-2015-10085",
  "github_data": {
    "repository": "gopistolet/gopistolet",
    "fix_commit": "b91aa4674d460993765884e8463c70e6d886bc90",
    "related_commits": [
      "b91aa4674d460993765884e8463c70e6d886bc90",
      "b91aa4674d460993765884e8463c70e6d886bc90"
    ],
    "patch_url": "https://github.com/gopistolet/gopistolet/commit/b91aa4674d460993765884e8463c70e6d886bc90.patch",
    "fix_commit_details": {
      "sha": "b91aa4674d460993765884e8463c70e6d886bc90",
      "commit_date": "2015-10-27T17:44:15Z",
      "author": {
        "login": "DenBeke",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #27 from gopistolet/ddos",
        "length": 84,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 411,
        "additions": 273,
        "deletions": 138
      },
      "files": [
        {
          "filename": "mta/mta.go",
          "status": "modified",
          "additions": 23,
          "deletions": 6,
          "patch": "@@ -205,15 +205,32 @@ func (s *Mta) HandleClient(proto smtp.Protocol) {\n \t})\n \n \tvar c *smtp.Cmd\n-\tvar ok bool\n+\tvar err error\n \n \tquit := false\n \tcmdC := make(chan bool)\n \n \tnextCmd := func() bool {\n \t\tgo func() {\n-\t\t\tc, ok = proto.GetCmd()\n-\t\t\tcmdC <- true\n+\t\t\tfor {\n+\t\t\t\tc, err = proto.GetCmd()\n+\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tif err == smtp.ErrLtl {\n+\t\t\t\t\t\tproto.Send(smtp.Answer{\n+\t\t\t\t\t\t\tStatus:  smtp.SyntaxError,\n+\t\t\t\t\t\t\tMessage: \"Line too long.\",\n+\t\t\t\t\t\t})\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// Not a line too long error. What to do?\n+\t\t\t\t\t\tcmdC <- true\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcmdC <- false\n \t\t}()\n \n \t\tselect {\n@@ -225,8 +242,8 @@ func (s *Mta) HandleClient(proto smtp.Protocol) {\n \t\t\t\t})\n \t\t\t\treturn true\n \t\t\t}\n-\t\tcase _ = <-cmdC:\n-\t\t\treturn false\n+\t\tcase q := <-cmdC:\n+\t\t\treturn q\n \n \t\t}\n \n@@ -235,7 +252,7 @@ func (s *Mta) HandleClient(proto smtp.Protocol) {\n \n \tquit = nextCmd()\n \n-\tfor ok == true && quit == false {\n+\tfor quit == false {\n \n \t\t//log.Printf(\"Received cmd: %#v\", *c)\n "
        },
        {
          "filename": "mta/mta_test.go",
          "status": "modified",
          "additions": 9,
          "deletions": 7,
          "patch": "@@ -1,7 +1,9 @@\n package mta\n \n import (\n+\t\"bufio\"\n \t\"bytes\"\n+\t\"io\"\n \t\"testing\"\n \n \t\"github.com/gopistolet/gopistolet/smtp\"\n@@ -47,18 +49,18 @@ func (p *testProtocol) Send(cmd smtp.Cmd) {\n \t}\n }\n \n-func (p *testProtocol) GetCmd() (*smtp.Cmd, bool) {\n+func (p *testProtocol) GetCmd() (*smtp.Cmd, error) {\n \tp.ctx.So(len(p.cmds), c.ShouldBeGreaterThan, 0)\n \n \tcmd := p.cmds[0]\n \tp.cmds = p.cmds[1:]\n \n \tif cmd == nil {\n-\t\treturn nil, false\n+\t\treturn nil, io.EOF\n \t}\n \n \t//c.Printf(\"SENDING: %#v\\n\", cmd)\n-\treturn &cmd, true\n+\treturn &cmd, nil\n }\n \n func (p *testProtocol) Close() {\n@@ -219,7 +221,7 @@ func TestMailAnswersCorrectSequence(t *testing.T) {\n \t\t\t\t\tTo: getMailWithoutError(\"guy2@somewhere.test\"),\n \t\t\t\t},\n \t\t\t\tsmtp.DataCmd{\n-\t\t\t\t\tR: *smtp.NewDataReader(bytes.NewReader([]byte(\"Some test email\\n.\\n\"))),\n+\t\t\t\t\tR: *smtp.NewDataReader(bufio.NewReader(bytes.NewReader([]byte(\"Some test email\\n.\\n\")))),\n \t\t\t\t},\n \t\t\t\tsmtp.QuitCmd{},\n \t\t\t},\n@@ -450,7 +452,7 @@ func TestReset(t *testing.T) {\n \t\t\t\t\t\tTo: getMailWithoutError(\"guy1@somewhere.test\"),\n \t\t\t\t\t},\n \t\t\t\t\tsmtp.DataCmd{\n-\t\t\t\t\t\tR: *smtp.NewDataReader(bytes.NewReader([]byte(\"Some email content\\n.\\n\"))),\n+\t\t\t\t\t\tR: *smtp.NewDataReader(bufio.NewReader(bytes.NewReader([]byte(\"Some email content\\n.\\n\")))),\n \t\t\t\t\t},\n \t\t\t\t\tsmtp.RcptCmd{\n \t\t\t\t\t\tTo: getMailWithoutError(\"someguy@somewhere.test\"),\n@@ -517,7 +519,7 @@ func TestReset(t *testing.T) {\n \t\t\t\t\t\tTo: getMailWithoutError(\"guy1@somewhere.test\"),\n \t\t\t\t\t},\n \t\t\t\t\tsmtp.DataCmd{\n-\t\t\t\t\t\tR: *smtp.NewDataReader(bytes.NewReader([]byte(\"Some email\\n.\\n\"))),\n+\t\t\t\t\t\tR: *smtp.NewDataReader(bufio.NewReader(bytes.NewReader([]byte(\"Some email\\n.\\n\")))),\n \t\t\t\t\t},\n \t\t\t\t\tsmtp.QuitCmd{},\n \t\t\t\t},\n@@ -592,7 +594,7 @@ func TestReset(t *testing.T) {\n \t\t\t\t\t\tTo: getMailWithoutError(\"guy1@somewhere.test\"),\n \t\t\t\t\t},\n \t\t\t\t\tsmtp.DataCmd{\n-\t\t\t\t\t\tR: *smtp.NewDataReader(bytes.NewReader([]byte(\"Some email\\n.\\n\"))),\n+\t\t\t\t\t\tR: *smtp.NewDataReader(bufio.NewReader(bytes.NewReader([]byte(\"Some email\\n.\\n\")))),\n \t\t\t\t\t},\n \t\t\t\t\tsmtp.QuitCmd{},\n \t\t\t\t},"
        },
        {
          "filename": "smtp/datareader_test.go",
          "status": "added",
          "additions": 86,
          "deletions": 0,
          "patch": "@@ -0,0 +1,86 @@\n+package smtp\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"io/ioutil\"\n+\t\"testing\"\n+)\n+\n+func compare(t *testing.T, data []byte, expected []byte) {\n+\tbr := bufio.NewReader(bytes.NewReader(data))\n+\n+\tdataReader := NewDataReader(br)\n+\toutput, err := ioutil.ReadAll(dataReader)\n+\tif bytes.Compare(output, expected) != 0 {\n+\t\tt.Errorf(\"Expected %v\\ngot %v\\n\", expected, output)\n+\t}\n+\tif err != nil {\n+\t\tt.Errorf(\"Did not expect error: %v\", err)\n+\t}\n+\n+}\n+\n+func expectError(t *testing.T, data []byte, expected error) {\n+\tbr := bufio.NewReader(bytes.NewReader(data))\n+\tdataReader := NewDataReader(br)\n+\t_, err := ioutil.ReadAll(dataReader)\n+\tif err != expected {\n+\t\tt.Errorf(\"Expected error: %v, got: %v\", expected, err)\n+\t}\n+\n+}\n+\n+func TestDataReaderValid(t *testing.T) {\n+\tdata := []byte(\"Some test mail\\nblablabla\\n.\\n\")\n+\texpected := []byte(\"Some test mail\\nblablabla\\n\")\n+\tcompare(t, data, expected)\n+\n+\tdata = []byte(\"Some test mail\\nblablabla\\n.\\nshould not read this\")\n+\texpected = []byte(\"Some test mail\\nblablabla\\n\")\n+\tcompare(t, data, expected)\n+\n+\tdata = []byte(\"Some test mail\\n..blablabla\\n.\\n\")\n+\texpected = []byte(\"Some test mail\\n.blablabla\\n\")\n+\tcompare(t, data, expected)\n+\n+\tdata = []byte(\"Some test mail\\n.blablabla\\n.\\n\")\n+\texpected = []byte(\"Some test mail\\nblablabla\\n\")\n+\tcompare(t, data, expected)\n+\n+\t// first line is 1000 chars\n+\tdata = []byte(\"aafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddd\\n.\\n\")\n+\texpected = []byte(\"aafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddd\\n\")\n+\tcompare(t, data, expected)\n+\n+\t// first line is 1001 chars but starts with a dot, so server should see it as 1000\n+\tdata = []byte(\".aafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsdddddd\\n.\\n\")\n+\texpected = []byte(\"aafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsdddddd\\n\")\n+\tcompare(t, data, expected)\n+\n+\t// first line is 1000 chars, second 10, third 1000\n+\tdata = []byte(\"aafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddd\\naj ge je a t\\naafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddd\\n.\\n\")\n+\texpected = []byte(\"aafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddd\\naj ge je a t\\naafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddd\\n\")\n+\tcompare(t, data, expected)\n+}\n+\n+func TestDataReaderInvalid(t *testing.T) {\n+\tdata := []byte(\"Some test mail\\nblablabla\\nno ending dot\")\n+\texpectError(t, data, ErrIncomplete)\n+\n+\tdata = []byte(\"Some test mail\\r\\nDot on invalid place\\n.test\")\n+\texpectError(t, data, ErrIncomplete)\n+\n+\tdata = []byte(\"\")\n+\texpectError(t, data, ErrIncomplete)\n+}\n+\n+func TestDataReaderTooLong(t *testing.T) {\n+\t// length === 1001\n+\tdata := []byte(\"aafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddd3\\n\")\n+\texpectError(t, data, ErrLtl)\n+\n+\t// first line is small, second is 1003\n+\tdata = []byte(\"Some text :)\\naafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddddddddfsdaafsddddddd321\\n\")\n+\texpectError(t, data, ErrLtl)\n+}"
        },
        {
          "filename": "smtp/parser.go",
          "status": "modified",
          "additions": 18,
          "deletions": 18,
          "patch": "@@ -1,6 +1,9 @@\n package smtp\n \n-import \"bufio\"\n+import (\n+\t\"bufio\"\n+\t\"log\"\n+)\n \n import \"strings\"\n import \"errors\"\n@@ -21,20 +24,9 @@ func (p *parser) ParseCommand(br *bufio.Reader) (command Cmd, err error) {\n \t\tservers (see Section 4).\n \t*/\n \n-\tline, err := br.ReadString('\\n')\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tfor line == \"\" {\n-\t\tline, err = br.ReadString('\\n')\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\n \tvar address *MailAddress\n-\tverb, args, err := parseLine(line)\n+\tverb, args, err := parseLine(br)\n+\tlog.Printf(\"Verb: %s. args: %v\", verb, args)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -156,7 +148,8 @@ func (p *parser) ParseCommand(br *bufio.Reader) (command Cmd, err error) {\n \n \tdefault:\n \t\t{\n-\t\t\tcommand = UnknownCmd{Cmd: verb, Line: strings.TrimSuffix(line, \"\\n\")}\n+\t\t\t// TODO: CLEAN THIS UP\n+\t\t\tcommand = UnknownCmd{Cmd: verb, Line: strings.TrimSuffix(verb, \"\\n\")}\n \t\t}\n \n \t}\n@@ -165,7 +158,7 @@ func (p *parser) ParseCommand(br *bufio.Reader) (command Cmd, err error) {\n }\n \n // parseLine returns the verb of the line and a list of all comma separated arguments\n-func parseLine(line string) (verb string, args []string, err error) {\n+func parseLine(br *bufio.Reader) (verb string, args []string, err error) {\n \n \t/*\n \t\tRFC 5321\n@@ -175,9 +168,16 @@ func parseLine(line string) (verb string, args []string, err error) {\n \t\tand the <CRLF> is 512 octets.  SMTP extensions may be used to\n \t\tincrease this limit.\n \t*/\n-\tif len(line) > 512 {\n-\t\treturn \"\", []string{}, errors.New(\"Line too long\")\n+\tbuffer, err := ReadUntill('\\n', MAX_CMD_LINE, br)\n+\tif err != nil {\n+\t\tif err == ErrLtl {\n+\t\t\tSkipTillNewline(br)\n+\t\t\treturn string(buffer), []string{}, err\n+\t\t}\n+\n+\t\treturn string(buffer), []string{}, err\n \t}\n+\tline := string(buffer)\n \n \t// Strip \\n and \\r\n \tline = strings.TrimSuffix(line, \"\\n\")"
        },
        {
          "filename": "smtp/parser_test.go",
          "status": "modified",
          "additions": 8,
          "deletions": 16,
          "patch": "@@ -48,7 +48,6 @@ func TestParser(t *testing.T) {\n \t\t}\n \n \t\tfor _, expectedCommand := range expectedCommands {\n-\t\t\tPrint(expectedCommand)\n \t\t\tcommand, err := p.ParseCommand(br)\n \t\t\tSo(err, ShouldEqual, nil)\n \t\t\tSo(command, ShouldResemble, expectedCommand)\n@@ -59,8 +58,6 @@ func TestParser(t *testing.T) {\n \tConvey(\"Testing parser DATA cmd\", t, func() {\n \t\tcommands := \"\"\n \t\tcommands += \"DATA\\r\\n\"\n-\t\tcommands += \"Some usefull data.\\r\\n\"\n-\t\tcommands += \".\\r\\n\"\n \t\tcommands += \"quit\\r\\n\"\n \n \t\tbr := bufio.NewReader(strings.NewReader(commands))\n@@ -69,13 +66,6 @@ func TestParser(t *testing.T) {\n \t\tcommand, err := p.ParseCommand(br)\n \t\tSo(err, ShouldEqual, nil)\n \t\tSo(command, ShouldHaveSameTypeAs, DataCmd{})\n-\t\tdataCommand, ok := command.(DataCmd)\n-\t\tSo(ok, ShouldEqual, true)\n-\t\tbr2 := bufio.NewReader(dataCommand.R.r)\n-\t\tline, _ := br2.ReadString('\\n')\n-\t\tSo(line, ShouldEqual, \"Some usefull data.\\r\\n\")\n-\t\tline, _ = br2.ReadString('\\n')\n-\t\tSo(line, ShouldEqual, \".\\r\\n\")\n \n \t\tcommand, err = p.ParseCommand(br)\n \t\tSo(err, ShouldEqual, nil)\n@@ -140,16 +130,16 @@ func TestParser(t *testing.T) {\n \t\t\targs []string\n \t\t}{\n \t\t\t{\n-\t\t\t\tline: \"HELO\",\n+\t\t\t\tline: \"HELO\\r\\n\",\n \t\t\t\tverb: \"HELO\",\n \t\t\t},\n \t\t\t{\n-\t\t\t\tline: \"HELO relay.example.org\",\n+\t\t\t\tline: \"HELO relay.example.org\\r\\n\",\n \t\t\t\tverb: \"HELO\",\n \t\t\t\targs: []string{\"relay.example.org\"},\n \t\t\t},\n \t\t\t{\n-\t\t\t\tline: \"MAIL FROM:<bob@example.org>\",\n+\t\t\t\tline: \"MAIL FROM:<bob@example.org>\\r\\n\",\n \t\t\t\tverb: \"MAIL\",\n \t\t\t\targs: []string{\"FROM:<bob@example.org>\"},\n \t\t\t},\n@@ -166,7 +156,8 @@ func TestParser(t *testing.T) {\n \t\t}\n \n \t\tfor _, test := range tests {\n-\t\t\tverb, args, err := parseLine(test.line)\n+\t\t\tbr := bufio.NewReader(strings.NewReader(test.line))\n+\t\t\tverb, args, err := parseLine(br)\n \t\t\tSo(err, ShouldEqual, nil)\n \t\t\tSo(verb, ShouldEqual, test.verb)\n \t\t\tSo(args, ShouldResemble, test.args)\n@@ -181,13 +172,14 @@ func TestParser(t *testing.T) {\n \t\t\taddressString string\n \t\t}{\n \t\t\t{\n-\t\t\t\tline:          \"RCPT TO:<alice@example.com>\",\n+\t\t\t\tline:          \"RCPT TO:<alice@example.com>\\r\\n\",\n \t\t\t\taddressString: \"alice@example.com\",\n \t\t\t},\n \t\t}\n \n \t\tfor _, test := range tests {\n-\t\t\t_, args, err := parseLine(test.line)\n+\t\t\tbr := bufio.NewReader(strings.NewReader(test.line))\n+\t\t\t_, args, err := parseLine(br)\n \t\t\tSo(err, ShouldEqual, nil)\n \n \t\t\taddr, err := parseTO(args)"
        },
        {
          "filename": "smtp/protocol.go",
          "status": "modified",
          "additions": 129,
          "deletions": 91,
          "patch": "@@ -2,7 +2,6 @@ package smtp\n \n import (\n \t\"bufio\"\n-\t\"bytes\"\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n@@ -33,124 +32,164 @@ var ErrLtl = errors.New(\"Line too long\")\n // ErrIncomplete Incomplete data error\n var ErrIncomplete = errors.New(\"Incomplete data\")\n \n-type LimitedReader struct {\n-\tR     io.Reader // underlying reader\n-\tN     int       // max bytes remaining\n-\tDelim byte\n-}\n+const (\n+\tMAX_DATA_LINE = 1000\n+\tMAX_CMD_LINE  = 512\n+)\n \n-func (l *LimitedReader) Read(p []byte) (int, error) {\n-\tif l.N <= 0 {\n-\t\treturn 0, io.EOF\n-\t}\n+// ReadUntill reads untill delim is found or max bytes are read.\n+// If delim was found it returns nil as error. If delim wasn't found after max bytes,\n+// it returns ErrLtl.\n+func ReadUntill(delim byte, max int, r io.Reader) ([]byte, error) {\n+\tbuffer := make([]byte, max)\n+\n+\tn := 0\n+\tfor n < max {\n+\t\tread, err := r.Read(buffer[n : n+1])\n+\t\tif read == 0 || err != nil {\n+\t\t\treturn buffer[0:n], err\n+\t\t}\n+\n+\t\tif read > 1 {\n+\t\t\tpanic(\"Should read 1 byte at a time.\")\n+\t\t}\n+\n+\t\tif buffer[n] == delim {\n+\t\t\treturn buffer[0 : n+1], nil\n+\t\t}\n+\n+\t\tn++\n \n-\tif len(p) > l.N {\n-\t\tp = p[0:l.N]\n \t}\n \n-\tbytesRead := 0\n-\tbuf := make([]byte, 1)\n-\tfor l.N > 0 && bytesRead < len(p) {\n-\t\tn, err := l.R.Read(buf)\n+\treturn buffer[0:n], ErrLtl\n+}\n \n-\t\tif n > 0 {\n-\t\t\tp[bytesRead] = buf[0]\n-\t\t\tl.N -= n\n-\t\t\tbytesRead += n\n-\t\t\tif buf[0] == l.Delim {\n-\t\t\t\tbreak\n+// SkipTillNewline removes all data untill a newline is found.\n+func SkipTillNewline(r io.Reader) error {\n+\tvar err error\n+\tfor {\n+\t\t_, err = ReadUntill('\\n', 1000, r)\n+\t\tif err != nil {\n+\t\t\tif err == ErrLtl {\n+\t\t\t\tcontinue\n \t\t\t}\n \n+\t\t\tbreak\n \t\t}\n \n-\t\tif err != nil {\n-\t\t\treturn bytesRead, err\n-\t\t}\n+\t\tbreak\n \t}\n \n-\treturn bytesRead, nil\n+\treturn err\n }\n \n-const (\n-\tMAX_LINE = 1000\n-)\n-\n // DataReader implements the reader that will read the data from a MAIL cmd\n type DataReader struct {\n-\tr      io.Reader\n-\tbuffer []byte\n+\tbr          *bufio.Reader\n+\tstate       int\n+\tbytesInLine int\n }\n \n-func NewDataReader(r io.Reader) *DataReader {\n+func NewDataReader(br *bufio.Reader) *DataReader {\n \tdr := &DataReader{\n-\t\tr:      r,\n-\t\tbuffer: make([]byte, 0, MAX_LINE),\n+\t\tbr: br,\n \t}\n \n \treturn dr\n }\n \n-func (r *DataReader) Read(p []byte) (int, error) {\n-\tvar n int = 0\n-\n-\tif len(r.buffer) > 0 {\n-\t\tn = copy(p, r.buffer)\n-\t\tr.buffer = r.buffer[n:]\n-\t\treturn n, nil\n-\t}\n-\n-\tlimited := &LimitedReader{\n-\t\tR:     r.r,\n-\t\tN:     MAX_LINE + 1,\n-\t\tDelim: '\\n',\n-\t}\n-\n-\tbr := bufio.NewReader(limited)\n+// Implementation from textproto.DotReader.Read\n+func (r *DataReader) Read(b []byte) (n int, err error) {\n+\t// Run data through a simple state machine to\n+\t// elide leading dots, rewrite trailing \\r\\n into \\n,\n+\t// and detect ending .\\r\\n line.\n+\tconst (\n+\t\tstateBeginLine = iota // beginning of line; initial state; must be zero\n+\t\tstateDot              // read . at beginning of line\n+\t\tstateDotCR            // read .\\r at beginning of line\n+\t\tstateCR               // read \\r (possibly at end of line)\n+\t\tstateData             // reading data in middle of line\n+\t\tstateEOF              // reached .\\r\\n end marker line\n+\t)\n+\n+\tbr := r.br\n+\tfor n < len(b) && r.state != stateEOF {\n+\t\tvar c byte\n+\t\tc, err = br.ReadByte()\n+\t\tif err != nil {\n+\t\t\terr = ErrIncomplete\n \n-\tline, err := br.ReadBytes('\\n')\n-\tlineLen := len(line)\n-\tif lineLen > 0 && line[len(line)-1] != '\\n' {\n-\t\tbuf := make([]byte, 1)\n+\t\t}\n+\t\tr.bytesInLine++\n+\t\tif r.bytesInLine > MAX_DATA_LINE {\n+\t\t\terr = ErrLtl\n+\t\t\tbreak\n+\t\t}\n+\t\tswitch r.state {\n+\t\tcase stateBeginLine:\n+\t\t\tif c == '.' {\n+\t\t\t\tr.state = stateDot\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif c == '\\r' {\n+\t\t\t\tr.state = stateCR\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tr.state = stateData\n \n-\t\tfor n, err := r.r.Read(buf); ; {\n-\t\t\tif n > 0 {\n-\t\t\t\tif buf[0] == '\\n' {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n+\t\tcase stateDot:\n+\t\t\tif c == '\\r' {\n+\t\t\t\tr.state = stateDotCR\n+\t\t\t\tcontinue\n \t\t\t}\n+\t\t\tif c == '\\n' {\n+\t\t\t\tr.state = stateEOF\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tr.state = stateData\n \n-\t\t\tif err != nil {\n+\t\tcase stateDotCR:\n+\t\t\tif c == '\\n' {\n+\t\t\t\tr.state = stateEOF\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t// Not part of .\\r\\n.\n+\t\t\t// Consume leading dot and emit saved \\r.\n+\t\t\tbr.UnreadByte()\n+\t\t\tc = '\\r'\n+\t\t\tr.state = stateData\n+\n+\t\tcase stateCR:\n+\t\t\tif c == '\\n' {\n+\t\t\t\tr.state = stateBeginLine\n+\t\t\t\tr.bytesInLine = 0\n \t\t\t\tbreak\n \t\t\t}\n-\n-\t\t\tn, err = r.r.Read(buf)\n+\t\t\t// Not part of \\r\\n.  Emit saved \\r\n+\t\t\tbr.UnreadByte()\n+\t\t\tc = '\\r'\n+\t\t\tr.state = stateData\n+\n+\t\tcase stateData:\n+\t\t\tif c == '\\r' {\n+\t\t\t\tr.state = stateCR\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif c == '\\n' {\n+\t\t\t\tr.state = stateBeginLine\n+\t\t\t\tr.bytesInLine = 0\n+\t\t\t}\n \t\t}\n+\t\tb[n] = c\n+\t\tn++\n \t}\n-\tfmt.Printf(\"Read %d bytes\\n\", lineLen)\n-\n-\tif bytes.Compare(line, []byte(\".\\r\\n\")) == 0 ||\n-\t\tbytes.Compare(line, []byte(\".\\r\")) == 0 ||\n-\t\tbytes.Compare(line, []byte(\".\\n\")) == 0 {\n-\n-\t\treturn 0, io.EOF\n-\t} else if lineLen > 2 && line[0] == '.' {\n-\t\tline = line[1:]\n-\t\tlineLen--\n-\t}\n-\n-\tif lineLen > MAX_LINE {\n-\t\treturn 0, ErrLtl\n-\t}\n-\n-\tn = copy(p, line)\n-\tr.buffer = r.buffer[0 : lineLen-n]\n-\tcopy(r.buffer, line[n:])\n \n-\tif err == io.EOF {\n-\t\treturn 0, ErrIncomplete\n+\tif err == nil && r.state == stateEOF {\n+\t\terr = io.EOF\n \t}\n \n-\treturn n, nil\n+\treturn\n }\n \n // Cmd All SMTP answers/commands should implement this interface.\n@@ -314,9 +353,8 @@ type Protocol interface {\n \t// Send a SMTP command.\n \tSend(Cmd)\n \t// Receive a command(will block while waiting for it).\n-\t// Returns false if there are no more commands left. Otherwise a command will be returned.\n-\t// We need the bool because if we just return nil, the nil will also implement the empty interface...\n-\tGetCmd() (*Cmd, bool)\n+\t// Returns an error if something wen't wrong. E.g line was too long.\n+\tGetCmd() (*Cmd, error)\n \t// Close the connection.\n \tClose()\n }\n@@ -343,14 +381,14 @@ func (p *MtaProtocol) Send(c Cmd) {\n \tfmt.Fprintf(p.c, \"%s\\r\\n\", c)\n }\n \n-func (p *MtaProtocol) GetCmd() (c *Cmd, ok bool) {\n+func (p *MtaProtocol) GetCmd() (c *Cmd, err error) {\n \tcmd, err := p.parser.ParseCommand(p.br)\n \tif err != nil {\n \t\tlog.Printf(\"Could not parse command: %v\", err)\n-\t\treturn nil, false\n+\t\treturn nil, err\n \t}\n \n-\treturn &cmd, true\n+\treturn &cmd, nil\n }\n \n func (p *MtaProtocol) Close() {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "78c831c4b7875de34e51da9fa25cd1c5f0bade63",
            "date": "2024-02-18T11:26:43Z",
            "author_login": "DenBeke"
          },
          {
            "sha": "a52943cfa01dbd2f0246da5a174725d8df12e51c",
            "date": "2024-02-15T21:34:24Z",
            "author_login": "DenBeke"
          },
          {
            "sha": "4cab2862da371845da0f128dbd35da5033990823",
            "date": "2024-02-15T20:54:20Z",
            "author_login": "DenBeke"
          },
          {
            "sha": "5ec4672c46f7e870f89d741ccf539cb7bcfc5893",
            "date": "2024-02-15T20:01:50Z",
            "author_login": "DenBeke"
          },
          {
            "sha": "30b8f265961125a299cd53e923f1cefa9aa88d9a",
            "date": "2024-02-10T20:42:18Z",
            "author_login": "DenBeke"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.5,
    "cvss_vector": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-404",
    "description": "A vulnerability was found in GoPistolet. It has been declared as problematic. This vulnerability affects unknown code of the component MTA. The manipulation leads to denial of service. Continious delivery with rolling releases is used by this product. Therefore, no version details of affected nor updated releases are available. The patch is identified as b91aa4674d460993765884e8463c70e6d886bc90. It is recommended to apply a patch to fix this issue. VDB-221506 is the identifier assigned to this vulnerability.",
    "attack_vector": "ADJACENT_NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-02-21T18:15:11.480",
    "last_modified": "2024-11-21T02:24:20.643",
    "fix_date": "2015-10-27T17:44:15Z"
  },
  "references": [
    {
      "url": "https://github.com/gopistolet/gopistolet/commit/b91aa4674d460993765884e8463c70e6d886bc90",
      "source": "cna@vuldb.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/gopistolet/gopistolet/pull/27",
      "source": "cna@vuldb.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://vuldb.com/?ctiid.221506",
      "source": "cna@vuldb.com",
      "tags": [
        "Permissions Required",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?id.221506",
      "source": "cna@vuldb.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/gopistolet/gopistolet/commit/b91aa4674d460993765884e8463c70e6d886bc90",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/gopistolet/gopistolet/pull/27",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://vuldb.com/?ctiid.221506",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Permissions Required",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?id.221506",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:04.089628",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "mistralmail",
    "owner": "gopistolet",
    "created_at": "2015-04-12T18:27:15Z",
    "updated_at": "2024-12-27T15:01:57Z",
    "pushed_at": "2024-02-18T11:27:02Z",
    "size": 8706,
    "stars": 75,
    "forks": 6,
    "open_issues": 0,
    "watchers": 75,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Go": 144503,
      "Vue": 13166,
      "JavaScript": 4533,
      "Dockerfile": 1307,
      "HTML": 323,
      "SCSS": 207
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T18:58:30.367777"
  }
}