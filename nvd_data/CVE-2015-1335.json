{
  "cve_id": "CVE-2015-1335",
  "github_data": {
    "repository": "lxc/lxc",
    "fix_commit": "592fd47a6245508b79fe6ac819fe6d3b2c1289be",
    "related_commits": [
      "592fd47a6245508b79fe6ac819fe6d3b2c1289be",
      "592fd47a6245508b79fe6ac819fe6d3b2c1289be"
    ],
    "patch_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be.patch",
    "fix_commit_details": {
      "sha": "592fd47a6245508b79fe6ac819fe6d3b2c1289be",
      "commit_date": "2015-08-31T17:57:20Z",
      "author": {
        "login": "hallyn",
        "type": "User",
        "stats": {
          "total_commits": 1127,
          "average_weekly_commits": 1.3627569528415961,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 289
        }
      },
      "commit_message": {
        "title": "CVE-2015-1335: Protect container mounts against symlinks",
        "length": 2212,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 383,
        "additions": 363,
        "deletions": 20
      },
      "files": [
        {
          "filename": "doc/lxc.container.conf.sgml.in",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -760,6 +760,18 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n         container. This is useful to mount /etc, /var or /home for\n         examples.\n       </para>\n+      <para>\n+\tNOTE - LXC will generally ensure that mount targets and relative\n+\tbind-mount sources are properly confined under the container\n+\troot, to avoid attacks involving over-mounting host directories\n+\tand files.  (Symbolic links in absolute mount sources are ignored)\n+\tHowever, if the container configuration first mounts a directory which\n+\tis under the control of the container user, such as /home/joe, into\n+        the container at some <filename>path</filename>, and then mounts\n+        under <filename>path</filename>, then a TOCTTOU attack would be\n+        possible where the container user modifies a symbolic link under\n+        his home directory at just the right time.\n+      </para>\n       <variablelist>\n         <varlistentry>\n           <term>"
        },
        {
          "filename": "src/lxc/cgfs.c",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -1363,7 +1363,10 @@ static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \"%s/sys/fs/cgroup\", root);\n-\tr = mount(\"cgroup_root\", path, \"tmpfs\", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \"size=10240k,mode=755\");\n+\tr = safe_mount(\"cgroup_root\", path, \"tmpfs\",\n+\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n+\t\t\t\"size=10240k,mode=755\",\n+\t\t\troot);\n \tif (r < 0) {\n \t\tSYSERROR(\"could not mount tmpfs to /sys/fs/cgroup in the container\");\n \t\treturn false;"
        },
        {
          "filename": "src/lxc/cgmanager.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -1477,7 +1477,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t}\n \n \t/* mount a tmpfs there so we can create subdirs */\n-\tif (mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\")) {\n+\tif (safe_mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\", root)) {\n \t\tSYSERROR(\"Failed to mount tmpfs at %s\", cgpath);\n \t\treturn false;\n \t}\n@@ -1488,7 +1488,7 @@ static bool cgm_bind_dir(const char *root, const char *dirname)\n \t\treturn false;\n \t}\n \n-\tif (mount(dirname, cgpath, \"none\", MS_BIND, 0)) {\n+\tif (safe_mount(dirname, cgpath, \"none\", MS_BIND, 0, root)) {\n \t\tSYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);\n \t\treturn false;\n \t}"
        },
        {
          "filename": "src/lxc/conf.c",
          "status": "modified",
          "additions": 19,
          "deletions": 16,
          "patch": "@@ -769,10 +769,11 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t * 2.6.32...\n \t\t */\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/net\",                  NULL,       MS_BIND,                        NULL },\n+\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/tty\",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys\",                                       \"%r/proc/sys\",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/net\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/tty\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sysrq-trigger\",                             \"%r/proc/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n@@ -815,7 +816,7 @@ static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_ha\n \t\t\t}\n \t\t\tmflags = add_required_remount_flags(source, destination,\n \t\t\t\t\tdefault_mounts[i].flags);\n-\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n+\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n \t\t\tsaved_errno = errno;\n \t\t\tif (r < 0 && errno == ENOENT) {\n \t\t\t\tINFO(\"Mount source or target for %s on %s doesn't exist. Skipping.\", source, destination);\n@@ -1167,7 +1168,8 @@ static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, cons\n \t\treturn 0;\n \t}\n \n-\tif (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {\n+\tif (safe_mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\",\n+\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n \t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n \t\treturn false;\n \t}\n@@ -1252,7 +1254,8 @@ static int fill_autodev(const struct lxc_rootfs *rootfs)\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tfclose(pathfile);\n-\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n+\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n+\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n \t\t\t\tSYSERROR(\"Failed bind mounting device %s from host into container\",\n \t\t\t\t\td->name);\n \t\t\t\treturn -1;\n@@ -1505,7 +1508,7 @@ static int setup_dev_console(const struct lxc_rootfs *rootfs,\n \t\treturn -1;\n \t}\n \n-\tif (mount(console->name, path, \"none\", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, path, \"none\", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n \t\treturn -1;\n \t}\n@@ -1560,7 +1563,7 @@ static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n \t\treturn 0;\n \t}\n \n-\tif (mount(console->name, lxcpath, \"none\", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, lxcpath, \"none\", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\"failed to mount '%s' on '%s'\", console->name, lxcpath);\n \t\treturn -1;\n \t}\n@@ -1710,13 +1713,13 @@ static char *get_field(char *src, int nfields)\n \n static int mount_entry(const char *fsname, const char *target,\n \t\t       const char *fstype, unsigned long mountflags,\n-\t\t       const char *data, int optional)\n+\t\t       const char *data, int optional, const char *rootfs)\n {\n #ifdef HAVE_STATVFS\n \tstruct statvfs sb;\n #endif\n \n-\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n+\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n \t\tif (optional) {\n \t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\", fsname,\n \t\t\t     target, strerror(errno));\n@@ -1763,7 +1766,7 @@ static int mount_entry(const char *fsname, const char *target,\n #endif\n \n \t\tif (mount(fsname, target, fstype,\n-\t\t\t  mountflags | MS_REMOUNT, data)) {\n+\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n \t\t\tif (optional) {\n \t\t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\",\n \t\t\t\t\t fsname, target, strerror(errno));\n@@ -1843,7 +1846,7 @@ static int mount_entry_create_dir_file(const struct mntent *mntent,\n }\n \n static inline int mount_entry_on_generic(struct mntent *mntent,\n-                 const char* path)\n+                 const char* path, const char *rootfs)\n {\n \tunsigned long mntflags;\n \tchar *mntdata;\n@@ -1863,7 +1866,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \t}\n \n \tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n-\t\t\t  mntflags, mntdata, optional);\n+\t\t\t  mntflags, mntdata, optional, rootfs);\n \n \tfree(mntdata);\n \n@@ -1872,7 +1875,7 @@ static inline int mount_entry_on_generic(struct mntent *mntent,\n \n static inline int mount_entry_on_systemfs(struct mntent *mntent)\n {\n-  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n }\n \n static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n@@ -1919,7 +1922,7 @@ static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n }\n \n static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n@@ -1935,7 +1938,7 @@ static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs);\n }\n \n static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n@@ -3602,7 +3605,7 @@ void lxc_execute_bind_init(struct lxc_conf *conf)\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \"none\", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \"none\", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n \tINFO(\"lxc.init.static bound into container at %s\", path);"
        },
        {
          "filename": "src/lxc/utils.c",
          "status": "modified",
          "additions": 234,
          "deletions": 1,
          "patch": "@@ -1404,6 +1404,239 @@ int setproctitle(char *title)\n \treturn ret;\n }\n \n+/*\n+ * @path:    a pathname where / replaced with '\\0'.\n+ * @offsetp: pointer to int showing which path segment was last seen.\n+ *           Updated on return to reflect the next segment.\n+ * @fulllen: full original path length.\n+ * Returns a pointer to the next path segment, or NULL if done.\n+ */\n+static char *get_nextpath(char *path, int *offsetp, int fulllen)\n+{\n+\tint offset = *offsetp;\n+\n+\tif (offset >= fulllen)\n+\t\treturn NULL;\n+\n+\twhile (path[offset] != '\\0' && offset < fulllen)\n+\t\toffset++;\n+\twhile (path[offset] == '\\0' && offset < fulllen)\n+\t\toffset++;\n+\n+\t*offsetp = offset;\n+\treturn (offset < fulllen) ? &path[offset] : NULL;\n+}\n+\n+/*\n+ * Check that @subdir is a subdir of @dir.  @len is the length of\n+ * @dir (to avoid having to recalculate it).\n+ */\n+static bool is_subdir(const char *subdir, const char *dir, size_t len)\n+{\n+\tsize_t subdirlen = strlen(subdir);\n+\n+\tif (subdirlen < len)\n+\t\treturn false;\n+\tif (strncmp(subdir, dir, len) != 0)\n+\t\treturn false;\n+\tif (dir[len-1] == '/')\n+\t\treturn true;\n+\tif (subdir[len] == '/' || subdirlen == len)\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+/*\n+ * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return\n+ * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.\n+ */\n+static int check_symlink(int fd)\n+{\n+\tstruct stat sb;\n+\tint ret = fstat(fd, &sb);\n+\tif (ret < 0)\n+\t\treturn -ENOENT;\n+\tif (S_ISLNK(sb.st_mode))\n+\t\treturn -ELOOP;\n+\treturn 0;\n+}\n+\n+/*\n+ * Open a file or directory, provided that it contains no symlinks.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+static int open_if_safe(int dirfd, const char *nextpath)\n+{\n+\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n+\tif (newfd >= 0) // was not a symlink, all good\n+\t\treturn newfd;\n+\n+\tif (errno == ELOOP)\n+\t\treturn newfd;\n+\n+\tif (errno == EPERM || errno == EACCES) {\n+\t\t/* we're not root (cause we got EPERM) so\n+\t\t   try opening with O_PATH */\n+\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n+\t\tif (newfd >= 0) {\n+\t\t\t/* O_PATH will return an fd for symlinks.  We know\n+\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n+\t\t\t * is now a link, then something * fishy is going on\n+\t\t\t */\n+\t\t\tint ret = check_symlink(newfd);\n+\t\t\tif (ret < 0) {\n+\t\t\t\tclose(newfd);\n+\t\t\t\tnewfd = ret;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newfd;\n+}\n+\n+/*\n+ * Open a path intending for mounting, ensuring that the final path\n+ * is inside the container's rootfs.\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ *\n+ * @target: path to be opened\n+ * @prefix_skip: a part of @target in which to ignore symbolic links.  This\n+ * would be the container's rootfs.\n+ *\n+ * Return an open fd for the path, or <0 on error.\n+ */\n+static int open_without_symlink(const char *target, const char *prefix_skip)\n+{\n+\tint curlen = 0, dirfd, fulllen, i;\n+\tchar *dup = NULL;\n+\n+\tfulllen = strlen(target);\n+\n+\t/* make sure prefix-skip makes sense */\n+\tif (prefix_skip) {\n+\t\tcurlen = strlen(prefix_skip);\n+\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n+\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n+\t\t\t\ttarget, prefix_skip);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\t/*\n+\t\t * get_nextpath() expects the curlen argument to be\n+\t\t * on a  (turned into \\0) / or before it, so decrement\n+\t\t * curlen to make sure that happens\n+\t\t */\n+\t\tif (curlen)\n+\t\t\tcurlen--;\n+\t} else {\n+\t\tprefix_skip = \"/\";\n+\t\tcurlen = 0;\n+\t}\n+\n+\t/* Make a copy of target which we can hack up, and tokenize it */\n+\tif ((dup = strdup(target)) == NULL) {\n+\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n+\t\treturn -ENOMEM;\n+\t}\n+\tfor (i = 0; i < fulllen; i++) {\n+\t\tif (dup[i] == '/')\n+\t\t\tdup[i] = '\\0';\n+\t}\n+\n+\tdirfd = open(prefix_skip, O_RDONLY);\n+\tif (dirfd < 0)\n+\t\tgoto out;\n+\twhile (1) {\n+\t\tint newfd, saved_errno;\n+\t\tchar *nextpath;\n+\n+\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n+\t\t\tgoto out;\n+\t\tnewfd = open_if_safe(dirfd, nextpath);\n+\t\tsaved_errno = errno;\n+\t\tclose(dirfd);\n+\t\tdirfd = newfd;\n+\t\tif (newfd < 0) {\n+\t\t\terrno = saved_errno;\n+\t\t\tif (errno == ELOOP)\n+\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n+\t\t\telse\n+\t\t\t\tSYSERROR(\"Error examining %s in %s\", nextpath, target);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+out:\n+\tfree(dup);\n+\treturn dirfd;\n+}\n+\n+/*\n+ * Safely mount a path into a container, ensuring that the mount target\n+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container\n+ * uses the host's /)\n+ *\n+ * CAVEAT: This function must not be used for other purposes than container\n+ * setup before executing the container's init\n+ */\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs)\n+{\n+\tint srcfd = -1, destfd, ret, saved_errno;\n+\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n+\tconst char *mntsrc = src;\n+\n+\tif (!rootfs)\n+\t\trootfs = \"\";\n+\n+\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n+\tif (flags & MS_BIND && src && src[0] != '/') {\n+\t\tINFO(\"this is a relative bind mount\");\n+\t\tsrcfd = open_without_symlink(src, NULL);\n+\t\tif (srcfd < 0)\n+\t\t\treturn srcfd;\n+\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n+\t\tif (ret < 0 || ret > 50) {\n+\t\t\tclose(srcfd);\n+\t\t\tERROR(\"Out of memory\");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tmntsrc = srcbuf;\n+\t}\n+\n+\tdestfd = open_without_symlink(dest, rootfs);\n+\tif (destfd < 0) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\treturn destfd;\n+\t}\n+\n+\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n+\tif (ret < 0 || ret > 50) {\n+\t\tif (srcfd != -1)\n+\t\t\tclose(srcfd);\n+\t\tclose(destfd);\n+\t\tERROR(\"Out of memory\");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tret = mount(mntsrc, destbuf, fstype, flags, data);\n+\tsaved_errno = errno;\n+\tif (srcfd != -1)\n+\t\tclose(srcfd);\n+\tclose(destfd);\n+\tif (ret < 0) {\n+\t\terrno = saved_errno;\n+\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n+\t\treturn ret;\n+\t}\n+\n+\treturn 0;\n+}\n+\n /*\n  * Mount a proc under @rootfs if proc self points to a pid other than\n  * my own.  This is needed to have a known-good proc mount for setting\n@@ -1446,7 +1679,7 @@ int mount_proc_if_needed(const char *rootfs)\n \treturn 0;\n \n domount:\n-\tif (mount(\"proc\", path, \"proc\", 0, NULL))\n+\tif (safe_mount(\"proc\", path, \"proc\", 0, NULL, rootfs) < 0)\n \t\treturn -1;\n \tINFO(\"Mounted /proc in container for security transition\");\n \treturn 1;"
        },
        {
          "filename": "src/lxc/utils.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -279,6 +279,8 @@ bool switch_to_ns(pid_t pid, const char *ns);\n int is_dir(const char *path);\n char *get_template_path(const char *t);\n int setproctitle(char *title);\n+int safe_mount(const char *src, const char *dest, const char *fstype,\n+\t\tunsigned long flags, const void *data, const char *rootfs);\n int mount_proc_if_needed(const char *rootfs);\n int null_stdfds(void);\n #endif /* __LXC_UTILS_H */"
        },
        {
          "filename": "src/tests/Makefile.am",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -55,6 +55,7 @@ bin_SCRIPTS += \\\n \tlxc-test-apparmor-mount \\\n \tlxc-test-checkpoint-restore \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tlxc-test-usernic\n@@ -82,6 +83,7 @@ EXTRA_DIST = \\\n \tlxc-test-cloneconfig \\\n \tlxc-test-createconfig \\\n \tlxc-test-snapdeps \\\n+\tlxc-test-symlink \\\n \tlxc-test-ubuntu \\\n \tlxc-test-unpriv \\\n \tmay_control.c \\"
        },
        {
          "filename": "src/tests/lxc-test-symlink",
          "status": "added",
          "additions": 88,
          "deletions": 0,
          "patch": "@@ -0,0 +1,88 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+# lxc: linux Container library\n+\n+# Authors:\n+# Serge Hallyn <serge.hallyn@ubuntu.com>\n+#\n+# This is a regression test for symbolic links\n+\n+dirname=`mktemp -d`\n+fname=`mktemp`\n+fname2=`mktemp`\n+\n+lxcpath=/var/lib/lxcsym1\n+\n+cleanup() {\n+\tlxc-destroy -P $lxcpath -f -n symtest1 || true\n+\trm -f $lxcpath\n+\trmdir $dirname || true\n+\trm -f $fname || true\n+\trm -f $fname2 || true\n+}\n+\n+trap cleanup EXIT SIGHUP SIGINT SIGTERM\n+\n+testrun() {\n+\texpected=$1\n+\trun=$2\n+\tpass=\"pass\"\n+\tlxc-start -P $lxcpath -n symtest1 -l trace -o $lxcpath/log || pass=\"fail\"\n+\t[ $pass = \"pass\" ] && lxc-wait -P $lxcpath -n symtest1 -t 10 -s RUNNING || pass=\"fail\"\n+\tif [ \"$pass\" != \"$expected\" ]; then\n+\t\techo \"Test $run: expected $expected but container did not.  Start log:\"\n+\t\tcat $lxcpath/log\n+\t\techo \"FAIL: Test $run: expected $expected but container did not.\"\n+\t\tfalse\n+\tfi\n+\tlxc-stop -P $lxcpath -n symtest1 -k || true\n+}\n+\n+# make lxcpath a symlink - this should NOT cause failure\n+ln -s /var/lib/lxc $lxcpath\n+\n+lxc-destroy -P $lxcpath -f -n symtest1 || true\n+lxc-create -P $lxcpath -t busybox -n symtest1\n+\n+cat >> /var/lib/lxc/symtest1/config << EOF\n+lxc.mount.entry = $dirname opt/xxx/dir none bind,create=dir\n+lxc.mount.entry = $fname opt/xxx/file none bind,create=file\n+lxc.mount.entry = $fname2 opt/xxx/file2 none bind\n+EOF\n+\n+# Regular - should succeed\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun pass 1\n+\n+# symlink - should fail\n+rm -rf /var/lib/lxc/symtest1/rootfs/opt/xxx\n+mkdir -p /var/lib/lxc/symtest1/rootfs/opt/xxx2\n+ln -s /var/lib/lxc/symtest1/rootfs/opt/xxx2 /var/lib/lxc/symtest1/rootfs/opt/xxx\n+touch /var/lib/lxc/symtest1/rootfs/opt/xxx/file2\n+testrun fail 2\n+\n+# final final symlink - should fail\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx/dir\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2src\n+ln -s $lxcpath/symtest1/rootfs/opt/xxx/file2src $lxcpath/symtest1/rootfs/opt/xxx/file2\n+testrun fail 3\n+\n+# Ideally we'd also try a loop device, but that won't work in nested containers\n+# anyway - TODO\n+\n+# what about /proc itself\n+\n+rm -rf $lxcpath/symtest1/rootfs/opt/xxx\n+mkdir -p $lxcpath/symtest1/rootfs/opt/xxx\n+touch $lxcpath/symtest1/rootfs/opt/xxx/file2\n+mv $lxcpath/symtest1/rootfs/proc $lxcpath/symtest1/rootfs/proc1\n+ln -s $lxcpath/symtest1/rootfs/proc1 $lxcpath/symtest1/rootfs/proc\n+testrun fail 4\n+\n+echo \"all tests passed\""
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "040e006d5d5c2cdccf2bcdda4f7c68b635509371",
            "date": "2025-01-09T23:24:26Z",
            "author_login": "stgraber"
          },
          {
            "sha": "4a4ba051aab0e45f1beac8b4222a230a3e6848de",
            "date": "2025-01-09T23:05:20Z",
            "author_login": "stgraber"
          },
          {
            "sha": "8d8fd27b57bf1ebc9cdbf129547961339dd45b8b",
            "date": "2025-01-08T23:07:17Z",
            "author_login": "sdanailo-42"
          },
          {
            "sha": "844c49fcf356a55b83a26a0bb8a5e6d25039f549",
            "date": "2025-01-08T22:51:15Z",
            "author_login": "sdanailo-42"
          },
          {
            "sha": "4c4636830528300d122d2a0b4aa540b61e2e7128",
            "date": "2025-01-08T23:05:26Z",
            "author_login": "sdanailo-42"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-59",
    "description": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2015-10-01T20:59:00.100",
    "last_modified": "2024-11-21T02:25:11.647",
    "fix_date": "2015-08-31T17:57:20Z"
  },
  "references": [
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-November/170045.html",
      "source": "security@ubuntu.com",
      "tags": []
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-November/171358.html",
      "source": "security@ubuntu.com",
      "tags": []
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-November/171364.html",
      "source": "security@ubuntu.com",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2019-05/msg00073.html",
      "source": "security@ubuntu.com",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2015-10/msg00023.html",
      "source": "security@ubuntu.com",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2015/dsa-3400",
      "source": "security@ubuntu.com",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/09/29/4",
      "source": "security@ubuntu.com",
      "tags": []
    },
    {
      "url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinoct2015-2719645.html",
      "source": "security@ubuntu.com",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/76894",
      "source": "security@ubuntu.com",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2753-1",
      "source": "security@ubuntu.com",
      "tags": []
    },
    {
      "url": "https://bugs.launchpad.net/ubuntu/+source/lxc/+bug/1476662",
      "source": "security@ubuntu.com",
      "tags": []
    },
    {
      "url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
      "source": "security@ubuntu.com",
      "tags": []
    },
    {
      "url": "https://lists.linuxcontainers.org/pipermail/lxc-devel/2015-September/012434.html",
      "source": "security@ubuntu.com",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-November/170045.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-November/171358.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-November/171364.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2019-05/msg00073.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2015-10/msg00023.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2015/dsa-3400",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/09/29/4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinoct2015-2719645.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/76894",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2753-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugs.launchpad.net/ubuntu/+source/lxc/+bug/1476662",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.linuxcontainers.org/pipermail/lxc-devel/2015-September/012434.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:37.901528",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "lxc",
    "owner": "lxc",
    "created_at": "2012-09-07T18:50:27Z",
    "updated_at": "2025-01-14T11:54:42Z",
    "pushed_at": "2025-01-09T23:24:26Z",
    "size": 35605,
    "stars": 4741,
    "forks": 1125,
    "open_issues": 176,
    "watchers": 4741,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "stable-0.7.4",
      "stable-1.0",
      "stable-1.1"
    ],
    "languages": {
      "C": 2574680,
      "Shell": 196933,
      "Meson": 74020,
      "Python": 5129,
      "Makefile": 300,
      "SmPL": 251
    },
    "commit_activity": {
      "total_commits_last_year": 159,
      "avg_commits_per_week": 3.0576923076923075,
      "days_active_last_year": 61
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:06:03.413007"
  }
}