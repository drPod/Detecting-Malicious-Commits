{
  "cve_id": "CVE-2015-2312",
  "github_data": {
    "repository": "capnproto/capnproto",
    "fix_commit": "104870608fde3c698483fdef6b97f093fc15685d",
    "related_commits": [
      "104870608fde3c698483fdef6b97f093fc15685d",
      "104870608fde3c698483fdef6b97f093fc15685d"
    ],
    "patch_url": "https://github.com/capnproto/capnproto/commit/104870608fde3c698483fdef6b97f093fc15685d.patch",
    "fix_commit_details": {
      "sha": "104870608fde3c698483fdef6b97f093fc15685d",
      "commit_date": "2015-02-28T04:23:13Z",
      "author": {
        "login": "kentonv",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "SECURITY: CPU usage amplification attack.",
        "length": 163,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 90,
        "additions": 87,
        "deletions": 3
      },
      "files": [
        {
          "filename": "CONTRIBUTORS",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -10,6 +10,7 @@ Scott Purdy <scott@fer.io>: kj/std iostream interface\n Bryan Borham <bjboreham@gmail.com>: Initial MSVC support\n Philip Quinn <p@partylemon.com>: cmake build and other assorted bits\n Brian Taylor <el.wubo@gmail.com>: emacs syntax highlighting\n+Ben Laurie <ben@links.org>: discovered and responsibly disclosed security bugs\n \n This file does not list people who maintain their own Cap'n Proto\n implementations as separate projects.  Those people are awesome too!  :)"
        },
        {
          "filename": "c++/src/capnp/arena.h",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -117,6 +117,13 @@ class SegmentReader {\n \n   KJ_ALWAYS_INLINE(bool containsInterval(const void* from, const void* to));\n \n+  KJ_ALWAYS_INLINE(bool amplifiedRead(WordCount virtualAmount));\n+  // Indicates that the reader should pretend that `virtualAmount` additional data was read even\n+  // though no actual pointer was traversed. This is used e.g. when reading a struct list pointer\n+  // where the element sizes are zero -- the sender could set the list size arbitrarily high and\n+  // cause the receiver to iterate over this list even though the message itself is small, so we\n+  // need to defend agaisnt DoS attacks based on this.\n+\n   inline Arena* getArena();\n   inline SegmentId getSegmentId();\n \n@@ -367,6 +374,10 @@ inline bool SegmentReader::containsInterval(const void* from, const void* to) {\n           arena);\n }\n \n+inline bool SegmentReader::amplifiedRead(WordCount virtualAmount) {\n+  return readLimiter->canRead(virtualAmount, arena);\n+}\n+\n inline Arena* SegmentReader::getArena() { return arena; }\n inline SegmentId SegmentReader::getSegmentId() { return id; }\n inline const word* SegmentReader::getStartPtr() { return ptr.begin(); }"
        },
        {
          "filename": "c++/src/capnp/encoding-test.c++",
          "status": "modified",
          "additions": 30,
          "deletions": 0,
          "patch": "@@ -1410,6 +1410,36 @@ TEST(Encoding, Has) {\n   EXPECT_TRUE(root.asReader().hasInt32List());\n }\n \n+TEST(Encoding, VoidListAmplification) {\n+  MallocMessageBuilder builder;\n+  builder.initRoot<test::TestAnyPointer>().getAnyPointerField().initAs<List<Void>>(1u << 28);\n+\n+  auto segments = builder.getSegmentsForOutput();\n+  EXPECT_EQ(1, segments.size());\n+  EXPECT_LT(segments[0].size(), 16);  // quite small for such a big list!\n+\n+  SegmentArrayMessageReader reader(builder.getSegmentsForOutput());\n+  auto root = reader.getRoot<test::TestAnyPointer>().getAnyPointerField();\n+  EXPECT_NONFATAL_FAILURE(root.getAs<List<TestAllTypes>>());\n+\n+  MallocMessageBuilder copy;\n+  EXPECT_NONFATAL_FAILURE(copy.setRoot(reader.getRoot<AnyPointer>()));\n+}\n+\n+TEST(Encoding, EmptyStructListAmplification) {\n+  MallocMessageBuilder builder;\n+  builder.initRoot<test::TestAnyPointer>().getAnyPointerField()\n+      .initAs<List<test::TestEmptyStruct>>(1u << 28);\n+\n+  auto segments = builder.getSegmentsForOutput();\n+  EXPECT_EQ(1, segments.size());\n+  EXPECT_LT(segments[0].size(), 16);  // quite small for such a big list!\n+\n+  SegmentArrayMessageReader reader(builder.getSegmentsForOutput());\n+  auto root = reader.getRoot<test::TestAnyPointer>().getAnyPointerField();\n+  EXPECT_NONFATAL_FAILURE(root.getAs<List<TestAllTypes>>());\n+}\n+\n TEST(Encoding, Constants) {\n   EXPECT_EQ(VOID, test::TestConstants::VOID_CONST);\n   EXPECT_EQ(true, test::TestConstants::BOOL_CONST);"
        },
        {
          "filename": "c++/src/capnp/layout.c++",
          "status": "modified",
          "additions": 45,
          "deletions": 3,
          "patch": "@@ -308,6 +308,11 @@ struct WireHelpers {\n     return segment == nullptr || segment->containsInterval(start, end);\n   }\n \n+  static KJ_ALWAYS_INLINE(bool amplifiedRead(SegmentReader* segment, WordCount virtualAmount)) {\n+    // If segment is null, this is an unchecked message, so we don't do read limiter checks.\n+    return segment == nullptr || segment->amplifiedRead(virtualAmount);\n+  }\n+\n   static KJ_ALWAYS_INLINE(word* allocate(\n       WirePointer*& ref, SegmentBuilder*& segment, WordCount amount,\n       WirePointer::Kind kind, BuilderArena* orphanArena)) {\n@@ -1675,6 +1680,15 @@ struct WireHelpers {\n             goto useDefault;\n           }\n \n+          if (wordsPerElement * (1 * ELEMENTS) == 0 * WORDS) {\n+            // Watch out for lists of zero-sized structs, which can claim to be arbitrarily large\n+            // without having sent actual data.\n+            KJ_REQUIRE(amplifiedRead(srcSegment, elementCount * (1 * WORDS / ELEMENTS)),\n+                       \"Message contains amplified list pointer.\") {\n+              goto useDefault;\n+            }\n+          }\n+\n           return setListPointer(dstSegment, dst,\n               ListReader(srcSegment, ptr, elementCount, wordsPerElement * BITS_PER_WORD,\n                          tag->structRef.dataSize.get() * BITS_PER_WORD,\n@@ -1693,6 +1707,15 @@ struct WireHelpers {\n             goto useDefault;\n           }\n \n+          if (elementSize == ElementSize::VOID) {\n+            // Watch out for lists of void, which can claim to be arbitrarily large without having\n+            // sent actual data.\n+            KJ_REQUIRE(amplifiedRead(srcSegment, elementCount * (1 * WORDS / ELEMENTS)),\n+                       \"Message contains amplified list pointer.\") {\n+              goto useDefault;\n+            }\n+          }\n+\n           return setListPointer(dstSegment, dst,\n               ListReader(srcSegment, ptr, elementCount, step, dataSize, pointerCount, elementSize,\n                          nestingLimit - 1),\n@@ -1931,6 +1954,15 @@ struct WireHelpers {\n         goto useDefault;\n       }\n \n+      if (wordsPerElement * (1 * ELEMENTS) == 0 * WORDS) {\n+        // Watch out for lists of zero-sized structs, which can claim to be arbitrarily large\n+        // without having sent actual data.\n+        KJ_REQUIRE(amplifiedRead(segment, size * (1 * WORDS / ELEMENTS)),\n+                   \"Message contains amplified list pointer.\") {\n+          goto useDefault;\n+        }\n+      }\n+\n       if (checkElementSize) {\n         // If a struct list was not expected, then presumably a non-struct list was upgraded to a\n         // struct list.  We need to manipulate the pointer to point at the first field of the\n@@ -1988,14 +2020,24 @@ struct WireHelpers {\n       BitCount dataSize = dataBitsPerElement(ref->listRef.elementSize()) * ELEMENTS;\n       WirePointerCount pointerCount =\n           pointersPerElement(ref->listRef.elementSize()) * ELEMENTS;\n+      ElementCount elementCount = ref->listRef.elementCount();\n       auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;\n \n-      KJ_REQUIRE(boundsCheck(segment, ptr, ptr +\n-                     roundBitsUpToWords(ElementCount64(ref->listRef.elementCount()) * step)),\n+      WordCount wordCount = roundBitsUpToWords(ElementCount64(elementCount) * step);\n+      KJ_REQUIRE(boundsCheck(segment, ptr, ptr + wordCount),\n                  \"Message contains out-of-bounds list pointer.\") {\n         goto useDefault;\n       }\n \n+      if (elementSize == ElementSize::VOID) {\n+        // Watch out for lists of void, which can claim to be arbitrarily large without having sent\n+        // actual data.\n+        KJ_REQUIRE(amplifiedRead(segment, elementCount * (1 * WORDS / ELEMENTS)),\n+                   \"Message contains amplified list pointer.\") {\n+          goto useDefault;\n+        }\n+      }\n+\n       if (checkElementSize) {\n         if (elementSize == ElementSize::BIT && expectedElementSize != ElementSize::BIT) {\n           KJ_FAIL_REQUIRE(\n@@ -2025,7 +2067,7 @@ struct WireHelpers {\n         }\n       }\n \n-      return ListReader(segment, ptr, ref->listRef.elementCount(), step,\n+      return ListReader(segment, ptr, elementCount, step,\n                         dataSize, pointerCount, elementSize, nestingLimit - 1);\n     }\n   }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "f600d249496c55289fa07fd6a21cadeeb340edb9",
            "date": "2024-12-28T00:22:29Z",
            "author_login": "fhanau"
          },
          {
            "sha": "4c2071bf467cb81622c1d86e083e957027dee5bd",
            "date": "2024-12-27T17:07:32Z",
            "author_login": "kentonv"
          },
          {
            "sha": "1c676b2df7f97220607591a38c28ce7e4a968ad4",
            "date": "2024-12-24T17:12:47Z",
            "author_login": "kentonv"
          },
          {
            "sha": "d18ee6f53dfdb3244a5af7bd270b28246ede380a",
            "date": "2024-12-24T16:57:44Z",
            "author_login": "kentonv"
          },
          {
            "sha": "dd0d2ed0fae0e3556523205f07d14fabd024c516",
            "date": "2024-12-24T16:55:13Z",
            "author_login": "kentonv"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-400",
    "description": "Sandstorm Cap'n Proto before 0.4.1.1 and 0.5.x before 0.5.1.1 allows remote peers to cause a denial of service (CPU and possibly general resource consumption) via a list with a large number of elements.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-08-09T18:29:01.073",
    "last_modified": "2024-11-21T02:27:11.513",
    "fix_date": "2015-02-28T04:23:13Z"
  },
  "references": [
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/03/17/3",
      "source": "security@debian.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=780567",
      "source": "security@debian.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/capnproto/capnproto/blob/master/security-advisories/2015-03-02-2-all-cpu-amplification.md",
      "source": "security@debian.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/capnproto/capnproto/commit/104870608fde3c698483fdef6b97f093fc15685d",
      "source": "security@debian.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/03/17/3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=780567",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/capnproto/capnproto/blob/master/security-advisories/2015-03-02-2-all-cpu-amplification.md",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/capnproto/capnproto/commit/104870608fde3c698483fdef6b97f093fc15685d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:05.101634",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "capnproto",
    "owner": "capnproto",
    "created_at": "2013-03-29T02:38:48Z",
    "updated_at": "2025-01-14T11:35:17Z",
    "pushed_at": "2025-01-09T11:43:20Z",
    "size": 22925,
    "stars": 11858,
    "forks": 933,
    "open_issues": 251,
    "watchers": 11858,
    "has_security_policy": false,
    "default_branch": "v2",
    "protected_branches": [],
    "languages": {
      "C++": 7786711,
      "Cap'n Proto": 215131,
      "Shell": 60601,
      "CMake": 52207,
      "Starlark": 32975,
      "Makefile": 31296,
      "M4": 30787,
      "Python": 3926,
      "Emacs Lisp": 2197,
      "C": 1631
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:18:38.447836"
  }
}