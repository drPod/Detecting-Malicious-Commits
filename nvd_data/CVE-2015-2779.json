{
  "cve_id": "CVE-2015-2779",
  "github_data": {
    "repository": "quassel/quassel",
    "fix_commit": "b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8",
    "related_commits": [
      "b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8",
      "b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8"
    ],
    "patch_url": "https://github.com/quassel/quassel/commit/b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8.patch",
    "fix_commit_details": {
      "sha": "b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8",
      "commit_date": "2015-02-21T12:33:57Z",
      "author": {
        "login": "mamarley",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Improve the message-splitting algorithm for PRIVMSG and CTCP",
        "length": 1261,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 195,
        "additions": 124,
        "deletions": 71
      },
      "files": [
        {
          "filename": "src/core/corebasichandler.cpp",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -33,6 +33,9 @@ CoreBasicHandler::CoreBasicHandler(CoreNetwork *parent)\n     connect(this, SIGNAL(putCmd(QString, const QList<QByteArray> &, const QByteArray &)),\n         network(), SLOT(putCmd(QString, const QList<QByteArray> &, const QByteArray &)));\n \n+    connect(this, SIGNAL(putCmd(QString, const QList<QList<QByteArray>> &, const QByteArray &)),\n+        network(), SLOT(putCmd(QString, const QList<QList<QByteArray>> &, const QByteArray &)));\n+\n     connect(this, SIGNAL(putRawLine(const QByteArray &)),\n         network(), SLOT(putRawLine(const QByteArray &)));\n }"
        },
        {
          "filename": "src/core/corebasichandler.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -55,6 +55,7 @@ class CoreBasicHandler : public BasicHandler\n signals:\n     void displayMsg(Message::Type, BufferInfo::Type, const QString &target, const QString &text, const QString &sender = \"\", Message::Flags flags = Message::None);\n     void putCmd(const QString &cmd, const QList<QByteArray> &params, const QByteArray &prefix = QByteArray());\n+    void putCmd(const QString &cmd, const QList<QList<QByteArray>> &params, const QByteArray &prefix = QByteArray());\n     void putRawLine(const QByteArray &msg);\n \n protected:"
        },
        {
          "filename": "src/core/corenetwork.cpp",
          "status": "modified",
          "additions": 86,
          "deletions": 0,
          "patch": "@@ -284,6 +284,16 @@ void CoreNetwork::putCmd(const QString &cmd, const QList<QByteArray> &params, co\n }\n \n \n+void CoreNetwork::putCmd(const QString &cmd, const QList<QList<QByteArray>> &params, const QByteArray &prefix)\n+{\n+    QListIterator<QList<QByteArray>> i(params);\n+    while (i.hasNext()) {\n+        QList<QByteArray> msg = i.next();\n+        putCmd(cmd, msg, prefix);\n+    }\n+}\n+\n+\n void CoreNetwork::setChannelJoined(const QString &channel)\n {\n     _autoWhoQueue.prepend(channel.toLower()); // prepend so this new chan is the first to be checked\n@@ -980,3 +990,79 @@ void CoreNetwork::requestSetNetworkInfo(const NetworkInfo &info)\n         }\n     }\n }\n+\n+\n+QList<QList<QByteArray>> CoreNetwork::splitMessage(const QString &cmd, const QString &message, std::function<QList<QByteArray>(QString &)> cmdGenerator)\n+{\n+    QString wrkMsg(message);\n+    QList<QList<QByteArray>> msgsToSend;\n+\n+    // do while (wrkMsg.size() > 0)\n+    do {\n+        // First, check to see if the whole message can be sent at once.  The\n+        // cmdGenerator function is passed in by the caller and is used to encode\n+        // and encrypt (if applicable) the message, since different callers might\n+        // want to use different encoding or encode different values.\n+        int splitPos = wrkMsg.size();\n+        QList<QByteArray> initialSplitMsgEnc = cmdGenerator(wrkMsg);\n+        int initialOverrun = userInputHandler()->lastParamOverrun(cmd, initialSplitMsgEnc);\n+\n+        if (initialOverrun) {\n+            // If the message was too long to be sent, first try splitting it along\n+            // word boundaries with QTextBoundaryFinder.\n+            QString splitMsg(wrkMsg);\n+            QTextBoundaryFinder qtbf(QTextBoundaryFinder::Word, splitMsg);\n+            qtbf.setPosition(initialSplitMsgEnc[1].size() - initialOverrun);\n+            QList<QByteArray> splitMsgEnc;\n+            int overrun = initialOverrun;\n+\n+            while (overrun) {\n+                splitPos = qtbf.toPreviousBoundary();\n+\n+                // splitPos==-1 means the QTBF couldn't find a split point at all and\n+                // splitPos==0 means the QTBF could only find a boundary at the beginning of\n+                // the string.  Neither one of these works for us.\n+                if (splitPos > 0) {\n+                    // If a split point could be found, split the message there, calculate the\n+                    // overrun, and continue with the loop.\n+                    splitMsg = splitMsg.left(splitPos);\n+                    splitMsgEnc = cmdGenerator(splitMsg);\n+                    overrun = userInputHandler()->lastParamOverrun(cmd, splitMsgEnc);\n+                }\n+                else {\n+                    // If a split point could not be found (the beginning of the message\n+                    // is reached without finding a split point short enough to send) and we\n+                    // are still in Word mode, switch to Grapheme mode.  We also need to restore\n+                    // the full wrkMsg to splitMsg, since splitMsg may have been cut down during\n+                    // the previous attempt to find a split point.\n+                    if (qtbf.type() == QTextBoundaryFinder::Word) {\n+                        splitMsg = wrkMsg;\n+                        splitPos = splitMsg.size();\n+                        QTextBoundaryFinder graphemeQtbf(QTextBoundaryFinder::Grapheme, splitMsg);\n+                        graphemeQtbf.setPosition(initialSplitMsgEnc[1].size() - initialOverrun);\n+                        qtbf = graphemeQtbf;\n+                    }\n+                    else {\n+                        // If the QTBF fails to find a split point in Grapheme mode, we give up.\n+                        // This should never happen, but it should be handled anyway.\n+                        qWarning() << \"Unexpected failure to split message!\";\n+                        return msgsToSend;\n+                    }\n+                }\n+            }\n+\n+            // Once a message of sendable length has been found, remove it from the wrkMsg and\n+            // add it to the list of messages to be sent.\n+            wrkMsg.remove(0, splitPos);\n+            msgsToSend.append(splitMsgEnc);\n+        }\n+        else{\n+            // If the entire remaining message is short enough to be sent all at once, remove\n+            // it from the wrkMsg and add it to the list of messages to be sent.\n+            wrkMsg.remove(0, splitPos);\n+            msgsToSend.append(initialSplitMsgEnc);\n+        }\n+    } while (wrkMsg.size() > 0);\n+\n+    return msgsToSend;\n+}"
        },
        {
          "filename": "src/core/corenetwork.h",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -40,6 +40,8 @@\n \n #include \"coresession.h\"\n \n+#include <functional>\n+\n class CoreIdentity;\n class CoreUserInputHandler;\n class CoreIgnoreListManager;\n@@ -93,6 +95,8 @@ class CoreNetwork : public Network\n     inline quint16 localPort() const { return socket.localPort(); }\n     inline quint16 peerPort() const { return socket.peerPort(); }\n \n+    QList<QList<QByteArray>> splitMessage(const QString &cmd, const QString &message, std::function<QList<QByteArray>(QString &)> cmdGenerator);\n+\n public slots:\n     virtual void setMyNick(const QString &mynick);\n \n@@ -112,6 +116,7 @@ public slots:\n     void userInput(BufferInfo bufferInfo, QString msg);\n     void putRawLine(QByteArray input);\n     void putCmd(const QString &cmd, const QList<QByteArray> &params, const QByteArray &prefix = QByteArray());\n+    void putCmd(const QString &cmd, const QList<QList<QByteArray>> &params, const QByteArray &prefix = QByteArray());\n \n     void setChannelJoined(const QString &channel);\n     void setChannelParted(const QString &channel);"
        },
        {
          "filename": "src/core/coreuserinputhandler.cpp",
          "status": "modified",
          "additions": 23,
          "deletions": 49,
          "patch": "@@ -473,12 +473,16 @@ void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString\n         return;\n \n     QString target = msg.section(' ', 0, 0);\n-    QByteArray encMsg = userEncode(target, msg.section(' ', 1));\n+    QString msgSection = msg.section(' ', 1);\n+\n+    std::function<QByteArray(const QString &, const QString &)> encodeFunc = [this] (const QString &target, const QString &message) -> QByteArray {\n+        return userEncode(target, message);\n+    };\n \n #ifdef HAVE_QCA2\n-    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));\n+    putPrivmsg(target, msgSection, encodeFunc, network()->cipher(target));\n #else\n-    putPrivmsg(serverEncode(target), encMsg);\n+    putPrivmsg(target, msgSection, encodeFunc);\n #endif\n }\n \n@@ -594,11 +598,14 @@ void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString\n     if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n         return;  // server buffer\n \n-    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);\n+    std::function<QByteArray(const QString &, const QString &)> encodeFunc = [this] (const QString &target, const QString &message) -> QByteArray {\n+        return channelEncode(target, message);\n+    };\n+\n #ifdef HAVE_QCA2\n-    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));\n+    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc, network()->cipher(bufferInfo.bufferName()));\n #else\n-    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);\n+    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc);\n #endif\n     emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n }\n@@ -763,56 +770,23 @@ void CoreUserInputHandler::defaultHandler(QString cmd, const BufferInfo &bufferI\n }\n \n \n-void CoreUserInputHandler::putPrivmsg(const QByteArray &target, const QByteArray &message, Cipher *cipher)\n+void CoreUserInputHandler::putPrivmsg(const QString &target, const QString &message, std::function<QByteArray(const QString &, const QString &)> encodeFunc, Cipher *cipher)\n {\n-    // Encrypted messages need special care. There's no clear relation between cleartext and encrypted message length,\n-    // so we can't just compute the maxSplitPos. Instead, we need to loop through the splitpoints until the crypted\n-    // version is short enough...\n-    // TODO: check out how the various possible encryption methods behave length-wise and make\n-    //       this clean by predicting the length of the crypted msg.\n-    //       For example, blowfish-ebc seems to create 8-char chunks.\n+    QString cmd(\"PRIVMSG\");\n+    QByteArray targetEnc = serverEncode(target);\n \n-    static const char *cmd = \"PRIVMSG\";\n-    static const char *splitter = \" .,-!?\";\n+    std::function<QList<QByteArray>(QString &)> cmdGenerator = [&] (QString &splitMsg) -> QList<QByteArray> {\n+        QByteArray splitMsgEnc = encodeFunc(target, splitMsg);\n \n-    int maxSplitPos = message.count();\n-    int splitPos = maxSplitPos;\n-    forever {\n-        QByteArray crypted = message.left(splitPos);\n-        bool isEncrypted = false;\n #ifdef HAVE_QCA2\n-        if (cipher && !cipher->key().isEmpty() && !message.isEmpty()) {\n-            isEncrypted = cipher->encrypt(crypted);\n+        if (cipher && !cipher->key().isEmpty() && !splitMsg.isEmpty()) {\n+            cipher->encrypt(splitMsgEnc);\n         }\n #endif\n-        int overrun = lastParamOverrun(cmd, QList<QByteArray>() << target << crypted);\n-        if (overrun) {\n-            // In case this is not an encrypted msg, we can just cut off at the end\n-            if (!isEncrypted)\n-                maxSplitPos = message.count() - overrun;\n-\n-            splitPos = -1;\n-            for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n-                splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); // keep split char on old line\n-            }\n-            if (splitPos <= 0 || splitPos > maxSplitPos)\n-                splitPos = maxSplitPos;\n-\n-            maxSplitPos = splitPos - 1;\n-            if (maxSplitPos <= 0) { // this should never happen, but who knows...\n-                qWarning() << tr(\"[Error] Could not encrypt your message: %1\").arg(message.data());\n-                return;\n-            }\n-            continue; // we never come back here for !encrypted!\n-        }\n-\n-        // now we have found a valid splitpos (or didn't need to split to begin with)\n-        putCmd(cmd, QList<QByteArray>() << target << crypted);\n-        if (splitPos < message.count())\n-            putPrivmsg(target, message.mid(splitPos), cipher);\n+        return QList<QByteArray>() << targetEnc << splitMsgEnc;\n+    };\n \n-        return;\n-    }\n+    putCmd(cmd, network()->splitMessage(cmd, message, cmdGenerator));\n }\n \n "
        },
        {
          "filename": "src/core/coreuserinputhandler.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -88,7 +88,7 @@ public slots:\n private:\n     void doMode(const BufferInfo& bufferInfo, const QChar &addOrRemove, const QChar &mode, const QString &nickList);\n     void banOrUnban(const BufferInfo &bufferInfo, const QString &text, bool ban);\n-    void putPrivmsg(const QByteArray &target, const QByteArray &message, Cipher *cipher = 0);\n+    void putPrivmsg(const QString &target, const QString &message, std::function<QByteArray(const QString &, const QString &)> encodeFunc, Cipher *cipher = 0);\n \n #ifdef HAVE_QCA2\n     QByteArray encrypt(const QString &target, const QByteArray &message, bool *didEncrypt = 0) const;"
        },
        {
          "filename": "src/core/ctcpparser.cpp",
          "status": "modified",
          "additions": 5,
          "deletions": 21,
          "patch": "@@ -312,29 +312,13 @@ QByteArray CtcpParser::pack(const QByteArray &ctcpTag, const QByteArray &message\n \n void CtcpParser::query(CoreNetwork *net, const QString &bufname, const QString &ctcpTag, const QString &message)\n {\n-    QList<QByteArray> params;\n-    params << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message)));\n-\n-    static const char *splitter = \" .,-!?\";\n-    int maxSplitPos = message.count();\n-    int splitPos = maxSplitPos;\n+    QString cmd(\"PRIVMSG\");\n \n-    int overrun = net->userInputHandler()->lastParamOverrun(\"PRIVMSG\", params);\n-    if (overrun) {\n-        maxSplitPos = message.count() - overrun -2;\n-        splitPos = -1;\n-        for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n-            splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); // keep split char on old line\n-        }\n-        if (splitPos <= 0 || splitPos > maxSplitPos)\n-            splitPos = maxSplitPos;\n-\n-        params = params.mid(0, 1) <<  lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message.left(splitPos))));\n-    }\n-    net->putCmd(\"PRIVMSG\", params);\n+    std::function<QList<QByteArray>(QString &)> cmdGenerator = [&] (QString &splitMsg) -> QList<QByteArray> {\n+        return QList<QByteArray>() << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, splitMsg)));\n+    };\n \n-    if (splitPos < message.count())\n-        query(net, bufname, ctcpTag, message.mid(splitPos));\n+    net->putCmd(cmd, net->splitMessage(cmd, message, cmdGenerator));\n }\n \n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "6e030aef07db55a327420d7931c162a82e0eba83",
            "date": "2024-09-18T12:34:35Z",
            "author_login": "wylfen"
          },
          {
            "sha": "0cca5e41a05923579e9b7cab46c0daaeeed4ef4b",
            "date": "2024-09-18T11:37:36Z",
            "author_login": "wylfen"
          },
          {
            "sha": "2977a2e57b3f639d93722e251a5f32c19afba31f",
            "date": "2024-04-28T14:00:33Z",
            "author_login": "Sput42"
          },
          {
            "sha": "64faafba5401777e0aff165c405ca185065c22de",
            "date": "2024-04-28T13:57:16Z",
            "author_login": "Sput42"
          },
          {
            "sha": "f6e14c36ccb03af949c2fb52680be45a9c4249b9",
            "date": "2024-04-28T13:55:45Z",
            "author_login": "Sput42"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-399",
    "description": "Stack consumption vulnerability in the message splitting functionality in Quassel before 0.12-rc1 allows remote attackers to cause a denial of service (uncontrolled recursion) via a crafted massage.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2015-04-10T15:00:05.147",
    "last_modified": "2024-11-21T02:28:03.340",
    "fix_date": "2015-02-21T12:33:57Z"
  },
  "references": [
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-August/163054.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-May/158666.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2015-04/msg00018.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/03/20/12",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/03/27/11",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/03/28/3",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/74048",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/quassel/quassel/commit/b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-August/163054.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-May/158666.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2015-04/msg00018.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/03/20/12",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/03/27/11",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/03/28/3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/74048",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/quassel/quassel/commit/b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:32.433144",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "quassel",
    "owner": "quassel",
    "created_at": "2012-12-04T21:43:06Z",
    "updated_at": "2025-01-13T13:10:10Z",
    "pushed_at": "2024-09-30T20:37:48Z",
    "size": 34956,
    "stars": 730,
    "forks": 222,
    "open_issues": 32,
    "watchers": 730,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "C++": 3883845,
      "Perl": 597856,
      "CMake": 87745,
      "C": 5127,
      "Objective-C++": 4195,
      "Shell": 3279,
      "PLpgSQL": 1393
    },
    "commit_activity": {
      "total_commits_last_year": 5,
      "avg_commits_per_week": 0.09615384615384616,
      "days_active_last_year": 2
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T12:54:36.846927"
  }
}