{
  "cve_id": "CVE-2015-3905",
  "github_data": {
    "repository": "kohler/t1utils",
    "fix_commit": "6b9d1aafcb61a3663c883663eb19ccdbfcde8d33",
    "related_commits": [
      "6b9d1aafcb61a3663c883663eb19ccdbfcde8d33",
      "6b9d1aafcb61a3663c883663eb19ccdbfcde8d33"
    ],
    "patch_url": "https://github.com/kohler/t1utils/commit/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33.patch",
    "fix_commit_details": {
      "sha": "6b9d1aafcb61a3663c883663eb19ccdbfcde8d33",
      "commit_date": "2015-02-26T20:34:00Z",
      "author": {
        "login": "kohler",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Security fixes.",
        "length": 231,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 156,
        "additions": 77,
        "deletions": 79
      },
      "files": [
        {
          "filename": "Makefile.am",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -9,9 +9,9 @@ t1ascii_SOURCES = include/lcdf/clp.h include/lcdf/inttypes.h \\\n t1binary_SOURCES = include/lcdf/clp.h include/lcdf/inttypes.h \\\n \tclp.c t1lib.h t1lib.c t1binary.c\n t1asm_SOURCES = include/lcdf/clp.h include/lcdf/inttypes.h \\\n-\tclp.c t1lib.h t1lib.c t1asm.c\n+\tclp.c t1lib.h t1asmhelp.h t1lib.c t1asm.c\n t1disasm_SOURCES = include/lcdf/clp.h include/lcdf/inttypes.h \\\n-\tclp.c t1lib.h t1lib.c t1disasm.c\n+\tclp.c t1lib.h t1asmhelp.h t1lib.c t1disasm.c\n t1unmac_SOURCES = include/lcdf/clp.h include/lcdf/inttypes.h \\\n \tclp.c t1lib.h t1lib.c t1unmac.c\n t1mac_SOURCES = include/lcdf/clp.h include/lcdf/inttypes.h \\"
        },
        {
          "filename": "t1asm.c",
          "status": "modified",
          "additions": 13,
          "deletions": 27,
          "patch": "@@ -66,6 +66,7 @@\n #include <errno.h>\n #include <lcdf/clp.h>\n #include \"t1lib.h\"\n+#include \"t1asmhelp.h\"\n \n #define LINESIZE 512\n \n@@ -90,10 +91,6 @@ static int in_eexec = 0;\n /* need to add 1 as space for \\0 */\n static char line[LINESIZE + 1];\n \n-/* lenIV and charstring start command */\n-static int lenIV = 4;\n-static char cs_start[10];\n-\n /* for charstring buffering */\n static byte *charstring_buf, *charstring_bp;\n static int charstring_bufsiz;\n@@ -273,7 +270,7 @@ static void eexec_start(char *string)\n static int check_line_charstring(void)\n {\n   char *p = line;\n-  while (isspace(*p))\n+  while (isspace((unsigned char) *p))\n     p++;\n   return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));\n }\n@@ -359,8 +356,8 @@ static int CDECL command_compare(const void *key, const void *item)\n \n static int is_integer(char *string)\n {\n-  if (isdigit(string[0]) || string[0] == '-' || string[0] == '+') {\n-    while (*++string && isdigit(*string))\n+  if (isdigit((unsigned char) string[0]) || string[0] == '-' || string[0] == '+') {\n+    while (*++string && isdigit((unsigned char) *string))\n       ;                                           /* deliberately empty */\n     if (!*string)\n       return 1;\n@@ -626,7 +623,7 @@ Report bugs to <ekohler@gmail.com>.\\n\", program_name);\n \n int main(int argc, char *argv[])\n {\n-  char *p, *q, *r;\n+  char *p, *q;\n \n   Clp_Parser *clp =\n     Clp_NewParser(argc, (const char * const *)argv, sizeof(options) / sizeof(options[0]), options);\n@@ -740,36 +737,25 @@ particular purpose.\\n\");\n     t1utils_getline();\n \n     if (!ever_active) {\n-      if (strncmp(line, \"currentfile eexec\", 17) == 0 && isspace(line[17])) {\n+      if (strncmp(line, \"currentfile eexec\", 17) == 0 && isspace((unsigned char) line[17])) {\n \t/* Allow arbitrary whitespace after \"currentfile eexec\".\n \t   Thanks to Tom Kacvinsky <tjk@ams.org> for reporting this.\n \t   Note: strlen(\"currentfile eexec\") == 17. */\n-\tfor (p = line + 18; isspace(*p); p++)\n+\tfor (p = line + 18; isspace((unsigned char) *p); p++)\n \t  ;\n \teexec_start(p);\n \tcontinue;\n       } else if (strncmp(line, \"/lenIV\", 6) == 0) {\n-\tlenIV = atoi(line + 6);\n-      } else if ((p = strstr(line, \"string currentfile\"))\n-\t\t && strstr(line, \"readstring\")) { /* enforce `readstring' */\n-\t/* locate the name of the charstring start command */\n-\t*p = '\\0';                                  /* damage line[] */\n-\tq = strrchr(line, '/');\n-\tif (q) {\n-\t  r = cs_start;\n-\t  ++q;\n-\t  while (!isspace(*q) && *q != '{')\n-\t    *r++ = *q++;\n-\t  *r = '\\0';\n-\t}\n-\t*p = 's';                                   /* repair line[] */\n+        set_lenIV(line);\n+      } else if ((p = strstr(line, \"string currentfile\"))) {\n+        set_cs_start(line);\n       }\n     }\n \n     if (!active) {\n-      if ((p = strstr(line, \"/Subrs\")) && isdigit(p[7]))\n+      if ((p = strstr(line, \"/Subrs\")) && isdigit((unsigned char) p[7]))\n \tever_active = active = 1;\n-      else if ((p = strstr(line, \"/CharStrings\")) && isdigit(p[13]))\n+      else if ((p = strstr(line, \"/CharStrings\")) && isdigit((unsigned char) p[13]))\n \tever_active = active = 1;\n     }\n     if ((p = strstr(line, \"currentfile closefile\"))) {\n@@ -778,7 +764,7 @@ particular purpose.\\n\");\n       /* 1/3/2002 -- happy new year! -- Luc Devroye reports a failure with\n          some printers when `currentfile closefile' is followed by space */\n       p += sizeof(\"currentfile closefile\") - 1;\n-      for (q = p; isspace(*q) && *q != '\\n'; q++)\n+      for (q = p; isspace((unsigned char) *q) && *q != '\\n'; q++)\n \t/* nada */;\n       if (q == p && !*q)\n \terror(\"warning: `currentfile closefile' line too long\");"
        },
        {
          "filename": "t1asmhelp.h",
          "status": "added",
          "additions": 48,
          "deletions": 0,
          "patch": "@@ -0,0 +1,48 @@\n+#ifndef T1ASMHELP_H\n+#define T1ASMHELP_H\n+\n+static int lenIV = 4;\n+\n+/* If the line contains an entry of the form `/lenIV <num>' then set the global\n+   lenIV to <num>.  This indicates the number of random bytes at the beginning\n+   of each charstring. */\n+\n+static void\n+set_lenIV(const char* line)\n+{\n+  char *p = strstr(line, \"/lenIV \");\n+\n+  /* Allow lenIV to be negative. Thanks to Tom Kacvinsky <tjk@ams.org> */\n+  if (p && (isdigit((unsigned char) p[7]) || p[7] == '+' || p[7] == '-')) {\n+    lenIV = atoi(p + 7);\n+  }\n+}\n+\n+\n+static const char* cs_start = \"\";\n+\n+static void\n+set_cs_start(const char* line)\n+{\n+    static int cs_start_set = 0;\n+    char *p, *q, *r;\n+\n+    if ((p = strstr(line, \"string currentfile\"))\n+        && strstr(line, \"readstring\")) {\n+        /* locate the name of the charstring start command */\n+        for (q = p; q != line && q[-1] != '/'; --q)\n+            /* nada */;\n+        if (q != line) {\n+            for (r = q; r != p && !isspace((unsigned char) *r) && *r != '{'; ++r)\n+                /* nada */;\n+            if (cs_start_set)\n+                free((char*) cs_start);\n+            cs_start = p = malloc(r - q + 1);\n+            memcpy(p, q, r - q);\n+            p[r - q] = 0;\n+            cs_start_set = 1;\n+        }\n+    }\n+}\n+\n+#endif"
        },
        {
          "filename": "t1disasm.c",
          "status": "modified",
          "additions": 1,
          "deletions": 40,
          "patch": "@@ -70,6 +70,7 @@\n #include <assert.h>\n #include <lcdf/clp.h>\n #include \"t1lib.h\"\n+#include \"t1asmhelp.h\"\n \n #ifdef __cplusplus\n extern \"C\" {\n@@ -78,8 +79,6 @@ extern \"C\" {\n typedef unsigned char byte;\n \n static FILE *ofp;\n-static int lenIV = 4;\n-static char cs_start[10];\n static int unknown = 0;\n \n /* decryption stuff */\n@@ -90,44 +89,6 @@ static uint16_t er_default = 55665;\n static int error_count = 0;\n \n \n-/* If the line contains an entry of the form `/lenIV <num>' then set the global\n-   lenIV to <num>.  This indicates the number of random bytes at the beginning\n-   of each charstring. */\n-\n-static void\n-set_lenIV(char *line)\n-{\n-  char *p = strstr(line, \"/lenIV \");\n-\n-  /* Allow lenIV to be negative. Thanks to Tom Kacvinsky <tjk@ams.org> */\n-  if (p && (isdigit(p[7]) || p[7] == '+' || p[7] == '-')) {\n-    lenIV = atoi(p + 7);\n-  }\n-}\n-\n-static void\n-set_cs_start(char *line)\n-{\n-  char *p, *q, *r;\n-\n-  if ((p = strstr(line, \"string currentfile\"))) {\n-    /* enforce presence of `readstring' -- 5/29/99 */\n-    if (!strstr(line, \"readstring\"))\n-      return;\n-    /* locate the name of the charstring start command */\n-    *p = '\\0';\t\t\t\t\t  /* damage line[] */\n-    q = strrchr(line, '/');\n-    if (q) {\n-      r = cs_start;\n-      ++q;\n-      while (!isspace(*q) && *q != '{')\n-\t*r++ = *q++;\n-      *r = '\\0';\n-    }\n-    *p = 's';\t\t\t\t\t  /* repair line[] */\n-  }\n-}\n-\n /* Subroutine to output strings. */\n \n static void"
        },
        {
          "filename": "t1lib.c",
          "status": "modified",
          "additions": 8,
          "deletions": 6,
          "patch": "@@ -59,7 +59,7 @@ translate_hex_string(char *s, char *saved_orphan)\n   char *start = s;\n   char *t = s;\n   for (; *s; s++) {\n-    if (isspace(*s))\n+    if (isspace((unsigned char) *s))\n       continue;\n     if (c1) {\n       *t++ = (hexval(c1) << 4) + hexval(*s);\n@@ -136,10 +136,10 @@ process_pfa(FILE *ifp, const char *ifp_filename, struct font_reader *fr)\n \n \t/* now that we have the line, handle it */\n \tif (blocktyp == PFA_ASCII) {\n-\t    if (strncmp(line, \"currentfile eexec\", 17) == 0 && isspace(line[17])) {\n+\t    if (strncmp(line, \"currentfile eexec\", 17) == 0 && isspace((unsigned char) line[17])) {\n \t\tchar saved_p;\n \t\t/* assert(line == buffer); */\n-\t\tfor (line += 18; isspace(*line); line++)\n+\t\tfor (line += 18; isspace((unsigned char) *line); line++)\n \t\t    /* nada */;\n \t\tsaved_p = *line;\n \t\t*line = 0;\n@@ -158,12 +158,14 @@ process_pfa(FILE *ifp, const char *ifp_filename, struct font_reader *fr)\n \tif (blocktyp == PFA_EEXEC_TEST) {\n \t    /* 8.Feb.2004: fix bug if first character in a binary eexec block\n \t       is 0, reported by Werner Lemberg */\n-\t    for (; line < last && isspace(*line); line++)\n+\t    for (; line < last && isspace((unsigned char) *line); line++)\n \t\t/* nada */;\n \t    if (line == last)\n \t\tcontinue;\n-\t    else if (last >= line + 4 && isxdigit(line[0]) && isxdigit(line[1])\n-\t\t     && isxdigit(line[2]) && isxdigit(line[3]))\n+\t    else if (last >= line + 4 && isxdigit((unsigned char) line[0])\n+                     && isxdigit((unsigned char) line[1])\n+\t\t     && isxdigit((unsigned char) line[2])\n+                     && isxdigit((unsigned char) line[3]))\n \t\tblocktyp = PFA_HEX;\n \t    else\n \t\tblocktyp = PFA_BINARY;"
        },
        {
          "filename": "t1mac.c",
          "status": "modified",
          "additions": 5,
          "deletions": 4,
          "patch": "@@ -370,10 +370,11 @@ t1mac_output_ascii(char *s, int len)\n     s[len-1] = '\\r';\n   t1mac_output_data((byte *)s, len);\n   if (strncmp(s, \"/FontName\", 9) == 0) {\n-    for (s += 9; isspace(*s); s++) ;\n+    for (s += 9; isspace((unsigned char) *s); s++)\n+        /* skip */;\n     if (*s == '/') {\n       const char *t = ++s;\n-      while (*t && !isspace(*t)) t++;\n+      while (*t && !isspace((unsigned char) *t)) t++;\n       free(font_name);\n       font_name = (char *)malloc(t - s + 1);\n       memcpy(font_name, s, t - s);\n@@ -994,11 +995,11 @@ particular purpose.\\n\");\n     int part = 0, len = 0;\n     char *x, *s;\n     for (x = s = font_name; *s; s++)\n-      if (isupper(*s) || isdigit(*s)) {\n+      if (isupper((unsigned char) *s) || isdigit((unsigned char) *s)) {\n \t*x++ = *s;\n \tpart++;\n \tlen = 1;\n-      } else if (islower(*s)) {\n+      } else if (islower((unsigned char) *s)) {\n \tif (len < (part <= 1 ? 5 : 3))\n \t  *x++ = *s;\n \tlen++;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "72d6300e81833e391d92db491e3abbb8a3a4dd69",
            "date": "2020-10-27T15:10:06Z",
            "author_login": "kohler"
          },
          {
            "sha": "3f1ddda424353f0f926dd28efa47b0ac61556ce8",
            "date": "2017-08-16T16:37:34Z",
            "author_login": "kohler"
          },
          {
            "sha": "e16fda51c46ee40c0d63af4b18a65e3070a99c87",
            "date": "2017-08-16T16:31:54Z",
            "author_login": "kohler"
          },
          {
            "sha": "010ebd1b57399d966d40ff0fb9e71d0dd9a1607f",
            "date": "2017-08-16T16:29:17Z",
            "author_login": "kohler"
          },
          {
            "sha": "aa1506e0a3bd3f25dcf8eab14159d34851d2d8ed",
            "date": "2017-08-16T16:26:16Z",
            "author_login": "kohler"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-119",
    "description": "Buffer overflow in the set_cs_start function in t1disasm.c in t1utils before 1.39 allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted font file.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2015-06-08T14:59:11.710",
    "last_modified": "2024-11-21T02:30:03.807",
    "fix_date": "2015-02-26T20:34:00Z"
  },
  "references": [
    {
      "url": "http://ubuntu.com/usn/usn-2627-1",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/05/13/9",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/05/22/10",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/74674",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=779274",
      "source": "security@debian.org",
      "tags": [
        "Exploit"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1218365",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "https://github.com/kohler/t1utils/blob/master/NEWS",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "https://github.com/kohler/t1utils/commit/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "https://github.com/kohler/t1utils/issues/4",
      "source": "security@debian.org",
      "tags": [
        "Exploit"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201507-10",
      "source": "security@debian.org",
      "tags": []
    },
    {
      "url": "http://ubuntu.com/usn/usn-2627-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/05/13/9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/05/22/10",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/74674",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=779274",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1218365",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/kohler/t1utils/blob/master/NEWS",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/kohler/t1utils/commit/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/kohler/t1utils/issues/4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201507-10",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:35.780472",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "t1utils",
    "owner": "kohler",
    "created_at": "2013-05-17T16:46:47Z",
    "updated_at": "2024-10-22T06:32:09Z",
    "pushed_at": "2020-10-27T15:10:22Z",
    "size": 294,
    "stars": 48,
    "forks": 17,
    "open_issues": 0,
    "watchers": 48,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 214777,
      "Roff": 11201,
      "M4": 3077,
      "C++": 1595,
      "Makefile": 1077,
      "Shell": 26
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T17:23:09.006533"
  }
}