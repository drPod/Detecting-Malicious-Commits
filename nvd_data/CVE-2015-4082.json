{
  "cve_id": "CVE-2015-4082",
  "github_data": {
    "repository": "jborg/attic",
    "fix_commit": "78f9ad1faba7193ca7f0acccbc13b1ff6ebf9072",
    "related_commits": [
      "78f9ad1faba7193ca7f0acccbc13b1ff6ebf9072",
      "78f9ad1faba7193ca7f0acccbc13b1ff6ebf9072"
    ],
    "patch_url": "https://github.com/jborg/attic/commit/78f9ad1faba7193ca7f0acccbc13b1ff6ebf9072.patch",
    "fix_commit_details": {
      "sha": "78f9ad1faba7193ca7f0acccbc13b1ff6ebf9072",
      "commit_date": "2015-04-06T21:07:10Z",
      "author": {
        "login": "jborg",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Require approval before accessing previously unknown unencrypted repositories",
        "length": 90,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 74,
        "additions": 71,
        "deletions": 3
      },
      "files": [
        {
          "filename": "CHANGES",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -7,6 +7,7 @@ Version 0.15\n ------------\n \n (feature release, released on X)\n+- Require approval before accessing previously unknown unencrypted repositories (#271)\n - Fix issue with hash index files larger than 2GB.\n - Fix Python 3.2 compatibility issue with noatime open() (#164)\n - Include missing pyx files in dist files (#168)"
        },
        {
          "filename": "attic/archiver.py",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -62,6 +62,7 @@ def do_init(self, args):\n         manifest.key = key\n         manifest.write()\n         repository.commit()\n+        Cache(repository, key, manifest, warn_if_unencrypted=False)\n         return self.exit_code\n \n     def do_check(self, args):"
        },
        {
          "filename": "attic/cache.py",
          "status": "modified",
          "additions": 25,
          "deletions": 2,
          "patch": "@@ -2,9 +2,11 @@\n from attic.remote import cache_if_remote\n import msgpack\n import os\n+import sys\n from binascii import hexlify\n import shutil\n \n+from .key import PlaintextKey\n from .helpers import Error, get_cache_dir, decode_dict, st_mtime_ns, unhexlify, UpgradableLock, int_to_bigint, \\\n     bigint_to_int\n from .hashindex import ChunkIndex\n@@ -16,20 +18,38 @@ class Cache(object):\n     class RepositoryReplay(Error):\n         \"\"\"Cache is newer than repository, refusing to continue\"\"\"\n \n-    def __init__(self, repository, key, manifest, path=None, sync=True):\n+    class CacheInitAbortedError(Error):\n+        \"\"\"Cache initialization aborted\"\"\"\n+\n+\n+    class EncryptionMethodMismatch(Error):\n+        \"\"\"Repository encryption method changed since last acccess, refusing to continue\n+        \"\"\"\n+\n+    def __init__(self, repository, key, manifest, path=None, sync=True, warn_if_unencrypted=True):\n+        self.lock = None\n         self.timestamp = None\n         self.txn_active = False\n         self.repository = repository\n         self.key = key\n         self.manifest = manifest\n         self.path = path or os.path.join(get_cache_dir(), hexlify(repository.id).decode('ascii'))\n         if not os.path.exists(self.path):\n+            if warn_if_unencrypted and isinstance(key, PlaintextKey):\n+                if 'ATTIC_UNKNOWN_UNENCRYPTED_REPO_ACCESS_IS_OK' not in os.environ:\n+                    print(\"\"\"Warning: Attempting to access a previously unknown unencrypted repository\\n\"\"\", file=sys.stderr)\n+                    answer = input('Do you want to continue? [yN] ')\n+                    if not (answer and answer in 'Yy'):\n+                        raise self.CacheInitAbortedError()\n             self.create()\n         self.open()\n         if sync and self.manifest.id != self.manifest_id:\n             # If repository is older than the cache something fishy is going on\n             if self.timestamp and self.timestamp > manifest.timestamp:\n                 raise self.RepositoryReplay()\n+            # Make sure an encrypted repository has not been swapped for an unencrypted repository\n+            if self.key_type is not None and self.key_type != str(key.TYPE):\n+                raise self.EncryptionMethodMismatch()\n             self.sync()\n             self.commit()\n \n@@ -65,11 +85,13 @@ def open(self):\n         self.id = self.config.get('cache', 'repository')\n         self.manifest_id = unhexlify(self.config.get('cache', 'manifest'))\n         self.timestamp = self.config.get('cache', 'timestamp', fallback=None)\n+        self.key_type = self.config.get('cache', 'key_type', fallback=None)\n         self.chunks = ChunkIndex.read(os.path.join(self.path, 'chunks').encode('utf-8'))\n         self.files = None\n \n     def close(self):\n-        self.lock.release()\n+        if self.lock:\n+            self.lock.release()\n \n     def _read_files(self):\n         self.files = {}\n@@ -111,6 +133,7 @@ def commit(self):\n                         msgpack.pack((path_hash, item), fd)\n         self.config.set('cache', 'manifest', hexlify(self.manifest.id).decode('ascii'))\n         self.config.set('cache', 'timestamp', self.manifest.timestamp)\n+        self.config.set('cache', 'key_type', str(self.key.TYPE))\n         with open(os.path.join(self.path, 'config'), 'w') as fd:\n             self.config.write(fd)\n         self.chunks.write(os.path.join(self.path, 'chunks').encode('utf-8'))"
        },
        {
          "filename": "attic/testsuite/archiver.py",
          "status": "modified",
          "additions": 44,
          "deletions": 1,
          "patch": "@@ -1,3 +1,5 @@\n+from binascii import hexlify\n+from configparser import RawConfigParser\n import os\n from io import StringIO\n import stat\n@@ -11,6 +13,7 @@\n from attic import xattr\n from attic.archive import Archive, ChunkBuffer\n from attic.archiver import Archiver\n+from attic.cache import Cache\n from attic.crypto import bytes_to_long, num_aes_blocks\n from attic.helpers import Manifest\n from attic.remote import RemoteRepository, PathNotAllowed\n@@ -41,6 +44,22 @@ def __exit__(self, *args, **kw):\n         os.chdir(self.old)\n \n \n+class environment_variable:\n+    def __init__(self, **values):\n+        self.values = values\n+        self.old_values = {}\n+\n+    def __enter__(self):\n+        for k, v in self.values.items():\n+            self.old_values[k] = os.environ.get(k)\n+            os.environ[k] = v\n+\n+    def __exit__(self, *args, **kw):\n+        for k, v in self.old_values.items():\n+            if v is not None:\n+                os.environ[k] = v\n+\n+\n class ArchiverTestCaseBase(AtticTestCase):\n \n     prefix = ''\n@@ -161,11 +180,35 @@ def test_basic_functionality(self):\n         info_output = self.attic('info', self.repository_location + '::test')\n         self.assert_in('Number of files: 4', info_output)\n         shutil.rmtree(self.cache_path)\n-        info_output2 = self.attic('info', self.repository_location + '::test')\n+        with environment_variable(ATTIC_UNKNOWN_UNENCRYPTED_REPO_ACCESS_IS_OK='1'):\n+            info_output2 = self.attic('info', self.repository_location + '::test')\n         # info_output2 starts with some \"initializing cache\" text but should\n         # end the same way as info_output\n         assert info_output2.endswith(info_output)\n \n+    def _extract_repository_id(self, path):\n+        return Repository(self.repository_path).id\n+\n+    def _set_repository_id(self, path, id):\n+        config = RawConfigParser()\n+        config.read(os.path.join(path, 'config'))\n+        config.set('repository', 'id', hexlify(id).decode('ascii'))\n+        with open(os.path.join(path, 'config'), 'w') as fd:\n+            config.write(fd)\n+        return Repository(self.repository_path).id\n+\n+    def test_repository_swap_detection(self):\n+        self.create_test_files()\n+        os.environ['ATTIC_PASSPHRASE'] = 'passphrase'\n+        self.attic('init', '--encryption=passphrase', self.repository_location)\n+        repository_id = self._extract_repository_id(self.repository_path)\n+        self.attic('create', self.repository_location + '::test', 'input')\n+        shutil.rmtree(self.repository_path)\n+        self.attic('init', '--encryption=none', self.repository_location)\n+        self._set_repository_id(self.repository_path, repository_id)\n+        self.assert_equal(repository_id, self._extract_repository_id(self.repository_path))\n+        self.assert_raises(Cache.EncryptionMethodMismatch, lambda :self.attic('create', self.repository_location + '::test.2', 'input'))\n+\n     def test_strip_components(self):\n         self.attic('init', self.repository_location)\n         self.create_regular_file('dir/file')"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2b348104f668836f9e00103681e3bc85cb49ecae",
            "date": "2015-05-24T19:48:03Z",
            "author_login": "jborg"
          },
          {
            "sha": "d7cd3bb8bd0be244454259ba96f64f25a654dade",
            "date": "2015-05-16T20:49:28Z",
            "author_login": "jborg"
          },
          {
            "sha": "7b61f6aff462bee6e84e3d030627711a13eb1b67",
            "date": "2015-05-16T19:35:31Z",
            "author_login": "jborg"
          },
          {
            "sha": "321b4d1afddf2be85efc89c7bbe07ef894a3dd45",
            "date": "2015-05-16T19:22:53Z",
            "author_login": "jborg"
          },
          {
            "sha": "67590aa9215e63d8e1ce860e86699aadab446d6e",
            "date": "2015-05-14T23:34:08Z",
            "author_login": "jdchristensen"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-264",
    "description": "attic before 0.15 does not confirm unencrypted backups with the user, which allows remote attackers with read and write privileges for the encrypted repository to obtain potentially sensitive information by changing the manifest type byte of the repository to \"unencrypted / without key file\".",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-08-18T16:29:00.340",
    "last_modified": "2024-11-21T02:30:25.430",
    "fix_date": "2015-04-06T21:07:10Z"
  },
  "references": [
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/05/31/3",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/74821",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/jborg/attic/commit/78f9ad1faba7193ca7f0acccbc13b1ff6ebf9072",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/jborg/attic/issues/271",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/05/31/3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/74821",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/jborg/attic/commit/78f9ad1faba7193ca7f0acccbc13b1ff6ebf9072",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/jborg/attic/issues/271",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:05.106792",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "attic",
    "owner": "jborg",
    "created_at": "2013-07-09T18:05:50Z",
    "updated_at": "2025-01-12T23:31:17Z",
    "pushed_at": "2021-09-13T16:02:58Z",
    "size": 5305,
    "stars": 1106,
    "forks": 104,
    "open_issues": 198,
    "watchers": 1106,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Python": 296164,
      "C": 18912
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T21:47:51.729943"
  }
}