{
  "cve_id": "CVE-2015-4646",
  "github_data": {
    "repository": "plougher/squashfs-tools",
    "fix_commit": "f95864afe8833fe3ad782d714b41378e860977b1",
    "related_commits": [
      "f95864afe8833fe3ad782d714b41378e860977b1",
      "f95864afe8833fe3ad782d714b41378e860977b1"
    ],
    "patch_url": "https://github.com/plougher/squashfs-tools/commit/f95864afe8833fe3ad782d714b41378e860977b1.patch",
    "fix_commit_details": {
      "sha": "f95864afe8833fe3ad782d714b41378e860977b1",
      "commit_date": "2019-07-15T20:19:06Z",
      "author": {
        "login": "plougher",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "unsquashfs-4: Add more sanity checks + fix CVE-2015-4645/6",
        "length": 1333,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 293,
        "additions": 239,
        "deletions": 54
      },
      "files": [
        {
          "filename": "squashfs-tools/read_xattrs.c",
          "status": "modified",
          "additions": 43,
          "deletions": 14,
          "patch": "@@ -150,7 +150,16 @@ static int read_xattr_entry(struct xattr_list *xattr,\n  */\n int read_xattrs_from_disk(int fd, struct squashfs_super_block *sBlk, int flag, long long *table_start)\n {\n-\tint res, bytes, i, indexes, index_bytes, ids;\n+\t/*\n+\t * Note on overflow limits:\n+\t * Size of ids (id_table.xattr_ids) is 2^32 (unsigned int)\n+\t * Max size of bytes is 2^32*16 or 2^36\n+\t * Max indexes is (2^32*16)/8K or 2^23\n+\t * Max index_bytes is ((2^32*16)/8K)*8 or 2^26 or 64M\n+\t */\n+\tint res, i, indexes, index_bytes;\n+\tunsigned int ids;\n+\tlong long bytes;\n \tlong long *index, start, end;\n \tstruct squashfs_xattr_table id_table;\n \n@@ -170,24 +179,44 @@ int read_xattrs_from_disk(int fd, struct squashfs_super_block *sBlk, int flag, l\n \n \tSQUASHFS_INSWAP_XATTR_TABLE(&id_table);\n \n-\tif(flag) {\n-\t\t/*\n-\t\t * id_table.xattr_table_start stores the start of the compressed xattr\n-\t\t * * metadata blocks.  This by definition is also the end of the previous\n-\t\t * filesystem table - the id lookup table.\n-\t\t */\n+\t/*\n+\t * Compute index table values\n+\t */\n+\tids = id_table.xattr_ids;\n+\txattr_table_start = id_table.xattr_table_start;\n+\tindex_bytes = SQUASHFS_XATTR_BLOCK_BYTES((long long) ids);\n+\tindexes = SQUASHFS_XATTR_BLOCKS((long long) ids);\n+\n+\t/*\n+\t * The size of the index table (index_bytes) should match the\n+\t * table start and end points\n+\t */\n+\tif(index_bytes != (sBlk->bytes_used - (sBlk->xattr_id_table_start + sizeof(id_table)))) {\n+\t\tERROR(\"read_xattrs_from_disk: Bad xattr_ids count in super block\\n\");\n+\t\treturn 0;\n+\t}\n+\n+\t/*\n+\t * id_table.xattr_table_start stores the start of the compressed xattr\n+\t * metadata blocks.  This by definition is also the end of the previous\n+\t * filesystem table - the id lookup table.\n+\t */\n+\tif(table_start != NULL)\n \t\t*table_start = id_table.xattr_table_start;\n+\n+\t/*\n+\t * If flag is set then return once we've read the above\n+\t * table_start.  That value is necessary for sanity checking,\n+\t * but we don't actually want to extract the xattrs, and so\n+\t * stop here.\n+\t */\n+\tif(flag)\n \t\treturn id_table.xattr_ids;\n-\t}\n \n \t/*\n \t * Allocate and read the index to the xattr id table metadata\n \t * blocks\n \t */\n-\tids = id_table.xattr_ids;\n-\txattr_table_start = id_table.xattr_table_start;\n-\tindex_bytes = SQUASHFS_XATTR_BLOCK_BYTES(ids);\n-\tindexes = SQUASHFS_XATTR_BLOCKS(ids);\n \tindex = malloc(index_bytes);\n \tif(index == NULL)\n \t\tMEM_ERROR();\n@@ -203,7 +232,7 @@ int read_xattrs_from_disk(int fd, struct squashfs_super_block *sBlk, int flag, l\n \t * Allocate enough space for the uncompressed xattr id table, and\n \t * read and decompress it\n \t */\n-\tbytes = SQUASHFS_XATTR_BYTES(ids);\n+\tbytes = SQUASHFS_XATTR_BYTES((long long) ids);\n \txattr_ids = malloc(bytes);\n \tif(xattr_ids == NULL)\n \t\tMEM_ERROR();\n@@ -213,7 +242,7 @@ int read_xattrs_from_disk(int fd, struct squashfs_super_block *sBlk, int flag, l\n \t\t\t\t\tbytes & (SQUASHFS_METADATA_SIZE - 1);\n \t\tint length = read_block(fd, index[i], NULL, expected,\n \t\t\t((unsigned char *) xattr_ids) +\n-\t\t\t(i * SQUASHFS_METADATA_SIZE));\n+\t\t\t((long long) i * SQUASHFS_METADATA_SIZE));\n \t\tTRACE(\"Read xattr id table block %d, from 0x%llx, length \"\n \t\t\t\"%d\\n\", i, index[i], length);\n \t\tif(length == 0) {"
        },
        {
          "filename": "squashfs-tools/unsquash-4.c",
          "status": "modified",
          "additions": 195,
          "deletions": 39,
          "patch": "@@ -29,30 +29,63 @@\n static struct squashfs_fragment_entry *fragment_table;\n static unsigned int *id_table;\n \n-static int read_fragment_table(long long *directory_table_end)\n+long long *alloc_index_table(int indexes)\n {\n+\tstatic long long *alloc_table = NULL;\n+\tstatic int alloc_size = 0;\n+\tint length = indexes * sizeof(long long);\n+\n+\tif(alloc_size < length) {\n+\t\tlong long *table = realloc(alloc_table, length);\n+\n+\t\tif(table == NULL)\n+\t\t\tEXIT_UNSQUASH(\"alloc_index_table: failed to allocate \"\n+\t\t\t\t\"index table\\n\");\n+\n+\t\talloc_table = table;\n+\t\talloc_size = length;\n+\t}\n+\n+\treturn alloc_table;\n+}\n+\n+\n+static int read_fragment_table(long long *table_start)\n+{\n+\t/*\n+\t * Note on overflow limits:\n+\t * Size of SBlk.s.fragments is 2^32 (unsigned int)\n+\t * Max size of bytes is 2^32*16 or 2^36\n+\t * Max indexes is (2^32*16)/8K or 2^23\n+\t * Max length is ((2^32*16)/8K)*8 or 2^26 or 64M\n+\t */\n \tint res, i;\n-\tint bytes = SQUASHFS_FRAGMENT_BYTES(sBlk.s.fragments);\n-\tint  indexes = SQUASHFS_FRAGMENT_INDEXES(sBlk.s.fragments);\n-\tlong long fragment_table_index[indexes];\n+\tlong long bytes = SQUASHFS_FRAGMENT_BYTES((long long) sBlk.s.fragments);\n+\tint indexes = SQUASHFS_FRAGMENT_INDEXES((long long) sBlk.s.fragments);\n+\tint length = SQUASHFS_FRAGMENT_INDEX_BYTES((long long) sBlk.s.fragments);\n+\tlong long *fragment_table_index;\n+\n+\t/*\n+\t * The size of the index table (length bytes) should match the\n+\t * table start and end points\n+\t */\n+\tif(length != (*table_start - sBlk.s.fragment_table_start)) {\n+\t\tERROR(\"read_fragment_table: Bad fragment count in super block\\n\");\n+\t\treturn FALSE;\n+\t}\n \n \tTRACE(\"read_fragment_table: %d fragments, reading %d fragment indexes \"\n \t\t\"from 0x%llx\\n\", sBlk.s.fragments, indexes,\n \t\tsBlk.s.fragment_table_start);\n \n-\tif(sBlk.s.fragments == 0) {\n-\t\t*directory_table_end = sBlk.s.fragment_table_start;\n-\t\treturn TRUE;\n-\t}\n-\n+\tfragment_table_index = alloc_index_table(indexes);\n \tfragment_table = malloc(bytes);\n \tif(fragment_table == NULL)\n \t\tEXIT_UNSQUASH(\"read_fragment_table: failed to allocate \"\n \t\t\t\"fragment table\\n\");\n \n-\tres = read_fs_bytes(fd, sBlk.s.fragment_table_start,\n-\t\tSQUASHFS_FRAGMENT_INDEX_BYTES(sBlk.s.fragments),\n-\t\tfragment_table_index);\n+\tres = read_fs_bytes(fd, sBlk.s.fragment_table_start, length,\n+\t\t\t\t\t\t\tfragment_table_index);\n \tif(res == FALSE) {\n \t\tERROR(\"read_fragment_table: failed to read fragment table \"\n \t\t\t\"index\\n\");\n@@ -78,7 +111,7 @@ static int read_fragment_table(long long *directory_table_end)\n \tfor(i = 0; i < sBlk.s.fragments; i++) \n \t\tSQUASHFS_INSWAP_FRAGMENT_ENTRY(&fragment_table[i]);\n \n-\t*directory_table_end = fragment_table_index[0];\n+\t*table_start = fragment_table_index[0];\n \treturn TRUE;\n }\n \n@@ -356,25 +389,42 @@ struct dir *squashfs_opendir_4(unsigned int block_start, unsigned int offset,\n }\n \n \n-static int read_uids_guids(long long *table_start)\n+static int read_id_table(long long *table_start)\n {\n+\t/*\n+\t * Note on overflow limits:\n+\t * Size of SBlk.s.no_ids is 2^16 (unsigned short)\n+\t * Max size of bytes is 2^16*4 or 256K\n+\t * Max indexes is (2^16*4)/8K or 32\n+\t * Max length is ((2^16*4)/8K)*8 or 256\n+\t */\n \tint res, i;\n \tint bytes = SQUASHFS_ID_BYTES(sBlk.s.no_ids);\n \tint indexes = SQUASHFS_ID_BLOCKS(sBlk.s.no_ids);\n-\tlong long id_index_table[indexes];\n+\tint length = SQUASHFS_ID_BLOCK_BYTES(sBlk.s.no_ids);\n+\tlong long *id_index_table;\n+\n+\t/*\n+\t * The size of the index table (length bytes) should match the\n+\t * table start and end points\n+\t */\n+\tif(length != (*table_start - sBlk.s.id_table_start)) {\n+\t\tERROR(\"read_id_table: Bad id count in super block\\n\");\n+\t\treturn FALSE;\n+\t}\n \n-\tTRACE(\"read_uids_guids: no_ids %d\\n\", sBlk.s.no_ids);\n+\tTRACE(\"read_id_table: no_ids %d\\n\", sBlk.s.no_ids);\n \n+\tid_index_table = alloc_index_table(indexes);\n \tid_table = malloc(bytes);\n \tif(id_table == NULL) {\n-\t\tERROR(\"read_uids_guids: failed to allocate id table\\n\");\n+\t\tERROR(\"read_id_table: failed to allocate id table\\n\");\n \t\treturn FALSE;\n \t}\n \n-\tres = read_fs_bytes(fd, sBlk.s.id_table_start,\n-\t\tSQUASHFS_ID_BLOCK_BYTES(sBlk.s.no_ids), id_index_table);\n+\tres = read_fs_bytes(fd, sBlk.s.id_table_start, length, id_index_table);\n \tif(res == FALSE) {\n-\t\tERROR(\"read_uids_guids: failed to read id index table\\n\");\n+\t\tERROR(\"read_id_table: failed to read id index table\\n\");\n \t\treturn FALSE;\n \t}\n \tSQUASHFS_INSWAP_ID_BLOCKS(id_index_table, indexes);\n@@ -393,7 +443,7 @@ static int read_uids_guids(long long *table_start)\n \t\tres = read_block(fd, id_index_table[i], NULL, expected,\n \t\t\t((char *) id_table) + i * SQUASHFS_METADATA_SIZE);\n \t\tif(res == FALSE) {\n-\t\t\tERROR(\"read_uids_guids: failed to read id table block\"\n+\t\t\tERROR(\"read_id_table: failed to read id table block\"\n \t\t\t\t\"\\n\");\n \t\t\treturn FALSE;\n \t\t}\n@@ -407,12 +457,30 @@ static int read_uids_guids(long long *table_start)\n \n static int parse_exports_table(long long *table_start)\n {\n+\t/*\n+\t * Note on overflow limits:\n+\t * Size of SBlk.s.inodes is 2^32 (unsigned int)\n+\t * Max indexes is (2^32*8)/8K or 2^22\n+\t * Max length is ((2^32*8)/8K)*8 or 2^25\n+\t */\n \tint res;\n-\tint indexes = SQUASHFS_LOOKUP_BLOCKS(sBlk.s.inodes);\n-\tlong long export_index_table[indexes];\n+\tint indexes = SQUASHFS_LOOKUP_BLOCKS((long long) sBlk.s.inodes);\n+\tint length = SQUASHFS_LOOKUP_BLOCK_BYTES((long long) sBlk.s.inodes);\n+\tlong long *export_index_table;\n+\n+\t/*\n+\t * The size of the index table (length bytes) should match the\n+\t * table start and end points\n+\t */\n+\tif(length != (*table_start - sBlk.s.lookup_table_start)) {\n+\t\tERROR(\"parse_exports_table: Bad inode count in super block\\n\");\n+\t\treturn FALSE;\n+\t}\n \n-\tres = read_fs_bytes(fd, sBlk.s.lookup_table_start,\n-\t\tSQUASHFS_LOOKUP_BLOCK_BYTES(sBlk.s.inodes), export_index_table);\n+\texport_index_table = alloc_index_table(indexes);\n+\n+\tres = read_fs_bytes(fd, sBlk.s.lookup_table_start, length,\n+\t\t\t\t\t\t\texport_index_table);\n \tif(res == FALSE) {\n \t\tERROR(\"parse_exports_table: failed to read export index table\\n\");\n \t\treturn FALSE;\n@@ -432,30 +500,118 @@ static int parse_exports_table(long long *table_start)\n \n int read_filesystem_tables_4()\n {\n-\tlong long directory_table_end, table_start;\n+\tlong long table_start;\n \n-\tif(read_xattrs_from_disk(fd, &sBlk.s, no_xattrs, &table_start) == 0)\n-\t\treturn FALSE;\n+\t/* Read xattrs */\n+\tif(sBlk.s.xattr_id_table_start != SQUASHFS_INVALID_BLK) {\n+\t\t/* sanity check super block contents */\n+\t\tif(sBlk.s.xattr_id_table_start >= sBlk.s.bytes_used) {\n+\t\t\tERROR(\"read_filesystem_tables: xattr id table start too large in super block\\n\");\n+\t\t\tgoto corrupted;\n+\t\t}\n \n-\tif(read_uids_guids(&table_start) == FALSE)\n-\t\treturn FALSE;\n+\t\tif(read_xattrs_from_disk(fd, &sBlk.s, no_xattrs, &table_start) == 0)\n+\t\t\tgoto corrupted;\n+\t} else\n+\t\ttable_start = sBlk.s.bytes_used;\n \n-\tif(parse_exports_table(&table_start) == FALSE)\n-\t\treturn FALSE;\n+\t/* Read id lookup table */\n \n-\tif(read_fragment_table(&directory_table_end) == FALSE)\n-\t\treturn FALSE;\n+\t/* Sanity check super block contents */\n+\tif(sBlk.s.id_table_start >= table_start) {\n+\t\tERROR(\"read_filesystem_tables: id table start too large in super block\\n\");\n+\t\tgoto corrupted;\n+\t}\n \n-\tif(read_inode_table(sBlk.s.inode_table_start,\n-\t\t\t\tsBlk.s.directory_table_start) == FALSE)\n-\t\treturn FALSE;\n+\t/* there should always be at least one id */\n+\tif(sBlk.s.no_ids == 0) {\n+\t\tERROR(\"read_filesystem_tables: Bad id count in super block\\n\");\n+\t\tgoto corrupted;\n+\t}\n+\n+\t/*\n+\t * the number of ids can never be more than double the number of inodes\n+\t * (the maximum is a unique uid and gid for each inode).\n+\t */\n+\tif(sBlk.s.no_ids > (sBlk.s.inodes * 2L)) {\n+\t\tERROR(\"read_filesystem_tables: Bad id count in super block\\n\");\n+\t\tgoto corrupted;\n+\t}\n+\n+\tif(read_id_table(&table_start) == FALSE)\n+\t\tgoto corrupted;\n+\n+\t/* Read exports table */\n+\tif(sBlk.s.lookup_table_start != SQUASHFS_INVALID_BLK) {\n+\n+\t\t/* sanity check super block contents */\n+\t\tif(sBlk.s.lookup_table_start >= table_start) {\n+\t\t\tERROR(\"read_filesystem_tables: lookup table start too large in super block\\n\");\n+\t\t\tgoto corrupted;\n+\t\t}\n+\n+\t\tif(parse_exports_table(&table_start) == FALSE)\n+\t\t\tgoto corrupted;\n+\t}\n+\n+\t/* Read fragment table */\n+\tif(sBlk.s.fragments != 0) {\n+\n+\t\t/* Sanity check super block contents */\n+\t\tif(sBlk.s.fragment_table_start >= table_start) {\n+\t\t\tERROR(\"read_filesystem_tables: fragment table start too large in super block\\n\");\n+\t\t\tgoto corrupted;\n+\t\t}\n+\n+\t\t/* The number of fragments should not exceed the number of inodes */\n+\t\tif(sBlk.s.fragments > sBlk.s.inodes) {\n+\t\t\tERROR(\"read_filesystem_tables: Bad fragment count in super block\\n\");\n+\t\t\tgoto corrupted;\n+\t\t}\n+\n+\t\tif(read_fragment_table(&table_start) == FALSE)\n+\t\t\tgoto corrupted;\n+\t} else {\n+\t\t/*\n+\t\t * Sanity check super block contents - with 0 fragments,\n+\t\t * the fragment table should be empty\n+\t\t */\n+\t\tif(sBlk.s.fragment_table_start != table_start) {\n+\t\t\tERROR(\"read_filesystem_tables: fragment table start invalid in super block\\n\");\n+\t\t\tgoto corrupted;\n+\t\t}\n+\t}\n+\n+\t/* Read directory table */\n+\n+\t/* Sanity check super block contents */\n+\tif(sBlk.s.directory_table_start >= table_start) {\n+\t\tERROR(\"read_filesystem_tables: directory table start too large in super block\\n\");\n+\t\tgoto corrupted;\n+\t}\n \n \tif(read_directory_table(sBlk.s.directory_table_start,\n-\t\t\t\tdirectory_table_end) == FALSE)\n-\t\treturn FALSE;\n+\t\t\t\ttable_start) == FALSE)\n+\t\tgoto corrupted;\n+\n+\t/* Read inode table */\n+\n+\t/* Sanity check super block contents */\n+\tif(sBlk.s.inode_table_start >= sBlk.s.directory_table_start) {\n+\t\tERROR(\"read_filesystem_tables: inode table start too large in super block\\n\");\n+\t\tgoto corrupted;\n+\t}\n+\n+\tif(read_inode_table(sBlk.s.inode_table_start,\n+\t\t\t\tsBlk.s.directory_table_start) == FALSE)\n+\t\tgoto corrupted;\n \n \tif(no_xattrs)\n \t\tsBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;\n \n \treturn TRUE;\n+\n+corrupted:\n+\tERROR(\"File system corruption detected\\n\");\n+\treturn FALSE;\n }"
        },
        {
          "filename": "squashfs-tools/unsquashfs.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -2465,7 +2465,7 @@ int parse_number(char *arg, int *res)\n \n \n #define VERSION() \\\n-\tprintf(\"unsquashfs version 4.3-git (2019/07/05)\\n\");\\\n+\tprintf(\"unsquashfs version 4.3-git (2019/07/15)\\n\");\\\n \tprintf(\"copyright (C) 2019 Phillip Lougher \"\\\n \t\t\"<phillip@squashfs.org.uk>\\n\\n\");\\\n     \tprintf(\"This program is free software; you can redistribute it and/or\"\\"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "dbe45af1d616bc8b79f35d255bb2b80d273ad9f6",
            "date": "2025-01-01T13:18:47Z",
            "author_login": "plougher"
          },
          {
            "sha": "d0c2f7af3224886bf6956ed3c66dafd065214840",
            "date": "2025-01-01T13:04:55Z",
            "author_login": "plougher"
          },
          {
            "sha": "3ca5f37152414d62c9a8eb32d81c64d7a68d142c",
            "date": "2025-01-01T13:02:23Z",
            "author_login": "plougher"
          },
          {
            "sha": "0baca77e56ab6ed000680d59b48bfb6f01fef1d4",
            "date": "2025-01-01T12:50:06Z",
            "author_login": "plougher"
          },
          {
            "sha": "615bfdefe266fa0fc4280185cf87fac8f5e309e3",
            "date": "2025-01-01T12:48:24Z",
            "author_login": "plougher"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-20",
    "description": "(1) unsquash-1.c, (2) unsquash-2.c, (3) unsquash-3.c, and (4) unsquash-4.c in Squashfs and sasquatch allow remote attackers to cause a denial of service (application crash) via a crafted input.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2017-04-13T17:59:00.340",
    "last_modified": "2024-11-21T02:31:28.440",
    "fix_date": "2019-07-15T20:19:06Z"
  },
  "references": [
    {
      "url": "http://seclists.org/oss-sec/2015/q2/756",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/75272",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/plougher/squashfs-tools/commit/f95864afe8833fe3ad782d714b41378e860977b1",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201701-73",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://seclists.org/oss-sec/2015/q2/756",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/75272",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/plougher/squashfs-tools/commit/f95864afe8833fe3ad782d714b41378e860977b1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201701-73",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:54.855406",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "squashfs-tools",
    "owner": "plougher",
    "created_at": "2012-11-01T16:44:15Z",
    "updated_at": "2025-01-13T11:33:55Z",
    "pushed_at": "2025-01-01T13:19:13Z",
    "size": 3683,
    "stars": 803,
    "forks": 199,
    "open_issues": 27,
    "watchers": 803,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "C": 1307937,
      "Roff": 306042,
      "Shell": 30686,
      "Makefile": 16500
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T17:30:50.126691"
  }
}