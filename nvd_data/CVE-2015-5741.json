{
  "cve_id": "CVE-2015-5741",
  "github_data": {
    "repository": "golang/go",
    "fix_commit": "300d9a21583e7cf0149a778a0611e76ff7c6680f",
    "related_commits": [
      "300d9a21583e7cf0149a778a0611e76ff7c6680f",
      "300d9a21583e7cf0149a778a0611e76ff7c6680f"
    ],
    "patch_url": "https://github.com/golang/go/commit/300d9a21583e7cf0149a778a0611e76ff7c6680f.patch",
    "fix_commit_details": {
      "sha": "300d9a21583e7cf0149a778a0611e76ff7c6680f",
      "commit_date": "2015-06-30T21:21:15Z",
      "author": {
        "login": "bradfitz",
        "type": "User",
        "stats": {
          "total_commits": 2382,
          "average_weekly_commits": 2.7037457434733256,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 440
        }
      },
      "commit_message": {
        "title": "net/http: harden Server against request smuggling",
        "length": 301,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 115,
        "additions": 99,
        "deletions": 16
      },
      "files": [
        {
          "filename": "src/net/http/readrequest_test.go",
          "status": "modified",
          "additions": 60,
          "deletions": 5,
          "patch": "@@ -9,6 +9,7 @@ import (\n \t\"bytes\"\n \t\"fmt\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"net/url\"\n \t\"reflect\"\n \t\"strings\"\n@@ -323,6 +324,32 @@ var reqTests = []reqTest{\n \t\tnoTrailer,\n \t\tnoError,\n \t},\n+\n+\t// HEAD with Content-Length 0. Make sure this is permitted,\n+\t// since I think we used to send it.\n+\t{\n+\t\t\"HEAD / HTTP/1.1\\r\\nHost: issue8261.com\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\",\n+\t\t&Request{\n+\t\t\tMethod: \"HEAD\",\n+\t\t\tURL: &url.URL{\n+\t\t\t\tPath: \"/\",\n+\t\t\t},\n+\t\t\tHeader: Header{\n+\t\t\t\t\"Connection\":     []string{\"close\"},\n+\t\t\t\t\"Content-Length\": []string{\"0\"},\n+\t\t\t},\n+\t\t\tHost:       \"issue8261.com\",\n+\t\t\tProto:      \"HTTP/1.1\",\n+\t\t\tProtoMajor: 1,\n+\t\t\tProtoMinor: 1,\n+\t\t\tClose:      true,\n+\t\t\tRequestURI: \"/\",\n+\t\t},\n+\n+\t\tnoBody,\n+\t\tnoTrailer,\n+\t\tnoError,\n+\t},\n }\n \n func TestReadRequest(t *testing.T) {\n@@ -357,10 +384,38 @@ func TestReadRequest(t *testing.T) {\n \t}\n }\n \n-func TestReadRequest_BadConnectHost(t *testing.T) {\n-\tdata := []byte(\"CONNECT []%20%48%54%54%50%2f%31%2e%31%0a%4d%79%48%65%61%64%65%72%3a%20%31%32%33%0a%0a HTTP/1.0\\n\\n\")\n-\tr, err := ReadRequest(bufio.NewReader(bytes.NewReader(data)))\n-\tif err == nil {\n-\t\tt.Fatal(\"Got unexpected request = %#v\", r)\n+// reqBytes treats req as a request (with \\n delimiters) and returns it with \\r\\n delimiters,\n+// ending in \\r\\n\\r\\n\n+func reqBytes(req string) []byte {\n+\treturn []byte(strings.Replace(strings.TrimSpace(req), \"\\n\", \"\\r\\n\", -1) + \"\\r\\n\\r\\n\")\n+}\n+\n+var badRequestTests = []struct {\n+\tname string\n+\treq  []byte\n+}{\n+\t{\"bad_connect_host\", reqBytes(\"CONNECT []%20%48%54%54%50%2f%31%2e%31%0a%4d%79%48%65%61%64%65%72%3a%20%31%32%33%0a%0a HTTP/1.0\")},\n+\t{\"smuggle_two_contentlen\", reqBytes(`POST / HTTP/1.1\n+Content-Length: 3\n+Content-Length: 4\n+\n+abc`)},\n+\t{\"smuggle_chunked_and_len\", reqBytes(`POST / HTTP/1.1\n+Transfer-Encoding: chunked\n+Content-Length: 3\n+\n+abc`)},\n+\t{\"smuggle_content_len_head\", reqBytes(`HEAD / HTTP/1.1\n+Host: foo\n+Content-Length: 5`)},\n+}\n+\n+func TestReadRequest_Bad(t *testing.T) {\n+\tfor _, tt := range badRequestTests {\n+\t\tgot, err := ReadRequest(bufio.NewReader(bytes.NewReader(tt.req)))\n+\t\tif err == nil {\n+\t\t\tall, err := ioutil.ReadAll(got.Body)\n+\t\t\tt.Errorf(\"%s: got unexpected request = %#v\\n  Body = %q, %v\", tt.name, got, all, err)\n+\t\t}\n \t}\n }"
        },
        {
          "filename": "src/net/http/transfer.go",
          "status": "modified",
          "additions": 39,
          "deletions": 11,
          "patch": "@@ -148,6 +148,9 @@ func (t *transferWriter) shouldSendContentLength() bool {\n \t\treturn true\n \t}\n \tif t.ContentLength == 0 && isIdentity(t.TransferEncoding) {\n+\t\tif t.Method == \"GET\" || t.Method == \"HEAD\" {\n+\t\t\treturn false\n+\t\t}\n \t\treturn true\n \t}\n \n@@ -317,6 +320,7 @@ func readTransfer(msg interface{}, r *bufio.Reader) (err error) {\n \t\t}\n \tcase *Request:\n \t\tt.Header = rr.Header\n+\t\tt.RequestMethod = rr.Method\n \t\tt.ProtoMajor = rr.ProtoMajor\n \t\tt.ProtoMinor = rr.ProtoMinor\n \t\t// Transfer semantics for Requests are exactly like those for\n@@ -333,7 +337,7 @@ func readTransfer(msg interface{}, r *bufio.Reader) (err error) {\n \t}\n \n \t// Transfer encoding, content length\n-\tt.TransferEncoding, err = fixTransferEncoding(t.RequestMethod, t.Header)\n+\tt.TransferEncoding, err = fixTransferEncoding(isResponse, t.RequestMethod, t.Header)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -421,12 +425,12 @@ func chunked(te []string) bool { return len(te) > 0 && te[0] == \"chunked\" }\n func isIdentity(te []string) bool { return len(te) == 1 && te[0] == \"identity\" }\n \n // Sanitize transfer encoding\n-func fixTransferEncoding(requestMethod string, header Header) ([]string, error) {\n+func fixTransferEncoding(isResponse bool, requestMethod string, header Header) ([]string, error) {\n \traw, present := header[\"Transfer-Encoding\"]\n \tif !present {\n \t\treturn nil, nil\n \t}\n-\n+\tisRequest := !isResponse\n \tdelete(header, \"Transfer-Encoding\")\n \n \tencodings := strings.Split(raw[0], \",\")\n@@ -451,10 +455,15 @@ func fixTransferEncoding(requestMethod string, header Header) ([]string, error)\n \t\treturn nil, &badStringError{\"too many transfer encodings\", strings.Join(te, \",\")}\n \t}\n \tif len(te) > 0 {\n-\t\t// Chunked encoding trumps Content-Length. See RFC 2616\n-\t\t// Section 4.4. Currently len(te) > 0 implies chunked\n-\t\t// encoding.\n-\t\tdelete(header, \"Content-Length\")\n+\t\t// RFC 7230 3.3.2 says \"A sender MUST NOT send a\n+\t\t// Content-Length header field in any message that\n+\t\t// contains a Transfer-Encoding header field.\"\n+\t\tif len(header[\"Content-Length\"]) > 0 {\n+\t\t\tif isRequest {\n+\t\t\t\treturn nil, errors.New(\"http: invalid Content-Length with Transfer-Encoding\")\n+\t\t\t}\n+\t\t\tdelete(header, \"Content-Length\")\n+\t\t}\n \t\treturn te, nil\n \t}\n \n@@ -465,9 +474,17 @@ func fixTransferEncoding(requestMethod string, header Header) ([]string, error)\n // function is not a method, because ultimately it should be shared by\n // ReadResponse and ReadRequest.\n func fixLength(isResponse bool, status int, requestMethod string, header Header, te []string) (int64, error) {\n-\n+\tcontentLens := header[\"Content-Length\"]\n+\tisRequest := !isResponse\n \t// Logic based on response type or status\n \tif noBodyExpected(requestMethod) {\n+\t\t// For HTTP requests, as part of hardening against request\n+\t\t// smuggling (RFC 7230), don't allow a Content-Length header for\n+\t\t// methods which don't permit bodies. As an exception, allow\n+\t\t// exactly one Content-Length header if its value is \"0\".\n+\t\tif isRequest && len(contentLens) > 0 && !(len(contentLens) == 1 && contentLens[0] == \"0\") {\n+\t\t\treturn 0, fmt.Errorf(\"http: method cannot contain a Content-Length; got %q\", contentLens)\n+\t\t}\n \t\treturn 0, nil\n \t}\n \tif status/100 == 1 {\n@@ -478,13 +495,21 @@ func fixLength(isResponse bool, status int, requestMethod string, header Header,\n \t\treturn 0, nil\n \t}\n \n+\tif len(contentLens) > 1 {\n+\t\t// harden against HTTP request smuggling. See RFC 7230.\n+\t\treturn 0, errors.New(\"http: message cannot contain multiple Content-Length headers\")\n+\t}\n+\n \t// Logic based on Transfer-Encoding\n \tif chunked(te) {\n \t\treturn -1, nil\n \t}\n \n \t// Logic based on Content-Length\n-\tcl := strings.TrimSpace(header.get(\"Content-Length\"))\n+\tvar cl string\n+\tif len(contentLens) == 1 {\n+\t\tcl = strings.TrimSpace(contentLens[0])\n+\t}\n \tif cl != \"\" {\n \t\tn, err := parseContentLength(cl)\n \t\tif err != nil {\n@@ -495,11 +520,14 @@ func fixLength(isResponse bool, status int, requestMethod string, header Header,\n \t\theader.Del(\"Content-Length\")\n \t}\n \n-\tif !isResponse && requestMethod == \"GET\" {\n-\t\t// RFC 2616 doesn't explicitly permit nor forbid an\n+\tif !isResponse {\n+\t\t// RFC 2616 neither explicitly permits nor forbids an\n \t\t// entity-body on a GET request so we permit one if\n \t\t// declared, but we default to 0 here (not -1 below)\n \t\t// if there's no mention of a body.\n+\t\t// Likewise, all other request methods are assumed to have\n+\t\t// no body if neither Transfer-Encoding chunked nor a\n+\t\t// Content-Length are set.\n \t\treturn 0, nil\n \t}\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "6da16013ba4444e0d71540f68279f0283a92d05d",
            "date": "2024-12-28T16:19:23Z",
            "author_login": "seankhliao"
          },
          {
            "sha": "de9fdc7b7154a1ddd73cb44292cdd65f4f56029a",
            "date": "2025-01-13T17:56:13Z",
            "author_login": "ianlancetaylor"
          },
          {
            "sha": "17ed2159583289d77c994d479c24f7e7c2837332",
            "date": "2025-01-09T23:01:03Z",
            "author_login": "griesemer"
          },
          {
            "sha": "c53307c3fdf1126eb6cdb1f09f4f9b83759be705",
            "date": "2025-01-10T15:00:24Z",
            "author_login": "alexandear"
          },
          {
            "sha": "47a56b2b6d2cca56384810027964968667b86fdc",
            "date": "2025-01-11T20:48:33Z",
            "author_login": "dsnet"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-444",
    "description": "The net/http library in net/http/transfer.go in Go before 1.4.3 does not properly parse HTTP headers, which allows remote attackers to conduct HTTP request smuggling attacks via a request that contains Content-Length and Transfer-Encoding header fields.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-02-08T19:15:10.770",
    "last_modified": "2024-11-21T02:33:45.273",
    "fix_date": "2015-06-30T21:21:15Z"
  },
  "references": [
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-October/167997.html",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-October/168029.html",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://seclists.org/oss-sec/2015/q3/237",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://seclists.org/oss-sec/2015/q3/292",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://seclists.org/oss-sec/2015/q3/294",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1250352",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/golang/go/commit/300d9a21583e7cf0149a778a0611e76ff7c6680f",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-October/167997.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-October/168029.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://seclists.org/oss-sec/2015/q3/237",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://seclists.org/oss-sec/2015/q3/292",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://seclists.org/oss-sec/2015/q3/294",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1250352",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/golang/go/commit/300d9a21583e7cf0149a778a0611e76ff7c6680f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:39.838846",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "go",
    "owner": "golang",
    "created_at": "2014-08-19T04:33:40Z",
    "updated_at": "2025-01-14T13:58:25Z",
    "pushed_at": "2025-01-13T19:19:33Z",
    "size": 385472,
    "stars": 125082,
    "forks": 17781,
    "open_issues": 9602,
    "watchers": 125082,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "dev.boringcrypto.go1.8",
      "dev.boringcrypto.go1.9",
      "dev.boringcrypto.go1.10",
      "dev.boringcrypto.go1.11",
      "dev.boringcrypto.go1.12",
      "dev.boringcrypto.go1.13",
      "dev.boringcrypto.go1.14",
      "dev.boringcrypto.go1.15",
      "dev.boringcrypto.go1.16",
      "dev.boringcrypto.go1.17",
      "dev.boringcrypto.go1.18",
      "dev.boringcrypto",
      "dev.cc",
      "dev.cmdgo",
      "dev.coretypes",
      "dev.debug",
      "dev.fuzz",
      "dev.garbage",
      "dev.gcfe",
      "dev.go2go",
      "dev.inline",
      "dev.link",
      "dev.power64",
      "dev.regabi",
      "dev.ssa",
      "dev.tls",
      "dev.typealias",
      "dev.typeparams",
      "dev.types",
      "dev.unified"
    ],
    "languages": {
      "Go": 47823232,
      "Assembly": 3216144,
      "HTML": 2621355,
      "C": 122435,
      "Shell": 64551,
      "Perl": 32036,
      "JavaScript": 20759,
      "Python": 19317,
      "Batchfile": 9485,
      "Dockerfile": 3563,
      "Makefile": 1868,
      "Awk": 450
    },
    "commit_activity": {
      "total_commits_last_year": 2897,
      "avg_commits_per_week": 55.71153846153846,
      "days_active_last_year": 341
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T14:07:55.970395"
  }
}