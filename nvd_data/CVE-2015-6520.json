{
  "cve_id": "CVE-2015-6520",
  "github_data": {
    "repository": "tillkamppeter/ippusbxd",
    "fix_commit": "46844402bca7a38fc224483ba6f0a93c4613203f",
    "related_commits": [
      "46844402bca7a38fc224483ba6f0a93c4613203f",
      "46844402bca7a38fc224483ba6f0a93c4613203f"
    ],
    "patch_url": "https://github.com/tillkamppeter/ippusbxd/commit/46844402bca7a38fc224483ba6f0a93c4613203f.patch",
    "fix_commit_details": {
      "sha": "46844402bca7a38fc224483ba6f0a93c4613203f",
      "commit_date": "2015-08-09T23:14:19Z",
      "author": {
        "login": "tillkamppeter",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "SECURITY FIX: Actually restrict the access to the printer to localhost",
        "length": 420,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 140,
        "additions": 125,
        "deletions": 15
      },
      "files": [
        {
          "filename": "src/ippusbxd.c",
          "status": "modified",
          "additions": 22,
          "deletions": 6,
          "patch": "@@ -171,9 +171,12 @@ static void start_daemon()\n \n \t// Capture a socket\n \tuint16_t desired_port = g_options.desired_port;\n-\tstruct tcp_sock_t *tcp_socket;\n-\twhile ((tcp_socket = tcp_open(desired_port)) == NULL &&\n-\t       g_options.only_desired_port == 0) {\n+\tstruct tcp_sock_t *tcp_socket = NULL, *tcp6_socket = NULL;\n+\tfor (;;) {\n+\t\ttcp_socket = tcp_open(desired_port);\n+\t\ttcp6_socket = tcp6_open(desired_port);\n+\t\tif (tcp_socket || tcp6_socket || g_options.only_desired_port)\n+\t\t\tbreak;\n \t\t// Search for a free port\n \t\tdesired_port ++;\n \t\t// We failed with 0 as port number or we reached the max\n@@ -183,11 +186,16 @@ static void start_daemon()\n \t\t\t// ports\n \t\t\t// https://en.wikipedia.org/wiki/Ephemeral_port\n \t\t\tdesired_port = 49152;\n+\t\tNOTE(\"Access to desired port failed, trying alternative port %d\", desired_port);\n \t}\n-\tif (tcp_socket == NULL)\n+\tif (tcp_socket == NULL && tcp6_socket == NULL)\n \t\tgoto cleanup_tcp;\n \n-\tuint16_t real_port = tcp_port_number_get(tcp_socket);\n+\tuint16_t real_port;\n+\tif (tcp_socket)\n+\t  real_port = tcp_port_number_get(tcp_socket);\n+\telse\n+\t  real_port = tcp_port_number_get(tcp6_socket);\n \tif (desired_port != 0 && g_options.only_desired_port == 1 &&\n \t    desired_port != real_port) {\n \t\tERR(\"Received port number did not match requested port number.\"\n@@ -197,6 +205,9 @@ static void start_daemon()\n \tprintf(\"%u|\", real_port);\n \tfflush(stdout);\n \n+\tNOTE(\"Port: %d, IPv4 %savailable, IPv6 %savailable\",\n+\t     real_port, tcp_socket ? \"\" : \"not \", tcp6_socket ? \"\" : \"not \");\n+\n \t// Lose connection to caller\n \tuint16_t pid;\n \tif (!g_options.nofork_mode && (pid = fork()) > 0) {\n@@ -216,7 +227,10 @@ static void start_daemon()\n \t\t}\n \n \t\targs->usb_sock = usb_sock;\n-\t\targs->tcp = tcp_conn_accept(tcp_socket);\n+\n+\t\t// For each request/response round we use the socket (IPv4 or\n+\t\t// IPv6) which receives data first\n+\t\targs->tcp = tcp_conn_select(tcp_socket, tcp6_socket);\n \t\tif (args->tcp == NULL) {\n \t\t\tERR(\"Failed to open tcp connection\");\n \t\t\tgoto cleanup_thread;\n@@ -243,6 +257,8 @@ static void start_daemon()\n cleanup_tcp:\n \tif (tcp_socket!= NULL)\n \t\ttcp_close(tcp_socket);\n+\tif (tcp6_socket!= NULL)\n+\t\ttcp_close(tcp6_socket);\n cleanup_usb:\n \tif (usb_sock != NULL)\n \t\tusb_close(usb_sock);"
        },
        {
          "filename": "src/tcp.c",
          "status": "modified",
          "additions": 100,
          "deletions": 8,
          "patch": "@@ -17,6 +17,9 @@\n #include <stdlib.h>\n #include <string.h>\n #include <ctype.h>\n+#include <sys/time.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n \n #include <fcntl.h>\n #include <unistd.h>\n@@ -31,15 +34,66 @@ struct tcp_sock_t *tcp_open(uint16_t port)\n {\n \tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n \tif (this == NULL) {\n-\t\tERR(\"callocing this failed\");\n+\t\tERR(\"IPv4: callocing this failed\");\n+\t\tgoto error;\n+\t}\n+\n+\t// Open [S]ocket [D]escriptor\n+\tthis->sd = -1;\n+\tthis->sd = socket(AF_INET, SOCK_STREAM, 0);\n+\tif (this->sd < 0) {\n+\t\tERR(\"IPv4 socket open failed\");\n+\t\tgoto error;\n+\t}\n+\n+\t// Configure socket params\n+\tstruct sockaddr_in addr;\n+\tmemset(&addr, 0, sizeof addr);\n+\taddr.sin_family = AF_INET;\n+\taddr.sin_port = htons(port);\n+\taddr.sin_addr.s_addr = htonl(0x7F000001);\n+\n+\t// Bind to localhost\n+\tif (bind(this->sd,\n+\t        (struct sockaddr *)&addr,\n+\t        sizeof addr) < 0) {\n+\t\tif (g_options.only_desired_port == 1)\n+\t\t\tERR(\"IPv4 bind on port failed. \"\n+\t\t\t    \"Requested port may be taken or require root permissions.\");\n+\t\tgoto error;\n+\t}\n+\n+\t// Let kernel over-accept max number of connections\n+\tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n+\t\tERR(\"IPv4 listen failed on socket\");\n+\t\tgoto error;\n+\t}\n+\n+\treturn this;\n+\n+error:\n+\tif (this != NULL) {\n+\t\tif (this->sd != -1) {\n+\t\t\tclose(this->sd);\n+\t\t}\n+\t\tfree(this);\n+\t}\n+\treturn NULL;\n+}\n+\n+struct tcp_sock_t *tcp6_open(uint16_t port)\n+{\n+\tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n+\tif (this == NULL) {\n+\t\tERR(\"IPv6: callocing this failed\");\n \t\tgoto error;\n \t}\n \n \t// Open [S]ocket [D]escriptor\n \tthis->sd = -1;\n \tthis->sd = socket(AF_INET6, SOCK_STREAM, 0);\n \tif (this->sd < 0) {\n-\t\tERR(\"sockect open failed\");\n+\t\tERR(\"Ipv6 socket open failed\");\n \t\tgoto error;\n \t}\n \n@@ -48,21 +102,21 @@ struct tcp_sock_t *tcp_open(uint16_t port)\n \tmemset(&addr, 0, sizeof addr);\n \taddr.sin6_family = AF_INET6;\n \taddr.sin6_port = htons(port);\n-\taddr.sin6_addr = in6addr_any;\n+\taddr.sin6_addr = in6addr_loopback;\n \n \t// Bind to localhost\n \tif (bind(this->sd,\n \t        (struct sockaddr *)&addr,\n \t        sizeof addr) < 0) {\n \t\tif (g_options.only_desired_port == 1)\n-\t\t\tERR(\"Bind on port failed. \"\n+\t\t\tERR(\"IPv6 bind on port failed. \"\n \t\t\t    \"Requested port may be taken or require root permissions.\");\n \t\tgoto error;\n \t}\n \n \t// Let kernel over-accept max number of connections\n \tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n-\t\tERR(\"listen failed on socket\");\n+\t\tERR(\"IPv6 listen failed on socket\");\n \t\tgoto error;\n \t}\n \n@@ -179,20 +233,58 @@ void tcp_packet_send(struct tcp_conn_t *conn, struct http_packet_t *pkt)\n }\n \n \n-struct tcp_conn_t *tcp_conn_accept(struct tcp_sock_t *sock)\n+struct tcp_conn_t *tcp_conn_select(struct tcp_sock_t *sock,\n+\t\t\t\t   struct tcp_sock_t *sock6)\n {\n \tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n \tif (conn == NULL) {\n \t\tERR(\"Calloc for connection struct failed\");\n \t\tgoto error;\n \t}\n+\tfd_set rfds;\n+\tstruct timeval tv;\n+\tint retval = 0;\n+\tint nfds = 0;\n+\twhile (retval == 0) {\n+\t\tFD_ZERO(&rfds);\n+\t\tif (sock) {\n+\t\t\tFD_SET(sock->sd, &rfds);\n+\t\t\tnfds = sock->sd;\n+\t\t}\n+\t\tif (sock6) {\n+\t\t\tFD_SET(sock6->sd, &rfds);\n+\t\t\tif (sock6->sd > nfds)\n+\t\t\t\tnfds = sock6->sd;\n+\t\t}\n+\t\tif (nfds == 0) {\n+\t\t\tERR(\"No valid TCP socket supplied.\");\n+\t\t\tgoto error;\n+\t\t}\n+\t\tnfds += 1;\n+\t\t/* Wait up to five seconds. */\n+\t\ttv.tv_sec = 5;\n+\t\ttv.tv_usec = 0;\n+\t\tretval = select(nfds, &rfds, NULL, NULL, &tv);\n+\t\tif (retval == -1) {\n+\t\t\tERR(\"Failed to open tcp connection\");\n+\t\t\tgoto error;\n+\t\t}\n+\t}\n \n-\tconn->sd = accept(sock->sd, NULL, NULL);\n+\tif (sock && FD_ISSET(sock->sd, &rfds)) {\n+\t\tconn->sd = accept(sock->sd, NULL, NULL);\n+\t\tNOTE (\"Using IPv4\");\n+\t} else if (sock6 && FD_ISSET(sock6->sd, &rfds)) {\n+\t\tconn->sd = accept(sock6->sd, NULL, NULL);\n+\t\tNOTE (\"Using IPv6\");\n+\t} else {\n+\t\tERR(\"select failed\");\n+\t\tgoto error;\n+\t}\n \tif (conn->sd < 0) {\n \t\tERR(\"accept failed\");\n \t\tgoto error;\n \t}\n-\n \treturn conn;\n \n error:"
        },
        {
          "filename": "src/tcp.h",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -40,10 +40,12 @@ struct tcp_conn_t {\n };\n \n struct tcp_sock_t *tcp_open(uint16_t);\n+struct tcp_sock_t *tcp6_open(uint16_t);\n void tcp_close(struct tcp_sock_t *);\n uint16_t tcp_port_number_get(struct tcp_sock_t *);\n \n-struct tcp_conn_t *tcp_conn_accept(struct tcp_sock_t *);\n+struct tcp_conn_t *tcp_conn_select(struct tcp_sock_t *sock,\n+\t\t\t\t   struct tcp_sock_t *sock6);\n void tcp_conn_close(struct tcp_conn_t *);\n \n struct http_packet_t *tcp_packet_get(struct tcp_conn_t *,"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2852dd4a5827ca6258f19eb21c6ea5d62d0d1437",
            "date": "2017-12-05T01:05:11Z",
            "author_login": "tillkamppeter"
          },
          {
            "sha": "439cc65f102d90faad0e09cc7e0ad14a7780b3c0",
            "date": "2017-10-17T00:22:18Z",
            "author_login": "DavieV"
          },
          {
            "sha": "21dc8e4e5de23c2a6c715e67d20ce42c60a60c67",
            "date": "2017-10-06T18:22:55Z",
            "author_login": "tillkamppeter"
          },
          {
            "sha": "642bb0af1bf504a60256ff77d9819e7459a806b1",
            "date": "2017-05-23T20:44:04Z",
            "author_login": "tillkamppeter"
          },
          {
            "sha": "74166e0102319f3e0c3542a5901055db59641752",
            "date": "2017-04-26T21:49:30Z",
            "author_login": "tillkamppeter"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-264",
    "description": "IPPUSBXD before 1.22 listens on all interfaces, which allows remote attackers to obtain access to USB connected printers via a direct request.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2015-09-01T14:59:03.900",
    "last_modified": "2024-11-21T02:35:08.820",
    "fix_date": "2015-08-09T23:14:19Z"
  },
  "references": [
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/08/11/1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/08/18/11",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2725-1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://bugs.launchpad.net/ubuntu/+source/ippusbxd/+bug/1455644",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/tillkamppeter/ippusbxd/commit/46844402bca7a38fc224483ba6f0a93c4613203f",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/08/11/1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/08/18/11",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2725-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugs.launchpad.net/ubuntu/+source/ippusbxd/+bug/1455644",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/tillkamppeter/ippusbxd/commit/46844402bca7a38fc224483ba6f0a93c4613203f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:37.895330",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "ippusbxd",
    "owner": "tillkamppeter",
    "created_at": "2014-04-30T17:42:52Z",
    "updated_at": "2024-09-14T16:38:08Z",
    "pushed_at": "2017-12-05T01:05:12Z",
    "size": 464,
    "stars": 17,
    "forks": 12,
    "open_issues": 1,
    "watchers": 17,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 98862,
      "CMake": 4757,
      "Makefile": 1147
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:01:19.006366"
  }
}