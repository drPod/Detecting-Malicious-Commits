{
  "cve_id": "CVE-2015-8324",
  "github_data": {
    "repository": "torvalds/linux",
    "fix_commit": "744692dc059845b2a3022119871846e74d4f6e11",
    "related_commits": [
      "744692dc059845b2a3022119871846e74d4f6e11",
      "744692dc059845b2a3022119871846e74d4f6e11"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "744692dc059845b2a3022119871846e74d4f6e11",
      "commit_date": "2010-03-04T21:14:02Z",
      "author": {
        "login": "jiayingz",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "ext4: use ext4_get_block_write in buffer write",
        "length": 605,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 311,
        "additions": 256,
        "deletions": 55
      },
      "files": [
        {
          "filename": "fs/ext4/ext4.h",
          "status": "modified",
          "additions": 13,
          "deletions": 2,
          "patch": "@@ -138,7 +138,7 @@ typedef struct ext4_io_end {\n \tstruct list_head\tlist;\t\t/* per-file finished AIO list */\n \tstruct inode\t\t*inode;\t\t/* file being written to */\n \tunsigned int\t\tflag;\t\t/* unwritten or not */\n-\tint\t\t\terror;\t\t/* I/O error code */\n+\tstruct page\t\t*page;\t\t/* page struct for buffer write */\n \tloff_t\t\t\toffset;\t\t/* offset in the file */\n \tssize_t\t\t\tsize;\t\t/* size of the extent */\n \tstruct work_struct\twork;\t\t/* data work queue */\n@@ -361,7 +361,7 @@ struct ext4_new_group_data {\n \t\t\t\t\t EXT4_GET_BLOCKS_CREATE_UNINIT_EXT)\n \t/* Convert extent to initialized after IO complete */\n #define EXT4_GET_BLOCKS_IO_CONVERT_EXT\t\t(EXT4_GET_BLOCKS_CONVERT|\\\n-\t\t\t\t\t EXT4_GET_BLOCKS_IO_CREATE_EXT)\n+\t\t\t\t\t EXT4_GET_BLOCKS_CREATE_UNINIT_EXT)\n \n /*\n  * Flags used by ext4_free_blocks\n@@ -702,6 +702,7 @@ struct ext4_inode_info {\n \n \t/* completed IOs that might need unwritten extents handling */\n \tstruct list_head i_completed_io_list;\n+\tspinlock_t i_completed_io_lock;\n \t/* current io_end structure for async DIO write*/\n \text4_io_end_t *cur_aio_dio;\n \n@@ -752,6 +753,7 @@ struct ext4_inode_info {\n #define EXT4_MOUNT_QUOTA\t\t0x80000 /* Some quota option set */\n #define EXT4_MOUNT_USRQUOTA\t\t0x100000 /* \"old\" user quota */\n #define EXT4_MOUNT_GRPQUOTA\t\t0x200000 /* \"old\" group quota */\n+#define EXT4_MOUNT_DIOREAD_NOLOCK\t0x400000 /* Enable support for dio read nolocking */\n #define EXT4_MOUNT_JOURNAL_CHECKSUM\t0x800000 /* Journal checksums */\n #define EXT4_MOUNT_JOURNAL_ASYNC_COMMIT\t0x1000000 /* Journal Async Commit */\n #define EXT4_MOUNT_I_VERSION            0x2000000 /* i_version support */\n@@ -1781,6 +1783,15 @@ extern int ext4_move_extents(struct file *o_filp, struct file *d_filp,\n \t\t\t     __u64 len, __u64 *moved_len);\n \n \n+/* BH_Uninit flag: blocks are allocated but uninitialized on disk */\n+enum ext4_state_bits {\n+\tBH_Uninit\t/* blocks are allocated but uninitialized on disk */\n+\t  = BH_JBDPrivateStart,\n+};\n+\n+BUFFER_FNS(Uninit, uninit)\n+TAS_BUFFER_FNS(Uninit, uninit)\n+\n /*\n  * Add new method to test wether block and inode bitmaps are properly\n  * initialized. With uninit_bg reading the block from disk is not enough"
        },
        {
          "filename": "fs/ext4/ext4_jbd2.h",
          "status": "modified",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -304,4 +304,28 @@ static inline int ext4_should_writeback_data(struct inode *inode)\n \treturn 0;\n }\n \n+/*\n+ * This function controls whether or not we should try to go down the\n+ * dioread_nolock code paths, which makes it safe to avoid taking\n+ * i_mutex for direct I/O reads.  This only works for extent-based\n+ * files, and it doesn't work for nobh or if data journaling is\n+ * enabled, since the dioread_nolock code uses b_private to pass\n+ * information back to the I/O completion handler, and this conflicts\n+ * with the jbd's use of b_private.\n+ */\n+static inline int ext4_should_dioread_nolock(struct inode *inode)\n+{\n+\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n+\t\treturn 0;\n+\tif (test_opt(inode->i_sb, NOBH))\n+\t\treturn 0;\n+\tif (!S_ISREG(inode->i_mode))\n+\t\treturn 0;\n+\tif (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))\n+\t\treturn 0;\n+\tif (ext4_should_journal_data(inode))\n+\t\treturn 0;\n+\treturn 1;\n+}\n+\n #endif\t/* _EXT4_JBD2_H */"
        },
        {
          "filename": "fs/ext4/extents.c",
          "status": "modified",
          "additions": 12,
          "deletions": 10,
          "patch": "@@ -1619,7 +1619,7 @@ int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,\n \tBUG_ON(path[depth].p_hdr == NULL);\n \n \t/* try to insert block into found extent and return */\n-\tif (ex && (flag != EXT4_GET_BLOCKS_PRE_IO)\n+\tif (ex && !(flag & EXT4_GET_BLOCKS_PRE_IO)\n \t\t&& ext4_can_extents_be_merged(inode, ex, newext)) {\n \t\text_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",\n \t\t\t\text4_ext_is_uninitialized(newext),\n@@ -1740,7 +1740,7 @@ int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,\n \n merge:\n \t/* try to merge extents to the right */\n-\tif (flag != EXT4_GET_BLOCKS_PRE_IO)\n+\tif (!(flag & EXT4_GET_BLOCKS_PRE_IO))\n \t\text4_ext_try_to_merge(inode, path, nearex);\n \n \t/* try to merge extents to the left */\n@@ -3065,7 +3065,7 @@ ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode,\n \text4_ext_show_leaf(inode, path);\n \n \t/* get_block() before submit the IO, split the extent */\n-\tif (flags == EXT4_GET_BLOCKS_PRE_IO) {\n+\tif ((flags & EXT4_GET_BLOCKS_PRE_IO)) {\n \t\tret = ext4_split_unwritten_extents(handle,\n \t\t\t\t\t\tinode, path, iblock,\n \t\t\t\t\t\tmax_blocks, flags);\n@@ -3078,10 +3078,12 @@ ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode,\n \t\t\tio->flag = EXT4_IO_UNWRITTEN;\n \t\telse\n \t\t\text4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n+\t\tif (ext4_should_dioread_nolock(inode))\n+\t\t\tset_buffer_uninit(bh_result);\n \t\tgoto out;\n \t}\n \t/* IO end_io complete, convert the filled extent to written */\n-\tif (flags == EXT4_GET_BLOCKS_CONVERT) {\n+\tif ((flags & EXT4_GET_BLOCKS_CONVERT)) {\n \t\tret = ext4_convert_unwritten_extents_endio(handle, inode,\n \t\t\t\t\t\t\tpath);\n \t\tif (ret >= 0)\n@@ -3351,21 +3353,21 @@ int ext4_ext_get_blocks(handle_t *handle, struct inode *inode,\n \tif (flags & EXT4_GET_BLOCKS_UNINIT_EXT){\n \t\text4_ext_mark_uninitialized(&newex);\n \t\t/*\n-\t\t * io_end structure was created for every async\n-\t\t * direct IO write to the middle of the file.\n-\t\t * To avoid unecessary convertion for every aio dio rewrite\n-\t\t * to the mid of file, here we flag the IO that is really\n-\t\t * need the convertion.\n+\t\t * io_end structure was created for every IO write to an\n+\t\t * uninitialized extent. To avoid unecessary conversion,\n+\t\t * here we flag the IO that really needs the conversion.\n \t\t * For non asycn direct IO case, flag the inode state\n \t\t * that we need to perform convertion when IO is done.\n \t\t */\n-\t\tif (flags == EXT4_GET_BLOCKS_PRE_IO) {\n+\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO)) {\n \t\t\tif (io)\n \t\t\t\tio->flag = EXT4_IO_UNWRITTEN;\n \t\t\telse\n \t\t\t\text4_set_inode_state(inode,\n \t\t\t\t\t\t     EXT4_STATE_DIO_UNWRITTEN);\n \t\t}\n+\t\tif (ext4_should_dioread_nolock(inode))\n+\t\t\tset_buffer_uninit(bh_result);\n \t}\n \n \tif (unlikely(EXT4_I(inode)->i_flags & EXT4_EOFBLOCKS_FL)) {"
        },
        {
          "filename": "fs/ext4/inode.c",
          "status": "modified",
          "additions": 174,
          "deletions": 39,
          "patch": "@@ -38,6 +38,7 @@\n #include <linux/uio.h>\n #include <linux/bio.h>\n #include <linux/workqueue.h>\n+#include <linux/kernel.h>\n \n #include \"ext4_jbd2.h\"\n #include \"xattr.h\"\n@@ -1534,6 +1535,8 @@ static void ext4_truncate_failed_write(struct inode *inode)\n \text4_truncate(inode);\n }\n \n+static int ext4_get_block_write(struct inode *inode, sector_t iblock,\n+\t\t   struct buffer_head *bh_result, int create);\n static int ext4_write_begin(struct file *file, struct address_space *mapping,\n \t\t\t    loff_t pos, unsigned len, unsigned flags,\n \t\t\t    struct page **pagep, void **fsdata)\n@@ -1575,8 +1578,12 @@ static int ext4_write_begin(struct file *file, struct address_space *mapping,\n \t}\n \t*pagep = page;\n \n-\tret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n-\t\t\t\text4_get_block);\n+\tif (ext4_should_dioread_nolock(inode))\n+\t\tret = block_write_begin(file, mapping, pos, len, flags, pagep,\n+\t\t\t\tfsdata, ext4_get_block_write);\n+\telse\n+\t\tret = block_write_begin(file, mapping, pos, len, flags, pagep,\n+\t\t\t\tfsdata, ext4_get_block);\n \n \tif (!ret && ext4_should_journal_data(inode)) {\n \t\tret = walk_page_buffers(handle, page_buffers(page),\n@@ -2092,6 +2099,8 @@ static void mpage_put_bnr_to_bhs(struct mpage_da_data *mpd, sector_t logical,\n \t\t\t\t} else if (buffer_mapped(bh))\n \t\t\t\t\tBUG_ON(bh->b_blocknr != pblock);\n \n+\t\t\t\tif (buffer_uninit(exbh))\n+\t\t\t\t\tset_buffer_uninit(bh);\n \t\t\t\tcur_logical++;\n \t\t\t\tpblock++;\n \t\t\t} while ((bh = bh->b_this_page) != head);\n@@ -2221,6 +2230,8 @@ static int mpage_da_map_blocks(struct mpage_da_data *mpd)\n \t */\n \tnew.b_state = 0;\n \tget_blocks_flags = EXT4_GET_BLOCKS_CREATE;\n+\tif (ext4_should_dioread_nolock(mpd->inode))\n+\t\tget_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT;\n \tif (mpd->b_state & (1 << BH_Delay))\n \t\tget_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE;\n \n@@ -2636,6 +2647,9 @@ static int __ext4_journalled_writepage(struct page *page,\n \treturn ret;\n }\n \n+static int ext4_set_bh_endio(struct buffer_head *bh, struct inode *inode);\n+static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate);\n+\n /*\n  * Note that we don't need to start a transaction unless we're journaling data\n  * because we should have holes filled from ext4_page_mkwrite(). We even don't\n@@ -2683,7 +2697,7 @@ static int ext4_writepage(struct page *page,\n \tint ret = 0;\n \tloff_t size;\n \tunsigned int len;\n-\tstruct buffer_head *page_bufs;\n+\tstruct buffer_head *page_bufs = NULL;\n \tstruct inode *inode = page->mapping->host;\n \n \ttrace_ext4_writepage(inode, page);\n@@ -2759,7 +2773,11 @@ static int ext4_writepage(struct page *page,\n \n \tif (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))\n \t\tret = nobh_writepage(page, noalloc_get_block_write, wbc);\n-\telse\n+\telse if (page_bufs && buffer_uninit(page_bufs)) {\n+\t\text4_set_bh_endio(page_bufs, inode);\n+\t\tret = block_write_full_page_endio(page, noalloc_get_block_write,\n+\t\t\t\t\t    wbc, ext4_end_io_buffer_write);\n+\t} else\n \t\tret = block_write_full_page(page, noalloc_get_block_write,\n \t\t\t\t\t    wbc);\n \n@@ -3347,10 +3365,44 @@ ext4_readpages(struct file *file, struct address_space *mapping,\n \treturn mpage_readpages(mapping, pages, nr_pages, ext4_get_block);\n }\n \n+static void ext4_free_io_end(ext4_io_end_t *io)\n+{\n+\tBUG_ON(!io);\n+\tif (io->page)\n+\t\tput_page(io->page);\n+\tiput(io->inode);\n+\tkfree(io);\n+}\n+\n+static void ext4_invalidatepage_free_endio(struct page *page, unsigned long offset)\n+{\n+\tstruct buffer_head *head, *bh;\n+\tunsigned int curr_off = 0;\n+\n+\tif (!page_has_buffers(page))\n+\t\treturn;\n+\thead = bh = page_buffers(page);\n+\tdo {\n+\t\tif (offset <= curr_off && test_clear_buffer_uninit(bh)\n+\t\t\t\t\t&& bh->b_private) {\n+\t\t\text4_free_io_end(bh->b_private);\n+\t\t\tbh->b_private = NULL;\n+\t\t\tbh->b_end_io = NULL;\n+\t\t}\n+\t\tcurr_off = curr_off + bh->b_size;\n+\t\tbh = bh->b_this_page;\n+\t} while (bh != head);\n+}\n+\n static void ext4_invalidatepage(struct page *page, unsigned long offset)\n {\n \tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n \n+\t/*\n+\t * free any io_end structure allocated for buffers to be discarded\n+\t */\n+\tif (ext4_should_dioread_nolock(page->mapping->host))\n+\t\text4_invalidatepage_free_endio(page, offset);\n \t/*\n \t * If it's a full truncate we just forget about the pending dirtying\n \t */\n@@ -3471,10 +3523,11 @@ static ssize_t ext4_ind_direct_IO(int rw, struct kiocb *iocb,\n static int ext4_get_block_write(struct inode *inode, sector_t iblock,\n \t\t   struct buffer_head *bh_result, int create)\n {\n-\thandle_t *handle = NULL;\n+\thandle_t *handle = ext4_journal_current_handle();\n \tint ret = 0;\n \tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n \tint dio_credits;\n+\tint started = 0;\n \n \text4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",\n \t\t   inode->i_ino, create);\n@@ -3485,44 +3538,44 @@ static int ext4_get_block_write(struct inode *inode, sector_t iblock,\n \t */\n \tcreate = EXT4_GET_BLOCKS_IO_CREATE_EXT;\n \n-\tif (max_blocks > DIO_MAX_BLOCKS)\n-\t\tmax_blocks = DIO_MAX_BLOCKS;\n-\tdio_credits = ext4_chunk_trans_blocks(inode, max_blocks);\n-\thandle = ext4_journal_start(inode, dio_credits);\n-\tif (IS_ERR(handle)) {\n-\t\tret = PTR_ERR(handle);\n-\t\tgoto out;\n+\tif (!handle) {\n+\t\tif (max_blocks > DIO_MAX_BLOCKS)\n+\t\t\tmax_blocks = DIO_MAX_BLOCKS;\n+\t\tdio_credits = ext4_chunk_trans_blocks(inode, max_blocks);\n+\t\thandle = ext4_journal_start(inode, dio_credits);\n+\t\tif (IS_ERR(handle)) {\n+\t\t\tret = PTR_ERR(handle);\n+\t\t\tgoto out;\n+\t\t}\n+\t\tstarted = 1;\n \t}\n+\n \tret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,\n \t\t\t      create);\n \tif (ret > 0) {\n \t\tbh_result->b_size = (ret << inode->i_blkbits);\n \t\tret = 0;\n \t}\n-\text4_journal_stop(handle);\n+\tif (started)\n+\t\text4_journal_stop(handle);\n out:\n \treturn ret;\n }\n \n-static void ext4_free_io_end(ext4_io_end_t *io)\n-{\n-\tBUG_ON(!io);\n-\tiput(io->inode);\n-\tkfree(io);\n-}\n-\n static void dump_completed_IO(struct inode * inode)\n {\n #ifdef\tEXT4_DEBUG\n \tstruct list_head *cur, *before, *after;\n \text4_io_end_t *io, *io0, *io1;\n+\tunsigned long flags;\n \n \tif (list_empty(&EXT4_I(inode)->i_completed_io_list)){\n \t\text4_debug(\"inode %lu completed_io list is empty\\n\", inode->i_ino);\n \t\treturn;\n \t}\n \n \text4_debug(\"Dump inode %lu completed_io list \\n\", inode->i_ino);\n+\tspin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);\n \tlist_for_each_entry(io, &EXT4_I(inode)->i_completed_io_list, list){\n \t\tcur = &io->list;\n \t\tbefore = cur->prev;\n@@ -3533,6 +3586,7 @@ static void dump_completed_IO(struct inode * inode)\n \t\text4_debug(\"io 0x%p from inode %lu,prev 0x%p,next 0x%p\\n\",\n \t\t\t    io, inode->i_ino, io0, io1);\n \t}\n+\tspin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);\n #endif\n }\n \n@@ -3556,9 +3610,7 @@ static int ext4_end_io_nolock(ext4_io_end_t *io)\n \tif (io->flag != EXT4_IO_UNWRITTEN)\n \t\treturn ret;\n \n-\tif (offset + size <= i_size_read(inode))\n-\t\tret = ext4_convert_unwritten_extents(inode, offset, size);\n-\n+\tret = ext4_convert_unwritten_extents(inode, offset, size);\n \tif (ret < 0) {\n \t\tprintk(KERN_EMERG \"%s: failed to convert unwritten\"\n \t\t\t\"extents to written extents, error is %d\"\n@@ -3577,18 +3629,25 @@ static int ext4_end_io_nolock(ext4_io_end_t *io)\n  */\n static void ext4_end_io_work(struct work_struct *work)\n {\n-\text4_io_end_t *io  = container_of(work, ext4_io_end_t, work);\n-\tstruct inode *inode = io->inode;\n-\tint ret = 0;\n+\text4_io_end_t\t\t*io = container_of(work, ext4_io_end_t, work);\n+\tstruct inode\t\t*inode = io->inode;\n+\tstruct ext4_inode_info\t*ei = EXT4_I(inode);\n+\tunsigned long\t\tflags;\n+\tint\t\t\tret;\n \n \tmutex_lock(&inode->i_mutex);\n \tret = ext4_end_io_nolock(io);\n-\tif (ret >= 0) {\n-\t\tif (!list_empty(&io->list))\n-\t\t\tlist_del_init(&io->list);\n-\t\text4_free_io_end(io);\n+\tif (ret < 0) {\n+\t\tmutex_unlock(&inode->i_mutex);\n+\t\treturn;\n \t}\n+\n+\tspin_lock_irqsave(&ei->i_completed_io_lock, flags);\n+\tif (!list_empty(&io->list))\n+\t\tlist_del_init(&io->list);\n+\tspin_unlock_irqrestore(&ei->i_completed_io_lock, flags);\n \tmutex_unlock(&inode->i_mutex);\n+\text4_free_io_end(io);\n }\n \n /*\n@@ -3607,15 +3666,18 @@ static void ext4_end_io_work(struct work_struct *work)\n int flush_completed_IO(struct inode *inode)\n {\n \text4_io_end_t *io;\n+\tstruct ext4_inode_info *ei = EXT4_I(inode);\n+\tunsigned long flags;\n \tint ret = 0;\n \tint ret2 = 0;\n \n-\tif (list_empty(&EXT4_I(inode)->i_completed_io_list))\n+\tif (list_empty(&ei->i_completed_io_list))\n \t\treturn ret;\n \n \tdump_completed_IO(inode);\n-\twhile (!list_empty(&EXT4_I(inode)->i_completed_io_list)){\n-\t\tio = list_entry(EXT4_I(inode)->i_completed_io_list.next,\n+\tspin_lock_irqsave(&ei->i_completed_io_lock, flags);\n+\twhile (!list_empty(&ei->i_completed_io_list)){\n+\t\tio = list_entry(ei->i_completed_io_list.next,\n \t\t\t\text4_io_end_t, list);\n \t\t/*\n \t\t * Calling ext4_end_io_nolock() to convert completed\n@@ -3631,28 +3693,31 @@ int flush_completed_IO(struct inode *inode)\n \t\t * avoid double converting from both fsync and background work\n \t\t * queue work.\n \t\t */\n+\t\tspin_unlock_irqrestore(&ei->i_completed_io_lock, flags);\n \t\tret = ext4_end_io_nolock(io);\n+\t\tspin_lock_irqsave(&ei->i_completed_io_lock, flags);\n \t\tif (ret < 0)\n \t\t\tret2 = ret;\n \t\telse\n \t\t\tlist_del_init(&io->list);\n \t}\n+\tspin_unlock_irqrestore(&ei->i_completed_io_lock, flags);\n \treturn (ret2 < 0) ? ret2 : 0;\n }\n \n-static ext4_io_end_t *ext4_init_io_end (struct inode *inode)\n+static ext4_io_end_t *ext4_init_io_end (struct inode *inode, gfp_t flags)\n {\n \text4_io_end_t *io = NULL;\n \n-\tio = kmalloc(sizeof(*io), GFP_NOFS);\n+\tio = kmalloc(sizeof(*io), flags);\n \n \tif (io) {\n \t\tigrab(inode);\n \t\tio->inode = inode;\n \t\tio->flag = 0;\n \t\tio->offset = 0;\n \t\tio->size = 0;\n-\t\tio->error = 0;\n+\t\tio->page = NULL;\n \t\tINIT_WORK(&io->work, ext4_end_io_work);\n \t\tINIT_LIST_HEAD(&io->list);\n \t}\n@@ -3665,6 +3730,8 @@ static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,\n {\n         ext4_io_end_t *io_end = iocb->private;\n \tstruct workqueue_struct *wq;\n+\tunsigned long flags;\n+\tstruct ext4_inode_info *ei;\n \n \t/* if not async direct IO or dio with 0 bytes write, just return */\n \tif (!io_end || !size)\n@@ -3684,17 +3751,85 @@ static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,\n \n \tio_end->offset = offset;\n \tio_end->size = size;\n+\tio_end->flag = EXT4_IO_UNWRITTEN;\n \twq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;\n \n \t/* queue the work to convert unwritten extents to written */\n \tqueue_work(wq, &io_end->work);\n \n \t/* Add the io_end to per-inode completed aio dio list*/\n-\tlist_add_tail(&io_end->list,\n-\t\t &EXT4_I(io_end->inode)->i_completed_io_list);\n+\tei = EXT4_I(io_end->inode);\n+\tspin_lock_irqsave(&ei->i_completed_io_lock, flags);\n+\tlist_add_tail(&io_end->list, &ei->i_completed_io_list);\n+\tspin_unlock_irqrestore(&ei->i_completed_io_lock, flags);\n \tiocb->private = NULL;\n }\n \n+static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate)\n+{\n+\text4_io_end_t *io_end = bh->b_private;\n+\tstruct workqueue_struct *wq;\n+\tstruct inode *inode;\n+\tunsigned long flags;\n+\n+\tif (!test_clear_buffer_uninit(bh) || !io_end)\n+\t\tgoto out;\n+\n+\tif (!(io_end->inode->i_sb->s_flags & MS_ACTIVE)) {\n+\t\tprintk(\"sb umounted, discard end_io request for inode %lu\\n\",\n+\t\t\tio_end->inode->i_ino);\n+\t\text4_free_io_end(io_end);\n+\t\tgoto out;\n+\t}\n+\n+\tio_end->flag = EXT4_IO_UNWRITTEN;\n+\tinode = io_end->inode;\n+\n+\t/* Add the io_end to per-inode completed io list*/\n+\tspin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);\n+\tlist_add_tail(&io_end->list, &EXT4_I(inode)->i_completed_io_list);\n+\tspin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);\n+\n+\twq = EXT4_SB(inode->i_sb)->dio_unwritten_wq;\n+\t/* queue the work to convert unwritten extents to written */\n+\tqueue_work(wq, &io_end->work);\n+out:\n+\tbh->b_private = NULL;\n+\tbh->b_end_io = NULL;\n+\tclear_buffer_uninit(bh);\n+\tend_buffer_async_write(bh, uptodate);\n+}\n+\n+static int ext4_set_bh_endio(struct buffer_head *bh, struct inode *inode)\n+{\n+\text4_io_end_t *io_end;\n+\tstruct page *page = bh->b_page;\n+\tloff_t offset = (sector_t)page->index << PAGE_CACHE_SHIFT;\n+\tsize_t size = bh->b_size;\n+\n+retry:\n+\tio_end = ext4_init_io_end(inode, GFP_ATOMIC);\n+\tif (!io_end) {\n+\t\tif (printk_ratelimit())\n+\t\t\tprintk(KERN_WARNING \"%s: allocation fail\\n\", __func__);\n+\t\tschedule();\n+\t\tgoto retry;\n+\t}\n+\tio_end->offset = offset;\n+\tio_end->size = size;\n+\t/*\n+\t * We need to hold a reference to the page to make sure it\n+\t * doesn't get evicted before ext4_end_io_work() has a chance\n+\t * to convert the extent from written to unwritten.\n+\t */\n+\tio_end->page = page;\n+\tget_page(io_end->page);\n+\n+\tbh->b_private = io_end;\n+\tbh->b_end_io = ext4_end_io_buffer_write;\n+\treturn 0;\n+}\n+\n /*\n  * For ext4 extent files, ext4 will do direct-io write to holes,\n  * preallocated extents, and those write extend the file, no need to\n@@ -3748,7 +3883,7 @@ static ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,\n \t\tiocb->private = NULL;\n \t\tEXT4_I(inode)->cur_aio_dio = NULL;\n \t\tif (!is_sync_kiocb(iocb)) {\n-\t\t\tiocb->private = ext4_init_io_end(inode);\n+\t\t\tiocb->private = ext4_init_io_end(inode, GFP_NOFS);\n \t\t\tif (!iocb->private)\n \t\t\t\treturn -ENOMEM;\n \t\t\t/*"
        },
        {
          "filename": "fs/ext4/super.c",
          "status": "modified",
          "additions": 33,
          "deletions": 4,
          "patch": "@@ -709,6 +709,7 @@ static struct inode *ext4_alloc_inode(struct super_block *sb)\n \tei->i_reserved_quota = 0;\n #endif\n \tINIT_LIST_HEAD(&ei->i_completed_io_list);\n+\tspin_lock_init(&ei->i_completed_io_lock);\n \tei->cur_aio_dio = NULL;\n \tei->i_sync_tid = 0;\n \tei->i_datasync_tid = 0;\n@@ -926,6 +927,9 @@ static int ext4_show_options(struct seq_file *seq, struct vfsmount *vfs)\n \tif (test_opt(sb, NOLOAD))\n \t\tseq_puts(seq, \",norecovery\");\n \n+\tif (test_opt(sb, DIOREAD_NOLOCK))\n+\t\tseq_puts(seq, \",dioread_nolock\");\n+\n \text4_show_quota_options(seq, sb);\n \n \treturn 0;\n@@ -1109,6 +1113,7 @@ enum {\n \tOpt_stripe, Opt_delalloc, Opt_nodelalloc,\n \tOpt_block_validity, Opt_noblock_validity,\n \tOpt_inode_readahead_blks, Opt_journal_ioprio,\n+\tOpt_dioread_nolock, Opt_dioread_lock,\n \tOpt_discard, Opt_nodiscard,\n };\n \n@@ -1176,6 +1181,8 @@ static const match_table_t tokens = {\n \t{Opt_auto_da_alloc, \"auto_da_alloc=%u\"},\n \t{Opt_auto_da_alloc, \"auto_da_alloc\"},\n \t{Opt_noauto_da_alloc, \"noauto_da_alloc\"},\n+\t{Opt_dioread_nolock, \"dioread_nolock\"},\n+\t{Opt_dioread_lock, \"dioread_lock\"},\n \t{Opt_discard, \"discard\"},\n \t{Opt_nodiscard, \"nodiscard\"},\n \t{Opt_err, NULL},\n@@ -1640,6 +1647,12 @@ static int parse_options(char *options, struct super_block *sb,\n \t\tcase Opt_nodiscard:\n \t\t\tclear_opt(sbi->s_mount_opt, DISCARD);\n \t\t\tbreak;\n+\t\tcase Opt_dioread_nolock:\n+\t\t\tset_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);\n+\t\t\tbreak;\n+\t\tcase Opt_dioread_lock:\n+\t\t\tclear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);\n+\t\t\tbreak;\n \t\tdefault:\n \t\t\text4_msg(sb, KERN_ERR,\n \t\t\t       \"Unrecognized mount option \\\"%s\\\" \"\n@@ -2795,7 +2808,7 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n \t      EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n \t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n \t\t       \"suppressed and not mounted read-only\");\n-\t\tgoto failed_mount4;\n+\t\tgoto failed_mount_wq;\n \t} else {\n \t\tclear_opt(sbi->s_mount_opt, DATA_FLAGS);\n \t\tset_opt(sbi->s_mount_opt, WRITEBACK_DATA);\n@@ -2808,7 +2821,7 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n \t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n \t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n \t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n-\t\tgoto failed_mount4;\n+\t\tgoto failed_mount_wq;\n \t}\n \n \tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n@@ -2847,21 +2860,25 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n \t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n \t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n \t\t\t       \"requested data journaling mode\");\n-\t\t\tgoto failed_mount4;\n+\t\t\tgoto failed_mount_wq;\n \t\t}\n \tdefault:\n \t\tbreak;\n \t}\n \tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n \n no_journal:\n-\n \tif (test_opt(sb, NOBH)) {\n \t\tif (!(test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)) {\n \t\t\text4_msg(sb, KERN_WARNING, \"Ignoring nobh option - \"\n \t\t\t\t\"its supported only with writeback mode\");\n \t\t\tclear_opt(sbi->s_mount_opt, NOBH);\n \t\t}\n+\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n+\t\t\text4_msg(sb, KERN_WARNING, \"dioread_nolock option is \"\n+\t\t\t\t\"not supported with nobh mode\");\n+\t\t\tgoto failed_mount_wq;\n+\t\t}\n \t}\n \tEXT4_SB(sb)->dio_unwritten_wq = create_workqueue(\"ext4-dio-unwritten\");\n \tif (!EXT4_SB(sb)->dio_unwritten_wq) {\n@@ -2926,6 +2943,18 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n \t\t\t \"requested data journaling mode\");\n \t\tclear_opt(sbi->s_mount_opt, DELALLOC);\n \t}\n+\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n+\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n+\t\t\text4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"\n+\t\t\t\t\"option - requested data journaling mode\");\n+\t\t\tclear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);\n+\t\t}\n+\t\tif (sb->s_blocksize < PAGE_SIZE) {\n+\t\t\text4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"\n+\t\t\t\t\"option - block size is too small\");\n+\t\t\tclear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);\n+\t\t}\n+\t}\n \n \terr = ext4_setup_system_zone(sb);\n \tif (err) {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "aa22f4da2a46b484a257d167c67a2adc1b7aaf68",
            "date": "2025-01-26T00:23:38Z",
            "author_login": "torvalds"
          },
          {
            "sha": "eda061cccd146fcbe71051bb4aa5a8672b71216e",
            "date": "2025-01-26T00:19:10Z",
            "author_login": "torvalds"
          },
          {
            "sha": "08de7f9d4d39fd9aa5e747a13acc891214fa2d5f",
            "date": "2025-01-26T00:12:07Z",
            "author_login": "torvalds"
          },
          {
            "sha": "647d69605c70368d54fc012fce8a43e8e5955b04",
            "date": "2025-01-26T00:03:40Z",
            "author_login": "torvalds"
          },
          {
            "sha": "184a0997fb77f4a9527fc867fcd16806776c27ce",
            "date": "2025-01-25T23:59:46Z",
            "author_login": "torvalds"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": null,
    "description": "The ext4 implementation in the Linux kernel before 2.6.34 does not properly track the initialization of certain data structures, which allows physically proximate attackers to cause a denial of service (NULL pointer dereference and panic) via a crafted USB device, related to the ext4_fill_super function.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2016-05-02T10:59:18.577",
    "last_modified": "2024-11-21T02:38:17.900",
    "fix_date": "2010-03-04T21:14:02Z"
  },
  "references": [
    {
      "url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=744692dc059845b2a3022119871846e74d4f6e11",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://mirror.linux.org.au/linux/kernel/v2.6/ChangeLog-2.6.34",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-0855.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/11/23/2",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinapr2016-2952096.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1267261",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=744692dc059845b2a3022119871846e74d4f6e11",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://mirror.linux.org.au/linux/kernel/v2.6/ChangeLog-2.6.34",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-0855.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2015/11/23/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinapr2016-2952096.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1267261",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:42.539599",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "linux",
    "owner": "torvalds",
    "created_at": "2011-09-04T22:48:12Z",
    "updated_at": "2025-01-26T06:54:23Z",
    "pushed_at": "2025-01-26T01:00:03Z",
    "size": 5386838,
    "stars": 186472,
    "forks": 54875,
    "open_issues": 441,
    "watchers": 186472,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1331921668,
      "Assembly": 9611819,
      "Shell": 5108035,
      "Python": 2992085,
      "Makefile": 2706967,
      "Perl": 1253833,
      "Rust": 816450,
      "Roff": 202277,
      "C++": 173994,
      "SmPL": 165946,
      "Yacc": 127472,
      "Lex": 71397,
      "Awk": 69555,
      "Jinja": 30138,
      "UnrealScript": 16848,
      "Gherkin": 10902,
      "M4": 3329,
      "MATLAB": 2482,
      "Clojure": 2442,
      "sed": 2433,
      "XS": 1239,
      "RPC": 962
    },
    "commit_activity": {
      "total_commits_last_year": 48379,
      "avg_commits_per_week": 930.3653846153846,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T07:34:00.817711"
  }
}