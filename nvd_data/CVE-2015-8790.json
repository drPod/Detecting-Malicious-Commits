{
  "cve_id": "CVE-2015-8790",
  "github_data": {
    "repository": "Matroska-Org/libebml",
    "fix_commit": "ababb64e0c792ad2a314245233db0833ba12036b",
    "related_commits": [
      "ababb64e0c792ad2a314245233db0833ba12036b",
      "ababb64e0c792ad2a314245233db0833ba12036b"
    ],
    "patch_url": "https://github.com/Matroska-Org/libebml/commit/ababb64e0c792ad2a314245233db0833ba12036b.patch",
    "fix_commit_details": {
      "sha": "ababb64e0c792ad2a314245233db0833ba12036b",
      "commit_date": "2015-10-20T09:27:52Z",
      "author": {
        "login": "mbunkus",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "EbmlUnicodeString: don't read beyond end of string",
        "length": 333,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 70,
        "additions": 47,
        "deletions": 23
      },
      "files": [
        {
          "filename": "ChangeLog",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -1,3 +1,12 @@\n+2015-10-20  Moritz Bunkus  <moritz@bunkus.org>\n+\n+        * EbmlUnicodeString::UpdateFromUTF8(): Fixed an invalid memory\n+        access. When reading from a UTF-8 string in which the length\n+        indicated by a UTF-8 character's first byte exceeds the string's\n+        actual number of bytes the parser would access beyond the end of\n+        the string resulting in a heap information leak. Fixes the issue\n+        reported as Cisco TALOS-CAN-0036.\n+\n 2015-10-17  Moritz Bunkus  <moritz@bunkus.org>\n \n         * Released v1.3.2."
        },
        {
          "filename": "src/EbmlUnicodeString.cpp",
          "status": "modified",
          "additions": 38,
          "deletions": 23,
          "patch": "@@ -47,6 +47,21 @@ START_LIBEBML_NAMESPACE\n \n // ===================== UTFstring class ===================\n \n+static unsigned int UTFCharLength(uint8 lead)\n+{\n+  if (lead < 0x80)\n+    return 1;\n+  else if ((lead >> 5) == 0x6)\n+    return 2;\n+  else if ((lead >> 4) == 0xe)\n+    return 3;\n+  else if ((lead >> 3) == 0x1e)\n+    return 4;\n+  else\n+    // Invalid size?\n+    return 0;\n+}\n+\n UTFstring::UTFstring()\n   :_Length(0)\n   ,_Data(NULL)\n@@ -143,39 +158,39 @@ void UTFstring::UpdateFromUTF8()\n   delete [] _Data;\n   // find the size of the final UCS-2 string\n   size_t i;\n-  for (_Length=0, i=0; i<UTF8string.length(); _Length++) {\n-    uint8 lead = static_cast<uint8>(UTF8string[i]);\n-    if (lead < 0x80)\n-      i++;\n-    else if ((lead >> 5) == 0x6)\n-      i += 2;\n-    else if ((lead >> 4) == 0xe)\n-      i += 3;\n-    else if ((lead >> 3) == 0x1e)\n-      i += 4;\n+  const size_t SrcLength = UTF8string.length();\n+  for (_Length=0, i=0; i<SrcLength; _Length++) {\n+    const unsigned int CharLength = UTFCharLength(static_cast<uint8>(UTF8string[i]));\n+    if ((CharLength >= 1) && (CharLength <= 4))\n+      i += CharLength;\n     else\n       // Invalid size?\n       break;\n   }\n   _Data = new wchar_t[_Length+1];\n   size_t j;\n-  for (j=0, i=0; i<UTF8string.length(); j++) {\n-    uint8 lead = static_cast<uint8>(UTF8string[i]);\n-    if (lead < 0x80) {\n+  for (j=0, i=0; i<SrcLength; j++) {\n+    const uint8 lead              = static_cast<uint8>(UTF8string[i]);\n+    const unsigned int CharLength = UTFCharLength(lead);\n+    if ((CharLength < 1) || (CharLength > 4))\n+      // Invalid char?\n+      break;\n+\n+    if ((i + CharLength) > SrcLength)\n+      // Guard against invalid memory access beyond the end of the\n+      // source buffer.\n+      break;\n+\n+    if (CharLength == 1)\n       _Data[j] = lead;\n-      i++;\n-    } else if ((lead >> 5) == 0x6) {\n+    else if (CharLength == 2)\n       _Data[j] = ((lead & 0x1F) << 6) + (UTF8string[i+1] & 0x3F);\n-      i += 2;\n-    } else if ((lead >> 4) == 0xe) {\n+    else if (CharLength == 3)\n       _Data[j] = ((lead & 0x0F) << 12) + ((UTF8string[i+1] & 0x3F) << 6) + (UTF8string[i+2] & 0x3F);\n-      i += 3;\n-    } else if ((lead >> 3) == 0x1e) {\n+    else if (CharLength == 4)\n       _Data[j] = ((lead & 0x07) << 18) + ((UTF8string[i+1] & 0x3F) << 12) + ((UTF8string[i+2] & 0x3F) << 6) + (UTF8string[i+3] & 0x3F);\n-      i += 4;\n-    } else\n-      // Invalid char?\n-      break;\n+\n+    i += CharLength;\n   }\n   _Data[j] = 0;\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "0327ea6815cf139d3e227316b82f79eb75f3ffa3",
            "date": "2025-01-05T12:28:24Z",
            "author_login": "robUx4"
          },
          {
            "sha": "797bb178fae763248eef78c60918e89edce98b46",
            "date": "2025-01-05T12:25:12Z",
            "author_login": "robUx4"
          },
          {
            "sha": "8caf7914ddb5e60cf0a1154b28164399ac5b40ac",
            "date": "2025-01-05T12:23:09Z",
            "author_login": "robUx4"
          },
          {
            "sha": "802880aa768facba75b6ebf66da70afa724d3cb4",
            "date": "2025-01-05T12:21:31Z",
            "author_login": "robUx4"
          },
          {
            "sha": "6efb11c2de4b39150ff654c39ed351e3e516b1e8",
            "date": "2025-01-01T12:48:47Z",
            "author_login": "robUx4"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-200",
    "description": "The EbmlUnicodeString::UpdateFromUTF8 function in libEBML before 1.3.3 allows context-dependent attackers to obtain sensitive information from process heap memory via a crafted UTF-8 string, which triggers an invalid memory access.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2016-01-29T19:59:02.157",
    "last_modified": "2024-11-21T02:39:12.177",
    "fix_date": "2015-10-20T09:27:52Z"
  },
  "references": [
    {
      "url": "http://lists.matroska.org/pipermail/matroska-users/2015-October/006985.html",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2016-01/msg00035.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2016/dsa-3538",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/85307",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/95124",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.talosintelligence.com/reports/TALOS-2016-0036/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/Matroska-Org/libebml/blob/release-1.3.3/ChangeLog",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/Matroska-Org/libebml/commit/ababb64e0c792ad2a314245233db0833ba12036b",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://lists.matroska.org/pipermail/matroska-users/2015-October/006985.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2016-01/msg00035.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2016/dsa-3538",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/85307",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/95124",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.talosintelligence.com/reports/TALOS-2016-0036/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/Matroska-Org/libebml/blob/release-1.3.3/ChangeLog",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/Matroska-Org/libebml/commit/ababb64e0c792ad2a314245233db0833ba12036b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:40.200623",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "libebml",
    "owner": "Matroska-Org",
    "created_at": "2013-01-02T12:55:31Z",
    "updated_at": "2025-01-05T12:43:49Z",
    "pushed_at": "2025-01-05T12:43:45Z",
    "size": 1269,
    "stars": 143,
    "forks": 47,
    "open_issues": 36,
    "watchers": 143,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "C++": 226541,
      "CMake": 6534,
      "C": 1825
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-2.1"
    },
    "collected_at": "2025-01-14T14:22:56.445946"
  }
}