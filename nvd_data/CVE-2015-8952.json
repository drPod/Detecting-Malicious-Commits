{
  "cve_id": "CVE-2015-8952",
  "github_data": {
    "repository": "torvalds/linux",
    "fix_commit": "82939d7999dfc1f1998c4b1c12e2f19edbdff272",
    "related_commits": [
      "82939d7999dfc1f1998c4b1c12e2f19edbdff272",
      "be0726d33cb8f411945884664924bed3cb8c70ee",
      "f9a61eb4e2471c56a63cd804c7474128138c38ac",
      "82939d7999dfc1f1998c4b1c12e2f19edbdff272",
      "be0726d33cb8f411945884664924bed3cb8c70ee",
      "f9a61eb4e2471c56a63cd804c7474128138c38ac"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "82939d7999dfc1f1998c4b1c12e2f19edbdff272",
      "commit_date": "2016-02-22T16:50:13Z",
      "author": {
        "login": "jankara",
        "type": "User",
        "stats": {
          "total_commits": 2059,
          "average_weekly_commits": 1.72879932829555,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 548
        }
      },
      "commit_message": {
        "title": "ext4: convert to mbcache2",
        "length": 370,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 150,
        "additions": 75,
        "deletions": 75
      },
      "files": [
        {
          "filename": "fs/ext4/ext4.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1468,7 +1468,7 @@ struct ext4_sb_info {\n \tstruct list_head s_es_list;\t/* List of inodes with reclaimable extents */\n \tlong s_es_nr_inode;\n \tstruct ext4_es_stats s_es_stats;\n-\tstruct mb_cache *s_mb_cache;\n+\tstruct mb2_cache *s_mb_cache;\n \tspinlock_t s_es_lock ____cacheline_aligned_in_smp;\n \n \t/* Ratelimit ext4 messages. */"
        },
        {
          "filename": "fs/ext4/super.c",
          "status": "modified",
          "additions": 5,
          "deletions": 2,
          "patch": "@@ -844,7 +844,6 @@ static void ext4_put_super(struct super_block *sb)\n \text4_release_system_zone(sb);\n \text4_mb_release(sb);\n \text4_ext_release(sb);\n-\text4_xattr_put_super(sb);\n \n \tif (!(sb->s_flags & MS_RDONLY)) {\n \t\text4_clear_feature_journal_needs_recovery(sb);\n@@ -3797,7 +3796,7 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n \n no_journal:\n \tif (ext4_mballoc_ready) {\n-\t\tsbi->s_mb_cache = ext4_xattr_create_cache(sb->s_id);\n+\t\tsbi->s_mb_cache = ext4_xattr_create_cache();\n \t\tif (!sbi->s_mb_cache) {\n \t\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n \t\t\tgoto failed_mount_wq;\n@@ -4027,6 +4026,10 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n \tif (EXT4_SB(sb)->rsv_conversion_wq)\n \t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\n failed_mount_wq:\n+\tif (sbi->s_mb_cache) {\n+\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n+\t\tsbi->s_mb_cache = NULL;\n+\t}\n \tif (sbi->s_journal) {\n \t\tjbd2_journal_destroy(sbi->s_journal);\n \t\tsbi->s_journal = NULL;"
        },
        {
          "filename": "fs/ext4/xattr.c",
          "status": "modified",
          "additions": 67,
          "deletions": 69,
          "patch": "@@ -53,7 +53,7 @@\n #include <linux/init.h>\n #include <linux/fs.h>\n #include <linux/slab.h>\n-#include <linux/mbcache.h>\n+#include <linux/mbcache2.h>\n #include <linux/quotaops.h>\n #include \"ext4_jbd2.h\"\n #include \"ext4.h\"\n@@ -78,10 +78,10 @@\n # define ea_bdebug(bh, fmt, ...)\tno_printk(fmt, ##__VA_ARGS__)\n #endif\n \n-static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\n+static void ext4_xattr_cache_insert(struct mb2_cache *, struct buffer_head *);\n static struct buffer_head *ext4_xattr_cache_find(struct inode *,\n \t\t\t\t\t\t struct ext4_xattr_header *,\n-\t\t\t\t\t\t struct mb_cache_entry **);\n+\t\t\t\t\t\t struct mb2_cache_entry **);\n static void ext4_xattr_rehash(struct ext4_xattr_header *,\n \t\t\t      struct ext4_xattr_entry *);\n static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n@@ -276,7 +276,7 @@ ext4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n \tstruct ext4_xattr_entry *entry;\n \tsize_t size;\n \tint error;\n-\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n+\tstruct mb2_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n \n \tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n \t\t  name_index, name, buffer, (long)buffer_size);\n@@ -428,7 +428,7 @@ ext4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n \tstruct inode *inode = d_inode(dentry);\n \tstruct buffer_head *bh = NULL;\n \tint error;\n-\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n+\tstruct mb2_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n \n \tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n \t\t  buffer, (long)buffer_size);\n@@ -545,30 +545,31 @@ static void\n ext4_xattr_release_block(handle_t *handle, struct inode *inode,\n \t\t\t struct buffer_head *bh)\n {\n-\tstruct mb_cache_entry *ce = NULL;\n \tint error = 0;\n-\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n \n-\tce = mb_cache_entry_get(ext4_mb_cache, bh->b_bdev, bh->b_blocknr);\n \tBUFFER_TRACE(bh, \"get_write_access\");\n \terror = ext4_journal_get_write_access(handle, bh);\n \tif (error)\n \t\tgoto out;\n \n \tlock_buffer(bh);\n \tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n+\t\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n+\n \t\tea_bdebug(bh, \"refcount now=0; freeing\");\n-\t\tif (ce)\n-\t\t\tmb_cache_entry_free(ce);\n+\t\t/*\n+\t\t * This must happen under buffer lock for\n+\t\t * ext4_xattr_block_set() to reliably detect freed block\n+\t\t */\n+\t\tmb2_cache_entry_delete_block(EXT4_GET_MB_CACHE(inode), hash,\n+\t\t\t\t\t     bh->b_blocknr);\n \t\tget_bh(bh);\n \t\tunlock_buffer(bh);\n \t\text4_free_blocks(handle, inode, bh, 0, 1,\n \t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n \t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n \t} else {\n \t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n-\t\tif (ce)\n-\t\t\tmb_cache_entry_release(ce);\n \t\t/*\n \t\t * Beware of this ugliness: Releasing of xattr block references\n \t\t * from different inodes can race and so we have to protect\n@@ -781,28 +782,31 @@ ext4_xattr_block_set(handle_t *handle, struct inode *inode,\n \tstruct super_block *sb = inode->i_sb;\n \tstruct buffer_head *new_bh = NULL;\n \tstruct ext4_xattr_search *s = &bs->s;\n-\tstruct mb_cache_entry *ce = NULL;\n+\tstruct mb2_cache_entry *ce = NULL;\n \tint error = 0;\n-\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n+\tstruct mb2_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n \n #define header(x) ((struct ext4_xattr_header *)(x))\n \n \tif (i->value && i->value_len > sb->s_blocksize)\n \t\treturn -ENOSPC;\n \tif (s->base) {\n-\t\tce = mb_cache_entry_get(ext4_mb_cache, bs->bh->b_bdev,\n-\t\t\t\t\tbs->bh->b_blocknr);\n \t\tBUFFER_TRACE(bs->bh, \"get_write_access\");\n \t\terror = ext4_journal_get_write_access(handle, bs->bh);\n \t\tif (error)\n \t\t\tgoto cleanup;\n \t\tlock_buffer(bs->bh);\n \n \t\tif (header(s->base)->h_refcount == cpu_to_le32(1)) {\n-\t\t\tif (ce) {\n-\t\t\t\tmb_cache_entry_free(ce);\n-\t\t\t\tce = NULL;\n-\t\t\t}\n+\t\t\t__u32 hash = le32_to_cpu(BHDR(bs->bh)->h_hash);\n+\n+\t\t\t/*\n+\t\t\t * This must happen under buffer lock for\n+\t\t\t * ext4_xattr_block_set() to reliably detect modified\n+\t\t\t * block\n+\t\t\t */\n+\t\t\tmb2_cache_entry_delete_block(ext4_mb_cache, hash,\n+\t\t\t\t\t\t     bs->bh->b_blocknr);\n \t\t\tea_bdebug(bs->bh, \"modifying in-place\");\n \t\t\terror = ext4_xattr_set_entry(i, s);\n \t\t\tif (!error) {\n@@ -826,10 +830,6 @@ ext4_xattr_block_set(handle_t *handle, struct inode *inode,\n \t\t\tint offset = (char *)s->here - bs->bh->b_data;\n \n \t\t\tunlock_buffer(bs->bh);\n-\t\t\tif (ce) {\n-\t\t\t\tmb_cache_entry_release(ce);\n-\t\t\t\tce = NULL;\n-\t\t\t}\n \t\t\tea_bdebug(bs->bh, \"cloning\");\n \t\t\ts->base = kmalloc(bs->bh->b_size, GFP_NOFS);\n \t\t\terror = -ENOMEM;\n@@ -884,6 +884,31 @@ ext4_xattr_block_set(handle_t *handle, struct inode *inode,\n \t\t\t\tif (error)\n \t\t\t\t\tgoto cleanup_dquot;\n \t\t\t\tlock_buffer(new_bh);\n+\t\t\t\t/*\n+\t\t\t\t * We have to be careful about races with\n+\t\t\t\t * freeing or rehashing of xattr block. Once we\n+\t\t\t\t * hold buffer lock xattr block's state is\n+\t\t\t\t * stable so we can check whether the block got\n+\t\t\t\t * freed / rehashed or not.  Since we unhash\n+\t\t\t\t * mbcache entry under buffer lock when freeing\n+\t\t\t\t * / rehashing xattr block, checking whether\n+\t\t\t\t * entry is still hashed is reliable.\n+\t\t\t\t */\n+\t\t\t\tif (hlist_bl_unhashed(&ce->e_hash_list)) {\n+\t\t\t\t\t/*\n+\t\t\t\t\t * Undo everything and check mbcache\n+\t\t\t\t\t * again.\n+\t\t\t\t\t */\n+\t\t\t\t\tunlock_buffer(new_bh);\n+\t\t\t\t\tdquot_free_block(inode,\n+\t\t\t\t\t\t\t EXT4_C2B(EXT4_SB(sb),\n+\t\t\t\t\t\t\t\t  1));\n+\t\t\t\t\tbrelse(new_bh);\n+\t\t\t\t\tmb2_cache_entry_put(ext4_mb_cache, ce);\n+\t\t\t\t\tce = NULL;\n+\t\t\t\t\tnew_bh = NULL;\n+\t\t\t\t\tgoto inserted;\n+\t\t\t\t}\n \t\t\t\tle32_add_cpu(&BHDR(new_bh)->h_refcount, 1);\n \t\t\t\tea_bdebug(new_bh, \"reusing; refcount now=%d\",\n \t\t\t\t\tle32_to_cpu(BHDR(new_bh)->h_refcount));\n@@ -894,7 +919,8 @@ ext4_xattr_block_set(handle_t *handle, struct inode *inode,\n \t\t\t\tif (error)\n \t\t\t\t\tgoto cleanup_dquot;\n \t\t\t}\n-\t\t\tmb_cache_entry_release(ce);\n+\t\t\tmb2_cache_entry_touch(ext4_mb_cache, ce);\n+\t\t\tmb2_cache_entry_put(ext4_mb_cache, ce);\n \t\t\tce = NULL;\n \t\t} else if (bs->bh && s->base == bs->bh->b_data) {\n \t\t\t/* We were modifying this block in-place. */\n@@ -959,7 +985,7 @@ ext4_xattr_block_set(handle_t *handle, struct inode *inode,\n \n cleanup:\n \tif (ce)\n-\t\tmb_cache_entry_release(ce);\n+\t\tmb2_cache_entry_put(ext4_mb_cache, ce);\n \tbrelse(new_bh);\n \tif (!(bs->bh && s->base == bs->bh->b_data))\n \t\tkfree(s->base);\n@@ -1511,17 +1537,6 @@ ext4_xattr_delete_inode(handle_t *handle, struct inode *inode)\n \tbrelse(bh);\n }\n \n-/*\n- * ext4_xattr_put_super()\n- *\n- * This is called when a file system is unmounted.\n- */\n-void\n-ext4_xattr_put_super(struct super_block *sb)\n-{\n-\tmb_cache_shrink(sb->s_bdev);\n-}\n-\n /*\n  * ext4_xattr_cache_insert()\n  *\n@@ -1531,28 +1546,18 @@ ext4_xattr_put_super(struct super_block *sb)\n  * Returns 0, or a negative error number on failure.\n  */\n static void\n-ext4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n+ext4_xattr_cache_insert(struct mb2_cache *ext4_mb_cache, struct buffer_head *bh)\n {\n \t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n-\tstruct mb_cache_entry *ce;\n \tint error;\n \n-\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n-\tif (!ce) {\n-\t\tea_bdebug(bh, \"out of memory\");\n-\t\treturn;\n-\t}\n-\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n+\terror = mb2_cache_entry_create(ext4_mb_cache, GFP_NOFS, hash,\n+\t\t\t\t       bh->b_blocknr);\n \tif (error) {\n-\t\tmb_cache_entry_free(ce);\n-\t\tif (error == -EBUSY) {\n+\t\tif (error == -EBUSY)\n \t\t\tea_bdebug(bh, \"already in cache\");\n-\t\t\terror = 0;\n-\t\t}\n-\t} else {\n+\t} else\n \t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n-\t\tmb_cache_entry_release(ce);\n-\t}\n }\n \n /*\n@@ -1605,26 +1610,19 @@ ext4_xattr_cmp(struct ext4_xattr_header *header1,\n  */\n static struct buffer_head *\n ext4_xattr_cache_find(struct inode *inode, struct ext4_xattr_header *header,\n-\t\t      struct mb_cache_entry **pce)\n+\t\t      struct mb2_cache_entry **pce)\n {\n \t__u32 hash = le32_to_cpu(header->h_hash);\n-\tstruct mb_cache_entry *ce;\n-\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n+\tstruct mb2_cache_entry *ce;\n+\tstruct mb2_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n \n \tif (!header->h_hash)\n \t\treturn NULL;  /* never share */\n \tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\n-again:\n-\tce = mb_cache_entry_find_first(ext4_mb_cache, inode->i_sb->s_bdev,\n-\t\t\t\t       hash);\n+\tce = mb2_cache_entry_find_first(ext4_mb_cache, hash);\n \twhile (ce) {\n \t\tstruct buffer_head *bh;\n \n-\t\tif (IS_ERR(ce)) {\n-\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n-\t\t\t\tgoto again;\n-\t\t\tbreak;\n-\t\t}\n \t\tbh = sb_bread(inode->i_sb, ce->e_block);\n \t\tif (!bh) {\n \t\t\tEXT4_ERROR_INODE(inode, \"block %lu read error\",\n@@ -1640,7 +1638,7 @@ ext4_xattr_cache_find(struct inode *inode, struct ext4_xattr_header *header,\n \t\t\treturn bh;\n \t\t}\n \t\tbrelse(bh);\n-\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n+\t\tce = mb2_cache_entry_find_next(ext4_mb_cache, ce);\n \t}\n \treturn NULL;\n }\n@@ -1715,15 +1713,15 @@ static void ext4_xattr_rehash(struct ext4_xattr_header *header,\n \n #define\tHASH_BUCKET_BITS\t10\n \n-struct mb_cache *\n-ext4_xattr_create_cache(char *name)\n+struct mb2_cache *\n+ext4_xattr_create_cache(void)\n {\n-\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n+\treturn mb2_cache_create(HASH_BUCKET_BITS);\n }\n \n-void ext4_xattr_destroy_cache(struct mb_cache *cache)\n+void ext4_xattr_destroy_cache(struct mb2_cache *cache)\n {\n \tif (cache)\n-\t\tmb_cache_destroy(cache);\n+\t\tmb2_cache_destroy(cache);\n }\n "
        },
        {
          "filename": "fs/ext4/xattr.h",
          "status": "modified",
          "additions": 2,
          "deletions": 3,
          "patch": "@@ -108,7 +108,6 @@ extern int ext4_xattr_set(struct inode *, int, const char *, const void *, size_\n extern int ext4_xattr_set_handle(handle_t *, struct inode *, int, const char *, const void *, size_t, int);\n \n extern void ext4_xattr_delete_inode(handle_t *, struct inode *);\n-extern void ext4_xattr_put_super(struct super_block *);\n \n extern int ext4_expand_extra_isize_ea(struct inode *inode, int new_extra_isize,\n \t\t\t    struct ext4_inode *raw_inode, handle_t *handle);\n@@ -124,8 +123,8 @@ extern int ext4_xattr_ibody_inline_set(handle_t *handle, struct inode *inode,\n \t\t\t\t       struct ext4_xattr_info *i,\n \t\t\t\t       struct ext4_xattr_ibody_find *is);\n \n-extern struct mb_cache *ext4_xattr_create_cache(char *name);\n-extern void ext4_xattr_destroy_cache(struct mb_cache *);\n+extern struct mb2_cache *ext4_xattr_create_cache(void);\n+extern void ext4_xattr_destroy_cache(struct mb2_cache *);\n \n #ifdef CONFIG_EXT4_FS_SECURITY\n extern int ext4_init_security(handle_t *handle, struct inode *inode,"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "aa22f4da2a46b484a257d167c67a2adc1b7aaf68",
            "date": "2025-01-26T00:23:38Z",
            "author_login": "torvalds"
          },
          {
            "sha": "eda061cccd146fcbe71051bb4aa5a8672b71216e",
            "date": "2025-01-26T00:19:10Z",
            "author_login": "torvalds"
          },
          {
            "sha": "08de7f9d4d39fd9aa5e747a13acc891214fa2d5f",
            "date": "2025-01-26T00:12:07Z",
            "author_login": "torvalds"
          },
          {
            "sha": "647d69605c70368d54fc012fce8a43e8e5955b04",
            "date": "2025-01-26T00:03:40Z",
            "author_login": "torvalds"
          },
          {
            "sha": "184a0997fb77f4a9527fc867fcd16806776c27ce",
            "date": "2025-01-25T23:59:46Z",
            "author_login": "torvalds"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-19",
    "description": "The mbcache feature in the ext2 and ext4 filesystem implementations in the Linux kernel before 4.6 mishandles xattr block caching, which allows local users to cause a denial of service (soft lockup) via filesystem operations in environments that use many attributes, as demonstrated by Ceph and Samba.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2016-10-16T21:59:01.910",
    "last_modified": "2024-11-21T02:39:31.643",
    "fix_date": "2016-02-22T16:50:13Z"
  },
  "references": [
    {
      "url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=82939d7999dfc1f1998c4b1c12e2f19edbdff272",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=be0726d33cb8f411945884664924bed3cb8c70ee",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=f9a61eb4e2471c56a63cd804c7474128138c38ac",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/08/22/2",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/08/25/4",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.kernel.org/show_bug.cgi?id=107301",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1360968",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/f9a61eb4e2471c56a63cd804c7474128138c38ac",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://lwn.net/Articles/668718/",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://usn.ubuntu.com/3582-1/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://usn.ubuntu.com/3582-2/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=82939d7999dfc1f1998c4b1c12e2f19edbdff272",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=be0726d33cb8f411945884664924bed3cb8c70ee",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=f9a61eb4e2471c56a63cd804c7474128138c38ac",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/08/22/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/08/25/4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.kernel.org/show_bug.cgi?id=107301",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1360968",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/f9a61eb4e2471c56a63cd804c7474128138c38ac",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://lwn.net/Articles/668718/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://usn.ubuntu.com/3582-1/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://usn.ubuntu.com/3582-2/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:46.803945",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "linux",
    "owner": "torvalds",
    "created_at": "2011-09-04T22:48:12Z",
    "updated_at": "2025-01-14T12:39:03Z",
    "pushed_at": "2025-01-13T17:27:04Z",
    "size": 5361369,
    "stars": 185823,
    "forks": 54743,
    "open_issues": 437,
    "watchers": 185823,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1326937103,
      "Assembly": 9568292,
      "Shell": 5072004,
      "Python": 2974128,
      "Makefile": 2713905,
      "Perl": 1253637,
      "Rust": 807711,
      "Roff": 202277,
      "C++": 173382,
      "SmPL": 165946,
      "Yacc": 127472,
      "Lex": 71321,
      "Awk": 69539,
      "Jinja": 30138,
      "UnrealScript": 16848,
      "Gherkin": 10172,
      "M4": 3329,
      "MATLAB": 2482,
      "sed": 2433,
      "Clojure": 2411,
      "XS": 1239,
      "RPC": 962
    },
    "commit_activity": {
      "total_commits_last_year": 46007,
      "avg_commits_per_week": 884.75,
      "days_active_last_year": 359
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T12:53:59.486675"
  }
}