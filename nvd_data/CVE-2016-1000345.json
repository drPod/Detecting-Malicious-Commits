{
  "cve_id": "CVE-2016-1000345",
  "github_data": {
    "repository": "bcgit/bc-java",
    "fix_commit": "21dcb3d9744c83dcf2ff8fcee06dbca7bfa4ef35",
    "related_commits": [
      "21dcb3d9744c83dcf2ff8fcee06dbca7bfa4ef35",
      "21dcb3d9744c83dcf2ff8fcee06dbca7bfa4ef35"
    ],
    "patch_url": "https://github.com/bcgit/bc-java/commit/21dcb3d9744c83dcf2ff8fcee06dbca7bfa4ef35.patch",
    "fix_commit_details": {
      "sha": "21dcb3d9744c83dcf2ff8fcee06dbca7bfa4ef35",
      "commit_date": "2016-08-27T03:20:05Z",
      "author": {
        "login": "dghgit",
        "type": "User",
        "stats": {
          "total_commits": 5139,
          "average_weekly_commits": 8.235576923076923,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 467
        }
      },
      "commit_message": {
        "title": "modified IESEngine so that MAC check is the primary one",
        "length": 117,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 124,
        "additions": 96,
        "deletions": 28
      },
      "files": [
        {
          "filename": "core/src/main/java/org/bouncycastle/crypto/engines/IESEngine.java",
          "status": "modified",
          "additions": 20,
          "deletions": 12,
          "patch": "@@ -67,8 +67,8 @@ public IESEngine(\n \n \n     /**\n-     * set up for use in conjunction with a block cipher to handle the\n-     * message.\n+     * Set up for use in conjunction with a block cipher to handle the\n+     * message.It is <b>strongly</b> recommended that the cipher is not in ECB mode.\n      *\n      * @param agree  the key agreement used as the basis for the encryption\n      * @param kdf    the key derivation function used for byte generation\n@@ -269,15 +269,16 @@ private byte[] decryptBlock(\n         int inLen)\n         throws InvalidCipherTextException\n     {\n-        byte[] M = null, K = null, K1 = null, K2 = null;\n-        int len;\n+        byte[] M, K, K1, K2;\n+        int len = 0;\n \n         // Ensure that the length of the input is greater than the MAC in bytes\n         if (inLen < V.length + mac.getMacSize())\n         {\n             throw new InvalidCipherTextException(\"Length of input must be greater than the MAC and V combined\");\n         }\n \n+        // note order is important: set up keys, do simple encryptions, check mac, do final encryption.\n         if (cipher == null)\n         {\n             // Streaming mode.\n@@ -298,14 +299,13 @@ private byte[] decryptBlock(\n                 System.arraycopy(K, K1.length, K2, 0, K2.length);\n             }\n \n+            // process the message\n             M = new byte[K1.length];\n \n             for (int i = 0; i != K1.length; i++)\n             {\n                 M[i] = (byte)(in_enc[inOff + V.length + i] ^ K1[i]);\n             }\n-\n-            len = K1.length;\n         }\n         else\n         {\n@@ -325,15 +325,15 @@ private byte[] decryptBlock(\n             }\n             else\n             {\n-                cipher.init(false, new KeyParameter(K1));    \n+                cipher.init(false, new KeyParameter(K1));\n             }\n \n             M = new byte[cipher.getOutputSize(inLen - V.length - mac.getMacSize())];\n+\n+            // do initial processing\n             len = cipher.processBytes(in_enc, inOff + V.length, inLen - V.length - mac.getMacSize(), M, 0);\n-            len += cipher.doFinal(M, len);\n         }\n \n-\n         // Convert the length of the encoding vector into a byte array.\n         byte[] P2 = param.getEncodingV();\n         byte[] L2 = null;\n@@ -362,11 +362,19 @@ private byte[] decryptBlock(\n \n         if (!Arrays.constantTimeAreEqual(T1, T2))\n         {\n-            throw new InvalidCipherTextException(\"Invalid MAC.\");\n+            throw new InvalidCipherTextException(\"invalid MAC\");\n         }\n \n-        // Output the message.\n-        return Arrays.copyOfRange(M, 0, len);\n+        if (cipher == null)\n+        {\n+            return M;\n+        }\n+        else\n+        {\n+            len += cipher.doFinal(M, len);\n+\n+            return Arrays.copyOfRange(M, 0, len);\n+        }\n     }\n \n "
        },
        {
          "filename": "prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/dh/IESCipher.java",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -45,6 +45,7 @@\n import org.bouncycastle.crypto.parsers.DHIESPublicKeyParser;\n import org.bouncycastle.jcajce.provider.asymmetric.util.DHUtil;\n import org.bouncycastle.jcajce.provider.asymmetric.util.IESUtil;\n+import org.bouncycastle.jcajce.provider.util.BadBlockException;\n import org.bouncycastle.jcajce.util.BCJcaJceHelper;\n import org.bouncycastle.jcajce.util.JcaJceHelper;\n import org.bouncycastle.jce.interfaces.IESKey;\n@@ -425,7 +426,7 @@ public byte[] engineDoFinal(\n             }\n             catch (Exception e)\n             {\n-                throw new BadPaddingException(e.getMessage());\n+                throw new BadBlockException(\"unable to process block\", e);\n             }\n         }\n \n@@ -464,7 +465,7 @@ public byte[] getEncoded(AsymmetricKeyParameter keyParameter)\n             }\n             catch (Exception e)\n             {\n-                throw new BadPaddingException(e.getMessage());\n+                throw new BadBlockException(\"unable to process block\", e);\n             }\n         }\n         else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n@@ -478,7 +479,7 @@ else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n             }\n             catch (InvalidCipherTextException e)\n             {\n-                throw new BadPaddingException(e.getMessage());\n+                throw new BadBlockException(\"unable to process block\", e);\n             }\n         }\n         else"
        },
        {
          "filename": "prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/ec/IESCipher.java",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -43,6 +43,7 @@\n import org.bouncycastle.crypto.parsers.ECIESPublicKeyParser;\n import org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;\n import org.bouncycastle.jcajce.provider.asymmetric.util.IESUtil;\n+import org.bouncycastle.jcajce.provider.util.BadBlockException;\n import org.bouncycastle.jcajce.util.BCJcaJceHelper;\n import org.bouncycastle.jcajce.util.JcaJceHelper;\n import org.bouncycastle.jce.interfaces.ECKey;\n@@ -430,7 +431,7 @@ public byte[] engineDoFinal(\n             }\n             catch (Exception e)\n             {\n-                throw new BadPaddingException(e.getMessage());\n+                throw new BadBlockException(\"unable to process block\", e);\n             }\n         }\n \n@@ -456,11 +457,10 @@ public byte[] getEncoded(AsymmetricKeyParameter keyParameter)\n \n                 return engine.processBlock(in, 0, in.length);\n             }\n-            catch (Exception e)\n+            catch (final Exception e)\n             {\n-                throw new BadPaddingException(e.getMessage());\n+                throw new BadBlockException(\"unable to process block\", e);\n             }\n-\n         }\n         else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n         {\n@@ -473,7 +473,7 @@ else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n             }\n             catch (InvalidCipherTextException e)\n             {\n-                throw new BadPaddingException(e.getMessage());\n+                throw new BadBlockException(\"unable to process block\", e);\n             }\n         }\n         else"
        },
        {
          "filename": "prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/rsa/CipherSpi.java",
          "status": "modified",
          "additions": 3,
          "deletions": 8,
          "patch": "@@ -32,6 +32,7 @@\n import org.bouncycastle.crypto.engines.RSABlindedEngine;\n import org.bouncycastle.crypto.params.ParametersWithRandom;\n import org.bouncycastle.jcajce.provider.asymmetric.util.BaseCipherSpi;\n+import org.bouncycastle.jcajce.provider.util.BadBlockException;\n import org.bouncycastle.jcajce.provider.util.DigestFactory;\n import org.bouncycastle.jcajce.util.BCJcaJceHelper;\n import org.bouncycastle.jcajce.util.JcaJceHelper;\n@@ -528,15 +529,9 @@ private byte[] getOutput()\n \n             return cipher.processBlock(bytes, 0, bytes.length);\n         }\n-        catch (final InvalidCipherTextException e)\n+        catch (InvalidCipherTextException e)\n         {\n-            throw new BadPaddingException(\"unable to decrypt block\")\n-            {\n-                public synchronized Throwable getCause()\n-                {\n-                    return e;\n-                }\n-            };\n+            throw new BadBlockException(\"unable to decrypt block\", e);\n         }\n         finally\n         {"
        },
        {
          "filename": "prov/src/main/java/org/bouncycastle/jcajce/provider/util/BadBlockException.java",
          "status": "added",
          "additions": 21,
          "deletions": 0,
          "patch": "@@ -0,0 +1,21 @@\n+package org.bouncycastle.jcajce.provider.util;\n+\n+import javax.crypto.BadPaddingException;\n+\n+public class BadBlockException\n+    extends BadPaddingException\n+{\n+    private final Throwable cause;\n+\n+    public BadBlockException(String msg, Throwable cause)\n+    {\n+        super(msg);\n+\n+        this.cause = cause;\n+    }\n+\n+    public Throwable getCause()\n+    {\n+        return cause;\n+    }\n+}"
        },
        {
          "filename": "prov/src/test/java/org/bouncycastle/jce/provider/test/DHIESTest.java",
          "status": "modified",
          "additions": 22,
          "deletions": 0,
          "patch": "@@ -7,6 +7,7 @@\n import java.security.SecureRandom;\n import java.security.Security;\n \n+import javax.crypto.BadPaddingException;\n import javax.crypto.Cipher;\n import javax.crypto.interfaces.DHPrivateKey;\n import javax.crypto.interfaces.DHPublicKey;\n@@ -222,6 +223,27 @@ public void doTest(\n         out2 = c2.doFinal(out1, 0, out1.length);\n         if (!areEqual(out2, message))\n             fail(testname + \" test failed with non-null parameters, DHAES mode true.\");\n+\n+        //\n+        // corrupted data test\n+        //\n+        byte[] tmp = new byte[out1.length];\n+        for (int i = 0; i != out1.length; i++)\n+        {\n+            System.arraycopy(out1, 0, tmp, 0, tmp.length);\n+            tmp[i] = (byte)~tmp[i];\n+\n+            try\n+            {\n+                c2.doFinal(tmp, 0, tmp.length);\n+\n+                fail(\"decrypted corrupted data\");\n+            }\n+            catch (BadPaddingException e)\n+            {\n+                isTrue(\"wrong message: \" + e.getMessage(), \"unable to process block\".equals(e.getMessage()));\n+            }\n+        }\n     }\n \n     public static void main("
        },
        {
          "filename": "prov/src/test/java/org/bouncycastle/jce/provider/test/ECIESTest.java",
          "status": "modified",
          "additions": 21,
          "deletions": 0,
          "patch": "@@ -7,6 +7,7 @@\n import java.security.Security;\n import java.security.spec.ECGenParameterSpec;\n \n+import javax.crypto.BadPaddingException;\n import javax.crypto.Cipher;\n import javax.crypto.SealedObject;\n \n@@ -241,7 +242,27 @@ public void doTest(\n         if (!areEqual(out2, message))\n             fail(testname + \" test failed with non-null parameters, DHAES mode false.\");\n         \n+        //\n+        // corrupted data test\n+        //\n+        int offset = out1.length - (message.length + 8);\n+        byte[] tmp = new byte[out1.length];\n+        for (int i = offset; i != out1.length; i++)\n+        {\n+            System.arraycopy(out1, 0, tmp, 0, tmp.length);\n+            tmp[i] = (byte)~tmp[i];\n+\n+            try\n+            {\n+                c2.doFinal(tmp, 0, tmp.length);\n \n+                fail(\"decrypted corrupted data\");\n+            }\n+            catch (BadPaddingException e)\n+            {\n+                isTrue(\"wrong message: \" + e.getMessage(), \"unable to process block\".equals(e.getMessage()));\n+            }\n+        }\n // TODO: DHAES mode is not currently implemented, perhaps it shouldn't be...\n //        c1 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n //        c2 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 6,
        "max_directory_depth": 10
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "5ce0d4d4536bcb622c1077a6b9157b02ad8adcc5",
            "date": "2025-01-14T16:09:19Z",
            "author_login": "dghgit"
          },
          {
            "sha": "29f141ac3217f48db3a65920c4971ffaddeb4a72",
            "date": "2025-01-14T16:08:32Z",
            "author_login": "dghgit"
          },
          {
            "sha": "8a81f6cdd89b798ecfc132b37c15331e7c5df2b4",
            "date": "2025-01-14T15:01:54Z",
            "author_login": "dghgit"
          },
          {
            "sha": "c9d83fbadb9a1ce7c12dca99833c6b42de088697",
            "date": "2025-01-14T14:10:20Z",
            "author_login": "dghgit"
          },
          {
            "sha": "9a36e56b93e361dbc065f5bd920574f96f99102f",
            "date": "2025-01-14T14:10:04Z",
            "author_login": "dghgit"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-361",
    "description": "In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES/ECIES CBC mode vulnerable to padding oracle attack. For BC 1.55 and older, in an environment where timings can be easily observed, it is possible with enough observations to identify when the decryption is failing due to padding.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-06-04T21:29:00.270",
    "last_modified": "2024-11-21T02:43:03.570",
    "fix_date": "2016-08-27T03:20:05Z"
  },
  "references": [
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:2669",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:2927",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/bcgit/bc-java/commit/21dcb3d9744c83dcf2ff8fcee06dbca7bfa4ef35#diff-4439ce586bf9a13bfec05c0d113b8098",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00009.html",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20181127-0004/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://usn.ubuntu.com/3727-1/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpuoct2020.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:2669",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:2927",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/bcgit/bc-java/commit/21dcb3d9744c83dcf2ff8fcee06dbca7bfa4ef35#diff-4439ce586bf9a13bfec05c0d113b8098",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00009.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20181127-0004/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://usn.ubuntu.com/3727-1/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpuoct2020.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:25.884073",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "bc-java",
    "owner": "bcgit",
    "created_at": "2013-06-01T02:38:42Z",
    "updated_at": "2025-01-13T21:13:46Z",
    "pushed_at": "2025-01-13T21:13:42Z",
    "size": 115936,
    "stars": 2364,
    "forks": 1146,
    "open_issues": 290,
    "watchers": 2364,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Java": 50883690,
      "Shell": 153252,
      "HTML": 81181,
      "Batchfile": 12956
    },
    "commit_activity": {
      "total_commits_last_year": 902,
      "avg_commits_per_week": 17.346153846153847,
      "days_active_last_year": 210
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:21:20.845974"
  }
}