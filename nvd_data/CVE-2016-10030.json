{
  "cve_id": "CVE-2016-10030",
  "github_data": {
    "repository": "SchedMD/slurm",
    "fix_commit": "92362a92fffe60187df61f99ab11c249d44120ee",
    "related_commits": [
      "92362a92fffe60187df61f99ab11c249d44120ee",
      "92362a92fffe60187df61f99ab11c249d44120ee"
    ],
    "patch_url": "https://github.com/SchedMD/slurm/commit/92362a92fffe60187df61f99ab11c249d44120ee.patch",
    "fix_commit_details": {
      "sha": "92362a92fffe60187df61f99ab11c249d44120ee",
      "commit_date": "2017-01-04T21:10:01Z",
      "author": {
        "login": "wickberg",
        "type": "User",
        "stats": {
          "total_commits": 7049,
          "average_weekly_commits": 5.816006600660066,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 433
        }
      },
      "commit_message": {
        "title": "Fix security issue in _prolog_error().",
        "length": 315,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 116,
        "additions": 112,
        "deletions": 4
      },
      "files": [
        {
          "filename": "NEWS",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -28,6 +28,9 @@ documents those changes that are of interest to users and administrators.\n  -- Fix check for PluginDir within slurmctld to work with multiple directories.\n  -- Cancel interactive jobs automatically on communication error to launching\n     srun/salloc process.\n+ -- Fix security issue caused by insecure file path handling triggered by the\n+    failure of a Prolog script. To exploit this a user needs to anticipate or\n+    cause the Prolog to fail for their job. CVE-2016-10030.\n \n * Changes in Slurm 16.05.7\n =========================="
        },
        {
          "filename": "src/slurmd/slurmd/req.c",
          "status": "modified",
          "additions": 109,
          "deletions": 4,
          "patch": "@@ -168,6 +168,7 @@ static void _note_batch_job_finished(uint32_t job_id);\n static int  _prolog_is_running (uint32_t jobid);\n static int  _step_limits_match(void *x, void *key);\n static int  _terminate_all_steps(uint32_t jobid, bool batch);\n+static int  _receive_fd(int socket);\n static void _rpc_launch_tasks(slurm_msg_t *);\n static void _rpc_abort_job(slurm_msg_t *);\n static void _rpc_batch_job(slurm_msg_t *msg, bool new_msg);\n@@ -214,6 +215,7 @@ static void _sync_messages_kill(kill_job_msg_t *req);\n static int  _waiter_init (uint32_t jobid);\n static int  _waiter_complete (uint32_t jobid);\n \n+static void _send_back_fd(int socket, int fd);\n static bool _steps_completed_now(uint32_t jobid);\n static int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n \t\t\t       uint16_t block_no, uint32_t *job_id);\n@@ -1383,6 +1385,111 @@ _rpc_launch_tasks(slurm_msg_t *msg)\n \t\tsend_registration_msg(errnum, false);\n }\n \n+/*\n+ * Open file based upon permissions of a different user\n+ * IN path_name - name of file to open\n+ * IN uid - User ID to use for file access check\n+ * IN gid - Group ID to use for file access check\n+ * RET -1 on error, file descriptor otherwise\n+ */\n+static int _open_as_other(char *path_name, batch_job_launch_msg_t *req)\n+{\n+\tpid_t child;\n+\tgids_t *gids;\n+\tint pipe[2];\n+\tint fd = -1, rc = 0;\n+\n+\tif (!(gids = _gids_cache_lookup(req->user_name, req->gid))) {\n+\t\terror(\"%s: gids_cache_lookup for %s failed\",\n+\t\t      __func__, req->user_name);\n+\t\treturn -1;\n+\t}\n+\n+\tif ((rc = container_g_create(req->job_id))) {\n+\t\terror(\"%s: container_g_create(%u): %m\", __func__, req->job_id);\n+\t\t_dealloc_gids(gids);\n+\t\treturn -1;\n+\t}\n+\n+\t/* child process will setuid to the user, register the process\n+\t * with the container, and open the file for us. */\n+\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, pipe) != 0) {\n+\t\terror(\"%s: Failed to open pipe: %m\", __func__);\n+\t\t_dealloc_gids(gids);\n+\t\treturn -1;\n+\t}\n+\n+\tchild = fork();\n+\tif (child == -1) {\n+\t\terror(\"%s: fork failure\", __func__);\n+\t\t_dealloc_gids(gids);\n+\t\tclose(pipe[0]);\n+\t\tclose(pipe[1]);\n+\t\treturn -1;\n+\t} else if (child > 0) {\n+\t\tclose(pipe[0]);\n+\t\t(void) waitpid(child, &rc, 0);\n+\t\t_dealloc_gids(gids);\n+\t\tif (WIFEXITED(rc) && (WEXITSTATUS(rc) == 0))\n+\t\t\tfd = _receive_fd(pipe[1]);\n+\t\tclose(pipe[1]);\n+\t\treturn fd;\n+\t}\n+\n+\t/* child process below here */\n+\n+\tclose(pipe[1]);\n+\n+\t/* container_g_add_pid needs to be called in the\n+\t * forked process part of the fork to avoid a race\n+\t * condition where if this process makes a file or\n+\t * detacts itself from a child before we add the pid\n+\t * to the container in the parent of the fork. */\n+\tif (container_g_add_pid(req->job_id, getpid(), req->uid)) {\n+\t\terror(\"%s container_g_add_pid(%u): %m\", __func__, req->job_id);\n+\t\texit(SLURM_ERROR);\n+\t}\n+\n+\t/* The child actually performs the I/O and exits with\n+\t * a return code, do not return! */\n+\n+\t/*********************************************************************\\\n+\t * NOTE: It would be best to do an exec() immediately after the fork()\n+\t * in order to help prevent a possible deadlock in the child process\n+\t * due to locks being set at the time of the fork and being freed by\n+\t * the parent process, but not freed by the child process. Performing\n+\t * the work inline is done for simplicity. Note that the logging\n+\t * performed by error() should be safe due to the use of\n+\t * atfork_install_handlers() as defined in src/common/log.c.\n+\t * Change the code below with caution.\n+\t\\*********************************************************************/\n+\n+\tif (setgroups(gids->ngids, gids->gids) < 0) {\n+\t\terror(\"%s: uid: %u setgroups failed: %m\", __func__, req->uid);\n+\t\texit(errno);\n+\t}\n+\t_dealloc_gids(gids);\n+\n+\tif (setgid(req->gid) < 0) {\n+\t\terror(\"%s: uid:%u setgid(%u): %m\", __func__, req->uid,req->gid);\n+\t\texit(errno);\n+\t}\n+\tif (setuid(req->uid) < 0) {\n+\t\terror(\"%s: getuid(%u): %m\", __func__, req->uid);\n+\t\texit(errno);\n+\t}\n+\n+\tfd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644);\n+\tif (fd == -1) {\n+\t\terror(\"%s: uid:%u can't open `%s`: %m\",\n+\t\t      __func__, req->uid, path_name);\n+\t\texit(errno);\n+\t}\n+\t_send_back_fd(pipe[0], fd);\n+\tclose(fd);\n+\texit(SLURM_SUCCESS);\n+}\n+\n static void\n _prolog_error(batch_job_launch_msg_t *req, int rc)\n {\n@@ -1415,10 +1522,8 @@ _prolog_error(batch_job_launch_msg_t *req, int rc)\n \t\t\treq->work_dir, err_name_ptr);\n \telse\n \t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n-\n-\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n-\t\terror(\"Unable to open %s: %s\", path_name,\n-\t\t      slurm_strerror(errno));\n+\tif ((fd = _open_as_other(path_name, req)) == -1) {\n+\t\terror(\"Unable to open %s: Permission denied\", path_name);\n \t\treturn;\n \t}\n \tsnprintf(err_name, sizeof(err_name),"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "3f3d105d8b5414795fb60ca397d82e4f6b1de556",
            "date": "2025-01-14T17:48:37Z",
            "author_login": "dannyauble"
          },
          {
            "sha": "d4bb45491f0138601de0c2f55fdedeb776c41cf3",
            "date": "2025-01-13T15:59:27Z",
            "author_login": "fafik23"
          },
          {
            "sha": "b0753d0bac24b2b5371df787087ff92da131d003",
            "date": "2025-01-13T15:52:40Z",
            "author_login": "fafik23"
          },
          {
            "sha": "f9377cbede66bf1b2929d153f11dd88fa5c945b5",
            "date": "2025-01-13T15:12:59Z",
            "author_login": "fafik23"
          },
          {
            "sha": "99d27d9096f74269a987339342acd693b52d8d0b",
            "date": "2025-01-13T13:28:41Z",
            "author_login": "fafik23"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-284",
    "description": "The _prolog_error function in slurmd/req.c in Slurm before 15.08.13, 16.x before 16.05.7, and 17.x before 17.02.0-pre4 has a vulnerability in how the slurmd daemon informs users of a Prolog failure on a compute node. That vulnerability could allow a user to assume control of an arbitrary file on the system. Any exploitation of this is dependent on the user being able to cause or anticipate the failure (non-zero return code) of a Prolog script that their job would run on. This issue affects all Slurm versions from 0.6.0 (September 2005) to present. Workarounds to prevent exploitation of this are to either disable your Prolog script, or modify it such that it always returns 0 (\"success\") and adjust it to set the node as down using scontrol instead of relying on the slurmd to handle that automatically. If you do not have a Prolog set you are unaffected by this issue.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-01-05T11:59:00.133",
    "last_modified": "2024-11-21T02:43:07.207",
    "fix_date": "2017-01-04T21:10:01Z"
  },
  "references": [
    {
      "url": "http://www.securityfocus.com/bid/95299",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/SchedMD/slurm/commit/92362a92fffe60187df61f99ab11c249d44120ee",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://www.schedmd.com/news.php?id=178",
      "source": "cve@mitre.org",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/95299",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/SchedMD/slurm/commit/92362a92fffe60187df61f99ab11c249d44120ee",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://www.schedmd.com/news.php?id=178",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:49.826359",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "slurm",
    "owner": "SchedMD",
    "created_at": "2011-06-20T16:15:51Z",
    "updated_at": "2025-01-14T17:48:46Z",
    "pushed_at": "2025-01-14T17:48:41Z",
    "size": 327812,
    "stars": 2801,
    "forks": 676,
    "open_issues": 4,
    "watchers": 2801,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 23119941,
      "Makefile": 6084958,
      "Roff": 1088397,
      "Python": 873821,
      "Shell": 567339,
      "Perl": 264707,
      "M4": 186734,
      "XS": 58871,
      "C++": 11213,
      "Vim Script": 9525,
      "Lua": 5836,
      "Cuda": 1568
    },
    "commit_activity": {
      "total_commits_last_year": 5837,
      "avg_commits_per_week": 112.25,
      "days_active_last_year": 291
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T20:59:49.886240"
  }
}