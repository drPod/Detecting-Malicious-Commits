{
  "cve_id": "CVE-2016-10190",
  "github_data": {
    "repository": "FFmpeg/FFmpeg",
    "fix_commit": "2a05c8f813de6f2278827734bf8102291e7484aa",
    "related_commits": [
      "2a05c8f813de6f2278827734bf8102291e7484aa",
      "2a05c8f813de6f2278827734bf8102291e7484aa"
    ],
    "patch_url": "https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa.patch",
    "fix_commit_details": {
      "sha": "2a05c8f813de6f2278827734bf8102291e7484aa",
      "commit_date": "2016-12-05T13:02:33Z",
      "author": {
        "login": "rbultje",
        "type": "User",
        "stats": {
          "total_commits": 1624,
          "average_weekly_commits": 1.2940239043824702,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 277
        }
      },
      "commit_message": {
        "title": "http: make length/offset-related variables unsigned.",
        "length": 121,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 70,
        "additions": 38,
        "deletions": 32
      },
      "files": [
        {
          "filename": "libavformat/http.c",
          "status": "modified",
          "additions": 38,
          "deletions": 32,
          "patch": "@@ -62,8 +62,8 @@ typedef struct HTTPContext {\n     int line_count;\n     int http_code;\n     /* Used if \"Transfer-Encoding: chunked\" otherwise -1. */\n-    int64_t chunksize;\n-    int64_t off, end_off, filesize;\n+    uint64_t chunksize;\n+    uint64_t off, end_off, filesize;\n     char *location;\n     HTTPAuthState auth_state;\n     HTTPAuthState proxy_auth_state;\n@@ -95,9 +95,9 @@ typedef struct HTTPContext {\n     AVDictionary *cookie_dict;\n     int icy;\n     /* how much data was read since the last ICY metadata packet */\n-    int icy_data_read;\n+    uint64_t icy_data_read;\n     /* after how many bytes of read data a new metadata packet will be found */\n-    int icy_metaint;\n+    uint64_t icy_metaint;\n     char *icy_metadata_headers;\n     char *icy_metadata_packet;\n     AVDictionary *metadata;\n@@ -489,7 +489,7 @@ static int http_open(URLContext *h, const char *uri, int flags,\n     else\n         h->is_streamed = 1;\n \n-    s->filesize = -1;\n+    s->filesize = UINT64_MAX;\n     s->location = av_strdup(uri);\n     if (!s->location)\n         return AVERROR(ENOMEM);\n@@ -616,9 +616,9 @@ static void parse_content_range(URLContext *h, const char *p)\n \n     if (!strncmp(p, \"bytes \", 6)) {\n         p     += 6;\n-        s->off = strtoll(p, NULL, 10);\n+        s->off = strtoull(p, NULL, 10);\n         if ((slash = strchr(p, '/')) && strlen(slash) > 0)\n-            s->filesize = strtoll(slash + 1, NULL, 10);\n+            s->filesize = strtoull(slash + 1, NULL, 10);\n     }\n     if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))\n         h->is_streamed = 0; /* we _can_ in fact seek */\n@@ -808,8 +808,9 @@ static int process_line(URLContext *h, char *line, int line_count,\n             if ((ret = parse_location(s, p)) < 0)\n                 return ret;\n             *new_location = 1;\n-        } else if (!av_strcasecmp(tag, \"Content-Length\") && s->filesize == -1) {\n-            s->filesize = strtoll(p, NULL, 10);\n+        } else if (!av_strcasecmp(tag, \"Content-Length\") &&\n+                   s->filesize == UINT64_MAX) {\n+            s->filesize = strtoull(p, NULL, 10);\n         } else if (!av_strcasecmp(tag, \"Content-Range\")) {\n             parse_content_range(h, p);\n         } else if (!av_strcasecmp(tag, \"Accept-Ranges\") &&\n@@ -818,7 +819,7 @@ static int process_line(URLContext *h, char *line, int line_count,\n             h->is_streamed = 0;\n         } else if (!av_strcasecmp(tag, \"Transfer-Encoding\") &&\n                    !av_strncasecmp(p, \"chunked\", 7)) {\n-            s->filesize  = -1;\n+            s->filesize  = UINT64_MAX;\n             s->chunksize = 0;\n         } else if (!av_strcasecmp(tag, \"WWW-Authenticate\")) {\n             ff_http_auth_handle_header(&s->auth_state, tag, p);\n@@ -842,7 +843,7 @@ static int process_line(URLContext *h, char *line, int line_count,\n             if (parse_cookie(s, p, &s->cookie_dict))\n                 av_log(h, AV_LOG_WARNING, \"Unable to parse '%s'\\n\", p);\n         } else if (!av_strcasecmp(tag, \"Icy-MetaInt\")) {\n-            s->icy_metaint = strtoll(p, NULL, 10);\n+            s->icy_metaint = strtoull(p, NULL, 10);\n         } else if (!av_strncasecmp(tag, \"Icy-\", 4)) {\n             if ((ret = parse_icy(s, tag, p)) < 0)\n                 return ret;\n@@ -972,7 +973,7 @@ static int http_read_header(URLContext *h, int *new_location)\n     char line[MAX_URL_SIZE];\n     int err = 0;\n \n-    s->chunksize = -1;\n+    s->chunksize = UINT64_MAX;\n \n     for (;;) {\n         if ((err = http_get_line(s, line, sizeof(line))) < 0)\n@@ -1006,7 +1007,7 @@ static int http_connect(URLContext *h, const char *path, const char *local_path,\n     int post, err;\n     char headers[HTTP_HEADERS_SIZE] = \"\";\n     char *authstr = NULL, *proxyauthstr = NULL;\n-    int64_t off = s->off;\n+    uint64_t off = s->off;\n     int len = 0;\n     const char *method;\n     int send_expect_100 = 0;\n@@ -1060,7 +1061,7 @@ static int http_connect(URLContext *h, const char *path, const char *local_path,\n     // server supports seeking by analysing the reply headers.\n     if (!has_header(s->headers, \"\\r\\nRange: \") && !post && (s->off > 0 || s->end_off || s->seekable == -1)) {\n         len += av_strlcatf(headers + len, sizeof(headers) - len,\n-                           \"Range: bytes=%\"PRId64\"-\", s->off);\n+                           \"Range: bytes=%\"PRIu64\"-\", s->off);\n         if (s->end_off)\n             len += av_strlcatf(headers + len, sizeof(headers) - len,\n                                \"%\"PRId64, s->end_off - 1);\n@@ -1135,7 +1136,7 @@ static int http_connect(URLContext *h, const char *path, const char *local_path,\n     s->line_count       = 0;\n     s->off              = 0;\n     s->icy_data_read    = 0;\n-    s->filesize         = -1;\n+    s->filesize         = UINT64_MAX;\n     s->willclose        = 0;\n     s->end_chunked_post = 0;\n     s->end_header       = 0;\n@@ -1175,15 +1176,13 @@ static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n         memcpy(buf, s->buf_ptr, len);\n         s->buf_ptr += len;\n     } else {\n-        int64_t target_end = s->end_off ? s->end_off : s->filesize;\n-        if ((!s->willclose || s->chunksize < 0) &&\n-            target_end >= 0 && s->off >= target_end)\n+        uint64_t target_end = s->end_off ? s->end_off : s->filesize;\n+        if ((!s->willclose || s->chunksize == UINT64_MAX) && s->off >= target_end)\n             return AVERROR_EOF;\n         len = ffurl_read(s->hd, buf, size);\n-        if (!len && (!s->willclose || s->chunksize < 0) &&\n-            target_end >= 0 && s->off < target_end) {\n+        if (!len && (!s->willclose || s->chunksize == UINT64_MAX) && s->off < target_end) {\n             av_log(h, AV_LOG_ERROR,\n-                   \"Stream ends prematurely at %\"PRId64\", should be %\"PRId64\"\\n\",\n+                   \"Stream ends prematurely at %\"PRIu64\", should be %\"PRIu64\"\\n\",\n                    s->off, target_end\n                   );\n             return AVERROR(EIO);\n@@ -1247,7 +1246,7 @@ static int http_read_stream(URLContext *h, uint8_t *buf, int size)\n             return err;\n     }\n \n-    if (s->chunksize >= 0) {\n+    if (s->chunksize != UINT64_MAX) {\n         if (!s->chunksize) {\n             char line[32];\n \n@@ -1256,13 +1255,19 @@ static int http_read_stream(URLContext *h, uint8_t *buf, int size)\n                         return err;\n                 } while (!*line);    /* skip CR LF from last chunk */\n \n-                s->chunksize = strtoll(line, NULL, 16);\n+                s->chunksize = strtoull(line, NULL, 16);\n \n-                av_log(NULL, AV_LOG_TRACE, \"Chunked encoding data size: %\"PRId64\"'\\n\",\n+                av_log(h, AV_LOG_TRACE,\n+                       \"Chunked encoding data size: %\"PRIu64\"'\\n\",\n                         s->chunksize);\n \n                 if (!s->chunksize)\n                     return 0;\n+                else if (s->chunksize == UINT64_MAX) {\n+                    av_log(h, AV_LOG_ERROR, \"Invalid chunk size %\"PRIu64\"\\n\",\n+                           s->chunksize);\n+                    return AVERROR(EINVAL);\n+                }\n         }\n         size = FFMIN(size, s->chunksize);\n     }\n@@ -1273,17 +1278,17 @@ static int http_read_stream(URLContext *h, uint8_t *buf, int size)\n     read_ret = http_buf_read(h, buf, size);\n     if (   (read_ret  < 0 && s->reconnect        && (!h->is_streamed || s->reconnect_streamed) && s->filesize > 0 && s->off < s->filesize)\n         || (read_ret == 0 && s->reconnect_at_eof && (!h->is_streamed || s->reconnect_streamed))) {\n-        int64_t target = h->is_streamed ? 0 : s->off;\n+        uint64_t target = h->is_streamed ? 0 : s->off;\n \n         if (s->reconnect_delay > s->reconnect_delay_max)\n             return AVERROR(EIO);\n \n-        av_log(h, AV_LOG_INFO, \"Will reconnect at %\"PRId64\" error=%s.\\n\", s->off, av_err2str(read_ret));\n+        av_log(h, AV_LOG_INFO, \"Will reconnect at %\"PRIu64\" error=%s.\\n\", s->off, av_err2str(read_ret));\n         av_usleep(1000U*1000*s->reconnect_delay);\n         s->reconnect_delay = 1 + 2*s->reconnect_delay;\n         seek_ret = http_seek_internal(h, target, SEEK_SET, 1);\n         if (seek_ret != target) {\n-            av_log(h, AV_LOG_ERROR, \"Failed to reconnect at %\"PRId64\".\\n\", target);\n+            av_log(h, AV_LOG_ERROR, \"Failed to reconnect at %\"PRIu64\".\\n\", target);\n             return read_ret;\n         }\n \n@@ -1338,10 +1343,11 @@ static int store_icy(URLContext *h, int size)\n {\n     HTTPContext *s = h->priv_data;\n     /* until next metadata packet */\n-    int remaining = s->icy_metaint - s->icy_data_read;\n+    uint64_t remaining;\n \n-    if (remaining < 0)\n+    if (s->icy_metaint < s->icy_data_read)\n         return AVERROR_INVALIDDATA;\n+    remaining = s->icy_metaint - s->icy_data_read;\n \n     if (!remaining) {\n         /* The metadata packet is variable sized. It has a 1 byte header\n@@ -1455,7 +1461,7 @@ static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int fo\n {\n     HTTPContext *s = h->priv_data;\n     URLContext *old_hd = s->hd;\n-    int64_t old_off = s->off;\n+    uint64_t old_off = s->off;\n     uint8_t old_buf[BUFFER_SIZE];\n     int old_buf_size, ret;\n     AVDictionary *options = NULL;\n@@ -1466,7 +1472,7 @@ static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int fo\n              ((whence == SEEK_CUR && off == 0) ||\n               (whence == SEEK_SET && off == s->off)))\n         return s->off;\n-    else if ((s->filesize == -1 && whence == SEEK_END))\n+    else if ((s->filesize == UINT64_MAX && whence == SEEK_END))\n         return AVERROR(ENOSYS);\n \n     if (whence == SEEK_CUR)\n@@ -1621,7 +1627,7 @@ static int http_proxy_open(URLContext *h, const char *uri, int flags)\n     s->buf_ptr    = s->buffer;\n     s->buf_end    = s->buffer;\n     s->line_count = 0;\n-    s->filesize   = -1;\n+    s->filesize   = UINT64_MAX;\n     cur_auth_type = s->proxy_auth_state.auth_type;\n \n     /* Note: This uses buffering, potentially reading more than the"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8eb1d76e146a0e557d596a4039efebac746b4d83",
            "date": "2025-01-12T03:34:17Z",
            "author_login": "nuomi2021"
          },
          {
            "sha": "d5873be583ada9e1fb887e2fe8dcfd4b12e0efcd",
            "date": "2025-01-13T20:28:02Z",
            "author_login": "jamrial"
          },
          {
            "sha": "b88fc4e098607bed98c74e6d13ed77b907776685",
            "date": "2025-01-08T11:06:30Z",
            "author_login": "mypopydev"
          },
          {
            "sha": "8ded602edad43227aa5b84ac8041d4b174ec9431",
            "date": "2025-01-08T11:04:12Z",
            "author_login": "mypopydev"
          },
          {
            "sha": "851a84650ef6026871f3b565d1f54c9d7a5397a4",
            "date": "2025-01-07T04:56:11Z",
            "author_login": "cyanreg"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-119",
    "description": "Heap-based buffer overflow in libavformat/http.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote web servers to execute arbitrary code via a negative chunk size in an HTTP response.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-02-09T15:59:00.627",
    "last_modified": "2024-11-21T02:43:31.140",
    "fix_date": "2016-12-05T13:02:33Z"
  },
  "references": [
    {
      "url": "http://www.openwall.com/lists/oss-security/2017/01/31/12",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2017/02/02/1",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/95986",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://ffmpeg.org/security.html",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2018/12/msg00009.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://trac.ffmpeg.org/ticket/5992",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2017/01/31/12",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2017/02/02/1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/95986",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://ffmpeg.org/security.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2018/12/msg00009.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://trac.ffmpeg.org/ticket/5992",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:52.215452",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "FFmpeg",
    "owner": "FFmpeg",
    "created_at": "2011-04-14T14:12:38Z",
    "updated_at": "2025-01-14T12:22:35Z",
    "pushed_at": "2025-01-13T21:15:03Z",
    "size": 431834,
    "stars": 47243,
    "forks": 12316,
    "open_issues": 3,
    "watchers": 47243,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master",
      "release/0.5",
      "release/0.6",
      "release/0.7",
      "release/0.8",
      "release/0.9",
      "release/0.10",
      "release/0.11",
      "release/1.0",
      "release/1.1",
      "release/1.2",
      "release/2.0",
      "release/2.1",
      "release/2.2",
      "release/2.3",
      "release/2.4",
      "release/2.5",
      "release/2.6",
      "release/2.7",
      "release/2.8",
      "release/3.0",
      "release/3.1",
      "release/3.2",
      "release/3.3",
      "release/3.4",
      "release/4.0",
      "release/4.1",
      "release/4.2",
      "release/4.3"
    ],
    "languages": {
      "C": 65826781,
      "Assembly": 5688727,
      "Makefile": 948271,
      "C++": 141194,
      "Objective-C": 108023,
      "Cuda": 85420,
      "Shell": 59093,
      "Perl": 29093,
      "Metal": 7961,
      "Python": 5992,
      "Awk": 1912,
      "HTML": 1631,
      "Ruby": 1462,
      "Verilog": 729,
      "Roff": 132
    },
    "commit_activity": {
      "total_commits_last_year": 4412,
      "avg_commits_per_week": 84.84615384615384,
      "days_active_last_year": 353
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:03:32.126548"
  }
}