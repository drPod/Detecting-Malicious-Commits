{
  "cve_id": "CVE-2016-10745",
  "github_data": {
    "repository": "pallets/jinja",
    "fix_commit": "9b53045c34e61013dc8f09b7e52a555fa16bed16",
    "related_commits": [
      "9b53045c34e61013dc8f09b7e52a555fa16bed16",
      "9b53045c34e61013dc8f09b7e52a555fa16bed16"
    ],
    "patch_url": "https://github.com/pallets/jinja/commit/9b53045c34e61013dc8f09b7e52a555fa16bed16.patch",
    "fix_commit_details": {
      "sha": "9b53045c34e61013dc8f09b7e52a555fa16bed16",
      "commit_date": "2016-12-29T13:13:38Z",
      "author": {
        "login": "mitsuhiko",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "SECURITY: support sandboxing in format expressions",
        "length": 50,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 148,
        "additions": 143,
        "deletions": 5
      },
      "files": [
        {
          "filename": "jinja2/nodes.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -604,7 +604,7 @@ class Call(Expr):\n \n     def as_const(self, eval_ctx=None):\n         eval_ctx = get_eval_context(self, eval_ctx)\n-        if eval_ctx.volatile:\n+        if eval_ctx.volatile or eval_ctx.environment.sandboxed:\n             raise Impossible()\n         obj = self.node.as_const(eval_ctx)\n "
        },
        {
          "filename": "jinja2/sandbox.py",
          "status": "modified",
          "additions": 116,
          "deletions": 3,
          "patch": "@@ -14,9 +14,17 @@\n \"\"\"\n import types\n import operator\n+from collections import Mapping\n from jinja2.environment import Environment\n from jinja2.exceptions import SecurityError\n-from jinja2._compat import string_types, PY2\n+from jinja2._compat import string_types, text_type, PY2\n+from jinja2.utils import Markup\n+\n+has_format = False\n+if hasattr(text_type, 'format'):\n+    from markupsafe import EscapeFormatter\n+    from string import Formatter\n+    has_format = True\n \n \n #: maximum number of items a range may produce\n@@ -38,6 +46,12 @@\n #: unsafe generator attirbutes.\n UNSAFE_GENERATOR_ATTRIBUTES = set(['gi_frame', 'gi_code'])\n \n+#: unsafe attributes on coroutines\n+UNSAFE_COROUTINE_ATTRIBUTES = set(['cr_frame', 'cr_code'])\n+\n+#: unsafe attributes on async generators\n+UNSAFE_ASYNC_GENERATOR_ATTRIBUTES = set(['ag_code', 'ag_frame'])\n+\n import warnings\n \n # make sure we don't warn in python 2.6 about stuff we don't care about\n@@ -94,6 +108,49 @@\n )\n \n \n+class _MagicFormatMapping(Mapping):\n+    \"\"\"This class implements a dummy wrapper to fix a bug in the Python\n+    standard library for string formatting.\n+\n+    See http://bugs.python.org/issue13598 for information about why\n+    this is necessary.\n+    \"\"\"\n+\n+    def __init__(self, args, kwargs):\n+        self._args = args\n+        self._kwargs = kwargs\n+        self._last_index = 0\n+\n+    def __getitem__(self, key):\n+        if key == '':\n+            idx = self._last_index\n+            self._last_index += 1\n+            try:\n+                return self._args[idx]\n+            except LookupError:\n+                pass\n+            key = str(idx)\n+        return self._kwargs[key]\n+\n+    def __iter__(self):\n+        return iter(self._kwargs)\n+\n+    def __len__(self):\n+        return len(self._kwargs)\n+\n+\n+def inspect_format_method(callable):\n+    if not has_format:\n+        return None\n+    if not isinstance(callable, (types.MethodType,\n+                                 types.BuiltinMethodType)) or \\\n+       callable.__name__ != 'format':\n+        return None\n+    obj = callable.__self__\n+    if isinstance(obj, string_types):\n+        return obj\n+\n+\n def safe_range(*args):\n     \"\"\"A range that can't generate ranges with a length of more than\n     MAX_RANGE items.\n@@ -145,6 +202,12 @@ def is_internal_attribute(obj, attr):\n     elif isinstance(obj, types.GeneratorType):\n         if attr in UNSAFE_GENERATOR_ATTRIBUTES:\n             return True\n+    elif hasattr(types, 'CoroutineType') and isinstance(obj, types.CoroutineType):\n+        if attr in UNSAFE_COROUTINE_ATTRIBUTES:\n+            return True\n+    elif hasattr(types, 'AsyncGeneratorType') and isinstance(obj, types.AsyncGeneratorType):\n+        if attri in UNSAFE_ASYNC_GENERATOR_ATTRIBUTES:\n+            return True\n     return attr.startswith('__')\n \n \n@@ -183,8 +246,8 @@ class SandboxedEnvironment(Environment):\n     attributes or functions are safe to access.\n \n     If the template tries to access insecure code a :exc:`SecurityError` is\n-    raised.  However also other exceptions may occour during the rendering so\n-    the caller has to ensure that all exceptions are catched.\n+    raised.  However also other exceptions may occur during the rendering so\n+    the caller has to ensure that all exceptions are caught.\n     \"\"\"\n     sandboxed = True\n \n@@ -346,8 +409,24 @@ def unsafe_undefined(self, obj, attribute):\n             obj.__class__.__name__\n         ), name=attribute, obj=obj, exc=SecurityError)\n \n+    def format_string(self, s, args, kwargs):\n+        \"\"\"If a format call is detected, then this is routed through this\n+        method so that our safety sandbox can be used for it.\n+        \"\"\"\n+        if isinstance(s, Markup):\n+            formatter = SandboxedEscapeFormatter(self, s.escape)\n+        else:\n+            formatter = SandboxedFormatter(self)\n+        kwargs = _MagicFormatMapping(args, kwargs)\n+        rv = formatter.vformat(s, args, kwargs)\n+        return type(s)(rv)\n+\n     def call(__self, __context, __obj, *args, **kwargs):\n         \"\"\"Call an object from sandboxed code.\"\"\"\n+        fmt = inspect_format_method(__obj)\n+        if fmt is not None:\n+            return __self.format_string(fmt, args, kwargs)\n+\n         # the double prefixes are to avoid double keyword argument\n         # errors when proxying the call.\n         if not __self.is_safe_callable(__obj):\n@@ -365,3 +444,37 @@ def is_safe_attribute(self, obj, attr, value):\n         if not SandboxedEnvironment.is_safe_attribute(self, obj, attr, value):\n             return False\n         return not modifies_known_mutable(obj, attr)\n+\n+\n+if has_format:\n+    # This really is not a public API apparenlty.\n+    try:\n+        from _string import formatter_field_name_split\n+    except ImportError:\n+        def formatter_field_name_split(field_name):\n+            return field_name._formatter_field_name_split()\n+\n+    class SandboxedFormatterMixin(object):\n+\n+        def __init__(self, env):\n+            self._env = env\n+\n+        def get_field(self, field_name, args, kwargs):\n+            first, rest = formatter_field_name_split(field_name)\n+            obj = self.get_value(first, args, kwargs)\n+            for is_attr, i in rest:\n+                if is_attr:\n+                    obj = self._env.getattr(obj, i)\n+                else:\n+                    obj = self._env.getitem(obj, i)\n+            return obj, first\n+\n+    class SandboxedFormatter(SandboxedFormatterMixin, Formatter):\n+        def __init__(self, env):\n+            SandboxedFormatterMixin.__init__(self, env)\n+            Formatter.__init__(self)\n+\n+    class SandboxedEscapeFormatter(SandboxedFormatterMixin, EscapeFormatter):\n+        def __init__(self, env, escape):\n+            SandboxedFormatterMixin.__init__(self, env)\n+            EscapeFormatter.__init__(self, escape)"
        },
        {
          "filename": "tests/test_security.py",
          "status": "modified",
          "additions": 26,
          "deletions": 1,
          "patch": "@@ -12,7 +12,7 @@\n \n from jinja2 import Environment\n from jinja2.sandbox import SandboxedEnvironment, \\\n-     ImmutableSandboxedEnvironment, unsafe\n+     ImmutableSandboxedEnvironment, unsafe, has_format\n from jinja2 import Markup, escape\n from jinja2.exceptions import SecurityError, TemplateSyntaxError, \\\n      TemplateRuntimeError\n@@ -159,3 +159,28 @@ def disable_op(arg):\n                 pass\n             else:\n                 assert False, 'expected runtime error'\n+\n+\n+@pytest.mark.sandbox\n+@pytest.mark.skipif(not has_format, reason='No format support')\n+class TestStringFormat(object):\n+\n+    def test_basic_format_safety(self):\n+        env = SandboxedEnvironment()\n+        t = env.from_string('{{ \"a{0.__class__}b\".format(42) }}')\n+        assert t.render() == 'ab'\n+\n+    def test_basic_format_all_okay(self):\n+        env = SandboxedEnvironment()\n+        t = env.from_string('{{ \"a{0.foo}b\".format({\"foo\": 42}) }}')\n+        assert t.render() == 'a42b'\n+\n+    def test_basic_format_safety(self):\n+        env = SandboxedEnvironment()\n+        t = env.from_string('{{ (\"a{0.__class__}b{1}\"|safe).format(42, \"<foo>\") }}')\n+        assert t.render() == 'ab&lt;foo&gt;'\n+\n+    def test_basic_format_all_okay(self):\n+        env = SandboxedEnvironment()\n+        t = env.from_string('{{ (\"a{0.foo}b{1}\"|safe).format({\"foo\": 42}, \"<foo>\") }}')\n+        assert t.render() == 'a42b&lt;foo&gt;'"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "6aeab5d1da0bc0793406d7b402693e779b6cca7a",
            "date": "2024-12-21T18:47:46Z",
            "author_login": "davidism"
          },
          {
            "sha": "ab8218c7a1b66b62e0ad6b941bd514e3a64a358f",
            "date": "2024-12-21T18:47:08Z",
            "author_login": "davidism"
          },
          {
            "sha": "b4ffc8ff299dfd360064bea4cd2f862364601ad2",
            "date": "2024-12-21T18:30:50Z",
            "author_login": "davidism"
          },
          {
            "sha": "877f6e51be8e1765b06d911cfaa9033775f051d1",
            "date": "2024-12-21T18:16:13Z",
            "author_login": "davidism"
          },
          {
            "sha": "8d588592653b052f957b720e1fc93196e06f207f",
            "date": "2024-12-21T18:14:49Z",
            "author_login": "davidism"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-134",
    "description": "In Pallets Jinja before 2.8.1, str.format allows a sandbox escape.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2019-04-08T13:29:00.280",
    "last_modified": "2024-11-21T02:44:39.103",
    "fix_date": "2016-12-29T13:13:38Z"
  },
  "references": [
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2019-05/msg00030.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00064.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:1022",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:1237",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:1260",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:3964",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:4062",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/pallets/jinja/commit/9b53045c34e61013dc8f09b7e52a555fa16bed16",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://palletsprojects.com/blog/jinja-281-released/",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://usn.ubuntu.com/4011-1/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://usn.ubuntu.com/4011-2/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2019-05/msg00030.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00064.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:1022",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:1237",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:1260",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:3964",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:4062",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/pallets/jinja/commit/9b53045c34e61013dc8f09b7e52a555fa16bed16",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://palletsprojects.com/blog/jinja-281-released/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://usn.ubuntu.com/4011-1/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://usn.ubuntu.com/4011-2/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:47.018878",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "jinja",
    "owner": "pallets",
    "created_at": "2010-10-17T13:41:17Z",
    "updated_at": "2025-01-14T17:14:56Z",
    "pushed_at": "2025-01-13T18:59:03Z",
    "size": 6851,
    "stars": 10514,
    "forks": 1626,
    "open_issues": 78,
    "watchers": 10514,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "stable"
    ],
    "languages": {
      "Python": 765568,
      "Shell": 165,
      "HTML": 81
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T17:33:24.688545"
  }
}