{
  "cve_id": "CVE-2016-2513",
  "github_data": {
    "repository": "django/django",
    "fix_commit": "67b46ba7016da2d259c1ecc7d666d11f5e1cfaab",
    "related_commits": [
      "67b46ba7016da2d259c1ecc7d666d11f5e1cfaab",
      "67b46ba7016da2d259c1ecc7d666d11f5e1cfaab"
    ],
    "patch_url": "https://github.com/django/django/commit/67b46ba7016da2d259c1ecc7d666d11f5e1cfaab.patch",
    "fix_commit_details": {
      "sha": "67b46ba7016da2d259c1ecc7d666d11f5e1cfaab",
      "commit_date": "2016-02-13T20:09:46Z",
      "author": {
        "login": "apollo13",
        "type": "User",
        "stats": {
          "total_commits": 302,
          "average_weekly_commits": 0.296368989205103,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 134
        }
      },
      "commit_message": {
        "title": "Fixed CVE-2016-2513 -- Fixed user enumeration timing attack during login.",
        "length": 98,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 232,
        "additions": 211,
        "deletions": 21
      },
      "files": [
        {
          "filename": "django/contrib/auth/hashers.py",
          "status": "modified",
          "additions": 57,
          "deletions": 20,
          "patch": "@@ -4,6 +4,7 @@\n import binascii\n import hashlib\n import importlib\n+import warnings\n from collections import OrderedDict\n \n from django.conf import settings\n@@ -46,10 +47,17 @@ def check_password(password, encoded, setter=None, preferred='default'):\n     preferred = get_hasher(preferred)\n     hasher = identify_hasher(encoded)\n \n-    must_update = hasher.algorithm != preferred.algorithm\n-    if not must_update:\n-        must_update = preferred.must_update(encoded)\n+    hasher_changed = hasher.algorithm != preferred.algorithm\n+    must_update = hasher_changed or preferred.must_update(encoded)\n     is_correct = hasher.verify(password, encoded)\n+\n+    # If the hasher didn't change (we don't protect against enumeration if it\n+    # does) and the password should get updated, try to close the timing gap\n+    # between the work factor of the current encoded password and the default\n+    # work factor.\n+    if not is_correct and not hasher_changed and must_update:\n+        hasher.harden_runtime(password, encoded)\n+\n     if setter and is_correct and must_update:\n         setter(password)\n     return is_correct\n@@ -216,6 +224,19 @@ def safe_summary(self, encoded):\n     def must_update(self, encoded):\n         return False\n \n+    def harden_runtime(self, password, encoded):\n+        \"\"\"\n+        Bridge the runtime gap between the work factor supplied in `encoded`\n+        and the work factor suggested by this hasher.\n+\n+        Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and\n+        `self.iterations` is 30000, this method should run password through\n+        another 10000 iterations of PBKDF2. Similar approaches should exist\n+        for any hasher that has a work factor. If not, this method should be\n+        defined as a no-op to silence the warning.\n+        \"\"\"\n+        warnings.warn('subclasses of BasePasswordHasher should provide a harden_runtime() method')\n+\n \n class PBKDF2PasswordHasher(BasePasswordHasher):\n     \"\"\"\n@@ -258,6 +279,12 @@ def must_update(self, encoded):\n         algorithm, iterations, salt, hash = encoded.split('$', 3)\n         return int(iterations) != self.iterations\n \n+    def harden_runtime(self, password, encoded):\n+        algorithm, iterations, salt, hash = encoded.split('$', 3)\n+        extra_iterations = self.iterations - int(iterations)\n+        if extra_iterations > 0:\n+            self.encode(password, salt, extra_iterations)\n+\n \n class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):\n     \"\"\"\n@@ -305,23 +332,8 @@ def encode(self, password, salt):\n     def verify(self, password, encoded):\n         algorithm, data = encoded.split('$', 1)\n         assert algorithm == self.algorithm\n-        bcrypt = self._load_library()\n-\n-        # Hash the password prior to using bcrypt to prevent password\n-        # truncation as described in #20138.\n-        if self.digest is not None:\n-            # Use binascii.hexlify() because a hex encoded bytestring is\n-            # Unicode on Python 3.\n-            password = binascii.hexlify(self.digest(force_bytes(password)).digest())\n-        else:\n-            password = force_bytes(password)\n-\n-        # Ensure that our data is a bytestring\n-        data = force_bytes(data)\n-        # force_bytes() necessary for py-bcrypt compatibility\n-        hashpw = force_bytes(bcrypt.hashpw(password, data))\n-\n-        return constant_time_compare(data, hashpw)\n+        encoded_2 = self.encode(password, force_bytes(data))\n+        return constant_time_compare(encoded, encoded_2)\n \n     def safe_summary(self, encoded):\n         algorithm, empty, algostr, work_factor, data = encoded.split('$', 4)\n@@ -338,6 +350,16 @@ def must_update(self, encoded):\n         algorithm, empty, algostr, rounds, data = encoded.split('$', 4)\n         return int(rounds) != self.rounds\n \n+    def harden_runtime(self, password, encoded):\n+        _, data = encoded.split('$', 1)\n+        salt = data[:29]  # Length of the salt in bcrypt.\n+        rounds = data.split('$')[2]\n+        # work factor is logarithmic, adding one doubles the load.\n+        diff = 2**(self.rounds - int(rounds)) - 1\n+        while diff > 0:\n+            self.encode(password, force_bytes(salt))\n+            diff -= 1\n+\n \n class BCryptPasswordHasher(BCryptSHA256PasswordHasher):\n     \"\"\"\n@@ -385,6 +407,9 @@ def safe_summary(self, encoded):\n             (_('hash'), mask_hash(hash)),\n         ])\n \n+    def harden_runtime(self, password, encoded):\n+        pass\n+\n \n class MD5PasswordHasher(BasePasswordHasher):\n     \"\"\"\n@@ -413,6 +438,9 @@ def safe_summary(self, encoded):\n             (_('hash'), mask_hash(hash)),\n         ])\n \n+    def harden_runtime(self, password, encoded):\n+        pass\n+\n \n class UnsaltedSHA1PasswordHasher(BasePasswordHasher):\n     \"\"\"\n@@ -445,6 +473,9 @@ def safe_summary(self, encoded):\n             (_('hash'), mask_hash(hash)),\n         ])\n \n+    def harden_runtime(self, password, encoded):\n+        pass\n+\n \n class UnsaltedMD5PasswordHasher(BasePasswordHasher):\n     \"\"\"\n@@ -478,6 +509,9 @@ def safe_summary(self, encoded):\n             (_('hash'), mask_hash(encoded, show=3)),\n         ])\n \n+    def harden_runtime(self, password, encoded):\n+        pass\n+\n \n class CryptPasswordHasher(BasePasswordHasher):\n     \"\"\"\n@@ -512,3 +546,6 @@ def safe_summary(self, encoded):\n             (_('salt'), salt),\n             (_('hash'), mask_hash(data, show=3)),\n         ])\n+\n+    def harden_runtime(self, password, encoded):\n+        pass"
        },
        {
          "filename": "docs/releases/1.8.10.txt",
          "status": "modified",
          "additions": 33,
          "deletions": 0,
          "patch": "@@ -22,6 +22,39 @@ redirecting to this URL sends the user to ``attacker.com``.\n Also, if a developer relies on ``is_safe_url()`` to provide safe redirect\n targets and puts such a URL into a link, they could suffer from an XSS attack.\n \n+CVE-2016-2513: User enumeration through timing difference on password hasher work factor upgrade\n+================================================================================================\n+\n+In each major version of Django since 1.6, the default number of iterations for\n+the ``PBKDF2PasswordHasher`` and its subclasses has increased. This improves\n+the security of the password as the speed of hardware increases, however, it\n+also creates a timing difference between a login request for a user with a\n+password encoded in an older number of iterations and login request for a\n+nonexistent user (which runs the default hasher's default number of iterations\n+since Django 1.6).\n+\n+This only affects users who haven't logged in since the iterations were\n+increased. The first time a user logs in after an iterations increase, their\n+password is updated with the new iterations and there is no longer a timing\n+difference.\n+\n+The new ``BasePasswordHasher.harden_runtime()`` method allows hashers to bridge\n+the runtime gap between the work factor (e.g. iterations) supplied in existing\n+encoded passwords and the default work factor of the hasher. This method\n+is implemented for ``PBKDF2PasswordHasher``  and ``BCryptPasswordHasher``.\n+The number of rounds for the latter hasher hasn't changed since Django 1.4, but\n+some projects may subclass it and increase the work factor as needed.\n+\n+A warning will be emitted for any :ref:`third-party password hashers that don't\n+implement <write-your-own-password-hasher>` a ``harden_runtime()`` method.\n+\n+If you have different password hashes in your database (such as SHA1 hashes\n+from users who haven't logged in since the default hasher switched to PBKDF2\n+in Django 1.4), the timing difference on a login request for these users may be\n+even greater and this fix doesn't remedy that difference (or any difference\n+when changing hashers). You may be able to :ref:`upgrade those hashes\n+<wrapping-password-hashers>` to prevent a timing attack for that case.\n+\n Bugfixes\n ========\n "
        },
        {
          "filename": "docs/releases/1.9.3.txt",
          "status": "modified",
          "additions": 33,
          "deletions": 0,
          "patch": "@@ -22,6 +22,39 @@ redirecting to this URL sends the user to ``attacker.com``.\n Also, if a developer relies on ``is_safe_url()`` to provide safe redirect\n targets and puts such a URL into a link, they could suffer from an XSS attack.\n \n+CVE-2016-2513: User enumeration through timing difference on password hasher work factor upgrade\n+================================================================================================\n+\n+In each major version of Django since 1.6, the default number of iterations for\n+the ``PBKDF2PasswordHasher`` and its subclasses has increased. This improves\n+the security of the password as the speed of hardware increases, however, it\n+also creates a timing difference between a login request for a user with a\n+password encoded in an older number of iterations and login request for a\n+nonexistent user (which runs the default hasher's default number of iterations\n+since Django 1.6).\n+\n+This only affects users who haven't logged in since the iterations were\n+increased. The first time a user logs in after an iterations increase, their\n+password is updated with the new iterations and there is no longer a timing\n+difference.\n+\n+The new ``BasePasswordHasher.harden_runtime()`` method allows hashers to bridge\n+the runtime gap between the work factor (e.g. iterations) supplied in existing\n+encoded passwords and the default work factor of the hasher. This method\n+is implemented for ``PBKDF2PasswordHasher``  and ``BCryptPasswordHasher``.\n+The number of rounds for the latter hasher hasn't changed since Django 1.4, but\n+some projects may subclass it and increase the work factor as needed.\n+\n+A warning will be emitted for any :ref:`third-party password hashers that don't\n+implement <write-your-own-password-hasher>` a ``harden_runtime()`` method.\n+\n+If you have different password hashes in your database (such as SHA1 hashes\n+from users who haven't logged in since the default hasher switched to PBKDF2\n+in Django 1.4), the timing difference on a login request for these users may be\n+even greater and this fix doesn't remedy that difference (or any difference\n+when changing hashers). You may be able to :ref:`upgrade those hashes\n+<wrapping-password-hashers>` to prevent a timing attack for that case.\n+\n Bugfixes\n ========\n "
        },
        {
          "filename": "docs/topics/auth/passwords.txt",
          "status": "modified",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -186,6 +186,14 @@ unmentioned algorithms won't be able to upgrade. Hashed passwords will be\n updated when increasing (or decreasing) the number of PBKDF2 iterations or\n bcrypt rounds.\n \n+Be aware that if all the passwords in your database aren't encoded in the\n+default hasher's algorithm, you may be vulnerable to a user enumeration timing\n+attack due to a difference between the duration of a login request for a user\n+with a password encoded in a non-default algorithm and the duration of a login\n+request for a nonexistent user (which runs the default hasher). You may be able\n+to mitigate this by :ref:`upgrading older password hashes\n+<wrapping-password-hashers>`.\n+\n .. versionchanged:: 1.9\n \n     Passwords updates when changing the number of bcrypt rounds was added.\n@@ -310,6 +318,29 @@ The corresponding algorithm names are:\n * ``unsalted_md5``\n * ``crypt``\n \n+.. _write-your-own-password-hasher:\n+\n+Writing your own hasher\n+-----------------------\n+\n+.. versionadded:: 1.9.3\n+\n+If you write your own password hasher that contains a work factor such as a\n+number of iterations, you should implement a\n+``harden_runtime(self, password, encoded)`` method to bridge the runtime gap\n+between the work factor supplied in the ``encoded`` password and the default\n+work factor of the hasher. This prevents a user enumeration timing attack due\n+to  difference between a login request for a user with a password encoded in an\n+older number of iterations and a nonexistent user (which runs the default\n+hasher's default number of iterations).\n+\n+Taking PBKDF2 as example, if ``encoded`` contains 20,000 iterations and the\n+hasher's default ``iterations`` is 30,000, the method should run ``password``\n+through another 10,000 iterations of PBKDF2.\n+\n+If your hasher doesn't have a work factor, implement the method as a no-op\n+(``pass``).\n+\n Manually managing a user's password\n ===================================\n "
        },
        {
          "filename": "tests/auth_tests/test_hashers.py",
          "status": "modified",
          "additions": 57,
          "deletions": 1,
          "patch": "@@ -10,9 +10,10 @@\n     check_password, get_hasher, identify_hasher, is_password_usable,\n     make_password,\n )\n-from django.test import SimpleTestCase\n+from django.test import SimpleTestCase, mock\n from django.test.utils import override_settings\n from django.utils import six\n+from django.utils.encoding import force_bytes\n \n try:\n     import crypt\n@@ -214,6 +215,28 @@ def setter(password):\n         finally:\n             hasher.rounds = old_rounds\n \n+    @skipUnless(bcrypt, \"bcrypt not installed\")\n+    def test_bcrypt_harden_runtime(self):\n+        hasher = get_hasher('bcrypt')\n+        self.assertEqual('bcrypt', hasher.algorithm)\n+\n+        with mock.patch.object(hasher, 'rounds', 4):\n+            encoded = make_password('letmein', hasher='bcrypt')\n+\n+        with mock.patch.object(hasher, 'rounds', 6), \\\n+                mock.patch.object(hasher, 'encode', side_effect=hasher.encode):\n+            hasher.harden_runtime('wrong_password', encoded)\n+\n+            # Increasing rounds from 4 to 6 means an increase of 4 in workload,\n+            # therefore hardening should run 3 times to make the timing the\n+            # same (the original encode() call already ran once).\n+            self.assertEqual(hasher.encode.call_count, 3)\n+\n+            # Get the original salt (includes the original workload factor)\n+            algorithm, data = encoded.split('$', 1)\n+            expected_call = (('wrong_password', force_bytes(data[:29])),)\n+            self.assertEqual(hasher.encode.call_args_list, [expected_call] * 3)\n+\n     def test_unusable(self):\n         encoded = make_password(None)\n         self.assertEqual(len(encoded), len(UNUSABLE_PASSWORD_PREFIX) + UNUSABLE_PASSWORD_SUFFIX_LENGTH)\n@@ -337,6 +360,25 @@ def setter(password):\n         finally:\n             hasher.iterations = old_iterations\n \n+    def test_pbkdf2_harden_runtime(self):\n+        hasher = get_hasher('default')\n+        self.assertEqual('pbkdf2_sha256', hasher.algorithm)\n+\n+        with mock.patch.object(hasher, 'iterations', 1):\n+            encoded = make_password('letmein')\n+\n+        with mock.patch.object(hasher, 'iterations', 6), \\\n+                mock.patch.object(hasher, 'encode', side_effect=hasher.encode):\n+            hasher.harden_runtime('wrong_password', encoded)\n+\n+            # Encode should get called once ...\n+            self.assertEqual(hasher.encode.call_count, 1)\n+\n+            # ... with the original salt and 5 iterations.\n+            algorithm, iterations, salt, hash = encoded.split('$', 3)\n+            expected_call = (('wrong_password', salt, 5),)\n+            self.assertEqual(hasher.encode.call_args, expected_call)\n+\n     def test_pbkdf2_upgrade_new_hasher(self):\n         hasher = get_hasher('default')\n         self.assertEqual('pbkdf2_sha256', hasher.algorithm)\n@@ -365,6 +407,20 @@ def setter(password):\n             self.assertTrue(check_password('letmein', encoded, setter))\n             self.assertTrue(state['upgraded'])\n \n+    def test_check_password_calls_harden_runtime(self):\n+        hasher = get_hasher('default')\n+        encoded = make_password('letmein')\n+\n+        with mock.patch.object(hasher, 'harden_runtime'), \\\n+                mock.patch.object(hasher, 'must_update', return_value=True):\n+            # Correct password supplied, no hardening needed\n+            check_password('letmein', encoded)\n+            self.assertEqual(hasher.harden_runtime.call_count, 0)\n+\n+            # Wrong password supplied, hardening needed\n+            check_password('wrong_password', encoded)\n+            self.assertEqual(hasher.harden_runtime.call_count, 1)\n+\n     def test_load_library_no_algorithm(self):\n         with self.assertRaises(ValueError) as e:\n             BasePasswordHasher()._load_library()"
        }
      ],
      "file_patterns": {
        "security_files": 3,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b721f127603516c75ebda6912046ff5f0694e150",
            "date": "2024-10-11T11:44:12Z",
            "author_login": "sarahboyce"
          },
          {
            "sha": "d206d4c200d71c0847e7f6720d88c587e7b46843",
            "date": "2025-01-01T20:27:52Z",
            "author_login": "jacobtylerwalls"
          },
          {
            "sha": "f07360e8087d3b403d1d12ff696da3138116055a",
            "date": "2025-01-14T03:04:33Z",
            "author_login": "charettes"
          },
          {
            "sha": "161e79d277ffe8b79b15ad51cb0d23de54270202",
            "date": "2025-01-13T18:55:41Z",
            "author_login": "charettes"
          },
          {
            "sha": "4bfec242b488b174f7d386ab5bbd3363751cdb93",
            "date": "2025-01-13T18:53:57Z",
            "author_login": "charettes"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-200",
    "description": "The password hasher in contrib/auth/hashers.py in Django before 1.8.10 and 1.9.x before 1.9.3 allows remote attackers to enumerate users via a timing attack involving login requests.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2016-04-08T15:59:07.230",
    "last_modified": "2024-11-21T02:48:35.850",
    "fix_date": "2016-02-13T20:09:46Z"
  },
  "references": [
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-0502.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-0504.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-0505.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-0506.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2016/dsa-3544",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.oracle.com/technetwork/topics/security/bulletinapr2016-2952098.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/83878",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.securitytracker.com/id/1035152",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2915-1",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2915-2",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2915-3",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/django/django/commit/67b46ba7016da2d259c1ecc7d666d11f5e1cfaab",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://www.djangoproject.com/weblog/2016/mar/01/security-releases/",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-0502.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-0504.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-0505.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-0506.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2016/dsa-3544",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.oracle.com/technetwork/topics/security/bulletinapr2016-2952098.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/83878",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securitytracker.com/id/1035152",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2915-1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2915-2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.ubuntu.com/usn/USN-2915-3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/django/django/commit/67b46ba7016da2d259c1ecc7d666d11f5e1cfaab",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://www.djangoproject.com/weblog/2016/mar/01/security-releases/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:40.219029",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "django",
    "owner": "django",
    "created_at": "2012-04-28T02:47:18Z",
    "updated_at": "2025-01-14T13:27:58Z",
    "pushed_at": "2025-01-14T11:34:55Z",
    "size": 264981,
    "stars": 81851,
    "forks": 32045,
    "open_issues": 301,
    "watchers": 81851,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "stable/0.90.x",
      "stable/0.91.x",
      "stable/0.95.x",
      "stable/0.96.x",
      "stable/1.0.x",
      "stable/1.1.x",
      "stable/1.2.x",
      "stable/1.3.x",
      "stable/1.4.x",
      "stable/1.5.x",
      "stable/1.6.x",
      "stable/1.7.x",
      "stable/1.8.x",
      "stable/1.9.x",
      "stable/1.10.x",
      "stable/1.11.x",
      "stable/2.0.x",
      "stable/2.1.x",
      "stable/2.2.x",
      "stable/3.0.x",
      "stable/3.1.x",
      "stable/3.2.x",
      "stable/4.0.x",
      "stable/4.1.x",
      "stable/4.2.x",
      "stable/5.0.x",
      "stable/5.1.x"
    ],
    "languages": {
      "Python": 17607947,
      "HTML": 250858,
      "JavaScript": 158876,
      "CSS": 92030,
      "Smarty": 392,
      "Procfile": 47
    },
    "commit_activity": {
      "total_commits_last_year": 938,
      "avg_commits_per_week": 18.03846153846154,
      "days_active_last_year": 299
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T13:28:27.491590"
  }
}