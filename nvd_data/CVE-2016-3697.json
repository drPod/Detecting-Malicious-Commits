{
  "cve_id": "CVE-2016-3697",
  "github_data": {
    "repository": "opencontainers/runc",
    "fix_commit": "69af385de62ea68e2e608335cffbb0f4aa3db091",
    "related_commits": [
      "69af385de62ea68e2e608335cffbb0f4aa3db091",
      "69af385de62ea68e2e608335cffbb0f4aa3db091"
    ],
    "patch_url": "https://github.com/opencontainers/runc/commit/69af385de62ea68e2e608335cffbb0f4aa3db091.patch",
    "fix_commit_details": {
      "sha": "69af385de62ea68e2e608335cffbb0f4aa3db091",
      "commit_date": "2016-03-30T11:48:07Z",
      "author": {
        "login": "cyphar",
        "type": "User",
        "stats": {
          "total_commits": 316,
          "average_weekly_commits": 0.5543859649122806,
          "total_additions": 157715,
          "total_deletions": 12850,
          "weeks_active": 142
        }
      },
      "commit_message": {
        "title": "libcontainer: user: always treat numeric ids numerically",
        "length": 362,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 89,
        "additions": 57,
        "deletions": 32
      },
      "files": [
        {
          "filename": "libcontainer/user/user.go",
          "status": "modified",
          "additions": 57,
          "deletions": 32,
          "patch": "@@ -235,10 +235,14 @@ func GetExecUserPath(userSpec string, defaults *ExecUser, passwdPath, groupPath\n //     * \"uid:gid\n //     * \"user:gid\"\n //     * \"uid:group\"\n+//\n+// It should be noted that if you specify a numeric user or group id, they will\n+// not be evaluated as usernames (only the metadata will be filled). So attempting\n+// to parse a user with user.Name = \"1337\" will produce the user with a UID of\n+// 1337.\n func GetExecUser(userSpec string, defaults *ExecUser, passwd, group io.Reader) (*ExecUser, error) {\n \tvar (\n \t\tuserArg, groupArg string\n-\t\tname              string\n \t)\n \n \tif defaults == nil {\n@@ -261,11 +265,22 @@ func GetExecUser(userSpec string, defaults *ExecUser, passwd, group io.Reader) (\n \t// allow for userArg to have either \"user\" syntax, or optionally \"user:group\" syntax\n \tparseLine(userSpec, &userArg, &groupArg)\n \n+\t// Convert userArg and groupArg to be numeric, so we don't have to execute\n+\t// Atoi *twice* for each iteration over lines.\n+\tuidArg, uidErr := strconv.Atoi(userArg)\n+\tgidArg, gidErr := strconv.Atoi(groupArg)\n+\n \tusers, err := ParsePasswdFilter(passwd, func(u User) bool {\n \t\tif userArg == \"\" {\n \t\t\treturn u.Uid == user.Uid\n \t\t}\n-\t\treturn u.Name == userArg || strconv.Itoa(u.Uid) == userArg\n+\n+\t\tif uidErr == nil {\n+\t\t\t// If the userArg is numeric, always treat it as a UID.\n+\t\t\treturn uidArg == u.Uid\n+\t\t}\n+\n+\t\treturn u.Name == userArg\n \t})\n \tif err != nil && passwd != nil {\n \t\tif userArg == \"\" {\n@@ -274,71 +289,81 @@ func GetExecUser(userSpec string, defaults *ExecUser, passwd, group io.Reader) (\n \t\treturn nil, fmt.Errorf(\"Unable to find user %v: %v\", userArg, err)\n \t}\n \n-\thaveUser := users != nil && len(users) > 0\n-\tif haveUser {\n-\t\t// if we found any user entries that matched our filter, let's take the first one as \"correct\"\n-\t\tname = users[0].Name\n+\tvar matchedUserName string\n+\tif len(users) > 0 {\n+\t\t// First match wins, even if there's more than one matching entry.\n+\t\tmatchedUserName = users[0].Name\n \t\tuser.Uid = users[0].Uid\n \t\tuser.Gid = users[0].Gid\n \t\tuser.Home = users[0].Home\n \t} else if userArg != \"\" {\n-\t\t// we asked for a user but didn't find them...  let's check to see if we wanted a numeric user\n-\t\tuser.Uid, err = strconv.Atoi(userArg)\n-\t\tif err != nil {\n-\t\t\t// not numeric - we have to bail\n-\t\t\treturn nil, fmt.Errorf(\"Unable to find user %v\", userArg)\n+\t\t// If we can't find a user with the given username, the only other valid\n+\t\t// option is if it's a numeric username with no associated entry in passwd.\n+\n+\t\tif uidErr != nil {\n+\t\t\t// Not numeric.\n+\t\t\treturn nil, fmt.Errorf(\"unable to find user %s: %v\", userArg, ErrNoPasswdEntries)\n \t\t}\n+\t\tuser.Uid = uidArg\n \n \t\t// Must be inside valid uid range.\n \t\tif user.Uid < minId || user.Uid > maxId {\n \t\t\treturn nil, ErrRange\n \t\t}\n \n-\t\t// if userArg couldn't be found in /etc/passwd but is numeric, just roll with it - this is legit\n+\t\t// Okay, so it's numeric. We can just roll with this.\n \t}\n \n-\tif groupArg != \"\" || name != \"\" {\n+\t// On to the groups. If we matched a username, we need to do this because of\n+\t// the supplementary group IDs.\n+\tif groupArg != \"\" || matchedUserName != \"\" {\n \t\tgroups, err := ParseGroupFilter(group, func(g Group) bool {\n-\t\t\t// Explicit group format takes precedence.\n-\t\t\tif groupArg != \"\" {\n-\t\t\t\treturn g.Name == groupArg || strconv.Itoa(g.Gid) == groupArg\n+\t\t\t// If the group argument isn't explicit, we'll just search for it.\n+\t\t\tif groupArg == \"\" {\n+\t\t\t\t// Check if user is a member of this group.\n+\t\t\t\tfor _, u := range g.List {\n+\t\t\t\t\tif u == matchedUserName {\n+\t\t\t\t\t\treturn true\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn false\n \t\t\t}\n \n-\t\t\t// Check if user is a member.\n-\t\t\tfor _, u := range g.List {\n-\t\t\t\tif u == name {\n-\t\t\t\t\treturn true\n-\t\t\t\t}\n+\t\t\tif gidErr == nil {\n+\t\t\t\t// If the groupArg is numeric, always treat it as a GID.\n+\t\t\t\treturn gidArg == g.Gid\n \t\t\t}\n \n-\t\t\treturn false\n+\t\t\treturn g.Name == groupArg\n \t\t})\n \t\tif err != nil && group != nil {\n-\t\t\treturn nil, fmt.Errorf(\"Unable to find groups for user %v: %v\", users[0].Name, err)\n+\t\t\treturn nil, fmt.Errorf(\"unable to find groups for spec %v: %v\", matchedUserName, err)\n \t\t}\n \n \t\thaveGroup := groups != nil && len(groups) > 0\n \t\tif groupArg != \"\" {\n \t\t\tif haveGroup {\n \t\t\t\t// if we found any group entries that matched our filter, let's take the first one as \"correct\"\n \t\t\t\tuser.Gid = groups[0].Gid\n-\t\t\t} else {\n-\t\t\t\t// we asked for a group but didn't find id...  let's check to see if we wanted a numeric group\n-\t\t\t\tuser.Gid, err = strconv.Atoi(groupArg)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\t// not numeric - we have to bail\n-\t\t\t\t\treturn nil, fmt.Errorf(\"Unable to find group %v\", groupArg)\n+\t\t\t} else if groupArg != \"\" {\n+\t\t\t\t// If we can't find a group with the given name, the only other valid\n+\t\t\t\t// option is if it's a numeric group name with no associated entry in group.\n+\n+\t\t\t\tif gidErr != nil {\n+\t\t\t\t\t// Not numeric.\n+\t\t\t\t\treturn nil, fmt.Errorf(\"unable to find group %s: %v\", groupArg, ErrNoGroupEntries)\n \t\t\t\t}\n+\t\t\t\tuser.Gid = gidArg\n \n \t\t\t\t// Ensure gid is inside gid range.\n \t\t\t\tif user.Gid < minId || user.Gid > maxId {\n \t\t\t\t\treturn nil, ErrRange\n \t\t\t\t}\n \n-\t\t\t\t// if groupArg couldn't be found in /etc/group but is numeric, just roll with it - this is legit\n+\t\t\t\t// Okay, so it's numeric. We can just roll with this.\n \t\t\t}\n-\t\t} else if haveGroup {\n-\t\t\t// If implicit group format, fill supplementary gids.\n+\t\t} else if len(groups) > 0 {\n+\t\t\t// Supplementary group ids only make sense if in the implicit form.\n \t\t\tuser.Sgids = make([]int, len(groups))\n \t\t\tfor i, group := range groups {\n \t\t\t\tuser.Sgids[i] = group.Gid"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "610aa88ab201f289c05c2e262912d0630f46eb35",
            "date": "2025-01-10T20:23:22Z",
            "author_login": "kolyshkin"
          },
          {
            "sha": "4120935737a51cbf23676977cc8bf0b6717702f1",
            "date": "2025-01-09T10:45:31Z",
            "author_login": "lifubang"
          },
          {
            "sha": "06f1e0765576dcf6d8c2ef5e56d309618310992c",
            "date": "2024-06-23T23:31:57Z",
            "author_login": "kolyshkin"
          },
          {
            "sha": "6171da60058fe58c6bd2f2a4ae8be381cfc12cce",
            "date": "2024-12-23T01:32:02Z",
            "author_login": "kolyshkin"
          },
          {
            "sha": "c49b89168140c70dc1badd17d5ed361788898fe9",
            "date": "2024-12-21T19:52:25Z",
            "author_login": "kolyshkin"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.8,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-264",
    "description": "libcontainer/user/user.go in runC before 0.1.0, as used in Docker before 1.11.2, improperly treats a numeric UID as a potential username, which allows local users to gain privileges via a numeric username in the password file in a container.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2016-06-01T20:59:06.137",
    "last_modified": "2024-11-21T02:50:31.670",
    "fix_date": "2016-03-30T11:48:07Z"
  },
  "references": [
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2016-05/msg00111.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-1034.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-2634.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/docker/docker/issues/21436",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/commit/69af385de62ea68e2e608335cffbb0f4aa3db091",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/pull/708",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/releases/tag/v0.1.0",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201612-28",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2016-05/msg00111.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-1034.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-2634.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/docker/docker/issues/21436",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/commit/69af385de62ea68e2e608335cffbb0f4aa3db091",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/pull/708",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/releases/tag/v0.1.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201612-28",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:42.556032",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "runc",
    "owner": "opencontainers",
    "created_at": "2015-06-05T23:30:45Z",
    "updated_at": "2025-01-14T11:33:23Z",
    "pushed_at": "2025-01-13T07:56:10Z",
    "size": 21572,
    "stars": 12051,
    "forks": 2130,
    "open_issues": 365,
    "watchers": 12051,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-1.0",
      "release-1.1",
      "release-1.2"
    ],
    "languages": {
      "Go": 1253070,
      "Shell": 305324,
      "C": 45119,
      "Makefile": 7226,
      "Dockerfile": 2644,
      "Ruby": 2035
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:26:33.730029"
  }
}