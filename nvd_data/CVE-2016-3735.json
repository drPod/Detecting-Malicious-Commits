{
  "cve_id": "CVE-2016-3735",
  "github_data": {
    "repository": "Piwigo/Piwigo",
    "fix_commit": "f51ee90c66527fd7ff634f3e8d414cb670da068d",
    "related_commits": [
      "f51ee90c66527fd7ff634f3e8d414cb670da068d",
      "f51ee90c66527fd7ff634f3e8d414cb670da068d"
    ],
    "patch_url": "https://github.com/Piwigo/Piwigo/commit/f51ee90c66527fd7ff634f3e8d414cb670da068d.patch",
    "fix_commit_details": {
      "sha": "f51ee90c66527fd7ff634f3e8d414cb670da068d",
      "commit_date": "2016-04-26T09:07:44Z",
      "author": {
        "login": "plegall",
        "type": "User",
        "stats": {
          "total_commits": 2218,
          "average_weekly_commits": 1.9576345984112975,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 558
        }
      },
      "commit_message": {
        "title": "bug #470, use a dedicated lib to generate random bytes",
        "length": 54,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 1196,
        "additions": 1170,
        "deletions": 26
      },
      "files": [
        {
          "filename": "include/functions_session.inc.php",
          "status": "modified",
          "additions": 11,
          "deletions": 26,
          "patch": "@@ -62,32 +62,17 @@\n  */\n function generate_key($size)\n {\n-  if (\n-    is_callable('openssl_random_pseudo_bytes')\n-    and !(version_compare(PHP_VERSION, '5.3.4') < 0 and defined('PHP_WINDOWS_VERSION_MAJOR'))\n-    )\n-  {\n-    return substr(\n-      str_replace(\n-        array('+', '/'),\n-        '',\n-        base64_encode(openssl_random_pseudo_bytes($size+10))\n-        ),\n-      0,\n-      $size\n-      );\n-  }\n-  else\n-  {\n-    $alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n-    $l = strlen($alphabet)-1;\n-    $key = '';\n-    for ($i=0; $i<$size; $i++)\n-    {\n-      $key.= $alphabet[mt_rand(0, $l)];\n-    }\n-    return $key;\n-  }\n+  include_once(PHPWG_ROOT_PATH.'include/random_compat/random.php');\n+\n+  return substr(\n+    str_replace(\n+      array('+', '/'),\n+      '',\n+      base64_encode(random_bytes($size+10))\n+      ),\n+    0,\n+    $size\n+    );\n }\n \n /**"
        },
        {
          "filename": "include/random_compat/byte_safe_strings.php",
          "status": "added",
          "additions": 181,
          "deletions": 0,
          "patch": "@@ -0,0 +1,181 @@\n+<?php\n+/**\n+ * Random_* Compatibility Library\n+ * for using the new PHP 7 random_* API in PHP 5 projects\n+ *\n+ * The MIT License (MIT)\n+ *\n+ * Copyright (c) 2015 Paragon Initiative Enterprises\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+\n+if (!function_exists('RandomCompat_strlen')) {\n+    if (\n+        defined('MB_OVERLOAD_STRING') &&\n+        ini_get('mbstring.func_overload') & MB_OVERLOAD_STRING\n+    ) {\n+        /**\n+         * strlen() implementation that isn't brittle to mbstring.func_overload\n+         *\n+         * This version uses mb_strlen() in '8bit' mode to treat strings as raw\n+         * binary rather than UTF-8, ISO-8859-1, etc\n+         *\n+         * @param string $binary_string\n+         *\n+         * @throws TypeError\n+         *\n+         * @return int\n+         */\n+        function RandomCompat_strlen($binary_string)\n+        {\n+            if (!is_string($binary_string)) {\n+                throw new TypeError(\n+                    'RandomCompat_strlen() expects a string'\n+                );\n+            }\n+\n+            return mb_strlen($binary_string, '8bit');\n+        }\n+\n+    } else {\n+        /**\n+         * strlen() implementation that isn't brittle to mbstring.func_overload\n+         *\n+         * This version just used the default strlen()\n+         *\n+         * @param string $binary_string\n+         *\n+         * @throws TypeError\n+         *\n+         * @return int\n+         */\n+        function RandomCompat_strlen($binary_string)\n+        {\n+            if (!is_string($binary_string)) {\n+                throw new TypeError(\n+                    'RandomCompat_strlen() expects a string'\n+                );\n+            }\n+            return strlen($binary_string);\n+        }\n+    }\n+}\n+\n+if (!function_exists('RandomCompat_substr')) {\n+\n+    if (\n+        defined('MB_OVERLOAD_STRING')\n+        &&\n+        ini_get('mbstring.func_overload') & MB_OVERLOAD_STRING\n+    ) {\n+        /**\n+         * substr() implementation that isn't brittle to mbstring.func_overload\n+         *\n+         * This version uses mb_substr() in '8bit' mode to treat strings as raw\n+         * binary rather than UTF-8, ISO-8859-1, etc\n+         *\n+         * @param string $binary_string\n+         * @param int $start\n+         * @param int $length (optional)\n+         *\n+         * @throws TypeError\n+         *\n+         * @return string\n+         */\n+        function RandomCompat_substr($binary_string, $start, $length = null)\n+        {\n+            if (!is_string($binary_string)) {\n+                throw new TypeError(\n+                    'RandomCompat_substr(): First argument should be a string'\n+                );\n+            }\n+\n+            if (!is_int($start)) {\n+                throw new TypeError(\n+                    'RandomCompat_substr(): Second argument should be an integer'\n+                );\n+            }\n+\n+            if ($length === null) {\n+                /**\n+                 * mb_substr($str, 0, NULL, '8bit') returns an empty string on\n+                 * PHP 5.3, so we have to find the length ourselves.\n+                 */\n+                $length = RandomCompat_strlen($length) - $start;\n+            } elseif (!is_int($length)) {\n+                throw new TypeError(\n+                    'RandomCompat_substr(): Third argument should be an integer, or omitted'\n+                );\n+            }\n+\n+            // Consistency with PHP's behavior\n+            if ($start === RandomCompat_strlen($binary_string) && $length === 0) {\n+                return '';\n+            }\n+            if ($start > RandomCompat_strlen($binary_string)) {\n+                return false;\n+            }\n+\n+            return mb_substr($binary_string, $start, $length, '8bit');\n+        }\n+\n+    } else {\n+\n+        /**\n+         * substr() implementation that isn't brittle to mbstring.func_overload\n+         *\n+         * This version just uses the default substr()\n+         *\n+         * @param string $binary_string\n+         * @param int $start\n+         * @param int $length (optional)\n+         *\n+         * @throws TypeError\n+         *\n+         * @return string\n+         */\n+        function RandomCompat_substr($binary_string, $start, $length = null)\n+        {\n+            if (!is_string($binary_string)) {\n+                throw new TypeError(\n+                    'RandomCompat_substr(): First argument should be a string'\n+                );\n+            }\n+\n+            if (!is_int($start)) {\n+                throw new TypeError(\n+                    'RandomCompat_substr(): Second argument should be an integer'\n+                );\n+            }\n+\n+            if ($length !== null) {\n+                if (!is_int($length)) {\n+                    throw new TypeError(\n+                        'RandomCompat_substr(): Third argument should be an integer, or omitted'\n+                    );\n+                }\n+\n+                return substr($binary_string, $start, $length);\n+            }\n+\n+            return substr($binary_string, $start);\n+        }\n+    }\n+}"
        },
        {
          "filename": "include/random_compat/cast_to_int.php",
          "status": "added",
          "additions": 71,
          "deletions": 0,
          "patch": "@@ -0,0 +1,71 @@\n+<?php\n+/**\n+ * Random_* Compatibility Library\n+ * for using the new PHP 7 random_* API in PHP 5 projects\n+ *\n+ * The MIT License (MIT)\n+ *\n+ * Copyright (c) 2015 Paragon Initiative Enterprises\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+\n+if (!function_exists('RandomCompat_intval')) {\n+    \n+    /**\n+     * Cast to an integer if we can, safely.\n+     * \n+     * If you pass it a float in the range (~PHP_INT_MAX, PHP_INT_MAX)\n+     * (non-inclusive), it will sanely cast it to an int. If you it's equal to\n+     * ~PHP_INT_MAX or PHP_INT_MAX, we let it fail as not an integer. Floats \n+     * lose precision, so the <= and => operators might accidentally let a float\n+     * through.\n+     * \n+     * @param int|float $number    The number we want to convert to an int\n+     * @param boolean   $fail_open Set to true to not throw an exception\n+     * \n+     * @return int (or float if $fail_open)\n+     *\n+     * @throws TypeError\n+     */\n+    function RandomCompat_intval($number, $fail_open = false)\n+    {\n+        if (is_numeric($number)) {\n+            $number += 0;\n+        }\n+\n+        if (\n+            is_float($number)\n+            &&\n+            $number > ~PHP_INT_MAX\n+            &&\n+            $number < PHP_INT_MAX\n+        ) {\n+            $number = (int) $number;\n+        }\n+\n+        if (is_int($number) || $fail_open) {\n+            return $number;\n+        }\n+\n+        throw new TypeError(\n+            'Expected an integer.'\n+        );\n+    }\n+}"
        },
        {
          "filename": "include/random_compat/error_polyfill.php",
          "status": "added",
          "additions": 42,
          "deletions": 0,
          "patch": "@@ -0,0 +1,42 @@\n+<?php\n+/**\n+ * Random_* Compatibility Library \n+ * for using the new PHP 7 random_* API in PHP 5 projects\n+ * \n+ * The MIT License (MIT)\n+ * \n+ * Copyright (c) 2015 Paragon Initiative Enterprises\n+ * \n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ * \n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ * \n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+\n+if (!class_exists('Error', false)) {\n+    // We can't really avoid making this extend Exception in PHP 5.\n+    class Error extends Exception\n+    {\n+        \n+    }\n+}\n+\n+if (!class_exists('TypeError', false)) {\n+    class TypeError extends Error\n+    {\n+        \n+    }\n+}"
        },
        {
          "filename": "include/random_compat/random.php",
          "status": "added",
          "additions": 197,
          "deletions": 0,
          "patch": "@@ -0,0 +1,197 @@\n+<?php\n+/**\n+ * Random_* Compatibility Library\n+ * for using the new PHP 7 random_* API in PHP 5 projects\n+ *\n+ * @version 2.0.2\n+ * @released 2016-04-03\n+ *\n+ * The MIT License (MIT)\n+ *\n+ * Copyright (c) 2015 Paragon Initiative Enterprises\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+\n+if (!defined('PHP_VERSION_ID')) {\n+    // This constant was introduced in PHP 5.2.7\n+    $RandomCompatversion = explode('.', PHP_VERSION);\n+    define(\n+        'PHP_VERSION_ID',\n+        $RandomCompatversion[0] * 10000\n+        + $RandomCompatversion[1] * 100\n+        + $RandomCompatversion[2]\n+    );\n+    $RandomCompatversion = null;\n+}\n+\n+if (PHP_VERSION_ID < 70000) {\n+\n+    if (!defined('RANDOM_COMPAT_READ_BUFFER')) {\n+        define('RANDOM_COMPAT_READ_BUFFER', 8);\n+    }\n+\n+    $RandomCompatDIR = dirname(__FILE__);\n+\n+    require_once $RandomCompatDIR.'/byte_safe_strings.php';\n+    require_once $RandomCompatDIR.'/cast_to_int.php';\n+    require_once $RandomCompatDIR.'/error_polyfill.php';\n+\n+    if (!function_exists('random_bytes')) {\n+        /**\n+         * PHP 5.2.0 - 5.6.x way to implement random_bytes()\n+         *\n+         * We use conditional statements here to define the function in accordance\n+         * to the operating environment. It's a micro-optimization.\n+         *\n+         * In order of preference:\n+         *   1. Use libsodium if available.\n+         *   2. fread() /dev/urandom if available (never on Windows)\n+         *   3. mcrypt_create_iv($bytes, MCRYPT_DEV_URANDOM)\n+         *   4. COM('CAPICOM.Utilities.1')->GetRandom()\n+         *   5. openssl_random_pseudo_bytes() (absolute last resort)\n+         *\n+         * See ERRATA.md for our reasoning behind this particular order\n+         */\n+        if (extension_loaded('libsodium')) {\n+            // See random_bytes_libsodium.php\n+            if (PHP_VERSION_ID >= 50300 && function_exists('\\\\Sodium\\\\randombytes_buf')) {\n+                require_once $RandomCompatDIR.'/random_bytes_libsodium.php';\n+            } elseif (method_exists('Sodium', 'randombytes_buf')) {\n+                require_once $RandomCompatDIR.'/random_bytes_libsodium_legacy.php';\n+            }\n+        }\n+\n+        /**\n+         * Reading directly from /dev/urandom:\n+         */\n+        if (DIRECTORY_SEPARATOR === '/') {\n+            // DIRECTORY_SEPARATOR === '/' on Unix-like OSes -- this is a fast\n+            // way to exclude Windows.\n+            $RandomCompatUrandom = true;\n+            $RandomCompat_basedir = ini_get('open_basedir');\n+\n+            if (!empty($RandomCompat_basedir)) {\n+                $RandomCompat_open_basedir = explode(\n+                    PATH_SEPARATOR,\n+                    strtolower($RandomCompat_basedir)\n+                );\n+                $RandomCompatUrandom = (array() !== array_intersect(\n+                    array('/dev', '/dev/', '/dev/urandom'),\n+                    $RandomCompat_open_basedir\n+                ));\n+                $RandomCompat_open_basedir = null;\n+            }\n+\n+            if (\n+                !function_exists('random_bytes')\n+                &&\n+                $RandomCompatUrandom\n+                &&\n+                @is_readable('/dev/urandom')\n+            ) {\n+                // Error suppression on is_readable() in case of an open_basedir\n+                // or safe_mode failure. All we care about is whether or not we\n+                // can read it at this point. If the PHP environment is going to\n+                // panic over trying to see if the file can be read in the first\n+                // place, that is not helpful to us here.\n+\n+                // See random_bytes_dev_urandom.php\n+                require_once $RandomCompatDIR.'/random_bytes_dev_urandom.php';\n+            }\n+            // Unset variables after use\n+            $RandomCompat_basedir = null;\n+        } else {\n+            $RandomCompatUrandom = false;\n+        }\n+\n+        /**\n+         * mcrypt_create_iv()\n+         */\n+        if (\n+            !function_exists('random_bytes')\n+            &&\n+            PHP_VERSION_ID >= 50307\n+            &&\n+            extension_loaded('mcrypt')\n+            &&\n+            (DIRECTORY_SEPARATOR !== '/' || $RandomCompatUrandom)\n+        ) {\n+            // Prevent this code from hanging indefinitely on non-Windows;\n+            // see https://bugs.php.net/bug.php?id=69833\n+            if (\n+                DIRECTORY_SEPARATOR !== '/' || \n+                (PHP_VERSION_ID <= 50609 || PHP_VERSION_ID >= 50613)\n+            ) {\n+                // See random_bytes_mcrypt.php\n+                require_once $RandomCompatDIR.'/random_bytes_mcrypt.php';\n+            }\n+        }\n+        $RandomCompatUrandom = null;\n+\n+        if (\n+            !function_exists('random_bytes')\n+            &&\n+            extension_loaded('com_dotnet')\n+            &&\n+            class_exists('COM')\n+        ) {\n+            $RandomCompat_disabled_classes = preg_split(\n+                '#\\s*,\\s*#',\n+                strtolower(ini_get('disable_classes'))\n+            );\n+\n+            if (!in_array('com', $RandomCompat_disabled_classes)) {\n+                try {\n+                    $RandomCompatCOMtest = new COM('CAPICOM.Utilities.1');\n+                    if (method_exists($RandomCompatCOMtest, 'GetRandom')) {\n+                        // See random_bytes_com_dotnet.php\n+                        require_once $RandomCompatDIR.'/random_bytes_com_dotnet.php';\n+                    }\n+                } catch (com_exception $e) {\n+                    // Don't try to use it.\n+                }\n+            }\n+            $RandomCompat_disabled_classes = null;\n+            $RandomCompatCOMtest = null;\n+        }\n+\n+        /**\n+         * throw new Exception\n+         */\n+        if (!function_exists('random_bytes')) {\n+            /**\n+             * We don't have any more options, so let's throw an exception right now\n+             * and hope the developer won't let it fail silently.\n+             */\n+            function random_bytes($length)\n+            {\n+                throw new Exception(\n+                    'There is no suitable CSPRNG installed on your system'\n+                );\n+            }\n+        }\n+    }\n+\n+    if (!function_exists('random_int')) {\n+        require_once $RandomCompatDIR.'/random_int.php';\n+    }\n+\n+    $RandomCompatDIR = null;\n+}"
        },
        {
          "filename": "include/random_compat/random_bytes_com_dotnet.php",
          "status": "added",
          "additions": 81,
          "deletions": 0,
          "patch": "@@ -0,0 +1,81 @@\n+<?php\n+/**\n+ * Random_* Compatibility Library \n+ * for using the new PHP 7 random_* API in PHP 5 projects\n+ * \n+ * The MIT License (MIT)\n+ * \n+ * Copyright (c) 2015 Paragon Initiative Enterprises\n+ * \n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ * \n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ * \n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+\n+/**\n+ * Windows with PHP < 5.3.0 will not have the function\n+ * openssl_random_pseudo_bytes() available, so let's use\n+ * CAPICOM to work around this deficiency.\n+ * \n+ * @param int $bytes\n+ * \n+ * @throws Exception\n+ * \n+ * @return string\n+ */\n+function random_bytes($bytes)\n+{\n+    try {\n+        $bytes = RandomCompat_intval($bytes);\n+    } catch (TypeError $ex) {\n+        throw new TypeError(\n+            'random_bytes(): $bytes must be an integer'\n+        );\n+    }\n+\n+    if ($bytes < 1) {\n+        throw new Error(\n+            'Length must be greater than 0'\n+        );\n+    }\n+\n+    $buf = '';\n+    $util = new COM('CAPICOM.Utilities.1');\n+    $execCount = 0;\n+\n+    /**\n+     * Let's not let it loop forever. If we run N times and fail to\n+     * get N bytes of random data, then CAPICOM has failed us.\n+     */\n+    do {\n+        $buf .= base64_decode($util->GetRandom($bytes, 0));\n+        if (RandomCompat_strlen($buf) >= $bytes) {\n+            /**\n+             * Return our random entropy buffer here:\n+             */\n+            return RandomCompat_substr($buf, 0, $bytes);\n+        }\n+        ++$execCount; \n+    } while ($execCount < $bytes);\n+\n+    /**\n+     * If we reach here, PHP has failed us.\n+     */\n+    throw new Exception(\n+        'Could not gather sufficient random data'\n+    );\n+}"
        },
        {
          "filename": "include/random_compat/random_bytes_dev_urandom.php",
          "status": "added",
          "additions": 148,
          "deletions": 0,
          "patch": "@@ -0,0 +1,148 @@\n+<?php\n+/**\n+ * Random_* Compatibility Library \n+ * for using the new PHP 7 random_* API in PHP 5 projects\n+ * \n+ * The MIT License (MIT)\n+ * \n+ * Copyright (c) 2015 Paragon Initiative Enterprises\n+ * \n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ * \n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ * \n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+\n+if (!defined('RANDOM_COMPAT_READ_BUFFER')) {\n+    define('RANDOM_COMPAT_READ_BUFFER', 8);\n+}\n+\n+/**\n+ * Unless open_basedir is enabled, use /dev/urandom for\n+ * random numbers in accordance with best practices\n+ * \n+ * Why we use /dev/urandom and not /dev/random\n+ * @ref http://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers\n+ * \n+ * @param int $bytes\n+ * \n+ * @throws Exception\n+ * \n+ * @return string\n+ */\n+function random_bytes($bytes)\n+{\n+    static $fp = null;\n+    /**\n+     * This block should only be run once\n+     */\n+    if (empty($fp)) {\n+        /**\n+         * We use /dev/urandom if it is a char device.\n+         * We never fall back to /dev/random\n+         */\n+        $fp = fopen('/dev/urandom', 'rb');\n+        if (!empty($fp)) {\n+            $st = fstat($fp);\n+            if (($st['mode'] & 0170000) !== 020000) {\n+                fclose($fp);\n+                $fp = false;\n+            }\n+        }\n+\n+        if (!empty($fp)) {\n+            /**\n+             * stream_set_read_buffer() does not exist in HHVM\n+             * \n+             * If we don't set the stream's read buffer to 0, PHP will\n+             * internally buffer 8192 bytes, which can waste entropy\n+             * \n+             * stream_set_read_buffer returns 0 on success\n+             */\n+            if (function_exists('stream_set_read_buffer')) {\n+                stream_set_read_buffer($fp, RANDOM_COMPAT_READ_BUFFER);\n+            }\n+            if (function_exists('stream_set_chunk_size')) {\n+                stream_set_chunk_size($fp, RANDOM_COMPAT_READ_BUFFER);\n+            }\n+        }\n+    }\n+\n+    try {\n+        $bytes = RandomCompat_intval($bytes);\n+    } catch (TypeError $ex) {\n+        throw new TypeError(\n+            'random_bytes(): $bytes must be an integer'\n+        );\n+    }\n+\n+    if ($bytes < 1) {\n+        throw new Error(\n+            'Length must be greater than 0'\n+        );\n+    }\n+\n+    /**\n+     * This if() block only runs if we managed to open a file handle\n+     * \n+     * It does not belong in an else {} block, because the above \n+     * if (empty($fp)) line is logic that should only be run once per\n+     * page load.\n+     */\n+    if (!empty($fp)) {\n+        $remaining = $bytes;\n+        $buf = '';\n+\n+        /**\n+         * We use fread() in a loop to protect against partial reads\n+         */\n+        do {\n+            $read = fread($fp, $remaining); \n+            if ($read === false) {\n+                /**\n+                 * We cannot safely read from the file. Exit the\n+                 * do-while loop and trigger the exception condition\n+                 */\n+                $buf = false;\n+                break;\n+            }\n+            /**\n+             * Decrease the number of bytes returned from remaining\n+             */\n+            $remaining -= RandomCompat_strlen($read);\n+            $buf .= $read;\n+        } while ($remaining > 0);\n+        \n+        /**\n+         * Is our result valid?\n+         */\n+        if ($buf !== false) {\n+            if (RandomCompat_strlen($buf) === $bytes) {\n+                /**\n+                 * Return our random entropy buffer here:\n+                 */\n+                return $buf;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * If we reach here, PHP has failed us.\n+     */\n+    throw new Exception(\n+        'Error reading from source device'\n+    );\n+}"
        },
        {
          "filename": "include/random_compat/random_bytes_libsodium.php",
          "status": "added",
          "additions": 86,
          "deletions": 0,
          "patch": "@@ -0,0 +1,86 @@\n+<?php\n+/**\n+ * Random_* Compatibility Library \n+ * for using the new PHP 7 random_* API in PHP 5 projects\n+ * \n+ * The MIT License (MIT)\n+ * \n+ * Copyright (c) 2015 Paragon Initiative Enterprises\n+ * \n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ * \n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ * \n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+\n+/**\n+ * If the libsodium PHP extension is loaded, we'll use it above any other\n+ * solution.\n+ *\n+ * libsodium-php project:\n+ * @ref https://github.com/jedisct1/libsodium-php\n+ *\n+ * @param int $bytes\n+ *\n+ * @throws Exception\n+ *\n+ * @return string\n+ */\n+function random_bytes($bytes)\n+{\n+    try {\n+        $bytes = RandomCompat_intval($bytes);\n+    } catch (TypeError $ex) {\n+        throw new TypeError(\n+            'random_bytes(): $bytes must be an integer'\n+        );\n+    }\n+\n+    if ($bytes < 1) {\n+        throw new Error(\n+            'Length must be greater than 0'\n+        );\n+    }\n+\n+    /**\n+     * \\Sodium\\randombytes_buf() doesn't allow more than 2147483647 bytes to be\n+     * generated in one invocation.\n+     */\n+    if ($bytes > 2147483647) {\n+        $buf = '';\n+        for ($i = 0; $i < $bytes; $i += 1073741824) {\n+            $n = ($bytes - $i) > 1073741824\n+                ? 1073741824\n+                : $bytes - $i;\n+            $buf .= \\Sodium\\randombytes_buf($n);\n+        }\n+    } else {\n+        $buf = \\Sodium\\randombytes_buf($bytes);\n+    }\n+\n+    if ($buf !== false) {\n+        if (RandomCompat_strlen($buf) === $bytes) {\n+            return $buf;\n+        }\n+    }\n+\n+    /**\n+     * If we reach here, PHP has failed us.\n+     */\n+    throw new Exception(\n+        'Could not gather sufficient random data'\n+    );\n+}"
        },
        {
          "filename": "include/random_compat/random_bytes_libsodium_legacy.php",
          "status": "added",
          "additions": 86,
          "deletions": 0,
          "patch": "@@ -0,0 +1,86 @@\n+<?php\n+/**\n+ * Random_* Compatibility Library \n+ * for using the new PHP 7 random_* API in PHP 5 projects\n+ * \n+ * The MIT License (MIT)\n+ * \n+ * Copyright (c) 2015 Paragon Initiative Enterprises\n+ * \n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ * \n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ * \n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+\n+/**\n+ * If the libsodium PHP extension is loaded, we'll use it above any other\n+ * solution.\n+ *\n+ * libsodium-php project:\n+ * @ref https://github.com/jedisct1/libsodium-php\n+ *\n+ * @param int $bytes\n+ *\n+ * @throws Exception\n+ *\n+ * @return string\n+ */\n+function random_bytes($bytes)\n+{\n+    try {\n+        $bytes = RandomCompat_intval($bytes);\n+    } catch (TypeError $ex) {\n+        throw new TypeError(\n+            'random_bytes(): $bytes must be an integer'\n+        );\n+    }\n+\n+    if ($bytes < 1) {\n+        throw new Error(\n+            'Length must be greater than 0'\n+        );\n+    }\n+\n+    /**\n+     * \\Sodium\\randombytes_buf() doesn't allow more than 2147483647 bytes to be\n+     * generated in one invocation.\n+     */\n+    if ($bytes > 2147483647) {\n+        $buf = '';\n+        for ($i = 0; $i < $bytes; $i += 1073741824) {\n+            $n = ($bytes - $i) > 1073741824\n+                ? 1073741824\n+                : $bytes - $i;\n+            $buf .= Sodium::randombytes_buf($n);\n+        }\n+    } else {\n+        $buf = Sodium::randombytes_buf($bytes);\n+    }\n+\n+    if ($buf !== false) {\n+        if (RandomCompat_strlen($buf) === $bytes) {\n+            return $buf;\n+        }\n+    }\n+\n+    /**\n+     * If we reach here, PHP has failed us.\n+     */\n+    throw new Exception(\n+        'Could not gather sufficient random data'\n+    );\n+}"
        },
        {
          "filename": "include/random_compat/random_bytes_mcrypt.php",
          "status": "added",
          "additions": 76,
          "deletions": 0,
          "patch": "@@ -0,0 +1,76 @@\n+<?php\n+/**\n+ * Random_* Compatibility Library \n+ * for using the new PHP 7 random_* API in PHP 5 projects\n+ * \n+ * The MIT License (MIT)\n+ * \n+ * Copyright (c) 2015 Paragon Initiative Enterprises\n+ * \n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ * \n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ * \n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+\n+\n+/**\n+ * Powered by ext/mcrypt (and thankfully NOT libmcrypt)\n+ * \n+ * @ref https://bugs.php.net/bug.php?id=55169\n+ * @ref https://github.com/php/php-src/blob/c568ffe5171d942161fc8dda066bce844bdef676/ext/mcrypt/mcrypt.c#L1321-L1386\n+ * \n+ * @param int $bytes\n+ * \n+ * @throws Exception\n+ * \n+ * @return string\n+ */\n+function random_bytes($bytes)\n+{\n+    try {\n+        $bytes = RandomCompat_intval($bytes);\n+    } catch (TypeError $ex) {\n+        throw new TypeError(\n+            'random_bytes(): $bytes must be an integer'\n+        );\n+    }\n+\n+    if ($bytes < 1) {\n+        throw new Error(\n+            'Length must be greater than 0'\n+        );\n+    }\n+\n+    $buf = @mcrypt_create_iv($bytes, MCRYPT_DEV_URANDOM);\n+    if (\n+        $buf !== false\n+        &&\n+        RandomCompat_strlen($buf) === $bytes\n+    ) {\n+        /**\n+         * Return our random entropy buffer here:\n+         */\n+        return $buf;\n+    }\n+\n+    /**\n+     * If we reach here, PHP has failed us.\n+     */\n+    throw new Exception(\n+        'Could not gather sufficient random data'\n+    );\n+}"
        },
        {
          "filename": "include/random_compat/random_int.php",
          "status": "added",
          "additions": 191,
          "deletions": 0,
          "patch": "@@ -0,0 +1,191 @@\n+<?php\n+/**\n+ * Random_* Compatibility Library \n+ * for using the new PHP 7 random_* API in PHP 5 projects\n+ * \n+ * The MIT License (MIT)\n+ * \n+ * Copyright (c) 2015 Paragon Initiative Enterprises\n+ * \n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ * \n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ * \n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+\n+/**\n+ * Fetch a random integer between $min and $max inclusive\n+ * \n+ * @param int $min\n+ * @param int $max\n+ * \n+ * @throws Exception\n+ * \n+ * @return int\n+ */\n+function random_int($min, $max)\n+{\n+    /**\n+     * Type and input logic checks\n+     * \n+     * If you pass it a float in the range (~PHP_INT_MAX, PHP_INT_MAX)\n+     * (non-inclusive), it will sanely cast it to an int. If you it's equal to\n+     * ~PHP_INT_MAX or PHP_INT_MAX, we let it fail as not an integer. Floats \n+     * lose precision, so the <= and => operators might accidentally let a float\n+     * through.\n+     */\n+    \n+    try {\n+        $min = RandomCompat_intval($min);\n+    } catch (TypeError $ex) {\n+        throw new TypeError(\n+            'random_int(): $min must be an integer'\n+        );\n+    }\n+\n+    try {\n+        $max = RandomCompat_intval($max);\n+    } catch (TypeError $ex) {\n+        throw new TypeError(\n+            'random_int(): $max must be an integer'\n+        );\n+    }\n+    \n+    /**\n+     * Now that we've verified our weak typing system has given us an integer,\n+     * let's validate the logic then we can move forward with generating random\n+     * integers along a given range.\n+     */\n+    if ($min > $max) {\n+        throw new Error(\n+            'Minimum value must be less than or equal to the maximum value'\n+        );\n+    }\n+\n+    if ($max === $min) {\n+        return $min;\n+    }\n+\n+    /**\n+     * Initialize variables to 0\n+     * \n+     * We want to store:\n+     * $bytes => the number of random bytes we need\n+     * $mask => an integer bitmask (for use with the &) operator\n+     *          so we can minimize the number of discards\n+     */\n+    $attempts = $bits = $bytes = $mask = $valueShift = 0;\n+\n+    /**\n+     * At this point, $range is a positive number greater than 0. It might\n+     * overflow, however, if $max - $min > PHP_INT_MAX. PHP will cast it to\n+     * a float and we will lose some precision.\n+     */\n+    $range = $max - $min;\n+\n+    /**\n+     * Test for integer overflow:\n+     */\n+    if (!is_int($range)) {\n+\n+        /**\n+         * Still safely calculate wider ranges.\n+         * Provided by @CodesInChaos, @oittaa\n+         * \n+         * @ref https://gist.github.com/CodesInChaos/03f9ea0b58e8b2b8d435\n+         * \n+         * We use ~0 as a mask in this case because it generates all 1s\n+         * \n+         * @ref https://eval.in/400356 (32-bit)\n+         * @ref http://3v4l.org/XX9r5  (64-bit)\n+         */\n+        $bytes = PHP_INT_SIZE;\n+        $mask = ~0;\n+\n+    } else {\n+\n+        /**\n+         * $bits is effectively ceil(log($range, 2)) without dealing with \n+         * type juggling\n+         */\n+        while ($range > 0) {\n+            if ($bits % 8 === 0) {\n+               ++$bytes;\n+            }\n+            ++$bits;\n+            $range >>= 1;\n+            $mask = $mask << 1 | 1;\n+        }\n+        $valueShift = $min;\n+    }\n+\n+    /**\n+     * Now that we have our parameters set up, let's begin generating\n+     * random integers until one falls between $min and $max\n+     */\n+    do {\n+        /**\n+         * The rejection probability is at most 0.5, so this corresponds\n+         * to a failure probability of 2^-128 for a working RNG\n+         */\n+        if ($attempts > 128) {\n+            throw new Exception(\n+                'random_int: RNG is broken - too many rejections'\n+            );\n+        }\n+\n+        /**\n+         * Let's grab the necessary number of random bytes\n+         */\n+        $randomByteString = random_bytes($bytes);\n+        if ($randomByteString === false) {\n+            throw new Exception(\n+                'Random number generator failure'\n+            );\n+        }\n+\n+        /**\n+         * Let's turn $randomByteString into an integer\n+         * \n+         * This uses bitwise operators (<< and |) to build an integer\n+         * out of the values extracted from ord()\n+         * \n+         * Example: [9F] | [6D] | [32] | [0C] =>\n+         *   159 + 27904 + 3276800 + 201326592 =>\n+         *   204631455\n+         */\n+        $val = 0;\n+        for ($i = 0; $i < $bytes; ++$i) {\n+            $val |= ord($randomByteString[$i]) << ($i * 8);\n+        }\n+\n+        /**\n+         * Apply mask\n+         */\n+        $val &= $mask;\n+        $val += $valueShift;\n+\n+        ++$attempts;\n+        /**\n+         * If $val overflows to a floating point number,\n+         * ... or is larger than $max,\n+         * ... or smaller than $min,\n+         * then try again.\n+         */\n+    } while (!is_int($val) || $val > $max || $val < $min);\n+\n+    return (int) $val;\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "28a676b2d9e83319a4ad33deb0eda610a0674aab",
            "date": "2025-01-10T09:59:56Z",
            "author_login": "plegall"
          },
          {
            "sha": "64064b59741f5522c8d9e2cf392c90ffd43313c7",
            "date": "2025-01-09T09:33:09Z",
            "author_login": "LintyDev"
          },
          {
            "sha": "0cce9ef09d2d4012e580d507e6b363bc2ec044ea",
            "date": "2025-01-08T15:38:07Z",
            "author_login": "HWFord"
          },
          {
            "sha": "94148e0323230b74e2f2deb4e5753f6488c3fea7",
            "date": "2025-01-08T12:56:20Z",
            "author_login": "winstoy"
          },
          {
            "sha": "5b7fffe78684903e2599421f6e504062e57a4da7",
            "date": "2025-01-08T10:33:27Z",
            "author_login": "HWFord"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-335",
    "description": "Piwigo is image gallery software written in PHP. When a criteria is not met on a host, piwigo defaults to usingmt_rand in order to generate password reset tokens. mt_rand output can be predicted after recovering the seed used to generate it. This low an unauthenticated attacker to take over an account providing they know an administrators email address in order to be able to request password reset.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-01-28T20:15:08.437",
    "last_modified": "2024-11-21T02:50:36.240",
    "fix_date": "2016-04-26T09:07:44Z"
  },
  "references": [
    {
      "url": "http://piwigo.org/release-2.8.1%2C",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://github.com/Piwigo/Piwigo/commit/f51ee90c66527fd7ff634f3e8d414cb670da068d",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Piwigo/Piwigo/issues/470%2C",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://piwigo.org/release-2.8.1%2C",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/Piwigo/Piwigo/commit/f51ee90c66527fd7ff634f3e8d414cb670da068d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Piwigo/Piwigo/issues/470%2C",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:57.091461",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "Piwigo",
    "owner": "Piwigo",
    "created_at": "2015-07-25T11:32:24Z",
    "updated_at": "2025-01-14T04:03:21Z",
    "pushed_at": "2025-01-13T14:23:21Z",
    "size": 75667,
    "stars": 3333,
    "forks": 449,
    "open_issues": 707,
    "watchers": 3333,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "PHP": 11006322,
      "HTML": 1488753,
      "JavaScript": 1039903,
      "Smarty": 656950,
      "CSS": 398303,
      "Yacc": 40453,
      "Perl": 27807,
      "Less": 5561,
      "Shell": 3901,
      "SCSS": 2818,
      "PureBasic": 2731
    },
    "commit_activity": {
      "total_commits_last_year": 249,
      "avg_commits_per_week": 4.788461538461538,
      "days_active_last_year": 118
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T13:37:56.448058"
  }
}