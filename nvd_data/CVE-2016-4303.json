{
  "cve_id": "CVE-2016-4303",
  "github_data": {
    "repository": "esnet/iperf",
    "fix_commit": "91f2fa59e8ed80dfbf400add0164ee0e508e412a",
    "related_commits": [
      "91f2fa59e8ed80dfbf400add0164ee0e508e412a",
      "91f2fa59e8ed80dfbf400add0164ee0e508e412a"
    ],
    "patch_url": "https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a.patch",
    "fix_commit_details": {
      "sha": "91f2fa59e8ed80dfbf400add0164ee0e508e412a",
      "commit_date": "2016-06-03T16:23:59Z",
      "author": {
        "login": "bmah888",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix a buffer overflow / heap corruption issue that could occur if a",
        "length": 608,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 1624,
        "additions": 697,
        "deletions": 927
      },
      "files": [
        {
          "filename": "configure.ac",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -62,6 +62,12 @@ AC_HEADER_STDC\n # Check for systems which need -lsocket and -lnsl\n #AX_LIB_SOCKET_NSL\n \n+# Check for the math library (needed by cjson on some platforms)\n+AC_SEARCH_LIBS(floor, [m], [], [\n+echo \"floor()\"\n+exit 1\n+])\n+\n # Solaris puts nanosleep in -lrt\n AC_SEARCH_LIBS(nanosleep, [rt], [], [\n echo \"nanosleep() required for timing operations.\""
        },
        {
          "filename": "src/cjson.c",
          "status": "modified",
          "additions": 571,
          "deletions": 842,
          "patch": "@@ -40,994 +40,723 @@\n #ifndef LLONG_MIN\n #define LLONG_MIN (-LLONG_MAX - 1LL)\n #endif\n+static const char *global_ep;\n \n+const char *cJSON_GetErrorPtr(void) {return global_ep;}\n \n-static const char *ep;\n-\n-const char *cJSON_GetErrorPtr( void )\n-{\n-\treturn ep;\n-}\n-\n-\n-static int cJSON_strcasecmp( const char *s1, const char *s2 )\n+static int cJSON_strcasecmp(const char *s1,const char *s2)\n {\n-\tif ( ! s1 )\n-\t\treturn ( s1 == s2 ) ? 0 : 1;\n-\tif ( ! s2 )\n-\t\treturn 1;\n-\tfor ( ; tolower(*s1) == tolower(*s2); ++s1, ++s2)\n-\t\tif( *s1 == 0 )\n-\t\t\treturn 0;\n+\tif (!s1) return (s1==s2)?0:1;if (!s2) return 1;\n+\tfor(; tolower(*s1) == tolower(*s2); ++s1, ++s2)\tif(*s1 == 0)\treturn 0;\n \treturn tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);\n }\n \n+static void *(*cJSON_malloc)(size_t sz) = malloc;\n+static void (*cJSON_free)(void *ptr) = free;\n \n-static void *(*cJSON_malloc)( size_t ) = malloc;\n-static void (*cJSON_free)( void * ) = free;\n-\n-void cJSON_InitHooks(cJSON_Hooks* hooks)\n+static char* cJSON_strdup(const char* str)\n {\n-\tif ( ! hooks ) {\n-\t\t/* Reset hooks. */\n-\t\tcJSON_malloc = malloc;\n-\t\tcJSON_free = free;\n-\t\treturn;\n-\t}\n-\tcJSON_malloc = (hooks->malloc_fn) ? hooks->malloc_fn : malloc;\n-\tcJSON_free = (hooks->free_fn) ? hooks->free_fn : free;\n-}\n+      size_t len;\n+      char* copy;\n \n+      len = strlen(str) + 1;\n+      if (!(copy = (char*)cJSON_malloc(len))) return 0;\n+      memcpy(copy,str,len);\n+      return copy;\n+}\n \n-static char* cJSON_strdup( const char* str )\n+void cJSON_InitHooks(cJSON_Hooks* hooks)\n {\n-\tsize_t len;\n-\tchar* copy;\n+    if (!hooks) { /* Reset hooks */\n+        cJSON_malloc = malloc;\n+        cJSON_free = free;\n+        return;\n+    }\n \n-\tlen = strlen( str ) + 1;\n-\tif ( ! ( copy = (char*) cJSON_malloc( len ) ) )\n-\t\treturn 0;\n-\tmemcpy( copy, str, len );\n-\treturn copy;\n+\tcJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;\n+\tcJSON_free\t = (hooks->free_fn)?hooks->free_fn:free;\n }\n \n-\n /* Internal constructor. */\n-static cJSON *cJSON_New_Item( void )\n+static cJSON *cJSON_New_Item(void)\n {\n-\tcJSON* node = (cJSON*) cJSON_malloc( sizeof(cJSON) );\n-\tif ( node )\n-\t\tmemset( node, 0, sizeof(cJSON) );\n+\tcJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));\n+\tif (node) memset(node,0,sizeof(cJSON));\n \treturn node;\n }\n \n-\n /* Delete a cJSON structure. */\n-void cJSON_Delete( cJSON *c )\n+void cJSON_Delete(cJSON *c)\n {\n \tcJSON *next;\n-\n-\twhile ( c ) {\n-\t\tnext = c->next;\n-\t\tif ( ! ( c->type & cJSON_IsReference ) && c->child )\n-\t\t\tcJSON_Delete( c->child );\n-\t\tif ( ! ( c->type & cJSON_IsReference ) && c->valuestring )\n-\t\t\tcJSON_free( c->valuestring );\n-\t\tif ( c->string )\n-\t\t\tcJSON_free( c->string );\n-\t\tcJSON_free( c );\n-\t\tc = next;\n+\twhile (c)\n+\t{\n+\t\tnext=c->next;\n+\t\tif (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);\n+\t\tif (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);\n+\t\tif (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);\n+\t\tcJSON_free(c);\n+\t\tc=next;\n \t}\n }\n \n-\n-static double ipow( double n, int exp )\n+/* Parse the input text to generate a number, and populate the result into item. */\n+static const char *parse_number(cJSON *item,const char *num)\n {\n-\tdouble r;\n+\tdouble n=0,sign=1,scale=0;int subscale=0,signsubscale=1;\n \n-\tif ( exp < 0 )\n-\t\treturn 1.0 / ipow( n, -exp );\n-\tr = 1;\n-\twhile ( exp > 0 ) {\n-\t\tif ( exp & 1 )\n-\t\t\tr *= n;\n-\t\texp >>= 1;\n-\t\tn *= n;\n+\tif (*num=='-') sign=-1,num++;\t/* Has sign? */\n+\tif (*num=='0') num++;\t\t\t/* is zero */\n+\tif (*num>='1' && *num<='9')\tdo\tn=(n*10.0)+(*num++ -'0');\twhile (*num>='0' && *num<='9');\t/* Number? */\n+\tif (*num=='.' && num[1]>='0' && num[1]<='9') {num++;\t\tdo\tn=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}\t/* Fractional part? */\n+\tif (*num=='e' || *num=='E')\t\t/* Exponent? */\n+\t{\tnum++;if (*num=='+') num++;\telse if (*num=='-') signsubscale=-1,num++;\t\t/* With sign? */\n+\t\twhile (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');\t/* Number? */\n \t}\n-\treturn r;\n-}\n \n+\tn=sign*n*pow(10.0,(scale+subscale*signsubscale));\t/* number = +/- number.fraction * 10^+/- exponent */\n+\t\n+\titem->valuedouble=n;\n+\titem->valueint=(int64_t)n;\n+\titem->type=cJSON_Number;\n+\treturn num;\n+}\n \n-/* Parse the input text to generate a number, and populate the result into item. */\n-static const char *parse_number( cJSON *item, const char *num )\n-{\n-\tint64_t i = 0;\n-\tdouble f = 0;\n-\tint isint = 1;\n-\tint sign = 1, scale = 0, subscale = 0, signsubscale = 1;\n+static int pow2gt (int x)\t{\t--x;\tx|=x>>1;\tx|=x>>2;\tx|=x>>4;\tx|=x>>8;\tx|=x>>16;\treturn x+1;\t}\n \n-\t/* Could use sscanf for this? */\n-\tif ( *num == '-' ) {\n-\t\t/* Has sign. */\n-\t\tsign = -1;\n-\t\t++num;\n-\t}\n-\tif ( *num == '0' )\n-\t\t/* Is zero. */\n-\t\t++num;\n-\tif ( *num >= '1' && *num<='9' ) {\n-\t\t/* Number. */\n-\t\tdo {\n-\t\t\ti = ( i * 10 ) + ( *num - '0' );\n-\t\t\tf = ( f * 10.0 ) + ( *num - '0' );\n-\t\t\t++num;\n-\t\t} while ( *num >= '0' && *num <= '9' );\n-\t}\n-\tif ( *num == '.' && num[1] >= '0' && num[1] <= '9' ) {\n-\t\t/* Fractional part. */\n-\t\tisint = 0;\n-\t\t++num;\n-\t\tdo {\n-\t\t\tf = ( f * 10.0 ) + ( *num++ - '0' );\n-\t\t\tscale--;\n-\t\t} while ( *num >= '0' && *num <= '9' );\n-\t}\n-\tif ( *num == 'e' || *num == 'E' ) {\n-\t\t/* Exponent. */\n-\t\tisint = 0;\n-\t\t++num;\n-\t\tif ( *num == '+' )\n-\t\t\t++num;\n-\t\telse if ( *num == '-' ) {\n-\t\t\t/* With sign. */\n-\t\t\tsignsubscale = -1;\n-\t\t\t++num;\n-\t\t}\n-\t\twhile ( *num >= '0' && *num <= '9' )\n-\t\t\tsubscale = ( subscale * 10 ) + ( *num++ - '0' );\n-\t}\n+typedef struct {char *buffer; int length; int offset; } printbuffer;\n \n-\t/* Put it together. */\n-\tif ( isint ) {\n-\t\t/* Int: number = +/- number */\n-\t\ti = sign * i;\n-\t\titem->valueint = i;\n-\t\titem->valuefloat = i;\n-\t} else {\n-\t\t/* Float: number = +/- number.fraction * 10^+/- exponent */\n-\t\tf = sign * f * ipow( 10.0, scale + subscale * signsubscale );\n-\t\titem->valueint = f;\n-\t\titem->valuefloat = f;\n-\t}\n+static char* ensure(printbuffer *p,int needed)\n+{\n+\tchar *newbuffer;int newsize;\n+\tif (!p || !p->buffer) return 0;\n+\tneeded+=p->offset;\n+\tif (needed<=p->length) return p->buffer+p->offset;\n \n-\titem->type = cJSON_Number;\n-\treturn num;\n+\tnewsize=pow2gt(needed);\n+\tnewbuffer=(char*)cJSON_malloc(newsize);\n+\tif (!newbuffer) {cJSON_free(p->buffer);p->length=0,p->buffer=0;return 0;}\n+\tif (newbuffer) memcpy(newbuffer,p->buffer,p->length);\n+\tcJSON_free(p->buffer);\n+\tp->length=newsize;\n+\tp->buffer=newbuffer;\n+\treturn newbuffer+p->offset;\n }\n \n-\n-/* Render the number nicely from the given item into a string. */\n-static char *print_number( cJSON *item )\n+static int update(printbuffer *p)\n {\n \tchar *str;\n-\tdouble f, f2;\n-\tint64_t i;\n+\tif (!p || !p->buffer) return 0;\n+\tstr=p->buffer+p->offset;\n+\treturn p->offset+strlen(str);\n+}\n \n-\tstr = (char*) cJSON_malloc( 64 );\n-\tif ( str ) {\n-\t\tf = item->valuefloat;\n-\t\ti = f;\n-\t\tf2 = i;\n-\t\tif ( f2 == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )\n-\t\t\tsprintf( str, \"%lld\", (long long) item->valueint );\n-\t\telse\n-\t\t\tsprintf( str, \"%g\", item->valuefloat );\n+/* Render the number nicely from the given item into a string. */\n+static char *print_number(cJSON *item,printbuffer *p)\n+{\n+\tchar *str=0;\n+\tdouble d=item->valuedouble;\n+\tif (d==0)\n+\t{\n+\t\tif (p)\tstr=ensure(p,2);\n+\t\telse\tstr=(char*)cJSON_malloc(2);\t/* special case for 0. */\n+\t\tif (str) strcpy(str,\"0\");\n+\t}\n+\telse if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=LLONG_MAX && d>=LLONG_MIN)\n+\t{\n+\t\tif (p)\tstr=ensure(p,64);\n+\t\telse\tstr=(char*)cJSON_malloc(64);\n+\t\tif (str)\tsprintf(str,\"%lld\",(long long) item->valueint);\n+\t}\n+\telse\n+\t{\n+\t\tif (p)\tstr=ensure(p,64);\n+\t\telse\tstr=(char*)cJSON_malloc(64);\t/* This is a nice tradeoff. */\n+\t\tif (str)\n+\t\t{\n+\t\t\tif (fpclassify(d) != FP_ZERO && !isnormal(d))\t\t\t\tsprintf(str,\"null\");\n+\t\t\telse if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)\tsprintf(str,\"%.0f\",d);\n+\t\t\telse if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)\t\t\t\t\tsprintf(str,\"%e\",d);\n+\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\tsprintf(str,\"%f\",d);\n+\t\t}\n \t}\n \treturn str;\n }\n \n+static unsigned parse_hex4(const char *str)\n+{\n+\tunsigned h=0;\n+\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n+\th=h<<4;str++;\n+\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n+\th=h<<4;str++;\n+\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n+\th=h<<4;str++;\n+\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n+\treturn h;\n+}\n \n /* Parse the input text into an unescaped cstring, and populate item. */\n static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n-\n-static const char *parse_string( cJSON *item, const char *str )\n+static const char *parse_string(cJSON *item,const char *str,const char **ep)\n {\n-\tconst char *ptr = str + 1;\n-\tchar *ptr2;\n-\tchar *out;\n-\tint len = 0;\n-\tunsigned uc, uc2;\n-\n-\tif ( *str != '\\\"' ) {\n-\t\t/* Not a string! */\n-\t\tep = str;\n-\t\treturn 0;\n-\t}\n+\tconst char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;\n+\tif (*str!='\\\"') {*ep=str;return 0;}\t/* not a string! */\n \t\n-\t/* Skip escaped quotes. */\n-\twhile ( *ptr != '\\\"' && *ptr && ++len )\n-\t\tif ( *ptr++ == '\\\\' )\n-\t\t\tptr++;\n+\twhile (*end_ptr!='\\\"' && *end_ptr && ++len) if (*end_ptr++ == '\\\\') end_ptr++;\t/* Skip escaped quotes. */\n \t\n-\tif ( ! ( out = (char*) cJSON_malloc( len + 1 ) ) )\n-\t\treturn 0;\n+\tout=(char*)cJSON_malloc(len+1);\t/* This is how long we need for the string, roughly. */\n+\tif (!out) return 0;\n+\titem->valuestring=out; /* assign here so out will be deleted during cJSON_Delete() later */\n+\titem->type=cJSON_String;\n \t\n-\tptr = str + 1;\n-\tptr2 = out;\n-\twhile ( *ptr != '\\\"' && *ptr ) {\n-\t\tif ( *ptr != '\\\\' )\n-\t\t\t*ptr2++ = *ptr++;\n-\t\telse {\n+\tptr=str+1;ptr2=out;\n+\twhile (ptr < end_ptr)\n+\t{\n+\t\tif (*ptr!='\\\\') *ptr2++=*ptr++;\n+\t\telse\n+\t\t{\n \t\t\tptr++;\n-\t\t\tswitch ( *ptr ) {\n-\t\t\t\tcase 'b': *ptr2++ ='\\b'; break;\n-\t\t\t\tcase 'f': *ptr2++ ='\\f'; break;\n-\t\t\t\tcase 'n': *ptr2++ ='\\n'; break;\n-\t\t\t\tcase 'r': *ptr2++ ='\\r'; break;\n-\t\t\t\tcase 't': *ptr2++ ='\\t'; break;\n-\t\t\t\tcase 'u':\n-\t\t\t\t\t/* Transcode utf16 to utf8. */\n-\t\t\t\t\t/* Get the unicode char. */\n-\t\t\t\t\tsscanf( ptr + 1,\"%4x\", &uc );\n-\t\t\t\t\tptr += 4;\n-\t\t\t\t\t/* Check for invalid. */\n-\t\t\t\t\tif ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 )\n-\t\t\t\t\t\tbreak;\n-\n-\t\t\t\t\t/* UTF16 surrogate pairs. */\n-\t\t\t\t\tif ( uc >= 0xD800 && uc <= 0xDBFF ) {\n-\t\t\t\t\t\tif ( ptr[1] != '\\\\' || ptr[2] != 'u' )\n-\t\t\t\t\t\t\t/* Missing second-half of surrogate. */\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tsscanf( ptr + 3, \"%4x\", &uc2 );\n-\t\t\t\t\t\tptr += 6;\n-\t\t\t\t\t\tif ( uc2 < 0xDC00 || uc2 > 0xDFFF )\n-\t\t\t\t\t\t\t/* Invalid second-half of surrogate. */\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tuc = 0x10000 | ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF );\n+\t\t\tswitch (*ptr)\n+\t\t\t{\n+\t\t\t\tcase 'b': *ptr2++='\\b';\tbreak;\n+\t\t\t\tcase 'f': *ptr2++='\\f';\tbreak;\n+\t\t\t\tcase 'n': *ptr2++='\\n';\tbreak;\n+\t\t\t\tcase 'r': *ptr2++='\\r';\tbreak;\n+\t\t\t\tcase 't': *ptr2++='\\t';\tbreak;\n+\t\t\t\tcase 'u':\t /* transcode utf16 to utf8. */\n+\t\t\t\t\tuc=parse_hex4(ptr+1);ptr+=4;\t/* get the unicode char. */\n+\t\t\t\t\tif (ptr >= end_ptr) {*ep=str;return 0;}\t/* invalid */\n+\t\t\t\t\t\n+\t\t\t\t\tif ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)    {*ep=str;return 0;}\t/* check for invalid.   */\n+\t\t\t\t\t\n+\t\t\t\t\tif (uc>=0xD800 && uc<=0xDBFF)\t/* UTF16 surrogate pairs.\t*/\n+\t\t\t\t\t{\n+\t\t\t\t\t\tif (ptr+6 > end_ptr)    {*ep=str;return 0;}\t/* invalid */\n+\t\t\t\t\t\tif (ptr[1]!='\\\\' || ptr[2]!='u')    {*ep=str;return 0;}\t/* missing second-half of surrogate.    */\n+\t\t\t\t\t\tuc2=parse_hex4(ptr+3);ptr+=6;\n+\t\t\t\t\t\tif (uc2<0xDC00 || uc2>0xDFFF)       {*ep=str;return 0;}\t/* invalid second-half of surrogate.    */\n+\t\t\t\t\t\tuc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));\n \t\t\t\t\t}\n \n-\t\t\t\t\tlen = 4;\n-\t\t\t\t\tif ( uc < 0x80 )\n-\t\t\t\t\t\tlen = 1;\n-\t\t\t\t\telse if ( uc < 0x800 )\n-\t\t\t\t\t\tlen = 2;\n-\t\t\t\t\telse if ( uc < 0x10000 )\n-\t\t\t\t\t\tlen = 3;\n-\t\t\t\t\tptr2 += len;\n+\t\t\t\t\tlen=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;\n \t\t\t\t\t\n-\t\t\t\t\tswitch ( len ) {\n-\t\t\t\t\t\tcase 4: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;\n-\t\t\t\t\t\tcase 3: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;\n-\t\t\t\t\t\tcase 2: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;\n-\t\t\t\t\t\tcase 1: *--ptr2 = ( uc | firstByteMark[len] );\n+\t\t\t\t\tswitch (len) {\n+\t\t\t\t\t\tcase 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n+\t\t\t\t\t\tcase 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n+\t\t\t\t\t\tcase 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n+\t\t\t\t\t\tcase 1: *--ptr2 =(uc | firstByteMark[len]);\n \t\t\t\t\t}\n-\t\t\t\t\tptr2 += len;\n+\t\t\t\t\tptr2+=len;\n \t\t\t\t\tbreak;\n-\t\t\t\tdefault:  *ptr2++ = *ptr; break;\n+\t\t\t\tdefault:  *ptr2++=*ptr; break;\n \t\t\t}\n-\t\t\t++ptr;\n+\t\t\tptr++;\n \t\t}\n \t}\n-\t*ptr2 = 0;\n-\tif ( *ptr == '\\\"' )\n-\t\t++ptr;\n-\titem->valuestring = out;\n-\titem->type = cJSON_String;\n+\t*ptr2=0;\n+\tif (*ptr=='\\\"') ptr++;\n \treturn ptr;\n }\n \n-\n /* Render the cstring provided to an escaped version that can be printed. */\n-static char *print_string_ptr( const char *str )\n+static char *print_string_ptr(const char *str,printbuffer *p)\n {\n-\tconst char *ptr;\n-\tchar *ptr2, *out;\n-\tint len = 0;\n-\tunsigned char token;\n+\tconst char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;\n+\n+\tif (!str)\n+\t{\n+\t\tif (p)\tout=ensure(p,3);\n+\t\telse\tout=(char*)cJSON_malloc(3);\n+\t\tif (!out) return 0;\n+\t\tstrcpy(out,\"\\\"\\\"\");\n+\t\treturn out;\n+\t}\n \t\n-\tif ( ! str )\n-\t\treturn cJSON_strdup( \"\" );\n-\tptr = str;\n-\twhile ( ( token = *ptr ) && ++len ) {\n-\t\tif ( strchr( \"\\\"\\\\\\b\\f\\n\\r\\t\", token ) )\n-\t\t\t++len;\n-\t\telse if ( token < 32 )\n-\t\t\tlen += 5;\n-\t\t++ptr;\n+\tfor (ptr=str;*ptr;ptr++) flag|=((*ptr>0 && *ptr<32)||(*ptr=='\\\"')||(*ptr=='\\\\'))?1:0;\n+\tif (!flag)\n+\t{\n+\t\tlen=ptr-str;\n+\t\tif (p) out=ensure(p,len+3);\n+\t\telse\t\tout=(char*)cJSON_malloc(len+3);\n+\t\tif (!out) return 0;\n+\t\tptr2=out;*ptr2++='\\\"';\n+\t\tstrcpy(ptr2,str);\n+\t\tptr2[len]='\\\"';\n+\t\tptr2[len+1]=0;\n+\t\treturn out;\n \t}\n \t\n-\tif ( ! ( out = (char*) cJSON_malloc( len + 3 ) ) )\n-\t\treturn 0;\n-\n-\tptr2 = out;\n-\tptr = str;\n-\t*ptr2++ = '\\\"';\n-\twhile ( *ptr ) {\n-\t\tif ( (unsigned char) *ptr > 31 && *ptr != '\\\"' && *ptr != '\\\\' )\n-\t\t\t*ptr2++ = *ptr++;\n-\t\telse {\n-\t\t\t*ptr2++ = '\\\\';\n-\t\t\tswitch ( token = *ptr++ ) {\n-\t\t\t\tcase '\\\\': *ptr2++ = '\\\\'; break;\n-\t\t\t\tcase '\\\"': *ptr2++ = '\\\"'; break;\n-\t\t\t\tcase '\\b': *ptr2++ = 'b'; break;\n-\t\t\t\tcase '\\f': *ptr2++ = 'f'; break;\n-\t\t\t\tcase '\\n': *ptr2++ = 'n'; break;\n-\t\t\t\tcase '\\r': *ptr2++ = 'r'; break;\n-\t\t\t\tcase '\\t': *ptr2++ = 't'; break;\n-\t\t\t\tdefault:\n-\t\t\t\t/* Escape and print. */\n-\t\t\t\tsprintf( ptr2, \"u%04x\", token );\n-\t\t\t\tptr2 += 5;\n-\t\t\t\tbreak;\n+\tptr=str;while ((token=*ptr) && ++len) {if (strchr(\"\\\"\\\\\\b\\f\\n\\r\\t\",token)) len++; else if (token<32) len+=5;ptr++;}\n+\t\n+\tif (p)\tout=ensure(p,len+3);\n+\telse\tout=(char*)cJSON_malloc(len+3);\n+\tif (!out) return 0;\n+\n+\tptr2=out;ptr=str;\n+\t*ptr2++='\\\"';\n+\twhile (*ptr)\n+\t{\n+\t\tif ((unsigned char)*ptr>31 && *ptr!='\\\"' && *ptr!='\\\\') *ptr2++=*ptr++;\n+\t\telse\n+\t\t{\n+\t\t\t*ptr2++='\\\\';\n+\t\t\tswitch (token=*ptr++)\n+\t\t\t{\n+\t\t\t\tcase '\\\\':\t*ptr2++='\\\\';\tbreak;\n+\t\t\t\tcase '\\\"':\t*ptr2++='\\\"';\tbreak;\n+\t\t\t\tcase '\\b':\t*ptr2++='b';\tbreak;\n+\t\t\t\tcase '\\f':\t*ptr2++='f';\tbreak;\n+\t\t\t\tcase '\\n':\t*ptr2++='n';\tbreak;\n+\t\t\t\tcase '\\r':\t*ptr2++='r';\tbreak;\n+\t\t\t\tcase '\\t':\t*ptr2++='t';\tbreak;\n+\t\t\t\tdefault: sprintf(ptr2,\"u%04x\",token);ptr2+=5;\tbreak;\t/* escape and print */\n \t\t\t}\n \t\t}\n \t}\n-\t*ptr2++ = '\\\"';\n-\t*ptr2++ = 0;\n+\t*ptr2++='\\\"';*ptr2++=0;\n \treturn out;\n }\n-\n-\n /* Invote print_string_ptr (which is useful) on an item. */\n-static char *print_string( cJSON *item )\n-{\n-\treturn print_string_ptr( item->valuestring );\n-}\n-\n+static char *print_string(cJSON *item,printbuffer *p)\t{return print_string_ptr(item->valuestring,p);}\n \n /* Predeclare these prototypes. */\n-static const char *parse_value( cJSON *item, const char *value );\n-static char *print_value( cJSON *item, int depth, int fmt );\n-static const char *parse_array( cJSON *item, const char *value );\n-static char *print_array( cJSON *item, int depth, int fmt );\n-static const char *parse_object( cJSON *item, const char *value );\n-static char *print_object( cJSON *item, int depth, int fmt );\n-\n-/* Utility to jump whitespace and cr/lf. */\n-static const char *skip( const char *in )\n-{\n-\twhile ( in && *in && (unsigned char) *in <= 32 )\n-\t\tin++;\n-\treturn in;\n-}\n+static const char *parse_value(cJSON *item,const char *value,const char **ep);\n+static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p);\n+static const char *parse_array(cJSON *item,const char *value,const char **ep);\n+static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);\n+static const char *parse_object(cJSON *item,const char *value,const char **ep);\n+static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);\n \n+/* Utility to jump whitespace and cr/lf */\n+static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}\n \n /* Parse an object - create a new root, and populate. */\n-cJSON *cJSON_Parse( const char *value )\n+cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)\n {\n-\tcJSON *c;\n-\tep = 0;\n-\tif ( ! ( c = cJSON_New_Item() ) )\n-\t\treturn 0;\t/* memory fail */\n+\tconst char *end=0,**ep=return_parse_end?return_parse_end:&global_ep;\n+\tcJSON *c=cJSON_New_Item();\n+\t*ep=0;\n+\tif (!c) return 0;       /* memory fail */\n \n-\tif ( ! parse_value( c, skip( value ) ) ) {\n-\t\tcJSON_Delete( c );\n-\t\treturn 0;\n-\t}\n+\tend=parse_value(c,skip(value),ep);\n+\tif (!end)\t{cJSON_Delete(c);return 0;}\t/* parse failure. ep is set. */\n+\n+\t/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */\n+\tif (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);*ep=end;return 0;}}\n+\tif (return_parse_end) *return_parse_end=end;\n \treturn c;\n }\n-\n+/* Default options for cJSON_Parse */\n+cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}\n \n /* Render a cJSON item/entity/structure to text. */\n-char *cJSON_Print( cJSON *item )\n-{\n-\treturn print_value( item, 0, 1 );\n-}\n-char *cJSON_PrintUnformatted( cJSON *item )\n+char *cJSON_Print(cJSON *item)\t\t\t\t{return print_value(item,0,1,0);}\n+char *cJSON_PrintUnformatted(cJSON *item)\t{return print_value(item,0,0,0);}\n+\n+char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)\n {\n-\treturn print_value( item, 0, 0 );\n+\tprintbuffer p;\n+\tp.buffer=(char*)cJSON_malloc(prebuffer);\n+\tp.length=prebuffer;\n+\tp.offset=0;\n+\treturn print_value(item,0,fmt,&p);\n }\n \n \n /* Parser core - when encountering text, process appropriately. */\n-static const char *parse_value( cJSON *item, const char *value )\n+static const char *parse_value(cJSON *item,const char *value,const char **ep)\n {\n-\tif ( ! value )\n-\t\treturn 0;\t/* Fail on null. */\n-\tif ( ! strncmp( value, \"null\", 4 ) ) {\n-\t\titem->type = cJSON_NULL;\n-\t\treturn value + 4;\n-\t}\n-\tif ( ! strncmp( value, \"false\", 5 ) ) {\n-\t\titem->type = cJSON_False;\n-\t\treturn value + 5;\n-\t}\n-\tif ( ! strncmp( value, \"true\", 4 ) ) {\n-\t\titem->type = cJSON_True;\n-\t\titem->valueint = 1;\n-\t\treturn value + 4;\n-\t}\n-\tif ( *value == '\\\"' )\n-\t\treturn parse_string( item, value );\n-\tif ( *value == '-' || ( *value >= '0' && *value <= '9' ) )\n-\t\treturn parse_number( item, value );\n-\tif ( *value == '[' )\n-\t\treturn parse_array( item, value );\n-\tif ( *value == '{' )\n-\t\treturn parse_object( item, value );\n+\tif (!value)\t\t\t\t\t\treturn 0;\t/* Fail on null. */\n+\tif (!strncmp(value,\"null\",4))\t{ item->type=cJSON_NULL;  return value+4; }\n+\tif (!strncmp(value,\"false\",5))\t{ item->type=cJSON_False; return value+5; }\n+\tif (!strncmp(value,\"true\",4))\t{ item->type=cJSON_True; item->valueint=1;\treturn value+4; }\n+\tif (*value=='\\\"')\t\t\t\t{ return parse_string(item,value,ep); }\n+\tif (*value=='-' || (*value>='0' && *value<='9'))\t{ return parse_number(item,value); }\n+\tif (*value=='[')\t\t\t\t{ return parse_array(item,value,ep); }\n+\tif (*value=='{')\t\t\t\t{ return parse_object(item,value,ep); }\n \n-\t/* Fail. */\n-\tep = value;\n-\treturn 0;\n+\t*ep=value;return 0;\t/* failure. */\n }\n \n-\n /* Render a value to text. */\n-static char *print_value( cJSON *item, int depth, int fmt )\n-{\n-\tchar *out = 0;\n-\n-\tif ( ! item )\n-\t\treturn 0;\n-\tswitch ( ( item->type ) & 255 ) {\n-\t\tcase cJSON_NULL:   out = cJSON_strdup( \"null\" ); break;\n-\t\tcase cJSON_False:  out = cJSON_strdup( \"false\" ); break;\n-\t\tcase cJSON_True:   out = cJSON_strdup( \"true\" ); break;\n-\t\tcase cJSON_Number: out = print_number( item ); break;\n-\t\tcase cJSON_String: out = print_string( item ); break;\n-\t\tcase cJSON_Array:  out = print_array( item, depth, fmt ); break;\n-\t\tcase cJSON_Object: out = print_object( item, depth, fmt ); break;\n+static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)\n+{\n+\tchar *out=0;\n+\tif (!item) return 0;\n+\tif (p)\n+\t{\n+\t\tswitch ((item->type)&255)\n+\t\t{\n+\t\t\tcase cJSON_NULL:\t{out=ensure(p,5);\tif (out) strcpy(out,\"null\");\tbreak;}\n+\t\t\tcase cJSON_False:\t{out=ensure(p,6);\tif (out) strcpy(out,\"false\");\tbreak;}\n+\t\t\tcase cJSON_True:\t{out=ensure(p,5);\tif (out) strcpy(out,\"true\");\tbreak;}\n+\t\t\tcase cJSON_Number:\tout=print_number(item,p);break;\n+\t\t\tcase cJSON_String:\tout=print_string(item,p);break;\n+\t\t\tcase cJSON_Array:\tout=print_array(item,depth,fmt,p);break;\n+\t\t\tcase cJSON_Object:\tout=print_object(item,depth,fmt,p);break;\n+\t\t}\n+\t}\n+\telse\n+\t{\n+\t\tswitch ((item->type)&255)\n+\t\t{\n+\t\t\tcase cJSON_NULL:\tout=cJSON_strdup(\"null\");\tbreak;\n+\t\t\tcase cJSON_False:\tout=cJSON_strdup(\"false\");break;\n+\t\t\tcase cJSON_True:\tout=cJSON_strdup(\"true\"); break;\n+\t\t\tcase cJSON_Number:\tout=print_number(item,0);break;\n+\t\t\tcase cJSON_String:\tout=print_string(item,0);break;\n+\t\t\tcase cJSON_Array:\tout=print_array(item,depth,fmt,0);break;\n+\t\t\tcase cJSON_Object:\tout=print_object(item,depth,fmt,0);break;\n+\t\t}\n \t}\n \treturn out;\n }\n \n-\n /* Build an array from input text. */\n-static const char *parse_array( cJSON *item, const char *value )\n+static const char *parse_array(cJSON *item,const char *value,const char **ep)\n {\n \tcJSON *child;\n+\tif (*value!='[')\t{*ep=value;return 0;}\t/* not an array! */\n \n-\tif ( *value != '[' ) {\n-\t\t/* Not an array! */\n-\t\tep = value;\n-\t\treturn 0;\n-\t}\n-\n-\titem->type = cJSON_Array;\n-\tvalue = skip( value + 1 );\n-\tif ( *value == ']' )\n-\t\treturn value + 1;\t/* empty array. */\n+\titem->type=cJSON_Array;\n+\tvalue=skip(value+1);\n+\tif (*value==']') return value+1;\t/* empty array. */\n \n-\tif ( ! ( item->child = child = cJSON_New_Item() ) )\n-\t\treturn 0;\t\t /* memory fail */\n-\tif ( ! ( value = skip( parse_value( child, skip( value ) ) ) ) )\n-\t\treturn 0;\n+\titem->child=child=cJSON_New_Item();\n+\tif (!item->child) return 0;\t\t /* memory fail */\n+\tvalue=skip(parse_value(child,skip(value),ep));\t/* skip any spacing, get the value. */\n+\tif (!value) return 0;\n \n-\twhile ( *value == ',' ) {\n+\twhile (*value==',')\n+\t{\n \t\tcJSON *new_item;\n-\t\tif ( ! ( new_item = cJSON_New_Item() ) )\n-\t\t\treturn 0;\t/* memory fail */\n-\t\tchild->next = new_item;\n-\t\tnew_item->prev = child;\n-\t\tchild = new_item;\n-\t\tif ( ! ( value = skip( parse_value( child, skip( value+1 ) ) ) ) )\n-\t\t\treturn 0;\t/* memory fail */\n+\t\tif (!(new_item=cJSON_New_Item())) return 0; \t/* memory fail */\n+\t\tchild->next=new_item;new_item->prev=child;child=new_item;\n+\t\tvalue=skip(parse_value(child,skip(value+1),ep));\n+\t\tif (!value) return 0;\t/* memory fail */\n \t}\n \n-\tif ( *value == ']' )\n-\t\treturn value + 1;\t/* end of array */\n-\t/* Malformed. */\n-\tep = value;\n-\treturn 0;\n+\tif (*value==']') return value+1;\t/* end of array */\n+\t*ep=value;return 0;\t/* malformed. */\n }\n \n-\n /* Render an array to text */\n-static char *print_array( cJSON *item, int depth, int fmt )\n+static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)\n {\n \tchar **entries;\n-\tchar *out = 0, *ptr, *ret;\n-\tint len = 5;\n-\tcJSON *child = item->child;\n-\tint numentries = 0, i = 0, fail = 0;\n+\tchar *out=0,*ptr,*ret;int len=5;\n+\tcJSON *child=item->child;\n+\tint numentries=0,i=0,fail=0;\n+\tsize_t tmplen=0;\n \t\n \t/* How many entries in the array? */\n-\twhile ( child ) {\n-\t\t++numentries;\n-\t\tchild = child->next;\n-\t}\n-\t/* Allocate an array to hold the values for each. */\n-\tif ( ! ( entries = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) )\n-\t\treturn 0;\n-\tmemset( entries, 0, numentries * sizeof(char*) );\n-\t/* Retrieve all the results. */\n-\tchild = item->child;\n-\twhile ( child && ! fail ) {\n-\t\tret = print_value( child, depth + 1, fmt );\n-\t\tentries[i++] = ret;\n-\t\tif ( ret )\n-\t\t\tlen += strlen( ret ) + 2 + ( fmt ? 1 : 0 );\n-\t\telse\n-\t\t\tfail = 1;\n-\t\tchild = child -> next;\n-\t}\n-\t\n-\t/* If we didn't fail, try to malloc the output string. */\n-\tif ( ! fail ) {\n-\t\tout = (char*) cJSON_malloc( len );\n-\t\tif ( ! out )\n-\t\t\tfail = 1;\n-\t}\n-\n-\t/* Handle failure. */\n-\tif ( fail ) {\n-\t\tfor ( i = 0; i < numentries; ++i )\n-\t\t\tif ( entries[i] )\n-\t\t\t\tcJSON_free( entries[i] );\n-\t\tcJSON_free( entries );\n-\t\treturn 0;\n+\twhile (child) numentries++,child=child->next;\n+\t/* Explicitly handle numentries==0 */\n+\tif (!numentries)\n+\t{\n+\t\tif (p)\tout=ensure(p,3);\n+\t\telse\tout=(char*)cJSON_malloc(3);\n+\t\tif (out) strcpy(out,\"[]\");\n+\t\treturn out;\n+\t}\n+\n+\tif (p)\n+\t{\n+\t\t/* Compose the output array. */\n+\t\ti=p->offset;\n+\t\tptr=ensure(p,1);if (!ptr) return 0;\t*ptr='[';\tp->offset++;\n+\t\tchild=item->child;\n+\t\twhile (child && !fail)\n+\t\t{\n+\t\t\tprint_value(child,depth+1,fmt,p);\n+\t\t\tp->offset=update(p);\n+\t\t\tif (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}\n+\t\t\tchild=child->next;\n+\t\t}\n+\t\tptr=ensure(p,2);if (!ptr) return 0;\t*ptr++=']';*ptr=0;\n+\t\tout=(p->buffer)+i;\n \t}\n-\t\n-\t/* Compose the output array. */\n-\t*out = '[';\n-\tptr = out + 1;\n-\t*ptr = 0;\n-\tfor ( i = 0; i < numentries; ++i ) {\n-\t\tstrcpy( ptr, entries[i] );\n-\t\tptr += strlen( entries[i] );\n-\t\tif ( i != numentries - 1 ) {\n-\t\t\t*ptr++ = ',';\n-\t\t\tif ( fmt )\n-\t\t\t\t*ptr++ = ' ';\n-\t\t\t*ptr = 0;\n+\telse\n+\t{\n+\t\t/* Allocate an array to hold the values for each */\n+\t\tentries=(char**)cJSON_malloc(numentries*sizeof(char*));\n+\t\tif (!entries) return 0;\n+\t\tmemset(entries,0,numentries*sizeof(char*));\n+\t\t/* Retrieve all the results: */\n+\t\tchild=item->child;\n+\t\twhile (child && !fail)\n+\t\t{\n+\t\t\tret=print_value(child,depth+1,fmt,0);\n+\t\t\tentries[i++]=ret;\n+\t\t\tif (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;\n+\t\t\tchild=child->next;\n \t\t}\n-\t\tcJSON_free( entries[i] );\n+\t\t\n+\t\t/* If we didn't fail, try to malloc the output string */\n+\t\tif (!fail)\tout=(char*)cJSON_malloc(len);\n+\t\t/* If that fails, we fail. */\n+\t\tif (!out) fail=1;\n+\n+\t\t/* Handle failure. */\n+\t\tif (fail)\n+\t\t{\n+\t\t\tfor (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);\n+\t\t\tcJSON_free(entries);\n+\t\t\treturn 0;\n+\t\t}\n+\t\t\n+\t\t/* Compose the output array. */\n+\t\t*out='[';\n+\t\tptr=out+1;*ptr=0;\n+\t\tfor (i=0;i<numentries;i++)\n+\t\t{\n+\t\t\ttmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;\n+\t\t\tif (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}\n+\t\t\tcJSON_free(entries[i]);\n+\t\t}\n+\t\tcJSON_free(entries);\n+\t\t*ptr++=']';*ptr++=0;\n \t}\n-\tcJSON_free( entries );\n-\t*ptr++ = ']';\n-\t*ptr++ = 0;\n \treturn out;\t\n }\n \n-\n /* Build an object from the text. */\n-static const char *parse_object( cJSON *item, const char *value )\n+static const char *parse_object(cJSON *item,const char *value,const char **ep)\n {\n \tcJSON *child;\n-\n-\tif ( *value != '{' ) {\n-\t\t/* Not an object! */\n-\t\tep = value;\n-\t\treturn 0;\n-\t}\n+\tif (*value!='{')\t{*ep=value;return 0;}\t/* not an object! */\n \t\n-\titem->type = cJSON_Object;\n-\tvalue =skip( value + 1 );\n-\tif ( *value == '}' )\n-\t\treturn value + 1;\t/* empty array. */\n+\titem->type=cJSON_Object;\n+\tvalue=skip(value+1);\n+\tif (*value=='}') return value+1;\t/* empty array. */\n \t\n-\tif ( ! ( item->child = child = cJSON_New_Item() ) )\n-\t\treturn 0;\n-\tif ( ! ( value = skip( parse_string( child, skip( value ) ) ) ) )\n-\t\treturn 0;\n-\tchild->string = child->valuestring;\n-\tchild->valuestring = 0;\n-\tif ( *value != ':' ) {\n-\t\t/* Fail! */\n-\t\tep = value;\n-\t\treturn 0;\n-\t}\n-\tif ( ! ( value = skip( parse_value( child, skip( value + 1 ) ) ) ) )\n-\t\treturn 0;\n+\titem->child=child=cJSON_New_Item();\n+\tif (!item->child) return 0;\n+\tvalue=skip(parse_string(child,skip(value),ep));\n+\tif (!value) return 0;\n+\tchild->string=child->valuestring;child->valuestring=0;\n+\tif (*value!=':') {*ep=value;return 0;}\t/* fail! */\n+\tvalue=skip(parse_value(child,skip(value+1),ep));\t/* skip any spacing, get the value. */\n+\tif (!value) return 0;\n \t\n-\twhile ( *value == ',' ) {\n+\twhile (*value==',')\n+\t{\n \t\tcJSON *new_item;\n-\t\tif ( ! ( new_item = cJSON_New_Item() ) )\n-\t\t\treturn 0;\t/* memory fail */\n-\t\tchild->next = new_item;\n-\t\tnew_item->prev = child;\n-\t\tchild = new_item;\n-\t\tif ( ! ( value = skip( parse_string( child, skip( value + 1 ) ) ) ) )\n-\t\t\treturn 0;\n-\t\tchild->string = child->valuestring;\n-\t\tchild->valuestring = 0;\n-\t\tif ( *value != ':' ) {\n-\t\t\t/* Fail! */\n-\t\t\tep = value;\n-\t\t\treturn 0;\n-\t\t}\n-\t\tif ( ! ( value = skip( parse_value( child, skip( value + 1 ) ) ) ) )\n-\t\t\treturn 0;\n+\t\tif (!(new_item=cJSON_New_Item()))\treturn 0; /* memory fail */\n+\t\tchild->next=new_item;new_item->prev=child;child=new_item;\n+\t\tvalue=skip(parse_string(child,skip(value+1),ep));\n+\t\tif (!value) return 0;\n+\t\tchild->string=child->valuestring;child->valuestring=0;\n+\t\tif (*value!=':') {*ep=value;return 0;}\t/* fail! */\n+\t\tvalue=skip(parse_value(child,skip(value+1),ep));\t/* skip any spacing, get the value. */\n+\t\tif (!value) return 0;\n \t}\n \t\n-\tif ( *value == '}' )\n-\t\treturn value + 1;\t/* end of array */\n-\t/* Malformed. */\n-\tep = value;\n-\treturn 0;\n+\tif (*value=='}') return value+1;\t/* end of array */\n+\t*ep=value;return 0;\t/* malformed. */\n }\n \n-\n /* Render an object to text. */\n-static char *print_object( cJSON *item, int depth, int fmt )\n+static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)\n {\n-\tchar **entries = 0, **names = 0;\n-\tchar *out = 0, *ptr, *ret, *str;\n-\tint len = 7, i = 0, j;\n-\tcJSON *child = item->child;\n-\tint numentries = 0, fail = 0;\n-\n+\tchar **entries=0,**names=0;\n+\tchar *out=0,*ptr,*ret,*str;int len=7,i=0,j;\n+\tcJSON *child=item->child;\n+\tint numentries=0,fail=0;\n+\tsize_t tmplen=0;\n \t/* Count the number of entries. */\n-\twhile ( child ) {\n-\t\t++numentries;\n-\t\tchild = child->next;\n-\t}\n-\t/* Allocate space for the names and the objects. */\n-\tif ( ! ( entries = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) )\n-\t\treturn 0;\n-\tif ( ! ( names = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) ) {\n-\t\tcJSON_free( entries );\n-\t\treturn 0;\n-\t}\n-\tmemset( entries, 0, sizeof(char*) * numentries );\n-\tmemset( names, 0, sizeof(char*) * numentries );\n-\n-\t/* Collect all the results into our arrays. */\n-\tchild = item->child;\n-\t++depth;\n-\tif ( fmt )\n-\t\tlen += depth;\n-\twhile ( child ) {\n-\t\tnames[i] = str = print_string_ptr( child->string );\n-\t\tentries[i++] = ret = print_value( child, depth, fmt );\n-\t\tif ( str && ret )\n-\t\t\tlen += strlen( ret ) + strlen( str ) + 2 + ( fmt ? 2 + depth : 0 );\n-\t\telse\n-\t\t\tfail = 1;\n-\t\tchild = child->next;\n-\t}\n-\t\n-\t/* Try to allocate the output string. */\n-\tif ( ! fail ) {\n-\t\tout = (char*) cJSON_malloc( len );\n-\t\tif ( ! out )\n-\t\t\tfail = 1;\n-\t}\n-\n-\t/* Handle failure. */\n-\tif ( fail ) {\n-\t\tfor ( i = 0; i < numentries; ++i ) {\n-\t\t\tif ( names[i] )\n-\t\t\t\tcJSON_free( names[i] );\n-\t\t\tif ( entries[i] )\n-\t\t\t\tcJSON_free( entries[i] );\n+\twhile (child) numentries++,child=child->next;\n+\t/* Explicitly handle empty object case */\n+\tif (!numentries)\n+\t{\n+\t\tif (p) out=ensure(p,fmt?depth+4:3);\n+\t\telse\tout=(char*)cJSON_malloc(fmt?depth+4:3);\n+\t\tif (!out)\treturn 0;\n+\t\tptr=out;*ptr++='{';\n+\t\tif (fmt) {*ptr++='\\n';for (i=0;i<depth;i++) *ptr++='\\t';}\n+\t\t*ptr++='}';*ptr++=0;\n+\t\treturn out;\n+\t}\n+\tif (p)\n+\t{\n+\t\t/* Compose the output: */\n+\t\ti=p->offset;\n+\t\tlen=fmt?2:1;\tptr=ensure(p,len+1);\tif (!ptr) return 0;\n+\t\t*ptr++='{';\tif (fmt) *ptr++='\\n';\t*ptr=0;\tp->offset+=len;\n+\t\tchild=item->child;depth++;\n+\t\twhile (child)\n+\t\t{\n+\t\t\tif (fmt)\n+\t\t\t{\n+\t\t\t\tptr=ensure(p,depth);\tif (!ptr) return 0;\n+\t\t\t\tfor (j=0;j<depth;j++) *ptr++='\\t';\n+\t\t\t\tp->offset+=depth;\n+\t\t\t}\n+\t\t\tprint_string_ptr(child->string,p);\n+\t\t\tp->offset=update(p);\n+\t\t\t\n+\t\t\tlen=fmt?2:1;\n+\t\t\tptr=ensure(p,len);\tif (!ptr) return 0;\n+\t\t\t*ptr++=':';if (fmt) *ptr++='\\t';\n+\t\t\tp->offset+=len;\n+\t\t\t\n+\t\t\tprint_value(child,depth,fmt,p);\n+\t\t\tp->offset=update(p);\n+\n+\t\t\tlen=(fmt?1:0)+(child->next?1:0);\n+\t\t\tptr=ensure(p,len+1); if (!ptr) return 0;\n+\t\t\tif (child->next) *ptr++=',';\n+\t\t\tif (fmt) *ptr++='\\n';*ptr=0;\n+\t\t\tp->offset+=len;\n+\t\t\tchild=child->next;\n \t\t}\n-\t\tcJSON_free( names );\n-\t\tcJSON_free( entries );\n-\t\treturn 0;\n+\t\tptr=ensure(p,fmt?(depth+1):2);\t if (!ptr) return 0;\n+\t\tif (fmt)\tfor (i=0;i<depth-1;i++) *ptr++='\\t';\n+\t\t*ptr++='}';*ptr=0;\n+\t\tout=(p->buffer)+i;\n \t}\n-\t\n-\t/* Compose the output. */\n-\t*out = '{';\n-\tptr = out + 1;\n-\tif ( fmt )\n-\t\t*ptr++ = '\\n';\n-\t*ptr = 0;\n-\tfor ( i = 0; i < numentries; ++i ) {\n-\t\tif ( fmt )\n-\t\t\tfor ( j = 0; j < depth; ++j )\n-\t\t\t\t*ptr++ = '\\t';\n-\t\tstrcpy( ptr, names[i] );\n-\t\tptr += strlen( names[i] );\n-\t\t*ptr++ = ':';\n-\t\tif ( fmt )\n-\t\t\t*ptr++ = '\\t';\n-\t\tstrcpy( ptr, entries[i] );\n-\t\tptr += strlen( entries[i] );\n-\t\tif ( i != numentries - 1 )\n-\t\t\t*ptr++ = ',';\n-\t\tif ( fmt )\n-\t\t\t*ptr++ = '\\n';\n-\t\t*ptr = 0;\n-\t\tcJSON_free( names[i] );\n-\t\tcJSON_free( entries[i] );\n+\telse\n+\t{\n+\t\t/* Allocate space for the names and the objects */\n+\t\tentries=(char**)cJSON_malloc(numentries*sizeof(char*));\n+\t\tif (!entries) return 0;\n+\t\tnames=(char**)cJSON_malloc(numentries*sizeof(char*));\n+\t\tif (!names) {cJSON_free(entries);return 0;}\n+\t\tmemset(entries,0,sizeof(char*)*numentries);\n+\t\tmemset(names,0,sizeof(char*)*numentries);\n+\n+\t\t/* Collect all the results into our arrays: */\n+\t\tchild=item->child;depth++;if (fmt) len+=depth;\n+\t\twhile (child && !fail)\n+\t\t{\n+\t\t\tnames[i]=str=print_string_ptr(child->string,0);\n+\t\t\tentries[i++]=ret=print_value(child,depth,fmt,0);\n+\t\t\tif (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;\n+\t\t\tchild=child->next;\n+\t\t}\n+\t\t\n+\t\t/* Try to allocate the output string */\n+\t\tif (!fail)\tout=(char*)cJSON_malloc(len);\n+\t\tif (!out) fail=1;\n+\n+\t\t/* Handle failure */\n+\t\tif (fail)\n+\t\t{\n+\t\t\tfor (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}\n+\t\t\tcJSON_free(names);cJSON_free(entries);\n+\t\t\treturn 0;\n+\t\t}\n+\t\t\n+\t\t/* Compose the output: */\n+\t\t*out='{';ptr=out+1;if (fmt)*ptr++='\\n';*ptr=0;\n+\t\tfor (i=0;i<numentries;i++)\n+\t\t{\n+\t\t\tif (fmt) for (j=0;j<depth;j++) *ptr++='\\t';\n+\t\t\ttmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;\n+\t\t\t*ptr++=':';if (fmt) *ptr++='\\t';\n+\t\t\tstrcpy(ptr,entries[i]);ptr+=strlen(entries[i]);\n+\t\t\tif (i!=numentries-1) *ptr++=',';\n+\t\t\tif (fmt) *ptr++='\\n';*ptr=0;\n+\t\t\tcJSON_free(names[i]);cJSON_free(entries[i]);\n+\t\t}\n+\t\t\n+\t\tcJSON_free(names);cJSON_free(entries);\n+\t\tif (fmt) for (i=0;i<depth-1;i++) *ptr++='\\t';\n+\t\t*ptr++='}';*ptr++=0;\n \t}\n-\t\n-\tcJSON_free( names );\n-\tcJSON_free( entries );\n-\tif ( fmt )\n-\t\tfor ( i = 0; i < depth - 1; ++i )\n-\t\t\t*ptr++ = '\\t';\n-\t*ptr++ = '}';\n-\t*ptr++ = 0;\n \treturn out;\t\n }\n \n-\n-int cJSON_GetArraySize( cJSON *array )\n-{\n-\tcJSON *c = array->child;\n-\tint i = 0;\n-\twhile ( c ) {\n-\t\t++i;\n-\t\tc = c->next;\n-\t}\n-\treturn i;\n-}\n-\n-\n-cJSON *cJSON_GetArrayItem( cJSON *array, int item )\n-{\n-\tcJSON *c = array->child;\n-\twhile ( c && item > 0 ) {\n-\t\t--item;\n-\t\tc = c->next;\n-\t}\n-\treturn c;\n-}\n-\n-\n-cJSON *cJSON_GetObjectItem( cJSON *object, const char *string )\n-{\n-\tcJSON *c = object->child;\n-\twhile ( c && cJSON_strcasecmp( c->string, string ) )\n-\t\tc = c->next;\n-\treturn c;\n-}\n-\n+/* Get Array size/item / object item. */\n+int    cJSON_GetArraySize(cJSON *array)\t\t\t\t\t\t\t{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}\n+cJSON *cJSON_GetArrayItem(cJSON *array,int item)\t\t\t\t{cJSON *c=array?array->child:0;while (c && item>0) item--,c=c->next; return c;}\n+cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)\t{cJSON *c=object?object->child:0;while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}\n+int cJSON_HasObjectItem(cJSON *object,const char *string)\t\t{return cJSON_GetObjectItem(object,string)?1:0;}\n \n /* Utility for array list handling. */\n-static void suffix_object( cJSON *prev, cJSON *item )\n-{\n-\tprev->next = item;\n-\titem->prev = prev;\n-}\n-\n-\n+static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}\n /* Utility for handling references. */\n-static cJSON *create_reference( cJSON *item )\n-{\n-\tcJSON *ref;\n-\tif ( ! ( ref = cJSON_New_Item() ) )\n-\t\treturn 0;\n-\tmemcpy( ref, item, sizeof(cJSON) );\n-\tref->string = 0;\n-\tref->type |= cJSON_IsReference;\n-\tref->next = ref->prev = 0;\n-\treturn ref;\n-}\n-\n+static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}\n \n /* Add item to array/object. */\n-void cJSON_AddItemToArray( cJSON *array, cJSON *item )\n-{\n-\tcJSON *c = array->child;\n-\tif ( ! item )\n-\t\treturn;\n-\tif ( ! c ) {\n-\t\tarray->child = item;\n-\t} else {\n-\t\twhile ( c && c->next )\n-\t\t\tc = c->next;\n-\t\tsuffix_object( c, item );\n-\t}\n-}\n-\n-void cJSON_AddItemToObject( cJSON *object, const char *string, cJSON *item )\n-{\n-\tif ( ! item )\n-\t\treturn;\n-\tif ( item->string )\n-\t\tcJSON_free( item->string );\n-\titem->string = cJSON_strdup( string );\n-\tcJSON_AddItemToArray( object, item );\n-}\n-\n-void cJSON_AddItemReferenceToArray( cJSON *array, cJSON *item )\n-{\n-\tcJSON_AddItemToArray( array, create_reference( item ) );\n-}\n-\n-void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )\n-{\n-\tcJSON_AddItemToObject( object, string, create_reference( item ) );\n-}\n-\n-cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )\n-{\n-\tcJSON *c = array->child;\n-\twhile ( c && which > 0 ) {\n-\t\tc = c->next;\n-\t\t--which;\n-\t}\n-\tif ( ! c )\n-\t\treturn 0;\n-\tif ( c->prev )\n-\t\tc->prev->next = c->next;\n-\tif ( c->next ) c->next->prev = c->prev;\n-\tif ( c == array->child )\n-\t\tarray->child = c->next;\n-\tc->prev = c->next = 0;\n-\treturn c;\n-}\n-\n-void cJSON_DeleteItemFromArray( cJSON *array, int which )\n-{\n-\tcJSON_Delete( cJSON_DetachItemFromArray( array, which ) );\n-}\n-\n-cJSON *cJSON_DetachItemFromObject( cJSON *object, const char *string )\n-{\n-\tint i = 0;\n-\tcJSON *c = object->child;\n-\twhile ( c && cJSON_strcasecmp( c->string, string ) ) {\n-\t\t++i;\n-\t\tc = c->next;\n-\t}\n-\tif ( c )\n-\t\treturn cJSON_DetachItemFromArray( object, i );\n-\treturn 0;\n-}\n-\n-void cJSON_DeleteItemFromObject( cJSON *object, const char *string )\n-{\n-\tcJSON_Delete( cJSON_DetachItemFromObject( object, string ) );\n-}\n+void   cJSON_AddItemToArray(cJSON *array, cJSON *item)\t\t\t\t\t\t{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}\n+void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)\t{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}\n+void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)\t{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}\n+void\tcJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)\t\t\t\t\t\t{cJSON_AddItemToArray(array,create_reference(item));}\n+void\tcJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)\t{cJSON_AddItemToObject(object,string,create_reference(item));}\n+\n+cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)\t\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;\n+\tif (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}\n+void   cJSON_DeleteItemFromArray(cJSON *array,int which)\t\t\t{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}\n+cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}\n+void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}\n \n /* Replace array/object items with new ones. */\n-void cJSON_ReplaceItemInArray( cJSON *array, int which, cJSON *newitem )\n-{\n-\tcJSON *c = array->child;\n-\twhile ( c && which > 0 ) {\n-\t\tc = c->next;\n-\t\t--which;\n-\t}\n-\tif ( ! c )\n-\t\treturn;\n-\tnewitem->next = c->next;\n-\tnewitem->prev = c->prev;\n-\tif ( newitem->next )\n-\t\tnewitem->next->prev = newitem;\n-\tif ( c == array->child )\n-\t\tarray->child = newitem;\n-\telse\n-\t\tnewitem->prev->next = newitem;\n-\tc->next = c->prev = 0;\n-\tcJSON_Delete( c );\n-}\n-\n-void cJSON_ReplaceItemInObject( cJSON *object, const char *string, cJSON *newitem )\n-{\n-\tint i = 0;\n-\tcJSON *c = object->child;\n-\twhile ( c && cJSON_strcasecmp( c->string, string ) ) {\n-\t\t++i;\n-\t\tc = c->next;\n-\t}\n-\tif ( c ) {\n-\t\tnewitem->string = cJSON_strdup( string );\n-\t\tcJSON_ReplaceItemInArray( object, i, newitem );\n-\t}\n-}\n-\n+void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}\n+\tnewitem->next=c;newitem->prev=c->prev;c->prev=newitem;if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;}\n+void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;\n+\tnewitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;\n+\tif (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}\n+void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}\n \n /* Create basic types: */\n-\n-cJSON *cJSON_CreateNull( void )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item )\n-\t\titem->type = cJSON_NULL;\n-\treturn item;\n-}\n-\n-cJSON *cJSON_CreateTrue( void )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item )\n-\t\titem->type = cJSON_True;\n-\treturn item;\n-}\n-\n-cJSON *cJSON_CreateFalse( void )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item )\n-\t\titem->type = cJSON_False;\n-\treturn item;\n-}\n-\n-cJSON *cJSON_CreateBool( int b )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item )\n-\t\titem->type = b ? cJSON_True : cJSON_False;\n-\treturn item;\n-}\n-\n-cJSON *cJSON_CreateInt( int64_t num )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item ) {\n-\t\titem->type = cJSON_Number;\n-\t\titem->valuefloat = num;\n-\t\titem->valueint = num;\n-\t}\n-\treturn item;\n-}\n-\n-cJSON *cJSON_CreateFloat( double num )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item ) {\n-\t\titem->type = cJSON_Number;\n-\t\titem->valuefloat = num;\n-\t\titem->valueint = num;\n-\t}\n-\treturn item;\n-}\n-\n-cJSON *cJSON_CreateString( const char *string )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item ) {\n-\t\titem->type = cJSON_String;\n-\t\titem->valuestring = cJSON_strdup( string );\n-\t}\n-\treturn item;\n-}\n-\n-cJSON *cJSON_CreateArray( void )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item )\n-\t\titem->type = cJSON_Array;\n-\treturn item;\n-}\n-\n-cJSON *cJSON_CreateObject( void )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item )\n-\t\titem->type = cJSON_Object;\n-\treturn item;\n-}\n-\n-\n-/* Create Arrays. */\n-\n-cJSON *cJSON_CreateIntArray( int64_t *numbers, int count )\n-{\n-\tint i;\n-\tcJSON *n = 0, *p = 0, *a = cJSON_CreateArray();\n-\tfor ( i = 0; a && i < count; ++i ) {\n-\t\tn = cJSON_CreateInt( numbers[i] );\n-\t\tif ( ! i )\n-\t\t\ta->child = n;\n-\t\telse\n-\t\t\tsuffix_object( p, n );\n-\t\tp = n;\n-\t}\n-\treturn a;\n-}\n-\n-cJSON *cJSON_CreateFloatArray( double *numbers, int count )\n-{\n-\tint i;\n-\tcJSON *n = 0, *p = 0, *a = cJSON_CreateArray();\n-\tfor ( i = 0; a && i < count; ++i ) {\n-\t\tn = cJSON_CreateFloat( numbers[i] );\n-\t\tif ( ! i )\n-\t\t\ta->child = n;\n-\t\telse\n-\t\t\tsuffix_object( p, n );\n-\t\tp = n;\n-\t}\n-\treturn a;\n-}\n-\n-cJSON *cJSON_CreateStringArray( const char **strings, int count )\n-{\n-\tint i;\n-\tcJSON *n = 0, *p = 0, *a = cJSON_CreateArray();\n-\tfor ( i = 0; a && i < count; ++i ) {\n-\t\tn = cJSON_CreateString( strings[i] );\n-\t\tif ( ! i )\n-\t\t\ta->child = n;\n-\t\telse\n-\t\t\tsuffix_object( p, n );\n-\t\tp = n;\n-\t}\n-\treturn a;\n+cJSON *cJSON_CreateNull(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}\n+cJSON *cJSON_CreateTrue(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}\n+cJSON *cJSON_CreateFalse(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}\n+cJSON *cJSON_CreateBool(int b)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}\n+cJSON *cJSON_CreateNumber(double num)\t\t\t{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int64_t)num;}return item;}\n+cJSON *cJSON_CreateString(const char *string)\t{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);if(!item->valuestring){cJSON_Delete(item);return 0;}}return item;}\n+cJSON *cJSON_CreateArray(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}\n+cJSON *cJSON_CreateObject(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}\n+\n+/* Create Arrays: */\n+cJSON *cJSON_CreateIntArray(const int *numbers,int count)\t\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\n+cJSON *cJSON_CreateFloatArray(const float *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\n+cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\n+cJSON *cJSON_CreateStringArray(const char **strings,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\n+\n+/* Duplication */\n+cJSON *cJSON_Duplicate(cJSON *item,int recurse)\n+{\n+\tcJSON *newitem,*cptr,*nptr=0,*newchild;\n+\t/* Bail on bad ptr */\n+\tif (!item) return 0;\n+\t/* Create new item */\n+\tnewitem=cJSON_New_Item();\n+\tif (!newitem) return 0;\n+\t/* Copy over all vars */\n+\tnewitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;\n+\tif (item->valuestring)\t{newitem->valuestring=cJSON_strdup(item->valuestring);\tif (!newitem->valuestring)\t{cJSON_Delete(newitem);return 0;}}\n+\tif (item->string)\t\t{newitem->string=cJSON_strdup(item->string);\t\t\tif (!newitem->string)\t\t{cJSON_Delete(newitem);return 0;}}\n+\t/* If non-recursive, then we're done! */\n+\tif (!recurse) return newitem;\n+\t/* Walk the ->next chain for the child. */\n+\tcptr=item->child;\n+\twhile (cptr)\n+\t{\n+\t\tnewchild=cJSON_Duplicate(cptr,1);\t\t/* Duplicate (with recurse) each item in the ->next chain */\n+\t\tif (!newchild) {cJSON_Delete(newitem);return 0;}\n+\t\tif (nptr)\t{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}\t/* If newitem->child already set, then crosswire ->prev and ->next and move on */\n+\t\telse\t\t{newitem->child=newchild;nptr=newchild;}\t\t\t\t\t/* Set newitem->child and move to it */\n+\t\tcptr=cptr->next;\n+\t}\n+\treturn newitem;\n+}\n+\n+void cJSON_Minify(char *json)\n+{\n+\tchar *into=json;\n+\twhile (*json)\n+\t{\n+\t\tif (*json==' ') json++;\n+\t\telse if (*json=='\\t') json++;\t/* Whitespace characters. */\n+\t\telse if (*json=='\\r') json++;\n+\t\telse if (*json=='\\n') json++;\n+\t\telse if (*json=='/' && json[1]=='/')  while (*json && *json!='\\n') json++;\t/* double-slash comments, to end of line. */\n+\t\telse if (*json=='/' && json[1]=='*') {while (*json && !(*json=='*' && json[1]=='/')) json++;json+=2;}\t/* multiline comments. */\n+\t\telse if (*json=='\\\"'){*into++=*json++;while (*json && *json!='\\\"'){if (*json=='\\\\') *into++=*json++;*into++=*json++;}*into++=*json++;} /* string literals, which are \\\" sensitive. */\n+\t\telse *into++=*json++;\t\t\t/* All other characters. */\n+\t}\n+\t*into=0;\t/* and null-terminate. */\n }"
        },
        {
          "filename": "src/cjson.h",
          "status": "modified",
          "additions": 79,
          "deletions": 54,
          "patch": "@@ -29,97 +29,122 @@ extern \"C\"\n #endif\n \n /* cJSON Types: */\n-#define cJSON_False 0\n-#define cJSON_True 1\n-#define cJSON_NULL 2\n-#define cJSON_Number 3\n-#define cJSON_String 4\n-#define cJSON_Array 5\n-#define cJSON_Object 6\n+#define cJSON_False  (1 << 0)\n+#define cJSON_True   (1 << 1)\n+#define cJSON_NULL   (1 << 2)\n+#define cJSON_Number (1 << 3)\n+#define cJSON_String (1 << 4)\n+#define cJSON_Array  (1 << 5)\n+#define cJSON_Object (1 << 6)\n \t\n #define cJSON_IsReference 256\n+#define cJSON_StringIsConst 512\n \n /* The cJSON structure: */\n typedef struct cJSON {\n-\tstruct cJSON *next, *prev;\t/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */\n+\tstruct cJSON *next,*prev;\t/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */\n \tstruct cJSON *child;\t\t/* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */\n \n-\tint type;\t\t\t/* The type of the item, as above. */\n+\tint type;\t\t\t\t\t/* The type of the item, as above. */\n \n-\tchar *valuestring;\t\t/* The item's string, if type==cJSON_String */\n-\tint64_t valueint;\t\t/* The item's number, if type==cJSON_Number */\n-\tdouble valuefloat;\t\t/* The item's number, if type==cJSON_Number */\n+\tchar *valuestring;\t\t\t/* The item's string, if type==cJSON_String */\n+\tint64_t valueint;\t\t\t/* The item's number, if type==cJSON_Number */\n+\tdouble valuedouble;\t\t\t/* The item's number, if type==cJSON_Number */\n \n-\tchar *string;\t\t\t/* The item's name string, if this item is the child of, or is in the list of subitems of an object. */\n+\tchar *string;\t\t\t\t/* The item's name string, if this item is the child of, or is in the list of subitems of an object. */\n } cJSON;\n \n typedef struct cJSON_Hooks {\n-      void *(*malloc_fn)(size_t sz );\n-      void (*free_fn)( void *ptr );\n+      void *(*malloc_fn)(size_t sz);\n+      void (*free_fn)(void *ptr);\n } cJSON_Hooks;\n \n /* Supply malloc, realloc and free functions to cJSON */\n-extern void cJSON_InitHooks( cJSON_Hooks* hooks );\n+extern void cJSON_InitHooks(cJSON_Hooks* hooks);\n \n \n /* Supply a block of JSON, and this returns a cJSON object you can interrogate. Call cJSON_Delete when finished. */\n-extern cJSON *cJSON_Parse( const char *value );\n+extern cJSON *cJSON_Parse(const char *value);\n /* Render a cJSON entity to text for transfer/storage. Free the char* when finished. */\n-extern char *cJSON_Print( cJSON *item );\n+extern char  *cJSON_Print(cJSON *item);\n /* Render a cJSON entity to text for transfer/storage without any formatting. Free the char* when finished. */\n-extern char *cJSON_PrintUnformatted( cJSON *item );\n+extern char  *cJSON_PrintUnformatted(cJSON *item);\n+/* Render a cJSON entity to text using a buffered strategy. prebuffer is a guess at the final size. guessing well reduces reallocation. fmt=0 gives unformatted, =1 gives formatted */\n+extern char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt);\n /* Delete a cJSON entity and all subentities. */\n-extern void cJSON_Delete( cJSON *c );\n+extern void   cJSON_Delete(cJSON *c);\n \n /* Returns the number of items in an array (or object). */\n-extern int cJSON_GetArraySize( cJSON *array );\n+extern int\t  cJSON_GetArraySize(cJSON *array);\n /* Retrieve item number \"item\" from array \"array\". Returns NULL if unsuccessful. */\n-extern cJSON *cJSON_GetArrayItem( cJSON *array, int item );\n+extern cJSON *cJSON_GetArrayItem(cJSON *array,int item);\n /* Get item \"string\" from object. Case insensitive. */\n-extern cJSON *cJSON_GetObjectItem( cJSON *object, const char *string );\n-\n+extern cJSON *cJSON_GetObjectItem(cJSON *object,const char *string);\n+extern int cJSON_HasObjectItem(cJSON *object,const char *string);\n /* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */\n-extern const char *cJSON_GetErrorPtr( void );\n+extern const char *cJSON_GetErrorPtr(void);\n \t\n /* These calls create a cJSON item of the appropriate type. */\n-extern cJSON *cJSON_CreateNull( void );\n-extern cJSON *cJSON_CreateTrue( void );\n-extern cJSON *cJSON_CreateFalse( void );\n-extern cJSON *cJSON_CreateBool( int b );\n-extern cJSON *cJSON_CreateInt( int64_t num );\n-extern cJSON *cJSON_CreateFloat( double num );\n-extern cJSON *cJSON_CreateString( const char *string );\n-extern cJSON *cJSON_CreateArray( void );\n-extern cJSON *cJSON_CreateObject( void );\n+extern cJSON *cJSON_CreateNull(void);\n+extern cJSON *cJSON_CreateTrue(void);\n+extern cJSON *cJSON_CreateFalse(void);\n+extern cJSON *cJSON_CreateBool(int b);\n+extern cJSON *cJSON_CreateNumber(double num);\n+extern cJSON *cJSON_CreateString(const char *string);\n+extern cJSON *cJSON_CreateArray(void);\n+extern cJSON *cJSON_CreateObject(void);\n \n /* These utilities create an Array of count items. */\n-extern cJSON *cJSON_CreateIntArray( int64_t *numbers, int count );\n-extern cJSON *cJSON_CreateFloatArray( double *numbers, int count );\n-extern cJSON *cJSON_CreateStringArray( const char **strings, int count );\n+extern cJSON *cJSON_CreateIntArray(const int *numbers,int count);\n+extern cJSON *cJSON_CreateFloatArray(const float *numbers,int count);\n+extern cJSON *cJSON_CreateDoubleArray(const double *numbers,int count);\n+extern cJSON *cJSON_CreateStringArray(const char **strings,int count);\n \n /* Append item to the specified array/object. */\n-extern void cJSON_AddItemToArray( cJSON *array, cJSON *item );\n-extern void cJSON_AddItemToObject( cJSON *object, const char *string, cJSON *item );\n+extern void cJSON_AddItemToArray(cJSON *array, cJSON *item);\n+extern void\tcJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item);\n+extern void\tcJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item);\t/* Use this when string is definitely const (i.e. a literal, or as good as), and will definitely survive the cJSON object */\n /* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */\n-extern void cJSON_AddItemReferenceToArray( cJSON *array, cJSON *item );\n-extern void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item );\n+extern void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);\n+extern void\tcJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item);\n \n /* Remove/Detatch items from Arrays/Objects. */\n-extern cJSON *cJSON_DetachItemFromArray( cJSON *array, int which );\n-extern void cJSON_DeleteItemFromArray( cJSON *array, int which );\n-extern cJSON *cJSON_DetachItemFromObject( cJSON *object, const char *string );\n-extern void cJSON_DeleteItemFromObject( cJSON *object, const char *string );\n+extern cJSON *cJSON_DetachItemFromArray(cJSON *array,int which);\n+extern void   cJSON_DeleteItemFromArray(cJSON *array,int which);\n+extern cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string);\n+extern void   cJSON_DeleteItemFromObject(cJSON *object,const char *string);\n \t\n /* Update array items. */\n-extern void cJSON_ReplaceItemInArray( cJSON *array, int which, cJSON *newitem );\n-extern void cJSON_ReplaceItemInObject( cJSON *object, const char *string, cJSON *newitem );\n-\n-#define cJSON_AddNullToObject( object, name )\t\tcJSON_AddItemToObject( object, name, cJSON_CreateNull() )\n-#define cJSON_AddTrueToObject( object, name )\t\tcJSON_AddItemToObject( object, name, cJSON_CreateTrue() )\n-#define cJSON_AddFalseToObject( object, name )\t\tcJSON_AddItemToObject( object, name, cJSON_CreateFalse() )\n-#define cJSON_AddIntToObject( object, name, n )\t\tcJSON_AddItemToObject( object, name, cJSON_CreateInt( n ) )\n-#define cJSON_AddFloatToObject( object, name, n )\tcJSON_AddItemToObject( object, name, cJSON_CreateFloat( n ) )\n-#define cJSON_AddStringToObject( object, name, s )\tcJSON_AddItemToObject( object, name, cJSON_CreateString( s ) )\n+extern void cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem);\t/* Shifts pre-existing items to the right. */\n+extern void cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem);\n+extern void cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);\n+\n+/* Duplicate a cJSON item */\n+extern cJSON *cJSON_Duplicate(cJSON *item,int recurse);\n+/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will\n+need to be released. With recurse!=0, it will duplicate any children connected to the item.\n+The item->next and ->prev pointers are always zero on return from Duplicate. */\n+\n+/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */\n+/* If you supply a ptr in return_parse_end and parsing fails, then return_parse_end will contain a pointer to the error. If not, then cJSON_GetErrorPtr() does the job. */\n+extern cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated);\n+\n+extern void cJSON_Minify(char *json);\n+\n+/* Macros for creating things quickly. */\n+#define cJSON_AddNullToObject(object,name)\t\tcJSON_AddItemToObject(object, name, cJSON_CreateNull())\n+#define cJSON_AddTrueToObject(object,name)\t\tcJSON_AddItemToObject(object, name, cJSON_CreateTrue())\n+#define cJSON_AddFalseToObject(object,name)\t\tcJSON_AddItemToObject(object, name, cJSON_CreateFalse())\n+#define cJSON_AddBoolToObject(object,name,b)\tcJSON_AddItemToObject(object, name, cJSON_CreateBool(b))\n+#define cJSON_AddNumberToObject(object,name,n)\tcJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))\n+#define cJSON_AddStringToObject(object,name,s)\tcJSON_AddItemToObject(object, name, cJSON_CreateString(s))\n+\n+/* When assigning an integer value, it needs to be propagated to valuedouble too. */\n+#define cJSON_SetIntValue(object,val)\t\t\t((object)?(object)->valueint=(object)->valuedouble=(val):(val))\n+#define cJSON_SetNumberValue(object,val)\t\t((object)?(object)->valueint=(object)->valuedouble=(val):(val))\n+\n+/* Macro for iterating over an array */\n+#define cJSON_ArrayForEach(pos, head)\t\t\tfor(pos = (head)->child; pos != NULL; pos = pos->next)\n \n #ifdef __cplusplus\n }"
        },
        {
          "filename": "src/iperf_api.c",
          "status": "modified",
          "additions": 39,
          "deletions": 29,
          "patch": "@@ -523,11 +523,11 @@ iperf_on_connect(struct iperf_test *test)\n \tcJSON_AddStringToObject(test->json_start, \"cookie\", test->cookie);\n         if (test->protocol->id == SOCK_STREAM) {\n \t    if (test->settings->mss)\n-\t\tcJSON_AddIntToObject(test->json_start, \"tcp_mss\", test->settings->mss);\n+\t\tcJSON_AddNumberToObject(test->json_start, \"tcp_mss\", test->settings->mss);\n \t    else {\n \t\tlen = sizeof(opt);\n \t\tgetsockopt(test->ctrl_sck, IPPROTO_TCP, TCP_MAXSEG, &opt, &len);\n-\t\tcJSON_AddIntToObject(test->json_start, \"tcp_mss_default\", opt);\n+\t\tcJSON_AddNumberToObject(test->json_start, \"tcp_mss_default\", opt);\n \t    }\n \t}\n     } else if (test->verbose) {\n@@ -1135,40 +1135,50 @@ send_parameters(struct iperf_test *test)\n \t    cJSON_AddTrueToObject(j, \"tcp\");\n \telse if (test->protocol->id == Pudp)\n \t    cJSON_AddTrueToObject(j, \"udp\");\n-\tcJSON_AddIntToObject(j, \"omit\", test->omit);\n+\tcJSON_AddNumberToObject(j, \"omit\", test->omit);\n \tif (test->server_affinity != -1)\n-\t    cJSON_AddIntToObject(j, \"server_affinity\", test->server_affinity);\n+\t    cJSON_AddNumberToObject(j, \"server_affinity\", test->server_affinity);\n \tif (test->duration)\n-\t    cJSON_AddIntToObject(j, \"time\", test->duration);\n+\t    cJSON_AddNumberToObject(j, \"time\", test->duration);\n \tif (test->settings->bytes)\n-\t    cJSON_AddIntToObject(j, \"num\", test->settings->bytes);\n+\t    cJSON_AddNumberToObject(j, \"num\", test->settings->bytes);\n \tif (test->settings->blocks)\n-\t    cJSON_AddIntToObject(j, \"blockcount\", test->settings->blocks);\n+\t    cJSON_AddNumberToObject(j, \"blockcount\", test->settings->blocks);\n \tif (test->settings->mss)\n-\t    cJSON_AddIntToObject(j, \"MSS\", test->settings->mss);\n+\t    cJSON_AddNumberToObject(j, \"MSS\", test->settings->mss);\n \tif (test->no_delay)\n \t    cJSON_AddTrueToObject(j, \"nodelay\");\n-\tcJSON_AddIntToObject(j, \"parallel\", test->num_streams);\n+\tcJSON_AddNumberToObject(j, \"parallel\", test->num_streams);\n \tif (test->reverse)\n \t    cJSON_AddTrueToObject(j, \"reverse\");\n \tif (test->settings->socket_bufsize)\n-\t    cJSON_AddIntToObject(j, \"window\", test->settings->socket_bufsize);\n+\t    cJSON_AddNumberToObject(j, \"window\", test->settings->socket_bufsize);\n \tif (test->settings->blksize)\n-\t    cJSON_AddIntToObject(j, \"len\", test->settings->blksize);\n+\t    cJSON_AddNumberToObject(j, \"len\", test->settings->blksize);\n \tif (test->settings->rate)\n-\t    cJSON_AddIntToObject(j, \"bandwidth\", test->settings->rate);\n+\t    cJSON_AddNumberToObject(j, \"bandwidth\", test->settings->rate);\n \tif (test->settings->burst)\n-\t    cJSON_AddIntToObject(j, \"burst\", test->settings->burst);\n+\t    cJSON_AddNumberToObject(j, \"burst\", test->settings->burst);\n \tif (test->settings->tos)\n-\t    cJSON_AddIntToObject(j, \"TOS\", test->settings->tos);\n+\t    cJSON_AddNumberToObject(j, \"TOS\", test->settings->tos);\n \tif (test->settings->flowlabel)\n-\t    cJSON_AddIntToObject(j, \"flowlabel\", test->settings->flowlabel);\n+\t    cJSON_AddNumberToObject(j, \"flowlabel\", test->settings->flowlabel);\n \tif (test->title)\n \t    cJSON_AddStringToObject(j, \"title\", test->title);\n \tif (test->congestion)\n \t    cJSON_AddStringToObject(j, \"congestion\", test->congestion);\n \tif (test->get_server_output)\n+<<<<<<< HEAD\n \t    cJSON_AddIntToObject(j, \"get_server_output\", iperf_get_test_get_server_output(test));\n+=======\n+\t    cJSON_AddNumberToObject(j, \"get_server_output\", iperf_get_test_get_server_output(test));\n+\tif (test->udp_counters_64bit)\n+\t    cJSON_AddNumberToObject(j, \"udp_counters_64bit\", iperf_get_test_udp_counters_64bit(test));\n+\tif (test->no_fq_socket_pacing)\n+\t    cJSON_AddNumberToObject(j, \"no_fq_socket_pacing\", iperf_get_no_fq_socket_pacing(test));\n+\n+\tcJSON_AddStringToObject(j, \"client_version\", IPERF_VERSION);\n+>>>>>>> ed94082... Fix a buffer overflow / heap corruption issue that could occur if a\n \n \tif (test->debug) {\n \t    printf(\"send_parameters:\\n%s\\n\", cJSON_Print(j));\n@@ -1267,14 +1277,14 @@ send_results(struct iperf_test *test)\n \ti_errno = IEPACKAGERESULTS;\n \tr = -1;\n     } else {\n-\tcJSON_AddFloatToObject(j, \"cpu_util_total\", test->cpu_util[0]);\n-\tcJSON_AddFloatToObject(j, \"cpu_util_user\", test->cpu_util[1]);\n-\tcJSON_AddFloatToObject(j, \"cpu_util_system\", test->cpu_util[2]);\n+\tcJSON_AddNumberToObject(j, \"cpu_util_total\", test->cpu_util[0]);\n+\tcJSON_AddNumberToObject(j, \"cpu_util_user\", test->cpu_util[1]);\n+\tcJSON_AddNumberToObject(j, \"cpu_util_system\", test->cpu_util[2]);\n \tif ( ! test->sender )\n \t    sender_has_retransmits = -1;\n \telse\n \t    sender_has_retransmits = test->sender_has_retransmits;\n-\tcJSON_AddIntToObject(j, \"sender_has_retransmits\", sender_has_retransmits);\n+\tcJSON_AddNumberToObject(j, \"sender_has_retransmits\", sender_has_retransmits);\n \n \t/* If on the server and sending server output, then do this */\n \tif (test->role == 's' && test->get_server_output) {\n@@ -1318,12 +1328,12 @@ send_results(struct iperf_test *test)\n \t\t    cJSON_AddItemToArray(j_streams, j_stream);\n \t\t    bytes_transferred = test->sender ? sp->result->bytes_sent : sp->result->bytes_received;\n \t\t    retransmits = (test->sender && test->sender_has_retransmits) ? sp->result->stream_retrans : -1;\n-\t\t    cJSON_AddIntToObject(j_stream, \"id\", sp->id);\n-\t\t    cJSON_AddIntToObject(j_stream, \"bytes\", bytes_transferred);\n-\t\t    cJSON_AddIntToObject(j_stream, \"retransmits\", retransmits);\n-\t\t    cJSON_AddFloatToObject(j_stream, \"jitter\", sp->jitter);\n-\t\t    cJSON_AddIntToObject(j_stream, \"errors\", sp->cnt_error);\n-\t\t    cJSON_AddIntToObject(j_stream, \"packets\", sp->packet_count);\n+\t\t    cJSON_AddNumberToObject(j_stream, \"id\", sp->id);\n+\t\t    cJSON_AddNumberToObject(j_stream, \"bytes\", bytes_transferred);\n+\t\t    cJSON_AddNumberToObject(j_stream, \"retransmits\", retransmits);\n+\t\t    cJSON_AddNumberToObject(j_stream, \"jitter\", sp->jitter);\n+\t\t    cJSON_AddNumberToObject(j_stream, \"errors\", sp->cnt_error);\n+\t\t    cJSON_AddNumberToObject(j_stream, \"packets\", sp->packet_count);\n \t\t}\n \t    }\n \t    if (r == 0 && test->debug) {\n@@ -1384,9 +1394,9 @@ get_results(struct iperf_test *test)\n \t\tprintf(\"get_results\\n%s\\n\", cJSON_Print(j));\n \t    }\n \n-\t    test->remote_cpu_util[0] = j_cpu_util_total->valuefloat;\n-\t    test->remote_cpu_util[1] = j_cpu_util_user->valuefloat;\n-\t    test->remote_cpu_util[2] = j_cpu_util_system->valuefloat;\n+\t    test->remote_cpu_util[0] = j_cpu_util_total->valuedouble;\n+\t    test->remote_cpu_util[1] = j_cpu_util_user->valuedouble;\n+\t    test->remote_cpu_util[2] = j_cpu_util_system->valuedouble;\n \t    result_has_retransmits = j_sender_has_retransmits->valueint;\n \t    if (! test->sender)\n \t\ttest->sender_has_retransmits = result_has_retransmits;\n@@ -1415,7 +1425,7 @@ get_results(struct iperf_test *test)\n \t\t\t    sid = j_id->valueint;\n \t\t\t    bytes_transferred = j_bytes->valueint;\n \t\t\t    retransmits = j_retransmits->valueint;\n-\t\t\t    jitter = j_jitter->valuefloat;\n+\t\t\t    jitter = j_jitter->valuedouble;\n \t\t\t    cerror = j_errors->valueint;\n \t\t\t    pcount = j_packets->valueint;\n \t\t\t    SLIST_FOREACH(sp, &test->streams, streams)"
        },
        {
          "filename": "src/iperf_util.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -272,10 +272,10 @@ iperf_json_printf(const char *format, ...)\n \t\tj = cJSON_CreateBool(va_arg(argp, int));\n \t\tbreak;\n \t\tcase 'd':\n-\t\tj = cJSON_CreateInt(va_arg(argp, int64_t));\n+\t\tj = cJSON_CreateNumber(va_arg(argp, int64_t));\n \t\tbreak;\n \t\tcase 'f':\n-\t\tj = cJSON_CreateFloat(va_arg(argp, double));\n+\t\tj = cJSON_CreateNumber(va_arg(argp, double));\n \t\tbreak;\n \t\tcase 's':\n \t\tj = cJSON_CreateString(va_arg(argp, char *));"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "352ef1bdfc2df1c7e3455b5652d810d52ffb190d",
            "date": "2025-01-10T21:52:54Z",
            "author_login": "bmah888"
          },
          {
            "sha": "85d454c27ca172e391bde73c91c93153d6960bbf",
            "date": "2024-12-17T18:43:27Z",
            "author_login": "bmah888"
          },
          {
            "sha": "0f7366ca2ef598c9953cfa914be5e8771af3885b",
            "date": "2024-12-17T18:42:55Z",
            "author_login": "bmah888"
          },
          {
            "sha": "e4cb673170a395c12d83ad74b247659b2e70e257",
            "date": "2024-12-16T22:15:25Z",
            "author_login": "bmah888"
          },
          {
            "sha": "1e80c4fcbef6904e89c4dbb088c06ca1f87672f0",
            "date": "2024-12-14T18:01:00Z",
            "author_login": "hwti"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-120",
    "description": "The parse_string function in cjson.c in the cJSON library mishandles UTF8/16 strings, which allows remote attackers to cause a denial of service (crash) or execute arbitrary code via a non-hex character in a JSON string, which triggers a heap-based buffer overflow.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2016-09-26T14:59:01.553",
    "last_modified": "2024-11-21T02:51:50.017",
    "fix_date": "2016-06-03T16:23:59Z"
  },
  "references": [
    {
      "url": "http://blog.talosintel.com/2016/06/esnet-vulnerability.html",
      "source": "cret@cert.org",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2016-08/msg00082.html",
      "source": "cret@cert.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2016-08/msg00090.html",
      "source": "cret@cert.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://software.es.net/iperf/news.html#security-issue-iperf-3-1-3-iperf-3-0-12-released",
      "source": "cret@cert.org",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.talosintelligence.com/reports/TALOS-2016-0164/",
      "source": "cret@cert.org",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a",
      "source": "cret@cert.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2020/01/msg00023.html",
      "source": "cret@cert.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://raw.githubusercontent.com/esnet/security/master/cve-2016-4303/esnet-secadv-2016-0001.txt.asc",
      "source": "cret@cert.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://blog.talosintel.com/2016/06/esnet-vulnerability.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2016-08/msg00082.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-updates/2016-08/msg00090.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://software.es.net/iperf/news.html#security-issue-iperf-3-1-3-iperf-3-0-12-released",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.talosintelligence.com/reports/TALOS-2016-0164/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2020/01/msg00023.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://raw.githubusercontent.com/esnet/security/master/cve-2016-4303/esnet-secadv-2016-0001.txt.asc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:46.795517",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "iperf",
    "owner": "esnet",
    "created_at": "2014-02-25T18:42:52Z",
    "updated_at": "2025-01-14T16:04:03Z",
    "pushed_at": "2025-01-10T21:52:54Z",
    "size": 13715,
    "stars": 7148,
    "forks": 1294,
    "open_issues": 216,
    "watchers": 7148,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "C": 625910,
      "Shell": 405552,
      "Makefile": 138792,
      "M4": 39335,
      "Roff": 23989,
      "Python": 3787,
      "Gnuplot": 997,
      "Dockerfile": 570
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T18:15:53.326521"
  }
}