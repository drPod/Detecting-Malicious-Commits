{
  "cve_id": "CVE-2016-4442",
  "github_data": {
    "repository": "MiniProfiler/rack-mini-profiler",
    "fix_commit": "4273771d65f1a7411e3ef5843329308d0e2d257c",
    "related_commits": [
      "4273771d65f1a7411e3ef5843329308d0e2d257c",
      "4273771d65f1a7411e3ef5843329308d0e2d257c"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "4273771d65f1a7411e3ef5843329308d0e2d257c",
      "commit_date": "2016-05-18T07:07:17Z",
      "author": {
        "login": "SamSaffron",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "FEATURE: perform security checks earlier in the pipeline",
        "length": 249,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 529,
        "additions": 435,
        "deletions": 94
      },
      "files": [
        {
          "filename": "Gemfile",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -2,4 +2,4 @@ source 'http://rubygems.org'\n \n gemspec\n \n-gem 'codecov', :require => false, :group => :test\n\\ No newline at end of file\n+gem 'codecov', :require => false, :group => :test"
        },
        {
          "filename": "Guardfile",
          "status": "added",
          "additions": 30,
          "deletions": 0,
          "patch": "@@ -0,0 +1,30 @@\n+# A sample Guardfile\n+# More info at https://github.com/guard/guard#readme\n+\n+directories %w(lib spec) \\\n+ .select{|d| Dir.exists?(d) ? d : UI.warning(\"Directory #{d} does not exist\")}\n+\n+## Note: if you are using the `directories` clause above and you are not\n+## watching the project directory ('.'), then you will want to move\n+## the Guardfile to a watched dir and symlink it back, e.g.\n+#\n+#  $ mkdir config\n+#  $ mv Guardfile config/\n+#  $ ln -s config/Guardfile .\n+#\n+# and, you'll have to watch \"config/Guardfile\" instead of \"Guardfile\"\n+\n+# Note: The cmd option is now required due to the increasing number of ways\n+#       rspec may be run, below are examples of the most common uses.\n+#  * bundler: 'bundle exec rspec'\n+#  * bundler binstubs: 'bin/rspec'\n+#  * spring: 'bin/rsspec' (This will use spring if running and you have\n+#                          installed the spring binstubs per the docs)\n+#  * zeus: 'zeus rspec' (requires the server to be started separetly)\n+#  * 'just' rspec: 'rspec'\n+guard :rspec, cmd: 'bundle exec rspec', failed_mode: :focus do\n+  watch(%r{^spec/.+_spec\\.rb$})\n+  watch(%r{^lib/mini_profiler/(.+)\\.rb$})     { |m| \"spec/lib/#{m[1]}_spec.rb\" }\n+  watch('spec/spec_helper.rb')  { \"spec\" }\n+end\n+"
        },
        {
          "filename": "autotest/discover.rb",
          "status": "removed",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -1,2 +0,0 @@\n-Autotest.add_discovery { \"rspec2\" }\n-"
        },
        {
          "filename": "lib/mini_profiler/client_settings.rb",
          "status": "modified",
          "additions": 59,
          "deletions": 8,
          "patch": "@@ -12,39 +12,90 @@ class ClientSettings\n       attr_accessor :backtrace_level\n \n \n-      def initialize(env)\n+      def initialize(env, store, start)\n         request = ::Rack::Request.new(env)\n         @cookie = request.cookies[COOKIE_NAME]\n+        @store = store\n+        @start = start\n+\n+        @allowed_tokens, @orig_auth_tokens = nil\n+\n         if @cookie\n           @cookie.split(\",\").map{|pair| pair.split(\"=\")}.each do |k,v|\n             @orig_disable_profiling = @disable_profiling = (v=='t') if k == \"dp\"\n             @backtrace_level = v.to_i if k == \"bt\"\n+            @orig_auth_tokens = v.to_s.split(\"|\") if k == \"a\"\n           end\n         end\n \n-        @backtrace_level = nil if !@backtrace_level.nil? && (@backtrace_level == 0 || @backtrace_level > BACKTRACE_NONE)\n+        if !@backtrace_level.nil? && (@backtrace_level == 0 || @backtrace_level > BACKTRACE_NONE)\n+          @backtrace_level = nil\n+        end\n+\n         @orig_backtrace_level = @backtrace_level\n \n       end\n \n+      def handle_cookie(result)\n+        status,headers,_body = result\n+\n+        if (MiniProfiler.config.authorization_mode == :whitelist && !MiniProfiler.request_authorized?)\n+          # this is non-obvious, don't kill the profiling cookie on errors or short requests\n+          # this ensures that stuff that never reaches the rails stack does not kill profiling\n+          if status.to_i >= 200 && status.to_i < 300 && ((Time.now - @start) > 0.1)\n+            discard_cookie!(headers)\n+          end\n+        else\n+          write!(headers)\n+        end\n+\n+        result\n+      end\n+\n       def write!(headers)\n-        if @orig_disable_profiling != @disable_profiling || @orig_backtrace_level != @backtrace_level || @cookie.nil?\n+\n+        tokens_changed = false\n+\n+        if MiniProfiler.request_authorized? && MiniProfiler.config.authorization_mode == :whitelist\n+          @allowed_tokens ||= @store.allowed_tokens\n+          tokens_changed = !@orig_auth_tokens || ((@allowed_tokens - @orig_auth_tokens).length > 0)\n+        end\n+\n+        if  @orig_disable_profiling != @disable_profiling ||\n+            @orig_backtrace_level != @backtrace_level ||\n+            @cookie.nil? ||\n+            tokens_changed\n+\n           settings = {\"p\" =>  \"t\" }\n-          settings[\"dp\"] = \"t\"              if @disable_profiling\n-          settings[\"bt\"] = @backtrace_level if @backtrace_level\n+          settings[\"dp\"] = \"t\"                  if @disable_profiling\n+          settings[\"bt\"] = @backtrace_level     if @backtrace_level\n+          settings[\"a\"] = @allowed_tokens.join(\"|\") if @allowed_tokens && MiniProfiler.request_authorized?\n+\n           settings_string = settings.map{|k,v| \"#{k}=#{v}\"}.join(\",\")\n           Rack::Utils.set_cookie_header!(headers, COOKIE_NAME, :value => settings_string, :path => '/')\n         end\n       end\n \n       def discard_cookie!(headers)\n-        Rack::Utils.delete_cookie_header!(headers, COOKIE_NAME, :path => '/')\n+        if @cookie\n+          Rack::Utils.delete_cookie_header!(headers, COOKIE_NAME, :path => '/')\n+        end\n       end\n \n-      def has_cookie?\n-        !@cookie.nil?\n+      def has_valid_cookie?\n+        valid_cookie = !@cookie.nil?\n+\n+        if (MiniProfiler.config.authorization_mode == :whitelist)\n+          @allowed_tokens ||= @store.allowed_tokens\n+\n+          valid_cookie = (Array === @orig_auth_tokens) &&\n+            ((@allowed_tokens & @orig_auth_tokens).length > 0)\n+        end\n+\n+        valid_cookie\n       end\n \n+\n       def disable_profiling?\n         @disable_profiling\n       end"
        },
        {
          "filename": "lib/mini_profiler/context.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,5 +1,6 @@\n class Rack::MiniProfiler::Context\n-  attr_accessor :inject_js,:current_timer,:page_struct,:skip_backtrace,:full_backtrace,:discard, :mpt_init, :measure\n+  attr_accessor :inject_js,:current_timer,:page_struct,:skip_backtrace,\n+                :full_backtrace,:discard, :mpt_init, :measure\n \n   def initialize(opts = {})\n     opts[\"measure\"] = true unless opts.key? \"measure\""
        },
        {
          "filename": "lib/mini_profiler/profiler.rb",
          "status": "modified",
          "additions": 21,
          "deletions": 34,
          "patch": "@@ -149,7 +149,9 @@ def config\n \n     def call(env)\n \n-      client_settings = ClientSettings.new(env)\n+      start = Time.now\n+      client_settings = ClientSettings.new(env, @storage, start)\n+      MiniProfiler.deauthorize_request if @config.authorization_mode == :whitelist\n \n       status = headers = body = nil\n       query_string = env['QUERY_STRING']\n@@ -162,43 +164,39 @@ def call(env)\n                 (@config.skip_paths && @config.skip_paths.any?{ |p| path.start_with?(p) }) ||\n                 query_string =~ /pp=skip/\n \n-      has_profiling_cookie = client_settings.has_cookie?\n-\n-      if skip_it || (@config.authorization_mode == :whitelist && !has_profiling_cookie)\n-        status,headers,body = @app.call(env)\n-        if !skip_it && @config.authorization_mode == :whitelist && !has_profiling_cookie && MiniProfiler.request_authorized?\n-          client_settings.write!(headers)\n-        end\n-        return [status,headers,body]\n+      if skip_it || (\n+        @config.authorization_mode == :whitelist &&\n+        !client_settings.has_valid_cookie?\n+      )\n+        return client_settings.handle_cookie(@app.call(env))\n       end\n \n       # handle all /mini-profiler requests here\n-      return serve_html(env) if path.start_with? @config.base_url_path\n+      return client_settings.handle_cookie(serve_html(env)) if path.start_with? @config.base_url_path\n \n       has_disable_cookie = client_settings.disable_profiling?\n       # manual session disable / enable\n       if query_string =~ /pp=disable/ || has_disable_cookie\n         skip_it = true\n       end\n \n-      if query_string =~ /pp=enable/ && (@config.authorization_mode != :whitelist || MiniProfiler.request_authorized?)\n+      if query_string =~ /pp=enable/\n         skip_it = false\n         config.enabled = true\n       end\n \n       if skip_it || !config.enabled\n         status,headers,body = @app.call(env)\n         client_settings.disable_profiling = true\n-        client_settings.write!(headers)\n-        return [status,headers,body]\n+        return client_settings.handle_cookie([status,headers,body])\n       else\n         client_settings.disable_profiling = false\n       end\n \n       # profile gc\n       if query_string =~ /pp=profile-gc/\n         current.measure = false if current\n-        return Rack::MiniProfiler::GCProfiler.new.profile_gc(@app, env)\n+        return client_settings.handle_cookie(Rack::MiniProfiler::GCProfiler.new.profile_gc(@app, env))\n       end\n \n       # profile memory\n@@ -215,11 +213,10 @@ def call(env)\n           body.close if body.respond_to? :close\n         end\n         report.pretty_print(result)\n-        return text_result(result.string)\n+        return client_settings.handle_cookie(text_result(result.string))\n       end\n \n       MiniProfiler.create_current(env, @config)\n-      MiniProfiler.deauthorize_request if @config.authorization_mode == :whitelist\n \n       if query_string =~ /pp=normal-backtrace/\n         client_settings.backtrace_level = ClientSettings::BACKTRACE_DEFAULT\n@@ -238,7 +235,6 @@ def call(env)\n       trace_exceptions = query_string =~ /pp=trace-exceptions/ && defined? TracePoint\n       status, headers, body, exceptions,trace = nil\n \n-      start = Time.now\n \n       if trace_exceptions\n         exceptions = []\n@@ -281,43 +277,37 @@ def call(env)\n         else\n           status,headers,body = @app.call(env)\n         end\n-        client_settings.write!(headers)\n       ensure\n         trace.disable if trace\n       end\n \n       skip_it = current.discard\n \n       if (config.authorization_mode == :whitelist && !MiniProfiler.request_authorized?)\n-        # this is non-obvious, don't kill the profiling cookie on errors or short requests\n-        # this ensures that stuff that never reaches the rails stack does not kill profiling\n-        if status.to_i >= 200 && status.to_i < 300 && ((Time.now - start) > 0.1)\n-          client_settings.discard_cookie!(headers)\n-        end\n         skip_it = true\n       end\n \n-      return [status,headers,body] if skip_it\n+      return client_settings.handle_cookie([status,headers,body]) if skip_it\n \n       # we must do this here, otherwise current[:discard] is not being properly treated\n       if trace_exceptions\n         body.close if body.respond_to? :close\n-        return dump_exceptions exceptions\n+        return client_settings.handle_cookie(dump_exceptions exceptions)\n       end\n \n       if query_string =~ /pp=env/ && !config.disable_env_dump\n         body.close if body.respond_to? :close\n-        return dump_env env\n+        return client_settings.handle_cookie(dump_env env)\n       end\n \n       if query_string =~ /pp=analyze-memory/\n         body.close if body.respond_to? :close\n-        return analyze_memory\n+        return client_settings.handle_cookie(analyze_memory)\n       end\n \n       if query_string =~ /pp=help/\n         body.close if body.respond_to? :close\n-        return help(client_settings, env)\n+        return client_settings.handle_cookie(help(client_settings, env))\n       end\n \n       page_struct = current.page_struct\n@@ -326,7 +316,7 @@ def call(env)\n \n       if flamegraph\n         body.close if body.respond_to? :close\n-        return self.flamegraph(flamegraph)\n+        return client_settings.handle_cookie(self.flamegraph(flamegraph))\n       end\n \n \n@@ -337,18 +327,16 @@ def call(env)\n \n         # inject headers, script\n         if status >= 200 && status < 300\n-          client_settings.write!(headers)\n           result = inject_profiler(env,status,headers,body)\n-          return result if result\n+          return client_settings.handle_cookie(result) if result\n         end\n       rescue Exception => e\n         if @config.storage_failure != nil\n           @config.storage_failure.call(e)\n         end\n       end\n \n-      client_settings.write!(headers)\n-      [status, headers, body]\n+      client_settings.handle_cookie([status, headers, body])\n \n     ensure\n       # Make sure this always happens\n@@ -543,7 +531,6 @@ def help(client_settings, env)\n </html>\n \"\n \n-      client_settings.write!(headers)\n       [200, headers, [body]]\n     end\n "
        },
        {
          "filename": "lib/mini_profiler/storage/abstract_store.rb",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -2,6 +2,9 @@ module Rack\n   class MiniProfiler\n     class AbstractStore\n \n+      # maximum age of allowed tokens before cycling in seconds\n+      MAX_TOKEN_AGE = 1800\n+\n       def save(page_struct)\n         raise NotImplementedError.new(\"save is not implemented\")\n       end\n@@ -31,6 +34,11 @@ def diagnostics(user)\n         \"\"\n       end\n \n+      # a list of tokens that are permitted to access profiler in whitelist mode\n+      def allowed_tokens\n+        raise NotImplementedError.new(\"allowed_tokens is not implemented\")\n+      end\n+\n     end\n   end\n end"
        },
        {
          "filename": "lib/mini_profiler/storage/file_store.rb",
          "status": "modified",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -51,6 +51,9 @@ def initialize(args = nil)\n         @user_view_cache    = FileCache.new(@path, \"mp_views\")\n         @user_view_lock     = Mutex.new\n \n+        @auth_token_cache    = FileCache.new(@path, \"tokens\")\n+        @auth_token_lock     = Mutex.new\n+\n         me = self\n         t = CacheCleanupThread.new do\n           interval = 10\n@@ -126,6 +129,28 @@ def get_unviewed_ids(user)\n         }\n       end\n \n+      def flush_tokens\n+        @auth_token_lock.synchronize {\n+          @auth_token_cache[\"\"] = nil\n+        }\n+      end\n+\n+      def allowed_tokens\n+        @auth_token_lock.synchronize {\n+          token1, token2, cycle_at = @auth_token_cache[\"\"]\n+\n+          unless cycle_at && (Time === cycle_at) && (cycle_at > Time.now)\n+            token2 = token1\n+            token1 = SecureRandom.hex\n+            cycle_at = Time.now + Rack::MiniProfiler::AbstractStore::MAX_TOKEN_AGE\n+          end\n+\n+          @auth_token_cache[\"\"] = [token1, token2, cycle_at]\n+\n+          [token1, token2].compact\n+        }\n+      end\n+\n       def cleanup_cache\n         files = Dir.entries(@path)\n         @timer_struct_lock.synchronize {"
        },
        {
          "filename": "lib/mini_profiler/storage/memcache_store.rb",
          "status": "modified",
          "additions": 33,
          "deletions": 0,
          "patch": "@@ -51,6 +51,39 @@ def get_unviewed_ids(user)\n         @client.get(\"#{@prefix}-#{user}-v\") || []\n       end\n \n+      def flush_tokens\n+        @client.set(\"#{@prefix}-tokens\", nil)\n+      end\n+\n+      def allowed_tokens\n+\n+        token_info = @client.get(\"#{@prefix}-tokens\")\n+        key1, key2, cycle_at = nil\n+\n+\n+        if token_info\n+           key1, key2, cycle_at = Marshal::load(token_info)\n+\n+           key1 = nil unless key1 && key1.length == 32\n+           key2 = nil unless key2 && key2.length == 32\n+\n+           if key1 && cycle_at && (cycle_at > Time.now)\n+              return [key1,key2].compact\n+           end\n+        end\n+\n+        timeout = Rack::MiniProfiler::AbstractStore::MAX_TOKEN_AGE\n+\n+        # cycle keys\n+        key2 = key1\n+        key1 = SecureRandom.hex\n+        cycle_at = Time.now + timeout\n+\n+        @client.set(\"#{@prefix}-tokens\", Marshal::dump([key1, key2, cycle_at]))\n+\n+        [key1, key2].compact\n+      end\n+\n     end\n   end\n end"
        },
        {
          "filename": "lib/mini_profiler/storage/memory_store.rb",
          "status": "modified",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -49,11 +49,15 @@ def increment_cycle\n       def initialize(args = nil)\n         args ||= {}\n         @expires_in_seconds = args.fetch(:expires_in) { EXPIRES_IN_SECONDS }\n+\n+        @token1, @token2, @cycle_tokens_at = nil\n+\n         initialize_locks\n         initialize_cleanup_thread(args)\n       end\n \n       def initialize_locks\n+        @token_lock = Mutex.new\n         @timer_struct_lock  = Mutex.new\n         @user_view_lock     = Mutex.new\n         @timer_struct_cache = {}\n@@ -116,6 +120,20 @@ def cleanup_cache\n           @timer_struct_cache.delete_if { |k, v| v[:started] < expire_older_than }\n         }\n       end\n+\n+      def allowed_tokens\n+        @token_lock.synchronize do\n+\n+          unless @cycle_at && (@cycle_at > Time.now)\n+            @token2 = @token1\n+            @token1 = SecureRandom.hex\n+            @cycle_at = Time.now + Rack::MiniProfiler::AbstractStore::MAX_TOKEN_AGE\n+          end\n+\n+          [@token1, @token2].compact\n+\n+        end\n+      end\n     end\n   end\n end"
        },
        {
          "filename": "lib/mini_profiler/storage/redis_store.rb",
          "status": "modified",
          "additions": 39,
          "deletions": 0,
          "patch": "@@ -2,6 +2,8 @@ module Rack\n   class MiniProfiler\n     class RedisStore < AbstractStore\n \n+      attr_reader :prefix\n+\n       EXPIRES_IN_SECONDS = 60 * 60 * 24\n \n       def initialize(args = nil)\n@@ -55,6 +57,43 @@ def diagnostics(user)\n \"\n       end\n \n+      def flush_tokens\n+        redis.del(\"#{@prefix}-key1\", \"#{@prefix}-key1_old\", \"#{@prefix}-key2\")\n+      end\n+\n+      # Only used for testing\n+      def simulate_expire\n+        redis.del(\"#{@prefix}-key1\")\n+      end\n+\n+      def allowed_tokens\n+        key1, key1_old, key2 = redis.mget(\"#{@prefix}-key1\", \"#{@prefix}-key1_old\", \"#{@prefix}-key2\")\n+\n+        if key1 && (key1.length == 32)\n+          return [key1, key2].compact\n+        end\n+\n+        timeout = Rack::MiniProfiler::AbstractStore::MAX_TOKEN_AGE\n+\n+        # TODO  this could be moved to lua to correct a concurrency flaw\n+        # it is not critical cause worse case some requests will miss profiling info\n+\n+        # no key so go ahead and set it\n+        key1 = SecureRandom.hex\n+\n+        if key1_old && (key1_old.length == 32)\n+          key2 = key1_old\n+          redis.setex \"#{@prefix}-key2\", timeout, key2\n+        else\n+          key2 = nil\n+        end\n+\n+        redis.setex \"#{@prefix}-key1\", timeout, key1\n+        redis.setex \"#{@prefix}-key1_old\", timeout*2, key1\n+\n+        [key1, key2].compact\n+      end\n+\n       private\n \n       def redis"
        },
        {
          "filename": "lib/rack-mini-profiler.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -1,6 +1,7 @@\n require 'json'\n require 'timeout'\n require 'thread'\n+require 'securerandom'\n \n require 'mini_profiler/version'\n require 'mini_profiler/asset_version'"
        },
        {
          "filename": "rack-mini-profiler.gemspec",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -26,12 +26,12 @@ Gem::Specification.new do |s|\n   s.add_development_dependency 'activerecord', '~> 3.0'\n   s.add_development_dependency 'dalli'\n   s.add_development_dependency 'rspec', '~> 2.14.1'\n-  s.add_development_dependency 'ZenTest'\n-  s.add_development_dependency 'autotest'\n   s.add_development_dependency 'redis'\n   s.add_development_dependency 'therubyracer'\n   s.add_development_dependency 'less'\n   s.add_development_dependency 'flamegraph'\n+  s.add_development_dependency 'guard'\n+  s.add_development_dependency 'guard-rspec'\n \n   s.require_paths = [\"lib\"]\n end"
        },
        {
          "filename": "spec/components/client_settings_spec.rb",
          "status": "removed",
          "additions": 0,
          "deletions": 42,
          "patch": "@@ -1,42 +0,0 @@\n-require 'spec_helper'\n-\n-describe Rack::MiniProfiler::ClientSettings do\n-\n-  describe \"with settings\" do\n-    before do\n-      settings = URI.encode_www_form_component(\"dp=t,bt=1\")\n-      @settings = Rack::MiniProfiler::ClientSettings.new({\"HTTP_COOKIE\" => \"__profilin=#{settings};\" })\n-    end\n-\n-    it 'has the cookies' do\n-      @settings.has_cookie?.should be_true\n-    end\n-\n-    it 'has profiling disabled' do\n-      @settings.disable_profiling?.should be_true\n-    end\n-\n-    it 'has backtrace set to full' do\n-      @settings.backtrace_full?.should be_true\n-    end\n-\n-    it 'should not write cookie changes if no change' do\n-      hash = {}\n-      @settings.write!(hash)\n-      hash.should == {}\n-    end\n-\n-    it 'should correctly write cookie changes if changed' do\n-      @settings.disable_profiling = false\n-      hash = {}\n-      @settings.write!(hash)\n-      hash.should_not == {}\n-    end\n-  end\n-\n-  it \"should not have settings by default\" do\n-    Rack::MiniProfiler::ClientSettings.new({}).has_cookie?.should == false\n-  end\n-\n-\n-end"
        },
        {
          "filename": "spec/integration/mini_profiler_spec.rb",
          "status": "modified",
          "additions": 13,
          "deletions": 4,
          "patch": "@@ -30,6 +30,12 @@ def app\n       map '/html' do\n         run lambda { |env| [200, {'Content-Type' => 'text/html'}, \"<html><BODY><h1>Hi</h1></BODY>\\n \\t</html>\"] }\n       end\n+      map '/whitelisted-html' do\n+        run lambda { |env|\n+          Rack::MiniProfiler.authorize_request\n+          [200, {'Content-Type' => 'text/html'}, \"<html><BODY><h1>Hi</h1></BODY>\\n \\t</html>\"]\n+        }\n+      end\n       map '/implicitbody' do\n         run lambda { |env| [200, {'Content-Type' => 'text/html'}, \"<html><h1>Hi</h1></html>\"] }\n       end\n@@ -107,7 +113,7 @@ def app\n \n     it 'avoids xss attacks' do\n       h = last_response.headers['X-MiniProfiler-Ids']\n-      id = ::JSON.parse(h)[0]\n+      _id = ::JSON.parse(h)[0]\n       get \"/mini-profiler-resources/results?id=%22%3E%3Cqss%3E\"\n       last_response.should_not be_ok\n       last_response.body.should_not =~ /<qss>/\n@@ -280,13 +286,14 @@ def load_prof(response)\n       it \"does not re-enable functionality if not whitelisted\" do\n         Rack::MiniProfiler.config.authorization_mode = :whitelist\n         get '/html?pp=enable'\n+        get '/html?pp=enable'\n         last_response.body.should_not include('/mini-profiler-resources/includes.js')\n       end\n \n       it \"re-enabled functionality if whitelisted\" do\n         Rack::MiniProfiler.config.authorization_mode = :whitelist\n-        expect(Rack::MiniProfiler).to receive(:request_authorized?) { true }.twice\n-        get '/html?pp=enable'\n+        get '/whitelisted-html?pp=enable'\n+        get '/whitelisted-html?pp=enable'\n         last_response.body.should include('/mini-profiler-resources/includes.js')\n       end\n     end\n@@ -334,7 +341,9 @@ def load_prof(response)\n     end\n \n     it \"should allow requests that are whitelisted\" do\n-      set_cookie(\"__profilin=stylin\")\n+      get '/whitelisted'\n+      # second time will ensure cookie is set\n+      # first time around there is no cookie, so no profiling\n       get '/whitelisted'\n       last_response.headers['X-MiniProfiler-Ids'].should_not be_nil\n     end"
        },
        {
          "filename": "spec/lib/client_settings_spec.rb",
          "status": "added",
          "additions": 77,
          "deletions": 0,
          "patch": "@@ -0,0 +1,77 @@\n+require 'spec_helper'\n+require 'rack'\n+\n+describe Rack::MiniProfiler::ClientSettings do\n+\n+  describe \"with settings\" do\n+    before do\n+      @store = Rack::MiniProfiler::MemoryStore.new\n+      settings = URI.encode_www_form_component(\"dp=t,bt=1\")\n+      @settings = Rack::MiniProfiler::ClientSettings.new(\n+        {\"HTTP_COOKIE\" => \"__profilin=#{settings};\" },\n+        @store,\n+        Time.now\n+      )\n+    end\n+\n+    it 'has the cookies' do\n+      @settings.has_valid_cookie?.should be_true\n+    end\n+\n+    it 'has profiling disabled' do\n+      @settings.disable_profiling?.should be_true\n+    end\n+\n+    it 'has backtrace set to full' do\n+      @settings.backtrace_full?.should be_true\n+    end\n+\n+    it 'should not write cookie changes if no change' do\n+      hash = {}\n+      @settings.write!(hash)\n+      hash.should == {}\n+    end\n+\n+    it 'should correctly write cookie changes if changed' do\n+      @settings.disable_profiling = false\n+      hash = {}\n+      @settings.write!(hash)\n+      hash.should_not == {}\n+    end\n+\n+    it 'writes auth token for authorized reqs' do\n+      Rack::MiniProfiler.config.authorization_mode = :whitelist\n+      Rack::MiniProfiler.authorize_request\n+      hash = {}\n+      @settings.write!(hash)\n+      hash[\"Set-Cookie\"].should include(@store.allowed_tokens.join(\"|\"))\n+    end\n+\n+    it 'does nothing on short unauthed requests' do\n+      Rack::MiniProfiler.config.authorization_mode = :whitelist\n+      Rack::MiniProfiler.deauthorize_request\n+      hash = {}\n+      @settings.handle_cookie([200, hash, []])\n+\n+      hash.should == {}\n+    end\n+\n+    it 'discards on long unauthed requests' do\n+      Rack::MiniProfiler.config.authorization_mode = :whitelist\n+      Rack::MiniProfiler.deauthorize_request\n+      hash = {}\n+      Time.travel(Time.now + 1) do\n+        @settings.handle_cookie([200, hash, []])\n+      end\n+\n+      hash[\"Set-Cookie\"].should include(\"max-age=0\")\n+    end\n+  end\n+\n+  it \"should not have settings by default\" do\n+    Rack::MiniProfiler::ClientSettings.new({}, Rack::MiniProfiler::MemoryStore.new, Time.now)\n+      .has_valid_cookie?.should == false\n+  end\n+\n+\n+end"
        },
        {
          "filename": "spec/lib/config_spec.rb",
          "status": "renamed",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "spec/lib/gc_profiler_spec.rb",
          "status": "renamed",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "spec/lib/profiler_spec.rb",
          "status": "renamed",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "spec/lib/sql_patches_spec.rb",
          "status": "renamed",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "spec/lib/storage/file_store_spec.rb",
          "status": "renamed",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -9,6 +9,31 @@\n       @store = Rack::MiniProfiler::FileStore.new(:path => tmp)\n     end\n \n+\n+    describe 'allowed_tokens' do\n+\n+      it 'should return tokens' do\n+        @store.flush_tokens\n+\n+        tokens = @store.allowed_tokens\n+        tokens.length.should == 1\n+        tokens.should == @store.allowed_tokens\n+\n+        Time.travel(Time.now + 1) do\n+          new_tokens = @store.allowed_tokens\n+          new_tokens.length.should == 1\n+          new_tokens.should == tokens\n+        end\n+\n+        Time.travel(Time.now + Rack::MiniProfiler::AbstractStore::MAX_TOKEN_AGE + 1) do\n+          new_tokens = @store.allowed_tokens\n+          new_tokens.length.should == 2\n+          (new_tokens - tokens).length.should == 1\n+        end\n+\n+      end\n+    end\n+\n     describe 'storage' do\n \n       it 'can store a PageStruct and retrieve it' do"
        },
        {
          "filename": "spec/lib/storage/memcache_store_spec.rb",
          "status": "renamed",
          "additions": 28,
          "deletions": 0,
          "patch": "@@ -46,6 +46,34 @@\n \n   end\n \n+\n+  describe 'allowed_tokens' do\n+    before do\n+      @store = Rack::MiniProfiler::MemcacheStore.new\n+    end\n+\n+    it 'should return tokens' do\n+\n+      @store.flush_tokens\n+\n+      tokens = @store.allowed_tokens\n+      tokens.length.should == 1\n+      tokens.should == @store.allowed_tokens\n+\n+      Time.travel(Time.now + 1) do\n+        new_tokens = @store.allowed_tokens\n+        new_tokens.length.should == 1\n+        new_tokens.should == tokens\n+      end\n+\n+      Time.travel(Time.now + Rack::MiniProfiler::AbstractStore::MAX_TOKEN_AGE + 1) do\n+        new_tokens = @store.allowed_tokens\n+        new_tokens.length.should == 2\n+        (new_tokens - tokens).length.should == 1\n+      end\n+    end\n+  end\n+\n   context 'passing in a Memcache client' do\n     describe 'client' do\n       it 'uses the passed in object rather than creating a new one' do"
        },
        {
          "filename": "spec/lib/storage/memory_store_spec.rb",
          "status": "renamed",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -60,6 +60,31 @@\n     end\n   end\n \n+  describe 'allowed_tokens' do\n+    before do\n+      @store = Rack::MiniProfiler::MemoryStore.new\n+    end\n+\n+    it 'should return tokens' do\n+\n+      tokens = @store.allowed_tokens\n+      tokens.length.should == 1\n+      tokens.should == @store.allowed_tokens\n+\n+      Time.travel(Time.now + 1) do\n+        new_tokens = @store.allowed_tokens\n+        new_tokens.length.should == 1\n+        new_tokens.should == tokens\n+      end\n+\n+      Time.travel(Time.now + Rack::MiniProfiler::AbstractStore::MAX_TOKEN_AGE + 1) do\n+        new_tokens = @store.allowed_tokens\n+        new_tokens.length.should == 2\n+        (new_tokens - tokens).length.should == 1\n+      end\n+\n+    end\n+  end\n \n   describe 'cache cleanup thread' do\n     let(:described){Rack::MiniProfiler::MemoryStore::CacheCleanupThread}"
        },
        {
          "filename": "spec/lib/storage/redis_store_spec.rb",
          "status": "renamed",
          "additions": 21,
          "deletions": 0,
          "patch": "@@ -80,6 +80,27 @@\n \n   end\n \n+  describe 'allowed_tokens' do\n+    before do\n+      @store = Rack::MiniProfiler::RedisStore.new(:db=>2)\n+    end\n+\n+    it 'should return tokens' do\n+\n+      @store.flush_tokens\n+\n+      tokens = @store.allowed_tokens\n+      tokens.length.should == 1\n+\n+      @store.simulate_expire\n+\n+      new_tokens = @store.allowed_tokens\n+\n+      new_tokens.length.should == 2\n+      (new_tokens - tokens).length.should == 1\n+    end\n+  end\n+\n \n   describe 'diagnostics' do\n     before do"
        },
        {
          "filename": "spec/lib/timer_struct/client_timer_struct_spec.rb",
          "status": "renamed",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "spec/lib/timer_struct/custom_spec.rb",
          "status": "renamed",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "spec/lib/timer_struct/page_timer_struct_spec.rb",
          "status": "renamed",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "spec/lib/timer_struct/request_timer_struct_spec.rb",
          "status": "renamed",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "spec/lib/timer_struct/sql_timer_struct_spec.rb",
          "status": "renamed",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "spec/lib/timer_struct/timer_struct_spec.rb",
          "status": "renamed",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "spec/spec_helper.rb",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -22,6 +22,13 @@ class << self\n       alias_method :old_new, :new\n       alias_method :old_now, :now\n \n+      def travel(to)\n+        @now = to\n+        yield\n+      ensure\n+        @now = nil\n+      end\n+\n       def new\n         @now || old_new\n       end"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 4,
        "dependency_files": 1,
        "test_files": 1,
        "unique_directories": 11,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d2228aeabbdfa3f5cb1178e86b208f88df86852c",
            "date": "2024-12-11T14:20:53Z",
            "author_login": "nateberkopec"
          },
          {
            "sha": "d5b895f3d72ca2e77d21bfc89db085ba4d013b78",
            "date": "2024-12-11T14:17:13Z",
            "author_login": "tomchipchase"
          },
          {
            "sha": "5e42a57acab20125f910c0f29d82f19e7220ff31",
            "date": "2024-02-14T22:41:48Z",
            "author_login": "SamSaffron"
          },
          {
            "sha": "263f0d81d18c0ae6ea94b47c4b9aed1f133fa5ee",
            "date": "2024-02-14T22:32:01Z",
            "author_login": "soberstadt"
          },
          {
            "sha": "9081657369f271615dfc2266cf188d231c1e6dae",
            "date": "2024-02-14T22:26:24Z",
            "author_login": "davidtaylorhq"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-200",
    "description": "The rack-mini-profiler gem before 0.10.1 for Ruby allows remote attackers to obtain sensitive information about allocated strings and objects by leveraging incorrect ordering of security checks.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-05-02T14:59:00.330",
    "last_modified": "2024-11-21T02:52:12.570",
    "fix_date": "2016-05-18T07:07:17Z"
  },
  "references": [
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/06/10/2",
      "source": "secalert@redhat.com",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/MiniProfiler/rack-mini-profiler/blob/v0.10.1/CHANGELOG.md",
      "source": "secalert@redhat.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/MiniProfiler/rack-mini-profiler/commit/4273771d65f1a7411e3ef5843329308d0e2d257c",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/06/10/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/MiniProfiler/rack-mini-profiler/blob/v0.10.1/CHANGELOG.md",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/MiniProfiler/rack-mini-profiler/commit/4273771d65f1a7411e3ef5843329308d0e2d257c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:56.542312",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "rack-mini-profiler",
    "owner": "MiniProfiler",
    "created_at": "2013-09-06T23:32:44Z",
    "updated_at": "2025-01-25T23:36:45Z",
    "pushed_at": "2024-12-11T14:21:27Z",
    "size": 2033,
    "stars": 3755,
    "forks": 406,
    "open_issues": 52,
    "watchers": 3755,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Ruby": 285084,
      "JavaScript": 119371,
      "CSS": 17575,
      "SCSS": 11753,
      "HTML": 864
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T08:08:31.753242"
  }
}