{
  "cve_id": "CVE-2016-4992",
  "github_data": {
    "repository": "389ds/389-ds-base",
    "fix_commit": "0b932d4b926d46ac5060f02617330dc444e06da1",
    "related_commits": [
      "0b932d4b926d46ac5060f02617330dc444e06da1",
      "0b932d4b926d46ac5060f02617330dc444e06da1"
    ],
    "patch_url": "https://github.com/389ds/389-ds-base/commit/0b932d4b926d46ac5060f02617330dc444e06da1.patch",
    "fix_commit_details": {
      "sha": "0b932d4b926d46ac5060f02617330dc444e06da1",
      "commit_date": "2016-07-13T21:49:18Z",
      "author": {
        "login": "nhosoi",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Bug 1347760 - CVE-2016-4992 389-ds-base: Information disclosure via repeated use of LDAP ADD operation, etc.",
        "length": 1524,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 425,
        "additions": 311,
        "deletions": 114
      },
      "files": [
        {
          "filename": "ldap/servers/slapd/back-ldbm/dn2entry.c",
          "status": "modified",
          "additions": 12,
          "deletions": 5,
          "patch": "@@ -151,14 +151,15 @@ struct backentry *\n dn2ancestor(\n     Slapi_Backend *be,\n     const Slapi_DN\t*sdn,\n-\tSlapi_DN *ancestordn,\n+    Slapi_DN *ancestordn,\n     back_txn\t\t*txn,\n-    int\t\t\t*err\n+    int\t\t\t*err,\n+    int allow_suffix\n )\n {\n-\tstruct backentry *e = NULL;\n+    struct backentry *e = NULL;\n \n-\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> dn2ancestor \\\"%s\\\"\\n\", slapi_sdn_get_dn(sdn), 0, 0 );\n+    LDAPDebug( LDAP_DEBUG_TRACE, \"=> dn2ancestor \\\"%s\\\"\\n\", slapi_sdn_get_dn(sdn), 0, 0 );\n \n     /* first, check to see if the given sdn is empty or a root suffix of the\n        given backend - if so, it has no parent */\n@@ -190,7 +191,13 @@ dn2ancestor(\n         */\n \n         /* stop when we get to \"\", or a backend suffix point */\n-        while (!e && !slapi_sdn_isempty(&ancestorndn) && !slapi_be_issuffix( be, &ancestorndn )) {\n+        while (!e && !slapi_sdn_isempty(&ancestorndn)) {\n+            if (!allow_suffix) {\n+                /* Original behavior. */\n+                if (slapi_be_issuffix(be, &ancestorndn)) {\n+                    break;\n+                }\n+            }\n             /* find the entry - it uses the ndn, so no further conversion is necessary */\n             e= dn2entry(be,&ancestorndn,txn,err);\n             if (!e) {"
        },
        {
          "filename": "ldap/servers/slapd/back-ldbm/findentry.c",
          "status": "modified",
          "additions": 106,
          "deletions": 33,
          "patch": "@@ -16,8 +16,8 @@\n #include \"back-ldbm.h\"\n \n \n-static struct backentry *find_entry_internal_dn(Slapi_PBlock *pb, backend *be, const Slapi_DN *sdn, int lock, back_txn *txn, int flags);\n-static struct backentry * find_entry_internal(Slapi_PBlock *pb, Slapi_Backend *be, const entry_address *addr, int lock, back_txn *txn, int flags);\n+static struct backentry *find_entry_internal_dn(Slapi_PBlock *pb, backend *be, const Slapi_DN *sdn, int lock, back_txn *txn, int flags, int *rc);\n+static struct backentry * find_entry_internal(Slapi_PBlock *pb, Slapi_Backend *be, const entry_address *addr, int lock, back_txn *txn, int flags, int *rc);\n /* The flags take these values */\n #define FE_TOMBSTONE_INCLUDED TOMBSTONE_INCLUDED /* :1 defined in back-ldbm.h */\n #define FE_REALLY_INTERNAL 0x2\n@@ -27,7 +27,7 @@ check_entry_for_referral(Slapi_PBlock *pb, Slapi_Entry *entry, char *matched, co\n {\n \tint rc=0, i=0, numValues=0;\n \tSlapi_Attr *attr;\n-\tSlapi_Value *val=NULL;\t\n+\tSlapi_Value *val=NULL;\n \tstruct berval **refscopy=NULL;\n \tstruct berval **url=NULL;\n \n@@ -80,22 +80,28 @@ check_entry_for_referral(Slapi_PBlock *pb, Slapi_Entry *entry, char *matched, co\n \n static struct backentry *\n find_entry_internal_dn(\n-\tSlapi_PBlock\t*pb,\n+    Slapi_PBlock\t*pb,\n     backend\t\t\t*be,\n     const Slapi_DN *sdn,\n     int\t\t\t\tlock,\n-\tback_txn\t\t*txn,\n-\tint\t\t\t\tflags\n+    back_txn\t\t*txn,\n+    int\t\t\t\tflags,\n+    int\t\t\t\t*rc /* return code */\n )\n { \n \tstruct backentry *e;\n \tint\tmanagedsait = 0;\n \tint\terr;\n \tldbm_instance *inst = (ldbm_instance *) be->be_instance_info;\n \tsize_t tries = 0;\n+\tint isroot = 0;\n+\tint op_type;\n+\tchar *errbuf = NULL;\n \n \t/* get the managedsait ldap message control */\n-\tslapi_pblock_get( pb, SLAPI_MANAGEDSAIT, &managedsait );\n+\tslapi_pblock_get(pb, SLAPI_MANAGEDSAIT, &managedsait);\n+\tslapi_pblock_get(pb, SLAPI_REQUESTOR_ISROOT, &isroot);\n+\tslapi_pblock_get(pb, SLAPI_OPERATION_TYPE, &op_type);\n \n \twhile ( (tries < LDBM_CACHE_RETRY_COUNT) && \n \t        (e = dn2entry_ext( be, sdn, txn, flags & TOMBSTONE_INCLUDED, &err ))\n@@ -113,6 +119,9 @@ find_entry_internal_dn(\n \t\t\tif(check_entry_for_referral(pb, e->ep_entry, NULL, \"find_entry_internal_dn\"))\n \t\t\t{\n \t\t\t\tCACHE_RETURN( &inst->inst_cache, &e );\n+\t\t\t\tif (rc) { /* if check_entry_for_referral returns non-zero, result is sent. */\n+\t\t\t\t\t*rc = FE_RC_SENT_RESULT;\n+\t\t\t\t}\n \t\t\t\treturn( NULL );\n \t\t\t}\n \t\t}\n@@ -151,27 +160,89 @@ find_entry_internal_dn(\n \t\tstruct backentry *me;\n \t\tSlapi_DN ancestorsdn;\n \t\tslapi_sdn_init(&ancestorsdn);\n-\t\tme= dn2ancestor(pb->pb_backend,sdn,&ancestorsdn,txn,&err);\n+\t\tme = dn2ancestor(pb->pb_backend, sdn, &ancestorsdn, txn, &err, 1 /* allow_suffix */);\n \t\tif ( !managedsait && me != NULL ) {\n \t\t\t/* if the entry is a referral send the referral */\n \t\t\tif(check_entry_for_referral(pb, me->ep_entry, (char*)slapi_sdn_get_dn(&ancestorsdn), \"find_entry_internal_dn\"))\n \t\t\t{\n \t\t\t\tCACHE_RETURN( &inst->inst_cache, &me );\n \t\t\t\tslapi_sdn_done(&ancestorsdn);\n+\t\t\t\tif (rc) { /* if check_entry_for_referral returns non-zero, result is sent. */\n+\t\t\t\t\t*rc = FE_RC_SENT_RESULT;\n+\t\t\t\t}\n \t\t\t\treturn( NULL );\n \t\t\t}\n \t\t\t/* else fall through to no such object */\n \t\t}\n \n \t\t/* entry not found */\n-\t\tslapi_send_ldap_result( pb, ( 0 == err || DB_NOTFOUND == err ) ?\n-\t\t\tLDAP_NO_SUCH_OBJECT : ( LDAP_INVALID_DN_SYNTAX == err ) ?\n-\t\t\tLDAP_INVALID_DN_SYNTAX : LDAP_OPERATIONS_ERROR,\n-\t\t\t(char*)slapi_sdn_get_dn(&ancestorsdn), NULL, 0, NULL );\n+\t\tif ((0 == err) || (DB_NOTFOUND == err)) {\n+\t\t\tif (me && !isroot) {\n+\t\t\t\t/* If not root, you may not want to reveal it. */\n+\t\t\t\tint acl_type = -1;\n+\t\t\t\tint return_err = LDAP_NO_SUCH_OBJECT;\n+\t\t\t\terr = LDAP_SUCCESS;\n+\t\t\t\tswitch (op_type) {\n+\t\t\t\tcase SLAPI_OPERATION_ADD:\n+\t\t\t\t\tacl_type = SLAPI_ACL_ADD;\n+\t\t\t\t\treturn_err = LDAP_INSUFFICIENT_ACCESS;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase SLAPI_OPERATION_DELETE:\n+\t\t\t\t\tacl_type = SLAPI_ACL_DELETE;\n+\t\t\t\t\treturn_err = LDAP_INSUFFICIENT_ACCESS;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase SLAPI_OPERATION_MODDN:\n+\t\t\t\t\tacl_type = SLAPI_ACL_MODDN;\n+\t\t\t\t\treturn_err = LDAP_INSUFFICIENT_ACCESS;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase SLAPI_OPERATION_MODIFY:\n+\t\t\t\t\tacl_type = SLAPI_ACL_WRITE;\n+\t\t\t\t\treturn_err = LDAP_INSUFFICIENT_ACCESS;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase SLAPI_OPERATION_SEARCH:\n+\t\t\t\tcase SLAPI_OPERATION_COMPARE:\n+\t\t\t\t\treturn_err = LDAP_SUCCESS;\n+\t\t\t\t\tacl_type = SLAPI_ACL_READ;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase SLAPI_OPERATION_BIND:\n+\t\t\t\t\tacl_type = -1; /* skip acl check. acl is not set up for bind. */\n+\t\t\t\t\treturn_err = LDAP_INVALID_CREDENTIALS;\n+\t\t\t\t\tslapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"No such entry\");\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tif (acl_type > 0) {\n+\t\t\t\t\terr = plugin_call_acl_plugin(pb, me->ep_entry, NULL, NULL, acl_type,\n+\t\t\t\t\t                             ACLPLUGIN_ACCESS_DEFAULT, &errbuf);\n+\t\t\t\t}\n+\t\t\t\tif (((acl_type > 0) && err) || (op_type == SLAPI_OPERATION_BIND)) {\n+\t\t\t\t\t/*\n+\t\t\t\t\t * Operations to be checked && ACL returns disallow.\n+\t\t\t\t\t * Not to disclose the info about the entry's existence,\n+\t\t\t\t\t * do not return the \"matched\" DN.\n+\t\t\t\t\t * Plus, the bind case returns LDAP_INAPPROPRIATE_AUTH.\n+\t\t\t\t\t */\n+\t\t\t\t\tslapi_send_ldap_result(pb, return_err, NULL, NULL, 0, NULL);\n+\t\t\t\t} else {\n+\t\t\t\t\tslapi_send_ldap_result(pb, LDAP_NO_SUCH_OBJECT,\n+\t\t\t\t\t\t(char*)slapi_sdn_get_dn(&ancestorsdn), NULL, 0, NULL);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tslapi_send_ldap_result( pb, LDAP_NO_SUCH_OBJECT,\n+\t\t\t\t\t(char*)slapi_sdn_get_dn(&ancestorsdn), NULL, 0, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tslapi_send_ldap_result( pb, ( LDAP_INVALID_DN_SYNTAX == err ) ?\n+\t\t\t\tLDAP_INVALID_DN_SYNTAX : LDAP_OPERATIONS_ERROR,\n+\t\t\t\t(char*)slapi_sdn_get_dn(&ancestorsdn), NULL, 0, NULL );\n+\t\t}\n+\t\tif (rc) {\n+\t\t\t*rc = FE_RC_SENT_RESULT;\n+\t\t}\n \t\tslapi_sdn_done(&ancestorsdn);\n \t\tCACHE_RETURN( &inst->inst_cache, &me );\n \t}\n \n+\tslapi_ch_free_string(&errbuf);\n \tLDAPDebug( LDAP_DEBUG_TRACE, \"<= find_entry_internal_dn not found (%s)\\n\",\n \t    slapi_sdn_get_dn(sdn), 0, 0 );\n \treturn( NULL );\n@@ -183,11 +254,11 @@ find_entry_internal_dn(\n  */\n static struct backentry *\n find_entry_internal_uniqueid(\n-\tSlapi_PBlock\t*pb,\n+    Slapi_PBlock\t*pb,\n     backend *be,\n-\tconst char \t\t\t*uniqueid,\n+    const char \t\t\t*uniqueid,\n     int\t\t\t\tlock,\n-\tback_txn\t\t*txn\n+    back_txn\t\t*txn\n )\n {\n \tldbm_instance *inst = (ldbm_instance *) be->be_instance_info;\n@@ -243,8 +314,9 @@ find_entry_internal(\n     Slapi_Backend *be,\n     const entry_address *addr,\n     int\t\t\tlock,\n-\tback_txn *txn,\n-\tint flags\n+    back_txn *txn,\n+    int flags,\n+    int *rc\n )\n {\n \t/* check if we should search based on uniqueid or dn */\n@@ -261,11 +333,9 @@ find_entry_internal(\n \t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (dn=%s) lock %d\\n\",\n \t\t           slapi_sdn_get_dn(addr->sdn), lock, 0 );\n \t\tif (addr->sdn) {\n-\t\t\tentry = find_entry_internal_dn (pb, be, addr->sdn, \n-\t\t\t                                lock, txn, flags);\n+\t\t\tentry = find_entry_internal_dn (pb, be, addr->sdn, lock, txn, flags, rc);\n \t\t} else {\n-\t\t\tLDAPDebug0Args( LDAP_DEBUG_ANY,\n-\t\t\t                \"find_entry_internal: Null target dn\\n\" );\n+\t\t\tLDAPDebug0Args( LDAP_DEBUG_ANY, \"find_entry_internal: Null target dn\\n\" );\n \t\t}\n \n \t\tLDAPDebug0Args( LDAP_DEBUG_TRACE, \"<= find_entry_internal\\n\" );\n@@ -278,21 +348,23 @@ find_entry(\n     Slapi_PBlock\t\t*pb,\n     Slapi_Backend *be,\n     const entry_address *addr,\n-\tback_txn *txn\n+    back_txn *txn,\n+    int *rc\n )\n {\n-\treturn( find_entry_internal( pb, be, addr, 0/*!lock*/, txn, 0/*flags*/ ) );\n+\treturn(find_entry_internal(pb, be, addr, 0/*!lock*/, txn, 0/*flags*/, rc));\n }\n \n struct backentry *\n find_entry2modify(\n     Slapi_PBlock\t\t*pb,\n     Slapi_Backend *be,\n     const entry_address *addr,\n-\tback_txn *txn\n+    back_txn *txn,\n+    int *rc\n )\n {\n-\treturn( find_entry_internal( pb, be, addr, 1/*lock*/, txn, 0/*flags*/ ) );\n+\treturn(find_entry_internal(pb, be, addr, 1/*lock*/, txn, 0/*flags*/, rc));\n }\n \n /* New routines which do not do any referral stuff.\n@@ -304,21 +376,23 @@ find_entry_only(\n     Slapi_PBlock\t\t*pb,\n     Slapi_Backend *be,\n     const entry_address *addr,\n-\tback_txn *txn\n+    back_txn *txn,\n+    int *rc\n )\n {\n-\treturn( find_entry_internal( pb, be, addr, 0/*!lock*/, txn, FE_REALLY_INTERNAL ) );\n+\treturn(find_entry_internal(pb, be, addr, 0/*!lock*/, txn, FE_REALLY_INTERNAL, rc));\n }\n \n struct backentry *\n find_entry2modify_only(\n     Slapi_PBlock\t\t*pb,\n     Slapi_Backend *be,\n     const entry_address *addr,\n-    back_txn *txn\n+    back_txn *txn,\n+    int *rc\n )\n {\n-\treturn( find_entry_internal( pb, be, addr, 1/*lock*/, txn, FE_REALLY_INTERNAL ) );\n+\treturn(find_entry_internal(pb, be, addr, 1/*lock*/, txn, 0 /* to check aci, disable INTERNAL */, rc));\n }\n \n struct backentry *\n@@ -327,10 +401,9 @@ find_entry2modify_only_ext(\n     Slapi_Backend *be,\n     const entry_address *addr,\n     int flags,\n-    back_txn *txn\n-\n+    back_txn *txn,\n+    int *rc\n )\n {\n-\treturn( find_entry_internal( pb, be, addr, 1/*lock*/, txn, \n-\t\t                         FE_REALLY_INTERNAL | flags ));\n+\treturn(find_entry_internal(pb, be, addr, 1/*lock*/, txn, FE_REALLY_INTERNAL | flags, rc));\n }"
        },
        {
          "filename": "ldap/servers/slapd/back-ldbm/ldbm_add.c",
          "status": "modified",
          "additions": 16,
          "deletions": 5,
          "patch": "@@ -93,6 +93,7 @@ ldbm_back_add( Slapi_PBlock *pb )\n \tint myrc = 0;\n \tPRUint64 conn_id;\n \tint op_id;\n+\tint result_sent = 0;\n \tif (slapi_pblock_get(pb, SLAPI_CONN_ID, &conn_id) < 0) {\n \t\tconn_id = 0; /* connection is NULL */\n \t}\n@@ -379,7 +380,7 @@ ldbm_back_add( Slapi_PBlock *pb )\n \t\t\t\taddr.sdn = &parentsdn;\n \t\t\t\taddr.udn = NULL;\n \t\t\t\taddr.uniqueid = operation->o_params.p.p_add.parentuniqueid;\n-\t\t\t\tparententry = find_entry2modify_only(pb,be,&addr,&txn);\n+\t\t\t\tparententry = find_entry2modify_only(pb, be, &addr, &txn, &result_sent);\n \t\t\t\tif (parententry && parententry->ep_entry) {\n \t\t\t\t\tif (!operation->o_params.p.p_add.parentuniqueid){\n \t\t\t\t\t\t/* Set the parentuniqueid now */\n@@ -431,6 +432,14 @@ ldbm_back_add( Slapi_PBlock *pb )\n \t\t\t\t\t\t/* The entry already exists */ \n \t\t\t\t\t\tldap_result_code = LDAP_ALREADY_EXISTS;\n \t\t\t\t\t}\n+\t\t\t\t\tif ((LDAP_ALREADY_EXISTS == ldap_result_code) && !isroot && !is_replicated_operation) {\n+\t\t\t\t\t\tmyrc = plugin_call_acl_plugin(pb, e, NULL, NULL, SLAPI_ACL_ADD,\n+\t\t\t\t\t\t                              ACLPLUGIN_ACCESS_DEFAULT, &errbuf);\n+\t\t\t\t\t\tif (myrc) {\n+\t\t\t\t\t\t\tldap_result_code = myrc;\n+\t\t\t\t\t\t\tldap_result_message = errbuf;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t\tgoto error_return;\n \t\t\t\t} \n \t\t\t\telse \n@@ -447,7 +456,7 @@ ldbm_back_add( Slapi_PBlock *pb )\n \t\t\t\t\t\tSlapi_DN ancestorsdn;\n \t\t\t\t\t\tstruct backentry *ancestorentry;\n \t\t\t\t\t\tslapi_sdn_init(&ancestorsdn);\n-\t\t\t\t\t\tancestorentry= dn2ancestor(pb->pb_backend,sdn,&ancestorsdn,&txn,&err);\n+\t\t\t\t\t\tancestorentry = dn2ancestor(pb->pb_backend, sdn, &ancestorsdn, &txn, &err, 0);\n \t\t\t\t\t\tslapi_sdn_done(&ancestorsdn);\n \t\t\t\t\t\tif ( ancestorentry != NULL )\n \t\t\t\t\t\t{\n@@ -495,7 +504,7 @@ ldbm_back_add( Slapi_PBlock *pb )\n \t\t\t\taddr.udn = NULL;\n \t\t\t\taddr.sdn = NULL;\n \t\t\t\taddr.uniqueid = (char *)slapi_entry_get_uniqueid(e); /* jcm - cast away const */\n-\t\t\t\ttombstoneentry = find_entry2modify( pb, be, &addr, &txn );\n+\t\t\t\ttombstoneentry = find_entry2modify(pb, be, &addr, &txn, &result_sent);\n \t\t\t\tif ( tombstoneentry==NULL )\n \t\t\t\t{\n \t\t\t\t\tldap_result_code= -1;\n@@ -712,7 +721,7 @@ ldbm_back_add( Slapi_PBlock *pb )\n \t\t\t\t\tLDAPDebug1Arg(LDAP_DEBUG_BACKLDBM, \"ldbm_add: Parent \\\"%s\\\" does not exist. \"\n \t\t\t\t\t              \"It might be a conflict entry.\\n\", slapi_sdn_get_dn(&parentsdn));\n \t\t\t\t\tslapi_sdn_init(&ancestorsdn);\n-\t\t\t\t\tancestorentry = dn2ancestor(be, &parentsdn, &ancestorsdn, &txn, &err );\n+\t\t\t\t\tancestorentry = dn2ancestor(be, &parentsdn, &ancestorsdn, &txn, &err, 1);\n \t\t\t\t\tCACHE_RETURN( &inst->inst_cache, &ancestorentry );\n \n \t\t\t\t\tldap_result_code= LDAP_NO_SUCH_OBJECT;\n@@ -1349,7 +1358,9 @@ ldbm_back_add( Slapi_PBlock *pb )\n \t\t\t * And we don't want the supplier to halt sending the updates. */\n \t\t\tldap_result_code = LDAP_SUCCESS;\n \t\t}\n-\t\tslapi_send_ldap_result( pb, ldap_result_code, ldap_result_matcheddn, ldap_result_message, 0, NULL );\n+\t\tif (!result_sent) {\n+\t\t\tslapi_send_ldap_result(pb, ldap_result_code, ldap_result_matcheddn, ldap_result_message, 0, NULL);\n+\t\t}\n \t}\n \tbackentry_free(&originalentry);\n \tbackentry_free(&tmpentry);"
        },
        {
          "filename": "ldap/servers/slapd/back-ldbm/ldbm_bind.c",
          "status": "modified",
          "additions": 8,
          "deletions": 3,
          "patch": "@@ -29,6 +29,7 @@ ldbm_back_bind( Slapi_PBlock *pb )\n \tentry_address *addr;\n \tback_txn txn = {NULL};\n \tint rc = SLAPI_BIND_SUCCESS;\n+\tint result_sent = 0;\n \n \t/* get parameters */\n \tslapi_pblock_get( pb, SLAPI_BACKEND, &be );\n@@ -63,8 +64,12 @@ ldbm_back_bind( Slapi_PBlock *pb )\n \t * find the target entry.  find_entry() takes care of referrals\n \t *   and sending errors if the entry does not exist.\n \t */\n-\tif (( e = find_entry( pb, be, addr, &txn )) == NULL ) {\n+\tif ((e = find_entry( pb, be, addr, &txn, &result_sent)) == NULL) {\n \t\trc = SLAPI_BIND_FAIL;\n+\t\t/* In the failure case, the result is supposed to be sent in the backend. */\n+\t\tif (!result_sent) {\n+\t\t\tslapi_send_ldap_result(pb, LDAP_INAPPROPRIATE_AUTH, NULL, NULL, 0, NULL);\n+\t\t}\n \t\tgoto bail;\n \t}\n \n@@ -82,8 +87,8 @@ ldbm_back_bind( Slapi_PBlock *pb )\n \t\tbvals= attr_get_present_values(attr);\n \t\tslapi_value_init_berval(&cv,cred);\n \t\tif ( slapi_pw_find_sv( bvals, &cv ) != 0 ) {\n-\t\t\tslapi_send_ldap_result( pb, LDAP_INVALID_CREDENTIALS, NULL,\n-\t\t\t    NULL, 0, NULL );\n+\t\t\tslapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Invalid credentials\");\n+\t\t\tslapi_send_ldap_result( pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL );\n \t\t\tCACHE_RETURN( &inst->inst_cache, &e );\n \t\t\tvalue_done(&cv);\n \t\t\trc = SLAPI_BIND_FAIL;"
        },
        {
          "filename": "ldap/servers/slapd/back-ldbm/ldbm_compare.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -56,7 +56,7 @@ ldbm_back_compare( Slapi_PBlock *pb )\n \t/* get the namespace dn */\n \tnamespace_dn = (Slapi_DN*)slapi_be_getsuffix(be, 0);\n \n-\tif ( (e = find_entry( pb, be, addr, &txn )) == NULL ) {\n+\tif ((e = find_entry(pb, be, addr, &txn, NULL)) == NULL) {\n \t\tret = -1;\t/* error result sent by find_entry() */\n \t\tgoto bail;\n \t}"
        },
        {
          "filename": "ldap/servers/slapd/back-ldbm/ldbm_delete.c",
          "status": "modified",
          "additions": 6,
          "deletions": 3,
          "patch": "@@ -77,6 +77,7 @@ ldbm_back_delete( Slapi_PBlock *pb )\n \tint op_id;\n \tID ep_id = 0;\n \tID tomb_ep_id = 0;\n+\tint result_sent = 0;\n \n \tif (slapi_pblock_get(pb, SLAPI_CONN_ID, &conn_id) < 0) {\n \t\tconn_id = 0; /* connection is NULL */\n@@ -266,7 +267,7 @@ ldbm_back_delete( Slapi_PBlock *pb )\n \t\t\t * deleted.  That is, the entry 'e' found with \"addr\" is a tomb-\n \t\t\t * stone.  If it is the case, we need to back off.\n \t\t\t */\n-\t\t\tif ( (e = find_entry2modify( pb, be, addr, &txn )) == NULL )\n+\t\t\tif ((e = find_entry2modify(pb, be, addr, &txn, &result_sent)) == NULL)\n \t\t\t{\n \t\t\t\tldap_result_code= LDAP_NO_SUCH_OBJECT; \n \t\t\t\tretval = -1;\n@@ -507,7 +508,7 @@ ldbm_back_delete( Slapi_PBlock *pb )\n \t\t\t\t\t\tparent_addr.uniqueid = NULL;\n \t\t\t\t\t}\n \t\t\t\t\tparent_addr.sdn = &parentsdn;\n-\t\t\t\t\tparent = find_entry2modify_only_ext(pb, be, &parent_addr, TOMBSTONE_INCLUDED, &txn);\n+\t\t\t\t\tparent = find_entry2modify_only_ext(pb, be, &parent_addr, TOMBSTONE_INCLUDED, &txn, &result_sent);\n \t\t\t\t}\n \t\t\t\tif (parent) {\n \t\t\t\t\tint isglue;\n@@ -1466,7 +1467,9 @@ ldbm_back_delete( Slapi_PBlock *pb )\n \t\t\t * And we don't want the supplier to halt sending the updates. */\n \t\t\tldap_result_code = LDAP_SUCCESS;\n \t\t}\n-\t\tslapi_send_ldap_result( pb, ldap_result_code, NULL, ldap_result_message, 0, NULL );\n+\t\tif (!result_sent) {\n+\t\t\tslapi_send_ldap_result( pb, ldap_result_code, NULL, ldap_result_message, 0, NULL );\n+\t\t}\n \t}\n \tslapi_log_error(SLAPI_LOG_BACKLDBM, \"ldbm_back_delete\",\n \t                \"conn=%lu op=%d modify_term: old_entry=0x%p, new_entry=0x%p, in_cache=%d\\n\","
        },
        {
          "filename": "ldap/servers/slapd/back-ldbm/ldbm_modify.c",
          "status": "modified",
          "additions": 11,
          "deletions": 7,
          "patch": "@@ -392,6 +392,7 @@ ldbm_back_modify( Slapi_PBlock *pb )\n \tint not_an_error = 0;\n \tint fixup_tombstone = 0;\n \tint ec_locked = 0;\n+\tint result_sent = 0;\n \n \tslapi_pblock_get( pb, SLAPI_BACKEND, &be);\n \tslapi_pblock_get( pb, SLAPI_PLUGIN_PRIVATE, &li );\n@@ -466,12 +467,12 @@ ldbm_back_modify( Slapi_PBlock *pb )\n \tif ( MANAGE_ENTRY_BEFORE_DBLOCK(li)) {\n \t\t/* find and lock the entry we are about to modify */\n \t\tif (fixup_tombstone) {\n-\t\t\te = find_entry2modify_only_ext( pb, be, addr, TOMBSTONE_INCLUDED, &txn );\n+\t\t\te = find_entry2modify_only_ext( pb, be, addr, TOMBSTONE_INCLUDED, &txn, &result_sent );\n \t\t} else {\n-\t\t\te = find_entry2modify( pb, be, addr, &txn );\n+\t\t\te = find_entry2modify( pb, be, addr, &txn, &result_sent );\n \t\t}\n \t\tif (e == NULL) {\n-\t\t\tldap_result_code= -1;\n+\t\t\tldap_result_code = -1;\n \t\t\tgoto error_return; /* error result sent by find_entry2modify() */\n \t\t}\n \t}\n@@ -551,12 +552,12 @@ ldbm_back_modify( Slapi_PBlock *pb )\n \t\t\tif ( !MANAGE_ENTRY_BEFORE_DBLOCK(li)) {\n \t\t\t\t/* find and lock the entry we are about to modify */\n \t\t\t\tif (fixup_tombstone) {\n-\t\t\t\t\te = find_entry2modify_only_ext( pb, be, addr, TOMBSTONE_INCLUDED, &txn );\n+\t\t\t\t\te = find_entry2modify_only_ext( pb, be, addr, TOMBSTONE_INCLUDED, &txn, &result_sent );\n \t\t\t\t} else {\n-\t\t\t\t\te = find_entry2modify( pb, be, addr, &txn );\n+\t\t\t\t\te = find_entry2modify( pb, be, addr, &txn, &result_sent );\n \t\t\t\t}\n \t\t\t\tif (e == NULL) {\n-\t\t\t\t\tldap_result_code= -1;\n+\t\t\t\t\tldap_result_code = -1;\n \t\t\t\t\tgoto error_return; /* error result sent by find_entry2modify() */\n \t\t\t\t}\n \t\t\t}\n@@ -966,7 +967,10 @@ ldbm_back_modify( Slapi_PBlock *pb )\n \t\t\t * And we don't want the supplier to halt sending the updates. */\n \t\t\tldap_result_code = LDAP_SUCCESS;\n \t\t}\n-\t\tslapi_send_ldap_result( pb, ldap_result_code, NULL, ldap_result_message, 0, NULL );\n+\t\tif (!result_sent) {\n+\t\t\t/* result is already sent in find_entry. */\n+\t\t\tslapi_send_ldap_result( pb, ldap_result_code, NULL, ldap_result_message, 0, NULL );\n+\t\t}\n \t}\n \n \t/* free our backups */"
        },
        {
          "filename": "ldap/servers/slapd/back-ldbm/ldbm_modrdn.c",
          "status": "modified",
          "additions": 9,
          "deletions": 6,
          "patch": "@@ -95,6 +95,7 @@ ldbm_back_modrdn( Slapi_PBlock *pb )\n     int myrc = 0;\n     PRUint64 conn_id;\n     int op_id;\n+    int result_sent = 0;\n     if (slapi_pblock_get(pb, SLAPI_CONN_ID, &conn_id) < 0) {\n         conn_id = 0; /* connection is NULL */\n     }\n@@ -474,7 +475,7 @@ ldbm_back_modrdn( Slapi_PBlock *pb )\n             /* find and lock the entry we are about to modify */\n             /* JCMREPL - Argh, what happens about the stinking referrals? */\n             slapi_pblock_get (pb, SLAPI_TARGET_ADDRESS, &old_addr);\n-            e = find_entry2modify( pb, be, old_addr, &txn );\n+            e = find_entry2modify(pb, be, old_addr, &txn, &result_sent);\n             if ( e == NULL )\n             {\n                 ldap_result_code= -1;\n@@ -510,7 +511,7 @@ ldbm_back_modrdn( Slapi_PBlock *pb )\n             } else {\n                 oldparent_addr.uniqueid = NULL;            \n             }\n-            parententry = find_entry2modify_only( pb, be, &oldparent_addr, &txn );\n+            parententry = find_entry2modify_only(pb, be, &oldparent_addr, &txn, &result_sent);\n             modify_init(&parent_modify_context,parententry);\n         \n             /* Fetch and lock the new parent of the entry that is moving */            \n@@ -520,7 +521,7 @@ ldbm_back_modrdn( Slapi_PBlock *pb )\n                 if (is_resurect_operation) {\n                     newsuperior_addr->uniqueid = slapi_entry_attr_get_charptr(e->ep_entry, SLAPI_ATTR_VALUE_PARENT_UNIQUEID);\n                 }\n-                newparententry = find_entry2modify_only( pb, be, newsuperior_addr, &txn );\n+                newparententry = find_entry2modify_only(pb, be, newsuperior_addr, &txn, &result_sent);\n                 slapi_ch_free_string(&newsuperior_addr->uniqueid);\n                 modify_init(&newparent_modify_context,newparententry);\n             }\n@@ -581,7 +582,7 @@ ldbm_back_modrdn( Slapi_PBlock *pb )\n                         Slapi_DN ancestorsdn;\n                         struct backentry *ancestorentry;\n                         slapi_sdn_init(&ancestorsdn);\n-                        ancestorentry= dn2ancestor(be,&dn_newdn,&ancestorsdn,&txn,&err);\n+                        ancestorentry = dn2ancestor(be, &dn_newdn, &ancestorsdn, &txn, &err, 0);\n                         CACHE_RETURN( &inst->inst_cache, &ancestorentry );\n                         ldap_result_matcheddn= slapi_ch_strdup((char *) slapi_sdn_get_dn(&ancestorsdn));\n                         ldap_result_code= LDAP_NO_SUCH_OBJECT;\n@@ -1486,8 +1487,10 @@ ldbm_back_modrdn( Slapi_PBlock *pb )\n              * And we don't want the supplier to halt sending the updates. */\n             ldap_result_code = LDAP_SUCCESS;\n         }\n-        slapi_send_ldap_result( pb, ldap_result_code, ldap_result_matcheddn,\n-                    ldap_result_message, 0,NULL );\n+        if (!result_sent) {\n+            slapi_send_ldap_result(pb, ldap_result_code, ldap_result_matcheddn,\n+                                   ldap_result_message, 0, NULL);\n+        }\n     }\n     slapi_mods_done(&smods_operation_wsi);\n     slapi_mods_done(&smods_generated);"
        },
        {
          "filename": "ldap/servers/slapd/back-ldbm/ldbm_search.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -584,7 +584,7 @@ ldbm_back_search( Slapi_PBlock *pb )\n     }\n     else\n     {\n-        if ( ( e = find_entry( pb, be, addr, &txn )) == NULL )\n+        if ((e = find_entry(pb, be, addr, &txn, NULL)) == NULL)\n         {\n             /* error or referral sent by find_entry */\n             return ldbm_back_search_cleanup(pb, li, sort_control, "
        },
        {
          "filename": "ldap/servers/slapd/back-ldbm/misc.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -412,7 +412,7 @@ ldbm_txn_ruv_modify_context( Slapi_PBlock *pb, modify_context *mc )\n \n     /* Note: if we find the bentry, it will stay locked until someone calls\n      * modify_term on the mc we'll be associating the bentry with */\n-    bentry = find_entry2modify_only( pb, be, &bentry_addr, &txn );\n+    bentry = find_entry2modify_only(pb, be, &bentry_addr, &txn, NULL);\n \n     if (NULL == bentry) {\n         /* Uh oh, we couldn't find and lock the RUV entry! */"
        },
        {
          "filename": "ldap/servers/slapd/back-ldbm/proto-back-ldbm.h",
          "status": "modified",
          "additions": 8,
          "deletions": 6,
          "patch": "@@ -174,7 +174,7 @@ int ldbm_back_ctrl_info(Slapi_Backend *be, int cmd, void *info);\n struct backentry *dn2entry(Slapi_Backend *be, const Slapi_DN *sdn, back_txn *txn, int    *err);\n struct backentry *dn2entry_ext(Slapi_Backend *be, const Slapi_DN *sdn, back_txn *txn, int flags, int *err);\n struct backentry *dn2entry_or_ancestor(Slapi_Backend *be, const Slapi_DN *sdn, Slapi_DN *ancestor, back_txn *txn, int *err);\n-struct backentry *dn2ancestor(Slapi_Backend *be,const Slapi_DN *sdn,Slapi_DN *ancestordn,back_txn *txn,int *err);\n+struct backentry *dn2ancestor(Slapi_Backend *be,const Slapi_DN *sdn,Slapi_DN *ancestordn,back_txn *txn,int *err, int allow_suffix);\n int get_copy_of_entry(Slapi_PBlock *pb, const entry_address *addr, back_txn *txn, int plock_parameter, int must_exist);\n int get_copy_of_entry_ext(Slapi_PBlock *pb, ID id, const entry_address *addr, back_txn *txn, int plock_parameter, int must_exist);\n void done_with_pblock_entry(Slapi_PBlock *pb, int plock_parameter);\n@@ -194,11 +194,13 @@ IDList * filter_candidates_ext( Slapi_PBlock *pb, backend *be, const char *base,\n /*\n  * findentry.c\n  */\n-struct backentry * find_entry2modify( Slapi_PBlock *pb, Slapi_Backend *be, const entry_address *addr, back_txn *txn );\n-struct backentry * find_entry( Slapi_PBlock *pb, Slapi_Backend *be, const entry_address *addr, back_txn *txn );\n-struct backentry * find_entry2modify_only( Slapi_PBlock *pb, Slapi_Backend *be, const entry_address *addr, back_txn *txn);\n-struct backentry * find_entry2modify_only_ext( Slapi_PBlock *pb, Slapi_Backend *be, const entry_address *addr, int flags, back_txn *txn);\n-struct backentry * find_entry_only( Slapi_PBlock *pb, Slapi_Backend *be, const entry_address *addr, back_txn *txn);\n+/* Return code */\n+#define FE_RC_SENT_RESULT 1\n+struct backentry *find_entry2modify(Slapi_PBlock *pb, Slapi_Backend *be, const entry_address *addr, back_txn *txn, int *rc);\n+struct backentry *find_entry(Slapi_PBlock *pb, Slapi_Backend *be, const entry_address *addr, back_txn *txn, int *rc);\n+struct backentry *find_entry2modify_only(Slapi_PBlock *pb, Slapi_Backend *be, const entry_address *addr, back_txn *txn, int *rc);\n+struct backentry *find_entry2modify_only_ext(Slapi_PBlock *pb, Slapi_Backend *be, const entry_address *addr, int flags, back_txn *txn, int *rc);\n+struct backentry *find_entry_only(Slapi_PBlock *pb, Slapi_Backend *be, const entry_address *addr, back_txn *txn, int *rc);\n int check_entry_for_referral(Slapi_PBlock *pb, Slapi_Entry *entry, char *matched, const char *callingfn);\n \n /*"
        },
        {
          "filename": "ldap/servers/slapd/back-ldbm/vlv_srch.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -162,7 +162,7 @@ vlvSearch_init(struct vlvSearch* p, Slapi_PBlock *pb, const Slapi_Entry *e, ldbm\n \n             addr.sdn = p->vlv_base;\n             addr.uniqueid = NULL;\n-            e = find_entry( pb, inst->inst_be, &addr, &txn );\n+            e = find_entry(pb, inst->inst_be, &addr, &txn, NULL);\n             /* Check to see if the entry is absent. If it is, mark this search\n              * as not initialized */\n             if (NULL == e) {"
        },
        {
          "filename": "ldap/servers/slapd/bind.c",
          "status": "modified",
          "additions": 39,
          "deletions": 36,
          "patch": "@@ -438,8 +438,8 @@ do_bind( Slapi_PBlock *pb )\n              * to an LDAP DN, fail and return an invalidCredentials error.\n              */\n             if ( NULL == pb->pb_conn->c_external_dn ) {\n-                send_ldap_result( pb, LDAP_INVALID_CREDENTIALS, NULL,\n-                                  \"client certificate mapping failed\", 0, NULL );\n+                slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Client certificate mapping failed\");\n+                send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, \"\", 0, NULL);\n                 /* call postop plugins */\n                 plugin_call_plugins( pb, SLAPI_PLUGIN_POST_BIND_FN );\n                 goto free_and_return;\n@@ -556,33 +556,32 @@ do_bind( Slapi_PBlock *pb )\n         /* Check if simple binds are allowed over an insecure channel.  We only check\n          * this for authenticated binds. */\n         } else if (config_get_require_secure_binds() == 1) {\n-                Connection *conn = NULL;\n-                int sasl_ssf = 0;\n-                int local_ssf = 0;\n-\n-                /* Allow simple binds only for SSL/TLS established connections\n-                 * or connections using SASL privacy layers */\n-                conn = pb->pb_conn;\n-                if ( slapi_pblock_get(pb, SLAPI_CONN_SASL_SSF, &sasl_ssf) != 0) {\n-                    slapi_log_error( SLAPI_LOG_PLUGIN, \"do_bind\",\n-                                     \"Could not get SASL SSF from connection\\n\" );\n-                    sasl_ssf = 0;\n-                }\n+            Connection *conn = NULL;\n+            int sasl_ssf = 0;\n+            int local_ssf = 0;\n+\n+            /* Allow simple binds only for SSL/TLS established connections\n+             * or connections using SASL privacy layers */\n+            conn = pb->pb_conn;\n+            if ( slapi_pblock_get(pb, SLAPI_CONN_SASL_SSF, &sasl_ssf) != 0) {\n+                slapi_log_error( SLAPI_LOG_PLUGIN, \"do_bind\",\n+                                 \"Could not get SASL SSF from connection\\n\" );\n+                sasl_ssf = 0;\n+            }\n \n-                if ( slapi_pblock_get(pb, SLAPI_CONN_LOCAL_SSF, &local_ssf) != 0) {\n-                    slapi_log_error( SLAPI_LOG_PLUGIN, \"do_bind\",\n-                                     \"Could not get local SSF from connection\\n\" );\n-                    local_ssf = 0;\n-                }\n+            if ( slapi_pblock_get(pb, SLAPI_CONN_LOCAL_SSF, &local_ssf) != 0) {\n+                slapi_log_error( SLAPI_LOG_PLUGIN, \"do_bind\",\n+                                 \"Could not get local SSF from connection\\n\" );\n+                local_ssf = 0;\n+            }\n \n-                if (((conn->c_flags & CONN_FLAG_SSL) != CONN_FLAG_SSL) &&\n-                    (sasl_ssf <= 1) && (local_ssf <= 1)) {\n-                        send_ldap_result(pb, LDAP_CONFIDENTIALITY_REQUIRED, NULL,\n-                                         \"Operation requires a secure connection\",\n-                                         0, NULL);\n-                        slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsBindSecurityErrors);\n-                        goto free_and_return;\n-                }\n+            if (((conn->c_flags & CONN_FLAG_SSL) != CONN_FLAG_SSL) &&\n+                (sasl_ssf <= 1) && (local_ssf <= 1)) {\n+                send_ldap_result(pb, LDAP_CONFIDENTIALITY_REQUIRED, NULL,\n+                                 \"Operation requires a secure connection\", 0, NULL);\n+                slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsBindSecurityErrors);\n+                goto free_and_return;\n+            }\n         }\n         break;\n     default:\n@@ -627,6 +626,7 @@ do_bind( Slapi_PBlock *pb )\n                 /*\n                  *  right dn, wrong passwd - reject with invalid credentials\n                  */\n+                slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Invalid credentials\");\n                 send_ldap_result( pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL );\n                 /* increment BindSecurityErrorcount */\n                 slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsBindSecurityErrors);\n@@ -686,7 +686,8 @@ do_bind( Slapi_PBlock *pb )\n             slapi_pblock_get(pb, SLAPI_BIND_TARGET_SDN, &pb_sdn);\n             if (!pb_sdn) {\n                 slapi_create_errormsg(errorbuf, sizeof(errorbuf), \"Pre-bind plug-in set NULL dn\\n\");\n-                send_ldap_result(pb, LDAP_OPERATIONS_ERROR, NULL, errorbuf, 0, NULL);\n+                slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, errorbuf);\n+                send_ldap_result(pb, LDAP_OPERATIONS_ERROR, NULL, \"\", 0, NULL);\n                 goto free_and_return;\n             } else if ((pb_sdn != sdn) || (sdn_updated = slapi_sdn_compare(original_sdn, pb_sdn))) {\n                 /*\n@@ -696,8 +697,10 @@ do_bind( Slapi_PBlock *pb )\n                 sdn = pb_sdn;\n                 dn = slapi_sdn_get_dn(sdn);\n                 if (!dn) {\n-                    slapi_create_errormsg(errorbuf, sizeof(errorbuf), \"Pre-bind plug-in set corrupted dn\\n\");\n-                    send_ldap_result(pb, LDAP_OPERATIONS_ERROR, NULL, errorbuf, 0, NULL);\n+                    char *udn = slapi_sdn_get_udn(sdn);\n+                    slapi_create_errormsg(errorbuf, sizeof(errorbuf), \"Pre-bind plug-in set corrupted dn %s\\n\", udn?udn:\"\");\n+                    slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, errorbuf);\n+                    send_ldap_result(pb, LDAP_OPERATIONS_ERROR, NULL, \"\", 0, NULL);\n                     goto free_and_return;\n                 }\n                 if (!sdn_updated) { /* pb_sdn != sdn; need to compare the dn's. */\n@@ -711,7 +714,8 @@ do_bind( Slapi_PBlock *pb )\n                         slapi_pblock_set( pb, SLAPI_BACKEND, be );\n                     } else {\n                         slapi_create_errormsg(errorbuf, sizeof(errorbuf), \"No matching backend for %s\\n\", dn);\n-                        send_ldap_result(pb, LDAP_OPERATIONS_ERROR, NULL, errorbuf, 0, NULL);\n+                        slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, errorbuf);\n+                        send_ldap_result(pb, LDAP_OPERATIONS_ERROR, NULL, \"\", 0, NULL);\n                         goto free_and_return;\n                     }\n                 }\n@@ -790,7 +794,8 @@ do_bind( Slapi_PBlock *pb )\n                                     goto account_locked;\n                                 }\n                             } else {\n-                                send_ldap_result(pb, LDAP_NO_SUCH_OBJECT, NULL, \"\", 0, NULL);\n+                                slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"No such entry\");\n+                                send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, \"\", 0, NULL);\n                                 goto free_and_return;\n                             }\n                         }\n@@ -850,8 +855,7 @@ do_bind( Slapi_PBlock *pb )\n              * the front end.\n              */\n             if ( rc == SLAPI_BIND_SUCCESS || rc == SLAPI_BIND_ANONYMOUS) {\n-                send_ldap_result( pb, LDAP_SUCCESS, NULL, NULL,\n-                                  0, NULL );\n+                send_ldap_result( pb, LDAP_SUCCESS, NULL, NULL, 0, NULL );\n             }\n \n             slapi_pblock_set( pb, SLAPI_PLUGIN_OPRETURN, &rc );\n@@ -876,8 +880,7 @@ free_and_return:;\n     slapi_sdn_free(&sdn);\n     slapi_ch_free_string( &saslmech );\n     slapi_ch_free( (void **)&cred.bv_val );\n-    if ( bind_target_entry != NULL )\n-        slapi_entry_free(bind_target_entry);\n+    slapi_entry_free(bind_target_entry);\n }\n \n "
        },
        {
          "filename": "ldap/servers/slapd/defbackend.c",
          "status": "modified",
          "additions": 78,
          "deletions": 4,
          "patch": "@@ -171,6 +171,51 @@ defbackend_abandon( Slapi_PBlock *pb )\n }\n \n \n+#define DEFBE_NO_SUCH_SUFFIX \"No such suffix\"\n+/*\n+ * Generate a \"No such suffix\" return text\n+ * Example:\n+ *   cn=X,dc=bogus,dc=com ==> \"No such suffix (dc=bogus,dc=com)\" \n+ *     if the last rdn starts with \"dc=\", print all last dc= rdn's.\n+ *   cn=X,cn=bogus ==> \"No such suffix (cn=bogus)\"\n+ *     otherwise, print the very last rdn.\n+ *   cn=X,z=bogus ==> \"No such suffix (x=bogus)\"\n+ *     it is true even if it is an invalid rdn.\n+ *   cn=X,bogus ==> \"No such suffix (bogus)\"\n+ *     another example of invalid rdn.\n+ */\n+static void\n+_defbackend_gen_returntext(char *buffer, size_t buflen, char **dns)\n+{\n+    int dnidx;\n+    int sidx;\n+    struct suffix_repeat {\n+        char *suffix;\n+        int size;\n+    } candidates[] = {\n+        {\"dc=\", 3}, /* dc could be repeated.  otherwise the last rdn is used. */\n+        {NULL, 0}\n+    };\n+    PR_snprintf(buffer, buflen, \"%s (\", DEFBE_NO_SUCH_SUFFIX);\n+    for (dnidx = 0; dns[dnidx]; dnidx++) ; /* finding the last */\n+    dnidx--; /* last rdn */\n+    for (sidx = 0; candidates[sidx].suffix; sidx++) {\n+        if (!PL_strncasecmp(dns[dnidx], candidates[sidx].suffix, candidates[sidx].size)) {\n+            while (!PL_strncasecmp(dns[--dnidx], candidates[sidx].suffix, candidates[sidx].size)) ;\n+            PL_strcat(buffer, dns[++dnidx]); /* the first \"dn=\", e.g. */\n+            for (++dnidx; dns[dnidx]; dnidx++) {\n+                PL_strcat(buffer, \",\");\n+                PL_strcat(buffer, dns[dnidx]);\n+            }\n+            PL_strcat(buffer, \")\");\n+            return; /* finished the task */\n+        }\n+    }\n+    PL_strcat(buffer, dns[dnidx]);\n+    PL_strcat(buffer, \")\");\n+    return;\n+}\n+\n static int\n defbackend_bind( Slapi_PBlock *pb )\n {\n@@ -188,11 +233,40 @@ defbackend_bind( Slapi_PBlock *pb )\n     slapi_pblock_get( pb, SLAPI_BIND_METHOD, &method );\n     slapi_pblock_get( pb, SLAPI_BIND_CREDENTIALS, &cred );\n     if ( method == LDAP_AUTH_SIMPLE && cred->bv_len == 0 ) {\n-\tslapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsAnonymousBinds);\n-\trc = SLAPI_BIND_ANONYMOUS;\n+        slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsAnonymousBinds);\n+        rc = SLAPI_BIND_ANONYMOUS;\n     } else {\n-\tsend_nobackend_ldap_result( pb );\n-\trc = SLAPI_BIND_FAIL;\n+        Slapi_DN *sdn = NULL;\n+        char *suffix = NULL;\n+        char **dns = NULL;\n+        \n+        if (pb->pb_op) {\n+            sdn = operation_get_target_spec(pb->pb_op);\n+            if (sdn) {\n+                dns = slapi_ldap_explode_dn(slapi_sdn_get_dn(sdn), 0);\n+                if (dns) {\n+                    size_t dnlen = slapi_sdn_get_ndn_len(sdn);\n+                    size_t len = dnlen + sizeof(DEFBE_NO_SUCH_SUFFIX) + 4;\n+                    suffix = slapi_ch_malloc(len);\n+                    if (dnlen) {\n+                        _defbackend_gen_returntext(suffix, len, dns);\n+                    } else {\n+                        PR_snprintf(suffix, len, \"%s\", DEFBE_NO_SUCH_SUFFIX);\n+                    }\n+                }\n+            }\n+        }\n+        if (suffix) {\n+            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, suffix);\n+        } else {\n+            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, DEFBE_NO_SUCH_SUFFIX);\n+        }\n+        send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, \"\", 0, NULL);\n+        if (dns) {\n+            slapi_ldap_value_free(dns);\n+        }\n+        slapi_ch_free_string(&suffix);\n+        rc = SLAPI_BIND_FAIL;\n     }\n \n     return( rc );"
        },
        {
          "filename": "ldap/servers/slapd/result.c",
          "status": "modified",
          "additions": 14,
          "deletions": 2,
          "patch": "@@ -2067,14 +2067,26 @@ log_result( Slapi_PBlock *pb, Operation *op, int err, ber_tag_t tag, int nentrie\n \t\t}\n \t\telse if ( !internal_op )\n \t\t{\n+\t\t\tchar *pbtxt = NULL;\n+\t\t\tchar *ext_str = NULL;\n+\t\t\tslapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &pbtxt);\n+\t\t\tif (pbtxt) {\n+\t\t\t\text_str = slapi_ch_smprintf(\" - %s\", pbtxt);\n+\t\t\t} else {\n+\t\t\t\text_str = \"\";\n+\t\t\t}\n \t\t\tslapi_log_access( LDAP_DEBUG_STATS,\n \t\t\t\t\t\t\t  \"conn=%\" NSPRIu64 \" op=%d RESULT err=%d\"\n-\t\t\t\t\t\t\t  \" tag=%\" BERTAG_T \" nentries=%d etime=%s%s%s\\n\",\n+\t\t\t\t\t\t\t  \" tag=%\" BERTAG_T \" nentries=%d etime=%s%s%s%s\\n\",\n \t\t\t\t\t\t\t  op->o_connid,\n \t\t\t\t\t\t\t  op->o_opid,\n \t\t\t\t\t\t\t  err, tag, nentries,\n \t\t\t\t\t\t\t  etime,\n-\t\t\t\t\t\t\t  notes_str, csn_str );\n+\t\t\t\t\t\t\t  notes_str, csn_str, ext_str);\n+\t\t\tif (pbtxt) {\n+\t\t\t\t/* if !pbtxt ==> ext_str == \"\".  Don't free ext_str. */\n+\t\t\t\tslapi_ch_free_string(&ext_str);\n+\t\t\t}\n \t\t}\n \t\telse\n \t\t{"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "eed4305bb29f7887c7afceeb241bad80f3e905b4",
            "date": "2025-01-14T18:55:03Z",
            "author_login": "droideck"
          },
          {
            "sha": "e6ad63be9b1918ce8ab05f214c80696db99dbc8b",
            "date": "2025-01-14T17:12:56Z",
            "author_login": "tbordaz"
          },
          {
            "sha": "9e092353064d6c43dd8b528b0d05342db4a4b1ff",
            "date": "2024-12-18T21:50:46Z",
            "author_login": "mreynolds389"
          },
          {
            "sha": "2bb63629aae5ba989c76b41188e38e7195a5c676",
            "date": "2025-01-14T03:46:08Z",
            "author_login": "droideck"
          },
          {
            "sha": "4bd27ecc4e1d21c8af5ab8cad795d70477179a98",
            "date": "2025-01-13T17:03:07Z",
            "author_login": "progier389"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-200",
    "description": "389 Directory Server in Red Hat Enterprise Linux Desktop 6 through 7, Red Hat Enterprise Linux HPC Node 6 through 7, Red Hat Enterprise Linux Server 6 through 7, and Red Hat Enterprise Linux Workstation 6 through 7 allows remote attackers to infer the existence of RDN component objects.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-06-08T19:29:00.260",
    "last_modified": "2024-11-21T02:53:22.880",
    "fix_date": "2016-07-13T21:49:18Z"
  },
  "references": [
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-2594.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-2765.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1347760",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/389ds/389-ds-base/commit/0b932d4b926d46ac5060f02617330dc444e06da1",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-2594.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-2765.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1347760",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/389ds/389-ds-base/commit/0b932d4b926d46ac5060f02617330dc444e06da1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:01.654066",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "389-ds-base",
    "owner": "389ds",
    "created_at": "2020-09-12T12:54:14Z",
    "updated_at": "2025-01-14T18:55:08Z",
    "pushed_at": "2025-01-14T19:13:56Z",
    "size": 61723,
    "stars": 224,
    "forks": 96,
    "open_issues": 524,
    "watchers": 224,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "389-ds-base-1.2.11",
      "389-ds-base-1.3.2",
      "389-ds-base-1.3.3",
      "389-ds-base-1.3.4",
      "389-ds-base-1.3.5",
      "389-ds-base-1.3.6",
      "389-ds-base-1.3.7",
      "389-ds-base-1.3.8",
      "389-ds-base-1.3.9",
      "389-ds-base-1.3.10",
      "389-ds-base-1.3.11",
      "389-ds-base-1.4.0",
      "389-ds-base-1.4.1",
      "389-ds-base-1.4.2",
      "389-ds-base-1.4.3",
      "389-ds-base-1.4.4",
      "389-ds-base-2.0",
      "389-ds-base-2.1",
      "389-ds-base-2.2",
      "389-ds-base-2.3",
      "389-ds-base-2.4",
      "389-ds-base-2.5",
      "389-ds-base-2.6",
      "389-ds-base-3.0",
      "main"
    ],
    "languages": {
      "C": 15934832,
      "Python": 7344491,
      "JavaScript": 4455877,
      "C++": 451972,
      "Rust": 147166,
      "TypeScript": 117060,
      "Perl": 116277,
      "Makefile": 100659,
      "M4": 67591,
      "SCSS": 45164,
      "Shell": 42602,
      "Roff": 25186,
      "CSS": 20639,
      "Yacc": 20413,
      "HTML": 15278,
      "Lex": 6900,
      "Dockerfile": 4562,
      "Java": 2300
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T19:45:26.044618"
  }
}