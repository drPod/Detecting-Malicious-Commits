{
  "cve_id": "CVE-2016-5093",
  "github_data": {
    "repository": "php/php-src",
    "fix_commit": "97eff7eb57fc2320c267a949cffd622c38712484",
    "related_commits": [
      "97eff7eb57fc2320c267a949cffd622c38712484",
      "97eff7eb57fc2320c267a949cffd622c38712484"
    ],
    "patch_url": "https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484.patch",
    "fix_commit_details": {
      "sha": "97eff7eb57fc2320c267a949cffd622c38712484",
      "commit_date": "2016-05-23T00:49:02Z",
      "author": {
        "login": "smalyshev",
        "type": "User",
        "stats": {
          "total_commits": 4051,
          "average_weekly_commits": 3.0096582466567607,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 527
        }
      },
      "commit_message": {
        "title": "Fix bug #72241: get_icu_value_internal out-of-bounds read",
        "length": 57,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 249,
        "additions": 132,
        "deletions": 117
      },
      "files": [
        {
          "filename": "ext/intl/locale/locale_methods.c",
          "status": "modified",
          "additions": 118,
          "deletions": 117,
          "patch": "@@ -65,26 +65,26 @@ ZEND_EXTERN_MODULE_GLOBALS( intl )\n */\n static const char * const LOC_GRANDFATHERED[] = {\n \t\"art-lojban\",\t\t\"i-klingon\",\t\t\"i-lux\",\t\t\t\"i-navajo\",\t\t\"no-bok\",\t\t\"no-nyn\",\n-\t\"cel-gaulish\",\t\t\"en-GB-oed\",\t\t\"i-ami\", \t\t\n-\t\"i-bnn\",\t\t\"i-default\",\t\t\"i-enochian\",\t\n-\t\"i-mingo\",\t\t\"i-pwn\", \t\t\"i-tao\", \n+\t\"cel-gaulish\",\t\t\"en-GB-oed\",\t\t\"i-ami\",\n+\t\"i-bnn\",\t\t\"i-default\",\t\t\"i-enochian\",\n+\t\"i-mingo\",\t\t\"i-pwn\", \t\t\"i-tao\",\n \t\"i-tay\",\t\t\"i-tsu\",\t\t\"sgn-BE-fr\",\n \t\"sgn-BE-nl\",\t\t\"sgn-CH-de\", \t\t\"zh-cmn\",\n  \t\"zh-cmn-Hans\", \t\t\"zh-cmn-Hant\",\t\t\"zh-gan\" ,\n \t\"zh-guoyu\", \t\t\"zh-hakka\", \t\t\"zh-min\",\n-\t\"zh-min-nan\", \t\t\"zh-wuu\", \t\t\"zh-xiang\",\t\n+\t\"zh-min-nan\", \t\t\"zh-wuu\", \t\t\"zh-xiang\",\n \t\"zh-yue\",\t\tNULL\n };\n \n /* Based on IANA registry at the time of writing this code\n *  This array lists the preferred values for the grandfathered tags if applicable\n-*  This is in sync with the array LOC_GRANDFATHERED\t \n+*  This is in sync with the array LOC_GRANDFATHERED\n *  e.g. the offsets of the grandfathered tags match the offset of the preferred  value\n */\n static const int \t\tLOC_PREFERRED_GRANDFATHERED_LEN = 6;\n static const char * const \tLOC_PREFERRED_GRANDFATHERED[]  = {\n \t\"jbo\",\t\t\t\"tlh\",\t\t\t\"lb\",\n-\t\"nv\", \t\t\t\"nb\",\t\t\t\"nn\",\t\t\t\n+\t\"nv\", \t\t\t\"nb\",\t\t\t\"nn\",\n \tNULL\n };\n \n@@ -122,7 +122,7 @@ static int16_t findOffset(const char* const* list, const char* key)\n /*}}}*/\n \n static char* getPreferredTag(const char* gf_tag)\n-{ \n+{\n \tchar* result = NULL;\n \tint grOffset = 0;\n \n@@ -141,15 +141,15 @@ static char* getPreferredTag(const char* gf_tag)\n }\n \n /* {{{\n-* returns the position of next token for lookup \n+* returns the position of next token for lookup\n * or -1 if no token\n-* strtokr equivalent search for token in reverse direction \n+* strtokr equivalent search for token in reverse direction\n */\n static int getStrrtokenPos(char* str, int savedPos)\n {\n \tint result =-1;\n \tint i;\n-\t\n+\n \tfor(i=savedPos-1; i>=0; i--) {\n \t\tif(isIDSeparator(*(str+i)) ){\n \t\t\t/* delimiter found; check for singleton */\n@@ -171,7 +171,7 @@ static int getStrrtokenPos(char* str, int savedPos)\n /* }}} */\n \n /* {{{\n-* returns the position of a singleton if present \n+* returns the position of a singleton if present\n * returns -1 if no singleton\n * strtok equivalent search for singleton\n */\n@@ -180,7 +180,7 @@ static int getSingletonPos(const char* str)\n \tint result =-1;\n \tint i=0;\n \tint len = 0;\n-\t\n+\n \tif( str && ((len=strlen(str))>0) ){\n \t\tfor( i=0; i<len ; i++){\n \t\t\tif( isIDSeparator(*(str+i)) ){\n@@ -198,7 +198,7 @@ static int getSingletonPos(const char* str)\n \t\t\t\t}\n \t\t\t}\n \t\t}/* end of for */\n-\t\t\n+\n \t}\n \treturn result;\n }\n@@ -224,7 +224,7 @@ PHP_NAMED_FUNCTION(zif_locale_get_default)\n PHP_NAMED_FUNCTION(zif_locale_set_default)\n {\n \tchar* locale_name = NULL;\n-\tint   len=0;\t\n+\tint   len=0;\n \n \tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n \t\t&locale_name ,&len ) == FAILURE)\n@@ -240,14 +240,14 @@ PHP_NAMED_FUNCTION(zif_locale_set_default)\n \t\tlen = strlen(locale_name);\n \t}\n \n-\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n+\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n \n \tRETURN_TRUE;\n }\n /* }}} */\n \n /* {{{\n-* Gets the value from ICU \n+* Gets the value from ICU\n * common code shared by get_primary_language,get_script or get_region or get_variant\n * result = 0 if error, 1 if successful , -1 if no value\n */\n@@ -284,7 +284,7 @@ static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*\n \t\t\t}\n \t\t}\n \n-\t\tsingletonPos = getSingletonPos( loc_name );\t\n+\t\tsingletonPos = getSingletonPos( loc_name );\n \t\tif( singletonPos == 0){\n \t\t\t/* singleton at start of script, region , variant etc.\n \t\t\t * or invalid singleton at start of language */\n@@ -299,7 +299,7 @@ static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*\n \t} /* end of if != LOC_CANONICAL_TAG */\n \n \tif( mod_loc_name == NULL){\n-\t\tmod_loc_name = estrdup(loc_name );\t\n+\t\tmod_loc_name = estrdup(loc_name );\n \t}\n \n \t/* Proceed to ICU */\n@@ -326,6 +326,7 @@ static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*\n \t\tif( U_FAILURE( status ) ) {\n \t\t\tif( status == U_BUFFER_OVERFLOW_ERROR ) {\n \t\t\t\tstatus = U_ZERO_ERROR;\n+\t\t\t\tbuflen++; /* add space for \\0 */\n \t\t\t\tcontinue;\n \t\t\t}\n \n@@ -366,7 +367,7 @@ static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*\n * Gets the value from ICU , called when PHP userspace function is called\n * common code shared by get_primary_language,get_script or get_region or get_variant\n */\n-static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) \n+static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n {\n \n \tconst char* loc_name        \t= NULL;\n@@ -422,47 +423,47 @@ static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n }\n /* }}} */\n \n-/* {{{ proto static string Locale::getScript($locale) \n- * gets the script for the $locale \n+/* {{{ proto static string Locale::getScript($locale)\n+ * gets the script for the $locale\n  }}} */\n-/* {{{ proto static string locale_get_script($locale) \n- * gets the script for the $locale \n+/* {{{ proto static string locale_get_script($locale)\n+ * gets the script for the $locale\n  */\n-PHP_FUNCTION( locale_get_script ) \n+PHP_FUNCTION( locale_get_script )\n {\n \tget_icu_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n /* }}} */\n \n-/* {{{ proto static string Locale::getRegion($locale) \n- * gets the region for the $locale \n+/* {{{ proto static string Locale::getRegion($locale)\n+ * gets the region for the $locale\n  }}} */\n-/* {{{ proto static string locale_get_region($locale) \n- * gets the region for the $locale \n+/* {{{ proto static string locale_get_region($locale)\n+ * gets the region for the $locale\n  */\n-PHP_FUNCTION( locale_get_region ) \n+PHP_FUNCTION( locale_get_region )\n {\n \tget_icu_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n /* }}} */\n \n-/* {{{ proto static string Locale::getPrimaryLanguage($locale) \n- * gets the primary language for the $locale \n+/* {{{ proto static string Locale::getPrimaryLanguage($locale)\n+ * gets the primary language for the $locale\n  }}} */\n-/* {{{ proto static string locale_get_primary_language($locale) \n- * gets the primary language for the $locale \n+/* {{{ proto static string locale_get_primary_language($locale)\n+ * gets the primary language for the $locale\n  */\n-PHP_FUNCTION(locale_get_primary_language ) \n+PHP_FUNCTION(locale_get_primary_language )\n {\n \tget_icu_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n /* }}} */\n \n \n /* {{{\n- * common code shared by display_xyz functions to  get the value from ICU \n+ * common code shared by display_xyz functions to  get the value from ICU\n  }}} */\n-static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) \n+static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n {\n \tconst char* loc_name        \t= NULL;\n \tint         loc_name_len    \t= 0;\n@@ -488,7 +489,7 @@ static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAME\n \tintl_error_reset( NULL TSRMLS_CC );\n \n \tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s|s\",\n-\t\t&loc_name, &loc_name_len , \n+\t\t&loc_name, &loc_name_len ,\n \t\t&disp_loc_name ,&disp_loc_name_len ) == FAILURE)\n \t{\n \t\tspprintf(&msg , 0, \"locale_get_display_%s : unable to parse input params\", tag_name );\n@@ -525,7 +526,7 @@ static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAME\n \tif( mod_loc_name==NULL ){\n \t\tmod_loc_name = estrdup( loc_name );\n \t}\n-\t\n+\n \t/* Check if disp_loc_name passed , if not use default locale */\n \tif( !disp_loc_name){\n \t\tdisp_loc_name = estrdup(intl_locale_get_default(TSRMLS_C));\n@@ -604,7 +605,7 @@ static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAME\n /* {{{ proto static string get_display_name($locale[, $in_locale = null])\n * gets the name for the $locale in $in_locale or default_locale\n */\n-PHP_FUNCTION(locale_get_display_name) \n+PHP_FUNCTION(locale_get_display_name)\n {\n     get_icu_disp_value_src_php( DISP_NAME , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -616,7 +617,7 @@ PHP_FUNCTION(locale_get_display_name)\n /* {{{ proto static string get_display_language($locale[, $in_locale = null])\n * gets the language for the $locale in $in_locale or default_locale\n */\n-PHP_FUNCTION(locale_get_display_language) \n+PHP_FUNCTION(locale_get_display_language)\n {\n     get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -628,7 +629,7 @@ PHP_FUNCTION(locale_get_display_language)\n /* {{{ proto static string get_display_script($locale, $in_locale = null)\n * gets the script for the $locale in $in_locale or default_locale\n */\n-PHP_FUNCTION(locale_get_display_script) \n+PHP_FUNCTION(locale_get_display_script)\n {\n     get_icu_disp_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -640,7 +641,7 @@ PHP_FUNCTION(locale_get_display_script)\n /* {{{ proto static string get_display_region($locale, $in_locale = null)\n * gets the region for the $locale in $in_locale or default_locale\n */\n-PHP_FUNCTION(locale_get_display_region) \n+PHP_FUNCTION(locale_get_display_region)\n {\n     get_icu_disp_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -654,7 +655,7 @@ PHP_FUNCTION(locale_get_display_region)\n * proto static string get_display_variant($locale, $in_locale = null)\n * gets the variant for the $locale in $in_locale or default_locale\n */\n-PHP_FUNCTION(locale_get_display_variant) \n+PHP_FUNCTION(locale_get_display_variant)\n {\n     get_icu_disp_value_src_php( LOC_VARIANT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -667,7 +668,7 @@ PHP_FUNCTION(locale_get_display_variant)\n  /* {{{ proto static array locale_get_keywords(string $locale) {\n  * return an associative array containing keyword-value\n  * pairs for this locale. The keys are keys to the array (doh!)\n- */ \n+ */\n PHP_FUNCTION( locale_get_keywords )\n {\n     UEnumeration*   e        = NULL;\n@@ -679,10 +680,10 @@ PHP_FUNCTION( locale_get_keywords )\n     const char*       \tloc_name        = NULL;\n     int        \t \tloc_name_len    = 0;\n \n-/* \n-\tICU expects the buffer to be allocated  before calling the function \n-\tand so the buffer size has been explicitly specified \n-\tICU uloc.h #define \tULOC_KEYWORD_AND_VALUES_CAPACITY   100 \n+/*\n+\tICU expects the buffer to be allocated  before calling the function\n+\tand so the buffer size has been explicitly specified\n+\tICU uloc.h #define \tULOC_KEYWORD_AND_VALUES_CAPACITY   100\n \thence the kw_value buffer size is 100\n */\n \tchar*\t \tkw_value        = NULL;\n@@ -721,7 +722,7 @@ PHP_FUNCTION( locale_get_keywords )\n \t\t\t\tkw_value_len=uloc_getKeywordValue( loc_name,kw_key, kw_value, kw_value_len+1 ,  &status );\n \t\t\t} else if(!U_FAILURE(status)) {\n \t\t\t\tkw_value = erealloc( kw_value , kw_value_len+1);\n-\t\t\t} \n+\t\t\t}\n \t\t\tif (U_FAILURE(status)) {\n \t        \t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, \"locale_get_keywords: Error encountered while getting the keyword  value for the  keyword\", 0 TSRMLS_CC );\n \t\t\t\tif( kw_value){\n@@ -740,10 +741,10 @@ PHP_FUNCTION( locale_get_keywords )\n }\n /* }}} */\n \n- /* {{{ proto static string Locale::canonicalize($locale) \n- * @return string the canonicalized locale \n+ /* {{{ proto static string Locale::canonicalize($locale)\n+ * @return string the canonicalized locale\n  * }}} */\n- /* {{{ proto static string locale_canonicalize(Locale $loc, string $locale) \n+ /* {{{ proto static string locale_canonicalize(Locale $loc, string $locale)\n  * @param string $locale\tThe locale string to canonicalize\n  */\n PHP_FUNCTION(locale_canonicalize)\n@@ -752,10 +753,10 @@ PHP_FUNCTION(locale_canonicalize)\n }\n /* }}} */\n \n-/* {{{ append_key_value \n+/* {{{ append_key_value\n * Internal function which is called from locale_compose\n * gets the value for the key_name and appends to the loc_name\n-* returns 1 if successful , -1 if not found , \n+* returns 1 if successful , -1 if not found ,\n * 0 if array element is not a string , -2 if buffer-overflow\n */\n static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n@@ -767,7 +768,7 @@ static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_\n \t\t\t/* element value is not a string */\n \t\t\treturn FAILURE;\n \t\t}\n-\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 && \n+\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 &&\n \t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n \t\t\t/* not lang or grandfathered tag */\n \t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n@@ -792,11 +793,11 @@ static void add_prefix(smart_str* loc_name, char* key_name)\n }\n /* }}} */\n \n-/* {{{ append_multiple_key_values \n+/* {{{ append_multiple_key_values\n * Internal function which is called from locale_compose\n * gets the multiple values for the key_name and appends to the loc_name\n-* used for 'variant','extlang','private' \n-* returns 1 if successful , -1 if not found , \n+* used for 'variant','extlang','private'\n+* returns 1 if successful , -1 if not found ,\n * 0 if array element is not a string , -2 if buffer-overflow\n */\n static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr, char* key_name TSRMLS_DC)\n@@ -850,8 +851,8 @@ static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr,\n \n \t\t/* Multiple variant values as variant0, variant1 ,variant2 */\n \t\tisFirstSubtag = 0;\n-\t\tfor( i=0 ; i< max_value; i++ ){  \n-\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\t\n+\t\tfor( i=0 ; i< max_value; i++ ){\n+\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\n \t\t\tif( zend_hash_find( hash_arr , cur_key_name , strlen(cur_key_name) + 1,(void **)&ele_value ) == SUCCESS ){\n \t\t\t\tif( Z_TYPE_PP(ele_value)!= IS_STRING ){\n \t\t\t\t\t/* variant is not a string */\n@@ -873,7 +874,7 @@ static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr,\n \n /*{{{\n * If applicable sets error message and aborts locale_compose gracefully\n-* returns 0  if locale_compose needs to be aborted \n+* returns 0  if locale_compose needs to be aborted\n * otherwise returns 1\n */\n static int handleAppendResult( int result, smart_str* loc_name TSRMLS_DC)\n@@ -890,11 +891,11 @@ static int handleAppendResult( int result, smart_str* loc_name TSRMLS_DC)\n /* }}} */\n \n #define RETURN_SMART_STR(s) smart_str_0((s)); RETURN_STRINGL((s)->c, (s)->len, 0)\n-/* {{{ proto static string Locale::composeLocale($array) \n-* Creates a locale by combining the parts of locale-ID passed\t\n+/* {{{ proto static string Locale::composeLocale($array)\n+* Creates a locale by combining the parts of locale-ID passed\n * }}} */\n-/* {{{ proto static string compose_locale($array) \n-* Creates a locale by combining the parts of locale-ID passed\t\n+/* {{{ proto static string compose_locale($array)\n+* Creates a locale by combining the parts of locale-ID passed\n * }}} */\n PHP_FUNCTION(locale_compose)\n {\n@@ -920,7 +921,7 @@ PHP_FUNCTION(locale_compose)\n \t\tRETURN_FALSE;\n \n \t/* Check for grandfathered first */\n-\tresult = append_key_value(loc_name, hash_arr,  LOC_GRANDFATHERED_LANG_TAG);\t\n+\tresult = append_key_value(loc_name, hash_arr,  LOC_GRANDFATHERED_LANG_TAG);\n \tif( result == SUCCESS){\n \t\tRETURN_SMART_STR(loc_name);\n \t}\n@@ -929,7 +930,7 @@ PHP_FUNCTION(locale_compose)\n \t}\n \n \t/* Not grandfathered */\n-\tresult = append_key_value(loc_name, hash_arr , LOC_LANG_TAG);\t\n+\tresult = append_key_value(loc_name, hash_arr , LOC_LANG_TAG);\n \tif( result == LOC_NOT_FOUND ){\n \t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n \t\t\"locale_compose: parameter array does not contain 'language' tag.\", 0 TSRMLS_CC );\n@@ -947,19 +948,19 @@ PHP_FUNCTION(locale_compose)\n \t}\n \n \t/* Script */\n-\tresult = append_key_value(loc_name, hash_arr , LOC_SCRIPT_TAG); \n+\tresult = append_key_value(loc_name, hash_arr , LOC_SCRIPT_TAG);\n \tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n \t\tRETURN_FALSE;\n \t}\n-\t\n+\n \t/* Region */\n \tresult = append_key_value( loc_name, hash_arr , LOC_REGION_TAG);\n \tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n \t\tRETURN_FALSE;\n \t}\n \n \t/* Variant */\n-\tresult = append_multiple_key_values( loc_name, hash_arr , LOC_VARIANT_TAG TSRMLS_CC); \n+\tresult = append_multiple_key_values( loc_name, hash_arr , LOC_VARIANT_TAG TSRMLS_CC);\n \tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n \t\tRETURN_FALSE;\n \t}\n@@ -985,16 +986,16 @@ static char* get_private_subtags(const char* loc_name)\n {\n \tchar* \tresult =NULL;\n \tint \tsingletonPos = 0;\n-\tint \tlen =0; \n+\tint \tlen =0;\n \tconst char* \tmod_loc_name =NULL;\n \n \tif( loc_name && (len = strlen(loc_name)>0 ) ){\n-\t\tmod_loc_name = loc_name ; \n+\t\tmod_loc_name = loc_name ;\n \t\tlen   = strlen(mod_loc_name);\n \t\twhile( (singletonPos = getSingletonPos(mod_loc_name))!= -1){\n \n-\t\t\tif( singletonPos!=-1){ \n-\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\t\t\n+\t\t\tif( singletonPos!=-1){\n+\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\n \t\t\t\t\t/* private subtag start found */\n \t\t\t\t\tif( singletonPos + 2 ==  len){\n \t\t\t\t\t\t/* loc_name ends with '-x-' ; return  NULL */\n@@ -1019,7 +1020,7 @@ static char* get_private_subtags(const char* loc_name)\n \n \t\t} /* end of while */\n \t}\n-\t\n+\n \treturn result;\n }\n /* }}} */\n@@ -1044,20 +1045,20 @@ static int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name\n \t} else {\n \t\tkey_value = get_icu_value_internal( loc_name , key_name , &result,1 );\n \t}\n-\tif( (strcmp(key_name , LOC_PRIVATE_TAG)==0) || \n+\tif( (strcmp(key_name , LOC_PRIVATE_TAG)==0) ||\n \t\t( strcmp(key_name , LOC_VARIANT_TAG)==0) ){\n \t\tif( result > 0 && key_value){\n \t\t\t/* Tokenize on the \"_\" or \"-\"  */\n-\t\t\ttoken = php_strtok_r( key_value , DELIMITER ,&last_ptr);\t\n+\t\t\ttoken = php_strtok_r( key_value , DELIMITER ,&last_ptr);\n \t\t\tif( cur_key_name ){\n \t\t\t\tefree( cur_key_name);\n \t\t\t}\n \t\t\tcur_key_name = (char*)ecalloc( 25,  25);\n-\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\t\n+\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\n \t\t\tadd_assoc_string( hash_arr, cur_key_name , token ,TRUE );\n \t\t\t/* tokenize on the \"_\" or \"-\" and stop  at singleton if any */\n \t\t\twhile( (token = php_strtok_r(NULL , DELIMITER , &last_ptr)) && (strlen(token)>1) ){\n-\t\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\t\n+\t\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\n \t\t\t\tadd_assoc_string( hash_arr, cur_key_name , token , TRUE );\n \t\t\t}\n /*\n@@ -1077,16 +1078,16 @@ static int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name\n \t}\n \t/*if( key_name != LOC_PRIVATE_TAG && key_value){*/\n \tif( key_value){\n-\t\tefree(key_value);\t\n+\t\tefree(key_value);\n \t}\n \treturn cur_result;\n }\n /* }}} */\n \n-/* {{{ proto static array Locale::parseLocale($locale) \n+/* {{{ proto static array Locale::parseLocale($locale)\n * parses a locale-id into an array the different parts of it\n  }}} */\n-/* {{{ proto static array parse_locale($locale) \n+/* {{{ proto static array parse_locale($locale)\n * parses a locale-id into an array the different parts of it\n */\n PHP_FUNCTION(locale_parse)\n@@ -1144,7 +1145,7 @@ PHP_FUNCTION(locale_get_all_variants)\n \tchar*\tsaved_ptr\t= NULL;\n \n \tintl_error_reset( NULL TSRMLS_CC );\n-\t\n+\n \tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n \t&loc_name, &loc_name_len ) == FAILURE)\n \t{\n@@ -1162,15 +1163,15 @@ PHP_FUNCTION(locale_get_all_variants)\n \tarray_init( return_value );\n \n \t/* If the locale is grandfathered, stop, no variants */\n-\tif( findOffset( LOC_GRANDFATHERED , loc_name ) >=  0 ){ \n+\tif( findOffset( LOC_GRANDFATHERED , loc_name ) >=  0 ){\n \t\t/* (\"Grandfathered Tag. No variants.\"); */\n \t}\n-\telse {\t\n+\telse {\n \t/* Call ICU variant */\n \t\tvariant = get_icu_value_internal( loc_name , LOC_VARIANT_TAG , &result ,0);\n \t\tif( result > 0 && variant){\n \t\t\t/* Tokenize on the \"_\" or \"-\" */\n-\t\t\ttoken = php_strtok_r( variant , DELIMITER , &saved_ptr);\t\n+\t\t\ttoken = php_strtok_r( variant , DELIMITER , &saved_ptr);\n \t\t\tadd_next_index_stringl( return_value, token , strlen(token) ,TRUE );\n \t\t\t/* tokenize on the \"_\" or \"-\" and stop  at singleton if any\t*/\n \t\t\twhile( (token = php_strtok_r(NULL , DELIMITER, &saved_ptr)) && (strlen(token)>1) ){\n@@ -1181,7 +1182,7 @@ PHP_FUNCTION(locale_get_all_variants)\n \t\t\tefree( variant );\n \t\t}\n \t}\n-\t\t\t\n+\n \n }\n /* }}} */\n@@ -1220,11 +1221,11 @@ static int strToMatch(const char* str ,char *retstr)\n /* }}} */\n \n /* {{{ proto static boolean Locale::filterMatches(string $langtag, string $locale[, bool $canonicalize])\n-* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm \n+* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm\n */\n /* }}} */\n /* {{{ proto boolean locale_filter_matches(string $langtag, string $locale[, bool $canonicalize])\n-* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm \n+* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm\n */\n PHP_FUNCTION(locale_filter_matches)\n {\n@@ -1243,13 +1244,13 @@ PHP_FUNCTION(locale_filter_matches)\n \tchar*       \tcur_lang_tag    = NULL;\n \tchar*       \tcur_loc_range   = NULL;\n \n-\tzend_bool \tboolCanonical \t= 0;\t\n+\tzend_bool \tboolCanonical \t= 0;\n \tUErrorCode\tstatus\t\t= U_ZERO_ERROR;\n \n \tintl_error_reset( NULL TSRMLS_CC );\n-\t\n+\n \tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"ss|b\",\n-\t\t&lang_tag, &lang_tag_len , &loc_range , &loc_range_len , \n+\t\t&lang_tag, &lang_tag_len , &loc_range , &loc_range_len ,\n \t\t&boolCanonical) == FAILURE)\n \t{\n \t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n@@ -1270,15 +1271,15 @@ PHP_FUNCTION(locale_filter_matches)\n \t\t/* canonicalize loc_range */\n \t\tcan_loc_range=get_icu_value_internal( loc_range , LOC_CANONICALIZE_TAG , &result , 0);\n \t\tif( result ==0) {\n-\t\t\tintl_error_set( NULL, status, \n+\t\t\tintl_error_set( NULL, status,\n \t\t\t\t\"locale_filter_matches : unable to canonicalize loc_range\" , 0 TSRMLS_CC );\n \t\t\tRETURN_FALSE;\n \t\t}\n \n \t\t/* canonicalize lang_tag */\n \t\tcan_lang_tag = get_icu_value_internal( lang_tag , LOC_CANONICALIZE_TAG , &result ,  0);\n \t\tif( result ==0) {\n-\t\t\tintl_error_set( NULL, status, \n+\t\t\tintl_error_set( NULL, status,\n \t\t\t\t\"locale_filter_matches : unable to canonicalize lang_tag\" , 0 TSRMLS_CC );\n \t\t\tRETURN_FALSE;\n \t\t}\n@@ -1306,11 +1307,11 @@ PHP_FUNCTION(locale_filter_matches)\n \n \t\t/* check if prefix */\n \t\ttoken \t= strstr( cur_lang_tag , cur_loc_range );\n-\t\n+\n \t\tif( token && (token==cur_lang_tag) ){\n \t\t\t/* check if the char. after match is SEPARATOR */\n \t\t\tchrcheck = token + (strlen(cur_loc_range));\n-\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){ \n+\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){\n \t\t\t\tif( cur_lang_tag){\n \t\t\t\t\tefree( cur_lang_tag );\n \t\t\t\t}\n@@ -1346,7 +1347,7 @@ PHP_FUNCTION(locale_filter_matches)\n \telse{\n \t\t/* Convert to lower case for case-insensitive comparison */\n \t\tcur_lang_tag = ecalloc( 1, strlen(lang_tag ) + 1);\n-\t\t\n+\n \t\tresult = strToMatch( lang_tag , cur_lang_tag);\n \t\tif( result == 0) {\n \t\t\tefree( cur_lang_tag );\n@@ -1362,11 +1363,11 @@ PHP_FUNCTION(locale_filter_matches)\n \n \t\t/* check if prefix */\n \t\ttoken \t= strstr( cur_lang_tag , cur_loc_range );\n-\t\t\n+\n \t\tif( token && (token==cur_lang_tag) ){\n \t\t\t/* check if the char. after match is SEPARATOR */\n \t\t\tchrcheck = token + (strlen(cur_loc_range));\n-\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){ \n+\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){\n \t\t\t\tif( cur_lang_tag){\n \t\t\t\t\tefree( cur_lang_tag );\n \t\t\t\t}\n@@ -1393,7 +1394,7 @@ PHP_FUNCTION(locale_filter_matches)\n static void array_cleanup( char* arr[] , int arr_size)\n {\n \tint i=0;\n-\tfor( i=0; i< arr_size; i++ ){ \n+\tfor( i=0; i< arr_size; i++ ){\n \t\tif( arr[i*2] ){\n \t\t\tefree( arr[i*2]);\n \t\t}\n@@ -1403,7 +1404,7 @@ static void array_cleanup( char* arr[] , int arr_size)\n \n #define LOOKUP_CLEAN_RETURN(value)\tarray_cleanup(cur_arr, cur_arr_len); return (value)\n /* {{{\n-* returns the lookup result to lookup_loc_range_src_php \n+* returns the lookup result to lookup_loc_range_src_php\n * internal function\n */\n static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int canonicalize  TSRMLS_DC)\n@@ -1427,7 +1428,7 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \tfor(zend_hash_internal_pointer_reset(hash_arr);\n \t\tzend_hash_has_more_elements(hash_arr) == SUCCESS;\n \t\tzend_hash_move_forward(hash_arr)) {\n-\t\t\n+\n \t\tif (zend_hash_get_current_data(hash_arr, (void**)&ele_value) == FAILURE) {\n \t\t\t/* Should never actually fail since the key is known to exist.*/\n \t\t\tcontinue;\n@@ -1436,20 +1437,20 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t\t\t/* element value is not a string */\n \t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: locale array element is not a string\", 0 TSRMLS_CC);\n \t\t\tLOOKUP_CLEAN_RETURN(NULL);\n-\t\t} \n+\t\t}\n \t\tcur_arr[cur_arr_len*2] = estrndup(Z_STRVAL_PP(ele_value), Z_STRLEN_PP(ele_value));\n \t\tresult = strToMatch(Z_STRVAL_PP(ele_value), cur_arr[cur_arr_len*2]);\n \t\tif(result == 0) {\n \t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\", 0 TSRMLS_CC);\n \t\t\tLOOKUP_CLEAN_RETURN(NULL);\n \t\t}\n \t\tcur_arr[cur_arr_len*2+1] = Z_STRVAL_PP(ele_value);\n-\t\tcur_arr_len++ ; \n+\t\tcur_arr_len++ ;\n \t} /* end of for */\n \n \t/* Canonicalize array elements */\n \tif(canonicalize) {\n-\t\tfor(i=0; i<cur_arr_len; i++) { \n+\t\tfor(i=0; i<cur_arr_len; i++) {\n \t\t\tlang_tag = get_icu_value_internal(cur_arr[i*2], LOC_CANONICALIZE_TAG, &result, 0);\n \t\t\tif(result != 1 || lang_tag == NULL || !lang_tag[0]) {\n \t\t\t\tif(lang_tag) {\n@@ -1459,7 +1460,7 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n \t\t\t}\n \t\t\tcur_arr[i*2] = erealloc(cur_arr[i*2], strlen(lang_tag)+1);\n-\t\t\tresult = strToMatch(lang_tag, cur_arr[i*2]);\t\n+\t\t\tresult = strToMatch(lang_tag, cur_arr[i*2]);\n \t\t\tefree(lang_tag);\n \t\t\tif(result == 0) {\n \t\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\" , 0 TSRMLS_CC);\n@@ -1482,11 +1483,11 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t\t} else {\n \t\t\tloc_range = can_loc_range;\n \t\t}\n-\t} \n+\t}\n \n \tcur_loc_range = ecalloc(1, strlen(loc_range)+1);\n \t/* convert to lower and replace hyphens */\n-\tresult = strToMatch(loc_range, cur_loc_range);\t\n+\tresult = strToMatch(loc_range, cur_loc_range);\n \tif(can_loc_range) {\n \t\tefree(can_loc_range);\n \t}\n@@ -1498,8 +1499,8 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t/* Lookup for the lang_tag match */\n \tsaved_pos = strlen(cur_loc_range);\n \twhile(saved_pos > 0) {\n-\t\tfor(i=0; i< cur_arr_len; i++){ \n-\t\t\tif(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {\t\n+\t\tfor(i=0; i< cur_arr_len; i++){\n+\t\t\tif(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {\n \t\t\t\t/* Match found */\n \t\t\t\treturn_value = estrdup(canonicalize?cur_arr[i*2]:cur_arr[i*2+1]);\n \t\t\t\tefree(cur_loc_range);\n@@ -1515,14 +1516,14 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n }\n /* }}} */\n \n-/* {{{ proto string Locale::lookup(array $langtag, string $locale[, bool $canonicalize[, string $default = null]]) \n+/* {{{ proto string Locale::lookup(array $langtag, string $locale[, bool $canonicalize[, string $default = null]])\n * Searchs the items in $langtag for the best match to the language\n-* range \n+* range\n */\n /* }}} */\n /* {{{ proto string locale_lookup(array $langtag, string $locale[, bool $canonicalize[, string $default = null]])\n * Searchs the items in $langtag for the best match to the language\n-* range \n+* range\n */\n PHP_FUNCTION(locale_lookup)\n {\n@@ -1552,8 +1553,8 @@ PHP_FUNCTION(locale_lookup)\n \n \tif( !hash_arr || zend_hash_num_elements( hash_arr ) == 0 ) {\n \t\tRETURN_EMPTY_STRING();\n-\t} \n-\t\n+\t}\n+\n \tresult = lookup_loc_range(loc_range, hash_arr, boolCanonical TSRMLS_CC);\n \tif(result == NULL || result[0] == '\\0') {\n \t\tif( fallback_loc ) {\n@@ -1590,10 +1591,10 @@ PHP_FUNCTION(locale_accept_from_http)\n \t\t\"locale_accept_from_http: unable to parse input parameters\", 0 TSRMLS_CC );\n \t\tRETURN_FALSE;\n \t}\n-\t\n+\n \tavailable = ures_openAvailableLocales(NULL, &status);\n \tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to retrieve locale list\");\n-\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN, \n+\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN,\n \t\t\t\t\t\t&outResult, http_accept, available, &status);\n \tuenum_close(available);\n \tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to find acceptable locale\");"
        },
        {
          "filename": "ext/intl/tests/bug72241.phpt",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+--TEST--\n+Bug #72241: get_icu_value_internal out-of-bounds read\n+--SKIPIF--\n+<?php if( !extension_loaded( 'intl' ) ) print 'skip'; ?>\n+--FILE--\n+<?php\n+$var1=str_repeat(\"A\", 1000);\n+$out = locale_get_primary_language($var1);\n+echo strlen($out) . PHP_EOL;\n+echo unpack('H*', $out)[1] . PHP_EOL;\n+--EXPECT--\n+1000\n+61616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161\n+"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "634edc8ab3850052942eba6432ba7a4f776ebae8",
            "date": "2025-01-14T11:36:58Z",
            "author_login": "cmb69"
          },
          {
            "sha": "58628e0cc629338fa43fb175f733778432346a86",
            "date": "2025-01-12T15:40:59Z",
            "author_login": "cmb69"
          },
          {
            "sha": "0e1fbf97f4ce4da519a2cf2654233a0d007800fd",
            "date": "2025-01-13T15:46:54Z",
            "author_login": "iluuu1994"
          },
          {
            "sha": "3c138641e12fad5e8a94174988801c0529ca1c38",
            "date": "2025-01-13T15:46:43Z",
            "author_login": "iluuu1994"
          },
          {
            "sha": "a6a290d541ae2de2e9248acd48ffa6129b6577b3",
            "date": "2025-01-06T14:18:00Z",
            "author_login": "iluuu1994"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-125",
    "description": "The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '\\0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2016-08-07T10:59:06.180",
    "last_modified": "2024-11-21T02:53:36.693",
    "fix_date": "2016-05-23T00:49:02Z"
  },
  "references": [
    {
      "url": "http://php.net/ChangeLog-5.php",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Release Notes"
      ]
    },
    {
      "url": "http://php.net/ChangeLog-7.php",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Release Notes"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-2750.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2016/dsa-3602",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/05/26/3",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/90946",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://bugs.php.net/bug.php?id=72241",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit"
      ]
    },
    {
      "url": "https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484?w=1",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://h20566.www2.hpe.com/portal/site/hpsc/public/kb/docDisplay?docId=emr_na-c05240731",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://php.net/ChangeLog-5.php",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Release Notes"
      ]
    },
    {
      "url": "http://php.net/ChangeLog-7.php",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Release Notes"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-2750.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2016/dsa-3602",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/05/26/3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/90946",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugs.php.net/bug.php?id=72241",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit"
      ]
    },
    {
      "url": "https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484?w=1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://h20566.www2.hpe.com/portal/site/hpsc/public/kb/docDisplay?docId=emr_na-c05240731",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:46.769210",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "php-src",
    "owner": "php",
    "created_at": "2011-06-16T01:52:25Z",
    "updated_at": "2025-01-14T11:37:56Z",
    "pushed_at": "2025-01-14T11:37:44Z",
    "size": 579039,
    "stars": 38520,
    "forks": 7798,
    "open_issues": 1300,
    "watchers": 38520,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "PEAR_1_4DEV",
      "PECL_OPENSSL",
      "PECL",
      "PECL_4_3",
      "PHAR_1_2",
      "PHP-4.0",
      "PHP-4.0.5",
      "PHP-4.0.6",
      "PHP-4.0.7",
      "PHP-4.2.0",
      "PHP-4.2.2",
      "PHP-4.3",
      "PHP-4.3.0",
      "PHP-4.3.1",
      "PHP-4.3.2",
      "PHP-4.3.7",
      "PHP-4.4",
      "PHP-5",
      "PHP-5.0",
      "PHP-5.1",
      "PHP-5.2",
      "PHP-5.2.1RC1",
      "PHP-5.3",
      "PHP-5.3.11",
      "PHP-5.3.12",
      "PHP-5.3.13",
      "PHP-5.3.14",
      "PHP-5.3.15",
      "PHP-5.3.16",
      "PHP-5.3.17"
    ],
    "languages": {
      "C": 65322886,
      "PHP": 30041198,
      "C++": 580205,
      "M4": 408378,
      "Shell": 299560,
      "Lua": 272563,
      "Assembly": 236754,
      "JavaScript": 198632,
      "Lex": 99367,
      "Yacc": 92094,
      "Makefile": 33437,
      "Roff": 32243,
      "GAP": 23811,
      "Python": 14072,
      "GDB": 13663,
      "XSLT": 7963,
      "Awk": 2920,
      "Batchfile": 2219,
      "DTrace": 2180,
      "HTML": 1894
    },
    "commit_activity": {
      "total_commits_last_year": 5383,
      "avg_commits_per_week": 103.51923076923077,
      "days_active_last_year": 358
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:07:39.017037"
  }
}