{
  "cve_id": "CVE-2016-5418",
  "github_data": {
    "repository": "libarchive/libarchive",
    "fix_commit": "dfd6b54ce33960e420fb206d8872fb759b577ad9",
    "related_commits": [
      "dfd6b54ce33960e420fb206d8872fb759b577ad9",
      "dfd6b54ce33960e420fb206d8872fb759b577ad9"
    ],
    "patch_url": "https://github.com/libarchive/libarchive/commit/dfd6b54ce33960e420fb206d8872fb759b577ad9.patch",
    "fix_commit_details": {
      "sha": "dfd6b54ce33960e420fb206d8872fb759b577ad9",
      "commit_date": "2016-09-11T20:21:57Z",
      "author": {
        "login": "kientzle",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fixes for Issue #745 and Issue #746 from Doran Moppert.",
        "length": 55,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 294,
        "additions": 227,
        "deletions": 67
      },
      "files": [
        {
          "filename": "libarchive/archive_write_disk_posix.c",
          "status": "modified",
          "additions": 227,
          "deletions": 67,
          "patch": "@@ -326,12 +326,14 @@ struct archive_write_disk {\n \n #define HFS_BLOCKS(s)\t((s) >> 12)\n \n+static int\tcheck_symlinks_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags);\n static int\tcheck_symlinks(struct archive_write_disk *);\n static int\tcreate_filesystem_object(struct archive_write_disk *);\n static struct fixup_entry *current_fixup(struct archive_write_disk *, const char *pathname);\n #if defined(HAVE_FCHDIR) && defined(PATH_MAX)\n static void\tedit_deep_directories(struct archive_write_disk *ad);\n #endif\n+static int\tcleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags);\n static int\tcleanup_pathname(struct archive_write_disk *);\n static int\tcreate_dir(struct archive_write_disk *, char *);\n static int\tcreate_parent_dir(struct archive_write_disk *, char *);\n@@ -2014,6 +2016,10 @@ create_filesystem_object(struct archive_write_disk *a)\n \tconst char *linkname;\n \tmode_t final_mode, mode;\n \tint r;\n+\t/* these for check_symlinks_fsobj */\n+\tchar *linkname_copy;\t/* non-const copy of linkname */\n+\tstruct archive_string error_string;\n+\tint error_number;\n \n \t/* We identify hard/symlinks according to the link names. */\n \t/* Since link(2) and symlink(2) don't handle modes, we're done here. */\n@@ -2022,6 +2028,27 @@ create_filesystem_object(struct archive_write_disk *a)\n #if !HAVE_LINK\n \t\treturn (EPERM);\n #else\n+\t\tarchive_string_init(&error_string);\n+\t\tlinkname_copy = strdup(linkname);\n+\t\tif (linkname_copy == NULL) {\n+\t\t    return (EPERM);\n+\t\t}\n+\t\t/* TODO: consider using the cleaned-up path as the link target? */\n+\t\tr = cleanup_pathname_fsobj(linkname_copy, &error_number, &error_string, a->flags);\n+\t\tif (r != ARCHIVE_OK) {\n+\t\t\tarchive_set_error(&a->archive, error_number, \"%s\", error_string.s);\n+\t\t\tfree(linkname_copy);\n+\t\t\t/* EPERM is more appropriate than error_number for our callers */\n+\t\t\treturn (EPERM);\n+\t\t}\n+\t\tr = check_symlinks_fsobj(linkname_copy, &error_number, &error_string, a->flags);\n+\t\tif (r != ARCHIVE_OK) {\n+\t\t\tarchive_set_error(&a->archive, error_number, \"%s\", error_string.s);\n+\t\t\tfree(linkname_copy);\n+\t\t\t/* EPERM is more appropriate than error_number for our callers */\n+\t\t\treturn (EPERM);\n+\t\t}\n+\t\tfree(linkname_copy);\n \t\tr = link(linkname, a->name) ? errno : 0;\n \t\t/*\n \t\t * New cpio and pax formats allow hardlink entries\n@@ -2362,115 +2389,228 @@ current_fixup(struct archive_write_disk *a, const char *pathname)\n  * recent paths.\n  */\n /* TODO: Extend this to support symlinks on Windows Vista and later. */\n+\n+/*\n+ * Checks the given path to see if any elements along it are symlinks.  Returns\n+ * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.\n+ */\n static int\n-check_symlinks(struct archive_write_disk *a)\n+check_symlinks_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)\n {\n #if !defined(HAVE_LSTAT)\n \t/* Platform doesn't have lstat, so we can't look for symlinks. */\n \t(void)a; /* UNUSED */\n+\t(void)path; /* UNUSED */\n+\t(void)error_number; /* UNUSED */\n+\t(void)error_string; /* UNUSED */\n+\t(void)flags; /* UNUSED */\n \treturn (ARCHIVE_OK);\n #else\n-\tchar *pn;\n+\tint res = ARCHIVE_OK;\n+\tchar *tail;\n+\tchar *head;\n+\tint last;\n \tchar c;\n \tint r;\n \tstruct stat st;\n+\tint restore_pwd;\n+\n+\t/* Nothing to do here if name is empty */\n+\tif(path[0] == '\\0')\n+\t    return (ARCHIVE_OK);\n \n \t/*\n \t * Guard against symlink tricks.  Reject any archive entry whose\n \t * destination would be altered by a symlink.\n+\t *\n+\t * Walk the filename in chunks separated by '/'.  For each segment:\n+\t *  - if it doesn't exist, continue\n+\t *  - if it's symlink, abort or remove it\n+\t *  - if it's a directory and it's not the last chunk, cd into it\n+\t * As we go:\n+\t *  head points to the current (relative) path\n+\t *  tail points to the temporary \\0 terminating the segment we're currently examining\n+\t *  c holds what used to be in *tail\n+\t *  last is 1 if this is the last tail\n \t */\n-\t/* Whatever we checked last time doesn't need to be re-checked. */\n-\tpn = a->name;\n-\tif (archive_strlen(&(a->path_safe)) > 0) {\n-\t\tchar *p = a->path_safe.s;\n-\t\twhile ((*pn != '\\0') && (*p == *pn))\n-\t\t\t++p, ++pn;\n-\t}\n+\trestore_pwd = open(\".\", O_RDONLY | O_BINARY | O_CLOEXEC);\n+\t__archive_ensure_cloexec_flag(restore_pwd);\n+\tif (restore_pwd < 0)\n+\t\treturn (ARCHIVE_FATAL);\n+\thead = path;\n+\ttail = path;\n+\tlast = 0;\n+\t/* TODO: reintroduce a safe cache here? */\n \t/* Skip the root directory if the path is absolute. */\n-\tif(pn == a->name && pn[0] == '/')\n-\t\t++pn;\n-\tc = pn[0];\n-\t/* Keep going until we've checked the entire name. */\n-\twhile (pn[0] != '\\0' && (pn[0] != '/' || pn[1] != '\\0')) {\n+\tif(tail == path && tail[0] == '/')\n+\t\t++tail;\n+\t/* Keep going until we've checked the entire name.\n+\t * head, tail, path all alias the same string, which is\n+\t * temporarily zeroed at tail, so be careful restoring the\n+\t * stashed (c=tail[0]) for error messages.\n+\t * Exiting the loop with break is okay; continue is not.\n+\t */\n+\twhile (!last) {\n+\t\t/* Skip the separator we just consumed, plus any adjacent ones */\n+\t\twhile (*tail == '/')\n+\t\t    ++tail;\n \t\t/* Skip the next path element. */\n-\t\twhile (*pn != '\\0' && *pn != '/')\n-\t\t\t++pn;\n-\t\tc = pn[0];\n-\t\tpn[0] = '\\0';\n+\t\twhile (*tail != '\\0' && *tail != '/')\n+\t\t\t++tail;\n+\t\t/* is this the last path component? */\n+\t\tlast = (tail[0] == '\\0') || (tail[0] == '/' && tail[1] == '\\0');\n+\t\t/* temporarily truncate the string here */\n+\t\tc = tail[0];\n+\t\ttail[0] = '\\0';\n \t\t/* Check that we haven't hit a symlink. */\n-\t\tr = lstat(a->name, &st);\n+\t\tr = lstat(head, &st);\n \t\tif (r != 0) {\n+\t\t\ttail[0] = c;\n \t\t\t/* We've hit a dir that doesn't exist; stop now. */\n \t\t\tif (errno == ENOENT) {\n \t\t\t\tbreak;\n \t\t\t} else {\n-\t\t\t\t/* Note: This effectively disables deep directory\n+\t\t\t\t/* Treat any other error as fatal - best to be paranoid here\n+\t\t\t\t * Note: This effectively disables deep directory\n \t\t\t\t * support when security checks are enabled.\n \t\t\t\t * Otherwise, very long pathnames that trigger\n \t\t\t\t * an error here could evade the sandbox.\n \t\t\t\t * TODO: We could do better, but it would probably\n \t\t\t\t * require merging the symlink checks with the\n \t\t\t\t * deep-directory editing. */\n-\t\t\t\treturn (ARCHIVE_FAILED);\n+\t\t\t\tif (error_number) *error_number = errno;\n+\t\t\t\tif (error_string)\n+\t\t\t\t\tarchive_string_sprintf(error_string,\n+\t\t\t\t\t\t\t\"Could not stat %s\",\n+\t\t\t\t\t\t\tpath);\n+\t\t\t\tres = ARCHIVE_FAILED;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t} else if (S_ISDIR(st.st_mode)) {\n+\t\t\tif (!last) {\n+\t\t\t\tif (chdir(head) != 0) {\n+\t\t\t\t\ttail[0] = c;\n+\t\t\t\t\tif (error_number) *error_number = errno;\n+\t\t\t\t\tif (error_string)\n+\t\t\t\t\t\tarchive_string_sprintf(error_string,\n+\t\t\t\t\t\t\t\t\"Could not chdir %s\",\n+\t\t\t\t\t\t\t\tpath);\n+\t\t\t\t\tres = (ARCHIVE_FATAL);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\t/* Our view is now from inside this dir: */\n+\t\t\t\thead = tail + 1;\n \t\t\t}\n \t\t} else if (S_ISLNK(st.st_mode)) {\n-\t\t\tif (c == '\\0') {\n+\t\t\tif (last) {\n \t\t\t\t/*\n \t\t\t\t * Last element is symlink; remove it\n \t\t\t\t * so we can overwrite it with the\n \t\t\t\t * item being extracted.\n \t\t\t\t */\n-\t\t\t\tif (unlink(a->name)) {\n-\t\t\t\t\tarchive_set_error(&a->archive, errno,\n-\t\t\t\t\t    \"Could not remove symlink %s\",\n-\t\t\t\t\t    a->name);\n-\t\t\t\t\tpn[0] = c;\n-\t\t\t\t\treturn (ARCHIVE_FAILED);\n+\t\t\t\tif (unlink(head)) {\n+\t\t\t\t\ttail[0] = c;\n+\t\t\t\t\tif (error_number) *error_number = errno;\n+\t\t\t\t\tif (error_string)\n+\t\t\t\t\t\tarchive_string_sprintf(error_string,\n+\t\t\t\t\t\t\t\t\"Could not remove symlink %s\",\n+\t\t\t\t\t\t\t\tpath);\n+\t\t\t\t\tres = ARCHIVE_FAILED;\n+\t\t\t\t\tbreak;\n \t\t\t\t}\n-\t\t\t\ta->pst = NULL;\n \t\t\t\t/*\n \t\t\t\t * Even if we did remove it, a warning\n \t\t\t\t * is in order.  The warning is silly,\n \t\t\t\t * though, if we're just replacing one\n \t\t\t\t * symlink with another symlink.\n \t\t\t\t */\n-\t\t\t\tif (!S_ISLNK(a->mode)) {\n-\t\t\t\t\tarchive_set_error(&a->archive, 0,\n-\t\t\t\t\t    \"Removing symlink %s\",\n-\t\t\t\t\t    a->name);\n+\t\t\t\ttail[0] = c;\n+\t\t\t\t/* FIXME:  not sure how important this is to restore\n+\t\t\t\tif (!S_ISLNK(path)) {\n+\t\t\t\t\tif (error_number) *error_number = 0;\n+\t\t\t\t\tif (error_string)\n+\t\t\t\t\t\tarchive_string_sprintf(error_string,\n+\t\t\t\t\t\t\t\t\"Removing symlink %s\",\n+\t\t\t\t\t\t\t\tpath);\n \t\t\t\t}\n+\t\t\t\t*/\n \t\t\t\t/* Symlink gone.  No more problem! */\n-\t\t\t\tpn[0] = c;\n-\t\t\t\treturn (0);\n-\t\t\t} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {\n+\t\t\t\tres = ARCHIVE_OK;\n+\t\t\t\tbreak;\n+\t\t\t} else if (flags & ARCHIVE_EXTRACT_UNLINK) {\n \t\t\t\t/* User asked us to remove problems. */\n-\t\t\t\tif (unlink(a->name) != 0) {\n-\t\t\t\t\tarchive_set_error(&a->archive, 0,\n-\t\t\t\t\t    \"Cannot remove intervening symlink %s\",\n-\t\t\t\t\t    a->name);\n-\t\t\t\t\tpn[0] = c;\n-\t\t\t\t\treturn (ARCHIVE_FAILED);\n+\t\t\t\tif (unlink(head) != 0) {\n+\t\t\t\t\ttail[0] = c;\n+\t\t\t\t\tif (error_number) *error_number = 0;\n+\t\t\t\t\tif (error_string)\n+\t\t\t\t\t\tarchive_string_sprintf(error_string,\n+\t\t\t\t\t\t\t\t\"Cannot remove intervening symlink %s\",\n+\t\t\t\t\t\t\t\tpath);\n+\t\t\t\t\tres = ARCHIVE_FAILED;\n+\t\t\t\t\tbreak;\n \t\t\t\t}\n-\t\t\t\ta->pst = NULL;\n+\t\t\t\ttail[0] = c;\n \t\t\t} else {\n-\t\t\t\tarchive_set_error(&a->archive, 0,\n-\t\t\t\t    \"Cannot extract through symlink %s\",\n-\t\t\t\t    a->name);\n-\t\t\t\tpn[0] = c;\n-\t\t\t\treturn (ARCHIVE_FAILED);\n+\t\t\t\ttail[0] = c;\n+\t\t\t\tif (error_number) *error_number = 0;\n+\t\t\t\tif (error_string)\n+\t\t\t\t\tarchive_string_sprintf(error_string,\n+\t\t\t\t\t\t\t\"Cannot extract through symlink %s\",\n+\t\t\t\t\t\t\tpath);\n+\t\t\t\tres = ARCHIVE_FAILED;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\t\tpn[0] = c;\n-\t\tif (pn[0] != '\\0')\n-\t\t\tpn++; /* Advance to the next segment. */\n+\t\t/* be sure to always maintain this */\n+\t\ttail[0] = c;\n+\t\tif (tail[0] != '\\0')\n+\t\t\ttail++; /* Advance to the next segment. */\n \t}\n-\tpn[0] = c;\n-\t/* We've checked and/or cleaned the whole path, so remember it. */\n-\tarchive_strcpy(&a->path_safe, a->name);\n-\treturn (ARCHIVE_OK);\n+\t/* Catches loop exits via break */\n+\ttail[0] = c;\n+#ifdef HAVE_FCHDIR\n+\t/* If we changed directory above, restore it here. */\n+\tif (restore_pwd >= 0) {\n+\t\tr = fchdir(restore_pwd);\n+\t\tif (r != 0) {\n+\t\t\tif(error_number) *error_number = errno;\n+\t\t\tif(error_string)\n+\t\t\t\tarchive_string_sprintf(error_string,\n+\t\t\t\t\t\t\"chdir() failure\");\n+\t\t}\n+\t\tclose(restore_pwd);\n+\t\trestore_pwd = -1;\n+\t\tif (r != 0) {\n+\t\t\tres = (ARCHIVE_FATAL);\n+\t\t}\n+\t}\n+#endif\n+\t/* TODO: reintroduce a safe cache here? */\n+\treturn res;\n #endif\n }\n \n+/*\n+ * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise\n+ * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}\n+ */\n+static int\n+check_symlinks(struct archive_write_disk *a)\n+{\n+\tstruct archive_string error_string;\n+\tint error_number;\n+\tint rc;\n+\tarchive_string_init(&error_string);\n+\trc = check_symlinks_fsobj(a->name, &error_number, &error_string, a->flags);\n+\tif (rc != ARCHIVE_OK) {\n+\t\tarchive_set_error(&a->archive, error_number, \"%s\", error_string.s);\n+\t}\n+\tarchive_string_free(&error_string);\n+\ta->pst = NULL;\t/* to be safe */\n+\treturn rc;\n+}\n+\n+\n #if defined(__CYGWIN__)\n /*\n  * 1. Convert a path separator from '\\' to '/' .\n@@ -2544,15 +2684,17 @@ cleanup_pathname_win(struct archive_write_disk *a)\n  * is set) if the path is absolute.\n  */\n static int\n-cleanup_pathname(struct archive_write_disk *a)\n+cleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)\n {\n \tchar *dest, *src;\n \tchar separator = '\\0';\n \n-\tdest = src = a->name;\n+\tdest = src = path;\n \tif (*src == '\\0') {\n-\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n-\t\t    \"Invalid empty pathname\");\n+\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n+\t\tif (error_string)\n+\t\t    archive_string_sprintf(error_string,\n+\t\t\t    \"Invalid empty pathname\");\n \t\treturn (ARCHIVE_FAILED);\n \t}\n \n@@ -2561,9 +2703,11 @@ cleanup_pathname(struct archive_write_disk *a)\n #endif\n \t/* Skip leading '/'. */\n \tif (*src == '/') {\n-\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n-\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n-\t\t\t                  \"Path is absolute\");\n+\t\tif (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n+\t\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n+\t\t\tif (error_string)\n+\t\t\t    archive_string_sprintf(error_string,\n+\t\t\t\t    \"Path is absolute\");\n \t\t\treturn (ARCHIVE_FAILED);\n \t\t}\n \n@@ -2590,10 +2734,11 @@ cleanup_pathname(struct archive_write_disk *a)\n \t\t\t} else if (src[1] == '.') {\n \t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n \t\t\t\t\t/* Conditionally warn about '..' */\n-\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n-\t\t\t\t\t\tarchive_set_error(&a->archive,\n-\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n-\t\t\t\t\t\t    \"Path contains '..'\");\n+\t\t\t\t\tif (flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n+\t\t\t\t\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n+\t\t\t\t\t\tif (error_string)\n+\t\t\t\t\t\t    archive_string_sprintf(error_string,\n+\t\t\t\t\t\t\t    \"Path contains '..'\");\n \t\t\t\t\t\treturn (ARCHIVE_FAILED);\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -2624,7 +2769,7 @@ cleanup_pathname(struct archive_write_disk *a)\n \t * We've just copied zero or more path elements, not including the\n \t * final '/'.\n \t */\n-\tif (dest == a->name) {\n+\tif (dest == path) {\n \t\t/*\n \t\t * Nothing got copied.  The path must have been something\n \t\t * like '.' or '/' or './' or '/././././/./'.\n@@ -2639,6 +2784,21 @@ cleanup_pathname(struct archive_write_disk *a)\n \treturn (ARCHIVE_OK);\n }\n \n+static int\n+cleanup_pathname(struct archive_write_disk *a)\n+{\n+\tstruct archive_string error_string;\n+\tint error_number;\n+\tint rc;\n+\tarchive_string_init(&error_string);\n+\trc = cleanup_pathname_fsobj(a->name, &error_number, &error_string, a->flags);\n+\tif (rc != ARCHIVE_OK) {\n+\t\tarchive_set_error(&a->archive, error_number, \"%s\", error_string.s);\n+\t}\n+\tarchive_string_free(&error_string);\n+\treturn rc;\n+}\n+\n /*\n  * Create the parent directory of the specified path, assuming path\n  * is already in mutable storage."
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "42565b88b5cc7441239269902a9d1735fd9ca0e2",
            "date": "2025-01-07T00:44:40Z",
            "author_login": "gperciva"
          },
          {
            "sha": "743bbe97693f648e05dc428a770fefed5f1a7d3f",
            "date": "2025-01-01T23:36:17Z",
            "author_login": "mostynb"
          },
          {
            "sha": "7708713b634eb2f72ffe484b565a5a87f58e8cb3",
            "date": "2025-01-01T23:30:37Z",
            "author_login": "mostynb"
          },
          {
            "sha": "a186d9662b4e3bc2e0f39d3248f9c1244c4346cb",
            "date": "2025-01-01T18:56:51Z",
            "author_login": "thesamesam"
          },
          {
            "sha": "14b8803c40d36fe1f0c8b3bb2846d865e3adcfce",
            "date": "2025-01-01T16:31:35Z",
            "author_login": "CookiePLMonster"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-19",
    "description": "The sandboxing code in libarchive 3.2.0 and earlier mishandles hardlink archive entries of non-zero data size, which might allow remote attackers to write to arbitrary files via a crafted archive file.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2016-09-21T14:25:13.457",
    "last_modified": "2024-11-21T02:54:16.420",
    "fix_date": "2016-09-11T20:21:57Z"
  },
  "references": [
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-1844.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-1850.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/08/09/2",
      "source": "secalert@redhat.com",
      "tags": [
        "Exploit",
        "Technical Description"
      ]
    },
    {
      "url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinjul2016-3090544.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/93165",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2016:1852",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2016:1853",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1362601",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://gist.github.com/anonymous/e48209b03f1dd9625a992717e7b89c4f",
      "source": "secalert@redhat.com",
      "tags": [
        "Exploit",
        "Technical Description"
      ]
    },
    {
      "url": "https://github.com/libarchive/libarchive/commit/dfd6b54ce33960e420fb206d8872fb759b577ad9",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/libarchive/libarchive/issues/746",
      "source": "secalert@redhat.com",
      "tags": [
        "Exploit",
        "Patch"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201701-03",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-1844.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2016-1850.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/08/09/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Technical Description"
      ]
    },
    {
      "url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinjul2016-3090544.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/93165",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2016:1852",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2016:1853",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1362601",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://gist.github.com/anonymous/e48209b03f1dd9625a992717e7b89c4f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Technical Description"
      ]
    },
    {
      "url": "https://github.com/libarchive/libarchive/commit/dfd6b54ce33960e420fb206d8872fb759b577ad9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/libarchive/libarchive/issues/746",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201701-03",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:46.792718",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "libarchive",
    "owner": "libarchive",
    "created_at": "2012-01-19T18:16:02Z",
    "updated_at": "2025-01-13T10:21:51Z",
    "pushed_at": "2025-01-07T00:44:40Z",
    "size": 27999,
    "stars": 3098,
    "forks": 776,
    "open_issues": 485,
    "watchers": 3098,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master",
      "patch/3.5",
      "patch/3.7"
    ],
    "languages": {
      "C": 7080834,
      "Roff": 378587,
      "CMake": 140517,
      "M4": 123454,
      "Makefile": 75578,
      "Shell": 52106,
      "C++": 28869,
      "Batchfile": 12189,
      "Dockerfile": 792
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:03:25.247306"
  }
}