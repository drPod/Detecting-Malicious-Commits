{
  "cve_id": "CVE-2016-6652",
  "github_data": {
    "repository": "spring-projects/spring-data-jpa",
    "fix_commit": "b8e7fe",
    "related_commits": [
      "b8e7fe",
      "b8e7fe"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "b8e7fe",
      "commit_date": "2016-09-06T11:34:08Z",
      "author": {
        "login": "christophstrobl",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "DATAJPA-965 - Fix potential blind SQL injection in Sort when used in combination with @Query.",
        "length": 856,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 497,
        "additions": 491,
        "deletions": 6
      },
      "files": [
        {
          "filename": "src/main/asciidoc/jpa.adoc",
          "status": "modified",
          "additions": 36,
          "deletions": 0,
          "patch": "@@ -303,6 +303,42 @@ public interface UserRepository extends JpaRepository<User, Long> {\n \n This also works with named native queries by adding the suffix `.count` to a copy of your query. Be aware that you probably must register a result set mapping for your count query, though.\n \n+[[jpa.query-methods.sorting]]\n+=== Using Sort\n+\n+Sorting can be done be either providing a `PageRequest` or using `Sort` directly. The properties actually used within the `Order` instances of `Sort` need to match to your domain model, which means they need to resolve to either a property or an alias used within the query. The JPQL defines this as a _state_field_path_expression_.\n+\n+[NOTE]\n+====\n+Using any non referenceable path expression leads to an Exception.\n+====\n+\n+Using `Sort` together with <<jpa.query-methods.at-query, @Query>> however allows you to sneak in non path checked `Order` instances containing _functions_ within the `ORDER BY` clause. This is possible because the `Order` is just appended to the given query string. By default we will reject any `Order` instance containing function calls, but you can use `JpaSort.unsafe` to add potentially unsafe ordering.\n+\n+.Using Sort and JpaSort\n+====\n+[source, java]\n+----\n+public interface UserRepository extends JpaRepository<User, Long> {\n+\n+  @Query(\"select u from User u where u.lastname like ?1%\")\n+  List<User> findByAndSort(String lastname, Sort sort);\n+\n+  @Query(\"select u.id, LENGTH(u.firstname) as fn_len from User u where u.lastname like ?1%\")\n+  List<Object[]> findByAsArrayAndSort(String lastname, Sort sort);\n+}\n+\n+repo.findByAndSort(\"lannister\", new Sort(\"firstname\"));               <1>\n+repo.findByAndSort(\"stark\", new Sort(\"LENGTH(firstname)\"));           <2>\n+repo.findByAndSort(\"targaryen\", JpaSort.unsafe(\"LENGTH(firstname)\")); <3>\n+repo.findByAsArrayAndSort(\"bolton\", new Sort(\"fn_len\"));              <4>\n+----\n+<1> Valid `Sort` expression pointing to property in domain model.\n+<2> Invalid `Sort` containing function call. Thows Exception.\n+<3> Valid `Sort` containing explicitly _unsafe_ `Order`.\n+<4> Valid `Sort` expression pointing to aliased function.\n+====\n+\n [[jpa.named-parameters]]\n === Using named parameters\n "
        },
        {
          "filename": "src/main/java/org/springframework/data/jpa/domain/JpaSort.java",
          "status": "modified",
          "additions": 202,
          "deletions": 1,
          "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2013-2015 the original author or authors.\n+ * Copyright 2013-2016 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -32,6 +32,7 @@\n  * \n  * @author Thomas Darimont\n  * @author Oliver Gierke\n+ * @author Christoph Strobl\n  */\n public class JpaSort extends Sort {\n \n@@ -83,6 +84,10 @@ private JpaSort(List<Order> orders, Direction direction, List<Path<?, ?>> paths)\n \t\tsuper(combine(orders, direction, paths));\n \t}\n \n+\tprivate JpaSort(List<Order> orders) {\n+\t\tsuper(orders);\n+\t}\n+\n \t/**\n \t * Returns a new {@link JpaSort} with the given sorting criteria added to the current one.\n \t * \n@@ -117,6 +122,30 @@ public JpaSort and(Direction direction, Path<?, ?>... paths) {\n \t\treturn new JpaSort(existing, direction, Arrays.asList(paths));\n \t}\n \n+\t/**\n+\t * Returns a new {@link JpaSort} with the given sorting criteria added to the current one.\n+\t *\n+\t * @param direction can be {@literal null}.\n+\t * @param properties must not be {@literal null} or empty.\n+\t * @return\n+\t */\n+\tpublic JpaSort andUnsafe(Direction direction, String... properties) {\n+\n+\t\tAssert.notEmpty(properties, \"Properties must not be null!\");\n+\n+\t\tList<Order> orders = new ArrayList<Order>();\n+\n+\t\tfor (Order order : this) {\n+\t\t\torders.add(order);\n+\t\t}\n+\n+\t\tfor (String property : properties) {\n+\t\t\torders.add(new JpaOrder(direction, property));\n+\t\t}\n+\n+\t\treturn new JpaSort(orders, direction, Collections.<Path<?, ?>> emptyList());\n+\t}\n+\n \t/**\n \t * Turns the given {@link Attribute}s into {@link Path}s.\n \t * \n@@ -174,6 +203,51 @@ public static <A extends Attribute<T, S>, T, S> Path<T, S> path(A attribute) {\n \t\treturn new Path<T, S>(Arrays.asList(attribute));\n \t}\n \n+\t/**\n+\t * Creates new unsafe {@link JpaSort} based on given properties.\n+\t *\n+\t * @param properties must not be {@literal null} or empty.\n+\t * @return\n+\t */\n+\tpublic static JpaSort unsafe(String... properties) {\n+\t\treturn unsafe(Sort.DEFAULT_DIRECTION, properties);\n+\t}\n+\n+\t/**\n+\t * Creates new unsafe {@link JpaSort} based on given {@link Direction} and properties.\n+\t *\n+\t * @param direction must not be {@literal null}.\n+\t * @param properties must not be {@literal null} or empty.\n+\t * @return\n+\t */\n+\tpublic static JpaSort unsafe(Direction direction, String... properties) {\n+\n+\t\tAssert.notNull(direction, \"Direction must not be null!\");\n+\t\tAssert.notEmpty(properties, \"Properties must not be empty!\");\n+\t\tAssert.noNullElements(properties, \"Properties must not contain null values!\");\n+\n+\t\treturn unsafe(direction, Arrays.asList(properties));\n+\t}\n+\n+\t/**\n+\t * Creates new unsafe {@link JpaSort} based on given {@link Direction} and properties.\n+\t *\n+\t * @param direction must not be {@literal null}.\n+\t * @param properties must not be {@literal null} or empty.\n+\t * @return\n+\t */\n+\tpublic static JpaSort unsafe(Direction direction, List<String> properties) {\n+\n+\t\tAssert.notEmpty(properties, \"Properties must not be empty!\");\n+\n+\t\tList<Order> orders = new ArrayList<Order>();\n+\t\tfor (String property : properties) {\n+\t\t\torders.add(new JpaOrder(direction, property));\n+\t\t}\n+\n+\t\treturn new JpaSort(orders);\n+\t}\n+\n \t/**\n \t * Value object to abstract a collection of {@link Attribute}s.\n \t * \n@@ -233,4 +307,131 @@ public String toString() {\n \t\t\treturn builder.length() == 0 ? \"\" : builder.substring(0, builder.lastIndexOf(\".\"));\n \t\t}\n \t}\n+\n+\t/**\n+\t * @author Christoph Strobl\n+\t */\n+\tpublic static class JpaOrder extends Order {\n+\n+\t\tprivate final boolean unsafe;\n+\t\tprivate final boolean ignoreCase;\n+\n+\t\t/**\n+\t\t * Creates a new {@link JpaOrder} instance. if order is {@literal null} then order defaults to\n+\t\t * {@link Sort#DEFAULT_DIRECTION}\n+\t\t *\n+\t\t * @param direction can be {@literal null}, will default to {@link Sort#DEFAULT_DIRECTION}.\n+\t\t * @param property must not be {@literal null}.\n+\t\t */\n+\t\tprivate JpaOrder(Direction direction, String property) {\n+\t\t\tthis(direction, property, NullHandling.NATIVE);\n+\t\t}\n+\n+\t\t/**\n+\t\t * Creates a new {@link Order} instance. if order is {@literal null} then order defaults to\n+\t\t * {@link Sort#DEFAULT_DIRECTION}.\n+\t\t *\n+\t\t * @param direction can be {@literal null}, will default to {@link Sort#DEFAULT_DIRECTION}.\n+\t\t * @param property must not be {@literal null}.\n+\t\t * @param nullHandlingHint can be {@literal null}, will default to {@link NullHandling#NATIVE}.\n+\t\t */\n+\t\tprivate JpaOrder(Direction direction, String property, NullHandling nullHandlingHint) {\n+\t\t\tthis(direction, property, nullHandlingHint, false, true);\n+\t\t}\n+\n+\t\tprivate JpaOrder(Direction direction, String property, NullHandling nullHandling, boolean ignoreCase,\n+\t\t\t\tboolean unsafe) {\n+\n+\t\t\tsuper(direction, property, nullHandling);\n+\t\t\tthis.ignoreCase = ignoreCase;\n+\t\t\tthis.unsafe = unsafe;\n+\t\t}\n+\n+\t\t/*\n+\t\t * (non-Javadoc)\n+\t\t * @see org.springframework.data.domain.Sort.Order#with(org.springframework.data.domain.Sort.Direction)\n+\t\t */\n+\t\t@Override\n+\t\tpublic JpaOrder with(Direction order) {\n+\t\t\treturn new JpaOrder(order, getProperty(), getNullHandling(), isIgnoreCase(), this.unsafe);\n+\t\t}\n+\n+\t\t/*\n+\t\t * (non-Javadoc)\n+\t\t * @see org.springframework.data.domain.Sort.Order#with(org.springframework.data.domain.Sort.NullHandling)\n+\t\t */\n+\t\t@Override\n+\t\tpublic JpaOrder with(NullHandling nullHandling) {\n+\t\t\treturn new JpaOrder(getDirection(), getProperty(), nullHandling, isIgnoreCase(), this.unsafe);\n+\t\t}\n+\n+\t\t/*\n+\t\t * (non-Javadoc)\n+\t\t * @see org.springframework.data.domain.Sort.Order#nullsFirst()\n+\t\t */\n+\t\t@Override\n+\t\tpublic JpaOrder nullsFirst() {\n+\t\t\treturn with(NullHandling.NULLS_FIRST);\n+\t\t}\n+\n+\t\t/*\n+\t\t * (non-Javadoc)\n+\t\t * @see org.springframework.data.domain.Sort.Order#nullsLast()\n+\t\t */\n+\t\t@Override\n+\t\tpublic JpaOrder nullsLast() {\n+\t\t\treturn with(NullHandling.NULLS_LAST);\n+\t\t}\n+\n+\t\t/*\n+\t\t * (non-Javadoc)\n+\t\t * @see org.springframework.data.domain.Sort.Order#nullsNative()\n+\t\t */\n+\t\tpublic JpaOrder nullsNative() {\n+\t\t\treturn with(NullHandling.NATIVE);\n+\t\t}\n+\n+\t\t/**\n+\t\t * Creates new {@link Sort} with potentially unsafe {@link Order} instances.\n+\t\t *\n+\t\t * @param properties must not be {@literal null}.\n+\t\t * @return\n+\t\t */\n+\t\tpublic Sort withUnsafe(String... properties) {\n+\n+\t\t\tAssert.notEmpty(properties, \"Properties must not be empty!\");\n+\t\t\tAssert.noNullElements(properties, \"Properties must not contain null values!\");\n+\n+\t\t\tList<Order> orders = new ArrayList<Order>();\n+\t\t\tfor (String property : properties) {\n+\t\t\t\torders.add(new JpaOrder(getDirection(), property, getNullHandling(), isIgnoreCase(), this.unsafe));\n+\t\t\t}\n+\t\t\treturn new Sort(orders);\n+\t\t}\n+\n+\t\t/*\n+\t\t * (non-Javadoc)\n+\t\t * @see org.springframework.data.domain.Sort.Order#ignoreCase()\n+\t\t */\n+\t\t@Override\n+\t\tpublic JpaOrder ignoreCase() {\n+\t\t\treturn new JpaOrder(getDirection(), getProperty(), getNullHandling(), true, this.unsafe);\n+\t\t}\n+\n+\t\t/*\n+\t\t * (non-Javadoc)\n+\t\t * @see org.springframework.data.domain.Sort.Order#isIgnoreCase()\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean isIgnoreCase() {\n+\t\t\treturn super.isIgnoreCase() || ignoreCase;\n+\t\t}\n+\n+\t\t/**\n+\t\t * @return true if {@link JpaOrder} created {@link #withUnsafe(String...)}.\n+\t\t */\n+\t\tpublic boolean isUnsafe() {\n+\t\t\treturn unsafe;\n+\t\t}\n+\t}\n }"
        },
        {
          "filename": "src/main/java/org/springframework/data/jpa/repository/query/QueryUtils.java",
          "status": "modified",
          "additions": 65,
          "deletions": 2,
          "patch": "@@ -53,8 +53,10 @@\n import javax.persistence.metamodel.PluralAttribute;\n \n import org.springframework.core.annotation.AnnotationUtils;\n+import org.springframework.dao.InvalidDataAccessApiUsageException;\n import org.springframework.data.domain.Sort;\n import org.springframework.data.domain.Sort.Order;\n+import org.springframework.data.jpa.domain.JpaSort.JpaOrder;\n import org.springframework.data.mapping.PropertyPath;\n import org.springframework.util.Assert;\n import org.springframework.util.StringUtils;\n@@ -66,6 +68,7 @@\n  * @author Kevin Raymond\n  * @author Thomas Darimont\n  * @author Komi Innocent\n+ * @author Christoph Strobl\n  */\n public abstract class QueryUtils {\n \n@@ -102,6 +105,10 @@ public abstract class QueryUtils {\n \tprivate static final int QUERY_JOIN_ALIAS_GROUP_INDEX = 2;\n \tprivate static final int VARIABLE_NAME_GROUP_INDEX = 4;\n \n+\tprivate static final Pattern PUNCTATION_PATTERN = Pattern.compile(\".*((?![\\\\._])[\\\\p{Punct}|\\\\s])\");\n+\tprivate static final String FUNCTION_ALIAS_GROUP_NAME = \"alias\";\n+\tprivate static final Pattern FUNCTION_PATTERN;\n+\n \tstatic {\n \n \t\tStringBuilder builder = new StringBuilder();\n@@ -145,6 +152,13 @@ public abstract class QueryUtils {\n \t\tbuilder.append(\"\\\\)\");\n \n \t\tCONSTRUCTOR_EXPRESSION = compile(builder.toString(), CASE_INSENSITIVE + DOTALL);\n+\n+\t\tbuilder = new StringBuilder();\n+\t\tbuilder.append(\"\\\\s+\"); // at least one space\n+\t\tbuilder.append(\"\\\\w+\\\\([0-9a-zA-z\\\\._,\\\\s']+\\\\)\"); // any function call including parameters within the brackets\n+\t\tbuilder.append(\"\\\\s+[as|AS]+\\\\s+(?<\" + FUNCTION_ALIAS_GROUP_NAME + \">[\\\\w\\\\.]+)\"); // the potential alias\n+\n+\t\tFUNCTION_PATTERN = compile(builder.toString());\n \t}\n \n \t/**\n@@ -227,9 +241,10 @@ public static String applySorting(String query, Sort sort, String alias) {\n \t\t}\n \n \t\tSet<String> aliases = getOuterJoinAliases(query);\n+\t\tSet<String> functionAliases = getFunctionAliases(query);\n \n \t\tfor (Order order : sort) {\n-\t\t\tbuilder.append(getOrderClause(aliases, alias, order)).append(\", \");\n+\t\t\tbuilder.append(getOrderClause(aliases, functionAliases, alias, order)).append(\", \");\n \t\t}\n \n \t\tbuilder.delete(builder.length() - 2, builder.length());\n@@ -246,9 +261,16 @@ public static String applySorting(String query, Sort sort, String alias) {\n \t * @param order the order object to build the clause for.\n \t * @return\n \t */\n-\tprivate static String getOrderClause(Set<String> joinAliases, String alias, Order order) {\n+\tprivate static String getOrderClause(Set<String> joinAliases, Set<String> functionAlias, String alias, Order order) {\n \n \t\tString property = order.getProperty();\n+\n+\t\tcheckSortExpression(order);\n+\n+\t\tif (functionAlias.contains(property)) {\n+\t\t\treturn String.format(\"%s %s\", property, toJpaDirection(order));\n+\t\t}\n+\n \t\tboolean qualifyReference = !property.contains(\"(\"); // ( indicates a function\n \n \t\tfor (String joinAlias : joinAliases) {\n@@ -287,6 +309,28 @@ static Set<String> getOuterJoinAliases(String query) {\n \t\treturn result;\n \t}\n \n+\t/**\n+\t * Returns the aliases used for aggregate functions like {@code SUM, COUNT, ...}.\n+\t *\n+\t * @param query\n+\t * @return\n+\t */\n+\tstatic Set<String> getFunctionAliases(String query) {\n+\n+\t\tSet<String> result = new HashSet<String>();\n+\t\tMatcher matcher = FUNCTION_PATTERN.matcher(query);\n+\n+\t\twhile (matcher.find()) {\n+\n+\t\t\tString alias = matcher.group(FUNCTION_ALIAS_GROUP_NAME);\n+\t\t\tif (StringUtils.hasText(alias)) {\n+\t\t\t\tresult.add(alias);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn result;\n+\t}\n+\n \tprivate static String toJpaDirection(Order order) {\n \t\treturn order.getDirection().name().toLowerCase(Locale.US);\n \t}\n@@ -617,4 +661,23 @@ private static boolean isAlreadyFetched(From<?, ?> from, String attribute) {\n \n \t\treturn false;\n \t}\n+\n+\t/**\n+\t * Check any given {@link JpaOrder#isUnsafe()} order for presence of at least one property offending the\n+\t * {@link #PUNCTATION_PATTERN} and throw an {@link Exception} indicating potential unsafe order by expression.\n+\t *\n+\t * @param order\n+\t */\n+\tprivate static void checkSortExpression(Order order) {\n+\n+\t\tif (order instanceof JpaOrder && ((JpaOrder) order).isUnsafe()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (PUNCTATION_PATTERN.matcher(order.getProperty()).find()) {\n+\t\t\tthrow new InvalidDataAccessApiUsageException(String\n+\t\t\t\t\t.format(\"Sort expression '%s' must not contain functions or expressions. Please use JpaSort.unsafe.\", order));\n+\t\t}\n+\t}\n+\n }"
        },
        {
          "filename": "src/test/java/org/springframework/data/jpa/domain/JpaSortTests.java",
          "status": "modified",
          "additions": 55,
          "deletions": 1,
          "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2013-2015 the original author or authors.\n+ * Copyright 2013-2016 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -29,6 +29,7 @@\n import org.springframework.data.domain.Sort;\n import org.springframework.data.domain.Sort.Direction;\n import org.springframework.data.domain.Sort.Order;\n+import org.springframework.data.jpa.domain.JpaSort.JpaOrder;\n import org.springframework.data.jpa.domain.JpaSort.Path;\n import org.springframework.data.jpa.domain.sample.Address_;\n import org.springframework.data.jpa.domain.sample.MailMessage_;\n@@ -47,6 +48,7 @@\n  * @see DATAJPA-12\n  * @author Thomas Darimont\n  * @author Oliver Gierke\n+ * @author Christoph Strobl\n  */\n @RunWith(SpringJUnit4ClassRunner.class)\n @ContextConfiguration(\"classpath:infrastructure.xml\")\n@@ -173,4 +175,56 @@ public void buildsUpPathForPluralAttributesCorrectly() {\n \t\tassertThat(new JpaSort(path(User_.colleagues).dot(User_.roles).dot(Role_.name)), //\n \t\t\t\thasItem(new Order(ASC, \"colleagues.roles.name\")));\n \t}\n+\n+\t/**\n+\t * @see DATAJPA-???\n+\t */\n+\t@Test\n+\tpublic void createsUnsafeSortCorrectly() {\n+\n+\t\tJpaSort sort = JpaSort.unsafe(DESC, \"foo.bar\");\n+\n+\t\tassertThat(sort, hasItem(new Order(DESC, \"foo.bar\")));\n+\t\tassertThat(sort.getOrderFor(\"foo.bar\"), is(instanceOf(JpaOrder.class)));\n+\t}\n+\n+\t/**\n+\t * @see DATAJPA-???\n+\t */\n+\t@Test\n+\tpublic void createsUnsafeSortWithMultiplePropertiesCorrectly() {\n+\n+\t\tJpaSort sort = JpaSort.unsafe(DESC, \"foo.bar\", \"spring.data\");\n+\n+\t\tassertThat(sort, hasItems(new Order(DESC, \"foo.bar\"), new Order(DESC, \"spring.data\")));\n+\t\tassertThat(sort.getOrderFor(\"foo.bar\"), is(instanceOf(JpaOrder.class)));\n+\t\tassertThat(sort.getOrderFor(\"spring.data\"), is(instanceOf(JpaOrder.class)));\n+\t}\n+\n+\t/**\n+\t * @see DATAJPA-???\n+\t */\n+\t@Test\n+\tpublic void combinesSafeAndUnsafeSortCorrectly() {\n+\n+\t\tJpaSort sort = new JpaSort(path(User_.colleagues).dot(User_.roles).dot(Role_.name)).andUnsafe(DESC, \"foo.bar\");\n+\n+\t\tassertThat(sort, hasItems(new Order(ASC, \"colleagues.roles.name\"), new Order(DESC, \"foo.bar\")));\n+\t\tassertThat(sort.getOrderFor(\"colleagues.roles.name\"), is(not(instanceOf(JpaOrder.class))));\n+\t\tassertThat(sort.getOrderFor(\"foo.bar\"), is(instanceOf(JpaOrder.class)));\n+\t}\n+\n+\t/**\n+\t * @see DATAJPA-???\n+\t */\n+\t@Test\n+\tpublic void combinesUnsafeAndSafeSortCorrectly() {\n+\n+\t\tSort sort = JpaSort.unsafe(DESC, \"foo.bar\").and(ASC, path(User_.colleagues).dot(User_.roles).dot(Role_.name));\n+\n+\t\tassertThat(sort, hasItems(new Order(ASC, \"colleagues.roles.name\"), new Order(DESC, \"foo.bar\")));\n+\t\tassertThat(sort.getOrderFor(\"colleagues.roles.name\"), is(not(instanceOf(JpaOrder.class))));\n+\t\tassertThat(sort.getOrderFor(\"foo.bar\"), is(instanceOf(JpaOrder.class)));\n+\t}\n+\n }"
        },
        {
          "filename": "src/test/java/org/springframework/data/jpa/repository/query/QueryUtilsUnitTests.java",
          "status": "modified",
          "additions": 133,
          "deletions": 2,
          "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2008-2015 the original author or authors.\n+ * Copyright 2008-2016 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,14 +23,17 @@\n \n import org.hamcrest.Matcher;\n import org.junit.Test;\n+import org.springframework.dao.InvalidDataAccessApiUsageException;\n import org.springframework.data.domain.Sort;\n+import org.springframework.data.jpa.domain.JpaSort;\n \n /**\n  * Unit test for {@link QueryUtils}.\n  * \n  * @author Oliver Gierke\n  * @author Thomas Darimont\n  * @author Komi Innocent\n+ * @author Christoph Strobl\n  */\n public class QueryUtilsUnitTests {\n \n@@ -230,7 +233,7 @@ public void projectsCOuntQueriesForQueriesWithSubselects() {\n \t/**\n \t * @see DATAJPA-148\n \t */\n-\t@Test\n+\t@Test(expected = InvalidDataAccessApiUsageException.class)\n \tpublic void doesNotPrefixSortsIfFunction() {\n \n \t\tSort sort = new Sort(\"sum(foo)\");\n@@ -361,6 +364,134 @@ public void doesNotQualifySortIfNoAliasDetected() {\n \t\t\t\tendsWith(\"order by firstname asc\"));\n \t}\n \n+\t/**\n+\t * @see DATAJPA-???\n+\t */\n+\t@Test(expected = InvalidDataAccessApiUsageException.class)\n+\tpublic void doesNotAllowWhitespaceInSort() {\n+\n+\t\tSort sort = new Sort(\"case when foo then bar\");\n+\t\tapplySorting(\"select p from Person p\", sort, \"p\");\n+\t}\n+\n+\t/**\n+\t * @see DATAJPA-???\n+\t */\n+\t@Test\n+\tpublic void doesNotPrefixUnsageJpaSortFunctionCalls() {\n+\n+\t\tJpaSort sort = JpaSort.unsafe(\"sum(foo)\");\n+\t\tassertThat(applySorting(\"select p from Person p\", sort, \"p\"), endsWith(\"order by sum(foo) asc\"));\n+\t}\n+\n+\t/**\n+\t * @see DATAJPA-???\n+\t */\n+\t@Test\n+\tpublic void doesNotPrefixMultipleAliasedFunctionCalls() {\n+\n+\t\tString query = \"SELECT AVG(m.price) AS avgPrice, SUM(m.stocks) AS sumStocks FROM Magazine m\";\n+\t\tSort sort = new Sort(\"avgPrice\", \"sumStocks\");\n+\n+\t\tassertThat(applySorting(query, sort, \"m\"), endsWith(\"order by avgPrice asc, sumStocks asc\"));\n+\t}\n+\n+\t/**\n+\t * @see DATAJPA-???\n+\t */\n+\t@Test\n+\tpublic void doesNotPrefixSingleAliasedFunctionCalls() {\n+\n+\t\tString query = \"SELECT AVG(m.price) AS avgPrice FROM Magazine m\";\n+\t\tSort sort = new Sort(\"avgPrice\");\n+\n+\t\tassertThat(applySorting(query, sort, \"m\"), endsWith(\"order by avgPrice asc\"));\n+\t}\n+\n+\t/**\n+\t * @see DATAJPA-???\n+\t */\n+\t@Test\n+\tpublic void prefixesSingleNonAliasedFunctionCallRelatedSortProperty() {\n+\n+\t\tString query = \"SELECT AVG(m.price) AS avgPrice FROM Magazine m\";\n+\t\tSort sort = new Sort(\"someOtherProperty\");\n+\n+\t\tassertThat(applySorting(query, sort, \"m\"), endsWith(\"order by m.someOtherProperty asc\"));\n+\t}\n+\n+\t/**\n+\t * @see DATAJPA-???\n+\t */\n+\t@Test\n+\tpublic void prefixesNonAliasedFunctionCallRelatedSortPropertyWhenSelectClauseContainesAliasedFunctionForDifferentProperty() {\n+\n+\t\tString query = \"SELECT m.name, AVG(m.price) AS avgPrice FROM Magazine m\";\n+\t\tSort sort = new Sort(\"name\", \"avgPrice\");\n+\n+\t\tassertThat(applySorting(query, sort, \"m\"), endsWith(\"order by m.name asc, avgPrice asc\"));\n+\t}\n+\n+\t/**\n+\t * @see DATAJPA-???\n+\t */\n+\t@Test\n+\tpublic void doesNotPrefixAliasedFunctionCallNameWithMultipleNumericParameters() {\n+\n+\t\tString query = \"SELECT SUBSTRING(m.name, 2, 5) AS trimmedName FROM Magazine m\";\n+\t\tSort sort = new Sort(\"trimmedName\");\n+\n+\t\tassertThat(applySorting(query, sort, \"m\"), endsWith(\"order by trimmedName asc\"));\n+\t}\n+\n+\t/**\n+\t * @see DATAJPA-???\n+\t */\n+\t@Test\n+\tpublic void doesNotPrefixAliasedFunctionCallNameWithMultipleStringParameters() {\n+\n+\t\tString query = \"SELECT CONCAT(m.name, 'foo') AS extendedName FROM Magazine m\";\n+\t\tSort sort = new Sort(\"extendedName\");\n+\n+\t\tassertThat(applySorting(query, sort, \"m\"), endsWith(\"order by extendedName asc\"));\n+\t}\n+\n+\t/**\n+\t * @see DATAJPA-???\n+\t */\n+\t@Test\n+\tpublic void doesNotPrefixAliasedFunctionCallNameWithUnderscores() {\n+\n+\t\tString query = \"SELECT AVG(m.price) AS avg_price FROM Magazine m\";\n+\t\tSort sort = new Sort(\"avg_price\");\n+\n+\t\tassertThat(applySorting(query, sort, \"m\"), endsWith(\"order by avg_price asc\"));\n+\t}\n+\n+\t/**\n+\t * @see DATAJPA-???\n+\t */\n+\t@Test\n+\tpublic void doesNotPrefixAliasedFunctionCallNameWithDots() {\n+\n+\t\tString query = \"SELECT AVG(m.price) AS m.avg FROM Magazine m\";\n+\t\tSort sort = new Sort(\"m.avg\");\n+\n+\t\tassertThat(applySorting(query, sort, \"m\"), endsWith(\"order by m.avg asc\"));\n+\t}\n+\n+\t/**\n+\t * @see DATAJPA-???\n+\t */\n+\t@Test\n+\tpublic void doesNotPrefixAliasedFunctionCallNameWhenQueryStringContainsMultipleWhiteSpaces() {\n+\n+\t\tString query = \"SELECT  AVG(  m.price  )   AS   avgPrice   FROM Magazine   m\";\n+\t\tSort sort = new Sort(\"avgPrice\");\n+\n+\t\tassertThat(applySorting(query, sort, \"m\"), endsWith(\"order by avgPrice asc\"));\n+\t}\n+\n \tprivate static void assertCountQuery(String originalQuery, String countQuery) {\n \t\tassertThat(createCountQueryFor(originalQuery), is(countQuery));\n \t}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 5,
        "max_directory_depth": 9
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "9f03598c900d6e390b04d1b5b5737f6fb7b9d443",
            "date": "2025-01-23T10:26:38Z",
            "author_login": "mp911de"
          },
          {
            "sha": "5315848cb766778477c25babce6cbfa966311feb",
            "date": "2024-12-28T07:02:46Z",
            "author_login": "JoshuaChen"
          },
          {
            "sha": "96968e91eb641aeaf9c50f5716fe30f94f7adc62",
            "date": "2025-01-23T09:46:28Z",
            "author_login": "mp911de"
          },
          {
            "sha": "25594c93c51eebe8809292a6b427ae750384971f",
            "date": "2025-01-22T13:15:39Z",
            "author_login": "mp911de"
          },
          {
            "sha": "acdc688b8fb4b1292af0be46a8e9e38bad792576",
            "date": "2025-01-22T09:03:52Z",
            "author_login": "mp911de"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-89",
    "description": "SQL injection vulnerability in Pivotal Spring Data JPA before 1.9.6 (Gosling SR6) and 1.10.x before 1.10.4 (Hopper SR4), when used with a repository that defines a String query using the @Query annotation, allows attackers to execute arbitrary JPQL commands via a sort instance with a function call.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2016-10-05T16:59:04.757",
    "last_modified": "2024-11-21T02:56:33.510",
    "fix_date": "2016-09-06T11:34:08Z"
  },
  "references": [
    {
      "url": "http://www.securityfocus.com/bid/93276",
      "source": "security_alert@emc.com",
      "tags": []
    },
    {
      "url": "https://github.com/spring-projects/spring-data-jpa/commit/b8e7fe",
      "source": "security_alert@emc.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://jira.spring.io/browse/DATAJPA-965",
      "source": "security_alert@emc.com",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://pivotal.io/security/cve-2016-6652",
      "source": "security_alert@emc.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201701-01",
      "source": "security_alert@emc.com",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/93276",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/spring-projects/spring-data-jpa/commit/b8e7fe",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://jira.spring.io/browse/DATAJPA-965",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://pivotal.io/security/cve-2016-6652",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201701-01",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:46.799755",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "spring-data-jpa",
    "owner": "spring-projects",
    "created_at": "2010-11-11T21:36:56Z",
    "updated_at": "2025-01-24T11:25:26Z",
    "pushed_at": "2025-01-24T09:53:18Z",
    "size": 14375,
    "stars": 3051,
    "forks": 1440,
    "open_issues": 127,
    "watchers": 3051,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "2.7.x",
      "3.0.x",
      "3.1.x",
      "3.2.x"
    ],
    "languages": {
      "Java": 2714799,
      "ANTLR": 93164,
      "PLpgSQL": 2517,
      "Shell": 688,
      "HTML": 172
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:59:22.992595"
  }
}