{
  "cve_id": "CVE-2016-6911",
  "github_data": {
    "repository": "libgd/libgd",
    "fix_commit": "4859d69e07504d4b0a4bdf9bcb4d9e3769ca35ae",
    "related_commits": [
      "4859d69e07504d4b0a4bdf9bcb4d9e3769ca35ae",
      "4859d69e07504d4b0a4bdf9bcb4d9e3769ca35ae"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "4859d69e07504d4b0a4bdf9bcb4d9e3769ca35ae",
      "commit_date": "2016-08-02T10:10:33Z",
      "author": {
        "login": "cmb69",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix invalid read in gdImageCreateFromTiffPtr()",
        "length": 742,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 113,
        "additions": 94,
        "deletions": 19
      },
      "files": [
        {
          "filename": "src/gd_io_dp.c",
          "status": "modified",
          "additions": 10,
          "deletions": 5,
          "patch": "@@ -263,6 +263,7 @@ static void dynamicPutchar(struct gdIOCtx *ctx, int a)\n \tappendDynamic(dctx->dp, &b, 1);\n }\n \n+/* returns the number of bytes actually read; 0 on EOF and error */\n static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n {\n \tint rlen, remain;\n@@ -272,21 +273,25 @@ static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n \tdctx = (dpIOCtxPtr) ctx;\n \tdp = dctx->dp;\n \n+\tif (dp->pos < 0 || dp->pos >= dp->realSize) {\n+\t\treturn 0;\n+\t}\n+\n \tremain = dp->logicalSize - dp->pos;\n \tif(remain >= len) {\n \t\trlen = len;\n \t} else {\n \t\tif(remain <= 0) {\n-\t\t\t/* 2.0.34: EOF is incorrect. We use 0 for\n-\t\t\t * errors and EOF, just like fileGetbuf,\n-\t\t\t * which is a simple fread() wrapper.\n-\t\t\t * TBB. Original bug report: Daniel Cowgill. */\n-\t\t\treturn 0; /* NOT EOF */\n+\t\t\treturn 0;\n \t\t}\n \n \t\trlen = remain;\n \t}\n \n+\tif (dp->pos + rlen > dp->realSize) {\n+\t\trlen = dp->realSize - dp->pos;\n+\t}\n+\n \tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n \tdp->pos += rlen;\n "
        },
        {
          "filename": "src/gd_tiff.c",
          "status": "modified",
          "additions": 16,
          "deletions": 13,
          "patch": "@@ -759,6 +759,7 @@ static int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n \tint height = im->sy;\n \tuint32 *buffer;\n \tuint32 rgba;\n+\tint success;\n \n \t/* switch off colour merging on target gd image just while we write out\n \t * content - we want to preserve the alpha data until the user chooses\n@@ -771,26 +772,28 @@ static int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n \t\treturn GD_FAILURE;\n \t}\n \n-\tTIFFReadRGBAImage(tif, width, height, buffer, 0);\n-\n-\tfor(y = 0; y < height; y++) {\n-\t\tfor(x = 0; x < width; x++) {\n-\t\t\t/* if it doesn't already exist, allocate a new colour,\n-\t\t\t * else use existing one */\n-\t\t\trgba = buffer[(y * width + x)];\n-\t\t\ta = (0xff - TIFFGetA(rgba)) / 2;\n-\t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);\n-\n-\t\t\t/* set pixel colour to this colour */\n-\t\t\tgdImageSetPixel(im, x, height - y - 1, color);\n+\tsuccess = TIFFReadRGBAImage(tif, width, height, buffer, 1);\n+\n+\tif (success) {\n+\t\tfor(y = 0; y < height; y++) {\n+\t\t\tfor(x = 0; x < width; x++) {\n+\t\t\t\t/* if it doesn't already exist, allocate a new colour,\n+\t\t\t\t * else use existing one */\n+\t\t\t\trgba = buffer[(y * width + x)];\n+\t\t\t\ta = (0xff - TIFFGetA(rgba)) / 2;\n+\t\t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);\n+\t\n+\t\t\t\t/* set pixel colour to this colour */\n+\t\t\t\tgdImageSetPixel(im, x, height - y - 1, color);\n+\t\t\t}\n \t\t}\n \t}\n \n \tgdFree(buffer);\n \n \t/* now reset colour merge for alpha blending routines */\n \tgdImageAlphaBlending(im, alphaBlendingFlag);\n-\treturn GD_SUCCESS;\n+\treturn success;\n }\n \n /*"
        },
        {
          "filename": "tests/tiff/.gitignore",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -1,3 +1,4 @@\n /tiff_dpi\n /tiff_im2im\n /tiff_null\n+/tiff_invalid_read"
        },
        {
          "filename": "tests/tiff/CMakeLists.txt",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -1,6 +1,7 @@\n IF(TIFF_FOUND)\n LIST(APPEND TESTS_FILES\n \ttiff_im2im\n+\ttiff_invalid_read\n \ttiff_null\n \ttiff_dpi\n )"
        },
        {
          "filename": "tests/tiff/Makemodule.am",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -2,8 +2,12 @@ if HAVE_LIBTIFF\n libgd_test_programs += \\\n \ttiff/tiff_dpi \\\n \ttiff/tiff_im2im \\\n+\ttiff/tiff_invalid_read \\\n \ttiff/tiff_null\n endif\n \n EXTRA_DIST += \\\n-\ttiff/CMakeLists.txt\n+\ttiff/CMakeLists.txt \\\n+\ttiff/tiff_invalid_read_1.tiff \\\n+\ttiff/tiff_invalid_read_2.tiff \\\n+\ttiff/tiff_invalid_read_3.tiff"
        },
        {
          "filename": "tests/tiff/tiff_invalid_read.c",
          "status": "added",
          "additions": 61,
          "deletions": 0,
          "patch": "@@ -0,0 +1,61 @@\n+/*\n+We're testing that reading corrupt TIFF files doesn't cause any memory issues,\n+and that the operation gracefully fails (i.e. gdImageCreateFromTiffPtr() returns\n+NULL).\n+*/\n+\n+#include \"gd.h\"\n+#include \"gdtest.h\"\n+\n+\n+static void check_file(char *basename);\n+static size_t read_test_file(char **buffer, char *basename);\n+\n+\n+int main()\n+{\n+    check_file(\"tiff_invalid_read_1.tiff\");\n+    check_file(\"tiff_invalid_read_2.tiff\");\n+    check_file(\"tiff_invalid_read_3.tiff\");\n+\n+    return gdNumFailures();\n+}\n+\n+\n+static void check_file(char *basename)\n+{\n+    gdImagePtr im;\n+    char *buffer;\n+    size_t size;\n+\n+    size = read_test_file(&buffer, basename);\n+    im = gdImageCreateFromTiffPtr(size, (void *) buffer);\n+    gdTestAssert(im == NULL);\n+    free(buffer);\n+}\n+\n+\n+static size_t read_test_file(char **buffer, char *basename)\n+{\n+    char *filename;\n+    FILE *fp;\n+    size_t exp_size, act_size;\n+\n+    filename = gdTestFilePath2(\"tiff\", basename);\n+    fp = fopen(filename, \"rb\");\n+    gdTestAssert(fp != NULL);\n+\n+\tfseek(fp, 0, SEEK_END);\n+\texp_size = ftell(fp);\n+\tfseek(fp, 0, SEEK_SET);\n+\n+    *buffer = malloc(exp_size);\n+    gdTestAssert(*buffer != NULL);\n+    act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);\n+    gdTestAssert(act_size == exp_size);\n+\n+    fclose(fp);\n+    free(filename);\n+\n+    return act_size;\n+}"
        },
        {
          "filename": "tests/tiff/tiff_invalid_read_1.tiff",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "tests/tiff/tiff_invalid_read_2.tiff",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "tests/tiff/tiff_invalid_read_3.tiff",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 7,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "0b8d70805d6f0b53a88902826ddc02208f8e32a1",
            "date": "2025-01-23T14:25:23Z",
            "author_login": "cmb69"
          },
          {
            "sha": "66c20541101167089ff72183e695a7b3b763b697",
            "date": "2025-01-19T19:04:08Z",
            "author_login": "cmb69"
          },
          {
            "sha": "e0de4803d13f5813f936287a3160b40bb2847241",
            "date": "2025-01-18T15:31:24Z",
            "author_login": "cmb69"
          },
          {
            "sha": "f1480ab14bd5e2e4b4d83d8f3e64e786aa810637",
            "date": "2025-01-18T12:19:50Z",
            "author_login": "cmb69"
          },
          {
            "sha": "721f9228c2cce7d1361a2f3fd95ec95b8b959dbf",
            "date": "2025-01-10T11:37:52Z",
            "author_login": "cmb69"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-125",
    "description": "The dynamicGetbuf function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TIFF image.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-01-26T15:59:00.297",
    "last_modified": "2024-11-21T02:57:04.960",
    "fix_date": "2016-08-02T10:10:33Z"
  },
  "references": [
    {
      "url": "http://www.debian.org/security/2016/dsa-3693",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/95840",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/libgd/libgd/blob/gd-2.2.4/CHANGELOG.md",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libgd/libgd/commit/4859d69e07504d4b0a4bdf9bcb4d9e3769ca35ae",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libgd/libgd/pull/353",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.debian.org/security/2016/dsa-3693",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/95840",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/libgd/libgd/blob/gd-2.2.4/CHANGELOG.md",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libgd/libgd/commit/4859d69e07504d4b0a4bdf9bcb4d9e3769ca35ae",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libgd/libgd/pull/353",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:49.843926",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "libgd",
    "owner": "libgd",
    "created_at": "2015-01-22T08:50:57Z",
    "updated_at": "2025-01-23T22:01:59Z",
    "pushed_at": "2025-01-23T14:25:23Z",
    "size": 26543,
    "stars": 911,
    "forks": 275,
    "open_issues": 133,
    "watchers": 911,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "GD-2.1",
      "GD-2.2",
      "GD-2.3"
    ],
    "languages": {
      "C": 1644961,
      "CMake": 68297,
      "C++": 65997,
      "M4": 46524,
      "HTML": 42081,
      "Shell": 37342,
      "Makefile": 10014,
      "Perl": 3997,
      "Batchfile": 2234,
      "Tcl": 1381,
      "Python": 1206
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T08:06:25.715141"
  }
}