{
  "cve_id": "CVE-2016-7078",
  "github_data": {
    "repository": "theforeman/foreman",
    "fix_commit": "5f606e11cf39719bf62f8b1f3396861b32387905",
    "related_commits": [
      "5f606e11cf39719bf62f8b1f3396861b32387905",
      "5f606e11cf39719bf62f8b1f3396861b32387905"
    ],
    "patch_url": "https://github.com/theforeman/foreman/commit/5f606e11cf39719bf62f8b1f3396861b32387905.patch",
    "fix_commit_details": {
      "sha": "5f606e11cf39719bf62f8b1f3396861b32387905",
      "commit_date": "2016-10-20T16:06:38Z",
      "author": {
        "login": "dLobatog",
        "type": "User",
        "stats": {
          "total_commits": 312,
          "average_weekly_commits": 0.3851851851851852,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 160
        }
      },
      "commit_message": {
        "title": "Fixes #16982 - Scope properly when no taxonomies are set",
        "length": 761,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 1359,
        "additions": 802,
        "deletions": 557
      },
      "files": [
        {
          "filename": "app/controllers/concerns/foreman/controller/smart_proxy_auth.rb",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -30,7 +30,11 @@ def add_smart_proxy_filters(actions, options = {})\n   # Permits registered Smart Proxies or a user with permission\n   def require_smart_proxy_or_login(features = nil)\n     features = features.call if features.respond_to?(:call)\n-    allowed_smart_proxies = features.blank? ? SmartProxy.all : SmartProxy.with_features(*features)\n+    allowed_smart_proxies = if features.blank?\n+                              SmartProxy.unscoped.all\n+                            else\n+                              SmartProxy.unscoped.with_features(*features)\n+                            end\n \n     if !Setting[:restrict_registered_smart_proxies] || auth_smart_proxy(allowed_smart_proxies, Setting[:require_ssl_smart_proxies])\n       set_admin_user\n@@ -47,7 +51,7 @@ def require_smart_proxy_or_login(features = nil)\n \n   # Filter requests to only permit from hosts with a registered smart proxy\n   # Uses rDNS of the request to match proxy hostnames\n-  def auth_smart_proxy(proxies = SmartProxy.all, require_cert = true)\n+  def auth_smart_proxy(proxies = SmartProxy.unscoped.all, require_cert = true)\n     request_hosts = nil\n     if request.ssl?\n       # If we have the client certficate in the request environment we can extract the dn and sans from there"
        },
        {
          "filename": "app/controllers/users_controller.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -158,7 +158,7 @@ def parameter_filter_context\n   end\n \n   def verify_active_session\n-    if !request.post? && params[:status].blank? && User.exists?(session[:user].presence)\n+    if !request.post? && params[:status].blank? && User.unscoped.exists?(session[:user].presence)\n       warning _(\"You have already logged in\")\n       redirect_back_or_to hosts_path\n       return"
        },
        {
          "filename": "app/models/concerns/taxonomix.rb",
          "status": "modified",
          "additions": 44,
          "deletions": 24,
          "patch": "@@ -1,15 +1,15 @@\n module Taxonomix\n   extend ActiveSupport::Concern\n   include DirtyAssociations\n+  TAXONOMY_JOIN_TABLE = :taxable_taxonomies\n \n   included do\n-    taxonomy_join_table = :taxable_taxonomies\n-    has_many taxonomy_join_table.to_sym, :dependent => :destroy, :as => :taxable\n+    has_many TAXONOMY_JOIN_TABLE, :dependent => :destroy, :as => :taxable\n     has_many :locations, -> { where(:type => 'Location') },\n-             :through => taxonomy_join_table, :source => :taxonomy,\n+             :through => TAXONOMY_JOIN_TABLE, :source => :taxonomy,\n              :validate => false\n     has_many :organizations, -> { where(:type => 'Organization') },\n-             :through => taxonomy_join_table, :source => :taxonomy,\n+             :through => TAXONOMY_JOIN_TABLE, :source => :taxonomy,\n              :validate => false\n     after_initialize :set_current_taxonomy\n \n@@ -28,10 +28,11 @@ module ClassMethods\n \n     # default inner_method includes children (subtree_ids)\n     def with_taxonomy_scope(loc = Location.current, org = Organization.current, inner_method = :subtree_ids)\n+      scope = block_given? ? yield : where(nil)\n+      return scope unless Taxonomy.enabled_taxonomies.present?\n       self.which_ancestry_method = inner_method\n       self.which_location        = Location.expand(loc) if SETTINGS[:locations_enabled]\n       self.which_organization    = Organization.expand(org) if SETTINGS[:organizations_enabled]\n-      scope = block_given? ? yield : where('1=1')\n       scope = scope_by_taxable_ids(scope)\n       scope.readonly(false)\n     end\n@@ -69,26 +70,45 @@ def enforce_default\n     end\n \n     def taxable_ids(loc = which_location, org = which_organization, inner_method = which_ancestry_method)\n-      if SETTINGS[:locations_enabled] && loc.present?\n-        inner_ids_loc = if Location.ignore?(self.to_s)\n-                          self.unscoped.pluck(\"#{table_name}.id\")\n-                        else\n-                          inner_select(loc, inner_method)\n-                        end\n+      # Return everything (represented by nil), including objects without\n+      # taxonomies. This value should only be returned for admin users.\n+      return nil if any_context?(loc) && any_context?(org) &&\n+        User.current.try(:admin?)\n+\n+      ids = unscoped.pluck(:id)\n+      ids &= inner_ids(loc, Location, inner_method) if SETTINGS[:locations_enabled]\n+      ids &= inner_ids(org, Organization, inner_method) if SETTINGS[:organizations_enabled]\n+\n+      if self == User\n+        # In the case of users we want the taxonomy scope to get both the users\n+        # of the taxonomy, admins, and the current user.\n+        ids.concat(admin_ids)\n+        ids << User.current.id if User.current.present?\n       end\n-      if SETTINGS[:organizations_enabled] && org.present?\n-        inner_ids_org = if Organization.ignore?(self.to_s)\n-                          self.unscoped.pluck(\"#{table_name}.id\")\n-                        else\n-                          inner_select(org, inner_method)\n-                        end\n-      end\n-      inner_ids   = inner_ids_loc & inner_ids_org if (inner_ids_loc && inner_ids_org)\n-      inner_ids ||= inner_ids_loc if inner_ids_loc\n-      inner_ids ||= inner_ids_org if inner_ids_org\n-      # In the case of users we want the taxonomy scope to get both the users of the taxonomy and admins.\n-      inner_ids.concat(admin_ids) if inner_ids && self == User\n-      inner_ids\n+\n+      ids\n+    end\n+\n+    # Returns the IDs available for the passed context.\n+    # Passing a nil or [] value as taxonomy equates to \"Any context\".\n+    # Any other value will be understood as 'IDs available in this taxonomy'.\n+    def inner_ids(taxonomy, taxonomy_class, inner_method)\n+      return unscoped.pluck(\"#{table_name}.id\") if taxonomy_class.ignore?(to_s)\n+      return inner_select(taxonomy, inner_method) if taxonomy.present?\n+      return [] unless User.current.present?\n+      # Any available taxonomy to the current user\n+      return unscoped.pluck(\"#{table_name}.id\") if User.current.admin?\n+\n+      taxonomy_relation = taxonomy_class.to_s.underscore.pluralize\n+      any_context_taxonomies = User.current.\n+        taxonomy_and_child_ids(:\"#{taxonomy_relation}\")\n+      unscoped.joins(TAXONOMY_JOIN_TABLE).\n+        where(\"#{TAXONOMY_JOIN_TABLE}.taxonomy_id\" => any_context_taxonomies).\n+        pluck(:id)\n+    end\n+\n+    def any_context?(taxonomy)\n+      taxonomy.blank?\n     end\n \n     # taxonomy can be either specific taxonomy object or array of these objects"
        },
        {
          "filename": "app/models/host/base.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -49,8 +49,8 @@ def self.taxonomy_conditions\n       org = Organization.expand(Organization.current) if SETTINGS[:organizations_enabled]\n       loc = Location.expand(Location.current) if SETTINGS[:locations_enabled]\n       conditions = {}\n-      conditions[:organization_id] = Array(org).map { |o| o.subtree_ids }.flatten.uniq if org.present?\n-      conditions[:location_id] = Array(loc).map { |l| l.subtree_ids }.flatten.uniq if loc.present?\n+      conditions[:organization_id] = Array(org).map { |o| o.subtree_ids }.flatten.uniq unless org.nil?\n+      conditions[:location_id] = Array(loc).map { |l| l.subtree_ids }.flatten.uniq unless loc.nil?\n       conditions\n     end\n "
        },
        {
          "filename": "app/services/sso/base.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -41,7 +41,7 @@ def authenticate!\n     end\n \n     def current_user\n-      User.except_hidden.find_by_login(self.user)\n+      User.unscoped.except_hidden.find_by_login(self.user)\n     end\n   end\n end"
        },
        {
          "filename": "app/services/sso/oauth.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -20,7 +20,7 @@ def authenticate!\n       if OAuth::Signature.verify(request, :consumer_secret => Setting['oauth_consumer_secret'])\n         if Setting['oauth_map_users']\n           user_name = request.headers['HTTP_FOREMAN_USER'].to_s\n-          User.find_by_login(user_name).tap do |obj|\n+          User.unscoped.find_by_login(user_name).tap do |obj|\n             Rails.logger.warn \"Oauth: mapping to user '#{user_name}' failed\" if obj.nil?\n           end.try(:login)\n         else"
        },
        {
          "filename": "app/services/tax_host.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -27,11 +27,11 @@ def selected_ids\n     ids = default_ids_hash\n     #types NOT ignored - get ids that are selected\n     hash_keys.each do |col|\n-      ids[col] = Array(taxonomy.send(col))\n+      ids[col] = Array(taxonomy.send(col)).uniq\n     end\n     #types that ARE ignored - get ALL ids for object\n     Array(taxonomy.ignore_types).each do |taxonomy_type|\n-      ids[\"#{taxonomy_type.tableize.singularize}_ids\"] = taxonomy_type.constantize.pluck(:id)\n+      ids[\"#{taxonomy_type.tableize.singularize}_ids\"] = taxonomy_type.constantize.pluck(:id).uniq\n     end\n \n     ids[\"#{opposite_taxonomy_type}_ids\"] = Array(taxonomy.send(\"#{opposite_taxonomy_type}_ids\"))\n@@ -213,7 +213,7 @@ def substract_deep_hashes(h1, h2)\n   def default_ids_hash(populate_values = false)\n     ids = HashWithIndifferentAccess.new\n     hash_keys.each do |col|\n-      ids[col] = populate_values ? Array(self.send(col)) : []\n+      ids[col] = populate_values ? Array(self.send(col)).uniq : []\n     end\n     ids\n   end"
        },
        {
          "filename": "db/migrate/20130908100439_delete_orphaned_records.rb",
          "status": "modified",
          "additions": 14,
          "deletions": 14,
          "patch": "@@ -37,23 +37,23 @@ def up\n     TrendCounter.where(\"trend_id NOT IN (?)\", Trend.pluck(:id)).delete_all\n \n     # NULLIFY FOREIGN KEY VALUE IF IT HAS AN ORPHANED FOREIGN KEY\n-    Audit.unscoped.where(\"user_id NOT IN (?)\", User.pluck(:id)).update_all(:user_id => nil)\n+    Audit.unscoped.where(\"user_id NOT IN (?)\", User.unscoped.pluck(:id)).update_all(:user_id => nil)\n     FakeConfigTemplate.where(\"template_kind_id NOT IN (?)\", TemplateKind.pluck(:id)).update_all(:template_kind_id => nil)\n-    Domain.where(\"dns_id NOT IN (?)\", SmartProxy.pluck(:id)).update_all(:dns_id => nil)\n-    Subnet.where(\"dhcp_id NOT IN (?)\", SmartProxy.pluck(:id)).update_all(:dhcp_id => nil)\n-    Subnet.where(\"dns_id NOT IN (?)\", SmartProxy.pluck(:id)).update_all(:dns_id => nil)\n-    Subnet.where(\"tftp_id NOT IN (?)\", SmartProxy.pluck(:id)).update_all(:tftp_id => nil)\n-    Image.where(\"architecture_id NOT IN (?)\", Architecture.pluck(:id)).update_all(:architecture_id => nil)\n-    Image.where(\"compute_resource_id NOT IN (?)\", ComputeResource.pluck(:id)).update_all(:compute_resource_id => nil)\n+    Domain.where(\"dns_id NOT IN (?)\", SmartProxy.unscoped.pluck(:id)).update_all(:dns_id => nil)\n+    Subnet.where(\"dhcp_id NOT IN (?)\", SmartProxy.unscoped.pluck(:id)).update_all(:dhcp_id => nil)\n+    Subnet.where(\"dns_id NOT IN (?)\", SmartProxy.unscoped.pluck(:id)).update_all(:dns_id => nil)\n+    Subnet.where(\"tftp_id NOT IN (?)\", SmartProxy.unscoped.pluck(:id)).update_all(:tftp_id => nil)\n+    Image.where(\"architecture_id NOT IN (?)\", Architecture.unscoped.pluck(:id)).update_all(:architecture_id => nil)\n+    Image.where(\"compute_resource_id NOT IN (?)\", ComputeResource.unscoped.pluck(:id)).update_all(:compute_resource_id => nil)\n     Image.where(\"operatingsystem_id NOT IN (?)\", Operatingsystem.unscoped.pluck(:id)).update_all(:operatingsystem_id => nil)\n-    Nic::Base.where(\"domain_id NOT IN (?)\", Domain.pluck(:id)).update_all(:domain_id => nil)\n-    Nic::Base.where(\"host_id NOT IN (?)\", Host::Base.pluck(:id)).update_all(:host_id => nil)\n-    Nic::Base.where(\"subnet_id NOT IN (?)\", Subnet.pluck(:id)).update_all(:subnet_id => nil)\n-    OsDefaultTemplate.where(\"config_template_id NOT IN (?)\", FakeConfigTemplate.pluck(:id)).update_all(:config_template_id => nil)\n+    Nic::Base.where(\"domain_id NOT IN (?)\", Domain.unscoped.pluck(:id)).update_all(:domain_id => nil)\n+    Nic::Base.where(\"host_id NOT IN (?)\", Host::Base.unscoped.pluck(:id)).update_all(:host_id => nil)\n+    Nic::Base.where(\"subnet_id NOT IN (?)\", Subnet.unscoped.pluck(:id)).update_all(:subnet_id => nil)\n+    OsDefaultTemplate.where(\"config_template_id NOT IN (?)\", FakeConfigTemplate.unscoped.pluck(:id)).update_all(:config_template_id => nil)\n     OsDefaultTemplate.where(\"operatingsystem_id NOT IN (?)\", Operatingsystem.unscoped.pluck(:id)).update_all(:operatingsystem_id => nil)\n-    OsDefaultTemplate.where(\"template_kind_id NOT IN (?)\", TemplateKind.pluck(:id)).update_all(:template_kind_id => nil)\n-    TemplateCombination.where(\"config_template_id NOT IN (?)\", FakeConfigTemplate.pluck(:id)).update_all(:config_template_id => nil)\n-    TemplateCombination.where(\"environment_id NOT IN (?)\", Environment.pluck(:id)).update_all(:environment_id => nil)\n+    OsDefaultTemplate.where(\"template_kind_id NOT IN (?)\", TemplateKind.unscoped.pluck(:id)).update_all(:template_kind_id => nil)\n+    TemplateCombination.where(\"config_template_id NOT IN (?)\", FakeConfigTemplate.unscoped.pluck(:id)).update_all(:config_template_id => nil)\n+    TemplateCombination.where(\"environment_id NOT IN (?)\", Environment.unscoped.pluck(:id)).update_all(:environment_id => nil)\n     TemplateCombination.where(\"hostgroup_id NOT IN (?)\", Hostgroup.unscoped.pluck(:id)).update_all(:hostgroup_id => nil)\n \n     host_groups_up"
        },
        {
          "filename": "db/seeds.d/07-provisioning_templates.rb",
          "status": "modified",
          "additions": 5,
          "deletions": 6,
          "patch": "@@ -7,14 +7,14 @@\n # Template kinds\n kinds = {}\n TemplateKind.default_template_labels.keys.collect(&:to_sym).each do |type|\n-  kinds[type] = TemplateKind.find_by_name(type)\n-  kinds[type] ||= TemplateKind.create(:name => type)\n+  kinds[type] = TemplateKind.unscoped.find_by_name(type)\n+  kinds[type] ||= TemplateKind.unscoped.create(:name => type)\n   raise \"Unable to create template kind: #{format_errors kinds[type]}\" if kinds[type].nil? || kinds[type].errors.any?\n end\n \n # Provisioning templates\n-organizations = Organization.all\n-locations = Location.all\n+organizations = Organization.unscoped.all\n+locations = Location.unscoped.all\n ProvisioningTemplate.without_auditing do\n   [\n     # Generic PXE files\n@@ -81,7 +81,6 @@\n     { :name => 'puppet.conf', :source => 'snippets/_puppet.conf.erb', :snippet => true },\n     { :name => 'puppet_setup', :source => 'snippets/_puppet_setup.erb', :snippet => true },\n     { :name => 'puppetlabs_repo', :source => 'snippets/_puppetlabs_repo.erb', :snippet => true },\n-    { :name => 'pxelinux_discovery', :source => 'snippets/_pxelinux_discovery.erb', :snippet => true },\n     { :name => 'redhat_register', :source => 'snippets/_redhat_register.erb', :snippet => true },\n     { :name => 'remote_execution_ssh_keys', :source => 'snippets/_remote_execution_ssh_keys.erb', :snippet => true },\n     { :name => 'saltstack_minion', :source => 'snippets/_saltstack_minion.erb', :snippet => true },\n@@ -95,7 +94,7 @@\n   ].each do |input|\n     contents = File.read(File.join(\"#{Rails.root}/app/views/unattended\", input.delete(:source)))\n \n-    if (t = ProvisioningTemplate.find_by_name(input[:name])) && !audit_modified?(ProvisioningTemplate, input[:name])\n+    if (t = ProvisioningTemplate.unscoped.find_by_name(input[:name])) && !audit_modified?(ProvisioningTemplate, input[:name])\n       if t.template != contents\n         t.template = contents\n         raise \"Unable to update template #{t.name}: #{format_errors t}\" unless t.save"
        },
        {
          "filename": "db/seeds.d/08-partition_tables.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -1,6 +1,6 @@\n # Partition tables\n-organizations = Organization.all\n-locations = Location.all\n+organizations = Organization.unscoped.all\n+locations = Location.unscoped.all\n Ptable.without_auditing do\n   [\n     { :name => 'AutoYaST entire SCSI disk', :os_family => 'Suse', :source => 'autoyast/disklayout_scsi.erb' },\n@@ -19,7 +19,7 @@\n   ].each do |input|\n     contents = File.read(File.join(\"#{Rails.root}/app/views/unattended\", input.delete(:source)))\n \n-    if (p = Ptable.find_by_name(input[:name])) && !audit_modified?(Ptable, input[:name])\n+    if (p = Ptable.unscoped.find_by_name(input[:name])) && !audit_modified?(Ptable, input[:name])\n       if p.layout != contents\n         p.layout = contents\n         raise \"Unable to update partition table: #{format_errors p}\" unless p.save"
        },
        {
          "filename": "db/seeds.d/10-installation_media.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -1,4 +1,4 @@\n-os_suse = Operatingsystem.where(:type => \"Suse\") || Operatingsystem.where(\"name LIKE ?\", \"suse\")\n+os_suse = Operatingsystem.unscoped.where(:type => \"Suse\") || Operatingsystem.unscoped.where(\"name LIKE ?\", \"suse\")\n \n # Installation media: default mirrors\n Medium.without_auditing do\n@@ -12,7 +12,7 @@\n     { :name => \"Ubuntu mirror\", :os_family => \"Debian\", :path => \"http://archive.ubuntu.com/ubuntu\" },\n     { :name => \"CoreOS mirror\", :os_family => \"Coreos\", :path => \"http://$release.release.core-os.net\" }\n   ].each do |input|\n-    next if Medium.where(['name = ? OR path = ?', input[:name], input[:path]]).any?\n+    next if Medium.unscoped.where(['name = ? OR path = ?', input[:name], input[:path]]).any?\n     next if audit_modified? Medium, input[:name]\n     m = Medium.create input\n     raise \"Unable to create medium: #{format_errors m}\" if m.nil? || m.errors.any?"
        },
        {
          "filename": "test/active_support_test_case_helper.rb",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -9,6 +9,7 @@ class ActiveSupport::TestCase\n   setup :begin_gc_deferment\n   setup :reset_setting_cache\n   setup :skip_if_plugin_asked_to\n+  setup :set_admin\n \n   teardown :reconsider_gc_deferment\n   teardown :clear_current_user\n@@ -40,6 +41,10 @@ def skip_if_plugin_asked_to\n     end\n   end\n \n+  def set_admin\n+    User.current = users(:admin)\n+  end\n+\n   def clear_current_user\n     User.current = nil\n   end\n@@ -125,7 +130,8 @@ def setup_users\n   def setup_user(operation, type = \"\", search = nil, user = :one)\n     @one = users(user)\n     as_admin do\n-      permission = Permission.find_by_name(\"#{operation}_#{type}\") || FactoryGirl.create(:permission, :name => \"#{operation}_#{type}\")\n+      permission = Permission.find_by_name(\"#{operation}_#{type}\") ||\n+        FactoryGirl.create(:permission, :name => \"#{operation}_#{type}\")\n       filter = FactoryGirl.build(:filter, :search => search)\n       filter.permissions = [ permission ]\n       role = Role.where(:name => \"#{operation}_#{type}\").first_or_create"
        },
        {
          "filename": "test/controllers/api/v1/auth_source_ldaps_controller_test.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ class Api::V1::AuthSourceLdapsControllerTest < ActionController::TestCase\n   end\n \n   test \"should create auth_source_ldap\" do\n-    assert_difference('AuthSourceLdap.count', 1) do\n+    assert_difference('AuthSourceLdap.unscoped.count', 1) do\n       post :create, { :auth_source_ldap => valid_attrs }\n     end\n     assert_response :success\n@@ -31,7 +31,7 @@ class Api::V1::AuthSourceLdapsControllerTest < ActionController::TestCase\n   end\n \n   test \"should destroy auth_source_ldap\" do\n-    assert_difference('AuthSourceLdap.count', -1) do\n+    assert_difference('AuthSourceLdap.unscoped.count', -1) do\n       auth = auth_sources(:one)\n       User.where(:auth_source_id => auth.id).update_all(:auth_source_id => nil)\n       delete :destroy, { :id => auth.id }"
        },
        {
          "filename": "test/controllers/api/v1/compute_resources_controller_test.rb",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -35,12 +35,13 @@ def teardown\n \n   test \"should update compute resource\" do\n     put :update, { :id => compute_resources(:mycompute).to_param, :compute_resource => { :description => \"new_description\" } }\n-    assert_equal \"new_description\", ComputeResource.find_by_name('mycompute').description\n+    assert_equal \"new_description\",\n+      ComputeResource.unscoped.find_by_name('mycompute').description\n     assert_response :success\n   end\n \n   test \"should destroy compute resource\" do\n-    assert_difference('ComputeResource.count', -1) do\n+    assert_difference('ComputeResource.unscoped.count', -1) do\n       delete :destroy, { :id => compute_resources(:yourcompute).id }\n     end\n     assert_response :success\n@@ -66,12 +67,13 @@ def teardown\n   test \"should update compute resource for owner\" do\n     setup_user 'edit', 'compute_resources', \"id = #{compute_resources(:mycompute).id}\"\n     put :update, { :id => compute_resources(:mycompute).to_param, :compute_resource => { :description => \"new_description\" } }\n-    assert_equal \"new_description\", ComputeResource.find_by_name('mycompute').description\n+    assert_equal \"new_description\",\n+      ComputeResource.unscoped.find_by_name('mycompute').description\n     assert_response :success\n   end\n \n   test \"should destroy compute resource for owner\" do\n-    assert_difference('ComputeResource.count', -1) do\n+    assert_difference('ComputeResource.unscoped.count', -1) do\n       setup_user 'destroy', 'compute_resources', \"id = #{compute_resources(:mycompute).id}\"\n       delete :destroy, { :id => compute_resources(:mycompute).id }\n     end"
        },
        {
          "filename": "test/controllers/api/v1/config_templates_controller_test.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -51,15 +51,15 @@ class Api::V1::ConfigTemplatesControllerTest < ActionController::TestCase\n     config_template = templates(:pxekickstart)\n     delete :destroy, { :id => config_template.to_param }\n     assert_response :unprocessable_entity\n-    assert ProvisioningTemplate.exists?(config_template.id)\n+    assert ProvisioningTemplate.unscoped.exists?(config_template.id)\n   end\n \n   test \"should destroy\" do\n     config_template = templates(:pxekickstart)\n     config_template.os_default_templates.clear\n     delete :destroy, { :id => config_template.to_param }\n     assert_response :success\n-    refute ProvisioningTemplate.exists?(config_template.id)\n+    refute ProvisioningTemplate.unscoped.exists?(config_template.id)\n   end\n \n   test \"should build pxe menu\" do"
        },
        {
          "filename": "test/controllers/api/v1/domains_controller_test.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -27,8 +27,8 @@ class Api::V1::DomainsControllerTest < ActionController::TestCase\n   end\n \n   test \"should update valid domain\" do\n-    put :update, { :id => Domain.first.to_param, :domain => { :name => \"domain.new\" } }\n-    assert_equal \"domain.new\", Domain.first.name\n+    put :update, { :id => Domain.unscoped.first.to_param, :domain => { :name => \"domain.new\" } }\n+    assert_equal \"domain.new\", Domain.unscoped.first.name\n     assert_response :success\n   end\n "
        },
        {
          "filename": "test/controllers/api/v1/environments_controller_test.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ class Api::V1::EnvironmentsControllerTest < ActionController::TestCase\n   end\n \n   test \"should create environment\" do\n-    assert_difference('Environment.count') do\n+    assert_difference('Environment.unscoped.count') do\n       post :create, { :environment => development_environment }\n     end\n     assert_response :success\n@@ -31,7 +31,7 @@ class Api::V1::EnvironmentsControllerTest < ActionController::TestCase\n   end\n \n   test \"should destroy environments\" do\n-    assert_difference('Environment.count', -1) do\n+    assert_difference('Environment.unscoped.count', -1) do\n       delete :destroy, { :id => environments(:testing).to_param }\n     end\n     assert_response :success"
        },
        {
          "filename": "test/controllers/api/v1/hostgroups_controller_test.rb",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -35,7 +35,7 @@ def valid_attrs_with_root(extra_attrs = {})\n   end\n \n   test \"should create hostgroup\" do\n-    assert_difference('Hostgroup.count') do\n+    assert_difference('Hostgroup.unscoped.count') do\n       post :create, { :hostgroup => valid_attrs }\n     end\n     assert_response :success\n@@ -48,22 +48,22 @@ def valid_attrs_with_root(extra_attrs = {})\n \n   test \"should destroy hostgroups\" do\n     hostgroup = FactoryGirl.create(:hostgroup)\n-    assert_difference('Hostgroup.count', -1) do\n+    assert_difference('Hostgroup.unscoped.count', -1) do\n       delete :destroy, :id => hostgroup\n     end\n     assert_response :success\n   end\n \n   test \"blocks API deletion of hosts with children\" do\n     assert hostgroups(:parent).has_children?\n-    assert_no_difference('Hostgroup.count') do\n+    assert_no_difference('Hostgroup.unscoped.count') do\n       delete :destroy, { :id => hostgroups(:parent).to_param }\n     end\n     assert_response :conflict\n   end\n \n   test \"should create nested hostgroup with a parent\" do\n-    assert_difference('Hostgroup.count') do\n+    assert_difference('Hostgroup.unscoped.count') do\n       post :create, { :hostgroup => valid_attrs.merge(:parent_id => hostgroups(:common).id) }\n     end\n     assert_response :success\n@@ -73,7 +73,7 @@ def valid_attrs_with_root(extra_attrs = {})\n   test \"should update a hostgroup to nested by passing parent_id\" do\n     put :update, { :id => hostgroups(:db).to_param, :hostgroup => {:parent_id => hostgroups(:common).id} }\n     assert_response :success\n-    assert_equal hostgroups(:common).id.to_s, Hostgroup.find_by_name(\"db\").ancestry\n+    assert_equal hostgroups(:common).id.to_s, Hostgroup.unscoped.find_by_name(\"db\").ancestry\n   end\n \n   private"
        },
        {
          "filename": "test/controllers/api/v1/media_controller_test.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -23,7 +23,7 @@ class Api::V1::MediaControllerTest < ActionController::TestCase\n   end\n \n   test \"should create medium\" do\n-    assert_difference('Medium.count', +1) do\n+    assert_difference('Medium.unscoped.count', +1) do\n       post :create, { :medium => new_medium }\n     end\n     assert_response :created\n@@ -37,7 +37,7 @@ class Api::V1::MediaControllerTest < ActionController::TestCase\n   end\n \n   test \"should destroy medium\" do\n-    assert_difference('Medium.count', -1) do\n+    assert_difference('Medium.unscoped.count', -1) do\n       delete :destroy, { :id => media(:unused).id.to_param }\n     end\n     assert_response :success"
        },
        {
          "filename": "test/controllers/api/v1/ptables_controller_test.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -23,7 +23,7 @@ def setup\n   end\n \n   test \"should create ptable\" do\n-    assert_difference('Ptable.count') do\n+    assert_difference('Ptable.unscoped.count') do\n       post :create, { :ptable => valid_attrs }\n     end\n     assert_response :success\n@@ -37,14 +37,14 @@ def setup\n   test \"should NOT destroy ptable in use\" do\n     FactoryGirl.create(:host, :ptable_id => @ptable.id)\n \n-    assert_difference('Ptable.count', -0) do\n+    assert_difference('Ptable.unscoped.count', -0) do\n       delete :destroy, { :id => @ptable.to_param }\n     end\n     assert_response :unprocessable_entity\n   end\n \n   test \"should destroy ptable that is NOT in use\" do\n-    assert_difference('Ptable.count', -1) do\n+    assert_difference('Ptable.unscoped.count', -1) do\n       delete :destroy, { :id => @ptable.to_param }\n     end\n     assert_response :success"
        },
        {
          "filename": "test/controllers/api/v1/smart_proxies_controller_test.rb",
          "status": "modified",
          "additions": 10,
          "deletions": 10,
          "patch": "@@ -44,7 +44,7 @@ class Api::V1::SmartProxiesControllerTest < ActionController::TestCase\n   end\n \n   test \"should create smart_proxy\" do\n-    assert_difference('SmartProxy.count') do\n+    assert_difference('SmartProxy.unscoped.count') do\n       post :create, { :smart_proxy => valid_attrs }\n     end\n     assert_response :success\n@@ -56,7 +56,7 @@ class Api::V1::SmartProxiesControllerTest < ActionController::TestCase\n   end\n \n   test \"should destroy smart_proxy\" do\n-    assert_difference('SmartProxy.count', -1) do\n+    assert_difference('SmartProxy.unscoped.count', -1) do\n       delete :destroy, { :id => smart_proxies(:four).to_param }\n     end\n     assert_response :success\n@@ -128,7 +128,7 @@ def setup_import_classes\n       Puppetclass.destroy_all\n       Environment.destroy_all\n     end\n-    assert_difference('Environment.count', 2) do\n+    assert_difference('Environment.unscoped.count', 2) do\n       post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id}, set_session_user\n     end\n     assert_response :success\n@@ -144,7 +144,7 @@ def setup_import_classes\n         Hostgroup.update_all(:environment_id => nil)\n         Puppetclass.destroy_all\n         Environment.destroy_all\n-        assert_difference('Puppetclass.count', 1) do\n+        assert_difference('Puppetclass.unscoped.count', 1) do\n           post :import_puppetclasses,\n                { :id => smart_proxies(:puppetmaster).id }.merge(dryrun_param),\n                set_session_user\n@@ -161,7 +161,7 @@ def setup_import_classes\n       Hostgroup.update_all(:environment_id => nil)\n       Puppetclass.destroy_all\n       Environment.destroy_all\n-      assert_difference('Puppetclass.count', 0) do\n+      assert_difference('Puppetclass.unscoped.count', 0) do\n         post :import_puppetclasses, { :id => smart_proxies(:puppetmaster).id, :dryrun => true }, set_session_user\n       end\n     end\n@@ -173,7 +173,7 @@ def setup_import_classes\n     as_admin do\n       Environment.create!(:name => 'xyz')\n     end\n-    assert_difference('Environment.count', -1) do\n+    assert_difference('Environment.unscoped.count', -1) do\n       post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id}, set_session_user\n     end\n     assert_response :success\n@@ -182,7 +182,7 @@ def setup_import_classes\n   test \"should obsolete puppetclasses\" do\n     setup_import_classes\n     as_admin do\n-      assert_difference('Environment.find_by_name(\"env1\").puppetclasses.count', -2) do\n+      assert_difference('Environment.unscoped.find_by_name(\"env1\").puppetclasses.count', -2) do\n         post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id}, set_session_user\n       end\n     end\n@@ -192,7 +192,7 @@ def setup_import_classes\n   test \"should update puppetclass smart class parameters\" do\n     setup_import_classes\n     LookupKey.destroy_all\n-    assert_difference('LookupKey.count', 1) do\n+    assert_difference('LookupKey.unscoped.count', 1) do\n       post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id}, set_session_user\n     end\n     assert_response :success\n@@ -202,7 +202,7 @@ def setup_import_classes\n     setup_import_classes\n     Puppetclass.find_by_name('b').destroy\n     Puppetclass.find_by_name('c').destroy\n-    assert_difference('Environment.count', 0) do\n+    assert_difference('Environment.unscoped.count', 0) do\n       post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id}, set_session_user\n     end\n     assert_response :success\n@@ -215,7 +215,7 @@ def setup_import_classes\n     as_admin do\n       env_name = 'env1'\n       assert Environment.find_by_name(env_name).destroy\n-      assert_difference('Environment.count', 1) do\n+      assert_difference('Environment.unscoped.count', 1) do\n         post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id, :environment_id => env_name}, set_session_user\n       end\n       assert_response :success"
        },
        {
          "filename": "test/controllers/api/v1/subnets_controller_test.rb",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -20,19 +20,19 @@ def test_index\n   end\n \n   test \"should create IPv4 subnet\" do\n-    assert_difference('Subnet::Ipv4.count') do\n+    assert_difference('Subnet::Ipv4.unscoped.count') do\n       post :create, { :subnet => valid_v4_attrs }\n     end\n     assert_response :success\n-    assert_equal 'Subnet::Ipv4', Subnet.find_by_name('QA2').type\n+    assert_equal 'Subnet::Ipv4', Subnet.unscoped.find_by_name('QA2').type\n   end\n \n   test \"should create IPv6 subnet\" do\n-    assert_difference('Subnet::Ipv6.count') do\n+    assert_difference('Subnet::Ipv6.unscoped.count') do\n       post :create, { :subnet => valid_v6_attrs }\n     end\n     assert_response :success\n-    assert_equal 'Subnet::Ipv6', Subnet.find_by_name('QA2').type\n+    assert_equal 'Subnet::Ipv6', Subnet.unscoped.find_by_name('QA2').type\n   end\n \n   test \"does not create subnet with non-existent domain\" do\n@@ -46,14 +46,14 @@ def test_index\n   end\n \n   test \"should destroy subnets\" do\n-    assert_difference('Subnet.count', -1) do\n+    assert_difference('Subnet.unscoped.count', -1) do\n       delete :destroy, { :id => subnets(:four).to_param }\n     end\n     assert_response :success\n   end\n \n   test \"should NOT destroy subnet that is in use\" do\n-    assert_difference('Subnet.count', 0) do\n+    assert_difference('Subnet.unscoped.count', 0) do\n       delete :destroy, { :id => subnets(:one).to_param }\n     end\n     assert_response :unprocessable_entity"
        },
        {
          "filename": "test/controllers/api/v1/users_controller_test.rb",
          "status": "modified",
          "additions": 9,
          "deletions": 9,
          "patch": "@@ -31,7 +31,7 @@ def setup\n     put :update, { :id => user.id, :user => valid_attrs }\n     assert_response :success\n \n-    mod_user = User.find_by_id(user.id)\n+    mod_user = User.unscoped.find_by_id(user.id)\n     assert mod_user.login == \"johnsmith\"\n   end\n \n@@ -40,7 +40,7 @@ def setup\n     put :update, { :id => user.id, :user => { :admin => true } }\n \n     assert_response :success\n-    assert User.find_by_id(user.id).admin?\n+    assert User.unscoped.find_by_id(user.id).admin?\n   end\n \n   test \"should not remove the default role\" do\n@@ -51,7 +51,7 @@ def setup\n     put :update, { :id => user.id, :user => { :login => \"johnsmith\" } }\n     assert_response :success\n \n-    mod_user = User.find_by_id(user.id)\n+    mod_user = User.unscoped.find_by_id(user.id)\n \n     assert mod_user.roles =([roles(:default_role)])\n   end\n@@ -64,7 +64,7 @@ def setup\n     put :update, { :id => user.id, :user => { :login => \"johnsmith\", :password => \"dummy\", :password_confirmation => \"dummy\" } }\n     assert_response :success\n \n-    mod_user = User.find_by_id(user.id)\n+    mod_user = User.unscoped.find_by_id(user.id)\n     assert mod_user.matching_password?(\"dummy\")\n   end\n \n@@ -76,7 +76,7 @@ def setup\n     put :update, { :id => user.id, :user => { :login => \"johnsmith\", :password => \"dummy\", :password_confirmation => \"DUMMY\" } }\n     assert_response :unprocessable_entity\n \n-    mod_user = User.find_by_id(user.id)\n+    mod_user = User.unscoped.find_by_id(user.id)\n     assert mod_user.matching_password?(\"changeme\")\n   end\n \n@@ -86,7 +86,7 @@ def setup\n     delete :destroy, { :id => user.id }\n     assert_response :success\n \n-    assert !User.exists?(user.id)\n+    refute User.unscoped.exists?(user.id)\n   end\n \n   test \"should not delete same user\" do\n@@ -100,7 +100,7 @@ def setup\n       response = ActiveSupport::JSON.decode(@response.body)\n       assert response['details'] == \"You are trying to delete your own account\"\n       assert response['message'] == \"Access denied\"\n-      assert User.exists?(user.id)\n+      assert User.unscoped.exists?(user.id)\n     end\n   end\n \n@@ -138,7 +138,7 @@ def user_one_as_anonymous_viewer\n         :admin => true, :login => 'new_admin', :auth_source_id => auth_sources(:one).id }\n       }\n       assert_response :success\n-      assert User.find_by_login('new_admin').admin?\n+      assert User.unscoped.find_by_login('new_admin').admin?\n     end\n   end\n \n@@ -175,7 +175,7 @@ def user_one_as_anonymous_viewer\n     assert_response :forbidden\n   end\n \n-  test \"#update should allow updating mysel without any special permissions\" do\n+  test \"#update should allow updating myself without any special permissions\" do\n     user = User.create :login => \"foo\", :mail => \"foo@bar.com\", :auth_source => auth_sources(:one)\n     as_user user do\n       put :update, { :id => user.id, :user => valid_attrs }"
        },
        {
          "filename": "test/controllers/api/v2/auth_source_ldaps_controller_test.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ class Api::V2::AuthSourceLdapsControllerTest < ActionController::TestCase\n   end\n \n   test \"should create auth_source_ldap\" do\n-    assert_difference('AuthSourceLdap.count', 1) do\n+    assert_difference('AuthSourceLdap.unscoped.count', 1) do\n       post :create, { :auth_source_ldap => valid_attrs }\n     end\n     assert_response :created\n@@ -31,7 +31,7 @@ class Api::V2::AuthSourceLdapsControllerTest < ActionController::TestCase\n   end\n \n   test \"should destroy auth_source_ldap\" do\n-    assert_difference('AuthSourceLdap.count', -1) do\n+    assert_difference('AuthSourceLdap.unscoped.count', -1) do\n       auth = auth_sources(:one)\n       User.where(:auth_source_id => auth.id).update_all(:auth_source_id => nil)\n       delete :destroy, { :id => auth.id }"
        },
        {
          "filename": "test/controllers/api/v2/compute_resources_controller_test.rb",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -35,12 +35,13 @@ def teardown\n \n   test \"should update compute resource\" do\n     put :update, { :id => compute_resources(:mycompute).to_param, :compute_resource => { :description => \"new_description\" } }\n-    assert_equal \"new_description\", ComputeResource.find_by_name('mycompute').description\n+    assert_equal \"new_description\",\n+      ComputeResource.unscoped.find_by_name('mycompute').description\n     assert_response :success\n   end\n \n   test \"should destroy compute resource\" do\n-    assert_difference('ComputeResource.count', -1) do\n+    assert_difference('ComputeResource.unscoped.count', -1) do\n       delete :destroy, { :id => compute_resources(:yourcompute).id }\n     end\n     assert_response :success\n@@ -66,12 +67,13 @@ def teardown\n   test \"should update compute resource for owner\" do\n     setup_user 'edit', 'compute_resources', \"id = #{compute_resources(:mycompute).id}\"\n     put :update, { :id => compute_resources(:mycompute).to_param, :compute_resource => { :description => \"new_description\" } }\n-    assert_equal \"new_description\", ComputeResource.find_by_name('mycompute').description\n+    assert_equal \"new_description\",\n+      ComputeResource.unscoped.find_by_name('mycompute').description\n     assert_response :success\n   end\n \n   test \"should destroy compute resource for owner\" do\n-    assert_difference('ComputeResource.count', -1) do\n+    assert_difference('ComputeResource.unscoped.count', -1) do\n       setup_user 'destroy', 'compute_resources', \"id = #{compute_resources(:mycompute).id}\"\n       delete :destroy, { :id => compute_resources(:mycompute).id }\n     end"
        },
        {
          "filename": "test/controllers/api/v2/config_reports_controller_test.rb",
          "status": "modified",
          "additions": 7,
          "deletions": 6,
          "patch": "@@ -48,9 +48,10 @@ def test_create_duplicate\n       Setting[:require_ssl_smart_proxies] = false\n \n       proxy = smart_proxies(:puppetmaster)\n+      proxy.update_attribute(:url, 'http://configreports.foreman')\n       host = URI.parse(proxy.url).host\n       Resolv.any_instance.stubs(:getnames).returns([host])\n-      post :create, {:config_report => create_a_puppet_transaction_report }\n+      post :create, { :config_report => create_a_puppet_transaction_report }\n       assert_equal proxy, @controller.detected_proxy\n       assert_response :created\n     end\n@@ -61,7 +62,7 @@ def test_create_duplicate\n \n       Resolv.any_instance.stubs(:getnames).returns(['another.host'])\n       post :create, {:config_report => create_a_puppet_transaction_report }\n-      assert_equal 403, @response.status\n+      assert_response :forbidden\n     end\n \n     test 'hosts with a registered smart proxy and SSL cert should create a report successfully' do\n@@ -83,7 +84,7 @@ def test_create_duplicate\n       @request.env['SSL_CLIENT_S_DN'] = 'CN=another.host'\n       @request.env['SSL_CLIENT_VERIFY'] = 'SUCCESS'\n       post :create, {:config_report => create_a_puppet_transaction_report }\n-      assert_equal 403, @response.status\n+      assert_response :forbidden\n     end\n \n     test 'hosts with an unverified SSL cert should not be able to create a report' do\n@@ -94,7 +95,7 @@ def test_create_duplicate\n       @request.env['SSL_CLIENT_S_DN'] = 'CN=else.where'\n       @request.env['SSL_CLIENT_VERIFY'] = 'FAILED'\n       post :create, {:config_report => create_a_puppet_transaction_report }\n-      assert_equal 403, @response.status\n+      assert_response :forbidden\n     end\n \n     test 'when \"require_ssl_smart_proxies\" and \"require_ssl\" are true, HTTP requests should not be able to create a report' do\n@@ -104,7 +105,7 @@ def test_create_duplicate\n \n       Resolv.any_instance.stubs(:getnames).returns(['else.where'])\n       post :create, {:config_report => create_a_puppet_transaction_report }\n-      assert_equal 403, @response.status\n+      assert_response :forbidden\n     end\n \n     test 'when \"require_ssl_smart_proxies\" is true and \"require_ssl\" is false, HTTP requests should be able to create reports' do\n@@ -142,7 +143,7 @@ def test_create_duplicate\n       delete :destroy, { :id => report.to_param }\n     end\n     assert_response :success\n-    refute Report.find_by_id(report.id)\n+    refute Report.unscoped.find_by_id(report.id)\n   end\n \n   test \"should get reports for given host only\" do"
        },
        {
          "filename": "test/controllers/api/v2/config_templates_controller_test.rb",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -65,15 +65,15 @@ class Api::V2::ConfigTemplatesControllerTest < ActionController::TestCase\n     config_template = templates(:pxekickstart)\n     delete :destroy, { :id => config_template.to_param }\n     assert_response 422\n-    assert ProvisioningTemplate.exists?(config_template.id)\n+    assert ProvisioningTemplate.unscoped.exists?(config_template.id)\n   end\n \n   test \"should destroy\" do\n     config_template = templates(:pxekickstart)\n     config_template.os_default_templates.clear\n     delete :destroy, { :id => config_template.to_param }\n     assert_response :ok\n-    refute ProvisioningTemplate.exists?(config_template.id)\n+    refute ProvisioningTemplate.unscoped.exists?(config_template.id)\n   end\n \n   test \"should build pxe menu\" do\n@@ -126,6 +126,8 @@ class Api::V2::ConfigTemplatesControllerTest < ActionController::TestCase\n \n   test \"should show template with non-admin user\" do\n     setup_user('view', 'provisioning_templates')\n+    templates(:pxekickstart).organizations = User.current.organizations\n+    templates(:pxekickstart).locations = User.current.locations\n     get :show, { :id => templates(:pxekickstart).to_param }, set_session_user.merge(:user => User.current.id)\n     assert_response :success\n   end"
        },
        {
          "filename": "test/controllers/api/v2/domains_controller_test.rb",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -40,7 +40,7 @@ class Api::V2::DomainsControllerTest < ActionController::TestCase\n \n   test \"should update valid domain\" do\n     put :update, { :id => Domain.first.to_param, :domain => { :name => \"domain.new\" } }\n-    assert_equal \"domain.new\", Domain.first.name\n+    assert_equal \"domain.new\", Domain.unscoped.first.name\n     assert_response :success\n   end\n \n@@ -69,15 +69,15 @@ def setup\n   test \"should get domains for location only\" do\n     get :index, {:location_id => taxonomies(:location1).id }\n     assert_response :success\n-    assert_equal 2, assigns(:domains).length\n-    assert_equal assigns(:domains), [domains(:mydomain), domains(:yourdomain)]\n+    assert_equal taxonomies(:location1).domains.length, assigns(:domains).length\n+    assert_equal assigns(:domains), taxonomies(:location1).domains\n   end\n \n   test \"should get domains for organization only\" do\n     get :index, {:organization_id => taxonomies(:organization1).id }\n     assert_response :success\n-    assert_equal 1, assigns(:domains).length\n-    assert_equal assigns(:domains), [domains(:mydomain)]\n+    assert_equal taxonomies(:organization1).domains.length, assigns(:domains).length\n+    assert_equal taxonomies(:organization1).domains, assigns(:domains)\n   end\n \n   test \"should get domains for both location and organization\" do"
        },
        {
          "filename": "test/controllers/api/v2/environments_controller_test.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -28,7 +28,7 @@ class Api::V2::EnvironmentsControllerTest < ActionController::TestCase\n   end\n \n   test \"should create environment\" do\n-    assert_difference('Environment.count') do\n+    assert_difference('Environment.unscoped.count') do\n       post :create, { :environment => development_environment }\n     end\n     assert_response :created\n@@ -40,7 +40,7 @@ class Api::V2::EnvironmentsControllerTest < ActionController::TestCase\n   end\n \n   test \"should destroy environments\" do\n-    assert_difference('Environment.count', -1) do\n+    assert_difference('Environment.unscoped.count', -1) do\n       delete :destroy, { :id => environments(:testing).to_param }\n     end\n     assert_response :success"
        },
        {
          "filename": "test/controllers/api/v2/hostgroups_controller_test.rb",
          "status": "modified",
          "additions": 7,
          "deletions": 6,
          "patch": "@@ -35,7 +35,7 @@ def valid_attrs_with_root(extra_attrs = {})\n   end\n \n   test \"should create hostgroup\" do\n-    assert_difference('Hostgroup.count') do\n+    assert_difference('Hostgroup.unscoped.count') do\n       post :create, { :hostgroup => valid_attrs }\n     end\n     assert_response :created\n@@ -47,29 +47,29 @@ def valid_attrs_with_root(extra_attrs = {})\n   end\n \n   test \"should destroy hostgroups\" do\n-    assert_difference('Hostgroup.count', -1) do\n+    assert_difference('Hostgroup.unscoped.count', -1) do\n       delete :destroy, { :id => hostgroups(:unusual).to_param }\n     end\n     assert_response :success\n   end\n \n   test \"should clone hostgroup\" do\n-    assert_difference('Hostgroup.count') do\n+    assert_difference('Hostgroup.unscoped.count') do\n       post :clone, { :id => hostgroups(:common).to_param, :name => Time.now.utc.to_s }\n     end\n     assert_response :success\n   end\n \n   test \"blocks API deletion of hosts with children\" do\n     assert hostgroups(:parent).has_children?\n-    assert_no_difference('Hostgroup.count') do\n+    assert_no_difference('Hostgroup.unscoped.count') do\n       delete :destroy, { :id => hostgroups(:parent).to_param }\n     end\n     assert_response :conflict\n   end\n \n   test \"should create nested hostgroup with a parent\" do\n-    assert_difference('Hostgroup.count') do\n+    assert_difference('Hostgroup.unscoped.count') do\n       post :create, { :hostgroup => valid_attrs.merge(:parent_id => hostgroups(:common).id) }\n     end\n     assert_response :success\n@@ -79,7 +79,8 @@ def valid_attrs_with_root(extra_attrs = {})\n   test \"should update a hostgroup to nested by passing parent_id\" do\n     put :update, { :id => hostgroups(:db).to_param, :hostgroup => {:parent_id => hostgroups(:common).id} }\n     assert_response :success\n-    assert_equal hostgroups(:common).id.to_s, Hostgroup.find_by_name(\"db\").ancestry\n+    assert_equal hostgroups(:common).id.to_s,\n+      Hostgroup.unscoped.find_by_name(\"db\").ancestry\n   end\n \n   test \"user without view_params permission can't see hostgroup parameters\" do"
        },
        {
          "filename": "test/controllers/api/v2/hosts_controller_test.rb",
          "status": "modified",
          "additions": 16,
          "deletions": 8,
          "patch": "@@ -235,9 +235,14 @@ def expect_attribute_modifier(modifier_class, args)\n     post :create, { :host => basic_attrs_with_profile(compute_attrs).merge(:interfaces_attributes =>  nics_attrs) }\n     assert_response :created\n \n-    assert_equal compute_attrs.vm_interfaces.count, last_record.interfaces.count\n-    assert_equal expected_compute_attributes(compute_attrs, 0), last_record.interfaces.find_by_mac('00:11:22:33:44:00').compute_attributes\n-    assert_equal expected_compute_attributes(compute_attrs, 1), last_record.interfaces.find_by_mac('00:11:22:33:44:01').compute_attributes\n+    as_admin do\n+      assert_equal compute_attrs.vm_interfaces.count,\n+        last_record.interfaces.count\n+      assert_equal expected_compute_attributes(compute_attrs, 0),\n+        last_record.interfaces.find_by_mac('00:11:22:33:44:00').compute_attributes\n+      assert_equal expected_compute_attributes(compute_attrs, 1),\n+        last_record.interfaces.find_by_mac('00:11:22:33:44:01').compute_attributes\n+    end\n   end\n \n   test \"should create host with managed is false if parameter is passed\" do\n@@ -280,10 +285,12 @@ def expect_attribute_modifier(modifier_class, args)\n     put :update, { :id => @host.to_param, :host => basic_attrs_with_profile(compute_attrs) }\n     assert_response :success\n \n-    @host.interfaces.reload\n-    assert_equal compute_attrs.vm_interfaces.count, @host.interfaces.count\n-    assert_equal expected_compute_attributes(compute_attrs, 0), @host.interfaces.find_by_primary(true).compute_attributes\n-    assert_equal expected_compute_attributes(compute_attrs, 1), @host.interfaces.find_by_primary(false).compute_attributes\n+    as_admin do\n+      @host.interfaces.reload\n+      assert_equal compute_attrs.vm_interfaces.count, @host.interfaces.count\n+      assert_equal expected_compute_attributes(compute_attrs, 0), @host.interfaces.find_by_primary(true).compute_attributes\n+      assert_equal expected_compute_attributes(compute_attrs, 1), @host.interfaces.find_by_primary(false).compute_attributes\n+    end\n   end\n \n   test \"should update host without :host root node and rails wraps it correctly\" do\n@@ -488,7 +495,7 @@ def test_create_invalid\n     facts['foreman_hostgroup'] = hostgroup.title\n     post :facts, {:name => hostname, :facts => facts}\n     assert_response :success\n-    assert_equal hostgroup, Host.find_by(:name => hostname).hostgroup\n+    assert_equal hostgroup.id, Host.find_by(:name => hostname).hostgroup_id\n   end\n \n   test 'assign hostgroup attributes when foreman_hostgroup present in facts' do\n@@ -521,6 +528,7 @@ def test_create_invalid\n     Setting[:require_ssl_smart_proxies] = false\n \n     proxy = smart_proxies(:puppetmaster)\n+    proxy.update_attribute(:url, 'https://factsimporter.foreman')\n     host = URI.parse(proxy.url).host\n     Resolv.any_instance.stubs(:getnames).returns([host])\n     hostname = fact_json['name']"
        },
        {
          "filename": "test/controllers/api/v2/locations_controller_test.rb",
          "status": "modified",
          "additions": 13,
          "deletions": 4,
          "patch": "@@ -65,7 +65,7 @@ def setup\n   end\n \n   test \"should destroy location if hosts do not use it\" do\n-    assert_difference('Location.count', -1) do\n+    assert_difference('Location.unscoped.count', -1) do\n       delete :destroy, { :id => taxonomies(:location2).to_param }\n     end\n     assert_response :success\n@@ -86,7 +86,7 @@ def setup\n \n   test \"should dissociate hosts from the destroyed location\" do\n     host = FactoryGirl.create(:host, :location => taxonomies(:location1))\n-    assert_difference('Location.count', -1) do\n+    assert_difference('Location.unscoped.count', -1) do\n       delete :destroy, { :id => taxonomies(:location1).to_param }\n     end\n     assert_response :success\n@@ -95,11 +95,20 @@ def setup\n \n   test \"should update *_ids. test for domain_ids\" do\n     # ignore all but Domain\n-    @location.ignore_types = [\"Hostgroup\", \"Environment\", \"User\", \"Medium\", \"Subnet\", \"SmartProxy\", \"ProvisioningTemplate\", \"ComputeResource\", \"Realm\"]\n+    @location.ignore_types = [\"Hostgroup\", \"Environment\", \"User\", \"Medium\",\n+                              \"Subnet\", \"SmartProxy\", \"ProvisioningTemplate\",\n+                              \"ComputeResource\", \"Realm\"]\n     as_admin do\n       @location.save(:validate => false)\n       assert_difference('@location.domains.count', 2) do\n-        put :update, { :id => @location.to_param, :location => { :domain_ids => Domain.pluck(:id) } }\n+        put :update, {\n+          :id => @location.to_param,\n+          :location => { :domain_ids => Domain.unscoped.pluck(:id) }\n+        }\n+        User.current = users(:admin)\n+        # as_admin gets invalidated after the call, so we need to restore it\n+        # in order to make the call to @location.domains.count  in the right\n+        # context\n       end\n     end\n     assert_response :success"
        },
        {
          "filename": "test/controllers/api/v2/media_controller_test.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -23,7 +23,7 @@ class Api::V2::MediaControllerTest < ActionController::TestCase\n   end\n \n   test \"should create medium\" do\n-    assert_difference('Medium.count', +1) do\n+    assert_difference('Medium.unscoped.count', +1) do\n       post :create, { :medium => new_medium }\n     end\n     assert_response :created\n@@ -37,7 +37,7 @@ class Api::V2::MediaControllerTest < ActionController::TestCase\n   end\n \n   test \"should destroy medium\" do\n-    assert_difference('Medium.count', -1) do\n+    assert_difference('Medium.unscoped.count', -1) do\n       delete :destroy, { :id => media(:unused).id.to_param }\n     end\n     assert_response :success"
        },
        {
          "filename": "test/controllers/api/v2/parameters_controller_test.rb",
          "status": "modified",
          "additions": 10,
          "deletions": 5,
          "patch": "@@ -157,31 +157,36 @@ def setup\n   test \"should update nested host parameter\" do\n     put :update, { :host_id => @host.to_param, :id => @host.parameters.first.to_param, :parameter => valid_attrs }\n     assert_response :success\n-    assert_equal '123', Host.find_by_name(@host.name).parameters.order(\"parameters.updated_at\").last.value\n+    assert_equal '123', Host.unscoped.find_by_name(@host.name).parameters.\n+      order(\"parameters.updated_at\").last.value\n   end\n \n   test \"should update nested domain parameter\" do\n     put :update, { :domain_id => domains(:mydomain).to_param, :id => parameters(:domain).to_param, :parameter => valid_attrs }\n     assert_response :success\n-    assert_equal Domain.find_by_name(\"mydomain.net\").parameters.order(\"parameters.updated_at\").last.value, \"123\"\n+    assert_equal Domain.unscoped.find_by_name(\"mydomain.net\").parameters.\n+      order(\"parameters.updated_at\").last.value, \"123\"\n   end\n \n   test \"should update nested subnet parameter\" do\n     put :update, { :subnet_id => subnets(:five).to_param, :id => parameters(:subnet).to_param, :parameter => valid_attrs }\n     assert_response :success\n-    assert_equal Subnet.find_by_name(\"five\").parameters.order(\"parameters.updated_at\").last.value, \"123\"\n+    assert_equal Subnet.unscoped.find_by_name(\"five\").parameters.\n+      order(\"parameters.updated_at\").last.value, \"123\"\n   end\n \n   test \"should update nested hostgroup parameter\" do\n     put :update, { :hostgroup_id => hostgroups(:common).to_param, :id => parameters(:group).to_param, :parameter => valid_attrs }\n     assert_response :success\n-    assert_equal Hostgroup.find_by_name(\"Common\").group_parameters.order(\"parameters.updated_at\").last.value, \"123\"\n+    assert_equal Hostgroup.unscoped.find_by_name(\"Common\").group_parameters.\n+      order(\"parameters.updated_at\").last.value, \"123\"\n   end\n \n   test \"should update nested os parameter\" do\n     put :update, { :operatingsystem_id => operatingsystems(:redhat).to_param, :id => parameters(:os).to_param, :parameter => valid_attrs }\n     assert_response :success\n-    assert_equal Operatingsystem.find_by_name(\"Redhat\").parameters.order(\"parameters.updated_at\").last.value, \"123\"\n+    assert_equal Operatingsystem.unscoped.find_by_name(\"Redhat\").parameters.\n+      order(\"parameters.updated_at\").last.value, \"123\"\n   end\n \n   test \"should destroy nested host parameter\" do"
        },
        {
          "filename": "test/controllers/api/v2/provisioning_templates_controller_test.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -53,15 +53,15 @@ class Api::V2::ProvisioningTemplatesControllerTest < ActionController::TestCase\n     provisioning_template = templates(:pxekickstart)\n     delete :destroy, { :id => provisioning_template.to_param }\n     assert_response 422\n-    assert ProvisioningTemplate.exists?(provisioning_template.id)\n+    assert ProvisioningTemplate.unscoped.exists?(provisioning_template.id)\n   end\n \n   test \"should destroy\" do\n     provisioning_template = templates(:pxekickstart)\n     provisioning_template.os_default_templates.clear\n     delete :destroy, { :id => provisioning_template.to_param }\n     assert_response :ok\n-    refute ProvisioningTemplate.exists?(provisioning_template.id)\n+    refute ProvisioningTemplate.unscoped.exists?(provisioning_template.id)\n   end\n \n   test \"should build pxe menu\" do"
        },
        {
          "filename": "test/controllers/api/v2/ptables_controller_test.rb",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -23,14 +23,14 @@ def setup\n   end\n \n   test \"should create ptable\" do\n-    assert_difference('Ptable.count') do\n+    assert_difference('Ptable.unscoped.count') do\n       post :create, { :ptable => valid_attrs }\n     end\n     assert_response :created\n   end\n \n   test \"should created ptable with unwrapped 'layout'\" do\n-    assert_difference('Ptable.count') do\n+    assert_difference('Ptable.unscoped.count') do\n       post :create, valid_attrs\n     end\n     assert_response :created\n@@ -52,14 +52,14 @@ def setup\n \n   test \"should NOT destroy ptable in use\" do\n     FactoryGirl.create(:host, :ptable_id => @ptable.id)\n-    assert_difference('Ptable.count', -0) do\n+    assert_difference('Ptable.unscoped.count', 0) do\n       delete :destroy, { :id => @ptable.to_param }\n     end\n     assert_response :unprocessable_entity\n   end\n \n   test \"should destroy ptable that is NOT in use\" do\n-    assert_difference('Ptable.count', -1) do\n+    assert_difference('Ptable.unscoped.count', -1) do\n       delete :destroy, { :id => @ptable.to_param }\n     end\n     assert_response :success"
        },
        {
          "filename": "test/controllers/api/v2/realms_controller_test.rb",
          "status": "modified",
          "additions": 8,
          "deletions": 7,
          "patch": "@@ -27,8 +27,9 @@ class Api::V2::RealmsControllerTest < ActionController::TestCase\n   end\n \n   test \"should update valid realm\" do\n-    put :update, { :id => Realm.first.to_param, :realm => { :name => \"realm.new\" } }\n-    assert_equal \"realm.new\", Realm.first.name\n+    realm_id = Realm.unscoped.first.id\n+    put :update, { :id => realm_id, :realm => { :name => \"realm.new\" } }\n+    assert_equal \"realm.new\", Realm.unscoped.find(realm_id).name\n     assert_response :success\n   end\n \n@@ -44,7 +45,7 @@ class Api::V2::RealmsControllerTest < ActionController::TestCase\n     delete :destroy, { :id => realm.to_param }\n     realm = ActiveSupport::JSON.decode(@response.body)\n     assert_response :ok\n-    refute Realm.find_by_id(realm['id'])\n+    refute Realm.unscoped.find_by_id(realm['id'])\n   end\n \n   #test that taxonomy scope works for api for realms\n@@ -56,15 +57,15 @@ def setup\n   test \"should get realms for location only\" do\n     get :index, {:location_id => taxonomies(:location1).id }\n     assert_response :success\n-    assert_equal 2, assigns(:realms).length\n-    assert_equal assigns(:realms), [realms(:myrealm), realms(:yourrealm)]\n+    assert_equal taxonomies(:location1).realms.length, assigns(:realms).length\n+    assert_equal assigns(:realms), taxonomies(:location1).realms\n   end\n \n   test \"should get realms for organization only\" do\n     get :index, {:organization_id => taxonomies(:organization1).id }\n     assert_response :success\n-    assert_equal 1, assigns(:realms).length\n-    assert_equal assigns(:realms), [realms(:myrealm)]\n+    assert_equal taxonomies(:organization1).realms.length, assigns(:realms).length\n+    assert_equal assigns(:realms), taxonomies(:organization1).realms\n   end\n \n   test \"should get realms for both location and organization\" do"
        },
        {
          "filename": "test/controllers/api/v2/reports_controller_test.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -53,6 +53,7 @@ def test_create_duplicate\n       Setting[:require_ssl_smart_proxies] = false\n \n       proxy = smart_proxies(:puppetmaster)\n+      proxy.update_attribute(:url, 'http://foremanimporter.report')\n       host = URI.parse(proxy.url).host\n       Resolv.any_instance.stubs(:getnames).returns([host])\n       post :create, {:report => create_a_puppet_transaction_report }"
        },
        {
          "filename": "test/controllers/api/v2/smart_proxies_controller_test.rb",
          "status": "modified",
          "additions": 17,
          "deletions": 17,
          "patch": "@@ -23,7 +23,7 @@ class Api::V2::SmartProxiesControllerTest < ActionController::TestCase\n     refute_empty smart_proxies\n \n     returned_proxy_ids = smart_proxies['results'].map { |p| p[\"id\"] }\n-    expected_proxy_ids = SmartProxy.with_features(\"TFTP\").map { |p| p.id }\n+    expected_proxy_ids = SmartProxy.unscoped.with_features(\"TFTP\").map { |p| p.id }\n     assert_equal expected_proxy_ids, returned_proxy_ids\n   end\n \n@@ -35,7 +35,7 @@ class Api::V2::SmartProxiesControllerTest < ActionController::TestCase\n     refute_empty smart_proxies\n \n     returned_proxy_ids = smart_proxies['results'].map { |p| p[\"id\"] }\n-    expected_proxy_ids = SmartProxy.with_features(\"TFTP\").map { |p| p.id }\n+    expected_proxy_ids = SmartProxy.unscoped.with_features(\"TFTP\").map { |p| p.id }\n     assert_equal expected_proxy_ids, returned_proxy_ids\n   end\n \n@@ -47,7 +47,7 @@ class Api::V2::SmartProxiesControllerTest < ActionController::TestCase\n   end\n \n   test \"should create smart_proxy\" do\n-    assert_difference('SmartProxy.count') do\n+    assert_difference('SmartProxy.unscoped.count') do\n       post :create, { :smart_proxy => valid_attrs }\n     end\n     assert_response :created\n@@ -59,7 +59,7 @@ class Api::V2::SmartProxiesControllerTest < ActionController::TestCase\n   end\n \n   test \"should destroy smart_proxy\" do\n-    assert_difference('SmartProxy.count', -1) do\n+    assert_difference('SmartProxy.unscoped.count', -1) do\n       delete :destroy, { :id => smart_proxies(:four).to_param }\n     end\n     assert_response :success\n@@ -131,7 +131,7 @@ def setup_import_classes\n       Puppetclass.destroy_all\n       Environment.destroy_all\n     end\n-    assert_difference('Environment.count', 2) do\n+    assert_difference('Environment.unscoped.count', 2) do\n       post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id}, set_session_user\n     end\n     assert_response :success\n@@ -147,7 +147,7 @@ def setup_import_classes\n         Hostgroup.update_all(:environment_id => nil)\n         Puppetclass.destroy_all\n         Environment.destroy_all\n-        assert_difference('Puppetclass.count', 1) do\n+        assert_difference('Puppetclass.unscoped.count', 1) do\n           post :import_puppetclasses,\n                { :id => smart_proxies(:puppetmaster).id }.merge(dryrun_param),\n                set_session_user\n@@ -164,7 +164,7 @@ def setup_import_classes\n       Hostgroup.update_all(:environment_id => nil)\n       Puppetclass.destroy_all\n       Environment.destroy_all\n-      assert_difference('Puppetclass.count', 0) do\n+      assert_difference('Puppetclass.unscoped.count', 0) do\n         post :import_puppetclasses, { :id => smart_proxies(:puppetmaster).id, :dryrun => true }, set_session_user\n       end\n     end\n@@ -176,7 +176,7 @@ def setup_import_classes\n     as_admin do\n       Environment.create!(:name => 'xyz')\n     end\n-    assert_difference('Environment.count', -1) do\n+    assert_difference('Environment.unscoped.count', -1) do\n       post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id}, set_session_user\n     end\n     assert_response :success\n@@ -185,7 +185,7 @@ def setup_import_classes\n   test \"should obsolete puppetclasses\" do\n     setup_import_classes\n     as_admin do\n-      assert_difference('Environment.find_by_name(\"env1\").puppetclasses.count', -2) do\n+      assert_difference('Environment.unscoped.find_by_name(\"env1\").puppetclasses.count', -2) do\n         post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id}, set_session_user\n       end\n     end\n@@ -195,7 +195,7 @@ def setup_import_classes\n   test \"should update puppetclass smart class parameters\" do\n     setup_import_classes\n     LookupKey.destroy_all\n-    assert_difference('LookupKey.count', 1) do\n+    assert_difference('LookupKey.unscoped.count', 1) do\n       post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id}, set_session_user\n     end\n     assert_response :success\n@@ -205,7 +205,7 @@ def setup_import_classes\n     setup_import_classes\n     Puppetclass.find_by_name('b').destroy\n     Puppetclass.find_by_name('c').destroy\n-    assert_difference('Environment.count', 0) do\n+    assert_difference('Environment.unscoped.count', 0) do\n       post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id}, set_session_user\n     end\n     assert_response :success\n@@ -218,7 +218,7 @@ def setup_import_classes\n     as_admin do\n       env_name = 'env1'\n       assert Environment.find_by_name(env_name).destroy\n-      assert_difference('Environment.count', 1) do\n+      assert_difference('Environment.unscoped.count', 1) do\n         post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id, :environment_id => env_name}, set_session_user\n       end\n       assert_response :success\n@@ -232,7 +232,7 @@ def setup_import_classes\n     as_admin do\n       Environment.create!(:name => 'xyz')\n     end\n-    assert_difference('Environment.count', 0) do\n+    assert_difference('Environment.unscoped.count', 0) do\n       post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id, :except => 'obsolete'}, set_session_user\n     end\n     assert_response :success\n@@ -241,8 +241,8 @@ def setup_import_classes\n   test \"should NOT add or update puppetclass smart class parameters if pass ?except=new,updated\" do\n     setup_import_classes\n     LookupKey.destroy_all\n-    assert_difference('LookupKey.count', 0) do\n-     post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id, :except => 'new,updated'}, set_session_user\n+    assert_difference('LookupKey.unscoped.count', 0) do\n+      post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id, :except => 'new,updated'}, set_session_user\n     end\n     assert_response :success\n   end\n@@ -265,7 +265,7 @@ def setup_import_classes\n     end\n \n     test \"should import puppetclasses for specified environment only\" do\n-      assert_difference('Puppetclass.count', 1) do\n+      assert_difference('Puppetclass.unscoped.count', 1) do\n         post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id, :environment_id => 'env1'}, set_session_user\n         assert_includes Puppetclass.pluck(:name), 'a'\n         refute_includes Puppetclass.pluck(:name), 'b'\n@@ -274,7 +274,7 @@ def setup_import_classes\n     end\n \n     test \"should import puppetclasses for all environments if none specified\" do\n-      assert_difference('Puppetclass.count', 2) do\n+      assert_difference('Puppetclass.unscoped.count', 2) do\n         post :import_puppetclasses, {:id => smart_proxies(:puppetmaster).id}, set_session_user\n         assert_includes Puppetclass.pluck(:name), 'a'\n         assert_includes Puppetclass.pluck(:name), 'b'"
        },
        {
          "filename": "test/controllers/api/v2/subnets_controller_test.rb",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -20,23 +20,23 @@ class Api::V2::SubnetsControllerTest < ActionController::TestCase\n   end\n \n   test \"should create IPv4 subnet\" do\n-    assert_difference('Subnet.count') do\n+    assert_difference('Subnet.unscoped.count') do\n       post :create, { :subnet => valid_v4_attrs }\n     end\n     assert_response :created\n   end\n \n   test \"should create IPv4 subnet if type is not defined\" do\n-    assert_difference('Subnet.count') do\n+    assert_difference('Subnet.unscoped.count') do\n       post :create, { :subnet => valid_v4_attrs.reject {|k, v| k == :network_type} }\n     end\n-    subnet = Subnet.find_by_name(valid_v4_attrs[:name])\n+    subnet = Subnet.unscoped.find_by_name(valid_v4_attrs[:name])\n     assert_equal valid_v4_attrs[:network_type], subnet.network_type\n     assert_response :created\n   end\n \n   test \"should create IPv6 subnet\" do\n-    assert_difference('Subnet.count') do\n+    assert_difference('Subnet.unscoped.count') do\n       post :create, { :subnet => valid_v6_attrs }\n     end\n     assert_response :created\n@@ -58,14 +58,14 @@ class Api::V2::SubnetsControllerTest < ActionController::TestCase\n   end\n \n   test \"should destroy subnets\" do\n-    assert_difference('Subnet.count', -1) do\n+    assert_difference('Subnet.unscoped.count', -1) do\n       delete :destroy, { :id => subnets(:four).to_param }\n     end\n     assert_response :success\n   end\n \n   test \"should NOT destroy subnet that is in use\" do\n-    assert_difference('Subnet.count', 0) do\n+    assert_difference('Subnet.unscoped.count', 0) do\n       delete :destroy, { :id => subnets(:one).to_param }\n     end\n     assert_response :unprocessable_entity"
        },
        {
          "filename": "test/controllers/api/v2/users_controller_test.rb",
          "status": "modified",
          "additions": 7,
          "deletions": 7,
          "patch": "@@ -61,7 +61,7 @@ def setup\n     put :update, { :id => user.id, :user => valid_attrs }\n     assert_response :success\n \n-    mod_user = User.find_by_id(user.id)\n+    mod_user = User.unscoped.find_by_id(user.id)\n     assert mod_user.login == \"johnsmith\"\n   end\n \n@@ -70,7 +70,7 @@ def setup\n     put :update, { :id => user.id, :user => { :admin => true } }\n \n     assert_response :success\n-    assert User.find_by_id(user.id).admin?\n+    assert User.unscoped.find_by_id(user.id).admin?\n   end\n \n   test \"should not remove the default role\" do\n@@ -81,7 +81,7 @@ def setup\n     put :update, { :id => user.id, :user => { :login => \"johnsmith\" } }\n     assert_response :success\n \n-    mod_user = User.find_by_id(user.id)\n+    mod_user = User.unscoped.find_by_id(user.id)\n \n     assert mod_user.roles =([roles(:default_role)])\n   end\n@@ -94,7 +94,7 @@ def setup\n     put :update, { :id => user.id, :user => { :login => \"johnsmith\", :password => \"dummy\", :password_confirmation => \"dummy\" } }\n     assert_response :success\n \n-    mod_user = User.find_by_id(user.id)\n+    mod_user = User.unscoped.find_by_id(user.id)\n     assert mod_user.matching_password?(\"dummy\")\n   end\n \n@@ -106,7 +106,7 @@ def setup\n     put :update, { :id => user.id, :user => { :login => \"johnsmith\", :password => \"dummy\", :password_confirmation => \"DUMMY\" } }\n     assert_response :unprocessable_entity\n \n-    mod_user = User.find_by_id(user.id)\n+    mod_user = User.unscoped.find_by_id(user.id)\n     assert mod_user.matching_password?(\"changeme\")\n   end\n \n@@ -116,7 +116,7 @@ def setup\n     delete :destroy, { :id => user.id }\n     assert_response :success\n \n-    assert !User.exists?(user.id)\n+    refute User.unscoped.exists?(user.id)\n   end\n \n   test \"should not delete same user\" do\n@@ -130,7 +130,7 @@ def setup\n       response = ActiveSupport::JSON.decode(@response.body)\n       assert_equal \"You are trying to delete your own account\", response['error']['details']\n       assert_equal \"Access denied\", response['error']['message']\n-      assert User.exists?(user.id)\n+      assert User.unscoped.exists?(user.id)\n     end\n   end\n "
        },
        {
          "filename": "test/controllers/application_controller_subclass_test.rb",
          "status": "modified",
          "additions": 5,
          "deletions": 3,
          "patch": "@@ -80,10 +80,12 @@ class TestableResourcesControllerTest < ActionController::TestCase\n     end\n \n     it \"requires an account with mail\" do\n-      user = FactoryGirl.create(:user)\n-      get :index, {}, set_session_user.merge(:user => user.id)\n+      as_admin do\n+        @user = FactoryGirl.create(:user)\n+      end\n+      get :index, {}, set_session_user.merge(:user => @user.id)\n       assert_response :redirect\n-      assert_redirected_to edit_user_path(user)\n+      assert_redirected_to edit_user_path(@user)\n       assert_equal \"An email address is required, please update your account details\", flash[:error]\n     end\n "
        },
        {
          "filename": "test/controllers/auth_source_ldaps_controller_test.rb",
          "status": "modified",
          "additions": 20,
          "deletions": 20,
          "patch": "@@ -2,7 +2,7 @@\n \n class AuthSourceLdapsControllerTest < ActionController::TestCase\n   setup do\n-    @model = AuthSourceLdap.first\n+    @model = AuthSourceLdap.unscoped.first\n   end\n \n   basic_index_test\n@@ -17,42 +17,42 @@ def test_create_invalid\n \n   def test_create_valid\n     AuthSourceLdap.any_instance.stubs(:valid?).returns(true)\n-    post :create, {:auth_source_ldap => {:name => AuthSourceLdap.first.name}}, set_session_user\n+    post :create, {:auth_source_ldap => {:name => AuthSourceLdap.unscoped.first.name}}, set_session_user\n     assert_redirected_to auth_source_ldaps_url\n   end\n \n   def test_update_invalid\n     AuthSourceLdap.any_instance.stubs(:valid?).returns(false)\n-    put :update, {:id => AuthSourceLdap.first, :auth_source_ldap => {:name => AuthSourceLdap.first.name} }, set_session_user\n+    put :update, {:id => AuthSourceLdap.unscoped.first, :auth_source_ldap => {:name => AuthSourceLdap.unscoped.first.name} }, set_session_user\n     assert_template 'edit'\n   end\n \n   def test_formats_valid\n     AuthSourceLdap.any_instance.stubs(:valid?).returns(false)\n-    put :update, {:id => AuthSourceLdap.first.id, :format => \"weird\", :auth_source_ldap => {:name => AuthSourceLdap.first.name} }, set_session_user\n+    put :update, {:id => AuthSourceLdap.unscoped.first.id, :format => \"weird\", :auth_source_ldap => {:name => AuthSourceLdap.unscoped.first.name} }, set_session_user\n     assert_response :success\n \n-    wierd_id = \"#{AuthSourceLdap.first.id}.weird\"\n-    put :update, {:id => wierd_id, :auth_source_ldap => {:name => AuthSourceLdap.first.name} }, set_session_user\n+    wierd_id = \"#{AuthSourceLdap.unscoped.first.id}.weird\"\n+    put :update, {:id => wierd_id, :auth_source_ldap => {:name => AuthSourceLdap.unscoped.first.name} }, set_session_user\n     assert_response :success\n \n-    parameterized_id = \"#{AuthSourceLdap.first.id}-#{AuthSourceLdap.first.name.parameterize}\"\n-    put :update, {:id => parameterized_id, :auth_source_ldap => {:name => AuthSourceLdap.first.name} }, set_session_user\n+    parameterized_id = \"#{AuthSourceLdap.unscoped.first.id}-#{AuthSourceLdap.unscoped.first.name.parameterize}\"\n+    put :update, {:id => parameterized_id, :auth_source_ldap => {:name => AuthSourceLdap.unscoped.first.name} }, set_session_user\n     assert_response :success\n   end\n \n   def test_update_valid\n     AuthSourceLdap.any_instance.stubs(:valid?).returns(true)\n-    put :update, {:id => AuthSourceLdap.first, :auth_source_ldap => {:name => AuthSourceLdap.first.name} }, set_session_user\n+    put :update, {:id => AuthSourceLdap.unscoped.first, :auth_source_ldap => {:name => AuthSourceLdap.unscoped.first.name} }, set_session_user\n     assert_redirected_to auth_source_ldaps_url\n   end\n \n   def test_destroy\n-    auth_source_ldap = AuthSourceLdap.first\n-    User.where(:auth_source_id => auth_source_ldap.id).update_all(:auth_source_id => nil)\n+    auth_source_ldap = AuthSourceLdap.unscoped.first\n+    User.unscoped.where(:auth_source_id => auth_source_ldap.id).update_all(:auth_source_id => nil)\n     delete :destroy, {:id => auth_source_ldap}, set_session_user\n     assert_redirected_to auth_source_ldaps_url\n-    assert !AuthSourceLdap.exists?(auth_source_ldap.id)\n+    refute AuthSourceLdap.unscoped.exists?(auth_source_ldap.id)\n   end\n \n   context 'user with viewer rights' do\n@@ -66,7 +66,7 @@ def test_destroy\n     end\n \n     test 'should fail to edit authentication source' do\n-      get :edit, { :id => AuthSourceLdap.first.id },\n+      get :edit, { :id => AuthSourceLdap.unscoped.first.id },\n         set_session_user(users(:one))\n       assert_response :forbidden\n       assert_includes @response.body, 'edit_authenticators'\n@@ -79,7 +79,7 @@ def test_destroy\n     as_admin do\n       put :update, {:commit => \"Update\", :id => auth_source_ldap.id, :auth_source_ldap => {:name => auth_source_ldap.name} }, set_session_user\n     end\n-    auth_source_ldap = AuthSourceLdap.find(auth_source_ldap.id)\n+    auth_source_ldap = AuthSourceLdap.unscoped.find(auth_source_ldap.id)\n     assert_equal old_pass, auth_source_ldap.account_password\n   end\n \n@@ -94,26 +94,26 @@ def test_destroy\n \n   test \"LDAP test succeeded\" do\n     AuthSourceLdap.any_instance.stubs(:test_connection).returns(:success => true)\n-    put :test_connection, {:id => AuthSourceLdap.first, :auth_source_ldap => {:name => AuthSourceLdap.first.name} }, set_session_user\n+    put :test_connection, {:id => AuthSourceLdap.unscoped.first, :auth_source_ldap => {:name => AuthSourceLdap.unscoped.first.name} }, set_session_user\n     assert_response :success\n   end\n \n   test \"LDAP test failed\" do\n     AuthSourceLdap.any_instance.stubs(:test_connection).raises(Foreman::Exception, 'Exception message')\n-    put :test_connection, {:id => AuthSourceLdap.first, :auth_source_ldap => {:name => AuthSourceLdap.first.name} }, set_session_user\n+    put :test_connection, {:id => AuthSourceLdap.unscoped.first, :auth_source_ldap => {:name => AuthSourceLdap.unscoped.first.name} }, set_session_user\n     assert_response :unprocessable_entity\n   end\n \n   test 'organizations/locations can be assigned to it' do\n-    auth_source_ldap_params = { :name => AuthSourceLdap.first.name,\n+    auth_source_ldap_params = { :name => AuthSourceLdap.unscoped.first.name,\n                                 :organization_ids => [taxonomies(:organization1).id],\n                                 :location_names => [taxonomies(:location1).name] }\n-    put :update, { :id => AuthSourceLdap.first,\n+    put :update, { :id => AuthSourceLdap.unscoped.first,\n                    :auth_source_ldap => auth_source_ldap_params },\n                    set_session_user\n     assert_equal [taxonomies(:organization1)],\n-      AuthSourceLdap.first.organizations.to_a\n+      AuthSourceLdap.unscoped.first.organizations.to_a\n     assert_equal [taxonomies(:location1)],\n-      AuthSourceLdap.first.locations.to_a\n+      AuthSourceLdap.unscoped.first.locations.to_a\n   end\n end"
        },
        {
          "filename": "test/controllers/compute_resources_controller_test.rb",
          "status": "modified",
          "additions": 7,
          "deletions": 7,
          "patch": "@@ -33,7 +33,7 @@ class ComputeResourcesControllerTest < ActionController::TestCase\n \n   test \"should not create compute resource when not permitted\" do\n     setup_user \"view\"\n-    assert_difference('ComputeResource.count', 0) do\n+    assert_difference('ComputeResource.unscoped.count', 0) do\n       attrs = {:name => \"test\", :provider => \"Libvirt\", :url => \"qemu://host/system\"}\n       post :create, {:compute_resource => attrs}, set_session_user\n     end\n@@ -42,7 +42,7 @@ class ComputeResourcesControllerTest < ActionController::TestCase\n \n   test \"should create compute resource\" do\n     setup_user \"create\"\n-    assert_difference('ComputeResource.count', +1) do\n+    assert_difference('ComputeResource.unscoped.count', +1) do\n       attrs = {:name => \"test\", :provider => \"Libvirt\", :url => \"qemu://host/system\"}\n       post :create, {:compute_resource => attrs}, set_session_user\n     end\n@@ -78,14 +78,14 @@ class ComputeResourcesControllerTest < ActionController::TestCase\n     old_password = @compute_resource.password\n     setup_user \"edit\"\n     put :update, {:id => @compute_resource.to_param, :compute_resource => {:name => \"editing_self\"}}, set_session_user\n-    @compute_resource = ComputeResource.find(@compute_resource.id)\n+    @compute_resource = ComputeResource.unscoped.find(@compute_resource.id)\n     assert_equal old_password, @compute_resource.password\n   end\n \n   test 'blank password submitted in compute resource edit form unsets password' do\n     setup_user \"edit\"\n     put :update, {:id => @compute_resource.to_param, :compute_resource => {:name => \"editing_self\", :password => ''}}, set_session_user\n-    @compute_resource = ComputeResource.find(@compute_resource.id)\n+    @compute_resource = ComputeResource.unscoped.find(@compute_resource.id)\n     assert @compute_resource.password.empty?\n   end\n \n@@ -121,7 +121,7 @@ class ComputeResourcesControllerTest < ActionController::TestCase\n \n   test \"should not destroy compute resource when not permitted\" do\n     setup_user \"view\"\n-    assert_difference('ComputeResource.count', 0) do\n+    assert_difference('ComputeResource.unscoped.count', 0) do\n       delete :destroy, {:id => @compute_resource.to_param}, set_session_user\n     end\n \n@@ -130,7 +130,7 @@ class ComputeResourcesControllerTest < ActionController::TestCase\n \n   test \"should not destroy compute resource when restricted\" do\n     setup_user \"destroy\"\n-    assert_difference('ComputeResource.count', 0) do\n+    assert_difference('ComputeResource.unscoped.count', 0) do\n       delete :destroy, {:id => @your_compute_resource.to_param}, set_session_user\n     end\n \n@@ -139,7 +139,7 @@ class ComputeResourcesControllerTest < ActionController::TestCase\n \n   test \"should destroy compute resource\" do\n     setup_user \"destroy\"\n-    assert_difference('ComputeResource.count', -1) do\n+    assert_difference('ComputeResource.unscoped.count', -1) do\n       delete :destroy, {:id => @compute_resource.to_param}, set_session_user\n     end\n "
        },
        {
          "filename": "test/controllers/compute_resources_vms_controller_test.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -139,6 +139,8 @@ def test_should_create_vm(name = \"new_test\")\n     @test_vm = @compute_resource.vms.create({:flavor_ref => 2, :name => 'test', :image_ref => 2})\n     as_admin { @compute_resource.save }\n     setup_user \"power\"\n+    @compute_resource.organizations = User.current.organizations\n+    @compute_resource.locations = User.current.locations\n \n     Fog::Compute::OpenStack::Server.any_instance.expects(:state).returns('ACTIVE').at_least_once\n     Fog::Compute::OpenStack::Server.any_instance.expects(:pause).returns(true)"
        },
        {
          "filename": "test/controllers/domains_controller_test.rb",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -2,7 +2,7 @@\n \n class DomainsControllerTest < ActionController::TestCase\n   setup do\n-    @model = Domain.first\n+    @model = domains(:mydomain)\n   end\n \n   basic_index_test\n@@ -23,18 +23,18 @@ def test_create_valid\n \n   def test_update_invalid\n     Domain.any_instance.stubs(:valid?).returns(false)\n-    put :update, {:id => Domain.first.to_param, :domain => {:name => Domain.first.name }}, set_session_user\n+    put :update, {:id => @model.to_param, :domain => {:name => @model.name }}, set_session_user\n     assert_template 'edit'\n   end\n \n   def test_update_valid\n     Domain.any_instance.stubs(:valid?).returns(true)\n-    put :update, {:id => Domain.first.to_param, :domain => {:name => Domain.first.name }}, set_session_user\n+    put :update, {:id => @model.to_param, :domain => {:name => @model.name }}, set_session_user\n     assert_redirected_to domains_url\n   end\n \n   def test_destroy\n-    domain = Domain.first\n+    domain = @model\n     domain.hosts.clear\n     domain.hostgroups.clear\n     domain.subnets.clear\n@@ -45,7 +45,7 @@ def test_destroy\n \n   def user_with_viewer_rights_should_fail_to_edit_a_domain\n     setup_users\n-    get :edit, {:id => Domain.first.id}\n+    get :edit, {:id => @model.id}\n     assert @response.status == '403 Forbidden'\n   end\n "
        },
        {
          "filename": "test/controllers/environments_controller_test.rb",
          "status": "modified",
          "additions": 20,
          "deletions": 19,
          "patch": "@@ -10,7 +10,7 @@ class EnvironmentsControllerTest < ActionController::TestCase\n   basic_edit_test\n \n   test \"should create new environment\" do\n-    assert_difference 'Environment.count' do\n+    assert_difference 'Environment.unscoped.count' do\n       post :create, { :commit => \"Create\", :environment => {:name => \"some_environment\"} }, set_session_user\n     end\n     assert_redirected_to environments_path\n@@ -22,7 +22,7 @@ class EnvironmentsControllerTest < ActionController::TestCase\n     assert environment.save!\n \n     put :update, { :commit => \"Update\", :id => environment.name, :environment => {:name => \"other_environment\"} }, set_session_user\n-    env = Environment.find(environment.id)\n+    env = Environment.unscoped.find(environment.id)\n     assert env.name == \"other_environment\"\n \n     assert_redirected_to environments_path\n@@ -33,7 +33,7 @@ class EnvironmentsControllerTest < ActionController::TestCase\n     environment = Environment.new :name => \"some_environment\"\n     assert environment.save!\n \n-    assert_difference('Environment.count', -1) do\n+    assert_difference('Environment.unscoped.count', -1) do\n       delete :destroy, {:id => environment.name}, set_session_user\n     end\n \n@@ -83,7 +83,8 @@ def setup_import_classes\n       }, set_session_user\n     assert_redirected_to environments_url\n     assert_equal \"Successfully updated environments and Puppet classes from the on-disk Puppet installation\", flash[:notice]\n-    assert Environment.find_by_name(\"env1\").puppetclasses.map(&:name).sort == [\"a\", \"b\", \"c\"]\n+    assert_equal [\"a\", \"b\", \"c\"],\n+      Environment.unscoped.find_by_name(\"env1\").puppetclasses.map(&:name).sort\n   end\n \n   test \"should handle disk environment containing less classes\" do\n@@ -103,8 +104,8 @@ def setup_import_classes\n       }, set_session_user\n     assert_redirected_to environments_url\n     assert_equal \"Successfully updated environments and Puppet classes from the on-disk Puppet installation\", flash[:notice]\n-    envs = Environment.find_by_name(\"env1\").puppetclasses.map(&:name).sort\n-    assert envs == [\"a\", \"b\", \"c\"]\n+    envs = Environment.unscoped.find_by_name(\"env1\").puppetclasses.map(&:name).sort\n+    assert_equal [\"a\", \"b\", \"c\"], envs\n   end\n   test \"should handle disk environment containing less environments\" do\n     setup_import_classes\n@@ -122,7 +123,7 @@ def setup_import_classes\n       }, set_session_user\n     assert_redirected_to environments_url\n     assert_equal \"Successfully updated environments and Puppet classes from the on-disk Puppet installation\", flash[:notice]\n-    assert Environment.find_by_name(\"env3\").puppetclasses.map(&:name).sort == []\n+    assert_equal [], Environment.unscoped.find_by_name(\"env3\").puppetclasses.map(&:name).sort\n   end\n \n   test \"should fail to remove active environments\" do\n@@ -140,13 +141,13 @@ def setup_import_classes\n     # assert_template \"puppetclasses_or_envs_changed\". This assertion will fail. And it should fail. See above.\n     post :obsolete_and_new,\n       {\"changed\"=>\n-        {\"obsolete\" =>\n-          {\"env1\"  => '[\"a\",\"b\",\"c\",\"_destroy_\"]'}\n-        }\n-      }, set_session_user\n-    assert Environment.find_by_name(\"env1\").hosts.count > 0\n+       {\"obsolete\" =>\n+        {\"env1\"  => '[\"a\",\"b\",\"c\",\"_destroy_\"]'}\n+       }\n+    }, set_session_user\n+    assert Environment.unscoped.find_by_name(\"env1\").hosts.count > 0\n     #assert flash[:error] =~ /^Failed to update the environments and puppetclasses from the on-disk puppet installation/\n-    assert Environment.find_by_name(\"env1\")\n+    assert Environment.unscoped.find_by_name(\"env1\")\n   end\n \n   test \"should obey config/ignored_environments.yml\" do\n@@ -207,11 +208,11 @@ def setup_user\n     ProxyAPI::Puppet.any_instance.stubs(:environments).returns([\"new\"])\n     get :import_environments, {:proxy => smart_proxies(:puppetmaster)}, set_session_user\n     post :obsolete_and_new,\n-         {\"changed\" =>\n-              {\"new\" =>\n-                   {\"new\" => '{\"a\":{\"new\":{}}}'}\n-              }\n-         }, set_session_user\n-    assert(Environment.all.map(&:name).include?('new'), 'Should include environment with name \"new\"')\n+      {\"changed\" =>\n+       {\"new\" =>\n+        {\"new\" => '{\"a\":{\"new\":{}}}'}\n+       }\n+    }, set_session_user\n+    assert(Environment.unscoped.all.map(&:name).include?('new'), 'Should include environment with name \"new\"')\n   end\n end"
        },
        {
          "filename": "test/controllers/fact_values_controller_test.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -13,7 +13,9 @@ def test_index\n   end\n \n   test 'user with viewer rights should succeed in viewing facts' do\n-    users(:one).roles = [Role.default, Role.find_by_name('Viewer')]\n+    as_admin do\n+      users(:one).roles = [Role.default, Role.find_by_name('Viewer')]\n+    end\n     get :index, {}, set_session_user.merge(:user => users(:one).id)\n     assert_response :success\n   end"
        },
        {
          "filename": "test/controllers/hostgroups_controller_test.rb",
          "status": "modified",
          "additions": 23,
          "deletions": 17,
          "patch": "@@ -12,7 +12,7 @@ def test_new\n   end\n \n   def test_nest\n-    get :nest, {:id => Hostgroup.first.id}, set_session_user\n+    get :nest, {:id => hostgroups(:common).id}, set_session_user\n     assert_template 'new'\n   end\n \n@@ -31,22 +31,22 @@ def test_create_valid\n   end\n \n   def test_clone\n-    get :clone, {:id => Hostgroup.first}, set_session_user\n+    get :clone, {:id => hostgroups(:common)}, set_session_user\n     assert_template 'new'\n   end\n \n   def test_edit\n-    get :edit, {:id => Hostgroup.first}, set_session_user\n+    get :edit, {:id => hostgroups(:common)}, set_session_user\n     assert_template 'edit'\n   end\n \n   def test_update_invalid\n-    put :update, {:id => Hostgroup.first, :hostgroup => { :name => '' }}, set_session_user\n+    put :update, {:id => hostgroups(:common), :hostgroup => { :name => '' }}, set_session_user\n     assert_template 'edit'\n   end\n \n   def test_update_valid\n-    put :update, {:id => Hostgroup.first, :hostgroup => { :name => Hostgroup.first.name }}, set_session_user\n+    put :update, {:id => hostgroups(:common), :hostgroup => { :name => hostgroups(:common).name }}, set_session_user\n     assert_redirected_to hostgroups_url\n   end\n \n@@ -63,8 +63,8 @@ def setup_user(operation, type = 'hostgroups')\n \n   test 'user with viewer rights should fail to edit a hostgroup ' do\n     setup_user \"view\"\n-    get :edit, {:id => Hostgroup.first.id}, set_session_user.merge(:user => users(:one).id)\n-    assert_equal @response.status, 403\n+    get :edit, {:id => hostgroups(:common).id}, set_session_user.merge(:user => users(:one).id)\n+    assert_response :forbidden\n   end\n \n   test 'user with viewer rights should succeed in viewing hostgroups' do\n@@ -124,19 +124,19 @@ def setup_user(operation, type = 'hostgroups')\n     subnet = FactoryGirl.create(:subnet_ipv4)\n     domain.subnets << subnet\n     domain.save\n-    xhr :post, :domain_selected, {:id => Hostgroup.first, :hostgroup => {}, :domain_id => domain.id, :format => :json}, set_session_user\n+    xhr :post, :domain_selected, {:id => hostgroups(:common), :hostgroup => {}, :domain_id => domain.id, :format => :json}, set_session_user\n     assert_equal subnet.name, JSON.parse(response.body)[0][\"subnet\"][\"name\"]\n     assert_equal subnet.unused_ip.suggest_new?, JSON.parse(response.body)[0][\"subnet\"][\"unused_ip\"][\"suggest_new\"]\n   end\n \n   test \"domain_selected should return empty on no domain_id\" do\n-    xhr :post, :domain_selected, {:id => Hostgroup.first, :hostgroup => {}, :format => :json, :domain_id => nil}, set_session_user\n+    xhr :post, :domain_selected, {:id => hostgroups(:common), :hostgroup => {}, :format => :json, :domain_id => nil}, set_session_user\n     assert_response :success\n     assert_empty JSON.parse(response.body)\n   end\n \n   test \"architecture_selected should not fail when no architecture selected\" do\n-    post :architecture_selected, {:id => Hostgroup.first, :hostgroup => {}, :architecture_id => nil}, set_session_user\n+    post :architecture_selected, {:id => hostgroups(:common), :hostgroup => {}, :architecture_id => nil}, set_session_user\n     assert_response :success\n     assert_template :partial => \"common/os_selection/_architecture\"\n   end\n@@ -202,8 +202,10 @@ def setup_user(operation, type = 'hostgroups')\n       post :create, {\"hostgroup\" => {\"name\"=>\"test_it\", \"parent_id\" => @base.id, :realm_id => realms(:myrealm).id,\n                                      :group_parameters_attributes => {\"0\" => {:name => \"x\", :value =>\"overridden\", :_destroy => \"\"}}}}, set_session_user\n       assert_redirected_to hostgroups_url\n-      hostgroup = Hostgroup.where(:name => \"test_it\").last\n-      assert_equal \"overridden\", hostgroup.parameters[\"x\"]\n+      hostgroup = Hostgroup.unscoped.where(:name => \"test_it\").last\n+      as_admin do\n+        assert_equal \"overridden\", hostgroup.parameters[\"x\"]\n+      end\n     end\n \n     it \"updates a hostgroup with a parent parameter\" do\n@@ -214,8 +216,10 @@ def setup_user(operation, type = 'hostgroups')\n       post :update, {\"id\" => child.id, \"hostgroup\" => {\"name\" => child.name,\n                                                        :group_parameters_attributes => {\"0\" => {:name => \"x\", :value =>\"overridden\", :_destroy => \"\"}}}}, set_session_user\n       assert_redirected_to hostgroups_url\n-      child.reload\n-      assert_equal \"overridden\", child.parameters[\"x\"]\n+      as_admin do\n+        child.reload\n+        assert_equal \"overridden\", child.parameters[\"x\"]\n+      end\n     end\n \n     it \"updates a hostgroup with a parent parameter, allows empty values\" do\n@@ -227,9 +231,11 @@ def setup_user(operation, type = 'hostgroups')\n                                                        :group_parameters_attributes => {\"0\" => {:name => \"x\", :value => \"\", :_destroy => \"\"},\n                                                                                         \"1\" => {:name => \"y\", :value => \"overridden\", :_destroy => \"\"}}}}, set_session_user\n       assert_redirected_to hostgroups_url\n-      child.reload\n-      assert_equal \"overridden\", child.parameters[\"y\"]\n-      assert_equal \"\", child.parameters[\"x\"]\n+      as_admin do\n+        child.reload\n+        assert_equal \"overridden\", child.parameters[\"y\"]\n+        assert_equal \"\", child.parameters[\"x\"]\n+      end\n     end\n \n     it \"changes the hostgroup's parent and check the parameters are updated\" do"
        },
        {
          "filename": "test/controllers/hosts_controller_test.rb",
          "status": "modified",
          "additions": 31,
          "deletions": 18,
          "patch": "@@ -63,7 +63,7 @@ def host_attributes(host)\n   end\n \n   test \"should create new host\" do\n-    assert_difference 'Host.count' do\n+    assert_difference 'Host.unscoped.count' do\n       post :create, { :commit => \"Create\",\n         :host => {:name => \"myotherfullhost\",\n           :mac => \"aabbecddee06\",\n@@ -91,7 +91,7 @@ def host_attributes(host)\n     leftovers = Host.search_for('myotherfullhost').first\n     refute leftovers\n     hostgroup = hostgroups(:common)\n-    assert_difference 'Host.count' do\n+    assert_difference 'Host.unscoped.count' do\n       post :create, { :commit => \"Create\",\n         :host => {:name => \"myotherfullhost\",\n           :mac => \"aabbecddee06\",\n@@ -141,7 +141,7 @@ def test_update_valid\n   end\n \n   test \"should destroy host\" do\n-    assert_difference('Host.count', -1) do\n+    assert_difference('Host.unscoped.count', -1) do\n       delete :destroy, {:id => @host.name}, set_session_user\n     end\n     assert_redirected_to hosts_url\n@@ -302,6 +302,8 @@ def setup_user_and_host(operation, filter = nil, &block)\n     as_admin do\n       @host1.owner = @one\n       @host2.owner = users(:two)\n+      @host2.organization = users(:two).organizations.first\n+      @host2.location = users(:two).locations.first\n       @host1.save!\n       @host2.save!\n     end\n@@ -382,8 +384,9 @@ def setup_user_and_host(operation, filter = nil, &block)\n     assert_response :redirect\n \n     # reloads hosts\n-    hosts.map! {|h| Host.find(h.id)}\n-    hosts.each { |host| assert_equal hostgroup, host.hostgroup }\n+    as_admin do\n+      hosts.each { |host| assert_equal hostgroup, host.reload.hostgroup }\n+    end\n   end\n \n   test 'multiple hostgroup change by host names' do\n@@ -402,9 +405,11 @@ def setup_user_and_host(operation, filter = nil, &block)\n     assert_response :redirect\n \n     host_names.each do |name|\n-      host = Host.find_by_name name\n-      assert_not_nil host\n-      assert_equal host.hostgroup, hostgroup\n+      as_admin do\n+        host = Host.unscoped.find_by_name(name)\n+        assert_not_nil host\n+        assert_equal host.hostgroup, hostgroup\n+      end\n     end\n   end\n \n@@ -423,8 +428,10 @@ def setup_multiple_environments\n     post :update_multiple_environment, { :host_ids => [@host1.id, @host2.id],\n       :environment => { :id => environments(:global_puppetmaster).id}},\n       set_session_user.merge(:user => users(:admin).id)\n-    assert_equal environments(:global_puppetmaster), Host.find(@host1.id).environment\n-    assert_equal environments(:global_puppetmaster), Host.find(@host2.id).environment\n+    as_admin do\n+      assert_equal environments(:global_puppetmaster), @host1.reload.environment\n+      assert_equal environments(:global_puppetmaster), @host2.reload.environment\n+    end\n     assert_equal \"Updated hosts: changed environment\", flash[:notice]\n   end\n \n@@ -449,8 +456,8 @@ def setup_multiple_environments\n     post :update_multiple_environment, params,\n       set_session_user.merge(:user => users(:admin).id)\n \n-    assert Host.find(@host1.id).environment == hostgroup.environment\n-    assert Host.find(@host2.id).environment == hostgroup.environment\n+    assert_equal hostgroup.environment_id, Host.unscoped.find(@host1.id).environment_id\n+    assert_equal hostgroup.environment_id, Host.unscoped.find(@host2.id).environment_id\n   end\n \n   test \"user with edit host rights with update owner should change owner\" do\n@@ -461,8 +468,10 @@ def setup_multiple_environments\n     post :update_multiple_owner, { :host_ids => [@host1.id, @host2.id],\n       :owner => { :id => users(:one).id_and_type}},\n       set_session_user.merge(:user => users(:admin).id)\n-    assert_equal users(:one).id_and_type, Host.find(@host1.id).is_owned_by\n-    assert_equal users(:one).id_and_type, Host.find(@host2.id).is_owned_by\n+    as_admin do\n+      assert_equal users(:one).id_and_type, @host1.reload.is_owned_by\n+      assert_equal users(:one).id_and_type, @host2.reload.is_owned_by\n+    end\n   end\n \n   def setup_multiple_compute_resource\n@@ -552,7 +561,9 @@ def setup_multiple_compute_resource\n       assert_empty flash[:error]\n \n       @hosts.each do |host|\n-        assert_equal proxy, host.reload.puppet_ca_proxy\n+        as_admin do\n+          assert_equal proxy, host.reload.puppet_ca_proxy\n+        end\n       end\n     end\n \n@@ -640,11 +651,11 @@ def setup_multiple_compute_resource\n \n   test \"if only authorize_login_delegation is set, REMOTE_USER should be\n         ignored for API requests\" do\n+    host = Host.first\n     Setting[:authorize_login_delegation] = true\n     Setting[:authorize_login_delegation_api] = false\n     set_remote_user_to users(:admin)\n     User.current = nil # User.current is admin at this point (from initialize_host)\n-    host = Host.first\n     get :show, {:id => host.to_param, :format => 'json'}\n     assert_response 401\n     get :show, {:id => host.to_param}\n@@ -931,7 +942,7 @@ def test_unset_manage\n     @request.env['HTTP_REFERER'] = hosts_path\n     location = taxonomies(:location1)\n     cnt_hosts_location = location.hosts.count\n-    assert_difference \"location.hosts.count\", (Host.count - cnt_hosts_location) do\n+    assert_difference \"location.hosts.count\", (Host.unscoped.count - cnt_hosts_location) do\n       post :update_multiple_location, {\n         :location => {:id => location.id, :optimistic_import => \"yes\"},\n         :host_ids => Host.pluck('hosts.id')\n@@ -1002,7 +1013,7 @@ def test_unset_manage\n     @request.env['HTTP_REFERER'] = hosts_path\n     organization = taxonomies(:organization1)\n     cnt_hosts_organization = organization.hosts.count\n-    assert_difference \"organization.hosts.count\", (Host.count - cnt_hosts_organization) do\n+    assert_difference \"organization.hosts.count\", (Host.unscoped.count - cnt_hosts_organization) do\n       post :update_multiple_organization, {\n         :organization => {:id => organization.id, :optimistic_import => \"yes\"},\n         :host_ids => Host.pluck('hosts.id')\n@@ -1083,6 +1094,8 @@ class Host::Valid < Host::Managed; end\n \n   test \"test non admin multiple action\" do\n     setup_user 'edit', 'hosts', \"owner_type = User and owner_id = #{users(:restricted).id}\", :restricted\n+    User.current.organizations << taxonomies(:organization1)\n+    User.current.locations << taxonomies(:location1)\n     host = FactoryGirl.create(:host)\n     host_ids = [host.id]\n     #the ajax can be any of the multiple actions, toke multiple_parameters for example"
        },
        {
          "filename": "test/controllers/images_controller_test.rb",
          "status": "modified",
          "additions": 10,
          "deletions": 4,
          "patch": "@@ -18,12 +18,14 @@ class ImagesControllerTest < ActionController::TestCase\n   end\n \n   test \"should create image\" do\n-    assert_difference('Image.count') do\n+    assert_difference('Image.unscoped.count') do\n       image_attributes = {:name => 'gold', :username => 'ec2-user', :uuid => Foreman.uuid.to_s, :operatingsystem_id => Operatingsystem.first.id, :architecture_id => Architecture.first.id, :compute_resource_id => @image.compute_resource_id}\n       post :create, { :image => image_attributes, :compute_resource_id => @image.compute_resource_id }, set_session_user\n     end\n \n-    assert_redirected_to compute_resource_path(@image.compute_resource)\n+    as_admin do\n+      assert_redirected_to compute_resource_path(@image.compute_resource)\n+    end\n   end\n \n   test \"should get edit\" do\n@@ -33,15 +35,19 @@ class ImagesControllerTest < ActionController::TestCase\n \n   test \"should update image\" do\n     put :update, { :id => @image.to_param, :image => {:name => 'lala', :username => 'ec2-user'}, :compute_resource_id => @image.compute_resource_id }, set_session_user\n-    assert_redirected_to compute_resource_path(@image.compute_resource)\n+    as_admin do\n+      assert_redirected_to compute_resource_path(@image.compute_resource)\n+    end\n   end\n \n   test \"should destroy image\" do\n     assert_difference('Image.count', -1) do\n       delete :destroy, { :id => @image.to_param, :compute_resource_id => @image.compute_resource_id }, set_session_user\n     end\n \n-    assert_redirected_to compute_resource_path(@image.compute_resource)\n+    as_admin do\n+      assert_redirected_to compute_resource_path(@image.compute_resource)\n+    end\n   end\n \n   # listing images in /hosts/new requries a JSON response from this controller"
        },
        {
          "filename": "test/controllers/locations_controller_test.rb",
          "status": "modified",
          "additions": 16,
          "deletions": 25,
          "patch": "@@ -151,40 +151,31 @@ class LocationsControllerTest < ActionController::TestCase\n     assert_response :success\n     assert_match \"Clone\", @response.body\n   end\n-  test \"should clone location with assocations\" do\n+  test \"should clone location with associations\" do\n     location = taxonomies(:location1)\n     FactoryGirl.create(:host, :location => nil)\n     location_dup = location.clone\n \n-    assert_difference \"Location.count\", 1 do\n-      post :create, {:location => {:name => \"location_dup_name\",\n-                                 :environment_ids => location_dup.environment_ids,\n-                                 :hostgroup_ids => location_dup.hostgroup_ids,\n-                                 :subnet_ids => location_dup.hostgroup_ids,\n-                                 :domain_ids => location_dup.domain_ids,\n-                                 :medium_ids => location_dup.medium_ids,\n-                                 :user_ids => location_dup.user_ids,\n-                                 :smart_proxy_ids => location_dup.smart_proxy_ids,\n-                                 :provisioning_template_ids => location_dup.provisioning_template_ids,\n-                                 :compute_resource_ids => location_dup.compute_resource_ids,\n-                                 :organization_ids => location_dup.organization_ids\n-                               }\n-                   }, set_session_user\n+    assert_difference \"Location.unscoped.count\", 1 do\n+      post :create, {\n+        :location => location_dup.selected_ids.each { |_,v| v.uniq! }\n+          .merge(:name => 'location_dup_name')\n+      }, set_session_user\n     end\n \n     new_location = Location.unscoped.order(:id).last\n     assert_redirected_to :controller => :locations, :action => :step2, :id => new_location.to_param\n \n-    assert_equal new_location.environment_ids.sort, location.environment_ids.sort\n-    assert_equal new_location.hostgroup_ids.sort, location.hostgroup_ids.sort\n-    assert_equal new_location.environment_ids.sort, location.environment_ids.sort\n-    assert_equal new_location.domain_ids.sort, location.domain_ids.sort\n-    assert_equal new_location.medium_ids.sort, location.medium_ids.sort\n-    assert_equal new_location.user_ids.sort, location.user_ids.sort\n-    assert_equal new_location.smart_proxy_ids.sort, location.smart_proxy_ids.sort\n-    assert_equal new_location.provisioning_template_ids.sort, location.provisioning_template_ids.sort\n-    assert_equal new_location.compute_resource_ids.sort, location.compute_resource_ids.sort\n-    assert_equal new_location.organization_ids.sort, location.organization_ids.sort\n+    assert_equal new_location.environment_ids.uniq.sort, location.environment_ids.uniq.sort\n+    assert_equal new_location.hostgroup_ids.uniq.sort, location.hostgroup_ids.uniq.sort\n+    assert_equal new_location.environment_ids.uniq.sort, location.environment_ids.uniq.sort\n+    assert_equal new_location.domain_ids.uniq.sort, location.domain_ids.uniq.sort\n+    assert_equal new_location.medium_ids.uniq.sort, location.medium_ids.uniq.sort\n+    assert_equal new_location.user_ids.uniq.sort, location.user_ids.uniq.sort\n+    assert_equal new_location.smart_proxy_ids.uniq.sort, location.smart_proxy_ids.uniq.sort\n+    assert_equal new_location.provisioning_template_ids.uniq.sort, location.provisioning_template_ids.uniq.sort\n+    assert_equal new_location.compute_resource_ids.uniq.sort, location.compute_resource_ids.uniq.sort\n+    assert_equal new_location.organization_ids.uniq.sort, location.organization_ids.uniq.sort\n   end\n \n   test \"should clear out Location.current\" do"
        },
        {
          "filename": "test/controllers/media_controller_test.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -23,13 +23,13 @@ def test_create_valid\n \n   def test_update_invalid\n     Medium.any_instance.stubs(:valid?).returns(false)\n-    put :update, {:id => Medium.first, :medium => {:name => nil}}, set_session_user\n+    put :update, {:id => @model, :medium => {:name => nil}}, set_session_user\n     assert_template 'edit'\n   end\n \n   def test_update_valid\n     Medium.any_instance.stubs(:valid?).returns(true)\n-    put :update, {:id => Medium.first, :medium => {:name => \"MyUpdatedMedia\"}}, set_session_user\n+    put :update, {:id => @model, :medium => {:name => \"MyUpdatedMedia\"}}, set_session_user\n     assert_redirected_to media_url\n   end\n \n@@ -47,7 +47,7 @@ def setup_user\n \n   test 'user with viewer rights should fail to edit a medium' do\n     setup_user\n-    get :edit, {:id => Medium.first.id}, set_session_user.merge(:user => users(:one).id)\n+    get :edit, {:id => @model.id}, set_session_user.merge(:user => users(:one).id)\n     assert_equal @response.status, 403\n   end\n "
        },
        {
          "filename": "test/controllers/organizations_controller_test.rb",
          "status": "modified",
          "additions": 15,
          "deletions": 24,
          "patch": "@@ -163,40 +163,31 @@ class OrganizationsControllerTest < ActionController::TestCase\n     assert_response :success\n     assert_match \"Clone\", @response.body\n   end\n-  test \"should clone organization with assocations\" do\n+  test \"should clone organization with associations\" do\n     organization = taxonomies(:organization1)\n     FactoryGirl.create(:host, :organization => nil)\n     organization_dup = organization.clone\n \n-    assert_difference \"Organization.count\", 1 do\n-      post :create, {:organization => {:name => \"organization_dup_name\",\n-                                       :environment_ids => organization_dup.environment_ids,\n-                                       :hostgroup_ids => organization_dup.hostgroup_ids,\n-                                       :subnet_ids => organization_dup.hostgroup_ids,\n-                                       :domain_ids => organization_dup.domain_ids,\n-                                       :medium_ids => organization_dup.medium_ids,\n-                                       :user_ids => organization_dup.user_ids,\n-                                       :smart_proxy_ids => organization_dup.smart_proxy_ids,\n-                                       :provisioning_template_ids => organization_dup.provisioning_template_ids,\n-                                       :compute_resource_ids => organization_dup.compute_resource_ids,\n-                                       :location_ids => organization_dup.location_ids\n-      }\n+    assert_difference \"Organization.unscoped.count\", 1 do\n+      post :create, {\n+        :organization => organization_dup.selected_ids.each { |_,v| v.uniq! }\n+          .merge(:name => 'organization_dup_name')\n       }, set_session_user\n     end\n \n     new_organization = Organization.unscoped.order(:id).last\n     assert_redirected_to :controller => :organizations, :action => :step2, :id => new_organization.to_param\n \n-    assert_equal new_organization.environment_ids.sort, organization.environment_ids.sort\n-    assert_equal new_organization.hostgroup_ids.sort, organization.hostgroup_ids.sort\n-    assert_equal new_organization.environment_ids.sort, organization.environment_ids.sort\n-    assert_equal new_organization.domain_ids.sort, organization.domain_ids.sort\n-    assert_equal new_organization.medium_ids.sort, organization.medium_ids.sort\n-    assert_equal new_organization.user_ids.sort, organization.user_ids.sort\n-    assert_equal new_organization.smart_proxy_ids.sort, organization.smart_proxy_ids.sort\n-    assert_equal new_organization.provisioning_template_ids.sort, organization.provisioning_template_ids.sort\n-    assert_equal new_organization.compute_resource_ids.sort, organization.compute_resource_ids.sort\n-    assert_equal new_organization.location_ids.sort, organization.location_ids.sort\n+    assert_equal new_organization.environment_ids.uniq.sort, organization.environment_ids.uniq.sort\n+    assert_equal new_organization.hostgroup_ids.uniq.sort, organization.hostgroup_ids.uniq.sort\n+    assert_equal new_organization.environment_ids.uniq.sort, organization.environment_ids.uniq.sort\n+    assert_equal new_organization.domain_ids.uniq.sort, organization.domain_ids.uniq.sort\n+    assert_equal new_organization.medium_ids.uniq.sort, organization.medium_ids.uniq.sort\n+    assert_equal new_organization.user_ids.uniq.sort, organization.user_ids.uniq.sort\n+    assert_equal new_organization.smart_proxy_ids.uniq.sort, organization.smart_proxy_ids.uniq.sort\n+    assert_equal new_organization.provisioning_template_ids.uniq.sort, organization.provisioning_template_ids.uniq.sort\n+    assert_equal new_organization.compute_resource_ids.uniq.sort, organization.compute_resource_ids.uniq.sort\n+    assert_equal new_organization.location_ids.uniq.sort, organization.location_ids.uniq.sort\n   end\n \n   test \"should clear out Organization.current\" do"
        },
        {
          "filename": "test/controllers/provisioning_templates_controller_test.rb",
          "status": "modified",
          "additions": 10,
          "deletions": 8,
          "patch": "@@ -40,14 +40,14 @@ class ProvisioningTemplatesControllerTest < ActionController::TestCase\n     @request.env['HTTP_REFERER'] = provisioning_templates_path\n     get :lock, {:id => templates(:pxekickstart).to_param }, set_session_user\n     assert_redirected_to provisioning_templates_path\n-    assert_equal ProvisioningTemplate.find(templates(:pxekickstart).id).locked, true\n+    assert_equal ProvisioningTemplate.unscoped.find(templates(:pxekickstart).id).locked, true\n   end\n \n   test \"unlock\" do\n     @request.env['HTTP_REFERER'] = provisioning_templates_path\n     get :unlock, {:id => templates(:locked).to_param }, set_session_user\n     assert_redirected_to provisioning_templates_path\n-    assert_equal ProvisioningTemplate.find(templates(:locked).id).locked, false\n+    assert_equal ProvisioningTemplate.unscoped.find(templates(:locked).id).locked, false\n   end\n \n   test \"clone\" do\n@@ -79,15 +79,15 @@ class ProvisioningTemplatesControllerTest < ActionController::TestCase\n     config_template = templates(:pxekickstart)\n     delete :destroy, {:id => config_template.to_param }, set_session_user\n     assert_redirected_to provisioning_templates_url\n-    assert ProvisioningTemplate.exists?(config_template.id)\n+    assert ProvisioningTemplate.unscoped.exists?(config_template.id)\n   end\n \n   test \"destroy\" do\n     config_template = templates(:pxekickstart)\n     config_template.os_default_templates.clear\n     delete :destroy, {:id => config_template.to_param }, set_session_user\n     assert_redirected_to provisioning_templates_url\n-    assert !ProvisioningTemplate.exists?(config_template.id)\n+    assert !ProvisioningTemplate.unscoped.exists?(config_template.id)\n   end\n \n   test \"audit comment\" do\n@@ -199,8 +199,8 @@ class ProvisioningTemplatesControllerTest < ActionController::TestCase\n         :template_kind_id => TemplateKind.find_by_name('iPXE').id,\n         :template_combinations_attributes => { '3923' => template_combination }\n       }\n-      assert_difference('TemplateCombination.count', 1) do\n-        assert_difference('ProvisioningTemplate.count', 1) do\n+      assert_difference('TemplateCombination.unscoped.count', 1) do\n+        assert_difference('ProvisioningTemplate.unscoped.count', 1) do\n           post :create, {\n             :provisioning_template => provisioning_template\n           }, set_session_user\n@@ -230,8 +230,10 @@ class ProvisioningTemplatesControllerTest < ActionController::TestCase\n           }\n         }, set_session_user\n         assert_response :found\n-        @template_combination.reload\n-        assert_equal new_environment, @template_combination.environment\n+        as_admin do\n+          @template_combination.reload\n+          assert_equal new_environment, @template_combination.environment\n+        end\n       end\n \n       test 'can be destroyed' do"
        },
        {
          "filename": "test/controllers/puppetclasses_controller_test.rb",
          "status": "modified",
          "additions": 30,
          "deletions": 18,
          "patch": "@@ -109,10 +109,12 @@ def setup_user(operation = nil, type = \"\", search = nil, user = :one)\n     post :parameters, {:id => puppetclass.id, :host_id => host.id,\n                        :host => existing_host_attributes }, set_session_user\n     assert_response :success\n-    lookup_keys_added = overridable_lookup_keys(puppetclass, assigns(:obj))\n-    assert_equal 1, lookup_keys_added.count\n-    assert lookup_keys_added.map(&:key).include?(\"special_info\")\n-    refute lookup_keys_added.map(&:key).include?(\"custom_class_param\")\n+    as_admin do\n+      lookup_keys_added = overridable_lookup_keys(puppetclass, assigns(:obj))\n+      assert_equal 1, lookup_keys_added.count\n+      assert lookup_keys_added.map(&:key).include?(\"special_info\")\n+      refute lookup_keys_added.map(&:key).include?(\"custom_class_param\")\n+    end\n   end\n \n   test 'puppetclass lookup keys are added to partial _class_parameters on EXISTING hostgroup form through ajax POST to parameters' do\n@@ -123,10 +125,12 @@ def setup_user(operation = nil, type = \"\", search = nil, user = :one)\n     post :parameters, {:id => puppetclass.id, :host_id => hostgroup.id,\n                        :hostgroup => existing_hostgroup_attributes }, set_session_user\n     assert_response :success\n-    lookup_keys_added = overridable_lookup_keys(puppetclass, hostgroup)\n-    assert_equal 2, lookup_keys_added.count\n-    assert lookup_keys_added.map(&:key).include?(\"special_info\")\n-    assert lookup_keys_added.map(&:key).include?(\"custom_class_param\")\n+    as_admin do\n+      lookup_keys_added = overridable_lookup_keys(puppetclass, hostgroup)\n+      assert_equal 2, lookup_keys_added.count\n+      assert lookup_keys_added.map(&:key).include?(\"special_info\")\n+      assert lookup_keys_added.map(&:key).include?(\"custom_class_param\")\n+    end\n   end\n \n   test 'puppetclass lookup keys are added to partial _class_parameters on NEW host form through ajax POST to parameters' do\n@@ -136,10 +140,12 @@ def setup_user(operation = nil, type = \"\", search = nil, user = :one)\n     post :parameters, {:id => puppetclass.id, :host_id => 'null',\n                        :host => new_host_attributes }, set_session_user\n     assert_response :success\n-    lookup_keys_added = overridable_lookup_keys(puppetclass, host)\n-    assert_equal 2, lookup_keys_added.count\n-    assert lookup_keys_added.map(&:key).include?(\"special_info\")\n-    assert lookup_keys_added.map(&:key).include?(\"custom_class_param\")\n+    as_admin do\n+      lookup_keys_added = overridable_lookup_keys(puppetclass, host)\n+      assert_equal 2, lookup_keys_added.count\n+      assert lookup_keys_added.map(&:key).include?(\"special_info\")\n+      assert lookup_keys_added.map(&:key).include?(\"custom_class_param\")\n+    end\n   end\n \n   test 'puppetclass lookup keys are added to partial _class_parameters on NEW hostgroup form through ajax POST to parameters' do\n@@ -150,10 +156,12 @@ def setup_user(operation = nil, type = \"\", search = nil, user = :one)\n     post :parameters, {:id => puppetclass.id, :host_id => 'null',\n                        :hostgroup => new_hostgroup_attributes }, set_session_user\n     assert_response :success\n-    lookup_keys_added = overridable_lookup_keys(puppetclass, hostgroup)\n-    assert_equal 2, lookup_keys_added.count\n-    assert lookup_keys_added.map(&:key).include?(\"special_info\")\n-    assert lookup_keys_added.map(&:key).include?(\"custom_class_param\")\n+    as_admin do\n+      lookup_keys_added = overridable_lookup_keys(puppetclass, hostgroup)\n+      assert_equal 2, lookup_keys_added.count\n+      assert lookup_keys_added.map(&:key).include?(\"special_info\")\n+      assert lookup_keys_added.map(&:key).include?(\"custom_class_param\")\n+    end\n   end\n \n   test \"sorting by environment name on the index screen should work\" do\n@@ -205,7 +213,9 @@ def test_override_none\n \n   test 'user with edit_puppetclasses permission should succeed in overriding all parameters' do\n     setup_user \"edit\", \"puppetclasses\"\n-    env = FactoryGirl.create(:environment)\n+    env = FactoryGirl.create(:environment,\n+                             :organizations => [users(:one).organizations.first],\n+                             :locations => [users(:one).locations.first])\n     pc = FactoryGirl.create(:puppetclass, :with_parameters, :environments => [env])\n     refute pc.class_params.first.override\n     post :override, {:id => pc.to_param, :enable => 'true'}, set_session_user.merge(:user => users(:one).id)\n@@ -215,7 +225,9 @@ def test_override_none\n \n   test 'user without edit_puppetclasses permission should fail in overriding all parameters' do\n     setup_user \"view\", \"puppetclasses\"\n-    env = FactoryGirl.create(:environment)\n+    env = FactoryGirl.create(:environment,\n+                             :organizations => [users(:one).organizations.first],\n+                             :locations => [users(:one).locations.first])\n     pc = FactoryGirl.create(:puppetclass, :with_parameters, :environments => [env])\n     refute pc.class_params.first.override\n     post :override, {:id => pc.to_param, :enable => 'true'}, set_session_user.merge(:user => users(:one).id)"
        },
        {
          "filename": "test/controllers/realms_controller_test.rb",
          "status": "modified",
          "additions": 5,
          "deletions": 3,
          "patch": "@@ -36,9 +36,11 @@ def test_update_invalid\n \n   def test_update_valid\n     Realm.any_instance.stubs(:valid?).returns(true)\n-    put :update, {:id => Realm.first.name,\n-                  :realm => { :realm_proxy_id => SmartProxy.first.id } }, set_session_user\n-    assert_equal SmartProxy.first.id, Realm.first.realm_proxy_id\n+    realm_id = Realm.unscoped.first.id\n+    proxy_id = SmartProxy.unscoped.first.id\n+    put :update, {:id => realm_id,\n+                  :realm => { :realm_proxy_id => proxy_id } }, set_session_user\n+    assert_equal proxy_id, Realm.unscoped.find(realm_id).realm_proxy_id\n     assert_redirected_to realms_url\n   end\n "
        },
        {
          "filename": "test/controllers/smart_proxies_controller_test.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -38,8 +38,9 @@ def test_update_invalid\n \n   def test_update_valid\n     SmartProxy.any_instance.stubs(:valid?).returns(true)\n-    put :update, {:id => SmartProxy.first,:smart_proxy => {:url => \"http://elsewhere.com:8443\"}}, set_session_user\n-    assert_equal \"http://elsewhere.com:8443\", SmartProxy.first.url\n+    put :update, {:id => SmartProxy.unscoped.first,\n+                  :smart_proxy => {:url => \"http://elsewhere.com:8443\"}}, set_session_user\n+    assert_equal \"http://elsewhere.com:8443\", SmartProxy.unscoped.first.url\n     assert_redirected_to smart_proxies_url\n   end\n "
        },
        {
          "filename": "test/controllers/subnets_controller_test.rb",
          "status": "modified",
          "additions": 12,
          "deletions": 12,
          "patch": "@@ -2,7 +2,7 @@\n \n class SubnetsControllerTest < ActionController::TestCase\n   setup do\n-    @model = Subnet.first\n+    @model = subnets(:one)\n   end\n \n   basic_index_test\n@@ -27,32 +27,32 @@ def test_create_valid_with_type\n \n   def test_update_invalid\n     Subnet.any_instance.stubs(:valid?).returns(false)\n-    put :update, {:id => Subnet.first, :subnet => {:network => nil}}, set_session_user\n+    subnet_id = @model\n+    put :update, {:id => subnet_id, :subnet => {:network => nil}}, set_session_user\n     assert_template 'edit'\n   end\n \n   def test_update_valid\n     Subnet.any_instance.stubs(:valid?).returns(true)\n-    put :update, {:id => Subnet.first, :subnet => {:network => '192.168.100.10'}}, set_session_user\n-    assert_equal '192.168.100.10', Subnet.first.network\n+    put :update, {:id => @model, :subnet => {:network => '192.168.100.10'}}, set_session_user\n+    assert_equal '192.168.100.10', Subnet.unscoped.find(@model).network\n     assert_redirected_to subnets_url\n   end\n \n   def test_should_not_destroy_if_used_by_hosts\n     subnet = subnets(:one)\n     delete :destroy, {:id => subnet}, set_session_user\n     assert_redirected_to subnets_url\n-    assert Subnet.exists?(subnet.id)\n+    assert Subnet.unscoped.exists?(subnet.id)\n   end\n \n   def test_destroy\n-    subnet = Subnet.first\n-    subnet.hosts.clear\n-    subnet.interfaces.clear\n-    subnet.domains.clear\n-    delete :destroy, {:id => subnet}, set_session_user\n+    @model.hosts.clear\n+    @model.interfaces.clear\n+    @model.domains.clear\n+    delete :destroy, {:id => @model}, set_session_user\n     assert_redirected_to subnets_url\n-    assert !Subnet.exists?(subnet.id)\n+    refute Subnet.exists?(@model.id)\n   end\n \n   context 'freeip' do\n@@ -153,7 +153,7 @@ def test_destroy\n                     :cidr => sample_subnet.cidr,\n                     :ipam => sample_subnet.ipam,\n                     :boot_mode => sample_subnet.boot_mode }\n-    assert_difference 'Subnet.count', 1 do\n+    assert_difference 'Subnet.unscoped.count', 1 do\n       post :create_multiple, { :subnets => [subnet_hash] }, set_session_user\n     end\n     assert_response :redirect"
        },
        {
          "filename": "test/controllers/unattended_controller_test.rb",
          "status": "modified",
          "additions": 10,
          "deletions": 3,
          "patch": "@@ -289,6 +289,8 @@ class UnattendedControllerTest < ActionController::TestCase\n       @secret_param = FactoryGirl.create(:host_parameter, :host => @rh_host, :name => 'secret_param')\n       setup_user 'view', 'hosts'\n       setup_user 'view', 'params', 'name = my_param'\n+      users(:one).organizations << @rh_host.organization\n+      users(:one).locations << @rh_host.location\n       @rh_host.provisioning_template(:kind => :provision).update_attribute(:template, \"params: <%= @host.params['my_param'] %>, <%= @host.params['secret_param'] %>\")\n     end\n \n@@ -438,16 +440,21 @@ class UnattendedControllerTest < ActionController::TestCase\n   end\n \n   test 'should render a template to user with valid filter' do\n-    user = FactoryGirl.create(:user, :with_mail, :admin => false)\n-    FactoryGirl.create(:filter, :role => user.roles.first, :permissions => Permission.where(:name => 'view_hosts'), :search => \"name = #{@rh_host.name}\")\n+    user = FactoryGirl.create(:user, :with_mail, :admin => false,\n+                              :organizations => [@org], :locations => [@loc])\n+    FactoryGirl.create(:filter, :role => user.roles.first,\n+                       :permissions => Permission.where(:name => 'view_hosts'),\n+                       :search => \"name = #{@rh_host.name}\")\n     get :host_template, {:kind => 'PXELinux', :spoof => @rh_host.ip, :format => 'text'}, set_session_user(user)\n     assert_response :success\n     assert @response.body.include?(\"linux\")\n   end\n \n   test 'should not render a template to user with invalid filter' do\n     user = FactoryGirl.create(:user, :with_mail, :admin => false)\n-    FactoryGirl.create(:filter, :role => user.roles.first, :permissions => Permission.where(:name => 'view_hosts'), :search => \"name = does_not_exist\")\n+    FactoryGirl.create(:filter, :role => user.roles.first,\n+                       :permissions => Permission.where(:name => 'view_hosts'),\n+                       :search => \"name = does_not_exist\")\n     get :host_template, {:kind => 'PXELinux', :spoof => @rh_host.ip, :format => 'text'}, set_session_user(user)\n     assert_response :not_found\n     assert_match /unable to find a host/, @response.body"
        },
        {
          "filename": "test/controllers/users_controller_test.rb",
          "status": "modified",
          "additions": 17,
          "deletions": 14,
          "patch": "@@ -32,7 +32,7 @@ class UsersControllerTest < ActionController::TestCase\n       }\n     }, set_session_user\n     assert_redirected_to users_path\n-    refute User.find_by_login('foo').admin\n+    refute User.unscoped.find_by_login('foo').admin\n   end\n \n   test 'should create admin user' do\n@@ -46,14 +46,14 @@ class UsersControllerTest < ActionController::TestCase\n       }\n     }, set_session_user\n     assert_redirected_to users_path\n-    assert User.find_by_login('foo').admin\n+    assert User.unscoped.find_by_login('foo').admin\n   end\n \n   test \"should update user\" do\n     user = User.create :login => \"foo\", :mail => \"foo@bar.com\", :auth_source => auth_sources(:one)\n \n     put :update, { :id => user.id, :user => {:login => \"johnsmith\"} }, set_session_user\n-    mod_user = User.find_by_id(user.id)\n+    mod_user = User.unscoped.find_by_id(user.id)\n \n     assert mod_user.login == \"johnsmith\"\n     assert_redirected_to users_path\n@@ -63,7 +63,7 @@ class UsersControllerTest < ActionController::TestCase\n     user = FactoryGirl.create(:user, :with_mail)\n     notification = FactoryGirl.create(:mail_notification)\n     put :update, { :id => user.id, :user => {:user_mail_notifications_attributes => {'0' => {:mail_notification_id => notification.id, :interval => 'Subscribe'}}}}, set_session_user\n-    user = User.find_by_id(user.id)\n+    user = User.unscoped.find_by_id(user.id)\n     assert user.mail_notifications.include? notification\n   end\n \n@@ -86,7 +86,7 @@ class UsersControllerTest < ActionController::TestCase\n     assert user.roles =([roles(:default_role)])\n \n     put :update, { :id => user.id, :user => {:login => \"johnsmith\"} }, set_session_user\n-    mod_user = User.find_by_id(user.id)\n+    mod_user = User.unscoped.find_by_id(user.id)\n \n     assert mod_user.roles =([roles(:default_role)])\n   end\n@@ -101,7 +101,8 @@ class UsersControllerTest < ActionController::TestCase\n                     :login => \"johnsmith\", :password => \"dummy\", :password_confirmation => \"dummy\"\n                   }\n                  }, set_session_user\n-    mod_user = User.find_by_id(user.id)\n+\n+    mod_user = User.unscoped.find_by_id(user.id)\n \n     assert mod_user.matching_password?(\"dummy\")\n     assert_redirected_to users_path\n@@ -117,7 +118,6 @@ class UsersControllerTest < ActionController::TestCase\n                     :login => \"johnsmith\", :password => \"dummy\", :password_confirmation => \"DUMMY\"\n                   }\n                  }, set_session_user\n-\n     user.reload\n     assert user.matching_password?(\"changeme\")\n     assert_template :edit\n@@ -176,7 +176,7 @@ class UsersControllerTest < ActionController::TestCase\n     user.update_attribute :admin, true\n     delete :destroy, {:id => user.id}, set_session_user.merge(:user => user.id)\n     assert_redirected_to users_url\n-    assert User.exists?(user.id)\n+    assert User.unscoped.exists?(user.id)\n     assert @request.flash[:notice] == \"You cannot delete this user while logged in as this user.\"\n   end\n \n@@ -206,7 +206,7 @@ class UsersControllerTest < ActionController::TestCase\n       \"id\"     => user.id}\n     put :update, update_hash, set_session_user.merge(:user => user.id)\n \n-    assert !User.find_by_login(user.login).mail.blank?\n+    assert !User.unscoped.find_by_login(user.login).mail.blank?\n   end\n \n   test \"should login external user\" do\n@@ -243,7 +243,7 @@ class UsersControllerTest < ActionController::TestCase\n     @request.session.clear\n     @request.env['REMOTE_USER'] = 'ares'\n     get :extlogin, {}, {}\n-    assert_redirected_to edit_user_path(User.find_by_login('ares'))\n+    assert_redirected_to edit_user_path(User.unscoped.find_by_login('ares'))\n   end\n \n   test \"should use intercept if available\" do\n@@ -283,7 +283,7 @@ class UsersControllerTest < ActionController::TestCase\n \n   test 'user with edit permission should be able to edit another user' do\n     setup_user 'edit', 'users'\n-    get :edit, { :id => users(:two) }\n+    get :edit, { :id => users(:two) }, set_session_user\n     assert_response :success\n   end\n \n@@ -295,7 +295,8 @@ class UsersControllerTest < ActionController::TestCase\n \n   test 'user with update permission should be able to update another user' do\n     setup_user 'edit', 'users'\n-    put :update, { :id => users(:two).id, :user => { :firstname => 'test' } }\n+    put :update, { :id => users(:two).id, :user => { :firstname => 'test' } },\n+      set_session_user\n \n     assert_response :redirect\n   end\n@@ -351,12 +352,14 @@ class UsersControllerTest < ActionController::TestCase\n     attrs = {:firstname=>\"foo\", :mail=>\"foo#bar\", :login=>\"ldap-user\", :auth_source_id=>auth_sources(:one).id}\n     AuthSourceLdap.any_instance.stubs(:authenticate).returns(attrs)\n     AuthSourceLdap.any_instance.stubs(:update_usergroups).returns(true)\n+    AuthSourceLdap.any_instance.stubs(:organizations).returns([taxonomies(:organization1)])\n+    AuthSourceLdap.any_instance.stubs(:locations).returns([taxonomies(:location1)])\n     post :login, {:login => {'login' => 'ldap-user', 'password' => 'password'}}\n     assert_redirected_to hosts_path\n     assert_match /mail.*invalid/i, flash[:warning]\n \n     # Subsequent redirects to the user edit page should preserve the warning\n-    user = User.find_by_login('ldap-user')\n+    user = User.unscoped.find_by_login('ldap-user')\n     get :index, {}, set_session_user.merge(:user => user.id)\n     assert_redirected_to edit_user_path(user)\n \n@@ -429,7 +432,7 @@ class UsersControllerTest < ActionController::TestCase\n                                 :default_organization_id => taxonomies(:organization1).id } }\n       assert_redirected_to users_path\n \n-      updated_user = User.find(users(:one).id)\n+      updated_user = User.unscoped.find(users(:one).id)\n       assert_equal taxonomies(:location1),     updated_user.default_location\n       assert_equal taxonomies(:organization1), updated_user.default_organization\n     end"
        },
        {
          "filename": "test/controllers/variable_lookup_keys_controller_test.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 7,
          "patch": "@@ -33,19 +33,14 @@ class VariableLookupKeysControllerTest < ActionController::TestCase\n     assert_redirected_to variable_lookup_keys_path\n   end\n \n-  def setup_user\n-    @request.session[:user] = users(:one).id\n-    users(:one).roles       = [Role.default, Role.find_by_name('Viewer')]\n-  end\n-\n   test 'user with viewer rights should fail to edit an external variable' do\n-    setup_user\n+    setup_users\n     get :edit, {:id => VariableLookupKey.first.id}, set_session_user.merge(:user => users(:one).id)\n     assert_equal response.status, 403\n   end\n \n   test 'user with viewer rights should succeed in viewing external variables' do\n-    setup_user\n+    setup_users\n     get :index, {}, set_session_user.merge(:user => users(:one).id)\n     assert_response :success\n   end"
        },
        {
          "filename": "test/factories/domain.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -6,6 +6,8 @@\n   factory :domain do\n     sequence(:name) {|n| \"example#{n}.com\" }\n     fullname { |n| n.name }\n+    organizations { [Organization.find_by_name('Organization 1')] } if SETTINGS[:organizations_enabled]\n+    locations { [Location.find_by_name('Location 1')] } if SETTINGS[:locations_enabled]\n \n     trait :with_parameter do\n       after(:create) do |domain,evaluator|"
        },
        {
          "filename": "test/factories/host_related.rb",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -17,6 +17,8 @@ def set_nic_attributes(host, attributes, evaluator)\n     sequence(:name) { |n| \"ptable#{n}\" }\n     layout 'zerombr\\nclearpart --all    --initlabel\\npart /boot --fstype ext3 --size=<%= 10 * 10 %> --asprimary\\npart /     --f   stype ext3 --size=1024 --grow\\npart swap  --recommended'\n     os_family 'Redhat'\n+    organizations { [Organization.find_by_name('Organization 1')] } if SETTINGS[:organizations_enabled]\n+    locations { [Location.find_by_name('Location 1')] } if SETTINGS[:locations_enabled]\n \n     trait :ubuntu do\n       sequence(:name) { |n| \"ubuntu default#{n}\" }\n@@ -110,6 +112,8 @@ def set_nic_attributes(host, attributes, evaluator)\n     sequence(:name) { |n| \"host#{n}\" }\n     sequence(:hostname) { |n| \"host#{n}\" }\n     root_pass 'xybxa6JUkz63w'\n+    organization { Organization.find_by_name('Organization 1') } if SETTINGS[:organizations_enabled]\n+    location { Location.find_by_name('Location 1') } if SETTINGS[:locations_enabled]\n \n     # This allows a test to declare build/create(:host, :ip => '1.2.3.4') and\n     # have the primary interface correctly updated with the specified attrs\n@@ -232,8 +236,6 @@ def set_nic_attributes(host, attributes, evaluator)\n       architecture { operatingsystem.try(:architectures).try(:first) }\n       medium { operatingsystem.try(:media).try(:first) }\n       ptable { operatingsystem.try(:ptables).try(:first) }\n-      location\n-      organization\n       domain\n       interfaces { [ FactoryGirl.build(:nic_primary_and_provision) ] }\n       association :operatingsystem, :with_associations\n@@ -431,6 +433,8 @@ def set_nic_attributes(host, attributes, evaluator)\n \n   factory :hostgroup do\n     sequence(:name) { |n| \"hostgroup#{n}\" }\n+    organizations { [Organization.find_by_name('Organization 1')] } if SETTINGS[:organizations_enabled]\n+    locations { [Location.find_by_name('Location 1')] } if SETTINGS[:locations_enabled]\n \n     trait :with_parent do\n       association :parent, :factory => :hostgroup"
        },
        {
          "filename": "test/factories/smart_proxy.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -2,6 +2,9 @@\n   factory :smart_proxy do\n     sequence(:name) {|n| \"proxy#{n}\" }\n     sequence(:url) {|n| \"https://somewhere#{n}.net:8443\" }\n+    organizations { [Organization.find_by_name('Organization 1')] } if SETTINGS[:organizations_enabled]\n+    locations { [Location.find_by_name('Location 1')] } if SETTINGS[:locations_enabled]\n+\n     before(:create, :build, :build_stubbed) do\n       ProxyAPI::Features.any_instance.stubs(:features => Feature.name_map.keys)\n     end"
        },
        {
          "filename": "test/factories/subnet.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -6,6 +6,8 @@\n   factory :subnet do\n     sequence(:name) {|n| \"subnet#{n}\" }\n     ipam \"None\"\n+    organizations { [Organization.find_by_name('Organization 1')] } if SETTINGS[:organizations_enabled]\n+    locations { [Location.find_by_name('Location 1')] } if SETTINGS[:locations_enabled]\n \n     trait :tftp do\n       association :tftp, :factory => :template_smart_proxy"
        },
        {
          "filename": "test/factories/user_related.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -14,6 +14,8 @@\n     auth_source { AuthSourceInternal.first }\n     password 'password'\n     sequence(:login) {|n| \"user#{n}\" }\n+    organizations { [ Organization.find_by_name('Organization 1') ] }\n+    locations { [ Location.find_by_name('Location 1') ] }\n \n     trait :admin do\n       admin { true }"
        },
        {
          "filename": "test/fixtures/taxable_taxonomies.yml",
          "status": "modified",
          "additions": 60,
          "deletions": 20,
          "patch": "@@ -4,21 +4,11 @@\n # model remove the '{}' from the fixture names and add the columns immediately\n # below each fixture, per the syntax in the comments below\n #\n-one:\n-  taxonomy: location1\n-  taxable: one\n-  taxable_type: \"Subnet\"\n-\n two:\n   taxonomy: location1\n   taxable: one\n   taxable_type: \"SmartProxy\"\n \n-three:\n-  taxonomy: organization1\n-  taxable: one\n-  taxable_type: \"Subnet\"\n-\n four:\n   taxonomy: organization1\n   taxable: one\n@@ -54,16 +44,6 @@ nine:\n   taxable: mydomain\n   taxable_type: \"Domain\"\n \n-ten:\n-  taxonomy: location1\n-  taxable: one\n-  taxable_type: \"Medium\"\n-\n-ten2:\n-  taxonomy: organization1\n-  taxable: one\n-  taxable_type: \"Medium\"\n-\n eleven:\n   taxonomy: location1\n   taxable: one\n@@ -153,3 +133,63 @@ scoped_user_location1:\n   taxonomy: location1\n   taxable: scoped\n   taxable_type: User\n+\n+user_one_org:\n+  taxonomy: organization1\n+  taxable: one\n+  taxable_type: \"User\"\n+\n+user_one_loc:\n+  taxonomy: location1\n+  taxable: one\n+  taxable_type: \"User\"\n+\n+subnet_one_org:\n+  taxonomy: organization1\n+  taxable: one\n+  taxable_type: \"Subnet\"\n+\n+subnet_one_loc:\n+  taxonomy: location1\n+  taxable: one\n+  taxable_type: \"Subnet\"\n+\n+compute_mycompute_org:\n+  taxonomy: organization1\n+  taxable: mycompute\n+  taxable_type: \"ComputeResource\"\n+\n+compute_mycompute_loc:\n+  taxonomy: location1\n+  taxable: mycompute\n+  taxable_type: \"ComputeResource\"\n+\n+hostgroup_common_org:\n+  taxonomy: organization1\n+  taxable: common\n+  taxable_type: \"Hostgroup\"\n+\n+hostgroup_common_loc:\n+  taxonomy: location1\n+  taxable: common\n+  taxable_type: \"Hostgroup\"\n+\n+medium_one_org:\n+  taxonomy: organization1\n+  taxable: one\n+  taxable_type: \"Medium\"\n+\n+medium_one_loc:\n+  taxonomy: location1\n+  taxable: one\n+  taxable_type: \"Medium\"\n+\n+auth_source_ldap_one_org:\n+  taxonomy: organization1\n+  taxable: one\n+  taxable_type: \"AuthSource\"\n+\n+auth_source_ldap_one_loc:\n+  taxonomy: location1\n+  taxable: one\n+  taxable_type: \"AuthSource\""
        },
        {
          "filename": "test/integration/location_test.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -2,7 +2,7 @@\n \n class LocationIntegrationTest < ActionDispatch::IntegrationTest\n   def setup\n-    FactoryGirl.create(:host)\n+    FactoryGirl.create(:host, :location => nil)\n   end\n \n   test \"index page\" do\n@@ -35,7 +35,7 @@ def setup\n \n   # content - click Assign All\n   test \"create new page when some hosts are not assigned a location and click Assign All\" do\n-    assert_new_button(locations_path,\"New Location\",new_location_path)\n+    assert_new_button(locations_path, \"New Location\", new_location_path)\n     fill_in \"location_name\", :with => \"Raleigh\"\n     click_button \"Submit\"\n     assert_current_path step2_location_path(Location.unscoped.order(:id).last)"
        },
        {
          "filename": "test/integration/organization_test.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -2,7 +2,7 @@\n \n class OrganizationIntegrationTest < ActionDispatch::IntegrationTest\n   def setup\n-    FactoryGirl.create(:host)\n+    FactoryGirl.create(:host, :organization => nil)\n   end\n \n   test \"index page\" do"
        },
        {
          "filename": "test/models/concerns/api_taxonomy_scope_test.rb",
          "status": "modified",
          "additions": 0,
          "deletions": 3,
          "patch": "@@ -42,7 +42,6 @@ class ApiTaxonomyScopeTest < ActiveSupport::TestCase\n     end\n \n     test \"set_taxonomy_scope respects user association to orgs and locs, fails on not allowed organization\" do\n-      users(:one).locations << taxonomies(:location1)\n       Location.expects(:my_locations).returns(Location.where(:id => taxonomies(:location1).id))\n       Organization.expects(:my_organizations).returns(Organization.where(:id => nil))\n       @dummy.expects(:not_found)\n@@ -52,8 +51,6 @@ class ApiTaxonomyScopeTest < ActiveSupport::TestCase\n     end\n \n     test \"set_taxonomy_scope respects user association to orgs and locs, sets both if allowed\" do\n-      users(:one).locations << taxonomies(:location1)\n-      users(:one).organizations << taxonomies(:organization1)\n       Location.expects(:my_locations).returns(Location.where(:id => taxonomies(:location1).id))\n       Organization.expects(:my_organizations).returns(Organization.where(:id => taxonomies(:organization1).id))\n       as_user :one do"
        },
        {
          "filename": "test/models/fact_value_test.rb",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -120,7 +120,13 @@ def setup\n \n     test 'returns visible facts for unlimited user' do\n       user_role = FactoryGirl.create(:user_user_role)\n-      FactoryGirl.create(:filter, :role => user_role.role, :permissions => Permission.where(:name => 'view_hosts'), :unlimited => true)\n+      FactoryGirl.create(:filter, :role => user_role.role,\n+                         :permissions => Permission.unscoped.where(:name => 'view_hosts'),\n+                         :unlimited => true)\n+      target_host.organization = user_role.owner.organizations.first\n+      target_host.location = user_role.owner.locations.first\n+      other_host.organization = user_role.owner.organizations.first\n+      other_host.location = user_role.owner.locations.first\n       as_user user_role.owner do\n         assert_empty (target_host.fact_values + other_host.fact_values).map(&:id) - FactValue.my_facts.map(&:id)\n       end"
        },
        {
          "filename": "test/models/host_test.rb",
          "status": "modified",
          "additions": 5,
          "deletions": 2,
          "patch": "@@ -175,10 +175,12 @@ def teardown\n   test \"non-admin user should be able to create host with new lookup value\" do\n     User.current = users(:one)\n     User.current.roles << [roles(:manager)]\n-    assert_difference('LookupValue.count') do\n+    assert_difference('LookupValue.unscoped.count') do\n       assert Host.create! :name => \"abc.mydomain.net\", :mac => \"aabbecddeeff\", :ip => \"3.3.4.3\",\n       :domain => domains(:mydomain), :operatingsystem => operatingsystems(:redhat),\n-      :subnet => subnets(:two), :architecture => architectures(:x86_64), :puppet_proxy => smart_proxies(:puppetmaster), :medium => media(:one),\n+      :subnet => subnets(:two), :architecture => architectures(:x86_64),\n+      :puppet_proxy => smart_proxies(:puppetmaster), :medium => media(:one),\n+      :organization => nil, :location => nil,\n       :environment => environments(:production), :disk => \"empty partition\",\n       :lookup_values_attributes => {\"new_123456\" => {\"lookup_key_id\" => lookup_keys(:complex).id, \"value\"=>\"some_value\", \"match\" => \"fqdn=abc.mydomain.net\"}}\n     end\n@@ -655,6 +657,7 @@ def teardown\n     org2 = FactoryGirl.create(:organization)\n     org3 = FactoryGirl.create(:organization)\n     user = FactoryGirl.create(:user, :organizations => [org1, org2])\n+    users(:one).organizations << [org1, org2, org3]\n     host1 = FactoryGirl.create(:host, :organization => org1)\n     host2 = FactoryGirl.create(:host, :organization => org2)\n     host3 = FactoryGirl.create(:host, :organization => org3)"
        },
        {
          "filename": "test/models/nic_test.rb",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -59,7 +59,13 @@ def teardown\n   test \"should delegate subnet attributes\" do\n     subnet = subnets(:two)\n     domain = (subnet.domains.any? ? subnet.domains : subnet.domains << Domain.first).first\n-    interface = Nic::Managed.create! :ip => \"3.3.4.127\", :mac => \"cabbccddeeff\", :host => FactoryGirl.create(:host), :subnet => subnet, :name => \"a\" + FactoryGirl.create(:host).name, :domain => domain\n+    interface = FactoryGirl.build(:nic_managed,\n+                                  :ip => \"3.3.4.127\",\n+                                  :mac => \"cabbccddeeff\",\n+                                  :host => FactoryGirl.create(:host),\n+                                  :subnet => subnet,\n+                                  :name => \"a\" + FactoryGirl.create(:host).name,\n+                                  :domain => domain)\n     assert_equal subnet.network, interface.network\n     assert_equal subnet.vlanid, interface.vlanid\n   end"
        },
        {
          "filename": "test/models/report_test.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 5,
          "patch": "@@ -41,11 +41,9 @@ def setup\n     end\n \n     test 'returns visible reports for filtered user' do\n-      user_role = FactoryGirl.create(:user_user_role)\n-      FactoryGirl.create(:filter, :role => user_role.role, :permissions => Permission.where(:name => 'view_hosts'), :search => \"hostgroup_id = #{@target_host.hostgroup_id}\")\n-      as_user user_role.owner do\n-        assert_equal @target_reports.map(&:id).sort, Report.my_reports.map(&:id).sort\n-      end\n+      setup_user('view', 'hosts',\n+                 \"hostgroup_id = #{@target_host.hostgroup_id}\")\n+      assert_equal @target_reports.map(&:id).sort, Report.my_reports.map(&:id).sort\n     end\n \n     test \"only return reports from host in user's taxonomies\" do"
        },
        {
          "filename": "test/models/shared/taxonomies_base_test.rb",
          "status": "modified",
          "additions": 19,
          "deletions": 16,
          "patch": "@@ -52,6 +52,7 @@ module TaxonomiesBaseTest\n     test 'it should return array of used ids by hosts' do\n       taxonomy = taxonomies(:\"#{taxonomy_name}1\")\n       subnet = FactoryGirl.create(:subnet_ipv4,\n+                                  :\"#{opposite_taxonomy}_ids\" => [],\n                                   :\"#{taxonomy_name.pluralize}\" => [taxonomy])\n       domain = FactoryGirl.create(:domain)\n       FactoryGirl.create(:host,\n@@ -126,24 +127,24 @@ module TaxonomiesBaseTest\n       # check if they match\n       assert_equal selected_ids[:environment_ids].sort, environment_ids.sort\n       assert_equal selected_ids[:hostgroup_ids].sort, hostgroup_ids.sort\n-      assert_equal selected_ids[:subnet_ids].sort, subnet_ids.sort\n+      assert_equal selected_ids[:subnet_ids].sort, subnet_ids.uniq.sort\n       assert_equal selected_ids[:domain_ids].sort, domain_ids.sort\n       assert_equal selected_ids[:realm_ids].sort, realm_ids.sort\n-      assert_equal selected_ids[:medium_ids].sort, medium_ids.sort\n+      assert_equal selected_ids[:medium_ids].sort, medium_ids.uniq.sort\n       assert_equal selected_ids[:user_ids].sort, user_ids.sort\n       assert_equal selected_ids[:smart_proxy_ids].sort, smart_proxy_ids.sort\n       assert_equal selected_ids[:provisioning_template_ids].sort, provisioning_template_ids.sort\n       assert_equal selected_ids[:compute_resource_ids].sort, compute_resource_ids.sort\n       # match to manually generated taxable_taxonomies\n       assert_equal selected_ids[:environment_ids], [environments(:production).id]\n-      assert_equal selected_ids[:hostgroup_ids], []\n+      assert_equal selected_ids[:hostgroup_ids], [hostgroups(:common).id]\n       assert_equal selected_ids[:subnet_ids], [subnets(:one).id]\n       assert_equal selected_ids[:domain_ids], [domains(:mydomain).id, domains(:yourdomain).id]\n       assert_equal selected_ids[:medium_ids], [media(:one).id]\n-      assert_equal selected_ids[:user_ids], [users(:scoped).id]\n+      assert_equal selected_ids[:user_ids], [users(:one).id, users(:scoped).id]\n       assert_equal selected_ids[:smart_proxy_ids].sort, [smart_proxies(:puppetmaster).id, smart_proxies(:one).id, smart_proxies(:two).id, smart_proxies(:three).id, smart_proxies(:realm).id].sort\n       assert_equal selected_ids[:provisioning_template_ids], [templates(:mystring2).id]\n-      assert_equal selected_ids[:compute_resource_ids], [compute_resources(:one).id]\n+      assert_equal selected_ids[:compute_resource_ids], [compute_resources(:one).id, compute_resources(:mycompute).id]\n     end\n \n     test 'it should return selected_ids array of ALL values (when types are ignored)' do\n@@ -168,8 +169,8 @@ module TaxonomiesBaseTest\n     test \"it should clone organization with all associations\" do\n       taxonomy = taxonomies(:\"#{taxonomy_name}1\")\n       taxonomy_dup = taxonomy.dup\n-      taxonomy_dup.name = \"taxonomy_dup_name\"\n-      assert taxonomy_dup.save!\n+      taxonomy_dup.name = \"taxonomy_dup_name_#{rand}\"\n+      assert taxonomy_dup.save\n       assert_equal taxonomy_dup.environment_ids, taxonomy.environment_ids\n       assert_equal taxonomy_dup.hostgroup_ids, taxonomy.hostgroup_ids\n       assert_equal taxonomy_dup.subnet_ids, taxonomy.subnet_ids\n@@ -213,7 +214,7 @@ module TaxonomiesBaseTest\n       as_admin do\n         assert_equal expected.sort,\n           taxonomy_class.public_send(:\"my_#{taxonomy_name.pluralize}\",\n-                                     users(:one)).pluck(:id).sort\n+                                     users(:one)).sort\n       end\n     end\n \n@@ -238,7 +239,9 @@ module TaxonomiesBaseTest\n       parent = taxonomies(:\"#{taxonomy_name}1\")\n       taxonomy = taxonomy_class.create :name => \"rack1\", :parent_id => parent.id\n       # check that inherited_ids of taxonomy matches selected_ids of parent\n-      assert_equal parent.selected_ids, taxonomy.inherited_ids\n+      as_admin do\n+        assert_equal parent.selected_ids, taxonomy.inherited_ids\n+      end\n     end\n \n     test \"selected_or_inherited_ids for inherited taxonomy\" do\n@@ -258,8 +261,8 @@ module TaxonomiesBaseTest\n       subnet = FactoryGirl.create(:subnet_ipv4, :organizations => [taxonomies(:organization1)])\n       domain1 = FactoryGirl.create(:domain)\n       domain2 = FactoryGirl.create(:domain)\n-      parent.update_attribute(:domains,[domain1,domain2])\n-      parent.update_attribute(:subnets,[subnet])\n+      parent.update_attribute(:domains, [domain1, domain2])\n+      parent.update_attribute(:subnets, [subnet])\n       # we're no longer using the fixture dhcp/dns/tftp proxy to create the host, so remove them\n       parent.update_attribute(:smart_proxies,[smart_proxies(:puppetmaster),smart_proxies(:realm)])\n \n@@ -268,7 +271,7 @@ module TaxonomiesBaseTest\n                          :compute_resource => compute_resources(:one),\n                          :domain           => domain1,\n                          :environment      => environments(:production),\n-                         :\"#{taxonomy_name}\"         => parent,\n+                         :\"#{taxonomy_name}\" => parent,\n                          :organization     => taxonomies(:organization1),\n                          :medium           => media(:one),\n                          :operatingsystem  => operatingsystems(:centos5_3),\n@@ -277,16 +280,16 @@ module TaxonomiesBaseTest\n                          :realm            => realms(:myrealm),\n                          :subnet           => subnet)\n       FactoryGirl.create(:host,\n-                         :\"#{taxonomy_name}\"         => parent,\n+                         :\"#{taxonomy_name}\" => parent,\n                          :domain           => domain2)\n       FactoryGirl.create(:os_default_template,\n                          :provisioning_template  => templates(:mystring2),\n                          :operatingsystem  => operatingsystems(:centos5_3),\n                          :template_kind    => TemplateKind.find_by_name('provision'))\n \n       # check that inherited_ids of taxonomy matches selected_ids of parent\n-      taxonomy.selected_or_inherited_ids.each do |k,v|\n-        assert_equal v.sort, parent.used_and_selected_ids[k].sort\n+      taxonomy.inherited_ids.each do |k,v|\n+        assert_equal v.sort, parent.selected_ids[k].sort\n       end\n     end\n \n@@ -299,7 +302,7 @@ module TaxonomiesBaseTest\n       end\n     end\n \n-    test \"multiple inheritence\" do\n+    test \"multiple inheritance\" do\n       parent1 = taxonomies(:\"#{taxonomy_name}1\")\n       assert_equal [subnets(:one).id], parent1.selected_ids[\"subnet_ids\"]\n "
        },
        {
          "filename": "test/models/subnet/ipv6_test.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -26,7 +26,7 @@ def setup\n \n   test \"should find the subnet by ip\" do\n     subnet = FactoryGirl.create(:subnet_ipv6)\n-    assert_equal subnet, Subnet::Ipv6.subnet_for(get_ip(subnet, 10))\n+    assert_equal subnet, Subnet::Ipv6.unscoped.subnet_for(get_ip(subnet, 10))\n   end\n \n   test \"from cant be bigger than to range\" do"
        },
        {
          "filename": "test/models/subnet_test.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -96,7 +96,7 @@ class Subnet::Test < Subnet; end\n     hostgroup = FactoryGirl.create(:hostgroup, :with_subnet)\n     subnet = hostgroup.subnet\n     refute subnet.destroy\n-    assert_match /is being used by/, subnet.errors.full_messages.join(\"\\n\")\n+    assert_match /is used by/, subnet.errors.full_messages.join(\"\\n\")\n   end\n \n   test \"should not destroy if host uses it\" do"
        },
        {
          "filename": "test/models/taxonomix_test.rb",
          "status": "modified",
          "additions": 104,
          "deletions": 44,
          "patch": "@@ -70,7 +70,8 @@ def setup\n     test 'expands organizations and locations to actual values' do\n       org2 = FactoryGirl.create(:organization)\n       org3 = FactoryGirl.create(:organization)\n-      user = FactoryGirl.create(:user, :organizations => [@org, org2])\n+      user = FactoryGirl.create(:user, :organizations => [@org, org2],\n+                                :locations => [])\n \n       as_user(user) do\n         @dummy.class.with_taxonomy_scope(nil, nil)\n@@ -162,47 +163,67 @@ def setup\n     assert_includes used_organizations, org4.id\n   end\n \n-  test \".taxable_ids can work with empty array returning nil\" do\n-    dummy_class = @dummy.class\n-    assert_nil dummy_class.taxable_ids([], [])\n-  end\n+  describe '#taxable_ids' do\n+    test \"can work with empty array returning nil\" do\n+      assert_nil @dummy.class.taxable_ids([], [])\n+    end\n \n-  test \".taxable_ids (and .inner_select) can work with array of taxonomies\" do\n-    loc1 = FactoryGirl.create(:location)\n-    loc2 = FactoryGirl.create(:location, :parent_id => loc1.id)\n-    loc3 = FactoryGirl.create(:location, :parent_id => loc2.id)\n-    loc4 = FactoryGirl.create(:location)\n-    org = FactoryGirl.create(:organization)\n-    env1 = FactoryGirl.create(:environment, :organizations => [org], :locations => [loc2])\n-    env2 = FactoryGirl.create(:environment, :organizations => [org])\n-    env3 = FactoryGirl.create(:environment, :locations => [loc2])\n-    env4 = FactoryGirl.create(:environment, :locations => [loc4])\n-    env5 = FactoryGirl.create(:environment, :locations => [loc1])\n-    env6 = FactoryGirl.create(:environment, :locations => [loc3])\n-\n-    taxable_ids = Environment.taxable_ids([loc2, loc4], org, :subtree_ids)\n-    visible = [ env1 ]\n-    invisible = [ env2, env3, env4, env5, env6 ]\n-    visible.each { |env| assert_includes taxable_ids, env.id }\n-    invisible.each { |env| refute_includes taxable_ids, env.id }\n-\n-    taxable_ids = Environment.taxable_ids([], org, :subtree_ids)\n-    visible = [ env1, env2 ]\n-    invisible = [ env3, env4, env5, env6 ]\n-    visible.each { |env| assert_includes taxable_ids, env.id }\n-    invisible.each { |env| refute_includes taxable_ids, env.id }\n-\n-    taxable_ids = Environment.taxable_ids(loc2, [], :subtree_ids)\n-    visible = [ env1, env3, env5, env6 ]\n-    invisible = [ env2, env4 ]\n-    visible.each { |env| assert_includes taxable_ids, env.id }\n-    invisible.each { |env| refute_includes taxable_ids, env.id }\n-\n-    taxable_ids = Environment.taxable_ids([loc2, loc4], [], :subtree_ids)\n-    visible = [ env1, env3, env4, env5, env6 ]\n-    invisible = [ env2 ]\n-    visible.each { |env| assert_includes taxable_ids, env.id }\n-    invisible.each { |env| refute_includes taxable_ids, env.id }\n+    test 'returns IDs for non-admin user of any context when no org/loc' do\n+      assert @dummy.class.all.count > 1\n+\n+      as_user(:one) do\n+        any_org = User.current.organizations\n+        any_loc = User.current.locations\n+\n+        visible_dummies = any_org.map(&:\"#{@dummy.class.table_name}\").flatten.map(&:id) &\n+          any_loc.map(&:\"#{@dummy.class.table_name}\").flatten.map(&:id)\n+\n+        # We need to call '.taxable_ids' using the Environment class because\n+        # '.taxable_ids' will look for the 'taxable_taxonomies.taxable_type'\n+        # table of the caller.\n+        # Since TaxonomixDummy is defined in terms of the Environment table,\n+        # the table will have Environment, not TaxonomixDummy as taxable_type\n+        assert_equal visible_dummies, Environment.taxable_ids(nil, nil)\n+        assert_equal visible_dummies, Environment.taxable_ids([], [])\n+      end\n+    end\n+\n+    test \"can work with array of taxonomies\" do\n+      loc1 = FactoryGirl.create(:location)\n+      loc2 = FactoryGirl.create(:location, :parent_id => loc1.id)\n+      loc3 = FactoryGirl.create(:location, :parent_id => loc2.id)\n+      loc4 = FactoryGirl.create(:location)\n+      org = FactoryGirl.create(:organization)\n+      env1 = FactoryGirl.create(:environment, :organizations => [org], :locations => [loc2])\n+      env2 = FactoryGirl.create(:environment, :organizations => [org])\n+      env3 = FactoryGirl.create(:environment, :locations => [loc2])\n+      env4 = FactoryGirl.create(:environment, :locations => [loc4])\n+      env5 = FactoryGirl.create(:environment, :locations => [loc1])\n+      env6 = FactoryGirl.create(:environment, :locations => [loc3])\n+      taxable_ids = Environment.taxable_ids([loc2, loc4], org, :subtree_ids)\n+      visible = [ env1 ]\n+      invisible = [ env2, env3, env4, env5, env6 ]\n+      visible.each { |env| assert_includes taxable_ids, env.id }\n+      invisible.each { |env| refute_includes taxable_ids, env.id }\n+\n+      taxable_ids = Environment.taxable_ids([], org, :subtree_ids)\n+      visible = [ env1, env2 ]\n+      invisible = [ env3, env4, env5, env6 ]\n+      visible.each { |env| assert_includes taxable_ids, env.id }\n+      invisible.each { |env| refute_includes taxable_ids, env.id }\n+\n+      taxable_ids = Environment.taxable_ids(loc2, [], :subtree_ids)\n+      visible = [ env1, env3, env5, env6 ]\n+      invisible = [ env2, env4 ]\n+      visible.each { |env| assert_includes taxable_ids, env.id }\n+      invisible.each { |env| refute_includes taxable_ids, env.id }\n+\n+      taxable_ids = Environment.taxable_ids([loc2, loc4], [], :subtree_ids)\n+      visible = [ env1, env3, env4, env5, env6 ]\n+      invisible = [ env2 ]\n+      visible.each { |env| assert_includes taxable_ids, env.id }\n+      invisible.each { |env| refute_includes taxable_ids, env.id }\n+    end\n   end\n \n   test \"validation does not prevent taxonomy association if user does not have permissions of already assigned taxonomies\" do\n@@ -279,8 +300,47 @@ def setup\n     user = FactoryGirl.create(:user, :id => 25, :organizations => [org])\n     ugroup = FactoryGirl.create(:usergroup, :id=> 25)\n     FactoryGirl.create(:host, :owner => ugroup, :organization => org)\n-    used_organizations = user.used_organization_ids\n-    assert_empty used_organizations\n-    assert_equal used_organizations.count, 0\n+    as_admin do\n+      used_organizations = user.used_organization_ids\n+      assert_empty used_organizations\n+      assert_equal used_organizations.count, 0\n+    end\n+  end\n+\n+  context 'admin permissions' do\n+    test \"returns only visible objects when org/loc are selected\" do\n+      scoped_environments = Environment.\n+        with_taxonomy_scope([taxonomies(:organization1)])\n+      assert scoped_environments.include?(*taxonomies(:organization1).environments)\n+      assert_not_equal Environment.unscoped.all, scoped_environments\n+      assert_equal taxonomies(:organization1).environments, scoped_environments\n+    end\n+\n+    test \"returns nil (all objects) when there are no org/loc\" do\n+      assert_equal User.with_taxonomy_scope([],[]).sort, User.unscoped.all.sort\n+    end\n+  end\n+\n+  test 'current user ID and admin IDs are always visible' do\n+    as_user(:one) do\n+      scoped_users = User.with_taxonomy_scope([],[])\n+      assert_include scoped_users, User.current\n+      assert_include scoped_users, users(:admin)\n+    end\n+  end\n+\n+  test 'users can only see objects scoped to its current taxonomies' do\n+    # Environment in organization 1 and location 1 cannot be seen by an user\n+    # who is scoped to organization 1 and location 2\n+    users(:one).organizations = [taxonomies(:organization1)]\n+    users(:one).locations = [taxonomies(:location2)]\n+    unreachable_env = FactoryGirl.create(\n+      :environment,\n+      :organizations => [taxonomies(:organization1)],\n+      :locations => [taxonomies(:location1)])\n+\n+    as_user(:one) do\n+      assert_not_include Environment.all, unreachable_env\n+    end\n   end\n end"
        },
        {
          "filename": "test/models/taxonomy_test.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -64,7 +64,7 @@ def setup\n \n   test 'for non admin user, nil is expanded to [] if user is not assigned to any org' do\n     # we have to run on specific taxonomy because my_* is defined only in Organization and Location\n-    user = FactoryGirl.create(:user)\n+    user = FactoryGirl.create(:user, :organizations => [])\n     as_user(user) do\n       assert_equal [], Organization.expand(nil)\n       assert_equal [], Organization.expand([])"
        },
        {
          "filename": "test/models/user_test.rb",
          "status": "modified",
          "additions": 26,
          "deletions": 16,
          "patch": "@@ -113,15 +113,15 @@ def setup\n       user = users(:internal)\n       last_login = user.last_login_on\n       assert_not_nil User.try_to_login(user.login, \"changeme\")\n-      assert_not_equal last_login, User.find(user.id).last_login_on\n+      assert_not_equal last_login, User.unscoped.find(user.id).last_login_on\n     end\n \n     test \"updating the last login time must not persist invalid attributes\" do\n       user = FactoryGirl.create(:user, :with_mail, :auth_source => FactoryGirl.create(:auth_source_ldap))\n       AuthSourceLdap.any_instance.expects(:authenticate).returns(:mail => 'foo#bar')\n       AuthSourceLdap.any_instance.stubs(:update_usergroups).returns(true)\n       assert_not_nil User.try_to_login(user.login, \"changeme\")\n-      reloaded_user = User.find(user.id)\n+      reloaded_user = User.unscoped.find(user.id)\n       assert_not_equal user.last_login_on, reloaded_user.last_login_on\n       assert_equal user.mail, reloaded_user.mail\n     end\n@@ -209,7 +209,10 @@ def setup_user(operation)\n \n   test \"user with create permissions should be able to create\" do\n     setup_user \"create\"\n-    record = User.new :login => \"dummy\", :mail => \"j@j.com\", :auth_source_id => AuthSourceInternal.first.id\n+    record = User.new :login => \"dummy\", :mail => \"j@j.com\",\n+      :auth_source_id => AuthSourceInternal.first.id,\n+      :organizations => User.current.organizations,\n+      :locations => User.current.locations\n     record.password_hash = \"asd\"\n     assert record.save\n     assert record.valid?\n@@ -243,8 +246,11 @@ def setup_user(operation)\n   test \"non-admin user can delegate roles he has assigned already\" do\n     setup_user \"create\"\n     create_role          = Role.find_by_name 'create_users'\n-    record               = User.new :login    => \"dummy\", :mail => \"j@j.com\", :auth_source_id => AuthSourceInternal.first.id,\n-                                    :role_ids => [create_role.id.to_s]\n+    record               = User.new(:login => \"dummy\", :mail => \"j@j.com\",\n+      :auth_source_id => AuthSourceInternal.first.id,\n+      :role_ids => [create_role.id.to_s],\n+      :organizations => User.current.organizations,\n+      :locations => User.current.locations)\n     record.password_hash = \"asd\"\n     assert record.valid?\n     assert record.save\n@@ -254,8 +260,11 @@ def setup_user(operation)\n   test \"admin can set admin flag and set any role\" do\n     as_admin do\n       extra_role           = Role.where(:name => \"foobar\").first_or_create\n-      record               = User.new :login    => \"dummy\", :mail => \"j@j.com\", :auth_source_id => AuthSourceInternal.first.id,\n-                                      :role_ids => [extra_role.id].map(&:to_s)\n+      record               = User.new(:login => \"dummy\", :mail => \"j@j.com\",\n+                                      :auth_source_id => AuthSourceInternal.first.id,\n+                                      :role_ids => [extra_role.id.to_s],\n+                                      :organizations => User.current.organizations,\n+                                      :locations => User.current.locations)\n       record.password_hash = \"asd\"\n       record.admin         = true\n       assert record.save\n@@ -388,6 +397,8 @@ def setup_user_for_audits\n   test \"user can save user if he does not change roles\" do\n     setup_user \"edit\"\n     record = users(:two)\n+    record.organizations = User.current.organizations\n+    record.locations = User.current.locations\n     assert record.save\n   end\n \n@@ -596,14 +607,13 @@ def setup_user_for_audits\n   end\n \n   test \"user can't set empty taxonomies set if he's assigned to some\" do\n-    user = FactoryGirl.create(:user)\n     org1 = FactoryGirl.create(:organization)\n-    user.organizations << org1\n+    user = FactoryGirl.create(:user, :organizations => [org1], :locations => [])\n \n-    as_user user do\n+    as_user(user) do\n       # empty set\n-      new_user = FactoryGirl.build(:user)\n-      refute new_user.save\n+      new_user = FactoryGirl.build(:user, :organizations => [], :locations => [])\n+      refute new_user.valid?\n       assert_not_empty new_user.errors[:organization_ids]\n       assert_empty new_user.errors[:location_ids]\n     end\n@@ -773,8 +783,8 @@ def editing_self_helper\n   end\n \n   test 'default taxonomy inclusion validator' do\n-    users(:one).default_location = Location.first\n-    users(:one).default_organization = Organization.first\n+    users(:one).default_location = taxonomies(:location2)\n+    users(:one).default_organization = taxonomies(:organization2)\n \n     refute users(:one).valid?\n     assert users(:one).errors.messages.has_key? :default_location\n@@ -790,8 +800,8 @@ def editing_self_helper\n \n   test \"return location and child ids for non-admin user\" do\n     as_user :one do\n+      # User 'one' contains location1 already\n       in_taxonomy :location1 do\n-        assert User.current.locations << Location.current\n         assert child = Location.create!(:name => 'child location', :parent_id => Location.current.id)\n         assert_equal [Location.current.id, child.id].sort, User.current.location_and_child_ids\n       end\n@@ -800,8 +810,8 @@ def editing_self_helper\n \n   test \"return organization and child ids for non-admin user\" do\n     as_user :one do\n+      # User 'one' contains organization1 already\n       in_taxonomy :organization1 do\n-        assert User.current.organizations << Organization.current\n         assert child = Organization.create!(:name => 'child organization', :parent_id => Organization.current.id)\n         assert_equal [Organization.current.id, child.id].sort, User.current.organization_and_child_ids\n       end"
        },
        {
          "filename": "test/test_helper.rb",
          "status": "modified",
          "additions": 6,
          "deletions": 1,
          "patch": "@@ -40,7 +40,12 @@ class ActionView::TestCase\n \n class ActionController::TestCase\n   include ::BasicRestResponseTest\n-  setup :setup_set_script_name, :set_api_user, :turn_off_login, :disable_webpack\n+  setup :setup_set_script_name, :set_api_user, :turn_off_login,\n+    :disable_webpack, :set_admin\n+\n+  def set_admin\n+    User.current = users(:admin)\n+  end\n \n   def turn_off_login\n     SETTINGS[:require_ssl] = false"
        },
        {
          "filename": "test/unit/has_many_common_test.rb",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -74,6 +74,10 @@ class HasManyCommonTest < ActiveSupport::TestCase\n     host = FactoryGirl.build(:host)\n     orig_id = host.hostgroup_id\n     host.hostgroup_name = \"Parent/inherited\"\n+    host.hostgroup.subnet.locations = [host.location]\n+    host.hostgroup.subnet.organizations = [host.organization]\n+    host.hostgroup.subnet6.locations = [host.location]\n+    host.hostgroup.subnet6.organizations = [host.organization]\n     host.save!\n     new_id = host.hostgroup_id\n     refute_equal orig_id, new_id"
        },
        {
          "filename": "test/unit/puppet_class_importer_test.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -212,15 +212,15 @@ def setup\n       get_an_instance.send(:update_classes_in_foreman, @envs.first.name,\n                            {@pc.name => {'obsolete' => [lks.first.key]}})\n       assert_equal [@envs.last], lks.first.environments\n-      assert_equal @envs, lks.last.environments\n+      assert_equal @envs.to_a.sort, lks.last.environments.to_a.sort\n     end\n \n     test 'when overridden' do\n       lks = FactoryGirl.create_list(:puppetclass_lookup_key, 2, :as_smart_class_param, :with_override, :puppetclass => @pc)\n       get_an_instance.send(:update_classes_in_foreman, @envs.first.name,\n                            {@pc.name => {'obsolete' => [lks.first.key]}})\n       assert_equal [@envs.last], lks.first.environments\n-      assert_equal @envs, lks.last.environments\n+      assert_equal @envs.to_a.sort, lks.last.environments.sort\n     end\n \n     test 'deletes the key from all environments' do\n@@ -232,7 +232,7 @@ def setup\n                            {@pc.name => {'obsolete' => [lks.first.key]}})\n       refute PuppetclassLookupKey.find_by_id(lks.first.id)\n       refute LookupValue.find_by_id(lval.id)\n-      assert_equal @envs, lks.last.environments\n+      assert_equal @envs.to_a.sort, lks.last.environments.to_a.sort\n     end\n   end\n "
        },
        {
          "filename": "test/unit/sso/basic_test.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -12,6 +12,7 @@ class BasicTest < ActiveSupport::TestCase\n   end\n \n   test 'authenticates if user.current is not set' do\n+    User.current = nil\n     basic = SSO::Basic.new(get_basic_controller(true))\n     assert_equal 'testuser', basic.authenticated?\n   end"
        },
        {
          "filename": "test/unit/tasks/seeds_test.rb",
          "status": "modified",
          "additions": 30,
          "deletions": 28,
          "patch": "@@ -15,7 +15,8 @@ class SeedsTest < ActiveSupport::TestCase\n \n   def seed\n     # Authorisation is disabled usually when run from a rake db:* task\n-    User.current = FactoryGirl.build(:user, :admin => true)\n+    User.current = FactoryGirl.build(:user, :admin => true,\n+                                     :organizations => [], :locations => [])\n     load File.expand_path('../../../../db/seeds.rb', __FILE__)\n   end\n \n@@ -46,18 +47,18 @@ def seed\n \n   context 'populating an initial admin user' do\n     test 'with defaults' do\n-      assert_difference 'User.where(:login => \"admin\").count', 1 do\n+      assert_difference 'User.unscoped.where(:login => \"admin\").count', 1 do\n         seed\n       end\n-      user = User.find_by_login('admin')\n+      user = User.unscoped.find_by_login('admin')\n       assert user.password_hash.present?\n       assert user.password_salt.present?\n       assert user.admin?\n       assert_valid user\n     end\n \n     test 'with environment overrides' do\n-      assert_difference 'User.where(:login => \"seed_test\").count', 1 do\n+      assert_difference 'User.unscoped.where(:login => \"seed_test\").count', 1 do\n         with_env('SEED_ADMIN_USER'       => 'seed_test',\n                  'SEED_ADMIN_PASSWORD'   => 'seed_secret',\n                  'SEED_ADMIN_FIRST_NAME' => 'Seed',\n@@ -66,7 +67,7 @@ def seed\n           seed\n         end\n       end\n-      user = User.find_by_login('seed_test')\n+      user = User.unscoped.find_by_login('seed_test')\n       assert user.matching_password? 'seed_secret'\n       assert user.admin?\n       refute user.hidden?\n@@ -75,37 +76,37 @@ def seed\n   end\n \n   test 'populates partition tables' do\n-    count = Ptable.count\n+    count = Ptable.unscoped.count\n     seed\n-    assert_not_equal count, Ptable.count\n-    refute Ptable.where(:os_family => nil).any?\n+    assert_not_equal count, Ptable.unscoped.count\n+    refute Ptable.unscoped.where(:os_family => nil).any?\n   end\n \n   test 'populates installation media' do\n-    count = Medium.count\n+    count = Medium.unscoped.count\n     seed\n-    assert_not_equal count, Medium.count\n-    refute Medium.where(:os_family => nil).any?\n+    assert_not_equal count, Medium.unscoped.count\n+    refute Medium.unscoped.where(:os_family => nil).any?\n   end\n \n   test 'populates config templates' do\n-    count = ProvisioningTemplate.count\n+    count = ProvisioningTemplate.unscoped.count\n     seed\n-    assert_not_equal count, ProvisioningTemplate.count\n+    assert_not_equal count, ProvisioningTemplate.unscoped.count\n \n     Dir[\"#{Rails.root}/app/views/unattended/**/*.erb\"].each do |tmpl|\n       if tmpl =~ /disklayout/\n-        assert Ptable.where(:template => File.read(tmpl)).any?, \"No partition table containing #{tmpl}\"\n+        assert Ptable.unscoped.where(:template => File.read(tmpl)).any?, \"No partition table containing #{tmpl}\"\n       else\n-        assert ProvisioningTemplate.where(:template => File.read(tmpl)).any?, \"No template containing #{tmpl}\"\n+        assert ProvisioningTemplate.unscoped.where(:template => File.read(tmpl)).any?, \"No template containing #{tmpl}\"\n       end\n     end\n   end\n \n   test 'populates bookmarks' do\n-    count = Bookmark.where(:public => true).count\n+    count = Bookmark.unscoped.where(:public => true).count\n     seed\n-    assert_not_equal count, Bookmark.where(:public => true).count\n+    assert_not_equal count, Bookmark.unscoped.where(:public => true).count\n   end\n \n   test 'is idempotent' do\n@@ -116,25 +117,26 @@ def seed\n \n   test \"does update template that was not modified by user\" do\n     seed\n-    ProvisioningTemplate.without_auditing { ProvisioningTemplate.find_by_name('Kickstart default').update_attributes(:template => 'test') }\n+    ProvisioningTemplate.without_auditing { ProvisioningTemplate.unscoped.find_by_name('Kickstart default').update_attributes(:template => 'test') }\n     seed\n-    refute_equal ProvisioningTemplate.find_by_name('Kickstart default').template, 'test'\n+    refute_equal ProvisioningTemplate.unscoped.find_by_name('Kickstart default').template, 'test'\n   end\n \n   test \"doesn't add a template back that was deleted\" do\n     seed\n-    assert_equal 1, ProvisioningTemplate.destroy_all(:name => 'Kickstart default').size\n+    assert_equal 1, ProvisioningTemplate.unscoped.\n+      destroy_all(:name => 'Kickstart default').size\n     seed\n-    refute ProvisioningTemplate.find_by_name('Kickstart default')\n+    refute ProvisioningTemplate.unscoped.find_by_name('Kickstart default')\n   end\n \n   test \"doesn't add a template back that was renamed\" do\n     seed\n-    tmpl = ProvisioningTemplate.find_by_name('Kickstart default')\n+    tmpl = ProvisioningTemplate.unscoped.find_by_name('Kickstart default')\n     tmpl.name = 'test'\n     tmpl.save!\n     seed\n-    refute ProvisioningTemplate.find_by_name('Kickstart default')\n+    refute ProvisioningTemplate.unscoped.find_by_name('Kickstart default')\n   end\n \n   test \"no audits are recorded\" do\n@@ -147,31 +149,31 @@ def seed\n     with_env('SEED_ORGANIZATION' => 'seed_test') do\n       seed\n     end\n-    assert Organization.find_by_name('seed_test')\n+    assert Organization.unscoped.find_by_name('seed_test')\n   end\n \n   test \"don't seed organization when an org already exists\" do\n     Organization.stubs(:any?).returns(true)\n     with_env('SEED_ORGANIZATION' => 'seed_test') do\n       seed\n     end\n-    refute Organization.find_by_name('seed_test')\n+    refute Organization.unscoped.find_by_name('seed_test')\n   end\n \n   test \"seed location when environment SEED_LOCATION specified\" do\n     Location.stubs(:any?).returns(false)\n     with_env('SEED_LOCATION' => 'seed_test') do\n       seed\n     end\n-    assert Location.find_by_name('seed_test')\n+    assert Location.unscoped.find_by_name('seed_test')\n   end\n \n   test \"don't seed location when a location already exists\" do\n     Location.stubs(:any?).returns(true)\n     with_env('SEED_LOCATION' => 'seed_test') do\n       seed\n     end\n-    refute Location.find_by_name('seed_test')\n+    refute Location.unscoped.find_by_name('seed_test')\n   end\n \n   test \"all access permissions are created by permissions seed\" do\n@@ -187,6 +189,6 @@ def seed\n   test \"viewer role contains all view permissions\" do\n     seed\n     view_permissions = Permission.all.select { |permission| permission.name.match(/view/) }\n-    assert_equal [], view_permissions - Role.find_by_name('Viewer').permissions\n+    assert_equal [], view_permissions - Role.unscoped.find_by_name('Viewer').permissions\n   end\n end"
        }
      ],
      "file_patterns": {
        "security_files": 6,
        "config_files": 4,
        "dependency_files": 0,
        "test_files": 75,
        "unique_directories": 22,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b4bd8e2f248e6bba92b53c1a9264edb8164c84cd",
            "date": "2024-12-01T11:50:03Z",
            "author_login": "ShimShtein"
          },
          {
            "sha": "820308f68104493b1fd9256c8dd2b604a9c6c806",
            "date": "2024-12-03T10:02:22Z",
            "author_login": "ShimShtein"
          },
          {
            "sha": "e9e78f33eae798c8fd5fce75728ea28f10d2a396",
            "date": "2024-12-19T14:13:01Z",
            "author_login": "ekohl"
          },
          {
            "sha": "ab23d6cd97d12e44d31a2bba3bc4caa5e9ee095d",
            "date": "2024-11-27T11:53:31Z",
            "author_login": "ShimShtein"
          },
          {
            "sha": "cab93bf66327699b4d36ee25e61b2bf33329c0ec",
            "date": "2024-04-26T17:22:24Z",
            "author_login": "MariaAga"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-285",
    "description": "foreman before version 1.15.0 is vulnerable to an information leak through organizations and locations feature. When a user is assigned _no_ organizations/locations, they are able to view all resources instead of none (mirroring an administrator's view). The user's actions are still limited by their assigned permissions, e.g. to control viewing, editing and deletion.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-09-10T15:29:04.280",
    "last_modified": "2024-11-21T02:57:24.930",
    "fix_date": "2016-10-20T16:06:38Z"
  },
  "references": [
    {
      "url": "http://www.securityfocus.com/bid/96385",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2016-7078",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/theforeman/foreman/commit/5f606e11cf39719bf62f8b1f3396861b32387905",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://projects.theforeman.org/issues/16982",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://seclists.org/oss-sec/2017/q1/470",
      "source": "secalert@redhat.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://theforeman.org/security.html#2016-7078",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/96385",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2016-7078",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/theforeman/foreman/commit/5f606e11cf39719bf62f8b1f3396861b32387905",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://projects.theforeman.org/issues/16982",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://seclists.org/oss-sec/2017/q1/470",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://theforeman.org/security.html#2016-7078",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:35.808858",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "foreman",
    "owner": "theforeman",
    "created_at": "2009-07-23T15:07:00Z",
    "updated_at": "2025-01-14T13:56:13Z",
    "pushed_at": "2025-01-14T13:56:07Z",
    "size": 129552,
    "stars": 2640,
    "forks": 993,
    "open_issues": 75,
    "watchers": 2640,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "1.0-stable",
      "1.1-stable",
      "1.2-stable",
      "1.3-stable",
      "1.4-stable",
      "1.5-stable",
      "1.6-stable",
      "1.7-stable",
      "1.8-stable",
      "1.9-stable",
      "1.10-stable",
      "1.11-stable",
      "1.12-stable",
      "1.13-stable",
      "1.14-stable",
      "1.15-stable",
      "1.16-stable",
      "1.17-stable",
      "1.18-stable",
      "1.19-stable",
      "1.20-stable",
      "1.21-stable",
      "1.22-stable",
      "1.23-stable",
      "1.24-stable",
      "2.0-stable",
      "2.1-stable",
      "2.2-stable",
      "2.3-stable"
    ],
    "languages": {
      "Ruby": 5249910,
      "JavaScript": 1439644,
      "HTML": 751656,
      "SCSS": 59934,
      "Shell": 42261,
      "Dockerfile": 3020,
      "CSS": 2383,
      "Makefile": 1995,
      "Mermaid": 1733,
      "Python": 1359,
      "Procfile": 983
    },
    "commit_activity": {
      "total_commits_last_year": 289,
      "avg_commits_per_week": 5.5576923076923075,
      "days_active_last_year": 155
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-14T14:32:13.724642"
  }
}