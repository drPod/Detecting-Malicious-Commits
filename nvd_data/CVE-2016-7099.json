{
  "cve_id": "CVE-2016-7099",
  "github_data": {
    "repository": "nodejs/node",
    "fix_commit": "743f0c916469f3129dfae406fa104dc46782e20b",
    "related_commits": [
      "743f0c916469f3129dfae406fa104dc46782e20b",
      "743f0c916469f3129dfae406fa104dc46782e20b"
    ],
    "patch_url": "https://github.com/nodejs/node/commit/743f0c916469f3129dfae406fa104dc46782e20b.patch",
    "fix_commit_details": {
      "sha": "743f0c916469f3129dfae406fa104dc46782e20b",
      "commit_date": "2016-08-15T16:46:27Z",
      "author": {
        "login": "bnoordhuis",
        "type": "User",
        "stats": {
          "total_commits": 2291,
          "average_weekly_commits": 2.756919374247894,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 396
        }
      },
      "commit_message": {
        "title": "lib: make tls.checkServerIdentity() more strict",
        "length": 203,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 282,
        "additions": 168,
        "deletions": 114
      },
      "files": [
        {
          "filename": "lib/tls.js",
          "status": "modified",
          "additions": 117,
          "deletions": 114,
          "patch": "@@ -66,134 +66,137 @@ exports.convertALPNProtocols = function(protocols, out) {\n   }\n };\n \n-exports.checkServerIdentity = function checkServerIdentity(host, cert) {\n-  // Create regexp to much hostnames\n-  function regexpify(host, wildcards) {\n-    // Add trailing dot (make hostnames uniform)\n-    if (!host || !host.endsWith('.')) host += '.';\n-\n-    // The same applies to hostname with more than one wildcard,\n-    // if hostname has wildcard when wildcards are not allowed,\n-    // or if there are less than two dots after wildcard (i.e. *.com or *d.com)\n-    //\n-    // also\n-    //\n-    // \"The client SHOULD NOT attempt to match a presented identifier in\n-    // which the wildcard character comprises a label other than the\n-    // left-most label (e.g., do not match bar.*.example.net).\"\n-    // RFC6125\n-    if (!wildcards && /\\*/.test(host) || /[\\.\\*].*\\*/.test(host) ||\n-        /\\*/.test(host) && !/\\*.*\\..+\\..+/.test(host)) {\n-      return /$./;\n-    }\n+function unfqdn(host) {\n+  return host.replace(/[.]$/, '');\n+}\n \n-    // Replace wildcard chars with regexp's wildcard and\n-    // escape all characters that have special meaning in regexps\n-    // (i.e. '.', '[', '{', '*', and others)\n-    var re = host.replace(\n-        /\\*([a-z0-9\\\\-_\\.])|[\\.,\\-\\\\\\^\\$+?*\\[\\]\\(\\):!\\|{}]/g,\n-        function(all, sub) {\n-          if (sub) return '[a-z0-9\\\\-_]*' + (sub === '-' ? '\\\\-' : sub);\n-          return '\\\\' + all;\n-        });\n-\n-    return new RegExp('^' + re + '$', 'i');\n-  }\n+function splitHost(host) {\n+  // String#toLowerCase() is locale-sensitive so we use\n+  // a conservative version that only lowercases A-Z.\n+  const replacer = (c) => String.fromCharCode(32 + c.charCodeAt(0));\n+  return unfqdn(host).replace(/[A-Z]/g, replacer).split('.');\n+}\n+\n+function check(hostParts, pattern, wildcards) {\n+  // Empty strings, null, undefined, etc. never match.\n+  if (!pattern)\n+    return false;\n+\n+  const patternParts = splitHost(pattern);\n+\n+  if (hostParts.length !== patternParts.length)\n+    return false;\n+\n+  // Pattern has empty components, e.g. \"bad..example.com\".\n+  if (patternParts.includes(''))\n+    return false;\n+\n+  // RFC 6125 allows IDNA U-labels (Unicode) in names but we have no\n+  // good way to detect their encoding or normalize them so we simply\n+  // reject them.  Control characters and blanks are rejected as well\n+  // because nothing good can come from accepting them.\n+  const isBad = (s) => /[^\\u0021-\\u007F]/u.test(s);\n+  if (patternParts.some(isBad))\n+    return false;\n+\n+  // Check host parts from right to left first.\n+  for (let i = hostParts.length - 1; i > 0; i -= 1)\n+    if (hostParts[i] !== patternParts[i])\n+      return false;\n+\n+  const hostSubdomain = hostParts[0];\n+  const patternSubdomain = patternParts[0];\n+  const patternSubdomainParts = patternSubdomain.split('*');\n+\n+  // Short-circuit when the subdomain does not contain a wildcard.\n+  // RFC 6125 does not allow wildcard substitution for components\n+  // containing IDNA A-labels (Punycode) so match those verbatim.\n+  if (patternSubdomainParts.length === 1 || patternSubdomain.includes('xn--'))\n+    return hostSubdomain === patternSubdomain;\n+\n+  if (!wildcards)\n+    return false;\n+\n+  // More than one wildcard is always wrong.\n+  if (patternSubdomainParts.length > 2)\n+    return false;\n+\n+  // *.tld wildcards are not allowed.\n+  if (patternParts.length <= 2)\n+    return false;\n+\n+  const [prefix, suffix] = patternSubdomainParts;\n+\n+  if (prefix.length + suffix.length > hostSubdomain.length)\n+    return false;\n \n-  var dnsNames = [];\n-  var uriNames = [];\n+  if (!hostSubdomain.startsWith(prefix))\n+    return false;\n+\n+  if (!hostSubdomain.endsWith(suffix))\n+    return false;\n+\n+  return true;\n+}\n+\n+exports.checkServerIdentity = function checkServerIdentity(host, cert) {\n+  const subject = cert.subject;\n+  const altNames = cert.subjectaltname;\n+  const dnsNames = [];\n+  const uriNames = [];\n   const ips = [];\n-  var matchCN = true;\n-  var valid = false;\n-  var reason = 'Unknown reason';\n-\n-  // There're several names to perform check against:\n-  // CN and altnames in certificate extension\n-  // (DNS names, IP addresses, and URIs)\n-  //\n-  // Walk through altnames and generate lists of those names\n-  if (cert.subjectaltname) {\n-    cert.subjectaltname.split(/, /g).forEach(function(altname) {\n-      var option = altname.match(/^(DNS|IP Address|URI):(.*)$/);\n-      if (!option)\n-        return;\n-      if (option[1] === 'DNS') {\n-        dnsNames.push(option[2]);\n-      } else if (option[1] === 'IP Address') {\n-        ips.push(option[2]);\n-      } else if (option[1] === 'URI') {\n-        var uri = url.parse(option[2]);\n-        if (uri) uriNames.push(uri.hostname);\n-      }\n-    });\n-  }\n \n-  // If hostname is an IP address, it should be present in the list of IP\n-  // addresses.\n-  if (net.isIP(host)) {\n-    valid = ips.some(function(ip) {\n-      return ip === host;\n-    });\n-    if (!valid) {\n-      reason = `IP: ${host} is not in the cert's list: ${ips.join(', ')}`;\n-    }\n-  } else if (cert.subject) {\n-    // Transform hostname to canonical form\n-    if (!host || !host.endsWith('.')) host += '.';\n-\n-    // Otherwise check all DNS/URI records from certificate\n-    // (with allowed wildcards)\n-    dnsNames = dnsNames.map(function(name) {\n-      return regexpify(name, true);\n-    });\n-\n-    // Wildcards ain't allowed in URI names\n-    uriNames = uriNames.map(function(name) {\n-      return regexpify(name, false);\n-    });\n-\n-    dnsNames = dnsNames.concat(uriNames);\n-\n-    if (dnsNames.length > 0) matchCN = false;\n-\n-    // Match against Common Name (CN) only if no supported identifiers are\n-    // present.\n-    //\n-    // \"As noted, a client MUST NOT seek a match for a reference identifier\n-    //  of CN-ID if the presented identifiers include a DNS-ID, SRV-ID,\n-    //  URI-ID, or any application-specific identifier types supported by the\n-    //  client.\"\n-    // RFC6125\n-    if (matchCN) {\n-      var commonNames = cert.subject.CN;\n-      if (Array.isArray(commonNames)) {\n-        for (var i = 0, k = commonNames.length; i < k; ++i) {\n-          dnsNames.push(regexpify(commonNames[i], true));\n-        }\n-      } else {\n-        dnsNames.push(regexpify(commonNames, true));\n+  host = '' + host;\n+\n+  if (altNames) {\n+    for (const name of altNames.split(', ')) {\n+      if (name.startsWith('DNS:')) {\n+        dnsNames.push(name.slice(4));\n+      } else if (name.startsWith('URI:')) {\n+        const uri = url.parse(name.slice(4));\n+        uriNames.push(uri.hostname);  // TODO(bnoordhuis) Also use scheme.\n+      } else if (name.startsWith('IP Address:')) {\n+        ips.push(name.slice(11));\n       }\n     }\n+  }\n \n-    valid = dnsNames.some(function(re) {\n-      return re.test(host);\n-    });\n+  let valid = false;\n+  let reason = 'Unknown reason';\n \n-    if (!valid) {\n-      if (cert.subjectaltname) {\n-        reason =\n-            `Host: ${host} is not in the cert's altnames: ` +\n-            `${cert.subjectaltname}`;\n-      } else {\n-        reason = `Host: ${host} is not cert's CN: ${cert.subject.CN}`;\n-      }\n+  if (net.isIP(host)) {\n+    valid = ips.includes(host);\n+    if (!valid)\n+      reason = `IP: ${host} is not in the cert's list: ${ips.join(', ')}`;\n+    // TODO(bnoordhuis) Also check URI SANs that are IP addresses.\n+  } else if (subject) {\n+    host = unfqdn(host);  // Remove trailing dot for error messages.\n+    const hostParts = splitHost(host);\n+    const wildcard = (pattern) => check(hostParts, pattern, true);\n+    const noWildcard = (pattern) => check(hostParts, pattern, false);\n+\n+    // Match against Common Name only if no supported identifiers are present.\n+    if (dnsNames.length === 0 && ips.length === 0 && uriNames.length === 0) {\n+      const cn = subject.CN;\n+\n+      if (Array.isArray(cn))\n+        valid = cn.some(wildcard);\n+      else if (cn)\n+        valid = wildcard(cn);\n+\n+      if (!valid)\n+        reason = `Host: ${host}. is not cert's CN: ${cn}`;\n+    } else {\n+      valid = dnsNames.some(wildcard) || uriNames.some(noWildcard);\n+      if (!valid)\n+        reason = `Host: ${host}. is not in the cert's altnames: ${altNames}`;\n     }\n   } else {\n     reason = 'Cert is empty';\n   }\n \n   if (!valid) {\n-    var err = new Error(\n+    const err = new Error(\n         `Hostname/IP doesn't match certificate's altnames: \"${reason}\"`);\n     err.reason = reason;\n     err.host = host;"
        },
        {
          "filename": "test/parallel/test-tls-check-server-identity.js",
          "status": "modified",
          "additions": 51,
          "deletions": 0,
          "patch": "@@ -11,6 +11,23 @@ var tls = require('tls');\n \n \n var tests = [\n+  // False-y values.\n+  {\n+    host: false,\n+    cert: { subject: { CN: 'a.com' } },\n+    error: 'Host: false. is not cert\\'s CN: a.com'\n+  },\n+  {\n+    host: null,\n+    cert: { subject: { CN: 'a.com' } },\n+    error: 'Host: null. is not cert\\'s CN: a.com'\n+  },\n+  {\n+    host: undefined,\n+    cert: { subject: { CN: 'a.com' } },\n+    error: 'Host: undefined. is not cert\\'s CN: a.com'\n+  },\n+\n   // Basic CN handling\n   { host: 'a.com', cert: { subject: { CN: 'a.com' } } },\n   { host: 'a.com', cert: { subject: { CN: 'A.COM' } } },\n@@ -20,15 +37,35 @@ var tests = [\n     error: 'Host: a.com. is not cert\\'s CN: b.com'\n   },\n   { host: 'a.com', cert: { subject: { CN: 'a.com.' } } },\n+  {\n+    host: 'a.com',\n+    cert: { subject: { CN: '.a.com' } },\n+    error: 'Host: a.com. is not cert\\'s CN: .a.com'\n+  },\n \n   // Wildcards in CN\n   { host: 'b.a.com', cert: { subject: { CN: '*.a.com' } } },\n+  {\n+    host: 'ba.com',\n+    cert: { subject: { CN: '*.a.com' } },\n+    error: 'Host: ba.com. is not cert\\'s CN: *.a.com'\n+  },\n+  {\n+    host: '\\n.b.com',\n+    cert: { subject: { CN: '*n.b.com' } },\n+    error: 'Host: \\n.b.com. is not cert\\'s CN: *n.b.com'\n+  },\n   { host: 'b.a.com', cert: {\n     subjectaltname: 'DNS:omg.com',\n     subject: { CN: '*.a.com' } },\n     error: 'Host: b.a.com. is not in the cert\\'s altnames: ' +\n            'DNS:omg.com'\n   },\n+  {\n+    host: 'b.a.com',\n+    cert: { subject: { CN: 'b*b.a.com' } },\n+    error: 'Host: b.a.com. is not cert\\'s CN: b*b.a.com'\n+  },\n \n   // Empty Cert\n   {\n@@ -199,6 +236,20 @@ var tests = [\n     error: 'Host: localhost. is not in the cert\\'s altnames: ' +\n            'DNS:a.com'\n   },\n+  // IDNA\n+  {\n+    host: 'xn--bcher-kva.example.com',\n+    cert: { subject: { CN: '*.example.com' } },\n+  },\n+  // RFC 6125, section 6.4.3: \"[...] the client SHOULD NOT attempt to match\n+  // a presented identifier where the wildcard character is embedded within\n+  // an A-label [...]\"\n+  {\n+    host: 'xn--bcher-kva.example.com',\n+    cert: { subject: { CN: 'xn--*.example.com' } },\n+    error: 'Host: xn--bcher-kva.example.com. is not cert\\'s CN: ' +\n+            'xn--*.example.com',\n+  },\n ];\n \n tests.forEach(function(test, i) {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "fc11189cbd2708811570f3db0b2be32c55f8f05e",
            "date": "2025-01-14T14:24:41Z",
            "author_login": "JakobJingleheimer"
          },
          {
            "sha": "5770972dc6c0458af5458b8056b16d70905ea9d8",
            "date": "2025-01-14T00:56:47Z",
            "author_login": "nodejs-github-bot"
          },
          {
            "sha": "f537efd1dda870baac652321445ce5944b7e09c5",
            "date": "2025-01-14T00:56:11Z",
            "author_login": "nodejs-github-bot"
          },
          {
            "sha": "4ef77497fb6e4eb4dfcc55a6c21f35ec707d38a5",
            "date": "2025-01-14T00:55:57Z",
            "author_login": "nodejs-github-bot"
          },
          {
            "sha": "7a9d78306b68b15e06eecbf30370c551da18bd90",
            "date": "2025-01-11T13:17:38Z",
            "author_login": "santigimeno"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-19",
    "description": "The tls.checkServerIdentity function in Node.js 0.10.x before 0.10.47, 0.12.x before 0.12.16, 4.x before 4.6.0, and 6.x before 6.7.0 does not properly handle wildcards in name fields of X.509 certificates, which allows man-in-the-middle attackers to spoof servers via a crafted certificate.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2016-10-10T16:59:01.277",
    "last_modified": "2024-11-21T02:57:27.747",
    "fix_date": "2016-08-15T16:46:27Z"
  },
  "references": [
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2016-10/msg00013.html",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2017-0002.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/93191",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/nodejs/node/commit/743f0c916469f3129dfae406fa104dc46782e20b",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    },
    {
      "url": "https://nodejs.org/en/blog/vulnerability/september-2016-security-releases/",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2016-10/msg00013.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://rhn.redhat.com/errata/RHSA-2017-0002.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/93191",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/nodejs/node/commit/743f0c916469f3129dfae406fa104dc46782e20b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    },
    {
      "url": "https://nodejs.org/en/blog/vulnerability/september-2016-security-releases/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:46.802279",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "node",
    "owner": "nodejs",
    "created_at": "2014-11-26T19:57:11Z",
    "updated_at": "2025-01-14T13:50:49Z",
    "pushed_at": "2025-01-14T13:50:54Z",
    "size": 1221233,
    "stars": 108898,
    "forks": 30265,
    "open_issues": 2078,
    "watchers": 108898,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "archived-io.js-v0.10",
      "archived-io.js-v0.12",
      "canary-base",
      "main",
      "v0.7.4-release",
      "v0.8.16-release",
      "v0.10",
      "v0.12",
      "v1.x",
      "v3.x",
      "v4.x",
      "v5.x",
      "v6.x",
      "v7.x",
      "v8.x",
      "v9.x"
    ],
    "languages": {
      "JavaScript": 14935002,
      "C++": 5475414,
      "Python": 2594676,
      "C": 674103,
      "HTML": 163390,
      "Shell": 113904,
      "Makefile": 60765,
      "Batchfile": 45390,
      "Emacs Lisp": 14363,
      "Perl": 11715,
      "R": 8037,
      "TypeScript": 1968,
      "Assembly": 157
    },
    "commit_activity": {
      "total_commits_last_year": 2529,
      "avg_commits_per_week": 48.63461538461539,
      "days_active_last_year": 353
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T14:19:17.728456"
  }
}