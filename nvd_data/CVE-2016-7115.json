{
  "cve_id": "CVE-2016-7115",
  "github_data": {
    "repository": "haakonnessjoen/MAC-Telnet",
    "fix_commit": "b69d11727d4f0f8cf719c79e3fb700f55ca03e9a",
    "related_commits": [
      "b69d11727d4f0f8cf719c79e3fb700f55ca03e9a",
      "b69d11727d4f0f8cf719c79e3fb700f55ca03e9a"
    ],
    "patch_url": "https://github.com/haakonnessjoen/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a.patch",
    "fix_commit_details": {
      "sha": "b69d11727d4f0f8cf719c79e3fb700f55ca03e9a",
      "commit_date": "2016-08-30T09:27:39Z",
      "author": {
        "login": "haakonnessjoen",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #20 from eyalitki/master",
        "length": 83,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 46,
        "additions": 30,
        "deletions": 16
      },
      "files": [
        {
          "filename": "mactelnet.c",
          "status": "modified",
          "additions": 14,
          "deletions": 7,
          "patch": "@@ -96,7 +96,7 @@ static char autologin_path[255];\n \n static int keepalive_counter = 0;\n \n-static unsigned char pass_salt[17];\n+static unsigned char pass_salt[16];\n static char username[MT_MNDP_MAX_STRING_SIZE];\n static char password[MT_MNDP_MAX_STRING_SIZE];\n static char nonpriv_username[MT_MNDP_MAX_STRING_SIZE];\n@@ -212,23 +212,26 @@ static void send_auth(char *username, char *password) {\n \tchar *terminal = getenv(\"TERM\");\n \tchar md5data[100];\n \tunsigned char md5sum[17];\n-\tint plen;\n+\tint plen, act_pass_len;\n \tmd5_state_t state;\n \n #if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n \tmlock(md5data, sizeof(md5data));\n \tmlock(md5sum, sizeof(md5data));\n #endif\n \n+\t/* calculate the actual password's length */\n+\tact_pass_len = strnlen(password, 82);\n+\n \t/* Concat string of 0 + password + pass_salt */\n \tmd5data[0] = 0;\n-\tstrncpy(md5data + 1, password, 82);\n-\tmd5data[83] = '\\0';\n-\tmemcpy(md5data + 1 + strlen(password), pass_salt, 16);\n+\tmemcpy(md5data + 1, password, act_pass_len);\n+\t/* in case that password is long, calculate only using the used-up parts */\n+\tmemcpy(md5data + 1 + act_pass_len, pass_salt, 16);\n \n \t/* Generate md5 sum of md5data with a leading 0 */\n \tmd5_init(&state);\n-\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(password) + 17);\n+\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\n \tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n \tmd5sum[0] = 0;\n \n@@ -312,7 +315,11 @@ static int handle_packet(unsigned char *data, int data_len) {\n \n \t\t\t/* If we receive pass_salt, transmit auth data back */\n \t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\n-\t\t\t\tmemcpy(pass_salt, cpkt.data, cpkt.length);\n+\t\t\t\t/* check validity, server sends exactly 16 bytes */\n+\t\t\t\tif (cpkt.length != 16) {\n+\t\t\t\t\tfprintf(stderr, _(\"Invalid salt length: %d (instead of 16) received from server %s\\n\"), cpkt.length, ether_ntoa((struct ether_addr *)dstmac));\n+\t\t\t\t}\n+\t\t\t\tmemcpy(pass_salt, cpkt.data, 16);\n \t\t\t\tsend_auth(username, password);\n \t\t\t}\n "
        },
        {
          "filename": "mactelnetd.c",
          "status": "modified",
          "additions": 10,
          "deletions": 5,
          "patch": "@@ -407,6 +407,7 @@ static void user_login(struct mt_connection *curconn, struct mt_mactelnet_hdr *p\n \tchar md5data[100];\n \tstruct mt_credentials *user;\n \tchar *slavename;\n+\tint act_pass_len;\n \n \t/* Reparse user file before each login */\n \tread_userfile();\n@@ -421,14 +422,18 @@ static void user_login(struct mt_connection *curconn, struct mt_mactelnet_hdr *p\n \t\t}\n #endif\n \n+\t\t/* calculate the password's actual length */\n+\t\tact_pass_len = strlen(user->password);\n+\t\tact_pass_len = act_pass_len <= 82 ? act_pass_len : 82;\n+\n \t\t/* Concat string of 0 + password + pass_salt */\n \t\tmd5data[0] = 0;\n-\t\tstrncpy(md5data + 1, user->password, 82);\n-\t\tmemcpy(md5data + 1 + strlen(user->password), curconn->pass_salt, 16);\n+\t\tmemcpy(md5data + 1, user->password, act_pass_len);\n+\t\tmemcpy(md5data + 1 + act_pass_len, curconn->pass_salt, 16);\n \n \t\t/* Generate md5 sum of md5data with a leading 0 */\n \t\tmd5_init(&state);\n-\t\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(user->password) + 17);\n+\t\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\n \t\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n \t\tmd5sum[0] = 0;\n \n@@ -635,7 +640,7 @@ static void handle_data_packet(struct mt_connection *curconn, struct mt_mactelne\n \t\t\tmemcpy(curconn->terminal_type, cpkt.data, act_size = (cpkt.length > 30 - 1 ? 30 - 1 : cpkt.length));\n \t\t\tcurconn->terminal_type[act_size] = 0;\n \n-\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD) {\n+\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD && cpkt.length == 17) {\n \n #if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n \t\t\tmlock(curconn->trypassword, 17);\n@@ -651,7 +656,7 @@ static void handle_data_packet(struct mt_connection *curconn, struct mt_mactelne\n \t\t\t}\n \n \t\t} else {\n-\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d\"), curconn->seskey, cpkt.cptype);\n+\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d, length: %d\"), curconn->seskey, cpkt.cptype, cpkt.length);\n \t\t}\n \n \t\t/* Parse next control packet */"
        },
        {
          "filename": "protocol.c",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -84,8 +84,9 @@ int add_control_packet(struct mt_packet *packet, enum mt_cptype cptype, void *cp\n \tunsigned char *data = packet->data + packet->size;\n \tunsigned int act_size = data_len + (cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN);\n \n-\t/* Something is really wrong. Packets should never become over 1500 bytes */\n-\tif (packet->size + act_size > MT_PACKET_LEN) {\n+\t/* Something is really wrong. Packets should never become over 1500 bytes,\n+       perform an Integer-Overflow safe check */\n+\tif (act_size > MT_PACKET_LEN - packet->size) {\n \t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n \t\treturn -1;\n \t\t//exit(1);\n@@ -149,7 +150,8 @@ int init_pongpacket(struct mt_packet *packet, unsigned char *srcmac, unsigned ch\n }\n \n int add_packetdata(struct mt_packet *packet, unsigned char *data, unsigned short length) {\n-\tif (packet->size + length > MT_PACKET_LEN) {\n+\t/* Integer-Overflow safe check */\n+\tif (length > MT_PACKET_LEN - packet->size) {\n \t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n \t\treturn -1;\n \t}\n@@ -272,7 +274,7 @@ int mndp_add_attribute(struct mt_packet *packet, enum mt_mndp_attrtype attrtype,\n \tunsigned short len = data_len;\n \n \t/* Something is really wrong. Packets should never become over 1500 bytes */\n-\tif (packet->size + 4 + data_len > MT_PACKET_LEN) {\n+\tif (data_len > MT_PACKET_LEN - 4 - packet->size) {\n \t\tfprintf(stderr, _(\"mndp_add_attribute: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n \t\treturn -1;\n \t}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "535c64a07ed22a5e1b5ea4ff58a790d2267819b5",
            "date": "2024-09-24T13:16:55Z",
            "author_login": "haakonnessjoen"
          },
          {
            "sha": "2ffcfe568c5c0f3175d9d57269df67132fa30b51",
            "date": "2024-09-24T13:00:12Z",
            "author_login": "jclarke-csco"
          },
          {
            "sha": "c6a8748e8227e17a4bd23f4a5e47d0e2340f7f99",
            "date": "2024-08-23T10:23:23Z",
            "author_login": "haakonnessjoen"
          },
          {
            "sha": "9545162d9cbe663ca88227da3ead5245681bc777",
            "date": "2024-08-23T09:31:35Z",
            "author_login": "togish"
          },
          {
            "sha": "4f56326997846e9ae485c12a895dae5c47874cac",
            "date": "2024-08-23T09:27:56Z",
            "author_login": "togish"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-119",
    "description": "Buffer overflow in the handle_packet function in mactelnet.c in the client in MAC-Telnet 0.4.3 and earlier allows remote TELNET servers to execute arbitrary code via a long string in an MT_CPTYPE_PASSSALT control packet.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2016-08-30T17:59:04.550",
    "last_modified": "2024-11-21T02:57:29.697",
    "fix_date": "2016-08-30T09:27:39Z"
  },
  "references": [
    {
      "url": "http://www.securityfocus.com/bid/92699",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/haakonnessjoen/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    },
    {
      "url": "https://github.com/haakonnessjoen/MAC-Telnet/pull/20",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/92699",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/haakonnessjoen/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    },
    {
      "url": "https://github.com/haakonnessjoen/MAC-Telnet/pull/20",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:46.777853",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "MAC-Telnet",
    "owner": "haakonnessjoen",
    "created_at": "2010-09-26T18:42:20Z",
    "updated_at": "2024-12-31T16:54:57Z",
    "pushed_at": "2024-09-24T13:16:55Z",
    "size": 637,
    "stars": 411,
    "forks": 127,
    "open_issues": 5,
    "watchers": 411,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 220423,
      "M4": 3959,
      "Shell": 1932,
      "Makefile": 1541,
      "Dockerfile": 702,
      "sed": 370
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T21:22:12.364387"
  }
}