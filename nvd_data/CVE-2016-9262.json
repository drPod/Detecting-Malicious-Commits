{
  "cve_id": "CVE-2016-9262",
  "github_data": {
    "repository": "mdadams/jasper",
    "fix_commit": "634ce8e8a5accc0fa05dd2c20d42b4749d4b2735",
    "related_commits": [
      "634ce8e8a5accc0fa05dd2c20d42b4749d4b2735",
      "634ce8e8a5accc0fa05dd2c20d42b4749d4b2735"
    ],
    "patch_url": "https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735.patch",
    "fix_commit_details": {
      "sha": "634ce8e8a5accc0fa05dd2c20d42b4749d4b2735",
      "commit_date": "2016-11-06T18:26:16Z",
      "author": {
        "login": "mdadams",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Made some changes to the I/O stream library for memory streams.",
        "length": 583,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 213,
        "additions": 198,
        "deletions": 15
      },
      "files": [
        {
          "filename": "src/libjasper/base/jas_debug.c",
          "status": "modified",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -135,3 +135,22 @@ int jas_memdump(FILE *out, void *data, size_t len)\n \t}\n \treturn 0;\n }\n+\n+/******************************************************************************\\\n+* Code.\n+\\******************************************************************************/\n+\n+void jas_deprecated(const char *s)\n+{\n+\tstatic char message[] =\n+\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n+\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n+\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n+\t\"YOUR CODE IS RELYING ON DEPRECATED FUNCTIONALTIY IN THE JASPER LIBRARY.\\n\"\n+\t\"THIS FUNCTIONALITY WILL BE REMOVED IN THE NEAR FUTURE.\\n\"\n+\t\"PLEASE FIX THIS PROBLEM BEFORE YOUR CODE STOPS WORKING!\\n\"\n+\t;\n+\tjas_eprintf(\"%s\", message);\n+\tjas_eprintf(\"The specific problem is as follows:\\n%s\\n\", s);\n+\t//abort();\n+}"
        },
        {
          "filename": "src/libjasper/base/jas_image.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -347,7 +347,7 @@ static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n \t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n \t\tgoto error;\n \t}\n-\tcmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) :\n+\tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :\n \t  jas_stream_tmpfile();\n \tif (!cmpt->stream_) {\n \t\tgoto error;"
        },
        {
          "filename": "src/libjasper/base/jas_stream.c",
          "status": "modified",
          "additions": 170,
          "deletions": 13,
          "patch": "@@ -169,6 +169,10 @@ static jas_stream_t *jas_stream_create()\n \treturn stream;\n }\n \n+#if 0\n+\n+/* Obsolete code. */\n+\n jas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n {\n \tjas_stream_t *stream;\n@@ -238,6 +242,136 @@ jas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n \treturn stream;\n }\n \n+#else\n+\n+/*\n+This function will eventually replace jas_stream_memopen.\n+If buf is 0 and bufsize > 0:\n+\ta buffer is dynamically allocated with size bufsize and this buffer is\n+\tnot growable.\n+If buf is 0 and bufsize is 0:\n+\ta buffer is dynamically allocated whose size will automatically grow to\n+\taccommodate the amount of data written.\n+If buf is not 0:\n+\tbufsize (which, in this case, is not currently allowed to be zero) is\n+\tthe size of the (nongrowable) buffer pointed to by buf.\n+*/\n+\n+jas_stream_t *jas_stream_memopen2(char *buf, size_t bufsize)\n+{\n+\tjas_stream_t *stream;\n+\tjas_stream_memobj_t *obj;\n+\n+\tJAS_DBGLOG(100, (\"jas_stream_memopen2(%p, %zu)\\n\", buf, bufsize));\n+\n+\tassert((buf && bufsize > 0) || (!buf));\n+\n+\tif (!(stream = jas_stream_create())) {\n+\t\treturn 0;\n+\t}\n+\n+\t/* A stream associated with a memory buffer is always opened\n+\tfor both reading and writing in binary mode. */\n+\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n+\n+\t/* Since the stream data is already resident in memory, buffering\n+\tis not necessary. */\n+\t/* But... It still may be faster to use buffering anyways. */\n+\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n+\n+\t/* Select the operations for a memory stream. */\n+\tstream->ops_ = &jas_stream_memops;\n+\n+\t/* Allocate memory for the underlying memory stream object. */\n+\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n+\t\tjas_stream_destroy(stream);\n+\t\treturn 0;\n+\t}\n+\tstream->obj_ = (void *) obj;\n+\n+\t/* Initialize a few important members of the memory stream object. */\n+\tobj->myalloc_ = 0;\n+\tobj->buf_ = 0;\n+\n+\t/* If the buffer size specified is nonpositive, then the buffer\n+\tis allocated internally and automatically grown as needed. */\n+\tif (!bufsize) {\n+\t\tobj->bufsize_ = 1024;\n+\t\tobj->growable_ = 1;\n+\t} else {\n+\t\tobj->bufsize_ = bufsize;\n+\t\tobj->growable_ = 0;\n+\t}\n+\tif (buf) {\n+\t\tobj->buf_ = JAS_CAST(unsigned char *, buf);\n+\t} else {\n+\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n+\t\tobj->myalloc_ = 1;\n+\t}\n+\tif (!obj->buf_) {\n+\t\tjas_stream_close(stream);\n+\t\treturn 0;\n+\t}\n+\tJAS_DBGLOG(100, (\"jas_stream_memopen2 buffer buf=%p myalloc=%d\\n\",\n+\t  obj->buf_, obj->myalloc_));\n+\n+\tif (bufsize > 0 && buf) {\n+\t\t/* If a buffer was supplied by the caller and its length is positive,\n+\t\t  make the associated buffer data appear in the stream initially. */\n+\t\tobj->len_ = bufsize;\n+\t} else {\n+\t\t/* The stream is initially empty. */\n+\t\tobj->len_ = 0;\n+\t}\n+\tobj->pos_ = 0;\n+\t\n+\treturn stream;\n+}\n+\n+/*\n+NOTE:\n+The version of the function jas_stream_memopen only exists for backwards\n+compatibility.\n+Eventually, it should be replaced by jas_stream_memopen2.\n+In retrospect, it was a very poor choice to have specified the buffer\n+size parameter (bufsize) to have type int.  On some machines, int may only\n+be a 16-bit integer.  This precludes larger-sized buffer allocations, which\n+are needed in practice.\n+\n+If bufsize <= 0, the buffer is growable; otherwise, the buffer has a fixed\n+size of bufsize.\n+If buf is 0, the buffer is dynamically allocated with jas_malloc.\n+If buf is not 0 and bufsize <= 0 (which is not permitted in any\n+circumstances), bad things will happen (especially if the buf was not\n+allocated with jas_malloc).\n+*/\n+jas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n+{\n+\tchar *new_buf;\n+\tsize_t new_bufsize;\n+\n+\tJAS_DBGLOG(100, (\"jas_stream_memopen(%p, %d)\\n\", buf, bufsize));\n+\tif (bufsize < 0) {\n+\t\tjas_deprecated(\"negative buffer size for jas_stream_memopen\");\n+\t}\n+\tif (buf && bufsize <= 0) {\n+\t\t// This was never a valid thing to do with the old API.\n+\t\tjas_eprintf(\"Invalid use of jas_stream_memopen detected.\\n\");\n+\t\tjas_deprecated(\"A user-provided buffer for \"\n+\t\t  \"jas_stream_memopen cannot be growable.\\n\");\n+\t}\n+\tif (bufsize <= 0) {\n+\t\tnew_bufsize = 0;\n+\t\tnew_buf = 0;\n+\t} else {\n+\t\tnew_bufsize = bufsize;\n+\t\tnew_buf = buf;\n+\t}\n+\treturn jas_stream_memopen2(new_buf, new_bufsize);\n+}\n+\n+#endif\n+\n jas_stream_t *jas_stream_fopen(const char *filename, const char *mode)\n {\n \tjas_stream_t *stream;\n@@ -520,6 +654,10 @@ int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n \tint c;\n \tchar *bufptr;\n \n+\tif (cnt < 0) {\n+\t\tjas_deprecated(\"negative count for jas_stream_read\");\n+\t}\n+\n \tbufptr = buf;\n \n \tn = 0;\n@@ -539,6 +677,10 @@ int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n \tint n;\n \tconst char *bufptr;\n \n+\tif (cnt < 0) {\n+\t\tjas_deprecated(\"negative count for jas_stream_write\");\n+\t}\n+\n \tbufptr = buf;\n \n \tn = 0;\n@@ -604,6 +746,9 @@ char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n int jas_stream_gobble(jas_stream_t *stream, int n)\n {\n \tint m;\n+\tif (n < 0) {\n+\t\tjas_deprecated(\"negative count for jas_stream_gobble\");\n+\t}\n \tm = n;\n \tfor (m = n; m > 0; --m) {\n \t\tif (jas_stream_getc(stream) == EOF) {\n@@ -616,6 +761,9 @@ int jas_stream_gobble(jas_stream_t *stream, int n)\n int jas_stream_pad(jas_stream_t *stream, int n, int c)\n {\n \tint m;\n+\tif (n < 0) {\n+\t\tjas_deprecated(\"negative count for jas_stream_pad\");\n+\t}\n \tm = n;\n \tfor (m = n; m > 0; --m) {\n \t\tif (jas_stream_putc(stream, c) == EOF)\n@@ -988,7 +1136,7 @@ long jas_stream_length(jas_stream_t *stream)\n \n static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n-\tint n;\n+\tssize_t n;\n \tassert(cnt >= 0);\n \tassert(buf);\n \n@@ -1001,14 +1149,21 @@ static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn cnt;\n }\n \n-static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n+static int mem_resize(jas_stream_memobj_t *m, size_t bufsize)\n {\n \tunsigned char *buf;\n \n \t//assert(m->buf_);\n-\tassert(bufsize >= 0);\n+\t//assert(bufsize >= 0);\n+\n+\tJAS_DBGLOG(100, (\"mem_resize(%p, %zu)\\n\", m, bufsize));\n+\tif (!bufsize) {\n+\t\tjas_eprintf(\n+\t\t  \"mem_resize was not really designed to handle a buffer of size 0\\n\"\n+\t\t  \"This may not work.\\n\"\n+\t\t);\n+\t}\n \n-\tJAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize));\n \tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n \t  bufsize) {\n \t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n@@ -1022,11 +1177,11 @@ static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n \n static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n-\tint n;\n+\tsize_t n;\n \tint ret;\n \tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n-\tlong newbufsize;\n-\tlong newpos;\n+\tsize_t newbufsize;\n+\tsize_t newpos;\n \n \tassert(buf);\n \tassert(cnt >= 0);\n@@ -1036,13 +1191,15 @@ static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \tif (newpos > m->bufsize_ && m->growable_) {\n \t\tnewbufsize = m->bufsize_;\n \t\twhile (newbufsize < newpos) {\n-\t\t\tnewbufsize <<= 1;\n-\t\t\tassert(newbufsize >= 0);\n+\t\t\t//newbufsize <<= 1;\n+\t\t\tif (!jas_safe_size_mul(newbufsize, 2, &newbufsize)) {\n+\t\t\t\tJAS_DBGLOG(100, (\"new buffer size would cause overflow\\n\"));\n+\t\t\t\treturn -1;\n+\t\t\t}\n \t\t}\n-\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %z\\n\", m->bufsize_,\n+\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %zu\\n\", m->bufsize_,\n \t\t  newbufsize));\n-\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %ul\\n\", m->bufsize_,\n-\t\t  JAS_CAST(unsigned long, newbufsize)));\n+\t\tassert(newbufsize > 0);\n \t\tif (mem_resize(m, newbufsize)) {\n \t\t\treturn -1;\n \t\t}\n@@ -1076,7 +1233,7 @@ static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n-\tlong newpos;\n+\tsize_t newpos;\n \n \tJAS_DBGLOG(100, (\"mem_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n \tswitch (origin) {"
        },
        {
          "filename": "src/libjasper/include/jasper/jas_debug.h",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -107,6 +107,9 @@ int jas_eprintf(const char *fmt, ...);\n /* Dump memory to a stream. */\n int jas_memdump(FILE *out, void *data, size_t len);\n \n+/* Warn about use of deprecated functionality. */\n+void jas_deprecated(const char *s);\n+\n #ifdef __cplusplus\n }\n #endif"
        },
        {
          "filename": "src/libjasper/include/jasper/jas_stream.h",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -267,7 +267,7 @@ typedef struct {\n \tuchar *buf_;\n \n \t/* The allocated size of the buffer for holding file data. */\n-\tint bufsize_;\n+\tsize_t bufsize_;\n \n \t/* The length of the file. */\n \tint_fast32_t len_;\n@@ -293,6 +293,10 @@ jas_stream_t *jas_stream_fopen(const char *filename, const char *mode);\n /* Open a memory buffer as a stream. */\n jas_stream_t *jas_stream_memopen(char *buf, int bufsize);\n \n+/* Do not use this function.\n+It will eventually replace jas_stream_memopen. */\n+jas_stream_t *jas_stream_memopen2(char *buf, size_t bufsize);\n+\n /* Open a file descriptor as a stream. */\n jas_stream_t *jas_stream_fdopen(int fd, const char *mode);\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8766848706a727f61c1c76a5a7cf1078433fad02",
            "date": "2024-04-27T17:53:19Z",
            "author_login": "mdadams"
          },
          {
            "sha": "2d6b6e8a9987386afe388e1cde859d0182445e63",
            "date": "2024-04-27T17:49:23Z",
            "author_login": "mdadams"
          },
          {
            "sha": "29154a52b6c2b895ac3db60d51be9f2a995ee145",
            "date": "2024-04-10T06:11:01Z",
            "author_login": "mdadams"
          },
          {
            "sha": "2fe7d2d73d18d9c7072507d462737b372f9d56bf",
            "date": "2024-03-30T16:57:05Z",
            "author_login": "mdadams"
          },
          {
            "sha": "6d084c53a77762f41bb5310713a5f1872fef55f5",
            "date": "2024-03-29T14:57:29Z",
            "author_login": "mdadams"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-190",
    "description": "Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-03-23T18:59:00.350",
    "last_modified": "2024-11-21T03:00:52.187",
    "fix_date": "2016-11-06T18:26:16Z"
  },
  "references": [
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/11/10/4",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/94224",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2017:1208",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://blogs.gentoo.org/ago/2016/11/07/jasper-use-after-free-in-jas_realloc-jas_malloc-c",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1393882",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201707-07",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://usn.ubuntu.com/3693-1/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/11/10/4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/94224",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2017:1208",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://blogs.gentoo.org/ago/2016/11/07/jasper-use-after-free-in-jas_realloc-jas_malloc-c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1393882",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201707-07",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://usn.ubuntu.com/3693-1/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:54.816602",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "jasper",
    "owner": "mdadams",
    "created_at": "2016-09-16T18:52:32Z",
    "updated_at": "2025-01-10T13:03:21Z",
    "pushed_at": "2024-04-27T17:54:09Z",
    "size": 4405,
    "stars": 232,
    "forks": 102,
    "open_issues": 4,
    "watchers": 232,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1567274,
      "Shell": 147989,
      "CMake": 50869,
      "Roff": 3703,
      "Batchfile": 1905,
      "C++": 235
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T14:01:40.770708"
  }
}