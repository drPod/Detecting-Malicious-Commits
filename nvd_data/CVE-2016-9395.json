{
  "cve_id": "CVE-2016-9395",
  "github_data": {
    "repository": "mdadams/jasper",
    "fix_commit": "d42b2388f7f8e0332c846675133acea151fc557a",
    "related_commits": [
      "d42b2388f7f8e0332c846675133acea151fc557a",
      "d42b2388f7f8e0332c846675133acea151fc557a"
    ],
    "patch_url": "https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a.patch",
    "fix_commit_details": {
      "sha": "d42b2388f7f8e0332c846675133acea151fc557a",
      "commit_date": "2016-11-12T00:27:34Z",
      "author": {
        "login": "mdadams",
        "type": "User",
        "stats": {
          "total_commits": 971,
          "average_weekly_commits": 1.2742782152230971,
          "total_additions": 188275,
          "total_deletions": 114603,
          "weeks_active": 97
        }
      },
      "commit_message": {
        "title": "The generation of the configuration file jas_config.h has been completely",
        "length": 1101,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 794,
        "additions": 524,
        "deletions": 270
      },
      "files": [
        {
          "filename": ".gitignore",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -40,6 +40,7 @@ Makefile.in\n \n # ./src/libjasper/include/jasper directory\n /src/libjasper/include/jasper/jas_config.h\n-/src/libjasper/include/jasper/jas_config.h.in\n-/src/libjasper/include/jasper/jas_config.h.in~\n+/src/libjasper/include/jasper/jas_pconf.h\n+/src/libjasper/include/jasper/jas_pconf.h.in\n+/src/libjasper/include/jasper/jas_pconf.h.in~\n /src/libjasper/include/jasper/stamp-h1"
        },
        {
          "filename": "configure.ac",
          "status": "modified",
          "additions": 71,
          "deletions": 43,
          "patch": "@@ -132,16 +132,6 @@ AH_TOP([\n /* If configure is being used, this symbol will be defined automatically\n   at this point in the configuration header file. */\n \n-#if defined(__GNUC__) && !defined(__clang__)\n-#define JAS_ATTRIBUTE_DISABLE_USAN \\\n-  __attribute__((no_sanitize_undefined))\n-#elif defined(__clang__)\n-#define JAS_ATTRIBUTE_DISABLE_USAN \\\n-  __attribute__((no_sanitize(\"undefined\")))\n-#else\n-#define JAS_ATTRIBUTE_DISABLE_USAN\n-#endif\n-\n /* The preprocessor symbol JAS_WIN_MSVC_BUILD should not be defined\n   unless the JasPer software is being built under Microsoft Windows\n   using Microsoft Visual C. */\n@@ -153,7 +143,7 @@ AH_TOP([\n AH_BOTTOM([\n #else\n /* A configure-based build is not being used. */\n-#include <jasper/jas_config2.h>\n+#include <jasper/jas_pconf2.h>\n #endif\n \n #endif\n@@ -312,31 +302,82 @@ AC_CHECK_LIB(m, main)\n # Check for header files.\n ############################################################\n \n-AC_HEADER_STDC\n-AC_CHECK_HEADERS(fcntl.h limits.h unistd.h stdint.h stdbool.h io.h windows.h sys/types.h sys/time.h stdlib.h stddef.h)\n+dnl AC_HEADER_STDC\n+AC_CHECK_HEADERS(fcntl.h io.h unistd.h windows.h sys/time.h sys/types.h)\n+\n+# Surely, there must be a better way to do this, but\n+# let's just get something working for now.\n+\n+if test $ac_cv_header_fcntl_h = yes; then\n+\tAC_SUBST([JAS_HAVE_FCNTL_H], [\"#define JAS_HAVE_FCNTL_H 1\"])\n+else\n+\tAC_SUBST([JAS_HAVE_FCNTL_H], [\"#undef JAS_HAVE_FCNTL_H\"])\n+fi\n+\n+if test $ac_cv_header_io_h = yes; then\n+\tAC_SUBST([JAS_HAVE_IO_H], [\"#define JAS_HAVE_IO_H 1\"])\n+else\n+\tAC_SUBST([JAS_HAVE_IO_H], [\"#undef JAS_HAVE_IO_H\"])\n+fi\n+\n+if test $ac_cv_header_unistd_h = yes; then\n+\tAC_SUBST([JAS_HAVE_UNISTD_H], [\"#define JAS_HAVE_UNISTD_H 1\"])\n+else\n+\tAC_SUBST([JAS_HAVE_UNISTD_H], [\"#undef JAS_HAVE_UNISTD_H\"])\n+fi\n+\n+if test $ac_cv_header_windows_h = yes; then\n+\tAC_SUBST([JAS_HAVE_WINDOWS_H], [\"#define JAS_HAVE_WINDOWS_H 1\"])\n+else\n+\tAC_SUBST([JAS_HAVE_WINDOWS_H], [\"#undef JAS_HAVE_WINDOWS_H\"])\n+fi\n+\n+if test $ac_cv_header_sys_time_h = yes; then\n+\tAC_SUBST([JAS_HAVE_SYS_TIME_H], [\"#define JAS_HAVE_SYS_TIME_H 1\"])\n+else\n+\tAC_SUBST([JAS_HAVE_SYS_TIME_H], [\"#undef JAS_HAVE_SYS_TIME_H\"])\n+fi\n+\n+if test $ac_cv_header_sys_types_h = yes; then\n+\tAC_SUBST([JAS_HAVE_SYS_TYPES_H], [\"#define JAS_HAVE_SYS_TYPES_H 1\"])\n+else\n+\tAC_SUBST([JAS_HAVE_SYS_TYPES_H], [\"#undef JAS_HAVE_SYS_TYPES_H\"])\n+fi\n \n ############################################################\n # Check for typedefs, structures, and compiler characteristics.\n ############################################################\n \n-AC_C_CONST\n-AC_C_INLINE\n-AC_TYPE_SIZE_T\n-AC_CHECK_TYPE(uchar, unsigned char)\n-AC_CHECK_TYPE(ushort, unsigned short)\n-AC_CHECK_TYPE(uint, unsigned int)\n-AC_CHECK_TYPE(ulong, unsigned long)\n-AC_CHECK_TYPE(longlong, long long)\n-AC_CHECK_TYPE(ulonglong, unsigned long long)\n-AC_CHECK_TYPE(ssize_t, int)\n+dnl AC_C_CONST\n+dnl AC_C_INLINE\n+dnl AC_TYPE_SIZE_T\n+dnl AC_CHECK_TYPE(uchar, unsigned char)\n+dnl AC_CHECK_TYPE(ushort, unsigned short)\n+dnl AC_CHECK_TYPE(uint, unsigned int)\n+dnl AC_CHECK_TYPE(ulong, unsigned long)\n+dnl AC_CHECK_TYPE(longlong, long long)\n+dnl AC_CHECK_TYPE(ulonglong, unsigned long long)\n+dnl AC_CHECK_TYPE(ssize_t, int)\n AC_CHECK_FUNCS(gettimeofday)\n AC_CHECK_FUNCS(getrusage)\n \n+if test $ac_cv_func_gettimeofday = yes; then\n+\tAC_SUBST([JAS_HAVE_GETTIMEOFDAY], [\"#define JAS_HAVE_GETTIMEOFDAY 1\"])\n+else\n+\tAC_SUBST([JAS_HAVE_GETTIMEOFDAY], [\"#undef JAS_HAVE_GETTIMEOFDAY\"])\n+fi\n+\n+if test $ac_cv_func_getrusage = yes; then\n+\tAC_SUBST([JAS_HAVE_GETRUSAGE], [\"#define JAS_HAVE_GETRUSAGE 1\"])\n+else\n+\tAC_SUBST([JAS_HAVE_GETRUSAGE], [\"#undef JAS_HAVE_GETRUSAGE\"])\n+fi\n+\n ############################################################\n # Checks for library functions.\n ############################################################\n \n-AC_FUNC_VPRINTF\n+dnl AC_FUNC_VPRINTF\n \n ############################################################\n # Enable memory limit feature.\n@@ -432,26 +473,9 @@ esac\n ], [debug=no])\n \n ############################################################\n-# Extra stuff for research purposes.\n+# Extra stuff\n ############################################################\n \n-AC_ARG_ENABLE(special0,\n-[  --enable-special0    enable something],\n-[\n-case \"${enableval}\" in\n-yes)\n-\tif test \"$GCC\" = yes; then\n-\t\tCFLAGS=\"-g -O0\"\n-\tfi\n-\t;;\n-no)\n-\t;;\n-*)\n-\tAC_MSG_ERROR(bad value ${enableval} for --enable-special0)\n-\t;;\n-esac\n-], [])\n-\n if test -n \"$EXTRA_CFLAGS\"; then\n \tCFLAGS=\"$CFLAGS $EXTRA_CFLAGS\"\n fi\n@@ -460,13 +484,17 @@ fi\n # Generate the configuration header file.\n ############################################################\n \n-AC_CONFIG_HEADERS([src/libjasper/include/jasper/jas_config.h])\n+# The private header file generated by AC_CONFIG_HEADERS is not\n+# currently used.  This just causes less verbose command lines\n+# when make is run.\n+AC_CONFIG_HEADERS([src/libjasper/include/jasper/jas_pconf.h])\n \n ############################################################\n # Generate the makefiles.\n ############################################################\n \n AC_CONFIG_FILES([\n+src/libjasper/include/jasper/jas_config.h\n Makefile\n src/Makefile\n src/appl/Makefile"
        },
        {
          "filename": "src/appl/imginfo.c",
          "status": "modified",
          "additions": 18,
          "deletions": 5,
          "patch": "@@ -88,6 +88,7 @@ typedef enum {\n \tOPT_VERBOSE,\n \tOPT_INFILE,\n \tOPT_DEBUG,\n+\tOPT_MAXSAMPLES,\n \tOPT_MAXMEM\n } optid_t;\n \n@@ -108,6 +109,7 @@ static jas_opt_t opts[] = {\n \t{OPT_VERBOSE, \"verbose\", 0},\n \t{OPT_INFILE, \"f\", JAS_OPT_HASARG},\n \t{OPT_DEBUG, \"debug-level\", JAS_OPT_HASARG},\n+\t{OPT_MAXSAMPLES, \"max-samples\", JAS_OPT_HASARG},\n #if defined(JAS_DEFAULT_MAX_MEM_USAGE)\n \t{OPT_MAXMEM, \"memory-limit\", JAS_OPT_HASARG},\n #endif\n@@ -135,13 +137,16 @@ int main(int argc, char **argv)\n \tchar *fmtname;\n \tint debug;\n \tsize_t max_mem;\n+\tsize_t max_samples;\n+\tchar optstr[32];\n \n \tif (jas_init()) {\n \t\tabort();\n \t}\n \n \tcmdname = argv[0];\n \n+\tmax_samples = 64 * JAS_MEBI;\n \tinfile = 0;\n \tverbose = 0;\n \tdebug = 0;\n@@ -165,6 +170,9 @@ int main(int argc, char **argv)\n \t\tcase OPT_INFILE:\n \t\t\tinfile = jas_optarg;\n \t\t\tbreak;\n+\t\tcase OPT_MAXSAMPLES:\n+\t\t\tmax_samples = strtoull(jas_optarg, 0, 10);\n+\t\t\tbreak;\n \t\tcase OPT_MAXMEM:\n \t\t\tmax_mem = strtoull(jas_optarg, 0, 10);\n \t\t\tbreak;\n@@ -199,8 +207,10 @@ int main(int argc, char **argv)\n \t\tfprintf(stderr, \"unknown image format\\n\");\n \t}\n \n+\tsnprintf(optstr, sizeof(optstr), \"max_samples=%-zu\", max_samples);\n+\n \t/* Decode the image. */\n-\tif (!(image = jas_image_decode(instream, fmtid, 0))) {\n+\tif (!(image = jas_image_decode(instream, fmtid, optstr))) {\n \t\tjas_stream_close(instream);\n \t\tfprintf(stderr, \"cannot load image\\n\");\n \t\treturn EXIT_FAILURE;\n@@ -209,6 +219,11 @@ int main(int argc, char **argv)\n \t/* Close the image file. */\n \tjas_stream_close(instream);\n \n+\tif (!(fmtname = jas_image_fmttostr(fmtid))) {\n+\t\tjas_eprintf(\"format name lookup failed\\n\");\n+\t\treturn EXIT_FAILURE;\n+\t}\n+\n \tif (!(numcmpts = jas_image_numcmpts(image))) {\n \t\tfprintf(stderr, \"warning: image has no components\\n\");\n \t}\n@@ -221,10 +236,8 @@ int main(int argc, char **argv)\n \t\theight = 0;\n \t\tdepth = 0;\n \t}\n-\tif (!(fmtname = jas_image_fmttostr(fmtid))) {\n-\t\tabort();\n-\t}\n-\tprintf(\"%s %d %d %d %d %ld\\n\", fmtname, numcmpts, width, height, depth, (long) jas_image_rawsize(image));\n+\tprintf(\"%s %d %d %d %d %ld\\n\", fmtname, numcmpts, width, height, depth,\n+\t  JAS_CAST(long, jas_image_rawsize(image)));\n \n \tjas_image_destroy(image);\n \tjas_image_clearfmts();"
        },
        {
          "filename": "src/libjasper/base/jas_debug.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -122,7 +122,7 @@ int jas_memdump(FILE *out, void *data, size_t len)\n {\n \tsize_t i;\n \tsize_t j;\n-\tuchar *dp;\n+\tjas_uchar *dp;\n \tdp = data;\n \tfor (i = 0; i < len; i += 16) {\n \t\tfprintf(out, \"%04zx:\", i);"
        },
        {
          "filename": "src/libjasper/base/jas_icc.c",
          "status": "modified",
          "additions": 15,
          "deletions": 15,
          "patch": "@@ -82,14 +82,14 @@\n \n static jas_iccattrval_t *jas_iccattrval_create0(void);\n \n-static int jas_iccgetuint(jas_stream_t *in, int n, ulonglong *val);\n+static int jas_iccgetuint(jas_stream_t *in, int n, jas_ulonglong *val);\n static int jas_iccgetuint8(jas_stream_t *in, jas_iccuint8_t *val);\n static int jas_iccgetuint16(jas_stream_t *in, jas_iccuint16_t *val);\n static int jas_iccgetsint32(jas_stream_t *in, jas_iccsint32_t *val);\n static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val);\n static int jas_iccgetuint64(jas_stream_t *in, jas_iccuint64_t *val);\n-static int jas_iccputuint(jas_stream_t *out, int n, ulonglong val);\n-static int jas_iccputsint(jas_stream_t *out, int n, longlong val);\n+static int jas_iccputuint(jas_stream_t *out, int n, jas_ulonglong val);\n+static int jas_iccputsint(jas_stream_t *out, int n, jas_longlong val);\n static jas_iccprof_t *jas_iccprof_create(void);\n static int jas_iccprof_readhdr(jas_stream_t *in, jas_icchdr_t *hdr);\n static int jas_iccprof_writehdr(jas_stream_t *out, jas_icchdr_t *hdr);\n@@ -1603,11 +1603,11 @@ static void jas_icclut16_dump(jas_iccattrval_t *attrval, FILE *out)\n *\n \\******************************************************************************/\n \n-static int jas_iccgetuint(jas_stream_t *in, int n, ulonglong *val)\n+static int jas_iccgetuint(jas_stream_t *in, int n, jas_ulonglong *val)\n {\n \tint i;\n \tint c;\n-\tulonglong v;\n+\tjas_ulonglong v;\n \tv = 0;\n \tfor (i = n; i > 0; --i) {\n \t\tif ((c = jas_stream_getc(in)) == EOF)\n@@ -1629,7 +1629,7 @@ static int jas_iccgetuint8(jas_stream_t *in, jas_iccuint8_t *val)\n \n static int jas_iccgetuint16(jas_stream_t *in, jas_iccuint16_t *val)\n {\n-\tulonglong tmp;\n+\tjas_ulonglong tmp;\n \tif (jas_iccgetuint(in, 2, &tmp))\n \t\treturn -1;\n \t*val = tmp;\n@@ -1638,17 +1638,17 @@ static int jas_iccgetuint16(jas_stream_t *in, jas_iccuint16_t *val)\n \n static int jas_iccgetsint32(jas_stream_t *in, jas_iccsint32_t *val)\n {\n-\tulonglong tmp;\n+\tjas_ulonglong tmp;\n \tif (jas_iccgetuint(in, 4, &tmp))\n \t\treturn -1;\n-\t*val = (tmp & 0x80000000) ? (-JAS_CAST(longlong, (((~tmp) &\n-\t  0x7fffffff) + 1))) : JAS_CAST(longlong, tmp);\n+\t*val = (tmp & 0x80000000) ? (-JAS_CAST(jas_longlong, (((~tmp) &\n+\t  0x7fffffff) + 1))) : JAS_CAST(jas_longlong, tmp);\n \treturn 0;\n }\n \n static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)\n {\n-\tulonglong tmp;\n+\tjas_ulonglong tmp;\n \tif (jas_iccgetuint(in, 4, &tmp))\n \t\treturn -1;\n \t*val = tmp;\n@@ -1657,14 +1657,14 @@ static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)\n \n static int jas_iccgetuint64(jas_stream_t *in, jas_iccuint64_t *val)\n {\n-\tulonglong tmp;\n+\tjas_ulonglong tmp;\n \tif (jas_iccgetuint(in, 8, &tmp))\n \t\treturn -1;\n \t*val = tmp;\n \treturn 0;\n }\n \n-static int jas_iccputuint(jas_stream_t *out, int n, ulonglong val)\n+static int jas_iccputuint(jas_stream_t *out, int n, jas_ulonglong val)\n {\n \tint i;\n \tint c;\n@@ -1676,9 +1676,9 @@ static int jas_iccputuint(jas_stream_t *out, int n, ulonglong val)\n \treturn 0;\n }\n \n-static int jas_iccputsint(jas_stream_t *out, int n, longlong val)\n+static int jas_iccputsint(jas_stream_t *out, int n, jas_longlong val)\n {\n-\tulonglong tmp;\n+\tjas_ulonglong tmp;\n \ttmp = (val < 0) ? (abort(), 0) : val;\n \treturn jas_iccputuint(out, n, tmp);\n }\n@@ -1719,7 +1719,7 @@ static long jas_iccpowi(int x, int n)\n }\n \n \n-jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)\n+jas_iccprof_t *jas_iccprof_createfrombuf(jas_uchar *buf, int len)\n {\n \tjas_stream_t *in;\n \tjas_iccprof_t *prof;"
        },
        {
          "filename": "src/libjasper/base/jas_iccdata.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -62,7 +62,7 @@\n #include <jasper/jas_config.h>\n #include <jasper/jas_types.h>\n \n-uchar jas_iccprofdata_srgb[] =\n+jas_uchar jas_iccprofdata_srgb[] =\n {\n \t0x00, 0x00, 0x0c, 0x48, 0x4c, 0x69, 0x6e, 0x6f,\n \t0x02, 0x10, 0x00, 0x00, 0x6d, 0x6e, 0x74, 0x72,\n@@ -461,7 +461,7 @@ uchar jas_iccprofdata_srgb[] =\n \n int jas_iccprofdata_srgblen = sizeof(jas_iccprofdata_srgb);\n \n-uchar jas_iccprofdata_sgray[] = {\n+jas_uchar jas_iccprofdata_sgray[] = {\n \t0x00, 0x00, 0x01, 0x8a, 0x00, 0x00, 0x00, 0x00,\n \t0x02, 0x20, 0x00, 0x00, 0x73, 0x63, 0x6e, 0x72,\n \t0x47, 0x52, 0x41, 0x59, 0x58, 0x59, 0x5a, 0x20,"
        },
        {
          "filename": "src/libjasper/base/jas_image.c",
          "status": "modified",
          "additions": 46,
          "deletions": 14,
          "patch": "@@ -133,30 +133,35 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,\n   int clrspc)\n {\n \tjas_image_t *image;\n-\tuint_fast32_t rawsize;\n+\tsize_t rawsize;\n \tuint_fast32_t inmem;\n \tint cmptno;\n \tjas_image_cmptparm_t *cmptparm;\n \n+\timage = 0;\n+\n+\tJAS_DBGLOG(100, (\"jas_image_create(%d, %p, %d)\\n\", numcmpts, cmptparms,\n+\t  clrspc));\n+\n \tif (!(image = jas_image_create0())) {\n-\t\treturn 0;\n+\t\tgoto error;\n \t}\n \n \timage->clrspc_ = clrspc;\n \timage->maxcmpts_ = numcmpts;\n-\timage->inmem_ = true;\n+//\timage->inmem_ = true;\n \n \t/* Allocate memory for the per-component information. */\n \tif (!(image->cmpts_ = jas_alloc2(image->maxcmpts_,\n \t  sizeof(jas_image_cmpt_t *)))) {\n-\t\tjas_image_destroy(image);\n-\t\treturn 0;\n+\t\tgoto error;\n \t}\n \t/* Initialize in case of failure. */\n \tfor (cmptno = 0; cmptno < image->maxcmpts_; ++cmptno) {\n \t\timage->cmpts_[cmptno] = 0;\n \t}\n \n+#if 0\n \t/* Compute the approximate raw size of the image. */\n \trawsize = 0;\n \tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n@@ -167,16 +172,22 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,\n \t/* Decide whether to buffer the image data in memory, based on the\n \t  raw size of the image. */\n \tinmem = (rawsize < JAS_IMAGE_INMEMTHRESH);\n+#endif\n \n \t/* Create the individual image components. */\n \tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n \t  ++cmptparm) {\n+\t\tif (!jas_safe_size_mul3(cmptparm->width, cmptparm->height,\n+\t\t  (cmptparm->prec + 7), &rawsize)) {\n+\t\t\tgoto error;\n+\t\t}\n+\t\trawsize /= 8;\n+\t\tinmem = (rawsize < JAS_IMAGE_INMEMTHRESH);\n \t\tif (!(image->cmpts_[cmptno] = jas_image_cmpt_create(cmptparm->tlx,\n \t\t  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,\n \t\t  cmptparm->width, cmptparm->height, cmptparm->prec,\n \t\t  cmptparm->sgnd, inmem))) {\n-\t\t\tjas_image_destroy(image);\n-\t\t\treturn 0;\n+\t\t\tgoto error;\n \t\t}\n \t\t++image->numcmpts_;\n \t}\n@@ -186,6 +197,12 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,\n \tjas_image_setbbox(image);\n \n \treturn image;\n+\n+error:\n+\tif (image) {\n+\t\tjas_image_destroy(image);\n+\t}\n+\treturn 0;\n }\n \n jas_image_t *jas_image_create0()\n@@ -204,7 +221,7 @@ jas_image_t *jas_image_create0()\n \timage->numcmpts_ = 0;\n \timage->maxcmpts_ = 0;\n \timage->cmpts_ = 0;\n-\timage->inmem_ = true;\n+//\timage->inmem_ = true;\n \timage->cmprof_ = 0;\n \n \treturn image;\n@@ -316,6 +333,19 @@ static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n \tjas_image_cmpt_t *cmpt;\n \tsize_t size;\n \n+\tJAS_DBGLOG(100, (\n+\t  \"jas_image_cmpt_create(%ld, %ld, %ld, %ld, %ld, %ld, %d, %d, %d)\\n\",\n+\t  JAS_CAST(long, tlx),\n+\t  JAS_CAST(long, tly),\n+\t  JAS_CAST(long, hstep),\n+\t  JAS_CAST(long, vstep),\n+\t  JAS_CAST(long, width),\n+\t  JAS_CAST(long, height),\n+\t  JAS_CAST(int, depth),\n+\t  sgnd,\n+\t  inmem\n+\t  ));\n+\n \tcmpt = 0;\n \tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n \t\tgoto error;\n@@ -324,6 +354,9 @@ static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n \t  !jas_safe_intfast32_add(tly, height, 0)) {\n \t\tgoto error;\n \t}\n+\tif (!jas_safe_intfast32_mul3(width, height, depth, 0)) {\n+\t\tgoto error;\n+\t}\n \n \tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n \t\tgoto error;\n@@ -344,8 +377,7 @@ static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n \t// Compute the number of samples in the image component, while protecting\n \t// against overflow.\n \t// size = cmpt->width_ * cmpt->height_ * cmpt->cps_;\n-\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n-\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n+\tif (!jas_safe_size_mul3(cmpt->width_, cmpt->height_, cmpt->cps_, &size)) {\n \t\tgoto error;\n \t}\n \tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :\n@@ -1279,7 +1311,7 @@ static void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,\n \t*bry = tmpbry;\n }\n \n-static inline long decode_twos_comp(ulong c, int prec)\n+static inline long decode_twos_comp(jas_ulong c, int prec)\n {\n \tlong result;\n \tassert(prec >= 2);\n@@ -1289,9 +1321,9 @@ static inline long decode_twos_comp(ulong c, int prec)\n \treturn result;\n }\n \n-static inline ulong encode_twos_comp(long n, int prec)\n+static inline jas_ulong encode_twos_comp(long n, int prec)\n {\n-\tulong result;\n+\tjas_ulong result;\n \tassert(prec >= 2);\n \tjas_eprintf(\"warning: support for signed data is untested\\n\");\n \t// NOTE: Is this correct?\n@@ -1332,7 +1364,7 @@ static int putint(jas_stream_t *out, int sgnd, int prec, long val)\n \tint n;\n \tint c;\n \tbool s;\n-\tulong tmp;\n+\tjas_ulong tmp;\n \tassert((!sgnd && prec >= 1) || (sgnd && prec >= 2));\n \tif (sgnd) {\n \t\tval = encode_twos_comp(val, prec);"
        },
        {
          "filename": "src/libjasper/base/jas_seq.c",
          "status": "modified",
          "additions": 58,
          "deletions": 44,
          "patch": "@@ -84,7 +84,8 @@\n * Constructors and destructors.\n \\******************************************************************************/\n \n-jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)\n+jas_matrix_t *jas_seq2d_create(jas_matind_t xstart, jas_matind_t ystart,\n+  jas_matind_t xend, jas_matind_t yend)\n {\n \tjas_matrix_t *matrix;\n \tassert(xstart <= xend && ystart <= yend);\n@@ -98,10 +99,10 @@ jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)\n \treturn matrix;\n }\n \n-jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n+jas_matrix_t *jas_matrix_create(jas_matind_t numrows, jas_matind_t numcols)\n {\n \tjas_matrix_t *matrix;\n-\tint i;\n+\tjas_matind_t i;\n \tsize_t size;\n \n \tmatrix = 0;\n@@ -180,8 +181,8 @@ void jas_matrix_destroy(jas_matrix_t *matrix)\n jas_seq2d_t *jas_seq2d_copy(jas_seq2d_t *x)\n {\n \tjas_matrix_t *y;\n-\tint i;\n-\tint j;\n+\tjas_matind_t i;\n+\tjas_matind_t j;\n \ty = jas_seq2d_create(jas_seq2d_xstart(x), jas_seq2d_ystart(x),\n \t  jas_seq2d_xend(x), jas_seq2d_yend(x));\n \tassert(y);\n@@ -196,8 +197,8 @@ jas_seq2d_t *jas_seq2d_copy(jas_seq2d_t *x)\n jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)\n {\n \tjas_matrix_t *y;\n-\tint i;\n-\tint j;\n+\tjas_matind_t i;\n+\tjas_matind_t j;\n \ty = jas_matrix_create(x->numrows_, x->numcols_);\n \tfor (i = 0; i < x->numrows_; ++i) {\n \t\tfor (j = 0; j < x->numcols_; ++j) {\n@@ -211,17 +212,17 @@ jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)\n * Bind operations.\n \\******************************************************************************/\n \n-void jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, int xstart,\n-  int ystart, int xend, int yend)\n+void jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, jas_matind_t xstart,\n+  jas_matind_t ystart, jas_matind_t xend, jas_matind_t yend)\n {\n \tjas_matrix_bindsub(s, s1, ystart - s1->ystart_, xstart - s1->xstart_,\n \t  yend - s1->ystart_ - 1, xend - s1->xstart_ - 1);\n }\n \n-void jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, int r0,\n-  int c0, int r1, int c1)\n+void jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1,\n+  jas_matind_t r0, jas_matind_t c0, jas_matind_t r1, jas_matind_t c1)\n {\n-\tint i;\n+\tjas_matind_t i;\n \n \tif (mat0->data_) {\n \t\tif (!(mat0->flags_ & JAS_MATRIX_REF)) {\n@@ -265,8 +266,8 @@ void jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, int r0,\n \n int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n {\n-\tint i;\n-\tint j;\n+\tjas_matind_t i;\n+\tjas_matind_t j;\n \n \tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=\n \t  mat1->numcols_) {\n@@ -284,10 +285,10 @@ int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n \n void jas_matrix_divpow2(jas_matrix_t *matrix, int n)\n {\n-\tint i;\n-\tint j;\n+\tjas_matind_t i;\n+\tjas_matind_t j;\n \tjas_seqent_t *rowstart;\n-\tint rowstep;\n+\tjas_matind_t rowstep;\n \tjas_seqent_t *data;\n \n \tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n@@ -307,12 +308,12 @@ void jas_matrix_divpow2(jas_matrix_t *matrix, int n)\n void jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval,\n   jas_seqent_t maxval)\n {\n-\tint i;\n-\tint j;\n+\tjas_matind_t i;\n+\tjas_matind_t j;\n \tjas_seqent_t v;\n \tjas_seqent_t *rowstart;\n \tjas_seqent_t *data;\n-\tint rowstep;\n+\tjas_matind_t rowstep;\n \n \tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n \t\tassert(matrix->rows_);\n@@ -335,10 +336,10 @@ void jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval,\n \n void jas_matrix_asr(jas_matrix_t *matrix, int n)\n {\n-\tint i;\n-\tint j;\n+\tjas_matind_t i;\n+\tjas_matind_t j;\n \tjas_seqent_t *rowstart;\n-\tint rowstep;\n+\tjas_matind_t rowstep;\n \tjas_seqent_t *data;\n \n \tassert(n >= 0);\n@@ -358,10 +359,10 @@ void jas_matrix_asr(jas_matrix_t *matrix, int n)\n \n void jas_matrix_asl(jas_matrix_t *matrix, int n)\n {\n-\tint i;\n-\tint j;\n+\tjas_matind_t i;\n+\tjas_matind_t j;\n \tjas_seqent_t *rowstart;\n-\tint rowstep;\n+\tjas_matind_t rowstep;\n \tjas_seqent_t *data;\n \n \tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n@@ -382,10 +383,11 @@ void jas_matrix_asl(jas_matrix_t *matrix, int n)\n * Code.\n \\******************************************************************************/\n \n-int jas_matrix_resize(jas_matrix_t *matrix, int numrows, int numcols)\n+int jas_matrix_resize(jas_matrix_t *matrix, jas_matind_t numrows,\n+  jas_matind_t numcols)\n {\n-\tint size;\n-\tint i;\n+\tjas_matind_t size;\n+\tjas_matind_t i;\n \n \tsize = numrows * numcols;\n \tif (size > matrix->datasize_ || numrows > matrix->maxrows_) {\n@@ -404,10 +406,10 @@ int jas_matrix_resize(jas_matrix_t *matrix, int numrows, int numcols)\n \n void jas_matrix_setall(jas_matrix_t *matrix, jas_seqent_t val)\n {\n-\tint i;\n-\tint j;\n+\tjas_matind_t i;\n+\tjas_matind_t j;\n \tjas_seqent_t *rowstart;\n-\tint rowstep;\n+\tjas_matind_t rowstep;\n \tjas_seqent_t *data;\n \n \tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n@@ -426,20 +428,32 @@ void jas_matrix_setall(jas_matrix_t *matrix, jas_seqent_t val)\n jas_matrix_t *jas_seq2d_input(FILE *in)\n {\n \tjas_matrix_t *matrix;\n-\tint i;\n-\tint j;\n+\tjas_matind_t i;\n+\tjas_matind_t j;\n \tlong x;\n-\tint numrows;\n-\tint numcols;\n-\tint xoff;\n-\tint yoff;\n-\n-\tif (fscanf(in, \"%d %d\", &xoff, &yoff) != 2)\n+\tjas_matind_t numrows;\n+\tjas_matind_t numcols;\n+\tjas_matind_t xoff;\n+\tjas_matind_t yoff;\n+\tlong tmp_xoff;\n+\tlong tmp_yoff;\n+\tlong tmp_numrows;\n+\tlong tmp_numcols;\n+\n+\tif (fscanf(in, \"%ld %ld\", &tmp_xoff, &tmp_yoff) != 2) {\n \t\treturn 0;\n-\tif (fscanf(in, \"%d %d\", &numcols, &numrows) != 2)\n+\t}\n+\txoff = tmp_xoff;\n+\tyoff = tmp_yoff;\n+\tif (fscanf(in, \"%ld %ld\", &tmp_numcols, &tmp_numrows) != 2) {\n \t\treturn 0;\n-\tif (!(matrix = jas_seq2d_create(xoff, yoff, xoff + numcols, yoff + numrows)))\n+\t}\n+\tnumrows = tmp_numrows;\n+\tnumcols = tmp_numcols;\n+\tif (!(matrix = jas_seq2d_create(xoff, yoff, xoff + numcols,\n+\t  yoff + numrows))) {\n \t\treturn 0;\n+\t}\n \n \tif (jas_matrix_numrows(matrix) != numrows ||\n \t  jas_matrix_numcols(matrix) != numcols) {\n@@ -463,8 +477,8 @@ jas_matrix_t *jas_seq2d_input(FILE *in)\n int jas_seq2d_output(jas_matrix_t *matrix, FILE *out)\n {\n #define MAXLINELEN\t80\n-\tint i;\n-\tint j;\n+\tjas_matind_t i;\n+\tjas_matind_t j;\n \tjas_seqent_t x;\n \tchar buf[MAXLINELEN + 1];\n \tchar sbuf[MAXLINELEN + 1];"
        },
        {
          "filename": "src/libjasper/base/jas_stream.c",
          "status": "modified",
          "additions": 7,
          "deletions": 4,
          "patch": "@@ -71,18 +71,21 @@\n * Includes.\n \\******************************************************************************/\n \n+/* The configuration header file should be included first. */\n+#include \"jasper/jas_config.h\"\n+\n #include <assert.h>\n-#if defined(HAVE_FCNTL_H)\n+#if defined(JAS_HAVE_FCNTL_H)\n #include <fcntl.h>\n #endif\n #include <stdlib.h>\n #include <stdarg.h>\n #include <stdio.h>\n #include <ctype.h>\n-#if defined(HAVE_UNISTD_H)\n+#if defined(JAS_HAVE_UNISTD_H)\n #include <unistd.h>\n #endif\n-#if defined(WIN32) || defined(HAVE_IO_H)\n+#if defined(WIN32) || defined(JAS_HAVE_IO_H)\n #include <io.h>\n #endif\n \n@@ -909,7 +912,7 @@ static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n \t\t\t/* The buffer must be large enough to accommodate maximum\n \t\t\t  putback. */\n \t\t\tassert(bufsize > JAS_STREAM_MAXPUTBACK);\n-\t\t\tstream->bufbase_ = JAS_CAST(uchar *, buf);\n+\t\t\tstream->bufbase_ = JAS_CAST(jas_uchar *, buf);\n \t\t\tstream->bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK;\n \t\t}\n \t} else {"
        },
        {
          "filename": "src/libjasper/base/jas_tmr.c",
          "status": "modified",
          "additions": 5,
          "deletions": 2,
          "patch": "@@ -69,6 +69,9 @@\n * Includes.\n \\******************************************************************************/\n \n+/* The configuration header file should be included first. */\n+#include \"jasper/jas_config.h\"\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <time.h>\n@@ -79,7 +82,7 @@\n * Code.\n \\******************************************************************************/\n \n-#if defined(HAVE_GETTIMEOFDAY)\n+#if defined(JAS_HAVE_GETTIMEOFDAY)\n \n void jas_tmr_start(jas_tmr_t *tmr)\n {\n@@ -104,7 +107,7 @@ double jas_tmr_get(jas_tmr_t *tmr)\n \treturn t1 - t0;\n }\n \n-#elif defined(HAVE_GETRUSAGE)\n+#elif defined(JAS_HAVE_GETRUSAGE)\n \n void jas_tmr_start(jas_tmr_t *tmr)\n {"
        },
        {
          "filename": "src/libjasper/bmp/bmp_dec.c",
          "status": "modified",
          "additions": 67,
          "deletions": 15,
          "patch": "@@ -78,9 +78,22 @@\n #include \"jasper/jas_image.h\"\n #include \"jasper/jas_malloc.h\"\n #include \"jasper/jas_debug.h\"\n+#include \"jasper/jas_tvp.h\"\n \n #include \"bmp_cod.h\"\n \n+/******************************************************************************\\\n+* Local types.\n+\\******************************************************************************/\n+\n+typedef struct {\n+\tsize_t max_samples;\n+} bmp_dec_importopts_t;\n+\n+typedef enum {\n+\tOPT_MAXSIZE,\n+} optid_t;\n+\n /******************************************************************************\\\n * Local prototypes.\n \\******************************************************************************/\n@@ -92,6 +105,43 @@ static int bmp_getint16(jas_stream_t *in, int_fast16_t *val);\n static int bmp_getint32(jas_stream_t *in, int_fast32_t *val);\n static int bmp_gobble(jas_stream_t *in, long n);\n \n+/******************************************************************************\\\n+* Option parsing.\n+\\******************************************************************************/\n+\n+static jas_taginfo_t decopts[] = {\n+\t{OPT_MAXSIZE, \"max_samples\"},\n+\t{-1, 0}\n+};\n+\n+static int bmp_dec_parseopts(char *optstr, bmp_dec_importopts_t *opts)\n+{\n+\tjas_tvparser_t *tvp;\n+\n+\topts->max_samples = 128 * JAS_MEBI;\n+\n+\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n+\t\treturn -1;\n+\t}\n+\n+\twhile (!jas_tvparser_next(tvp)) {\n+\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n+\t\t  jas_tvparser_gettag(tvp)))->id) {\n+\t\tcase OPT_MAXSIZE:\n+\t\t\topts->max_samples = atoi(jas_tvparser_getval(tvp));\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n+\t\t\t  jas_tvparser_gettag(tvp));\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tjas_tvparser_destroy(tvp);\n+\n+\treturn 0;\n+}\n+\n /******************************************************************************\\\n * Interface functions.\n \\******************************************************************************/\n@@ -106,12 +156,14 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \tjas_image_cmptparm_t *cmptparm;\n \tuint_fast16_t numcmpts;\n \tlong n;\n+\tbmp_dec_importopts_t opts;\n+\tsize_t num_samples;\n \n \timage = 0;\n \tinfo = 0;\n \n-\tif (optstr) {\n-\t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n+\tif (bmp_dec_parseopts(optstr, &opts)) {\n+\t\tgoto error;\n \t}\n \n \tjas_eprintf(\n@@ -125,7 +177,6 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \tif (bmp_gethdr(in, &hdr)) {\n \t\tjas_eprintf(\"cannot get header\\n\");\n \t\tgoto error;\n-\t\t//return 0;\n \t}\n \tJAS_DBGLOG(1, (\n \t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n@@ -135,7 +186,6 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t/* Read the bitmap information. */\n \tif (!(info = bmp_getinfo(in))) {\n \t\tjas_eprintf(\"cannot get info\\n\");\n-\t\t//return 0;\n \t\tgoto error;\n \t}\n \tJAS_DBGLOG(1,\n@@ -154,11 +204,21 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t\tgoto error;\n \t}\n \n+\tif (!jas_safe_size_mul3(info->width, info->height, info->numplanes,\n+\t  &num_samples)) {\n+\t\tjas_eprintf(\"image size too large\\n\");\n+\t\tgoto error;\n+\t}\n+\n+\tif (opts.max_samples > 0 && num_samples > opts.max_samples) {\n+\t\tjas_eprintf(\"maximum number of pixels exceeded (%zu)\\n\",\n+\t\t  opts.max_samples);\n+\t\tgoto error;\n+\t}\n+\n \t/* Ensure that we support this type of BMP file. */\n \tif (!bmp_issupported(&hdr, info)) {\n \t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n-\t\t//bmp_info_destroy(info);\n-\t\t//return 0;\n \t\tgoto error;\n \t}\n \n@@ -167,13 +227,10 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n \t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n \t\tgoto error;\n-\t\t//return 0;\n \t}\n \tif (n > 0) {\n \t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n \t\tif (bmp_gobble(in, n)) {\n-\t\t\t//bmp_info_destroy(info);\n-\t\t\t//return 0;\n \t\t\tgoto error;\n \t\t}\n \t}\n@@ -196,8 +253,6 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t/* Create image object. */\n \tif (!(image = jas_image_create(numcmpts, cmptparms,\n \t  JAS_CLRSPC_UNKNOWN))) {\n-\t\t//bmp_info_destroy(info);\n-\t\t//return 0;\n \t\tgoto error;\n \t}\n \n@@ -217,9 +272,6 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \n \t/* Read the bitmap data. */\n \tif (bmp_getdata(in, info, image)) {\n-\t\t//bmp_info_destroy(info);\n-\t\t//jas_image_destroy(image);\n-\t\t//return 0;\n \t\tgoto error;\n \t}\n \n@@ -241,7 +293,7 @@ int bmp_validate(jas_stream_t *in)\n {\n \tint n;\n \tint i;\n-\tuchar buf[2];\n+\tjas_uchar buf[2];\n \n \tassert(JAS_STREAM_MAXPUTBACK >= 2);\n "
        },
        {
          "filename": "src/libjasper/include/jasper/jas_cm.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -68,7 +68,9 @@\n #ifndef JAS_CM_H\n #define JAS_CM_H\n \n+/* The configuration header file should be included first. */\n #include <jasper/jas_config.h>\n+\n #include <jasper/jas_icc.h>\n \n #ifdef __cplusplus"
        },
        {
          "filename": "src/libjasper/include/jasper/jas_config.h.in",
          "status": "added",
          "additions": 27,
          "deletions": 0,
          "patch": "@@ -0,0 +1,27 @@\n+#ifndef JAS_CONFIG_H\n+#define JAS_CONFIG_H\n+\n+/* This preprocessor symbol identifies the version of JasPer. */\n+#define\tJAS_VERSION \"@JAS_VERSION@\"\n+\n+@JAS_HAVE_FCNTL_H@\n+@JAS_HAVE_IO_H@\n+@JAS_HAVE_UNISTD_H@\n+@JAS_HAVE_WINDOWS_H@\n+@JAS_HAVE_SYS_TIME_H@\n+@JAS_HAVE_SYS_TYPES_H@\n+\n+@JAS_HAVE_GETTIMEOFDAY@\n+@JAS_HAVE_GETRUSAGE@\n+\n+#if defined(__GNUC__) && !defined(__clang__)\n+#define JAS_ATTRIBUTE_DISABLE_USAN \\\n+  __attribute__((no_sanitize_undefined))\n+#elif defined(__clang__)\n+#define JAS_ATTRIBUTE_DISABLE_USAN \\\n+  __attribute__((no_sanitize(\"undefined\")))\n+#else\n+#define JAS_ATTRIBUTE_DISABLE_USAN\n+#endif\n+\n+#endif"
        },
        {
          "filename": "src/libjasper/include/jasper/jas_config2.h",
          "status": "modified",
          "additions": 0,
          "deletions": 13,
          "patch": "@@ -70,23 +70,10 @@\n  * normally defined by configure.\n  */\n \n-#define\tuchar\t\tunsigned char\n-#define\tushort\t\tunsigned short\n-#define\tuint\t\tunsigned int\n-#define\tulong\t\tunsigned long\n-#undef longlong\n-#define\tlonglong\tlong long\n-#undef ulonglong\n-#define\tulonglong\tunsigned long long\n-/*#define\tssize_t\t\tint*/\n-\n #define\tHAVE_FCNTL_H\t\t1\n-#define\tHAVE_LIMITS_H\t\t1\n #define\tHAVE_IO_H\t\t1\n #define\tHAVE_WINDOWS_H\t\t1\n #define\tHAVE_SYS_TYPES_H\t1\n-#define\tHAVE_STDLIB_H\t\t1\n-#define\tHAVE_STDDEF_H\t\t1\n \n #ifndef __cplusplus\n #undef inline"
        },
        {
          "filename": "src/libjasper/include/jasper/jas_debug.h",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -72,9 +72,11 @@\n * Includes.\n \\******************************************************************************/\n \n+/* The configuration header file should be included first. */\n+#include <jasper/jas_config.h>\n+\n #include <stdio.h>\n \n-#include <jasper/jas_config.h>\n #include <jasper/jas_types.h>\n #include <jasper/jas_debug.h>\n "
        },
        {
          "filename": "src/libjasper/include/jasper/jas_fix.h",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -74,11 +74,13 @@\n * Includes.\n \\******************************************************************************/\n \n+/* The configuration header file should be included first. */\n+#include <jasper/jas_config.h>\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <math.h>\n \n-#include <jasper/jas_config.h>\n #include <jasper/jas_types.h>\n #include <jasper/jas_debug.h>\n "
        },
        {
          "filename": "src/libjasper/include/jasper/jas_getopt.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -74,6 +74,7 @@\n extern \"C\" {\n #endif\n \n+/* The configuration header file should be included first. */\n #include <jasper/jas_config.h>\n \n /******************************************************************************\\"
        },
        {
          "filename": "src/libjasper/include/jasper/jas_icc.h",
          "status": "modified",
          "additions": 7,
          "deletions": 5,
          "patch": "@@ -62,7 +62,9 @@\n #ifndef JAS_ICC_H\n #define\tJAS_ICC_H\n \n+/* The configuration header file should be included first. */\n #include <jasper/jas_config.h>\n+\n #include <jasper/jas_types.h>\n #include <jasper/jas_stream.h>\n \n@@ -252,10 +254,10 @@ typedef struct {\n \tchar *ascdata; /* ASCII invariant description */\n \tjas_iccuint32_t uclangcode; /* Unicode language code */\n \tjas_iccuint32_t uclen; /* Unicode localizable description count */\n-\tuchar *ucdata; /* Unicode localizable description */\n+\tjas_uchar *ucdata; /* Unicode localizable description */\n \tjas_iccuint16_t sccode; /* ScriptCode code */\n \tjas_iccuint8_t maclen; /* Localizable Macintosh description count */\n-\tuchar macdata[69]; /* Localizable Macintosh description */\n+\tjas_uchar macdata[69]; /* Localizable Macintosh description */\n } jas_icctxtdesc_t;\n \n /* Text type. */\n@@ -393,11 +395,11 @@ jas_iccattrval_t *jas_iccattrval_create(jas_iccuint32_t type);\n \n void jas_iccattrtab_dump(jas_iccattrtab_t *attrtab, FILE *out);\n \n-extern uchar jas_iccprofdata_srgb[];\n+extern jas_uchar jas_iccprofdata_srgb[];\n extern int jas_iccprofdata_srgblen;\n-extern uchar jas_iccprofdata_sgray[];\n+extern jas_uchar jas_iccprofdata_sgray[];\n extern int jas_iccprofdata_sgraylen;\n-jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len);\n+jas_iccprof_t *jas_iccprof_createfrombuf(jas_uchar *buf, int len);\n jas_iccprof_t *jas_iccprof_createfromclrspc(int clrspc);\n \n #ifdef __cplusplus"
        },
        {
          "filename": "src/libjasper/include/jasper/jas_image.h",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -74,7 +74,9 @@\n * Includes.\n \\******************************************************************************/\n \n+/* The configuration header file should be included first. */\n #include <jasper/jas_config.h>\n+\n #include <jasper/jas_stream.h>\n #include <jasper/jas_seq.h>\n #include <jasper/jas_cm.h>\n@@ -217,7 +219,7 @@ typedef struct {\n \n \tjas_cmprof_t *cmprof_;\n \n-\tbool inmem_;\n+//\tbool inmem_;\n \n } jas_image_t;\n "
        },
        {
          "filename": "src/libjasper/include/jasper/jas_init.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -62,6 +62,7 @@\n #ifndef JAS_INIT_H\n #define JAS_INIT_H\n \n+/* The configuration header file should be included first. */\n #include <jasper/jas_config.h>\n \n #ifdef __cplusplus"
        },
        {
          "filename": "src/libjasper/include/jasper/jas_malloc.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -74,6 +74,7 @@\n * Includes.\n \\******************************************************************************/\n \n+/* The configuration header file should be included first. */\n #include <jasper/jas_config.h>\n \n #include <stdlib.h>"
        },
        {
          "filename": "src/libjasper/include/jasper/jas_math.h",
          "status": "modified",
          "additions": 70,
          "deletions": 0,
          "patch": "@@ -74,7 +74,9 @@\n * Includes\n \\******************************************************************************/\n \n+/* The configuration header file should be included first. */\n #include <jasper/jas_config.h>\n+\n #include <jasper/jas_types.h>\n \n #include <assert.h>\n@@ -91,6 +93,9 @@ extern \"C\" {\n * Macros\n \\******************************************************************************/\n \n+#define JAS_KIBI\tJAS_CAST(size_t, 1024)\n+#define JAS_MEBI\t(JAS_KIBI * JAS_KIBI)\n+\n /* Compute the absolute value. */\n #define\tJAS_ABS(x) \\\n \t(((x) >= 0) ? (x) : (-(x)))\n@@ -187,6 +192,20 @@ inline static bool jas_safe_size_mul(size_t x, size_t y, size_t *result)\n \treturn true;\n }\n \n+inline static bool jas_safe_size_mul3(size_t a, size_t b, size_t c,\n+  size_t *result)\n+{\n+\tsize_t tmp;\n+\tif (!jas_safe_size_mul(a, b, &tmp) ||\n+\t  !jas_safe_size_mul(tmp, c, &tmp)) {\n+\t\treturn false;\n+\t}\n+\tif (result) {\n+\t\t*result = tmp;\n+\t}\n+\treturn true;\n+}\n+\n /* Compute the sum of two size_t integer with overflow checking. */\n inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)\n {\n@@ -211,6 +230,57 @@ inline static bool jas_safe_size_sub(size_t x, size_t y, size_t *result)\n \treturn true;\n }\n \n+/* Compute the sum of two size_t integer with overflow checking. */\n+inline static bool jas_safe_intfast32_mul(int_fast32_t x, int_fast32_t y,\n+  int_fast32_t *result)\n+{\n+\tif (x > 0) {\n+\t\t/* x is positive */\n+\t\tif (y > 0) {\n+\t\t\t/* x and y are positive */\n+\t\t\tif (x > INT_FAST32_MAX / y) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t} else {\n+\t\t\t/* x positive, y nonpositive */\n+\t\t\tif (y < INT_FAST32_MIN / x) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\t/* x is nonpositive */\n+\t\tif (y > 0) {\n+\t\t\t/* x is nonpositive, y is positive */\n+\t\t\tif (x < INT_FAST32_MIN / y) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t} else { /* x and y are nonpositive */\n+\t\t\tif (x != 0 && y < INT_FAST32_MAX / x) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif (result) {\n+\t\t*result = x * y;\n+\t}\n+\treturn true;\n+}\n+\n+inline static bool jas_safe_intfast32_mul3(int_fast32_t a, int_fast32_t b,\n+  int_fast32_t c, int_fast32_t *result)\n+{\n+\tint_fast32_t tmp;\n+\tif (!jas_safe_intfast32_mul(a, b, &tmp) ||\n+\t  !jas_safe_intfast32_mul(tmp, c, &tmp)) {\n+\t\treturn false;\n+\t}\n+\tif (result) {\n+\t\t*result = tmp;\n+\t}\n+\treturn true;\n+}\n+\n /* Compute the sum of two size_t integer with overflow checking. */\n inline static bool jas_safe_intfast32_add(int_fast32_t x, int_fast32_t y,\n   int_fast32_t *result)"
        },
        {
          "filename": "src/libjasper/include/jasper/jas_seq.h",
          "status": "modified",
          "additions": 19,
          "deletions": 14,
          "patch": "@@ -74,6 +74,7 @@\n * Includes.\n \\******************************************************************************/\n \n+/* The configuration header file should be included first. */\n #include <jasper/jas_config.h>\n \n #include <jasper/jas_stream.h>\n@@ -102,6 +103,8 @@ typedef int_fast32_t jas_seqent_t;\n /* An element in a matrix. */\n typedef int_fast32_t jas_matent_t;\n \n+typedef int_fast32_t jas_matind_t;\n+\n /* Matrix. */\n \n typedef struct {\n@@ -110,22 +113,22 @@ typedef struct {\n \tint flags_;\n \n \t/* The starting horizontal index. */\n-\tint_fast32_t xstart_;\n+\tjas_matind_t xstart_;\n \n \t/* The starting vertical index. */\n-\tint_fast32_t ystart_;\n+\tjas_matind_t ystart_;\n \n \t/* The ending horizontal index. */\n-\tint_fast32_t xend_;\n+\tjas_matind_t xend_;\n \n \t/* The ending vertical index. */\n-\tint_fast32_t yend_;\n+\tjas_matind_t yend_;\n \n \t/* The number of rows in the matrix. */\n-\tint_fast32_t numrows_;\n+\tjas_matind_t numrows_;\n \n \t/* The number of columns in the matrix. */\n-\tint_fast32_t numcols_;\n+\tjas_matind_t numcols_;\n \n \t/* Pointers to the start of each row. */\n \tjas_seqent_t **rows_;\n@@ -182,25 +185,26 @@ typedef jas_matrix_t jas_seq_t;\n \t(&(matrix)->rows_[i][j])\n \n #define\tjas_matrix_getvref(matrix, i) \\\n-\t(((matrix)->numrows_ > 1) ? jas_matrix_getref(matrix, i, 0) : jas_matrix_getref(matrix, 0, i))\n+\t(((matrix)->numrows_ > 1) ? jas_matrix_getref(matrix, i, 0) : \\\n+\t  jas_matrix_getref(matrix, 0, i))\n \n #define jas_matrix_length(matrix) \\\n \t(max((matrix)->numrows_, (matrix)->numcols_))\n \n /* Create a matrix with the specified dimensions. */\n-jas_matrix_t *jas_matrix_create(int numrows, int numcols);\n+jas_matrix_t *jas_matrix_create(jas_matind_t numrows, jas_matind_t numcols);\n \n /* Destroy a matrix. */\n void jas_matrix_destroy(jas_matrix_t *matrix);\n \n /* Resize a matrix.  The previous contents of the matrix are lost. */\n-int jas_matrix_resize(jas_matrix_t *matrix, int numrows, int numcols);\n+int jas_matrix_resize(jas_matrix_t *matrix, jas_matind_t numrows, jas_matind_t numcols);\n \n int jas_matrix_output(jas_matrix_t *matrix, FILE *out);\n \n /* Create a matrix that references part of another matrix. */\n-void jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, int r0,\n-  int c0, int r1, int c1);\n+void jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, jas_matind_t r0,\n+  jas_matind_t c0, jas_matind_t r1, jas_matind_t c1);\n \n /* Create a matrix that is a reference to a row of another matrix. */\n #define jas_matrix_bindrow(mat0, mat1, r) \\\n@@ -250,7 +254,8 @@ jas_matrix_t *jas_matrix_input(FILE *);\n \n jas_seq2d_t *jas_seq2d_copy(jas_seq2d_t *x);\n \n-jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend);\n+jas_matrix_t *jas_seq2d_create(jas_matind_t xstart, jas_matind_t ystart,\n+  jas_matind_t xend, jas_matind_t yend);\n \n #define\tjas_seq2d_destroy(s) \\\n \tjas_matrix_destroy(s)\n@@ -280,8 +285,8 @@ jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend);\n #define jas_seq2d_size(s) \\\n \t(jas_seq2d_width(s) * jas_seq2d_height(s))\n \n-void jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, int xstart,\n-  int ystart, int xend, int yend);\n+void jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, jas_matind_t xstart,\n+  jas_matind_t ystart, jas_matind_t xend, jas_matind_t yend);\n \n /******************************************************************************\\\n * Functions/macros for 1-D sequence class."
        },
        {
          "filename": "src/libjasper/include/jasper/jas_stream.h",
          "status": "modified",
          "additions": 9,
          "deletions": 8,
          "patch": "@@ -74,14 +74,15 @@\n * Includes.\n \\******************************************************************************/\n \n+/* The configuration header file should be included first. */\n #include <jasper/jas_config.h>\n \n #include <stdio.h>\n-#if defined(HAVE_FCNTL_H)\n+#if defined(JAS_HAVE_FCNTL_H)\n #include <fcntl.h>\n #endif\n #include <string.h>\n-#if defined(HAVE_UNISTD_H)\n+#if defined(JAS_HAVE_UNISTD_H)\n #include <unistd.h>\n #endif\n #include <jasper/jas_types.h>\n@@ -208,24 +209,24 @@ typedef struct {\n \tint flags_;\n \n \t/* The start of the buffer area to use for reading/writing. */\n-\tuchar *bufbase_;\n+\tjas_uchar *bufbase_;\n \n \t/* The start of the buffer area excluding the extra initial space for\n \t  character putback. */\n-\tuchar *bufstart_;\n+\tjas_uchar *bufstart_;\n \n \t/* The buffer size. */\n \tint bufsize_;\n \n \t/* The current position in the buffer. */\n-\tuchar *ptr_;\n+\tjas_uchar *ptr_;\n \n \t/* The number of characters that must be read/written before\n \tthe buffer needs to be filled/flushed. */\n \tint cnt_;\n \n \t/* A trivial buffer to be used for unbuffered operation. */\n-\tuchar tinybuf_[JAS_STREAM_MAXPUTBACK + 1];\n+\tjas_uchar tinybuf_[JAS_STREAM_MAXPUTBACK + 1];\n \n \t/* The operations for the underlying stream file object. */\n \tjas_stream_ops_t *ops_;\n@@ -264,7 +265,7 @@ typedef struct {\n typedef struct {\n \n \t/* The data associated with this file. */\n-\tuchar *buf_;\n+\tjas_uchar *buf_;\n \n \t/* The allocated size of the buffer for holding file data. */\n \tsize_t bufsize_;\n@@ -451,7 +452,7 @@ directly, you will die a horrible, miserable, and painful death! */\n \t  jas_stream_putc2(stream, c)) : EOF)\n #define jas_stream_putc2(stream, c) \\\n \t(((stream)->bufmode_ |= JAS_STREAM_WRBUF, --(stream)->cnt_ < 0) ? \\\n-\t  jas_stream_flushbuf((stream), (uchar)(c)) : \\\n+\t  jas_stream_flushbuf((stream), (jas_uchar)(c)) : \\\n \t  (++(stream)->rwcnt_, (int)(*(stream)->ptr_++ = (c))))\n \n /* These prototypes need to be here for the sake of the stream_getc and"
        },
        {
          "filename": "src/libjasper/include/jasper/jas_string.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -74,7 +74,9 @@\n * Includes.\n \\******************************************************************************/\n \n+/* The configuration header file should be included first. */\n #include <jasper/jas_config.h>\n+\n #include <string.h>\n \n #ifdef __cplusplus"
        },
        {
          "filename": "src/libjasper/include/jasper/jas_tmr.h",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -62,24 +62,26 @@\n #ifndef JAS_TMR_H\n #define JAS_TMR_H\n \n-#include<time.h>\n+/* The configuration header file should be included first. */\n #include <jasper/jas_config.h>\n-#if defined(HAVE_SYS_TIME_H)\n+\n+#include<time.h>\n+#if defined(JAS_HAVE_SYS_TIME_H)\n #include <sys/time.h>\n #endif\n \n #ifdef __cplusplus\n extern \"C\" {\n #endif\n \n-#if defined(HAVE_GETTIMEOFDAY)\n+#if defined(JAS_HAVE_GETTIMEOFDAY)\n \n typedef struct {\n \tstruct timeval start;\n \tstruct timeval stop;\n } jas_tmr_t;\n \n-#elif defined(HAVE_GETRUSAGE)\n+#elif defined(JAS_HAVE_GETRUSAGE)\n \n typedef struct {\n \tstruct rusage start;"
        },
        {
          "filename": "src/libjasper/include/jasper/jas_tvp.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -72,6 +72,7 @@\n * Includes.\n \\******************************************************************************/\n \n+/* The configuration header file should be included first. */\n #include <jasper/jas_config.h>\n \n #ifdef __cplusplus"
        },
        {
          "filename": "src/libjasper/include/jasper/jas_types.h",
          "status": "modified",
          "additions": 13,
          "deletions": 25,
          "patch": "@@ -70,11 +70,13 @@\n #ifndef JAS_TYPES_H\n #define JAS_TYPES_H\n \n+/* The configuration header file should be included first. */\n #include <jasper/jas_config.h>\n \n #if !defined(JAS_CONFIGURE)\n \n-#if defined(WIN32) || defined(HAVE_WINDOWS_H)\n+#if defined(WIN32) || defined(JAS_HAVE_WINDOWS_H)\n+// THIS SHOULD NO LONGER BE NEEDED SINCE MSVC SUPPORTS LONG LONG.\n /*\n    We are dealing with Microsoft Windows and most likely Microsoft\n    Visual C (MSVC).  (Heaven help us.)  Sadly, MSVC does not correctly\n@@ -84,10 +86,10 @@\n    and \"UINT64\" types that are defined in the header file \"windows.h\".\n  */\n #include <windows.h>\n-#undef longlong\n-#define\tlonglong\tINT64\n-#undef ulonglong\n-#define\tulonglong\tUINT64\n+//#undef longlong\n+//#define\tlonglong\tINT64\n+//#undef ulonglong\n+//#define\tulonglong\tUINT64\n #endif\n \n #endif\n@@ -98,29 +100,15 @@\n #include <stdbool.h>\n #include <stdint.h>\n \n-#if defined(HAVE_SYS_TYPES_H)\n+#if defined(JAS_HAVE_SYS_TYPES_H)\n #include <sys/types.h>\n #endif\n \n-/* Hopefully, these macro definitions will fix more problems than they cause. */\n-#if !defined(uchar)\n-#define uchar unsigned char\n-#endif\n-#if !defined(ushort)\n-#define ushort unsigned short\n-#endif\n-#if !defined(uint)\n-#define uint unsigned int\n-#endif\n-#if !defined(ulong)\n-#define ulong unsigned long\n-#endif\n-#if !defined(longlong)\n-#define longlong long long\n-#endif\n-#if !defined(ulonglong)\n-#define ulonglong unsigned long long\n-#endif\n+#define jas_uchar unsigned char\n+#define jas_uint unsigned int\n+#define jas_ulong unsigned long\n+#define jas_longlong long long\n+#define jas_ulonglong unsigned long long\n \n /* The below macro is intended to be used for type casts.  By using this\n   macro, type casts can be easily located in the source code with"
        },
        {
          "filename": "src/libjasper/include/jasper/jas_version.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -68,6 +68,7 @@\n #ifndef JAS_VERSION_H\n #define JAS_VERSION_H\n \n+/* The configuration header file should be included first. */\n #include <jasper/jas_config.h>\n \n #ifdef __cplusplus"
        },
        {
          "filename": "src/libjasper/include/jasper/jasper.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -62,7 +62,9 @@\n #ifndef JAS_JASPER_H\n #define JAS_JASPER_H\n \n+/* The configuration header file should be included first. */\n #include <jasper/jas_config.h>\n+\n #include <jasper/jas_types.h>\n #include <jasper/jas_version.h>\n "
        },
        {
          "filename": "src/libjasper/jp2/jp2_dec.c",
          "status": "modified",
          "additions": 8,
          "deletions": 7,
          "patch": "@@ -77,6 +77,7 @@\n #include \"jasper/jas_debug.h\"\n #include \"jasper/jas_malloc.h\"\n #include \"jasper/jas_version.h\"\n+#include \"jasper/jas_types.h\"\n \n #include \"jp2_cod.h\"\n #include \"jp2_dec.h\"\n@@ -225,7 +226,7 @@ jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)\n \n \t/* Does the number of components indicated in the IHDR box match\n \t  the value specified in the code stream? */\n-\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,\n+\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,\n \t  jas_image_numcmpts(dec->image))) {\n \t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n \t}\n@@ -239,7 +240,7 @@ jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)\n \t/* Determine if all components have the same data type. */\n \tsamedtype = true;\n \tdtype = jas_image_cmptdtype(dec->image, 0);\n-\tfor (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n+\tfor (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n \t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n \t\t\tsamedtype = false;\n \t\t\tbreak;\n@@ -262,14 +263,14 @@ jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)\n \tif (dec->bpcc) {\n \t\t/* Is the number of components indicated in the BPCC box\n \t\t  consistent with the code stream data? */\n-\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(\n+\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(\n \t\t  dec->image))) {\n \t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n \t\t}\n \t\t/* Is the component data type information indicated in the BPCC\n \t\t  box consistent with the code stream data? */\n \t\tif (!samedtype) {\n-\t\t\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));\n+\t\t\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n \t\t\t  ++i) {\n \t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n \t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n@@ -324,13 +325,13 @@ jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)\n \t/* Determine the number of channels (which is essentially the number\n \t  of components after any palette mappings have been applied). */\n \tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n-\t  JAS_CAST(uint, jas_image_numcmpts(dec->image));\n+\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n \n \t/* Perform a basic sanity check on the CMAP box if present. */\n \tif (dec->cmap) {\n \t\tfor (i = 0; i < dec->numchans; ++i) {\n \t\t\t/* Is the component number reasonable? */\n-\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,\n+\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,\n \t\t\t  jas_image_numcmpts(dec->image))) {\n \t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n \t\t\t\tgoto error;\n@@ -391,7 +392,7 @@ jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)\n \n \t/* Mark all components as being of unknown type. */\n \n-\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n+\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n \t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n \t}\n "
        },
        {
          "filename": "src/libjasper/jpc/jpc_cs.c",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -289,7 +289,7 @@ jpc_ms_t *jpc_getms(jas_stream_t *in, jpc_cstate_t *cstate)\n \t\t\tjpc_ms_dump(ms, stderr);\n \t\t}\n \n-\t\tif (JAS_CAST(ulong, jas_stream_tell(tmpstream)) != ms->len) {\n+\t\tif (JAS_CAST(jas_ulong, jas_stream_tell(tmpstream)) != ms->len) {\n \t\t\tjas_eprintf(\n \t\t\t  \"warning: trailing garbage in marker segment (%ld bytes)\\n\",\n \t\t\t  ms->len - jas_stream_tell(tmpstream));\n@@ -1177,7 +1177,7 @@ static int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in\n \t\tif (!(ppm->data = jas_malloc(ppm->len))) {\n \t\t\tgoto error;\n \t\t}\n-\t\tif (JAS_CAST(uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {\n+\t\tif (JAS_CAST(jas_uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {\n \t\t\tgoto error;\n \t\t}\n \t} else {\n@@ -1197,7 +1197,7 @@ static int jpc_ppm_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *ou\n \t/* Eliminate compiler warning about unused variables. */\n \tcstate = 0;\n \n-\tif (JAS_CAST(uint, jas_stream_write(out, (char *) ppm->data, ppm->len)) != ppm->len) {\n+\tif (JAS_CAST(jas_uint, jas_stream_write(out, (char *) ppm->data, ppm->len)) != ppm->len) {\n \t\treturn -1;\n \t}\n \treturn 0;"
        },
        {
          "filename": "src/libjasper/jpc/jpc_cs.h",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -490,7 +490,7 @@ typedef struct {\n \tuint_fast16_t len;\n \n \t/* The data. */\n-\tuchar *data;\n+\tjas_uchar *data;\n \n } jpc_ppm_t;\n \n@@ -529,7 +529,7 @@ typedef struct {\n \tuint_fast16_t len;\n \n \t/* The data. */\n-\tuchar *data;\n+\tjas_uchar *data;\n \n } jpc_com_t;\n \n@@ -577,7 +577,7 @@ typedef struct {\n typedef struct {\n \n \t/* The data. */\n-\tuchar *data;\n+\tjas_uchar *data;\n \n \t/* The length. */\n \tuint_fast16_t len;"
        },
        {
          "filename": "src/libjasper/jpc/jpc_dec.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -2276,7 +2276,7 @@ int jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n jpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)\n {\n \tjpc_streamlist_t *streams;\n-\tuchar *dataptr;\n+\tjas_uchar *dataptr;\n \tuint_fast32_t datacnt;\n \tuint_fast32_t tpcnt;\n \tjpc_ppxstabent_t *ent;"
        },
        {
          "filename": "src/libjasper/jpc/jpc_dec.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -99,7 +99,7 @@ typedef struct {\n \tuint_fast32_t len;\n \n \t/* The data. */\n-\tuchar *data;\n+\tjas_uchar *data;\n \n } jpc_ppxstabent_t;\n "
        },
        {
          "filename": "src/libjasper/jpc/jpc_enc.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -961,7 +961,7 @@ startoff = jas_stream_getrwcount(enc->out);\n \tcom = &enc->mrk->parms.com;\n \tcom->len = JAS_CAST(uint_fast16_t, strlen(buf));\n \tcom->regid = JPC_COM_LATIN;\n-\tif (!(com->data = JAS_CAST(uchar *, jas_strdup(buf)))) {\n+\tif (!(com->data = JAS_CAST(jas_uchar *, jas_strdup(buf)))) {\n \t\tabort();\n \t}\n \tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {"
        },
        {
          "filename": "src/libjasper/jpc/jpc_mqdec.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -109,7 +109,7 @@ typedef struct {\n \tjas_stream_t *in;\n \n \t/* The last character read. */\n-\tuchar inbuffer;\n+\tjas_uchar inbuffer;\n \n \t/* The EOF indicator. */\n \tint eof;"
        },
        {
          "filename": "src/libjasper/jpg/jpg_dec.c",
          "status": "modified",
          "additions": 27,
          "deletions": 25,
          "patch": "@@ -80,6 +80,14 @@\n * Types.\n \\******************************************************************************/\n \n+typedef struct {\n+\tsize_t max_samples;\n+} jpg_dec_importopts_t;\n+\n+typedef enum {\n+\tOPT_MAXSIZE,\n+} optid_t;\n+\n /* JPEG decoder data sink type. */\n \n typedef struct jpg_dest_s {\n@@ -127,27 +135,19 @@ static int jpg_copystreamtofile(FILE *out, jas_stream_t *in);\n static jas_image_t *jpg_mkimage(j_decompress_ptr cinfo);\n \n /******************************************************************************\\\n-*\n+* Option parsing.\n \\******************************************************************************/\n \n-typedef struct {\n-\tsize_t max_size;\n-} jpg_dec_importopts_t;\n-\n-typedef enum {\n-\tOPT_MAXSIZE,\n-} optid_t;\n-\n static jas_taginfo_t decopts[] = {\n-\t{OPT_MAXSIZE, \"max_size\"},\n+\t{OPT_MAXSIZE, \"max_samples\"},\n \t{-1, 0}\n };\n \n static int jpg_dec_parseopts(char *optstr, jpg_dec_importopts_t *opts)\n {\n \tjas_tvparser_t *tvp;\n \n-\topts->max_size = 0;\n+\topts->max_samples = 64 * JAS_MEBI;\n \n \tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n \t\treturn -1;\n@@ -157,7 +157,7 @@ static int jpg_dec_parseopts(char *optstr, jpg_dec_importopts_t *opts)\n \t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n \t\t  jas_tvparser_gettag(tvp)))->id) {\n \t\tcase OPT_MAXSIZE:\n-\t\t\topts->max_size = atoi(jas_tvparser_getval(tvp));\n+\t\t\topts->max_samples = atoi(jas_tvparser_getval(tvp));\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n@@ -188,7 +188,9 @@ jas_image_t *jpg_decode(jas_stream_t *in, char *optstr)\n \tjas_image_t *image;\n \tint ret;\n \tjpg_dec_importopts_t opts;\n-\tsize_t size;\n+\tsize_t num_samples;\n+\n+\tJAS_DBGLOG(100, (\"jpg_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n \n \tif (jpg_dec_parseopts(optstr, &opts)) {\n \t\tgoto error;\n@@ -236,6 +238,18 @@ jas_image_t *jpg_decode(jas_stream_t *in, char *optstr)\n \t  cinfo.image_width, cinfo.image_height, cinfo.num_components)\n \t  );\n \n+\tif (opts.max_samples > 0) {\n+\t\tif (!jas_safe_size_mul3(cinfo.image_width, cinfo.image_height,\n+\t\t  cinfo.num_components, &num_samples)) {\n+\t\t\tgoto error;\n+\t\t}\n+\t\tif (num_samples > opts.max_samples) {\n+\t\t\tjas_eprintf(\"image is too large (%zu > %zu)\\n\", num_samples,\n+\t\t\t  opts.max_samples);\n+\t\t\tgoto error;\n+\t\t}\n+\t}\n+\n \t/* Start the decompressor. */\n \tJAS_DBGLOG(10, (\"jpeg_start_decompress(%p)\\n\", &cinfo));\n \tret = jpeg_start_decompress(&cinfo);\n@@ -245,18 +259,6 @@ jas_image_t *jpg_decode(jas_stream_t *in, char *optstr)\n \t  cinfo.output_width, cinfo.output_height, cinfo.output_components)\n \t  );\n \n-\tif (opts.max_size) {\n-\t\tif (!jas_safe_size_mul(cinfo.output_width, cinfo.output_height,\n-\t\t  &size) ||\n-\t\t  !jas_safe_size_mul(size, cinfo.output_components, &size)) {\n-\t\t\tgoto error;\n-\t\t}\n-\t\tif (size > opts.max_size) {\n-\t\t\tjas_eprintf(\"image is too large\\n\");\n-\t\t\tgoto error;\n-\t\t}\n-\t}\n-\n \t/* Create an image object to hold the decoded data. */\n \tif (!(image = jpg_mkimage(&cinfo))) {\n \t\tjas_eprintf(\"jpg_mkimage failed\\n\");"
        },
        {
          "filename": "src/libjasper/jpg/jpg_val.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -77,7 +77,7 @@\n \n int jpg_validate(jas_stream_t *in)\n {\n-\tuchar buf[JPG_MAGICLEN];\n+\tjas_uchar buf[JPG_MAGICLEN];\n \tint i;\n \tint n;\n "
        },
        {
          "filename": "src/libjasper/mif/mif_cod.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -370,7 +370,7 @@ int mif_encode(jas_image_t *image, jas_stream_t *out, char *optstr)\n \n int mif_validate(jas_stream_t *in)\n {\n-\tuchar buf[MIF_MAGICLEN];\n+\tjas_uchar buf[MIF_MAGICLEN];\n \tuint_fast32_t magic;\n \tint i;\n \tint n;\n@@ -462,7 +462,7 @@ static int mif_hdr_growcmpts(mif_hdr_t *hdr, int maxcmpts)\n \n static mif_hdr_t *mif_hdr_get(jas_stream_t *in)\n {\n-\tuchar magicbuf[MIF_MAGICLEN];\n+\tjas_uchar magicbuf[MIF_MAGICLEN];\n \tchar buf[4096];\n \tmif_hdr_t *hdr;\n \tbool done;"
        },
        {
          "filename": "src/libjasper/pgx/pgx_dec.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -151,7 +151,7 @@ jas_image_t *pgx_decode(jas_stream_t *in, char *optstr)\n \n int pgx_validate(jas_stream_t *in)\n {\n-\tuchar buf[PGX_MAGICLEN];\n+\tjas_uchar buf[PGX_MAGICLEN];\n \tuint_fast32_t magic;\n \tint i;\n \tint n;\n@@ -195,7 +195,7 @@ int pgx_validate(jas_stream_t *in)\n static int pgx_gethdr(jas_stream_t *in, pgx_hdr_t *hdr)\n {\n \tint c;\n-\tuchar buf[2];\n+\tjas_uchar buf[2];\n \n \tif ((c = jas_stream_getc(in)) == EOF) {\n \t\tgoto error;"
        },
        {
          "filename": "src/libjasper/pnm/pnm_dec.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -180,7 +180,7 @@ jas_image_t *pnm_decode(jas_stream_t *in, char *opts)\n \n int pnm_validate(jas_stream_t *in)\n {\n-\tuchar buf[2];\n+\tjas_uchar buf[2];\n \tint i;\n \tint n;\n "
        },
        {
          "filename": "src/libjasper/ras/ras_dec.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -185,7 +185,7 @@ jas_image_t *ras_decode(jas_stream_t *in, char *optstr)\n \n int ras_validate(jas_stream_t *in)\n {\n-\tuchar buf[RAS_MAGICLEN];\n+\tjas_uchar buf[RAS_MAGICLEN];\n \tint i;\n \tint n;\n \tuint_fast32_t magic;"
        },
        {
          "filename": "test/bin/run_test_1",
          "status": "modified",
          "additions": 8,
          "deletions": 2,
          "patch": "@@ -54,23 +54,29 @@ for in_file in \"${bad_list[@]}\"; do\n \tname=$(basename \"$in_file\")\n \techo \"############################################################\"\n \tcase \"$name\" in\n-\t2_crashes.bmp|jasper-doublefree-mem_close.jpg)\n+\t2_crashes.bmp)\n+\t\t#jasper-doublefree-mem_close.jpg\n \t\t# The file jasper-doublefree-mem_close.jpg must be skipped\n \t\t# since this test could pass or fail depending on the version of\n \t\t# the JPEG library used (and if it passes it will be VERY SLOW).\n+\t\t# Thie file 2_crashes.bmp must be skipped since it will try\n+\t\t# to allocate a huge palette which can cause an ASAN failure.\n \t\techo \"Skipping $in_file\"\n \t\tcontinue\n \t\t;;\n \tesac\n \n \techo \"Input file: $in_file\"\n+\timginfo_opts=()\n+\timginfo_opts+=(--max-samples 100000000)\n \tspecial_asan_options=()\n \tspecial_asan_options+=(exitcode=10)\n \tspecial_asan_options+=(allocator_may_return_null=true)\n \tspecial_asan_options+=(detect_leaks=false)\n \t#special_asan_options+=(soft_rss_limit_mb=1024)\n \texpected_status=1\n-\tASAN_OPTIONS=\"${special_asan_options[*]}\" \"$imginfo\" < \"$in_file\"\n+\tASAN_OPTIONS=\"${special_asan_options[*]}\" \\\n+\t  \"$imginfo\" \"${imginfo_opts[@]}\" < \"$in_file\"\n \tstatus=$?\n \techo \"actual exit status: $status\"\n \techo \"expected exit status: $expected_status\""
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 3,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 13,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8766848706a727f61c1c76a5a7cf1078433fad02",
            "date": "2024-04-27T17:53:19Z",
            "author_login": "mdadams"
          },
          {
            "sha": "2d6b6e8a9987386afe388e1cde859d0182445e63",
            "date": "2024-04-27T17:49:23Z",
            "author_login": "mdadams"
          },
          {
            "sha": "29154a52b6c2b895ac3db60d51be9f2a995ee145",
            "date": "2024-04-10T06:11:01Z",
            "author_login": "mdadams"
          },
          {
            "sha": "2fe7d2d73d18d9c7072507d462737b372f9d56bf",
            "date": "2024-03-30T16:57:05Z",
            "author_login": "mdadams"
          },
          {
            "sha": "6d084c53a77762f41bb5310713a5f1872fef55f5",
            "date": "2024-03-29T14:57:29Z",
            "author_login": "mdadams"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-20",
    "description": "The jas_seq2d_create function in jas_seq.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (assertion failure) via a crafted file.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-03-23T18:59:00.897",
    "last_modified": "2024-11-21T03:01:06.187",
    "fix_date": "2016-11-12T00:27:34Z"
  },
  "references": [
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2017-01/msg00008.html",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2017-01/msg00009.html",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/11/17/1",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/94376",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://blogs.gentoo.org/ago/2016/11/16/jasper-multiple-assertion-failure",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1396977",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2017-01/msg00008.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2017-01/msg00009.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2016/11/17/1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/94376",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://blogs.gentoo.org/ago/2016/11/16/jasper-multiple-assertion-failure",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1396977",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:54.818153",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "jasper",
    "owner": "mdadams",
    "created_at": "2016-09-16T18:52:32Z",
    "updated_at": "2025-01-10T13:03:21Z",
    "pushed_at": "2024-04-27T17:54:09Z",
    "size": 4405,
    "stars": 232,
    "forks": 102,
    "open_issues": 4,
    "watchers": 232,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1567274,
      "Shell": 147989,
      "CMake": 50869,
      "Roff": 3703,
      "Batchfile": 1905,
      "C++": 235
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T14:01:40.770708"
  }
}