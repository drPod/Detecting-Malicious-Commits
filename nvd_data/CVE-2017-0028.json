{
  "cve_id": "CVE-2017-0028",
  "github_data": {
    "repository": "Microsoft/ChakraCore",
    "fix_commit": "402f3d967c0a905ec5b9ca9c240783d3f2c15724",
    "related_commits": [
      "402f3d967c0a905ec5b9ca9c240783d3f2c15724",
      "402f3d967c0a905ec5b9ca9c240783d3f2c15724"
    ],
    "patch_url": "https://github.com/Microsoft/ChakraCore/commit/402f3d967c0a905ec5b9ca9c240783d3f2c15724.patch",
    "fix_commit_details": {
      "sha": "402f3d967c0a905ec5b9ca9c240783d3f2c15724",
      "commit_date": "2017-01-12T19:23:32Z",
      "author": {
        "login": "pleath",
        "type": "User",
        "stats": {
          "total_commits": 599,
          "average_weekly_commits": 1.2350515463917526,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 137
        }
      },
      "commit_message": {
        "title": "[CVE-2017-0028] Fix binding of 'async' identifier in the presence of async arrow function.",
        "length": 90,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 29,
        "additions": 28,
        "deletions": 1
      },
      "files": [
        {
          "filename": "lib/Parser/Parse.cpp",
          "status": "modified",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -2863,6 +2863,7 @@ ParseNodePtr Parser::ParseTerm(BOOL fAllowCall,\n     _Inout_opt_ charcount_t *plastRParen /*= nullptr*/)\n {\n     ParseNodePtr pnode = nullptr;\n+    PidRefStack *savedTopAsyncRef = nullptr;\n     charcount_t ichMin = 0;\n     size_t iecpMin = 0;\n     size_t iuMin;\n@@ -2915,6 +2916,13 @@ ParseNodePtr Parser::ParseTerm(BOOL fAllowCall,\n                 isLambdaExpr = true;\n                 goto LFunction;\n             }\n+            else if (m_token.tk == tkLParen)\n+            {\n+                // This is potentially an async arrow function. Save the state of the async references\n+                // in case it needs to be restored. (Note that the case of a single parameter with no ()'s\n+                // is detected upstream and need not be handled here.)\n+                savedTopAsyncRef = pid->GetTopRef();\n+            }\n         }\n \n         // Don't push a reference if this is a single lambda parameter, because we'll reparse with\n@@ -3269,6 +3277,18 @@ LFunction :\n \n     pnode = ParsePostfixOperators<buildAST>(pnode, fAllowCall, fInNew, isAsyncExpr, &fCanAssign, &term, pfIsDotOrIndex);\n \n+    if (savedTopAsyncRef != nullptr &&\n+        this->m_token.tk == tkDArrow)\n+    {\n+        // This is an async arrow function; we're going to back up and reparse it.\n+        // Make sure we don't leave behind a bogus reference to the 'async' identifier.\n+        for (IdentPtr pid = wellKnownPropertyPids.async; pid->GetTopRef() != savedTopAsyncRef;)\n+        {\n+            Assert(pid->GetTopRef() != nullptr);\n+            pid->RemovePrevPidRef(nullptr);\n+        }\n+    }\n+\n     // Pass back identifier if requested\n     if (pToken && term.tk == tkID)\n     {"
        },
        {
          "filename": "test/es6/lambda-params-shadow.js",
          "status": "modified",
          "additions": 8,
          "deletions": 1,
          "patch": "@@ -18,7 +18,14 @@ class B extends A {\n     }\r\n }\r\n let b = new B();\r\n-if (count !== 3) {\r\n+class async extends A {\r\n+    constructor() {\r\n+        super();\r\n+        let Q = async A => { A };\r\n+    }\r\n+}\r\n+let a = new async();\r\n+if (count !== 4) {\r\n     WScript.Echo('fail');\r\n }\r\n \r"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e26c81f6eabf3b4c0f45c3963be807d3ea90c63e",
            "date": "2024-08-01T13:19:47Z",
            "author_login": "rhuanjl"
          },
          {
            "sha": "13358c622f6cf7ce3d2512a170513fc5cb6021cd",
            "date": "2024-07-03T21:57:05Z",
            "author_login": "ppenzin"
          },
          {
            "sha": "3998959ee28adf70502212bdecc5ed3a88c00986",
            "date": "2024-03-07T22:40:43Z",
            "author_login": "StephanTLavavej"
          },
          {
            "sha": "3a7b12017dc84ff569855d26c399845cafca028f",
            "date": "2024-05-23T14:26:58Z",
            "author_login": "ShortDevelopment"
          },
          {
            "sha": "682026b6077320b0d079f96595b751bd757c8229",
            "date": "2024-05-16T22:11:15Z",
            "author_login": "rhuanjl"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-119",
    "description": "A remote code execution vulnerability exists when Microsoft scripting engine improperly accesses objects in memory. The vulnerability could corrupt memory in a way that enables an attacker to execute arbitrary code in the context of the current user. An attacker who successfully exploited the vulnerability could gain the same user rights as the current user, aka \"Scripting Engine Memory Corruption Vulnerability.\"",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-07-17T13:18:08.547",
    "last_modified": "2024-11-21T03:02:12.553",
    "fix_date": "2017-01-12T19:23:32Z"
  },
  "references": [
    {
      "url": "https://github.com/Microsoft/ChakraCore/commit/402f3d967c0a905ec5b9ca9c240783d3f2c15724",
      "source": "secure@microsoft.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Microsoft/ChakraCore/commit/402f3d967c0a905ec5b9ca9c240783d3f2c15724",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:01.701775",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "ChakraCore",
    "owner": "Microsoft",
    "created_at": "2016-01-05T19:05:31Z",
    "updated_at": "2025-01-14T06:24:58Z",
    "pushed_at": "2024-08-12T08:15:35Z",
    "size": 183810,
    "stars": 9145,
    "forks": 1197,
    "open_issues": 606,
    "watchers": 9145,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "JavaScript": 51476459,
      "C++": 37031250,
      "C": 5066953,
      "WebAssembly": 3112291,
      "Assembly": 213208,
      "Roff": 176573,
      "Python": 102745,
      "CMake": 94903,
      "Batchfile": 84427,
      "PowerShell": 64480,
      "Shell": 52761,
      "Perl": 29562,
      "Pawn": 13139,
      "Mustache": 2910,
      "CSS": 1576
    },
    "commit_activity": {
      "total_commits_last_year": 25,
      "avg_commits_per_week": 0.4807692307692308,
      "days_active_last_year": 14
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T15:44:41.249948"
  }
}