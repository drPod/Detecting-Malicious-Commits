{
  "cve_id": "CVE-2017-0152",
  "github_data": {
    "repository": "Microsoft/ChakraCore",
    "fix_commit": "9da019424601325a6e95e6be0fa03d7d21d0b517",
    "related_commits": [
      "9da019424601325a6e95e6be0fa03d7d21d0b517",
      "9da019424601325a6e95e6be0fa03d7d21d0b517"
    ],
    "patch_url": "https://github.com/Microsoft/ChakraCore/commit/9da019424601325a6e95e6be0fa03d7d21d0b517.patch",
    "fix_commit_details": {
      "sha": "9da019424601325a6e95e6be0fa03d7d21d0b517",
      "commit_date": "2017-03-09T00:58:06Z",
      "author": {
        "login": "aneeshdk",
        "type": "User",
        "stats": {
          "total_commits": 239,
          "average_weekly_commits": 0.4927835051546392,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 66
        }
      },
      "commit_message": {
        "title": "[CVE-2017-0152] MSFT: 10592731 : Issue with Function name capturing in param scope",
        "length": 613,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 34,
        "additions": 33,
        "deletions": 1
      },
      "files": [
        {
          "filename": "lib/Parser/Parse.cpp",
          "status": "modified",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -5198,6 +5198,19 @@ bool Parser::ParseFncDeclHelper(ParseNodePtr pnodeFnc, LPCOLESTR pNameHint, usho\n                         paramScope->SetCannotMergeWithBodyScope();\n                     }\n                 }\n+                if (paramScope->GetCanMergeWithBodyScope() && !fDeclaration && pnodeFnc->sxFnc.pnodeName != nullptr)\n+                {\n+                    Symbol* funcSym = pnodeFnc->sxFnc.pnodeName->sxVar.sym;\n+                    if (funcSym->GetPid()->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)\n+                    {\n+                        // This is a function expression with name captured in the param scope. In non-eval, non-split cases the function\n+                        // name symbol is added to the body scope to make it accessible in the body. But if there is a function or var\n+                        // declaration with the same name in the body then adding to the body will fail. So in this case we have to add\n+                        // the name symbol to the param scope by splitting it.\n+                        paramScope->SetCannotMergeWithBodyScope();\n+                    }\n+                }\n+\n             }\n         }\n "
        },
        {
          "filename": "lib/Runtime/ByteCode/ByteCodeEmitter.cpp",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -3319,6 +3319,7 @@ void ByteCodeGenerator::EmitOneFunction(ParseNode *pnode)\n         {\n             // Emit bytecode to copy the initial values from param names to their corresponding body bindings.\n             // We have to do this after the rest param is marked as false for need declaration.\n+            Symbol* funcSym = funcInfo->root->sxFnc.GetFuncSymbol();\n             paramScope->ForEachSymbol([&](Symbol* param) {\n                 Symbol* varSym = funcInfo->GetBodyScope()->FindLocalSymbol(param->GetName());\n                 Assert(varSym || pnode->sxFnc.pnodeName->sxVar.sym == param);\n@@ -3327,7 +3328,9 @@ void ByteCodeGenerator::EmitOneFunction(ParseNode *pnode)\n                 {\n                     // Do not copy the arguments to the body if it is not used\n                 }\n-                else if (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister))\n+                else if ((funcSym == nullptr || funcSym != param)    // Do not copy the symbol over to body as the function expression symbol\n+                                                                     // is expected to stay inside the function expression scope\n+                    && (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister)))\n                 {\n                     // Simulating EmitPropLoad here. We can't directly call the method as we have to use the param scope specifically.\n                     // Walking the scope chain is not possible at this time."
        },
        {
          "filename": "test/es6/default-splitscope.js",
          "status": "modified",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -159,6 +159,22 @@ var tests = [\n             return a;\n         }\n         assert.areEqual(10, f11()(), \"Recursive call to the function from the body scope returns the right value when eval is there in the body\");\n+\n+        function f13() {\n+            var a = function jnvgfg(sfgnmj = function ccunlk() { jnvgfg(undefined, 1); }, b) {\n+                if (b) {\n+                    assert.areEqual(undefined, jnvgfg, \"This refers to the instance in the body and the value of the function expression is not copied over\");\n+                }\n+                var jnvgfg = 10;\n+                if (!b) {\n+                    sfgnmj();\n+                    return 100;\n+                }\n+            };\n+            assert.areEqual(100, a(), \"After the recursion the right value is returned by the split scoped function\");\n+        };\n+        f13();\n+\n     } \n  }, \n  { "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e26c81f6eabf3b4c0f45c3963be807d3ea90c63e",
            "date": "2024-08-01T13:19:47Z",
            "author_login": "rhuanjl"
          },
          {
            "sha": "13358c622f6cf7ce3d2512a170513fc5cb6021cd",
            "date": "2024-07-03T21:57:05Z",
            "author_login": "ppenzin"
          },
          {
            "sha": "3998959ee28adf70502212bdecc5ed3a88c00986",
            "date": "2024-03-07T22:40:43Z",
            "author_login": "StephanTLavavej"
          },
          {
            "sha": "3a7b12017dc84ff569855d26c399845cafca028f",
            "date": "2024-05-23T14:26:58Z",
            "author_login": "ShortDevelopment"
          },
          {
            "sha": "682026b6077320b0d079f96595b751bd757c8229",
            "date": "2024-05-16T22:11:15Z",
            "author_login": "rhuanjl"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-119",
    "description": "A remote code execution vulnerability exists in the way affected Microsoft scripting engine render when handling objects in memory in Microsoft browsers. The vulnerability could corrupt memory in such a way that an attacker could execute arbitrary code in the context of the current user. An attacker who successfully exploited the vulnerability could gain the same user rights as the current user, aka \"Scripting Engine Memory Corruption Vulnerability.\"",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-07-17T13:18:11.250",
    "last_modified": "2024-11-21T03:02:26.700",
    "fix_date": "2017-03-09T00:58:06Z"
  },
  "references": [
    {
      "url": "https://github.com/Microsoft/ChakraCore/commit/9da019424601325a6e95e6be0fa03d7d21d0b517",
      "source": "secure@microsoft.com",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Microsoft/ChakraCore/commit/9da019424601325a6e95e6be0fa03d7d21d0b517",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:01.701887",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "ChakraCore",
    "owner": "Microsoft",
    "created_at": "2016-01-05T19:05:31Z",
    "updated_at": "2025-01-14T06:24:58Z",
    "pushed_at": "2024-08-12T08:15:35Z",
    "size": 183810,
    "stars": 9145,
    "forks": 1197,
    "open_issues": 606,
    "watchers": 9145,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "JavaScript": 51476459,
      "C++": 37031250,
      "C": 5066953,
      "WebAssembly": 3112291,
      "Assembly": 213208,
      "Roff": 176573,
      "Python": 102745,
      "CMake": 94903,
      "Batchfile": 84427,
      "PowerShell": 64480,
      "Shell": 52761,
      "Perl": 29562,
      "Pawn": 13139,
      "Mustache": 2910,
      "CSS": 1576
    },
    "commit_activity": {
      "total_commits_last_year": 25,
      "avg_commits_per_week": 0.4807692307692308,
      "days_active_last_year": 14
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T15:44:41.249948"
  }
}