{
  "cve_id": "CVE-2017-0377",
  "github_data": {
    "repository": "torproject/tor",
    "fix_commit": "665baf5ed5c6186d973c46cdea165c0548027350",
    "related_commits": [
      "665baf5ed5c6186d973c46cdea165c0548027350",
      "665baf5ed5c6186d973c46cdea165c0548027350"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "665baf5ed5c6186d973c46cdea165c0548027350",
      "commit_date": "2017-06-28T15:41:50Z",
      "author": {
        "login": "nmathewson",
        "type": "User",
        "stats": {
          "total_commits": 20512,
          "average_weekly_commits": 17.38305084745763,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 929
        }
      },
      "commit_message": {
        "title": "Consider the exit family when applying guard restrictions.",
        "length": 568,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 59,
        "additions": 53,
        "deletions": 6
      },
      "files": [
        {
          "filename": "changes/bug22753",
          "status": "added",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -0,0 +1,7 @@\n+  o Major bugfixes (path selection, security):\n+    - When choosing which guard to use for a circuit, avoid the\n+      exit's family along with the exit itself. Previously, the new\n+      guard selection logic avoided the exit, but did not consider\n+      its family.  Fixes bug 22753; bugfix on 0.3.0.1-alpha. Tracked\n+      as TROVE-2016-006 and CVE-2017-0377.\n+"
        },
        {
          "filename": "src/or/entrynodes.c",
          "status": "modified",
          "additions": 38,
          "deletions": 1,
          "patch": "@@ -1428,6 +1428,38 @@ entry_guard_passes_filter(const or_options_t *options, guard_selection_t *gs,\n   }\n }\n \n+/** Return true iff <b>guard</b> is in the same family as <b>node</b>.\n+ */\n+static int\n+guard_in_node_family(const entry_guard_t *guard, const node_t *node)\n+{\n+  const node_t *guard_node = node_get_by_id(guard->identity);\n+  if (guard_node) {\n+    return nodes_in_same_family(guard_node, node);\n+  } else {\n+    /* If we don't have a node_t for the guard node, we might have\n+     * a bridge_info_t for it. So let's check to see whether the bridge\n+     * address matches has any family issues.\n+     *\n+     * (Strictly speaking, I believe this check is unnecessary, since we only\n+     * use it to avoid the exit's family when building circuits, and we don't\n+     * build multihop circuits until we have a routerinfo_t for the\n+     * bridge... at which point, we'll also have a node_t for the\n+     * bridge. Nonetheless, it seems wise to include it, in case our\n+     * assumptions change down the road.  -nickm.)\n+     */\n+    if (get_options()->EnforceDistinctSubnets && guard->bridge_addr) {\n+      tor_addr_t node_addr;\n+      node_get_addr(node, &node_addr);\n+      if (addrs_in_same_network_family(&node_addr,\n+                                       &guard->bridge_addr->addr)) {\n+        return 1;\n+      }\n+    }\n+    return 0;\n+  }\n+}\n+\n /**\n  * Return true iff <b>guard</b> obeys the restrictions defined in <b>rst</b>.\n  * (If <b>rst</b> is NULL, there are no restrictions.)\n@@ -1440,7 +1472,12 @@ entry_guard_obeys_restriction(const entry_guard_t *guard,\n   if (! rst)\n     return 1; // No restriction?  No problem.\n \n-  // Only one kind of restriction exists right now\n+  // Only one kind of restriction exists right now: excluding an exit\n+  // ID and all of its family.\n+  const node_t *node = node_get_by_id((const char*)rst->exclude_id);\n+  if (node && guard_in_node_family(guard, node))\n+    return 0;\n+\n   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);\n }\n "
        },
        {
          "filename": "src/or/entrynodes.h",
          "status": "modified",
          "additions": 5,
          "deletions": 4,
          "patch": "@@ -276,16 +276,17 @@ struct entry_guard_handle_t;\n  * A restriction to remember which entry guards are off-limits for a given\n  * circuit.\n  *\n- * Right now, we only use restrictions to block a single guard from being\n- * selected; this mechanism is designed to be more extensible in the future,\n- * however.\n+ * Right now, we only use restrictions to block a single guard and its family\n+ * from being selected; this mechanism is designed to be more extensible in\n+ * the future, however.\n  *\n  * Note: This mechanism is NOT for recording which guards are never to be\n  * used: only which guards cannot be used on <em>one particular circuit</em>.\n  */\n struct entry_guard_restriction_t {\n   /**\n-   * The guard's RSA identity digest must not equal this.\n+   * The guard's RSA identity digest must not equal this; and it must not\n+   * be in the same family as any node with this digest.\n    */\n   uint8_t exclude_id[DIGEST_LEN];\n };"
        },
        {
          "filename": "src/or/nodelist.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1343,7 +1343,7 @@ nodelist_refresh_countries(void)\n \n /** Return true iff router1 and router2 have similar enough network addresses\n  * that we should treat them as being in the same family */\n-static inline int\n+int\n addrs_in_same_network_family(const tor_addr_t *a1,\n                              const tor_addr_t *a2)\n {"
        },
        {
          "filename": "src/or/nodelist.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -94,6 +94,8 @@ int node_is_unreliable(const node_t *router, int need_uptime,\n int router_exit_policy_all_nodes_reject(const tor_addr_t *addr, uint16_t port,\n                                         int need_uptime);\n void router_set_status(const char *digest, int up);\n+int addrs_in_same_network_family(const tor_addr_t *a1,\n+                                 const tor_addr_t *a2);\n \n /** router_have_minimum_dir_info tests to see if we have enough\n  * descriptor information to create circuits."
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "27d4ba90f6dbf0c80d518a358b9600ae789509e4",
            "date": "2024-03-05T22:23:20Z",
            "author_login": "micah"
          },
          {
            "sha": "3cb6a690be60fcdab60130402ff88dcfc0657596",
            "date": "2023-06-19T12:09:45Z",
            "author_login": "dgoulet-tor"
          },
          {
            "sha": "94f4d0968b57db8b3346a5b51b9e0c2ed3e8d98f",
            "date": "2023-06-15T17:00:11Z",
            "author_login": "dgoulet-tor"
          },
          {
            "sha": "623a55764b8c72e6271f822c1fe68b9613c551b9",
            "date": "2023-06-19T12:09:24Z",
            "author_login": "dgoulet-tor"
          },
          {
            "sha": "7a83aa4f5042905844cb9ab48a4876becd8f2175",
            "date": "2023-06-15T17:23:36Z",
            "author_login": "dgoulet-tor"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-200",
    "description": "Tor 0.3.x before 0.3.0.9 has a guard-selection algorithm that only considers the exit relay (not the exit relay's family), which might allow remote attackers to defeat intended anonymity properties by leveraging the existence of large families.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-07-02T15:29:00.187",
    "last_modified": "2024-11-21T03:02:51.920",
    "fix_date": "2017-06-28T15:41:50Z"
  },
  "references": [
    {
      "url": "https://blog.torproject.org/blog/tor-0309-released-security-update-clients",
      "source": "security@debian.org",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://blog.torproject.org/blog/tor-0314-alpha-released-security-update-clients",
      "source": "security@debian.org",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/torproject/tor/commit/665baf5ed5c6186d973c46cdea165c0548027350",
      "source": "security@debian.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security-tracker.debian.org/CVE-2017-0377",
      "source": "security@debian.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://trac.torproject.org/projects/tor/ticket/22753",
      "source": "security@debian.org",
      "tags": [
        "Issue Tracking",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://blog.torproject.org/blog/tor-0309-released-security-update-clients",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://blog.torproject.org/blog/tor-0314-alpha-released-security-update-clients",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/torproject/tor/commit/665baf5ed5c6186d973c46cdea165c0548027350",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security-tracker.debian.org/CVE-2017-0377",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://trac.torproject.org/projects/tor/ticket/22753",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:01.671893",
    "processing_status": "enhanced"
  }
}