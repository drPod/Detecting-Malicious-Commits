{
  "cve_id": "CVE-2017-11664",
  "github_data": {
    "repository": "Mindwerks/wildmidi",
    "fix_commit": "ad6d7cf88d6673167ca1f517248af9409a9f1be1",
    "related_commits": [
      "ad6d7cf88d6673167ca1f517248af9409a9f1be1",
      "ad6d7cf88d6673167ca1f517248af9409a9f1be1"
    ],
    "patch_url": "https://github.com/Mindwerks/wildmidi/commit/ad6d7cf88d6673167ca1f517248af9409a9f1be1.patch",
    "fix_commit_details": {
      "sha": "ad6d7cf88d6673167ca1f517248af9409a9f1be1",
      "commit_date": "2017-08-02T14:55:10Z",
      "author": {
        "login": "sezero",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix bug #175:",
        "length": 200,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 202,
        "additions": 162,
        "deletions": 40
      },
      "files": [
        {
          "filename": "include/internal_midi.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -191,7 +191,7 @@ extern int _WM_midi_setup_divisions(struct _mdi *mdi, uint32_t divisions);\n \n extern struct _mdi * _WM_initMDI(void);\n extern void _WM_freeMDI(struct _mdi *mdi);\n-extern uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t running_event);\n+extern uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint32_t siz, uint8_t running_event);\n extern void _WM_ResetToStart(struct _mdi *mdi);\n extern void _WM_do_pan_adjust(struct _mdi *mdi, uint8_t ch);\n extern void _WM_do_note_off_extra(struct _note *nte);"
        },
        {
          "filename": "src/f_hmi.c",
          "status": "modified",
          "additions": 34,
          "deletions": 6,
          "patch": "@@ -42,10 +42,10 @@ struct _mdi *\n _WM_ParseNewHmi(uint8_t *hmi_data, uint32_t hmi_size) {\n     uint32_t hmi_tmp = 0;\n     uint8_t *hmi_base = hmi_data;\n+    uint32_t data_siz;\n     uint16_t hmi_bpm = 0;\n     uint16_t hmi_division = 0;\n \n-//  uint32_t hmi_duration_secs = 0;\n     uint32_t hmi_track_cnt = 0;\n     uint32_t *hmi_track_offset = NULL;\n     uint32_t i = 0;\n@@ -74,8 +74,6 @@ _WM_ParseNewHmi(uint8_t *hmi_data, uint32_t hmi_size) {\n         uint8_t channel;\n     } *note;\n \n-    //FIXME: This needs to be used for sanity check.\n-    UNUSED(hmi_size);\n \n     if (memcmp(hmi_data, \"HMI-MIDISONG061595\", 18)) {\n         _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, NULL, 0);\n@@ -216,21 +214,35 @@ _WM_ParseNewHmi(uint8_t *hmi_data, uint32_t hmi_size) {\n             do {\n                 hmi_data = hmi_base + hmi_track_offset[i];\n                 hmi_delta[i] = 0;\n+                if (hmi_track_offset[i] >= hmi_size) {\n+                    _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n+                    goto _hmi_end;\n+                }\n+                data_siz = hmi_size - hmi_track_offset[i];\n \n                 if (hmi_data[0] == 0xfe) {\n                     // HMI only event of some sort.\n                     if (hmi_data[1] == 0x10) {\n                         hmi_tmp = (hmi_data[4] + 5);\n                         hmi_data += hmi_tmp;\n                         hmi_track_offset[i] += hmi_tmp;\n+                        hmi_tmp += 4;\n                     } else if (hmi_data[1] == 0x15) {\n                         hmi_data += 4;\n                         hmi_track_offset[i] += 4;\n+                        hmi_tmp = 8;\n+                    } else {\n+                        hmi_tmp = 4;\n                     }\n                     hmi_data += 4;\n                     hmi_track_offset[i] += 4;\n+                    if (hmi_tmp > data_siz) {\n+                        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n+                        goto _hmi_end;\n+                    }\n+                    data_siz -= hmi_tmp;\n                 } else {\n-                    if ((setup_ret = _WM_SetupMidiEvent(hmi_mdi,hmi_data,hmi_running_event[i])) == 0) {\n+                    if ((setup_ret = _WM_SetupMidiEvent(hmi_mdi,hmi_data,data_siz,hmi_running_event[i])) == 0) {\n                         goto _hmi_end;\n                     }\n                     if ((hmi_data[0] == 0xff) && (hmi_data[1] == 0x2f) && (hmi_data[2] == 0x00)) {\n@@ -269,17 +281,25 @@ _WM_ParseNewHmi(uint8_t *hmi_data, uint32_t hmi_size) {\n \n                         hmi_data += setup_ret;\n                         hmi_track_offset[i] += setup_ret;\n+                        data_siz -= setup_ret;\n \n                         note[hmi_tmp].length = 0;\n-                        if (*hmi_data > 0x7f) {\n+                        if (data_siz && *hmi_data > 0x7f) {\n                             do {\n+                                if (!data_siz) break;\n                                 note[hmi_tmp].length = (note[hmi_tmp].length << 7) | (*hmi_data & 0x7F);\n                                 hmi_data++;\n+                                data_siz--;\n                                 hmi_track_offset[i]++;\n                             } while (*hmi_data > 0x7F);\n                         }\n+                        if (!data_siz) {\n+                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n+                            goto _hmi_end;\n+                        }\n                         note[hmi_tmp].length = (note[hmi_tmp].length << 7) | (*hmi_data & 0x7F);\n                         hmi_data++;\n+                        data_siz--;\n                         hmi_track_offset[i]++;\n \n                         if (note[hmi_tmp].length) {\n@@ -293,20 +313,28 @@ _WM_ParseNewHmi(uint8_t *hmi_data, uint32_t hmi_size) {\n                     } else {\n                         hmi_data += setup_ret;\n                         hmi_track_offset[i] += setup_ret;\n+                        data_siz -= setup_ret;\n                     }\n                 }\n \n                 // get track delta\n                 // hmi_delta[i] = 0; // set at start of loop\n-                if (*hmi_data > 0x7f) {\n+                if (data_siz && *hmi_data > 0x7f) {\n                     do {\n+                        if (!data_siz) break;\n                         hmi_delta[i] = (hmi_delta[i] << 7) | (*hmi_data & 0x7F);\n                         hmi_data++;\n+                        data_siz--;\n                         hmi_track_offset[i]++;\n                     } while (*hmi_data > 0x7F);\n                 }\n+                if (!data_siz) {\n+                    _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n+                    goto _hmi_end;\n+                }\n                 hmi_delta[i] = (hmi_delta[i] << 7) | (*hmi_data & 0x7F);\n                 hmi_data++;\n+                data_siz--;\n                 hmi_track_offset[i]++;\n             } while (!hmi_delta[i]);\n             if ((!smallest_delta) || (smallest_delta > hmi_delta[i])) {"
        },
        {
          "filename": "src/f_hmp.c",
          "status": "modified",
          "additions": 13,
          "deletions": 2,
          "patch": "@@ -235,6 +235,7 @@ _WM_ParseNewHmp(uint8_t *hmp_data, uint32_t hmp_size) {\n \n         // goto start of next chunk\n         hmp_data = hmp_chunk[i] + chunk_length[i];\n+        chunk_length[i] -= chunk_ofs[i];\n         hmp_chunk[i] += chunk_ofs[i]++;\n         chunk_end[i] = 0;\n     }\n@@ -273,17 +274,19 @@ _WM_ParseNewHmp(uint8_t *hmp_data, uint32_t hmp_size) {\n                     // Reserved for loop markers\n                     // TODO: still deciding what to do about these\n                     hmp_chunk[i] += 3;\n+                    chunk_length[i] -= 3;\n                 } else {\n                     uint32_t setup_ret = 0;\n \n-                    if ((setup_ret = _WM_SetupMidiEvent(hmp_mdi, hmp_chunk[i], 0)) == 0) {\n+                    if ((setup_ret = _WM_SetupMidiEvent(hmp_mdi, hmp_chunk[i], chunk_length[i], 0)) == 0) {\n                         goto _hmp_end;\n                     }\n \n                     if ((hmp_chunk[i][0] == 0xff) && (hmp_chunk[i][1] == 0x2f) && (hmp_chunk[i][2] == 0x00)) {\n                         /* End of Chunk */\n                         end_of_chunks++;\n                         chunk_end[i] = 1;\n+                        chunk_length[i] -= 3;\n                         hmp_chunk[i] += 3;\n                         goto NEXT_CHUNK;\n                     } else if ((hmp_chunk[i][0] == 0xff) && (hmp_chunk[i][1] == 0x51) && (hmp_chunk[i][2] == 0x03)) {\n@@ -296,18 +299,26 @@ _WM_ParseNewHmp(uint8_t *hmp_data, uint32_t hmp_size) {\n                         fprintf(stderr,\"DEBUG: Tempo change %f\\r\\n\", tempo_f);\n                     }\n                     hmp_chunk[i] += setup_ret;\n+                    chunk_length[i] -= setup_ret;\n                 }\n                 var_len_shift = 0;\n                 chunk_delta[i] = 0;\n-                if (*hmp_chunk[i] < 0x80) {\n+                if (chunk_length[i] && *hmp_chunk[i] < 0x80) {\n                     do {\n+                        if (! chunk_length[i]) break;\n                         chunk_delta[i] = chunk_delta[i] + ((*hmp_chunk[i] & 0x7F) << var_len_shift);\n                         var_len_shift += 7;\n                         hmp_chunk[i]++;\n+                        chunk_length[i]--;\n                     } while (*hmp_chunk[i] < 0x80);\n                 }\n+                if (! chunk_length[i]) {\n+                    _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, \"file too short\", 0);\n+                    goto _hmp_end;\n+                }\n                 chunk_delta[i] = chunk_delta[i] + ((*hmp_chunk[i] & 0x7F) << var_len_shift);\n                 hmp_chunk[i]++;\n+                chunk_length[i]--;\n             } while (!chunk_delta[i]);\n \n             if ((!smallest_delta) || (smallest_delta > chunk_delta[i])) {"
        },
        {
          "filename": "src/f_midi.c",
          "status": "modified",
          "additions": 37,
          "deletions": 18,
          "patch": "@@ -43,8 +43,8 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n \n     uint32_t tmp_val;\n     uint32_t midi_type;\n-    uint32_t track_size;\n     uint8_t **tracks;\n+    uint32_t *track_size;\n     uint32_t end_of_tracks = 0;\n     uint32_t no_tracks;\n     uint32_t i;\n@@ -56,15 +56,11 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n     float sample_count_f = 0.0;\n     float sample_remainder = 0.0;\n     uint8_t *sysex_store = NULL;\n-//  uint32_t sysex_store_len = 0;\n \n     uint32_t *track_delta;\n     uint8_t *track_end;\n     uint32_t smallest_delta = 0;\n     uint32_t subtract_delta = 0;\n-//  uint32_t tmp_length = 0;\n-//  uint8_t current_event = 0;\n-//  uint8_t current_event_ch = 0;\n     uint8_t *running_event;\n     uint32_t setup_ret = 0;\n \n@@ -151,6 +147,7 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n     _WM_midi_setup_divisions(mdi,divisions);\n \n     tracks = malloc(sizeof(uint8_t *) * no_tracks);\n+    track_size = malloc(sizeof(uint32_t) * no_tracks);\n     track_delta = malloc(sizeof(uint32_t) * no_tracks);\n     track_end = malloc(sizeof(uint8_t) * no_tracks);\n     running_event = malloc(sizeof(uint8_t) * no_tracks);\n@@ -168,38 +165,42 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n         midi_data += 4;\n         midi_size -= 4;\n \n-        track_size = *midi_data++ << 24;\n-        track_size |= *midi_data++ << 16;\n-        track_size |= *midi_data++ << 8;\n-        track_size |= *midi_data++;\n+        /* track size */\n+        tmp_val = *midi_data++ << 24;\n+        tmp_val |= *midi_data++ << 16;\n+        tmp_val |= *midi_data++ << 8;\n+        tmp_val |= *midi_data++;\n         midi_size -= 4;\n-        if (midi_size < track_size) {\n+        if (midi_size < tmp_val) {\n             _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n             goto _end;\n         }\n-        if (track_size < 3) {\n+        if (tmp_val < 3) {\n             _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(bad track size)\", 0);\n             goto _end;\n         }\n-        if ((midi_data[track_size - 3] != 0xFF)\n-                || (midi_data[track_size - 2] != 0x2F)\n-                || (midi_data[track_size - 1] != 0x00)) {\n+        if ((midi_data[tmp_val - 3] != 0xFF)\n+                || (midi_data[tmp_val - 2] != 0x2F)\n+                || (midi_data[tmp_val - 1] != 0x00)) {\n             _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(missing EOT)\", 0);\n             goto _end;\n         }\n         tracks[i] = midi_data;\n-        midi_data += track_size;\n-        midi_size -= track_size;\n+        track_size[i] = tmp_val;\n+        midi_data += tmp_val;\n+        midi_size -= tmp_val;\n         track_end[i] = 0;\n         running_event[i] = 0;\n         track_delta[i] = 0;\n \n         while (*tracks[i] > 0x7F) {\n             track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n             tracks[i]++;\n+            track_size[i]--;\n         }\n         track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n         tracks[i]++;\n+        track_size[i]--;\n \n         if (midi_type == 1 ) {\n             if (track_delta[i] < smallest_delta) {\n@@ -243,7 +244,7 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n                     }\n                 }\n                 do {\n-                    setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], running_event[i]);\n+                    setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], track_size[i], running_event[i]);\n                     if (setup_ret == 0) {\n                         goto _end;\n                     }\n@@ -259,6 +260,7 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n                             end_of_tracks++;\n                             track_end[i] = 1;\n                             tracks[i] += 3;\n+                            track_size[i] -= 3;\n                             goto NEXT_TRACK;\n                         } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x51) && (tracks[i][2] == 0x03)) {\n                             /* Tempo */\n@@ -270,15 +272,23 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n                         }\n                     }\n                     tracks[i] += setup_ret;\n+                    track_size[i] -= setup_ret;\n \n                     if (*tracks[i] > 0x7f) {\n                         do {\n+                            if (!track_size[i]) break;\n                             track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                             tracks[i]++;\n+                            track_size[i]--;\n                         } while (*tracks[i] > 0x7f);\n                     }\n+                    if (!track_size[i]) {\n+                        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n+                        goto _end;\n+                    }\n                     track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                     tracks[i]++;\n+                    track_size[i]--;\n                 } while (!track_delta[i]);\n                 if ((!smallest_delta) || (smallest_delta > track_delta[i])) {\n                     smallest_delta = track_delta[i];\n@@ -304,7 +314,7 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n         for (i = 0; i < no_tracks; i++) {\n             running_event[i] = 0;\n             do {\n-                setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], running_event[i]);\n+                setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], track_size[i], running_event[i]);\n                 if (setup_ret == 0) {\n                     goto _end;\n                 }\n@@ -329,16 +339,24 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n                     }\n                 }\n                 tracks[i] += setup_ret;\n+                track_size[i] -= setup_ret;\n \n                 track_delta[i] = 0;\n                 if (*tracks[i] > 0x7f) {\n                     do {\n+                        if (!track_size[i]) break;\n                         track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                         tracks[i]++;\n+                        track_size[i]--;\n                     } while (*tracks[i] > 0x7f);\n                 }\n+                if (!track_size[i]) {\n+                    _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n+                    goto _end;\n+                }\n                 track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                 tracks[i]++;\n+                track_size[i]--;\n \n                 sample_count_f = (((float) track_delta[i] * samples_per_delta_f)\n                                   + sample_remainder);\n@@ -372,6 +390,7 @@ _end:   free(sysex_store);\n     free(track_delta);\n     free(running_event);\n     free(tracks);\n+    free(track_size);\n     if (mdi->reverb) return (mdi);\n     _WM_freeMDI(mdi);\n     return (NULL);"
        },
        {
          "filename": "src/f_mus.c",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -61,7 +61,8 @@ _WM_ParseNewMus(uint8_t *mus_data, uint32_t mus_size) {\n     float tempo_f = 0.0;\n     uint16_t mus_freq = 0;\n     float samples_per_tick_f = 0.0;\n-    uint8_t mus_event[] = { 0, 0, 0, 0 };\n+#define MUS_SZ 4\n+    uint8_t mus_event[MUS_SZ] = { 0, 0, 0, 0 };\n     uint8_t mus_event_size = 0;\n     uint8_t mus_prev_vol[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n     uint32_t setup_ret = 0;\n@@ -314,7 +315,7 @@ _WM_ParseNewMus(uint8_t *mus_data, uint32_t mus_size) {\n                 break;\n         }\n \n-        setup_ret = _WM_SetupMidiEvent(mus_mdi, (uint8_t *)mus_event, 0);\n+        setup_ret = _WM_SetupMidiEvent(mus_mdi, (uint8_t *)mus_event, MUS_SZ, 0);\n         if (setup_ret == 0) {\n             goto _mus_end;\n         }"
        },
        {
          "filename": "src/f_xmidi.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -267,7 +267,7 @@ struct _mdi *_WM_ParseNewXmi(uint8_t *xmi_data, uint32_t xmi_size) {\n                             setup_ret = 6;\n                             goto _XMI_Next_Event;\n                         }\n-                        if ((setup_ret = _WM_SetupMidiEvent(xmi_mdi,xmi_data,0)) == 0) {\n+                        if ((setup_ret = _WM_SetupMidiEvent(xmi_mdi,xmi_data, xmi_size, 0)) == 0) {\n                             goto _xmi_end;\n                         }\n "
        },
        {
          "filename": "src/internal_midi.c",
          "status": "modified",
          "additions": 73,
          "deletions": 10,
          "patch": "@@ -1962,7 +1962,7 @@ void _WM_freeMDI(struct _mdi *mdi) {\n     free(mdi);\n }\n \n-uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t running_event) {\n+uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint32_t siz, uint8_t running_event) {\n     /*\n      Only add standard MIDI and Sysex events in here.\n      Non-standard events need to be handled by calling function\n@@ -1978,10 +1978,13 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n     uint8_t data_2 = 0;\n     char *text = NULL;\n \n+    if (!siz) goto shortbuf;\n+\n     if (event_data[0] >= 0x80) {\n         command = *event_data & 0xf0;\n         channel = *event_data++ & 0x0f;\n         ret_cnt++;\n+        if (--siz == 0) goto shortbuf;\n     } else {\n         command = running_event & 0xf0;\n         channel = running_event & 0x0f;\n@@ -1990,25 +1993,29 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n     switch(command) {\n         case 0x80:\n         _SETUP_NOTEOFF:\n+            if (siz < 2) goto shortbuf;\n             data_1 = *event_data++;\n             data_2 = *event_data++;\n             _WM_midi_setup_noteoff(mdi, channel, data_1, data_2);\n             ret_cnt += 2;\n             break;\n         case 0x90:\n             if (event_data[1] == 0) goto _SETUP_NOTEOFF; /* A velocity of 0 in a note on is actually a note off */\n+            if (siz < 2) goto shortbuf;\n             data_1 = *event_data++;\n             data_2 = *event_data++;\n             midi_setup_noteon(mdi, channel, data_1, data_2);\n             ret_cnt += 2;\n             break;\n         case 0xa0:\n+            if (siz < 2) goto shortbuf;\n             data_1 = *event_data++;\n             data_2 = *event_data++;\n             midi_setup_aftertouch(mdi, channel, data_1, data_2);\n             ret_cnt += 2;\n             break;\n         case 0xb0:\n+            if (siz < 2) goto shortbuf;\n             data_1 = *event_data++;\n             data_2 = *event_data++;\n             midi_setup_control(mdi, channel, data_1, data_2);\n@@ -2025,6 +2032,7 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n             ret_cnt++;\n             break;\n         case 0xe0:\n+            if (siz < 2) goto shortbuf;\n             data_1 = *event_data++;\n             data_2 = *event_data++;\n             midi_setup_pitch(mdi, channel, ((data_2 << 7) | (data_1 & 0x7f)));\n@@ -2041,23 +2049,29 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                      Sequence Number\n                      We only setting this up here for WM_Event2Midi function\n                      */\n+                    if (siz < 4) goto shortbuf;\n                     midi_setup_sequenceno(mdi, ((event_data[2] << 8) + event_data[3]));\n                     ret_cnt += 4;\n                 } else if (event_data[0] == 0x01) {\n                     /* Text Event */\n                     /* Get Length */\n                     event_data++;\n                     ret_cnt++;\n-                    if (*event_data > 0x7f) {\n+                    if (--siz && *event_data > 0x7f) {\n                         do {\n+                            if (!siz) break;\n                             tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                             event_data++;\n+                            siz--;\n                             ret_cnt++;\n                         } while (*event_data > 0x7f);\n                     }\n+                    if (!siz) goto shortbuf;\n                     tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                     event_data++;\n                     ret_cnt++;\n+                    if (--siz < tmp_length) goto shortbuf;\n+                    if (!tmp_length) break; /* bad file? */\n \n                     text = malloc(tmp_length + 1);\n                     memcpy(text, event_data, tmp_length);\n@@ -2071,16 +2085,21 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                     /* Get Length */\n                     event_data++;\n                     ret_cnt++;\n-                    if (*event_data > 0x7f) {\n+                    if (--siz && *event_data > 0x7f) {\n                         do {\n+                            if (!siz) break;\n                             tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                             event_data++;\n+                            siz--;\n                             ret_cnt++;\n                         } while (*event_data > 0x7f);\n                     }\n+                    if (!siz) goto shortbuf;\n                     tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                     event_data++;\n                     ret_cnt++;\n+                    if (--siz < tmp_length) goto shortbuf;\n+                    if (!tmp_length) break; /* bad file? */\n \n                     /* Copy copyright info in the getinfo struct */\n                     if (mdi->extra_info.copyright) {\n@@ -2107,16 +2126,21 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                     /* Get Length */\n                     event_data++;\n                     ret_cnt++;\n-                    if (*event_data > 0x7f) {\n+                    if (--siz && *event_data > 0x7f) {\n                         do {\n+                            if (!siz) break;\n                             tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                             event_data++;\n+                            siz--;\n                             ret_cnt++;\n                         } while (*event_data > 0x7f);\n                     }\n+                    if (!siz) goto shortbuf;\n                     tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                     event_data++;\n                     ret_cnt++;\n+                    if (--siz < tmp_length) goto shortbuf;\n+                    if (!tmp_length) break; /* bad file? */\n \n                     text = malloc(tmp_length + 1);\n                     memcpy(text, event_data, tmp_length);\n@@ -2130,16 +2154,21 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                     /* Get Length */\n                     event_data++;\n                     ret_cnt++;\n-                    if (*event_data > 0x7f) {\n+                    if (--siz && *event_data > 0x7f) {\n                         do {\n+                            if (!siz) break;\n                             tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                             event_data++;\n+                            siz--;\n                             ret_cnt++;\n                         } while (*event_data > 0x7f);\n                     }\n+                    if (!siz) goto shortbuf;\n                     tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                     event_data++;\n                     ret_cnt++;\n+                    if (--siz < tmp_length) goto shortbuf;\n+                    if (!tmp_length) break; /* bad file? */\n \n                     text = malloc(tmp_length + 1);\n                     memcpy(text, event_data, tmp_length);\n@@ -2153,16 +2182,21 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                     /* Get Length */\n                     event_data++;\n                     ret_cnt++;\n-                    if (*event_data > 0x7f) {\n+                    if (--siz && *event_data > 0x7f) {\n                         do {\n+                            if (!siz) break;\n                             tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                             event_data++;\n+                            siz--;\n                             ret_cnt++;\n                         } while (*event_data > 0x7f);\n                     }\n+                    if (!siz) goto shortbuf;\n                     tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                     event_data++;\n                     ret_cnt++;\n+                    if (--siz < tmp_length) goto shortbuf;\n+                    if (!tmp_length) break; /* bad file? */\n \n                     text = malloc(tmp_length + 1);\n                     memcpy(text, event_data, tmp_length);\n@@ -2176,16 +2210,21 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                     /* Get Length */\n                     event_data++;\n                     ret_cnt++;\n-                    if (*event_data > 0x7f) {\n+                    if (--siz && *event_data > 0x7f) {\n                         do {\n+                            if (!siz) break;\n                             tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                             event_data++;\n+                            siz--;\n                             ret_cnt++;\n                         } while (*event_data > 0x7f);\n                     }\n+                    if (!siz) goto shortbuf;\n                     tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                     event_data++;\n                     ret_cnt++;\n+                    if (--siz < tmp_length) goto shortbuf;\n+                    if (!tmp_length) break; /* bad file? */\n \n                     text = malloc(tmp_length + 1);\n                     memcpy(text, event_data, tmp_length);\n@@ -2199,16 +2238,21 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                     /* Get Length */\n                     event_data++;\n                     ret_cnt++;\n-                    if (*event_data > 0x7f) {\n+                    if (--siz && *event_data > 0x7f) {\n                         do {\n+                            if (!siz) break;\n                             tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                             event_data++;\n+                            siz--;\n                             ret_cnt++;\n                         } while (*event_data > 0x7f);\n                     }\n+                    if (!siz) goto shortbuf;\n                     tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                     event_data++;\n                     ret_cnt++;\n+                    if (--siz < tmp_length) goto shortbuf;\n+                    if (!tmp_length) break; /* bad file? */\n \n                     text = malloc(tmp_length + 1);\n                     memcpy(text, event_data, tmp_length);\n@@ -2222,13 +2266,15 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                      Channel Prefix\n                      We only setting this up here for WM_Event2Midi function\n                      */\n+                    if (siz < 3) goto shortbuf;\n                     midi_setup_channelprefix(mdi, event_data[2]);\n                     ret_cnt += 3;\n                 } else if ((event_data[0] == 0x21) && (event_data[1] == 0x01)) {\n                     /*\n                      Port Prefix\n                      We only setting this up here for WM_Event2Midi function\n                      */\n+                    if (siz < 3) goto shortbuf;\n                     midi_setup_portprefix(mdi, event_data[2]);\n                     ret_cnt += 3;\n                 } else if ((event_data[0] == 0x2F) && (event_data[1] == 0x00)) {\n@@ -2237,6 +2283,7 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                      Deal with this inside calling function\n                      We only setting this up here for _WM_Event2Midi function\n                      */\n+                    if (siz < 2) goto shortbuf;\n                     _WM_midi_setup_endoftrack(mdi);\n                     ret_cnt += 2;\n                 } else if ((event_data[0] == 0x51) && (event_data[1] == 0x03)) {\n@@ -2245,9 +2292,11 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                      Deal with this inside calling function.\n                      We only setting this up here for _WM_Event2Midi function\n                      */\n+                    if (siz < 5) goto shortbuf;\n                     _WM_midi_setup_tempo(mdi, ((event_data[2] << 16) + (event_data[3] << 8) + event_data[4]));\n                     ret_cnt += 5;\n                 } else if ((event_data[0] == 0x54) && (event_data[1] == 0x05)) {\n+                    if (siz < 7) goto shortbuf;\n                     /*\n                      SMPTE Offset\n                      We only setting this up here for WM_Event2Midi function\n@@ -2265,13 +2314,15 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                      Time Signature\n                      We only setting this up here for WM_Event2Midi function\n                      */\n+                    if (siz < 6) goto shortbuf;\n                     midi_setup_timesignature(mdi, ((event_data[2] << 24) + (event_data[3] << 16) + (event_data[4] << 8) + event_data[5]));\n                     ret_cnt += 6;\n                 } else if ((event_data[0] == 0x59) && (event_data[1] == 0x02)) {\n                     /*\n                      Key Signature\n                      We only setting this up here for WM_Event2Midi function\n                      */\n+                    if (siz < 4) goto shortbuf;\n                     midi_setup_keysignature(mdi, ((event_data[2] << 8) + event_data[3]));\n                     ret_cnt += 4;\n                 } else {\n@@ -2280,16 +2331,20 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                      */\n                     event_data++;\n                     ret_cnt++;\n-                    if (*event_data > 0x7f) {\n+                    if (--siz && *event_data > 0x7f) {\n                         do {\n+                            if (!siz) break;\n                             tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                             event_data++;\n+                            siz--;\n                             ret_cnt++;\n                         } while (*event_data > 0x7f);\n                     }\n+                    if (!siz) goto shortbuf;\n                     tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                     ret_cnt++;\n                     ret_cnt += tmp_length;\n+                    if (--siz < tmp_length) goto shortbuf;\n                 }\n \n             } else if ((channel == 0) || (channel == 7)) {\n@@ -2301,15 +2356,19 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n \n                 if (*event_data > 0x7f) {\n                     do {\n+                        if (!siz) break;\n                         sysex_len = (sysex_len << 7) + (*event_data & 0x7F);\n                         event_data++;\n+                        siz--;\n                         ret_cnt++;\n                     } while (*event_data > 0x7f);\n                 }\n+                if (!siz) goto shortbuf;\n                 sysex_len = (sysex_len << 7) + (*event_data & 0x7F);\n                 event_data++;\n-                if (!sysex_len) break;\n                 ret_cnt++;\n+                if (--siz < sysex_len) goto shortbuf;\n+                if (!sysex_len) break; /* bad file? */\n \n                 sysex_store = malloc(sizeof(uint8_t) * sysex_len);\n                 memcpy(sysex_store, event_data, sysex_len);\n@@ -2381,5 +2440,9 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n     if (ret_cnt == 0)\n         _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(missing event)\", 0);\n     return ret_cnt;\n+\n+shortbuf:\n+    _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(input too short)\", 0);\n+    return 0;\n }\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d6acaaadd1c68f369f4342904dd28f2271d7bb0e",
            "date": "2025-01-06T11:00:28Z",
            "author_login": "MonicaLiu0311"
          },
          {
            "sha": "67b0c9a70bd49e4b99df285a984171c158747c55",
            "date": "2024-11-28T18:46:36Z",
            "author_login": "trialuser02"
          },
          {
            "sha": "233defddc71a10d6f5d86babd747f7e3e8fdf897",
            "date": "2024-09-30T12:02:45Z",
            "author_login": "psi29a"
          },
          {
            "sha": "7df9c72c3af71357fd4b4a584b1049004618e27a",
            "date": "2024-09-30T12:02:17Z",
            "author_login": "psi29a"
          },
          {
            "sha": "1973ffc4f454ad78a5fb191edf9354aab70d2831",
            "date": "2024-09-23T06:00:13Z",
            "author_login": "raziel-"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-125",
    "description": "The _WM_SetupMidiEvent function in internal_midi.c:2122 in WildMIDI 0.4.2 can cause a denial of service (invalid memory read and application crash) via a crafted mid file.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2017-08-17T16:29:00.330",
    "last_modified": "2024-11-21T03:08:15.350",
    "fix_date": "2017-08-02T14:55:10Z"
  },
  "references": [
    {
      "url": "http://seclists.org/fulldisclosure/2017/Aug/12",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Mindwerks/wildmidi/commit/ad6d7cf88d6673167ca1f517248af9409a9f1be1",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.exploit-db.com/exploits/42433/",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "http://seclists.org/fulldisclosure/2017/Aug/12",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Mindwerks/wildmidi/commit/ad6d7cf88d6673167ca1f517248af9409a9f1be1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.exploit-db.com/exploits/42433/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory",
        "VDB Entry"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:05.105216",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "wildmidi",
    "owner": "Mindwerks",
    "created_at": "2014-01-09T15:02:09Z",
    "updated_at": "2025-01-08T12:18:37Z",
    "pushed_at": "2025-01-06T11:00:29Z",
    "size": 3149,
    "stars": 209,
    "forks": 43,
    "open_issues": 35,
    "watchers": 209,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 705342,
      "CMake": 23705,
      "Makefile": 16155,
      "C++": 5976,
      "GLSL": 347
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T20:06:39.086897"
  }
}