{
  "cve_id": "CVE-2017-13003",
  "github_data": {
    "repository": "the-tcpdump-group/tcpdump",
    "fix_commit": "a25211918f2e790c67d859d20ccf8dbb81da1598",
    "related_commits": [
      "a25211918f2e790c67d859d20ccf8dbb81da1598",
      "a25211918f2e790c67d859d20ccf8dbb81da1598"
    ],
    "patch_url": "https://github.com/the-tcpdump-group/tcpdump/commit/a25211918f2e790c67d859d20ccf8dbb81da1598.patch",
    "fix_commit_details": {
      "sha": "a25211918f2e790c67d859d20ccf8dbb81da1598",
      "commit_date": "2017-02-20T05:13:25Z",
      "author": {
        "login": "guyharris",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "CVE-2017-13003/Clean up the LMP dissector.",
        "length": 871,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 483,
        "additions": 400,
        "deletions": 83
      },
      "files": [
        {
          "filename": "extract.h",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -19,6 +19,13 @@\n  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n  */\n \n+/*\n+ * For 8-bit values; provided for the sake of completeness.  Byte order\n+ * isn't relevant, and alignment isn't an issue.\n+ */\n+#define EXTRACT_8BITS(p)\t(*(p))\n+#define EXTRACT_LE_8BITS(p)\t(*(p))\n+\n /*\n  * Inline functions or macros to extract possibly-unaligned big-endian\n  * integral values.\n@@ -226,7 +233,6 @@ EXTRACT_64BITS(const void *p)\n  * Macros to extract possibly-unaligned little-endian integral values.\n  * XXX - do loads on little-endian machines that support unaligned loads?\n  */\n-#define EXTRACT_LE_8BITS(p) (*(p))\n #define EXTRACT_LE_16BITS(p) \\\n \t((uint16_t)(((uint16_t)(*((const uint8_t *)(p) + 1)) << 8) | \\\n \t            ((uint16_t)(*((const uint8_t *)(p) + 0)) << 0)))"
        },
        {
          "filename": "print-lmp.c",
          "status": "modified",
          "additions": 350,
          "deletions": 82,
          "patch": "@@ -11,13 +11,14 @@\n  * FOR A PARTICULAR PURPOSE.\n  *\n  * Original code by Hannes Gredler (hannes@gredler.at)\n- * Support for LMP service discovery extensions (defined by UNI 1.0) added\n- * by Manu Pathak (mapathak@cisco.com), May 2005\n+ * Support for LMP service discovery extensions (defined by OIF UNI 1.0)\n+ * added by Manu Pathak (mapathak@cisco.com), May 2005\n  */\n \n /* \\summary: Link Management Protocol (LMP) printer */\n \n /* specification: RFC 4204 */\n+/* OIF UNI 1.0: http://www.oiforum.com/public/documents/OIF-UNI-01.0.pdf */\n \n #ifdef HAVE_CONFIG_H\n #include \"config.h\"\n@@ -353,17 +354,84 @@ static const struct tok lmp_ctype_values[] = {\n     { 0, NULL}\n };\n \n+static int\n+lmp_print_data_link_subobjs(netdissect_options *ndo, const u_char *obj_tptr,\n+                            int total_subobj_len, int offset)\n+{\n+    int hexdump = FALSE;\n+    int subobj_type, subobj_len;\n+\n+    union { /* int to float conversion buffer */\n+        float f;\n+        uint32_t i;\n+    } bw;\n+\n+    while (total_subobj_len > 0 && hexdump == FALSE ) {\n+\tsubobj_type = EXTRACT_8BITS(obj_tptr+offset);\n+\tsubobj_len  = EXTRACT_8BITS(obj_tptr+offset+1);\n+\tND_PRINT((ndo, \"\\n\\t    Subobject, Type: %s (%u), Length: %u\",\n+\t\ttok2str(lmp_data_link_subobj,\n+\t\t\t\"Unknown\",\n+\t\t\tsubobj_type),\n+\t\t\tsubobj_type,\n+\t\t\tsubobj_len));\n+\tif (subobj_len < 4) {\n+\t    ND_PRINT((ndo, \" (too short)\"));\n+\t    break;\n+\t}\n+\tif ((subobj_len % 4) != 0) {\n+\t    ND_PRINT((ndo, \" (not a multiple of 4)\"));\n+\t    break;\n+\t}\n+\tif (total_subobj_len < subobj_len) {\n+\t    ND_PRINT((ndo, \" (goes past the end of the object)\"));\n+\t    break;\n+\t}\n+\tswitch(subobj_type) {\n+\tcase INT_SWITCHING_TYPE_SUBOBJ:\n+\t    ND_PRINT((ndo, \"\\n\\t      Switching Type: %s (%u)\",\n+\t\ttok2str(gmpls_switch_cap_values,\n+\t\t\t\"Unknown\",\n+\t\t\tEXTRACT_8BITS(obj_tptr+offset+2)),\n+\t\tEXTRACT_8BITS(obj_tptr+offset+2)));\n+\t    ND_PRINT((ndo, \"\\n\\t      Encoding Type: %s (%u)\",\n+\t\ttok2str(gmpls_encoding_values,\n+\t\t\t\"Unknown\",\n+\t\t\tEXTRACT_8BITS(obj_tptr+offset+3)),\n+\t\tEXTRACT_8BITS(obj_tptr+offset+3)));\n+\t    bw.i = EXTRACT_32BITS(obj_tptr+offset+4);\n+\t    ND_PRINT((ndo, \"\\n\\t      Min Reservable Bandwidth: %.3f Mbps\",\n+                bw.f*8/1000000));\n+\t    bw.i = EXTRACT_32BITS(obj_tptr+offset+8);\n+\t    ND_PRINT((ndo, \"\\n\\t      Max Reservable Bandwidth: %.3f Mbps\",\n+                bw.f*8/1000000));\n+\t    break;\n+\tcase WAVELENGTH_SUBOBJ:\n+\t    ND_PRINT((ndo, \"\\n\\t      Wavelength: %u\",\n+\t\tEXTRACT_32BITS(obj_tptr+offset+4)));\n+\t    break;\n+\tdefault:\n+\t    /* Any Unknown Subobject ==> Exit loop */\n+\t    hexdump=TRUE;\n+\t    break;\n+\t}\n+\ttotal_subobj_len-=subobj_len;\n+\toffset+=subobj_len;\n+    }\n+    return (hexdump);\n+}\n+\n void\n lmp_print(netdissect_options *ndo,\n           register const u_char *pptr, register u_int len)\n {\n     const struct lmp_common_header *lmp_com_header;\n     const struct lmp_object_header *lmp_obj_header;\n     const u_char *tptr,*obj_tptr;\n-    int tlen,lmp_obj_len,lmp_obj_ctype,obj_tlen;\n+    u_int tlen,lmp_obj_len,lmp_obj_ctype,obj_tlen;\n     int hexdump;\n-    int offset,subobj_type,subobj_len,total_subobj_len;\n-    int link_type;\n+    u_int offset;\n+    u_int link_type;\n \n     union { /* int to float conversion buffer */\n         float f;\n@@ -401,6 +469,14 @@ lmp_print(netdissect_options *ndo,\n            tok2str(lmp_msg_type_values, \"unknown, type: %u\",lmp_com_header->msg_type),\n            bittok2str(lmp_header_flag_values,\"none\",lmp_com_header->flags),\n            tlen));\n+    if (tlen < sizeof(const struct lmp_common_header)) {\n+        ND_PRINT((ndo, \" (too short)\"));\n+        return;\n+    }\n+    if (tlen > len) {\n+        ND_PRINT((ndo, \" (too long)\"));\n+        tlen = len;\n+    }\n \n     tptr+=sizeof(const struct lmp_common_header);\n     tlen-=sizeof(const struct lmp_common_header);\n@@ -413,9 +489,6 @@ lmp_print(netdissect_options *ndo,\n         lmp_obj_len=EXTRACT_16BITS(lmp_obj_header->length);\n         lmp_obj_ctype=(lmp_obj_header->ctype)&0x7f;\n \n-        if(lmp_obj_len % 4 || lmp_obj_len < 4)\n-            return;\n-\n         ND_PRINT((ndo, \"\\n\\t  %s Object (%u), Class-Type: %s (%u) Flags: [%snegotiable], length: %u\",\n                tok2str(lmp_obj_values,\n                        \"Unknown\",\n@@ -428,6 +501,15 @@ lmp_print(netdissect_options *ndo,\n                (lmp_obj_header->ctype)&0x80 ? \"\" : \"non-\",\n                lmp_obj_len));\n \n+        if (lmp_obj_len < 4) {\n+            ND_PRINT((ndo, \" (too short)\"));\n+            return;\n+        }\n+        if ((lmp_obj_len % 4) != 0) {\n+            ND_PRINT((ndo, \" (not a multiple of 4)\"));\n+            return;\n+        }\n+\n         obj_tptr=tptr+sizeof(struct lmp_object_header);\n         obj_tlen=lmp_obj_len-sizeof(struct lmp_object_header);\n \n@@ -441,6 +523,10 @@ lmp_print(netdissect_options *ndo,\n             switch(lmp_obj_ctype) {\n             case LMP_CTYPE_LOC:\n             case LMP_CTYPE_RMT:\n+                if (obj_tlen != 4) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n                 ND_PRINT((ndo, \"\\n\\t    Control Channel ID: %u (0x%08x)\",\n                        EXTRACT_32BITS(obj_tptr),\n                        EXTRACT_32BITS(obj_tptr)));\n@@ -456,18 +542,30 @@ lmp_print(netdissect_options *ndo,\n             switch(lmp_obj_ctype) {\n             case LMP_CTYPE_IPV4_LOC:\n             case LMP_CTYPE_IPV4_RMT:\n+                if (obj_tlen != 4) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n                 ND_PRINT((ndo, \"\\n\\t    IPv4 Link ID: %s (0x%08x)\",\n                        ipaddr_string(ndo, obj_tptr),\n                        EXTRACT_32BITS(obj_tptr)));\n                 break;\n             case LMP_CTYPE_IPV6_LOC:\n             case LMP_CTYPE_IPV6_RMT:\n+                if (obj_tlen != 16) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n                 ND_PRINT((ndo, \"\\n\\t    IPv6 Link ID: %s (0x%08x)\",\n                        ip6addr_string(ndo, obj_tptr),\n                        EXTRACT_32BITS(obj_tptr)));\n                 break;\n             case LMP_CTYPE_UNMD_LOC:\n             case LMP_CTYPE_UNMD_RMT:\n+                if (obj_tlen != 4) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n                 ND_PRINT((ndo, \"\\n\\t    Link ID: %u (0x%08x)\",\n                        EXTRACT_32BITS(obj_tptr),\n                        EXTRACT_32BITS(obj_tptr)));\n@@ -480,11 +578,19 @@ lmp_print(netdissect_options *ndo,\n         case LMP_OBJ_MESSAGE_ID:\n             switch(lmp_obj_ctype) {\n             case LMP_CTYPE_1:\n+                if (obj_tlen != 4) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n                 ND_PRINT((ndo, \"\\n\\t    Message ID: %u (0x%08x)\",\n                        EXTRACT_32BITS(obj_tptr),\n                        EXTRACT_32BITS(obj_tptr)));\n                 break;\n             case LMP_CTYPE_2:\n+                if (obj_tlen != 4) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n                 ND_PRINT((ndo, \"\\n\\t    Message ID Ack: %u (0x%08x)\",\n                        EXTRACT_32BITS(obj_tptr),\n                        EXTRACT_32BITS(obj_tptr)));\n@@ -498,6 +604,10 @@ lmp_print(netdissect_options *ndo,\n             switch(lmp_obj_ctype) {\n             case LMP_CTYPE_LOC:\n             case LMP_CTYPE_RMT:\n+                if (obj_tlen != 4) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n                 ND_PRINT((ndo, \"\\n\\t    Node ID: %s (0x%08x)\",\n                        ipaddr_string(ndo, obj_tptr),\n                        EXTRACT_32BITS(obj_tptr)));\n@@ -511,6 +621,10 @@ lmp_print(netdissect_options *ndo,\n         case LMP_OBJ_CONFIG:\n             switch(lmp_obj_ctype) {\n             case LMP_CTYPE_HELLO_CONFIG:\n+                if (obj_tlen != 4) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n                 ND_PRINT((ndo, \"\\n\\t    Hello Interval: %u\\n\\t    Hello Dead Interval: %u\",\n                        EXTRACT_16BITS(obj_tptr),\n                        EXTRACT_16BITS(obj_tptr+2)));\n@@ -524,6 +638,10 @@ lmp_print(netdissect_options *ndo,\n         case LMP_OBJ_HELLO:\n             switch(lmp_obj_ctype) {\n \t    case LMP_CTYPE_HELLO:\n+                if (obj_tlen != 8) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n                 ND_PRINT((ndo, \"\\n\\t    Tx Seq: %u, Rx Seq: %u\",\n                        EXTRACT_32BITS(obj_tptr),\n                        EXTRACT_32BITS(obj_tptr+4)));\n@@ -535,13 +653,17 @@ lmp_print(netdissect_options *ndo,\n             break;\n \n         case LMP_OBJ_TE_LINK:\n+\t    switch(lmp_obj_ctype) {\n+\t    case LMP_CTYPE_IPV4:\n+                if (obj_tlen != 12) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n \t\tND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n-\t\tbittok2str(lmp_obj_te_link_flag_values,\n+\t\t    bittok2str(lmp_obj_te_link_flag_values,\n \t\t\t\"none\",\n-\t\t\tEXTRACT_16BITS(obj_tptr)>>8)));\n+\t\t\tEXTRACT_8BITS(obj_tptr))));\n \n-\t    switch(lmp_obj_ctype) {\n-\t    case LMP_CTYPE_IPV4:\n \t\tND_PRINT((ndo, \"\\n\\t    Local Link-ID: %s (0x%08x)\"\n \t\t       \"\\n\\t    Remote Link-ID: %s (0x%08x)\",\n                        ipaddr_string(ndo, obj_tptr+4),\n@@ -551,73 +673,108 @@ lmp_print(netdissect_options *ndo,\n \t\tbreak;\n \n \t    case LMP_CTYPE_IPV6:\n+                if (obj_tlen != 36) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n+\t\tND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n+\t\t    bittok2str(lmp_obj_te_link_flag_values,\n+\t\t\t\"none\",\n+\t\t\tEXTRACT_8BITS(obj_tptr))));\n+\n+\t\tND_PRINT((ndo, \"\\n\\t    Local Link-ID: %s (0x%08x)\"\n+\t\t       \"\\n\\t    Remote Link-ID: %s (0x%08x)\",\n+                       ip6addr_string(ndo, obj_tptr+4),\n+                       EXTRACT_32BITS(obj_tptr+4),\n+                       ip6addr_string(ndo, obj_tptr+20),\n+                       EXTRACT_32BITS(obj_tptr+20)));\n+                break;\n+\n \t    case LMP_CTYPE_UNMD:\n+                if (obj_tlen != 12) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n+\t\tND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n+\t\t    bittok2str(lmp_obj_te_link_flag_values,\n+\t\t\t\"none\",\n+\t\t\tEXTRACT_8BITS(obj_tptr))));\n+\n+\t\tND_PRINT((ndo, \"\\n\\t    Local Link-ID: %u (0x%08x)\"\n+\t\t       \"\\n\\t    Remote Link-ID: %u (0x%08x)\",\n+                       EXTRACT_32BITS(obj_tptr+4),\n+                       EXTRACT_32BITS(obj_tptr+4),\n+                       EXTRACT_32BITS(obj_tptr+8),\n+                       EXTRACT_32BITS(obj_tptr+8)));\n+\t\tbreak;\n+\n             default:\n                 hexdump=TRUE;\n             }\n             break;\n \n         case LMP_OBJ_DATA_LINK:\n-\t\tND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n-\t\tbittok2str(lmp_obj_data_link_flag_values,\n-\t\t\t\"none\",\n-\t\t\tEXTRACT_16BITS(obj_tptr)>>8)));\n-\n \t    switch(lmp_obj_ctype) {\n \t    case LMP_CTYPE_IPV4:\n-\t    case LMP_CTYPE_UNMD:\n+                if (obj_tlen < 12) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n+\t        ND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n+\t\t    bittok2str(lmp_obj_data_link_flag_values,\n+\t\t\t\"none\",\n+\t\t\tEXTRACT_8BITS(obj_tptr))));\n                 ND_PRINT((ndo, \"\\n\\t    Local Interface ID: %s (0x%08x)\"\n                        \"\\n\\t    Remote Interface ID: %s (0x%08x)\",\n                        ipaddr_string(ndo, obj_tptr+4),\n                        EXTRACT_32BITS(obj_tptr+4),\n                        ipaddr_string(ndo, obj_tptr+8),\n                        EXTRACT_32BITS(obj_tptr+8)));\n \n-\t\ttotal_subobj_len = lmp_obj_len - 16;\n-\t\toffset = 12;\n-\t\twhile (total_subobj_len > 0 && hexdump == FALSE ) {\n-\t\t\tsubobj_type = EXTRACT_16BITS(obj_tptr+offset)>>8;\n-\t\t\tsubobj_len  = EXTRACT_16BITS(obj_tptr+offset)&0x00FF;\n-\t\t\tND_PRINT((ndo, \"\\n\\t    Subobject, Type: %s (%u), Length: %u\",\n-\t\t\t\ttok2str(lmp_data_link_subobj,\n-\t\t\t\t\t\"Unknown\",\n-\t\t\t\t\tsubobj_type),\n-\t\t\t\t\tsubobj_type,\n-\t\t\t\t\tsubobj_len));\n-\t\t\tswitch(subobj_type) {\n-\t\t\tcase INT_SWITCHING_TYPE_SUBOBJ:\n-\t\t\t\tND_PRINT((ndo, \"\\n\\t      Switching Type: %s (%u)\",\n-\t\t\t\t\ttok2str(gmpls_switch_cap_values,\n-\t\t\t\t\t\t\"Unknown\",\n-\t\t\t\t\t\tEXTRACT_16BITS(obj_tptr+offset+2)>>8),\n-\t\t\t\t\tEXTRACT_16BITS(obj_tptr+offset+2)>>8));\n-\t\t\t\tND_PRINT((ndo, \"\\n\\t      Encoding Type: %s (%u)\",\n-\t\t\t\t\ttok2str(gmpls_encoding_values,\n-\t\t\t\t\t\t\"Unknown\",\n-\t\t\t\t\t\tEXTRACT_16BITS(obj_tptr+offset+2)&0x00FF),\n-\t\t\t\t\tEXTRACT_16BITS(obj_tptr+offset+2)&0x00FF));\n-\t\t\t\tbw.i = EXTRACT_32BITS(obj_tptr+offset+4);\n-\t\t\t\tND_PRINT((ndo, \"\\n\\t      Min Reservable Bandwidth: %.3f Mbps\",\n-                                       bw.f*8/1000000));\n-\t\t\t\tbw.i = EXTRACT_32BITS(obj_tptr+offset+8);\n-\t\t\t\tND_PRINT((ndo, \"\\n\\t      Max Reservable Bandwidth: %.3f Mbps\",\n-                                       bw.f*8/1000000));\n-\t\t\t\tbreak;\n-\t\t\tcase WAVELENGTH_SUBOBJ:\n-\t\t\t\tND_PRINT((ndo, \"\\n\\t      Wavelength: %u\",\n-\t\t\t\t\tEXTRACT_32BITS(obj_tptr+offset+4)));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\t/* Any Unknown Subobject ==> Exit loop */\n-\t\t\t\thexdump=TRUE;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\ttotal_subobj_len-=subobj_len;\n-\t\t\toffset+=subobj_len;\n-\t\t}\n-\n+\t\tif (lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 12, 12))\n+\t\t    hexdump=TRUE;\n \t\tbreak;\n+\n \t    case LMP_CTYPE_IPV6:\n+                if (obj_tlen < 36) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n+\t        ND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n+\t\t    bittok2str(lmp_obj_data_link_flag_values,\n+\t\t\t\"none\",\n+\t\t\tEXTRACT_8BITS(obj_tptr))));\n+                ND_PRINT((ndo, \"\\n\\t    Local Interface ID: %s (0x%08x)\"\n+                       \"\\n\\t    Remote Interface ID: %s (0x%08x)\",\n+                       ip6addr_string(ndo, obj_tptr+4),\n+                       EXTRACT_32BITS(obj_tptr+4),\n+                       ip6addr_string(ndo, obj_tptr+20),\n+                       EXTRACT_32BITS(obj_tptr+20)));\n+\n+\t\tif (lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 36, 36))\n+\t\t    hexdump=TRUE;\n+\t\tbreak;\n+\n+\t    case LMP_CTYPE_UNMD:\n+                if (obj_tlen < 12) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n+\t        ND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n+\t\t    bittok2str(lmp_obj_data_link_flag_values,\n+\t\t\t\"none\",\n+\t\t\tEXTRACT_8BITS(obj_tptr))));\n+                ND_PRINT((ndo, \"\\n\\t    Local Interface ID: %u (0x%08x)\"\n+                       \"\\n\\t    Remote Interface ID: %u (0x%08x)\",\n+                       EXTRACT_32BITS(obj_tptr+4),\n+                       EXTRACT_32BITS(obj_tptr+4),\n+                       EXTRACT_32BITS(obj_tptr+8),\n+                       EXTRACT_32BITS(obj_tptr+8)));\n+\n+\t\tif (lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 12, 12))\n+\t\t    hexdump=TRUE;\n+\t\tbreak;\n+\n             default:\n                 hexdump=TRUE;\n             }\n@@ -626,6 +783,10 @@ lmp_print(netdissect_options *ndo,\n         case LMP_OBJ_VERIFY_BEGIN:\n \t    switch(lmp_obj_ctype) {\n             case LMP_CTYPE_1:\n+                if (obj_tlen != 20) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n \t\tND_PRINT((ndo, \"\\n\\t    Flags: %s\",\n \t\tbittok2str(lmp_obj_begin_verify_flag_values,\n \t\t\t\"none\",\n@@ -654,6 +815,10 @@ lmp_print(netdissect_options *ndo,\n         case LMP_OBJ_VERIFY_BEGIN_ACK:\n \t    switch(lmp_obj_ctype) {\n             case LMP_CTYPE_1:\n+                if (obj_tlen != 4) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n                 ND_PRINT((ndo, \"\\n\\t    Verify Dead Interval: %u\"\n                        \"\\n\\t    Verify Transport Response: %u\",\n                        EXTRACT_16BITS(obj_tptr),\n@@ -668,6 +833,10 @@ lmp_print(netdissect_options *ndo,\n \tcase LMP_OBJ_VERIFY_ID:\n \t    switch(lmp_obj_ctype) {\n             case LMP_CTYPE_1:\n+                if (obj_tlen != 4) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n                 ND_PRINT((ndo, \"\\n\\t    Verify ID: %u\",\n                        EXTRACT_32BITS(obj_tptr)));\n                 break;\n@@ -680,19 +849,20 @@ lmp_print(netdissect_options *ndo,\n \tcase LMP_OBJ_CHANNEL_STATUS:\n             switch(lmp_obj_ctype) {\n \t    case LMP_CTYPE_IPV4:\n-\t    case LMP_CTYPE_UNMD:\n \t\toffset = 0;\n \t\t/* Decode pairs: <Interface_ID (4 bytes), Channel_status (4 bytes)> */\n-\t\twhile (offset < (lmp_obj_len-(int)sizeof(struct lmp_object_header)) ) {\n+\t\twhile (offset+8 <= obj_tlen) {\n \t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %s (0x%08x)\",\n \t\t\tipaddr_string(ndo, obj_tptr+offset),\n \t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n \n-\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Active: %s (%u)\", \t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31) ?\n+\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Active: %s (%u)\",\n+\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31) ?\n \t\t\t\t\t\t\"Allocated\" : \"Non-allocated\",\n \t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31)));\n \n-\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Direction: %s (%u)\", (EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1 ?\n+\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Direction: %s (%u)\",\n+\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1 ?\n \t\t\t\t\t\t\"Transmit\" : \"Receive\",\n \t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1));\n \n@@ -704,7 +874,61 @@ lmp_print(netdissect_options *ndo,\n \t\t\toffset+=8;\n \t\t}\n                 break;\n+\n \t    case LMP_CTYPE_IPV6:\n+\t\toffset = 0;\n+\t\t/* Decode pairs: <Interface_ID (16 bytes), Channel_status (4 bytes)> */\n+\t\twhile (offset+20 <= obj_tlen) {\n+\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %s (0x%08x)\",\n+\t\t\tip6addr_string(ndo, obj_tptr+offset),\n+\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n+\n+\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Active: %s (%u)\",\n+\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+16)>>31) ?\n+\t\t\t\t\t\t\"Allocated\" : \"Non-allocated\",\n+\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+16)>>31)));\n+\n+\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Direction: %s (%u)\",\n+\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+16)>>30)&0x1 ?\n+\t\t\t\t\t\t\"Transmit\" : \"Receive\",\n+\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+16)>>30)&0x1));\n+\n+\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Channel Status: %s (%u)\",\n+\t\t\t\t\ttok2str(lmp_obj_channel_status_values,\n+\t\t\t\t\t\"Unknown\",\n+\t\t\t\t\tEXTRACT_32BITS(obj_tptr+offset+16)&0x3FFFFFF),\n+\t\t\tEXTRACT_32BITS(obj_tptr+offset+16)&0x3FFFFFF));\n+\t\t\toffset+=20;\n+\t\t}\n+                break;\n+\n+\t    case LMP_CTYPE_UNMD:\n+\t\toffset = 0;\n+\t\t/* Decode pairs: <Interface_ID (4 bytes), Channel_status (4 bytes)> */\n+\t\twhile (offset+8 <= obj_tlen) {\n+\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %u (0x%08x)\",\n+\t\t\tEXTRACT_32BITS(obj_tptr+offset),\n+\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n+\n+\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Active: %s (%u)\",\n+\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31) ?\n+\t\t\t\t\t\t\"Allocated\" : \"Non-allocated\",\n+\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31)));\n+\n+\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Direction: %s (%u)\",\n+\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1 ?\n+\t\t\t\t\t\t\"Transmit\" : \"Receive\",\n+\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1));\n+\n+\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Channel Status: %s (%u)\",\n+\t\t\t\t\ttok2str(lmp_obj_channel_status_values,\n+\t\t\t\t\t\"Unknown\",\n+\t\t\t\t\tEXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF),\n+\t\t\tEXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF));\n+\t\t\toffset+=8;\n+\t\t}\n+                break;\n+\n             default:\n                 hexdump=TRUE;\n             }\n@@ -713,16 +937,35 @@ lmp_print(netdissect_options *ndo,\n \tcase LMP_OBJ_CHANNEL_STATUS_REQ:\n             switch(lmp_obj_ctype) {\n \t    case LMP_CTYPE_IPV4:\n-\t    case LMP_CTYPE_UNMD:\n \t\toffset = 0;\n-\t\twhile (offset < (lmp_obj_len-(int)sizeof(struct lmp_object_header)) ) {\n+\t\twhile (offset+4 <= obj_tlen) {\n \t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %s (0x%08x)\",\n \t\t\tipaddr_string(ndo, obj_tptr+offset),\n \t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n \t\t\toffset+=4;\n \t\t}\n                 break;\n+\n \t    case LMP_CTYPE_IPV6:\n+\t\toffset = 0;\n+\t\twhile (offset+16 <= obj_tlen) {\n+\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %s (0x%08x)\",\n+\t\t\tip6addr_string(ndo, obj_tptr+offset),\n+\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n+\t\t\toffset+=16;\n+\t\t}\n+                break;\n+\n+\t    case LMP_CTYPE_UNMD:\n+\t\toffset = 0;\n+\t\twhile (offset+4 <= obj_tlen) {\n+\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %u (0x%08x)\",\n+\t\t\tEXTRACT_32BITS(obj_tptr+offset),\n+\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n+\t\t\toffset+=4;\n+\t\t}\n+                break;\n+\n \t    default:\n                 hexdump=TRUE;\n             }\n@@ -731,13 +974,21 @@ lmp_print(netdissect_options *ndo,\n         case LMP_OBJ_ERROR_CODE:\n \t    switch(lmp_obj_ctype) {\n             case LMP_CTYPE_BEGIN_VERIFY_ERROR:\n+                if (obj_tlen != 4) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n \t\tND_PRINT((ndo, \"\\n\\t    Error Code: %s\",\n \t\tbittok2str(lmp_obj_begin_verify_error_values,\n \t\t\t\"none\",\n \t\t\tEXTRACT_32BITS(obj_tptr))));\n                 break;\n \n             case LMP_CTYPE_LINK_SUMMARY_ERROR:\n+                if (obj_tlen != 4) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n \t\tND_PRINT((ndo, \"\\n\\t    Error Code: %s\",\n \t\tbittok2str(lmp_obj_link_summary_error_values,\n \t\t\t\"none\",\n@@ -751,51 +1002,60 @@ lmp_print(netdissect_options *ndo,\n \tcase LMP_OBJ_SERVICE_CONFIG:\n \t    switch (lmp_obj_ctype) {\n \t    case LMP_CTYPE_SERVICE_CONFIG_SP:\n-\n+                if (obj_tlen != 4) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n \t\tND_PRINT((ndo, \"\\n\\t Flags: %s\",\n \t\t       bittok2str(lmp_obj_service_config_sp_flag_values,\n \t\t\t\t  \"none\",\n-\t\t\t\t  EXTRACT_16BITS(obj_tptr)>>8)));\n+\t\t\t\t  EXTRACT_8BITS(obj_tptr))));\n \n \t\tND_PRINT((ndo, \"\\n\\t  UNI Version: %u\",\n-\t\t       EXTRACT_16BITS(obj_tptr) & 0x00FF));\n+\t\t       EXTRACT_8BITS(obj_tptr+1)));\n \n \t\tbreak;\n \n             case LMP_CTYPE_SERVICE_CONFIG_CPSA:\n+                if (obj_tlen != 16) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n \n-\t\tlink_type = EXTRACT_16BITS(obj_tptr)>>8;\n+\t\tlink_type = EXTRACT_8BITS(obj_tptr);\n \n \t\tND_PRINT((ndo, \"\\n\\t Link Type: %s (%u)\",\n \t\t       tok2str(lmp_sd_service_config_cpsa_link_type_values,\n \t\t\t       \"Unknown\", link_type),\n \t\t       link_type));\n \n-\t\tif (link_type == LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH) {\n+\t\tswitch (link_type) {\n+\t\tcase LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH:\n \t\t    ND_PRINT((ndo, \"\\n\\t Signal Type: %s (%u)\",\n \t\t\t   tok2str(lmp_sd_service_config_cpsa_signal_type_sdh_values,\n \t\t\t\t   \"Unknown\",\n-\t\t\t\t   EXTRACT_16BITS(obj_tptr) & 0x00FF),\n-\t\t\t   EXTRACT_16BITS(obj_tptr) & 0x00FF));\n-\t\t}\n+\t\t\t\t   EXTRACT_8BITS(obj_tptr+1)),\n+\t\t\t   EXTRACT_8BITS(obj_tptr+1)));\n+\t\t    break;\n \n-\t\tif (link_type == LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET) {\n+\t\tcase LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET:\n \t\t    ND_PRINT((ndo, \"\\n\\t Signal Type: %s (%u)\",\n \t\t\t   tok2str(lmp_sd_service_config_cpsa_signal_type_sonet_values,\n \t\t\t\t   \"Unknown\",\n-\t\t\t\t   EXTRACT_16BITS(obj_tptr) & 0x00FF),\n-\t\t\t   EXTRACT_16BITS(obj_tptr) & 0x00FF));\n+\t\t\t\t   EXTRACT_8BITS(obj_tptr+1)),\n+\t\t\t   EXTRACT_8BITS(obj_tptr+1)));\n+\t\t    break;\n \t\t}\n \n \t\tND_PRINT((ndo, \"\\n\\t Transparency: %s\",\n \t\t       bittok2str(lmp_obj_service_config_cpsa_tp_flag_values,\n \t\t\t\t  \"none\",\n-\t\t\t\t  EXTRACT_16BITS(obj_tptr+2)>>8)));\n+\t\t\t\t  EXTRACT_8BITS(obj_tptr+2))));\n \n \t\tND_PRINT((ndo, \"\\n\\t Contiguous Concatenation Types: %s\",\n \t\t       bittok2str(lmp_obj_service_config_cpsa_cct_flag_values,\n \t\t\t\t  \"none\",\n-\t\t\t\t  EXTRACT_16BITS(obj_tptr+2)>>8 & 0x00FF)));\n+\t\t\t\t  EXTRACT_8BITS(obj_tptr+3))));\n \n \t\tND_PRINT((ndo, \"\\n\\t Minimum NCC: %u\",\n \t\t       EXTRACT_16BITS(obj_tptr+4)));\n@@ -816,6 +1076,10 @@ lmp_print(netdissect_options *ndo,\n \t\tbreak;\n \n \t    case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM:\n+                if (obj_tlen != 8) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n \n \t\tND_PRINT((ndo, \"\\n\\t Transparency Flags: %s\",\n \t\t       bittok2str(\n@@ -827,17 +1091,21 @@ lmp_print(netdissect_options *ndo,\n \t\t       bittok2str(\n \t\t\t   lmp_obj_service_config_nsa_tcm_flag_values,\n \t\t\t   \"none\",\n-\t\t\t   EXTRACT_16BITS(obj_tptr+6) & 0x00FF)));\n+\t\t\t   EXTRACT_8BITS(obj_tptr+7))));\n \n \t\tbreak;\n \n \t    case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY:\n+                if (obj_tlen != 4) {\n+                    ND_PRINT((ndo, \" (not correct for object)\"));\n+                    break;\n+                }\n \n \t\tND_PRINT((ndo, \"\\n\\t Diversity: Flags: %s\",\n \t\t       bittok2str(\n \t\t\t   lmp_obj_service_config_nsa_network_diversity_flag_values,\n \t\t\t   \"none\",\n-\t\t\t   EXTRACT_16BITS(obj_tptr+2) & 0x00FF)));\n+\t\t\t   EXTRACT_8BITS(obj_tptr+3))));\n \t\tbreak;\n \n \t    default:"
        },
        {
          "filename": "tests/TESTLIST",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -492,6 +492,7 @@ pimv2-oobr-4\t\tpimv2-oobr-4.pcap\t\tpimv2-oobr-4.out\t\t-vvv -e\n 802_15_4-oobr-2\t\t802_15_4-oobr-2.pcap\t\t802_15_4-oobr-2.out\t-vvv -e\n 802_15_4-data\t\t802_15_4-data.pcap\t\t802_15_4-data.out\t-vvv -e\n 802_15_4_beacon\t\t802_15_4_beacon.pcap\t\t802_15_4_beacon.out\t-vvv -e\n+lmpv1_busyloop\t\tlmpv1_busyloop.pcap\t\tlmpv1_busyloop.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap"
        },
        {
          "filename": "tests/lmpv1_busyloop.out",
          "status": "added",
          "additions": 42,
          "deletions": 0,
          "patch": "@@ -0,0 +1,42 @@\n+00:80:ad:91:d8:6f > 00:0b:64:00:10:72, ethertype IPv4 (0x0800), length 725: (tos 0x0, ttl 128, id 35978, offset 0, flags [none], proto UDP (17), length 711)\n+    168.152.32.1.701 > 168.152.32.39.701: [udp sum ok] \n+\tLMPv1, msg-type: Config, Flags: [Control Channel Down], length: 257\n+\t  Data Link Object (12), Class-Type: IPv4 (1) Flags: [non-negotiable], length: 516\n+\t    Flags: [Allocated for user traffic]\n+\t    Local Interface ID: 0.0.2.0 (0x00000200)\n+\t    Remote Interface ID: 2.0.2.0 (0x02000200)\n+\t    Subobject, Type: Wavelength (2), Length: 0 (too short)\n+\t    0x0000:  0253 e10b 0000 0200 0200 0200 0200 0200\n+\t    0x0010:  0200 0200 0200 0200 0200 0200 0200 0200\n+\t    0x0020:  0200 0200 0200 0200 0200 0200 0200 0200\n+\t    0x0030:  0200 0200 0200 0200 0200 0200 0200 0200\n+\t    0x0040:  0200 0280 6d00 0200 0200 0200 0200 0200\n+\t    0x0050:  0200 0200 0200 0200 0200 0200 0200 0200\n+\t    0x0060:  0200 0200 0200 0200 0200 0200 0200 0200\n+\t    0x0070:  0200 0200 0200 0200 0200 0200 0200 8202\n+\t    0x0080:  0002 0002 0002 0002 0002 0002 0002 0002\n+\t    0x0090:  0002 0002 0002 0002 0002 0002 0002 0002\n+\t    0x00a0:  0002 0002 0002 0002 0002 0002 0002 0002\n+\t    0x00b0:  2002 0002 0002 0002 0002 0002 0002 0002\n+\t    0x00c0:  0000 0200 0200 0002 0002 0000 0200 0200\n+\t    0x00d0:  0002 0002 0000 0200 0200 0002 0002 0000\n+\t    0x00e0:  0200 0200 0002 0002 0000 0200 0200 0002\n+\t    0x00f0:  0002 0000 0200 0200 0002 0002 0000 0200\n+\t    0x0100:  0200 0002 0002 0000 0200 0200 0002 0002\n+\t    0x0110:  0000 0200 0200 0002 0002 0000 0200 0200\n+\t    0x0120:  0002 0002 0000 0200 0200 0002 0002 0000\n+\t    0x0130:  0200 0200 0002 0002 0000 0200 0200 0002\n+\t    0x0140:  0002 0000 0200 0200 0002 0002 0000 0200\n+\t    0x0150:  0200 0002 0002 0000 0200 0200 0002 0002\n+\t    0x0160:  0000 0200 0200 0002 0002 0000 0200 0200\n+\t    0x0170:  0002 0002 0000 0200 0200 0002 0002 0000\n+\t    0x0180:  0200 0200 0002 0002 0000 0200 0200 0002\n+\t    0x0190:  0002 0000 0200 0200 0002 0002 0000 0200\n+\t    0x01a0:  0200 0002 0002 0000 0200 0200 0002 0002\n+\t    0x01b0:  0000 0200 0200 0002 0002 0000 0200 0200\n+\t    0x01c0:  0002 0002 0000 0200 0200 0002 0002 0000\n+\t    0x01d0:  0200 0200 0002 0002 0000 0200 0200 0002\n+\t    0x01e0:  0002 0000 0200 0200 0002 0002 0000 0200\n+\t    0x01f0:  0200 0002 0002 0000 0200 0200 0002 0002\n+\t  Unknown Object (0), Class-Type: Unknown (0) Flags: [non-negotiable], length: 512\n+\t\t packet exceeded snapshot"
        },
        {
          "filename": "tests/lmpv1_busyloop.pcap",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "05a263a5418a9e5b971509c486246eb0913c8aea",
            "date": "2025-01-12T21:05:02Z",
            "author_login": "fxlb"
          },
          {
            "sha": "9aee9964aaee40750acde45f838f48eb8f95fbe3",
            "date": "2025-01-09T15:35:53Z",
            "author_login": "fxlb"
          },
          {
            "sha": "6cd500c8dafe5a9bbf3e56312493709e8b118726",
            "date": "2025-01-08T20:12:09Z",
            "author_login": "fxlb"
          },
          {
            "sha": "c5b54bfbd68b03f7997feaa277db30d399975a4d",
            "date": "2022-10-11T20:10:46Z",
            "author_login": "fenner"
          },
          {
            "sha": "431bdb5c365360d61968e7fa02322825b1da4208",
            "date": "2025-01-07T19:21:12Z",
            "author_login": "fxlb"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-125",
    "description": "The LMP parser in tcpdump before 4.9.2 has a buffer over-read in print-lmp.c:lmp_print().",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-09-14T06:29:01.310",
    "last_modified": "2024-11-21T03:10:37.790",
    "fix_date": "2017-02-20T05:13:25Z"
  },
  "references": [
    {
      "url": "http://www.debian.org/security/2017/dsa-3971",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.securitytracker.com/id/1039307",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.tcpdump.org/tcpdump-changes.txt",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHEA-2018:0705",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/the-tcpdump-group/tcpdump/commit/a25211918f2e790c67d859d20ccf8dbb81da1598",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201709-23",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://support.apple.com/HT208221",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2017/dsa-3971",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securitytracker.com/id/1039307",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.tcpdump.org/tcpdump-changes.txt",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHEA-2018:0705",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/the-tcpdump-group/tcpdump/commit/a25211918f2e790c67d859d20ccf8dbb81da1598",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201709-23",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://support.apple.com/HT208221",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:07.365990",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "tcpdump",
    "owner": "the-tcpdump-group",
    "created_at": "2013-04-14T21:46:15Z",
    "updated_at": "2025-01-14T07:48:01Z",
    "pushed_at": "2025-01-13T06:19:33Z",
    "size": 27691,
    "stars": 2789,
    "forks": 860,
    "open_issues": 115,
    "watchers": 2789,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master",
      "tcpdump-3.5",
      "tcpdump-3.6",
      "tcpdump-3.7",
      "tcpdump-3.8",
      "tcpdump-3.9",
      "tcpdump-4.0",
      "tcpdump-4.1",
      "tcpdump-4.2",
      "tcpdump-4.3",
      "tcpdump-4.4",
      "tcpdump-4.5",
      "tcpdump-4.6",
      "tcpdump-4.7",
      "tcpdump-4.8",
      "tcpdump-4.9",
      "tcpdump-4.99"
    ],
    "languages": {
      "C": 3548298,
      "CMake": 76892,
      "Roff": 66849,
      "Shell": 50525,
      "M4": 31504,
      "Perl": 29240,
      "Makefile": 14259,
      "Awk": 4120,
      "GDB": 660
    },
    "commit_activity": {
      "total_commits_last_year": 314,
      "avg_commits_per_week": 6.038461538461538,
      "days_active_last_year": 158
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:04:48.453717"
  }
}