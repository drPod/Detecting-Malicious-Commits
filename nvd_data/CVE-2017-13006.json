{
  "cve_id": "CVE-2017-13006",
  "github_data": {
    "repository": "the-tcpdump-group/tcpdump",
    "fix_commit": "cc4a7391c616be7a64ed65742ef9ed3f106eb165",
    "related_commits": [
      "cc4a7391c616be7a64ed65742ef9ed3f106eb165",
      "cc4a7391c616be7a64ed65742ef9ed3f106eb165"
    ],
    "patch_url": "https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165.patch",
    "fix_commit_details": {
      "sha": "cc4a7391c616be7a64ed65742ef9ed3f106eb165",
      "commit_date": "2017-03-06T03:56:20Z",
      "author": {
        "login": "guyharris",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "CVE-2017-13006/L2TP: Check whether an AVP's content exceeds the AVP length.",
        "length": 395,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 265,
        "additions": 219,
        "deletions": 46
      },
      "files": [
        {
          "filename": "print-l2tp.c",
          "status": "modified",
          "additions": 177,
          "deletions": 46,
          "patch": "@@ -297,10 +297,14 @@ print_32bits_val(netdissect_options *ndo, const uint32_t *dat)\n /* AVP-specific print out routines */\n /***********************************/\n static void\n-l2tp_msgtype_print(netdissect_options *ndo, const u_char *dat)\n+l2tp_msgtype_print(netdissect_options *ndo, const u_char *dat, u_int length)\n {\n \tconst uint16_t *ptr = (const uint16_t *)dat;\n \n+\tif (length < 2) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n \tND_PRINT((ndo, \"%s\", tok2str(l2tp_msgtype2str, \"MSGTYPE-#%u\",\n \t    EXTRACT_16BITS(ptr))));\n }\n@@ -310,28 +314,53 @@ l2tp_result_code_print(netdissect_options *ndo, const u_char *dat, u_int length)\n {\n \tconst uint16_t *ptr = (const uint16_t *)dat;\n \n-\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr))); ptr++;\t/* Result Code */\n-\tif (length > 2) {\t\t\t\t/* Error Code (opt) */\n-\t        ND_PRINT((ndo, \"/%u\", EXTRACT_16BITS(ptr))); ptr++;\n+\t/* Result Code */\n+\tif (length < 2) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n \t}\n-\tif (length > 4) {\t\t\t\t/* Error Message (opt) */\n-\t\tND_PRINT((ndo, \" \"));\n-\t\tprint_string(ndo, (const u_char *)ptr, length - 4);\n+\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr)));\n+\tptr++;\n+\tlength -= 2;\n+\n+\t/* Error Code (opt) */\n+\tif (length == 0)\n+\t\treturn;\n+\tif (length < 2) {\n+\t\tND_PRINT((ndo, \" AVP too short\"));\n+\t\treturn;\n \t}\n+\tND_PRINT((ndo, \"/%u\", EXTRACT_16BITS(ptr)));\n+\tptr++;\n+\tlength -= 2;\n+\n+\t/* Error Message (opt) */\n+\tif (length == 0)\n+\t\treturn;\n+\tND_PRINT((ndo, \" \"));\n+\tprint_string(ndo, (const u_char *)ptr, length);\n }\n \n static void\n-l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)\n+l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat, u_int length)\n {\n+\tif (length < 2) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n \tND_PRINT((ndo, \"%u.%u\", (EXTRACT_16BITS(dat) >> 8),\n \t    (EXTRACT_16BITS(dat) & 0xff)));\n }\n \n static void\n-l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)\n+l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat, u_int length)\n {\n \tconst uint32_t *ptr = (const uint32_t *)dat;\n \n+\tif (length < 4) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n \tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {\n \t\tND_PRINT((ndo, \"A\"));\n \t}\n@@ -341,10 +370,14 @@ l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)\n }\n \n static void\n-l2tp_bearer_cap_print(netdissect_options *ndo, const u_char *dat)\n+l2tp_bearer_cap_print(netdissect_options *ndo, const u_char *dat, u_int length)\n {\n \tconst uint32_t *ptr = (const uint32_t *)dat;\n \n+\tif (length < 4) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n \tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_ANALOG_MASK) {\n \t\tND_PRINT((ndo, \"A\"));\n \t}\n@@ -356,19 +389,29 @@ l2tp_bearer_cap_print(netdissect_options *ndo, const u_char *dat)\n static void\n l2tp_q931_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n {\n+\tif (length < 3) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n \tprint_16bits_val(ndo, (const uint16_t *)dat);\n \tND_PRINT((ndo, \", %02x\", dat[2]));\n-\tif (length > 3) {\n+\tdat += 3;\n+\tlength -= 3;\n+\tif (length != 0) {\n \t\tND_PRINT((ndo, \" \"));\n-\t\tprint_string(ndo, dat+3, length-3);\n+\t\tprint_string(ndo, dat, length);\n \t}\n }\n \n static void\n-l2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat)\n+l2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat, u_int length)\n {\n \tconst uint32_t *ptr = (const uint32_t *)dat;\n \n+\tif (length < 4) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n \tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_ANALOG_MASK) {\n \t\tND_PRINT((ndo, \"A\"));\n \t}\n@@ -378,10 +421,14 @@ l2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat)\n }\n \n static void\n-l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)\n+l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat, u_int length)\n {\n \tconst uint32_t *ptr = (const uint32_t *)dat;\n \n+\tif (length < 4) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n \tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {\n \t\tND_PRINT((ndo, \"A\"));\n \t}\n@@ -397,67 +444,117 @@ l2tp_packet_proc_delay_print(netdissect_options *ndo)\n }\n \n static void\n-l2tp_proxy_auth_type_print(netdissect_options *ndo, const u_char *dat)\n+l2tp_proxy_auth_type_print(netdissect_options *ndo, const u_char *dat, u_int length)\n {\n \tconst uint16_t *ptr = (const uint16_t *)dat;\n \n+\tif (length < 2) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n \tND_PRINT((ndo, \"%s\", tok2str(l2tp_authentype2str,\n \t\t\t     \"AuthType-#%u\", EXTRACT_16BITS(ptr))));\n }\n \n static void\n-l2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat)\n+l2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat, u_int length)\n {\n \tconst uint16_t *ptr = (const uint16_t *)dat;\n \n+\tif (length < 2) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n \tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr) & L2TP_PROXY_AUTH_ID_MASK));\n }\n \n static void\n-l2tp_call_errors_print(netdissect_options *ndo, const u_char *dat)\n+l2tp_call_errors_print(netdissect_options *ndo, const u_char *dat, u_int length)\n {\n \tconst uint16_t *ptr = (const uint16_t *)dat;\n \tuint16_t val_h, val_l;\n \n+\tif (length < 2) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n \tptr++;\t\t/* skip \"Reserved\" */\n+\tlength -= 2;\n \n-\tval_h = EXTRACT_16BITS(ptr); ptr++;\n-\tval_l = EXTRACT_16BITS(ptr); ptr++;\n+\tif (length < 4) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n+\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n+\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n \tND_PRINT((ndo, \"CRCErr=%u \", (val_h<<16) + val_l));\n \n-\tval_h = EXTRACT_16BITS(ptr); ptr++;\n-\tval_l = EXTRACT_16BITS(ptr); ptr++;\n+\tif (length < 4) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n+\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n+\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n \tND_PRINT((ndo, \"FrameErr=%u \", (val_h<<16) + val_l));\n \n-\tval_h = EXTRACT_16BITS(ptr); ptr++;\n-\tval_l = EXTRACT_16BITS(ptr); ptr++;\n+\tif (length < 4) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n+\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n+\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n \tND_PRINT((ndo, \"HardOver=%u \", (val_h<<16) + val_l));\n \n-\tval_h = EXTRACT_16BITS(ptr); ptr++;\n-\tval_l = EXTRACT_16BITS(ptr); ptr++;\n+\tif (length < 4) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n+\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n+\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n \tND_PRINT((ndo, \"BufOver=%u \", (val_h<<16) + val_l));\n \n-\tval_h = EXTRACT_16BITS(ptr); ptr++;\n-\tval_l = EXTRACT_16BITS(ptr); ptr++;\n+\tif (length < 4) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n+\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n+\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n \tND_PRINT((ndo, \"Timeout=%u \", (val_h<<16) + val_l));\n \n+\tif (length < 4) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n \tval_h = EXTRACT_16BITS(ptr); ptr++;\n \tval_l = EXTRACT_16BITS(ptr); ptr++;\n \tND_PRINT((ndo, \"AlignErr=%u \", (val_h<<16) + val_l));\n }\n \n static void\n-l2tp_accm_print(netdissect_options *ndo, const u_char *dat)\n+l2tp_accm_print(netdissect_options *ndo, const u_char *dat, u_int length)\n {\n \tconst uint16_t *ptr = (const uint16_t *)dat;\n \tuint16_t val_h, val_l;\n \n+\tif (length < 2) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n \tptr++;\t\t/* skip \"Reserved\" */\n+\tlength -= 2;\n \n-\tval_h = EXTRACT_16BITS(ptr); ptr++;\n-\tval_l = EXTRACT_16BITS(ptr); ptr++;\n+\tif (length < 4) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n+\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n+\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n \tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n \n+\tif (length < 4) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n \tval_h = EXTRACT_16BITS(ptr); ptr++;\n \tval_l = EXTRACT_16BITS(ptr); ptr++;\n \tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n@@ -468,14 +565,27 @@ l2tp_ppp_discon_cc_print(netdissect_options *ndo, const u_char *dat, u_int lengt\n {\n \tconst uint16_t *ptr = (const uint16_t *)dat;\n \n-\tND_PRINT((ndo, \"%04x, \", EXTRACT_16BITS(ptr))); ptr++;\t/* Disconnect Code */\n-\tND_PRINT((ndo, \"%04x \",  EXTRACT_16BITS(ptr))); ptr++;\t/* Control Protocol Number */\n+\tif (length < 5) {\n+\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\treturn;\n+\t}\n+\t/* Disconnect Code */\n+\tND_PRINT((ndo, \"%04x, \", EXTRACT_16BITS(dat)));\n+\tdat += 2;\n+\tlength -= 2;\n+\t/* Control Protocol Number */\n+\tND_PRINT((ndo, \"%04x \",  EXTRACT_16BITS(dat)));\n+\tdat += 2;\n+\tlength -= 2;\n+\t/* Direction */\n \tND_PRINT((ndo, \"%s\", tok2str(l2tp_cc_direction2str,\n-\t\t\t     \"Direction-#%u\", *((const u_char *)ptr++))));\n+\t\t\t     \"Direction-#%u\", EXTRACT_8BITS(ptr))));\n+\tptr++;\n+\tlength--;\n \n-\tif (length > 5) {\n+\tif (length != 0) {\n \t\tND_PRINT((ndo, \" \"));\n-\t\tprint_string(ndo, (const u_char *)ptr, length-5);\n+\t\tprint_string(ndo, (const u_char *)ptr, length);\n \t}\n }\n \n@@ -508,7 +618,12 @@ l2tp_avp_print(netdissect_options *ndo, const u_char *dat, int length)\n \t/* If it goes past the end of the remaining length of the captured\n \t   data, we'll give up. */\n \tND_TCHECK2(*ptr, len);\n-\t/* After this point, no need to worry about truncation */\n+\n+\t/*\n+\t * After this point, we don't need to check whether we go past\n+\t * the length of the captured data; however, we *do* need to\n+\t * check whether we go past the end of the AVP.\n+\t */\n \n \tif (EXTRACT_16BITS(ptr) & L2TP_AVP_HDR_FLAG_MANDATORY) {\n \t\tND_PRINT((ndo, \"*\"));\n@@ -537,27 +652,35 @@ l2tp_avp_print(netdissect_options *ndo, const u_char *dat, int length)\n \t\t} else {\n \t\t\tswitch (attr_type) {\n \t\t\tcase L2TP_AVP_MSGTYPE:\n-\t\t\t\tl2tp_msgtype_print(ndo, (const u_char *)ptr);\n+\t\t\t\tl2tp_msgtype_print(ndo, (const u_char *)ptr, len-6);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_RESULT_CODE:\n \t\t\t\tl2tp_result_code_print(ndo, (const u_char *)ptr, len-6);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_PROTO_VER:\n-\t\t\t\tl2tp_proto_ver_print(ndo, ptr);\n+\t\t\t\tl2tp_proto_ver_print(ndo, ptr, len-6);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_FRAMING_CAP:\n-\t\t\t\tl2tp_framing_cap_print(ndo, (const u_char *)ptr);\n+\t\t\t\tl2tp_framing_cap_print(ndo, (const u_char *)ptr, len-6);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_BEARER_CAP:\n-\t\t\t\tl2tp_bearer_cap_print(ndo, (const u_char *)ptr);\n+\t\t\t\tl2tp_bearer_cap_print(ndo, (const u_char *)ptr, len-6);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_TIE_BREAKER:\n+\t\t\t\tif (len-6 < 8) {\n+\t\t\t\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tprint_octets(ndo, (const u_char *)ptr, 8);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_FIRM_VER:\n \t\t\tcase L2TP_AVP_ASSND_TUN_ID:\n \t\t\tcase L2TP_AVP_RECV_WIN_SIZE:\n \t\t\tcase L2TP_AVP_ASSND_SESS_ID:\n+\t\t\t\tif (len-6 < 2) {\n+\t\t\t\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tprint_16bits_val(ndo, ptr);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_HOST_NAME:\n@@ -582,6 +705,10 @@ l2tp_avp_print(netdissect_options *ndo, const u_char *dat, int length)\n \t\t\t\tl2tp_q931_cc_print(ndo, (const u_char *)ptr, len-6);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_CHALLENGE_RESP:\n+\t\t\t\tif (len-6 < 16) {\n+\t\t\t\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tprint_octets(ndo, (const u_char *)ptr, 16);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_CALL_SER_NUM:\n@@ -590,28 +717,32 @@ l2tp_avp_print(netdissect_options *ndo, const u_char *dat, int length)\n \t\t\tcase L2TP_AVP_TX_CONN_SPEED:\n \t\t\tcase L2TP_AVP_PHY_CHANNEL_ID:\n \t\t\tcase L2TP_AVP_RX_CONN_SPEED:\n+\t\t\t\tif (len-6 < 4) {\n+\t\t\t\t\tND_PRINT((ndo, \"AVP too short\"));\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tprint_32bits_val(ndo, (const uint32_t *)ptr);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_BEARER_TYPE:\n-\t\t\t\tl2tp_bearer_type_print(ndo, (const u_char *)ptr);\n+\t\t\t\tl2tp_bearer_type_print(ndo, (const u_char *)ptr, len-6);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_FRAMING_TYPE:\n-\t\t\t\tl2tp_framing_type_print(ndo, (const u_char *)ptr);\n+\t\t\t\tl2tp_framing_type_print(ndo, (const u_char *)ptr, len-6);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_PACKET_PROC_DELAY:\n \t\t\t\tl2tp_packet_proc_delay_print(ndo);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_PROXY_AUTH_TYPE:\n-\t\t\t\tl2tp_proxy_auth_type_print(ndo, (const u_char *)ptr);\n+\t\t\t\tl2tp_proxy_auth_type_print(ndo, (const u_char *)ptr, len-6);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_PROXY_AUTH_ID:\n-\t\t\t\tl2tp_proxy_auth_id_print(ndo, (const u_char *)ptr);\n+\t\t\t\tl2tp_proxy_auth_id_print(ndo, (const u_char *)ptr, len-6);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_CALL_ERRORS:\n-\t\t\t\tl2tp_call_errors_print(ndo, (const u_char *)ptr);\n+\t\t\t\tl2tp_call_errors_print(ndo, (const u_char *)ptr, len-6);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_ACCM:\n-\t\t\t\tl2tp_accm_print(ndo, (const u_char *)ptr);\n+\t\t\t\tl2tp_accm_print(ndo, (const u_char *)ptr, len-6);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_SEQ_REQUIRED:\n \t\t\t\tbreak;\t/* No Attribute Value */"
        },
        {
          "filename": "tests/TESTLIST",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -500,6 +500,9 @@ lmpv1_busyloop\t\tlmpv1_busyloop.pcap\t\tlmpv1_busyloop.out\t-vvv -e\n juniper_atm1\t\tjuniper_atm1.pcap\t\tjuniper_atm1.out\t-vvv -e\n juniper_es\t\tjuniper_es.pcap\t\t\tjuniper_es.out\t-vvv -e\n \n+# bad packets from Yannick Formaggio\n+l2tp-avp-overflow\tl2tp-avp-overflow.pcap\t\tl2tp-avp-overflow.out\t-v\n+\n # RTP tests\n # fuzzed pcap\n rtp-seg-fault-1  rtp-seg-fault-1.pcap  rtp-seg-fault-1.out  -v -T rtp"
        },
        {
          "filename": "tests/l2tp-avp-overflow.out",
          "status": "added",
          "additions": 39,
          "deletions": 0,
          "patch": "@@ -0,0 +1,39 @@\n+IP (tos 0x30, ttl 48, id 12331, offset 0, flags [none], proto UDP (17), length 12336, bad cksum 1f51 (->ab7b)!)\n+    127.0.0.229.12416 > 127.0.128.1.1701:  l2tp:[TL](560/2056) AVP-#60963() |...\n+IP (tos 0x30, ttl 48, id 12336, offset 0, flags [none], proto UDP (17), length 12336, bad cksum 1f51 (->2a8b)!)\n+    127.0.0.229.12416 > 127.236.0.1.1701:  l2tp:[TL](560/2056) AVP-#48() |...\n+IP (tos 0x30, ttl 48, id 12331, offset 0, flags [none], proto UDP (17), length 8752, bad cksum 1f51 (->3890)!)\n+    127.0.0.229.32767 > 127.236.0.1.1701:  l2tp:[TL](560/2056) ACCM(AVP too short) |...\n+IP (tos 0x30, ttl 48, id 12336, offset 0, flags [none], proto UDP (17), length 12336, bad cksum 1f51 (->2a8b)!)\n+    127.0.0.229.12416 > 127.236.0.1.1701:  l2tp:[TL](560/2056) ACCM(AVP too short) |...\n+IP (tos 0x30, ttl 48, id 12331, offset 0, flags [none], proto UDP (17), length 12336, bad cksum 1f51 (->2a90)!)\n+    127.0.0.229.12416 > 127.236.0.1.1701:  l2tp:[TL](560/2056) ACCM(AVP too short) |...\n+IP (tos 0x30, ttl 48, id 12336, offset 0, flags [none], proto UDP (17), length 12336, bad cksum 1f51 (->ab5d)!)\n+    127.0.0.0.0 > 0.0.0.0.2048: UDP, bad length 17704 > 12308\n+[|ether]\n+IP (tos 0x30, ttl 48, id 12336, offset 0, flags [none], proto UDP (17), length 12336, bad cksum 1f51 (->2a8b)!)\n+    127.0.0.229.12416 > 127.236.0.1.1701:  l2tp:[TL](560/2056) AVP-#48() |...\n+IP (tos 0x30, ttl 48, id 12331, offset 0, flags [none], proto UDP (17), length 8752, bad cksum 1f51 (->3890)!)\n+    127.0.0.229.12416 > 127.236.0.1.1701:  l2tp:[TL](560/2056) ACCM(AVP too short) |...\n+IP (tos 0x30, ttl 48, id 12336, offset 0, flags [none], proto UDP (17), length 12336, bad cksum 1f51 (->2a8b)!)\n+    127.0.0.229.12416 > 127.236.0.1.1701:  l2tp:[TL](560/2056) ACCM(AVP too short) |...\n+IP (tos 0x30, ttl 48, id 12331, offset 0, flags [none], proto UDP (17), length 12336, bad cksum 1f51 (->2a90)!)\n+    127.0.0.229.12416 > 127.236.0.1.1701:  l2tp:[TL](560/2056) ACCM(AVP too short) |...\n+IP (tos 0x30, ttl 48, id 12336, offset 0, flags [none], proto UDP (17), length 12336, bad cksum 1f51 (->ab5d)!)\n+    127.0.0.0.0 > 0.0.0.0.2048: UDP, bad length 17704 > 12308\n+[|ether]\n+IP (tos 0x30, ttl 48, id 12336, offset 0, flags [none], proto UDP (17), length 12336, bad cksum 1f51 (->2a8b)!)\n+    127.0.0.229.12416 > 127.236.0.1.1701:  l2tp:[TL](560/2056) AVP-#48() |...\n+IP (tos 0x30, ttl 48, id 12331, offset 0, flags [none], proto UDP (17), length 8752, bad cksum 1f51 (->3890)!)\n+    127.0.0.229.12416 > 127.236.0.1.1701:  l2tp:[TL](560/2056) ACCM(AVP too short) |...\n+IP (tos 0x30, ttl 48, id 12336, offset 0, flags [none], proto UDP (17), length 12336, bad cksum 1f51 (->2a8b)!)\n+    127.0.0.229.12416 > 127.236.0.1.1701:  l2tp:[TL](560/2056) ACCM(AVP too short) |...\n+IP (tos 0x30, ttl 48, id 12331, offset 0, flags [none], proto UDP (17), length 12336, bad cksum 1f51 (->2a90)!)\n+    127.0.0.229.12416 > 127.236.0.1.1701:  l2tp:[TL](560/2056) ACCM(AVP too short) |...\n+IP (tos 0x30, ttl 48, id 12336, offset 0, flags [none], proto UDP (17), length 12336, bad cksum 1f51 (->2a8b)!)\n+    127.0.0.229.12416 > 127.236.0.1.1701:  l2tp:[TL](560/2056) AVP-#48() |...\n+IP (tos 0x30, ttl 48, id 12331, offset 0, flags [none], proto UDP (17), length 8752, bad cksum 1f51 (->3890)!)\n+    127.0.0.229.12416 > 127.236.0.1.1701:  l2tp:[TL](560/2056) VENDOR0001:ATTR0023(0530) |...\n+IP (tos 0x30, ttl 48, id 12336, offset 0, flags [none], proto UDP (17), length 12336, bad cksum 1f51 (->2a8b)!)\n+    127.0.0.229.12416 > 127.236.0.1.1701:  l2tp:[TL](560/2056) VENDOR0080:ATTR06a5(19e8) |...\n+EXIT CODE 00000100"
        },
        {
          "filename": "tests/l2tp-avp-overflow.pcap",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "05a263a5418a9e5b971509c486246eb0913c8aea",
            "date": "2025-01-12T21:05:02Z",
            "author_login": "fxlb"
          },
          {
            "sha": "9aee9964aaee40750acde45f838f48eb8f95fbe3",
            "date": "2025-01-09T15:35:53Z",
            "author_login": "fxlb"
          },
          {
            "sha": "6cd500c8dafe5a9bbf3e56312493709e8b118726",
            "date": "2025-01-08T20:12:09Z",
            "author_login": "fxlb"
          },
          {
            "sha": "c5b54bfbd68b03f7997feaa277db30d399975a4d",
            "date": "2022-10-11T20:10:46Z",
            "author_login": "fenner"
          },
          {
            "sha": "431bdb5c365360d61968e7fa02322825b1da4208",
            "date": "2025-01-07T19:21:12Z",
            "author_login": "fxlb"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-125",
    "description": "The L2TP parser in tcpdump before 4.9.2 has a buffer over-read in print-l2tp.c, several functions.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-09-14T06:29:01.513",
    "last_modified": "2024-11-21T03:10:38.257",
    "fix_date": "2017-03-06T03:56:20Z"
  },
  "references": [
    {
      "url": "http://www.debian.org/security/2017/dsa-3971",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.securitytracker.com/id/1039307",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.tcpdump.org/tcpdump-changes.txt",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHEA-2018:0705",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201709-23",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://support.apple.com/HT208221",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.debian.org/security/2017/dsa-3971",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securitytracker.com/id/1039307",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.tcpdump.org/tcpdump-changes.txt",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHEA-2018:0705",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201709-23",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://support.apple.com/HT208221",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:07.366499",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "tcpdump",
    "owner": "the-tcpdump-group",
    "created_at": "2013-04-14T21:46:15Z",
    "updated_at": "2025-01-14T07:48:01Z",
    "pushed_at": "2025-01-13T06:19:33Z",
    "size": 27691,
    "stars": 2789,
    "forks": 860,
    "open_issues": 115,
    "watchers": 2789,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master",
      "tcpdump-3.5",
      "tcpdump-3.6",
      "tcpdump-3.7",
      "tcpdump-3.8",
      "tcpdump-3.9",
      "tcpdump-4.0",
      "tcpdump-4.1",
      "tcpdump-4.2",
      "tcpdump-4.3",
      "tcpdump-4.4",
      "tcpdump-4.5",
      "tcpdump-4.6",
      "tcpdump-4.7",
      "tcpdump-4.8",
      "tcpdump-4.9",
      "tcpdump-4.99"
    ],
    "languages": {
      "C": 3548298,
      "CMake": 76892,
      "Roff": 66849,
      "Shell": 50525,
      "M4": 31504,
      "Perl": 29240,
      "Makefile": 14259,
      "Awk": 4120,
      "GDB": 660
    },
    "commit_activity": {
      "total_commits_last_year": 314,
      "avg_commits_per_week": 6.038461538461538,
      "days_active_last_year": 158
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:04:48.453717"
  }
}