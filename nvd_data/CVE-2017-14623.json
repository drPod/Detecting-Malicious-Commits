{
  "cve_id": "CVE-2017-14623",
  "github_data": {
    "repository": "go-ldap/ldap",
    "fix_commit": "95ede1266b237bf8e9aa5dce0b3250e51bfefe66",
    "related_commits": [
      "95ede1266b237bf8e9aa5dce0b3250e51bfefe66",
      "95ede1266b237bf8e9aa5dce0b3250e51bfefe66"
    ],
    "patch_url": "https://github.com/go-ldap/ldap/commit/95ede1266b237bf8e9aa5dce0b3250e51bfefe66.patch",
    "fix_commit_details": {
      "sha": "95ede1266b237bf8e9aa5dce0b3250e51bfefe66",
      "commit_date": "2017-08-24T17:36:02Z",
      "author": {
        "login": "johnweldon",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #126 from tiziano88/check_empty_password",
        "length": 107,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 146,
        "additions": 70,
        "deletions": 76
      },
      "files": [
        {
          "filename": "bind.go",
          "status": "modified",
          "additions": 37,
          "deletions": 43,
          "patch": "@@ -7,7 +7,7 @@ package ldap\n import (\n \t\"errors\"\n \n-\t\"gopkg.in/asn1-ber.v1\"\n+\tber \"gopkg.in/asn1-ber.v1\"\n )\n \n // SimpleBindRequest represents a username/password bind operation\n@@ -18,6 +18,9 @@ type SimpleBindRequest struct {\n \tPassword string\n \t// Controls are optional controls to send with the bind request\n \tControls []Control\n+\t// AllowEmptyPassword sets whether the client allows binding with an empty password\n+\t// (normally used for unauthenticated bind).\n+\tAllowEmptyPassword bool\n }\n \n // SimpleBindResult contains the response from the server\n@@ -28,9 +31,10 @@ type SimpleBindResult struct {\n // NewSimpleBindRequest returns a bind request\n func NewSimpleBindRequest(username string, password string, controls []Control) *SimpleBindRequest {\n \treturn &SimpleBindRequest{\n-\t\tUsername: username,\n-\t\tPassword: password,\n-\t\tControls: controls,\n+\t\tUsername:           username,\n+\t\tPassword:           password,\n+\t\tControls:           controls,\n+\t\tAllowEmptyPassword: false,\n \t}\n }\n \n@@ -47,6 +51,10 @@ func (bindRequest *SimpleBindRequest) encode() *ber.Packet {\n \n // SimpleBind performs the simple bind operation defined in the given request\n func (l *Conn) SimpleBind(simpleBindRequest *SimpleBindRequest) (*SimpleBindResult, error) {\n+\tif simpleBindRequest.Password == \"\" && !simpleBindRequest.AllowEmptyPassword {\n+\t\treturn nil, NewError(ErrorEmptyPassword, errors.New(\"ldap: empty password not allowed by the client\"))\n+\t}\n+\n \tpacket := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, \"LDAP Request\")\n \tpacket.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagInteger, l.nextMessageID(), \"MessageID\"))\n \tencodedBindRequest := simpleBindRequest.encode()\n@@ -97,47 +105,33 @@ func (l *Conn) SimpleBind(simpleBindRequest *SimpleBindRequest) (*SimpleBindResu\n \treturn result, nil\n }\n \n-// Bind performs a bind with the given username and password\n+// Bind performs a bind with the given username and password.\n+//\n+// It does not allow unauthenticated bind (i.e. empty password). Use the UnauthenticatedBind method\n+// for that.\n func (l *Conn) Bind(username, password string) error {\n-\tpacket := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, \"LDAP Request\")\n-\tpacket.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagInteger, l.nextMessageID(), \"MessageID\"))\n-\tbindRequest := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ApplicationBindRequest, nil, \"Bind Request\")\n-\tbindRequest.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagInteger, 3, \"Version\"))\n-\tbindRequest.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, username, \"User Name\"))\n-\tbindRequest.AppendChild(ber.NewString(ber.ClassContext, ber.TypePrimitive, 0, password, \"Password\"))\n-\tpacket.AppendChild(bindRequest)\n-\n-\tif l.Debug {\n-\t\tber.PrintPacket(packet)\n-\t}\n-\n-\tmsgCtx, err := l.sendMessage(packet)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tdefer l.finishMessage(msgCtx)\n-\n-\tpacketResponse, ok := <-msgCtx.responses\n-\tif !ok {\n-\t\treturn NewError(ErrorNetwork, errors.New(\"ldap: response channel closed\"))\n-\t}\n-\tpacket, err = packetResponse.ReadPacket()\n-\tl.Debug.Printf(\"%d: got response %p\", msgCtx.id, packet)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tif l.Debug {\n-\t\tif err := addLDAPDescriptions(packet); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tber.PrintPacket(packet)\n+\treq := &SimpleBindRequest{\n+\t\tUsername:           username,\n+\t\tPassword:           password,\n+\t\tAllowEmptyPassword: false,\n \t}\n+\t_, err := l.SimpleBind(req)\n+\treturn err\n+}\n \n-\tresultCode, resultDescription := getLDAPResultCode(packet)\n-\tif resultCode != 0 {\n-\t\treturn NewError(resultCode, errors.New(resultDescription))\n+// UnauthenticatedBind performs an unauthenticated bind.\n+//\n+// A username may be provided for trace (e.g. logging) purpose only, but it is normally not\n+// authenticated or otherwise validated by the LDAP server.\n+//\n+// See https://tools.ietf.org/html/rfc4513#section-5.1.2 .\n+// See https://tools.ietf.org/html/rfc4513#section-6.3.1 .\n+func (l *Conn) UnauthenticatedBind(username string) error {\n+\treq := &SimpleBindRequest{\n+\t\tUsername:           username,\n+\t\tPassword:           \"\",\n+\t\tAllowEmptyPassword: true,\n \t}\n-\n-\treturn nil\n+\t_, err := l.SimpleBind(req)\n+\treturn err\n }"
        },
        {
          "filename": "error.go",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -54,6 +54,7 @@ const (\n \tErrorDebugging          = 203\n \tErrorUnexpectedMessage  = 204\n \tErrorUnexpectedResponse = 205\n+\tErrorEmptyPassword      = 206\n )\n \n // LDAPResultCodeMap contains string descriptions for LDAP error codes\n@@ -104,6 +105,7 @@ var LDAPResultCodeMap = map[uint8]string{\n \tErrorDebugging:          \"Debugging Error\",\n \tErrorUnexpectedMessage:  \"Unexpected Message\",\n \tErrorUnexpectedResponse: \"Unexpected Response\",\n+\tErrorEmptyPassword:      \"Empty password not allowed by the client\",\n }\n \n func getLDAPResultCode(packet *ber.Packet) (code uint8, description string) {"
        },
        {
          "filename": "ldap_test.go",
          "status": "modified",
          "additions": 31,
          "deletions": 33,
          "patch": "@@ -1,11 +1,9 @@\n-package ldap_test\n+package ldap\n \n import (\n \t\"crypto/tls\"\n \t\"fmt\"\n \t\"testing\"\n-\n-\t\"gopkg.in/ldap.v2\"\n )\n \n var ldapServer = \"ldap.itd.umich.edu\"\n@@ -23,7 +21,7 @@ var attributes = []string{\n \n func TestDial(t *testing.T) {\n \tfmt.Printf(\"TestDial: starting...\\n\")\n-\tl, err := ldap.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n+\tl, err := Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n \tif err != nil {\n \t\tt.Errorf(err.Error())\n \t\treturn\n@@ -34,7 +32,7 @@ func TestDial(t *testing.T) {\n \n func TestDialTLS(t *testing.T) {\n \tfmt.Printf(\"TestDialTLS: starting...\\n\")\n-\tl, err := ldap.DialTLS(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapTLSPort), &tls.Config{InsecureSkipVerify: true})\n+\tl, err := DialTLS(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapTLSPort), &tls.Config{InsecureSkipVerify: true})\n \tif err != nil {\n \t\tt.Errorf(err.Error())\n \t\treturn\n@@ -45,7 +43,7 @@ func TestDialTLS(t *testing.T) {\n \n func TestStartTLS(t *testing.T) {\n \tfmt.Printf(\"TestStartTLS: starting...\\n\")\n-\tl, err := ldap.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n+\tl, err := Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n \tif err != nil {\n \t\tt.Errorf(err.Error())\n \t\treturn\n@@ -60,16 +58,16 @@ func TestStartTLS(t *testing.T) {\n \n func TestSearch(t *testing.T) {\n \tfmt.Printf(\"TestSearch: starting...\\n\")\n-\tl, err := ldap.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n+\tl, err := Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n \tif err != nil {\n \t\tt.Errorf(err.Error())\n \t\treturn\n \t}\n \tdefer l.Close()\n \n-\tsearchRequest := ldap.NewSearchRequest(\n+\tsearchRequest := NewSearchRequest(\n \t\tbaseDN,\n-\t\tldap.ScopeWholeSubtree, ldap.DerefAlways, 0, 0, false,\n+\t\tScopeWholeSubtree, DerefAlways, 0, 0, false,\n \t\tfilter[0],\n \t\tattributes,\n \t\tnil)\n@@ -85,16 +83,16 @@ func TestSearch(t *testing.T) {\n \n func TestSearchStartTLS(t *testing.T) {\n \tfmt.Printf(\"TestSearchStartTLS: starting...\\n\")\n-\tl, err := ldap.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n+\tl, err := Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n \tif err != nil {\n \t\tt.Errorf(err.Error())\n \t\treturn\n \t}\n \tdefer l.Close()\n \n-\tsearchRequest := ldap.NewSearchRequest(\n+\tsearchRequest := NewSearchRequest(\n \t\tbaseDN,\n-\t\tldap.ScopeWholeSubtree, ldap.DerefAlways, 0, 0, false,\n+\t\tScopeWholeSubtree, DerefAlways, 0, 0, false,\n \t\tfilter[0],\n \t\tattributes,\n \t\tnil)\n@@ -125,22 +123,22 @@ func TestSearchStartTLS(t *testing.T) {\n \n func TestSearchWithPaging(t *testing.T) {\n \tfmt.Printf(\"TestSearchWithPaging: starting...\\n\")\n-\tl, err := ldap.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n+\tl, err := Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n \tif err != nil {\n \t\tt.Errorf(err.Error())\n \t\treturn\n \t}\n \tdefer l.Close()\n \n-\terr = l.Bind(\"\", \"\")\n+\terr = l.UnauthenticatedBind(\"\")\n \tif err != nil {\n \t\tt.Errorf(err.Error())\n \t\treturn\n \t}\n \n-\tsearchRequest := ldap.NewSearchRequest(\n+\tsearchRequest := NewSearchRequest(\n \t\tbaseDN,\n-\t\tldap.ScopeWholeSubtree, ldap.DerefAlways, 0, 0, false,\n+\t\tScopeWholeSubtree, DerefAlways, 0, 0, false,\n \t\tfilter[2],\n \t\tattributes,\n \t\tnil)\n@@ -152,12 +150,12 @@ func TestSearchWithPaging(t *testing.T) {\n \n \tfmt.Printf(\"TestSearchWithPaging: %s -> num of entries = %d\\n\", searchRequest.Filter, len(sr.Entries))\n \n-\tsearchRequest = ldap.NewSearchRequest(\n+\tsearchRequest = NewSearchRequest(\n \t\tbaseDN,\n-\t\tldap.ScopeWholeSubtree, ldap.DerefAlways, 0, 0, false,\n+\t\tScopeWholeSubtree, DerefAlways, 0, 0, false,\n \t\tfilter[2],\n \t\tattributes,\n-\t\t[]ldap.Control{ldap.NewControlPaging(5)})\n+\t\t[]Control{NewControlPaging(5)})\n \tsr, err = l.SearchWithPaging(searchRequest, 5)\n \tif err != nil {\n \t\tt.Errorf(err.Error())\n@@ -166,23 +164,23 @@ func TestSearchWithPaging(t *testing.T) {\n \n \tfmt.Printf(\"TestSearchWithPaging: %s -> num of entries = %d\\n\", searchRequest.Filter, len(sr.Entries))\n \n-\tsearchRequest = ldap.NewSearchRequest(\n+\tsearchRequest = NewSearchRequest(\n \t\tbaseDN,\n-\t\tldap.ScopeWholeSubtree, ldap.DerefAlways, 0, 0, false,\n+\t\tScopeWholeSubtree, DerefAlways, 0, 0, false,\n \t\tfilter[2],\n \t\tattributes,\n-\t\t[]ldap.Control{ldap.NewControlPaging(500)})\n+\t\t[]Control{NewControlPaging(500)})\n \tsr, err = l.SearchWithPaging(searchRequest, 5)\n \tif err == nil {\n \t\tt.Errorf(\"expected an error when paging size in control in search request doesn't match size given in call, got none\")\n \t\treturn\n \t}\n }\n \n-func searchGoroutine(t *testing.T, l *ldap.Conn, results chan *ldap.SearchResult, i int) {\n-\tsearchRequest := ldap.NewSearchRequest(\n+func searchGoroutine(t *testing.T, l *Conn, results chan *SearchResult, i int) {\n+\tsearchRequest := NewSearchRequest(\n \t\tbaseDN,\n-\t\tldap.ScopeWholeSubtree, ldap.DerefAlways, 0, 0, false,\n+\t\tScopeWholeSubtree, DerefAlways, 0, 0, false,\n \t\tfilter[i],\n \t\tattributes,\n \t\tnil)\n@@ -197,17 +195,17 @@ func searchGoroutine(t *testing.T, l *ldap.Conn, results chan *ldap.SearchResult\n \n func testMultiGoroutineSearch(t *testing.T, TLS bool, startTLS bool) {\n \tfmt.Printf(\"TestMultiGoroutineSearch: starting...\\n\")\n-\tvar l *ldap.Conn\n+\tvar l *Conn\n \tvar err error\n \tif TLS {\n-\t\tl, err = ldap.DialTLS(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapTLSPort), &tls.Config{InsecureSkipVerify: true})\n+\t\tl, err = DialTLS(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapTLSPort), &tls.Config{InsecureSkipVerify: true})\n \t\tif err != nil {\n \t\t\tt.Errorf(err.Error())\n \t\t\treturn\n \t\t}\n \t\tdefer l.Close()\n \t} else {\n-\t\tl, err = ldap.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n+\t\tl, err = Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n \t\tif err != nil {\n \t\t\tt.Errorf(err.Error())\n \t\t\treturn\n@@ -223,9 +221,9 @@ func testMultiGoroutineSearch(t *testing.T, TLS bool, startTLS bool) {\n \t\t}\n \t}\n \n-\tresults := make([]chan *ldap.SearchResult, len(filter))\n+\tresults := make([]chan *SearchResult, len(filter))\n \tfor i := range filter {\n-\t\tresults[i] = make(chan *ldap.SearchResult)\n+\t\tresults[i] = make(chan *SearchResult)\n \t\tgo searchGoroutine(t, l, results[i], i)\n \t}\n \tfor i := range filter {\n@@ -245,17 +243,17 @@ func TestMultiGoroutineSearch(t *testing.T) {\n }\n \n func TestEscapeFilter(t *testing.T) {\n-\tif got, want := ldap.EscapeFilter(\"a\\x00b(c)d*e\\\\f\"), `a\\00b\\28c\\29d\\2ae\\5cf`; got != want {\n+\tif got, want := EscapeFilter(\"a\\x00b(c)d*e\\\\f\"), `a\\00b\\28c\\29d\\2ae\\5cf`; got != want {\n \t\tt.Errorf(\"Got %s, expected %s\", want, got)\n \t}\n-\tif got, want := ldap.EscapeFilter(\"Lu\u010di\u0107\"), `Lu\\c4\\8di\\c4\\87`; got != want {\n+\tif got, want := EscapeFilter(\"Lu\u010di\u0107\"), `Lu\\c4\\8di\\c4\\87`; got != want {\n \t\tt.Errorf(\"Got %s, expected %s\", want, got)\n \t}\n }\n \n func TestCompare(t *testing.T) {\n \tfmt.Printf(\"TestCompare: starting...\\n\")\n-\tl, err := ldap.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n+\tl, err := Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", ldapServer, ldapPort))\n \tif err != nil {\n \t\tt.Fatal(err.Error())\n \t}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "5d1b644709dfd57fd319e688a87932e15244722d",
            "date": "2025-01-10T13:10:57Z",
            "author_login": "rtpt-erikgeiser"
          },
          {
            "sha": "aebc65e39b4db0f1ed22d7add9f7bee1e5b351aa",
            "date": "2024-12-26T22:07:07Z",
            "author_login": "johnweldon"
          },
          {
            "sha": "dc5f57d120a5f5ea26f9dd94437a9c838a2b32bf",
            "date": "2024-12-26T19:14:11Z",
            "author_login": "johnweldon"
          },
          {
            "sha": "f71ace8fc5717a3bb398255cfbde501d444b1830",
            "date": "2024-12-16T12:27:13Z",
            "author_login": "ilyam8"
          },
          {
            "sha": "5f6693ace8f09eedf5906a2ab6401b6355955d18",
            "date": "2024-12-14T23:16:28Z",
            "author_login": "cpuschma"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-287",
    "description": "In the ldap.v2 (aka go-ldap) package through 2.5.0 for Go, an attacker may be able to login with an empty password. This issue affects an application using this package if these conditions are met: (1) it relies only on the return error of the Bind function call to determine whether a user is authorized (i.e., a nil return value is interpreted as successful authorization) and (2) it is used with an LDAP server allowing unauthenticated bind.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2017-09-20T23:29:00.247",
    "last_modified": "2024-11-21T03:13:13.603",
    "fix_date": "2017-08-24T17:36:02Z"
  },
  "references": [
    {
      "url": "https://github.com/go-ldap/ldap/commit/95ede1266b237bf8e9aa5dce0b3250e51bfefe66",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/go-ldap/ldap/pull/126",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    },
    {
      "url": "https://github.com/go-ldap/ldap/commit/95ede1266b237bf8e9aa5dce0b3250e51bfefe66",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/go-ldap/ldap/pull/126",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:07.389624",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "ldap",
    "owner": "go-ldap",
    "created_at": "2014-10-16T00:33:17Z",
    "updated_at": "2025-01-14T13:22:06Z",
    "pushed_at": "2025-01-10T13:10:57Z",
    "size": 534,
    "stars": 2271,
    "forks": 363,
    "open_issues": 69,
    "watchers": 2271,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Go": 301696,
      "Makefile": 1992,
      "Shell": 136
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T17:59:03.887857"
  }
}