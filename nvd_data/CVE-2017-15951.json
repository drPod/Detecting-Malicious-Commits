{
  "cve_id": "CVE-2017-15951",
  "github_data": {
    "repository": "torvalds/linux",
    "fix_commit": "363b02dab09b3226f3bd1420dad9c72b79a42a76",
    "related_commits": [
      "363b02dab09b3226f3bd1420dad9c72b79a42a76",
      "363b02dab09b3226f3bd1420dad9c72b79a42a76"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "363b02dab09b3226f3bd1420dad9c72b79a42a76",
      "commit_date": "2017-10-04T15:43:25Z",
      "author": {
        "login": "dhowells",
        "type": "User",
        "stats": {
          "total_commits": 3553,
          "average_weekly_commits": 2.9832073887489505,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 621
        }
      },
      "commit_message": {
        "title": "KEYS: Fix race between updating and finding a negative key",
        "length": 1931,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 137,
        "additions": 80,
        "deletions": 57
      },
      "files": [
        {
          "filename": "include/linux/key.h",
          "status": "modified",
          "additions": 30,
          "deletions": 17,
          "patch": "@@ -138,6 +138,11 @@ struct key_restriction {\n \tstruct key_type *keytype;\n };\n \n+enum key_state {\n+\tKEY_IS_UNINSTANTIATED,\n+\tKEY_IS_POSITIVE,\t\t/* Positively instantiated */\n+};\n+\n /*****************************************************************************/\n /*\n  * authentication token / access credential / keyring\n@@ -169,25 +174,24 @@ struct key {\n \t\t\t\t\t\t * - may not match RCU dereferenced payload\n \t\t\t\t\t\t * - payload should contain own length\n \t\t\t\t\t\t */\n+\tshort\t\t\tstate;\t\t/* Key state (+) or rejection error (-) */\n \n #ifdef KEY_DEBUGGING\n \tunsigned\t\tmagic;\n #define KEY_DEBUG_MAGIC\t\t0x18273645u\n #endif\n \n \tunsigned long\t\tflags;\t\t/* status flags (change with bitops) */\n-#define KEY_FLAG_INSTANTIATED\t0\t/* set if key has been instantiated */\n-#define KEY_FLAG_DEAD\t\t1\t/* set if key type has been deleted */\n-#define KEY_FLAG_REVOKED\t2\t/* set if key had been revoked */\n-#define KEY_FLAG_IN_QUOTA\t3\t/* set if key consumes quota */\n-#define KEY_FLAG_USER_CONSTRUCT\t4\t/* set if key is being constructed in userspace */\n-#define KEY_FLAG_NEGATIVE\t5\t/* set if key is negative */\n-#define KEY_FLAG_ROOT_CAN_CLEAR\t6\t/* set if key can be cleared by root without permission */\n-#define KEY_FLAG_INVALIDATED\t7\t/* set if key has been invalidated */\n-#define KEY_FLAG_BUILTIN\t8\t/* set if key is built in to the kernel */\n-#define KEY_FLAG_ROOT_CAN_INVAL\t9\t/* set if key can be invalidated by root without permission */\n-#define KEY_FLAG_KEEP\t\t10\t/* set if key should not be removed */\n-#define KEY_FLAG_UID_KEYRING\t11\t/* set if key is a user or user session keyring */\n+#define KEY_FLAG_DEAD\t\t0\t/* set if key type has been deleted */\n+#define KEY_FLAG_REVOKED\t1\t/* set if key had been revoked */\n+#define KEY_FLAG_IN_QUOTA\t2\t/* set if key consumes quota */\n+#define KEY_FLAG_USER_CONSTRUCT\t3\t/* set if key is being constructed in userspace */\n+#define KEY_FLAG_ROOT_CAN_CLEAR\t4\t/* set if key can be cleared by root without permission */\n+#define KEY_FLAG_INVALIDATED\t5\t/* set if key has been invalidated */\n+#define KEY_FLAG_BUILTIN\t6\t/* set if key is built in to the kernel */\n+#define KEY_FLAG_ROOT_CAN_INVAL\t7\t/* set if key can be invalidated by root without permission */\n+#define KEY_FLAG_KEEP\t\t8\t/* set if key should not be removed */\n+#define KEY_FLAG_UID_KEYRING\t9\t/* set if key is a user or user session keyring */\n \n \t/* the key type and key description string\n \t * - the desc is used to match a key against search criteria\n@@ -213,7 +217,6 @@ struct key {\n \t\t\tstruct list_head name_link;\n \t\t\tstruct assoc_array keys;\n \t\t};\n-\t\tint reject_error;\n \t};\n \n \t/* This is set on a keyring to restrict the addition of a link to a key\n@@ -353,17 +356,27 @@ extern void key_set_timeout(struct key *, unsigned);\n #define\tKEY_NEED_SETATTR 0x20\t/* Require permission to change attributes */\n #define\tKEY_NEED_ALL\t0x3f\t/* All the above permissions */\n \n+static inline short key_read_state(const struct key *key)\n+{\n+\t/* Barrier versus mark_key_instantiated(). */\n+\treturn smp_load_acquire(&key->state);\n+}\n+\n /**\n- * key_is_instantiated - Determine if a key has been positively instantiated\n+ * key_is_positive - Determine if a key has been positively instantiated\n  * @key: The key to check.\n  *\n  * Return true if the specified key has been positively instantiated, false\n  * otherwise.\n  */\n-static inline bool key_is_instantiated(const struct key *key)\n+static inline bool key_is_positive(const struct key *key)\n+{\n+\treturn key_read_state(key) == KEY_IS_POSITIVE;\n+}\n+\n+static inline bool key_is_negative(const struct key *key)\n {\n-\treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n-\t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);\n+\treturn key_read_state(key) < 0;\n }\n \n #define dereference_key_rcu(KEY)\t\t\t\t\t\\"
        },
        {
          "filename": "net/dns_resolver/dns_key.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -224,7 +224,7 @@ static int dns_resolver_match_preparse(struct key_match_data *match_data)\n static void dns_resolver_describe(const struct key *key, struct seq_file *m)\n {\n \tseq_puts(m, key->description);\n-\tif (key_is_instantiated(key)) {\n+\tif (key_is_positive(key)) {\n \t\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n \n \t\tif (err)"
        },
        {
          "filename": "security/keys/big_key.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -247,7 +247,7 @@ void big_key_revoke(struct key *key)\n \n \t/* clear the quota */\n \tkey_payload_reserve(key, 0);\n-\tif (key_is_instantiated(key) &&\n+\tif (key_is_positive(key) &&\n \t    (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)\n \t\tvfs_truncate(path, 0);\n }\n@@ -279,7 +279,7 @@ void big_key_describe(const struct key *key, struct seq_file *m)\n \n \tseq_puts(m, key->description);\n \n-\tif (key_is_instantiated(key))\n+\tif (key_is_positive(key))\n \t\tseq_printf(m, \": %zu [%s]\",\n \t\t\t   datalen,\n \t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");"
        },
        {
          "filename": "security/keys/encrypted-keys/encrypted.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -854,7 +854,7 @@ static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n-\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\tif (key_is_negative(key))\n \t\treturn -ENOKEY;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;"
        },
        {
          "filename": "security/keys/gc.c",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -129,15 +129,15 @@ static noinline void key_gc_unused_keys(struct list_head *keys)\n \twhile (!list_empty(keys)) {\n \t\tstruct key *key =\n \t\t\tlist_entry(keys->next, struct key, graveyard_link);\n+\t\tshort state = key->state;\n+\n \t\tlist_del(&key->graveyard_link);\n \n \t\tkdebug(\"- %u\", key->serial);\n \t\tkey_check(key);\n \n \t\t/* Throw away the key data if the key is instantiated */\n-\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n-\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n-\t\t    key->type->destroy)\n+\t\tif (state == KEY_IS_POSITIVE && key->type->destroy)\n \t\t\tkey->type->destroy(key);\n \n \t\tsecurity_key_free(key);\n@@ -151,7 +151,7 @@ static noinline void key_gc_unused_keys(struct list_head *keys)\n \t\t}\n \n \t\tatomic_dec(&key->user->nkeys);\n-\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n+\t\tif (state != KEY_IS_UNINSTANTIATED)\n \t\t\tatomic_dec(&key->user->nikeys);\n \n \t\tkey_user_put(key->user);"
        },
        {
          "filename": "security/keys/key.c",
          "status": "modified",
          "additions": 20,
          "deletions": 11,
          "patch": "@@ -401,6 +401,18 @@ int key_payload_reserve(struct key *key, size_t datalen)\n }\n EXPORT_SYMBOL(key_payload_reserve);\n \n+/*\n+ * Change the key state to being instantiated.\n+ */\n+static void mark_key_instantiated(struct key *key, int reject_error)\n+{\n+\t/* Commit the payload before setting the state; barrier versus\n+\t * key_read_state().\n+\t */\n+\tsmp_store_release(&key->state,\n+\t\t\t  (reject_error < 0) ? reject_error : KEY_IS_POSITIVE);\n+}\n+\n /*\n  * Instantiate a key and link it into the target keyring atomically.  Must be\n  * called with the target keyring's semaphore writelocked.  The target key's\n@@ -424,14 +436,14 @@ static int __key_instantiate_and_link(struct key *key,\n \tmutex_lock(&key_construction_mutex);\n \n \t/* can't instantiate twice */\n-\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n+\tif (key->state == KEY_IS_UNINSTANTIATED) {\n \t\t/* instantiate the key */\n \t\tret = key->type->instantiate(key, prep);\n \n \t\tif (ret == 0) {\n \t\t\t/* mark the key as being instantiated */\n \t\t\tatomic_inc(&key->user->nikeys);\n-\t\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n+\t\t\tmark_key_instantiated(key, 0);\n \n \t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n \t\t\t\tawaken = 1;\n@@ -577,13 +589,10 @@ int key_reject_and_link(struct key *key,\n \tmutex_lock(&key_construction_mutex);\n \n \t/* can't instantiate twice */\n-\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n+\tif (key->state == KEY_IS_UNINSTANTIATED) {\n \t\t/* mark the key as being negatively instantiated */\n \t\tatomic_inc(&key->user->nikeys);\n-\t\tkey->reject_error = -error;\n-\t\tsmp_wmb();\n-\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n-\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n+\t\tmark_key_instantiated(key, -error);\n \t\tnow = current_kernel_time();\n \t\tkey->expiry = now.tv_sec + timeout;\n \t\tkey_schedule_gc(key->expiry + key_gc_delay);\n@@ -752,8 +761,8 @@ static inline key_ref_t __key_update(key_ref_t key_ref,\n \n \tret = key->type->update(key, prep);\n \tif (ret == 0)\n-\t\t/* updating a negative key instantiates it */\n-\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n+\t\t/* Updating a negative key positively instantiates it */\n+\t\tmark_key_instantiated(key, 0);\n \n \tup_write(&key->sem);\n \n@@ -986,8 +995,8 @@ int key_update(key_ref_t key_ref, const void *payload, size_t plen)\n \n \tret = key->type->update(key, &prep);\n \tif (ret == 0)\n-\t\t/* updating a negative key instantiates it */\n-\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n+\t\t/* Updating a negative key positively instantiates it */\n+\t\tmark_key_instantiated(key, 0);\n \n \tup_write(&key->sem);\n "
        },
        {
          "filename": "security/keys/keyctl.c",
          "status": "modified",
          "additions": 4,
          "deletions": 5,
          "patch": "@@ -766,10 +766,9 @@ long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n \n \tkey = key_ref_to_ptr(key_ref);\n \n-\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n-\t\tret = -ENOKEY;\n-\t\tgoto error2;\n-\t}\n+\tret = key_read_state(key);\n+\tif (ret < 0)\n+\t\tgoto error2; /* Negatively instantiated */\n \n \t/* see if we can read it directly */\n \tret = key_permission(key_ref, KEY_NEED_READ);\n@@ -901,7 +900,7 @@ long keyctl_chown_key(key_serial_t id, uid_t user, gid_t group)\n \t\tatomic_dec(&key->user->nkeys);\n \t\tatomic_inc(&newowner->nkeys);\n \n-\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n+\t\tif (key->state != KEY_IS_UNINSTANTIATED) {\n \t\t\tatomic_dec(&key->user->nikeys);\n \t\t\tatomic_inc(&newowner->nikeys);\n \t\t}"
        },
        {
          "filename": "security/keys/keyring.c",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -414,7 +414,7 @@ static void keyring_describe(const struct key *keyring, struct seq_file *m)\n \telse\n \t\tseq_puts(m, \"[anon]\");\n \n-\tif (key_is_instantiated(keyring)) {\n+\tif (key_is_positive(keyring)) {\n \t\tif (keyring->keys.nr_leaves_on_tree != 0)\n \t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n \t\telse\n@@ -553,7 +553,8 @@ static int keyring_search_iterator(const void *object, void *iterator_data)\n {\n \tstruct keyring_search_context *ctx = iterator_data;\n \tconst struct key *key = keyring_ptr_to_key(object);\n-\tunsigned long kflags = key->flags;\n+\tunsigned long kflags = READ_ONCE(key->flags);\n+\tshort state = READ_ONCE(key->state);\n \n \tkenter(\"{%d}\", key->serial);\n \n@@ -597,9 +598,8 @@ static int keyring_search_iterator(const void *object, void *iterator_data)\n \n \tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n \t\t/* we set a different error code if we pass a negative key */\n-\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\n-\t\t\tsmp_rmb();\n-\t\t\tctx->result = ERR_PTR(key->reject_error);\n+\t\tif (state < 0) {\n+\t\t\tctx->result = ERR_PTR(state);\n \t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n \t\t\tgoto skipped;\n \t\t}"
        },
        {
          "filename": "security/keys/proc.c",
          "status": "modified",
          "additions": 5,
          "deletions": 2,
          "patch": "@@ -182,6 +182,7 @@ static int proc_keys_show(struct seq_file *m, void *v)\n \tunsigned long timo;\n \tkey_ref_t key_ref, skey_ref;\n \tchar xbuf[16];\n+\tshort state;\n \tint rc;\n \n \tstruct keyring_search_context ctx = {\n@@ -236,17 +237,19 @@ static int proc_keys_show(struct seq_file *m, void *v)\n \t\t\tsprintf(xbuf, \"%luw\", timo / (60*60*24*7));\n \t}\n \n+\tstate = key_read_state(key);\n+\n #define showflag(KEY, LETTER, FLAG) \\\n \t(test_bit(FLAG,\t&(KEY)->flags) ? LETTER : '-')\n \n \tseq_printf(m, \"%08x %c%c%c%c%c%c%c %5d %4s %08x %5d %5d %-9.9s \",\n \t\t   key->serial,\n-\t\t   showflag(key, 'I', KEY_FLAG_INSTANTIATED),\n+\t\t   state != KEY_IS_UNINSTANTIATED ? 'I' : '-',\n \t\t   showflag(key, 'R', KEY_FLAG_REVOKED),\n \t\t   showflag(key, 'D', KEY_FLAG_DEAD),\n \t\t   showflag(key, 'Q', KEY_FLAG_IN_QUOTA),\n \t\t   showflag(key, 'U', KEY_FLAG_USER_CONSTRUCT),\n-\t\t   showflag(key, 'N', KEY_FLAG_NEGATIVE),\n+\t\t   state < 0 ? 'N' : '-',\n \t\t   showflag(key, 'i', KEY_FLAG_INVALIDATED),\n \t\t   refcount_read(&key->usage),\n \t\t   xbuf,"
        },
        {
          "filename": "security/keys/process_keys.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -730,7 +730,7 @@ key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n \n \tret = -EIO;\n \tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n-\t    !test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n+\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n \t\tgoto invalid_key;\n \n \t/* check the permissions */"
        },
        {
          "filename": "security/keys/request_key.c",
          "status": "modified",
          "additions": 3,
          "deletions": 4,
          "patch": "@@ -595,10 +595,9 @@ int wait_for_key_construction(struct key *key, bool intr)\n \t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n \tif (ret)\n \t\treturn -ERESTARTSYS;\n-\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n-\t\tsmp_rmb();\n-\t\treturn key->reject_error;\n-\t}\n+\tret = key_read_state(key);\n+\tif (ret < 0)\n+\t\treturn ret;\n \treturn key_validate(key);\n }\n EXPORT_SYMBOL(wait_for_key_construction);"
        },
        {
          "filename": "security/keys/request_key_auth.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -73,7 +73,7 @@ static void request_key_auth_describe(const struct key *key,\n \n \tseq_puts(m, \"key:\");\n \tseq_puts(m, key->description);\n-\tif (key_is_instantiated(key))\n+\tif (key_is_positive(key))\n \t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n }\n "
        },
        {
          "filename": "security/keys/trusted.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1066,7 +1066,7 @@ static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n \tchar *datablob;\n \tint ret = 0;\n \n-\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\tif (key_is_negative(key))\n \t\treturn -ENOKEY;\n \tp = key->payload.data[0];\n \tif (!p->migratable)"
        },
        {
          "filename": "security/keys/user_defined.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -114,7 +114,7 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n \t/* attach the new data, displacing the old */\n \tkey->expiry = prep->expiry;\n-\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\tif (key_is_positive(key))\n \t\tzap = dereference_key_locked(key);\n \trcu_assign_keypointer(key, prep->payload.data[0]);\n \tprep->payload.data[0] = NULL;\n@@ -162,7 +162,7 @@ EXPORT_SYMBOL_GPL(user_destroy);\n void user_describe(const struct key *key, struct seq_file *m)\n {\n \tseq_puts(m, key->description);\n-\tif (key_is_instantiated(key))\n+\tif (key_is_positive(key))\n \t\tseq_printf(m, \": %u\", key->datalen);\n }\n "
        }
      ],
      "file_patterns": {
        "security_files": 14,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "aa22f4da2a46b484a257d167c67a2adc1b7aaf68",
            "date": "2025-01-26T00:23:38Z",
            "author_login": "torvalds"
          },
          {
            "sha": "eda061cccd146fcbe71051bb4aa5a8672b71216e",
            "date": "2025-01-26T00:19:10Z",
            "author_login": "torvalds"
          },
          {
            "sha": "08de7f9d4d39fd9aa5e747a13acc891214fa2d5f",
            "date": "2025-01-26T00:12:07Z",
            "author_login": "torvalds"
          },
          {
            "sha": "647d69605c70368d54fc012fce8a43e8e5955b04",
            "date": "2025-01-26T00:03:40Z",
            "author_login": "torvalds"
          },
          {
            "sha": "184a0997fb77f4a9527fc867fcd16806776c27ce",
            "date": "2025-01-25T23:59:46Z",
            "author_login": "torvalds"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.8,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-20",
    "description": "The KEYS subsystem in the Linux kernel before 4.13.10 does not correctly synchronize the actions of updating versus finding a key in the \"negative\" state to avoid a race condition, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2017-10-28T02:29:00.217",
    "last_modified": "2024-11-21T03:15:31.400",
    "fix_date": "2017-10-04T15:43:25Z"
  },
  "references": [
    {
      "url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=363b02dab09b3226f3bd1420dad9c72b79a42a76",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.13.10",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/101621",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=363b02dab09b3226f3bd1420dad9c72b79a42a76",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.13.10",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/101621",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:09.720326",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "linux",
    "owner": "torvalds",
    "created_at": "2011-09-04T22:48:12Z",
    "updated_at": "2025-01-26T06:54:23Z",
    "pushed_at": "2025-01-26T01:00:03Z",
    "size": 5386838,
    "stars": 186472,
    "forks": 54875,
    "open_issues": 441,
    "watchers": 186472,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1331921668,
      "Assembly": 9611819,
      "Shell": 5108035,
      "Python": 2992085,
      "Makefile": 2706967,
      "Perl": 1253833,
      "Rust": 816450,
      "Roff": 202277,
      "C++": 173994,
      "SmPL": 165946,
      "Yacc": 127472,
      "Lex": 71397,
      "Awk": 69555,
      "Jinja": 30138,
      "UnrealScript": 16848,
      "Gherkin": 10902,
      "M4": 3329,
      "MATLAB": 2482,
      "Clojure": 2442,
      "sed": 2433,
      "XS": 1239,
      "RPC": 962
    },
    "commit_activity": {
      "total_commits_last_year": 48379,
      "avg_commits_per_week": 930.3653846153846,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T07:34:00.817711"
  }
}