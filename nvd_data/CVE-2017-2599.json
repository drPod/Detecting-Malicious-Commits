{
  "cve_id": "CVE-2017-2599",
  "github_data": {
    "repository": "jenkinsci/jenkins",
    "fix_commit": "4ed5c850b6855ab064a66d02fb338f366853ce89",
    "related_commits": [
      "4ed5c850b6855ab064a66d02fb338f366853ce89",
      "4ed5c850b6855ab064a66d02fb338f366853ce89"
    ],
    "patch_url": "https://github.com/jenkinsci/jenkins/commit/4ed5c850b6855ab064a66d02fb338f366853ce89.patch",
    "fix_commit_details": {
      "sha": "4ed5c850b6855ab064a66d02fb338f366853ce89",
      "commit_date": "2017-01-04T15:01:53Z",
      "author": {
        "login": "jglick",
        "type": "User",
        "stats": {
          "total_commits": 3950,
          "average_weekly_commits": 5.077120822622108,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 479
        }
      },
      "commit_message": {
        "title": "Merge pull request #90 from jenkinsci-cert/SECURITY-321",
        "length": 150,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 506,
        "additions": 440,
        "deletions": 66
      },
      "files": [
        {
          "filename": "core/src/main/java/hudson/model/AbstractItem.java",
          "status": "modified",
          "additions": 4,
          "deletions": 23,
          "patch": "@@ -45,7 +45,6 @@\n import jenkins.model.DirectlyModifiableTopLevelItemGroup;\n import jenkins.model.Jenkins;\n import jenkins.security.NotReallyRoleSensitiveCallable;\n-import org.acegisecurity.Authentication;\n import jenkins.util.xml.XMLUtils;\n \n import org.apache.tools.ant.taskdefs.Copy;\n@@ -76,7 +75,6 @@\n import org.xml.sax.SAXException;\n \n import javax.servlet.ServletException;\n-import javax.servlet.ServletOutputStream;\n import javax.xml.transform.Source;\n import javax.xml.transform.TransformerException;\n import javax.xml.transform.stream.StreamResult;\n@@ -236,27 +234,10 @@ protected void renameTo(final String newName) throws IOException {\n                 if (this.name.equals(newName))\n                     return;\n \n-                // the test to see if the project already exists or not needs to be done in escalated privilege\n-                // to avoid overwriting\n-                ACL.impersonate(ACL.SYSTEM,new NotReallyRoleSensitiveCallable<Void,IOException>() {\n-                    final Authentication user = Jenkins.getAuthentication();\n-                    @Override\n-                    public Void call() throws IOException {\n-                        Item existing = parent.getItem(newName);\n-                        if (existing != null && existing!=AbstractItem.this) {\n-                            if (existing.getACL().hasPermission(user,Item.DISCOVER))\n-                                // the look up is case insensitive, so we need \"existing!=this\"\n-                                // to allow people to rename \"Foo\" to \"foo\", for example.\n-                                // see http://www.nabble.com/error-on-renaming-project-tt18061629.html\n-                                throw new IllegalArgumentException(\"Job \" + newName + \" already exists\");\n-                            else {\n-                                // can't think of any real way to hide this, but at least the error message could be vague.\n-                                throw new IOException(\"Unable to rename to \" + newName);\n-                            }\n-                        }\n-                        return null;\n-                    }\n-                });\n+                // the lookup is case insensitive, so we should not fail if this item was the \u201cexisting\u201d one\n+                // to allow people to rename \"Foo\" to \"foo\", for example.\n+                // see http://www.nabble.com/error-on-renaming-project-tt18061629.html\n+                Items.verifyItemDoesNotAlreadyExist(parent, newName, this);\n \n                 File oldRoot = this.getRootDir();\n "
        },
        {
          "filename": "core/src/main/java/hudson/model/ItemGroupMixIn.java",
          "status": "modified",
          "additions": 2,
          "deletions": 7,
          "patch": "@@ -262,10 +262,7 @@ public synchronized TopLevelItem createProjectFromXML(String name, InputStream x\n         acl.checkPermission(Item.CREATE);\n \n         Jenkins.getInstance().getProjectNamingStrategy().checkName(name);\n-        if (parent.getItem(name) != null) {\n-            throw new IllegalArgumentException(parent.getDisplayName() + \" already contains an item '\" + name + \"'\");\n-        }\n-        // TODO what if we have no DISCOVER permission on the existing job?\n+        Items.verifyItemDoesNotAlreadyExist(parent, name, null);\n \n         // place it as config.xml\n         File configXml = Items.getConfigFile(getRootDirFor(name)).getFile();\n@@ -318,9 +315,7 @@ public synchronized TopLevelItem createProject( TopLevelItemDescriptor type, Str\n         acl.getACL().checkCreatePermission(parent, type);\n \n         Jenkins.getInstance().getProjectNamingStrategy().checkName(name);\n-        if(parent.getItem(name)!=null)\n-            throw new IllegalArgumentException(\"Project of the name \"+name+\" already exists\");\n-        // TODO problem with DISCOVER as noted above\n+        Items.verifyItemDoesNotAlreadyExist(parent, name, null);\n \n         TopLevelItem item = type.newInstance(parent, name);\n         try {"
        },
        {
          "filename": "core/src/main/java/hudson/model/Items.java",
          "status": "modified",
          "additions": 30,
          "deletions": 3,
          "patch": "@@ -52,6 +52,8 @@\n import javax.annotation.Nonnull;\n \n import jenkins.model.DirectlyModifiableTopLevelItemGroup;\n+import org.acegisecurity.context.SecurityContext;\n+import org.acegisecurity.context.SecurityContextHolder;\n import org.apache.commons.io.FileUtils;\n \n /**\n@@ -419,9 +421,7 @@ public static <I extends AbstractItem & TopLevelItem> I move(I item, DirectlyMod\n             throw new IllegalArgumentException();\n         }\n         String name = item.getName();\n-        if (destination.getItem(name) != null) {\n-            throw new IllegalArgumentException(name + \" already exists\");\n-        }\n+        verifyItemDoesNotAlreadyExist(destination, name, null);\n         String oldFullName = item.getFullName();\n         // TODO AbstractItem.renameTo has a more baroque implementation; factor it out into a utility method perhaps?\n         File destDir = destination.getRootDirFor(item);\n@@ -434,6 +434,33 @@ public static <I extends AbstractItem & TopLevelItem> I move(I item, DirectlyMod\n         return newItem;\n     }\n \n+    /**\n+     * Securely check for the existence of an item before trying to create one with the same name.\n+     * @param parent the folder where we are about to create/rename/move an item\n+     * @param newName the proposed new name\n+     * @param variant if not null, an existing item which we accept could be there\n+     * @throws IllegalArgumentException if there is already something there, which you were supposed to know about\n+     * @throws Failure if there is already something there but you should not be told details\n+     */\n+    static void verifyItemDoesNotAlreadyExist(@Nonnull ItemGroup<?> parent, @Nonnull String newName, @CheckForNull Item variant) throws IllegalArgumentException, Failure {\n+        Item existing;\n+        SecurityContext orig = ACL.impersonate(ACL.SYSTEM);\n+        try {\n+            existing = parent.getItem(newName);\n+        } finally {\n+            SecurityContextHolder.setContext(orig);\n+        }\n+        if (existing != null && existing != variant) {\n+            if (existing.hasPermission(Item.DISCOVER)) {\n+                String prefix = parent.getFullName();\n+                throw new IllegalArgumentException((prefix.isEmpty() ? \"\" : prefix + \"/\") + newName + \" already exists\");\n+            } else {\n+                // Cannot hide its existence, so at least be as vague as possible.\n+                throw new Failure(\"\");\n+            }\n+        }\n+    }\n+\n     /**\n      * Used to load/save job configuration.\n      *"
        },
        {
          "filename": "test/src/test/groovy/hudson/model/AbstractProjectTest.groovy",
          "status": "modified",
          "additions": 0,
          "deletions": 33,
          "patch": "@@ -525,39 +525,6 @@ public class AbstractProjectTest extends HudsonTestCase {\n         done.signal()\n     }\n \n-    public void testRenameToPrivileged() {\n-        def secret = jenkins.createProject(FreeStyleProject.class,\"secret\");\n-        def regular = jenkins.createProject(FreeStyleProject.class,\"regular\")\n-\n-        jenkins.securityRealm = createDummySecurityRealm();\n-        def auth = new ProjectMatrixAuthorizationStrategy();\n-        jenkins.authorizationStrategy = auth;\n-\n-        auth.add(Jenkins.ADMINISTER, \"alice\");\n-        auth.add(Jenkins.READ, \"bob\");\n-\n-        // bob the regular user can only see regular jobs\n-        regular.addProperty(new AuthorizationMatrixProperty([(Job.READ) : [\"bob\"] as Set]));\n-\n-        def wc = createWebClient()\n-        wc.login(\"bob\")\n-        wc.executeOnServer {\n-            assert jenkins.getItem(\"secret\")==null;\n-            try {\n-                regular.renameTo(\"secret\")\n-                fail(\"rename as an overwrite should have failed\");\n-            } catch (Exception e) {\n-                // expected rename to fail in some non-descriptive generic way\n-                e.printStackTrace()\n-            }\n-        }\n-\n-        // those two jobs should still be there\n-        assert jenkins.getItem(\"regular\")!=null;\n-        assert jenkins.getItem(\"secret\")!=null;\n-    }\n-\n-\n     /**\n      * Trying to POST to config.xml by a different job type should fail.\n      */"
        },
        {
          "filename": "test/src/test/java/hudson/model/ItemsTest.java",
          "status": "modified",
          "additions": 404,
          "deletions": 0,
          "patch": "@@ -24,8 +24,37 @@\n \n package hudson.model;\n \n+import com.gargoylesoftware.htmlunit.FailingHttpStatusCodeException;\n+import com.gargoylesoftware.htmlunit.HttpMethod;\n+import com.gargoylesoftware.htmlunit.WebRequest;\n+import com.gargoylesoftware.htmlunit.WebResponse;\n+import hudson.AbortException;\n+import hudson.cli.CLICommand;\n+import hudson.cli.CLICommandInvoker;\n+import hudson.cli.CopyJobCommand;\n+import hudson.cli.CreateJobCommand;\n+import hudson.security.ACL;\n+import hudson.security.AuthorizationStrategy;\n+import hudson.security.Permission;\n+import hudson.security.SidACL;\n+import hudson.security.csrf.CrumbIssuer;\n+import java.io.ByteArrayInputStream;\n import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import jenkins.model.Jenkins;\n+import org.acegisecurity.acls.sid.Sid;\n+import org.acegisecurity.context.SecurityContext;\n+import org.acegisecurity.context.SecurityContextHolder;\n+import org.apache.commons.httpclient.HttpStatus;\n \n import org.junit.Test;\n import static org.junit.Assert.*;\n@@ -73,5 +102,380 @@ public class ItemsTest {\n         assertFalse(new File(tmp, \"foo/test/1\").exists());\n         assertTrue(new File(tmp, \"bar/test/1\").exists());\n     }\n+    \n+    // TODO would be more efficient to run these all as a single test case, but after a few Jetty seems to stop serving new content and new requests just hang.\n+\n+    private void overwriteTargetSetUp() throws Exception {\n+        // A fully visible item:\n+        r.createFreeStyleProject(\"visible\").setDescription(\"visible\");\n+        // An item known to exist but not visible:\n+        r.createFreeStyleProject(\"known\").setDescription(\"known\");\n+        // An item not even known to exist:\n+        r.createFreeStyleProject(\"secret\").setDescription(\"secret\");\n+        // A folder from which to launch move attacks:\n+        r.createFolder(\"d\");\n+        r.jenkins.setSecurityRealm(r.createDummySecurityRealm());\n+        r.jenkins.setAuthorizationStrategy(new MockAuthorizationStrategy().\n+            grant(Jenkins.READ).everywhere().to(\"attacker\").\n+            grant(Item.READ, Item.CONFIGURE, Item.CREATE, Item.DELETE).onPaths(\"(?!known|secret).*\").to(\"attacker\").\n+            grant(Item.DISCOVER).onPaths(\"known\").to(\"attacker\"));\n+    }\n+\n+    /** Control cases: if there is no such item yet, nothing is stopping you. */\n+    @Test public void overwriteNonexistentTarget() throws Exception {\n+        overwriteTargetSetUp();\n+        for (OverwriteTactic tactic : OverwriteTactic.values()) {\n+            tactic.run(r, \"nonexistent\");\n+            System.out.println(tactic + \" worked as expected on a nonexistent target\");\n+            r.jenkins.getItem(\"nonexistent\").delete();\n+        }\n+    }\n+\n+    private void cannotOverwrite(String target) throws Exception {\n+        overwriteTargetSetUp();\n+        for (OverwriteTactic tactic : OverwriteTactic.values()) {\n+            try {\n+                tactic.run(r, target);\n+                fail(tactic + \" was not supposed to work against \" + target);\n+            } catch (Exception x) {\n+                System.out.println(\"good, \" + tactic + \" failed on \" + target + \": \" + x);\n+                assertEquals(tactic + \" still overwrote \" + target, target, r.jenkins.getItemByFullName(target, FreeStyleProject.class).getDescription());\n+            }\n+        }\n+    }\n+\n+    /** More control cases: for non-security-sensitive scenarios, we prevent you from overwriting existing items. */\n+    @Test public void overwriteVisibleTarget() throws Exception {\n+        cannotOverwrite(\"visible\");\n+    }\n+\n+    /** You may not overwrite an item you know is there even if you cannot see it. */\n+    @Test public void overwriteKnownTarget() throws Exception {\n+        cannotOverwrite(\"known\");\n+    }\n+\n+    /** You are somehow prevented from overwriting an item even if you did not previously know it was there. */\n+    @Issue(\"SECURITY-321\")\n+    @Test public void overwriteHiddenTarget() throws Exception {\n+        cannotOverwrite(\"secret\");\n+    }\n+\n+    /** All known means of creating an item under a new name. */\n+    private enum OverwriteTactic {\n+        /** Use the REST command to create an empty project (normally used only from the UI in the New Item dialog). */\n+        REST_EMPTY {\n+            @Override void run(JenkinsRule r, String target) throws Exception {\n+                JenkinsRule.WebClient wc = wc(r);\n+                wc.getOptions().setRedirectEnabled(false);\n+                wc.getOptions().setThrowExceptionOnFailingStatusCode(false); // redirect perversely counts as a failure\n+                WebResponse webResponse = wc.getPage(new WebRequest(createCrumbedUrl(r, wc, \"createItem?name=\" + target + \"&mode=hudson.model.FreeStyleProject\"), HttpMethod.POST)).getWebResponse();\n+                if (webResponse.getStatusCode() != HttpStatus.SC_MOVED_TEMPORARILY) {\n+                    throw new FailingHttpStatusCodeException(webResponse);\n+                }\n+            }\n+        },\n+        /** Use the REST command to copy an existing project (normally used from the UI in the New Item dialog). */\n+        REST_COPY {\n+            @Override void run(JenkinsRule r, String target) throws Exception {\n+                r.createFreeStyleProject(\"dupe\");\n+                JenkinsRule.WebClient wc = wc(r);\n+                wc.getOptions().setRedirectEnabled(false);\n+                wc.getOptions().setThrowExceptionOnFailingStatusCode(false);\n+                WebResponse webResponse = wc.getPage(new WebRequest(createCrumbedUrl(r, wc, \"createItem?name=\" + target + \"&mode=copy&from=dupe\"), HttpMethod.POST)).getWebResponse();\n+                r.jenkins.getItem(\"dupe\").delete();\n+                if (webResponse.getStatusCode() != HttpStatus.SC_MOVED_TEMPORARILY) {\n+                    throw new FailingHttpStatusCodeException(webResponse);\n+                }\n+            }\n+        },\n+        /** Overwrite target using REST command to create a project from XML submission. */\n+        REST_CREATE {\n+            @Override void run(JenkinsRule r, String target) throws Exception {\n+                JenkinsRule.WebClient wc = wc(r);\n+                WebRequest req = new WebRequest(createCrumbedUrl(r, wc, \"createItem?name=\" + target), HttpMethod.POST);\n+                req.setAdditionalHeader(\"Content-Type\", \"application/xml\");\n+                req.setRequestBody(\"<project/>\");\n+                wc.getPage(req);\n+            }\n+        },\n+        /** Overwrite target using REST command to rename an existing project (normally used from the UI in the Configure screen). */\n+        REST_RENAME {\n+            @Override void run(JenkinsRule r, String target) throws Exception {\n+                r.createFreeStyleProject(\"dupe\");\n+                JenkinsRule.WebClient wc = wc(r);\n+                wc.getOptions().setRedirectEnabled(false);\n+                wc.getOptions().setThrowExceptionOnFailingStatusCode(false);\n+                WebResponse webResponse = wc.getPage(new WebRequest(createCrumbedUrl(r, wc, \"job/dupe/doRename?newName=\" + target), HttpMethod.POST)).getWebResponse();\n+                if (webResponse.getStatusCode() != HttpStatus.SC_MOVED_TEMPORARILY) {\n+                    r.jenkins.getItem(\"dupe\").delete();\n+                    throw new FailingHttpStatusCodeException(webResponse);\n+                }\n+                assertNull(r.jenkins.getItem(\"dupe\"));\n+            }\n+        },\n+        /** Overwrite target using the CLI {@code create-job} command. */\n+        CLI_CREATE {\n+            @Override void run(JenkinsRule r, String target) throws Exception {\n+                CLICommand cmd = new CreateJobCommand();\n+                CLICommandInvoker invoker = new CLICommandInvoker(r, cmd);\n+                cmd.setTransportAuth(User.get(\"attacker\").impersonate());\n+                int status = invoker.withStdin(new ByteArrayInputStream(\"<project/>\".getBytes(\"US-ASCII\"))).invokeWithArgs(target).returnCode();\n+                if (status != 0) {\n+                    throw new AbortException(\"CLI command failed with status \" + status);\n+                }\n+            }\n+        },\n+        /** Overwrite target using the CLI {@code copy-job} command. */\n+        CLI_COPY {\n+            @Override void run(JenkinsRule r, String target) throws Exception {\n+                r.createFreeStyleProject(\"dupe\");\n+                CLICommand cmd = new CopyJobCommand();\n+                CLICommandInvoker invoker = new CLICommandInvoker(r, cmd);\n+                cmd.setTransportAuth(User.get(\"attacker\").impersonate());\n+                int status = invoker.invokeWithArgs(\"dupe\", target).returnCode();\n+                r.jenkins.getItem(\"dupe\").delete();\n+                if (status != 0) {\n+                    throw new AbortException(\"CLI command failed with status \" + status);\n+                }\n+            }\n+        },\n+        /** Overwrite target using a move function normally called from {@code cloudbees-folder} via a {@code move} action. */\n+        MOVE {\n+            @Override void run(JenkinsRule r, String target) throws Exception {\n+                try {\n+                    SecurityContext orig = ACL.impersonate(User.get(\"attacker\").impersonate());\n+                    try {\n+                        Items.move(r.jenkins.getItemByFullName(\"d\", MockFolder.class).createProject(FreeStyleProject.class, target), r.jenkins);\n+                    } finally {\n+                        SecurityContextHolder.setContext(orig);\n+                    }\n+                    assertNull(r.jenkins.getItemByFullName(\"d/\" + target));\n+                } catch (Exception x) {\n+                    r.jenkins.getItemByFullName(\"d/\" + target).delete();\n+                    throw x;\n+                }\n+            }\n+        };\n+        abstract void run(JenkinsRule r, String target) throws Exception;\n+        private static final JenkinsRule.WebClient wc(JenkinsRule r) throws Exception {\n+            return r.createWebClient().login(\"attacker\");\n+        }\n+        // TODO replace with standard version once it is fixed to detect an existing query string\n+        private static URL createCrumbedUrl(JenkinsRule r, JenkinsRule.WebClient wc, String relativePath) throws IOException {\n+            CrumbIssuer issuer = r.jenkins.getCrumbIssuer();\n+            String crumbName = issuer.getDescriptor().getCrumbRequestField();\n+            String crumb = issuer.getCrumb(null);\n+            return new URL(wc.getContextPath() + relativePath + (relativePath.contains(\"?\") ? \"&\" : \"?\") + crumbName + \"=\" + crumb);\n+        }\n+    }\n+\n+    // TODO delete in 1.651+ and use standard version\n+    /**\n+     * An authorization strategy configured in a fluent style from test code.\n+     * Install using {@link Jenkins#setAuthorizationStrategy}.\n+     * You probably also want to call {@link Jenkins#setSecurityRealm} on {@link JenkinsRule#createDummySecurityRealm}.\n+     */\n+    private static class MockAuthorizationStrategy extends AuthorizationStrategy {\n+\n+        private final List<Grant.GrantOn.GrantOnTo> grantsOnTo = new ArrayList<Grant.GrantOn.GrantOnTo>();\n+\n+        /** Creates a new strategy granting no permissions. */\n+        public MockAuthorizationStrategy() {}\n+\n+        /**\n+         * Begin granting a set of permissions.\n+         * Note that grants cannot be subsequently revoked, but you could reset the strategy to a newly configured one.\n+         * @param permissions which permissions to grant ({@link Permission#impliedBy} is honored)\n+         */\n+        public Grant grant(Permission... permissions) {\n+            Set<Permission> effective = new HashSet<Permission>(Arrays.asList(permissions));\n+            boolean added = true;\n+            while (added) {\n+                added = false;\n+                for (Permission p : Permission.getAll()) {\n+                    added |= effective.contains(p.impliedBy) && effective.add(p);\n+                }\n+            }\n+            return new Grant(effective);\n+        }\n+\n+        /**\n+         * Like {@link #grant} but does <em>not</em> honor {@link Permission#impliedBy}.\n+         */\n+        public Grant grantWithoutImplication(Permission... permissions) {\n+            return new Grant(new HashSet<Permission>(Arrays.asList(permissions)));\n+        }\n+\n+        /**\n+         * A grant of a set of permissions.\n+         * You must proceed to specify where they should be granted.\n+         */\n+        public class Grant {\n+\n+            private final Set<Permission> permissions;\n+\n+            Grant(Set<Permission> permissions) {\n+                this.permissions = permissions;\n+            }\n+\n+            /**\n+             * Everywhere in Jenkins.\n+             */\n+            public GrantOn everywhere() {\n+                return onPaths(\".*\");\n+            }\n+\n+            /**\n+             * On {@code Jenkins} itself, but not any child objects.\n+             */\n+            public GrantOn onRoot() {\n+                return onPaths(\"\");\n+            }\n+\n+            /**\n+             * On some items such as jobs.\n+             * If some of these happen to be {@link ItemGroup}s, the grant is <em>not</em> applied to children.\n+             */\n+            public GrantOn onItems(Item... items) {\n+                String[] paths = new String[items.length];\n+                for (int i = 0; i < items.length; i++) {\n+                    paths[i] = Pattern.quote(items[i].getFullName());\n+                }\n+                return onPaths(paths);\n+            }\n+\n+            /**\n+             * On some item groups, typically folders.\n+             * The grant applies to the folder itself as well as any (direct or indirect) children.\n+             */\n+            public GrantOn onFolders(ItemGroup<?>... folders) {\n+                String[] paths = new String[folders.length];\n+                for (int i = 0; i < folders.length; i++) {\n+                    paths[i] = Pattern.quote(folders[i].getFullName()) + \"(|/.+)\";\n+                }\n+                return onPaths(paths);\n+            }\n+\n+            /**\n+             * On some item path expressions.\n+             * Each element is an implicitly rooted regular expression.\n+             * {@code Jenkins} itself is {@code \"\"}, a top-level job would be {@code \"jobname\"}, a nested job would be {@code \"folder/jobname\"}, etc.\n+             * Grants are <em>not</em> implicitly applied to child objects.\n+             */\n+            public GrantOn onPaths(String... pathRegexps) {\n+                StringBuilder b = new StringBuilder();\n+                boolean first = true;\n+                for (String rx : pathRegexps) {\n+                    if (first) {\n+                        first = false;\n+                    } else {\n+                        b.append('|');\n+                    }\n+                    b.append(\"(?:\").append(rx).append(')');\n+                }\n+                return new GrantOn(b.toString());\n+            }\n+\n+            /**\n+             * A grant of some permissions in certain places.\n+             * You must proceed to specify to whom the grant is made.\n+             */\n+            public class GrantOn {\n+\n+                private final Pattern regexp;\n+\n+                GrantOn(String regexp) {\n+                    this.regexp = Pattern.compile(regexp);\n+                }\n+\n+                /** To some users or groups. */\n+                public MockAuthorizationStrategy to(String... sids) {\n+                    return new GrantOnTo(new HashSet<String>(Arrays.asList(sids))).add();\n+                }\n+\n+                /** To some users. */\n+                public MockAuthorizationStrategy to(User... users) {\n+                    String[] sids = new String[users.length];\n+                    for (int i = 0; i < users.length; i++) {\n+                        sids[i] = users[i].getId();\n+                    }\n+                    return to(sids);\n+                }\n+\n+                /** To everyone, including anonymous users. */\n+                public MockAuthorizationStrategy toEveryone() {\n+                    return to(/* SidACL.toString(ACL.EVERYONE) */\"role_everyone\");\n+                }\n+\n+                /** To all authenticated users. */\n+                public MockAuthorizationStrategy toAuthenticated() {\n+                    return to(/* SecurityRealm.AUTHENTICATED_AUTHORITY */\"authenticated\");\n+                }\n+\n+                private class GrantOnTo {\n+\n+                    private final Set<String> sids;\n+\n+                    GrantOnTo(Set<String> sids) {\n+                        this.sids = sids;\n+                    }\n+\n+                    MockAuthorizationStrategy add() {\n+                        grantsOnTo.add(this);\n+                        return MockAuthorizationStrategy.this;\n+                    }\n+\n+                    boolean matches(String path, String name, Permission permission) {\n+                        return regexp.matcher(path).matches() &&\n+                            sids.contains(name) && // TODO consider IdStrategy\n+                            permissions.contains(permission);\n+                    }\n+\n+                }\n+\n+            }\n+\n+        }\n+\n+        @Override\n+        public ACL getRootACL() {\n+            return new ACLImpl(\"\");\n+        }\n+\n+        @Override\n+        public ACL getACL(AbstractItem item) {\n+            return new ACLImpl(item.getFullName());\n+        }\n+\n+        @Override\n+        public ACL getACL(Job<?, ?> project) {\n+            return getACL((AbstractItem) project); // stupid overload\n+        }\n+\n+        private class ACLImpl extends SidACL {\n+\n+            private final String path;\n+\n+            ACLImpl(String path) {\n+                this.path = path;\n+            }\n+\n+            @Override protected Boolean hasPermission(Sid p, Permission permission) {\n+                String name = toString(p);\n+                for (Grant.GrantOn.GrantOnTo grantOnTo : grantsOnTo) {\n+                    if (grantOnTo.matches(path, name, permission)) {\n+                        return true;\n+                    }\n+                }\n+                return null; // allow groups to be checked after users, etc.\n+            }\n+\n+        }\n+\n+        @Override\n+        public Collection<String> getGroups() {\n+            return Collections.emptySet(); // we do not differentiate usernames from groups\n+        }\n+    }\n \n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 3,
        "max_directory_depth": 6
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "81af439caeefa41e70fdaa43e738e4e507413615",
            "date": "2025-01-14T16:07:47Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "6f37252727aeab611b5cae5f0605b2e2a4c1a7ad",
            "date": "2025-01-14T16:07:22Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "ab605fad8b35d3a38cdb7499175f0dd131ff8ee4",
            "date": "2025-01-14T13:40:54Z",
            "author_login": "jenkins-release-bot"
          },
          {
            "sha": "475d33c97dfd8a2e6e503672ef246694c91eda4d",
            "date": "2025-01-14T13:40:38Z",
            "author_login": "jenkins-release-bot"
          },
          {
            "sha": "e7f5953809d4d60257a6bfaaf1bc932d077a8597",
            "date": "2025-01-14T07:48:04Z",
            "author_login": "mawinter69"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N",
    "cwe_id": "CWE-863",
    "description": "Jenkins before versions 2.44 and 2.32.2 is vulnerable to an insufficient permission check. This allows users with permissions to create new items (e.g. jobs) to overwrite existing items they don't have access to (SECURITY-321).",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2018-04-11T16:29:00.277",
    "last_modified": "2024-11-21T03:23:48.170",
    "fix_date": "2017-01-04T15:01:53Z"
  },
  "references": [
    {
      "url": "http://www.securityfocus.com/bid/95949",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2017-2599",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/jenkinsci/jenkins/commit/4ed5c850b6855ab064a66d02fb338f366853ce89",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://jenkins.io/security/advisory/2017-02-01/",
      "source": "secalert@redhat.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/95949",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2017-2599",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/jenkinsci/jenkins/commit/4ed5c850b6855ab064a66d02fb338f366853ce89",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://jenkins.io/security/advisory/2017-02-01/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:21.820995",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "jenkins",
    "owner": "jenkinsci",
    "created_at": "2010-11-22T21:21:23Z",
    "updated_at": "2025-01-14T11:56:32Z",
    "pushed_at": "2025-01-14T07:48:05Z",
    "size": 162004,
    "stars": 23472,
    "forks": 8877,
    "open_issues": 74,
    "watchers": 23472,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master",
      "stable-1.625",
      "stable-1.642",
      "stable-1.651",
      "stable-2.7",
      "stable-2.19",
      "stable-2.32",
      "stable-2.46",
      "stable-2.60",
      "stable-2.73",
      "stable-2.89",
      "stable-2.107",
      "stable-2.121",
      "stable-2.138",
      "stable-2.150",
      "stable-2.164",
      "stable-2.176",
      "stable-2.190",
      "stable-2.204",
      "stable-2.222",
      "stable-2.235",
      "stable-2.249",
      "stable-2.263",
      "stable-2.277",
      "stable-2.289",
      "stable-2.302"
    ],
    "languages": {
      "Java": 12325164,
      "HTML": 970700,
      "JavaScript": 398710,
      "SCSS": 330642,
      "Groovy": 68802,
      "CSS": 41768,
      "Ruby": 17290,
      "Perl": 16145,
      "Handlebars": 14958,
      "Python": 4925,
      "ANTLR": 4633,
      "Shell": 2872,
      "C": 2091,
      "Batchfile": 1023,
      "Dockerfile": 210
    },
    "commit_activity": {
      "total_commits_last_year": 1355,
      "avg_commits_per_week": 26.057692307692307,
      "days_active_last_year": 302
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:17:56.125951"
  }
}