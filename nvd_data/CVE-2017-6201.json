{
  "cve_id": "CVE-2017-6201",
  "github_data": {
    "repository": "sandstorm-io/sandstorm",
    "fix_commit": "164997fb958effbc90c5328c166706280a84aaa1",
    "related_commits": [
      "164997fb958effbc90c5328c166706280a84aaa1",
      "164997fb958effbc90c5328c166706280a84aaa1"
    ],
    "patch_url": "https://github.com/sandstorm-io/sandstorm/commit/164997fb958effbc90c5328c166706280a84aaa1.patch",
    "fix_commit_details": {
      "sha": "164997fb958effbc90c5328c166706280a84aaa1",
      "commit_date": "2017-03-02T06:27:12Z",
      "author": {
        "login": "kentonv",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Implement IP blacklist for user-initiated requests.",
        "length": 51,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 670,
        "additions": 539,
        "deletions": 131
      },
      "files": [
        {
          "filename": "shell/client/admin-client.js",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -150,6 +150,10 @@ Router.map(function () {\n     path: \"/admin/preinstalled-apps\",\n     controller: newAdminRoute,\n   });\n+  this.route(\"newAdminNetworking\", {\n+    path: \"/admin/networking\",\n+    controller: newAdminRoute,\n+  });\n   this.route(\"newAdminMaintenance\", {\n     path: \"/admin/maintenance\",\n     controller: newAdminRoute,"
        },
        {
          "filename": "shell/client/admin/admin.html",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -99,6 +99,10 @@ <h2>Configuration</h2>\n             <div class=\"item-name\">App sources</div>\n             <div class=\"item-subtext\">Where to look for apps and app updates.</div>\n           {{/adminNavItem}}\n+          {{#adminNavItem routeName=\"newAdminNetworking\"}}\n+            <div class=\"item-name\">Networking</div>\n+            <div class=\"item-subtext\">Control how the network is accessed.</div>\n+          {{/adminNavItem}}\n         </ul>\n       </li>\n       <li>"
        },
        {
          "filename": "shell/client/admin/networking-client.js",
          "status": "added",
          "additions": 105,
          "deletions": 0,
          "patch": "@@ -0,0 +1,105 @@\n+// Sandstorm - Personal Cloud Sandbox\n+// Copyright (c) 2017 Sandstorm Development Group, Inc. and contributors\n+// All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+import { PRIVATE_IPV4_ADDRESSES, PRIVATE_IPV6_ADDRESSES } from \"/imports/constants.js\";\n+\n+const DEFAULT_IP_BLACKLIST = PRIVATE_IPV4_ADDRESSES.concat(PRIVATE_IPV6_ADDRESSES).join(\"\\n\");\n+\n+Template.newAdminNetworking.onCreated(function () {\n+  this.originalIpBlacklist = globalDb.getSettingWithFallback(\"ipBlacklist\", \"\");\n+  this.ipBlacklist = new ReactiveVar(this.originalIpBlacklist);\n+  this.formState = new ReactiveVar({\n+    state: \"edit\", // Other allowed states: \"submitting\", \"success\", and \"error\"\n+    message: undefined,\n+  });\n+});\n+\n+Template.newAdminNetworking.helpers({\n+  ipBlacklist() {\n+    const instance = Template.instance();\n+    return instance.ipBlacklist.get();\n+  },\n+\n+  saveDisabled() {\n+    const instance = Template.instance();\n+    return instance.formState.get().state === \"submitting\" ||\n+           instance.ipBlacklist.get() === instance.originalIpBlacklist;\n+  },\n+\n+  restoreDisabled() {\n+    const instance = Template.instance();\n+    return instance.ipBlacklist.get() === DEFAULT_IP_BLACKLIST;\n+  },\n+\n+  hasError() {\n+    const instance = Template.instance();\n+    return instance.formState.get().state === \"error\";\n+  },\n+\n+  hasSuccess() {\n+    const instance = Template.instance();\n+    return instance.formState.get().state === \"success\";\n+  },\n+\n+  message() {\n+    const instance = Template.instance();\n+    return instance.formState.get().message;\n+  },\n+});\n+\n+Template.newAdminNetworking.events({\n+  \"submit .admin-networking\"(evt) {\n+    evt.preventDefault();\n+    evt.stopPropagation();\n+  },\n+\n+  \"input textarea.ip-blacklist\"(evt) {\n+    evt.preventDefault();\n+    evt.stopPropagation();\n+    const instance = Template.instance();\n+    instance.ipBlacklist.set(evt.currentTarget.value);\n+  },\n+\n+  \"click .save\"(evt) {\n+    const instance = Template.instance();\n+    const newIpBlacklist = instance.ipBlacklist.get();\n+\n+    instance.formState.set({\n+      state: \"submitting\",\n+      message: \"\",\n+    });\n+\n+    Meteor.call(\"setSetting\", undefined, \"ipBlacklist\", newIpBlacklist, (err) => {\n+      if (err) {\n+        instance.formState.set({\n+          state: \"error\",\n+          message: err.message,\n+        });\n+      } else {\n+        instance.originalIpBlacklist = newIpBlacklist;\n+        instance.formState.set({\n+          state: \"success\",\n+          message: \"Saved changes.\",\n+        });\n+      }\n+    });\n+  },\n+\n+  \"click .restore\"(evt) {\n+    const instance = Template.instance();\n+    instance.ipBlacklist.set(DEFAULT_IP_BLACKLIST);\n+  },\n+});"
        },
        {
          "filename": "shell/client/admin/networking.html",
          "status": "added",
          "additions": 37,
          "deletions": 0,
          "patch": "@@ -0,0 +1,37 @@\n+<template name=\"newAdminNetworking\">\n+  <h1>\n+    <ul class=\"admin-breadcrumbs\">\n+      <li>{{#linkTo route=\"newAdminRoot\"}}Admin{{/linkTo}}</li>\n+      <li>Security</li>\n+    </ul>\n+  </h1>\n+\n+  {{#if hasSuccess}}\n+    {{#focusingSuccessBox}}\n+      {{message}}\n+    {{/focusingSuccessBox}}\n+  {{/if}}\n+  {{#if hasError}}\n+    {{#focusingErrorBox}}\n+      {{message}}\n+    {{/focusingErrorBox}}\n+  {{/if}}\n+\n+  <form class=\"admin-networking\">\n+    <div class=\"form-group\">\n+      <label>\n+        Server-side request IP blacklist:\n+        <textarea class=\"ip-blacklist\" value=\"{{ ipBlacklist }}\"></textarea>\n+      </label>\n+      <span class=\"form-subtext\">Users will be prohibited from making requests to these IP addresses. This includes making a request from an app, downloading an SPK file from a user-provided URL, etc. You may specify one IP address or network (in CIDR notation, e.g. \"127.0.0.0/8\") per line. The default value includes standard local and private network addresses. Note that when an HTTP proxy is in use, this setting may be ignored; the proxy must implement its own blacklist.</span>\n+    </div>\n+\n+    {{!-- TODO(someday): Allow whitelisting certain IPs or hosts? --}}\n+    {{!-- TODO(someday): Configure HTTP proxy here. --}}\n+\n+    <div class=\"button-row\">\n+      <button type=\"submit\" class=\"save\" disabled=\"{{saveDisabled}}\">Save</button>\n+      <button type=\"button\" class=\"restore\" disabled=\"{{restoreDisabled}}\">Restore defaults</button>\n+    </div>\n+  </form>\n+</template>"
        },
        {
          "filename": "shell/client/styles/_admin-networking.scss",
          "status": "added",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -0,0 +1,20 @@\n+.admin-networking {\n+  @extend %standard-form;\n+\n+  textarea {\n+    min-height: 200px;\n+    font-family: monospace;\n+  }\n+\n+  .save {\n+    @extend %button-base;\n+    @extend %button-primary;\n+    margin-left: 10px;\n+  }\n+\n+  .restore {\n+    @extend %button-base;\n+    @extend %button-secondary;\n+    margin-left: 10px;\n+  }\n+}"
        },
        {
          "filename": "shell/client/styles/_new-admin.scss",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -104,3 +104,4 @@\n @import \"_admin-users.scss\";\n @import \"_admin-stats.scss\";\n @import \"_admin-hosting-management.scss\";\n+@import \"_admin-networking.scss\";"
        },
        {
          "filename": "shell/imports/constants.js",
          "status": "modified",
          "additions": 52,
          "deletions": 2,
          "patch": "@@ -14,6 +14,56 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-ACCOUNT_DELETION_SUSPENSION_TIME = 7 * 60 * 60 * 24 * 1000; // 7 days in ms\n+const ACCOUNT_DELETION_SUSPENSION_TIME = 7 * 60 * 60 * 24 * 1000; // 7 days in ms\n \n-export { ACCOUNT_DELETION_SUSPENSION_TIME };\n+// Lists below developed from RFC6890, which is an overview of all special addresses.\n+const PRIVATE_IPV4_ADDRESSES = [\n+  \"10.0.0.0/8\",            // RFC1918 reserved for internal network\n+  \"127.0.0.0/8\",           // RFC1122 loopback / localhost\n+  \"169.254.0.0/16\",        // RFC3927 \"link local\" (auto-configured LAN in absence of DHCP)\n+  \"172.16.0.0/12\",         // RFC1918 reserved for internal network\n+  \"192.168.0.0/16\",        // RFC1918 reserved for internal network\n+];\n+\n+const PRIVATE_IPV6_ADDRESSES = [\n+  \"::1/128\",               // RFC4291 loopback / localhost\n+  \"fc00::/7\",              // RFC4193 unique private network\n+  \"fe80::/10\",             // RFC4291 \"link local\" (auto-configured LAN in absence of DHCP)\n+];\n+\n+const SPECIAL_IPV4_ADDRESSES = [\n+  \"0.0.0.0/8\",             // RFC1122 \"this host\" / wildcard\n+  \"100.64.0.0/10\",         // RFC6598 \"shared address space\" for carrier-grade NAT\n+  \"192.0.0.0/24\",          // RFC6890 reserved for special protocols\n+  \"192.0.2.0/24\",          // RFC5737 \"example address\" block 1 -- like example.com for IPs\n+  \"192.88.99.0/24\",        // RFC3068 6to4 relay\n+  \"198.18.0.0/15\",         // RFC2544 standard benchmarks\n+  \"198.51.100.0/24\",       // RFC5737 \"example address\" block 2 -- like example.com for IPs\n+  \"203.0.113.0/24\",        // RFC5737 \"example address\" block 3 -- like example.com for IPs\n+  \"224.0.0.0/4\",           // RFC1112 multicast\n+  \"240.0.0.0/4\",           // RFC1112 multicast / reserved for future use\n+  \"255.255.255.255/32\"     // RFC0919 broadcast address\n+];\n+\n+const SPECIAL_IPV6_ADDRESSES = [\n+  \"::/128\",                // RFC4291 unspecified address / wildcard\n+  \"64:ff9b::/96\",          // RFC6052 IPv4-IPv6 translation\n+  \"::ffff:0:0/96\",         // RFC4291 IPv4-mapped address\n+                           // TODO(someday): I don't understand the difference between the above\n+                           //     two. Both are described as mapping ip4 addresses into the ip6\n+                           //     space. Perhaps this should be allowed, however, we'd need to\n+                           //     filter the ip4 address against the ip4 blacklist, so special\n+                           //     handling would be needed.\n+  \"100::/64\",              // RFC6666 discard-only address block\n+  \"2001::/23\",             // RFC2928 reserved for special protocols\n+  \"2001:2::/48\",           // RFC5180 standard benchmarks\n+  \"2001:db8::/32\",         // RFC3849 \"example address\" block -- like example.com for IPs\n+  \"2001:10::/28\",          // RFC4843 ORCHID\n+  \"2002::/16\",             // RFC3056 6to4 relay\n+  \"ff00::/8\",              // RFC4291 multicast\n+];\n+\n+export {\n+  ACCOUNT_DELETION_SUSPENSION_TIME, PRIVATE_IPV4_ADDRESSES, PRIVATE_IPV6_ADDRESSES,\n+  SPECIAL_IPV4_ADDRESSES, SPECIAL_IPV6_ADDRESSES\n+};"
        },
        {
          "filename": "shell/imports/server/migrations.js",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -9,6 +9,7 @@ import { _ } from \"meteor/underscore\";\n import { Match } from \"meteor/check\";\n import { userPictureUrl, fetchPicture } from \"/imports/server/accounts/picture.js\";\n import { waitPromise } from \"/imports/server/async-helpers.js\";\n+import { PRIVATE_IPV4_ADDRESSES, PRIVATE_IPV6_ADDRESSES } from \"/imports/constants.js\";\n \n const Future = Npm.require(\"fibers/future\");\n const Url = Npm.require(\"url\");\n@@ -777,6 +778,15 @@ function removeFeatureKeys(db, backend) {\n   db.notifications.remove({ \"admin.type\": \"trialFeatureKeyExpired\" });\n }\n \n+function setIpBlacklist(db, backend) {\n+  if (Meteor.settings.public.isTesting) {\n+    db.collections.settings.insert({ _id: \"ipBlacklist\", value: \"192.168.0.0/16\" });\n+  } else {\n+    const defaultIpBlacklist = PRIVATE_IPV4_ADDRESSES.concat(PRIVATE_IPV6_ADDRESSES).join(\"\\n\");\n+    db.collections.settings.insert({ _id: \"ipBlacklist\", value: defaultIpBlacklist });\n+  }\n+}\n+\n // This must come after all the functions named within are defined.\n // Only append to this list!  Do not modify or remove list entries;\n // doing so is likely change the meaning and semantics of user databases.\n@@ -813,6 +823,7 @@ const MIGRATIONS = [\n   setNewServer,\n   addMembraneRequirementsToIdentities,\n   addEncryptionToFrontendRefIpNetwork,\n+  setIpBlacklist,\n ];\n \n const NEW_SERVER_STARTUP = ["
        },
        {
          "filename": "shell/imports/server/networking.js",
          "status": "added",
          "additions": 164,
          "deletions": 0,
          "patch": "@@ -0,0 +1,164 @@\n+// Sandstorm - Personal Cloud Sandbox\n+// Copyright (c) 2017 Sandstorm Development Group, Inc. and contributors\n+// All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+import { SPECIAL_IPV4_ADDRESSES, SPECIAL_IPV6_ADDRESSES } from \"/imports/constants.js\";\n+\n+const Dns = Npm.require(\"dns\");\n+const Ip = Npm.require(\"ip\");\n+const Url = Npm.require(\"url\");\n+\n+const lookupInFiber = Meteor.wrapAsync(Dns.lookup, Dns);\n+\n+function getNetwork(addr, bits) {\n+  // npm ip's \"mask\" and \"cidr\" functions are broken for ipv6. :(\n+\n+  const parsed = Ip.toBuffer(addr);\n+\n+  for (let i = Math.ceil(bits / 8); i < parsed.length; i++) {\n+    parsed[i] = 0;\n+  }\n+  const n = Math.floor(bits / 8);\n+  if (n < parsed.length) {\n+    parsed[n] = parsed[n] & (0xff << (8 - bits % 8));\n+  }\n+\n+  return parsed;\n+}\n+\n+function parseCidr(cidr) {\n+  // Given a CIDR-format network specification, return a function which, given an address string,\n+  // returns true if the address is in this network.\n+\n+  // The \"ip\" NPM module's CIDR handling unfortunately is very broken for IPv6. Many bugs have been\n+  // filed but it remains broken.\n+\n+  try {\n+    cidr = cidr.trim();\n+    if (cidr === \"\") return null;\n+\n+    const parts = cidr.split('/');\n+    if (parts.length === 1) {\n+      // Bare address.\n+      return addr => Ip.isEqual(cidr, addr);\n+    } else if (parts.length === 2) {\n+      const bits = parseInt(parts[1], 10);\n+      if (bits !== bits) throw new Error(\"value after slash must be an integer\");\n+      const network = getNetwork(parts[0], bits);\n+      return addr => {\n+        return network.equals(getNetwork(addr, bits));\n+      };\n+    } else {\n+      throw new Error(\"too many slashes\");\n+    }\n+  } catch (err) {\n+    console.error(\"invalid network specification in IP blacklist:\", cidr, err);\n+    return null;\n+  }\n+}\n+\n+SPECIAL_FILTERS = SPECIAL_IPV4_ADDRESSES.concat(SPECIAL_IPV6_ADDRESSES).map(parseCidr);\n+\n+function ssrfSafeLookup(db, url) {\n+  // Given an HTTP/HTTPS URL, look up the hostname, verify it doesn't point to a blacklisted IP,\n+  // then return an object of {url, host}, where `url` has the original hostname substituted with\n+  // an IP address, and `host` is the original hostname suitable for sending in the `Host` header.\n+\n+  const parsedUrl = Url.parse(url);\n+\n+  if (parsedUrl.protocol !== \"http:\" && parsedUrl.protocol !== \"https:\") {\n+    throw new Error(\"not an HTTP nor HTTPS URL: \" + url);\n+  }\n+\n+  const addresses = lookupInFiber(parsedUrl.hostname, { all: true, hints: Dns.ADDRCONFIG });\n+\n+  // TODO(perf): Subscribe to blacklist changes so that we don't have to do a new lookup and\n+  //   parse each time.\n+  const blacklist = db.getSettingWithFallback(\"ipBlacklist\", \"\")\n+      .split(\"\\n\").map(parseCidr).filter(x => x);\n+\n+  for (let i in addresses) {\n+    const address = addresses[i];\n+    if (address.family !== 4 && address.family !== 6) continue;\n+\n+    let ok = true;\n+    blacklist.forEach(test => { if (test(address.address)) { ok = false; } });\n+    SPECIAL_FILTERS.forEach(test => { if (test(address.address)) { ok = false; } });\n+\n+    if (ok) {\n+      const host = parsedUrl.host;\n+      delete parsedUrl.host;\n+      parsedUrl.hostname = address.address;\n+      return { url: Url.format(parsedUrl), host };\n+    }\n+  }\n+\n+  if (addresses.length > 0) {\n+    throw new Meteor.Error(403,\n+        \"can't connect to blacklisted private network address: \" + parsedUrl.hostname +\n+        \"; the Sandstorm server admin can change the blacklist in the admin settings\");\n+  } else {\n+    throw new Meteor.Error(404, \"host not found: \" + parsedUrl.hostname);\n+  }\n+}\n+\n+function ssrfSafeLookupOrProxy(db, url) {\n+  // If there is an HTTP proxy, then it will have to do the work of blacklisting IPs, because it's\n+  // the proxy that does the DNS lookup.\n+  const httpProxy = process.env.HTTP_PROXY || process.env.http_proxy;\n+  const httpsProxy = process.env.HTTPS_PROXY || process.env.https_proxy;\n+\n+  if (httpProxy && url.startsWith(\"http:\")) {\n+    return { proxy: httpProxy };\n+  } else if (httpsProxy && url.startsWith(\"https:\")) {\n+    return { proxy: httpsProxy };\n+  } else {\n+    return ssrfSafeLookup(db, url);\n+  }\n+}\n+\n+function ssrfSafeHttp(originalHttpCall, db, method, url, options, callback) {\n+  if (typeof options === \"function\") {\n+    callback = options;\n+    options = undefined;\n+  }\n+  if (!options) options = {};\n+\n+  if (options.npmRequestOptions && options.npmRequestOptions.proxy) {\n+    // Request already specifies a different proxy.\n+    return originalHttpCall(method, url, options, callback);\n+  }\n+\n+  const safe = ssrfSafeLookupOrProxy(db, url);\n+\n+  if (safe.proxy) {\n+    if (!options.npmRequestOptions) options.npmRequestOptions = {};\n+    options.npmRequestOptions.proxy = safe.proxy;\n+    return originalHttpCall(method, url, options, callback);\n+  } else {\n+    const safe = ssrfSafeLookup(db, url);\n+    if (!options.headers) options.headers = {};\n+    options.headers.host = safe.host;\n+    options.servername = safe.host.split(\":\")[0];\n+    return originalHttpCall(method, safe.url, options, callback);\n+  }\n+}\n+\n+function monkeyPatchHttp(db, HTTP) {\n+  const original = HTTP.call.bind(HTTP);\n+  HTTP.call = ssrfSafeHttp.bind(this, original, db);\n+}\n+\n+export { ssrfSafeLookup, ssrfSafeLookupOrProxy, monkeyPatchHttp };"
        },
        {
          "filename": "shell/server/00-startup.js",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -20,6 +20,7 @@ import { PersistentImpl } from \"/imports/server/persistent.js\";\n import { migrateToLatest } from \"/imports/server/migrations.js\";\n import { ACCOUNT_DELETION_SUSPENSION_TIME } from \"/imports/constants.js\";\n import { onInMeteor } from \"/imports/server/async-helpers.js\";\n+import { monkeyPatchHttp } from \"/imports/server/networking.js\";\n let url = require(\"url\");\n const Capnp = require(\"capnp\");\n \n@@ -59,6 +60,8 @@ SandstormDb.periodicCleanup(24 * 60 * 60 * 1000, () => {\n     deleteAccount);\n });\n \n+monkeyPatchHttp(globalDb, HTTP);\n+\n Meteor.startup(() => { migrateToLatest(globalDb, globalBackend); });\n \n // If there are multiple replicas, prefix every log message with our replica number."
        },
        {
          "filename": "shell/server/drivers/external-ui-view.js",
          "status": "modified",
          "additions": 17,
          "deletions": 3,
          "patch": "@@ -15,6 +15,7 @@\n // limitations under the License.\n \n import { PersistentImpl } from \"/imports/server/persistent.js\";\n+import { ssrfSafeLookup } from \"/imports/server/networking.js\";\n \n const Future = Npm.require(\"fibers/future\");\n const Capnp = Npm.require(\"capnp\");\n@@ -44,7 +45,12 @@ ExternalUiView = class ExternalUiView {\n       };\n     }\n \n-    return { session: new Capnp.Capability(new ExternalWebSession(this.url, options), ApiSession) };\n+    return inMeteor(() => {\n+      return {\n+        session: new Capnp.Capability(new ExternalWebSession(this.url, options, globalDb),\n+                                      ApiSession)\n+      };\n+    });\n   }\n };\n \n@@ -287,12 +293,20 @@ ExternalWebSession = class ExternalWebSession extends PersistentImpl {\n   constructor(url, options, db, saveTemplate) {\n     super(db, saveTemplate);\n \n+    // TODO(soon): Support HTTP proxy.\n+    const safe = ssrfSafeLookup(db, url);\n+\n+    if (!options) options = {};\n+    if (!options.headers) options.headers = {};\n+    options.headers.host = safe.host;\n+    options.servername = safe.host.split(\":\")[0];\n+\n     if (!saveTemplate) {\n       // enable backwards-compatibilty tweaks.\n       this.fromHackSession = true;\n     }\n \n-    const parsedUrl = Url.parse(url);\n+    const parsedUrl = Url.parse(safe.url);\n     this.host = parsedUrl.hostname;\n     if (this.fromHackSession) {\n       // HackSessionContext.getExternalUiView() apparently ignored any path on the URL. Whoops.\n@@ -308,7 +322,7 @@ ExternalWebSession = class ExternalWebSession extends PersistentImpl {\n \n     this.port = parsedUrl.port;\n     this.protocol = parsedUrl.protocol;\n-    this.options = options || {};\n+    this.options = options;\n   }\n \n   get(path, context) {"
        },
        {
          "filename": "shell/server/hack-session.js",
          "status": "modified",
          "additions": 68,
          "deletions": 59,
          "patch": "@@ -22,6 +22,7 @@ const Dgram = Npm.require(\"dgram\");\n const Capnp = Npm.require(\"capnp\");\n import { hashSturdyRef, checkRequirements, fetchApiToken } from \"/imports/server/persistent.js\";\n import { inMeteor, waitPromise } from \"/imports/server/async-helpers.js\";\n+import { ssrfSafeLookup } from \"/imports/server/networking.js\";\n \n const EmailRpc = Capnp.importSystem(\"sandstorm/email.capnp\");\n const HackSessionContext = Capnp.importSystem(\"sandstorm/hack-session.capnp\").HackSessionContext;\n@@ -411,68 +412,76 @@ HackSessionContextImpl = class HackSessionContextImpl extends SessionContextImpl\n     const _this = this;\n     const session = _this;\n \n-    return new Promise((resolve, reject) => {\n-      let requestMethod = Http.request;\n-      if (url.indexOf(\"https://\") === 0) {\n-        requestMethod = Https.request;\n-      } else if (url.indexOf(\"http://\") !== 0) {\n-        err = new Error(\"Protocol not recognized.\");\n-        err.nature = \"precondition\";\n-        reject(err);\n-      }\n-\n-      req = requestMethod(url, (resp) => {\n-        const buffers = [];\n-        let err;\n-\n-        switch (Math.floor(resp.statusCode / 100)) {\n-          case 2: // 2xx response -- OK.\n-            resp.on(\"data\", (buf) => {\n-              buffers.push(buf);\n-            });\n-\n-            resp.on(\"end\", () => {\n-              resolve({\n-                content: Buffer.concat(buffers),\n-                mimeType: resp.headers[\"content-type\"] || null,\n-              });\n-            });\n-            break;\n-          case 3: // 3xx response -- redirect.\n-            resolve(session.httpGet(resp.headers.location));\n-            break;\n-          case 4: // 4xx response -- client error.\n-            err = new Error(\"Status code \" + resp.statusCode + \" received in response.\");\n-            err.nature = \"precondition\";\n-            reject(err);\n-            break;\n-          case 5: // 5xx response -- internal server error.\n-            err = new Error(\"Status code \" + resp.statusCode + \" received in response.\");\n-            err.nature = \"localBug\";\n-            reject(err);\n-            break;\n-          default: // ???\n-            err = new Error(\"Invalid status code \" + resp.statusCode + \" received in response.\");\n-            err.nature = \"localBug\";\n-            reject(err);\n-            break;\n+    return inMeteor(() => {\n+      return ssrfSafeLookup(globalDb, url);\n+    }).then(safe => {\n+      return new Promise((resolve, reject) => {\n+        let requestMethod = Http.request;\n+        if (safe.url.indexOf(\"https://\") === 0) {\n+          requestMethod = Https.request;\n+        } else if (safe.url.indexOf(\"http://\") !== 0) {\n+          err = new Error(\"Protocol not recognized.\");\n+          err.nature = \"precondition\";\n+          reject(err);\n         }\n-      });\n-\n-      req.on(\"error\", (e) => {\n-        e.nature = \"networkFailure\";\n-        reject(e);\n-      });\n \n-      req.setTimeout(15000, () => {\n-        req.abort();\n-        err = new Error(\"Request timed out.\");\n-        err.nature = \"localBug\";\n-        err.durability = \"overloaded\";\n-        reject(err);\n+        const options = Url.parse(safe.url);\n+        options.headers = { host: safe.host };\n+        options.servername = safe.host.split(\":\")[0];\n+\n+        req = requestMethod(options, (resp) => {\n+          const buffers = [];\n+          let err;\n+  \n+          switch (Math.floor(resp.statusCode / 100)) {\n+            case 2: // 2xx response -- OK.\n+              resp.on(\"data\", (buf) => {\n+                buffers.push(buf);\n+              });\n+  \n+              resp.on(\"end\", () => {\n+                resolve({\n+                  content: Buffer.concat(buffers),\n+                  mimeType: resp.headers[\"content-type\"] || null,\n+                });\n+              });\n+              break;\n+            case 3: // 3xx response -- redirect.\n+              resolve(session.httpGet(resp.headers.location));\n+              break;\n+            case 4: // 4xx response -- client error.\n+              err = new Error(\"Status code \" + resp.statusCode + \" received in response.\");\n+              err.nature = \"precondition\";\n+              reject(err);\n+              break;\n+            case 5: // 5xx response -- internal server error.\n+              err = new Error(\"Status code \" + resp.statusCode + \" received in response.\");\n+              err.nature = \"localBug\";\n+              reject(err);\n+              break;\n+            default: // ???\n+              err = new Error(\"Invalid status code \" + resp.statusCode + \" received in response.\");\n+              err.nature = \"localBug\";\n+              reject(err);\n+              break;\n+          }\n+        });\n+  \n+        req.on(\"error\", (e) => {\n+          e.nature = \"networkFailure\";\n+          reject(e);\n+        });\n+  \n+        req.setTimeout(15000, () => {\n+          req.abort();\n+          err = new Error(\"Request timed out.\");\n+          err.nature = \"localBug\";\n+          err.durability = \"overloaded\";\n+          reject(err);\n+        });\n+  \n+        req.end();\n       });\n-\n-      req.end();\n     });\n   }\n "
        },
        {
          "filename": "shell/server/installer.js",
          "status": "modified",
          "additions": 53,
          "deletions": 67,
          "patch": "@@ -21,6 +21,7 @@ import ChildProcess from \"child_process\";\n import Url from \"url\";\n \n import { inMeteor, waitPromise } from \"/imports/server/async-helpers.js\";\n+import { ssrfSafeLookupOrProxy } from \"/imports/server/networking.js\";\n \n const Request = HTTPInternals.NpmModules.request.module;\n \n@@ -298,82 +299,67 @@ AppInstaller = class AppInstaller {\n   }\n \n   doDownloadTo(out) {\n-    const url = Url.parse(this.url);\n-    const options = {\n-      hostname: url.hostname,\n-      port: url.port,\n-      path: url.path,\n-    };\n-\n-    let protocol;\n-    if (url.protocol === \"http:\" || url.protocol === \"https:\") {\n-      protocol = Request.defaults({\n-        maxRedirects: 20,\n-        // Since we will verify the download against a hash anyway, we don't need to verify the\n-        // server's certificate. In fact, the only reason we support HTTPS at all here is because\n-        // some servers refuse to serve over HTTP (which is, in general, a good thing). Skipping the\n-        // certificate check here is helpful in that it means we don't have to worry about having a\n-        // reasonable list of trusted CAs available to Sandstorm.\n-        strictSSL: false,\n-      });\n-    } else {\n-      throw new Error(\"Protocol not supported: \" + url.protocol);\n-    }\n-\n-    // TODO(security):  It could arguably be a security problem that it's possible to probe the\n-    //   server's local network (behind any firewalls) by presenting URLs here.\n-    let bytesExpected = undefined;\n-    let bytesReceived = 0;\n-    const hasher = Crypto.createHash(\"sha256\");\n-    let done = false;\n-    const updateDownloadProgress = _.throttle(this.wrapCallback(() => {\n-      if (!done) {\n-        if (bytesExpected) {\n-          this.updateProgress(\"download\", bytesReceived / bytesExpected);\n-        } else {\n-          this.updateProgress(\"download\", bytesReceived);\n+    inMeteor(this.wrapCallback(function () {\n+      const safe = ssrfSafeLookupOrProxy(globalDb, this.url);\n+\n+      let bytesExpected = undefined;\n+      let bytesReceived = 0;\n+      const hasher = Crypto.createHash(\"sha256\");\n+      let done = false;\n+      const updateDownloadProgress = _.throttle(this.wrapCallback(() => {\n+        if (!done) {\n+          if (bytesExpected) {\n+            this.updateProgress(\"download\", bytesReceived / bytesExpected);\n+          } else {\n+            this.updateProgress(\"download\", bytesReceived);\n+          }\n         }\n-      }\n-    }), 500);\n-\n-    const request = protocol.get(this.url);\n-\n-    request.on(\"response\", this.wrapCallback((response) => {\n-      if (\"content-length\" in response.headers) {\n-        bytesExpected = parseInt(response.headers[\"content-length\"]);\n-      }\n-    }));\n+      }), 500);\n+\n+      const request = safe.proxy\n+          ? Request.get(this.url, { proxy: safe.proxy })\n+          : Request.get(safe.url, {\n+              headers: { host: safe.host },\n+              servername: safe.host.split(\":\")[0],\n+            });\n+\n+      request.on(\"response\", this.wrapCallback((response) => {\n+        if (\"content-length\" in response.headers) {\n+          bytesExpected = parseInt(response.headers[\"content-length\"]);\n+        }\n+      }));\n \n-    request.on(\"data\", this.wrapCallback((chunk) => {\n-      hasher.update(chunk);\n-      out.write(chunk);\n-      bytesReceived += chunk.length;\n-      updateDownloadProgress();\n-    }));\n+      request.on(\"data\", this.wrapCallback((chunk) => {\n+        hasher.update(chunk);\n+        out.write(chunk);\n+        bytesReceived += chunk.length;\n+        updateDownloadProgress();\n+      }));\n \n-    request.on(\"end\", this.wrapCallback(() => {\n-      out.done();\n+      request.on(\"end\", this.wrapCallback(() => {\n+        out.done();\n \n-      if (hasher.digest(\"hex\").slice(0, 32) !== this.packageId) {\n-        throw new Error(\"Package hash did not match.\");\n-      }\n+        if (hasher.digest(\"hex\").slice(0, 32) !== this.packageId) {\n+          throw new Error(\"Package hash did not match.\");\n+        }\n \n-      done = true;\n-      delete this.downloadRequest;\n+        done = true;\n+        delete this.downloadRequest;\n \n-      this.updateProgress(\"unpack\");\n-      out.saveAs(this.packageId).then(this.wrapCallback((info) => {\n-        this.appId = info.appId;\n-        this.authorPgpKeyFingerprint = info.authorPgpKeyFingerprint;\n-        this.done(info.manifest);\n-      }), this.wrapCallback((err) => {\n-        throw err;\n+        this.updateProgress(\"unpack\");\n+        out.saveAs(this.packageId).then(this.wrapCallback((info) => {\n+          this.appId = info.appId;\n+          this.authorPgpKeyFingerprint = info.authorPgpKeyFingerprint;\n+          this.done(info.manifest);\n+        }), this.wrapCallback((err) => {\n+          throw err;\n+        }));\n       }));\n-    }));\n \n-    request.on(\"error\", this.wrapCallback((err) => { throw err; }));\n+      request.on(\"error\", this.wrapCallback((err) => { throw err; }));\n \n-    this.downloadRequest = request;\n+      this.downloadRequest = request;\n+    }));\n   }\n \n   done(manifest) {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 7,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "73a5e98de0bb4467456016242db7ddac135afce8",
            "date": "2024-12-17T00:21:47Z",
            "author_login": "ocdtrekkie"
          },
          {
            "sha": "999aab500309357bf36c719c4b3d7549c9304c78",
            "date": "2024-12-16T06:50:29Z",
            "author_login": "ocdtrekkie"
          },
          {
            "sha": "295900411435c0860218f079549595dda3212b89",
            "date": "2024-12-16T06:39:19Z",
            "author_login": "ocdtrekkie"
          },
          {
            "sha": "807dafb8f43e283fbccd197718bd1300ff8bd8dc",
            "date": "2024-12-15T20:16:26Z",
            "author_login": "neuroradiology"
          },
          {
            "sha": "b2174c11e4efb8a945201f163a72936672451c8e",
            "date": "2024-12-15T16:51:20Z",
            "author_login": "neuroradiology"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-918",
    "description": "A Server Side Request Forgery vulnerability exists in the install app process in Sandstorm before build 0.203. A remote attacker may exploit this issue by providing a URL. It could bypass access control such as firewalls that prevent the attackers from accessing the URLs directly.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-02-06T16:29:00.887",
    "last_modified": "2024-11-21T03:29:14.833",
    "fix_date": "2017-03-02T06:27:12Z"
  },
  "references": [
    {
      "url": "https://devco.re/blog/2018/01/26/Sandstorm-Security-Review-CVE-2017-6200-en/",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sandstorm-io/sandstorm/commit/164997fb958effbc90c5328c166706280a84aaa1",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://sandstorm.io/news/2017-03-02-security-review",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://devco.re/blog/2018/01/26/Sandstorm-Security-Review-CVE-2017-6200-en/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sandstorm-io/sandstorm/commit/164997fb958effbc90c5328c166706280a84aaa1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://sandstorm.io/news/2017-03-02-security-review",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:15.399167",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "sandstorm",
    "owner": "sandstorm-io",
    "created_at": "2014-01-08T07:10:33Z",
    "updated_at": "2025-01-12T09:13:22Z",
    "pushed_at": "2024-12-17T00:21:53Z",
    "size": 20193,
    "stars": 6788,
    "forks": 710,
    "open_issues": 650,
    "watchers": 6788,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "JavaScript": 1614340,
      "C++": 960745,
      "Cap'n Proto": 325239,
      "HTML": 281602,
      "SCSS": 165828,
      "Shell": 108319,
      "Perl": 30029,
      "C": 28725,
      "TypeScript": 23734,
      "Makefile": 18331,
      "Yacc": 16084,
      "Raku": 11517,
      "Assembly": 10958,
      "Lex": 4118,
      "Python": 2586,
      "Standard ML": 2054
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T14:24:04.130328"
  }
}