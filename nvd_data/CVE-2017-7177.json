{
  "cve_id": "CVE-2017-7177",
  "github_data": {
    "repository": "inliniac/suricata",
    "fix_commit": "4a04f814b15762eb446a5ead4d69d021512df6f8",
    "related_commits": [
      "4a04f814b15762eb446a5ead4d69d021512df6f8",
      "4a04f814b15762eb446a5ead4d69d021512df6f8"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "4a04f814b15762eb446a5ead4d69d021512df6f8",
      "commit_date": "2017-02-05T13:57:54Z",
      "author": {
        "login": "jasonish",
        "type": "User",
        "stats": {
          "total_commits": 1542,
          "average_weekly_commits": 1.788863109048724,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 332
        }
      },
      "commit_message": {
        "title": "defrag - take protocol into account during re-assembly",
        "length": 317,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 174,
        "additions": 106,
        "deletions": 68
      },
      "files": [
        {
          "filename": "src/defrag-hash.c",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])"
        },
        {
          "filename": "src/defrag.c",
          "status": "modified",
          "additions": 102,
          "deletions": 68,
          "patch": "@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\"DefragTimeoutTest\", DefragTimeoutTest);\n     UtRegisterTest(\"DefragMfIpv4Test\", DefragMfIpv4Test);\n     UtRegisterTest(\"DefragMfIpv6Test\", DefragMfIpv6Test);\n+    UtRegisterTest(\"DefragTestBadProto\", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n "
        },
        {
          "filename": "src/defrag.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d63ad75d91014018acd950b0a35e03e23c38e8cc",
            "date": "2025-01-22T22:32:35Z",
            "author_login": "jasonish"
          },
          {
            "sha": "c8b28b1512141c57e1d5cf5216aea07ba13371bf",
            "date": "2025-01-21T22:57:31Z",
            "author_login": "jasonish"
          },
          {
            "sha": "d3c556b82da5273cd5a9f8d529dc896bdb346518",
            "date": "2025-01-21T21:23:15Z",
            "author_login": "jasonish"
          },
          {
            "sha": "c4fc2aac3b2a4b8fcd3d2deb7ffbd647c9155444",
            "date": "2025-01-21T21:21:46Z",
            "author_login": "jasonish"
          },
          {
            "sha": "a0bb260d916c2e2247df6a81142fc3eba201d1e8",
            "date": "2025-01-23T12:54:22Z",
            "author_login": "catenacyber"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-358",
    "description": "Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-03-18T20:59:00.173",
    "last_modified": "2024-11-21T03:31:19.377",
    "fix_date": "2017-02-05T13:57:54Z"
  },
  "references": [
    {
      "url": "http://www.securityfocus.com/bid/97047",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2018/12/msg00000.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/2019",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/97047",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2018/12/msg00000.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/2019",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:52.274867",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "suricata",
    "owner": "inliniac",
    "created_at": "2012-08-14T08:30:06Z",
    "updated_at": "2025-01-26T01:29:23Z",
    "pushed_at": "2025-01-24T13:42:36Z",
    "size": 74939,
    "stars": 4895,
    "forks": 1489,
    "open_issues": 83,
    "watchers": 4895,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "main-7.0.x",
      "master",
      "master-3.2.x",
      "master-4.0.x",
      "master-4.1.x",
      "master-5.0.x",
      "master-6.0.x"
    ],
    "languages": {
      "C": 14021986,
      "Rust": 3489814,
      "M4": 118208,
      "Python": 103285,
      "Shell": 46705,
      "Makefile": 45599,
      "Perl": 36748,
      "SmPL": 5503,
      "Lua": 1583,
      "Dockerfile": 1044
    },
    "commit_activity": {
      "total_commits_last_year": 1060,
      "avg_commits_per_week": 20.384615384615383,
      "days_active_last_year": 255
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-26T08:10:19.775033"
  }
}