{
  "cve_id": "CVE-2017-7586",
  "github_data": {
    "repository": "erikd/libsndfile",
    "fix_commit": "708e996c87c5fae77b104ccfeb8f6db784c32074",
    "related_commits": [
      "708e996c87c5fae77b104ccfeb8f6db784c32074",
      "f457b7b5ecfe91697ed01cfc825772c4d8de1236",
      "708e996c87c5fae77b104ccfeb8f6db784c32074",
      "f457b7b5ecfe91697ed01cfc825772c4d8de1236"
    ],
    "patch_url": "https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074.patch",
    "fix_commit_details": {
      "sha": "708e996c87c5fae77b104ccfeb8f6db784c32074",
      "commit_date": "2016-11-27T05:12:46Z",
      "author": {
        "login": "erikd",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "src/ : Move to a variable length header buffer",
        "length": 392,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 412,
        "additions": 218,
        "deletions": 194
      },
      "files": [
        {
          "filename": "src/common.c",
          "status": "modified",
          "additions": 204,
          "deletions": 184,
          "patch": "@@ -33,6 +33,49 @@\n #include \"sfendian.h\"\n #include \"common.h\"\n \n+#define\tINITAL_HEADER_SIZE\t256\n+\n+/* Allocate and initialize the SF_PRIVATE struct. */\n+SF_PRIVATE *\n+psf_allocate (void)\n+{\tSF_PRIVATE * psf ;\n+\n+\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n+\t\treturn\tNULL ;\n+\n+\tif ((psf->header.ptr = calloc (1, INITAL_HEADER_SIZE)) == NULL)\n+\t{\tfree (psf) ;\n+\t\treturn\tNULL ;\n+\t\t} ;\n+\tpsf->header.len = INITAL_HEADER_SIZE ;\n+\n+\treturn psf ;\n+} /* psf_allocate */\n+\n+static int\n+psf_bump_header_allocation (SF_PRIVATE * psf, sf_count_t needed)\n+{\n+\tsf_count_t newlen, smallest = INITAL_HEADER_SIZE ;\n+\tvoid * ptr ;\n+\n+\tnewlen = (needed > psf->header.len) ? 2 * SF_MAX (needed, smallest) : 2 * psf->header.len ;\n+\n+\tif (newlen > 100 * 1024)\n+\t{\tpsf_log_printf (psf, \"Request for header allocation of %D denined.\\n\", newlen) ;\n+\t\treturn 1 ;\n+\t\t}\n+\n+\tif ((ptr = realloc (psf->header.ptr, newlen)) == NULL)\n+\t{\tpsf_log_printf (psf, \"realloc (%p, %D) failed\\n\", psf->header.ptr, newlen) ;\n+\t\tpsf->error = SFE_MALLOC_FAILED ;\n+\t\treturn 1 ;\n+\t\t} ;\n+\n+\tpsf->header.ptr = ptr ;\n+\tpsf->header.len = newlen ;\n+\treturn 0 ;\n+} /* psf_bump_header_allocation */\n+\n /*-----------------------------------------------------------------------------------------------\n ** psf_log_printf allows libsndfile internal functions to print to an internal parselog which\n ** can later be displayed.\n@@ -336,9 +379,9 @@ psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)\n \tint\t\tmaxlen ;\n \tchar\t*start ;\n \n-\tmaxlen = strlen ((char*) psf->header) ;\n-\tstart\t= ((char*) psf->header) + maxlen ;\n-\tmaxlen\t= sizeof (psf->header) - maxlen ;\n+\tmaxlen = strlen ((char*) psf->header.ptr) ;\n+\tstart\t= ((char*) psf->header.ptr) + maxlen ;\n+\tmaxlen\t= psf->header.len - maxlen ;\n \n \tva_start (argptr, format) ;\n \tvsnprintf (start, maxlen, format, argptr) ;\n@@ -347,7 +390,7 @@ psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)\n \t/* Make sure the string is properly terminated. */\n \tstart [maxlen - 1] = 0 ;\n \n-\tpsf->headindex = strlen ((char*) psf->header) ;\n+\tpsf->header.indx = strlen ((char*) psf->header.ptr) ;\n \n \treturn ;\n } /* psf_asciiheader_printf */\n@@ -400,30 +443,25 @@ psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)\n \n static inline void\n header_put_byte (SF_PRIVATE *psf, char x)\n-{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 1)\n-\t\tpsf->header [psf->headindex++] = x ;\n+{\tpsf->header.ptr [psf->header.indx++] = x ;\n } /* header_put_byte */\n \n #if (CPU_IS_BIG_ENDIAN == 1)\n static inline void\n header_put_marker (SF_PRIVATE *psf, int x)\n-{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n-\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n-\t\tpsf->header [psf->headindex++] = x ;\n-\t\t} ;\n+{\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n+\tpsf->header.ptr [psf->header.indx++] = x ;\n } /* header_put_marker */\n \n #elif (CPU_IS_LITTLE_ENDIAN == 1)\n static inline void\n header_put_marker (SF_PRIVATE *psf, int x)\n-{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n-\t{\tpsf->header [psf->headindex++] = x ;\n-\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n-\t\t} ;\n+{\tpsf->header.ptr [psf->header.indx++] = x ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n } /* header_put_marker */\n \n #else\n@@ -433,120 +471,74 @@ header_put_marker (SF_PRIVATE *psf, int x)\n \n static inline void\n header_put_be_short (SF_PRIVATE *psf, int x)\n-{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)\n-\t{\tpsf->header [psf->headindex++] = (x >> 8) ;\n-\t\tpsf->header [psf->headindex++] = x ;\n-\t\t} ;\n+{\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n+\tpsf->header.ptr [psf->header.indx++] = x ;\n } /* header_put_be_short */\n \n static inline void\n header_put_le_short (SF_PRIVATE *psf, int x)\n-{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)\n-\t{\tpsf->header [psf->headindex++] = x ;\n-\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n-\t\t} ;\n+{\tpsf->header.ptr [psf->header.indx++] = x ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n } /* header_put_le_short */\n \n static inline void\n header_put_be_3byte (SF_PRIVATE *psf, int x)\n-{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)\n-\t{\tpsf->header [psf->headindex++] = (x >> 16) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n-\t\tpsf->header [psf->headindex++] = x ;\n-\t\t} ;\n+{\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n+\tpsf->header.ptr [psf->header.indx++] = x ;\n } /* header_put_be_3byte */\n \n static inline void\n header_put_le_3byte (SF_PRIVATE *psf, int x)\n-{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)\n-\t{\tpsf->header [psf->headindex++] = x ;\n-\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n-\t\t} ;\n+{\tpsf->header.ptr [psf->header.indx++] = x ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n } /* header_put_le_3byte */\n \n static inline void\n header_put_be_int (SF_PRIVATE *psf, int x)\n-{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n-\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n-\t\tpsf->header [psf->headindex++] = x ;\n-\t\t} ;\n+{\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n+\tpsf->header.ptr [psf->header.indx++] = x ;\n } /* header_put_be_int */\n \n static inline void\n header_put_le_int (SF_PRIVATE *psf, int x)\n-{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n-\t{\tpsf->header [psf->headindex++] = x ;\n-\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n-\t\t} ;\n+{\tpsf->header.ptr [psf->header.indx++] = x ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n } /* header_put_le_int */\n \n-#if (SIZEOF_SF_COUNT_T == 4)\n-\n-static inline void\n-header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n-{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n-\t{\tpsf->header [psf->headindex++] = 0 ;\n-\t\tpsf->header [psf->headindex++] = 0 ;\n-\t\tpsf->header [psf->headindex++] = 0 ;\n-\t\tpsf->header [psf->headindex++] = 0 ;\n-\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n-\t\tpsf->header [psf->headindex++] = x ;\n-\t\t} ;\n-} /* header_put_be_8byte */\n-\n-static inline void\n-header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)\n-{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n-\t{\tpsf->header [psf->headindex++] = x ;\n-\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n-\t\tpsf->header [psf->headindex++] = 0 ;\n-\t\tpsf->header [psf->headindex++] = 0 ;\n-\t\tpsf->header [psf->headindex++] = 0 ;\n-\t\tpsf->header [psf->headindex++] = 0 ;\n-\t\t} ;\n-} /* header_put_le_8byte */\n-\n-#elif (SIZEOF_SF_COUNT_T == 8)\n+#if (SIZEOF_SF_COUNT_T == 8)\n \n static inline void\n header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n-{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n-\t{\tpsf->header [psf->headindex++] = (x >> 56) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 48) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 40) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 32) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n-\t\tpsf->header [psf->headindex++] = x ;\n-\t\t} ;\n+{\tpsf->header.ptr [psf->header.indx++] = (x >> 56) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 48) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 40) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 32) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n+\tpsf->header.ptr [psf->header.indx++] = x ;\n } /* header_put_be_8byte */\n \n static inline void\n header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)\n-{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n-\t{\tpsf->header [psf->headindex++] = x ;\n-\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 32) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 40) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 48) ;\n-\t\tpsf->header [psf->headindex++] = (x >> 56) ;\n-\t\t} ;\n+{\tpsf->header.ptr [psf->header.indx++] = x ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 32) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 40) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 48) ;\n+\tpsf->header.ptr [psf->header.indx++] = (x >> 56) ;\n } /* header_put_le_8byte */\n \n #else\n-#error \"SIZEOF_SF_COUNT_T is not defined.\"\n+#error \"SIZEOF_SF_COUNT_T != 8\"\n #endif\n \n int\n@@ -567,7 +559,11 @@ psf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)\n \tva_start (argptr, format) ;\n \n \twhile ((c = *format++))\n-\t{\tswitch (c)\n+\t{\n+\t\tif (psf->header.indx + 16 >= psf->header.len && psf_bump_header_allocation (psf, 16))\n+\t\t\treturn count ;\n+\n+\t\tswitch (c)\n \t\t{\tcase ' ' : /* Do nothing. Just used to space out format string. */\n \t\t\t\t\tbreak ;\n \n@@ -658,20 +654,20 @@ psf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)\n \t\t\t\t\t/* Floats are passed as doubles. Is this always true? */\n \t\t\t\t\tfloatdata = (float) va_arg (argptr, double) ;\n \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n-\t\t\t\t\t\tfloat32_be_write (floatdata, psf->header + psf->headindex) ;\n+\t\t\t\t\t\tfloat32_be_write (floatdata, psf->header.ptr + psf->header.indx) ;\n \t\t\t\t\telse\n-\t\t\t\t\t\tfloat32_le_write (floatdata, psf->header + psf->headindex) ;\n-\t\t\t\t\tpsf->headindex += 4 ;\n+\t\t\t\t\t\tfloat32_le_write (floatdata, psf->header.ptr + psf->header.indx) ;\n+\t\t\t\t\tpsf->header.indx += 4 ;\n \t\t\t\t\tcount += 4 ;\n \t\t\t\t\tbreak ;\n \n \t\t\tcase 'd' :\n \t\t\t\t\tdoubledata = va_arg (argptr, double) ;\n \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n-\t\t\t\t\t\tdouble64_be_write (doubledata, psf->header + psf->headindex) ;\n+\t\t\t\t\t\tdouble64_be_write (doubledata, psf->header.ptr + psf->header.indx) ;\n \t\t\t\t\telse\n-\t\t\t\t\t\tdouble64_le_write (doubledata, psf->header + psf->headindex) ;\n-\t\t\t\t\tpsf->headindex += 8 ;\n+\t\t\t\t\t\tdouble64_le_write (doubledata, psf->header.ptr + psf->header.indx) ;\n+\t\t\t\t\tpsf->header.indx += 8 ;\n \t\t\t\t\tcount += 8 ;\n \t\t\t\t\tbreak ;\n \n@@ -680,13 +676,17 @@ psf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)\n \t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n \t\t\t\t\tsize = strlen (strptr) + 1 ;\n \t\t\t\t\tsize += (size & 1) ;\n+\n+\t\t\t\t\tif (psf->header.indx + (sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, 16))\n+\t\t\t\t\t\treturn count ;\n+\n \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n \t\t\t\t\t\theader_put_be_int (psf, size) ;\n \t\t\t\t\telse\n \t\t\t\t\t\theader_put_le_int (psf, size) ;\n-\t\t\t\t\tmemcpy (&(psf->header [psf->headindex]), strptr, size) ;\n-\t\t\t\t\tpsf->headindex += size ;\n-\t\t\t\t\tpsf->header [psf->headindex - 1] = 0 ;\n+\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;\n+\t\t\t\t\tpsf->header.indx += size ;\n+\t\t\t\t\tpsf->header.ptr [psf->header.indx - 1] = 0 ;\n \t\t\t\t\tcount += 4 + size ;\n \t\t\t\t\tbreak ;\n \n@@ -697,14 +697,16 @@ psf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)\n \t\t\t\t\t*/\n \t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n \t\t\t\t\tsize = strlen (strptr) ;\n+\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n+\t\t\t\t\t\treturn count ;\n \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n \t\t\t\t\t\theader_put_be_int (psf, size) ;\n \t\t\t\t\telse\n \t\t\t\t\t\theader_put_le_int (psf, size) ;\n-\t\t\t\t\tmemcpy (&(psf->header [psf->headindex]), strptr, size + 1) ;\n+\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + 1) ;\n \t\t\t\t\tsize += (size & 1) ;\n-\t\t\t\t\tpsf->headindex += size ;\n-\t\t\t\t\tpsf->header [psf->headindex] = 0 ;\n+\t\t\t\t\tpsf->header.indx += size ;\n+\t\t\t\t\tpsf->header.ptr [psf->header.indx] = 0 ;\n \t\t\t\t\tcount += 4 + size ;\n \t\t\t\t\tbreak ;\n \n@@ -715,51 +717,66 @@ psf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)\n \t\t\t\t\tsize = strlen (strptr) ;\n \t\t\t\t\tsize = (size & 1) ? size : size + 1 ;\n \t\t\t\t\tsize = (size > 254) ? 254 : size ;\n+\n+\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n+\t\t\t\t\t\treturn count ;\n+\n \t\t\t\t\theader_put_byte (psf, size) ;\n-\t\t\t\t\tmemcpy (&(psf->header [psf->headindex]), strptr, size) ;\n-\t\t\t\t\tpsf->headindex += size ;\n+\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;\n+\t\t\t\t\tpsf->header.indx += size ;\n \t\t\t\t\tcount += 1 + size ;\n \t\t\t\t\tbreak ;\n \n \t\t\tcase 'b' :\n \t\t\t\t\tbindata\t= va_arg (argptr, void *) ;\n \t\t\t\t\tsize\t= va_arg (argptr, size_t) ;\n-\t\t\t\t\tif (psf->headindex + size < sizeof (psf->header))\n-\t\t\t\t\t{\tmemcpy (&(psf->header [psf->headindex]), bindata, size) ;\n-\t\t\t\t\t\tpsf->headindex += size ;\n-\t\t\t\t\t\tcount += size ;\n-\t\t\t\t\t\t} ;\n+\n+\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n+\t\t\t\t\t\treturn count ;\n+\n+\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), bindata, size) ;\n+\t\t\t\t\tpsf->header.indx += size ;\n+\t\t\t\t\tcount += size ;\n \t\t\t\t\tbreak ;\n \n \t\t\tcase 'z' :\n \t\t\t\t\tsize = va_arg (argptr, size_t) ;\n+\n+\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n+\t\t\t\t\t\treturn count ;\n+\n \t\t\t\t\tcount += size ;\n \t\t\t\t\twhile (size)\n-\t\t\t\t\t{\tpsf->header [psf->headindex] = 0 ;\n-\t\t\t\t\t\tpsf->headindex ++ ;\n+\t\t\t\t\t{\tpsf->header.ptr [psf->header.indx] = 0 ;\n+\t\t\t\t\t\tpsf->header.indx ++ ;\n \t\t\t\t\t\tsize -- ;\n \t\t\t\t\t\t} ;\n \t\t\t\t\tbreak ;\n \n \t\t\tcase 'h' :\n \t\t\t\t\tbindata = va_arg (argptr, void *) ;\n-\t\t\t\t\tmemcpy (&(psf->header [psf->headindex]), bindata, 16) ;\n-\t\t\t\t\tpsf->headindex += 16 ;\n+\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), bindata, 16) ;\n+\t\t\t\t\tpsf->header.indx += 16 ;\n \t\t\t\t\tcount += 16 ;\n \t\t\t\t\tbreak ;\n \n \t\t\tcase 'j' :\t/* Jump forwards/backwards by specified amount. */\n \t\t\t\t\tsize = va_arg (argptr, size_t) ;\n-\t\t\t\t\tpsf->headindex += size ;\n+\n+\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n+\t\t\t\t\t\treturn count ;\n+\n+\t\t\t\t\tpsf->header.indx += size ;\n \t\t\t\t\tcount += size ;\n \t\t\t\t\tbreak ;\n \n \t\t\tcase 'o' :\t/* Jump to specified offset. */\n \t\t\t\t\tsize = va_arg (argptr, size_t) ;\n-\t\t\t\t\tif (size < sizeof (psf->header))\n-\t\t\t\t\t{\tpsf->headindex = size ;\n-\t\t\t\t\t\tcount = 0 ;\n-\t\t\t\t\t\t} ;\n+\n+\t\t\t\t\tif ((sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, size))\n+\t\t\t\t\t\treturn count ;\n+\n+\t\t\t\t\tpsf->header.indx = size ;\n \t\t\t\t\tbreak ;\n \n \t\t\tdefault :\n@@ -824,31 +841,20 @@ static int\n header_read (SF_PRIVATE *psf, void *ptr, int bytes)\n {\tint count = 0 ;\n \n-\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n-\t\treturn psf_fread (ptr, 1, bytes, psf) ;\n-\n-\tif (psf->headindex + bytes > SIGNED_SIZEOF (psf->header))\n-\t{\tint most ;\n+\tif (psf->header.indx + bytes >= psf->header.len && psf_bump_header_allocation (psf, bytes))\n+\t\treturn count ;\n \n-\t\tmost = SIGNED_SIZEOF (psf->header) - psf->headend ;\n-\t\tpsf_fread (psf->header + psf->headend, 1, most, psf) ;\n-\t\tmemcpy (ptr, psf->header + psf->headend, most) ;\n-\t\tpsf->headend = psf->headindex += most ;\n-\t\tpsf_fread ((char *) ptr + most, bytes - most, 1, psf) ;\n-\t\treturn bytes ;\n-\t\t} ;\n-\n-\tif (psf->headindex + bytes > psf->headend)\n-\t{\tcount = psf_fread (psf->header + psf->headend, 1, bytes - (psf->headend - psf->headindex), psf) ;\n-\t\tif (count != bytes - (int) (psf->headend - psf->headindex))\n+\tif (psf->header.indx + bytes > psf->header.end)\n+\t{\tcount = psf_fread (psf->header.ptr + psf->header.end, 1, bytes - (psf->header.end - psf->header.indx), psf) ;\n+\t\tif (count != bytes - (int) (psf->header.end - psf->header.indx))\n \t\t{\tpsf_log_printf (psf, \"Error : psf_fread returned short count.\\n\") ;\n \t\t\treturn count ;\n \t\t\t} ;\n-\t\tpsf->headend += count ;\n+\t\tpsf->header.end += count ;\n \t\t} ;\n \n-\tmemcpy (ptr, psf->header + psf->headindex, bytes) ;\n-\tpsf->headindex += bytes ;\n+\tmemcpy (ptr, psf->header.ptr + psf->header.indx, bytes) ;\n+\tpsf->header.indx += bytes ;\n \n \treturn bytes ;\n } /* header_read */\n@@ -858,39 +864,44 @@ header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)\n {\n \tswitch (whence)\n \t{\tcase SEEK_SET :\n-\t\t\tif (position > SIGNED_SIZEOF (psf->header))\n+\t\t\tif (psf->header.indx + position >= psf->header.len)\n+\t\t\t\tpsf_bump_header_allocation (psf, position) ;\n+\t\t\tif (position > psf->header.len)\n \t\t\t{\t/* Too much header to cache so just seek instead. */\n \t\t\t\tpsf_fseek (psf, position, whence) ;\n \t\t\t\treturn ;\n \t\t\t\t} ;\n-\t\t\tif (position > psf->headend)\n-\t\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - psf->headend, psf) ;\n-\t\t\tpsf->headindex = position ;\n+\t\t\tif (position > psf->header.end)\n+\t\t\t\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - psf->header.end, psf) ;\n+\t\t\tpsf->header.indx = position ;\n \t\t\tbreak ;\n \n \t\tcase SEEK_CUR :\n-\t\t\tif (psf->headindex + position < 0)\n+\t\t\tif (psf->header.indx + position >= psf->header.len)\n+\t\t\t\tpsf_bump_header_allocation (psf, position) ;\n+\n+\t\t\tif (psf->header.indx + position < 0)\n \t\t\t\tbreak ;\n \n-\t\t\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n+\t\t\tif (psf->header.indx >= psf->header.len)\n \t\t\t{\tpsf_fseek (psf, position, whence) ;\n \t\t\t\treturn ;\n \t\t\t\t} ;\n \n-\t\t\tif (psf->headindex + position <= psf->headend)\n-\t\t\t{\tpsf->headindex += position ;\n+\t\t\tif (psf->header.indx + position <= psf->header.end)\n+\t\t\t{\tpsf->header.indx += position ;\n \t\t\t\tbreak ;\n \t\t\t\t} ;\n \n-\t\t\tif (psf->headindex + position > SIGNED_SIZEOF (psf->header))\n+\t\t\tif (psf->header.indx + position > psf->header.len)\n \t\t\t{\t/* Need to jump this without caching it. */\n-\t\t\t\tpsf->headindex = psf->headend ;\n+\t\t\t\tpsf->header.indx = psf->header.end ;\n \t\t\t\tpsf_fseek (psf, position, SEEK_CUR) ;\n \t\t\t\tbreak ;\n \t\t\t\t} ;\n \n-\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - (psf->headend - psf->headindex), psf) ;\n-\t\t\tpsf->headindex = psf->headend ;\n+\t\t\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - (psf->header.end - psf->header.indx), psf) ;\n+\t\t\tpsf->header.indx = psf->header.end ;\n \t\t\tbreak ;\n \n \t\tcase SEEK_END :\n@@ -906,15 +917,18 @@ static int\n header_gets (SF_PRIVATE *psf, char *ptr, int bufsize)\n {\tint\t\tk ;\n \n+\tif (psf->header.indx + bufsize >= psf->header.len && psf_bump_header_allocation (psf, bufsize))\n+\t\treturn 0 ;\n+\n \tfor (k = 0 ; k < bufsize - 1 ; k++)\n-\t{\tif (psf->headindex < psf->headend)\n-\t\t{\tptr [k] = psf->header [psf->headindex] ;\n-\t\t\tpsf->headindex ++ ;\n+\t{\tif (psf->header.indx < psf->header.end)\n+\t\t{\tptr [k] = psf->header.ptr [psf->header.indx] ;\n+\t\t\tpsf->header.indx ++ ;\n \t\t\t}\n \t\telse\n-\t\t{\tpsf->headend += psf_fread (psf->header + psf->headend, 1, 1, psf) ;\n-\t\t\tptr [k] = psf->header [psf->headindex] ;\n-\t\t\tpsf->headindex = psf->headend ;\n+\t\t{\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, 1, psf) ;\n+\t\t\tptr [k] = psf->header.ptr [psf->header.indx] ;\n+\t\t\tpsf->header.indx = psf->header.end ;\n \t\t\t} ;\n \n \t\tif (ptr [k] == '\\n')\n@@ -937,15 +951,19 @@ psf_binheader_readf (SF_PRIVATE *psf, char const *format, ...)\n \tfloat\t\t\t*floatptr ;\n \tdouble\t\t\t*doubleptr ;\n \tchar\t\t\tc ;\n-\tint\t\t\t\tbyte_count = 0, count ;\n+\tint\t\t\t\tbyte_count = 0, count = 0 ;\n \n \tif (! format)\n \t\treturn psf_ftell (psf) ;\n \n \tva_start (argptr, format) ;\n \n \twhile ((c = *format++))\n-\t{\tswitch (c)\n+\t{\n+\t\tif (psf->header.indx + 16 >= psf->header.len && psf_bump_header_allocation (psf, 16))\n+\t\t\treturn count ;\n+\n+\t\tswitch (c)\n \t\t{\tcase 'e' : /* All conversions are now from LE to host. */\n \t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_LITTLE ;\n \t\t\t\t\tbreak ;\n@@ -956,13 +974,15 @@ psf_binheader_readf (SF_PRIVATE *psf, char const *format, ...)\n \n \t\t\tcase 'm' : /* 4 byte marker value eg 'RIFF' */\n \t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n+\t\t\t\t\t*intptr = 0 ;\n \t\t\t\t\tucptr = (unsigned char*) intptr ;\n \t\t\t\t\tbyte_count += header_read (psf, ucptr, sizeof (int)) ;\n \t\t\t\t\t*intptr = GET_MARKER (ucptr) ;\n \t\t\t\t\tbreak ;\n \n \t\t\tcase 'h' :\n \t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n+\t\t\t\t\t*intptr = 0 ;\n \t\t\t\t\tucptr = (unsigned char*) intptr ;\n \t\t\t\t\tbyte_count += header_read (psf, sixteen_bytes, sizeof (sixteen_bytes)) ;\n \t\t\t\t\t{\tint k ;\n@@ -1050,51 +1070,51 @@ psf_binheader_readf (SF_PRIVATE *psf, char const *format, ...)\n \t\t\t\t\tsize  += (size & 1) ;\n \t\t\t\t\tlongdata = H2LE_32 (size) ;\n \t\t\t\t\tget_int (psf, longdata) ;\n-\t\t\t\t\tmemcpy (&(psf->header [psf->headindex]), strptr, size) ;\n-\t\t\t\t\tpsf->headindex += size ;\n+\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;\n+\t\t\t\t\tpsf->header.indx += size ;\n \t\t\t\t\t*/\n \t\t\t\t\tbreak ;\n \n \t\t\tcase 'b' : /* Raw bytes */\n \t\t\t\t\tcharptr = va_arg (argptr, char*) ;\n \t\t\t\t\tcount = va_arg (argptr, size_t) ;\n-\t\t\t\t\tif (count > 0)\n-\t\t\t\t\t\tbyte_count += header_read (psf, charptr, count) ;\n+\t\t\t\t\tmemset (charptr, 0, count) ;\n+\t\t\t\t\tbyte_count += header_read (psf, charptr, count) ;\n \t\t\t\t\tbreak ;\n \n \t\t\tcase 'G' :\n \t\t\t\t\tcharptr = va_arg (argptr, char*) ;\n \t\t\t\t\tcount = va_arg (argptr, size_t) ;\n-\t\t\t\t\tif (count > 0)\n-\t\t\t\t\t\tbyte_count += header_gets (psf, charptr, count) ;\n+\t\t\t\t\tmemset (charptr, 0, count) ;\n+\n+\t\t\t\t\tif (psf->header.indx + count >= psf->header.len && psf_bump_header_allocation (psf, count))\n+\t\t\t\t\t\treturn 0 ;\n+\n+\t\t\t\t\tbyte_count += header_gets (psf, charptr, count) ;\n \t\t\t\t\tbreak ;\n \n \t\t\tcase 'z' :\n \t\t\t\t\tpsf_log_printf (psf, \"Format conversion 'z' not implemented yet.\\n\") ;\n \t\t\t\t\t/*\n \t\t\t\t\tsize    = va_arg (argptr, size_t) ;\n \t\t\t\t\twhile (size)\n-\t\t\t\t\t{\tpsf->header [psf->headindex] = 0 ;\n-\t\t\t\t\t\tpsf->headindex ++ ;\n+\t\t\t\t\t{\tpsf->header.ptr [psf->header.indx] = 0 ;\n+\t\t\t\t\t\tpsf->header.indx ++ ;\n \t\t\t\t\t\tsize -- ;\n \t\t\t\t\t\t} ;\n \t\t\t\t\t*/\n \t\t\t\t\tbreak ;\n \n-\t\t\tcase 'p' :\n-\t\t\t\t\t/* Get the seek position first. */\n+\t\t\tcase 'p' :\t/* Seek to position from start. */\n \t\t\t\t\tcount = va_arg (argptr, size_t) ;\n \t\t\t\t\theader_seek (psf, count, SEEK_SET) ;\n \t\t\t\t\tbyte_count = count ;\n \t\t\t\t\tbreak ;\n \n-\t\t\tcase 'j' :\n-\t\t\t\t\t/* Get the seek position first. */\n+\t\t\tcase 'j' :\t/* Seek to position from current position. */\n \t\t\t\t\tcount = va_arg (argptr, size_t) ;\n-\t\t\t\t\tif (count)\n-\t\t\t\t\t{\theader_seek (psf, count, SEEK_CUR) ;\n-\t\t\t\t\t\tbyte_count += count ;\n-\t\t\t\t\t\t} ;\n+\t\t\t\t\theader_seek (psf, count, SEEK_CUR) ;\n+\t\t\t\t\tbyte_count += count ;\n \t\t\t\t\tbreak ;\n \n \t\t\tdefault :"
        },
        {
          "filename": "src/common.h",
          "status": "modified",
          "additions": 9,
          "deletions": 6,
          "patch": "@@ -79,7 +79,6 @@\n #define\tSF_FILENAME_LEN\t\t\t(1024)\n #define SF_SYSERR_LEN\t\t\t(256)\n #define SF_MAX_STRINGS\t\t\t(32)\n-#define\tSF_HEADER_LEN\t\t\t(12292)\n #define\tSF_PARSELOG_LEN\t\t\t(2048)\n \n #define\tPSF_SEEK_ERROR\t\t\t((sf_count_t) -1)\n@@ -382,7 +381,12 @@ typedef struct sf_private_tag\n \t\tint\t\t\t\tindx ;\n \t} parselog ;\n \n-\tunsigned char\theader\t\t[SF_HEADER_LEN] ; /* Must be unsigned */\n+\n+\tstruct\n+\t{\tunsigned char\t* ptr ;\n+\t\tsf_count_t\t\tindx, end, len ;\n+\t} header ;\n+\n \tint\t\t\t\trwf_endian ;\t/* Header endian-ness flag. */\n \n \t/* Storage and housekeeping data for adding/reading strings from\n@@ -401,10 +405,6 @@ typedef struct sf_private_tag\n \n \tunsigned\t\tunique_id ;\n \n-\t/* Index variables for maintaining parselog and header above. */\n-\tint\t\t\t\theadindex, headend ;\n-\tint\t\t\t\thas_text ;\n-\n \tint\t\t\t\terror ;\n \n \tint\t\t\t\tendian ;\t\t/* File endianness : SF_ENDIAN_LITTLE or SF_ENDIAN_BIG. */\n@@ -736,6 +736,9 @@ enum\n \tSFE_MAX_ERROR\t\t\t/* This must be last in list. */\n } ;\n \n+/* Allocate and initialize the SF_PRIVATE struct. */\n+SF_PRIVATE * psf_allocate (void) ;\n+\n int subformat_to_bytewidth (int format) ;\n int s_bitwidth_to_subformat (int bits) ;\n int u_bitwidth_to_subformat (int bits) ;"
        },
        {
          "filename": "src/sndfile.c",
          "status": "modified",
          "additions": 5,
          "deletions": 4,
          "patch": "@@ -267,7 +267,7 @@ ErrorStruct SndfileErrors [] =\n \t{\tSFE_BAD_CHUNK_MARKER\t, \"Error : Bad chunk marker.\" },\n \t{\tSFE_BAD_CHUNK_DATA_PTR\t, \"Error : Bad data pointer in SF_CHUNK_INFO struct.\" },\n \t{\tSFE_FILENAME_TOO_LONG\t, \"Error : Supplied filename too long.\" },\n-\n+\t{\tSFE_BAD_HEADER_ALLOC \t, \"Error : Required header allocation is too large.\" },\n \n \t{\tSFE_MAX_ERROR\t\t\t, \"Maximum error number.\" },\n \t{\tSFE_MAX_ERROR + 1\t\t, NULL }\n@@ -326,7 +326,7 @@ sf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n \t/* Ultimate sanity check. */\n \tassert (sizeof (sf_count_t) == 8) ;\n \n-\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n+\tif ((psf = psf_allocate ()) == NULL)\n \t{\tsf_errno = SFE_MALLOC_FAILED ;\n \t\treturn\tNULL ;\n \t\t} ;\n@@ -358,7 +358,7 @@ sf_open_fd\t(int fd, int mode, SF_INFO *sfinfo, int close_desc)\n \t\treturn\tNULL ;\n \t\t} ;\n \n-\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n+\tif ((psf = psf_allocate ()) == NULL)\n \t{\tsf_errno = SFE_MALLOC_FAILED ;\n \t\treturn\tNULL ;\n \t\t} ;\n@@ -400,7 +400,7 @@ sf_open_virtual\t(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user\n \t\treturn NULL ;\n \t\t} ;\n \n-\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n+\tif ((psf = psf_allocate ()) == NULL)\n \t{\tsf_errno = SFE_MALLOC_FAILED ;\n \t\treturn\tNULL ;\n \t\t} ;\n@@ -2688,6 +2688,7 @@ psf_close (SF_PRIVATE *psf)\n \tpsf_close_rsrc (psf) ;\n \n \t/* For an ISO C compliant implementation it is ok to free a NULL pointer. */\n+\tfree (psf->header.ptr) ;\n \tfree (psf->container_data) ;\n \tfree (psf->codec_data) ;\n \tfree (psf->interleave) ;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "0d3f80b7394368623df558d8ba3fee6348584d4d",
            "date": "2024-11-16T04:00:33Z",
            "author_login": "arthurt"
          },
          {
            "sha": "b8d90da26268eed4bbf15042d634e718629906f5",
            "date": "2024-11-16T03:48:54Z",
            "author_login": "arthurt"
          },
          {
            "sha": "4755f5bd7854611d92ad0f1295587b439f9950ba",
            "date": "2024-11-16T03:46:53Z",
            "author_login": "arthurt"
          },
          {
            "sha": "58c05b87162264200b1aa7790be260fd74c9deee",
            "date": "2024-06-27T03:26:03Z",
            "author_login": "brad0"
          },
          {
            "sha": "3ab2093f32325fa5eeeb099d53064639c0e9a861",
            "date": "2024-04-04T02:06:32Z",
            "author_login": "brad0"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-119",
    "description": "In libsndfile before 1.0.28, an error in the \"header_read()\" function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-04-07T20:59:00.220",
    "last_modified": "2024-11-21T03:32:13.200",
    "fix_date": "2016-11-27T05:12:46Z"
  },
  "references": [
    {
      "url": "http://www.mega-nerd.com/libsndfile/#History",
      "source": "cve@mitre.org",
      "tags": [
        "Product",
        "Release Notes"
      ]
    },
    {
      "url": "http://www.mega-nerd.com/libsndfile/NEWS",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/97522",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/erikd/libsndfile/commit/f457b7b5ecfe91697ed01cfc825772c4d8de1236",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201707-04",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.mega-nerd.com/libsndfile/#History",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product",
        "Release Notes"
      ]
    },
    {
      "url": "http://www.mega-nerd.com/libsndfile/NEWS",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/97522",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/erikd/libsndfile/commit/f457b7b5ecfe91697ed01cfc825772c4d8de1236",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201707-04",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:54.845815",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "libsndfile",
    "owner": "erikd",
    "created_at": "2012-01-15T09:10:10Z",
    "updated_at": "2025-01-13T15:38:02Z",
    "pushed_at": "2024-11-16T18:22:19Z",
    "size": 32832,
    "stars": 1497,
    "forks": 398,
    "open_issues": 171,
    "watchers": 1497,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "fuzz-testing",
      "master"
    ],
    "languages": {
      "C": 2423995,
      "Smarty": 179798,
      "CMake": 106424,
      "M4": 82989,
      "C++": 44206,
      "Python": 42209,
      "Makefile": 30299,
      "Shell": 28775,
      "MATLAB": 6242
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-2.1"
    },
    "collected_at": "2025-01-14T13:11:40.771425"
  }
}