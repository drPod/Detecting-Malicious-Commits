{
  "cve_id": "CVE-2017-7946",
  "github_data": {
    "repository": "radare/radare2",
    "fix_commit": "d1e8ac62c6d978d4662f69116e30230d43033c92",
    "related_commits": [
      "d1e8ac62c6d978d4662f69116e30230d43033c92",
      "d1e8ac62c6d978d4662f69116e30230d43033c92"
    ],
    "patch_url": "https://github.com/radare/radare2/commit/d1e8ac62c6d978d4662f69116e30230d43033c92.patch",
    "fix_commit_details": {
      "sha": "d1e8ac62c6d978d4662f69116e30230d43033c92",
      "commit_date": "2017-04-18T11:37:33Z",
      "author": {
        "login": "radare",
        "type": "User",
        "stats": {
          "total_commits": 16352,
          "average_weekly_commits": 19.630252100840337,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 785
        }
      },
      "commit_message": {
        "title": "Fix null deref and uaf in mach0 parser",
        "length": 38,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 92,
        "additions": 51,
        "deletions": 41
      },
      "files": [
        {
          "filename": "libr/bin/format/mach0/mach0.c",
          "status": "modified",
          "additions": 51,
          "deletions": 41,
          "patch": "@@ -1119,7 +1119,7 @@ static int init_items(struct MACH0_(obj_t)* bin) {\n \t\tcase LC_LOAD_WEAK_DYLIB:\n \t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"load_dylib\", 0);\n \t\t\tbin->nlibs++;\n-\t\t\tif (!parse_dylib(bin, off)){\n+\t\t\tif (!parse_dylib (bin, off)){\n \t\t\t\tbprintf (\"Cannot parse dylib\\n\");\n \t\t\t\tbin->nlibs--;\n \t\t\t\treturn false;\n@@ -1130,30 +1130,31 @@ static int init_items(struct MACH0_(obj_t)* bin) {\n \t\t\t{\n \t\t\tut8 dyldi[sizeof (struct dyld_info_command)] = {0};\n \t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dyld_info\", 0);\n-\t\t\tbin->dyld_info = malloc (sizeof(struct dyld_info_command));\n-\n-\t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){\n-\t\t\t\tbprintf (\"Cannot parse dyldinfo\\n\");\n-\t\t\t\tfree (bin->dyld_info);\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {\n-\t\t\t\tfree (bin->dyld_info);\n-\t\t\t\tbin->dyld_info = NULL;\n-\t\t\t\tbprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n-\t\t\t} else {\n-\t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);\n-\t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);\n-\t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);\n-\t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);\n-\t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);\n-\t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);\n-\t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);\n-\t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);\n-\t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);\n-\t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);\n-\t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);\n-\t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);\n+\t\t\tbin->dyld_info = calloc (1, sizeof (struct dyld_info_command));\n+\t\t\tif (bin->dyld_info) {\n+\t\t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){\n+\t\t\t\t\tbprintf (\"Cannot parse dyldinfo\\n\");\n+\t\t\t\t\tR_FREE (bin->dyld_info);\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {\n+\t\t\t\t\tfree (bin->dyld_info);\n+\t\t\t\t\tbin->dyld_info = NULL;\n+\t\t\t\t\tbprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n+\t\t\t\t} else {\n+\t\t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);\n+\t\t\t\t}\n \t\t\t}\n \t\t\t}\n \t\t\tbreak;\n@@ -1747,17 +1748,20 @@ struct reloc_t* MACH0_(get_relocs)(struct MACH0_(obj_t)* bin) {\n \t\tif ((bind_size + lazy_size)<1) {\n \t\t\treturn NULL;\n \t\t}\n-\t\tif (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size)\n+\t\tif (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size) {\n \t\t\treturn NULL;\n+\t\t}\n \t\tif (bin->dyld_info->lazy_bind_off > bin->size || \\\n-\t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size)\n+\t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size) {\n \t\t\treturn NULL;\n-\t\tif (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size)\n+\t\t}\n+\t\tif (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size) {\n \t\t\treturn NULL;\n+\t\t}\n \t\t// NOTE(eddyb) it's a waste of memory, but we don't know the actual number of relocs.\n-\t\tif (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t))))\n+\t\tif (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t)))) {\n \t\t\treturn NULL;\n-\n+\t\t}\n \t\topcodes = calloc (1, bind_size + lazy_size + 1);\n \t\tif (!opcodes) {\n \t\t\tfree (relocs);\n@@ -1905,12 +1909,14 @@ relocs[i++].last = 0;\\\n \t\tfree (opcodes);\n \t} else {\n \t\tint j;\n-\t\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)\n+\t\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms) {\n \t\t\treturn NULL;\n-\t\tif (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t))))\n+\t\t}\n+\t\tif (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t)))) {\n \t\t\treturn NULL;\n+\t\t}\n \t\tfor (j = 0; j < bin->dysymtab.nundefsym; j++) {\n-\t\t\tif (parse_import_ptr(bin, &relocs[i], bin->dysymtab.iundefsym + j)) {\n+\t\t\tif (parse_import_ptr (bin, &relocs[i], bin->dysymtab.iundefsym + j)) {\n \t\t\t\trelocs[i].ord = j;\n \t\t\t\trelocs[i++].last = 0;\n \t\t\t}\n@@ -1954,18 +1960,19 @@ struct addr_t* MACH0_(get_entrypoint)(struct MACH0_(obj_t)* bin) {\n \t\t}\n \t\tbin->entry = entry->addr;\n \t}\n-\n \treturn entry;\n }\n \n struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n \tstruct lib_t *libs;\n \tint i;\n \n-\tif (!bin->nlibs)\n+\tif (!bin->nlibs) {\n \t\treturn NULL;\n-\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t))))\n+\t}\n+\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t)))) {\n \t\treturn NULL;\n+\t}\n \tfor (i = 0; i < bin->nlibs; i++) {\n \t\tstrncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);\n \t\tlibs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\\0';\n@@ -1978,12 +1985,14 @@ struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n ut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {\n \tint i;\n \n-\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER)\n+\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER) {\n \t\treturn 0;\n-\n-\tfor (i = 0; i < bin->nsegs; ++i)\n-\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0)\n+\t}\n+\tfor (i = 0; i < bin->nsegs; ++i) {\n+\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0) {\n \t\t\treturn bin->segs[i].vmaddr;\n+\t\t}\n+\t}\n \treturn 0;\n }\n \n@@ -2309,8 +2318,9 @@ ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {\n \t\tut8 b[128];\n \t\tut64 entry = addr_to_offset(bin, bin->entry);\n \t\t// XXX: X86 only and hacky!\n-\t\tif (entry > bin->size || entry + sizeof (b) > bin->size)\n+\t\tif (entry > bin->size || entry + sizeof (b) > bin->size) {\n \t\t\treturn 0;\n+\t\t}\n \t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n \t\tif (i < 1) {\n \t\t\treturn 0;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "0f85675c7a5d542a89318b62d4a4bc997e595e03",
            "date": "2025-01-14T11:01:39Z",
            "author_login": "radare"
          },
          {
            "sha": "92d45a6034fe60123adc23bf49b398809fe36d25",
            "date": "2025-01-14T11:11:00Z",
            "author_login": "radare"
          },
          {
            "sha": "07be136859c56f96a692c8d5d1a3531345f16a0c",
            "date": "2025-01-14T10:46:07Z",
            "author_login": "radare"
          },
          {
            "sha": "05ebe2e92fc1905702201106228b285c80bd958b",
            "date": "2025-01-14T10:28:47Z",
            "author_login": "radare"
          },
          {
            "sha": "e672c13d0f3620daf80a718e47d759f933bd8961",
            "date": "2025-01-14T10:18:30Z",
            "author_login": "trufae"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-416",
    "description": "The get_relocs_64 function in libr/bin/format/mach0/mach0.c in radare2 1.3.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted Mach0 file.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-04-18T20:59:00.200",
    "last_modified": "2024-11-21T03:33:01.610",
    "fix_date": "2017-04-18T11:37:33Z"
  },
  "references": [
    {
      "url": "https://github.com/radare/radare2/commit/d1e8ac62c6d978d4662f69116e30230d43033c92",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/radare/radare2/issues/7301",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/radare/radare2/commit/d1e8ac62c6d978d4662f69116e30230d43033c92",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/radare/radare2/issues/7301",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:54.861372",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "radare2",
    "owner": "radare",
    "created_at": "2012-07-03T07:42:26Z",
    "updated_at": "2025-01-14T11:39:09Z",
    "pushed_at": "2025-01-14T11:39:05Z",
    "size": 182812,
    "stars": 20990,
    "forks": 3027,
    "open_issues": 874,
    "watchers": 20990,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 29143253,
      "Makefile": 262919,
      "Shell": 145034,
      "Meson": 123192,
      "C++": 82794,
      "HTML": 55704,
      "Rebol": 54153,
      "Python": 38146,
      "Roff": 36722,
      "JavaScript": 23584,
      "CSS": 19465,
      "Batchfile": 8970,
      "Perl": 6449,
      "sed": 4448,
      "R": 1960,
      "Rez": 1386,
      "Assembly": 939,
      "Vala": 839,
      "Wren": 460,
      "Gnuplot": 429,
      "C#": 164,
      "Dart": 125,
      "Rascal": 45
    },
    "commit_activity": {
      "total_commits_last_year": 1594,
      "avg_commits_per_week": 30.653846153846153,
      "days_active_last_year": 294
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:06:47.409274"
  }
}