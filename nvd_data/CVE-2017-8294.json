{
  "cve_id": "CVE-2017-8294",
  "github_data": {
    "repository": "VirusTotal/yara",
    "fix_commit": "83d799804648c2a0895d40a19835d9b757c6fa4e",
    "related_commits": [
      "83d799804648c2a0895d40a19835d9b757c6fa4e",
      "83d799804648c2a0895d40a19835d9b757c6fa4e"
    ],
    "patch_url": "https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e.patch",
    "fix_commit_details": {
      "sha": "83d799804648c2a0895d40a19835d9b757c6fa4e",
      "commit_date": "2017-04-27T09:39:04Z",
      "author": {
        "login": "plusvic",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix issue #646 (#648)",
        "length": 150,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 180,
        "additions": 135,
        "deletions": 45
      },
      "files": [
        {
          "filename": "libyara/exec.c",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -850,6 +850,7 @@ int yr_execute_code(\n           (uint8_t*) r2.re->code,\n           (uint8_t*) r1.ss->c_string,\n           r1.ss->length,\n+          0,\n           r2.re->flags | RE_FLAGS_SCAN,\n           NULL,\n           NULL) >= 0;"
        },
        {
          "filename": "libyara/include/yara/re.h",
          "status": "modified",
          "additions": 4,
          "deletions": 11,
          "patch": "@@ -94,7 +94,6 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n #define RE_FLAGS_NO_CASE                0x20\n #define RE_FLAGS_SCAN                   0x40\n #define RE_FLAGS_DOT_ALL                0x80\n-#define RE_FLAGS_NOT_AT_START          0x100\n #define RE_FLAGS_GREEDY                0x400\n #define RE_FLAGS_UNGREEDY              0x800\n \n@@ -107,14 +106,6 @@ typedef struct RE_ERROR RE_ERROR;\n typedef uint8_t RE_SPLIT_ID_TYPE;\n \n \n-#define CHAR_IN_CLASS(chr, cls)  \\\n-    ((cls)[(chr) / 8] & 1 << ((chr) % 8))\n-\n-\n-#define IS_WORD_CHAR(chr) \\\n-    (isalnum(chr) || (chr) == '_')\n-\n-\n struct RE_NODE\n {\n   int type;\n@@ -213,7 +204,8 @@ void yr_re_node_destroy(\n int yr_re_exec(\n     uint8_t* re_code,\n     uint8_t* input,\n-    size_t input_size,\n+    size_t input_forwards_size,\n+    size_t input_backwards_size,\n     int flags,\n     RE_MATCH_CALLBACK_FUNC callback,\n     void* callback_args);\n@@ -222,7 +214,8 @@ int yr_re_exec(\n int yr_re_fast_exec(\n     uint8_t* re_code,\n     uint8_t* input,\n-    size_t input_size,\n+    size_t input_forwards_size,\n+    size_t input_backwards_size,\n     int flags,\n     RE_MATCH_CALLBACK_FUNC callback,\n     void* callback_args);"
        },
        {
          "filename": "libyara/re.c",
          "status": "modified",
          "additions": 79,
          "deletions": 31,
          "patch": "@@ -140,6 +140,24 @@ typedef struct _RE_THREAD_STORAGE\n YR_THREAD_STORAGE_KEY thread_storage_key = 0;\n \n \n+#define CHAR_IN_CLASS(chr, cls)  \\\n+    ((cls)[(chr) / 8] & 1 << ((chr) % 8))\n+\n+\n+int _yr_re_is_word_char(\n+    uint8_t* input,\n+    int character_size)\n+{\n+  int result = ((isalnum(*input) || (*input) == '_'));\n+\n+  if (character_size == 2)\n+    result = result && (*(input + 1) == 0);\n+\n+  return result;\n+}\n+\n+\n+\n //\n // yr_re_initialize\n //\n@@ -360,6 +378,7 @@ int yr_re_match(\n       re->code,\n       (uint8_t*) target,\n       strlen(target),\n+      0,\n       re->flags | RE_FLAGS_SCAN,\n       NULL,\n       NULL);\n@@ -1799,18 +1818,30 @@ int _yr_re_fiber_sync(\n //\n // yr_re_exec\n //\n-// Executes a regular expression\n+// Executes a regular expression. The specified regular expression will try to\n+// match the data starting at the address specified by \"input\". The \"input\"\n+// pointer can point to any address inside a memory buffer. Arguments\n+// \"input_forwards_size\" and \"input_backwards_size\" indicate how many bytes\n+// can be accesible starting at \"input\" and going forwards and backwards\n+// respectively.\n+//\n+//   <--- input_backwards_size -->|<----------- input_forwards_size -------->\n+//  |--------  memory buffer  -----------------------------------------------|\n+//                                ^\n+//                              input\n //\n // Args:\n //   uint8_t* re_code                 - Regexp code be executed\n //   uint8_t* input                   - Pointer to input data\n-//   size_t input_size                - Input data size\n+//   size_t input_forwards_size       - Number of accessible bytes starting at\n+//                                      \"input\" and going forwards.\n+//   size_t input_backwards_size      - Number of accessible bytes starting at\n+//                                      \"input\" and going backwards\n //   int flags                        - Flags:\n //      RE_FLAGS_SCAN\n //      RE_FLAGS_BACKWARDS\n //      RE_FLAGS_EXHAUSTIVE\n //      RE_FLAGS_WIDE\n-//      RE_FLAGS_NOT_AT_START\n //      RE_FLAGS_NO_CASE\n //      RE_FLAGS_DOT_ALL\n //   RE_MATCH_CALLBACK_FUNC callback  - Callback function\n@@ -1825,10 +1856,12 @@ int _yr_re_fiber_sync(\n //      -4  Too many fibers\n //      -5  Unknown fatal error\n \n+\n int yr_re_exec(\n     uint8_t* re_code,\n     uint8_t* input_data,\n-    size_t input_size,\n+    size_t input_forwards_size,\n+    size_t input_backwards_size,\n     int flags,\n     RE_MATCH_CALLBACK_FUNC callback,\n     void* callback_args)\n@@ -1858,18 +1891,23 @@ int yr_re_exec(\n   #define ACTION_KILL       2\n   #define ACTION_KILL_TAIL  3\n \n-  #define prolog if (bytes_matched >= max_bytes_matched) \\\n+  #define prolog { \\\n+      if ((bytes_matched >= max_bytes_matched) || \\\n+          (character_size == 2 && *(input + 1) != 0)) \\\n       { \\\n         action = ACTION_KILL; \\\n         break; \\\n-      }\n+      } \\\n+    }\n \n-  #define fail_if_error(e) switch (e) { \\\n+  #define fail_if_error(e) { \\\n+      switch (e) { \\\n         case ERROR_INSUFFICIENT_MEMORY: \\\n           return -2; \\\n         case ERROR_TOO_MANY_RE_FIBERS: \\\n           return -4; \\\n-      }\n+      } \\\n+    }\n \n   if (_yr_re_alloc_storage(&storage) != ERROR_SUCCESS)\n     return -2;\n@@ -1884,14 +1922,17 @@ int yr_re_exec(\n \n   if (flags & RE_FLAGS_BACKWARDS)\n   {\n+    max_bytes_matched = (int) yr_min(input_backwards_size, RE_SCAN_LIMIT);\n     input -= character_size;\n     input_incr = -input_incr;\n   }\n-\n-  max_bytes_matched = (int) yr_min(input_size, RE_SCAN_LIMIT);\n+  else\n+  {\n+    max_bytes_matched = (int) yr_min(input_forwards_size, RE_SCAN_LIMIT);\n+  }\n \n   // Round down max_bytes_matched to a multiple of character_size, this way if\n-  // character_size is 2 and input_size is odd we are ignoring the\n+  // character_size is 2 and max_bytes_matched is odd we are ignoring the\n   // extra byte which can't match anyways.\n \n   max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;\n@@ -1973,14 +2014,14 @@ int yr_re_exec(\n \n         case RE_OPCODE_WORD_CHAR:\n           prolog;\n-          match = IS_WORD_CHAR(*input);\n+          match = _yr_re_is_word_char(input, character_size);\n           action = match ? ACTION_NONE : ACTION_KILL;\n           fiber->ip += 1;\n           break;\n \n         case RE_OPCODE_NON_WORD_CHAR:\n           prolog;\n-          match = !IS_WORD_CHAR(*input);\n+          match = !_yr_re_is_word_char(input, character_size);\n           action = match ? ACTION_NONE : ACTION_KILL;\n           fiber->ip += 1;\n           break;\n@@ -2028,16 +2069,25 @@ int yr_re_exec(\n         case RE_OPCODE_WORD_BOUNDARY:\n         case RE_OPCODE_NON_WORD_BOUNDARY:\n \n-          if (bytes_matched == 0 &&\n-              !(flags & RE_FLAGS_NOT_AT_START) &&\n-              !(flags & RE_FLAGS_BACKWARDS))\n+          if (bytes_matched == 0 && input_backwards_size < character_size)\n+          {\n             match = TRUE;\n+          }\n           else if (bytes_matched >= max_bytes_matched)\n+          {\n             match = TRUE;\n-          else if (IS_WORD_CHAR(*(input - input_incr)) != IS_WORD_CHAR(*input))\n-            match = TRUE;\n+          }\n           else\n-            match = FALSE;\n+          {\n+            assert(input <  input_data + input_forwards_size);\n+            assert(input >= input_data - input_backwards_size);\n+\n+            assert(input - input_incr <  input_data + input_forwards_size);\n+            assert(input - input_incr >= input_data - input_backwards_size);\n+\n+            match = _yr_re_is_word_char(input, character_size) != \\\n+                    _yr_re_is_word_char(input - input_incr, character_size);\n+          }\n \n           if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)\n             match = !match;\n@@ -2048,16 +2098,16 @@ int yr_re_exec(\n \n         case RE_OPCODE_MATCH_AT_START:\n           if (flags & RE_FLAGS_BACKWARDS)\n-            kill = input_size > (size_t) bytes_matched;\n+            kill = input_backwards_size > (size_t) bytes_matched;\n           else\n-            kill = (flags & RE_FLAGS_NOT_AT_START) || (bytes_matched != 0);\n+            kill = input_backwards_size > 0 || (bytes_matched != 0);\n           action = kill ? ACTION_KILL : ACTION_CONTINUE;\n           fiber->ip += 1;\n           break;\n \n         case RE_OPCODE_MATCH_AT_END:\n           kill = flags & RE_FLAGS_BACKWARDS ||\n-                 input_size > (size_t) bytes_matched;\n+                 input_forwards_size > (size_t) bytes_matched;\n           action = kill ? ACTION_KILL : ACTION_CONTINUE;\n           fiber->ip += 1;\n           break;\n@@ -2134,13 +2184,6 @@ int yr_re_exec(\n       }\n     }\n \n-    if (flags & RE_FLAGS_WIDE &&\n-        bytes_matched < max_bytes_matched &&\n-        *(input + 1) != 0)\n-    {\n-      _yr_re_fiber_kill_all(&fibers, &storage->fiber_pool);\n-    }\n-\n     input += input_incr;\n     bytes_matched += character_size;\n \n@@ -2164,7 +2207,8 @@ int yr_re_exec(\n int yr_re_fast_exec(\n     uint8_t* code,\n     uint8_t* input_data,\n-    size_t input_size,\n+    size_t input_forwards_size,\n+    size_t input_backwards_size,\n     int flags,\n     RE_MATCH_CALLBACK_FUNC callback,\n     void* callback_args)\n@@ -2187,7 +2231,11 @@ int yr_re_fast_exec(\n   int input_incr;\n   int sp = 0;\n   int bytes_matched;\n-  int max_bytes_matched = input_size;\n+  int max_bytes_matched;\n+\n+  max_bytes_matched = flags & RE_FLAGS_BACKWARDS ?\n+      input_backwards_size :\n+      input_forwards_size;\n \n   input_incr = flags & RE_FLAGS_BACKWARDS ? -1 : 1;\n "
        },
        {
          "filename": "libyara/scan.c",
          "status": "modified",
          "additions": 7,
          "deletions": 3,
          "patch": "@@ -528,7 +528,8 @@ int _yr_scan_match_callback(\n typedef int (*RE_EXEC_FUNC)(\n     uint8_t* code,\n     uint8_t* input,\n-    size_t input_size,\n+    size_t input_forwards_size,\n+    size_t input_backwards_size,\n     int flags,\n     RE_MATCH_CALLBACK_FUNC callback,\n     void* callback_args);\n@@ -569,7 +570,8 @@ int _yr_scan_verify_re_match(\n         ac_match->forward_code,\n         data + offset,\n         data_size - offset,\n-        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,\n+        offset,\n+        flags,\n         NULL,\n         NULL);\n   }\n@@ -581,7 +583,8 @@ int _yr_scan_verify_re_match(\n         ac_match->forward_code,\n         data + offset,\n         data_size - offset,\n-        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,\n+        offset,\n+        flags,\n         NULL,\n         NULL);\n   }\n@@ -616,6 +619,7 @@ int _yr_scan_verify_re_match(\n     backward_matches = exec(\n         ac_match->backward_code,\n         data + offset,\n+        data_size - offset,\n         offset,\n         flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE,\n         _yr_scan_match_callback,"
        },
        {
          "filename": "tests/test-rules.c",
          "status": "modified",
          "additions": 44,
          "deletions": 0,
          "patch": "@@ -901,6 +901,50 @@ void test_re()\n       \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 8 }\",\n       \"a\\0x\\0x\\0b\\0\");\n \n+  assert_true_rule_blob(\n+      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n+      \"a\\0b\\0c\\0\");\n+\n+  assert_true_rule_blob(\n+      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n+      \"\\0a\\0b\\0c\\0\");\n+\n+  assert_true_rule_blob(\n+      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n+      \"\\ta\\0b\\0c\\0\");\n+\n+  assert_false_rule_blob(\n+      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n+      \"x\\0a\\0b\\0c\\0\");\n+\n+  assert_true_rule_blob(\n+      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n+      \"x\\ta\\0b\\0c\\0\");\n+\n+  assert_true_rule_blob(\n+      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n+      \"a\\0b\\0c\\0\");\n+\n+  assert_true_rule_blob(\n+      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n+      \"a\\0b\\0c\\0\\0\");\n+\n+  assert_true_rule_blob(\n+      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n+      \"a\\0b\\0c\\0\\t\");\n+\n+  assert_false_rule_blob(\n+      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n+      \"a\\0b\\0c\\0x\\0\");\n+\n+  assert_true_rule_blob(\n+      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n+      \"a\\0b\\0c\\0b\\t\");\n+\n+  assert_false_rule_blob(\n+      \"rule test { strings: $a = /\\\\b/ wide condition: $a }\",\n+      \"abc\");\n+\n   assert_regexp_syntax_error(\")\");\n   assert_true_regexp(\"abc\", \"abc\", \"abc\");\n   assert_false_regexp(\"abc\", \"xbc\");"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "5ff67fca5b09cc6389c17047720e97e84b91fd48",
            "date": "2025-01-13T09:12:24Z",
            "author_login": "shanehuntley"
          },
          {
            "sha": "d3eae3258a2969a00914d71c2530dd1cc9d22f84",
            "date": "2025-01-13T09:12:02Z",
            "author_login": "secDre4mer"
          },
          {
            "sha": "91fda4f2ed0fdafe1eee011be794600ccd03621c",
            "date": "2025-01-13T09:10:52Z",
            "author_login": "n0tduck1e"
          },
          {
            "sha": "ef8f1de92e7094244f75fd62f3bfa9f0cccae68a",
            "date": "2025-01-13T09:10:16Z",
            "author_login": "utkonos"
          },
          {
            "sha": "390b66bc93143c688611ba303c664bbfc84e7a0b",
            "date": "2024-12-13T09:30:33Z",
            "author_login": "signalblur"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-125",
    "description": "libyara/re.c in the regex component in YARA 3.5.0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted rule that is mishandled in the yr_re_exec function.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-04-27T14:59:00.310",
    "last_modified": "2024-11-21T03:33:42.920",
    "fix_date": "2017-04-27T09:39:04Z"
  },
  "references": [
    {
      "url": "http://www.securityfocus.com/bid/98072",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/VirusTotal/yara/issues/646",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/98072",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/VirusTotal/yara/issues/646",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:54.876688",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "yara",
    "owner": "VirusTotal",
    "created_at": "2012-12-06T15:33:08Z",
    "updated_at": "2025-01-14T01:12:14Z",
    "pushed_at": "2025-01-13T09:12:24Z",
    "size": 23889,
    "stars": 8460,
    "forks": 1463,
    "open_issues": 174,
    "watchers": 8460,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "C": 2925532,
      "Yacc": 109087,
      "Lex": 46056,
      "C++": 46003,
      "Starlark": 33327,
      "M4": 27377,
      "Makefile": 10568,
      "Roff": 5739,
      "JavaScript": 2903,
      "Shell": 1808,
      "YARA": 1545,
      "HTML": 1462
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T14:12:40.127424"
  }
}