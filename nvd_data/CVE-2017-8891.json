{
  "cve_id": "CVE-2017-8891",
  "github_data": {
    "repository": "dropbox/lepton",
    "fix_commit": "82167c144a322cc956da45407f6dce8d4303d346",
    "related_commits": [
      "82167c144a322cc956da45407f6dce8d4303d346",
      "82167c144a322cc956da45407f6dce8d4303d346"
    ],
    "patch_url": "https://github.com/dropbox/lepton/commit/82167c144a322cc956da45407f6dce8d4303d346.patch",
    "fix_commit_details": {
      "sha": "82167c144a322cc956da45407f6dce8d4303d346",
      "commit_date": "2017-04-05T06:58:01Z",
      "author": {
        "login": "danielrh",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix #87 : always check that threads_required set up the appropriate number of threads---fire off nop functions on unused threads for consistency",
        "length": 144,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 38,
        "additions": 24,
        "deletions": 14
      },
      "files": [
        {
          "filename": "src/lepton/bitops.cc",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -356,6 +356,7 @@ bounded_iostream::bounded_iostream(Sirikata::DecoderWriter *w,\n     this->size_callback = size_callback;\n     buffer_position = 0;\n     byte_position = 0;\n+    byte_bound = 0x7FFFFFFF;\n     num_bytes_attempted_to_write = 0;\n     set_bound(0);\n }\n@@ -384,7 +385,7 @@ void bounded_iostream::close() {\n     parent->Close();\n }\n \n-unsigned int bounded_iostream::write_no_buffer(const void *from, size_t bytes_to_write) {\n+uint32_t bounded_iostream::write_no_buffer(const void *from, size_t bytes_to_write) {\n     //return iostream::write(from,tpsize,dtsize);\n     std::pair<unsigned int, Sirikata::JpegError> retval;\n     if (byte_bound != 0 && byte_position + bytes_to_write > byte_bound) {"
        },
        {
          "filename": "src/lepton/bitops.hh",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -467,12 +467,12 @@ class bounded_iostream\n     uint8_t buffer[buffer_size];\n     uint32_t buffer_position;\n     Sirikata::DecoderWriter *parent;\n-    unsigned int byte_bound;\n-    unsigned int byte_position;\n-    unsigned int num_bytes_attempted_to_write;\n+    uint32_t byte_bound;\n+    uint32_t byte_position;\n+    uint32_t num_bytes_attempted_to_write;\n     Sirikata::JpegError err;\n     std::function<void(Sirikata::DecoderWriter*, size_t)> size_callback;\n-    unsigned int write_no_buffer( const void* from, size_t bytes_to_write );\n+    uint32_t write_no_buffer( const void* from, size_t bytes_to_write );\n public:\n \tbounded_iostream( Sirikata::DecoderWriter * parent,\n                       const std::function<void(Sirikata::DecoderWriter*, size_t)> &size_callback,"
        },
        {
          "filename": "src/lepton/lepton_codec.cc",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -275,6 +275,7 @@ CodingReturnValue LeptonCodec::ThreadState::vp8_decode_thread(unsigned int threa\n     /* deserialize each block in planar order */\n \n     dev_assert(luma_splits_.size() == 2); // not ready to do multiple work items on a thread yet\n+    always_assert(luma_splits_.size() >= 2);\n     int min_y = luma_splits_[0];\n     int max_y = luma_splits_[1];\n     while(true) {"
        },
        {
          "filename": "src/lepton/vp8_decoder.cc",
          "status": "modified",
          "additions": 14,
          "deletions": 8,
          "patch": "@@ -417,6 +417,7 @@ std::vector<ThreadHandoff> VP8ComponentDecoder::initialize_decoder_state(const U\n void VP8ComponentDecoder::flush() {\n         mux_splicer.drain(mux_reader_);\n }\n+namespace{void nop(){}}\n CodingReturnValue VP8ComponentDecoder::decode_chunk(UncompressedComponents * const colldata)\n {\n     mux_splicer.init(spin_workers_);\n@@ -455,14 +456,19 @@ CodingReturnValue VP8ComponentDecoder::decode_chunk(UncompressedComponents * con\n     if (do_threading_) {\n         for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) {\n             unsigned int cur_spin_worker = thread_id;\n-            spin_workers_[cur_spin_worker].work\n-                = std::bind(worker_thread,\n-                            thread_state_[thread_id],\n-                            thread_id,\n-                            colldata,\n-                            mux_splicer.thread_target,\n-                            getWorker(cur_spin_worker),\n-                            &send_to_actual_thread_state);\n+            if (!thread_state_[thread_id]) {\n+                spin_workers_[cur_spin_worker].work\n+                    = &nop;\n+            } else {\n+                spin_workers_[cur_spin_worker].work\n+                    = std::bind(worker_thread,\n+                                thread_state_[thread_id],\n+                                thread_id,\n+                                colldata,\n+                                mux_splicer.thread_target,\n+                                getWorker(cur_spin_worker),\n+                                &send_to_actual_thread_state);\n+            }\n             spin_workers_[cur_spin_worker].activate_work();\n         }\n         flush();"
        },
        {
          "filename": "src/vp8/decoder/boolreader.hh",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -119,7 +119,9 @@ public:\n             return;\n         }\n         size_t del = rope[0].second-rope[0].first;\n-        memcpy(dest, rope[0].first, del);\n+        if (del) {\n+            memcpy(dest, rope[0].first, del);\n+        }\n         dest += del;\n         size -=del;\n         if (size) {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "f34c7f42d2e0d688239cb880648dc152713c4eae",
            "date": "2023-02-13T22:13:01Z",
            "author_login": "lesniewski"
          },
          {
            "sha": "05bdcf148591da3df05da162a6d39b11e130b660",
            "date": "2022-11-18T16:50:35Z",
            "author_login": "april-dbx"
          },
          {
            "sha": "429fe880d331b49a5be08b4d8dc762cbada6d4ca",
            "date": "2022-04-06T08:21:36Z",
            "author_login": "lesniewski"
          },
          {
            "sha": "1b7404d76b2143f18b968cf617bca171b162f1c2",
            "date": "2022-04-06T18:55:14Z",
            "author_login": "lesniewski"
          },
          {
            "sha": "6c4441cafac0e2f0b066cec79ed6bd49c445c7b7",
            "date": "2022-03-30T00:26:55Z",
            "author_login": "lesniewski"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-1187",
    "description": "Dropbox Lepton 1.2.1 allows DoS (SEGV and application crash) via a malformed lepton file because the code does not ensure setup of a correct number of threads.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-05-10T16:29:00.227",
    "last_modified": "2024-11-21T03:34:54.957",
    "fix_date": "2017-04-05T06:58:01Z"
  },
  "references": [
    {
      "url": "http://openwall.com/lists/oss-security/2017/05/10/1",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/dropbox/lepton/commit/82167c144a322cc956da45407f6dce8d4303d346",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/dropbox/lepton/issues/87",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://openwall.com/lists/oss-security/2017/05/10/1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/dropbox/lepton/commit/82167c144a322cc956da45407f6dce8d4303d346",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/dropbox/lepton/issues/87",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:58:56.554797",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "lepton",
    "owner": "dropbox",
    "created_at": "2016-07-13T16:27:29Z",
    "updated_at": "2025-01-10T01:29:58Z",
    "pushed_at": "2024-03-04T16:56:20Z",
    "size": 54427,
    "stars": 5007,
    "forks": 352,
    "open_issues": 27,
    "watchers": 5007,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 1253119,
      "Makefile": 21184,
      "CMake": 17273,
      "Hack": 12458,
      "Shell": 11330,
      "Python": 11249,
      "JavaScript": 4782,
      "M4": 3897,
      "Perl": 1098,
      "HTML": 112
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:48:58.691535"
  }
}