{
  "cve_id": "CVE-2017-9205",
  "github_data": {
    "repository": "jsummers/imageworsener",
    "fix_commit": "b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d",
    "related_commits": [
      "b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d",
      "b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d"
    ],
    "patch_url": "https://github.com/jsummers/imageworsener/commit/b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d.patch",
    "fix_commit_details": {
      "sha": "b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d",
      "commit_date": "2017-05-14T16:37:43Z",
      "author": {
        "login": "jsummers",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fixed invalid memory access bugs when decoding JPEG Exif data",
        "length": 94,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 38,
        "additions": 25,
        "deletions": 13
      },
      "files": [
        {
          "filename": "src/imagew-jpeg.c",
          "status": "modified",
          "additions": 25,
          "deletions": 13,
          "patch": "@@ -58,6 +58,18 @@ struct iw_exif_state {\n \tsize_t d_len;\n };\n \n+static unsigned int get_exif_ui16(struct iw_exif_state *e, unsigned int pos)\n+{\n+\tif(e->d_len<2 || pos>e->d_len-2) return 0;\n+\treturn iw_get_ui16_e(&e->d[pos], e->endian);\n+}\n+\n+static unsigned int get_exif_ui32(struct iw_exif_state *e, unsigned int pos)\n+{\n+\tif(e->d_len<4 || pos>e->d_len-4) return 0;\n+\treturn iw_get_ui32_e(&e->d[pos], e->endian);\n+}\n+\n // Try to read an Exif tag into an integer.\n // Returns zero on failure.\n static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n@@ -66,17 +78,17 @@ static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n \tunsigned int field_type;\n \tunsigned int value_count;\n \n-\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n-\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n+\tfield_type = get_exif_ui16(e, tag_pos+2);\n+\tvalue_count = get_exif_ui32(e, tag_pos+4);\n \n \tif(value_count!=1) return 0;\n \n \tif(field_type==3) { // SHORT (uint16)\n-\t\t*pv = iw_get_ui16_e(&e->d[tag_pos+8],e->endian);\n+\t\t*pv = get_exif_ui16(e, tag_pos+8);\n \t\treturn 1;\n \t}\n \telse if(field_type==4) { // LONG (uint32)\n-\t\t*pv = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n+\t\t*pv = get_exif_ui32(e, tag_pos+8);\n \t\treturn 1;\n \t}\n \n@@ -93,8 +105,8 @@ static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n \tunsigned int value_pos;\n \tunsigned int numer, denom;\n \n-\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n-\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n+\tfield_type = get_exif_ui16(e, tag_pos+2);\n+\tvalue_count = get_exif_ui32(e, tag_pos+4);\n \n \tif(value_count!=1) return 0;\n \n@@ -103,12 +115,12 @@ static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n \t// A rational is 8 bytes. Since 8>4, it is stored indirectly. First, read\n \t// the location where it is stored.\n \n-\tvalue_pos = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n+\tvalue_pos = get_exif_ui32(e, tag_pos+8);\n \tif(value_pos > e->d_len-8) return 0;\n \n \t// Read the actual value.\n-\tnumer = iw_get_ui32_e(&e->d[value_pos  ],e->endian);\n-\tdenom = iw_get_ui32_e(&e->d[value_pos+4],e->endian);\n+\tnumer = get_exif_ui32(e, value_pos);\n+\tdenom = get_exif_ui32(e, value_pos+4);\n \tif(denom==0) return 0;\n \n \t*pv = ((double)numer)/denom;\n@@ -125,15 +137,15 @@ static void iwjpeg_scan_exif_ifd(struct iwjpegrcontext *rctx,\n \tunsigned int v;\n \tdouble v_dbl;\n \n-\tif(ifd<8 || ifd>e->d_len-18) return;\n+\tif(ifd<8 || e->d_len<18 || ifd>e->d_len-18) return;\n \n-\ttag_count = iw_get_ui16_e(&e->d[ifd],e->endian);\n+\ttag_count = get_exif_ui16(e, ifd);\n \tif(tag_count>1000) return; // Sanity check.\n \n \tfor(i=0;i<tag_count;i++) {\n \t\ttag_pos = ifd+2+i*12;\n \t\tif(tag_pos+12 > e->d_len) return; // Avoid overruns.\n-\t\ttag_id = iw_get_ui16_e(&e->d[tag_pos],e->endian);\n+\t\ttag_id = get_exif_ui16(e, tag_pos);\n \n \t\tswitch(tag_id) {\n \t\tcase 274: // 274 = Orientation\n@@ -177,7 +189,7 @@ static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n \n \te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n \n-\tifd = iw_get_ui32_e(&d[4],e.endian);\n+\tifd = get_exif_ui32(&e, 4);\n \n \tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "348e606cc14619549f6ab61cd40272e007c843e5",
            "date": "2023-03-19T16:14:20Z",
            "author_login": "jsummers"
          },
          {
            "sha": "6a43f725425bec281ccca7f5c690379c680e7fa2",
            "date": "2022-11-22T12:59:40Z",
            "author_login": "jsummers"
          },
          {
            "sha": "8484ed7ed42b46d5128f29bd9fbbca6ec16529ec",
            "date": "2022-11-15T20:18:16Z",
            "author_login": "jsummers"
          },
          {
            "sha": "e735cdf1635958a1c4aea64d71d033064eb64bef",
            "date": "2022-11-15T20:09:15Z",
            "author_login": "jsummers"
          },
          {
            "sha": "a3d1390cc3a381ce9a7a4daf949be930fdc0bc0d",
            "date": "2022-11-15T18:19:31Z",
            "author_login": "jsummers"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-125",
    "description": "The iw_get_ui16be function in imagew-util.c:422:24 in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (invalid read and SEGV) via a crafted image, related to imagew-jpeg.c.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-05-23T04:29:04.570",
    "last_modified": "2024-11-21T03:35:34.887",
    "fix_date": "2017-05-14T16:37:43Z"
  },
  "references": [
    {
      "url": "https://blogs.gentoo.org/ago/2017/05/20/imageworsener-multiple-vulnerabilities/",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/jsummers/imageworsener/commit/b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://blogs.gentoo.org/ago/2017/05/20/imageworsener-multiple-vulnerabilities/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/jsummers/imageworsener/commit/b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:01.639603",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "imageworsener",
    "owner": "jsummers",
    "created_at": "2011-02-08T00:35:27Z",
    "updated_at": "2024-12-15T08:40:40Z",
    "pushed_at": "2024-01-16T03:30:19Z",
    "size": 2015,
    "stars": 257,
    "forks": 30,
    "open_issues": 11,
    "watchers": 257,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 517703,
      "Shell": 17237,
      "M4": 3490,
      "Makefile": 3335
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0.0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:15:29.806717"
  }
}