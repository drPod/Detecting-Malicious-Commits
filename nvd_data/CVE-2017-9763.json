{
  "cve_id": "CVE-2017-9763",
  "github_data": {
    "repository": "radare/radare2",
    "fix_commit": "65000a7fd9eea62359e6d6714f17b94a99a82edd",
    "related_commits": [
      "65000a7fd9eea62359e6d6714f17b94a99a82edd",
      "65000a7fd9eea62359e6d6714f17b94a99a82edd"
    ],
    "patch_url": "https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd.patch",
    "fix_commit_details": {
      "sha": "65000a7fd9eea62359e6d6714f17b94a99a82edd",
      "commit_date": "2017-06-12T07:57:30Z",
      "author": {
        "login": "radare",
        "type": "User",
        "stats": {
          "total_commits": 16356,
          "average_weekly_commits": 19.635054021608642,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 785
        }
      },
      "commit_message": {
        "title": "Fix #7723 - crash in ext2 GRUB code because of variable size array in stack",
        "length": 75,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 98,
        "additions": 59,
        "deletions": 39
      },
      "files": [
        {
          "filename": "libr/core/cmd_mount.c",
          "status": "modified",
          "additions": 7,
          "deletions": 4,
          "patch": "@@ -35,8 +35,9 @@ static int cmd_mount(void *data, const char *_input) {\n \tswitch (*input) {\n \tcase ' ':\n \t\tinput++;\n-\t\tif (input[0]==' ')\n+\t\tif (input[0]==' ') {\n \t\t\tinput++;\n+\t\t}\n \t\tptr = strchr (input, ' ');\n \t\tif (ptr) {\n \t\t\t*ptr = 0;\n@@ -46,13 +47,15 @@ static int cmd_mount(void *data, const char *_input) {\n \t\t\t\t*ptr2 = 0;\n \t\t\t\toff = r_num_math (core->num, ptr2+1);\n \t\t\t}\n-\t\t\tif (!r_fs_mount (core->fs, ptr, input, off))\n+\t\t\tif (!r_fs_mount (core->fs, ptr, input, off)) {\n \t\t\t\teprintf (\"Cannot mount %s\\n\", input);\n+\t\t\t}\n \t\t} else {\n-\t\t\tif (!(ptr = r_fs_name (core->fs, core->offset)))\n+\t\t\tif (!(ptr = r_fs_name (core->fs, core->offset))) {\n \t\t\t\teprintf (\"Unknown filesystem type\\n\");\n-\t\t\telse if (!r_fs_mount (core->fs, ptr, input, core->offset))\n+\t\t\t} else if (!r_fs_mount (core->fs, ptr, input, core->offset)) {\n \t\t\t\teprintf (\"Cannot mount %s\\n\", input);\n+\t\t\t}\n \t\t\tfree (ptr);\n \t\t}\n \t\tbreak;"
        },
        {
          "filename": "shlr/grub/fs/ext2.c",
          "status": "modified",
          "additions": 24,
          "deletions": 13,
          "patch": "@@ -42,6 +42,7 @@\n #define FILETYPE_INO_DIRECTORY\t0040000\n #define FILETYPE_INO_SYMLINK\t0120000\n \n+#include <stdlib.h>\n #include <grub/err.h>\n #include <grub/file.h>\n #include <grub/mm.h>\n@@ -367,8 +368,9 @@ grub_ext4_find_leaf (struct grub_ext2_data *data, char *buf,\n       block = (block << 32) + grub_le_to_cpu32 (index[i].leaf);\n       if (grub_disk_read (data->disk,\n                           block << LOG2_EXT2_BLOCK_SIZE (data),\n-                          0, EXT2_BLOCK_SIZE(data), buf))\n+                          0, EXT2_BLOCK_SIZE(data), buf)) {\n         return 0;\n+      }\n \n       ext_block = (struct grub_ext4_extent_header *) buf;\n     }\n@@ -385,11 +387,10 @@ grub_ext2_read_block (grub_fshelp_node_t node, grub_disk_addr_t fileblock)\n \n   if (grub_le_to_cpu32(inode->flags) & EXT4_EXTENTS_FLAG)\n     {\n-#ifndef _MSC_VER\n-\t  char buf[EXT2_BLOCK_SIZE (data)];\n-#else\n-\t  char * buf = grub_malloc (EXT2_BLOCK_SIZE(data));\n-#endif\n+\t  char * buf = grub_malloc (EXT2_BLOCK_SIZE (data));\n+          if (!buf) {\n+              return -1;\n+          }\n       struct grub_ext4_extent_header *leaf;\n       struct grub_ext4_extent *ext;\n       int i;\n@@ -400,6 +401,7 @@ grub_ext2_read_block (grub_fshelp_node_t node, grub_disk_addr_t fileblock)\n       if (! leaf)\n         {\n           grub_error (GRUB_ERR_BAD_FS, \"invalid extent\");\n+\t  free (buf);\n           return -1;\n         }\n \n@@ -413,23 +415,27 @@ grub_ext2_read_block (grub_fshelp_node_t node, grub_disk_addr_t fileblock)\n       if (--i >= 0)\n         {\n           fileblock -= grub_le_to_cpu32 (ext[i].block);\n-          if (fileblock >= grub_le_to_cpu16 (ext[i].len))\n+          if (fileblock >= grub_le_to_cpu16 (ext[i].len)) {\n+  \t    free (buf);\n             return 0;\n-          else\n+          } else\n             {\n               grub_disk_addr_t start;\n \n               start = grub_le_to_cpu16 (ext[i].start_hi);\n               start = (start << 32) + grub_le_to_cpu32 (ext[i].start);\n+  \t    free (buf);\n \n               return fileblock + start;\n             }\n         }\n       else\n         {\n           grub_error (GRUB_ERR_BAD_FS, \"something wrong with extent\");\n+  \t    free (buf);\n           return -1;\n         }\n+free (buf);\n     }\n   /* Direct blocks.  */\n   if (fileblock < INDIRECT_BLOCKS) {\n@@ -440,15 +446,17 @@ grub_ext2_read_block (grub_fshelp_node_t node, grub_disk_addr_t fileblock)\n       grub_uint32_t *indir;\n \n       indir = grub_malloc (blksz);\n-      if (! indir)\n+      if (! indir) {\n \treturn grub_errno;\n+}\n \n       if (grub_disk_read (data->disk,\n \t\t\t  ((grub_disk_addr_t)\n \t\t\t   grub_le_to_cpu32 (inode->blocks.indir_block))\n \t\t\t  << log2_blksz,\n-\t\t\t  0, blksz, indir))\n+\t\t\t  0, blksz, indir)) {\n \treturn grub_errno;\n+}\n \n       blknr = grub_le_to_cpu32 (indir[fileblock - INDIRECT_BLOCKS]);\n       grub_free (indir);\n@@ -463,22 +471,25 @@ grub_ext2_read_block (grub_fshelp_node_t node, grub_disk_addr_t fileblock)\n       grub_uint32_t *indir;\n \n       indir = grub_malloc (blksz);\n-      if (! indir)\n+      if (! indir) {\n \treturn grub_errno;\n+}\n \n       if (grub_disk_read (data->disk,\n \t\t\t  ((grub_disk_addr_t)\n \t\t\t   grub_le_to_cpu32 (inode->blocks.double_indir_block))\n \t\t\t  << log2_blksz,\n-\t\t\t  0, blksz, indir))\n+\t\t\t  0, blksz, indir)) {\n \treturn grub_errno;\n+}\n \n       if (grub_disk_read (data->disk,\n \t\t\t  ((grub_disk_addr_t)\n \t\t\t   grub_le_to_cpu32 (indir[rblock / perblock]))\n \t\t\t  << log2_blksz,\n-\t\t\t  0, blksz, indir))\n+\t\t\t  0, blksz, indir)) {\n \treturn grub_errno;\n+}\n \n       blknr = grub_le_to_cpu32 (indir[rblock % perblock]);\n             grub_free (indir);"
        },
        {
          "filename": "shlr/grub/fs/fshelp.c",
          "status": "modified",
          "additions": 10,
          "deletions": 5,
          "patch": "@@ -91,11 +91,7 @@ find_file (const char *currpath, grub_fshelp_node_t currroot,\n \t   grub_fshelp_node_t *currfound,\n \t   struct grub_fshelp_find_file_closure *c)\n {\n-#ifndef _MSC_VER\n-\tchar fpath[grub_strlen (currpath) + 1];\n-#else\n \tchar *fpath = grub_malloc (grub_strlen (currpath) + 1);\n-#endif\n   char *name = fpath;\n   char *next;\n   enum grub_fshelp_filetype type = GRUB_FSHELP_DIR;\n@@ -113,6 +109,7 @@ find_file (const char *currpath, grub_fshelp_node_t currroot,\n   if (! *name)\n     {\n       *currfound = currnode;\n+free (fpath);\n       return 0;\n     }\n \n@@ -135,6 +132,7 @@ find_file (const char *currpath, grub_fshelp_node_t currroot,\n       if (type != GRUB_FSHELP_DIR)\n \t{\n \t  free_node (currnode, c);\n+free (fpath);\n \t  return grub_error (GRUB_ERR_BAD_FILE_TYPE, \"not a directory\");\n \t}\n \n@@ -146,8 +144,10 @@ find_file (const char *currpath, grub_fshelp_node_t currroot,\n       found = c->iterate_dir (currnode, iterate, &cc);\n       if (! found)\n \t{\n-\t  if (grub_errno)\n+\t  if (grub_errno) {\n+free (fpath);\n \t    return grub_errno;\n+}\n \n \t  break;\n \t}\n@@ -162,6 +162,7 @@ find_file (const char *currpath, grub_fshelp_node_t currroot,\n \t    {\n \t      free_node (currnode, c);\n \t      free_node (oldnode, c);\n+free (fpath);\n \t      return grub_error (GRUB_ERR_SYMLINK_LOOP,\n \t\t\t\t \"too deep nesting of symlinks\");\n \t    }\n@@ -172,6 +173,7 @@ find_file (const char *currpath, grub_fshelp_node_t currroot,\n \t  if (!symlink)\n \t    {\n \t      free_node (oldnode, c);\n+free (fpath);\n \t      return grub_errno;\n \t    }\n \n@@ -190,6 +192,7 @@ find_file (const char *currpath, grub_fshelp_node_t currroot,\n \t  if (grub_errno)\n \t    {\n \t      free_node (oldnode, c);\n+free (fpath);\n \t      return grub_errno;\n \t    }\n \t}\n@@ -201,12 +204,14 @@ find_file (const char *currpath, grub_fshelp_node_t currroot,\n \t{\n \t  *currfound = currnode;\n \t  c->foundtype = type;\n+free (fpath);\n \t  return 0;\n \t}\n \n       name = next;\n     }\n \n+free (fpath);\n   return grub_error (GRUB_ERR_FILE_NOT_FOUND, \"file not found\");\n }\n "
        },
        {
          "filename": "shlr/grub/grubfs.c",
          "status": "modified",
          "additions": 17,
          "deletions": 16,
          "patch": "@@ -1,4 +1,4 @@\n-/* radare - LGPL - Copyright 2011 pancake<nopcode.org> */\n+/* radare - LGPL - Copyright 2011-2017 pancake<nopcode.org> */\n \n #include <r_io.h>\n #include <r_fs.h>\n@@ -17,20 +17,20 @@ static void* empty (int sz) {\n }\n \n static grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {\n-\tif (disk != NULL) {\n-\t\tconst int blocksize = 512; // unhardcode 512\n-\t\tint ret;\n-\t\tRIOBind *iob = disk->data;\n-\t\tif (bio) iob = bio;\n-\t\t//printf (\"io %p\\n\", file->root->iob.io);\n-\t\tret = iob->read_at (iob->io, delta+(blocksize*sector),\n-\t\t\t(ut8*)buf, size*blocksize);\n-\t\tif (ret == -1)\n-\t\t\treturn 1;\n-\t\t//printf (\"DISK PTR = %p\\n\", disk->data);\n-\t\t//printf (\"\\nBUF: %x %x %x %x\\n\", buf[0], buf[1], buf[2], buf[3]);\n-\t} else eprintf (\"oops. no disk\\n\");\n-\treturn 0; // 0 is ok\n+\tif (!disk) {\n+\t\teprintf (\"oops. no disk\\n\");\n+\t\treturn 1;\n+\t}\n+\tconst int blocksize = 512; // TODO unhardcode 512\n+\tRIOBind *iob = disk->data;\n+\tif (bio) {\n+\t\tiob = bio;\n+\t}\n+\t//printf (\"io %p\\n\", file->root->iob.io);\n+\tif (iob->read_at (iob->io, delta+(blocksize*sector), (ut8*)buf, size*blocksize) == -1) {\n+\t\treturn 1;\n+\t}\n+\treturn 0;\n }\n \n GrubFS *grubfs_new (struct grub_fs *myfs, void *data) {\n@@ -58,8 +58,9 @@ grub_disk_t grubfs_disk (void *data) {\n \n void grubfs_free (GrubFS *gf) {\n \tif (gf) {\n-\t\tif (gf->file && gf->file->device)\n+\t\tif (gf->file && gf->file->device) {\n \t\t\tfree (gf->file->device->disk);\n+\t\t}\n \t\t//free (gf->file->device);\n \t\tfree (gf->file);\n \t\tfree (gf);"
        },
        {
          "filename": "sys/rebuild.sh",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -72,7 +72,7 @@ RebuildGdb() {\n }\n \n case \"$1\" in\n-fs)     RebuildFs; ;;\n+grub|fs)RebuildFs; ;;\n bin)    RebuildBin ; ;;\n gdb)    RebuildGdb ; ;;\n sdb)    RebuildSdb ; ;;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "bf1558f840f834098011062a4ab5013d4fe3b040",
            "date": "2025-01-14T21:59:45Z",
            "author_login": "radare"
          },
          {
            "sha": "01c8ba5cc4ec0ff667370b38e10806a0ea4b501f",
            "date": "2025-01-14T21:25:37Z",
            "author_login": "radare"
          },
          {
            "sha": "ddacbae857aed8a71a22af3ae5f0d789b0edbfeb",
            "date": "2025-01-14T21:25:11Z",
            "author_login": "radare"
          },
          {
            "sha": "bf6227e9295110ab97c8cf3237914acd6cfa09b0",
            "date": "2024-12-27T21:02:32Z",
            "author_login": "dennis-doyensec"
          },
          {
            "sha": "a7e958f9ebdf9771c36e8376078f027792981fea",
            "date": "2025-01-14T17:22:24Z",
            "author_login": "radare"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-119",
    "description": "The grub_ext2_read_block function in fs/ext2.c in GNU GRUB before 2013-11-12, as used in shlr/grub/fs/ext2.c in radare2 1.5.0, allows remote attackers to cause a denial of service (excessive stack use and application crash) via a crafted binary file, related to use of a variable-size stack array.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2017-06-19T16:29:00.797",
    "last_modified": "2024-11-21T03:36:47.567",
    "fix_date": "2017-06-12T07:57:30Z"
  },
  "references": [
    {
      "url": "http://git.savannah.gnu.org/cgit/grub.git/commit/grub-core/fs/ext2.c?id=ac8cac1dac50daaf1c390d701cca3b55e16ee768",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/99141",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/radare/radare2/issues/7723",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://git.savannah.gnu.org/cgit/grub.git/commit/grub-core/fs/ext2.c?id=ac8cac1dac50daaf1c390d701cca3b55e16ee768",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/99141",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/radare/radare2/issues/7723",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:01.660994",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "radare2",
    "owner": "radare",
    "created_at": "2012-07-03T07:42:26Z",
    "updated_at": "2025-01-14T11:39:09Z",
    "pushed_at": "2025-01-14T11:39:05Z",
    "size": 182812,
    "stars": 20990,
    "forks": 3027,
    "open_issues": 874,
    "watchers": 20990,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 29143253,
      "Makefile": 262919,
      "Shell": 145034,
      "Meson": 123192,
      "C++": 82794,
      "HTML": 55704,
      "Rebol": 54153,
      "Python": 38146,
      "Roff": 36722,
      "JavaScript": 23584,
      "CSS": 19465,
      "Batchfile": 8970,
      "Perl": 6449,
      "sed": 4448,
      "R": 1960,
      "Rez": 1386,
      "Assembly": 939,
      "Vala": 839,
      "Wren": 460,
      "Gnuplot": 429,
      "C#": 164,
      "Dart": 125,
      "Rascal": 45
    },
    "commit_activity": {
      "total_commits_last_year": 1594,
      "avg_commits_per_week": 30.653846153846153,
      "days_active_last_year": 294
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:06:47.409274"
  }
}