{
  "cve_id": "CVE-2018-1000129",
  "github_data": {
    "repository": "rhuss/jolokia",
    "fix_commit": "5895d5c137c335e6b473e9dcb9baf748851bbc5f",
    "related_commits": [
      "5895d5c137c335e6b473e9dcb9baf748851bbc5f",
      "5895d5c137c335e6b473e9dcb9baf748851bbc5f"
    ],
    "patch_url": "https://github.com/rhuss/jolokia/commit/5895d5c137c335e6b473e9dcb9baf748851bbc5f.patch",
    "fix_commit_details": {
      "sha": "5895d5c137c335e6b473e9dcb9baf748851bbc5f",
      "commit_date": "2018-01-24T09:35:53Z",
      "author": {
        "login": "rhuss",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix: Verify a given 'mimeType' and/or 'callback' request parameter",
        "length": 145,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 270,
        "additions": 242,
        "deletions": 28
      },
      "files": [
        {
          "filename": "agent/core/src/main/java/org/jolokia/http/AgentServlet.java",
          "status": "modified",
          "additions": 21,
          "deletions": 11,
          "patch": "@@ -264,20 +264,28 @@ protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throw\n     @SuppressWarnings({ \"PMD.AvoidCatchingThrowable\", \"PMD.AvoidInstanceofChecksInCatchClause\" })\n     private void handle(ServletRequestHandler pReqHandler,HttpServletRequest pReq, HttpServletResponse pResp) throws IOException {\n         JSONAware json = null;\n+\n         try {\n             // Check access policy\n             requestHandler.checkAccess(allowDnsReverseLookup ? pReq.getRemoteHost() : null,\n                                        pReq.getRemoteAddr(),\n                                        getOriginOrReferer(pReq));\n \n+            // If a callback is given, check this is a valid javascript function name\n+            validateCallbackIfGiven(pReq);\n+\n             // Remember the agent URL upon the first request. Needed for discovery\n             updateAgentDetailsIfNeeded(pReq);\n \n             // Dispatch for the proper HTTP request method\n             json = handleSecurely(pReqHandler, pReq, pResp);\n         } catch (Throwable exp) {\n-            json = requestHandler.handleThrowable(\n+            try {\n+                json = requestHandler.handleThrowable(\n                     exp instanceof RuntimeMBeanException ? ((RuntimeMBeanException) exp).getTargetException() : exp);\n+            } catch (Throwable exp2) {\n+                exp2.printStackTrace();\n+            }\n         } finally {\n             setCorsHeader(pReq, pResp);\n \n@@ -289,6 +297,7 @@ private void handle(ServletRequestHandler pReqHandler,HttpServletRequest pReq, H\n         }\n     }\n \n+\n     private JSONAware handleSecurely(final ServletRequestHandler pReqHandler, final HttpServletRequest pReq, final HttpServletResponse pResp) throws IOException, PrivilegedActionException {\n         Subject subject = (Subject) pReq.getAttribute(ConfigKey.JAAS_SUBJECT_REQUEST_ATTRIBUTE);\n         if (subject != null) {\n@@ -380,15 +389,6 @@ private void setCorsHeader(HttpServletRequest pReq, HttpServletResponse pResp) {\n         }\n     }\n \n-    // Extract mime type for response (if not JSONP)\n-    private String getMimeType(HttpServletRequest pReq) {\n-        String requestMimeType = pReq.getParameter(ConfigKey.MIME_TYPE.getKeyValue());\n-        if (requestMimeType != null) {\n-            return requestMimeType;\n-        }\n-        return configMimeType;\n-    }\n-\n     private boolean isStreamingEnabled(HttpServletRequest pReq) {\n         String streamingFromReq = pReq.getParameter(ConfigKey.STREAMING.getKeyValue());\n         if (streamingFromReq != null) {\n@@ -470,8 +470,12 @@ Configuration initConfig(ServletConfig pConfig) {\n \n     private void sendResponse(HttpServletResponse pResp, HttpServletRequest pReq, JSONAware pJson) throws IOException {\n         String callback = pReq.getParameter(ConfigKey.CALLBACK.getKeyValue());\n-        setContentType(pResp, callback != null ? \"text/javascript\" : getMimeType(pReq));\n \n+        setContentType(pResp,\n+                       MimeTypeUtil.getResponseMimeType(\n+                           pReq.getParameter(ConfigKey.MIME_TYPE.getKeyValue()),\n+                           configMimeType, callback\n+                                                       ));\n         pResp.setStatus(HttpServletResponse.SC_OK);\n         setNoCacheHeaders(pResp);\n         if (pJson == null) {\n@@ -487,6 +491,12 @@ private void sendResponse(HttpServletResponse pResp, HttpServletRequest pReq, JS\n         }\n     }\n \n+    private void validateCallbackIfGiven(HttpServletRequest pReq) {\n+        String callback = pReq.getParameter(ConfigKey.CALLBACK.getKeyValue());\n+        if (callback != null && !MimeTypeUtil.isValidCallback(callback)) {\n+            throw new IllegalArgumentException(\"Invalid callback name given, which must be a valid javascript function name\");\n+        }\n+    }\n     private void sendStreamingResponse(HttpServletResponse pResp, String pCallback, JSONStreamAware pJson) throws IOException {\n         Writer writer = new OutputStreamWriter(pResp.getOutputStream(), \"UTF-8\");\n         IoUtil.streamResponseAndClose(writer, pJson, pCallback);"
        },
        {
          "filename": "agent/core/src/main/java/org/jolokia/util/MimeTypeUtil.java",
          "status": "added",
          "additions": 74,
          "deletions": 0,
          "patch": "@@ -0,0 +1,74 @@\n+package org.jolokia.util;\n+\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Helper class for handling proper response mime types\n+ *\n+ * @author roland\n+ * @since 24.01.18\n+ */\n+public class MimeTypeUtil {\n+\n+\n+    /**\n+     * Extract the response mime type. This value is calculated for different situations:\n+     * <p>\n+     * <ul>\n+     * <li>If a callback is given and its valid, the mime type is \"text/javascript\"</li>\n+     * <li>Otherwise:\n+     * <ul>\n+     * <li>If a valid mimeType is given in the request (\"text/plain\", \"application/json\"), then this\n+     * mimet type is returned</li>\n+     * <li>If another mimeType is given, then \"text/plain\" is used</li>\n+     * <li>If no mimeType is given then a given default mime type is used, but also sanitized\n+     * as described above</li>\n+     * </ul>\n+     * </li>\n+     * </ul>\n+     *\n+     * @param pRequestMimeType the mimetype given in the request\n+     * @param defaultMimeType  the default mime type to use if none is given in the request\n+     * @param pCallback        a callback given (can be null)\n+     */\n+    public static String getResponseMimeType(String pRequestMimeType, String defaultMimeType, String pCallback) {\n+\n+        // For a valid given callback, return \"text/javascript\" for proper inclusion\n+        if (pCallback != null && isValidCallback(pCallback)) {\n+            return \"text/javascript\";\n+        }\n+\n+        // Pick up mime time from request, but sanitize\n+        if (pRequestMimeType != null) {\n+            return sanitize(pRequestMimeType);\n+        }\n+\n+        // Use the given default mime type (possibly picked up from a configuration)\n+        return sanitize(defaultMimeType);\n+    }\n+\n+    private static String sanitize(String mimeType) {\n+        for (String accepted : new String[]{\n+            \"application/json\",\n+            \"text/plain\"\n+        }) {\n+            if (accepted.equalsIgnoreCase(mimeType)) {\n+                return accepted;\n+            }\n+        }\n+        return \"text/plain\";\n+    }\n+\n+    /**\n+     * Check that a callback matches a javascript function name. The argument must be not null\n+     *\n+     * @param pCallback callback to verify\n+     * @return true if valud, false otherwise\n+     */\n+    public static boolean isValidCallback(String pCallback) {\n+        Pattern validJavaScriptFunctionNamePattern =\n+            Pattern.compile(\"^[$A-Z_][0-9A-Z_$]*$\", Pattern.CASE_INSENSITIVE);\n+        return validJavaScriptFunctionNamePattern.matcher(pCallback).matches();\n+    }\n+\n+}\n\\ No newline at end of file"
        },
        {
          "filename": "agent/core/src/test/java/org/jolokia/http/AgentServletTest.java",
          "status": "modified",
          "additions": 67,
          "deletions": 3,
          "patch": "@@ -113,7 +113,7 @@ public void configWithOverWrite() throws ServletException {\n     }\n \n     @Test\n-    public void initWithcustomAccessRestrictor() throws ServletException {\n+    public void initWithCustomAccessRestrictor() throws ServletException {\n         prepareStandardInitialisation();\n         servlet.destroy();\n     }\n@@ -251,6 +251,44 @@ public void simpleGet() throws ServletException, IOException {\n         servlet.destroy();\n     }\n \n+    @Test\n+    public void simpleGetWithWrongMimeType() throws ServletException, IOException {\n+        checkMimeTypes(\"text/html\", \"text/plain\");\n+    }\n+\n+    @Test\n+    public void simpleGetWithTextPlainMimeType() throws ServletException, IOException {\n+        checkMimeTypes(\"text/plain\", \"text/plain\");\n+    }\n+\n+    @Test\n+    public void simpleGetWithApplicationJsonMimeType() throws ServletException, IOException {\n+        checkMimeTypes(\"application/json\", \"application/json\");\n+    }\n+\n+    private void checkMimeTypes(String given, final String expected) throws ServletException, IOException {\n+        prepareStandardInitialisation();\n+\n+        initRequestResponseMocks(\n+            getStandardRequestSetup(),\n+            new Runnable() {\n+                public void run() {\n+                    response.setCharacterEncoding(\"utf-8\");\n+                    // The default content type\n+                    response.setContentType(expected);\n+                    response.setStatus(200);\n+                }\n+            });\n+        expect(request.getPathInfo()).andReturn(HttpTestUtil.HEAP_MEMORY_GET_REQUEST);\n+        expect(request.getParameter(ConfigKey.MIME_TYPE.getKeyValue())).andReturn(given);\n+        replay(request, response);\n+\n+        servlet.doGet(request, response);\n+\n+        verifyMocks();\n+        servlet.destroy();\n+    }\n+\n     @Test\n     public void simpleGetWithNoReverseDnsLookupFalse() throws ServletException, IOException {\n         checkNoReverseDns(false,\"127.0.0.1\");\n@@ -484,6 +522,7 @@ public void run() {\n                 });\n         expect(request.getPathInfo()).andReturn(HttpTestUtil.HEAP_MEMORY_GET_REQUEST);\n         expect(request.getAttribute(\"subject\")).andReturn(null);\n+        expect(request.getParameter(ConfigKey.MIME_TYPE.getKeyValue())).andReturn(null);\n \n         replay(request, response);\n \n@@ -493,6 +532,30 @@ public void run() {\n         servlet.destroy();\n     }\n \n+    @Test\n+    public void withInvalidCallback() throws IOException, ServletException {\n+        servlet = new AgentServlet(new AllowAllRestrictor());\n+        initConfigMocks(null, null,\"Error 400\", IllegalArgumentException.class);\n+        replay(config, context);\n+        servlet.init(config);\n+        ByteArrayOutputStream sw = initRequestResponseMocks(\n+            \"doSomethingEvil(); myCallback\",\n+            getStandardRequestSetup(),\n+            getStandardResponseSetup());\n+        expect(request.getPathInfo()).andReturn(HttpTestUtil.HEAP_MEMORY_GET_REQUEST);\n+        expect(request.getAttribute(\"subject\")).andReturn(null);\n+        expect(request.getParameter(ConfigKey.MIME_TYPE.getKeyValue())).andReturn(null);\n+\n+        replay(request, response);\n+\n+        servlet.doGet(request, response);\n+        String resp = sw.toString();\n+        assertTrue(resp.contains(\"error_type\"));\n+        assertTrue(resp.contains(\"IllegalArgumentException\"));\n+        assertTrue(resp.matches(\".*status.*400.*\"));\n+        servlet.destroy();\n+    }\n+\n     @Test\n     public void withException() throws ServletException, IOException {\n         servlet = new AgentServlet(new AllowAllRestrictor());\n@@ -606,7 +669,7 @@ private ByteArrayOutputStream initRequestResponseMocks(String callback,Runnable\n         response = createMock(HttpServletResponse.class);\n         setNoCacheHeaders(response);\n \n-        expect(request.getParameter(ConfigKey.CALLBACK.getKeyValue())).andReturn(callback);\n+        expect(request.getParameter(ConfigKey.CALLBACK.getKeyValue())).andReturn(callback).anyTimes();\n         requestSetup.run();\n         responseSetup.run();\n \n@@ -648,6 +711,7 @@ private Runnable getStandardResponseSetup() {\n         return new Runnable() {\n             public void run() {\n                 response.setCharacterEncoding(\"utf-8\");\n+                // The default content type\n                 response.setContentType(\"text/plain\");\n                 response.setStatus(200);\n             }\n@@ -690,7 +754,7 @@ public void run() {\n                 expect(request.getAttribute(ConfigKey.JAAS_SUBJECT_REQUEST_ATTRIBUTE)).andReturn(null);\n \n                 expect(request.getPathInfo()).andReturn(HttpTestUtil.HEAP_MEMORY_GET_REQUEST);\n-                expect(request.getParameter(ConfigKey.MIME_TYPE.getKeyValue())).andReturn(\"text/plain\");\n+                expect(request.getParameter(ConfigKey.MIME_TYPE.getKeyValue())).andReturn(\"text/plain\").anyTimes();\n                 StringBuffer buf = new StringBuffer();\n                 buf.append(url).append(HttpTestUtil.HEAP_MEMORY_GET_REQUEST);\n                 expect(request.getRequestURL()).andReturn(buf);"
        },
        {
          "filename": "agent/jvm/src/main/java/org/jolokia/jvmagent/handler/JolokiaHttpHandler.java",
          "status": "modified",
          "additions": 19,
          "deletions": 13,
          "patch": "@@ -224,6 +224,9 @@ public void doHandle(HttpExchange pExchange) throws IOException {\n                                        extractOriginOrReferer(pExchange));\n             String method = pExchange.getRequestMethod();\n \n+            // If a callback is given, check this is a valid javascript function name\n+            validateCallbackIfGiven(parsedUri);\n+\n             // Dispatch for the proper HTTP request method\n             if (\"GET\".equalsIgnoreCase(method)) {\n                 setHeaders(pExchange);\n@@ -244,6 +247,14 @@ public void doHandle(HttpExchange pExchange) throws IOException {\n         }\n     }\n \n+\n+    private void validateCallbackIfGiven(ParsedUri pUri) {\n+        String callback = pUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n+        if (callback != null && !MimeTypeUtil.isValidCallback(callback)) {\n+            throw new IllegalArgumentException(\"Invalid callback name given, which must be a valid javascript function name\");\n+        }\n+    }\n+\n     // ========================================================================\n \n     // Used for checking origin or referer is an origin policy is enabled\n@@ -342,10 +353,11 @@ private void sendStreamingResponse(HttpExchange pExchange, ParsedUri pParsedUri,\n         Headers headers = pExchange.getResponseHeaders();\n         if (pJson != null) {\n             headers.set(\"Content-Type\", getMimeType(pParsedUri) + \"; charset=utf-8\");\n-            String callback = pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n             pExchange.sendResponseHeaders(200, 0);\n             Writer writer = new OutputStreamWriter(pExchange.getResponseBody(), \"UTF-8\");\n-            IoUtil.streamResponseAndClose(writer, pJson, callback);\n+\n+            String callback = pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n+            IoUtil.streamResponseAndClose(writer, pJson, callback != null && MimeTypeUtil.isValidCallback(callback) ? callback : null);\n         } else {\n             headers.set(\"Content-Type\", \"text/plain\");\n             pExchange.sendResponseHeaders(200,-1);\n@@ -360,7 +372,7 @@ private void sendAllJSON(HttpExchange pExchange, ParsedUri pParsedUri, JSONAware\n                 headers.set(\"Content-Type\", getMimeType(pParsedUri) + \"; charset=utf-8\");\n                 String json = pJson.toJSONString();\n                 String callback = pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n-                String content = callback == null ? json : callback + \"(\" + json + \");\";\n+                String content = callback != null && MimeTypeUtil.isValidCallback(callback) ? callback + \"(\" + json + \");\" : json;\n                 byte[] response = content.getBytes(\"UTF8\");\n                 pExchange.sendResponseHeaders(200,response.length);\n                 out = pExchange.getResponseBody();\n@@ -380,16 +392,10 @@ private void sendAllJSON(HttpExchange pExchange, ParsedUri pParsedUri, JSONAware\n \n     // Get the proper mime type according to configuration\n     private String getMimeType(ParsedUri pParsedUri) {\n-        if (pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue()) != null) {\n-            return \"text/javascript\";\n-        } else {\n-            String mimeType = pParsedUri.getParameter(ConfigKey.MIME_TYPE.getKeyValue());\n-            if (mimeType != null) {\n-                return mimeType;\n-            }\n-            mimeType = configuration.get(ConfigKey.MIME_TYPE);\n-            return mimeType != null ? mimeType : ConfigKey.MIME_TYPE.getDefaultValue();\n-        }\n+        return MimeTypeUtil.getResponseMimeType(\n+            pParsedUri.getParameter(ConfigKey.MIME_TYPE.getKeyValue()),\n+            configuration.get(ConfigKey.MIME_TYPE),\n+            pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue()));\n     }\n \n     // Creat a log handler from either the given class or by creating a default log handler printing"
        },
        {
          "filename": "agent/jvm/src/test/java/org/jolokia/jvmagent/handler/JolokiaHttpHandlerTest.java",
          "status": "modified",
          "additions": 61,
          "deletions": 1,
          "patch": "@@ -74,14 +74,74 @@ public void testCallbackGet() throws IOException, URISyntaxException {\n         assertTrue(result.startsWith(\"data({\"));\n     }\n \n+\n+    @Test\n+    public void testInvalidMimeType() throws IOException, URISyntaxException {\n+        checkMimeType(\"text/html\", \"text/plain\");\n+    }\n+\n+    @Test\n+    public void testMimeTypeApplicationJson() throws IOException, URISyntaxException {\n+        checkMimeType(\"application/json\", \"application/json\");\n+    }\n+\n+    private void checkMimeType(String given, String expected) throws IOException, URISyntaxException {\n+        HttpExchange exchange = prepareExchange(\"http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage?mimeType=\" + given);\n+\n+        // Simple GET method\n+        expect(exchange.getRequestMethod()).andReturn(\"GET\");\n+\n+        Headers header = new Headers();\n+        ByteArrayOutputStream out = prepareResponse(handler, exchange, header);\n+\n+        handler.doHandle(exchange);\n+\n+        assertEquals(header.getFirst(\"content-type\"),expected + \"; charset=utf-8\");\n+    }\n+\n+    @Test\n+    public void testInvalidCallbackGetStreaming() throws IOException, URISyntaxException, ParseException {\n+        checkInvalidCallback(true);\n+    }\n+\n+    @Test\n+    public void testInvalidCallbackGetNonStreaming() throws IOException, URISyntaxException, ParseException {\n+        checkInvalidCallback(false);\n+    }\n+\n+    private void checkInvalidCallback(boolean streaming) throws URISyntaxException, IOException, ParseException {\n+        JolokiaHttpHandler handler = new JolokiaHttpHandler(getConfig(ConfigKey.SERIALIZE_EXCEPTION, Boolean.toString(streaming)));\n+        handler.start(false);\n+\n+        HttpExchange exchange = prepareExchange(\"http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage?callback=evilCallback();data\");\n+\n+        // Simple GET method\n+        expect(exchange.getRequestMethod()).andReturn(\"GET\");\n+\n+        Headers header = new Headers();\n+        ByteArrayOutputStream out = prepareResponse(handler, exchange, header);\n+\n+        handler.doHandle(exchange);\n+\n+        assertEquals(header.getFirst(\"content-type\"),\"text/plain; charset=utf-8\");\n+        String result = out.toString(\"utf-8\");\n+        JSONObject resp = (JSONObject) new JSONParser().parse(result);\n+        assertTrue(resp.containsKey(\"error\"));\n+        assertEquals(resp.get(\"error_type\"), IllegalArgumentException.class.getName());\n+        assertTrue(((String) resp.get(\"error\")).contains(\"callback\"));\n+        assertFalse(((String) resp.get(\"error\")).contains(\"evilCallback\"));\n+\n+        handler.stop();\n+    }\n+\n+\n     @Test\n     public void testCallbackPost() throws URISyntaxException, IOException, java.text.ParseException {\n         HttpExchange exchange = prepareExchange(\"http://localhost:8080/jolokia?callback=data\",\n                                                 \"Content-Type\",\"text/plain; charset=UTF-8\",\n                                                 \"Origin\",null\n                                                );\n \n-        // Simple GET method\n         prepareMemoryPostReadRequest(exchange);\n         Headers header = new Headers();\n         ByteArrayOutputStream out = prepareResponse(handler, exchange, header);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 5,
        "max_directory_depth": 9
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "83f090377798aefec3773a6e4e9a18c73b674438",
            "date": "2025-01-14T10:54:56Z",
            "author_login": "grgrzybek"
          },
          {
            "sha": "f368d58475462731416df929abd9b44f06b20fcb",
            "date": "2025-01-14T09:23:12Z",
            "author_login": "grgrzybek"
          },
          {
            "sha": "86f1ed453c3e559a410b6587cf3d084eaf758a22",
            "date": "2025-01-14T08:44:11Z",
            "author_login": "grgrzybek"
          },
          {
            "sha": "4e62afe34cd8c5c6d17ec542cc4fe5199eee2476",
            "date": "2025-01-13T13:37:06Z",
            "author_login": "grgrzybek"
          },
          {
            "sha": "b456e7657caf1bcb26b59061409cabdc25356bd3",
            "date": "2025-01-13T09:19:44Z",
            "author_login": "grgrzybek"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-79",
    "description": "An XSS vulnerability exists in the Jolokia agent version 1.3.7 in the HTTP servlet that allows an attacker to execute malicious javascript in the victim's browser.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-03-14T13:29:00.237",
    "last_modified": "2024-11-21T03:39:44.620",
    "fix_date": "2018-01-24T09:35:53Z"
  },
  "references": [
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:2669",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:3817",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/rhuss/jolokia/commit/5895d5c137c335e6b473e9dcb9baf748851bbc5f#diff-f19898247eddb55de6400489bff748ad",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://jolokia.org/#Security_fixes_with_1.5.0",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:2669",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:3817",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/rhuss/jolokia/commit/5895d5c137c335e6b473e9dcb9baf748851bbc5f#diff-f19898247eddb55de6400489bff748ad",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://jolokia.org/#Security_fixes_with_1.5.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:17.559786",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "jolokia",
    "owner": "rhuss",
    "created_at": "2010-07-15T20:08:44Z",
    "updated_at": "2025-01-14T10:55:07Z",
    "pushed_at": "2025-01-14T10:55:03Z",
    "size": 28805,
    "stars": 820,
    "forks": 226,
    "open_issues": 83,
    "watchers": 820,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Java": 2710256,
      "TypeScript": 144067,
      "JavaScript": 121554,
      "CSS": 21160,
      "Shell": 7649,
      "Lex": 5787
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T20:14:22.286822"
  }
}