{
  "cve_id": "CVE-2018-1000850",
  "github_data": {
    "repository": "square/retrofit",
    "fix_commit": "b9a7f6ad72073ddd40254c0058710e87a073047d",
    "related_commits": [
      "b9a7f6ad72073ddd40254c0058710e87a073047d",
      "b9a7f6ad72073ddd40254c0058710e87a073047d"
    ],
    "patch_url": "https://github.com/square/retrofit/commit/b9a7f6ad72073ddd40254c0058710e87a073047d.patch",
    "fix_commit_details": {
      "sha": "b9a7f6ad72073ddd40254c0058710e87a073047d",
      "commit_date": "2018-10-21T20:45:51Z",
      "author": {
        "login": "squarejesse",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Forbid path traversal ('.' and '..') as @Path parameters.",
        "length": 189,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 114,
        "additions": 113,
        "deletions": 1
      },
      "files": [
        {
          "filename": "retrofit/src/main/java/retrofit2/RequestBuilder.java",
          "status": "modified",
          "additions": 23,
          "deletions": 1,
          "patch": "@@ -16,6 +16,7 @@\n package retrofit2;\n \n import java.io.IOException;\n+import java.util.regex.Pattern;\n import javax.annotation.Nullable;\n import okhttp3.FormBody;\n import okhttp3.Headers;\n@@ -32,6 +33,21 @@ final class RequestBuilder {\n       { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n   private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = \" \\\"<>^`{}|\\\\?#\";\n \n+  /**\n+   * Matches strings that contain {@code .} or {@code ..} as a complete path segment. This also\n+   * matches dots in their percent-encoded form, {@code %2E}.\n+   *\n+   * <p>It is okay to have these strings within a larger path segment (like {@code a..z} or {@code\n+   * index.html}) but when alone they have a special meaning. A single dot resolves to no path\n+   * segment so {@code /one/./three/} becomes {@code /one/three/}. A double-dot pops the preceding\n+   * directory, so {@code /one/../three/} becomes {@code /three/}.\n+   *\n+   * <p>We forbid these in Retrofit paths because they're likely to have the unintended effect.\n+   * For example, passing {@code ..} to {@code DELETE /account/book/{isbn}/} yields {@code DELETE\n+   * /account/}.\n+   */\n+  private static final Pattern PATH_TRAVERSAL = Pattern.compile(\"(.*/)?(\\\\.|%2e|%2E){1,2}(/.*)?\");\n+\n   private final String method;\n \n   private final HttpUrl baseUrl;\n@@ -91,7 +107,13 @@ void addPathParam(String name, String value, boolean encoded) {\n       // The relative URL is cleared when the first query parameter is set.\n       throw new AssertionError();\n     }\n-    relativeUrl = relativeUrl.replace(\"{\" + name + \"}\", canonicalizeForPath(value, encoded));\n+    String replacement = canonicalizeForPath(value, encoded);\n+    String newRelativeUrl = relativeUrl.replace(\"{\" + name + \"}\", replacement);\n+    if (PATH_TRAVERSAL.matcher(newRelativeUrl).matches()) {\n+      throw new IllegalArgumentException(\n+          \"@Path parameters shouldn't perform path traversal ('.' or '..'): \" + value);\n+    }\n+    relativeUrl = newRelativeUrl;\n   }\n \n   private static String canonicalizeForPath(String input, boolean alreadyEncoded) {"
        },
        {
          "filename": "retrofit/src/test/java/retrofit2/RequestFactoryTest.java",
          "status": "modified",
          "additions": 90,
          "deletions": 0,
          "patch": "@@ -878,6 +878,88 @@ Call<ResponseBody> method(@Path(value = \"ping\", encoded = true) String ping) {\n     assertThat(request.body()).isNull();\n   }\n \n+  @Test public void pathParametersAndPathTraversal() {\n+    class Example {\n+      @GET(\"/foo/bar/{ping}/\") //\n+      Call<ResponseBody> method(@Path(value = \"ping\") String ping) {\n+        return null;\n+      }\n+    }\n+\n+    assertMalformedRequest(Example.class, \".\");\n+    assertMalformedRequest(Example.class, \"..\");\n+\n+    assertThat(buildRequest(Example.class, \"./a\").url().encodedPath())\n+        .isEqualTo(\"/foo/bar/.%2Fa/\");\n+    assertThat(buildRequest(Example.class, \"a/.\").url().encodedPath())\n+        .isEqualTo(\"/foo/bar/a%2F./\");\n+    assertThat(buildRequest(Example.class, \"a/..\").url().encodedPath())\n+        .isEqualTo(\"/foo/bar/a%2F../\");\n+    assertThat(buildRequest(Example.class, \"../a\").url().encodedPath())\n+        .isEqualTo(\"/foo/bar/..%2Fa/\");\n+    assertThat(buildRequest(Example.class, \"..\\\\..\").url().encodedPath())\n+        .isEqualTo(\"/foo/bar/..%5C../\");\n+\n+    assertThat(buildRequest(Example.class, \"%2E\").url().encodedPath())\n+        .isEqualTo(\"/foo/bar/%252E/\");\n+    assertThat(buildRequest(Example.class, \"%2E%2E\").url().encodedPath())\n+        .isEqualTo(\"/foo/bar/%252E%252E/\");\n+  }\n+\n+  @Test public void encodedPathParametersAndPathTraversal() {\n+    class Example {\n+      @GET(\"/foo/bar/{ping}/\") //\n+      Call<ResponseBody> method(@Path(value = \"ping\", encoded = true) String ping) {\n+        return null;\n+      }\n+    }\n+\n+    assertMalformedRequest(Example.class, \".\");\n+    assertMalformedRequest(Example.class, \"%2E\");\n+    assertMalformedRequest(Example.class, \"%2e\");\n+    assertMalformedRequest(Example.class, \"..\");\n+    assertMalformedRequest(Example.class, \"%2E.\");\n+    assertMalformedRequest(Example.class, \"%2e.\");\n+    assertMalformedRequest(Example.class, \".%2E\");\n+    assertMalformedRequest(Example.class, \".%2e\");\n+    assertMalformedRequest(Example.class, \"%2E%2e\");\n+    assertMalformedRequest(Example.class, \"%2e%2E\");\n+    assertMalformedRequest(Example.class, \"./a\");\n+    assertMalformedRequest(Example.class, \"a/.\");\n+    assertMalformedRequest(Example.class, \"../a\");\n+    assertMalformedRequest(Example.class, \"a/..\");\n+    assertMalformedRequest(Example.class, \"a/../b\");\n+    assertMalformedRequest(Example.class, \"a/%2e%2E/b\");\n+\n+    assertThat(buildRequest(Example.class, \"...\").url().encodedPath())\n+        .isEqualTo(\"/foo/bar/.../\");\n+    assertThat(buildRequest(Example.class, \"a..b\").url().encodedPath())\n+        .isEqualTo(\"/foo/bar/a..b/\");\n+    assertThat(buildRequest(Example.class, \"a..\").url().encodedPath())\n+        .isEqualTo(\"/foo/bar/a../\");\n+    assertThat(buildRequest(Example.class, \"a..b\").url().encodedPath())\n+        .isEqualTo(\"/foo/bar/a..b/\");\n+    assertThat(buildRequest(Example.class, \"..b\").url().encodedPath())\n+        .isEqualTo(\"/foo/bar/..b/\");\n+    assertThat(buildRequest(Example.class, \"..\\\\..\").url().encodedPath())\n+        .isEqualTo(\"/foo/bar/..%5C../\");\n+  }\n+\n+  @Test public void dotDotsOkayWhenNotFullPathSegment() {\n+    class Example {\n+      @GET(\"/foo{ping}bar/\") //\n+      Call<ResponseBody> method(@Path(value = \"ping\", encoded = true) String ping) {\n+        return null;\n+      }\n+    }\n+\n+    assertMalformedRequest(Example.class, \"/./\");\n+    assertMalformedRequest(Example.class, \"/../\");\n+\n+    assertThat(buildRequest(Example.class, \".\").url().encodedPath()).isEqualTo(\"/foo.bar/\");\n+    assertThat(buildRequest(Example.class, \"..\").url().encodedPath()).isEqualTo(\"/foo..bar/\");\n+  }\n+\n   @Test public void pathParamRequired() {\n     class Example {\n       @GET(\"/foo/bar/{ping}/\") //\n@@ -2783,4 +2865,12 @@ static <T> Request buildRequest(Class<T> cls, Object... args) {\n \n     return buildRequest(cls, retrofitBuilder, args);\n   }\n+\n+  static void assertMalformedRequest(Class<?> cls, Object... args) {\n+    try {\n+      Request request = buildRequest(cls, args);\n+      fail(\"expected a malformed request but was \" + request);\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e6a1d5bce7e003923e1c2a6d2c255b276d9b8337",
            "date": "2025-01-10T20:34:35Z",
            "author_login": "JakeWharton"
          },
          {
            "sha": "d0c394b3857f83d3b4210653fed1877857572fe6",
            "date": "2025-01-10T18:55:23Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "68a1f7cbde6aaf5eba2742d9f950c58f19e130c2",
            "date": "2025-01-09T23:16:44Z",
            "author_login": "JakeWharton"
          },
          {
            "sha": "96298b958621361643aa7cde705cfd9122d1ac2e",
            "date": "2025-01-09T23:07:14Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "6b5d65dea63c2449fadd66e8178e6414f195b1a8",
            "date": "2025-01-08T18:32:26Z",
            "author_login": "JakeWharton"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-22",
    "description": "Square Retrofit version versions from (including) 2.0 and 2.5.0 (excluding) contains a Directory Traversal vulnerability in RequestBuilder class, method addPathParameter that can result in By manipulating the URL an attacker could add or delete resources otherwise unavailable to her.. This attack appear to be exploitable via An attacker should have access to an encoded path parameter on POST, PUT or DELETE request.. This vulnerability appears to have been fixed in 2.5.0 and later.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-12-20T15:29:02.423",
    "last_modified": "2024-11-21T03:40:29.607",
    "fix_date": "2018-10-21T20:45:51Z"
  },
  "references": [
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:3892",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/square/retrofit/blob/master/CHANGELOG.md",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/square/retrofit/commit/b9a7f6ad72073ddd40254c0058710e87a073047d#diff-943ec7ed35e68201824904d1dc0ec982",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://ihacktoprotect.com/post/retrofit-path-traversal/",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.apache.org/thread.html/519eb0fd45642dcecd9ff74cb3e71c20a4753f7d82e2f07864b5108f%40%3Cdev.drill.apache.org%3E",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.apache.org/thread.html/b0656d359c7d40ec9f39c8cc61bca66802ef9a2a12ee199f5b0c1442%40%3Cdev.drill.apache.org%3E",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.apache.org/thread.html/f9bc3e55f4e28d1dcd1a69aae6d53e609a758e34d2869b4d798e13cc%40%3Cissues.drill.apache.org%3E",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:3892",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/square/retrofit/blob/master/CHANGELOG.md",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/square/retrofit/commit/b9a7f6ad72073ddd40254c0058710e87a073047d#diff-943ec7ed35e68201824904d1dc0ec982",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://ihacktoprotect.com/post/retrofit-path-traversal/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.apache.org/thread.html/519eb0fd45642dcecd9ff74cb3e71c20a4753f7d82e2f07864b5108f%40%3Cdev.drill.apache.org%3E",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.apache.org/thread.html/b0656d359c7d40ec9f39c8cc61bca66802ef9a2a12ee199f5b0c1442%40%3Cdev.drill.apache.org%3E",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.apache.org/thread.html/f9bc3e55f4e28d1dcd1a69aae6d53e609a758e34d2869b4d798e13cc%40%3Cissues.drill.apache.org%3E",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:42.188935",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "retrofit",
    "owner": "square",
    "created_at": "2010-09-06T21:39:43Z",
    "updated_at": "2025-01-14T07:40:42Z",
    "pushed_at": "2025-01-10T20:34:37Z",
    "size": 5202,
    "stars": 43227,
    "forks": 7312,
    "open_issues": 155,
    "watchers": 43227,
    "has_security_policy": false,
    "default_branch": "trunk",
    "protected_branches": [
      "trunk"
    ],
    "languages": {
      "HTML": 2045275,
      "Java": 1215477,
      "CSS": 81931,
      "Kotlin": 46224,
      "JavaScript": 4962
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T15:08:15.404454"
  }
}