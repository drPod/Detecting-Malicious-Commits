{
  "cve_id": "CVE-2018-10895",
  "github_data": {
    "repository": "qutebrowser/qutebrowser",
    "fix_commit": "43e58ac865ff862c2008c510fc5f7627e10b4660",
    "related_commits": [
      "43e58ac865ff862c2008c510fc5f7627e10b4660",
      "43e58ac865ff862c2008c510fc5f7627e10b4660"
    ],
    "patch_url": "https://github.com/qutebrowser/qutebrowser/commit/43e58ac865ff862c2008c510fc5f7627e10b4660.patch",
    "fix_commit_details": {
      "sha": "43e58ac865ff862c2008c510fc5f7627e10b4660",
      "commit_date": "2018-07-09T21:38:47Z",
      "author": {
        "login": "The-Compiler",
        "type": "User",
        "stats": {
          "total_commits": 18349,
          "average_weekly_commits": 31.636206896551723,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 545
        }
      },
      "commit_message": {
        "title": "CVE-2018-10895: Fix CSRF issues with qute://settings/set URL",
        "length": 624,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 202,
        "additions": 181,
        "deletions": 21
      },
      "files": [
        {
          "filename": "qutebrowser/browser/qutescheme.py",
          "status": "modified",
          "additions": 27,
          "deletions": 1,
          "patch": "@@ -32,9 +32,17 @@\n import mimetypes\n import urllib\n import collections\n+import base64\n+\n+try:\n+    import secrets\n+except ImportError:\n+    # New in Python 3.6\n+    secrets = None\n \n import pkg_resources\n from PyQt5.QtCore import QUrlQuery, QUrl\n+from PyQt5.QtNetwork import QNetworkReply\n \n import qutebrowser\n from qutebrowser.config import config, configdata, configexc, configdiff\n@@ -46,6 +54,7 @@\n \n pyeval_output = \":pyeval was never called\"\n spawn_output = \":spawn was never called\"\n+csrf_token = None\n \n \n _HANDLERS = {}\n@@ -449,12 +458,29 @@ def _qute_settings_set(url):\n @add_handler('settings')\n def qute_settings(url):\n     \"\"\"Handler for qute://settings. View/change qute configuration.\"\"\"\n+    global csrf_token\n+\n     if url.path() == '/set':\n+        if url.password() != csrf_token:\n+            message.error(\"Invalid CSRF token for qute://settings!\")\n+            raise QuteSchemeError(\"Invalid CSRF token!\",\n+                                  QNetworkReply.ContentAccessDenied)\n         return _qute_settings_set(url)\n \n+    # Requests to qute://settings/set should only be allowed from\n+    # qute://settings. As an additional security precaution, we generate a CSRF\n+    # token to use here.\n+    if secrets:\n+        csrf_token = secrets.token_urlsafe()\n+    else:\n+        # On Python < 3.6, from secrets.py\n+        token = base64.urlsafe_b64encode(os.urandom(32))\n+        csrf_token = token.rstrip(b'=').decode('ascii')\n+\n     src = jinja.render('settings.html', title='settings',\n                        configdata=configdata,\n-                       confget=config.instance.get_str)\n+                       confget=config.instance.get_str,\n+                       csrf_token=csrf_token)\n     return 'text/html', src\n \n "
        },
        {
          "filename": "qutebrowser/browser/webengine/interceptor.py",
          "status": "modified",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -19,6 +19,7 @@\n \n \"\"\"A request interceptor taking care of adblocking and custom headers.\"\"\"\n \n+from PyQt5.QtCore import QUrl\n from PyQt5.QtWebEngineCore import (QWebEngineUrlRequestInterceptor,\n                                    QWebEngineUrlRequestInfo)\n \n@@ -69,6 +70,18 @@ def interceptRequest(self, info):\n                                   resource_type, navigation_type))\n \n         url = info.requestUrl()\n+        firstparty = info.firstPartyUrl()\n+\n+        if ((url.scheme(), url.host(), url.path()) ==\n+                ('qute', 'settings', '/set')):\n+            if (firstparty != QUrl('qute://settings/') or\n+                    info.resourceType() !=\n+                    QWebEngineUrlRequestInfo.ResourceTypeXhr):\n+                log.webview.warning(\"Blocking malicious request from {} to {}\"\n+                                    .format(firstparty.toDisplayString(),\n+                                            url.toDisplayString()))\n+                info.block(True)\n+                return\n \n         # FIXME:qtwebengine only block ads for NavigationTypeOther?\n         if self._host_blocker.is_blocked(url):"
        },
        {
          "filename": "qutebrowser/browser/webengine/webenginequtescheme.py",
          "status": "modified",
          "additions": 21,
          "deletions": 1,
          "patch": "@@ -55,8 +55,28 @@ def requestStarted(self, job):\n             job.fail(QWebEngineUrlRequestJob.UrlInvalid)\n             return\n \n-        assert job.requestMethod() == b'GET'\n+        # Only the browser itself or qute:// pages should access any of those\n+        # URLs.\n+        # The request interceptor further locks down qute://settings/set.\n+        try:\n+            initiator = job.initiator()\n+        except AttributeError:\n+            # Added in Qt 5.11\n+            pass\n+        else:\n+            if initiator.isValid() and initiator.scheme() != 'qute':\n+                log.misc.warning(\"Blocking malicious request from {} to {}\"\n+                                 .format(initiator.toDisplayString(),\n+                                         url.toDisplayString()))\n+                job.fail(QWebEngineUrlRequestJob.RequestDenied)\n+                return\n+\n+        if job.requestMethod() != b'GET':\n+            job.fail(QWebEngineUrlRequestJob.RequestDenied)\n+            return\n+\n         assert url.scheme() == 'qute'\n+\n         log.misc.debug(\"Got request for {}\".format(url.toDisplayString()))\n         try:\n             mimetype, data = qutescheme.data_for_url(url)"
        },
        {
          "filename": "qutebrowser/browser/webkit/network/filescheme.py",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -111,11 +111,13 @@ def dirbrowser_html(path):\n     return html.encode('UTF-8', errors='xmlcharrefreplace')\n \n \n-def handler(request):\n+def handler(request, _operation, _current_url):\n     \"\"\"Handler for a file:// URL.\n \n     Args:\n         request: QNetworkRequest to answer to.\n+        _operation: The HTTP operation being done.\n+        _current_url: The page we're on currently.\n \n     Return:\n         A QNetworkReply for directories, None for files."
        },
        {
          "filename": "qutebrowser/browser/webkit/network/networkmanager.py",
          "status": "modified",
          "additions": 7,
          "deletions": 7,
          "patch": "@@ -373,13 +373,6 @@ def createRequest(self, op, req, outgoing_data):\n                     req, proxy_error, QNetworkReply.UnknownProxyError,\n                     self)\n \n-        scheme = req.url().scheme()\n-        if scheme in self._scheme_handlers:\n-            result = self._scheme_handlers[scheme](req)\n-            if result is not None:\n-                result.setParent(self)\n-                return result\n-\n         for header, value in shared.custom_headers(url=req.url()):\n             req.setRawHeader(header, value)\n \n@@ -416,5 +409,12 @@ def createRequest(self, op, req, outgoing_data):\n                 req.url().toDisplayString(),\n                 current_url.toDisplayString()))\n \n+        scheme = req.url().scheme()\n+        if scheme in self._scheme_handlers:\n+            result = self._scheme_handlers[scheme](req, op, current_url)\n+            if result is not None:\n+                result.setParent(self)\n+                return result\n+\n         self.set_referer(req, current_url)\n         return super().createRequest(op, req, outgoing_data)"
        },
        {
          "filename": "qutebrowser/browser/webkit/network/webkitqutescheme.py",
          "status": "modified",
          "additions": 24,
          "deletions": 5,
          "patch": "@@ -21,27 +21,46 @@\n \n import mimetypes\n \n-from PyQt5.QtNetwork import QNetworkReply\n+from PyQt5.QtCore import QUrl\n+from PyQt5.QtNetwork import QNetworkReply, QNetworkAccessManager\n \n from qutebrowser.browser import pdfjs, qutescheme\n from qutebrowser.browser.webkit.network import networkreply\n from qutebrowser.utils import log, usertypes, qtutils\n \n \n-def handler(request):\n+def handler(request, operation, current_url):\n     \"\"\"Scheme handler for qute:// URLs.\n \n     Args:\n         request: QNetworkRequest to answer to.\n+        operation: The HTTP operation being done.\n+        current_url: The page we're on currently.\n \n     Return:\n         A QNetworkReply.\n     \"\"\"\n+    if operation != QNetworkAccessManager.GetOperation:\n+        return networkreply.ErrorNetworkReply(\n+            request, \"Unsupported request type\",\n+            QNetworkReply.ContentOperationNotPermittedError)\n+\n+    url = request.url()\n+\n+    if ((url.scheme(), url.host(), url.path()) ==\n+            ('qute', 'settings', '/set')):\n+        if current_url != QUrl('qute://settings/'):\n+            log.webview.warning(\"Blocking malicious request from {} to {}\"\n+                                .format(current_url.toDisplayString(),\n+                                        url.toDisplayString()))\n+            return networkreply.ErrorNetworkReply(\n+                request, \"Invalid qute://settings request\",\n+                QNetworkReply.ContentAccessDenied)\n+\n     try:\n-        mimetype, data = qutescheme.data_for_url(request.url())\n+        mimetype, data = qutescheme.data_for_url(url)\n     except qutescheme.NoHandlerFound:\n-        errorstr = \"No handler found for {}!\".format(\n-            request.url().toDisplayString())\n+        errorstr = \"No handler found for {}!\".format(url.toDisplayString())\n         return networkreply.ErrorNetworkReply(\n             request, errorstr, QNetworkReply.ContentNotFoundError)\n     except qutescheme.QuteSchemeOSError as e:"
        },
        {
          "filename": "qutebrowser/html/settings.html",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -3,7 +3,8 @@\n {% block script %}\n var cset = function(option, value) {\n   // FIXME:conf we might want some error handling here?\n-  var url = \"qute://settings/set?option=\" + encodeURIComponent(option);\n+  var url = \"qute://user:{{csrf_token}}@settings/set\"\n+  url += \"?option=\" + encodeURIComponent(option);\n   url += \"&value=\" + encodeURIComponent(value);\n   var xhr = new XMLHttpRequest();\n   xhr.open(\"GET\", url);"
        },
        {
          "filename": "tests/end2end/data/misc/qutescheme_csrf.html",
          "status": "added",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -0,0 +1,20 @@\n+<!DOCTYPE html>\n+<html>\n+    <head>\n+        <meta charset=\"utf-8\">\n+        <title>CSRF issues with qute://settings</title>\n+        <script type=\"text/javascript\">\n+            function add_img() {\n+                const elem = document.createElement(\"img\")\n+                elem.src = \"qute://settings/set?option=auto_save.interval&value=invalid\";\n+                document.body.appendChild(elem);\n+            }\n+        </script>\n+    </head>\n+    <body>\n+        <form action=\"qute://settings/set?option=auto_save.interval&value=invalid\" method=\"post\"><button type=\"submit\" id=\"via-form\">Via form</button></form>\n+        <input type=\"button\" onclick=\"add_img()\" value=\"Via img\" id=\"via-img\">\n+        <a href=\"qute://settings/set?option=auto_save.interval&value=invalid\" id=\"via-link\">Via link</a>\n+        <a href=\"/redirect-to?url=qute://settings/set%3Foption=auto_save.interval%26value=invalid\" id=\"via-redirect\">Via redirect</a>\n+    </body>\n+</html>"
        },
        {
          "filename": "tests/end2end/features/qutescheme.feature",
          "status": "modified",
          "additions": 57,
          "deletions": 0,
          "patch": "@@ -130,6 +130,63 @@ Feature: Special qute:// pages\n         And I press the key \"<Tab>\"\n         Then \"Invalid value 'foo' *\" should be logged\n \n+    @qtwebkit_skip\n+    Scenario: qute://settings CSRF via img (webengine)\n+        When I open data/misc/qutescheme_csrf.html\n+        And I run :click-element id via-img\n+        Then \"Blocking malicious request from http://localhost:*/data/misc/qutescheme_csrf.html to qute://settings/set?*\" should be logged\n+\n+    @qtwebkit_skip\n+    Scenario: qute://settings CSRF via link (webengine)\n+        When I open data/misc/qutescheme_csrf.html\n+        And I run :click-element id via-link\n+        Then \"Blocking malicious request from qute://settings/set?* to qute://settings/set?*\" should be logged\n+\n+    @qtwebkit_skip\n+    Scenario: qute://settings CSRF via redirect (webengine)\n+        When I open data/misc/qutescheme_csrf.html\n+        And I run :click-element id via-redirect\n+        Then \"Blocking malicious request from qute://settings/set?* to qute://settings/set?*\" should be logged\n+\n+    @qtwebkit_skip\n+    Scenario: qute://settings CSRF via form (webengine)\n+        When I open data/misc/qutescheme_csrf.html\n+        And I run :click-element id via-form\n+        Then \"Blocking malicious request from qute://settings/set?* to qute://settings/set?*\" should be logged\n+\n+    @qtwebkit_skip\n+    Scenario: qute://settings CSRF token (webengine)\n+        When I open qute://settings\n+        And I run :jseval const xhr = new XMLHttpRequest(); xhr.open(\"GET\", \"qute://settings/set\"); xhr.send()\n+        Then \"Error while handling qute://* URL\" should be logged\n+        And the error \"Invalid CSRF token for qute://settings!\" should be shown\n+\n+    @qtwebengine_skip\n+    Scenario: qute://settings CSRF via img (webkit)\n+        When I open data/misc/qutescheme_csrf.html\n+        And I run :click-element id via-img\n+        Then \"Blocking malicious request from http://localhost:*/data/misc/qutescheme_csrf.html to qute://settings/set?*\" should be logged\n+\n+    @qtwebengine_skip\n+    Scenario: qute://settings CSRF via link (webkit)\n+        When I open data/misc/qutescheme_csrf.html\n+        And I run :click-element id via-link\n+        Then \"Blocking malicious request from http://localhost:*/data/misc/qutescheme_csrf.html to qute://settings/set?*\" should be logged\n+        And \"Error while loading qute://settings/set?*: Invalid qute://settings request\" should be logged\n+\n+    @qtwebengine_skip\n+    Scenario: qute://settings CSRF via redirect (webkit)\n+        When I open data/misc/qutescheme_csrf.html\n+        And I run :click-element id via-redirect\n+        Then \"Blocking malicious request from http://localhost:*/data/misc/qutescheme_csrf.html to qute://settings/set?*\" should be logged\n+        And \"Error while loading qute://settings/set?*: Invalid qute://settings request\" should be logged\n+\n+    @qtwebengine_skip\n+    Scenario: qute://settings CSRF via form (webkit)\n+        When I open data/misc/qutescheme_csrf.html\n+        And I run :click-element id via-form\n+        Then \"Error while loading qute://settings/set?*: Unsupported request type\" should be logged\n+\n     # pdfjs support\n \n     @qtwebengine_skip: pdfjs is not implemented yet"
        },
        {
          "filename": "tests/end2end/test_invocations.py",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -368,8 +368,10 @@ def test_qute_settings_persistence(short_tmpdir, request, quteproc_new):\n     \"\"\"Make sure settings from qute://settings are persistent.\"\"\"\n     args = _base_args(request.config) + ['--basedir', str(short_tmpdir)]\n     quteproc_new.start(args)\n-    quteproc_new.open_path(\n-        'qute://settings/set?option=search.ignore_case&value=always')\n+    quteproc_new.open_path('qute://settings/')\n+    quteproc_new.send_cmd(':jseval --world main '\n+                          'cset(\"search.ignore_case\", \"always\")')\n+\n     assert quteproc_new.get_setting('search.ignore_case') == 'always'\n \n     quteproc_new.send_cmd(':quit')"
        },
        {
          "filename": "tests/unit/browser/webkit/network/test_filescheme.py",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -248,7 +248,7 @@ class TestFileSchemeHandler:\n     def test_dir(self, tmpdir):\n         url = QUrl.fromLocalFile(str(tmpdir))\n         req = QNetworkRequest(url)\n-        reply = filescheme.handler(req)\n+        reply = filescheme.handler(req, None, None)\n         # The URL will always use /, even on Windows - so we force this here\n         # too.\n         tmpdir_path = str(tmpdir).replace(os.sep, '/')\n@@ -259,7 +259,7 @@ def test_file(self, tmpdir):\n         filename.ensure()\n         url = QUrl.fromLocalFile(str(filename))\n         req = QNetworkRequest(url)\n-        reply = filescheme.handler(req)\n+        reply = filescheme.handler(req, None, None)\n         assert reply is None\n \n     def test_unicode_encode_error(self, mocker):\n@@ -269,5 +269,5 @@ def test_unicode_encode_error(self, mocker):\n         err = UnicodeEncodeError('ascii', '', 0, 2, 'foo')\n         mocker.patch('os.path.isdir', side_effect=err)\n \n-        reply = filescheme.handler(req)\n+        reply = filescheme.handler(req, None, None)\n         assert reply is None"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 8,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "0a32d6fef5550c2c0c38073533d36c3f47d6b130",
            "date": "2025-01-09T10:50:34Z",
            "author_login": "The-Compiler"
          },
          {
            "sha": "c5395c23f7033d8884a6b89549fc73e0308711f6",
            "date": "2025-01-09T10:27:40Z",
            "author_login": "The-Compiler"
          },
          {
            "sha": "d272804126de00a4a59776aa7b1808abb96ecb0e",
            "date": "2025-01-09T10:20:48Z",
            "author_login": "The-Compiler"
          },
          {
            "sha": "ed8141cb4b97427c4fc69b2c60f5d734cb7d9d1b",
            "date": "2025-01-06T14:14:21Z",
            "author_login": "The-Compiler"
          },
          {
            "sha": "2b8c053aee5c847f0f324e6c9a4262a79144f2c8",
            "date": "2025-01-06T14:07:30Z",
            "author_login": "The-Compiler"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-352",
    "description": "qutebrowser before version 1.4.1 is vulnerable to a cross-site request forgery flaw that allows websites to access 'qute://*' URLs. A malicious website could exploit this to load a 'qute://settings/set' URL, which then sets 'editor.command' to a bash script, resulting in arbitrary code execution.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-07-12T12:29:00.213",
    "last_modified": "2024-11-21T03:42:14.780",
    "fix_date": "2018-07-09T21:38:47Z"
  },
  "references": [
    {
      "url": "http://www.openwall.com/lists/oss-security/2018/07/11/7",
      "source": "secalert@redhat.com",
      "tags": [
        "Mailing List",
        "Mitigation",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2018-10895",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/qutebrowser/qutebrowser/commit/43e58ac865ff862c2008c510fc5f7627e10b4660",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2018/07/11/7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Mitigation",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2018-10895",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/qutebrowser/qutebrowser/commit/43e58ac865ff862c2008c510fc5f7627e10b4660",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:32.384031",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "qutebrowser",
    "owner": "qutebrowser",
    "created_at": "2014-06-26T14:59:34Z",
    "updated_at": "2025-01-13T20:25:55Z",
    "pushed_at": "2025-01-13T04:22:22Z",
    "size": 63852,
    "stars": 10002,
    "forks": 1018,
    "open_issues": 1235,
    "watchers": 10002,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "v0.11.x",
      "v1.1.x",
      "v1.2.x",
      "v1.3.x",
      "v1.4.x",
      "v1.5.x",
      "v1.6.x",
      "v1.7.x",
      "v1.8.x",
      "v1.9.x"
    ],
    "languages": {
      "Python": 4059218,
      "JavaScript": 771996,
      "Gherkin": 373139,
      "HTML": 131743,
      "Shell": 50490,
      "NSIS": 41173,
      "CSS": 4753,
      "Jinja": 3137,
      "Batchfile": 2012,
      "Makefile": 1510,
      "C++": 456,
      "QMake": 192
    },
    "commit_activity": {
      "total_commits_last_year": 476,
      "avg_commits_per_week": 9.153846153846153,
      "days_active_last_year": 143
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-14T15:16:35.329343"
  }
}