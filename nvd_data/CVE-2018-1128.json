{
  "cve_id": "CVE-2018-1128",
  "github_data": {
    "repository": "ceph/ceph",
    "fix_commit": "5ead97120e07054d80623dada90a5cc764c28468",
    "related_commits": [
      "5ead97120e07054d80623dada90a5cc764c28468",
      "5ead97120e07054d80623dada90a5cc764c28468"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "5ead97120e07054d80623dada90a5cc764c28468",
      "commit_date": "2018-05-24T21:55:26Z",
      "author": {
        "login": "liewegas",
        "type": "User",
        "stats": {
          "total_commits": 25876,
          "average_weekly_commits": 28.94407158836689,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 589
        }
      },
      "commit_message": {
        "title": "auth/cephx: add authorizer challenge",
        "length": 1001,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 354,
        "additions": 273,
        "deletions": 81
      },
      "files": [
        {
          "filename": "src/auth/Auth.h",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -136,6 +136,11 @@ struct AuthAuthorizer {\n   explicit AuthAuthorizer(__u32 p) : protocol(p) {}\n   virtual ~AuthAuthorizer() {}\n   virtual bool verify_reply(bufferlist::iterator& reply) = 0;\n+  virtual bool add_challenge(CephContext *cct, bufferlist& challenge) = 0;\n+};\n+\n+struct AuthAuthorizerChallenge {\n+  virtual ~AuthAuthorizerChallenge() {}\n };\n \n "
        },
        {
          "filename": "src/auth/AuthAuthorizeHandler.h",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -34,7 +34,9 @@ struct AuthAuthorizeHandler {\n   virtual bool verify_authorizer(CephContext *cct, KeyStore *keys,\n \t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n                                  EntityName& entity_name, uint64_t& global_id,\n-\t\t\t\t AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid = NULL) = 0;\n+\t\t\t\t AuthCapsInfo& caps_info, CryptoKey& session_key,\n+\t\t\t\t uint64_t *auid,\n+\t\t\t\t std::unique_ptr<AuthAuthorizerChallenge> *challenge) = 0;\n   virtual int authorizer_session_crypto() = 0;\n };\n "
        },
        {
          "filename": "src/auth/cephx/CephxAuthorizeHandler.cc",
          "status": "modified",
          "additions": 8,
          "deletions": 4,
          "patch": "@@ -6,9 +6,12 @@\n \n \n \n-bool CephxAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n-\t\t\t\t\t      bufferlist& authorizer_data, bufferlist& authorizer_reply,\n-                                              EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,  uint64_t *auid)\n+bool CephxAuthorizeHandler::verify_authorizer(\n+  CephContext *cct, KeyStore *keys,\n+  bufferlist& authorizer_data, bufferlist& authorizer_reply,\n+  EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info,\n+  CryptoKey& session_key, uint64_t *auid,\n+  std::unique_ptr<AuthAuthorizerChallenge> *challenge)\n {\n   bufferlist::iterator iter = authorizer_data.begin();\n \n@@ -19,7 +22,8 @@ bool CephxAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n \n   CephXServiceTicketInfo auth_ticket_info;\n \n-  bool isvalid = cephx_verify_authorizer(cct, keys, iter, auth_ticket_info, authorizer_reply);\n+  bool isvalid = cephx_verify_authorizer(cct, keys, iter, auth_ticket_info, challenge,\n+\t\t\t\t\t authorizer_reply);\n \n   if (isvalid) {\n     caps_info = auth_ticket_info.ticket.caps;"
        },
        {
          "filename": "src/auth/cephx/CephxAuthorizeHandler.h",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -23,7 +23,8 @@ struct CephxAuthorizeHandler : public AuthAuthorizeHandler {\n   bool verify_authorizer(CephContext *cct, KeyStore *keys,\n \t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n                          EntityName& entity_name, uint64_t& global_id,\n-\t\t\t AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid = NULL) override;\n+\t\t\t AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid,\n+\t\t\t std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;\n   int authorizer_session_crypto() override;\n };\n "
        },
        {
          "filename": "src/auth/cephx/CephxProtocol.cc",
          "status": "modified",
          "additions": 56,
          "deletions": 1,
          "patch": "@@ -304,6 +304,7 @@ CephXAuthorizer *CephXTicketHandler::build_authorizer(uint64_t global_id) const\n   ::encode(service_id, a->bl);\n \n   ::encode(ticket, a->bl);\n+  a->base_bl = a->bl;\n \n   CephXAuthorize msg;\n   msg.nonce = a->nonce;\n@@ -390,7 +391,9 @@ bool cephx_decode_ticket(CephContext *cct, KeyStore *keys, uint32_t service_id,\n  */\n bool cephx_verify_authorizer(CephContext *cct, KeyStore *keys,\n \t\t\t     bufferlist::iterator& indata,\n-\t\t\t     CephXServiceTicketInfo& ticket_info, bufferlist& reply_bl)\n+\t\t\t     CephXServiceTicketInfo& ticket_info,\n+\t\t\t     std::unique_ptr<AuthAuthorizerChallenge> *challenge,\n+\t\t\t     bufferlist& reply_bl)\n {\n   __u8 authorizer_v;\n   uint32_t service_id;\n@@ -457,6 +460,30 @@ bool cephx_verify_authorizer(CephContext *cct, KeyStore *keys,\n     return false;\n   }\n \n+  if (challenge) {\n+    auto *c = static_cast<CephXAuthorizeChallenge*>(challenge->get());\n+    if (!auth_msg.have_challenge || !c) {\n+      c = new CephXAuthorizeChallenge;\n+      challenge->reset(c);\n+      get_random_bytes((char*)&c->server_challenge, sizeof(c->server_challenge));\n+      ldout(cct,10) << __func__ << \" adding server_challenge \" << c->server_challenge\n+\t\t    << dendl;\n+\n+      encode_encrypt_enc_bl(cct, *c, ticket_info.session_key, reply_bl, error);\n+      if (!error.empty()) {\n+\tldout(cct, 10) << \"verify_authorizer: encode_encrypt error: \" << error << dendl;\n+\treturn false;\n+      }\n+      return false;\n+    }\n+    ldout(cct, 10) << __func__ << \" got server_challenge+1 \"\n+\t\t   << auth_msg.server_challenge_plus_one\n+\t\t   << \" expecting \" << c->server_challenge + 1 << dendl;\n+    if (c->server_challenge + 1 != auth_msg.server_challenge_plus_one) {\n+      return false;\n+    }\n+  }\n+\n   /*\n    * Reply authorizer:\n    *  {timestamp + 1}^session_key\n@@ -493,3 +520,31 @@ bool CephXAuthorizer::verify_reply(bufferlist::iterator& indata)\n   return true;\n }\n \n+bool CephXAuthorizer::add_challenge(CephContext *cct, bufferlist& challenge)\n+{\n+  bl = base_bl;\n+\n+  CephXAuthorize msg;\n+  msg.nonce = nonce;\n+\n+  auto p = challenge.begin();\n+  if (!p.end()) {\n+    std::string error;\n+    CephXAuthorizeChallenge ch;\n+    decode_decrypt_enc_bl(cct, ch, session_key, challenge, error);\n+    if (!error.empty()) {\n+      ldout(cct, 0) << \"failed to decrypt challenge (\" << challenge.length() << \" bytes): \"\n+\t\t    << error << dendl;\n+      return false;\n+    }\n+    msg.have_challenge = true;\n+    msg.server_challenge_plus_one = ch.server_challenge + 1;\n+  }\n+\n+  std::string error;\n+  if (encode_encrypt(cct, msg, session_key, bl, error)) {\n+    ldout(cct, 0) << __func__ << \" failed to encrypt authorizer: \" << error << dendl;\n+    return false;\n+  }\n+  return true;\n+}"
        },
        {
          "filename": "src/auth/cephx/CephxProtocol.h",
          "status": "modified",
          "additions": 33,
          "deletions": 4,
          "patch": "@@ -273,12 +273,14 @@ struct CephXAuthorizer : public AuthAuthorizer {\n   CephContext *cct;\n public:\n   uint64_t nonce;\n+  bufferlist base_bl;\n \n   explicit CephXAuthorizer(CephContext *cct_)\n     : AuthAuthorizer(CEPH_AUTH_CEPHX), cct(cct_), nonce(0) {}\n \n   bool build_authorizer();\n   bool verify_reply(bufferlist::iterator& reply) override;\n+  bool add_challenge(CephContext *cct, bufferlist& challenge) override;\n };\n \n \n@@ -384,17 +386,41 @@ struct CephXServiceTicketInfo {\n };\n WRITE_CLASS_ENCODER(CephXServiceTicketInfo)\n \n+struct CephXAuthorizeChallenge : public AuthAuthorizerChallenge {\n+  uint64_t server_challenge;\n+  void encode(bufferlist& bl) const {\n+    __u8 struct_v = 1;\n+    ::encode(struct_v, bl);\n+    ::encode(server_challenge, bl);\n+  }\n+  void decode(bufferlist::iterator& bl) {\n+    __u8 struct_v;\n+    ::decode(struct_v, bl);\n+    ::decode(server_challenge, bl);\n+  }\n+};\n+WRITE_CLASS_ENCODER(CephXAuthorizeChallenge)\n+\n struct CephXAuthorize {\n   uint64_t nonce;\n+  bool have_challenge = false;\n+  uint64_t server_challenge_plus_one = 0;\n   void encode(bufferlist& bl) const {\n-    __u8 struct_v = 1;\n+    __u8 struct_v = 2;\n     ::encode(struct_v, bl);\n     ::encode(nonce, bl);\n+    ::encode(have_challenge, bl);\n+    ::encode(server_challenge_plus_one, bl);\n   }\n   void decode(bufferlist::iterator& bl) {\n     __u8 struct_v;\n     ::decode(struct_v, bl);\n     ::decode(nonce, bl);\n+    if (struct_v >= 2) {\n+      ::decode(have_challenge, bl);\n+      ::decode(server_challenge_plus_one, bl);\n+    }\n+\n   }\n };\n WRITE_CLASS_ENCODER(CephXAuthorize)\n@@ -409,9 +435,12 @@ bool cephx_decode_ticket(CephContext *cct, KeyStore *keys,\n /*\n  * Verify authorizer and generate reply authorizer\n  */\n-extern bool cephx_verify_authorizer(CephContext *cct, KeyStore *keys,\n-\t\t\t\t    bufferlist::iterator& indata,\n-\t\t\t\t    CephXServiceTicketInfo& ticket_info, bufferlist& reply_bl);\n+extern bool cephx_verify_authorizer(\n+  CephContext *cct, KeyStore *keys,\n+  bufferlist::iterator& indata,\n+  CephXServiceTicketInfo& ticket_info,\n+  std::unique_ptr<AuthAuthorizerChallenge> *challenge,\n+  bufferlist& reply_bl);\n \n \n "
        },
        {
          "filename": "src/auth/cephx/CephxServiceHandler.cc",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -152,7 +152,9 @@ int CephxServiceHandler::handle_request(bufferlist::iterator& indata, bufferlist\n \n       bufferlist tmp_bl;\n       CephXServiceTicketInfo auth_ticket_info;\n-      if (!cephx_verify_authorizer(cct, key_server, indata, auth_ticket_info, tmp_bl)) {\n+      // note: no challenge here.\n+      if (!cephx_verify_authorizer(cct, key_server, indata, auth_ticket_info, nullptr,\n+\t\t\t\t   tmp_bl)) {\n         ret = -EPERM;\n \tbreak;\n       }"
        },
        {
          "filename": "src/auth/none/AuthNoneAuthorizeHandler.cc",
          "status": "modified",
          "additions": 7,
          "deletions": 4,
          "patch": "@@ -17,10 +17,13 @@\n \n #define dout_subsys ceph_subsys_auth\n \n-bool AuthNoneAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n-\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n-\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\n-uint64_t *auid)\n+bool AuthNoneAuthorizeHandler::verify_authorizer(\n+  CephContext *cct, KeyStore *keys,\n+  bufferlist& authorizer_data, bufferlist& authorizer_reply,\n+  EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info,\n+  CryptoKey& session_key,\n+  uint64_t *auid,\n+  std::unique_ptr<AuthAuthorizerChallenge> *challenge)\n {\n   bufferlist::iterator iter = authorizer_data.begin();\n "
        },
        {
          "filename": "src/auth/none/AuthNoneAuthorizeHandler.h",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -23,7 +23,8 @@ struct AuthNoneAuthorizeHandler : public AuthAuthorizeHandler {\n   bool verify_authorizer(CephContext *cct, KeyStore *keys,\n \t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n                          EntityName& entity_name, uint64_t& global_id,\n-\t\t\t AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid=NULL) override;\n+\t\t\t AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid,\n+\t\t\t std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;\n   int authorizer_session_crypto() override;\n };\n "
        },
        {
          "filename": "src/auth/none/AuthNoneProtocol.h",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -17,6 +17,8 @@\n \n #include \"auth/Auth.h\"\n \n+class CephContext;\n+\n struct AuthNoneAuthorizer : public AuthAuthorizer {\n   AuthNoneAuthorizer() : AuthAuthorizer(CEPH_AUTH_NONE) { }\n   bool build_authorizer(const EntityName &ename, uint64_t global_id) {\n@@ -27,6 +29,7 @@ struct AuthNoneAuthorizer : public AuthAuthorizer {\n     return 0;\n   }\n   bool verify_reply(bufferlist::iterator& reply) override { return true; }\n+  bool add_challenge(CephContext *cct, bufferlist& ch) override { return true; }\n };\n \n #endif"
        },
        {
          "filename": "src/auth/unknown/AuthUnknownAuthorizeHandler.cc",
          "status": "modified",
          "additions": 7,
          "deletions": 4,
          "patch": "@@ -14,10 +14,13 @@\n \n #include \"AuthUnknownAuthorizeHandler.h\"\n \n-bool AuthUnknownAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n-\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n-\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\n-uint64_t *auid)\n+bool AuthUnknownAuthorizeHandler::verify_authorizer(\n+  CephContext *cct, KeyStore *keys,\n+  bufferlist& authorizer_data, bufferlist& authorizer_reply,\n+  EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info,\n+  CryptoKey& session_key,\n+  uint64_t *auid,\n+  std::unique_ptr<AuthAuthorizerChallenge> *challenge)\n {\n   // For unknown authorizers, there's nothing to verify.  They're \"OK\" by definition.  PLR\n "
        },
        {
          "filename": "src/auth/unknown/AuthUnknownAuthorizeHandler.h",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -23,7 +23,8 @@ struct AuthUnknownAuthorizeHandler : public AuthAuthorizeHandler {\n   bool verify_authorizer(CephContext *cct, KeyStore *keys,\n \t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n                          EntityName& entity_name, uint64_t& global_id,\n-\t\t\t AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid=NULL) override;\n+\t\t\t AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid,\n+\t\t\t std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;\n   int authorizer_session_crypto() override;\n };\n "
        },
        {
          "filename": "src/include/msgr.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -93,7 +93,7 @@ struct ceph_entity_inst {\n #define CEPH_MSGR_TAG_SEQ           13 /* 64-bit int follows with seen seq number */\n #define CEPH_MSGR_TAG_KEEPALIVE2     14\n #define CEPH_MSGR_TAG_KEEPALIVE2_ACK 15  /* keepalive reply */\n-\n+#define CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER 16  /* ceph v2 doing server challenge */\n \n /*\n  * connection negotiation"
        },
        {
          "filename": "src/mds/MDSDaemon.cc",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -1262,7 +1262,8 @@ bool MDSDaemon::ms_handle_refused(Connection *con)\n \n bool MDSDaemon::ms_verify_authorizer(Connection *con, int peer_type,\n \t\t\t       int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n-\t\t\t       bool& is_valid, CryptoKey& session_key)\n+\t\t\t\t     bool& is_valid, CryptoKey& session_key,\n+\t\t\t\t     std::unique_ptr<AuthAuthorizerChallenge> *challenge)\n {\n   Mutex::Locker l(mds_lock);\n   if (stopping) {\n@@ -1294,7 +1295,7 @@ bool MDSDaemon::ms_verify_authorizer(Connection *con, int peer_type,\n     is_valid = authorize_handler->verify_authorizer(\n       cct, keys,\n       authorizer_data, authorizer_reply, name, global_id, caps_info,\n-      session_key);\n+      session_key, nullptr, challenge);\n   } else {\n     dout(10) << __func__ << \" no rotating_keys (yet), denied\" << dendl;\n     is_valid = false;"
        },
        {
          "filename": "src/mds/MDSDaemon.h",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -108,7 +108,8 @@ class MDSDaemon : public Dispatcher, public md_config_obs_t {\n   bool ms_get_authorizer(int dest_type, AuthAuthorizer **authorizer, bool force_new) override;\n   bool ms_verify_authorizer(Connection *con, int peer_type,\n \t\t\t       int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n-\t\t\t       bool& isvalid, CryptoKey& session_key) override;\n+\t\t\t    bool& isvalid, CryptoKey& session_key,\n+\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;\n   void ms_handle_accept(Connection *con) override;\n   void ms_handle_connect(Connection *con) override;\n   bool ms_handle_reset(Connection *con) override;"
        },
        {
          "filename": "src/mgr/DaemonServer.cc",
          "status": "modified",
          "additions": 12,
          "deletions": 8,
          "patch": "@@ -141,13 +141,15 @@ entity_addr_t DaemonServer::get_myaddr() const\n }\n \n \n-bool DaemonServer::ms_verify_authorizer(Connection *con,\n-    int peer_type,\n-    int protocol,\n-    ceph::bufferlist& authorizer_data,\n-    ceph::bufferlist& authorizer_reply,\n-    bool& is_valid,\n-    CryptoKey& session_key)\n+bool DaemonServer::ms_verify_authorizer(\n+  Connection *con,\n+  int peer_type,\n+  int protocol,\n+  ceph::bufferlist& authorizer_data,\n+  ceph::bufferlist& authorizer_reply,\n+  bool& is_valid,\n+  CryptoKey& session_key,\n+  std::unique_ptr<AuthAuthorizerChallenge> *challenge)\n {\n   AuthAuthorizeHandler *handler = nullptr;\n   if (peer_type == CEPH_ENTITY_TYPE_OSD ||\n@@ -175,7 +177,9 @@ bool DaemonServer::ms_verify_authorizer(Connection *con,\n       authorizer_data,\n       authorizer_reply, s->entity_name,\n       s->global_id, caps_info,\n-      session_key);\n+      session_key,\n+      nullptr,\n+      challenge);\n   } else {\n     dout(10) << __func__ << \" no rotating_keys (yet), denied\" << dendl;\n     is_valid = false;"
        },
        {
          "filename": "src/mgr/DaemonServer.h",
          "status": "modified",
          "additions": 9,
          "deletions": 7,
          "patch": "@@ -123,13 +123,15 @@ class DaemonServer : public Dispatcher, public md_config_obs_t\n   bool ms_handle_refused(Connection *con) override;\n   bool ms_get_authorizer(int dest_type, AuthAuthorizer **authorizer,\n                          bool force_new) override;\n-  bool ms_verify_authorizer(Connection *con,\n-      int peer_type,\n-      int protocol,\n-      ceph::bufferlist& authorizer,\n-      ceph::bufferlist& authorizer_reply,\n-      bool& isvalid,\n-      CryptoKey& session_key) override;\n+  bool ms_verify_authorizer(\n+    Connection *con,\n+    int peer_type,\n+    int protocol,\n+    ceph::bufferlist& authorizer,\n+    ceph::bufferlist& authorizer_reply,\n+    bool& isvalid,\n+    CryptoKey& session_key,\n+    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;\n \n   bool handle_open(MMgrOpen *m);\n   bool handle_report(MMgrReport *m);"
        },
        {
          "filename": "src/mon/Monitor.cc",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -5898,7 +5898,8 @@ bool Monitor::ms_get_authorizer(int service_id, AuthAuthorizer **authorizer,\n bool Monitor::ms_verify_authorizer(Connection *con, int peer_type,\n \t\t\t\t   int protocol, bufferlist& authorizer_data,\n \t\t\t\t   bufferlist& authorizer_reply,\n-\t\t\t\t   bool& isvalid, CryptoKey& session_key)\n+\t\t\t\t   bool& isvalid, CryptoKey& session_key,\n+\t\t\t\t   std::unique_ptr<AuthAuthorizerChallenge> *challenge)\n {\n   dout(10) << \"ms_verify_authorizer \" << con->get_peer_addr()\n \t   << \" \" << ceph_entity_type_name(peer_type)\n@@ -5917,7 +5918,7 @@ bool Monitor::ms_verify_authorizer(Connection *con, int peer_type,\n       \n       if (authorizer_data.length()) {\n \tbool ret = cephx_verify_authorizer(g_ceph_context, &keyring, iter,\n-\t\t\t\t\t  auth_ticket_info, authorizer_reply);\n+\t\t\t\t\t   auth_ticket_info, challenge, authorizer_reply);\n \tif (ret) {\n \t  session_key = auth_ticket_info.session_key;\n \t  isvalid = true;"
        },
        {
          "filename": "src/mon/Monitor.h",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -906,7 +906,8 @@ class Monitor : public Dispatcher,\n   bool ms_get_authorizer(int dest_type, AuthAuthorizer **authorizer, bool force_new) override;\n   bool ms_verify_authorizer(Connection *con, int peer_type,\n \t\t\t    int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n-\t\t\t    bool& isvalid, CryptoKey& session_key) override;\n+\t\t\t    bool& isvalid, CryptoKey& session_key,\n+\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;\n   bool ms_handle_reset(Connection *con) override;\n   void ms_handle_remote_reset(Connection *con) override {}\n   bool ms_handle_refused(Connection *con) override;"
        },
        {
          "filename": "src/msg/Dispatcher.h",
          "status": "modified",
          "additions": 6,
          "deletions": 1,
          "patch": "@@ -17,6 +17,7 @@\n #define CEPH_DISPATCHER_H\n \n #include \"include/assert.h\"\n+#include <memory>\n #include \"include/buffer_fwd.h\"\n #include \"include/assert.h\"\n \n@@ -26,6 +27,7 @@ class Connection;\n class AuthAuthorizer;\n class CryptoKey;\n class CephContext;\n+class AuthAuthorizerChallenge;\n \n class Dispatcher {\n public:\n@@ -204,7 +206,10 @@ class Dispatcher {\n \t\t\t\t    ceph::bufferlist& authorizer,\n \t\t\t\t    ceph::bufferlist& authorizer_reply,\n \t\t\t\t    bool& isvalid,\n-\t\t\t\t    CryptoKey& session_key) { return false; }\n+\t\t\t\t    CryptoKey& session_key,\n+\t\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) {\n+    return false;\n+  }\n   /**\n    * @} //Authentication\n    */"
        },
        {
          "filename": "src/msg/Messenger.h",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -806,11 +806,13 @@ class Messenger {\n    */\n   bool ms_deliver_verify_authorizer(Connection *con, int peer_type,\n \t\t\t\t    int protocol, bufferlist& authorizer, bufferlist& authorizer_reply,\n-\t\t\t\t    bool& isvalid, CryptoKey& session_key) {\n+\t\t\t\t    bool& isvalid, CryptoKey& session_key,\n+\t\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) {\n     for (list<Dispatcher*>::iterator p = dispatchers.begin();\n \t p != dispatchers.end();\n \t ++p) {\n-      if ((*p)->ms_verify_authorizer(con, peer_type, protocol, authorizer, authorizer_reply, isvalid, session_key))\n+      if ((*p)->ms_verify_authorizer(con, peer_type, protocol, authorizer, authorizer_reply,\n+\t\t\t\t     isvalid, session_key, challenge))\n \treturn true;\n     }\n     return false;"
        },
        {
          "filename": "src/msg/async/AsyncConnection.cc",
          "status": "modified",
          "additions": 30,
          "deletions": 7,
          "patch": "@@ -1026,8 +1026,7 @@ ssize_t AsyncConnection::_process_connection()\n \n     case STATE_CONNECTING_SEND_CONNECT_MSG:\n       {\n-        if (!got_bad_auth) {\n-          delete authorizer;\n+        if (!authorizer) {\n           authorizer = async_msgr->get_authorizer(peer_type, false);\n         }\n         bufferlist bl;\n@@ -1107,7 +1106,15 @@ ssize_t AsyncConnection::_process_connection()\n           }\n \n           authorizer_reply.append(state_buffer, connect_reply.authorizer_len);\n-          bufferlist::iterator iter = authorizer_reply.begin();\n+\n+\t  if (connect_reply.tag == CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER) {\n+\t    ldout(async_msgr->cct,10) << __func__ << \" connect got auth challenge\" << dendl;\n+\t    authorizer->add_challenge(async_msgr->cct, authorizer_reply);\n+\t    state = STATE_CONNECTING_SEND_CONNECT_MSG;\n+\t    break;\n+\t  }\n+\n+          auto iter = authorizer_reply.begin();\n           if (authorizer && !authorizer->verify_reply(iter)) {\n             ldout(async_msgr->cct, 0) << __func__ << \" failed verifying authorize reply\" << dendl;\n             goto fail;\n@@ -1521,12 +1528,26 @@ ssize_t AsyncConnection::handle_connect_msg(ceph_msg_connect &connect, bufferlis\n   lock.unlock();\n \n   bool authorizer_valid;\n-  if (!async_msgr->verify_authorizer(this, peer_type, connect.authorizer_protocol, authorizer_bl,\n-                               authorizer_reply, authorizer_valid, session_key) || !authorizer_valid) {\n+  bool need_challenge = HAVE_FEATURE(connect.features, CEPHX_V2);\n+  bool had_challenge = (bool)authorizer_challenge;\n+  if (!async_msgr->verify_authorizer(\n+\tthis, peer_type, connect.authorizer_protocol, authorizer_bl,\n+\tauthorizer_reply, authorizer_valid, session_key,\n+\tneed_challenge ? &authorizer_challenge : nullptr) ||\n+      !authorizer_valid) {\n     lock.lock();\n-    ldout(async_msgr->cct,0) << __func__ << \": got bad authorizer\" << dendl;\n+    char tag;\n+    if (need_challenge && !had_challenge && authorizer_challenge) {\n+      ldout(async_msgr->cct,0) << __func__ << \": challenging authorizer\"\n+\t\t\t       << dendl;\n+      assert(authorizer_reply.length());\n+      tag = CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER;\n+    } else {\n+      ldout(async_msgr->cct,0) << __func__ << \": got bad authorizer\" << dendl;\n+      tag = CEPH_MSGR_TAG_BADAUTHORIZER;\n+    }\n     session_security.reset();\n-    return _reply_accept(CEPH_MSGR_TAG_BADAUTHORIZER, connect, reply, authorizer_reply);\n+    return _reply_accept(tag, connect, reply, authorizer_reply);\n   }\n \n   // We've verified the authorizer for this AsyncConnection, so set up the session security structure.  PLR\n@@ -1720,6 +1741,8 @@ ssize_t AsyncConnection::handle_connect_msg(ceph_msg_connect &connect, bufferlis\n     // there shouldn't exist any buffer\n     assert(recv_start == recv_end);\n \n+    existing->authorizer_challenge.reset();\n+\n     auto deactivate_existing = std::bind(\n         [existing, new_worker, new_center, connect, reply, authorizer_reply](ConnectedSocket &cs) mutable {\n       // we need to delete time event in original thread"
        },
        {
          "filename": "src/msg/async/AsyncConnection.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -371,6 +371,7 @@ class AsyncConnection : public Connection {\n   Worker *worker;\n   EventCenter *center;\n   ceph::shared_ptr<AuthSessionHandler> session_security;\n+  std::unique_ptr<AuthAuthorizerChallenge> authorizer_challenge; // accept side\n \n  public:\n   // used by eventcallback"
        },
        {
          "filename": "src/msg/async/AsyncMessenger.h",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -384,9 +384,10 @@ class AsyncMessenger : public SimplePolicyMessenger {\n    * This wraps ms_deliver_verify_authorizer; we use it for AsyncConnection.\n    */\n   bool verify_authorizer(Connection *con, int peer_type, int protocol, bufferlist& auth, bufferlist& auth_reply,\n-                         bool& isvalid, CryptoKey& session_key) {\n+                         bool& isvalid, CryptoKey& session_key,\n+\t\t\t std::unique_ptr<AuthAuthorizerChallenge> *challenge) {\n     return ms_deliver_verify_authorizer(con, peer_type, protocol, auth,\n-                                        auth_reply, isvalid, session_key);\n+                                        auth_reply, isvalid, session_key, challenge);\n   }\n   /**\n    * Increment the global sequence for this AsyncMessenger and return it."
        },
        {
          "filename": "src/msg/simple/Pipe.cc",
          "status": "modified",
          "additions": 31,
          "deletions": 6,
          "patch": "@@ -354,6 +354,10 @@ int Pipe::accept()\n   // used for reading in the remote acked seq on connect\n   uint64_t newly_acked_seq = 0;\n \n+  bool need_challenge = false;\n+  bool had_challenge = false;\n+  std::unique_ptr<AuthAuthorizerChallenge> authorizer_challenge;\n+\n   recv_reset();\n \n   set_socket_options();\n@@ -514,14 +518,27 @@ int Pipe::accept()\n \n     pipe_lock.Unlock();\n \n-    if (!msgr->verify_authorizer(connection_state.get(), peer_type, connect.authorizer_protocol, authorizer,\n-\t\t\t\t authorizer_reply, authorizer_valid, session_key) ||\n+    need_challenge = HAVE_FEATURE(connect.features, CEPHX_V2);\n+    had_challenge = (bool)authorizer_challenge;\n+    authorizer_reply.clear();\n+    if (!msgr->verify_authorizer(\n+\t  connection_state.get(), peer_type, connect.authorizer_protocol, authorizer,\n+\t  authorizer_reply, authorizer_valid, session_key,\n+\t  need_challenge ? &authorizer_challenge : nullptr) ||\n \t!authorizer_valid) {\n-      ldout(msgr->cct,0) << \"accept: got bad authorizer\" << dendl;\n       pipe_lock.Lock();\n       if (state != STATE_ACCEPTING)\n \tgoto shutting_down_msgr_unlocked;\n-      reply.tag = CEPH_MSGR_TAG_BADAUTHORIZER;\n+      if (!had_challenge && need_challenge && authorizer_challenge) {\n+\tldout(msgr->cct,0) << \"accept: challenging authorizer \"\n+\t\t\t   << authorizer_reply.length()\n+\t\t\t   << \" bytes\" << dendl;\n+\tassert(authorizer_reply.length());\n+\treply.tag = CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER;\n+      } else {\n+\tldout(msgr->cct,0) << \"accept: got bad authorizer\" << dendl;\n+\treply.tag = CEPH_MSGR_TAG_BADAUTHORIZER;\n+      }\n       session_security.reset();\n       goto reply;\n     } \n@@ -1127,8 +1144,9 @@ int Pipe::connect()\n \n \n   while (1) {\n-    delete authorizer;\n-    authorizer = msgr->get_authorizer(peer_type, false);\n+    if (!authorizer) {\n+      authorizer = msgr->get_authorizer(peer_type, false);\n+    }\n     bufferlist authorizer_reply;\n \n     ceph_msg_connect connect;\n@@ -1195,6 +1213,13 @@ int Pipe::connect()\n       authorizer_reply.push_back(bp);\n     }\n \n+    if (reply.tag == CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER) {\n+      authorizer->add_challenge(msgr->cct, authorizer_reply);\n+      ldout(msgr->cct,10) << \" got authorizer challenge, \" << authorizer_reply.length()\n+\t\t\t  << \" bytes\" << dendl;\n+      continue;\n+    }\n+\n     if (authorizer) {\n       bufferlist::iterator iter = authorizer_reply.begin();\n       if (!authorizer->verify_reply(iter)) {"
        },
        {
          "filename": "src/msg/simple/SimpleMessenger.cc",
          "status": "modified",
          "additions": 5,
          "deletions": 2,
          "patch": "@@ -415,9 +415,12 @@ AuthAuthorizer *SimpleMessenger::get_authorizer(int peer_type, bool force_new)\n \n bool SimpleMessenger::verify_authorizer(Connection *con, int peer_type,\n \t\t\t\t\tint protocol, bufferlist& authorizer, bufferlist& authorizer_reply,\n-\t\t\t\t\tbool& isvalid,CryptoKey& session_key)\n+\t\t\t\t\tbool& isvalid,CryptoKey& session_key,\n+\t\t\t\t\tstd::unique_ptr<AuthAuthorizerChallenge> *challenge)\n {\n-  return ms_deliver_verify_authorizer(con, peer_type, protocol, authorizer, authorizer_reply, isvalid,session_key);\n+  return ms_deliver_verify_authorizer(con, peer_type, protocol, authorizer, authorizer_reply,\n+\t\t\t\t      isvalid, session_key,\n+\t\t\t\t      challenge);\n }\n \n ConnectionRef SimpleMessenger::get_connection(const entity_inst_t& dest)"
        },
        {
          "filename": "src/msg/simple/SimpleMessenger.h",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -346,8 +346,10 @@ class SimpleMessenger : public SimplePolicyMessenger {\n   /**\n    * This wraps ms_deliver_verify_authorizer; we use it for Pipe.\n    */\n-  bool verify_authorizer(Connection *con, int peer_type, int protocol, bufferlist& auth, bufferlist& auth_reply,\n-                         bool& isvalid,CryptoKey& session_key);\n+  bool verify_authorizer(Connection *con, int peer_type, int protocol, bufferlist& auth,\n+\t\t\t bufferlist& auth_reply,\n+                         bool& isvalid,CryptoKey& session_key,\n+\t\t\t std::unique_ptr<AuthAuthorizerChallenge> *challenge);\n   /**\n    * Increment the global sequence for this SimpleMessenger and return it.\n    * This is for the connect protocol, although it doesn't hurt if somebody"
        },
        {
          "filename": "src/osd/OSD.cc",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -7236,9 +7236,11 @@ bool OSD::ms_get_authorizer(int dest_type, AuthAuthorizer **authorizer, bool for\n }\n \n \n-bool OSD::ms_verify_authorizer(Connection *con, int peer_type,\n-\t\t\t       int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n-\t\t\t       bool& isvalid, CryptoKey& session_key)\n+bool OSD::ms_verify_authorizer(\n+  Connection *con, int peer_type,\n+  int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n+  bool& isvalid, CryptoKey& session_key,\n+  std::unique_ptr<AuthAuthorizerChallenge> *challenge)\n {\n   AuthAuthorizeHandler *authorize_handler = 0;\n   switch (peer_type) {\n@@ -7270,7 +7272,7 @@ bool OSD::ms_verify_authorizer(Connection *con, int peer_type,\n     isvalid = authorize_handler->verify_authorizer(\n       cct, keys,\n       authorizer_data, authorizer_reply, name, global_id, caps_info, session_key,\n-      &auid);\n+      &auid, challenge);\n   } else {\n     dout(10) << __func__ << \" no rotating_keys (yet), denied\" << dendl;\n     isvalid = false;"
        },
        {
          "filename": "src/osd/OSD.h",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -1582,7 +1582,8 @@ class OSD : public Dispatcher,\n     }\n     bool ms_verify_authorizer(Connection *con, int peer_type,\n \t\t\t      int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n-\t\t\t      bool& isvalid, CryptoKey& session_key) override {\n+\t\t\t      bool& isvalid, CryptoKey& session_key,\n+\t\t\t      std::unique_ptr<AuthAuthorizerChallenge> *challenge) override {\n       isvalid = true;\n       return true;\n     }\n@@ -2359,7 +2360,8 @@ class OSD : public Dispatcher,\n   bool ms_get_authorizer(int dest_type, AuthAuthorizer **authorizer, bool force_new) override;\n   bool ms_verify_authorizer(Connection *con, int peer_type,\n \t\t\t    int protocol, bufferlist& authorizer, bufferlist& authorizer_reply,\n-\t\t\t    bool& isvalid, CryptoKey& session_key) override;\n+\t\t\t    bool& isvalid, CryptoKey& session_key,\n+\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;\n   void ms_handle_connect(Connection *con) override;\n   void ms_handle_fast_connect(Connection *con) override;\n   void ms_handle_fast_accept(Connection *con) override;"
        },
        {
          "filename": "src/test/messenger/simple_dispatcher.h",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -113,9 +113,10 @@ class SimpleDispatcher: public Dispatcher {\n    * authorizer, false otherwise.\n    */\n   bool ms_verify_authorizer(Connection *con, int peer_type,\n-\t\t\t\t    int protocol, bufferlist& authorizer,\n-\t\t\t\t    bufferlist& authorizer_reply,\n-\t\t\t\t    bool& isvalid, CryptoKey& session_key) override {\n+\t\t\t    int protocol, bufferlist& authorizer,\n+\t\t\t    bufferlist& authorizer_reply,\n+\t\t\t    bool& isvalid, CryptoKey& session_key,\n+\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override {\n     /* always succeed */\n     isvalid = true;\n     return true;"
        },
        {
          "filename": "src/test/messenger/xio_dispatcher.h",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -115,7 +115,8 @@ class XioDispatcher: public Dispatcher {\n   virtual bool ms_verify_authorizer(Connection *con, int peer_type,\n \t\t\t\t    int protocol, bufferlist& authorizer,\n \t\t\t\t    bufferlist& authorizer_reply,\n-\t\t\t\t    bool& isvalid, CryptoKey& session_key) {\n+\t\t\t\t    bool& isvalid, CryptoKey& session_key,\n+\t\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) {\n     /* always succeed */\n     isvalid = true;\n     return true;"
        },
        {
          "filename": "src/test/msgr/perf_msgr_client.cc",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -58,7 +58,8 @@ class MessengerClient {\n     bool ms_handle_refused(Connection *con) override { return false; }\n     bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                               bufferlist& authorizer, bufferlist& authorizer_reply,\n-                              bool& isvalid, CryptoKey& session_key) override {\n+                              bool& isvalid, CryptoKey& session_key,\n+\t\t\t      std::unique_ptr<AuthAuthorizerChallenge> *challenge) override {\n       isvalid = true;\n       return true;\n     }"
        },
        {
          "filename": "src/test/msgr/perf_msgr_server.cc",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -100,7 +100,8 @@ class ServerDispatcher : public Dispatcher {\n   }\n   bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                             bufferlist& authorizer, bufferlist& authorizer_reply,\n-                            bool& isvalid, CryptoKey& session_key) override {\n+                            bool& isvalid, CryptoKey& session_key,\n+\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override {\n     isvalid = true;\n     return true;\n   }"
        },
        {
          "filename": "src/test/msgr/test_msgr.cc",
          "status": "modified",
          "additions": 6,
          "deletions": 3,
          "patch": "@@ -203,7 +203,8 @@ class FakeDispatcher : public Dispatcher {\n \n   bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                             bufferlist& authorizer, bufferlist& authorizer_reply,\n-                            bool& isvalid, CryptoKey& session_key) override {\n+                            bool& isvalid, CryptoKey& session_key,\n+\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override {\n     isvalid = true;\n     return true;\n   }\n@@ -893,7 +894,8 @@ class SyntheticDispatcher : public Dispatcher {\n \n   bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                             bufferlist& authorizer, bufferlist& authorizer_reply,\n-                            bool& isvalid, CryptoKey& session_key) override {\n+                            bool& isvalid, CryptoKey& session_key,\n+\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override {\n     isvalid = true;\n     return true;\n   }\n@@ -1436,7 +1438,8 @@ class MarkdownDispatcher : public Dispatcher {\n   }\n   bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                             bufferlist& authorizer, bufferlist& authorizer_reply,\n-                            bool& isvalid, CryptoKey& session_key) override {\n+                            bool& isvalid, CryptoKey& session_key,\n+\t\t\t    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override {\n     isvalid = true;\n     return true;\n   }"
        }
      ],
      "file_patterns": {
        "security_files": 12,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 5,
        "unique_directories": 14,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "88b53e28ee8c5c52a2e195e4c03a1c58ce67647c",
            "date": "2025-01-26T07:51:31Z",
            "author_login": "ronen-fr"
          },
          {
            "sha": "3d944579d521defc949879ab2dd6f41c2196416f",
            "date": "2025-01-25T17:49:05Z",
            "author_login": "idryomov"
          },
          {
            "sha": "4c09477c256cf11533b339838f611d7647313f25",
            "date": "2025-01-25T17:06:43Z",
            "author_login": "zdover23"
          },
          {
            "sha": "5670054bd0533c8f2507d0596797214da8ba489a",
            "date": "2025-01-24T13:46:19Z",
            "author_login": "zdover23"
          },
          {
            "sha": "67f5769ce6e110b89362763cfb41a0e00e595cdf",
            "date": "2025-01-25T10:11:14Z",
            "author_login": "idryomov"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-294",
    "description": "It was found that cephx authentication protocol did not verify ceph clients correctly and was vulnerable to replay attack. Any attacker having access to ceph cluster network who is able to sniff packets on network can use this vulnerability to authenticate with ceph service and perform actions allowed by ceph service. Ceph branches master, mimic, luminous and jewel are believed to be vulnerable.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-07-10T14:29:00.370",
    "last_modified": "2024-11-21T03:59:14.563",
    "fix_date": "2018-05-24T21:55:26Z"
  },
  "references": [
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2019-04/msg00100.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://tracker.ceph.com/issues/24836",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2020/11/17/3",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2020/11/17/4",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:2177",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:2179",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:2261",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:2274",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1575866",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ceph/ceph/commit/5ead97120e07054d80623dada90a5cc764c28468",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00017.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2018/dsa-4339",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2019-04/msg00100.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://tracker.ceph.com/issues/24836",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2020/11/17/3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2020/11/17/4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:2177",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:2179",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:2261",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:2274",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1575866",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ceph/ceph/commit/5ead97120e07054d80623dada90a5cc764c28468",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00017.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2018/dsa-4339",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:28.632262",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "ceph",
    "owner": "ceph",
    "created_at": "2011-09-01T21:41:26Z",
    "updated_at": "2025-01-26T07:51:36Z",
    "pushed_at": "2025-01-26T07:51:31Z",
    "size": 813624,
    "stars": 14476,
    "forks": 6061,
    "open_issues": 836,
    "watchers": 14476,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "argonaut",
      "bobtail",
      "cuttlefish"
    ],
    "languages": {
      "C++": 50333744,
      "Python": 12344928,
      "Raku": 3800803,
      "C": 3470858,
      "TypeScript": 3408430,
      "Shell": 2350089,
      "HTML": 881976,
      "CMake": 874020,
      "Terra": 773718,
      "Cython": 630103,
      "Jsonnet": 382417,
      "JavaScript": 141459,
      "Java": 109488,
      "Gherkin": 97105,
      "Perl": 69050,
      "Assembly": 53250,
      "SCSS": 50600,
      "Jinja": 37110,
      "Roff": 26436,
      "PowerShell": 10012,
      "Dockerfile": 9380,
      "Makefile": 4786,
      "Awk": 3196,
      "CSS": 2086,
      "DIGITAL Command Language": 2074,
      "Lua": 1304,
      "SWIG": 951,
      "Turing": 941,
      "Smarty": 173
    },
    "commit_activity": {
      "total_commits_last_year": 6386,
      "avg_commits_per_week": 122.8076923076923,
      "days_active_last_year": 355
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T08:25:32.814428"
  }
}