{
  "cve_id": "CVE-2018-11512",
  "github_data": {
    "repository": "Creatiwity/wityCMS",
    "fix_commit": "7967e5bf15b4d2ee6b85b56e82d7e1229147de44",
    "related_commits": [
      "7967e5bf15b4d2ee6b85b56e82d7e1229147de44",
      "7967e5bf15b4d2ee6b85b56e82d7e1229147de44"
    ],
    "patch_url": "https://github.com/Creatiwity/wityCMS/commit/7967e5bf15b4d2ee6b85b56e82d7e1229147de44.patch",
    "fix_commit_details": {
      "sha": "7967e5bf15b4d2ee6b85b56e82d7e1229147de44",
      "commit_date": "2017-02-26T10:45:28Z",
      "author": {
        "login": "JohanDufau",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "#146 - Uses HTML purifier and htmlspecialchars in search app",
        "length": 60,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 31747,
        "additions": 31724,
        "deletions": 23
      },
      "files": [
        {
          "filename": ".gitignore",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -9,3 +9,6 @@ upload/[^.]*/\n \n # macOS\n .DS_Store\n+\n+# HTML Purifier\n+helpers/htmlpurifier/HTMLPurifier/DefinitionCache/Serializer/*/"
        },
        {
          "filename": "apps/search/front/templates/form.html",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -1,9 +1,9 @@\n <div class=\"wity-app wity-app-search wity-action-form\">\n-\t<h1>{lang Research} {if !empty({$query})}<strong>\"{$query}\"</strong>{/if}</h1>\n+\t<h1>{lang Research} {if !empty({$query})}<strong>\"{!$query!}\"</strong>{/if}</h1>\n \n \t<form class=\"search-form\" action=\"/search\" method=\"get\">\n \t\t<p class=\"input-group research\">\n-\t\t\t<input class=\"form-control\" type=\"text\" name=\"query\" placeholder=\"{lang Search}\" value=\"{if !empty({$query})}{$query}{/if}\" />\n+\t\t\t<input class=\"form-control\" type=\"text\" name=\"query\" placeholder=\"{lang Search}\" value=\"{if !empty({$query})}{!$query!}{/if}\" />\n \t\t\t<span class=\"input-group-btn\">\n \t\t\t\t<button class=\"btn btn-default\" type=\"submit\"><span class=\"glyphicon glyphicon-search\"></span></button>\n \t\t\t</span>"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier.auto.php",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+<?php\n+\n+/**\n+ * This is a stub include that automatically configures the include path.\n+ */\n+\n+set_include_path(dirname(__FILE__) . PATH_SEPARATOR . get_include_path() );\n+require_once 'HTMLPurifier/Bootstrap.php';\n+require_once 'HTMLPurifier.autoload.php';\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier.autoload.php",
          "status": "added",
          "additions": 27,
          "deletions": 0,
          "patch": "@@ -0,0 +1,27 @@\n+<?php\n+\n+/**\n+ * @file\n+ * Convenience file that registers autoload handler for HTML Purifier.\n+ * It also does some sanity checks.\n+ */\n+\n+if (function_exists('spl_autoload_register') && function_exists('spl_autoload_unregister')) {\n+    // We need unregister for our pre-registering functionality\n+    HTMLPurifier_Bootstrap::registerAutoload();\n+    if (function_exists('__autoload')) {\n+        // Be polite and ensure that userland autoload gets retained\n+        spl_autoload_register('__autoload');\n+    }\n+} elseif (!function_exists('__autoload')) {\n+    function __autoload($class)\n+    {\n+        return HTMLPurifier_Bootstrap::autoload($class);\n+    }\n+}\n+\n+if (ini_get('zend.ze1_compatibility_mode')) {\n+    trigger_error(\"HTML Purifier is not compatible with zend.ze1_compatibility_mode; please turn it off\", E_USER_ERROR);\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier.composer.php",
          "status": "added",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -0,0 +1,4 @@\n+<?php\n+if (!defined('HTMLPURIFIER_PREFIX')) {\n+    define('HTMLPURIFIER_PREFIX', dirname(__FILE__));\n+}"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier.func.php",
          "status": "added",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -0,0 +1,25 @@\n+<?php\n+\n+/**\n+ * @file\n+ * Defines a function wrapper for HTML Purifier for quick use.\n+ * @note ''HTMLPurifier()'' is NOT the same as ''new HTMLPurifier()''\n+ */\n+\n+/**\n+ * Purify HTML.\n+ * @param string $html String HTML to purify\n+ * @param mixed $config Configuration to use, can be any value accepted by\n+ *        HTMLPurifier_Config::create()\n+ * @return string\n+ */\n+function HTMLPurifier($html, $config = null)\n+{\n+    static $purifier = false;\n+    if (!$purifier) {\n+        $purifier = new HTMLPurifier();\n+    }\n+    return $purifier->purify($html, $config);\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier.includes.php",
          "status": "added",
          "additions": 232,
          "deletions": 0,
          "patch": "@@ -0,0 +1,232 @@\n+<?php\n+\n+/**\n+ * @file\n+ * This file was auto-generated by generate-includes.php and includes all of\n+ * the core files required by HTML Purifier. Use this if performance is a\n+ * primary concern and you are using an opcode cache. PLEASE DO NOT EDIT THIS\n+ * FILE, changes will be overwritten the next time the script is run.\n+ *\n+ * @version 4.8.0\n+ *\n+ * @warning\n+ *      You must *not* include any other HTML Purifier files before this file,\n+ *      because 'require' not 'require_once' is used.\n+ *\n+ * @warning\n+ *      This file requires that the include path contains the HTML Purifier\n+ *      library directory; this is not auto-set.\n+ */\n+\n+require 'HTMLPurifier.php';\n+require 'HTMLPurifier/Arborize.php';\n+require 'HTMLPurifier/AttrCollections.php';\n+require 'HTMLPurifier/AttrDef.php';\n+require 'HTMLPurifier/AttrTransform.php';\n+require 'HTMLPurifier/AttrTypes.php';\n+require 'HTMLPurifier/AttrValidator.php';\n+require 'HTMLPurifier/Bootstrap.php';\n+require 'HTMLPurifier/Definition.php';\n+require 'HTMLPurifier/CSSDefinition.php';\n+require 'HTMLPurifier/ChildDef.php';\n+require 'HTMLPurifier/Config.php';\n+require 'HTMLPurifier/ConfigSchema.php';\n+require 'HTMLPurifier/ContentSets.php';\n+require 'HTMLPurifier/Context.php';\n+require 'HTMLPurifier/DefinitionCache.php';\n+require 'HTMLPurifier/DefinitionCacheFactory.php';\n+require 'HTMLPurifier/Doctype.php';\n+require 'HTMLPurifier/DoctypeRegistry.php';\n+require 'HTMLPurifier/ElementDef.php';\n+require 'HTMLPurifier/Encoder.php';\n+require 'HTMLPurifier/EntityLookup.php';\n+require 'HTMLPurifier/EntityParser.php';\n+require 'HTMLPurifier/ErrorCollector.php';\n+require 'HTMLPurifier/ErrorStruct.php';\n+require 'HTMLPurifier/Exception.php';\n+require 'HTMLPurifier/Filter.php';\n+require 'HTMLPurifier/Generator.php';\n+require 'HTMLPurifier/HTMLDefinition.php';\n+require 'HTMLPurifier/HTMLModule.php';\n+require 'HTMLPurifier/HTMLModuleManager.php';\n+require 'HTMLPurifier/IDAccumulator.php';\n+require 'HTMLPurifier/Injector.php';\n+require 'HTMLPurifier/Language.php';\n+require 'HTMLPurifier/LanguageFactory.php';\n+require 'HTMLPurifier/Length.php';\n+require 'HTMLPurifier/Lexer.php';\n+require 'HTMLPurifier/Node.php';\n+require 'HTMLPurifier/PercentEncoder.php';\n+require 'HTMLPurifier/PropertyList.php';\n+require 'HTMLPurifier/PropertyListIterator.php';\n+require 'HTMLPurifier/Queue.php';\n+require 'HTMLPurifier/Strategy.php';\n+require 'HTMLPurifier/StringHash.php';\n+require 'HTMLPurifier/StringHashParser.php';\n+require 'HTMLPurifier/TagTransform.php';\n+require 'HTMLPurifier/Token.php';\n+require 'HTMLPurifier/TokenFactory.php';\n+require 'HTMLPurifier/URI.php';\n+require 'HTMLPurifier/URIDefinition.php';\n+require 'HTMLPurifier/URIFilter.php';\n+require 'HTMLPurifier/URIParser.php';\n+require 'HTMLPurifier/URIScheme.php';\n+require 'HTMLPurifier/URISchemeRegistry.php';\n+require 'HTMLPurifier/UnitConverter.php';\n+require 'HTMLPurifier/VarParser.php';\n+require 'HTMLPurifier/VarParserException.php';\n+require 'HTMLPurifier/Zipper.php';\n+require 'HTMLPurifier/AttrDef/CSS.php';\n+require 'HTMLPurifier/AttrDef/Clone.php';\n+require 'HTMLPurifier/AttrDef/Enum.php';\n+require 'HTMLPurifier/AttrDef/Integer.php';\n+require 'HTMLPurifier/AttrDef/Lang.php';\n+require 'HTMLPurifier/AttrDef/Switch.php';\n+require 'HTMLPurifier/AttrDef/Text.php';\n+require 'HTMLPurifier/AttrDef/URI.php';\n+require 'HTMLPurifier/AttrDef/CSS/Number.php';\n+require 'HTMLPurifier/AttrDef/CSS/AlphaValue.php';\n+require 'HTMLPurifier/AttrDef/CSS/Background.php';\n+require 'HTMLPurifier/AttrDef/CSS/BackgroundPosition.php';\n+require 'HTMLPurifier/AttrDef/CSS/Border.php';\n+require 'HTMLPurifier/AttrDef/CSS/Color.php';\n+require 'HTMLPurifier/AttrDef/CSS/Composite.php';\n+require 'HTMLPurifier/AttrDef/CSS/DenyElementDecorator.php';\n+require 'HTMLPurifier/AttrDef/CSS/Filter.php';\n+require 'HTMLPurifier/AttrDef/CSS/Font.php';\n+require 'HTMLPurifier/AttrDef/CSS/FontFamily.php';\n+require 'HTMLPurifier/AttrDef/CSS/Ident.php';\n+require 'HTMLPurifier/AttrDef/CSS/ImportantDecorator.php';\n+require 'HTMLPurifier/AttrDef/CSS/Length.php';\n+require 'HTMLPurifier/AttrDef/CSS/ListStyle.php';\n+require 'HTMLPurifier/AttrDef/CSS/Multiple.php';\n+require 'HTMLPurifier/AttrDef/CSS/Percentage.php';\n+require 'HTMLPurifier/AttrDef/CSS/TextDecoration.php';\n+require 'HTMLPurifier/AttrDef/CSS/URI.php';\n+require 'HTMLPurifier/AttrDef/HTML/Bool.php';\n+require 'HTMLPurifier/AttrDef/HTML/Nmtokens.php';\n+require 'HTMLPurifier/AttrDef/HTML/Class.php';\n+require 'HTMLPurifier/AttrDef/HTML/Color.php';\n+require 'HTMLPurifier/AttrDef/HTML/FrameTarget.php';\n+require 'HTMLPurifier/AttrDef/HTML/ID.php';\n+require 'HTMLPurifier/AttrDef/HTML/Pixels.php';\n+require 'HTMLPurifier/AttrDef/HTML/Length.php';\n+require 'HTMLPurifier/AttrDef/HTML/LinkTypes.php';\n+require 'HTMLPurifier/AttrDef/HTML/MultiLength.php';\n+require 'HTMLPurifier/AttrDef/URI/Email.php';\n+require 'HTMLPurifier/AttrDef/URI/Host.php';\n+require 'HTMLPurifier/AttrDef/URI/IPv4.php';\n+require 'HTMLPurifier/AttrDef/URI/IPv6.php';\n+require 'HTMLPurifier/AttrDef/URI/Email/SimpleCheck.php';\n+require 'HTMLPurifier/AttrTransform/Background.php';\n+require 'HTMLPurifier/AttrTransform/BdoDir.php';\n+require 'HTMLPurifier/AttrTransform/BgColor.php';\n+require 'HTMLPurifier/AttrTransform/BoolToCSS.php';\n+require 'HTMLPurifier/AttrTransform/Border.php';\n+require 'HTMLPurifier/AttrTransform/EnumToCSS.php';\n+require 'HTMLPurifier/AttrTransform/ImgRequired.php';\n+require 'HTMLPurifier/AttrTransform/ImgSpace.php';\n+require 'HTMLPurifier/AttrTransform/Input.php';\n+require 'HTMLPurifier/AttrTransform/Lang.php';\n+require 'HTMLPurifier/AttrTransform/Length.php';\n+require 'HTMLPurifier/AttrTransform/Name.php';\n+require 'HTMLPurifier/AttrTransform/NameSync.php';\n+require 'HTMLPurifier/AttrTransform/Nofollow.php';\n+require 'HTMLPurifier/AttrTransform/SafeEmbed.php';\n+require 'HTMLPurifier/AttrTransform/SafeObject.php';\n+require 'HTMLPurifier/AttrTransform/SafeParam.php';\n+require 'HTMLPurifier/AttrTransform/ScriptRequired.php';\n+require 'HTMLPurifier/AttrTransform/TargetBlank.php';\n+require 'HTMLPurifier/AttrTransform/TargetNoreferrer.php';\n+require 'HTMLPurifier/AttrTransform/Textarea.php';\n+require 'HTMLPurifier/ChildDef/Chameleon.php';\n+require 'HTMLPurifier/ChildDef/Custom.php';\n+require 'HTMLPurifier/ChildDef/Empty.php';\n+require 'HTMLPurifier/ChildDef/List.php';\n+require 'HTMLPurifier/ChildDef/Required.php';\n+require 'HTMLPurifier/ChildDef/Optional.php';\n+require 'HTMLPurifier/ChildDef/StrictBlockquote.php';\n+require 'HTMLPurifier/ChildDef/Table.php';\n+require 'HTMLPurifier/DefinitionCache/Decorator.php';\n+require 'HTMLPurifier/DefinitionCache/Null.php';\n+require 'HTMLPurifier/DefinitionCache/Serializer.php';\n+require 'HTMLPurifier/DefinitionCache/Decorator/Cleanup.php';\n+require 'HTMLPurifier/DefinitionCache/Decorator/Memory.php';\n+require 'HTMLPurifier/HTMLModule/Bdo.php';\n+require 'HTMLPurifier/HTMLModule/CommonAttributes.php';\n+require 'HTMLPurifier/HTMLModule/Edit.php';\n+require 'HTMLPurifier/HTMLModule/Forms.php';\n+require 'HTMLPurifier/HTMLModule/Hypertext.php';\n+require 'HTMLPurifier/HTMLModule/Iframe.php';\n+require 'HTMLPurifier/HTMLModule/Image.php';\n+require 'HTMLPurifier/HTMLModule/Legacy.php';\n+require 'HTMLPurifier/HTMLModule/List.php';\n+require 'HTMLPurifier/HTMLModule/Name.php';\n+require 'HTMLPurifier/HTMLModule/Nofollow.php';\n+require 'HTMLPurifier/HTMLModule/NonXMLCommonAttributes.php';\n+require 'HTMLPurifier/HTMLModule/Object.php';\n+require 'HTMLPurifier/HTMLModule/Presentation.php';\n+require 'HTMLPurifier/HTMLModule/Proprietary.php';\n+require 'HTMLPurifier/HTMLModule/Ruby.php';\n+require 'HTMLPurifier/HTMLModule/SafeEmbed.php';\n+require 'HTMLPurifier/HTMLModule/SafeObject.php';\n+require 'HTMLPurifier/HTMLModule/SafeScripting.php';\n+require 'HTMLPurifier/HTMLModule/Scripting.php';\n+require 'HTMLPurifier/HTMLModule/StyleAttribute.php';\n+require 'HTMLPurifier/HTMLModule/Tables.php';\n+require 'HTMLPurifier/HTMLModule/Target.php';\n+require 'HTMLPurifier/HTMLModule/TargetBlank.php';\n+require 'HTMLPurifier/HTMLModule/TargetNoreferrer.php';\n+require 'HTMLPurifier/HTMLModule/Text.php';\n+require 'HTMLPurifier/HTMLModule/Tidy.php';\n+require 'HTMLPurifier/HTMLModule/XMLCommonAttributes.php';\n+require 'HTMLPurifier/HTMLModule/Tidy/Name.php';\n+require 'HTMLPurifier/HTMLModule/Tidy/Proprietary.php';\n+require 'HTMLPurifier/HTMLModule/Tidy/XHTMLAndHTML4.php';\n+require 'HTMLPurifier/HTMLModule/Tidy/Strict.php';\n+require 'HTMLPurifier/HTMLModule/Tidy/Transitional.php';\n+require 'HTMLPurifier/HTMLModule/Tidy/XHTML.php';\n+require 'HTMLPurifier/Injector/AutoParagraph.php';\n+require 'HTMLPurifier/Injector/DisplayLinkURI.php';\n+require 'HTMLPurifier/Injector/Linkify.php';\n+require 'HTMLPurifier/Injector/PurifierLinkify.php';\n+require 'HTMLPurifier/Injector/RemoveEmpty.php';\n+require 'HTMLPurifier/Injector/RemoveSpansWithoutAttributes.php';\n+require 'HTMLPurifier/Injector/SafeObject.php';\n+require 'HTMLPurifier/Lexer/DOMLex.php';\n+require 'HTMLPurifier/Lexer/DirectLex.php';\n+require 'HTMLPurifier/Node/Comment.php';\n+require 'HTMLPurifier/Node/Element.php';\n+require 'HTMLPurifier/Node/Text.php';\n+require 'HTMLPurifier/Strategy/Composite.php';\n+require 'HTMLPurifier/Strategy/Core.php';\n+require 'HTMLPurifier/Strategy/FixNesting.php';\n+require 'HTMLPurifier/Strategy/MakeWellFormed.php';\n+require 'HTMLPurifier/Strategy/RemoveForeignElements.php';\n+require 'HTMLPurifier/Strategy/ValidateAttributes.php';\n+require 'HTMLPurifier/TagTransform/Font.php';\n+require 'HTMLPurifier/TagTransform/Simple.php';\n+require 'HTMLPurifier/Token/Comment.php';\n+require 'HTMLPurifier/Token/Tag.php';\n+require 'HTMLPurifier/Token/Empty.php';\n+require 'HTMLPurifier/Token/End.php';\n+require 'HTMLPurifier/Token/Start.php';\n+require 'HTMLPurifier/Token/Text.php';\n+require 'HTMLPurifier/URIFilter/DisableExternal.php';\n+require 'HTMLPurifier/URIFilter/DisableExternalResources.php';\n+require 'HTMLPurifier/URIFilter/DisableResources.php';\n+require 'HTMLPurifier/URIFilter/HostBlacklist.php';\n+require 'HTMLPurifier/URIFilter/MakeAbsolute.php';\n+require 'HTMLPurifier/URIFilter/Munge.php';\n+require 'HTMLPurifier/URIFilter/SafeIframe.php';\n+require 'HTMLPurifier/URIScheme/data.php';\n+require 'HTMLPurifier/URIScheme/file.php';\n+require 'HTMLPurifier/URIScheme/ftp.php';\n+require 'HTMLPurifier/URIScheme/http.php';\n+require 'HTMLPurifier/URIScheme/https.php';\n+require 'HTMLPurifier/URIScheme/mailto.php';\n+require 'HTMLPurifier/URIScheme/news.php';\n+require 'HTMLPurifier/URIScheme/nntp.php';\n+require 'HTMLPurifier/URIScheme/tel.php';\n+require 'HTMLPurifier/VarParser/Flexible.php';\n+require 'HTMLPurifier/VarParser/Native.php';"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier.kses.php",
          "status": "added",
          "additions": 30,
          "deletions": 0,
          "patch": "@@ -0,0 +1,30 @@\n+<?php\n+\n+/**\n+ * @file\n+ * Emulation layer for code that used kses(), substituting in HTML Purifier.\n+ */\n+\n+require_once dirname(__FILE__) . '/HTMLPurifier.auto.php';\n+\n+function kses($string, $allowed_html, $allowed_protocols = null)\n+{\n+    $config = HTMLPurifier_Config::createDefault();\n+    $allowed_elements = array();\n+    $allowed_attributes = array();\n+    foreach ($allowed_html as $element => $attributes) {\n+        $allowed_elements[$element] = true;\n+        foreach ($attributes as $attribute => $x) {\n+            $allowed_attributes[\"$element.$attribute\"] = true;\n+        }\n+    }\n+    $config->set('HTML.AllowedElements', $allowed_elements);\n+    $config->set('HTML.AllowedAttributes', $allowed_attributes);\n+    if ($allowed_protocols !== null) {\n+        $config->set('URI.AllowedSchemes', $allowed_protocols);\n+    }\n+    $purifier = new HTMLPurifier($config);\n+    return $purifier->purify($string);\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier.path.php",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+<?php\n+\n+/**\n+ * @file\n+ * Convenience stub file that adds HTML Purifier's library file to the path\n+ * without any other side-effects.\n+ */\n+\n+set_include_path(dirname(__FILE__) . PATH_SEPARATOR . get_include_path() );\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier.php",
          "status": "added",
          "additions": 292,
          "deletions": 0,
          "patch": "@@ -0,0 +1,292 @@\n+<?php\n+\n+/*! @mainpage\n+ *\n+ * HTML Purifier is an HTML filter that will take an arbitrary snippet of\n+ * HTML and rigorously test, validate and filter it into a version that\n+ * is safe for output onto webpages. It achieves this by:\n+ *\n+ *  -# Lexing (parsing into tokens) the document,\n+ *  -# Executing various strategies on the tokens:\n+ *      -# Removing all elements not in the whitelist,\n+ *      -# Making the tokens well-formed,\n+ *      -# Fixing the nesting of the nodes, and\n+ *      -# Validating attributes of the nodes; and\n+ *  -# Generating HTML from the purified tokens.\n+ *\n+ * However, most users will only need to interface with the HTMLPurifier\n+ * and HTMLPurifier_Config.\n+ */\n+\n+/*\n+    HTML Purifier 4.8.0 - Standards Compliant HTML Filtering\n+    Copyright (C) 2006-2008 Edward Z. Yang\n+\n+    This library is free software; you can redistribute it and/or\n+    modify it under the terms of the GNU Lesser General Public\n+    License as published by the Free Software Foundation; either\n+    version 2.1 of the License, or (at your option) any later version.\n+\n+    This library is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+    Lesser General Public License for more details.\n+\n+    You should have received a copy of the GNU Lesser General Public\n+    License along with this library; if not, write to the Free Software\n+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+/**\n+ * Facade that coordinates HTML Purifier's subsystems in order to purify HTML.\n+ *\n+ * @note There are several points in which configuration can be specified\n+ *       for HTML Purifier.  The precedence of these (from lowest to\n+ *       highest) is as follows:\n+ *          -# Instance: new HTMLPurifier($config)\n+ *          -# Invocation: purify($html, $config)\n+ *       These configurations are entirely independent of each other and\n+ *       are *not* merged (this behavior may change in the future).\n+ *\n+ * @todo We need an easier way to inject strategies using the configuration\n+ *       object.\n+ */\n+class HTMLPurifier\n+{\n+\n+    /**\n+     * Version of HTML Purifier.\n+     * @type string\n+     */\n+    public $version = '4.8.0';\n+\n+    /**\n+     * Constant with version of HTML Purifier.\n+     */\n+    const VERSION = '4.8.0';\n+\n+    /**\n+     * Global configuration object.\n+     * @type HTMLPurifier_Config\n+     */\n+    public $config;\n+\n+    /**\n+     * Array of extra filter objects to run on HTML,\n+     * for backwards compatibility.\n+     * @type HTMLPurifier_Filter[]\n+     */\n+    private $filters = array();\n+\n+    /**\n+     * Single instance of HTML Purifier.\n+     * @type HTMLPurifier\n+     */\n+    private static $instance;\n+\n+    /**\n+     * @type HTMLPurifier_Strategy_Core\n+     */\n+    protected $strategy;\n+\n+    /**\n+     * @type HTMLPurifier_Generator\n+     */\n+    protected $generator;\n+\n+    /**\n+     * Resultant context of last run purification.\n+     * Is an array of contexts if the last called method was purifyArray().\n+     * @type HTMLPurifier_Context\n+     */\n+    public $context;\n+\n+    /**\n+     * Initializes the purifier.\n+     *\n+     * @param HTMLPurifier_Config|mixed $config Optional HTMLPurifier_Config object\n+     *                for all instances of the purifier, if omitted, a default\n+     *                configuration is supplied (which can be overridden on a\n+     *                per-use basis).\n+     *                The parameter can also be any type that\n+     *                HTMLPurifier_Config::create() supports.\n+     */\n+    public function __construct($config = null)\n+    {\n+        $this->config = HTMLPurifier_Config::create($config);\n+        $this->strategy = new HTMLPurifier_Strategy_Core();\n+    }\n+\n+    /**\n+     * Adds a filter to process the output. First come first serve\n+     *\n+     * @param HTMLPurifier_Filter $filter HTMLPurifier_Filter object\n+     */\n+    public function addFilter($filter)\n+    {\n+        trigger_error(\n+            'HTMLPurifier->addFilter() is deprecated, use configuration directives' .\n+            ' in the Filter namespace or Filter.Custom',\n+            E_USER_WARNING\n+        );\n+        $this->filters[] = $filter;\n+    }\n+\n+    /**\n+     * Filters an HTML snippet/document to be XSS-free and standards-compliant.\n+     *\n+     * @param string $html String of HTML to purify\n+     * @param HTMLPurifier_Config $config Config object for this operation,\n+     *                if omitted, defaults to the config object specified during this\n+     *                object's construction. The parameter can also be any type\n+     *                that HTMLPurifier_Config::create() supports.\n+     *\n+     * @return string Purified HTML\n+     */\n+    public function purify($html, $config = null)\n+    {\n+        // :TODO: make the config merge in, instead of replace\n+        $config = $config ? HTMLPurifier_Config::create($config) : $this->config;\n+\n+        // implementation is partially environment dependant, partially\n+        // configuration dependant\n+        $lexer = HTMLPurifier_Lexer::create($config);\n+\n+        $context = new HTMLPurifier_Context();\n+\n+        // setup HTML generator\n+        $this->generator = new HTMLPurifier_Generator($config, $context);\n+        $context->register('Generator', $this->generator);\n+\n+        // set up global context variables\n+        if ($config->get('Core.CollectErrors')) {\n+            // may get moved out if other facilities use it\n+            $language_factory = HTMLPurifier_LanguageFactory::instance();\n+            $language = $language_factory->create($config, $context);\n+            $context->register('Locale', $language);\n+\n+            $error_collector = new HTMLPurifier_ErrorCollector($context);\n+            $context->register('ErrorCollector', $error_collector);\n+        }\n+\n+        // setup id_accumulator context, necessary due to the fact that\n+        // AttrValidator can be called from many places\n+        $id_accumulator = HTMLPurifier_IDAccumulator::build($config, $context);\n+        $context->register('IDAccumulator', $id_accumulator);\n+\n+        $html = HTMLPurifier_Encoder::convertToUTF8($html, $config, $context);\n+\n+        // setup filters\n+        $filter_flags = $config->getBatch('Filter');\n+        $custom_filters = $filter_flags['Custom'];\n+        unset($filter_flags['Custom']);\n+        $filters = array();\n+        foreach ($filter_flags as $filter => $flag) {\n+            if (!$flag) {\n+                continue;\n+            }\n+            if (strpos($filter, '.') !== false) {\n+                continue;\n+            }\n+            $class = \"HTMLPurifier_Filter_$filter\";\n+            $filters[] = new $class;\n+        }\n+        foreach ($custom_filters as $filter) {\n+            // maybe \"HTMLPurifier_Filter_$filter\", but be consistent with AutoFormat\n+            $filters[] = $filter;\n+        }\n+        $filters = array_merge($filters, $this->filters);\n+        // maybe prepare(), but later\n+\n+        for ($i = 0, $filter_size = count($filters); $i < $filter_size; $i++) {\n+            $html = $filters[$i]->preFilter($html, $config, $context);\n+        }\n+\n+        // purified HTML\n+        $html =\n+            $this->generator->generateFromTokens(\n+                // list of tokens\n+                $this->strategy->execute(\n+                    // list of un-purified tokens\n+                    $lexer->tokenizeHTML(\n+                        // un-purified HTML\n+                        $html,\n+                        $config,\n+                        $context\n+                    ),\n+                    $config,\n+                    $context\n+                )\n+            );\n+\n+        for ($i = $filter_size - 1; $i >= 0; $i--) {\n+            $html = $filters[$i]->postFilter($html, $config, $context);\n+        }\n+\n+        $html = HTMLPurifier_Encoder::convertFromUTF8($html, $config, $context);\n+        $this->context =& $context;\n+        return $html;\n+    }\n+\n+    /**\n+     * Filters an array of HTML snippets\n+     *\n+     * @param string[] $array_of_html Array of html snippets\n+     * @param HTMLPurifier_Config $config Optional config object for this operation.\n+     *                See HTMLPurifier::purify() for more details.\n+     *\n+     * @return string[] Array of purified HTML\n+     */\n+    public function purifyArray($array_of_html, $config = null)\n+    {\n+        $context_array = array();\n+        foreach ($array_of_html as $key => $html) {\n+            $array_of_html[$key] = $this->purify($html, $config);\n+            $context_array[$key] = $this->context;\n+        }\n+        $this->context = $context_array;\n+        return $array_of_html;\n+    }\n+\n+    /**\n+     * Singleton for enforcing just one HTML Purifier in your system\n+     *\n+     * @param HTMLPurifier|HTMLPurifier_Config $prototype Optional prototype\n+     *                   HTMLPurifier instance to overload singleton with,\n+     *                   or HTMLPurifier_Config instance to configure the\n+     *                   generated version with.\n+     *\n+     * @return HTMLPurifier\n+     */\n+    public static function instance($prototype = null)\n+    {\n+        if (!self::$instance || $prototype) {\n+            if ($prototype instanceof HTMLPurifier) {\n+                self::$instance = $prototype;\n+            } elseif ($prototype) {\n+                self::$instance = new HTMLPurifier($prototype);\n+            } else {\n+                self::$instance = new HTMLPurifier();\n+            }\n+        }\n+        return self::$instance;\n+    }\n+\n+    /**\n+     * Singleton for enforcing just one HTML Purifier in your system\n+     *\n+     * @param HTMLPurifier|HTMLPurifier_Config $prototype Optional prototype\n+     *                   HTMLPurifier instance to overload singleton with,\n+     *                   or HTMLPurifier_Config instance to configure the\n+     *                   generated version with.\n+     *\n+     * @return HTMLPurifier\n+     * @note Backwards compatibility, see instance()\n+     */\n+    public static function getInstance($prototype = null)\n+    {\n+        return HTMLPurifier::instance($prototype);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier.safe-includes.php",
          "status": "added",
          "additions": 226,
          "deletions": 0,
          "patch": "@@ -0,0 +1,226 @@\n+<?php\n+\n+/**\n+ * @file\n+ * This file was auto-generated by generate-includes.php and includes all of\n+ * the core files required by HTML Purifier. This is a convenience stub that\n+ * includes all files using dirname(__FILE__) and require_once. PLEASE DO NOT\n+ * EDIT THIS FILE, changes will be overwritten the next time the script is run.\n+ *\n+ * Changes to include_path are not necessary.\n+ */\n+\n+$__dir = dirname(__FILE__);\n+\n+require_once $__dir . '/HTMLPurifier.php';\n+require_once $__dir . '/HTMLPurifier/Arborize.php';\n+require_once $__dir . '/HTMLPurifier/AttrCollections.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform.php';\n+require_once $__dir . '/HTMLPurifier/AttrTypes.php';\n+require_once $__dir . '/HTMLPurifier/AttrValidator.php';\n+require_once $__dir . '/HTMLPurifier/Bootstrap.php';\n+require_once $__dir . '/HTMLPurifier/Definition.php';\n+require_once $__dir . '/HTMLPurifier/CSSDefinition.php';\n+require_once $__dir . '/HTMLPurifier/ChildDef.php';\n+require_once $__dir . '/HTMLPurifier/Config.php';\n+require_once $__dir . '/HTMLPurifier/ConfigSchema.php';\n+require_once $__dir . '/HTMLPurifier/ContentSets.php';\n+require_once $__dir . '/HTMLPurifier/Context.php';\n+require_once $__dir . '/HTMLPurifier/DefinitionCache.php';\n+require_once $__dir . '/HTMLPurifier/DefinitionCacheFactory.php';\n+require_once $__dir . '/HTMLPurifier/Doctype.php';\n+require_once $__dir . '/HTMLPurifier/DoctypeRegistry.php';\n+require_once $__dir . '/HTMLPurifier/ElementDef.php';\n+require_once $__dir . '/HTMLPurifier/Encoder.php';\n+require_once $__dir . '/HTMLPurifier/EntityLookup.php';\n+require_once $__dir . '/HTMLPurifier/EntityParser.php';\n+require_once $__dir . '/HTMLPurifier/ErrorCollector.php';\n+require_once $__dir . '/HTMLPurifier/ErrorStruct.php';\n+require_once $__dir . '/HTMLPurifier/Exception.php';\n+require_once $__dir . '/HTMLPurifier/Filter.php';\n+require_once $__dir . '/HTMLPurifier/Generator.php';\n+require_once $__dir . '/HTMLPurifier/HTMLDefinition.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModuleManager.php';\n+require_once $__dir . '/HTMLPurifier/IDAccumulator.php';\n+require_once $__dir . '/HTMLPurifier/Injector.php';\n+require_once $__dir . '/HTMLPurifier/Language.php';\n+require_once $__dir . '/HTMLPurifier/LanguageFactory.php';\n+require_once $__dir . '/HTMLPurifier/Length.php';\n+require_once $__dir . '/HTMLPurifier/Lexer.php';\n+require_once $__dir . '/HTMLPurifier/Node.php';\n+require_once $__dir . '/HTMLPurifier/PercentEncoder.php';\n+require_once $__dir . '/HTMLPurifier/PropertyList.php';\n+require_once $__dir . '/HTMLPurifier/PropertyListIterator.php';\n+require_once $__dir . '/HTMLPurifier/Queue.php';\n+require_once $__dir . '/HTMLPurifier/Strategy.php';\n+require_once $__dir . '/HTMLPurifier/StringHash.php';\n+require_once $__dir . '/HTMLPurifier/StringHashParser.php';\n+require_once $__dir . '/HTMLPurifier/TagTransform.php';\n+require_once $__dir . '/HTMLPurifier/Token.php';\n+require_once $__dir . '/HTMLPurifier/TokenFactory.php';\n+require_once $__dir . '/HTMLPurifier/URI.php';\n+require_once $__dir . '/HTMLPurifier/URIDefinition.php';\n+require_once $__dir . '/HTMLPurifier/URIFilter.php';\n+require_once $__dir . '/HTMLPurifier/URIParser.php';\n+require_once $__dir . '/HTMLPurifier/URIScheme.php';\n+require_once $__dir . '/HTMLPurifier/URISchemeRegistry.php';\n+require_once $__dir . '/HTMLPurifier/UnitConverter.php';\n+require_once $__dir . '/HTMLPurifier/VarParser.php';\n+require_once $__dir . '/HTMLPurifier/VarParserException.php';\n+require_once $__dir . '/HTMLPurifier/Zipper.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/Clone.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/Enum.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/Integer.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/Lang.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/Switch.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/Text.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/URI.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/Number.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/AlphaValue.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/Background.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/BackgroundPosition.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/Border.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/Color.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/Composite.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/DenyElementDecorator.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/Filter.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/Font.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/FontFamily.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/Ident.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/ImportantDecorator.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/Length.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/ListStyle.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/Multiple.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/Percentage.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/TextDecoration.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/CSS/URI.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/HTML/Bool.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/HTML/Nmtokens.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/HTML/Class.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/HTML/Color.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/HTML/FrameTarget.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/HTML/ID.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/HTML/Pixels.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/HTML/Length.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/HTML/LinkTypes.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/HTML/MultiLength.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/URI/Email.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/URI/Host.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/URI/IPv4.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/URI/IPv6.php';\n+require_once $__dir . '/HTMLPurifier/AttrDef/URI/Email/SimpleCheck.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/Background.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/BdoDir.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/BgColor.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/BoolToCSS.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/Border.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/EnumToCSS.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/ImgRequired.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/ImgSpace.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/Input.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/Lang.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/Length.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/Name.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/NameSync.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/Nofollow.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/SafeEmbed.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/SafeObject.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/SafeParam.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/ScriptRequired.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/TargetBlank.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/TargetNoreferrer.php';\n+require_once $__dir . '/HTMLPurifier/AttrTransform/Textarea.php';\n+require_once $__dir . '/HTMLPurifier/ChildDef/Chameleon.php';\n+require_once $__dir . '/HTMLPurifier/ChildDef/Custom.php';\n+require_once $__dir . '/HTMLPurifier/ChildDef/Empty.php';\n+require_once $__dir . '/HTMLPurifier/ChildDef/List.php';\n+require_once $__dir . '/HTMLPurifier/ChildDef/Required.php';\n+require_once $__dir . '/HTMLPurifier/ChildDef/Optional.php';\n+require_once $__dir . '/HTMLPurifier/ChildDef/StrictBlockquote.php';\n+require_once $__dir . '/HTMLPurifier/ChildDef/Table.php';\n+require_once $__dir . '/HTMLPurifier/DefinitionCache/Decorator.php';\n+require_once $__dir . '/HTMLPurifier/DefinitionCache/Null.php';\n+require_once $__dir . '/HTMLPurifier/DefinitionCache/Serializer.php';\n+require_once $__dir . '/HTMLPurifier/DefinitionCache/Decorator/Cleanup.php';\n+require_once $__dir . '/HTMLPurifier/DefinitionCache/Decorator/Memory.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Bdo.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/CommonAttributes.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Edit.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Forms.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Hypertext.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Iframe.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Image.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Legacy.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/List.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Name.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Nofollow.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/NonXMLCommonAttributes.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Object.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Presentation.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Proprietary.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Ruby.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/SafeEmbed.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/SafeObject.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/SafeScripting.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Scripting.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/StyleAttribute.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Tables.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Target.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/TargetBlank.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/TargetNoreferrer.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Text.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Tidy.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/XMLCommonAttributes.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Tidy/Name.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Tidy/Proprietary.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Tidy/XHTMLAndHTML4.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Tidy/Strict.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Tidy/Transitional.php';\n+require_once $__dir . '/HTMLPurifier/HTMLModule/Tidy/XHTML.php';\n+require_once $__dir . '/HTMLPurifier/Injector/AutoParagraph.php';\n+require_once $__dir . '/HTMLPurifier/Injector/DisplayLinkURI.php';\n+require_once $__dir . '/HTMLPurifier/Injector/Linkify.php';\n+require_once $__dir . '/HTMLPurifier/Injector/PurifierLinkify.php';\n+require_once $__dir . '/HTMLPurifier/Injector/RemoveEmpty.php';\n+require_once $__dir . '/HTMLPurifier/Injector/RemoveSpansWithoutAttributes.php';\n+require_once $__dir . '/HTMLPurifier/Injector/SafeObject.php';\n+require_once $__dir . '/HTMLPurifier/Lexer/DOMLex.php';\n+require_once $__dir . '/HTMLPurifier/Lexer/DirectLex.php';\n+require_once $__dir . '/HTMLPurifier/Node/Comment.php';\n+require_once $__dir . '/HTMLPurifier/Node/Element.php';\n+require_once $__dir . '/HTMLPurifier/Node/Text.php';\n+require_once $__dir . '/HTMLPurifier/Strategy/Composite.php';\n+require_once $__dir . '/HTMLPurifier/Strategy/Core.php';\n+require_once $__dir . '/HTMLPurifier/Strategy/FixNesting.php';\n+require_once $__dir . '/HTMLPurifier/Strategy/MakeWellFormed.php';\n+require_once $__dir . '/HTMLPurifier/Strategy/RemoveForeignElements.php';\n+require_once $__dir . '/HTMLPurifier/Strategy/ValidateAttributes.php';\n+require_once $__dir . '/HTMLPurifier/TagTransform/Font.php';\n+require_once $__dir . '/HTMLPurifier/TagTransform/Simple.php';\n+require_once $__dir . '/HTMLPurifier/Token/Comment.php';\n+require_once $__dir . '/HTMLPurifier/Token/Tag.php';\n+require_once $__dir . '/HTMLPurifier/Token/Empty.php';\n+require_once $__dir . '/HTMLPurifier/Token/End.php';\n+require_once $__dir . '/HTMLPurifier/Token/Start.php';\n+require_once $__dir . '/HTMLPurifier/Token/Text.php';\n+require_once $__dir . '/HTMLPurifier/URIFilter/DisableExternal.php';\n+require_once $__dir . '/HTMLPurifier/URIFilter/DisableExternalResources.php';\n+require_once $__dir . '/HTMLPurifier/URIFilter/DisableResources.php';\n+require_once $__dir . '/HTMLPurifier/URIFilter/HostBlacklist.php';\n+require_once $__dir . '/HTMLPurifier/URIFilter/MakeAbsolute.php';\n+require_once $__dir . '/HTMLPurifier/URIFilter/Munge.php';\n+require_once $__dir . '/HTMLPurifier/URIFilter/SafeIframe.php';\n+require_once $__dir . '/HTMLPurifier/URIScheme/data.php';\n+require_once $__dir . '/HTMLPurifier/URIScheme/file.php';\n+require_once $__dir . '/HTMLPurifier/URIScheme/ftp.php';\n+require_once $__dir . '/HTMLPurifier/URIScheme/http.php';\n+require_once $__dir . '/HTMLPurifier/URIScheme/https.php';\n+require_once $__dir . '/HTMLPurifier/URIScheme/mailto.php';\n+require_once $__dir . '/HTMLPurifier/URIScheme/news.php';\n+require_once $__dir . '/HTMLPurifier/URIScheme/nntp.php';\n+require_once $__dir . '/HTMLPurifier/URIScheme/tel.php';\n+require_once $__dir . '/HTMLPurifier/VarParser/Flexible.php';\n+require_once $__dir . '/HTMLPurifier/VarParser/Native.php';"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Arborize.php",
          "status": "added",
          "additions": 71,
          "deletions": 0,
          "patch": "@@ -0,0 +1,71 @@\n+<?php\n+\n+/**\n+ * Converts a stream of HTMLPurifier_Token into an HTMLPurifier_Node,\n+ * and back again.\n+ *\n+ * @note This transformation is not an equivalence.  We mutate the input\n+ * token stream to make it so; see all [MUT] markers in code.\n+ */\n+class HTMLPurifier_Arborize\n+{\n+    public static function arborize($tokens, $config, $context) {\n+        $definition = $config->getHTMLDefinition();\n+        $parent = new HTMLPurifier_Token_Start($definition->info_parent);\n+        $stack = array($parent->toNode());\n+        foreach ($tokens as $token) {\n+            $token->skip = null; // [MUT]\n+            $token->carryover = null; // [MUT]\n+            if ($token instanceof HTMLPurifier_Token_End) {\n+                $token->start = null; // [MUT]\n+                $r = array_pop($stack);\n+                assert($r->name === $token->name);\n+                assert(empty($token->attr));\n+                $r->endCol = $token->col;\n+                $r->endLine = $token->line;\n+                $r->endArmor = $token->armor;\n+                continue;\n+            }\n+            $node = $token->toNode();\n+            $stack[count($stack)-1]->children[] = $node;\n+            if ($token instanceof HTMLPurifier_Token_Start) {\n+                $stack[] = $node;\n+            }\n+        }\n+        assert(count($stack) == 1);\n+        return $stack[0];\n+    }\n+\n+    public static function flatten($node, $config, $context) {\n+        $level = 0;\n+        $nodes = array($level => new HTMLPurifier_Queue(array($node)));\n+        $closingTokens = array();\n+        $tokens = array();\n+        do {\n+            while (!$nodes[$level]->isEmpty()) {\n+                $node = $nodes[$level]->shift(); // FIFO\n+                list($start, $end) = $node->toTokenPair();\n+                if ($level > 0) {\n+                    $tokens[] = $start;\n+                }\n+                if ($end !== NULL) {\n+                    $closingTokens[$level][] = $end;\n+                }\n+                if ($node instanceof HTMLPurifier_Node_Element) {\n+                    $level++;\n+                    $nodes[$level] = new HTMLPurifier_Queue();\n+                    foreach ($node->children as $childNode) {\n+                        $nodes[$level]->push($childNode);\n+                    }\n+                }\n+            }\n+            $level--;\n+            if ($level && isset($closingTokens[$level])) {\n+                while ($token = array_pop($closingTokens[$level])) {\n+                    $tokens[] = $token;\n+                }\n+            }\n+        } while ($level > 0);\n+        return $tokens;\n+    }\n+}"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrCollections.php",
          "status": "added",
          "additions": 148,
          "deletions": 0,
          "patch": "@@ -0,0 +1,148 @@\n+<?php\n+\n+/**\n+ * Defines common attribute collections that modules reference\n+ */\n+\n+class HTMLPurifier_AttrCollections\n+{\n+\n+    /**\n+     * Associative array of attribute collections, indexed by name.\n+     * @type array\n+     */\n+    public $info = array();\n+\n+    /**\n+     * Performs all expansions on internal data for use by other inclusions\n+     * It also collects all attribute collection extensions from\n+     * modules\n+     * @param HTMLPurifier_AttrTypes $attr_types HTMLPurifier_AttrTypes instance\n+     * @param HTMLPurifier_HTMLModule[] $modules Hash array of HTMLPurifier_HTMLModule members\n+     */\n+    public function __construct($attr_types, $modules)\n+    {\n+        $this->doConstruct($attr_types, $modules);\n+    }\n+\n+    public function doConstruct($attr_types, $modules)\n+    {\n+        // load extensions from the modules\n+        foreach ($modules as $module) {\n+            foreach ($module->attr_collections as $coll_i => $coll) {\n+                if (!isset($this->info[$coll_i])) {\n+                    $this->info[$coll_i] = array();\n+                }\n+                foreach ($coll as $attr_i => $attr) {\n+                    if ($attr_i === 0 && isset($this->info[$coll_i][$attr_i])) {\n+                        // merge in includes\n+                        $this->info[$coll_i][$attr_i] = array_merge(\n+                            $this->info[$coll_i][$attr_i],\n+                            $attr\n+                        );\n+                        continue;\n+                    }\n+                    $this->info[$coll_i][$attr_i] = $attr;\n+                }\n+            }\n+        }\n+        // perform internal expansions and inclusions\n+        foreach ($this->info as $name => $attr) {\n+            // merge attribute collections that include others\n+            $this->performInclusions($this->info[$name]);\n+            // replace string identifiers with actual attribute objects\n+            $this->expandIdentifiers($this->info[$name], $attr_types);\n+        }\n+    }\n+\n+    /**\n+     * Takes a reference to an attribute associative array and performs\n+     * all inclusions specified by the zero index.\n+     * @param array &$attr Reference to attribute array\n+     */\n+    public function performInclusions(&$attr)\n+    {\n+        if (!isset($attr[0])) {\n+            return;\n+        }\n+        $merge = $attr[0];\n+        $seen  = array(); // recursion guard\n+        // loop through all the inclusions\n+        for ($i = 0; isset($merge[$i]); $i++) {\n+            if (isset($seen[$merge[$i]])) {\n+                continue;\n+            }\n+            $seen[$merge[$i]] = true;\n+            // foreach attribute of the inclusion, copy it over\n+            if (!isset($this->info[$merge[$i]])) {\n+                continue;\n+            }\n+            foreach ($this->info[$merge[$i]] as $key => $value) {\n+                if (isset($attr[$key])) {\n+                    continue;\n+                } // also catches more inclusions\n+                $attr[$key] = $value;\n+            }\n+            if (isset($this->info[$merge[$i]][0])) {\n+                // recursion\n+                $merge = array_merge($merge, $this->info[$merge[$i]][0]);\n+            }\n+        }\n+        unset($attr[0]);\n+    }\n+\n+    /**\n+     * Expands all string identifiers in an attribute array by replacing\n+     * them with the appropriate values inside HTMLPurifier_AttrTypes\n+     * @param array &$attr Reference to attribute array\n+     * @param HTMLPurifier_AttrTypes $attr_types HTMLPurifier_AttrTypes instance\n+     */\n+    public function expandIdentifiers(&$attr, $attr_types)\n+    {\n+        // because foreach will process new elements we add, make sure we\n+        // skip duplicates\n+        $processed = array();\n+\n+        foreach ($attr as $def_i => $def) {\n+            // skip inclusions\n+            if ($def_i === 0) {\n+                continue;\n+            }\n+\n+            if (isset($processed[$def_i])) {\n+                continue;\n+            }\n+\n+            // determine whether or not attribute is required\n+            if ($required = (strpos($def_i, '*') !== false)) {\n+                // rename the definition\n+                unset($attr[$def_i]);\n+                $def_i = trim($def_i, '*');\n+                $attr[$def_i] = $def;\n+            }\n+\n+            $processed[$def_i] = true;\n+\n+            // if we've already got a literal object, move on\n+            if (is_object($def)) {\n+                // preserve previous required\n+                $attr[$def_i]->required = ($required || $attr[$def_i]->required);\n+                continue;\n+            }\n+\n+            if ($def === false) {\n+                unset($attr[$def_i]);\n+                continue;\n+            }\n+\n+            if ($t = $attr_types->get($def)) {\n+                $attr[$def_i] = $t;\n+                $attr[$def_i]->required = $required;\n+            } else {\n+                unset($attr[$def_i]);\n+            }\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef.php",
          "status": "added",
          "additions": 138,
          "deletions": 0,
          "patch": "@@ -0,0 +1,138 @@\n+<?php\n+\n+/**\n+ * Base class for all validating attribute definitions.\n+ *\n+ * This family of classes forms the core for not only HTML attribute validation,\n+ * but also any sort of string that needs to be validated or cleaned (which\n+ * means CSS properties and composite definitions are defined here too).\n+ * Besides defining (through code) what precisely makes the string valid,\n+ * subclasses are also responsible for cleaning the code if possible.\n+ */\n+\n+abstract class HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * Tells us whether or not an HTML attribute is minimized.\n+     * Has no meaning in other contexts.\n+     * @type bool\n+     */\n+    public $minimized = false;\n+\n+    /**\n+     * Tells us whether or not an HTML attribute is required.\n+     * Has no meaning in other contexts\n+     * @type bool\n+     */\n+    public $required = false;\n+\n+    /**\n+     * Validates and cleans passed string according to a definition.\n+     *\n+     * @param string $string String to be validated and cleaned.\n+     * @param HTMLPurifier_Config $config Mandatory HTMLPurifier_Config object.\n+     * @param HTMLPurifier_Context $context Mandatory HTMLPurifier_Context object.\n+     */\n+    abstract public function validate($string, $config, $context);\n+\n+    /**\n+     * Convenience method that parses a string as if it were CDATA.\n+     *\n+     * This method process a string in the manner specified at\n+     * <http://www.w3.org/TR/html4/types.html#h-6.2> by removing\n+     * leading and trailing whitespace, ignoring line feeds, and replacing\n+     * carriage returns and tabs with spaces.  While most useful for HTML\n+     * attributes specified as CDATA, it can also be applied to most CSS\n+     * values.\n+     *\n+     * @note This method is not entirely standards compliant, as trim() removes\n+     *       more types of whitespace than specified in the spec. In practice,\n+     *       this is rarely a problem, as those extra characters usually have\n+     *       already been removed by HTMLPurifier_Encoder.\n+     *\n+     * @warning This processing is inconsistent with XML's whitespace handling\n+     *          as specified by section 3.3.3 and referenced XHTML 1.0 section\n+     *          4.7.  However, note that we are NOT necessarily\n+     *          parsing XML, thus, this behavior may still be correct. We\n+     *          assume that newlines have been normalized.\n+     */\n+    public function parseCDATA($string)\n+    {\n+        $string = trim($string);\n+        $string = str_replace(array(\"\\n\", \"\\t\", \"\\r\"), ' ', $string);\n+        return $string;\n+    }\n+\n+    /**\n+     * Factory method for creating this class from a string.\n+     * @param string $string String construction info\n+     * @return HTMLPurifier_AttrDef Created AttrDef object corresponding to $string\n+     */\n+    public function make($string)\n+    {\n+        // default implementation, return a flyweight of this object.\n+        // If $string has an effect on the returned object (i.e. you\n+        // need to overload this method), it is best\n+        // to clone or instantiate new copies. (Instantiation is safer.)\n+        return $this;\n+    }\n+\n+    /**\n+     * Removes spaces from rgb(0, 0, 0) so that shorthand CSS properties work\n+     * properly. THIS IS A HACK!\n+     * @param string $string a CSS colour definition\n+     * @return string\n+     */\n+    protected function mungeRgb($string)\n+    {\n+        return preg_replace('/rgb\\((\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\)/', 'rgb(\\1,\\2,\\3)', $string);\n+    }\n+\n+    /**\n+     * Parses a possibly escaped CSS string and returns the \"pure\"\n+     * version of it.\n+     */\n+    protected function expandCSSEscape($string)\n+    {\n+        // flexibly parse it\n+        $ret = '';\n+        for ($i = 0, $c = strlen($string); $i < $c; $i++) {\n+            if ($string[$i] === '\\\\') {\n+                $i++;\n+                if ($i >= $c) {\n+                    $ret .= '\\\\';\n+                    break;\n+                }\n+                if (ctype_xdigit($string[$i])) {\n+                    $code = $string[$i];\n+                    for ($a = 1, $i++; $i < $c && $a < 6; $i++, $a++) {\n+                        if (!ctype_xdigit($string[$i])) {\n+                            break;\n+                        }\n+                        $code .= $string[$i];\n+                    }\n+                    // We have to be extremely careful when adding\n+                    // new characters, to make sure we're not breaking\n+                    // the encoding.\n+                    $char = HTMLPurifier_Encoder::unichr(hexdec($code));\n+                    if (HTMLPurifier_Encoder::cleanUTF8($char) === '') {\n+                        continue;\n+                    }\n+                    $ret .= $char;\n+                    if ($i < $c && trim($string[$i]) !== '') {\n+                        $i--;\n+                    }\n+                    continue;\n+                }\n+                if ($string[$i] === \"\\n\") {\n+                    continue;\n+                }\n+            }\n+            $ret .= $string[$i];\n+        }\n+        return $ret;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS.php",
          "status": "added",
          "additions": 111,
          "deletions": 0,
          "patch": "@@ -0,0 +1,111 @@\n+<?php\n+\n+/**\n+ * Validates the HTML attribute style, otherwise known as CSS.\n+ * @note We don't implement the whole CSS specification, so it might be\n+ *       difficult to reuse this component in the context of validating\n+ *       actual stylesheet declarations.\n+ * @note If we were really serious about validating the CSS, we would\n+ *       tokenize the styles and then parse the tokens. Obviously, we\n+ *       are not doing that. Doing that could seriously harm performance,\n+ *       but would make these components a lot more viable for a CSS\n+ *       filtering solution.\n+ */\n+class HTMLPurifier_AttrDef_CSS extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * @param string $css\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($css, $config, $context)\n+    {\n+        $css = $this->parseCDATA($css);\n+\n+        $definition = $config->getCSSDefinition();\n+        $allow_duplicates = $config->get(\"CSS.AllowDuplicates\");\n+\n+        // we're going to break the spec and explode by semicolons.\n+        // This is because semicolon rarely appears in escaped form\n+        // Doing this is generally flaky but fast\n+        // IT MIGHT APPEAR IN URIs, see HTMLPurifier_AttrDef_CSSURI\n+        // for details\n+\n+        $declarations = explode(';', $css);\n+        $propvalues = array();\n+        $new_declarations = '';\n+\n+        /**\n+         * Name of the current CSS property being validated.\n+         */\n+        $property = false;\n+        $context->register('CurrentCSSProperty', $property);\n+\n+        foreach ($declarations as $declaration) {\n+            if (!$declaration) {\n+                continue;\n+            }\n+            if (!strpos($declaration, ':')) {\n+                continue;\n+            }\n+            list($property, $value) = explode(':', $declaration, 2);\n+            $property = trim($property);\n+            $value = trim($value);\n+            $ok = false;\n+            do {\n+                if (isset($definition->info[$property])) {\n+                    $ok = true;\n+                    break;\n+                }\n+                if (ctype_lower($property)) {\n+                    break;\n+                }\n+                $property = strtolower($property);\n+                if (isset($definition->info[$property])) {\n+                    $ok = true;\n+                    break;\n+                }\n+            } while (0);\n+            if (!$ok) {\n+                continue;\n+            }\n+            // inefficient call, since the validator will do this again\n+            if (strtolower(trim($value)) !== 'inherit') {\n+                // inherit works for everything (but only on the base property)\n+                $result = $definition->info[$property]->validate(\n+                    $value,\n+                    $config,\n+                    $context\n+                );\n+            } else {\n+                $result = 'inherit';\n+            }\n+            if ($result === false) {\n+                continue;\n+            }\n+            if ($allow_duplicates) {\n+                $new_declarations .= \"$property:$result;\";\n+            } else {\n+                $propvalues[$property] = $result;\n+            }\n+        }\n+\n+        $context->destroy('CurrentCSSProperty');\n+\n+        // procedure does not write the new CSS simultaneously, so it's\n+        // slightly inefficient, but it's the only way of getting rid of\n+        // duplicates. Perhaps config to optimize it, but not now.\n+\n+        foreach ($propvalues as $prop => $value) {\n+            $new_declarations .= \"$prop:$value;\";\n+        }\n+\n+        return $new_declarations ? $new_declarations : false;\n+\n+    }\n+\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/AlphaValue.php",
          "status": "added",
          "additions": 34,
          "deletions": 0,
          "patch": "@@ -0,0 +1,34 @@\n+<?php\n+\n+class HTMLPurifier_AttrDef_CSS_AlphaValue extends HTMLPurifier_AttrDef_CSS_Number\n+{\n+\n+    public function __construct()\n+    {\n+        parent::__construct(false); // opacity is non-negative, but we will clamp it\n+    }\n+\n+    /**\n+     * @param string $number\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return string\n+     */\n+    public function validate($number, $config, $context)\n+    {\n+        $result = parent::validate($number, $config, $context);\n+        if ($result === false) {\n+            return $result;\n+        }\n+        $float = (float)$result;\n+        if ($float < 0.0) {\n+            $result = '0';\n+        }\n+        if ($float > 1.0) {\n+            $result = '1';\n+        }\n+        return $result;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/Background.php",
          "status": "added",
          "additions": 111,
          "deletions": 0,
          "patch": "@@ -0,0 +1,111 @@\n+<?php\n+\n+/**\n+ * Validates shorthand CSS property background.\n+ * @warning Does not support url tokens that have internal spaces.\n+ */\n+class HTMLPurifier_AttrDef_CSS_Background extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * Local copy of component validators.\n+     * @type HTMLPurifier_AttrDef[]\n+     * @note See HTMLPurifier_AttrDef_Font::$info for a similar impl.\n+     */\n+    protected $info;\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function __construct($config)\n+    {\n+        $def = $config->getCSSDefinition();\n+        $this->info['background-color'] = $def->info['background-color'];\n+        $this->info['background-image'] = $def->info['background-image'];\n+        $this->info['background-repeat'] = $def->info['background-repeat'];\n+        $this->info['background-attachment'] = $def->info['background-attachment'];\n+        $this->info['background-position'] = $def->info['background-position'];\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        // regular pre-processing\n+        $string = $this->parseCDATA($string);\n+        if ($string === '') {\n+            return false;\n+        }\n+\n+        // munge rgb() decl if necessary\n+        $string = $this->mungeRgb($string);\n+\n+        // assumes URI doesn't have spaces in it\n+        $bits = explode(' ', $string); // bits to process\n+\n+        $caught = array();\n+        $caught['color'] = false;\n+        $caught['image'] = false;\n+        $caught['repeat'] = false;\n+        $caught['attachment'] = false;\n+        $caught['position'] = false;\n+\n+        $i = 0; // number of catches\n+\n+        foreach ($bits as $bit) {\n+            if ($bit === '') {\n+                continue;\n+            }\n+            foreach ($caught as $key => $status) {\n+                if ($key != 'position') {\n+                    if ($status !== false) {\n+                        continue;\n+                    }\n+                    $r = $this->info['background-' . $key]->validate($bit, $config, $context);\n+                } else {\n+                    $r = $bit;\n+                }\n+                if ($r === false) {\n+                    continue;\n+                }\n+                if ($key == 'position') {\n+                    if ($caught[$key] === false) {\n+                        $caught[$key] = '';\n+                    }\n+                    $caught[$key] .= $r . ' ';\n+                } else {\n+                    $caught[$key] = $r;\n+                }\n+                $i++;\n+                break;\n+            }\n+        }\n+\n+        if (!$i) {\n+            return false;\n+        }\n+        if ($caught['position'] !== false) {\n+            $caught['position'] = $this->info['background-position']->\n+                validate($caught['position'], $config, $context);\n+        }\n+\n+        $ret = array();\n+        foreach ($caught as $value) {\n+            if ($value === false) {\n+                continue;\n+            }\n+            $ret[] = $value;\n+        }\n+\n+        if (empty($ret)) {\n+            return false;\n+        }\n+        return implode(' ', $ret);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/BackgroundPosition.php",
          "status": "added",
          "additions": 157,
          "deletions": 0,
          "patch": "@@ -0,0 +1,157 @@\n+<?php\n+\n+/* W3C says:\n+    [ // adjective and number must be in correct order, even if\n+      // you could switch them without introducing ambiguity.\n+      // some browsers support that syntax\n+        [\n+            <percentage> | <length> | left | center | right\n+        ]\n+        [\n+            <percentage> | <length> | top | center | bottom\n+        ]?\n+    ] |\n+    [ // this signifies that the vertical and horizontal adjectives\n+      // can be arbitrarily ordered, however, there can only be two,\n+      // one of each, or none at all\n+        [\n+            left | center | right\n+        ] ||\n+        [\n+            top | center | bottom\n+        ]\n+    ]\n+    top, left = 0%\n+    center, (none) = 50%\n+    bottom, right = 100%\n+*/\n+\n+/* QuirksMode says:\n+    keyword + length/percentage must be ordered correctly, as per W3C\n+\n+    Internet Explorer and Opera, however, support arbitrary ordering. We\n+    should fix it up.\n+\n+    Minor issue though, not strictly necessary.\n+*/\n+\n+// control freaks may appreciate the ability to convert these to\n+// percentages or something, but it's not necessary\n+\n+/**\n+ * Validates the value of background-position.\n+ */\n+class HTMLPurifier_AttrDef_CSS_BackgroundPosition extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * @type HTMLPurifier_AttrDef_CSS_Length\n+     */\n+    protected $length;\n+\n+    /**\n+     * @type HTMLPurifier_AttrDef_CSS_Percentage\n+     */\n+    protected $percentage;\n+\n+    public function __construct()\n+    {\n+        $this->length = new HTMLPurifier_AttrDef_CSS_Length();\n+        $this->percentage = new HTMLPurifier_AttrDef_CSS_Percentage();\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        $string = $this->parseCDATA($string);\n+        $bits = explode(' ', $string);\n+\n+        $keywords = array();\n+        $keywords['h'] = false; // left, right\n+        $keywords['v'] = false; // top, bottom\n+        $keywords['ch'] = false; // center (first word)\n+        $keywords['cv'] = false; // center (second word)\n+        $measures = array();\n+\n+        $i = 0;\n+\n+        $lookup = array(\n+            'top' => 'v',\n+            'bottom' => 'v',\n+            'left' => 'h',\n+            'right' => 'h',\n+            'center' => 'c'\n+        );\n+\n+        foreach ($bits as $bit) {\n+            if ($bit === '') {\n+                continue;\n+            }\n+\n+            // test for keyword\n+            $lbit = ctype_lower($bit) ? $bit : strtolower($bit);\n+            if (isset($lookup[$lbit])) {\n+                $status = $lookup[$lbit];\n+                if ($status == 'c') {\n+                    if ($i == 0) {\n+                        $status = 'ch';\n+                    } else {\n+                        $status = 'cv';\n+                    }\n+                }\n+                $keywords[$status] = $lbit;\n+                $i++;\n+            }\n+\n+            // test for length\n+            $r = $this->length->validate($bit, $config, $context);\n+            if ($r !== false) {\n+                $measures[] = $r;\n+                $i++;\n+            }\n+\n+            // test for percentage\n+            $r = $this->percentage->validate($bit, $config, $context);\n+            if ($r !== false) {\n+                $measures[] = $r;\n+                $i++;\n+            }\n+        }\n+\n+        if (!$i) {\n+            return false;\n+        } // no valid values were caught\n+\n+        $ret = array();\n+\n+        // first keyword\n+        if ($keywords['h']) {\n+            $ret[] = $keywords['h'];\n+        } elseif ($keywords['ch']) {\n+            $ret[] = $keywords['ch'];\n+            $keywords['cv'] = false; // prevent re-use: center = center center\n+        } elseif (count($measures)) {\n+            $ret[] = array_shift($measures);\n+        }\n+\n+        if ($keywords['v']) {\n+            $ret[] = $keywords['v'];\n+        } elseif ($keywords['cv']) {\n+            $ret[] = $keywords['cv'];\n+        } elseif (count($measures)) {\n+            $ret[] = array_shift($measures);\n+        }\n+\n+        if (empty($ret)) {\n+            return false;\n+        }\n+        return implode(' ', $ret);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/Border.php",
          "status": "added",
          "additions": 56,
          "deletions": 0,
          "patch": "@@ -0,0 +1,56 @@\n+<?php\n+\n+/**\n+ * Validates the border property as defined by CSS.\n+ */\n+class HTMLPurifier_AttrDef_CSS_Border extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * Local copy of properties this property is shorthand for.\n+     * @type HTMLPurifier_AttrDef[]\n+     */\n+    protected $info = array();\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function __construct($config)\n+    {\n+        $def = $config->getCSSDefinition();\n+        $this->info['border-width'] = $def->info['border-width'];\n+        $this->info['border-style'] = $def->info['border-style'];\n+        $this->info['border-top-color'] = $def->info['border-top-color'];\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        $string = $this->parseCDATA($string);\n+        $string = $this->mungeRgb($string);\n+        $bits = explode(' ', $string);\n+        $done = array(); // segments we've finished\n+        $ret = ''; // return value\n+        foreach ($bits as $bit) {\n+            foreach ($this->info as $propname => $validator) {\n+                if (isset($done[$propname])) {\n+                    continue;\n+                }\n+                $r = $validator->validate($bit, $config, $context);\n+                if ($r !== false) {\n+                    $ret .= $r . ' ';\n+                    $done[$propname] = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return rtrim($ret);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/Color.php",
          "status": "added",
          "additions": 105,
          "deletions": 0,
          "patch": "@@ -0,0 +1,105 @@\n+<?php\n+\n+/**\n+ * Validates Color as defined by CSS.\n+ */\n+class HTMLPurifier_AttrDef_CSS_Color extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * @param string $color\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($color, $config, $context)\n+    {\n+        static $colors = null;\n+        if ($colors === null) {\n+            $colors = $config->get('Core.ColorKeywords');\n+        }\n+\n+        $color = trim($color);\n+        if ($color === '') {\n+            return false;\n+        }\n+\n+        $lower = strtolower($color);\n+        if (isset($colors[$lower])) {\n+            return $colors[$lower];\n+        }\n+\n+        if (strpos($color, 'rgb(') !== false) {\n+            // rgb literal handling\n+            $length = strlen($color);\n+            if (strpos($color, ')') !== $length - 1) {\n+                return false;\n+            }\n+            $triad = substr($color, 4, $length - 4 - 1);\n+            $parts = explode(',', $triad);\n+            if (count($parts) !== 3) {\n+                return false;\n+            }\n+            $type = false; // to ensure that they're all the same type\n+            $new_parts = array();\n+            foreach ($parts as $part) {\n+                $part = trim($part);\n+                if ($part === '') {\n+                    return false;\n+                }\n+                $length = strlen($part);\n+                if ($part[$length - 1] === '%') {\n+                    // handle percents\n+                    if (!$type) {\n+                        $type = 'percentage';\n+                    } elseif ($type !== 'percentage') {\n+                        return false;\n+                    }\n+                    $num = (float)substr($part, 0, $length - 1);\n+                    if ($num < 0) {\n+                        $num = 0;\n+                    }\n+                    if ($num > 100) {\n+                        $num = 100;\n+                    }\n+                    $new_parts[] = \"$num%\";\n+                } else {\n+                    // handle integers\n+                    if (!$type) {\n+                        $type = 'integer';\n+                    } elseif ($type !== 'integer') {\n+                        return false;\n+                    }\n+                    $num = (int)$part;\n+                    if ($num < 0) {\n+                        $num = 0;\n+                    }\n+                    if ($num > 255) {\n+                        $num = 255;\n+                    }\n+                    $new_parts[] = (string)$num;\n+                }\n+            }\n+            $new_triad = implode(',', $new_parts);\n+            $color = \"rgb($new_triad)\";\n+        } else {\n+            // hexadecimal handling\n+            if ($color[0] === '#') {\n+                $hex = substr($color, 1);\n+            } else {\n+                $hex = $color;\n+                $color = '#' . $color;\n+            }\n+            $length = strlen($hex);\n+            if ($length !== 3 && $length !== 6) {\n+                return false;\n+            }\n+            if (!ctype_xdigit($hex)) {\n+                return false;\n+            }\n+        }\n+        return $color;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/Composite.php",
          "status": "added",
          "additions": 48,
          "deletions": 0,
          "patch": "@@ -0,0 +1,48 @@\n+<?php\n+\n+/**\n+ * Allows multiple validators to attempt to validate attribute.\n+ *\n+ * Composite is just what it sounds like: a composite of many validators.\n+ * This means that multiple HTMLPurifier_AttrDef objects will have a whack\n+ * at the string.  If one of them passes, that's what is returned.  This is\n+ * especially useful for CSS values, which often are a choice between\n+ * an enumerated set of predefined values or a flexible data type.\n+ */\n+class HTMLPurifier_AttrDef_CSS_Composite extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * List of objects that may process strings.\n+     * @type HTMLPurifier_AttrDef[]\n+     * @todo Make protected\n+     */\n+    public $defs;\n+\n+    /**\n+     * @param HTMLPurifier_AttrDef[] $defs List of HTMLPurifier_AttrDef objects\n+     */\n+    public function __construct($defs)\n+    {\n+        $this->defs = $defs;\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        foreach ($this->defs as $i => $def) {\n+            $result = $this->defs[$i]->validate($string, $config, $context);\n+            if ($result !== false) {\n+                return $result;\n+            }\n+        }\n+        return false;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/DenyElementDecorator.php",
          "status": "added",
          "additions": 44,
          "deletions": 0,
          "patch": "@@ -0,0 +1,44 @@\n+<?php\n+\n+/**\n+ * Decorator which enables CSS properties to be disabled for specific elements.\n+ */\n+class HTMLPurifier_AttrDef_CSS_DenyElementDecorator extends HTMLPurifier_AttrDef\n+{\n+    /**\n+     * @type HTMLPurifier_AttrDef\n+     */\n+    public $def;\n+    /**\n+     * @type string\n+     */\n+    public $element;\n+\n+    /**\n+     * @param HTMLPurifier_AttrDef $def Definition to wrap\n+     * @param string $element Element to deny\n+     */\n+    public function __construct($def, $element)\n+    {\n+        $this->def = $def;\n+        $this->element = $element;\n+    }\n+\n+    /**\n+     * Checks if CurrentToken is set and equal to $this->element\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        $token = $context->get('CurrentToken', true);\n+        if ($token && $token->name == $this->element) {\n+            return false;\n+        }\n+        return $this->def->validate($string, $config, $context);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/Filter.php",
          "status": "added",
          "additions": 77,
          "deletions": 0,
          "patch": "@@ -0,0 +1,77 @@\n+<?php\n+\n+/**\n+ * Microsoft's proprietary filter: CSS property\n+ * @note Currently supports the alpha filter. In the future, this will\n+ *       probably need an extensible framework\n+ */\n+class HTMLPurifier_AttrDef_CSS_Filter extends HTMLPurifier_AttrDef\n+{\n+    /**\n+     * @type HTMLPurifier_AttrDef_Integer\n+     */\n+    protected $intValidator;\n+\n+    public function __construct()\n+    {\n+        $this->intValidator = new HTMLPurifier_AttrDef_Integer();\n+    }\n+\n+    /**\n+     * @param string $value\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($value, $config, $context)\n+    {\n+        $value = $this->parseCDATA($value);\n+        if ($value === 'none') {\n+            return $value;\n+        }\n+        // if we looped this we could support multiple filters\n+        $function_length = strcspn($value, '(');\n+        $function = trim(substr($value, 0, $function_length));\n+        if ($function !== 'alpha' &&\n+            $function !== 'Alpha' &&\n+            $function !== 'progid:DXImageTransform.Microsoft.Alpha'\n+        ) {\n+            return false;\n+        }\n+        $cursor = $function_length + 1;\n+        $parameters_length = strcspn($value, ')', $cursor);\n+        $parameters = substr($value, $cursor, $parameters_length);\n+        $params = explode(',', $parameters);\n+        $ret_params = array();\n+        $lookup = array();\n+        foreach ($params as $param) {\n+            list($key, $value) = explode('=', $param);\n+            $key = trim($key);\n+            $value = trim($value);\n+            if (isset($lookup[$key])) {\n+                continue;\n+            }\n+            if ($key !== 'opacity') {\n+                continue;\n+            }\n+            $value = $this->intValidator->validate($value, $config, $context);\n+            if ($value === false) {\n+                continue;\n+            }\n+            $int = (int)$value;\n+            if ($int > 100) {\n+                $value = '100';\n+            }\n+            if ($int < 0) {\n+                $value = '0';\n+            }\n+            $ret_params[] = \"$key=$value\";\n+            $lookup[$key] = true;\n+        }\n+        $ret_parameters = implode(',', $ret_params);\n+        $ret_function = \"$function($ret_parameters)\";\n+        return $ret_function;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/Font.php",
          "status": "added",
          "additions": 176,
          "deletions": 0,
          "patch": "@@ -0,0 +1,176 @@\n+<?php\n+\n+/**\n+ * Validates shorthand CSS property font.\n+ */\n+class HTMLPurifier_AttrDef_CSS_Font extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * Local copy of validators\n+     * @type HTMLPurifier_AttrDef[]\n+     * @note If we moved specific CSS property definitions to their own\n+     *       classes instead of having them be assembled at run time by\n+     *       CSSDefinition, this wouldn't be necessary.  We'd instantiate\n+     *       our own copies.\n+     */\n+    protected $info = array();\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function __construct($config)\n+    {\n+        $def = $config->getCSSDefinition();\n+        $this->info['font-style'] = $def->info['font-style'];\n+        $this->info['font-variant'] = $def->info['font-variant'];\n+        $this->info['font-weight'] = $def->info['font-weight'];\n+        $this->info['font-size'] = $def->info['font-size'];\n+        $this->info['line-height'] = $def->info['line-height'];\n+        $this->info['font-family'] = $def->info['font-family'];\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        static $system_fonts = array(\n+            'caption' => true,\n+            'icon' => true,\n+            'menu' => true,\n+            'message-box' => true,\n+            'small-caption' => true,\n+            'status-bar' => true\n+        );\n+\n+        // regular pre-processing\n+        $string = $this->parseCDATA($string);\n+        if ($string === '') {\n+            return false;\n+        }\n+\n+        // check if it's one of the keywords\n+        $lowercase_string = strtolower($string);\n+        if (isset($system_fonts[$lowercase_string])) {\n+            return $lowercase_string;\n+        }\n+\n+        $bits = explode(' ', $string); // bits to process\n+        $stage = 0; // this indicates what we're looking for\n+        $caught = array(); // which stage 0 properties have we caught?\n+        $stage_1 = array('font-style', 'font-variant', 'font-weight');\n+        $final = ''; // output\n+\n+        for ($i = 0, $size = count($bits); $i < $size; $i++) {\n+            if ($bits[$i] === '') {\n+                continue;\n+            }\n+            switch ($stage) {\n+                case 0: // attempting to catch font-style, font-variant or font-weight\n+                    foreach ($stage_1 as $validator_name) {\n+                        if (isset($caught[$validator_name])) {\n+                            continue;\n+                        }\n+                        $r = $this->info[$validator_name]->validate(\n+                            $bits[$i],\n+                            $config,\n+                            $context\n+                        );\n+                        if ($r !== false) {\n+                            $final .= $r . ' ';\n+                            $caught[$validator_name] = true;\n+                            break;\n+                        }\n+                    }\n+                    // all three caught, continue on\n+                    if (count($caught) >= 3) {\n+                        $stage = 1;\n+                    }\n+                    if ($r !== false) {\n+                        break;\n+                    }\n+                case 1: // attempting to catch font-size and perhaps line-height\n+                    $found_slash = false;\n+                    if (strpos($bits[$i], '/') !== false) {\n+                        list($font_size, $line_height) =\n+                            explode('/', $bits[$i]);\n+                        if ($line_height === '') {\n+                            // ooh, there's a space after the slash!\n+                            $line_height = false;\n+                            $found_slash = true;\n+                        }\n+                    } else {\n+                        $font_size = $bits[$i];\n+                        $line_height = false;\n+                    }\n+                    $r = $this->info['font-size']->validate(\n+                        $font_size,\n+                        $config,\n+                        $context\n+                    );\n+                    if ($r !== false) {\n+                        $final .= $r;\n+                        // attempt to catch line-height\n+                        if ($line_height === false) {\n+                            // we need to scroll forward\n+                            for ($j = $i + 1; $j < $size; $j++) {\n+                                if ($bits[$j] === '') {\n+                                    continue;\n+                                }\n+                                if ($bits[$j] === '/') {\n+                                    if ($found_slash) {\n+                                        return false;\n+                                    } else {\n+                                        $found_slash = true;\n+                                        continue;\n+                                    }\n+                                }\n+                                $line_height = $bits[$j];\n+                                break;\n+                            }\n+                        } else {\n+                            // slash already found\n+                            $found_slash = true;\n+                            $j = $i;\n+                        }\n+                        if ($found_slash) {\n+                            $i = $j;\n+                            $r = $this->info['line-height']->validate(\n+                                $line_height,\n+                                $config,\n+                                $context\n+                            );\n+                            if ($r !== false) {\n+                                $final .= '/' . $r;\n+                            }\n+                        }\n+                        $final .= ' ';\n+                        $stage = 2;\n+                        break;\n+                    }\n+                    return false;\n+                case 2: // attempting to catch font-family\n+                    $font_family =\n+                        implode(' ', array_slice($bits, $i, $size - $i));\n+                    $r = $this->info['font-family']->validate(\n+                        $font_family,\n+                        $config,\n+                        $context\n+                    );\n+                    if ($r !== false) {\n+                        $final .= $r . ' ';\n+                        // processing completed successfully\n+                        return rtrim($final);\n+                    }\n+                    return false;\n+            }\n+        }\n+        return false;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/FontFamily.php",
          "status": "added",
          "additions": 219,
          "deletions": 0,
          "patch": "@@ -0,0 +1,219 @@\n+<?php\n+\n+/**\n+ * Validates a font family list according to CSS spec\n+ */\n+class HTMLPurifier_AttrDef_CSS_FontFamily extends HTMLPurifier_AttrDef\n+{\n+\n+    protected $mask = null;\n+\n+    public function __construct()\n+    {\n+        $this->mask = '_- ';\n+        for ($c = 'a'; $c <= 'z'; $c++) {\n+            $this->mask .= $c;\n+        }\n+        for ($c = 'A'; $c <= 'Z'; $c++) {\n+            $this->mask .= $c;\n+        }\n+        for ($c = '0'; $c <= '9'; $c++) {\n+            $this->mask .= $c;\n+        } // cast-y, but should be fine\n+        // special bytes used by UTF-8\n+        for ($i = 0x80; $i <= 0xFF; $i++) {\n+            // We don't bother excluding invalid bytes in this range,\n+            // because the our restriction of well-formed UTF-8 will\n+            // prevent these from ever occurring.\n+            $this->mask .= chr($i);\n+        }\n+\n+        /*\n+            PHP's internal strcspn implementation is\n+            O(length of string * length of mask), making it inefficient\n+            for large masks.  However, it's still faster than\n+            preg_match 8)\n+          for (p = s1;;) {\n+            spanp = s2;\n+            do {\n+              if (*spanp == c || p == s1_end) {\n+                return p - s1;\n+              }\n+            } while (spanp++ < (s2_end - 1));\n+            c = *++p;\n+          }\n+         */\n+        // possible optimization: invert the mask.\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        static $generic_names = array(\n+            'serif' => true,\n+            'sans-serif' => true,\n+            'monospace' => true,\n+            'fantasy' => true,\n+            'cursive' => true\n+        );\n+        $allowed_fonts = $config->get('CSS.AllowedFonts');\n+\n+        // assume that no font names contain commas in them\n+        $fonts = explode(',', $string);\n+        $final = '';\n+        foreach ($fonts as $font) {\n+            $font = trim($font);\n+            if ($font === '') {\n+                continue;\n+            }\n+            // match a generic name\n+            if (isset($generic_names[$font])) {\n+                if ($allowed_fonts === null || isset($allowed_fonts[$font])) {\n+                    $final .= $font . ', ';\n+                }\n+                continue;\n+            }\n+            // match a quoted name\n+            if ($font[0] === '\"' || $font[0] === \"'\") {\n+                $length = strlen($font);\n+                if ($length <= 2) {\n+                    continue;\n+                }\n+                $quote = $font[0];\n+                if ($font[$length - 1] !== $quote) {\n+                    continue;\n+                }\n+                $font = substr($font, 1, $length - 2);\n+            }\n+\n+            $font = $this->expandCSSEscape($font);\n+\n+            // $font is a pure representation of the font name\n+\n+            if ($allowed_fonts !== null && !isset($allowed_fonts[$font])) {\n+                continue;\n+            }\n+\n+            if (ctype_alnum($font) && $font !== '') {\n+                // very simple font, allow it in unharmed\n+                $final .= $font . ', ';\n+                continue;\n+            }\n+\n+            // bugger out on whitespace.  form feed (0C) really\n+            // shouldn't show up regardless\n+            $font = str_replace(array(\"\\n\", \"\\t\", \"\\r\", \"\\x0C\"), ' ', $font);\n+\n+            // Here, there are various classes of characters which need\n+            // to be treated differently:\n+            //  - Alphanumeric characters are essentially safe.  We\n+            //    handled these above.\n+            //  - Spaces require quoting, though most parsers will do\n+            //    the right thing if there aren't any characters that\n+            //    can be misinterpreted\n+            //  - Dashes rarely occur, but they fairly unproblematic\n+            //    for parsing/rendering purposes.\n+            //  The above characters cover the majority of Western font\n+            //  names.\n+            //  - Arbitrary Unicode characters not in ASCII.  Because\n+            //    most parsers give little thought to Unicode, treatment\n+            //    of these codepoints is basically uniform, even for\n+            //    punctuation-like codepoints.  These characters can\n+            //    show up in non-Western pages and are supported by most\n+            //    major browsers, for example: \"\uff2d\uff33 \u660e\u671d\" is a\n+            //    legitimate font-name\n+            //    <http://ja.wikipedia.org/wiki/MS_\u660e\u671d>.  See\n+            //    the CSS3 spec for more examples:\n+            //    <http://www.w3.org/TR/2011/WD-css3-fonts-20110324/localizedfamilynames.png>\n+            //    You can see live samples of these on the Internet:\n+            //    <http://www.google.co.jp/search?q=font-family+\uff2d\uff33+\u660e\u671d|\u30b4\u30b7\u30c3\u30af>\n+            //    However, most of these fonts have ASCII equivalents:\n+            //    for example, 'MS Mincho', and it's considered\n+            //    professional to use ASCII font names instead of\n+            //    Unicode font names.  Thanks Takeshi Terada for\n+            //    providing this information.\n+            //  The following characters, to my knowledge, have not been\n+            //  used to name font names.\n+            //  - Single quote.  While theoretically you might find a\n+            //    font name that has a single quote in its name (serving\n+            //    as an apostrophe, e.g. Dave's Scribble), I haven't\n+            //    been able to find any actual examples of this.\n+            //    Internet Explorer's cssText translation (which I\n+            //    believe is invoked by innerHTML) normalizes any\n+            //    quoting to single quotes, and fails to escape single\n+            //    quotes.  (Note that this is not IE's behavior for all\n+            //    CSS properties, just some sort of special casing for\n+            //    font-family).  So a single quote *cannot* be used\n+            //    safely in the font-family context if there will be an\n+            //    innerHTML/cssText translation.  Note that Firefox 3.x\n+            //    does this too.\n+            //  - Double quote.  In IE, these get normalized to\n+            //    single-quotes, no matter what the encoding.  (Fun\n+            //    fact, in IE8, the 'content' CSS property gained\n+            //    support, where they special cased to preserve encoded\n+            //    double quotes, but still translate unadorned double\n+            //    quotes into single quotes.)  So, because their\n+            //    fixpoint behavior is identical to single quotes, they\n+            //    cannot be allowed either.  Firefox 3.x displays\n+            //    single-quote style behavior.\n+            //  - Backslashes are reduced by one (so \\\\ -> \\) every\n+            //    iteration, so they cannot be used safely.  This shows\n+            //    up in IE7, IE8 and FF3\n+            //  - Semicolons, commas and backticks are handled properly.\n+            //  - The rest of the ASCII punctuation is handled properly.\n+            // We haven't checked what browsers do to unadorned\n+            // versions, but this is not important as long as the\n+            // browser doesn't /remove/ surrounding quotes (as IE does\n+            // for HTML).\n+            //\n+            // With these results in hand, we conclude that there are\n+            // various levels of safety:\n+            //  - Paranoid: alphanumeric, spaces and dashes(?)\n+            //  - International: Paranoid + non-ASCII Unicode\n+            //  - Edgy: Everything except quotes, backslashes\n+            //  - NoJS: Standards compliance, e.g. sod IE. Note that\n+            //    with some judicious character escaping (since certain\n+            //    types of escaping doesn't work) this is theoretically\n+            //    OK as long as innerHTML/cssText is not called.\n+            // We believe that international is a reasonable default\n+            // (that we will implement now), and once we do more\n+            // extensive research, we may feel comfortable with dropping\n+            // it down to edgy.\n+\n+            // Edgy: alphanumeric, spaces, dashes, underscores and Unicode.  Use of\n+            // str(c)spn assumes that the string was already well formed\n+            // Unicode (which of course it is).\n+            if (strspn($font, $this->mask) !== strlen($font)) {\n+                continue;\n+            }\n+\n+            // Historical:\n+            // In the absence of innerHTML/cssText, these ugly\n+            // transforms don't pose a security risk (as \\\\ and \\\"\n+            // might--these escapes are not supported by most browsers).\n+            // We could try to be clever and use single-quote wrapping\n+            // when there is a double quote present, but I have choosen\n+            // not to implement that.  (NOTE: you can reduce the amount\n+            // of escapes by one depending on what quoting style you use)\n+            // $font = str_replace('\\\\', '\\\\5C ', $font);\n+            // $font = str_replace('\"',  '\\\\22 ', $font);\n+            // $font = str_replace(\"'\",  '\\\\27 ', $font);\n+\n+            // font possibly with spaces, requires quoting\n+            $final .= \"'$font', \";\n+        }\n+        $final = rtrim($final, ', ');\n+        if ($final === '') {\n+            return false;\n+        }\n+        return $final;\n+    }\n+\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/Ident.php",
          "status": "added",
          "additions": 32,
          "deletions": 0,
          "patch": "@@ -0,0 +1,32 @@\n+<?php\n+\n+/**\n+ * Validates based on {ident} CSS grammar production\n+ */\n+class HTMLPurifier_AttrDef_CSS_Ident extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        $string = trim($string);\n+\n+        // early abort: '' and '0' (strings that convert to false) are invalid\n+        if (!$string) {\n+            return false;\n+        }\n+\n+        $pattern = '/^(-?[A-Za-z_][A-Za-z_\\-0-9]*)$/';\n+        if (!preg_match($pattern, $string)) {\n+            return false;\n+        }\n+        return $string;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/ImportantDecorator.php",
          "status": "added",
          "additions": 56,
          "deletions": 0,
          "patch": "@@ -0,0 +1,56 @@\n+<?php\n+\n+/**\n+ * Decorator which enables !important to be used in CSS values.\n+ */\n+class HTMLPurifier_AttrDef_CSS_ImportantDecorator extends HTMLPurifier_AttrDef\n+{\n+    /**\n+     * @type HTMLPurifier_AttrDef\n+     */\n+    public $def;\n+    /**\n+     * @type bool\n+     */\n+    public $allow;\n+\n+    /**\n+     * @param HTMLPurifier_AttrDef $def Definition to wrap\n+     * @param bool $allow Whether or not to allow !important\n+     */\n+    public function __construct($def, $allow = false)\n+    {\n+        $this->def = $def;\n+        $this->allow = $allow;\n+    }\n+\n+    /**\n+     * Intercepts and removes !important if necessary\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        // test for ! and important tokens\n+        $string = trim($string);\n+        $is_important = false;\n+        // :TODO: optimization: test directly for !important and ! important\n+        if (strlen($string) >= 9 && substr($string, -9) === 'important') {\n+            $temp = rtrim(substr($string, 0, -9));\n+            // use a temp, because we might want to restore important\n+            if (strlen($temp) >= 1 && substr($temp, -1) === '!') {\n+                $string = rtrim(substr($temp, 0, -1));\n+                $is_important = true;\n+            }\n+        }\n+        $string = $this->def->validate($string, $config, $context);\n+        if ($this->allow && $is_important) {\n+            $string .= ' !important';\n+        }\n+        return $string;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/Length.php",
          "status": "added",
          "additions": 77,
          "deletions": 0,
          "patch": "@@ -0,0 +1,77 @@\n+<?php\n+\n+/**\n+ * Represents a Length as defined by CSS.\n+ */\n+class HTMLPurifier_AttrDef_CSS_Length extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * @type HTMLPurifier_Length|string\n+     */\n+    protected $min;\n+\n+    /**\n+     * @type HTMLPurifier_Length|string\n+     */\n+    protected $max;\n+\n+    /**\n+     * @param HTMLPurifier_Length|string $min Minimum length, or null for no bound. String is also acceptable.\n+     * @param HTMLPurifier_Length|string $max Maximum length, or null for no bound. String is also acceptable.\n+     */\n+    public function __construct($min = null, $max = null)\n+    {\n+        $this->min = $min !== null ? HTMLPurifier_Length::make($min) : null;\n+        $this->max = $max !== null ? HTMLPurifier_Length::make($max) : null;\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        $string = $this->parseCDATA($string);\n+\n+        // Optimizations\n+        if ($string === '') {\n+            return false;\n+        }\n+        if ($string === '0') {\n+            return '0';\n+        }\n+        if (strlen($string) === 1) {\n+            return false;\n+        }\n+\n+        $length = HTMLPurifier_Length::make($string);\n+        if (!$length->isValid()) {\n+            return false;\n+        }\n+\n+        if ($this->min) {\n+            $c = $length->compareTo($this->min);\n+            if ($c === false) {\n+                return false;\n+            }\n+            if ($c < 0) {\n+                return false;\n+            }\n+        }\n+        if ($this->max) {\n+            $c = $length->compareTo($this->max);\n+            if ($c === false) {\n+                return false;\n+            }\n+            if ($c > 0) {\n+                return false;\n+            }\n+        }\n+        return $length->toString();\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/ListStyle.php",
          "status": "added",
          "additions": 112,
          "deletions": 0,
          "patch": "@@ -0,0 +1,112 @@\n+<?php\n+\n+/**\n+ * Validates shorthand CSS property list-style.\n+ * @warning Does not support url tokens that have internal spaces.\n+ */\n+class HTMLPurifier_AttrDef_CSS_ListStyle extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * Local copy of validators.\n+     * @type HTMLPurifier_AttrDef[]\n+     * @note See HTMLPurifier_AttrDef_CSS_Font::$info for a similar impl.\n+     */\n+    protected $info;\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function __construct($config)\n+    {\n+        $def = $config->getCSSDefinition();\n+        $this->info['list-style-type'] = $def->info['list-style-type'];\n+        $this->info['list-style-position'] = $def->info['list-style-position'];\n+        $this->info['list-style-image'] = $def->info['list-style-image'];\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        // regular pre-processing\n+        $string = $this->parseCDATA($string);\n+        if ($string === '') {\n+            return false;\n+        }\n+\n+        // assumes URI doesn't have spaces in it\n+        $bits = explode(' ', strtolower($string)); // bits to process\n+\n+        $caught = array();\n+        $caught['type'] = false;\n+        $caught['position'] = false;\n+        $caught['image'] = false;\n+\n+        $i = 0; // number of catches\n+        $none = false;\n+\n+        foreach ($bits as $bit) {\n+            if ($i >= 3) {\n+                return;\n+            } // optimization bit\n+            if ($bit === '') {\n+                continue;\n+            }\n+            foreach ($caught as $key => $status) {\n+                if ($status !== false) {\n+                    continue;\n+                }\n+                $r = $this->info['list-style-' . $key]->validate($bit, $config, $context);\n+                if ($r === false) {\n+                    continue;\n+                }\n+                if ($r === 'none') {\n+                    if ($none) {\n+                        continue;\n+                    } else {\n+                        $none = true;\n+                    }\n+                    if ($key == 'image') {\n+                        continue;\n+                    }\n+                }\n+                $caught[$key] = $r;\n+                $i++;\n+                break;\n+            }\n+        }\n+\n+        if (!$i) {\n+            return false;\n+        }\n+\n+        $ret = array();\n+\n+        // construct type\n+        if ($caught['type']) {\n+            $ret[] = $caught['type'];\n+        }\n+\n+        // construct image\n+        if ($caught['image']) {\n+            $ret[] = $caught['image'];\n+        }\n+\n+        // construct position\n+        if ($caught['position']) {\n+            $ret[] = $caught['position'];\n+        }\n+\n+        if (empty($ret)) {\n+            return false;\n+        }\n+        return implode(' ', $ret);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/Multiple.php",
          "status": "added",
          "additions": 71,
          "deletions": 0,
          "patch": "@@ -0,0 +1,71 @@\n+<?php\n+\n+/**\n+ * Framework class for strings that involve multiple values.\n+ *\n+ * Certain CSS properties such as border-width and margin allow multiple\n+ * lengths to be specified.  This class can take a vanilla border-width\n+ * definition and multiply it, usually into a max of four.\n+ *\n+ * @note Even though the CSS specification isn't clear about it, inherit\n+ *       can only be used alone: it will never manifest as part of a multi\n+ *       shorthand declaration.  Thus, this class does not allow inherit.\n+ */\n+class HTMLPurifier_AttrDef_CSS_Multiple extends HTMLPurifier_AttrDef\n+{\n+    /**\n+     * Instance of component definition to defer validation to.\n+     * @type HTMLPurifier_AttrDef\n+     * @todo Make protected\n+     */\n+    public $single;\n+\n+    /**\n+     * Max number of values allowed.\n+     * @todo Make protected\n+     */\n+    public $max;\n+\n+    /**\n+     * @param HTMLPurifier_AttrDef $single HTMLPurifier_AttrDef to multiply\n+     * @param int $max Max number of values allowed (usually four)\n+     */\n+    public function __construct($single, $max = 4)\n+    {\n+        $this->single = $single;\n+        $this->max = $max;\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        $string = $this->mungeRgb($this->parseCDATA($string));\n+        if ($string === '') {\n+            return false;\n+        }\n+        $parts = explode(' ', $string); // parseCDATA replaced \\r, \\t and \\n\n+        $length = count($parts);\n+        $final = '';\n+        for ($i = 0, $num = 0; $i < $length && $num < $this->max; $i++) {\n+            if (ctype_space($parts[$i])) {\n+                continue;\n+            }\n+            $result = $this->single->validate($parts[$i], $config, $context);\n+            if ($result !== false) {\n+                $final .= $result . ' ';\n+                $num++;\n+            }\n+        }\n+        if ($final === '') {\n+            return false;\n+        }\n+        return rtrim($final);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/Number.php",
          "status": "added",
          "additions": 84,
          "deletions": 0,
          "patch": "@@ -0,0 +1,84 @@\n+<?php\n+\n+/**\n+ * Validates a number as defined by the CSS spec.\n+ */\n+class HTMLPurifier_AttrDef_CSS_Number extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * Indicates whether or not only positive values are allowed.\n+     * @type bool\n+     */\n+    protected $non_negative = false;\n+\n+    /**\n+     * @param bool $non_negative indicates whether negatives are forbidden\n+     */\n+    public function __construct($non_negative = false)\n+    {\n+        $this->non_negative = $non_negative;\n+    }\n+\n+    /**\n+     * @param string $number\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return string|bool\n+     * @warning Some contexts do not pass $config, $context. These\n+     *          variables should not be used without checking HTMLPurifier_Length\n+     */\n+    public function validate($number, $config, $context)\n+    {\n+        $number = $this->parseCDATA($number);\n+\n+        if ($number === '') {\n+            return false;\n+        }\n+        if ($number === '0') {\n+            return '0';\n+        }\n+\n+        $sign = '';\n+        switch ($number[0]) {\n+            case '-':\n+                if ($this->non_negative) {\n+                    return false;\n+                }\n+                $sign = '-';\n+            case '+':\n+                $number = substr($number, 1);\n+        }\n+\n+        if (ctype_digit($number)) {\n+            $number = ltrim($number, '0');\n+            return $number ? $sign . $number : '0';\n+        }\n+\n+        // Period is the only non-numeric character allowed\n+        if (strpos($number, '.') === false) {\n+            return false;\n+        }\n+\n+        list($left, $right) = explode('.', $number, 2);\n+\n+        if ($left === '' && $right === '') {\n+            return false;\n+        }\n+        if ($left !== '' && !ctype_digit($left)) {\n+            return false;\n+        }\n+\n+        $left = ltrim($left, '0');\n+        $right = rtrim($right, '0');\n+\n+        if ($right === '') {\n+            return $left ? $sign . $left : '0';\n+        } elseif (!ctype_digit($right)) {\n+            return false;\n+        }\n+        return $sign . $left . '.' . $right;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/Percentage.php",
          "status": "added",
          "additions": 54,
          "deletions": 0,
          "patch": "@@ -0,0 +1,54 @@\n+<?php\n+\n+/**\n+ * Validates a Percentage as defined by the CSS spec.\n+ */\n+class HTMLPurifier_AttrDef_CSS_Percentage extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * Instance to defer number validation to.\n+     * @type HTMLPurifier_AttrDef_CSS_Number\n+     */\n+    protected $number_def;\n+\n+    /**\n+     * @param bool $non_negative Whether to forbid negative values\n+     */\n+    public function __construct($non_negative = false)\n+    {\n+        $this->number_def = new HTMLPurifier_AttrDef_CSS_Number($non_negative);\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        $string = $this->parseCDATA($string);\n+\n+        if ($string === '') {\n+            return false;\n+        }\n+        $length = strlen($string);\n+        if ($length === 1) {\n+            return false;\n+        }\n+        if ($string[$length - 1] !== '%') {\n+            return false;\n+        }\n+\n+        $number = substr($string, 0, $length - 1);\n+        $number = $this->number_def->validate($number, $config, $context);\n+\n+        if ($number === false) {\n+            return false;\n+        }\n+        return \"$number%\";\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/TextDecoration.php",
          "status": "added",
          "additions": 46,
          "deletions": 0,
          "patch": "@@ -0,0 +1,46 @@\n+<?php\n+\n+/**\n+ * Validates the value for the CSS property text-decoration\n+ * @note This class could be generalized into a version that acts sort of\n+ *       like Enum except you can compound the allowed values.\n+ */\n+class HTMLPurifier_AttrDef_CSS_TextDecoration extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        static $allowed_values = array(\n+            'line-through' => true,\n+            'overline' => true,\n+            'underline' => true,\n+        );\n+\n+        $string = strtolower($this->parseCDATA($string));\n+\n+        if ($string === 'none') {\n+            return $string;\n+        }\n+\n+        $parts = explode(' ', $string);\n+        $final = '';\n+        foreach ($parts as $part) {\n+            if (isset($allowed_values[$part])) {\n+                $final .= $part . ' ';\n+            }\n+        }\n+        $final = rtrim($final);\n+        if ($final === '') {\n+            return false;\n+        }\n+        return $final;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/CSS/URI.php",
          "status": "added",
          "additions": 77,
          "deletions": 0,
          "patch": "@@ -0,0 +1,77 @@\n+<?php\n+\n+/**\n+ * Validates a URI in CSS syntax, which uses url('http://example.com')\n+ * @note While theoretically speaking a URI in a CSS document could\n+ *       be non-embedded, as of CSS2 there is no such usage so we're\n+ *       generalizing it. This may need to be changed in the future.\n+ * @warning Since HTMLPurifier_AttrDef_CSS blindly uses semicolons as\n+ *          the separator, you cannot put a literal semicolon in\n+ *          in the URI. Try percent encoding it, in that case.\n+ */\n+class HTMLPurifier_AttrDef_CSS_URI extends HTMLPurifier_AttrDef_URI\n+{\n+\n+    public function __construct()\n+    {\n+        parent::__construct(true); // always embedded\n+    }\n+\n+    /**\n+     * @param string $uri_string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($uri_string, $config, $context)\n+    {\n+        // parse the URI out of the string and then pass it onto\n+        // the parent object\n+\n+        $uri_string = $this->parseCDATA($uri_string);\n+        if (strpos($uri_string, 'url(') !== 0) {\n+            return false;\n+        }\n+        $uri_string = substr($uri_string, 4);\n+        if (strlen($uri_string) == 0) {\n+            return false;\n+        }\n+        $new_length = strlen($uri_string) - 1;\n+        if ($uri_string[$new_length] != ')') {\n+            return false;\n+        }\n+        $uri = trim(substr($uri_string, 0, $new_length));\n+\n+        if (!empty($uri) && ($uri[0] == \"'\" || $uri[0] == '\"')) {\n+            $quote = $uri[0];\n+            $new_length = strlen($uri) - 1;\n+            if ($uri[$new_length] !== $quote) {\n+                return false;\n+            }\n+            $uri = substr($uri, 1, $new_length - 1);\n+        }\n+\n+        $uri = $this->expandCSSEscape($uri);\n+\n+        $result = parent::validate($uri, $config, $context);\n+\n+        if ($result === false) {\n+            return false;\n+        }\n+\n+        // extra sanity check; should have been done by URI\n+        $result = str_replace(array('\"', \"\\\\\", \"\\n\", \"\\x0c\", \"\\r\"), \"\", $result);\n+\n+        // suspicious characters are ()'; we're going to percent encode\n+        // them for safety.\n+        $result = str_replace(array('(', ')', \"'\"), array('%28', '%29', '%27'), $result);\n+\n+        // there's an extra bug where ampersands lose their escaping on\n+        // an innerHTML cycle, so a very unlucky query parameter could\n+        // then change the meaning of the URL.  Unfortunately, there's\n+        // not much we can do about that...\n+        return \"url(\\\"$result\\\")\";\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/Clone.php",
          "status": "added",
          "additions": 44,
          "deletions": 0,
          "patch": "@@ -0,0 +1,44 @@\n+<?php\n+\n+/**\n+ * Dummy AttrDef that mimics another AttrDef, BUT it generates clones\n+ * with make.\n+ */\n+class HTMLPurifier_AttrDef_Clone extends HTMLPurifier_AttrDef\n+{\n+    /**\n+     * What we're cloning.\n+     * @type HTMLPurifier_AttrDef\n+     */\n+    protected $clone;\n+\n+    /**\n+     * @param HTMLPurifier_AttrDef $clone\n+     */\n+    public function __construct($clone)\n+    {\n+        $this->clone = $clone;\n+    }\n+\n+    /**\n+     * @param string $v\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($v, $config, $context)\n+    {\n+        return $this->clone->validate($v, $config, $context);\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @return HTMLPurifier_AttrDef\n+     */\n+    public function make($string)\n+    {\n+        return clone $this->clone;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/Enum.php",
          "status": "added",
          "additions": 73,
          "deletions": 0,
          "patch": "@@ -0,0 +1,73 @@\n+<?php\n+\n+// Enum = Enumerated\n+/**\n+ * Validates a keyword against a list of valid values.\n+ * @warning The case-insensitive compare of this function uses PHP's\n+ *          built-in strtolower and ctype_lower functions, which may\n+ *          cause problems with international comparisons\n+ */\n+class HTMLPurifier_AttrDef_Enum extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * Lookup table of valid values.\n+     * @type array\n+     * @todo Make protected\n+     */\n+    public $valid_values = array();\n+\n+    /**\n+     * Bool indicating whether or not enumeration is case sensitive.\n+     * @note In general this is always case insensitive.\n+     */\n+    protected $case_sensitive = false; // values according to W3C spec\n+\n+    /**\n+     * @param array $valid_values List of valid values\n+     * @param bool $case_sensitive Whether or not case sensitive\n+     */\n+    public function __construct($valid_values = array(), $case_sensitive = false)\n+    {\n+        $this->valid_values = array_flip($valid_values);\n+        $this->case_sensitive = $case_sensitive;\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        $string = trim($string);\n+        if (!$this->case_sensitive) {\n+            // we may want to do full case-insensitive libraries\n+            $string = ctype_lower($string) ? $string : strtolower($string);\n+        }\n+        $result = isset($this->valid_values[$string]);\n+\n+        return $result ? $string : false;\n+    }\n+\n+    /**\n+     * @param string $string In form of comma-delimited list of case-insensitive\n+     *      valid values. Example: \"foo,bar,baz\". Prepend \"s:\" to make\n+     *      case sensitive\n+     * @return HTMLPurifier_AttrDef_Enum\n+     */\n+    public function make($string)\n+    {\n+        if (strlen($string) > 2 && $string[0] == 's' && $string[1] == ':') {\n+            $string = substr($string, 2);\n+            $sensitive = true;\n+        } else {\n+            $sensitive = false;\n+        }\n+        $values = explode(',', $string);\n+        return new HTMLPurifier_AttrDef_Enum($values, $sensitive);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/HTML/Bool.php",
          "status": "added",
          "additions": 48,
          "deletions": 0,
          "patch": "@@ -0,0 +1,48 @@\n+<?php\n+\n+/**\n+ * Validates a boolean attribute\n+ */\n+class HTMLPurifier_AttrDef_HTML_Bool extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * @type bool\n+     */\n+    protected $name;\n+\n+    /**\n+     * @type bool\n+     */\n+    public $minimized = true;\n+\n+    /**\n+     * @param bool $name\n+     */\n+    public function __construct($name = false)\n+    {\n+        $this->name = $name;\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        return $this->name;\n+    }\n+\n+    /**\n+     * @param string $string Name of attribute\n+     * @return HTMLPurifier_AttrDef_HTML_Bool\n+     */\n+    public function make($string)\n+    {\n+        return new HTMLPurifier_AttrDef_HTML_Bool($string);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/HTML/Class.php",
          "status": "added",
          "additions": 48,
          "deletions": 0,
          "patch": "@@ -0,0 +1,48 @@\n+<?php\n+\n+/**\n+ * Implements special behavior for class attribute (normally NMTOKENS)\n+ */\n+class HTMLPurifier_AttrDef_HTML_Class extends HTMLPurifier_AttrDef_HTML_Nmtokens\n+{\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    protected function split($string, $config, $context)\n+    {\n+        // really, this twiddle should be lazy loaded\n+        $name = $config->getDefinition('HTML')->doctype->name;\n+        if ($name == \"XHTML 1.1\" || $name == \"XHTML 2.0\") {\n+            return parent::split($string, $config, $context);\n+        } else {\n+            return preg_split('/\\s+/', $string);\n+        }\n+    }\n+\n+    /**\n+     * @param array $tokens\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    protected function filter($tokens, $config, $context)\n+    {\n+        $allowed = $config->get('Attr.AllowedClasses');\n+        $forbidden = $config->get('Attr.ForbiddenClasses');\n+        $ret = array();\n+        foreach ($tokens as $token) {\n+            if (($allowed === null || isset($allowed[$token])) &&\n+                !isset($forbidden[$token]) &&\n+                // We need this O(n) check because of PHP's array\n+                // implementation that casts -0 to 0.\n+                !in_array($token, $ret, true)\n+            ) {\n+                $ret[] = $token;\n+            }\n+        }\n+        return $ret;\n+    }\n+}"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/HTML/Color.php",
          "status": "added",
          "additions": 51,
          "deletions": 0,
          "patch": "@@ -0,0 +1,51 @@\n+<?php\n+\n+/**\n+ * Validates a color according to the HTML spec.\n+ */\n+class HTMLPurifier_AttrDef_HTML_Color extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        static $colors = null;\n+        if ($colors === null) {\n+            $colors = $config->get('Core.ColorKeywords');\n+        }\n+\n+        $string = trim($string);\n+\n+        if (empty($string)) {\n+            return false;\n+        }\n+        $lower = strtolower($string);\n+        if (isset($colors[$lower])) {\n+            return $colors[$lower];\n+        }\n+        if ($string[0] === '#') {\n+            $hex = substr($string, 1);\n+        } else {\n+            $hex = $string;\n+        }\n+\n+        $length = strlen($hex);\n+        if ($length !== 3 && $length !== 6) {\n+            return false;\n+        }\n+        if (!ctype_xdigit($hex)) {\n+            return false;\n+        }\n+        if ($length === 3) {\n+            $hex = $hex[0] . $hex[0] . $hex[1] . $hex[1] . $hex[2] . $hex[2];\n+        }\n+        return \"#$hex\";\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/HTML/FrameTarget.php",
          "status": "added",
          "additions": 38,
          "deletions": 0,
          "patch": "@@ -0,0 +1,38 @@\n+<?php\n+\n+/**\n+ * Special-case enum attribute definition that lazy loads allowed frame targets\n+ */\n+class HTMLPurifier_AttrDef_HTML_FrameTarget extends HTMLPurifier_AttrDef_Enum\n+{\n+\n+    /**\n+     * @type array\n+     */\n+    public $valid_values = false; // uninitialized value\n+\n+    /**\n+     * @type bool\n+     */\n+    protected $case_sensitive = false;\n+\n+    public function __construct()\n+    {\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        if ($this->valid_values === false) {\n+            $this->valid_values = $config->get('Attr.AllowedFrameTargets');\n+        }\n+        return parent::validate($string, $config, $context);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/HTML/ID.php",
          "status": "added",
          "additions": 113,
          "deletions": 0,
          "patch": "@@ -0,0 +1,113 @@\n+<?php\n+\n+/**\n+ * Validates the HTML attribute ID.\n+ * @warning Even though this is the id processor, it\n+ *          will ignore the directive Attr:IDBlacklist, since it will only\n+ *          go according to the ID accumulator. Since the accumulator is\n+ *          automatically generated, it will have already absorbed the\n+ *          blacklist. If you're hacking around, make sure you use load()!\n+ */\n+\n+class HTMLPurifier_AttrDef_HTML_ID extends HTMLPurifier_AttrDef\n+{\n+\n+    // selector is NOT a valid thing to use for IDREFs, because IDREFs\n+    // *must* target IDs that exist, whereas selector #ids do not.\n+\n+    /**\n+     * Determines whether or not we're validating an ID in a CSS\n+     * selector context.\n+     * @type bool\n+     */\n+    protected $selector;\n+\n+    /**\n+     * @param bool $selector\n+     */\n+    public function __construct($selector = false)\n+    {\n+        $this->selector = $selector;\n+    }\n+\n+    /**\n+     * @param string $id\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($id, $config, $context)\n+    {\n+        if (!$this->selector && !$config->get('Attr.EnableID')) {\n+            return false;\n+        }\n+\n+        $id = trim($id); // trim it first\n+\n+        if ($id === '') {\n+            return false;\n+        }\n+\n+        $prefix = $config->get('Attr.IDPrefix');\n+        if ($prefix !== '') {\n+            $prefix .= $config->get('Attr.IDPrefixLocal');\n+            // prevent re-appending the prefix\n+            if (strpos($id, $prefix) !== 0) {\n+                $id = $prefix . $id;\n+            }\n+        } elseif ($config->get('Attr.IDPrefixLocal') !== '') {\n+            trigger_error(\n+                '%Attr.IDPrefixLocal cannot be used unless ' .\n+                '%Attr.IDPrefix is set',\n+                E_USER_WARNING\n+            );\n+        }\n+\n+        if (!$this->selector) {\n+            $id_accumulator =& $context->get('IDAccumulator');\n+            if (isset($id_accumulator->ids[$id])) {\n+                return false;\n+            }\n+        }\n+\n+        // we purposely avoid using regex, hopefully this is faster\n+\n+        if ($config->get('Attr.ID.HTML5') === true) {\n+            if (preg_match('/[\\t\\n\\x0b\\x0c ]/', $id)) {\n+                return false;\n+            }\n+        } else {\n+            if (ctype_alpha($id)) {\n+                // OK\n+            } else {\n+                if (!ctype_alpha(@$id[0])) {\n+                    return false;\n+                }\n+                // primitive style of regexps, I suppose\n+                $trim = trim(\n+                    $id,\n+                    'A..Za..z0..9:-._'\n+                );\n+                if ($trim !== '') {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        $regexp = $config->get('Attr.IDBlacklistRegexp');\n+        if ($regexp && preg_match($regexp, $id)) {\n+            return false;\n+        }\n+\n+        if (!$this->selector) {\n+            $id_accumulator->add($id);\n+        }\n+\n+        // if no change was made to the ID, return the result\n+        // else, return the new id if stripping whitespace made it\n+        //     valid, or return false.\n+        return $id;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/HTML/Length.php",
          "status": "added",
          "additions": 56,
          "deletions": 0,
          "patch": "@@ -0,0 +1,56 @@\n+<?php\n+\n+/**\n+ * Validates the HTML type length (not to be confused with CSS's length).\n+ *\n+ * This accepts integer pixels or percentages as lengths for certain\n+ * HTML attributes.\n+ */\n+\n+class HTMLPurifier_AttrDef_HTML_Length extends HTMLPurifier_AttrDef_HTML_Pixels\n+{\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        $string = trim($string);\n+        if ($string === '') {\n+            return false;\n+        }\n+\n+        $parent_result = parent::validate($string, $config, $context);\n+        if ($parent_result !== false) {\n+            return $parent_result;\n+        }\n+\n+        $length = strlen($string);\n+        $last_char = $string[$length - 1];\n+\n+        if ($last_char !== '%') {\n+            return false;\n+        }\n+\n+        $points = substr($string, 0, $length - 1);\n+\n+        if (!is_numeric($points)) {\n+            return false;\n+        }\n+\n+        $points = (int)$points;\n+\n+        if ($points < 0) {\n+            return '0%';\n+        }\n+        if ($points > 100) {\n+            return '100%';\n+        }\n+        return ((string)$points) . '%';\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/HTML/LinkTypes.php",
          "status": "added",
          "additions": 72,
          "deletions": 0,
          "patch": "@@ -0,0 +1,72 @@\n+<?php\n+\n+/**\n+ * Validates a rel/rev link attribute against a directive of allowed values\n+ * @note We cannot use Enum because link types allow multiple\n+ *       values.\n+ * @note Assumes link types are ASCII text\n+ */\n+class HTMLPurifier_AttrDef_HTML_LinkTypes extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * Name config attribute to pull.\n+     * @type string\n+     */\n+    protected $name;\n+\n+    /**\n+     * @param string $name\n+     */\n+    public function __construct($name)\n+    {\n+        $configLookup = array(\n+            'rel' => 'AllowedRel',\n+            'rev' => 'AllowedRev'\n+        );\n+        if (!isset($configLookup[$name])) {\n+            trigger_error(\n+                'Unrecognized attribute name for link ' .\n+                'relationship.',\n+                E_USER_ERROR\n+            );\n+            return;\n+        }\n+        $this->name = $configLookup[$name];\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        $allowed = $config->get('Attr.' . $this->name);\n+        if (empty($allowed)) {\n+            return false;\n+        }\n+\n+        $string = $this->parseCDATA($string);\n+        $parts = explode(' ', $string);\n+\n+        // lookup to prevent duplicates\n+        $ret_lookup = array();\n+        foreach ($parts as $part) {\n+            $part = strtolower(trim($part));\n+            if (!isset($allowed[$part])) {\n+                continue;\n+            }\n+            $ret_lookup[$part] = true;\n+        }\n+\n+        if (empty($ret_lookup)) {\n+            return false;\n+        }\n+        $string = implode(' ', array_keys($ret_lookup));\n+        return $string;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/HTML/MultiLength.php",
          "status": "added",
          "additions": 60,
          "deletions": 0,
          "patch": "@@ -0,0 +1,60 @@\n+<?php\n+\n+/**\n+ * Validates a MultiLength as defined by the HTML spec.\n+ *\n+ * A multilength is either a integer (pixel count), a percentage, or\n+ * a relative number.\n+ */\n+class HTMLPurifier_AttrDef_HTML_MultiLength extends HTMLPurifier_AttrDef_HTML_Length\n+{\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        $string = trim($string);\n+        if ($string === '') {\n+            return false;\n+        }\n+\n+        $parent_result = parent::validate($string, $config, $context);\n+        if ($parent_result !== false) {\n+            return $parent_result;\n+        }\n+\n+        $length = strlen($string);\n+        $last_char = $string[$length - 1];\n+\n+        if ($last_char !== '*') {\n+            return false;\n+        }\n+\n+        $int = substr($string, 0, $length - 1);\n+\n+        if ($int == '') {\n+            return '*';\n+        }\n+        if (!is_numeric($int)) {\n+            return false;\n+        }\n+\n+        $int = (int)$int;\n+        if ($int < 0) {\n+            return false;\n+        }\n+        if ($int == 0) {\n+            return '0';\n+        }\n+        if ($int == 1) {\n+            return '*';\n+        }\n+        return ((string)$int) . '*';\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/HTML/Nmtokens.php",
          "status": "added",
          "additions": 70,
          "deletions": 0,
          "patch": "@@ -0,0 +1,70 @@\n+<?php\n+\n+/**\n+ * Validates contents based on NMTOKENS attribute type.\n+ */\n+class HTMLPurifier_AttrDef_HTML_Nmtokens extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        $string = trim($string);\n+\n+        // early abort: '' and '0' (strings that convert to false) are invalid\n+        if (!$string) {\n+            return false;\n+        }\n+\n+        $tokens = $this->split($string, $config, $context);\n+        $tokens = $this->filter($tokens, $config, $context);\n+        if (empty($tokens)) {\n+            return false;\n+        }\n+        return implode(' ', $tokens);\n+    }\n+\n+    /**\n+     * Splits a space separated list of tokens into its constituent parts.\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    protected function split($string, $config, $context)\n+    {\n+        // OPTIMIZABLE!\n+        // do the preg_match, capture all subpatterns for reformulation\n+\n+        // we don't support U+00A1 and up codepoints or\n+        // escaping because I don't know how to do that with regexps\n+        // and plus it would complicate optimization efforts (you never\n+        // see that anyway).\n+        $pattern = '/(?:(?<=\\s)|\\A)' . // look behind for space or string start\n+            '((?:--|-?[A-Za-z_])[A-Za-z_\\-0-9]*)' .\n+            '(?:(?=\\s)|\\z)/'; // look ahead for space or string end\n+        preg_match_all($pattern, $string, $matches);\n+        return $matches[1];\n+    }\n+\n+    /**\n+     * Template method for removing certain tokens based on arbitrary criteria.\n+     * @note If we wanted to be really functional, we'd do an array_filter\n+     *       with a callback. But... we're not.\n+     * @param array $tokens\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    protected function filter($tokens, $config, $context)\n+    {\n+        return $tokens;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/HTML/Pixels.php",
          "status": "added",
          "additions": 76,
          "deletions": 0,
          "patch": "@@ -0,0 +1,76 @@\n+<?php\n+\n+/**\n+ * Validates an integer representation of pixels according to the HTML spec.\n+ */\n+class HTMLPurifier_AttrDef_HTML_Pixels extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * @type int\n+     */\n+    protected $max;\n+\n+    /**\n+     * @param int $max\n+     */\n+    public function __construct($max = null)\n+    {\n+        $this->max = $max;\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        $string = trim($string);\n+        if ($string === '0') {\n+            return $string;\n+        }\n+        if ($string === '') {\n+            return false;\n+        }\n+        $length = strlen($string);\n+        if (substr($string, $length - 2) == 'px') {\n+            $string = substr($string, 0, $length - 2);\n+        }\n+        if (!is_numeric($string)) {\n+            return false;\n+        }\n+        $int = (int)$string;\n+\n+        if ($int < 0) {\n+            return '0';\n+        }\n+\n+        // upper-bound value, extremely high values can\n+        // crash operating systems, see <http://ha.ckers.org/imagecrash.html>\n+        // WARNING, above link WILL crash you if you're using Windows\n+\n+        if ($this->max !== null && $int > $this->max) {\n+            return (string)$this->max;\n+        }\n+        return (string)$int;\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @return HTMLPurifier_AttrDef\n+     */\n+    public function make($string)\n+    {\n+        if ($string === '') {\n+            $max = null;\n+        } else {\n+            $max = (int)$string;\n+        }\n+        $class = get_class($this);\n+        return new $class($max);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/Integer.php",
          "status": "added",
          "additions": 91,
          "deletions": 0,
          "patch": "@@ -0,0 +1,91 @@\n+<?php\n+\n+/**\n+ * Validates an integer.\n+ * @note While this class was modeled off the CSS definition, no currently\n+ *       allowed CSS uses this type.  The properties that do are: widows,\n+ *       orphans, z-index, counter-increment, counter-reset.  Some of the\n+ *       HTML attributes, however, find use for a non-negative version of this.\n+ */\n+class HTMLPurifier_AttrDef_Integer extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * Whether or not negative values are allowed.\n+     * @type bool\n+     */\n+    protected $negative = true;\n+\n+    /**\n+     * Whether or not zero is allowed.\n+     * @type bool\n+     */\n+    protected $zero = true;\n+\n+    /**\n+     * Whether or not positive values are allowed.\n+     * @type bool\n+     */\n+    protected $positive = true;\n+\n+    /**\n+     * @param $negative Bool indicating whether or not negative values are allowed\n+     * @param $zero Bool indicating whether or not zero is allowed\n+     * @param $positive Bool indicating whether or not positive values are allowed\n+     */\n+    public function __construct($negative = true, $zero = true, $positive = true)\n+    {\n+        $this->negative = $negative;\n+        $this->zero = $zero;\n+        $this->positive = $positive;\n+    }\n+\n+    /**\n+     * @param string $integer\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($integer, $config, $context)\n+    {\n+        $integer = $this->parseCDATA($integer);\n+        if ($integer === '') {\n+            return false;\n+        }\n+\n+        // we could possibly simply typecast it to integer, but there are\n+        // certain fringe cases that must not return an integer.\n+\n+        // clip leading sign\n+        if ($this->negative && $integer[0] === '-') {\n+            $digits = substr($integer, 1);\n+            if ($digits === '0') {\n+                $integer = '0';\n+            } // rm minus sign for zero\n+        } elseif ($this->positive && $integer[0] === '+') {\n+            $digits = $integer = substr($integer, 1); // rm unnecessary plus\n+        } else {\n+            $digits = $integer;\n+        }\n+\n+        // test if it's numeric\n+        if (!ctype_digit($digits)) {\n+            return false;\n+        }\n+\n+        // perform scope tests\n+        if (!$this->zero && $integer == 0) {\n+            return false;\n+        }\n+        if (!$this->positive && $integer > 0) {\n+            return false;\n+        }\n+        if (!$this->negative && $integer < 0) {\n+            return false;\n+        }\n+\n+        return $integer;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/Lang.php",
          "status": "added",
          "additions": 86,
          "deletions": 0,
          "patch": "@@ -0,0 +1,86 @@\n+<?php\n+\n+/**\n+ * Validates the HTML attribute lang, effectively a language code.\n+ * @note Built according to RFC 3066, which obsoleted RFC 1766\n+ */\n+class HTMLPurifier_AttrDef_Lang extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        $string = trim($string);\n+        if (!$string) {\n+            return false;\n+        }\n+\n+        $subtags = explode('-', $string);\n+        $num_subtags = count($subtags);\n+\n+        if ($num_subtags == 0) { // sanity check\n+            return false;\n+        }\n+\n+        // process primary subtag : $subtags[0]\n+        $length = strlen($subtags[0]);\n+        switch ($length) {\n+            case 0:\n+                return false;\n+            case 1:\n+                if (!($subtags[0] == 'x' || $subtags[0] == 'i')) {\n+                    return false;\n+                }\n+                break;\n+            case 2:\n+            case 3:\n+                if (!ctype_alpha($subtags[0])) {\n+                    return false;\n+                } elseif (!ctype_lower($subtags[0])) {\n+                    $subtags[0] = strtolower($subtags[0]);\n+                }\n+                break;\n+            default:\n+                return false;\n+        }\n+\n+        $new_string = $subtags[0];\n+        if ($num_subtags == 1) {\n+            return $new_string;\n+        }\n+\n+        // process second subtag : $subtags[1]\n+        $length = strlen($subtags[1]);\n+        if ($length == 0 || ($length == 1 && $subtags[1] != 'x') || $length > 8 || !ctype_alnum($subtags[1])) {\n+            return $new_string;\n+        }\n+        if (!ctype_lower($subtags[1])) {\n+            $subtags[1] = strtolower($subtags[1]);\n+        }\n+\n+        $new_string .= '-' . $subtags[1];\n+        if ($num_subtags == 2) {\n+            return $new_string;\n+        }\n+\n+        // process all other subtags, index 2 and up\n+        for ($i = 2; $i < $num_subtags; $i++) {\n+            $length = strlen($subtags[$i]);\n+            if ($length == 0 || $length > 8 || !ctype_alnum($subtags[$i])) {\n+                return $new_string;\n+            }\n+            if (!ctype_lower($subtags[$i])) {\n+                $subtags[$i] = strtolower($subtags[$i]);\n+            }\n+            $new_string .= '-' . $subtags[$i];\n+        }\n+        return $new_string;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/Switch.php",
          "status": "added",
          "additions": 53,
          "deletions": 0,
          "patch": "@@ -0,0 +1,53 @@\n+<?php\n+\n+/**\n+ * Decorator that, depending on a token, switches between two definitions.\n+ */\n+class HTMLPurifier_AttrDef_Switch\n+{\n+\n+    /**\n+     * @type string\n+     */\n+    protected $tag;\n+\n+    /**\n+     * @type HTMLPurifier_AttrDef\n+     */\n+    protected $withTag;\n+\n+    /**\n+     * @type HTMLPurifier_AttrDef\n+     */\n+    protected $withoutTag;\n+\n+    /**\n+     * @param string $tag Tag name to switch upon\n+     * @param HTMLPurifier_AttrDef $with_tag Call if token matches tag\n+     * @param HTMLPurifier_AttrDef $without_tag Call if token doesn't match, or there is no token\n+     */\n+    public function __construct($tag, $with_tag, $without_tag)\n+    {\n+        $this->tag = $tag;\n+        $this->withTag = $with_tag;\n+        $this->withoutTag = $without_tag;\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        $token = $context->get('CurrentToken', true);\n+        if (!$token || $token->name !== $this->tag) {\n+            return $this->withoutTag->validate($string, $config, $context);\n+        } else {\n+            return $this->withTag->validate($string, $config, $context);\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/Text.php",
          "status": "added",
          "additions": 21,
          "deletions": 0,
          "patch": "@@ -0,0 +1,21 @@\n+<?php\n+\n+/**\n+ * Validates arbitrary text according to the HTML spec.\n+ */\n+class HTMLPurifier_AttrDef_Text extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        return $this->parseCDATA($string);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/URI.php",
          "status": "added",
          "additions": 111,
          "deletions": 0,
          "patch": "@@ -0,0 +1,111 @@\n+<?php\n+\n+/**\n+ * Validates a URI as defined by RFC 3986.\n+ * @note Scheme-specific mechanics deferred to HTMLPurifier_URIScheme\n+ */\n+class HTMLPurifier_AttrDef_URI extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * @type HTMLPurifier_URIParser\n+     */\n+    protected $parser;\n+\n+    /**\n+     * @type bool\n+     */\n+    protected $embedsResource;\n+\n+    /**\n+     * @param bool $embeds_resource Does the URI here result in an extra HTTP request?\n+     */\n+    public function __construct($embeds_resource = false)\n+    {\n+        $this->parser = new HTMLPurifier_URIParser();\n+        $this->embedsResource = (bool)$embeds_resource;\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @return HTMLPurifier_AttrDef_URI\n+     */\n+    public function make($string)\n+    {\n+        $embeds = ($string === 'embedded');\n+        return new HTMLPurifier_AttrDef_URI($embeds);\n+    }\n+\n+    /**\n+     * @param string $uri\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($uri, $config, $context)\n+    {\n+        if ($config->get('URI.Disable')) {\n+            return false;\n+        }\n+\n+        $uri = $this->parseCDATA($uri);\n+\n+        // parse the URI\n+        $uri = $this->parser->parse($uri);\n+        if ($uri === false) {\n+            return false;\n+        }\n+\n+        // add embedded flag to context for validators\n+        $context->register('EmbeddedURI', $this->embedsResource);\n+\n+        $ok = false;\n+        do {\n+\n+            // generic validation\n+            $result = $uri->validate($config, $context);\n+            if (!$result) {\n+                break;\n+            }\n+\n+            // chained filtering\n+            $uri_def = $config->getDefinition('URI');\n+            $result = $uri_def->filter($uri, $config, $context);\n+            if (!$result) {\n+                break;\n+            }\n+\n+            // scheme-specific validation\n+            $scheme_obj = $uri->getSchemeObj($config, $context);\n+            if (!$scheme_obj) {\n+                break;\n+            }\n+            if ($this->embedsResource && !$scheme_obj->browsable) {\n+                break;\n+            }\n+            $result = $scheme_obj->validate($uri, $config, $context);\n+            if (!$result) {\n+                break;\n+            }\n+\n+            // Post chained filtering\n+            $result = $uri_def->postFilter($uri, $config, $context);\n+            if (!$result) {\n+                break;\n+            }\n+\n+            // survived gauntlet\n+            $ok = true;\n+\n+        } while (false);\n+\n+        $context->destroy('EmbeddedURI');\n+        if (!$ok) {\n+            return false;\n+        }\n+        // back to string\n+        return $uri->toString();\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/URI/Email.php",
          "status": "added",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -0,0 +1,20 @@\n+<?php\n+\n+abstract class HTMLPurifier_AttrDef_URI_Email extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * Unpacks a mailbox into its display-name and address\n+     * @param string $string\n+     * @return mixed\n+     */\n+    public function unpack($string)\n+    {\n+        // needs to be implemented\n+    }\n+\n+}\n+\n+// sub-implementations\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/URI/Email/SimpleCheck.php",
          "status": "added",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -0,0 +1,29 @@\n+<?php\n+\n+/**\n+ * Primitive email validation class based on the regexp found at\n+ * http://www.regular-expressions.info/email.html\n+ */\n+class HTMLPurifier_AttrDef_URI_Email_SimpleCheck extends HTMLPurifier_AttrDef_URI_Email\n+{\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        // no support for named mailboxes i.e. \"Bob <bob@example.com>\"\n+        // that needs more percent encoding to be done\n+        if ($string == '') {\n+            return false;\n+        }\n+        $string = trim($string);\n+        $result = preg_match('/^[A-Z0-9._%-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i', $string);\n+        return $result ? $string : false;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/URI/Host.php",
          "status": "added",
          "additions": 137,
          "deletions": 0,
          "patch": "@@ -0,0 +1,137 @@\n+<?php\n+\n+/**\n+ * Validates a host according to the IPv4, IPv6 and DNS (future) specifications.\n+ */\n+class HTMLPurifier_AttrDef_URI_Host extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * IPv4 sub-validator.\n+     * @type HTMLPurifier_AttrDef_URI_IPv4\n+     */\n+    protected $ipv4;\n+\n+    /**\n+     * IPv6 sub-validator.\n+     * @type HTMLPurifier_AttrDef_URI_IPv6\n+     */\n+    protected $ipv6;\n+\n+    public function __construct()\n+    {\n+        $this->ipv4 = new HTMLPurifier_AttrDef_URI_IPv4();\n+        $this->ipv6 = new HTMLPurifier_AttrDef_URI_IPv6();\n+    }\n+\n+    /**\n+     * @param string $string\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($string, $config, $context)\n+    {\n+        $length = strlen($string);\n+        // empty hostname is OK; it's usually semantically equivalent:\n+        // the default host as defined by a URI scheme is used:\n+        //\n+        //      If the URI scheme defines a default for host, then that\n+        //      default applies when the host subcomponent is undefined\n+        //      or when the registered name is empty (zero length).\n+        if ($string === '') {\n+            return '';\n+        }\n+        if ($length > 1 && $string[0] === '[' && $string[$length - 1] === ']') {\n+            //IPv6\n+            $ip = substr($string, 1, $length - 2);\n+            $valid = $this->ipv6->validate($ip, $config, $context);\n+            if ($valid === false) {\n+                return false;\n+            }\n+            return '[' . $valid . ']';\n+        }\n+\n+        // need to do checks on unusual encodings too\n+        $ipv4 = $this->ipv4->validate($string, $config, $context);\n+        if ($ipv4 !== false) {\n+            return $ipv4;\n+        }\n+\n+        // A regular domain name.\n+\n+        // This doesn't match I18N domain names, but we don't have proper IRI support,\n+        // so force users to insert Punycode.\n+\n+        // There is not a good sense in which underscores should be\n+        // allowed, since it's technically not! (And if you go as\n+        // far to allow everything as specified by the DNS spec...\n+        // well, that's literally everything, modulo some space limits\n+        // for the components and the overall name (which, by the way,\n+        // we are NOT checking!).  So we (arbitrarily) decide this:\n+        // let's allow underscores wherever we would have allowed\n+        // hyphens, if they are enabled.  This is a pretty good match\n+        // for browser behavior, for example, a large number of browsers\n+        // cannot handle foo_.example.com, but foo_bar.example.com is\n+        // fairly well supported.\n+        $underscore = $config->get('Core.AllowHostnameUnderscore') ? '_' : '';\n+\n+        // Based off of RFC 1738, but amended so that\n+        // as per RFC 3696, the top label need only not be all numeric.\n+        // The productions describing this are:\n+        $a   = '[a-z]';     // alpha\n+        $an  = '[a-z0-9]';  // alphanum\n+        $and = \"[a-z0-9-$underscore]\"; // alphanum | \"-\"\n+        // domainlabel = alphanum | alphanum *( alphanum | \"-\" ) alphanum\n+        $domainlabel = \"$an(?:$and*$an)?\";\n+        // AMENDED as per RFC 3696\n+        // toplabel    = alphanum | alphanum *( alphanum | \"-\" ) alphanum\n+        //      side condition: not all numeric\n+        $toplabel = \"$an(?:$and*$an)?\";\n+        // hostname    = *( domainlabel \".\" ) toplabel [ \".\" ]\n+        if (preg_match(\"/^(?:$domainlabel\\.)*($toplabel)\\.?$/i\", $string, $matches)) {\n+            if (!ctype_digit($matches[1])) {\n+                return $string;\n+            }\n+        }\n+\n+        // PHP 5.3 and later support this functionality natively\n+        if (function_exists('idn_to_ascii')) {\n+            return idn_to_ascii($string);\n+\n+        // If we have Net_IDNA2 support, we can support IRIs by\n+        // punycoding them. (This is the most portable thing to do,\n+        // since otherwise we have to assume browsers support\n+        } elseif ($config->get('Core.EnableIDNA')) {\n+            $idna = new Net_IDNA2(array('encoding' => 'utf8', 'overlong' => false, 'strict' => true));\n+            // we need to encode each period separately\n+            $parts = explode('.', $string);\n+            try {\n+                $new_parts = array();\n+                foreach ($parts as $part) {\n+                    $encodable = false;\n+                    for ($i = 0, $c = strlen($part); $i < $c; $i++) {\n+                        if (ord($part[$i]) > 0x7a) {\n+                            $encodable = true;\n+                            break;\n+                        }\n+                    }\n+                    if (!$encodable) {\n+                        $new_parts[] = $part;\n+                    } else {\n+                        $new_parts[] = $idna->encode($part);\n+                    }\n+                }\n+                $string = implode('.', $new_parts);\n+                if (preg_match(\"/^($domainlabel\\.)*$toplabel\\.?$/i\", $string)) {\n+                    return $string;\n+                }\n+            } catch (Exception $e) {\n+                // XXX error reporting\n+            }\n+        }\n+        return false;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/URI/IPv4.php",
          "status": "added",
          "additions": 45,
          "deletions": 0,
          "patch": "@@ -0,0 +1,45 @@\n+<?php\n+\n+/**\n+ * Validates an IPv4 address\n+ * @author Feyd @ forums.devnetwork.net (public domain)\n+ */\n+class HTMLPurifier_AttrDef_URI_IPv4 extends HTMLPurifier_AttrDef\n+{\n+\n+    /**\n+     * IPv4 regex, protected so that IPv6 can reuse it.\n+     * @type string\n+     */\n+    protected $ip4;\n+\n+    /**\n+     * @param string $aIP\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($aIP, $config, $context)\n+    {\n+        if (!$this->ip4) {\n+            $this->_loadRegex();\n+        }\n+\n+        if (preg_match('#^' . $this->ip4 . '$#s', $aIP)) {\n+            return $aIP;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Lazy load function to prevent regex from being stuffed in\n+     * cache.\n+     */\n+    protected function _loadRegex()\n+    {\n+        $oct = '(?:25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])'; // 0-255\n+        $this->ip4 = \"(?:{$oct}\\\\.{$oct}\\\\.{$oct}\\\\.{$oct})\";\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrDef/URI/IPv6.php",
          "status": "added",
          "additions": 89,
          "deletions": 0,
          "patch": "@@ -0,0 +1,89 @@\n+<?php\n+\n+/**\n+ * Validates an IPv6 address.\n+ * @author Feyd @ forums.devnetwork.net (public domain)\n+ * @note This function requires brackets to have been removed from address\n+ *       in URI.\n+ */\n+class HTMLPurifier_AttrDef_URI_IPv6 extends HTMLPurifier_AttrDef_URI_IPv4\n+{\n+\n+    /**\n+     * @param string $aIP\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string\n+     */\n+    public function validate($aIP, $config, $context)\n+    {\n+        if (!$this->ip4) {\n+            $this->_loadRegex();\n+        }\n+\n+        $original = $aIP;\n+\n+        $hex = '[0-9a-fA-F]';\n+        $blk = '(?:' . $hex . '{1,4})';\n+        $pre = '(?:/(?:12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9]))'; // /0 - /128\n+\n+        //      prefix check\n+        if (strpos($aIP, '/') !== false) {\n+            if (preg_match('#' . $pre . '$#s', $aIP, $find)) {\n+                $aIP = substr($aIP, 0, 0 - strlen($find[0]));\n+                unset($find);\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        //      IPv4-compatiblity check\n+        if (preg_match('#(?<=:' . ')' . $this->ip4 . '$#s', $aIP, $find)) {\n+            $aIP = substr($aIP, 0, 0 - strlen($find[0]));\n+            $ip = explode('.', $find[0]);\n+            $ip = array_map('dechex', $ip);\n+            $aIP .= $ip[0] . $ip[1] . ':' . $ip[2] . $ip[3];\n+            unset($find, $ip);\n+        }\n+\n+        //      compression check\n+        $aIP = explode('::', $aIP);\n+        $c = count($aIP);\n+        if ($c > 2) {\n+            return false;\n+        } elseif ($c == 2) {\n+            list($first, $second) = $aIP;\n+            $first = explode(':', $first);\n+            $second = explode(':', $second);\n+\n+            if (count($first) + count($second) > 8) {\n+                return false;\n+            }\n+\n+            while (count($first) < 8) {\n+                array_push($first, '0');\n+            }\n+\n+            array_splice($first, 8 - count($second), 8, $second);\n+            $aIP = $first;\n+            unset($first, $second);\n+        } else {\n+            $aIP = explode(':', $aIP[0]);\n+        }\n+        $c = count($aIP);\n+\n+        if ($c != 8) {\n+            return false;\n+        }\n+\n+        //      All the pieces should be 16-bit hex strings. Are they?\n+        foreach ($aIP as $piece) {\n+            if (!preg_match('#^[0-9a-fA-F]{4}$#s', sprintf('%04s', $piece))) {\n+                return false;\n+            }\n+        }\n+        return $original;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform.php",
          "status": "added",
          "additions": 60,
          "deletions": 0,
          "patch": "@@ -0,0 +1,60 @@\n+<?php\n+\n+/**\n+ * Processes an entire attribute array for corrections needing multiple values.\n+ *\n+ * Occasionally, a certain attribute will need to be removed and popped onto\n+ * another value.  Instead of creating a complex return syntax for\n+ * HTMLPurifier_AttrDef, we just pass the whole attribute array to a\n+ * specialized object and have that do the special work.  That is the\n+ * family of HTMLPurifier_AttrTransform.\n+ *\n+ * An attribute transformation can be assigned to run before or after\n+ * HTMLPurifier_AttrDef validation.  See HTMLPurifier_HTMLDefinition for\n+ * more details.\n+ */\n+\n+abstract class HTMLPurifier_AttrTransform\n+{\n+\n+    /**\n+     * Abstract: makes changes to the attributes dependent on multiple values.\n+     *\n+     * @param array $attr Assoc array of attributes, usually from\n+     *              HTMLPurifier_Token_Tag::$attr\n+     * @param HTMLPurifier_Config $config Mandatory HTMLPurifier_Config object.\n+     * @param HTMLPurifier_Context $context Mandatory HTMLPurifier_Context object\n+     * @return array Processed attribute array.\n+     */\n+    abstract public function transform($attr, $config, $context);\n+\n+    /**\n+     * Prepends CSS properties to the style attribute, creating the\n+     * attribute if it doesn't exist.\n+     * @param array &$attr Attribute array to process (passed by reference)\n+     * @param string $css CSS to prepend\n+     */\n+    public function prependCSS(&$attr, $css)\n+    {\n+        $attr['style'] = isset($attr['style']) ? $attr['style'] : '';\n+        $attr['style'] = $css . $attr['style'];\n+    }\n+\n+    /**\n+     * Retrieves and removes an attribute\n+     * @param array &$attr Attribute array to process (passed by reference)\n+     * @param mixed $key Key of attribute to confiscate\n+     * @return mixed\n+     */\n+    public function confiscateAttr(&$attr, $key)\n+    {\n+        if (!isset($attr[$key])) {\n+            return null;\n+        }\n+        $value = $attr[$key];\n+        unset($attr[$key]);\n+        return $value;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/Background.php",
          "status": "added",
          "additions": 28,
          "deletions": 0,
          "patch": "@@ -0,0 +1,28 @@\n+<?php\n+\n+/**\n+ * Pre-transform that changes proprietary background attribute to CSS.\n+ */\n+class HTMLPurifier_AttrTransform_Background extends HTMLPurifier_AttrTransform\n+{\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        if (!isset($attr['background'])) {\n+            return $attr;\n+        }\n+\n+        $background = $this->confiscateAttr($attr, 'background');\n+        // some validation should happen here\n+\n+        $this->prependCSS($attr, \"background-image:url($background);\");\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/BdoDir.php",
          "status": "added",
          "additions": 27,
          "deletions": 0,
          "patch": "@@ -0,0 +1,27 @@\n+<?php\n+\n+// this MUST be placed in post, as it assumes that any value in dir is valid\n+\n+/**\n+ * Post-trasnform that ensures that bdo tags have the dir attribute set.\n+ */\n+class HTMLPurifier_AttrTransform_BdoDir extends HTMLPurifier_AttrTransform\n+{\n+\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        if (isset($attr['dir'])) {\n+            return $attr;\n+        }\n+        $attr['dir'] = $config->get('Attr.DefaultTextDir');\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/BgColor.php",
          "status": "added",
          "additions": 28,
          "deletions": 0,
          "patch": "@@ -0,0 +1,28 @@\n+<?php\n+\n+/**\n+ * Pre-transform that changes deprecated bgcolor attribute to CSS.\n+ */\n+class HTMLPurifier_AttrTransform_BgColor extends HTMLPurifier_AttrTransform\n+{\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        if (!isset($attr['bgcolor'])) {\n+            return $attr;\n+        }\n+\n+        $bgcolor = $this->confiscateAttr($attr, 'bgcolor');\n+        // some validation should happen here\n+\n+        $this->prependCSS($attr, \"background-color:$bgcolor;\");\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/BoolToCSS.php",
          "status": "added",
          "additions": 47,
          "deletions": 0,
          "patch": "@@ -0,0 +1,47 @@\n+<?php\n+\n+/**\n+ * Pre-transform that changes converts a boolean attribute to fixed CSS\n+ */\n+class HTMLPurifier_AttrTransform_BoolToCSS extends HTMLPurifier_AttrTransform\n+{\n+    /**\n+     * Name of boolean attribute that is trigger.\n+     * @type string\n+     */\n+    protected $attr;\n+\n+    /**\n+     * CSS declarations to add to style, needs trailing semicolon.\n+     * @type string\n+     */\n+    protected $css;\n+\n+    /**\n+     * @param string $attr attribute name to convert from\n+     * @param string $css CSS declarations to add to style (needs semicolon)\n+     */\n+    public function __construct($attr, $css)\n+    {\n+        $this->attr = $attr;\n+        $this->css = $css;\n+    }\n+\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        if (!isset($attr[$this->attr])) {\n+            return $attr;\n+        }\n+        unset($attr[$this->attr]);\n+        $this->prependCSS($attr, $this->css);\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/Border.php",
          "status": "added",
          "additions": 26,
          "deletions": 0,
          "patch": "@@ -0,0 +1,26 @@\n+<?php\n+\n+/**\n+ * Pre-transform that changes deprecated border attribute to CSS.\n+ */\n+class HTMLPurifier_AttrTransform_Border extends HTMLPurifier_AttrTransform\n+{\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        if (!isset($attr['border'])) {\n+            return $attr;\n+        }\n+        $border_width = $this->confiscateAttr($attr, 'border');\n+        // some validation should happen here\n+        $this->prependCSS($attr, \"border:{$border_width}px solid;\");\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/EnumToCSS.php",
          "status": "added",
          "additions": 68,
          "deletions": 0,
          "patch": "@@ -0,0 +1,68 @@\n+<?php\n+\n+/**\n+ * Generic pre-transform that converts an attribute with a fixed number of\n+ * values (enumerated) to CSS.\n+ */\n+class HTMLPurifier_AttrTransform_EnumToCSS extends HTMLPurifier_AttrTransform\n+{\n+    /**\n+     * Name of attribute to transform from.\n+     * @type string\n+     */\n+    protected $attr;\n+\n+    /**\n+     * Lookup array of attribute values to CSS.\n+     * @type array\n+     */\n+    protected $enumToCSS = array();\n+\n+    /**\n+     * Case sensitivity of the matching.\n+     * @type bool\n+     * @warning Currently can only be guaranteed to work with ASCII\n+     *          values.\n+     */\n+    protected $caseSensitive = false;\n+\n+    /**\n+     * @param string $attr Attribute name to transform from\n+     * @param array $enum_to_css Lookup array of attribute values to CSS\n+     * @param bool $case_sensitive Case sensitivity indicator, default false\n+     */\n+    public function __construct($attr, $enum_to_css, $case_sensitive = false)\n+    {\n+        $this->attr = $attr;\n+        $this->enumToCSS = $enum_to_css;\n+        $this->caseSensitive = (bool)$case_sensitive;\n+    }\n+\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        if (!isset($attr[$this->attr])) {\n+            return $attr;\n+        }\n+\n+        $value = trim($attr[$this->attr]);\n+        unset($attr[$this->attr]);\n+\n+        if (!$this->caseSensitive) {\n+            $value = strtolower($value);\n+        }\n+\n+        if (!isset($this->enumToCSS[$value])) {\n+            return $attr;\n+        }\n+        $this->prependCSS($attr, $this->enumToCSS[$value]);\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/ImgRequired.php",
          "status": "added",
          "additions": 47,
          "deletions": 0,
          "patch": "@@ -0,0 +1,47 @@\n+<?php\n+\n+// must be called POST validation\n+\n+/**\n+ * Transform that supplies default values for the src and alt attributes\n+ * in img tags, as well as prevents the img tag from being removed\n+ * because of a missing alt tag. This needs to be registered as both\n+ * a pre and post attribute transform.\n+ */\n+class HTMLPurifier_AttrTransform_ImgRequired extends HTMLPurifier_AttrTransform\n+{\n+\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        $src = true;\n+        if (!isset($attr['src'])) {\n+            if ($config->get('Core.RemoveInvalidImg')) {\n+                return $attr;\n+            }\n+            $attr['src'] = $config->get('Attr.DefaultInvalidImage');\n+            $src = false;\n+        }\n+\n+        if (!isset($attr['alt'])) {\n+            if ($src) {\n+                $alt = $config->get('Attr.DefaultImageAlt');\n+                if ($alt === null) {\n+                    $attr['alt'] = basename($attr['src']);\n+                } else {\n+                    $attr['alt'] = $alt;\n+                }\n+            } else {\n+                $attr['alt'] = $config->get('Attr.DefaultInvalidImageAlt');\n+            }\n+        }\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/ImgSpace.php",
          "status": "added",
          "additions": 61,
          "deletions": 0,
          "patch": "@@ -0,0 +1,61 @@\n+<?php\n+\n+/**\n+ * Pre-transform that changes deprecated hspace and vspace attributes to CSS\n+ */\n+class HTMLPurifier_AttrTransform_ImgSpace extends HTMLPurifier_AttrTransform\n+{\n+    /**\n+     * @type string\n+     */\n+    protected $attr;\n+\n+    /**\n+     * @type array\n+     */\n+    protected $css = array(\n+        'hspace' => array('left', 'right'),\n+        'vspace' => array('top', 'bottom')\n+    );\n+\n+    /**\n+     * @param string $attr\n+     */\n+    public function __construct($attr)\n+    {\n+        $this->attr = $attr;\n+        if (!isset($this->css[$attr])) {\n+            trigger_error(htmlspecialchars($attr) . ' is not valid space attribute');\n+        }\n+    }\n+\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        if (!isset($attr[$this->attr])) {\n+            return $attr;\n+        }\n+\n+        $width = $this->confiscateAttr($attr, $this->attr);\n+        // some validation could happen here\n+\n+        if (!isset($this->css[$this->attr])) {\n+            return $attr;\n+        }\n+\n+        $style = '';\n+        foreach ($this->css[$this->attr] as $suffix) {\n+            $property = \"margin-$suffix\";\n+            $style .= \"$property:{$width}px;\";\n+        }\n+        $this->prependCSS($attr, $style);\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/Input.php",
          "status": "added",
          "additions": 56,
          "deletions": 0,
          "patch": "@@ -0,0 +1,56 @@\n+<?php\n+\n+/**\n+ * Performs miscellaneous cross attribute validation and filtering for\n+ * input elements. This is meant to be a post-transform.\n+ */\n+class HTMLPurifier_AttrTransform_Input extends HTMLPurifier_AttrTransform\n+{\n+    /**\n+     * @type HTMLPurifier_AttrDef_HTML_Pixels\n+     */\n+    protected $pixels;\n+\n+    public function __construct()\n+    {\n+        $this->pixels = new HTMLPurifier_AttrDef_HTML_Pixels();\n+    }\n+\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        if (!isset($attr['type'])) {\n+            $t = 'text';\n+        } else {\n+            $t = strtolower($attr['type']);\n+        }\n+        if (isset($attr['checked']) && $t !== 'radio' && $t !== 'checkbox') {\n+            unset($attr['checked']);\n+        }\n+        if (isset($attr['maxlength']) && $t !== 'text' && $t !== 'password') {\n+            unset($attr['maxlength']);\n+        }\n+        if (isset($attr['size']) && $t !== 'text' && $t !== 'password') {\n+            $result = $this->pixels->validate($attr['size'], $config, $context);\n+            if ($result === false) {\n+                unset($attr['size']);\n+            } else {\n+                $attr['size'] = $result;\n+            }\n+        }\n+        if (isset($attr['src']) && $t !== 'image') {\n+            unset($attr['src']);\n+        }\n+        if (!isset($attr['value']) && ($t === 'radio' || $t === 'checkbox')) {\n+            $attr['value'] = '';\n+        }\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/Lang.php",
          "status": "added",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -0,0 +1,31 @@\n+<?php\n+\n+/**\n+ * Post-transform that copies lang's value to xml:lang (and vice-versa)\n+ * @note Theoretically speaking, this could be a pre-transform, but putting\n+ *       post is more efficient.\n+ */\n+class HTMLPurifier_AttrTransform_Lang extends HTMLPurifier_AttrTransform\n+{\n+\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        $lang = isset($attr['lang']) ? $attr['lang'] : false;\n+        $xml_lang = isset($attr['xml:lang']) ? $attr['xml:lang'] : false;\n+\n+        if ($lang !== false && $xml_lang === false) {\n+            $attr['xml:lang'] = $lang;\n+        } elseif ($xml_lang !== false) {\n+            $attr['lang'] = $xml_lang;\n+        }\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/Length.php",
          "status": "added",
          "additions": 45,
          "deletions": 0,
          "patch": "@@ -0,0 +1,45 @@\n+<?php\n+\n+/**\n+ * Class for handling width/height length attribute transformations to CSS\n+ */\n+class HTMLPurifier_AttrTransform_Length extends HTMLPurifier_AttrTransform\n+{\n+\n+    /**\n+     * @type string\n+     */\n+    protected $name;\n+\n+    /**\n+     * @type string\n+     */\n+    protected $cssName;\n+\n+    public function __construct($name, $css_name = null)\n+    {\n+        $this->name = $name;\n+        $this->cssName = $css_name ? $css_name : $name;\n+    }\n+\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        if (!isset($attr[$this->name])) {\n+            return $attr;\n+        }\n+        $length = $this->confiscateAttr($attr, $this->name);\n+        if (ctype_digit($length)) {\n+            $length .= 'px';\n+        }\n+        $this->prependCSS($attr, $this->cssName . \":$length;\");\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/Name.php",
          "status": "added",
          "additions": 33,
          "deletions": 0,
          "patch": "@@ -0,0 +1,33 @@\n+<?php\n+\n+/**\n+ * Pre-transform that changes deprecated name attribute to ID if necessary\n+ */\n+class HTMLPurifier_AttrTransform_Name extends HTMLPurifier_AttrTransform\n+{\n+\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        // Abort early if we're using relaxed definition of name\n+        if ($config->get('HTML.Attr.Name.UseCDATA')) {\n+            return $attr;\n+        }\n+        if (!isset($attr['name'])) {\n+            return $attr;\n+        }\n+        $id = $this->confiscateAttr($attr, 'name');\n+        if (isset($attr['id'])) {\n+            return $attr;\n+        }\n+        $attr['id'] = $id;\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/NameSync.php",
          "status": "added",
          "additions": 41,
          "deletions": 0,
          "patch": "@@ -0,0 +1,41 @@\n+<?php\n+\n+/**\n+ * Post-transform that performs validation to the name attribute; if\n+ * it is present with an equivalent id attribute, it is passed through;\n+ * otherwise validation is performed.\n+ */\n+class HTMLPurifier_AttrTransform_NameSync extends HTMLPurifier_AttrTransform\n+{\n+\n+    public function __construct()\n+    {\n+        $this->idDef = new HTMLPurifier_AttrDef_HTML_ID();\n+    }\n+\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        if (!isset($attr['name'])) {\n+            return $attr;\n+        }\n+        $name = $attr['name'];\n+        if (isset($attr['id']) && $attr['id'] === $name) {\n+            return $attr;\n+        }\n+        $result = $this->idDef->validate($name, $config, $context);\n+        if ($result === false) {\n+            unset($attr['name']);\n+        } else {\n+            $attr['name'] = $result;\n+        }\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/Nofollow.php",
          "status": "added",
          "additions": 52,
          "deletions": 0,
          "patch": "@@ -0,0 +1,52 @@\n+<?php\n+\n+// must be called POST validation\n+\n+/**\n+ * Adds rel=\"nofollow\" to all outbound links.  This transform is\n+ * only attached if Attr.Nofollow is TRUE.\n+ */\n+class HTMLPurifier_AttrTransform_Nofollow extends HTMLPurifier_AttrTransform\n+{\n+    /**\n+     * @type HTMLPurifier_URIParser\n+     */\n+    private $parser;\n+\n+    public function __construct()\n+    {\n+        $this->parser = new HTMLPurifier_URIParser();\n+    }\n+\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        if (!isset($attr['href'])) {\n+            return $attr;\n+        }\n+\n+        // XXX Kind of inefficient\n+        $url = $this->parser->parse($attr['href']);\n+        $scheme = $url->getSchemeObj($config, $context);\n+\n+        if ($scheme->browsable && !$url->isLocal($config, $context)) {\n+            if (isset($attr['rel'])) {\n+                $rels = explode(' ', $attr['rel']);\n+                if (!in_array('nofollow', $rels)) {\n+                    $rels[] = 'nofollow';\n+                }\n+                $attr['rel'] = implode(' ', $rels);\n+            } else {\n+                $attr['rel'] = 'nofollow';\n+            }\n+        }\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/SafeEmbed.php",
          "status": "added",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -0,0 +1,25 @@\n+<?php\n+\n+class HTMLPurifier_AttrTransform_SafeEmbed extends HTMLPurifier_AttrTransform\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = \"SafeEmbed\";\n+\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        $attr['allowscriptaccess'] = 'never';\n+        $attr['allownetworking'] = 'internal';\n+        $attr['type'] = 'application/x-shockwave-flash';\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/SafeObject.php",
          "status": "added",
          "additions": 28,
          "deletions": 0,
          "patch": "@@ -0,0 +1,28 @@\n+<?php\n+\n+/**\n+ * Writes default type for all objects. Currently only supports flash.\n+ */\n+class HTMLPurifier_AttrTransform_SafeObject extends HTMLPurifier_AttrTransform\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = \"SafeObject\";\n+\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        if (!isset($attr['type'])) {\n+            $attr['type'] = 'application/x-shockwave-flash';\n+        }\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/SafeParam.php",
          "status": "added",
          "additions": 79,
          "deletions": 0,
          "patch": "@@ -0,0 +1,79 @@\n+<?php\n+\n+/**\n+ * Validates name/value pairs in param tags to be used in safe objects. This\n+ * will only allow name values it recognizes, and pre-fill certain attributes\n+ * with required values.\n+ *\n+ * @note\n+ *      This class only supports Flash. In the future, Quicktime support\n+ *      may be added.\n+ *\n+ * @warning\n+ *      This class expects an injector to add the necessary parameters tags.\n+ */\n+class HTMLPurifier_AttrTransform_SafeParam extends HTMLPurifier_AttrTransform\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = \"SafeParam\";\n+\n+    /**\n+     * @type HTMLPurifier_AttrDef_URI\n+     */\n+    private $uri;\n+\n+    public function __construct()\n+    {\n+        $this->uri = new HTMLPurifier_AttrDef_URI(true); // embedded\n+        $this->wmode = new HTMLPurifier_AttrDef_Enum(array('window', 'opaque', 'transparent'));\n+    }\n+\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        // If we add support for other objects, we'll need to alter the\n+        // transforms.\n+        switch ($attr['name']) {\n+            // application/x-shockwave-flash\n+            // Keep this synchronized with Injector/SafeObject.php\n+            case 'allowScriptAccess':\n+                $attr['value'] = 'never';\n+                break;\n+            case 'allowNetworking':\n+                $attr['value'] = 'internal';\n+                break;\n+            case 'allowFullScreen':\n+                if ($config->get('HTML.FlashAllowFullScreen')) {\n+                    $attr['value'] = ($attr['value'] == 'true') ? 'true' : 'false';\n+                } else {\n+                    $attr['value'] = 'false';\n+                }\n+                break;\n+            case 'wmode':\n+                $attr['value'] = $this->wmode->validate($attr['value'], $config, $context);\n+                break;\n+            case 'movie':\n+            case 'src':\n+                $attr['name'] = \"movie\";\n+                $attr['value'] = $this->uri->validate($attr['value'], $config, $context);\n+                break;\n+            case 'flashvars':\n+                // we're going to allow arbitrary inputs to the SWF, on\n+                // the reasoning that it could only hack the SWF, not us.\n+                break;\n+            // add other cases to support other param name/value pairs\n+            default:\n+                $attr['name'] = $attr['value'] = null;\n+        }\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/ScriptRequired.php",
          "status": "added",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -0,0 +1,23 @@\n+<?php\n+\n+/**\n+ * Implements required attribute stipulation for <script>\n+ */\n+class HTMLPurifier_AttrTransform_ScriptRequired extends HTMLPurifier_AttrTransform\n+{\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        if (!isset($attr['type'])) {\n+            $attr['type'] = 'text/javascript';\n+        }\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/TargetBlank.php",
          "status": "added",
          "additions": 45,
          "deletions": 0,
          "patch": "@@ -0,0 +1,45 @@\n+<?php\n+\n+// must be called POST validation\n+\n+/**\n+ * Adds target=\"blank\" to all outbound links.  This transform is\n+ * only attached if Attr.TargetBlank is TRUE.  This works regardless\n+ * of whether or not Attr.AllowedFrameTargets\n+ */\n+class HTMLPurifier_AttrTransform_TargetBlank extends HTMLPurifier_AttrTransform\n+{\n+    /**\n+     * @type HTMLPurifier_URIParser\n+     */\n+    private $parser;\n+\n+    public function __construct()\n+    {\n+        $this->parser = new HTMLPurifier_URIParser();\n+    }\n+\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        if (!isset($attr['href'])) {\n+            return $attr;\n+        }\n+\n+        // XXX Kind of inefficient\n+        $url = $this->parser->parse($attr['href']);\n+        $scheme = $url->getSchemeObj($config, $context);\n+\n+        if ($scheme->browsable && !$url->isBenign($config, $context)) {\n+            $attr['target'] = '_blank';\n+        }\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/TargetNoreferrer.php",
          "status": "added",
          "additions": 37,
          "deletions": 0,
          "patch": "@@ -0,0 +1,37 @@\n+<?php\n+\n+// must be called POST validation\n+\n+/**\n+ * Adds rel=\"noreferrer\" to any links which target a different window\n+ * than the current one.  This is used to prevent malicious websites\n+ * from silently replacing the original window, which could be used\n+ * to do phishing.\n+ * This transform is controlled by %HTML.TargetNoreferrer.\n+ */\n+class HTMLPurifier_AttrTransform_TargetNoreferrer extends HTMLPurifier_AttrTransform\n+{\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        if (isset($attr['rel'])) {\n+            $rels = explode(' ', $attr['rel']);\n+        } else {\n+            $rels = array();\n+        }\n+        if (isset($attr['target']) && !in_array('noreferrer', $rels)) {\n+            $rels[] = 'noreferrer';\n+        }\n+        if (!empty($rels) || isset($attr['rel'])) {\n+            $attr['rel'] = implode(' ', $rels);\n+        }\n+\n+        return $attr;\n+    }\n+}\n+"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTransform/Textarea.php",
          "status": "added",
          "additions": 27,
          "deletions": 0,
          "patch": "@@ -0,0 +1,27 @@\n+<?php\n+\n+/**\n+ * Sets height/width defaults for <textarea>\n+ */\n+class HTMLPurifier_AttrTransform_Textarea extends HTMLPurifier_AttrTransform\n+{\n+    /**\n+     * @param array $attr\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function transform($attr, $config, $context)\n+    {\n+        // Calculated from Firefox\n+        if (!isset($attr['cols'])) {\n+            $attr['cols'] = '22';\n+        }\n+        if (!isset($attr['rows'])) {\n+            $attr['rows'] = '3';\n+        }\n+        return $attr;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrTypes.php",
          "status": "added",
          "additions": 96,
          "deletions": 0,
          "patch": "@@ -0,0 +1,96 @@\n+<?php\n+\n+/**\n+ * Provides lookup array of attribute types to HTMLPurifier_AttrDef objects\n+ */\n+class HTMLPurifier_AttrTypes\n+{\n+    /**\n+     * Lookup array of attribute string identifiers to concrete implementations.\n+     * @type HTMLPurifier_AttrDef[]\n+     */\n+    protected $info = array();\n+\n+    /**\n+     * Constructs the info array, supplying default implementations for attribute\n+     * types.\n+     */\n+    public function __construct()\n+    {\n+        // XXX This is kind of poor, since we don't actually /clone/\n+        // instances; instead, we use the supplied make() attribute. So,\n+        // the underlying class must know how to deal with arguments.\n+        // With the old implementation of Enum, that ignored its\n+        // arguments when handling a make dispatch, the IAlign\n+        // definition wouldn't work.\n+\n+        // pseudo-types, must be instantiated via shorthand\n+        $this->info['Enum']    = new HTMLPurifier_AttrDef_Enum();\n+        $this->info['Bool']    = new HTMLPurifier_AttrDef_HTML_Bool();\n+\n+        $this->info['CDATA']    = new HTMLPurifier_AttrDef_Text();\n+        $this->info['ID']       = new HTMLPurifier_AttrDef_HTML_ID();\n+        $this->info['Length']   = new HTMLPurifier_AttrDef_HTML_Length();\n+        $this->info['MultiLength'] = new HTMLPurifier_AttrDef_HTML_MultiLength();\n+        $this->info['NMTOKENS'] = new HTMLPurifier_AttrDef_HTML_Nmtokens();\n+        $this->info['Pixels']   = new HTMLPurifier_AttrDef_HTML_Pixels();\n+        $this->info['Text']     = new HTMLPurifier_AttrDef_Text();\n+        $this->info['URI']      = new HTMLPurifier_AttrDef_URI();\n+        $this->info['LanguageCode'] = new HTMLPurifier_AttrDef_Lang();\n+        $this->info['Color']    = new HTMLPurifier_AttrDef_HTML_Color();\n+        $this->info['IAlign']   = self::makeEnum('top,middle,bottom,left,right');\n+        $this->info['LAlign']   = self::makeEnum('top,bottom,left,right');\n+        $this->info['FrameTarget'] = new HTMLPurifier_AttrDef_HTML_FrameTarget();\n+\n+        // unimplemented aliases\n+        $this->info['ContentType'] = new HTMLPurifier_AttrDef_Text();\n+        $this->info['ContentTypes'] = new HTMLPurifier_AttrDef_Text();\n+        $this->info['Charsets'] = new HTMLPurifier_AttrDef_Text();\n+        $this->info['Character'] = new HTMLPurifier_AttrDef_Text();\n+\n+        // \"proprietary\" types\n+        $this->info['Class'] = new HTMLPurifier_AttrDef_HTML_Class();\n+\n+        // number is really a positive integer (one or more digits)\n+        // FIXME: ^^ not always, see start and value of list items\n+        $this->info['Number']   = new HTMLPurifier_AttrDef_Integer(false, false, true);\n+    }\n+\n+    private static function makeEnum($in)\n+    {\n+        return new HTMLPurifier_AttrDef_Clone(new HTMLPurifier_AttrDef_Enum(explode(',', $in)));\n+    }\n+\n+    /**\n+     * Retrieves a type\n+     * @param string $type String type name\n+     * @return HTMLPurifier_AttrDef Object AttrDef for type\n+     */\n+    public function get($type)\n+    {\n+        // determine if there is any extra info tacked on\n+        if (strpos($type, '#') !== false) {\n+            list($type, $string) = explode('#', $type, 2);\n+        } else {\n+            $string = '';\n+        }\n+\n+        if (!isset($this->info[$type])) {\n+            trigger_error('Cannot retrieve undefined attribute type ' . $type, E_USER_ERROR);\n+            return;\n+        }\n+        return $this->info[$type]->make($string);\n+    }\n+\n+    /**\n+     * Sets a new implementation for a type\n+     * @param string $type String type name\n+     * @param HTMLPurifier_AttrDef $impl Object AttrDef for type\n+     */\n+    public function set($type, $impl)\n+    {\n+        $this->info[$type] = $impl;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/AttrValidator.php",
          "status": "added",
          "additions": 178,
          "deletions": 0,
          "patch": "@@ -0,0 +1,178 @@\n+<?php\n+\n+/**\n+ * Validates the attributes of a token. Doesn't manage required attributes\n+ * very well. The only reason we factored this out was because RemoveForeignElements\n+ * also needed it besides ValidateAttributes.\n+ */\n+class HTMLPurifier_AttrValidator\n+{\n+\n+    /**\n+     * Validates the attributes of a token, mutating it as necessary.\n+     * that has valid tokens\n+     * @param HTMLPurifier_Token $token Token to validate.\n+     * @param HTMLPurifier_Config $config Instance of HTMLPurifier_Config\n+     * @param HTMLPurifier_Context $context Instance of HTMLPurifier_Context\n+     */\n+    public function validateToken($token, $config, $context)\n+    {\n+        $definition = $config->getHTMLDefinition();\n+        $e =& $context->get('ErrorCollector', true);\n+\n+        // initialize IDAccumulator if necessary\n+        $ok =& $context->get('IDAccumulator', true);\n+        if (!$ok) {\n+            $id_accumulator = HTMLPurifier_IDAccumulator::build($config, $context);\n+            $context->register('IDAccumulator', $id_accumulator);\n+        }\n+\n+        // initialize CurrentToken if necessary\n+        $current_token =& $context->get('CurrentToken', true);\n+        if (!$current_token) {\n+            $context->register('CurrentToken', $token);\n+        }\n+\n+        if (!$token instanceof HTMLPurifier_Token_Start &&\n+            !$token instanceof HTMLPurifier_Token_Empty\n+        ) {\n+            return;\n+        }\n+\n+        // create alias to global definition array, see also $defs\n+        // DEFINITION CALL\n+        $d_defs = $definition->info_global_attr;\n+\n+        // don't update token until the very end, to ensure an atomic update\n+        $attr = $token->attr;\n+\n+        // do global transformations (pre)\n+        // nothing currently utilizes this\n+        foreach ($definition->info_attr_transform_pre as $transform) {\n+            $attr = $transform->transform($o = $attr, $config, $context);\n+            if ($e) {\n+                if ($attr != $o) {\n+                    $e->send(E_NOTICE, 'AttrValidator: Attributes transformed', $o, $attr);\n+                }\n+            }\n+        }\n+\n+        // do local transformations only applicable to this element (pre)\n+        // ex. <p align=\"right\"> to <p style=\"text-align:right;\">\n+        foreach ($definition->info[$token->name]->attr_transform_pre as $transform) {\n+            $attr = $transform->transform($o = $attr, $config, $context);\n+            if ($e) {\n+                if ($attr != $o) {\n+                    $e->send(E_NOTICE, 'AttrValidator: Attributes transformed', $o, $attr);\n+                }\n+            }\n+        }\n+\n+        // create alias to this element's attribute definition array, see\n+        // also $d_defs (global attribute definition array)\n+        // DEFINITION CALL\n+        $defs = $definition->info[$token->name]->attr;\n+\n+        $attr_key = false;\n+        $context->register('CurrentAttr', $attr_key);\n+\n+        // iterate through all the attribute keypairs\n+        // Watch out for name collisions: $key has previously been used\n+        foreach ($attr as $attr_key => $value) {\n+\n+            // call the definition\n+            if (isset($defs[$attr_key])) {\n+                // there is a local definition defined\n+                if ($defs[$attr_key] === false) {\n+                    // We've explicitly been told not to allow this element.\n+                    // This is usually when there's a global definition\n+                    // that must be overridden.\n+                    // Theoretically speaking, we could have a\n+                    // AttrDef_DenyAll, but this is faster!\n+                    $result = false;\n+                } else {\n+                    // validate according to the element's definition\n+                    $result = $defs[$attr_key]->validate(\n+                        $value,\n+                        $config,\n+                        $context\n+                    );\n+                }\n+            } elseif (isset($d_defs[$attr_key])) {\n+                // there is a global definition defined, validate according\n+                // to the global definition\n+                $result = $d_defs[$attr_key]->validate(\n+                    $value,\n+                    $config,\n+                    $context\n+                );\n+            } else {\n+                // system never heard of the attribute? DELETE!\n+                $result = false;\n+            }\n+\n+            // put the results into effect\n+            if ($result === false || $result === null) {\n+                // this is a generic error message that should replaced\n+                // with more specific ones when possible\n+                if ($e) {\n+                    $e->send(E_ERROR, 'AttrValidator: Attribute removed');\n+                }\n+\n+                // remove the attribute\n+                unset($attr[$attr_key]);\n+            } elseif (is_string($result)) {\n+                // generally, if a substitution is happening, there\n+                // was some sort of implicit correction going on. We'll\n+                // delegate it to the attribute classes to say exactly what.\n+\n+                // simple substitution\n+                $attr[$attr_key] = $result;\n+            } else {\n+                // nothing happens\n+            }\n+\n+            // we'd also want slightly more complicated substitution\n+            // involving an array as the return value,\n+            // although we're not sure how colliding attributes would\n+            // resolve (certain ones would be completely overriden,\n+            // others would prepend themselves).\n+        }\n+\n+        $context->destroy('CurrentAttr');\n+\n+        // post transforms\n+\n+        // global (error reporting untested)\n+        foreach ($definition->info_attr_transform_post as $transform) {\n+            $attr = $transform->transform($o = $attr, $config, $context);\n+            if ($e) {\n+                if ($attr != $o) {\n+                    $e->send(E_NOTICE, 'AttrValidator: Attributes transformed', $o, $attr);\n+                }\n+            }\n+        }\n+\n+        // local (error reporting untested)\n+        foreach ($definition->info[$token->name]->attr_transform_post as $transform) {\n+            $attr = $transform->transform($o = $attr, $config, $context);\n+            if ($e) {\n+                if ($attr != $o) {\n+                    $e->send(E_NOTICE, 'AttrValidator: Attributes transformed', $o, $attr);\n+                }\n+            }\n+        }\n+\n+        $token->attr = $attr;\n+\n+        // destroy CurrentToken if we made it ourselves\n+        if (!$current_token) {\n+            $context->destroy('CurrentToken');\n+        }\n+\n+    }\n+\n+\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Bootstrap.php",
          "status": "added",
          "additions": 124,
          "deletions": 0,
          "patch": "@@ -0,0 +1,124 @@\n+<?php\n+\n+// constants are slow, so we use as few as possible\n+if (!defined('HTMLPURIFIER_PREFIX')) {\n+    define('HTMLPURIFIER_PREFIX', realpath(dirname(__FILE__) . '/..'));\n+}\n+\n+// accomodations for versions earlier than 5.0.2\n+// borrowed from PHP_Compat, LGPL licensed, by Aidan Lister <aidan@php.net>\n+if (!defined('PHP_EOL')) {\n+    switch (strtoupper(substr(PHP_OS, 0, 3))) {\n+        case 'WIN':\n+            define('PHP_EOL', \"\\r\\n\");\n+            break;\n+        case 'DAR':\n+            define('PHP_EOL', \"\\r\");\n+            break;\n+        default:\n+            define('PHP_EOL', \"\\n\");\n+    }\n+}\n+\n+/**\n+ * Bootstrap class that contains meta-functionality for HTML Purifier such as\n+ * the autoload function.\n+ *\n+ * @note\n+ *      This class may be used without any other files from HTML Purifier.\n+ */\n+class HTMLPurifier_Bootstrap\n+{\n+\n+    /**\n+     * Autoload function for HTML Purifier\n+     * @param string $class Class to load\n+     * @return bool\n+     */\n+    public static function autoload($class)\n+    {\n+        $file = HTMLPurifier_Bootstrap::getPath($class);\n+        if (!$file) {\n+            return false;\n+        }\n+        // Technically speaking, it should be ok and more efficient to\n+        // just do 'require', but Antonio Parraga reports that with\n+        // Zend extensions such as Zend debugger and APC, this invariant\n+        // may be broken.  Since we have efficient alternatives, pay\n+        // the cost here and avoid the bug.\n+        require_once HTMLPURIFIER_PREFIX . '/' . $file;\n+        return true;\n+    }\n+\n+    /**\n+     * Returns the path for a specific class.\n+     * @param string $class Class path to get\n+     * @return string\n+     */\n+    public static function getPath($class)\n+    {\n+        if (strncmp('HTMLPurifier', $class, 12) !== 0) {\n+            return false;\n+        }\n+        // Custom implementations\n+        if (strncmp('HTMLPurifier_Language_', $class, 22) === 0) {\n+            $code = str_replace('_', '-', substr($class, 22));\n+            $file = 'HTMLPurifier/Language/classes/' . $code . '.php';\n+        } else {\n+            $file = str_replace('_', '/', $class) . '.php';\n+        }\n+        if (!file_exists(HTMLPURIFIER_PREFIX . '/' . $file)) {\n+            return false;\n+        }\n+        return $file;\n+    }\n+\n+    /**\n+     * \"Pre-registers\" our autoloader on the SPL stack.\n+     */\n+    public static function registerAutoload()\n+    {\n+        $autoload = array('HTMLPurifier_Bootstrap', 'autoload');\n+        if (($funcs = spl_autoload_functions()) === false) {\n+            spl_autoload_register($autoload);\n+        } elseif (function_exists('spl_autoload_unregister')) {\n+            if (version_compare(PHP_VERSION, '5.3.0', '>=')) {\n+                // prepend flag exists, no need for shenanigans\n+                spl_autoload_register($autoload, true, true);\n+            } else {\n+                $buggy  = version_compare(PHP_VERSION, '5.2.11', '<');\n+                $compat = version_compare(PHP_VERSION, '5.1.2', '<=') &&\n+                          version_compare(PHP_VERSION, '5.1.0', '>=');\n+                foreach ($funcs as $func) {\n+                    if ($buggy && is_array($func)) {\n+                        // :TRICKY: There are some compatibility issues and some\n+                        // places where we need to error out\n+                        $reflector = new ReflectionMethod($func[0], $func[1]);\n+                        if (!$reflector->isStatic()) {\n+                            throw new Exception(\n+                                'HTML Purifier autoloader registrar is not compatible\n+                                with non-static object methods due to PHP Bug #44144;\n+                                Please do not use HTMLPurifier.autoload.php (or any\n+                                file that includes this file); instead, place the code:\n+                                spl_autoload_register(array(\\'HTMLPurifier_Bootstrap\\', \\'autoload\\'))\n+                                after your own autoloaders.'\n+                            );\n+                        }\n+                        // Suprisingly, spl_autoload_register supports the\n+                        // Class::staticMethod callback format, although call_user_func doesn't\n+                        if ($compat) {\n+                            $func = implode('::', $func);\n+                        }\n+                    }\n+                    spl_autoload_unregister($func);\n+                }\n+                spl_autoload_register($autoload);\n+                foreach ($funcs as $func) {\n+                    spl_autoload_register($func);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/CSSDefinition.php",
          "status": "added",
          "additions": 487,
          "deletions": 0,
          "patch": "@@ -0,0 +1,487 @@\n+<?php\n+\n+/**\n+ * Defines allowed CSS attributes and what their values are.\n+ * @see HTMLPurifier_HTMLDefinition\n+ */\n+class HTMLPurifier_CSSDefinition extends HTMLPurifier_Definition\n+{\n+\n+    public $type = 'CSS';\n+\n+    /**\n+     * Assoc array of attribute name to definition object.\n+     * @type HTMLPurifier_AttrDef[]\n+     */\n+    public $info = array();\n+\n+    /**\n+     * Constructs the info array.  The meat of this class.\n+     * @param HTMLPurifier_Config $config\n+     */\n+    protected function doSetup($config)\n+    {\n+        $this->info['text-align'] = new HTMLPurifier_AttrDef_Enum(\n+            array('left', 'right', 'center', 'justify'),\n+            false\n+        );\n+\n+        $border_style =\n+            $this->info['border-bottom-style'] =\n+            $this->info['border-right-style'] =\n+            $this->info['border-left-style'] =\n+            $this->info['border-top-style'] = new HTMLPurifier_AttrDef_Enum(\n+                array(\n+                    'none',\n+                    'hidden',\n+                    'dotted',\n+                    'dashed',\n+                    'solid',\n+                    'double',\n+                    'groove',\n+                    'ridge',\n+                    'inset',\n+                    'outset'\n+                ),\n+                false\n+            );\n+\n+        $this->info['border-style'] = new HTMLPurifier_AttrDef_CSS_Multiple($border_style);\n+\n+        $this->info['clear'] = new HTMLPurifier_AttrDef_Enum(\n+            array('none', 'left', 'right', 'both'),\n+            false\n+        );\n+        $this->info['float'] = new HTMLPurifier_AttrDef_Enum(\n+            array('none', 'left', 'right'),\n+            false\n+        );\n+        $this->info['font-style'] = new HTMLPurifier_AttrDef_Enum(\n+            array('normal', 'italic', 'oblique'),\n+            false\n+        );\n+        $this->info['font-variant'] = new HTMLPurifier_AttrDef_Enum(\n+            array('normal', 'small-caps'),\n+            false\n+        );\n+\n+        $uri_or_none = new HTMLPurifier_AttrDef_CSS_Composite(\n+            array(\n+                new HTMLPurifier_AttrDef_Enum(array('none')),\n+                new HTMLPurifier_AttrDef_CSS_URI()\n+            )\n+        );\n+\n+        $this->info['list-style-position'] = new HTMLPurifier_AttrDef_Enum(\n+            array('inside', 'outside'),\n+            false\n+        );\n+        $this->info['list-style-type'] = new HTMLPurifier_AttrDef_Enum(\n+            array(\n+                'disc',\n+                'circle',\n+                'square',\n+                'decimal',\n+                'lower-roman',\n+                'upper-roman',\n+                'lower-alpha',\n+                'upper-alpha',\n+                'none'\n+            ),\n+            false\n+        );\n+        $this->info['list-style-image'] = $uri_or_none;\n+\n+        $this->info['list-style'] = new HTMLPurifier_AttrDef_CSS_ListStyle($config);\n+\n+        $this->info['text-transform'] = new HTMLPurifier_AttrDef_Enum(\n+            array('capitalize', 'uppercase', 'lowercase', 'none'),\n+            false\n+        );\n+        $this->info['color'] = new HTMLPurifier_AttrDef_CSS_Color();\n+\n+        $this->info['background-image'] = $uri_or_none;\n+        $this->info['background-repeat'] = new HTMLPurifier_AttrDef_Enum(\n+            array('repeat', 'repeat-x', 'repeat-y', 'no-repeat')\n+        );\n+        $this->info['background-attachment'] = new HTMLPurifier_AttrDef_Enum(\n+            array('scroll', 'fixed')\n+        );\n+        $this->info['background-position'] = new HTMLPurifier_AttrDef_CSS_BackgroundPosition();\n+\n+        $border_color =\n+            $this->info['border-top-color'] =\n+            $this->info['border-bottom-color'] =\n+            $this->info['border-left-color'] =\n+            $this->info['border-right-color'] =\n+            $this->info['background-color'] = new HTMLPurifier_AttrDef_CSS_Composite(\n+                array(\n+                    new HTMLPurifier_AttrDef_Enum(array('transparent')),\n+                    new HTMLPurifier_AttrDef_CSS_Color()\n+                )\n+            );\n+\n+        $this->info['background'] = new HTMLPurifier_AttrDef_CSS_Background($config);\n+\n+        $this->info['border-color'] = new HTMLPurifier_AttrDef_CSS_Multiple($border_color);\n+\n+        $border_width =\n+            $this->info['border-top-width'] =\n+            $this->info['border-bottom-width'] =\n+            $this->info['border-left-width'] =\n+            $this->info['border-right-width'] = new HTMLPurifier_AttrDef_CSS_Composite(\n+                array(\n+                    new HTMLPurifier_AttrDef_Enum(array('thin', 'medium', 'thick')),\n+                    new HTMLPurifier_AttrDef_CSS_Length('0') //disallow negative\n+                )\n+            );\n+\n+        $this->info['border-width'] = new HTMLPurifier_AttrDef_CSS_Multiple($border_width);\n+\n+        $this->info['letter-spacing'] = new HTMLPurifier_AttrDef_CSS_Composite(\n+            array(\n+                new HTMLPurifier_AttrDef_Enum(array('normal')),\n+                new HTMLPurifier_AttrDef_CSS_Length()\n+            )\n+        );\n+\n+        $this->info['word-spacing'] = new HTMLPurifier_AttrDef_CSS_Composite(\n+            array(\n+                new HTMLPurifier_AttrDef_Enum(array('normal')),\n+                new HTMLPurifier_AttrDef_CSS_Length()\n+            )\n+        );\n+\n+        $this->info['font-size'] = new HTMLPurifier_AttrDef_CSS_Composite(\n+            array(\n+                new HTMLPurifier_AttrDef_Enum(\n+                    array(\n+                        'xx-small',\n+                        'x-small',\n+                        'small',\n+                        'medium',\n+                        'large',\n+                        'x-large',\n+                        'xx-large',\n+                        'larger',\n+                        'smaller'\n+                    )\n+                ),\n+                new HTMLPurifier_AttrDef_CSS_Percentage(),\n+                new HTMLPurifier_AttrDef_CSS_Length()\n+            )\n+        );\n+\n+        $this->info['line-height'] = new HTMLPurifier_AttrDef_CSS_Composite(\n+            array(\n+                new HTMLPurifier_AttrDef_Enum(array('normal')),\n+                new HTMLPurifier_AttrDef_CSS_Number(true), // no negatives\n+                new HTMLPurifier_AttrDef_CSS_Length('0'),\n+                new HTMLPurifier_AttrDef_CSS_Percentage(true)\n+            )\n+        );\n+\n+        $margin =\n+            $this->info['margin-top'] =\n+            $this->info['margin-bottom'] =\n+            $this->info['margin-left'] =\n+            $this->info['margin-right'] = new HTMLPurifier_AttrDef_CSS_Composite(\n+                array(\n+                    new HTMLPurifier_AttrDef_CSS_Length(),\n+                    new HTMLPurifier_AttrDef_CSS_Percentage(),\n+                    new HTMLPurifier_AttrDef_Enum(array('auto'))\n+                )\n+            );\n+\n+        $this->info['margin'] = new HTMLPurifier_AttrDef_CSS_Multiple($margin);\n+\n+        // non-negative\n+        $padding =\n+            $this->info['padding-top'] =\n+            $this->info['padding-bottom'] =\n+            $this->info['padding-left'] =\n+            $this->info['padding-right'] = new HTMLPurifier_AttrDef_CSS_Composite(\n+                array(\n+                    new HTMLPurifier_AttrDef_CSS_Length('0'),\n+                    new HTMLPurifier_AttrDef_CSS_Percentage(true)\n+                )\n+            );\n+\n+        $this->info['padding'] = new HTMLPurifier_AttrDef_CSS_Multiple($padding);\n+\n+        $this->info['text-indent'] = new HTMLPurifier_AttrDef_CSS_Composite(\n+            array(\n+                new HTMLPurifier_AttrDef_CSS_Length(),\n+                new HTMLPurifier_AttrDef_CSS_Percentage()\n+            )\n+        );\n+\n+        $trusted_wh = new HTMLPurifier_AttrDef_CSS_Composite(\n+            array(\n+                new HTMLPurifier_AttrDef_CSS_Length('0'),\n+                new HTMLPurifier_AttrDef_CSS_Percentage(true),\n+                new HTMLPurifier_AttrDef_Enum(array('auto'))\n+            )\n+        );\n+        $max = $config->get('CSS.MaxImgLength');\n+\n+        $this->info['width'] =\n+        $this->info['height'] =\n+            $max === null ?\n+                $trusted_wh :\n+                new HTMLPurifier_AttrDef_Switch(\n+                    'img',\n+                    // For img tags:\n+                    new HTMLPurifier_AttrDef_CSS_Composite(\n+                        array(\n+                            new HTMLPurifier_AttrDef_CSS_Length('0', $max),\n+                            new HTMLPurifier_AttrDef_Enum(array('auto'))\n+                        )\n+                    ),\n+                    // For everyone else:\n+                    $trusted_wh\n+                );\n+\n+        $this->info['text-decoration'] = new HTMLPurifier_AttrDef_CSS_TextDecoration();\n+\n+        $this->info['font-family'] = new HTMLPurifier_AttrDef_CSS_FontFamily();\n+\n+        // this could use specialized code\n+        $this->info['font-weight'] = new HTMLPurifier_AttrDef_Enum(\n+            array(\n+                'normal',\n+                'bold',\n+                'bolder',\n+                'lighter',\n+                '100',\n+                '200',\n+                '300',\n+                '400',\n+                '500',\n+                '600',\n+                '700',\n+                '800',\n+                '900'\n+            ),\n+            false\n+        );\n+\n+        // MUST be called after other font properties, as it references\n+        // a CSSDefinition object\n+        $this->info['font'] = new HTMLPurifier_AttrDef_CSS_Font($config);\n+\n+        // same here\n+        $this->info['border'] =\n+        $this->info['border-bottom'] =\n+        $this->info['border-top'] =\n+        $this->info['border-left'] =\n+        $this->info['border-right'] = new HTMLPurifier_AttrDef_CSS_Border($config);\n+\n+        $this->info['border-collapse'] = new HTMLPurifier_AttrDef_Enum(\n+            array('collapse', 'separate')\n+        );\n+\n+        $this->info['caption-side'] = new HTMLPurifier_AttrDef_Enum(\n+            array('top', 'bottom')\n+        );\n+\n+        $this->info['table-layout'] = new HTMLPurifier_AttrDef_Enum(\n+            array('auto', 'fixed')\n+        );\n+\n+        $this->info['vertical-align'] = new HTMLPurifier_AttrDef_CSS_Composite(\n+            array(\n+                new HTMLPurifier_AttrDef_Enum(\n+                    array(\n+                        'baseline',\n+                        'sub',\n+                        'super',\n+                        'top',\n+                        'text-top',\n+                        'middle',\n+                        'bottom',\n+                        'text-bottom'\n+                    )\n+                ),\n+                new HTMLPurifier_AttrDef_CSS_Length(),\n+                new HTMLPurifier_AttrDef_CSS_Percentage()\n+            )\n+        );\n+\n+        $this->info['border-spacing'] = new HTMLPurifier_AttrDef_CSS_Multiple(new HTMLPurifier_AttrDef_CSS_Length(), 2);\n+\n+        // These CSS properties don't work on many browsers, but we live\n+        // in THE FUTURE!\n+        $this->info['white-space'] = new HTMLPurifier_AttrDef_Enum(\n+            array('nowrap', 'normal', 'pre', 'pre-wrap', 'pre-line')\n+        );\n+\n+        if ($config->get('CSS.Proprietary')) {\n+            $this->doSetupProprietary($config);\n+        }\n+\n+        if ($config->get('CSS.AllowTricky')) {\n+            $this->doSetupTricky($config);\n+        }\n+\n+        if ($config->get('CSS.Trusted')) {\n+            $this->doSetupTrusted($config);\n+        }\n+\n+        $allow_important = $config->get('CSS.AllowImportant');\n+        // wrap all attr-defs with decorator that handles !important\n+        foreach ($this->info as $k => $v) {\n+            $this->info[$k] = new HTMLPurifier_AttrDef_CSS_ImportantDecorator($v, $allow_important);\n+        }\n+\n+        $this->setupConfigStuff($config);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    protected function doSetupProprietary($config)\n+    {\n+        // Internet Explorer only scrollbar colors\n+        $this->info['scrollbar-arrow-color'] = new HTMLPurifier_AttrDef_CSS_Color();\n+        $this->info['scrollbar-base-color'] = new HTMLPurifier_AttrDef_CSS_Color();\n+        $this->info['scrollbar-darkshadow-color'] = new HTMLPurifier_AttrDef_CSS_Color();\n+        $this->info['scrollbar-face-color'] = new HTMLPurifier_AttrDef_CSS_Color();\n+        $this->info['scrollbar-highlight-color'] = new HTMLPurifier_AttrDef_CSS_Color();\n+        $this->info['scrollbar-shadow-color'] = new HTMLPurifier_AttrDef_CSS_Color();\n+\n+        // vendor specific prefixes of opacity\n+        $this->info['-moz-opacity'] = new HTMLPurifier_AttrDef_CSS_AlphaValue();\n+        $this->info['-khtml-opacity'] = new HTMLPurifier_AttrDef_CSS_AlphaValue();\n+\n+        // only opacity, for now\n+        $this->info['filter'] = new HTMLPurifier_AttrDef_CSS_Filter();\n+\n+        // more CSS3\n+        $this->info['page-break-after'] =\n+        $this->info['page-break-before'] = new HTMLPurifier_AttrDef_Enum(\n+            array(\n+                'auto',\n+                'always',\n+                'avoid',\n+                'left',\n+                'right'\n+            )\n+        );\n+        $this->info['page-break-inside'] = new HTMLPurifier_AttrDef_Enum(array('auto', 'avoid'));\n+\n+        $border_radius = new HTMLPurifier_AttrDef_CSS_Composite(\n+            array(\n+                new HTMLPurifier_AttrDef_CSS_Percentage(true), // disallow negative\n+                new HTMLPurifier_AttrDef_CSS_Length('0') // disallow negative\n+            ));\n+\n+        $this->info['border-top-left-radius'] =\n+        $this->info['border-top-right-radius'] =\n+        $this->info['border-bottom-right-radius'] =\n+        $this->info['border-bottom-left-radius'] = new HTMLPurifier_AttrDef_CSS_Multiple($border_radius, 2);\n+        // TODO: support SLASH syntax\n+        $this->info['border-radius'] = new HTMLPurifier_AttrDef_CSS_Multiple($border_radius, 4);\n+\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    protected function doSetupTricky($config)\n+    {\n+        $this->info['display'] = new HTMLPurifier_AttrDef_Enum(\n+            array(\n+                'inline',\n+                'block',\n+                'list-item',\n+                'run-in',\n+                'compact',\n+                'marker',\n+                'table',\n+                'inline-block',\n+                'inline-table',\n+                'table-row-group',\n+                'table-header-group',\n+                'table-footer-group',\n+                'table-row',\n+                'table-column-group',\n+                'table-column',\n+                'table-cell',\n+                'table-caption',\n+                'none'\n+            )\n+        );\n+        $this->info['visibility'] = new HTMLPurifier_AttrDef_Enum(\n+            array('visible', 'hidden', 'collapse')\n+        );\n+        $this->info['overflow'] = new HTMLPurifier_AttrDef_Enum(array('visible', 'hidden', 'auto', 'scroll'));\n+        $this->info['opacity'] = new HTMLPurifier_AttrDef_CSS_AlphaValue();\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    protected function doSetupTrusted($config)\n+    {\n+        $this->info['position'] = new HTMLPurifier_AttrDef_Enum(\n+            array('static', 'relative', 'absolute', 'fixed')\n+        );\n+        $this->info['top'] =\n+        $this->info['left'] =\n+        $this->info['right'] =\n+        $this->info['bottom'] = new HTMLPurifier_AttrDef_CSS_Composite(\n+            array(\n+                new HTMLPurifier_AttrDef_CSS_Length(),\n+                new HTMLPurifier_AttrDef_CSS_Percentage(),\n+                new HTMLPurifier_AttrDef_Enum(array('auto')),\n+            )\n+        );\n+        $this->info['z-index'] = new HTMLPurifier_AttrDef_CSS_Composite(\n+            array(\n+                new HTMLPurifier_AttrDef_Integer(),\n+                new HTMLPurifier_AttrDef_Enum(array('auto')),\n+            )\n+        );\n+    }\n+\n+    /**\n+     * Performs extra config-based processing. Based off of\n+     * HTMLPurifier_HTMLDefinition.\n+     * @param HTMLPurifier_Config $config\n+     * @todo Refactor duplicate elements into common class (probably using\n+     *       composition, not inheritance).\n+     */\n+    protected function setupConfigStuff($config)\n+    {\n+        // setup allowed elements\n+        $support = \"(for information on implementing this, see the \" .\n+            \"support forums) \";\n+        $allowed_properties = $config->get('CSS.AllowedProperties');\n+        if ($allowed_properties !== null) {\n+            foreach ($this->info as $name => $d) {\n+                if (!isset($allowed_properties[$name])) {\n+                    unset($this->info[$name]);\n+                }\n+                unset($allowed_properties[$name]);\n+            }\n+            // emit errors\n+            foreach ($allowed_properties as $name => $d) {\n+                // :TODO: Is this htmlspecialchars() call really necessary?\n+                $name = htmlspecialchars($name);\n+                trigger_error(\"Style attribute '$name' is not supported $support\", E_USER_WARNING);\n+            }\n+        }\n+\n+        $forbidden_properties = $config->get('CSS.ForbiddenProperties');\n+        if ($forbidden_properties !== null) {\n+            foreach ($this->info as $name => $d) {\n+                if (isset($forbidden_properties[$name])) {\n+                    unset($this->info[$name]);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ChildDef.php",
          "status": "added",
          "additions": 52,
          "deletions": 0,
          "patch": "@@ -0,0 +1,52 @@\n+<?php\n+\n+/**\n+ * Defines allowed child nodes and validates nodes against it.\n+ */\n+abstract class HTMLPurifier_ChildDef\n+{\n+    /**\n+     * Type of child definition, usually right-most part of class name lowercase.\n+     * Used occasionally in terms of context.\n+     * @type string\n+     */\n+    public $type;\n+\n+    /**\n+     * Indicates whether or not an empty array of children is okay.\n+     *\n+     * This is necessary for redundant checking when changes affecting\n+     * a child node may cause a parent node to now be disallowed.\n+     * @type bool\n+     */\n+    public $allow_empty;\n+\n+    /**\n+     * Lookup array of all elements that this definition could possibly allow.\n+     * @type array\n+     */\n+    public $elements = array();\n+\n+    /**\n+     * Get lookup of tag names that should not close this element automatically.\n+     * All other elements will do so.\n+     * @param HTMLPurifier_Config $config HTMLPurifier_Config object\n+     * @return array\n+     */\n+    public function getAllowedElements($config)\n+    {\n+        return $this->elements;\n+    }\n+\n+    /**\n+     * Validates nodes according to definition and returns modification.\n+     *\n+     * @param HTMLPurifier_Node[] $children Array of HTMLPurifier_Node\n+     * @param HTMLPurifier_Config $config HTMLPurifier_Config object\n+     * @param HTMLPurifier_Context $context HTMLPurifier_Context object\n+     * @return bool|array true to leave nodes as is, false to remove parent node, array of replacement children\n+     */\n+    abstract public function validateChildren($children, $config, $context);\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ChildDef/Chameleon.php",
          "status": "added",
          "additions": 67,
          "deletions": 0,
          "patch": "@@ -0,0 +1,67 @@\n+<?php\n+\n+/**\n+ * Definition that uses different definitions depending on context.\n+ *\n+ * The del and ins tags are notable because they allow different types of\n+ * elements depending on whether or not they're in a block or inline context.\n+ * Chameleon allows this behavior to happen by using two different\n+ * definitions depending on context.  While this somewhat generalized,\n+ * it is specifically intended for those two tags.\n+ */\n+class HTMLPurifier_ChildDef_Chameleon extends HTMLPurifier_ChildDef\n+{\n+\n+    /**\n+     * Instance of the definition object to use when inline. Usually stricter.\n+     * @type HTMLPurifier_ChildDef_Optional\n+     */\n+    public $inline;\n+\n+    /**\n+     * Instance of the definition object to use when block.\n+     * @type HTMLPurifier_ChildDef_Optional\n+     */\n+    public $block;\n+\n+    /**\n+     * @type string\n+     */\n+    public $type = 'chameleon';\n+\n+    /**\n+     * @param array $inline List of elements to allow when inline.\n+     * @param array $block List of elements to allow when block.\n+     */\n+    public function __construct($inline, $block)\n+    {\n+        $this->inline = new HTMLPurifier_ChildDef_Optional($inline);\n+        $this->block = new HTMLPurifier_ChildDef_Optional($block);\n+        $this->elements = $this->block->elements;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Node[] $children\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool\n+     */\n+    public function validateChildren($children, $config, $context)\n+    {\n+        if ($context->get('IsInline') === false) {\n+            return $this->block->validateChildren(\n+                $children,\n+                $config,\n+                $context\n+            );\n+        } else {\n+            return $this->inline->validateChildren(\n+                $children,\n+                $config,\n+                $context\n+            );\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ChildDef/Custom.php",
          "status": "added",
          "additions": 102,
          "deletions": 0,
          "patch": "@@ -0,0 +1,102 @@\n+<?php\n+\n+/**\n+ * Custom validation class, accepts DTD child definitions\n+ *\n+ * @warning Currently this class is an all or nothing proposition, that is,\n+ *          it will only give a bool return value.\n+ */\n+class HTMLPurifier_ChildDef_Custom extends HTMLPurifier_ChildDef\n+{\n+    /**\n+     * @type string\n+     */\n+    public $type = 'custom';\n+\n+    /**\n+     * @type bool\n+     */\n+    public $allow_empty = false;\n+\n+    /**\n+     * Allowed child pattern as defined by the DTD.\n+     * @type string\n+     */\n+    public $dtd_regex;\n+\n+    /**\n+     * PCRE regex derived from $dtd_regex.\n+     * @type string\n+     */\n+    private $_pcre_regex;\n+\n+    /**\n+     * @param $dtd_regex Allowed child pattern from the DTD\n+     */\n+    public function __construct($dtd_regex)\n+    {\n+        $this->dtd_regex = $dtd_regex;\n+        $this->_compileRegex();\n+    }\n+\n+    /**\n+     * Compiles the PCRE regex from a DTD regex ($dtd_regex to $_pcre_regex)\n+     */\n+    protected function _compileRegex()\n+    {\n+        $raw = str_replace(' ', '', $this->dtd_regex);\n+        if ($raw{0} != '(') {\n+            $raw = \"($raw)\";\n+        }\n+        $el = '[#a-zA-Z0-9_.-]+';\n+        $reg = $raw;\n+\n+        // COMPLICATED! AND MIGHT BE BUGGY! I HAVE NO CLUE WHAT I'M\n+        // DOING! Seriously: if there's problems, please report them.\n+\n+        // collect all elements into the $elements array\n+        preg_match_all(\"/$el/\", $reg, $matches);\n+        foreach ($matches[0] as $match) {\n+            $this->elements[$match] = true;\n+        }\n+\n+        // setup all elements as parentheticals with leading commas\n+        $reg = preg_replace(\"/$el/\", '(,\\\\0)', $reg);\n+\n+        // remove commas when they were not solicited\n+        $reg = preg_replace(\"/([^,(|]\\(+),/\", '\\\\1', $reg);\n+\n+        // remove all non-paranthetical commas: they are handled by first regex\n+        $reg = preg_replace(\"/,\\(/\", '(', $reg);\n+\n+        $this->_pcre_regex = $reg;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Node[] $children\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool\n+     */\n+    public function validateChildren($children, $config, $context)\n+    {\n+        $list_of_children = '';\n+        $nesting = 0; // depth into the nest\n+        foreach ($children as $node) {\n+            if (!empty($node->is_whitespace)) {\n+                continue;\n+            }\n+            $list_of_children .= $node->name . ',';\n+        }\n+        // add leading comma to deal with stray comma declarations\n+        $list_of_children = ',' . rtrim($list_of_children, ',');\n+        $okay =\n+            preg_match(\n+                '/^,?' . $this->_pcre_regex . '$/',\n+                $list_of_children\n+            );\n+        return (bool)$okay;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ChildDef/Empty.php",
          "status": "added",
          "additions": 38,
          "deletions": 0,
          "patch": "@@ -0,0 +1,38 @@\n+<?php\n+\n+/**\n+ * Definition that disallows all elements.\n+ * @warning validateChildren() in this class is actually never called, because\n+ *          empty elements are corrected in HTMLPurifier_Strategy_MakeWellFormed\n+ *          before child definitions are parsed in earnest by\n+ *          HTMLPurifier_Strategy_FixNesting.\n+ */\n+class HTMLPurifier_ChildDef_Empty extends HTMLPurifier_ChildDef\n+{\n+    /**\n+     * @type bool\n+     */\n+    public $allow_empty = true;\n+\n+    /**\n+     * @type string\n+     */\n+    public $type = 'empty';\n+\n+    public function __construct()\n+    {\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Node[] $children\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function validateChildren($children, $config, $context)\n+    {\n+        return array();\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ChildDef/List.php",
          "status": "added",
          "additions": 92,
          "deletions": 0,
          "patch": "@@ -0,0 +1,92 @@\n+<?php\n+\n+/**\n+ * Definition for list containers ul and ol.\n+ *\n+ * What does this do?  The big thing is to handle ol/ul at the top\n+ * level of list nodes, which should be handled specially by /folding/\n+ * them into the previous list node.  We generally shouldn't ever\n+ * see other disallowed elements, because the autoclose behavior\n+ * in MakeWellFormed handles it.\n+ */\n+class HTMLPurifier_ChildDef_List extends HTMLPurifier_ChildDef\n+{\n+    /**\n+     * @type string\n+     */\n+    public $type = 'list';\n+    /**\n+     * @type array\n+     */\n+    // lying a little bit, so that we can handle ul and ol ourselves\n+    // XXX: This whole business with 'wrap' is all a bit unsatisfactory\n+    public $elements = array('li' => true, 'ul' => true, 'ol' => true);\n+\n+    /**\n+     * @param array $children\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function validateChildren($children, $config, $context)\n+    {\n+        // Flag for subclasses\n+        $this->whitespace = false;\n+\n+        // if there are no tokens, delete parent node\n+        if (empty($children)) {\n+            return false;\n+        }\n+\n+        // if li is not allowed, delete parent node\n+        if (!isset($config->getHTMLDefinition()->info['li'])) {\n+            trigger_error(\"Cannot allow ul/ol without allowing li\", E_USER_WARNING);\n+            return false;\n+        }\n+\n+        // the new set of children\n+        $result = array();\n+\n+        // a little sanity check to make sure it's not ALL whitespace\n+        $all_whitespace = true;\n+\n+        $current_li = false;\n+\n+        foreach ($children as $node) {\n+            if (!empty($node->is_whitespace)) {\n+                $result[] = $node;\n+                continue;\n+            }\n+            $all_whitespace = false; // phew, we're not talking about whitespace\n+\n+            if ($node->name === 'li') {\n+                // good\n+                $current_li = $node;\n+                $result[] = $node;\n+            } else {\n+                // we want to tuck this into the previous li\n+                // Invariant: we expect the node to be ol/ul\n+                // ToDo: Make this more robust in the case of not ol/ul\n+                // by distinguishing between existing li and li created\n+                // to handle non-list elements; non-list elements should\n+                // not be appended to an existing li; only li created\n+                // for non-list. This distinction is not currently made.\n+                if ($current_li === false) {\n+                    $current_li = new HTMLPurifier_Node_Element('li');\n+                    $result[] = $current_li;\n+                }\n+                $current_li->children[] = $node;\n+                $current_li->empty = false; // XXX fascinating! Check for this error elsewhere ToDo\n+            }\n+        }\n+        if (empty($result)) {\n+            return false;\n+        }\n+        if ($all_whitespace) {\n+            return false;\n+        }\n+        return $result;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ChildDef/Optional.php",
          "status": "added",
          "additions": 45,
          "deletions": 0,
          "patch": "@@ -0,0 +1,45 @@\n+<?php\n+\n+/**\n+ * Definition that allows a set of elements, and allows no children.\n+ * @note This is a hack to reuse code from HTMLPurifier_ChildDef_Required,\n+ *       really, one shouldn't inherit from the other.  Only altered behavior\n+ *       is to overload a returned false with an array.  Thus, it will never\n+ *       return false.\n+ */\n+class HTMLPurifier_ChildDef_Optional extends HTMLPurifier_ChildDef_Required\n+{\n+    /**\n+     * @type bool\n+     */\n+    public $allow_empty = true;\n+\n+    /**\n+     * @type string\n+     */\n+    public $type = 'optional';\n+\n+    /**\n+     * @param array $children\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function validateChildren($children, $config, $context)\n+    {\n+        $result = parent::validateChildren($children, $config, $context);\n+        // we assume that $children is not modified\n+        if ($result === false) {\n+            if (empty($children)) {\n+                return true;\n+            } elseif ($this->whitespace) {\n+                return $children;\n+            } else {\n+                return array();\n+            }\n+        }\n+        return $result;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ChildDef/Required.php",
          "status": "added",
          "additions": 118,
          "deletions": 0,
          "patch": "@@ -0,0 +1,118 @@\n+<?php\n+\n+/**\n+ * Definition that allows a set of elements, but disallows empty children.\n+ */\n+class HTMLPurifier_ChildDef_Required extends HTMLPurifier_ChildDef\n+{\n+    /**\n+     * Lookup table of allowed elements.\n+     * @type array\n+     */\n+    public $elements = array();\n+\n+    /**\n+     * Whether or not the last passed node was all whitespace.\n+     * @type bool\n+     */\n+    protected $whitespace = false;\n+\n+    /**\n+     * @param array|string $elements List of allowed element names (lowercase).\n+     */\n+    public function __construct($elements)\n+    {\n+        if (is_string($elements)) {\n+            $elements = str_replace(' ', '', $elements);\n+            $elements = explode('|', $elements);\n+        }\n+        $keys = array_keys($elements);\n+        if ($keys == array_keys($keys)) {\n+            $elements = array_flip($elements);\n+            foreach ($elements as $i => $x) {\n+                $elements[$i] = true;\n+                if (empty($i)) {\n+                    unset($elements[$i]);\n+                } // remove blank\n+            }\n+        }\n+        $this->elements = $elements;\n+    }\n+\n+    /**\n+     * @type bool\n+     */\n+    public $allow_empty = false;\n+\n+    /**\n+     * @type string\n+     */\n+    public $type = 'required';\n+\n+    /**\n+     * @param array $children\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function validateChildren($children, $config, $context)\n+    {\n+        // Flag for subclasses\n+        $this->whitespace = false;\n+\n+        // if there are no tokens, delete parent node\n+        if (empty($children)) {\n+            return false;\n+        }\n+\n+        // the new set of children\n+        $result = array();\n+\n+        // whether or not parsed character data is allowed\n+        // this controls whether or not we silently drop a tag\n+        // or generate escaped HTML from it\n+        $pcdata_allowed = isset($this->elements['#PCDATA']);\n+\n+        // a little sanity check to make sure it's not ALL whitespace\n+        $all_whitespace = true;\n+\n+        $stack = array_reverse($children);\n+        while (!empty($stack)) {\n+            $node = array_pop($stack);\n+            if (!empty($node->is_whitespace)) {\n+                $result[] = $node;\n+                continue;\n+            }\n+            $all_whitespace = false; // phew, we're not talking about whitespace\n+\n+            if (!isset($this->elements[$node->name])) {\n+                // special case text\n+                // XXX One of these ought to be redundant or something\n+                if ($pcdata_allowed && $node instanceof HTMLPurifier_Node_Text) {\n+                    $result[] = $node;\n+                    continue;\n+                }\n+                // spill the child contents in\n+                // ToDo: Make configurable\n+                if ($node instanceof HTMLPurifier_Node_Element) {\n+                    for ($i = count($node->children) - 1; $i >= 0; $i--) {\n+                        $stack[] = $node->children[$i];\n+                    }\n+                    continue;\n+                }\n+                continue;\n+            }\n+            $result[] = $node;\n+        }\n+        if (empty($result)) {\n+            return false;\n+        }\n+        if ($all_whitespace) {\n+            $this->whitespace = true;\n+            return false;\n+        }\n+        return $result;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ChildDef/StrictBlockquote.php",
          "status": "added",
          "additions": 110,
          "deletions": 0,
          "patch": "@@ -0,0 +1,110 @@\n+<?php\n+\n+/**\n+ * Takes the contents of blockquote when in strict and reformats for validation.\n+ */\n+class HTMLPurifier_ChildDef_StrictBlockquote extends HTMLPurifier_ChildDef_Required\n+{\n+    /**\n+     * @type array\n+     */\n+    protected $real_elements;\n+\n+    /**\n+     * @type array\n+     */\n+    protected $fake_elements;\n+\n+    /**\n+     * @type bool\n+     */\n+    public $allow_empty = true;\n+\n+    /**\n+     * @type string\n+     */\n+    public $type = 'strictblockquote';\n+\n+    /**\n+     * @type bool\n+     */\n+    protected $init = false;\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return array\n+     * @note We don't want MakeWellFormed to auto-close inline elements since\n+     *       they might be allowed.\n+     */\n+    public function getAllowedElements($config)\n+    {\n+        $this->init($config);\n+        return $this->fake_elements;\n+    }\n+\n+    /**\n+     * @param array $children\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function validateChildren($children, $config, $context)\n+    {\n+        $this->init($config);\n+\n+        // trick the parent class into thinking it allows more\n+        $this->elements = $this->fake_elements;\n+        $result = parent::validateChildren($children, $config, $context);\n+        $this->elements = $this->real_elements;\n+\n+        if ($result === false) {\n+            return array();\n+        }\n+        if ($result === true) {\n+            $result = $children;\n+        }\n+\n+        $def = $config->getHTMLDefinition();\n+        $block_wrap_name = $def->info_block_wrapper;\n+        $block_wrap = false;\n+        $ret = array();\n+\n+        foreach ($result as $node) {\n+            if ($block_wrap === false) {\n+                if (($node instanceof HTMLPurifier_Node_Text && !$node->is_whitespace) ||\n+                    ($node instanceof HTMLPurifier_Node_Element && !isset($this->elements[$node->name]))) {\n+                        $block_wrap = new HTMLPurifier_Node_Element($def->info_block_wrapper);\n+                        $ret[] = $block_wrap;\n+                }\n+            } else {\n+                if ($node instanceof HTMLPurifier_Node_Element && isset($this->elements[$node->name])) {\n+                    $block_wrap = false;\n+\n+                }\n+            }\n+            if ($block_wrap) {\n+                $block_wrap->children[] = $node;\n+            } else {\n+                $ret[] = $node;\n+            }\n+        }\n+        return $ret;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    private function init($config)\n+    {\n+        if (!$this->init) {\n+            $def = $config->getHTMLDefinition();\n+            // allow all inline elements\n+            $this->real_elements = $this->elements;\n+            $this->fake_elements = $def->info_content_sets['Flow'];\n+            $this->fake_elements['#PCDATA'] = true;\n+            $this->init = true;\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ChildDef/Table.php",
          "status": "added",
          "additions": 224,
          "deletions": 0,
          "patch": "@@ -0,0 +1,224 @@\n+<?php\n+\n+/**\n+ * Definition for tables.  The general idea is to extract out all of the\n+ * essential bits, and then reconstruct it later.\n+ *\n+ * This is a bit confusing, because the DTDs and the W3C\n+ * validators seem to disagree on the appropriate definition. The\n+ * DTD claims:\n+ *\n+ *      (CAPTION?, (COL*|COLGROUP*), THEAD?, TFOOT?, TBODY+)\n+ *\n+ * But actually, the HTML4 spec then has this to say:\n+ *\n+ *      The TBODY start tag is always required except when the table\n+ *      contains only one table body and no table head or foot sections.\n+ *      The TBODY end tag may always be safely omitted.\n+ *\n+ * So the DTD is kind of wrong.  The validator is, unfortunately, kind\n+ * of on crack.\n+ *\n+ * The definition changed again in XHTML1.1; and in my opinion, this\n+ * formulation makes the most sense.\n+ *\n+ *      caption?, ( col* | colgroup* ), (( thead?, tfoot?, tbody+ ) | ( tr+ ))\n+ *\n+ * Essentially, we have two modes: thead/tfoot/tbody mode, and tr mode.\n+ * If we encounter a thead, tfoot or tbody, we are placed in the former\n+ * mode, and we *must* wrap any stray tr segments with a tbody. But if\n+ * we don't run into any of them, just have tr tags is OK.\n+ */\n+class HTMLPurifier_ChildDef_Table extends HTMLPurifier_ChildDef\n+{\n+    /**\n+     * @type bool\n+     */\n+    public $allow_empty = false;\n+\n+    /**\n+     * @type string\n+     */\n+    public $type = 'table';\n+\n+    /**\n+     * @type array\n+     */\n+    public $elements = array(\n+        'tr' => true,\n+        'tbody' => true,\n+        'thead' => true,\n+        'tfoot' => true,\n+        'caption' => true,\n+        'colgroup' => true,\n+        'col' => true\n+    );\n+\n+    public function __construct()\n+    {\n+    }\n+\n+    /**\n+     * @param array $children\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return array\n+     */\n+    public function validateChildren($children, $config, $context)\n+    {\n+        if (empty($children)) {\n+            return false;\n+        }\n+\n+        // only one of these elements is allowed in a table\n+        $caption = false;\n+        $thead = false;\n+        $tfoot = false;\n+\n+        // whitespace\n+        $initial_ws = array();\n+        $after_caption_ws = array();\n+        $after_thead_ws = array();\n+        $after_tfoot_ws = array();\n+\n+        // as many of these as you want\n+        $cols = array();\n+        $content = array();\n+\n+        $tbody_mode = false; // if true, then we need to wrap any stray\n+                             // <tr>s with a <tbody>.\n+\n+        $ws_accum =& $initial_ws;\n+\n+        foreach ($children as $node) {\n+            if ($node instanceof HTMLPurifier_Node_Comment) {\n+                $ws_accum[] = $node;\n+                continue;\n+            }\n+            switch ($node->name) {\n+            case 'tbody':\n+                $tbody_mode = true;\n+                // fall through\n+            case 'tr':\n+                $content[] = $node;\n+                $ws_accum =& $content;\n+                break;\n+            case 'caption':\n+                // there can only be one caption!\n+                if ($caption !== false)  break;\n+                $caption = $node;\n+                $ws_accum =& $after_caption_ws;\n+                break;\n+            case 'thead':\n+                $tbody_mode = true;\n+                // XXX This breaks rendering properties with\n+                // Firefox, which never floats a <thead> to\n+                // the top. Ever. (Our scheme will float the\n+                // first <thead> to the top.)  So maybe\n+                // <thead>s that are not first should be\n+                // turned into <tbody>? Very tricky, indeed.\n+                if ($thead === false) {\n+                    $thead = $node;\n+                    $ws_accum =& $after_thead_ws;\n+                } else {\n+                    // Oops, there's a second one! What\n+                    // should we do?  Current behavior is to\n+                    // transmutate the first and last entries into\n+                    // tbody tags, and then put into content.\n+                    // Maybe a better idea is to *attach\n+                    // it* to the existing thead or tfoot?\n+                    // We don't do this, because Firefox\n+                    // doesn't float an extra tfoot to the\n+                    // bottom like it does for the first one.\n+                    $node->name = 'tbody';\n+                    $content[] = $node;\n+                    $ws_accum =& $content;\n+                }\n+                break;\n+            case 'tfoot':\n+                // see above for some aveats\n+                $tbody_mode = true;\n+                if ($tfoot === false) {\n+                    $tfoot = $node;\n+                    $ws_accum =& $after_tfoot_ws;\n+                } else {\n+                    $node->name = 'tbody';\n+                    $content[] = $node;\n+                    $ws_accum =& $content;\n+                }\n+                break;\n+            case 'colgroup':\n+            case 'col':\n+                $cols[] = $node;\n+                $ws_accum =& $cols;\n+                break;\n+            case '#PCDATA':\n+                // How is whitespace handled? We treat is as sticky to\n+                // the *end* of the previous element. So all of the\n+                // nonsense we have worked on is to keep things\n+                // together.\n+                if (!empty($node->is_whitespace)) {\n+                    $ws_accum[] = $node;\n+                }\n+                break;\n+            }\n+        }\n+\n+        if (empty($content)) {\n+            return false;\n+        }\n+\n+        $ret = $initial_ws;\n+        if ($caption !== false) {\n+            $ret[] = $caption;\n+            $ret = array_merge($ret, $after_caption_ws);\n+        }\n+        if ($cols !== false) {\n+            $ret = array_merge($ret, $cols);\n+        }\n+        if ($thead !== false) {\n+            $ret[] = $thead;\n+            $ret = array_merge($ret, $after_thead_ws);\n+        }\n+        if ($tfoot !== false) {\n+            $ret[] = $tfoot;\n+            $ret = array_merge($ret, $after_tfoot_ws);\n+        }\n+\n+        if ($tbody_mode) {\n+            // we have to shuffle tr into tbody\n+            $current_tr_tbody = null;\n+\n+            foreach($content as $node) {\n+                switch ($node->name) {\n+                case 'tbody':\n+                    $current_tr_tbody = null;\n+                    $ret[] = $node;\n+                    break;\n+                case 'tr':\n+                    if ($current_tr_tbody === null) {\n+                        $current_tr_tbody = new HTMLPurifier_Node_Element('tbody');\n+                        $ret[] = $current_tr_tbody;\n+                    }\n+                    $current_tr_tbody->children[] = $node;\n+                    break;\n+                case '#PCDATA':\n+                    assert($node->is_whitespace);\n+                    if ($current_tr_tbody === null) {\n+                        $ret[] = $node;\n+                    } else {\n+                        $current_tr_tbody->children[] = $node;\n+                    }\n+                    break;\n+                }\n+            }\n+        } else {\n+            $ret = array_merge($ret, $content);\n+        }\n+\n+        return $ret;\n+\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Config.php",
          "status": "added",
          "additions": 920,
          "deletions": 0,
          "patch": "@@ -0,0 +1,920 @@\n+<?php\n+\n+/**\n+ * Configuration object that triggers customizable behavior.\n+ *\n+ * @warning This class is strongly defined: that means that the class\n+ *          will fail if an undefined directive is retrieved or set.\n+ *\n+ * @note Many classes that could (although many times don't) use the\n+ *       configuration object make it a mandatory parameter.  This is\n+ *       because a configuration object should always be forwarded,\n+ *       otherwise, you run the risk of missing a parameter and then\n+ *       being stumped when a configuration directive doesn't work.\n+ *\n+ * @todo Reconsider some of the public member variables\n+ */\n+class HTMLPurifier_Config\n+{\n+\n+    /**\n+     * HTML Purifier's version\n+     * @type string\n+     */\n+    public $version = '4.8.0';\n+\n+    /**\n+     * Whether or not to automatically finalize\n+     * the object if a read operation is done.\n+     * @type bool\n+     */\n+    public $autoFinalize = true;\n+\n+    // protected member variables\n+\n+    /**\n+     * Namespace indexed array of serials for specific namespaces.\n+     * @see getSerial() for more info.\n+     * @type string[]\n+     */\n+    protected $serials = array();\n+\n+    /**\n+     * Serial for entire configuration object.\n+     * @type string\n+     */\n+    protected $serial;\n+\n+    /**\n+     * Parser for variables.\n+     * @type HTMLPurifier_VarParser_Flexible\n+     */\n+    protected $parser = null;\n+\n+    /**\n+     * Reference HTMLPurifier_ConfigSchema for value checking.\n+     * @type HTMLPurifier_ConfigSchema\n+     * @note This is public for introspective purposes. Please don't\n+     *       abuse!\n+     */\n+    public $def;\n+\n+    /**\n+     * Indexed array of definitions.\n+     * @type HTMLPurifier_Definition[]\n+     */\n+    protected $definitions;\n+\n+    /**\n+     * Whether or not config is finalized.\n+     * @type bool\n+     */\n+    protected $finalized = false;\n+\n+    /**\n+     * Property list containing configuration directives.\n+     * @type array\n+     */\n+    protected $plist;\n+\n+    /**\n+     * Whether or not a set is taking place due to an alias lookup.\n+     * @type bool\n+     */\n+    private $aliasMode;\n+\n+    /**\n+     * Set to false if you do not want line and file numbers in errors.\n+     * (useful when unit testing).  This will also compress some errors\n+     * and exceptions.\n+     * @type bool\n+     */\n+    public $chatty = true;\n+\n+    /**\n+     * Current lock; only gets to this namespace are allowed.\n+     * @type string\n+     */\n+    private $lock;\n+\n+    /**\n+     * Constructor\n+     * @param HTMLPurifier_ConfigSchema $definition ConfigSchema that defines\n+     * what directives are allowed.\n+     * @param HTMLPurifier_PropertyList $parent\n+     */\n+    public function __construct($definition, $parent = null)\n+    {\n+        $parent = $parent ? $parent : $definition->defaultPlist;\n+        $this->plist = new HTMLPurifier_PropertyList($parent);\n+        $this->def = $definition; // keep a copy around for checking\n+        $this->parser = new HTMLPurifier_VarParser_Flexible();\n+    }\n+\n+    /**\n+     * Convenience constructor that creates a config object based on a mixed var\n+     * @param mixed $config Variable that defines the state of the config\n+     *                      object. Can be: a HTMLPurifier_Config() object,\n+     *                      an array of directives based on loadArray(),\n+     *                      or a string filename of an ini file.\n+     * @param HTMLPurifier_ConfigSchema $schema Schema object\n+     * @return HTMLPurifier_Config Configured object\n+     */\n+    public static function create($config, $schema = null)\n+    {\n+        if ($config instanceof HTMLPurifier_Config) {\n+            // pass-through\n+            return $config;\n+        }\n+        if (!$schema) {\n+            $ret = HTMLPurifier_Config::createDefault();\n+        } else {\n+            $ret = new HTMLPurifier_Config($schema);\n+        }\n+        if (is_string($config)) {\n+            $ret->loadIni($config);\n+        } elseif (is_array($config)) $ret->loadArray($config);\n+        return $ret;\n+    }\n+\n+    /**\n+     * Creates a new config object that inherits from a previous one.\n+     * @param HTMLPurifier_Config $config Configuration object to inherit from.\n+     * @return HTMLPurifier_Config object with $config as its parent.\n+     */\n+    public static function inherit(HTMLPurifier_Config $config)\n+    {\n+        return new HTMLPurifier_Config($config->def, $config->plist);\n+    }\n+\n+    /**\n+     * Convenience constructor that creates a default configuration object.\n+     * @return HTMLPurifier_Config default object.\n+     */\n+    public static function createDefault()\n+    {\n+        $definition = HTMLPurifier_ConfigSchema::instance();\n+        $config = new HTMLPurifier_Config($definition);\n+        return $config;\n+    }\n+\n+    /**\n+     * Retrieves a value from the configuration.\n+     *\n+     * @param string $key String key\n+     * @param mixed $a\n+     *\n+     * @return mixed\n+     */\n+    public function get($key, $a = null)\n+    {\n+        if ($a !== null) {\n+            $this->triggerError(\n+                \"Using deprecated API: use \\$config->get('$key.$a') instead\",\n+                E_USER_WARNING\n+            );\n+            $key = \"$key.$a\";\n+        }\n+        if (!$this->finalized) {\n+            $this->autoFinalize();\n+        }\n+        if (!isset($this->def->info[$key])) {\n+            // can't add % due to SimpleTest bug\n+            $this->triggerError(\n+                'Cannot retrieve value of undefined directive ' . htmlspecialchars($key),\n+                E_USER_WARNING\n+            );\n+            return;\n+        }\n+        if (isset($this->def->info[$key]->isAlias)) {\n+            $d = $this->def->info[$key];\n+            $this->triggerError(\n+                'Cannot get value from aliased directive, use real name ' . $d->key,\n+                E_USER_ERROR\n+            );\n+            return;\n+        }\n+        if ($this->lock) {\n+            list($ns) = explode('.', $key);\n+            if ($ns !== $this->lock) {\n+                $this->triggerError(\n+                    'Cannot get value of namespace ' . $ns . ' when lock for ' .\n+                    $this->lock .\n+                    ' is active, this probably indicates a Definition setup method ' .\n+                    'is accessing directives that are not within its namespace',\n+                    E_USER_ERROR\n+                );\n+                return;\n+            }\n+        }\n+        return $this->plist->get($key);\n+    }\n+\n+    /**\n+     * Retrieves an array of directives to values from a given namespace\n+     *\n+     * @param string $namespace String namespace\n+     *\n+     * @return array\n+     */\n+    public function getBatch($namespace)\n+    {\n+        if (!$this->finalized) {\n+            $this->autoFinalize();\n+        }\n+        $full = $this->getAll();\n+        if (!isset($full[$namespace])) {\n+            $this->triggerError(\n+                'Cannot retrieve undefined namespace ' .\n+                htmlspecialchars($namespace),\n+                E_USER_WARNING\n+            );\n+            return;\n+        }\n+        return $full[$namespace];\n+    }\n+\n+    /**\n+     * Returns a SHA-1 signature of a segment of the configuration object\n+     * that uniquely identifies that particular configuration\n+     *\n+     * @param string $namespace Namespace to get serial for\n+     *\n+     * @return string\n+     * @note Revision is handled specially and is removed from the batch\n+     *       before processing!\n+     */\n+    public function getBatchSerial($namespace)\n+    {\n+        if (empty($this->serials[$namespace])) {\n+            $batch = $this->getBatch($namespace);\n+            unset($batch['DefinitionRev']);\n+            $this->serials[$namespace] = sha1(serialize($batch));\n+        }\n+        return $this->serials[$namespace];\n+    }\n+\n+    /**\n+     * Returns a SHA-1 signature for the entire configuration object\n+     * that uniquely identifies that particular configuration\n+     *\n+     * @return string\n+     */\n+    public function getSerial()\n+    {\n+        if (empty($this->serial)) {\n+            $this->serial = sha1(serialize($this->getAll()));\n+        }\n+        return $this->serial;\n+    }\n+\n+    /**\n+     * Retrieves all directives, organized by namespace\n+     *\n+     * @warning This is a pretty inefficient function, avoid if you can\n+     */\n+    public function getAll()\n+    {\n+        if (!$this->finalized) {\n+            $this->autoFinalize();\n+        }\n+        $ret = array();\n+        foreach ($this->plist->squash() as $name => $value) {\n+            list($ns, $key) = explode('.', $name, 2);\n+            $ret[$ns][$key] = $value;\n+        }\n+        return $ret;\n+    }\n+\n+    /**\n+     * Sets a value to configuration.\n+     *\n+     * @param string $key key\n+     * @param mixed $value value\n+     * @param mixed $a\n+     */\n+    public function set($key, $value, $a = null)\n+    {\n+        if (strpos($key, '.') === false) {\n+            $namespace = $key;\n+            $directive = $value;\n+            $value = $a;\n+            $key = \"$key.$directive\";\n+            $this->triggerError(\"Using deprecated API: use \\$config->set('$key', ...) instead\", E_USER_NOTICE);\n+        } else {\n+            list($namespace) = explode('.', $key);\n+        }\n+        if ($this->isFinalized('Cannot set directive after finalization')) {\n+            return;\n+        }\n+        if (!isset($this->def->info[$key])) {\n+            $this->triggerError(\n+                'Cannot set undefined directive ' . htmlspecialchars($key) . ' to value',\n+                E_USER_WARNING\n+            );\n+            return;\n+        }\n+        $def = $this->def->info[$key];\n+\n+        if (isset($def->isAlias)) {\n+            if ($this->aliasMode) {\n+                $this->triggerError(\n+                    'Double-aliases not allowed, please fix '.\n+                    'ConfigSchema bug with' . $key,\n+                    E_USER_ERROR\n+                );\n+                return;\n+            }\n+            $this->aliasMode = true;\n+            $this->set($def->key, $value);\n+            $this->aliasMode = false;\n+            $this->triggerError(\"$key is an alias, preferred directive name is {$def->key}\", E_USER_NOTICE);\n+            return;\n+        }\n+\n+        // Raw type might be negative when using the fully optimized form\n+        // of stdclass, which indicates allow_null == true\n+        $rtype = is_int($def) ? $def : $def->type;\n+        if ($rtype < 0) {\n+            $type = -$rtype;\n+            $allow_null = true;\n+        } else {\n+            $type = $rtype;\n+            $allow_null = isset($def->allow_null);\n+        }\n+\n+        try {\n+            $value = $this->parser->parse($value, $type, $allow_null);\n+        } catch (HTMLPurifier_VarParserException $e) {\n+            $this->triggerError(\n+                'Value for ' . $key . ' is of invalid type, should be ' .\n+                HTMLPurifier_VarParser::getTypeName($type),\n+                E_USER_WARNING\n+            );\n+            return;\n+        }\n+        if (is_string($value) && is_object($def)) {\n+            // resolve value alias if defined\n+            if (isset($def->aliases[$value])) {\n+                $value = $def->aliases[$value];\n+            }\n+            // check to see if the value is allowed\n+            if (isset($def->allowed) && !isset($def->allowed[$value])) {\n+                $this->triggerError(\n+                    'Value not supported, valid values are: ' .\n+                    $this->_listify($def->allowed),\n+                    E_USER_WARNING\n+                );\n+                return;\n+            }\n+        }\n+        $this->plist->set($key, $value);\n+\n+        // reset definitions if the directives they depend on changed\n+        // this is a very costly process, so it's discouraged\n+        // with finalization\n+        if ($namespace == 'HTML' || $namespace == 'CSS' || $namespace == 'URI') {\n+            $this->definitions[$namespace] = null;\n+        }\n+\n+        $this->serials[$namespace] = false;\n+    }\n+\n+    /**\n+     * Convenience function for error reporting\n+     *\n+     * @param array $lookup\n+     *\n+     * @return string\n+     */\n+    private function _listify($lookup)\n+    {\n+        $list = array();\n+        foreach ($lookup as $name => $b) {\n+            $list[] = $name;\n+        }\n+        return implode(', ', $list);\n+    }\n+\n+    /**\n+     * Retrieves object reference to the HTML definition.\n+     *\n+     * @param bool $raw Return a copy that has not been setup yet. Must be\n+     *             called before it's been setup, otherwise won't work.\n+     * @param bool $optimized If true, this method may return null, to\n+     *             indicate that a cached version of the modified\n+     *             definition object is available and no further edits\n+     *             are necessary.  Consider using\n+     *             maybeGetRawHTMLDefinition, which is more explicitly\n+     *             named, instead.\n+     *\n+     * @return HTMLPurifier_HTMLDefinition\n+     */\n+    public function getHTMLDefinition($raw = false, $optimized = false)\n+    {\n+        return $this->getDefinition('HTML', $raw, $optimized);\n+    }\n+\n+    /**\n+     * Retrieves object reference to the CSS definition\n+     *\n+     * @param bool $raw Return a copy that has not been setup yet. Must be\n+     *             called before it's been setup, otherwise won't work.\n+     * @param bool $optimized If true, this method may return null, to\n+     *             indicate that a cached version of the modified\n+     *             definition object is available and no further edits\n+     *             are necessary.  Consider using\n+     *             maybeGetRawCSSDefinition, which is more explicitly\n+     *             named, instead.\n+     *\n+     * @return HTMLPurifier_CSSDefinition\n+     */\n+    public function getCSSDefinition($raw = false, $optimized = false)\n+    {\n+        return $this->getDefinition('CSS', $raw, $optimized);\n+    }\n+\n+    /**\n+     * Retrieves object reference to the URI definition\n+     *\n+     * @param bool $raw Return a copy that has not been setup yet. Must be\n+     *             called before it's been setup, otherwise won't work.\n+     * @param bool $optimized If true, this method may return null, to\n+     *             indicate that a cached version of the modified\n+     *             definition object is available and no further edits\n+     *             are necessary.  Consider using\n+     *             maybeGetRawURIDefinition, which is more explicitly\n+     *             named, instead.\n+     *\n+     * @return HTMLPurifier_URIDefinition\n+     */\n+    public function getURIDefinition($raw = false, $optimized = false)\n+    {\n+        return $this->getDefinition('URI', $raw, $optimized);\n+    }\n+\n+    /**\n+     * Retrieves a definition\n+     *\n+     * @param string $type Type of definition: HTML, CSS, etc\n+     * @param bool $raw Whether or not definition should be returned raw\n+     * @param bool $optimized Only has an effect when $raw is true.  Whether\n+     *        or not to return null if the result is already present in\n+     *        the cache.  This is off by default for backwards\n+     *        compatibility reasons, but you need to do things this\n+     *        way in order to ensure that caching is done properly.\n+     *        Check out enduser-customize.html for more details.\n+     *        We probably won't ever change this default, as much as the\n+     *        maybe semantics is the \"right thing to do.\"\n+     *\n+     * @throws HTMLPurifier_Exception\n+     * @return HTMLPurifier_Definition\n+     */\n+    public function getDefinition($type, $raw = false, $optimized = false)\n+    {\n+        if ($optimized && !$raw) {\n+            throw new HTMLPurifier_Exception(\"Cannot set optimized = true when raw = false\");\n+        }\n+        if (!$this->finalized) {\n+            $this->autoFinalize();\n+        }\n+        // temporarily suspend locks, so we can handle recursive definition calls\n+        $lock = $this->lock;\n+        $this->lock = null;\n+        $factory = HTMLPurifier_DefinitionCacheFactory::instance();\n+        $cache = $factory->create($type, $this);\n+        $this->lock = $lock;\n+        if (!$raw) {\n+            // full definition\n+            // ---------------\n+            // check if definition is in memory\n+            if (!empty($this->definitions[$type])) {\n+                $def = $this->definitions[$type];\n+                // check if the definition is setup\n+                if ($def->setup) {\n+                    return $def;\n+                } else {\n+                    $def->setup($this);\n+                    if ($def->optimized) {\n+                        $cache->add($def, $this);\n+                    }\n+                    return $def;\n+                }\n+            }\n+            // check if definition is in cache\n+            $def = $cache->get($this);\n+            if ($def) {\n+                // definition in cache, save to memory and return it\n+                $this->definitions[$type] = $def;\n+                return $def;\n+            }\n+            // initialize it\n+            $def = $this->initDefinition($type);\n+            // set it up\n+            $this->lock = $type;\n+            $def->setup($this);\n+            $this->lock = null;\n+            // save in cache\n+            $cache->add($def, $this);\n+            // return it\n+            return $def;\n+        } else {\n+            // raw definition\n+            // --------------\n+            // check preconditions\n+            $def = null;\n+            if ($optimized) {\n+                if (is_null($this->get($type . '.DefinitionID'))) {\n+                    // fatally error out if definition ID not set\n+                    throw new HTMLPurifier_Exception(\n+                        \"Cannot retrieve raw version without specifying %$type.DefinitionID\"\n+                    );\n+                }\n+            }\n+            if (!empty($this->definitions[$type])) {\n+                $def = $this->definitions[$type];\n+                if ($def->setup && !$optimized) {\n+                    $extra = $this->chatty ?\n+                        \" (try moving this code block earlier in your initialization)\" :\n+                        \"\";\n+                    throw new HTMLPurifier_Exception(\n+                        \"Cannot retrieve raw definition after it has already been setup\" .\n+                        $extra\n+                    );\n+                }\n+                if ($def->optimized === null) {\n+                    $extra = $this->chatty ? \" (try flushing your cache)\" : \"\";\n+                    throw new HTMLPurifier_Exception(\n+                        \"Optimization status of definition is unknown\" . $extra\n+                    );\n+                }\n+                if ($def->optimized !== $optimized) {\n+                    $msg = $optimized ? \"optimized\" : \"unoptimized\";\n+                    $extra = $this->chatty ?\n+                        \" (this backtrace is for the first inconsistent call, which was for a $msg raw definition)\"\n+                        : \"\";\n+                    throw new HTMLPurifier_Exception(\n+                        \"Inconsistent use of optimized and unoptimized raw definition retrievals\" . $extra\n+                    );\n+                }\n+            }\n+            // check if definition was in memory\n+            if ($def) {\n+                if ($def->setup) {\n+                    // invariant: $optimized === true (checked above)\n+                    return null;\n+                } else {\n+                    return $def;\n+                }\n+            }\n+            // if optimized, check if definition was in cache\n+            // (because we do the memory check first, this formulation\n+            // is prone to cache slamming, but I think\n+            // guaranteeing that either /all/ of the raw\n+            // setup code or /none/ of it is run is more important.)\n+            if ($optimized) {\n+                // This code path only gets run once; once we put\n+                // something in $definitions (which is guaranteed by the\n+                // trailing code), we always short-circuit above.\n+                $def = $cache->get($this);\n+                if ($def) {\n+                    // save the full definition for later, but don't\n+                    // return it yet\n+                    $this->definitions[$type] = $def;\n+                    return null;\n+                }\n+            }\n+            // check invariants for creation\n+            if (!$optimized) {\n+                if (!is_null($this->get($type . '.DefinitionID'))) {\n+                    if ($this->chatty) {\n+                        $this->triggerError(\n+                            'Due to a documentation error in previous version of HTML Purifier, your ' .\n+                            'definitions are not being cached.  If this is OK, you can remove the ' .\n+                            '%$type.DefinitionRev and %$type.DefinitionID declaration.  Otherwise, ' .\n+                            'modify your code to use maybeGetRawDefinition, and test if the returned ' .\n+                            'value is null before making any edits (if it is null, that means that a ' .\n+                            'cached version is available, and no raw operations are necessary).  See ' .\n+                            '<a href=\"http://htmlpurifier.org/docs/enduser-customize.html#optimized\">' .\n+                            'Customize</a> for more details',\n+                            E_USER_WARNING\n+                        );\n+                    } else {\n+                        $this->triggerError(\n+                            \"Useless DefinitionID declaration\",\n+                            E_USER_WARNING\n+                        );\n+                    }\n+                }\n+            }\n+            // initialize it\n+            $def = $this->initDefinition($type);\n+            $def->optimized = $optimized;\n+            return $def;\n+        }\n+        throw new HTMLPurifier_Exception(\"The impossible happened!\");\n+    }\n+\n+    /**\n+     * Initialise definition\n+     *\n+     * @param string $type What type of definition to create\n+     *\n+     * @return HTMLPurifier_CSSDefinition|HTMLPurifier_HTMLDefinition|HTMLPurifier_URIDefinition\n+     * @throws HTMLPurifier_Exception\n+     */\n+    private function initDefinition($type)\n+    {\n+        // quick checks failed, let's create the object\n+        if ($type == 'HTML') {\n+            $def = new HTMLPurifier_HTMLDefinition();\n+        } elseif ($type == 'CSS') {\n+            $def = new HTMLPurifier_CSSDefinition();\n+        } elseif ($type == 'URI') {\n+            $def = new HTMLPurifier_URIDefinition();\n+        } else {\n+            throw new HTMLPurifier_Exception(\n+                \"Definition of $type type not supported\"\n+            );\n+        }\n+        $this->definitions[$type] = $def;\n+        return $def;\n+    }\n+\n+    public function maybeGetRawDefinition($name)\n+    {\n+        return $this->getDefinition($name, true, true);\n+    }\n+\n+    /**\n+     * @return HTMLPurifier_HTMLDefinition\n+     */\n+    public function maybeGetRawHTMLDefinition()\n+    {\n+        return $this->getDefinition('HTML', true, true);\n+    }\n+    \n+    /**\n+     * @return HTMLPurifier_CSSDefinition\n+     */\n+    public function maybeGetRawCSSDefinition()\n+    {\n+        return $this->getDefinition('CSS', true, true);\n+    }\n+    \n+    /**\n+     * @return HTMLPurifier_URIDefinition\n+     */\n+    public function maybeGetRawURIDefinition()\n+    {\n+        return $this->getDefinition('URI', true, true);\n+    }\n+\n+    /**\n+     * Loads configuration values from an array with the following structure:\n+     * Namespace.Directive => Value\n+     *\n+     * @param array $config_array Configuration associative array\n+     */\n+    public function loadArray($config_array)\n+    {\n+        if ($this->isFinalized('Cannot load directives after finalization')) {\n+            return;\n+        }\n+        foreach ($config_array as $key => $value) {\n+            $key = str_replace('_', '.', $key);\n+            if (strpos($key, '.') !== false) {\n+                $this->set($key, $value);\n+            } else {\n+                $namespace = $key;\n+                $namespace_values = $value;\n+                foreach ($namespace_values as $directive => $value2) {\n+                    $this->set($namespace .'.'. $directive, $value2);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a list of array(namespace, directive) for all directives\n+     * that are allowed in a web-form context as per an allowed\n+     * namespaces/directives list.\n+     *\n+     * @param array $allowed List of allowed namespaces/directives\n+     * @param HTMLPurifier_ConfigSchema $schema Schema to use, if not global copy\n+     *\n+     * @return array\n+     */\n+    public static function getAllowedDirectivesForForm($allowed, $schema = null)\n+    {\n+        if (!$schema) {\n+            $schema = HTMLPurifier_ConfigSchema::instance();\n+        }\n+        if ($allowed !== true) {\n+            if (is_string($allowed)) {\n+                $allowed = array($allowed);\n+            }\n+            $allowed_ns = array();\n+            $allowed_directives = array();\n+            $blacklisted_directives = array();\n+            foreach ($allowed as $ns_or_directive) {\n+                if (strpos($ns_or_directive, '.') !== false) {\n+                    // directive\n+                    if ($ns_or_directive[0] == '-') {\n+                        $blacklisted_directives[substr($ns_or_directive, 1)] = true;\n+                    } else {\n+                        $allowed_directives[$ns_or_directive] = true;\n+                    }\n+                } else {\n+                    // namespace\n+                    $allowed_ns[$ns_or_directive] = true;\n+                }\n+            }\n+        }\n+        $ret = array();\n+        foreach ($schema->info as $key => $def) {\n+            list($ns, $directive) = explode('.', $key, 2);\n+            if ($allowed !== true) {\n+                if (isset($blacklisted_directives[\"$ns.$directive\"])) {\n+                    continue;\n+                }\n+                if (!isset($allowed_directives[\"$ns.$directive\"]) && !isset($allowed_ns[$ns])) {\n+                    continue;\n+                }\n+            }\n+            if (isset($def->isAlias)) {\n+                continue;\n+            }\n+            if ($directive == 'DefinitionID' || $directive == 'DefinitionRev') {\n+                continue;\n+            }\n+            $ret[] = array($ns, $directive);\n+        }\n+        return $ret;\n+    }\n+\n+    /**\n+     * Loads configuration values from $_GET/$_POST that were posted\n+     * via ConfigForm\n+     *\n+     * @param array $array $_GET or $_POST array to import\n+     * @param string|bool $index Index/name that the config variables are in\n+     * @param array|bool $allowed List of allowed namespaces/directives\n+     * @param bool $mq_fix Boolean whether or not to enable magic quotes fix\n+     * @param HTMLPurifier_ConfigSchema $schema Schema to use, if not global copy\n+     *\n+     * @return mixed\n+     */\n+    public static function loadArrayFromForm($array, $index = false, $allowed = true, $mq_fix = true, $schema = null)\n+    {\n+        $ret = HTMLPurifier_Config::prepareArrayFromForm($array, $index, $allowed, $mq_fix, $schema);\n+        $config = HTMLPurifier_Config::create($ret, $schema);\n+        return $config;\n+    }\n+\n+    /**\n+     * Merges in configuration values from $_GET/$_POST to object. NOT STATIC.\n+     *\n+     * @param array $array $_GET or $_POST array to import\n+     * @param string|bool $index Index/name that the config variables are in\n+     * @param array|bool $allowed List of allowed namespaces/directives\n+     * @param bool $mq_fix Boolean whether or not to enable magic quotes fix\n+     */\n+    public function mergeArrayFromForm($array, $index = false, $allowed = true, $mq_fix = true)\n+    {\n+         $ret = HTMLPurifier_Config::prepareArrayFromForm($array, $index, $allowed, $mq_fix, $this->def);\n+         $this->loadArray($ret);\n+    }\n+\n+    /**\n+     * Prepares an array from a form into something usable for the more\n+     * strict parts of HTMLPurifier_Config\n+     *\n+     * @param array $array $_GET or $_POST array to import\n+     * @param string|bool $index Index/name that the config variables are in\n+     * @param array|bool $allowed List of allowed namespaces/directives\n+     * @param bool $mq_fix Boolean whether or not to enable magic quotes fix\n+     * @param HTMLPurifier_ConfigSchema $schema Schema to use, if not global copy\n+     *\n+     * @return array\n+     */\n+    public static function prepareArrayFromForm($array, $index = false, $allowed = true, $mq_fix = true, $schema = null)\n+    {\n+        if ($index !== false) {\n+            $array = (isset($array[$index]) && is_array($array[$index])) ? $array[$index] : array();\n+        }\n+        $mq = $mq_fix && function_exists('get_magic_quotes_gpc') && get_magic_quotes_gpc();\n+\n+        $allowed = HTMLPurifier_Config::getAllowedDirectivesForForm($allowed, $schema);\n+        $ret = array();\n+        foreach ($allowed as $key) {\n+            list($ns, $directive) = $key;\n+            $skey = \"$ns.$directive\";\n+            if (!empty($array[\"Null_$skey\"])) {\n+                $ret[$ns][$directive] = null;\n+                continue;\n+            }\n+            if (!isset($array[$skey])) {\n+                continue;\n+            }\n+            $value = $mq ? stripslashes($array[$skey]) : $array[$skey];\n+            $ret[$ns][$directive] = $value;\n+        }\n+        return $ret;\n+    }\n+\n+    /**\n+     * Loads configuration values from an ini file\n+     *\n+     * @param string $filename Name of ini file\n+     */\n+    public function loadIni($filename)\n+    {\n+        if ($this->isFinalized('Cannot load directives after finalization')) {\n+            return;\n+        }\n+        $array = parse_ini_file($filename, true);\n+        $this->loadArray($array);\n+    }\n+\n+    /**\n+     * Checks whether or not the configuration object is finalized.\n+     *\n+     * @param string|bool $error String error message, or false for no error\n+     *\n+     * @return bool\n+     */\n+    public function isFinalized($error = false)\n+    {\n+        if ($this->finalized && $error) {\n+            $this->triggerError($error, E_USER_ERROR);\n+        }\n+        return $this->finalized;\n+    }\n+\n+    /**\n+     * Finalizes configuration only if auto finalize is on and not\n+     * already finalized\n+     */\n+    public function autoFinalize()\n+    {\n+        if ($this->autoFinalize) {\n+            $this->finalize();\n+        } else {\n+            $this->plist->squash(true);\n+        }\n+    }\n+\n+    /**\n+     * Finalizes a configuration object, prohibiting further change\n+     */\n+    public function finalize()\n+    {\n+        $this->finalized = true;\n+        $this->parser = null;\n+    }\n+\n+    /**\n+     * Produces a nicely formatted error message by supplying the\n+     * stack frame information OUTSIDE of HTMLPurifier_Config.\n+     *\n+     * @param string $msg An error message\n+     * @param int $no An error number\n+     */\n+    protected function triggerError($msg, $no)\n+    {\n+        // determine previous stack frame\n+        $extra = '';\n+        if ($this->chatty) {\n+            $trace = debug_backtrace();\n+            // zip(tail(trace), trace) -- but PHP is not Haskell har har\n+            for ($i = 0, $c = count($trace); $i < $c - 1; $i++) {\n+                // XXX this is not correct on some versions of HTML Purifier\n+                if ($trace[$i + 1]['class'] === 'HTMLPurifier_Config') {\n+                    continue;\n+                }\n+                $frame = $trace[$i];\n+                $extra = \" invoked on line {$frame['line']} in file {$frame['file']}\";\n+                break;\n+            }\n+        }\n+        trigger_error($msg . $extra, $no);\n+    }\n+\n+    /**\n+     * Returns a serialized form of the configuration object that can\n+     * be reconstituted.\n+     *\n+     * @return string\n+     */\n+    public function serialize()\n+    {\n+        $this->getDefinition('HTML');\n+        $this->getDefinition('CSS');\n+        $this->getDefinition('URI');\n+        return serialize($this);\n+    }\n+\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema.php",
          "status": "added",
          "additions": 176,
          "deletions": 0,
          "patch": "@@ -0,0 +1,176 @@\n+<?php\n+\n+/**\n+ * Configuration definition, defines directives and their defaults.\n+ */\n+class HTMLPurifier_ConfigSchema\n+{\n+    /**\n+     * Defaults of the directives and namespaces.\n+     * @type array\n+     * @note This shares the exact same structure as HTMLPurifier_Config::$conf\n+     */\n+    public $defaults = array();\n+\n+    /**\n+     * The default property list. Do not edit this property list.\n+     * @type array\n+     */\n+    public $defaultPlist;\n+\n+    /**\n+     * Definition of the directives.\n+     * The structure of this is:\n+     *\n+     *  array(\n+     *      'Namespace' => array(\n+     *          'Directive' => new stdclass(),\n+     *      )\n+     *  )\n+     *\n+     * The stdclass may have the following properties:\n+     *\n+     *  - If isAlias isn't set:\n+     *      - type: Integer type of directive, see HTMLPurifier_VarParser for definitions\n+     *      - allow_null: If set, this directive allows null values\n+     *      - aliases: If set, an associative array of value aliases to real values\n+     *      - allowed: If set, a lookup array of allowed (string) values\n+     *  - If isAlias is set:\n+     *      - namespace: Namespace this directive aliases to\n+     *      - name: Directive name this directive aliases to\n+     *\n+     * In certain degenerate cases, stdclass will actually be an integer. In\n+     * that case, the value is equivalent to an stdclass with the type\n+     * property set to the integer. If the integer is negative, type is\n+     * equal to the absolute value of integer, and allow_null is true.\n+     *\n+     * This class is friendly with HTMLPurifier_Config. If you need introspection\n+     * about the schema, you're better of using the ConfigSchema_Interchange,\n+     * which uses more memory but has much richer information.\n+     * @type array\n+     */\n+    public $info = array();\n+\n+    /**\n+     * Application-wide singleton\n+     * @type HTMLPurifier_ConfigSchema\n+     */\n+    protected static $singleton;\n+\n+    public function __construct()\n+    {\n+        $this->defaultPlist = new HTMLPurifier_PropertyList();\n+    }\n+\n+    /**\n+     * Unserializes the default ConfigSchema.\n+     * @return HTMLPurifier_ConfigSchema\n+     */\n+    public static function makeFromSerial()\n+    {\n+        $contents = file_get_contents(HTMLPURIFIER_PREFIX . '/HTMLPurifier/ConfigSchema/schema.ser');\n+        $r = unserialize($contents);\n+        if (!$r) {\n+            $hash = sha1($contents);\n+            trigger_error(\"Unserialization of configuration schema failed, sha1 of file was $hash\", E_USER_ERROR);\n+        }\n+        return $r;\n+    }\n+\n+    /**\n+     * Retrieves an instance of the application-wide configuration definition.\n+     * @param HTMLPurifier_ConfigSchema $prototype\n+     * @return HTMLPurifier_ConfigSchema\n+     */\n+    public static function instance($prototype = null)\n+    {\n+        if ($prototype !== null) {\n+            HTMLPurifier_ConfigSchema::$singleton = $prototype;\n+        } elseif (HTMLPurifier_ConfigSchema::$singleton === null || $prototype === true) {\n+            HTMLPurifier_ConfigSchema::$singleton = HTMLPurifier_ConfigSchema::makeFromSerial();\n+        }\n+        return HTMLPurifier_ConfigSchema::$singleton;\n+    }\n+\n+    /**\n+     * Defines a directive for configuration\n+     * @warning Will fail of directive's namespace is defined.\n+     * @warning This method's signature is slightly different from the legacy\n+     *          define() static method! Beware!\n+     * @param string $key Name of directive\n+     * @param mixed $default Default value of directive\n+     * @param string $type Allowed type of the directive. See\n+     *      HTMLPurifier_DirectiveDef::$type for allowed values\n+     * @param bool $allow_null Whether or not to allow null values\n+     */\n+    public function add($key, $default, $type, $allow_null)\n+    {\n+        $obj = new stdclass();\n+        $obj->type = is_int($type) ? $type : HTMLPurifier_VarParser::$types[$type];\n+        if ($allow_null) {\n+            $obj->allow_null = true;\n+        }\n+        $this->info[$key] = $obj;\n+        $this->defaults[$key] = $default;\n+        $this->defaultPlist->set($key, $default);\n+    }\n+\n+    /**\n+     * Defines a directive value alias.\n+     *\n+     * Directive value aliases are convenient for developers because it lets\n+     * them set a directive to several values and get the same result.\n+     * @param string $key Name of Directive\n+     * @param array $aliases Hash of aliased values to the real alias\n+     */\n+    public function addValueAliases($key, $aliases)\n+    {\n+        if (!isset($this->info[$key]->aliases)) {\n+            $this->info[$key]->aliases = array();\n+        }\n+        foreach ($aliases as $alias => $real) {\n+            $this->info[$key]->aliases[$alias] = $real;\n+        }\n+    }\n+\n+    /**\n+     * Defines a set of allowed values for a directive.\n+     * @warning This is slightly different from the corresponding static\n+     *          method definition.\n+     * @param string $key Name of directive\n+     * @param array $allowed Lookup array of allowed values\n+     */\n+    public function addAllowedValues($key, $allowed)\n+    {\n+        $this->info[$key]->allowed = $allowed;\n+    }\n+\n+    /**\n+     * Defines a directive alias for backwards compatibility\n+     * @param string $key Directive that will be aliased\n+     * @param string $new_key Directive that the alias will be to\n+     */\n+    public function addAlias($key, $new_key)\n+    {\n+        $obj = new stdclass;\n+        $obj->key = $new_key;\n+        $obj->isAlias = true;\n+        $this->info[$key] = $obj;\n+    }\n+\n+    /**\n+     * Replaces any stdclass that only has the type property with type integer.\n+     */\n+    public function postProcess()\n+    {\n+        foreach ($this->info as $key => $v) {\n+            if (count((array) $v) == 1) {\n+                $this->info[$key] = $v->type;\n+            } elseif (count((array) $v) == 2 && isset($v->allow_null)) {\n+                $this->info[$key] = -$v->type;\n+            }\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/Builder/ConfigSchema.php",
          "status": "added",
          "additions": 48,
          "deletions": 0,
          "patch": "@@ -0,0 +1,48 @@\n+<?php\n+\n+/**\n+ * Converts HTMLPurifier_ConfigSchema_Interchange to our runtime\n+ * representation used to perform checks on user configuration.\n+ */\n+class HTMLPurifier_ConfigSchema_Builder_ConfigSchema\n+{\n+\n+    /**\n+     * @param HTMLPurifier_ConfigSchema_Interchange $interchange\n+     * @return HTMLPurifier_ConfigSchema\n+     */\n+    public function build($interchange)\n+    {\n+        $schema = new HTMLPurifier_ConfigSchema();\n+        foreach ($interchange->directives as $d) {\n+            $schema->add(\n+                $d->id->key,\n+                $d->default,\n+                $d->type,\n+                $d->typeAllowsNull\n+            );\n+            if ($d->allowed !== null) {\n+                $schema->addAllowedValues(\n+                    $d->id->key,\n+                    $d->allowed\n+                );\n+            }\n+            foreach ($d->aliases as $alias) {\n+                $schema->addAlias(\n+                    $alias->key,\n+                    $d->id->key\n+                );\n+            }\n+            if ($d->valueAliases !== null) {\n+                $schema->addValueAliases(\n+                    $d->id->key,\n+                    $d->valueAliases\n+                );\n+            }\n+        }\n+        $schema->postProcess();\n+        return $schema;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/Builder/Xml.php",
          "status": "added",
          "additions": 144,
          "deletions": 0,
          "patch": "@@ -0,0 +1,144 @@\n+<?php\n+\n+/**\n+ * Converts HTMLPurifier_ConfigSchema_Interchange to an XML format,\n+ * which can be further processed to generate documentation.\n+ */\n+class HTMLPurifier_ConfigSchema_Builder_Xml extends XMLWriter\n+{\n+\n+    /**\n+     * @type HTMLPurifier_ConfigSchema_Interchange\n+     */\n+    protected $interchange;\n+\n+    /**\n+     * @type string\n+     */\n+    private $namespace;\n+\n+    /**\n+     * @param string $html\n+     */\n+    protected function writeHTMLDiv($html)\n+    {\n+        $this->startElement('div');\n+\n+        $purifier = HTMLPurifier::getInstance();\n+        $html = $purifier->purify($html);\n+        $this->writeAttribute('xmlns', 'http://www.w3.org/1999/xhtml');\n+        $this->writeRaw($html);\n+\n+        $this->endElement(); // div\n+    }\n+\n+    /**\n+     * @param mixed $var\n+     * @return string\n+     */\n+    protected function export($var)\n+    {\n+        if ($var === array()) {\n+            return 'array()';\n+        }\n+        return var_export($var, true);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_ConfigSchema_Interchange $interchange\n+     */\n+    public function build($interchange)\n+    {\n+        // global access, only use as last resort\n+        $this->interchange = $interchange;\n+\n+        $this->setIndent(true);\n+        $this->startDocument('1.0', 'UTF-8');\n+        $this->startElement('configdoc');\n+        $this->writeElement('title', $interchange->name);\n+\n+        foreach ($interchange->directives as $directive) {\n+            $this->buildDirective($directive);\n+        }\n+\n+        if ($this->namespace) {\n+            $this->endElement();\n+        } // namespace\n+\n+        $this->endElement(); // configdoc\n+        $this->flush();\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_ConfigSchema_Interchange_Directive $directive\n+     */\n+    public function buildDirective($directive)\n+    {\n+        // Kludge, although I suppose having a notion of a \"root namespace\"\n+        // certainly makes things look nicer when documentation is built.\n+        // Depends on things being sorted.\n+        if (!$this->namespace || $this->namespace !== $directive->id->getRootNamespace()) {\n+            if ($this->namespace) {\n+                $this->endElement();\n+            } // namespace\n+            $this->namespace = $directive->id->getRootNamespace();\n+            $this->startElement('namespace');\n+            $this->writeAttribute('id', $this->namespace);\n+            $this->writeElement('name', $this->namespace);\n+        }\n+\n+        $this->startElement('directive');\n+        $this->writeAttribute('id', $directive->id->toString());\n+\n+        $this->writeElement('name', $directive->id->getDirective());\n+\n+        $this->startElement('aliases');\n+        foreach ($directive->aliases as $alias) {\n+            $this->writeElement('alias', $alias->toString());\n+        }\n+        $this->endElement(); // aliases\n+\n+        $this->startElement('constraints');\n+        if ($directive->version) {\n+            $this->writeElement('version', $directive->version);\n+        }\n+        $this->startElement('type');\n+        if ($directive->typeAllowsNull) {\n+            $this->writeAttribute('allow-null', 'yes');\n+        }\n+        $this->text($directive->type);\n+        $this->endElement(); // type\n+        if ($directive->allowed) {\n+            $this->startElement('allowed');\n+            foreach ($directive->allowed as $value => $x) {\n+                $this->writeElement('value', $value);\n+            }\n+            $this->endElement(); // allowed\n+        }\n+        $this->writeElement('default', $this->export($directive->default));\n+        $this->writeAttribute('xml:space', 'preserve');\n+        if ($directive->external) {\n+            $this->startElement('external');\n+            foreach ($directive->external as $project) {\n+                $this->writeElement('project', $project);\n+            }\n+            $this->endElement();\n+        }\n+        $this->endElement(); // constraints\n+\n+        if ($directive->deprecatedVersion) {\n+            $this->startElement('deprecated');\n+            $this->writeElement('version', $directive->deprecatedVersion);\n+            $this->writeElement('use', $directive->deprecatedUse->toString());\n+            $this->endElement(); // deprecated\n+        }\n+\n+        $this->startElement('description');\n+        $this->writeHTMLDiv($directive->description);\n+        $this->endElement(); // description\n+\n+        $this->endElement(); // directive\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/Exception.php",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+<?php\n+\n+/**\n+ * Exceptions related to configuration schema\n+ */\n+class HTMLPurifier_ConfigSchema_Exception extends HTMLPurifier_Exception\n+{\n+\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/Interchange.php",
          "status": "added",
          "additions": 47,
          "deletions": 0,
          "patch": "@@ -0,0 +1,47 @@\n+<?php\n+\n+/**\n+ * Generic schema interchange format that can be converted to a runtime\n+ * representation (HTMLPurifier_ConfigSchema) or HTML documentation. Members\n+ * are completely validated.\n+ */\n+class HTMLPurifier_ConfigSchema_Interchange\n+{\n+\n+    /**\n+     * Name of the application this schema is describing.\n+     * @type string\n+     */\n+    public $name;\n+\n+    /**\n+     * Array of Directive ID => array(directive info)\n+     * @type HTMLPurifier_ConfigSchema_Interchange_Directive[]\n+     */\n+    public $directives = array();\n+\n+    /**\n+     * Adds a directive array to $directives\n+     * @param HTMLPurifier_ConfigSchema_Interchange_Directive $directive\n+     * @throws HTMLPurifier_ConfigSchema_Exception\n+     */\n+    public function addDirective($directive)\n+    {\n+        if (isset($this->directives[$i = $directive->id->toString()])) {\n+            throw new HTMLPurifier_ConfigSchema_Exception(\"Cannot redefine directive '$i'\");\n+        }\n+        $this->directives[$i] = $directive;\n+    }\n+\n+    /**\n+     * Convenience function to perform standard validation. Throws exception\n+     * on failed validation.\n+     */\n+    public function validate()\n+    {\n+        $validator = new HTMLPurifier_ConfigSchema_Validator();\n+        return $validator->validate($this);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/Interchange/Directive.php",
          "status": "added",
          "additions": 89,
          "deletions": 0,
          "patch": "@@ -0,0 +1,89 @@\n+<?php\n+\n+/**\n+ * Interchange component class describing configuration directives.\n+ */\n+class HTMLPurifier_ConfigSchema_Interchange_Directive\n+{\n+\n+    /**\n+     * ID of directive.\n+     * @type HTMLPurifier_ConfigSchema_Interchange_Id\n+     */\n+    public $id;\n+\n+    /**\n+     * Type, e.g. 'integer' or 'istring'.\n+     * @type string\n+     */\n+    public $type;\n+\n+    /**\n+     * Default value, e.g. 3 or 'DefaultVal'.\n+     * @type mixed\n+     */\n+    public $default;\n+\n+    /**\n+     * HTML description.\n+     * @type string\n+     */\n+    public $description;\n+\n+    /**\n+     * Whether or not null is allowed as a value.\n+     * @type bool\n+     */\n+    public $typeAllowsNull = false;\n+\n+    /**\n+     * Lookup table of allowed scalar values.\n+     * e.g. array('allowed' => true).\n+     * Null if all values are allowed.\n+     * @type array\n+     */\n+    public $allowed;\n+\n+    /**\n+     * List of aliases for the directive.\n+     * e.g. array(new HTMLPurifier_ConfigSchema_Interchange_Id('Ns', 'Dir'))).\n+     * @type HTMLPurifier_ConfigSchema_Interchange_Id[]\n+     */\n+    public $aliases = array();\n+\n+    /**\n+     * Hash of value aliases, e.g. array('alt' => 'real'). Null if value\n+     * aliasing is disabled (necessary for non-scalar types).\n+     * @type array\n+     */\n+    public $valueAliases;\n+\n+    /**\n+     * Version of HTML Purifier the directive was introduced, e.g. '1.3.1'.\n+     * Null if the directive has always existed.\n+     * @type string\n+     */\n+    public $version;\n+\n+    /**\n+     * ID of directive that supercedes this old directive.\n+     * Null if not deprecated.\n+     * @type HTMLPurifier_ConfigSchema_Interchange_Id\n+     */\n+    public $deprecatedUse;\n+\n+    /**\n+     * Version of HTML Purifier this directive was deprecated. Null if not\n+     * deprecated.\n+     * @type string\n+     */\n+    public $deprecatedVersion;\n+\n+    /**\n+     * List of external projects this directive depends on, e.g. array('CSSTidy').\n+     * @type array\n+     */\n+    public $external = array();\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/Interchange/Id.php",
          "status": "added",
          "additions": 58,
          "deletions": 0,
          "patch": "@@ -0,0 +1,58 @@\n+<?php\n+\n+/**\n+ * Represents a directive ID in the interchange format.\n+ */\n+class HTMLPurifier_ConfigSchema_Interchange_Id\n+{\n+\n+    /**\n+     * @type string\n+     */\n+    public $key;\n+\n+    /**\n+     * @param string $key\n+     */\n+    public function __construct($key)\n+    {\n+        $this->key = $key;\n+    }\n+\n+    /**\n+     * @return string\n+     * @warning This is NOT magic, to ensure that people don't abuse SPL and\n+     *          cause problems for PHP 5.0 support.\n+     */\n+    public function toString()\n+    {\n+        return $this->key;\n+    }\n+\n+    /**\n+     * @return string\n+     */\n+    public function getRootNamespace()\n+    {\n+        return substr($this->key, 0, strpos($this->key, \".\"));\n+    }\n+\n+    /**\n+     * @return string\n+     */\n+    public function getDirective()\n+    {\n+        return substr($this->key, strpos($this->key, \".\") + 1);\n+    }\n+\n+    /**\n+     * @param string $id\n+     * @return HTMLPurifier_ConfigSchema_Interchange_Id\n+     */\n+    public static function make($id)\n+    {\n+        return new HTMLPurifier_ConfigSchema_Interchange_Id($id);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/InterchangeBuilder.php",
          "status": "added",
          "additions": 226,
          "deletions": 0,
          "patch": "@@ -0,0 +1,226 @@\n+<?php\n+\n+class HTMLPurifier_ConfigSchema_InterchangeBuilder\n+{\n+\n+    /**\n+     * Used for processing DEFAULT, nothing else.\n+     * @type HTMLPurifier_VarParser\n+     */\n+    protected $varParser;\n+\n+    /**\n+     * @param HTMLPurifier_VarParser $varParser\n+     */\n+    public function __construct($varParser = null)\n+    {\n+        $this->varParser = $varParser ? $varParser : new HTMLPurifier_VarParser_Native();\n+    }\n+\n+    /**\n+     * @param string $dir\n+     * @return HTMLPurifier_ConfigSchema_Interchange\n+     */\n+    public static function buildFromDirectory($dir = null)\n+    {\n+        $builder = new HTMLPurifier_ConfigSchema_InterchangeBuilder();\n+        $interchange = new HTMLPurifier_ConfigSchema_Interchange();\n+        return $builder->buildDir($interchange, $dir);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_ConfigSchema_Interchange $interchange\n+     * @param string $dir\n+     * @return HTMLPurifier_ConfigSchema_Interchange\n+     */\n+    public function buildDir($interchange, $dir = null)\n+    {\n+        if (!$dir) {\n+            $dir = HTMLPURIFIER_PREFIX . '/HTMLPurifier/ConfigSchema/schema';\n+        }\n+        if (file_exists($dir . '/info.ini')) {\n+            $info = parse_ini_file($dir . '/info.ini');\n+            $interchange->name = $info['name'];\n+        }\n+\n+        $files = array();\n+        $dh = opendir($dir);\n+        while (false !== ($file = readdir($dh))) {\n+            if (!$file || $file[0] == '.' || strrchr($file, '.') !== '.txt') {\n+                continue;\n+            }\n+            $files[] = $file;\n+        }\n+        closedir($dh);\n+\n+        sort($files);\n+        foreach ($files as $file) {\n+            $this->buildFile($interchange, $dir . '/' . $file);\n+        }\n+        return $interchange;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_ConfigSchema_Interchange $interchange\n+     * @param string $file\n+     */\n+    public function buildFile($interchange, $file)\n+    {\n+        $parser = new HTMLPurifier_StringHashParser();\n+        $this->build(\n+            $interchange,\n+            new HTMLPurifier_StringHash($parser->parseFile($file))\n+        );\n+    }\n+\n+    /**\n+     * Builds an interchange object based on a hash.\n+     * @param HTMLPurifier_ConfigSchema_Interchange $interchange HTMLPurifier_ConfigSchema_Interchange object to build\n+     * @param HTMLPurifier_StringHash $hash source data\n+     * @throws HTMLPurifier_ConfigSchema_Exception\n+     */\n+    public function build($interchange, $hash)\n+    {\n+        if (!$hash instanceof HTMLPurifier_StringHash) {\n+            $hash = new HTMLPurifier_StringHash($hash);\n+        }\n+        if (!isset($hash['ID'])) {\n+            throw new HTMLPurifier_ConfigSchema_Exception('Hash does not have any ID');\n+        }\n+        if (strpos($hash['ID'], '.') === false) {\n+            if (count($hash) == 2 && isset($hash['DESCRIPTION'])) {\n+                $hash->offsetGet('DESCRIPTION'); // prevent complaining\n+            } else {\n+                throw new HTMLPurifier_ConfigSchema_Exception('All directives must have a namespace');\n+            }\n+        } else {\n+            $this->buildDirective($interchange, $hash);\n+        }\n+        $this->_findUnused($hash);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_ConfigSchema_Interchange $interchange\n+     * @param HTMLPurifier_StringHash $hash\n+     * @throws HTMLPurifier_ConfigSchema_Exception\n+     */\n+    public function buildDirective($interchange, $hash)\n+    {\n+        $directive = new HTMLPurifier_ConfigSchema_Interchange_Directive();\n+\n+        // These are required elements:\n+        $directive->id = $this->id($hash->offsetGet('ID'));\n+        $id = $directive->id->toString(); // convenience\n+\n+        if (isset($hash['TYPE'])) {\n+            $type = explode('/', $hash->offsetGet('TYPE'));\n+            if (isset($type[1])) {\n+                $directive->typeAllowsNull = true;\n+            }\n+            $directive->type = $type[0];\n+        } else {\n+            throw new HTMLPurifier_ConfigSchema_Exception(\"TYPE in directive hash '$id' not defined\");\n+        }\n+\n+        if (isset($hash['DEFAULT'])) {\n+            try {\n+                $directive->default = $this->varParser->parse(\n+                    $hash->offsetGet('DEFAULT'),\n+                    $directive->type,\n+                    $directive->typeAllowsNull\n+                );\n+            } catch (HTMLPurifier_VarParserException $e) {\n+                throw new HTMLPurifier_ConfigSchema_Exception($e->getMessage() . \" in DEFAULT in directive hash '$id'\");\n+            }\n+        }\n+\n+        if (isset($hash['DESCRIPTION'])) {\n+            $directive->description = $hash->offsetGet('DESCRIPTION');\n+        }\n+\n+        if (isset($hash['ALLOWED'])) {\n+            $directive->allowed = $this->lookup($this->evalArray($hash->offsetGet('ALLOWED')));\n+        }\n+\n+        if (isset($hash['VALUE-ALIASES'])) {\n+            $directive->valueAliases = $this->evalArray($hash->offsetGet('VALUE-ALIASES'));\n+        }\n+\n+        if (isset($hash['ALIASES'])) {\n+            $raw_aliases = trim($hash->offsetGet('ALIASES'));\n+            $aliases = preg_split('/\\s*,\\s*/', $raw_aliases);\n+            foreach ($aliases as $alias) {\n+                $directive->aliases[] = $this->id($alias);\n+            }\n+        }\n+\n+        if (isset($hash['VERSION'])) {\n+            $directive->version = $hash->offsetGet('VERSION');\n+        }\n+\n+        if (isset($hash['DEPRECATED-USE'])) {\n+            $directive->deprecatedUse = $this->id($hash->offsetGet('DEPRECATED-USE'));\n+        }\n+\n+        if (isset($hash['DEPRECATED-VERSION'])) {\n+            $directive->deprecatedVersion = $hash->offsetGet('DEPRECATED-VERSION');\n+        }\n+\n+        if (isset($hash['EXTERNAL'])) {\n+            $directive->external = preg_split('/\\s*,\\s*/', trim($hash->offsetGet('EXTERNAL')));\n+        }\n+\n+        $interchange->addDirective($directive);\n+    }\n+\n+    /**\n+     * Evaluates an array PHP code string without array() wrapper\n+     * @param string $contents\n+     */\n+    protected function evalArray($contents)\n+    {\n+        return eval('return array(' . $contents . ');');\n+    }\n+\n+    /**\n+     * Converts an array list into a lookup array.\n+     * @param array $array\n+     * @return array\n+     */\n+    protected function lookup($array)\n+    {\n+        $ret = array();\n+        foreach ($array as $val) {\n+            $ret[$val] = true;\n+        }\n+        return $ret;\n+    }\n+\n+    /**\n+     * Convenience function that creates an HTMLPurifier_ConfigSchema_Interchange_Id\n+     * object based on a string Id.\n+     * @param string $id\n+     * @return HTMLPurifier_ConfigSchema_Interchange_Id\n+     */\n+    protected function id($id)\n+    {\n+        return HTMLPurifier_ConfigSchema_Interchange_Id::make($id);\n+    }\n+\n+    /**\n+     * Triggers errors for any unused keys passed in the hash; such keys\n+     * may indicate typos, missing values, etc.\n+     * @param HTMLPurifier_StringHash $hash Hash to check.\n+     */\n+    protected function _findUnused($hash)\n+    {\n+        $accessed = $hash->getAccessed();\n+        foreach ($hash as $k => $v) {\n+            if (!isset($accessed[$k])) {\n+                trigger_error(\"String hash key '$k' not used by builder\", E_USER_NOTICE);\n+            }\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/Validator.php",
          "status": "added",
          "additions": 248,
          "deletions": 0,
          "patch": "@@ -0,0 +1,248 @@\n+<?php\n+\n+/**\n+ * Performs validations on HTMLPurifier_ConfigSchema_Interchange\n+ *\n+ * @note If you see '// handled by InterchangeBuilder', that means a\n+ *       design decision in that class would prevent this validation from\n+ *       ever being necessary. We have them anyway, however, for\n+ *       redundancy.\n+ */\n+class HTMLPurifier_ConfigSchema_Validator\n+{\n+\n+    /**\n+     * @type HTMLPurifier_ConfigSchema_Interchange\n+     */\n+    protected $interchange;\n+\n+    /**\n+     * @type array\n+     */\n+    protected $aliases;\n+\n+    /**\n+     * Context-stack to provide easy to read error messages.\n+     * @type array\n+     */\n+    protected $context = array();\n+\n+    /**\n+     * to test default's type.\n+     * @type HTMLPurifier_VarParser\n+     */\n+    protected $parser;\n+\n+    public function __construct()\n+    {\n+        $this->parser = new HTMLPurifier_VarParser();\n+    }\n+\n+    /**\n+     * Validates a fully-formed interchange object.\n+     * @param HTMLPurifier_ConfigSchema_Interchange $interchange\n+     * @return bool\n+     */\n+    public function validate($interchange)\n+    {\n+        $this->interchange = $interchange;\n+        $this->aliases = array();\n+        // PHP is a bit lax with integer <=> string conversions in\n+        // arrays, so we don't use the identical !== comparison\n+        foreach ($interchange->directives as $i => $directive) {\n+            $id = $directive->id->toString();\n+            if ($i != $id) {\n+                $this->error(false, \"Integrity violation: key '$i' does not match internal id '$id'\");\n+            }\n+            $this->validateDirective($directive);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Validates a HTMLPurifier_ConfigSchema_Interchange_Id object.\n+     * @param HTMLPurifier_ConfigSchema_Interchange_Id $id\n+     */\n+    public function validateId($id)\n+    {\n+        $id_string = $id->toString();\n+        $this->context[] = \"id '$id_string'\";\n+        if (!$id instanceof HTMLPurifier_ConfigSchema_Interchange_Id) {\n+            // handled by InterchangeBuilder\n+            $this->error(false, 'is not an instance of HTMLPurifier_ConfigSchema_Interchange_Id');\n+        }\n+        // keys are now unconstrained (we might want to narrow down to A-Za-z0-9.)\n+        // we probably should check that it has at least one namespace\n+        $this->with($id, 'key')\n+            ->assertNotEmpty()\n+            ->assertIsString(); // implicit assertIsString handled by InterchangeBuilder\n+        array_pop($this->context);\n+    }\n+\n+    /**\n+     * Validates a HTMLPurifier_ConfigSchema_Interchange_Directive object.\n+     * @param HTMLPurifier_ConfigSchema_Interchange_Directive $d\n+     */\n+    public function validateDirective($d)\n+    {\n+        $id = $d->id->toString();\n+        $this->context[] = \"directive '$id'\";\n+        $this->validateId($d->id);\n+\n+        $this->with($d, 'description')\n+            ->assertNotEmpty();\n+\n+        // BEGIN - handled by InterchangeBuilder\n+        $this->with($d, 'type')\n+            ->assertNotEmpty();\n+        $this->with($d, 'typeAllowsNull')\n+            ->assertIsBool();\n+        try {\n+            // This also tests validity of $d->type\n+            $this->parser->parse($d->default, $d->type, $d->typeAllowsNull);\n+        } catch (HTMLPurifier_VarParserException $e) {\n+            $this->error('default', 'had error: ' . $e->getMessage());\n+        }\n+        // END - handled by InterchangeBuilder\n+\n+        if (!is_null($d->allowed) || !empty($d->valueAliases)) {\n+            // allowed and valueAliases require that we be dealing with\n+            // strings, so check for that early.\n+            $d_int = HTMLPurifier_VarParser::$types[$d->type];\n+            if (!isset(HTMLPurifier_VarParser::$stringTypes[$d_int])) {\n+                $this->error('type', 'must be a string type when used with allowed or value aliases');\n+            }\n+        }\n+\n+        $this->validateDirectiveAllowed($d);\n+        $this->validateDirectiveValueAliases($d);\n+        $this->validateDirectiveAliases($d);\n+\n+        array_pop($this->context);\n+    }\n+\n+    /**\n+     * Extra validation if $allowed member variable of\n+     * HTMLPurifier_ConfigSchema_Interchange_Directive is defined.\n+     * @param HTMLPurifier_ConfigSchema_Interchange_Directive $d\n+     */\n+    public function validateDirectiveAllowed($d)\n+    {\n+        if (is_null($d->allowed)) {\n+            return;\n+        }\n+        $this->with($d, 'allowed')\n+            ->assertNotEmpty()\n+            ->assertIsLookup(); // handled by InterchangeBuilder\n+        if (is_string($d->default) && !isset($d->allowed[$d->default])) {\n+            $this->error('default', 'must be an allowed value');\n+        }\n+        $this->context[] = 'allowed';\n+        foreach ($d->allowed as $val => $x) {\n+            if (!is_string($val)) {\n+                $this->error(\"value $val\", 'must be a string');\n+            }\n+        }\n+        array_pop($this->context);\n+    }\n+\n+    /**\n+     * Extra validation if $valueAliases member variable of\n+     * HTMLPurifier_ConfigSchema_Interchange_Directive is defined.\n+     * @param HTMLPurifier_ConfigSchema_Interchange_Directive $d\n+     */\n+    public function validateDirectiveValueAliases($d)\n+    {\n+        if (is_null($d->valueAliases)) {\n+            return;\n+        }\n+        $this->with($d, 'valueAliases')\n+            ->assertIsArray(); // handled by InterchangeBuilder\n+        $this->context[] = 'valueAliases';\n+        foreach ($d->valueAliases as $alias => $real) {\n+            if (!is_string($alias)) {\n+                $this->error(\"alias $alias\", 'must be a string');\n+            }\n+            if (!is_string($real)) {\n+                $this->error(\"alias target $real from alias '$alias'\", 'must be a string');\n+            }\n+            if ($alias === $real) {\n+                $this->error(\"alias '$alias'\", \"must not be an alias to itself\");\n+            }\n+        }\n+        if (!is_null($d->allowed)) {\n+            foreach ($d->valueAliases as $alias => $real) {\n+                if (isset($d->allowed[$alias])) {\n+                    $this->error(\"alias '$alias'\", 'must not be an allowed value');\n+                } elseif (!isset($d->allowed[$real])) {\n+                    $this->error(\"alias '$alias'\", 'must be an alias to an allowed value');\n+                }\n+            }\n+        }\n+        array_pop($this->context);\n+    }\n+\n+    /**\n+     * Extra validation if $aliases member variable of\n+     * HTMLPurifier_ConfigSchema_Interchange_Directive is defined.\n+     * @param HTMLPurifier_ConfigSchema_Interchange_Directive $d\n+     */\n+    public function validateDirectiveAliases($d)\n+    {\n+        $this->with($d, 'aliases')\n+            ->assertIsArray(); // handled by InterchangeBuilder\n+        $this->context[] = 'aliases';\n+        foreach ($d->aliases as $alias) {\n+            $this->validateId($alias);\n+            $s = $alias->toString();\n+            if (isset($this->interchange->directives[$s])) {\n+                $this->error(\"alias '$s'\", 'collides with another directive');\n+            }\n+            if (isset($this->aliases[$s])) {\n+                $other_directive = $this->aliases[$s];\n+                $this->error(\"alias '$s'\", \"collides with alias for directive '$other_directive'\");\n+            }\n+            $this->aliases[$s] = $d->id->toString();\n+        }\n+        array_pop($this->context);\n+    }\n+\n+    // protected helper functions\n+\n+    /**\n+     * Convenience function for generating HTMLPurifier_ConfigSchema_ValidatorAtom\n+     * for validating simple member variables of objects.\n+     * @param $obj\n+     * @param $member\n+     * @return HTMLPurifier_ConfigSchema_ValidatorAtom\n+     */\n+    protected function with($obj, $member)\n+    {\n+        return new HTMLPurifier_ConfigSchema_ValidatorAtom($this->getFormattedContext(), $obj, $member);\n+    }\n+\n+    /**\n+     * Emits an error, providing helpful context.\n+     * @throws HTMLPurifier_ConfigSchema_Exception\n+     */\n+    protected function error($target, $msg)\n+    {\n+        if ($target !== false) {\n+            $prefix = ucfirst($target) . ' in ' . $this->getFormattedContext();\n+        } else {\n+            $prefix = ucfirst($this->getFormattedContext());\n+        }\n+        throw new HTMLPurifier_ConfigSchema_Exception(trim($prefix . ' ' . $msg));\n+    }\n+\n+    /**\n+     * Returns a formatted context string.\n+     * @return string\n+     */\n+    protected function getFormattedContext()\n+    {\n+        return implode(' in ', array_reverse($this->context));\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/ValidatorAtom.php",
          "status": "added",
          "additions": 130,
          "deletions": 0,
          "patch": "@@ -0,0 +1,130 @@\n+<?php\n+\n+/**\n+ * Fluent interface for validating the contents of member variables.\n+ * This should be immutable. See HTMLPurifier_ConfigSchema_Validator for\n+ * use-cases. We name this an 'atom' because it's ONLY for validations that\n+ * are independent and usually scalar.\n+ */\n+class HTMLPurifier_ConfigSchema_ValidatorAtom\n+{\n+    /**\n+     * @type string\n+     */\n+    protected $context;\n+\n+    /**\n+     * @type object\n+     */\n+    protected $obj;\n+\n+    /**\n+     * @type string\n+     */\n+    protected $member;\n+\n+    /**\n+     * @type mixed\n+     */\n+    protected $contents;\n+\n+    public function __construct($context, $obj, $member)\n+    {\n+        $this->context = $context;\n+        $this->obj = $obj;\n+        $this->member = $member;\n+        $this->contents =& $obj->$member;\n+    }\n+\n+    /**\n+     * @return HTMLPurifier_ConfigSchema_ValidatorAtom\n+     */\n+    public function assertIsString()\n+    {\n+        if (!is_string($this->contents)) {\n+            $this->error('must be a string');\n+        }\n+        return $this;\n+    }\n+\n+    /**\n+     * @return HTMLPurifier_ConfigSchema_ValidatorAtom\n+     */\n+    public function assertIsBool()\n+    {\n+        if (!is_bool($this->contents)) {\n+            $this->error('must be a boolean');\n+        }\n+        return $this;\n+    }\n+\n+    /**\n+     * @return HTMLPurifier_ConfigSchema_ValidatorAtom\n+     */\n+    public function assertIsArray()\n+    {\n+        if (!is_array($this->contents)) {\n+            $this->error('must be an array');\n+        }\n+        return $this;\n+    }\n+\n+    /**\n+     * @return HTMLPurifier_ConfigSchema_ValidatorAtom\n+     */\n+    public function assertNotNull()\n+    {\n+        if ($this->contents === null) {\n+            $this->error('must not be null');\n+        }\n+        return $this;\n+    }\n+\n+    /**\n+     * @return HTMLPurifier_ConfigSchema_ValidatorAtom\n+     */\n+    public function assertAlnum()\n+    {\n+        $this->assertIsString();\n+        if (!ctype_alnum($this->contents)) {\n+            $this->error('must be alphanumeric');\n+        }\n+        return $this;\n+    }\n+\n+    /**\n+     * @return HTMLPurifier_ConfigSchema_ValidatorAtom\n+     */\n+    public function assertNotEmpty()\n+    {\n+        if (empty($this->contents)) {\n+            $this->error('must not be empty');\n+        }\n+        return $this;\n+    }\n+\n+    /**\n+     * @return HTMLPurifier_ConfigSchema_ValidatorAtom\n+     */\n+    public function assertIsLookup()\n+    {\n+        $this->assertIsArray();\n+        foreach ($this->contents as $v) {\n+            if ($v !== true) {\n+                $this->error('must be a lookup array');\n+            }\n+        }\n+        return $this;\n+    }\n+\n+    /**\n+     * @param string $msg\n+     * @throws HTMLPurifier_ConfigSchema_Exception\n+     */\n+    protected function error($msg)\n+    {\n+        throw new HTMLPurifier_ConfigSchema_Exception(ucfirst($this->member) . ' in ' . $this->context . ' ' . $msg);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema.ser",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Attr.AllowedClasses.txt",
          "status": "added",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -0,0 +1,8 @@\n+Attr.AllowedClasses\n+TYPE: lookup/null\n+VERSION: 4.0.0\n+DEFAULT: null\n+--DESCRIPTION--\n+List of allowed class values in the class attribute. By default, this is null,\n+which means all classes are allowed.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Attr.AllowedFrameTargets.txt",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+Attr.AllowedFrameTargets\n+TYPE: lookup\n+DEFAULT: array()\n+--DESCRIPTION--\n+Lookup table of all allowed link frame targets.  Some commonly used link\n+targets include _blank, _self, _parent and _top. Values should be\n+lowercase, as validation will be done in a case-sensitive manner despite\n+W3C's recommendation. XHTML 1.0 Strict does not permit the target attribute\n+so this directive will have no effect in that doctype. XHTML 1.1 does not\n+enable the Target module by default, you will have to manually enable it\n+(see the module documentation for more details.)\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Attr.AllowedRel.txt",
          "status": "added",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -0,0 +1,9 @@\n+Attr.AllowedRel\n+TYPE: lookup\n+VERSION: 1.6.0\n+DEFAULT: array()\n+--DESCRIPTION--\n+List of allowed forward document relationships in the rel attribute. Common\n+values may be nofollow or print. By default, this is empty, meaning that no\n+document relationships are allowed.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Attr.AllowedRev.txt",
          "status": "added",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -0,0 +1,9 @@\n+Attr.AllowedRev\n+TYPE: lookup\n+VERSION: 1.6.0\n+DEFAULT: array()\n+--DESCRIPTION--\n+List of allowed reverse document relationships in the rev attribute. This\n+attribute is a bit of an edge-case; if you don't know what it is for, stay\n+away.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Attr.ClassUseCDATA.txt",
          "status": "added",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -0,0 +1,19 @@\n+Attr.ClassUseCDATA\n+TYPE: bool/null\n+DEFAULT: null\n+VERSION: 4.0.0\n+--DESCRIPTION--\n+If null, class will auto-detect the doctype and, if matching XHTML 1.1 or\n+XHTML 2.0, will use the restrictive NMTOKENS specification of class. Otherwise,\n+it will use a relaxed CDATA definition.  If true, the relaxed CDATA definition\n+is forced; if false, the NMTOKENS definition is forced.  To get behavior\n+of HTML Purifier prior to 4.0.0, set this directive to false.\n+\n+Some rational behind the auto-detection:\n+in previous versions of HTML Purifier, it was assumed that the form of\n+class was NMTOKENS, as specified by the XHTML Modularization (representing\n+XHTML 1.1 and XHTML 2.0).  The DTDs for HTML 4.01 and XHTML 1.0, however\n+specify class as CDATA.  HTML 5 effectively defines it as CDATA, but\n+with the additional constraint that each name should be unique (this is not\n+explicitly outlined in previous specifications).\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Attr.DefaultImageAlt.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+Attr.DefaultImageAlt\n+TYPE: string/null\n+DEFAULT: null\n+VERSION: 3.2.0\n+--DESCRIPTION--\n+This is the content of the alt tag of an image if the user had not\n+previously specified an alt attribute.  This applies to all images without\n+a valid alt attribute, as opposed to %Attr.DefaultInvalidImageAlt, which\n+only applies to invalid images, and overrides in the case of an invalid image.\n+Default behavior with null is to use the basename of the src tag for the alt.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Attr.DefaultInvalidImage.txt",
          "status": "added",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -0,0 +1,9 @@\n+Attr.DefaultInvalidImage\n+TYPE: string\n+DEFAULT: ''\n+--DESCRIPTION--\n+This is the default image an img tag will be pointed to if it does not have\n+a valid src attribute.  In future versions, we may allow the image tag to\n+be removed completely, but due to design issues, this is not possible right\n+now.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Attr.DefaultInvalidImageAlt.txt",
          "status": "added",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -0,0 +1,8 @@\n+Attr.DefaultInvalidImageAlt\n+TYPE: string\n+DEFAULT: 'Invalid image'\n+--DESCRIPTION--\n+This is the content of the alt tag of an invalid image if the user had not\n+previously specified an alt attribute.  It has no effect when the image is\n+valid but there was no alt attribute present.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Attr.DefaultTextDir.txt",
          "status": "added",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -0,0 +1,10 @@\n+Attr.DefaultTextDir\n+TYPE: string\n+DEFAULT: 'ltr'\n+--DESCRIPTION--\n+Defines the default text direction (ltr or rtl) of the document being\n+parsed.  This generally is the same as the value of the dir attribute in\n+HTML, or ltr if that is not specified.\n+--ALLOWED--\n+'ltr', 'rtl'\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Attr.EnableID.txt",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+Attr.EnableID\n+TYPE: bool\n+DEFAULT: false\n+VERSION: 1.2.0\n+--DESCRIPTION--\n+Allows the ID attribute in HTML.  This is disabled by default due to the\n+fact that without proper configuration user input can easily break the\n+validation of a webpage by specifying an ID that is already on the\n+surrounding HTML.  If you don't mind throwing caution to the wind, enable\n+this directive, but I strongly recommend you also consider blacklisting IDs\n+you use (%Attr.IDBlacklist) or prefixing all user supplied IDs\n+(%Attr.IDPrefix).  When set to true HTML Purifier reverts to the behavior of\n+pre-1.2.0 versions.\n+--ALIASES--\n+HTML.EnableAttrID\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Attr.ForbiddenClasses.txt",
          "status": "added",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -0,0 +1,8 @@\n+Attr.ForbiddenClasses\n+TYPE: lookup\n+VERSION: 4.0.0\n+DEFAULT: array()\n+--DESCRIPTION--\n+List of forbidden class values in the class attribute. By default, this is\n+empty, which means that no classes are forbidden. See also %Attr.AllowedClasses.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Attr.ID.HTML5.txt",
          "status": "added",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -0,0 +1,10 @@\n+Attr.ID.HTML5\n+TYPE: bool/null\n+DEFAULT: null\n+VERSION: 4.8.0\n+--DESCRIPTION--\n+In HTML5, restrictions on the format of the id attribute have been significantly\n+relaxed, such that any string is valid so long as it contains no spaces and\n+is at least one character.  In lieu of a general HTML5 compatibility flag,\n+set this configuration directive to true to use the relaxed rules.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Attr.IDBlacklist.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Attr.IDBlacklist\n+TYPE: list\n+DEFAULT: array()\n+DESCRIPTION: Array of IDs not allowed in the document.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Attr.IDBlacklistRegexp.txt",
          "status": "added",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -0,0 +1,9 @@\n+Attr.IDBlacklistRegexp\n+TYPE: string/null\n+VERSION: 1.6.0\n+DEFAULT: NULL\n+--DESCRIPTION--\n+PCRE regular expression to be matched against all IDs. If the expression is\n+matches, the ID is rejected. Use this with care: may cause significant\n+degradation. ID matching is done after all other validation.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Attr.IDPrefix.txt",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+Attr.IDPrefix\n+TYPE: string\n+VERSION: 1.2.0\n+DEFAULT: ''\n+--DESCRIPTION--\n+String to prefix to IDs.  If you have no idea what IDs your pages may use,\n+you may opt to simply add a prefix to all user-submitted ID attributes so\n+that they are still usable, but will not conflict with core page IDs.\n+Example: setting the directive to 'user_' will result in a user submitted\n+'foo' to become 'user_foo'  Be sure to set %HTML.EnableAttrID to true\n+before using this.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Attr.IDPrefixLocal.txt",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+Attr.IDPrefixLocal\n+TYPE: string\n+VERSION: 1.2.0\n+DEFAULT: ''\n+--DESCRIPTION--\n+Temporary prefix for IDs used in conjunction with %Attr.IDPrefix.  If you\n+need to allow multiple sets of user content on web page, you may need to\n+have a seperate prefix that changes with each iteration.  This way,\n+seperately submitted user content displayed on the same page doesn't\n+clobber each other. Ideal values are unique identifiers for the content it\n+represents (i.e. the id of the row in the database). Be sure to add a\n+seperator (like an underscore) at the end.  Warning: this directive will\n+not work unless %Attr.IDPrefix is set to a non-empty value!\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/AutoFormat.AutoParagraph.txt",
          "status": "added",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -0,0 +1,31 @@\n+AutoFormat.AutoParagraph\n+TYPE: bool\n+VERSION: 2.0.1\n+DEFAULT: false\n+--DESCRIPTION--\n+\n+<p>\n+  This directive turns on auto-paragraphing, where double newlines are\n+  converted in to paragraphs whenever possible. Auto-paragraphing:\n+</p>\n+<ul>\n+  <li>Always applies to inline elements or text in the root node,</li>\n+  <li>Applies to inline elements or text with double newlines in nodes\n+      that allow paragraph tags,</li>\n+  <li>Applies to double newlines in paragraph tags</li>\n+</ul>\n+<p>\n+  <code>p</code> tags must be allowed for this directive to take effect.\n+  We do not use <code>br</code> tags for paragraphing, as that is\n+  semantically incorrect.\n+</p>\n+<p>\n+  To prevent auto-paragraphing as a content-producer, refrain from using\n+  double-newlines except to specify a new paragraph or in contexts where\n+  it has special meaning (whitespace usually has no meaning except in\n+  tags like <code>pre</code>, so this should not be difficult.) To prevent\n+  the paragraphing of inline text adjacent to block elements, wrap them\n+  in <code>div</code> tags (the behavior is slightly different outside of\n+  the root node.)\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/AutoFormat.Custom.txt",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+AutoFormat.Custom\n+TYPE: list\n+VERSION: 2.0.1\n+DEFAULT: array()\n+--DESCRIPTION--\n+\n+<p>\n+  This directive can be used to add custom auto-format injectors.\n+  Specify an array of injector names (class name minus the prefix)\n+  or concrete implementations. Injector class must exist.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/AutoFormat.DisplayLinkURI.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+AutoFormat.DisplayLinkURI\n+TYPE: bool\n+VERSION: 3.2.0\n+DEFAULT: false\n+--DESCRIPTION--\n+<p>\n+  This directive turns on the in-text display of URIs in &lt;a&gt; tags, and disables\n+  those links. For example, <a href=\"http://example.com\">example</a> becomes\n+  example (<a>http://example.com</a>).\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/AutoFormat.Linkify.txt",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+AutoFormat.Linkify\n+TYPE: bool\n+VERSION: 2.0.1\n+DEFAULT: false\n+--DESCRIPTION--\n+\n+<p>\n+  This directive turns on linkification, auto-linking http, ftp and\n+  https URLs. <code>a</code> tags with the <code>href</code> attribute\n+  must be allowed.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/AutoFormat.PurifierLinkify.DocURL.txt",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+AutoFormat.PurifierLinkify.DocURL\n+TYPE: string\n+VERSION: 2.0.1\n+DEFAULT: '#%s'\n+ALIASES: AutoFormatParam.PurifierLinkifyDocURL\n+--DESCRIPTION--\n+<p>\n+  Location of configuration documentation to link to, let %s substitute\n+  into the configuration's namespace and directive names sans the percent\n+  sign.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/AutoFormat.PurifierLinkify.txt",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+AutoFormat.PurifierLinkify\n+TYPE: bool\n+VERSION: 2.0.1\n+DEFAULT: false\n+--DESCRIPTION--\n+\n+<p>\n+  Internal auto-formatter that converts configuration directives in\n+  syntax <a>%Namespace.Directive</a> to links. <code>a</code> tags\n+  with the <code>href</code> attribute must be allowed.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/AutoFormat.RemoveEmpty.Predicate.txt",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+AutoFormat.RemoveEmpty.Predicate\n+TYPE: hash\n+VERSION: 4.7.0\n+DEFAULT: array('colgroup' => array(), 'th' => array(), 'td' => array(), 'iframe' => array('src'))\n+--DESCRIPTION--\n+<p>\n+  Given that an element has no contents, it will be removed by default, unless\n+  this predicate dictates otherwise.  The predicate can either be an associative\n+  map from tag name to list of attributes that must be present for the element\n+  to be considered preserved: thus, the default always preserves <code>colgroup</code>,\n+  <code>th</code> and <code>td</code>, and also <code>iframe</code> if it\n+  has a <code>src</code>.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/AutoFormat.RemoveEmpty.RemoveNbsp.Exceptions.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+AutoFormat.RemoveEmpty.RemoveNbsp.Exceptions\n+TYPE: lookup\n+VERSION: 4.0.0\n+DEFAULT: array('td' => true, 'th' => true)\n+--DESCRIPTION--\n+<p>\n+  When %AutoFormat.RemoveEmpty and %AutoFormat.RemoveEmpty.RemoveNbsp\n+  are enabled, this directive defines what HTML elements should not be\n+  removede if they have only a non-breaking space in them.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/AutoFormat.RemoveEmpty.RemoveNbsp.txt",
          "status": "added",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -0,0 +1,15 @@\n+AutoFormat.RemoveEmpty.RemoveNbsp\n+TYPE: bool\n+VERSION: 4.0.0\n+DEFAULT: false\n+--DESCRIPTION--\n+<p>\n+  When enabled, HTML Purifier will treat any elements that contain only\n+  non-breaking spaces as well as regular whitespace as empty, and remove\n+  them when %AutoForamt.RemoveEmpty is enabled.\n+</p>\n+<p>\n+  See %AutoFormat.RemoveEmpty.RemoveNbsp.Exceptions for a list of elements\n+  that don't have this behavior applied to them.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/AutoFormat.RemoveEmpty.txt",
          "status": "added",
          "additions": 46,
          "deletions": 0,
          "patch": "@@ -0,0 +1,46 @@\n+AutoFormat.RemoveEmpty\n+TYPE: bool\n+VERSION: 3.2.0\n+DEFAULT: false\n+--DESCRIPTION--\n+<p>\n+  When enabled, HTML Purifier will attempt to remove empty elements that\n+  contribute no semantic information to the document. The following types\n+  of nodes will be removed:\n+</p>\n+<ul><li>\n+    Tags with no attributes and no content, and that are not empty\n+    elements (remove <code>&lt;a&gt;&lt;/a&gt;</code> but not\n+    <code>&lt;br /&gt;</code>), and\n+  </li>\n+  <li>\n+    Tags with no content, except for:<ul>\n+      <li>The <code>colgroup</code> element, or</li>\n+      <li>\n+        Elements with the <code>id</code> or <code>name</code> attribute,\n+        when those attributes are permitted on those elements.\n+      </li>\n+    </ul></li>\n+</ul>\n+<p>\n+  Please be very careful when using this functionality; while it may not\n+  seem that empty elements contain useful information, they can alter the\n+  layout of a document given appropriate styling. This directive is most\n+  useful when you are processing machine-generated HTML, please avoid using\n+  it on regular user HTML.\n+</p>\n+<p>\n+  Elements that contain only whitespace will be treated as empty. Non-breaking\n+  spaces, however, do not count as whitespace. See\n+  %AutoFormat.RemoveEmpty.RemoveNbsp for alternate behavior.\n+</p>\n+<p>\n+  This algorithm is not perfect; you may still notice some empty tags,\n+  particularly if a node had elements, but those elements were later removed\n+  because they were not permitted in that context, or tags that, after\n+  being auto-closed by another tag, where empty. This is for safety reasons\n+  to prevent clever code from breaking validation. The general rule of thumb:\n+  if a tag looked empty on the way in, it will get removed; if HTML Purifier\n+  made it empty, it will stay.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/AutoFormat.RemoveSpansWithoutAttributes.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+AutoFormat.RemoveSpansWithoutAttributes\n+TYPE: bool\n+VERSION: 4.0.1\n+DEFAULT: false\n+--DESCRIPTION--\n+<p>\n+  This directive causes <code>span</code> tags without any attributes\n+  to be removed. It will also remove spans that had all attributes\n+  removed during processing.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/CSS.AllowDuplicates.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+CSS.AllowDuplicates\n+TYPE: bool\n+DEFAULT: false\n+VERSION: 4.8.0\n+--DESCRIPTION--\n+<p>\n+  By default, HTML Purifier removes duplicate CSS properties,\n+  like <code>color:red; color:blue</code>.  If this is set to\n+  true, duplicate properties are allowed.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/CSS.AllowImportant.txt",
          "status": "added",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -0,0 +1,8 @@\n+CSS.AllowImportant\n+TYPE: bool\n+DEFAULT: false\n+VERSION: 3.1.0\n+--DESCRIPTION--\n+This parameter determines whether or not !important cascade modifiers should\n+be allowed in user CSS. If false, !important will stripped.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/CSS.AllowTricky.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+CSS.AllowTricky\n+TYPE: bool\n+DEFAULT: false\n+VERSION: 3.1.0\n+--DESCRIPTION--\n+This parameter determines whether or not to allow \"tricky\" CSS properties and\n+values. Tricky CSS properties/values can drastically modify page layout or\n+be used for deceptive practices but do not directly constitute a security risk.\n+For example, <code>display:none;</code> is considered a tricky property that\n+will only be allowed if this directive is set to true.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/CSS.AllowedFonts.txt",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+CSS.AllowedFonts\n+TYPE: lookup/null\n+VERSION: 4.3.0\n+DEFAULT: NULL\n+--DESCRIPTION--\n+<p>\n+    Allows you to manually specify a set of allowed fonts.  If\n+    <code>NULL</code>, all fonts are allowed.  This directive\n+    affects generic names (serif, sans-serif, monospace, cursive,\n+    fantasy) as well as specific font families.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/CSS.AllowedProperties.txt",
          "status": "added",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -0,0 +1,18 @@\n+CSS.AllowedProperties\n+TYPE: lookup/null\n+VERSION: 3.1.0\n+DEFAULT: NULL\n+--DESCRIPTION--\n+\n+<p>\n+    If HTML Purifier's style attributes set is unsatisfactory for your needs,\n+    you can overload it with your own list of tags to allow.  Note that this\n+    method is subtractive: it does its job by taking away from HTML Purifier\n+    usual feature set, so you cannot add an attribute that HTML Purifier never\n+    supported in the first place.\n+</p>\n+<p>\n+    <strong>Warning:</strong> If another directive conflicts with the\n+    elements here, <em>that</em> directive will win and override.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/CSS.DefinitionRev.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+CSS.DefinitionRev\n+TYPE: int\n+VERSION: 2.0.0\n+DEFAULT: 1\n+--DESCRIPTION--\n+\n+<p>\n+    Revision identifier for your custom definition. See\n+    %HTML.DefinitionRev for details.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/CSS.ForbiddenProperties.txt",
          "status": "added",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -0,0 +1,13 @@\n+CSS.ForbiddenProperties\n+TYPE: lookup\n+VERSION: 4.2.0\n+DEFAULT: array()\n+--DESCRIPTION--\n+<p>\n+    This is the logical inverse of %CSS.AllowedProperties, and it will\n+    override that directive or any other directive.  If possible,\n+    %CSS.AllowedProperties is recommended over this directive,\n+    because it can sometimes be difficult to tell whether or not you've\n+    forbidden all of the CSS properties you truly would like to disallow.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/CSS.MaxImgLength.txt",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+CSS.MaxImgLength\n+TYPE: string/null\n+DEFAULT: '1200px'\n+VERSION: 3.1.1\n+--DESCRIPTION--\n+<p>\n+ This parameter sets the maximum allowed length on <code>img</code> tags,\n+ effectively the <code>width</code> and <code>height</code> properties.\n+ Only absolute units of measurement (in, pt, pc, mm, cm) and pixels (px) are allowed. This is\n+ in place to prevent imagecrash attacks, disable with null at your own risk.\n+ This directive is similar to %HTML.MaxImgLength, and both should be\n+ concurrently edited, although there are\n+ subtle differences in the input format (the CSS max is a number with\n+ a unit).\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/CSS.Proprietary.txt",
          "status": "added",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -0,0 +1,10 @@\n+CSS.Proprietary\n+TYPE: bool\n+VERSION: 3.0.0\n+DEFAULT: false\n+--DESCRIPTION--\n+\n+<p>\n+    Whether or not to allow safe, proprietary CSS values.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/CSS.Trusted.txt",
          "status": "added",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -0,0 +1,9 @@\n+CSS.Trusted\n+TYPE: bool\n+VERSION: 4.2.1\n+DEFAULT: false\n+--DESCRIPTION--\n+Indicates whether or not the user's CSS input is trusted or not. If the\n+input is trusted, a more expansive set of allowed properties.  See\n+also %HTML.Trusted.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Cache.DefinitionImpl.txt",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+Cache.DefinitionImpl\n+TYPE: string/null\n+VERSION: 2.0.0\n+DEFAULT: 'Serializer'\n+--DESCRIPTION--\n+\n+This directive defines which method to use when caching definitions,\n+the complex data-type that makes HTML Purifier tick. Set to null\n+to disable caching (not recommended, as you will see a definite\n+performance degradation).\n+\n+--ALIASES--\n+Core.DefinitionCache\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Cache.SerializerPath.txt",
          "status": "added",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -0,0 +1,13 @@\n+Cache.SerializerPath\n+TYPE: string/null\n+VERSION: 2.0.0\n+DEFAULT: NULL\n+--DESCRIPTION--\n+\n+<p>\n+    Absolute path with no trailing slash to store serialized definitions in.\n+    Default is within the\n+    HTML Purifier library inside DefinitionCache/Serializer. This\n+    path must be writable by the webserver.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Cache.SerializerPermissions.txt",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+Cache.SerializerPermissions\n+TYPE: int/null\n+VERSION: 4.3.0\n+DEFAULT: 0755\n+--DESCRIPTION--\n+\n+<p>\n+    Directory permissions of the files and directories created inside\n+    the DefinitionCache/Serializer or other custom serializer path.\n+</p>\n+<p>\n+    In HTML Purifier 4.8.0, this also supports <code>NULL</code>,\n+    which means that no chmod'ing or directory creation shall\n+    occur.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.AggressivelyFixLt.txt",
          "status": "added",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -0,0 +1,18 @@\n+Core.AggressivelyFixLt\n+TYPE: bool\n+VERSION: 2.1.0\n+DEFAULT: true\n+--DESCRIPTION--\n+<p>\n+    This directive enables aggressive pre-filter fixes HTML Purifier can\n+    perform in order to ensure that open angled-brackets do not get killed\n+    during parsing stage. Enabling this will result in two preg_replace_callback\n+    calls and at least two preg_replace calls for every HTML document parsed;\n+    if your users make very well-formed HTML, you can set this directive false.\n+    This has no effect when DirectLex is used.\n+</p>\n+<p>\n+    <strong>Notice:</strong> This directive's default turned from false to true\n+    in HTML Purifier 3.2.0.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.AllowHostnameUnderscore.txt",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+Core.AllowHostnameUnderscore\n+TYPE: bool\n+VERSION: 4.6.0\n+DEFAULT: false\n+--DESCRIPTION--\n+<p>\n+    By RFC 1123, underscores are not permitted in host names.\n+    (This is in contrast to the specification for DNS, RFC\n+    2181, which allows underscores.)\n+    However, most browsers do the right thing when faced with\n+    an underscore in the host name, and so some poorly written\n+    websites are written with the expectation this should work.\n+    Setting this parameter to true relaxes our allowed character\n+    check so that underscores are permitted.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.CollectErrors.txt",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+Core.CollectErrors\n+TYPE: bool\n+VERSION: 2.0.0\n+DEFAULT: false\n+--DESCRIPTION--\n+\n+Whether or not to collect errors found while filtering the document. This\n+is a useful way to give feedback to your users. <strong>Warning:</strong>\n+Currently this feature is very patchy and experimental, with lots of\n+possible error messages not yet implemented. It will not cause any\n+problems, but it may not help your users either.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.ColorKeywords.txt",
          "status": "added",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -0,0 +1,29 @@\n+Core.ColorKeywords\n+TYPE: hash\n+VERSION: 2.0.0\n+--DEFAULT--\n+array (\n+  'maroon' => '#800000',\n+  'red' => '#FF0000',\n+  'orange' => '#FFA500',\n+  'yellow' => '#FFFF00',\n+  'olive' => '#808000',\n+  'purple' => '#800080',\n+  'fuchsia' => '#FF00FF',\n+  'white' => '#FFFFFF',\n+  'lime' => '#00FF00',\n+  'green' => '#008000',\n+  'navy' => '#000080',\n+  'blue' => '#0000FF',\n+  'aqua' => '#00FFFF',\n+  'teal' => '#008080',\n+  'black' => '#000000',\n+  'silver' => '#C0C0C0',\n+  'gray' => '#808080',\n+)\n+--DESCRIPTION--\n+\n+Lookup array of color names to six digit hexadecimal number corresponding\n+to color, with preceding hash mark. Used when parsing colors.  The lookup\n+is done in a case-insensitive manner.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.ConvertDocumentToFragment.txt",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+Core.ConvertDocumentToFragment\n+TYPE: bool\n+DEFAULT: true\n+--DESCRIPTION--\n+\n+This parameter determines whether or not the filter should convert\n+input that is a full document with html and body tags to a fragment\n+of just the contents of a body tag. This parameter is simply something\n+HTML Purifier can do during an edge-case: for most inputs, this\n+processing is not necessary.\n+\n+--ALIASES--\n+Core.AcceptFullDocuments\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.DirectLexLineNumberSyncInterval.txt",
          "status": "added",
          "additions": 17,
          "deletions": 0,
          "patch": "@@ -0,0 +1,17 @@\n+Core.DirectLexLineNumberSyncInterval\n+TYPE: int\n+VERSION: 2.0.0\n+DEFAULT: 0\n+--DESCRIPTION--\n+\n+<p>\n+  Specifies the number of tokens the DirectLex line number tracking\n+  implementations should process before attempting to resyncronize the\n+  current line count by manually counting all previous new-lines. When\n+  at 0, this functionality is disabled. Lower values will decrease\n+  performance, and this is only strictly necessary if the counting\n+  algorithm is buggy (in which case you should report it as a bug).\n+  This has no effect when %Core.MaintainLineNumbers is disabled or DirectLex is\n+  not being used.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.DisableExcludes.txt",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+Core.DisableExcludes\n+TYPE: bool\n+DEFAULT: false\n+VERSION: 4.5.0\n+--DESCRIPTION--\n+<p>\n+  This directive disables SGML-style exclusions, e.g. the exclusion of\n+  <code>&lt;object&gt;</code> in any descendant of a\n+  <code>&lt;pre&gt;</code> tag.  Disabling excludes will allow some\n+  invalid documents to pass through HTML Purifier, but HTML Purifier\n+  will also be less likely to accidentally remove large documents during\n+  processing.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.EnableIDNA.txt",
          "status": "added",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -0,0 +1,9 @@\n+Core.EnableIDNA\n+TYPE: bool\n+DEFAULT: false\n+VERSION: 4.4.0\n+--DESCRIPTION--\n+Allows international domain names in URLs.  This configuration option\n+requires the PEAR Net_IDNA2 module to be installed.  It operates by\n+punycoding any internationalized host names for maximum portability.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.Encoding.txt",
          "status": "added",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -0,0 +1,15 @@\n+Core.Encoding\n+TYPE: istring\n+DEFAULT: 'utf-8'\n+--DESCRIPTION--\n+If for some reason you are unable to convert all webpages to UTF-8, you can\n+use this directive as a stop-gap compatibility change to let HTML Purifier\n+deal with non UTF-8 input.  This technique has notable deficiencies:\n+absolutely no characters outside of the selected character encoding will be\n+preserved, not even the ones that have been ampersand escaped (this is due\n+to a UTF-8 specific <em>feature</em> that automatically resolves all\n+entities), making it pretty useless for anything except the most I18N-blind\n+applications, although %Core.EscapeNonASCIICharacters offers fixes this\n+trouble with another tradeoff. This directive only accepts ISO-8859-1 if\n+iconv is not enabled.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.EscapeInvalidChildren.txt",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+Core.EscapeInvalidChildren\n+TYPE: bool\n+DEFAULT: false\n+--DESCRIPTION--\n+<p><strong>Warning:</strong> this configuration option is no longer does anything as of 4.6.0.</p>\n+\n+<p>When true, a child is found that is not allowed in the context of the\n+parent element will be transformed into text as if it were ASCII. When\n+false, that element and all internal tags will be dropped, though text will\n+be preserved.  There is no option for dropping the element but preserving\n+child nodes.</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.EscapeInvalidTags.txt",
          "status": "added",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -0,0 +1,7 @@\n+Core.EscapeInvalidTags\n+TYPE: bool\n+DEFAULT: false\n+--DESCRIPTION--\n+When true, invalid tags will be written back to the document as plain text.\n+Otherwise, they are silently dropped.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.EscapeNonASCIICharacters.txt",
          "status": "added",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -0,0 +1,13 @@\n+Core.EscapeNonASCIICharacters\n+TYPE: bool\n+VERSION: 1.4.0\n+DEFAULT: false\n+--DESCRIPTION--\n+This directive overcomes a deficiency in %Core.Encoding by blindly\n+converting all non-ASCII characters into decimal numeric entities before\n+converting it to its native encoding. This means that even characters that\n+can be expressed in the non-UTF-8 encoding will be entity-ized, which can\n+be a real downer for encodings like Big5. It also assumes that the ASCII\n+repetoire is available, although this is the case for almost all encodings.\n+Anyway, use UTF-8!\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.HiddenElements.txt",
          "status": "added",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -0,0 +1,19 @@\n+Core.HiddenElements\n+TYPE: lookup\n+--DEFAULT--\n+array (\n+  'script' => true,\n+  'style' => true,\n+)\n+--DESCRIPTION--\n+\n+<p>\n+  This directive is a lookup array of elements which should have their\n+  contents removed when they are not allowed by the HTML definition.\n+  For example, the contents of a <code>script</code> tag are not\n+  normally shown in a document, so if script tags are to be removed,\n+  their contents should be removed to. This is opposed to a <code>b</code>\n+  tag, which defines some presentational changes but does not hide its\n+  contents.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.Language.txt",
          "status": "added",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -0,0 +1,10 @@\n+Core.Language\n+TYPE: string\n+VERSION: 2.0.0\n+DEFAULT: 'en'\n+--DESCRIPTION--\n+\n+ISO 639 language code for localizable things in HTML Purifier to use,\n+which is mainly error reporting. There is currently only an English (en)\n+translation, so this directive is currently useless.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.LexerImpl.txt",
          "status": "added",
          "additions": 34,
          "deletions": 0,
          "patch": "@@ -0,0 +1,34 @@\n+Core.LexerImpl\n+TYPE: mixed/null\n+VERSION: 2.0.0\n+DEFAULT: NULL\n+--DESCRIPTION--\n+\n+<p>\n+  This parameter determines what lexer implementation can be used. The\n+  valid values are:\n+</p>\n+<dl>\n+  <dt><em>null</em></dt>\n+  <dd>\n+    Recommended, the lexer implementation will be auto-detected based on\n+    your PHP-version and configuration.\n+  </dd>\n+  <dt><em>string</em> lexer identifier</dt>\n+  <dd>\n+    This is a slim way of manually overridding the implementation.\n+    Currently recognized values are: DOMLex (the default PHP5\n+implementation)\n+    and DirectLex (the default PHP4 implementation). Only use this if\n+    you know what you are doing: usually, the auto-detection will\n+    manage things for cases you aren't even aware of.\n+  </dd>\n+  <dt><em>object</em> lexer instance</dt>\n+  <dd>\n+    Super-advanced: you can specify your own, custom, implementation that\n+    implements the interface defined by <code>HTMLPurifier_Lexer</code>.\n+    I may remove this option simply because I don't expect anyone\n+    to use it.\n+  </dd>\n+</dl>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.MaintainLineNumbers.txt",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+Core.MaintainLineNumbers\n+TYPE: bool/null\n+VERSION: 2.0.0\n+DEFAULT: NULL\n+--DESCRIPTION--\n+\n+<p>\n+  If true, HTML Purifier will add line number information to all tokens.\n+  This is useful when error reporting is turned on, but can result in\n+  significant performance degradation and should not be used when\n+  unnecessary. This directive must be used with the DirectLex lexer,\n+  as the DOMLex lexer does not (yet) support this functionality.\n+  If the value is null, an appropriate value will be selected based\n+  on other configuration.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.NormalizeNewlines.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+Core.NormalizeNewlines\n+TYPE: bool\n+VERSION: 4.2.0\n+DEFAULT: true\n+--DESCRIPTION--\n+<p>\n+    Whether or not to normalize newlines to the operating\n+    system default.  When <code>false</code>, HTML Purifier\n+    will attempt to preserve mixed newline files.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.RemoveInvalidImg.txt",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+Core.RemoveInvalidImg\n+TYPE: bool\n+DEFAULT: true\n+VERSION: 1.3.0\n+--DESCRIPTION--\n+\n+<p>\n+  This directive enables pre-emptive URI checking in <code>img</code>\n+  tags, as the attribute validation strategy is not authorized to\n+  remove elements from the document. Revert to pre-1.3.0 behavior by setting to false.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.RemoveProcessingInstructions.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+Core.RemoveProcessingInstructions\n+TYPE: bool\n+VERSION: 4.2.0\n+DEFAULT: false\n+--DESCRIPTION--\n+Instead of escaping processing instructions in the form <code>&lt;? ...\n+?&gt;</code>, remove it out-right.  This may be useful if the HTML\n+you are validating contains XML processing instruction gunk, however,\n+it can also be user-unfriendly for people attempting to post PHP\n+snippets.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Core.RemoveScriptContents.txt",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+Core.RemoveScriptContents\n+TYPE: bool/null\n+DEFAULT: NULL\n+VERSION: 2.0.0\n+DEPRECATED-VERSION: 2.1.0\n+DEPRECATED-USE: Core.HiddenElements\n+--DESCRIPTION--\n+<p>\n+  This directive enables HTML Purifier to remove not only script tags\n+  but all of their contents.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Filter.Custom.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+Filter.Custom\n+TYPE: list\n+VERSION: 3.1.0\n+DEFAULT: array()\n+--DESCRIPTION--\n+<p>\n+  This directive can be used to add custom filters; it is nearly the\n+  equivalent of the now deprecated <code>HTMLPurifier-&gt;addFilter()</code>\n+  method. Specify an array of concrete implementations.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Filter.ExtractStyleBlocks.Escaping.txt",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+Filter.ExtractStyleBlocks.Escaping\n+TYPE: bool\n+VERSION: 3.0.0\n+DEFAULT: true\n+ALIASES: Filter.ExtractStyleBlocksEscaping, FilterParam.ExtractStyleBlocksEscaping\n+--DESCRIPTION--\n+\n+<p>\n+  Whether or not to escape the dangerous characters &lt;, &gt; and &amp;\n+  as \\3C, \\3E and \\26, respectively. This is can be safely set to false\n+  if the contents of StyleBlocks will be placed in an external stylesheet,\n+  where there is no risk of it being interpreted as HTML.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Filter.ExtractStyleBlocks.Scope.txt",
          "status": "added",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -0,0 +1,29 @@\n+Filter.ExtractStyleBlocks.Scope\n+TYPE: string/null\n+VERSION: 3.0.0\n+DEFAULT: NULL\n+ALIASES: Filter.ExtractStyleBlocksScope, FilterParam.ExtractStyleBlocksScope\n+--DESCRIPTION--\n+\n+<p>\n+  If you would like users to be able to define external stylesheets, but\n+  only allow them to specify CSS declarations for a specific node and\n+  prevent them from fiddling with other elements, use this directive.\n+  It accepts any valid CSS selector, and will prepend this to any\n+  CSS declaration extracted from the document. For example, if this\n+  directive is set to <code>#user-content</code> and a user uses the\n+  selector <code>a:hover</code>, the final selector will be\n+  <code>#user-content a:hover</code>.\n+</p>\n+<p>\n+  The comma shorthand may be used; consider the above example, with\n+  <code>#user-content, #user-content2</code>, the final selector will\n+  be <code>#user-content a:hover, #user-content2 a:hover</code>.\n+</p>\n+<p>\n+  <strong>Warning:</strong> It is possible for users to bypass this measure\n+  using a naughty + selector. This is a bug in CSS Tidy 1.3, not HTML\n+  Purifier, and I am working to get it fixed. Until then, HTML Purifier\n+  performs a basic check to prevent this.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Filter.ExtractStyleBlocks.TidyImpl.txt",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+Filter.ExtractStyleBlocks.TidyImpl\n+TYPE: mixed/null\n+VERSION: 3.1.0\n+DEFAULT: NULL\n+ALIASES: FilterParam.ExtractStyleBlocksTidyImpl\n+--DESCRIPTION--\n+<p>\n+  If left NULL, HTML Purifier will attempt to instantiate a <code>csstidy</code>\n+  class to use for internal cleaning. This will usually be good enough.\n+</p>\n+<p>\n+  However, for trusted user input, you can set this to <code>false</code> to\n+  disable cleaning. In addition, you can supply your own concrete implementation\n+  of Tidy's interface to use, although I don't know why you'd want to do that.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Filter.ExtractStyleBlocks.txt",
          "status": "added",
          "additions": 74,
          "deletions": 0,
          "patch": "@@ -0,0 +1,74 @@\n+Filter.ExtractStyleBlocks\n+TYPE: bool\n+VERSION: 3.1.0\n+DEFAULT: false\n+EXTERNAL: CSSTidy\n+--DESCRIPTION--\n+<p>\n+  This directive turns on the style block extraction filter, which removes\n+  <code>style</code> blocks from input HTML, cleans them up with CSSTidy,\n+  and places them in the <code>StyleBlocks</code> context variable, for further\n+  use by you, usually to be placed in an external stylesheet, or a\n+  <code>style</code> block in the <code>head</code> of your document.\n+</p>\n+<p>\n+  Sample usage:\n+</p>\n+<pre><![CDATA[\n+<?php\n+    header('Content-type: text/html; charset=utf-8');\n+    echo '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\n+?>\n+<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n+  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n+<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"en\" xml:lang=\"en\">\n+<head>\n+  <title>Filter.ExtractStyleBlocks</title>\n+<?php\n+    require_once '/path/to/library/HTMLPurifier.auto.php';\n+    require_once '/path/to/csstidy.class.php';\n+\n+    $dirty = '<style>body {color:#F00;}</style> Some text';\n+\n+    $config = HTMLPurifier_Config::createDefault();\n+    $config->set('Filter', 'ExtractStyleBlocks', true);\n+    $purifier = new HTMLPurifier($config);\n+\n+    $html = $purifier->purify($dirty);\n+\n+    // This implementation writes the stylesheets to the styles/ directory.\n+    // You can also echo the styles inside the document, but it's a bit\n+    // more difficult to make sure they get interpreted properly by\n+    // browsers; try the usual CSS armoring techniques.\n+    $styles = $purifier->context->get('StyleBlocks');\n+    $dir = 'styles/';\n+    if (!is_dir($dir)) mkdir($dir);\n+    $hash = sha1($_GET['html']);\n+    foreach ($styles as $i => $style) {\n+        file_put_contents($name = $dir . $hash . \"_$i\");\n+        echo '<link rel=\"stylesheet\" type=\"text/css\" href=\"'.$name.'\" />';\n+    }\n+?>\n+</head>\n+<body>\n+  <div>\n+    <?php echo $html; ?>\n+  </div>\n+</b]]><![CDATA[ody>\n+</html>\n+]]></pre>\n+<p>\n+  <strong>Warning:</strong> It is possible for a user to mount an\n+  imagecrash attack using this CSS. Counter-measures are difficult;\n+  it is not simply enough to limit the range of CSS lengths (using\n+  relative lengths with many nesting levels allows for large values\n+  to be attained without actually specifying them in the stylesheet),\n+  and the flexible nature of selectors makes it difficult to selectively\n+  disable lengths on image tags (HTML Purifier, however, does disable\n+  CSS width and height in inline styling). There are probably two effective\n+  counter measures: an explicit width and height set to auto in all\n+  images in your document (unlikely) or the disabling of width and\n+  height (somewhat reasonable). Whether or not these measures should be\n+  used is left to the reader.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Filter.YouTube.txt",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+Filter.YouTube\n+TYPE: bool\n+VERSION: 3.1.0\n+DEFAULT: false\n+--DESCRIPTION--\n+<p>\n+  <strong>Warning:</strong> Deprecated in favor of %HTML.SafeObject and\n+  %Output.FlashCompat (turn both on to allow YouTube videos and other\n+  Flash content).\n+</p>\n+<p>\n+  This directive enables YouTube video embedding in HTML Purifier. Check\n+  <a href=\"http://htmlpurifier.org/docs/enduser-youtube.html\">this document\n+  on embedding videos</a> for more information on what this filter does.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.Allowed.txt",
          "status": "added",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -0,0 +1,25 @@\n+HTML.Allowed\n+TYPE: itext/null\n+VERSION: 2.0.0\n+DEFAULT: NULL\n+--DESCRIPTION--\n+\n+<p>\n+    This is a preferred convenience directive that combines\n+    %HTML.AllowedElements and %HTML.AllowedAttributes.\n+    Specify elements and attributes that are allowed using:\n+    <code>element1[attr1|attr2],element2...</code>.  For example,\n+    if you would like to only allow paragraphs and links, specify\n+    <code>a[href],p</code>.  You can specify attributes that apply\n+    to all elements using an asterisk, e.g. <code>*[lang]</code>.\n+    You can also use newlines instead of commas to separate elements.\n+</p>\n+<p>\n+    <strong>Warning</strong>:\n+    All of the constraints on the component directives are still enforced.\n+    The syntax is a <em>subset</em> of TinyMCE's <code>valid_elements</code>\n+    whitelist: directly copy-pasting it here will probably result in\n+    broken whitelists. If %HTML.AllowedElements or %HTML.AllowedAttributes\n+    are set, this directive has no effect.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.AllowedAttributes.txt",
          "status": "added",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -0,0 +1,19 @@\n+HTML.AllowedAttributes\n+TYPE: lookup/null\n+VERSION: 1.3.0\n+DEFAULT: NULL\n+--DESCRIPTION--\n+\n+<p>\n+    If HTML Purifier's attribute set is unsatisfactory, overload it!\n+    The syntax is \"tag.attr\" or \"*.attr\" for the global attributes\n+    (style, id, class, dir, lang, xml:lang).\n+</p>\n+<p>\n+    <strong>Warning:</strong> If another directive conflicts with the\n+    elements here, <em>that</em> directive will win and override. For\n+    example, %HTML.EnableAttrID will take precedence over *.id in this\n+    directive.  You must set that directive to true before you can use\n+    IDs at all.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.AllowedComments.txt",
          "status": "added",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -0,0 +1,10 @@\n+HTML.AllowedComments\n+TYPE: lookup\n+VERSION: 4.4.0\n+DEFAULT: array()\n+--DESCRIPTION--\n+A whitelist which indicates what explicit comment bodies should be\n+allowed, modulo leading and trailing whitespace.  See also %HTML.AllowedCommentsRegexp\n+(these directives are union'ed together, so a comment is considered\n+valid if any directive deems it valid.)\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.AllowedCommentsRegexp.txt",
          "status": "added",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -0,0 +1,15 @@\n+HTML.AllowedCommentsRegexp\n+TYPE: string/null\n+VERSION: 4.4.0\n+DEFAULT: NULL\n+--DESCRIPTION--\n+A regexp, which if it matches the body of a comment, indicates that\n+it should be allowed. Trailing and leading spaces are removed prior\n+to running this regular expression.\n+<strong>Warning:</strong> Make sure you specify\n+correct anchor metacharacters <code>^regex$</code>, otherwise you may accept\n+comments that you did not mean to! In particular, the regex <code>/foo|bar/</code>\n+is probably not sufficiently strict, since it also allows <code>foobar</code>.\n+See also %HTML.AllowedComments (these directives are union'ed together,\n+so a comment is considered valid if any directive deems it valid.)\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.AllowedElements.txt",
          "status": "added",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -0,0 +1,23 @@\n+HTML.AllowedElements\n+TYPE: lookup/null\n+VERSION: 1.3.0\n+DEFAULT: NULL\n+--DESCRIPTION--\n+<p>\n+    If HTML Purifier's tag set is unsatisfactory for your needs, you can\n+    overload it with your own list of tags to allow.  If you change\n+    this, you probably also want to change %HTML.AllowedAttributes; see\n+    also %HTML.Allowed which lets you set allowed elements and\n+    attributes at the same time.\n+</p>\n+<p>\n+    If you attempt to allow an element that HTML Purifier does not know\n+    about, HTML Purifier will raise an error.  You will need to manually\n+    tell HTML Purifier about this element by using the\n+    <a href=\"http://htmlpurifier.org/docs/enduser-customize.html\">advanced customization features.</a>\n+</p>\n+<p>\n+    <strong>Warning:</strong> If another directive conflicts with the\n+    elements here, <em>that</em> directive will win and override.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.AllowedModules.txt",
          "status": "added",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -0,0 +1,20 @@\n+HTML.AllowedModules\n+TYPE: lookup/null\n+VERSION: 2.0.0\n+DEFAULT: NULL\n+--DESCRIPTION--\n+\n+<p>\n+    A doctype comes with a set of usual modules to use. Without having\n+    to mucking about with the doctypes, you can quickly activate or\n+    disable these modules by specifying which modules you wish to allow\n+    with this directive. This is most useful for unit testing specific\n+    modules, although end users may find it useful for their own ends.\n+</p>\n+<p>\n+    If you specify a module that does not exist, the manager will silently\n+    fail to use it, so be careful! User-defined modules are not affected\n+    by this directive. Modules defined in %HTML.CoreModules are not\n+    affected by this directive.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.Attr.Name.UseCDATA.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+HTML.Attr.Name.UseCDATA\n+TYPE: bool\n+DEFAULT: false\n+VERSION: 4.0.0\n+--DESCRIPTION--\n+The W3C specification DTD defines the name attribute to be CDATA, not ID, due\n+to limitations of DTD.  In certain documents, this relaxed behavior is desired,\n+whether it is to specify duplicate names, or to specify names that would be\n+illegal IDs (for example, names that begin with a digit.) Set this configuration\n+directive to true to use the relaxed parsing rules.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.BlockWrapper.txt",
          "status": "added",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -0,0 +1,18 @@\n+HTML.BlockWrapper\n+TYPE: string\n+VERSION: 1.3.0\n+DEFAULT: 'p'\n+--DESCRIPTION--\n+\n+<p>\n+    String name of element to wrap inline elements that are inside a block\n+    context.  This only occurs in the children of blockquote in strict mode.\n+</p>\n+<p>\n+    Example: by default value,\n+    <code>&lt;blockquote&gt;Foo&lt;/blockquote&gt;</code> would become\n+    <code>&lt;blockquote&gt;&lt;p&gt;Foo&lt;/p&gt;&lt;/blockquote&gt;</code>.\n+    The <code>&lt;p&gt;</code> tags can be replaced with whatever you desire,\n+    as long as it is a block level element.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.CoreModules.txt",
          "status": "added",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -0,0 +1,23 @@\n+HTML.CoreModules\n+TYPE: lookup\n+VERSION: 2.0.0\n+--DEFAULT--\n+array (\n+  'Structure' => true,\n+  'Text' => true,\n+  'Hypertext' => true,\n+  'List' => true,\n+  'NonXMLCommonAttributes' => true,\n+  'XMLCommonAttributes' => true,\n+  'CommonAttributes' => true,\n+)\n+--DESCRIPTION--\n+\n+<p>\n+    Certain modularized doctypes (XHTML, namely), have certain modules\n+    that must be included for the doctype to be an conforming document\n+    type: put those modules here. By default, XHTML's core modules\n+    are used. You can set this to a blank array to disable core module\n+    protection, but this is not recommended.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.CustomDoctype.txt",
          "status": "added",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -0,0 +1,9 @@\n+HTML.CustomDoctype\n+TYPE: string/null\n+VERSION: 2.0.1\n+DEFAULT: NULL\n+--DESCRIPTION--\n+\n+A custom doctype for power-users who defined their own document\n+type. This directive only applies when %HTML.Doctype is blank.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.DefinitionID.txt",
          "status": "added",
          "additions": 33,
          "deletions": 0,
          "patch": "@@ -0,0 +1,33 @@\n+HTML.DefinitionID\n+TYPE: string/null\n+DEFAULT: NULL\n+VERSION: 2.0.0\n+--DESCRIPTION--\n+\n+<p>\n+    Unique identifier for a custom-built HTML definition. If you edit\n+    the raw version of the HTMLDefinition, introducing changes that the\n+    configuration object does not reflect, you must specify this variable.\n+    If you change your custom edits, you should change this directive, or\n+    clear your cache. Example:\n+</p>\n+<pre>\n+$config = HTMLPurifier_Config::createDefault();\n+$config->set('HTML', 'DefinitionID', '1');\n+$def = $config->getHTMLDefinition();\n+$def->addAttribute('a', 'tabindex', 'Number');\n+</pre>\n+<p>\n+    In the above example, the configuration is still at the defaults, but\n+    using the advanced API, an extra attribute has been added. The\n+    configuration object normally has no way of knowing that this change\n+    has taken place, so it needs an extra directive: %HTML.DefinitionID.\n+    If someone else attempts to use the default configuration, these two\n+    pieces of code will not clobber each other in the cache, since one has\n+    an extra directive attached to it.\n+</p>\n+<p>\n+    You <em>must</em> specify a value to this directive to use the\n+    advanced API features.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.DefinitionRev.txt",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+HTML.DefinitionRev\n+TYPE: int\n+VERSION: 2.0.0\n+DEFAULT: 1\n+--DESCRIPTION--\n+\n+<p>\n+    Revision identifier for your custom definition specified in\n+    %HTML.DefinitionID.  This serves the same purpose: uniquely identifying\n+    your custom definition, but this one does so in a chronological\n+    context: revision 3 is more up-to-date then revision 2.  Thus, when\n+    this gets incremented, the cache handling is smart enough to clean\n+    up any older revisions of your definition as well as flush the\n+    cache.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.Doctype.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+HTML.Doctype\n+TYPE: string/null\n+DEFAULT: NULL\n+--DESCRIPTION--\n+Doctype to use during filtering. Technically speaking this is not actually\n+a doctype (as it does not identify a corresponding DTD), but we are using\n+this name for sake of simplicity. When non-blank, this will override any\n+older directives like %HTML.XHTML or %HTML.Strict.\n+--ALLOWED--\n+'HTML 4.01 Transitional', 'HTML 4.01 Strict', 'XHTML 1.0 Transitional', 'XHTML 1.0 Strict', 'XHTML 1.1'\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.FlashAllowFullScreen.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+HTML.FlashAllowFullScreen\n+TYPE: bool\n+VERSION: 4.2.0\n+DEFAULT: false\n+--DESCRIPTION--\n+<p>\n+    Whether or not to permit embedded Flash content from\n+    %HTML.SafeObject to expand to the full screen.  Corresponds to\n+    the <code>allowFullScreen</code> parameter.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.ForbiddenAttributes.txt",
          "status": "added",
          "additions": 21,
          "deletions": 0,
          "patch": "@@ -0,0 +1,21 @@\n+HTML.ForbiddenAttributes\n+TYPE: lookup\n+VERSION: 3.1.0\n+DEFAULT: array()\n+--DESCRIPTION--\n+<p>\n+    While this directive is similar to %HTML.AllowedAttributes, for\n+    forwards-compatibility with XML, this attribute has a different syntax. Instead of\n+    <code>tag.attr</code>, use <code>tag@attr</code>. To disallow <code>href</code>\n+    attributes in <code>a</code> tags, set this directive to\n+    <code>a@href</code>. You can also disallow an attribute globally with\n+    <code>attr</code> or <code>*@attr</code> (either syntax is fine; the latter\n+    is provided for consistency with %HTML.AllowedAttributes).\n+</p>\n+<p>\n+    <strong>Warning:</strong> This directive complements %HTML.ForbiddenElements,\n+    accordingly, check\n+    out that directive for a discussion of why you\n+    should think twice before using this directive.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.ForbiddenElements.txt",
          "status": "added",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -0,0 +1,20 @@\n+HTML.ForbiddenElements\n+TYPE: lookup\n+VERSION: 3.1.0\n+DEFAULT: array()\n+--DESCRIPTION--\n+<p>\n+    This was, perhaps, the most requested feature ever in HTML\n+    Purifier. Please don't abuse it! This is the logical inverse of\n+    %HTML.AllowedElements, and it will override that directive, or any\n+    other directive.\n+</p>\n+<p>\n+    If possible, %HTML.Allowed is recommended over this directive, because it\n+    can sometimes be difficult to tell whether or not you've forbidden all of\n+    the behavior you would like to disallow. If you forbid <code>img</code>\n+    with the expectation of preventing images on your site, you'll be in for\n+    a nasty surprise when people start using the <code>background-image</code>\n+    CSS property.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.MaxImgLength.txt",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+HTML.MaxImgLength\n+TYPE: int/null\n+DEFAULT: 1200\n+VERSION: 3.1.1\n+--DESCRIPTION--\n+<p>\n+ This directive controls the maximum number of pixels in the width and\n+ height attributes in <code>img</code> tags. This is\n+ in place to prevent imagecrash attacks, disable with null at your own risk.\n+ This directive is similar to %CSS.MaxImgLength, and both should be\n+ concurrently edited, although there are\n+ subtle differences in the input format (the HTML max is an integer).\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.Nofollow.txt",
          "status": "added",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -0,0 +1,7 @@\n+HTML.Nofollow\n+TYPE: bool\n+VERSION: 4.3.0\n+DEFAULT: FALSE\n+--DESCRIPTION--\n+If enabled, nofollow rel attributes are added to all outgoing links.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.Parent.txt",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+HTML.Parent\n+TYPE: string\n+VERSION: 1.3.0\n+DEFAULT: 'div'\n+--DESCRIPTION--\n+\n+<p>\n+    String name of element that HTML fragment passed to library will be\n+    inserted in.  An interesting variation would be using span as the\n+    parent element, meaning that only inline tags would be allowed.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.Proprietary.txt",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+HTML.Proprietary\n+TYPE: bool\n+VERSION: 3.1.0\n+DEFAULT: false\n+--DESCRIPTION--\n+<p>\n+    Whether or not to allow proprietary elements and attributes in your\n+    documents, as per <code>HTMLPurifier_HTMLModule_Proprietary</code>.\n+    <strong>Warning:</strong> This can cause your documents to stop\n+    validating!\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.SafeEmbed.txt",
          "status": "added",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -0,0 +1,13 @@\n+HTML.SafeEmbed\n+TYPE: bool\n+VERSION: 3.1.1\n+DEFAULT: false\n+--DESCRIPTION--\n+<p>\n+    Whether or not to permit embed tags in documents, with a number of extra\n+    security features added to prevent script execution. This is similar to\n+    what websites like MySpace do to embed tags. Embed is a proprietary\n+    element and will cause your website to stop validating; you should\n+    see if you can use %Output.FlashCompat with %HTML.SafeObject instead\n+    first.</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.SafeIframe.txt",
          "status": "added",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -0,0 +1,13 @@\n+HTML.SafeIframe\n+TYPE: bool\n+VERSION: 4.4.0\n+DEFAULT: false\n+--DESCRIPTION--\n+<p>\n+    Whether or not to permit iframe tags in untrusted documents.  This\n+    directive must be accompanied by a whitelist of permitted iframes,\n+    such as %URI.SafeIframeRegexp, otherwise it will fatally error.\n+    This directive has no effect on strict doctypes, as iframes are not\n+    valid.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.SafeObject.txt",
          "status": "added",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -0,0 +1,13 @@\n+HTML.SafeObject\n+TYPE: bool\n+VERSION: 3.1.1\n+DEFAULT: false\n+--DESCRIPTION--\n+<p>\n+    Whether or not to permit object tags in documents, with a number of extra\n+    security features added to prevent script execution. This is similar to\n+    what websites like MySpace do to object tags.  You should also enable\n+    %Output.FlashCompat in order to generate Internet Explorer\n+    compatibility code for your object tags.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.SafeScripting.txt",
          "status": "added",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -0,0 +1,10 @@\n+HTML.SafeScripting\n+TYPE: lookup\n+VERSION: 4.5.0\n+DEFAULT: array()\n+--DESCRIPTION--\n+<p>\n+    Whether or not to permit script tags to external scripts in documents.\n+    Inline scripting is not allowed, and the script must match an explicit whitelist.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.Strict.txt",
          "status": "added",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -0,0 +1,9 @@\n+HTML.Strict\n+TYPE: bool\n+VERSION: 1.3.0\n+DEFAULT: false\n+DEPRECATED-VERSION: 1.7.0\n+DEPRECATED-USE: HTML.Doctype\n+--DESCRIPTION--\n+Determines whether or not to use Transitional (loose) or Strict rulesets.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.TargetBlank.txt",
          "status": "added",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -0,0 +1,8 @@\n+HTML.TargetBlank\n+TYPE: bool\n+VERSION: 4.4.0\n+DEFAULT: FALSE\n+--DESCRIPTION--\n+If enabled, <code>target=blank</code> attributes are added to all outgoing links.\n+(This includes links from an HTTPS version of a page to an HTTP version.)\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.TargetNoreferrer.txt",
          "status": "added",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -0,0 +1,9 @@\n+HTML.TargetNoreferrer\n+TYPE: bool\n+VERSION: 4.8.0\n+DEFAULT: TRUE\n+--DESCRIPTION--\n+If enabled, noreferrer rel attributes are added to links which have\n+a target attribute associated with them.  This prevents malicious\n+destinations from overwriting the original window.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.TidyAdd.txt",
          "status": "added",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -0,0 +1,8 @@\n+HTML.TidyAdd\n+TYPE: lookup\n+VERSION: 2.0.0\n+DEFAULT: array()\n+--DESCRIPTION--\n+\n+Fixes to add to the default set of Tidy fixes as per your level.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.TidyLevel.txt",
          "status": "added",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -0,0 +1,24 @@\n+HTML.TidyLevel\n+TYPE: string\n+VERSION: 2.0.0\n+DEFAULT: 'medium'\n+--DESCRIPTION--\n+\n+<p>General level of cleanliness the Tidy module should enforce.\n+There are four allowed values:</p>\n+<dl>\n+    <dt>none</dt>\n+    <dd>No extra tidying should be done</dd>\n+    <dt>light</dt>\n+    <dd>Only fix elements that would be discarded otherwise due to\n+    lack of support in doctype</dd>\n+    <dt>medium</dt>\n+    <dd>Enforce best practices</dd>\n+    <dt>heavy</dt>\n+    <dd>Transform all deprecated elements and attributes to standards\n+    compliant equivalents</dd>\n+</dl>\n+\n+--ALLOWED--\n+'none', 'light', 'medium', 'heavy'\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.TidyRemove.txt",
          "status": "added",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -0,0 +1,8 @@\n+HTML.TidyRemove\n+TYPE: lookup\n+VERSION: 2.0.0\n+DEFAULT: array()\n+--DESCRIPTION--\n+\n+Fixes to remove from the default set of Tidy fixes as per your level.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.Trusted.txt",
          "status": "added",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -0,0 +1,9 @@\n+HTML.Trusted\n+TYPE: bool\n+VERSION: 2.0.0\n+DEFAULT: false\n+--DESCRIPTION--\n+Indicates whether or not the user input is trusted or not. If the input is\n+trusted, a more expansive set of allowed tags and attributes will be used.\n+See also %CSS.Trusted.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/HTML.XHTML.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+HTML.XHTML\n+TYPE: bool\n+DEFAULT: true\n+VERSION: 1.1.0\n+DEPRECATED-VERSION: 1.7.0\n+DEPRECATED-USE: HTML.Doctype\n+--DESCRIPTION--\n+Determines whether or not output is XHTML 1.0 or HTML 4.01 flavor.\n+--ALIASES--\n+Core.XHTML\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Output.CommentScriptContents.txt",
          "status": "added",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -0,0 +1,10 @@\n+Output.CommentScriptContents\n+TYPE: bool\n+VERSION: 2.0.0\n+DEFAULT: true\n+--DESCRIPTION--\n+Determines whether or not HTML Purifier should attempt to fix up the\n+contents of script tags for legacy browsers with comments.\n+--ALIASES--\n+Core.CommentScriptContents\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Output.FixInnerHTML.txt",
          "status": "added",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -0,0 +1,15 @@\n+Output.FixInnerHTML\n+TYPE: bool\n+VERSION: 4.3.0\n+DEFAULT: true\n+--DESCRIPTION--\n+<p>\n+  If true, HTML Purifier will protect against Internet Explorer's\n+  mishandling of the <code>innerHTML</code> attribute by appending\n+  a space to any attribute that does not contain angled brackets, spaces\n+  or quotes, but contains a backtick.  This slightly changes the\n+  semantics of any given attribute, so if this is unacceptable and\n+  you do not use <code>innerHTML</code> on any of your pages, you can\n+  turn this directive off.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Output.FlashCompat.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+Output.FlashCompat\n+TYPE: bool\n+VERSION: 4.1.0\n+DEFAULT: false\n+--DESCRIPTION--\n+<p>\n+  If true, HTML Purifier will generate Internet Explorer compatibility\n+  code for all object code.  This is highly recommended if you enable\n+  %HTML.SafeObject.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Output.Newline.txt",
          "status": "added",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -0,0 +1,13 @@\n+Output.Newline\n+TYPE: string/null\n+VERSION: 2.0.1\n+DEFAULT: NULL\n+--DESCRIPTION--\n+\n+<p>\n+    Newline string to format final output with. If left null, HTML Purifier\n+    will auto-detect the default newline type of the system and use that;\n+    you can manually override it here. Remember, \\r\\n is Windows, \\r\n+    is Mac, and \\n is Unix.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Output.SortAttr.txt",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+Output.SortAttr\n+TYPE: bool\n+VERSION: 3.2.0\n+DEFAULT: false\n+--DESCRIPTION--\n+<p>\n+  If true, HTML Purifier will sort attributes by name before writing them back\n+  to the document, converting a tag like: <code>&lt;el b=\"\" a=\"\" c=\"\" /&gt;</code>\n+  to <code>&lt;el a=\"\" b=\"\" c=\"\" /&gt;</code>. This is a workaround for\n+  a bug in FCKeditor which causes it to swap attributes order, adding noise\n+  to text diffs. If you're not seeing this bug, chances are, you don't need\n+  this directive.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Output.TidyFormat.txt",
          "status": "added",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -0,0 +1,25 @@\n+Output.TidyFormat\n+TYPE: bool\n+VERSION: 1.1.1\n+DEFAULT: false\n+--DESCRIPTION--\n+<p>\n+    Determines whether or not to run Tidy on the final output for pretty\n+    formatting reasons, such as indentation and wrap.\n+</p>\n+<p>\n+    This can greatly improve readability for editors who are hand-editing\n+    the HTML, but is by no means necessary as HTML Purifier has already\n+    fixed all major errors the HTML may have had. Tidy is a non-default\n+    extension, and this directive will silently fail if Tidy is not\n+    available.\n+</p>\n+<p>\n+    If you are looking to make the overall look of your page's source\n+    better, I recommend running Tidy on the entire page rather than just\n+    user-content (after all, the indentation relative to the containing\n+    blocks will be incorrect).\n+</p>\n+--ALIASES--\n+Core.TidyFormat\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/Test.ForceNoIconv.txt",
          "status": "added",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -0,0 +1,7 @@\n+Test.ForceNoIconv\n+TYPE: bool\n+DEFAULT: false\n+--DESCRIPTION--\n+When set to true, HTMLPurifier_Encoder will act as if iconv does not exist\n+and use only pure PHP implementations.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.AllowedSchemes.txt",
          "status": "added",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -0,0 +1,18 @@\n+URI.AllowedSchemes\n+TYPE: lookup\n+--DEFAULT--\n+array (\n+  'http' => true,\n+  'https' => true,\n+  'mailto' => true,\n+  'ftp' => true,\n+  'nntp' => true,\n+  'news' => true,\n+  'tel' => true,\n+)\n+--DESCRIPTION--\n+Whitelist that defines the schemes that a URI is allowed to have.  This\n+prevents XSS attacks from using pseudo-schemes like javascript or mocha.\n+There is also support for the <code>data</code> and <code>file</code>\n+URI schemes, but they are not enabled by default.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.Base.txt",
          "status": "added",
          "additions": 17,
          "deletions": 0,
          "patch": "@@ -0,0 +1,17 @@\n+URI.Base\n+TYPE: string/null\n+VERSION: 2.1.0\n+DEFAULT: NULL\n+--DESCRIPTION--\n+\n+<p>\n+    The base URI is the URI of the document this purified HTML will be\n+    inserted into.  This information is important if HTML Purifier needs\n+    to calculate absolute URIs from relative URIs, such as when %URI.MakeAbsolute\n+    is on.  You may use a non-absolute URI for this value, but behavior\n+    may vary (%URI.MakeAbsolute deals nicely with both absolute and\n+    relative paths, but forwards-compatibility is not guaranteed).\n+    <strong>Warning:</strong> If set, the scheme on this URI\n+    overrides the one specified by %URI.DefaultScheme.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.DefaultScheme.txt",
          "status": "added",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -0,0 +1,10 @@\n+URI.DefaultScheme\n+TYPE: string\n+DEFAULT: 'http'\n+--DESCRIPTION--\n+\n+<p>\n+    Defines through what scheme the output will be served, in order to\n+    select the proper object validator when no scheme information is present.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.DefinitionID.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+URI.DefinitionID\n+TYPE: string/null\n+VERSION: 2.1.0\n+DEFAULT: NULL\n+--DESCRIPTION--\n+\n+<p>\n+    Unique identifier for a custom-built URI definition. If you  want\n+    to add custom URIFilters, you must specify this value.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.DefinitionRev.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+URI.DefinitionRev\n+TYPE: int\n+VERSION: 2.1.0\n+DEFAULT: 1\n+--DESCRIPTION--\n+\n+<p>\n+    Revision identifier for your custom definition. See\n+    %HTML.DefinitionRev for details.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.Disable.txt",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+URI.Disable\n+TYPE: bool\n+VERSION: 1.3.0\n+DEFAULT: false\n+--DESCRIPTION--\n+\n+<p>\n+    Disables all URIs in all forms. Not sure why you'd want to do that\n+    (after all, the Internet's founded on the notion of a hyperlink).\n+</p>\n+\n+--ALIASES--\n+Attr.DisableURI\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.DisableExternal.txt",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+URI.DisableExternal\n+TYPE: bool\n+VERSION: 1.2.0\n+DEFAULT: false\n+--DESCRIPTION--\n+Disables links to external websites.  This is a highly effective anti-spam\n+and anti-pagerank-leech measure, but comes at a hefty price: nolinks or\n+images outside of your domain will be allowed.  Non-linkified URIs will\n+still be preserved.  If you want to be able to link to subdomains or use\n+absolute URIs, specify %URI.Host for your website.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.DisableExternalResources.txt",
          "status": "added",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -0,0 +1,13 @@\n+URI.DisableExternalResources\n+TYPE: bool\n+VERSION: 1.3.0\n+DEFAULT: false\n+--DESCRIPTION--\n+Disables the embedding of external resources, preventing users from\n+embedding things like images from other hosts. This prevents access\n+tracking (good for email viewers), bandwidth leeching, cross-site request\n+forging, goatse.cx posting, and other nasties, but also results in a loss\n+of end-user functionality (they can't directly post a pic they posted from\n+Flickr anymore). Use it if you don't have a robust user-content moderation\n+team.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.DisableResources.txt",
          "status": "added",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -0,0 +1,15 @@\n+URI.DisableResources\n+TYPE: bool\n+VERSION: 4.2.0\n+DEFAULT: false\n+--DESCRIPTION--\n+<p>\n+    Disables embedding resources, essentially meaning no pictures. You can\n+    still link to them though. See %URI.DisableExternalResources for why\n+    this might be a good idea.\n+</p>\n+<p>\n+    <em>Note:</em> While this directive has been available since 1.3.0,\n+    it didn't actually start doing anything until 4.2.0.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.Host.txt",
          "status": "added",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -0,0 +1,19 @@\n+URI.Host\n+TYPE: string/null\n+VERSION: 1.2.0\n+DEFAULT: NULL\n+--DESCRIPTION--\n+\n+<p>\n+    Defines the domain name of the server, so we can determine whether or\n+    an absolute URI is from your website or not.  Not strictly necessary,\n+    as users should be using relative URIs to reference resources on your\n+    website.  It will, however, let you use absolute URIs to link to\n+    subdomains of the domain you post here: i.e. example.com will allow\n+    sub.example.com.  However, higher up domains will still be excluded:\n+    if you set %URI.Host to sub.example.com, example.com will be blocked.\n+    <strong>Note:</strong> This directive overrides %URI.Base because\n+    a given page may be on a sub-domain, but you wish HTML Purifier to be\n+    more relaxed and allow some of the parent domains too.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.HostBlacklist.txt",
          "status": "added",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -0,0 +1,9 @@\n+URI.HostBlacklist\n+TYPE: list\n+VERSION: 1.3.0\n+DEFAULT: array()\n+--DESCRIPTION--\n+List of strings that are forbidden in the host of any URI. Use it to kill\n+domain names of spam, etc. Note that it will catch anything in the domain,\n+so <tt>moo.com</tt> will catch <tt>moo.com.example.com</tt>.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.MakeAbsolute.txt",
          "status": "added",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -0,0 +1,13 @@\n+URI.MakeAbsolute\n+TYPE: bool\n+VERSION: 2.1.0\n+DEFAULT: false\n+--DESCRIPTION--\n+\n+<p>\n+    Converts all URIs into absolute forms. This is useful when the HTML\n+    being filtered assumes a specific base path, but will actually be\n+    viewed in a different context (and setting an alternate base URI is\n+    not possible). %URI.Base must be set for this directive to work.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.Munge.txt",
          "status": "added",
          "additions": 83,
          "deletions": 0,
          "patch": "@@ -0,0 +1,83 @@\n+URI.Munge\n+TYPE: string/null\n+VERSION: 1.3.0\n+DEFAULT: NULL\n+--DESCRIPTION--\n+\n+<p>\n+    Munges all browsable (usually http, https and ftp)\n+    absolute URIs into another URI, usually a URI redirection service.\n+    This directive accepts a URI, formatted with a <code>%s</code> where\n+    the url-encoded original URI should be inserted (sample:\n+    <code>http://www.google.com/url?q=%s</code>).\n+</p>\n+<p>\n+    Uses for this directive:\n+</p>\n+<ul>\n+    <li>\n+        Prevent PageRank leaks, while being fairly transparent\n+        to users (you may also want to add some client side JavaScript to\n+        override the text in the statusbar). <strong>Notice</strong>:\n+        Many security experts believe that this form of protection does not deter spam-bots.\n+    </li>\n+    <li>\n+        Redirect users to a splash page telling them they are leaving your\n+        website. While this is poor usability practice, it is often mandated\n+        in corporate environments.\n+    </li>\n+</ul>\n+<p>\n+    Prior to HTML Purifier 3.1.1, this directive also enabled the munging\n+    of browsable external resources, which could break things if your redirection\n+    script was a splash page or used <code>meta</code> tags. To revert to\n+    previous behavior, please use %URI.MungeResources.\n+</p>\n+<p>\n+    You may want to also use %URI.MungeSecretKey along with this directive\n+    in order to enforce what URIs your redirector script allows. Open\n+    redirector scripts can be a security risk and negatively affect the\n+    reputation of your domain name.\n+</p>\n+<p>\n+    Starting with HTML Purifier 3.1.1, there is also these substitutions:\n+</p>\n+<table>\n+    <thead>\n+        <tr>\n+            <th>Key</th>\n+            <th>Description</th>\n+            <th>Example <code>&lt;a href=\"\"&gt;</code></th>\n+        </tr>\n+    </thead>\n+    <tbody>\n+        <tr>\n+            <td>%r</td>\n+            <td>1 - The URI embeds a resource<br />(blank) - The URI is merely a link</td>\n+            <td></td>\n+        </tr>\n+        <tr>\n+            <td>%n</td>\n+            <td>The name of the tag this URI came from</td>\n+            <td>a</td>\n+        </tr>\n+        <tr>\n+            <td>%m</td>\n+            <td>The name of the attribute this URI came from</td>\n+            <td>href</td>\n+        </tr>\n+        <tr>\n+            <td>%p</td>\n+            <td>The name of the CSS property this URI came from, or blank if irrelevant</td>\n+            <td></td>\n+        </tr>\n+    </tbody>\n+</table>\n+<p>\n+    Admittedly, these letters are somewhat arbitrary; the only stipulation\n+    was that they couldn't be a through f. r is for resource (I would have preferred\n+    e, but you take what you can get), n is for name, m\n+    was picked because it came after n (and I couldn't use a), p is for\n+    property.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.MungeResources.txt",
          "status": "added",
          "additions": 17,
          "deletions": 0,
          "patch": "@@ -0,0 +1,17 @@\n+URI.MungeResources\n+TYPE: bool\n+VERSION: 3.1.1\n+DEFAULT: false\n+--DESCRIPTION--\n+<p>\n+    If true, any URI munging directives like %URI.Munge\n+    will also apply to embedded resources, such as <code>&lt;img src=\"\"&gt;</code>.\n+    Be careful enabling this directive if you have a redirector script\n+    that does not use the <code>Location</code> HTTP header; all of your images\n+    and other embedded resources will break.\n+</p>\n+<p>\n+    <strong>Warning:</strong> It is strongly advised you use this in conjunction\n+    %URI.MungeSecretKey to mitigate the security risk of an open redirector.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.MungeSecretKey.txt",
          "status": "added",
          "additions": 30,
          "deletions": 0,
          "patch": "@@ -0,0 +1,30 @@\n+URI.MungeSecretKey\n+TYPE: string/null\n+VERSION: 3.1.1\n+DEFAULT: NULL\n+--DESCRIPTION--\n+<p>\n+    This directive enables secure checksum generation along with %URI.Munge.\n+    It should be set to a secure key that is not shared with anyone else.\n+    The checksum can be placed in the URI using %t. Use of this checksum\n+    affords an additional level of protection by allowing a redirector\n+    to check if a URI has passed through HTML Purifier with this line:\n+</p>\n+\n+<pre>$checksum === hash_hmac(\"sha256\", $url, $secret_key)</pre>\n+\n+<p>\n+    If the output is TRUE, the redirector script should accept the URI.\n+</p>\n+\n+<p>\n+    Please note that it would still be possible for an attacker to procure\n+    secure hashes en-mass by abusing your website's Preview feature or the\n+    like, but this service affords an additional level of protection\n+    that should be combined with website blacklisting.\n+</p>\n+\n+<p>\n+    Remember this has no effect if %URI.Munge is not on.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.OverrideAllowedSchemes.txt",
          "status": "added",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -0,0 +1,9 @@\n+URI.OverrideAllowedSchemes\n+TYPE: bool\n+DEFAULT: true\n+--DESCRIPTION--\n+If this is set to true (which it is by default), you can override\n+%URI.AllowedSchemes by simply registering a HTMLPurifier_URIScheme to the\n+registry.  If false, you will also have to update that directive in order\n+to add more schemes.\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/URI.SafeIframeRegexp.txt",
          "status": "added",
          "additions": 22,
          "deletions": 0,
          "patch": "@@ -0,0 +1,22 @@\n+URI.SafeIframeRegexp\n+TYPE: string/null\n+VERSION: 4.4.0\n+DEFAULT: NULL\n+--DESCRIPTION--\n+<p>\n+    A PCRE regular expression that will be matched against an iframe URI.  This is\n+    a relatively inflexible scheme, but works well enough for the most common\n+    use-case of iframes: embedded video.  This directive only has an effect if\n+    %HTML.SafeIframe is enabled.  Here are some example values:\n+</p>\n+<ul>\n+    <li><code>%^http://www.youtube.com/embed/%</code> - Allow YouTube videos</li>\n+    <li><code>%^http://player.vimeo.com/video/%</code> - Allow Vimeo videos</li>\n+    <li><code>%^http://(www.youtube.com/embed/|player.vimeo.com/video/)%</code> - Allow both</li>\n+</ul>\n+<p>\n+    Note that this directive does not give you enough granularity to, say, disable\n+    all <code>autoplay</code> videos.  Pipe up on the HTML Purifier forums if this\n+    is a capability you want.\n+</p>\n+--# vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ConfigSchema/schema/info.ini",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+name = \"HTML Purifier\"\n+\n+; vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ContentSets.php",
          "status": "added",
          "additions": 170,
          "deletions": 0,
          "patch": "@@ -0,0 +1,170 @@\n+<?php\n+\n+/**\n+ * @todo Unit test\n+ */\n+class HTMLPurifier_ContentSets\n+{\n+\n+    /**\n+     * List of content set strings (pipe separators) indexed by name.\n+     * @type array\n+     */\n+    public $info = array();\n+\n+    /**\n+     * List of content set lookups (element => true) indexed by name.\n+     * @type array\n+     * @note This is in HTMLPurifier_HTMLDefinition->info_content_sets\n+     */\n+    public $lookup = array();\n+\n+    /**\n+     * Synchronized list of defined content sets (keys of info).\n+     * @type array\n+     */\n+    protected $keys = array();\n+    /**\n+     * Synchronized list of defined content values (values of info).\n+     * @type array\n+     */\n+    protected $values = array();\n+\n+    /**\n+     * Merges in module's content sets, expands identifiers in the content\n+     * sets and populates the keys, values and lookup member variables.\n+     * @param HTMLPurifier_HTMLModule[] $modules List of HTMLPurifier_HTMLModule\n+     */\n+    public function __construct($modules)\n+    {\n+        if (!is_array($modules)) {\n+            $modules = array($modules);\n+        }\n+        // populate content_sets based on module hints\n+        // sorry, no way of overloading\n+        foreach ($modules as $module) {\n+            foreach ($module->content_sets as $key => $value) {\n+                $temp = $this->convertToLookup($value);\n+                if (isset($this->lookup[$key])) {\n+                    // add it into the existing content set\n+                    $this->lookup[$key] = array_merge($this->lookup[$key], $temp);\n+                } else {\n+                    $this->lookup[$key] = $temp;\n+                }\n+            }\n+        }\n+        $old_lookup = false;\n+        while ($old_lookup !== $this->lookup) {\n+            $old_lookup = $this->lookup;\n+            foreach ($this->lookup as $i => $set) {\n+                $add = array();\n+                foreach ($set as $element => $x) {\n+                    if (isset($this->lookup[$element])) {\n+                        $add += $this->lookup[$element];\n+                        unset($this->lookup[$i][$element]);\n+                    }\n+                }\n+                $this->lookup[$i] += $add;\n+            }\n+        }\n+\n+        foreach ($this->lookup as $key => $lookup) {\n+            $this->info[$key] = implode(' | ', array_keys($lookup));\n+        }\n+        $this->keys   = array_keys($this->info);\n+        $this->values = array_values($this->info);\n+    }\n+\n+    /**\n+     * Accepts a definition; generates and assigns a ChildDef for it\n+     * @param HTMLPurifier_ElementDef $def HTMLPurifier_ElementDef reference\n+     * @param HTMLPurifier_HTMLModule $module Module that defined the ElementDef\n+     */\n+    public function generateChildDef(&$def, $module)\n+    {\n+        if (!empty($def->child)) { // already done!\n+            return;\n+        }\n+        $content_model = $def->content_model;\n+        if (is_string($content_model)) {\n+            // Assume that $this->keys is alphanumeric\n+            $def->content_model = preg_replace_callback(\n+                '/\\b(' . implode('|', $this->keys) . ')\\b/',\n+                array($this, 'generateChildDefCallback'),\n+                $content_model\n+            );\n+            //$def->content_model = str_replace(\n+            //    $this->keys, $this->values, $content_model);\n+        }\n+        $def->child = $this->getChildDef($def, $module);\n+    }\n+\n+    public function generateChildDefCallback($matches)\n+    {\n+        return $this->info[$matches[0]];\n+    }\n+\n+    /**\n+     * Instantiates a ChildDef based on content_model and content_model_type\n+     * member variables in HTMLPurifier_ElementDef\n+     * @note This will also defer to modules for custom HTMLPurifier_ChildDef\n+     *       subclasses that need content set expansion\n+     * @param HTMLPurifier_ElementDef $def HTMLPurifier_ElementDef to have ChildDef extracted\n+     * @param HTMLPurifier_HTMLModule $module Module that defined the ElementDef\n+     * @return HTMLPurifier_ChildDef corresponding to ElementDef\n+     */\n+    public function getChildDef($def, $module)\n+    {\n+        $value = $def->content_model;\n+        if (is_object($value)) {\n+            trigger_error(\n+                'Literal object child definitions should be stored in '.\n+                'ElementDef->child not ElementDef->content_model',\n+                E_USER_NOTICE\n+            );\n+            return $value;\n+        }\n+        switch ($def->content_model_type) {\n+            case 'required':\n+                return new HTMLPurifier_ChildDef_Required($value);\n+            case 'optional':\n+                return new HTMLPurifier_ChildDef_Optional($value);\n+            case 'empty':\n+                return new HTMLPurifier_ChildDef_Empty();\n+            case 'custom':\n+                return new HTMLPurifier_ChildDef_Custom($value);\n+        }\n+        // defer to its module\n+        $return = false;\n+        if ($module->defines_child_def) { // save a func call\n+            $return = $module->getChildDef($def);\n+        }\n+        if ($return !== false) {\n+            return $return;\n+        }\n+        // error-out\n+        trigger_error(\n+            'Could not determine which ChildDef class to instantiate',\n+            E_USER_ERROR\n+        );\n+        return false;\n+    }\n+\n+    /**\n+     * Converts a string list of elements separated by pipes into\n+     * a lookup array.\n+     * @param string $string List of elements\n+     * @return array Lookup array of elements\n+     */\n+    protected function convertToLookup($string)\n+    {\n+        $array = explode('|', str_replace(' ', '', $string));\n+        $ret = array();\n+        foreach ($array as $k) {\n+            $ret[$k] = true;\n+        }\n+        return $ret;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Context.php",
          "status": "added",
          "additions": 95,
          "deletions": 0,
          "patch": "@@ -0,0 +1,95 @@\n+<?php\n+\n+/**\n+ * Registry object that contains information about the current context.\n+ * @warning Is a bit buggy when variables are set to null: it thinks\n+ *          they don't exist! So use false instead, please.\n+ * @note Since the variables Context deals with may not be objects,\n+ *       references are very important here! Do not remove!\n+ */\n+class HTMLPurifier_Context\n+{\n+\n+    /**\n+     * Private array that stores the references.\n+     * @type array\n+     */\n+    private $_storage = array();\n+\n+    /**\n+     * Registers a variable into the context.\n+     * @param string $name String name\n+     * @param mixed $ref Reference to variable to be registered\n+     */\n+    public function register($name, &$ref)\n+    {\n+        if (array_key_exists($name, $this->_storage)) {\n+            trigger_error(\n+                \"Name $name produces collision, cannot re-register\",\n+                E_USER_ERROR\n+            );\n+            return;\n+        }\n+        $this->_storage[$name] =& $ref;\n+    }\n+\n+    /**\n+     * Retrieves a variable reference from the context.\n+     * @param string $name String name\n+     * @param bool $ignore_error Boolean whether or not to ignore error\n+     * @return mixed\n+     */\n+    public function &get($name, $ignore_error = false)\n+    {\n+        if (!array_key_exists($name, $this->_storage)) {\n+            if (!$ignore_error) {\n+                trigger_error(\n+                    \"Attempted to retrieve non-existent variable $name\",\n+                    E_USER_ERROR\n+                );\n+            }\n+            $var = null; // so we can return by reference\n+            return $var;\n+        }\n+        return $this->_storage[$name];\n+    }\n+\n+    /**\n+     * Destroys a variable in the context.\n+     * @param string $name String name\n+     */\n+    public function destroy($name)\n+    {\n+        if (!array_key_exists($name, $this->_storage)) {\n+            trigger_error(\n+                \"Attempted to destroy non-existent variable $name\",\n+                E_USER_ERROR\n+            );\n+            return;\n+        }\n+        unset($this->_storage[$name]);\n+    }\n+\n+    /**\n+     * Checks whether or not the variable exists.\n+     * @param string $name String name\n+     * @return bool\n+     */\n+    public function exists($name)\n+    {\n+        return array_key_exists($name, $this->_storage);\n+    }\n+\n+    /**\n+     * Loads a series of variables from an associative array\n+     * @param array $context_array Assoc array of variables to load\n+     */\n+    public function loadArray($context_array)\n+    {\n+        foreach ($context_array as $key => $discard) {\n+            $this->register($key, $context_array[$key]);\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Definition.php",
          "status": "added",
          "additions": 55,
          "deletions": 0,
          "patch": "@@ -0,0 +1,55 @@\n+<?php\n+\n+/**\n+ * Super-class for definition datatype objects, implements serialization\n+ * functions for the class.\n+ */\n+abstract class HTMLPurifier_Definition\n+{\n+\n+    /**\n+     * Has setup() been called yet?\n+     * @type bool\n+     */\n+    public $setup = false;\n+\n+    /**\n+     * If true, write out the final definition object to the cache after\n+     * setup.  This will be true only if all invocations to get a raw\n+     * definition object are also optimized.  This does not cause file\n+     * system thrashing because on subsequent calls the cached object\n+     * is used and any writes to the raw definition object are short\n+     * circuited.  See enduser-customize.html for the high-level\n+     * picture.\n+     * @type bool\n+     */\n+    public $optimized = null;\n+\n+    /**\n+     * What type of definition is it?\n+     * @type string\n+     */\n+    public $type;\n+\n+    /**\n+     * Sets up the definition object into the final form, something\n+     * not done by the constructor\n+     * @param HTMLPurifier_Config $config\n+     */\n+    abstract protected function doSetup($config);\n+\n+    /**\n+     * Setup function that aborts if already setup\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        if ($this->setup) {\n+            return;\n+        }\n+        $this->setup = true;\n+        $this->doSetup($config);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/DefinitionCache.php",
          "status": "added",
          "additions": 129,
          "deletions": 0,
          "patch": "@@ -0,0 +1,129 @@\n+<?php\n+\n+/**\n+ * Abstract class representing Definition cache managers that implements\n+ * useful common methods and is a factory.\n+ * @todo Create a separate maintenance file advanced users can use to\n+ *       cache their custom HTMLDefinition, which can be loaded\n+ *       via a configuration directive\n+ * @todo Implement memcached\n+ */\n+abstract class HTMLPurifier_DefinitionCache\n+{\n+    /**\n+     * @type string\n+     */\n+    public $type;\n+\n+    /**\n+     * @param string $type Type of definition objects this instance of the\n+     *      cache will handle.\n+     */\n+    public function __construct($type)\n+    {\n+        $this->type = $type;\n+    }\n+\n+    /**\n+     * Generates a unique identifier for a particular configuration\n+     * @param HTMLPurifier_Config $config Instance of HTMLPurifier_Config\n+     * @return string\n+     */\n+    public function generateKey($config)\n+    {\n+        return $config->version . ',' . // possibly replace with function calls\n+               $config->getBatchSerial($this->type) . ',' .\n+               $config->get($this->type . '.DefinitionRev');\n+    }\n+\n+    /**\n+     * Tests whether or not a key is old with respect to the configuration's\n+     * version and revision number.\n+     * @param string $key Key to test\n+     * @param HTMLPurifier_Config $config Instance of HTMLPurifier_Config to test against\n+     * @return bool\n+     */\n+    public function isOld($key, $config)\n+    {\n+        if (substr_count($key, ',') < 2) {\n+            return true;\n+        }\n+        list($version, $hash, $revision) = explode(',', $key, 3);\n+        $compare = version_compare($version, $config->version);\n+        // version mismatch, is always old\n+        if ($compare != 0) {\n+            return true;\n+        }\n+        // versions match, ids match, check revision number\n+        if ($hash == $config->getBatchSerial($this->type) &&\n+            $revision < $config->get($this->type . '.DefinitionRev')) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks if a definition's type jives with the cache's type\n+     * @note Throws an error on failure\n+     * @param HTMLPurifier_Definition $def Definition object to check\n+     * @return bool true if good, false if not\n+     */\n+    public function checkDefType($def)\n+    {\n+        if ($def->type !== $this->type) {\n+            trigger_error(\"Cannot use definition of type {$def->type} in cache for {$this->type}\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Adds a definition object to the cache\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     */\n+    abstract public function add($def, $config);\n+\n+    /**\n+     * Unconditionally saves a definition object to the cache\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     */\n+    abstract public function set($def, $config);\n+\n+    /**\n+     * Replace an object in the cache\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     */\n+    abstract public function replace($def, $config);\n+\n+    /**\n+     * Retrieves a definition object from the cache\n+     * @param HTMLPurifier_Config $config\n+     */\n+    abstract public function get($config);\n+\n+    /**\n+     * Removes a definition object to the cache\n+     * @param HTMLPurifier_Config $config\n+     */\n+    abstract public function remove($config);\n+\n+    /**\n+     * Clears all objects from cache\n+     * @param HTMLPurifier_Config $config\n+     */\n+    abstract public function flush($config);\n+\n+    /**\n+     * Clears all expired (older version or revision) objects from cache\n+     * @note Be careful implementing this method as flush. Flush must\n+     *       not interfere with other Definition types, and cleanup()\n+     *       should not be repeatedly called by userland code.\n+     * @param HTMLPurifier_Config $config\n+     */\n+    abstract public function cleanup($config);\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/DefinitionCache/Decorator.php",
          "status": "added",
          "additions": 112,
          "deletions": 0,
          "patch": "@@ -0,0 +1,112 @@\n+<?php\n+\n+class HTMLPurifier_DefinitionCache_Decorator extends HTMLPurifier_DefinitionCache\n+{\n+\n+    /**\n+     * Cache object we are decorating\n+     * @type HTMLPurifier_DefinitionCache\n+     */\n+    public $cache;\n+\n+    /**\n+     * The name of the decorator\n+     * @var string\n+     */\n+    public $name;\n+\n+    public function __construct()\n+    {\n+    }\n+\n+    /**\n+     * Lazy decorator function\n+     * @param HTMLPurifier_DefinitionCache $cache Reference to cache object to decorate\n+     * @return HTMLPurifier_DefinitionCache_Decorator\n+     */\n+    public function decorate(&$cache)\n+    {\n+        $decorator = $this->copy();\n+        // reference is necessary for mocks in PHP 4\n+        $decorator->cache =& $cache;\n+        $decorator->type = $cache->type;\n+        return $decorator;\n+    }\n+\n+    /**\n+     * Cross-compatible clone substitute\n+     * @return HTMLPurifier_DefinitionCache_Decorator\n+     */\n+    public function copy()\n+    {\n+        return new HTMLPurifier_DefinitionCache_Decorator();\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function add($def, $config)\n+    {\n+        return $this->cache->add($def, $config);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function set($def, $config)\n+    {\n+        return $this->cache->set($def, $config);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function replace($def, $config)\n+    {\n+        return $this->cache->replace($def, $config);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function get($config)\n+    {\n+        return $this->cache->get($config);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function remove($config)\n+    {\n+        return $this->cache->remove($config);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function flush($config)\n+    {\n+        return $this->cache->flush($config);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function cleanup($config)\n+    {\n+        return $this->cache->cleanup($config);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/DefinitionCache/Decorator/Cleanup.php",
          "status": "added",
          "additions": 78,
          "deletions": 0,
          "patch": "@@ -0,0 +1,78 @@\n+<?php\n+\n+/**\n+ * Definition cache decorator class that cleans up the cache\n+ * whenever there is a cache miss.\n+ */\n+class HTMLPurifier_DefinitionCache_Decorator_Cleanup extends HTMLPurifier_DefinitionCache_Decorator\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Cleanup';\n+\n+    /**\n+     * @return HTMLPurifier_DefinitionCache_Decorator_Cleanup\n+     */\n+    public function copy()\n+    {\n+        return new HTMLPurifier_DefinitionCache_Decorator_Cleanup();\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function add($def, $config)\n+    {\n+        $status = parent::add($def, $config);\n+        if (!$status) {\n+            parent::cleanup($config);\n+        }\n+        return $status;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function set($def, $config)\n+    {\n+        $status = parent::set($def, $config);\n+        if (!$status) {\n+            parent::cleanup($config);\n+        }\n+        return $status;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function replace($def, $config)\n+    {\n+        $status = parent::replace($def, $config);\n+        if (!$status) {\n+            parent::cleanup($config);\n+        }\n+        return $status;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function get($config)\n+    {\n+        $ret = parent::get($config);\n+        if (!$ret) {\n+            parent::cleanup($config);\n+        }\n+        return $ret;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/DefinitionCache/Decorator/Memory.php",
          "status": "added",
          "additions": 85,
          "deletions": 0,
          "patch": "@@ -0,0 +1,85 @@\n+<?php\n+\n+/**\n+ * Definition cache decorator class that saves all cache retrievals\n+ * to PHP's memory; good for unit tests or circumstances where\n+ * there are lots of configuration objects floating around.\n+ */\n+class HTMLPurifier_DefinitionCache_Decorator_Memory extends HTMLPurifier_DefinitionCache_Decorator\n+{\n+    /**\n+     * @type array\n+     */\n+    protected $definitions;\n+\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Memory';\n+\n+    /**\n+     * @return HTMLPurifier_DefinitionCache_Decorator_Memory\n+     */\n+    public function copy()\n+    {\n+        return new HTMLPurifier_DefinitionCache_Decorator_Memory();\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function add($def, $config)\n+    {\n+        $status = parent::add($def, $config);\n+        if ($status) {\n+            $this->definitions[$this->generateKey($config)] = $def;\n+        }\n+        return $status;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function set($def, $config)\n+    {\n+        $status = parent::set($def, $config);\n+        if ($status) {\n+            $this->definitions[$this->generateKey($config)] = $def;\n+        }\n+        return $status;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function replace($def, $config)\n+    {\n+        $status = parent::replace($def, $config);\n+        if ($status) {\n+            $this->definitions[$this->generateKey($config)] = $def;\n+        }\n+        return $status;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function get($config)\n+    {\n+        $key = $this->generateKey($config);\n+        if (isset($this->definitions[$key])) {\n+            return $this->definitions[$key];\n+        }\n+        $this->definitions[$key] = parent::get($config);\n+        return $this->definitions[$key];\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/DefinitionCache/Decorator/Template.php.in",
          "status": "added",
          "additions": 82,
          "deletions": 0,
          "patch": "@@ -0,0 +1,82 @@\n+<?php\n+\n+require_once 'HTMLPurifier/DefinitionCache/Decorator.php';\n+\n+/**\n+ * Definition cache decorator template.\n+ */\n+class HTMLPurifier_DefinitionCache_Decorator_Template extends HTMLPurifier_DefinitionCache_Decorator\n+{\n+\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Template'; // replace this\n+\n+    public function copy()\n+    {\n+        // replace class name with yours\n+        return new HTMLPurifier_DefinitionCache_Decorator_Template();\n+    }\n+\n+    // remove methods you don't need\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function add($def, $config)\n+    {\n+        return parent::add($def, $config);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function set($def, $config)\n+    {\n+        return parent::set($def, $config);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function replace($def, $config)\n+    {\n+        return parent::replace($def, $config);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function get($config)\n+    {\n+        return parent::get($config);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function flush($config)\n+    {\n+        return parent::flush($config);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed\n+     */\n+    public function cleanup($config)\n+    {\n+        return parent::cleanup($config);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/DefinitionCache/Null.php",
          "status": "added",
          "additions": 76,
          "deletions": 0,
          "patch": "@@ -0,0 +1,76 @@\n+<?php\n+\n+/**\n+ * Null cache object to use when no caching is on.\n+ */\n+class HTMLPurifier_DefinitionCache_Null extends HTMLPurifier_DefinitionCache\n+{\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return bool\n+     */\n+    public function add($def, $config)\n+    {\n+        return false;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return bool\n+     */\n+    public function set($def, $config)\n+    {\n+        return false;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return bool\n+     */\n+    public function replace($def, $config)\n+    {\n+        return false;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return bool\n+     */\n+    public function remove($config)\n+    {\n+        return false;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return bool\n+     */\n+    public function get($config)\n+    {\n+        return false;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return bool\n+     */\n+    public function flush($config)\n+    {\n+        return false;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return bool\n+     */\n+    public function cleanup($config)\n+    {\n+        return false;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/DefinitionCache/Serializer.php",
          "status": "added",
          "additions": 313,
          "deletions": 0,
          "patch": "@@ -0,0 +1,313 @@\n+<?php\n+\n+class HTMLPurifier_DefinitionCache_Serializer extends HTMLPurifier_DefinitionCache\n+{\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return int|bool\n+     */\n+    public function add($def, $config)\n+    {\n+        if (!$this->checkDefType($def)) {\n+            return;\n+        }\n+        $file = $this->generateFilePath($config);\n+        if (file_exists($file)) {\n+            return false;\n+        }\n+        if (!$this->_prepareDir($config)) {\n+            return false;\n+        }\n+        return $this->_write($file, serialize($def), $config);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return int|bool\n+     */\n+    public function set($def, $config)\n+    {\n+        if (!$this->checkDefType($def)) {\n+            return;\n+        }\n+        $file = $this->generateFilePath($config);\n+        if (!$this->_prepareDir($config)) {\n+            return false;\n+        }\n+        return $this->_write($file, serialize($def), $config);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Definition $def\n+     * @param HTMLPurifier_Config $config\n+     * @return int|bool\n+     */\n+    public function replace($def, $config)\n+    {\n+        if (!$this->checkDefType($def)) {\n+            return;\n+        }\n+        $file = $this->generateFilePath($config);\n+        if (!file_exists($file)) {\n+            return false;\n+        }\n+        if (!$this->_prepareDir($config)) {\n+            return false;\n+        }\n+        return $this->_write($file, serialize($def), $config);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return bool|HTMLPurifier_Config\n+     */\n+    public function get($config)\n+    {\n+        $file = $this->generateFilePath($config);\n+        if (!file_exists($file)) {\n+            return false;\n+        }\n+        return unserialize(file_get_contents($file));\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return bool\n+     */\n+    public function remove($config)\n+    {\n+        $file = $this->generateFilePath($config);\n+        if (!file_exists($file)) {\n+            return false;\n+        }\n+        return unlink($file);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return bool\n+     */\n+    public function flush($config)\n+    {\n+        if (!$this->_prepareDir($config)) {\n+            return false;\n+        }\n+        $dir = $this->generateDirectoryPath($config);\n+        $dh = opendir($dir);\n+        // Apparently, on some versions of PHP, readdir will return\n+        // an empty string if you pass an invalid argument to readdir.\n+        // So you need this test.  See #49.\n+        if (false === $dh) {\n+            return false;\n+        }\n+        while (false !== ($filename = readdir($dh))) {\n+            if (empty($filename)) {\n+                continue;\n+            }\n+            if ($filename[0] === '.') {\n+                continue;\n+            }\n+            unlink($dir . '/' . $filename);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @return bool\n+     */\n+    public function cleanup($config)\n+    {\n+        if (!$this->_prepareDir($config)) {\n+            return false;\n+        }\n+        $dir = $this->generateDirectoryPath($config);\n+        $dh = opendir($dir);\n+        // See #49 (and above).\n+        if (false === $dh) {\n+            return false;\n+        }\n+        while (false !== ($filename = readdir($dh))) {\n+            if (empty($filename)) {\n+                continue;\n+            }\n+            if ($filename[0] === '.') {\n+                continue;\n+            }\n+            $key = substr($filename, 0, strlen($filename) - 4);\n+            if ($this->isOld($key, $config)) {\n+                unlink($dir . '/' . $filename);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Generates the file path to the serial file corresponding to\n+     * the configuration and definition name\n+     * @param HTMLPurifier_Config $config\n+     * @return string\n+     * @todo Make protected\n+     */\n+    public function generateFilePath($config)\n+    {\n+        $key = $this->generateKey($config);\n+        return $this->generateDirectoryPath($config) . '/' . $key . '.ser';\n+    }\n+\n+    /**\n+     * Generates the path to the directory contain this cache's serial files\n+     * @param HTMLPurifier_Config $config\n+     * @return string\n+     * @note No trailing slash\n+     * @todo Make protected\n+     */\n+    public function generateDirectoryPath($config)\n+    {\n+        $base = $this->generateBaseDirectoryPath($config);\n+        return $base . '/' . $this->type;\n+    }\n+\n+    /**\n+     * Generates path to base directory that contains all definition type\n+     * serials\n+     * @param HTMLPurifier_Config $config\n+     * @return mixed|string\n+     * @todo Make protected\n+     */\n+    public function generateBaseDirectoryPath($config)\n+    {\n+        $base = $config->get('Cache.SerializerPath');\n+        $base = is_null($base) ? HTMLPURIFIER_PREFIX . '/HTMLPurifier/DefinitionCache/Serializer' : $base;\n+        return $base;\n+    }\n+\n+    /**\n+     * Convenience wrapper function for file_put_contents\n+     * @param string $file File name to write to\n+     * @param string $data Data to write into file\n+     * @param HTMLPurifier_Config $config\n+     * @return int|bool Number of bytes written if success, or false if failure.\n+     */\n+    private function _write($file, $data, $config)\n+    {\n+        $result = file_put_contents($file, $data);\n+        if ($result !== false) {\n+            // set permissions of the new file (no execute)\n+            $chmod = $config->get('Cache.SerializerPermissions');\n+            if ($chmod === null) {\n+                // don't do anything\n+            } else {\n+                $chmod = $chmod & 0666;\n+                chmod($file, $chmod);\n+            }\n+        }\n+        return $result;\n+    }\n+\n+    /**\n+     * Prepares the directory that this type stores the serials in\n+     * @param HTMLPurifier_Config $config\n+     * @return bool True if successful\n+     */\n+    private function _prepareDir($config)\n+    {\n+        $directory = $this->generateDirectoryPath($config);\n+        $chmod = $config->get('Cache.SerializerPermissions');\n+        if (!is_dir($directory)) {\n+            $base = $this->generateBaseDirectoryPath($config);\n+            if (!is_dir($base)) {\n+                trigger_error(\n+                    'Base directory ' . $base . ' does not exist,\n+                    please create or change using %Cache.SerializerPath',\n+                    E_USER_WARNING\n+                );\n+                return false;\n+            } elseif (!$this->_testPermissions($base, $chmod)) {\n+                return false;\n+            }\n+            if ($chmod === null) {\n+                trigger_error(\n+                    'Base directory ' . $base . ' does not exist,\n+                    please create or change using %Cache.SerializerPath',\n+                    E_USER_WARNING\n+                );\n+                return false;\n+            }\n+            if ($chmod !== null) {\n+                mkdir($directory, $chmod);\n+            } else {\n+                mkdir($directory);\n+            }\n+            if (!$this->_testPermissions($directory, $chmod)) {\n+                trigger_error(\n+                    'Base directory ' . $base . ' does not exist,\n+                    please create or change using %Cache.SerializerPath',\n+                    E_USER_WARNING\n+                );\n+                return false;\n+            }\n+        } elseif (!$this->_testPermissions($directory, $chmod)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Tests permissions on a directory and throws out friendly\n+     * error messages and attempts to chmod it itself if possible\n+     * @param string $dir Directory path\n+     * @param int $chmod Permissions\n+     * @return bool True if directory is writable\n+     */\n+    private function _testPermissions($dir, $chmod)\n+    {\n+        // early abort, if it is writable, everything is hunky-dory\n+        if (is_writable($dir)) {\n+            return true;\n+        }\n+        if (!is_dir($dir)) {\n+            // generally, you'll want to handle this beforehand\n+            // so a more specific error message can be given\n+            trigger_error(\n+                'Directory ' . $dir . ' does not exist',\n+                E_USER_WARNING\n+            );\n+            return false;\n+        }\n+        if (function_exists('posix_getuid') && $chmod !== null) {\n+            // POSIX system, we can give more specific advice\n+            if (fileowner($dir) === posix_getuid()) {\n+                // we can chmod it ourselves\n+                $chmod = $chmod | 0700;\n+                if (chmod($dir, $chmod)) {\n+                    return true;\n+                }\n+            } elseif (filegroup($dir) === posix_getgid()) {\n+                $chmod = $chmod | 0070;\n+            } else {\n+                // PHP's probably running as nobody, so we'll\n+                // need to give global permissions\n+                $chmod = $chmod | 0777;\n+            }\n+            trigger_error(\n+                'Directory ' . $dir . ' not writable, ' .\n+                'please chmod to ' . decoct($chmod),\n+                E_USER_WARNING\n+            );\n+        } else {\n+            // generic error message\n+            trigger_error(\n+                'Directory ' . $dir . ' not writable, ' .\n+                'please alter file permissions',\n+                E_USER_WARNING\n+            );\n+        }\n+        return false;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/DefinitionCache/Serializer/HTML/4.8.0,b6889960956c877d241a7e8f87e613efc7a3611d,1.ser",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/DefinitionCache/Serializer/README",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+This is a dummy file to prevent Git from ignoring this empty directory.\n+\n+    vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/DefinitionCache/Serializer/URI/4.8.0,3478238e680361cd87bf880f5b3cc50a1e7abc6c,1.ser",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/DefinitionCacheFactory.php",
          "status": "added",
          "additions": 106,
          "deletions": 0,
          "patch": "@@ -0,0 +1,106 @@\n+<?php\n+\n+/**\n+ * Responsible for creating definition caches.\n+ */\n+class HTMLPurifier_DefinitionCacheFactory\n+{\n+    /**\n+     * @type array\n+     */\n+    protected $caches = array('Serializer' => array());\n+\n+    /**\n+     * @type array\n+     */\n+    protected $implementations = array();\n+\n+    /**\n+     * @type HTMLPurifier_DefinitionCache_Decorator[]\n+     */\n+    protected $decorators = array();\n+\n+    /**\n+     * Initialize default decorators\n+     */\n+    public function setup()\n+    {\n+        $this->addDecorator('Cleanup');\n+    }\n+\n+    /**\n+     * Retrieves an instance of global definition cache factory.\n+     * @param HTMLPurifier_DefinitionCacheFactory $prototype\n+     * @return HTMLPurifier_DefinitionCacheFactory\n+     */\n+    public static function instance($prototype = null)\n+    {\n+        static $instance;\n+        if ($prototype !== null) {\n+            $instance = $prototype;\n+        } elseif ($instance === null || $prototype === true) {\n+            $instance = new HTMLPurifier_DefinitionCacheFactory();\n+            $instance->setup();\n+        }\n+        return $instance;\n+    }\n+\n+    /**\n+     * Registers a new definition cache object\n+     * @param string $short Short name of cache object, for reference\n+     * @param string $long Full class name of cache object, for construction\n+     */\n+    public function register($short, $long)\n+    {\n+        $this->implementations[$short] = $long;\n+    }\n+\n+    /**\n+     * Factory method that creates a cache object based on configuration\n+     * @param string $type Name of definitions handled by cache\n+     * @param HTMLPurifier_Config $config Config instance\n+     * @return mixed\n+     */\n+    public function create($type, $config)\n+    {\n+        $method = $config->get('Cache.DefinitionImpl');\n+        if ($method === null) {\n+            return new HTMLPurifier_DefinitionCache_Null($type);\n+        }\n+        if (!empty($this->caches[$method][$type])) {\n+            return $this->caches[$method][$type];\n+        }\n+        if (isset($this->implementations[$method]) &&\n+            class_exists($class = $this->implementations[$method], false)) {\n+            $cache = new $class($type);\n+        } else {\n+            if ($method != 'Serializer') {\n+                trigger_error(\"Unrecognized DefinitionCache $method, using Serializer instead\", E_USER_WARNING);\n+            }\n+            $cache = new HTMLPurifier_DefinitionCache_Serializer($type);\n+        }\n+        foreach ($this->decorators as $decorator) {\n+            $new_cache = $decorator->decorate($cache);\n+            // prevent infinite recursion in PHP 4\n+            unset($cache);\n+            $cache = $new_cache;\n+        }\n+        $this->caches[$method][$type] = $cache;\n+        return $this->caches[$method][$type];\n+    }\n+\n+    /**\n+     * Registers a decorator to add to all new cache objects\n+     * @param HTMLPurifier_DefinitionCache_Decorator|string $decorator An instance or the name of a decorator\n+     */\n+    public function addDecorator($decorator)\n+    {\n+        if (is_string($decorator)) {\n+            $class = \"HTMLPurifier_DefinitionCache_Decorator_$decorator\";\n+            $decorator = new $class;\n+        }\n+        $this->decorators[$decorator->name] = $decorator;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Doctype.php",
          "status": "added",
          "additions": 73,
          "deletions": 0,
          "patch": "@@ -0,0 +1,73 @@\n+<?php\n+\n+/**\n+ * Represents a document type, contains information on which modules\n+ * need to be loaded.\n+ * @note This class is inspected by Printer_HTMLDefinition->renderDoctype.\n+ *       If structure changes, please update that function.\n+ */\n+class HTMLPurifier_Doctype\n+{\n+    /**\n+     * Full name of doctype\n+     * @type string\n+     */\n+    public $name;\n+\n+    /**\n+     * List of standard modules (string identifiers or literal objects)\n+     * that this doctype uses\n+     * @type array\n+     */\n+    public $modules = array();\n+\n+    /**\n+     * List of modules to use for tidying up code\n+     * @type array\n+     */\n+    public $tidyModules = array();\n+\n+    /**\n+     * Is the language derived from XML (i.e. XHTML)?\n+     * @type bool\n+     */\n+    public $xml = true;\n+\n+    /**\n+     * List of aliases for this doctype\n+     * @type array\n+     */\n+    public $aliases = array();\n+\n+    /**\n+     * Public DTD identifier\n+     * @type string\n+     */\n+    public $dtdPublic;\n+\n+    /**\n+     * System DTD identifier\n+     * @type string\n+     */\n+    public $dtdSystem;\n+\n+    public function __construct(\n+        $name = null,\n+        $xml = true,\n+        $modules = array(),\n+        $tidyModules = array(),\n+        $aliases = array(),\n+        $dtd_public = null,\n+        $dtd_system = null\n+    ) {\n+        $this->name         = $name;\n+        $this->xml          = $xml;\n+        $this->modules      = $modules;\n+        $this->tidyModules  = $tidyModules;\n+        $this->aliases      = $aliases;\n+        $this->dtdPublic    = $dtd_public;\n+        $this->dtdSystem    = $dtd_system;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/DoctypeRegistry.php",
          "status": "added",
          "additions": 142,
          "deletions": 0,
          "patch": "@@ -0,0 +1,142 @@\n+<?php\n+\n+class HTMLPurifier_DoctypeRegistry\n+{\n+\n+    /**\n+     * Hash of doctype names to doctype objects.\n+     * @type array\n+     */\n+    protected $doctypes;\n+\n+    /**\n+     * Lookup table of aliases to real doctype names.\n+     * @type array\n+     */\n+    protected $aliases;\n+\n+    /**\n+     * Registers a doctype to the registry\n+     * @note Accepts a fully-formed doctype object, or the\n+     *       parameters for constructing a doctype object\n+     * @param string $doctype Name of doctype or literal doctype object\n+     * @param bool $xml\n+     * @param array $modules Modules doctype will load\n+     * @param array $tidy_modules Modules doctype will load for certain modes\n+     * @param array $aliases Alias names for doctype\n+     * @param string $dtd_public\n+     * @param string $dtd_system\n+     * @return HTMLPurifier_Doctype Editable registered doctype\n+     */\n+    public function register(\n+        $doctype,\n+        $xml = true,\n+        $modules = array(),\n+        $tidy_modules = array(),\n+        $aliases = array(),\n+        $dtd_public = null,\n+        $dtd_system = null\n+    ) {\n+        if (!is_array($modules)) {\n+            $modules = array($modules);\n+        }\n+        if (!is_array($tidy_modules)) {\n+            $tidy_modules = array($tidy_modules);\n+        }\n+        if (!is_array($aliases)) {\n+            $aliases = array($aliases);\n+        }\n+        if (!is_object($doctype)) {\n+            $doctype = new HTMLPurifier_Doctype(\n+                $doctype,\n+                $xml,\n+                $modules,\n+                $tidy_modules,\n+                $aliases,\n+                $dtd_public,\n+                $dtd_system\n+            );\n+        }\n+        $this->doctypes[$doctype->name] = $doctype;\n+        $name = $doctype->name;\n+        // hookup aliases\n+        foreach ($doctype->aliases as $alias) {\n+            if (isset($this->doctypes[$alias])) {\n+                continue;\n+            }\n+            $this->aliases[$alias] = $name;\n+        }\n+        // remove old aliases\n+        if (isset($this->aliases[$name])) {\n+            unset($this->aliases[$name]);\n+        }\n+        return $doctype;\n+    }\n+\n+    /**\n+     * Retrieves reference to a doctype of a certain name\n+     * @note This function resolves aliases\n+     * @note When possible, use the more fully-featured make()\n+     * @param string $doctype Name of doctype\n+     * @return HTMLPurifier_Doctype Editable doctype object\n+     */\n+    public function get($doctype)\n+    {\n+        if (isset($this->aliases[$doctype])) {\n+            $doctype = $this->aliases[$doctype];\n+        }\n+        if (!isset($this->doctypes[$doctype])) {\n+            trigger_error('Doctype ' . htmlspecialchars($doctype) . ' does not exist', E_USER_ERROR);\n+            $anon = new HTMLPurifier_Doctype($doctype);\n+            return $anon;\n+        }\n+        return $this->doctypes[$doctype];\n+    }\n+\n+    /**\n+     * Creates a doctype based on a configuration object,\n+     * will perform initialization on the doctype\n+     * @note Use this function to get a copy of doctype that config\n+     *       can hold on to (this is necessary in order to tell\n+     *       Generator whether or not the current document is XML\n+     *       based or not).\n+     * @param HTMLPurifier_Config $config\n+     * @return HTMLPurifier_Doctype\n+     */\n+    public function make($config)\n+    {\n+        return clone $this->get($this->getDoctypeFromConfig($config));\n+    }\n+\n+    /**\n+     * Retrieves the doctype from the configuration object\n+     * @param HTMLPurifier_Config $config\n+     * @return string\n+     */\n+    public function getDoctypeFromConfig($config)\n+    {\n+        // recommended test\n+        $doctype = $config->get('HTML.Doctype');\n+        if (!empty($doctype)) {\n+            return $doctype;\n+        }\n+        $doctype = $config->get('HTML.CustomDoctype');\n+        if (!empty($doctype)) {\n+            return $doctype;\n+        }\n+        // backwards-compatibility\n+        if ($config->get('HTML.XHTML')) {\n+            $doctype = 'XHTML 1.0';\n+        } else {\n+            $doctype = 'HTML 4.01';\n+        }\n+        if ($config->get('HTML.Strict')) {\n+            $doctype .= ' Strict';\n+        } else {\n+            $doctype .= ' Transitional';\n+        }\n+        return $doctype;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ElementDef.php",
          "status": "added",
          "additions": 216,
          "deletions": 0,
          "patch": "@@ -0,0 +1,216 @@\n+<?php\n+\n+/**\n+ * Structure that stores an HTML element definition. Used by\n+ * HTMLPurifier_HTMLDefinition and HTMLPurifier_HTMLModule.\n+ * @note This class is inspected by HTMLPurifier_Printer_HTMLDefinition.\n+ *       Please update that class too.\n+ * @warning If you add new properties to this class, you MUST update\n+ *          the mergeIn() method.\n+ */\n+class HTMLPurifier_ElementDef\n+{\n+    /**\n+     * Does the definition work by itself, or is it created solely\n+     * for the purpose of merging into another definition?\n+     * @type bool\n+     */\n+    public $standalone = true;\n+\n+    /**\n+     * Associative array of attribute name to HTMLPurifier_AttrDef.\n+     * @type array\n+     * @note Before being processed by HTMLPurifier_AttrCollections\n+     *       when modules are finalized during\n+     *       HTMLPurifier_HTMLDefinition->setup(), this array may also\n+     *       contain an array at index 0 that indicates which attribute\n+     *       collections to load into the full array. It may also\n+     *       contain string indentifiers in lieu of HTMLPurifier_AttrDef,\n+     *       see HTMLPurifier_AttrTypes on how they are expanded during\n+     *       HTMLPurifier_HTMLDefinition->setup() processing.\n+     */\n+    public $attr = array();\n+\n+    // XXX: Design note: currently, it's not possible to override\n+    // previously defined AttrTransforms without messing around with\n+    // the final generated config. This is by design; a previous version\n+    // used an associated list of attr_transform, but it was extremely\n+    // easy to accidentally override other attribute transforms by\n+    // forgetting to specify an index (and just using 0.)  While we\n+    // could check this by checking the index number and complaining,\n+    // there is a second problem which is that it is not at all easy to\n+    // tell when something is getting overridden. Combine this with a\n+    // codebase where this isn't really being used, and it's perfect for\n+    // nuking.\n+\n+    /**\n+     * List of tags HTMLPurifier_AttrTransform to be done before validation.\n+     * @type array\n+     */\n+    public $attr_transform_pre = array();\n+\n+    /**\n+     * List of tags HTMLPurifier_AttrTransform to be done after validation.\n+     * @type array\n+     */\n+    public $attr_transform_post = array();\n+\n+    /**\n+     * HTMLPurifier_ChildDef of this tag.\n+     * @type HTMLPurifier_ChildDef\n+     */\n+    public $child;\n+\n+    /**\n+     * Abstract string representation of internal ChildDef rules.\n+     * @see HTMLPurifier_ContentSets for how this is parsed and then transformed\n+     * into an HTMLPurifier_ChildDef.\n+     * @warning This is a temporary variable that is not available after\n+     *      being processed by HTMLDefinition\n+     * @type string\n+     */\n+    public $content_model;\n+\n+    /**\n+     * Value of $child->type, used to determine which ChildDef to use,\n+     * used in combination with $content_model.\n+     * @warning This must be lowercase\n+     * @warning This is a temporary variable that is not available after\n+     *      being processed by HTMLDefinition\n+     * @type string\n+     */\n+    public $content_model_type;\n+\n+    /**\n+     * Does the element have a content model (#PCDATA | Inline)*? This\n+     * is important for chameleon ins and del processing in\n+     * HTMLPurifier_ChildDef_Chameleon. Dynamically set: modules don't\n+     * have to worry about this one.\n+     * @type bool\n+     */\n+    public $descendants_are_inline = false;\n+\n+    /**\n+     * List of the names of required attributes this element has.\n+     * Dynamically populated by HTMLPurifier_HTMLDefinition::getElement()\n+     * @type array\n+     */\n+    public $required_attr = array();\n+\n+    /**\n+     * Lookup table of tags excluded from all descendants of this tag.\n+     * @type array\n+     * @note SGML permits exclusions for all descendants, but this is\n+     *       not possible with DTDs or XML Schemas. W3C has elected to\n+     *       use complicated compositions of content_models to simulate\n+     *       exclusion for children, but we go the simpler, SGML-style\n+     *       route of flat-out exclusions, which correctly apply to\n+     *       all descendants and not just children. Note that the XHTML\n+     *       Modularization Abstract Modules are blithely unaware of such\n+     *       distinctions.\n+     */\n+    public $excludes = array();\n+\n+    /**\n+     * This tag is explicitly auto-closed by the following tags.\n+     * @type array\n+     */\n+    public $autoclose = array();\n+\n+    /**\n+     * If a foreign element is found in this element, test if it is\n+     * allowed by this sub-element; if it is, instead of closing the\n+     * current element, place it inside this element.\n+     * @type string\n+     */\n+    public $wrap;\n+\n+    /**\n+     * Whether or not this is a formatting element affected by the\n+     * \"Active Formatting Elements\" algorithm.\n+     * @type bool\n+     */\n+    public $formatting;\n+\n+    /**\n+     * Low-level factory constructor for creating new standalone element defs\n+     */\n+    public static function create($content_model, $content_model_type, $attr)\n+    {\n+        $def = new HTMLPurifier_ElementDef();\n+        $def->content_model = $content_model;\n+        $def->content_model_type = $content_model_type;\n+        $def->attr = $attr;\n+        return $def;\n+    }\n+\n+    /**\n+     * Merges the values of another element definition into this one.\n+     * Values from the new element def take precedence if a value is\n+     * not mergeable.\n+     * @param HTMLPurifier_ElementDef $def\n+     */\n+    public function mergeIn($def)\n+    {\n+        // later keys takes precedence\n+        foreach ($def->attr as $k => $v) {\n+            if ($k === 0) {\n+                // merge in the includes\n+                // sorry, no way to override an include\n+                foreach ($v as $v2) {\n+                    $this->attr[0][] = $v2;\n+                }\n+                continue;\n+            }\n+            if ($v === false) {\n+                if (isset($this->attr[$k])) {\n+                    unset($this->attr[$k]);\n+                }\n+                continue;\n+            }\n+            $this->attr[$k] = $v;\n+        }\n+        $this->_mergeAssocArray($this->excludes, $def->excludes);\n+        $this->attr_transform_pre = array_merge($this->attr_transform_pre, $def->attr_transform_pre);\n+        $this->attr_transform_post = array_merge($this->attr_transform_post, $def->attr_transform_post);\n+\n+        if (!empty($def->content_model)) {\n+            $this->content_model =\n+                str_replace(\"#SUPER\", $this->content_model, $def->content_model);\n+            $this->child = false;\n+        }\n+        if (!empty($def->content_model_type)) {\n+            $this->content_model_type = $def->content_model_type;\n+            $this->child = false;\n+        }\n+        if (!is_null($def->child)) {\n+            $this->child = $def->child;\n+        }\n+        if (!is_null($def->formatting)) {\n+            $this->formatting = $def->formatting;\n+        }\n+        if ($def->descendants_are_inline) {\n+            $this->descendants_are_inline = $def->descendants_are_inline;\n+        }\n+    }\n+\n+    /**\n+     * Merges one array into another, removes values which equal false\n+     * @param $a1 Array by reference that is merged into\n+     * @param $a2 Array that merges into $a1\n+     */\n+    private function _mergeAssocArray(&$a1, $a2)\n+    {\n+        foreach ($a2 as $k => $v) {\n+            if ($v === false) {\n+                if (isset($a1[$k])) {\n+                    unset($a1[$k]);\n+                }\n+                continue;\n+            }\n+            $a1[$k] = $v;\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Encoder.php",
          "status": "added",
          "additions": 611,
          "deletions": 0,
          "patch": "@@ -0,0 +1,611 @@\n+<?php\n+\n+/**\n+ * A UTF-8 specific character encoder that handles cleaning and transforming.\n+ * @note All functions in this class should be static.\n+ */\n+class HTMLPurifier_Encoder\n+{\n+\n+    /**\n+     * Constructor throws fatal error if you attempt to instantiate class\n+     */\n+    private function __construct()\n+    {\n+        trigger_error('Cannot instantiate encoder, call methods statically', E_USER_ERROR);\n+    }\n+\n+    /**\n+     * Error-handler that mutes errors, alternative to shut-up operator.\n+     */\n+    public static function muteErrorHandler()\n+    {\n+    }\n+\n+    /**\n+     * iconv wrapper which mutes errors, but doesn't work around bugs.\n+     * @param string $in Input encoding\n+     * @param string $out Output encoding\n+     * @param string $text The text to convert\n+     * @return string\n+     */\n+    public static function unsafeIconv($in, $out, $text)\n+    {\n+        set_error_handler(array('HTMLPurifier_Encoder', 'muteErrorHandler'));\n+        $r = iconv($in, $out, $text);\n+        restore_error_handler();\n+        return $r;\n+    }\n+\n+    /**\n+     * iconv wrapper which mutes errors and works around bugs.\n+     * @param string $in Input encoding\n+     * @param string $out Output encoding\n+     * @param string $text The text to convert\n+     * @param int $max_chunk_size\n+     * @return string\n+     */\n+    public static function iconv($in, $out, $text, $max_chunk_size = 8000)\n+    {\n+        $code = self::testIconvTruncateBug();\n+        if ($code == self::ICONV_OK) {\n+            return self::unsafeIconv($in, $out, $text);\n+        } elseif ($code == self::ICONV_TRUNCATES) {\n+            // we can only work around this if the input character set\n+            // is utf-8\n+            if ($in == 'utf-8') {\n+                if ($max_chunk_size < 4) {\n+                    trigger_error('max_chunk_size is too small', E_USER_WARNING);\n+                    return false;\n+                }\n+                // split into 8000 byte chunks, but be careful to handle\n+                // multibyte boundaries properly\n+                if (($c = strlen($text)) <= $max_chunk_size) {\n+                    return self::unsafeIconv($in, $out, $text);\n+                }\n+                $r = '';\n+                $i = 0;\n+                while (true) {\n+                    if ($i + $max_chunk_size >= $c) {\n+                        $r .= self::unsafeIconv($in, $out, substr($text, $i));\n+                        break;\n+                    }\n+                    // wibble the boundary\n+                    if (0x80 != (0xC0 & ord($text[$i + $max_chunk_size]))) {\n+                        $chunk_size = $max_chunk_size;\n+                    } elseif (0x80 != (0xC0 & ord($text[$i + $max_chunk_size - 1]))) {\n+                        $chunk_size = $max_chunk_size - 1;\n+                    } elseif (0x80 != (0xC0 & ord($text[$i + $max_chunk_size - 2]))) {\n+                        $chunk_size = $max_chunk_size - 2;\n+                    } elseif (0x80 != (0xC0 & ord($text[$i + $max_chunk_size - 3]))) {\n+                        $chunk_size = $max_chunk_size - 3;\n+                    } else {\n+                        return false; // rather confusing UTF-8...\n+                    }\n+                    $chunk = substr($text, $i, $chunk_size); // substr doesn't mind overlong lengths\n+                    $r .= self::unsafeIconv($in, $out, $chunk);\n+                    $i += $chunk_size;\n+                }\n+                return $r;\n+            } else {\n+                return false;\n+            }\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Cleans a UTF-8 string for well-formedness and SGML validity\n+     *\n+     * It will parse according to UTF-8 and return a valid UTF8 string, with\n+     * non-SGML codepoints excluded.\n+     *\n+     * @param string $str The string to clean\n+     * @param bool $force_php\n+     * @return string\n+     *\n+     * @note Just for reference, the non-SGML code points are 0 to 31 and\n+     *       127 to 159, inclusive.  However, we allow code points 9, 10\n+     *       and 13, which are the tab, line feed and carriage return\n+     *       respectively. 128 and above the code points map to multibyte\n+     *       UTF-8 representations.\n+     *\n+     * @note Fallback code adapted from utf8ToUnicode by Henri Sivonen and\n+     *       hsivonen@iki.fi at <http://iki.fi/hsivonen/php-utf8/> under the\n+     *       LGPL license.  Notes on what changed are inside, but in general,\n+     *       the original code transformed UTF-8 text into an array of integer\n+     *       Unicode codepoints. Understandably, transforming that back to\n+     *       a string would be somewhat expensive, so the function was modded to\n+     *       directly operate on the string.  However, this discourages code\n+     *       reuse, and the logic enumerated here would be useful for any\n+     *       function that needs to be able to understand UTF-8 characters.\n+     *       As of right now, only smart lossless character encoding converters\n+     *       would need that, and I'm probably not going to implement them.\n+     *       Once again, PHP 6 should solve all our problems.\n+     */\n+    public static function cleanUTF8($str, $force_php = false)\n+    {\n+        // UTF-8 validity is checked since PHP 4.3.5\n+        // This is an optimization: if the string is already valid UTF-8, no\n+        // need to do PHP stuff. 99% of the time, this will be the case.\n+        // The regexp matches the XML char production, as well as well as excluding\n+        // non-SGML codepoints U+007F to U+009F\n+        if (preg_match(\n+            '/^[\\x{9}\\x{A}\\x{D}\\x{20}-\\x{7E}\\x{A0}-\\x{D7FF}\\x{E000}-\\x{FFFD}\\x{10000}-\\x{10FFFF}]*$/Du',\n+            $str\n+        )) {\n+            return $str;\n+        }\n+\n+        $mState = 0; // cached expected number of octets after the current octet\n+                     // until the beginning of the next UTF8 character sequence\n+        $mUcs4  = 0; // cached Unicode character\n+        $mBytes = 1; // cached expected number of octets in the current sequence\n+\n+        // original code involved an $out that was an array of Unicode\n+        // codepoints.  Instead of having to convert back into UTF-8, we've\n+        // decided to directly append valid UTF-8 characters onto a string\n+        // $out once they're done.  $char accumulates raw bytes, while $mUcs4\n+        // turns into the Unicode code point, so there's some redundancy.\n+\n+        $out = '';\n+        $char = '';\n+\n+        $len = strlen($str);\n+        for ($i = 0; $i < $len; $i++) {\n+            $in = ord($str{$i});\n+            $char .= $str[$i]; // append byte to char\n+            if (0 == $mState) {\n+                // When mState is zero we expect either a US-ASCII character\n+                // or a multi-octet sequence.\n+                if (0 == (0x80 & ($in))) {\n+                    // US-ASCII, pass straight through.\n+                    if (($in <= 31 || $in == 127) &&\n+                        !($in == 9 || $in == 13 || $in == 10) // save \\r\\t\\n\n+                    ) {\n+                        // control characters, remove\n+                    } else {\n+                        $out .= $char;\n+                    }\n+                    // reset\n+                    $char = '';\n+                    $mBytes = 1;\n+                } elseif (0xC0 == (0xE0 & ($in))) {\n+                    // First octet of 2 octet sequence\n+                    $mUcs4 = ($in);\n+                    $mUcs4 = ($mUcs4 & 0x1F) << 6;\n+                    $mState = 1;\n+                    $mBytes = 2;\n+                } elseif (0xE0 == (0xF0 & ($in))) {\n+                    // First octet of 3 octet sequence\n+                    $mUcs4 = ($in);\n+                    $mUcs4 = ($mUcs4 & 0x0F) << 12;\n+                    $mState = 2;\n+                    $mBytes = 3;\n+                } elseif (0xF0 == (0xF8 & ($in))) {\n+                    // First octet of 4 octet sequence\n+                    $mUcs4 = ($in);\n+                    $mUcs4 = ($mUcs4 & 0x07) << 18;\n+                    $mState = 3;\n+                    $mBytes = 4;\n+                } elseif (0xF8 == (0xFC & ($in))) {\n+                    // First octet of 5 octet sequence.\n+                    //\n+                    // This is illegal because the encoded codepoint must be\n+                    // either:\n+                    // (a) not the shortest form or\n+                    // (b) outside the Unicode range of 0-0x10FFFF.\n+                    // Rather than trying to resynchronize, we will carry on\n+                    // until the end of the sequence and let the later error\n+                    // handling code catch it.\n+                    $mUcs4 = ($in);\n+                    $mUcs4 = ($mUcs4 & 0x03) << 24;\n+                    $mState = 4;\n+                    $mBytes = 5;\n+                } elseif (0xFC == (0xFE & ($in))) {\n+                    // First octet of 6 octet sequence, see comments for 5\n+                    // octet sequence.\n+                    $mUcs4 = ($in);\n+                    $mUcs4 = ($mUcs4 & 1) << 30;\n+                    $mState = 5;\n+                    $mBytes = 6;\n+                } else {\n+                    // Current octet is neither in the US-ASCII range nor a\n+                    // legal first octet of a multi-octet sequence.\n+                    $mState = 0;\n+                    $mUcs4  = 0;\n+                    $mBytes = 1;\n+                    $char = '';\n+                }\n+            } else {\n+                // When mState is non-zero, we expect a continuation of the\n+                // multi-octet sequence\n+                if (0x80 == (0xC0 & ($in))) {\n+                    // Legal continuation.\n+                    $shift = ($mState - 1) * 6;\n+                    $tmp = $in;\n+                    $tmp = ($tmp & 0x0000003F) << $shift;\n+                    $mUcs4 |= $tmp;\n+\n+                    if (0 == --$mState) {\n+                        // End of the multi-octet sequence. mUcs4 now contains\n+                        // the final Unicode codepoint to be output\n+\n+                        // Check for illegal sequences and codepoints.\n+\n+                        // From Unicode 3.1, non-shortest form is illegal\n+                        if (((2 == $mBytes) && ($mUcs4 < 0x0080)) ||\n+                            ((3 == $mBytes) && ($mUcs4 < 0x0800)) ||\n+                            ((4 == $mBytes) && ($mUcs4 < 0x10000)) ||\n+                            (4 < $mBytes) ||\n+                            // From Unicode 3.2, surrogate characters = illegal\n+                            (($mUcs4 & 0xFFFFF800) == 0xD800) ||\n+                            // Codepoints outside the Unicode range are illegal\n+                            ($mUcs4 > 0x10FFFF)\n+                        ) {\n+\n+                        } elseif (0xFEFF != $mUcs4 && // omit BOM\n+                            // check for valid Char unicode codepoints\n+                            (\n+                                0x9 == $mUcs4 ||\n+                                0xA == $mUcs4 ||\n+                                0xD == $mUcs4 ||\n+                                (0x20 <= $mUcs4 && 0x7E >= $mUcs4) ||\n+                                // 7F-9F is not strictly prohibited by XML,\n+                                // but it is non-SGML, and thus we don't allow it\n+                                (0xA0 <= $mUcs4 && 0xD7FF >= $mUcs4) ||\n+                                (0x10000 <= $mUcs4 && 0x10FFFF >= $mUcs4)\n+                            )\n+                        ) {\n+                            $out .= $char;\n+                        }\n+                        // initialize UTF8 cache (reset)\n+                        $mState = 0;\n+                        $mUcs4  = 0;\n+                        $mBytes = 1;\n+                        $char = '';\n+                    }\n+                } else {\n+                    // ((0xC0 & (*in) != 0x80) && (mState != 0))\n+                    // Incomplete multi-octet sequence.\n+                    // used to result in complete fail, but we'll reset\n+                    $mState = 0;\n+                    $mUcs4  = 0;\n+                    $mBytes = 1;\n+                    $char ='';\n+                }\n+            }\n+        }\n+        return $out;\n+    }\n+\n+    /**\n+     * Translates a Unicode codepoint into its corresponding UTF-8 character.\n+     * @note Based on Feyd's function at\n+     *       <http://forums.devnetwork.net/viewtopic.php?p=191404#191404>,\n+     *       which is in public domain.\n+     * @note While we're going to do code point parsing anyway, a good\n+     *       optimization would be to refuse to translate code points that\n+     *       are non-SGML characters.  However, this could lead to duplication.\n+     * @note This is very similar to the unichr function in\n+     *       maintenance/generate-entity-file.php (although this is superior,\n+     *       due to its sanity checks).\n+     */\n+\n+    // +----------+----------+----------+----------+\n+    // | 33222222 | 22221111 | 111111   |          |\n+    // | 10987654 | 32109876 | 54321098 | 76543210 | bit\n+    // +----------+----------+----------+----------+\n+    // |          |          |          | 0xxxxxxx | 1 byte 0x00000000..0x0000007F\n+    // |          |          | 110yyyyy | 10xxxxxx | 2 byte 0x00000080..0x000007FF\n+    // |          | 1110zzzz | 10yyyyyy | 10xxxxxx | 3 byte 0x00000800..0x0000FFFF\n+    // | 11110www | 10wwzzzz | 10yyyyyy | 10xxxxxx | 4 byte 0x00010000..0x0010FFFF\n+    // +----------+----------+----------+----------+\n+    // | 00000000 | 00011111 | 11111111 | 11111111 | Theoretical upper limit of legal scalars: 2097151 (0x001FFFFF)\n+    // | 00000000 | 00010000 | 11111111 | 11111111 | Defined upper limit of legal scalar codes\n+    // +----------+----------+----------+----------+\n+\n+    public static function unichr($code)\n+    {\n+        if ($code > 1114111 or $code < 0 or\n+          ($code >= 55296 and $code <= 57343) ) {\n+            // bits are set outside the \"valid\" range as defined\n+            // by UNICODE 4.1.0\n+            return '';\n+        }\n+\n+        $x = $y = $z = $w = 0;\n+        if ($code < 128) {\n+            // regular ASCII character\n+            $x = $code;\n+        } else {\n+            // set up bits for UTF-8\n+            $x = ($code & 63) | 128;\n+            if ($code < 2048) {\n+                $y = (($code & 2047) >> 6) | 192;\n+            } else {\n+                $y = (($code & 4032) >> 6) | 128;\n+                if ($code < 65536) {\n+                    $z = (($code >> 12) & 15) | 224;\n+                } else {\n+                    $z = (($code >> 12) & 63) | 128;\n+                    $w = (($code >> 18) & 7)  | 240;\n+                }\n+            }\n+        }\n+        // set up the actual character\n+        $ret = '';\n+        if ($w) {\n+            $ret .= chr($w);\n+        }\n+        if ($z) {\n+            $ret .= chr($z);\n+        }\n+        if ($y) {\n+            $ret .= chr($y);\n+        }\n+        $ret .= chr($x);\n+\n+        return $ret;\n+    }\n+\n+    /**\n+     * @return bool\n+     */\n+    public static function iconvAvailable()\n+    {\n+        static $iconv = null;\n+        if ($iconv === null) {\n+            $iconv = function_exists('iconv') && self::testIconvTruncateBug() != self::ICONV_UNUSABLE;\n+        }\n+        return $iconv;\n+    }\n+\n+    /**\n+     * Convert a string to UTF-8 based on configuration.\n+     * @param string $str The string to convert\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return string\n+     */\n+    public static function convertToUTF8($str, $config, $context)\n+    {\n+        $encoding = $config->get('Core.Encoding');\n+        if ($encoding === 'utf-8') {\n+            return $str;\n+        }\n+        static $iconv = null;\n+        if ($iconv === null) {\n+            $iconv = self::iconvAvailable();\n+        }\n+        if ($iconv && !$config->get('Test.ForceNoIconv')) {\n+            // unaffected by bugs, since UTF-8 support all characters\n+            $str = self::unsafeIconv($encoding, 'utf-8//IGNORE', $str);\n+            if ($str === false) {\n+                // $encoding is not a valid encoding\n+                trigger_error('Invalid encoding ' . $encoding, E_USER_ERROR);\n+                return '';\n+            }\n+            // If the string is bjorked by Shift_JIS or a similar encoding\n+            // that doesn't support all of ASCII, convert the naughty\n+            // characters to their true byte-wise ASCII/UTF-8 equivalents.\n+            $str = strtr($str, self::testEncodingSupportsASCII($encoding));\n+            return $str;\n+        } elseif ($encoding === 'iso-8859-1') {\n+            $str = utf8_encode($str);\n+            return $str;\n+        }\n+        $bug = HTMLPurifier_Encoder::testIconvTruncateBug();\n+        if ($bug == self::ICONV_OK) {\n+            trigger_error('Encoding not supported, please install iconv', E_USER_ERROR);\n+        } else {\n+            trigger_error(\n+                'You have a buggy version of iconv, see https://bugs.php.net/bug.php?id=48147 ' .\n+                'and http://sourceware.org/bugzilla/show_bug.cgi?id=13541',\n+                E_USER_ERROR\n+            );\n+        }\n+    }\n+\n+    /**\n+     * Converts a string from UTF-8 based on configuration.\n+     * @param string $str The string to convert\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return string\n+     * @note Currently, this is a lossy conversion, with unexpressable\n+     *       characters being omitted.\n+     */\n+    public static function convertFromUTF8($str, $config, $context)\n+    {\n+        $encoding = $config->get('Core.Encoding');\n+        if ($escape = $config->get('Core.EscapeNonASCIICharacters')) {\n+            $str = self::convertToASCIIDumbLossless($str);\n+        }\n+        if ($encoding === 'utf-8') {\n+            return $str;\n+        }\n+        static $iconv = null;\n+        if ($iconv === null) {\n+            $iconv = self::iconvAvailable();\n+        }\n+        if ($iconv && !$config->get('Test.ForceNoIconv')) {\n+            // Undo our previous fix in convertToUTF8, otherwise iconv will barf\n+            $ascii_fix = self::testEncodingSupportsASCII($encoding);\n+            if (!$escape && !empty($ascii_fix)) {\n+                $clear_fix = array();\n+                foreach ($ascii_fix as $utf8 => $native) {\n+                    $clear_fix[$utf8] = '';\n+                }\n+                $str = strtr($str, $clear_fix);\n+            }\n+            $str = strtr($str, array_flip($ascii_fix));\n+            // Normal stuff\n+            $str = self::iconv('utf-8', $encoding . '//IGNORE', $str);\n+            return $str;\n+        } elseif ($encoding === 'iso-8859-1') {\n+            $str = utf8_decode($str);\n+            return $str;\n+        }\n+        trigger_error('Encoding not supported', E_USER_ERROR);\n+        // You might be tempted to assume that the ASCII representation\n+        // might be OK, however, this is *not* universally true over all\n+        // encodings.  So we take the conservative route here, rather\n+        // than forcibly turn on %Core.EscapeNonASCIICharacters\n+    }\n+\n+    /**\n+     * Lossless (character-wise) conversion of HTML to ASCII\n+     * @param string $str UTF-8 string to be converted to ASCII\n+     * @return string ASCII encoded string with non-ASCII character entity-ized\n+     * @warning Adapted from MediaWiki, claiming fair use: this is a common\n+     *       algorithm. If you disagree with this license fudgery,\n+     *       implement it yourself.\n+     * @note Uses decimal numeric entities since they are best supported.\n+     * @note This is a DUMB function: it has no concept of keeping\n+     *       character entities that the projected character encoding\n+     *       can allow. We could possibly implement a smart version\n+     *       but that would require it to also know which Unicode\n+     *       codepoints the charset supported (not an easy task).\n+     * @note Sort of with cleanUTF8() but it assumes that $str is\n+     *       well-formed UTF-8\n+     */\n+    public static function convertToASCIIDumbLossless($str)\n+    {\n+        $bytesleft = 0;\n+        $result = '';\n+        $working = 0;\n+        $len = strlen($str);\n+        for ($i = 0; $i < $len; $i++) {\n+            $bytevalue = ord($str[$i]);\n+            if ($bytevalue <= 0x7F) { //0xxx xxxx\n+                $result .= chr($bytevalue);\n+                $bytesleft = 0;\n+            } elseif ($bytevalue <= 0xBF) { //10xx xxxx\n+                $working = $working << 6;\n+                $working += ($bytevalue & 0x3F);\n+                $bytesleft--;\n+                if ($bytesleft <= 0) {\n+                    $result .= \"&#\" . $working . \";\";\n+                }\n+            } elseif ($bytevalue <= 0xDF) { //110x xxxx\n+                $working = $bytevalue & 0x1F;\n+                $bytesleft = 1;\n+            } elseif ($bytevalue <= 0xEF) { //1110 xxxx\n+                $working = $bytevalue & 0x0F;\n+                $bytesleft = 2;\n+            } else { //1111 0xxx\n+                $working = $bytevalue & 0x07;\n+                $bytesleft = 3;\n+            }\n+        }\n+        return $result;\n+    }\n+\n+    /** No bugs detected in iconv. */\n+    const ICONV_OK = 0;\n+\n+    /** Iconv truncates output if converting from UTF-8 to another\n+     *  character set with //IGNORE, and a non-encodable character is found */\n+    const ICONV_TRUNCATES = 1;\n+\n+    /** Iconv does not support //IGNORE, making it unusable for\n+     *  transcoding purposes */\n+    const ICONV_UNUSABLE = 2;\n+\n+    /**\n+     * glibc iconv has a known bug where it doesn't handle the magic\n+     * //IGNORE stanza correctly.  In particular, rather than ignore\n+     * characters, it will return an EILSEQ after consuming some number\n+     * of characters, and expect you to restart iconv as if it were\n+     * an E2BIG.  Old versions of PHP did not respect the errno, and\n+     * returned the fragment, so as a result you would see iconv\n+     * mysteriously truncating output. We can work around this by\n+     * manually chopping our input into segments of about 8000\n+     * characters, as long as PHP ignores the error code.  If PHP starts\n+     * paying attention to the error code, iconv becomes unusable.\n+     *\n+     * @return int Error code indicating severity of bug.\n+     */\n+    public static function testIconvTruncateBug()\n+    {\n+        static $code = null;\n+        if ($code === null) {\n+            // better not use iconv, otherwise infinite loop!\n+            $r = self::unsafeIconv('utf-8', 'ascii//IGNORE', \"\\xCE\\xB1\" . str_repeat('a', 9000));\n+            if ($r === false) {\n+                $code = self::ICONV_UNUSABLE;\n+            } elseif (($c = strlen($r)) < 9000) {\n+                $code = self::ICONV_TRUNCATES;\n+            } elseif ($c > 9000) {\n+                trigger_error(\n+                    'Your copy of iconv is extremely buggy. Please notify HTML Purifier maintainers: ' .\n+                    'include your iconv version as per phpversion()',\n+                    E_USER_ERROR\n+                );\n+            } else {\n+                $code = self::ICONV_OK;\n+            }\n+        }\n+        return $code;\n+    }\n+\n+    /**\n+     * This expensive function tests whether or not a given character\n+     * encoding supports ASCII. 7/8-bit encodings like Shift_JIS will\n+     * fail this test, and require special processing. Variable width\n+     * encodings shouldn't ever fail.\n+     *\n+     * @param string $encoding Encoding name to test, as per iconv format\n+     * @param bool $bypass Whether or not to bypass the precompiled arrays.\n+     * @return Array of UTF-8 characters to their corresponding ASCII,\n+     *      which can be used to \"undo\" any overzealous iconv action.\n+     */\n+    public static function testEncodingSupportsASCII($encoding, $bypass = false)\n+    {\n+        // All calls to iconv here are unsafe, proof by case analysis:\n+        // If ICONV_OK, no difference.\n+        // If ICONV_TRUNCATE, all calls involve one character inputs,\n+        // so bug is not triggered.\n+        // If ICONV_UNUSABLE, this call is irrelevant\n+        static $encodings = array();\n+        if (!$bypass) {\n+            if (isset($encodings[$encoding])) {\n+                return $encodings[$encoding];\n+            }\n+            $lenc = strtolower($encoding);\n+            switch ($lenc) {\n+                case 'shift_jis':\n+                    return array(\"\\xC2\\xA5\" => '\\\\', \"\\xE2\\x80\\xBE\" => '~');\n+                case 'johab':\n+                    return array(\"\\xE2\\x82\\xA9\" => '\\\\');\n+            }\n+            if (strpos($lenc, 'iso-8859-') === 0) {\n+                return array();\n+            }\n+        }\n+        $ret = array();\n+        if (self::unsafeIconv('UTF-8', $encoding, 'a') === false) {\n+            return false;\n+        }\n+        for ($i = 0x20; $i <= 0x7E; $i++) { // all printable ASCII chars\n+            $c = chr($i); // UTF-8 char\n+            $r = self::unsafeIconv('UTF-8', \"$encoding//IGNORE\", $c); // initial conversion\n+            if ($r === '' ||\n+                // This line is needed for iconv implementations that do not\n+                // omit characters that do not exist in the target character set\n+                ($r === $c && self::unsafeIconv($encoding, 'UTF-8//IGNORE', $r) !== $c)\n+            ) {\n+                // Reverse engineer: what's the UTF-8 equiv of this byte\n+                // sequence? This assumes that there's no variable width\n+                // encoding that doesn't support ASCII.\n+                $ret[self::unsafeIconv($encoding, 'UTF-8//IGNORE', $c)] = $c;\n+            }\n+        }\n+        $encodings[$encoding] = $ret;\n+        return $ret;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/EntityLookup.php",
          "status": "added",
          "additions": 48,
          "deletions": 0,
          "patch": "@@ -0,0 +1,48 @@\n+<?php\n+\n+/**\n+ * Object that provides entity lookup table from entity name to character\n+ */\n+class HTMLPurifier_EntityLookup\n+{\n+    /**\n+     * Assoc array of entity name to character represented.\n+     * @type array\n+     */\n+    public $table;\n+\n+    /**\n+     * Sets up the entity lookup table from the serialized file contents.\n+     * @param bool $file\n+     * @note The serialized contents are versioned, but were generated\n+     *       using the maintenance script generate_entity_file.php\n+     * @warning This is not in constructor to help enforce the Singleton\n+     */\n+    public function setup($file = false)\n+    {\n+        if (!$file) {\n+            $file = HTMLPURIFIER_PREFIX . '/HTMLPurifier/EntityLookup/entities.ser';\n+        }\n+        $this->table = unserialize(file_get_contents($file));\n+    }\n+\n+    /**\n+     * Retrieves sole instance of the object.\n+     * @param bool|HTMLPurifier_EntityLookup $prototype Optional prototype of custom lookup table to overload with.\n+     * @return HTMLPurifier_EntityLookup\n+     */\n+    public static function instance($prototype = false)\n+    {\n+        // no references, since PHP doesn't copy unless modified\n+        static $instance = null;\n+        if ($prototype) {\n+            $instance = $prototype;\n+        } elseif (!$instance) {\n+            $instance = new HTMLPurifier_EntityLookup();\n+            $instance->setup();\n+        }\n+        return $instance;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/EntityLookup/entities.ser",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+a:253:{s:4:\"fnof\";s:2:\"\u0192\";s:5:\"Alpha\";s:2:\"\u0391\";s:4:\"Beta\";s:2:\"\u0392\";s:5:\"Gamma\";s:2:\"\u0393\";s:5:\"Delta\";s:2:\"\u0394\";s:7:\"Epsilon\";s:2:\"\u0395\";s:4:\"Zeta\";s:2:\"\u0396\";s:3:\"Eta\";s:2:\"\u0397\";s:5:\"Theta\";s:2:\"\u0398\";s:4:\"Iota\";s:2:\"\u0399\";s:5:\"Kappa\";s:2:\"\u039a\";s:6:\"Lambda\";s:2:\"\u039b\";s:2:\"Mu\";s:2:\"\u039c\";s:2:\"Nu\";s:2:\"\u039d\";s:2:\"Xi\";s:2:\"\u039e\";s:7:\"Omicron\";s:2:\"\u039f\";s:2:\"Pi\";s:2:\"\u03a0\";s:3:\"Rho\";s:2:\"\u03a1\";s:5:\"Sigma\";s:2:\"\u03a3\";s:3:\"Tau\";s:2:\"\u03a4\";s:7:\"Upsilon\";s:2:\"\u03a5\";s:3:\"Phi\";s:2:\"\u03a6\";s:3:\"Chi\";s:2:\"\u03a7\";s:3:\"Psi\";s:2:\"\u03a8\";s:5:\"Omega\";s:2:\"\u03a9\";s:5:\"alpha\";s:2:\"\u03b1\";s:4:\"beta\";s:2:\"\u03b2\";s:5:\"gamma\";s:2:\"\u03b3\";s:5:\"delta\";s:2:\"\u03b4\";s:7:\"epsilon\";s:2:\"\u03b5\";s:4:\"zeta\";s:2:\"\u03b6\";s:3:\"eta\";s:2:\"\u03b7\";s:5:\"theta\";s:2:\"\u03b8\";s:4:\"iota\";s:2:\"\u03b9\";s:5:\"kappa\";s:2:\"\u03ba\";s:6:\"lambda\";s:2:\"\u03bb\";s:2:\"mu\";s:2:\"\u03bc\";s:2:\"nu\";s:2:\"\u03bd\";s:2:\"xi\";s:2:\"\u03be\";s:7:\"omicron\";s:2:\"\u03bf\";s:2:\"pi\";s:2:\"\u03c0\";s:3:\"rho\";s:2:\"\u03c1\";s:6:\"sigmaf\";s:2:\"\u03c2\";s:5:\"sigma\";s:2:\"\u03c3\";s:3:\"tau\";s:2:\"\u03c4\";s:7:\"upsilon\";s:2:\"\u03c5\";s:3:\"phi\";s:2:\"\u03c6\";s:3:\"chi\";s:2:\"\u03c7\";s:3:\"psi\";s:2:\"\u03c8\";s:5:\"omega\";s:2:\"\u03c9\";s:8:\"thetasym\";s:2:\"\u03d1\";s:5:\"upsih\";s:2:\"\u03d2\";s:3:\"piv\";s:2:\"\u03d6\";s:4:\"bull\";s:3:\"\u2022\";s:6:\"hellip\";s:3:\"\u2026\";s:5:\"prime\";s:3:\"\u2032\";s:5:\"Prime\";s:3:\"\u2033\";s:5:\"oline\";s:3:\"\u203e\";s:5:\"frasl\";s:3:\"\u2044\";s:6:\"weierp\";s:3:\"\u2118\";s:5:\"image\";s:3:\"\u2111\";s:4:\"real\";s:3:\"\u211c\";s:5:\"trade\";s:3:\"\u2122\";s:7:\"alefsym\";s:3:\"\u2135\";s:4:\"larr\";s:3:\"\u2190\";s:4:\"uarr\";s:3:\"\u2191\";s:4:\"rarr\";s:3:\"\u2192\";s:4:\"darr\";s:3:\"\u2193\";s:4:\"harr\";s:3:\"\u2194\";s:5:\"crarr\";s:3:\"\u21b5\";s:4:\"lArr\";s:3:\"\u21d0\";s:4:\"uArr\";s:3:\"\u21d1\";s:4:\"rArr\";s:3:\"\u21d2\";s:4:\"dArr\";s:3:\"\u21d3\";s:4:\"hArr\";s:3:\"\u21d4\";s:6:\"forall\";s:3:\"\u2200\";s:4:\"part\";s:3:\"\u2202\";s:5:\"exist\";s:3:\"\u2203\";s:5:\"empty\";s:3:\"\u2205\";s:5:\"nabla\";s:3:\"\u2207\";s:4:\"isin\";s:3:\"\u2208\";s:5:\"notin\";s:3:\"\u2209\";s:2:\"ni\";s:3:\"\u220b\";s:4:\"prod\";s:3:\"\u220f\";s:3:\"sum\";s:3:\"\u2211\";s:5:\"minus\";s:3:\"\u2212\";s:6:\"lowast\";s:3:\"\u2217\";s:5:\"radic\";s:3:\"\u221a\";s:4:\"prop\";s:3:\"\u221d\";s:5:\"infin\";s:3:\"\u221e\";s:3:\"ang\";s:3:\"\u2220\";s:3:\"and\";s:3:\"\u2227\";s:2:\"or\";s:3:\"\u2228\";s:3:\"cap\";s:3:\"\u2229\";s:3:\"cup\";s:3:\"\u222a\";s:3:\"int\";s:3:\"\u222b\";s:6:\"there4\";s:3:\"\u2234\";s:3:\"sim\";s:3:\"\u223c\";s:4:\"cong\";s:3:\"\u2245\";s:5:\"asymp\";s:3:\"\u2248\";s:2:\"ne\";s:3:\"\u2260\";s:5:\"equiv\";s:3:\"\u2261\";s:2:\"le\";s:3:\"\u2264\";s:2:\"ge\";s:3:\"\u2265\";s:3:\"sub\";s:3:\"\u2282\";s:3:\"sup\";s:3:\"\u2283\";s:4:\"nsub\";s:3:\"\u2284\";s:4:\"sube\";s:3:\"\u2286\";s:4:\"supe\";s:3:\"\u2287\";s:5:\"oplus\";s:3:\"\u2295\";s:6:\"otimes\";s:3:\"\u2297\";s:4:\"perp\";s:3:\"\u22a5\";s:4:\"sdot\";s:3:\"\u22c5\";s:5:\"lceil\";s:3:\"\u2308\";s:5:\"rceil\";s:3:\"\u2309\";s:6:\"lfloor\";s:3:\"\u230a\";s:6:\"rfloor\";s:3:\"\u230b\";s:4:\"lang\";s:3:\"\u2329\";s:4:\"rang\";s:3:\"\u232a\";s:3:\"loz\";s:3:\"\u25ca\";s:6:\"spades\";s:3:\"\u2660\";s:5:\"clubs\";s:3:\"\u2663\";s:6:\"hearts\";s:3:\"\u2665\";s:5:\"diams\";s:3:\"\u2666\";s:4:\"quot\";s:1:\"\"\";s:3:\"amp\";s:1:\"&\";s:2:\"lt\";s:1:\"<\";s:2:\"gt\";s:1:\">\";s:4:\"apos\";s:1:\"'\";s:5:\"OElig\";s:2:\"\u0152\";s:5:\"oelig\";s:2:\"\u0153\";s:6:\"Scaron\";s:2:\"\u0160\";s:6:\"scaron\";s:2:\"\u0161\";s:4:\"Yuml\";s:2:\"\u0178\";s:4:\"circ\";s:2:\"\u02c6\";s:5:\"tilde\";s:2:\"\u02dc\";s:4:\"ensp\";s:3:\"\u2002\";s:4:\"emsp\";s:3:\"\u2003\";s:6:\"thinsp\";s:3:\"\u2009\";s:4:\"zwnj\";s:3:\"\u200c\";s:3:\"zwj\";s:3:\"\u200d\";s:3:\"lrm\";s:3:\"\u200e\";s:3:\"rlm\";s:3:\"\u200f\";s:5:\"ndash\";s:3:\"\u2013\";s:5:\"mdash\";s:3:\"\u2014\";s:5:\"lsquo\";s:3:\"\u2018\";s:5:\"rsquo\";s:3:\"\u2019\";s:5:\"sbquo\";s:3:\"\u201a\";s:5:\"ldquo\";s:3:\"\u201c\";s:5:\"rdquo\";s:3:\"\u201d\";s:5:\"bdquo\";s:3:\"\u201e\";s:6:\"dagger\";s:3:\"\u2020\";s:6:\"Dagger\";s:3:\"\u2021\";s:6:\"permil\";s:3:\"\u2030\";s:6:\"lsaquo\";s:3:\"\u2039\";s:6:\"rsaquo\";s:3:\"\u203a\";s:4:\"euro\";s:3:\"\u20ac\";s:4:\"nbsp\";s:2:\"\u00a0\";s:5:\"iexcl\";s:2:\"\u00a1\";s:4:\"cent\";s:2:\"\u00a2\";s:5:\"pound\";s:2:\"\u00a3\";s:6:\"curren\";s:2:\"\u00a4\";s:3:\"yen\";s:2:\"\u00a5\";s:6:\"brvbar\";s:2:\"\u00a6\";s:4:\"sect\";s:2:\"\u00a7\";s:3:\"uml\";s:2:\"\u00a8\";s:4:\"copy\";s:2:\"\u00a9\";s:4:\"ordf\";s:2:\"\u00aa\";s:5:\"laquo\";s:2:\"\u00ab\";s:3:\"not\";s:2:\"\u00ac\";s:3:\"shy\";s:2:\"\u00ad\";s:3:\"reg\";s:2:\"\u00ae\";s:4:\"macr\";s:2:\"\u00af\";s:3:\"deg\";s:2:\"\u00b0\";s:6:\"plusmn\";s:2:\"\u00b1\";s:4:\"sup2\";s:2:\"\u00b2\";s:4:\"sup3\";s:2:\"\u00b3\";s:5:\"acute\";s:2:\"\u00b4\";s:5:\"micro\";s:2:\"\u00b5\";s:4:\"para\";s:2:\"\u00b6\";s:6:\"middot\";s:2:\"\u00b7\";s:5:\"cedil\";s:2:\"\u00b8\";s:4:\"sup1\";s:2:\"\u00b9\";s:4:\"ordm\";s:2:\"\u00ba\";s:5:\"raquo\";s:2:\"\u00bb\";s:6:\"frac14\";s:2:\"\u00bc\";s:6:\"frac12\";s:2:\"\u00bd\";s:6:\"frac34\";s:2:\"\u00be\";s:6:\"iquest\";s:2:\"\u00bf\";s:6:\"Agrave\";s:2:\"\u00c0\";s:6:\"Aacute\";s:2:\"\u00c1\";s:5:\"Acirc\";s:2:\"\u00c2\";s:6:\"Atilde\";s:2:\"\u00c3\";s:4:\"Auml\";s:2:\"\u00c4\";s:5:\"Aring\";s:2:\"\u00c5\";s:5:\"AElig\";s:2:\"\u00c6\";s:6:\"Ccedil\";s:2:\"\u00c7\";s:6:\"Egrave\";s:2:\"\u00c8\";s:6:\"Eacute\";s:2:\"\u00c9\";s:5:\"Ecirc\";s:2:\"\u00ca\";s:4:\"Euml\";s:2:\"\u00cb\";s:6:\"Igrave\";s:2:\"\u00cc\";s:6:\"Iacute\";s:2:\"\u00cd\";s:5:\"Icirc\";s:2:\"\u00ce\";s:4:\"Iuml\";s:2:\"\u00cf\";s:3:\"ETH\";s:2:\"\u00d0\";s:6:\"Ntilde\";s:2:\"\u00d1\";s:6:\"Ograve\";s:2:\"\u00d2\";s:6:\"Oacute\";s:2:\"\u00d3\";s:5:\"Ocirc\";s:2:\"\u00d4\";s:6:\"Otilde\";s:2:\"\u00d5\";s:4:\"Ouml\";s:2:\"\u00d6\";s:5:\"times\";s:2:\"\u00d7\";s:6:\"Oslash\";s:2:\"\u00d8\";s:6:\"Ugrave\";s:2:\"\u00d9\";s:6:\"Uacute\";s:2:\"\u00da\";s:5:\"Ucirc\";s:2:\"\u00db\";s:4:\"Uuml\";s:2:\"\u00dc\";s:6:\"Yacute\";s:2:\"\u00dd\";s:5:\"THORN\";s:2:\"\u00de\";s:5:\"szlig\";s:2:\"\u00df\";s:6:\"agrave\";s:2:\"\u00e0\";s:6:\"aacute\";s:2:\"\u00e1\";s:5:\"acirc\";s:2:\"\u00e2\";s:6:\"atilde\";s:2:\"\u00e3\";s:4:\"auml\";s:2:\"\u00e4\";s:5:\"aring\";s:2:\"\u00e5\";s:5:\"aelig\";s:2:\"\u00e6\";s:6:\"ccedil\";s:2:\"\u00e7\";s:6:\"egrave\";s:2:\"\u00e8\";s:6:\"eacute\";s:2:\"\u00e9\";s:5:\"ecirc\";s:2:\"\u00ea\";s:4:\"euml\";s:2:\"\u00eb\";s:6:\"igrave\";s:2:\"\u00ec\";s:6:\"iacute\";s:2:\"\u00ed\";s:5:\"icirc\";s:2:\"\u00ee\";s:4:\"iuml\";s:2:\"\u00ef\";s:3:\"eth\";s:2:\"\u00f0\";s:6:\"ntilde\";s:2:\"\u00f1\";s:6:\"ograve\";s:2:\"\u00f2\";s:6:\"oacute\";s:2:\"\u00f3\";s:5:\"ocirc\";s:2:\"\u00f4\";s:6:\"otilde\";s:2:\"\u00f5\";s:4:\"ouml\";s:2:\"\u00f6\";s:6:\"divide\";s:2:\"\u00f7\";s:6:\"oslash\";s:2:\"\u00f8\";s:6:\"ugrave\";s:2:\"\u00f9\";s:6:\"uacute\";s:2:\"\u00fa\";s:5:\"ucirc\";s:2:\"\u00fb\";s:4:\"uuml\";s:2:\"\u00fc\";s:6:\"yacute\";s:2:\"\u00fd\";s:5:\"thorn\";s:2:\"\u00fe\";s:4:\"yuml\";s:2:\"\u00ff\";}\n\\ No newline at end of file"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/EntityParser.php",
          "status": "added",
          "additions": 153,
          "deletions": 0,
          "patch": "@@ -0,0 +1,153 @@\n+<?php\n+\n+// if want to implement error collecting here, we'll need to use some sort\n+// of global data (probably trigger_error) because it's impossible to pass\n+// $config or $context to the callback functions.\n+\n+/**\n+ * Handles referencing and derefencing character entities\n+ */\n+class HTMLPurifier_EntityParser\n+{\n+\n+    /**\n+     * Reference to entity lookup table.\n+     * @type HTMLPurifier_EntityLookup\n+     */\n+    protected $_entity_lookup;\n+\n+    /**\n+     * Callback regex string for parsing entities.\n+     * @type string\n+     */\n+    protected $_substituteEntitiesRegex =\n+        '/&(?:[#]x([a-fA-F0-9]+)|[#]0*(\\d+)|([A-Za-z_:][A-Za-z0-9.\\-_:]*));?/';\n+        //     1. hex             2. dec      3. string (XML style)\n+\n+    /**\n+     * Decimal to parsed string conversion table for special entities.\n+     * @type array\n+     */\n+    protected $_special_dec2str =\n+            array(\n+                    34 => '\"',\n+                    38 => '&',\n+                    39 => \"'\",\n+                    60 => '<',\n+                    62 => '>'\n+            );\n+\n+    /**\n+     * Stripped entity names to decimal conversion table for special entities.\n+     * @type array\n+     */\n+    protected $_special_ent2dec =\n+            array(\n+                    'quot' => 34,\n+                    'amp'  => 38,\n+                    'lt'   => 60,\n+                    'gt'   => 62\n+            );\n+\n+    /**\n+     * Substitutes non-special entities with their parsed equivalents. Since\n+     * running this whenever you have parsed character is t3h 5uck, we run\n+     * it before everything else.\n+     *\n+     * @param string $string String to have non-special entities parsed.\n+     * @return string Parsed string.\n+     */\n+    public function substituteNonSpecialEntities($string)\n+    {\n+        // it will try to detect missing semicolons, but don't rely on it\n+        return preg_replace_callback(\n+            $this->_substituteEntitiesRegex,\n+            array($this, 'nonSpecialEntityCallback'),\n+            $string\n+        );\n+    }\n+\n+    /**\n+     * Callback function for substituteNonSpecialEntities() that does the work.\n+     *\n+     * @param array $matches  PCRE matches array, with 0 the entire match, and\n+     *                  either index 1, 2 or 3 set with a hex value, dec value,\n+     *                  or string (respectively).\n+     * @return string Replacement string.\n+     */\n+\n+    protected function nonSpecialEntityCallback($matches)\n+    {\n+        // replaces all but big five\n+        $entity = $matches[0];\n+        $is_num = (@$matches[0][1] === '#');\n+        if ($is_num) {\n+            $is_hex = (@$entity[2] === 'x');\n+            $code = $is_hex ? hexdec($matches[1]) : (int) $matches[2];\n+            // abort for special characters\n+            if (isset($this->_special_dec2str[$code])) {\n+                return $entity;\n+            }\n+            return HTMLPurifier_Encoder::unichr($code);\n+        } else {\n+            if (isset($this->_special_ent2dec[$matches[3]])) {\n+                return $entity;\n+            }\n+            if (!$this->_entity_lookup) {\n+                $this->_entity_lookup = HTMLPurifier_EntityLookup::instance();\n+            }\n+            if (isset($this->_entity_lookup->table[$matches[3]])) {\n+                return $this->_entity_lookup->table[$matches[3]];\n+            } else {\n+                return $entity;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Substitutes only special entities with their parsed equivalents.\n+     *\n+     * @notice We try to avoid calling this function because otherwise, it\n+     * would have to be called a lot (for every parsed section).\n+     *\n+     * @param string $string String to have non-special entities parsed.\n+     * @return string Parsed string.\n+     */\n+    public function substituteSpecialEntities($string)\n+    {\n+        return preg_replace_callback(\n+            $this->_substituteEntitiesRegex,\n+            array($this, 'specialEntityCallback'),\n+            $string\n+        );\n+    }\n+\n+    /**\n+     * Callback function for substituteSpecialEntities() that does the work.\n+     *\n+     * This callback has same syntax as nonSpecialEntityCallback().\n+     *\n+     * @param array $matches  PCRE-style matches array, with 0 the entire match, and\n+     *                  either index 1, 2 or 3 set with a hex value, dec value,\n+     *                  or string (respectively).\n+     * @return string Replacement string.\n+     */\n+    protected function specialEntityCallback($matches)\n+    {\n+        $entity = $matches[0];\n+        $is_num = (@$matches[0][1] === '#');\n+        if ($is_num) {\n+            $is_hex = (@$entity[2] === 'x');\n+            $int = $is_hex ? hexdec($matches[1]) : (int) $matches[2];\n+            return isset($this->_special_dec2str[$int]) ?\n+                $this->_special_dec2str[$int] :\n+                $entity;\n+        } else {\n+            return isset($this->_special_ent2dec[$matches[3]]) ?\n+                $this->_special_ent2dec[$matches[3]] :\n+                $entity;\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ErrorCollector.php",
          "status": "added",
          "additions": 244,
          "deletions": 0,
          "patch": "@@ -0,0 +1,244 @@\n+<?php\n+\n+/**\n+ * Error collection class that enables HTML Purifier to report HTML\n+ * problems back to the user\n+ */\n+class HTMLPurifier_ErrorCollector\n+{\n+\n+    /**\n+     * Identifiers for the returned error array. These are purposely numeric\n+     * so list() can be used.\n+     */\n+    const LINENO   = 0;\n+    const SEVERITY = 1;\n+    const MESSAGE  = 2;\n+    const CHILDREN = 3;\n+\n+    /**\n+     * @type array\n+     */\n+    protected $errors;\n+\n+    /**\n+     * @type array\n+     */\n+    protected $_current;\n+\n+    /**\n+     * @type array\n+     */\n+    protected $_stacks = array(array());\n+\n+    /**\n+     * @type HTMLPurifier_Language\n+     */\n+    protected $locale;\n+\n+    /**\n+     * @type HTMLPurifier_Generator\n+     */\n+    protected $generator;\n+\n+    /**\n+     * @type HTMLPurifier_Context\n+     */\n+    protected $context;\n+\n+    /**\n+     * @type array\n+     */\n+    protected $lines = array();\n+\n+    /**\n+     * @param HTMLPurifier_Context $context\n+     */\n+    public function __construct($context)\n+    {\n+        $this->locale    =& $context->get('Locale');\n+        $this->context   = $context;\n+        $this->_current  =& $this->_stacks[0];\n+        $this->errors    =& $this->_stacks[0];\n+    }\n+\n+    /**\n+     * Sends an error message to the collector for later use\n+     * @param int $severity Error severity, PHP error style (don't use E_USER_)\n+     * @param string $msg Error message text\n+     */\n+    public function send($severity, $msg)\n+    {\n+        $args = array();\n+        if (func_num_args() > 2) {\n+            $args = func_get_args();\n+            array_shift($args);\n+            unset($args[0]);\n+        }\n+\n+        $token = $this->context->get('CurrentToken', true);\n+        $line  = $token ? $token->line : $this->context->get('CurrentLine', true);\n+        $col   = $token ? $token->col  : $this->context->get('CurrentCol', true);\n+        $attr  = $this->context->get('CurrentAttr', true);\n+\n+        // perform special substitutions, also add custom parameters\n+        $subst = array();\n+        if (!is_null($token)) {\n+            $args['CurrentToken'] = $token;\n+        }\n+        if (!is_null($attr)) {\n+            $subst['$CurrentAttr.Name'] = $attr;\n+            if (isset($token->attr[$attr])) {\n+                $subst['$CurrentAttr.Value'] = $token->attr[$attr];\n+            }\n+        }\n+\n+        if (empty($args)) {\n+            $msg = $this->locale->getMessage($msg);\n+        } else {\n+            $msg = $this->locale->formatMessage($msg, $args);\n+        }\n+\n+        if (!empty($subst)) {\n+            $msg = strtr($msg, $subst);\n+        }\n+\n+        // (numerically indexed)\n+        $error = array(\n+            self::LINENO   => $line,\n+            self::SEVERITY => $severity,\n+            self::MESSAGE  => $msg,\n+            self::CHILDREN => array()\n+        );\n+        $this->_current[] = $error;\n+\n+        // NEW CODE BELOW ...\n+        // Top-level errors are either:\n+        //  TOKEN type, if $value is set appropriately, or\n+        //  \"syntax\" type, if $value is null\n+        $new_struct = new HTMLPurifier_ErrorStruct();\n+        $new_struct->type = HTMLPurifier_ErrorStruct::TOKEN;\n+        if ($token) {\n+            $new_struct->value = clone $token;\n+        }\n+        if (is_int($line) && is_int($col)) {\n+            if (isset($this->lines[$line][$col])) {\n+                $struct = $this->lines[$line][$col];\n+            } else {\n+                $struct = $this->lines[$line][$col] = $new_struct;\n+            }\n+            // These ksorts may present a performance problem\n+            ksort($this->lines[$line], SORT_NUMERIC);\n+        } else {\n+            if (isset($this->lines[-1])) {\n+                $struct = $this->lines[-1];\n+            } else {\n+                $struct = $this->lines[-1] = $new_struct;\n+            }\n+        }\n+        ksort($this->lines, SORT_NUMERIC);\n+\n+        // Now, check if we need to operate on a lower structure\n+        if (!empty($attr)) {\n+            $struct = $struct->getChild(HTMLPurifier_ErrorStruct::ATTR, $attr);\n+            if (!$struct->value) {\n+                $struct->value = array($attr, 'PUT VALUE HERE');\n+            }\n+        }\n+        if (!empty($cssprop)) {\n+            $struct = $struct->getChild(HTMLPurifier_ErrorStruct::CSSPROP, $cssprop);\n+            if (!$struct->value) {\n+                // if we tokenize CSS this might be a little more difficult to do\n+                $struct->value = array($cssprop, 'PUT VALUE HERE');\n+            }\n+        }\n+\n+        // Ok, structs are all setup, now time to register the error\n+        $struct->addError($severity, $msg);\n+    }\n+\n+    /**\n+     * Retrieves raw error data for custom formatter to use\n+     */\n+    public function getRaw()\n+    {\n+        return $this->errors;\n+    }\n+\n+    /**\n+     * Default HTML formatting implementation for error messages\n+     * @param HTMLPurifier_Config $config Configuration, vital for HTML output nature\n+     * @param array $errors Errors array to display; used for recursion.\n+     * @return string\n+     */\n+    public function getHTMLFormatted($config, $errors = null)\n+    {\n+        $ret = array();\n+\n+        $this->generator = new HTMLPurifier_Generator($config, $this->context);\n+        if ($errors === null) {\n+            $errors = $this->errors;\n+        }\n+\n+        // 'At line' message needs to be removed\n+\n+        // generation code for new structure goes here. It needs to be recursive.\n+        foreach ($this->lines as $line => $col_array) {\n+            if ($line == -1) {\n+                continue;\n+            }\n+            foreach ($col_array as $col => $struct) {\n+                $this->_renderStruct($ret, $struct, $line, $col);\n+            }\n+        }\n+        if (isset($this->lines[-1])) {\n+            $this->_renderStruct($ret, $this->lines[-1]);\n+        }\n+\n+        if (empty($errors)) {\n+            return '<p>' . $this->locale->getMessage('ErrorCollector: No errors') . '</p>';\n+        } else {\n+            return '<ul><li>' . implode('</li><li>', $ret) . '</li></ul>';\n+        }\n+\n+    }\n+\n+    private function _renderStruct(&$ret, $struct, $line = null, $col = null)\n+    {\n+        $stack = array($struct);\n+        $context_stack = array(array());\n+        while ($current = array_pop($stack)) {\n+            $context = array_pop($context_stack);\n+            foreach ($current->errors as $error) {\n+                list($severity, $msg) = $error;\n+                $string = '';\n+                $string .= '<div>';\n+                // W3C uses an icon to indicate the severity of the error.\n+                $error = $this->locale->getErrorName($severity);\n+                $string .= \"<span class=\\\"error e$severity\\\"><strong>$error</strong></span> \";\n+                if (!is_null($line) && !is_null($col)) {\n+                    $string .= \"<em class=\\\"location\\\">Line $line, Column $col: </em> \";\n+                } else {\n+                    $string .= '<em class=\"location\">End of Document: </em> ';\n+                }\n+                $string .= '<strong class=\"description\">' . $this->generator->escape($msg) . '</strong> ';\n+                $string .= '</div>';\n+                // Here, have a marker for the character on the column appropriate.\n+                // Be sure to clip extremely long lines.\n+                //$string .= '<pre>';\n+                //$string .= '';\n+                //$string .= '</pre>';\n+                $ret[] = $string;\n+            }\n+            foreach ($current->children as $array) {\n+                $context[] = $current;\n+                $stack = array_merge($stack, array_reverse($array, true));\n+                for ($i = count($array); $i > 0; $i--) {\n+                    $context_stack[] = $context;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/ErrorStruct.php",
          "status": "added",
          "additions": 74,
          "deletions": 0,
          "patch": "@@ -0,0 +1,74 @@\n+<?php\n+\n+/**\n+ * Records errors for particular segments of an HTML document such as tokens,\n+ * attributes or CSS properties. They can contain error structs (which apply\n+ * to components of what they represent), but their main purpose is to hold\n+ * errors applying to whatever struct is being used.\n+ */\n+class HTMLPurifier_ErrorStruct\n+{\n+\n+    /**\n+     * Possible values for $children first-key. Note that top-level structures\n+     * are automatically token-level.\n+     */\n+    const TOKEN     = 0;\n+    const ATTR      = 1;\n+    const CSSPROP   = 2;\n+\n+    /**\n+     * Type of this struct.\n+     * @type string\n+     */\n+    public $type;\n+\n+    /**\n+     * Value of the struct we are recording errors for. There are various\n+     * values for this:\n+     *  - TOKEN: Instance of HTMLPurifier_Token\n+     *  - ATTR: array('attr-name', 'value')\n+     *  - CSSPROP: array('prop-name', 'value')\n+     * @type mixed\n+     */\n+    public $value;\n+\n+    /**\n+     * Errors registered for this structure.\n+     * @type array\n+     */\n+    public $errors = array();\n+\n+    /**\n+     * Child ErrorStructs that are from this structure. For example, a TOKEN\n+     * ErrorStruct would contain ATTR ErrorStructs. This is a multi-dimensional\n+     * array in structure: [TYPE]['identifier']\n+     * @type array\n+     */\n+    public $children = array();\n+\n+    /**\n+     * @param string $type\n+     * @param string $id\n+     * @return mixed\n+     */\n+    public function getChild($type, $id)\n+    {\n+        if (!isset($this->children[$type][$id])) {\n+            $this->children[$type][$id] = new HTMLPurifier_ErrorStruct();\n+            $this->children[$type][$id]->type = $type;\n+        }\n+        return $this->children[$type][$id];\n+    }\n+\n+    /**\n+     * @param int $severity\n+     * @param string $message\n+     */\n+    public function addError($severity, $message)\n+    {\n+        $this->errors[] = array($severity, $message);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Exception.php",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+<?php\n+\n+/**\n+ * Global exception class for HTML Purifier; any exceptions we throw\n+ * are from here.\n+ */\n+class HTMLPurifier_Exception extends Exception\n+{\n+\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Filter.php",
          "status": "added",
          "additions": 56,
          "deletions": 0,
          "patch": "@@ -0,0 +1,56 @@\n+<?php\n+\n+/**\n+ * Represents a pre or post processing filter on HTML Purifier's output\n+ *\n+ * Sometimes, a little ad-hoc fixing of HTML has to be done before\n+ * it gets sent through HTML Purifier: you can use filters to acheive\n+ * this effect. For instance, YouTube videos can be preserved using\n+ * this manner. You could have used a decorator for this task, but\n+ * PHP's support for them is not terribly robust, so we're going\n+ * to just loop through the filters.\n+ *\n+ * Filters should be exited first in, last out. If there are three filters,\n+ * named 1, 2 and 3, the order of execution should go 1->preFilter,\n+ * 2->preFilter, 3->preFilter, purify, 3->postFilter, 2->postFilter,\n+ * 1->postFilter.\n+ *\n+ * @note Methods are not declared abstract as it is perfectly legitimate\n+ *       for an implementation not to want anything to happen on a step\n+ */\n+\n+class HTMLPurifier_Filter\n+{\n+\n+    /**\n+     * Name of the filter for identification purposes.\n+     * @type string\n+     */\n+    public $name;\n+\n+    /**\n+     * Pre-processor function, handles HTML before HTML Purifier\n+     * @param string $html\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return string\n+     */\n+    public function preFilter($html, $config, $context)\n+    {\n+        return $html;\n+    }\n+\n+    /**\n+     * Post-processor function, handles HTML after HTML Purifier\n+     * @param string $html\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return string\n+     */\n+    public function postFilter($html, $config, $context)\n+    {\n+        return $html;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Filter/ExtractStyleBlocks.php",
          "status": "added",
          "additions": 338,
          "deletions": 0,
          "patch": "@@ -0,0 +1,338 @@\n+<?php\n+\n+// why is this a top level function? Because PHP 5.2.0 doesn't seem to\n+// understand how to interpret this filter if it's a static method.\n+// It's all really silly, but if we go this route it might be reasonable\n+// to coalesce all of these methods into one.\n+function htmlpurifier_filter_extractstyleblocks_muteerrorhandler()\n+{\n+}\n+\n+/**\n+ * This filter extracts <style> blocks from input HTML, cleans them up\n+ * using CSSTidy, and then places them in $purifier->context->get('StyleBlocks')\n+ * so they can be used elsewhere in the document.\n+ *\n+ * @note\n+ *      See tests/HTMLPurifier/Filter/ExtractStyleBlocksTest.php for\n+ *      sample usage.\n+ *\n+ * @note\n+ *      This filter can also be used on stylesheets not included in the\n+ *      document--something purists would probably prefer. Just directly\n+ *      call HTMLPurifier_Filter_ExtractStyleBlocks->cleanCSS()\n+ */\n+class HTMLPurifier_Filter_ExtractStyleBlocks extends HTMLPurifier_Filter\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'ExtractStyleBlocks';\n+\n+    /**\n+     * @type array\n+     */\n+    private $_styleMatches = array();\n+\n+    /**\n+     * @type csstidy\n+     */\n+    private $_tidy;\n+\n+    /**\n+     * @type HTMLPurifier_AttrDef_HTML_ID\n+     */\n+    private $_id_attrdef;\n+\n+    /**\n+     * @type HTMLPurifier_AttrDef_CSS_Ident\n+     */\n+    private $_class_attrdef;\n+\n+    /**\n+     * @type HTMLPurifier_AttrDef_Enum\n+     */\n+    private $_enum_attrdef;\n+\n+    public function __construct()\n+    {\n+        $this->_tidy = new csstidy();\n+        $this->_tidy->set_cfg('lowercase_s', false);\n+        $this->_id_attrdef = new HTMLPurifier_AttrDef_HTML_ID(true);\n+        $this->_class_attrdef = new HTMLPurifier_AttrDef_CSS_Ident();\n+        $this->_enum_attrdef = new HTMLPurifier_AttrDef_Enum(\n+            array(\n+                'first-child',\n+                'link',\n+                'visited',\n+                'active',\n+                'hover',\n+                'focus'\n+            )\n+        );\n+    }\n+\n+    /**\n+     * Save the contents of CSS blocks to style matches\n+     * @param array $matches preg_replace style $matches array\n+     */\n+    protected function styleCallback($matches)\n+    {\n+        $this->_styleMatches[] = $matches[1];\n+    }\n+\n+    /**\n+     * Removes inline <style> tags from HTML, saves them for later use\n+     * @param string $html\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return string\n+     * @todo Extend to indicate non-text/css style blocks\n+     */\n+    public function preFilter($html, $config, $context)\n+    {\n+        $tidy = $config->get('Filter.ExtractStyleBlocks.TidyImpl');\n+        if ($tidy !== null) {\n+            $this->_tidy = $tidy;\n+        }\n+        $html = preg_replace_callback('#<style(?:\\s.*)?>(.+)</style>#isU', array($this, 'styleCallback'), $html);\n+        $style_blocks = $this->_styleMatches;\n+        $this->_styleMatches = array(); // reset\n+        $context->register('StyleBlocks', $style_blocks); // $context must not be reused\n+        if ($this->_tidy) {\n+            foreach ($style_blocks as &$style) {\n+                $style = $this->cleanCSS($style, $config, $context);\n+            }\n+        }\n+        return $html;\n+    }\n+\n+    /**\n+     * Takes CSS (the stuff found in <style>) and cleans it.\n+     * @warning Requires CSSTidy <http://csstidy.sourceforge.net/>\n+     * @param string $css CSS styling to clean\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @throws HTMLPurifier_Exception\n+     * @return string Cleaned CSS\n+     */\n+    public function cleanCSS($css, $config, $context)\n+    {\n+        // prepare scope\n+        $scope = $config->get('Filter.ExtractStyleBlocks.Scope');\n+        if ($scope !== null) {\n+            $scopes = array_map('trim', explode(',', $scope));\n+        } else {\n+            $scopes = array();\n+        }\n+        // remove comments from CSS\n+        $css = trim($css);\n+        if (strncmp('<!--', $css, 4) === 0) {\n+            $css = substr($css, 4);\n+        }\n+        if (strlen($css) > 3 && substr($css, -3) == '-->') {\n+            $css = substr($css, 0, -3);\n+        }\n+        $css = trim($css);\n+        set_error_handler('htmlpurifier_filter_extractstyleblocks_muteerrorhandler');\n+        $this->_tidy->parse($css);\n+        restore_error_handler();\n+        $css_definition = $config->getDefinition('CSS');\n+        $html_definition = $config->getDefinition('HTML');\n+        $new_css = array();\n+        foreach ($this->_tidy->css as $k => $decls) {\n+            // $decls are all CSS declarations inside an @ selector\n+            $new_decls = array();\n+            foreach ($decls as $selector => $style) {\n+                $selector = trim($selector);\n+                if ($selector === '') {\n+                    continue;\n+                } // should not happen\n+                // Parse the selector\n+                // Here is the relevant part of the CSS grammar:\n+                //\n+                // ruleset\n+                //   : selector [ ',' S* selector ]* '{' ...\n+                // selector\n+                //   : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?\n+                // combinator\n+                //   : '+' S*\n+                //   : '>' S*\n+                // simple_selector\n+                //   : element_name [ HASH | class | attrib | pseudo ]*\n+                //   | [ HASH | class | attrib | pseudo ]+\n+                // element_name\n+                //   : IDENT | '*'\n+                //   ;\n+                // class\n+                //   : '.' IDENT\n+                //   ;\n+                // attrib\n+                //   : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*\n+                //     [ IDENT | STRING ] S* ]? ']'\n+                //   ;\n+                // pseudo\n+                //   : ':' [ IDENT | FUNCTION S* [IDENT S*]? ')' ]\n+                //   ;\n+                //\n+                // For reference, here are the relevant tokens:\n+                //\n+                // HASH         #{name}\n+                // IDENT        {ident}\n+                // INCLUDES     ==\n+                // DASHMATCH    |=\n+                // STRING       {string}\n+                // FUNCTION     {ident}\\(\n+                //\n+                // And the lexical scanner tokens\n+                //\n+                // name         {nmchar}+\n+                // nmchar       [_a-z0-9-]|{nonascii}|{escape}\n+                // nonascii     [\\240-\\377]\n+                // escape       {unicode}|\\\\[^\\r\\n\\f0-9a-f]\n+                // unicode      \\\\{h}}{1,6}(\\r\\n|[ \\t\\r\\n\\f])?\n+                // ident        -?{nmstart}{nmchar*}\n+                // nmstart      [_a-z]|{nonascii}|{escape}\n+                // string       {string1}|{string2}\n+                // string1      \\\"([^\\n\\r\\f\\\\\"]|\\\\{nl}|{escape})*\\\"\n+                // string2      \\'([^\\n\\r\\f\\\\\"]|\\\\{nl}|{escape})*\\'\n+                //\n+                // We'll implement a subset (in order to reduce attack\n+                // surface); in particular:\n+                //\n+                //      - No Unicode support\n+                //      - No escapes support\n+                //      - No string support (by proxy no attrib support)\n+                //      - element_name is matched against allowed\n+                //        elements (some people might find this\n+                //        annoying...)\n+                //      - Pseudo-elements one of :first-child, :link,\n+                //        :visited, :active, :hover, :focus\n+\n+                // handle ruleset\n+                $selectors = array_map('trim', explode(',', $selector));\n+                $new_selectors = array();\n+                foreach ($selectors as $sel) {\n+                    // split on +, > and spaces\n+                    $basic_selectors = preg_split('/\\s*([+> ])\\s*/', $sel, -1, PREG_SPLIT_DELIM_CAPTURE);\n+                    // even indices are chunks, odd indices are\n+                    // delimiters\n+                    $nsel = null;\n+                    $delim = null; // guaranteed to be non-null after\n+                    // two loop iterations\n+                    for ($i = 0, $c = count($basic_selectors); $i < $c; $i++) {\n+                        $x = $basic_selectors[$i];\n+                        if ($i % 2) {\n+                            // delimiter\n+                            if ($x === ' ') {\n+                                $delim = ' ';\n+                            } else {\n+                                $delim = ' ' . $x . ' ';\n+                            }\n+                        } else {\n+                            // simple selector\n+                            $components = preg_split('/([#.:])/', $x, -1, PREG_SPLIT_DELIM_CAPTURE);\n+                            $sdelim = null;\n+                            $nx = null;\n+                            for ($j = 0, $cc = count($components); $j < $cc; $j++) {\n+                                $y = $components[$j];\n+                                if ($j === 0) {\n+                                    if ($y === '*' || isset($html_definition->info[$y = strtolower($y)])) {\n+                                        $nx = $y;\n+                                    } else {\n+                                        // $nx stays null; this matters\n+                                        // if we don't manage to find\n+                                        // any valid selector content,\n+                                        // in which case we ignore the\n+                                        // outer $delim\n+                                    }\n+                                } elseif ($j % 2) {\n+                                    // set delimiter\n+                                    $sdelim = $y;\n+                                } else {\n+                                    $attrdef = null;\n+                                    if ($sdelim === '#') {\n+                                        $attrdef = $this->_id_attrdef;\n+                                    } elseif ($sdelim === '.') {\n+                                        $attrdef = $this->_class_attrdef;\n+                                    } elseif ($sdelim === ':') {\n+                                        $attrdef = $this->_enum_attrdef;\n+                                    } else {\n+                                        throw new HTMLPurifier_Exception('broken invariant sdelim and preg_split');\n+                                    }\n+                                    $r = $attrdef->validate($y, $config, $context);\n+                                    if ($r !== false) {\n+                                        if ($r !== true) {\n+                                            $y = $r;\n+                                        }\n+                                        if ($nx === null) {\n+                                            $nx = '';\n+                                        }\n+                                        $nx .= $sdelim . $y;\n+                                    }\n+                                }\n+                            }\n+                            if ($nx !== null) {\n+                                if ($nsel === null) {\n+                                    $nsel = $nx;\n+                                } else {\n+                                    $nsel .= $delim . $nx;\n+                                }\n+                            } else {\n+                                // delimiters to the left of invalid\n+                                // basic selector ignored\n+                            }\n+                        }\n+                    }\n+                    if ($nsel !== null) {\n+                        if (!empty($scopes)) {\n+                            foreach ($scopes as $s) {\n+                                $new_selectors[] = \"$s $nsel\";\n+                            }\n+                        } else {\n+                            $new_selectors[] = $nsel;\n+                        }\n+                    }\n+                }\n+                if (empty($new_selectors)) {\n+                    continue;\n+                }\n+                $selector = implode(', ', $new_selectors);\n+                foreach ($style as $name => $value) {\n+                    if (!isset($css_definition->info[$name])) {\n+                        unset($style[$name]);\n+                        continue;\n+                    }\n+                    $def = $css_definition->info[$name];\n+                    $ret = $def->validate($value, $config, $context);\n+                    if ($ret === false) {\n+                        unset($style[$name]);\n+                    } else {\n+                        $style[$name] = $ret;\n+                    }\n+                }\n+                $new_decls[$selector] = $style;\n+            }\n+            $new_css[$k] = $new_decls;\n+        }\n+        // remove stuff that shouldn't be used, could be reenabled\n+        // after security risks are analyzed\n+        $this->_tidy->css = $new_css;\n+        $this->_tidy->import = array();\n+        $this->_tidy->charset = null;\n+        $this->_tidy->namespace = null;\n+        $css = $this->_tidy->print->plain();\n+        // we are going to escape any special characters <>& to ensure\n+        // that no funny business occurs (i.e. </style> in a font-family prop).\n+        if ($config->get('Filter.ExtractStyleBlocks.Escaping')) {\n+            $css = str_replace(\n+                array('<', '>', '&'),\n+                array('\\3C ', '\\3E ', '\\26 '),\n+                $css\n+            );\n+        }\n+        return $css;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Filter/YouTube.php",
          "status": "added",
          "additions": 65,
          "deletions": 0,
          "patch": "@@ -0,0 +1,65 @@\n+<?php\n+\n+class HTMLPurifier_Filter_YouTube extends HTMLPurifier_Filter\n+{\n+\n+    /**\n+     * @type string\n+     */\n+    public $name = 'YouTube';\n+\n+    /**\n+     * @param string $html\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return string\n+     */\n+    public function preFilter($html, $config, $context)\n+    {\n+        $pre_regex = '#<object[^>]+>.+?' .\n+            '(?:http:)?//www.youtube.com/((?:v|cp)/[A-Za-z0-9\\-_=]+).+?</object>#s';\n+        $pre_replace = '<span class=\"youtube-embed\">\\1</span>';\n+        return preg_replace($pre_regex, $pre_replace, $html);\n+    }\n+\n+    /**\n+     * @param string $html\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return string\n+     */\n+    public function postFilter($html, $config, $context)\n+    {\n+        $post_regex = '#<span class=\"youtube-embed\">((?:v|cp)/[A-Za-z0-9\\-_=]+)</span>#';\n+        return preg_replace_callback($post_regex, array($this, 'postFilterCallback'), $html);\n+    }\n+\n+    /**\n+     * @param $url\n+     * @return string\n+     */\n+    protected function armorUrl($url)\n+    {\n+        return str_replace('--', '-&#45;', $url);\n+    }\n+\n+    /**\n+     * @param array $matches\n+     * @return string\n+     */\n+    protected function postFilterCallback($matches)\n+    {\n+        $url = $this->armorUrl($matches[1]);\n+        return '<object width=\"425\" height=\"350\" type=\"application/x-shockwave-flash\" ' .\n+        'data=\"//www.youtube.com/' . $url . '\">' .\n+        '<param name=\"movie\" value=\"//www.youtube.com/' . $url . '\"></param>' .\n+        '<!--[if IE]>' .\n+        '<embed src=\"//www.youtube.com/' . $url . '\"' .\n+        'type=\"application/x-shockwave-flash\"' .\n+        'wmode=\"transparent\" width=\"425\" height=\"350\" />' .\n+        '<![endif]-->' .\n+        '</object>';\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Generator.php",
          "status": "added",
          "additions": 286,
          "deletions": 0,
          "patch": "@@ -0,0 +1,286 @@\n+<?php\n+\n+/**\n+ * Generates HTML from tokens.\n+ * @todo Refactor interface so that configuration/context is determined\n+ *       upon instantiation, no need for messy generateFromTokens() calls\n+ * @todo Make some of the more internal functions protected, and have\n+ *       unit tests work around that\n+ */\n+class HTMLPurifier_Generator\n+{\n+\n+    /**\n+     * Whether or not generator should produce XML output.\n+     * @type bool\n+     */\n+    private $_xhtml = true;\n+\n+    /**\n+     * :HACK: Whether or not generator should comment the insides of <script> tags.\n+     * @type bool\n+     */\n+    private $_scriptFix = false;\n+\n+    /**\n+     * Cache of HTMLDefinition during HTML output to determine whether or\n+     * not attributes should be minimized.\n+     * @type HTMLPurifier_HTMLDefinition\n+     */\n+    private $_def;\n+\n+    /**\n+     * Cache of %Output.SortAttr.\n+     * @type bool\n+     */\n+    private $_sortAttr;\n+\n+    /**\n+     * Cache of %Output.FlashCompat.\n+     * @type bool\n+     */\n+    private $_flashCompat;\n+\n+    /**\n+     * Cache of %Output.FixInnerHTML.\n+     * @type bool\n+     */\n+    private $_innerHTMLFix;\n+\n+    /**\n+     * Stack for keeping track of object information when outputting IE\n+     * compatibility code.\n+     * @type array\n+     */\n+    private $_flashStack = array();\n+\n+    /**\n+     * Configuration for the generator\n+     * @type HTMLPurifier_Config\n+     */\n+    protected $config;\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     */\n+    public function __construct($config, $context)\n+    {\n+        $this->config = $config;\n+        $this->_scriptFix = $config->get('Output.CommentScriptContents');\n+        $this->_innerHTMLFix = $config->get('Output.FixInnerHTML');\n+        $this->_sortAttr = $config->get('Output.SortAttr');\n+        $this->_flashCompat = $config->get('Output.FlashCompat');\n+        $this->_def = $config->getHTMLDefinition();\n+        $this->_xhtml = $this->_def->doctype->xml;\n+    }\n+\n+    /**\n+     * Generates HTML from an array of tokens.\n+     * @param HTMLPurifier_Token[] $tokens Array of HTMLPurifier_Token\n+     * @return string Generated HTML\n+     */\n+    public function generateFromTokens($tokens)\n+    {\n+        if (!$tokens) {\n+            return '';\n+        }\n+\n+        // Basic algorithm\n+        $html = '';\n+        for ($i = 0, $size = count($tokens); $i < $size; $i++) {\n+            if ($this->_scriptFix && $tokens[$i]->name === 'script'\n+                && $i + 2 < $size && $tokens[$i+2] instanceof HTMLPurifier_Token_End) {\n+                // script special case\n+                // the contents of the script block must be ONE token\n+                // for this to work.\n+                $html .= $this->generateFromToken($tokens[$i++]);\n+                $html .= $this->generateScriptFromToken($tokens[$i++]);\n+            }\n+            $html .= $this->generateFromToken($tokens[$i]);\n+        }\n+\n+        // Tidy cleanup\n+        if (extension_loaded('tidy') && $this->config->get('Output.TidyFormat')) {\n+            $tidy = new Tidy;\n+            $tidy->parseString(\n+                $html,\n+                array(\n+                   'indent'=> true,\n+                   'output-xhtml' => $this->_xhtml,\n+                   'show-body-only' => true,\n+                   'indent-spaces' => 2,\n+                   'wrap' => 68,\n+                ),\n+                'utf8'\n+            );\n+            $tidy->cleanRepair();\n+            $html = (string) $tidy; // explicit cast necessary\n+        }\n+\n+        // Normalize newlines to system defined value\n+        if ($this->config->get('Core.NormalizeNewlines')) {\n+            $nl = $this->config->get('Output.Newline');\n+            if ($nl === null) {\n+                $nl = PHP_EOL;\n+            }\n+            if ($nl !== \"\\n\") {\n+                $html = str_replace(\"\\n\", $nl, $html);\n+            }\n+        }\n+        return $html;\n+    }\n+\n+    /**\n+     * Generates HTML from a single token.\n+     * @param HTMLPurifier_Token $token HTMLPurifier_Token object.\n+     * @return string Generated HTML\n+     */\n+    public function generateFromToken($token)\n+    {\n+        if (!$token instanceof HTMLPurifier_Token) {\n+            trigger_error('Cannot generate HTML from non-HTMLPurifier_Token object', E_USER_WARNING);\n+            return '';\n+\n+        } elseif ($token instanceof HTMLPurifier_Token_Start) {\n+            $attr = $this->generateAttributes($token->attr, $token->name);\n+            if ($this->_flashCompat) {\n+                if ($token->name == \"object\") {\n+                    $flash = new stdclass();\n+                    $flash->attr = $token->attr;\n+                    $flash->param = array();\n+                    $this->_flashStack[] = $flash;\n+                }\n+            }\n+            return '<' . $token->name . ($attr ? ' ' : '') . $attr . '>';\n+\n+        } elseif ($token instanceof HTMLPurifier_Token_End) {\n+            $_extra = '';\n+            if ($this->_flashCompat) {\n+                if ($token->name == \"object\" && !empty($this->_flashStack)) {\n+                    // doesn't do anything for now\n+                }\n+            }\n+            return $_extra . '</' . $token->name . '>';\n+\n+        } elseif ($token instanceof HTMLPurifier_Token_Empty) {\n+            if ($this->_flashCompat && $token->name == \"param\" && !empty($this->_flashStack)) {\n+                $this->_flashStack[count($this->_flashStack)-1]->param[$token->attr['name']] = $token->attr['value'];\n+            }\n+            $attr = $this->generateAttributes($token->attr, $token->name);\n+             return '<' . $token->name . ($attr ? ' ' : '') . $attr .\n+                ( $this->_xhtml ? ' /': '' ) // <br /> v. <br>\n+                . '>';\n+\n+        } elseif ($token instanceof HTMLPurifier_Token_Text) {\n+            return $this->escape($token->data, ENT_NOQUOTES);\n+\n+        } elseif ($token instanceof HTMLPurifier_Token_Comment) {\n+            return '<!--' . $token->data . '-->';\n+        } else {\n+            return '';\n+\n+        }\n+    }\n+\n+    /**\n+     * Special case processor for the contents of script tags\n+     * @param HTMLPurifier_Token $token HTMLPurifier_Token object.\n+     * @return string\n+     * @warning This runs into problems if there's already a literal\n+     *          --> somewhere inside the script contents.\n+     */\n+    public function generateScriptFromToken($token)\n+    {\n+        if (!$token instanceof HTMLPurifier_Token_Text) {\n+            return $this->generateFromToken($token);\n+        }\n+        // Thanks <http://lachy.id.au/log/2005/05/script-comments>\n+        $data = preg_replace('#//\\s*$#', '', $token->data);\n+        return '<!--//--><![CDATA[//><!--' . \"\\n\" . trim($data) . \"\\n\" . '//--><!]]>';\n+    }\n+\n+    /**\n+     * Generates attribute declarations from attribute array.\n+     * @note This does not include the leading or trailing space.\n+     * @param array $assoc_array_of_attributes Attribute array\n+     * @param string $element Name of element attributes are for, used to check\n+     *        attribute minimization.\n+     * @return string Generated HTML fragment for insertion.\n+     */\n+    public function generateAttributes($assoc_array_of_attributes, $element = '')\n+    {\n+        $html = '';\n+        if ($this->_sortAttr) {\n+            ksort($assoc_array_of_attributes);\n+        }\n+        foreach ($assoc_array_of_attributes as $key => $value) {\n+            if (!$this->_xhtml) {\n+                // Remove namespaced attributes\n+                if (strpos($key, ':') !== false) {\n+                    continue;\n+                }\n+                // Check if we should minimize the attribute: val=\"val\" -> val\n+                if ($element && !empty($this->_def->info[$element]->attr[$key]->minimized)) {\n+                    $html .= $key . ' ';\n+                    continue;\n+                }\n+            }\n+            // Workaround for Internet Explorer innerHTML bug.\n+            // Essentially, Internet Explorer, when calculating\n+            // innerHTML, omits quotes if there are no instances of\n+            // angled brackets, quotes or spaces.  However, when parsing\n+            // HTML (for example, when you assign to innerHTML), it\n+            // treats backticks as quotes.  Thus,\n+            //      <img alt=\"``\" />\n+            // becomes\n+            //      <img alt=`` />\n+            // becomes\n+            //      <img alt='' />\n+            // Fortunately, all we need to do is trigger an appropriate\n+            // quoting style, which we do by adding an extra space.\n+            // This also is consistent with the W3C spec, which states\n+            // that user agents may ignore leading or trailing\n+            // whitespace (in fact, most don't, at least for attributes\n+            // like alt, but an extra space at the end is barely\n+            // noticeable).  Still, we have a configuration knob for\n+            // this, since this transformation is not necesary if you\n+            // don't process user input with innerHTML or you don't plan\n+            // on supporting Internet Explorer.\n+            if ($this->_innerHTMLFix) {\n+                if (strpos($value, '`') !== false) {\n+                    // check if correct quoting style would not already be\n+                    // triggered\n+                    if (strcspn($value, '\"\\' <>') === strlen($value)) {\n+                        // protect!\n+                        $value .= ' ';\n+                    }\n+                }\n+            }\n+            $html .= $key.'=\"'.$this->escape($value).'\" ';\n+        }\n+        return rtrim($html);\n+    }\n+\n+    /**\n+     * Escapes raw text data.\n+     * @todo This really ought to be protected, but until we have a facility\n+     *       for properly generating HTML here w/o using tokens, it stays\n+     *       public.\n+     * @param string $string String data to escape for HTML.\n+     * @param int $quote Quoting style, like htmlspecialchars. ENT_NOQUOTES is\n+     *               permissible for non-attribute output.\n+     * @return string escaped data.\n+     */\n+    public function escape($string, $quote = null)\n+    {\n+        // Workaround for APC bug on Mac Leopard reported by sidepodcast\n+        // http://htmlpurifier.org/phorum/read.php?3,4823,4846\n+        if ($quote === null) {\n+            $quote = ENT_COMPAT;\n+        }\n+        return htmlspecialchars($string, $quote, 'UTF-8');\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLDefinition.php",
          "status": "added",
          "additions": 493,
          "deletions": 0,
          "patch": "@@ -0,0 +1,493 @@\n+<?php\n+\n+/**\n+ * Definition of the purified HTML that describes allowed children,\n+ * attributes, and many other things.\n+ *\n+ * Conventions:\n+ *\n+ * All member variables that are prefixed with info\n+ * (including the main $info array) are used by HTML Purifier internals\n+ * and should not be directly edited when customizing the HTMLDefinition.\n+ * They can usually be set via configuration directives or custom\n+ * modules.\n+ *\n+ * On the other hand, member variables without the info prefix are used\n+ * internally by the HTMLDefinition and MUST NOT be used by other HTML\n+ * Purifier internals. Many of them, however, are public, and may be\n+ * edited by userspace code to tweak the behavior of HTMLDefinition.\n+ *\n+ * @note This class is inspected by Printer_HTMLDefinition; please\n+ *       update that class if things here change.\n+ *\n+ * @warning Directives that change this object's structure must be in\n+ *          the HTML or Attr namespace!\n+ */\n+class HTMLPurifier_HTMLDefinition extends HTMLPurifier_Definition\n+{\n+\n+    // FULLY-PUBLIC VARIABLES ---------------------------------------------\n+\n+    /**\n+     * Associative array of element names to HTMLPurifier_ElementDef.\n+     * @type HTMLPurifier_ElementDef[]\n+     */\n+    public $info = array();\n+\n+    /**\n+     * Associative array of global attribute name to attribute definition.\n+     * @type array\n+     */\n+    public $info_global_attr = array();\n+\n+    /**\n+     * String name of parent element HTML will be going into.\n+     * @type string\n+     */\n+    public $info_parent = 'div';\n+\n+    /**\n+     * Definition for parent element, allows parent element to be a\n+     * tag that's not allowed inside the HTML fragment.\n+     * @type HTMLPurifier_ElementDef\n+     */\n+    public $info_parent_def;\n+\n+    /**\n+     * String name of element used to wrap inline elements in block context.\n+     * @type string\n+     * @note This is rarely used except for BLOCKQUOTEs in strict mode\n+     */\n+    public $info_block_wrapper = 'p';\n+\n+    /**\n+     * Associative array of deprecated tag name to HTMLPurifier_TagTransform.\n+     * @type array\n+     */\n+    public $info_tag_transform = array();\n+\n+    /**\n+     * Indexed list of HTMLPurifier_AttrTransform to be performed before validation.\n+     * @type HTMLPurifier_AttrTransform[]\n+     */\n+    public $info_attr_transform_pre = array();\n+\n+    /**\n+     * Indexed list of HTMLPurifier_AttrTransform to be performed after validation.\n+     * @type HTMLPurifier_AttrTransform[]\n+     */\n+    public $info_attr_transform_post = array();\n+\n+    /**\n+     * Nested lookup array of content set name (Block, Inline) to\n+     * element name to whether or not it belongs in that content set.\n+     * @type array\n+     */\n+    public $info_content_sets = array();\n+\n+    /**\n+     * Indexed list of HTMLPurifier_Injector to be used.\n+     * @type HTMLPurifier_Injector[]\n+     */\n+    public $info_injector = array();\n+\n+    /**\n+     * Doctype object\n+     * @type HTMLPurifier_Doctype\n+     */\n+    public $doctype;\n+\n+\n+\n+    // RAW CUSTOMIZATION STUFF --------------------------------------------\n+\n+    /**\n+     * Adds a custom attribute to a pre-existing element\n+     * @note This is strictly convenience, and does not have a corresponding\n+     *       method in HTMLPurifier_HTMLModule\n+     * @param string $element_name Element name to add attribute to\n+     * @param string $attr_name Name of attribute\n+     * @param mixed $def Attribute definition, can be string or object, see\n+     *             HTMLPurifier_AttrTypes for details\n+     */\n+    public function addAttribute($element_name, $attr_name, $def)\n+    {\n+        $module = $this->getAnonymousModule();\n+        if (!isset($module->info[$element_name])) {\n+            $element = $module->addBlankElement($element_name);\n+        } else {\n+            $element = $module->info[$element_name];\n+        }\n+        $element->attr[$attr_name] = $def;\n+    }\n+\n+    /**\n+     * Adds a custom element to your HTML definition\n+     * @see HTMLPurifier_HTMLModule::addElement() for detailed\n+     *       parameter and return value descriptions.\n+     */\n+    public function addElement($element_name, $type, $contents, $attr_collections, $attributes = array())\n+    {\n+        $module = $this->getAnonymousModule();\n+        // assume that if the user is calling this, the element\n+        // is safe. This may not be a good idea\n+        $element = $module->addElement($element_name, $type, $contents, $attr_collections, $attributes);\n+        return $element;\n+    }\n+\n+    /**\n+     * Adds a blank element to your HTML definition, for overriding\n+     * existing behavior\n+     * @param string $element_name\n+     * @return HTMLPurifier_ElementDef\n+     * @see HTMLPurifier_HTMLModule::addBlankElement() for detailed\n+     *       parameter and return value descriptions.\n+     */\n+    public function addBlankElement($element_name)\n+    {\n+        $module  = $this->getAnonymousModule();\n+        $element = $module->addBlankElement($element_name);\n+        return $element;\n+    }\n+\n+    /**\n+     * Retrieves a reference to the anonymous module, so you can\n+     * bust out advanced features without having to make your own\n+     * module.\n+     * @return HTMLPurifier_HTMLModule\n+     */\n+    public function getAnonymousModule()\n+    {\n+        if (!$this->_anonModule) {\n+            $this->_anonModule = new HTMLPurifier_HTMLModule();\n+            $this->_anonModule->name = 'Anonymous';\n+        }\n+        return $this->_anonModule;\n+    }\n+\n+    private $_anonModule = null;\n+\n+    // PUBLIC BUT INTERNAL VARIABLES --------------------------------------\n+\n+    /**\n+     * @type string\n+     */\n+    public $type = 'HTML';\n+\n+    /**\n+     * @type HTMLPurifier_HTMLModuleManager\n+     */\n+    public $manager;\n+\n+    /**\n+     * Performs low-cost, preliminary initialization.\n+     */\n+    public function __construct()\n+    {\n+        $this->manager = new HTMLPurifier_HTMLModuleManager();\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    protected function doSetup($config)\n+    {\n+        $this->processModules($config);\n+        $this->setupConfigStuff($config);\n+        unset($this->manager);\n+\n+        // cleanup some of the element definitions\n+        foreach ($this->info as $k => $v) {\n+            unset($this->info[$k]->content_model);\n+            unset($this->info[$k]->content_model_type);\n+        }\n+    }\n+\n+    /**\n+     * Extract out the information from the manager\n+     * @param HTMLPurifier_Config $config\n+     */\n+    protected function processModules($config)\n+    {\n+        if ($this->_anonModule) {\n+            // for user specific changes\n+            // this is late-loaded so we don't have to deal with PHP4\n+            // reference wonky-ness\n+            $this->manager->addModule($this->_anonModule);\n+            unset($this->_anonModule);\n+        }\n+\n+        $this->manager->setup($config);\n+        $this->doctype = $this->manager->doctype;\n+\n+        foreach ($this->manager->modules as $module) {\n+            foreach ($module->info_tag_transform as $k => $v) {\n+                if ($v === false) {\n+                    unset($this->info_tag_transform[$k]);\n+                } else {\n+                    $this->info_tag_transform[$k] = $v;\n+                }\n+            }\n+            foreach ($module->info_attr_transform_pre as $k => $v) {\n+                if ($v === false) {\n+                    unset($this->info_attr_transform_pre[$k]);\n+                } else {\n+                    $this->info_attr_transform_pre[$k] = $v;\n+                }\n+            }\n+            foreach ($module->info_attr_transform_post as $k => $v) {\n+                if ($v === false) {\n+                    unset($this->info_attr_transform_post[$k]);\n+                } else {\n+                    $this->info_attr_transform_post[$k] = $v;\n+                }\n+            }\n+            foreach ($module->info_injector as $k => $v) {\n+                if ($v === false) {\n+                    unset($this->info_injector[$k]);\n+                } else {\n+                    $this->info_injector[$k] = $v;\n+                }\n+            }\n+        }\n+        $this->info = $this->manager->getElements();\n+        $this->info_content_sets = $this->manager->contentSets->lookup;\n+    }\n+\n+    /**\n+     * Sets up stuff based on config. We need a better way of doing this.\n+     * @param HTMLPurifier_Config $config\n+     */\n+    protected function setupConfigStuff($config)\n+    {\n+        $block_wrapper = $config->get('HTML.BlockWrapper');\n+        if (isset($this->info_content_sets['Block'][$block_wrapper])) {\n+            $this->info_block_wrapper = $block_wrapper;\n+        } else {\n+            trigger_error(\n+                'Cannot use non-block element as block wrapper',\n+                E_USER_ERROR\n+            );\n+        }\n+\n+        $parent = $config->get('HTML.Parent');\n+        $def = $this->manager->getElement($parent, true);\n+        if ($def) {\n+            $this->info_parent = $parent;\n+            $this->info_parent_def = $def;\n+        } else {\n+            trigger_error(\n+                'Cannot use unrecognized element as parent',\n+                E_USER_ERROR\n+            );\n+            $this->info_parent_def = $this->manager->getElement($this->info_parent, true);\n+        }\n+\n+        // support template text\n+        $support = \"(for information on implementing this, see the support forums) \";\n+\n+        // setup allowed elements -----------------------------------------\n+\n+        $allowed_elements = $config->get('HTML.AllowedElements');\n+        $allowed_attributes = $config->get('HTML.AllowedAttributes'); // retrieve early\n+\n+        if (!is_array($allowed_elements) && !is_array($allowed_attributes)) {\n+            $allowed = $config->get('HTML.Allowed');\n+            if (is_string($allowed)) {\n+                list($allowed_elements, $allowed_attributes) = $this->parseTinyMCEAllowedList($allowed);\n+            }\n+        }\n+\n+        if (is_array($allowed_elements)) {\n+            foreach ($this->info as $name => $d) {\n+                if (!isset($allowed_elements[$name])) {\n+                    unset($this->info[$name]);\n+                }\n+                unset($allowed_elements[$name]);\n+            }\n+            // emit errors\n+            foreach ($allowed_elements as $element => $d) {\n+                $element = htmlspecialchars($element); // PHP doesn't escape errors, be careful!\n+                trigger_error(\"Element '$element' is not supported $support\", E_USER_WARNING);\n+            }\n+        }\n+\n+        // setup allowed attributes ---------------------------------------\n+\n+        $allowed_attributes_mutable = $allowed_attributes; // by copy!\n+        if (is_array($allowed_attributes)) {\n+            // This actually doesn't do anything, since we went away from\n+            // global attributes. It's possible that userland code uses\n+            // it, but HTMLModuleManager doesn't!\n+            foreach ($this->info_global_attr as $attr => $x) {\n+                $keys = array($attr, \"*@$attr\", \"*.$attr\");\n+                $delete = true;\n+                foreach ($keys as $key) {\n+                    if ($delete && isset($allowed_attributes[$key])) {\n+                        $delete = false;\n+                    }\n+                    if (isset($allowed_attributes_mutable[$key])) {\n+                        unset($allowed_attributes_mutable[$key]);\n+                    }\n+                }\n+                if ($delete) {\n+                    unset($this->info_global_attr[$attr]);\n+                }\n+            }\n+\n+            foreach ($this->info as $tag => $info) {\n+                foreach ($info->attr as $attr => $x) {\n+                    $keys = array(\"$tag@$attr\", $attr, \"*@$attr\", \"$tag.$attr\", \"*.$attr\");\n+                    $delete = true;\n+                    foreach ($keys as $key) {\n+                        if ($delete && isset($allowed_attributes[$key])) {\n+                            $delete = false;\n+                        }\n+                        if (isset($allowed_attributes_mutable[$key])) {\n+                            unset($allowed_attributes_mutable[$key]);\n+                        }\n+                    }\n+                    if ($delete) {\n+                        if ($this->info[$tag]->attr[$attr]->required) {\n+                            trigger_error(\n+                                \"Required attribute '$attr' in element '$tag' \" .\n+                                \"was not allowed, which means '$tag' will not be allowed either\",\n+                                E_USER_WARNING\n+                            );\n+                        }\n+                        unset($this->info[$tag]->attr[$attr]);\n+                    }\n+                }\n+            }\n+            // emit errors\n+            foreach ($allowed_attributes_mutable as $elattr => $d) {\n+                $bits = preg_split('/[.@]/', $elattr, 2);\n+                $c = count($bits);\n+                switch ($c) {\n+                    case 2:\n+                        if ($bits[0] !== '*') {\n+                            $element = htmlspecialchars($bits[0]);\n+                            $attribute = htmlspecialchars($bits[1]);\n+                            if (!isset($this->info[$element])) {\n+                                trigger_error(\n+                                    \"Cannot allow attribute '$attribute' if element \" .\n+                                    \"'$element' is not allowed/supported $support\"\n+                                );\n+                            } else {\n+                                trigger_error(\n+                                    \"Attribute '$attribute' in element '$element' not supported $support\",\n+                                    E_USER_WARNING\n+                                );\n+                            }\n+                            break;\n+                        }\n+                        // otherwise fall through\n+                    case 1:\n+                        $attribute = htmlspecialchars($bits[0]);\n+                        trigger_error(\n+                            \"Global attribute '$attribute' is not \".\n+                            \"supported in any elements $support\",\n+                            E_USER_WARNING\n+                        );\n+                        break;\n+                }\n+            }\n+        }\n+\n+        // setup forbidden elements ---------------------------------------\n+\n+        $forbidden_elements   = $config->get('HTML.ForbiddenElements');\n+        $forbidden_attributes = $config->get('HTML.ForbiddenAttributes');\n+\n+        foreach ($this->info as $tag => $info) {\n+            if (isset($forbidden_elements[$tag])) {\n+                unset($this->info[$tag]);\n+                continue;\n+            }\n+            foreach ($info->attr as $attr => $x) {\n+                if (isset($forbidden_attributes[\"$tag@$attr\"]) ||\n+                    isset($forbidden_attributes[\"*@$attr\"]) ||\n+                    isset($forbidden_attributes[$attr])\n+                ) {\n+                    unset($this->info[$tag]->attr[$attr]);\n+                    continue;\n+                } elseif (isset($forbidden_attributes[\"$tag.$attr\"])) { // this segment might get removed eventually\n+                    // $tag.$attr are not user supplied, so no worries!\n+                    trigger_error(\n+                        \"Error with $tag.$attr: tag.attr syntax not supported for \" .\n+                        \"HTML.ForbiddenAttributes; use tag@attr instead\",\n+                        E_USER_WARNING\n+                    );\n+                }\n+            }\n+        }\n+        foreach ($forbidden_attributes as $key => $v) {\n+            if (strlen($key) < 2) {\n+                continue;\n+            }\n+            if ($key[0] != '*') {\n+                continue;\n+            }\n+            if ($key[1] == '.') {\n+                trigger_error(\n+                    \"Error with $key: *.attr syntax not supported for HTML.ForbiddenAttributes; use attr instead\",\n+                    E_USER_WARNING\n+                );\n+            }\n+        }\n+\n+        // setup injectors -----------------------------------------------------\n+        foreach ($this->info_injector as $i => $injector) {\n+            if ($injector->checkNeeded($config) !== false) {\n+                // remove injector that does not have it's required\n+                // elements/attributes present, and is thus not needed.\n+                unset($this->info_injector[$i]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parses a TinyMCE-flavored Allowed Elements and Attributes list into\n+     * separate lists for processing. Format is element[attr1|attr2],element2...\n+     * @warning Although it's largely drawn from TinyMCE's implementation,\n+     *      it is different, and you'll probably have to modify your lists\n+     * @param array $list String list to parse\n+     * @return array\n+     * @todo Give this its own class, probably static interface\n+     */\n+    public function parseTinyMCEAllowedList($list)\n+    {\n+        $list = str_replace(array(' ', \"\\t\"), '', $list);\n+\n+        $elements = array();\n+        $attributes = array();\n+\n+        $chunks = preg_split('/(,|[\\n\\r]+)/', $list);\n+        foreach ($chunks as $chunk) {\n+            if (empty($chunk)) {\n+                continue;\n+            }\n+            // remove TinyMCE element control characters\n+            if (!strpos($chunk, '[')) {\n+                $element = $chunk;\n+                $attr = false;\n+            } else {\n+                list($element, $attr) = explode('[', $chunk);\n+            }\n+            if ($element !== '*') {\n+                $elements[$element] = true;\n+            }\n+            if (!$attr) {\n+                continue;\n+            }\n+            $attr = substr($attr, 0, strlen($attr) - 1); // remove trailing ]\n+            $attr = explode('|', $attr);\n+            foreach ($attr as $key) {\n+                $attributes[\"$element.$key\"] = true;\n+            }\n+        }\n+        return array($elements, $attributes);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule.php",
          "status": "added",
          "additions": 284,
          "deletions": 0,
          "patch": "@@ -0,0 +1,284 @@\n+<?php\n+\n+/**\n+ * Represents an XHTML 1.1 module, with information on elements, tags\n+ * and attributes.\n+ * @note Even though this is technically XHTML 1.1, it is also used for\n+ *       regular HTML parsing. We are using modulization as a convenient\n+ *       way to represent the internals of HTMLDefinition, and our\n+ *       implementation is by no means conforming and does not directly\n+ *       use the normative DTDs or XML schemas.\n+ * @note The public variables in a module should almost directly\n+ *       correspond to the variables in HTMLPurifier_HTMLDefinition.\n+ *       However, the prefix info carries no special meaning in these\n+ *       objects (include it anyway if that's the correspondence though).\n+ * @todo Consider making some member functions protected\n+ */\n+\n+class HTMLPurifier_HTMLModule\n+{\n+\n+    // -- Overloadable ----------------------------------------------------\n+\n+    /**\n+     * Short unique string identifier of the module.\n+     * @type string\n+     */\n+    public $name;\n+\n+    /**\n+     * Informally, a list of elements this module changes.\n+     * Not used in any significant way.\n+     * @type array\n+     */\n+    public $elements = array();\n+\n+    /**\n+     * Associative array of element names to element definitions.\n+     * Some definitions may be incomplete, to be merged in later\n+     * with the full definition.\n+     * @type array\n+     */\n+    public $info = array();\n+\n+    /**\n+     * Associative array of content set names to content set additions.\n+     * This is commonly used to, say, add an A element to the Inline\n+     * content set. This corresponds to an internal variable $content_sets\n+     * and NOT info_content_sets member variable of HTMLDefinition.\n+     * @type array\n+     */\n+    public $content_sets = array();\n+\n+    /**\n+     * Associative array of attribute collection names to attribute\n+     * collection additions. More rarely used for adding attributes to\n+     * the global collections. Example is the StyleAttribute module adding\n+     * the style attribute to the Core. Corresponds to HTMLDefinition's\n+     * attr_collections->info, since the object's data is only info,\n+     * with extra behavior associated with it.\n+     * @type array\n+     */\n+    public $attr_collections = array();\n+\n+    /**\n+     * Associative array of deprecated tag name to HTMLPurifier_TagTransform.\n+     * @type array\n+     */\n+    public $info_tag_transform = array();\n+\n+    /**\n+     * List of HTMLPurifier_AttrTransform to be performed before validation.\n+     * @type array\n+     */\n+    public $info_attr_transform_pre = array();\n+\n+    /**\n+     * List of HTMLPurifier_AttrTransform to be performed after validation.\n+     * @type array\n+     */\n+    public $info_attr_transform_post = array();\n+\n+    /**\n+     * List of HTMLPurifier_Injector to be performed during well-formedness fixing.\n+     * An injector will only be invoked if all of it's pre-requisites are met;\n+     * if an injector fails setup, there will be no error; it will simply be\n+     * silently disabled.\n+     * @type array\n+     */\n+    public $info_injector = array();\n+\n+    /**\n+     * Boolean flag that indicates whether or not getChildDef is implemented.\n+     * For optimization reasons: may save a call to a function. Be sure\n+     * to set it if you do implement getChildDef(), otherwise it will have\n+     * no effect!\n+     * @type bool\n+     */\n+    public $defines_child_def = false;\n+\n+    /**\n+     * Boolean flag whether or not this module is safe. If it is not safe, all\n+     * of its members are unsafe. Modules are safe by default (this might be\n+     * slightly dangerous, but it doesn't make much sense to force HTML Purifier,\n+     * which is based off of safe HTML, to explicitly say, \"This is safe,\" even\n+     * though there are modules which are \"unsafe\")\n+     *\n+     * @type bool\n+     * @note Previously, safety could be applied at an element level granularity.\n+     *       We've removed this ability, so in order to add \"unsafe\" elements\n+     *       or attributes, a dedicated module with this property set to false\n+     *       must be used.\n+     */\n+    public $safe = true;\n+\n+    /**\n+     * Retrieves a proper HTMLPurifier_ChildDef subclass based on\n+     * content_model and content_model_type member variables of\n+     * the HTMLPurifier_ElementDef class. There is a similar function\n+     * in HTMLPurifier_HTMLDefinition.\n+     * @param HTMLPurifier_ElementDef $def\n+     * @return HTMLPurifier_ChildDef subclass\n+     */\n+    public function getChildDef($def)\n+    {\n+        return false;\n+    }\n+\n+    // -- Convenience -----------------------------------------------------\n+\n+    /**\n+     * Convenience function that sets up a new element\n+     * @param string $element Name of element to add\n+     * @param string|bool $type What content set should element be registered to?\n+     *              Set as false to skip this step.\n+     * @param string $contents Allowed children in form of:\n+     *              \"$content_model_type: $content_model\"\n+     * @param array $attr_includes What attribute collections to register to\n+     *              element?\n+     * @param array $attr What unique attributes does the element define?\n+     * @see HTMLPurifier_ElementDef:: for in-depth descriptions of these parameters.\n+     * @return HTMLPurifier_ElementDef Created element definition object, so you\n+     *         can set advanced parameters\n+     */\n+    public function addElement($element, $type, $contents, $attr_includes = array(), $attr = array())\n+    {\n+        $this->elements[] = $element;\n+        // parse content_model\n+        list($content_model_type, $content_model) = $this->parseContents($contents);\n+        // merge in attribute inclusions\n+        $this->mergeInAttrIncludes($attr, $attr_includes);\n+        // add element to content sets\n+        if ($type) {\n+            $this->addElementToContentSet($element, $type);\n+        }\n+        // create element\n+        $this->info[$element] = HTMLPurifier_ElementDef::create(\n+            $content_model,\n+            $content_model_type,\n+            $attr\n+        );\n+        // literal object $contents means direct child manipulation\n+        if (!is_string($contents)) {\n+            $this->info[$element]->child = $contents;\n+        }\n+        return $this->info[$element];\n+    }\n+\n+    /**\n+     * Convenience function that creates a totally blank, non-standalone\n+     * element.\n+     * @param string $element Name of element to create\n+     * @return HTMLPurifier_ElementDef Created element\n+     */\n+    public function addBlankElement($element)\n+    {\n+        if (!isset($this->info[$element])) {\n+            $this->elements[] = $element;\n+            $this->info[$element] = new HTMLPurifier_ElementDef();\n+            $this->info[$element]->standalone = false;\n+        } else {\n+            trigger_error(\"Definition for $element already exists in module, cannot redefine\");\n+        }\n+        return $this->info[$element];\n+    }\n+\n+    /**\n+     * Convenience function that registers an element to a content set\n+     * @param string $element Element to register\n+     * @param string $type Name content set (warning: case sensitive, usually upper-case\n+     *        first letter)\n+     */\n+    public function addElementToContentSet($element, $type)\n+    {\n+        if (!isset($this->content_sets[$type])) {\n+            $this->content_sets[$type] = '';\n+        } else {\n+            $this->content_sets[$type] .= ' | ';\n+        }\n+        $this->content_sets[$type] .= $element;\n+    }\n+\n+    /**\n+     * Convenience function that transforms single-string contents\n+     * into separate content model and content model type\n+     * @param string $contents Allowed children in form of:\n+     *                  \"$content_model_type: $content_model\"\n+     * @return array\n+     * @note If contents is an object, an array of two nulls will be\n+     *       returned, and the callee needs to take the original $contents\n+     *       and use it directly.\n+     */\n+    public function parseContents($contents)\n+    {\n+        if (!is_string($contents)) {\n+            return array(null, null);\n+        } // defer\n+        switch ($contents) {\n+            // check for shorthand content model forms\n+            case 'Empty':\n+                return array('empty', '');\n+            case 'Inline':\n+                return array('optional', 'Inline | #PCDATA');\n+            case 'Flow':\n+                return array('optional', 'Flow | #PCDATA');\n+        }\n+        list($content_model_type, $content_model) = explode(':', $contents);\n+        $content_model_type = strtolower(trim($content_model_type));\n+        $content_model = trim($content_model);\n+        return array($content_model_type, $content_model);\n+    }\n+\n+    /**\n+     * Convenience function that merges a list of attribute includes into\n+     * an attribute array.\n+     * @param array $attr Reference to attr array to modify\n+     * @param array $attr_includes Array of includes / string include to merge in\n+     */\n+    public function mergeInAttrIncludes(&$attr, $attr_includes)\n+    {\n+        if (!is_array($attr_includes)) {\n+            if (empty($attr_includes)) {\n+                $attr_includes = array();\n+            } else {\n+                $attr_includes = array($attr_includes);\n+            }\n+        }\n+        $attr[0] = $attr_includes;\n+    }\n+\n+    /**\n+     * Convenience function that generates a lookup table with boolean\n+     * true as value.\n+     * @param string $list List of values to turn into a lookup\n+     * @note You can also pass an arbitrary number of arguments in\n+     *       place of the regular argument\n+     * @return array array equivalent of list\n+     */\n+    public function makeLookup($list)\n+    {\n+        if (is_string($list)) {\n+            $list = func_get_args();\n+        }\n+        $ret = array();\n+        foreach ($list as $value) {\n+            if (is_null($value)) {\n+                continue;\n+            }\n+            $ret[$value] = true;\n+        }\n+        return $ret;\n+    }\n+\n+    /**\n+     * Lazy load construction of the module after determining whether\n+     * or not it's needed, and also when a finalized configuration object\n+     * is available.\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Bdo.php",
          "status": "added",
          "additions": 44,
          "deletions": 0,
          "patch": "@@ -0,0 +1,44 @@\n+<?php\n+\n+/**\n+ * XHTML 1.1 Bi-directional Text Module, defines elements that\n+ * declare directionality of content. Text Extension Module.\n+ */\n+class HTMLPurifier_HTMLModule_Bdo extends HTMLPurifier_HTMLModule\n+{\n+\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Bdo';\n+\n+    /**\n+     * @type array\n+     */\n+    public $attr_collections = array(\n+        'I18N' => array('dir' => false)\n+    );\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $bdo = $this->addElement(\n+            'bdo',\n+            'Inline',\n+            'Inline',\n+            array('Core', 'Lang'),\n+            array(\n+                'dir' => 'Enum#ltr,rtl', // required\n+                // The Abstract Module specification has the attribute\n+                // inclusions wrong for bdo: bdo allows Lang\n+            )\n+        );\n+        $bdo->attr_transform_post[] = new HTMLPurifier_AttrTransform_BdoDir();\n+\n+        $this->attr_collections['I18N']['dir'] = 'Enum#ltr,rtl';\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/CommonAttributes.php",
          "status": "added",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -0,0 +1,31 @@\n+<?php\n+\n+class HTMLPurifier_HTMLModule_CommonAttributes extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'CommonAttributes';\n+\n+    /**\n+     * @type array\n+     */\n+    public $attr_collections = array(\n+        'Core' => array(\n+            0 => array('Style'),\n+            // 'xml:space' => false,\n+            'class' => 'Class',\n+            'id' => 'ID',\n+            'title' => 'CDATA',\n+        ),\n+        'Lang' => array(),\n+        'I18N' => array(\n+            0 => array('Lang'), // proprietary, for xml:lang/lang\n+        ),\n+        'Common' => array(\n+            0 => array('Core', 'I18N')\n+        )\n+    );\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Edit.php",
          "status": "added",
          "additions": 55,
          "deletions": 0,
          "patch": "@@ -0,0 +1,55 @@\n+<?php\n+\n+/**\n+ * XHTML 1.1 Edit Module, defines editing-related elements. Text Extension\n+ * Module.\n+ */\n+class HTMLPurifier_HTMLModule_Edit extends HTMLPurifier_HTMLModule\n+{\n+\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Edit';\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $contents = 'Chameleon: #PCDATA | Inline ! #PCDATA | Flow';\n+        $attr = array(\n+            'cite' => 'URI',\n+            // 'datetime' => 'Datetime', // not implemented\n+        );\n+        $this->addElement('del', 'Inline', $contents, 'Common', $attr);\n+        $this->addElement('ins', 'Inline', $contents, 'Common', $attr);\n+    }\n+\n+    // HTML 4.01 specifies that ins/del must not contain block\n+    // elements when used in an inline context, chameleon is\n+    // a complicated workaround to acheive this effect\n+\n+    // Inline context ! Block context (exclamation mark is\n+    // separator, see getChildDef for parsing)\n+\n+    /**\n+     * @type bool\n+     */\n+    public $defines_child_def = true;\n+\n+    /**\n+     * @param HTMLPurifier_ElementDef $def\n+     * @return HTMLPurifier_ChildDef_Chameleon\n+     */\n+    public function getChildDef($def)\n+    {\n+        if ($def->content_model_type != 'chameleon') {\n+            return false;\n+        }\n+        $value = explode('!', $def->content_model);\n+        return new HTMLPurifier_ChildDef_Chameleon($value[0], $value[1]);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Forms.php",
          "status": "added",
          "additions": 190,
          "deletions": 0,
          "patch": "@@ -0,0 +1,190 @@\n+<?php\n+\n+/**\n+ * XHTML 1.1 Forms module, defines all form-related elements found in HTML 4.\n+ */\n+class HTMLPurifier_HTMLModule_Forms extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Forms';\n+\n+    /**\n+     * @type bool\n+     */\n+    public $safe = false;\n+\n+    /**\n+     * @type array\n+     */\n+    public $content_sets = array(\n+        'Block' => 'Form',\n+        'Inline' => 'Formctrl',\n+    );\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $form = $this->addElement(\n+            'form',\n+            'Form',\n+            'Required: Heading | List | Block | fieldset',\n+            'Common',\n+            array(\n+                'accept' => 'ContentTypes',\n+                'accept-charset' => 'Charsets',\n+                'action*' => 'URI',\n+                'method' => 'Enum#get,post',\n+                // really ContentType, but these two are the only ones used today\n+                'enctype' => 'Enum#application/x-www-form-urlencoded,multipart/form-data',\n+            )\n+        );\n+        $form->excludes = array('form' => true);\n+\n+        $input = $this->addElement(\n+            'input',\n+            'Formctrl',\n+            'Empty',\n+            'Common',\n+            array(\n+                'accept' => 'ContentTypes',\n+                'accesskey' => 'Character',\n+                'alt' => 'Text',\n+                'checked' => 'Bool#checked',\n+                'disabled' => 'Bool#disabled',\n+                'maxlength' => 'Number',\n+                'name' => 'CDATA',\n+                'readonly' => 'Bool#readonly',\n+                'size' => 'Number',\n+                'src' => 'URI#embedded',\n+                'tabindex' => 'Number',\n+                'type' => 'Enum#text,password,checkbox,button,radio,submit,reset,file,hidden,image',\n+                'value' => 'CDATA',\n+            )\n+        );\n+        $input->attr_transform_post[] = new HTMLPurifier_AttrTransform_Input();\n+\n+        $this->addElement(\n+            'select',\n+            'Formctrl',\n+            'Required: optgroup | option',\n+            'Common',\n+            array(\n+                'disabled' => 'Bool#disabled',\n+                'multiple' => 'Bool#multiple',\n+                'name' => 'CDATA',\n+                'size' => 'Number',\n+                'tabindex' => 'Number',\n+            )\n+        );\n+\n+        $this->addElement(\n+            'option',\n+            false,\n+            'Optional: #PCDATA',\n+            'Common',\n+            array(\n+                'disabled' => 'Bool#disabled',\n+                'label' => 'Text',\n+                'selected' => 'Bool#selected',\n+                'value' => 'CDATA',\n+            )\n+        );\n+        // It's illegal for there to be more than one selected, but not\n+        // be multiple. Also, no selected means undefined behavior. This might\n+        // be difficult to implement; perhaps an injector, or a context variable.\n+\n+        $textarea = $this->addElement(\n+            'textarea',\n+            'Formctrl',\n+            'Optional: #PCDATA',\n+            'Common',\n+            array(\n+                'accesskey' => 'Character',\n+                'cols*' => 'Number',\n+                'disabled' => 'Bool#disabled',\n+                'name' => 'CDATA',\n+                'readonly' => 'Bool#readonly',\n+                'rows*' => 'Number',\n+                'tabindex' => 'Number',\n+            )\n+        );\n+        $textarea->attr_transform_pre[] = new HTMLPurifier_AttrTransform_Textarea();\n+\n+        $button = $this->addElement(\n+            'button',\n+            'Formctrl',\n+            'Optional: #PCDATA | Heading | List | Block | Inline',\n+            'Common',\n+            array(\n+                'accesskey' => 'Character',\n+                'disabled' => 'Bool#disabled',\n+                'name' => 'CDATA',\n+                'tabindex' => 'Number',\n+                'type' => 'Enum#button,submit,reset',\n+                'value' => 'CDATA',\n+            )\n+        );\n+\n+        // For exclusions, ideally we'd specify content sets, not literal elements\n+        $button->excludes = $this->makeLookup(\n+            'form',\n+            'fieldset', // Form\n+            'input',\n+            'select',\n+            'textarea',\n+            'label',\n+            'button', // Formctrl\n+            'a', // as per HTML 4.01 spec, this is omitted by modularization\n+            'isindex',\n+            'iframe' // legacy items\n+        );\n+\n+        // Extra exclusion: img usemap=\"\" is not permitted within this element.\n+        // We'll omit this for now, since we don't have any good way of\n+        // indicating it yet.\n+\n+        // This is HIGHLY user-unfriendly; we need a custom child-def for this\n+        $this->addElement('fieldset', 'Form', 'Custom: (#WS?,legend,(Flow|#PCDATA)*)', 'Common');\n+\n+        $label = $this->addElement(\n+            'label',\n+            'Formctrl',\n+            'Optional: #PCDATA | Inline',\n+            'Common',\n+            array(\n+                'accesskey' => 'Character',\n+                // 'for' => 'IDREF', // IDREF not implemented, cannot allow\n+            )\n+        );\n+        $label->excludes = array('label' => true);\n+\n+        $this->addElement(\n+            'legend',\n+            false,\n+            'Optional: #PCDATA | Inline',\n+            'Common',\n+            array(\n+                'accesskey' => 'Character',\n+            )\n+        );\n+\n+        $this->addElement(\n+            'optgroup',\n+            false,\n+            'Required: option',\n+            'Common',\n+            array(\n+                'disabled' => 'Bool#disabled',\n+                'label*' => 'Text',\n+            )\n+        );\n+        // Don't forget an injector for <isindex>. This one's a little complex\n+        // because it maps to multiple elements.\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Hypertext.php",
          "status": "added",
          "additions": 40,
          "deletions": 0,
          "patch": "@@ -0,0 +1,40 @@\n+<?php\n+\n+/**\n+ * XHTML 1.1 Hypertext Module, defines hypertext links. Core Module.\n+ */\n+class HTMLPurifier_HTMLModule_Hypertext extends HTMLPurifier_HTMLModule\n+{\n+\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Hypertext';\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $a = $this->addElement(\n+            'a',\n+            'Inline',\n+            'Inline',\n+            'Common',\n+            array(\n+                // 'accesskey' => 'Character',\n+                // 'charset' => 'Charset',\n+                'href' => 'URI',\n+                // 'hreflang' => 'LanguageCode',\n+                'rel' => new HTMLPurifier_AttrDef_HTML_LinkTypes('rel'),\n+                'rev' => new HTMLPurifier_AttrDef_HTML_LinkTypes('rev'),\n+                // 'tabindex' => 'Number',\n+                // 'type' => 'ContentType',\n+            )\n+        );\n+        $a->formatting = true;\n+        $a->excludes = array('a' => true);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Iframe.php",
          "status": "added",
          "additions": 51,
          "deletions": 0,
          "patch": "@@ -0,0 +1,51 @@\n+<?php\n+\n+/**\n+ * XHTML 1.1 Iframe Module provides inline frames.\n+ *\n+ * @note This module is not considered safe unless an Iframe\n+ * whitelisting mechanism is specified.  Currently, the only\n+ * such mechanism is %URL.SafeIframeRegexp\n+ */\n+class HTMLPurifier_HTMLModule_Iframe extends HTMLPurifier_HTMLModule\n+{\n+\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Iframe';\n+\n+    /**\n+     * @type bool\n+     */\n+    public $safe = false;\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        if ($config->get('HTML.SafeIframe')) {\n+            $this->safe = true;\n+        }\n+        $this->addElement(\n+            'iframe',\n+            'Inline',\n+            'Flow',\n+            'Common',\n+            array(\n+                'src' => 'URI#embedded',\n+                'width' => 'Length',\n+                'height' => 'Length',\n+                'name' => 'ID',\n+                'scrolling' => 'Enum#yes,no,auto',\n+                'frameborder' => 'Enum#0,1',\n+                'longdesc' => 'URI',\n+                'marginheight' => 'Pixels',\n+                'marginwidth' => 'Pixels',\n+            )\n+        );\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Image.php",
          "status": "added",
          "additions": 49,
          "deletions": 0,
          "patch": "@@ -0,0 +1,49 @@\n+<?php\n+\n+/**\n+ * XHTML 1.1 Image Module provides basic image embedding.\n+ * @note There is specialized code for removing empty images in\n+ *       HTMLPurifier_Strategy_RemoveForeignElements\n+ */\n+class HTMLPurifier_HTMLModule_Image extends HTMLPurifier_HTMLModule\n+{\n+\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Image';\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $max = $config->get('HTML.MaxImgLength');\n+        $img = $this->addElement(\n+            'img',\n+            'Inline',\n+            'Empty',\n+            'Common',\n+            array(\n+                'alt*' => 'Text',\n+                // According to the spec, it's Length, but percents can\n+                // be abused, so we allow only Pixels.\n+                'height' => 'Pixels#' . $max,\n+                'width' => 'Pixels#' . $max,\n+                'longdesc' => 'URI',\n+                'src*' => new HTMLPurifier_AttrDef_URI(true), // embedded\n+            )\n+        );\n+        if ($max === null || $config->get('HTML.Trusted')) {\n+            $img->attr['height'] =\n+            $img->attr['width'] = 'Length';\n+        }\n+\n+        // kind of strange, but splitting things up would be inefficient\n+        $img->attr_transform_pre[] =\n+        $img->attr_transform_post[] =\n+            new HTMLPurifier_AttrTransform_ImgRequired();\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Legacy.php",
          "status": "added",
          "additions": 186,
          "deletions": 0,
          "patch": "@@ -0,0 +1,186 @@\n+<?php\n+\n+/**\n+ * XHTML 1.1 Legacy module defines elements that were previously\n+ * deprecated.\n+ *\n+ * @note Not all legacy elements have been implemented yet, which\n+ *       is a bit of a reverse problem as compared to browsers! In\n+ *       addition, this legacy module may implement a bit more than\n+ *       mandated by XHTML 1.1.\n+ *\n+ * This module can be used in combination with TransformToStrict in order\n+ * to transform as many deprecated elements as possible, but retain\n+ * questionably deprecated elements that do not have good alternatives\n+ * as well as transform elements that don't have an implementation.\n+ * See docs/ref-strictness.txt for more details.\n+ */\n+\n+class HTMLPurifier_HTMLModule_Legacy extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Legacy';\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $this->addElement(\n+            'basefont',\n+            'Inline',\n+            'Empty',\n+            null,\n+            array(\n+                'color' => 'Color',\n+                'face' => 'Text', // extremely broad, we should\n+                'size' => 'Text', // tighten it\n+                'id' => 'ID'\n+            )\n+        );\n+        $this->addElement('center', 'Block', 'Flow', 'Common');\n+        $this->addElement(\n+            'dir',\n+            'Block',\n+            'Required: li',\n+            'Common',\n+            array(\n+                'compact' => 'Bool#compact'\n+            )\n+        );\n+        $this->addElement(\n+            'font',\n+            'Inline',\n+            'Inline',\n+            array('Core', 'I18N'),\n+            array(\n+                'color' => 'Color',\n+                'face' => 'Text', // extremely broad, we should\n+                'size' => 'Text', // tighten it\n+            )\n+        );\n+        $this->addElement(\n+            'menu',\n+            'Block',\n+            'Required: li',\n+            'Common',\n+            array(\n+                'compact' => 'Bool#compact'\n+            )\n+        );\n+\n+        $s = $this->addElement('s', 'Inline', 'Inline', 'Common');\n+        $s->formatting = true;\n+\n+        $strike = $this->addElement('strike', 'Inline', 'Inline', 'Common');\n+        $strike->formatting = true;\n+\n+        $u = $this->addElement('u', 'Inline', 'Inline', 'Common');\n+        $u->formatting = true;\n+\n+        // setup modifications to old elements\n+\n+        $align = 'Enum#left,right,center,justify';\n+\n+        $address = $this->addBlankElement('address');\n+        $address->content_model = 'Inline | #PCDATA | p';\n+        $address->content_model_type = 'optional';\n+        $address->child = false;\n+\n+        $blockquote = $this->addBlankElement('blockquote');\n+        $blockquote->content_model = 'Flow | #PCDATA';\n+        $blockquote->content_model_type = 'optional';\n+        $blockquote->child = false;\n+\n+        $br = $this->addBlankElement('br');\n+        $br->attr['clear'] = 'Enum#left,all,right,none';\n+\n+        $caption = $this->addBlankElement('caption');\n+        $caption->attr['align'] = 'Enum#top,bottom,left,right';\n+\n+        $div = $this->addBlankElement('div');\n+        $div->attr['align'] = $align;\n+\n+        $dl = $this->addBlankElement('dl');\n+        $dl->attr['compact'] = 'Bool#compact';\n+\n+        for ($i = 1; $i <= 6; $i++) {\n+            $h = $this->addBlankElement(\"h$i\");\n+            $h->attr['align'] = $align;\n+        }\n+\n+        $hr = $this->addBlankElement('hr');\n+        $hr->attr['align'] = $align;\n+        $hr->attr['noshade'] = 'Bool#noshade';\n+        $hr->attr['size'] = 'Pixels';\n+        $hr->attr['width'] = 'Length';\n+\n+        $img = $this->addBlankElement('img');\n+        $img->attr['align'] = 'IAlign';\n+        $img->attr['border'] = 'Pixels';\n+        $img->attr['hspace'] = 'Pixels';\n+        $img->attr['vspace'] = 'Pixels';\n+\n+        // figure out this integer business\n+\n+        $li = $this->addBlankElement('li');\n+        $li->attr['value'] = new HTMLPurifier_AttrDef_Integer();\n+        $li->attr['type'] = 'Enum#s:1,i,I,a,A,disc,square,circle';\n+\n+        $ol = $this->addBlankElement('ol');\n+        $ol->attr['compact'] = 'Bool#compact';\n+        $ol->attr['start'] = new HTMLPurifier_AttrDef_Integer();\n+        $ol->attr['type'] = 'Enum#s:1,i,I,a,A';\n+\n+        $p = $this->addBlankElement('p');\n+        $p->attr['align'] = $align;\n+\n+        $pre = $this->addBlankElement('pre');\n+        $pre->attr['width'] = 'Number';\n+\n+        // script omitted\n+\n+        $table = $this->addBlankElement('table');\n+        $table->attr['align'] = 'Enum#left,center,right';\n+        $table->attr['bgcolor'] = 'Color';\n+\n+        $tr = $this->addBlankElement('tr');\n+        $tr->attr['bgcolor'] = 'Color';\n+\n+        $th = $this->addBlankElement('th');\n+        $th->attr['bgcolor'] = 'Color';\n+        $th->attr['height'] = 'Length';\n+        $th->attr['nowrap'] = 'Bool#nowrap';\n+        $th->attr['width'] = 'Length';\n+\n+        $td = $this->addBlankElement('td');\n+        $td->attr['bgcolor'] = 'Color';\n+        $td->attr['height'] = 'Length';\n+        $td->attr['nowrap'] = 'Bool#nowrap';\n+        $td->attr['width'] = 'Length';\n+\n+        $ul = $this->addBlankElement('ul');\n+        $ul->attr['compact'] = 'Bool#compact';\n+        $ul->attr['type'] = 'Enum#square,disc,circle';\n+\n+        // \"safe\" modifications to \"unsafe\" elements\n+        // WARNING: If you want to add support for an unsafe, legacy\n+        // attribute, make a new TrustedLegacy module with the trusted\n+        // bit set appropriately\n+\n+        $form = $this->addBlankElement('form');\n+        $form->content_model = 'Flow | #PCDATA';\n+        $form->content_model_type = 'optional';\n+        $form->attr['target'] = 'FrameTarget';\n+\n+        $input = $this->addBlankElement('input');\n+        $input->attr['align'] = 'IAlign';\n+\n+        $legend = $this->addBlankElement('legend');\n+        $legend->attr['align'] = 'LAlign';\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/List.php",
          "status": "added",
          "additions": 51,
          "deletions": 0,
          "patch": "@@ -0,0 +1,51 @@\n+<?php\n+\n+/**\n+ * XHTML 1.1 List Module, defines list-oriented elements. Core Module.\n+ */\n+class HTMLPurifier_HTMLModule_List extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'List';\n+\n+    // According to the abstract schema, the List content set is a fully formed\n+    // one or more expr, but it invariably occurs in an optional declaration\n+    // so we're not going to do that subtlety. It might cause trouble\n+    // if a user defines \"List\" and expects that multiple lists are\n+    // allowed to be specified, but then again, that's not very intuitive.\n+    // Furthermore, the actual XML Schema may disagree. Regardless,\n+    // we don't have support for such nested expressions without using\n+    // the incredibly inefficient and draconic Custom ChildDef.\n+\n+    /**\n+     * @type array\n+     */\n+    public $content_sets = array('Flow' => 'List');\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $ol = $this->addElement('ol', 'List', new HTMLPurifier_ChildDef_List(), 'Common');\n+        $ul = $this->addElement('ul', 'List', new HTMLPurifier_ChildDef_List(), 'Common');\n+        // XXX The wrap attribute is handled by MakeWellFormed.  This is all\n+        // quite unsatisfactory, because we generated this\n+        // *specifically* for lists, and now a big chunk of the handling\n+        // is done properly by the List ChildDef.  So actually, we just\n+        // want enough information to make autoclosing work properly,\n+        // and then hand off the tricky stuff to the ChildDef.\n+        $ol->wrap = 'li';\n+        $ul->wrap = 'li';\n+        $this->addElement('dl', 'List', 'Required: dt | dd', 'Common');\n+\n+        $this->addElement('li', false, 'Flow', 'Common');\n+\n+        $this->addElement('dd', false, 'Flow', 'Common');\n+        $this->addElement('dt', false, 'Inline', 'Common');\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Name.php",
          "status": "added",
          "additions": 26,
          "deletions": 0,
          "patch": "@@ -0,0 +1,26 @@\n+<?php\n+\n+class HTMLPurifier_HTMLModule_Name extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Name';\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $elements = array('a', 'applet', 'form', 'frame', 'iframe', 'img', 'map');\n+        foreach ($elements as $name) {\n+            $element = $this->addBlankElement($name);\n+            $element->attr['name'] = 'CDATA';\n+            if (!$config->get('HTML.Attr.Name.UseCDATA')) {\n+                $element->attr_transform_post[] = new HTMLPurifier_AttrTransform_NameSync();\n+            }\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Nofollow.php",
          "status": "added",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -0,0 +1,25 @@\n+<?php\n+\n+/**\n+ * Module adds the nofollow attribute transformation to a tags.  It\n+ * is enabled by HTML.Nofollow\n+ */\n+class HTMLPurifier_HTMLModule_Nofollow extends HTMLPurifier_HTMLModule\n+{\n+\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Nofollow';\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $a = $this->addBlankElement('a');\n+        $a->attr_transform_post[] = new HTMLPurifier_AttrTransform_Nofollow();\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/NonXMLCommonAttributes.php",
          "status": "added",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -0,0 +1,20 @@\n+<?php\n+\n+class HTMLPurifier_HTMLModule_NonXMLCommonAttributes extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'NonXMLCommonAttributes';\n+\n+    /**\n+     * @type array\n+     */\n+    public $attr_collections = array(\n+        'Lang' => array(\n+            'lang' => 'LanguageCode',\n+        )\n+    );\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Object.php",
          "status": "added",
          "additions": 62,
          "deletions": 0,
          "patch": "@@ -0,0 +1,62 @@\n+<?php\n+\n+/**\n+ * XHTML 1.1 Object Module, defines elements for generic object inclusion\n+ * @warning Users will commonly use <embed> to cater to legacy browsers: this\n+ *      module does not allow this sort of behavior\n+ */\n+class HTMLPurifier_HTMLModule_Object extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Object';\n+\n+    /**\n+     * @type bool\n+     */\n+    public $safe = false;\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $this->addElement(\n+            'object',\n+            'Inline',\n+            'Optional: #PCDATA | Flow | param',\n+            'Common',\n+            array(\n+                'archive' => 'URI',\n+                'classid' => 'URI',\n+                'codebase' => 'URI',\n+                'codetype' => 'Text',\n+                'data' => 'URI',\n+                'declare' => 'Bool#declare',\n+                'height' => 'Length',\n+                'name' => 'CDATA',\n+                'standby' => 'Text',\n+                'tabindex' => 'Number',\n+                'type' => 'ContentType',\n+                'width' => 'Length'\n+            )\n+        );\n+\n+        $this->addElement(\n+            'param',\n+            false,\n+            'Empty',\n+            null,\n+            array(\n+                'id' => 'ID',\n+                'name*' => 'Text',\n+                'type' => 'Text',\n+                'value' => 'Text',\n+                'valuetype' => 'Enum#data,ref,object'\n+            )\n+        );\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Presentation.php",
          "status": "added",
          "additions": 42,
          "deletions": 0,
          "patch": "@@ -0,0 +1,42 @@\n+<?php\n+\n+/**\n+ * XHTML 1.1 Presentation Module, defines simple presentation-related\n+ * markup. Text Extension Module.\n+ * @note The official XML Schema and DTD specs further divide this into\n+ *       two modules:\n+ *          - Block Presentation (hr)\n+ *          - Inline Presentation (b, big, i, small, sub, sup, tt)\n+ *       We have chosen not to heed this distinction, as content_sets\n+ *       provides satisfactory disambiguation.\n+ */\n+class HTMLPurifier_HTMLModule_Presentation extends HTMLPurifier_HTMLModule\n+{\n+\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Presentation';\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $this->addElement('hr', 'Block', 'Empty', 'Common');\n+        $this->addElement('sub', 'Inline', 'Inline', 'Common');\n+        $this->addElement('sup', 'Inline', 'Inline', 'Common');\n+        $b = $this->addElement('b', 'Inline', 'Inline', 'Common');\n+        $b->formatting = true;\n+        $big = $this->addElement('big', 'Inline', 'Inline', 'Common');\n+        $big->formatting = true;\n+        $i = $this->addElement('i', 'Inline', 'Inline', 'Common');\n+        $i->formatting = true;\n+        $small = $this->addElement('small', 'Inline', 'Inline', 'Common');\n+        $small->formatting = true;\n+        $tt = $this->addElement('tt', 'Inline', 'Inline', 'Common');\n+        $tt->formatting = true;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Proprietary.php",
          "status": "added",
          "additions": 40,
          "deletions": 0,
          "patch": "@@ -0,0 +1,40 @@\n+<?php\n+\n+/**\n+ * Module defines proprietary tags and attributes in HTML.\n+ * @warning If this module is enabled, standards-compliance is off!\n+ */\n+class HTMLPurifier_HTMLModule_Proprietary extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Proprietary';\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $this->addElement(\n+            'marquee',\n+            'Inline',\n+            'Flow',\n+            'Common',\n+            array(\n+                'direction' => 'Enum#left,right,up,down',\n+                'behavior' => 'Enum#alternate',\n+                'width' => 'Length',\n+                'height' => 'Length',\n+                'scrolldelay' => 'Number',\n+                'scrollamount' => 'Number',\n+                'loop' => 'Number',\n+                'bgcolor' => 'Color',\n+                'hspace' => 'Pixels',\n+                'vspace' => 'Pixels',\n+            )\n+        );\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Ruby.php",
          "status": "added",
          "additions": 36,
          "deletions": 0,
          "patch": "@@ -0,0 +1,36 @@\n+<?php\n+\n+/**\n+ * XHTML 1.1 Ruby Annotation Module, defines elements that indicate\n+ * short runs of text alongside base text for annotation or pronounciation.\n+ */\n+class HTMLPurifier_HTMLModule_Ruby extends HTMLPurifier_HTMLModule\n+{\n+\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Ruby';\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $this->addElement(\n+            'ruby',\n+            'Inline',\n+            'Custom: ((rb, (rt | (rp, rt, rp))) | (rbc, rtc, rtc?))',\n+            'Common'\n+        );\n+        $this->addElement('rbc', false, 'Required: rb', 'Common');\n+        $this->addElement('rtc', false, 'Required: rt', 'Common');\n+        $rb = $this->addElement('rb', false, 'Inline', 'Common');\n+        $rb->excludes = array('ruby' => true);\n+        $rt = $this->addElement('rt', false, 'Inline', 'Common', array('rbspan' => 'Number'));\n+        $rt->excludes = array('ruby' => true);\n+        $this->addElement('rp', false, 'Optional: #PCDATA', 'Common');\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/SafeEmbed.php",
          "status": "added",
          "additions": 40,
          "deletions": 0,
          "patch": "@@ -0,0 +1,40 @@\n+<?php\n+\n+/**\n+ * A \"safe\" embed module. See SafeObject. This is a proprietary element.\n+ */\n+class HTMLPurifier_HTMLModule_SafeEmbed extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'SafeEmbed';\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $max = $config->get('HTML.MaxImgLength');\n+        $embed = $this->addElement(\n+            'embed',\n+            'Inline',\n+            'Empty',\n+            'Common',\n+            array(\n+                'src*' => 'URI#embedded',\n+                'type' => 'Enum#application/x-shockwave-flash',\n+                'width' => 'Pixels#' . $max,\n+                'height' => 'Pixels#' . $max,\n+                'allowscriptaccess' => 'Enum#never',\n+                'allownetworking' => 'Enum#internal',\n+                'flashvars' => 'Text',\n+                'wmode' => 'Enum#window,transparent,opaque',\n+                'name' => 'ID',\n+            )\n+        );\n+        $embed->attr_transform_post[] = new HTMLPurifier_AttrTransform_SafeEmbed();\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/SafeObject.php",
          "status": "added",
          "additions": 62,
          "deletions": 0,
          "patch": "@@ -0,0 +1,62 @@\n+<?php\n+\n+/**\n+ * A \"safe\" object module. In theory, objects permitted by this module will\n+ * be safe, and untrusted users can be allowed to embed arbitrary flash objects\n+ * (maybe other types too, but only Flash is supported as of right now).\n+ * Highly experimental.\n+ */\n+class HTMLPurifier_HTMLModule_SafeObject extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'SafeObject';\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        // These definitions are not intrinsically safe: the attribute transforms\n+        // are a vital part of ensuring safety.\n+\n+        $max = $config->get('HTML.MaxImgLength');\n+        $object = $this->addElement(\n+            'object',\n+            'Inline',\n+            'Optional: param | Flow | #PCDATA',\n+            'Common',\n+            array(\n+                // While technically not required by the spec, we're forcing\n+                // it to this value.\n+                'type' => 'Enum#application/x-shockwave-flash',\n+                'width' => 'Pixels#' . $max,\n+                'height' => 'Pixels#' . $max,\n+                'data' => 'URI#embedded',\n+                'codebase' => new HTMLPurifier_AttrDef_Enum(\n+                    array(\n+                        'http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0'\n+                    )\n+                ),\n+            )\n+        );\n+        $object->attr_transform_post[] = new HTMLPurifier_AttrTransform_SafeObject();\n+\n+        $param = $this->addElement(\n+            'param',\n+            false,\n+            'Empty',\n+            false,\n+            array(\n+                'id' => 'ID',\n+                'name*' => 'Text',\n+                'value' => 'Text'\n+            )\n+        );\n+        $param->attr_transform_post[] = new HTMLPurifier_AttrTransform_SafeParam();\n+        $this->info_injector[] = 'SafeObject';\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/SafeScripting.php",
          "status": "added",
          "additions": 40,
          "deletions": 0,
          "patch": "@@ -0,0 +1,40 @@\n+<?php\n+\n+/**\n+ * A \"safe\" script module. No inline JS is allowed, and pointed to JS\n+ * files must match whitelist.\n+ */\n+class HTMLPurifier_HTMLModule_SafeScripting extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'SafeScripting';\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        // These definitions are not intrinsically safe: the attribute transforms\n+        // are a vital part of ensuring safety.\n+\n+        $allowed = $config->get('HTML.SafeScripting');\n+        $script = $this->addElement(\n+            'script',\n+            'Inline',\n+            'Empty',\n+            null,\n+            array(\n+                // While technically not required by the spec, we're forcing\n+                // it to this value.\n+                'type' => 'Enum#text/javascript',\n+                'src*' => new HTMLPurifier_AttrDef_Enum(array_keys($allowed))\n+            )\n+        );\n+        $script->attr_transform_pre[] =\n+        $script->attr_transform_post[] = new HTMLPurifier_AttrTransform_ScriptRequired();\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Scripting.php",
          "status": "added",
          "additions": 73,
          "deletions": 0,
          "patch": "@@ -0,0 +1,73 @@\n+<?php\n+\n+/*\n+\n+WARNING: THIS MODULE IS EXTREMELY DANGEROUS AS IT ENABLES INLINE SCRIPTING\n+INSIDE HTML PURIFIER DOCUMENTS. USE ONLY WITH TRUSTED USER INPUT!!!\n+\n+*/\n+\n+/**\n+ * XHTML 1.1 Scripting module, defines elements that are used to contain\n+ * information pertaining to executable scripts or the lack of support\n+ * for executable scripts.\n+ * @note This module does not contain inline scripting elements\n+ */\n+class HTMLPurifier_HTMLModule_Scripting extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Scripting';\n+\n+    /**\n+     * @type array\n+     */\n+    public $elements = array('script', 'noscript');\n+\n+    /**\n+     * @type array\n+     */\n+    public $content_sets = array('Block' => 'script | noscript', 'Inline' => 'script | noscript');\n+\n+    /**\n+     * @type bool\n+     */\n+    public $safe = false;\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        // TODO: create custom child-definition for noscript that\n+        // auto-wraps stray #PCDATA in a similar manner to\n+        // blockquote's custom definition (we would use it but\n+        // blockquote's contents are optional while noscript's contents\n+        // are required)\n+\n+        // TODO: convert this to new syntax, main problem is getting\n+        // both content sets working\n+\n+        // In theory, this could be safe, but I don't see any reason to\n+        // allow it.\n+        $this->info['noscript'] = new HTMLPurifier_ElementDef();\n+        $this->info['noscript']->attr = array(0 => array('Common'));\n+        $this->info['noscript']->content_model = 'Heading | List | Block';\n+        $this->info['noscript']->content_model_type = 'required';\n+\n+        $this->info['script'] = new HTMLPurifier_ElementDef();\n+        $this->info['script']->attr = array(\n+            'defer' => new HTMLPurifier_AttrDef_Enum(array('defer')),\n+            'src' => new HTMLPurifier_AttrDef_URI(true),\n+            'type' => new HTMLPurifier_AttrDef_Enum(array('text/javascript'))\n+        );\n+        $this->info['script']->content_model = '#PCDATA';\n+        $this->info['script']->content_model_type = 'optional';\n+        $this->info['script']->attr_transform_pre[] =\n+        $this->info['script']->attr_transform_post[] =\n+            new HTMLPurifier_AttrTransform_ScriptRequired();\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/StyleAttribute.php",
          "status": "added",
          "additions": 33,
          "deletions": 0,
          "patch": "@@ -0,0 +1,33 @@\n+<?php\n+\n+/**\n+ * XHTML 1.1 Edit Module, defines editing-related elements. Text Extension\n+ * Module.\n+ */\n+class HTMLPurifier_HTMLModule_StyleAttribute extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'StyleAttribute';\n+\n+    /**\n+     * @type array\n+     */\n+    public $attr_collections = array(\n+        // The inclusion routine differs from the Abstract Modules but\n+        // is in line with the DTD and XML Schemas.\n+        'Style' => array('style' => false), // see constructor\n+        'Core' => array(0 => array('Style'))\n+    );\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $this->attr_collections['Style']['style'] = new HTMLPurifier_AttrDef_CSS();\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Tables.php",
          "status": "added",
          "additions": 75,
          "deletions": 0,
          "patch": "@@ -0,0 +1,75 @@\n+<?php\n+\n+/**\n+ * XHTML 1.1 Tables Module, fully defines accessible table elements.\n+ */\n+class HTMLPurifier_HTMLModule_Tables extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Tables';\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $this->addElement('caption', false, 'Inline', 'Common');\n+\n+        $this->addElement(\n+            'table',\n+            'Block',\n+            new HTMLPurifier_ChildDef_Table(),\n+            'Common',\n+            array(\n+                'border' => 'Pixels',\n+                'cellpadding' => 'Length',\n+                'cellspacing' => 'Length',\n+                'frame' => 'Enum#void,above,below,hsides,lhs,rhs,vsides,box,border',\n+                'rules' => 'Enum#none,groups,rows,cols,all',\n+                'summary' => 'Text',\n+                'width' => 'Length'\n+            )\n+        );\n+\n+        // common attributes\n+        $cell_align = array(\n+            'align' => 'Enum#left,center,right,justify,char',\n+            'charoff' => 'Length',\n+            'valign' => 'Enum#top,middle,bottom,baseline',\n+        );\n+\n+        $cell_t = array_merge(\n+            array(\n+                'abbr' => 'Text',\n+                'colspan' => 'Number',\n+                'rowspan' => 'Number',\n+                // Apparently, as of HTML5 this attribute only applies\n+                // to 'th' elements.\n+                'scope' => 'Enum#row,col,rowgroup,colgroup',\n+            ),\n+            $cell_align\n+        );\n+        $this->addElement('td', false, 'Flow', 'Common', $cell_t);\n+        $this->addElement('th', false, 'Flow', 'Common', $cell_t);\n+\n+        $this->addElement('tr', false, 'Required: td | th', 'Common', $cell_align);\n+\n+        $cell_col = array_merge(\n+            array(\n+                'span' => 'Number',\n+                'width' => 'MultiLength',\n+            ),\n+            $cell_align\n+        );\n+        $this->addElement('col', false, 'Empty', 'Common', $cell_col);\n+        $this->addElement('colgroup', false, 'Optional: col', 'Common', $cell_col);\n+\n+        $this->addElement('tbody', false, 'Required: tr', 'Common', $cell_align);\n+        $this->addElement('thead', false, 'Required: tr', 'Common', $cell_align);\n+        $this->addElement('tfoot', false, 'Required: tr', 'Common', $cell_align);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Target.php",
          "status": "added",
          "additions": 28,
          "deletions": 0,
          "patch": "@@ -0,0 +1,28 @@\n+<?php\n+\n+/**\n+ * XHTML 1.1 Target Module, defines target attribute in link elements.\n+ */\n+class HTMLPurifier_HTMLModule_Target extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Target';\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $elements = array('a');\n+        foreach ($elements as $name) {\n+            $e = $this->addBlankElement($name);\n+            $e->attr = array(\n+                'target' => new HTMLPurifier_AttrDef_HTML_FrameTarget()\n+            );\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/TargetBlank.php",
          "status": "added",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -0,0 +1,24 @@\n+<?php\n+\n+/**\n+ * Module adds the target=blank attribute transformation to a tags.  It\n+ * is enabled by HTML.TargetBlank\n+ */\n+class HTMLPurifier_HTMLModule_TargetBlank extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'TargetBlank';\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $a = $this->addBlankElement('a');\n+        $a->attr_transform_post[] = new HTMLPurifier_AttrTransform_TargetBlank();\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/TargetNoreferrer.php",
          "status": "added",
          "additions": 21,
          "deletions": 0,
          "patch": "@@ -0,0 +1,21 @@\n+<?php\n+\n+/**\n+ * Module adds the target-based noreferrer attribute transformation to a tags.  It\n+ * is enabled by HTML.TargetNoreferrer\n+ */\n+class HTMLPurifier_HTMLModule_TargetNoreferrer extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'TargetNoreferrer';\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config) {\n+        $a = $this->addBlankElement('a');\n+        $a->attr_transform_post[] = new HTMLPurifier_AttrTransform_TargetNoreferrer();\n+    }\n+}"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Text.php",
          "status": "added",
          "additions": 87,
          "deletions": 0,
          "patch": "@@ -0,0 +1,87 @@\n+<?php\n+\n+/**\n+ * XHTML 1.1 Text Module, defines basic text containers. Core Module.\n+ * @note In the normative XML Schema specification, this module\n+ *       is further abstracted into the following modules:\n+ *          - Block Phrasal (address, blockquote, pre, h1, h2, h3, h4, h5, h6)\n+ *          - Block Structural (div, p)\n+ *          - Inline Phrasal (abbr, acronym, cite, code, dfn, em, kbd, q, samp, strong, var)\n+ *          - Inline Structural (br, span)\n+ *       This module, functionally, does not distinguish between these\n+ *       sub-modules, but the code is internally structured to reflect\n+ *       these distinctions.\n+ */\n+class HTMLPurifier_HTMLModule_Text extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Text';\n+\n+    /**\n+     * @type array\n+     */\n+    public $content_sets = array(\n+        'Flow' => 'Heading | Block | Inline'\n+    );\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        // Inline Phrasal -------------------------------------------------\n+        $this->addElement('abbr', 'Inline', 'Inline', 'Common');\n+        $this->addElement('acronym', 'Inline', 'Inline', 'Common');\n+        $this->addElement('cite', 'Inline', 'Inline', 'Common');\n+        $this->addElement('dfn', 'Inline', 'Inline', 'Common');\n+        $this->addElement('kbd', 'Inline', 'Inline', 'Common');\n+        $this->addElement('q', 'Inline', 'Inline', 'Common', array('cite' => 'URI'));\n+        $this->addElement('samp', 'Inline', 'Inline', 'Common');\n+        $this->addElement('var', 'Inline', 'Inline', 'Common');\n+\n+        $em = $this->addElement('em', 'Inline', 'Inline', 'Common');\n+        $em->formatting = true;\n+\n+        $strong = $this->addElement('strong', 'Inline', 'Inline', 'Common');\n+        $strong->formatting = true;\n+\n+        $code = $this->addElement('code', 'Inline', 'Inline', 'Common');\n+        $code->formatting = true;\n+\n+        // Inline Structural ----------------------------------------------\n+        $this->addElement('span', 'Inline', 'Inline', 'Common');\n+        $this->addElement('br', 'Inline', 'Empty', 'Core');\n+\n+        // Block Phrasal --------------------------------------------------\n+        $this->addElement('address', 'Block', 'Inline', 'Common');\n+        $this->addElement('blockquote', 'Block', 'Optional: Heading | Block | List', 'Common', array('cite' => 'URI'));\n+        $pre = $this->addElement('pre', 'Block', 'Inline', 'Common');\n+        $pre->excludes = $this->makeLookup(\n+            'img',\n+            'big',\n+            'small',\n+            'object',\n+            'applet',\n+            'font',\n+            'basefont'\n+        );\n+        $this->addElement('h1', 'Heading', 'Inline', 'Common');\n+        $this->addElement('h2', 'Heading', 'Inline', 'Common');\n+        $this->addElement('h3', 'Heading', 'Inline', 'Common');\n+        $this->addElement('h4', 'Heading', 'Inline', 'Common');\n+        $this->addElement('h5', 'Heading', 'Inline', 'Common');\n+        $this->addElement('h6', 'Heading', 'Inline', 'Common');\n+\n+        // Block Structural -----------------------------------------------\n+        $p = $this->addElement('p', 'Block', 'Inline', 'Common');\n+        $p->autoclose = array_flip(\n+            array(\"address\", \"blockquote\", \"center\", \"dir\", \"div\", \"dl\", \"fieldset\", \"ol\", \"p\", \"ul\")\n+        );\n+\n+        $this->addElement('div', 'Block', 'Flow', 'Common');\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Tidy.php",
          "status": "added",
          "additions": 230,
          "deletions": 0,
          "patch": "@@ -0,0 +1,230 @@\n+<?php\n+\n+/**\n+ * Abstract class for a set of proprietary modules that clean up (tidy)\n+ * poorly written HTML.\n+ * @todo Figure out how to protect some of these methods/properties\n+ */\n+class HTMLPurifier_HTMLModule_Tidy extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * List of supported levels.\n+     * Index zero is a special case \"no fixes\" level.\n+     * @type array\n+     */\n+    public $levels = array(0 => 'none', 'light', 'medium', 'heavy');\n+\n+    /**\n+     * Default level to place all fixes in.\n+     * Disabled by default.\n+     * @type string\n+     */\n+    public $defaultLevel = null;\n+\n+    /**\n+     * Lists of fixes used by getFixesForLevel().\n+     * Format is:\n+     *      HTMLModule_Tidy->fixesForLevel[$level] = array('fix-1', 'fix-2');\n+     * @type array\n+     */\n+    public $fixesForLevel = array(\n+        'light' => array(),\n+        'medium' => array(),\n+        'heavy' => array()\n+    );\n+\n+    /**\n+     * Lazy load constructs the module by determining the necessary\n+     * fixes to create and then delegating to the populate() function.\n+     * @param HTMLPurifier_Config $config\n+     * @todo Wildcard matching and error reporting when an added or\n+     *       subtracted fix has no effect.\n+     */\n+    public function setup($config)\n+    {\n+        // create fixes, initialize fixesForLevel\n+        $fixes = $this->makeFixes();\n+        $this->makeFixesForLevel($fixes);\n+\n+        // figure out which fixes to use\n+        $level = $config->get('HTML.TidyLevel');\n+        $fixes_lookup = $this->getFixesForLevel($level);\n+\n+        // get custom fix declarations: these need namespace processing\n+        $add_fixes = $config->get('HTML.TidyAdd');\n+        $remove_fixes = $config->get('HTML.TidyRemove');\n+\n+        foreach ($fixes as $name => $fix) {\n+            // needs to be refactored a little to implement globbing\n+            if (isset($remove_fixes[$name]) ||\n+                (!isset($add_fixes[$name]) && !isset($fixes_lookup[$name]))) {\n+                unset($fixes[$name]);\n+            }\n+        }\n+\n+        // populate this module with necessary fixes\n+        $this->populate($fixes);\n+    }\n+\n+    /**\n+     * Retrieves all fixes per a level, returning fixes for that specific\n+     * level as well as all levels below it.\n+     * @param string $level level identifier, see $levels for valid values\n+     * @return array Lookup up table of fixes\n+     */\n+    public function getFixesForLevel($level)\n+    {\n+        if ($level == $this->levels[0]) {\n+            return array();\n+        }\n+        $activated_levels = array();\n+        for ($i = 1, $c = count($this->levels); $i < $c; $i++) {\n+            $activated_levels[] = $this->levels[$i];\n+            if ($this->levels[$i] == $level) {\n+                break;\n+            }\n+        }\n+        if ($i == $c) {\n+            trigger_error(\n+                'Tidy level ' . htmlspecialchars($level) . ' not recognized',\n+                E_USER_WARNING\n+            );\n+            return array();\n+        }\n+        $ret = array();\n+        foreach ($activated_levels as $level) {\n+            foreach ($this->fixesForLevel[$level] as $fix) {\n+                $ret[$fix] = true;\n+            }\n+        }\n+        return $ret;\n+    }\n+\n+    /**\n+     * Dynamically populates the $fixesForLevel member variable using\n+     * the fixes array. It may be custom overloaded, used in conjunction\n+     * with $defaultLevel, or not used at all.\n+     * @param array $fixes\n+     */\n+    public function makeFixesForLevel($fixes)\n+    {\n+        if (!isset($this->defaultLevel)) {\n+            return;\n+        }\n+        if (!isset($this->fixesForLevel[$this->defaultLevel])) {\n+            trigger_error(\n+                'Default level ' . $this->defaultLevel . ' does not exist',\n+                E_USER_ERROR\n+            );\n+            return;\n+        }\n+        $this->fixesForLevel[$this->defaultLevel] = array_keys($fixes);\n+    }\n+\n+    /**\n+     * Populates the module with transforms and other special-case code\n+     * based on a list of fixes passed to it\n+     * @param array $fixes Lookup table of fixes to activate\n+     */\n+    public function populate($fixes)\n+    {\n+        foreach ($fixes as $name => $fix) {\n+            // determine what the fix is for\n+            list($type, $params) = $this->getFixType($name);\n+            switch ($type) {\n+                case 'attr_transform_pre':\n+                case 'attr_transform_post':\n+                    $attr = $params['attr'];\n+                    if (isset($params['element'])) {\n+                        $element = $params['element'];\n+                        if (empty($this->info[$element])) {\n+                            $e = $this->addBlankElement($element);\n+                        } else {\n+                            $e = $this->info[$element];\n+                        }\n+                    } else {\n+                        $type = \"info_$type\";\n+                        $e = $this;\n+                    }\n+                    // PHP does some weird parsing when I do\n+                    // $e->$type[$attr], so I have to assign a ref.\n+                    $f =& $e->$type;\n+                    $f[$attr] = $fix;\n+                    break;\n+                case 'tag_transform':\n+                    $this->info_tag_transform[$params['element']] = $fix;\n+                    break;\n+                case 'child':\n+                case 'content_model_type':\n+                    $element = $params['element'];\n+                    if (empty($this->info[$element])) {\n+                        $e = $this->addBlankElement($element);\n+                    } else {\n+                        $e = $this->info[$element];\n+                    }\n+                    $e->$type = $fix;\n+                    break;\n+                default:\n+                    trigger_error(\"Fix type $type not supported\", E_USER_ERROR);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parses a fix name and determines what kind of fix it is, as well\n+     * as other information defined by the fix\n+     * @param $name String name of fix\n+     * @return array(string $fix_type, array $fix_parameters)\n+     * @note $fix_parameters is type dependant, see populate() for usage\n+     *       of these parameters\n+     */\n+    public function getFixType($name)\n+    {\n+        // parse it\n+        $property = $attr = null;\n+        if (strpos($name, '#') !== false) {\n+            list($name, $property) = explode('#', $name);\n+        }\n+        if (strpos($name, '@') !== false) {\n+            list($name, $attr) = explode('@', $name);\n+        }\n+\n+        // figure out the parameters\n+        $params = array();\n+        if ($name !== '') {\n+            $params['element'] = $name;\n+        }\n+        if (!is_null($attr)) {\n+            $params['attr'] = $attr;\n+        }\n+\n+        // special case: attribute transform\n+        if (!is_null($attr)) {\n+            if (is_null($property)) {\n+                $property = 'pre';\n+            }\n+            $type = 'attr_transform_' . $property;\n+            return array($type, $params);\n+        }\n+\n+        // special case: tag transform\n+        if (is_null($property)) {\n+            return array('tag_transform', $params);\n+        }\n+\n+        return array($property, $params);\n+\n+    }\n+\n+    /**\n+     * Defines all fixes the module will perform in a compact\n+     * associative array of fix name to fix implementation.\n+     * @return array\n+     */\n+    public function makeFixes()\n+    {\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Tidy/Name.php",
          "status": "added",
          "additions": 33,
          "deletions": 0,
          "patch": "@@ -0,0 +1,33 @@\n+<?php\n+\n+/**\n+ * Name is deprecated, but allowed in strict doctypes, so onl\n+ */\n+class HTMLPurifier_HTMLModule_Tidy_Name extends HTMLPurifier_HTMLModule_Tidy\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Tidy_Name';\n+\n+    /**\n+     * @type string\n+     */\n+    public $defaultLevel = 'heavy';\n+\n+    /**\n+     * @return array\n+     */\n+    public function makeFixes()\n+    {\n+        $r = array();\n+        // @name for img, a -----------------------------------------------\n+        // Technically, it's allowed even on strict, so we allow authors to use\n+        // it. However, it's deprecated in future versions of XHTML.\n+        $r['img@name'] =\n+        $r['a@name'] = new HTMLPurifier_AttrTransform_Name();\n+        return $r;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Tidy/Proprietary.php",
          "status": "added",
          "additions": 34,
          "deletions": 0,
          "patch": "@@ -0,0 +1,34 @@\n+<?php\n+\n+class HTMLPurifier_HTMLModule_Tidy_Proprietary extends HTMLPurifier_HTMLModule_Tidy\n+{\n+\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Tidy_Proprietary';\n+\n+    /**\n+     * @type string\n+     */\n+    public $defaultLevel = 'light';\n+\n+    /**\n+     * @return array\n+     */\n+    public function makeFixes()\n+    {\n+        $r = array();\n+        $r['table@background'] = new HTMLPurifier_AttrTransform_Background();\n+        $r['td@background']    = new HTMLPurifier_AttrTransform_Background();\n+        $r['th@background']    = new HTMLPurifier_AttrTransform_Background();\n+        $r['tr@background']    = new HTMLPurifier_AttrTransform_Background();\n+        $r['thead@background'] = new HTMLPurifier_AttrTransform_Background();\n+        $r['tfoot@background'] = new HTMLPurifier_AttrTransform_Background();\n+        $r['tbody@background'] = new HTMLPurifier_AttrTransform_Background();\n+        $r['table@height']     = new HTMLPurifier_AttrTransform_Length('height');\n+        return $r;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Tidy/Strict.php",
          "status": "added",
          "additions": 43,
          "deletions": 0,
          "patch": "@@ -0,0 +1,43 @@\n+<?php\n+\n+class HTMLPurifier_HTMLModule_Tidy_Strict extends HTMLPurifier_HTMLModule_Tidy_XHTMLAndHTML4\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Tidy_Strict';\n+\n+    /**\n+     * @type string\n+     */\n+    public $defaultLevel = 'light';\n+\n+    /**\n+     * @return array\n+     */\n+    public function makeFixes()\n+    {\n+        $r = parent::makeFixes();\n+        $r['blockquote#content_model_type'] = 'strictblockquote';\n+        return $r;\n+    }\n+\n+    /**\n+     * @type bool\n+     */\n+    public $defines_child_def = true;\n+\n+    /**\n+     * @param HTMLPurifier_ElementDef $def\n+     * @return HTMLPurifier_ChildDef_StrictBlockquote\n+     */\n+    public function getChildDef($def)\n+    {\n+        if ($def->content_model_type != 'strictblockquote') {\n+            return parent::getChildDef($def);\n+        }\n+        return new HTMLPurifier_ChildDef_StrictBlockquote($def->content_model);\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Tidy/Transitional.php",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+<?php\n+\n+class HTMLPurifier_HTMLModule_Tidy_Transitional extends HTMLPurifier_HTMLModule_Tidy_XHTMLAndHTML4\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Tidy_Transitional';\n+\n+    /**\n+     * @type string\n+     */\n+    public $defaultLevel = 'heavy';\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Tidy/XHTML.php",
          "status": "added",
          "additions": 26,
          "deletions": 0,
          "patch": "@@ -0,0 +1,26 @@\n+<?php\n+\n+class HTMLPurifier_HTMLModule_Tidy_XHTML extends HTMLPurifier_HTMLModule_Tidy\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Tidy_XHTML';\n+\n+    /**\n+     * @type string\n+     */\n+    public $defaultLevel = 'medium';\n+\n+    /**\n+     * @return array\n+     */\n+    public function makeFixes()\n+    {\n+        $r = array();\n+        $r['@lang'] = new HTMLPurifier_AttrTransform_Lang();\n+        return $r;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/Tidy/XHTMLAndHTML4.php",
          "status": "added",
          "additions": 179,
          "deletions": 0,
          "patch": "@@ -0,0 +1,179 @@\n+<?php\n+\n+class HTMLPurifier_HTMLModule_Tidy_XHTMLAndHTML4 extends HTMLPurifier_HTMLModule_Tidy\n+{\n+\n+    /**\n+     * @return array\n+     */\n+    public function makeFixes()\n+    {\n+        $r = array();\n+\n+        // == deprecated tag transforms ===================================\n+\n+        $r['font'] = new HTMLPurifier_TagTransform_Font();\n+        $r['menu'] = new HTMLPurifier_TagTransform_Simple('ul');\n+        $r['dir'] = new HTMLPurifier_TagTransform_Simple('ul');\n+        $r['center'] = new HTMLPurifier_TagTransform_Simple('div', 'text-align:center;');\n+        $r['u'] = new HTMLPurifier_TagTransform_Simple('span', 'text-decoration:underline;');\n+        $r['s'] = new HTMLPurifier_TagTransform_Simple('span', 'text-decoration:line-through;');\n+        $r['strike'] = new HTMLPurifier_TagTransform_Simple('span', 'text-decoration:line-through;');\n+\n+        // == deprecated attribute transforms =============================\n+\n+        $r['caption@align'] =\n+            new HTMLPurifier_AttrTransform_EnumToCSS(\n+                'align',\n+                array(\n+                    // we're following IE's behavior, not Firefox's, due\n+                    // to the fact that no one supports caption-side:right,\n+                    // W3C included (with CSS 2.1). This is a slightly\n+                    // unreasonable attribute!\n+                    'left' => 'text-align:left;',\n+                    'right' => 'text-align:right;',\n+                    'top' => 'caption-side:top;',\n+                    'bottom' => 'caption-side:bottom;' // not supported by IE\n+                )\n+            );\n+\n+        // @align for img -------------------------------------------------\n+        $r['img@align'] =\n+            new HTMLPurifier_AttrTransform_EnumToCSS(\n+                'align',\n+                array(\n+                    'left' => 'float:left;',\n+                    'right' => 'float:right;',\n+                    'top' => 'vertical-align:top;',\n+                    'middle' => 'vertical-align:middle;',\n+                    'bottom' => 'vertical-align:baseline;',\n+                )\n+            );\n+\n+        // @align for table -----------------------------------------------\n+        $r['table@align'] =\n+            new HTMLPurifier_AttrTransform_EnumToCSS(\n+                'align',\n+                array(\n+                    'left' => 'float:left;',\n+                    'center' => 'margin-left:auto;margin-right:auto;',\n+                    'right' => 'float:right;'\n+                )\n+            );\n+\n+        // @align for hr -----------------------------------------------\n+        $r['hr@align'] =\n+            new HTMLPurifier_AttrTransform_EnumToCSS(\n+                'align',\n+                array(\n+                    // we use both text-align and margin because these work\n+                    // for different browsers (IE and Firefox, respectively)\n+                    // and the melange makes for a pretty cross-compatible\n+                    // solution\n+                    'left' => 'margin-left:0;margin-right:auto;text-align:left;',\n+                    'center' => 'margin-left:auto;margin-right:auto;text-align:center;',\n+                    'right' => 'margin-left:auto;margin-right:0;text-align:right;'\n+                )\n+            );\n+\n+        // @align for h1, h2, h3, h4, h5, h6, p, div ----------------------\n+        // {{{\n+        $align_lookup = array();\n+        $align_values = array('left', 'right', 'center', 'justify');\n+        foreach ($align_values as $v) {\n+            $align_lookup[$v] = \"text-align:$v;\";\n+        }\n+        // }}}\n+        $r['h1@align'] =\n+        $r['h2@align'] =\n+        $r['h3@align'] =\n+        $r['h4@align'] =\n+        $r['h5@align'] =\n+        $r['h6@align'] =\n+        $r['p@align'] =\n+        $r['div@align'] =\n+            new HTMLPurifier_AttrTransform_EnumToCSS('align', $align_lookup);\n+\n+        // @bgcolor for table, tr, td, th ---------------------------------\n+        $r['table@bgcolor'] =\n+        $r['td@bgcolor'] =\n+        $r['th@bgcolor'] =\n+            new HTMLPurifier_AttrTransform_BgColor();\n+\n+        // @border for img ------------------------------------------------\n+        $r['img@border'] = new HTMLPurifier_AttrTransform_Border();\n+\n+        // @clear for br --------------------------------------------------\n+        $r['br@clear'] =\n+            new HTMLPurifier_AttrTransform_EnumToCSS(\n+                'clear',\n+                array(\n+                    'left' => 'clear:left;',\n+                    'right' => 'clear:right;',\n+                    'all' => 'clear:both;',\n+                    'none' => 'clear:none;',\n+                )\n+            );\n+\n+        // @height for td, th ---------------------------------------------\n+        $r['td@height'] =\n+        $r['th@height'] =\n+            new HTMLPurifier_AttrTransform_Length('height');\n+\n+        // @hspace for img ------------------------------------------------\n+        $r['img@hspace'] = new HTMLPurifier_AttrTransform_ImgSpace('hspace');\n+\n+        // @noshade for hr ------------------------------------------------\n+        // this transformation is not precise but often good enough.\n+        // different browsers use different styles to designate noshade\n+        $r['hr@noshade'] =\n+            new HTMLPurifier_AttrTransform_BoolToCSS(\n+                'noshade',\n+                'color:#808080;background-color:#808080;border:0;'\n+            );\n+\n+        // @nowrap for td, th ---------------------------------------------\n+        $r['td@nowrap'] =\n+        $r['th@nowrap'] =\n+            new HTMLPurifier_AttrTransform_BoolToCSS(\n+                'nowrap',\n+                'white-space:nowrap;'\n+            );\n+\n+        // @size for hr  --------------------------------------------------\n+        $r['hr@size'] = new HTMLPurifier_AttrTransform_Length('size', 'height');\n+\n+        // @type for li, ol, ul -------------------------------------------\n+        // {{{\n+        $ul_types = array(\n+            'disc' => 'list-style-type:disc;',\n+            'square' => 'list-style-type:square;',\n+            'circle' => 'list-style-type:circle;'\n+        );\n+        $ol_types = array(\n+            '1' => 'list-style-type:decimal;',\n+            'i' => 'list-style-type:lower-roman;',\n+            'I' => 'list-style-type:upper-roman;',\n+            'a' => 'list-style-type:lower-alpha;',\n+            'A' => 'list-style-type:upper-alpha;'\n+        );\n+        $li_types = $ul_types + $ol_types;\n+        // }}}\n+\n+        $r['ul@type'] = new HTMLPurifier_AttrTransform_EnumToCSS('type', $ul_types);\n+        $r['ol@type'] = new HTMLPurifier_AttrTransform_EnumToCSS('type', $ol_types, true);\n+        $r['li@type'] = new HTMLPurifier_AttrTransform_EnumToCSS('type', $li_types, true);\n+\n+        // @vspace for img ------------------------------------------------\n+        $r['img@vspace'] = new HTMLPurifier_AttrTransform_ImgSpace('vspace');\n+\n+        // @width for hr, td, th ------------------------------------------\n+        $r['td@width'] =\n+        $r['th@width'] =\n+        $r['hr@width'] = new HTMLPurifier_AttrTransform_Length('width');\n+\n+        return $r;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModule/XMLCommonAttributes.php",
          "status": "added",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -0,0 +1,20 @@\n+<?php\n+\n+class HTMLPurifier_HTMLModule_XMLCommonAttributes extends HTMLPurifier_HTMLModule\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'XMLCommonAttributes';\n+\n+    /**\n+     * @type array\n+     */\n+    public $attr_collections = array(\n+        'Lang' => array(\n+            'xml:lang' => 'LanguageCode',\n+        )\n+    );\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/HTMLModuleManager.php",
          "status": "added",
          "additions": 464,
          "deletions": 0,
          "patch": "@@ -0,0 +1,464 @@\n+<?php\n+\n+class HTMLPurifier_HTMLModuleManager\n+{\n+\n+    /**\n+     * @type HTMLPurifier_DoctypeRegistry\n+     */\n+    public $doctypes;\n+\n+    /**\n+     * Instance of current doctype.\n+     * @type string\n+     */\n+    public $doctype;\n+\n+    /**\n+     * @type HTMLPurifier_AttrTypes\n+     */\n+    public $attrTypes;\n+\n+    /**\n+     * Active instances of modules for the specified doctype are\n+     * indexed, by name, in this array.\n+     * @type HTMLPurifier_HTMLModule[]\n+     */\n+    public $modules = array();\n+\n+    /**\n+     * Array of recognized HTMLPurifier_HTMLModule instances,\n+     * indexed by module's class name. This array is usually lazy loaded, but a\n+     * user can overload a module by pre-emptively registering it.\n+     * @type HTMLPurifier_HTMLModule[]\n+     */\n+    public $registeredModules = array();\n+\n+    /**\n+     * List of extra modules that were added by the user\n+     * using addModule(). These get unconditionally merged into the current doctype, whatever\n+     * it may be.\n+     * @type HTMLPurifier_HTMLModule[]\n+     */\n+    public $userModules = array();\n+\n+    /**\n+     * Associative array of element name to list of modules that have\n+     * definitions for the element; this array is dynamically filled.\n+     * @type array\n+     */\n+    public $elementLookup = array();\n+\n+    /**\n+     * List of prefixes we should use for registering small names.\n+     * @type array\n+     */\n+    public $prefixes = array('HTMLPurifier_HTMLModule_');\n+\n+    /**\n+     * @type HTMLPurifier_ContentSets\n+     */\n+    public $contentSets;\n+\n+    /**\n+     * @type HTMLPurifier_AttrCollections\n+     */\n+    public $attrCollections;\n+\n+    /**\n+     * If set to true, unsafe elements and attributes will be allowed.\n+     * @type bool\n+     */\n+    public $trusted = false;\n+\n+    public function __construct()\n+    {\n+        // editable internal objects\n+        $this->attrTypes = new HTMLPurifier_AttrTypes();\n+        $this->doctypes  = new HTMLPurifier_DoctypeRegistry();\n+\n+        // setup basic modules\n+        $common = array(\n+            'CommonAttributes', 'Text', 'Hypertext', 'List',\n+            'Presentation', 'Edit', 'Bdo', 'Tables', 'Image',\n+            'StyleAttribute',\n+            // Unsafe:\n+            'Scripting', 'Object', 'Forms',\n+            // Sorta legacy, but present in strict:\n+            'Name',\n+        );\n+        $transitional = array('Legacy', 'Target', 'Iframe');\n+        $xml = array('XMLCommonAttributes');\n+        $non_xml = array('NonXMLCommonAttributes');\n+\n+        // setup basic doctypes\n+        $this->doctypes->register(\n+            'HTML 4.01 Transitional',\n+            false,\n+            array_merge($common, $transitional, $non_xml),\n+            array('Tidy_Transitional', 'Tidy_Proprietary'),\n+            array(),\n+            '-//W3C//DTD HTML 4.01 Transitional//EN',\n+            'http://www.w3.org/TR/html4/loose.dtd'\n+        );\n+\n+        $this->doctypes->register(\n+            'HTML 4.01 Strict',\n+            false,\n+            array_merge($common, $non_xml),\n+            array('Tidy_Strict', 'Tidy_Proprietary', 'Tidy_Name'),\n+            array(),\n+            '-//W3C//DTD HTML 4.01//EN',\n+            'http://www.w3.org/TR/html4/strict.dtd'\n+        );\n+\n+        $this->doctypes->register(\n+            'XHTML 1.0 Transitional',\n+            true,\n+            array_merge($common, $transitional, $xml, $non_xml),\n+            array('Tidy_Transitional', 'Tidy_XHTML', 'Tidy_Proprietary', 'Tidy_Name'),\n+            array(),\n+            '-//W3C//DTD XHTML 1.0 Transitional//EN',\n+            'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'\n+        );\n+\n+        $this->doctypes->register(\n+            'XHTML 1.0 Strict',\n+            true,\n+            array_merge($common, $xml, $non_xml),\n+            array('Tidy_Strict', 'Tidy_XHTML', 'Tidy_Strict', 'Tidy_Proprietary', 'Tidy_Name'),\n+            array(),\n+            '-//W3C//DTD XHTML 1.0 Strict//EN',\n+            'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'\n+        );\n+\n+        $this->doctypes->register(\n+            'XHTML 1.1',\n+            true,\n+            // Iframe is a real XHTML 1.1 module, despite being\n+            // \"transitional\"!\n+            array_merge($common, $xml, array('Ruby', 'Iframe')),\n+            array('Tidy_Strict', 'Tidy_XHTML', 'Tidy_Proprietary', 'Tidy_Strict', 'Tidy_Name'), // Tidy_XHTML1_1\n+            array(),\n+            '-//W3C//DTD XHTML 1.1//EN',\n+            'http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd'\n+        );\n+\n+    }\n+\n+    /**\n+     * Registers a module to the recognized module list, useful for\n+     * overloading pre-existing modules.\n+     * @param $module Mixed: string module name, with or without\n+     *                HTMLPurifier_HTMLModule prefix, or instance of\n+     *                subclass of HTMLPurifier_HTMLModule.\n+     * @param $overload Boolean whether or not to overload previous modules.\n+     *                  If this is not set, and you do overload a module,\n+     *                  HTML Purifier will complain with a warning.\n+     * @note This function will not call autoload, you must instantiate\n+     *       (and thus invoke) autoload outside the method.\n+     * @note If a string is passed as a module name, different variants\n+     *       will be tested in this order:\n+     *          - Check for HTMLPurifier_HTMLModule_$name\n+     *          - Check all prefixes with $name in order they were added\n+     *          - Check for literal object name\n+     *          - Throw fatal error\n+     *       If your object name collides with an internal class, specify\n+     *       your module manually. All modules must have been included\n+     *       externally: registerModule will not perform inclusions for you!\n+     */\n+    public function registerModule($module, $overload = false)\n+    {\n+        if (is_string($module)) {\n+            // attempt to load the module\n+            $original_module = $module;\n+            $ok = false;\n+            foreach ($this->prefixes as $prefix) {\n+                $module = $prefix . $original_module;\n+                if (class_exists($module)) {\n+                    $ok = true;\n+                    break;\n+                }\n+            }\n+            if (!$ok) {\n+                $module = $original_module;\n+                if (!class_exists($module)) {\n+                    trigger_error(\n+                        $original_module . ' module does not exist',\n+                        E_USER_ERROR\n+                    );\n+                    return;\n+                }\n+            }\n+            $module = new $module();\n+        }\n+        if (empty($module->name)) {\n+            trigger_error('Module instance of ' . get_class($module) . ' must have name');\n+            return;\n+        }\n+        if (!$overload && isset($this->registeredModules[$module->name])) {\n+            trigger_error('Overloading ' . $module->name . ' without explicit overload parameter', E_USER_WARNING);\n+        }\n+        $this->registeredModules[$module->name] = $module;\n+    }\n+\n+    /**\n+     * Adds a module to the current doctype by first registering it,\n+     * and then tacking it on to the active doctype\n+     */\n+    public function addModule($module)\n+    {\n+        $this->registerModule($module);\n+        if (is_object($module)) {\n+            $module = $module->name;\n+        }\n+        $this->userModules[] = $module;\n+    }\n+\n+    /**\n+     * Adds a class prefix that registerModule() will use to resolve a\n+     * string name to a concrete class\n+     */\n+    public function addPrefix($prefix)\n+    {\n+        $this->prefixes[] = $prefix;\n+    }\n+\n+    /**\n+     * Performs processing on modules, after being called you may\n+     * use getElement() and getElements()\n+     * @param HTMLPurifier_Config $config\n+     */\n+    public function setup($config)\n+    {\n+        $this->trusted = $config->get('HTML.Trusted');\n+\n+        // generate\n+        $this->doctype = $this->doctypes->make($config);\n+        $modules = $this->doctype->modules;\n+\n+        // take out the default modules that aren't allowed\n+        $lookup = $config->get('HTML.AllowedModules');\n+        $special_cases = $config->get('HTML.CoreModules');\n+\n+        if (is_array($lookup)) {\n+            foreach ($modules as $k => $m) {\n+                if (isset($special_cases[$m])) {\n+                    continue;\n+                }\n+                if (!isset($lookup[$m])) {\n+                    unset($modules[$k]);\n+                }\n+            }\n+        }\n+\n+        // custom modules\n+        if ($config->get('HTML.Proprietary')) {\n+            $modules[] = 'Proprietary';\n+        }\n+        if ($config->get('HTML.SafeObject')) {\n+            $modules[] = 'SafeObject';\n+        }\n+        if ($config->get('HTML.SafeEmbed')) {\n+            $modules[] = 'SafeEmbed';\n+        }\n+        if ($config->get('HTML.SafeScripting') !== array()) {\n+            $modules[] = 'SafeScripting';\n+        }\n+        if ($config->get('HTML.Nofollow')) {\n+            $modules[] = 'Nofollow';\n+        }\n+        if ($config->get('HTML.TargetBlank')) {\n+            $modules[] = 'TargetBlank';\n+        }\n+        // NB: HTML.TargetNoreferrer must be AFTER HTML.TargetBlank\n+        // so that its post-attr-transform gets run afterwards.\n+        if ($config->get('HTML.TargetNoreferrer')) {\n+            $modules[] = 'TargetNoreferrer';\n+        }\n+\n+        // merge in custom modules\n+        $modules = array_merge($modules, $this->userModules);\n+\n+        foreach ($modules as $module) {\n+            $this->processModule($module);\n+            $this->modules[$module]->setup($config);\n+        }\n+\n+        foreach ($this->doctype->tidyModules as $module) {\n+            $this->processModule($module);\n+            $this->modules[$module]->setup($config);\n+        }\n+\n+        // prepare any injectors\n+        foreach ($this->modules as $module) {\n+            $n = array();\n+            foreach ($module->info_injector as $injector) {\n+                if (!is_object($injector)) {\n+                    $class = \"HTMLPurifier_Injector_$injector\";\n+                    $injector = new $class;\n+                }\n+                $n[$injector->name] = $injector;\n+            }\n+            $module->info_injector = $n;\n+        }\n+\n+        // setup lookup table based on all valid modules\n+        foreach ($this->modules as $module) {\n+            foreach ($module->info as $name => $def) {\n+                if (!isset($this->elementLookup[$name])) {\n+                    $this->elementLookup[$name] = array();\n+                }\n+                $this->elementLookup[$name][] = $module->name;\n+            }\n+        }\n+\n+        // note the different choice\n+        $this->contentSets = new HTMLPurifier_ContentSets(\n+            // content set assembly deals with all possible modules,\n+            // not just ones deemed to be \"safe\"\n+            $this->modules\n+        );\n+        $this->attrCollections = new HTMLPurifier_AttrCollections(\n+            $this->attrTypes,\n+            // there is no way to directly disable a global attribute,\n+            // but using AllowedAttributes or simply not including\n+            // the module in your custom doctype should be sufficient\n+            $this->modules\n+        );\n+    }\n+\n+    /**\n+     * Takes a module and adds it to the active module collection,\n+     * registering it if necessary.\n+     */\n+    public function processModule($module)\n+    {\n+        if (!isset($this->registeredModules[$module]) || is_object($module)) {\n+            $this->registerModule($module);\n+        }\n+        $this->modules[$module] = $this->registeredModules[$module];\n+    }\n+\n+    /**\n+     * Retrieves merged element definitions.\n+     * @return Array of HTMLPurifier_ElementDef\n+     */\n+    public function getElements()\n+    {\n+        $elements = array();\n+        foreach ($this->modules as $module) {\n+            if (!$this->trusted && !$module->safe) {\n+                continue;\n+            }\n+            foreach ($module->info as $name => $v) {\n+                if (isset($elements[$name])) {\n+                    continue;\n+                }\n+                $elements[$name] = $this->getElement($name);\n+            }\n+        }\n+\n+        // remove dud elements, this happens when an element that\n+        // appeared to be safe actually wasn't\n+        foreach ($elements as $n => $v) {\n+            if ($v === false) {\n+                unset($elements[$n]);\n+            }\n+        }\n+\n+        return $elements;\n+\n+    }\n+\n+    /**\n+     * Retrieves a single merged element definition\n+     * @param string $name Name of element\n+     * @param bool $trusted Boolean trusted overriding parameter: set to true\n+     *                 if you want the full version of an element\n+     * @return HTMLPurifier_ElementDef Merged HTMLPurifier_ElementDef\n+     * @note You may notice that modules are getting iterated over twice (once\n+     *       in getElements() and once here). This\n+     *       is because\n+     */\n+    public function getElement($name, $trusted = null)\n+    {\n+        if (!isset($this->elementLookup[$name])) {\n+            return false;\n+        }\n+\n+        // setup global state variables\n+        $def = false;\n+        if ($trusted === null) {\n+            $trusted = $this->trusted;\n+        }\n+\n+        // iterate through each module that has registered itself to this\n+        // element\n+        foreach ($this->elementLookup[$name] as $module_name) {\n+            $module = $this->modules[$module_name];\n+\n+            // refuse to create/merge from a module that is deemed unsafe--\n+            // pretend the module doesn't exist--when trusted mode is not on.\n+            if (!$trusted && !$module->safe) {\n+                continue;\n+            }\n+\n+            // clone is used because, ideally speaking, the original\n+            // definition should not be modified. Usually, this will\n+            // make no difference, but for consistency's sake\n+            $new_def = clone $module->info[$name];\n+\n+            if (!$def && $new_def->standalone) {\n+                $def = $new_def;\n+            } elseif ($def) {\n+                // This will occur even if $new_def is standalone. In practice,\n+                // this will usually result in a full replacement.\n+                $def->mergeIn($new_def);\n+            } else {\n+                // :TODO:\n+                // non-standalone definitions that don't have a standalone\n+                // to merge into could be deferred to the end\n+                // HOWEVER, it is perfectly valid for a non-standalone\n+                // definition to lack a standalone definition, even\n+                // after all processing: this allows us to safely\n+                // specify extra attributes for elements that may not be\n+                // enabled all in one place.  In particular, this might\n+                // be the case for trusted elements.  WARNING: care must\n+                // be taken that the /extra/ definitions are all safe.\n+                continue;\n+            }\n+\n+            // attribute value expansions\n+            $this->attrCollections->performInclusions($def->attr);\n+            $this->attrCollections->expandIdentifiers($def->attr, $this->attrTypes);\n+\n+            // descendants_are_inline, for ChildDef_Chameleon\n+            if (is_string($def->content_model) &&\n+                strpos($def->content_model, 'Inline') !== false) {\n+                if ($name != 'del' && $name != 'ins') {\n+                    // this is for you, ins/del\n+                    $def->descendants_are_inline = true;\n+                }\n+            }\n+\n+            $this->contentSets->generateChildDef($def, $module);\n+        }\n+\n+        // This can occur if there is a blank definition, but no base to\n+        // mix it in with\n+        if (!$def) {\n+            return false;\n+        }\n+\n+        // add information on required attributes\n+        foreach ($def->attr as $attr_name => $attr_def) {\n+            if ($attr_def->required) {\n+                $def->required_attr[] = $attr_name;\n+            }\n+        }\n+        return $def;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/IDAccumulator.php",
          "status": "added",
          "additions": 57,
          "deletions": 0,
          "patch": "@@ -0,0 +1,57 @@\n+<?php\n+\n+/**\n+ * Component of HTMLPurifier_AttrContext that accumulates IDs to prevent dupes\n+ * @note In Slashdot-speak, dupe means duplicate.\n+ * @note The default constructor does not accept $config or $context objects:\n+ *       use must use the static build() factory method to perform initialization.\n+ */\n+class HTMLPurifier_IDAccumulator\n+{\n+\n+    /**\n+     * Lookup table of IDs we've accumulated.\n+     * @public\n+     */\n+    public $ids = array();\n+\n+    /**\n+     * Builds an IDAccumulator, also initializing the default blacklist\n+     * @param HTMLPurifier_Config $config Instance of HTMLPurifier_Config\n+     * @param HTMLPurifier_Context $context Instance of HTMLPurifier_Context\n+     * @return HTMLPurifier_IDAccumulator Fully initialized HTMLPurifier_IDAccumulator\n+     */\n+    public static function build($config, $context)\n+    {\n+        $id_accumulator = new HTMLPurifier_IDAccumulator();\n+        $id_accumulator->load($config->get('Attr.IDBlacklist'));\n+        return $id_accumulator;\n+    }\n+\n+    /**\n+     * Add an ID to the lookup table.\n+     * @param string $id ID to be added.\n+     * @return bool status, true if success, false if there's a dupe\n+     */\n+    public function add($id)\n+    {\n+        if (isset($this->ids[$id])) {\n+            return false;\n+        }\n+        return $this->ids[$id] = true;\n+    }\n+\n+    /**\n+     * Load a list of IDs into the lookup table\n+     * @param $array_of_ids Array of IDs to load\n+     * @note This function doesn't care about duplicates\n+     */\n+    public function load($array_of_ids)\n+    {\n+        foreach ($array_of_ids as $id) {\n+            $this->ids[$id] = true;\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Injector.php",
          "status": "added",
          "additions": 281,
          "deletions": 0,
          "patch": "@@ -0,0 +1,281 @@\n+<?php\n+\n+/**\n+ * Injects tokens into the document while parsing for well-formedness.\n+ * This enables \"formatter-like\" functionality such as auto-paragraphing,\n+ * smiley-ification and linkification to take place.\n+ *\n+ * A note on how handlers create changes; this is done by assigning a new\n+ * value to the $token reference. These values can take a variety of forms and\n+ * are best described HTMLPurifier_Strategy_MakeWellFormed->processToken()\n+ * documentation.\n+ *\n+ * @todo Allow injectors to request a re-run on their output. This\n+ *       would help if an operation is recursive.\n+ */\n+abstract class HTMLPurifier_Injector\n+{\n+\n+    /**\n+     * Advisory name of injector, this is for friendly error messages.\n+     * @type string\n+     */\n+    public $name;\n+\n+    /**\n+     * @type HTMLPurifier_HTMLDefinition\n+     */\n+    protected $htmlDefinition;\n+\n+    /**\n+     * Reference to CurrentNesting variable in Context. This is an array\n+     * list of tokens that we are currently \"inside\"\n+     * @type array\n+     */\n+    protected $currentNesting;\n+\n+    /**\n+     * Reference to current token.\n+     * @type HTMLPurifier_Token\n+     */\n+    protected $currentToken;\n+\n+    /**\n+     * Reference to InputZipper variable in Context.\n+     * @type HTMLPurifier_Zipper\n+     */\n+    protected $inputZipper;\n+\n+    /**\n+     * Array of elements and attributes this injector creates and therefore\n+     * need to be allowed by the definition. Takes form of\n+     * array('element' => array('attr', 'attr2'), 'element2')\n+     * @type array\n+     */\n+    public $needed = array();\n+\n+    /**\n+     * Number of elements to rewind backwards (relative).\n+     * @type bool|int\n+     */\n+    protected $rewindOffset = false;\n+\n+    /**\n+     * Rewind to a spot to re-perform processing. This is useful if you\n+     * deleted a node, and now need to see if this change affected any\n+     * earlier nodes. Rewinding does not affect other injectors, and can\n+     * result in infinite loops if not used carefully.\n+     * @param bool|int $offset\n+     * @warning HTML Purifier will prevent you from fast-forwarding with this\n+     *          function.\n+     */\n+    public function rewindOffset($offset)\n+    {\n+        $this->rewindOffset = $offset;\n+    }\n+\n+    /**\n+     * Retrieves rewind offset, and then unsets it.\n+     * @return bool|int\n+     */\n+    public function getRewindOffset()\n+    {\n+        $r = $this->rewindOffset;\n+        $this->rewindOffset = false;\n+        return $r;\n+    }\n+\n+    /**\n+     * Prepares the injector by giving it the config and context objects:\n+     * this allows references to important variables to be made within\n+     * the injector. This function also checks if the HTML environment\n+     * will work with the Injector (see checkNeeded()).\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return bool|string Boolean false if success, string of missing needed element/attribute if failure\n+     */\n+    public function prepare($config, $context)\n+    {\n+        $this->htmlDefinition = $config->getHTMLDefinition();\n+        // Even though this might fail, some unit tests ignore this and\n+        // still test checkNeeded, so be careful. Maybe get rid of that\n+        // dependency.\n+        $result = $this->checkNeeded($config);\n+        if ($result !== false) {\n+            return $result;\n+        }\n+        $this->currentNesting =& $context->get('CurrentNesting');\n+        $this->currentToken   =& $context->get('CurrentToken');\n+        $this->inputZipper    =& $context->get('InputZipper');\n+        return false;\n+    }\n+\n+    /**\n+     * This function checks if the HTML environment\n+     * will work with the Injector: if p tags are not allowed, the\n+     * Auto-Paragraphing injector should not be enabled.\n+     * @param HTMLPurifier_Config $config\n+     * @return bool|string Boolean false if success, string of missing needed element/attribute if failure\n+     */\n+    public function checkNeeded($config)\n+    {\n+        $def = $config->getHTMLDefinition();\n+        foreach ($this->needed as $element => $attributes) {\n+            if (is_int($element)) {\n+                $element = $attributes;\n+            }\n+            if (!isset($def->info[$element])) {\n+                return $element;\n+            }\n+            if (!is_array($attributes)) {\n+                continue;\n+            }\n+            foreach ($attributes as $name) {\n+                if (!isset($def->info[$element]->attr[$name])) {\n+                    return \"$element.$name\";\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Tests if the context node allows a certain element\n+     * @param string $name Name of element to test for\n+     * @return bool True if element is allowed, false if it is not\n+     */\n+    public function allowsElement($name)\n+    {\n+        if (!empty($this->currentNesting)) {\n+            $parent_token = array_pop($this->currentNesting);\n+            $this->currentNesting[] = $parent_token;\n+            $parent = $this->htmlDefinition->info[$parent_token->name];\n+        } else {\n+            $parent = $this->htmlDefinition->info_parent_def;\n+        }\n+        if (!isset($parent->child->elements[$name]) || isset($parent->excludes[$name])) {\n+            return false;\n+        }\n+        // check for exclusion\n+        for ($i = count($this->currentNesting) - 2; $i >= 0; $i--) {\n+            $node = $this->currentNesting[$i];\n+            $def  = $this->htmlDefinition->info[$node->name];\n+            if (isset($def->excludes[$name])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Iterator function, which starts with the next token and continues until\n+     * you reach the end of the input tokens.\n+     * @warning Please prevent previous references from interfering with this\n+     *          functions by setting $i = null beforehand!\n+     * @param int $i Current integer index variable for inputTokens\n+     * @param HTMLPurifier_Token $current Current token variable.\n+     *          Do NOT use $token, as that variable is also a reference\n+     * @return bool\n+     */\n+    protected function forward(&$i, &$current)\n+    {\n+        if ($i === null) {\n+            $i = count($this->inputZipper->back) - 1;\n+        } else {\n+            $i--;\n+        }\n+        if ($i < 0) {\n+            return false;\n+        }\n+        $current = $this->inputZipper->back[$i];\n+        return true;\n+    }\n+\n+    /**\n+     * Similar to _forward, but accepts a third parameter $nesting (which\n+     * should be initialized at 0) and stops when we hit the end tag\n+     * for the node $this->inputIndex starts in.\n+     * @param int $i Current integer index variable for inputTokens\n+     * @param HTMLPurifier_Token $current Current token variable.\n+     *          Do NOT use $token, as that variable is also a reference\n+     * @param int $nesting\n+     * @return bool\n+     */\n+    protected function forwardUntilEndToken(&$i, &$current, &$nesting)\n+    {\n+        $result = $this->forward($i, $current);\n+        if (!$result) {\n+            return false;\n+        }\n+        if ($nesting === null) {\n+            $nesting = 0;\n+        }\n+        if ($current instanceof HTMLPurifier_Token_Start) {\n+            $nesting++;\n+        } elseif ($current instanceof HTMLPurifier_Token_End) {\n+            if ($nesting <= 0) {\n+                return false;\n+            }\n+            $nesting--;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Iterator function, starts with the previous token and continues until\n+     * you reach the beginning of input tokens.\n+     * @warning Please prevent previous references from interfering with this\n+     *          functions by setting $i = null beforehand!\n+     * @param int $i Current integer index variable for inputTokens\n+     * @param HTMLPurifier_Token $current Current token variable.\n+     *          Do NOT use $token, as that variable is also a reference\n+     * @return bool\n+     */\n+    protected function backward(&$i, &$current)\n+    {\n+        if ($i === null) {\n+            $i = count($this->inputZipper->front) - 1;\n+        } else {\n+            $i--;\n+        }\n+        if ($i < 0) {\n+            return false;\n+        }\n+        $current = $this->inputZipper->front[$i];\n+        return true;\n+    }\n+\n+    /**\n+     * Handler that is called when a text token is processed\n+     */\n+    public function handleText(&$token)\n+    {\n+    }\n+\n+    /**\n+     * Handler that is called when a start or empty token is processed\n+     */\n+    public function handleElement(&$token)\n+    {\n+    }\n+\n+    /**\n+     * Handler that is called when an end token is processed\n+     */\n+    public function handleEnd(&$token)\n+    {\n+        $this->notifyEnd($token);\n+    }\n+\n+    /**\n+     * Notifier that is called when an end token is processed\n+     * @param HTMLPurifier_Token $token Current token variable.\n+     * @note This differs from handlers in that the token is read-only\n+     * @deprecated\n+     */\n+    public function notifyEnd($token)\n+    {\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Injector/AutoParagraph.php",
          "status": "added",
          "additions": 356,
          "deletions": 0,
          "patch": "@@ -0,0 +1,356 @@\n+<?php\n+\n+/**\n+ * Injector that auto paragraphs text in the root node based on\n+ * double-spacing.\n+ * @todo Ensure all states are unit tested, including variations as well.\n+ * @todo Make a graph of the flow control for this Injector.\n+ */\n+class HTMLPurifier_Injector_AutoParagraph extends HTMLPurifier_Injector\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'AutoParagraph';\n+\n+    /**\n+     * @type array\n+     */\n+    public $needed = array('p');\n+\n+    /**\n+     * @return HTMLPurifier_Token_Start\n+     */\n+    private function _pStart()\n+    {\n+        $par = new HTMLPurifier_Token_Start('p');\n+        $par->armor['MakeWellFormed_TagClosedError'] = true;\n+        return $par;\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Token_Text $token\n+     */\n+    public function handleText(&$token)\n+    {\n+        $text = $token->data;\n+        // Does the current parent allow <p> tags?\n+        if ($this->allowsElement('p')) {\n+            if (empty($this->currentNesting) || strpos($text, \"\\n\\n\") !== false) {\n+                // Note that we have differing behavior when dealing with text\n+                // in the anonymous root node, or a node inside the document.\n+                // If the text as a double-newline, the treatment is the same;\n+                // if it doesn't, see the next if-block if you're in the document.\n+\n+                $i = $nesting = null;\n+                if (!$this->forwardUntilEndToken($i, $current, $nesting) && $token->is_whitespace) {\n+                    // State 1.1: ...    ^ (whitespace, then document end)\n+                    //               ----\n+                    // This is a degenerate case\n+                } else {\n+                    if (!$token->is_whitespace || $this->_isInline($current)) {\n+                        // State 1.2: PAR1\n+                        //            ----\n+\n+                        // State 1.3: PAR1\\n\\nPAR2\n+                        //            ------------\n+\n+                        // State 1.4: <div>PAR1\\n\\nPAR2 (see State 2)\n+                        //                 ------------\n+                        $token = array($this->_pStart());\n+                        $this->_splitText($text, $token);\n+                    } else {\n+                        // State 1.5: \\n<hr />\n+                        //            --\n+                    }\n+                }\n+            } else {\n+                // State 2:   <div>PAR1... (similar to 1.4)\n+                //                 ----\n+\n+                // We're in an element that allows paragraph tags, but we're not\n+                // sure if we're going to need them.\n+                if ($this->_pLookAhead()) {\n+                    // State 2.1: <div>PAR1<b>PAR1\\n\\nPAR2\n+                    //                 ----\n+                    // Note: This will always be the first child, since any\n+                    // previous inline element would have triggered this very\n+                    // same routine, and found the double newline. One possible\n+                    // exception would be a comment.\n+                    $token = array($this->_pStart(), $token);\n+                } else {\n+                    // State 2.2.1: <div>PAR1<div>\n+                    //                   ----\n+\n+                    // State 2.2.2: <div>PAR1<b>PAR1</b></div>\n+                    //                   ----\n+                }\n+            }\n+            // Is the current parent a <p> tag?\n+        } elseif (!empty($this->currentNesting) &&\n+            $this->currentNesting[count($this->currentNesting) - 1]->name == 'p') {\n+            // State 3.1: ...<p>PAR1\n+            //                  ----\n+\n+            // State 3.2: ...<p>PAR1\\n\\nPAR2\n+            //                  ------------\n+            $token = array();\n+            $this->_splitText($text, $token);\n+            // Abort!\n+        } else {\n+            // State 4.1: ...<b>PAR1\n+            //                  ----\n+\n+            // State 4.2: ...<b>PAR1\\n\\nPAR2\n+            //                  ------------\n+        }\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Token $token\n+     */\n+    public function handleElement(&$token)\n+    {\n+        // We don't have to check if we're already in a <p> tag for block\n+        // tokens, because the tag would have been autoclosed by MakeWellFormed.\n+        if ($this->allowsElement('p')) {\n+            if (!empty($this->currentNesting)) {\n+                if ($this->_isInline($token)) {\n+                    // State 1: <div>...<b>\n+                    //                  ---\n+                    // Check if this token is adjacent to the parent token\n+                    // (seek backwards until token isn't whitespace)\n+                    $i = null;\n+                    $this->backward($i, $prev);\n+\n+                    if (!$prev instanceof HTMLPurifier_Token_Start) {\n+                        // Token wasn't adjacent\n+                        if ($prev instanceof HTMLPurifier_Token_Text &&\n+                            substr($prev->data, -2) === \"\\n\\n\"\n+                        ) {\n+                            // State 1.1.4: <div><p>PAR1</p>\\n\\n<b>\n+                            //                                  ---\n+                            // Quite frankly, this should be handled by splitText\n+                            $token = array($this->_pStart(), $token);\n+                        } else {\n+                            // State 1.1.1: <div><p>PAR1</p><b>\n+                            //                              ---\n+                            // State 1.1.2: <div><br /><b>\n+                            //                         ---\n+                            // State 1.1.3: <div>PAR<b>\n+                            //                      ---\n+                        }\n+                    } else {\n+                        // State 1.2.1: <div><b>\n+                        //                   ---\n+                        // Lookahead to see if <p> is needed.\n+                        if ($this->_pLookAhead()) {\n+                            // State 1.3.1: <div><b>PAR1\\n\\nPAR2\n+                            //                   ---\n+                            $token = array($this->_pStart(), $token);\n+                        } else {\n+                            // State 1.3.2: <div><b>PAR1</b></div>\n+                            //                   ---\n+\n+                            // State 1.3.3: <div><b>PAR1</b><div></div>\\n\\n</div>\n+                            //                   ---\n+                        }\n+                    }\n+                } else {\n+                    // State 2.3: ...<div>\n+                    //               -----\n+                }\n+            } else {\n+                if ($this->_isInline($token)) {\n+                    // State 3.1: <b>\n+                    //            ---\n+                    // This is where the {p} tag is inserted, not reflected in\n+                    // inputTokens yet, however.\n+                    $token = array($this->_pStart(), $token);\n+                } else {\n+                    // State 3.2: <div>\n+                    //            -----\n+                }\n+\n+                $i = null;\n+                if ($this->backward($i, $prev)) {\n+                    if (!$prev instanceof HTMLPurifier_Token_Text) {\n+                        // State 3.1.1: ...</p>{p}<b>\n+                        //                        ---\n+                        // State 3.2.1: ...</p><div>\n+                        //                     -----\n+                        if (!is_array($token)) {\n+                            $token = array($token);\n+                        }\n+                        array_unshift($token, new HTMLPurifier_Token_Text(\"\\n\\n\"));\n+                    } else {\n+                        // State 3.1.2: ...</p>\\n\\n{p}<b>\n+                        //                            ---\n+                        // State 3.2.2: ...</p>\\n\\n<div>\n+                        //                         -----\n+                        // Note: PAR<ELEM> cannot occur because PAR would have been\n+                        // wrapped in <p> tags.\n+                    }\n+                }\n+            }\n+        } else {\n+            // State 2.2: <ul><li>\n+            //                ----\n+            // State 2.4: <p><b>\n+            //               ---\n+        }\n+    }\n+\n+    /**\n+     * Splits up a text in paragraph tokens and appends them\n+     * to the result stream that will replace the original\n+     * @param string $data String text data that will be processed\n+     *    into paragraphs\n+     * @param HTMLPurifier_Token[] $result Reference to array of tokens that the\n+     *    tags will be appended onto\n+     */\n+    private function _splitText($data, &$result)\n+    {\n+        $raw_paragraphs = explode(\"\\n\\n\", $data);\n+        $paragraphs = array(); // without empty paragraphs\n+        $needs_start = false;\n+        $needs_end = false;\n+\n+        $c = count($raw_paragraphs);\n+        if ($c == 1) {\n+            // There were no double-newlines, abort quickly. In theory this\n+            // should never happen.\n+            $result[] = new HTMLPurifier_Token_Text($data);\n+            return;\n+        }\n+        for ($i = 0; $i < $c; $i++) {\n+            $par = $raw_paragraphs[$i];\n+            if (trim($par) !== '') {\n+                $paragraphs[] = $par;\n+            } else {\n+                if ($i == 0) {\n+                    // Double newline at the front\n+                    if (empty($result)) {\n+                        // The empty result indicates that the AutoParagraph\n+                        // injector did not add any start paragraph tokens.\n+                        // This means that we have been in a paragraph for\n+                        // a while, and the newline means we should start a new one.\n+                        $result[] = new HTMLPurifier_Token_End('p');\n+                        $result[] = new HTMLPurifier_Token_Text(\"\\n\\n\");\n+                        // However, the start token should only be added if\n+                        // there is more processing to be done (i.e. there are\n+                        // real paragraphs in here). If there are none, the\n+                        // next start paragraph tag will be handled by the\n+                        // next call to the injector\n+                        $needs_start = true;\n+                    } else {\n+                        // We just started a new paragraph!\n+                        // Reinstate a double-newline for presentation's sake, since\n+                        // it was in the source code.\n+                        array_unshift($result, new HTMLPurifier_Token_Text(\"\\n\\n\"));\n+                    }\n+                } elseif ($i + 1 == $c) {\n+                    // Double newline at the end\n+                    // There should be a trailing </p> when we're finally done.\n+                    $needs_end = true;\n+                }\n+            }\n+        }\n+\n+        // Check if this was just a giant blob of whitespace. Move this earlier,\n+        // perhaps?\n+        if (empty($paragraphs)) {\n+            return;\n+        }\n+\n+        // Add the start tag indicated by \\n\\n at the beginning of $data\n+        if ($needs_start) {\n+            $result[] = $this->_pStart();\n+        }\n+\n+        // Append the paragraphs onto the result\n+        foreach ($paragraphs as $par) {\n+            $result[] = new HTMLPurifier_Token_Text($par);\n+            $result[] = new HTMLPurifier_Token_End('p');\n+            $result[] = new HTMLPurifier_Token_Text(\"\\n\\n\");\n+            $result[] = $this->_pStart();\n+        }\n+\n+        // Remove trailing start token; Injector will handle this later if\n+        // it was indeed needed. This prevents from needing to do a lookahead,\n+        // at the cost of a lookbehind later.\n+        array_pop($result);\n+\n+        // If there is no need for an end tag, remove all of it and let\n+        // MakeWellFormed close it later.\n+        if (!$needs_end) {\n+            array_pop($result); // removes \\n\\n\n+            array_pop($result); // removes </p>\n+        }\n+    }\n+\n+    /**\n+     * Returns true if passed token is inline (and, ergo, allowed in\n+     * paragraph tags)\n+     * @param HTMLPurifier_Token $token\n+     * @return bool\n+     */\n+    private function _isInline($token)\n+    {\n+        return isset($this->htmlDefinition->info['p']->child->elements[$token->name]);\n+    }\n+\n+    /**\n+     * Looks ahead in the token list and determines whether or not we need\n+     * to insert a <p> tag.\n+     * @return bool\n+     */\n+    private function _pLookAhead()\n+    {\n+        if ($this->currentToken instanceof HTMLPurifier_Token_Start) {\n+            $nesting = 1;\n+        } else {\n+            $nesting = 0;\n+        }\n+        $ok = false;\n+        $i = null;\n+        while ($this->forwardUntilEndToken($i, $current, $nesting)) {\n+            $result = $this->_checkNeedsP($current);\n+            if ($result !== null) {\n+                $ok = $result;\n+                break;\n+            }\n+        }\n+        return $ok;\n+    }\n+\n+    /**\n+     * Determines if a particular token requires an earlier inline token\n+     * to get a paragraph. This should be used with _forwardUntilEndToken\n+     * @param HTMLPurifier_Token $current\n+     * @return bool\n+     */\n+    private function _checkNeedsP($current)\n+    {\n+        if ($current instanceof HTMLPurifier_Token_Start) {\n+            if (!$this->_isInline($current)) {\n+                // <div>PAR1<div>\n+                //      ----\n+                // Terminate early, since we hit a block element\n+                return false;\n+            }\n+        } elseif ($current instanceof HTMLPurifier_Token_Text) {\n+            if (strpos($current->data, \"\\n\\n\") !== false) {\n+                // <div>PAR1<b>PAR1\\n\\nPAR2\n+                //      ----\n+                return true;\n+            } else {\n+                // <div>PAR1<b>PAR1...\n+                //      ----\n+            }\n+        }\n+        return null;\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Injector/DisplayLinkURI.php",
          "status": "added",
          "additions": 40,
          "deletions": 0,
          "patch": "@@ -0,0 +1,40 @@\n+<?php\n+\n+/**\n+ * Injector that displays the URL of an anchor instead of linking to it, in addition to showing the text of the link.\n+ */\n+class HTMLPurifier_Injector_DisplayLinkURI extends HTMLPurifier_Injector\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'DisplayLinkURI';\n+\n+    /**\n+     * @type array\n+     */\n+    public $needed = array('a');\n+\n+    /**\n+     * @param $token\n+     */\n+    public function handleElement(&$token)\n+    {\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Token $token\n+     */\n+    public function handleEnd(&$token)\n+    {\n+        if (isset($token->start->attr['href'])) {\n+            $url = $token->start->attr['href'];\n+            unset($token->start->attr['href']);\n+            $token = array($token, new HTMLPurifier_Token_Text(\" ($url)\"));\n+        } else {\n+            // nothing to display\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Injector/Linkify.php",
          "status": "added",
          "additions": 64,
          "deletions": 0,
          "patch": "@@ -0,0 +1,64 @@\n+<?php\n+\n+/**\n+ * Injector that converts http, https and ftp text URLs to actual links.\n+ */\n+class HTMLPurifier_Injector_Linkify extends HTMLPurifier_Injector\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'Linkify';\n+\n+    /**\n+     * @type array\n+     */\n+    public $needed = array('a' => array('href'));\n+\n+    /**\n+     * @param HTMLPurifier_Token $token\n+     */\n+    public function handleText(&$token)\n+    {\n+        if (!$this->allowsElement('a')) {\n+            return;\n+        }\n+\n+        if (strpos($token->data, '://') === false) {\n+            // our really quick heuristic failed, abort\n+            // this may not work so well if we want to match things like\n+            // \"google.com\", but then again, most people don't\n+            return;\n+        }\n+\n+        // there is/are URL(s). Let's split the string.\n+        // We use this regex:\n+        // https://gist.github.com/gruber/249502\n+        // but with @cscott's backtracking fix and also\n+        // the Unicode characters un-Unicodified.\n+        $bits = preg_split(\n+            '/\\\\b((?:[a-z][\\\\w\\\\-]+:(?:\\\\/{1,3}|[a-z0-9%])|www\\\\d{0,3}[.]|[a-z0-9.\\\\-]+[.][a-z]{2,4}\\\\/)(?:[^\\\\s()<>]|\\\\((?:[^\\\\s()<>]|(?:\\\\([^\\\\s()<>]+\\\\)))*\\\\))+(?:\\\\((?:[^\\\\s()<>]|(?:\\\\([^\\\\s()<>]+\\\\)))*\\\\)|[^\\\\s`!()\\\\[\\\\]{};:\\'\".,<>?\\x{00ab}\\x{00bb}\\x{201c}\\x{201d}\\x{2018}\\x{2019}]))/iu',\n+            $token->data, -1, PREG_SPLIT_DELIM_CAPTURE);\n+\n+\n+        $token = array();\n+\n+        // $i = index\n+        // $c = count\n+        // $l = is link\n+        for ($i = 0, $c = count($bits), $l = false; $i < $c; $i++, $l = !$l) {\n+            if (!$l) {\n+                if ($bits[$i] === '') {\n+                    continue;\n+                }\n+                $token[] = new HTMLPurifier_Token_Text($bits[$i]);\n+            } else {\n+                $token[] = new HTMLPurifier_Token_Start('a', array('href' => $bits[$i]));\n+                $token[] = new HTMLPurifier_Token_Text($bits[$i]);\n+                $token[] = new HTMLPurifier_Token_End('a');\n+            }\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Injector/PurifierLinkify.php",
          "status": "added",
          "additions": 71,
          "deletions": 0,
          "patch": "@@ -0,0 +1,71 @@\n+<?php\n+\n+/**\n+ * Injector that converts configuration directive syntax %Namespace.Directive\n+ * to links\n+ */\n+class HTMLPurifier_Injector_PurifierLinkify extends HTMLPurifier_Injector\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'PurifierLinkify';\n+\n+    /**\n+     * @type string\n+     */\n+    public $docURL;\n+\n+    /**\n+     * @type array\n+     */\n+    public $needed = array('a' => array('href'));\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return string\n+     */\n+    public function prepare($config, $context)\n+    {\n+        $this->docURL = $config->get('AutoFormat.PurifierLinkify.DocURL');\n+        return parent::prepare($config, $context);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Token $token\n+     */\n+    public function handleText(&$token)\n+    {\n+        if (!$this->allowsElement('a')) {\n+            return;\n+        }\n+        if (strpos($token->data, '%') === false) {\n+            return;\n+        }\n+\n+        $bits = preg_split('#%([a-z0-9]+\\.[a-z0-9]+)#Si', $token->data, -1, PREG_SPLIT_DELIM_CAPTURE);\n+        $token = array();\n+\n+        // $i = index\n+        // $c = count\n+        // $l = is link\n+        for ($i = 0, $c = count($bits), $l = false; $i < $c; $i++, $l = !$l) {\n+            if (!$l) {\n+                if ($bits[$i] === '') {\n+                    continue;\n+                }\n+                $token[] = new HTMLPurifier_Token_Text($bits[$i]);\n+            } else {\n+                $token[] = new HTMLPurifier_Token_Start(\n+                    'a',\n+                    array('href' => str_replace('%s', $bits[$i], $this->docURL))\n+                );\n+                $token[] = new HTMLPurifier_Token_Text('%' . $bits[$i]);\n+                $token[] = new HTMLPurifier_Token_End('a');\n+            }\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Injector/RemoveEmpty.php",
          "status": "added",
          "additions": 112,
          "deletions": 0,
          "patch": "@@ -0,0 +1,112 @@\n+<?php\n+\n+class HTMLPurifier_Injector_RemoveEmpty extends HTMLPurifier_Injector\n+{\n+    /**\n+     * @type HTMLPurifier_Context\n+     */\n+    private $context;\n+\n+    /**\n+     * @type HTMLPurifier_Config\n+     */\n+    private $config;\n+\n+    /**\n+     * @type HTMLPurifier_AttrValidator\n+     */\n+    private $attrValidator;\n+\n+    /**\n+     * @type bool\n+     */\n+    private $removeNbsp;\n+\n+    /**\n+     * @type bool\n+     */\n+    private $removeNbspExceptions;\n+\n+    /**\n+     * Cached contents of %AutoFormat.RemoveEmpty.Predicate\n+     * @type array\n+     */\n+    private $exclude;\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return void\n+     */\n+    public function prepare($config, $context)\n+    {\n+        parent::prepare($config, $context);\n+        $this->config = $config;\n+        $this->context = $context;\n+        $this->removeNbsp = $config->get('AutoFormat.RemoveEmpty.RemoveNbsp');\n+        $this->removeNbspExceptions = $config->get('AutoFormat.RemoveEmpty.RemoveNbsp.Exceptions');\n+        $this->exclude = $config->get('AutoFormat.RemoveEmpty.Predicate');\n+        foreach ($this->exclude as $key => $attrs) {\n+            if (!is_array($attrs)) {\n+                // HACK, see HTMLPurifier/Printer/ConfigForm.php\n+                $this->exclude[$key] = explode(';', $attrs);\n+            }\n+        }\n+        $this->attrValidator = new HTMLPurifier_AttrValidator();\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Token $token\n+     */\n+    public function handleElement(&$token)\n+    {\n+        if (!$token instanceof HTMLPurifier_Token_Start) {\n+            return;\n+        }\n+        $next = false;\n+        $deleted = 1; // the current tag\n+        for ($i = count($this->inputZipper->back) - 1; $i >= 0; $i--, $deleted++) {\n+            $next = $this->inputZipper->back[$i];\n+            if ($next instanceof HTMLPurifier_Token_Text) {\n+                if ($next->is_whitespace) {\n+                    continue;\n+                }\n+                if ($this->removeNbsp && !isset($this->removeNbspExceptions[$token->name])) {\n+                    $plain = str_replace(\"\\xC2\\xA0\", \"\", $next->data);\n+                    $isWsOrNbsp = $plain === '' || ctype_space($plain);\n+                    if ($isWsOrNbsp) {\n+                        continue;\n+                    }\n+                }\n+            }\n+            break;\n+        }\n+        if (!$next || ($next instanceof HTMLPurifier_Token_End && $next->name == $token->name)) {\n+            $this->attrValidator->validateToken($token, $this->config, $this->context);\n+            $token->armor['ValidateAttributes'] = true;\n+            if (isset($this->exclude[$token->name])) {\n+                $r = true;\n+                foreach ($this->exclude[$token->name] as $elem) {\n+                    if (!isset($token->attr[$elem])) $r = false;\n+                }\n+                if ($r) return;\n+            }\n+            if (isset($token->attr['id']) || isset($token->attr['name'])) {\n+                return;\n+            }\n+            $token = $deleted + 1;\n+            for ($b = 0, $c = count($this->inputZipper->front); $b < $c; $b++) {\n+                $prev = $this->inputZipper->front[$b];\n+                if ($prev instanceof HTMLPurifier_Token_Text && $prev->is_whitespace) {\n+                    continue;\n+                }\n+                break;\n+            }\n+            // This is safe because we removed the token that triggered this.\n+            $this->rewindOffset($b+$deleted);\n+            return;\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Injector/RemoveSpansWithoutAttributes.php",
          "status": "added",
          "additions": 84,
          "deletions": 0,
          "patch": "@@ -0,0 +1,84 @@\n+<?php\n+\n+/**\n+ * Injector that removes spans with no attributes\n+ */\n+class HTMLPurifier_Injector_RemoveSpansWithoutAttributes extends HTMLPurifier_Injector\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'RemoveSpansWithoutAttributes';\n+\n+    /**\n+     * @type array\n+     */\n+    public $needed = array('span');\n+\n+    /**\n+     * @type HTMLPurifier_AttrValidator\n+     */\n+    private $attrValidator;\n+\n+    /**\n+     * Used by AttrValidator.\n+     * @type HTMLPurifier_Config\n+     */\n+    private $config;\n+\n+    /**\n+     * @type HTMLPurifier_Context\n+     */\n+    private $context;\n+\n+    public function prepare($config, $context)\n+    {\n+        $this->attrValidator = new HTMLPurifier_AttrValidator();\n+        $this->config = $config;\n+        $this->context = $context;\n+        return parent::prepare($config, $context);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Token $token\n+     */\n+    public function handleElement(&$token)\n+    {\n+        if ($token->name !== 'span' || !$token instanceof HTMLPurifier_Token_Start) {\n+            return;\n+        }\n+\n+        // We need to validate the attributes now since this doesn't normally\n+        // happen until after MakeWellFormed. If all the attributes are removed\n+        // the span needs to be removed too.\n+        $this->attrValidator->validateToken($token, $this->config, $this->context);\n+        $token->armor['ValidateAttributes'] = true;\n+\n+        if (!empty($token->attr)) {\n+            return;\n+        }\n+\n+        $nesting = 0;\n+        while ($this->forwardUntilEndToken($i, $current, $nesting)) {\n+        }\n+\n+        if ($current instanceof HTMLPurifier_Token_End && $current->name === 'span') {\n+            // Mark closing span tag for deletion\n+            $current->markForDeletion = true;\n+            // Delete open span tag\n+            $token = false;\n+        }\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Token $token\n+     */\n+    public function handleEnd(&$token)\n+    {\n+        if ($token->markForDeletion) {\n+            $token = false;\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        },
        {
          "filename": "helpers/htmlpurifier/HTMLPurifier/Injector/SafeObject.php",
          "status": "added",
          "additions": 124,
          "deletions": 0,
          "patch": "@@ -0,0 +1,124 @@\n+<?php\n+\n+/**\n+ * Adds important param elements to inside of object in order to make\n+ * things safe.\n+ */\n+class HTMLPurifier_Injector_SafeObject extends HTMLPurifier_Injector\n+{\n+    /**\n+     * @type string\n+     */\n+    public $name = 'SafeObject';\n+\n+    /**\n+     * @type array\n+     */\n+    public $needed = array('object', 'param');\n+\n+    /**\n+     * @type array\n+     */\n+    protected $objectStack = array();\n+\n+    /**\n+     * @type array\n+     */\n+    protected $paramStack = array();\n+\n+    /**\n+     * Keep this synchronized with AttrTransform/SafeParam.php.\n+     * @type array\n+     */\n+    protected $addParam = array(\n+        'allowScriptAccess' => 'never',\n+        'allowNetworking' => 'internal',\n+    );\n+\n+    /**\n+     * These are all lower-case keys.\n+     * @type array\n+     */\n+    protected $allowedParam = array(\n+        'wmode' => true,\n+        'movie' => true,\n+        'flashvars' => true,\n+        'src' => true,\n+        'allowfullscreen' => true, // if omitted, assume to be 'false'\n+    );\n+\n+    /**\n+     * @param HTMLPurifier_Config $config\n+     * @param HTMLPurifier_Context $context\n+     * @return void\n+     */\n+    public function prepare($config, $context)\n+    {\n+        parent::prepare($config, $context);\n+    }\n+\n+    /**\n+     * @param HTMLPurifier_Token $token\n+     */\n+    public function handleElement(&$token)\n+    {\n+        if ($token->name == 'object') {\n+            $this->objectStack[] = $token;\n+            $this->paramStack[] = array();\n+            $new = array($token);\n+            foreach ($this->addParam as $name => $value) {\n+                $new[] = new HTMLPurifier_Token_Empty('param', array('name' => $name, 'value' => $value));\n+            }\n+            $token = $new;\n+        } elseif ($token->name == 'param') {\n+            $nest = count($this->currentNesting) - 1;\n+            if ($nest >= 0 && $this->currentNesting[$nest]->name === 'object') {\n+                $i = count($this->objectStack) - 1;\n+                if (!isset($token->attr['name'])) {\n+                    $token = false;\n+                    return;\n+                }\n+                $n = $token->attr['name'];\n+                // We need this fix because YouTube doesn't supply a data\n+                // attribute, which we need if a type is specified. This is\n+                // *very* Flash specific.\n+                if (!isset($this->objectStack[$i]->attr['data']) &&\n+                    ($token->attr['name'] == 'movie' || $token->attr['name'] == 'src')\n+                ) {\n+                    $this->objectStack[$i]->attr['data'] = $token->attr['value'];\n+                }\n+                // Check if the parameter is the correct value but has not\n+                // already been added\n+                if (!isset($this->paramStack[$i][$n]) &&\n+                    isset($this->addParam[$n]) &&\n+                    $token->attr['name'] === $this->addParam[$n]) {\n+                    // keep token, and add to param stack\n+                    $this->paramStack[$i][$n] = true;\n+                } elseif (isset($this->allowedParam[strtolower($n)])) {\n+                    // keep token, don't do anything to it\n+                    // (could possibly check for duplicates here)\n+                    // Note: In principle, parameters should be case sensitive.\n+                    // But it seems they are not really; so accept any case.\n+                } else {\n+                    $token = false;\n+                }\n+            } else {\n+                // not directly inside an object, DENY!\n+                $token = false;\n+            }\n+        }\n+    }\n+\n+    public function handleEnd(&$token)\n+    {\n+        // This is the WRONG way of handling the object and param stacks;\n+        // we should be inserting them directly on the relevant object tokens\n+        // so that the global stack handling handles it.\n+        if ($token->name == 'object') {\n+            array_pop($this->objectStack);\n+            array_pop($this->paramStack);\n+        }\n+    }\n+}\n+\n+// vim: et sw=4 sts=4"
        }
      ],
      "file_patterns": {
        "security_files": 2,
        "config_files": 135,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 25,
        "max_directory_depth": 6
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "07865b7167085c7580e3033d3ab6978583163e97",
            "date": "2018-06-04T07:54:06Z",
            "author_login": "JohanDufau"
          },
          {
            "sha": "4da60d609d21b83a4534b74cf6b4253e246a1787",
            "date": "2018-06-04T07:48:48Z",
            "author_login": "JohanDufau"
          },
          {
            "sha": "45dad2a0fc3bfad997bc5498933b424d053c901c",
            "date": "2018-06-04T07:44:22Z",
            "author_login": "JohanDufau"
          },
          {
            "sha": "1d4d6443648256a055e4e1a51cbbe41973cb616c",
            "date": "2018-06-04T07:44:07Z",
            "author_login": "JohanDufau"
          },
          {
            "sha": "7c3b69733a47ec3007f988adc5169c5a36356197",
            "date": "2017-11-13T15:30:47Z",
            "author_login": "JohanDufau"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-79",
    "description": "Stored cross-site scripting (XSS) vulnerability in the \"Website's name\" field found in the \"Settings\" page under the \"General\" menu in Creatiwity wityCMS 0.6.1 allows remote attackers to inject arbitrary web script or HTML via a crafted website name by doing an authenticated POST HTTP request to admin/settings/general.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-05-28T13:29:00.297",
    "last_modified": "2024-11-21T03:43:31.517",
    "fix_date": "2017-02-26T10:45:28Z"
  },
  "references": [
    {
      "url": "https://github.com/Creatiwity/wityCMS/commit/7967e5bf15b4d2ee6b85b56e82d7e1229147de44",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/Creatiwity/wityCMS/issues/150",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.exploit-db.com/exploits/44790/",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/Creatiwity/wityCMS/commit/7967e5bf15b4d2ee6b85b56e82d7e1229147de44",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/Creatiwity/wityCMS/issues/150",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.exploit-db.com/exploits/44790/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory",
        "VDB Entry"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:25.861089",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "wityCMS",
    "owner": "Creatiwity",
    "created_at": "2012-07-18T21:24:04Z",
    "updated_at": "2024-06-02T07:43:47Z",
    "pushed_at": "2023-04-16T18:06:41Z",
    "size": 16951,
    "stars": 31,
    "forks": 16,
    "open_issues": 6,
    "watchers": 31,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "PHP": 2345180,
      "HTML": 357662,
      "JavaScript": 235640,
      "CSS": 163583
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T15:31:17.406326"
  }
}