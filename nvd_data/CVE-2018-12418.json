{
  "cve_id": "CVE-2018-12418",
  "github_data": {
    "repository": "junrar/junrar",
    "fix_commit": "ad8d0ba8e155630da8a1215cee3f253e0af45817",
    "related_commits": [
      "ad8d0ba8e155630da8a1215cee3f253e0af45817",
      "ad8d0ba8e155630da8a1215cee3f253e0af45817"
    ],
    "patch_url": "https://github.com/junrar/junrar/commit/ad8d0ba8e155630da8a1215cee3f253e0af45817.patch",
    "fix_commit_details": {
      "sha": "ad8d0ba8e155630da8a1215cee3f253e0af45817",
      "commit_date": "2018-05-31T02:22:23Z",
      "author": {
        "login": "tballison",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "make Archive slightly more robust against corrupt files.  Add (#8)",
        "length": 100,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 117,
        "additions": 102,
        "deletions": 15
      },
      "files": [
        {
          "filename": "src/main/java/com/github/junrar/Archive.java",
          "status": "modified",
          "additions": 42,
          "deletions": 15,
          "patch": "@@ -26,7 +26,9 @@\n import java.io.PipedInputStream;\r\n import java.io.PipedOutputStream;\r\n import java.util.ArrayList;\r\n+import java.util.HashSet;\r\n import java.util.List;\r\n+import java.util.Set;\r\n import java.util.logging.Level;\r\n import java.util.logging.Logger;\r\n \r\n@@ -62,6 +64,8 @@\n public class Archive implements Closeable {\r\n \tprivate static Logger logger = Logger.getLogger(Archive.class.getName());\r\n \r\n+\tprivate static int MAX_HEADER_SIZE = 20971520;//20MB\r\n+\r\n \tprivate IReadOnlyAccess rof;\r\n \r\n \tprivate final UnrarCallback unrarCallback;\r\n@@ -229,11 +233,13 @@ private void readHeaders(long fileLength) throws IOException, RarException {\n \t\theaders.clear();\r\n \t\tcurrentHeaderIndex = 0;\r\n \t\tint toRead = 0;\r\n-\r\n+\t\t//keep track of positions already processed for\r\n+\t\t//more robustness against corrupt files\r\n+\t\tSet<Long> processedPositions = new HashSet<Long>();\r\n \t\twhile (true) {\r\n \t\t\tint size = 0;\r\n \t\t\tlong newpos = 0;\r\n-\t\t\tbyte[] baseBlockBuffer = new byte[BaseBlock.BaseBlockSize];\r\n+\t\t\tbyte[] baseBlockBuffer = safelyAllocate(BaseBlock.BaseBlockSize, MAX_HEADER_SIZE);\r\n \r\n \t\t\tlong position = rof.getPosition();\r\n \r\n@@ -266,7 +272,7 @@ private void readHeaders(long fileLength) throws IOException, RarException {\n \t\t\tcase MainHeader:\r\n \t\t\t\ttoRead = block.hasEncryptVersion() ? MainHeader.mainHeaderSizeWithEnc\r\n \t\t\t\t\t\t: MainHeader.mainHeaderSize;\r\n-\t\t\t\tbyte[] mainbuff = new byte[toRead];\r\n+\t\t\t\tbyte[] mainbuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\r\n \t\t\t\trof.readFully(mainbuff, toRead);\r\n \t\t\t\tMainHeader mainhead = new MainHeader(block, mainbuff);\r\n \t\t\t\theaders.add(mainhead);\r\n@@ -280,7 +286,7 @@ private void readHeaders(long fileLength) throws IOException, RarException {\n \r\n \t\t\tcase SignHeader:\r\n \t\t\t\ttoRead = SignHeader.signHeaderSize;\r\n-\t\t\t\tbyte[] signBuff = new byte[toRead];\r\n+\t\t\t\tbyte[] signBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\r\n \t\t\t\trof.readFully(signBuff, toRead);\r\n \t\t\t\tSignHeader signHead = new SignHeader(block, signBuff);\r\n \t\t\t\theaders.add(signHead);\r\n@@ -290,7 +296,7 @@ private void readHeaders(long fileLength) throws IOException, RarException {\n \r\n \t\t\tcase AvHeader:\r\n \t\t\t\ttoRead = AVHeader.avHeaderSize;\r\n-\t\t\t\tbyte[] avBuff = new byte[toRead];\r\n+\t\t\t\tbyte[] avBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\r\n \t\t\t\trof.readFully(avBuff, toRead);\r\n \t\t\t\tAVHeader avHead = new AVHeader(block, avBuff);\r\n \t\t\t\theaders.add(avHead);\r\n@@ -299,14 +305,18 @@ private void readHeaders(long fileLength) throws IOException, RarException {\n \r\n \t\t\tcase CommHeader:\r\n \t\t\t\ttoRead = CommentHeader.commentHeaderSize;\r\n-\t\t\t\tbyte[] commBuff = new byte[toRead];\r\n+\t\t\t\tbyte[] commBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\r\n \t\t\t\trof.readFully(commBuff, toRead);\r\n \t\t\t\tCommentHeader commHead = new CommentHeader(block, commBuff);\r\n \t\t\t\theaders.add(commHead);\r\n \t\t\t\t// logger.info(\"method: \"+commHead.getUnpMethod()+\"; 0x\"+\r\n \t\t\t\t// Integer.toHexString(commHead.getUnpMethod()));\r\n \t\t\t\tnewpos = commHead.getPositionInFile()\r\n \t\t\t\t\t\t+ commHead.getHeaderSize();\r\n+\t\t\t\tif (processedPositions.contains(newpos)) {\r\n+\t\t\t\t\tthrow new RarException(RarExceptionType.badRarArchive);\r\n+\t\t\t\t}\r\n+\t\t\t\tprocessedPositions.add(newpos);\r\n \t\t\t\trof.setPosition(newpos);\r\n \r\n \t\t\t\tbreak;\r\n@@ -321,7 +331,7 @@ private void readHeaders(long fileLength) throws IOException, RarException {\n \t\t\t\t}\r\n \t\t\t\tEndArcHeader endArcHead;\r\n \t\t\t\tif (toRead > 0) {\r\n-\t\t\t\t\tbyte[] endArchBuff = new byte[toRead];\r\n+\t\t\t\t\tbyte[] endArchBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\r\n \t\t\t\t\trof.readFully(endArchBuff, toRead);\r\n \t\t\t\t\tendArcHead = new EndArcHeader(block, endArchBuff);\r\n \t\t\t\t\t// logger.info(\"HeaderType: endarch\\ndatacrc:\"+\r\n@@ -335,7 +345,7 @@ private void readHeaders(long fileLength) throws IOException, RarException {\n \t\t\t\treturn;\r\n \r\n \t\t\tdefault:\r\n-\t\t\t\tbyte[] blockHeaderBuffer = new byte[BlockHeader.blockHeaderSize];\r\n+\t\t\t\tbyte[] blockHeaderBuffer = safelyAllocate(BlockHeader.blockHeaderSize, MAX_HEADER_SIZE);\r\n \t\t\t\trof.readFully(blockHeaderBuffer, BlockHeader.blockHeaderSize);\r\n \t\t\t\tBlockHeader blockHead = new BlockHeader(block,\r\n \t\t\t\t\t\tblockHeaderBuffer);\r\n@@ -346,40 +356,47 @@ private void readHeaders(long fileLength) throws IOException, RarException {\n \t\t\t\t\ttoRead = blockHead.getHeaderSize()\r\n \t\t\t\t\t\t\t- BlockHeader.BaseBlockSize\r\n \t\t\t\t\t\t\t- BlockHeader.blockHeaderSize;\r\n-\t\t\t\t\tbyte[] fileHeaderBuffer = new byte[toRead];\r\n+\t\t\t\t\tbyte[] fileHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\r\n \t\t\t\t\trof.readFully(fileHeaderBuffer, toRead);\r\n \r\n \t\t\t\t\tFileHeader fh = new FileHeader(blockHead, fileHeaderBuffer);\r\n \t\t\t\t\theaders.add(fh);\r\n \t\t\t\t\tnewpos = fh.getPositionInFile() + fh.getHeaderSize()\r\n \t\t\t\t\t\t\t+ fh.getFullPackSize();\r\n+\t\t\t\t\tif (processedPositions.contains(newpos)) {\r\n+\t\t\t\t\t\tthrow new RarException(RarExceptionType.badRarArchive);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\tprocessedPositions.add(newpos);\r\n \t\t\t\t\trof.setPosition(newpos);\r\n \t\t\t\t\tbreak;\r\n \r\n \t\t\t\tcase ProtectHeader:\r\n \t\t\t\t\ttoRead = blockHead.getHeaderSize()\r\n \t\t\t\t\t\t\t- BlockHeader.BaseBlockSize\r\n \t\t\t\t\t\t\t- BlockHeader.blockHeaderSize;\r\n-\t\t\t\t\tbyte[] protectHeaderBuffer = new byte[toRead];\r\n+\t\t\t\t\tbyte[] protectHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\r\n \t\t\t\t\trof.readFully(protectHeaderBuffer, toRead);\r\n \t\t\t\t\tProtectHeader ph = new ProtectHeader(blockHead,\r\n \t\t\t\t\t\t\tprotectHeaderBuffer);\r\n-\r\n \t\t\t\t\tnewpos = ph.getPositionInFile() + ph.getHeaderSize()\r\n \t\t\t\t\t\t\t+ ph.getDataSize();\r\n+\t\t\t\t\tif (processedPositions.contains(newpos)) {\r\n+\t\t\t\t\t\tthrow new RarException(RarExceptionType.badRarArchive);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\tprocessedPositions.add(newpos);\r\n \t\t\t\t\trof.setPosition(newpos);\r\n \t\t\t\t\tbreak;\r\n \r\n \t\t\t\tcase SubHeader: {\r\n-\t\t\t\t\tbyte[] subHeadbuffer = new byte[SubBlockHeader.SubBlockHeaderSize];\r\n+\t\t\t\t\tbyte[] subHeadbuffer = safelyAllocate(SubBlockHeader.SubBlockHeaderSize, MAX_HEADER_SIZE);\r\n \t\t\t\t\trof.readFully(subHeadbuffer,\r\n \t\t\t\t\t\t\tSubBlockHeader.SubBlockHeaderSize);\r\n \t\t\t\t\tSubBlockHeader subHead = new SubBlockHeader(blockHead,\r\n \t\t\t\t\t\t\tsubHeadbuffer);\r\n \t\t\t\t\tsubHead.print();\r\n \t\t\t\t\tswitch (subHead.getSubType()) {\r\n \t\t\t\t\tcase MAC_HEAD: {\r\n-\t\t\t\t\t\tbyte[] macHeaderbuffer = new byte[MacInfoHeader.MacInfoHeaderSize];\r\n+\t\t\t\t\t\tbyte[] macHeaderbuffer = safelyAllocate(MacInfoHeader.MacInfoHeaderSize, MAX_HEADER_SIZE);\r\n \t\t\t\t\t\trof.readFully(macHeaderbuffer,\r\n \t\t\t\t\t\t\t\tMacInfoHeader.MacInfoHeaderSize);\r\n \t\t\t\t\t\tMacInfoHeader macHeader = new MacInfoHeader(subHead,\r\n@@ -393,7 +410,7 @@ private void readHeaders(long fileLength) throws IOException, RarException {\n \t\t\t\t\tcase BEEA_HEAD:\r\n \t\t\t\t\t\tbreak;\r\n \t\t\t\t\tcase EA_HEAD: {\r\n-\t\t\t\t\t\tbyte[] eaHeaderBuffer = new byte[EAHeader.EAHeaderSize];\r\n+\t\t\t\t\t\tbyte[] eaHeaderBuffer = safelyAllocate(EAHeader.EAHeaderSize, MAX_HEADER_SIZE);\r\n \t\t\t\t\t\trof.readFully(eaHeaderBuffer, EAHeader.EAHeaderSize);\r\n \t\t\t\t\t\tEAHeader eaHeader = new EAHeader(subHead,\r\n \t\t\t\t\t\t\t\teaHeaderBuffer);\r\n@@ -411,7 +428,7 @@ private void readHeaders(long fileLength) throws IOException, RarException {\n \t\t\t\t\t\ttoRead -= BaseBlock.BaseBlockSize;\r\n \t\t\t\t\t\ttoRead -= BlockHeader.blockHeaderSize;\r\n \t\t\t\t\t\ttoRead -= SubBlockHeader.SubBlockHeaderSize;\r\n-\t\t\t\t\t\tbyte[] uoHeaderBuffer = new byte[toRead];\r\n+\t\t\t\t\t\tbyte[] uoHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\r\n \t\t\t\t\t\trof.readFully(uoHeaderBuffer, toRead);\r\n \t\t\t\t\t\tUnixOwnersHeader uoHeader = new UnixOwnersHeader(\r\n \t\t\t\t\t\t\t\tsubHead, uoHeaderBuffer);\r\n@@ -434,6 +451,16 @@ private void readHeaders(long fileLength) throws IOException, RarException {\n \t\t}\r\n \t}\r\n \r\n+\tprivate static byte[] safelyAllocate(long len, int maxSize) throws RarException {\r\n+\t\tif (maxSize < 0) {\r\n+\t\t\tthrow new IllegalArgumentException(\"maxsize must be >= 0\");\r\n+\t\t}\r\n+\t\tif (len < 0 || len > (long)maxSize) {\r\n+\t\t\tthrow new RarException(RarExceptionType.badRarArchive);\r\n+\t\t}\r\n+\t\treturn new byte[(int)len];\r\n+\t}\r\n+\r\n \t/**\r\n \t * Extract the file specified by the given header and write it to the\r\n \t * supplied output stream\r"
        },
        {
          "filename": "src/test/java/com/github/junrar/testUtil/SimpleTest.java",
          "status": "added",
          "additions": 60,
          "deletions": 0,
          "patch": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.github.junrar.testUtil;\n+\n+import com.github.junrar.Archive;\n+import com.github.junrar.rarfile.FileHeader;\n+import org.junit.Test;\n+\n+import java.io.File;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SimpleTest {\n+\n+    @Test\n+    public void testTikaDocs() throws Exception {\n+        String[] expected = {\"testEXCEL.xls\", \"13824\",\n+                \"testHTML.html\", \"167\",\n+                \"testOpenOffice2.odt\", \"26448\",\n+                \"testPDF.pdf\", \"34824\",\n+                \"testPPT.ppt\", \"16384\",\n+                \"testRTF.rtf\", \"3410\",\n+                \"testTXT.txt\", \"49\",\n+                \"testWORD.doc\", \"19456\",\n+                \"testXML.xml\", \"766\"};\n+\n+\n+        File f = new File(getClass().getResource(\"test-documents.rar\").toURI());\n+        Archive archive = null;\n+        try {\n+            archive = new Archive(f);\n+\n+            FileHeader fileHeader = archive.nextFileHeader();\n+            int i = 0;\n+            while (fileHeader != null) {\n+                assertTrue(fileHeader.getFileNameString().contains(expected[i++]));\n+                assertEquals(Long.parseLong(expected[i++]), fileHeader.getUnpSize());\n+                fileHeader = archive.nextFileHeader();\n+            }\n+        } finally {\n+            archive.close();\n+        }\n+\n+    }\n+}"
        },
        {
          "filename": "src/test/resources/com/github/junrar/testUtil/test-documents.rar",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 3,
        "max_directory_depth": 7
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b4e51ae3daa47758aff7d1aab9a2e19685046a6b",
            "date": "2024-12-16T08:01:17Z",
            "author_login": "gotson"
          },
          {
            "sha": "d74c30ef1cb9e9875e128c6122b31a9473e1761a",
            "date": "2024-12-16T07:41:19Z",
            "author_login": "gotson"
          },
          {
            "sha": "44dd10c64d3c47389263b88534c92e6d63d290c3",
            "date": "2024-12-16T07:33:29Z",
            "author_login": "gotson"
          },
          {
            "sha": "9ea7d0f7abd9a0d8e1b2a02ebf139b2469167933",
            "date": "2024-04-16T01:51:06Z",
            "author_login": "gotson"
          },
          {
            "sha": "b589e68a250d707d24f6fbc0578b240c074db051",
            "date": "2024-02-05T16:40:54Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-835",
    "description": "Archive.java in Junrar before 1.0.1, as used in Apache Tika and other products, is affected by a denial of service vulnerability due to an infinite loop when handling corrupt RAR files.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-06-14T16:29:00.287",
    "last_modified": "2024-11-21T03:45:11.173",
    "fix_date": "2018-05-31T02:22:23Z"
  },
  "references": [
    {
      "url": "https://github.com/junrar/junrar/commit/ad8d0ba8e155630da8a1215cee3f253e0af45817",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/junrar/junrar/pull/8",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/junrar/junrar/commit/ad8d0ba8e155630da8a1215cee3f253e0af45817",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/junrar/junrar/pull/8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:28.532774",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "junrar",
    "owner": "junrar",
    "created_at": "2012-09-04T13:14:45Z",
    "updated_at": "2025-01-07T03:00:07Z",
    "pushed_at": "2024-12-16T08:04:29Z",
    "size": 13823,
    "stars": 292,
    "forks": 77,
    "open_issues": 8,
    "watchers": 292,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Java": 462418,
      "Shell": 1377
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T17:15:04.526002"
  }
}