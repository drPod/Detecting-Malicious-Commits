{
  "cve_id": "CVE-2018-12435",
  "github_data": {
    "repository": "randombit/botan",
    "fix_commit": "48fc8df51d99f9d8ba251219367b3d629cc848e3",
    "related_commits": [
      "48fc8df51d99f9d8ba251219367b3d629cc848e3",
      "48fc8df51d99f9d8ba251219367b3d629cc848e3"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "48fc8df51d99f9d8ba251219367b3d629cc848e3",
      "commit_date": "2018-06-05T22:40:14Z",
      "author": {
        "login": "randombit",
        "type": "User",
        "stats": {
          "total_commits": 13797,
          "average_weekly_commits": 14.121801432958035,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 792
        }
      },
      "commit_message": {
        "title": "Address DSA/ECDSA side channel",
        "length": 30,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 105,
        "additions": 88,
        "deletions": 17
      },
      "files": [
        {
          "filename": "doc/security.rst",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -18,6 +18,14 @@ https://keybase.io/jacklloyd and on most PGP keyservers.\n 2018\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+* 2018-06-13 (CVE-2018-0495): ECDSA side channel\n+\n+  A side channel in the ECDSA signature operation could allow a local attacker\n+  to recover the secret key. Found by Keegan Ryan of NCC Group.\n+\n+  Fixed in 2.7.0. Due to a slight difference in code structure, versions before\n+  2.5.0 are not affected by this issue.\n+\n * 2018-04-10 (CVE-2018-9860): Memory overread in TLS CBC decryption\n \n   An off by one error in TLS CBC decryption meant that for a particular"
        },
        {
          "filename": "src/lib/pubkey/dsa/dsa.cpp",
          "status": "modified",
          "additions": 28,
          "deletions": 10,
          "patch": "@@ -74,7 +74,9 @@ namespace {\n class DSA_Signature_Operation final : public PK_Ops::Signature_with_EMSA\n    {\n    public:\n-      DSA_Signature_Operation(const DSA_PrivateKey& dsa, const std::string& emsa) :\n+      DSA_Signature_Operation(const DSA_PrivateKey& dsa,\n+                              const std::string& emsa,\n+                              RandomNumberGenerator& rng) :\n          PK_Ops::Signature_with_EMSA(emsa),\n          m_group(dsa.get_group()),\n          m_x(dsa.get_x()),\n@@ -83,6 +85,9 @@ class DSA_Signature_Operation final : public PK_Ops::Signature_with_EMSA\n #if defined(BOTAN_HAS_RFC6979_GENERATOR)\n          m_rfc6979_hash = hash_for_emsa(emsa);\n #endif\n+\n+         m_b = BigInt::random_integer(rng, 2, dsa.group_q());\n+         m_b_inv = inverse_mod(m_b, dsa.group_q());\n          }\n \n       size_t max_input_bits() const override { return m_group.get_q().bits(); }\n@@ -96,6 +101,8 @@ class DSA_Signature_Operation final : public PK_Ops::Signature_with_EMSA\n #if defined(BOTAN_HAS_RFC6979_GENERATOR)\n       std::string m_rfc6979_hash;\n #endif\n+\n+      BigInt m_b, m_b_inv;\n    };\n \n secure_vector<uint8_t>\n@@ -104,22 +111,32 @@ DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n    {\n    const BigInt& q = m_group.get_q();\n \n-   BigInt i(msg, msg_len, q.bits());\n+   BigInt m(msg, msg_len, q.bits());\n \n-   while(i >= q)\n-      i -= q;\n+   while(m >= q)\n+      m -= q;\n \n #if defined(BOTAN_HAS_RFC6979_GENERATOR)\n    BOTAN_UNUSED(rng);\n-   const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash);\n+   const BigInt k = generate_rfc6979_nonce(m_x, q, m, m_rfc6979_hash);\n #else\n    const BigInt k = BigInt::random_integer(rng, 1, q);\n #endif\n \n-   BigInt s = inverse_mod(k, q);\n+   const BigInt k_inv = inverse_mod(k, q);\n+\n    const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));\n \n-   s = m_mod_q.multiply(s, mul_add(m_x, r, i));\n+   /*\n+   * Blind the input message and compute x*r+m as (x*r*b + m*b)/b\n+   */\n+   m_b = m_mod_q.square(m_b);\n+   m_b_inv = m_mod_q.square(m_b_inv);\n+\n+   m = m_mod_q.multiply(m_b, m);\n+   const BigInt xr = m_mod_q.multiply(m_mod_q.multiply(m_x, m_b), r);\n+\n+   const BigInt s = m_mod_q.multiply(m_b_inv, m_mod_q.multiply(k_inv, xr + m));\n \n    // With overwhelming probability, a bug rather than actual zero r/s\n    if(r.is_zero() || s.is_zero())\n@@ -140,7 +157,8 @@ class DSA_Verification_Operation final : public PK_Ops::Verification_with_EMSA\n          m_group(dsa.get_group()),\n          m_y(dsa.get_y()),\n          m_mod_q(dsa.group_q())\n-         {}\n+         {\n+         }\n \n       size_t max_input_bits() const override { return m_group.get_q().bits(); }\n \n@@ -193,12 +211,12 @@ DSA_PublicKey::create_verification_op(const std::string& params,\n    }\n \n std::unique_ptr<PK_Ops::Signature>\n-DSA_PrivateKey::create_signature_op(RandomNumberGenerator& /*rng*/,\n+DSA_PrivateKey::create_signature_op(RandomNumberGenerator& rng,\n                                     const std::string& params,\n                                     const std::string& provider) const\n    {\n    if(provider == \"base\" || provider.empty())\n-      return std::unique_ptr<PK_Ops::Signature>(new DSA_Signature_Operation(*this, params));\n+      return std::unique_ptr<PK_Ops::Signature>(new DSA_Signature_Operation(*this, params, rng));\n    throw Provider_Not_Found(algo_name(), provider);\n    }\n "
        },
        {
          "filename": "src/lib/pubkey/ec_group/ec_group.cpp",
          "status": "modified",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -84,11 +84,21 @@ class EC_Group_Data final\n \n       BigInt mod_order(const BigInt& x) const { return m_mod_order.reduce(x); }\n \n+      BigInt square_mod_order(const BigInt& x) const\n+         {\n+         return m_mod_order.square(x);\n+         }\n+\n       BigInt multiply_mod_order(const BigInt& x, const BigInt& y) const\n          {\n          return m_mod_order.multiply(x, y);\n          }\n \n+      BigInt multiply_mod_order(const BigInt& x, const BigInt& y, const BigInt& z) const\n+         {\n+         return m_mod_order.multiply(m_mod_order.multiply(x, y), z);\n+         }\n+\n       BigInt inverse_mod_order(const BigInt& x) const\n          {\n          return inverse_mod(x, m_order);\n@@ -477,11 +487,21 @@ BigInt EC_Group::mod_order(const BigInt& k) const\n    return data().mod_order(k);\n    }\n \n+BigInt EC_Group::square_mod_order(const BigInt& x) const\n+   {\n+   return data().square_mod_order(x);\n+   }\n+\n BigInt EC_Group::multiply_mod_order(const BigInt& x, const BigInt& y) const\n    {\n    return data().multiply_mod_order(x, y);\n    }\n \n+BigInt EC_Group::multiply_mod_order(const BigInt& x, const BigInt& y, const BigInt& z) const\n+   {\n+   return data().multiply_mod_order(x, y, z);\n+   }\n+\n BigInt EC_Group::inverse_mod_order(const BigInt& x) const\n    {\n    return data().inverse_mod_order(x);"
        },
        {
          "filename": "src/lib/pubkey/ec_group/ec_group.h",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -203,11 +203,21 @@ class BOTAN_PUBLIC_API(2,0) EC_Group final\n       */\n       BigInt inverse_mod_order(const BigInt& x) const;\n \n+      /*\n+      * Reduce (x*x) modulo the order\n+      */\n+      BigInt square_mod_order(const BigInt& x) const;\n+\n       /*\n       * Reduce (x*y) modulo the order\n       */\n       BigInt multiply_mod_order(const BigInt& x, const BigInt& y) const;\n \n+      /*\n+      * Reduce (x*y*z) modulo the order\n+      */\n+      BigInt multiply_mod_order(const BigInt& x, const BigInt& y, const BigInt& z) const;\n+\n       /**\n       * Return the cofactor\n       * @result the cofactor"
        },
        {
          "filename": "src/lib/pubkey/ecdsa/ecdsa.cpp",
          "status": "modified",
          "additions": 22,
          "deletions": 7,
          "patch": "@@ -51,14 +51,18 @@ class ECDSA_Signature_Operation final : public PK_Ops::Signature_with_EMSA\n    public:\n \n       ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,\n-                                const std::string& emsa) :\n+                                const std::string& emsa,\n+                                RandomNumberGenerator& rng) :\n          PK_Ops::Signature_with_EMSA(emsa),\n          m_group(ecdsa.domain()),\n          m_x(ecdsa.private_value())\n          {\n #if defined(BOTAN_HAS_RFC6979_GENERATOR)\n          m_rfc6979_hash = hash_for_emsa(emsa);\n #endif\n+\n+         m_b = m_group.random_scalar(rng);\n+         m_b_inv = m_group.inverse_mod_order(m_b);\n          }\n \n       size_t max_input_bits() const override { return m_group.get_order_bits(); }\n@@ -75,6 +79,8 @@ class ECDSA_Signature_Operation final : public PK_Ops::Signature_with_EMSA\n #endif\n \n       std::vector<BigInt> m_ws;\n+\n+      BigInt m_b, m_b_inv;\n    };\n \n secure_vector<uint8_t>\n@@ -89,12 +95,21 @@ ECDSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n    const BigInt k = m_group.random_scalar(rng);\n #endif\n \n-   const BigInt k_inv = m_group.inverse_mod_order(k);\n    const BigInt r = m_group.mod_order(\n       m_group.blinded_base_point_multiply_x(k, rng, m_ws));\n \n-   const BigInt xrm = m_group.mod_order(m_group.multiply_mod_order(m_x, r) + m);\n-   const BigInt s = m_group.multiply_mod_order(k_inv, xrm);\n+   const BigInt k_inv = m_group.inverse_mod_order(k);\n+\n+   /*\n+   * Blind the input message and compute x*r+m as (x*r*b + m*b)/b\n+   */\n+   m_b = m_group.square_mod_order(m_b);\n+   m_b_inv = m_group.square_mod_order(m_b_inv);\n+\n+   m = m_group.multiply_mod_order(m_b, m);\n+   const BigInt xr = m_group.multiply_mod_order(m_x, m_b, r);\n+\n+   const BigInt s = m_group.multiply_mod_order(k_inv, xr + m, m_b_inv);\n \n    // With overwhelming probability, a bug rather than actual zero r/s\n    if(r.is_zero() || s.is_zero())\n@@ -144,7 +159,7 @@ bool ECDSA_Verification_Operation::verify(const uint8_t msg[], size_t msg_len,\n \n    const BigInt w = m_group.inverse_mod_order(s);\n \n-   const BigInt u1 = m_group.multiply_mod_order(e, w);\n+   const BigInt u1 = m_group.multiply_mod_order(m_group.mod_order(e), w);\n    const BigInt u2 = m_group.multiply_mod_order(r, w);\n    const PointGFp R = m_gy_mul.multi_exp(u1, u2);\n \n@@ -198,7 +213,7 @@ ECDSA_PublicKey::create_verification_op(const std::string& params,\n    }\n \n std::unique_ptr<PK_Ops::Signature>\n-ECDSA_PrivateKey::create_signature_op(RandomNumberGenerator& /*rng*/,\n+ECDSA_PrivateKey::create_signature_op(RandomNumberGenerator& rng,\n                                       const std::string& params,\n                                       const std::string& provider) const\n    {\n@@ -233,7 +248,7 @@ ECDSA_PrivateKey::create_signature_op(RandomNumberGenerator& /*rng*/,\n #endif\n \n    if(provider == \"base\" || provider.empty())\n-      return std::unique_ptr<PK_Ops::Signature>(new ECDSA_Signature_Operation(*this, params));\n+      return std::unique_ptr<PK_Ops::Signature>(new ECDSA_Signature_Operation(*this, params, rng));\n \n    throw Provider_Not_Found(algo_name(), provider);\n    }"
        }
      ],
      "file_patterns": {
        "security_files": 5,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 4,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "373fcb730affe95275525dc21b98ee4725231941",
            "date": "2025-01-26T02:02:55Z",
            "author_login": "randombit"
          },
          {
            "sha": "37306e79366acf9ac1b38094d9afaec568f7f945",
            "date": "2025-01-25T23:52:11Z",
            "author_login": "randombit"
          },
          {
            "sha": "79027d2410086547374dea517e45258e5e7261fe",
            "date": "2025-01-24T17:16:03Z",
            "author_login": "reneme"
          },
          {
            "sha": "770eadb51c3c2714b4746872302a3a91ee9f5b36",
            "date": "2025-01-24T13:53:06Z",
            "author_login": "randombit"
          },
          {
            "sha": "8e7ab0ecbce07731d518c7673cf2b182e1972c74",
            "date": "2025-01-24T13:49:46Z",
            "author_login": "randombit"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-200",
    "description": "Botan 2.5.0 through 2.6.0 before 2.7.0 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP, related to dsa/dsa.cpp, ec_group/ec_group.cpp, and ecdsa/ecdsa.cpp. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-06-15T02:29:00.377",
    "last_modified": "2024-11-21T03:45:12.927",
    "fix_date": "2018-06-05T22:40:14Z"
  },
  "references": [
    {
      "url": "https://botan.randombit.net/security.html",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/randombit/botan/commit/48fc8df51d99f9d8ba251219367b3d629cc848e3",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.nccgroup.trust/us/our-research/technical-advisory-return-of-the-hidden-number-problem/",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://botan.randombit.net/security.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/randombit/botan/commit/48fc8df51d99f9d8ba251219367b3d629cc848e3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.nccgroup.trust/us/our-research/technical-advisory-return-of-the-hidden-number-problem/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:28.533818",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "botan",
    "owner": "randombit",
    "created_at": "2013-03-06T16:51:39Z",
    "updated_at": "2025-01-26T02:02:59Z",
    "pushed_at": "2025-01-26T02:46:19Z",
    "size": 107162,
    "stars": 2811,
    "forks": 577,
    "open_issues": 219,
    "watchers": 2811,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "insito-bib",
      "master",
      "release-1_8",
      "release-1_10",
      "release-2"
    ],
    "languages": {
      "C++": 9996118,
      "Python": 672287,
      "C": 204972,
      "Shell": 26311,
      "CMake": 8895,
      "PowerShell": 1888,
      "Emacs Lisp": 1313,
      "HTML": 184
    },
    "commit_activity": {
      "total_commits_last_year": 1307,
      "avg_commits_per_week": 25.134615384615383,
      "days_active_last_year": 251
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-2-clause"
    },
    "collected_at": "2025-01-26T07:36:07.549517"
  }
}