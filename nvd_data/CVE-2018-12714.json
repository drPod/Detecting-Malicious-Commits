{
  "cve_id": "CVE-2018-12714",
  "github_data": {
    "repository": "torvalds/linux",
    "fix_commit": "81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
    "related_commits": [
      "81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
      "81f9c4e4177d31ced6f52a89bb70e93bfb77ca03"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
      "commit_date": "2018-06-23T22:23:28Z",
      "author": {
        "login": "torvalds",
        "type": "User",
        "stats": {
          "total_commits": 38557,
          "average_weekly_commits": 32.37363560033585,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 881
        }
      },
      "commit_message": {
        "title": "Merge tag 'trace-v4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace",
        "length": 967,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 47,
        "additions": 28,
        "deletions": 19
      },
      "files": [
        {
          "filename": "Documentation/trace/histogram.txt",
          "status": "modified",
          "additions": 12,
          "deletions": 11,
          "patch": "@@ -1729,35 +1729,35 @@ If a variable isn't a key variable or prefixed with 'vals=', the\n associated event field will be saved in a variable but won't be summed\n as a value:\n \n-  # echo 'hist:keys=next_pid:ts1=common_timestamp ... >> event/trigger\n+  # echo 'hist:keys=next_pid:ts1=common_timestamp ...' >> event/trigger\n \n Multiple variables can be assigned at the same time.  The below would\n result in both ts0 and b being created as variables, with both\n common_timestamp and field1 additionally being summed as values:\n \n-  # echo 'hist:keys=pid:vals=$ts0,$b:ts0=common_timestamp,b=field1 ... >> \\\n+  # echo 'hist:keys=pid:vals=$ts0,$b:ts0=common_timestamp,b=field1 ...' >> \\\n \tevent/trigger\n \n Note that variable assignments can appear either preceding or\n following their use.  The command below behaves identically to the\n command above:\n \n-  # echo 'hist:keys=pid:ts0=common_timestamp,b=field1:vals=$ts0,$b ... >> \\\n+  # echo 'hist:keys=pid:ts0=common_timestamp,b=field1:vals=$ts0,$b ...' >> \\\n \tevent/trigger\n \n Any number of variables not bound to a 'vals=' prefix can also be\n assigned by simply separating them with colons.  Below is the same\n thing but without the values being summed in the histogram:\n \n-  # echo 'hist:keys=pid:ts0=common_timestamp:b=field1 ... >> event/trigger\n+  # echo 'hist:keys=pid:ts0=common_timestamp:b=field1 ...' >> event/trigger\n \n Variables set as above can be referenced and used in expressions on\n another event.\n \n For example, here's how a latency can be calculated:\n \n-  # echo 'hist:keys=pid,prio:ts0=common_timestamp ... >> event1/trigger\n-  # echo 'hist:keys=next_pid:wakeup_lat=common_timestamp-$ts0 ... >> event2/trigger\n+  # echo 'hist:keys=pid,prio:ts0=common_timestamp ...' >> event1/trigger\n+  # echo 'hist:keys=next_pid:wakeup_lat=common_timestamp-$ts0 ...' >> event2/trigger\n \n In the first line above, the event's timetamp is saved into the\n variable ts0.  In the next line, ts0 is subtracted from the second\n@@ -1766,7 +1766,7 @@ yet another variable, 'wakeup_lat'.  The hist trigger below in turn\n makes use of the wakeup_lat variable to compute a combined latency\n using the same key and variable from yet another event:\n \n-  # echo 'hist:key=pid:wakeupswitch_lat=$wakeup_lat+$switchtime_lat ... >> event3/trigger\n+  # echo 'hist:key=pid:wakeupswitch_lat=$wakeup_lat+$switchtime_lat ...' >> event3/trigger\n \n 2.2.2 Synthetic Events\n ----------------------\n@@ -1807,10 +1807,11 @@ the command that defined it with a '!':\n At this point, there isn't yet an actual 'wakeup_latency' event\n instantiated in the event subsytem - for this to happen, a 'hist\n trigger action' needs to be instantiated and bound to actual fields\n-and variables defined on other events (see Section 6.3.3 below).\n+and variables defined on other events (see Section 2.2.3 below on\n+how that is done using hist trigger 'onmatch' action). Once that is\n+done, the 'wakeup_latency' synthetic event instance is created.\n \n-Once that is done, an event instance is created, and a histogram can\n-be defined using it:\n+A histogram can now be defined for the new synthetic event:\n \n   # echo 'hist:keys=pid,prio,lat.log2:sort=pid,lat' >> \\\n         /sys/kernel/debug/tracing/events/synthetic/wakeup_latency/trigger\n@@ -1960,7 +1961,7 @@ hist trigger specification.\n     back to that pid, the timestamp difference is calculated.  If the\n     resulting latency, stored in wakeup_lat, exceeds the current\n     maximum latency, the values specified in the save() fields are\n-    recoreded:\n+    recorded:\n \n     # echo 'hist:keys=pid:ts0=common_timestamp.usecs \\\n             if comm==\"cyclictest\"' >> \\"
        },
        {
          "filename": "kernel/softirq.c",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -139,9 +139,13 @@ static void __local_bh_enable(unsigned int cnt)\n {\n \tlockdep_assert_irqs_disabled();\n \n+\tif (preempt_count() == cnt)\n+\t\ttrace_preempt_on(CALLER_ADDR0, get_lock_parent_ip());\n+\n \tif (softirq_count() == (cnt & SOFTIRQ_MASK))\n \t\ttrace_softirqs_on(_RET_IP_);\n-\tpreempt_count_sub(cnt);\n+\n+\t__preempt_count_sub(cnt);\n }\n \n /*"
        },
        {
          "filename": "kernel/trace/trace.c",
          "status": "modified",
          "additions": 1,
          "deletions": 5,
          "patch": "@@ -1360,8 +1360,6 @@ __update_max_tr(struct trace_array *tr, struct task_struct *tsk, int cpu)\n void\n update_max_tr(struct trace_array *tr, struct task_struct *tsk, int cpu)\n {\n-\tstruct ring_buffer *buf;\n-\n \tif (tr->stop_count)\n \t\treturn;\n \n@@ -1375,9 +1373,7 @@ update_max_tr(struct trace_array *tr, struct task_struct *tsk, int cpu)\n \n \tarch_spin_lock(&tr->max_lock);\n \n-\tbuf = tr->trace_buffer.buffer;\n-\ttr->trace_buffer.buffer = tr->max_buffer.buffer;\n-\ttr->max_buffer.buffer = buf;\n+\tswap(tr->trace_buffer.buffer, tr->max_buffer.buffer);\n \n \t__update_max_tr(tr, tsk, cpu);\n \tarch_spin_unlock(&tr->max_lock);"
        },
        {
          "filename": "kernel/trace/trace_events_filter.c",
          "status": "modified",
          "additions": 9,
          "deletions": 1,
          "patch": "@@ -78,7 +78,8 @@ static const char * ops[] = { OPS };\n \tC(TOO_MANY_PREDS,\t\"Too many terms in predicate expression\"), \\\n \tC(INVALID_FILTER,\t\"Meaningless filter expression\"),\t\\\n \tC(IP_FIELD_ONLY,\t\"Only 'ip' field is supported for function trace\"), \\\n-\tC(INVALID_VALUE,\t\"Invalid value (did you forget quotes)?\"),\n+\tC(INVALID_VALUE,\t\"Invalid value (did you forget quotes)?\"), \\\n+\tC(NO_FILTER,\t\t\"No filter found\"),\n \n #undef C\n #define C(a, b)\t\tFILT_ERR_##a\n@@ -550,6 +551,13 @@ predicate_parse(const char *str, int nr_parens, int nr_preds,\n \t\tgoto out_free;\n \t}\n \n+\tif (!N) {\n+\t\t/* No program? */\n+\t\tret = -EINVAL;\n+\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);\n+\t\tgoto out_free;\n+\t}\n+\n \tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n \tprog[N].target = 1;\t\t/* TRUE */\n \tprog[N+1].pred = NULL;"
        },
        {
          "filename": "scripts/Makefile.build",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -239,6 +239,7 @@ cmd_record_mcount =\t\t\t\t\t\t\\\n \t     \"$(CC_FLAGS_FTRACE)\" ]; then\t\t\t\\\n \t\t$(sub_cmd_record_mcount)\t\t\t\\\n \tfi;\n+endif # -record-mcount\n endif # CONFIG_FTRACE_MCOUNT_RECORD\n \n ifdef CONFIG_STACK_VALIDATION\n@@ -263,7 +264,6 @@ ifneq ($(RETPOLINE_CFLAGS),)\n   objtool_args += --retpoline\n endif\n endif\n-endif\n \n \n ifdef CONFIG_MODVERSIONS"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 4,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "aa22f4da2a46b484a257d167c67a2adc1b7aaf68",
            "date": "2025-01-26T00:23:38Z",
            "author_login": "torvalds"
          },
          {
            "sha": "eda061cccd146fcbe71051bb4aa5a8672b71216e",
            "date": "2025-01-26T00:19:10Z",
            "author_login": "torvalds"
          },
          {
            "sha": "08de7f9d4d39fd9aa5e747a13acc891214fa2d5f",
            "date": "2025-01-26T00:12:07Z",
            "author_login": "torvalds"
          },
          {
            "sha": "647d69605c70368d54fc012fce8a43e8e5955b04",
            "date": "2025-01-26T00:03:40Z",
            "author_login": "torvalds"
          },
          {
            "sha": "184a0997fb77f4a9527fc867fcd16806776c27ce",
            "date": "2025-01-25T23:59:46Z",
            "author_login": "torvalds"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-787",
    "description": "An issue was discovered in the Linux kernel through 4.17.2. The filter parsing in kernel/trace/trace_events_filter.c could be called with no filter, which is an N=0 case when it expected at least one line to have been read, thus making the N-1 index invalid. This allows attackers to cause a denial of service (slab out-of-bounds write) or possibly have unspecified other impact via crafted perf_event_open and mmap system calls.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2018-06-24T23:29:00.333",
    "last_modified": "2024-11-21T03:45:43.577",
    "fix_date": "2018-06-23T22:23:28Z"
  },
  "references": [
    {
      "url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/104544",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://bugzilla.kernel.org/show_bug.cgi?id=200019",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/lcytxw/bug_repro/tree/master/bug_200019",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.securityfocus.com/bid/104544",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://bugzilla.kernel.org/show_bug.cgi?id=200019",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/lcytxw/bug_repro/tree/master/bug_200019",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:28.545059",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "linux",
    "owner": "torvalds",
    "created_at": "2011-09-04T22:48:12Z",
    "updated_at": "2025-01-14T12:39:03Z",
    "pushed_at": "2025-01-13T17:27:04Z",
    "size": 5361369,
    "stars": 185823,
    "forks": 54743,
    "open_issues": 437,
    "watchers": 185823,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1326937103,
      "Assembly": 9568292,
      "Shell": 5072004,
      "Python": 2974128,
      "Makefile": 2713905,
      "Perl": 1253637,
      "Rust": 807711,
      "Roff": 202277,
      "C++": 173382,
      "SmPL": 165946,
      "Yacc": 127472,
      "Lex": 71321,
      "Awk": 69539,
      "Jinja": 30138,
      "UnrealScript": 16848,
      "Gherkin": 10172,
      "M4": 3329,
      "MATLAB": 2482,
      "sed": 2433,
      "Clojure": 2411,
      "XS": 1239,
      "RPC": 962
    },
    "commit_activity": {
      "total_commits_last_year": 46007,
      "avg_commits_per_week": 884.75,
      "days_active_last_year": 359
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T12:53:59.486675"
  }
}