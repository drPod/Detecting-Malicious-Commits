{
  "cve_id": "CVE-2018-14774",
  "github_data": {
    "repository": "symfony/symfony",
    "fix_commit": "725dee4cd8b4ccd52e335ae4b4522242cea9bd4a",
    "related_commits": [
      "725dee4cd8b4ccd52e335ae4b4522242cea9bd4a",
      "725dee4cd8b4ccd52e335ae4b4522242cea9bd4a"
    ],
    "patch_url": "https://github.com/symfony/symfony/commit/725dee4cd8b4ccd52e335ae4b4522242cea9bd4a.patch",
    "fix_commit_details": {
      "sha": "725dee4cd8b4ccd52e335ae4b4522242cea9bd4a",
      "commit_date": "2018-07-31T12:39:31Z",
      "author": {
        "login": "nicolas-grekas",
        "type": "User",
        "stats": {
          "total_commits": 16251,
          "average_weekly_commits": 20.70191082802548,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 533
        }
      },
      "commit_message": {
        "title": "[HttpKernel] fix trusted headers management in HttpCache and InlineFragmentRenderer",
        "length": 83,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 442,
        "additions": 350,
        "deletions": 92
      },
      "files": [
        {
          "filename": "src/Symfony/Component/HttpFoundation/Request.php",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -1944,6 +1944,11 @@ private function getTrustedValues($type, $ip = null)\n         if (self::$trustedHeaders[self::HEADER_FORWARDED] && $this->headers->has(self::$trustedHeaders[self::HEADER_FORWARDED])) {\n             $forwardedValues = $this->headers->get(self::$trustedHeaders[self::HEADER_FORWARDED]);\n             $forwardedValues = preg_match_all(sprintf('{(?:%s)=(?:\"?\\[?)([a-zA-Z0-9\\.:_\\-/]*+)}', self::$forwardedParams[$type]), $forwardedValues, $matches) ? $matches[1] : array();\n+            if (self::HEADER_CLIENT_PORT === $type) {\n+                foreach ($forwardedValues as $k => $v) {\n+                    $forwardedValues[$k] = substr_replace($v, '0.0.0.0', 0, strrpos($v, ':'));\n+                }\n+            }\n         }\n \n         if (null !== $ip) {"
        },
        {
          "filename": "src/Symfony/Component/HttpKernel/Fragment/InlineFragmentRenderer.php",
          "status": "modified",
          "additions": 2,
          "deletions": 27,
          "patch": "@@ -16,6 +16,7 @@\n use Symfony\\Component\\HttpFoundation\\Response;\n use Symfony\\Component\\HttpKernel\\Controller\\ControllerReference;\n use Symfony\\Component\\HttpKernel\\Event\\GetResponseForExceptionEvent;\n+use Symfony\\Component\\HttpKernel\\HttpCache\\SubRequestHandler;\n use Symfony\\Component\\HttpKernel\\HttpKernelInterface;\n use Symfony\\Component\\HttpKernel\\KernelEvents;\n \n@@ -76,7 +77,7 @@ public function render($uri, Request $request, array $options = array())\n \n         $level = ob_get_level();\n         try {\n-            return $this->kernel->handle($subRequest, HttpKernelInterface::SUB_REQUEST, false);\n+            return SubRequestHandler::handle($this->kernel, $subRequest, HttpKernelInterface::SUB_REQUEST, false);\n         } catch (\\Exception $e) {\n             // we dispatch the exception event to trigger the logging\n             // the response that comes back is simply ignored\n@@ -109,21 +110,6 @@ protected function createSubRequest($uri, Request $request)\n         $cookies = $request->cookies->all();\n         $server = $request->server->all();\n \n-        // Override the arguments to emulate a sub-request.\n-        // Sub-request object will point to localhost as client ip and real client ip\n-        // will be included into trusted header for client ip\n-        try {\n-            if ($trustedHeaderName = Request::getTrustedHeaderName(Request::HEADER_CLIENT_IP)) {\n-                $currentXForwardedFor = $request->headers->get($trustedHeaderName, '');\n-\n-                $server['HTTP_'.$trustedHeaderName] = ($currentXForwardedFor ? $currentXForwardedFor.', ' : '').$request->getClientIp();\n-            }\n-        } catch (\\InvalidArgumentException $e) {\n-            // Do nothing\n-        }\n-\n-        $server['REMOTE_ADDR'] = $this->resolveTrustedProxy();\n-\n         unset($server['HTTP_IF_MODIFIED_SINCE']);\n         unset($server['HTTP_IF_NONE_MATCH']);\n \n@@ -139,17 +125,6 @@ protected function createSubRequest($uri, Request $request)\n         return $subRequest;\n     }\n \n-    private function resolveTrustedProxy()\n-    {\n-        if (!$trustedProxies = Request::getTrustedProxies()) {\n-            return '127.0.0.1';\n-        }\n-\n-        $firstTrustedProxy = reset($trustedProxies);\n-\n-        return false !== ($i = strpos($firstTrustedProxy, '/')) ? substr($firstTrustedProxy, 0, $i) : $firstTrustedProxy;\n-    }\n-\n     /**\n      * {@inheritdoc}\n      */"
        },
        {
          "filename": "src/Symfony/Component/HttpKernel/HttpCache/HttpCache.php",
          "status": "modified",
          "additions": 1,
          "deletions": 20,
          "patch": "@@ -468,27 +468,8 @@ protected function forward(Request $request, $catch = false, Response $entry = n\n             $this->surrogate->addSurrogateCapability($request);\n         }\n \n-        // modify the X-Forwarded-For header if needed\n-        $forwardedFor = $request->headers->get('X-Forwarded-For');\n-        if ($forwardedFor) {\n-            $request->headers->set('X-Forwarded-For', $forwardedFor.', '.$request->server->get('REMOTE_ADDR'));\n-        } else {\n-            $request->headers->set('X-Forwarded-For', $request->server->get('REMOTE_ADDR'));\n-        }\n-\n-        // fix the client IP address by setting it to 127.0.0.1 as HttpCache\n-        // is always called from the same process as the backend.\n-        $request->server->set('REMOTE_ADDR', '127.0.0.1');\n-\n-        // make sure HttpCache is a trusted proxy\n-        if (!\\in_array('127.0.0.1', $trustedProxies = Request::getTrustedProxies())) {\n-            $trustedProxies[] = '127.0.0.1';\n-            Request::setTrustedProxies($trustedProxies);\n-        }\n-\n         // always a \"master\" request (as the real master request can be in cache)\n-        $response = $this->kernel->handle($request, HttpKernelInterface::MASTER_REQUEST, $catch);\n-        // FIXME: we probably need to also catch exceptions if raw === true\n+        $response = SubRequestHandler::handle($this->kernel, $request, HttpKernelInterface::MASTER_REQUEST, $catch);\n \n         // we don't implement the stale-if-error on Requests, which is nonetheless part of the RFC\n         if (null !== $entry && \\in_array($response->getStatusCode(), array(500, 502, 503, 504))) {"
        },
        {
          "filename": "src/Symfony/Component/HttpKernel/HttpCache/SubRequestHandler.php",
          "status": "added",
          "additions": 100,
          "deletions": 0,
          "patch": "@@ -0,0 +1,100 @@\n+<?php\n+\n+/*\n+ * This file is part of the Symfony package.\n+ *\n+ * (c) Fabien Potencier <fabien@symfony.com>\n+ *\n+ * For the full copyright and license information, please view the LICENSE\n+ * file that was distributed with this source code.\n+ */\n+\n+namespace Symfony\\Component\\HttpKernel\\HttpCache;\n+\n+use Symfony\\Component\\HttpFoundation\\IpUtils;\n+use Symfony\\Component\\HttpFoundation\\Request;\n+use Symfony\\Component\\HttpFoundation\\Response;\n+use Symfony\\Component\\HttpKernel\\HttpKernelInterface;\n+\n+/**\n+ * @author Nicolas Grekas <p@tchwork.com>\n+ *\n+ * @internal\n+ */\n+class SubRequestHandler\n+{\n+    /**\n+     * @return Response\n+     */\n+    public static function handle(HttpKernelInterface $kernel, Request $request, $type, $catch)\n+    {\n+        // save global state related to trusted headers and proxies\n+        $trustedProxies = Request::getTrustedProxies();\n+        $trustedHeaders = array(\n+            Request::HEADER_FORWARDED => Request::getTrustedHeaderName(Request::HEADER_FORWARDED),\n+            Request::HEADER_CLIENT_IP => Request::getTrustedHeaderName(Request::HEADER_CLIENT_IP),\n+            Request::HEADER_CLIENT_HOST => Request::getTrustedHeaderName(Request::HEADER_CLIENT_HOST),\n+            Request::HEADER_CLIENT_PROTO => Request::getTrustedHeaderName(Request::HEADER_CLIENT_PROTO),\n+            Request::HEADER_CLIENT_PORT => Request::getTrustedHeaderName(Request::HEADER_CLIENT_PORT),\n+        );\n+\n+        // remove untrusted values\n+        $remoteAddr = $request->server->get('REMOTE_ADDR');\n+        if (!IpUtils::checkIp($remoteAddr, $trustedProxies)) {\n+            foreach (array_filter($trustedHeaders) as $name) {\n+                $request->headers->remove($name);\n+            }\n+        }\n+\n+        // compute trusted values, taking any trusted proxies into account\n+        $trustedIps = array();\n+        $trustedValues = array();\n+        foreach (array_reverse($request->getClientIps()) as $ip) {\n+            $trustedIps[] = $ip;\n+            $trustedValues[] = sprintf('for=\"%s\"', $ip);\n+        }\n+        if ($ip !== $remoteAddr) {\n+            $trustedIps[] = $remoteAddr;\n+            $trustedValues[] = sprintf('for=\"%s\"', $remoteAddr);\n+        }\n+\n+        // set trusted values, reusing as much as possible the global trusted settings\n+        if ($name = $trustedHeaders[Request::HEADER_FORWARDED]) {\n+            $trustedValues[0] .= sprintf(';host=\"%s\";proto=%s', $request->getHttpHost(), $request->getScheme());\n+            $request->headers->set($name, implode(', ', $trustedValues));\n+        }\n+        if ($name = $trustedHeaders[Request::HEADER_CLIENT_IP]) {\n+            $request->headers->set($name, implode(', ', $trustedIps));\n+        }\n+        if (!$name && !$trustedHeaders[Request::HEADER_FORWARDED]) {\n+            $request->headers->set('X-Forwarded-For', implode(', ', $trustedIps));\n+            Request::setTrustedHeaderName(Request::HEADER_CLIENT_IP, 'X_FORWARDED_FOR');\n+        }\n+\n+        // fix the client IP address by setting it to 127.0.0.1,\n+        // which is the core responsibility of this method\n+        $request->server->set('REMOTE_ADDR', '127.0.0.1');\n+\n+        // ensure 127.0.0.1 is set as trusted proxy\n+        if (!IpUtils::checkIp('127.0.0.1', $trustedProxies)) {\n+            Request::setTrustedProxies(array_merge($trustedProxies, array('127.0.0.1')));\n+        }\n+\n+        try {\n+            $e = null;\n+            $response = $kernel->handle($request, $type, $catch);\n+        } catch (\\Throwable $e) {\n+        } catch (\\Exception $e) {\n+        }\n+\n+        // restore global state\n+        Request::setTrustedHeaderName(Request::HEADER_CLIENT_IP, $trustedHeaders[Request::HEADER_CLIENT_IP]);\n+        Request::setTrustedProxies($trustedProxies);\n+\n+        if (null !== $e) {\n+            throw $e;\n+        }\n+\n+        return $response;\n+    }\n+}"
        },
        {
          "filename": "src/Symfony/Component/HttpKernel/Tests/Fragment/InlineFragmentRendererTest.php",
          "status": "modified",
          "additions": 20,
          "deletions": 18,
          "patch": "@@ -26,12 +26,16 @@ class InlineFragmentRendererTest extends TestCase\n \n     protected function setUp()\n     {\n-        $this->originalTrustedHeaderName = Request::getTrustedHeaderName(Request::HEADER_CLIENT_IP);\n+        $this->originalTrustedHeaderNames = array(\n+            Request::getTrustedHeaderName(Request::HEADER_CLIENT_IP),\n+            Request::getTrustedHeaderName(Request::HEADER_FORWARDED),\n+        );\n     }\n \n     protected function tearDown()\n     {\n-        Request::setTrustedHeaderName(Request::HEADER_CLIENT_IP, $this->originalTrustedHeaderName);\n+        Request::setTrustedHeaderName(Request::HEADER_CLIENT_IP, $this->originalTrustedHeaderNames[0]);\n+        Request::setTrustedHeaderName(Request::HEADER_FORWARDED, $this->originalTrustedHeaderNames[1]);\n     }\n \n     public function testRender()\n@@ -55,7 +59,7 @@ public function testRenderWithObjectsAsAttributes()\n         $subRequest = Request::create('/_fragment?_path=_format%3Dhtml%26_locale%3Den%26_controller%3Dmain_controller');\n         $subRequest->attributes->replace(array('object' => $object, '_format' => 'html', '_controller' => 'main_controller', '_locale' => 'en'));\n         $subRequest->headers->set('x-forwarded-for', array('127.0.0.1'));\n-        $subRequest->server->set('HTTP_X_FORWARDED_FOR', '127.0.0.1');\n+        $subRequest->headers->set('forwarded', array('for=\"127.0.0.1\";host=\"localhost\";proto=http'));\n \n         $strategy = new InlineFragmentRenderer($this->getKernelExpectingRequest($subRequest));\n \n@@ -83,8 +87,12 @@ public function testRenderWithObjectsAsAttributesPassedAsObjectsInTheController(\n     public function testRenderWithTrustedHeaderDisabled()\n     {\n         Request::setTrustedHeaderName(Request::HEADER_CLIENT_IP, '');\n+        Request::setTrustedHeaderName(Request::HEADER_FORWARDED, '');\n \n-        $strategy = new InlineFragmentRenderer($this->getKernelExpectingRequest(Request::create('/')));\n+        $expectedSubRequest = Request::create('/');\n+        $expectedSubRequest->headers->set('x-forwarded-for', array('127.0.0.1'));\n+\n+        $strategy = new InlineFragmentRenderer($this->getKernelExpectingRequest($expectedSubRequest));\n         $this->assertSame('foo', $strategy->render('/', Request::create('/'))->getContent());\n     }\n \n@@ -168,11 +176,10 @@ public function testESIHeaderIsKeptInSubrequest()\n     {\n         $expectedSubRequest = Request::create('/');\n         $expectedSubRequest->headers->set('Surrogate-Capability', 'abc=\"ESI/1.0\"');\n-\n         if (Request::getTrustedHeaderName(Request::HEADER_CLIENT_IP)) {\n             $expectedSubRequest->headers->set('x-forwarded-for', array('127.0.0.1'));\n-            $expectedSubRequest->server->set('HTTP_X_FORWARDED_FOR', '127.0.0.1');\n         }\n+        $expectedSubRequest->headers->set('forwarded', array('for=\"127.0.0.1\";host=\"localhost\";proto=http'));\n \n         $strategy = new InlineFragmentRenderer($this->getKernelExpectingRequest($expectedSubRequest));\n \n@@ -194,10 +201,8 @@ public function testESIHeaderIsKeptInSubrequestWithTrustedHeaderDisabled()\n     public function testHeadersPossiblyResultingIn304AreNotAssignedToSubrequest()\n     {\n         $expectedSubRequest = Request::create('/');\n-        if (Request::getTrustedHeaderName(Request::HEADER_CLIENT_IP)) {\n-            $expectedSubRequest->headers->set('x-forwarded-for', array('127.0.0.1'));\n-            $expectedSubRequest->server->set('HTTP_X_FORWARDED_FOR', '127.0.0.1');\n-        }\n+        $expectedSubRequest->headers->set('x-forwarded-for', array('127.0.0.1'));\n+        $expectedSubRequest->headers->set('forwarded', array('for=\"127.0.0.1\";host=\"localhost\";proto=http'));\n \n         $strategy = new InlineFragmentRenderer($this->getKernelExpectingRequest($expectedSubRequest));\n         $request = Request::create('/', 'GET', array(), array(), array(), array('HTTP_IF_MODIFIED_SINCE' => 'Fri, 01 Jan 2016 00:00:00 GMT', 'HTTP_IF_NONE_MATCH' => '*'));\n@@ -208,12 +213,9 @@ public function testFirstTrustedProxyIsSetAsRemote()\n     {\n         $expectedSubRequest = Request::create('/');\n         $expectedSubRequest->headers->set('Surrogate-Capability', 'abc=\"ESI/1.0\"');\n-        $expectedSubRequest->server->set('REMOTE_ADDR', '1.1.1.1');\n-\n-        if (Request::getTrustedHeaderName(Request::HEADER_CLIENT_IP)) {\n-            $expectedSubRequest->headers->set('x-forwarded-for', array('127.0.0.1'));\n-            $expectedSubRequest->server->set('HTTP_X_FORWARDED_FOR', '127.0.0.1');\n-        }\n+        $expectedSubRequest->server->set('REMOTE_ADDR', '127.0.0.1');\n+        $expectedSubRequest->headers->set('x-forwarded-for', array('127.0.0.1'));\n+        $expectedSubRequest->headers->set('forwarded', array('for=\"127.0.0.1\";host=\"localhost\";proto=http'));\n \n         Request::setTrustedProxies(array('1.1.1.1'));\n \n@@ -230,9 +232,9 @@ public function testIpAddressOfRangedTrustedProxyIsSetAsRemote()\n     {\n         $expectedSubRequest = Request::create('/');\n         $expectedSubRequest->headers->set('Surrogate-Capability', 'abc=\"ESI/1.0\"');\n-        $expectedSubRequest->server->set('REMOTE_ADDR', '1.1.1.1');\n+        $expectedSubRequest->server->set('REMOTE_ADDR', '127.0.0.1');\n         $expectedSubRequest->headers->set('x-forwarded-for', array('127.0.0.1'));\n-        $expectedSubRequest->server->set('HTTP_X_FORWARDED_FOR', '127.0.0.1');\n+        $expectedSubRequest->headers->set('forwarded', array('for=\"127.0.0.1\";host=\"localhost\";proto=http'));\n \n         Request::setTrustedProxies(array('1.1.1.1/24'));\n "
        },
        {
          "filename": "src/Symfony/Component/HttpKernel/Tests/HttpCache/HttpCacheTest.php",
          "status": "modified",
          "additions": 30,
          "deletions": 24,
          "patch": "@@ -1303,66 +1303,72 @@ public function testClientIpIsAlwaysLocalhostForForwardedRequests()\n         $this->setNextResponse();\n         $this->request('GET', '/', array('REMOTE_ADDR' => '10.0.0.1'));\n \n-        $this->assertEquals('127.0.0.1', $this->kernel->getBackendRequest()->server->get('REMOTE_ADDR'));\n+        $that = $this;\n+        $this->kernel->assert(function ($backendRequest) use ($that) {\n+            $that->assertSame('127.0.0.1', $backendRequest->server->get('REMOTE_ADDR'));\n+        });\n     }\n \n     /**\n      * @dataProvider getTrustedProxyData\n      */\n-    public function testHttpCacheIsSetAsATrustedProxy(array $existing, array $expected)\n+    public function testHttpCacheIsSetAsATrustedProxy(array $existing)\n     {\n         Request::setTrustedProxies($existing);\n \n         $this->setNextResponse();\n         $this->request('GET', '/', array('REMOTE_ADDR' => '10.0.0.1'));\n+        $this->assertSame($existing, Request::getTrustedProxies());\n \n-        $this->assertEquals($expected, Request::getTrustedProxies());\n+        $that = $this;\n+        $existing = array_unique(array_merge($existing, array('127.0.0.1')));\n+        $this->kernel->assert(function ($backendRequest) use ($existing, $that) {\n+            $that->assertSame($existing, Request::getTrustedProxies());\n+            $that->assertsame('10.0.0.1', $backendRequest->getClientIp());\n+        });\n \n         Request::setTrustedProxies(array());\n     }\n \n     public function getTrustedProxyData()\n     {\n         return array(\n-            array(array(), array('127.0.0.1')),\n-            array(array('10.0.0.2'), array('10.0.0.2', '127.0.0.1')),\n-            array(array('10.0.0.2', '127.0.0.1'), array('10.0.0.2', '127.0.0.1')),\n+            array(array()),\n+            array(array('10.0.0.2')),\n+            array(array('10.0.0.2', '127.0.0.1')),\n         );\n     }\n \n     /**\n-     * @dataProvider getXForwardedForData\n+     * @dataProvider getForwardedData\n      */\n-    public function testXForwarderForHeaderForForwardedRequests($xForwardedFor, $expected)\n+    public function testForwarderHeaderForForwardedRequests($forwarded, $expected)\n     {\n         $this->setNextResponse();\n         $server = array('REMOTE_ADDR' => '10.0.0.1');\n-        if (false !== $xForwardedFor) {\n-            $server['HTTP_X_FORWARDED_FOR'] = $xForwardedFor;\n+        if (null !== $forwarded) {\n+            Request::setTrustedProxies($server);\n+            $server['HTTP_FORWARDED'] = $forwarded;\n         }\n         $this->request('GET', '/', $server);\n \n-        $this->assertEquals($expected, $this->kernel->getBackendRequest()->headers->get('X-Forwarded-For'));\n+        $that = $this;\n+        $this->kernel->assert(function ($backendRequest) use ($expected, $that) {\n+            $that->assertSame($expected, $backendRequest->headers->get('Forwarded'));\n+        });\n+\n+        Request::setTrustedProxies(array());\n     }\n \n-    public function getXForwardedForData()\n+    public function getForwardedData()\n     {\n         return array(\n-            array(false, '10.0.0.1'),\n-            array('10.0.0.2', '10.0.0.2, 10.0.0.1'),\n-            array('10.0.0.2, 10.0.0.3', '10.0.0.2, 10.0.0.3, 10.0.0.1'),\n+            array(null, 'for=\"10.0.0.1\";host=\"localhost\";proto=http'),\n+            array('for=10.0.0.2', 'for=\"10.0.0.2\";host=\"localhost\";proto=http, for=\"10.0.0.1\"'),\n+            array('for=10.0.0.2, for=10.0.0.3', 'for=\"10.0.0.2\";host=\"localhost\";proto=http, for=\"10.0.0.3\", for=\"10.0.0.1\"'),\n         );\n     }\n \n-    public function testXForwarderForHeaderForPassRequests()\n-    {\n-        $this->setNextResponse();\n-        $server = array('REMOTE_ADDR' => '10.0.0.1');\n-        $this->request('POST', '/', $server);\n-\n-        $this->assertEquals('10.0.0.1', $this->kernel->getBackendRequest()->headers->get('X-Forwarded-For'));\n-    }\n-\n     public function testEsiCacheRemoveValidationHeadersIfEmbeddedResponses()\n     {\n         $time = \\DateTime::createFromFormat('U', time());"
        },
        {
          "filename": "src/Symfony/Component/HttpKernel/Tests/HttpCache/SubRequestHandlerTest.php",
          "status": "added",
          "additions": 168,
          "deletions": 0,
          "patch": "@@ -0,0 +1,168 @@\n+<?php\n+\n+/*\n+ * This file is part of the Symfony package.\n+ *\n+ * (c) Fabien Potencier <fabien@symfony.com>\n+ *\n+ * For the full copyright and license information, please view the LICENSE\n+ * file that was distributed with this source code.\n+ */\n+\n+namespace Symfony\\Component\\HttpKernel\\Tests\\HttpCache;\n+\n+use PHPUnit\\Framework\\TestCase;\n+use Symfony\\Component\\HttpFoundation\\Request;\n+use Symfony\\Component\\HttpFoundation\\Response;\n+use Symfony\\Component\\HttpKernel\\HttpCache\\SubRequestHandler;\n+use Symfony\\Component\\HttpKernel\\HttpKernelInterface;\n+\n+class SubRequestHandlerTest extends TestCase\n+{\n+    private static $globalState;\n+\n+    protected function setUp()\n+    {\n+        self::$globalState = $this->getGlobalState();\n+    }\n+\n+    protected function tearDown()\n+    {\n+        foreach (self::$globalState[1] as $key => $name) {\n+            Request::setTrustedHeaderName($key, $name);\n+        }\n+        Request::setTrustedProxies(self::$globalState[0]);\n+    }\n+\n+    public function testTrustedHeadersAreKept()\n+    {\n+        Request::setTrustedProxies(array('10.0.0.1'));\n+        $globalState = $this->getGlobalState();\n+\n+        $request = Request::create('/');\n+        $request->server->set('REMOTE_ADDR', '10.0.0.1');\n+        $request->headers->set('X-Forwarded-For', '10.0.0.2');\n+        $request->headers->set('X-Forwarded-Host', 'Good');\n+        $request->headers->set('X-Forwarded-Port', '1234');\n+        $request->headers->set('X-Forwarded-Proto', 'https');\n+\n+        $that = $this;\n+        $kernel = new TestSubRequestHandlerKernel(function ($request, $type, $catch) use ($that) {\n+            $that->assertSame('127.0.0.1', $request->server->get('REMOTE_ADDR'));\n+            $that->assertSame('10.0.0.2', $request->getClientIp());\n+            $that->assertSame('Good', $request->headers->get('X-Forwarded-Host'));\n+            $that->assertSame('1234', $request->headers->get('X-Forwarded-Port'));\n+            $that->assertSame('https', $request->headers->get('X-Forwarded-Proto'));\n+        });\n+\n+        SubRequestHandler::handle($kernel, $request, HttpKernelInterface::MASTER_REQUEST, true);\n+\n+        $this->assertSame($globalState, $this->getGlobalState());\n+    }\n+\n+    public function testUntrustedHeadersAreRemoved()\n+    {\n+        $request = Request::create('/');\n+        $request->server->set('REMOTE_ADDR', '10.0.0.1');\n+        $request->headers->set('X-Forwarded-For', '10.0.0.2');\n+        $request->headers->set('X-Forwarded-Host', 'Evil');\n+        $request->headers->set('X-Forwarded-Port', '1234');\n+        $request->headers->set('X-Forwarded-Proto', 'http');\n+        $request->headers->set('Forwarded', 'Evil2');\n+\n+        $that = $this;\n+        $kernel = new TestSubRequestHandlerKernel(function ($request, $type, $catch) use ($that) {\n+            $that->assertSame('127.0.0.1', $request->server->get('REMOTE_ADDR'));\n+            $that->assertSame('10.0.0.1', $request->getClientIp());\n+            $that->assertFalse($request->headers->has('X-Forwarded-Host'));\n+            $that->assertFalse($request->headers->has('X-Forwarded-Port'));\n+            $that->assertFalse($request->headers->has('X-Forwarded-Proto'));\n+            $that->assertSame('for=\"10.0.0.1\";host=\"localhost\";proto=http', $request->headers->get('Forwarded'));\n+        });\n+\n+        SubRequestHandler::handle($kernel, $request, HttpKernelInterface::MASTER_REQUEST, true);\n+\n+        $this->assertSame(self::$globalState, $this->getGlobalState());\n+    }\n+\n+    public function testTrustedForwardedHeader()\n+    {\n+        Request::setTrustedProxies(array('10.0.0.1'));\n+        $globalState = $this->getGlobalState();\n+\n+        $request = Request::create('/');\n+        $request->server->set('REMOTE_ADDR', '10.0.0.1');\n+        $request->headers->set('Forwarded', 'for=\"10.0.0.2\";host=\"foo.bar\";proto=https');\n+        $request->headers->set('X-Forwarded-Host', 'foo.bar');\n+        $request->headers->set('X-Forwarded-Proto', 'https');\n+\n+        $that = $this;\n+        $kernel = new TestSubRequestHandlerKernel(function ($request, $type, $catch) use ($that) {\n+            $that->assertSame('127.0.0.1', $request->server->get('REMOTE_ADDR'));\n+            $that->assertSame('10.0.0.2', $request->getClientIp());\n+            $that->assertSame('foo.bar', $request->getHttpHost());\n+            $that->assertSame('https', $request->getScheme());\n+            $that->assertSame(443, $request->getPort());\n+        });\n+\n+        SubRequestHandler::handle($kernel, $request, HttpKernelInterface::MASTER_REQUEST, true);\n+\n+        $this->assertSame($globalState, $this->getGlobalState());\n+    }\n+\n+    public function testTrustedXForwardedForHeader()\n+    {\n+        Request::setTrustedProxies(array('10.0.0.1'));\n+        $globalState = $this->getGlobalState();\n+\n+        $request = Request::create('/');\n+        $request->server->set('REMOTE_ADDR', '10.0.0.1');\n+        $request->headers->set('X-Forwarded-For', '10.0.0.2');\n+        $request->headers->set('X-Forwarded-Host', 'foo.bar');\n+        $request->headers->set('X-Forwarded-Proto', 'https');\n+\n+        $that = $this;\n+        $kernel = new TestSubRequestHandlerKernel(function ($request, $type, $catch) use ($that) {\n+            $that->assertSame('127.0.0.1', $request->server->get('REMOTE_ADDR'));\n+            $that->assertSame('10.0.0.2', $request->getClientIp());\n+            $that->assertSame('foo.bar', $request->getHttpHost());\n+            $that->assertSame('https', $request->getScheme());\n+        });\n+\n+        SubRequestHandler::handle($kernel, $request, HttpKernelInterface::MASTER_REQUEST, true);\n+\n+        $this->assertSame($globalState, $this->getGlobalState());\n+    }\n+\n+    private function getGlobalState()\n+    {\n+        return array(\n+            Request::getTrustedProxies(),\n+            array(\n+                Request::HEADER_FORWARDED => Request::getTrustedHeaderName(Request::HEADER_FORWARDED),\n+                Request::HEADER_CLIENT_IP => Request::getTrustedHeaderName(Request::HEADER_CLIENT_IP),\n+                Request::HEADER_CLIENT_HOST => Request::getTrustedHeaderName(Request::HEADER_CLIENT_HOST),\n+                Request::HEADER_CLIENT_PROTO => Request::getTrustedHeaderName(Request::HEADER_CLIENT_PROTO),\n+                Request::HEADER_CLIENT_PORT => Request::getTrustedHeaderName(Request::HEADER_CLIENT_PORT),\n+            ),\n+        );\n+    }\n+}\n+\n+class TestSubRequestHandlerKernel implements HttpKernelInterface\n+{\n+    private $assertCallback;\n+\n+    public function __construct(\\Closure $assertCallback)\n+    {\n+        $this->assertCallback = $assertCallback;\n+    }\n+\n+    public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true)\n+    {\n+        $assertCallback = $this->assertCallback;\n+        $assertCallback($request, $type, $catch);\n+\n+        return new Response();\n+    }\n+}"
        },
        {
          "filename": "src/Symfony/Component/HttpKernel/Tests/HttpCache/TestHttpKernel.php",
          "status": "modified",
          "additions": 24,
          "deletions": 3,
          "patch": "@@ -34,19 +34,40 @@ public function __construct($body, $status, $headers, \\Closure $customizer = nul\n         $this->status = $status;\n         $this->headers = $headers;\n         $this->customizer = $customizer;\n+        $this->trustedHeadersReflector = new \\ReflectionProperty('Symfony\\Component\\HttpFoundation\\Request', 'trustedHeaders');\n+        $this->trustedHeadersReflector->setAccessible(true);\n \n         parent::__construct(new EventDispatcher(), $this);\n     }\n \n-    public function getBackendRequest()\n+    public function assert(\\Closure $callback)\n     {\n-        return $this->backendRequest;\n+        $trustedConfig = array(Request::getTrustedProxies(), $this->trustedHeadersReflector->getValue());\n+\n+        list($trustedProxies, $trustedHeaders, $backendRequest) = $this->backendRequest;\n+        Request::setTrustedProxies($trustedProxies);\n+        $this->trustedHeadersReflector->setValue(null, $trustedHeaders);\n+\n+        try {\n+            $e = null;\n+            $callback($backendRequest);\n+        } catch (\\Throwable $e) {\n+        } catch (\\Exception $e) {\n+        }\n+\n+        list($trustedProxies, $trustedHeaders) = $trustedConfig;\n+        Request::setTrustedProxies($trustedProxies);\n+        $this->trustedHeadersReflector->setValue(null, $trustedHeaders);\n+\n+        if (null !== $e) {\n+            throw $e;\n+        }\n     }\n \n     public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = false)\n     {\n         $this->catch = $catch;\n-        $this->backendRequest = $request;\n+        $this->backendRequest = array($request::getTrustedProxies(), $this->trustedHeadersReflector->getValue(), $request);\n \n         return parent::handle($request, $type, $catch);\n     }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 5,
        "max_directory_depth": 6
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "f6312d3f3313afc62c5b1e920b2cbfe62fcf3f8e",
            "date": "2025-01-13T09:20:08Z",
            "author_login": "nicolas-grekas"
          },
          {
            "sha": "7b338721ca42ba1d5544658b39359916715170f4",
            "date": "2025-01-12T22:16:37Z",
            "author_login": "derrabus"
          },
          {
            "sha": "1a76f128845de80fe6644c7de12e0dcdad8197f1",
            "date": "2025-01-12T20:19:12Z",
            "author_login": "derrabus"
          },
          {
            "sha": "0d0758e87be2e990d7744e4e66b59e6609a2b3c9",
            "date": "2025-01-12T17:25:07Z",
            "author_login": "fabpot"
          },
          {
            "sha": "946278f9f8cd1bc40c075d37b1d6c2a289c8eb4c",
            "date": "2025-01-12T12:57:08Z",
            "author_login": "alamirault"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-20",
    "description": "An issue was discovered in HttpKernel in Symfony 2.7.0 through 2.7.48, 2.8.0 through 2.8.43, 3.3.0 through 3.3.17, 3.4.0 through 3.4.13, 4.0.0 through 4.0.13, and 4.1.0 through 4.1.2. When using HttpCache, the values of the X-Forwarded-Host headers are implicitly set as trusted while this should be forbidden, leading to potential host header injection.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-08-03T17:29:00.347",
    "last_modified": "2024-11-21T03:49:45.740",
    "fix_date": "2018-07-31T12:39:31Z"
  },
  "references": [
    {
      "url": "https://github.com/symfony/symfony/commit/725dee4cd8b4ccd52e335ae4b4522242cea9bd4a",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://symfony.com/blog/cve-2018-14774-possible-host-header-injection-when-using-httpcache",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/symfony/symfony/commit/725dee4cd8b4ccd52e335ae4b4522242cea9bd4a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://symfony.com/blog/cve-2018-14774-possible-host-header-injection-when-using-httpcache",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:32.426480",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "symfony",
    "owner": "symfony",
    "created_at": "2010-01-04T14:21:21Z",
    "updated_at": "2025-01-14T09:56:31Z",
    "pushed_at": "2025-01-13T13:22:56Z",
    "size": 290479,
    "stars": 29917,
    "forks": 9510,
    "open_issues": 879,
    "watchers": 29917,
    "has_security_policy": false,
    "default_branch": "7.3",
    "protected_branches": [
      "2.0",
      "2.1",
      "2.2",
      "2.3",
      "2.4",
      "2.5",
      "2.6",
      "2.7",
      "2.8",
      "3.0",
      "3.1",
      "3.2",
      "3.3",
      "3.4",
      "4.0",
      "4.1",
      "4.2",
      "4.3",
      "4.4",
      "5.0",
      "5.1",
      "5.2",
      "5.3",
      "5.4",
      "6.0",
      "6.1",
      "6.2",
      "6.3",
      "6.4",
      "7.0"
    ],
    "languages": {
      "PHP": 30007525,
      "Twig": 527335,
      "CSS": 56186,
      "JavaScript": 28225,
      "HTML": 16804,
      "Shell": 9654,
      "Makefile": 1612,
      "Hack": 26
    },
    "commit_activity": {
      "total_commits_last_year": 4163,
      "avg_commits_per_week": 80.0576923076923,
      "days_active_last_year": 343
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:44:47.171985"
  }
}