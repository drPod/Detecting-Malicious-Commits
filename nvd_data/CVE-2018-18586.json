{
  "cve_id": "CVE-2018-18586",
  "github_data": {
    "repository": "kyz/libmspack",
    "fix_commit": "7cadd489698be117c47efcadd742651594429e6d",
    "related_commits": [
      "7cadd489698be117c47efcadd742651594429e6d",
      "7cadd489698be117c47efcadd742651594429e6d"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "7cadd489698be117c47efcadd742651594429e6d",
      "commit_date": "2018-10-20T18:06:32Z",
      "author": {
        "login": "kyz",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "add anti \"../\" and leading slash protection to chmextract",
        "length": 57,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 150,
        "additions": 27,
        "deletions": 123
      },
      "files": [
        {
          "filename": "libmspack/ChangeLog",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -1,3 +1,13 @@\n+2018-10-20  Stuart Caie <kyzer@cabextract.org.uk>\n+\n+\t* src/chmextract.c: add anti \"../\" and leading slash protection to\n+\tchmextract. I'm not pleased about this. All the sample code provided\n+\twith libmspack is meant to be simple examples of library use, not\n+\t\"productised\" binaries. Making the \"useful\" code samples install\n+\tas binaries was a mistake. They were never intended to protect you\n+\tfrom unpacking archive files with relative/absolute paths, and I\n+\twould prefer that they never will be.\n+\n 2018-10-17  Stuart Caie <kyzer@cabextract.org.uk>\n \n \t* cab.h: Make the CAB block input buffer one byte larger, to allow"
        },
        {
          "filename": "libmspack/src/chmextract.c",
          "status": "modified",
          "additions": 17,
          "deletions": 123,
          "patch": "@@ -25,8 +25,6 @@\n \n mode_t user_umask;\n \n-#define FILENAME \".test.chmx\"\n-\n /**\n  * Ensures that all directory components in a filepath exist. New directory\n  * components are created, if necessary.\n@@ -51,126 +49,22 @@ static int ensure_filepath(char *path) {\n   return 1;\n }\n \n-/**\n- * Creates a UNIX filename from the internal CAB filename and the given\n- * parameters.\n- *\n- * @param fname  the internal CAB filename.\n- * @param dir    a directory path to prepend to the output filename.\n- * @param lower  if non-zero, filename should be made lower-case.\n- * @param isunix if zero, MS-DOS path seperators are used in the internal\n- *               CAB filename. If non-zero, UNIX path seperators are used.\n- * @param utf8   if non-zero, the internal CAB filename is encoded in UTF8.\n- * @return a freshly allocated and created filename, or NULL if there was\n- *         not enough memory.\n- * @see unix_path_seperators()\n- */\n-static char *create_output_name(unsigned char *fname, unsigned char *dir,\n-\t\t\t int lower, int isunix, int utf8)\n-{\n-  unsigned char *p, *name, c, *fe, sep, slash;\n-  unsigned int x;\n-\n-  sep   = (isunix) ? '/'  : '\\\\'; /* the path-seperator */\n-  slash = (isunix) ? '\\\\' : '/';  /* the other slash */\n-\n-  /* length of filename */\n-  x = strlen((char *) fname);\n-  /* UTF8 worst case scenario: tolower() expands all chars from 1 to 3 bytes */\n-  if (utf8) x *= 3;\n-  /* length of output directory */\n-  if (dir) x += strlen((char *) dir);\n-\n-  if (!(name = (unsigned char *) malloc(x + 2))) {\n-    fprintf(stderr, \"out of memory!\\n\");\n-    return NULL;\n-  }\n-  \n-  /* start with blank name */\n-  *name = '\\0';\n-\n-  /* add output directory if needed */\n-  if (dir) {\n-    strcpy((char *) name, (char *) dir);\n-    strcat((char *) name, \"/\");\n-  }\n-\n-  /* remove leading slashes */\n-  while (*fname == sep) fname++;\n-\n-  /* copy from fi->filename to new name, converting MS-DOS slashes to UNIX\n-   * slashes as we go. Also lowercases characters if needed.\n-   */\n-  p = &name[strlen((char *)name)];\n-  fe = &fname[strlen((char *)fname)];\n-\n-  if (utf8) {\n-    /* UTF8 translates two-byte unicode characters into 1, 2 or 3 bytes.\n-     * %000000000xxxxxxx -> %0xxxxxxx\n-     * %00000xxxxxyyyyyy -> %110xxxxx %10yyyyyy\n-     * %xxxxyyyyyyzzzzzz -> %1110xxxx %10yyyyyy %10zzzzzz\n-     *\n-     * Therefore, the inverse is as follows:\n-     * First char:\n-     *  0x00 - 0x7F = one byte char\n-     *  0x80 - 0xBF = invalid\n-     *  0xC0 - 0xDF = 2 byte char (next char only 0x80-0xBF is valid)\n-     *  0xE0 - 0xEF = 3 byte char (next 2 chars only 0x80-0xBF is valid)\n-     *  0xF0 - 0xFF = invalid\n-     */\n-    do {\n-      if (fname >= fe) {\n-\tfree(name);\n-\treturn NULL;\n-      }\n-\n-      /* get next UTF8 char */\n-      if ((c = *fname++) < 0x80) x = c;\n-      else {\n-\tif ((c >= 0xC0) && (c < 0xE0)) {\n-\t  x = (c & 0x1F) << 6;\n-\t  x |= *fname++ & 0x3F;\n-\t}\n-\telse if ((c >= 0xE0) && (c < 0xF0)) {\n-\t  x = (c & 0xF) << 12;\n-\t  x |= (*fname++ & 0x3F) << 6;\n-\t  x |= *fname++ & 0x3F;\n-\t}\n-\telse x = '?';\n-      }\n-\n-      /* whatever is the path seperator -> '/'\n-       * whatever is the other slash    -> '\\\\'\n-       * otherwise, if lower is set, the lowercase version */\n-      if      (x == sep)   x = '/';\n-      else if (x == slash) x = '\\\\';\n-      else if (lower)      x = (unsigned int) tolower((int) x);\n-\n-      /* integer back to UTF8 */\n-      if (x < 0x80) {\n-\t*p++ = (unsigned char) x;\n-      }\n-      else if (x < 0x800) {\n-\t*p++ = 0xC0 | (x >> 6);   \n-\t*p++ = 0x80 | (x & 0x3F);\n-      }\n-      else {\n-\t*p++ = 0xE0 | (x >> 12);\n-\t*p++ = 0x80 | ((x >> 6) & 0x3F);\n-\t*p++ = 0x80 | (x & 0x3F);\n-      }\n-    } while (x);\n-  }\n-  else {\n-    /* regular non-utf8 version */\n-    do {\n-      c = *fname++;\n-      if      (c == sep)   c = '/';\n-      else if (c == slash) c = '\\\\';\n-      else if (lower)      c = (unsigned char) tolower((int) c);\n-    } while ((*p++ = c));\n-  }\n-  return (char *) name;\n+char *create_output_name(char *fname) {\n+    char *out, *p;\n+    if ((out = malloc(strlen(fname) + 1))) {\n+        /* remove leading slashes */\n+        while (*fname == '/' || *fname == '\\\\') fname++;\n+        /* if that removes all characters, just call it \"x\" */\n+        strcpy(out, (*fname) ? fname : \"x\");\n+\n+        /* change \"../\" to \"xx/\" */\n+        for (p = out; *p; p++) {\n+            if (p[0] == '.' && p[1] == '.' && (p[2] == '/' || p[2] == '\\\\')) {\n+               p[0] = p[1] = 'x';\n+            }\n+        }\n+    }\n+    return out;\n }\n \n static int sortfunc(const void *a, const void *b) {\n@@ -205,7 +99,7 @@ int main(int argc, char *argv[]) {\n \t  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\n \n \t  for (i = 0; i < numf; i++) {\n-\t    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);\n+\t    char *outname = create_output_name(f[i]->filename);\n \t    printf(\"Extracting %s\\n\", outname);\n \t    ensure_filepath(outname);\n \t    if (chmd->extract(chmd, f[i], outname)) {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "305907723a4e7ab2018e58040059ffb5e77db837",
            "date": "2023-02-24T12:01:05Z",
            "author_login": "kyz"
          },
          {
            "sha": "e1d7bdd6d8f1a8ee863f1b33188c2b2fb1117d29",
            "date": "2023-02-24T12:00:46Z",
            "author_login": "kyz"
          },
          {
            "sha": "a1be011bdd4a5ff5fe5a88bffc4dd90938709a6f",
            "date": "2023-02-24T12:00:27Z",
            "author_login": "kyz"
          },
          {
            "sha": "d80cd5ee33d494ab3a08eb8e79c7d97776f6b973",
            "date": "2023-02-24T11:58:31Z",
            "author_login": "kyz"
          },
          {
            "sha": "66d24943a0e9ff5fd03beb26848e907c22849be9",
            "date": "2023-02-24T11:56:16Z",
            "author_login": "kyz"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-22",
    "description": "chmextract.c in the chmextract sample program, as distributed with libmspack before 0.8alpha, does not protect against absolute/relative pathnames in CHM files, leading to Directory Traversal. NOTE: the vendor disputes that this is a libmspack vulnerability, because chmextract.c was only intended as a source-code example, not a supported application",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-10-23T02:29:00.700",
    "last_modified": "2024-11-21T03:56:12.647",
    "fix_date": "2018-10-20T18:06:32Z"
  },
  "references": [
    {
      "url": "https://bugs.debian.org/911639",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/kyz/libmspack/commit/7cadd489698be117c47efcadd742651594429e6d",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201903-20",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.openwall.com/lists/oss-security/2018/10/22/1",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugs.debian.org/911639",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/kyz/libmspack/commit/7cadd489698be117c47efcadd742651594429e6d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201903-20",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.openwall.com/lists/oss-security/2018/10/22/1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:38.529585",
    "processing_status": "enhanced"
  }
}