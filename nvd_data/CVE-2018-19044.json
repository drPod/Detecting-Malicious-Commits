{
  "cve_id": "CVE-2018-19044",
  "github_data": {
    "repository": "acassen/keepalived",
    "fix_commit": "04f2d32871bb3b11d7dc024039952f2fe2750306",
    "related_commits": [
      "04f2d32871bb3b11d7dc024039952f2fe2750306",
      "04f2d32871bb3b11d7dc024039952f2fe2750306"
    ],
    "patch_url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306.patch",
    "fix_commit_details": {
      "sha": "04f2d32871bb3b11d7dc024039952f2fe2750306",
      "commit_date": "2018-10-31T23:54:13Z",
      "author": {
        "login": "pqarmitage",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "When opening files for write, ensure they aren't symbolic links",
        "length": 1013,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 86,
        "additions": 63,
        "deletions": 23
      },
      "files": [
        {
          "filename": "keepalived/core/main.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \"Unable to open config-test log file %s\\n\", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);"
        },
        {
          "filename": "keepalived/core/pidfile.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -60,7 +60,7 @@ int\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \"w\");\n "
        },
        {
          "filename": "keepalived/core/smtp.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\"/tmp/smtp-alert.log\", \"a\");\n+\tFILE *fp = fopen_safe(\"/tmp/smtp-alert.log\", \"a\");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];"
        },
        {
          "filename": "keepalived/vrrp/vrrp_dbus.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -594,7 +594,7 @@ read_file(gchar* filepath)\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \"rb\");\n+\tf = fopen(filepath, \"r\");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);"
        },
        {
          "filename": "keepalived/vrrp/vrrp_json.c",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -37,6 +37,7 @@\n #include \"vrrp_iprule.h\"\n #include \"logger.h\"\n #include \"timer.h\"\n+#include \"utils.h\"\n \n static inline double\n timeval_to_double(const timeval_t *t)\n@@ -55,7 +56,7 @@ vrrp_print_json(void)\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\"/tmp/keepalived.json\",\"w\");\n+\tfile = fopen_safe(\"/tmp/keepalived.json\", \"w\");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \"Can't open /tmp/keepalived.json (%d: %s)\",\n \t\t\terrno, strerror(errno));"
        },
        {
          "filename": "keepalived/vrrp/vrrp_parser.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \"w\"))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \"w\"))) {\n \t\t\tfprintf(tf, \"%d\\n\", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}"
        },
        {
          "filename": "keepalived/vrrp/vrrp_print.c",
          "status": "modified",
          "additions": 7,
          "deletions": 10,
          "patch": "@@ -32,14 +32,15 @@\n #include \"vrrp.h\"\n #include \"vrrp_data.h\"\n #include \"vrrp_print.h\"\n+#include \"utils.h\"\n \n static const char *dump_file = \"/tmp/keepalived.data\";\n static const char *stats_file = \"/tmp/keepalived.stats\";\n \n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \"w\");\n+\tFILE *file = fopen_safe(dump_file, \"w\");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n@@ -55,28 +56,24 @@ vrrp_print_data(void)\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \"w\");\n+\tFILE *file = fopen_safe(stats_file, \"w\");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n \t\t\tstats_file, errno, strerror(errno));\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \"VRRP Instance: %s\\n\", vrrp->iname);\n \t\tfprintf(file, \"  Advertisements:\\n\");\n \t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \"    Sent: %d\\n\", vrrp->stats->advert_sent);\n \t\tfprintf(file, \"  Became master: %d\\n\", vrrp->stats->become_master);\n-\t\tfprintf(file, \"  Released master: %d\\n\",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \"  Released master: %d\\n\", vrrp->stats->release_master);\n \t\tfprintf(file, \"  Packet Errors:\\n\");\n \t\tfprintf(file, \"    Length: %\" PRIu64 \"\\n\", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \"    TTL: %\" PRIu64 \"\\n\", vrrp->stats->ip_ttl_err);"
        },
        {
          "filename": "keepalived/vrrp/vrrp_scheduler.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1134,7 +1134,7 @@ dump_threads(void)\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \"a\");\n+\tfp = fopen_safe(file_name, \"a\");\n \tFREE(file_name);\n \n \tset_time_now();"
        },
        {
          "filename": "lib/logger.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \"a\");\n+\tlog_file = fopen_safe(file_name, \"a\");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));"
        },
        {
          "filename": "lib/memory.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)\n \t}\n \n \tsnprintf(log_name, log_name_len, \"/tmp/%s_mem.%d.log\", prog_name, getpid());\n-\tlog_op = fopen(log_name, \"a\");\n+\tlog_op = fopen_safe(log_name, \"a\");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \"Unable to open %s for appending\", log_name);\n \t\tlog_op = stderr;"
        },
        {
          "filename": "lib/notify.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \"Unable to open %snotify fifo %s - errno %d\", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);"
        },
        {
          "filename": "lib/parser.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \"/tmp/keywords.%d\", getpid());\n-\t\tfp = fopen(file_name, \"w\");\n+\t\tfp = fopen_safe(file_name, \"w\");\n \t\tif (!fp)\n \t\t\treturn;\n \t}"
        },
        {
          "filename": "lib/utils.c",
          "status": "modified",
          "additions": 42,
          "deletions": 1,
          "patch": "@@ -123,7 +123,7 @@ write_stacktrace(const char *file_name, const char *str)\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \"%s\\n\", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n@@ -788,6 +788,47 @@ string_equal(const char *str1, const char *str2)\n \treturn !strcmp(str1, str2);\n }\n \n+/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n+ * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\n+FILE *fopen_safe(const char *path, const char *mode)\n+{\n+\tint fd;\n+\tFILE *file;\n+\tint flags = O_NOFOLLOW | O_CREAT;\n+\n+\tif (mode[0] == 'r')\n+\t\treturn fopen(path, mode);\n+\n+\tif (mode[0] != 'a' && mode[0] != 'w')\n+\t\treturn NULL;\n+\n+\tif (mode[1] &&\n+\t    (mode[1] != '+' || mode[2]))\n+\t\treturn NULL;\n+\n+\tif (mode[0] == 'w')\n+\t\tflags |= O_TRUNC;\n+\telse\n+\t\tflags |= O_APPEND;\n+\n+\tif (mode[1])\n+\t\tflags |= O_RDWR;\n+\telse\n+\t\tflags |= O_WRONLY;\n+\n+\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n+\tif (fd == -1)\n+\t\treturn NULL;\n+\n+\tfile = fdopen (fd, \"w\");\n+\tif (!file) {\n+\t\tclose(fd);\n+\t\treturn NULL;\n+\t}\n+\n+\treturn file;\n+}\n+\n void\n set_std_fd(bool force)\n {"
        },
        {
          "filename": "lib/utils.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -182,6 +182,7 @@ extern int inet_inaddrcmp(int, const void *, const void *);\n extern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\n extern char *get_local_name(void);\n extern bool string_equal(const char *, const char *);\n+extern FILE *fopen_safe(const char *, const char *);\n extern void set_std_fd(bool);\n extern void close_std_fd(void);\n #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "4108ed2aa302a90a8db35f3dcfded5ec56694fe0",
            "date": "2024-12-19T12:28:07Z",
            "author_login": "pqarmitage"
          },
          {
            "sha": "9f371cc1b849763b1ee3a1f193b127f46fa7a6ad",
            "date": "2024-12-18T20:14:56Z",
            "author_login": "xgqt"
          },
          {
            "sha": "ddf638ee96ab2ca8b871a08cb2d897362342af9e",
            "date": "2024-12-18T20:08:38Z",
            "author_login": "xgqt"
          },
          {
            "sha": "0d436ab912bbdec97dd157c23237d8c2a1a0e18b",
            "date": "2024-12-14T14:09:07Z",
            "author_login": "pqarmitage"
          },
          {
            "sha": "abdb0e4807b5d328b2608ca3235364a4cb114ef7",
            "date": "2024-12-14T14:03:16Z",
            "author_login": "pqarmitage"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-59",
    "description": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-11-08T20:29:00.323",
    "last_modified": "2024-11-21T03:57:12.890",
    "fix_date": "2018-10-31T23:54:13Z"
  },
  "references": [
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:2285",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://bugzilla.suse.com/show_bug.cgi?id=1015141",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/acassen/keepalived/issues/1048",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201903-01",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:2285",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugzilla.suse.com/show_bug.cgi?id=1015141",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/acassen/keepalived/issues/1048",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201903-01",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:38.550524",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "keepalived",
    "owner": "acassen",
    "created_at": "2012-07-11T12:42:41Z",
    "updated_at": "2025-01-14T13:21:18Z",
    "pushed_at": "2024-12-19T12:28:07Z",
    "size": 19807,
    "stars": 4076,
    "forks": 737,
    "open_issues": 42,
    "watchers": 4076,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 2699054,
      "M4": 132078,
      "Shell": 24090,
      "Makefile": 23960,
      "Python": 9213,
      "Perl": 3511
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T16:26:42.847055"
  }
}