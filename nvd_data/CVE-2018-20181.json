{
  "cve_id": "CVE-2018-20181",
  "github_data": {
    "repository": "rdesktop/rdesktop",
    "fix_commit": "4dca546d04321a610c1835010b5dad85163b65e1",
    "related_commits": [
      "4dca546d04321a610c1835010b5dad85163b65e1",
      "4dca546d04321a610c1835010b5dad85163b65e1"
    ],
    "patch_url": "https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1.patch",
    "fix_commit_details": {
      "sha": "4dca546d04321a610c1835010b5dad85163b65e1",
      "commit_date": "2019-01-16T09:45:33Z",
      "author": {
        "login": "hean01-cendio",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Malicious RDP server security fixes",
        "length": 1760,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 321,
        "additions": 250,
        "deletions": 71
      },
      "files": [
        {
          "filename": "asn.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -22,7 +22,7 @@\n \n /* Parse an ASN.1 BER header */\n RD_BOOL\n-ber_parse_header(STREAM s, int tagval, int *length)\n+ber_parse_header(STREAM s, int tagval, uint32 *length)\n {\n \tint tag, len;\n "
        },
        {
          "filename": "bitmap.c",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -794,15 +794,15 @@ process_plane(uint8 * in, int width, int height, uint8 * out, int size)\n \t\t\t\t\treplen = revcode;\n \t\t\t\t\tcollen = 0;\n \t\t\t\t}\n-\t\t\t\twhile (collen > 0)\n+\t\t\t\twhile (indexw < width && collen > 0)\n \t\t\t\t{\n \t\t\t\t\tcolor = CVAL(in);\n \t\t\t\t\t*out = color;\n \t\t\t\t\tout += 4;\n \t\t\t\t\tindexw++;\n \t\t\t\t\tcollen--;\n \t\t\t\t}\n-\t\t\t\twhile (replen > 0)\n+\t\t\t\twhile (indexw < width && replen > 0)\n \t\t\t\t{\n \t\t\t\t\t*out = color;\n \t\t\t\t\tout += 4;\n@@ -824,7 +824,7 @@ process_plane(uint8 * in, int width, int height, uint8 * out, int size)\n \t\t\t\t\treplen = revcode;\n \t\t\t\t\tcollen = 0;\n \t\t\t\t}\n-\t\t\t\twhile (collen > 0)\n+\t\t\t\twhile (indexw < width && collen > 0)\n \t\t\t\t{\n \t\t\t\t\tx = CVAL(in);\n \t\t\t\t\tif (x & 1)\n@@ -844,7 +844,7 @@ process_plane(uint8 * in, int width, int height, uint8 * out, int size)\n \t\t\t\t\tindexw++;\n \t\t\t\t\tcollen--;\n \t\t\t\t}\n-\t\t\t\twhile (replen > 0)\n+\t\t\t\twhile (indexw < width && replen > 0)\n \t\t\t\t{\n \t\t\t\t\tx = last_line[indexw * 4] + color;\n \t\t\t\t\t*out = x;"
        },
        {
          "filename": "cliprdr.c",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -118,6 +118,7 @@ cliprdr_process(STREAM s)\n \tuint16 type, status;\n \tuint32 length, format;\n \tuint8 *data;\n+\tstruct stream packet = *s;\n \n \tin_uint16_le(s, type);\n \tin_uint16_le(s, status);\n@@ -127,6 +128,11 @@ cliprdr_process(STREAM s)\n \tlogger(Clipboard, Debug, \"cliprdr_process(), type=%d, status=%d, length=%d\", type, status,\n \t       length);\n \n+\tif (!s_check_rem(s, length))\n+\t{\n+\t\trdp_protocol_error(\"cliprdr_process(), consume of packet from stream would overrun\", &packet);\n+\t}\n+\n \tif (status == CLIPRDR_ERROR)\n \t{\n \t\tswitch (type)"
        },
        {
          "filename": "constants.h",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -751,6 +751,9 @@ enum RDP_DESKTOP_ORIENTATION\n #define ENC_SALTED_CHECKSUM\t\t0x0010\n #define NO_BITMAP_COMPRESSION_HDR\t0x0400\n \n+/* [MS-RDPBCGR], TS_BITMAP_DATA, flags */\n+#define BITMAP_COMPRESSION              0x0001\n+\n /* orderFlags, [MS-RDPBCGR] 2.2.7.1.3 */\n #define NEGOTIATEORDERSUPPORT\t0x0002\n #define ZEROBOUNDSDELTASSUPPORT 0x0008"
        },
        {
          "filename": "cssp.c",
          "status": "modified",
          "additions": 16,
          "deletions": 1,
          "patch": "@@ -595,6 +595,7 @@ cssp_read_tsrequest(STREAM token, STREAM pubkey)\n \tSTREAM s;\n \tint length;\n \tint tagval;\n+\tstruct stream packet;\n \n \ts = tcp_recv(NULL, 4);\n \n@@ -622,6 +623,7 @@ cssp_read_tsrequest(STREAM token, STREAM pubkey)\n \n \t// receive the remainings of message\n \ts = tcp_recv(s, length);\n+\tpacket = *s;\n \n \t// parse the response and into nego token\n \tif (!ber_in_header(s, &tagval, &length) ||\n@@ -632,6 +634,12 @@ cssp_read_tsrequest(STREAM token, STREAM pubkey)\n \tif (!ber_in_header(s, &tagval, &length) ||\n \t    tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n \t\treturn False;\n+\n+\tif (!s_check_rem(s, length))\n+\t{\n+\t\t rdp_protocol_error(\"cssp_read_tsrequest(), consume of version from stream would overrun\",\n+\t\t\t\t    &packet);\n+\t}\n \tin_uint8s(s, length);\n \n \t// negoToken [1]\n@@ -653,7 +661,14 @@ cssp_read_tsrequest(STREAM token, STREAM pubkey)\n \t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n \t\t\treturn False;\n \n-\t\ttoken->end = token->p = token->data;\n+\t\tif (!s_check_rem(s, length))\n+\t\t{\n+\t\t\trdp_protocol_error(\"cssp_read_tsrequest(), consume of token from stream would overrun\",\n+\t\t\t\t\t   &packet);\n+\t\t}\n+\n+\t\ts_realloc(token, length);\n+\t\ts_reset(token);\n \t\tout_uint8p(token, s->p, length);\n \t\ts_mark_end(token);\n \t}"
        },
        {
          "filename": "lspci.c",
          "status": "modified",
          "additions": 8,
          "deletions": 1,
          "patch": "@@ -1,7 +1,8 @@\n /*  -*- c-basic-offset: 8 -*-\n    rdesktop: A Remote Desktop Protocol client.\n    Support for the Matrox \"lspci\" channel\n-   Copyright (C) 2005 Matrox Graphics Inc. \n+   Copyright (C) 2005 Matrox Graphics Inc.\n+   Copyright 2018 Henrik Andersson <hean01@cendio.se> for Cendio AB\n \n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -134,6 +135,12 @@ lspci_process(STREAM s)\n \tunsigned int pkglen;\n \tstatic char *rest = NULL;\n \tchar *buf;\n+\tstruct stream packet = *s;\n+\n+\tif (!s_check(s))\n+\t{\n+\t\trdp_protocol_error(\"lspci_process(), stream is in unstable state\", &packet);\n+\t}\n \n \tpkglen = s->end - s->p;\n \t/* str_handle_lines requires null terminated strings */"
        },
        {
          "filename": "mcs.c",
          "status": "modified",
          "additions": 18,
          "deletions": 2,
          "patch": "@@ -45,9 +45,16 @@ mcs_out_domain_params(STREAM s, int max_channels, int max_users, int max_tokens,\n static RD_BOOL\n mcs_parse_domain_params(STREAM s)\n {\n-\tint length;\n+\tuint32 length;\n+\tstruct stream packet = *s;\n \n \tber_parse_header(s, MCS_TAG_DOMAIN_PARAMS, &length);\n+\n+\tif (!s_check_rem(s, length))\n+\t{\n+\t\trdp_protocol_error(\"mcs_parse_domain_params(), consume domain params from stream would overrun\", &packet);\n+\t}\n+\n \tin_uint8s(s, length);\n \n \treturn s_check(s);\n@@ -89,8 +96,9 @@ mcs_recv_connect_response(STREAM mcs_data)\n {\n \tUNUSED(mcs_data);\n \tuint8 result;\n-\tint length;\n+\tuint32 length;\n \tSTREAM s;\n+\tstruct stream packet;\n \tRD_BOOL is_fastpath;\n \tuint8 fastpath_hdr;\n \n@@ -99,6 +107,8 @@ mcs_recv_connect_response(STREAM mcs_data)\n \n \tif (s == NULL)\n \t\treturn False;\n+\t\n+\tpacket = *s;\n \n \tber_parse_header(s, MCS_CONNECT_RESPONSE, &length);\n \n@@ -112,6 +122,12 @@ mcs_recv_connect_response(STREAM mcs_data)\n \n \tber_parse_header(s, BER_TAG_INTEGER, &length);\n \tin_uint8s(s, length);\t/* connect id */\n+\n+\tif (!s_check_rem(s, length))\n+\t{\n+\t\trdp_protocol_error(\"mcs_recv_connect_response(), consume connect id from stream would overrun\", &packet);\n+\t}\n+\n \tmcs_parse_domain_params(s);\n \n \tber_parse_header(s, BER_TAG_OCTET_STRING, &length);"
        },
        {
          "filename": "orders.c",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -1259,11 +1259,17 @@ process_secondary_order(STREAM s)\n \tuint16 flags;\n \tuint8 type;\n \tuint8 *next_order;\n+\tstruct stream packet = *s;\n \n \tin_uint16_le(s, length);\n \tin_uint16_le(s, flags);\t/* used by bmpcache2 */\n \tin_uint8(s, type);\n \n+\tif (!s_check_rem(s, length + 7))\n+\t{\n+\t\trdp_protocol_error(\"process_secondary_order(), next order pointer would overrun stream\", &packet);\n+\t}\n+\n \tnext_order = s->p + (sint16) length + 7;\n \n \tswitch (type)"
        },
        {
          "filename": "proto.h",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -164,6 +164,7 @@ RD_BOOL rdp_connect(char *server, uint32 flags, char *domain, char *password, ch\n \t\t    char *directory, RD_BOOL reconnect);\n void rdp_reset_state(void);\n void rdp_disconnect(void);\n+void rdp_protocol_error(const char *message, STREAM s);\n /* rdpdr.c */\n int get_device_index(RD_NTHANDLE handle);\n void convert_to_unix_filename(char *filename);\n@@ -224,7 +225,7 @@ void tcp_run_ui(RD_BOOL run);\n /* asn.c */\n RD_BOOL ber_in_header(STREAM s, int *tagval, int *length);\n void ber_out_header(STREAM s, int tagval, int length);\n-RD_BOOL ber_parse_header(STREAM s, int tagval, int *length);\n+RD_BOOL ber_parse_header(STREAM s, int tagval, uint32 *length);\n void ber_out_integer(STREAM s, int value);\n void ber_out_sequence(STREAM s, STREAM contents);\n "
        },
        {
          "filename": "rdp.c",
          "status": "modified",
          "additions": 132,
          "deletions": 60,
          "patch": "@@ -285,6 +285,19 @@ rdp_in_unistr(STREAM s, int in_len, char **string, uint32 * str_size)\n \tsize_t ibl, obl;\n \tchar *pin, *pout;\n \n+\tstruct stream packet = *s;\n+\n+\tif ((in_len < 0) || ((uint32)in_len >= (RD_UINT32_MAX / 2)))\n+\t{\n+\t\tlogger(Protocol, Error, \"rdp_in_unistr(), length of unicode data is out of bounds.\");\n+\t\tabort();\n+\t}\n+\n+\tif (!s_check_rem(s, in_len))\n+\t{\n+\t\trdp_protocol_error(\"rdp_in_unistr(), consume of unicode data from stream would overrun\", &packet);\n+\t}\n+\n \t// if not already open\n \tif (!icv_utf16_to_local)\n \t{\n@@ -1211,13 +1224,19 @@ process_demand_active(STREAM s)\n {\n \tuint8 type;\n \tuint16 len_src_descriptor, len_combined_caps;\n+\tstruct stream packet = *s;\n \n \t/* at this point we need to ensure that we have ui created */\n \trd_create_ui();\n \n \tin_uint32_le(s, g_rdp_shareid);\n \tin_uint16_le(s, len_src_descriptor);\n \tin_uint16_le(s, len_combined_caps);\n+\n+\tif (!s_check_rem(s, len_src_descriptor))\n+\t{\n+\t\trdp_protocol_error(\"rdp_demand_active(), consume of source descriptor from stream would overrun\", &packet);\n+\t}\n \tin_uint8s(s, len_src_descriptor);\n \n \tlogger(Protocol, Debug, \"process_demand_active(), shareid=0x%x\", g_rdp_shareid);\n@@ -1390,78 +1409,113 @@ process_pointer_pdu(STREAM s)\n \t}\n }\n \n-/* Process bitmap updates */\n-void\n-process_bitmap_updates(STREAM s)\n+/* Process TS_BITMAP_DATA */\n+static void\n+process_bitmap_data(STREAM s)\n {\n-\tuint16 num_updates;\n \tuint16 left, top, right, bottom, width, height;\n-\tuint16 cx, cy, bpp, Bpp, compress, bufsize, size;\n+\tuint16 cx, cy, bpp, Bpp, flags, bufsize, size;\n \tuint8 *data, *bmpdata;\n-\tint i;\n-\n+\t\n \tlogger(Protocol, Debug, \"%s()\", __func__);\n \n-\tin_uint16_le(s, num_updates);\n+\tstruct stream packet = *s;\n \n-\tfor (i = 0; i < num_updates; i++)\n-\t{\n-\t\tin_uint16_le(s, left);\n-\t\tin_uint16_le(s, top);\n-\t\tin_uint16_le(s, right);\n-\t\tin_uint16_le(s, bottom);\n-\t\tin_uint16_le(s, width);\n-\t\tin_uint16_le(s, height);\n-\t\tin_uint16_le(s, bpp);\n-\t\tBpp = (bpp + 7) / 8;\n-\t\tin_uint16_le(s, compress);\n-\t\tin_uint16_le(s, bufsize);\n-\n-\t\tcx = right - left + 1;\n-\t\tcy = bottom - top + 1;\n-\n-\t\tlogger(Graphics, Debug,\n-\t\t       \"process_bitmap_updates(), [%d,%d,%d,%d], [%d,%d], bpp=%d, compression=%d\",\n-\t\t       left, top, right, bottom, width, height, Bpp, compress);\n-\n-\t\tif (!compress)\n-\t\t{\n-\t\t\tint y;\n-\t\t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n-\t\t\tfor (y = 0; y < height; y++)\n-\t\t\t{\n-\t\t\t\tin_uint8a(s, &bmpdata[(height - y - 1) * (width * Bpp)],\n-\t\t\t\t\t  width * Bpp);\n-\t\t\t}\n-\t\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n-\t\t\txfree(bmpdata);\n-\t\t\tcontinue;\n-\t\t}\n+\tin_uint16_le(s, left); /* destLeft */\n+\tin_uint16_le(s, top); /* destTop */\n+\tin_uint16_le(s, right); /* destRight */\n+\tin_uint16_le(s, bottom); /* destBottom */\n+\tin_uint16_le(s, width); /* width */\n+\tin_uint16_le(s, height); /* height */\n+\tin_uint16_le(s, bpp); /*bitsPerPixel */\n+\tBpp = (bpp + 7) / 8;\n+\tin_uint16_le(s, flags); /* flags */\n+\tin_uint16_le(s, bufsize); /* bitmapLength */\n \n+\tcx = right - left + 1;\n+\tcy = bottom - top + 1;\n \n-\t\tif (compress & 0x400)\n-\t\t{\n-\t\t\tsize = bufsize;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tin_uint8s(s, 2);\t/* pad */\n-\t\t\tin_uint16_le(s, size);\n-\t\t\tin_uint8s(s, 4);\t/* line_size, final_size */\n-\t\t}\n-\t\tin_uint8p(s, data, size);\n+\t/* FIXME: There are a assumtion that we do not consider in\n+\t\tthis code. The value of bpp is not passed to\n+\t\tui_paint_bitmap() which relies on g_server_bpp for drawing\n+\t\tthe bitmap data.\n+\n+\t\tDoes this means that we can sanity check bpp with g_server_bpp ?\n+\t*/\n+\n+\tif (Bpp == 0 || width == 0 || height == 0)\n+\t{\n+        logger(Protocol, Warning, \"%s(), [%d,%d,%d,%d], [%d,%d], bpp=%d, flags=%x\", __func__,\n+\t\t\t\tleft, top, right, bottom, width, height, bpp, flags);\n+\t\trdp_protocol_error(\"TS_BITMAP_DATA, unsafe size of bitmap data received from server\", &packet);\n+\t}\n+\n+\tif ((RD_UINT32_MAX / Bpp) <= (width * height))\n+\t{\n+\t\tlogger(Protocol, Warning, \"%s(), [%d,%d,%d,%d], [%d,%d], bpp=%d, flags=%x\", __func__,\n+\t\t\t\tleft, top, right, bottom, width, height, bpp, flags);\n+\t\trdp_protocol_error(\"TS_BITMAP_DATA, unsafe size of bitmap data received from server\", &packet);\n+\t}\n+ \n+\tif (flags == 0)\n+\t{\n+\t\t/* read uncompressed bitmap data */\n+\t\tint y;\n \t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n-\t\tif (bitmap_decompress(bmpdata, width, height, data, size, Bpp))\n+\t\tfor (y = 0; y < height; y++)\n \t\t{\n-\t\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n+\t\t\tin_uint8a(s, &bmpdata[(height - y - 1) * (width * Bpp)], width * Bpp);\n \t\t}\n-\t\telse\n-\t\t{\n-\t\t\tlogger(Graphics, Warning,\n-\t\t\t       \"process_bitmap_updates(), failed to decompress bitmap\");\n-\t\t}\n-\n+\t\t\n+\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n \t\txfree(bmpdata);\n+\t\treturn;\n+\t}\n+\n+\tif (flags & NO_BITMAP_COMPRESSION_HDR)\n+\t{\n+\t\tsize = bufsize;\n+\t}\n+\telse\n+\t{\n+\t\t/* Read TS_CD_HEADER */\n+\t\tin_uint8s(s, 2);        /* skip cbCompFirstRowSize (must be 0x0000) */\n+\t\tin_uint16_le(s, size);  /* cbCompMainBodySize */\n+\t\tin_uint8s(s, 2);        /* skip cbScanWidth */\n+\t\tin_uint8s(s, 2);        /* skip cbUncompressedSize */\n+\t}\n+\n+\t/* read compressed bitmap data */\n+\tif (!s_check_rem(s, size))\n+\t{\n+\t\trdp_protocol_error(\"process_bitmap_data(), consume of bitmap data from stream would overrun\", &packet);\n+\t}\n+\tin_uint8p(s, data, size);\n+\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n+\tif (bitmap_decompress(bmpdata, width, height, data, size, Bpp))\n+\t{\n+\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n+\t}\n+\telse\n+\t{\n+\t\tlogger(Protocol, Warning, \"%s(), failed to decompress bitmap\", __func__);\n+\t}\n+\n+\txfree(bmpdata);\n+}\n+\n+/* Process TS_UPDATE_BITMAP_DATA */\n+void\n+process_bitmap_updates(STREAM s)\n+{\n+\tint i;\n+\tuint16 num_updates;\n+\t\n+\tin_uint16_le(s, num_updates);   /* rectangles */\n+\n+\tfor (i = 0; i < num_updates; i++)\n+\t{\n+\t\tprocess_bitmap_data(s);\n \t}\n }\n \n@@ -2013,3 +2067,21 @@ rdp_disconnect(void)\n \tlogger(Protocol, Debug, \"%s()\", __func__);\n \tsec_disconnect();\n }\n+\n+/* Abort rdesktop upon protocol error\n+\n+   A protocol error is defined as:\n+\n+    - A value is outside specified range for example;\n+      bpp for a bitmap is not allowed to be greater than the\n+      value 32 but is represented by a byte in protocol.\n+\n+*/\n+void\n+rdp_protocol_error(const char *message, STREAM s)\n+{\n+\tlogger(Protocol, Error, \"%s(), %s\", __func__, message);\n+\tif (s)\n+\t\thexdump(s->p, s_length(s));\n+\texit(0);\n+}"
        },
        {
          "filename": "rdpdr.c",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -854,6 +854,7 @@ rdpdr_process(STREAM s)\n \tuint16 vmin;\n \tuint16 component;\n \tuint16 pakid;\n+\tstruct stream packet = *s;\n \n \tlogger(Protocol, Debug, \"rdpdr_process()\");\n \t/* hexdump(s->p, s->end - s->p); */\n@@ -873,8 +874,18 @@ rdpdr_process(STREAM s)\n \t\t\t\t/* DR_CORE_SERVER_ANNOUNCE_REQ */\n \t\t\t\tin_uint8s(s, 2);\t/* skip versionMajor */\n \t\t\t\tin_uint16_le(s, vmin);\t/* VersionMinor */\n+\n \t\t\t\tin_uint32_le(s, g_client_id);\t/* ClientID */\n \n+\t\t\t\t/* g_client_id is sent back to server,\n+\t\t\t\t   so lets check that we actually got\n+\t\t\t\t   valid data from stream to prevent\n+\t\t\t\t   that we leak back data to server */\n+\t\t\t\tif (!s_check(s))\n+\t\t\t\t{\n+\t\t\t\t\trdp_protocol_error(\"rdpdr_process(), consume of g_client_id from stream did overrun\", &packet);\n+\t\t\t\t}\n+\n \t\t\t\t/* The RDP client is responsibility to provide a random client id\n \t\t\t\t   if server version is < 12 */\n \t\t\t\tif (vmin < 0x000c)"
        },
        {
          "filename": "rdpsnd.c",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -269,6 +269,12 @@ rdpsnd_process_training(STREAM in)\n \tuint16 tick;\n \tuint16 packsize;\n \tSTREAM out;\n+\tstruct stream packet = *in;\n+\n+\tif (!s_check_rem(in, 4))\n+\t{\n+\t\trdp_protocol_error(\"rdpsnd_process_training(), consume of training data from stream would overrun\", &packet);\n+\t}\n \n \tin_uint16_le(in, tick);\n \tin_uint16_le(in, packsize);\n@@ -445,6 +451,11 @@ rdpsnddbg_process(STREAM s)\n \tstatic char *rest = NULL;\n \tchar *buf;\n \n+\tif (!s_check(s))\n+\t{\n+\t\trdp_protocol_error(\"rdpsnddbg_process(), stream is in unstable state\", s);\n+\t}\n+\n \tpkglen = s->end - s->p;\n \t/* str_handle_lines requires null terminated strings */\n \tbuf = (char *) xmalloc(pkglen + 1);"
        },
        {
          "filename": "seamless.c",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -168,6 +168,12 @@ seamless_process_line(const char *line, void *data)\n \n \t\t\ticon_buf[len] = strtol(byte, NULL, 16);\n \t\t\tlen++;\n+\n+\t\t\tif ((size_t)len >= sizeof(icon_buf))\n+\t\t\t{\n+\t\t\t\tlogger(Protocol, Warning, \"seamless_process_line(), icon data would overrun icon_buf\");\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \n \t\tui_seamless_seticon(id, tok5, width, height, chunk, icon_buf, len);\n@@ -370,6 +376,12 @@ seamless_process(STREAM s)\n {\n \tunsigned int pkglen;\n \tchar *buf;\n+\tstruct stream packet = *s;\n+\n+\tif (!s_check(s))\n+\t{\n+\t\trdp_protocol_error(\"seamless_process(), stream is in unstable state\", &packet);\n+\t}\n \n \tpkglen = s->end - s->p;\n \t/* str_handle_lines requires null terminated strings */"
        },
        {
          "filename": "secure.c",
          "status": "modified",
          "additions": 17,
          "deletions": 0,
          "patch": "@@ -296,6 +296,9 @@ sec_encrypt(uint8 * data, int length)\n void\n sec_decrypt(uint8 * data, int length)\n {\n+\tif (length <= 0)\n+\t\treturn;\n+\n \tif (g_sec_decrypt_use_count == 4096)\n \t{\n \t\tsec_update(g_sec_decrypt_key, g_sec_decrypt_update_key);\n@@ -848,9 +851,11 @@ sec_recv(RD_BOOL * is_fastpath)\n \tuint16 sec_flags;\n \tuint16 channel;\n \tSTREAM s;\n+\tstruct stream packet;\n \n \twhile ((s = mcs_recv(&channel, is_fastpath, &fastpath_hdr)) != NULL)\n \t{\n+\t\tpacket = *s;\n \t\tif (*is_fastpath == True)\n \t\t{\n \t\t\t/* If fastpath packet is encrypted, read data\n@@ -859,6 +864,10 @@ sec_recv(RD_BOOL * is_fastpath)\n \t\t\tfastpath_flags = (fastpath_hdr & 0xC0) >> 6;\n \t\t\tif (fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED)\n \t\t\t{\n+\t\t\t\tif (!s_check_rem(s, 8)) {\n+\t\t\t\t\trdp_protocol_error(\"sec_recv(), consume fastpath signature from stream would overrun\", &packet);\n+\t\t\t\t}\n+\n \t\t\t\tin_uint8s(s, 8);\t/* signature */\n \t\t\t\tsec_decrypt(s->p, s->end - s->p);\n \t\t\t}\n@@ -875,6 +884,10 @@ sec_recv(RD_BOOL * is_fastpath)\n \t\t\t{\n \t\t\t\tif (sec_flags & SEC_ENCRYPT)\n \t\t\t\t{\n+\t\t\t\t\tif (!s_check_rem(s, 8)) {\n+\t\t\t\t\t\trdp_protocol_error(\"sec_recv(), consume encrypt signature from stream would overrun\", &packet);\n+\t\t\t\t\t}\n+\n \t\t\t\t\tin_uint8s(s, 8);\t/* signature */\n \t\t\t\t\tsec_decrypt(s->p, s->end - s->p);\n \t\t\t\t}\n@@ -889,6 +902,10 @@ sec_recv(RD_BOOL * is_fastpath)\n \t\t\t\t{\n \t\t\t\t\tuint8 swapbyte;\n \n+\t\t\t\t\tif (!s_check_rem(s, 8)) {\n+\t\t\t\t\t\trdp_protocol_error(\"sec_recv(), consume redirect signature from stream would overrun\", &packet);\n+\t\t\t\t\t}\n+\n \t\t\t\t\tin_uint8s(s, 8);\t/* signature */\n \t\t\t\t\tsec_decrypt(s->p, s->end - s->p);\n "
        },
        {
          "filename": "stream.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -54,7 +54,7 @@ size_t in_ansi_string(STREAM s, char *string, size_t len);\n #define s_pop_layer(s,h)\t(s)->p = (s)->h;\n #define s_mark_end(s)\t\t(s)->end = (s)->p;\n #define s_check(s)\t\t((s)->p <= (s)->end)\n-#define s_check_rem(s,n)\t((s)->p + n <= (s)->end)\n+#define s_check_rem(s,n) (s_check(s) && (n <= (s)->end - (s)->p))\n #define s_check_end(s)\t\t((s)->p == (s)->end)\n #define s_length(s)\t\t((s)->end - (s)->data)\n #define s_left(s)               ((s)->size - ((s)->p - (s)->data))"
        },
        {
          "filename": "types.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -43,6 +43,8 @@ typedef signed short sint16;\n typedef unsigned int uint32;\n typedef signed int sint32;\n \n+#define RD_UINT32_MAX (uint32)(-1)\n+\n typedef void *RD_HBITMAP;\n typedef void *RD_HGLYPH;\n typedef void *RD_HCOLOURMAP;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "4716f1e01647ead3093805fd4355faf92c00ed0d",
            "date": "2021-12-30T08:23:18Z",
            "author_login": "oldlavender"
          },
          {
            "sha": "da36432c3145fb6086df1b7c8c60d3470d501a16",
            "date": "2021-12-30T08:20:26Z",
            "author_login": "oldlavender"
          },
          {
            "sha": "3986164464a8d229f2358fee053938d8ad7ee4e0",
            "date": "2021-12-30T08:10:26Z",
            "author_login": "oldlavender"
          },
          {
            "sha": "134262fc030ad3c105f3b0538b8f10de88e73ef0",
            "date": "2021-12-30T07:35:32Z",
            "author_login": "oldlavender"
          },
          {
            "sha": "1620a263bf710de951c3273ad07b5dff8f00c146",
            "date": "2020-02-06T13:56:26Z",
            "author_login": "vv9k"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-191",
    "description": "rdesktop versions up to and including v1.8.3 contain an Integer Underflow that leads to a Heap-Based Buffer Overflow in the function seamless_process() and results in memory corruption and probably even a remote code execution.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2019-03-15T18:29:00.657",
    "last_modified": "2024-11-21T04:01:02.017",
    "fix_date": "2019-01-16T09:45:33Z"
  },
  "references": [
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00040.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/106938",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00030.html",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://research.checkpoint.com/reverse-rdp-attack-code-execution-on-rdp-clients/",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201903-06",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2019/dsa-4394",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00040.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/106938",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00030.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://research.checkpoint.com/reverse-rdp-attack-code-execution-on-rdp-clients/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/201903-06",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2019/dsa-4394",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:46.992343",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "rdesktop",
    "owner": "rdesktop",
    "created_at": "2015-07-06T15:35:15Z",
    "updated_at": "2025-01-09T10:14:17Z",
    "pushed_at": "2023-09-19T01:29:12Z",
    "size": 2487,
    "stars": 1300,
    "forks": 370,
    "open_issues": 121,
    "watchers": 1300,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1062889,
      "M4": 24950,
      "Makefile": 6036,
      "Shell": 5756,
      "Python": 2995
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-14T14:16:21.965646"
  }
}