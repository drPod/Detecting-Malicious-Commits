{
  "cve_id": "CVE-2018-20406",
  "github_data": {
    "repository": "python/cpython",
    "fix_commit": "a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd",
    "related_commits": [
      "a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd",
      "a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd"
    ],
    "patch_url": "https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd.patch",
    "fix_commit_details": {
      "sha": "a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd",
      "commit_date": "2018-09-21T01:36:40Z",
      "author": {
        "login": "benjaminp",
        "type": "User",
        "stats": {
          "total_commits": 5882,
          "average_weekly_commits": 3.271412680756396,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 488
        }
      },
      "commit_message": {
        "title": "closes bpo-34656: Avoid relying on signed overflow in _pickle memos. (GH-9261)",
        "length": 78,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 62,
        "additions": 31,
        "deletions": 31
      },
      "files": [
        {
          "filename": "Modules/_pickle.c",
          "status": "modified",
          "additions": 31,
          "deletions": 31,
          "patch": "@@ -602,9 +602,9 @@ typedef struct {\n } PyMemoEntry;\n \n typedef struct {\n-    Py_ssize_t mt_mask;\n-    Py_ssize_t mt_used;\n-    Py_ssize_t mt_allocated;\n+    size_t mt_mask;\n+    size_t mt_used;\n+    size_t mt_allocated;\n     PyMemoEntry *mt_table;\n } PyMemoTable;\n \n@@ -650,8 +650,8 @@ typedef struct UnpicklerObject {\n     /* The unpickler memo is just an array of PyObject *s. Using a dict\n        is unnecessary, since the keys are contiguous ints. */\n     PyObject **memo;\n-    Py_ssize_t memo_size;       /* Capacity of the memo array */\n-    Py_ssize_t memo_len;        /* Number of objects in the memo */\n+    size_t memo_size;       /* Capacity of the memo array */\n+    size_t memo_len;        /* Number of objects in the memo */\n \n     PyObject *pers_func;        /* persistent_load() method, can be NULL. */\n     PyObject *pers_func_self;   /* borrowed reference to self if pers_func\n@@ -737,7 +737,6 @@ PyMemoTable_New(void)\n static PyMemoTable *\n PyMemoTable_Copy(PyMemoTable *self)\n {\n-    Py_ssize_t i;\n     PyMemoTable *new = PyMemoTable_New();\n     if (new == NULL)\n         return NULL;\n@@ -754,7 +753,7 @@ PyMemoTable_Copy(PyMemoTable *self)\n         PyErr_NoMemory();\n         return NULL;\n     }\n-    for (i = 0; i < self->mt_allocated; i++) {\n+    for (size_t i = 0; i < self->mt_allocated; i++) {\n         Py_XINCREF(self->mt_table[i].me_key);\n     }\n     memcpy(new->mt_table, self->mt_table,\n@@ -800,7 +799,7 @@ _PyMemoTable_Lookup(PyMemoTable *self, PyObject *key)\n {\n     size_t i;\n     size_t perturb;\n-    size_t mask = (size_t)self->mt_mask;\n+    size_t mask = self->mt_mask;\n     PyMemoEntry *table = self->mt_table;\n     PyMemoEntry *entry;\n     Py_hash_t hash = (Py_hash_t)key >> 3;\n@@ -821,22 +820,24 @@ _PyMemoTable_Lookup(PyMemoTable *self, PyObject *key)\n \n /* Returns -1 on failure, 0 on success. */\n static int\n-_PyMemoTable_ResizeTable(PyMemoTable *self, Py_ssize_t min_size)\n+_PyMemoTable_ResizeTable(PyMemoTable *self, size_t min_size)\n {\n     PyMemoEntry *oldtable = NULL;\n     PyMemoEntry *oldentry, *newentry;\n-    Py_ssize_t new_size = MT_MINSIZE;\n-    Py_ssize_t to_process;\n+    size_t new_size = MT_MINSIZE;\n+    size_t to_process;\n \n     assert(min_size > 0);\n \n-    /* Find the smallest valid table size >= min_size. */\n-    while (new_size < min_size && new_size > 0)\n-        new_size <<= 1;\n-    if (new_size <= 0) {\n+    if (min_size > PY_SSIZE_T_MAX) {\n         PyErr_NoMemory();\n         return -1;\n     }\n+\n+    /* Find the smallest valid table size >= min_size. */\n+    while (new_size < min_size) {\n+        new_size <<= 1;\n+    }\n     /* new_size needs to be a power of two. */\n     assert((new_size & (new_size - 1)) == 0);\n \n@@ -909,10 +910,12 @@ PyMemoTable_Set(PyMemoTable *self, PyObject *key, Py_ssize_t value)\n      * Very large memo tables (over 50K items) use doubling instead.\n      * This may help applications with severe memory constraints.\n      */\n-    if (!(self->mt_used * 3 >= (self->mt_mask + 1) * 2))\n+    if (SIZE_MAX / 3 >= self->mt_used && self->mt_used * 3 < self->mt_allocated * 2) {\n         return 0;\n-    return _PyMemoTable_ResizeTable(self,\n-        (self->mt_used > 50000 ? 2 : 4) * self->mt_used);\n+    }\n+    // self->mt_used is always < PY_SSIZE_T_MAX, so this can't overflow.\n+    size_t desired_size = (self->mt_used > 50000 ? 2 : 4) * self->mt_used;\n+    return _PyMemoTable_ResizeTable(self, desired_size);\n }\n \n #undef MT_MINSIZE\n@@ -1376,9 +1379,9 @@ _Unpickler_Readline(UnpicklerObject *self, char **result)\n /* Returns -1 (with an exception set) on failure, 0 on success. The memo array\n    will be modified in place. */\n static int\n-_Unpickler_ResizeMemoList(UnpicklerObject *self, Py_ssize_t new_size)\n+_Unpickler_ResizeMemoList(UnpicklerObject *self, size_t new_size)\n {\n-    Py_ssize_t i;\n+    size_t i;\n \n     assert(new_size > self->memo_size);\n \n@@ -1397,9 +1400,9 @@ _Unpickler_ResizeMemoList(UnpicklerObject *self, Py_ssize_t new_size)\n \n /* Returns NULL if idx is out of bounds. */\n static PyObject *\n-_Unpickler_MemoGet(UnpicklerObject *self, Py_ssize_t idx)\n+_Unpickler_MemoGet(UnpicklerObject *self, size_t idx)\n {\n-    if (idx < 0 || idx >= self->memo_size)\n+    if (idx >= self->memo_size)\n         return NULL;\n \n     return self->memo[idx];\n@@ -1408,7 +1411,7 @@ _Unpickler_MemoGet(UnpicklerObject *self, Py_ssize_t idx)\n /* Returns -1 (with an exception set) on failure, 0 on success.\n    This takes its own reference to `value`. */\n static int\n-_Unpickler_MemoPut(UnpicklerObject *self, Py_ssize_t idx, PyObject *value)\n+_Unpickler_MemoPut(UnpicklerObject *self, size_t idx, PyObject *value)\n {\n     PyObject *old_item;\n \n@@ -4413,14 +4416,13 @@ static PyObject *\n _pickle_PicklerMemoProxy_copy_impl(PicklerMemoProxyObject *self)\n /*[clinic end generated code: output=bb83a919d29225ef input=b73043485ac30b36]*/\n {\n-    Py_ssize_t i;\n     PyMemoTable *memo;\n     PyObject *new_memo = PyDict_New();\n     if (new_memo == NULL)\n         return NULL;\n \n     memo = self->pickler->memo;\n-    for (i = 0; i < memo->mt_allocated; ++i) {\n+    for (size_t i = 0; i < memo->mt_allocated; ++i) {\n         PyMemoEntry entry = memo->mt_table[i];\n         if (entry.me_key != NULL) {\n             int status;\n@@ -6843,7 +6845,7 @@ static PyObject *\n _pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)\n /*[clinic end generated code: output=e12af7e9bc1e4c77 input=97769247ce032c1d]*/\n {\n-    Py_ssize_t i;\n+    size_t i;\n     PyObject *new_memo = PyDict_New();\n     if (new_memo == NULL)\n         return NULL;\n@@ -6994,8 +6996,7 @@ static int\n Unpickler_set_memo(UnpicklerObject *self, PyObject *obj)\n {\n     PyObject **new_memo;\n-    Py_ssize_t new_memo_size = 0;\n-    Py_ssize_t i;\n+    size_t new_memo_size = 0;\n \n     if (obj == NULL) {\n         PyErr_SetString(PyExc_TypeError,\n@@ -7012,7 +7013,7 @@ Unpickler_set_memo(UnpicklerObject *self, PyObject *obj)\n         if (new_memo == NULL)\n             return -1;\n \n-        for (i = 0; i < new_memo_size; i++) {\n+        for (size_t i = 0; i < new_memo_size; i++) {\n             Py_XINCREF(unpickler->memo[i]);\n             new_memo[i] = unpickler->memo[i];\n         }\n@@ -7060,8 +7061,7 @@ Unpickler_set_memo(UnpicklerObject *self, PyObject *obj)\n \n   error:\n     if (new_memo_size) {\n-        i = new_memo_size;\n-        while (--i >= 0) {\n+        for (size_t i = new_memo_size - 1; i != SIZE_MAX; i--) {\n             Py_XDECREF(new_memo[i]);\n         }\n         PyMem_FREE(new_memo);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "f7ceb317aec498823555885a4b7fed5e0244f300",
            "date": "2025-01-14T20:40:45Z",
            "author_login": "serhiy-storchaka"
          },
          {
            "sha": "b5ee0258bf5bb60a5a5a65c64717853e06b64808",
            "date": "2025-01-14T19:56:11Z",
            "author_login": "mpage"
          },
          {
            "sha": "1c13c56a34fc4c4d8969f0b6dc93d5208a50d61b",
            "date": "2025-01-14T19:43:42Z",
            "author_login": "nascheme"
          },
          {
            "sha": "d906bde250d59c396d8dab92285b832c66cdec27",
            "date": "2025-01-14T16:07:37Z",
            "author_login": "picnixz"
          },
          {
            "sha": "d786ac7f584f23c3206f4c86032bdabe83c17b51",
            "date": "2025-01-14T15:31:13Z",
            "author_login": "vstinner"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-190",
    "description": "Modules/_pickle.c in Python before 3.7.1 has an integer overflow via a large LONG_BINPUT value that is mishandled during a \"resize to twice the size\" attempt. This issue might cause memory exhaustion, but is only relevant if the pickle format is used for serializing tens or hundreds of gigabytes of data. This issue is fixed in: v3.4.10, v3.4.10rc1; v3.5.10, v3.5.10rc1, v3.5.7, v3.5.7rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.7, v3.6.7rc1, v3.6.7rc2, v3.6.8, v3.6.8rc1, v3.6.9, v3.6.9rc1; v3.7.1, v3.7.1rc1, v3.7.1rc2, v3.7.2, v3.7.2rc1, v3.7.3, v3.7.3rc1, v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-12-23T23:29:00.307",
    "last_modified": "2024-11-21T04:01:25.520",
    "fix_date": "2018-09-21T01:36:40Z"
  },
  "references": [
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2020-01/msg00040.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:3725",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://bugs.python.org/issue34656",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00011.html",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2020/07/msg00011.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/46PVWY5LFP4BRPG3BVQ5QEEFYBVEXHCK/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/AEZ5IQT7OF7Q2NCGIVABOWYGKO7YU3NJ/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/D3LXPABKVLFYUHRYJPM3CSS5MS6FXKS7/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ICBEGRHIPHWPG2VGYS6R4EVKVUUF4AQW/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JSKPGPZQNTAULHW4UH63KGOOUIDE4RRB/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TR6GCO3WTV4D5L23WTCBF275VE6BVNI3/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20190416-0010/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://usn.ubuntu.com/4127-1/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://usn.ubuntu.com/4127-2/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2020-01/msg00040.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:3725",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://bugs.python.org/issue34656",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00011.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2020/07/msg00011.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/46PVWY5LFP4BRPG3BVQ5QEEFYBVEXHCK/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/AEZ5IQT7OF7Q2NCGIVABOWYGKO7YU3NJ/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/D3LXPABKVLFYUHRYJPM3CSS5MS6FXKS7/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ICBEGRHIPHWPG2VGYS6R4EVKVUUF4AQW/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JSKPGPZQNTAULHW4UH63KGOOUIDE4RRB/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TR6GCO3WTV4D5L23WTCBF275VE6BVNI3/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20190416-0010/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://usn.ubuntu.com/4127-1/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://usn.ubuntu.com/4127-2/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:42.200583",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "cpython",
    "owner": "python",
    "created_at": "2017-02-10T19:23:51Z",
    "updated_at": "2025-01-14T11:40:35Z",
    "pushed_at": "2025-01-14T11:26:26Z",
    "size": 657526,
    "stars": 64721,
    "forks": 30871,
    "open_issues": 8974,
    "watchers": 64721,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "3.9",
      "3.10",
      "3.11",
      "3.12",
      "3.13",
      "main"
    ],
    "languages": {
      "Python": 35947988,
      "C": 20215174,
      "C++": 463381,
      "M4": 257753,
      "HTML": 206335,
      "Batchfile": 78178,
      "Shell": 71664,
      "Roff": 45666,
      "Makefile": 36295,
      "Objective-C": 33051,
      "Common Lisp": 24579,
      "PLSQL": 22886,
      "PowerShell": 20323,
      "Rich Text Format": 6905,
      "JavaScript": 4245,
      "Kotlin": 3800,
      "Assembly": 2552,
      "DTrace": 2196,
      "CSS": 1325,
      "XSLT": 1174,
      "CMake": 327,
      "VBScript": 70
    },
    "commit_activity": {
      "total_commits_last_year": 5718,
      "avg_commits_per_week": 109.96153846153847,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:09:03.245623"
  }
}