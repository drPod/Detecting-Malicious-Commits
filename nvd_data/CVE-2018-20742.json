{
  "cve_id": "CVE-2018-20742",
  "github_data": {
    "repository": "ucbrise/opaque",
    "fix_commit": "5ddda15d89f5ac82f4416208c5319ace4aecdc36",
    "related_commits": [
      "5ddda15d89f5ac82f4416208c5319ace4aecdc36",
      "5ddda15d89f5ac82f4416208c5319ace4aecdc36"
    ],
    "patch_url": "https://github.com/ucbrise/opaque/commit/5ddda15d89f5ac82f4416208c5319ace4aecdc36.patch",
    "fix_commit_details": {
      "sha": "5ddda15d89f5ac82f4416208c5319ace4aecdc36",
      "commit_date": "2018-12-01T09:11:22Z",
      "author": {
        "login": "ankurdave",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Check that ecall [user_check] pointers and ocall_malloc result pointer are outside enclave (#67)",
        "length": 370,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 83,
        "additions": 81,
        "deletions": 2
      },
      "files": [
        {
          "filename": "src/enclave/App/App.cpp",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -357,7 +357,7 @@ void ocall_print_string(const char *str)\n   fflush(stdout);\n }\n \n-void ocall_malloc(size_t size, uint8_t **ret) {\n+void unsafe_ocall_malloc(size_t size, uint8_t **ret) {\n   *ret = static_cast<uint8_t *>(malloc(size));\n }\n "
        },
        {
          "filename": "src/enclave/Enclave/Enclave.cpp",
          "status": "modified",
          "additions": 51,
          "deletions": 0,
          "patch": "@@ -10,6 +10,7 @@\n #include \"Project.h\"\n #include \"Sort.h\"\n #include \"isv_enclave.h\"\n+#include \"sgx_lfence.h\"\n #include \"util.h\"\n \n // This file contains definitions of the ecalls declared in Enclave.edl. Errors originating within\n@@ -19,6 +20,11 @@\n \n void ecall_encrypt(uint8_t *plaintext, uint32_t plaintext_length,\n                    uint8_t *ciphertext, uint32_t cipher_length) {\n+  // Guard against encrypting or overwriting enclave memory\n+  assert(sgx_is_outside_enclave(plaintext, plaintext_length) == 1);\n+  assert(sgx_is_outside_enclave(ciphertext, cipher_length) == 1);\n+  sgx_lfence();\n+\n   try {\n     // IV (12 bytes) + ciphertext + mac (16 bytes)\n     assert(cipher_length >= plaintext_length + SGX_AESGCM_IV_SIZE + SGX_AESGCM_MAC_SIZE);\n@@ -33,6 +39,10 @@ void ecall_encrypt(uint8_t *plaintext, uint32_t plaintext_length,\n void ecall_project(uint8_t *condition, size_t condition_length,\n                    uint8_t *input_rows, size_t input_rows_length,\n                    uint8_t **output_rows, size_t *output_rows_length) {\n+  // Guard against operating on arbitrary enclave memory\n+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n+  sgx_lfence();\n+\n   try {\n     project(condition, condition_length,\n             input_rows, input_rows_length,\n@@ -45,6 +55,10 @@ void ecall_project(uint8_t *condition, size_t condition_length,\n void ecall_filter(uint8_t *condition, size_t condition_length,\n                   uint8_t *input_rows, size_t input_rows_length,\n                   uint8_t **output_rows, size_t *output_rows_length) {\n+  // Guard against operating on arbitrary enclave memory\n+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n+  sgx_lfence();\n+\n   try {\n     filter(condition, condition_length,\n            input_rows, input_rows_length,\n@@ -56,6 +70,10 @@ void ecall_filter(uint8_t *condition, size_t condition_length,\n \n void ecall_sample(uint8_t *input_rows, size_t input_rows_length,\n                   uint8_t **output_rows, size_t *output_rows_length) {\n+  // Guard against operating on arbitrary enclave memory\n+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n+  sgx_lfence();\n+\n   try {\n     sample(input_rows, input_rows_length,\n            output_rows, output_rows_length);\n@@ -68,6 +86,10 @@ void ecall_find_range_bounds(uint8_t *sort_order, size_t sort_order_length,\n                              uint32_t num_partitions,\n                              uint8_t *input_rows, size_t input_rows_length,\n                              uint8_t **output_rows, size_t *output_rows_length) {\n+  // Guard against operating on arbitrary enclave memory\n+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n+  sgx_lfence();\n+\n   try {\n     find_range_bounds(sort_order, sort_order_length,\n                       num_partitions,\n@@ -83,6 +105,11 @@ void ecall_partition_for_sort(uint8_t *sort_order, size_t sort_order_length,\n                               uint8_t *input_rows, size_t input_rows_length,\n                               uint8_t *boundary_rows, size_t boundary_rows_length,\n                               uint8_t **output_partitions, size_t *output_partition_lengths) {\n+  // Guard against operating on arbitrary enclave memory\n+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n+  assert(sgx_is_outside_enclave(boundary_rows, boundary_rows_length) == 1);\n+  sgx_lfence();\n+\n   try {\n     partition_for_sort(sort_order, sort_order_length,\n                        num_partitions,\n@@ -97,6 +124,10 @@ void ecall_partition_for_sort(uint8_t *sort_order, size_t sort_order_length,\n void ecall_external_sort(uint8_t *sort_order, size_t sort_order_length,\n                          uint8_t *input_rows, size_t input_rows_length,\n                          uint8_t **output_rows, size_t *output_rows_length) {\n+  // Guard against operating on arbitrary enclave memory\n+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n+  sgx_lfence();\n+\n   try {\n     external_sort(sort_order, sort_order_length,\n                   input_rows, input_rows_length,\n@@ -109,6 +140,10 @@ void ecall_external_sort(uint8_t *sort_order, size_t sort_order_length,\n void ecall_scan_collect_last_primary(uint8_t *join_expr, size_t join_expr_length,\n                                      uint8_t *input_rows, size_t input_rows_length,\n                                      uint8_t **output_rows, size_t *output_rows_length) {\n+  // Guard against operating on arbitrary enclave memory\n+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n+  sgx_lfence();\n+\n   try {\n     scan_collect_last_primary(join_expr, join_expr_length,\n                               input_rows, input_rows_length,\n@@ -122,6 +157,11 @@ void ecall_non_oblivious_sort_merge_join(uint8_t *join_expr, size_t join_expr_le\n                                          uint8_t *input_rows, size_t input_rows_length,\n                                          uint8_t *join_row, size_t join_row_length,\n                                          uint8_t **output_rows, size_t *output_rows_length) {\n+  // Guard against operating on arbitrary enclave memory\n+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n+  assert(sgx_is_outside_enclave(join_row, join_row_length) == 1);\n+  sgx_lfence();\n+\n   try {\n     non_oblivious_sort_merge_join(join_expr, join_expr_length,\n                                   input_rows, input_rows_length,\n@@ -138,6 +178,10 @@ void ecall_non_oblivious_aggregate_step1(\n   uint8_t **first_row, size_t *first_row_length,\n   uint8_t **last_group, size_t *last_group_length,\n   uint8_t **last_row, size_t *last_row_length) {\n+  // Guard against operating on arbitrary enclave memory\n+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n+  sgx_lfence();\n+\n   try {\n     non_oblivious_aggregate_step1(\n       agg_op, agg_op_length,\n@@ -157,6 +201,13 @@ void ecall_non_oblivious_aggregate_step2(\n   uint8_t *prev_partition_last_group, size_t prev_partition_last_group_length,\n   uint8_t *prev_partition_last_row, size_t prev_partition_last_row_length,\n   uint8_t **output_rows, size_t *output_rows_length) {\n+  // Guard against operating on arbitrary enclave memory\n+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n+  assert(sgx_is_outside_enclave(next_partition_first_row, next_partition_first_row_length) == 1);\n+  assert(sgx_is_outside_enclave(prev_partition_last_group, prev_partition_last_group_length) == 1);\n+  assert(sgx_is_outside_enclave(prev_partition_last_row, prev_partition_last_row_length) == 1);\n+  sgx_lfence();\n+\n   try {\n     non_oblivious_aggregate_step2(\n       agg_op, agg_op_length,"
        },
        {
          "filename": "src/enclave/Enclave/Enclave.edl",
          "status": "modified",
          "additions": 12,
          "deletions": 1,
          "patch": "@@ -88,7 +88,18 @@ enclave {\n \n   untrusted {\n     void ocall_print_string([in, string] const char *str);\n-    void ocall_malloc(size_t size, [out] uint8_t **ret);\n+\n+    /**\n+     * Allocate memory outside of the enclave and return the pointer in `ret`.\n+     *\n+     * Before dereferencing the resulting pointer, the caller must check whether it is actually\n+     * outside the enclave using `sgx_is_outside_enclave()`. Otherwise, an attacker could cause the\n+     * enclave to perform unexpected operations on its own memory. The function `ocall_malloc()`\n+     * wraps this function with such a bounds check and most callers should use that function\n+     * instead.\n+     */\n+    void unsafe_ocall_malloc(size_t size, [out] uint8_t **ret);\n+\n     void ocall_free([user_check] uint8_t *buf);\n     void ocall_exit(int exit_code);\n     void ocall_throw([in, string] const char *message);"
        },
        {
          "filename": "src/enclave/Enclave/util.cpp",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -4,6 +4,7 @@\n #include <cstdio>\n \n #include \"Enclave_t.h\"\n+#include \"sgx_lfence.h\"\n \n int printf(const char *fmt, ...) {\n   char buf[BUFSIZ] = {'\\0'};\n@@ -38,6 +39,14 @@ void exit(int exit_code) {\n   ocall_exit(exit_code);\n }\n \n+void ocall_malloc(size_t size, uint8_t **ret) {\n+  unsafe_ocall_malloc(size, ret);\n+\n+  // Guard against overwriting enclave memory\n+  assert(sgx_is_outside_enclave(*ret, size) == 1);\n+  sgx_lfence();\n+}\n+\n void print_bytes(uint8_t *ptr, uint32_t len) {\n   for (uint32_t i = 0; i < len; i++) {\n     printf(\"%u\", *(ptr + i));"
        },
        {
          "filename": "src/enclave/Enclave/util.h",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -18,6 +18,14 @@ namespace std {\n     using ::exit;\n }\n \n+/**\n+ * Allocate memory outside of the enclave and return the pointer in `ret`.\n+ *\n+ * This is a checked wrapper around `unsafe_ocall_malloc`. The resulting pointer is safe to write\n+ * to.\n+ */\n+void ocall_malloc(size_t size, uint8_t **ret);\n+\n std::string string_format(const std::string &fmt, ...);\n \n void print_bytes(uint8_t *ptr, uint32_t len);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "98e0152104ef9249976a5926b136499c4166994c",
            "date": "2023-03-29T16:04:05Z",
            "author_login": "haibow"
          },
          {
            "sha": "d0bb5a9c1925945c0562a21051f8c079aad418ad",
            "date": "2022-02-18T02:15:04Z",
            "author_login": "octaviansima"
          },
          {
            "sha": "6f6edd7ccb0024bbf0e791199d4684fcf13882e0",
            "date": "2021-09-24T01:08:15Z",
            "author_login": "octaviansima"
          },
          {
            "sha": "1744b8a549ded68be7ecaf6f30bf0f85862d7000",
            "date": "2021-09-21T20:11:48Z",
            "author_login": "octaviansima"
          },
          {
            "sha": "8ea5583c2946f7035bc62128ba8f6a476f896a86",
            "date": "2021-08-27T19:31:01Z",
            "author_login": "wzheng"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-787",
    "description": "An issue was discovered in UC Berkeley RISE Opaque before 2018-12-01. There is no boundary check on ocall_malloc. The return value could be a pointer to enclave memory. It could cause an arbitrary enclave memory write.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2019-01-24T05:29:00.753",
    "last_modified": "2024-11-21T04:02:04.347",
    "fix_date": "2018-12-01T09:11:22Z"
  },
  "references": [
    {
      "url": "https://github.com/ucbrise/opaque/commit/5ddda15d89f5ac82f4416208c5319ace4aecdc36",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ucbrise/opaque/issues/66",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ucbrise/opaque/commit/5ddda15d89f5ac82f4416208c5319ace4aecdc36",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ucbrise/opaque/issues/66",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:44.407911",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "opaque-sql",
    "owner": "ucbrise",
    "created_at": "2016-10-31T19:09:35Z",
    "updated_at": "2024-12-13T12:06:30Z",
    "pushed_at": "2023-03-29T16:04:05Z",
    "size": 18925,
    "stars": 180,
    "forks": 74,
    "open_issues": 22,
    "watchers": 180,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Scala": 312667,
      "C++": 288513,
      "Assembly": 37794,
      "Shell": 31328,
      "Python": 11226,
      "C": 11133,
      "CMake": 6674,
      "Dockerfile": 1338,
      "Batchfile": 813,
      "Makefile": 608,
      "GDB": 164
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T19:57:34.925961"
  }
}