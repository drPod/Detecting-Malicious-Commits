{
  "cve_id": "CVE-2018-20786",
  "github_data": {
    "repository": "vim/vim",
    "fix_commit": "cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8",
    "related_commits": [
      "cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8",
      "cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8",
      "commit_date": "2018-12-24T20:38:45Z",
      "author": {
        "login": "brammool",
        "type": "User",
        "stats": {
          "total_commits": 16567,
          "average_weekly_commits": 15.382544103992572,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 874
        }
      },
      "commit_message": {
        "title": "patch 8.1.0633: crash when out of memory while opening a terminal window",
        "length": 193,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 90,
        "additions": 70,
        "deletions": 20
      },
      "files": [
        {
          "filename": "src/libvterm/src/state.c",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -53,6 +53,8 @@ static VTermState *vterm_state_new(VTerm *vt)\n {\n   VTermState *state = vterm_allocator_malloc(vt, sizeof(VTermState));\n \n+  if (state == NULL)\n+    return NULL;\n   state->vt = vt;\n \n   state->rows = vt->rows;\n@@ -1693,13 +1695,19 @@ static const VTermParserCallbacks parser_callbacks = {\n   on_resize /* resize */\n };\n \n+/*\n+ * Return the existing state or create a new one.\n+ * Returns NULL when out of memory.\n+ */\n VTermState *vterm_obtain_state(VTerm *vt)\n {\n   VTermState *state;\n   if(vt->state)\n     return vt->state;\n \n   state = vterm_state_new(vt);\n+  if (state == NULL)\n+    return NULL;\n   vt->state = state;\n \n   state->combine_chars_size = 16;"
        },
        {
          "filename": "src/libvterm/src/termscreen.c",
          "status": "modified",
          "additions": 16,
          "deletions": 12,
          "patch": "@@ -1,5 +1,6 @@\n #include \"vterm_internal.h\"\n \n+/* vim: set sw=2 : */\n #include <stdio.h>\n #include <string.h>\n \n@@ -95,8 +96,7 @@ static ScreenCell *realloc_buffer(VTermScreen *screen, ScreenCell *buffer, int n\n     }\n   }\n \n-  if(buffer)\n-    vterm_allocator_free(screen->vt, buffer);\n+  vterm_allocator_free(screen->vt, buffer);\n \n   return new_buffer;\n }\n@@ -518,8 +518,7 @@ static int resize(int new_rows, int new_cols, VTermPos *delta, void *user)\n   screen->rows = new_rows;\n   screen->cols = new_cols;\n \n-  if(screen->sb_buffer)\n-    vterm_allocator_free(screen->vt, screen->sb_buffer);\n+  vterm_allocator_free(screen->vt, screen->sb_buffer);\n \n   screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * new_cols);\n \n@@ -619,16 +618,21 @@ static VTermStateCallbacks state_cbs = {\n   &setlineinfo /* setlineinfo */\n };\n \n+/*\n+ * Allocate a new screen and return it.\n+ * Return NULL when out of memory.\n+ */\n static VTermScreen *screen_new(VTerm *vt)\n {\n   VTermState *state = vterm_obtain_state(vt);\n   VTermScreen *screen;\n   int rows, cols;\n \n-  if(!state)\n+  if (state == NULL)\n     return NULL;\n-\n   screen = vterm_allocator_malloc(vt, sizeof(VTermScreen));\n+  if (screen == NULL)\n+    return NULL;\n \n   vterm_get_size(vt, &rows, &cols);\n \n@@ -646,10 +650,13 @@ static VTermScreen *screen_new(VTerm *vt)\n   screen->cbdata    = NULL;\n \n   screen->buffers[0] = realloc_buffer(screen, NULL, rows, cols);\n-\n   screen->buffer = screen->buffers[0];\n-\n   screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * cols);\n+  if (screen->buffer == NULL || screen->sb_buffer == NULL)\n+  {\n+    vterm_screen_free(screen);\n+    return NULL;\n+  }\n \n   vterm_state_set_callbacks(screen->state, &state_cbs, screen);\n \n@@ -659,11 +666,8 @@ static VTermScreen *screen_new(VTerm *vt)\n INTERNAL void vterm_screen_free(VTermScreen *screen)\n {\n   vterm_allocator_free(screen->vt, screen->buffers[0]);\n-  if(screen->buffers[1])\n-    vterm_allocator_free(screen->vt, screen->buffers[1]);\n-\n+  vterm_allocator_free(screen->vt, screen->buffers[1]);\n   vterm_allocator_free(screen->vt, screen->sb_buffer);\n-\n   vterm_allocator_free(screen->vt, screen);\n }\n "
        },
        {
          "filename": "src/libvterm/src/vterm.c",
          "status": "modified",
          "additions": 19,
          "deletions": 1,
          "patch": "@@ -1,5 +1,6 @@\n #define DEFINE_INLINES\n \n+/* vim: set sw=2 : */\n #include \"vterm_internal.h\"\n \n #include <stdio.h>\n@@ -41,6 +42,8 @@ VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *fun\n   /* Need to bootstrap using the allocator function directly */\n   VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);\n \n+  if (vt == NULL)\n+    return NULL;\n   vt->allocator = funcs;\n   vt->allocdata = allocdata;\n \n@@ -55,10 +58,21 @@ VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *fun\n   vt->parser.strbuffer_len = 500; /* should be able to hold an OSC string */\n   vt->parser.strbuffer_cur = 0;\n   vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);\n+  if (vt->parser.strbuffer == NULL)\n+  {\n+    vterm_allocator_free(vt, vt);\n+    return NULL;\n+  }\n \n   vt->outbuffer_len = 200;\n   vt->outbuffer_cur = 0;\n   vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);\n+  if (vt->outbuffer == NULL)\n+  {\n+    vterm_allocator_free(vt, vt->parser.strbuffer);\n+    vterm_allocator_free(vt, vt);\n+    return NULL;\n+  }\n \n   return vt;\n }\n@@ -82,9 +96,13 @@ INTERNAL void *vterm_allocator_malloc(VTerm *vt, size_t size)\n   return (*vt->allocator->malloc)(size, vt->allocdata);\n }\n \n+/*\n+ * Free \"ptr\" unless it is NULL.\n+ */\n INTERNAL void vterm_allocator_free(VTerm *vt, void *ptr)\n {\n-  (*vt->allocator->free)(ptr, vt->allocdata);\n+  if (ptr)\n+    (*vt->allocator->free)(ptr, vt->allocdata);\n }\n \n void vterm_get_size(const VTerm *vt, int *rowsp, int *colsp)"
        },
        {
          "filename": "src/terminal.c",
          "status": "modified",
          "additions": 25,
          "deletions": 7,
          "patch": "@@ -3430,6 +3430,7 @@ set_vterm_palette(VTerm *vterm, long_u *rgb)\n {\n     int\t\tindex = 0;\n     VTermState\t*state = vterm_obtain_state(vterm);\n+\n     for (; index < 16; index++)\n     {\n \tVTermColor\tcolor;\n@@ -3703,8 +3704,9 @@ static VTermAllocatorFunctions vterm_allocator = {\n \n /*\n  * Create a new vterm and initialize it.\n+ * Return FAIL when out of memory.\n  */\n-    static void\n+    static int\n create_vterm(term_T *term, int rows, int cols)\n {\n     VTerm\t    *vterm;\n@@ -3714,15 +3716,26 @@ create_vterm(term_T *term, int rows, int cols)\n \n     vterm = vterm_new_with_allocator(rows, cols, &vterm_allocator, NULL);\n     term->tl_vterm = vterm;\n+    if (vterm == NULL)\n+\treturn FAIL;\n+\n+    // Allocate screen and state here, so we can bail out if that fails.\n+    state = vterm_obtain_state(vterm);\n     screen = vterm_obtain_screen(vterm);\n+    if (state == NULL || screen == NULL)\n+    {\n+\tvterm_free(vterm);\n+\treturn FAIL;\n+    }\n+\n     vterm_screen_set_callbacks(screen, &screen_callbacks, term);\n     /* TODO: depends on 'encoding'. */\n     vterm_set_utf8(vterm, 1);\n \n     init_default_colors(term);\n \n     vterm_state_set_default_colors(\n-\t    vterm_obtain_state(vterm),\n+\t    state,\n \t    &term->tl_default_color.fg,\n \t    &term->tl_default_color.bg);\n \n@@ -3746,9 +3759,10 @@ create_vterm(term_T *term, int rows, int cols)\n #else\n     value.boolean = 0;\n #endif\n-    state = vterm_obtain_state(vterm);\n     vterm_state_set_termprop(state, VTERM_PROP_CURSORBLINK, &value);\n     vterm_state_set_unrecognised_fallbacks(state, &parser_fallbacks, term);\n+\n+    return OK;\n }\n \n /*\n@@ -5629,7 +5643,8 @@ term_and_job_init(\n     vim_free(cwd_wchar);\n     vim_free(env_wchar);\n \n-    create_vterm(term, term->tl_rows, term->tl_cols);\n+    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n+\tgoto failed;\n \n #if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n     if (opt->jo_set2 & JO2_ANSI_COLORS)\n@@ -5710,7 +5725,8 @@ create_pty_only(term_T *term, jobopt_T *options)\n     char\t    in_name[80], out_name[80];\n     channel_T\t    *channel = NULL;\n \n-    create_vterm(term, term->tl_rows, term->tl_cols);\n+    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n+\treturn FAIL;\n \n     vim_snprintf(in_name, sizeof(in_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-in-%d\",\n \t    GetCurrentProcessId(),\n@@ -5822,7 +5838,8 @@ term_and_job_init(\n \tjobopt_T    *opt,\n \tjobopt_T    *orig_opt UNUSED)\n {\n-    create_vterm(term, term->tl_rows, term->tl_cols);\n+    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n+\treturn FAIL;\n \n #if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n     if (opt->jo_set2 & JO2_ANSI_COLORS)\n@@ -5844,7 +5861,8 @@ term_and_job_init(\n     static int\n create_pty_only(term_T *term, jobopt_T *opt)\n {\n-    create_vterm(term, term->tl_rows, term->tl_cols);\n+    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n+\treturn FAIL;\n \n     term->tl_job = job_alloc();\n     if (term->tl_job == NULL)"
        },
        {
          "filename": "src/version.c",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -799,6 +799,8 @@ static char *(features[]) =\n \n static int included_patches[] =\n {   /* Add new patch number below this line */\n+/**/\n+    633,\n /**/\n     632,\n /**/"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "fb49e3cde79de4ce558c86d21a56eb9d60aeabd5",
            "date": "2025-01-25T15:18:51Z",
            "author_login": "chrisbra"
          },
          {
            "sha": "c729d6d154e097b439ff264b9736604824f4a5f4",
            "date": "2025-01-25T15:07:12Z",
            "author_login": "saccarosium"
          },
          {
            "sha": "d65aa1bbdb808ef8fecde6df240c48cc39a52a8e",
            "date": "2025-01-25T14:29:03Z",
            "author_login": "zeertzjq"
          },
          {
            "sha": "509a8d58f9a8ce00744114c1f21f0d951a559ecd",
            "date": "2025-01-25T14:26:09Z",
            "author_login": "pbnj"
          },
          {
            "sha": "99181205c5f8284a30f839107a12932924168f17",
            "date": "2025-01-25T13:54:28Z",
            "author_login": "chrisbra"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-476",
    "description": "libvterm through 0+bzr726, as used in Vim and other products, mishandles certain out-of-memory conditions, leading to a denial of service (application crash), related to screen.c, state.c, and vterm.c.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2019-02-24T14:29:00.283",
    "last_modified": "2024-11-21T04:02:10.427",
    "fix_date": "2018-12-24T20:38:45Z"
  },
  "references": [
    {
      "url": "https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vim/vim/issues/3711",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://usn.ubuntu.com/4309-1/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vim/vim/issues/3711",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://usn.ubuntu.com/4309-1/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:44.491944",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "vim",
    "owner": "vim",
    "created_at": "2015-08-18T21:03:56Z",
    "updated_at": "2025-01-26T05:55:44Z",
    "pushed_at": "2025-01-25T15:21:53Z",
    "size": 155300,
    "stars": 37307,
    "forks": 5538,
    "open_issues": 1502,
    "watchers": 37307,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Vim Script": 19563490,
      "C": 14392521,
      "Roff": 576344,
      "Makefile": 496830,
      "C++": 246793,
      "NSIS": 179173,
      "M4": 159971,
      "Java": 85446,
      "Shell": 71333,
      "PostScript": 64070,
      "Module Management System": 56375,
      "Python": 51761,
      "XS": 51261,
      "Ruby": 40309,
      "JavaScript": 37774,
      "NewLisp": 37431,
      "Raku": 34258,
      "Emacs Lisp": 30304,
      "Perl": 29735,
      "SystemVerilog": 27883,
      "Smalltalk": 25762,
      "Awk": 19481,
      "Batchfile": 19124,
      "Objective-C": 13147,
      "DIGITAL Command Language": 10835,
      "HTML": 6885,
      "Prolog": 4336,
      "KRL": 4206,
      "MATLAB": 1970,
      "Thrift": 1670,
      "OpenEdge ABL": 1490,
      "sed": 826,
      "Tcl": 745,
      "Lua": 738,
      "BitBake": 388,
      "TeX": 225
    },
    "commit_activity": {
      "total_commits_last_year": 1869,
      "avg_commits_per_week": 35.94230769230769,
      "days_active_last_year": 322
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "vim"
    },
    "collected_at": "2025-01-26T07:35:34.408543"
  }
}