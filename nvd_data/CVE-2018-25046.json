{
  "cve_id": "CVE-2018-25046",
  "github_data": {
    "repository": "cloudfoundry/archiver",
    "fix_commit": "09b5706aa9367972c09144a450bb4523049ee840",
    "related_commits": [
      "09b5706aa9367972c09144a450bb4523049ee840",
      "09b5706aa9367972c09144a450bb4523049ee840"
    ],
    "patch_url": "https://github.com/cloudfoundry/archiver/commit/09b5706aa9367972c09144a450bb4523049ee840.patch",
    "fix_commit_details": {
      "sha": "09b5706aa9367972c09144a450bb4523049ee840",
      "commit_date": "2018-05-23T22:22:29Z",
      "author": {
        "login": "sjolicoeur",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Refactored the path resolution to use securejoin",
        "length": 106,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 114,
        "additions": 109,
        "deletions": 5
      },
      "files": [
        {
          "filename": "extractor/extractor_test.go",
          "status": "modified",
          "additions": 97,
          "deletions": 0,
          "patch": "@@ -120,6 +120,24 @@ var _ = Describe(\"Extractor\", func() {\n \t\t\t})\n \n \t\t\tIt(\"extracts the ZIP's files, generating directories, and honoring file permissions and symlinks\", extractionTest)\n+\n+\t\t\tContext(\"with a bad zip archive\", func() {\n+\t\t\t\tBeforeEach(func() {\n+\t\t\t\t\ttest_helper.CreateZipArchive(extractionSrc, []test_helper.ArchiveFile{\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tName: \"../some-file\",\n+\t\t\t\t\t\t\tBody: \"file-in-bad-dir-contents\",\n+\t\t\t\t\t\t},\n+\t\t\t\t\t})\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"returns an error\", func() {\n+\t\t\t\t\tsubdir := filepath.Join(extractionDest, \"subdir\")\n+\t\t\t\t\tExpect(os.Mkdir(subdir, 0777)).To(Succeed())\n+\t\t\t\t\terr := extractor.Extract(extractionSrc, subdir)\n+\t\t\t\t\tExpect(err).To(HaveOccurred())\n+\t\t\t\t})\n+\t\t\t})\n \t\t})\n \n \t\tContext(\"when 'unzip' is not in the PATH\", func() {\n@@ -138,6 +156,27 @@ var _ = Describe(\"Extractor\", func() {\n \t\t\t})\n \n \t\t\tIt(\"extracts the ZIP's files, generating directories, and honoring file permissions and symlinks\", extractionTest)\n+\n+\t\t\tContext(\"with a bad zip archive\", func() {\n+\t\t\t\tBeforeEach(func() {\n+\t\t\t\t\ttest_helper.CreateZipArchive(extractionSrc, []test_helper.ArchiveFile{\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tName: \"../some-file\",\n+\t\t\t\t\t\t\tBody: \"file-in-bad-dir-contents\",\n+\t\t\t\t\t\t},\n+\t\t\t\t\t})\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"does not insecurely extract the file outside of the provided destination\", func() {\n+\t\t\t\t\tsubdir := filepath.Join(extractionDest, \"subdir\")\n+\t\t\t\t\tExpect(os.Mkdir(subdir, 0777)).To(Succeed())\n+\t\t\t\t\terr := extractor.Extract(extractionSrc, subdir)\n+\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n+\n+\t\t\t\t\tExpect(filepath.Join(extractionDest, \"some-file\")).NotTo(BeAnExistingFile())\n+\t\t\t\t\tExpect(filepath.Join(subdir, \"some-file\")).To(BeAnExistingFile())\n+\t\t\t\t})\n+\t\t\t})\n \t\t})\n \t})\n \n@@ -153,6 +192,24 @@ var _ = Describe(\"Extractor\", func() {\n \t\t\t})\n \n \t\t\tIt(\"extracts the TGZ's files, generating directories, and honoring file permissions and symlinks\", extractionTest)\n+\n+\t\t\tContext(\"with a bad tgz archive\", func() {\n+\t\t\t\tBeforeEach(func() {\n+\t\t\t\t\ttest_helper.CreateTarGZArchive(extractionSrc, []test_helper.ArchiveFile{\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tName: \"../some-file\",\n+\t\t\t\t\t\t\tBody: \"file-in-bad-dir-contents\",\n+\t\t\t\t\t\t},\n+\t\t\t\t\t})\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"returns an error\", func() {\n+\t\t\t\t\tsubdir := filepath.Join(extractionDest, \"subdir\")\n+\t\t\t\t\tExpect(os.Mkdir(subdir, 0777)).To(Succeed())\n+\t\t\t\t\terr := extractor.Extract(extractionSrc, subdir)\n+\t\t\t\t\tExpect(err).To(HaveOccurred())\n+\t\t\t\t})\n+\t\t\t})\n \t\t})\n \n \t\tContext(\"when 'tar' is not in the PATH\", func() {\n@@ -171,6 +228,26 @@ var _ = Describe(\"Extractor\", func() {\n \t\t\t})\n \n \t\t\tIt(\"extracts the TGZ's files, generating directories, and honoring file permissions and symlinks\", extractionTest)\n+\n+\t\t\tContext(\"with a bad tgz archive\", func() {\n+\t\t\t\tBeforeEach(func() {\n+\t\t\t\t\ttest_helper.CreateTarGZArchive(extractionSrc, []test_helper.ArchiveFile{\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tName: \"../some-file\",\n+\t\t\t\t\t\t\tBody: \"file-in-bad-dir-contents\",\n+\t\t\t\t\t\t},\n+\t\t\t\t\t})\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"does not insecurely extract the file outside of the provided destination\", func() {\n+\t\t\t\t\tsubdir := filepath.Join(extractionDest, \"subdir\")\n+\t\t\t\t\tExpect(os.Mkdir(subdir, 0777)).To(Succeed())\n+\t\t\t\t\terr := extractor.Extract(extractionSrc, subdir)\n+\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n+\t\t\t\t\tExpect(filepath.Join(extractionDest, \"some-file\")).NotTo(BeAnExistingFile())\n+\t\t\t\t\tExpect(filepath.Join(subdir, \"some-file\")).To(BeAnExistingFile())\n+\t\t\t\t})\n+\t\t\t})\n \t\t})\n \t})\n \n@@ -181,5 +258,25 @@ var _ = Describe(\"Extractor\", func() {\n \t\t})\n \n \t\tIt(\"extracts the TAR's files, generating directories, and honoring file permissions and symlinks\", extractionTest)\n+\n+\t\tContext(\"with a bad tar archive\", func() {\n+\t\t\tBeforeEach(func() {\n+\t\t\t\ttest_helper.CreateTarArchive(extractionSrc, []test_helper.ArchiveFile{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tName: \"../some-file\",\n+\t\t\t\t\t\tBody: \"file-in-bad-dir-contents\",\n+\t\t\t\t\t},\n+\t\t\t\t})\n+\t\t\t})\n+\n+\t\t\tIt(\"does not insecurely extract the file outside of the provided destination\", func() {\n+\t\t\t\tsubdir := filepath.Join(extractionDest, \"subdir\")\n+\t\t\t\tExpect(os.Mkdir(subdir, 0777)).To(Succeed())\n+\t\t\t\terr := extractor.Extract(extractionSrc, subdir)\n+\t\t\t\tExpect(err).NotTo(HaveOccurred())\n+\t\t\t\tExpect(filepath.Join(extractionDest, \"some-file\")).NotTo(BeAnExistingFile())\n+\t\t\t\tExpect(filepath.Join(subdir, \"some-file\")).To(BeAnExistingFile())\n+\t\t\t})\n+\t\t})\n \t})\n })"
        },
        {
          "filename": "extractor/tgz_extractor.go",
          "status": "modified",
          "additions": 7,
          "deletions": 2,
          "patch": "@@ -8,6 +8,8 @@ import (\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n+\n+\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n )\n \n type tgzExtractor struct{}\n@@ -87,14 +89,17 @@ func extractTarArchive(tarReader *tar.Reader, dest string) error {\n }\n \n func extractTarArchiveFile(header *tar.Header, dest string, input io.Reader) error {\n-\tfilePath := filepath.Join(dest, header.Name)\n+\tfilePath, err := securejoin.SecureJoin(dest, header.Name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tfileInfo := header.FileInfo()\n \n \tif fileInfo.IsDir() {\n \t\treturn os.MkdirAll(filePath, fileInfo.Mode())\n \t}\n \n-\terr := os.MkdirAll(filepath.Dir(filePath), 0755)\n+\terr = os.MkdirAll(filepath.Dir(filePath), 0755)\n \tif err != nil {\n \t\treturn err\n \t}"
        },
        {
          "filename": "extractor/zip_extractor.go",
          "status": "modified",
          "additions": 5,
          "deletions": 3,
          "patch": "@@ -8,6 +8,8 @@ import (\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n+\n+\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n )\n \n type zipExtractor struct{}\n@@ -77,16 +79,16 @@ func extractZip(src, dest string) error {\n }\n \n func extractZipArchiveFile(file *zip.File, dest string, input io.Reader) error {\n-\tfilePath := filepath.Join(dest, file.Name)\n+\tfilePath, err := securejoin.SecureJoin(dest, file.Name)\n \tfileInfo := file.FileInfo()\n \n \tif fileInfo.IsDir() {\n-\t\terr := os.MkdirAll(filePath, fileInfo.Mode())\n+\t\terr = os.MkdirAll(filePath, fileInfo.Mode())\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \t} else {\n-\t\terr := os.MkdirAll(filepath.Dir(filePath), 0755)\n+\t\terr = os.MkdirAll(filepath.Dir(filePath), 0755)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "a2294ad028f6cd30989b49cf3bd71d5588fe11a2",
            "date": "2025-01-14T00:21:26Z",
            "author_login": "tas-runtime-bot"
          },
          {
            "sha": "0d2c10b6625e7c7d56751cd7c2d026879888ef53",
            "date": "2025-01-07T00:18:58Z",
            "author_login": "tas-runtime-bot"
          },
          {
            "sha": "0c1685186123162df611cfbce69b1a5cc76e3a58",
            "date": "2024-12-31T00:18:51Z",
            "author_login": "tas-runtime-bot"
          },
          {
            "sha": "8d28dac63d93a84d70b6d25ebe1abef478b5efce",
            "date": "2024-12-24T00:17:55Z",
            "author_login": "tas-runtime-bot"
          },
          {
            "sha": "4b156aa19cc18728bcf0f504b75213da4d64d850",
            "date": "2024-12-17T00:16:08Z",
            "author_login": "tas-runtime-bot"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H",
    "cwe_id": "CWE-22",
    "description": "Due to improper path sanitization, archives containing relative file paths can cause files to be written (or overwritten) outside of the target directory.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-12-27T22:15:11.140",
    "last_modified": "2024-11-21T04:03:25.993",
    "fix_date": "2018-05-23T22:22:29Z"
  },
  "references": [
    {
      "url": "https://github.com/cloudfoundry/archiver/commit/09b5706aa9367972c09144a450bb4523049ee840",
      "source": "security@golang.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://pkg.go.dev/vuln/GO-2020-0025",
      "source": "security@golang.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://snyk.io/research/zip-slip-vulnerability",
      "source": "security@golang.org",
      "tags": [
        "Technical Description",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/cloudfoundry/archiver/commit/09b5706aa9367972c09144a450bb4523049ee840",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://pkg.go.dev/vuln/GO-2020-0025",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://snyk.io/research/zip-slip-vulnerability",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Technical Description",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:23.221139",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "archiver",
    "owner": "cloudfoundry",
    "created_at": "2014-04-12T00:04:44Z",
    "updated_at": "2025-01-14T00:21:49Z",
    "pushed_at": "2025-01-14T00:21:45Z",
    "size": 4227,
    "stars": 28,
    "forks": 16,
    "open_issues": 1,
    "watchers": 28,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "develop",
      "main"
    ],
    "languages": {
      "Go": 23756,
      "Shell": 1602
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:04:01.008026"
  }
}