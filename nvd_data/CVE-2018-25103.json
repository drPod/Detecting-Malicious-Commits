{
  "cve_id": "CVE-2018-25103",
  "github_data": {
    "repository": "lighttpd/lighttpd1.4",
    "fix_commit": "d161f53de04bc826ce1bdaeb3dce2c72ca50a3f8",
    "related_commits": [
      "d161f53de04bc826ce1bdaeb3dce2c72ca50a3f8",
      "df8e4f95614e476276a55e34da2aa8b00b1148e9",
      "d161f53de04bc826ce1bdaeb3dce2c72ca50a3f8",
      "df8e4f95614e476276a55e34da2aa8b00b1148e9"
    ],
    "patch_url": "https://github.com/lighttpd/lighttpd1.4/commit/d161f53de04bc826ce1bdaeb3dce2c72ca50a3f8.patch",
    "fix_commit_details": {
      "sha": "d161f53de04bc826ce1bdaeb3dce2c72ca50a3f8",
      "commit_date": "2018-07-24T02:25:23Z",
      "author": {
        "login": "gstrauss",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "[core] security: use-after-free invalid Range req",
        "length": 72,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 128,
        "additions": 75,
        "deletions": 53
      },
      "files": [
        {
          "filename": "src/base.h",
          "status": "modified",
          "additions": 0,
          "deletions": 4,
          "patch": "@@ -47,7 +47,6 @@ typedef struct {\n \n \t/* strings to the header */\n \tbuffer *http_host; /* not alloced */\n-\tconst char   *http_range;\n \tconst char   *http_content_type;\n \tconst char   *http_if_modified_since;\n \tconst char   *http_if_none_match;\n@@ -58,9 +57,6 @@ typedef struct {\n \toff_t content_length; /* returned by strtoll() */\n \toff_t te_chunked;\n \n-\t/* internal representation */\n-\tint     accept_encoding;\n-\n \t/* internal */\n \tbuffer *pathinfo;\n } request;"
        },
        {
          "filename": "src/connections.c",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -685,7 +685,6 @@ int connection_reset(server *srv, connection *con) {\n \t\tcon->request.x = NULL;\n \n \tCLEAN(http_host);\n-\tCLEAN(http_range);\n \tCLEAN(http_content_type);\n #undef CLEAN\n \tcon->request.content_length = 0;"
        },
        {
          "filename": "src/http-header-glue.c",
          "status": "modified",
          "additions": 25,
          "deletions": 20,
          "patch": "@@ -229,7 +229,7 @@ int http_response_handle_cachable(server *srv, connection *con, buffer *mtime) {\n }\n \n \n-static int http_response_parse_range(server *srv, connection *con, buffer *path, stat_cache_entry *sce) {\n+static int http_response_parse_range(server *srv, connection *con, buffer *path, stat_cache_entry *sce, const char *range) {\n \tint multipart = 0;\n \tint error;\n \toff_t start, end;\n@@ -247,11 +247,26 @@ static int http_response_parse_range(server *srv, connection *con, buffer *path,\n \t\tcontent_type = ds->value;\n \t}\n \n-\tfor (s = con->request.http_range, error = 0;\n+\tfor (s = range, error = 0;\n \t     !error && *s && NULL != (minus = strchr(s, '-')); ) {\n \t\tchar *err;\n \t\toff_t la, le;\n \n+\t\tif (s != minus) {\n+\t\t\tla = strtoll(s, &err, 10);\n+\t\t\tif (err != minus) {\n+\t\t\t\t/* should not have multiple range-unit in Range, but\n+\t\t\t\t * handle just in case multiple Range headers merged */\n+\t\t\t\twhile (*s == ' ' || *s == '\\t') ++s;\n+\t\t\t\tif (0 != strncmp(s, \"bytes=\", 6)) return -1;\n+\t\t\t\ts += 6;\n+\t\t\t\tif (s != minus) {\n+\t\t\t\t\tla = strtoll(s, &err, 10);\n+\t\t\t\t\tif (err != minus) return -1;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n \t\tif (s == minus) {\n \t\t\t/* -<stop> */\n \n@@ -281,9 +296,6 @@ static int http_response_parse_range(server *srv, connection *con, buffer *path,\n \t\t} else if (*(minus+1) == '\\0' || *(minus+1) == ',') {\n \t\t\t/* <start>- */\n \n-\t\t\tla = strtoll(s, &err, 10);\n-\n-\t\t\tif (err == minus) {\n \t\t\t\t/* ok */\n \n \t\t\t\tif (*(err + 1) == '\\0') {\n@@ -301,16 +313,9 @@ static int http_response_parse_range(server *srv, connection *con, buffer *path,\n \t\t\t\t} else {\n \t\t\t\t\terror = 1;\n \t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t/* error */\n-\t\t\t\terror = 1;\n-\t\t\t}\n \t\t} else {\n \t\t\t/* <start>-<stop> */\n \n-\t\t\tla = strtoll(s, &err, 10);\n-\n-\t\t\tif (err == minus) {\n \t\t\t\tle = strtoll(minus+1, &err, 10);\n \n \t\t\t\t/* RFC 2616 - 14.35.1 */\n@@ -335,11 +340,6 @@ static int http_response_parse_range(server *srv, connection *con, buffer *path,\n \n \t\t\t\t\terror = 1;\n \t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t/* error */\n-\n-\t\t\t\terror = 1;\n-\t\t\t}\n \t\t}\n \n \t\tif (!error) {\n@@ -516,9 +516,11 @@ void http_response_send_file (server *srv, connection *con, buffer *path) {\n \t\t}\n \t}\n \n-\tif (con->request.http_range && con->conf.range_requests\n+\tif (con->conf.range_requests\n \t    && (200 == con->http_status || 0 == con->http_status)\n+\t    && NULL != (ds = (data_string *)array_get_element(con->request.headers, \"Range\"))\n \t    && NULL == array_get_element(con->response.headers, \"Content-Encoding\")) {\n+\t\tbuffer *range = ds->value;\n \t\tint do_range_request = 1;\n \t\t/* check if we have a conditional GET */\n \n@@ -547,11 +549,14 @@ void http_response_send_file (server *srv, connection *con, buffer *path) {\n \t\t\t}\n \t\t}\n \n-\t\tif (do_range_request) {\n+\t\tif (do_range_request\n+\t\t    && !buffer_string_is_empty(range)\n+\t\t    && 0 == strncmp(range->ptr, \"bytes=\", 6)) {\n+\t\t\t/* support only \"bytes\" byte-unit */\n \t\t\t/* content prepared, I'm done */\n \t\t\tcon->file_finished = 1;\n \n-\t\t\tif (0 == http_response_parse_range(srv, con, path, sce)) {\n+\t\t\tif (0 == http_response_parse_range(srv, con, path, sce, range->ptr+6)) {\n \t\t\t\tcon->http_status = 206;\n \t\t\t}\n \t\t\treturn;"
        },
        {
          "filename": "src/request.c",
          "status": "modified",
          "additions": 0,
          "deletions": 24,
          "patch": "@@ -1118,30 +1118,6 @@ int http_request_parse(server *srv, connection *con) {\n \t\t\t\t\t\t\t\t\tds->free((data_unset*) ds);\n \t\t\t\t\t\t\t\t\tds = NULL;\n \t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t} else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN(\"Range\")))) {\n-\t\t\t\t\t\t\t\tif (!con->request.http_range) {\n-\t\t\t\t\t\t\t\t\t/* bytes=.*-.* */\n-\n-\t\t\t\t\t\t\t\t\tif (0 == strncasecmp(ds->value->ptr, \"bytes=\", 6) &&\n-\t\t\t\t\t\t\t\t\t    NULL != strchr(ds->value->ptr+6, '-')) {\n-\n-\t\t\t\t\t\t\t\t\t\t/* if dup, only the first one will survive */\n-\t\t\t\t\t\t\t\t\t\tcon->request.http_range = ds->value->ptr + 6;\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\tcon->http_status = 400;\n-\t\t\t\t\t\t\t\t\tcon->keep_alive = 0;\n-\n-\t\t\t\t\t\t\t\t\tif (srv->srvconf.log_request_header_on_error) {\n-\t\t\t\t\t\t\t\t\t\tlog_error_write(srv, __FILE__, __LINE__, \"s\",\n-\t\t\t\t\t\t\t\t\t\t\t\t\"duplicate Range-header -> 400\");\n-\t\t\t\t\t\t\t\t\t\tlog_error_write(srv, __FILE__, __LINE__, \"Sb\",\n-\t\t\t\t\t\t\t\t\t\t\t\t\"request-header:\\n\",\n-\t\t\t\t\t\t\t\t\t\t\t\tcon->request.request);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\tarray_insert_unique(con->request.headers, (data_unset *)ds);\n-\t\t\t\t\t\t\t\t\treturn 0;\n-\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tif (ds) array_insert_unique(con->request.headers, (data_unset *)ds);"
        },
        {
          "filename": "src/t/test_request.c",
          "status": "modified",
          "additions": 29,
          "deletions": 3,
          "patch": "@@ -13,7 +13,6 @@ static void test_request_connection_reset(connection *con)\n     con->request.http_method = HTTP_METHOD_UNSET;\n     con->request.http_version = HTTP_VERSION_UNSET;\n     con->request.http_host = NULL;\n-    con->request.http_range = NULL;\n     con->request.http_content_type = NULL;\n     con->request.http_if_modified_since = NULL;\n     con->request.http_if_none_match = NULL;\n@@ -372,13 +371,40 @@ static void test_request_http_request_parse(server *srv, connection *con)\n                     \"Content-Type: 4\\r\\n\"\n                     \"\\r\\n\"));\n \n-    run_http_request_parse(srv, con, __LINE__, 400,\n-      \"Duplicate Range headers\",\n+    /* (not actually testing Range here anymore; parsing deferred until use) */\n+\n+    run_http_request_parse(srv, con, __LINE__, 0,\n+      \"Duplicate Range headers (get appended)\",\n       CONST_STR_LEN(\"GET / HTTP/1.0\\r\\n\"\n                     \"Range: bytes=5-6\\r\\n\"\n                     \"Range: bytes=5-9\\r\\n\"\n                     \"\\r\\n\"));\n \n+    run_http_request_parse(srv, con, __LINE__, 0,\n+      \"Duplicate Range headers with invalid range (a)\",\n+      CONST_STR_LEN(\"GET / HTTP/1.0\\r\\n\"\n+                    \"Range: bytes=0\\r\\n\"\n+                    \"Range: bytes=5-9\\r\\n\"\n+                    \"\\r\\n\"));\n+    run_http_request_parse(srv, con, __LINE__, 0,\n+      \"Duplicate Range headers with invalid range (b)\",\n+      CONST_STR_LEN(\"GET / HTTP/1.0\\r\\n\"\n+                    \"Range: bytes=5-9\\r\\n\"\n+                    \"Range: bytes=0\\r\\n\"\n+                    \"\\r\\n\"));\n+    run_http_request_parse(srv, con, __LINE__, 0,\n+      \"Duplicate Range headers with invalid range (c)\",\n+      CONST_STR_LEN(\"GET / HTTP/1.0\\r\\n\"\n+                    \"Range: 0\\r\\n\"\n+                    \"Range: bytes=5-9\\r\\n\"\n+                    \"\\r\\n\"));\n+    run_http_request_parse(srv, con, __LINE__, 0,\n+      \"Duplicate Range headers with invalid range (d)\",\n+      CONST_STR_LEN(\"GET / HTTP/1.0\\r\\n\"\n+                    \"Range: bytes=5-9\\r\\n\"\n+                    \"Range: 0\\r\\n\"\n+                    \"\\r\\n\"));\n+\n     run_http_request_parse(srv, con, __LINE__, 0,\n       \"Duplicate If-None-Match headers\",\n       CONST_STR_LEN(\"GET / HTTP/1.0\\r\\n\""
        },
        {
          "filename": "tests/request.t",
          "status": "modified",
          "additions": 21,
          "deletions": 1,
          "patch": "@@ -8,7 +8,7 @@ BEGIN {\n \n use strict;\n use IO::Socket;\n-use Test::More tests => 50;\n+use Test::More tests => 52;\n use LightyTest;\n \n my $tf = LightyTest->new();\n@@ -391,6 +391,26 @@ EOF\n $t->{RESPONSE} = [ { 'HTTP-Protocol' => 'HTTP/1.0', 'HTTP-Status' => 200 } ];\n ok($tf->handle_http($t) == 0, 'GET, Range with range-requests-disabled');\n \n+$t->{REQUEST}  = ( <<EOF\n+GET /12345.txt HTTP/1.0\n+Host: 123.example.org\n+Range: 0\n+Range: bytes=0-3\n+EOF\n+ );\n+$t->{RESPONSE} = [ { 'HTTP-Protocol' => 'HTTP/1.0', 'HTTP-Status' => 200, 'HTTP-Content' => \"12345\\n\" } ];\n+ok($tf->handle_http($t) == 0, 'GET, Range invalid range-unit (first)');\n+\n+$t->{REQUEST}  = ( <<EOF\n+GET /12345.txt HTTP/1.0\n+Host: 123.example.org\n+Range: bytes=0-3\n+Range: 0\n+EOF\n+ );\n+$t->{RESPONSE} = [ { 'HTTP-Protocol' => 'HTTP/1.0', 'HTTP-Status' => 206 } ];\n+ok($tf->handle_http($t) == 0, 'GET, Range ignore invalid range (second)');\n+\n $t->{REQUEST}  = ( <<EOF\n OPTIONS / HTTP/1.0\n Content-Length: 4"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "98bef7f788a9e885577b2991a9f38f4ada331a3f",
            "date": "2025-01-10T07:26:47Z",
            "author_login": "gstrauss"
          },
          {
            "sha": "48532013aff12606e6dedb13bbff1bb5d9395550",
            "date": "2025-01-10T04:12:08Z",
            "author_login": "gstrauss"
          },
          {
            "sha": "17fbe0fe3d4f012a9540020e343d72424099598b",
            "date": "2025-01-09T07:59:53Z",
            "author_login": "gstrauss"
          },
          {
            "sha": "9a4d50a1fab43961002968b368270e18b272c24d",
            "date": "2025-01-09T07:54:01Z",
            "author_login": "gstrauss"
          },
          {
            "sha": "97e122c99bde17736fcf7851a7659400e829da2e",
            "date": "2025-01-09T05:09:15Z",
            "author_login": "gstrauss"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": null,
    "description": "There exists use-after-free vulnerabilities in lighttpd <= 1.4.50 request parsing which might read from invalid pointers to memory used in the same request, not from other requests.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-06-17T18:15:12.650",
    "last_modified": "2024-11-21T04:03:34.090",
    "fix_date": "2018-07-24T02:25:23Z"
  },
  "references": [
    {
      "url": "https://9443417.fs1.hubspotusercontent-na1.net/hubfs/9443417/Security%20Advisories/2024/AMI-SA-2024002.pdf",
      "source": "cret@cert.org",
      "tags": []
    },
    {
      "url": "https://blogvdoo.wordpress.com/2018/11/06/giving-back-securing-open-source-iot-projects/#more-736",
      "source": "cret@cert.org",
      "tags": []
    },
    {
      "url": "https://github.com/lighttpd/lighttpd1.4/commit/d161f53de04bc826ce1bdaeb3dce2c72ca50a3f8",
      "source": "cret@cert.org",
      "tags": []
    },
    {
      "url": "https://github.com/lighttpd/lighttpd1.4/commit/df8e4f95614e476276a55e34da2aa8b00b1148e9",
      "source": "cret@cert.org",
      "tags": []
    },
    {
      "url": "https://www.kb.cert.org/vuls/id/312260",
      "source": "cret@cert.org",
      "tags": []
    },
    {
      "url": "https://www.runzero.com/blog/lighttpd/",
      "source": "cret@cert.org",
      "tags": []
    },
    {
      "url": "https://9443417.fs1.hubspotusercontent-na1.net/hubfs/9443417/Security%20Advisories/2024/AMI-SA-2024002.pdf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://blogvdoo.wordpress.com/2018/11/06/giving-back-securing-open-source-iot-projects/#more-736",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/lighttpd/lighttpd1.4/commit/d161f53de04bc826ce1bdaeb3dce2c72ca50a3f8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/lighttpd/lighttpd1.4/commit/df8e4f95614e476276a55e34da2aa8b00b1148e9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://www.kb.cert.org/vuls/id/312260",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://www.runzero.com/blog/lighttpd/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:28.835352",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "lighttpd1.4",
    "owner": "lighttpd",
    "created_at": "2011-11-12T15:12:57Z",
    "updated_at": "2025-01-12T00:45:37Z",
    "pushed_at": "2025-01-10T07:26:55Z",
    "size": 12240,
    "stars": 624,
    "forks": 287,
    "open_issues": 1,
    "watchers": 624,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "C": 4133125,
      "C++": 268649,
      "Perl": 83909,
      "M4": 54953,
      "CMake": 45129,
      "Python": 34182,
      "Meson": 31795,
      "Yacc": 24068,
      "Makefile": 17691,
      "Shell": 16246,
      "HTML": 4365,
      "Ruby": 44
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T13:16:10.929845"
  }
}