{
  "cve_id": "CVE-2018-3740",
  "github_data": {
    "repository": "rgrove/sanitize",
    "fix_commit": "01629a162e448a83d901456d0ba8b65f3b03d46e",
    "related_commits": [
      "01629a162e448a83d901456d0ba8b65f3b03d46e",
      "01629a162e448a83d901456d0ba8b65f3b03d46e"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "01629a162e448a83d901456d0ba8b65f3b03d46e",
      "commit_date": "2018-03-20T02:17:59Z",
      "author": {
        "login": "rgrove",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix: Prevent code injection due to improper escaping in libxml2 >= 2.9.2",
        "length": 492,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 169,
        "additions": 149,
        "deletions": 20
      },
      "files": [
        {
          "filename": "lib/sanitize/transformers/clean_element.rb",
          "status": "modified",
          "additions": 74,
          "deletions": 19,
          "patch": "@@ -18,6 +18,31 @@ class Sanitize; module Transformers; class CleanElement\n   # http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#embedding-custom-non-visible-data-with-the-data-*-attributes\n   REGEX_DATA_ATTR = /\\Adata-(?!xml)[a-z_][\\w.\\u00E0-\\u00F6\\u00F8-\\u017F\\u01DD-\\u02AF-]*\\z/u\n \n+  # Attributes that need additional escaping on `<a>` elements due to unsafe\n+  # libxml2 behavior.\n+  UNSAFE_LIBXML_ATTRS_A = Set.new(%w[\n+    name\n+  ])\n+\n+  # Attributes that need additional escaping on all elements due to unsafe\n+  # libxml2 behavior.\n+  UNSAFE_LIBXML_ATTRS_GLOBAL = Set.new(%w[\n+    action\n+    href\n+    src\n+  ])\n+\n+  # Mapping of original characters to escape sequences for characters that\n+  # should be escaped in attributes affected by unsafe libxml2 behavior.\n+  UNSAFE_LIBXML_ESCAPE_CHARS = {\n+    ' ' => '%20',\n+    '\"' => '%22'\n+  }\n+\n+  # Regex that matches any single character that needs to be escaped in\n+  # attributes affected by unsafe libxml2 behavior.\n+  UNSAFE_LIBXML_ESCAPE_REGEX = /[ \"]/\n+\n   def initialize(config)\n     @add_attributes          = config[:add_attributes]\n     @attributes              = config[:attributes].dup\n@@ -92,31 +117,61 @@ def call(env)\n       node.attribute_nodes.each do |attr|\n         attr_name = attr.name.downcase\n \n-        if attr_whitelist.include?(attr_name)\n-          # The attribute is whitelisted.\n+        unless attr_whitelist.include?(attr_name)\n+          # The attribute isn't whitelisted.\n+\n+          if allow_data_attributes && attr_name.start_with?('data-')\n+            # Arbitrary data attributes are allowed. If this is a data\n+            # attribute, continue.\n+            next if attr_name =~ REGEX_DATA_ATTR\n+          end\n+\n+          # Either the attribute isn't a data attribute or arbitrary data\n+          # attributes aren't allowed. Remove the attribute.\n+          attr.unlink\n+          next\n+        end\n+\n+        # The attribute is whitelisted.\n \n-          # Remove any attributes that use unacceptable protocols.\n-          if @protocols.include?(name) && @protocols[name].include?(attr_name)\n-            attr_protocols = @protocols[name][attr_name]\n+        # Remove any attributes that use unacceptable protocols.\n+        if @protocols.include?(name) && @protocols[name].include?(attr_name)\n+          attr_protocols = @protocols[name][attr_name]\n \n-            if attr.value =~ REGEX_PROTOCOL\n-              attr.unlink unless attr_protocols.include?($1.downcase)\n-            else\n-              attr.unlink unless attr_protocols.include?(:relative)\n+          if attr.value =~ REGEX_PROTOCOL\n+            unless attr_protocols.include?($1.downcase)\n+              attr.unlink\n+              next\n             end\n-          end\n-        else\n-          # The attribute isn't whitelisted.\n \n-          if allow_data_attributes && attr_name.start_with?('data-')\n-            # Arbitrary data attributes are allowed. Verify that the attribute\n-            # is a valid data attribute.\n-            attr.unlink unless attr_name =~ REGEX_DATA_ATTR\n           else\n-            # Either the attribute isn't a data attribute, or arbitrary data\n-            # attributes aren't allowed. Remove the attribute.\n-            attr.unlink\n+            unless attr_protocols.include?(:relative)\n+              attr.unlink\n+              next\n+            end\n           end\n+\n+          # Leading and trailing whitespace around URLs is ignored at parse\n+          # time. Stripping it here prevents it from being escaped by the\n+          # libxml2 workaround below.\n+          attr.value = attr.value.strip\n+        end\n+\n+        # libxml2 >= 2.9.2 doesn't escape comments within some attributes, in an\n+        # attempt to preserve server-side includes. This can result in XSS since\n+        # an unescaped double quote can allow an attacker to inject a\n+        # non-whitelisted attribute.\n+        #\n+        # Sanitize works around this by implementing its own escaping for\n+        # affected attributes, some of which can exist on any element and some\n+        # of which can only exist on `<a>` elements.\n+        #\n+        # The relevant libxml2 code is here:\n+        # <https://github.com/GNOME/libxml2/commit/960f0e275616cadc29671a218d7fb9b69eb35588>\n+        if UNSAFE_LIBXML_ATTRS_GLOBAL.include?(attr_name) ||\n+            (name == 'a' && UNSAFE_LIBXML_ATTRS_A.include?(attr_name))\n+\n+          attr.value = attr.value.gsub(UNSAFE_LIBXML_ESCAPE_REGEX, UNSAFE_LIBXML_ESCAPE_CHARS)\n         end\n       end\n     end"
        },
        {
          "filename": "test/test_clean_element.rb",
          "status": "modified",
          "additions": 11,
          "deletions": 1,
          "patch": "@@ -234,7 +234,7 @@\n \n     it 'should not choke on valueless attributes' do\n       @s.fragment('foo <a href>foo</a> bar')\n-        .must_equal 'foo <a href=\"\" rel=\"nofollow\">foo</a> bar'\n+        .must_equal 'foo <a href rel=\"nofollow\">foo</a> bar'\n     end\n \n     it 'should downcase attribute names' do\n@@ -300,6 +300,16 @@\n       }).must_equal input\n     end\n \n+    it \"should not allow relative URLs when relative URLs aren't whitelisted\" do\n+      input = '<a href=\"/foo/bar\">Link</a>'\n+\n+      Sanitize.fragment(input,\n+        :elements   => ['a'],\n+        :attributes => {'a' => ['href']},\n+        :protocols  => {'a' => {'href' => ['http']}}\n+      ).must_equal '<a>Link</a>'\n+    end\n+\n     it 'should allow relative URLs containing colons when the colon is not in the first path segment' do\n       input = '<a href=\"/wiki/Special:Random\">Random Page</a>'\n "
        },
        {
          "filename": "test/test_malicious_html.rb",
          "status": "modified",
          "additions": 64,
          "deletions": 0,
          "patch": "@@ -125,4 +125,68 @@\n         must_equal '&lt;alert(\"XSS\");//&lt;'\n     end\n   end\n+\n+  # libxml2 >= 2.9.2 doesn't escape comments within some attributes, in an\n+  # attempt to preserve server-side includes. This can result in XSS since an\n+  # unescaped double quote can allow an attacker to inject a non-whitelisted\n+  # attribute. Sanitize works around this by implementing its own escaping for\n+  # affected attributes.\n+  #\n+  # The relevant libxml2 code is here:\n+  # <https://github.com/GNOME/libxml2/commit/960f0e275616cadc29671a218d7fb9b69eb35588>\n+  describe 'unsafe libxml2 server-side includes in attributes' do\n+    tag_configs = [\n+      {\n+        tag_name: 'a',\n+        escaped_attrs: %w[ action href src name ],\n+        unescaped_attrs: []\n+      },\n+\n+      {\n+        tag_name: 'div',\n+        escaped_attrs: %w[ action href src ],\n+        unescaped_attrs: %w[ name ]\n+      }\n+    ]\n+\n+    before do\n+      @s = Sanitize.new({\n+        elements: %w[ a div ],\n+\n+        attributes: {\n+          all: %w[ action href src name ]\n+        }\n+      })\n+    end\n+\n+    tag_configs.each do |tag_config|\n+      tag_name = tag_config[:tag_name]\n+\n+      tag_config[:escaped_attrs].each do |attr_name|\n+        input = %[<#{tag_name} #{attr_name}='examp<!--\" onmouseover=alert(1)>-->le.com'>foo</#{tag_name}>]\n+\n+        it 'should escape unsafe characters in attributes' do\n+          @s.fragment(input).must_equal(%[<#{tag_name} #{attr_name}=\"examp<!--%22%20onmouseover=alert(1)>-->le.com\">foo</#{tag_name}>])\n+        end\n+\n+        it 'should round-trip to the same output' do\n+          output = @s.fragment(input)\n+          @s.fragment(output).must_equal(output)\n+        end\n+      end\n+\n+      tag_config[:unescaped_attrs].each do |attr_name|\n+        input = %[<#{tag_name} #{attr_name}='examp<!--\" onmouseover=alert(1)>-->le.com'>foo</#{tag_name}>]\n+\n+        it 'should not escape characters unnecessarily' do\n+          @s.fragment(input).must_equal(input)\n+        end\n+\n+        it 'should round-trip to the same output' do\n+          output = @s.fragment(input)\n+          @s.fragment(output).must_equal(output)\n+        end\n+      end\n+    end\n+  end\n end"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2dfa666ed5f8c59e1f9efcf0339f1e769876d3df",
            "date": "2024-12-30T22:26:29Z",
            "author_login": "rgrove"
          },
          {
            "sha": "19ee751d1b1c1e9d0335c0438fdb6b389544c45c",
            "date": "2024-12-30T04:50:12Z",
            "author_login": "rgrove"
          },
          {
            "sha": "859c3aa11fdd71829a2424d98346fb8d8d14e522",
            "date": "2024-12-29T05:12:01Z",
            "author_login": "rgrove"
          },
          {
            "sha": "45dbeac426189fca4772bf7221744be86cdd969f",
            "date": "2024-12-29T01:17:23Z",
            "author_login": "rgrove"
          },
          {
            "sha": "010e4e2a6e2423290876db4c5e7bbfa6845d1c3e",
            "date": "2024-12-29T00:57:02Z",
            "author_login": "rgrove"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-79",
    "description": "A specially crafted HTML fragment can cause Sanitize gem for Ruby to allow non-whitelisted attributes to be used on a whitelisted HTML element.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-03-30T19:29:00.270",
    "last_modified": "2024-11-21T04:05:59.220",
    "fix_date": "2018-03-20T02:17:59Z"
  },
  "references": [
    {
      "url": "https://about.gitlab.com/2018/06/25/security-release-gitlab-11-dot-0-dot-1-released/",
      "source": "support@hackerone.com",
      "tags": []
    },
    {
      "url": "https://github.com/rgrove/sanitize/commit/01629a162e448a83d901456d0ba8b65f3b03d46e",
      "source": "support@hackerone.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/rgrove/sanitize/issues/176",
      "source": "support@hackerone.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2018/dsa-4358",
      "source": "support@hackerone.com",
      "tags": []
    },
    {
      "url": "https://about.gitlab.com/2018/06/25/security-release-gitlab-11-dot-0-dot-1-released/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/rgrove/sanitize/commit/01629a162e448a83d901456d0ba8b65f3b03d46e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/rgrove/sanitize/issues/176",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2018/dsa-4358",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:21.809100",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "sanitize",
    "owner": "rgrove",
    "created_at": "2008-12-25T06:03:43Z",
    "updated_at": "2025-01-17T03:23:30Z",
    "pushed_at": "2024-12-30T22:30:26Z",
    "size": 2039,
    "stars": 2042,
    "forks": 143,
    "open_issues": 0,
    "watchers": 2042,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Ruby": 140122
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T07:41:32.776147"
  }
}