{
  "cve_id": "CVE-2018-5809",
  "github_data": {
    "repository": "LibRaw/LibRaw",
    "fix_commit": "fd6330292501983ac75fe4162275794b18445bd9",
    "related_commits": [
      "fd6330292501983ac75fe4162275794b18445bd9",
      "fd6330292501983ac75fe4162275794b18445bd9"
    ],
    "patch_url": "https://github.com/LibRaw/LibRaw/commit/fd6330292501983ac75fe4162275794b18445bd9.patch",
    "fix_commit_details": {
      "sha": "fd6330292501983ac75fe4162275794b18445bd9",
      "commit_date": "2018-04-24T12:17:31Z",
      "author": {
        "login": "alextutubalin",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Secunia 81800#1: samsumg_load_raw",
        "length": 258,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 314,
        "additions": 216,
        "deletions": 98
      },
      "files": [
        {
          "filename": "dcraw/dcraw.c",
          "status": "modified",
          "additions": 108,
          "deletions": 49,
          "patch": "@@ -251,6 +251,7 @@ static float fMAX(float a, float b)\n \t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n  */\n \n+#define RAWINDEX(row, col) ((row)*raw_width + (col))\n #define RAW(row,col) \\\n \traw_image[(row)*raw_width+(col)]\n //@end DEFINES\n@@ -1511,9 +1512,14 @@ void CLASS pentax_load_raw()\n \n void CLASS nikon_coolscan_load_raw()\n {\n-  int bufsize = width*3*tiff_bps/8;\n-  if(tiff_bps <= 8)\n-    gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,255);\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+  int bypp = tiff_bps <= 8 ? 1 : 2;\n+  int bufsize = width * 3 * bypp;\n+\n+  if (tiff_bps <= 8)\n+    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n   else\n     gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n   fseek (ifp, data_offset, SEEK_SET);\n@@ -1794,7 +1800,12 @@ void CLASS rollei_thumb()\n void CLASS rollei_load_raw()\n {\n   uchar pixel[10];\n-  unsigned iten=0, isix, i, buffer=0, todo[16];\n+  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width > 32767 || raw_height > 32767)\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixel = raw_width*(raw_height+7);\n \n   isix = raw_width * raw_height * 5 / 8;\n   while (fread (pixel, 1, 10, ifp) == 10) {\n@@ -1810,8 +1821,11 @@ void CLASS rollei_load_raw()\n       todo[i]   = isix++;\n       todo[i+1] = buffer >> (14-i)*5;\n     }\n-    for (i=0; i < 16; i+=2)\n-      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n+    for (i = 0; i < 16; i += 2)\n+      if(todo[i] < maxpixel)\n+        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n+      else\n+        derror();\n   }\n   maximum = 0x3ff;\n }\n@@ -3857,6 +3871,11 @@ void CLASS sony_arw2_load_raw()\n void CLASS samsung_load_raw()\n {\n   int row, col, c, i, dir, op[4], len[4];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width> 32768 || raw_height > 32768)  // definitely too much for old samsung\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixels = raw_width*(raw_height+7);\n \n   order = 0x4949;\n   for (row=0; row < raw_height; row++) {\n@@ -3875,11 +3894,17 @@ void CLASS samsung_load_raw()\n \tcase 2: len[c]--;\t\tbreak;\n \tcase 1: len[c]++;\n       }\n-      for (c=0; c < 16; c+=2) {\n-\ti = len[((c & 1) << 1) | (c >> 3)];\n-        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n-\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n-\tif (c == 14) c = -1;\n+      for (c = 0; c < 16; c += 2)\n+      {\n+        i = len[((c & 1) << 1) | (c >> 3)];\n+\tunsigned idest = RAWINDEX(row, col + c);\n+\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n+\tif(idest < maxpixels && isrc < maxpixels) // less than zero is handled by unsigned conversion\n+  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n+\telse\n+  \t  derror();\n+        if (c == 14)\n+          c = -1;\n       }\n     }\n   }\n@@ -11081,37 +11106,68 @@ void CLASS parse_exif (int base)\n        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n-         char mn_text[512];\n-         char* pos;\n-         char ccms[512];\n-         ushort l;\n-         float num;\n-\n-         fgets(mn_text, len, ifp);\n-         pos = strstr(mn_text, \"gain_r=\");\n-         if (pos) cam_mul[0] = atof(pos+7);\n-         pos = strstr(mn_text, \"gain_b=\");\n-         if (pos) cam_mul[2] = atof(pos+7);\n-         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n-         else cam_mul[0] = cam_mul[2] = 0.0f;\n-\n-         pos = strstr(mn_text, \"ccm=\") + 4;\n-         l = strstr(pos, \" \") - pos;\n-         memcpy (ccms, pos, l);\n-         ccms[l] = '\\0';\n-\n-         pos = strtok (ccms, \",\");\n-         for (l=0; l<4; l++) {\n-           num = 0.0;\n-           for (c=0; c<3; c++) {\n-             imgdata.color.ccm[l][c] = (float)atoi(pos);\n-             num += imgdata.color.ccm[l][c];\n-             pos = strtok (NULL, \",\");\n-           }\n-           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n-         }\n+        char mn_text[512];\n+        char *pos;\n+        char ccms[512];\n+        ushort l;\n+        float num;\n+\n+\tfgets(mn_text, MIN(len,511), ifp);\n+        mn_text[511] = 0;\n+\n+        pos = strstr(mn_text, \"gain_r=\");\n+        if (pos)\n+          cam_mul[0] = atof(pos + 7);\n+        pos = strstr(mn_text, \"gain_b=\");\n+        if (pos)\n+          cam_mul[2] = atof(pos + 7);\n+        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n+          cam_mul[1] = cam_mul[3] = 1.0f;\n+        else\n+          cam_mul[0] = cam_mul[2] = 0.0f;\n+\n+        pos = strstr(mn_text, \"ccm=\");\n+        if(pos)\n+        {\n+         pos +=4;\n+         char *pos2 = strstr(pos, \" \");\n+         if(pos2)\n+         {\n+           l = pos2 - pos;\n+           memcpy(ccms, pos, l);\n+           ccms[l] = '\\0';\n+#if defined WIN32 || defined(__MINGW32__)\n+           // Win32 strtok is already thread-safe\n+          pos = strtok(ccms, \",\");\n+#else\n+          char *last=0;\n+          pos = strtok_r(ccms, \",\",&last);\n+#endif\n+          if(pos)\n+          {\n+            for (l = 0; l < 4; l++)\n+            {\n+              num = 0.0;\n+              for (c = 0; c < 3; c++)\n+              {\n+                imgdata.color.ccm[l][c] = (float)atoi(pos);\n+                num += imgdata.color.ccm[l][c];\n+#if defined WIN32 || defined(__MINGW32__)\n+                pos = strtok(NULL, \",\");\n+#else\n+                pos = strtok_r(NULL, \",\",&last);\n+#endif\n+                if(!pos) goto end; // broken\n+              }\n+              if (num > 0.01)\n+                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n+            }\n+          }\n+        }\n        }\n-       else\n+      end:;\n+      }\n+      else\n #endif\n         parse_makernote (base, 0);\n        break;\n@@ -15077,7 +15133,8 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n   UINT64 bitbuf=0;\n   int vbits, col, i, c;\n   ushort img[2][2064];\n-  double sum[]={0,0};\n+  double sum[] = {0, 0};\n+  if(width > 2064) return 0.f; // too wide\n \n   FORC(2) {\n     fseek (ifp, c ? off1:off0, SEEK_SET);\n@@ -15100,14 +15157,16 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n #ifdef LIBRAW_LIBRARY_BUILD\n static void remove_trailing_spaces(char *string, size_t len)\n {\n-  if(len<1) return; // not needed, b/c sizeof of make/model is 64\n-  string[len-1]=0;\n-  if(len<3) return; // also not needed\n-  len = strnlen(string,len-1);\n-  for(int i=len-1; i>=0; i--)\n+  if (len < 1)\n+    return; // not needed, b/c sizeof of make/model is 64\n+  string[len - 1] = 0;\n+  if (len < 3)\n+    return; // also not needed\n+  len = strnlen(string, len - 1);\n+  for (int i = len - 1; i >= 0; i--)\n   {\n-    if(isspace(string[i]))\n-      string[i]=0;\n+    if (isspace((unsigned char)string[i]))\n+      string[i] = 0;\n     else\n       break;\n   }"
        },
        {
          "filename": "internal/dcraw_common.cpp",
          "status": "modified",
          "additions": 107,
          "deletions": 49,
          "patch": "@@ -1228,9 +1228,14 @@ void CLASS pentax_load_raw()\n \n void CLASS nikon_coolscan_load_raw()\n {\n-  int bufsize = width*3*tiff_bps/8;\n-  if(tiff_bps <= 8)\n-    gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,255);\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+  int bypp = tiff_bps <= 8 ? 1 : 2;\n+  int bufsize = width * 3 * bypp;\n+\n+  if (tiff_bps <= 8)\n+    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n   else\n     gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n   fseek (ifp, data_offset, SEEK_SET);\n@@ -1506,7 +1511,12 @@ void CLASS rollei_thumb()\n void CLASS rollei_load_raw()\n {\n   uchar pixel[10];\n-  unsigned iten=0, isix, i, buffer=0, todo[16];\n+  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width > 32767 || raw_height > 32767)\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixel = raw_width*(raw_height+7);\n \n   isix = raw_width * raw_height * 5 / 8;\n   while (fread (pixel, 1, 10, ifp) == 10) {\n@@ -1522,8 +1532,11 @@ void CLASS rollei_load_raw()\n       todo[i]   = isix++;\n       todo[i+1] = buffer >> (14-i)*5;\n     }\n-    for (i=0; i < 16; i+=2)\n-      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n+    for (i = 0; i < 16; i += 2)\n+      if(todo[i] < maxpixel)\n+        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n+      else\n+        derror();\n   }\n   maximum = 0x3ff;\n }\n@@ -3569,6 +3582,11 @@ void CLASS sony_arw2_load_raw()\n void CLASS samsung_load_raw()\n {\n   int row, col, c, i, dir, op[4], len[4];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width> 32768 || raw_height > 32768)  // definitely too much for old samsung\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixels = raw_width*(raw_height+7);\n \n   order = 0x4949;\n   for (row=0; row < raw_height; row++) {\n@@ -3587,11 +3605,17 @@ void CLASS samsung_load_raw()\n \tcase 2: len[c]--;\t\tbreak;\n \tcase 1: len[c]++;\n       }\n-      for (c=0; c < 16; c+=2) {\n-\ti = len[((c & 1) << 1) | (c >> 3)];\n-        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n-\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n-\tif (c == 14) c = -1;\n+      for (c = 0; c < 16; c += 2)\n+      {\n+        i = len[((c & 1) << 1) | (c >> 3)];\n+\tunsigned idest = RAWINDEX(row, col + c);\n+\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n+\tif(idest < maxpixels && isrc < maxpixels) // less than zero is handled by unsigned conversion\n+  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n+\telse\n+  \t  derror();\n+        if (c == 14)\n+          c = -1;\n       }\n     }\n   }\n@@ -9890,37 +9914,68 @@ void CLASS parse_exif (int base)\n        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n-         char mn_text[512];\n-         char* pos;\n-         char ccms[512];\n-         ushort l;\n-         float num;\n-\n-         fgets(mn_text, len, ifp);\n-         pos = strstr(mn_text, \"gain_r=\");\n-         if (pos) cam_mul[0] = atof(pos+7);\n-         pos = strstr(mn_text, \"gain_b=\");\n-         if (pos) cam_mul[2] = atof(pos+7);\n-         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n-         else cam_mul[0] = cam_mul[2] = 0.0f;\n-\n-         pos = strstr(mn_text, \"ccm=\") + 4;\n-         l = strstr(pos, \" \") - pos;\n-         memcpy (ccms, pos, l);\n-         ccms[l] = '\\0';\n-\n-         pos = strtok (ccms, \",\");\n-         for (l=0; l<4; l++) {\n-           num = 0.0;\n-           for (c=0; c<3; c++) {\n-             imgdata.color.ccm[l][c] = (float)atoi(pos);\n-             num += imgdata.color.ccm[l][c];\n-             pos = strtok (NULL, \",\");\n-           }\n-           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n-         }\n+        char mn_text[512];\n+        char *pos;\n+        char ccms[512];\n+        ushort l;\n+        float num;\n+\n+\tfgets(mn_text, MIN(len,511), ifp);\n+        mn_text[511] = 0;\n+\n+        pos = strstr(mn_text, \"gain_r=\");\n+        if (pos)\n+          cam_mul[0] = atof(pos + 7);\n+        pos = strstr(mn_text, \"gain_b=\");\n+        if (pos)\n+          cam_mul[2] = atof(pos + 7);\n+        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n+          cam_mul[1] = cam_mul[3] = 1.0f;\n+        else\n+          cam_mul[0] = cam_mul[2] = 0.0f;\n+\n+        pos = strstr(mn_text, \"ccm=\");\n+        if(pos)\n+        {\n+         pos +=4;\n+         char *pos2 = strstr(pos, \" \");\n+         if(pos2)\n+         {\n+           l = pos2 - pos;\n+           memcpy(ccms, pos, l);\n+           ccms[l] = '\\0';\n+#if defined WIN32 || defined(__MINGW32__)\n+           // Win32 strtok is already thread-safe\n+          pos = strtok(ccms, \",\");\n+#else\n+          char *last=0;\n+          pos = strtok_r(ccms, \",\",&last);\n+#endif\n+          if(pos)\n+          {\n+            for (l = 0; l < 4; l++)\n+            {\n+              num = 0.0;\n+              for (c = 0; c < 3; c++)\n+              {\n+                imgdata.color.ccm[l][c] = (float)atoi(pos);\n+                num += imgdata.color.ccm[l][c];\n+#if defined WIN32 || defined(__MINGW32__)\n+                pos = strtok(NULL, \",\");\n+#else\n+                pos = strtok_r(NULL, \",\",&last);\n+#endif\n+                if(!pos) goto end; // broken\n+              }\n+              if (num > 0.01)\n+                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n+            }\n+          }\n+        }\n        }\n-       else\n+      end:;\n+      }\n+      else\n #endif\n         parse_makernote (base, 0);\n        break;\n@@ -13739,7 +13794,8 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n   UINT64 bitbuf=0;\n   int vbits, col, i, c;\n   ushort img[2][2064];\n-  double sum[]={0,0};\n+  double sum[] = {0, 0};\n+  if(width > 2064) return 0.f; // too wide\n \n   FORC(2) {\n     fseek (ifp, c ? off1:off0, SEEK_SET);\n@@ -13762,14 +13818,16 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n #ifdef LIBRAW_LIBRARY_BUILD\n static void remove_trailing_spaces(char *string, size_t len)\n {\n-  if(len<1) return; // not needed, b/c sizeof of make/model is 64\n-  string[len-1]=0;\n-  if(len<3) return; // also not needed\n-  len = strnlen(string,len-1);\n-  for(int i=len-1; i>=0; i--)\n+  if (len < 1)\n+    return; // not needed, b/c sizeof of make/model is 64\n+  string[len - 1] = 0;\n+  if (len < 3)\n+    return; // also not needed\n+  len = strnlen(string, len - 1);\n+  for (int i = len - 1; i >= 0; i--)\n   {\n-    if(isspace(string[i]))\n-      string[i]=0;\n+    if (isspace((unsigned char)string[i]))\n+      string[i] = 0;\n     else\n       break;\n   }"
        },
        {
          "filename": "internal/defines.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -153,6 +153,7 @@ static float fMAX(float a, float b)\n \t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n  */\n \n+#define RAWINDEX(row, col) ((row)*raw_width + (col))\n #define RAW(row,col) \\\n \traw_image[(row)*raw_width+(col)]\n #define BAYER(row,col) \\"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "cc118c1c1869e2559dbd0c7639d219154cc46e40",
            "date": "2024-11-30T15:36:46Z",
            "author_login": "alextutubalin"
          },
          {
            "sha": "9bcb8a1d9593ba67e4eb67fed716efc5e1353d5c",
            "date": "2024-09-18T09:07:43Z",
            "author_login": "alextutubalin"
          },
          {
            "sha": "bf1a9140e0d032c0f3d5eccbe2b7aa4e7167e287",
            "date": "2024-09-16T08:49:24Z",
            "author_login": "alextutubalin"
          },
          {
            "sha": "77a46b31978a2381e61df524dc9b6670a1f22321",
            "date": "2024-09-16T08:45:25Z",
            "author_login": "alextutubalin"
          },
          {
            "sha": "4f5a4cfb3724eb57386efad362b998b68a10eba7",
            "date": "2024-09-14T17:32:15Z",
            "author_login": "alextutubalin"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-787",
    "description": "An error within the \"LibRaw::parse_exif()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.9 can be exploited to cause a stack-based buffer overflow and subsequently execute arbitrary code.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-12-07T22:29:01.147",
    "last_modified": "2024-11-21T04:09:27.167",
    "fix_date": "2018-04-24T12:17:31Z"
  },
  "references": [
    {
      "url": "https://github.com/LibRaw/LibRaw/blob/master/Changelog.txt",
      "source": "PSIRT-CNA@flexerasoftware.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/LibRaw/LibRaw/commit/fd6330292501983ac75fe4162275794b18445bd9",
      "source": "PSIRT-CNA@flexerasoftware.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://secuniaresearch.flexerasoftware.com/advisories/81800/",
      "source": "PSIRT-CNA@flexerasoftware.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://secuniaresearch.flexerasoftware.com/secunia_research/2018-9/",
      "source": "PSIRT-CNA@flexerasoftware.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/LibRaw/LibRaw/blob/master/Changelog.txt",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/LibRaw/LibRaw/commit/fd6330292501983ac75fe4162275794b18445bd9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://secuniaresearch.flexerasoftware.com/advisories/81800/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://secuniaresearch.flexerasoftware.com/secunia_research/2018-9/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:42.170191",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "LibRaw",
    "owner": "LibRaw",
    "created_at": "2010-10-11T18:01:13Z",
    "updated_at": "2025-01-14T03:39:50Z",
    "pushed_at": "2024-11-30T15:42:21Z",
    "size": 14433,
    "stars": 1172,
    "forks": 287,
    "open_issues": 2,
    "watchers": 1172,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 2012970,
      "C": 18819,
      "M4": 8267,
      "QMake": 6245,
      "Makefile": 5329,
      "Shell": 1869,
      "Perl": 1289
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:49:33.251436"
  }
}