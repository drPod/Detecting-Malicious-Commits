{
  "cve_id": "CVE-2018-6558",
  "github_data": {
    "repository": "google/fscrypt",
    "fix_commit": "3022c1603d968c22f147b4a2c49c4637dd1be91b",
    "related_commits": [
      "3022c1603d968c22f147b4a2c49c4637dd1be91b",
      "315f9b042237200174a1fb99427f74027e191d66",
      "3022c1603d968c22f147b4a2c49c4637dd1be91b",
      "315f9b042237200174a1fb99427f74027e191d66"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "3022c1603d968c22f147b4a2c49c4637dd1be91b",
      "commit_date": "2018-08-22T12:17:32Z",
      "author": {
        "login": "josephlr",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Ensure setting user privileges is reversible",
        "length": 409,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 179,
        "additions": 92,
        "deletions": 87
      },
      "files": [
        {
          "filename": "pam/pam.go",
          "status": "modified",
          "additions": 16,
          "deletions": 17,
          "patch": "@@ -35,16 +35,14 @@ import (\n \t\"unsafe\"\n \n \t\"github.com/google/fscrypt/security\"\n-\t\"github.com/google/fscrypt/util\"\n )\n \n // Handle wraps the C pam_handle_t type. This is used from within modules.\n type Handle struct {\n-\thandle *C.pam_handle_t\n-\tstatus C.int\n-\t// OrigUser is the user who invoked the PAM module (usually root)\n-\tOrigUser *user.User\n-\t// PamUser is the user who the PAM module is for\n+\thandle    *C.pam_handle_t\n+\tstatus    C.int\n+\torigPrivs *security.Privileges\n+\t// PamUser is the user for whom the PAM module is running.\n \tPamUser *user.User\n }\n \n@@ -62,13 +60,8 @@ func NewHandle(pamh unsafe.Pointer) (*Handle, error) {\n \t\treturn nil, err\n \t}\n \n-\tif h.PamUser, err = user.Lookup(C.GoString(pamUsername)); err != nil {\n-\t\treturn nil, err\n-\t}\n-\tif h.OrigUser, err = util.EffectiveUser(); err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn h, nil\n+\th.PamUser, err = user.Lookup(C.GoString(pamUsername))\n+\treturn h, err\n }\n \n func (h *Handle) setData(name string, data unsafe.Pointer, cleanup C.CleanupFunc) error {\n@@ -140,14 +133,20 @@ func (h *Handle) StartAsPamUser() error {\n \tif _, err := security.UserKeyringID(h.PamUser, true); err != nil {\n \t\tlog.Printf(\"Setting up keyrings in PAM: %v\", err)\n \t}\n-\treturn security.SetProcessPrivileges(h.PamUser)\n+\tuserPrivs, err := security.UserPrivileges(h.PamUser)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif h.origPrivs, err = security.ProcessPrivileges(); err != nil {\n+\t\treturn err\n+\t}\n+\treturn security.SetProcessPrivileges(userPrivs)\n }\n \n // StopAsPamUser restores the original privileges that were running the\n-// PAM module (this is usually root). As this error is often ignored in a defer\n-// statement, any error is also logged.\n+// PAM module (this is usually root).\n func (h *Handle) StopAsPamUser() error {\n-\terr := security.SetProcessPrivileges(h.OrigUser)\n+\terr := security.SetProcessPrivileges(h.origPrivs)\n \tif err != nil {\n \t\tlog.Print(err)\n \t}"
        },
        {
          "filename": "security/privileges.go",
          "status": "modified",
          "additions": 76,
          "deletions": 70,
          "patch": "@@ -43,30 +43,15 @@ package security\n // cgo maps them to different Go types.\n \n /*\n+#define _GNU_SOURCE    // for getresuid and setresuid\n #include <sys/types.h>\n-#include <unistd.h>\t// setreuid, setregid\n-#include <grp.h>\t// setgroups\n-\n-static int my_setreuid(uid_t ruid, uid_t euid)\n-{\n-\treturn setreuid(ruid, euid);\n-}\n-\n-static int my_setregid(gid_t rgid, gid_t egid)\n-{\n-\treturn setregid(rgid, egid);\n-}\n-\n-static int my_setgroups(size_t size, const gid_t *list)\n-{\n-\treturn setgroups(size, list);\n-}\n+#include <unistd.h>    // getting and setting uids and gids\n+#include <grp.h>       // setgroups\n */\n import \"C\"\n \n import (\n \t\"log\"\n-\t\"os\"\n \t\"os/user\"\n \t\"syscall\"\n \n@@ -75,72 +60,93 @@ import (\n \t\"github.com/google/fscrypt/util\"\n )\n \n-// SetProcessPrivileges temporarily drops the privileges of the current process\n-// to have the effective uid/gid of the target user. The privileges can be\n-// changed again with another call to SetProcessPrivileges.\n-func SetProcessPrivileges(target *user.User) error {\n-\teuid := util.AtoiOrPanic(target.Uid)\n-\tegid := util.AtoiOrPanic(target.Gid)\n-\tif os.Geteuid() == euid {\n-\t\tlog.Printf(\"Privileges already set to %q\", target.Username)\n-\t\treturn nil\n-\t}\n-\tlog.Printf(\"Setting privileges to %q\", target.Username)\n+// Privileges encapulate the effective uid/gid and groups of a process.\n+type Privileges struct {\n+\teuid   C.uid_t\n+\tegid   C.gid_t\n+\tgroups []C.gid_t\n+}\n \n-\t// If setting privs to root, we want to set the uid first, so we will\n-\t// then have the necessary permissions to perform the other actions.\n-\tif euid == 0 {\n-\t\tif err := setUids(-1, euid); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\tif err := setGids(-1, egid); err != nil {\n-\t\treturn err\n-\t}\n-\tif err := setGroups(target); err != nil {\n-\t\treturn err\n+// ProcessPrivileges returns the process's current effective privileges.\n+func ProcessPrivileges() (*Privileges, error) {\n+\truid := C.getuid()\n+\teuid := C.geteuid()\n+\trgid := C.getgid()\n+\tegid := C.getegid()\n+\n+\tvar groups []C.gid_t\n+\tn, err := C.getgroups(0, nil)\n+\tif n < 0 {\n+\t\treturn nil, err\n \t}\n-\t// If not setting privs to root, we want to avoid dropping the uid\n-\t// util the very end.\n-\tif euid != 0 {\n-\t\tif err := setUids(-1, euid); err != nil {\n-\t\t\treturn err\n+\t// If n == 0, the user isn't in any groups, so groups == nil is fine.\n+\tif n > 0 {\n+\t\tgroups = make([]C.gid_t, n)\n+\t\tn, err = C.getgroups(n, &groups[0])\n+\t\tif n < 0 {\n+\t\t\treturn nil, err\n \t\t}\n+\t\tgroups = groups[:n]\n \t}\n-\treturn nil\n+\tlog.Printf(\"Current privs (real, effective): uid=(%d,%d) gid=(%d,%d) groups=%v\",\n+\t\truid, euid, rgid, egid, groups)\n+\treturn &Privileges{euid, egid, groups}, nil\n }\n \n-func setUids(ruid, euid int) error {\n-\tres, err := C.my_setreuid(C.uid_t(ruid), C.uid_t(euid))\n-\tlog.Printf(\"setreuid(%d, %d) = %d (errno %v)\", ruid, euid, res, err)\n-\tif res == 0 {\n-\t\treturn nil\n+// UserPrivileges returns the defualt privileges for the specified user.\n+func UserPrivileges(user *user.User) (*Privileges, error) {\n+\tprivs := &Privileges{\n+\t\teuid: C.uid_t(util.AtoiOrPanic(user.Uid)),\n+\t\tegid: C.gid_t(util.AtoiOrPanic(user.Gid)),\n \t}\n-\treturn errors.Wrapf(err.(syscall.Errno), \"setting uids\")\n+\tuserGroups, err := user.GroupIds()\n+\tif err != nil {\n+\t\treturn nil, util.SystemError(err.Error())\n+\t}\n+\tprivs.groups = make([]C.gid_t, len(userGroups))\n+\tfor i, group := range userGroups {\n+\t\tprivs.groups[i] = C.gid_t(util.AtoiOrPanic(group))\n+\t}\n+\treturn privs, nil\n }\n \n-func setGids(rgid, egid int) error {\n-\tres, err := C.my_setregid(C.gid_t(rgid), C.gid_t(egid))\n-\tlog.Printf(\"setregid(%d, %d) = %d (errno %v)\", rgid, egid, res, err)\n-\tif res == 0 {\n-\t\treturn nil\n+// SetProcessPrivileges sets the privileges of the current process to have those\n+// specified by privs. The original privileges can be obtained by first saving\n+// the output of ProcessPrivileges, calling SetProcessPrivileges with the\n+// desired privs, then calling SetProcessPrivileges with the saved privs.\n+func SetProcessPrivileges(privs *Privileges) error {\n+\tlog.Printf(\"Setting euid=%d egid=%d groups=%v\", privs.euid, privs.egid, privs.groups)\n+\n+\t// If setting privs as root, we need to set the euid to 0 first, so that\n+\t// we will have the necessary permissions to make the other changes to\n+\t// the groups/egid/euid, regardless of our original euid.\n+\tC.seteuid(0)\n+\n+\t// Seperately handle the case where the user is in no groups.\n+\tnumGroups := C.size_t(len(privs.groups))\n+\tgroupsPtr := (*C.gid_t)(nil)\n+\tif numGroups > 0 {\n+\t\tgroupsPtr = &privs.groups[0]\n \t}\n-\treturn errors.Wrapf(err.(syscall.Errno), \"setting gids\")\n-}\n \n-func setGroups(target *user.User) error {\n-\tgroupStrings, err := target.GroupIds()\n-\tif err != nil {\n-\t\treturn util.SystemError(err.Error())\n+\tif res, err := C.setgroups(numGroups, groupsPtr); res < 0 {\n+\t\treturn errors.Wrapf(err.(syscall.Errno), \"setting groups\")\n+\t}\n+\tif res, err := C.setegid(privs.egid); res < 0 {\n+\t\treturn errors.Wrapf(err.(syscall.Errno), \"setting egid\")\n \t}\n-\tgids := make([]C.gid_t, len(groupStrings))\n-\tfor i, groupString := range groupStrings {\n-\t\tgids[i] = C.gid_t(util.AtoiOrPanic(groupString))\n+\tif res, err := C.seteuid(privs.euid); res < 0 {\n+\t\treturn errors.Wrapf(err.(syscall.Errno), \"setting euid\")\n \t}\n-\tres, err := C.my_setgroups(C.size_t(len(groupStrings)), &gids[0])\n-\tlog.Printf(\"setgroups(%v) = %d (errno %v)\", gids, res, err)\n+\tProcessPrivileges()\n+\treturn nil\n+}\n+\n+func setUids(ruid, euid int) error {\n+\tres, err := C.setreuid(C.uid_t(ruid), C.uid_t(euid))\n+\tlog.Printf(\"setreuid(%d, %d) = %d (errno %v)\", ruid, euid, res, err)\n \tif res == 0 {\n \t\treturn nil\n \t}\n-\treturn errors.Wrapf(err.(syscall.Errno), \"setting groups\")\n+\treturn errors.Wrapf(err.(syscall.Errno), \"setting uids\")\n }"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7a17e3a0f1e9c0dfa7eae11816f55c820f689d4f",
            "date": "2024-12-28T00:08:52Z",
            "author_login": "ebiggers"
          },
          {
            "sha": "094d62bfc76262da865a305783e9bb809af7998d",
            "date": "2024-12-03T12:11:03Z",
            "author_login": "betelgeuse"
          },
          {
            "sha": "068b9f8f5dec46b222470f6d3f03244ba5b65f5c",
            "date": "2024-05-02T08:20:01Z",
            "author_login": "NymanRobin"
          },
          {
            "sha": "54745f1c7b5e1c51e7842df2d95b37e0de4695ca",
            "date": "2024-05-01T01:11:09Z",
            "author_login": "dkg"
          },
          {
            "sha": "49c71dedfee544fd74808d3a18972fb65d6e9f02",
            "date": "2024-03-19T22:02:51Z",
            "author_login": "ebiggers"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": null,
    "description": "The pam_fscrypt module in fscrypt before 0.2.4 may incorrectly restore primary and supplementary group IDs to the values associated with the root user, which allows attackers to gain privileges via a successful login through certain applications that use Linux-PAM (aka pam).",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-08-23T19:29:01.127",
    "last_modified": "2024-11-21T04:10:54.240",
    "fix_date": "2018-08-22T12:17:32Z"
  },
  "references": [
    {
      "url": "https://github.com/google/fscrypt/commit/3022c1603d968c22f147b4a2c49c4637dd1be91b",
      "source": "security@ubuntu.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/google/fscrypt/commit/315f9b042237200174a1fb99427f74027e191d66",
      "source": "security@ubuntu.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/google/fscrypt/issues/77",
      "source": "security@ubuntu.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://launchpad.net/bugs/1787548",
      "source": "security@ubuntu.com",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/google/fscrypt/commit/3022c1603d968c22f147b4a2c49c4637dd1be91b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/google/fscrypt/commit/315f9b042237200174a1fb99427f74027e191d66",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/google/fscrypt/issues/77",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://launchpad.net/bugs/1787548",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:32.450127",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "fscrypt",
    "owner": "google",
    "created_at": "2017-07-12T17:52:15Z",
    "updated_at": "2025-01-20T11:50:48Z",
    "pushed_at": "2024-12-28T00:13:46Z",
    "size": 3272,
    "stars": 907,
    "forks": 98,
    "open_issues": 41,
    "watchers": 907,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Go": 444742,
      "Shell": 52850,
      "Makefile": 7988,
      "C": 5054
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:40:36.790599"
  }
}