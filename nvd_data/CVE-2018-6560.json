{
  "cve_id": "CVE-2018-6560",
  "github_data": {
    "repository": "flatpak/flatpak",
    "fix_commit": "52346bf187b5a7f1c0fe9075b328b7ad6abe78f6",
    "related_commits": [
      "52346bf187b5a7f1c0fe9075b328b7ad6abe78f6",
      "52346bf187b5a7f1c0fe9075b328b7ad6abe78f6"
    ],
    "patch_url": "https://github.com/flatpak/flatpak/commit/52346bf187b5a7f1c0fe9075b328b7ad6abe78f6.patch",
    "fix_commit_details": {
      "sha": "52346bf187b5a7f1c0fe9075b328b7ad6abe78f6",
      "commit_date": "2018-01-28T19:51:54Z",
      "author": {
        "login": "alexlarsson",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix vulnerability in dbus proxy",
        "length": 976,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 127,
        "additions": 89,
        "deletions": 38
      },
      "files": [
        {
          "filename": "dbus-proxy/flatpak-proxy.c",
          "status": "modified",
          "additions": 89,
          "deletions": 38,
          "patch": "@@ -173,10 +173,11 @@\n \n typedef struct FlatpakProxyClient FlatpakProxyClient;\n \n-/* We start looking ignoring the first cr-lf\n-   since there is no previous line initially */\n-#define AUTH_END_INIT_OFFSET 2\n-#define AUTH_END_STRING \"\\r\\nBEGIN\\r\\n\"\n+#define FIND_AUTH_END_CONTINUE -1\n+#define FIND_AUTH_END_ABORT -2\n+\n+#define AUTH_LINE_SENTINEL \"\\r\\n\"\n+#define AUTH_BEGIN \"BEGIN\"\n \n typedef enum {\n   EXPECTED_REPLY_NONE,\n@@ -258,7 +259,7 @@ struct FlatpakProxyClient\n   FlatpakProxy *proxy;\n \n   gboolean      authenticated;\n-  int           auth_end_offset;\n+  GByteArray   *auth_buffer;\n \n   ProxySide     client_side;\n   ProxySide     bus_side;\n@@ -372,6 +373,7 @@ flatpak_proxy_client_finalize (GObject *object)\n   client->proxy->clients = g_list_remove (client->proxy->clients, client);\n   g_clear_object (&client->proxy);\n \n+  g_byte_array_free (client->auth_buffer, TRUE);\n   g_hash_table_destroy (client->rewrite_reply);\n   g_hash_table_destroy (client->get_owner_reply);\n   g_hash_table_destroy (client->unique_id_policy);\n@@ -407,7 +409,7 @@ flatpak_proxy_client_init (FlatpakProxyClient *client)\n   init_side (client, &client->client_side);\n   init_side (client, &client->bus_side);\n \n-  client->auth_end_offset = AUTH_END_INIT_OFFSET;\n+  client->auth_buffer = g_byte_array_new ();\n   client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\n   client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\n   client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n@@ -2315,51 +2317,92 @@ got_buffer_from_side (ProxySide *side, Buffer *buffer)\n     got_buffer_from_bus (client, side, buffer);\n }\n \n+#define _DBUS_ISASCII(c) ((c) != '\\0' && (((c) & ~0x7f) == 0))\n+\n+static gboolean\n+auth_line_is_valid (guint8 *line, guint8 *line_end)\n+{\n+  guint8 *p;\n+\n+  for (p = line; p < line_end; p++)\n+    {\n+      if (!_DBUS_ISASCII(*p))\n+        return FALSE;\n+\n+      /* Technically, the dbus spec allows all ASCII characters, but for robustness we also\n+         fail if we see any control characters. Such low values will appear in  potential attacks,\n+         but will never happen in real sasl (where all binary data is hex encoded). */\n+      if (*p < ' ')\n+        return FALSE;\n+    }\n+\n+  /* For robustness we require the first char of the line to be an upper case letter.\n+     This is not technically required by the dbus spec, but all commands are upper\n+     case, and there is no provisioning for whitespace before the command, so in practice\n+     this is true, and this means we're not confused by e.g. initial whitespace. */\n+  if (line[0] < 'A' || line[0] > 'Z')\n+    return FALSE;\n+\n+  return TRUE;\n+}\n+\n+static gboolean\n+auth_line_is_begin (guint8 *line)\n+{\n+  guint8 next_char;\n+\n+  if (!g_str_has_prefix ((char *)line, AUTH_BEGIN))\n+    return FALSE;\n+\n+  /* dbus-daemon accepts either nothing, or a whitespace followed by anything as end of auth */\n+  next_char = line[strlen (AUTH_BEGIN)];\n+  return (next_char == 0 ||\n+          next_char == ' ' ||\n+          next_char == '\\t');\n+}\n+\n static gssize\n find_auth_end (FlatpakProxyClient *client, Buffer *buffer)\n {\n-  guchar *match;\n-  int i;\n+  goffset offset = 0;\n+  gsize original_size = client->auth_buffer->len;\n+\n+  /* Add the new data to the remaining data from last iteration */\n+  g_byte_array_append (client->auth_buffer, buffer->data, buffer->pos);\n \n-  /* First try to match any leftover at the start */\n-  if (client->auth_end_offset > 0)\n+  while (TRUE)\n     {\n-      gsize left = strlen (AUTH_END_STRING) - client->auth_end_offset;\n-      gsize to_match = MIN (left, buffer->pos);\n-      /* Matched at least up to to_match */\n-      if (memcmp (buffer->data, &AUTH_END_STRING[client->auth_end_offset], to_match) == 0)\n+      guint8 *line_start = client->auth_buffer->data + offset;\n+      gsize remaining_data = client->auth_buffer->len - offset;\n+      guint8 *line_end;\n+\n+      line_end = memmem (line_start, remaining_data,\n+                         AUTH_LINE_SENTINEL, strlen (AUTH_LINE_SENTINEL));\n+      if (line_end) /* Found end of line */\n         {\n-          client->auth_end_offset += to_match;\n+          offset = (line_end + strlen (AUTH_LINE_SENTINEL) - line_start);\n \n-          /* Matched all */\n-          if (client->auth_end_offset == strlen (AUTH_END_STRING))\n-            return to_match;\n+          if (!auth_line_is_valid (line_start, line_end))\n+            return FIND_AUTH_END_ABORT;\n \n-          /* Matched to end of buffer */\n-          return -1;\n-        }\n+          *line_end = 0;\n+          if (auth_line_is_begin (line_start))\n+            return offset - original_size;\n \n-      /* Did not actually match at start */\n-      client->auth_end_offset = -1;\n-    }\n+          /* continue with next line */\n+        }\n+      else\n+        {\n+          /* No end-of-line in this buffer */\n+          g_byte_array_remove_range (client->auth_buffer, 0, offset);\n \n-  /* Look for whole match inside buffer */\n-  match = memmem (buffer, buffer->pos,\n-                  AUTH_END_STRING, strlen (AUTH_END_STRING));\n-  if (match != NULL)\n-    return match - buffer->data + strlen (AUTH_END_STRING);\n+          /* Abort if more than 16k before newline, similar to what dbus-daemon does */\n+          if (client->auth_buffer->len >= 16*1024)\n+            return FIND_AUTH_END_ABORT;\n \n-  /* Record longest prefix match at the end */\n-  for (i = MIN (strlen (AUTH_END_STRING) - 1, buffer->pos); i > 0; i--)\n-    {\n-      if (memcmp (buffer->data + buffer->pos - i, AUTH_END_STRING, i) == 0)\n-        {\n-          client->auth_end_offset = i;\n-          break;\n+          return FIND_AUTH_END_CONTINUE;\n         }\n     }\n-\n-  return -1;\n }\n \n static gboolean\n@@ -2418,6 +2461,14 @@ side_in_cb (GSocket *socket, GIOCondition condition, gpointer user_data)\n                       if (extra_data > 0)\n                         side->extra_input_data = g_bytes_new (buffer->data + buffer->size, extra_data);\n                     }\n+                  else if (auth_end == FIND_AUTH_END_ABORT)\n+                    {\n+                      buffer_unref (buffer);\n+                      if (client->proxy->log_messages)\n+                        g_print (\"Invalid AUTH line, aborting\\n\");\n+                      side_closed (side);\n+                      break;\n+                    }\n                 }\n \n               got_buffer_from_side (side, buffer);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d0ab55ea4ceb2047288a6799d823201fe6b4391f",
            "date": "2025-01-10T13:16:02Z",
            "author_login": "smcv"
          },
          {
            "sha": "51aaaa943a66edf98c925b67ce48641c39943d88",
            "date": "2025-01-10T12:31:30Z",
            "author_login": "smcv"
          },
          {
            "sha": "bb22b078e2ea277ebc039b1f490fa48895a6ec5b",
            "date": "2025-01-10T12:30:52Z",
            "author_login": "smcv"
          },
          {
            "sha": "a2691022b29f72bfa04541c0eef90e2a5eef6354",
            "date": "2025-01-01T17:00:12Z",
            "author_login": "chrisawi"
          },
          {
            "sha": "a160cbcb1fb3c4cd27a4fe5ec30f4ebd54b4064b",
            "date": "2025-01-09T17:44:33Z",
            "author_login": "GeorgesStavracas"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-436",
    "description": "In dbus-proxy/flatpak-proxy.c in Flatpak before 0.8.9, and 0.9.x and 0.10.x before 0.10.3, crafted D-Bus messages to the host can be used to break out of the sandbox, because whitespace handling in the proxy is not identical to whitespace handling in the daemon.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-02-02T14:29:01.637",
    "last_modified": "2024-11-21T04:10:54.507",
    "fix_date": "2018-01-28T19:51:54Z"
  },
  "references": [
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:2766",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/flatpak/flatpak/commit/52346bf187b5a7f1c0fe9075b328b7ad6abe78f6",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/flatpak/flatpak/releases/tag/0.10.3",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/flatpak/flatpak/releases/tag/0.8.9",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2018:2766",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/flatpak/flatpak/commit/52346bf187b5a7f1c0fe9075b328b7ad6abe78f6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/flatpak/flatpak/releases/tag/0.10.3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/flatpak/flatpak/releases/tag/0.8.9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:15.393085",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "flatpak",
    "owner": "flatpak",
    "created_at": "2016-05-19T14:19:21Z",
    "updated_at": "2025-01-12T14:43:18Z",
    "pushed_at": "2025-01-10T13:30:35Z",
    "size": 48404,
    "stars": 4331,
    "forks": 408,
    "open_issues": 1048,
    "watchers": 4331,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "flatpak-0.8.x",
      "flatpak-0.10.x",
      "flatpak-1.0.x",
      "flatpak-1.2.x",
      "flatpak-1.4.x",
      "flatpak-1.6.x",
      "flatpak-1.8.x",
      "flatpak-1.10.x",
      "flatpak-1.12.x",
      "flatpak-1.14.x",
      "main"
    ],
    "languages": {
      "C": 4869239,
      "Shell": 253955,
      "Python": 95324,
      "Meson": 63156,
      "Yacc": 46057,
      "Makefile": 1402,
      "M4": 1366
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-2.1"
    },
    "collected_at": "2025-01-14T15:07:54.048648"
  }
}