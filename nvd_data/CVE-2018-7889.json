{
  "cve_id": "CVE-2018-7889",
  "github_data": {
    "repository": "kovidgoyal/calibre",
    "fix_commit": "aeb5b036a0bf657951756688b3c72bd68b6e4a7d",
    "related_commits": [
      "aeb5b036a0bf657951756688b3c72bd68b6e4a7d",
      "aeb5b036a0bf657951756688b3c72bd68b6e4a7d"
    ],
    "patch_url": "https://github.com/kovidgoyal/calibre/commit/aeb5b036a0bf657951756688b3c72bd68b6e4a7d.patch",
    "fix_commit_details": {
      "sha": "aeb5b036a0bf657951756688b3c72bd68b6e4a7d",
      "commit_date": "2018-03-07T04:35:56Z",
      "author": {
        "login": "kovidgoyal",
        "type": "User",
        "stats": {
          "total_commits": 38387,
          "average_weekly_commits": 40.364879074658255,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 943
        }
      },
      "commit_message": {
        "title": "E-book viewer: Change the file format used to import/export bookmarks to use JSON. This prevents malicious bookmarks files from causing code execution.",
        "length": 198,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 102,
        "additions": 87,
        "deletions": 15
      },
      "files": [
        {
          "filename": "src/calibre/gui2/viewer/bookmarkmanager.py",
          "status": "modified",
          "additions": 9,
          "deletions": 9,
          "patch": "@@ -6,7 +6,7 @@\n __license__ = 'GPL v3'\n __copyright__ = '2013, Kovid Goyal <kovid at kovidgoyal.net>'\n \n-import cPickle\n+import json\n \n from PyQt5.Qt import (\n     Qt, QListWidget, QListWidgetItem, QItemSelectionModel, QAction,\n@@ -186,32 +186,32 @@ def pos_key(b):\n         self.edited.emit(bm)\n \n     def bm_to_item(self, bm):\n-        return bytearray(cPickle.dumps(bm, -1))\n+        return bm.copy()\n \n     def item_to_bm(self, item):\n-        return cPickle.loads(bytes(item.data(Qt.UserRole)))\n+        return item.data(Qt.UserRole).copy()\n \n     def get_bookmarks(self):\n         return list(self)\n \n     def export_bookmarks(self):\n         filename = choose_save_file(\n             self, 'export-viewer-bookmarks', _('Export bookmarks'),\n-            filters=[(_('Saved bookmarks'), ['pickle'])], all_files=False, initial_filename='bookmarks.pickle')\n+            filters=[(_('Saved bookmarks'), ['calibre-bookmarks'])], all_files=False, initial_filename='bookmarks.calibre-bookmarks')\n         if filename:\n-            with open(filename, 'wb') as fileobj:\n-                cPickle.dump(self.get_bookmarks(), fileobj, -1)\n+            with lopen(filename, 'wb') as fileobj:\n+                fileobj.write(json.dumps(self.get_bookmarks(), indent=True))\n \n     def import_bookmarks(self):\n         files = choose_files(self, 'export-viewer-bookmarks', _('Import bookmarks'),\n-            filters=[(_('Saved bookmarks'), ['pickle'])], all_files=False, select_only_single_file=True)\n+            filters=[(_('Saved bookmarks'), ['calibre-bookmarks'])], all_files=False, select_only_single_file=True)\n         if not files:\n             return\n         filename = files[0]\n \n         imported = None\n-        with open(filename, 'rb') as fileobj:\n-            imported = cPickle.load(fileobj)\n+        with lopen(filename, 'rb') as fileobj:\n+            imported = json.load(fileobj)\n \n         if imported is not None:\n             bad = False"
        },
        {
          "filename": "src/calibre/srv/code.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -26,7 +26,7 @@\n from calibre.srv.routes import endpoint, json\n from calibre.srv.utils import get_library_data, get_use_roman\n from calibre.utils.config import prefs, tweaks\n-from calibre.utils.icu import sort_key\n+from calibre.utils.icu import sort_key, numeric_sort_key\n from calibre.utils.localization import get_lang\n from calibre.utils.search_query_parser import ParseException\n \n@@ -393,4 +393,4 @@ def field_names(ctx, rd, field):\n     Optional: ?library_id=<default library>\n     '''\n     db, library_id = get_library_data(ctx, rd)[:2]\n-    return tuple(db.all_field_names(field))\n+    return tuple(sorted(db.all_field_names(field), key=numeric_sort_key))"
        },
        {
          "filename": "src/pyj/book_list/edit_metadata.pyj",
          "status": "modified",
          "additions": 76,
          "deletions": 4,
          "patch": "@@ -15,6 +15,7 @@ from book_list.library_data import (\n     loaded_book_ids, set_book_metadata\n )\n from book_list.router import back\n+from book_list.theme import get_color\n from book_list.top_bar import create_top_bar, set_title\n from book_list.ui import set_panel_handler, show_panel\n from date import format_date\n@@ -39,6 +40,11 @@ add_extra_css(def():\n     style += build_rule(sel + 'table.metadata td', padding_bottom='0.5ex', padding_top='0.5ex', cursor='pointer')\n     style += build_rule(sel + 'table.metadata tr:hover', color='red')\n     style += build_rule(sel + 'table.metadata tr:active', transform='scale(1.5)')\n+\n+    style += build_rule(sel + '.completions', display='flex', flex_wrap='wrap', align_items='center')\n+    style += build_rule(sel + '.completions > div', margin='0.5ex 0.5rem', margin_left='0', padding='0.5ex 0.5rem', border='solid 1px currentColor', border_radius='1ex', cursor='pointer')\n+    style += build_rule(sel + '.completions > div:active', transform='scale(1.5)')\n+    style += build_rule(sel + '.completions > div:hover', background=get_color('window-foreground'), color=get_color('window-background'))\n     return style\n )\n \n@@ -114,21 +120,83 @@ def simple_line_edit(container_id, book_id, field, fm, div, mi):\n         return x\n \n \n+def add_completion(container_id, name):\n+    pass\n+\n+\n+def show_completions(container_id, div, field, prefix, names):\n+    clear(div)\n+    completions = E.div(class_='completions')\n+    div.appendChild(completions)\n+    for i, name in enumerate(names):\n+        completions.appendChild(E.div(name, onclick=add_completion.bind(None, container_id, name)))\n+        if i >= 50:\n+            break\n+\n+\n+def update_completions(container_id, ok, field, names):\n+    c = document.getElementById(container_id)\n+    if not c:\n+        return\n+    d = c.querySelector('div[data-ctype=\"edit\"]')\n+    if not d or d.style.display is not 'block':\n+        return\n+    div = d.lastChild\n+    clear(div)\n+    if not ok:\n+        err = E.div()\n+        safe_set_inner_html(err, names)\n+        div.appendChild(E.div(\n+            _('Failed to download items for completion, with error:'), err\n+        ))\n+        return\n+    val = d.querySelector('input').value or ''\n+    val = value_to_json(val)\n+    if jstype(val) is 'string':\n+        prefix = val\n+    else:\n+        prefix = val[-1] if val.length else ''\n+    if prefix is update_completions.prefix:\n+        return\n+    pl = prefix.toLowerCase().strip()\n+    if pl:\n+        if pl.startswith(update_completions.prefix.toLowerCase()):\n+            matching_names = [x for x in update_completions.names if x.toLowerCase().startswith(pl)]\n+        else:\n+            matching_names = [x for x in names if x.toLowerCase().startswith(pl)]\n+    else:\n+        matching_names = []\n+    update_completions.prefix = prefix\n+    update_completions.names = matching_names\n+    show_completions(container_id, div, field, prefix, matching_names)\n+\n+\n+update_completions.ui_to_list = None\n+update_completions.list_to_ui = None\n+update_completions.names = v'[]'\n+update_completions.prefix = ''\n+\n+\n+def line_edit_updated(container_id, field):\n+    field_names_for(field, update_completions.bind(None, container_id))\n+\n+\n def multiple_line_edit(list_to_ui, ui_to_list, container_id, book_id, field, fm, div, mi):\n     nonlocal value_to_json\n+    update_completions.ui_to_list = ui_to_list\n+    update_completions.list_to_ui = list_to_ui\n     name = fm.name or field\n-    le = E.input(type='text', name=name.replace('#', '_c_'), autocomplete=True)\n+    le = E.input(type='text', name=name.replace('#', '_c_'), autocomplete=True, oninput=line_edit_updated.bind(None, container_id, field))\n     le.value = (resolved_metadata(mi, field) or v'[]').join(list_to_ui)\n     form = create_form(le, line_edit_get_value, container_id, book_id, field)\n     div.appendChild(E.div(style='margin: 0.5ex 1rem', _(\n         'Edit the \"{0}\" below. Multiple items can be separated by {1}.').format(name, list_to_ui.strip())))\n     div.appendChild(E.div(style='margin: 0.5ex 1rem', form))\n-    div.appendChild(E.div(style='margin: 0.5ex 1rem'))\n+    div.appendChild(E.div(E.span(_('Loading all {}...').format(name)), style='margin: 0.5ex 1rem'))\n     le.focus(), le.select()\n     value_to_json = def(x):\n         return [a.strip() for a in x.split(ui_to_list) if a.strip()]\n-    div.lastChild.appendChild(E.span(_('Loading all {}...').format(name)))\n-    field_names_for(field, print)\n+    field_names_for(field, update_completions.bind(None, container_id))\n \n \n def edit_field(container_id, book_id, field):\n@@ -142,6 +210,10 @@ def edit_field(container_id, book_id, field):\n     d.style.display = 'block'\n     d.previousSibling.style.display = 'none'\n     clear(d)\n+    update_completions.ui_to_list = None\n+    update_completions.list_to_ui = None\n+    update_completions.names = v'[]'\n+    update_completions.prefix = ''\n     if field is 'authors':\n         multiple_line_edit(' & ', '&', container_id, book_id, field, fm, d, mi)\n     else:"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "851c826bd88c00c38b8a899bf7d5e9995d7a0f84",
            "date": "2025-01-14T05:03:23Z",
            "author_login": "kovidgoyal"
          },
          {
            "sha": "22ade2ce40ed9d5b5cb9437360eab9b9afa74325",
            "date": "2025-01-14T05:00:49Z",
            "author_login": "unkn0w7n"
          },
          {
            "sha": "55469a6ab628cd884168980453fb570fa5486271",
            "date": "2025-01-14T04:33:00Z",
            "author_login": "kovidgoyal"
          },
          {
            "sha": "50068c9d069cbdd53ef609d7336b07e8036e1bb4",
            "date": "2025-01-14T03:24:15Z",
            "author_login": "kovidgoyal"
          },
          {
            "sha": "db0f74812ba1e945903aa959515d1f6d49af3439",
            "date": "2025-01-13T18:41:23Z",
            "author_login": "un-pogaz"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-502",
    "description": "gui2/viewer/bookmarkmanager.py in Calibre 3.18 calls cPickle.load on imported bookmark data, which allows remote attackers to execute arbitrary code via a crafted .pickle file, as demonstrated by Python code that contains an os.system call.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-03-08T21:29:00.207",
    "last_modified": "2024-11-21T04:12:55.787",
    "fix_date": "2018-03-07T04:35:56Z"
  },
  "references": [
    {
      "url": "https://bugs.launchpad.net/calibre/+bug/1753870",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/kovidgoyal/calibre/commit/aeb5b036a0bf657951756688b3c72bd68b6e4a7d",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://bugs.launchpad.net/calibre/+bug/1753870",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/kovidgoyal/calibre/commit/aeb5b036a0bf657951756688b3c72bd68b6e4a7d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:17.549655",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "calibre",
    "owner": "kovidgoyal",
    "created_at": "2013-05-28T10:03:23Z",
    "updated_at": "2025-01-14T13:01:55Z",
    "pushed_at": "2025-01-14T05:03:28Z",
    "size": 306518,
    "stars": 20329,
    "forks": 2289,
    "open_issues": 4,
    "watchers": 20329,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Python": 24136488,
      "C": 5183353,
      "C++": 791099,
      "HTML": 101638,
      "Shell": 51424,
      "XSLT": 44181,
      "CSS": 24467,
      "JavaScript": 15520,
      "Objective-C": 15127,
      "Batchfile": 7842,
      "Vim Script": 860,
      "CMake": 844
    },
    "commit_activity": {
      "total_commits_last_year": 2038,
      "avg_commits_per_week": 39.19230769230769,
      "days_active_last_year": 323
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-14T13:51:20.685120"
  }
}