{
  "cve_id": "CVE-2018-8788",
  "github_data": {
    "repository": "FreeRDP/FreeRDP",
    "fix_commit": "d1112c279bd1a327e8e4d0b5f371458bf2579659",
    "related_commits": [
      "d1112c279bd1a327e8e4d0b5f371458bf2579659",
      "d1112c279bd1a327e8e4d0b5f371458bf2579659"
    ],
    "patch_url": "https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659.patch",
    "fix_commit_details": {
      "sha": "d1112c279bd1a327e8e4d0b5f371458bf2579659",
      "commit_date": "2018-10-22T14:52:21Z",
      "author": {
        "login": "akallabeth",
        "type": "User",
        "stats": {
          "total_commits": 7809,
          "average_weekly_commits": 11.029661016949152,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 486
        }
      },
      "commit_message": {
        "title": "Fixed CVE-2018-8788",
        "length": 81,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 166,
        "additions": 130,
        "deletions": 36
      },
      "files": [
        {
          "filename": "include/freerdp/codec/nsc.h",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -77,8 +77,8 @@ struct _NSC_CONTEXT\n \t/* color palette allocated by the application */\n \tconst BYTE* palette;\n \n-\tvoid (*decode)(NSC_CONTEXT* context);\n-\tvoid (*encode)(NSC_CONTEXT* context, const BYTE* BitmapData,\n+\tBOOL (*decode)(NSC_CONTEXT* context);\n+\tBOOL (*encode)(NSC_CONTEXT* context, const BYTE* BitmapData,\n \t               UINT32 rowstride);\n \n \tNSC_CONTEXT_PRIV* priv;"
        },
        {
          "filename": "libfreerdp/codec/nsc.c",
          "status": "modified",
          "additions": 80,
          "deletions": 14,
          "patch": "@@ -42,13 +42,24 @@\n #define NSC_INIT_SIMD(_nsc_context) do { } while (0)\n #endif\n \n-static void nsc_decode(NSC_CONTEXT* context)\n+static BOOL nsc_decode(NSC_CONTEXT* context)\n {\n \tUINT16 x;\n \tUINT16 y;\n-\tUINT16 rw = ROUND_UP_TO(context->width, 8);\n-\tBYTE shift = context->ColorLossLevel - 1; /* colorloss recovery + YCoCg shift */\n-\tBYTE* bmpdata = context->BitmapData;\n+\tUINT16 rw;\n+\tBYTE shift;\n+\tBYTE* bmpdata;\n+\tsize_t pos = 0;\n+\n+\tif (!context)\n+\t\treturn FALSE;\n+\n+\trw = ROUND_UP_TO(context->width, 8);\n+\tshift = context->ColorLossLevel - 1; /* colorloss recovery + YCoCg shift */\n+\tbmpdata = context->BitmapData;\n+\n+\tif (!bmpdata)\n+\t\treturn FALSE;\n \n \tfor (y = 0; y < context->height; y++)\n \t{\n@@ -80,6 +91,11 @@ static void nsc_decode(NSC_CONTEXT* context)\n \t\t\tINT16 r_val = y_val + co_val - cg_val;\n \t\t\tINT16 g_val = y_val + cg_val;\n \t\t\tINT16 b_val = y_val - co_val - cg_val;\n+\n+\t\t\tif (pos + 4 > context->BitmapDataLength)\n+\t\t\t\treturn FALSE;\n+\n+\t\t\tpos += 4;\n \t\t\t*bmpdata++ = MINMAX(b_val, 0, 0xFF);\n \t\t\t*bmpdata++ = MINMAX(g_val, 0, 0xFF);\n \t\t\t*bmpdata++ = MINMAX(r_val, 0, 0xFF);\n@@ -90,9 +106,11 @@ static void nsc_decode(NSC_CONTEXT* context)\n \t\t\taplane++;\n \t\t}\n \t}\n+\n+\treturn TRUE;\n }\n \n-static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)\n+static BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize)\n {\n \tUINT32 len;\n \tUINT32 left;\n@@ -105,6 +123,10 @@ static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)\n \n \t\tif (left == 5)\n \t\t{\n+\t\t\tif (outSize < 1)\n+\t\t\t\treturn FALSE;\n+\n+\t\t\toutSize--;\n \t\t\t*out++ = value;\n \t\t\tleft--;\n \t\t}\n@@ -124,26 +146,42 @@ static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)\n \t\t\t\tin += 4;\n \t\t\t}\n \n+\t\t\tif (outSize < len)\n+\t\t\t\treturn FALSE;\n+\n+\t\t\toutSize -= len;\n \t\t\tFillMemory(out, len, value);\n \t\t\tout += len;\n \t\t\tleft -= len;\n \t\t}\n \t\telse\n \t\t{\n+\t\t\tif (outSize < 1)\n+\t\t\t\treturn FALSE;\n+\n+\t\t\toutSize--;\n \t\t\t*out++ = value;\n \t\t\tleft--;\n \t\t}\n \t}\n \n-\t*((UINT32*)out) = *((UINT32*)in);\n+\tif ((outSize < 4) || (left < 4))\n+\t\treturn FALSE;\n+\n+\tmemcpy(out, in, 4);\n+\treturn TRUE;\n }\n \n-static void nsc_rle_decompress_data(NSC_CONTEXT* context)\n+static BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)\n {\n \tUINT16 i;\n \tBYTE* rle;\n \tUINT32 planeSize;\n \tUINT32 originalSize;\n+\n+\tif (!context)\n+\t\treturn FALSE;\n+\n \trle = context->Planes;\n \n \tfor (i = 0; i < 4; i++)\n@@ -152,14 +190,30 @@ static void nsc_rle_decompress_data(NSC_CONTEXT* context)\n \t\tplaneSize = context->PlaneByteCount[i];\n \n \t\tif (planeSize == 0)\n+\t\t{\n+\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n+\t\t\t\treturn FALSE;\n+\n \t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n+\t\t}\n \t\telse if (planeSize < originalSize)\n-\t\t\tnsc_rle_decode(rle, context->priv->PlaneBuffers[i], originalSize);\n+\t\t{\n+\t\t\tif (!nsc_rle_decode(rle, context->priv->PlaneBuffers[i], context->priv->PlaneBuffersLength,\n+\t\t\t                    originalSize))\n+\t\t\t\treturn FALSE;\n+\t\t}\n \t\telse\n+\t\t{\n+\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n+\t\t\t\treturn FALSE;\n+\n \t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n+\t\t}\n \n \t\trle += planeSize;\n \t}\n+\n+\treturn TRUE;\n }\n \n static BOOL nsc_stream_initialize(NSC_CONTEXT* context, wStream* s)\n@@ -396,13 +450,25 @@ BOOL nsc_process_message(NSC_CONTEXT* context, UINT16 bpp,\n \t\treturn FALSE;\n \n \t/* RLE decode */\n-\tPROFILER_ENTER(context->priv->prof_nsc_rle_decompress_data)\n-\tnsc_rle_decompress_data(context);\n-\tPROFILER_EXIT(context->priv->prof_nsc_rle_decompress_data)\n+\t{\n+\t\tBOOL rc;\n+\t\tPROFILER_ENTER(context->priv->prof_nsc_rle_decompress_data)\n+\t\trc = nsc_rle_decompress_data(context);\n+\t\tPROFILER_EXIT(context->priv->prof_nsc_rle_decompress_data)\n+\n+\t\tif (!rc)\n+\t\t\treturn FALSE;\n+\t}\n \t/* Colorloss recover, Chroma supersample and AYCoCg to ARGB Conversion in one step */\n-\tPROFILER_ENTER(context->priv->prof_nsc_decode)\n-\tcontext->decode(context);\n-\tPROFILER_EXIT(context->priv->prof_nsc_decode)\n+\t{\n+\t\tBOOL rc;\n+\t\tPROFILER_ENTER(context->priv->prof_nsc_decode)\n+\t\trc = context->decode(context);\n+\t\tPROFILER_EXIT(context->priv->prof_nsc_decode)\n+\n+\t\tif (!rc)\n+\t\t\treturn FALSE;\n+\t}\n \n \tif (!freerdp_image_copy(pDstData, DstFormat, nDstStride, nXDst, nYDst,\n \t                        width, height, context->BitmapData,"
        },
        {
          "filename": "libfreerdp/codec/nsc_encode.c",
          "status": "modified",
          "additions": 44,
          "deletions": 18,
          "patch": "@@ -51,6 +51,7 @@ static BOOL nsc_context_initialize_encode(NSC_CONTEXT* context)\n \t\tfor (i = 0; i < 5; i++)\n \t\t{\n \t\t\tBYTE* tmp = (BYTE*) realloc(context->priv->PlaneBuffers[i], length);\n+\n \t\t\tif (!tmp)\n \t\t\t\tgoto fail;\n \n@@ -87,7 +88,7 @@ static BOOL nsc_context_initialize_encode(NSC_CONTEXT* context)\n \treturn FALSE;\n }\n \n-static void nsc_encode_argb_to_aycocg(NSC_CONTEXT* context, const BYTE* data,\n+static BOOL nsc_encode_argb_to_aycocg(NSC_CONTEXT* context, const BYTE* data,\n                                       UINT32 scanline)\n {\n \tUINT16 x;\n@@ -104,10 +105,20 @@ static void nsc_encode_argb_to_aycocg(NSC_CONTEXT* context, const BYTE* data,\n \tINT16 b_val;\n \tBYTE a_val;\n \tUINT32 tempWidth;\n+\n+\tif (!context || data || (scanline == 0))\n+\t\treturn FALSE;\n+\n \ttempWidth = ROUND_UP_TO(context->width, 8);\n \trw = (context->ChromaSubsamplingLevel ? tempWidth : context->width);\n \tccl = context->ColorLossLevel;\n \n+\tif (context->priv->PlaneBuffersLength < rw * scanline)\n+\t\treturn FALSE;\n+\n+\tif (rw < scanline * 2)\n+\t\treturn FALSE;\n+\n \tfor (y = 0; y < context->height; y++)\n \t{\n \t\tsrc = data + (context->height - 1 - y) * scanline;\n@@ -242,31 +253,37 @@ static void nsc_encode_argb_to_aycocg(NSC_CONTEXT* context, const BYTE* data,\n \t\tCopyMemory(coplane, coplane - rw, rw);\n \t\tCopyMemory(cgplane, cgplane - rw, rw);\n \t}\n+\n+\treturn TRUE;\n }\n \n-static void nsc_encode_subsampling(NSC_CONTEXT* context)\n+static BOOL nsc_encode_subsampling(NSC_CONTEXT* context)\n {\n \tUINT16 x;\n \tUINT16 y;\n-\tBYTE* co_dst;\n-\tBYTE* cg_dst;\n-\tINT8* co_src0;\n-\tINT8* co_src1;\n-\tINT8* cg_src0;\n-\tINT8* cg_src1;\n \tUINT32 tempWidth;\n \tUINT32 tempHeight;\n+\n+\tif (!context)\n+\t\treturn FALSE;\n+\n \ttempWidth = ROUND_UP_TO(context->width, 8);\n \ttempHeight = ROUND_UP_TO(context->height, 2);\n \n+\tif (tempHeight == 0)\n+\t\treturn FALSE;\n+\n+\tif (tempWidth > context->priv->PlaneBuffersLength / tempHeight)\n+\t\treturn FALSE;\n+\n \tfor (y = 0; y < tempHeight >> 1; y++)\n \t{\n-\t\tco_dst = context->priv->PlaneBuffers[1] + y * (tempWidth >> 1);\n-\t\tcg_dst = context->priv->PlaneBuffers[2] + y * (tempWidth >> 1);\n-\t\tco_src0 = (INT8*) context->priv->PlaneBuffers[1] + (y << 1) * tempWidth;\n-\t\tco_src1 = co_src0 + tempWidth;\n-\t\tcg_src0 = (INT8*) context->priv->PlaneBuffers[2] + (y << 1) * tempWidth;\n-\t\tcg_src1 = cg_src0 + tempWidth;\n+\t\tBYTE* co_dst = context->priv->PlaneBuffers[1] + y * (tempWidth >> 1);\n+\t\tBYTE* cg_dst = context->priv->PlaneBuffers[2] + y * (tempWidth >> 1);\n+\t\tconst INT8* co_src0 = (INT8*) context->priv->PlaneBuffers[1] + (y << 1) * tempWidth;\n+\t\tconst INT8* co_src1 = co_src0 + tempWidth;\n+\t\tconst INT8* cg_src0 = (INT8*) context->priv->PlaneBuffers[2] + (y << 1) * tempWidth;\n+\t\tconst INT8* cg_src1 = cg_src0 + tempWidth;\n \n \t\tfor (x = 0; x < tempWidth >> 1; x++)\n \t\t{\n@@ -280,19 +297,28 @@ static void nsc_encode_subsampling(NSC_CONTEXT* context)\n \t\t\tcg_src1 += 2;\n \t\t}\n \t}\n+\n+\treturn TRUE;\n }\n \n-void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)\n+BOOL nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)\n {\n-\tnsc_encode_argb_to_aycocg(context, bmpdata, rowstride);\n+\tif (!context || !bmpdata || (rowstride == 0))\n+\t\treturn FALSE;\n+\n+\tif (!nsc_encode_argb_to_aycocg(context, bmpdata, rowstride))\n+\t\treturn FALSE;\n \n \tif (context->ChromaSubsamplingLevel)\n \t{\n-\t\tnsc_encode_subsampling(context);\n+\t\tif (!nsc_encode_subsampling(context))\n+\t\t\treturn FALSE;\n \t}\n+\n+\treturn TRUE;\n }\n \n-static UINT32 nsc_rle_encode(BYTE* in, BYTE* out, UINT32 originalSize)\n+static UINT32 nsc_rle_encode(const BYTE* in, BYTE* out, UINT32 originalSize)\n {\n \tUINT32 left;\n \tUINT32 runlength = 1;"
        },
        {
          "filename": "libfreerdp/codec/nsc_encode.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -24,7 +24,7 @@\n \n #include <freerdp/api.h>\n \n-FREERDP_LOCAL void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata,\n+FREERDP_LOCAL BOOL nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata,\n                               UINT32 rowstride);\n \n #endif /* FREERDP_LIB_CODEC_NSC_ENCODE_H */"
        },
        {
          "filename": "libfreerdp/codec/nsc_sse2.c",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -385,7 +385,7 @@ static void nsc_encode_subsampling_sse2(NSC_CONTEXT* context)\n \t}\n }\n \n-static void nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n+static BOOL nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n                             UINT32 scanline)\n {\n \tnsc_encode_argb_to_aycocg_sse2(context, data, scanline);\n@@ -394,6 +394,8 @@ static void nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n \t{\n \t\tnsc_encode_subsampling_sse2(context);\n \t}\n+\n+\treturn TRUE;\n }\n \n void nsc_init_sse2(NSC_CONTEXT* context)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d0fb99715de93983522517eaf475303f3bcbf213",
            "date": "2025-01-14T11:16:30Z",
            "author_login": "akallabeth"
          },
          {
            "sha": "fca3b3d7db4f343d24c5072f139d88217fbb0ad2",
            "date": "2025-01-14T11:09:22Z",
            "author_login": "akallabeth"
          },
          {
            "sha": "6b577b167ec0b41d73cbb9a2336c245fd5954c0d",
            "date": "2025-01-14T08:59:48Z",
            "author_login": "akallabeth"
          },
          {
            "sha": "5a45a8cad4733ab4337711484210eadb97825944",
            "date": "2025-01-13T17:23:47Z",
            "author_login": "akallabeth"
          },
          {
            "sha": "d938f978a8ce46b66dfc0dc39e6115adcd3f548b",
            "date": "2025-01-14T07:30:15Z",
            "author_login": "akallabeth"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-787",
    "description": "FreeRDP prior to version 2.0.0-rc4 contains an Out-Of-Bounds Write of up to 4 bytes in function nsc_rle_decode() that results in a memory corruption and possibly even a remote code execution.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2018-11-29T18:29:00.990",
    "last_modified": "2024-11-21T04:14:18.937",
    "fix_date": "2018-10-22T14:52:21Z"
  },
  "references": [
    {
      "url": "http://www.securityfocus.com/bid/106938",
      "source": "cve@checkpoint.com",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:0697",
      "source": "cve@checkpoint.com",
      "tags": []
    },
    {
      "url": "https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659",
      "source": "cve@checkpoint.com",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00015.html",
      "source": "cve@checkpoint.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://research.checkpoint.com/reverse-rdp-attack-code-execution-on-rdp-clients/",
      "source": "cve@checkpoint.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://usn.ubuntu.com/3845-1/",
      "source": "cve@checkpoint.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://usn.ubuntu.com/3845-2/",
      "source": "cve@checkpoint.com",
      "tags": []
    },
    {
      "url": "http://www.securityfocus.com/bid/106938",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:0697",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00015.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://research.checkpoint.com/reverse-rdp-attack-code-execution-on-rdp-clients/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://usn.ubuntu.com/3845-1/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://usn.ubuntu.com/3845-2/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:38.575848",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "FreeRDP",
    "owner": "FreeRDP",
    "created_at": "2011-06-30T19:14:15Z",
    "updated_at": "2025-01-14T11:51:38Z",
    "pushed_at": "2025-01-14T11:16:30Z",
    "size": 68011,
    "stars": 11214,
    "forks": 14938,
    "open_issues": 248,
    "watchers": 11214,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master",
      "stable-1.0",
      "stable-1.1",
      "stable-2.0"
    ],
    "languages": {
      "C": 17349509,
      "C++": 685511,
      "CMake": 627854,
      "Objective-C": 540407,
      "Java": 373726,
      "HTML": 99135,
      "Shell": 51324,
      "Python": 46681,
      "Lua": 27393,
      "Roff": 26338,
      "Perl": 8044,
      "C#": 5756,
      "CSS": 5696,
      "Makefile": 2420,
      "Rich Text Format": 937
    },
    "commit_activity": {
      "total_commits_last_year": 2287,
      "avg_commits_per_week": 43.98076923076923,
      "days_active_last_year": 268
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:01:37.323973"
  }
}