{
  "cve_id": "CVE-2019-15148",
  "github_data": {
    "repository": "gopro/gpmf-parser",
    "fix_commit": "341f12cd5b97ab419e53853ca00176457c9f1681",
    "related_commits": [
      "341f12cd5b97ab419e53853ca00176457c9f1681",
      "341f12cd5b97ab419e53853ca00176457c9f1681"
    ],
    "patch_url": "https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681.patch",
    "fix_commit_details": {
      "sha": "341f12cd5b97ab419e53853ca00176457c9f1681",
      "commit_date": "2019-05-28T23:29:02Z",
      "author": {
        "login": "dnewman-gpsw",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fixed many security issues with the too crude mp4 reader",
        "length": 56,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 861,
        "additions": 517,
        "deletions": 344
      },
      "files": [
        {
          "filename": "GPMF_parser.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -2,7 +2,7 @@\n  * \n  *  @brief GPMF Parser library\n  *\n- *  @version 1.2.1\n+ *  @version 1.2.2\n  * \n  *  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n  *\t\n@@ -42,7 +42,7 @@ GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) // size is in longs not byt\n {\n \tif (ms)\n \t{\n-\t\tint32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];\n+\t\tuint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];\n \t\tif (nestsize == 0 && ms->nest_level == 0)\n \t\t\tnestsize = ms->buffer_size_longs;\n "
        },
        {
          "filename": "GPMF_parser.h",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -2,7 +2,7 @@\n  * \n  *  @brief GPMF Parser library include\n  * \n- *  @version 1.1.0\n+ *  @version 1.1.1\n  * \n  *  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n  *\t\n@@ -126,7 +126,11 @@ typedef enum GPMFKey // TAG in all caps are GoPro preserved (are defined by GoPr\n \tGPMF_KEY_UNITS =\t\t\tMAKEID('U','N','I','T'),//UNIT - Freedform display string for metadata units (char sting like \"RPM\", \"MPH\", \"km/h\", etc)\n \tGPMF_KEY_SCALE =\t\t\tMAKEID('S','C','A','L'),//SCAL - divisor for input data to scale to the correct units.\n \tGPMF_KEY_TYPE =\t\t\t\tMAKEID('T','Y','P','E'),//TYPE - Type define for complex data structures\n-\tGPMF_KEY_TOTAL_SAMPLES =\tMAKEID('T','S','M','P'),//TOTL - Total Sample Count including the current payload \t\n+\tGPMF_KEY_TOTAL_SAMPLES =\tMAKEID('T','S','M','P'),//TSMP - Total Sample Count including the current payload \t\n+\tGPMF_KEY_TIME_OFFSET =\t\tMAKEID('T','I','M','O'),//TIMO - Time offset of the metadata stream that follows (single 4 byte float)\n+\tGPMF_KEY_TIMING_OFFSET =\tMAKEID('T','I','M','O'),//TIMO - duplicated, as older code might use the other version of TIMO\n+\tGPMF_KEY_TIME_STAMP =\t\tMAKEID('S','T','M','P'),//STMP - Time stamp for the first sample. \n+\tGPMF_KEY_TIME_STAMPS =\t\tMAKEID('S','T','P','S'),//STPS - Stream of all the timestamps delivered (Generally don't use this. This would be if your sensor has no peroidic times, yet precision is required, or for debugging.) \n \tGPMF_KEY_TICK =\t\t\t\tMAKEID('T','I','C','K'),//TICK - Used for slow data. Beginning of data timing in milliseconds. \n \tGPMF_KEY_TOCK =\t\t\t\tMAKEID('T','O','C','K'),//TOCK - Used for slow data. End of data timing in milliseconds. \n \tGPMF_KEY_EMPTY_PAYLOADS =\tMAKEID('E','M','P','T'),//EMPT - Payloads that are empty since the device start (e.g. BLE disconnect.)"
        },
        {
          "filename": "demo/GPMF_demo.c",
          "status": "modified",
          "additions": 10,
          "deletions": 3,
          "patch": "@@ -46,6 +46,12 @@ int main(int argc, char *argv[])\n \t}\n \n \tsize_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);\n+\tif (mp4 == 0)\n+\t{\n+\t\tprintf(\"error: %s is an invalid MP4/MOV\\n\", argv[1]);\n+\t\treturn -1;\n+\t}\n+\n //\tsize_t mp4 = OpenMP4SourceUDTA(argv[1]);  //Search for GPMF payload with MP4's udta \n \n \tmetadatalength = GetDuration(mp4);\n@@ -90,7 +96,7 @@ int main(int argc, char *argv[])\n \t\tfor (index = 0; index < payloads; index++)\n \t\t{\n \t\t\tuint32_t payloadsize = GetPayloadSize(mp4, index);\n-\t\t\tfloat in = 0.0, out = 0.0; //times\n+\t\t\tdouble in = 0.0, out = 0.0; //times\n \t\t\tpayload = GetPayload(mp4, payload, index);\n \t\t\tif (payload == NULL)\n \t\t\t\tgoto cleanup;\n@@ -238,9 +244,10 @@ int main(int argc, char *argv[])\n \t\t{\n \t\t\tif (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream\n \t\t\t{\n+\t\t\t\tdouble in = 0.0, out = 0.0;\n \t\t\t\tuint32_t fourcc = GPMF_Key(ms);\n-\t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE);// GPMF_SAMPLE_RATE_FAST);\n-\t\t\t\tprintf(\"%c%c%c%c sampling rate = %f Hz\\n\", PRINTF_4CC(fourcc), rate);\n+\t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE, &in, &out);// GPMF_SAMPLE_RATE_FAST);\n+\t\t\t\tprintf(\"%c%c%c%c sampling rate = %f Hz (from %f to %f)\\n\", PRINTF_4CC(fourcc), rate, in, out);\n \t\t\t}\n \t\t}\n #endif"
        },
        {
          "filename": "demo/GPMF_mp4reader.c",
          "status": "modified",
          "additions": 494,
          "deletions": 333,
          "patch": "@@ -2,15 +2,14 @@\n *\n *  @brief Way Too Crude MP4|MOV reader\n *\n-*  @version 1.2.1\n+*  @version 1.3.1\n *\n-*  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n+*  (C) Copyright 2017-2019 GoPro Inc (http://gopro.com/).\n *\n-*  Licensed under the Apache License, Version 2.0 (the \"License\");\n-*  you may not use this file except in compliance with the License.\n-*  You may obtain a copy of the License at\n-*\n-*      http://www.apache.org/licenses/LICENSE-2.0\n+*  Licensed under either:\n+*  - Apache License, Version 2.0, http://www.apache.org/licenses/LICENSE-2.0\n+*  - MIT license, http://opensource.org/licenses/MIT\n+*  at your option.\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n@@ -20,21 +19,24 @@\n *\n */\n \n-/* This is not an elegant MP4 parser, only used to help demonstrate extraction of MP4 */\n-\n+/* This is not an elegant MP4 parser, only used to help demonstrate extraction of GPMF */\n \n #include <stdlib.h>\n #include <stdio.h>\n #include <string.h>\n #include <stdint.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n #include \"GPMF_mp4reader.h\"\n \n #define PRINT_MP4_STRUCTURE\t\t0\n \n #ifdef WIN32\n-#define LONGSEEK  _fseeki64\n+#define LONGSEEK\t_fseeki64\n+#define stat64\t\t_stat64\n #else\n-#define LONGSEEK  fseeko\n+#define LONGSEEK\tfseeko\n #endif\n \n \n@@ -50,7 +52,6 @@ uint32_t GetNumberPayloads(size_t handle)\n \treturn 0;\n }\n \n-\n uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)\n {\n \tmp4object *mp4 = (mp4object *)handle;\n@@ -63,31 +64,35 @@ uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)\n \n \t\tif (MP4buffer)\n \t\t{\n-\t\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\n-\t\t\tfread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);\n-\t\t\treturn MP4buffer;\n+\t\t\tif (mp4->filesize > mp4->metaoffsets[index]+mp4->metasizes[index])\n+\t\t\t{\n+\t\t\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\n+\t\t\t\tfread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);\n+\t\t\t\tmp4->filepos = mp4->metaoffsets[index] + mp4->metasizes[index];\n+\t\t\t\treturn MP4buffer;\n+\t\t\t}\n \t\t}\n \t}\n \treturn NULL;\n }\n \n \n-void SavePayload(size_t handle, uint32_t *payload, uint32_t index)\n+void LongSeek(mp4object *mp4, int64_t offset)\n {\n-\tmp4object *mp4 = (mp4object *)handle;\n-\tif (mp4 == NULL) return;\n-\n-\tuint32_t *MP4buffer = NULL;\n-\tif (index < mp4->indexcount && mp4->mediafp && payload)\n+\tif (mp4 && offset)\n \t{\n-\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\n-\t\tfwrite(payload, 1, mp4->metasizes[index], mp4->mediafp);\n+\t\tif (mp4->filepos + offset < mp4->filesize)\n+\t\t{\n+\t\t\tLONGSEEK(mp4->mediafp, offset, SEEK_CUR);\n+\t\t\tmp4->filepos += offset;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tmp4->filepos = mp4->filesize;\n+\t\t}\n \t}\n-\treturn;\n }\n \n-\n-\n void FreePayload(uint32_t *lastpayload)\n {\n \tif (lastpayload)\n@@ -106,6 +111,7 @@ uint32_t GetPayloadSize(size_t handle, uint32_t index)\n \treturn 0;\n }\n \n+\n #define MAX_NEST_LEVEL\t20\n \n size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  //RAW or within MP4\n@@ -115,6 +121,12 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \n \tmemset(mp4, 0, sizeof(mp4object));\n \n+\tstruct stat64 mp4stat;\n+\tstat64(filename, &mp4stat);\n+\tmp4->filesize = mp4stat.st_size;\n+\n+\tif (mp4->filesize < 64) return 0;\n+\n #ifdef _WINDOWS\n \tfopen_s(&mp4->mediafp, filename, \"rb\");\n #else\n@@ -129,25 +141,27 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\tuint64_t nestsize[MAX_NEST_LEVEL] = { 0 };\n \t\tuint64_t lastsize = 0, qtsize;\n \n+\n \t\tdo\n \t\t{\n \t\t\tlen = fread(&qtsize32, 1, 4, mp4->mediafp);\n \t\t\tlen += fread(&qttag, 1, 4, mp4->mediafp);\n-\t\t\tif (len == 8)\n+\t\t\tmp4->filepos += len;\n+\t\t\tif (len == 8 && mp4->filepos < mp4->filesize)\n \t\t\t{\n \t\t\t\tif (!VALID_FOURCC(qttag))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);\n-\n-\t\t\t\t\tNESTSIZE(lastsize - 8);\n-\t\t\t\t\tcontinue;\n+\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\tbreak;\n \t\t\t\t}\n \n \t\t\t\tqtsize32 = BYTESWAP32(qtsize32);\n \n \t\t\t\tif (qtsize32 == 1) // 64-bit Atom\n \t\t\t\t{\n-\t\t\t\t\tfread(&qtsize, 1, 8, mp4->mediafp);\n+\t\t\t\t\tlen = fread(&qtsize, 1, 8, mp4->mediafp);\n+\t\t\t\t\tmp4->filepos += len;\n \t\t\t\t\tqtsize = BYTESWAP64(qtsize) - 8;\n \t\t\t\t}\n \t\t\t\telse\n@@ -168,9 +182,10 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \n \t\t\t\tif (qttag == MAKEID('m', 'd', 'a', 't') ||\n \t\t\t\t\tqttag == MAKEID('f', 't', 'y', 'p') ||\n-\t\t\t\t\tqttag == MAKEID('u', 'd', 't', 'a'))\n+\t\t\t\t\tqttag == MAKEID('u', 'd', 't', 'a') ||\n+\t\t\t\t\tqttag == MAKEID('f', 'r', 'e', 'e'))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\tNESTSIZE(qtsize);\n \n@@ -187,8 +202,6 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\tqttag != MAKEID('d', 'i', 'n', 'f') &&\n \t\t\t\t\tqttag != MAKEID('a', 'l', 'i', 's') &&\n \t\t\t\t\tqttag != MAKEID('s', 't', 's', 'd') &&\n-\t\t\t\t\tqttag != MAKEID('a', 'l', 'i', 's') &&\n-\t\t\t\t\tqttag != MAKEID('a', 'l', 'i', 's') &&\n \t\t\t\t\tqttag != MAKEID('s', 't', 'b', 'l') &&\n \t\t\t\t\tqttag != MAKEID('s', 't', 't', 's') &&\n \t\t\t\t\tqttag != MAKEID('s', 't', 's', 'c') &&\n@@ -197,7 +210,7 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\tqttag != MAKEID('c', 'o', '6', '4') &&\n \t\t\t\t\tqttag != MAKEID('h', 'd', 'l', 'r'))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t}\n@@ -210,7 +223,9 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);\n \t\t\t\t\t\tlen += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);\n \t\t\t\t\t\tlen += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);\n-\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd\n+\n+\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over mvhd\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -233,7 +248,9 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t\tmp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd\n+\n+\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over mvhd\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -244,10 +261,11 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);\n \t\t\t\t\t\tlen += fread(&temp, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.\n \n-\t\t\t\t\t\tif (temp != MAKEID('a', 'l', 'i', 's'))\n+\t\t\t\t\t\tif (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))\n \t\t\t\t\t\t\ttype = temp;\n \n-\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over hldr\n+\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over hldr\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \n@@ -267,10 +285,11 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t\t\ttype = 0; // MP4\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsd\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stsd\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -286,32 +305,35 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tmp4->metastsc_count = num;\n \t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n-\t\t\t\t\t\t\t\tmp4->metastsc = (SampleToChunk *)malloc(num * 12);\n-\t\t\t\t\t\t\t\tif (mp4->metastsc)\n+\t\t\t\t\t\t\t\tif (num > 0)\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tuint32_t total_stsc = num;\n-\t\t\t\t\t\t\t\t\tlen += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);\n-\n-\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\tmp4->metastsc = (SampleToChunk *)malloc(num * sizeof(SampleToChunk));\n+\t\t\t\t\t\t\t\t\tif (mp4->metastsc)\n \t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);\n-\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);\n-\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);\n-\t\t\t\t\t\t\t\t\t} while (num > 0);\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);\n \n-\t\t\t\t\t\t\t\tif (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.\n+\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);\n+\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);\n+\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);\n+\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n-\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n-\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n+\t\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsx\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stsx\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -330,33 +352,44 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tmp4->metasize_count = num;\n \t\t\t\t\t\t\t\tif (mp4->metasizes) free(mp4->metasizes);\n-\t\t\t\t\t\t\t\tmp4->metasizes = (uint32_t *)malloc(num * 4);\n-\t\t\t\t\t\t\t\tif (mp4->metasizes)\n+\t\t\t\t\t\t\t\tif(num > 0)\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tif (equalsamplesize == 0)\n+\t\t\t\t\t\t\t\t\tmp4->metasizes = (uint32_t *)malloc(num * 4);\n+\t\t\t\t\t\t\t\t\tif (mp4->metasizes)\n \t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);\n-\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\tif (equalsamplesize == 0)\n \t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);\n-\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tequalsamplesize = BYTESWAP32(equalsamplesize);\n-\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);\n+\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);\n+\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = equalsamplesize;\n-\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t\t\tequalsamplesize = BYTESWAP32(equalsamplesize);\n+\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = equalsamplesize;\n+\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stsz\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -369,93 +402,121 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\tnum = BYTESWAP32(num);\n \t\t\t\t\t\t\tif (num * 4 <= qtsize - 8 - len)\n \t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tuint32_t metastco_count = num;\n+\n \t\t\t\t\t\t\t\tif (mp4->metastsc_count > 0 && num != mp4->metasize_count)\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tmp4->indexcount = mp4->metasize_count;\n+\t\t\t\t\t\t\t\t\tmp4->indexcount = num;\n \t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n-\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);\n-\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n+\t\t\t\t\t\t\t\t\tif(num > 0)\n \t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;\n-\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);\n-\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)\n+\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);\n+\t\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n \t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;\n-\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;\n-\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;\n-\t\t\t\t\t\t\t\t\t\t\tint repeat = 1;\n-\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets32, 1, num * 4, mp4->mediafp);\n-\t\t\t\t\t\t\t\t\t\t\tdo\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);\n-\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n-\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];\n-\t\t\t\t\t\t\t\t\t\t\tnum = 1;\n-\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->metasize_count)\n+\t\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);\n+\t\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)\n \t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tif (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)\n+\t\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tint repeat = 1;\n+\t\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets32, 1, num * 4, mp4->mediafp);\n+\t\t\t\t\t\t\t\t\t\t\t\tdo\n \t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++; stsc_pos++;\n-\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets32[stco_pos];\n-\t\t\t\t\t\t\t\t\t\t\t\t\trepeat = 1;\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t\telse if (repeat == mp4->metastsc[stsc_pos].samples)\n-\t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;\n-\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets32[stco_pos];\n-\t\t\t\t\t\t\t\t\t\t\t\t\trepeat = 1;\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);\n+\t\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];\n+\t\t\t\t\t\t\t\t\t\t\t\tnum = 1;\n+\t\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->indexcount)\n \t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n-\t\t\t\t\t\t\t\t\t\t\t\t\trepeat++;\n+\t\t\t\t\t\t\t\t\t\t\t\t\tif ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ((uint32_t)stco_pos + 1 < metastco_count)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets32[stco_pos];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstsc_pos++;\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\trepeat = 1;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\trepeat++;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t//int delta = metaoffsets[num] - metaoffsets[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t//printf(\"%3d:%08x, delta = %08x\\n\", num, (int)fileoffset, delta);\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnum++;\n \t\t\t\t\t\t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;\n-\t\t\t\t\t\t\t\t\t\t\t\t//int delta = metaoffsets[num] - metaoffsets[num - 1];\n-\t\t\t\t\t\t\t\t\t\t\t\t//printf(\"%3d:%08x, delta = %08x\\n\", num, (int)fileoffset, delta);\n+\t\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n \n-\t\t\t\t\t\t\t\t\t\t\t\tnum++;\n+\t\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);\n \t\t\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n-\n-\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\t\tmp4->indexcount = num;\n \t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n-\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);\n-\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n+\t\t\t\t\t\t\t\t\tif (num > 0)\n \t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;\n-\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);\n-\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)\n+\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);\n+\t\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n \t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tsize_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);\n-\t\t\t\t\t\t\t\t\t\t\tlen += readlen;\n-\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);\n+\t\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)\n \t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);\n-\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t\t\t\tsize_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);\n+\t\t\t\t\t\t\t\t\t\t\t\tlen += readlen;\n+\t\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);\n+\t\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n \n-\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);\n+\t\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);\n+\t\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stco\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -467,60 +528,79 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n \t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);\n \t\t\t\t\t\t\tnum = BYTESWAP32(num);\n+\n+\t\t\t\t\t\t\tif(num == 0)\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n+\n \t\t\t\t\t\t\tif (num * 8 <= qtsize - 8 - len)\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tif (mp4->metastsc_count > 0 && num != mp4->metasize_count)\n \t\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\t\tmp4->indexcount = mp4->metasize_count;\n \t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n-\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);\n-\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n+\t\t\t\t\t\t\t\t\tif (mp4->metasize_count)\n \t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tuint64_t *metaoffsets64 = NULL;\n-\t\t\t\t\t\t\t\t\t\tmetaoffsets64 = (uint64_t *)malloc(num * 8);\n-\t\t\t\t\t\t\t\t\t\tif (metaoffsets64)\n+\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);\n+\t\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n \t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;\n-\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;\n-\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;\n-\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets64, 1, num * 8, mp4->mediafp);\n-\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\tuint64_t *metaoffsets64 = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tmetaoffsets64 = (uint64_t *)malloc(num * 8);\n+\t\t\t\t\t\t\t\t\t\t\tif (metaoffsets64)\n \t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);\n-\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets64, 1, num * 8, mp4->mediafp);\n+\t\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);\n+\t\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n \n-\t\t\t\t\t\t\t\t\t\t\tfileoffset = metaoffsets64[0];\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset;\n-\t\t\t\t\t\t\t\t\t\t\t//printf(\"%3d:%08x, delta = %08x\\n\", 0, (int)fileoffset, 0);\n+\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = metaoffsets64[0];\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset;\n+\t\t\t\t\t\t\t\t\t\t\t\t//printf(\"%3d:%08x, delta = %08x\\n\", 0, (int)fileoffset, 0);\n \n-\t\t\t\t\t\t\t\t\t\t\tnum = 1;\n-\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->metasize_count)\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tif (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)\n-\t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;\n-\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets64[stco_pos];\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\t\t\tnum = 1;\n+\t\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->metasize_count)\n \t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\tif (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets64[stco_pos];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t//int delta = metaoffsets[num] - metaoffsets[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t//printf(\"%3d:%08x, delta = %08x\\n\", num, (int)fileoffset, delta);\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnum++;\n \t\t\t\t\t\t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;\n-\t\t\t\t\t\t\t\t\t\t\t\t//int delta = metaoffsets[num] - metaoffsets[num - 1];\n-\t\t\t\t\t\t\t\t\t\t\t\t//printf(\"%3d:%08x, delta = %08x\\n\", num, (int)fileoffset, delta);\n+\t\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n \n-\t\t\t\t\t\t\t\t\t\t\t\tnum++;\n+\t\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets64);\n \t\t\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n-\n-\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets64);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t{\n@@ -538,10 +618,11 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stco\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -578,10 +659,11 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stco\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -595,6 +677,15 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\tbreak;\n \t\t\t}\n \t\t} while (len > 0);\n+\n+\t\tif (mp4)\n+\t\t{\n+\t\t\tif (mp4->metasizes == NULL || mp4->metaoffsets == NULL)\n+\t\t\t{\n+\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\tmp4 = NULL;\n+\t\t\t}\n+\t\t}\n \t}\n \telse\n \t{\n@@ -631,20 +722,32 @@ void CloseSource(size_t handle)\n }\n \n \n-uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out)\n+uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out)\n {\n \tmp4object *mp4 = (mp4object *)handle;\n-\tif (mp4 == NULL) return 0;\n+\tif (mp4 == NULL) return GPMF_ERROR_MEMORY;\n \n-\tif (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 1;\n+\tif (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return GPMF_ERROR_MEMORY;\n \n-\t*in = (float)((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n-\t*out = (float)((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n-\treturn 0;\n+\t*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n+\t*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n+\treturn GPMF_OK;\n }\n \n \n-\n+uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator)\n+{\n+    mp4object *mp4 = (mp4object *)handle;\n+    if (mp4 == NULL) return GPMF_ERROR_MEMORY;\n+    \n+    if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in_numerator == NULL || out_numerator == NULL) return GPMF_ERROR_MEMORY;\n+\n+\t*in_numerator = (uint32_t)(index * mp4->basemetadataduration);\n+\t*out_numerator = (uint32_t)((index + 1) * mp4->basemetadataduration);\n+\t*denominator = (uint32_t)mp4->meta_clockdemon;\n+    \n+    return GPMF_OK;\n+}\n \n size_t OpenMP4SourceUDTA(char *filename)\n {\n@@ -661,7 +764,8 @@ size_t OpenMP4SourceUDTA(char *filename)\n \n \tif (mp4->mediafp)\n \t{\n-\t\tuint32_t qttag, qtsize32, len;\n+\t\tuint32_t qttag, qtsize32;\n+\t\tsize_t len;\n \t\tint32_t nest = 0;\n \t\tuint64_t nestsize[MAX_NEST_LEVEL] = { 0 };\n \t\tuint64_t lastsize = 0, qtsize;\n@@ -674,7 +778,7 @@ size_t OpenMP4SourceUDTA(char *filename)\n \t\t\t{\n \t\t\t\tif (!GPMF_VALID_FOURCC(qttag))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);\n+\t\t\t\t\tLongSeek(mp4, lastsize - 8 - 8);\n \n \t\t\t\t\tNESTSIZE(lastsize - 8);\n \t\t\t\t\tcontinue;\n@@ -701,7 +805,7 @@ size_t OpenMP4SourceUDTA(char *filename)\n \t\t\t\tif (qttag == MAKEID('m', 'd', 'a', 't') ||\n \t\t\t\t\tqttag == MAKEID('f', 't', 'y', 'p'))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n@@ -725,7 +829,7 @@ size_t OpenMP4SourceUDTA(char *filename)\n \t\t\t\tif (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms\n \t\t\t\t\tqttag != MAKEID('u', 'd', 't', 'a'))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n@@ -740,7 +844,7 @@ size_t OpenMP4SourceUDTA(char *filename)\n }\n \n \n-double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)\n+double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags, double *firstsampletime, double *lastsampletime)\n {\n \tmp4object *mp4 = (mp4object *)handle;\n \tif (mp4 == NULL) return 0.0;\n@@ -750,221 +854,278 @@ double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)\n \tuint32_t testend = mp4->indexcount;\n \tdouble rate = 0.0;\n \n+\tuint32_t *payload;\n+\tuint32_t payloadsize;\n+\tint32_t ret;\n+\n \tif (mp4->indexcount < 1)\n \t\treturn 0.0;\n \n-\tif (mp4->indexcount > 3) // samples after first and before last are statistically the best, avoiding camera start up or shutdown anomollies. \n-\t{\n-\t\tteststart++;\n-\t\ttestend--;\n-\t}\n-\n-\tuint32_t *payload = GetPayload(handle, NULL, teststart); // second payload\n-\tuint32_t payloadsize = GetPayloadSize(handle, teststart);\n-\tint32_t ret = GPMF_Init(ms, payload, payloadsize);\n+\tpayload = GetPayload(handle, NULL, teststart); \n+\tpayloadsize = GetPayloadSize(handle, teststart);\n+\tret = GPMF_Init(ms, payload, payloadsize);\n \n \tif (ret != GPMF_OK)\n \t\tgoto cleanup;\n \n \t{\n+\t\tuint64_t minimumtimestamp = 0;\n+\t\tuint64_t starttimestamp = 0;\n+\t\tuint64_t endtimestamp = 0;\n \t\tuint32_t startsamples = 0;\n \t\tuint32_t endsamples = 0;\n-\t\tuint32_t missing_samples = 0;\n+\t\tdouble intercept = 0.0;\n+\n+\n \n-\t\twhile (ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n+\t\twhile (teststart < mp4->indexcount && ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n \t\t{\n-\t\t\tmissing_samples = 1;\n \t\t\tteststart++;\n \t\t\tpayload = GetPayload(handle, payload, teststart); // second last payload\n \t\t\tpayloadsize = GetPayloadSize(handle, teststart);\n \t\t\tret = GPMF_Init(ms, payload, payloadsize);\n \t\t}\n \n-\t\tif (missing_samples)\n-\t\t{\n-\t\t\tteststart++;   //samples after sensor start are statistically the best\n-\t\t\tpayload = GetPayload(handle, payload, teststart);\n-\t\t\tpayloadsize = GetPayloadSize(handle, teststart);\n-\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n-\t\t}\n-\n-\t\tif (ret == GPMF_OK)\n+\t\tif (ret == GPMF_OK && payload)\n \t\t{\n-\t\t\tuint32_t samples = GPMF_Repeat(ms);\n+\t\t\tuint32_t samples = GPMF_PayloadSampleCount(ms);\n \t\t\tGPMF_stream find_stream;\n \t\t\tGPMF_CopyState(ms, &find_stream);\n+\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n+\t\t\t\tstartsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;\n \n-\t\t\tif (!(flags & GPMF_SAMPLE_RATE_PRECISE) && GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n+\t\t\tGPMF_CopyState(ms, &find_stream);\n+\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))\n+\t\t\t\tstarttimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));\n+\n+\t\t\tif (starttimestamp) // is this earliest in the payload, examine the other streams in this early payload.\n \t\t\t{\n-\t\t\t\tstartsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;\n+\t\t\t\tGPMF_stream any_stream;\n+\t\t\t\tGPMF_Init(&any_stream, payload, payloadsize);\n+\n+\t\t\t\tminimumtimestamp = starttimestamp;\n+\t\t\t\twhile (GPMF_OK == GPMF_FindNext(&any_stream, GPMF_KEY_TIME_STAMP, GPMF_RECURSE_LEVELS))\n+\t\t\t\t{\n+\t\t\t\t\tuint64_t timestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&any_stream));\n+\t\t\t\t\tif (timestamp < minimumtimestamp)\n+\t\t\t\t\t\tminimumtimestamp = timestamp;\n+\t\t\t\t}\n+\t\t\t}\n \n-\t\t\t\tpayload = GetPayload(handle, payload, testend); // second last payload\n+\t\t\ttestend = mp4->indexcount;\n+\t\t\tdo\n+\t\t\t{\n+\t\t\t\ttestend--;// last payload with the fourcc needed\n+\t\t\t\tpayload = GetPayload(handle, payload, testend);\n \t\t\t\tpayloadsize = GetPayloadSize(handle, testend);\n \t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n-\t\t\t\tif (ret != GPMF_OK)\n-\t\t\t\t\tgoto cleanup;\n+\t\t\t} while (testend > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));\n \n-\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n+\t\t\tGPMF_CopyState(ms, &find_stream);\n+\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n+\t\t\t\tendsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));\n+\t\t\telse // If there is no TSMP we have to count the samples.\n+\t\t\t{\n+\t\t\t\tuint32_t i;\n+\t\t\t\tfor (i = teststart; i <= testend; i++)\n \t\t\t\t{\n-\t\t\t\t\tGPMF_CopyState(ms, &find_stream);\n-\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n+\t\t\t\t\tpayload = GetPayload(handle,payload, i); // second last payload\n+\t\t\t\t\tpayloadsize = GetPayloadSize(handle, i);\n+\t\t\t\t\tif (GPMF_OK == GPMF_Init(ms, payload, payloadsize))\n+\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n+\t\t\t\t\t\t\tendsamples += GPMF_PayloadSampleCount(ms);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (starttimestamp != 0)\n+\t\t\t{\n+\t\t\t\tuint32_t last_samples = GPMF_PayloadSampleCount(ms);\n+\t\t\t\tuint32_t totaltimestamped_samples = endsamples - last_samples - startsamples;\n+\t\t\t\tdouble time_stamp_scale = 1000000000.0; // scan for nanoseconds, microseconds to seconds, all base 10.\n+\n+\t\t\t\tGPMF_CopyState(ms, &find_stream);\n+\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))\n+\t\t\t\t\tendtimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));\n+\n+\t\t\t\tif (endtimestamp)\n+\t\t\t\t{\n+\t\t\t\t\tdouble approxrate = 0.0;\n+\t\t\t\t\tif (endsamples > startsamples)\n+\t\t\t\t\t\tapproxrate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n+\n+\t\t\t\t\tif (approxrate == 0.0)\n+\t\t\t\t\t\tapproxrate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n+\n+\n+\t\t\t\t\twhile (time_stamp_scale >= 1)\n \t\t\t\t\t{\n-\t\t\t\t\t\tendsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));\n-\t\t\t\t\t\trate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n-\t\t\t\t\t\tgoto cleanup;\n+\t\t\t\t\t\trate = (double)(totaltimestamped_samples) / ((double)(endtimestamp - starttimestamp) / time_stamp_scale);\n+\t\t\t\t\t\tif (rate*0.9 < approxrate && approxrate < rate*1.1)\n+\t\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\t\ttime_stamp_scale *= 0.1;\n \t\t\t\t\t}\n+\t\t\t\t\tif (time_stamp_scale < 1.0) rate = 0.0;\n+\t\t\t\t\tintercept = (((double)minimumtimestamp - (double)starttimestamp) / time_stamp_scale) * rate;\n \t\t\t\t}\n-\n-\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n \t\t\t}\n-\t\t\telse // for increased precision, for older GPMF streams sometimes missing the total sample count \n+\n+\t\t\tif (rate == 0.0) //Timestamps didn't help weren't available\n \t\t\t{\n-\t\t\t\tuint32_t payloadpos = 0, payloadcount = 0;\n-\t\t\t\tdouble slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;\n-\t\t\t\tuint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);\n-\t\t\t\tmemset(repeatarray, 0, mp4->indexcount * 4 + 4);\n+\t\t\t\tif (!(flags & GPMF_SAMPLE_RATE_PRECISE))\n+\t\t\t\t{\n+\t\t\t\t\tif (endsamples > startsamples)\n+\t\t\t\t\t\trate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n \n-\t\t\t\tsamples = 0;\n+\t\t\t\t\tif (rate == 0.0)\n+\t\t\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n \n-\t\t\t\tfor (payloadpos = teststart; payloadpos < testend; payloadcount++, payloadpos++)\n+\t\t\t\t\tdouble in, out;\n+\t\t\t\t\tif (GPMF_OK == GetPayloadTime(handle, teststart, &in, &out))\n+\t\t\t\t\t\tintercept = (double)-in * rate;\n+\t\t\t\t}\n+\t\t\t\telse // for increased precision, for older GPMF streams sometimes missing the total sample count \n \t\t\t\t{\n-\t\t\t\t\tpayload = GetPayload(handle, payload, payloadpos); // second last payload\n-\t\t\t\t\tpayloadsize = GetPayloadSize(handle, payloadpos);\n-\t\t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n+\t\t\t\t\tuint32_t payloadpos = 0, payloadcount = 0;\n+\t\t\t\t\tdouble slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;\n+\t\t\t\t\tuint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);\n+\t\t\t\t\tmemset(repeatarray, 0, mp4->indexcount * 4 + 4);\n \n-\t\t\t\t\tif (ret != GPMF_OK)\n-\t\t\t\t\t\tgoto cleanup;\n+\t\t\t\t\tsamples = 0;\n \n-\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n+\t\t\t\t\tfor (payloadpos = teststart; payloadpos <= testend; payloadpos++)\n \t\t\t\t\t{\n-\t\t\t\t\t\tGPMF_stream find_stream2;\n-\t\t\t\t\t\tGPMF_CopyState(ms, &find_stream2);\n+\t\t\t\t\t\tpayload = GetPayload(handle, payload, payloadpos); // second last payload\n+\t\t\t\t\t\tpayloadsize = GetPayloadSize(handle, payloadpos);\n+\t\t\t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n \n-\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats\n+\t\t\t\t\t\tif (ret != GPMF_OK)\n+\t\t\t\t\t\t\tgoto cleanup;\n+\n+\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\tif (repeatarray)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfloat in, out;\n+\t\t\t\t\t\t\tGPMF_stream find_stream2;\n+\t\t\t\t\t\t\tGPMF_CopyState(ms, &find_stream2);\n+\n+\t\t\t\t\t\t\tpayloadcount++;\n \n-\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tif (repeatarray)\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tsamples++;\n-\t\t\t\t\t\t\t\t} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));\n+\t\t\t\t\t\t\t\t\tdouble in, out;\n \n-\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n-\t\t\t\t\t\t\t\tmeanY += (double)samples;\n+\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\tsamples++;\n+\t\t\t\t\t\t\t\t\t} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));\n \n-\t\t\t\t\t\t\t\tGetPayloadTime(handle, payloadpos, &in, &out);\n-\t\t\t\t\t\t\t\tmeanX += out;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tuint32_t repeat = GPMF_Repeat(ms);\n-\t\t\t\t\t\t\tsamples += repeat;\n+\t\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n+\t\t\t\t\t\t\t\t\tmeanY += (double)samples;\n \n-\t\t\t\t\t\t\tif (repeatarray)\n+\t\t\t\t\t\t\t\t\tif (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))\n+\t\t\t\t\t\t\t\t\t\tmeanX += out;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfloat in, out;\n+\t\t\t\t\t\t\t\tuint32_t repeat = GPMF_PayloadSampleCount(ms);\n+\t\t\t\t\t\t\t\tsamples += repeat;\n+\n+\t\t\t\t\t\t\t\tif (repeatarray)\n+\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\tdouble in, out;\n \n-\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n-\t\t\t\t\t\t\t\tmeanY += (double)samples;\n+\t\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n+\t\t\t\t\t\t\t\t\tmeanY += (double)samples;\n \n-\t\t\t\t\t\t\t\tGetPayloadTime(handle, payloadpos, &in, &out);\n-\t\t\t\t\t\t\t\tmeanX += out;\n+\t\t\t\t\t\t\t\t\tif (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))\n+\t\t\t\t\t\t\t\t\t\tmeanX += out;\n+\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\trepeatarray[payloadpos] = 0;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// Compute the line of best fit for a jitter removed sample rate.  \n-\t\t\t\t// This does assume an unchanging clock, even though the IMU data can thermally impacted causing small clock changes.  \n-\t\t\t\t// TODO: Next enhancement would be a low order polynominal fit the compensate for any thermal clock drift.\n-\t\t\t\tif (repeatarray)\n-\t\t\t\t{\n-\t\t\t\t\tmeanY /= (double)payloadcount;\n-\t\t\t\t\tmeanX /= (double)payloadcount;\n \n-\t\t\t\t\tfor (payloadpos = teststart; payloadpos < testend; payloadpos++)\n+\t\t\t\t\t// Compute the line of best fit for a jitter removed sample rate.  \n+\t\t\t\t\t// This does assume an unchanging clock, even though the IMU data can thermally impacted causing small clock changes.  \n+\t\t\t\t\t// TODO: Next enhancement would be a low order polynominal fit the compensate for any thermal clock drift.\n+\t\t\t\t\tif (repeatarray)\n \t\t\t\t\t{\n-\t\t\t\t\t\tfloat in, out;\n-\t\t\t\t\t\tGetPayloadTime(handle, payloadpos, &in, &out);\n+\t\t\t\t\t\tmeanY /= (double)payloadcount;\n+\t\t\t\t\t\tmeanX /= (double)payloadcount;\n \n-\t\t\t\t\t\ttop += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);\n-\t\t\t\t\t\tbot += ((double)out - meanX)*((double)out - meanX);\n-\t\t\t\t\t}\n+\t\t\t\t\t\tfor (payloadpos = teststart; payloadpos <= testend; payloadpos++)\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tdouble in, out;\n+\t\t\t\t\t\t\tif (repeatarray[payloadpos] && GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\ttop += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);\n+\t\t\t\t\t\t\t\tbot += ((double)out - meanX)*((double)out - meanX);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n \n-\t\t\t\t\tslope = top / bot;\n+\t\t\t\t\t\tslope = top / bot;\n+\t\t\t\t\t\trate = slope;\n \n+\t\t\t\t\t\t// This sample code might be useful for compare data latency between channels.\n+\t\t\t\t\t\tintercept = meanY - slope * meanX;\n #if 0\n-\t\t\t\t\t// This sample code might be useful for compare data latency between channels.\n+\t\t\t\t\t\tprintf(\"%c%c%c%c start offset = %f (%.3fms) rate = %f\\n\", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope, rate);\n+\t\t\t\t\t\tprintf(\"%c%c%c%c first sample at time %.3fms\\n\", PRINTF_4CC(fourcc), -1000.0 * intercept / slope);\n+#endif\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n \t\t\t\t\t{\n-\t\t\t\t\t\tdouble intercept;\n-\t\t\t\t\t\tintercept = meanY - slope*meanX;\n-\t\t\t\t\t\tprintf(\"%c%c%c%c start offset = %f (%.3fms)\\n\", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope);\n+\t\t\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n \t\t\t\t\t}\n-#endif\n-\t\t\t\t\trate = slope;\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n-\t\t\t\t}\n-\n-\t\t\t\tfree(repeatarray);\n \n-\t\t\t\tgoto cleanup;\n+\t\t\t\t\tfree(repeatarray);\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n-\t}\n \n-cleanup:\n-\tif (payload) \n-\t{\n-\t\tFreePayload(payload);\n-\t\tpayload = NULL;\n-\t}\n-\n-\treturn rate;\n-}\n+\t\t\tif (firstsampletime && lastsampletime)\n+\t\t\t{\n+\t\t\t\tuint32_t endpayload = mp4->indexcount;\n+\t\t\t\tdo\n+\t\t\t\t{\n+\t\t\t\t\tendpayload--;// last payload with the fourcc needed\n+\t\t\t\t\tpayload = GetPayload(handle, payload, endpayload);\n+\t\t\t\t\tpayloadsize = GetPayloadSize(handle, endpayload);\n+\t\t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n+\t\t\t\t} while (endpayload > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));\n \n+\t\t\t\tif (endpayload > 0 && ret == GPMF_OK)\n+\t\t\t\t{\n+\t\t\t\t\tuint32_t totalsamples = endsamples - startsamples;\n+\t\t\t\t\tfloat timo = 0.0;\n \n-double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double rate, uint32_t index, double *in, double *out)\n-{\n-\tmp4object *mp4 = (mp4object *)handle;\n-\tif (mp4 == NULL) return 0.0;\n+\t\t\t\t\tGPMF_CopyState(ms, &find_stream);\n+\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_OFFSET, GPMF_CURRENT_LEVEL))\n+\t\t\t\t\t\tGPMF_FormattedData(&find_stream, &timo, 4, 0, 1);\n \n-\tuint32_t key, insamples;\n-\tuint32_t repeat, outsamples;\n-\tGPMF_stream find_stream;\n+\t\t\t\t\tdouble first, last;\n+\t\t\t\t\tfirst = -intercept / rate - timo;\n+\t\t\t\t\tlast = first + (double)totalsamples / rate;\n \n-\tif (gs == NULL || mp4->metaoffsets == 0 || mp4->indexcount == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 0.0;\n+\t\t\t\t\t//printf(\"%c%c%c%c first sample at time %.3fms, last at %.3fms\\n\", PRINTF_4CC(fourcc), 1000.0*first, 1000.0*last);\n \n-\tkey = GPMF_Key(gs);\n-\trepeat = GPMF_Repeat(gs);\n-\tif (rate == 0.0)\n-\t\trate = GetGPMFSampleRate(handle, key, GPMF_SAMPLE_RATE_FAST);\n+\t\t\t\t\tif (firstsampletime) *firstsampletime = first;\n \n-\tif (rate == 0.0)\n-\t{\n-\t\t*in = *out = 0.0;\n-\t\treturn 0.0;\n+\t\t\t\t\tif (lastsampletime) *lastsampletime = last;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n \n-\tGPMF_CopyState(gs, &find_stream);\n-\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n-\t{\n-\t\toutsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));\n-\t\tinsamples = outsamples - repeat;\n+cleanup:\n+\tif (payload)\n+\t\tFreePayload(payload);\n+\tpayload = NULL;\n \n-\t\t*in = ((double)insamples / (double)rate);\n-\t\t*out = ((double)outsamples / (double)rate);\n-\t}\n-\telse\n-\t{\n-\t\t// might too costly in some applications read all the samples to determine the clock jitter, here I return the estimate from the MP4 track.\n-\t\t*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n-\t\t*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n-\t}\n \treturn rate;\n }\n+"
        },
        {
          "filename": "demo/GPMF_mp4reader.h",
          "status": "modified",
          "additions": 5,
          "deletions": 4,
          "patch": "@@ -64,6 +64,8 @@ typedef struct mp4object\n \tuint32_t meta_clockdemon, meta_clockcount;\n \tdouble basemetadataduration;\n \tFILE *mediafp;\n+\tuint64_t filesize;\n+\tuint64_t filepos;\n } mp4object;\n \n #define MAKEID(a,b,c,d)\t\t\t(((d&0xff)<<24)|((c&0xff)<<16)|((b&0xff)<<8)|(a&0xff))\n@@ -101,16 +103,15 @@ void CloseSource(size_t handle);\n float GetDuration(size_t handle);\n uint32_t GetNumberPayloads(size_t handle);\n uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index);\n-void SavePayload(size_t handle, uint32_t *payload, uint32_t index);\n void FreePayload(uint32_t *lastpayload);\n uint32_t GetPayloadSize(size_t handle, uint32_t index);\n-uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out); //MP4 timestamps for the payload\n+uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out); //MP4 timestamps for the payload\n+uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator);\n \n #define GPMF_SAMPLE_RATE_FAST\t\t0\n #define GPMF_SAMPLE_RATE_PRECISE\t1\n \n-double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags);\n-double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double lastrate, uint32_t index, double *in, double *out); //Jitter corrected sample(s) time, if lastrate is unknown, send 0.0 and it will be computed\n+double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags, double *in, double *out);\n \n #ifdef __cplusplus\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "54cf26ebddd15628ac30552f7eba57807b7dc6f7",
            "date": "2024-10-11T16:56:22Z",
            "author_login": "dnewman-gpsw"
          },
          {
            "sha": "227fcade5e24c74d4a543a0671727319be91f096",
            "date": "2024-09-09T18:58:51Z",
            "author_login": "dnewman-gpsw"
          },
          {
            "sha": "2678feb68e1b53735bcb39ed0d3f3a79d7defe39",
            "date": "2024-03-18T17:33:58Z",
            "author_login": "dnewman-gpsw"
          },
          {
            "sha": "8e4fb95288cb9f9c51065b52a2178af9335207e0",
            "date": "2024-02-17T03:50:53Z",
            "author_login": "bradh"
          },
          {
            "sha": "ccf170f7d5c56a74469c98a78da986cf91a6a895",
            "date": "2024-02-11T18:13:39Z",
            "author_login": "dnewman-gpsw"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-787",
    "description": "GoPro GPMF-parser 1.2.2 has an out-of-bounds write in OpenMP4Source in demo/GPMF_mp4reader.c.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2019-08-18T19:15:10.620",
    "last_modified": "2024-11-21T04:28:09.897",
    "fix_date": "2019-05-28T23:29:02Z"
  },
  "references": [
    {
      "url": "https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/gopro/gpmf-parser/issues/60",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/gopro/gpmf-parser/issues/60",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:57.274787",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "gpmf-parser",
    "owner": "gopro",
    "created_at": "2017-03-29T23:27:56Z",
    "updated_at": "2025-01-11T19:58:13Z",
    "pushed_at": "2024-10-11T16:56:27Z",
    "size": 57658,
    "stars": 558,
    "forks": 114,
    "open_issues": 24,
    "watchers": 558,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "C": 96854,
      "CMake": 1081,
      "Shell": 699,
      "Dockerfile": 107
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:11:42.851745"
  }
}