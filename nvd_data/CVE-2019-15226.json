{
  "cve_id": "CVE-2019-15226",
  "github_data": {
    "repository": "envoyproxy/envoy",
    "fix_commit": "afc39bea36fd436e54262f150c009e8d72db5014",
    "related_commits": [
      "afc39bea36fd436e54262f150c009e8d72db5014",
      "afc39bea36fd436e54262f150c009e8d72db5014"
    ],
    "patch_url": "https://github.com/envoyproxy/envoy/commit/afc39bea36fd436e54262f150c009e8d72db5014.patch",
    "fix_commit_details": {
      "sha": "afc39bea36fd436e54262f150c009e8d72db5014",
      "commit_date": "2019-10-07T21:58:39Z",
      "author": {
        "login": "asraa",
        "type": "User",
        "stats": {
          "total_commits": 179,
          "average_weekly_commits": 0.40589569160997735,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 84
        }
      },
      "commit_message": {
        "title": "Track byteSize of HeaderMap internally.",
        "length": 424,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 486,
        "additions": 397,
        "deletions": 89
      },
      "files": [
        {
          "filename": "docs/root/intro/version_history.rst",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -85,6 +85,10 @@ Version history\n * upstream: added :ref:`fail_traffic_on_panic <envoy_api_field_Cluster.CommonLbConfig.ZoneAwareLbConfig.fail_traffic_on_panic>` to allow failing all requests to a cluster during panic state.\n * zookeeper: parse responses and emit latency stats.\n \n+1.11.2 (October 8, 2019)\n+========================\n+* http: fixed CVE-2019-15226 by adding a cached byte size in HeaderMap.\n+\n 1.11.1 (August 13, 2019)\n ========================\n * http: added mitigation of client initiated attacks that result in flooding of the downstream HTTP/2 connections. Those attacks can be logged at the \"warning\" level when the runtime feature `http.connection_manager.log_flood_exception` is enabled. The runtime setting defaults to disabled to avoid log spam when under attack."
        },
        {
          "filename": "include/envoy/access_log/access_log.h",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -78,6 +78,10 @@ class Instance {\n \n   /**\n    * Log a completed request.\n+   * Prior to logging, call refreshByteSize() on HeaderMaps to ensure that an accurate byte size\n+   * count is logged.\n+   * TODO(asraa): Remove refreshByteSize() requirement when entries in HeaderMap can no longer be\n+   * modified by reference and headerMap holds an accurate internal byte size count.\n    * @param request_headers supplies the incoming request headers after filtering.\n    * @param response_headers supplies response headers.\n    * @param response_trailers supplies response trailers."
        },
        {
          "filename": "include/envoy/http/header_map.h",
          "status": "modified",
          "additions": 33,
          "deletions": 1,
          "patch": "@@ -457,9 +457,41 @@ class HeaderMap {\n   virtual void setReferenceKey(const LowerCaseString& key, const std::string& value) PURE;\n \n   /**\n+   * HeaderMap contains an internal byte size count, updated as entries are added, removed, or\n+   * modified through the HeaderMap interface. However, HeaderEntries can be accessed and modified\n+   * by reference so that the HeaderMap can no longer accurately update the internal byte size\n+   * count.\n+   *\n+   * Calling byteSize before a HeaderEntry is accessed will return the internal byte size count. The\n+   * value is cleared when a HeaderEntry is accessed, and the value is updated and set again when\n+   * refreshByteSize is called.\n+   *\n+   * To guarantee an accurate byte size count, call refreshByteSize.\n+   *\n+   * @return uint64_t the approximate size of the header map in bytes if valid.\n+   */\n+  virtual absl::optional<uint64_t> byteSize() const PURE;\n+\n+  /**\n+   * This returns the sum of the byte sizes of the keys and values in the HeaderMap. This also\n+   * updates and sets the byte size count.\n+   *\n+   * To guarantee an accurate byte size count, use this. If it is known HeaderEntries have not been\n+   * manipulated since a call to refreshByteSize, it is safe to use byteSize.\n+   *\n+   * @return uint64_t the approximate size of the header map in bytes.\n+   */\n+  virtual uint64_t refreshByteSize() PURE;\n+\n+  /**\n+   * This returns the sum of the byte sizes of the keys and values in the HeaderMap.\n+   *\n+   * This iterates over the HeaderMap to calculate size and should only be called directly when the\n+   * user wants an explicit recalculation of the byte size.\n+   *\n    * @return uint64_t the approximate size of the header map in bytes.\n    */\n-  virtual uint64_t byteSize() const PURE;\n+  virtual uint64_t byteSizeInternal() const PURE;\n \n   /**\n    * Get a header by key."
        },
        {
          "filename": "source/common/http/conn_manager_impl.cc",
          "status": "modified",
          "additions": 12,
          "deletions": 8,
          "patch": "@@ -506,6 +506,18 @@ ConnectionManagerImpl::ActiveStream::~ActiveStream() {\n   }\n \n   connection_manager_.stats_.named_.downstream_rq_active_.dec();\n+  // Refresh byte sizes of the HeaderMaps before logging.\n+  // TODO(asraa): Remove this when entries in HeaderMap can no longer be modified by reference and\n+  // HeaderMap holds an accurate internal byte size count.\n+  if (request_headers_ != nullptr) {\n+    request_headers_->refreshByteSize();\n+  }\n+  if (response_headers_ != nullptr) {\n+    response_headers_->refreshByteSize();\n+  }\n+  if (response_trailers_ != nullptr) {\n+    response_trailers_->refreshByteSize();\n+  }\n   for (const AccessLog::InstanceSharedPtr& access_log : connection_manager_.config_.accessLogs()) {\n     access_log->log(request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n                     stream_info_);\n@@ -719,14 +731,6 @@ void ConnectionManagerImpl::ActiveStream::decodeHeaders(HeaderMapPtr&& headers,\n     }\n   }\n \n-  ASSERT(connection_manager_.config_.maxRequestHeadersKb() > 0);\n-  if (request_headers_->byteSize() > (connection_manager_.config_.maxRequestHeadersKb() * 1024)) {\n-    sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_),\n-                   Code::RequestHeaderFieldsTooLarge, \"\", nullptr, is_head_request_, absl::nullopt,\n-                   StreamInfo::ResponseCodeDetails::get().RequestHeadersTooLarge);\n-    return;\n-  }\n-\n   // Currently we only support relative paths at the application layer. We expect the codec to have\n   // broken the path into pieces if applicable. NOTE: Currently the HTTP/1.1 codec only does this\n   // when the allow_absolute_url flag is enabled on the HCM."
        },
        {
          "filename": "source/common/http/header_map_impl.cc",
          "status": "modified",
          "additions": 54,
          "deletions": 9,
          "patch": "@@ -295,14 +295,17 @@ struct HeaderMapImpl::StaticLookupTable : public TrieLookupTable<EntryCb> {\n   }\n };\n \n-void HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) {\n+uint64_t HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) {\n   if (data.empty()) {\n-    return;\n+    return 0;\n   }\n+  uint64_t byte_size = 0;\n   if (!header.empty()) {\n     header.append(\",\", 1);\n+    byte_size += 1;\n   }\n   header.append(data.data(), data.size());\n+  return data.size() + byte_size;\n }\n \n HeaderMapImpl::HeaderMapImpl() { memset(&inline_headers_, 0, sizeof(inline_headers_)); }\n@@ -319,6 +322,20 @@ HeaderMapImpl::HeaderMapImpl(\n   }\n }\n \n+void HeaderMapImpl::addSize(uint64_t size) {\n+  // Adds size to cached_byte_size_ if it exists.\n+  if (cached_byte_size_.has_value()) {\n+    cached_byte_size_.value() += size;\n+  }\n+}\n+\n+void HeaderMapImpl::subtractSize(uint64_t size) {\n+  if (cached_byte_size_.has_value()) {\n+    ASSERT(cached_byte_size_ >= size);\n+    cached_byte_size_.value() -= size;\n+  }\n+}\n+\n void HeaderMapImpl::copyFrom(const HeaderMap& header_map) {\n   header_map.iterate(\n       [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {\n@@ -359,10 +376,13 @@ void HeaderMapImpl::insertByKey(HeaderString&& key, HeaderString&& value) {\n     if (*ref_lookup_response.entry_ == nullptr) {\n       maybeCreateInline(ref_lookup_response.entry_, *ref_lookup_response.key_, std::move(value));\n     } else {\n-      appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());\n+      const uint64_t added_size =\n+          appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());\n+      addSize(added_size);\n       value.clear();\n     }\n   } else {\n+    addSize(key.size() + value.size());\n     std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));\n     i->entry_ = i;\n   }\n@@ -373,7 +393,8 @@ void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {\n   // the existing value.\n   auto* entry = getExistingInline(key.getStringView());\n   if (entry != nullptr) {\n-    appendToHeader(entry->value(), value.getStringView());\n+    const uint64_t added_size = appendToHeader(entry->value(), value.getStringView());\n+    addSize(added_size);\n     key.clear();\n     value.clear();\n   } else {\n@@ -408,7 +429,8 @@ void HeaderMapImpl::addCopy(const LowerCaseString& key, uint64_t value) {\n   if (entry != nullptr) {\n     char buf[32];\n     StringUtil::itoa(buf, sizeof(buf), value);\n-    appendToHeader(entry->value(), buf);\n+    const uint64_t added_size = appendToHeader(entry->value(), buf);\n+    addSize(added_size);\n     return;\n   }\n   HeaderString new_key;\n@@ -423,7 +445,8 @@ void HeaderMapImpl::addCopy(const LowerCaseString& key, uint64_t value) {\n void HeaderMapImpl::addCopy(const LowerCaseString& key, const std::string& value) {\n   auto* entry = getExistingInline(key.get());\n   if (entry != nullptr) {\n-    appendToHeader(entry->value(), value);\n+    const uint64_t added_size = appendToHeader(entry->value(), value);\n+    addSize(added_size);\n     return;\n   }\n   HeaderString new_key;\n@@ -451,13 +474,24 @@ void HeaderMapImpl::setReferenceKey(const LowerCaseString& key, const std::strin\n   ASSERT(new_value.empty()); // NOLINT(bugprone-use-after-move)\n }\n \n-uint64_t HeaderMapImpl::byteSize() const {\n+absl::optional<uint64_t> HeaderMapImpl::byteSize() const { return cached_byte_size_; }\n+\n+uint64_t HeaderMapImpl::refreshByteSize() {\n+  if (!cached_byte_size_.has_value()) {\n+    // In this case, the cached byte size is not valid, and the byte size is computed via an\n+    // iteration over the HeaderMap. The cached byte size is updated.\n+    cached_byte_size_ = byteSizeInternal();\n+  }\n+  return cached_byte_size_.value();\n+}\n+\n+uint64_t HeaderMapImpl::byteSizeInternal() const {\n+  // Computes the total byte size by summing the byte size of the keys and values.\n   uint64_t byte_size = 0;\n   for (const HeaderEntryImpl& header : headers_) {\n     byte_size += header.key().size();\n     byte_size += header.value().size();\n   }\n-\n   return byte_size;\n }\n \n@@ -474,6 +508,7 @@ const HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) const {\n HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {\n   for (HeaderEntryImpl& header : headers_) {\n     if (header.key() == key.get().c_str()) {\n+      cached_byte_size_.reset();\n       return &header;\n     }\n   }\n@@ -528,6 +563,7 @@ void HeaderMapImpl::remove(const LowerCaseString& key) {\n   } else {\n     for (auto i = headers_.begin(); i != headers_.end();) {\n       if (i->key() == key.get().c_str()) {\n+        subtractSize(i->key().size() + i->value().size());\n         i = headers_.erase(i);\n       } else {\n         ++i;\n@@ -537,7 +573,7 @@ void HeaderMapImpl::remove(const LowerCaseString& key) {\n }\n \n void HeaderMapImpl::removePrefix(const LowerCaseString& prefix) {\n-  headers_.remove_if([&](const HeaderEntryImpl& entry) {\n+  headers_.remove_if([&prefix, this](const HeaderEntryImpl& entry) {\n     bool to_remove = absl::StartsWith(entry.key().getStringView(), prefix.get());\n     if (to_remove) {\n       // If this header should be removed, make sure any references in the\n@@ -546,8 +582,13 @@ void HeaderMapImpl::removePrefix(const LowerCaseString& prefix) {\n       if (cb) {\n         StaticLookupResponse ref_lookup_response = cb(*this);\n         if (ref_lookup_response.entry_) {\n+          const uint32_t key_value_size = (*ref_lookup_response.entry_)->key().size() +\n+                                          (*ref_lookup_response.entry_)->value().size();\n+          subtractSize(key_value_size);\n           *ref_lookup_response.entry_ = nullptr;\n         }\n+      } else {\n+        subtractSize(entry.key().size() + entry.value().size());\n       }\n     }\n     return to_remove;\n@@ -570,6 +611,7 @@ void HeaderMapImpl::dumpState(std::ostream& os, int indent_level) const {\n \n HeaderMapImpl::HeaderEntryImpl& HeaderMapImpl::maybeCreateInline(HeaderEntryImpl** entry,\n                                                                  const LowerCaseString& key) {\n+  cached_byte_size_.reset();\n   if (*entry) {\n     return **entry;\n   }\n@@ -588,6 +630,7 @@ HeaderMapImpl::HeaderEntryImpl& HeaderMapImpl::maybeCreateInline(HeaderEntryImpl\n     return **entry;\n   }\n \n+  addSize(key.get().size() + value.size());\n   std::list<HeaderEntryImpl>::iterator i = headers_.insert(key, std::move(value));\n   i->entry_ = i;\n   *entry = &(*i);\n@@ -609,6 +652,8 @@ void HeaderMapImpl::removeInline(HeaderEntryImpl** ptr_to_entry) {\n   }\n \n   HeaderEntryImpl* entry = *ptr_to_entry;\n+  const uint64_t size_to_subtract = entry->entry_->key().size() + entry->entry_->value().size();\n+  subtractSize(size_to_subtract);\n   *ptr_to_entry = nullptr;\n   headers_.erase(entry->entry_);\n }"
        },
        {
          "filename": "source/common/http/header_map_impl.h",
          "status": "modified",
          "additions": 20,
          "deletions": 3,
          "patch": "@@ -16,12 +16,21 @@ namespace Http {\n \n /**\n  * These are definitions of all of the inline header access functions described inside header_map.h\n+ *\n+ * When a non-const reference or pointer to a HeaderEntry is returned, the internal byte size count\n+ * will be cleared, since HeaderMap will no longer be able to accurately update the size of that\n+ * HeaderEntry.\n+ * TODO(asraa): Remove functions with a non-const HeaderEntry return value.\n  */\n #define DEFINE_INLINE_HEADER_FUNCS(name)                                                           \\\n public:                                                                                            \\\n   const HeaderEntry* name() const override { return inline_headers_.name##_; }                     \\\n-  HeaderEntry* name() override { return inline_headers_.name##_; }                                 \\\n+  HeaderEntry* name() override {                                                                   \\\n+    cached_byte_size_.reset();                                                                     \\\n+    return inline_headers_.name##_;                                                                \\\n+  }                                                                                                \\\n   HeaderEntry& insert##name() override {                                                           \\\n+    cached_byte_size_.reset();                                                                     \\\n     return maybeCreateInline(&inline_headers_.name##_, Headers::get().name);                       \\\n   }                                                                                                \\\n   void remove##name() override { removeInline(&inline_headers_.name##_); }\n@@ -43,7 +52,7 @@ class HeaderMapImpl : public HeaderMap, NonCopyable {\n    * @param header the header to append to.\n    * @param data to append to the header.\n    */\n-  static void appendToHeader(HeaderString& header, absl::string_view data);\n+  static uint64_t appendToHeader(HeaderString& header, absl::string_view data);\n \n   HeaderMapImpl();\n   explicit HeaderMapImpl(\n@@ -71,7 +80,9 @@ class HeaderMapImpl : public HeaderMap, NonCopyable {\n   void addCopy(const LowerCaseString& key, const std::string& value) override;\n   void setReference(const LowerCaseString& key, const std::string& value) override;\n   void setReferenceKey(const LowerCaseString& key, const std::string& value) override;\n-  uint64_t byteSize() const override;\n+  absl::optional<uint64_t> byteSize() const override;\n+  uint64_t refreshByteSize() override;\n+  uint64_t byteSizeInternal() const override;\n   const HeaderEntry* get(const LowerCaseString& key) const override;\n   HeaderEntry* get(const LowerCaseString& key) override;\n   void iterate(ConstIterateCb cb, void* context) const override;\n@@ -195,10 +206,16 @@ class HeaderMapImpl : public HeaderMap, NonCopyable {\n   HeaderEntryImpl* getExistingInline(absl::string_view key);\n \n   void removeInline(HeaderEntryImpl** entry);\n+  void addSize(uint64_t size);\n+  void subtractSize(uint64_t size);\n \n   AllInlineHeaders inline_headers_;\n   HeaderList headers_;\n \n+  // When present, this holds the internal byte size of the HeaderMap. The value is removed once an\n+  // inline header entry is accessed and updated when refreshByteSize() is called.\n+  absl::optional<uint64_t> cached_byte_size_ = 0;\n+\n   ALL_INLINE_HEADERS(DEFINE_INLINE_HEADER_FUNCS)\n };\n "
        },
        {
          "filename": "source/common/http/http1/codec_impl.cc",
          "status": "modified",
          "additions": 8,
          "deletions": 2,
          "patch": "@@ -460,8 +460,10 @@ void ConnectionImpl::onHeaderValue(const char* data, size_t length) {\n   header_parsing_state_ = HeaderParsingState::Value;\n   current_header_value_.append(data, length);\n \n-  const uint32_t total =\n-      current_header_field_.size() + current_header_value_.size() + current_header_map_->byteSize();\n+  // Verify that the cached value in byte size exists.\n+  ASSERT(current_header_map_->byteSize().has_value());\n+  const uint32_t total = current_header_field_.size() + current_header_value_.size() +\n+                         current_header_map_->byteSize().value();\n   if (total > (max_request_headers_kb_ * 1024)) {\n     error_code_ = Http::Code::RequestHeaderFieldsTooLarge;\n     sendProtocolError();\n@@ -472,6 +474,10 @@ void ConnectionImpl::onHeaderValue(const char* data, size_t length) {\n int ConnectionImpl::onHeadersCompleteBase() {\n   ENVOY_CONN_LOG(trace, \"headers complete\", connection_);\n   completeLastHeader();\n+  // Validate that the completed HeaderMap's cached byte size exists and is correct.\n+  // This assert iterates over the HeaderMap.\n+  ASSERT(current_header_map_->byteSize().has_value() &&\n+         current_header_map_->byteSize() == current_header_map_->byteSizeInternal());\n   if (!(parser_.http_major == 1 && parser_.http_minor == 1)) {\n     // This is not necessarily true, but it's good enough since higher layers only care if this is\n     // HTTP/1.1 or not."
        },
        {
          "filename": "source/common/http/http2/codec_impl.cc",
          "status": "modified",
          "additions": 13,
          "deletions": 2,
          "patch": "@@ -509,6 +509,10 @@ int ConnectionImpl::onFrameReceived(const nghttp2_frame* frame) {\n \n   switch (frame->hd.type) {\n   case NGHTTP2_HEADERS: {\n+    // Verify that the final HeaderMap's byte size is under the limit before decoding headers.\n+    // This assert iterates over the HeaderMap.\n+    ASSERT(stream->headers_->byteSize().has_value() &&\n+           stream->headers_->byteSize().value() == stream->headers_->byteSizeInternal());\n     stream->remote_end_stream_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;\n     if (!stream->cookies_.empty()) {\n       HeaderString key(Headers::get().Cookie);\n@@ -620,6 +624,12 @@ int ConnectionImpl::onFrameSend(const nghttp2_frame* frame) {\n   case NGHTTP2_HEADERS:\n   case NGHTTP2_DATA: {\n     StreamImpl* stream = getStream(frame->hd.stream_id);\n+    if (stream->headers_) {\n+      // Verify that the final HeaderMap's byte size is under the limit before sending frames.\n+      // This assert iterates over the HeaderMap.\n+      ASSERT(stream->headers_->byteSize().has_value() &&\n+             stream->headers_->byteSize().value() == stream->headers_->byteSizeInternal());\n+    }\n     stream->local_end_stream_sent_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;\n     break;\n   }\n@@ -808,9 +818,10 @@ int ConnectionImpl::saveHeader(const nghttp2_frame* frame, HeaderString&& name,\n     stats_.headers_cb_no_stream_.inc();\n     return 0;\n   }\n-\n   stream->saveHeader(std::move(name), std::move(value));\n-  if (stream->headers_->byteSize() > max_request_headers_kb_ * 1024) {\n+  // Verify that the cached value in byte size exists.\n+  ASSERT(stream->headers_->byteSize().has_value());\n+  if (stream->headers_->byteSize().value() > max_request_headers_kb_ * 1024) {\n     // This will cause the library to reset/close the stream.\n     stats_.header_overflow_.inc();\n     return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;"
        },
        {
          "filename": "source/common/router/router.cc",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -1398,6 +1398,15 @@ Filter::UpstreamRequest::~UpstreamRequest() {\n \n   stream_info_.setUpstreamTiming(upstream_timing_);\n   stream_info_.onRequestComplete();\n+  // Prior to logging, refresh the byte size of the HeaderMaps.\n+  // TODO(asraa): Remove this when entries in HeaderMap can no longer be modified by reference and\n+  // HeaderMap holds an accurate internal byte size count.\n+  if (upstream_headers_ != nullptr) {\n+    upstream_headers_->refreshByteSize();\n+  }\n+  if (upstream_trailers_ != nullptr) {\n+    upstream_trailers_->refreshByteSize();\n+  }\n   for (const auto& upstream_log : parent_.config_.upstream_logs_) {\n     upstream_log->log(parent_.downstream_headers_, upstream_headers_.get(),\n                       upstream_trailers_.get(), stream_info_);"
        },
        {
          "filename": "source/extensions/access_loggers/common/access_log_base.h",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -27,6 +27,11 @@ class ImplBase : public AccessLog::Instance {\n \n   /**\n    * Log a completed request if the underlying AccessLog `filter_` allows it.\n+   *\n+   * Prior to logging, call refreshByteSize() on HeaderMaps to ensure that an accurate byte size\n+   * count is logged.\n+   * TODO(asraa): Remove refreshByteSize() requirement when entries in HeaderMap can no longer be\n+   * modified by reference and HeaderMap holds an accurate internal byte size count.\n    */\n   void log(const Http::HeaderMap* request_headers, const Http::HeaderMap* response_headers,\n            const Http::HeaderMap* response_trailers,"
        },
        {
          "filename": "source/extensions/access_loggers/grpc/http_grpc_access_log_impl.cc",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -95,7 +95,7 @@ void HttpGrpcAccessLog::emitLog(const Http::HeaderMap& request_headers,\n     request_properties->set_original_path(\n         std::string(request_headers.EnvoyOriginalPath()->value().getStringView()));\n   }\n-  request_properties->set_request_headers_bytes(request_headers.byteSize());\n+  request_properties->set_request_headers_bytes(request_headers.byteSize().value());\n   request_properties->set_request_body_bytes(stream_info.bytesReceived());\n   if (request_headers.Method() != nullptr) {\n     envoy::api::v2::core::RequestMethod method =\n@@ -123,7 +123,7 @@ void HttpGrpcAccessLog::emitLog(const Http::HeaderMap& request_headers,\n   if (stream_info.responseCodeDetails()) {\n     response_properties->set_response_code_details(stream_info.responseCodeDetails().value());\n   }\n-  response_properties->set_response_headers_bytes(response_headers.byteSize());\n+  response_properties->set_response_headers_bytes(response_headers.byteSize().value());\n   response_properties->set_response_body_bytes(stream_info.bytesSent());\n   if (!response_headers_to_log_.empty()) {\n     auto* logged_headers = response_properties->mutable_response_headers();"
        },
        {
          "filename": "source/extensions/filters/common/expr/context.cc",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -79,7 +79,7 @@ absl::optional<CelValue> RequestWrapper::operator[](CelValue key) const {\n     } else if (value == UserAgent) {\n       return convertHeaderEntry(headers_.value_->UserAgent());\n     } else if (value == TotalSize) {\n-      return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize());\n+      return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize().value());\n     }\n   }\n   return {};"
        },
        {
          "filename": "source/extensions/filters/http/rbac/rbac_filter.cc",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -76,6 +76,10 @@ Http::FilterHeadersStatus RoleBasedAccessControlFilter::decodeHeaders(Http::Head\n   if (shadow_engine != nullptr) {\n     std::string shadow_resp_code =\n         Filters::Common::RBAC::DynamicMetadataKeysSingleton::get().EngineResultAllowed;\n+    // Refresh headers byte size before checking if allowed.\n+    // TODO(asraa): Remove this when entries in HeaderMap can no longer be modified by reference and\n+    // HeaderMap holds an accurate internal byte size count.\n+    headers.refreshByteSize();\n     if (shadow_engine->allowed(*callbacks_->connection(), headers, callbacks_->streamInfo(),\n                                &effective_policy_id)) {\n       ENVOY_LOG(debug, \"shadow allowed\");\n@@ -105,6 +109,10 @@ Http::FilterHeadersStatus RoleBasedAccessControlFilter::decodeHeaders(Http::Head\n   const auto engine =\n       config_->engine(callbacks_->route(), Filters::Common::RBAC::EnforcementMode::Enforced);\n   if (engine != nullptr) {\n+    // Refresh headers byte size before checking if allowed.\n+    // TODO(asraa): Remove this when entries in HeaderMap can no longer be modified by reference and\n+    // HeaderMap holds an accurate internal byte size count.\n+    headers.refreshByteSize();\n     if (engine->allowed(*callbacks_->connection(), headers, callbacks_->streamInfo(), nullptr)) {\n       ENVOY_LOG(debug, \"enforced allowed\");\n       config_->stats().allowed_.inc();"
        },
        {
          "filename": "test/common/http/conn_manager_impl_test.cc",
          "status": "modified",
          "additions": 0,
          "deletions": 45,
          "patch": "@@ -4409,51 +4409,6 @@ TEST_F(HttpConnectionManagerImplTest, DisableKeepAliveWhenOverloaded) {\n   EXPECT_EQ(1U, stats_.named_.downstream_cx_overload_disable_keepalive_.value());\n }\n \n-TEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersRejected) {\n-  setup(false, \"\");\n-\n-  std::string response_code;\n-  std::string response_body;\n-  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n-    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n-    HeaderMapPtr headers{\n-        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n-    headers->addCopy(LowerCaseString(\"Foo\"), std::string(60 * 1024, 'a'));\n-\n-    EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n-        .WillOnce(Invoke([&response_code](const HeaderMap& headers, bool) -> void {\n-          response_code = std::string(headers.Status()->value().getStringView());\n-        }));\n-    decoder->decodeHeaders(std::move(headers), true);\n-    conn_manager_->newStream(response_encoder_);\n-  }));\n-\n-  Buffer::OwnedImpl fake_input(\"1234\");\n-  conn_manager_->onData(fake_input, false); // kick off request\n-\n-  EXPECT_EQ(\"431\", response_code);\n-  EXPECT_EQ(\"\", response_body);\n-}\n-\n-TEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersAcceptedIfConfigured) {\n-  max_request_headers_kb_ = 62;\n-  setup(false, \"\");\n-\n-  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n-    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n-    HeaderMapPtr headers{\n-        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n-    headers->addCopy(LowerCaseString(\"Foo\"), std::string(60 * 1024, 'a'));\n-\n-    EXPECT_CALL(response_encoder_, encodeHeaders(_, _)).Times(0);\n-    decoder->decodeHeaders(std::move(headers), true);\n-    conn_manager_->newStream(response_encoder_);\n-  }));\n-\n-  Buffer::OwnedImpl fake_input(\"1234\");\n-  conn_manager_->onData(fake_input, false); // kick off request\n-}\n-\n TEST_F(HttpConnectionManagerImplTest, TestStopAllIterationAndBufferOnDecodingPathFirstFilter) {\n   setup(false, \"envoy-custom-server\", false);\n   setUpEncoderAndDecoder(true, true);"
        },
        {
          "filename": "test/common/http/header_map_impl_speed_test.cc",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -104,7 +104,7 @@ static void HeaderMapImplGetByteSize(benchmark::State& state) {\n   addDummyHeaders(headers, state.range(0));\n   uint64_t size = 0;\n   for (auto _ : state) {\n-    size += headers.byteSize();\n+    size += headers.byteSize().value();\n   }\n   benchmark::DoNotOptimize(size);\n }"
        },
        {
          "filename": "test/common/http/header_map_impl_test.cc",
          "status": "modified",
          "additions": 51,
          "deletions": 0,
          "patch": "@@ -366,6 +366,7 @@ TEST(HeaderMapImplTest, InlineInsert) {\n   HeaderMapImpl headers;\n   EXPECT_TRUE(headers.empty());\n   EXPECT_EQ(0, headers.size());\n+  EXPECT_EQ(headers.byteSize().value(), 0);\n   EXPECT_EQ(nullptr, headers.Host());\n   headers.insertHost().value(std::string(\"hello\"));\n   EXPECT_FALSE(headers.empty());\n@@ -375,6 +376,19 @@ TEST(HeaderMapImplTest, InlineInsert) {\n   EXPECT_EQ(\"hello\", headers.get(Headers::get().Host)->value().getStringView());\n }\n \n+// Utility function for testing byteSize() against a manual byte count.\n+uint64_t countBytesForTest(const HeaderMapImpl& headers) {\n+  uint64_t byte_size = 0;\n+  headers.iterate(\n+      [](const Http::HeaderEntry& header, void* context) -> Http::HeaderMap::Iterate {\n+        auto* byte_size = static_cast<uint64_t*>(context);\n+        *byte_size += header.key().getStringView().size() + header.value().getStringView().size();\n+        return Http::HeaderMap::Iterate::Continue;\n+      },\n+      &byte_size);\n+  return byte_size;\n+}\n+\n TEST(HeaderMapImplTest, MoveIntoInline) {\n   HeaderMapImpl headers;\n   HeaderString key;\n@@ -392,6 +406,7 @@ TEST(HeaderMapImplTest, MoveIntoInline) {\n   headers.addViaMove(std::move(key2), std::move(value2));\n   EXPECT_EQ(\"cache-control\", headers.CacheControl()->key().getStringView());\n   EXPECT_EQ(\"hello,there\", headers.CacheControl()->value().getStringView());\n+  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n }\n \n TEST(HeaderMapImplTest, Remove) {\n@@ -401,6 +416,7 @@ TEST(HeaderMapImplTest, Remove) {\n   LowerCaseString static_key(\"hello\");\n   std::string ref_value(\"value\");\n   headers.addReference(static_key, ref_value);\n+  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n   EXPECT_EQ(\"value\", headers.get(static_key)->value().getStringView());\n   EXPECT_EQ(HeaderString::Type::Reference, headers.get(static_key)->value().type());\n   EXPECT_EQ(1UL, headers.size());\n@@ -409,26 +425,31 @@ TEST(HeaderMapImplTest, Remove) {\n   EXPECT_EQ(nullptr, headers.get(static_key));\n   EXPECT_EQ(0UL, headers.size());\n   EXPECT_TRUE(headers.empty());\n+  EXPECT_EQ(headers.refreshByteSize(), 0);\n \n   // Add and remove by inline.\n   headers.insertContentLength().value(5);\n+  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n   EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());\n   EXPECT_EQ(1UL, headers.size());\n   EXPECT_FALSE(headers.empty());\n   headers.removeContentLength();\n   EXPECT_EQ(nullptr, headers.ContentLength());\n   EXPECT_EQ(0UL, headers.size());\n   EXPECT_TRUE(headers.empty());\n+  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n \n   // Add inline and remove by name.\n   headers.insertContentLength().value(5);\n   EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());\n   EXPECT_EQ(1UL, headers.size());\n   EXPECT_FALSE(headers.empty());\n+  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n   headers.remove(Headers::get().ContentLength);\n   EXPECT_EQ(nullptr, headers.ContentLength());\n   EXPECT_EQ(0UL, headers.size());\n   EXPECT_TRUE(headers.empty());\n+  EXPECT_EQ(headers.refreshByteSize(), 0);\n }\n \n TEST(HeaderMapImplTest, RemoveRegex) {\n@@ -446,17 +467,21 @@ TEST(HeaderMapImplTest, RemoveRegex) {\n   headers.addReference(key3, \"value\");\n   headers.addReference(key4, \"value\");\n   headers.addReference(key5, \"value\");\n+  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n \n   // Test removing the first header, middle headers, and the end header.\n   headers.removePrefix(LowerCaseString(\"x-prefix-\"));\n+  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n   EXPECT_EQ(nullptr, headers.get(key1));\n   EXPECT_NE(nullptr, headers.get(key2));\n   EXPECT_EQ(nullptr, headers.get(key3));\n   EXPECT_NE(nullptr, headers.get(key4));\n   EXPECT_EQ(nullptr, headers.get(key5));\n \n   // Remove all headers.\n+  headers.refreshByteSize();\n   headers.removePrefix(LowerCaseString(\"\"));\n+  EXPECT_EQ(headers.byteSize().value(), 0);\n   EXPECT_EQ(nullptr, headers.get(key2));\n   EXPECT_EQ(nullptr, headers.get(key4));\n \n@@ -465,8 +490,10 @@ TEST(HeaderMapImplTest, RemoveRegex) {\n   EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());\n   EXPECT_EQ(1UL, headers.size());\n   EXPECT_FALSE(headers.empty());\n+  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n   headers.removePrefix(LowerCaseString(\"content\"));\n   EXPECT_EQ(nullptr, headers.ContentLength());\n+  EXPECT_EQ(headers.refreshByteSize(), 0);\n }\n \n TEST(HeaderMapImplTest, SetRemovesAllValues) {\n@@ -484,6 +511,7 @@ TEST(HeaderMapImplTest, SetRemovesAllValues) {\n   headers.addReference(key2, ref_value2);\n   headers.addReference(key1, ref_value3);\n   headers.addReference(key1, ref_value4);\n+  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n \n   using MockCb = testing::MockFunction<void(const std::string&, const std::string&)>;\n \n@@ -531,20 +559,23 @@ TEST(HeaderMapImplTest, DoubleInlineAdd) {\n     const std::string bar(\"bar\");\n     headers.addReference(Headers::get().ContentLength, foo);\n     headers.addReference(Headers::get().ContentLength, bar);\n+    EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n     EXPECT_EQ(\"foo,bar\", headers.ContentLength()->value().getStringView());\n     EXPECT_EQ(1UL, headers.size());\n   }\n   {\n     HeaderMapImpl headers;\n     headers.addReferenceKey(Headers::get().ContentLength, \"foo\");\n     headers.addReferenceKey(Headers::get().ContentLength, \"bar\");\n+    EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n     EXPECT_EQ(\"foo,bar\", headers.ContentLength()->value().getStringView());\n     EXPECT_EQ(1UL, headers.size());\n   }\n   {\n     HeaderMapImpl headers;\n     headers.addReferenceKey(Headers::get().ContentLength, 5);\n     headers.addReferenceKey(Headers::get().ContentLength, 6);\n+    EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n     EXPECT_EQ(\"5,6\", headers.ContentLength()->value().getStringView());\n     EXPECT_EQ(1UL, headers.size());\n   }\n@@ -553,6 +584,7 @@ TEST(HeaderMapImplTest, DoubleInlineAdd) {\n     const std::string foo(\"foo\");\n     headers.addReference(Headers::get().ContentLength, foo);\n     headers.addReferenceKey(Headers::get().ContentLength, 6);\n+    EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n     EXPECT_EQ(\"foo,6\", headers.ContentLength()->value().getStringView());\n     EXPECT_EQ(1UL, headers.size());\n   }\n@@ -568,6 +600,7 @@ TEST(HeaderMapImplTest, DoubleCookieAdd) {\n   headers.addReference(set_cookie, foo);\n   headers.addReference(set_cookie, bar);\n   EXPECT_EQ(2UL, headers.size());\n+  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n \n   std::vector<absl::string_view> out;\n   Http::HeaderUtility::getAllOfHeader(headers, \"set-cookie\", out);\n@@ -580,6 +613,7 @@ TEST(HeaderMapImplTest, DoubleInlineSet) {\n   HeaderMapImpl headers;\n   headers.setReferenceKey(Headers::get().ContentType, \"blah\");\n   headers.setReferenceKey(Headers::get().ContentType, \"text/html\");\n+  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n   EXPECT_EQ(\"text/html\", headers.ContentType()->value().getStringView());\n   EXPECT_EQ(1UL, headers.size());\n }\n@@ -588,6 +622,7 @@ TEST(HeaderMapImplTest, AddReferenceKey) {\n   HeaderMapImpl headers;\n   LowerCaseString foo(\"hello\");\n   headers.addReferenceKey(foo, \"world\");\n+  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n   EXPECT_NE(\"world\", headers.get(foo)->value().getStringView().data());\n   EXPECT_EQ(\"world\", headers.get(foo)->value().getStringView());\n }\n@@ -596,10 +631,13 @@ TEST(HeaderMapImplTest, SetReferenceKey) {\n   HeaderMapImpl headers;\n   LowerCaseString foo(\"hello\");\n   headers.setReferenceKey(foo, \"world\");\n+  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n   EXPECT_NE(\"world\", headers.get(foo)->value().getStringView().data());\n   EXPECT_EQ(\"world\", headers.get(foo)->value().getStringView());\n+  headers.refreshByteSize();\n \n   headers.setReferenceKey(foo, \"monde\");\n+  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n   EXPECT_NE(\"monde\", headers.get(foo)->value().getStringView().data());\n   EXPECT_EQ(\"monde\", headers.get(foo)->value().getStringView());\n }\n@@ -610,6 +648,7 @@ TEST(HeaderMapImplTest, AddCopy) {\n   // Start with a string value.\n   std::unique_ptr<LowerCaseString> lcKeyPtr(new LowerCaseString(\"hello\"));\n   headers.addCopy(*lcKeyPtr, \"world\");\n+  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n \n   const HeaderString& value = headers.get(*lcKeyPtr)->value();\n \n@@ -629,14 +668,19 @@ TEST(HeaderMapImplTest, AddCopy) {\n   //\n   // addReferenceKey and addCopy can both add multiple instances of a\n   // given header, so we need to delete the old \"hello\" header.\n+  // Test that removing will return 0 byte size.\n+  headers.refreshByteSize();\n   headers.remove(LowerCaseString(\"hello\"));\n+  EXPECT_EQ(headers.byteSize().value(), 0);\n \n   // Build \"hello\" with string concatenation to make it unlikely that the\n   // compiler is just reusing the same string constant for everything.\n   lcKeyPtr = std::make_unique<LowerCaseString>(std::string(\"he\") + \"llo\");\n   EXPECT_STREQ(\"hello\", lcKeyPtr->get().c_str());\n \n+  headers.refreshByteSize();\n   headers.addCopy(*lcKeyPtr, 42);\n+  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n \n   const HeaderString& value3 = headers.get(*lcKeyPtr)->value();\n \n@@ -662,15 +706,20 @@ TEST(HeaderMapImplTest, AddCopy) {\n   headers.addCopy(cache_control, \"max-age=1345\");\n   EXPECT_EQ(\"max-age=1345\", headers.get(cache_control)->value().getStringView());\n   EXPECT_EQ(\"max-age=1345\", headers.CacheControl()->value().getStringView());\n+  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n   headers.addCopy(cache_control, \"public\");\n+  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n   EXPECT_EQ(\"max-age=1345,public\", headers.get(cache_control)->value().getStringView());\n   headers.addCopy(cache_control, \"\");\n+  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n   EXPECT_EQ(\"max-age=1345,public\", headers.get(cache_control)->value().getStringView());\n   headers.addCopy(cache_control, 123);\n+  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n   EXPECT_EQ(\"max-age=1345,public,123\", headers.get(cache_control)->value().getStringView());\n   headers.addCopy(cache_control, std::numeric_limits<uint64_t>::max());\n   EXPECT_EQ(\"max-age=1345,public,123,18446744073709551615\",\n             headers.get(cache_control)->value().getStringView());\n+  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n }\n \n TEST(HeaderMapImplTest, Equality) {\n@@ -690,6 +739,7 @@ TEST(HeaderMapImplTest, LargeCharInHeader) {\n   LowerCaseString static_key(\"\\x90hello\");\n   std::string ref_value(\"value\");\n   headers.addReference(static_key, ref_value);\n+  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n   EXPECT_EQ(\"value\", headers.get(static_key)->value().getStringView());\n }\n \n@@ -844,6 +894,7 @@ TEST(HeaderMapImplTest, PseudoHeaderOrder) {\n   {\n     LowerCaseString foo(\"hello\");\n     Http::TestHeaderMapImpl headers{};\n+    EXPECT_EQ(headers.refreshByteSize(), 0);\n     EXPECT_EQ(0UL, headers.size());\n     EXPECT_TRUE(headers.empty());\n "
        },
        {
          "filename": "test/common/http/http2/codec_impl_test.cc",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -1089,17 +1089,19 @@ TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtLimitAccepted) {\n \n   TestHeaderMapImpl request_headers;\n   HttpTestUtility::addDefaultHeaders(request_headers);\n+  // Refresh byte size after adding default inline headers by reference.\n+  request_headers.refreshByteSize();\n   std::string key = \"big\";\n   uint32_t head_room = 77;\n   uint32_t long_string_length =\n-      codec_limit_kb * 1024 - request_headers.byteSize() - key.length() - head_room;\n+      codec_limit_kb * 1024 - request_headers.byteSize().value() - key.length() - head_room;\n   std::string long_string = std::string(long_string_length, 'q');\n   request_headers.addCopy(key, long_string);\n \n   // The amount of data sent to the codec is not equivalent to the size of the\n   // request headers that Envoy computes, as the codec limits based on the\n   // entire http2 frame. The exact head room needed (76) was found through iteration.\n-  ASSERT_EQ(request_headers.byteSize() + head_room, codec_limit_kb * 1024);\n+  ASSERT_EQ(request_headers.byteSize().value() + head_room, codec_limit_kb * 1024);\n \n   EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));\n   request_encoder_->encodeHeaders(request_headers, true);"
        },
        {
          "filename": "test/integration/http2_integration_test.cc",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -64,6 +64,8 @@ TEST_P(Http2IntegrationTest, Retry) { testRetry(); }\n \n TEST_P(Http2IntegrationTest, RetryAttemptCount) { testRetryAttemptCountHeader(); }\n \n+TEST_P(Http2IntegrationTest, LargeRequestTrailersRejected) { testLargeRequestTrailers(66, 60); }\n+\n static std::string response_metadata_filter = R\"EOF(\n name: response-metadata-filter\n config: {}"
        },
        {
          "filename": "test/integration/http_integration.cc",
          "status": "modified",
          "additions": 70,
          "deletions": 6,
          "patch": "@@ -260,7 +260,8 @@ void HttpIntegrationTest::setDownstreamProtocol(Http::CodecClient::Type downstre\n \n IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n     const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n-    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {\n+    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,\n+    std::chrono::milliseconds time) {\n   ASSERT(codec_client_ != nullptr);\n   // Send the request to Envoy.\n   IntegrationStreamDecoderPtr response;\n@@ -269,7 +270,7 @@ IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n   } else {\n     response = codec_client_->makeHeaderOnlyRequest(request_headers);\n   }\n-  waitForNextUpstreamRequest(upstream_index);\n+  waitForNextUpstreamRequest(upstream_index, time);\n   // Send response headers, and end_stream if there is no response body.\n   upstream_request_->encodeHeaders(response_headers, response_size == 0);\n   // Send any response data, with end_stream true.\n@@ -333,15 +334,16 @@ void HttpIntegrationTest::verifyResponse(IntegrationStreamDecoderPtr response,\n }\n \n uint64_t\n-HttpIntegrationTest::waitForNextUpstreamRequest(const std::vector<uint64_t>& upstream_indices) {\n+HttpIntegrationTest::waitForNextUpstreamRequest(const std::vector<uint64_t>& upstream_indices,\n+                                                std::chrono::milliseconds connection_wait_timeout) {\n   uint64_t upstream_with_request;\n   // If there is no upstream connection, wait for it to be established.\n   if (!fake_upstream_connection_) {\n \n     AssertionResult result = AssertionFailure();\n     for (auto upstream_index : upstream_indices) {\n       result = fake_upstreams_[upstream_index]->waitForHttpConnection(\n-          *dispatcher_, fake_upstream_connection_, TestUtility::DefaultTimeout,\n+          *dispatcher_, fake_upstream_connection_, connection_wait_timeout,\n           max_request_headers_kb_);\n       if (result) {\n         upstream_with_request = upstream_index;\n@@ -361,8 +363,9 @@ HttpIntegrationTest::waitForNextUpstreamRequest(const std::vector<uint64_t>& ups\n   return upstream_with_request;\n }\n \n-void HttpIntegrationTest::waitForNextUpstreamRequest(uint64_t upstream_index) {\n-  waitForNextUpstreamRequest(std::vector<uint64_t>({upstream_index}));\n+void HttpIntegrationTest::waitForNextUpstreamRequest(\n+    uint64_t upstream_index, std::chrono::milliseconds connection_wait_timeout) {\n+  waitForNextUpstreamRequest(std::vector<uint64_t>({upstream_index}), connection_wait_timeout);\n }\n \n void HttpIntegrationTest::checkSimpleRequestSuccess(uint64_t expected_request_size,\n@@ -916,6 +919,67 @@ void HttpIntegrationTest::testLargeRequestHeaders(uint32_t size, uint32_t max_si\n   }\n }\n \n+void HttpIntegrationTest::testLargeRequestTrailers(uint32_t size, uint32_t max_size) {\n+  // `size` parameter is the size of the trailer that will be added to the\n+  // request. The actual request byte size will exceed `size` due to keys\n+  // and other headers.\n+\n+  config_helper_.addConfigModifier(\n+      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n+          -> void { hcm.mutable_max_request_headers_kb()->set_value(max_size); });\n+  max_request_headers_kb_ = max_size;\n+  Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};\n+  request_trailers.addCopy(\"big\", std::string(size * 1024, 'a'));\n+\n+  initialize();\n+\n+  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n+  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n+\n+  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n+  request_encoder_ = &encoder_decoder.first;\n+  auto response = std::move(encoder_decoder.second);\n+  codec_client_->sendData(*request_encoder_, 10, false);\n+  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n+\n+  if (size >= max_size && downstream_protocol_ == Http::CodecClient::Type::HTTP2) {\n+    // For HTTP/2, expect a stream reset when the size of the trailers is larger than the maximum\n+    // limit.\n+    response->waitForReset();\n+    codec_client_->close();\n+    EXPECT_FALSE(response->complete());\n+\n+  } else {\n+    waitForNextUpstreamRequest();\n+    upstream_request_->encodeHeaders(default_response_headers_, true);\n+    response->waitForEndStream();\n+    EXPECT_TRUE(response->complete());\n+  }\n+}\n+\n+void HttpIntegrationTest::testManyRequestHeaders(std::chrono::milliseconds time) {\n+  config_helper_.addConfigModifier(\n+      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n+          -> void { hcm.mutable_max_request_headers_kb()->set_value(96); });\n+  max_request_headers_kb_ = 96;\n+\n+  Http::TestHeaderMapImpl big_headers{\n+      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n+\n+  for (int i = 0; i < 20000; i++) {\n+    big_headers.addCopy(std::to_string(i), std::string(0, 'a'));\n+  }\n+  initialize();\n+\n+  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n+\n+  auto response =\n+      sendRequestAndWaitForResponse(big_headers, 0, default_response_headers_, 0, 0, time);\n+\n+  EXPECT_TRUE(response->complete());\n+  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n+}\n+\n void HttpIntegrationTest::testDownstreamResetBeforeResponseComplete() {\n   initialize();\n   codec_client_ = makeHttpConnection(lookupPort(\"http\"));"
        },
        {
          "filename": "test/integration/http_integration.h",
          "status": "modified",
          "additions": 14,
          "deletions": 7,
          "patch": "@@ -122,18 +122,21 @@ class HttpIntegrationTest : public BaseIntegrationTest {\n   //\n   // Waits for the complete downstream response before returning.\n   // Requires |codec_client_| to be initialized.\n-  IntegrationStreamDecoderPtr\n-  sendRequestAndWaitForResponse(const Http::TestHeaderMapImpl& request_headers,\n-                                uint32_t request_body_size,\n-                                const Http::TestHeaderMapImpl& response_headers,\n-                                uint32_t response_body_size, int upstream_index = 0);\n+  IntegrationStreamDecoderPtr sendRequestAndWaitForResponse(\n+      const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n+      const Http::TestHeaderMapImpl& response_headers, uint32_t response_body_size,\n+      int upstream_index = 0, std::chrono::milliseconds time = TestUtility::DefaultTimeout);\n \n   // Wait for the end of stream on the next upstream stream on any of the provided fake upstreams.\n   // Sets fake_upstream_connection_ to the connection and upstream_request_ to stream.\n   // In cases where the upstream that will receive the request is not deterministic, a second\n   // upstream index may be provided, in which case both upstreams will be checked for requests.\n-  uint64_t waitForNextUpstreamRequest(const std::vector<uint64_t>& upstream_indices);\n-  void waitForNextUpstreamRequest(uint64_t upstream_index = 0);\n+  uint64_t waitForNextUpstreamRequest(\n+      const std::vector<uint64_t>& upstream_indices,\n+      std::chrono::milliseconds connection_wait_timeout = TestUtility::DefaultTimeout);\n+  void waitForNextUpstreamRequest(\n+      uint64_t upstream_index = 0,\n+      std::chrono::milliseconds connection_wait_timeout = TestUtility::DefaultTimeout);\n \n   // Close |codec_client_| and |fake_upstream_connection_| cleanly.\n   void cleanupUpstreamAndDownstream();\n@@ -185,7 +188,11 @@ class HttpIntegrationTest : public BaseIntegrationTest {\n   void testRouterUpstreamResponseBeforeRequestComplete();\n \n   void testTwoRequests(bool force_network_backup = false);\n+  void testLargeHeaders(Http::TestHeaderMapImpl request_headers,\n+                        Http::TestHeaderMapImpl request_trailers, uint32_t size, uint32_t max_size);\n   void testLargeRequestHeaders(uint32_t size, uint32_t max_size = 60);\n+  void testLargeRequestTrailers(uint32_t size, uint32_t max_size = 60);\n+  void testManyRequestHeaders(std::chrono::milliseconds time = TestUtility::DefaultTimeout);\n \n   void testAddEncodedTrailers();\n   void testRetry();"
        },
        {
          "filename": "test/integration/protocol_integration_test.cc",
          "status": "modified",
          "additions": 82,
          "deletions": 0,
          "patch": "@@ -576,6 +576,46 @@ TEST_P(DownstreamProtocolIntegrationTest, ValidZeroLengthContent) {\n   EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n }\n \n+// Validate that lots of tiny cookies doesn't cause a DoS (single cookie header).\n+TEST_P(DownstreamProtocolIntegrationTest, LargeCookieParsingConcatenated) {\n+  initialize();\n+\n+  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n+  Http::TestHeaderMapImpl request_headers{{\":method\", \"POST\"},\n+                                          {\":path\", \"/test/long/url\"},\n+                                          {\":scheme\", \"http\"},\n+                                          {\":authority\", \"host\"},\n+                                          {\"content-length\", \"0\"}};\n+  std::vector<std::string> cookie_pieces;\n+  for (int i = 0; i < 7000; i++) {\n+    cookie_pieces.push_back(fmt::sprintf(\"a%x=b\", i));\n+  }\n+  request_headers.addCopy(\"cookie\", absl::StrJoin(cookie_pieces, \"; \"));\n+  auto response = sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0);\n+\n+  ASSERT_TRUE(response->complete());\n+  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n+}\n+\n+// Validate that lots of tiny cookies doesn't cause a DoS (many cookie headers).\n+TEST_P(DownstreamProtocolIntegrationTest, LargeCookieParsingMany) {\n+  initialize();\n+\n+  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n+  Http::TestHeaderMapImpl request_headers{{\":method\", \"POST\"},\n+                                          {\":path\", \"/test/long/url\"},\n+                                          {\":scheme\", \"http\"},\n+                                          {\":authority\", \"host\"},\n+                                          {\"content-length\", \"0\"}};\n+  for (int i = 0; i < 2000; i++) {\n+    request_headers.addCopy(\"cookie\", fmt::sprintf(\"a%x=b\", i));\n+  }\n+  auto response = sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0);\n+\n+  ASSERT_TRUE(response->complete());\n+  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n+}\n+\n TEST_P(DownstreamProtocolIntegrationTest, InvalidContentLength) {\n   initialize();\n \n@@ -850,6 +890,48 @@ TEST_P(DownstreamProtocolIntegrationTest, LargeRequestHeadersAccepted) {\n   testLargeRequestHeaders(95, 96);\n }\n \n+TEST_P(DownstreamProtocolIntegrationTest, ManyRequestHeadersTimeout) {\n+  // Set timeout for 5 seconds, and ensure that a request with 20k+ headers can be sent.\n+  testManyRequestHeaders(std::chrono::milliseconds(5000));\n+}\n+\n+TEST_P(DownstreamProtocolIntegrationTest, LargeRequestTrailersAccepted) {\n+  testLargeRequestTrailers(60, 96);\n+}\n+\n+TEST_P(DownstreamProtocolIntegrationTest, LargeRequestTrailersRejected) {\n+  testLargeRequestTrailers(66, 60);\n+}\n+\n+TEST_P(DownstreamProtocolIntegrationTest, ManyTrailerHeaders) {\n+  config_helper_.addConfigModifier(\n+      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n+          -> void { hcm.mutable_max_request_headers_kb()->set_value(96); });\n+\n+  Http::TestHeaderMapImpl request_trailers{};\n+  for (int i = 0; i < 20000; i++) {\n+    request_trailers.addCopy(std::to_string(i), \"\");\n+  }\n+\n+  initialize();\n+  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n+  auto encoder_decoder =\n+      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n+                                                          {\":path\", \"/test/long/url\"},\n+                                                          {\":scheme\", \"http\"},\n+                                                          {\":authority\", \"host\"}});\n+  request_encoder_ = &encoder_decoder.first;\n+  auto response = std::move(encoder_decoder.second);\n+  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n+  waitForNextUpstreamRequest();\n+  upstream_request_->encodeHeaders(default_response_headers_, true);\n+  response->waitForEndStream();\n+\n+  EXPECT_TRUE(upstream_request_->complete());\n+  EXPECT_TRUE(response->complete());\n+  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n+}\n+\n // Tests StopAllIterationAndBuffer. Verifies decode-headers-return-stop-all-filter calls decodeData\n // once after iteration is resumed.\n TEST_P(DownstreamProtocolIntegrationTest, testDecodeHeadersReturnsStopAll) {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 8,
        "unique_directories": 14,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7b20933ee263eb9aeaceee6bc309b80b997cbbb2",
            "date": "2025-01-14T14:13:49Z",
            "author_login": "phlax"
          },
          {
            "sha": "03cb8d59f80a2a75d9e1289c909e5979a79ace91",
            "date": "2025-01-13T06:31:54Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "3487b225f48717dd5a2babb5f921df4353633cee",
            "date": "2025-01-13T06:10:11Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "acdcfc6ac262ee4087a652532b93922550efb061",
            "date": "2025-01-10T07:01:57Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "02633ec5db8d6a3f24fa6752dff36b4fb5f0800e",
            "date": "2025-01-10T07:02:42Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "Upon receiving each incoming request header data, Envoy will iterate over existing request headers to verify that the total size of the headers stays below a maximum limit. The implementation in versions 1.10.0 through 1.11.1 for HTTP/1.x traffic and all versions of Envoy for HTTP/2 traffic had O(n^2) performance characteristics. A remote attacker may craft a request that stays below the maximum request header size but consists of many thousands of small headers to consume CPU and result in a denial-of-service attack.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2019-10-09T16:15:14.687",
    "last_modified": "2024-11-21T04:28:14.570",
    "fix_date": "2019-10-07T21:58:39Z"
  },
  "references": [
    {
      "url": "https://github.com/envoyproxy/envoy/commit/afc39bea36fd436e54262f150c009e8d72db5014",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/commits/master",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/issues/8520",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/commit/afc39bea36fd436e54262f150c009e8d72db5014",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/commits/master",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/issues/8520",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:59.946149",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "envoy",
    "owner": "envoyproxy",
    "created_at": "2016-08-08T15:07:24Z",
    "updated_at": "2025-01-14T12:22:22Z",
    "pushed_at": "2025-01-14T05:36:17Z",
    "size": 240648,
    "stars": 25321,
    "forks": 4848,
    "open_issues": 1639,
    "watchers": 25321,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C++": 48293036,
      "Starlark": 3105942,
      "Java": 1320095,
      "Python": 605206,
      "Assembly": 327095,
      "Kotlin": 309606,
      "Swift": 250537,
      "Shell": 229801,
      "Go": 183281,
      "Rust": 107190,
      "JavaScript": 66339,
      "C": 61597,
      "Objective-C++": 55490,
      "Objective-C": 48840,
      "Jinja": 47798,
      "Smarty": 3528,
      "CSS": 2927,
      "HTML": 1522,
      "Emacs Lisp": 966,
      "Dockerfile": 960,
      "Thrift": 748,
      "PureBasic": 472,
      "Batchfile": 439,
      "Makefile": 303
    },
    "commit_activity": {
      "total_commits_last_year": 3286,
      "avg_commits_per_week": 63.19230769230769,
      "days_active_last_year": 303
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:55:59.245540"
  }
}