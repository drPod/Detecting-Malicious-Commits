{
  "cve_id": "CVE-2019-15694",
  "github_data": {
    "repository": "TigerVNC/tigervnc",
    "fix_commit": "0943c006c7d900dfc0281639e992791d6c567438",
    "related_commits": [
      "0943c006c7d900dfc0281639e992791d6c567438",
      "0943c006c7d900dfc0281639e992791d6c567438"
    ],
    "patch_url": "https://github.com/TigerVNC/tigervnc/commit/0943c006c7d900dfc0281639e992791d6c567438.patch",
    "fix_commit_details": {
      "sha": "0943c006c7d900dfc0281639e992791d6c567438",
      "commit_date": "2019-09-23T09:00:17Z",
      "author": {
        "login": "CendioOssman",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Use size_t for lengths in stream objects",
        "length": 239,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 366,
        "additions": 184,
        "deletions": 182
      },
      "files": [
        {
          "filename": "common/rdr/FdInStream.cxx",
          "status": "modified",
          "additions": 10,
          "deletions": 10,
          "patch": "@@ -56,7 +56,7 @@ using namespace rdr;\n enum { DEFAULT_BUF_SIZE = 8192,\n        MIN_BULK_SIZE = 1024 };\n \n-FdInStream::FdInStream(int fd_, int timeoutms_, int bufSize_,\n+FdInStream::FdInStream(int fd_, int timeoutms_, size_t bufSize_,\n                        bool closeWhenDone_)\n   : fd(fd_), closeWhenDone(closeWhenDone_),\n     timeoutms(timeoutms_), blockCallback(0),\n@@ -67,7 +67,7 @@ FdInStream::FdInStream(int fd_, int timeoutms_, int bufSize_,\n }\n \n FdInStream::FdInStream(int fd_, FdInStreamBlockCallback* blockCallback_,\n-                       int bufSize_)\n+                       size_t bufSize_)\n   : fd(fd_), timeoutms(0), blockCallback(blockCallback_),\n     timing(false), timeWaitedIn100us(5), timedKbits(0),\n     bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n@@ -92,12 +92,12 @@ void FdInStream::setBlockCallback(FdInStreamBlockCallback* blockCallback_)\n   timeoutms = 0;\n }\n \n-int FdInStream::pos()\n+size_t FdInStream::pos()\n {\n   return offset + ptr - start;\n }\n \n-void FdInStream::readBytes(void* data, int length)\n+void FdInStream::readBytes(void* data, size_t length)\n {\n   if (length < MIN_BULK_SIZE) {\n     InStream::readBytes(data, length);\n@@ -106,7 +106,7 @@ void FdInStream::readBytes(void* data, int length)\n \n   U8* dataPtr = (U8*)data;\n \n-  int n = end - ptr;\n+  size_t n = end - ptr;\n   if (n > length) n = length;\n \n   memcpy(dataPtr, ptr, n);\n@@ -123,7 +123,7 @@ void FdInStream::readBytes(void* data, int length)\n }\n \n \n-int FdInStream::overrun(int itemSize, int nItems, bool wait)\n+size_t FdInStream::overrun(size_t itemSize, size_t nItems, bool wait)\n {\n   if (itemSize > bufSize)\n     throw Exception(\"FdInStream overrun: max itemSize exceeded\");\n@@ -135,7 +135,7 @@ int FdInStream::overrun(int itemSize, int nItems, bool wait)\n   end -= ptr - start;\n   ptr = start;\n \n-  int bytes_to_read;\n+  size_t bytes_to_read;\n   while (end < start + itemSize) {\n     bytes_to_read = start + bufSize - end;\n     if (!timing) {\n@@ -147,12 +147,12 @@ int FdInStream::overrun(int itemSize, int nItems, bool wait)\n       // bytes is ineffecient.\n       bytes_to_read = vncmin(bytes_to_read, vncmax(itemSize*nItems, 8));\n     }\n-    int n = readWithTimeoutOrCallback((U8*)end, bytes_to_read, wait);\n+    size_t n = readWithTimeoutOrCallback((U8*)end, bytes_to_read, wait);\n     if (n == 0) return 0;\n     end += n;\n   }\n \n-  if (itemSize * nItems > end - ptr)\n+  if (itemSize * nItems > (size_t)(end - ptr))\n     nItems = (end - ptr) / itemSize;\n \n   return nItems;\n@@ -171,7 +171,7 @@ int FdInStream::overrun(int itemSize, int nItems, bool wait)\n // returning EINTR.\n //\n \n-int FdInStream::readWithTimeoutOrCallback(void* buf, int len, bool wait)\n+size_t FdInStream::readWithTimeoutOrCallback(void* buf, size_t len, bool wait)\n {\n   struct timeval before, after;\n   if (timing)"
        },
        {
          "filename": "common/rdr/FdInStream.h",
          "status": "modified",
          "additions": 9,
          "deletions": 8,
          "patch": "@@ -37,27 +37,28 @@ namespace rdr {\n \n   public:\n \n-    FdInStream(int fd, int timeoutms=-1, int bufSize=0,\n+    FdInStream(int fd, int timeoutms=-1, size_t bufSize=0,\n                bool closeWhenDone_=false);\n-    FdInStream(int fd, FdInStreamBlockCallback* blockCallback, int bufSize=0);\n+    FdInStream(int fd, FdInStreamBlockCallback* blockCallback,\n+               size_t bufSize=0);\n     virtual ~FdInStream();\n \n     void setTimeout(int timeoutms);\n     void setBlockCallback(FdInStreamBlockCallback* blockCallback);\n     int getFd() { return fd; }\n-    int pos();\n-    void readBytes(void* data, int length);\n+    size_t pos();\n+    void readBytes(void* data, size_t length);\n \n     void startTiming();\n     void stopTiming();\n     unsigned int kbitsPerSecond();\n     unsigned int timeWaited() { return timeWaitedIn100us; }\n \n   protected:\n-    int overrun(int itemSize, int nItems, bool wait);\n+    size_t overrun(size_t itemSize, size_t nItems, bool wait);\n \n   private:\n-    int readWithTimeoutOrCallback(void* buf, int len, bool wait=true);\n+    size_t readWithTimeoutOrCallback(void* buf, size_t len, bool wait=true);\n \n     int fd;\n     bool closeWhenDone;\n@@ -68,8 +69,8 @@ namespace rdr {\n     unsigned int timeWaitedIn100us;\n     unsigned int timedKbits;\n \n-    int bufSize;\n-    int offset;\n+    size_t bufSize;\n+    size_t offset;\n     U8* start;\n   };\n "
        },
        {
          "filename": "common/rdr/FdOutStream.cxx",
          "status": "modified",
          "additions": 10,
          "deletions": 10,
          "patch": "@@ -51,7 +51,7 @@ using namespace rdr;\n \n enum { DEFAULT_BUF_SIZE = 16384 };\n \n-FdOutStream::FdOutStream(int fd_, bool blocking_, int timeoutms_, int bufSize_)\n+FdOutStream::FdOutStream(int fd_, bool blocking_, int timeoutms_, size_t bufSize_)\n   : fd(fd_), blocking(blocking_), timeoutms(timeoutms_),\n     bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n {\n@@ -79,7 +79,7 @@ void FdOutStream::setBlocking(bool blocking_) {\n   blocking = blocking_;\n }\n \n-int FdOutStream::length()\n+size_t FdOutStream::length()\n {\n   return offset + ptr - sentUpTo;\n }\n@@ -97,9 +97,9 @@ unsigned FdOutStream::getIdleTime()\n void FdOutStream::flush()\n {\n   while (sentUpTo < ptr) {\n-    int n = writeWithTimeout((const void*) sentUpTo,\n-                             ptr - sentUpTo,\n-                             blocking? timeoutms : 0);\n+    size_t n = writeWithTimeout((const void*) sentUpTo,\n+                                ptr - sentUpTo,\n+                                blocking? timeoutms : 0);\n \n     // Timeout?\n     if (n == 0) {\n@@ -120,7 +120,7 @@ void FdOutStream::flush()\n }\n \n \n-int FdOutStream::overrun(int itemSize, int nItems)\n+size_t FdOutStream::overrun(size_t itemSize, size_t nItems)\n {\n   if (itemSize > bufSize)\n     throw Exception(\"FdOutStream overrun: max itemSize exceeded\");\n@@ -129,10 +129,10 @@ int FdOutStream::overrun(int itemSize, int nItems)\n   flush();\n \n   // Still not enough space?\n-  if (itemSize > end - ptr) {\n+  if (itemSize > (size_t)(end - ptr)) {\n     // Can we shuffle things around?\n     // (don't do this if it gains us less than 25%)\n-    if ((sentUpTo - start > bufSize / 4) &&\n+    if (((size_t)(sentUpTo - start) > bufSize / 4) &&\n         (itemSize < bufSize - (ptr - sentUpTo))) {\n       memmove(start, sentUpTo, ptr - sentUpTo);\n       ptr = start + (ptr - sentUpTo);\n@@ -150,7 +150,7 @@ int FdOutStream::overrun(int itemSize, int nItems)\n   }\n \n   // Can we fit all the items asked for?\n-  if (itemSize * nItems > end - ptr)\n+  if (itemSize * nItems > (size_t)(end - ptr))\n     nItems = (end - ptr) / itemSize;\n \n   return nItems;\n@@ -166,7 +166,7 @@ int FdOutStream::overrun(int itemSize, int nItems)\n // select() and send() returning EINTR.\n //\n \n-int FdOutStream::writeWithTimeout(const void* data, int length, int timeoutms)\n+size_t FdOutStream::writeWithTimeout(const void* data, size_t length, int timeoutms)\n {\n   int n;\n "
        },
        {
          "filename": "common/rdr/FdOutStream.h",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -34,28 +34,28 @@ namespace rdr {\n \n   public:\n \n-    FdOutStream(int fd, bool blocking=true, int timeoutms=-1, int bufSize=0);\n+    FdOutStream(int fd, bool blocking=true, int timeoutms=-1, size_t bufSize=0);\n     virtual ~FdOutStream();\n \n     void setTimeout(int timeoutms);\n     void setBlocking(bool blocking);\n     int getFd() { return fd; }\n \n     void flush();\n-    int length();\n+    size_t length();\n \n     int bufferUsage();\n \n     unsigned getIdleTime();\n \n   private:\n-    int overrun(int itemSize, int nItems);\n-    int writeWithTimeout(const void* data, int length, int timeoutms);\n+    size_t overrun(size_t itemSize, size_t nItems);\n+    size_t writeWithTimeout(const void* data, size_t length, int timeoutms);\n     int fd;\n     bool blocking;\n     int timeoutms;\n-    int bufSize;\n-    int offset;\n+    size_t bufSize;\n+    size_t offset;\n     U8* start;\n     U8* sentUpTo;\n     struct timeval lastWrite;"
        },
        {
          "filename": "common/rdr/FileInStream.cxx",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -48,17 +48,17 @@ void FileInStream::reset(void) {\n   ptr = end = b;\n }\n \n-int FileInStream::pos()\n+size_t FileInStream::pos()\n {\n   if (!file)\n     throw Exception(\"File is not open\");\n \n   return ftell(file) + ptr - b;\n }\n \n-int FileInStream::overrun(int itemSize, int nItems, bool wait)\n+size_t FileInStream::overrun(size_t itemSize, size_t nItems, bool wait)\n {\n-  if (itemSize > (int)sizeof(b))\n+  if (itemSize > sizeof(b))\n     throw Exception(\"FileInStream overrun: max itemSize exceeded\");\n \n   if (end - ptr != 0)\n@@ -80,7 +80,7 @@ int FileInStream::overrun(int itemSize, int nItems, bool wait)\n     end += b + sizeof(b) - end;\n   }\n \n-  if (itemSize * nItems > end - ptr)\n+  if (itemSize * nItems > (size_t)(end - ptr))\n     nItems = (end - ptr) / itemSize;\n \n   return nItems;"
        },
        {
          "filename": "common/rdr/FileInStream.h",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -35,10 +35,10 @@ namespace rdr {\n \n     void reset(void);\n \n-    int pos();\n+    size_t pos();\n \n   protected:\n-    int overrun(int itemSize, int nItems, bool wait = true);\n+    size_t overrun(size_t itemSize, size_t nItems, bool wait = true);\n \n   private:\n     U8 b[131072];"
        },
        {
          "filename": "common/rdr/HexInStream.cxx",
          "status": "modified",
          "additions": 10,
          "deletions": 10,
          "patch": "@@ -28,7 +28,7 @@ const int DEFAULT_BUF_LEN = 16384;\n \n static inline int min(int a, int b) {return a<b ? a : b;}\n \n-HexInStream::HexInStream(InStream& is, int bufSize_)\n+HexInStream::HexInStream(InStream& is, size_t bufSize_)\n : bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_LEN), offset(0), in_stream(is)\n {\n   ptr = end = start = new U8[bufSize];\n@@ -50,16 +50,16 @@ bool HexInStream::readHexAndShift(char c, int* v) {\n   return true;\n }\n \n-bool HexInStream::hexStrToBin(const char* s, char** data, int* length) {\n-  int l=strlen(s);\n+bool HexInStream::hexStrToBin(const char* s, char** data, size_t* length) {\n+  size_t l=strlen(s);\n   if ((l % 2) == 0) {\n     delete [] *data;\n     *data = 0; *length = 0;\n     if (l == 0)\n       return true;\n     *data = new char[l/2];\n     *length = l/2;\n-    for(int i=0;i<l;i+=2) {\n+    for(size_t i=0;i<l;i+=2) {\n       int byte = 0;\n       if (!readHexAndShift(s[i], &byte) ||\n         !readHexAndShift(s[i+1], &byte))\n@@ -76,11 +76,11 @@ bool HexInStream::hexStrToBin(const char* s, char** data, int* length) {\n }\n \n \n-int HexInStream::pos() {\n+size_t HexInStream::pos() {\n   return offset + ptr - start;\n }\n \n-int HexInStream::overrun(int itemSize, int nItems, bool wait) {\n+size_t HexInStream::overrun(size_t itemSize, size_t nItems, bool wait) {\n   if (itemSize > bufSize)\n     throw Exception(\"HexInStream overrun: max itemSize exceeded\");\n \n@@ -92,14 +92,14 @@ int HexInStream::overrun(int itemSize, int nItems, bool wait) {\n   ptr = start;\n \n   while (end < ptr + itemSize) {\n-    int n = in_stream.check(2, 1, wait);\n+    size_t n = in_stream.check(2, 1, wait);\n     if (n == 0) return 0;\n     const U8* iptr = in_stream.getptr();\n     const U8* eptr = in_stream.getend();\n-    int length = min((eptr - iptr)/2, start + bufSize - end);\n+    size_t length = min((eptr - iptr)/2, start + bufSize - end);\n \n     U8* optr = (U8*) end;\n-    for (int i=0; i<length; i++) {\n+    for (size_t i=0; i<length; i++) {\n       int v = 0;\n       readHexAndShift(iptr[i*2], &v);\n       readHexAndShift(iptr[i*2+1], &v);\n@@ -110,7 +110,7 @@ int HexInStream::overrun(int itemSize, int nItems, bool wait) {\n     end += length;\n   }\n \n-  if (itemSize * nItems > end - ptr)\n+  if (itemSize * nItems > (size_t)(end - ptr))\n     nItems = (end - ptr) / itemSize;\n \n   return nItems;"
        },
        {
          "filename": "common/rdr/HexInStream.h",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -26,21 +26,21 @@ namespace rdr {\n   class HexInStream : public InStream {\n   public:\n \n-    HexInStream(InStream& is, int bufSize=0);\n+    HexInStream(InStream& is, size_t bufSize=0);\n     virtual ~HexInStream();\n \n-    int pos();\n+    size_t pos();\n \n     static bool readHexAndShift(char c, int* v);\n-    static bool hexStrToBin(const char* s, char** data, int* length);\n+    static bool hexStrToBin(const char* s, char** data, size_t* length);\n \n   protected:\n-    int overrun(int itemSize, int nItems, bool wait);\n+    size_t overrun(size_t itemSize, size_t nItems, bool wait);\n \n   private:\n-    int bufSize;\n+    size_t bufSize;\n     U8* start;\n-    int offset;\n+    size_t offset;\n \n     InStream& in_stream;\n   };"
        },
        {
          "filename": "common/rdr/HexOutStream.cxx",
          "status": "modified",
          "additions": 10,
          "deletions": 10,
          "patch": "@@ -23,9 +23,9 @@ using namespace rdr;\n \n const int DEFAULT_BUF_LEN = 16384;\n \n-static inline int min(int a, int b) {return a<b ? a : b;}\n+static inline size_t min(size_t a, size_t b) {return a<b ? a : b;}\n \n-HexOutStream::HexOutStream(OutStream& os, int buflen)\n+HexOutStream::HexOutStream(OutStream& os, size_t buflen)\n : out_stream(os), offset(0), bufSize(buflen ? buflen : DEFAULT_BUF_LEN)\n {\n   if (bufSize % 2)\n@@ -48,9 +48,9 @@ char HexOutStream::intToHex(int i) {\n     throw rdr::Exception(\"intToHex failed\");\n }\n \n-char* HexOutStream::binToHexStr(const char* data, int length) {\n+char* HexOutStream::binToHexStr(const char* data, size_t length) {\n   char* buffer = new char[length*2+1];\n-  for (int i=0; i<length; i++) {\n+  for (size_t i=0; i<length; i++) {\n     buffer[i*2] = intToHex((data[i] >> 4) & 15);\n     buffer[i*2+1] = intToHex((data[i] & 15));\n     if (!buffer[i*2] || !buffer[i*2+1]) {\n@@ -70,9 +70,9 @@ HexOutStream::writeBuffer() {\n     out_stream.check(2);\n     U8* optr = out_stream.getptr();\n     U8* oend = out_stream.getend();\n-    int length = min(ptr-pos, (oend-optr)/2);\n+    size_t length = min(ptr-pos, (oend-optr)/2);\n \n-    for (int i=0; i<length; i++) {\n+    for (size_t i=0; i<length; i++) {\n       optr[i*2] = intToHex((pos[i] >> 4) & 0xf);\n       optr[i*2+1] = intToHex(pos[i] & 0xf);\n     }\n@@ -84,7 +84,7 @@ HexOutStream::writeBuffer() {\n   ptr = start;\n }\n \n-int HexOutStream::length()\n+size_t HexOutStream::length()\n {\n   return offset + ptr - start;\n }\n@@ -95,14 +95,14 @@ HexOutStream::flush() {\n   out_stream.flush();\n }\n \n-int\n-HexOutStream::overrun(int itemSize, int nItems) {\n+size_t\n+HexOutStream::overrun(size_t itemSize, size_t nItems) {\n   if (itemSize > bufSize)\n     throw Exception(\"HexOutStream overrun: max itemSize exceeded\");\n \n   writeBuffer();\n \n-  if (itemSize * nItems > end - ptr)\n+  if (itemSize * nItems > (size_t)(end - ptr))\n     nItems = (end - ptr) / itemSize;\n \n   return nItems;"
        },
        {
          "filename": "common/rdr/HexOutStream.h",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -26,24 +26,24 @@ namespace rdr {\n   class HexOutStream : public OutStream {\n   public:\n \n-    HexOutStream(OutStream& os, int buflen=0);\n+    HexOutStream(OutStream& os, size_t buflen=0);\n     virtual ~HexOutStream();\n \n     void flush();\n-    int length();\n+    size_t length();\n \n     static char intToHex(int i);\n-    static char* binToHexStr(const char* data, int length);\n+    static char* binToHexStr(const char* data, size_t length);\n \n   private:\n     void writeBuffer();\n-    int overrun(int itemSize, int nItems);\n+    size_t overrun(size_t itemSize, size_t nItems);\n \n     OutStream& out_stream;\n \n     U8* start;\n-    int offset;\n-    int bufSize;\n+    size_t offset;\n+    size_t bufSize;\n   };\n \n }"
        },
        {
          "filename": "common/rdr/InStream.h",
          "status": "modified",
          "additions": 8,
          "deletions": 8,
          "patch": "@@ -41,7 +41,7 @@ namespace rdr {\n     // for the bytes, zero is returned if the bytes are not immediately\n     // available.\n \n-    inline int check(int itemSize, int nItems=1, bool wait=true)\n+    inline size_t check(size_t itemSize, size_t nItems=1, bool wait=true)\n     {\n       if (ptr + itemSize * nItems > end) {\n         if (ptr + itemSize > end)\n@@ -56,7 +56,7 @@ namespace rdr {\n     // be read without blocking.  It returns true if this is the case, false\n     // otherwise.  The length must be \"small\" (less than the buffer size).\n \n-    inline bool checkNoWait(int length) { return check(length, 1, false)!=0; }\n+    inline bool checkNoWait(size_t length) { return check(length, 1, false)!=0; }\n \n     // readU/SN() methods read unsigned and signed N-bit integers.\n \n@@ -82,21 +82,21 @@ namespace rdr {\n \n     static U32 maxStringLength;\n \n-    inline void skip(int bytes) {\n+    inline void skip(size_t bytes) {\n       while (bytes > 0) {\n-        int n = check(1, bytes);\n+        size_t n = check(1, bytes);\n         ptr += n;\n         bytes -= n;\n       }\n     }\n \n     // readBytes() reads an exact number of bytes.\n \n-    void readBytes(void* data, int length) {\n+    void readBytes(void* data, size_t length) {\n       U8* dataPtr = (U8*)data;\n       U8* dataEnd = dataPtr + length;\n       while (dataPtr < dataEnd) {\n-        int n = check(1, dataEnd - dataPtr);\n+        size_t n = check(1, dataEnd - dataPtr);\n         memcpy(dataPtr, ptr, n);\n         ptr += n;\n         dataPtr += n;\n@@ -114,7 +114,7 @@ namespace rdr {\n \n     // pos() returns the position in the stream.\n \n-    virtual int pos() = 0;\n+    virtual size_t pos() = 0;\n \n     // getptr(), getend() and setptr() are \"dirty\" methods which allow you to\n     // manipulate the buffer directly.  This is useful for a stream which is a\n@@ -133,7 +133,7 @@ namespace rdr {\n     // instead of blocking to wait for the bytes, zero is returned if the bytes\n     // are not immediately available.\n \n-    virtual int overrun(int itemSize, int nItems, bool wait=true) = 0;\n+    virtual size_t overrun(size_t itemSize, size_t nItems, bool wait=true) = 0;\n \n   protected:\n "
        },
        {
          "filename": "common/rdr/MemInStream.h",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -36,7 +36,7 @@ namespace rdr {\n \n   public:\n \n-    MemInStream(const void* data, int len, bool deleteWhenDone_=false)\n+    MemInStream(const void* data, size_t len, bool deleteWhenDone_=false)\n       : start((const U8*)data), deleteWhenDone(deleteWhenDone_)\n     {\n       ptr = start;\n@@ -48,12 +48,12 @@ namespace rdr {\n         delete [] start;\n     }\n \n-    int pos() { return ptr - start; }\n-    void reposition(int pos) { ptr = start + pos; }\n+    size_t pos() { return ptr - start; }\n+    void reposition(size_t pos) { ptr = start + pos; }\n \n   private:\n \n-    int overrun(int itemSize, int nItems, bool wait) { throw EndOfStream(); }\n+    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }\n     const U8* start;\n     bool deleteWhenDone;\n   };"
        },
        {
          "filename": "common/rdr/MemOutStream.h",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -40,16 +40,16 @@ namespace rdr {\n       delete [] start;\n     }\n \n-    void writeBytes(const void* data, int length) {\n+    void writeBytes(const void* data, size_t length) {\n       check(length);\n       memcpy(ptr, data, length);\n       ptr += length;\n     }\n \n-    int length() { return ptr - start; }\n+    size_t length() { return ptr - start; }\n     void clear() { ptr = start; };\n     void clearAndZero() { memset(start, 0, ptr-start); clear(); }\n-    void reposition(int pos) { ptr = start + pos; }\n+    void reposition(size_t pos) { ptr = start + pos; }\n \n     // data() returns a pointer to the buffer.\n \n@@ -60,9 +60,9 @@ namespace rdr {\n     // overrun() either doubles the buffer or adds enough space for nItems of\n     // size itemSize bytes.\n \n-    int overrun(int itemSize, int nItems) {\n-      int len = ptr - start + itemSize * nItems;\n-      if (len < (end - start) * 2)\n+    size_t overrun(size_t itemSize, size_t nItems) {\n+      size_t len = ptr - start + itemSize * nItems;\n+      if (len < (size_t)(end - start) * 2)\n         len = (end - start) * 2;\n \n       U8* newStart = new U8[len];"
        },
        {
          "filename": "common/rdr/OutStream.h",
          "status": "modified",
          "additions": 10,
          "deletions": 10,
          "patch": "@@ -44,7 +44,7 @@ namespace rdr {\n     // itemSize bytes.  Returns the number of items which fit (up to a maximum\n     // of nItems).\n \n-    inline int check(int itemSize, int nItems=1)\n+    inline size_t check(size_t itemSize, size_t nItems=1)\n     {\n       if (ptr + itemSize * nItems > end) {\n         if (ptr + itemSize > end)\n@@ -76,25 +76,25 @@ namespace rdr {\n       writeBytes(str, len);\n     }\n \n-    inline void pad(int bytes) {\n+    inline void pad(size_t bytes) {\n       while (bytes-- > 0) writeU8(0);\n     }\n \n-    inline void skip(int bytes) {\n+    inline void skip(size_t bytes) {\n       while (bytes > 0) {\n-        int n = check(1, bytes);\n+        size_t n = check(1, bytes);\n         ptr += n;\n         bytes -= n;\n       }\n     }\n \n     // writeBytes() writes an exact number of bytes.\n \n-    void writeBytes(const void* data, int length) {\n+    void writeBytes(const void* data, size_t length) {\n       const U8* dataPtr = (const U8*)data;\n       const U8* dataEnd = dataPtr + length;\n       while (dataPtr < dataEnd) {\n-        int n = check(1, dataEnd - dataPtr);\n+        size_t n = check(1, dataEnd - dataPtr);\n         memcpy(ptr, dataPtr, n);\n         ptr += n;\n         dataPtr += n;\n@@ -103,9 +103,9 @@ namespace rdr {\n \n     // copyBytes() efficiently transfers data between streams\n \n-    void copyBytes(InStream* is, int length) {\n+    void copyBytes(InStream* is, size_t length) {\n       while (length > 0) {\n-        int n = check(1, length);\n+        size_t n = check(1, length);\n         is->readBytes(ptr, n);\n         ptr += n;\n         length -= n;\n@@ -124,7 +124,7 @@ namespace rdr {\n \n     // length() returns the length of the stream.\n \n-    virtual int length() = 0;\n+    virtual size_t length() = 0;\n \n     // flush() requests that the stream be flushed.\n \n@@ -145,7 +145,7 @@ namespace rdr {\n     // the number of items which fit (up to a maximum of nItems).  itemSize is\n     // supposed to be \"small\" (a few bytes).\n \n-    virtual int overrun(int itemSize, int nItems) = 0;\n+    virtual size_t overrun(size_t itemSize, size_t nItems) = 0;\n \n   protected:\n "
        },
        {
          "filename": "common/rdr/RandomStream.cxx",
          "status": "modified",
          "additions": 7,
          "deletions": 7,
          "patch": "@@ -35,7 +35,7 @@ static rfb::LogWriter vlog(\"RandomStream\");\n \n using namespace rdr;\n \n-const int DEFAULT_BUF_LEN = 256;\n+const size_t DEFAULT_BUF_LEN = 256;\n \n unsigned int RandomStream::seed;\n \n@@ -86,11 +86,11 @@ RandomStream::~RandomStream() {\n #endif\n }\n \n-int RandomStream::pos() {\n+size_t RandomStream::pos() {\n   return offset + ptr - start;\n }\n \n-int RandomStream::overrun(int itemSize, int nItems, bool wait) {\n+size_t RandomStream::overrun(size_t itemSize, size_t nItems, bool wait) {\n   if (itemSize > DEFAULT_BUF_LEN)\n     throw Exception(\"RandomStream overrun: max itemSize exceeded\");\n \n@@ -101,7 +101,7 @@ int RandomStream::overrun(int itemSize, int nItems, bool wait) {\n   offset += ptr - start;\n   ptr = start;\n \n-  int length = start + DEFAULT_BUF_LEN - end;\n+  size_t length = start + DEFAULT_BUF_LEN - end;\n \n #ifdef RFB_HAVE_WINCRYPT\n   if (provider) {\n@@ -112,7 +112,7 @@ int RandomStream::overrun(int itemSize, int nItems, bool wait) {\n #else\n #ifndef WIN32\n   if (fp) {\n-    int n = fread((U8*)end, length, 1, fp);\n+    size_t n = fread((U8*)end, length, 1, fp);\n     if (n != 1)\n       throw rdr::SystemException(\"reading /dev/urandom or /dev/random failed\",\n                                  errno);\n@@ -122,11 +122,11 @@ int RandomStream::overrun(int itemSize, int nItems, bool wait) {\n   {\n #endif\n #endif\n-    for (int i=0; i<length; i++)\n+    for (size_t i=0; i<length; i++)\n       *(U8*)end++ = (int) (256.0*rand()/(RAND_MAX+1.0));\n   }\n \n-  if (itemSize * nItems > end - ptr)\n+  if (itemSize * nItems > (size_t)(end - ptr))\n     nItems = (end - ptr) / itemSize;\n \n   return nItems;"
        },
        {
          "filename": "common/rdr/RandomStream.h",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -39,14 +39,14 @@ namespace rdr {\n     RandomStream();\n     virtual ~RandomStream();\n \n-    int pos();\n+    size_t pos();\n \n   protected:\n-    int overrun(int itemSize, int nItems, bool wait);\n+    size_t overrun(size_t itemSize, size_t nItems, bool wait);\n \n   private:\n     U8* start;\n-    int offset;\n+    size_t offset;\n \n     static unsigned int seed;\n #ifdef RFB_HAVE_WINCRYPT"
        },
        {
          "filename": "common/rdr/TLSInStream.cxx",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -75,12 +75,12 @@ TLSInStream::~TLSInStream()\n   delete[] start;\n }\n \n-int TLSInStream::pos()\n+size_t TLSInStream::pos()\n {\n   return offset + ptr - start;\n }\n \n-int TLSInStream::overrun(int itemSize, int nItems, bool wait)\n+size_t TLSInStream::overrun(size_t itemSize, size_t nItems, bool wait)\n {\n   if (itemSize > bufSize)\n     throw Exception(\"TLSInStream overrun: max itemSize exceeded\");\n@@ -93,19 +93,19 @@ int TLSInStream::overrun(int itemSize, int nItems, bool wait)\n   ptr = start;\n \n   while (end < start + itemSize) {\n-    int n = readTLS((U8*) end, start + bufSize - end, wait);\n+    size_t n = readTLS((U8*) end, start + bufSize - end, wait);\n     if (!wait && n == 0)\n       return 0;\n     end += n;\n   }\n \n-  if (itemSize * nItems > end - ptr)\n+  if (itemSize * nItems > (size_t)(end - ptr))\n     nItems = (end - ptr) / itemSize;\n \n   return nItems;\n }\n \n-int TLSInStream::readTLS(U8* buf, int len, bool wait)\n+size_t TLSInStream::readTLS(U8* buf, size_t len, bool wait)\n {\n   int n;\n "
        },
        {
          "filename": "common/rdr/TLSInStream.h",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -36,17 +36,17 @@ namespace rdr {\n     TLSInStream(InStream* in, gnutls_session_t session);\n     virtual ~TLSInStream();\n \n-    int pos();\n+    size_t pos();\n \n   private:\n-    int overrun(int itemSize, int nItems, bool wait);\n-    int readTLS(U8* buf, int len, bool wait);\n+    size_t overrun(size_t itemSize, size_t nItems, bool wait);\n+    size_t readTLS(U8* buf, size_t len, bool wait);\n     static ssize_t pull(gnutls_transport_ptr_t str, void* data, size_t size);\n \n     gnutls_session_t session;\n     InStream* in;\n-    int bufSize;\n-    int offset;\n+    size_t bufSize;\n+    size_t offset;\n     U8* start;\n   };\n };"
        },
        {
          "filename": "common/rdr/TLSOutStream.cxx",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -75,7 +75,7 @@ TLSOutStream::~TLSOutStream()\n   delete [] start;\n }\n \n-int TLSOutStream::length()\n+size_t TLSOutStream::length()\n {\n   return offset + ptr - start;\n }\n@@ -84,7 +84,7 @@ void TLSOutStream::flush()\n {\n   U8* sentUpTo = start;\n   while (sentUpTo < ptr) {\n-    int n = writeTLS(sentUpTo, ptr - sentUpTo);\n+    size_t n = writeTLS(sentUpTo, ptr - sentUpTo);\n     sentUpTo += n;\n     offset += n;\n   }\n@@ -93,20 +93,20 @@ void TLSOutStream::flush()\n   out->flush();\n }\n \n-int TLSOutStream::overrun(int itemSize, int nItems)\n+size_t TLSOutStream::overrun(size_t itemSize, size_t nItems)\n {\n   if (itemSize > bufSize)\n     throw Exception(\"TLSOutStream overrun: max itemSize exceeded\");\n \n   flush();\n \n-  if (itemSize * nItems > end - ptr)\n+  if (itemSize * nItems > (size_t)(end - ptr))\n     nItems = (end - ptr) / itemSize;\n \n   return nItems;\n }\n \n-int TLSOutStream::writeTLS(const U8* data, int length)\n+size_t TLSOutStream::writeTLS(const U8* data, size_t length)\n {\n   int n;\n "
        },
        {
          "filename": "common/rdr/TLSOutStream.h",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -36,20 +36,20 @@ namespace rdr {\n     virtual ~TLSOutStream();\n \n     void flush();\n-    int length();\n+    size_t length();\n \n   protected:\n-    int overrun(int itemSize, int nItems);\n+    size_t overrun(size_t itemSize, size_t nItems);\n \n   private:\n-    int writeTLS(const U8* data, int length);\n+    size_t writeTLS(const U8* data, size_t length);\n     static ssize_t push(gnutls_transport_ptr_t str, const void* data, size_t size);\n \n     gnutls_session_t session;\n     OutStream* out;\n-    int bufSize;\n+    size_t bufSize;\n     U8* start;\n-    int offset;\n+    size_t offset;\n   };\n };\n "
        },
        {
          "filename": "common/rdr/ZlibInStream.cxx",
          "status": "modified",
          "additions": 8,
          "deletions": 8,
          "patch": "@@ -26,7 +26,7 @@ using namespace rdr;\n \n enum { DEFAULT_BUF_SIZE = 16384 };\n \n-ZlibInStream::ZlibInStream(int bufSize_)\n+ZlibInStream::ZlibInStream(size_t bufSize_)\n   : underlying(0), bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0),\n     zs(NULL), bytesIn(0)\n {\n@@ -40,14 +40,14 @@ ZlibInStream::~ZlibInStream()\n   delete [] start;\n }\n \n-void ZlibInStream::setUnderlying(InStream* is, int bytesIn_)\n+void ZlibInStream::setUnderlying(InStream* is, size_t bytesIn_)\n {\n   underlying = is;\n   bytesIn = bytesIn_;\n   ptr = end = start;\n }\n \n-int ZlibInStream::pos()\n+size_t ZlibInStream::pos()\n {\n   return offset + ptr - start;\n }\n@@ -96,7 +96,7 @@ void ZlibInStream::deinit()\n   zs = NULL;\n }\n \n-int ZlibInStream::overrun(int itemSize, int nItems, bool wait)\n+size_t ZlibInStream::overrun(size_t itemSize, size_t nItems, bool wait)\n {\n   if (itemSize > bufSize)\n     throw Exception(\"ZlibInStream overrun: max itemSize exceeded\");\n@@ -108,12 +108,12 @@ int ZlibInStream::overrun(int itemSize, int nItems, bool wait)\n   end -= ptr - start;\n   ptr = start;\n \n-  while (end - ptr < itemSize) {\n+  while ((size_t)(end - ptr) < itemSize) {\n     if (!decompress(wait))\n       return 0;\n   }\n \n-  if (itemSize * nItems > end - ptr)\n+  if (itemSize * nItems > (size_t)(end - ptr))\n     nItems = (end - ptr) / itemSize;\n \n   return nItems;\n@@ -131,11 +131,11 @@ bool ZlibInStream::decompress(bool wait)\n   zs->next_out = (U8*)end;\n   zs->avail_out = start + bufSize - end;\n \n-  int n = underlying->check(1, 1, wait);\n+  size_t n = underlying->check(1, 1, wait);\n   if (n == 0) return false;\n   zs->next_in = (U8*)underlying->getptr();\n   zs->avail_in = underlying->getend() - underlying->getptr();\n-  if ((int)zs->avail_in > bytesIn)\n+  if (zs->avail_in > bytesIn)\n     zs->avail_in = bytesIn;\n \n   int rc = inflate(zs, Z_SYNC_FLUSH);"
        },
        {
          "filename": "common/rdr/ZlibInStream.h",
          "status": "modified",
          "additions": 7,
          "deletions": 7,
          "patch": "@@ -34,27 +34,27 @@ namespace rdr {\n \n   public:\n \n-    ZlibInStream(int bufSize=0);\n+    ZlibInStream(size_t bufSize=0);\n     virtual ~ZlibInStream();\n \n-    void setUnderlying(InStream* is, int bytesIn);\n+    void setUnderlying(InStream* is, size_t bytesIn);\n     void flushUnderlying();\n-    int pos();\n+    size_t pos();\n     void reset();\n \n   private:\n \n     void init();\n     void deinit();\n \n-    int overrun(int itemSize, int nItems, bool wait);\n+    size_t overrun(size_t itemSize, size_t nItems, bool wait);\n     bool decompress(bool wait);\n \n     InStream* underlying;\n-    int bufSize;\n-    int offset;\n+    size_t bufSize;\n+    size_t offset;\n     z_stream_s* zs;\n-    int bytesIn;\n+    size_t bytesIn;\n     U8* start;\n   };\n "
        },
        {
          "filename": "common/rdr/ZlibOutStream.cxx",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -33,7 +33,7 @@ using namespace rdr;\n \n enum { DEFAULT_BUF_SIZE = 16384 };\n \n-ZlibOutStream::ZlibOutStream(OutStream* os, int bufSize_, int compressLevel)\n+ZlibOutStream::ZlibOutStream(OutStream* os, size_t bufSize_, int compressLevel)\n   : underlying(os), compressionLevel(compressLevel), newLevel(compressLevel),\n     bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n {\n@@ -75,7 +75,7 @@ void ZlibOutStream::setCompressionLevel(int level)\n   newLevel = level;\n }\n \n-int ZlibOutStream::length()\n+size_t ZlibOutStream::length()\n {\n   return offset + ptr - start;\n }\n@@ -98,7 +98,7 @@ void ZlibOutStream::flush()\n   ptr = start;\n }\n \n-int ZlibOutStream::overrun(int itemSize, int nItems)\n+size_t ZlibOutStream::overrun(size_t itemSize, size_t nItems)\n {\n #ifdef ZLIBOUT_DEBUG\n   vlog.debug(\"overrun\");\n@@ -109,7 +109,7 @@ int ZlibOutStream::overrun(int itemSize, int nItems)\n \n   checkCompressionLevel();\n \n-  while (end - ptr < itemSize) {\n+  while ((size_t)(end - ptr) < itemSize) {\n     zs->next_in = start;\n     zs->avail_in = ptr - start;\n \n@@ -130,7 +130,7 @@ int ZlibOutStream::overrun(int itemSize, int nItems)\n     }\n   }\n \n-  if (itemSize * nItems > end - ptr)\n+  if (itemSize * nItems > (size_t)(end - ptr))\n     nItems = (end - ptr) / itemSize;\n \n   return nItems;"
        },
        {
          "filename": "common/rdr/ZlibOutStream.h",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -35,25 +35,25 @@ namespace rdr {\n \n   public:\n \n-    ZlibOutStream(OutStream* os=0, int bufSize=0, int compressionLevel=-1);\n+    ZlibOutStream(OutStream* os=0, size_t bufSize=0, int compressionLevel=-1);\n     virtual ~ZlibOutStream();\n \n     void setUnderlying(OutStream* os);\n     void setCompressionLevel(int level=-1);\n     void flush();\n-    int length();\n+    size_t length();\n \n   private:\n \n-    int overrun(int itemSize, int nItems);\n+    size_t overrun(size_t itemSize, size_t nItems);\n     void deflate(int flush);\n     void checkCompressionLevel();\n \n     OutStream* underlying;\n     int compressionLevel;\n     int newLevel;\n-    int bufSize;\n-    int offset;\n+    size_t bufSize;\n+    size_t offset;\n     z_stream_s* zs;\n     U8* start;\n   };"
        },
        {
          "filename": "common/rfb/Configuration.cxx",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -421,7 +421,7 @@ StringParameter::operator const char *() const {\n // -=- BinaryParameter\n \n BinaryParameter::BinaryParameter(const char* name_, const char* desc_,\n-\t\t\t\t const void* v, int l, ConfigurationObject co)\n+\t\t\t\t const void* v, size_t l, ConfigurationObject co)\n : VoidParameter(name_, desc_, co), value(0), length(0), def_value((char*)v), def_length(l) {\n   if (l) {\n     value = new char[l];\n@@ -441,7 +441,7 @@ bool BinaryParameter::setParam(const char* v) {\n   return rdr::HexInStream::hexStrToBin(v, &value, &length);\n }\n \n-void BinaryParameter::setParam(const void* v, int len) {\n+void BinaryParameter::setParam(const void* v, size_t len) {\n   LOCK_CONFIG;\n   if (immutable) return; \n   vlog.debug(\"set %s(Binary)\", getName());\n@@ -462,7 +462,7 @@ char* BinaryParameter::getValueStr() const {\n   return rdr::HexOutStream::binToHexStr(value, length);\n }\n \n-void BinaryParameter::getData(void** data_, int* length_) const {\n+void BinaryParameter::getData(void** data_, size_t* length_) const {\n   LOCK_CONFIG;\n   if (length_) *length_ = length;\n   if (data_) {"
        },
        {
          "filename": "common/rfb/Configuration.h",
          "status": "modified",
          "additions": 7,
          "deletions": 6,
          "patch": "@@ -256,24 +256,25 @@ namespace rfb {\n \n   class BinaryParameter : public VoidParameter {\n   public:\n-    BinaryParameter(const char* name_, const char* desc_, const void* v, int l,\n-\t\t    ConfigurationObject co=ConfGlobal);\n+    BinaryParameter(const char* name_, const char* desc_,\n+                    const void* v, size_t l,\n+                    ConfigurationObject co=ConfGlobal);\n     using VoidParameter::setParam;\n     virtual ~BinaryParameter();\n     virtual bool setParam(const char* value);\n-    virtual void setParam(const void* v, int l);\n+    virtual void setParam(const void* v, size_t l);\n     virtual char* getDefaultStr() const;\n     virtual char* getValueStr() const;\n \n     // getData() will return length zero if there is no data\n     // NB: data may be set to zero, OR set to a zero-length buffer\n-    void getData(void** data, int* length) const;\n+    void getData(void** data, size_t* length) const;\n \n   protected:\n     char* value;\n-    int length;\n+    size_t length;\n     char* def_value;\n-    int def_length;\n+    size_t def_length;\n   };\n \n   // -=- ParameterIterator"
        },
        {
          "filename": "common/rfb/Password.cxx",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -38,7 +38,7 @@ PlainPasswd::PlainPasswd() {}\n PlainPasswd::PlainPasswd(char* pwd) : CharArray(pwd) {\n }\n \n-PlainPasswd::PlainPasswd(int len) : CharArray(len) {\n+PlainPasswd::PlainPasswd(size_t len) : CharArray(len) {\n }\n \n PlainPasswd::PlainPasswd(const ObfuscatedPasswd& obfPwd) : CharArray(9) {\n@@ -63,11 +63,11 @@ void PlainPasswd::replaceBuf(char* b) {\n ObfuscatedPasswd::ObfuscatedPasswd() : length(0) {\n }\n \n-ObfuscatedPasswd::ObfuscatedPasswd(int len) : CharArray(len), length(len) {\n+ObfuscatedPasswd::ObfuscatedPasswd(size_t len) : CharArray(len), length(len) {\n }\n \n ObfuscatedPasswd::ObfuscatedPasswd(const PlainPasswd& plainPwd) : CharArray(8), length(8) {\n-  int l = strlen(plainPwd.buf), i;\n+  size_t l = strlen(plainPwd.buf), i;\n   for (i=0; i<8; i++)\n     buf[i] = i<l ? plainPwd.buf[i] : 0;\n   deskey(d3desObfuscationKey, EN0);"
        },
        {
          "filename": "common/rfb/Password.h",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -28,7 +28,7 @@ namespace rfb {\n   public:\n     PlainPasswd();\n     PlainPasswd(char* pwd);\n-    PlainPasswd(int len);\n+    PlainPasswd(size_t len);\n     PlainPasswd(const ObfuscatedPasswd& obfPwd);\n     ~PlainPasswd();\n     void replaceBuf(char* b);\n@@ -37,10 +37,10 @@ namespace rfb {\n   class ObfuscatedPasswd : public CharArray {\n   public:\n     ObfuscatedPasswd();\n-    ObfuscatedPasswd(int l);\n+    ObfuscatedPasswd(size_t l);\n     ObfuscatedPasswd(const PlainPasswd& plainPwd);\n     ~ObfuscatedPasswd();\n-    int length;\n+    size_t length;\n   };\n \n }"
        },
        {
          "filename": "common/rfb/util.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -50,7 +50,7 @@ namespace rfb {\n   public:\n     CharArray() : buf(0) {}\n     CharArray(char* str) : buf(str) {} // note: assumes ownership\n-    CharArray(int len) {\n+    CharArray(size_t len) {\n       buf = new char[len]();\n     }\n     ~CharArray() {"
        },
        {
          "filename": "tests/perf/encperf.cxx",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -71,11 +71,11 @@ class DummyOutStream : public rdr::OutStream {\n public:\n   DummyOutStream();\n \n-  virtual int length();\n+  virtual size_t length();\n   virtual void flush();\n \n private:\n-  virtual int overrun(int itemSize, int nItems);\n+  virtual size_t overrun(size_t itemSize, size_t nItems);\n \n   int offset;\n   rdr::U8 buf[131072];\n@@ -141,7 +141,7 @@ DummyOutStream::DummyOutStream()\n   end = buf + sizeof(buf);\n }\n \n-int DummyOutStream::length()\n+size_t DummyOutStream::length()\n {\n   flush();\n   return offset;\n@@ -153,10 +153,10 @@ void DummyOutStream::flush()\n   ptr = buf;\n }\n \n-int DummyOutStream::overrun(int itemSize, int nItems)\n+size_t DummyOutStream::overrun(size_t itemSize, size_t nItems)\n {\n   flush();\n-  if (itemSize * nItems > end - ptr)\n+  if (itemSize * nItems > (size_t)(end - ptr))\n     nItems = (end - ptr) / itemSize;\n   return nItems;\n }"
        },
        {
          "filename": "win/rfb_win32/Registry.cxx",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -146,7 +146,7 @@ void RegKey::setString(const TCHAR* valname, const TCHAR* value) const {\n   if (result != ERROR_SUCCESS) throw rdr::SystemException(\"setString\", result);\n }\n \n-void RegKey::setBinary(const TCHAR* valname, const void* value, int length) const {\n+void RegKey::setBinary(const TCHAR* valname, const void* value, size_t length) const {\n   LONG result = RegSetValueEx(key, valname, 0, REG_BINARY, (const BYTE*)value, length);\n   if (result != ERROR_SUCCESS) throw rdr::SystemException(\"setBinary\", result);\n }\n@@ -169,12 +169,12 @@ TCHAR* RegKey::getString(const TCHAR* valname, const TCHAR* def) const {\n   }\n }\n \n-void RegKey::getBinary(const TCHAR* valname, void** data, int* length) const {\n+void RegKey::getBinary(const TCHAR* valname, void** data, size_t* length) const {\n   TCharArray hex(getRepresentation(valname));\n   if (!rdr::HexInStream::hexStrToBin(CStr(hex.buf), (char**)data, length))\n     throw rdr::Exception(\"getBinary failed\");\n }\n-void RegKey::getBinary(const TCHAR* valname, void** data, int* length, void* def, int deflen) const {\n+void RegKey::getBinary(const TCHAR* valname, void** data, size_t* length, void* def, size_t deflen) const {\n   try {\n     getBinary(valname, data, length);\n   } catch(rdr::Exception&) {"
        },
        {
          "filename": "win/rfb_win32/Registry.h",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -71,15 +71,15 @@ namespace rfb {\n \n       void setExpandString(const TCHAR* valname, const TCHAR* s) const;\n       void setString(const TCHAR* valname, const TCHAR* s) const;\n-      void setBinary(const TCHAR* valname, const void* data, int length) const;\n+      void setBinary(const TCHAR* valname, const void* data, size_t length) const;\n       void setInt(const TCHAR* valname, int i) const;\n       void setBool(const TCHAR* valname, bool b) const;\n \n       TCHAR* getString(const TCHAR* valname) const;\n       TCHAR* getString(const TCHAR* valname, const TCHAR* def) const;\n \n-      void getBinary(const TCHAR* valname, void** data, int* length) const;\n-      void getBinary(const TCHAR* valname, void** data, int* length, void* def, int deflength) const;\n+      void getBinary(const TCHAR* valname, void** data, size_t* length) const;\n+      void getBinary(const TCHAR* valname, void** data, size_t* length, void* def, size_t deflength) const;\n \n       int getInt(const TCHAR* valname) const;\n       int getInt(const TCHAR* valname, int def) const;"
        }
      ],
      "file_patterns": {
        "security_files": 2,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "ba73536bcdc32e2d0f8b465ba0295f9ab9ce2b54",
            "date": "2025-01-14T11:41:42Z",
            "author_login": "CendioOssman"
          },
          {
            "sha": "fac3d805774f9d482db7d4e4fdee4bdc6300c455",
            "date": "2025-01-13T16:31:44Z",
            "author_login": "CendioOssman"
          },
          {
            "sha": "5b0b8c0db44eb20ac501158affd3c77fe2c7fdb3",
            "date": "2025-01-13T09:17:28Z",
            "author_login": "CendioOssman"
          },
          {
            "sha": "68763a13f9ebc386e101907683b30dde842f3618",
            "date": "2024-12-17T19:04:04Z",
            "author_login": "JoachimFalk"
          },
          {
            "sha": "e378f3f87d4104545224afa54d418bbebf255f8e",
            "date": "2024-12-17T18:58:34Z",
            "author_login": "JoachimFalk"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.2,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-122",
    "description": "TigerVNC version prior to 1.10.1 is vulnerable to heap buffer overflow, which could be triggered from DecodeManager::decodeRect. Vulnerability occurs due to the signdness error in processing MemOutStream. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2019-12-26T15:15:11.337",
    "last_modified": "2024-11-21T04:29:16.497",
    "fix_date": "2019-09-23T09:00:17Z"
  },
  "references": [
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2020-01/msg00039.html",
      "source": "vulnerability@kaspersky.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/CendioOssman/tigervnc/commit/0943c006c7d900dfc0281639e992791d6c567438",
      "source": "vulnerability@kaspersky.com",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/TigerVNC/tigervnc/releases/tag/v1.10.1",
      "source": "vulnerability@kaspersky.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.openwall.com/lists/oss-security/2019/12/20/2",
      "source": "vulnerability@kaspersky.com",
      "tags": [
        "Exploit",
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2020-01/msg00039.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/CendioOssman/tigervnc/commit/0943c006c7d900dfc0281639e992791d6c567438",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/TigerVNC/tigervnc/releases/tag/v1.10.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.openwall.com/lists/oss-security/2019/12/20/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Mailing List",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:24.272793",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "tigervnc",
    "owner": "TigerVNC",
    "created_at": "2014-06-25T12:48:26Z",
    "updated_at": "2025-01-14T11:44:26Z",
    "pushed_at": "2025-01-14T11:44:21Z",
    "size": 25050,
    "stars": 5359,
    "forks": 970,
    "open_issues": 175,
    "watchers": 5359,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 2105004,
      "Java": 1745894,
      "C": 1008908,
      "CMake": 70519,
      "Roff": 50879,
      "Makefile": 32567,
      "Objective-C++": 17412,
      "Perl": 12443,
      "Shell": 11196,
      "Objective-C": 1780,
      "Python": 1378
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T13:43:04.443892"
  }
}