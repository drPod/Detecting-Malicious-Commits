{
  "cve_id": "CVE-2019-16097",
  "github_data": {
    "repository": "goharbor/harbor",
    "fix_commit": "b6db8a8a106259ec9a2c48be8a380cb3b37cf517",
    "related_commits": [
      "b6db8a8a106259ec9a2c48be8a380cb3b37cf517",
      "b6db8a8a106259ec9a2c48be8a380cb3b37cf517"
    ],
    "patch_url": "https://github.com/goharbor/harbor/commit/b6db8a8a106259ec9a2c48be8a380cb3b37cf517.patch",
    "fix_commit_details": {
      "sha": "b6db8a8a106259ec9a2c48be8a380cb3b37cf517",
      "commit_date": "2019-08-27T01:42:52Z",
      "author": {
        "login": "reasonerjt",
        "type": "User",
        "stats": {
          "total_commits": 1749,
          "average_weekly_commits": 3.7371794871794872,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 252
        }
      },
      "commit_message": {
        "title": "Disallow creating an admin user when registration",
        "length": 199,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 73,
        "additions": 47,
        "deletions": 26
      },
      "files": [
        {
          "filename": "src/core/api/user.go",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -324,6 +324,14 @@ func (ua *UserAPI) Post() {\n \t\tua.RenderError(http.StatusBadRequest, \"register error:\"+err.Error())\n \t\treturn\n \t}\n+\n+\tif !ua.IsAdmin && user.HasAdminRole {\n+\t\tmsg := \"Non-admin cannot create an admin user.\"\n+\t\tlog.Errorf(msg)\n+\t\tua.SendForbiddenError(errors.New(msg))\n+\t\treturn\n+\t}\n+\n \tuserExist, err := dao.UserExists(user, \"username\")\n \tif err != nil {\n \t\tlog.Errorf(\"Error occurred in Register: %v\", err)\n@@ -346,6 +354,7 @@ func (ua *UserAPI) Post() {\n \t\tua.SendConflictError(errors.New(\"email has already been used\"))\n \t\treturn\n \t}\n+\n \tuserID, err := dao.Register(user)\n \tif err != nil {\n \t\tlog.Errorf(\"Error occurred in Register: %v\", err)"
        },
        {
          "filename": "src/core/api/user_test.go",
          "status": "modified",
          "additions": 38,
          "deletions": 26,
          "patch": "@@ -45,67 +45,67 @@ func TestUsersPost(t *testing.T) {\n \t\tcommon.AUTHMode: \"db_auth\",\n \t})\n \t// case 1: register a new user without admin auth, expect 400, because self registration is on\n-\tfmt.Println(\"Register user without admin auth\")\n+\tt.Log(\"case 1: Register user without admin auth\")\n \tcode, err := apiTest.UsersPost(testUser0002)\n \tif err != nil {\n \t\tt.Error(\"Error occurred while add a test User\", err.Error())\n \t\tt.Log(err)\n \t} else {\n-\t\tassert.Equal(400, code, \"Add user status should be 400\")\n+\t\tassert.Equal(400, code, \"case 1: Add user status should be 400\")\n \t}\n \n \t// case 2: register a new user with admin auth, but username is empty, expect 400\n-\tfmt.Println(\"Register user with admin auth, but username is empty\")\n+\tt.Log(\"case 2: Register user with admin auth, but username is empty\")\n \tcode, err = apiTest.UsersPost(testUser0002, *admin)\n \tif err != nil {\n \t\tt.Error(\"Error occurred while add a user\", err.Error())\n \t\tt.Log(err)\n \t} else {\n-\t\tassert.Equal(400, code, \"Add user status should be 400\")\n+\t\tassert.Equal(400, code, \"case 2: Add user status should be 400\")\n \t}\n \n \t// case 3: register a new user with admin auth, but bad username format, expect 400\n \ttestUser0002.Username = \"test@$\"\n-\tfmt.Println(\"Register user with admin auth, but bad username format\")\n+\tt.Log(\"case 3: Register user with admin auth, but bad username format\")\n \tcode, err = apiTest.UsersPost(testUser0002, *admin)\n \tif err != nil {\n \t\tt.Error(\"Error occurred while add a user\", err.Error())\n \t\tt.Log(err)\n \t} else {\n-\t\tassert.Equal(400, code, \"Add user status should be 400\")\n+\t\tassert.Equal(400, code, \"case 3: Add user status should be 400\")\n \t}\n \n \t// case 4: register a new user with admin auth, but bad userpassword format, expect 400\n \ttestUser0002.Username = \"testUser0002\"\n-\tfmt.Println(\"Register user with admin auth, but empty password.\")\n+\tt.Log(\"case 4: Register user with admin auth, but empty password.\")\n \tcode, err = apiTest.UsersPost(testUser0002, *admin)\n \tif err != nil {\n \t\tt.Error(\"Error occurred while add a user\", err.Error())\n \t\tt.Log(err)\n \t} else {\n-\t\tassert.Equal(400, code, \"Add user status should be 400\")\n+\t\tassert.Equal(400, code, \"case 4: Add user status should be 400\")\n \t}\n \n \t// case 5: register a new user with admin auth, but email is empty, expect 400\n \ttestUser0002.Password = \"testUser0002\"\n-\tfmt.Println(\"Register user with admin auth, but email is empty\")\n+\tt.Log(\"case 5: Register user with admin auth, but email is empty\")\n \tcode, err = apiTest.UsersPost(testUser0002, *admin)\n \tif err != nil {\n \t\tt.Error(\"Error occurred while add a user\", err.Error())\n \t\tt.Log(err)\n \t} else {\n-\t\tassert.Equal(400, code, \"Add user status should be 400\")\n+\t\tassert.Equal(400, code, \"case 5: Add user status should be 400\")\n \t}\n \n \t// case 6: register a new user with admin auth, but bad email format, expect 400\n \ttestUser0002.Email = \"test...\"\n-\tfmt.Println(\"Register user with admin auth, but bad email format\")\n+\tt.Log(\"case 6: Register user with admin auth, but bad email format\")\n \tcode, err = apiTest.UsersPost(testUser0002, *admin)\n \tif err != nil {\n \t\tt.Error(\"Error occurred while add a user\", err.Error())\n \t\tt.Log(err)\n \t} else {\n-\t\tassert.Equal(400, code, \"Add user status should be 400\")\n+\t\tassert.Equal(400, code, \"case 6: Add user status should be 400\")\n \t}\n \n \t// case 7: register a new user with admin auth, but userrealname is empty, expect 400\n@@ -123,59 +123,71 @@ func TestUsersPost(t *testing.T) {\n \t// case 8: register a new user with admin auth, but bad userrealname format, expect 400\n \ttestUser0002.Email = \"testUser0002@mydomain.com\"\n \ttestUser0002.Realname = \"test$com\"\n-\tfmt.Println(\"Register user with admin auth, but bad user realname format\")\n+\tt.Log(\"case 8: Register user with admin auth, but bad user realname format\")\n \tcode, err = apiTest.UsersPost(testUser0002, *admin)\n \tif err != nil {\n \t\tt.Error(\"Error occurred while add a user\", err.Error())\n \t\tt.Log(err)\n \n \t} else {\n-\t\tassert.Equal(400, code, \"Add user status should be 400\")\n+\t\tassert.Equal(400, code, \"case 8: Add user status should be 400\")\n \t}\n \n \t// case 9: register a new user with admin auth, but bad user comment, expect 400\n \ttestUser0002.Realname = \"testUser0002\"\n \ttestUser0002.Comment = \"vmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\"\n-\tfmt.Println(\"Register user with admin auth, but user comment length is illegal\")\n+\tt.Log(\"case 9: Register user with admin auth, but user comment length is illegal\")\n \tcode, err = apiTest.UsersPost(testUser0002, *admin)\n \tif err != nil {\n \t\tt.Error(\"Error occurred while add a user\", err.Error())\n \t\tt.Log(err)\n \t} else {\n-\t\tassert.Equal(400, code, \"Add user status should be 400\")\n+\t\tassert.Equal(400, code, \"case 9: Add user status should be 400\")\n \t}\n-\n-\t// case 10: register a new user with admin auth, expect 201\n-\tfmt.Println(\"Register user with admin auth, right parameters\")\n \ttestUser0002.Comment = \"test user\"\n+\n+\t// case 10: register an admin using non-admin user, expect 403\n+\tt.Log(\"case 10: Register admin user with non admin auth\")\n+\ttestUser0002.HasAdminRole = true\n+\tcode, err = apiTest.UsersPost(testUser0002)\n+\tif err != nil {\n+\t\tt.Error(\"Error occurred while add a user\", err.Error())\n+\t\tt.Log(err)\n+\t} else {\n+\t\tassert.Equal(http.StatusForbidden, code, \"case 10: Add user status should be 403\")\n+\t}\n+\ttestUser0002.HasAdminRole = false\n+\n+\t// case 11: register a new user with admin auth, expect 201\n+\tt.Log(\"case 11: Register user with admin auth, right parameters\")\n \tcode, err = apiTest.UsersPost(testUser0002, *admin)\n \tif err != nil {\n \t\tt.Error(\"Error occurred while add a user\", err.Error())\n \t\tt.Log(err)\n \t} else {\n-\t\tassert.Equal(201, code, \"Add user status should be 201\")\n+\t\tassert.Equal(201, code, \"case 11: Add user status should be 201\")\n \t}\n \n-\t// case 11: register duplicate user with admin auth, expect 409\n-\tfmt.Println(\"Register duplicate user with admin auth\")\n+\t// case 12: register duplicate user with admin auth, expect 409\n+\tt.Log(\"case 12: Register duplicate user with admin auth\")\n \tcode, err = apiTest.UsersPost(testUser0002, *admin)\n \tif err != nil {\n \t\tt.Error(\"Error occurred while add a user\", err.Error())\n \t\tt.Log(err)\n \t} else {\n-\t\tassert.Equal(409, code, \"Add user status should be 409\")\n+\t\tassert.Equal(409, code, \"case 12: Add user status should be 409\")\n \t}\n \n-\t// case 12: register a new user with admin auth, but duplicate email, expect 409\n-\tfmt.Println(\"Register user with admin auth, but duplicate email\")\n+\t// case 13: register a new user with admin auth, but duplicate email, expect 409\n+\tt.Log(\"case 13: Register user with admin auth, but duplicate email\")\n \ttestUser0002.Username = \"testUsertest\"\n \ttestUser0002.Email = \"testUser0002@mydomain.com\"\n \tcode, err = apiTest.UsersPost(testUser0002, *admin)\n \tif err != nil {\n \t\tt.Error(\"Error occurred while add a user\", err.Error())\n \t\tt.Log(err)\n \t} else {\n-\t\tassert.Equal(409, code, \"Add user status should be 409\")\n+\t\tassert.Equal(409, code, \"case 13: Add user status should be 409\")\n \t}\n }\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "60798a49b334ae7822ec458063f63d46df0a1978",
            "date": "2025-01-14T09:49:50Z",
            "author_login": "stonezdj"
          },
          {
            "sha": "cc6ace188dae8eba4177ced9d8ddd205f6e3d0f3",
            "date": "2025-01-14T09:12:56Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "7c502a858100bd5087c1026d2d83cfbe7fde0be8",
            "date": "2025-01-14T06:48:50Z",
            "author_login": "stonezdj"
          },
          {
            "sha": "67654f26bf34eab40fd351d1ee496c9a97d5dcda",
            "date": "2025-01-14T03:54:26Z",
            "author_login": "stonezdj"
          },
          {
            "sha": "b0545c05fd0a70c589f21cdce0bf4e0e60842ed8",
            "date": "2025-01-10T09:02:57Z",
            "author_login": "wy65701436"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-862",
    "description": "core/api/user.go in Harbor 1.7.0 through 1.8.2 allows non-admin users to create admin accounts via the POST /api/users API, when Harbor is setup with DB as authentication backend and allow user to do self-registration. Fixed version: v1.7.6 v1.8.3. v.1.9.0. Workaround without applying the fix: configure Harbor to use non-DB authentication backend such as LDAP.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2019-09-08T16:15:11.820",
    "last_modified": "2024-11-21T04:30:01.773",
    "fix_date": "2019-08-27T01:42:52Z"
  },
  "references": [
    {
      "url": "http://www.vmware.com/security/advisories/VMSA-2019-0015.html",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/goharbor/harbor/commit/b6db8a8a106259ec9a2c48be8a380cb3b37cf517",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/goharbor/harbor/compare/v1.8.2...v1.9.0-rc1",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/goharbor/harbor/releases/tag/v1.7.6",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/goharbor/harbor/releases/tag/v1.8.3",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://unit42.paloaltonetworks.com/critical-vulnerability-in-harbor-enables-privilege-escalation-from-zero-to-admin-cve-2019-16097/",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.vmware.com/security/advisories/VMSA-2019-0015.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/goharbor/harbor/commit/b6db8a8a106259ec9a2c48be8a380cb3b37cf517",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/goharbor/harbor/compare/v1.8.2...v1.9.0-rc1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/goharbor/harbor/releases/tag/v1.7.6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/goharbor/harbor/releases/tag/v1.8.3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://unit42.paloaltonetworks.com/critical-vulnerability-in-harbor-enables-privilege-escalation-from-zero-to-admin-cve-2019-16097/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:57.309004",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "harbor",
    "owner": "goharbor",
    "created_at": "2016-01-28T21:10:28Z",
    "updated_at": "2025-01-14T12:26:50Z",
    "pushed_at": "2025-01-14T11:05:01Z",
    "size": 236439,
    "stars": 24632,
    "forks": 4793,
    "open_issues": 690,
    "watchers": 24632,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-0.5.0",
      "release-1.1.0",
      "release-1.2.0",
      "release-1.3.0",
      "release-1.4.0",
      "release-1.5.0",
      "release-1.6.0",
      "release-1.7.0",
      "release-1.8.0",
      "release-1.9.0"
    ],
    "languages": {
      "Go": 5831616,
      "TypeScript": 2181040,
      "HTML": 881556,
      "Python": 620594,
      "RobotFramework": 587125,
      "Jinja": 350205,
      "SCSS": 120201,
      "Shell": 72882,
      "Makefile": 35439,
      "Dockerfile": 12943,
      "PLpgSQL": 11799,
      "JavaScript": 7469,
      "CSS": 2078,
      "Smarty": 1931
    },
    "commit_activity": {
      "total_commits_last_year": 332,
      "avg_commits_per_week": 6.384615384615385,
      "days_active_last_year": 133
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:54:05.886679"
  }
}