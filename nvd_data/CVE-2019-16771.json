{
  "cve_id": "CVE-2019-16771",
  "github_data": {
    "repository": "line/armeria",
    "fix_commit": "b597f7a865a527a84ee3d6937075cfbb4470ed20",
    "related_commits": [
      "b597f7a865a527a84ee3d6937075cfbb4470ed20",
      "b597f7a865a527a84ee3d6937075cfbb4470ed20"
    ],
    "patch_url": "https://github.com/line/armeria/commit/b597f7a865a527a84ee3d6937075cfbb4470ed20.patch",
    "fix_commit_details": {
      "sha": "b597f7a865a527a84ee3d6937075cfbb4470ed20",
      "commit_date": "2019-12-05T09:35:47Z",
      "author": {
        "login": "trustin",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-35fr-h7jr-hh86",
        "length": 603,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 479,
        "additions": 395,
        "deletions": 84
      },
      "files": [
        {
          "filename": "core/src/main/java/com/linecorp/armeria/common/HttpHeaderNames.java",
          "status": "modified",
          "additions": 90,
          "deletions": 4,
          "patch": "@@ -32,10 +32,12 @@\n \n import java.lang.reflect.Field;\n import java.lang.reflect.Modifier;\n+import java.util.BitSet;\n import java.util.Map;\n \n import com.google.common.base.Ascii;\n import com.google.common.collect.ImmutableMap;\n+import com.google.common.math.IntMath;\n \n import io.netty.util.AsciiString;\n \n@@ -65,6 +67,35 @@ public final class HttpHeaderNames {\n     //   - Sec-Fetch-User\n     //   - Sec-Metadata\n \n+    private static final int PROHIBITED_NAME_CHAR_MASK = ~63;\n+    private static final BitSet PROHIBITED_NAME_CHARS = new BitSet(~PROHIBITED_NAME_CHAR_MASK + 1);\n+    private static final String[] PROHIBITED_NAME_CHAR_NAMES = new String[~PROHIBITED_NAME_CHAR_MASK + 1];\n+\n+    static {\n+        PROHIBITED_NAME_CHARS.set(0);\n+        PROHIBITED_NAME_CHARS.set('\\t');\n+        PROHIBITED_NAME_CHARS.set('\\n');\n+        PROHIBITED_NAME_CHARS.set(0xB);\n+        PROHIBITED_NAME_CHARS.set('\\f');\n+        PROHIBITED_NAME_CHARS.set('\\r');\n+        PROHIBITED_NAME_CHARS.set(' ');\n+        PROHIBITED_NAME_CHARS.set(',');\n+        PROHIBITED_NAME_CHARS.set(':');\n+        PROHIBITED_NAME_CHARS.set(';');\n+        PROHIBITED_NAME_CHARS.set('=');\n+        PROHIBITED_NAME_CHAR_NAMES[0] = \"<NUL>\";\n+        PROHIBITED_NAME_CHAR_NAMES['\\t'] = \"<TAB>\";\n+        PROHIBITED_NAME_CHAR_NAMES['\\n'] = \"<LF>\";\n+        PROHIBITED_NAME_CHAR_NAMES[0xB] = \"<VT>\";\n+        PROHIBITED_NAME_CHAR_NAMES['\\f'] = \"<FF>\";\n+        PROHIBITED_NAME_CHAR_NAMES['\\r'] = \"<CR>\";\n+        PROHIBITED_NAME_CHAR_NAMES[' '] = \"<SP>\";\n+        PROHIBITED_NAME_CHAR_NAMES[','] = \",\";\n+        PROHIBITED_NAME_CHAR_NAMES[':'] = \":\";\n+        PROHIBITED_NAME_CHAR_NAMES[';'] = \";\";\n+        PROHIBITED_NAME_CHAR_NAMES['='] = \"=\";\n+    }\n+\n     // Pseudo-headers\n \n     /**\n@@ -564,10 +595,16 @@ public final class HttpHeaderNames {\n         map = builder.build();\n     }\n \n+    private static AsciiString create(String name) {\n+        return AsciiString.cached(Ascii.toLowerCase(name));\n+    }\n+\n     /**\n      * Lower-cases and converts the specified header name into an {@link AsciiString}. If {@code \"name\"} is\n      * a known header name, this method will return a pre-instantiated {@link AsciiString} to reduce\n      * the allocation rate of {@link AsciiString}.\n+     *\n+     * @throws IllegalArgumentException if the specified {@code name} is not a valid header name.\n      */\n     public static AsciiString of(CharSequence name) {\n         if (name instanceof AsciiString) {\n@@ -576,22 +613,71 @@ public static AsciiString of(CharSequence name) {\n \n         final String lowerCased = Ascii.toLowerCase(requireNonNull(name, \"name\"));\n         final AsciiString cached = map.get(lowerCased);\n-        return cached != null ? cached : AsciiString.cached(lowerCased);\n+        if (cached != null) {\n+            return cached;\n+        }\n+\n+        return validate(AsciiString.cached(lowerCased));\n     }\n \n     /**\n      * Lower-cases and converts the specified header name into an {@link AsciiString}. If {@code \"name\"} is\n      * a known header name, this method will return a pre-instantiated {@link AsciiString} to reduce\n      * the allocation rate of {@link AsciiString}.\n+     *\n+     * @throws IllegalArgumentException if the specified {@code name} is not a valid header name.\n      */\n     public static AsciiString of(AsciiString name) {\n         final AsciiString lowerCased = name.toLowerCase();\n         final AsciiString cached = map.get(lowerCased);\n-        return cached != null ? cached : lowerCased;\n+        if (cached != null) {\n+            return cached;\n+        }\n+\n+        return validate(lowerCased);\n     }\n \n-    private static AsciiString create(String name) {\n-        return AsciiString.cached(Ascii.toLowerCase(name));\n+    private static AsciiString validate(AsciiString name) {\n+        if (name.isEmpty()) {\n+            throw new IllegalArgumentException(\"malformed header name: <EMPTY>\");\n+        }\n+\n+        final int lastIndex;\n+        try {\n+            lastIndex = name.forEachByte(value -> {\n+                if ((value & PROHIBITED_NAME_CHAR_MASK) != 0) { // value >= 64\n+                    return true;\n+                }\n+\n+                // value < 64\n+                return !PROHIBITED_NAME_CHARS.get(value);\n+            });\n+        } catch (Exception e) {\n+            throw new Error(e);\n+        }\n+\n+        if (lastIndex >= 0) {\n+            throw new IllegalArgumentException(malformedHeaderNameMessage(name));\n+        }\n+\n+        return name;\n+    }\n+\n+    private static String malformedHeaderNameMessage(AsciiString name) {\n+        final StringBuilder buf = new StringBuilder(IntMath.saturatedAdd(name.length(), 64));\n+        buf.append(\"malformed header name: \");\n+\n+        final int nameLength = name.length();\n+        for (int i = 0; i < nameLength; i++) {\n+            final char ch = name.charAt(i);\n+            if (PROHIBITED_NAME_CHARS.get(ch)) {\n+                buf.append(PROHIBITED_NAME_CHAR_NAMES[ch]);\n+            } else {\n+                buf.append(ch);\n+            }\n+        }\n+\n+        return buf.toString();\n     }\n \n     private HttpHeaderNames() {}"
        },
        {
          "filename": "core/src/main/java/com/linecorp/armeria/common/HttpHeadersBase.java",
          "status": "modified",
          "additions": 62,
          "deletions": 16,
          "patch": "@@ -29,7 +29,6 @@\n  */\n package com.linecorp.armeria.common;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n import static com.linecorp.armeria.internal.ArmeriaHttpUtil.isAbsoluteUri;\n import static io.netty.handler.codec.http2.Http2Headers.PseudoHeaderName.hasPseudoHeaderFormat;\n@@ -41,6 +40,7 @@\n import java.net.URI;\n import java.net.URISyntaxException;\n import java.util.Arrays;\n+import java.util.BitSet;\n import java.util.Date;\n import java.util.Iterator;\n import java.util.List;\n@@ -58,6 +58,7 @@\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Iterators;\n+import com.google.common.math.IntMath;\n \n import io.netty.handler.codec.DateFormatter;\n import io.netty.util.AsciiString;\n@@ -67,6 +68,23 @@\n  */\n class HttpHeadersBase implements HttpHeaderGetters {\n \n+    private static final int PROHIBITED_VALUE_CHAR_MASK = ~15;\n+    private static final BitSet PROHIBITED_VALUE_CHARS = new BitSet(~PROHIBITED_VALUE_CHAR_MASK + 1);\n+    private static final String[] PROHIBITED_VALUE_CHAR_NAMES = new String[~PROHIBITED_VALUE_CHAR_MASK + 1];\n+\n+    static {\n+        PROHIBITED_VALUE_CHARS.set(0);\n+        PROHIBITED_VALUE_CHARS.set('\\n');\n+        PROHIBITED_VALUE_CHARS.set(0xB);\n+        PROHIBITED_VALUE_CHARS.set('\\f');\n+        PROHIBITED_VALUE_CHARS.set('\\r');\n+        PROHIBITED_VALUE_CHAR_NAMES[0] = \"<NUL>\";\n+        PROHIBITED_VALUE_CHAR_NAMES['\\n'] = \"<LF>\";\n+        PROHIBITED_VALUE_CHAR_NAMES[0xB] = \"<VT>\";\n+        PROHIBITED_VALUE_CHAR_NAMES['\\f'] = \"<FF>\";\n+        PROHIBITED_VALUE_CHAR_NAMES['\\r'] = \"<CR>\";\n+    }\n+\n     static final int DEFAULT_SIZE_HINT = 16;\n \n     /**\n@@ -545,15 +563,15 @@ final long getTimeMillisAndRemove(CharSequence name, long defaultValue) {\n     }\n \n     final void add(CharSequence name, String value) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(value, \"value\");\n         final int h = normalizedName.hashCode();\n         final int i = index(h);\n         add0(h, i, normalizedName, value);\n     }\n \n     final void add(CharSequence name, Iterable<String> values) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(values, \"values\");\n         final int h = normalizedName.hashCode();\n         final int i = index(h);\n@@ -564,7 +582,7 @@ final void add(CharSequence name, Iterable<String> values) {\n     }\n \n     final void add(CharSequence name, String... values) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(values, \"values\");\n         final int h = normalizedName.hashCode();\n         final int i = index(h);\n@@ -590,7 +608,7 @@ final void addObject(CharSequence name, Object value) {\n     }\n \n     final void addObject(CharSequence name, Iterable<?> values) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(values, \"values\");\n         for (Object v : values) {\n             requireNonNullElement(values, v);\n@@ -599,7 +617,7 @@ final void addObject(CharSequence name, Iterable<?> values) {\n     }\n \n     final void addObject(CharSequence name, Object... values) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(values, \"values\");\n         for (Object v : values) {\n             requireNonNullElement(values, v);\n@@ -638,7 +656,7 @@ final void addTimeMillis(CharSequence name, long value) {\n     }\n \n     final void set(CharSequence name, String value) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(value, \"value\");\n         final int h = normalizedName.hashCode();\n         final int i = index(h);\n@@ -647,7 +665,7 @@ final void set(CharSequence name, String value) {\n     }\n \n     final void set(CharSequence name, Iterable<String> values) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(values, \"values\");\n \n         final int h = normalizedName.hashCode();\n@@ -661,7 +679,7 @@ final void set(CharSequence name, Iterable<String> values) {\n     }\n \n     final void set(CharSequence name, String... values) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(values, \"values\");\n \n         final int h = normalizedName.hashCode();\n@@ -739,7 +757,7 @@ final void setObject(CharSequence name, Object value) {\n     }\n \n     final void setObject(CharSequence name, Iterable<?> values) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(values, \"values\");\n \n         final int h = normalizedName.hashCode();\n@@ -753,7 +771,7 @@ final void setObject(CharSequence name, Iterable<?> values) {\n     }\n \n     final void setObject(CharSequence name, Object... values) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(values, \"values\");\n \n         final int h = normalizedName.hashCode();\n@@ -813,11 +831,6 @@ final void clear() {\n         size = 0;\n     }\n \n-    private static AsciiString normalizeName(CharSequence name) {\n-        checkArgument(requireNonNull(name, \"name\").length() > 0, \"name is empty.\");\n-        return HttpHeaderNames.of(name);\n-    }\n-\n     private static void requireNonNullElement(Object values, @Nullable Object e) {\n         if (e == null) {\n             throw new NullPointerException(\"values contains null: \" + values);\n@@ -829,11 +842,44 @@ private int index(int hash) {\n     }\n \n     private void add0(int h, int i, AsciiString name, String value) {\n+        validateValue(value);\n         // Update the hash table.\n         entries[i] = new HeaderEntry(h, name, value, entries[i]);\n         ++size;\n     }\n \n+    private static void validateValue(String value) {\n+        final int valueLength = value.length();\n+        for (int i = 0; i < valueLength; i++) {\n+            final char ch = value.charAt(i);\n+            if ((ch & PROHIBITED_VALUE_CHAR_MASK) != 0) { // ch >= 16\n+                continue;\n+            }\n+\n+            // ch < 16\n+            if (PROHIBITED_VALUE_CHARS.get(ch)) {\n+                throw new IllegalArgumentException(malformedHeaderValueMessage(value));\n+            }\n+        }\n+    }\n+\n+    private static String malformedHeaderValueMessage(String value) {\n+        final StringBuilder buf = new StringBuilder(IntMath.saturatedAdd(value.length(), 64));\n+        buf.append(\"malformed header value: \");\n+\n+        final int valueLength = value.length();\n+        for (int i = 0; i < valueLength; i++) {\n+            final char ch = value.charAt(i);\n+            if (PROHIBITED_VALUE_CHARS.get(ch)) {\n+                buf.append(PROHIBITED_VALUE_CHAR_NAMES[ch]);\n+            } else {\n+                buf.append(ch);\n+            }\n+        }\n+\n+        return buf.toString();\n+    }\n+\n     private boolean addFast(Iterable<? extends Entry<? extends CharSequence, ?>> headers) {\n         if (!(headers instanceof HttpHeadersBase)) {\n             return false;"
        },
        {
          "filename": "core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -673,7 +673,7 @@ private static CharSequenceMap toLowercaseMap(Iterator<? extends CharSequence> v\n         final CharSequenceMap result = new CharSequenceMap(arraySizeHint);\n \n         while (valuesIter.hasNext()) {\n-            final AsciiString lowerCased = HttpHeaderNames.of(valuesIter.next()).toLowerCase();\n+            final AsciiString lowerCased = AsciiString.of(valuesIter.next()).toLowerCase();\n             try {\n                 int index = lowerCased.forEachByte(FIND_COMMA);\n                 if (index != -1) {"
        },
        {
          "filename": "core/src/test/java/com/linecorp/armeria/common/HttpHeaderNamesTest.java",
          "status": "modified",
          "additions": 60,
          "deletions": 4,
          "patch": "@@ -16,15 +16,16 @@\n package com.linecorp.armeria.common;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n \n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n import io.netty.util.AsciiString;\n \n-public class HttpHeaderNamesTest {\n+class HttpHeaderNamesTest {\n \n     @Test\n-    public void testOfAsciiString() {\n+    void testOfAsciiString() {\n         // Should produce a lower-cased AsciiString.\n         final AsciiString mixedCased = AsciiString.of(\"Foo\");\n         assertThat((Object) HttpHeaderNames.of(mixedCased)).isNotSameAs(mixedCased);\n@@ -39,11 +40,66 @@ public void testOfAsciiString() {\n     }\n \n     @Test\n-    public void testOfCharSequence() {\n+    void testOfCharSequence() {\n         // Should produce a lower-cased AsciiString.\n         assertThat((Object) HttpHeaderNames.of(\"Foo\")).isEqualTo(AsciiString.of(\"foo\"));\n \n         // Should reuse known header name instances.\n         assertThat((Object) HttpHeaderNames.of(\"date\")).isSameAs(HttpHeaderNames.DATE);\n     }\n+\n+    @Test\n+    void pseudoHeaderNameValidation() {\n+        // Known pseudo header names should pass validation.\n+        assertThat((Object) HttpHeaderNames.of(\":method\")).isSameAs(HttpHeaderNames.METHOD);\n+        assertThat((Object) HttpHeaderNames.of(\":scheme\")).isSameAs(HttpHeaderNames.SCHEME);\n+        assertThat((Object) HttpHeaderNames.of(\":authority\")).isSameAs(HttpHeaderNames.AUTHORITY);\n+        assertThat((Object) HttpHeaderNames.of(\":path\")).isSameAs(HttpHeaderNames.PATH);\n+        assertThat((Object) HttpHeaderNames.of(\":status\")).isSameAs(HttpHeaderNames.STATUS);\n+\n+        // However, any other headers that start with `:` should fail.\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\":foo\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: :foo\");\n+    }\n+\n+    @Test\n+    void headerNameValidation() {\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\"\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <EMPTY>\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\"\\u0000\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <NUL>\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\"\\t\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <TAB>\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\"\\n\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <LF>\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\"\\u000B\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <VT>\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\"\\f\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <FF>\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\"\\r\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <CR>\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\" \"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <SP>\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\",\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: ,\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\":\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: :\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\";\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: ;\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\"=\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: =\");\n+    }\n }"
        },
        {
          "filename": "core/src/test/java/com/linecorp/armeria/common/HttpHeadersBaseTest.java",
          "status": "modified",
          "additions": 81,
          "deletions": 59,
          "patch": "@@ -31,25 +31,25 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatThrownBy;\n-import static org.junit.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.fail;\n \n import java.net.URI;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.NoSuchElementException;\n \n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n import com.google.common.collect.ImmutableList;\n \n import io.netty.handler.codec.http2.Http2Headers.PseudoHeaderName;\n import io.netty.util.AsciiString;\n \n-public class HttpHeadersBaseTest {\n+class HttpHeadersBaseTest {\n \n     @Test\n-    public void testEqualsInsertionOrderSameHeaderName() {\n+    void testEqualsInsertionOrderSameHeaderName() {\n         final HttpHeadersBase h1 = newEmptyHeaders();\n         h1.add(\"a\", \"b\");\n         h1.add(\"a\", \"c\");\n@@ -60,7 +60,7 @@ public void testEqualsInsertionOrderSameHeaderName() {\n     }\n \n     @Test\n-    public void testEqualsInsertionOrderDifferentHeaderNames() {\n+    void testEqualsInsertionOrderDifferentHeaderNames() {\n         final HttpHeadersBase h1 = newEmptyHeaders();\n         h1.add(\"a\", \"b\");\n         h1.add(\"c\", \"d\");\n@@ -73,7 +73,7 @@ public void testEqualsInsertionOrderDifferentHeaderNames() {\n     // Tests forked from io.netty.handler.codec.DefaultHeadersTest\n \n     @Test\n-    public void addShouldIncreaseAndRemoveShouldDecreaseTheSize() {\n+    void addShouldIncreaseAndRemoveShouldDecreaseTheSize() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         assertThat(headers.size()).isEqualTo(0);\n         headers.add(\"name1\", \"value1\", \"value2\");\n@@ -93,7 +93,7 @@ public void addShouldIncreaseAndRemoveShouldDecreaseTheSize() {\n     }\n \n     @Test\n-    public void afterClearHeadersShouldBeEmpty() {\n+    void afterClearHeadersShouldBeEmpty() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\");\n         headers.add(\"name2\", \"value2\");\n@@ -106,7 +106,7 @@ public void afterClearHeadersShouldBeEmpty() {\n     }\n \n     @Test\n-    public void removingANameForASecondTimeShouldReturnFalse() {\n+    void removingANameForASecondTimeShouldReturnFalse() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\");\n         headers.add(\"name2\", \"value2\");\n@@ -115,7 +115,7 @@ public void removingANameForASecondTimeShouldReturnFalse() {\n     }\n \n     @Test\n-    public void multipleValuesPerNameShouldBeAllowed() {\n+    void multipleValuesPerNameShouldBeAllowed() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name\", \"value1\");\n         headers.add(\"name\", \"value2\");\n@@ -128,7 +128,7 @@ public void multipleValuesPerNameShouldBeAllowed() {\n     }\n \n     @Test\n-    public void multipleValuesPerNameIteratorWithOtherNames() {\n+    void multipleValuesPerNameIteratorWithOtherNames() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\");\n         headers.add(\"name1\", \"value2\");\n@@ -146,7 +146,7 @@ public void multipleValuesPerNameIteratorWithOtherNames() {\n     }\n \n     @Test\n-    public void multipleValuesPerNameIterator() {\n+    void multipleValuesPerNameIterator() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\");\n         headers.add(\"name1\", \"value2\");\n@@ -157,15 +157,15 @@ public void multipleValuesPerNameIterator() {\n     }\n \n     @Test\n-    public void multipleValuesPerNameIteratorEmpty() {\n+    void multipleValuesPerNameIteratorEmpty() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         assertThat(headers.valueIterator(\"name\")).isExhausted();\n         assertThatThrownBy(() -> headers.valueIterator(\"name\").next())\n                 .isInstanceOf(NoSuchElementException.class);\n     }\n \n     @Test\n-    public void testContains() {\n+    void testContains() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n \n         headers.addLong(\"long\", Long.MAX_VALUE);\n@@ -200,7 +200,7 @@ public void testContains() {\n     }\n \n     @Test\n-    public void testCopy() throws Exception {\n+    void testCopy() throws Exception {\n         HttpHeadersBase headers = newEmptyHeaders();\n         headers.addLong(\"long\", Long.MAX_VALUE);\n         headers.addInt(\"int\", Integer.MIN_VALUE);\n@@ -239,7 +239,7 @@ public void testCopy() throws Exception {\n     }\n \n     @Test\n-    public void canMixConvertedAndNormalValues() {\n+    void canMixConvertedAndNormalValues() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name\", \"value\");\n         headers.addInt(\"name\", 100);\n@@ -251,7 +251,7 @@ public void canMixConvertedAndNormalValues() {\n     }\n \n     @Test\n-    public void testGetAndRemove() {\n+    void testGetAndRemove() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\");\n         headers.add(\"name2\", \"value2\", \"value3\");\n@@ -267,14 +267,14 @@ public void testGetAndRemove() {\n     }\n \n     @Test\n-    public void whenNameContainsMultipleValuesGetShouldReturnTheFirst() {\n+    void whenNameContainsMultipleValuesGetShouldReturnTheFirst() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\", \"value2\");\n         assertThat(headers.get(\"name1\")).isEqualTo(\"value1\");\n     }\n \n     @Test\n-    public void getWithDefaultValueWorks() {\n+    void getWithDefaultValueWorks() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\");\n \n@@ -283,7 +283,7 @@ public void getWithDefaultValueWorks() {\n     }\n \n     @Test\n-    public void setShouldOverWritePreviousValue() {\n+    void setShouldOverWritePreviousValue() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.set(\"name\", \"value1\");\n         headers.set(\"name\", \"value2\");\n@@ -294,7 +294,7 @@ public void setShouldOverWritePreviousValue() {\n     }\n \n     @Test\n-    public void setAllShouldOverwriteSomeAndLeaveOthersUntouched() {\n+    void setAllShouldOverwriteSomeAndLeaveOthersUntouched() {\n         final HttpHeadersBase h1 = newEmptyHeaders();\n \n         h1.add(\"name1\", \"value1\");\n@@ -319,7 +319,7 @@ public void setAllShouldOverwriteSomeAndLeaveOthersUntouched() {\n     }\n \n     @Test\n-    public void headersWithSameNamesAndValuesShouldBeEquivalent() {\n+    void headersWithSameNamesAndValuesShouldBeEquivalent() {\n         final HttpHeadersBase headers1 = newEmptyHeaders();\n         headers1.add(\"name1\", \"value1\");\n         headers1.add(\"name2\", \"value2\");\n@@ -340,15 +340,15 @@ public void headersWithSameNamesAndValuesShouldBeEquivalent() {\n     }\n \n     @Test\n-    public void emptyHeadersShouldBeEqual() {\n+    void emptyHeadersShouldBeEqual() {\n         final HttpHeadersBase headers1 = newEmptyHeaders();\n         final HttpHeadersBase headers2 = newEmptyHeaders();\n         assertThat(headers2).isEqualTo(headers1);\n         assertThat(headers2.hashCode()).isEqualTo(headers1.hashCode());\n     }\n \n     @Test\n-    public void headersWithSameNamesButDifferentValuesShouldNotBeEquivalent() {\n+    void headersWithSameNamesButDifferentValuesShouldNotBeEquivalent() {\n         final HttpHeadersBase headers1 = newEmptyHeaders();\n         headers1.add(\"name1\", \"value1\");\n         final HttpHeadersBase headers2 = newEmptyHeaders();\n@@ -357,7 +357,7 @@ public void headersWithSameNamesButDifferentValuesShouldNotBeEquivalent() {\n     }\n \n     @Test\n-    public void subsetOfHeadersShouldNotBeEquivalent() {\n+    void subsetOfHeadersShouldNotBeEquivalent() {\n         final HttpHeadersBase headers1 = newEmptyHeaders();\n         headers1.add(\"name1\", \"value1\");\n         headers1.add(\"name2\", \"value2\");\n@@ -367,7 +367,7 @@ public void subsetOfHeadersShouldNotBeEquivalent() {\n     }\n \n     @Test\n-    public void headersWithDifferentNamesAndValuesShouldNotBeEquivalent() {\n+    void headersWithDifferentNamesAndValuesShouldNotBeEquivalent() {\n         final HttpHeadersBase h1 = newEmptyHeaders();\n         h1.set(\"name1\", \"value1\");\n         final HttpHeadersBase h2 = newEmptyHeaders();\n@@ -378,15 +378,15 @@ public void headersWithDifferentNamesAndValuesShouldNotBeEquivalent() {\n         assertThat(h2).isEqualTo(h2);\n     }\n \n-    @Test(expected = NoSuchElementException.class)\n-    public void iterateEmptyHeadersShouldThrow() {\n+    @Test\n+    void iterateEmptyHeadersShouldThrow() {\n         final Iterator<Map.Entry<AsciiString, String>> iterator = newEmptyHeaders().iterator();\n         assertThat(iterator.hasNext()).isFalse();\n-        iterator.next();\n+        assertThatThrownBy(iterator::next).isInstanceOf(NoSuchElementException.class);\n     }\n \n     @Test\n-    public void iteratorShouldReturnAllNameValuePairs() {\n+    void iteratorShouldReturnAllNameValuePairs() {\n         final HttpHeadersBase headers1 = newEmptyHeaders();\n         headers1.add(\"name1\", \"value1\", \"value2\");\n         headers1.add(\"name2\", \"value3\");\n@@ -403,7 +403,7 @@ public void iteratorShouldReturnAllNameValuePairs() {\n     }\n \n     @Test\n-    public void iteratorSetShouldFail() {\n+    void iteratorSetShouldFail() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\", \"value2\", \"value3\");\n         headers.add(\"name2\", \"value4\");\n@@ -414,7 +414,7 @@ public void iteratorSetShouldFail() {\n     }\n \n     @Test\n-    public void testEntryEquals() {\n+    void testEntryEquals() {\n         final HttpHeadersBase nameValue = newEmptyHeaders();\n         nameValue.add(\"name\", \"value\");\n         final HttpHeadersBase nameValueCopy = newEmptyHeaders();\n@@ -444,13 +444,13 @@ public void testEntryEquals() {\n     }\n \n     @Test\n-    public void getAllReturnsEmptyListForUnknownName() {\n+    void getAllReturnsEmptyListForUnknownName() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         assertThat(headers.getAll(\"noname\").size()).isEqualTo(0);\n     }\n \n     @Test\n-    public void setHeadersShouldClearAndOverwrite() {\n+    void setHeadersShouldClearAndOverwrite() {\n         final HttpHeadersBase headers1 = newEmptyHeaders();\n         headers1.add(\"name\", \"value\");\n \n@@ -463,7 +463,7 @@ public void setHeadersShouldClearAndOverwrite() {\n     }\n \n     @Test\n-    public void setHeadersShouldOnlyOverwriteHeaders() {\n+    void setHeadersShouldOnlyOverwriteHeaders() {\n         final HttpHeadersBase headers1 = newEmptyHeaders();\n         headers1.add(\"name\", \"value\");\n         headers1.add(\"name1\", \"value1\");\n@@ -481,22 +481,22 @@ public void setHeadersShouldOnlyOverwriteHeaders() {\n         assertThat(expected).isEqualTo(headers1);\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n-    public void testAddSelf() {\n+    @Test\n+    void testAddSelf() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n-        headers.add(headers);\n+        assertThatThrownBy(() -> headers.add(headers)).isInstanceOf(IllegalArgumentException.class);\n     }\n \n     @Test\n-    public void testSetSelfIsNoOp() {\n+    void testSetSelfIsNoOp() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name\", \"value\");\n         headers.set(headers);\n         assertThat(headers.size()).isEqualTo(1);\n     }\n \n     @Test\n-    public void testToString() {\n+    void testToString() {\n         HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\");\n         headers.add(\"name1\", \"value2\");\n@@ -527,7 +527,7 @@ public void testToString() {\n     }\n \n     @Test\n-    public void testNotThrowWhenConvertFails() {\n+    void testNotThrowWhenConvertFails() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.set(\"name1\", \"\");\n         assertThat(headers.getInt(\"name1\")).isNull();\n@@ -546,10 +546,30 @@ public void testNotThrowWhenConvertFails() {\n         assertThat(headers.getTimeMillis(\"name1\", Long.MAX_VALUE)).isEqualTo(Long.MAX_VALUE);\n     }\n \n+    @Test\n+    void valueValidation() {\n+        final HttpHeadersBase headers = newEmptyHeaders();\n+        assertThatThrownBy(() -> headers.add(\"foo\", \"\\u0000\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header value: <NUL>\");\n+        assertThatThrownBy(() -> headers.add(\"foo\", \"\\n\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header value: <LF>\");\n+        assertThatThrownBy(() -> headers.add(\"foo\", \"\\u000B\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header value: <VT>\");\n+        assertThatThrownBy(() -> headers.add(\"foo\", \"\\f\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header value: <FF>\");\n+        assertThatThrownBy(() -> headers.add(\"foo\", \"\\r\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header value: <CR>\");\n+    }\n+\n     // Tests forked from io.netty.handler.codec.http.HttpHeadersTest\n \n     @Test\n-    public void testGetOperations() {\n+    void testGetOperations() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"Foo\", \"1\");\n         headers.add(\"Foo\", \"2\");\n@@ -560,33 +580,35 @@ public void testGetOperations() {\n         assertThat(values).containsExactly(\"1\", \"2\");\n     }\n \n-    @Test(expected = NullPointerException.class)\n-    public void testSetNullHeaderValue() {\n-        final HttpHeadersBase headers = newEmptyHeaders();\n-        headers.set(\"test\", (String) null);\n+    @Test\n+    void testSetNullHeaderValue() {\n+        assertThatThrownBy(() -> newEmptyHeaders().set(\"test\", (String) null))\n+                .isInstanceOf(NullPointerException.class);\n     }\n \n     // Tests forked from io.netty.handler.codec.http2.DefaultHttp2HeadersTest\n \n-    @Test(expected = NullPointerException.class)\n-    public void nullHeaderNameNotAllowed() {\n-        newEmptyHeaders().add(null, \"foo\");\n+    @Test\n+    void nullHeaderNameNotAllowed() {\n+        assertThatThrownBy(() -> newEmptyHeaders().add(null, \"foo\")).isInstanceOf(NullPointerException.class);\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n-    public void emptyHeaderNameNotAllowed() {\n-        newEmptyHeaders().add(\"\", \"foo\");\n+    @Test\n+    void emptyHeaderNameNotAllowed() {\n+        assertThatThrownBy(() -> newEmptyHeaders().add(\"\", \"foo\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <EMPTY>\");\n     }\n \n     @Test\n-    public void testPseudoHeadersMustComeFirstWhenIterating() {\n+    void testPseudoHeadersMustComeFirstWhenIterating() {\n         final HttpHeadersBase headers = newHttp2Headers();\n         verifyPseudoHeadersFirst(headers);\n         verifyAllPseudoHeadersPresent(headers);\n     }\n \n     @Test\n-    public void testPseudoHeadersWithRemovePreservesPseudoIterationOrder() {\n+    void testPseudoHeadersWithRemovePreservesPseudoIterationOrder() {\n         final HttpHeadersBase headers = newHttp2Headers();\n         final HttpHeadersBase nonPseudoHeaders = newEmptyHeaders();\n         for (Map.Entry<AsciiString, String> entry : headers) {\n@@ -614,7 +636,7 @@ public void testPseudoHeadersWithRemovePreservesPseudoIterationOrder() {\n     }\n \n     @Test\n-    public void testPseudoHeadersWithClearDoesNotLeak() {\n+    void testPseudoHeadersWithClearDoesNotLeak() {\n         final HttpHeadersBase headers = newHttp2Headers();\n \n         assertThat(headers.isEmpty()).isFalse();\n@@ -643,7 +665,7 @@ public void testPseudoHeadersWithClearDoesNotLeak() {\n     }\n \n     @Test\n-    public void testSetOrdersPseudoHeadersCorrectly() {\n+    void testSetOrdersPseudoHeadersCorrectly() {\n         final HttpHeadersBase headers = newHttp2Headers();\n         final HttpHeadersBase other = newEmptyHeaders();\n         other.add(\"name2\", \"value2\");\n@@ -663,7 +685,7 @@ public void testSetOrdersPseudoHeadersCorrectly() {\n     }\n \n     @Test\n-    public void testHeaderNameNormalization() {\n+    void testHeaderNameNormalization() {\n         final HttpHeadersBase headers = newHttp2Headers();\n         headers.add(\"Foo\", \"bar\");\n         assertThat(headers.getAll(\"foo\")).containsExactly(\"bar\");\n@@ -673,7 +695,7 @@ public void testHeaderNameNormalization() {\n     }\n \n     @Test\n-    public void testClearResetsPseudoHeaderDivision() {\n+    void testClearResetsPseudoHeaderDivision() {\n         final HttpHeadersBase http2Headers = newHttp2Headers();\n         http2Headers.method(HttpMethod.POST);\n         http2Headers.set(\"some\", \"value\");\n@@ -684,7 +706,7 @@ public void testClearResetsPseudoHeaderDivision() {\n     }\n \n     @Test\n-    public void testContainsNameAndValue() {\n+    void testContainsNameAndValue() {\n         final HttpHeadersBase headers = newHttp2Headers();\n         assertThat(headers.contains(\"name1\", \"value2\")).isTrue();\n         assertThat(headers.contains(\"name1\", \"Value2\")).isFalse();\n@@ -693,7 +715,7 @@ public void testContainsNameAndValue() {\n     }\n \n     @Test\n-    public void testUri() {\n+    void testUri() {\n         final HttpHeadersBase headers = newHttp2Headers();\n         assertThat(headers.uri()).isEqualTo(URI.create(\"https://netty.io/index.html\"));\n     }"
        },
        {
          "filename": "core/src/test/java/com/linecorp/armeria/server/HttpServerHeaderValidationTest.java",
          "status": "added",
          "additions": 101,
          "deletions": 0,
          "patch": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2016 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server;\n+\n+import static com.linecorp.armeria.common.SessionProtocol.H1;\n+import static com.linecorp.armeria.common.SessionProtocol.H1C;\n+import static com.linecorp.armeria.common.SessionProtocol.H2;\n+import static com.linecorp.armeria.common.SessionProtocol.H2C;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Timeout;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n+\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.testing.junit.server.ServerExtension;\n+\n+import io.netty.handler.codec.http.QueryStringDecoder;\n+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n+\n+@Timeout(10000)\n+class HttpServerHeaderValidationTest {\n+\n+    static final ClientFactory clientFactory = ClientFactory.builder().sslContextCustomizer(scb -> {\n+        scb.trustManager(InsecureTrustManagerFactory.INSTANCE);\n+    }).build();\n+\n+    @RegisterExtension\n+    static final ServerExtension server = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.http(0);\n+            sb.https(0);\n+            sb.tlsSelfSigned();\n+\n+            sb.route().get(\"/headers-custom\")\n+              .build((ctx, req) -> {\n+                  final String param = new QueryStringDecoder(req.path()).parameters()\n+                                                                         .get(\"param\").get(0);\n+                  return HttpResponse.of(\n+                          ResponseHeaders.of(HttpStatus.OK, \"server-header\", param),\n+                          HttpData.ofUtf8(\"OK\"));\n+              });\n+        }\n+    };\n+\n+    @AfterAll\n+    static void closeClientFactory() {\n+        clientFactory.close();\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(WebClientProvider.class)\n+    void malformedHeaderValue(WebClient client) throws Exception {\n+        final String payloadRaw = \"my-header\\r\\nnot-a-header: should_be_illegal\";\n+        final String payload = URLEncoder.encode(payloadRaw, StandardCharsets.US_ASCII.name());\n+        final String path = \"/headers-custom?param=\" + payload;\n+        final AggregatedHttpResponse res = client.get(path).aggregate().get();\n+        assertThat(res.status()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);\n+        assertThat(res.headers().get(\"not-a-header\")).isNull();\n+    }\n+\n+    private static class WebClientProvider implements ArgumentsProvider {\n+        @Override\n+        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {\n+            return Stream.of(H1C, H1, H2C, H2)\n+                         .map(protocol -> Arguments.of(WebClient.of(\n+                                 clientFactory,\n+                                 protocol.uriText() + \"://127.0.0.1:\" +\n+                                 (protocol.isTls() ? server.httpsPort() : server.httpPort()))));\n+        }\n+    }\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 4,
        "max_directory_depth": 8
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "65629276366b5eb7c1094bb492759789094f437a",
            "date": "2025-01-14T02:52:48Z",
            "author_login": "ikhoon"
          },
          {
            "sha": "8ae035e0b7f42e314c35a2148e75df9558465735",
            "date": "2025-01-14T02:51:54Z",
            "author_login": "minwoox"
          },
          {
            "sha": "bbb0571ed0845a5872c4c63dc476bf6ce6b8396b",
            "date": "2025-01-14T02:48:03Z",
            "author_login": "ikhoon"
          },
          {
            "sha": "68ba43d431e67015d7460d601ef56c90dc684f4e",
            "date": "2025-01-14T02:37:02Z",
            "author_login": "ikhoon"
          },
          {
            "sha": "d7a4d293924f50cec7138f575193f76cb2352593",
            "date": "2025-01-11T10:06:05Z",
            "author_login": "github-actions[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N",
    "cwe_id": "CWE-113",
    "description": "Versions of Armeria 0.85.0 through and including 0.96.0 are vulnerable to HTTP response splitting, which allows remote attackers to inject arbitrary HTTP headers via CRLF sequences when unsanitized data is used to populate the headers of an HTTP response. This vulnerability has been patched in 0.97.0. Potential impacts of this vulnerability include cross-user defacement, cache poisoning, Cross-site scripting (XSS), and page hijacking.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2019-12-06T19:15:10.787",
    "last_modified": "2024-11-21T04:31:09.460",
    "fix_date": "2019-12-05T09:35:47Z"
  },
  "references": [
    {
      "url": "https://github.com/line/armeria/commit/b597f7a865a527a84ee3d6937075cfbb4470ed20",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/line/armeria/security/advisories/GHSA-35fr-h7jr-hh86",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/line/armeria/commit/b597f7a865a527a84ee3d6937075cfbb4470ed20",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/line/armeria/security/advisories/GHSA-35fr-h7jr-hh86",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:24.249115",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "armeria",
    "owner": "line",
    "created_at": "2015-11-16T04:04:01Z",
    "updated_at": "2025-01-14T10:26:52Z",
    "pushed_at": "2025-01-14T06:11:16Z",
    "size": 243017,
    "stars": 4854,
    "forks": 925,
    "open_issues": 678,
    "watchers": 4854,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Java": 21571056,
      "MDX": 1120492,
      "TypeScript": 278598,
      "Thrift": 257694,
      "Scala": 238820,
      "Kotlin": 156259,
      "Less": 35351,
      "JavaScript": 26455,
      "Shell": 2062,
      "HTML": 1222,
      "CSS": 820
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:33:35.165360"
  }
}