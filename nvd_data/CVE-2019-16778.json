{
  "cve_id": "CVE-2019-16778",
  "github_data": {
    "repository": "tensorflow/tensorflow",
    "fix_commit": "db4f9717c41bccc3ce10099ab61996b246099892",
    "related_commits": [
      "db4f9717c41bccc3ce10099ab61996b246099892",
      "db4f9717c41bccc3ce10099ab61996b246099892"
    ],
    "patch_url": "https://github.com/tensorflow/tensorflow/commit/db4f9717c41bccc3ce10099ab61996b246099892.patch",
    "fix_commit_details": {
      "sha": "db4f9717c41bccc3ce10099ab61996b246099892",
      "commit_date": "2019-07-03T22:45:01Z",
      "author": {
        "login": "rryan",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix heap buffer overflow in UnsortedSegmentSum.",
        "length": 567,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 65,
        "additions": 32,
        "deletions": 33
      },
      "files": [
        {
          "filename": "tensorflow/core/kernels/segment_reduction_ops.cc",
          "status": "modified",
          "additions": 9,
          "deletions": 10,
          "patch": "@@ -376,18 +376,17 @@ namespace functor {\n template <typename T, typename Index, typename InitialValueF,\n           typename ReductionF>\n struct UnsortedSegmentFunctor<CPUDevice, T, Index, InitialValueF, ReductionF> {\n-  void operator()(OpKernelContext* ctx, const Index num_segments,\n-                  const TensorShape& segment_ids_shape,\n+  void operator()(OpKernelContext* ctx, const TensorShape& segment_ids_shape,\n                   typename TTypes<Index>::ConstFlat segment_ids,\n-                  const Index data_size, const T* data,\n+                  typename TTypes<T, 2>::ConstTensor data,\n                   typename TTypes<T, 2>::Tensor output) {\n     output.setConstant(InitialValueF()());\n-    if (data_size == 0) {\n+    if (data.size() == 0) {\n       return;\n     }\n     const int64 N = segment_ids.dimension(0);\n+    const int64 num_segments = output.dimension(0);\n     ReductionF reduction;\n-    auto data_flat = typename TTypes<T, 2>::ConstTensor(data, N, data_size / N);\n     for (int64 i = 0; i < N; ++i) {\n       Index j = internal::SubtleMustCopy(segment_ids(i));\n       if (j < 0) {\n@@ -397,7 +396,7 @@ struct UnsortedSegmentFunctor<CPUDevice, T, Index, InitialValueF, ReductionF> {\n                   errors::InvalidArgument(\n                       \"segment_ids\", SliceDebugString(segment_ids_shape, i),\n                       \" = \", j, \" is out of range [0, \", num_segments, \")\"));\n-      reduction(data_flat.template chip<0>(i), output.template chip<0>(j));\n+      reduction(data.template chip<0>(i), output.template chip<0>(j));\n     }\n   }\n };\n@@ -485,7 +484,7 @@ class UnsortedSegmentReductionOp : public OpKernel {\n       return;\n     }\n     const auto segment_flat = segment_ids.flat<Index>();\n-    const Index output_rows = internal::SubtleMustCopy(static_cast<Index>(\n+    const int64 output_rows = internal::SubtleMustCopy(static_cast<int64>(\n         num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()()\n                                          : num_segments.scalar<int64>()()));\n     OP_REQUIRES(context, output_rows >= 0,\n@@ -499,9 +498,9 @@ class UnsortedSegmentReductionOp : public OpKernel {\n     Tensor* output = nullptr;\n     OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n     auto output_flat = output->flat_outer_dims<T>();\n-    auto data_ptr = data.template flat<T>().data();\n-    reduction_functor_(context, output_rows, segment_ids.shape(), segment_flat,\n-                       data.NumElements(), data_ptr, output_flat);\n+    auto data_flat = data.flat_inner_outer_dims<T, 2>(segment_ids.dims() - 1);\n+    reduction_functor_(context, segment_ids.shape(), segment_flat, data_flat,\n+                       output_flat);\n   }\n \n  protected:"
        },
        {
          "filename": "tensorflow/core/kernels/segment_reduction_ops.h",
          "status": "modified",
          "additions": 2,
          "deletions": 3,
          "patch": "@@ -59,10 +59,9 @@ struct SegmentSumFunctor {\n template <typename Device, typename T, typename Index, typename InitialValueF,\n           typename ReductionF>\n struct UnsortedSegmentFunctor {\n-  void operator()(OpKernelContext* ctx, const Index num_segments,\n-                  const TensorShape& segment_ids_shape,\n+  void operator()(OpKernelContext* ctx, const TensorShape& segment_ids_shape,\n                   typename TTypes<Index>::ConstFlat segment_ids,\n-                  const Index data_size, const T* data,\n+                  typename TTypes<T, 2>::ConstTensor data,\n                   typename TTypes<T, 2>::Tensor output);\n };\n "
        },
        {
          "filename": "tensorflow/core/kernels/segment_reduction_ops_gpu.cu.cc",
          "status": "modified",
          "additions": 21,
          "deletions": 20,
          "patch": "@@ -106,21 +106,21 @@ __global__ void SortedSegmentSumCustomKernel(const Index input_outer_dim_size,\n // Each element is mapped from input to output by a combination of its\n // 'segment_ids' mapping and 'inner_dim_size'.\n template <typename T, typename Index, typename KernelReductionFunctor>\n-__global__ void UnsortedSegmentCustomKernel(const Index input_outer_dim_size,\n-                                            const Index inner_dim_size,\n-                                            const Index output_outer_dim_size,\n+__global__ void UnsortedSegmentCustomKernel(const int64 input_outer_dim_size,\n+                                            const int64 inner_dim_size,\n+                                            const int64 output_outer_dim_size,\n                                             const Index* segment_ids,\n                                             const T* input, T* output) {\n-  const Index input_total_size = input_outer_dim_size * inner_dim_size;\n-  const Index output_total_size = output_outer_dim_size * inner_dim_size;\n-  for (int input_index : GpuGridRangeX(input_total_size)) {\n-    const Index input_segment_index = input_index / inner_dim_size;\n-    const Index segment_offset = input_index % inner_dim_size;\n+  const int64 input_total_size = input_outer_dim_size * inner_dim_size;\n+  for (int64 input_index : GpuGridRangeX(input_total_size)) {\n+    const int64 input_segment_index = input_index / inner_dim_size;\n+    const int64 segment_offset = input_index % inner_dim_size;\n     const Index output_segment_index = segment_ids[input_segment_index];\n-    if (output_segment_index < 0 || output_segment_index >= output_total_size) {\n+    if (output_segment_index < 0 ||\n+        output_segment_index >= output_outer_dim_size) {\n       continue;\n     }\n-    const Index output_index =\n+    const int64 output_index =\n         output_segment_index * inner_dim_size + segment_offset;\n     KernelReductionFunctor()(output + output_index, ldg(input + input_index));\n   }\n@@ -174,10 +174,9 @@ void SegmentSumFunctor<T, Index>::operator()(\n template <typename T, typename Index, typename InitialValueF,\n           typename ReductionF>\n struct UnsortedSegmentFunctor<GPUDevice, T, Index, InitialValueF, ReductionF> {\n-  void operator()(OpKernelContext* ctx, const Index num_segments,\n-                  const TensorShape& segment_ids_shape,\n+  void operator()(OpKernelContext* ctx, const TensorShape& segment_ids_shape,\n                   typename TTypes<Index>::ConstFlat segment_ids,\n-                  const Index data_size, const T* data,\n+                  typename TTypes<T, 2>::ConstTensor data,\n                   typename TTypes<T, 2>::Tensor output) {\n     if (output.size() == 0) {\n       return;\n@@ -188,6 +187,7 @@ struct UnsortedSegmentFunctor<GPUDevice, T, Index, InitialValueF, ReductionF> {\n     TF_CHECK_OK(GpuLaunchKernel(\n         SetToValue<T>, config.block_count, config.thread_per_block, 0,\n         d.stream(), output.size(), output.data(), InitialValueF()()));\n+    const int64 data_size = data.size();\n     if (data_size == 0 || segment_ids_shape.num_elements() == 0) {\n       return;\n     }\n@@ -196,15 +196,16 @@ struct UnsortedSegmentFunctor<GPUDevice, T, Index, InitialValueF, ReductionF> {\n     // *) 'data_size' is the total number of elements to process.\n     // *) 'segment_ids.shape' is a prefix of data's shape.\n     // *) 'input_outer_dim_size' is the total number of segments to process.\n-    const Index input_outer_dim_size = segment_ids.dimension(0);\n-    const Index input_inner_dim_size = data_size / input_outer_dim_size;\n+    const int64 input_outer_dim_size = segment_ids.dimension(0);\n+    const int64 input_inner_dim_size = data.dimension(1);\n+    const int64 output_outer_dim_size = output.dimension(0);\n     config = GetGpuLaunchConfig(data_size, d);\n \n-    TF_CHECK_OK(\n-        GpuLaunchKernel(UnsortedSegmentCustomKernel<T, Index, ReductionF>,\n-                        config.block_count, config.thread_per_block, 0,\n-                        d.stream(), input_outer_dim_size, input_inner_dim_size,\n-                        num_segments, segment_ids.data(), data, output.data()));\n+    TF_CHECK_OK(GpuLaunchKernel(\n+        UnsortedSegmentCustomKernel<T, Index, ReductionF>, config.block_count,\n+        config.thread_per_block, 0, d.stream(), input_outer_dim_size,\n+        input_inner_dim_size, output_outer_dim_size, segment_ids.data(),\n+        data.data(), output.data()));\n   }\n };\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7f1cdb4f94bf497a8f81b47cb0b0f6f33dfcdf2f",
            "date": "2025-01-14T15:43:26Z",
            "author_login": "vwbaker"
          },
          {
            "sha": "8f888e57d9fab1d2e4127fdeaabc3f8976471065",
            "date": "2025-01-14T15:28:59Z",
            "author_login": "ddunl"
          },
          {
            "sha": "4e74930bd620da4ea2bb691359aaa9b2dc6b0605",
            "date": "2025-01-14T15:28:20Z",
            "author_login": "tensorflower-gardener"
          },
          {
            "sha": "251362e6c6746aaf6bffcfe514e79c6cc65336d7",
            "date": "2025-01-14T15:24:59Z",
            "author_login": "loislo"
          },
          {
            "sha": "eaa68cb298188196e413abfb1606c38f785dfed4",
            "date": "2025-01-14T15:15:19Z",
            "author_login": "tensorflower-gardener"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 2.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-122",
    "description": "In TensorFlow before 1.15, a heap buffer overflow in UnsortedSegmentSum can be produced when the Index template argument is int32. In this case data_size and num_segments fields are truncated from int64 to int32 and can produce negative numbers, resulting in accessing out of bounds heap memory. This is unlikely to be exploitable and was detected and fixed internally in TensorFlow 1.15 and 2.0.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2019-12-16T21:15:11.403",
    "last_modified": "2024-11-21T04:31:10.367",
    "fix_date": "2019-07-03T22:45:01Z"
  },
  "references": [
    {
      "url": "https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2019-002.md",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/db4f9717c41bccc3ce10099ab61996b246099892",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-844w-j86r-4x2j",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2019-002.md",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/db4f9717c41bccc3ce10099ab61996b246099892",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-844w-j86r-4x2j",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:24.259831",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "tensorflow",
    "owner": "tensorflow",
    "created_at": "2015-11-07T01:19:20Z",
    "updated_at": "2025-01-14T12:53:26Z",
    "pushed_at": "2025-01-14T12:53:14Z",
    "size": 1120707,
    "stars": 187254,
    "forks": 74432,
    "open_issues": 6569,
    "watchers": 187254,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 101199988,
      "Python": 45779571,
      "MLIR": 10763008,
      "HTML": 7662661,
      "Starlark": 7430486,
      "Go": 2171370,
      "C": 1288066,
      "Java": 1178817,
      "Jupyter Notebook": 805736,
      "Shell": 701425,
      "Objective-C++": 279654,
      "Objective-C": 169202,
      "CMake": 148610,
      "Smarty": 121630,
      "Swift": 81659,
      "Dockerfile": 37903,
      "C#": 13585,
      "Batchfile": 12126,
      "Ruby": 8898,
      "Perl": 7536,
      "Roff": 5034,
      "Cython": 3899,
      "Makefile": 2845,
      "CSS": 2761,
      "Vim Snippet": 58
    },
    "commit_activity": {
      "total_commits_last_year": 15729,
      "avg_commits_per_week": 302.4807692307692,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:54:01.412891"
  }
}