{
  "cve_id": "CVE-2019-16782",
  "github_data": {
    "repository": "rack/rack",
    "fix_commit": "7fecaee81f59926b6e1913511c90650e76673b38",
    "related_commits": [
      "7fecaee81f59926b6e1913511c90650e76673b38",
      "7fecaee81f59926b6e1913511c90650e76673b38"
    ],
    "patch_url": "https://github.com/rack/rack/commit/7fecaee81f59926b6e1913511c90650e76673b38.patch",
    "fix_commit_details": {
      "sha": "7fecaee81f59926b6e1913511c90650e76673b38",
      "commit_date": "2019-12-18T18:07:23Z",
      "author": {
        "login": "tenderlove",
        "type": "User",
        "stats": {
          "total_commits": 179,
          "average_weekly_commits": 0.19123931623931623,
          "total_additions": 3574,
          "total_deletions": 2706,
          "weeks_active": 46
        }
      },
      "commit_message": {
        "title": "Merge branch 'advisory-fix-1'",
        "length": 632,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 142,
        "additions": 130,
        "deletions": 12
      },
      "files": [
        {
          "filename": "lib/rack/session/abstract/id.rb",
          "status": "modified",
          "additions": 66,
          "deletions": 1,
          "patch": "@@ -8,11 +8,38 @@\n require 'rack/request'\n require 'rack/response'\n require 'securerandom'\n+require 'digest/sha2'\n \n module Rack\n \n   module Session\n \n+    class SessionId\n+      ID_VERSION = 2\n+\n+      attr_reader :public_id\n+\n+      def initialize(public_id)\n+        @public_id = public_id\n+      end\n+\n+      def private_id\n+        \"#{ID_VERSION}::#{hash_sid(public_id)}\"\n+      end\n+\n+      alias :cookie_value :public_id\n+\n+      def empty?; false; end\n+      def to_s; raise; end\n+      def inspect; public_id.inspect; end\n+\n+      private\n+\n+      def hash_sid(sid)\n+        Digest::SHA256.hexdigest(sid)\n+      end\n+    end\n+\n     module Abstract\n       # SessionHash is responsible to lazily load the session from store.\n \n@@ -375,14 +402,18 @@ def commit_session(req, res)\n             req.get_header(RACK_ERRORS).puts(\"Deferring cookie for #{session_id}\") if $VERBOSE\n           else\n             cookie = Hash.new\n-            cookie[:value] = data\n+            cookie[:value] = cookie_value(data)\n             cookie[:expires] = Time.now + options[:expire_after] if options[:expire_after]\n             cookie[:expires] = Time.now + options[:max_age] if options[:max_age]\n             set_cookie(req, res, cookie.merge!(options))\n           end\n         end\n         public :commit_session\n \n+        def cookie_value(data)\n+          data\n+        end\n+\n         # Sets the cookie back to the client with session id. We skip the cookie\n         # setting if the value didn't change (sid is the same) or expires was given.\n \n@@ -424,6 +455,40 @@ def delete_session(req, sid, options)\n         end\n       end\n \n+      class PersistedSecure < Persisted\n+        class SecureSessionHash < SessionHash\n+          def [](key)\n+            if key == \"session_id\"\n+              load_for_read!\n+              id.public_id\n+            else\n+              super\n+            end\n+          end\n+        end\n+\n+        def generate_sid(*)\n+          public_id = super\n+\n+          SessionId.new(public_id)\n+        end\n+\n+        def extract_session_id(*)\n+          public_id = super\n+          public_id && SessionId.new(public_id)\n+        end\n+\n+        private\n+\n+        def session_class\n+          SecureSessionHash\n+        end\n+\n+        def cookie_value(data)\n+          data.cookie_value\n+        end\n+      end\n+\n       class ID < Persisted\n         def self.inherited(klass)\n           k = klass.ancestors.find { |kl| kl.respond_to?(:superclass) && kl.superclass == ID }"
        },
        {
          "filename": "lib/rack/session/cookie.rb",
          "status": "modified",
          "additions": 11,
          "deletions": 2,
          "patch": "@@ -48,7 +48,7 @@ module Session\n     #   })\n     #\n \n-    class Cookie < Abstract::Persisted\n+    class Cookie < Abstract::PersistedSecure\n       # Encode session cookies as Base64\n       class Base64\n         def encode(str)\n@@ -154,6 +154,15 @@ def persistent_session_id!(data, sid = nil)\n         data\n       end\n \n+      class SessionId < DelegateClass(Session::SessionId)\n+        attr_reader :cookie_value\n+\n+        def initialize(session_id, cookie_value)\n+          super(session_id)\n+          @cookie_value = cookie_value\n+        end\n+      end\n+\n       def write_session(req, session_id, session, options)\n         session = session.merge(\"session_id\" => session_id)\n         session_data = coder.encode(session)\n@@ -166,7 +175,7 @@ def write_session(req, session_id, session, options)\n           req.get_header(RACK_ERRORS).puts(\"Warning! Rack::Session::Cookie data size exceeds 4K.\")\n           nil\n         else\n-          session_data\n+          SessionId.new(session_id, session_data)\n         end\n       end\n "
        },
        {
          "filename": "lib/rack/session/pool.rb",
          "status": "modified",
          "additions": 13,
          "deletions": 6,
          "patch": "@@ -26,7 +26,7 @@ module Session\n     #   )\n     #   Rack::Handler::WEBrick.run sessioned\n \n-    class Pool < Abstract::Persisted\n+    class Pool < Abstract::PersistedSecure\n       attr_reader :mutex, :pool\n       DEFAULT_OPTIONS = Abstract::ID::DEFAULT_OPTIONS.merge drop: false\n \n@@ -39,30 +39,31 @@ def initialize(app, options = {})\n       def generate_sid\n         loop do\n           sid = super\n-          break sid unless @pool.key? sid\n+          break sid unless @pool.key? sid.private_id\n         end\n       end\n \n       def find_session(req, sid)\n         with_lock(req) do\n-          unless sid and session = @pool[sid]\n+          unless sid and session = get_session_with_fallback(sid)\n             sid, session = generate_sid, {}\n-            @pool.store sid, session\n+            @pool.store sid.private_id, session\n           end\n           [sid, session]\n         end\n       end\n \n       def write_session(req, session_id, new_session, options)\n         with_lock(req) do\n-          @pool.store session_id, new_session\n+          @pool.store session_id.private_id, new_session\n           session_id\n         end\n       end\n \n       def delete_session(req, session_id, options)\n         with_lock(req) do\n-          @pool.delete(session_id)\n+          @pool.delete(session_id.public_id)\n+          @pool.delete(session_id.private_id)\n           generate_sid unless options[:drop]\n         end\n       end\n@@ -73,6 +74,12 @@ def with_lock(req)\n       ensure\n         @mutex.unlock if @mutex.locked?\n       end\n+\n+      private\n+\n+      def get_session_with_fallback(sid)\n+        @pool[sid.private_id] || @pool[sid.public_id]\n+      end\n     end\n   end\n end"
        },
        {
          "filename": "test/spec_session_pool.rb",
          "status": "modified",
          "additions": 40,
          "deletions": 3,
          "patch": "@@ -8,15 +8,15 @@\n \n describe Rack::Session::Pool do\n   session_key = Rack::Session::Pool::DEFAULT_OPTIONS[:key]\n-  session_match = /#{session_key}=[0-9a-fA-F]+;/\n+  session_match = /#{session_key}=([0-9a-fA-F]+);/\n \n   incrementor = lambda do |env|\n     env[\"rack.session\"][\"counter\"] ||= 0\n     env[\"rack.session\"][\"counter\"] += 1\n     Rack::Response.new(env[\"rack.session\"].inspect).to_a\n   end\n \n-  session_id = Rack::Lint.new(lambda do |env|\n+  get_session_id = Rack::Lint.new(lambda do |env|\n     Rack::Response.new(env[\"rack.session\"].inspect).to_a\n   end)\n \n@@ -145,6 +145,43 @@\n     pool.pool.size.must_equal 1\n   end\n \n+  it \"can read the session with the legacy id\" do\n+    pool = Rack::Session::Pool.new(incrementor)\n+    req = Rack::MockRequest.new(pool)\n+\n+    res0 = req.get(\"/\")\n+    cookie = res0[\"Set-Cookie\"]\n+    session_id = Rack::Session::SessionId.new cookie[session_match, 1]\n+    ses0 = pool.pool[session_id.private_id]\n+    pool.pool[session_id.public_id] = ses0\n+    pool.pool.delete(session_id.private_id)\n+\n+    res1 = req.get(\"/\", \"HTTP_COOKIE\" => cookie)\n+    res1[\"Set-Cookie\"].must_be_nil\n+    res1.body.must_equal '{\"counter\"=>2}'\n+    pool.pool[session_id.private_id].wont_be_nil\n+  end\n+\n+  it \"drops the session in the legacy id as well\" do\n+    pool = Rack::Session::Pool.new(incrementor)\n+    req = Rack::MockRequest.new(pool)\n+    drop = Rack::Utils::Context.new(pool, drop_session)\n+    dreq = Rack::MockRequest.new(drop)\n+\n+    res0 = req.get(\"/\")\n+    cookie = res0[\"Set-Cookie\"]\n+    session_id = Rack::Session::SessionId.new cookie[session_match, 1]\n+    ses0 = pool.pool[session_id.private_id]\n+    pool.pool[session_id.public_id] = ses0\n+    pool.pool.delete(session_id.private_id)\n+\n+    res2 = dreq.get(\"/\", \"HTTP_COOKIE\" => cookie)\n+    res2[\"Set-Cookie\"].must_be_nil\n+    res2.body.must_equal '{\"counter\"=>2}'\n+    pool.pool[session_id.private_id].must_be_nil\n+    pool.pool[session_id.public_id].must_be_nil\n+  end\n+\n   # anyone know how to do this better?\n   it \"should merge sessions when multithreaded\" do\n     unless $DEBUG\n@@ -193,7 +230,7 @@\n   end\n \n   it \"does not return a cookie if cookie was not written (only read)\" do\n-    app = Rack::Session::Pool.new(session_id)\n+    app = Rack::Session::Pool.new(get_session_id)\n     res = Rack::MockRequest.new(app).get(\"/\")\n     res[\"Set-Cookie\"].must_be_nil\n   end"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "49d4ed033f9c6d0bdba7b2a181437589049dbf7f",
            "date": "2025-01-03T23:29:09Z",
            "author_login": "ioquatix"
          },
          {
            "sha": "e9f2f246377da9d1c1cb55dae4328273ef235488",
            "date": "2024-12-11T06:18:49Z",
            "author_login": "ioquatix"
          },
          {
            "sha": "f682e0e413ff3070b6fad10d672a5dc92f69ee3e",
            "date": "2024-12-11T05:59:24Z",
            "author_login": "ioquatix"
          },
          {
            "sha": "c52c1b6428b4841e7a634b80d73f28e1cffd8c12",
            "date": "2024-12-10T02:37:02Z",
            "author_login": "ioquatix"
          },
          {
            "sha": "05e3997a4ad78e38a0532c14b1014c661ad8bc12",
            "date": "2024-11-24T21:01:44Z",
            "author_login": "AllyMarthaJ"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N",
    "cwe_id": "CWE-208",
    "description": "There's a possible information leak / session hijack vulnerability in Rack (RubyGem rack). This vulnerability is patched in versions 1.6.12 and 2.0.8. Attackers may be able to find and hijack sessions by using timing attacks targeting the session id. Session ids are usually stored and indexed in a database that uses some kind of scheme for speeding up lookups of that session id. By carefully measuring the amount of time it takes to look up a session, an attacker may be able to find a valid session id and hijack the session. The session id itself may be generated randomly, but the way the session is indexed by the backing store does not use a secure comparison.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2019-12-18T20:15:16.180",
    "last_modified": "2024-11-21T04:31:10.920",
    "fix_date": "2019-12-18T18:07:23Z"
  },
  "references": [
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2020-02/msg00016.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2019/12/18/2",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2019/12/18/3",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2019/12/19/3",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2020/04/08/1",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2020/04/09/2",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/rack/rack/commit/7fecaee81f59926b6e1913511c90650e76673b38",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/rack/rack/security/advisories/GHSA-hrqr-hxpp-chr3",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HZXMWILCICQLA2BYSP6I2CRMUG53YBLX/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2020-02/msg00016.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2019/12/18/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2019/12/18/3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2019/12/19/3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2020/04/08/1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2020/04/09/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/rack/rack/commit/7fecaee81f59926b6e1913511c90650e76673b38",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/rack/rack/security/advisories/GHSA-hrqr-hxpp-chr3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HZXMWILCICQLA2BYSP6I2CRMUG53YBLX/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:24.264418",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "rack",
    "owner": "rack",
    "created_at": "2008-12-24T03:03:12Z",
    "updated_at": "2025-01-14T02:05:28Z",
    "pushed_at": "2025-01-03T23:42:02Z",
    "size": 10097,
    "stars": 4949,
    "forks": 1635,
    "open_issues": 10,
    "watchers": 4949,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "1-5-stable",
      "1-6-stable",
      "2-0-stable",
      "2-1-stable",
      "2-2-stable",
      "3-0-stable",
      "3-1-stable",
      "main",
      "rack-0.4",
      "rack-0.9",
      "rack-1.0",
      "rack-1.1",
      "rack-1.2",
      "rack-1.3",
      "rack-1.4",
      "rack-1.5"
    ],
    "languages": {
      "Ruby": 661792,
      "CSS": 7342,
      "HTML": 49,
      "JavaScript": 34
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T14:07:02.368474"
  }
}