{
  "cve_id": "CVE-2019-16785",
  "github_data": {
    "repository": "Pylons/waitress",
    "fix_commit": "8eba394ad75deaf9e5cd15b78a3d16b12e6b0eba",
    "related_commits": [
      "8eba394ad75deaf9e5cd15b78a3d16b12e6b0eba",
      "8eba394ad75deaf9e5cd15b78a3d16b12e6b0eba"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "8eba394ad75deaf9e5cd15b78a3d16b12e6b0eba",
      "commit_date": "2019-12-12T22:55:36Z",
      "author": {
        "login": "digitalresistor",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Remove support for non CRLF line endings",
        "length": 601,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 711,
        "additions": 408,
        "deletions": 303
      },
      "files": [
        {
          "filename": "waitress/parser.py",
          "status": "modified",
          "additions": 20,
          "deletions": 20,
          "patch": "@@ -19,24 +19,14 @@\n import re\n from io import BytesIO\n \n-from waitress.compat import (\n-    tostr,\n-    urlparse,\n-    unquote_bytes_to_wsgi,\n-)\n-\n from waitress.buffers import OverflowableBuffer\n-\n-from waitress.receiver import (\n-    FixedStreamReceiver,\n-    ChunkedReceiver,\n-)\n-\n+from waitress.compat import tostr, unquote_bytes_to_wsgi, urlparse\n+from waitress.receiver import ChunkedReceiver, FixedStreamReceiver\n from waitress.utilities import (\n-    find_double_newline,\n+    BadRequest,\n     RequestEntityTooLarge,\n     RequestHeaderFieldsTooLarge,\n-    BadRequest,\n+    find_double_newline,\n )\n \n \n@@ -95,8 +85,13 @@ def received(self, data):\n                 # Header finished.\n                 header_plus = s[:index]\n                 consumed = len(data) - (len(s) - index)\n-                # Remove preceeding blank lines.\n+\n+                # Remove preceeding blank lines. This is suggested by\n+                # https://tools.ietf.org/html/rfc7230#section-3.5 to support\n+                # clients sending an extra CR LF after another request when\n+                # using HTTP pipelining\n                 header_plus = header_plus.lstrip()\n+\n                 if not header_plus:\n                     self.empty = True\n                     self.completed = True\n@@ -169,13 +164,15 @@ def parse_header(self, header_plus):\n         Parses the header_plus block of text (the headers plus the\n         first line of the request).\n         \"\"\"\n-        index = header_plus.find(b\"\\n\")\n+        index = header_plus.find(b\"\\r\\n\")\n         if index >= 0:\n             first_line = header_plus[:index].rstrip()\n-            header = header_plus[index + 1 :]\n+            header = header_plus[index + 2 :]\n         else:\n-            first_line = header_plus.rstrip()\n-            header = b\"\"\n+            raise ParsingError(\"HTTP message header invalid\")\n+\n+        if b\"\\r\" in first_line or b\"\\n\" in first_line:\n+            raise ParsingError(\"Bare CR or LF found in HTTP message\")\n \n         self.first_line = first_line  # for testing\n \n@@ -299,8 +296,11 @@ def get_header_lines(header):\n     Splits the header into lines, putting multi-line headers together.\n     \"\"\"\n     r = []\n-    lines = header.split(b\"\\n\")\n+    lines = header.split(b\"\\r\\n\")\n     for line in lines:\n+        if b\"\\r\" in line or b\"\\n\" in line:\n+            raise ParsingError('Bare CR or LF found in header line \"%s\"' % tostr(line))\n+\n         if line.startswith((b\" \", b\"\\t\")):\n             if not r:\n                 # https://corte.si/posts/code/pathod/pythonservers/index.html"
        },
        {
          "filename": "waitress/receiver.py",
          "status": "modified",
          "additions": 37,
          "deletions": 9,
          "patch": "@@ -14,9 +14,7 @@\n \"\"\"Data Chunk Receiver\n \"\"\"\n \n-from waitress.utilities import find_double_newline\n-\n-from waitress.utilities import BadRequest\n+from waitress.utilities import BadRequest, find_double_newline\n \n \n class FixedStreamReceiver(object):\n@@ -35,18 +33,23 @@ def __len__(self):\n     def received(self, data):\n         \"See IStreamConsumer\"\n         rm = self.remain\n+\n         if rm < 1:\n             self.completed = True  # Avoid any chance of spinning\n+\n             return 0\n         datalen = len(data)\n+\n         if rm <= datalen:\n             self.buf.append(data[:rm])\n             self.remain = 0\n             self.completed = True\n+\n             return rm\n         else:\n             self.buf.append(data)\n             self.remain -= datalen\n+\n             return datalen\n \n     def getfile(self):\n@@ -59,6 +62,7 @@ def getbuf(self):\n class ChunkedReceiver(object):\n \n     chunk_remainder = 0\n+    validate_chunk_end = False\n     control_line = b\"\"\n     all_chunks_received = False\n     trailer = b\"\"\n@@ -76,35 +80,57 @@ def __len__(self):\n \n     def received(self, s):\n         # Returns the number of bytes consumed.\n+\n         if self.completed:\n             return 0\n         orig_size = len(s)\n+\n         while s:\n             rm = self.chunk_remainder\n+\n             if rm > 0:\n                 # Receive the remainder of a chunk.\n                 to_write = s[:rm]\n                 self.buf.append(to_write)\n                 written = len(to_write)\n                 s = s[written:]\n+\n                 self.chunk_remainder -= written\n+\n+                if self.chunk_remainder == 0:\n+                    self.validate_chunk_end = True\n+            elif self.validate_chunk_end:\n+                pos = s.find(b\"\\r\\n\")\n+\n+                if pos == 0:\n+                    # Chop off the terminating CR LF from the chunk\n+                    s = s[2:]\n+                else:\n+                    self.error = BadRequest(\"Chunk not properly terminated\")\n+                    self.all_chunks_received = True\n+\n+                # Always exit this loop\n+                self.validate_chunk_end = False\n             elif not self.all_chunks_received:\n                 # Receive a control line.\n                 s = self.control_line + s\n-                pos = s.find(b\"\\n\")\n+                pos = s.find(b\"\\r\\n\")\n+\n                 if pos < 0:\n                     # Control line not finished.\n                     self.control_line = s\n                     s = \"\"\n                 else:\n                     # Control line finished.\n                     line = s[:pos]\n-                    s = s[pos + 1 :]\n+                    s = s[pos + 2 :]\n                     self.control_line = b\"\"\n                     line = line.strip()\n+\n                     if line:\n                         # Begin a new chunk.\n                         semi = line.find(b\";\")\n+\n                         if semi >= 0:\n                             # discard extension info.\n                             line = line[:semi]\n@@ -113,6 +139,7 @@ def received(self, s):\n                         except ValueError:  # garbage in input\n                             self.error = BadRequest(\"garbage in chunked encoding input\")\n                             sz = 0\n+\n                         if sz > 0:\n                             # Start a new chunk.\n                             self.chunk_remainder = sz\n@@ -123,15 +150,14 @@ def received(self, s):\n             else:\n                 # Receive the trailer.\n                 trailer = self.trailer + s\n+\n                 if trailer.startswith(b\"\\r\\n\"):\n                     # No trailer.\n                     self.completed = True\n+\n                     return orig_size - (len(trailer) - 2)\n-                elif trailer.startswith(b\"\\n\"):\n-                    # No trailer.\n-                    self.completed = True\n-                    return orig_size - (len(trailer) - 1)\n                 pos = find_double_newline(trailer)\n+\n                 if pos < 0:\n                     # Trailer not finished.\n                     self.trailer = trailer\n@@ -140,7 +166,9 @@ def received(self, s):\n                     # Finished the trailer.\n                     self.completed = True\n                     self.trailer = trailer[:pos]\n+\n                     return orig_size - (len(trailer) - pos)\n+\n         return orig_size\n \n     def getfile(self):"
        },
        {
          "filename": "waitress/tests/test_channel.py",
          "status": "modified",
          "additions": 8,
          "deletions": 22,
          "patch": "@@ -423,7 +423,7 @@ def test_del_channel(self):\n     def test_received(self):\n         inst, sock, map = self._makeOneWithMap()\n         inst.server = DummyServer()\n-        inst.received(b\"GET / HTTP/1.1\\n\\n\")\n+        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n         self.assertEqual(inst.server.tasks, [inst])\n         self.assertTrue(inst.requests)\n \n@@ -438,7 +438,7 @@ def test_received_preq_not_completed(self):\n         inst.request = preq\n         preq.completed = False\n         preq.empty = True\n-        inst.received(b\"GET / HTTP/1.1\\n\\n\")\n+        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n         self.assertEqual(inst.requests, ())\n         self.assertEqual(inst.server.tasks, [])\n \n@@ -449,7 +449,7 @@ def test_received_preq_completed_empty(self):\n         inst.request = preq\n         preq.completed = True\n         preq.empty = True\n-        inst.received(b\"GET / HTTP/1.1\\n\\n\")\n+        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n         self.assertEqual(inst.request, None)\n         self.assertEqual(inst.server.tasks, [])\n \n@@ -460,7 +460,7 @@ def test_received_preq_error(self):\n         inst.request = preq\n         preq.completed = True\n         preq.error = True\n-        inst.received(b\"GET / HTTP/1.1\\n\\n\")\n+        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n         self.assertEqual(inst.request, None)\n         self.assertEqual(len(inst.server.tasks), 1)\n         self.assertTrue(inst.requests)\n@@ -473,24 +473,10 @@ def test_received_preq_completed_connection_close(self):\n         preq.completed = True\n         preq.empty = True\n         preq.connection_close = True\n-        inst.received(b\"GET / HTTP/1.1\\n\\n\" + b\"a\" * 50000)\n+        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\" + b\"a\" * 50000)\n         self.assertEqual(inst.request, None)\n         self.assertEqual(inst.server.tasks, [])\n \n-    def test_received_preq_completed_n_lt_data(self):\n-        inst, sock, map = self._makeOneWithMap()\n-        inst.server = DummyServer()\n-        preq = DummyParser()\n-        inst.request = preq\n-        preq.completed = True\n-        preq.empty = False\n-        line = b\"GET / HTTP/1.1\\n\\n\"\n-        preq.retval = len(line)\n-        inst.received(line + line)\n-        self.assertEqual(inst.request, None)\n-        self.assertEqual(len(inst.requests), 2)\n-        self.assertEqual(len(inst.server.tasks), 1)\n-\n     def test_received_headers_finished_expect_continue_false(self):\n         inst, sock, map = self._makeOneWithMap()\n         inst.server = DummyServer()\n@@ -501,7 +487,7 @@ def test_received_headers_finished_expect_continue_false(self):\n         preq.completed = False\n         preq.empty = False\n         preq.retval = 1\n-        inst.received(b\"GET / HTTP/1.1\\n\\n\")\n+        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n         self.assertEqual(inst.request, preq)\n         self.assertEqual(inst.server.tasks, [])\n         self.assertEqual(inst.outbufs[0].get(100), b\"\")\n@@ -515,7 +501,7 @@ def test_received_headers_finished_expect_continue_true(self):\n         preq.headers_finished = True\n         preq.completed = False\n         preq.empty = False\n-        inst.received(b\"GET / HTTP/1.1\\n\\n\")\n+        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n         self.assertEqual(inst.request, preq)\n         self.assertEqual(inst.server.tasks, [])\n         self.assertEqual(sock.sent, b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")\n@@ -532,7 +518,7 @@ def test_received_headers_finished_expect_continue_true_sent_true(self):\n         preq.completed = False\n         preq.empty = False\n         inst.sent_continue = True\n-        inst.received(b\"GET / HTTP/1.1\\n\\n\")\n+        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n         self.assertEqual(inst.request, preq)\n         self.assertEqual(inst.server.tasks, [])\n         self.assertEqual(sock.sent, b\"\")"
        },
        {
          "filename": "waitress/tests/test_functional.py",
          "status": "modified",
          "additions": 132,
          "deletions": 107,
          "patch": "@@ -179,7 +179,7 @@ def _read_echo(self, fp):\n         return line, headers, echo.parse_response(body)\n \n     def test_date_and_server(self):\n-        to_send = \"GET / HTTP/1.0\\n\" \"Content-Length: 0\\n\\n\"\n+        to_send = \"GET / HTTP/1.0\\r\\nContent-Length: 0\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n         self.connect()\n         self.sock.send(to_send)\n@@ -191,7 +191,7 @@ def test_date_and_server(self):\n \n     def test_bad_host_header(self):\n         # https://corte.si/posts/code/pathod/pythonservers/index.html\n-        to_send = \"GET / HTTP/1.0\\n\" \" Host: 0\\n\\n\"\n+        to_send = \"GET / HTTP/1.0\\r\\n Host: 0\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n         self.connect()\n         self.sock.send(to_send)\n@@ -202,7 +202,7 @@ def test_bad_host_header(self):\n         self.assertTrue(headers.get(\"date\"))\n \n     def test_send_with_body(self):\n-        to_send = \"GET / HTTP/1.0\\n\" \"Content-Length: 5\\n\\n\"\n+        to_send = \"GET / HTTP/1.0\\r\\nContent-Length: 5\\r\\n\\r\\n\"\n         to_send += \"hello\"\n         to_send = tobytes(to_send)\n         self.connect()\n@@ -214,7 +214,7 @@ def test_send_with_body(self):\n         self.assertEqual(echo.body, b\"hello\")\n \n     def test_send_empty_body(self):\n-        to_send = \"GET / HTTP/1.0\\n\" \"Content-Length: 0\\n\\n\"\n+        to_send = \"GET / HTTP/1.0\\r\\nContent-Length: 0\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n         self.connect()\n         self.sock.send(to_send)\n@@ -241,12 +241,12 @@ def test_multiple_requests_without_body(self):\n         self.sock = orig_sock\n \n     def test_without_crlf(self):\n-        data = \"Echo\\nthis\\r\\nplease\"\n+        data = \"Echo\\r\\nthis\\r\\nplease\"\n         s = tobytes(\n-            \"GET / HTTP/1.0\\n\"\n-            \"Connection: close\\n\"\n-            \"Content-Length: %d\\n\"\n-            \"\\n\"\n+            \"GET / HTTP/1.0\\r\\n\"\n+            \"Connection: close\\r\\n\"\n+            \"Content-Length: %d\\r\\n\"\n+            \"\\r\\n\"\n             \"%s\" % (len(data), data)\n         )\n         self.connect()\n@@ -262,7 +262,7 @@ def test_large_body(self):\n         # 1024 characters.\n         body = \"This string has 32 characters.\\r\\n\" * 32\n         s = tobytes(\n-            \"GET / HTTP/1.0\\n\" \"Content-Length: %d\\n\" \"\\n\" \"%s\" % (len(body), body)\n+            \"GET / HTTP/1.0\\r\\nContent-Length: %d\\r\\n\\r\\n%s\" % (len(body), body)\n         )\n         self.connect()\n         self.sock.send(s)\n@@ -289,7 +289,7 @@ def test_many_clients(self):\n             h.close()\n \n     def test_chunking_request_without_content(self):\n-        header = tobytes(\"GET / HTTP/1.1\\n\" \"Transfer-Encoding: chunked\\n\\n\")\n+        header = tobytes(\"GET / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\")\n         self.connect()\n         self.sock.send(header)\n         self.sock.send(b\"0\\r\\n\\r\\n\")\n@@ -304,13 +304,14 @@ def test_chunking_request_with_content(self):\n         control_line = b\"20;\\r\\n\"  # 20 hex = 32 dec\n         s = b\"This string has 32 characters.\\r\\n\"\n         expected = s * 12\n-        header = tobytes(\"GET / HTTP/1.1\\n\" \"Transfer-Encoding: chunked\\n\\n\")\n+        header = tobytes(\"GET / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\")\n         self.connect()\n         self.sock.send(header)\n         fp = self.sock.makefile(\"rb\", 0)\n         for n in range(12):\n             self.sock.send(control_line)\n             self.sock.send(s)\n+            self.sock.send(b\"\\r\\n\")  # End the chunk\n         self.sock.send(b\"0\\r\\n\\r\\n\")\n         line, headers, echo = self._read_echo(fp)\n         self.assertline(line, \"200\", \"OK\", \"HTTP/1.1\")\n@@ -321,11 +322,34 @@ def test_chunking_request_with_content(self):\n     def test_broken_chunked_encoding(self):\n         control_line = \"20;\\r\\n\"  # 20 hex = 32 dec\n         s = \"This string has 32 characters.\\r\\n\"\n-        to_send = \"GET / HTTP/1.1\\nTransfer-Encoding: chunked\\n\\n\"\n-        to_send += control_line + s\n+        to_send = \"GET / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n+        to_send += control_line + s + \"\\r\\n\"\n         # garbage in input\n-        to_send += \"GET / HTTP/1.1\\nTransfer-Encoding: chunked\\n\\n\"\n+        to_send += \"garbage\\r\\n\"\n+        to_send = tobytes(to_send)\n+        self.connect()\n+        self.sock.send(to_send)\n+        fp = self.sock.makefile(\"rb\", 0)\n+        line, headers, response_body = read_http(fp)\n+        # receiver caught garbage and turned it into a 400\n+        self.assertline(line, \"400\", \"Bad Request\", \"HTTP/1.1\")\n+        cl = int(headers[\"content-length\"])\n+        self.assertEqual(cl, len(response_body))\n+        self.assertEqual(\n+            sorted(headers.keys()), [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"]\n+        )\n+        self.assertEqual(headers[\"content-type\"], \"text/plain\")\n+        # connection has been closed\n+        self.send_check_error(to_send)\n+        self.assertRaises(ConnectionClosed, read_http, fp)\n+\n+    def test_broken_chunked_encoding_missing_chunk_end(self):\n+        control_line = \"20;\\r\\n\"  # 20 hex = 32 dec\n+        s = \"This string has 32 characters.\\r\\n\"\n+        to_send = \"GET / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n         to_send += control_line + s\n+        # garbage in input\n+        to_send += \"garbage\"\n         to_send = tobytes(to_send)\n         self.connect()\n         self.sock.send(to_send)\n@@ -335,6 +359,7 @@ def test_broken_chunked_encoding(self):\n         self.assertline(line, \"400\", \"Bad Request\", \"HTTP/1.1\")\n         cl = int(headers[\"content-length\"])\n         self.assertEqual(cl, len(response_body))\n+        self.assertTrue(b\"Chunk not properly terminated\" in response_body)\n         self.assertEqual(\n             sorted(headers.keys()), [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"]\n         )\n@@ -347,7 +372,7 @@ def test_keepalive_http_10(self):\n         # Handling of Keep-Alive within HTTP 1.0\n         data = \"Default: Don't keep me alive\"\n         s = tobytes(\n-            \"GET / HTTP/1.0\\n\" \"Content-Length: %d\\n\" \"\\n\" \"%s\" % (len(data), data)\n+            \"GET / HTTP/1.0\\r\\nContent-Length: %d\\r\\n\\r\\n%s\" % (len(data), data)\n         )\n         self.connect()\n         self.sock.send(s)\n@@ -365,10 +390,10 @@ def test_keepalive_http10_explicit(self):\n         # the corresponding header\n         data = \"Keep me alive\"\n         s = tobytes(\n-            \"GET / HTTP/1.0\\n\"\n-            \"Connection: Keep-Alive\\n\"\n-            \"Content-Length: %d\\n\"\n-            \"\\n\"\n+            \"GET / HTTP/1.0\\r\\n\"\n+            \"Connection: Keep-Alive\\r\\n\"\n+            \"Content-Length: %d\\r\\n\"\n+            \"\\r\\n\"\n             \"%s\" % (len(data), data)\n         )\n         self.connect()\n@@ -385,7 +410,7 @@ def test_keepalive_http_11(self):\n         # All connections are kept alive, unless stated otherwise\n         data = \"Default: Keep me alive\"\n         s = tobytes(\n-            \"GET / HTTP/1.1\\n\" \"Content-Length: %d\\n\" \"\\n\" \"%s\" % (len(data), data)\n+            \"GET / HTTP/1.1\\r\\nContent-Length: %d\\r\\n\\r\\n%s\" % (len(data), data)\n         )\n         self.connect()\n         self.sock.send(s)\n@@ -398,10 +423,10 @@ def test_keepalive_http11_explicit(self):\n         # Explicitly set keep-alive\n         data = \"Default: Keep me alive\"\n         s = tobytes(\n-            \"GET / HTTP/1.1\\n\"\n-            \"Connection: keep-alive\\n\"\n-            \"Content-Length: %d\\n\"\n-            \"\\n\"\n+            \"GET / HTTP/1.1\\r\\n\"\n+            \"Connection: keep-alive\\r\\n\"\n+            \"Content-Length: %d\\r\\n\"\n+            \"\\r\\n\"\n             \"%s\" % (len(data), data)\n         )\n         self.connect()\n@@ -415,10 +440,10 @@ def test_keepalive_http11_connclose(self):\n         # specifying Connection: close explicitly\n         data = \"Don't keep me alive\"\n         s = tobytes(\n-            \"GET / HTTP/1.1\\n\"\n-            \"Connection: close\\n\"\n-            \"Content-Length: %d\\n\"\n-            \"\\n\"\n+            \"GET / HTTP/1.1\\r\\n\"\n+            \"Connection: close\\r\\n\"\n+            \"Content-Length: %d\\r\\n\"\n+            \"\\r\\n\"\n             \"%s\" % (len(data), data)\n         )\n         self.connect()\n@@ -430,12 +455,12 @@ def test_keepalive_http11_connclose(self):\n \n     def test_proxy_headers(self):\n         to_send = (\n-            \"GET / HTTP/1.0\\n\"\n-            \"Content-Length: 0\\n\"\n-            \"Host: www.google.com:8080\\n\"\n-            \"X-Forwarded-For: 192.168.1.1\\n\"\n-            \"X-Forwarded-Proto: https\\n\"\n-            \"X-Forwarded-Port: 5000\\n\\n\"\n+            \"GET / HTTP/1.0\\r\\n\"\n+            \"Content-Length: 0\\r\\n\"\n+            \"Host: www.google.com:8080\\r\\n\"\n+            \"X-Forwarded-For: 192.168.1.1\\r\\n\"\n+            \"X-Forwarded-Proto: https\\r\\n\"\n+            \"X-Forwarded-Port: 5000\\r\\n\\r\\n\"\n         )\n         to_send = tobytes(to_send)\n         self.connect()\n@@ -507,11 +532,11 @@ def test_expect_continue(self):\n         # specifying Connection: close explicitly\n         data = \"I have expectations\"\n         to_send = tobytes(\n-            \"GET / HTTP/1.1\\n\"\n-            \"Connection: close\\n\"\n-            \"Content-Length: %d\\n\"\n-            \"Expect: 100-continue\\n\"\n-            \"\\n\"\n+            \"GET / HTTP/1.1\\r\\n\"\n+            \"Connection: close\\r\\n\"\n+            \"Content-Length: %d\\r\\n\"\n+            \"Expect: 100-continue\\r\\n\"\n+            \"\\r\\n\"\n             \"%s\" % (len(data), data)\n         )\n         self.connect()\n@@ -546,10 +571,10 @@ def test_short_body(self):\n         # check to see if server closes connection when body is too short\n         # for cl header\n         to_send = tobytes(\n-            \"GET /short_body HTTP/1.0\\n\"\n-            \"Connection: Keep-Alive\\n\"\n-            \"Content-Length: 0\\n\"\n-            \"\\n\"\n+            \"GET /short_body HTTP/1.0\\r\\n\"\n+            \"Connection: Keep-Alive\\r\\n\"\n+            \"Content-Length: 0\\r\\n\"\n+            \"\\r\\n\"\n         )\n         self.connect()\n         self.sock.send(to_send)\n@@ -572,10 +597,10 @@ def test_long_body(self):\n         # check server doesnt close connection when body is too short\n         # for cl header\n         to_send = tobytes(\n-            \"GET /long_body HTTP/1.0\\n\"\n-            \"Connection: Keep-Alive\\n\"\n-            \"Content-Length: 0\\n\"\n-            \"\\n\"\n+            \"GET /long_body HTTP/1.0\\r\\n\"\n+            \"Connection: Keep-Alive\\r\\n\"\n+            \"Content-Length: 0\\r\\n\"\n+            \"\\r\\n\"\n         )\n         self.connect()\n         self.sock.send(to_send)\n@@ -611,9 +636,9 @@ def tearDown(self):\n     def test_http10_generator(self):\n         body = string.ascii_letters\n         to_send = (\n-            \"GET / HTTP/1.0\\n\"\n-            \"Connection: Keep-Alive\\n\"\n-            \"Content-Length: %d\\n\\n\" % len(body)\n+            \"GET / HTTP/1.0\\r\\n\"\n+            \"Connection: Keep-Alive\\r\\n\"\n+            \"Content-Length: %d\\r\\n\\r\\n\" % len(body)\n         )\n         to_send += body\n         to_send = tobytes(to_send)\n@@ -633,9 +658,9 @@ def test_http10_generator(self):\n     def test_http10_list(self):\n         body = string.ascii_letters\n         to_send = (\n-            \"GET /list HTTP/1.0\\n\"\n-            \"Connection: Keep-Alive\\n\"\n-            \"Content-Length: %d\\n\\n\" % len(body)\n+            \"GET /list HTTP/1.0\\r\\n\"\n+            \"Connection: Keep-Alive\\r\\n\"\n+            \"Content-Length: %d\\r\\n\\r\\n\" % len(body)\n         )\n         to_send += body\n         to_send = tobytes(to_send)\n@@ -656,9 +681,9 @@ def test_http10_list(self):\n     def test_http10_listlentwo(self):\n         body = string.ascii_letters\n         to_send = (\n-            \"GET /list_lentwo HTTP/1.0\\n\"\n-            \"Connection: Keep-Alive\\n\"\n-            \"Content-Length: %d\\n\\n\" % len(body)\n+            \"GET /list_lentwo HTTP/1.0\\r\\n\"\n+            \"Connection: Keep-Alive\\r\\n\"\n+            \"Content-Length: %d\\r\\n\\r\\n\" % len(body)\n         )\n         to_send += body\n         to_send = tobytes(to_send)\n@@ -677,7 +702,7 @@ def test_http10_listlentwo(self):\n \n     def test_http11_generator(self):\n         body = string.ascii_letters\n-        to_send = \"GET / HTTP/1.1\\n\" \"Content-Length: %s\\n\\n\" % len(body)\n+        to_send = \"GET / HTTP/1.1\\r\\nContent-Length: %s\\r\\n\\r\\n\" % len(body)\n         to_send += body\n         to_send = tobytes(to_send)\n         self.connect()\n@@ -698,7 +723,7 @@ def test_http11_generator(self):\n \n     def test_http11_list(self):\n         body = string.ascii_letters\n-        to_send = \"GET /list HTTP/1.1\\n\" \"Content-Length: %d\\n\\n\" % len(body)\n+        to_send = \"GET /list HTTP/1.1\\r\\nContent-Length: %d\\r\\n\\r\\n\" % len(body)\n         to_send += body\n         to_send = tobytes(to_send)\n         self.connect()\n@@ -716,7 +741,7 @@ def test_http11_list(self):\n \n     def test_http11_listlentwo(self):\n         body = string.ascii_letters\n-        to_send = \"GET /list_lentwo HTTP/1.1\\n\" \"Content-Length: %s\\n\\n\" % len(body)\n+        to_send = \"GET /list_lentwo HTTP/1.1\\r\\nContent-Length: %s\\r\\n\\r\\n\" % len(body)\n         to_send += body\n         to_send = tobytes(to_send)\n         self.connect()\n@@ -749,10 +774,10 @@ def test_short_body(self):\n         # check to see if server closes connection when body is too short\n         # for cl header\n         to_send = tobytes(\n-            \"GET /short_body HTTP/1.0\\n\"\n-            \"Connection: Keep-Alive\\n\"\n-            \"Content-Length: 0\\n\"\n-            \"\\n\"\n+            \"GET /short_body HTTP/1.0\\r\\n\"\n+            \"Connection: Keep-Alive\\r\\n\"\n+            \"Content-Length: 0\\r\\n\"\n+            \"\\r\\n\"\n         )\n         self.connect()\n         self.sock.send(to_send)\n@@ -773,10 +798,10 @@ def test_long_body(self):\n         # check server doesnt close connection when body is too long\n         # for cl header\n         to_send = tobytes(\n-            \"GET /long_body HTTP/1.0\\n\"\n-            \"Connection: Keep-Alive\\n\"\n-            \"Content-Length: 0\\n\"\n-            \"\\n\"\n+            \"GET /long_body HTTP/1.0\\r\\n\"\n+            \"Connection: Keep-Alive\\r\\n\"\n+            \"Content-Length: 0\\r\\n\"\n+            \"\\r\\n\"\n         )\n         self.connect()\n         self.sock.send(to_send)\n@@ -796,10 +821,10 @@ def test_equal_body(self):\n         # check server doesnt close connection when body is equal to\n         # cl header\n         to_send = tobytes(\n-            \"GET /equal_body HTTP/1.0\\n\"\n-            \"Connection: Keep-Alive\\n\"\n-            \"Content-Length: 0\\n\"\n-            \"\\n\"\n+            \"GET /equal_body HTTP/1.0\\r\\n\"\n+            \"Connection: Keep-Alive\\r\\n\"\n+            \"Content-Length: 0\\r\\n\"\n+            \"\\r\\n\"\n         )\n         self.connect()\n         self.sock.send(to_send)\n@@ -819,10 +844,10 @@ def test_equal_body(self):\n     def test_no_content_length(self):\n         # wtf happens when there's no content-length\n         to_send = tobytes(\n-            \"GET /no_content_length HTTP/1.0\\n\"\n-            \"Connection: Keep-Alive\\n\"\n-            \"Content-Length: 0\\n\"\n-            \"\\n\"\n+            \"GET /no_content_length HTTP/1.0\\r\\n\"\n+            \"Connection: Keep-Alive\\r\\n\"\n+            \"Content-Length: 0\\r\\n\"\n+            \"\\r\\n\"\n         )\n         self.connect()\n         self.sock.send(to_send)\n@@ -853,7 +878,7 @@ def tearDown(self):\n \n     def test_request_body_too_large_with_wrong_cl_http10(self):\n         body = \"a\" * self.toobig\n-        to_send = \"GET / HTTP/1.0\\n\" \"Content-Length: 5\\n\\n\"\n+        to_send = \"GET / HTTP/1.0\\r\\nContent-Length: 5\\r\\n\\r\\n\"\n         to_send += body\n         to_send = tobytes(to_send)\n         self.connect()\n@@ -872,7 +897,7 @@ def test_request_body_too_large_with_wrong_cl_http10(self):\n \n     def test_request_body_too_large_with_wrong_cl_http10_keepalive(self):\n         body = \"a\" * self.toobig\n-        to_send = \"GET / HTTP/1.0\\n\" \"Content-Length: 5\\n\" \"Connection: Keep-Alive\\n\\n\"\n+        to_send = \"GET / HTTP/1.0\\r\\nContent-Length: 5\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n         to_send += body\n         to_send = tobytes(to_send)\n         self.connect()\n@@ -893,7 +918,7 @@ def test_request_body_too_large_with_wrong_cl_http10_keepalive(self):\n \n     def test_request_body_too_large_with_no_cl_http10(self):\n         body = \"a\" * self.toobig\n-        to_send = \"GET / HTTP/1.0\\n\\n\"\n+        to_send = \"GET / HTTP/1.0\\r\\n\\r\\n\"\n         to_send += body\n         to_send = tobytes(to_send)\n         self.connect()\n@@ -909,7 +934,7 @@ def test_request_body_too_large_with_no_cl_http10(self):\n \n     def test_request_body_too_large_with_no_cl_http10_keepalive(self):\n         body = \"a\" * self.toobig\n-        to_send = \"GET / HTTP/1.0\\nConnection: Keep-Alive\\n\\n\"\n+        to_send = \"GET / HTTP/1.0\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n         to_send += body\n         to_send = tobytes(to_send)\n         self.connect()\n@@ -932,7 +957,7 @@ def test_request_body_too_large_with_no_cl_http10_keepalive(self):\n \n     def test_request_body_too_large_with_wrong_cl_http11(self):\n         body = \"a\" * self.toobig\n-        to_send = \"GET / HTTP/1.1\\n\" \"Content-Length: 5\\n\\n\"\n+        to_send = \"GET / HTTP/1.1\\r\\nContent-Length: 5\\r\\n\\r\\n\"\n         to_send += body\n         to_send = tobytes(to_send)\n         self.connect()\n@@ -954,7 +979,7 @@ def test_request_body_too_large_with_wrong_cl_http11(self):\n \n     def test_request_body_too_large_with_wrong_cl_http11_connclose(self):\n         body = \"a\" * self.toobig\n-        to_send = \"GET / HTTP/1.1\\nContent-Length: 5\\nConnection: close\\n\\n\"\n+        to_send = \"GET / HTTP/1.1\\r\\nContent-Length: 5\\r\\nConnection: close\\r\\n\\r\\n\"\n         to_send += body\n         to_send = tobytes(to_send)\n         self.connect()\n@@ -971,7 +996,7 @@ def test_request_body_too_large_with_wrong_cl_http11_connclose(self):\n \n     def test_request_body_too_large_with_no_cl_http11(self):\n         body = \"a\" * self.toobig\n-        to_send = \"GET / HTTP/1.1\\n\\n\"\n+        to_send = \"GET / HTTP/1.1\\r\\n\\r\\n\"\n         to_send += body\n         to_send = tobytes(to_send)\n         self.connect()\n@@ -996,7 +1021,7 @@ def test_request_body_too_large_with_no_cl_http11(self):\n \n     def test_request_body_too_large_with_no_cl_http11_connclose(self):\n         body = \"a\" * self.toobig\n-        to_send = \"GET / HTTP/1.1\\nConnection: close\\n\\n\"\n+        to_send = \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n         to_send += body\n         to_send = tobytes(to_send)\n         self.connect()\n@@ -1014,7 +1039,7 @@ def test_request_body_too_large_with_no_cl_http11_connclose(self):\n     def test_request_body_too_large_chunked_encoding(self):\n         control_line = \"20;\\r\\n\"  # 20 hex = 32 dec\n         s = \"This string has 32 characters.\\r\\n\"\n-        to_send = \"GET / HTTP/1.1\\nTransfer-Encoding: chunked\\n\\n\"\n+        to_send = \"GET / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n         repeat = control_line + s\n         to_send += repeat * ((self.toobig // len(repeat)) + 1)\n         to_send = tobytes(to_send)\n@@ -1042,7 +1067,7 @@ def tearDown(self):\n         self.stop_subprocess()\n \n     def test_before_start_response_http_10(self):\n-        to_send = \"GET /before_start_response HTTP/1.0\\n\\n\"\n+        to_send = \"GET /before_start_response HTTP/1.0\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n         self.connect()\n         self.sock.send(to_send)\n@@ -1058,7 +1083,7 @@ def test_before_start_response_http_10(self):\n         self.assertRaises(ConnectionClosed, read_http, fp)\n \n     def test_before_start_response_http_11(self):\n-        to_send = \"GET /before_start_response HTTP/1.1\\n\\n\"\n+        to_send = \"GET /before_start_response HTTP/1.1\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n         self.connect()\n         self.sock.send(to_send)\n@@ -1077,7 +1102,7 @@ def test_before_start_response_http_11(self):\n \n     def test_before_start_response_http_11_close(self):\n         to_send = tobytes(\n-            \"GET /before_start_response HTTP/1.1\\n\" \"Connection: close\\n\\n\"\n+            \"GET /before_start_response HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n         )\n         self.connect()\n         self.sock.send(to_send)\n@@ -1097,7 +1122,7 @@ def test_before_start_response_http_11_close(self):\n         self.assertRaises(ConnectionClosed, read_http, fp)\n \n     def test_after_start_response_http10(self):\n-        to_send = \"GET /after_start_response HTTP/1.0\\n\\n\"\n+        to_send = \"GET /after_start_response HTTP/1.0\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n         self.connect()\n         self.sock.send(to_send)\n@@ -1117,7 +1142,7 @@ def test_after_start_response_http10(self):\n         self.assertRaises(ConnectionClosed, read_http, fp)\n \n     def test_after_start_response_http11(self):\n-        to_send = \"GET /after_start_response HTTP/1.1\\n\\n\"\n+        to_send = \"GET /after_start_response HTTP/1.1\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n         self.connect()\n         self.sock.send(to_send)\n@@ -1136,7 +1161,7 @@ def test_after_start_response_http11(self):\n \n     def test_after_start_response_http11_close(self):\n         to_send = tobytes(\n-            \"GET /after_start_response HTTP/1.1\\n\" \"Connection: close\\n\\n\"\n+            \"GET /after_start_response HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n         )\n         self.connect()\n         self.sock.send(to_send)\n@@ -1156,7 +1181,7 @@ def test_after_start_response_http11_close(self):\n         self.assertRaises(ConnectionClosed, read_http, fp)\n \n     def test_after_write_cb(self):\n-        to_send = \"GET /after_write_cb HTTP/1.1\\n\\n\"\n+        to_send = \"GET /after_write_cb HTTP/1.1\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n         self.connect()\n         self.sock.send(to_send)\n@@ -1169,7 +1194,7 @@ def test_after_write_cb(self):\n         self.assertRaises(ConnectionClosed, read_http, fp)\n \n     def test_in_generator(self):\n-        to_send = \"GET /in_generator HTTP/1.1\\n\\n\"\n+        to_send = \"GET /in_generator HTTP/1.1\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n         self.connect()\n         self.sock.send(to_send)\n@@ -1192,7 +1217,7 @@ def tearDown(self):\n         self.stop_subprocess()\n \n     def test_filelike_http11(self):\n-        to_send = \"GET /filelike HTTP/1.1\\n\\n\"\n+        to_send = \"GET /filelike HTTP/1.1\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n \n         self.connect()\n@@ -1210,7 +1235,7 @@ def test_filelike_http11(self):\n             # connection has not been closed\n \n     def test_filelike_nocl_http11(self):\n-        to_send = \"GET /filelike_nocl HTTP/1.1\\n\\n\"\n+        to_send = \"GET /filelike_nocl HTTP/1.1\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n \n         self.connect()\n@@ -1228,7 +1253,7 @@ def test_filelike_nocl_http11(self):\n             # connection has not been closed\n \n     def test_filelike_shortcl_http11(self):\n-        to_send = \"GET /filelike_shortcl HTTP/1.1\\n\\n\"\n+        to_send = \"GET /filelike_shortcl HTTP/1.1\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n \n         self.connect()\n@@ -1247,7 +1272,7 @@ def test_filelike_shortcl_http11(self):\n             # connection has not been closed\n \n     def test_filelike_longcl_http11(self):\n-        to_send = \"GET /filelike_longcl HTTP/1.1\\n\\n\"\n+        to_send = \"GET /filelike_longcl HTTP/1.1\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n \n         self.connect()\n@@ -1265,7 +1290,7 @@ def test_filelike_longcl_http11(self):\n             # connection has not been closed\n \n     def test_notfilelike_http11(self):\n-        to_send = \"GET /notfilelike HTTP/1.1\\n\\n\"\n+        to_send = \"GET /notfilelike HTTP/1.1\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n \n         self.connect()\n@@ -1283,7 +1308,7 @@ def test_notfilelike_http11(self):\n             # connection has not been closed\n \n     def test_notfilelike_iobase_http11(self):\n-        to_send = \"GET /notfilelike_iobase HTTP/1.1\\n\\n\"\n+        to_send = \"GET /notfilelike_iobase HTTP/1.1\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n \n         self.connect()\n@@ -1301,7 +1326,7 @@ def test_notfilelike_iobase_http11(self):\n             # connection has not been closed\n \n     def test_notfilelike_nocl_http11(self):\n-        to_send = \"GET /notfilelike_nocl HTTP/1.1\\n\\n\"\n+        to_send = \"GET /notfilelike_nocl HTTP/1.1\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n \n         self.connect()\n@@ -1318,7 +1343,7 @@ def test_notfilelike_nocl_http11(self):\n         self.assertRaises(ConnectionClosed, read_http, fp)\n \n     def test_notfilelike_shortcl_http11(self):\n-        to_send = \"GET /notfilelike_shortcl HTTP/1.1\\n\\n\"\n+        to_send = \"GET /notfilelike_shortcl HTTP/1.1\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n \n         self.connect()\n@@ -1337,7 +1362,7 @@ def test_notfilelike_shortcl_http11(self):\n             # connection has not been closed\n \n     def test_notfilelike_longcl_http11(self):\n-        to_send = \"GET /notfilelike_longcl HTTP/1.1\\n\\n\"\n+        to_send = \"GET /notfilelike_longcl HTTP/1.1\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n \n         self.connect()\n@@ -1356,7 +1381,7 @@ def test_notfilelike_longcl_http11(self):\n         self.assertRaises(ConnectionClosed, read_http, fp)\n \n     def test_filelike_http10(self):\n-        to_send = \"GET /filelike HTTP/1.0\\n\\n\"\n+        to_send = \"GET /filelike HTTP/1.0\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n \n         self.connect()\n@@ -1375,7 +1400,7 @@ def test_filelike_http10(self):\n         self.assertRaises(ConnectionClosed, read_http, fp)\n \n     def test_filelike_nocl_http10(self):\n-        to_send = \"GET /filelike_nocl HTTP/1.0\\n\\n\"\n+        to_send = \"GET /filelike_nocl HTTP/1.0\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n \n         self.connect()\n@@ -1394,7 +1419,7 @@ def test_filelike_nocl_http10(self):\n         self.assertRaises(ConnectionClosed, read_http, fp)\n \n     def test_notfilelike_http10(self):\n-        to_send = \"GET /notfilelike HTTP/1.0\\n\\n\"\n+        to_send = \"GET /notfilelike HTTP/1.0\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n \n         self.connect()\n@@ -1413,7 +1438,7 @@ def test_notfilelike_http10(self):\n         self.assertRaises(ConnectionClosed, read_http, fp)\n \n     def test_notfilelike_nocl_http10(self):\n-        to_send = \"GET /notfilelike_nocl HTTP/1.0\\n\\n\"\n+        to_send = \"GET /notfilelike_nocl HTTP/1.0\\r\\n\\r\\n\"\n         to_send = tobytes(to_send)\n \n         self.connect()\n@@ -1582,7 +1607,7 @@ def read_http(fp):  # pragma: no cover\n     header_lines = []\n     while True:\n         line = fp.readline()\n-        if line in (b\"\\r\\n\", b\"\\n\", b\"\"):\n+        if line in (b\"\\r\\n\", b\"\\r\\n\", b\"\"):\n             break\n         else:\n             header_lines.append(line)"
        },
        {
          "filename": "waitress/tests/test_parser.py",
          "status": "modified",
          "additions": 152,
          "deletions": 122,
          "patch": "@@ -15,10 +15,7 @@\n \"\"\"\n import unittest\n \n-from waitress.compat import (\n-    text_,\n-    tobytes,\n-)\n+from waitress.compat import text_, tobytes\n \n \n class TestHTTPRequestParser(unittest.TestCase):\n@@ -40,47 +37,33 @@ def test_get_body_stream_nonNone(self):\n         result = self.parser.get_body_stream()\n         self.assertEqual(result, body_rcv)\n \n-    def test_received_nonsense_with_double_cr(self):\n-        data = b\"\"\"\\\n-HTTP/1.0 GET /foobar\n-\n-\n-\"\"\"\n+    def test_received_get_no_headers(self):\n+        data = b\"HTTP/1.0 GET /foobar\\r\\n\\r\\n\"\n         result = self.parser.received(data)\n-        self.assertEqual(result, 22)\n+        self.assertEqual(result, 24)\n         self.assertTrue(self.parser.completed)\n         self.assertEqual(self.parser.headers, {})\n \n     def test_received_bad_host_header(self):\n         from waitress.utilities import BadRequest\n \n-        data = b\"\"\"\\\n-HTTP/1.0 GET /foobar\n- Host: foo\n-\n-\n-\"\"\"\n+        data = b\"HTTP/1.0 GET /foobar\\r\\n Host: foo\\r\\n\\r\\n\"\n         result = self.parser.received(data)\n-        self.assertEqual(result, 33)\n+        self.assertEqual(result, 36)\n         self.assertTrue(self.parser.completed)\n         self.assertEqual(self.parser.error.__class__, BadRequest)\n \n     def test_received_nonsense_nothing(self):\n-        data = b\"\"\"\\\n-\n-\n-\"\"\"\n+        data = b\"\\r\\n\\r\\n\"\n         result = self.parser.received(data)\n-        self.assertEqual(result, 2)\n+        self.assertEqual(result, 4)\n         self.assertTrue(self.parser.completed)\n         self.assertEqual(self.parser.headers, {})\n \n     def test_received_no_doublecr(self):\n-        data = b\"\"\"\\\n-GET /foobar HTTP/8.4\n-\"\"\"\n+        data = b\"GET /foobar HTTP/8.4\\r\\n\"\n         result = self.parser.received(data)\n-        self.assertEqual(result, 21)\n+        self.assertEqual(result, 22)\n         self.assertFalse(self.parser.completed)\n         self.assertEqual(self.parser.headers, {})\n \n@@ -93,113 +76,114 @@ def test_received_cl_too_large(self):\n         from waitress.utilities import RequestEntityTooLarge\n \n         self.parser.adj.max_request_body_size = 2\n-        data = b\"\"\"\\\n-GET /foobar HTTP/8.4\n-Content-Length: 10\n-\n-\"\"\"\n+        data = b\"GET /foobar HTTP/8.4\\r\\nContent-Length: 10\\r\\n\\r\\n\"\n         result = self.parser.received(data)\n-        self.assertEqual(result, 41)\n+        self.assertEqual(result, 44)\n         self.assertTrue(self.parser.completed)\n         self.assertTrue(isinstance(self.parser.error, RequestEntityTooLarge))\n \n     def test_received_headers_too_large(self):\n         from waitress.utilities import RequestHeaderFieldsTooLarge\n \n         self.parser.adj.max_request_header_size = 2\n-        data = b\"\"\"\\\n-GET /foobar HTTP/8.4\n-X-Foo: 1\n-\"\"\"\n+        data = b\"GET /foobar HTTP/8.4\\r\\nX-Foo: 1\\r\\n\\r\\n\"\n         result = self.parser.received(data)\n-        self.assertEqual(result, 30)\n+        self.assertEqual(result, 34)\n         self.assertTrue(self.parser.completed)\n         self.assertTrue(isinstance(self.parser.error, RequestHeaderFieldsTooLarge))\n \n     def test_received_body_too_large(self):\n         from waitress.utilities import RequestEntityTooLarge\n \n         self.parser.adj.max_request_body_size = 2\n-        data = b\"\"\"\\\n-GET /foobar HTTP/1.1\n-Transfer-Encoding: chunked\n-X-Foo: 1\n-\n-20;\\r\\n\n-This string has 32 characters\\r\\n\n-0\\r\\n\\r\\n\"\"\"\n+        data = (\n+            b\"GET /foobar HTTP/1.1\\r\\n\"\n+            b\"Transfer-Encoding: chunked\\r\\n\"\n+            b\"X-Foo: 1\\r\\n\"\n+            b\"\\r\\n\"\n+            b\"1d;\\r\\n\"\n+            b\"This string has 29 characters\\r\\n\"\n+            b\"0\\r\\n\\r\\n\"\n+        )\n+\n         result = self.parser.received(data)\n-        self.assertEqual(result, 58)\n+        self.assertEqual(result, 62)\n         self.parser.received(data[result:])\n         self.assertTrue(self.parser.completed)\n         self.assertTrue(isinstance(self.parser.error, RequestEntityTooLarge))\n \n     def test_received_error_from_parser(self):\n         from waitress.utilities import BadRequest\n \n-        data = b\"\"\"\\\n-GET /foobar HTTP/1.1\n-Transfer-Encoding: chunked\n-X-Foo: 1\n-\n-garbage\n-\"\"\"\n+        data = (\n+            b\"GET /foobar HTTP/1.1\\r\\n\"\n+            b\"Transfer-Encoding: chunked\\r\\n\"\n+            b\"X-Foo: 1\\r\\n\"\n+            b\"\\r\\n\"\n+            b\"garbage\\r\\n\"\n+        )\n         # header\n         result = self.parser.received(data)\n         # body\n         result = self.parser.received(data[result:])\n-        self.assertEqual(result, 8)\n+        self.assertEqual(result, 9)\n         self.assertTrue(self.parser.completed)\n         self.assertTrue(isinstance(self.parser.error, BadRequest))\n \n     def test_received_chunked_completed_sets_content_length(self):\n-        data = b\"\"\"\\\n-GET /foobar HTTP/1.1\n-Transfer-Encoding: chunked\n-X-Foo: 1\n-\n-20;\\r\\n\n-This string has 32 characters\\r\\n\n-0\\r\\n\\r\\n\"\"\"\n+        data = (\n+            b\"GET /foobar HTTP/1.1\\r\\n\"\n+            b\"Transfer-Encoding: chunked\\r\\n\"\n+            b\"X-Foo: 1\\r\\n\"\n+            b\"\\r\\n\"\n+            b\"1d;\\r\\n\"\n+            b\"This string has 29 characters\\r\\n\"\n+            b\"0\\r\\n\\r\\n\"\n+        )\n         result = self.parser.received(data)\n-        self.assertEqual(result, 58)\n+        self.assertEqual(result, 62)\n         data = data[result:]\n         result = self.parser.received(data)\n         self.assertTrue(self.parser.completed)\n         self.assertTrue(self.parser.error is None)\n-        self.assertEqual(self.parser.headers[\"CONTENT_LENGTH\"], \"32\")\n+        self.assertEqual(self.parser.headers[\"CONTENT_LENGTH\"], \"29\")\n \n     def test_parse_header_gardenpath(self):\n-        data = b\"\"\"\\\n-GET /foobar HTTP/8.4\n-foo: bar\"\"\"\n+        data = b\"GET /foobar HTTP/8.4\\r\\nfoo: bar\\r\\n\"\n         self.parser.parse_header(data)\n         self.assertEqual(self.parser.first_line, b\"GET /foobar HTTP/8.4\")\n         self.assertEqual(self.parser.headers[\"FOO\"], \"bar\")\n \n     def test_parse_header_no_cr_in_headerplus(self):\n+        from waitress.parser import ParsingError\n+\n         data = b\"GET /foobar HTTP/8.4\"\n-        self.parser.parse_header(data)\n-        self.assertEqual(self.parser.first_line, data)\n+\n+        try:\n+            self.parser.parse_header(data)\n+        except ParsingError:\n+            pass\n+        else:  # pragma: nocover\n+            self.assertTrue(False)\n \n     def test_parse_header_bad_content_length(self):\n-        data = b\"GET /foobar HTTP/8.4\\ncontent-length: abc\"\n+        data = b\"GET /foobar HTTP/8.4\\r\\ncontent-length: abc\\r\\n\"\n         self.parser.parse_header(data)\n         self.assertEqual(self.parser.body_rcv, None)\n \n     def test_parse_header_11_te_chunked(self):\n         # NB: test that capitalization of header value is unimportant\n-        data = b\"GET /foobar HTTP/1.1\\ntransfer-encoding: ChUnKed\"\n+        data = b\"GET /foobar HTTP/1.1\\r\\ntransfer-encoding: ChUnKed\\r\\n\"\n         self.parser.parse_header(data)\n         self.assertEqual(self.parser.body_rcv.__class__.__name__, \"ChunkedReceiver\")\n \n     def test_parse_header_11_expect_continue(self):\n-        data = b\"GET /foobar HTTP/1.1\\nexpect: 100-continue\"\n+        data = b\"GET /foobar HTTP/1.1\\r\\nexpect: 100-continue\\r\\n\"\n         self.parser.parse_header(data)\n         self.assertEqual(self.parser.expect_continue, True)\n \n     def test_parse_header_connection_close(self):\n-        data = b\"GET /foobar HTTP/1.1\\nConnection: close\\n\\n\"\n+        data = b\"GET /foobar HTTP/1.1\\r\\nConnection: close\\r\\n\"\n         self.parser.parse_header(data)\n         self.assertEqual(self.parser.connection_close, True)\n \n@@ -213,6 +197,50 @@ def test_close_with_no_body_rcv(self):\n         self.parser.body_rcv = None\n         self.parser.close()  # doesn't raise\n \n+    def test_parse_header_lf_only(self):\n+        from waitress.parser import ParsingError\n+\n+        data = b\"GET /foobar HTTP/8.4\\nfoo: bar\"\n+\n+        try:\n+            self.parser.parse_header(data)\n+        except ParsingError:\n+            pass\n+        else:  # pragma: nocover\n+            self.assertTrue(False)\n+\n+    def test_parse_header_cr_only(self):\n+        from waitress.parser import ParsingError\n+\n+        data = b\"GET /foobar HTTP/8.4\\rfoo: bar\"\n+        try:\n+            self.parser.parse_header(data)\n+        except ParsingError:\n+            pass\n+        else:  # pragma: nocover\n+            self.assertTrue(False)\n+\n+    def test_parse_header_extra_lf_in_header(self):\n+        from waitress.parser import ParsingError\n+\n+        data = b\"GET /foobar HTTP/8.4\\r\\nfoo: \\nbar\\r\\n\"\n+        try:\n+            self.parser.parse_header(data)\n+        except ParsingError as e:\n+            self.assertIn(\"Bare CR or LF found in header line\", e.args[0])\n+        else:  # pragma: nocover\n+            self.assertTrue(False)\n+\n+    def test_parse_header_extra_lf_in_first_line(self):\n+        from waitress.parser import ParsingError\n+\n+        data = b\"GET /foobar\\n HTTP/8.4\\r\\n\"\n+        try:\n+            self.parser.parse_header(data)\n+        except ParsingError as e:\n+            self.assertIn(\"Bare CR or LF found in HTTP message\", e.args[0])\n+        else:  # pragma: nocover\n+            self.assertTrue(False)\n \n class Test_split_uri(unittest.TestCase):\n     def _callFUT(self, uri):\n@@ -298,7 +326,7 @@ def _callFUT(self, data):\n         return get_header_lines(data)\n \n     def test_get_header_lines(self):\n-        result = self._callFUT(b\"slam\\nslim\")\n+        result = self._callFUT(b\"slam\\r\\nslim\")\n         self.assertEqual(result, [b\"slam\", b\"slim\"])\n \n     def test_get_header_lines_folded(self):\n@@ -310,11 +338,11 @@ def test_get_header_lines_folded(self):\n         # interpreting the field value or forwarding the message downstream.\n \n         # We are just preserving the whitespace that indicates folding.\n-        result = self._callFUT(b\"slim\\n slam\")\n+        result = self._callFUT(b\"slim\\r\\n slam\")\n         self.assertEqual(result, [b\"slim slam\"])\n \n     def test_get_header_lines_tabbed(self):\n-        result = self._callFUT(b\"slam\\n\\tslim\")\n+        result = self._callFUT(b\"slam\\r\\n\\tslim\")\n         self.assertEqual(result, [b\"slam\\tslim\"])\n \n     def test_get_header_lines_malformed(self):\n@@ -361,55 +389,57 @@ def setUp(self):\n \n     def feed(self, data):\n         parser = self.parser\n+\n         for n in range(100):  # make sure we never loop forever\n             consumed = parser.received(data)\n             data = data[consumed:]\n+\n             if parser.completed:\n                 return\n         raise ValueError(\"Looping\")  # pragma: no cover\n \n     def testSimpleGET(self):\n-        data = b\"\"\"\\\n-GET /foobar HTTP/8.4\n-FirstName: mickey\n-lastname: Mouse\n-content-length: 7\n-\n-Hello.\n-\"\"\"\n+        data = (\n+            b\"GET /foobar HTTP/8.4\\r\\n\"\n+            b\"FirstName: mickey\\r\\n\"\n+            b\"lastname: Mouse\\r\\n\"\n+            b\"content-length: 6\\r\\n\"\n+            b\"\\r\\n\"\n+            b\"Hello.\"\n+        )\n         parser = self.parser\n         self.feed(data)\n         self.assertTrue(parser.completed)\n         self.assertEqual(parser.version, \"8.4\")\n         self.assertFalse(parser.empty)\n         self.assertEqual(\n             parser.headers,\n-            {\"FIRSTNAME\": \"mickey\", \"LASTNAME\": \"Mouse\", \"CONTENT_LENGTH\": \"7\",},\n+            {\"FIRSTNAME\": \"mickey\", \"LASTNAME\": \"Mouse\", \"CONTENT_LENGTH\": \"6\",},\n         )\n         self.assertEqual(parser.path, \"/foobar\")\n         self.assertEqual(parser.command, \"GET\")\n         self.assertEqual(parser.query, \"\")\n         self.assertEqual(parser.proxy_scheme, \"\")\n         self.assertEqual(parser.proxy_netloc, \"\")\n-        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello.\\n\")\n+        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello.\")\n \n     def testComplexGET(self):\n-        data = b\"\"\"\\\n-GET /foo/a+%2B%2F%C3%A4%3D%26a%3Aint?d=b+%2B%2F%3D%26b%3Aint&c+%2B%2F%3D%26c%3Aint=6 HTTP/8.4\n-FirstName: mickey\n-lastname: Mouse\n-content-length: 10\n-\n-Hello mickey.\n-\"\"\"\n+        data = (\n+            b\"GET /foo/a+%2B%2F%C3%A4%3D%26a%3Aint?d=b+%2B%2F%3D%26b%3Aint&c+%2B%2F%3D%26c%3Aint=6 HTTP/8.4\\r\\n\"\n+            b\"FirstName: mickey\\r\\n\"\n+            b\"lastname: Mouse\\r\\n\"\n+            b\"content-length: 10\\r\\n\"\n+            b\"\\r\\n\"\n+            b\"Hello mickey.\"\n+        )\n         parser = self.parser\n         self.feed(data)\n         self.assertEqual(parser.command, \"GET\")\n         self.assertEqual(parser.version, \"8.4\")\n         self.assertFalse(parser.empty)\n         self.assertEqual(\n             parser.headers,\n-            {\"FIRSTNAME\": \"mickey\", \"LASTNAME\": \"Mouse\", \"CONTENT_LENGTH\": \"10\",},\n+            {\"FIRSTNAME\": \"mickey\", \"LASTNAME\": \"Mouse\", \"CONTENT_LENGTH\": \"10\"},\n         )\n         # path should be utf-8 encoded\n         self.assertEqual(\n@@ -422,59 +452,59 @@ def testComplexGET(self):\n         self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello mick\")\n \n     def testProxyGET(self):\n-        data = b\"\"\"\\\n-GET https://example.com:8080/foobar HTTP/8.4\n-content-length: 7\n-\n-Hello.\n-\"\"\"\n+        data = (\n+            b\"GET https://example.com:8080/foobar HTTP/8.4\\r\\n\"\n+            b\"content-length: 6\\r\\n\"\n+            b\"\\r\\n\"\n+            b\"Hello.\"\n+        )\n         parser = self.parser\n         self.feed(data)\n         self.assertTrue(parser.completed)\n         self.assertEqual(parser.version, \"8.4\")\n         self.assertFalse(parser.empty)\n-        self.assertEqual(parser.headers, {\"CONTENT_LENGTH\": \"7\",})\n+        self.assertEqual(parser.headers, {\"CONTENT_LENGTH\": \"6\"})\n         self.assertEqual(parser.path, \"/foobar\")\n         self.assertEqual(parser.command, \"GET\")\n         self.assertEqual(parser.proxy_scheme, \"https\")\n         self.assertEqual(parser.proxy_netloc, \"example.com:8080\")\n         self.assertEqual(parser.command, \"GET\")\n         self.assertEqual(parser.query, \"\")\n-        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello.\\n\")\n+        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello.\")\n \n     def testDuplicateHeaders(self):\n         # Ensure that headers with the same key get concatenated as per\n         # RFC2616.\n-        data = b\"\"\"\\\n-GET /foobar HTTP/8.4\n-x-forwarded-for: 10.11.12.13\n-x-forwarded-for: unknown,127.0.0.1\n-X-Forwarded_for: 255.255.255.255\n-content-length: 7\n-\n-Hello.\n-\"\"\"\n+        data = (\n+            b\"GET /foobar HTTP/8.4\\r\\n\"\n+            b\"x-forwarded-for: 10.11.12.13\\r\\n\"\n+            b\"x-forwarded-for: unknown,127.0.0.1\\r\\n\"\n+            b\"X-Forwarded_for: 255.255.255.255\\r\\n\"\n+            b\"content-length: 6\\r\\n\"\n+            b\"\\r\\n\"\n+            b\"Hello.\"\n+        )\n         self.feed(data)\n         self.assertTrue(self.parser.completed)\n         self.assertEqual(\n             self.parser.headers,\n             {\n-                \"CONTENT_LENGTH\": \"7\",\n+                \"CONTENT_LENGTH\": \"6\",\n                 \"X_FORWARDED_FOR\": \"10.11.12.13, unknown,127.0.0.1\",\n             },\n         )\n \n     def testSpoofedHeadersDropped(self):\n-        data = b\"\"\"\\\n-GET /foobar HTTP/8.4\n-x-auth_user: bob\n-content-length: 7\n-\n-Hello.\n-\"\"\"\n+        data = (\n+            b\"GET /foobar HTTP/8.4\\r\\n\"\n+            b\"x-auth_user: bob\\r\\n\"\n+            b\"content-length: 6\\r\\n\"\n+            b\"\\r\\n\"\n+            b\"Hello.\"\n+        )\n         self.feed(data)\n         self.assertTrue(self.parser.completed)\n-        self.assertEqual(self.parser.headers, {\"CONTENT_LENGTH\": \"7\",})\n+        self.assertEqual(self.parser.headers, {\"CONTENT_LENGTH\": \"6\",})\n \n \n class DummyBodyStream(object):"
        },
        {
          "filename": "waitress/tests/test_receiver.py",
          "status": "modified",
          "additions": 51,
          "deletions": 7,
          "patch": "@@ -83,27 +83,27 @@ def test_received_control_line_notfinished(self):\n     def test_received_control_line_finished_garbage_in_input(self):\n         buf = DummyBuffer()\n         inst = self._makeOne(buf)\n-        result = inst.received(b\"garbage\\n\")\n-        self.assertEqual(result, 8)\n+        result = inst.received(b\"garbage\\r\\n\")\n+        self.assertEqual(result, 9)\n         self.assertTrue(inst.error)\n \n     def test_received_control_line_finished_all_chunks_not_received(self):\n         buf = DummyBuffer()\n         inst = self._makeOne(buf)\n-        result = inst.received(b\"a;discard\\n\")\n+        result = inst.received(b\"a;discard\\r\\n\")\n         self.assertEqual(inst.control_line, b\"\")\n         self.assertEqual(inst.chunk_remainder, 10)\n         self.assertEqual(inst.all_chunks_received, False)\n-        self.assertEqual(result, 10)\n+        self.assertEqual(result, 11)\n         self.assertEqual(inst.completed, False)\n \n     def test_received_control_line_finished_all_chunks_received(self):\n         buf = DummyBuffer()\n         inst = self._makeOne(buf)\n-        result = inst.received(b\"0;discard\\n\")\n+        result = inst.received(b\"0;discard\\r\\n\")\n         self.assertEqual(inst.control_line, b\"\")\n         self.assertEqual(inst.all_chunks_received, True)\n-        self.assertEqual(result, 10)\n+        self.assertEqual(result, 11)\n         self.assertEqual(inst.completed, False)\n \n     def test_received_trailer_startswith_crlf(self):\n@@ -120,7 +120,7 @@ def test_received_trailer_startswith_lf(self):\n         inst.all_chunks_received = True\n         result = inst.received(b\"\\n\")\n         self.assertEqual(result, 1)\n-        self.assertEqual(inst.completed, True)\n+        self.assertEqual(inst.completed, False)\n \n     def test_received_trailer_not_finished(self):\n         buf = DummyBuffer()\n@@ -154,6 +154,50 @@ def test___len__(self):\n         inst = self._makeOne(buf)\n         self.assertEqual(inst.__len__(), 2)\n \n+    def test_received_chunk_is_properly_terminated(self):\n+        buf = DummyBuffer()\n+        inst = self._makeOne(buf)\n+        data = b\"4\\r\\nWiki\\r\\n\"\n+        result = inst.received(data)\n+        self.assertEqual(result, len(data))\n+        self.assertEqual(inst.completed, False)\n+        self.assertEqual(buf.data[0], b\"Wiki\")\n+\n+    def test_received_chunk_not_properly_terminated(self):\n+        from waitress.utilities import BadRequest\n+\n+        buf = DummyBuffer()\n+        inst = self._makeOne(buf)\n+        data = b\"4\\r\\nWikibadchunk\\r\\n\"\n+        result = inst.received(data)\n+        self.assertEqual(result, len(data))\n+        self.assertEqual(inst.completed, False)\n+        self.assertEqual(buf.data[0], b\"Wiki\")\n+        self.assertEqual(inst.error.__class__, BadRequest)\n+\n+    def test_received_multiple_chunks(self):\n+        from waitress.utilities import BadRequest\n+\n+        buf = DummyBuffer()\n+        inst = self._makeOne(buf)\n+        data = (\n+            b\"4\\r\\n\"\n+            b\"Wiki\\r\\n\"\n+            b\"5\\r\\n\"\n+            b\"pedia\\r\\n\"\n+            b\"E\\r\\n\"\n+            b\" in\\r\\n\"\n+            b\"\\r\\n\"\n+            b\"chunks.\\r\\n\"\n+            b\"0\\r\\n\"\n+            b\"\\r\\n\"\n+        )\n+        result = inst.received(data)\n+        self.assertEqual(result, len(data))\n+        self.assertEqual(inst.completed, True)\n+        self.assertEqual(b\"\".join(buf.data), b\"Wikipedia in\\r\\n\\r\\nchunks.\")\n+        self.assertEqual(inst.error, None)\n+\n \n class DummyBuffer(object):\n     def __init__(self, data=None):"
        },
        {
          "filename": "waitress/tests/test_utilities.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -83,7 +83,7 @@ def test_one_linefeed(self):\n         self.assertEqual(self._callFUT(b\"\\n\"), -1)\n \n     def test_double_linefeed(self):\n-        self.assertEqual(self._callFUT(b\"\\n\\n\"), 2)\n+        self.assertEqual(self._callFUT(b\"\\n\\n\"), -1)\n \n     def test_one_crlf(self):\n         self.assertEqual(self._callFUT(b\"\\r\\n\"), -1)\n@@ -92,7 +92,7 @@ def test_double_crfl(self):\n         self.assertEqual(self._callFUT(b\"\\r\\n\\r\\n\"), 4)\n \n     def test_mixed(self):\n-        self.assertEqual(self._callFUT(b\"\\n\\n00\\r\\n\\r\\n\"), 2)\n+        self.assertEqual(self._callFUT(b\"\\n\\n00\\r\\n\\r\\n\"), 8)\n \n \n class TestBadRequest(unittest.TestCase):"
        },
        {
          "filename": "waitress/utilities.py",
          "status": "modified",
          "additions": 6,
          "deletions": 14,
          "patch": "@@ -28,20 +28,12 @@\n \n def find_double_newline(s):\n     \"\"\"Returns the position just after a double newline in the given string.\"\"\"\n-    pos1 = s.find(b\"\\n\\r\\n\")  # One kind of double newline\n-    if pos1 >= 0:\n-        pos1 += 3\n-    pos2 = s.find(b\"\\n\\n\")  # Another kind of double newline\n-    if pos2 >= 0:\n-        pos2 += 2\n-\n-    if pos1 >= 0:\n-        if pos2 >= 0:\n-            return min(pos1, pos2)\n-        else:\n-            return pos1\n-    else:\n-        return pos2\n+    pos = s.find(b\"\\r\\n\\r\\n\")\n+\n+    if pos >= 0:\n+        pos += 4\n+\n+    return pos\n \n \n def concat(*args):"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 5,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "fc592e804a1aed87654c1ad21337dad86582c71f",
            "date": "2024-11-25T01:07:27Z",
            "author_login": "mmerickel"
          },
          {
            "sha": "7a19337321c43b81076da20bc9c4e2e077a7e01c",
            "date": "2024-11-24T19:55:09Z",
            "author_login": "kgaughan"
          },
          {
            "sha": "2a1524a9b5786459786a4b86e5b2f09d1041e53d",
            "date": "2024-11-23T19:40:01Z",
            "author_login": "kgaughan"
          },
          {
            "sha": "b11ae729cc51ca2998a1ad9b4992b34f34ac95e7",
            "date": "2024-11-16T19:46:41Z",
            "author_login": "digitalresistor"
          },
          {
            "sha": "38ffad094b785168aba197f6b6d8df5de713cc2b",
            "date": "2024-11-16T19:39:00Z",
            "author_login": "digitalresistor"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:L/A:N",
    "cwe_id": "CWE-444",
    "description": "Waitress through version 1.3.1 implemented a \"MAY\" part of the RFC7230 which states: \"Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.\" Unfortunately if a front-end server does not parse header fields with an LF the same way as it does those with a CRLF it can lead to the front-end and the back-end server parsing the same HTTP message in two different ways. This can lead to a potential for HTTP request smuggling/splitting whereby Waitress may see two requests while the front-end server only sees a single HTTP message. This issue is fixed in Waitress 1.4.0.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2019-12-20T23:15:11.167",
    "last_modified": "2024-11-21T04:31:11.193",
    "fix_date": "2019-12-12T22:55:36Z"
  },
  "references": [
    {
      "url": "https://access.redhat.com/errata/RHSA-2020:0720",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://docs.pylonsproject.org/projects/waitress/en/latest/#security-fixes",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/Pylons/waitress/commit/8eba394ad75deaf9e5cd15b78a3d16b12e6b0eba",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Pylons/waitress/security/advisories/GHSA-pg36-wpm5-g57p",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00011.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GVDHR2DNKCNQ7YQXISJ45NT4IQDX3LJ7/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LYEOTGWJZVKPRXX2HBNVIYWCX73QYPM5/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpuapr2022.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2020:0720",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://docs.pylonsproject.org/projects/waitress/en/latest/#security-fixes",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/Pylons/waitress/commit/8eba394ad75deaf9e5cd15b78a3d16b12e6b0eba",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Pylons/waitress/security/advisories/GHSA-pg36-wpm5-g57p",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00011.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GVDHR2DNKCNQ7YQXISJ45NT4IQDX3LJ7/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LYEOTGWJZVKPRXX2HBNVIYWCX73QYPM5/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpuapr2022.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:24.267133",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "waitress",
    "owner": "Pylons",
    "created_at": "2011-12-17T06:58:21Z",
    "updated_at": "2025-01-24T08:47:57Z",
    "pushed_at": "2024-11-25T01:07:27Z",
    "size": 1868,
    "stars": 1468,
    "forks": 178,
    "open_issues": 16,
    "watchers": 1468,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Python": 495340
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T08:28:55.652876"
  }
}