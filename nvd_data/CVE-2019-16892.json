{
  "cve_id": "CVE-2019-16892",
  "github_data": {
    "repository": "rubyzip/rubyzip",
    "fix_commit": "d65fe7bd283ec94f9d6dc7605f61a6b0dd00f55e",
    "related_commits": [
      "d65fe7bd283ec94f9d6dc7605f61a6b0dd00f55e",
      "d65fe7bd283ec94f9d6dc7605f61a6b0dd00f55e"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "d65fe7bd283ec94f9d6dc7605f61a6b0dd00f55e",
      "commit_date": "2019-09-25T18:56:00Z",
      "author": {
        "login": "jdleesmiller",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #403 from rubyzip/check-size",
        "length": 85,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 163,
        "additions": 149,
        "deletions": 14
      },
      "files": [
        {
          "filename": "Changelog.md",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -1,5 +1,16 @@\n # X.X.X (Next)\n \n+-\n+\n+# 1.3.0 (Next)\n+\n+Security\n+\n+- Add `validate_entry_sizes` option so that callers can trust an entry's reported size when using `extract` [#403](https://github.com/rubyzip/rubyzip/pull/403)\n+   - This option defaults to `false` for backward compatibility in this release, but you are strongly encouraged to set it to `true`. It will default to `true` in rubyzip 2.0.\n+\n+New Feature\n+\n - Add `add_stored` method to simplify adding entries without compression [#366](https://github.com/rubyzip/rubyzip/pull/366)\n \n Tooling / Documentation"
        },
        {
          "filename": "README.md",
          "status": "modified",
          "additions": 60,
          "deletions": 13,
          "patch": "@@ -152,19 +152,23 @@ When modifying a zip archive the file permissions of the archive are preserved.\n ### Reading a Zip file\n \n ```ruby\n+MAX_SIZE = 1024**2 # 1MiB (but of course you can increase this)\n Zip::File.open('foo.zip') do |zip_file|\n   # Handle entries one by one\n   zip_file.each do |entry|\n-    # Extract to file/directory/symlink\n     puts \"Extracting #{entry.name}\"\n-    entry.extract(dest_file)\n+    raise 'File too large when extracted' if entry.size > MAX_SIZE\n+\n+    # Extract to file or directory based on name in the archive\n+    entry.extract\n \n     # Read into memory\n     content = entry.get_input_stream.read\n   end\n \n   # Find specific entry\n   entry = zip_file.glob('*.csv').first\n+  raise 'File too large when extracted' if entry.size > MAX_SIZE\n   puts entry.get_input_stream.read\n end\n ```\n@@ -219,6 +223,8 @@ File.open(new_path, \"wb\") {|f| f.write(buffer.string) }\n \n ## Configuration\n \n+### Existing Files\n+\n By default, rubyzip will not overwrite files if they already exist inside of the extracted path. To change this behavior, you may specify a configuration option like so:\n \n ```ruby\n@@ -233,18 +239,63 @@ Additionally, if you want to configure rubyzip to overwrite existing files while\n Zip.continue_on_exists_proc = true\n ```\n \n+### Non-ASCII Names\n+\n If you want to store non-english names and want to open them on Windows(pre 7) you need to set this option:\n \n ```ruby\n Zip.unicode_names = true\n ```\n \n+Sometimes file names inside zip contain non-ASCII characters. If you can assume which encoding was used for such names and want to be able to find such entries using `find_entry` then you can force assumed encoding like so:\n+\n+```ruby\n+Zip.force_entry_names_encoding = 'UTF-8'\n+```\n+\n+Allowed encoding names are the same as accepted by `String#force_encoding`\n+\n+### Date Validation\n+\n Some zip files might have an invalid date format, which will raise a warning. You can hide this warning with the following setting:\n \n ```ruby\n Zip.warn_invalid_date = false\n ```\n \n+### Size Validation\n+\n+**This setting defaults to `false` in rubyzip 1.3 for backward compatibility, but it will default to `true` in rubyzip 2.0.**\n+\n+If you set\n+```\n+Zip.validate_entry_sizes = true\n+```\n+then `rubyzip`'s `extract` method checks that an entry's reported uncompressed size is not (significantly) smaller than its actual size. This is to help you protect your application against [zip bombs](https://en.wikipedia.org/wiki/Zip_bomb). Before `extract`ing an entry, you should check that its size is in the range you expect. For example, if your application supports processing up to 100 files at once, each up to 10MiB, your zip extraction code might look like:\n+\n+```ruby\n+MAX_FILE_SIZE = 10 * 1024**2 # 10MiB\n+MAX_FILES = 100\n+Zip::File.open('foo.zip') do |zip_file|\n+  num_files = 0\n+  zip_file.each do |entry|\n+    num_files += 1 if entry.file?\n+    raise 'Too many extracted files' if num_files > MAX_FILES\n+    raise 'File too large when extracted' if entry.size > MAX_FILE_SIZE\n+    entry.extract\n+  end\n+end\n+```\n+\n+If you need to extract zip files that report incorrect uncompressed sizes and you really trust them not too be too large, you can disable this setting with\n+```ruby\n+Zip.validate_entry_sizes = false\n+```\n+\n+Note that if you use the lower level `Zip::InputStream` interface, `rubyzip` does *not* check the entry `size`s. In this case, the caller is responsible for making sure it does not read more data than expected from the input stream.\n+\n+### Default Compression\n+\n You can set the default compression level like so:\n \n ```ruby\n@@ -253,13 +304,17 @@ Zip.default_compression = Zlib::DEFAULT_COMPRESSION\n \n It defaults to `Zlib::DEFAULT_COMPRESSION`. Possible values are `Zlib::BEST_COMPRESSION`, `Zlib::DEFAULT_COMPRESSION` and `Zlib::NO_COMPRESSION`\n \n-Sometimes file names inside zip contain non-ASCII characters. If you can assume which encoding was used for such names and want to be able to find such entries using `find_entry` then you can force assumed encoding like so:\n+### Zip64 Support\n+\n+By default, Zip64 support is disabled for writing. To enable it do this:\n \n ```ruby\n-Zip.force_entry_names_encoding = 'UTF-8'\n+Zip.write_zip64_support = true\n ```\n \n-Allowed encoding names are the same as accepted by `String#force_encoding`\n+_NOTE_: If you will enable Zip64 writing then you will need zip extractor with Zip64 support to extract archive.\n+\n+### Block Form\n \n You can set multiple settings at the same time by using a block:\n \n@@ -272,14 +327,6 @@ You can set multiple settings at the same time by using a block:\n   end\n ```\n \n-By default, Zip64 support is disabled for writing. To enable it do this:\n-\n-```ruby\n-Zip.write_zip64_support = true\n-```\n-\n-_NOTE_: If you will enable Zip64 writing then you will need zip extractor with Zip64 support to extract archive.\n-\n ## Developing\n \n To run the test you need to do this:"
        },
        {
          "filename": "lib/zip.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -42,7 +42,8 @@ module Zip\n                 :write_zip64_support,\n                 :warn_invalid_date,\n                 :case_insensitive_match,\n-                :force_entry_names_encoding\n+                :force_entry_names_encoding,\n+                :validate_entry_sizes\n \n   def reset!\n     @_ran_once = false\n@@ -54,6 +55,7 @@ def reset!\n     @write_zip64_support = false\n     @warn_invalid_date = true\n     @case_insensitive_match = false\n+    @validate_entry_sizes = false\n   end\n \n   def setup"
        },
        {
          "filename": "lib/zip/entry.rb",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -603,9 +603,21 @@ def create_file(dest_path, _continue_on_exists_proc = proc { Zip.continue_on_exi\n         get_input_stream do |is|\n           set_extra_attributes_on_path(dest_path)\n \n+          bytes_written = 0\n+          warned = false\n           buf = ''.dup\n           while (buf = is.sysread(::Zip::Decompressor::CHUNK_SIZE, buf))\n             os << buf\n+            bytes_written += buf.bytesize\n+            if bytes_written > size && !warned\n+              message = \"Entry #{name} should be #{size}B but is larger when inflated\"\n+              if ::Zip.validate_entry_sizes\n+                raise ::Zip::EntrySizeError, message\n+              else\n+                puts \"WARNING: #{message}\"\n+                warned = true\n+              end\n+            end\n           end\n         end\n       end"
        },
        {
          "filename": "lib/zip/errors.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -4,6 +4,7 @@ class EntryExistsError < Error; end\n   class DestinationFileExistsError < Error; end\n   class CompressionMethodError < Error; end\n   class EntryNameError < Error; end\n+  class EntrySizeError < Error; end\n   class InternalError < Error; end\n   class GPFBit3Error < Error; end\n "
        },
        {
          "filename": "test/file_extract_test.rb",
          "status": "modified",
          "additions": 62,
          "deletions": 0,
          "patch": "@@ -10,6 +10,10 @@ def setup\n     ::File.delete(EXTRACTED_FILENAME) if ::File.exist?(EXTRACTED_FILENAME)\n   end\n \n+  def teardown\n+    ::Zip.reset!\n+  end\n+\n   def test_extract\n     ::Zip::File.open(TEST_ZIP.zip_name) do |zf|\n       zf.extract(ENTRY_TO_EXTRACT, EXTRACTED_FILENAME)\n@@ -80,4 +84,62 @@ def test_extract_non_entry_2\n     end\n     assert(!File.exist?(outFile))\n   end\n+\n+  def test_extract_incorrect_size\n+    # The uncompressed size fields in the zip file cannot be trusted. This makes\n+    # it harder for callers to validate the sizes of the files they are\n+    # extracting, which can lead to denial of service. See also\n+    # https://en.wikipedia.org/wiki/Zip_bomb\n+    Dir.mktmpdir do |tmp|\n+      real_zip = File.join(tmp, 'real.zip')\n+      fake_zip = File.join(tmp, 'fake.zip')\n+      file_name = 'a'\n+      true_size = 500_000\n+      fake_size = 1\n+\n+      ::Zip::File.open(real_zip, ::Zip::File::CREATE) do |zf|\n+        zf.get_output_stream(file_name) do |os|\n+          os.write 'a' * true_size\n+        end\n+      end\n+\n+      compressed_size = nil\n+      ::Zip::File.open(real_zip) do |zf|\n+        a_entry = zf.find_entry(file_name)\n+        compressed_size = a_entry.compressed_size\n+        assert_equal true_size, a_entry.size\n+      end\n+\n+      true_size_bytes = [compressed_size, true_size, file_name.size].pack('LLS')\n+      fake_size_bytes = [compressed_size, fake_size, file_name.size].pack('LLS')\n+\n+      data = File.binread(real_zip)\n+      assert data.include?(true_size_bytes)\n+      data.gsub! true_size_bytes, fake_size_bytes\n+\n+      File.open(fake_zip, 'wb') do |file|\n+        file.write data\n+      end\n+\n+      Dir.chdir tmp do\n+        ::Zip::File.open(fake_zip) do |zf|\n+          a_entry = zf.find_entry(file_name)\n+          assert_equal fake_size, a_entry.size\n+\n+          ::Zip.validate_entry_sizes = false\n+          a_entry.extract\n+          assert_equal true_size, File.size(file_name)\n+          FileUtils.rm file_name\n+\n+          ::Zip.validate_entry_sizes = true\n+          error = assert_raises ::Zip::EntrySizeError do\n+            a_entry.extract\n+          end\n+          assert_equal \\\n+            'Entry a should be 1B but is larger when inflated',\n+            error.message\n+        end\n+      end\n+    end\n+  end\n end"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "3f909b2bdc89e406ce26fd864b110f4b1b90197b",
            "date": "2025-01-11T10:21:42Z",
            "author_login": "tagliala"
          },
          {
            "sha": "f7c6b79256f99311231747ff9cc6a169a2014628",
            "date": "2025-01-25T09:55:27Z",
            "author_login": "hainesr"
          },
          {
            "sha": "8ed666289129ffe2b826ccec4824290520b843f0",
            "date": "2025-01-06T22:03:49Z",
            "author_login": "tagliala"
          },
          {
            "sha": "0d920d552f809a261c31345b8009752f65a01fdb",
            "date": "2025-01-07T07:40:56Z",
            "author_login": "tagliala"
          },
          {
            "sha": "89cdf82a7794dbbd4d4bcfd4726eb42641257d5b",
            "date": "2025-01-05T19:24:16Z",
            "author_login": "hainesr"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
    "cwe_id": null,
    "description": "In Rubyzip before 1.3.0, a crafted ZIP file can bypass application checks on ZIP entry sizes because data about the uncompressed size can be spoofed. This allows attackers to cause a denial of service (disk consumption).",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2019-09-25T22:15:10.023",
    "last_modified": "2024-11-21T04:31:17.280",
    "fix_date": "2019-09-25T18:56:00Z"
  },
  "references": [
    {
      "url": "https://access.redhat.com/errata/RHBA-2019:4047",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:4201",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/rubyzip/rubyzip/commit/d65fe7bd283ec94f9d6dc7605f61a6b0dd00f55e",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/rubyzip/rubyzip/pull/403",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/J45KSFPP6DFVWLC7Z73L7SX735CKZYO6/",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/MWWPORMSBHZTMP4PGF4DQD22TTKBQMMC/",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/X255K6ZBAQC462PQN2ND5HOTTQEJ2G2X/",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHBA-2019:4047",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/errata/RHSA-2019:4201",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/rubyzip/rubyzip/commit/d65fe7bd283ec94f9d6dc7605f61a6b0dd00f55e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/rubyzip/rubyzip/pull/403",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/J45KSFPP6DFVWLC7Z73L7SX735CKZYO6/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/MWWPORMSBHZTMP4PGF4DQD22TTKBQMMC/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/X255K6ZBAQC462PQN2ND5HOTTQEJ2G2X/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T22:59:59.912914",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "rubyzip",
    "owner": "rubyzip",
    "created_at": "2010-09-24T10:50:15Z",
    "updated_at": "2025-01-25T17:47:32Z",
    "pushed_at": "2025-01-25T17:47:29Z",
    "size": 2828,
    "stars": 1363,
    "forks": 313,
    "open_issues": 34,
    "watchers": 1363,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Ruby": 341970,
      "Makefile": 370
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-2-clause"
    },
    "collected_at": "2025-01-26T08:04:43.089162"
  }
}