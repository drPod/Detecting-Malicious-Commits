{
  "cve_id": "CVE-2019-18671",
  "github_data": {
    "repository": "keepkey/keepkey-firmware",
    "fix_commit": "b222c66cdd7c3203d917c80ba615082d309d80c3",
    "related_commits": [
      "b222c66cdd7c3203d917c80ba615082d309d80c3",
      "b222c66cdd7c3203d917c80ba615082d309d80c3"
    ],
    "patch_url": "https://github.com/keepkey/keepkey-firmware/commit/b222c66cdd7c3203d917c80ba615082d309d80c3.patch",
    "fix_commit_details": {
      "sha": "b222c66cdd7c3203d917c80ba615082d309d80c3",
      "commit_date": "2019-09-11T19:20:00Z",
      "author": {
        "login": "keepkeyjon",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "board: factor out tiny_dispatch",
        "length": 102,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 156,
        "additions": 85,
        "deletions": 71
      },
      "files": [
        {
          "filename": "lib/board/messages.c",
          "status": "modified",
          "additions": 85,
          "deletions": 71,
          "patch": "@@ -37,11 +37,6 @@ static msg_failure_t msg_failure;\n static msg_debug_link_get_state_t msg_debug_link_get_state;\n #endif\n \n-/* Tiny messages */\n-static bool msg_tiny_flag = false;\n-static CONFIDENTIAL uint8_t msg_tiny[MSG_TINY_BFR_SZ];\n-static uint16_t msg_tiny_id = MSG_TINY_TYPE_ERROR; /* Default to error type */\n-\n /* Allow mapped messages to reset message stack.  This variable by itself doesn't\n  * do much but messages down the line can use it to determine for to gracefully\n  * exit from a message should the message stack been reset\n@@ -147,28 +142,6 @@ static void dispatch(const MessagesMap_t *entry, uint8_t *msg, uint32_t msg_size\n     entry->process_func(decode_buffer);\n }\n \n-/*\n- * tiny_dispatch() - Process received tiny messages\n- *\n- * INPUT\n- *     - entry: pointer to message entry\n- *     - msg: pointer to received message buffer\n- *     - msg_size: size of message\n- * OUTPUT\n- *     none\n- *\n- */\n-static void tiny_dispatch(const MessagesMap_t *entry, uint8_t *msg, uint32_t msg_size)\n-{\n-    if (!pb_parse(entry, msg, msg_size, msg_tiny)) {\n-        call_msg_failure_handler(FailureType_Failure_UnexpectedMessage,\n-                                 \"Could not parse tiny protocol buffer message\");\n-        return;\n-    }\n-\n-    msg_tiny_id = entry->msg_id;\n-}\n-\n /*\n  * raw_dispatch() - Process messages that will not be parsed by protocol buffers\n  * and should be manually parsed at message function\n@@ -337,31 +310,93 @@ void usb_rx_helper(const uint8_t *buf, size_t length, MessageMapType type)\n     entry = NULL;\n }\n \n-void handle_usb_rx(const void *msg, size_t len)\n-{\n-    if (msg_tiny_flag) {\n-        uint8_t buf[64];\n-        memcpy(buf, msg, sizeof(buf));\n-\n-        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n-        uint32_t msgSize = buf[8]        |\n-                ((uint32_t)buf[7]) <<  8 |\n-                ((uint32_t)buf[6]) << 16 |\n-                ((uint32_t)buf[5]) << 24;\n-\n-        if (msgSize > 64 - 9) {\n-            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n-            return;\n-        }\n+/* Tiny messages */\n+static bool msg_tiny_flag = false;\n+static CONFIDENTIAL uint8_t msg_tiny[MSG_TINY_BFR_SZ];\n+static uint16_t msg_tiny_id = MSG_TINY_TYPE_ERROR; /* Default to error type */\n \n-        // Determine callback handler and message map type.\n-        const MessagesMap_t *entry = message_map_entry(NORMAL_MSG, msgId, IN_MSG);\n-        if (!entry) {\n-            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n-            return;\n+_Static_assert(sizeof(msg_tiny) >= sizeof(Cancel), \"msg_tiny too tiny\");\n+_Static_assert(sizeof(msg_tiny) >= sizeof(Initialize), \"msg_tiny too tiny\");\n+_Static_assert(sizeof(msg_tiny) >= sizeof(PassphraseAck), \"msg_tiny too tiny\");\n+_Static_assert(sizeof(msg_tiny) >= sizeof(ButtonAck), \"msg_tiny too tiny\");\n+_Static_assert(sizeof(msg_tiny) >= sizeof(PinMatrixAck), \"msg_tiny too tiny\");\n+#if DEBUG_LINK\n+_Static_assert(sizeof(msg_tiny) >= sizeof(DebugLinkDecision),\n+               \"msg_tiny too tiny\");\n+_Static_assert(sizeof(msg_tiny) >= sizeof(DebugLinkGetState),\n+               \"msg_tiny too tiny\");\n+#endif\n+\n+static void msg_read_tiny(const uint8_t *msg, size_t len) {\n+    if (len != 64)\n+        return;\n+\n+    uint8_t buf[64];\n+    memcpy(buf, msg, sizeof(buf));\n+\n+    if (buf[0] != '?' || buf[1] != '#' || buf[2] != '#') {\n+        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n+        return;\n+    }\n+\n+    uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n+    uint32_t msgSize = buf[8]        |\n+            ((uint32_t)buf[7]) <<  8 |\n+            ((uint32_t)buf[6]) << 16 |\n+            ((uint32_t)buf[5]) << 24;\n+\n+    if (msgSize > 64 - 9) {\n+        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n+        return;\n+    }\n+\n+    const pb_field_t *fields = NULL;\n+    pb_istream_t stream = pb_istream_from_buffer(buf + 9, msgSize);\n+\n+    switch (msgId) {\n+    case MessageType_MessageType_PinMatrixAck:\n+        fields = PinMatrixAck_fields;\n+        break;\n+    case MessageType_MessageType_ButtonAck:\n+        fields = ButtonAck_fields;\n+        break;\n+    case MessageType_MessageType_PassphraseAck:\n+        fields = PassphraseAck_fields;\n+        break;\n+    case MessageType_MessageType_Cancel:\n+        fields = Cancel_fields;\n+        break;\n+    case MessageType_MessageType_Initialize:\n+        fields = Initialize_fields;\n+        break;\n+#if DEBUG_LINK\n+    case MessageType_MessageType_DebugLinkDecision:\n+        fields = DebugLinkDecision_fields;\n+        break;\n+    case MessageType_MessageType_DebugLinkGetState:\n+        fields = DebugLinkGetState_fields;\n+        break;\n+#endif\n+    }\n+\n+    if (fields) {\n+        bool status = pb_decode(&stream, fields, msg_tiny);\n+        if (status) {\n+            msg_tiny_id = msgId;\n+        } else {\n+            (*msg_failure)(FailureType_Failure_SyntaxError, stream.errmsg);\n+            msg_tiny_id = 0xffff;\n         }\n+    } else {\n+        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n+        msg_tiny_id = 0xffff;\n+    }\n+}\n \n-        tiny_dispatch(entry, buf + 9, msgSize);\n+void handle_usb_rx(const void *msg, size_t len)\n+{\n+    if (msg_tiny_flag) {\n+        msg_read_tiny(msg, len);\n     } else {\n         usb_rx_helper(msg, len, NORMAL_MSG);\n     }\n@@ -371,28 +406,7 @@ void handle_usb_rx(const void *msg, size_t len)\n void handle_debug_usb_rx(const void *msg, size_t len)\n {\n     if (msg_tiny_flag) {\n-        uint8_t buf[64];\n-        memcpy(buf, msg, sizeof(buf));\n-\n-        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n-        uint32_t msgSize = buf[8]        |\n-                ((uint32_t)buf[7]) <<  8 |\n-                ((uint32_t)buf[6]) << 16 |\n-                ((uint32_t)buf[5]) << 24;\n-\n-        if (msgSize > 64 - 9) {\n-            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n-            return;\n-        }\n-\n-        // Determine callback handler and message map type.\n-        const MessagesMap_t *entry = message_map_entry(DEBUG_MSG, msgId, IN_MSG);\n-        if (!entry) {\n-            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n-            return;\n-        }\n-\n-        tiny_dispatch(entry, buf + 9, msgSize);\n+        msg_read_tiny(msg, len);\n     } else {\n         usb_rx_helper(msg, len, DEBUG_MSG);\n     }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "742a7d62e31465696509d8a8f32ebae9c4c703fa",
            "date": "2024-03-06T02:12:26Z",
            "author_login": "pastaghost"
          },
          {
            "sha": "a8d9caae87119e739dfd6ad709144305884aac85",
            "date": "2024-03-06T02:06:47Z",
            "author_login": "pastaghost"
          },
          {
            "sha": "33b3ae5f5371c3e17616e3070ef048c048f59080",
            "date": "2024-03-05T21:25:07Z",
            "author_login": "pastaghost"
          },
          {
            "sha": "1297662a2313fa6b363440458f0964be970fe9e3",
            "date": "2024-03-04T22:52:35Z",
            "author_login": "pastaghost"
          },
          {
            "sha": "50164a2eece63b84f1d5d4ff80df1184d3bb17c2",
            "date": "2024-03-04T22:52:28Z",
            "author_login": "pastaghost"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-787",
    "description": "Insufficient checks in the USB packet handling of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow out-of-bounds writes in the .bss segment via crafted messages. The vulnerability could allow code execution or other forms of impact. It can be triggered by unauthenticated attackers and the interface is reachable via WebUSB.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2019-12-06T18:15:12.653",
    "last_modified": "2024-11-21T04:33:29.950",
    "fix_date": "2019-09-11T19:20:00Z"
  },
  "references": [
    {
      "url": "https://blog.inhq.net/posts/keepkey-CVE-2019-18671/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/keepkey/keepkey-firmware/commit/b222c66cdd7c3203d917c80ba615082d309d80c3",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://medium.com/shapeshift-stories/keepkey-release-notes-v-6f7d2ec78065",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://medium.com/shapeshift-stories/shapeshift-security-update-8ec89bb1b4e3",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://blog.inhq.net/posts/keepkey-CVE-2019-18671/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/keepkey/keepkey-firmware/commit/b222c66cdd7c3203d917c80ba615082d309d80c3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://medium.com/shapeshift-stories/keepkey-release-notes-v-6f7d2ec78065",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://medium.com/shapeshift-stories/shapeshift-security-update-8ec89bb1b4e3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:24.248762",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "keepkey-firmware",
    "owner": "keepkey",
    "created_at": "2015-07-21T16:37:45Z",
    "updated_at": "2025-01-07T15:34:05Z",
    "pushed_at": "2024-03-06T02:19:56Z",
    "size": 40493,
    "stars": 157,
    "forks": 103,
    "open_issues": 14,
    "watchers": 157,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "beta"
    ],
    "languages": {
      "C": 1873217,
      "C++": 92884,
      "CMake": 37609,
      "Assembly": 28081,
      "Shell": 8597,
      "Dockerfile": 2436,
      "Python": 1057,
      "Pawn": 656,
      "GDB": 179
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-3.0"
    },
    "collected_at": "2025-01-14T13:13:29.883414"
  }
}