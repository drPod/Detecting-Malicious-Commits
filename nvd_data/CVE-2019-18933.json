{
  "cve_id": "CVE-2019-18933",
  "github_data": {
    "repository": "zulip/zulip",
    "fix_commit": "0c2cc41d2e40807baa5ee2c72987ebfb64ea2eb6",
    "related_commits": [
      "0c2cc41d2e40807baa5ee2c72987ebfb64ea2eb6",
      "0c2cc41d2e40807baa5ee2c72987ebfb64ea2eb6"
    ],
    "patch_url": "https://github.com/zulip/zulip/commit/0c2cc41d2e40807baa5ee2c72987ebfb64ea2eb6.patch",
    "fix_commit_details": {
      "sha": "0c2cc41d2e40807baa5ee2c72987ebfb64ea2eb6",
      "commit_date": "2019-11-18T06:57:36Z",
      "author": {
        "login": "mateuszmandera",
        "type": "User",
        "stats": {
          "total_commits": 1273,
          "average_weekly_commits": 1.9675425038639875,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 268
        }
      },
      "commit_message": {
        "title": "CVE-2019-18933: Fix insecure account creation via social authentication.",
        "length": 1932,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 286,
        "additions": 283,
        "deletions": 3
      },
      "files": [
        {
          "filename": "tools/linter_lib/custom_check.py",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -416,6 +416,7 @@\n              'zerver/migrations/0060_move_avatars_to_be_uid_based.py',\n              'zerver/migrations/0104_fix_unreads.py',\n              'zerver/migrations/0206_stream_rendered_description.py',\n+             'zerver/migrations/0209_user_profile_no_empty_password.py',\n              'pgroonga/migrations/0002_html_escape_subject.py',\n          ]),\n          'description': \"Don't import models or other code in migrations; see docs/subsystems/schema-migrations.md\","
        },
        {
          "filename": "zerver/migrations/0209_user_profile_no_empty_password.py",
          "status": "added",
          "additions": 234,
          "deletions": 0,
          "patch": "@@ -0,0 +1,234 @@\n+# -*- coding: utf-8 -*-\n+# Generated by Django 1.11.24 on 2019-10-16 22:48\n+from __future__ import unicode_literals\n+\n+from django.conf import settings\n+from django.contrib.auth import get_backends\n+from django.db import migrations\n+from django.db.backends.postgresql_psycopg2.schema import DatabaseSchemaEditor\n+from django.db.migrations.state import StateApps\n+from django.contrib.auth.hashers import check_password, make_password\n+from django.utils.timezone import now as timezone_now\n+\n+from zerver.lib.cache import cache_delete, user_profile_by_api_key_cache_key\n+from zerver.lib.queue import queue_json_publish\n+from zerver.lib.utils import generate_api_key\n+from zproject.backends import EmailAuthBackend\n+\n+from typing import Any, Set, Union\n+\n+import ujson\n+\n+def ensure_no_empty_passwords(apps: StateApps, schema_editor: DatabaseSchemaEditor) -> None:\n+    \"\"\"With CVE-2019-18933, it was possible for certain users created\n+    using social login (e.g. Google/GitHub auth) to have the empty\n+    string as their password in the Zulip database, rather than\n+    Django's \"unusable password\" (i.e. no password at all).  This was a\n+    serious security issue for organizations with both password and\n+    Google/GitHub authentication enabled.\n+\n+    Combined with the code changes to prevent new users from entering\n+    this buggy state, this migration sets the intended \"no password\"\n+    state for any users who are in this buggy state, as had been\n+    intended.\n+\n+    While this bug was discovered by our own development team and we\n+    believe it hasn't been exploited in the wild, out of an abundance\n+    of caution, this migration also resets the personal API keys for\n+    all users where Zulip's database-level logging cannot **prove**\n+    that user's current personal API key was never accessed using this\n+    bug.\n+\n+    There are a few ways this can be proven: (1) the user's password\n+    has never been changed and is not the empty string,\n+    or (2) the user's personal API key has changed since that user last\n+    changed their password (which is not ''). Both constitute proof\n+    because this bug cannot be used to gain the access required to change\n+    or reset a user's password.\n+\n+    Resetting those API keys has the effect of logging many users out\n+    of the Zulip mobile and terminal apps unnecessarily (e.g. because\n+    the user changed their password at any point in the past, even\n+    though the user never was affected by the bug), but we're\n+    comfortable with that cost for ensuring that this bug is\n+    completely fixed.\n+\n+    To avoid this inconvenience for self-hosted servers which don't\n+    even have EmailAuthBackend enabled, we skip resetting any API keys\n+    if the server doesn't have EmailAuthBackend configured.\n+    \"\"\"\n+\n+    UserProfile = apps.get_model('zerver', 'UserProfile')\n+    RealmAuditLog = apps.get_model('zerver', 'RealmAuditLog')\n+\n+    # Because we're backporting this migration to the Zulip 2.0.x\n+    # series, we've given it migration number 0209, which is a\n+    # duplicate with an existing migration already merged into Zulip\n+    # master.  Migration 0247_realmauditlog_event_type_to_int.py\n+    # changes the format of RealmAuditLog.event_type, so we need the\n+    # following conditional block to determine what values to use when\n+    # searching for the relevant events in that log.\n+    event_type_class = RealmAuditLog._meta.get_field('event_type').get_internal_type()\n+    if event_type_class == 'CharField':\n+        USER_PASSWORD_CHANGED = 'user_password_changed'  # type: Union[int, str]\n+        USER_API_KEY_CHANGED = 'user_api_key_changed'  # type: Union[int, str]\n+    else:\n+        USER_PASSWORD_CHANGED = 122\n+        USER_API_KEY_CHANGED = 127\n+\n+    # First, we do some bulk queries to collect data we'll find useful\n+    # in the loop over all users below.\n+\n+    # Users who changed their password at any time since account\n+    # creation.  These users could theoretically have started with an\n+    # empty password, but set a password later via the password reset\n+    # flow.  If their API key has changed since they changed their\n+    # password, we can prove their current API key cannot have been\n+    # exposed; we store those users in\n+    # password_change_user_ids_no_reset_needed.\n+    password_change_user_ids = set(RealmAuditLog.objects.filter(\n+        event_type=USER_PASSWORD_CHANGED).values_list(\"modified_user_id\", flat=True))\n+    password_change_user_ids_api_key_reset_needed = set()  # type: Set[int]\n+    password_change_user_ids_no_reset_needed = set()  # type: Set[int]\n+\n+    for user_id in password_change_user_ids:\n+        # Here, we check the timing for users who have changed\n+        # their password.\n+\n+        # We check if the user changed their API key since their first password change.\n+        query = RealmAuditLog.objects.filter(\n+            modified_user=user_id, event_type__in=[USER_PASSWORD_CHANGED,\n+                                                   USER_API_KEY_CHANGED]\n+        ).order_by(\"event_time\")\n+\n+        earliest_password_change = query.filter(event_type=USER_PASSWORD_CHANGED).first()\n+        # Since these users are in password_change_user_ids, this must not be None.\n+        assert earliest_password_change is not None\n+\n+        latest_api_key_change = query.filter(event_type=USER_API_KEY_CHANGED).last()\n+        if latest_api_key_change is None:\n+            # This user has never changed their API key.  As a\n+            # result, even though it's very likely this user never\n+            # had an empty password, they have changed their\n+            # password, and we have no record of the password's\n+            # original hash, so we can't prove the user's API key\n+            # was never affected.  We schedule this user's API key\n+            # to be reset.\n+            password_change_user_ids_api_key_reset_needed.add(user_id)\n+        elif earliest_password_change.event_time <= latest_api_key_change.event_time:\n+            # This user has changed their password before\n+            # generating their current personal API key, so we can\n+            # prove their current personal API key could not have\n+            # been exposed by this bug.\n+            password_change_user_ids_no_reset_needed.add(user_id)\n+        else:\n+            password_change_user_ids_api_key_reset_needed.add(user_id)\n+\n+    if password_change_user_ids_no_reset_needed and settings.PRODUCTION:\n+        # We record in this log file users whose current API key was\n+        # generated after a real password was set, so there's no need\n+        # to reset their API key, but because they've changed their\n+        # password, we don't know whether or not they originally had a\n+        # buggy password.\n+        #\n+        # In theory, this list can be recalculated using the above\n+        # algorithm modified to only look at events before the time\n+        # this migration was installed, but it's helpful to log it as well.\n+        with open(\"/var/log/zulip/0209_password_migration.log\", \"w\") as log_file:\n+            line = \"No reset needed, but changed password: {}\\n\"\n+            log_file.write(line.format(password_change_user_ids_no_reset_needed))\n+\n+    AFFECTED_USER_TYPE_EMPTY_PASSWORD = 'empty_password'\n+    AFFECTED_USER_TYPE_CHANGED_PASSWORD = 'changed_password'\n+    MIGRATION_ID = '0209_user_profile_no_empty_password'\n+\n+    def write_realm_audit_log_entry(user_profile: Any,\n+                                    event_time: Any, event_type: Any,\n+                                    affected_user_type: str) -> None:\n+        RealmAuditLog.objects.create(\n+            realm=user_profile.realm,\n+            modified_user=user_profile,\n+            event_type=event_type,\n+            event_time=event_time,\n+            extra_data=ujson.dumps({\n+                'migration_id': MIGRATION_ID,\n+                'affected_user_type': affected_user_type,\n+            })\n+        )\n+\n+    # If Zulip's built-in password authentication is not enabled on\n+    # the server level, then we plan to skip resetting any users' API\n+    # keys, since the bug requires EmailAuthBackend.\n+    email_auth_enabled = any(isinstance(backend, EmailAuthBackend)\n+                             for backend in get_backends())\n+\n+    # A quick note: This query could in theory exclude users with\n+    # is_active=False, is_bot=True, or realm__deactivated=True here to\n+    # accessing only active human users in non-deactivated realms.\n+    # But it's better to just be thorough; users can be reactivated,\n+    # and e.g. a server admin could manually edit the database to\n+    # change a bot into a human user if they really wanted to.  And\n+    # there's essentially no harm in rewriting state for a deactivated\n+    # account.\n+    for user_profile in UserProfile.objects.all():\n+        event_time = timezone_now()\n+        if check_password('', user_profile.password):\n+            # This user currently has the empty string as their password.\n+\n+            # Change their password and record that we did so.\n+            user_profile.password = make_password(None)\n+            update_fields = [\"password\"]\n+            write_realm_audit_log_entry(user_profile, event_time,\n+                                        USER_PASSWORD_CHANGED,\n+                                        AFFECTED_USER_TYPE_EMPTY_PASSWORD)\n+\n+            if email_auth_enabled and not user_profile.is_bot:\n+                # As explained above, if the built-in password authentication\n+                # is enabled, reset the API keys. We can skip bot accounts here,\n+                # because the `password` attribute on a bot user is useless.\n+                reset_user_api_key(user_profile)\n+                update_fields.append(\"api_key\")\n+\n+                event_time = timezone_now()\n+                write_realm_audit_log_entry(user_profile, event_time,\n+                                            USER_API_KEY_CHANGED,\n+                                            AFFECTED_USER_TYPE_EMPTY_PASSWORD)\n+\n+            user_profile.save(update_fields=update_fields)\n+            continue\n+\n+        elif email_auth_enabled and \\\n+                user_profile.id in password_change_user_ids_api_key_reset_needed:\n+            # For these users, we just need to reset the API key.\n+            reset_user_api_key(user_profile)\n+            user_profile.save(update_fields=[\"api_key\"])\n+\n+            write_realm_audit_log_entry(user_profile, event_time,\n+                                        USER_API_KEY_CHANGED,\n+                                        AFFECTED_USER_TYPE_CHANGED_PASSWORD)\n+\n+def reset_user_api_key(user_profile: Any) -> None:\n+    old_api_key = user_profile.api_key\n+    user_profile.api_key = generate_api_key()\n+    cache_delete(user_profile_by_api_key_cache_key(old_api_key))\n+\n+    # Like with any API key change, we need to clear any server-side\n+    # state for sending push notifications to mobile app clients that\n+    # could have been registered with the old API key.  Fortunately,\n+    # we can just write to the queue processor that handles sending\n+    # those notices to the push notifications bouncer service.\n+    event = {'type': 'clear_push_device_tokens',\n+             'user_profile_id': user_profile.id}\n+    queue_json_publish(\"deferred_work\", event)\n+\n+class Migration(migrations.Migration):\n+    atomic = False\n+\n+    dependencies = [\n+        ('zerver', '0208_add_realm_night_logo_fields'),\n+    ]\n+\n+    operations = [\n+        migrations.RunPython(ensure_no_empty_passwords,\n+                             reverse_code=migrations.RunPython.noop),\n+    ]"
        },
        {
          "filename": "zerver/migrations/0254_merge_0209_0253.py",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+# -*- coding: utf-8 -*-\n+# Generated by Django 1.11.26 on 2019-11-21 01:47\n+from __future__ import unicode_literals\n+\n+from django.db import migrations\n+from typing import Any, List\n+\n+class Migration(migrations.Migration):\n+\n+    dependencies = [\n+        ('zerver', '0253_userprofile_wildcard_mentions_notify'),\n+        ('zerver', '0209_user_profile_no_empty_password'),\n+    ]\n+\n+    operations = [\n+    ]  # type: List[Any]"
        },
        {
          "filename": "zerver/tests/test_auth_backends.py",
          "status": "modified",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -212,6 +212,26 @@ def test_email_auth_backend(self) -> None:\n                                             realm=get_realm('zephyr'),\n                                             return_data=dict()))\n \n+    def test_email_auth_backend_empty_password(self) -> None:\n+        user_profile = self.example_user('hamlet')\n+        password = \"testpassword\"\n+        user_profile.set_password(password)\n+        user_profile.save()\n+\n+        # First, verify authentication works with the a nonempty\n+        # password so we know we've set up the test correctly.\n+        self.assertIsNotNone(EmailAuthBackend().authenticate(username=self.example_email('hamlet'),\n+                                                             password=password,\n+                                                             realm=get_realm(\"zulip\")))\n+\n+        # Now do the same test with the empty string as the password.\n+        password = \"\"\n+        user_profile.set_password(password)\n+        user_profile.save()\n+        self.assertIsNone(EmailAuthBackend().authenticate(username=self.example_email('hamlet'),\n+                                                          password=password,\n+                                                          realm=get_realm(\"zulip\")))\n+\n     def test_email_auth_backend_disabled_password_auth(self) -> None:\n         user_profile = self.example_user('hamlet')\n         password = \"testpassword\""
        },
        {
          "filename": "zerver/views/registration.py",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -199,10 +199,14 @@ def accounts_register(request: HttpRequest) -> HttpResponse:\n         form['password'].field.required = False\n \n     if form.is_valid():\n-        if password_auth_enabled(realm):\n+        if password_auth_enabled(realm) and form['password'].field.required:\n             password = form.cleaned_data['password']\n         else:\n-            # SSO users don't need no passwords\n+            # If the user wasn't prompted for a password when\n+            # completing the authentication form (because they're\n+            # signing up with SSO and no password is required), set\n+            # the password field to `None` (Which causes Django to\n+            # create an unusable password).\n             password = None\n \n         if realm_creation:"
        },
        {
          "filename": "zerver/views/users.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -328,7 +328,7 @@ def add_bot_backend(\n     if bot_type in (UserProfile.INCOMING_WEBHOOK_BOT, UserProfile.EMBEDDED_BOT) and service_name:\n         check_valid_bot_config(bot_type, service_name, config_data)\n \n-    bot_profile = do_create_user(email=email, password='',\n+    bot_profile = do_create_user(email=email, password=None,\n                                  realm=user_profile.realm, full_name=full_name,\n                                  short_name=short_name,\n                                  bot_type=bot_type,"
        },
        {
          "filename": "zproject/backends.py",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -212,6 +212,11 @@ def authenticate(self, *, username: str, password: str,\n             if return_data is not None:\n                 return_data['email_auth_disabled'] = True\n             return None\n+        if password == \"\":\n+            # Never allow an empty password.  This is defensive code;\n+            # a user having password \"\" should only be possible\n+            # through a bug somewhere else.\n+            return None\n \n         user_profile = common_get_active_user(username, realm, return_data=return_data)\n         if user_profile is None:"
        }
      ],
      "file_patterns": {
        "security_files": 2,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 5,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "99ea0255da6d835e98f12adb7100af0f6d9ccb85",
            "date": "2025-01-09T06:57:21Z",
            "author_login": "mateuszmandera"
          },
          {
            "sha": "4196859cd65d373537a0a6092ffe8dc2a6b09ada",
            "date": "2025-01-09T05:56:09Z",
            "author_login": "mateuszmandera"
          },
          {
            "sha": "67887324ed74f9196aff2c26c40f5937ff811819",
            "date": "2024-11-19T21:51:08Z",
            "author_login": "mateuszmandera"
          },
          {
            "sha": "8b09190bcd129ea5e46509343049e595b92f06d9",
            "date": "2025-01-13T13:33:06Z",
            "author_login": "amanagr"
          },
          {
            "sha": "a05cbfa0c9e41e2fa2930b28653076279ae7bda0",
            "date": "2025-01-13T13:24:09Z",
            "author_login": "amanagr"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": null,
    "description": "In Zulip Server versions from 1.7.0 to before 2.0.7, a bug in the new user signup process meant that users who registered their account using social authentication (e.g., GitHub or Google SSO) in an organization that also allows password authentication could have their personal API key stolen by an unprivileged attacker, allowing nearly full access to the user's account.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2019-11-21T23:15:13.687",
    "last_modified": "2024-11-21T04:33:51.953",
    "fix_date": "2019-11-18T06:57:36Z"
  },
  "references": [
    {
      "url": "https://blog.zulip.org/2019/11/21/zulip-2-0-7-security-release/",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/zulip/zulip/commit/0c2cc41d2e40807baa5ee2c72987ebfb64ea2eb6",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://blog.zulip.org/2019/11/21/zulip-2-0-7-security-release/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/zulip/zulip/commit/0c2cc41d2e40807baa5ee2c72987ebfb64ea2eb6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:09.211883",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "zulip",
    "owner": "zulip",
    "created_at": "2015-09-25T16:37:25Z",
    "updated_at": "2025-01-14T13:31:30Z",
    "pushed_at": "2025-01-14T02:34:21Z",
    "size": 495185,
    "stars": 21946,
    "forks": 8107,
    "open_issues": 2487,
    "watchers": 21946,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "1.4.x",
      "1.5.x",
      "1.8.x",
      "1.9.x",
      "2.0.x",
      "2.1.x",
      "3.x",
      "3.1-with-bmemcached",
      "4.x",
      "4.0-rc1-branch",
      "5.x",
      "5.x-user-sharding",
      "5.0-rc1-branch",
      "5.0-rc2-branch",
      "6.x",
      "6.0-beta1-branch",
      "6.0-rc1-branch",
      "7.x",
      "7.0-beta1-branch",
      "7.0-beta2-branch",
      "8.x",
      "9.x",
      "buddy-list-prep",
      "chat.zulip.org",
      "dockertest",
      "main",
      "s3-compatible-uploads",
      "zulip-cloud-current"
    ],
    "languages": {
      "Python": 14193798,
      "TypeScript": 4055572,
      "JavaScript": 2278673,
      "HTML": 957053,
      "CSS": 942085,
      "Handlebars": 597145,
      "Shell": 161466,
      "Puppet": 137563,
      "Perl": 10353,
      "Dockerfile": 4219,
      "Ruby": 3794,
      "Emacs Lisp": 157
    },
    "commit_activity": {
      "total_commits_last_year": 6397,
      "avg_commits_per_week": 123.01923076923077,
      "days_active_last_year": 356
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:44:17.890508"
  }
}