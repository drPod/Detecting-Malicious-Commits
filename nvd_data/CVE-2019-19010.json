{
  "cve_id": "CVE-2019-19010",
  "github_data": {
    "repository": "ProgVal/Limnoria",
    "fix_commit": "3848ae78de45b35c029cc333963d436b9d2f0a35",
    "related_commits": [
      "3848ae78de45b35c029cc333963d436b9d2f0a35",
      "3848ae78de45b35c029cc333963d436b9d2f0a35"
    ],
    "patch_url": "https://github.com/ProgVal/Limnoria/commit/3848ae78de45b35c029cc333963d436b9d2f0a35.patch",
    "fix_commit_details": {
      "sha": "3848ae78de45b35c029cc333963d436b9d2f0a35",
      "commit_date": "2019-11-09T14:24:37Z",
      "author": {
        "login": "progval",
        "type": "User",
        "stats": {
          "total_commits": 3168,
          "average_weekly_commits": 2.781387181738367,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 506
        }
      },
      "commit_message": {
        "title": "Math: Rewrite calc functions with a proper evaluator.",
        "length": 162,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 294,
        "additions": 185,
        "deletions": 109
      },
      "files": [
        {
          "filename": "plugins/Math/evaluator.py",
          "status": "added",
          "additions": 169,
          "deletions": 0,
          "patch": "@@ -0,0 +1,169 @@\n+###\n+# Copyright (c) 2019, Valentin Lorentz\n+# All rights reserved.\n+#\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions are met:\n+#\n+#   * Redistributions of source code must retain the above copyright notice,\n+#     this list of conditions, and the following disclaimer.\n+#   * Redistributions in binary form must reproduce the above copyright notice,\n+#     this list of conditions, and the following disclaimer in the\n+#     documentation and/or other materials provided with the distribution.\n+#   * Neither the name of the author of this software nor the name of\n+#     contributors to this software may be used to endorse or promote products\n+#     derived from this software without specific prior written consent.\n+#\n+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+# POSSIBILITY OF SUCH DAMAGE.\n+###\n+\n+import ast\n+import math\n+import cmath\n+import operator\n+\n+class InvalidNode(Exception):\n+    pass\n+\n+def filter_module(module, safe_names):\n+    return dict([\n+        (name, getattr(module, name))\n+        for name in safe_names\n+        if hasattr(module, name)\n+    ])\n+\n+UNARY_OPS = {\n+    ast.UAdd: lambda x: x,\n+    ast.USub: lambda x: -x,\n+}\n+\n+BIN_OPS = {\n+    ast.Add: operator.add,\n+    ast.Sub: operator.sub,\n+    ast.Mult: operator.mul,\n+    ast.Div: operator.truediv,\n+    ast.Pow: operator.pow,\n+    ast.BitXor: operator.xor,\n+    ast.BitOr: operator.or_,\n+    ast.BitAnd: operator.and_,\n+}\n+\n+MATH_CONSTANTS = 'e inf nan pi tau'.split()\n+SAFE_MATH_FUNCTIONS = (\n+    'acos acosh asin asinh atan atan2 atanh copysign cos cosh degrees erf '\n+    'erfc exp expm1 fabs fmod frexp fsum gamma hypot ldexp lgamma log log10 '\n+    'log1p log2 modf pow radians remainder sin sinh tan tanh'\n+).split()\n+SAFE_CMATH_FUNCTIONS = (\n+    'acos acosh asin asinh atan atanh cos cosh exp inf infj log log10 '\n+    'nanj phase polar rect sin sinh tan tanh tau'\n+).split()\n+\n+SAFE_ENV = filter_module(math, MATH_CONSTANTS + SAFE_MATH_FUNCTIONS)\n+SAFE_ENV.update(filter_module(cmath, SAFE_CMATH_FUNCTIONS))\n+\n+def _sqrt(x):\n+    if isinstance(x, complex) or x < 0:\n+        return cmath.sqrt(x)\n+    else:\n+        return math.sqrt(x)\n+\n+def _cbrt(x):\n+    return math.pow(x, 1.0/3)\n+\n+def _factorial(x):\n+    if x<=10000:\n+        return float(math.factorial(x))\n+    else:\n+        raise Exception('factorial argument too large')\n+\n+SAFE_ENV.update({\n+    'i': 1j,\n+    'abs': abs,\n+    'max': max,\n+    'min': min,\n+    'round': lambda x, y=0: round(x, int(y)),\n+    'factorial': _factorial,\n+    'sqrt': _sqrt,\n+    'cbrt': _cbrt,\n+    'ceil': lambda x: float(math.ceil(x)),\n+    'floor': lambda x: float(math.floor(x)),\n+})\n+\n+UNSAFE_ENV = SAFE_ENV.copy()\n+# Add functions that return integers\n+UNSAFE_ENV.update(filter_module(math, 'ceil floor factorial gcd'.split()))\n+\n+\n+# It would be nice if ast.literal_eval used a visitor so we could subclass\n+# to extend it, but it doesn't, so let's reimplement it entirely.\n+class SafeEvalVisitor(ast.NodeVisitor):\n+    def __init__(self, allow_ints):\n+        self._allow_ints = allow_ints\n+        self._env = UNSAFE_ENV if allow_ints else SAFE_ENV\n+\n+    def _convert_num(self, x):\n+        \"\"\"Converts numbers to complex if ints are not allowed.\"\"\"\n+        if self._allow_ints:\n+            return x\n+        else:\n+            x = complex(x)\n+            if x.imag == 0:\n+                x = x.real\n+                # Need to use string-formatting here instead of str() because\n+                # use of str() on large numbers loses information:\n+                # str(float(33333333333333)) => '3.33333333333e+13'\n+                # float('3.33333333333e+13') => 33333333333300.0\n+                return float('%.16f' % x)\n+            else:\n+                return x\n+\n+    def visit_Expression(self, node):\n+        return self.visit(node.body)\n+\n+    def visit_Num(self, node):\n+        return self._convert_num(node.n)\n+\n+    def visit_Name(self, node):\n+        id_ = node.id.lower()\n+        if id_ in self._env:\n+            return self._env[id_]\n+        else:\n+            raise NameError(node.id)\n+\n+    def visit_Call(self, node):\n+        func = self.visit(node.func)\n+        args = map(self.visit, node.args)\n+        # TODO: keywords?\n+        return func(*args)\n+\n+    def visit_UnaryOp(self, node):\n+        op = UNARY_OPS.get(node.op.__class__)\n+        if op:\n+            return op(self.visit(node.operand))\n+        else:\n+            raise InvalidNode('illegal operator %s' % node.op.__class__.__name__)\n+\n+    def visit_BinOp(self, node):\n+        op = BIN_OPS.get(node.op.__class__)\n+        if op:\n+            return op(self.visit(node.left), self.visit(node.right))\n+        else:\n+            raise InvalidNode('illegal operator %s' % node.op.__class__.__name__)\n+\n+    def generic_visit(self, node):\n+        raise InvalidNode('illegal construct %s' % node.__class__.__name__)\n+\n+def safe_eval(text, allow_ints):\n+    node = ast.parse(text, mode='eval')\n+    return SafeEvalVisitor(allow_ints).visit(node)"
        },
        {
          "filename": "plugins/Math/plugin.py",
          "status": "modified",
          "additions": 12,
          "deletions": 105,
          "patch": "@@ -44,6 +44,7 @@\n _ = PluginInternationalization('Math')\n \n from .local import convertcore\n+from .evaluator import safe_eval, InvalidNode, SAFE_ENV\n \n baseArg = ('int', 'base', lambda i: i <= 36)\n \n@@ -97,36 +98,6 @@ def _convertBaseToBase(self, number, toBase, fromBase):\n             return str(number)\n         return self._convertDecimalToBase(number, toBase)\n \n-    _mathEnv = {'__builtins__': types.ModuleType('__builtins__'), 'i': 1j}\n-    _mathEnv.update(math.__dict__)\n-    _mathEnv.update(cmath.__dict__)\n-    def _sqrt(x):\n-        if isinstance(x, complex) or x < 0:\n-            return cmath.sqrt(x)\n-        else:\n-            return math.sqrt(x)\n-    def _cbrt(x):\n-        return math.pow(x, 1.0/3)\n-    def _factorial(x):\n-        if x<=10000:\n-            return float(math.factorial(x))\n-        else:\n-            raise Exception('factorial argument too large')\n-    _mathEnv['sqrt'] = _sqrt\n-    _mathEnv['cbrt'] = _cbrt\n-    _mathEnv['abs'] = abs\n-    _mathEnv['max'] = max\n-    _mathEnv['min'] = min\n-    _mathEnv['round'] = lambda x, y=0: round(x, int(y))\n-    _mathSafeEnv = dict([(x,y) for x,y in _mathEnv.items()])\n-    _mathSafeEnv['factorial'] = _factorial\n-    _mathRe = re.compile(r'((?:(?<![A-Fa-f\\d)])-)?'\n-                         r'(?:0x[A-Fa-f\\d]+|'\n-                         r'0[0-7]+|'\n-                         r'\\d+\\.\\d+|'\n-                         r'\\.\\d+|'\n-                         r'\\d+\\.|'\n-                         r'\\d+))')\n     def _floatToString(self, x):\n         if -1e-10 < x < 1e-10:\n             return '0'\n@@ -157,17 +128,6 @@ def _complexToString(self, x):\n         else:\n             return '%s%s' % (realS, imagS)\n \n-    _calc_match_forbidden_chars = re.compile('[_\\[\\]]')\n-    _calc_remover = utils.str.MultipleRemover('_[] \\t')\n-    ###\n-    # So this is how the 'calc' command works:\n-    # First, we make a nice little safe environment for evaluation; basically,\n-    # the names in the 'math' and 'cmath' modules.  Then, we remove the ability\n-    # of a random user to get ints evaluated: this means we have to turn all\n-    # int literals (even octal numbers and hexadecimal numbers) into floats.\n-    # Then we delete all square brackets, underscores, and whitespace, so no\n-    # one can do list comprehensions or call __...__ functions.\n-    ###\n     @internationalizeDocstring\n     def calc(self, irc, msg, args, text):\n         \"\"\"<math expression>\n@@ -178,57 +138,17 @@ def calc(self, irc, msg, args, text):\n         crash to the bot with something like '10**10**10**10'.  One consequence\n         is that large values such as '10**24' might not be exact.\n         \"\"\"\n-        try:\n-            text = str(text)\n-        except UnicodeEncodeError:\n-            irc.error(_(\"There's no reason you should have fancy non-ASCII \"\n-                            \"characters in your mathematical expression. \"\n-                            \"Please remove them.\"))\n-            return\n-        if self._calc_match_forbidden_chars.match(text):\n-            # Note: this is important to keep this to forbid usage of\n-            # __builtins__\n-            irc.error(_('There\\'s really no reason why you should have '\n-                           'underscores or brackets in your mathematical '\n-                           'expression.  Please remove them.'))\n-            return\n-        text = self._calc_remover(text)\n-        if 'lambda' in text:\n-            irc.error(_('You can\\'t use lambda in this command.'))\n-            return\n-        text = text.lower()\n-        def handleMatch(m):\n-            s = m.group(1)\n-            if s.startswith('0x'):\n-                i = int(s, 16)\n-            elif s.startswith('0') and '.' not in s:\n-                try:\n-                    i = int(s, 8)\n-                except ValueError:\n-                    i = int(s)\n-            else:\n-                i = float(s)\n-            x = complex(i)\n-            if x.imag == 0:\n-                x = x.real\n-                # Need to use string-formatting here instead of str() because\n-                # use of str() on large numbers loses information:\n-                # str(float(33333333333333)) => '3.33333333333e+13'\n-                # float('3.33333333333e+13') => 33333333333300.0\n-                return '%.16f' % x\n-            return str(x)\n-        text = self._mathRe.sub(handleMatch, text)\n         try:\n             self.log.info('evaluating %q from %s', text, msg.prefix)\n-            x = complex(eval(text, self._mathSafeEnv, self._mathSafeEnv))\n+            x = complex(safe_eval(text, allow_ints=False))\n             irc.reply(self._complexToString(x))\n         except OverflowError:\n             maxFloat = math.ldexp(0.9999999999999999, 1024)\n             irc.error(_('The answer exceeded %s or so.') % maxFloat)\n-        except TypeError:\n-            irc.error(_('Something in there wasn\\'t a valid number.'))\n+        except InvalidNode as e:\n+            irc.error(_('Invalid syntax: %s') % e.args[0])\n         except NameError as e:\n-            irc.error(_('%s is not a defined function.') % str(e).split()[1])\n+            irc.error(_('%s is not a defined function.') % e.args[0])\n         except Exception as e:\n             irc.error(str(e))\n     calc = wrap(calc, ['text'])\n@@ -241,28 +161,15 @@ def icalc(self, irc, msg, args, text):\n         math, and can thus cause the bot to suck up CPU.  Hence it requires\n         the 'trusted' capability to use.\n         \"\"\"\n-        if self._calc_match_forbidden_chars.match(text):\n-            # Note: this is important to keep this to forbid usage of\n-            # __builtins__\n-            irc.error(_('There\\'s really no reason why you should have '\n-                           'underscores or brackets in your mathematical '\n-                           'expression.  Please remove them.'))\n-            return\n-        # This removes spaces, too, but we'll leave the removal of _[] for\n-        # safety's sake.\n-        text = self._calc_remover(text)\n-        if 'lambda' in text:\n-            irc.error(_('You can\\'t use lambda in this command.'))\n-            return\n-        text = text.replace('lambda', '')\n         try:\n             self.log.info('evaluating %q from %s', text, msg.prefix)\n-            irc.reply(str(eval(text, self._mathEnv, self._mathEnv)))\n+            x = safe_eval(text, allow_ints=True)\n+            irc.reply(str(x))\n         except OverflowError:\n             maxFloat = math.ldexp(0.9999999999999999, 1024)\n             irc.error(_('The answer exceeded %s or so.') % maxFloat)\n-        except TypeError:\n-            irc.error(_('Something in there wasn\\'t a valid number.'))\n+        except InvalidNode as e:\n+            irc.error(_('Invalid syntax: %s') % e.args[0])\n         except NameError as e:\n             irc.error(_('%s is not a defined function.') % str(e).split()[1])\n         except Exception as e:\n@@ -286,8 +193,8 @@ def rpn(self, irc, msg, args):\n                     x = abs(x)\n                 stack.append(x)\n             except ValueError: # Not a float.\n-                if arg in self._mathSafeEnv:\n-                    f = self._mathSafeEnv[arg]\n+                if arg in SAFE_ENV:\n+                    f = SAFE_ENV[arg]\n                     if callable(f):\n                         called = False\n                         arguments = []\n@@ -310,7 +217,7 @@ def rpn(self, irc, msg, args):\n                     arg1 = stack.pop()\n                     s = '%s%s%s' % (arg1, arg, arg2)\n                     try:\n-                        stack.append(eval(s, self._mathSafeEnv, self._mathSafeEnv))\n+                        stack.append(safe_eval(s, allow_ints=False))\n                     except SyntaxError:\n                         irc.error(format(_('%q is not a defined function.'),\n                                          arg))"
        },
        {
          "filename": "plugins/Math/test.py",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -91,9 +91,6 @@ def testBase(self):\n         self.assertError('base 4 4')\n         self.assertError('base 10 12 A')\n \n-        print()\n-        print(\"If we have not fixed a bug with Math.base, the following \")\n-        print(\"tests will hang the test-suite.\")\n         self.assertRegexp('base 2 10 [base 10 2 -12]', '-12')\n         self.assertRegexp('base 16 2 [base 2 16 -110101]', '-110101')\n \n@@ -117,7 +114,10 @@ def testCalc(self):\n         self.assertError('calc factorial(20000)')\n \n     def testCalcNoNameError(self):\n-        self.assertNotRegexp('calc foobar(x)', 'NameError')\n+        self.assertRegexp('calc foobar(x)', 'foobar is not a defined function')\n+\n+    def testCalcInvalidNode(self):\n+        self.assertRegexp('calc {\"foo\": \"bar\"}', 'Illegal construct Dict')\n \n     def testCalcImaginary(self):\n         self.assertResponse('calc 3 + sqrt(-1)', '3+i')"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e57f7ebc2aff78b2b33f5e2d75b5f49944448c42",
            "date": "2024-12-20T06:58:40Z",
            "author_login": "progval"
          },
          {
            "sha": "ab25c3e039f6c04957daf375f55498280ef2787b",
            "date": "2024-12-20T06:57:41Z",
            "author_login": "progval"
          },
          {
            "sha": "aaeab253a5442aeab670dbb877e5920e8f209fa3",
            "date": "2024-12-20T06:57:23Z",
            "author_login": "progval"
          },
          {
            "sha": "912e334f6b68a484cf585ec67bf98b04e81230e7",
            "date": "2024-05-25T15:43:47Z",
            "author_login": "progval"
          },
          {
            "sha": "56e06a9ce8143f04237b87ae1870fd1a79ff5a47",
            "date": "2024-12-06T10:42:55Z",
            "author_login": "progval"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-94",
    "description": "Eval injection in the Math plugin of Limnoria (before 2019.11.09) and Supybot (through 2018-05-09) allows remote unprivileged attackers to disclose information or possibly have unspecified other impact via the calc and icalc IRC commands.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2019-11-16T01:15:10.217",
    "last_modified": "2024-11-21T04:33:59.200",
    "fix_date": "2019-11-09T14:24:37Z"
  },
  "references": [
    {
      "url": "https://github.com/ProgVal/Limnoria/commit/3848ae78de45b35c029cc333963d436b9d2f0a35",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ProgVal/Limnoria/wiki/math-eval-vulnerability",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/54CQM2TEXRADLE77VOMCPHL5PBHR3ZWJ/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/5P2AGND54UIJV3WHOYO2YINIXSDGAAPO/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/DRNOUHFEN75QAIKT4Y3HDN3TT5LSIWN2/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/ProgVal/Limnoria/commit/3848ae78de45b35c029cc333963d436b9d2f0a35",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ProgVal/Limnoria/wiki/math-eval-vulnerability",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/54CQM2TEXRADLE77VOMCPHL5PBHR3ZWJ/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/5P2AGND54UIJV3WHOYO2YINIXSDGAAPO/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/DRNOUHFEN75QAIKT4Y3HDN3TT5LSIWN2/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:09.195387",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "Limnoria",
    "owner": "ProgVal",
    "created_at": "2011-04-26T08:18:00Z",
    "updated_at": "2025-01-10T21:40:31Z",
    "pushed_at": "2024-12-22T15:29:41Z",
    "size": 36539,
    "stars": 626,
    "forks": 175,
    "open_issues": 249,
    "watchers": 626,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Python": 3251848,
      "Makefile": 983,
      "Shell": 331
    },
    "commit_activity": {
      "total_commits_last_year": 60,
      "avg_commits_per_week": 1.1538461538461537,
      "days_active_last_year": 35
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T16:36:03.084418"
  }
}