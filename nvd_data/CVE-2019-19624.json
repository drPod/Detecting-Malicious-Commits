{
  "cve_id": "CVE-2019-19624",
  "github_data": {
    "repository": "opencv/opencv",
    "fix_commit": "d1615ba11a93062b1429fce9f0f638d1572d3418",
    "related_commits": [
      "d1615ba11a93062b1429fce9f0f638d1572d3418",
      "d1615ba11a93062b1429fce9f0f638d1572d3418"
    ],
    "patch_url": "https://github.com/opencv/opencv/commit/d1615ba11a93062b1429fce9f0f638d1572d3418.patch",
    "fix_commit_details": {
      "sha": "d1615ba11a93062b1429fce9f0f638d1572d3418",
      "commit_date": "2019-05-27T06:18:26Z",
      "author": {
        "login": "thangktran",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "video:fixed DISOpticalFlow segfault from small img",
        "length": 50,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 95,
        "additions": 93,
        "deletions": 2
      },
      "files": [
        {
          "filename": "modules/video/src/dis_flow.cpp",
          "status": "modified",
          "additions": 65,
          "deletions": 2,
          "patch": "@@ -140,6 +140,8 @@ class DISOpticalFlowImpl CV_FINAL : public DISOpticalFlow\n     void prepareBuffers(Mat &I0, Mat &I1, Mat &flow, bool use_flow);\n     void precomputeStructureTensor(Mat &dst_I0xx, Mat &dst_I0yy, Mat &dst_I0xy, Mat &dst_I0x, Mat &dst_I0y, Mat &I0x,\n                                    Mat &I0y);\n+    int autoSelectCoarsestScale(int img_width);\n+    void autoSelectPatchSizeAndScales(int img_width);\n \n     struct PatchInverseSearch_ParBody : public ParallelLoopBody\n     {\n@@ -435,6 +437,44 @@ void DISOpticalFlowImpl::precomputeStructureTensor(Mat &dst_I0xx, Mat &dst_I0yy,\n     }\n }\n \n+int DISOpticalFlowImpl::autoSelectCoarsestScale(int img_width)\n+{\n+    const int fratio = 5;\n+    return std::max(0, (int)std::floor(log2((2.0f*(float)img_width) / ((float)fratio * (float)patch_size))));\n+}\n+\n+void DISOpticalFlowImpl::autoSelectPatchSizeAndScales(int img_width)\n+{\n+    switch (finest_scale)\n+    {\n+    case 1:\n+        patch_size = 8;\n+        coarsest_scale = autoSelectCoarsestScale(img_width);\n+        finest_scale = std::max(coarsest_scale-2, 0);\n+        break;\n+\n+    case 3:\n+        patch_size = 12;\n+        coarsest_scale = autoSelectCoarsestScale(img_width);\n+        finest_scale = std::max(coarsest_scale-4, 0);\n+        break;\n+\n+    case 4:\n+        patch_size = 12;\n+        coarsest_scale = autoSelectCoarsestScale(img_width);\n+        finest_scale = std::max(coarsest_scale-5, 0);\n+        break;\n+\n+    // default case, fall-through.\n+    case 2:\n+    default:\n+        patch_size = 8;\n+        coarsest_scale = autoSelectCoarsestScale(img_width);\n+        finest_scale = std::max(coarsest_scale-2, 0);\n+        break;\n+    }\n+}\n+\n DISOpticalFlowImpl::PatchInverseSearch_ParBody::PatchInverseSearch_ParBody(DISOpticalFlowImpl &_dis, int _nstripes,\n                                                                            int _hs, Mat &dst_Sx, Mat &dst_Sy,\n                                                                            Mat &src_Ux, Mat &src_Uy, Mat &_I0, Mat &_I1,\n@@ -1318,9 +1358,20 @@ bool DISOpticalFlowImpl::ocl_calc(InputArray I0, InputArray I1, InputOutputArray\n     else\n         flow.create(I1Mat.size(), CV_32FC2);\n     UMat &u_flowMat = flow.getUMatRef();\n-    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code serach for maximal movement of width/4 */\n+    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code search for maximal movement of width/4 */\n                          (int)(log(min(I0Mat.cols, I0Mat.rows) / patch_size) / log(2.0)));              /* Deepest pyramid level greater or equal than patch*/\n \n+    if (coarsest_scale<0)\n+        CV_Error(cv::Error::StsBadSize, \"The input image must have either width or height >= 12\");\n+\n+    if (coarsest_scale<finest_scale)\n+    {\n+        // choose the finest level based on coarsest level.\n+        // Refs: https://github.com/tikroeger/OF_DIS/blob/2c9f2a674f3128d3a41c10e41cc9f3a35bb1b523/run_dense.cpp#L239\n+        int original_img_width = I0.size().width;\n+        autoSelectPatchSizeAndScales(original_img_width);\n+    }\n+\n     ocl_prepareBuffers(I0Mat, I1Mat, u_flowMat, use_input_flow);\n     u_Ux[coarsest_scale].setTo(0.0f);\n     u_Uy[coarsest_scale].setTo(0.0f);\n@@ -1385,8 +1436,20 @@ void DISOpticalFlowImpl::calc(InputArray I0, InputArray I1, InputOutputArray flo\n     else\n         flow.create(I1Mat.size(), CV_32FC2);\n     Mat flowMat = flow.getMat();\n-    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code serach for maximal movement of width/4 */\n+    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code search for maximal movement of width/4 */\n                          (int)(log(min(I0Mat.cols, I0Mat.rows) / patch_size) / log(2.0)));              /* Deepest pyramid level greater or equal than patch*/\n+\n+    if (coarsest_scale<0)\n+        CV_Error(cv::Error::StsBadSize, \"The input image must have either width or height >= 12\");\n+\n+    if (coarsest_scale<finest_scale)\n+    {\n+        // choose the finest level based on coarsest level.\n+        // Refs: https://github.com/tikroeger/OF_DIS/blob/2c9f2a674f3128d3a41c10e41cc9f3a35bb1b523/run_dense.cpp#L239\n+        int original_img_width = I0.size().width;\n+        autoSelectPatchSizeAndScales(original_img_width);\n+    }\n+\n     int num_stripes = getNumThreads();\n \n     prepareBuffers(I0Mat, I1Mat, flowMat, use_input_flow);"
        },
        {
          "filename": "modules/video/test/test_OF_accuracy.cpp",
          "status": "modified",
          "additions": 28,
          "deletions": 0,
          "patch": "@@ -121,6 +121,34 @@ TEST(DenseOpticalFlow_DIS, ReferenceAccuracy)\n     }\n }\n \n+TEST(DenseOpticalFlow_DIS, InvalidImgSize_CoarsestLevelLessThanZero)\n+{\n+    cv::Ptr<cv::DISOpticalFlow> of = cv::DISOpticalFlow::create();\n+    const int mat_size = 10;\n+\n+    cv::Mat x(mat_size, mat_size, CV_8UC1, 42);\n+    cv::Mat y(mat_size, mat_size, CV_8UC1, 42);\n+    cv::Mat flow;\n+\n+    ASSERT_THROW(of->calc(x, y, flow), cv::Exception);\n+}\n+\n+// make sure that autoSelectPatchSizeAndScales() works properly.\n+TEST(DenseOpticalFlow_DIS, InvalidImgSize_CoarsestLevelLessThanFinestLevel)\n+{\n+    cv::Ptr<cv::DISOpticalFlow> of = cv::DISOpticalFlow::create();\n+    const int mat_size = 80;\n+\n+    cv::Mat x(mat_size, mat_size, CV_8UC1, 42);\n+    cv::Mat y(mat_size, mat_size, CV_8UC1, 42);\n+    cv::Mat flow;\n+\n+    of->calc(x, y, flow);\n+\n+    ASSERT_EQ(flow.rows, mat_size);\n+    ASSERT_EQ(flow.cols, mat_size);\n+}\n+\n TEST(DenseOpticalFlow_VariationalRefinement, ReferenceAccuracy)\n {\n     Mat frame1, frame2, GT;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "1a6ef7e08c88742cafd6015a20456253c9c1b316",
            "date": "2025-01-14T13:23:22Z",
            "author_login": "asmorkalov"
          },
          {
            "sha": "534243647e5d840b14260b326702f3b8c47d7938",
            "date": "2025-01-13T18:13:22Z",
            "author_login": "asmorkalov"
          },
          {
            "sha": "342ced1e043975db5d2b9f42209a535f382e219d",
            "date": "2025-01-13T17:23:10Z",
            "author_login": "asmorkalov"
          },
          {
            "sha": "bfb54aa69138fe2da67646eede14db6306b10cbf",
            "date": "2025-01-13T14:05:55Z",
            "author_login": "vrabaud"
          },
          {
            "sha": "6931a4cc0666ebee6084f38ce30e2cee5f32b79c",
            "date": "2025-01-13T10:05:21Z",
            "author_login": "asmorkalov"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:L",
    "cwe_id": "CWE-125",
    "description": "An out-of-bounds read was discovered in OpenCV before 4.1.1. Specifically, variable coarsest_scale is assumed to be greater than or equal to finest_scale within the calc()/ocl_calc() functions in dis_flow.cpp. However, this is not true when dealing with small images, leading to an out-of-bounds read of the heap-allocated arrays Ux and Uy.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2019-12-06T15:15:10.330",
    "last_modified": "2024-11-21T04:35:04.850",
    "fix_date": "2019-05-27T06:18:26Z"
  },
  "references": [
    {
      "url": "https://github.com/opencv/opencv/commit/d1615ba11a93062b1429fce9f0f638d1572d3418",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/opencv/opencv/issues/14554",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/security/cve/cve-2019-19624",
      "source": "nvd@nist.gov",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/opencv/opencv/commit/d1615ba11a93062b1429fce9f0f638d1572d3418",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/opencv/opencv/issues/14554",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:24.247931",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "opencv",
    "owner": "opencv",
    "created_at": "2012-07-19T09:40:17Z",
    "updated_at": "2025-01-14T13:03:57Z",
    "pushed_at": "2025-01-14T13:23:22Z",
    "size": 542664,
    "stars": 80074,
    "forks": 55930,
    "open_issues": 2700,
    "watchers": 80074,
    "has_security_policy": false,
    "default_branch": "4.x",
    "protected_branches": [
      "2.4",
      "3.4",
      "4.x",
      "5.x",
      "master",
      "next"
    ],
    "languages": {
      "C++": 40006957,
      "C": 1538459,
      "Python": 1319502,
      "CMake": 993360,
      "Java": 752207,
      "Objective-C++": 394547,
      "Cuda": 343525,
      "Swift": 301765,
      "JavaScript": 243601,
      "Objective-C": 99998,
      "HTML": 40097,
      "Shell": 26085,
      "Perl": 15865,
      "PowerShell": 14591,
      "Kotlin": 5815,
      "TeX": 5144,
      "Batchfile": 1498,
      "Prolog": 843,
      "Dockerfile": 309
    },
    "commit_activity": {
      "total_commits_last_year": 995,
      "avg_commits_per_week": 19.134615384615383,
      "days_active_last_year": 282
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:24:10.847382"
  }
}