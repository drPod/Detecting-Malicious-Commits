{
  "cve_id": "CVE-2019-20392",
  "github_data": {
    "repository": "CESNET/libyang",
    "fix_commit": "32fb4993bc8bb49e93e84016af3c10ea53964be5",
    "related_commits": [
      "32fb4993bc8bb49e93e84016af3c10ea53964be5",
      "32fb4993bc8bb49e93e84016af3c10ea53964be5"
    ],
    "patch_url": "https://github.com/CESNET/libyang/commit/32fb4993bc8bb49e93e84016af3c10ea53964be5.patch",
    "fix_commit_details": {
      "sha": "32fb4993bc8bb49e93e84016af3c10ea53964be5",
      "commit_date": "2019-03-08T07:55:16Z",
      "author": {
        "login": "michalvasko",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "schema tree BUGFIX do not check features while still resolving schema",
        "length": 81,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 31,
        "additions": 17,
        "deletions": 14
      },
      "files": [
        {
          "filename": "src/resolve.c",
          "status": "modified",
          "additions": 5,
          "deletions": 3,
          "patch": "@@ -3941,7 +3941,8 @@ resolve_schema_leafref_predicate(const char *path, const struct lys_node *contex\n         } else {\n             trg_mod = lys_node_module(parent);\n         }\n-        rc = lys_getnext_data(trg_mod, context_node, source, sour_len, LYS_LEAF | LYS_LEAFLIST, &src_node);\n+        rc = lys_getnext_data(trg_mod, context_node, source, sour_len, LYS_LEAF | LYS_LEAFLIST, LYS_GETNEXT_NOSTATECHECK,\n+                              &src_node);\n         if (rc) {\n             LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path-parsed);\n             return 0;\n@@ -3984,7 +3985,8 @@ resolve_schema_leafref_predicate(const char *path, const struct lys_node *contex\n             } else {\n                 trg_mod = lys_node_module(parent);\n             }\n-            rc = lys_getnext_data(trg_mod, dst_node, dest, dest_len, LYS_CONTAINER | LYS_LIST | LYS_LEAF, &dst_node);\n+            rc = lys_getnext_data(trg_mod, dst_node, dest, dest_len, LYS_CONTAINER | LYS_LIST | LYS_LEAF,\n+                                  LYS_GETNEXT_NOSTATECHECK, &dst_node);\n             if (rc) {\n                 LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path_key_expr);\n                 return 0;\n@@ -6065,7 +6067,7 @@ resolve_list_keys(struct lys_node_list *list, const char *keys_str)\n         }\n \n         rc = lys_getnext_data(lys_node_module((struct lys_node *)list), (struct lys_node *)list, keys_str, len, LYS_LEAF,\n-                              (const struct lys_node **)&list->keys[i]);\n+                              LYS_GETNEXT_NOSTATECHECK, (const struct lys_node **)&list->keys[i]);\n         if (rc) {\n             LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list key\", keys_str);\n             return EXIT_FAILURE;"
        },
        {
          "filename": "src/tree_data.c",
          "status": "modified",
          "additions": 8,
          "deletions": 8,
          "patch": "@@ -1172,7 +1172,7 @@ lyd_new(struct lyd_node *parent, const struct lys_module *module, const char *na\n     }\n \n     if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF\n-                         | LYS_RPC | LYS_ACTION, &snode) || !snode) {\n+                         | LYS_RPC | LYS_ACTION, 0, &snode) || !snode) {\n         LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n                name, lys_node_module(siblings)->name, siblings->name);\n         return NULL;\n@@ -1265,7 +1265,7 @@ lyd_new_leaf(struct lyd_node *parent, const struct lys_module *module, const cha\n         return NULL;\n     }\n \n-    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, &snode) || !snode) {\n+    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, 0, &snode) || !snode) {\n         LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n                name, lys_node_module(siblings)->name, siblings->name);\n         return NULL;\n@@ -1513,7 +1513,7 @@ lyd_new_anydata(struct lyd_node *parent, const struct lys_module *module, const\n         return NULL;\n     }\n \n-    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {\n+    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, 0, &snode) || !snode) {\n         LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n                name, lys_node_module(siblings)->name, siblings->name);\n         return NULL;\n@@ -1538,7 +1538,7 @@ lyd_new_yangdata(const struct lys_module *module, const char *name_template, con\n         return NULL;\n     }\n \n-    if (lys_getnext_data(module, schema, name, strlen(name), LYS_CONTAINER, &snode) || !snode) {\n+    if (lys_getnext_data(module, schema, name, strlen(name), LYS_CONTAINER, 0, &snode) || !snode) {\n         LOGERR(module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a container child of \\\"%s:%s\\\".\",\n                name, module->name, schema->name);\n         return NULL;\n@@ -1564,7 +1564,7 @@ lyd_new_output(struct lyd_node *parent, const struct lys_module *module, const c\n     }\n \n     if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF\n-                         | LYS_RPC | LYS_ACTION, &snode) || !snode) {\n+                         | LYS_RPC | LYS_ACTION, 0, &snode) || !snode) {\n         LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n                name, lys_node_module(siblings)->name, siblings->name);\n         return NULL;\n@@ -1589,7 +1589,7 @@ lyd_new_output_leaf(struct lyd_node *parent, const struct lys_module *module, co\n         return NULL;\n     }\n \n-    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, &snode) || !snode) {\n+    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, 0, &snode) || !snode) {\n         LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n                name, lys_node_module(siblings)->name, siblings->name);\n         return NULL;\n@@ -1615,7 +1615,7 @@ lyd_new_output_anydata(struct lyd_node *parent, const struct lys_module *module,\n         return NULL;\n     }\n \n-    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {\n+    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, 0, &snode) || !snode) {\n         LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n                name, lys_node_module(siblings)->name, siblings->name);\n         return NULL;\n@@ -5609,7 +5609,7 @@ lyd_dup_to_ctx(const struct lyd_node *node, int options, struct ly_ctx *ctx)\n                 }\n                 /* we know its parent, so we can start with it */\n                 lys_getnext_data(trg_mod, parent->schema, elem->schema->name, strlen(elem->schema->name),\n-                                 elem->schema->nodetype, (const struct lys_node **)&schema);\n+                                 elem->schema->nodetype, 0, (const struct lys_node **)&schema);\n             } else {\n                 /* we have to search in complete context */\n                 schema = lyd_get_schema_inctx(elem, ctx);"
        },
        {
          "filename": "src/tree_internal.h",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -485,12 +485,13 @@ int lys_get_sibling(const struct lys_node *siblings, const char *mod_name, int m\n  * @param[in] name Node name.\n  * @param[in] nam_len Node \\p name length.\n  * @param[in] type ORed desired type of the node. 0 means any (data node) type.\n+ * @param[in] getnext_opts lys_getnext() options to use.\n  * @param[out] ret Pointer to the node of the desired type. Can be NULL.\n  *\n  * @return EXIT_SUCCESS on success, EXIT_FAILURE on fail.\n  */\n int lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n-                     LYS_NODE type, const struct lys_node **ret);\n+                     LYS_NODE type, int getnext_opts, const struct lys_node **ret);\n \n int lyd_get_unique_default(const char* unique_expr, struct lyd_node *list, const char **dflt);\n "
        },
        {
          "filename": "src/tree_schema.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -213,7 +213,7 @@ lys_get_sibling(const struct lys_node *siblings, const char *mod_name, int mod_n\n \n int\n lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n-                 LYS_NODE type, const struct lys_node **ret)\n+                 LYS_NODE type, int getnext_opts, const struct lys_node **ret)\n {\n     const struct lys_node *node;\n \n@@ -226,7 +226,7 @@ lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, co\n \n     /* try to find the node */\n     node = NULL;\n-    while ((node = lys_getnext(node, parent, mod, 0))) {\n+    while ((node = lys_getnext(node, parent, mod, getnext_opts))) {\n         if (!type || (node->nodetype & type)) {\n             /* module check */\n             if (lys_node_module(node) != lys_main_module(mod)) {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "03e294d83b610f89e8ba7b2156a80dc0ad534443",
            "date": "2025-01-08T11:32:35Z",
            "author_login": "michalvasko"
          },
          {
            "sha": "9458469a06846e87d6a8b5e00dbf013d0e9d50c0",
            "date": "2025-01-08T11:32:25Z",
            "author_login": "michalvasko"
          },
          {
            "sha": "13bdd039a5852c8450e87868bea94d41144cafd0",
            "date": "2025-01-08T11:30:35Z",
            "author_login": "michalvasko"
          },
          {
            "sha": "08a2b06a4a0913aff45b0c65038d4c0f3c548b80",
            "date": "2025-01-08T08:51:31Z",
            "author_login": "michalvasko"
          },
          {
            "sha": "26e01dab9ef9866719eb478f8d493dfc6149908b",
            "date": "2025-01-08T08:51:15Z",
            "author_login": "michalvasko"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-119",
    "description": "An invalid memory access flaw is present in libyang before v1.0-r1 in the function resolve_feature_value() when an if-feature statement is used inside a list key node, and the feature used is not defined. Applications that use libyang to parse untrusted input yang files may crash.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-01-22T22:15:10.143",
    "last_modified": "2024-11-21T04:38:22.570",
    "fix_date": "2019-03-08T07:55:16Z"
  },
  "references": [
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1793922",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/CESNET/libyang/commit/32fb4993bc8bb49e93e84016af3c10ea53964be5",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/CESNET/libyang/compare/v0.16-r3...v1.0-r1",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/CESNET/libyang/issues/723",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2023/09/msg00019.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1793922",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/CESNET/libyang/commit/32fb4993bc8bb49e93e84016af3c10ea53964be5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/CESNET/libyang/compare/v0.16-r3...v1.0-r1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/CESNET/libyang/issues/723",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2023/09/msg00019.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:37.480406",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "libyang",
    "owner": "CESNET",
    "created_at": "2015-03-13T10:25:52Z",
    "updated_at": "2025-01-10T17:28:31Z",
    "pushed_at": "2025-01-09T14:22:09Z",
    "size": 45098,
    "stars": 374,
    "forks": 294,
    "open_issues": 16,
    "watchers": 374,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "devel",
      "libyang1",
      "master"
    ],
    "languages": {
      "C": 6704302,
      "CMake": 51183,
      "Tcl": 17965,
      "Shell": 17558,
      "Roff": 9841,
      "Makefile": 226
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T14:12:54.209083"
  }
}