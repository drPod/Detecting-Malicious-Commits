{
  "cve_id": "CVE-2019-25089",
  "github_data": {
    "repository": "Morgawr/Muon",
    "fix_commit": "c09ed972c020f759110c707b06ca2644f0bacd7f",
    "related_commits": [
      "c09ed972c020f759110c707b06ca2644f0bacd7f",
      "c09ed972c020f759110c707b06ca2644f0bacd7f"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "c09ed972c020f759110c707b06ca2644f0bacd7f",
      "commit_date": "2019-04-13T14:35:37Z",
      "author": {
        "login": "Morgawr",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix #4: Use randomized URLs",
        "length": 340,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 96,
        "additions": 78,
        "deletions": 18
      },
      "files": [
        {
          "filename": "build-wordlist.sh",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+#!/usr/bin/env bash\n+\n+function gen_dict() {\n+\tDICT=$1\n+\n+}\n+DICTFILE=/usr/share/dict/words\n+OUTFILE=db/wordlist\n+if test -f \"$DICTFILE\"; then\n+\t# Get all words longer than 5 characters and save them in their own wordlist file\n+\tawk 'length>5' $DICTFILE | uniq > $OUTFILE\n+else\n+\t(>&2 echo \"Error: The file ${DICTFILE} does not exist. Cannot generate wordlist for file indexing.\")\n+\texit 1\n+fi\n+"
        },
        {
          "filename": "create-db.sh",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -3,6 +3,6 @@\n mkdir db 2> /dev/null\n rm db/database.db 2> /dev/null\n sqlite3 db/database.db << EOF\n-create table data(id integer primary key autoincrement, folder text, filename text, text text, type text, policy text, expires_at timestamp, max_visits int, visits int);\n+create table data(id integer primary key autoincrement, folder text, filename text, type text, policy text, expires_at timestamp, max_visits int, visits int);\n create table autoexpire(id integer primary key autoincrement, data_id integer, expires_at timestamp);\n EOF"
        },
        {
          "filename": "project.clj",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,4 +1,4 @@\n-(defproject muon \"0.1.1\"\n+(defproject muon \"0.2.0-indev\"\n   :description \"Muon - Build your own self-destructible file host.\"\n   :url \"https://github.com/Morgawr/Muon.git\"\n   :dependencies [[org.clojure/clojure \"1.9.0\"]"
        },
        {
          "filename": "src/muon/handler.clj",
          "status": "modified",
          "additions": 60,
          "deletions": 16,
          "patch": "@@ -10,20 +10,24 @@\n             [clojure.java.jdbc :as db]))\n \n ; Modify this if you want to change the url returned by the\n-; webserver\n+; webserver.\n (def DOMAIN_ROOT \"http://localhost:8080/\")\n \n ; Change the password!!\n (def PASSWORD \"password\")\n \n+; Change this if you want to use a different file to source\n+; the randomized wordlists for your system.\n+(def WORDSFILE \"db/wordlist\")\n+\n ; Default Content-Type\n (def MIME \"application/octet-stream\")\n (def MIMEFILE \"/etc/mime.types\")\n (def mimetypes nil)\n \n (defn build-url\n   [& args]\n-  (reduce str DOMAIN_ROOT args))\n+  (reduce str DOMAIN_ROOT (interpose \"/\" args)))\n \n (defn pool\n   [spec]\n@@ -42,6 +46,11 @@\n (def pooled-db (delay (pool sqldb)))\n (defn db-connection [] @pooled-db)\n \n+(defn get-words-file []\n+  (clojure.string/split-lines (slurp WORDSFILE)))\n+\n+(def words-file (memoize get-words-file))\n+\n (defn get-from-db\n   [id]\n   (first (db/query (db-connection) (hn/format (hn/build {:select :*\n@@ -58,22 +67,40 @@\n    :headers {}\n    :body \"Internal server error, this should NOT happen.\"})\n \n+(defn generate-random-folder []\n+  (let [words (words-file)]\n+    (str (rand-nth words) (rand-nth words) (rand-nth words))))\n+\n+(def base-file-data {:folder \"\"\n+                     :filename \"\"\n+                     :type \"\"\n+                     :visits 0\n+                     :expires_at 0\n+                     :max_visits 0\n+                     :policy \"\"})\n+\n (defn save-to-db\n-  [text type opts]\n+  [folder filename type opts]\n   (let [duration (try (Integer/parseInt (:duration opts)) (catch Exception e nil))\n-        clicks (try (Integer/parseInt (:clicks opts)) (catch Exception e nil))]\n+        clicks (try (Integer/parseInt (:clicks opts)) (catch Exception e nil))\n+        data (merge base-file-data {:folder folder :filename filename :type type})\n+        get-id #(last (ffirst %))\n+        save-fn (fn [query expires?] \n+                  (let [res (db/insert! (db-connection) :data query)]\n+                    (when expires?\n+                      ; Set up auto-expire entry in the table\n+                      (db/insert! (db-connection) :autoexpire {:data_id (get-id res) \n+                                                               :expires_at (:expires_at query)}))\n+                    res))\n+        get-url #(build-url \"resource\" folder filename)]\n     (cond\n      (and (nil? duration) (nil? clicks)) wrong-options\n      (not (nil? clicks))\n-       (let [res (db/insert! (db-connection) :data {:text text :type type :policy \"clicks\" :expires_at 0 :max_visits clicks :visits 0})]\n-         (build-url\n-          \"resource/\"\n-          (str (last (ffirst res)) \"\\n\")))\n+       (let [res (save-fn (merge data {:policy \"clicks\" :max_visits clicks}) false)]\n+         (str (get-url) \"\\n\"))\n      (not (nil? duration))\n-       (let [res (db/insert! (db-connection) :data {:text text :type type :policy \"timed\" :expires_at (+ (System/currentTimeMillis) (* duration 1000)) :max_visits 0 :visits 0})]\n-         (build-url\n-          \"resource/\"\n-          (str (last (ffirst res)) \"\\n\")))\n+       (let [res (save-fn (merge data {:policy \"timed\" :expires_at (+ (System/currentTimeMillis) (* duration 1000))}) true)]\n+         (str (get-url) \"\\n\"))\n      :else internal-error)))\n \n (defn get-mime [filename]\n@@ -82,11 +109,23 @@\n         mime (or (get mimetypes ext) MIME)]\n     mime))\n \n+; TODO(morg): Make exit condition with exception if we recur too many times.\n+(defn randomize-file-location [filename]\n+  (loop []\n+    (let [folder (generate-random-folder)\n+          full-name (reduce str (interpose \"/\" [\"resources\" folder filename]))\n+          new-file (io/as-file full-name)]\n+      (do\n+        (io/make-parents full-name)\n+        (if (not (.exists new-file))\n+          [folder new-file]\n+          (recur))))))\n+\n (defn handle-file-upload\n   [data]\n-  (let [filename (str \"resources/\" (System/currentTimeMillis))]\n-    (io/copy (:tempfile (:file data)) (io/as-file filename))\n-    (save-to-db filename (get-mime (:filename (:file data))) data)))\n+  (let [[folder file] (randomize-file-location (:filename (:file data)))]\n+    (io/copy (:tempfile (:file data)) file)\n+    (save-to-db folder (:filename (:file data)) (get-mime (:filename (:file data))) data)))\n \n (defn build-response\n   [text type]\n@@ -120,13 +159,18 @@\n                    (zipmap (rest line) (repeat (first line))))\n                 (clojure.string/split (slurp file) #\"\\n\"))))\n \n+\n+(defn check-password [password]\n+  (not= password PASSWORD))\n+\n (defroutes app-routes\n   (GET \"/\" [] \"Welcome to Muon, the private self-destructible file host.\")\n+  ; TODO(morg) Remove the /resource/ path and only access $HOST/<folder>/<filename> \n   (GET [\"/resource/:id\" :id #\"[0-9]+\"] [id] (return-data (Integer/parseInt id)))\n   (mp/wrap-multipart-params\n    (POST \"/upload\" {params :params}\n          (cond\n-           (not= (:password params) PASSWORD)\n+           (check-password (:password params))\n              {:status 401\n               :header {}\n               :body \"Unauthorized access. This incident will be reported to your parents.\\n\"}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "bfbd83fa787fd441a99fdc6cc516ec9fbcee9433",
            "date": "2021-02-14T10:49:47Z",
            "author_login": "Morgawr"
          },
          {
            "sha": "b37b3f2ab300895e86cc0ab5a4512c551159bc87",
            "date": "2021-02-14T09:48:30Z",
            "author_login": "Morgawr"
          },
          {
            "sha": "675679beb6f8a501ad64a661a1bdd5a7f41cb80d",
            "date": "2021-02-14T09:21:42Z",
            "author_login": "Morgawr"
          },
          {
            "sha": "b0b1030630606b12cacbe8a252cc9a61a4cbeb81",
            "date": "2021-02-14T07:22:11Z",
            "author_login": "Morgawr"
          },
          {
            "sha": "1c0717ef0bd071ed2c737aeb289caf9bb219fc9d",
            "date": "2021-02-14T07:14:04Z",
            "author_login": "Morgawr"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-330",
    "description": "A vulnerability has been found in Morgawr Muon 0.1.1 and classified as problematic. Affected by this vulnerability is an unknown functionality of the file src/muon/handler.clj. The manipulation leads to insufficiently random values. The attack can be launched remotely. Upgrading to version 0.2.0-indev is able to address this issue. The name of the patch is c09ed972c020f759110c707b06ca2644f0bacd7f. It is recommended to upgrade the affected component. The identifier VDB-216877 was assigned to this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-12-27T12:15:10.837",
    "last_modified": "2024-11-21T04:39:54.807",
    "fix_date": "2019-04-13T14:35:37Z"
  },
  "references": [
    {
      "url": "https://github.com/Morgawr/Muon/commit/c09ed972c020f759110c707b06ca2644f0bacd7f",
      "source": "cna@vuldb.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Morgawr/Muon/issues/4",
      "source": "cna@vuldb.com",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?ctiid.216877",
      "source": "cna@vuldb.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?id.216877",
      "source": "cna@vuldb.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Morgawr/Muon/commit/c09ed972c020f759110c707b06ca2644f0bacd7f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Morgawr/Muon/issues/4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?ctiid.216877",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?id.216877",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:23.215830",
    "processing_status": "enhanced"
  }
}