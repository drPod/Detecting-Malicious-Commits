{
  "cve_id": "CVE-2020-10683",
  "github_data": {
    "repository": "dom4j/dom4j",
    "fix_commit": "a8228522a99a02146106672a34c104adbda5c658",
    "related_commits": [
      "a8228522a99a02146106672a34c104adbda5c658",
      "a8228522a99a02146106672a34c104adbda5c658"
    ],
    "patch_url": "https://github.com/dom4j/dom4j/commit/a8228522a99a02146106672a34c104adbda5c658.patch",
    "fix_commit_details": {
      "sha": "a8228522a99a02146106672a34c104adbda5c658",
      "commit_date": "2020-04-11T17:06:44Z",
      "author": {
        "login": "FilipJirsak",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "SAXReader uses system default XMLReader with its defaults. New factory method SAXReader.createDefault() sets more secure defaults.",
        "length": 130,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 1926,
        "additions": 973,
        "deletions": 953
      },
      "files": [
        {
          "filename": "src/main/java/org/dom4j/DocumentHelper.java",
          "status": "modified",
          "additions": 29,
          "deletions": 36,
          "patch": "@@ -107,12 +107,12 @@ public static QName createQName(String localName) {\n      * XPath <code>XPath</code> instance using the singleton {@link\n      * DocumentFactory}.\n      * </p>\n-     * \n+     *\n      * @param xpathExpression\n      *            is the XPath expression to create\n-     * \n+     *\n      * @return a new <code>XPath</code> instance\n-     * \n+     *\n      * @throws InvalidXPathException\n      *             if the XPath expression is invalid\n      */\n@@ -127,14 +127,14 @@ public static XPath createXPath(String xpathExpression)\n      * XPath <code>XPath</code> instance using the singleton {@link\n      * DocumentFactory}.\n      * </p>\n-     * \n+     *\n      * @param xpathExpression\n      *            is the XPath expression to create\n      * @param context\n      *            is the variable context to use when evaluating the XPath\n-     * \n+     *\n      * @return a new <code>XPath</code> instance\n-     * \n+     *\n      * @throws InvalidXPathException\n      *             if the XPath expression is invalid\n      */\n@@ -150,10 +150,10 @@ public static XPath createXPath(String xpathExpression,\n      * filter expressions occur within XPath expressions such as\n      * <code>self::node()[ filterExpression ]</code>\n      * </p>\n-     * \n+     *\n      * @param xpathFilterExpression\n      *            is the XPath filter expression to create\n-     * \n+     *\n      * @return a new <code>NodeFilter</code> instance\n      */\n     public static NodeFilter createXPathFilter(String xpathFilterExpression) {\n@@ -166,10 +166,10 @@ public static NodeFilter createXPathFilter(String xpathFilterExpression) {\n      * an XSLT style {@link Pattern}instance which can then be used in an XSLT\n      * processing model.\n      * </p>\n-     * \n+     *\n      * @param xpathPattern\n      *            is the XPath pattern expression to create\n-     * \n+     *\n      * @return a new <code>Pattern</code> instance\n      */\n     public static Pattern createPattern(String xpathPattern) {\n@@ -182,12 +182,12 @@ public static Pattern createPattern(String xpathPattern) {\n      * {@link List}of {@link Node}instances appending all the results together\n      * into a single list.\n      * </p>\n-     * \n+     *\n      * @param xpathFilterExpression\n      *            is the XPath filter expression to evaluate\n      * @param nodes\n      *            is the list of nodes on which to evalute the XPath\n-     * \n+     *\n      * @return the results of all the XPath evaluations as a single list\n      */\n     public static List<Node> selectNodes(String xpathFilterExpression, List<Node> nodes) {\n@@ -202,12 +202,12 @@ public static List<Node> selectNodes(String xpathFilterExpression, List<Node> no\n      * {@link List}of {@link Node}instances appending all the results together\n      * into a single list.\n      * </p>\n-     * \n+     *\n      * @param xpathFilterExpression\n      *            is the XPath filter expression to evaluate\n      * @param node\n      *            is the Node on which to evalute the XPath\n-     * \n+     *\n      * @return the results of all the XPath evaluations as a single list\n      */\n     public static List<Node> selectNodes(String xpathFilterExpression, Node node) {\n@@ -221,7 +221,7 @@ public static List<Node> selectNodes(String xpathFilterExpression, Node node) {\n      * <code>sort</code> sorts the given List of Nodes using an XPath\n      * expression as a {@link java.util.Comparator}.\n      * </p>\n-     * \n+     *\n      * @param list\n      *            is the list of Nodes to sort\n      * @param xpathExpression\n@@ -238,7 +238,7 @@ public static void sort(List<Node> list, String xpathExpression) {\n      * expression as a {@link java.util.Comparator}and optionally removing\n      * duplicates.\n      * </p>\n-     * \n+     *\n      * @param list\n      *            is the list of Nodes to sort\n      * @param expression\n@@ -259,24 +259,17 @@ public static void sort(List<Node> list, String expression, boolean distinct) {\n      * </p>\n      *\n      * Loading external DTD and entities is disabled (if it is possible) for security reasons.\n-     * \n+     *\n      * @param text\n      *            the XML text to be parsed\n-     * \n+     *\n      * @return a newly parsed Document\n-     * \n+     *\n      * @throws DocumentException\n      *             if the document could not be parsed\n      */\n     public static Document parseText(String text) throws DocumentException {\n-        SAXReader reader = new SAXReader();\n-        try {\n-            reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n-            reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n-            reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n-        } catch (SAXException e) {\n-            //Parse with external resources downloading allowed.\n-        }\n+        SAXReader reader = SAXReader.createDefault();\n \n         String encoding = getEncoding(text);\n \n@@ -330,14 +323,14 @@ private static String getEncoding(String text) {\n      * get the first child &lt;a&gt; element, which would be created if it did\n      * not exist, then the next child &lt;b&gt; and so on until finally a\n      * &lt;c&gt; element is returned.\n-     * \n+     *\n      * @param source\n      *            is the Element or Document to start navigating from\n      * @param path\n      *            is a simple path expression, seperated by '/' which denotes\n      *            the path from the source to the resulting element such as\n      *            a/b/c\n-     * \n+     *\n      * @return the first Element on the given path which either already existed\n      *         on the path or were created by this method.\n      */\n@@ -386,24 +379,24 @@ public static Element makeElement(Branch source, String path) {\n  * Redistribution and use of this software and associated documentation\n  * (\"Software\"), with or without modification, are permitted provided that the\n  * following conditions are met:\n- * \n+ *\n  * 1. Redistributions of source code must retain copyright statements and\n  * notices. Redistributions must also contain a copy of this document.\n- * \n+ *\n  * 2. Redistributions in binary form must reproduce the above copyright notice,\n  * this list of conditions and the following disclaimer in the documentation\n  * and/or other materials provided with the distribution.\n- * \n+ *\n  * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n  * from this Software without prior written permission of MetaStuff, Ltd. For\n  * written permission, please contact dom4j-info@metastuff.com.\n- * \n+ *\n  * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n  * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n  * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n- * \n+ *\n  * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n- * \n+ *\n  * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n  * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n@@ -415,6 +408,6 @@ public static Element makeElement(Branch source, String path) {\n  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n  * POSSIBILITY OF SUCH DAMAGE.\n- * \n+ *\n  * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n  */"
        },
        {
          "filename": "src/main/java/org/dom4j/io/SAXHelper.java",
          "status": "modified",
          "additions": 24,
          "deletions": 13,
          "patch": "@@ -13,12 +13,14 @@\n import org.xml.sax.XMLReader;\n import org.xml.sax.helpers.XMLReaderFactory;\n \n+import javax.xml.parsers.SAXParserFactory;\n+\n /**\n  * <p>\n  * <code>SAXHelper</code> contains some helper methods for working with SAX\n  * and XMLReader objects.\n  * </p>\n- * \n+ *\n  * @author <a href=\"mailto:james.strachan@metastuff.com\">James Strachan </a>\n  * @version $Revision: 1.18 $\n  */\n@@ -61,12 +63,21 @@ public static boolean setParserFeature(XMLReader reader,\n     /**\n      * Creats a default XMLReader via the org.xml.sax.driver system property or\n      * JAXP if the system property is not set.\n-     * \n+     *\n+     * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n+     * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n+     *\n+     * <pre>\n+     * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+     * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+     * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+     * </pre>\n+     *\n      * @param validating\n      *            DOCUMENT ME!\n-     * \n+     *\n      * @return DOCUMENT ME!\n-     * \n+     *\n      * @throws SAXException\n      *             DOCUMENT ME!\n      */\n@@ -125,12 +136,12 @@ public static XMLReader createXMLReader(boolean validating)\n      * This method attempts to use JAXP to locate the SAX2 XMLReader\n      * implementation. This method uses reflection to avoid being dependent\n      * directly on the JAXP classes.\n-     * \n+     *\n      * @param validating\n      *            DOCUMENT ME!\n      * @param namespaceAware\n      *            DOCUMENT ME!\n-     * \n+     *\n      * @return DOCUMENT ME!\n      */\n     protected static XMLReader createXMLReaderViaJAXP(boolean validating,\n@@ -176,24 +187,24 @@ protected static boolean isVerboseErrorReporting() {\n  * Redistribution and use of this software and associated documentation\n  * (\"Software\"), with or without modification, are permitted provided that the\n  * following conditions are met:\n- * \n+ *\n  * 1. Redistributions of source code must retain copyright statements and\n  * notices. Redistributions must also contain a copy of this document.\n- * \n+ *\n  * 2. Redistributions in binary form must reproduce the above copyright notice,\n  * this list of conditions and the following disclaimer in the documentation\n  * and/or other materials provided with the distribution.\n- * \n+ *\n  * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n  * from this Software without prior written permission of MetaStuff, Ltd. For\n  * written permission, please contact dom4j-info@metastuff.com.\n- * \n+ *\n  * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n  * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n  * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n- * \n+ *\n  * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n- * \n+ *\n  * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n  * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n@@ -205,6 +216,6 @@ protected static boolean isVerboseErrorReporting() {\n  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n  * POSSIBILITY OF SUCH DAMAGE.\n- * \n+ *\n  * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n  */"
        },
        {
          "filename": "src/main/java/org/dom4j/io/SAXReader.java",
          "status": "modified",
          "additions": 920,
          "deletions": 904,
          "patch": "@@ -30,965 +30,981 @@\n import org.xml.sax.helpers.DefaultHandler;\n import org.xml.sax.helpers.XMLReaderFactory;\n \n+import javax.xml.parsers.SAXParserFactory;\n+\n /**\n  * <code>SAXReader</code> creates a DOM4J tree from SAX parsing events.\n- *\n+ * <p>\n  * The actual SAX parser that is used by this class is configurable so you can\n  * use your favourite SAX parser if you wish. DOM4J comes configured with its\n  * own SAX parser so you do not need to worry about configuring the SAX parser.\n- *\n+ * <p>\n  * To explicitly configure the SAX parser that is used via Java code you can use\n  * a constructor or use the {@link #setXMLReader(XMLReader)}or {@link\n  * #setXMLReaderClassName(String)} methods.\n- *\n+ * <p>\n  * If the parser is not specified explicitly then the standard SAX policy of\n  * using the <code>org.xml.sax.driver</code> system property is used to\n  * determine the implementation class of {@link XMLReader}.\n- *\n+ * <p>\n  * If the <code>org.xml.sax.driver</code> system property is not defined then\n  * JAXP is used via reflection (so that DOM4J is not explicitly dependent on the\n  * JAXP classes) to load the JAXP configured SAXParser. If there is any error\n  * creating a JAXP SAXParser an informational message is output and then the\n  * default (Aelfred) SAX parser is used instead.\n- *\n+ * <p>\n  * If you are trying to use JAXP to explicitly set your SAX parser and are\n  * experiencing problems, you can turn on verbose error reporting by defining\n  * the system property <code>org.dom4j.verbose</code> to be \"true\" which will\n  * output a more detailed description of why JAXP could not find a SAX parser\n- *\n+ * <p>\n  * For more information on JAXP please go to <a\n  * href=\"http://java.sun.com/xml/\">Sun's Java &amp; XML site </a>\n  *\n  * @author <a href=\"mailto:james.strachan@metastuff.com\">James Strachan </a>\n  * @version $Revision: 1.58 $\n  */\n public class SAXReader {\n-    private static final String SAX_STRING_INTERNING = \n-            \"http://xml.org/sax/features/string-interning\";\n-    private static final String SAX_DECL_HANDLER =\n-            \"http://xml.org/sax/properties/declaration-handler\";\n-    private static final String SAX_LEXICAL_HANDLER = \n-            \"http://xml.org/sax/properties/lexical-handler\";\n-    private static final String SAX_LEXICALHANDLER = \n-            \"http://xml.org/sax/handlers/LexicalHandler\";\n-\n-    /** <code>DocumentFactory</code> used to create new document objects */\n-    private DocumentFactory factory;\n-\n-    /** <code>XMLReader</code> used to parse the SAX events */\n-    private XMLReader xmlReader;\n-\n-    /** Whether validation should occur */\n-    private boolean validating;\n-\n-    /** DispatchHandler to call when each <code>Element</code> is encountered */\n-    private DispatchHandler dispatchHandler;\n-\n-    /** ErrorHandler class to use */\n-    private ErrorHandler errorHandler;\n-\n-    /** The entity resolver */\n-    private EntityResolver entityResolver;\n-\n-    /** Should element & attribute names and namespace URIs be interned? */\n-    private boolean stringInternEnabled = true;\n-\n-    /** Should internal DTD declarations be expanded into a List in the DTD */\n-    private boolean includeInternalDTDDeclarations = false;\n-\n-    /** Should external DTD declarations be expanded into a List in the DTD */\n-    private boolean includeExternalDTDDeclarations = false;\n-\n-    /** Whether adjacent text nodes should be merged */\n-    private boolean mergeAdjacentText = false;\n-\n-    /** Holds value of property stripWhitespaceText. */\n-    private boolean stripWhitespaceText = false;\n-\n-    /** Should we ignore comments */\n-    private boolean ignoreComments = false;\n-\n-    /** Encoding of InputSource - null means system default encoding */\n-    private String encoding = null;\n-\n-    // private boolean includeExternalGeneralEntities = false;\n-    // private boolean includeExternalParameterEntities = false;\n-\n-    /** The SAX filter used to filter SAX events */\n-    private XMLFilter xmlFilter;\n-\n-    public SAXReader() {\n-    }\n-\n-    public SAXReader(boolean validating) {\n-        this.validating = validating;\n-    }\n-\n-    public SAXReader(DocumentFactory factory) {\n-        this.factory = factory;\n-    }\n-\n-    public SAXReader(DocumentFactory factory, boolean validating) {\n-        this.factory = factory;\n-        this.validating = validating;\n-    }\n-\n-    public SAXReader(XMLReader xmlReader) {\n-        this.xmlReader = xmlReader;\n-    }\n-\n-    public SAXReader(XMLReader xmlReader, boolean validating) {\n-        this.xmlReader = xmlReader;\n-        this.validating = validating;\n-    }\n-\n-    public SAXReader(String xmlReaderClassName) throws SAXException {\n-        if (xmlReaderClassName != null) {\n-            this.xmlReader = XMLReaderFactory\n-                    .createXMLReader(xmlReaderClassName);\n+  private static final String SAX_STRING_INTERNING =\n+          \"http://xml.org/sax/features/string-interning\";\n+  private static final String SAX_DECL_HANDLER =\n+          \"http://xml.org/sax/properties/declaration-handler\";\n+  private static final String SAX_LEXICAL_HANDLER =\n+          \"http://xml.org/sax/properties/lexical-handler\";\n+  private static final String SAX_LEXICALHANDLER =\n+          \"http://xml.org/sax/handlers/LexicalHandler\";\n+\n+  /**\n+   * <code>DocumentFactory</code> used to create new document objects\n+   */\n+  private DocumentFactory factory;\n+\n+  /**\n+   * <code>XMLReader</code> used to parse the SAX events\n+   */\n+  private XMLReader xmlReader;\n+\n+  /**\n+   * Whether validation should occur\n+   */\n+  private boolean validating;\n+\n+  /**\n+   * DispatchHandler to call when each <code>Element</code> is encountered\n+   */\n+  private DispatchHandler dispatchHandler;\n+\n+  /**\n+   * ErrorHandler class to use\n+   */\n+  private ErrorHandler errorHandler;\n+\n+  /**\n+   * The entity resolver\n+   */\n+  private EntityResolver entityResolver;\n+\n+  /**\n+   * Should element & attribute names and namespace URIs be interned?\n+   */\n+  private boolean stringInternEnabled = true;\n+\n+  /**\n+   * Should internal DTD declarations be expanded into a List in the DTD\n+   */\n+  private boolean includeInternalDTDDeclarations = false;\n+\n+  /**\n+   * Should external DTD declarations be expanded into a List in the DTD\n+   */\n+  private boolean includeExternalDTDDeclarations = false;\n+\n+  /**\n+   * Whether adjacent text nodes should be merged\n+   */\n+  private boolean mergeAdjacentText = false;\n+\n+  /**\n+   * Holds value of property stripWhitespaceText.\n+   */\n+  private boolean stripWhitespaceText = false;\n+\n+  /**\n+   * Should we ignore comments\n+   */\n+  private boolean ignoreComments = false;\n+\n+  /**\n+   * Encoding of InputSource - null means system default encoding\n+   */\n+  private String encoding = null;\n+\n+  // private boolean includeExternalGeneralEntities = false;\n+  // private boolean includeExternalParameterEntities = false;\n+\n+  /**\n+   * The SAX filter used to filter SAX events\n+   *\n+   * @since 2.1.2\n+   */\n+  private XMLFilter xmlFilter;\n+\n+  public static SAXReader createDefault() {\n+    SAXReader reader = new SAXReader();\n+    try {\n+      reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+      reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+      reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+    } catch (SAXException e) {\n+      // nothing to do, incompatible reader\n+    }\n+    return reader;\n+  }\n+\n+  /**\n+   * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n+   * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n+   *\n+   * <pre>\n+   * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+   * </pre>\n+   */\n+  public SAXReader() {\n+  }\n+\n+  /**\n+   * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n+   * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n+   *\n+   * <pre>\n+   * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+   * </pre>\n+   *\n+   * @param validating\n+   */\n+  public SAXReader(boolean validating) {\n+    this.validating = validating;\n+  }\n+\n+  /**\n+   * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n+   * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n+   *\n+   * <pre>\n+   * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+   * </pre>\n+   *\n+   * @param factory\n+   */\n+  public SAXReader(DocumentFactory factory) {\n+    this.factory = factory;\n+  }\n+\n+  /**\n+   * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n+   * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n+   *\n+   * <pre>\n+   * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+   * </pre>\n+   *\n+   * @param factory\n+   * @param validating\n+   */\n+  public SAXReader(DocumentFactory factory, boolean validating) {\n+    this.factory = factory;\n+    this.validating = validating;\n+  }\n+\n+  public SAXReader(XMLReader xmlReader) {\n+    this.xmlReader = xmlReader;\n+  }\n+\n+  public SAXReader(XMLReader xmlReader, boolean validating) {\n+    this.xmlReader = xmlReader;\n+    this.validating = validating;\n+  }\n+\n+  public SAXReader(String xmlReaderClassName) throws SAXException {\n+    if (xmlReaderClassName != null) {\n+      this.xmlReader = XMLReaderFactory\n+              .createXMLReader(xmlReaderClassName);\n+    }\n+  }\n+\n+  public SAXReader(String xmlReaderClassName, boolean validating)\n+          throws SAXException {\n+    if (xmlReaderClassName != null) {\n+      this.xmlReader = XMLReaderFactory\n+              .createXMLReader(xmlReaderClassName);\n+    }\n+\n+    this.validating = validating;\n+  }\n+\n+  /**\n+   * Allows a SAX property to be set on the underlying SAX parser. This can be\n+   * useful to set parser-specific properties such as the location of schema\n+   * or DTD resources. Though use this method with caution as it has the\n+   * possibility of breaking the standard behaviour. An alternative to calling\n+   * this method is to correctly configure an XMLReader object instance and\n+   * call the {@link #setXMLReader(XMLReader)}method\n+   *\n+   * @param name  is the SAX property name\n+   * @param value is the value of the SAX property\n+   * @throws SAXException if the XMLReader could not be created or the property could\n+   *                      not be changed.\n+   */\n+  public void setProperty(String name, Object value) throws SAXException {\n+    getXMLReader().setProperty(name, value);\n+  }\n+\n+  /**\n+   * Sets a SAX feature on the underlying SAX parser. This can be useful to\n+   * set parser-specific features. Though use this method with caution as it\n+   * has the possibility of breaking the standard behaviour. An alternative to\n+   * calling this method is to correctly configure an XMLReader object\n+   * instance and call the {@link #setXMLReader(XMLReader)}method\n+   *\n+   * @param name  is the SAX feature name\n+   * @param value is the value of the SAX feature\n+   * @throws SAXException if the XMLReader could not be created or the feature could\n+   *                      not be changed.\n+   */\n+  public void setFeature(String name, boolean value) throws SAXException {\n+    getXMLReader().setFeature(name, value);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given <code>File</code>\n+   * </p>\n+   *\n+   * @param file is the <code>File</code> to read from.\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(File file) throws DocumentException {\n+    try {\n+      /*\n+       * We cannot convert the file to an URL because if the filename\n+       * contains '#' characters, there will be problems with the URL in\n+       * the InputSource (because a URL like\n+       * http://myhost.com/index#anchor is treated the same as\n+       * http://myhost.com/index) Thanks to Christian Oetterli\n+       */\n+      InputSource source = new InputSource(new FileInputStream(file));\n+      if (this.encoding != null) {\n+        source.setEncoding(this.encoding);\n+      }\n+      String path = file.getAbsolutePath();\n+\n+      if (path != null) {\n+        // Code taken from Ant FileUtils\n+        StringBuffer sb = new StringBuffer(\"file://\");\n+\n+        // add an extra slash for filesystems with drive-specifiers\n+        if (!path.startsWith(File.separator)) {\n+          sb.append(\"/\");\n         }\n-    }\n \n-    public SAXReader(String xmlReaderClassName, boolean validating)\n-            throws SAXException {\n-        if (xmlReaderClassName != null) {\n-            this.xmlReader = XMLReaderFactory\n-                    .createXMLReader(xmlReaderClassName);\n+        path = path.replace('\\\\', '/');\n+        sb.append(path);\n+\n+        source.setSystemId(sb.toString());\n+      }\n+\n+      return read(source);\n+    } catch (FileNotFoundException e) {\n+      throw new DocumentException(e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given <code>URL</code> using SAX\n+   * </p>\n+   *\n+   * @param url <code>URL</code> to read from.\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(URL url) throws DocumentException {\n+    String systemID = url.toExternalForm();\n+\n+    InputSource source = new InputSource(systemID);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given URL or filename using SAX.\n+   * </p>\n+   *\n+   * <p>\n+   * If the systemId contains a <code>':'</code> character then it is\n+   * assumed to be a URL otherwise its assumed to be a file name. If you want\n+   * finer grained control over this mechansim then please explicitly pass in\n+   * either a {@link URL}or a {@link File}instance instead of a {@link\n+   * String} to denote the source of the document.\n+   * </p>\n+   *\n+   * @param systemId is a URL for a document or a file name.\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(String systemId) throws DocumentException {\n+    InputSource source = new InputSource(systemId);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given stream using SAX\n+   * </p>\n+   *\n+   * @param in <code>InputStream</code> to read from.\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(InputStream in) throws DocumentException {\n+    InputSource source = new InputSource(in);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * Reads a Document from the given <code>Reader</code> using SAX\n+   *\n+   * @param reader is the reader for the input\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(Reader reader) throws DocumentException {\n+    InputSource source = new InputSource(reader);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given stream using SAX\n+   * </p>\n+   *\n+   * @param in       <code>InputStream</code> to read from.\n+   * @param systemId is the URI for the input\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(InputStream in, String systemId)\n+          throws DocumentException {\n+    InputSource source = new InputSource(in);\n+    source.setSystemId(systemId);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given <code>Reader</code> using SAX\n+   * </p>\n+   *\n+   * @param reader   is the reader for the input\n+   * @param systemId is the URI for the input\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(Reader reader, String systemId)\n+          throws DocumentException {\n+    InputSource source = new InputSource(reader);\n+    source.setSystemId(systemId);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given <code>InputSource</code> using SAX\n+   * </p>\n+   *\n+   * @param in <code>InputSource</code> to read from.\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(InputSource in) throws DocumentException {\n+    try {\n+      XMLReader reader = getXMLReader();\n+\n+      reader = installXMLFilter(reader);\n+\n+      EntityResolver thatEntityResolver = this.entityResolver;\n+\n+      if (thatEntityResolver == null) {\n+        thatEntityResolver = createDefaultEntityResolver(in\n+                .getSystemId());\n+        this.entityResolver = thatEntityResolver;\n+      }\n+\n+      reader.setEntityResolver(thatEntityResolver);\n+\n+      SAXContentHandler contentHandler = createContentHandler(reader);\n+      contentHandler.setEntityResolver(thatEntityResolver);\n+      contentHandler.setInputSource(in);\n+\n+      boolean internal = isIncludeInternalDTDDeclarations();\n+      boolean external = isIncludeExternalDTDDeclarations();\n+\n+      contentHandler.setIncludeInternalDTDDeclarations(internal);\n+      contentHandler.setIncludeExternalDTDDeclarations(external);\n+      contentHandler.setMergeAdjacentText(isMergeAdjacentText());\n+      contentHandler.setStripWhitespaceText(isStripWhitespaceText());\n+      contentHandler.setIgnoreComments(isIgnoreComments());\n+      reader.setContentHandler(contentHandler);\n+\n+      configureReader(reader, contentHandler);\n+\n+      reader.parse(in);\n+\n+      return contentHandler.getDocument();\n+    } catch (Exception e) {\n+      if (e instanceof SAXParseException) {\n+        // e.printStackTrace();\n+        SAXParseException parseException = (SAXParseException) e;\n+        String systemId = parseException.getSystemId();\n+\n+        if (systemId == null) {\n+          systemId = \"\";\n         }\n \n-        this.validating = validating;\n-    }\n-\n-    /**\n-     * Allows a SAX property to be set on the underlying SAX parser. This can be\n-     * useful to set parser-specific properties such as the location of schema\n-     * or DTD resources. Though use this method with caution as it has the\n-     * possibility of breaking the standard behaviour. An alternative to calling\n-     * this method is to correctly configure an XMLReader object instance and\n-     * call the {@link #setXMLReader(XMLReader)}method\n-     * \n-     * @param name\n-     *            is the SAX property name\n-     * @param value\n-     *            is the value of the SAX property\n-     * \n-     * @throws SAXException\n-     *             if the XMLReader could not be created or the property could\n-     *             not be changed.\n-     */\n-    public void setProperty(String name, Object value) throws SAXException {\n-        getXMLReader().setProperty(name, value);\n-    }\n-\n-    /**\n-     * Sets a SAX feature on the underlying SAX parser. This can be useful to\n-     * set parser-specific features. Though use this method with caution as it\n-     * has the possibility of breaking the standard behaviour. An alternative to\n-     * calling this method is to correctly configure an XMLReader object\n-     * instance and call the {@link #setXMLReader(XMLReader)}method\n-     * \n-     * @param name\n-     *            is the SAX feature name\n-     * @param value\n-     *            is the value of the SAX feature\n-     * \n-     * @throws SAXException\n-     *             if the XMLReader could not be created or the feature could\n-     *             not be changed.\n-     */\n-    public void setFeature(String name, boolean value) throws SAXException {\n-        getXMLReader().setFeature(name, value);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given <code>File</code>\n-     * </p>\n-     * \n-     * @param file\n-     *            is the <code>File</code> to read from.\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(File file) throws DocumentException {\n-        try {\n-            /*\n-             * We cannot convert the file to an URL because if the filename\n-             * contains '#' characters, there will be problems with the URL in\n-             * the InputSource (because a URL like\n-             * http://myhost.com/index#anchor is treated the same as\n-             * http://myhost.com/index) Thanks to Christian Oetterli\n-             */\n-            InputSource source = new InputSource(new FileInputStream(file));\n-            if (this.encoding != null) {\n-                source.setEncoding(this.encoding);\n-            }\n-            String path = file.getAbsolutePath();\n-\n-            if (path != null) {\n-                // Code taken from Ant FileUtils\n-                StringBuffer sb = new StringBuffer(\"file://\");\n-\n-                // add an extra slash for filesystems with drive-specifiers\n-                if (!path.startsWith(File.separator)) {\n-                    sb.append(\"/\");\n-                }\n-\n-                path = path.replace('\\\\', '/');\n-                sb.append(path);\n-\n-                source.setSystemId(sb.toString());\n-            }\n-\n-            return read(source);\n-        } catch (FileNotFoundException e) {\n-            throw new DocumentException(e.getMessage(), e);\n+        String message = \"Error on line \"\n+                + parseException.getLineNumber() + \" of document \"\n+                + systemId + \" : \" + parseException.getMessage();\n+\n+        throw new DocumentException(message, e);\n+      } else {\n+        throw new DocumentException(e.getMessage(), e);\n+      }\n+    }\n+  }\n+\n+  // Properties\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return the validation mode, true if validating will be done otherwise\n+   * false.\n+   */\n+  public boolean isValidating() {\n+    return validating;\n+  }\n+\n+  /**\n+   * Sets the validation mode.\n+   *\n+   * @param validation indicates whether or not validation should occur.\n+   */\n+  public void setValidation(boolean validation) {\n+    this.validating = validation;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return whether internal DTD declarations should be expanded into the\n+   * DocumentType object or not.\n+   */\n+  public boolean isIncludeInternalDTDDeclarations() {\n+    return includeInternalDTDDeclarations;\n+  }\n+\n+  /**\n+   * Sets whether internal DTD declarations should be expanded into the\n+   * DocumentType object or not.\n+   *\n+   * @param include whether or not DTD declarations should be expanded and\n+   *                included into the DocumentType object.\n+   */\n+  public void setIncludeInternalDTDDeclarations(boolean include) {\n+    this.includeInternalDTDDeclarations = include;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return whether external DTD declarations should be expanded into the\n+   * DocumentType object or not.\n+   */\n+  public boolean isIncludeExternalDTDDeclarations() {\n+    return includeExternalDTDDeclarations;\n+  }\n+\n+  /**\n+   * Sets whether DTD external declarations should be expanded into the\n+   * DocumentType object or not.\n+   *\n+   * @param include whether or not DTD declarations should be expanded and\n+   *                included into the DocumentType object.\n+   */\n+  public void setIncludeExternalDTDDeclarations(boolean include) {\n+    this.includeExternalDTDDeclarations = include;\n+  }\n+\n+  /**\n+   * Sets whether String interning is enabled or disabled for element &amp;\n+   * attribute names and namespace URIs. This proprety is enabled by default.\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public boolean isStringInternEnabled() {\n+    return stringInternEnabled;\n+  }\n+\n+  /**\n+   * Sets whether String interning is enabled or disabled for element &amp;\n+   * attribute names and namespace URIs\n+   *\n+   * @param stringInternEnabled DOCUMENT ME!\n+   */\n+  public void setStringInternEnabled(boolean stringInternEnabled) {\n+    this.stringInternEnabled = stringInternEnabled;\n+  }\n+\n+  /**\n+   * Returns whether adjacent text nodes should be merged together.\n+   *\n+   * @return Value of property mergeAdjacentText.\n+   */\n+  public boolean isMergeAdjacentText() {\n+    return mergeAdjacentText;\n+  }\n+\n+  /**\n+   * Sets whether or not adjacent text nodes should be merged together when\n+   * parsing.\n+   *\n+   * @param mergeAdjacentText New value of property mergeAdjacentText.\n+   */\n+  public void setMergeAdjacentText(boolean mergeAdjacentText) {\n+    this.mergeAdjacentText = mergeAdjacentText;\n+  }\n+\n+  /**\n+   * Sets whether whitespace between element start and end tags should be\n+   * ignored\n+   *\n+   * @return Value of property stripWhitespaceText.\n+   */\n+  public boolean isStripWhitespaceText() {\n+    return stripWhitespaceText;\n+  }\n+\n+  /**\n+   * Sets whether whitespace between element start and end tags should be\n+   * ignored.\n+   *\n+   * @param stripWhitespaceText New value of property stripWhitespaceText.\n+   */\n+  public void setStripWhitespaceText(boolean stripWhitespaceText) {\n+    this.stripWhitespaceText = stripWhitespaceText;\n+  }\n+\n+  /**\n+   * Returns whether we should ignore comments or not.\n+   *\n+   * @return boolean\n+   */\n+  public boolean isIgnoreComments() {\n+    return ignoreComments;\n+  }\n+\n+  /**\n+   * Sets whether we should ignore comments or not.\n+   *\n+   * @param ignoreComments whether we should ignore comments or not.\n+   */\n+  public void setIgnoreComments(boolean ignoreComments) {\n+    this.ignoreComments = ignoreComments;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return the <code>DocumentFactory</code> used to create document\n+   * objects\n+   */\n+  public DocumentFactory getDocumentFactory() {\n+    if (factory == null) {\n+      factory = DocumentFactory.getInstance();\n+    }\n+\n+    return factory;\n+  }\n+\n+  /**\n+   * <p>\n+   * This sets the <code>DocumentFactory</code> used to create new\n+   * documents. This method allows the building of custom DOM4J tree objects\n+   * to be implemented easily using a custom derivation of\n+   * {@link DocumentFactory}\n+   * </p>\n+   *\n+   * @param documentFactory <code>DocumentFactory</code> used to create DOM4J objects\n+   */\n+  public void setDocumentFactory(DocumentFactory documentFactory) {\n+    this.factory = documentFactory;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return the <code>ErrorHandler</code> used by SAX\n+   */\n+  public ErrorHandler getErrorHandler() {\n+    return errorHandler;\n+  }\n+\n+  /**\n+   * Sets the <code>ErrorHandler</code> used by the SAX\n+   * <code>XMLReader</code>.\n+   *\n+   * @param errorHandler is the <code>ErrorHandler</code> used by SAX\n+   */\n+  public void setErrorHandler(ErrorHandler errorHandler) {\n+    this.errorHandler = errorHandler;\n+  }\n+\n+  /**\n+   * Returns the current entity resolver used to resolve entities\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public EntityResolver getEntityResolver() {\n+    return entityResolver;\n+  }\n+\n+  /**\n+   * Sets the entity resolver used to resolve entities.\n+   *\n+   * @param entityResolver DOCUMENT ME!\n+   */\n+  public void setEntityResolver(EntityResolver entityResolver) {\n+    this.entityResolver = entityResolver;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return the <code>XMLReader</code> used to parse SAX events\n+   * @throws SAXException DOCUMENT ME!\n+   */\n+  public XMLReader getXMLReader() throws SAXException {\n+    if (xmlReader == null) {\n+      xmlReader = createXMLReader();\n+    }\n+\n+    return xmlReader;\n+  }\n+\n+  /**\n+   * Sets the <code>XMLReader</code> used to parse SAX events\n+   *\n+   * @param reader is the <code>XMLReader</code> to parse SAX events\n+   */\n+  public void setXMLReader(XMLReader reader) {\n+    this.xmlReader = reader;\n+  }\n+\n+  /**\n+   * Returns encoding used for InputSource (null means system default\n+   * encoding)\n+   *\n+   * @return encoding used for InputSource\n+   */\n+  public String getEncoding() {\n+    return encoding;\n+  }\n+\n+  /**\n+   * Sets encoding used for InputSource (null means system default encoding)\n+   *\n+   * @param encoding is encoding used for InputSource\n+   */\n+  public void setEncoding(String encoding) {\n+    this.encoding = encoding;\n+  }\n+\n+  /**\n+   * Sets the class name of the <code>XMLReader</code> to be used to parse\n+   * SAX events.\n+   *\n+   * @param xmlReaderClassName is the class name of the <code>XMLReader</code> to parse SAX\n+   *                           events\n+   * @throws SAXException DOCUMENT ME!\n+   */\n+  public void setXMLReaderClassName(String xmlReaderClassName)\n+          throws SAXException {\n+    setXMLReader(XMLReaderFactory.createXMLReader(xmlReaderClassName));\n+  }\n+\n+  /**\n+   * Adds the <code>ElementHandler</code> to be called when the specified\n+   * path is encounted.\n+   *\n+   * @param path    is the path to be handled\n+   * @param handler is the <code>ElementHandler</code> to be called by the event\n+   *                based processor.\n+   */\n+  public void addHandler(String path, ElementHandler handler) {\n+    getDispatchHandler().addHandler(path, handler);\n+  }\n+\n+  /**\n+   * Removes the <code>ElementHandler</code> from the event based processor,\n+   * for the specified path.\n+   *\n+   * @param path is the path to remove the <code>ElementHandler</code> for.\n+   */\n+  public void removeHandler(String path) {\n+    getDispatchHandler().removeHandler(path);\n+  }\n+\n+  /**\n+   * When multiple <code>ElementHandler</code> instances have been\n+   * registered, this will set a default <code>ElementHandler</code> to be\n+   * called for any path which does <b>NOT </b> have a handler registered.\n+   *\n+   * @param handler is the <code>ElementHandler</code> to be called by the event\n+   *                based processor.\n+   */\n+  public void setDefaultHandler(ElementHandler handler) {\n+    getDispatchHandler().setDefaultHandler(handler);\n+  }\n+\n+  /**\n+   * This method clears out all the existing handlers and default handler\n+   * setting things back as if no handler existed. Useful when reusing an\n+   * object instance.\n+   */\n+  public void resetHandlers() {\n+    getDispatchHandler().resetHandlers();\n+  }\n+\n+  /**\n+   * Returns the SAX filter being used to filter SAX events.\n+   *\n+   * @return the SAX filter being used or null if no SAX filter is installed\n+   */\n+  public XMLFilter getXMLFilter() {\n+    return xmlFilter;\n+  }\n+\n+  /**\n+   * Sets the SAX filter to be used when filtering SAX events\n+   *\n+   * @param filter is the SAX filter to use or null to disable filtering\n+   */\n+  public void setXMLFilter(XMLFilter filter) {\n+    this.xmlFilter = filter;\n+  }\n+\n+  // Implementation methods\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Installs any XMLFilter objects required to allow the SAX event stream to\n+   * be filtered and preprocessed before it gets to dom4j.\n+   *\n+   * @param reader DOCUMENT ME!\n+   * @return the new XMLFilter if applicable or the original XMLReader if no\n+   * filter is being used.\n+   */\n+  protected XMLReader installXMLFilter(XMLReader reader) {\n+    XMLFilter filter = getXMLFilter();\n+\n+    if (filter != null) {\n+      // find the root XMLFilter\n+      XMLFilter root = filter;\n+\n+      while (true) {\n+        XMLReader parent = root.getParent();\n+\n+        if (parent instanceof XMLFilter) {\n+          root = (XMLFilter) parent;\n+        } else {\n+          break;\n         }\n+      }\n+\n+      root.setParent(reader);\n+\n+      return filter;\n     }\n \n-    /**\n-     * <p>\n-     * Reads a Document from the given <code>URL</code> using SAX\n-     * </p>\n-     * \n-     * @param url\n-     *            <code>URL</code> to read from.\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(URL url) throws DocumentException {\n-        String systemID = url.toExternalForm();\n-\n-        InputSource source = new InputSource(systemID);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n+    return reader;\n+  }\n \n-        return read(source);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given URL or filename using SAX.\n-     * </p>\n-     * \n-     * <p>\n-     * If the systemId contains a <code>':'</code> character then it is\n-     * assumed to be a URL otherwise its assumed to be a file name. If you want\n-     * finer grained control over this mechansim then please explicitly pass in\n-     * either a {@link URL}or a {@link File}instance instead of a {@link\n-     * String} to denote the source of the document.\n-     * </p>\n-     * \n-     * @param systemId\n-     *            is a URL for a document or a file name.\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(String systemId) throws DocumentException {\n-        InputSource source = new InputSource(systemId);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n-\n-        return read(source);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given stream using SAX\n-     * </p>\n-     * \n-     * @param in\n-     *            <code>InputStream</code> to read from.\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(InputStream in) throws DocumentException {\n-        InputSource source = new InputSource(in);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n-\n-        return read(source);\n-    }\n-\n-    /**\n-     * Reads a Document from the given <code>Reader</code> using SAX\n-     *\n-     * @param reader\n-     *            is the reader for the input\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(Reader reader) throws DocumentException {\n-        InputSource source = new InputSource(reader);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n-\n-        return read(source);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given stream using SAX\n-     * </p>\n-     * \n-     * @param in\n-     *            <code>InputStream</code> to read from.\n-     * @param systemId\n-     *            is the URI for the input\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(InputStream in, String systemId)\n-            throws DocumentException {\n-        InputSource source = new InputSource(in);\n-        source.setSystemId(systemId);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n-\n-        return read(source);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given <code>Reader</code> using SAX\n-     * </p>\n-     * \n-     * @param reader\n-     *            is the reader for the input\n-     * @param systemId\n-     *            is the URI for the input\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(Reader reader, String systemId)\n-            throws DocumentException {\n-        InputSource source = new InputSource(reader);\n-        source.setSystemId(systemId);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n-\n-        return read(source);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given <code>InputSource</code> using SAX\n-     * </p>\n-     * \n-     * @param in\n-     *            <code>InputSource</code> to read from.\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(InputSource in) throws DocumentException {\n-        try {\n-            XMLReader reader = getXMLReader();\n-\n-            reader = installXMLFilter(reader);\n-\n-            EntityResolver thatEntityResolver = this.entityResolver;\n-\n-            if (thatEntityResolver == null) {\n-                thatEntityResolver = createDefaultEntityResolver(in\n-                        .getSystemId());\n-                this.entityResolver = thatEntityResolver;\n-            }\n-\n-            reader.setEntityResolver(thatEntityResolver);\n-\n-            SAXContentHandler contentHandler = createContentHandler(reader);\n-            contentHandler.setEntityResolver(thatEntityResolver);\n-            contentHandler.setInputSource(in);\n-\n-            boolean internal = isIncludeInternalDTDDeclarations();\n-            boolean external = isIncludeExternalDTDDeclarations();\n-\n-            contentHandler.setIncludeInternalDTDDeclarations(internal);\n-            contentHandler.setIncludeExternalDTDDeclarations(external);\n-            contentHandler.setMergeAdjacentText(isMergeAdjacentText());\n-            contentHandler.setStripWhitespaceText(isStripWhitespaceText());\n-            contentHandler.setIgnoreComments(isIgnoreComments());\n-            reader.setContentHandler(contentHandler);\n-\n-            configureReader(reader, contentHandler);\n-\n-            reader.parse(in);\n-\n-            return contentHandler.getDocument();\n-        } catch (Exception e) {\n-            if (e instanceof SAXParseException) {\n-                // e.printStackTrace();\n-                SAXParseException parseException = (SAXParseException) e;\n-                String systemId = parseException.getSystemId();\n-\n-                if (systemId == null) {\n-                    systemId = \"\";\n-                }\n-\n-                String message = \"Error on line \"\n-                        + parseException.getLineNumber() + \" of document \"\n-                        + systemId + \" : \" + parseException.getMessage();\n-\n-                throw new DocumentException(message, e);\n-            } else {\n-                throw new DocumentException(e.getMessage(), e);\n-            }\n+  protected DispatchHandler getDispatchHandler() {\n+    if (dispatchHandler == null) {\n+      dispatchHandler = new DispatchHandler();\n+    }\n+\n+    return dispatchHandler;\n+  }\n+\n+  protected void setDispatchHandler(DispatchHandler dispatchHandler) {\n+    this.dispatchHandler = dispatchHandler;\n+  }\n+\n+  /**\n+   * Factory Method to allow alternate methods of creating and configuring\n+   * XMLReader objects\n+   *\n+   * @return DOCUMENT ME!\n+   * @throws SAXException DOCUMENT ME!\n+   */\n+  protected XMLReader createXMLReader() throws SAXException {\n+    return SAXHelper.createXMLReader(isValidating());\n+  }\n+\n+  /**\n+   * Configures the XMLReader before use\n+   *\n+   * @param reader  DOCUMENT ME!\n+   * @param handler DOCUMENT ME!\n+   * @throws DocumentException DOCUMENT ME!\n+   */\n+  protected void configureReader(XMLReader reader, DefaultHandler handler)\n+          throws DocumentException {\n+    // configure lexical handling\n+    SAXHelper.setParserProperty(reader, SAX_LEXICALHANDLER, handler);\n+\n+    // try alternate property just in case\n+    SAXHelper.setParserProperty(reader, SAX_LEXICAL_HANDLER, handler);\n+\n+    // register the DeclHandler\n+    if (includeInternalDTDDeclarations || includeExternalDTDDeclarations) {\n+      SAXHelper.setParserProperty(reader, SAX_DECL_HANDLER, handler);\n+    }\n+\n+    // string interning\n+    SAXHelper.setParserFeature(reader, SAX_STRING_INTERNING,\n+            isStringInternEnabled());\n+\n+    try {\n+      // configure validation support\n+      reader.setFeature(\"http://xml.org/sax/features/validation\",\n+              isValidating());\n+\n+      if (errorHandler != null) {\n+        reader.setErrorHandler(errorHandler);\n+      } else {\n+        reader.setErrorHandler(handler);\n+      }\n+    } catch (Exception e) {\n+      if (isValidating()) {\n+        throw new DocumentException(\"Validation not supported for\"\n+                + \" XMLReader: \" + reader, e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Factory Method to allow user derived SAXContentHandler objects to be used\n+   *\n+   * @param reader DOCUMENT ME!\n+   * @return DOCUMENT ME!\n+   */\n+  protected SAXContentHandler createContentHandler(XMLReader reader) {\n+    return new SAXContentHandler(getDocumentFactory(), dispatchHandler);\n+  }\n+\n+  protected EntityResolver createDefaultEntityResolver(String systemId) {\n+    String prefix = null;\n+\n+    if ((systemId != null) && (systemId.length() > 0)) {\n+      int idx = systemId.lastIndexOf('/');\n+\n+      if (idx > 0) {\n+        prefix = systemId.substring(0, idx + 1);\n+      }\n+    }\n+\n+    return new SAXEntityResolver(prefix);\n+  }\n+\n+  protected static class SAXEntityResolver implements EntityResolver,\n+          Serializable {\n+    protected String uriPrefix;\n+\n+    public SAXEntityResolver(String uriPrefix) {\n+      this.uriPrefix = uriPrefix;\n+    }\n+\n+    public InputSource resolveEntity(String publicId, String systemId) {\n+      // try create a relative URI reader...\n+      if ((systemId != null) && (systemId.length() > 0)) {\n+        if ((uriPrefix != null) && (systemId.indexOf(':') <= 0)) {\n+          systemId = uriPrefix + systemId;\n         }\n-    }\n-\n-    // Properties\n-    // -------------------------------------------------------------------------\n-\n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return the validation mode, true if validating will be done otherwise\n-     *         false.\n-     */\n-    public boolean isValidating() {\n-        return validating;\n-    }\n-\n-    /**\n-     * Sets the validation mode.\n-     * \n-     * @param validation\n-     *            indicates whether or not validation should occur.\n-     */\n-    public void setValidation(boolean validation) {\n-        this.validating = validation;\n-    }\n+      }\n \n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return whether internal DTD declarations should be expanded into the\n-     *         DocumentType object or not.\n-     */\n-    public boolean isIncludeInternalDTDDeclarations() {\n-        return includeInternalDTDDeclarations;\n-    }\n-\n-    /**\n-     * Sets whether internal DTD declarations should be expanded into the\n-     * DocumentType object or not.\n-     * \n-     * @param include\n-     *            whether or not DTD declarations should be expanded and\n-     *            included into the DocumentType object.\n-     */\n-    public void setIncludeInternalDTDDeclarations(boolean include) {\n-        this.includeInternalDTDDeclarations = include;\n-    }\n-\n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return whether external DTD declarations should be expanded into the\n-     *         DocumentType object or not.\n-     */\n-    public boolean isIncludeExternalDTDDeclarations() {\n-        return includeExternalDTDDeclarations;\n-    }\n-\n-    /**\n-     * Sets whether DTD external declarations should be expanded into the\n-     * DocumentType object or not.\n-     * \n-     * @param include\n-     *            whether or not DTD declarations should be expanded and\n-     *            included into the DocumentType object.\n-     */\n-    public void setIncludeExternalDTDDeclarations(boolean include) {\n-        this.includeExternalDTDDeclarations = include;\n-    }\n-\n-    /**\n-     * Sets whether String interning is enabled or disabled for element &amp;\n-     * attribute names and namespace URIs. This proprety is enabled by default.\n-     * \n-     * @return DOCUMENT ME!\n-     */\n-    public boolean isStringInternEnabled() {\n-        return stringInternEnabled;\n-    }\n-\n-    /**\n-     * Sets whether String interning is enabled or disabled for element &amp;\n-     * attribute names and namespace URIs\n-     * \n-     * @param stringInternEnabled\n-     *            DOCUMENT ME!\n-     */\n-    public void setStringInternEnabled(boolean stringInternEnabled) {\n-        this.stringInternEnabled = stringInternEnabled;\n-    }\n-\n-    /**\n-     * Returns whether adjacent text nodes should be merged together.\n-     * \n-     * @return Value of property mergeAdjacentText.\n-     */\n-    public boolean isMergeAdjacentText() {\n-        return mergeAdjacentText;\n-    }\n-\n-    /**\n-     * Sets whether or not adjacent text nodes should be merged together when\n-     * parsing.\n-     * \n-     * @param mergeAdjacentText\n-     *            New value of property mergeAdjacentText.\n-     */\n-    public void setMergeAdjacentText(boolean mergeAdjacentText) {\n-        this.mergeAdjacentText = mergeAdjacentText;\n-    }\n-\n-    /**\n-     * Sets whether whitespace between element start and end tags should be\n-     * ignored\n-     * \n-     * @return Value of property stripWhitespaceText.\n-     */\n-    public boolean isStripWhitespaceText() {\n-        return stripWhitespaceText;\n-    }\n-\n-    /**\n-     * Sets whether whitespace between element start and end tags should be\n-     * ignored.\n-     * \n-     * @param stripWhitespaceText\n-     *            New value of property stripWhitespaceText.\n-     */\n-    public void setStripWhitespaceText(boolean stripWhitespaceText) {\n-        this.stripWhitespaceText = stripWhitespaceText;\n-    }\n-\n-    /**\n-     * Returns whether we should ignore comments or not.\n-     * \n-     * @return boolean\n-     */\n-    public boolean isIgnoreComments() {\n-        return ignoreComments;\n-    }\n-\n-    /**\n-     * Sets whether we should ignore comments or not.\n-     * \n-     * @param ignoreComments\n-     *            whether we should ignore comments or not.\n-     */\n-    public void setIgnoreComments(boolean ignoreComments) {\n-        this.ignoreComments = ignoreComments;\n-    }\n-\n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return the <code>DocumentFactory</code> used to create document\n-     *         objects\n-     */\n-    public DocumentFactory getDocumentFactory() {\n-        if (factory == null) {\n-            factory = DocumentFactory.getInstance();\n-        }\n-\n-        return factory;\n-    }\n-\n-    /**\n-     * <p>\n-     * This sets the <code>DocumentFactory</code> used to create new\n-     * documents. This method allows the building of custom DOM4J tree objects\n-     * to be implemented easily using a custom derivation of\n-     * {@link DocumentFactory}\n-     * </p>\n-     * \n-     * @param documentFactory\n-     *            <code>DocumentFactory</code> used to create DOM4J objects\n-     */\n-    public void setDocumentFactory(DocumentFactory documentFactory) {\n-        this.factory = documentFactory;\n-    }\n-\n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return the <code>ErrorHandler</code> used by SAX\n-     */\n-    public ErrorHandler getErrorHandler() {\n-        return errorHandler;\n-    }\n-\n-    /**\n-     * Sets the <code>ErrorHandler</code> used by the SAX\n-     * <code>XMLReader</code>.\n-     * \n-     * @param errorHandler\n-     *            is the <code>ErrorHandler</code> used by SAX\n-     */\n-    public void setErrorHandler(ErrorHandler errorHandler) {\n-        this.errorHandler = errorHandler;\n-    }\n-\n-    /**\n-     * Returns the current entity resolver used to resolve entities\n-     * \n-     * @return DOCUMENT ME!\n-     */\n-    public EntityResolver getEntityResolver() {\n-        return entityResolver;\n-    }\n-\n-    /**\n-     * Sets the entity resolver used to resolve entities.\n-     * \n-     * @param entityResolver\n-     *            DOCUMENT ME!\n-     */\n-    public void setEntityResolver(EntityResolver entityResolver) {\n-        this.entityResolver = entityResolver;\n-    }\n-\n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return the <code>XMLReader</code> used to parse SAX events\n-     * \n-     * @throws SAXException\n-     *             DOCUMENT ME!\n-     */\n-    public XMLReader getXMLReader() throws SAXException {\n-        if (xmlReader == null) {\n-            xmlReader = createXMLReader();\n-        }\n-\n-        return xmlReader;\n-    }\n-\n-    /**\n-     * Sets the <code>XMLReader</code> used to parse SAX events\n-     * \n-     * @param reader\n-     *            is the <code>XMLReader</code> to parse SAX events\n-     */\n-    public void setXMLReader(XMLReader reader) {\n-        this.xmlReader = reader;\n-    }\n-\n-    /**\n-     * Returns encoding used for InputSource (null means system default\n-     * encoding)\n-     * \n-     * @return encoding used for InputSource\n-     * \n-     */\n-    public String getEncoding() {\n-        return encoding;\n-    }\n-\n-    /**\n-     * Sets encoding used for InputSource (null means system default encoding)\n-     * \n-     * @param encoding\n-     *            is encoding used for InputSource\n-     */\n-    public void setEncoding(String encoding) {\n-        this.encoding = encoding;\n-    }\n-\n-    /**\n-     * Sets the class name of the <code>XMLReader</code> to be used to parse\n-     * SAX events.\n-     * \n-     * @param xmlReaderClassName\n-     *            is the class name of the <code>XMLReader</code> to parse SAX\n-     *            events\n-     * \n-     * @throws SAXException\n-     *             DOCUMENT ME!\n-     */\n-    public void setXMLReaderClassName(String xmlReaderClassName)\n-            throws SAXException {\n-        setXMLReader(XMLReaderFactory.createXMLReader(xmlReaderClassName));\n-    }\n-\n-    /**\n-     * Adds the <code>ElementHandler</code> to be called when the specified\n-     * path is encounted.\n-     * \n-     * @param path\n-     *            is the path to be handled\n-     * @param handler\n-     *            is the <code>ElementHandler</code> to be called by the event\n-     *            based processor.\n-     */\n-    public void addHandler(String path, ElementHandler handler) {\n-        getDispatchHandler().addHandler(path, handler);\n-    }\n-\n-    /**\n-     * Removes the <code>ElementHandler</code> from the event based processor,\n-     * for the specified path.\n-     * \n-     * @param path\n-     *            is the path to remove the <code>ElementHandler</code> for.\n-     */\n-    public void removeHandler(String path) {\n-        getDispatchHandler().removeHandler(path);\n-    }\n-\n-    /**\n-     * When multiple <code>ElementHandler</code> instances have been\n-     * registered, this will set a default <code>ElementHandler</code> to be\n-     * called for any path which does <b>NOT </b> have a handler registered.\n-     * \n-     * @param handler\n-     *            is the <code>ElementHandler</code> to be called by the event\n-     *            based processor.\n-     */\n-    public void setDefaultHandler(ElementHandler handler) {\n-        getDispatchHandler().setDefaultHandler(handler);\n-    }\n-\n-    /**\n-     * This method clears out all the existing handlers and default handler\n-     * setting things back as if no handler existed. Useful when reusing an\n-     * object instance.\n-     */\n-    public void resetHandlers() {\n-        getDispatchHandler().resetHandlers();\n-    }\n-\n-    /**\n-     * Returns the SAX filter being used to filter SAX events.\n-     * \n-     * @return the SAX filter being used or null if no SAX filter is installed\n-     */\n-    public XMLFilter getXMLFilter() {\n-        return xmlFilter;\n-    }\n-\n-    /**\n-     * Sets the SAX filter to be used when filtering SAX events\n-     * \n-     * @param filter\n-     *            is the SAX filter to use or null to disable filtering\n-     */\n-    public void setXMLFilter(XMLFilter filter) {\n-        this.xmlFilter = filter;\n-    }\n-\n-    // Implementation methods\n-    // -------------------------------------------------------------------------\n-\n-    /**\n-     * Installs any XMLFilter objects required to allow the SAX event stream to\n-     * be filtered and preprocessed before it gets to dom4j.\n-     * \n-     * @param reader\n-     *            DOCUMENT ME!\n-     * \n-     * @return the new XMLFilter if applicable or the original XMLReader if no\n-     *         filter is being used.\n-     */\n-    protected XMLReader installXMLFilter(XMLReader reader) {\n-        XMLFilter filter = getXMLFilter();\n-\n-        if (filter != null) {\n-            // find the root XMLFilter\n-            XMLFilter root = filter;\n-\n-            while (true) {\n-                XMLReader parent = root.getParent();\n-\n-                if (parent instanceof XMLFilter) {\n-                    root = (XMLFilter) parent;\n-                } else {\n-                    break;\n-                }\n-            }\n-\n-            root.setParent(reader);\n-\n-            return filter;\n-        }\n-\n-        return reader;\n-    }\n-\n-    protected DispatchHandler getDispatchHandler() {\n-        if (dispatchHandler == null) {\n-            dispatchHandler = new DispatchHandler();\n-        }\n-\n-        return dispatchHandler;\n-    }\n-\n-    protected void setDispatchHandler(DispatchHandler dispatchHandler) {\n-        this.dispatchHandler = dispatchHandler;\n-    }\n-\n-    /**\n-     * Factory Method to allow alternate methods of creating and configuring\n-     * XMLReader objects\n-     * \n-     * @return DOCUMENT ME!\n-     * \n-     * @throws SAXException\n-     *             DOCUMENT ME!\n-     */\n-    protected XMLReader createXMLReader() throws SAXException {\n-        return SAXHelper.createXMLReader(isValidating());\n-    }\n-\n-    /**\n-     * Configures the XMLReader before use\n-     * \n-     * @param reader\n-     *            DOCUMENT ME!\n-     * @param handler\n-     *            DOCUMENT ME!\n-     * \n-     * @throws DocumentException\n-     *             DOCUMENT ME!\n-     */\n-    protected void configureReader(XMLReader reader, DefaultHandler handler)\n-            throws DocumentException {\n-        // configure lexical handling\n-        SAXHelper.setParserProperty(reader, SAX_LEXICALHANDLER, handler);\n-\n-        // try alternate property just in case\n-        SAXHelper.setParserProperty(reader, SAX_LEXICAL_HANDLER, handler);\n-\n-        // register the DeclHandler\n-        if (includeInternalDTDDeclarations || includeExternalDTDDeclarations) {\n-            SAXHelper.setParserProperty(reader, SAX_DECL_HANDLER, handler);\n-        }\n-\n-        // string interning\n-        SAXHelper.setParserFeature(reader, SAX_STRING_INTERNING,\n-                isStringInternEnabled());\n-\n-        try {\n-            // configure validation support\n-            reader.setFeature(\"http://xml.org/sax/features/validation\",\n-                    isValidating());\n-\n-            if (errorHandler != null) {\n-                reader.setErrorHandler(errorHandler);\n-            } else {\n-                reader.setErrorHandler(handler);\n-            }\n-        } catch (Exception e) {\n-            if (isValidating()) {\n-                throw new DocumentException(\"Validation not supported for\"\n-                        + \" XMLReader: \" + reader, e);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Factory Method to allow user derived SAXContentHandler objects to be used\n-     * \n-     * @param reader\n-     *            DOCUMENT ME!\n-     * \n-     * @return DOCUMENT ME!\n-     */\n-    protected SAXContentHandler createContentHandler(XMLReader reader) {\n-        return new SAXContentHandler(getDocumentFactory(), dispatchHandler);\n-    }\n-\n-    protected EntityResolver createDefaultEntityResolver(String systemId) {\n-        String prefix = null;\n-\n-        if ((systemId != null) && (systemId.length() > 0)) {\n-            int idx = systemId.lastIndexOf('/');\n-\n-            if (idx > 0) {\n-                prefix = systemId.substring(0, idx + 1);\n-            }\n-        }\n-\n-        return new SAXEntityResolver(prefix);\n-    }\n-\n-    protected static class SAXEntityResolver implements EntityResolver,\n-            Serializable {\n-        protected String uriPrefix;\n-\n-        public SAXEntityResolver(String uriPrefix) {\n-            this.uriPrefix = uriPrefix;\n-        }\n-\n-        public InputSource resolveEntity(String publicId, String systemId) {\n-            // try create a relative URI reader...\n-            if ((systemId != null) && (systemId.length() > 0)) {\n-                if ((uriPrefix != null) && (systemId.indexOf(':') <= 0)) {\n-                    systemId = uriPrefix + systemId;\n-                }\n-            }\n-\n-            return new InputSource(systemId);\n-        }\n+      return new InputSource(systemId);\n     }\n+  }\n }\n \n /*\n  * Redistribution and use of this software and associated documentation\n  * (\"Software\"), with or without modification, are permitted provided that the\n  * following conditions are met:\n- * \n+ *\n  * 1. Redistributions of source code must retain copyright statements and\n  * notices. Redistributions must also contain a copy of this document.\n- * \n+ *\n  * 2. Redistributions in binary form must reproduce the above copyright notice,\n  * this list of conditions and the following disclaimer in the documentation\n  * and/or other materials provided with the distribution.\n- * \n+ *\n  * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n  * from this Software without prior written permission of MetaStuff, Ltd. For\n  * written permission, please contact dom4j-info@metastuff.com.\n- * \n+ *\n  * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n  * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n  * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n- * \n+ *\n  * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n- * \n+ *\n  * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n  * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n@@ -1000,6 +1016,6 @@ public InputSource resolveEntity(String publicId, String systemId) {\n  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n  * POSSIBILITY OF SUCH DAMAGE.\n- * \n+ *\n  * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n  */"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 6
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "41b079a88790b8d5694aa6c9c738dd624a0a667b",
            "date": "2023-01-22T21:20:31Z",
            "author_login": "FilipJirsak"
          },
          {
            "sha": "8db3742e13860c6767971867458073e8dd0fa1d1",
            "date": "2023-01-22T20:55:45Z",
            "author_login": "FilipJirsak"
          },
          {
            "sha": "acfb939aefeb1ed64bcc351ac82836a86a08ff52",
            "date": "2023-01-22T20:17:53Z",
            "author_login": "FilipJirsak"
          },
          {
            "sha": "cd4bcda705d65c3b9f639a912692c2baf19d8829",
            "date": "2020-07-27T09:14:09Z",
            "author_login": "tisoft"
          },
          {
            "sha": "4d38f754c8d3a732b3618881dbc270f0d7e26475",
            "date": "2023-01-22T20:13:28Z",
            "author_login": "FilipJirsak"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-611",
    "description": "dom4j before 2.0.3 and 2.1.x before 2.1.3 allows external DTDs and External Entities by default, which might enable XXE attacks. However, there is popular external documentation from OWASP showing how to enable the safe, non-default behavior in any application that uses dom4j.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-05-01T19:15:12.927",
    "last_modified": "2024-11-21T04:55:50.587",
    "fix_date": "2020-04-11T17:06:44Z"
  },
  "references": [
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2020-05/msg00061.html",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1694235",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/dom4j/dom4j/commit/a8228522a99a02146106672a34c104adbda5c658",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/dom4j/dom4j/commits/version-2.0.3",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/dom4j/dom4j/issues/87",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/dom4j/dom4j/releases/tag/version-2.1.3",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.apache.org/thread.html/r51f3f9801058e47153c0ad9bc6209d57a592fc0e7aefd787760911b8%40%3Cdev.velocity.apache.org%3E",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.apache.org/thread.html/r91c64cd51e68e97d524395474eaa25362d564572276b9917fcbf5c32%40%3Cdev.velocity.apache.org%3E",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.apache.org/thread.html/rb1b990d7920ae0d50da5109b73b92bab736d46c9788dd4b135cb1a51%40%3Cnotifications.freemarker.apache.org%3E",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20200518-0002/",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://usn.ubuntu.com/4575-1/",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.oracle.com//security-alerts/cpujul2021.html",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpuApr2021.html",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpujan2021.html",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpujan2022.html",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpujul2020.html",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpujul2022.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpuoct2020.html",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpuoct2021.html",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2020-05/msg00061.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1694235",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/dom4j/dom4j/commit/a8228522a99a02146106672a34c104adbda5c658",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/dom4j/dom4j/commits/version-2.0.3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/dom4j/dom4j/issues/87",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/dom4j/dom4j/releases/tag/version-2.1.3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.apache.org/thread.html/r51f3f9801058e47153c0ad9bc6209d57a592fc0e7aefd787760911b8%40%3Cdev.velocity.apache.org%3E",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.apache.org/thread.html/r91c64cd51e68e97d524395474eaa25362d564572276b9917fcbf5c32%40%3Cdev.velocity.apache.org%3E",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.apache.org/thread.html/rb1b990d7920ae0d50da5109b73b92bab736d46c9788dd4b135cb1a51%40%3Cnotifications.freemarker.apache.org%3E",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20200518-0002/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://usn.ubuntu.com/4575-1/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.oracle.com//security-alerts/cpujul2021.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpuApr2021.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpujan2021.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpujan2022.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpujul2020.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpujul2022.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpuoct2020.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpuoct2021.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:44.969436",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "dom4j",
    "owner": "dom4j",
    "created_at": "2015-07-02T09:23:15Z",
    "updated_at": "2025-01-13T04:35:03Z",
    "pushed_at": "2024-02-01T11:11:56Z",
    "size": 35528,
    "stars": 919,
    "forks": 240,
    "open_issues": 85,
    "watchers": 919,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Java": 2079942,
      "HTML": 44617,
      "XSLT": 6304
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T18:30:31.807112"
  }
}