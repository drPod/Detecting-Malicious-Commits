{
  "cve_id": "CVE-2020-11020",
  "github_data": {
    "repository": "faye/faye",
    "fix_commit": "65d297d341b607f3cb0b5fa6021a625a991cc30e",
    "related_commits": [
      "65d297d341b607f3cb0b5fa6021a625a991cc30e",
      "65d297d341b607f3cb0b5fa6021a625a991cc30e"
    ],
    "patch_url": "https://github.com/faye/faye/commit/65d297d341b607f3cb0b5fa6021a625a991cc30e.patch",
    "fix_commit_details": {
      "sha": "65d297d341b607f3cb0b5fa6021a625a991cc30e",
      "commit_date": "2020-04-25T14:07:48Z",
      "author": {
        "login": "jcoglan",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Strict meta channel recognition in server",
        "length": 1021,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 106,
        "additions": 98,
        "deletions": 8
      },
      "files": [
        {
          "filename": "lib/faye/protocol/server.rb",
          "status": "modified",
          "additions": 12,
          "deletions": 4,
          "patch": "@@ -6,8 +6,6 @@ class Server\n     include Logging\n     include Extensible\n \n-    META_METHODS = %w[handshake connect disconnect subscribe unsubscribe]\n-\n     attr_reader :engine\n \n     def initialize(options = {})\n@@ -107,9 +105,9 @@ def handle(message, local = false, &callback)\n     end\n \n     def handle_meta(message, local, &callback)\n-      method = Channel.parse(message['channel'])[1]\n+      method = method_for(message)\n \n-      unless META_METHODS.include?(method)\n+      unless method\n         response = make_response(message)\n         response['error'] = Faye::Error.channel_forbidden(message['channel'])\n         response['successful'] = false\n@@ -123,6 +121,16 @@ def handle_meta(message, local, &callback)\n       end\n     end\n \n+    def method_for(message)\n+      case message['channel']\n+      when Channel::HANDSHAKE   then :handshake\n+      when Channel::CONNECT     then :connect\n+      when Channel::SUBSCRIBE   then :subscribe\n+      when Channel::UNSUBSCRIBE then :unsubscribe\n+      when Channel::DISCONNECT  then :disconnect\n+      end\n+    end\n+\n     def advize(response, connection_type)\n       return unless [Channel::HANDSHAKE, Channel::CONNECT].include?(response['channel'])\n "
        },
        {
          "filename": "spec/javascript/server/extensions_spec.js",
          "status": "modified",
          "additions": 36,
          "deletions": 0,
          "patch": "@@ -36,6 +36,42 @@ jstest.describe(\"Server extensions\", function() { with(this) {\n     }})\n   }})\n \n+  describe(\"with subscription auth installed\", function() { with(this) {\n+    before(function() { with(this) {\n+      var extension = {\n+        incoming: function(message, callback) {\n+          if (message.channel === \"/meta/subscribe\" && !message.auth) {\n+            message.error = \"Invalid auth\"\n+          }\n+          callback(message)\n+        }\n+      }\n+      server.addExtension(extension)\n+    }})\n+\n+    it(\"does not subscribe using the intended channel\", function() { with(this) {\n+      var message = {\n+        channel: \"/meta/subscribe\",\n+        clientId: \"fakeclientid\",\n+        subscription: \"/foo\"\n+      }\n+      stub(engine, \"clientExists\").yields([true])\n+      expect(engine, \"subscribe\").exactly(0)\n+      server.process(message, false, function() {})\n+    }})\n+\n+    it(\"does not subscribe using an extended channel\", function() { with(this) {\n+      var message = {\n+        channel: \"/meta/subscribe/x\",\n+        clientId: \"fakeclientid\",\n+        subscription: \"/foo\"\n+      }\n+      stub(engine, \"clientExists\").yields([true])\n+      expect(engine, \"subscribe\").exactly(0)\n+      server.process(message, false, function() {})\n+    }})\n+  }})\n+\n   describe(\"with an outgoing extension installed\", function() { with(this) {\n     before(function() { with(this) {\n       var extension = {"
        },
        {
          "filename": "spec/ruby/server/extensions_spec.rb",
          "status": "modified",
          "additions": 36,
          "deletions": 0,
          "patch": "@@ -40,6 +40,42 @@ def incoming(message, callback)\n     end\n   end\n \n+  describe \"with subscription auth installed\" do\n+    before do\n+      extension = Class.new do\n+        def incoming(message, callback)\n+          if message[\"channel\"] == \"/meta/subscribe\" and !message[\"auth\"]\n+            message[\"error\"] = \"Invalid auth\"\n+          end\n+          callback.call(message)\n+        end\n+      end\n+      server.add_extension(extension.new)\n+    end\n+\n+    it \"does not subscribe using the intended channel\" do\n+      message = {\n+        \"channel\" => \"/meta/subscribe\",\n+        \"clientId\" => \"fakeclientid\",\n+        \"subscription\" => \"/foo\"\n+      }\n+      engine.stub(:client_exists).and_yield(true)\n+      engine.should_not_receive(:subscribe)\n+      server.process(message, false) {}\n+    end\n+\n+    it \"does not subscribe using an extended channel\" do\n+      message = {\n+        \"channel\" => \"/meta/subscribe/x\",\n+        \"clientId\" => \"fakeclientid\",\n+        \"subscription\" => \"/foo\"\n+      }\n+      engine.stub(:client_exists).and_yield(true)\n+      engine.should_not_receive(:subscribe)\n+      server.process(message, false) {}\n+    end\n+  end\n+\n   describe \"with an outgoing extension installed\" do\n     before do\n       extension = Class.new do"
        },
        {
          "filename": "src/protocol/server.js",
          "status": "modified",
          "additions": 14,
          "deletions": 4,
          "patch": "@@ -13,8 +13,6 @@ var Class      = require('../util/class'),\n     Socket     = require('./socket');\n \n var Server = Class({ className: 'Server',\n-  META_METHODS: ['handshake', 'connect', 'disconnect', 'subscribe', 'unsubscribe'],\n-\n   initialize: function(options) {\n     this._options  = options || {};\n     var engineOpts = this._options.engine || {};\n@@ -120,10 +118,10 @@ var Server = Class({ className: 'Server',\n   },\n \n   _handleMeta: function(message, local, callback, context) {\n-    var method = Channel.parse(message.channel)[1],\n+    var method = this._methodFor(message),\n         response;\n \n-    if (array.indexOf(this.META_METHODS, method) < 0) {\n+    if (method === null) {\n       response = this._makeResponse(message);\n       response.error = Error.channelForbidden(message.channel);\n       response.successful = false;\n@@ -137,6 +135,18 @@ var Server = Class({ className: 'Server',\n     }, this);\n   },\n \n+  _methodFor: function(message) {\n+    var channel = message.channel;\n+\n+    if (channel === Channel.HANDSHAKE)   return 'handshake';\n+    if (channel === Channel.CONNECT)     return 'connect';\n+    if (channel === Channel.SUBSCRIBE)   return 'subscribe';\n+    if (channel === Channel.UNSUBSCRIBE) return 'unsubscribe';\n+    if (channel === Channel.DISCONNECT)  return 'disconnect';\n+\n+    return null;\n+  },\n+\n   _advize: function(response, connectionType) {\n     if (array.indexOf([Channel.HANDSHAKE, Channel.CONNECT], response.channel) < 0)\n       return;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d842738b5075fd4a1e6d10c7ea727b66f35342ca",
            "date": "2024-06-05T16:10:34Z",
            "author_login": "jcoglan"
          },
          {
            "sha": "60141e8d3942a88ba3de6a9b3aef9503bc1bb1e6",
            "date": "2020-07-31T16:23:05Z",
            "author_login": "jcoglan"
          },
          {
            "sha": "755a1b10cfd1dcbb4d48241874fbd4c81f1df1f4",
            "date": "2020-07-31T16:33:51Z",
            "author_login": "jcoglan"
          },
          {
            "sha": "2de94af9815148d40b786eea27e98783f044add3",
            "date": "2020-07-31T13:17:52Z",
            "author_login": "jcoglan"
          },
          {
            "sha": "66ce1a13a34f3d2f6cf77f683bd9f42991b6f938",
            "date": "2020-07-31T12:47:50Z",
            "author_login": "jcoglan"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:L/A:N",
    "cwe_id": "CWE-287",
    "description": "Faye (NPM, RubyGem) versions greater than 0.5.0 and before 1.0.4, 1.1.3 and 1.2.5, has the potential for authentication bypass in the extension system. The vulnerability allows any client to bypass checks put in place by server-side extensions, by appending extra segments to the message channel. It is patched in versions 1.0.4, 1.1.3 and 1.2.5.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-04-29T18:15:13.360",
    "last_modified": "2024-11-21T04:56:35.843",
    "fix_date": "2020-04-25T14:07:48Z"
  },
  "references": [
    {
      "url": "https://github.com/faye/faye/commit/65d297d341b607f3cb0b5fa6021a625a991cc30e",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/faye/faye/security/advisories/GHSA-qpg4-4w7w-2mq5",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/faye/faye/commit/65d297d341b607f3cb0b5fa6021a625a991cc30e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/faye/faye/security/advisories/GHSA-qpg4-4w7w-2mq5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Mitigation",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:44.962758",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "faye",
    "owner": "faye",
    "created_at": "2009-06-06T10:37:03Z",
    "updated_at": "2025-01-08T04:27:10Z",
    "pushed_at": "2024-07-04T02:47:11Z",
    "size": 3038,
    "stars": 4392,
    "forks": 369,
    "open_issues": 25,
    "watchers": 4392,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "JavaScript": 297588,
      "Ruby": 181619,
      "Haml": 119566,
      "Sass": 3372,
      "Makefile": 872,
      "CSS": 300,
      "HTML": 179
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T16:17:14.053020"
  }
}