{
  "cve_id": "CVE-2020-11091",
  "github_data": {
    "repository": "weaveworks/weave",
    "fix_commit": "15f21f1899060f7716c70a8555a084e836f39a60",
    "related_commits": [
      "15f21f1899060f7716c70a8555a084e836f39a60",
      "15f21f1899060f7716c70a8555a084e836f39a60"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "15f21f1899060f7716c70a8555a084e836f39a60",
      "commit_date": "2020-05-22T10:00:50Z",
      "author": {
        "login": "bboreham",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #3801 from weaveworks/disable-accept-ra",
        "length": 101,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 82,
        "additions": 47,
        "deletions": 35
      },
      "files": [
        {
          "filename": "net/bridge.go",
          "status": "modified",
          "additions": 15,
          "deletions": 11,
          "patch": "@@ -63,10 +63,10 @@ const (\n )\n \n type Bridge interface {\n-\tinit(config *BridgeConfig) error // create and initialise bridge device(s)\n-\tattach(veth *netlink.Veth) error // attach veth to bridge\n-\tIsFastdp() bool                  // does this bridge use fastdp?\n-\tString() string                  // human-readable type string\n+\tinit(procPath string, config *BridgeConfig) error // create and initialise bridge device(s)\n+\tattach(veth *netlink.Veth) error                  // attach veth to bridge\n+\tIsFastdp() bool                                   // does this bridge use fastdp?\n+\tString() string                                   // human-readable type string\n }\n \n // Used to indicate a fallback to the Bridge type\n@@ -250,7 +250,7 @@ func EnsureBridge(procPath string, config *BridgeConfig, log *logrus.Logger, ips\n \t}\n \n \tfor {\n-\t\tif err := bridgeType.init(config); err != nil {\n+\t\tif err := bridgeType.init(procPath, config); err != nil {\n \t\t\tif errors.Cause(err) == errBridgeNotSupported {\n \t\t\t\tlog.Warnf(\"Skipping bridge creation of %q due to: %s\", bridgeType, err)\n \t\t\t\tbridgeType = bridgeImpl{}\n@@ -279,6 +279,10 @@ func EnsureBridge(procPath string, config *BridgeConfig, log *logrus.Logger, ips\n \t\t\treturn bridgeType, errors.Wrap(err, \"setting proxy_arp\")\n \t\t}\n \t}\n+\t// No ipv6 router advertisments please\n+\tif err := sysctl(procPath, \"net/ipv6/conf/\"+config.WeaveBridgeName+\"/accept_ra\", \"0\"); err != nil {\n+\t\treturn bridgeType, errors.Wrap(err, \"setting accept_ra to 0\")\n+\t}\n \n \tif err := linkSetUpByName(config.WeaveBridgeName); err != nil {\n \t\treturn bridgeType, err\n@@ -345,11 +349,11 @@ func (b bridgeImpl) initPrep(config *BridgeConfig) error {\n \treturn nil\n }\n \n-func (b bridgeImpl) init(config *BridgeConfig) error {\n+func (b bridgeImpl) init(procPath string, config *BridgeConfig) error {\n \tif err := b.initPrep(config); err != nil {\n \t\treturn err\n \t}\n-\tif _, err := CreateAndAttachVeth(BridgeIfName, PcapIfName, config.WeaveBridgeName, config.MTU, true, false, func(veth netlink.Link) error {\n+\tif _, err := CreateAndAttachVeth(procPath, BridgeIfName, PcapIfName, config.WeaveBridgeName, config.MTU, true, false, func(veth netlink.Link) error {\n \t\treturn netlink.LinkSetUp(veth)\n \t}); err != nil {\n \t\treturn errors.Wrap(err, \"creating pcap veth pair\")\n@@ -361,7 +365,7 @@ func (b bridgeImpl) init(config *BridgeConfig) error {\n \treturn nil\n }\n \n-func (f fastdpImpl) init(config *BridgeConfig) error {\n+func (f fastdpImpl) init(procPath string, config *BridgeConfig) error {\n \todpSupported, err := odp.CreateDatapath(f.datapathName)\n \tif !odpSupported {\n \t\tmsg := \"\"\n@@ -392,14 +396,14 @@ func (f fastdpImpl) init(config *BridgeConfig) error {\n \treturn nil\n }\n \n-func (bf bridgedFastdpImpl) init(config *BridgeConfig) error {\n-\tif err := bf.fastdpImpl.init(config); err != nil {\n+func (bf bridgedFastdpImpl) init(procPath string, config *BridgeConfig) error {\n+\tif err := bf.fastdpImpl.init(procPath, config); err != nil {\n \t\treturn err\n \t}\n \tif err := bf.bridgeImpl.initPrep(config); err != nil {\n \t\treturn err\n \t}\n-\tif _, err := CreateAndAttachVeth(BridgeIfName, DatapathIfName, config.WeaveBridgeName, config.MTU, true, false, func(veth netlink.Link) error {\n+\tif _, err := CreateAndAttachVeth(procPath, BridgeIfName, DatapathIfName, config.WeaveBridgeName, config.MTU, true, false, func(veth netlink.Link) error {\n \t\tif err := netlink.LinkSetUp(veth); err != nil {\n \t\t\treturn errors.Wrapf(err, \"setting link up on %q\", veth.Attrs().Name)\n \t\t}"
        },
        {
          "filename": "net/netns.go",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -55,9 +55,9 @@ func WithNetNSByPath(path string, work func() error) error {\n }\n \n func NSPathByPid(pid int) string {\n-\treturn NSPathByPidWithRoot(\"/\", pid)\n+\treturn NSPathByPidWithProc(\"/proc\", pid)\n }\n \n-func NSPathByPidWithRoot(root string, pid int) string {\n-\treturn filepath.Join(root, fmt.Sprintf(\"/proc/%d/ns/net\", pid))\n+func NSPathByPidWithProc(procPath string, pid int) string {\n+\treturn filepath.Join(procPath, fmt.Sprint(pid), \"/ns/net\")\n }"
        },
        {
          "filename": "net/veth.go",
          "status": "modified",
          "additions": 17,
          "deletions": 8,
          "patch": "@@ -13,7 +13,7 @@ import (\n )\n \n // create and attach a veth to the Weave bridge\n-func CreateAndAttachVeth(name, peerName, bridgeName string, mtu int, keepTXOn bool, errIfLinkExist bool, init func(peer netlink.Link) error) (*netlink.Veth, error) {\n+func CreateAndAttachVeth(procPath, name, peerName, bridgeName string, mtu int, keepTXOn bool, errIfLinkExist bool, init func(peer netlink.Link) error) (*netlink.Veth, error) {\n \tbridge, err := netlink.LinkByName(bridgeName)\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(`bridge \"%s\" not present; did you launch weave?`, bridgeName)\n@@ -49,6 +49,13 @@ func CreateAndAttachVeth(name, peerName, bridgeName string, mtu int, keepTXOn bo\n \tif err := bridgeType.attach(veth); err != nil {\n \t\treturn cleanup(\"attaching veth %q to %q: %s\", name, bridgeName, err)\n \t}\n+\t// No ipv6 router advertisments please\n+\tif err := sysctl(procPath, \"net/ipv6/conf/\"+name+\"/accept_ra\", \"0\"); err != nil {\n+\t\treturn cleanup(\"setting accept_ra to 0: %s\", err)\n+\t}\n+\tif err := sysctl(procPath, \"net/ipv6/conf/\"+peerName+\"/accept_ra\", \"0\"); err != nil {\n+\t\treturn cleanup(\"setting accept_ra to 0: %s\", err)\n+\t}\n \tif !bridgeType.IsFastdp() && !keepTXOn {\n \t\tif err := EthtoolTXOff(veth.PeerName); err != nil {\n \t\t\treturn cleanup(`unable to set tx off on %q: %s`, peerName, err)\n@@ -112,6 +119,9 @@ func interfaceExistsInNamespace(netNSPath string, ifName string) bool {\n }\n \n func AttachContainer(netNSPath, id, ifName, bridgeName string, mtu int, withMulticastRoute bool, cidrs []*net.IPNet, keepTXOn bool, hairpinMode bool) error {\n+\t// AttachContainer expects to be called in host pid namespace\n+\tconst procPath = \"/proc\"\n+\n \tns, err := netns.GetFromPath(netNSPath)\n \tif err != nil {\n \t\treturn err\n@@ -124,12 +134,12 @@ func AttachContainer(netNSPath, id, ifName, bridgeName string, mtu int, withMult\n \t\t\tid = id[:maxIDLen] // trim passed ID if too long\n \t\t}\n \t\tname, peerName := vethPrefix+\"pl\"+id, vethPrefix+\"pg\"+id\n-\t\tveth, err := CreateAndAttachVeth(name, peerName, bridgeName, mtu, keepTXOn, true, func(veth netlink.Link) error {\n+\t\tveth, err := CreateAndAttachVeth(procPath, name, peerName, bridgeName, mtu, keepTXOn, true, func(veth netlink.Link) error {\n \t\t\tif err := netlink.LinkSetNsFd(veth, int(ns)); err != nil {\n \t\t\t\treturn fmt.Errorf(\"failed to move veth to container netns: %s\", err)\n \t\t\t}\n \t\t\tif err := WithNetNS(ns, func() error {\n-\t\t\t\treturn setupIface(peerName, ifName)\n+\t\t\t\treturn setupIface(procPath, peerName, ifName)\n \t\t\t}); err != nil {\n \t\t\t\treturn fmt.Errorf(\"error setting up interface: %s\", err)\n \t\t\t}\n@@ -206,7 +216,7 @@ func setupIfaceAddrs(veth netlink.Link, withMulticastRoute bool, cidrs []*net.IP\n }\n \n // setupIface expects to be called in the container's netns\n-func setupIface(ifaceName, newIfName string) error {\n+func setupIface(procPath, ifaceName, newIfName string) error {\n \tipt, err := iptables.New()\n \tif err != nil {\n \t\treturn err\n@@ -219,23 +229,22 @@ func setupIface(ifaceName, newIfName string) error {\n \tif err := netlink.LinkSetName(link, newIfName); err != nil {\n \t\treturn err\n \t}\n-\t// This is only called by AttachContainer which is only called in host pid namespace\n-\tif err := configureARPCache(\"/proc\", newIfName); err != nil {\n+\tif err := configureARPCache(procPath, newIfName); err != nil {\n \t\treturn err\n \t}\n \treturn ipt.Append(\"filter\", \"INPUT\", \"-i\", newIfName, \"-d\", \"224.0.0.0/4\", \"-j\", \"DROP\")\n }\n \n // configureARP is a helper for the Docker plugin which doesn't set the addresses itself\n-func ConfigureARP(prefix, rootPath string) error {\n+func ConfigureARP(prefix, procPath string) error {\n \tlinks, err := netlink.LinkList()\n \tif err != nil {\n \t\treturn err\n \t}\n \tfor _, link := range links {\n \t\tifName := link.Attrs().Name\n \t\tif strings.HasPrefix(ifName, prefix) {\n-\t\t\tconfigureARPCache(rootPath+\"/proc\", ifName)\n+\t\t\tconfigureARPCache(procPath, ifName)\n \t\t\tif addrs, err := netlink.AddrList(link, netlink.FAMILY_V4); err == nil {\n \t\t\t\tfor _, addr := range addrs {\n \t\t\t\t\tarping.GratuitousArpOverIfaceByName(addr.IPNet.IP, ifName)"
        },
        {
          "filename": "plugin/net/driver.go",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -39,9 +39,10 @@ type driver struct {\n \t// used only by plugin-v2\n \tforceMulticast bool\n \tnetworks       map[string]network\n+\tprocPath       string\n }\n \n-func New(client *docker.Client, weave *weaveapi.Client, name, scope string, dns, isPluginV2, forceMulticast bool) (skel.Driver, error) {\n+func New(client *docker.Client, weave *weaveapi.Client, name, scope string, dns, isPluginV2, forceMulticast bool, procPath string) (skel.Driver, error) {\n \tdriver := &driver{\n \t\tname:       name,\n \t\tscope:      scope,\n@@ -51,6 +52,7 @@ func New(client *docker.Client, weave *weaveapi.Client, name, scope string, dns,\n \t\t// make sure that it's used only by plugin-v2\n \t\tforceMulticast: isPluginV2 && forceMulticast,\n \t\tnetworks:       make(map[string]network),\n+\t\tprocPath:       procPath,\n \t}\n \n \t// Do not start watcher in the case of plugin v2, which prevents us from\n@@ -134,7 +136,7 @@ func (driver *driver) CreateEndpoint(create *api.CreateEndpointRequest) (*api.Cr\n \n \t// create veths. note we assume endpoint IDs are unique in the first 9 chars\n \tname, peerName := vethPair(create.EndpointID)\n-\tif _, err := weavenet.CreateAndAttachVeth(name, peerName, weavenet.WeaveBridgeName, 0, false, true, nil); err != nil {\n+\tif _, err := weavenet.CreateAndAttachVeth(driver.procPath, name, peerName, weavenet.WeaveBridgeName, 0, false, true, nil); err != nil {\n \t\treturn nil, driver.error(\"JoinEndpoint\", \"%s\", err)\n \t}\n "
        },
        {
          "filename": "plugin/net/watcher.go",
          "status": "modified",
          "additions": 2,
          "deletions": 7,
          "patch": "@@ -43,14 +43,9 @@ func (w *watcher) ContainerStarted(id string) {\n \t\t\t\t\tw.driver.warn(\"ContainerStarted\", \"unable to register %s with weaveDNS: %s\", id, err)\n \t\t\t\t}\n \t\t\t}\n-\t\t\trootDir := \"/\"\n-\t\t\tif w.driver.isPluginV2 {\n-\t\t\t\t// We bind mount host's /proc to /host/proc for plugin-v2\n-\t\t\t\trootDir = \"/host\"\n-\t\t\t}\n-\t\t\tnetNSPath := weavenet.NSPathByPidWithRoot(rootDir, info.State.Pid)\n+\t\t\tnetNSPath := weavenet.NSPathByPidWithProc(w.driver.procPath, info.State.Pid)\n \t\t\tif err := weavenet.WithNetNSByPath(netNSPath, func() error {\n-\t\t\t\treturn weavenet.ConfigureARP(weavenet.VethName, rootDir)\n+\t\t\t\treturn weavenet.ConfigureARP(weavenet.VethName, w.driver.procPath)\n \t\t\t}); err != nil {\n \t\t\t\tw.driver.warn(\"ContainerStarted\", \"unable to configure interfaces: %s\", err)\n \t\t\t}"
        },
        {
          "filename": "plugin/plugin.go",
          "status": "modified",
          "additions": 5,
          "deletions": 4,
          "patch": "@@ -32,6 +32,7 @@ type Config struct {\n \tEnableV2Multicast bool\n \tDNS               bool\n \tDefaultSubnet     string\n+\tProcPath          string // path to reach host /proc filesystem\n }\n \n type Plugin struct {\n@@ -62,15 +63,15 @@ func (plugin *Plugin) run(dockerClient *docker.Client, weave *weaveapi.Client, r\n \tendChan := make(chan error, 1)\n \n \tif plugin.Socket != \"\" {\n-\t\tglobalListener, err := listenAndServe(dockerClient, weave, plugin.Socket, endChan, \"global\", false, plugin.DNS, plugin.EnableV2, plugin.EnableV2Multicast)\n+\t\tglobalListener, err := listenAndServe(dockerClient, weave, plugin.Socket, endChan, \"global\", false, plugin.DNS, plugin.EnableV2, plugin.EnableV2Multicast, plugin.ProcPath)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \t\tdefer os.Remove(plugin.Socket)\n \t\tdefer globalListener.Close()\n \t}\n \tif plugin.MeshSocket != \"\" {\n-\t\tmeshListener, err := listenAndServe(dockerClient, weave, plugin.MeshSocket, endChan, \"local\", true, plugin.DNS, plugin.EnableV2, plugin.EnableV2Multicast)\n+\t\tmeshListener, err := listenAndServe(dockerClient, weave, plugin.MeshSocket, endChan, \"local\", true, plugin.DNS, plugin.EnableV2, plugin.EnableV2Multicast, plugin.ProcPath)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n@@ -87,15 +88,15 @@ func (plugin *Plugin) run(dockerClient *docker.Client, weave *weaveapi.Client, r\n \treturn <-endChan\n }\n \n-func listenAndServe(dockerClient *docker.Client, weave *weaveapi.Client, address string, endChan chan<- error, scope string, withIpam, dns bool, isPluginV2, forceMulticast bool) (net.Listener, error) {\n+func listenAndServe(dockerClient *docker.Client, weave *weaveapi.Client, address string, endChan chan<- error, scope string, withIpam, dns bool, isPluginV2, forceMulticast bool, procPath string) (net.Listener, error) {\n \tvar name string\n \tif isPluginV2 {\n \t\tname = pluginV2Name\n \t} else {\n \t\tname = pluginNameFromAddress(address)\n \t}\n \n-\td, err := netplugin.New(dockerClient, weave, name, scope, dns, isPluginV2, forceMulticast)\n+\td, err := netplugin.New(dockerClient, weave, name, scope, dns, isPluginV2, forceMulticast, procPath)\n \tif err != nil {\n \t\treturn nil, err\n \t}"
        },
        {
          "filename": "prog/weaver/main.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -453,6 +453,7 @@ func main() {\n \n \tpluginConfig.DNS = !noDNS\n \tpluginConfig.DefaultSubnet = defaultSubnet.String()\n+\tpluginConfig.ProcPath = procPath\n \tplugin := plugin.NewPlugin(pluginConfig)\n \n \t// The weave script always waits for a status call to succeed,"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 4,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8c8476381d48820891356497bfcee6337e99a401",
            "date": "2022-11-23T10:40:02Z",
            "author_login": "enekofb"
          },
          {
            "sha": "25ccf44179801358f4c4c8276a39ff3b90c82020",
            "date": "2022-10-07T14:07:16Z",
            "author_login": "enekofb"
          },
          {
            "sha": "d30828a3f2f8e10e95dd0a369e2bace0d627e5ff",
            "date": "2022-10-04T10:13:21Z",
            "author_login": "enekofb"
          },
          {
            "sha": "6d7a29ade6e196e51a800b9df658c8a017f1b38b",
            "date": "2022-06-09T12:25:21Z",
            "author_login": "kingdonb"
          },
          {
            "sha": "1686ded5d52c87c4fa6d89c6522011c205a32013",
            "date": "2022-06-09T11:46:06Z",
            "author_login": "rajch"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:C/C:N/I:H/A:N",
    "cwe_id": "CWE-350",
    "description": "In Weave Net before version 2.6.3, an attacker able to run a process as root in a container is able to respond to DNS requests from the host and thereby insert themselves as a fake service. In a cluster with an IPv4 internal network, if IPv6 is not totally disabled on the host (via ipv6.disable=1 on the kernel cmdline), it will be either unconfigured or configured on some interfaces, but it's pretty likely that ipv6 forwarding is disabled, ie /proc/sys/net/ipv6/conf//forwarding == 0. Also by default, /proc/sys/net/ipv6/conf//accept_ra == 1. The combination of these 2 sysctls means that the host accepts router advertisements and configure the IPv6 stack using them. By sending rogue router advertisements, an attacker can reconfigure the host to redirect part or all of the IPv6 traffic of the host to the attacker controlled container. Even if there was no IPv6 traffic before, if the DNS returns A (IPv4) and AAAA (IPv6) records, many HTTP libraries will try to connect via IPv6 first then fallback to IPv4, giving an opportunity to the attacker to respond. If by chance you also have on the host a vulnerability like last year's RCE in apt (CVE-2019-3462), you can now escalate to the host. Weave Net version 2.6.3 disables the accept_ra option on the veth devices that it creates.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-06-03T23:15:11.167",
    "last_modified": "2024-11-21T04:56:46.143",
    "fix_date": "2020-05-22T10:00:50Z"
  },
  "references": [
    {
      "url": "https://github.com/weaveworks/weave/commit/15f21f1899060f7716c70a8555a084e836f39a60",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/weaveworks/weave/security/advisories/GHSA-59qg-grp7-5r73",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/weaveworks/weave/commit/15f21f1899060f7716c70a8555a084e836f39a60",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/weaveworks/weave/security/advisories/GHSA-59qg-grp7-5r73",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:47.832894",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "weave",
    "owner": "weaveworks",
    "created_at": "2014-08-18T05:19:07Z",
    "updated_at": "2025-01-24T05:50:23Z",
    "pushed_at": "2024-08-09T08:45:55Z",
    "size": 27240,
    "stars": 6625,
    "forks": 673,
    "open_issues": 529,
    "watchers": 6625,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Go": 772745,
      "Shell": 219492,
      "Makefile": 18761,
      "Dockerfile": 4434,
      "Ruby": 1545,
      "Python": 1057
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:50:40.615384"
  }
}