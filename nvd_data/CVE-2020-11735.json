{
  "cve_id": "CVE-2020-11735",
  "github_data": {
    "repository": "wolfSSL/wolfssl",
    "fix_commit": "1de07da61f0c8e9926dcbd68119f73230dae283f",
    "related_commits": [
      "1de07da61f0c8e9926dcbd68119f73230dae283f",
      "1de07da61f0c8e9926dcbd68119f73230dae283f"
    ],
    "patch_url": "https://github.com/wolfSSL/wolfssl/commit/1de07da61f0c8e9926dcbd68119f73230dae283f.patch",
    "fix_commit_details": {
      "sha": "1de07da61f0c8e9926dcbd68119f73230dae283f",
      "commit_date": "2020-03-18T01:05:44Z",
      "author": {
        "login": "SparkiDev",
        "type": "User",
        "stats": {
          "total_commits": 2018,
          "average_weekly_commits": 2.768175582990398,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 356
        }
      },
      "commit_message": {
        "title": "Constant time EC map to affine for private operations",
        "length": 203,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 132,
        "additions": 124,
        "deletions": 8
      },
      "files": [
        {
          "filename": "wolfcrypt/src/ecc.c",
          "status": "modified",
          "additions": 46,
          "deletions": 8,
          "patch": "@@ -2285,9 +2285,10 @@ int ecc_projective_dbl_point(ecc_point *P, ecc_point *R, mp_int* a,\n   P        [in/out] The point to map\n   modulus  The modulus of the field the ECC curve is in\n   mp       The \"b\" value from montgomery_setup()\n+  ct       Operation should be constant time.\n   return   MP_OKAY on success\n */\n-int ecc_map(ecc_point* P, mp_int* modulus, mp_digit mp)\n+int ecc_map_ex(ecc_point* P, mp_int* modulus, mp_digit mp, int ct)\n {\n #ifndef WOLFSSL_SP_MATH\n #ifdef WOLFSSL_SMALL_STACK\n@@ -2307,6 +2308,8 @@ int ecc_map(ecc_point* P, mp_int* modulus, mp_digit mp)\n    mp_int *x, *y, *z;\n    int    err;\n \n+   (void)ct;\n+\n    if (P == NULL || modulus == NULL)\n        return ECC_BAD_ARG_E;\n \n@@ -2402,12 +2405,23 @@ int ecc_map(ecc_point* P, mp_int* modulus, mp_digit mp)\n    z = P->z;\n #endif\n \n-   /* first map z back to normal */\n-   err = mp_montgomery_reduce(z, modulus, mp);\n-\n    /* get 1/z */\n-   if (err == MP_OKAY)\n-       err = mp_invmod(z, modulus, t1);\n+   if (err == MP_OKAY) {\n+#if defined(ECC_TIMING_RESISTANT) && defined(USE_FAST_MATH)\n+       if (ct) {\n+           err = mp_invmod_mont_ct(z, modulus, t1, mp);\n+           if (err == MP_OKAY)\n+               err = mp_montgomery_reduce(t1, modulus, mp);\n+       }\n+       else\n+#endif\n+       {\n+           /* first map z back to normal */\n+           err = mp_montgomery_reduce(z, modulus, mp);\n+           if (err == MP_OKAY)\n+               err = mp_invmod(z, modulus, t1);\n+       }\n+   }\n \n    /* get 1/z^2 and 1/z^3 */\n    if (err == MP_OKAY)\n@@ -2484,6 +2498,10 @@ int ecc_map(ecc_point* P, mp_int* modulus, mp_digit mp)\n #endif\n }\n \n+int ecc_map(ecc_point* P, mp_int* modulus, mp_digit mp)\n+{\n+    return ecc_map_ex(P, modulus, mp, 0);\n+}\n #endif /* !WOLFSSL_SP_MATH || WOLFSSL_PUBLIC_ECC_ADD_DBL */\n \n #if !defined(FREESCALE_LTC_ECC) && !defined(WOLFSSL_STM32_PKA)\n@@ -3639,6 +3657,8 @@ static int wc_ecc_shared_secret_gen_sync(ecc_key* private_key, ecc_point* point,\n     }\n #else\n     {\n+        mp_digit mp = 0;\n+\n         /* make new point */\n         result = wc_ecc_new_point_h(private_key->heap);\n         if (result == NULL) {\n@@ -3649,8 +3669,16 @@ static int wc_ecc_shared_secret_gen_sync(ecc_key* private_key, ecc_point* point,\n             return MEMORY_E;\n         }\n \n-        err = wc_ecc_mulmod_ex(k, point, result, curve->Af, curve->prime, 1,\n+        /* Map in a separate call as this should be constant time */\n+        err = wc_ecc_mulmod_ex(k, point, result, curve->Af, curve->prime, 0,\n                                                              private_key->heap);\n+        if (err == MP_OKAY) {\n+            err = mp_montgomery_setup(curve->prime, &mp);\n+        }\n+        if (err == MP_OKAY) {\n+            /* Use constant time map if compiled in */\n+            err = ecc_map_ex(result, curve->prime, mp, 1);\n+        }\n         if (err == MP_OKAY) {\n             x = mp_unsigned_bin_size(curve->prime);\n             if (*outlen < x || (int)x < mp_unsigned_bin_size(result->x)) {\n@@ -4008,6 +4036,8 @@ static int wc_ecc_make_pub_ex(ecc_key* key, ecc_curve_spec* curveIn,\n         err = WC_KEY_SIZE_E;\n #else\n     {\n+        mp_digit mp;\n+\n         if (err == MP_OKAY) {\n             base = wc_ecc_new_point_h(key->heap);\n             if (base == NULL)\n@@ -4023,12 +4053,20 @@ static int wc_ecc_make_pub_ex(ecc_key* key, ecc_curve_spec* curveIn,\n \n         /* make the public key */\n         if (err == MP_OKAY) {\n+            /* Map in a separate call as this should be constant time */\n             err = wc_ecc_mulmod_ex(&key->k, base, pub, curve->Af, curve->prime,\n-                                                                  1, key->heap);\n+                                                                  0, key->heap);\n             if (err == MP_MEM) {\n                err = MEMORY_E;\n             }\n         }\n+        if (err == MP_OKAY) {\n+            err = mp_montgomery_setup(curve->prime, &mp);\n+        }\n+        if (err == MP_OKAY) {\n+            /* Use constant time map if compiled in */\n+            err = ecc_map_ex(pub, curve->prime, mp, 1);\n+        }\n \n         wc_ecc_del_point_h(base, key->heap);\n     }"
        },
        {
          "filename": "wolfcrypt/src/tfm.c",
          "status": "modified",
          "additions": 75,
          "deletions": 0,
          "patch": "@@ -1160,6 +1160,75 @@ int fp_invmod(fp_int *a, fp_int *b, fp_int *c)\n   return FP_OKAY;\n }\n \n+#define CT_INV_MOD_PRE_CNT      8\n+\n+/* modulus (b) must be greater than 2 and a prime */\n+int fp_invmod_mont_ct(fp_int *a, fp_int *b, fp_int *c, fp_digit mp)\n+{\n+  int i, j;\n+#ifndef WOLFSSL_SMALL_STACK\n+  fp_int t[1], e[1];\n+  fp_int pre[CT_INV_MOD_PRE_CNT];\n+#else\n+  fp_int* t;\n+  fp_int* e;\n+  fp_int* pre;\n+#endif\n+\n+#ifdef WOLFSSL_SMALL_STACK\n+  t = (fp_int*)XMALLOC(sizeof(fp_int) * (2 + CT_INV_MOD_PRE_CNT), NULL,\n+                                                           DYNAMIC_TYPE_BIGINT);\n+  if (t == NULL)\n+    return FP_MEM;\n+  e = t + 1;\n+  pre = t + 2;\n+#endif\n+\n+  fp_init(t);\n+  fp_init(e);\n+\n+  fp_init(&pre[0]);\n+  fp_copy(a, &pre[0]);\n+  for (i = 1; i < CT_INV_MOD_PRE_CNT; i++) {\n+    fp_init(&pre[i]);\n+    fp_sqr(&pre[i-1], &pre[i]);\n+    fp_montgomery_reduce(&pre[i], b, mp);\n+    fp_mul(&pre[i], a, &pre[i]);\n+    fp_montgomery_reduce(&pre[i], b, mp);\n+  }\n+\n+  fp_sub_d(b, 2, e);\n+  /* Highest bit is always set. */\n+  for (i = fp_count_bits(e)-2, j = 1; i >= 0; i--, j++) {\n+      if (!fp_is_bit_set(e, i) || j == CT_INV_MOD_PRE_CNT)\n+          break;\n+  }\n+  fp_copy(&pre[j-1], t);\n+  for (j = 0; i >= 0; i--) {\n+    int set = fp_is_bit_set(e, i);\n+\n+    if ((j == CT_INV_MOD_PRE_CNT) || (!set && j > 0)) {\n+      fp_mul(t, &pre[j-1], t);\n+      fp_montgomery_reduce(t, b, mp);\n+      j = 0;\n+    }\n+    fp_sqr(t, t);\n+    fp_montgomery_reduce(t, b, mp);\n+    j += set;\n+  }\n+  if (j > 0) {\n+    fp_mul(t, &pre[j-1], c);\n+    fp_montgomery_reduce(c, b, mp);\n+  }\n+  else \n+    fp_copy(t, c);\n+\n+#ifdef WOLFSSL_SMALL_STACK\n+  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);\n+#endif\n+  return FP_OKAY;\n+}\n+\n /* d = a * b (mod c) */\n int fp_mulmod(fp_int *a, fp_int *b, fp_int *c, fp_int *d)\n {\n@@ -3545,6 +3614,12 @@ int mp_invmod (mp_int * a, mp_int * b, mp_int * c)\n   return fp_invmod(a, b, c);\n }\n \n+/* hac 14.61, pp608 */\n+int mp_invmod_mont_ct (mp_int * a, mp_int * b, mp_int * c, mp_digit mp)\n+{\n+  return fp_invmod_mont_ct(a, b, c, mp);\n+}\n+\n /* this is a shell function that calls either the normal or Montgomery\n  * exptmod functions.  Originally the call to the montgomery code was\n  * embedded in the normal function but that wasted a lot of stack space"
        },
        {
          "filename": "wolfssl/wolfcrypt/ecc.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -439,6 +439,7 @@ ECC_API int ecc_mul2add(ecc_point* A, mp_int* kA,\n                 ecc_point* C, mp_int* a, mp_int* modulus, void* heap);\n \n ECC_API int ecc_map(ecc_point*, mp_int*, mp_digit);\n+ECC_API int ecc_map_ex(ecc_point*, mp_int*, mp_digit, int ct);\n ECC_API int ecc_projective_add_point(ecc_point* P, ecc_point* Q, ecc_point* R,\n                                      mp_int* a, mp_int* modulus, mp_digit mp);\n ECC_API int ecc_projective_dbl_point(ecc_point* P, ecc_point* R, mp_int* a,"
        },
        {
          "filename": "wolfssl/wolfcrypt/tfm.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -535,6 +535,7 @@ int fp_sqrmod(fp_int *a, fp_int *b, fp_int *c);\n \n /* c = 1/a (mod b) */\n int fp_invmod(fp_int *a, fp_int *b, fp_int *c);\n+int fp_invmod_mont_ct(fp_int *a, fp_int *b, fp_int *c, fp_digit mp);\n \n /* c = (a, b) */\n /*int fp_gcd(fp_int *a, fp_int *b, fp_int *c);*/\n@@ -743,6 +744,7 @@ MP_API int  mp_submod (mp_int* a, mp_int* b, mp_int* c, mp_int* d);\n MP_API int  mp_addmod (mp_int* a, mp_int* b, mp_int* c, mp_int* d);\n MP_API int  mp_mod(mp_int *a, mp_int *b, mp_int *c);\n MP_API int  mp_invmod(mp_int *a, mp_int *b, mp_int *c);\n+MP_API int  mp_invmod_mont_ct(mp_int *a, mp_int *b, mp_int *c, fp_digit mp);\n MP_API int  mp_exptmod (mp_int * g, mp_int * x, mp_int * p, mp_int * y);\n MP_API int  mp_exptmod_ex (mp_int * g, mp_int * x, int minDigits, mp_int * p,\n                            mp_int * y);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e76186f06080bff1ca0c6c9e07c02cfb38041e4c",
            "date": "2025-01-14T19:54:01Z",
            "author_login": "SparkiDev"
          },
          {
            "sha": "9f5c89ab4bfc1f530d0d285f367c0c80f8cdf401",
            "date": "2025-01-13T23:22:28Z",
            "author_login": "kareem-wolfssl"
          },
          {
            "sha": "e037e0875dd2e07361e9fac4cf7a0238e0309e33",
            "date": "2025-01-11T00:31:34Z",
            "author_login": "JacobBarthelmeh"
          },
          {
            "sha": "d4c654205b396bc094101924cec5c70f3c1c43a1",
            "date": "2025-01-10T23:38:02Z",
            "author_login": "douzzer"
          },
          {
            "sha": "99a6e82ff8e6e5672d24a341d0563ef0e4eb0c83",
            "date": "2025-01-10T22:58:30Z",
            "author_login": "JacobBarthelmeh"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-203",
    "description": "The private-key operations in ecc.c in wolfSSL before 4.4.0 do not use a constant-time modular inverse when mapping to affine coordinates, aka a \"projective coordinates leak.\"",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-06-25T14:15:11.583",
    "last_modified": "2024-11-21T04:58:30.663",
    "fix_date": "2020-03-18T01:05:44Z"
  },
  "references": [
    {
      "url": "https://github.com/wolfSSL/wolfssl/commit/1de07da61f0c8e9926dcbd68119f73230dae283f",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/wolfSSL/wolfssl/releases/tag/v4.4.0-stable",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/wolfSSL/wolfssl/commit/1de07da61f0c8e9926dcbd68119f73230dae283f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/wolfSSL/wolfssl/releases/tag/v4.4.0-stable",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:01.339063",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "wolfssl",
    "owner": "wolfSSL",
    "created_at": "2015-01-07T18:50:58Z",
    "updated_at": "2025-01-13T00:58:18Z",
    "pushed_at": "2025-01-11T00:31:34Z",
    "size": 721845,
    "stars": 2393,
    "forks": 837,
    "open_issues": 146,
    "watchers": 2393,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "C": 62599471,
      "Assembly": 10706563,
      "SWIG": 703527,
      "Shell": 514989,
      "M4": 472265,
      "CMake": 469091,
      "C#": 318580,
      "Makefile": 179610,
      "C++": 139371,
      "Perl": 131729,
      "Ada": 101144,
      "Cuda": 44905,
      "FreeMarker": 21402,
      "Batchfile": 16006,
      "Tcl": 13135,
      "Python": 12935,
      "Objective-C": 8372,
      "Euphoria": 8268,
      "Dockerfile": 7146,
      "Swift": 2317,
      "BitBake": 1232,
      "XS": 195
    },
    "commit_activity": {
      "total_commits_last_year": 2519,
      "avg_commits_per_week": 48.44230769230769,
      "days_active_last_year": 301
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T13:12:30.290141"
  }
}