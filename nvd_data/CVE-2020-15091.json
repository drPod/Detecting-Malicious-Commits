{
  "cve_id": "CVE-2020-15091",
  "github_data": {
    "repository": "tendermint/tendermint",
    "fix_commit": "480b995a31727593f58b361af979054d17d84340",
    "related_commits": [
      "480b995a31727593f58b361af979054d17d84340",
      "480b995a31727593f58b361af979054d17d84340"
    ],
    "patch_url": "https://github.com/tendermint/tendermint/commit/480b995a31727593f58b361af979054d17d84340.patch",
    "fix_commit_details": {
      "sha": "480b995a31727593f58b361af979054d17d84340",
      "commit_date": "2020-06-30T07:43:51Z",
      "author": {
        "login": "melekes",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "consensus: Do not allow signatures for a wrong block in commits",
        "length": 1490,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 112,
        "additions": 108,
        "deletions": 4
      },
      "files": [
        {
          "filename": "consensus/invalid_test.go",
          "status": "added",
          "additions": 97,
          "deletions": 0,
          "patch": "@@ -0,0 +1,97 @@\n+package consensus\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/tendermint/tendermint/libs/bytes\"\n+\t\"github.com/tendermint/tendermint/libs/log\"\n+\ttmrand \"github.com/tendermint/tendermint/libs/rand\"\n+\t\"github.com/tendermint/tendermint/p2p\"\n+\ttmproto \"github.com/tendermint/tendermint/proto/tendermint/types\"\n+\t\"github.com/tendermint/tendermint/types\"\n+)\n+\n+//----------------------------------------------\n+// byzantine failures\n+\n+// one byz val sends a precommit for a random block at each height\n+// Ensure a testnet makes blocks\n+func TestReactorInvalidPrecommit(t *testing.T) {\n+\tN := 4\n+\tcss, cleanup := randConsensusNet(N, \"consensus_reactor_test\", newMockTickerFunc(true), newCounter)\n+\tdefer cleanup()\n+\n+\tfor i := 0; i < 4; i++ {\n+\t\tticker := NewTimeoutTicker()\n+\t\tticker.SetLogger(css[i].Logger)\n+\t\tcss[i].SetTimeoutTicker(ticker)\n+\n+\t}\n+\n+\treactors, blocksSubs, eventBuses := startConsensusNet(t, css, N)\n+\n+\t// this val sends a random precommit at each height\n+\tbyzValIdx := 0\n+\tbyzVal := css[byzValIdx]\n+\tbyzR := reactors[byzValIdx]\n+\n+\t// update the doPrevote function to just send a valid precommit for a random block\n+\t// and otherwise disable the priv validator\n+\tbyzVal.mtx.Lock()\n+\tpv := byzVal.privValidator\n+\tbyzVal.doPrevote = func(height int64, round int32) {\n+\t\tinvalidDoPrevoteFunc(t, height, round, byzVal, byzR.Switch, pv)\n+\t}\n+\tbyzVal.mtx.Unlock()\n+\tdefer stopConsensusNet(log.TestingLogger(), reactors, eventBuses)\n+\n+\t// wait for a bunch of blocks\n+\t// TODO: make this tighter by ensuring the halt happens by block 2\n+\tfor i := 0; i < 10; i++ {\n+\t\ttimeoutWaitGroup(t, N, func(j int) {\n+\t\t\t<-blocksSubs[j].Out()\n+\t\t}, css)\n+\t}\n+}\n+\n+func invalidDoPrevoteFunc(t *testing.T, height int64, round int32, cs *State, sw *p2p.Switch, pv types.PrivValidator) {\n+\t// routine to:\n+\t// - precommit for a random block\n+\t// - send precommit to all peers\n+\t// - disable privValidator (so we don't do normal precommits)\n+\tgo func() {\n+\t\tcs.mtx.Lock()\n+\t\tcs.privValidator = pv\n+\t\tpubKey, err := cs.privValidator.GetPubKey()\n+\t\tif err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t\taddr := pubKey.Address()\n+\t\tvalIndex, _ := cs.Validators.GetByAddress(addr)\n+\n+\t\t// precommit a random block\n+\t\tblockHash := bytes.HexBytes(tmrand.Bytes(32))\n+\t\tprecommit := &types.Vote{\n+\t\t\tValidatorAddress: addr,\n+\t\t\tValidatorIndex:   valIndex,\n+\t\t\tHeight:           cs.Height,\n+\t\t\tRound:            cs.Round,\n+\t\t\tTimestamp:        cs.voteTime(),\n+\t\t\tType:             tmproto.PrecommitType,\n+\t\t\tBlockID: types.BlockID{\n+\t\t\t\tHash:          blockHash,\n+\t\t\t\tPartSetHeader: types.PartSetHeader{Total: 1, Hash: tmrand.Bytes(32)}},\n+\t\t}\n+\t\tp := precommit.ToProto()\n+\t\tcs.privValidator.SignVote(cs.state.ChainID, p)\n+\t\tprecommit.Signature = p.Signature\n+\t\tcs.privValidator = nil // disable priv val so we don't do normal votes\n+\t\tcs.mtx.Unlock()\n+\n+\t\tpeers := sw.Peers().List()\n+\t\tfor _, peer := range peers {\n+\t\t\tcs.Logger.Info(\"Sending bad vote\", \"block\", blockHash, \"peer\", peer)\n+\t\t\tpeer.Send(VoteChannel, MustEncode(&VoteMessage{precommit}))\n+\t\t}\n+\t}()\n+}"
        },
        {
          "filename": "types/vote_set.go",
          "status": "modified",
          "additions": 11,
          "deletions": 4,
          "patch": "@@ -549,9 +549,11 @@ func (voteSet *VoteSet) sumTotalFrac() (int64, int64, float64) {\n //--------------------------------------------------------------------------------\n // Commit\n \n-// MakeCommit constructs a Commit from the VoteSet.\n-// Panics if the vote type is not PrecommitType or if\n-// there's no +2/3 votes for a single block.\n+// MakeCommit constructs a Commit from the VoteSet. It only includes precommits\n+// for the block, which has 2/3+ majority, and nil.\n+//\n+// Panics if the vote type is not PrecommitType or if there's no +2/3 votes for\n+// a single block.\n func (voteSet *VoteSet) MakeCommit() *Commit {\n \tif voteSet.signedMsgType != tmproto.PrecommitType {\n \t\tpanic(\"Cannot MakeCommit() unless VoteSet.Type is PrecommitType\")\n@@ -567,7 +569,12 @@ func (voteSet *VoteSet) MakeCommit() *Commit {\n \t// For every validator, get the precommit\n \tcommitSigs := make([]CommitSig, len(voteSet.votes))\n \tfor i, v := range voteSet.votes {\n-\t\tcommitSigs[i] = v.CommitSig()\n+\t\tcommitSig := v.CommitSig()\n+\t\t// if block ID exists but doesn't match, exclude sig\n+\t\tif commitSig.ForBlock() && !v.BlockID.Equals(*voteSet.maj23) {\n+\t\t\tcommitSig = NewCommitSigAbsent()\n+\t\t}\n+\t\tcommitSigs[i] = commitSig\n \t}\n \n \treturn NewCommit(voteSet.GetHeight(), voteSet.GetRound(), *voteSet.maj23, commitSigs)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "35581cf54ec436b8c37fabb43fdaa3f48339a170",
            "date": "2023-02-02T21:35:52Z",
            "author_login": "jaekwon"
          },
          {
            "sha": "64747b2b184184ecba4f4bffc54ffbcb47cfbcb0",
            "date": "2023-01-05T21:16:29Z",
            "author_login": "jaekwon"
          },
          {
            "sha": "014cdcf09844d48f6d30f3e520034b7edffd9670",
            "date": "2022-11-22T12:42:46Z",
            "author_login": "thanethomson"
          },
          {
            "sha": "08e5d0bf78c4becdfab0d9e5197e7adca4120b69",
            "date": "2022-11-21T11:05:35Z",
            "author_login": "thanethomson"
          },
          {
            "sha": "c645fd0b71cca2fa0ff1f597591f325e3c0ab905",
            "date": "2022-11-15T19:57:57Z",
            "author_login": "thanethomson"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-347",
    "description": "TenderMint from version 0.33.0 and before version 0.33.6 allows block proposers to include signatures for the wrong block. This may happen naturally if you start a network, have it run for some time and restart it (**without changing chainID**). A malicious block proposer (even with a minimal amount of stake) can use this vulnerability to completely halt the network. This issue is fixed in Tendermint 0.33.6 which checks all the signatures are for the block with 2/3+ majority before creating a commit.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-07-02T17:15:12.547",
    "last_modified": "2024-11-21T05:04:47.290",
    "fix_date": "2020-06-30T07:43:51Z"
  },
  "references": [
    {
      "url": "https://github.com/tendermint/tendermint/commit/480b995a31727593f58b361af979054d17d84340",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tendermint/tendermint/issues/4926",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tendermint/tendermint/security/advisories/GHSA-6jqj-f58p-mrw3",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tendermint/tendermint/commit/480b995a31727593f58b361af979054d17d84340",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tendermint/tendermint/issues/4926",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tendermint/tendermint/security/advisories/GHSA-6jqj-f58p-mrw3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:01.352849",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "tendermint",
    "owner": "tendermint",
    "created_at": "2014-05-14T23:21:35Z",
    "updated_at": "2025-01-13T20:11:21Z",
    "pushed_at": "2024-12-27T00:20:39Z",
    "size": 150233,
    "stars": 5739,
    "forks": 2086,
    "open_issues": 20,
    "watchers": 5739,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Go": 3979011,
      "TeX": 332482,
      "TLA": 228722,
      "Shell": 27771,
      "Python": 25606,
      "Makefile": 17042,
      "Jinja": 13466,
      "Dockerfile": 6422,
      "HCL": 2065,
      "HTML": 787
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T17:02:01.644376"
  }
}