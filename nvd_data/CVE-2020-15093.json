{
  "cve_id": "CVE-2020-15093",
  "github_data": {
    "repository": "theupdateframework/tuf",
    "fix_commit": "2977188139d065ff3356c3cb4aec60c582b57e0e",
    "related_commits": [
      "2977188139d065ff3356c3cb4aec60c582b57e0e",
      "2977188139d065ff3356c3cb4aec60c582b57e0e"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "2977188139d065ff3356c3cb4aec60c582b57e0e",
      "commit_date": "2020-01-10T20:19:16Z",
      "author": {
        "login": "SantiagoTorres",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #974 from lukpueh/fix-signature-threshold",
        "length": 85,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 176,
        "additions": 145,
        "deletions": 31
      },
      "files": [
        {
          "filename": "tests/test_sig.py",
          "status": "modified",
          "additions": 63,
          "deletions": 0,
          "patch": "@@ -31,6 +31,7 @@\n \n import unittest\n import logging\n+import copy\n \n import tuf\n import tuf.log\n@@ -384,6 +385,68 @@ def test_verify_single_key(self):\n     tuf.roledb.remove_role('Root')\n \n \n+\n+  def test_verify_must_not_count_duplicate_keyids_towards_threshold(self):\n+    # Create and sign dummy metadata twice with same key\n+    # Note that we use the non-deterministic rsassa-pss signing scheme, so\n+    # creating the signature twice shows that we don't only detect duplicate\n+    # signatures but also different signatures from the same key.\n+    signable = {\"signed\" : \"test\", \"signatures\" : []}\n+    signed = securesystemslib.formats.encode_canonical(\n+        signable[\"signed\"]).encode(\"utf-8\")\n+    signable[\"signatures\"].append(\n+        securesystemslib.keys.create_signature(KEYS[0], signed))\n+    signable[\"signatures\"].append(\n+        securesystemslib.keys.create_signature(KEYS[0], signed))\n+\n+    # 'get_signature_status' uses keys from keydb for verification\n+    tuf.keydb.add_key(KEYS[0])\n+\n+    # Assert that 'get_signature_status' returns two good signatures ...\n+    status = tuf.sig.get_signature_status(\n+        signable, \"root\", keyids=[KEYS[0][\"keyid\"]], threshold=2)\n+    self.assertTrue(len(status[\"good_sigs\"]) == 2)\n+\n+    # ... but only one counts towards the threshold\n+    self.assertFalse(\n+        tuf.sig.verify(signable, \"root\", keyids=[KEYS[0][\"keyid\"]], threshold=2))\n+\n+    # Clean-up keydb\n+    tuf.keydb.remove_key(KEYS[0][\"keyid\"])\n+\n+\n+\n+  def test_verify_count_different_keyids_for_same_key_towards_threshold(self):\n+    # Create and sign dummy metadata twice with same key but different keyids\n+    signable = {\"signed\" : \"test\", \"signatures\" : []}\n+    key_sha256 = copy.deepcopy(KEYS[0])\n+    key_sha256[\"keyid\"] = \"deadbeef256\"\n+\n+    key_sha512 = copy.deepcopy(KEYS[0])\n+    key_sha512[\"keyid\"] = \"deadbeef512\"\n+\n+    signed = securesystemslib.formats.encode_canonical(\n+        signable[\"signed\"]).encode(\"utf-8\")\n+    signable[\"signatures\"].append(\n+        securesystemslib.keys.create_signature(key_sha256, signed))\n+    signable[\"signatures\"].append(\n+        securesystemslib.keys.create_signature(key_sha512, signed))\n+\n+    # 'get_signature_status' uses keys from keydb for verification\n+    tuf.keydb.add_key(key_sha256)\n+    tuf.keydb.add_key(key_sha512)\n+\n+    # Assert that both keys count towards threshold although its the same key\n+    keyids = [key_sha256[\"keyid\"], key_sha512[\"keyid\"]]\n+    self.assertTrue(\n+        tuf.sig.verify(signable, \"root\", keyids=keyids, threshold=2))\n+\n+    # Clean-up keydb\n+    tuf.keydb.remove_key(key_sha256[\"keyid\"])\n+    tuf.keydb.remove_key(key_sha512[\"keyid\"])\n+\n+\n+\n   def test_verify_unrecognized_sig(self):\n     signable = {'signed' : 'test', 'signatures' : []}\n     signed = securesystemslib.formats.encode_canonical(signable['signed']).encode('utf-8')"
        },
        {
          "filename": "tests/test_updater.py",
          "status": "modified",
          "additions": 47,
          "deletions": 0,
          "patch": "@@ -425,6 +425,53 @@ def test_1__update_versioninfo(self):\n \n \n \n+  def test_1__refresh_must_not_count_duplicate_keyids_towards_threshold(self):\n+    # Update root threshold on the server repository and sign twice with 1 key\n+    repository = repo_tool.load_repository(self.repository_directory)\n+    repository.root.threshold = 2\n+    repository.root.load_signing_key(self.role_keys['root']['private'])\n+\n+    # The client uses the threshold from the previous root file to verify the\n+    # new root. Thus we need to make two updates so that the threshold used for\n+    # verification becomes 2. I.e. we bump the version, sign twice with the\n+    # same key and write to disk '2.root.json' and '3.root.json'.\n+    for version in [2, 3]:\n+      repository.root.version = version\n+      info = tuf.roledb.get_roleinfo(\"root\")\n+      metadata = repo_lib.generate_root_metadata(\n+          info[\"version\"], info[\"expires\"], False)\n+      signed_metadata = repo_lib.sign_metadata(\n+          metadata, info[\"keyids\"], \"root.json\", \"default\")\n+      signed_metadata[\"signatures\"].append(signed_metadata[\"signatures\"][0])\n+      live_root_path = os.path.join(\n+          self.repository_directory, \"metadata\", \"root.json\")\n+\n+      # Bypass server side verification in 'write' or 'writeall', which would\n+      # catch the unmet threshold.\n+      # We also skip writing to 'metadata.staged' and copying to 'metadata' and\n+      # instead write directly to 'metadata'\n+      repo_lib.write_metadata_file(signed_metadata, live_root_path, info[\"version\"], True)\n+\n+\n+    # Update from current '1.root.json' to '3.root.json' on client and assert\n+    # raise of 'BadSignatureError' (caused by unmet signature threshold).\n+    try:\n+      self.repository_updater.refresh()\n+\n+    except tuf.exceptions.NoWorkingMirrorError as e:\n+      mirror_errors = list(e.mirror_errors.values())\n+      self.assertTrue(len(mirror_errors) == 1)\n+      self.assertTrue(\n+          isinstance(mirror_errors[0],\n+          securesystemslib.exceptions.BadSignatureError))\n+      self.assertEqual(\n+          str(mirror_errors[0]),\n+          repr(\"root\") + \" metadata has bad signature.\")\n+\n+    else:\n+      self.fail(\n+          \"Expected a NoWorkingMirrorError composed of one BadSignatureError\")\n+\n \n   def test_1__update_fileinfo(self):\n       # Tests"
        },
        {
          "filename": "tuf/sig.py",
          "status": "modified",
          "additions": 35,
          "deletions": 31,
          "patch": "@@ -71,11 +71,23 @@ def get_signature_status(signable, role=None, repository_name='default',\n   \"\"\"\n   <Purpose>\n     Return a dictionary representing the status of the signatures listed in\n-    'signable'.  Given an object conformant to SIGNABLE_SCHEMA, a set of public\n-    keys in 'tuf.keydb', a set of roles in 'tuf.roledb', and a role,\n-    the status of these signatures can be determined.  This method will iterate\n-    the signatures in 'signable' and enumerate all the keys that are valid,\n-    invalid, unrecognized, or unauthorized.\n+    'signable'. Signatures in the returned dictionary are identified by the\n+    signature keyid and can have a status of either:\n+\n+    * bad -- Invalid signature\n+    * good -- Valid signature from key that is available in 'tuf.keydb', and is\n+      authorized for the passed role as per 'tuf.roledb' (authorization may be\n+      overwritten by passed 'keyids').\n+    * unknown -- Signature from key that is not available in 'tuf.keydb', or if\n+      'role' is None.\n+    * unknown signing schemes -- Signature from key with unknown signing\n+      scheme.\n+    * untrusted -- Valid signature from key that is available in 'tuf.keydb',\n+      but is not trusted for the passed role as per 'tuf.roledb' or the passed\n+      'keyids'.\n+\n+    NOTE: The result may contain duplicate keyids or keyids that reference the\n+    same key, if 'signable' lists multiple signatures from the same key.\n \n   <Arguments>\n     signable:\n@@ -87,7 +99,7 @@ def get_signature_status(signable, role=None, repository_name='default',\n       Conformant to tuf.formats.SIGNABLE_SCHEMA.\n \n     role:\n-      TUF role (e.g., 'root', 'targets', 'snapshot').\n+      TUF role string (e.g. 'root', 'targets', 'snapshot' or timestamp).\n \n     threshold:\n       Rather than reference the role's threshold as set in tuf.roledb.py, use\n@@ -133,22 +145,6 @@ def get_signature_status(signable, role=None, repository_name='default',\n \n   # The signature status dictionary returned.\n   signature_status = {}\n-\n-  # The fields of the signature_status dict, where each field stores keyids.  A\n-  # description of each field:\n-  #\n-  # good_sigs = keys confirmed to have produced 'sig' using 'signed', which are\n-  # associated with 'role';\n-  #\n-  # bad_sigs = negation of good_sigs;\n-  #\n-  # unknown_sigs = keys not found in the 'keydb' database;\n-  #\n-  # untrusted_sigs = keys that are not in the list of keyids associated with\n-  # 'role';\n-  #\n-  # unknown_signing_scheme = signing schemes specified in keys that are\n-  # unsupported;\n   good_sigs = []\n   bad_sigs = []\n   unknown_sigs = []\n@@ -240,18 +236,26 @@ def verify(signable, role, repository_name='default', threshold=None,\n     keyids=None):\n   \"\"\"\n   <Purpose>\n-    Verify whether the authorized signatures of 'signable' meet the minimum\n-    required by 'role'.  Authorized signatures are those with valid keys\n-    associated with 'role'.  'signable' must conform to SIGNABLE_SCHEMA\n-    and 'role' must not equal 'None' or be less than zero.\n+    Verify that 'signable' has a valid threshold of authorized signatures\n+    identified by unique keyids. The threshold and whether a keyid is\n+    authorized is determined by querying the 'threshold' and 'keyids' info for\n+    the passed 'role' in 'tuf.roledb'. Both values can be overwritten by\n+    passing the 'threshold' or 'keyids' arguments.\n+\n+    NOTE:\n+    - Signatures with identical authorized keyids only count towards the\n+      threshold once.\n+    - Signatures with different authorized keyids each count towards the\n+      threshold, even if the keyids identify the same key.\n \n   <Arguments>\n     signable:\n-      A dictionary containing a list of signatures and a 'signed' identifier.\n+      A dictionary containing a list of signatures and a 'signed' identifier\n+      that conforms to SIGNABLE_SCHEMA, e.g.:\n       signable = {'signed':, 'signatures': [{'keyid':, 'method':, 'sig':}]}\n \n     role:\n-      TUF role (e.g., 'root', 'targets', 'snapshot').\n+      TUF role string (e.g. 'root', 'targets', 'snapshot' or timestamp).\n \n     threshold:\n       Rather than reference the role's threshold as set in tuf.roledb.py, use\n@@ -278,8 +282,8 @@ def verify(signable, role, repository_name='default', threshold=None,\n     get_signature_status() will be caught here and re-raised.\n \n   <Returns>\n-    Boolean.  True if the number of good signatures >= the role's threshold,\n-    False otherwise.\n+    Boolean.  True if the number of good unique (by keyid) signatures >= the\n+    role's threshold, False otherwise.\n   \"\"\"\n \n   tuf.formats.SIGNABLE_SCHEMA.check_match(signable)\n@@ -303,7 +307,7 @@ def verify(signable, role, repository_name='default', threshold=None,\n   if threshold is None or threshold <= 0: #pragma: no cover\n     raise securesystemslib.exceptions.Error(\"Invalid threshold: \" + repr(threshold))\n \n-  return len(good_sigs) >= threshold\n+  return len(set(good_sigs)) >= threshold\n \n \n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "58d2acc03f4ead4a41430faff8acb68fa1af7461",
            "date": "2025-01-21T12:08:06Z",
            "author_login": "jku"
          },
          {
            "sha": "bfb1353cd17859405686bb2345492cc26b7e105e",
            "date": "2025-01-20T21:34:37Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "717bc1a5f9fe9287090e2421df8fe955464cf46a",
            "date": "2025-01-17T09:55:00Z",
            "author_login": "jku"
          },
          {
            "sha": "5b2c041da01962a2f5f7c20cb74a860a8fbca5c4",
            "date": "2025-01-14T08:38:19Z",
            "author_login": "jku"
          },
          {
            "sha": "e49b613cf8d8d47040fdd7161d4896f2d654850e",
            "date": "2025-01-14T08:27:24Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N",
    "cwe_id": "CWE-347",
    "description": "The tough library (Rust/crates.io) prior to version 0.7.1 does not properly verify the threshold of cryptographic signatures. It allows an attacker to duplicate a valid signature in order to circumvent TUF requiring a minimum threshold of unique signatures before the metadata is considered valid. A fix is available in version 0.7.1. CVE-2020-6174 is assigned to the same vulnerability in the TUF reference implementation.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-07-09T19:15:11.413",
    "last_modified": "2024-11-21T05:04:47.553",
    "fix_date": "2020-01-10T20:19:16Z"
  },
  "references": [
    {
      "url": "https://crates.io/crates/tough",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/awslabs/tough/security/advisories/GHSA-5q2r-92f9-4m49",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/theupdateframework/tuf/commit/2977188139d065ff3356c3cb4aec60c582b57e0e",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/theupdateframework/tuf/pull/974",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://crates.io/crates/tough",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/awslabs/tough/security/advisories/GHSA-5q2r-92f9-4m49",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/theupdateframework/tuf/commit/2977188139d065ff3356c3cb4aec60c582b57e0e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/theupdateframework/tuf/pull/974",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:01.359550",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "python-tuf",
    "owner": "theupdateframework",
    "created_at": "2013-01-31T18:36:34Z",
    "updated_at": "2025-01-23T18:31:19Z",
    "pushed_at": "2025-01-21T12:08:15Z",
    "size": 18652,
    "stars": 1640,
    "forks": 275,
    "open_issues": 90,
    "watchers": 1640,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "develop",
      "series/3.1"
    ],
    "languages": {
      "Python": 434033
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T08:03:58.226990"
  }
}