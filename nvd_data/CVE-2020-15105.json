{
  "cve_id": "CVE-2020-15105",
  "github_data": {
    "repository": "Bouke/django-two-factor-auth",
    "fix_commit": "454fd9842fa6e8bb772dbf0943976bc8e3335359",
    "related_commits": [
      "454fd9842fa6e8bb772dbf0943976bc8e3335359",
      "454fd9842fa6e8bb772dbf0943976bc8e3335359"
    ],
    "patch_url": "https://github.com/Bouke/django-two-factor-auth/commit/454fd9842fa6e8bb772dbf0943976bc8e3335359.patch",
    "fix_commit_details": {
      "sha": "454fd9842fa6e8bb772dbf0943976bc8e3335359",
      "commit_date": "2020-07-08T19:11:38Z",
      "author": {
        "login": "Bouke",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-vhr6-pvjm-9qwf",
        "length": 97,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 264,
        "additions": 230,
        "deletions": 34
      },
      "files": [
        {
          "filename": "CHANGELOG.md",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -1,4 +1,12 @@\n ## [Unreleased]\n+### Added\n+- It is possible to set a timeout between a user authenticiating in the LoginView and them needing to re-authenticate. By default this is 10 minutes.\n+\n+### Removed\n+- The final step in the LoginView no longer re-validates a user's credentials\n+\n+### Changed\n+- Security Fix: LoginView no longer stores credentials in plaintext in the session store\n \n ## 1.11.0 - 2020-03-13\n ### Added"
        },
        {
          "filename": "docs/configuration.rst",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -73,6 +73,13 @@ General Settings\n      `the upstream ticket`_). Don't set this option to 8 unless all of your\n      users use a 8 digit compatible token generator app.\n \n+``TWO_FACTOR_LOGIN_TIMEOUT`` (default ``600``)\n+  The number of seconds between a user successfully passing the \"authentication\"\n+  step (usually by entering a valid username and password) and them having to\n+  restart the login flow and re-authenticate. This ensures that users can't sit\n+  indefinately in a state of having entered their password successfully but not\n+  having passed two factor authentication. Set to ``0`` to disable.\n+\n ``PHONENUMBER_DEFAULT_REGION`` (default: ``None``)\n   The default region for parsing phone numbers. If your application's primary\n   audience is a certain country, setting the region to that country allows"
        },
        {
          "filename": "tests/test_views_login.py",
          "status": "modified",
          "additions": 108,
          "deletions": 29,
          "patch": "@@ -1,3 +1,4 @@\n+import json\n from unittest import mock\n \n from django.conf import settings\n@@ -88,6 +89,100 @@ def test_valid_login_with_disallowed_external_redirect(self):\n              'login_view-current_step': 'auth'})\n         self.assertRedirects(response, reverse('two_factor:profile'), fetch_redirect_response=False)\n \n+    @mock.patch('two_factor.views.core.time')\n+    def test_valid_login_primary_key_stored(self, mock_time):\n+        mock_time.time.return_value = 12345.12\n+        user = self.create_user()\n+        user.totpdevice_set.create(name='default',\n+                                   key=random_hex_str())\n+\n+        response = self._post({'auth-username': 'bouke@example.com',\n+                               'auth-password': 'secret',\n+                               'login_view-current_step': 'auth'})\n+        self.assertContains(response, 'Token:')\n+\n+        self.assertEqual(self.client.session['wizard_login_view']['user_pk'], str(user.pk))\n+        self.assertEqual(\n+            self.client.session['wizard_login_view']['user_backend'],\n+            'django.contrib.auth.backends.ModelBackend')\n+        self.assertEqual(self.client.session['wizard_login_view']['authentication_time'], 12345)\n+\n+    @mock.patch('two_factor.views.core.time')\n+    def test_valid_login_post_auth_session_clear_of_form_data(self, mock_time):\n+        mock_time.time.return_value = 12345.12\n+        user = self.create_user()\n+        user.totpdevice_set.create(name='default',\n+                                   key=random_hex_str())\n+\n+        response = self._post({'auth-username': 'bouke@example.com',\n+                               'auth-password': 'secret',\n+                               'login_view-current_step': 'auth'})\n+        self.assertContains(response, 'Token:')\n+\n+        self.assertEqual(self.client.session['wizard_login_view']['user_pk'], str(user.pk))\n+        self.assertEqual(self.client.session['wizard_login_view']['step'], 'token')\n+        self.assertEqual(self.client.session['wizard_login_view']['step_data'], {'auth': None})\n+        self.assertEqual(self.client.session['wizard_login_view']['step_files'], {'auth': {}})\n+        self.assertEqual(self.client.session['wizard_login_view']['validated_step_data'], {})\n+\n+    @mock.patch('two_factor.views.core.logger')\n+    @mock.patch('two_factor.views.core.time')\n+    def test_valid_login_expired(self, mock_time, mock_logger):\n+        mock_time.time.return_value = 12345.12\n+        user = self.create_user()\n+        device = user.totpdevice_set.create(name='default',\n+                                            key=random_hex_str())\n+\n+        response = self._post({'auth-username': 'bouke@example.com',\n+                               'auth-password': 'secret',\n+                               'login_view-current_step': 'auth'})\n+        self.assertContains(response, 'Token:')\n+\n+        self.assertEqual(self.client.session['wizard_login_view']['user_pk'], str(user.pk))\n+        self.assertEqual(\n+            self.client.session['wizard_login_view']['user_backend'],\n+            'django.contrib.auth.backends.ModelBackend')\n+        self.assertEqual(self.client.session['wizard_login_view']['authentication_time'], 12345)\n+\n+        mock_time.time.return_value = 20345.12\n+\n+        response = self._post({'token-otp_token': totp(device.bin_key),\n+                               'login_view-current_step': 'token'})\n+        self.assertEqual(response.status_code, 200)\n+        self.assertNotContains(response, 'Token:')\n+        self.assertContains(response, 'Password:')\n+        self.assertContains(response, 'Your session has timed out. Please login again.')\n+\n+        # Check that a message was logged.\n+        mock_logger.info.assert_called_with(\n+            \"User's authentication flow has timed out. The user \"\n+            \"has been redirected to the initial auth form.\")\n+\n+    @override_settings(TWO_FACTOR_LOGIN_TIMEOUT=0)\n+    @mock.patch('two_factor.views.core.time')\n+    def test_valid_login_no_timeout(self, mock_time):\n+        mock_time.time.return_value = 12345.12\n+        user = self.create_user()\n+        device = user.totpdevice_set.create(name='default',\n+                                            key=random_hex_str())\n+\n+        response = self._post({'auth-username': 'bouke@example.com',\n+                               'auth-password': 'secret',\n+                               'login_view-current_step': 'auth'})\n+        self.assertContains(response, 'Token:')\n+\n+        self.assertEqual(self.client.session['wizard_login_view']['user_pk'], str(user.pk))\n+        self.assertEqual(\n+            self.client.session['wizard_login_view']['user_backend'],\n+            'django.contrib.auth.backends.ModelBackend')\n+        self.assertEqual(self.client.session['wizard_login_view']['authentication_time'], 12345)\n+\n+        mock_time.time.return_value = 20345.12\n+\n+        response = self._post({'token-otp_token': totp(device.bin_key),\n+                               'login_view-current_step': 'token'})\n+        self.assertRedirects(response, resolve_url(settings.LOGIN_REDIRECT_URL))\n+        self.assertEqual(self.client.session['_auth_user_id'], str(user.pk))\n \n     def test_valid_login_with_redirect_authenticated_user(self):\n         user = self.create_user()\n@@ -251,35 +346,6 @@ def test_with_backup_token(self, mock_signal):\n         # Check that the signal was fired.\n         mock_signal.assert_called_with(sender=mock.ANY, request=mock.ANY, user=user, device=device)\n \n-    @mock.patch('two_factor.views.utils.logger')\n-    def test_change_password_in_between(self, mock_logger):\n-        \"\"\"\n-        When the password of the user is changed while trying to login, should\n-        not result in errors. Refs #63.\n-        \"\"\"\n-        user = self.create_user()\n-        self.enable_otp()\n-\n-        response = self._post({'auth-username': 'bouke@example.com',\n-                               'auth-password': 'secret',\n-                               'login_view-current_step': 'auth'})\n-        self.assertContains(response, 'Token:')\n-\n-        # Now, the password is changed. When the form is submitted, the\n-        # credentials should be checked again. If that's the case, the\n-        # login form should note that the credentials are invalid.\n-        user.set_password('secret2')\n-        user.save()\n-        response = self._post({'login_view-current_step': 'token'})\n-        self.assertContains(response, 'Please enter a correct')\n-        self.assertContains(response, 'and password.')\n-\n-        # Check that a message was logged.\n-        mock_logger.warning.assert_called_with(\n-            \"Current step '%s' is no longer valid, returning to last valid \"\n-            \"step in the wizard.\",\n-            'token')\n-\n     @mock.patch('two_factor.views.utils.logger')\n     def test_reset_wizard_state(self, mock_logger):\n         self.create_user()\n@@ -332,6 +398,19 @@ def test_missing_management_data(self):\n         # view should return HTTP 400 Bad Request\n         self.assertEqual(response.status_code, 400)\n \n+    def test_no_password_in_session(self):\n+        self.create_user()\n+        self.enable_otp()\n+\n+        response = self._post({'auth-username': 'bouke@example.com',\n+                               'auth-password': 'secret',\n+                               'login_view-current_step': 'auth'})\n+        self.assertContains(response, 'Token:')\n+\n+        session_contents = json.dumps(list(self.client.session.items()))\n+\n+        self.assertNotIn('secret', session_contents)\n+\n \n class BackupTokensTest(UserMixin, TestCase):\n     def setUp(self):"
        },
        {
          "filename": "two_factor/views/core.py",
          "status": "modified",
          "additions": 75,
          "deletions": 4,
          "patch": "@@ -2,6 +2,7 @@\n import warnings\n from base64 import b32encode\n from binascii import unhexlify\n+import time\n \n import django_otp\n import qrcode\n@@ -12,13 +13,15 @@\n from django.contrib.auth.forms import AuthenticationForm\n from django.contrib.auth.views import SuccessURLAllowedHostsMixin\n from django.contrib.sites.shortcuts import get_current_site\n-from django.forms import Form\n+from django.forms import Form, ValidationError\n from django.http import Http404, HttpResponse, HttpResponseRedirect\n from django.shortcuts import redirect, resolve_url\n from django.urls import reverse\n from django.utils.decorators import method_decorator\n+from django.utils.functional import cached_property\n from django.utils.http import is_safe_url\n from django.utils.module_loading import import_string\n+from django.utils.translation import gettext as _\n from django.views.decorators.cache import never_cache\n from django.views.decorators.csrf import csrf_protect\n from django.views.decorators.debug import sensitive_post_parameters\n@@ -72,6 +75,7 @@ class LoginView(SuccessURLAllowedHostsMixin, IdempotentSessionWizardView):\n         'backup': False,\n     }\n     redirect_authenticated_user = False\n+    storage_name = 'two_factor.views.utils.LoginStorage'\n \n     def has_token_step(self):\n         return default_device(self.get_user())\n@@ -80,6 +84,14 @@ def has_backup_step(self):\n         return default_device(self.get_user()) and \\\n             'token' not in self.storage.validated_step_data\n \n+    @cached_property\n+    def expired(self):\n+        login_timeout = getattr(settings, 'TWO_FACTOR_LOGIN_TIMEOUT', 600)\n+        if login_timeout == 0:\n+            return False\n+        expiration_time = self.storage.data.get(\"authentication_time\", 0) + login_timeout\n+        return int(time.time()) > expiration_time\n+\n     condition_dict = {\n         'token': has_token_step,\n         'backup': has_backup_step,\n@@ -90,12 +102,25 @@ def __init__(self, **kwargs):\n         super().__init__(**kwargs)\n         self.user_cache = None\n         self.device_cache = None\n+        self.show_timeout_error = False\n \n     def post(self, *args, **kwargs):\n         \"\"\"\n         The user can select a particular device to challenge, being the backup\n         devices added to the account.\n         \"\"\"\n+        wizard_goto_step = self.request.POST.get('wizard_goto_step', None)\n+\n+        if wizard_goto_step == 'auth':\n+            self.storage.reset()\n+\n+        if self.expired and self.steps.current != 'auth':\n+            logger.info(\"User's authentication flow has timed out. The user \"\n+                        \"has been redirected to the initial auth form.\")\n+            self.storage.reset()\n+            self.show_timeout_error = True\n+            return self.render_goto_step('auth')\n+\n         # Generating a challenge doesn't require to validate the form.\n         if 'challenge_device' in self.request.POST:\n             return self.render_goto_step('token')\n@@ -152,6 +177,54 @@ def get_form_kwargs(self, step=None):\n             }\n         return {}\n \n+    def get_done_form_list(self):\n+        \"\"\"\n+        Return the forms that should be processed during the final step\n+        \"\"\"\n+        # Intentionally do not process the auth form on the final step. We\n+        # haven't stored this data, and it isn't required to login the user\n+        form_list = self.get_form_list()\n+        form_list.pop('auth')\n+        return form_list\n+\n+    def process_step(self, form):\n+        \"\"\"\n+        Process an individual step in the flow\n+        \"\"\"\n+        # To prevent saving any private auth data to the session store, we\n+        # validate the authentication form, determine the resulting user, then\n+        # only store the minimum needed to login that user (the user's primary\n+        # key and the backend used)\n+        if self.steps.current == 'auth':\n+            user = form.is_valid() and form.user_cache\n+            self.storage.reset()\n+            self.storage.authenticated_user = user\n+            self.storage.data[\"authentication_time\"] = int(time.time())\n+\n+            # By returning None when the user clicks the \"back\" button to the\n+            # auth step the form will be blank with validation warnings\n+            return None\n+\n+        return super().process_step(form)\n+\n+    def process_step_files(self, form):\n+        \"\"\"\n+        Process the files submitted from a specific test\n+        \"\"\"\n+        if self.steps.current == 'auth':\n+            return {}\n+        return super().process_step_files(form)\n+\n+    def get_form(self, *args, **kwargs):\n+        \"\"\"\n+        Returns the form for the step\n+        \"\"\"\n+        form = super().get_form(*args, **kwargs)\n+        if self.show_timeout_error:\n+            form.cleaned_data = getattr(form, 'cleaned_data', {})\n+            form.add_error(None, ValidationError(_('Your session has timed out. Please login again.')))\n+        return form\n+\n     def get_device(self, step=None):\n         \"\"\"\n         Returns the OTP device selected by the user, or his default device.\n@@ -187,9 +260,7 @@ def get_user(self):\n         if not a valid user; see also issue #65.\n         \"\"\"\n         if not self.user_cache:\n-            form_obj = self.get_form(step='auth',\n-                                     data=self.storage.get_step_data('auth'))\n-            self.user_cache = form_obj.is_valid() and form_obj.user_cache\n+            self.user_cache = self.storage.authenticated_user\n         return self.user_cache\n \n     def get_context_data(self, form, **kwargs):"
        },
        {
          "filename": "two_factor/views/utils.py",
          "status": "modified",
          "additions": 32,
          "deletions": 1,
          "patch": "@@ -1,5 +1,6 @@\n import logging\n \n+from django.contrib.auth import load_backend\n from django.core.exceptions import SuspiciousOperation\n from django.utils.decorators import method_decorator\n from django.utils.translation import gettext as _\n@@ -37,6 +38,33 @@ def _set_validated_step_data(self, validated_step_data):\n                                    _set_validated_step_data)\n \n \n+class LoginStorage(ExtraSessionStorage):\n+    \"\"\"\n+    SessionStorage that includes the property 'authenticated_user' for storing\n+    backend authenticated users while logging in.\n+    \"\"\"\n+    def _get_authenticated_user(self):\n+        # Ensure that both user_pk and user_backend exist in the session\n+        if not all([self.data.get(\"user_pk\"), self.data.get(\"user_backend\")]):\n+            return False\n+        # Acquire the user the same way django.contrib.auth.get_user does\n+        backend = load_backend(self.data[\"user_backend\"])\n+        user = backend.get_user(self.data[\"user_pk\"])\n+        if not user:\n+            return False\n+        # Set user.backend to the dotted path version of the backend for login()\n+        user.backend = self.data[\"user_backend\"]\n+        return user\n+\n+    def _set_authenticated_user(self, user):\n+        # Acquire the PK the same way django's auth middleware does\n+        self.data[\"user_pk\"] = user._meta.pk.value_to_string(user)\n+        self.data[\"user_backend\"] = user.backend\n+\n+    authenticated_user = property(_get_authenticated_user,\n+                                  _set_authenticated_user)\n+\n+\n class IdempotentSessionWizardView(SessionWizardView):\n     \"\"\"\n     WizardView that allows certain steps to be marked non-idempotent, in which\n@@ -153,6 +181,9 @@ def process_step(self, form):\n \n         return super().process_step(form)\n \n+    def get_done_form_list(self):\n+        return self.get_form_list()\n+\n     def render_done(self, form, **kwargs):\n         \"\"\"\n         This method gets called when all forms passed. The method should also\n@@ -162,7 +193,7 @@ def render_done(self, form, **kwargs):\n         \"\"\"\n         final_form_list = []\n         # walk through the form list and try to validate the data again.\n-        for form_key in self.get_form_list():\n+        for form_key in self.get_done_form_list():\n             form_obj = self.get_form(step=form_key,\n                                      data=self.storage.get_step_data(form_key),\n                                      files=self.storage.get_step_files("
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2ad520c3fd9d156c01912840f985034ef824c8bc",
            "date": "2025-01-10T03:28:47Z",
            "author_login": "moggers87"
          },
          {
            "sha": "77f9d2ae8b28441056925257b4e4c481a91b0a16",
            "date": "2025-01-06T17:55:09Z",
            "author_login": "pre-commit-ci[bot]"
          },
          {
            "sha": "2b39120375e346c08f8a6c20e0775d44be48cc41",
            "date": "2024-12-02T21:04:08Z",
            "author_login": "moggers87"
          },
          {
            "sha": "fc0fe191904b6c7f38f059c70c9b09eb2b70873a",
            "date": "2024-12-02T17:53:22Z",
            "author_login": "pre-commit-ci[bot]"
          },
          {
            "sha": "95255bbe714830152e68c9ff2dd09dee4087a2a1",
            "date": "2024-10-01T10:49:00Z",
            "author_login": "moggers87"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:L/A:N",
    "cwe_id": "CWE-312",
    "description": "Django Two-Factor Authentication before 1.12, stores the user's password in clear text in the user session (base64-encoded). The password is stored in the session when the user submits their username and password, and is removed once they complete authentication by entering a two-factor authentication code. This means that the password is stored in clear text in the session for an arbitrary amount of time, and potentially forever if the user begins the login process by entering their username and password and then leaves before entering their two-factor authentication code. The severity of this issue depends on which type of session storage you have configured: in the worst case, if you're using Django's default database session storage, then users' passwords are stored in clear text in your database. In the best case, if you're using Django's signed cookie session, then users' passwords are only stored in clear text within their browser's cookie store. In the common case of using Django's cache session store, the users' passwords are stored in clear text in whatever cache storage you have configured (typically Memcached or Redis). This has been fixed in 1.12. After upgrading, users should be sure to delete any clear text passwords that have been stored. For example, if you're using the database session backend, you'll likely want to delete any session record from the database and purge that data from any database backups or replicas. In addition, affected organizations who have suffered a database breach while using an affected version should inform their users that their clear text passwords have been compromised. All organizations should encourage users whose passwords were insecurely stored to change these passwords on any sites where they were used. As a workaround, wwitching Django's session storage to use signed cookies instead of the database or cache lessens the impact of this issue, but should not be done without a thorough understanding of the security tradeoffs of using signed cookies rather than a server-side session storage. There is no way to fully mitigate the issue without upgrading.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-07-10T21:15:10.950",
    "last_modified": "2024-11-21T05:04:49.277",
    "fix_date": "2020-07-08T19:11:38Z"
  },
  "references": [
    {
      "url": "https://github.com/Bouke/django-two-factor-auth/blob/master/CHANGELOG.md#112---2020-07-08",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Bouke/django-two-factor-auth/commit/454fd9842fa6e8bb772dbf0943976bc8e3335359",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Bouke/django-two-factor-auth/security/advisories/GHSA-vhr6-pvjm-9qwf",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Bouke/django-two-factor-auth/blob/master/CHANGELOG.md#112---2020-07-08",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Bouke/django-two-factor-auth/commit/454fd9842fa6e8bb772dbf0943976bc8e3335359",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Bouke/django-two-factor-auth/security/advisories/GHSA-vhr6-pvjm-9qwf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:01.360454",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "django-two-factor-auth",
    "owner": "Bouke",
    "created_at": "2012-09-11T13:25:14Z",
    "updated_at": "2025-01-14T04:53:04Z",
    "pushed_at": "2025-01-13T17:42:55Z",
    "size": 1981,
    "stars": 1733,
    "forks": 448,
    "open_issues": 109,
    "watchers": 1733,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Python": 283485,
      "HTML": 21411,
      "JavaScript": 3720,
      "Makefile": 1211
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T16:27:24.204556"
  }
}