{
  "cve_id": "CVE-2020-15121",
  "github_data": {
    "repository": "radareorg/radare2",
    "fix_commit": "04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9",
    "related_commits": [
      "04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9",
      "04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9"
    ],
    "patch_url": "https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9.patch",
    "fix_commit_details": {
      "sha": "04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9",
      "commit_date": "2020-06-10T16:00:00Z",
      "author": {
        "login": "GustavoLCR",
        "type": "User",
        "stats": {
          "total_commits": 270,
          "average_weekly_commits": 0.3241296518607443,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 83
        }
      },
      "commit_message": {
        "title": "Fix command injection on PDB download (#16966)",
        "length": 1044,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 630,
        "additions": 370,
        "deletions": 260
      },
      "files": [
        {
          "filename": "libr/bin/pdb/pdb_downloader.c",
          "status": "modified",
          "additions": 83,
          "deletions": 108,
          "patch": "@@ -18,150 +18,107 @@ static bool checkExtract() {\n \treturn true;\n }\n \n-static bool checkCurl() {\n-\tconst char nul[] = R_SYS_DEVNULL;\n-\tif (r_sys_cmdf (\"curl --version > %s\", nul) != 0) {\n+static bool download_and_write(SPDBDownloaderOpt *opt, const char *file) {\n+\tchar *dir = r_str_newf (\"%s%s%s%s%s\",\n+\t\topt->symbol_store_path, R_SYS_DIR,\n+\t\topt->dbg_file, R_SYS_DIR,\n+\t\topt->guid);\n+\tif (!r_sys_mkdirp (dir)) {\n+\t\tfree (dir);\n \t\treturn false;\n \t}\n+\tchar *url = r_str_newf (\"%s/%s/%s/%s\", opt->symbol_server, opt->dbg_file, opt->guid, file);\n+\tint len;\n+\tchar *file_buf = r_socket_http_get (url, NULL, &len);\n+\tfree (url);\n+\tif (!len || R_STR_ISEMPTY (file_buf)) {\n+\t\tfree (dir);\n+\t\tfree (file_buf);\n+\t\treturn false;\n+\t}\n+\tchar *path = r_str_newf (\"%s%s%s\", dir, R_SYS_DIR, opt->dbg_file);\n+\tFILE *f = fopen (path, \"wb\");\n+\tif (f) {\n+\t\tfwrite (file_buf, sizeof (char), (size_t)len, f);\n+\t\tfclose (f);\n+\t}\n+\tfree (dir);\n+\tfree (path);\n+\tfree (file_buf);\n \treturn true;\n }\n \n static int download(struct SPDBDownloader *pd) {\n \tSPDBDownloaderOpt *opt = pd->opt;\n-\tchar *curl_cmd = NULL;\n-\tchar *extractor_cmd = NULL;\n-\tchar *abspath_to_archive = NULL;\n-\tchar *abspath_to_file = NULL;\n-\tchar *archive_name = NULL;\n-\tsize_t archive_name_len = 0;\n-\tchar *symbol_store_path = NULL;\n-\tchar *dbg_file = NULL;\n-\tchar *guid = NULL;\n-\tchar *archive_name_escaped  = NULL;\n-\tchar *user_agent = NULL;\n-\tchar *symbol_server = NULL;\n-\n \tint res = 0;\n \tint cmd_ret;\n+\n \tif (!opt->dbg_file || !*opt->dbg_file) {\n \t\t// no pdb debug file\n \t\treturn 0;\n \t}\n-\tif (!checkCurl ()) {\n-\t\treturn 0;\n-\t}\n-\t// dbg_file len is > 0\n-\tarchive_name_len = strlen (opt->dbg_file);\n-\tarchive_name = malloc (archive_name_len + 1);\n-\tif (!archive_name) {\n-\t\treturn 0;\n-\t}\n-\tmemcpy (archive_name, opt->dbg_file, archive_name_len + 1);\n-\tarchive_name[archive_name_len - 1] = '_';\n-\tsymbol_store_path = r_str_escape (opt->symbol_store_path);\n-\tdbg_file = r_str_escape (opt->dbg_file);\n-\tguid = r_str_escape (opt->guid);\n-\tarchive_name_escaped = r_str_escape (archive_name);\n-\tuser_agent = r_str_escape (opt->user_agent);\n-\tsymbol_server = r_str_escape (opt->symbol_server);\n-\n-\tabspath_to_archive = r_str_newf (\"%s%s%s%s%s%s%s\",\n-\t\t\t    symbol_store_path, R_SYS_DIR,\n-\t\t\t    dbg_file, R_SYS_DIR,\n-\t\t\t    guid, R_SYS_DIR,\n-\t\t\t    archive_name_escaped);\n-\n-\tabspath_to_file = strdup (abspath_to_archive);\n-\tabspath_to_file[strlen (abspath_to_file) - 1] = 'b';\n+\n+\tchar *abspath_to_file = r_str_newf (\"%s%s%s%s%s%s%s\",\n+\t\topt->symbol_store_path, R_SYS_DIR,\n+\t\topt->dbg_file, R_SYS_DIR,\n+\t\topt->guid, R_SYS_DIR,\n+\t\topt->dbg_file);\n+\n \tif (r_file_exists (abspath_to_file)) {\n \t\teprintf (\"File already downloaded.\\n\");\n-\t\tR_FREE (user_agent);\n-\t\tR_FREE (abspath_to_archive);\n-\t\tR_FREE (archive_name_escaped);\n-\t\tR_FREE (symbol_store_path);\n-\t\tR_FREE (dbg_file);\n-\t\tR_FREE (guid);\n-\t\tR_FREE (archive_name);\n-\t\tR_FREE (abspath_to_file);\n-\t\tR_FREE (symbol_server);\n+\t\tfree (abspath_to_file);\n \t\treturn 1;\n \t}\n \n \tif (checkExtract () || opt->extract == 0) {\n-\t\tres = 1;\n-\n-\t\tcurl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",\n-\t\t                       user_agent,\n-\t\t                       symbol_server,\n-\t\t\t\t\t\t\t   dbg_file,\n-\t\t\t\t\t\t\t   guid,\n-\t\t                       archive_name_escaped,\n-\t\t                       abspath_to_archive);\n+\t\tchar *extractor_cmd = NULL;\n+\t\tchar *archive_name = strdup (opt->dbg_file);\n+\t\tarchive_name[strlen (archive_name) - 1] = '_';\n+\t\tchar *abspath_to_archive = r_str_newf (\"%s%s%s%s%s%s%s\",\n+\t\t\topt->symbol_store_path, R_SYS_DIR,\n+\t\t\topt->dbg_file, R_SYS_DIR,\n+\t\t\topt->guid, R_SYS_DIR,\n+\t\t\tarchive_name);\n+\n+\t\teprintf (\"Attempting to download compressed pdb in %s\\n\", abspath_to_archive);\n+\t\tchar *abs_arch_esc = r_str_escape_sh (abspath_to_archive);\n #if __WINDOWS__\n-\t\tconst char *cabextractor = \"expand\";\n-\t\tconst char *format = \"%s %s %s\";\n-\n-\t\t// extractor_cmd -> %1 %2 %3\n-\t\t// %1 - 'expand'\n-\t\t// %2 - absolute path to archive\n-\t\t// %3 - absolute path to file that will be dearchive\n-\t\textractor_cmd = r_str_newf (format, cabextractor,\n-\t\t\tabspath_to_archive, abspath_to_file);\n+\t\tchar *abs_file_esc = r_str_escape_sh (abspath_to_file);\n+\t\t// expand %1 %2\n+\t\t// %1 - absolute path to archive\n+\t\t// %2 - absolute path to file that will be dearchive\n+\t\textractor_cmd = r_str_newf (\"expand \\\"%s\\\" \\\"%s\\\"\", abs_arch_esc, abs_file_esc);\n+\t\tfree (abs_file_esc);\n #else\n-\t\tconst char *cabextractor = \"cabextract\";\n-\t\tconst char *format = \"%s -d \\\"%s\\\" \\\"%s\\\"\";\n \t\tchar *abspath_to_dir = r_file_dirname (abspath_to_archive);\n+\t\tchar *abs_dir_esc = r_str_escape_sh (abspath_to_dir);\n \t\t// cabextract -d %1 %2\n \t\t// %1 - path to directory where to extract all files from cab archive\n \t\t// %2 - absolute path to cab archive\n-\t\textractor_cmd = r_str_newf (format, cabextractor, abspath_to_dir, abspath_to_archive);\n-\t\tR_FREE (abspath_to_dir);\n+\t\textractor_cmd = r_str_newf (\"cabextract -d \\\"%s\\\" \\\"%s\\\"\", abs_arch_esc, abs_dir_esc);\n+\t\tfree (abs_dir_esc);\n+\t\tfree (abspath_to_dir);\n #endif\n-\t\teprintf (\"Attempting to download compressed pdb in %s\\n\", abspath_to_archive);\n-\t\tif ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {\n-\t\t\teprintf(\"curl exited with error %d\\n\", cmd_ret);\n-\t\t\tres = 0;\n-\t\t}\n-\t\teprintf (\"Attempting to decompress pdb\\n\");\n-\t\tif (opt->extract > 0) {\n+\t\tfree (abs_arch_esc);\n+\t\tres = download_and_write (opt, archive_name);\n+\n+\t\tif (opt->extract > 0 && res) {\n+\t\t\teprintf (\"Attempting to decompress pdb\\n\");\n \t\t\tif (res && ((cmd_ret = r_sys_cmd (extractor_cmd)) != 0)) {\n \t\t\t\teprintf (\"cab extractor exited with error %d\\n\", cmd_ret);\n \t\t\t\tres = 0;\n \t\t\t}\n \t\t\tr_file_rm (abspath_to_archive);\n \t\t}\n-\t\tR_FREE (curl_cmd);\n+\t\tfree (archive_name);\n+\t\tfree (abspath_to_archive);\n \t}\n \tif (res == 0) {\n \t\teprintf (\"Falling back to uncompressed pdb\\n\");\n-\t\tres = 1;\n-\n-\t\tarchive_name_escaped[strlen (archive_name_escaped) - 1] = 'b';\n-\n-\t\tcurl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",\n-\t\t                       opt->user_agent,\n-\t\t                       opt->symbol_server,\n-\t\t                       opt->dbg_file,\n-\t\t                       opt->guid,\n-\t\t                       archive_name_escaped,\n-\t\t                       abspath_to_file);\n \t\teprintf (\"Attempting to download uncompressed pdb in %s\\n\", abspath_to_file);\n-\t\tif ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {\n-\t\t\teprintf(\"curl exited with error %d\\n\", cmd_ret);\n-\t\t\tres = 0;\n-\t\t}\n-\t\tR_FREE (curl_cmd);\n-\t}\n-\tR_FREE (abspath_to_archive);\n-\tR_FREE (abspath_to_file);\n-\tR_FREE (archive_name);\n-\tR_FREE (extractor_cmd);\n-\tR_FREE (symbol_store_path);\n-\tR_FREE (dbg_file);\n-\tR_FREE (guid);\n-\tR_FREE (archive_name_escaped);\n-\tR_FREE (user_agent);\n-\tR_FREE (symbol_server);\n+\t\tres = download_and_write (opt, opt->dbg_file);\n+\t}\n+\tfree (abspath_to_file);\n \treturn res;\n }\n \n@@ -191,6 +148,19 @@ void deinit_pdb_downloader(SPDBDownloader *pd) {\n \tpd->download = 0;\n }\n \n+static bool is_valid_guid(const char *guid) {\n+\tif (!guid) {\n+\t\treturn false;\n+\t}\n+\tsize_t i;\n+\tfor (i = 0; guid[i]; i++) {\n+\t\tif (!isxdigit (guid[i])) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\treturn i >= 33; // len of GUID and age\n+}\n+\n int r_bin_pdb_download(RCore *core, int isradjson, int *actions_done, SPDBOptions *options) {\n \tint ret;\n \tSPDBDownloaderOpt opt;\n@@ -202,6 +172,11 @@ int r_bin_pdb_download(RCore *core, int isradjson, int *actions_done, SPDBOption\n \t\treturn 1;\n \t}\n \n+\tif (!is_valid_guid (info->guid)) {\n+\t\teprintf (\"Invalid GUID for file\\n\");\n+\t\treturn 1;\n+\t}\n+\n \tif (!options || !options->symbol_server || !options->user_agent) {\n \t\teprintf (\"Can't retrieve pdb configurations\\n\");\n \t\treturn 1;"
        },
        {
          "filename": "libr/config.mk.tail",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -52,6 +52,11 @@ CFLAGS+=-DHAVE_LIB_GMP=1\n BN_LIBS=-lgmp\n endif\n \n+# open-ssl\n+ifeq (${HAVE_LIB_SSL},1)\n+BN_LIBS=${SSL_LDFLAGS}\n+endif\n+\n #both of these need ssl includes\n ifneq (,$(filter r_socket r_util,$(BINDEPS)))\n ifeq (${HAVE_LIB_SSL},1)"
        },
        {
          "filename": "libr/include/r_socket.h",
          "status": "modified",
          "additions": 0,
          "deletions": 5,
          "patch": "@@ -1,11 +1,6 @@\n #ifndef R2_SOCKET_H\n #define R2_SOCKET_H\n \n-/* Must be included before windows.h (r_types) */\n-#if defined(__WINDOWS__)\n-#include <ws2tcpip.h>\n-#endif\n-\n #include \"r_types.h\"\n #include \"r_bind.h\"\n #include \"r_list.h\""
        },
        {
          "filename": "libr/include/r_types.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -152,6 +152,7 @@\n   #ifdef _MSC_VER\n   /* Must be included before windows.h */\n   #include <winsock2.h>\n+  #include <ws2tcpip.h>\n   #ifndef WIN32_LEAN_AND_MEAN\n   #define WIN32_LEAN_AND_MEAN\n   #endif"
        },
        {
          "filename": "libr/include/r_util/r_str.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -148,6 +148,7 @@ R_API int r_str_path_unescape(char *path);\n R_API char *r_str_path_escape(const char *path);\n R_API int r_str_unescape(char *buf);\n R_API char *r_str_escape(const char *buf);\n+R_API char *r_str_escape_sh(const char *buf);\n R_API char *r_str_escape_dot(const char *buf);\n R_API char *r_str_escape_latin1(const char *buf, bool show_asciidot, bool esc_bslash, bool colors);\n R_API char *r_str_escape_utf8(const char *buf, bool show_asciidot, bool esc_bslash);"
        },
        {
          "filename": "libr/socket/socket.c",
          "status": "modified",
          "additions": 48,
          "deletions": 99,
          "patch": "@@ -260,80 +260,30 @@ R_API bool r_socket_spawn(RSocket *s, const char *cmd, unsigned int timeout) {\n R_API bool r_socket_connect(RSocket *s, const char *host, const char *port, int proto, unsigned int timeout) {\n \tr_return_val_if_fail (s, false);\n #if __WINDOWS__\n+#define gai_strerror gai_strerrorA\n \tstruct sockaddr_in sa;\n-\tstruct hostent *he;\n \tWSADATA wsadata;\n-\tTIMEVAL Timeout;\n-\tTimeout.tv_sec = timeout;\n-\tTimeout.tv_usec = 0;\n \n \tif (WSAStartup (MAKEWORD (1, 1), &wsadata) == SOCKET_ERROR) {\n \t\teprintf (\"Error creating socket.\");\n \t\treturn false;\n \t}\n-\ts->fd = socket (AF_INET, SOCK_STREAM, 0);\n-\tif (s->fd == R_INVALID_SOCKET) {\n-\t\treturn false;\n-\t}\n-\n-\tunsigned long iMode = 1;\n-\tint iResult = ioctlsocket (s->fd, FIONBIO, &iMode);\n-\tif (iResult != NO_ERROR) {\n-\t\teprintf (\"ioctlsocket error: %d\\n\", iResult);\n-\t}\n-\tmemset (&sa, 0, sizeof (sa));\n-\tsa.sin_family = AF_INET;\n-\the = (struct hostent *)gethostbyname (host);\n-\tif (he == (struct hostent*)0) {\n-#ifdef _MSC_VER\n-\t\tclosesocket (s->fd);\n-#else\n-\t\tclose (s->fd);\n #endif\n-\t\treturn false;\n-\t}\n-\tsa.sin_addr = *((struct in_addr *)he->h_addr);\n-\ts->port = r_socket_port_by_name (port);\n-\ts->proto = proto;\n-\tsa.sin_port = htons (s->port);\n-\tif (!connect (s->fd, (const struct sockaddr*)&sa, sizeof (struct sockaddr))) {\n-#ifdef _MSC_VER\n-\t\tclosesocket (s->fd);\n-#else\n-\t\tclose (s->fd);\n-#endif\n-\t\treturn false;\n-\t}\n-\tiMode = 0;\n-\tiResult = ioctlsocket (s->fd, FIONBIO, &iMode);\n-\tif (iResult != NO_ERROR) {\n-\t\teprintf (\"ioctlsocket error: %d\\n\", iResult);\n-\t}\n-\tif (timeout > 0) {\n-\t\tr_socket_block_time (s, 1, timeout, 0);\n-\t}\n-\tfd_set Write, Err;\n-\tFD_ZERO (&Write);\n-\tFD_ZERO (&Err);\n-\tFD_SET (s->fd, &Write);\n-\tFD_SET (s->fd, &Err);\n-\tselect (0, NULL, &Write, &Err, &Timeout);\n-\tif (FD_ISSET (s->fd, &Write)) {\n-\t\treturn true;\n-\t}\n-\treturn false;\n-#elif __UNIX__\n \tint ret;\n-\tstruct addrinfo hints = {0};\n+\tstruct addrinfo hints = { 0 };\n \tstruct addrinfo *res, *rp;\n \tif (!proto) {\n \t\tproto = R_SOCKET_PROTO_TCP;\n \t}\n+#if __UNIX__\n \tr_sys_signal (SIGPIPE, SIG_IGN);\n+#endif\n \tif (proto == R_SOCKET_PROTO_UNIX) {\n+#if __UNIX__\n \t\tif (!__connect_unix (s, host)) {\n \t\t\treturn false;\n \t\t}\n+#endif\n \t} else {\n \t\thints.ai_family = AF_UNSPEC; /* Allow IPv4 or IPv6 */\n \t\thints.ai_protocol = proto;\n@@ -367,17 +317,15 @@ R_API bool r_socket_connect(RSocket *s, const char *host, const char *port, int\n \t\t\t\treturn true;\n \t\t\t}\n \t\t\tif (errno == EINPROGRESS) {\n-\t\t\t\tstruct timeval tv;\n-\t\t\t\ttv.tv_sec = timeout;\n-\t\t\t\ttv.tv_usec = 0;\n+\t\t\t\tstruct timeval tv = {timeout, 0};\n \t\t\t\tfd_set wfds;\n-\t\t\t\tFD_ZERO(&wfds);\n-\t\t\t\tFD_SET(s->fd, &wfds);\n+\t\t\t\tFD_ZERO (&wfds);\n+\t\t\t\tFD_SET (s->fd, &wfds);\n \n \t\t\t\tif ((ret = select (s->fd + 1, NULL, &wfds, NULL, &tv)) != -1) {\n \t\t\t\t\tif (r_socket_is_connected (s)) {\n \t\t\t\t\t\tfreeaddrinfo (res);\n-\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\tgoto success;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tperror (\"connect\");\n@@ -391,18 +339,42 @@ R_API bool r_socket_connect(RSocket *s, const char *host, const char *port, int\n \t\t\treturn false;\n \t\t}\n \t}\n-#endif\n+success:\n #if HAVE_LIB_SSL\n \tif (s->is_ssl) {\n \t\ts->ctx = SSL_CTX_new (SSLv23_client_method ());\n \t\tif (!s->ctx) {\n-\t\t\tr_socket_free (s);\n+\t\t\tr_socket_close (s);\n \t\t\treturn false;\n \t\t}\n \t\ts->sfd = SSL_new (s->ctx);\n \t\tSSL_set_fd (s->sfd, s->fd);\n-\t\tif (SSL_connect (s->sfd) != 1) {\n-\t\t\tr_socket_free (s);\n+\t\tint ret = SSL_connect (s->sfd);\n+\t\tif (ret != 1) {\n+\t\t\tint error = SSL_get_error (s->sfd, ret);\n+\t\t\tint tries = 10;\n+\t\t\twhile (tries && ret && (error == SSL_ERROR_WANT_READ || error == SSL_ERROR_WANT_WRITE)) {\n+\t\t\t\tstruct timeval tv = {1, 0};\n+\t\t\t\tfd_set rfds, wfds;\n+\t\t\t\tFD_ZERO (&rfds);\n+\t\t\t\tFD_ZERO (&wfds);\n+\t\t\t\tif (error == SSL_ERROR_WANT_READ) {\n+\t\t\t\t\tFD_SET (s->fd, &rfds);\n+\t\t\t\t} else {\n+\t\t\t\t\tFD_SET (s->fd, &wfds);\n+\t\t\t\t}\n+\t\t\t\tif ((ret = select (s->fd + 1, &rfds, &wfds, NULL, &tv)) < 1) {\n+\t\t\t\t\tr_socket_close (s);\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tret = SSL_connect (s->sfd);\n+\t\t\t\tif (ret == 1) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t\terror = SSL_get_error (s->sfd, ret);\n+\t\t\t\ttries--;\n+\t\t\t}\n+\t\t\tr_socket_close (s);\n \t\t\treturn false;\n \t\t}\n \t}\n@@ -622,9 +594,7 @@ R_API RSocket *r_socket_accept_timeout(RSocket *s, unsigned int timeout) {\n \tFD_ZERO (&except_fds);\n \tFD_SET (s->fd, &except_fds);\n \n-\tstruct timeval t;\n-\tt.tv_sec = timeout;\n-\tt.tv_usec = 0;\n+\tstruct timeval t = {timeout, 0};\n \n \tint r = select (s->fd + 1, &read_fds, NULL, &except_fds, &t);\n \tif(r < 0) {\n@@ -659,9 +629,7 @@ R_API int r_socket_block_time(RSocket *s, int block, int sec, int usec) {\n \tioctlsocket (s->fd, FIONBIO, (u_long FAR*)&block);\n #endif\n \tif (sec > 0 || usec > 0) {\n-\t\tstruct timeval tv = {0};\n-\t\ttv.tv_sec = sec;\n-\t\ttv.tv_usec = usec;\n+\t\tstruct timeval tv = {sec, usec};\n \t\tif (setsockopt (s->fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof (tv)) < 0) {\n \t\t\treturn false;\n \t\t}\n@@ -678,32 +646,17 @@ R_API int r_socket_flush(RSocket *s) {\n \treturn true;\n }\n \n-// XXX: rewrite it to use select //\n /* waits secs until new data is received.\t  */\n /* returns -1 on error, 0 is false, 1 is true */\n R_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n-#if __UNIX__\n-\t//int msecs = (1000 * secs) + (usecs / 1000);\n-\tint msecs = (usecs / 1000);\n-\tstruct pollfd fds[1];\n-\tfds[0].fd = s->fd;\n-\tfds[0].events = POLLIN | POLLPRI;\n-\tfds[0].revents = POLLNVAL | POLLHUP | POLLERR;\n-\treturn poll ((struct pollfd *)&fds, 1, msecs);\n-#elif __WINDOWS__\n \tfd_set rfds;\n-\tstruct timeval tv;\n+\tstruct timeval tv = {secs, usecs};\n \tif (s->fd == R_INVALID_SOCKET) {\n \t\treturn -1;\n \t}\n \tFD_ZERO (&rfds);\n \tFD_SET (s->fd, &rfds);\n-\ttv.tv_sec = secs;\n-\ttv.tv_usec = usecs;\n \treturn select (s->fd + 1, &rfds, NULL, NULL, &tv);\n-#else\n-\treturn true; /* always ready if unknown */\n-#endif\n }\n \n R_API char *r_socket_to_string(RSocket *s) {\n@@ -794,28 +747,24 @@ R_API int r_socket_read(RSocket *s, unsigned char *buf, int len) {\n \t\treturn SSL_read (s->sfd, buf, len);\n \t}\n #endif\n-#if __WINDOWS__\n-rep:\n-\t{\n-\tint ret = recv (s->fd, (void *)buf, len, 0);\n-\tif (ret == -1) {\n-\t\tgoto rep;\n-\t}\n-\treturn ret;\n-\t}\n-#else\n \t// int r = read (s->fd, buf, len);\n \tint r = recv (s->fd, buf, len, 0);\n \tD { eprintf (\"READ \"); int i; for (i = 0; i<len; i++) { eprintf (\"%02x \", buf[i]); } eprintf (\"\\n\"); }\n \treturn r;\n-#endif\n }\n \n R_API int r_socket_read_block(RSocket *s, ut8 *buf, int len) {\n \tint ret = 0;\n \tfor (ret = 0; ret < len; ) {\n \t\tint r = r_socket_read (s, buf + ret, len - ret);\n \t\tif (r == -1) {\n+#if HAVE_LIB_SSL\n+\t\t\tif (SSL_get_error (s->sfd, r) == SSL_ERROR_WANT_READ) {\n+\t\t\t\tif (r_socket_ready (s, 1, 0) == 1) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+#endif\n \t\t\treturn -1;\n \t\t}\n \t\tif (r < 1) {"
        },
        {
          "filename": "libr/socket/socket_http.c",
          "status": "modified",
          "additions": 151,
          "deletions": 36,
          "patch": "@@ -3,45 +3,81 @@\n #include <r_socket.h>\n #include <r_util.h>\n \n-static int __socket_slurp (RSocket *s, ut8 *buf, int bufsz) {\n-\tint i;\n-\tint chsz = 1;\n-\t// r_socket_block_time (s, 1, 1, 0);\n-\tif (r_socket_read_block (s, (ut8 *) buf, 1) != 1) {\n+#if __WINDOWS__\n+#include <WinInet.h>\n+#endif\n+\n+#define SOCKET_HTTP_MAX_HEADER_LENGTH 0x2000\n+#define SOCKET_HTTP_MAX_REDIRECTS 5\n+\n+static size_t socket_slurp(RSocket *s, RBuffer *buf) {\n+\tsize_t i;\n+\tif (r_socket_ready (s, 1, 0) != 1) {\n \t\treturn 0;\n \t}\n-\tfor (i = 1; i < bufsz; i += chsz) {\n-\t\tbuf[i] =0;\n-\t\tr_socket_block_time (s, 1, 0, 1000);\n-\t\tint olen = r_socket_read_block (s, (ut8 *) buf + i , chsz);\n-\t\tif (olen != chsz) {\n-\t\t\tbuf[i] = 0;\n+\tr_socket_block_time (s, 1, 0, 1000);\n+\tfor (i = 0; i < SOCKET_HTTP_MAX_HEADER_LENGTH; i += 1) {\n+\t\tut8 c;\n+\t\tint olen = r_socket_read_block (s, &c, 1);\n+\t\tif (olen != 1) {\n+\t\t\tr_buf_append_bytes (buf, (ut8 *)\"\", 1);\n \t\t\tbreak;\n \t\t}\n+\t\tr_buf_append_bytes (buf, &c, 1);\n \t}\n \treturn i;\n }\n \n-static char *r_socket_http_answer (RSocket *s, int *code, int *rlen) {\n+static char *socket_http_get_recursive(const char *url, int *code, int *rlen, ut32 redirections);\n+\n+static char *socket_http_answer(RSocket *s, int *code, int *rlen, ut32 redirections) {\n \tr_return_val_if_fail (s, NULL);\n \tconst char *p;\n-\tint ret, len = 0, bufsz = 32768, delta = 0;\n-\tchar *dn, *buf = calloc (1, bufsz + 32); // XXX: use r_buffer here\n-\tif (!buf) {\n+\tint ret, len = 0, delta = 0;\n+\tchar *dn;\n+\tRBuffer *b = r_buf_new ();\n+\tif (!b) {\n \t\treturn NULL;\n \t}\n \tchar *res = NULL;\n-\tint olen = __socket_slurp (s, (ut8*)buf, bufsz);\n+\tsize_t olen = socket_slurp (s, b);\n+\tchar *buf = malloc (olen + 1);\n+\tif (!buf) {\n+\t\tgoto exit;\n+\t}\n+\tr_buf_read_at (b, 0, (ut8 *)buf, olen);\n+\tbuf[olen] = 0;\n \tif ((dn = (char*)r_str_casestr (buf, \"\\n\\n\"))) {\n \t\tdelta += 2;\n \t} else if ((dn = (char*)r_str_casestr (buf, \"\\r\\n\\r\\n\"))) {\n \t\tdelta += 4;\n \t} else {\n-\t\tgoto fail;\n+\t\tgoto exit;\n \t}\n \n \tolen -= delta;\n \t*dn = 0; // chop headers\n+\n+\t/* Follow redirects */\n+\tp = r_str_casestr (buf, \"Location:\");\n+\tif (p) {\n+\t\tif (!redirections) {\n+\t\t\teprintf (\"Too many redirects\\n\");\n+\t\t\tgoto exit;\n+\t\t}\n+\t\tp += strlen (\"Location:\");\n+\t\tchar *end_url = strchr (p, '\\n');\n+\t\tif (end_url) {\n+\t\t\tint url_len = end_url - p;\n+\t\t\tchar *url = r_str_ndup (p, url_len);\n+\t\t\tr_str_trim (url);\n+\t\t\tres = socket_http_get_recursive (url, code, rlen, --redirections);\n+\t\t\tfree (url);\n+\t\t\tlen = *rlen;\n+\t\t}\n+\t\tgoto exit;\n+\t}\n+\n \t/* Parse Len */\n \tp = r_str_casestr (buf, \"Content-Length: \");\n \tif (p) {\n@@ -52,6 +88,10 @@ static char *r_socket_http_answer (RSocket *s, int *code, int *rlen) {\n \tif (len > 0) {\n \t\tif (len > olen) {\n \t\t\tres = malloc (len + 2);\n+\t\t\tif (!res) {\n+\t\t\t\tgoto exit;\n+\t\t\t}\n+\t\t\tolen -= dn - buf;\n \t\t\tmemcpy (res, dn + delta, olen);\n \t\t\tdo {\n \t\t\t\tret = r_socket_read_block (s, (ut8*) res + olen, len - olen);\n@@ -71,48 +111,118 @@ static char *r_socket_http_answer (RSocket *s, int *code, int *rlen) {\n \t} else {\n \t\tres = NULL;\n \t}\n-fail:\n+exit:\n \tfree (buf);\n-// is 's' free'd? isn't this going to cause a double free?\n+\tr_buf_free (b);\n \tr_socket_close (s);\n \tif (rlen) {\n \t\t*rlen = len;\n \t}\n \treturn res;\n }\n \n-R_API char *r_socket_http_get(const char *url, int *code, int *rlen) {\n+#if __WINDOWS__\n+static char *http_get_w32(const char *url, int *code, int *rlen) {\n+\tHINTERNET hInternet = InternetOpenA (\"radare2 \"R2_VERSION, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);\n+\tif (!hInternet) {\n+\t\tr_sys_perror (\"InternetOpenA\");\n+\t\treturn NULL;\n+\t}\n+\tHINTERNET hOpenUrl = InternetOpenUrlA (hInternet, url, NULL, 0, 0, 0);\n+\tif (!hOpenUrl) {\n+\t\tr_sys_perror (\"InternetOpenUrlA\");\n+\t\tInternetCloseHandle (hInternet);\n+\t\treturn NULL;\n+\t}\n+\n+\tchar *ret = NULL;\n+\tsize_t read_sz = 0x100000;\n+\tDWORD r = 0, w = 0;\n+\tbool res = true;\n+\tdo {\n+\t\tw += r;\n+\t\tif (!res && GetLastError () == ERROR_INSUFFICIENT_BUFFER) {\n+\t\t\tread_sz *= 2;\n+\t\t}\n+\t\tchar *tmp = realloc (ret, read_sz + w);\n+\t\tif (!tmp) {\n+\t\t\tR_FREE (ret);\n+\t\t\tgoto exit;\n+\t\t}\n+\t\tret = tmp;\n+\t} while (!(res = InternetReadFile (hOpenUrl, ret + w, read_sz, &r)) || r);\n+\n+\tif (w) {\n+\t\tchar *tmp = realloc (ret, (size_t)w + 1);\n+\t\tif (tmp) {\n+\t\t\tret = tmp;\n+\t\t\tret[w] = 0;\n+\t\t} else {\n+\t\t\tR_FREE (ret);\n+\t\t}\n+\t} else {\n+\t\tR_FREE (ret);\n+\t}\n+\n+exit:\n+\tif (rlen) {\n+\t\t*rlen = w;\n+\t}\n+\tif (code && w) {\n+\t\t*code = 200;\n+\t}\n+\tInternetCloseHandle (hInternet);\n+\tInternetCloseHandle (hOpenUrl);\n+\treturn ret;\n+}\n+#endif\n+\n+static char *socket_http_get_recursive(const char *url, int *code, int *rlen, ut32 redirections) {\n+\tif (code) {\n+\t\t*code = 0;\n+\t}\n+\tif (rlen) {\n+\t\t*rlen = 0;\n+\t}\n \tchar *curl_env = r_sys_getenv (\"R2_CURL\");\n-\tif (curl_env && *curl_env) {\n-\t\tchar *encoded_url = r_str_escape (url);\n-\t\tchar *res = r_sys_cmd_strf (\"curl '%s'\", encoded_url);\n-\t\tfree (encoded_url);\n+\tif (!R_STR_ISEMPTY (curl_env) && atoi (curl_env)) {\n+\t\tint len;\n+\t\tchar *escaped_url = r_str_escape_sh (url);\n+\t\tchar *command = r_str_newf (\"curl -sfL -o - \\\"%s\\\"\", escaped_url);\n+\t\tchar *res = r_sys_cmd_str (command, NULL, &len);\n+\t\tfree (escaped_url);\n+\t\tfree (command);\n+\t\tfree (curl_env);\n+\t\tif (!res) {\n+\t\t\treturn NULL;\n+\t\t}\n \t\tif (res) {\n \t\t\tif (code) {\n \t\t\t\t*code = 200;\n \t\t\t}\n \t\t\tif (rlen) {\n-\t\t\t\t*rlen = strlen (res);\n+\t\t\t\t*rlen = len;\n \t\t\t}\n \t\t}\n-\t\tfree (curl_env);\n \t\treturn res;\n \t}\n \tfree (curl_env);\n+#if __WINDOWS__\n+\treturn http_get_w32 (url, code, rlen);\n+#else\n \tRSocket *s;\n \tint ssl = r_str_startswith (url, \"https://\");\n+#if !HAVE_LIB_SSL\n+\tif (ssl) {\n+\t\teprintf (\"Tried to get '%s', but SSL support is disabled, set R2_CURL=1 to use curl\\n\", url);\n+\t\treturn NULL;\n+\t}\n+#endif\n \tchar *response, *host, *path, *port = \"80\";\n \tchar *uri = strdup (url);\n \tif (!uri) {\n \t\treturn NULL;\n \t}\n-\n-\tif (code) {\n-\t\t*code = 0;\n-\t}\n-\tif (rlen) {\n-\t\t*rlen = 0;\n-\t}\n \thost = strstr (uri, \"://\");\n \tif (!host) {\n \t\tfree (uri);\n@@ -147,17 +257,22 @@ R_API char *r_socket_http_get(const char *url, int *code, int *rlen) {\n \t\t\t\t\"Accept: */*\\r\\n\"\n \t\t\t\t\"Host: %s:%s\\r\\n\"\n \t\t\t\t\"\\r\\n\", path, host, port);\n-\t\tresponse = r_socket_http_answer (s, code, rlen);\n+\t\tresponse = socket_http_answer (s, code, rlen, redirections);\n \t} else {\n \t\teprintf (\"Cannot connect to %s:%s\\n\", host, port);\n \t\tresponse = NULL;\n \t}\n \tfree (uri);\n \tr_socket_free (s);\n \treturn response;\n+#endif\n+}\n+\n+R_API char *r_socket_http_get(const char *url, int *code, int *rlen) {\n+\treturn socket_http_get_recursive (url, code, rlen, SOCKET_HTTP_MAX_REDIRECTS);\n }\n \n-R_API char *r_socket_http_post (const char *url, const char *data, int *code, int *rlen) {\n+R_API char *r_socket_http_post(const char *url, const char *data, int *code, int *rlen) {\n \tRSocket *s;\n \tbool ssl = r_str_startswith (url, \"https://\");\n \tchar *uri = strdup (url);\n@@ -206,7 +321,7 @@ R_API char *r_socket_http_post (const char *url, const char *data, int *code, in\n \t\t\t\"\\r\\n\", path, host, (int)strlen (data));\n \tfree (uri);\n \tr_socket_write (s, (void *)data, strlen (data));\n-\treturn r_socket_http_answer (s, code, rlen);\n+\treturn socket_http_answer (s, code, rlen, 0);\n }\n \n #if TEST"
        },
        {
          "filename": "libr/util/str.c",
          "status": "modified",
          "additions": 28,
          "deletions": 0,
          "patch": "@@ -1351,6 +1351,34 @@ R_API char *r_str_escape(const char *buf) {\n \treturn r_str_escape_ (buf, false, true, true, false, true);\n }\n \n+// Return MUST BE surrounded by double-quotes\n+R_API char *r_str_escape_sh(const char *buf) {\n+\tr_return_val_if_fail (buf, NULL);\n+\tchar *new_buf = malloc (1 + strlen (buf) * 2);\n+\tif (!new_buf) {\n+\t\treturn NULL;\n+\t}\n+\tconst char *p = buf;\n+\tchar *q = new_buf;\n+\twhile (*p) {\n+\t\tswitch (*p) {\n+#if __UNIX__\n+\t\tcase '$':\n+\t\tcase '`':\n+#endif\n+\t\tcase '\\\\':\n+\t\tcase '\"':\n+\t\t\t*q++ = '\\\\';\n+\t\t\t/* FALLTHRU */\n+\t\tdefault:\n+\t\t\t*q++ = *p++;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\t*q = '\\0';\n+\treturn new_buf;\n+}\n+\n R_API char *r_str_escape_dot(const char *buf) {\n \treturn r_str_escape_ (buf, true, true, true, false, true);\n }"
        },
        {
          "filename": "libr/util/sys.c",
          "status": "modified",
          "additions": 28,
          "deletions": 9,
          "patch": "@@ -660,6 +660,7 @@ R_API int r_sys_cmd_str_full(const char *cmd, const char *input, char **output,\n \t\t}\n \t\t// we should handle broken pipes somehow better\n \t\tr_sys_signal (SIGPIPE, SIG_IGN);\n+\t\tsize_t err_len = 0, out_len = 0;\n \t\tfor (;;) {\n \t\t\tfd_set rfds, wfds;\n \t\t\tint nfd;\n@@ -680,20 +681,29 @@ R_API int r_sys_cmd_str_full(const char *cmd, const char *input, char **output,\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tif (output && FD_ISSET (sh_out[0], &rfds)) {\n-\t\t\t\tif (!(bytes = read (sh_out[0], buffer, sizeof (buffer)-1))) {\n+\t\t\t\tif ((bytes = read (sh_out[0], buffer, sizeof (buffer))) < 1) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n-\t\t\t\tbuffer[sizeof (buffer) - 1] = '\\0';\n-\t\t\t\tif (len) {\n-\t\t\t\t\t*len += bytes;\n+\t\t\t\tchar *tmp = realloc (outputptr, out_len + bytes + 1);\n+\t\t\t\tif (!tmp) {\n+\t\t\t\t\tR_FREE (outputptr);\n+\t\t\t\t\tbreak;\n \t\t\t\t}\n-\t\t\t\toutputptr = r_str_append (outputptr, buffer);\n+\t\t\t\toutputptr = tmp;\n+\t\t\t\tmemcpy (outputptr + out_len, buffer, bytes);\n+\t\t\t\tout_len += bytes;\n \t\t\t} else if (FD_ISSET (sh_err[0], &rfds) && sterr) {\n-\t\t\t\tif (!read (sh_err[0], buffer, sizeof (buffer)-1)) {\n+\t\t\t\tif ((bytes = read (sh_err[0], buffer, sizeof (buffer))) < 1) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tchar *tmp = realloc (*sterr, err_len + bytes + 1);\n+\t\t\t\tif (!tmp) {\n+\t\t\t\t\tR_FREE (*sterr);\n \t\t\t\t\tbreak;\n \t\t\t\t}\n-\t\t\t\tbuffer[sizeof (buffer) - 1] = '\\0';\n-\t\t\t\t*sterr = r_str_append (*sterr, buffer);\n+\t\t\t\t*sterr = tmp;\n+\t\t\t\tmemcpy (*sterr + err_len, buffer, bytes);\n+\t\t\t\terr_len += bytes;\n \t\t\t} else if (FD_ISSET (sh_in[1], &wfds) && inputptr && *inputptr) {\n \t\t\t\tint inputptr_len = strlen (inputptr);\n \t\t\t\tbytes = write (sh_in[1], inputptr, inputptr_len);\n@@ -727,6 +737,15 @@ R_API int r_sys_cmd_str_full(const char *cmd, const char *input, char **output,\n \t\t\tret = false;\n \t\t}\n \n+\t\tif (len) {\n+\t\t\t*len = out_len;\n+\t\t}\n+\t\tif (*sterr) {\n+\t\t\t(*sterr)[err_len] = 0;\n+\t\t}\n+\t\tif (outputptr) {\n+\t\t\toutputptr[out_len] = 0;\n+\t\t}\n \t\tif (output) {\n \t\t\t*output = outputptr;\n \t\t} else {\n@@ -829,7 +848,7 @@ R_API bool r_sys_mkdirp(const char *dir) {\n \t{\n \t\tchar *p = strstr (ptr, \":\\\\\");\n \t\tif (p) {\n-\t\t\tptr = p + 2;\n+\t\t\tptr = p + 3;\n \t\t}\n \t}\n #endif"
        },
        {
          "filename": "meson.build",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -112,7 +112,7 @@ endif\n platform_deps = []\n platform_inc = ['.', 'libr/include']\n if host_machine.system() == 'windows'\n-  platform_deps = [cc.find_library('ws2_32'), cc.find_library('psapi')]\n+  platform_deps = [cc.find_library('ws2_32'), cc.find_library('wininet'), cc.find_library('psapi')]\n endif\n platform_inc = include_directories(platform_inc)\n "
        },
        {
          "filename": "shlr/sdb/src/disk.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -64,7 +64,7 @@ static inline int r_sys_mkdirp(char *dir) {\n #if __SDB_WINDOWS__\n \tchar *p = strstr (ptr, \":\\\\\");\n \tif (p) {\n-\t\tptr = p + 2;\n+\t\tptr = p + 3;\n \t}\n #endif\n \twhile ((ptr = strchr (ptr, slash))) {"
        },
        {
          "filename": "test/db/formats/pdb",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -1,6 +1,9 @@\n NAME=PDB downloader check\n FILE=bins/pdb/user32.dll\n-CMDS=!!rabin2 -PP ${R2_FILE} ~PDB\n+CMDS=<<EOF\n+%R2_CURL=1\n+!!rabin2 -PP ${R2_FILE} ~PDB\n+EOF\n EXPECT=<<EOF\n PDB \"user32.pdb\" download success\n EOF"
        },
        {
          "filename": "test/unit/test_str.c",
          "status": "modified",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -336,6 +336,24 @@ bool test_r_str_sanitize_sdb_key(void) {\n \tmu_end;\n }\n \n+bool test_r_str_escape_sh(void) {\n+\tchar *escaped = r_str_escape_sh (\"Hello, \\\"World\\\"\");\n+\tmu_assert_streq (escaped, \"Hello, \\\\\\\"World\\\\\\\"\", \"escaped \\\"double quotes\\\"\");\n+\tfree (escaped);\n+\tescaped = r_str_escape_sh (\"Hello, \\\\World\\\\\");\n+\tmu_assert_streq (escaped, \"Hello, \\\\\\\\World\\\\\\\\\", \"escaped backspace\");\n+\tfree (escaped);\n+#if __UNIX__\n+\tescaped = r_str_escape_sh (\"Hello, $(World)\");\n+\tmu_assert_streq (escaped, \"Hello, \\\\$(World)\", \"escaped $(command)\");\n+\tfree (escaped);\n+\tescaped = r_str_escape_sh (\"Hello, `World`\");\n+\tmu_assert_streq (escaped, \"Hello, \\\\`World\\\\`\", \"escaped `command`\");\n+\tfree (escaped);\n+#endif\n+\tmu_end;\n+}\n+\n bool test_r_str_unescape(void) {\n \tchar buf[] = \"Hello\\\\x31World\\\\n\";\n \tr_str_unescape (buf);\n@@ -477,6 +495,7 @@ bool all_tests () {\n \tmu_run_test (test_r_str_utf8_charsize);\n \tmu_run_test (test_r_str_utf8_charsize_prev);\n \tmu_run_test (test_r_str_sanitize_sdb_key);\n+\tmu_run_test (test_r_str_escape_sh);\n \tmu_run_test (test_r_str_unescape);\n \tmu_run_test (test_r_str_constpool);\n \tmu_run_test (test_r_str_format_msvc_argv);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 10,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "a7e958f9ebdf9771c36e8376078f027792981fea",
            "date": "2025-01-14T17:22:24Z",
            "author_login": "radare"
          },
          {
            "sha": "0f85675c7a5d542a89318b62d4a4bc997e595e03",
            "date": "2025-01-14T11:01:39Z",
            "author_login": "radare"
          },
          {
            "sha": "92d45a6034fe60123adc23bf49b398809fe36d25",
            "date": "2025-01-14T11:11:00Z",
            "author_login": "radare"
          },
          {
            "sha": "07be136859c56f96a692c8d5d1a3531345f16a0c",
            "date": "2025-01-14T10:46:07Z",
            "author_login": "radare"
          },
          {
            "sha": "05ebe2e92fc1905702201106228b285c80bd958b",
            "date": "2025-01-14T10:28:47Z",
            "author_login": "radare"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:N/I:H/A:N",
    "cwe_id": "CWE-78",
    "description": "In radare2 before version 4.5.0, malformed PDB file names in the PDB server path cause shell injection. To trigger the problem it's required to open the executable in radare2 and run idpd to trigger the download. The shell code will execute, and will create a file called pwned in the current directory.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-07-20T18:15:12.187",
    "last_modified": "2024-11-21T05:04:51.953",
    "fix_date": "2020-06-10T16:00:00Z"
  },
  "references": [
    {
      "url": "https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/radareorg/radare2/issues/16945",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/radareorg/radare2/pull/16966",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/radareorg/radare2/security/advisories/GHSA-r552-vp94-9358",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/MWC7KNBETYE5MK6VIUU26LUIISIFGSBZ/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YE77P5RSE2T7JHEKMWF2ARTSJGMPXCFY/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/radareorg/radare2/issues/16945",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/radareorg/radare2/pull/16966",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/radareorg/radare2/security/advisories/GHSA-r552-vp94-9358",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/MWC7KNBETYE5MK6VIUU26LUIISIFGSBZ/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YE77P5RSE2T7JHEKMWF2ARTSJGMPXCFY/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:01.371160",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "radare2",
    "owner": "radareorg",
    "created_at": "2012-07-03T07:42:26Z",
    "updated_at": "2025-01-14T11:39:09Z",
    "pushed_at": "2025-01-14T11:39:05Z",
    "size": 182812,
    "stars": 20990,
    "forks": 3027,
    "open_issues": 874,
    "watchers": 20990,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 29143253,
      "Makefile": 262919,
      "Shell": 145034,
      "Meson": 123192,
      "C++": 82794,
      "HTML": 55704,
      "Rebol": 54153,
      "Python": 38146,
      "Roff": 36722,
      "JavaScript": 23584,
      "CSS": 19465,
      "Batchfile": 8970,
      "Perl": 6449,
      "sed": 4448,
      "R": 1960,
      "Rez": 1386,
      "Assembly": 939,
      "Vala": 839,
      "Wren": 460,
      "Gnuplot": 429,
      "C#": 164,
      "Dart": 125,
      "Rascal": 45
    },
    "commit_activity": {
      "total_commits_last_year": 1594,
      "avg_commits_per_week": 30.653846153846153,
      "days_active_last_year": 294
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:04:16.054007"
  }
}