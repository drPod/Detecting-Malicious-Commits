{
  "cve_id": "CVE-2020-15173",
  "github_data": {
    "repository": "accel-ppp/accel-ppp",
    "fix_commit": "2324bcd5ba12cf28f47357a8f03cd41b7c04c52b",
    "related_commits": [
      "2324bcd5ba12cf28f47357a8f03cd41b7c04c52b",
      "2324bcd5ba12cf28f47357a8f03cd41b7c04c52b"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "2324bcd5ba12cf28f47357a8f03cd41b7c04c52b",
      "commit_date": "2020-09-05T21:38:35Z",
      "author": {
        "login": "themiron",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "l2tp: fix RCE through buffer overflow & fix LE/BE compatibility",
        "length": 637,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 234,
        "additions": 126,
        "deletions": 108
      },
      "files": [
        {
          "filename": "accel-pppd/ctrl/l2tp/l2tp_prot.h",
          "status": "modified",
          "additions": 12,
          "deletions": 19,
          "patch": "@@ -5,17 +5,16 @@\n \n #define L2TP_PORT 1701\n \n+#define L2TP_FLAG_T   0x8000\n+#define L2TP_FLAG_L   0x4000\n+#define L2TP_FLAG_S   0x0800\n+#define L2TP_FLAG_O   0x0200\n+#define L2TP_FLAG_P   0x0100\n+#define L2TP_VER_MASK 0x000f\n+\n struct l2tp_hdr_t\n {\n-\tuint8_t P:1;\n-\tuint8_t O:1;\n-\tuint8_t reserved2:1;\n-\tuint8_t S:1;\n-\tuint8_t reserved1:2;\n-\tuint8_t L:1;\n-\tuint8_t T:1;\n-\tuint8_t ver:4;\n-\tuint8_t reserved3:4;\n+\tuint16_t flags;\n \tuint16_t length;\n \tunion {\n \t\tstruct {\n@@ -28,18 +27,13 @@ struct l2tp_hdr_t\n \tuint16_t Nr;\n } __attribute__((packed));\n \n-/*#define L2TP_T(hdr) (hdr->flags >> 15)\n-#define L2TP_L(hdr) ((hdr->flags >> 14) & 1)\n-#define L2TP_S(hdr) ((hdr->flags >> 10) & 1)\n-#define L2TP_O(hdr) ((hdr->flags >> 8) & 1)\n-#define L2TP_VER(hdr) (hdr->flags & 0xf)*/\n+#define L2TP_AVP_FLAG_M   0x8000\n+#define L2TP_AVP_FLAG_H   0x4000\n+#define L2TP_AVP_LEN_MASK 0x03ff\n \n struct l2tp_avp_t\n {\n-\tuint16_t length:10;\n-\tuint16_t reserved:4;\n-\tuint16_t H:1;\n-\tuint16_t M:1;\n+\tuint16_t flags;\n \tuint16_t vendor;\n \tuint16_t type;\n \tuint8_t val[0];\n@@ -53,4 +47,3 @@ struct l2tp_avp_result_code\n } __attribute__((packed));\n \n #endif\n-"
        },
        {
          "filename": "accel-pppd/ctrl/l2tp/packet.c",
          "status": "modified",
          "additions": 114,
          "deletions": 89,
          "patch": "@@ -28,12 +28,18 @@ void l2tp_packet_print(const struct l2tp_packet_t *pack,\n \tconst struct l2tp_attr_t *attr;\n \tconst struct l2tp_dict_value_t *val;\n \n-\tif (pack->hdr.ver == 2) {\n+\tswitch (pack->hdr.flags & L2TP_VER_MASK) {\n+\tcase 2:\n \t\tprint(\"[L2TP tid=%u sid=%u\", ntohs(pack->hdr.tid), ntohs(pack->hdr.sid));\n \t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n-\t} else {\n+\t\tbreak;\n+\tcase 3:\n \t\tprint(\"[L2TP cid=%u\", pack->hdr.cid);\n \t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n+\t\tbreak;\n+\tdefault:\n+\t\tprint(\"[L2TP unknown version]\\n\");\n+\t\treturn;\n \t}\n \n \tlist_for_each_entry(attr, &pack->attrs, entry) {\n@@ -72,10 +78,7 @@ struct l2tp_packet_t *l2tp_packet_alloc(int ver, int msg_type,\n \n \tmemset(pack, 0, sizeof(*pack));\n \tINIT_LIST_HEAD(&pack->attrs);\n-\tpack->hdr.ver = ver;\n-\tpack->hdr.T = 1;\n-\tpack->hdr.L = 1;\n-\tpack->hdr.S = 1;\n+\tpack->hdr.flags = L2TP_FLAG_T | L2TP_FLAG_L | L2TP_FLAG_S | (ver & L2TP_VER_MASK);\n \tmemcpy(&pack->addr, addr, sizeof(*addr));\n \tpack->hide_avps = H;\n \tpack->secret = secret;\n@@ -150,21 +153,23 @@ static int decode_avp(struct l2tp_avp_t *avp, const struct l2tp_attr_t *RV,\n \tuint8_t md5[MD5_DIGEST_LENGTH];\n \tuint8_t p1[MD5_DIGEST_LENGTH];\n \tuint8_t *prev_block = NULL;\n+\tuint16_t avp_len;\n \tuint16_t attr_len;\n \tuint16_t orig_attr_len;\n \tuint16_t bytes_left;\n \tuint16_t blocks_left;\n \tuint16_t last_block_len;\n \n-\tif (avp->length < sizeof(struct l2tp_avp_t) + 2) {\n+\tavp_len = avp->flags & L2TP_AVP_LEN_MASK;\n+\tif (avp_len < sizeof(struct l2tp_avp_t) + 2) {\n \t\t/* Hidden AVPs must contain at least two bytes\n \t\t   for storing original attribute length */\n \t\tlog_warn(\"l2tp: incorrect hidden avp received (type %hu):\"\n \t\t\t \" length too small (%hu bytes)\\n\",\n-\t\t\t ntohs(avp->type), avp->length);\n+\t\t\t ntohs(avp->type), avp_len);\n \t\treturn -1;\n \t}\n-\tattr_len = avp->length - sizeof(struct l2tp_avp_t);\n+\tattr_len = avp_len - sizeof(struct l2tp_avp_t);\n \n \t/* Decode first block */\n \tMD5_Init(&md5_ctx);\n@@ -228,31 +233,29 @@ static int decode_avp(struct l2tp_avp_t *avp, const struct l2tp_attr_t *RV,\n int l2tp_recv(int fd, struct l2tp_packet_t **p, struct in_pktinfo *pkt_info,\n \t      const char *secret, size_t secret_len)\n {\n-\tint n, length;\n-\tuint8_t *buf;\n+\tstruct l2tp_packet_t *pack;\n \tstruct l2tp_hdr_t *hdr;\n \tstruct l2tp_avp_t *avp;\n-\tstruct l2tp_dict_attr_t *da;\n-\tstruct l2tp_attr_t *attr, *RV = NULL;\n-\tuint8_t *ptr;\n-\tstruct l2tp_packet_t *pack;\n+\tstruct l2tp_attr_t *RV = NULL;\n \tstruct sockaddr_in addr;\n-\tsocklen_t len = sizeof(addr);\n-\tstruct msghdr msg;\n-\tchar msg_control[128];\n-\tstruct cmsghdr *cmsg;\n+\tsocklen_t addr_len;\n \tuint16_t orig_avp_len;\n \tvoid *orig_avp_val;\n+\tuint8_t *buf, *ptr;\n+\tint n, length;\n \n-  *p = NULL;\n+\t*p = NULL;\n \n \tif (pkt_info) {\n+\t\tstruct msghdr msg;\n+\t\tstruct cmsghdr *cmsg;\n+\t\tchar msg_control[128];\n+\n \t\tmemset(&msg, 0, sizeof(msg));\n \t\tmsg.msg_control = msg_control;\n-\t\tmsg.msg_controllen = 128;\n+\t\tmsg.msg_controllen = sizeof(msg_control);\n \n \t\tn = recvmsg(fd, &msg, MSG_PEEK);\n-\n \t\tif (n < 0) {\n \t\t\tif (errno == EAGAIN)\n \t\t\t\treturn -1;\n@@ -276,8 +279,8 @@ int l2tp_recv(int fd, struct l2tp_packet_t **p, struct in_pktinfo *pkt_info,\n \thdr = (struct l2tp_hdr_t *)buf;\n \tptr = (uint8_t *)(hdr + 1);\n \n-\tn = recvfrom(fd, buf, L2TP_MAX_PACKET_SIZE, 0, &addr, &len);\n-\n+\taddr_len = sizeof(addr);\n+\tn = recvfrom(fd, buf, L2TP_MAX_PACKET_SIZE, 0, &addr, &addr_len);\n \tif (n < 0) {\n \t\tmempool_free(buf);\n \t\tif (errno == EAGAIN) {\n@@ -289,45 +292,50 @@ int l2tp_recv(int fd, struct l2tp_packet_t **p, struct in_pktinfo *pkt_info,\n \t\treturn 0;\n \t}\n \n-\tif (n < 6) {\n+\tif (n < sizeof(*hdr)) {\n \t\tif (conf_verbose)\n \t\t\tlog_warn(\"l2tp: short packet received (%i/%zu)\\n\", n, sizeof(*hdr));\n \t\tgoto out_err_hdr;\n \t}\n \n-\tif (hdr->T == 0)\n+\thdr->flags = ntohs(hdr->flags);\n+\tif (!(hdr->flags & L2TP_FLAG_T))\n \t\tgoto out_err_hdr;\n-\n-\tif (n < ntohs(hdr->length)) {\n+\tif (!(hdr->flags & L2TP_FLAG_L)) {\n \t\tif (conf_verbose)\n-\t\t\tlog_warn(\"l2tp: short packet received (%i/%i)\\n\", n, ntohs(hdr->length));\n+\t\t\tlog_warn(\"l2tp: incorrect control message received (L=0)\\n\");\n \t\tgoto out_err_hdr;\n \t}\n-\n-\tif (hdr->ver == 2) {\n-\t\tif (hdr->L == 0) {\n-\t\t\tif (conf_verbose)\n-\t\t\t\tlog_warn(\"l2tp: incorrect message received (L=0)\\n\");\n-\t\t\tif (!conf_avp_permissive)\n-\t\t\t    goto out_err_hdr;\n-\t\t}\n-\n-\t\tif (hdr->S == 0) {\n+\tif (!(hdr->flags & L2TP_FLAG_S)) {\n+\t\tif (conf_verbose)\n+\t\t\tlog_warn(\"l2tp: incorrect control message received (S=0)\\n\");\n+\t\tgoto out_err_hdr;\n+\t}\n+\tswitch (hdr->flags & L2TP_VER_MASK) {\n+\tcase 2:\n+\t\tif (hdr->flags & L2TP_FLAG_O) {\n \t\t\tif (conf_verbose)\n-\t\t\t\tlog_warn(\"l2tp: incorrect message received (S=0)\\n\");\n-\t\t\tif (!conf_avp_permissive)\n-\t\t\t    goto out_err_hdr;\n+\t\t\t\tlog_warn(\"l2tp: incorrect control message received (O=1)\\n\");\n+\t\t\tgoto out_err_hdr;\n \t\t}\n+\t\tbreak;\n+\tcase 3:\n+\t\tbreak;\n+\tdefault:\n+\t\tif (conf_verbose)\n+\t\t\tlog_warn(\"l2tp: protocol version %i is not supported\\n\",\n+\t\t\t\t hdr->flags & L2TP_VER_MASK);\n+\t\tgoto out_err_hdr;\n+\t}\n \n-\t\tif (hdr->O == 1) {\n-\t\t\tif (conf_verbose)\n-\t\t\t\tlog_warn(\"l2tp: incorrect message received (O=1)\\n\");\n-\t\t\tif (!conf_avp_permissive)\n-\t\t\t    goto out_err_hdr;\n-\t\t}\n-\t} else if (hdr->ver != 3) {\n+\tlength = ntohs(hdr->length);\n+\tif (length < sizeof(*hdr)) {\n \t\tif (conf_verbose)\n-\t\t\tlog_warn(\"l2tp: protocol version %i is not supported\\n\", hdr->ver);\n+\t\t\tlog_warn(\"l2tp: short packet received (%i/%zu)\\n\", length, sizeof(*hdr));\n+\t\tgoto out_err_hdr;\n+\t} else if (n < length) {\n+\t\tif (conf_verbose)\n+\t\t\tlog_warn(\"l2tp: short packet received (%i/%i)\\n\", n, length);\n \t\tgoto out_err_hdr;\n \t}\n \n@@ -342,13 +350,27 @@ int l2tp_recv(int fd, struct l2tp_packet_t **p, struct in_pktinfo *pkt_info,\n \n \tmemcpy(&pack->addr, &addr, sizeof(addr));\n \tmemcpy(&pack->hdr, hdr, sizeof(*hdr));\n-\tlength = ntohs(hdr->length) - sizeof(*hdr);\n+\tlength -= sizeof(*hdr);\n \n-\twhile (length) {\n-\t\t*(uint16_t *)ptr = ntohs(*(uint16_t *)ptr);\n-\t\tavp = (struct l2tp_avp_t *)ptr;\n+\twhile (length > 0) {\n+\t\tstruct l2tp_dict_attr_t *da;\n+\t\tstruct l2tp_attr_t *attr;\n+\t\tuint16_t avp_len;\n \n-\t\tif (avp->length > length) {\n+\t\tif (length < sizeof(*avp)) {\n+\t\t\tif (conf_verbose)\n+\t\t\t\tlog_warn(\"l2tp: short avp received\\n\");\n+\t\t\tgoto out_err;\n+\t\t}\n+\n+\t\tavp = (struct l2tp_avp_t *)ptr;\n+\t\tavp->flags = ntohs(avp->flags);\n+\t\tavp_len = avp->flags & L2TP_AVP_LEN_MASK;\n+\t\tif (avp_len < sizeof(*avp)) {\n+\t\t\tif (conf_verbose)\n+\t\t\t\tlog_warn(\"l2tp: short avp received\\n\");\n+\t\t\tgoto out_err;\n+\t\t} else if (length < avp_len) {\n \t\t\tif (conf_verbose)\n \t\t\t\tlog_warn(\"l2tp: incorrect avp received (exceeds message length)\\n\");\n \t\t\tgoto out_err;\n@@ -359,26 +381,32 @@ int l2tp_recv(int fd, struct l2tp_packet_t **p, struct in_pktinfo *pkt_info,\n \n \t\tda = l2tp_dict_find_attr_by_id(ntohs(avp->type));\n \t\tif (!da) {\n-\t\t\tif (conf_verbose)\n-\t\t\t\tlog_warn(\"l2tp: unknown avp received (type=%i, M=%u)\\n\", ntohs(avp->type), avp->M);\n-\t\t\tif (avp->M && !conf_avp_permissive)\n+\t\t\tif (conf_verbose) {\n+\t\t\t\tlog_warn(\"l2tp: unknown avp received (type=%i, M=%u)\\n\",\n+\t\t\t\t\t ntohs(avp->type), !!(avp->flags & L2TP_AVP_FLAG_M));\n+\t\t\t}\n+\t\t\tif ((avp->flags & L2TP_AVP_FLAG_M) && !conf_avp_permissive)\n \t\t\t\tgoto out_err;\n \t\t} else {\n-\t\t\tif (da->M != -1 && da->M != avp->M) {\n-\t\t\t\tif (conf_verbose)\n-\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, M=%i, must be %i)\\n\", ntohs(avp->type), avp->M, da->M);\n+\t\t\tif (da->M != -1 && !da->M != !(avp->flags & L2TP_AVP_FLAG_M)) {\n+\t\t\t\tif (conf_verbose) {\n+\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, M=%i, must be %i)\\n\",\n+\t\t\t\t\t\t ntohs(avp->type), !!(avp->flags & L2TP_AVP_FLAG_M), da->M);\n+\t\t\t\t}\n \t\t\t\tif (!conf_avp_permissive)\n \t\t\t\t    goto out_err;\n \t\t\t}\n \n-\t\t\tif (da->H != -1 && da->H != avp->H) {\n-\t\t\t\tif (conf_verbose)\n-\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=%i, must be %i)\\n\", ntohs(avp->type), avp->H, da->H);\n+\t\t\tif (da->H != -1 && !da->H != !(avp->flags & L2TP_AVP_FLAG_H)) {\n+\t\t\t\tif (conf_verbose) {\n+\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=%i, must be %i)\\n\",\n+\t\t\t\t\t\t ntohs(avp->type), !!(avp->flags & L2TP_AVP_FLAG_H), da->H);\n+\t\t\t\t}\n \t\t\t\tif (!conf_avp_permissive)\n \t\t\t\t    goto out_err;\n \t\t\t}\n \n-\t\t\tif (avp->H) {\n+\t\t\tif (avp->flags & L2TP_AVP_FLAG_H) {\n \t\t\t\tif (!RV) {\n \t\t\t\t\tif (conf_verbose)\n \t\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=1, but Random-Vector is not received)\\n\", ntohs(avp->type));\n@@ -393,24 +421,21 @@ int l2tp_recv(int fd, struct l2tp_packet_t **p, struct in_pktinfo *pkt_info,\n \t\t\t\t}\n \t\t\t\tif (decode_avp(avp, RV, secret, secret_len) < 0)\n \t\t\t\t\tgoto out_err;\n-\t\t\t}\n \n-\t\t\tattr = mempool_alloc(attr_pool);\n-\t\t\tmemset(attr, 0, sizeof(*attr));\n-\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n-\n-\t\t\tif (avp->H) {\n \t\t\t\torig_avp_len = ntohs(*(uint16_t *)avp->val) + sizeof(*avp);\n \t\t\t\torig_avp_val = avp->val + sizeof(uint16_t);\n \t\t\t} else {\n-\t\t\t\torig_avp_len = avp->length;\n+\t\t\t\torig_avp_len = avp_len;\n \t\t\t\torig_avp_val = avp->val;\n \t\t\t}\n \n+\t\t\tattr = mempool_alloc(attr_pool);\n+\t\t\tmemset(attr, 0, sizeof(*attr));\n \t\t\tattr->attr = da;\n-\t\t\tattr->M = avp->M;\n+\t\t\tattr->M = !!(avp->flags & L2TP_AVP_FLAG_M);\n \t\t\tattr->H = 0;\n \t\t\tattr->length = orig_avp_len - sizeof(*avp);\n+\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n \n \t\t\tif (attr->attr->id == Random_Vector)\n \t\t\t\tRV = attr;\n@@ -447,8 +472,8 @@ int l2tp_recv(int fd, struct l2tp_packet_t **p, struct in_pktinfo *pkt_info,\n \t\t\t}\n \t\t}\n skip:\n-\t\tptr += avp->length;\n-\t\tlength -= avp->length;\n+\t\tptr += avp_len;\n+\t\tlength -= avp_len;\n \t}\n \n \t*p = pack;\n@@ -473,21 +498,22 @@ int l2tp_recv(int fd, struct l2tp_packet_t **p, struct in_pktinfo *pkt_info,\n \n int l2tp_packet_send(int sock, struct l2tp_packet_t *pack)\n {\n-\tuint8_t *buf = mempool_alloc(buf_pool);\n+\tstruct l2tp_hdr_t *hdr;\n \tstruct l2tp_avp_t *avp;\n \tstruct l2tp_attr_t *attr;\n-\tuint8_t *ptr;\n-\tint n;\n-\tint len = sizeof(pack->hdr);\n+\tuint8_t *buf, *ptr;\n+\tint n, len;\n \n+\tbuf = mempool_alloc(buf_pool);\n \tif (!buf) {\n \t\tlog_emerg(\"l2tp: out of memory\\n\");\n \t\treturn -1;\n \t}\n \n \tmemset(buf, 0, L2TP_MAX_PACKET_SIZE);\n-\n-\tptr = buf + sizeof(pack->hdr);\n+\thdr = (struct l2tp_hdr_t *)buf;\n+\tptr = (uint8_t *)(hdr + 1);\n+\tlen = sizeof(pack->hdr);\n \n \tlist_for_each_entry(attr, &pack->attrs, entry) {\n \t\tif (len + sizeof(*avp) + attr->length >= L2TP_MAX_PACKET_SIZE) {\n@@ -497,10 +523,9 @@ int l2tp_packet_send(int sock, struct l2tp_packet_t *pack)\n \t\t}\n \t\tavp = (struct l2tp_avp_t *)ptr;\n \t\tavp->type = htons(attr->attr->id);\n-\t\tavp->M = attr->M;\n-\t\tavp->H = attr->H;\n-\t\tavp->length = sizeof(*avp) + attr->length;\n-\t\t*(uint16_t *)ptr = htons(*(uint16_t *)ptr);\n+\t\tavp->flags = htons((attr->M ? L2TP_AVP_FLAG_M : 0) |\n+\t\t\t\t   (attr->H ? L2TP_AVP_FLAG_H : 0) |\n+\t\t\t\t   ((sizeof(*avp) + attr->length) & L2TP_AVP_LEN_MASK));\n \t\tif (attr->H)\n \t\t\tmemcpy(avp->val, attr->val.octets, attr->length);\n \t\telse\n@@ -525,9 +550,9 @@ int l2tp_packet_send(int sock, struct l2tp_packet_t *pack)\n \n \tpack->hdr.length = htons(len);\n \tmemcpy(buf, &pack->hdr, sizeof(pack->hdr));\n+\thdr->flags = htons(pack->hdr.flags);\n \n-\tn = sendto(sock, buf, ntohs(pack->hdr.length), 0,\n-\t\t   &pack->addr, sizeof(pack->addr));\n+\tn = sendto(sock, buf, len, 0, &pack->addr, sizeof(pack->addr));\n \tmempool_free(buf);\n \n \tif (n < 0) {\n@@ -541,9 +566,9 @@ int l2tp_packet_send(int sock, struct l2tp_packet_t *pack)\n \t\t}\n \t}\n \n-\tif (n != ntohs(pack->hdr.length)) {\n+\tif (n != len) {\n \t\tif (conf_verbose)\n-\t\t\tlog_warn(\"l2tp: short write (%i/%i)\\n\", n, ntohs(pack->hdr.length));\n+\t\t\tlog_warn(\"l2tp: short write (%i/%i)\\n\", n, len);\n \t}\n \n \treturn 0;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b6938e83144ff4f5495195dbb60d59e1e7511840",
            "date": "2025-01-09T21:04:55Z",
            "author_login": "svlobanov"
          },
          {
            "sha": "186f120b71d445388c4dd7bd105446f529572816",
            "date": "2025-01-03T13:15:06Z",
            "author_login": "nuclearcat"
          },
          {
            "sha": "6e6f8211185846ab37be6a0cf68557112053dfb1",
            "date": "2024-12-12T20:42:38Z",
            "author_login": "DmitriyEshenko"
          },
          {
            "sha": "563f4aadcb736d5c2b26e9575a71cafcb8cf6287",
            "date": "2024-12-11T00:54:14Z",
            "author_login": "svlobanov"
          },
          {
            "sha": "6350ca6af999605b9474b9efe013657c4802de2b",
            "date": "2024-12-11T00:36:32Z",
            "author_login": "svlobanov"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.2,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H",
    "cwe_id": "CWE-119",
    "description": "In ACCEL-PPP (an implementation of PPTP/PPPoE/L2TP/SSTP), there is a buffer overflow when receiving an l2tp control packet ith an AVP which type is a string and no hidden flags, length set to less than 6. If your application is used in open networks or there are untrusted nodes in the network it is highly recommended to apply the patch. The problem was patched with commit 2324bcd5ba12cf28f47357a8f03cd41b7c04c52b As a workaround changes of commit 2324bcd5ba12cf28f47357a8f03cd41b7c04c52b can be applied to older versions.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-09-09T23:15:10.977",
    "last_modified": "2024-11-21T05:05:00.193",
    "fix_date": "2020-09-05T21:38:35Z"
  },
  "references": [
    {
      "url": "https://github.com/accel-ppp/accel-ppp/commit/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/accel-ppp/accel-ppp/security/advisories/GHSA-rr68-fchr-69vf",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/accel-ppp/accel-ppp/commit/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/accel-ppp/accel-ppp/security/advisories/GHSA-rr68-fchr-69vf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:03.825568",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "accel-ppp",
    "owner": "accel-ppp",
    "created_at": "2020-03-07T12:58:24Z",
    "updated_at": "2025-01-11T07:55:06Z",
    "pushed_at": "2025-01-09T21:04:55Z",
    "size": 5164,
    "stars": 239,
    "forks": 86,
    "open_issues": 35,
    "watchers": 239,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 2065303,
      "Roff": 44034,
      "Python": 41289,
      "CMake": 27980,
      "Shell": 5577,
      "Makefile": 184
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-26T07:58:46.383116"
  }
}