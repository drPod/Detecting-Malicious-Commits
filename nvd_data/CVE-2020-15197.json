{
  "cve_id": "CVE-2020-15197",
  "github_data": {
    "repository": "tensorflow/tensorflow",
    "fix_commit": "3cbb917b4714766030b28eba9fb41bb97ce9ee02",
    "related_commits": [
      "3cbb917b4714766030b28eba9fb41bb97ce9ee02",
      "3cbb917b4714766030b28eba9fb41bb97ce9ee02"
    ],
    "patch_url": "https://github.com/tensorflow/tensorflow/commit/3cbb917b4714766030b28eba9fb41bb97ce9ee02.patch",
    "fix_commit_details": {
      "sha": "3cbb917b4714766030b28eba9fb41bb97ce9ee02",
      "commit_date": "2020-09-19T01:15:03Z",
      "author": {
        "login": "mihaimaruseac",
        "type": "User",
        "stats": {
          "total_commits": 1590,
          "average_weekly_commits": 3.3125,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 214
        }
      },
      "commit_message": {
        "title": "Fix multiple vulnerabilities in `tf.raw_ops.*CountSparseOutput`.",
        "length": 239,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 159,
        "additions": 159,
        "deletions": 0
      },
      "files": [
        {
          "filename": "tensorflow/core/kernels/count_ops.cc",
          "status": "modified",
          "additions": 41,
          "deletions": 0,
          "patch": "@@ -178,10 +178,30 @@ class SparseCount : public OpKernel {\n     const Tensor& weights = context->input(3);\n     bool use_weights = weights.NumElements() > 0;\n \n+    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()),\n+                errors::InvalidArgument(\n+                    \"Input indices must be a 2-dimensional tensor. Got: \",\n+                    indices.shape().DebugString()));\n+\n+    if (use_weights) {\n+      OP_REQUIRES(\n+          context, weights.shape() == values.shape(),\n+          errors::InvalidArgument(\n+              \"Weights and values must have the same shape. Weight shape: \",\n+              weights.shape().DebugString(),\n+              \"; values shape: \", values.shape().DebugString()));\n+    }\n+\n     bool is_1d = shape.NumElements() == 1;\n     int num_batches = is_1d ? 1 : shape.flat<int64>()(0);\n     int num_values = values.NumElements();\n \n+    OP_REQUIRES(context, num_values == indices.shape().dim_size(0),\n+                errors::InvalidArgument(\n+                    \"Number of values must match first dimension of indices.\",\n+                    \"Got \", num_values,\n+                    \" values, indices shape: \", indices.shape().DebugString()));\n+\n     const auto indices_values = indices.matrix<int64>();\n     const auto values_values = values.flat<T>();\n     const auto weight_values = weights.flat<W>();\n@@ -235,12 +255,33 @@ class RaggedCount : public OpKernel {\n     bool use_weights = weights.NumElements() > 0;\n     bool is_1d = false;\n \n+    if (use_weights) {\n+      OP_REQUIRES(\n+          context, weights.shape() == values.shape(),\n+          errors::InvalidArgument(\n+              \"Weights and values must have the same shape. Weight shape: \",\n+              weights.shape().DebugString(),\n+              \"; values shape: \", values.shape().DebugString()));\n+    }\n+\n     const auto splits_values = splits.flat<int64>();\n     const auto values_values = values.flat<T>();\n     const auto weight_values = weights.flat<W>();\n     int num_batches = splits.NumElements() - 1;\n     int num_values = values.NumElements();\n \n+    OP_REQUIRES(\n+        context, num_batches > 0,\n+        errors::InvalidArgument(\n+            \"Must provide at least 2 elements for the splits argument\"));\n+    OP_REQUIRES(context, splits_values(0) == 0,\n+                errors::InvalidArgument(\"Splits must start with 0, not with \",\n+                                        splits_values(0)));\n+    OP_REQUIRES(context, splits_values(num_batches) == num_values,\n+                errors::InvalidArgument(\n+                    \"Splits must end with the number of values, got \",\n+                    splits_values(num_batches), \" instead of \", num_values));\n+\n     auto per_batch_counts = BatchedMap<W>(num_batches);\n     T max_value = 0;\n     int batch_idx = 0;"
        },
        {
          "filename": "tensorflow/python/ops/bincount_ops_test.py",
          "status": "modified",
          "additions": 118,
          "deletions": 0,
          "patch": "@@ -25,7 +25,9 @@\n from tensorflow.python.framework import errors\n from tensorflow.python.framework import ops\n from tensorflow.python.framework import sparse_tensor\n+from tensorflow.python.framework import test_util\n from tensorflow.python.ops import bincount_ops\n+from tensorflow.python.ops import gen_count_ops\n from tensorflow.python.ops import sparse_ops\n from tensorflow.python.ops.ragged import ragged_factory_ops\n from tensorflow.python.ops.ragged import ragged_tensor\n@@ -834,5 +836,121 @@ def test_ragged_input_different_shape_fails(self):\n       self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n \n \n+@test_util.run_all_in_graph_and_eager_modes\n+@test_util.disable_tfrt\n+class RawOpsTest(test.TestCase, parameterized.TestCase):\n+\n+  def testSparseCountSparseOutputBadIndicesShape(self):\n+    indices = [[[0], [0]], [[0], [1]], [[1], [0]], [[1], [2]]]\n+    values = [1, 1, 1, 10]\n+    weights = [1, 2, 4, 6]\n+    dense_shape = [2, 3]\n+    with self.assertRaisesRegex(errors.InvalidArgumentError,\n+                                \"Input indices must be a 2-dimensional tensor\"):\n+      self.evaluate(\n+          gen_count_ops.SparseCountSparseOutput(\n+              indices=indices,\n+              values=values,\n+              dense_shape=dense_shape,\n+              weights=weights,\n+              binary_output=False))\n+\n+  def testSparseCountSparseOutputBadWeightsShape(self):\n+    indices = [[0, 0], [0, 1], [1, 0], [1, 2]]\n+    values = [1, 1, 1, 10]\n+    weights = [1, 2, 4]\n+    dense_shape = [2, 3]\n+    with self.assertRaisesRegex(errors.InvalidArgumentError,\n+                                \"Weights and values must have the same shape\"):\n+      self.evaluate(\n+          gen_count_ops.SparseCountSparseOutput(\n+              indices=indices,\n+              values=values,\n+              dense_shape=dense_shape,\n+              weights=weights,\n+              binary_output=False))\n+\n+  def testSparseCountSparseOutputBadNumberOfValues(self):\n+    indices = [[0, 0], [0, 1], [1, 0]]\n+    values = [1, 1, 1, 10]\n+    weights = [1, 2, 4, 6]\n+    dense_shape = [2, 3]\n+    with self.assertRaisesRegex(\n+        errors.InvalidArgumentError,\n+        \"Number of values must match first dimension of indices\"):\n+      self.evaluate(\n+          gen_count_ops.SparseCountSparseOutput(\n+              indices=indices,\n+              values=values,\n+              dense_shape=dense_shape,\n+              weights=weights,\n+              binary_output=False))\n+\n+  def testRaggedCountSparseOutput(self):\n+    splits = [0, 4, 7]\n+    values = [1, 1, 2, 1, 2, 10, 5]\n+    weights = [1, 2, 3, 4, 5, 6, 7]\n+    output_indices, output_values, output_shape = self.evaluate(\n+        gen_count_ops.RaggedCountSparseOutput(\n+            splits=splits, values=values, weights=weights, binary_output=False))\n+    self.assertAllEqual([[0, 1], [0, 2], [1, 2], [1, 5], [1, 10]],\n+                        output_indices)\n+    self.assertAllEqual([7, 3, 5, 7, 6], output_values)\n+    self.assertAllEqual([2, 11], output_shape)\n+\n+  def testRaggedCountSparseOutputBadWeightsShape(self):\n+    splits = [0, 4, 7]\n+    values = [1, 1, 2, 1, 2, 10, 5]\n+    weights = [1, 2, 3, 4, 5, 6]\n+    with self.assertRaisesRegex(errors.InvalidArgumentError,\n+                                \"Weights and values must have the same shape\"):\n+      self.evaluate(\n+          gen_count_ops.RaggedCountSparseOutput(\n+              splits=splits,\n+              values=values,\n+              weights=weights,\n+              binary_output=False))\n+\n+  def testRaggedCountSparseOutputEmptySplits(self):\n+    splits = []\n+    values = [1, 1, 2, 1, 2, 10, 5]\n+    weights = [1, 2, 3, 4, 5, 6, 7]\n+    with self.assertRaisesRegex(\n+        errors.InvalidArgumentError,\n+        \"Must provide at least 2 elements for the splits argument\"):\n+      self.evaluate(\n+          gen_count_ops.RaggedCountSparseOutput(\n+              splits=splits,\n+              values=values,\n+              weights=weights,\n+              binary_output=False))\n+\n+  def testRaggedCountSparseOutputBadSplitsStart(self):\n+    splits = [1, 7]\n+    values = [1, 1, 2, 1, 2, 10, 5]\n+    weights = [1, 2, 3, 4, 5, 6, 7]\n+    with self.assertRaisesRegex(errors.InvalidArgumentError,\n+                                \"Splits must start with 0\"):\n+      self.evaluate(\n+          gen_count_ops.RaggedCountSparseOutput(\n+              splits=splits,\n+              values=values,\n+              weights=weights,\n+              binary_output=False))\n+\n+  def testRaggedCountSparseOutputBadSplitsEnd(self):\n+    splits = [0, 5]\n+    values = [1, 1, 2, 1, 2, 10, 5]\n+    weights = [1, 2, 3, 4, 5, 6, 7]\n+    with self.assertRaisesRegex(errors.InvalidArgumentError,\n+                                \"Splits must end with the number of values\"):\n+      self.evaluate(\n+          gen_count_ops.RaggedCountSparseOutput(\n+              splits=splits,\n+              values=values,\n+              weights=weights,\n+              binary_output=False))\n+\n+\n if __name__ == \"__main__\":\n   test.main()"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "359517872b9281259b49f7186a9de6382598d7ee",
            "date": "2025-01-14T22:18:13Z",
            "author_login": "tensorflower-gardener"
          },
          {
            "sha": "d93cc4f4f767f0d4a72f2fafcc59005be939c019",
            "date": "2025-01-14T20:36:32Z",
            "author_login": "sdasgup3"
          },
          {
            "sha": "d4e4516cc7d11a68a81a82227f3a432f7ab350a0",
            "date": "2025-01-14T19:59:15Z",
            "author_login": "ddunl"
          },
          {
            "sha": "65367823d999b6a36a685617100a7bb6ce03add4",
            "date": "2025-01-14T19:58:00Z",
            "author_login": "sdasgup3"
          },
          {
            "sha": "36cbae5466dbf356d91cf56127b2ab2ccd5a8b1f",
            "date": "2025-01-14T19:54:19Z",
            "author_login": "penpornk"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:N/I:N/A:H",
    "cwe_id": "CWE-20",
    "description": "In Tensorflow before version 2.3.1, the `SparseCountSparseOutput` implementation does not validate that the input arguments form a valid sparse tensor. In particular, there is no validation that the `indices` tensor has rank 2. This tensor must be a matrix because code assumes its elements are accessed as elements of a matrix. However, malicious users can pass in tensors of different rank, resulting in a `CHECK` assertion failure and a crash. This can be used to cause denial of service in serving installations, if users are allowed to control the components of the input sparse tensor. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-09-25T19:15:14.963",
    "last_modified": "2024-11-21T05:05:03.693",
    "fix_date": "2020-09-19T01:15:03Z"
  },
  "references": [
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/3cbb917b4714766030b28eba9fb41bb97ce9ee02",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.3.1",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-qc53-44cj-vfvx",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/3cbb917b4714766030b28eba9fb41bb97ce9ee02",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.3.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-qc53-44cj-vfvx",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:06.153135",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "tensorflow",
    "owner": "tensorflow",
    "created_at": "2015-11-07T01:19:20Z",
    "updated_at": "2025-01-14T12:53:26Z",
    "pushed_at": "2025-01-14T12:53:14Z",
    "size": 1120707,
    "stars": 187254,
    "forks": 74432,
    "open_issues": 6569,
    "watchers": 187254,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 101199988,
      "Python": 45779571,
      "MLIR": 10763008,
      "HTML": 7662661,
      "Starlark": 7430486,
      "Go": 2171370,
      "C": 1288066,
      "Java": 1178817,
      "Jupyter Notebook": 805736,
      "Shell": 701425,
      "Objective-C++": 279654,
      "Objective-C": 169202,
      "CMake": 148610,
      "Smarty": 121630,
      "Swift": 81659,
      "Dockerfile": 37903,
      "C#": 13585,
      "Batchfile": 12126,
      "Ruby": 8898,
      "Perl": 7536,
      "Roff": 5034,
      "Cython": 3899,
      "Makefile": 2845,
      "CSS": 2761,
      "Vim Snippet": 58
    },
    "commit_activity": {
      "total_commits_last_year": 15729,
      "avg_commits_per_week": 302.4807692307692,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:54:01.412891"
  }
}