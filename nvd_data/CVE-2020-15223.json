{
  "cve_id": "CVE-2020-15223",
  "github_data": {
    "repository": "ory/fosite",
    "fix_commit": "03dd55813f5521985f7dd64277b7ba0cf1441319",
    "related_commits": [
      "03dd55813f5521985f7dd64277b7ba0cf1441319",
      "03dd55813f5521985f7dd64277b7ba0cf1441319"
    ],
    "patch_url": "https://github.com/ory/fosite/commit/03dd55813f5521985f7dd64277b7ba0cf1441319.patch",
    "fix_commit_details": {
      "sha": "03dd55813f5521985f7dd64277b7ba0cf1441319",
      "commit_date": "2020-09-24T10:00:29Z",
      "author": {
        "login": "zepatrik",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-7mqr-2v3q-v2wm",
        "length": 367,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 138,
        "additions": 103,
        "deletions": 35
      },
      "files": [
        {
          "filename": ".golangci.yml",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -6,7 +6,6 @@ linters:\n     - deadcode\n     - unused\n     - structcheck\n-    - errcheck\n     - gosimple\n     - bodyclose\n     - staticcheck"
        },
        {
          "filename": "access_error.go",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -53,5 +53,6 @@ func (f *Fosite) writeJsonError(rw http.ResponseWriter, err error) {\n \t}\n \n \trw.WriteHeader(rfcerr.Code)\n-\trw.Write(js)\n+\t// ignoring the error because the connection is broken when it happens\n+\t_, _ = rw.Write(js)\n }"
        },
        {
          "filename": "access_write.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -39,5 +39,5 @@ func (f *Fosite) WriteAccessResponse(rw http.ResponseWriter, requester AccessReq\n \trw.Header().Set(\"Content-Type\", \"application/json;charset=UTF-8\")\n \n \trw.WriteHeader(http.StatusOK)\n-\trw.Write(js)\n+\t_, _ = rw.Write(js)\n }"
        },
        {
          "filename": "authorize_error.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -53,7 +53,7 @@ func (f *Fosite) WriteAuthorizeError(rw http.ResponseWriter, ar AuthorizeRequest\n \t\t}\n \n \t\trw.WriteHeader(rfcerr.Code)\n-\t\trw.Write(js)\n+\t\t_, _ = rw.Write(js)\n \t\treturn\n \t}\n "
        },
        {
          "filename": "errors.go",
          "status": "modified",
          "additions": 0,
          "deletions": 5,
          "patch": "@@ -163,11 +163,6 @@ var (\n \t\tHint:        \"Token validation failed.\",\n \t\tCode:        http.StatusUnauthorized,\n \t}\n-\tErrRevocationClientMismatch = &RFC6749Error{\n-\t\tName:        errRevocationClientMismatchName,\n-\t\tDescription: \"Token was not issued to the client making the revocation request\",\n-\t\tCode:        http.StatusBadRequest,\n-\t}\n \tErrLoginRequired = &RFC6749Error{\n \t\tName:        errLoginRequired,\n \t\tDescription: \"The Authorization Server requires End-User authentication\","
        },
        {
          "filename": "errors_test.go",
          "status": "modified",
          "additions": 0,
          "deletions": 7,
          "patch": "@@ -28,13 +28,6 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n )\n \n-func TestAddDebug(t *testing.T) {\n-\terr := ErrRevocationClientMismatch.WithDebug(\"debug\")\n-\tassert.NotEqual(t, err, ErrRevocationClientMismatch)\n-\tassert.Empty(t, ErrRevocationClientMismatch.Debug)\n-\tassert.NotEmpty(t, err.Debug)\n-}\n-\n func TestIs(t *testing.T) {\n \tassert.True(t, errors.Is(ErrUnknownRequest, ErrUnknownRequest))\n \tassert.True(t, errors.Is(ErrUnknownRequest, &RFC6749Error{"
        },
        {
          "filename": "go_mod_indirect_pins.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -5,5 +5,6 @@ package fosite\n import (\n \t_ \"github.com/gorilla/websocket\"\n \t_ \"github.com/mattn/goveralls\"\n+\n \t_ \"github.com/ory/go-acc\"\n )"
        },
        {
          "filename": "handler/oauth2/revocation.go",
          "status": "modified",
          "additions": 20,
          "deletions": 9,
          "patch": "@@ -57,21 +57,32 @@ func (r *TokenRevocationHandler) RevokeToken(ctx context.Context, token string,\n \t}\n \n \tvar ar fosite.Requester\n-\tvar err error\n-\tif ar, err = discoveryFuncs[0](); err != nil {\n-\t\tar, err = discoveryFuncs[1]()\n+\tvar err1, err2 error\n+\tif ar, err1 = discoveryFuncs[0](); err1 != nil {\n+\t\tar, err2 = discoveryFuncs[1]()\n \t}\n-\tif err != nil {\n-\t\treturn err\n+\t// err2 can only be not nil if first err1 was not nil\n+\tif err2 != nil {\n+\t\treturn storeErrorsToRevocationError(err1, err2)\n \t}\n \n \tif ar.GetClient().GetID() != client.GetID() {\n-\t\treturn errors.WithStack(fosite.ErrRevocationClientMismatch)\n+\t\treturn errors.WithStack(fosite.ErrUnauthorizedClient)\n \t}\n \n \trequestID := ar.GetID()\n-\tr.TokenRevocationStorage.RevokeRefreshToken(ctx, requestID)\n-\tr.TokenRevocationStorage.RevokeAccessToken(ctx, requestID)\n+\terr1 = r.TokenRevocationStorage.RevokeRefreshToken(ctx, requestID)\n+\terr2 = r.TokenRevocationStorage.RevokeAccessToken(ctx, requestID)\n \n-\treturn nil\n+\treturn storeErrorsToRevocationError(err1, err2)\n+}\n+\n+func storeErrorsToRevocationError(err1, err2 error) error {\n+\t// both errors are 404 or nil <=> the token is revoked\n+\tif (errors.Is(err1, fosite.ErrNotFound) || err1 == nil) && (errors.Is(err2, fosite.ErrNotFound) || err2 == nil) {\n+\t\treturn nil\n+\t}\n+\n+\t// there was an unexpected error => the token may still exist and the client should retry later\n+\treturn errors.WithStack(fosite.ErrTemporarilyUnavailable)\n }"
        },
        {
          "filename": "handler/oauth2/revocation_test.go",
          "status": "modified",
          "additions": 66,
          "deletions": 6,
          "patch": "@@ -57,7 +57,7 @@ func TestRevokeToken(t *testing.T) {\n \t}{\n \t\t{\n \t\t\tdescription: \"should fail - token was issued to another client\",\n-\t\t\texpectErr:   fosite.ErrRevocationClientMismatch,\n+\t\t\texpectErr:   fosite.ErrUnauthorizedClient,\n \t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n \t\t\tmock: func() {\n \t\t\t\ttoken = \"foo\"\n@@ -134,8 +134,8 @@ func TestRevokeToken(t *testing.T) {\n \t\t\t},\n \t\t},\n \t\t{\n-\t\t\tdescription: \"should fail - refresh token discovery first; both tokens not found\",\n-\t\t\texpectErr:   fosite.ErrNotFound,\n+\t\t\tdescription: \"should pass - refresh token discovery first; both tokens not found\",\n+\t\t\texpectErr:   nil,\n \t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n \t\t\tmock: func() {\n \t\t\t\ttoken = \"foo\"\n@@ -148,8 +148,8 @@ func TestRevokeToken(t *testing.T) {\n \t\t\t},\n \t\t},\n \t\t{\n-\t\t\tdescription: \"should fail - access token discovery first; both tokens not found\",\n-\t\t\texpectErr:   fosite.ErrNotFound,\n+\t\t\tdescription: \"should pass - access token discovery first; both tokens not found\",\n+\t\t\texpectErr:   nil,\n \t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n \t\t\tmock: func() {\n \t\t\t\ttoken = \"foo\"\n@@ -161,8 +161,68 @@ func TestRevokeToken(t *testing.T) {\n \t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n \t\t\t},\n \t\t},\n+\t\t{\n+\t\t\tdescription: \"should fail - store error for access token get\",\n+\t\t\texpectErr:   fosite.ErrTemporarilyUnavailable,\n+\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n+\t\t\tmock: func() {\n+\t\t\t\ttoken = \"foo\"\n+\t\t\t\ttokenType = fosite.AccessToken\n+\t\t\t\tatStrat.EXPECT().AccessTokenSignature(token)\n+\t\t\t\tstore.EXPECT().GetAccessTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fmt.Errorf(\"random error\"))\n+\n+\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n+\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tdescription: \"should fail - store error for refresh token get\",\n+\t\t\texpectErr:   fosite.ErrTemporarilyUnavailable,\n+\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n+\t\t\tmock: func() {\n+\t\t\t\ttoken = \"foo\"\n+\t\t\t\ttokenType = fosite.RefreshToken\n+\t\t\t\tatStrat.EXPECT().AccessTokenSignature(token)\n+\t\t\t\tstore.EXPECT().GetAccessTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n+\n+\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n+\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fmt.Errorf(\"random error\"))\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tdescription: \"should fail - store error for access token revoke\",\n+\t\t\texpectErr:   fosite.ErrTemporarilyUnavailable,\n+\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n+\t\t\tmock: func() {\n+\t\t\t\ttoken = \"foo\"\n+\t\t\t\ttokenType = fosite.AccessToken\n+\t\t\t\tatStrat.EXPECT().AccessTokenSignature(token)\n+\t\t\t\tstore.EXPECT().GetAccessTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(ar, nil)\n+\n+\t\t\t\tar.EXPECT().GetID()\n+\t\t\t\tar.EXPECT().GetClient().Return(&fosite.DefaultClient{ID: \"bar\"})\n+\t\t\t\tstore.EXPECT().RevokeRefreshToken(gomock.Any(), gomock.Any()).Return(fosite.ErrNotFound)\n+\t\t\t\tstore.EXPECT().RevokeAccessToken(gomock.Any(), gomock.Any()).Return(fmt.Errorf(\"random error\"))\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tdescription: \"should fail - store error for refresh token revoke\",\n+\t\t\texpectErr:   fosite.ErrTemporarilyUnavailable,\n+\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n+\t\t\tmock: func() {\n+\t\t\t\ttoken = \"foo\"\n+\t\t\t\ttokenType = fosite.RefreshToken\n+\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n+\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(ar, nil)\n+\n+\t\t\t\tar.EXPECT().GetID()\n+\t\t\t\tar.EXPECT().GetClient().Return(&fosite.DefaultClient{ID: \"bar\"})\n+\t\t\t\tstore.EXPECT().RevokeRefreshToken(gomock.Any(), gomock.Any()).Return(fmt.Errorf(\"random error\"))\n+\t\t\t\tstore.EXPECT().RevokeAccessToken(gomock.Any(), gomock.Any()).Return(fosite.ErrNotFound)\n+\t\t\t},\n+\t\t},\n \t} {\n-\t\tt.Run(fmt.Sprintf(\"case=%d\", k), func(t *testing.T) {\n+\t\tt.Run(fmt.Sprintf(\"case=%d/description=%s\", k, c.description), func(t *testing.T) {\n \t\t\tc.mock()\n \t\t\terr := h.RevokeToken(nil, token, tokenType, c.client)\n "
        },
        {
          "filename": "handler/openid/helper.go",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -39,7 +39,11 @@ func (i *IDTokenHandleHelper) GetAccessTokenHash(ctx context.Context, requester\n \n \tbuffer := bytes.NewBufferString(token)\n \thash := sha256.New()\n-\thash.Write(buffer.Bytes())\n+\t// sha256.digest.Write() always returns nil for err, the panic should never happen\n+\t_, err := hash.Write(buffer.Bytes())\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n \thashBuf := bytes.NewBuffer(hash.Sum([]byte{}))\n \tlen := hashBuf.Len()\n "
        },
        {
          "filename": "revoke_handler.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -112,7 +112,7 @@ func (f *Fosite) WriteRevocationResponse(rw http.ResponseWriter, err error) {\n \t\t}\n \n \t\trw.WriteHeader(ErrInvalidRequest.Code)\n-\t\trw.Write(js)\n+\t\t_, _ = rw.Write(js)\n \t} else if errors.Is(err, ErrInvalidClient) {\n \t\trw.Header().Set(\"Content-Type\", \"application/json;charset=UTF-8\")\n \n@@ -123,7 +123,7 @@ func (f *Fosite) WriteRevocationResponse(rw http.ResponseWriter, err error) {\n \t\t}\n \n \t\trw.WriteHeader(ErrInvalidClient.Code)\n-\t\trw.Write(js)\n+\t\t_, _ = rw.Write(js)\n \t} else {\n \t\t// 200 OK\n \t\trw.WriteHeader(http.StatusOK)"
        },
        {
          "filename": "token/hmac/hmacsha.go",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -169,6 +169,10 @@ func (c *HMACStrategy) Signature(token string) string {\n \n func generateHMAC(data []byte, key *[32]byte) []byte {\n \th := hmac.New(sha512.New512_256, key[:])\n-\th.Write(data)\n+\t// sha512.digest.Write() always returns nil for err, the panic should never happen\n+\t_, err := h.Write(data)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n \treturn h.Sum(nil)\n }"
        }
      ],
      "file_patterns": {
        "security_files": 3,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "049ed1924cd0b41f12357b0fe617530c264421ac",
            "date": "2025-01-02T13:56:36Z",
            "author_login": "ory-bot"
          },
          {
            "sha": "af3992eac8353d44f74e16a70952f6eeaf856893",
            "date": "2025-01-02T12:40:13Z",
            "author_login": "ory-bot"
          },
          {
            "sha": "f2e501049dfaa72d0f62974f2f1f75ab5391fc58",
            "date": "2025-01-02T12:34:58Z",
            "author_login": "ory-bot"
          },
          {
            "sha": "57c58efbf4dc89069addd9f10c1a75fa549e7298",
            "date": "2025-01-02T12:21:36Z",
            "author_login": "ory-bot"
          },
          {
            "sha": "398f862fabde606106fbbafaafb9517db01a4d40",
            "date": "2025-01-02T12:18:49Z",
            "author_login": "ory-bot"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.0,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:N",
    "cwe_id": "CWE-755",
    "description": "In ORY Fosite (the security first OAuth2 & OpenID Connect framework for Go) before version 0.34.0, the `TokenRevocationHandler` ignores errors coming from the storage. This can lead to unexpected 200 status codes indicating successful revocation while the token is still valid. Whether an attacker can use this for her advantage depends on the ability to trigger errors in the store. This is fixed in version 0.34.0",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-09-24T17:15:13.210",
    "last_modified": "2024-11-21T05:05:07.623",
    "fix_date": "2020-09-24T10:00:29Z"
  },
  "references": [
    {
      "url": "https://github.com/ory/fosite/commit/03dd55813f5521985f7dd64277b7ba0cf1441319",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ory/fosite/security/advisories/GHSA-7mqr-2v3q-v2wm",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://tools.ietf.org/html/rfc7009#section-2.2.1",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ory/fosite/commit/03dd55813f5521985f7dd64277b7ba0cf1441319",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ory/fosite/security/advisories/GHSA-7mqr-2v3q-v2wm",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://tools.ietf.org/html/rfc7009#section-2.2.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:06.147040",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "fosite",
    "owner": "ory",
    "created_at": "2015-12-25T14:23:27Z",
    "updated_at": "2025-01-13T20:53:13Z",
    "pushed_at": "2025-01-02T13:56:36Z",
    "size": 7445,
    "stars": 2345,
    "forks": 368,
    "open_issues": 44,
    "watchers": 2345,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Go": 1043530,
      "Shell": 3856,
      "Makefile": 1062
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:22:34.127677"
  }
}