{
  "cve_id": "CVE-2020-15233",
  "github_data": {
    "repository": "ory/fosite",
    "fix_commit": "cdee51ebe721bfc8acca0fd0b86b030ca70867bf",
    "related_commits": [
      "cdee51ebe721bfc8acca0fd0b86b030ca70867bf",
      "cdee51ebe721bfc8acca0fd0b86b030ca70867bf"
    ],
    "patch_url": "https://github.com/ory/fosite/commit/cdee51ebe721bfc8acca0fd0b86b030ca70867bf.patch",
    "fix_commit_details": {
      "sha": "cdee51ebe721bfc8acca0fd0b86b030ca70867bf",
      "commit_date": "2020-10-02T10:26:51Z",
      "author": {
        "login": "aeneasr",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix: make redirect URL checking more strict",
        "length": 982,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 88,
        "additions": 61,
        "deletions": 27
      },
      "files": [
        {
          "filename": "authorize_helper.go",
          "status": "modified",
          "additions": 17,
          "deletions": 7,
          "patch": "@@ -118,24 +118,34 @@ func isMatchingRedirectURI(uri string, haystack []string) bool {\n \t}\n \n \tfor _, b := range haystack {\n-\t\tif strings.ToLower(b) == strings.ToLower(uri) || isLoopbackURI(requested, b) {\n+\t\tif b == uri || isMatchingAsLoopback(requested, b) {\n \t\t\treturn true\n \t\t}\n \t}\n \treturn false\n }\n \n-func isLoopbackURI(requested *url.URL, registeredURI string) bool {\n+func isMatchingAsLoopback(requested *url.URL, registeredURI string) bool {\n \tregistered, err := url.Parse(registeredURI)\n \tif err != nil {\n \t\treturn false\n \t}\n \n-\tif registered.Scheme != \"http\" || !isLoopbackAddress(registered.Host) {\n-\t\treturn false\n-\t}\n-\n-\tif requested.Scheme == \"http\" && isLoopbackAddress(requested.Host) && registered.Path == requested.Path {\n+\t// Native apps that are able to open a port on the loopback network\n+\t// interface without needing special permissions (typically, those on\n+\t// desktop operating systems) can use the loopback interface to receive\n+\t// the OAuth redirect.\n+\t//\n+\t// Loopback redirect URIs use the \"http\" scheme and are constructed with\n+\t// the loopback IP literal and whatever port the client is listening on.\n+\t//\n+\t// Source: https://tools.ietf.org/html/rfc8252#section-7.3\n+\tif requested.Scheme == \"http\" &&\n+\t\tisLoopbackAddress(requested.Host) &&\n+\t\tregistered.Hostname() == requested.Hostname() &&\n+\t\t// The port is skipped here - see codedoc above!\n+\t\tregistered.Path == requested.Path &&\n+\t\tregistered.RawQuery == requested.RawQuery {\n \t\treturn true\n \t}\n "
        },
        {
          "filename": "authorize_helper_test.go",
          "status": "modified",
          "additions": 43,
          "deletions": 19,
          "patch": "@@ -137,18 +137,6 @@ func TestDoesClientWhiteListRedirect(t *testing.T) {\n \t\t\tisError:  false,\n \t\t\texpected: \"https://bar.com/cb\",\n \t\t},\n-\t\t{\n-\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"https://bar.Com/cb\"}},\n-\t\t\turl:      \"https://bar.com/cb\",\n-\t\t\tisError:  false,\n-\t\t\texpected: \"https://bar.com/cb\",\n-\t\t},\n-\t\t{\n-\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"https://bar.com/cb\"}},\n-\t\t\turl:      \"https://bar.Com/cb\",\n-\t\t\tisError:  false,\n-\t\t\texpected: \"https://bar.Com/cb\",\n-\t\t},\n \t\t{\n \t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"https://bar.com/cb\"}},\n \t\t\turl:     \"https://bar.com/cb123\",\n@@ -157,8 +145,8 @@ func TestDoesClientWhiteListRedirect(t *testing.T) {\n \t\t{\n \t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://[::1]\"}},\n \t\t\turl:      \"http://[::1]:1024\",\n-\t\t\tisError:  false,\n \t\t\texpected: \"http://[::1]:1024\",\n+\t\t\tisError:  false,\n \t\t},\n \t\t{\n \t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://[::1]\"}},\n@@ -168,8 +156,8 @@ func TestDoesClientWhiteListRedirect(t *testing.T) {\n \t\t{\n \t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://[::1]/cb\"}},\n \t\t\turl:      \"http://[::1]:1024/cb\",\n-\t\t\tisError:  false,\n \t\t\texpected: \"http://[::1]:1024/cb\",\n+\t\t\tisError:  false,\n \t\t},\n \t\t{\n \t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://[::1]\"}},\n@@ -179,14 +167,14 @@ func TestDoesClientWhiteListRedirect(t *testing.T) {\n \t\t{\n \t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1\"}},\n \t\t\turl:      \"http://127.0.0.1:1024\",\n-\t\t\tisError:  false,\n \t\t\texpected: \"http://127.0.0.1:1024\",\n+\t\t\tisError:  false,\n \t\t},\n \t\t{\n \t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1/cb\"}},\n \t\t\turl:      \"http://127.0.0.1:64000/cb\",\n-\t\t\tisError:  false,\n \t\t\texpected: \"http://127.0.0.1:64000/cb\",\n+\t\t\tisError:  false,\n \t\t},\n \t\t{\n \t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1\"}},\n@@ -196,14 +184,14 @@ func TestDoesClientWhiteListRedirect(t *testing.T) {\n \t\t{\n \t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1\"}},\n \t\t\turl:      \"http://127.0.0.1\",\n-\t\t\tisError:  false,\n \t\t\texpected: \"http://127.0.0.1\",\n+\t\t\tisError:  false,\n \t\t},\n \t\t{\n \t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1/Cb\"}},\n \t\t\turl:      \"http://127.0.0.1:8080/Cb\",\n-\t\t\tisError:  false,\n \t\t\texpected: \"http://127.0.0.1:8080/Cb\",\n+\t\t\tisError:  false,\n \t\t},\n \t\t{\n \t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1\"}},\n@@ -215,9 +203,45 @@ func TestDoesClientWhiteListRedirect(t *testing.T) {\n \t\t\turl:     \":/invalid.uri)bar\",\n \t\t\tisError: true,\n \t\t},\n+\t\t{\n+\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1:8080/cb\"}},\n+\t\t\turl:     \"http://127.0.0.1:8080/Cb\",\n+\t\t\tisError: true,\n+\t\t},\n+\t\t{\n+\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1:8080/cb\"}},\n+\t\t\turl:     \"http://127.0.0.1:8080/cb?foo=bar\",\n+\t\t\tisError: true,\n+\t\t},\n+\t\t{\n+\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1:8080/cb?foo=bar\"}},\n+\t\t\turl:      \"http://127.0.0.1:8080/cb?foo=bar\",\n+\t\t\texpected: \"http://127.0.0.1:8080/cb?foo=bar\",\n+\t\t\tisError:  false,\n+\t\t},\n+\t\t{\n+\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1:8080/cb?foo=bar\"}},\n+\t\t\turl:     \"http://127.0.0.1:8080/cb?baz=bar&foo=bar\",\n+\t\t\tisError: true,\n+\t\t},\n+\t\t{\n+\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1:8080/cb?foo=bar&baz=bar\"}},\n+\t\t\turl:     \"http://127.0.0.1:8080/cb?baz=bar&foo=bar\",\n+\t\t\tisError: true,\n+\t\t},\n+\t\t{\n+\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"https://www.ory.sh/cb\"}},\n+\t\t\turl:     \"http://127.0.0.1:8080/cb\",\n+\t\t\tisError: true,\n+\t\t},\n+\t\t{\n+\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1:8080/cb\"}},\n+\t\t\turl:     \"https://www.ory.sh/cb\",\n+\t\t\tisError: true,\n+\t\t},\n \t} {\n \t\tredir, err := MatchRedirectURIWithClientRedirectURIs(c.url, c.client)\n-\t\tassert.Equal(t, c.isError, err != nil, \"%d: %s\", k, err)\n+\t\tassert.Equal(t, c.isError, err != nil, \"%d: %+v\", k, c)\n \t\tif err == nil {\n \t\t\trequire.NotNil(t, redir, \"%d\", k)\n \t\t\tassert.Equal(t, c.expected, redir.String(), \"%d\", k)"
        },
        {
          "filename": "helper_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -51,7 +51,7 @@ func TestEscapeJSONString(t *testing.T) {\n \tfor _, str := range []string{\"\", \"foobar\", `foo\"bar`, `foo\\bar`, \"foo\\n\\tbar\"} {\n \t\tescaped := EscapeJSONString(str)\n \t\tvar unmarshaled string\n-\t\terr := json.Unmarshal([]byte(`\"` + escaped + `\"`), &unmarshaled)\n+\t\terr := json.Unmarshal([]byte(`\"`+escaped+`\"`), &unmarshaled)\n \t\trequire.NoError(t, err, str)\n \t\tassert.Equal(t, str, unmarshaled, str)\n \t}"
        }
      ],
      "file_patterns": {
        "security_files": 2,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "049ed1924cd0b41f12357b0fe617530c264421ac",
            "date": "2025-01-02T13:56:36Z",
            "author_login": "ory-bot"
          },
          {
            "sha": "af3992eac8353d44f74e16a70952f6eeaf856893",
            "date": "2025-01-02T12:40:13Z",
            "author_login": "ory-bot"
          },
          {
            "sha": "f2e501049dfaa72d0f62974f2f1f75ab5391fc58",
            "date": "2025-01-02T12:34:58Z",
            "author_login": "ory-bot"
          },
          {
            "sha": "57c58efbf4dc89069addd9f10c1a75fa549e7298",
            "date": "2025-01-02T12:21:36Z",
            "author_login": "ory-bot"
          },
          {
            "sha": "398f862fabde606106fbbafaafb9517db01a4d40",
            "date": "2025-01-02T12:18:49Z",
            "author_login": "ory-bot"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-20",
    "description": "ORY Fosite is a security first OAuth2 & OpenID Connect framework for Go. In Fosite from version 0.30.2 and before version 0.34.1, there is an issue in which an an attacker can override the registered redirect URL by performing an OAuth flow and requesting a redirect URL that is to the loopback adapter. Attackers can provide both custom URL query parameters to their loopback redirect URL, as well as actually overriding the host of the registered redirect URL. These attacks are only applicable in scenarios where the attacker has access over the loopback interface. This vulnerability has been patched in ORY Fosite v0.34.1.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-10-02T21:15:12.403",
    "last_modified": "2024-11-21T05:05:09.047",
    "fix_date": "2020-10-02T10:26:51Z"
  },
  "references": [
    {
      "url": "https://github.com/ory/fosite/commit/cdee51ebe721bfc8acca0fd0b86b030ca70867bf",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ory/fosite/security/advisories/GHSA-rfq3-w54c-f9q5",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ory/fosite/commit/cdee51ebe721bfc8acca0fd0b86b030ca70867bf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ory/fosite/security/advisories/GHSA-rfq3-w54c-f9q5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:06.166793",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "fosite",
    "owner": "ory",
    "created_at": "2015-12-25T14:23:27Z",
    "updated_at": "2025-01-13T20:53:13Z",
    "pushed_at": "2025-01-02T13:56:36Z",
    "size": 7445,
    "stars": 2345,
    "forks": 368,
    "open_issues": 44,
    "watchers": 2345,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Go": 1043530,
      "Shell": 3856,
      "Makefile": 1062
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:22:34.127677"
  }
}