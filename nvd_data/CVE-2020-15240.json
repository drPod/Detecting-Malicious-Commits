{
  "cve_id": "CVE-2020-15240",
  "github_data": {
    "repository": "auth0/omniauth-auth0",
    "fix_commit": "fd3a14f4ccdfbc515d1121d6378ff88bf55a7a7a",
    "related_commits": [
      "fd3a14f4ccdfbc515d1121d6378ff88bf55a7a7a",
      "fd3a14f4ccdfbc515d1121d6378ff88bf55a7a7a"
    ],
    "patch_url": "https://github.com/auth0/omniauth-auth0/commit/fd3a14f4ccdfbc515d1121d6378ff88bf55a7a7a.patch",
    "fix_commit_details": {
      "sha": "fd3a14f4ccdfbc515d1121d6378ff88bf55a7a7a",
      "commit_date": "2020-10-08T20:12:47Z",
      "author": {
        "login": "jimmyjames",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Verify the JWT signature",
        "length": 24,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 266,
        "additions": 236,
        "deletions": 30
      },
      "files": [
        {
          "filename": "lib/omniauth/auth0/jwt_validator.rb",
          "status": "modified",
          "additions": 26,
          "deletions": 3,
          "patch": "@@ -28,17 +28,24 @@ def initialize(options, authorize_params = {})\n         @client_secret = options.client_secret\n       end\n \n+      # Verify a token's signature. Only tokens signed with the RS256 or HS256 signatures are supported.\n+      # @return array - The token's key and signing algorithm\n       def verify_signature(jwt)\n         head = token_head(jwt)\n \n         # Make sure the algorithm is supported and get the decode key.\n         if head[:alg] == 'RS256'\n-          [rs256_decode_key(head[:kid]), head[:alg]]\n+          key, alg = [rs256_decode_key(head[:kid]), head[:alg]]\n         elsif head[:alg] == 'HS256'\n-          [@client_secret, head[:alg]]\n+          key, alg = [@client_secret, head[:alg]]\n         else\n           raise OmniAuth::Auth0::TokenValidationError.new(\"Signature algorithm of #{head[:alg]} is not supported. Expected the ID token to be signed with RS256 or HS256\")\n         end\n+\n+        # Call decode to verify the signature\n+        JWT.decode(jwt, key, true, decode_opts(alg))\n+\n+        return key, alg\n       end\n \n       # Verify a JWT.\n@@ -93,11 +100,27 @@ def jwks_key(key, kid)\n       end\n \n       private\n+      # Get the JWT decode options. We disable the claim checks since we perform our claim validation logic\n+      # Docs: https://github.com/jwt/ruby-jwt\n+      # @return hash\n+      def decode_opts(alg)\n+        {\n+          algorithm: alg,\n+          verify_expiration: false,\n+          verify_iat: false,\n+          verify_iss: false,\n+          verify_aud: false,\n+          verify_jti: false,\n+          verify_subj: false,\n+          verify_not_before: false\n+        }\n+      end\n+\n       def rs256_decode_key(kid)\n         jwks_x5c = jwks_key(:x5c, kid)\n \n         if jwks_x5c.nil?\n-          raise OmniAuth::Auth0::TokenValidationError.new(\"Could not find a public key for Key ID (kid) '#{kid}''\")\n+          raise OmniAuth::Auth0::TokenValidationError.new(\"Could not find a public key for Key ID (kid) '#{kid}'\")\n         end\n \n         jwks_public_cert(jwks_x5c.first)"
        },
        {
          "filename": "spec/omniauth/auth0/jwt_validator_spec.rb",
          "status": "modified",
          "additions": 210,
          "deletions": 27,
          "patch": "@@ -12,17 +12,17 @@\n   let(:domain) { 'samples.auth0.com' }\n   let(:future_timecode) { 32_503_680_000 }\n   let(:past_timecode) { 303_912_000 }\n-  let(:jwks_kid) { 'NkJCQzIyQzRBMEU4NjhGNUU4MzU4RkY0M0ZDQzkwOUQ0Q0VGNUMwQg' }\n+  let(:valid_jwks_kid) { 'NkJCQzIyQzRBMEU4NjhGNUU4MzU4RkY0M0ZDQzkwOUQ0Q0VGNUMwQg' }\n \n   let(:rsa_private_key) do\n     OpenSSL::PKey::RSA.generate 2048\n   end\n \n-  let(:rsa_token_jwks) do\n+  let(:valid_jwks) do\n     {\n       keys: [\n         {\n-          kid: jwks_kid,\n+          kid: valid_jwks_kid,\n           x5c: [Base64.encode64(make_cert(rsa_private_key).to_der)]\n         }\n       ]\n@@ -91,29 +91,29 @@\n     end\n   end\n \n-  describe 'JWT verifier jwks_key' do\n+  describe 'JWT verifier jwks key parsing' do\n     let(:jwt_validator) do\n       make_jwt_validator\n     end\n \n     before do\n-      stub_jwks\n+      stub_complete_jwks\n     end\n \n     it 'should return a key' do\n-      expect(jwt_validator.jwks_key(:alg, jwks_kid)).to eq('RS256')\n+      expect(jwt_validator.jwks_key(:alg, valid_jwks_kid)).to eq('RS256')\n     end\n \n     it 'should return an x5c key' do\n-      expect(jwt_validator.jwks_key(:x5c, jwks_kid).length).to eq(1)\n+      expect(jwt_validator.jwks_key(:x5c, valid_jwks_kid).length).to eq(1)\n     end\n \n     it 'should return nil if there is not key' do\n-      expect(jwt_validator.jwks_key(:auth0, jwks_kid)).to eq(nil)\n+      expect(jwt_validator.jwks_key(:auth0, valid_jwks_kid)).to eq(nil)\n     end\n \n     it 'should return nil if the key ID is invalid' do\n-      expect(jwt_validator.jwks_key(:alg, \"#{jwks_kid}_invalid\")).to eq(nil)\n+      expect(jwt_validator.jwks_key(:alg, \"#{valid_jwks_kid}_invalid\")).to eq(nil)\n     end\n   end\n \n@@ -153,8 +153,24 @@\n     end\n \n     before do\n-      stub_jwks\n-      stub_dummy_jwks\n+      stub_complete_jwks\n+      stub_expected_jwks\n+    end\n+\n+    it 'should fail when JWT is nil' do\n+      expect do\n+        jwt_validator.verify(nil)\n+      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n+        message: \"ID token is required but missing\"\n+      }))\n+    end\n+\n+    it 'should fail when JWT is not well-formed' do\n+      expect do\n+        jwt_validator.verify('abc.123')\n+      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n+        message: \"ID token could not be decoded\"\n+      }))\n     end\n \n     it 'should fail with missing issuer' do\n@@ -248,6 +264,39 @@\n       }))\n     end\n \n+    it 'should pass when past expiration but within default leeway' do\n+      exp = Time.now.to_i - 59\n+      payload = {\n+        iss: \"https://#{domain}/\",\n+        sub: 'sub',\n+        aud: client_id,\n+        exp: exp,\n+        iat: past_timecode\n+      }\n+\n+      token = make_hs256_token(payload)\n+      id_token = jwt_validator.verify(token)\n+      expect(id_token['exp']).to eq(exp)\n+    end\n+\n+    it 'should fail when past expiration and outside default leeway' do\n+      exp = Time.now.to_i - 61\n+      payload = {\n+        iss: \"https://#{domain}/\",\n+        sub: 'sub',\n+        aud: client_id,\n+        exp: exp,\n+        iat: past_timecode\n+      }\n+\n+      token = make_hs256_token(payload)\n+      expect do\n+        jwt_validator.verify(token)\n+      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n+        message: \"Expiration time (exp) claim error in the ID token; current time (#{Time.now}) is after expiration time (#{Time.at(exp + 60)})\"\n+      }))\n+    end\n+\n     it 'should fail when missing iat' do\n       payload = {\n         iss: \"https://#{domain}/\",\n@@ -377,6 +426,114 @@\n       }))\n     end\n \n+    it 'should fail when \u201cmax_age\u201d sent on the authentication request and this claim added the \u201cmax_age\u201d value doesn\u2019t represent a date in the future, outside the default leeway' do\n+      now = Time.now.to_i\n+      auth_time = now - 121\n+      max_age = 60\n+      payload = {\n+        iss: \"https://#{domain}/\",\n+        sub: 'sub',\n+        aud: client_id,\n+        exp: future_timecode,\n+        iat: past_timecode,\n+        auth_time: auth_time\n+      }\n+\n+      token = make_hs256_token(payload)\n+      expect do\n+        jwt_validator.verify(token, { max_age: max_age })\n+        # Time.at(auth_time + max_age + leeway\n+      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n+        message: \"Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (#{Time.now}) is after last auth time (#{Time.at(auth_time + max_age + 60)})\"\n+      }))\n+    end\n+\n+    it 'should verify when \u201cmax_age\u201d sent on the authentication request and this claim added the \u201cmax_age\u201d value doesn\u2019t represent a date in the future, outside the default leeway' do\n+      now = Time.now.to_i\n+      auth_time = now - 119\n+      max_age = 60\n+      payload = {\n+        iss: \"https://#{domain}/\",\n+        sub: 'sub',\n+        aud: client_id,\n+        exp: future_timecode,\n+        iat: past_timecode,\n+        auth_time: auth_time\n+      }\n+\n+      token = make_hs256_token(payload)\n+      id_token = jwt_validator.verify(token, { max_age: max_age })\n+      expect(id_token['auth_time']).to eq(auth_time)\n+    end\n+\n+    it 'should fail for RS256 token when kid is incorrect' do\n+      domain = 'example.org'\n+      sub = 'abc123'\n+      payload = {\n+        sub: sub,\n+        exp: future_timecode,\n+        iss: \"https://#{domain}/\",\n+        iat: past_timecode,\n+        aud: client_id\n+      }\n+      invalid_kid = 'invalid-kid'\n+      token = make_rs256_token(payload, invalid_kid)\n+      expect do\n+        verified_token = make_jwt_validator(opt_domain: domain).verify(token)\n+      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n+        message: \"Could not find a public key for Key ID (kid) 'invalid-kid'\"\n+      }))\n+    end\n+\n+    it 'should fail when RS256 token has invalid signature' do\n+      domain = 'example.org'\n+      sub = 'abc123'\n+      payload = {\n+        sub: sub,\n+        exp: future_timecode,\n+        iss: \"https://#{domain}/\",\n+        iat: past_timecode,\n+        aud: client_id\n+      }\n+      token = make_rs256_token(payload) + 'bad'\n+      expect do\n+        verified_token = make_jwt_validator(opt_domain: domain).verify(token)\n+      end.to raise_error(an_instance_of(JWT::VerificationError).and having_attributes({\n+        message: \"Signature verification raised\"\n+      }))\n+    end\n+\n+    it 'should fail when algorithm is not RS256 or HS256' do\n+      payload = {\n+        iss: \"https://#{domain}/\",\n+        sub: 'abc123',\n+        aud: client_id,\n+        exp: future_timecode,\n+        iat: past_timecode\n+      }\n+      token = JWT.encode payload, 'secret', 'HS384'\n+      expect do\n+        jwt_validator.verify(token)\n+      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n+        message: \"Signature algorithm of HS384 is not supported. Expected the ID token to be signed with RS256 or HS256\"\n+      }))\n+    end\n+\n+    it 'should fail when HS256 token has invalid signature' do\n+      payload = {\n+        iss: \"https://#{domain}/\",\n+        sub: 'abc123',\n+        aud: client_id,\n+        exp: future_timecode,\n+        iat: past_timecode\n+      }\n+      token = make_hs256_token(payload, 'bad_secret')\n+      expect do\n+        # validator is configured to use \"CLIENT_SECRET\" by default\n+        jwt_validator.verify(token)\n+      end.to raise_error(an_instance_of(JWT::VerificationError))\n+    end\n+\n     it 'should verify a valid HS256 token with multiple audiences' do\n       audience = [\n         client_id,\n@@ -417,13 +574,44 @@\n         exp: future_timecode,\n         iss: \"https://#{domain}/\",\n         iat: past_timecode,\n-        aud: client_id,\n-        kid: jwks_kid\n+        aud: client_id\n       }\n       token = make_rs256_token(payload)\n       verified_token = make_jwt_validator(opt_domain: domain).verify(token)\n       expect(verified_token['sub']).to eq(sub)\n     end\n+\n+    it 'should verify a HS256 JWT signature when calling verify signature directly' do\n+      sub = 'abc123'\n+        payload = {\n+          iss: \"https://#{domain}/\",\n+          sub: sub,\n+          aud: client_id,\n+          exp: future_timecode,\n+          iat: past_timecode\n+        }\n+        token = make_hs256_token(payload)\n+        verified_token_signature = jwt_validator.verify_signature(token)\n+        expect(verified_token_signature[0]).to eq('CLIENT_SECRET')\n+        expect(verified_token_signature[1]).to eq('HS256')\n+    end\n+\n+    it 'should verify a RS256 JWT signature verify signature directly' do\n+      domain = 'example.org'\n+      sub = 'abc123'\n+      payload = {\n+        sub: sub,\n+        exp: future_timecode,\n+        iss: \"https://#{domain}/\",\n+        iat: past_timecode,\n+        aud: client_id\n+      }\n+      token = make_rs256_token(payload)\n+      verified_token_signature = make_jwt_validator(opt_domain: domain).verify_signature(token)\n+      expect(verified_token_signature.length).to be(2)\n+      expect(verified_token_signature[0]).to be_a(OpenSSL::PKey::RSA)\n+      expect(verified_token_signature[1]).to eq('RS256')\n+    end\n   end\n \n   private\n@@ -439,14 +627,16 @@ def make_jwt_validator(opt_domain: domain, opt_issuer: nil)\n     OmniAuth::Auth0::JWTValidator.new(opts)\n   end\n \n-  def make_hs256_token(payload = nil)\n+  def make_hs256_token(payload = nil, secret = nil)\n     payload = { sub: 'abc123' } if payload.nil?\n-    JWT.encode payload, client_secret, 'HS256'\n+    secret = client_secret if secret.nil?\n+    JWT.encode payload, secret, 'HS256'\n   end\n \n-  def make_rs256_token(payload = nil)\n+  def make_rs256_token(payload = nil, kid = nil)\n     payload = { sub: 'abc123' } if payload.nil?\n-    JWT.encode payload, rsa_private_key, 'RS256', kid: jwks_kid\n+    kid = valid_jwks_kid if kid.nil?\n+    JWT.encode payload, rsa_private_key, 'RS256', kid: kid\n   end\n \n   def make_cert(private_key)\n@@ -474,7 +664,7 @@ def make_cert(private_key)\n     cert.sign private_key, OpenSSL::Digest::SHA1.new\n   end\n \n-  def stub_jwks\n+  def stub_complete_jwks\n     stub_request(:get, 'https://samples.auth0.com/.well-known/jwks.json')\n       .to_return(\n         headers: { 'Content-Type' => 'application/json' },\n@@ -483,18 +673,11 @@ def stub_jwks\n       )\n   end\n \n-  def stub_bad_jwks\n-    stub_request(:get, 'https://samples.auth0.com/.well-known/jwks-bad.json')\n-      .to_return(\n-        status: 404\n-      )\n-  end\n-\n-  def stub_dummy_jwks\n+  def stub_expected_jwks\n     stub_request(:get, 'https://example.org/.well-known/jwks.json')\n       .to_return(\n         headers: { 'Content-Type' => 'application/json' },\n-        body: rsa_token_jwks,\n+        body: valid_jwks,\n         status: 200\n       )\n   end"
        }
      ],
      "file_patterns": {
        "security_files": 2,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2e2e2488af0da877740aa187b4a3304f509b3b67",
            "date": "2024-10-31T08:17:32Z",
            "author_login": "kishore7snehil"
          },
          {
            "sha": "313e3b58c8e1768701bdfc4c76c592d6337bd8b6",
            "date": "2024-10-09T06:58:47Z",
            "author_login": "arpit-jn"
          },
          {
            "sha": "8e2c478016515130fdc14e7fce521d7fcf9c09a9",
            "date": "2024-10-04T08:04:14Z",
            "author_login": "arpit-jn"
          },
          {
            "sha": "0cd8eb5b5493319fa5de400b3ff28c42fd8e7528",
            "date": "2024-08-05T10:05:55Z",
            "author_login": "arpit-jn"
          },
          {
            "sha": "4b8302b5722efb70ecde98d4c0e5701d855fa12e",
            "date": "2024-07-25T14:25:20Z",
            "author_login": "stevenwong-okta"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-287",
    "description": "omniauth-auth0 (rubygems) versions >= 2.3.0 and < 2.4.1 improperly validate the JWT token signature when using the `jwt_validator.verify` method. Improper validation of the JWT token signature can allow an attacker to bypass authentication and authorization. You are affected by this vulnerability if all of the following conditions apply: 1. You are using `omniauth-auth0`. 2. You are using `JWTValidator.verify` method directly OR you are not authenticating using the SDK\u2019s default Authorization Code Flow. The issue is patched in version 2.4.1.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-10-21T18:15:12.813",
    "last_modified": "2024-11-21T05:05:10.037",
    "fix_date": "2020-10-08T20:12:47Z"
  },
  "references": [
    {
      "url": "https://github.com/auth0/omniauth-auth0/commit/fd3a14f4ccdfbc515d1121d6378ff88bf55a7a7a",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/auth0/omniauth-auth0/security/advisories/GHSA-58r4-h6v8-jcvm",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://rubygems.org/gems/omniauth-auth0",
      "source": "security-advisories@github.com",
      "tags": [
        "Product",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/auth0/omniauth-auth0/commit/fd3a14f4ccdfbc515d1121d6378ff88bf55a7a7a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/auth0/omniauth-auth0/security/advisories/GHSA-58r4-h6v8-jcvm",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://rubygems.org/gems/omniauth-auth0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:06.187984",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "omniauth-auth0",
    "owner": "auth0",
    "created_at": "2013-04-15T20:05:53Z",
    "updated_at": "2024-10-31T08:17:36Z",
    "pushed_at": "2024-11-18T11:44:51Z",
    "size": 469,
    "stars": 125,
    "forks": 68,
    "open_issues": 8,
    "watchers": 125,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Ruby": 63288
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T19:53:15.092491"
  }
}