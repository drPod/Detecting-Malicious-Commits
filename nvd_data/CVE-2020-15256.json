{
  "cve_id": "CVE-2020-15256",
  "github_data": {
    "repository": "mariocasciaro/object-path",
    "fix_commit": "2be3354c6c46215c7635eb1b76d80f1319403c68",
    "related_commits": [
      "2be3354c6c46215c7635eb1b76d80f1319403c68",
      "2be3354c6c46215c7635eb1b76d80f1319403c68"
    ],
    "patch_url": "https://github.com/mariocasciaro/object-path/commit/2be3354c6c46215c7635eb1b76d80f1319403c68.patch",
    "fix_commit_details": {
      "sha": "2be3354c6c46215c7635eb1b76d80f1319403c68",
      "commit_date": "2020-10-10T16:25:50Z",
      "author": {
        "login": "mariocasciaro",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix prototype pollution in set()",
        "length": 32,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 1484,
        "additions": 765,
        "deletions": 719
      },
      "files": [
        {
          "filename": "index.js",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -112,6 +112,10 @@\n       }\n       var currentPath = path[0];\n       var currentValue = getShallowProperty(obj, currentPath);\n+      if (options.includeInheritedProps && (currentPath === '__proto__' ||\n+        (currentPath === 'constructor' && typeof currentValue === 'function'))) {\n+        throw new Error('For security reasons, object\\'s magic properties cannot be set')\n+      }\n       if (path.length === 1) {\n         if (currentValue === void 0 || !doNotReplace) {\n           obj[currentPath] = value;"
        },
        {
          "filename": "test.js",
          "status": "modified",
          "additions": 761,
          "deletions": 719,
          "patch": "@@ -1,947 +1,989 @@\n-'use strict';\n+'use strict'\n var expect = require('chai').expect,\n-objectPath = require('./index.js');\n+  objectPath = require('./index.js')\n \n \n-function getTestObj() {\n+function getTestObj () {\n   return {\n     a: 'b',\n     b: {\n       c: [],\n       d: ['a', 'b'],\n-      e: [{},{f: 'g'}],\n+      e: [{}, {f: 'g'}],\n       f: 'i'\n     }\n-  };\n+  }\n }\n \n-describe('get', function() {\n-  it('should return the value using unicode key', function() {\n+describe('get', function () {\n+  it('should return the value using unicode key', function () {\n     var obj = {\n       '15\\u00f8C': {\n         '3\\u0111': 1\n       }\n-    };\n-    expect(objectPath.get(obj, '15\\u00f8C.3\\u0111')).to.be.equal(1);\n-    expect(objectPath.get(obj, ['15\\u00f8C','3\\u0111'])).to.be.equal(1);\n-  });\n+    }\n+    expect(objectPath.get(obj, '15\\u00f8C.3\\u0111')).to.be.equal(1)\n+    expect(objectPath.get(obj, ['15\\u00f8C', '3\\u0111'])).to.be.equal(1)\n+  })\n \n-  it('should return the value using dot in key', function() {\n+  it('should return the value using dot in key', function () {\n     var obj = {\n       'a.b': {\n         'looks.like': 1\n       }\n-    };\n-    expect(objectPath.get(obj, 'a.b.looks.like')).to.be.equal(void 0);\n-    expect(objectPath.get(obj, ['a.b','looks.like'])).to.be.equal(1);\n-  });\n-\n-  it('should return the value under shallow object', function() {\n-    var obj = getTestObj();\n-    expect(objectPath.get(obj, 'a')).to.be.equal('b');\n-    expect(objectPath.get(obj, ['a'])).to.be.equal('b');\n-  });\n-\n-  it('should work with number path', function() {\n-    var obj = getTestObj();\n-    expect(objectPath.get(obj.b.d, 0)).to.be.equal('a');\n-    expect(objectPath.get(obj.b, 0)).to.be.equal(void 0);\n-  });\n-\n-  it('should return the value under deep object', function() {\n-    var obj = getTestObj();\n-    expect(objectPath.get(obj, 'b.f')).to.be.equal('i');\n-    expect(objectPath.get(obj, ['b','f'])).to.be.equal('i');\n-  });\n-\n-  it('should return the value under array', function() {\n-    var obj = getTestObj();\n-    expect(objectPath.get(obj, 'b.d.0')).to.be.equal('a');\n-    expect(objectPath.get(obj, ['b','d',0])).to.be.equal('a');\n-  });\n-\n-  it('should return the value under array deep', function() {\n-    var obj = getTestObj();\n-    expect(objectPath.get(obj, 'b.e.1.f')).to.be.equal('g');\n-    expect(objectPath.get(obj, ['b','e',1,'f'])).to.be.equal('g');\n-  });\n-\n-  it('should return undefined for missing values under object', function() {\n-    var obj = getTestObj();\n-    expect(objectPath.get(obj, 'a.b')).to.not.exist;\n-    expect(objectPath.get(obj, ['a','b'])).to.not.exist;\n-  });\n-\n-  it('should return undefined for missing values under array', function() {\n-    var obj = getTestObj();\n-    expect(objectPath.get(obj, 'b.d.5')).to.not.exist;\n-    expect(objectPath.get(obj, ['b','d','5'])).to.not.exist;\n-  });\n-\n-  it('should return the value under integer-like key', function() {\n-    var obj = { '1a': 'foo' };\n-    expect(objectPath.get(obj, '1a')).to.be.equal('foo');\n-    expect(objectPath.get(obj, ['1a'])).to.be.equal('foo');\n-  });\n-\n-  it('should return the default value when the key doesnt exist', function() {\n-    var obj = { '1a': 'foo' };\n-    expect(objectPath.get(obj, '1b', null)).to.be.equal(null);\n-    expect(objectPath.get(obj, ['1b'], null)).to.be.equal(null);\n-  });\n-\n-  it('should return the default value when path is empty', function() {\n-    var obj = { '1a': 'foo' };\n-    expect(objectPath.get(obj, '', null)).to.be.deep.equal({ '1a': 'foo' });\n-    expect(objectPath.get(obj, [])).to.be.deep.equal({ '1a': 'foo' });\n-    expect(objectPath.get({  }, ['1'])).to.be.equal(undefined);\n-  });\n-\n-  it('should return the default value when object is null or undefined', function() {\n-    expect(objectPath.get(null, 'test', 'a')).to.be.deep.equal('a');\n-    expect(objectPath.get(undefined, 'test', 'a')).to.be.deep.equal('a');\n-  });\n+    }\n+    expect(objectPath.get(obj, 'a.b.looks.like')).to.be.equal(void 0)\n+    expect(objectPath.get(obj, ['a.b', 'looks.like'])).to.be.equal(1)\n+  })\n+\n+  it('should return the value under shallow object', function () {\n+    var obj = getTestObj()\n+    expect(objectPath.get(obj, 'a')).to.be.equal('b')\n+    expect(objectPath.get(obj, ['a'])).to.be.equal('b')\n+  })\n+\n+  it('should work with number path', function () {\n+    var obj = getTestObj()\n+    expect(objectPath.get(obj.b.d, 0)).to.be.equal('a')\n+    expect(objectPath.get(obj.b, 0)).to.be.equal(void 0)\n+  })\n+\n+  it('should return the value under deep object', function () {\n+    var obj = getTestObj()\n+    expect(objectPath.get(obj, 'b.f')).to.be.equal('i')\n+    expect(objectPath.get(obj, ['b', 'f'])).to.be.equal('i')\n+  })\n+\n+  it('should return the value under array', function () {\n+    var obj = getTestObj()\n+    expect(objectPath.get(obj, 'b.d.0')).to.be.equal('a')\n+    expect(objectPath.get(obj, ['b', 'd', 0])).to.be.equal('a')\n+  })\n+\n+  it('should return the value under array deep', function () {\n+    var obj = getTestObj()\n+    expect(objectPath.get(obj, 'b.e.1.f')).to.be.equal('g')\n+    expect(objectPath.get(obj, ['b', 'e', 1, 'f'])).to.be.equal('g')\n+  })\n+\n+  it('should return undefined for missing values under object', function () {\n+    var obj = getTestObj()\n+    expect(objectPath.get(obj, 'a.b')).to.not.exist\n+    expect(objectPath.get(obj, ['a', 'b'])).to.not.exist\n+  })\n+\n+  it('should return undefined for missing values under array', function () {\n+    var obj = getTestObj()\n+    expect(objectPath.get(obj, 'b.d.5')).to.not.exist\n+    expect(objectPath.get(obj, ['b', 'd', '5'])).to.not.exist\n+  })\n+\n+  it('should return the value under integer-like key', function () {\n+    var obj = {'1a': 'foo'}\n+    expect(objectPath.get(obj, '1a')).to.be.equal('foo')\n+    expect(objectPath.get(obj, ['1a'])).to.be.equal('foo')\n+  })\n+\n+  it('should return the default value when the key doesnt exist', function () {\n+    var obj = {'1a': 'foo'}\n+    expect(objectPath.get(obj, '1b', null)).to.be.equal(null)\n+    expect(objectPath.get(obj, ['1b'], null)).to.be.equal(null)\n+  })\n+\n+  it('should return the default value when path is empty', function () {\n+    var obj = {'1a': 'foo'}\n+    expect(objectPath.get(obj, '', null)).to.be.deep.equal({'1a': 'foo'})\n+    expect(objectPath.get(obj, [])).to.be.deep.equal({'1a': 'foo'})\n+    expect(objectPath.get({}, ['1'])).to.be.equal(undefined)\n+  })\n+\n+  it('should return the default value when object is null or undefined', function () {\n+    expect(objectPath.get(null, 'test', 'a')).to.be.deep.equal('a')\n+    expect(objectPath.get(undefined, 'test', 'a')).to.be.deep.equal('a')\n+  })\n \n   it(\n     'should not fail on an object with a null prototype',\n-    function assertSuccessForObjWithNullProto(){\n-      var foo = 'FOO';\n-      var objWithNullProto = Object.create(null);\n-      objWithNullProto.foo = foo;\n-      expect(objectPath.get(objWithNullProto, 'foo')).to.equal(foo);\n+    function assertSuccessForObjWithNullProto () {\n+      var foo = 'FOO'\n+      var objWithNullProto = Object.create(null)\n+      objWithNullProto.foo = foo\n+      expect(objectPath.get(objWithNullProto, 'foo')).to.equal(foo)\n     }\n-  );\n+  )\n \n-  it('should skip non own properties', function() {\n-    var Base = function(enabled){ };\n+  it('should skip non own properties', function () {\n+    var Base = function (enabled) {\n+    }\n     Base.prototype = {\n       one: {\n         two: true\n       }\n-    };\n-    var Extended = function(){\n-      Base.call(this,  true);\n-    };\n-    Extended.prototype = Object.create(Base.prototype);\n+    }\n+    var Extended = function () {\n+      Base.call(this, true)\n+    }\n+    Extended.prototype = Object.create(Base.prototype)\n \n-    var extended = new Extended();\n+    var extended = new Extended()\n \n-    expect(objectPath.get(extended, ['one','two'])).to.be.equal(undefined);\n-    extended.enabled = true;\n+    expect(objectPath.get(extended, ['one', 'two'])).to.be.equal(undefined)\n+    extended.enabled = true\n \n-    expect(objectPath.get(extended, 'enabled')).to.be.equal(true);\n-    expect(objectPath.get(extended, 'one')).to.be.equal(undefined);\n-  });\n-});\n+    expect(objectPath.get(extended, 'enabled')).to.be.equal(true)\n+    expect(objectPath.get(extended, 'one')).to.be.equal(undefined)\n+  })\n+})\n \n \n-describe('set', function() {\n-  it('should set the value using unicode key', function() {\n+describe('set', function () {\n+  it('should set the value using unicode key', function () {\n     var obj = {\n       '15\\u00f8C': {\n         '3\\u0111': 1\n       }\n-    };\n-    objectPath.set(obj, '15\\u00f8C.3\\u0111', 2);\n-    expect(objectPath.get(obj, '15\\u00f8C.3\\u0111')).to.be.equal(2);\n-    objectPath.set(obj, '15\\u00f8C.3\\u0111', 3);\n-    expect(objectPath.get(obj, ['15\\u00f8C','3\\u0111'])).to.be.equal(3);\n-  });\n-\n-  it('should set the value using dot in key', function() {\n+    }\n+    objectPath.set(obj, '15\\u00f8C.3\\u0111', 2)\n+    expect(objectPath.get(obj, '15\\u00f8C.3\\u0111')).to.be.equal(2)\n+    objectPath.set(obj, '15\\u00f8C.3\\u0111', 3)\n+    expect(objectPath.get(obj, ['15\\u00f8C', '3\\u0111'])).to.be.equal(3)\n+  })\n+\n+  it('should set the value using dot in key', function () {\n     var obj = {\n       'a.b': {\n         'looks.like': 1\n       }\n-    };\n-    objectPath.set(obj, ['a.b','looks.like'], 2);\n-    expect(objectPath.get(obj, ['a.b','looks.like'])).to.be.equal(2);\n-  });\n-\n-  it('should set value under shallow object', function() {\n-    var obj = getTestObj();\n-    objectPath.set(obj, 'c', {m: 'o'});\n-    expect(obj).to.include.nested.property('c.m', 'o');\n-    obj = getTestObj();\n-    objectPath.set(obj, ['c'], {m: 'o'});\n-    expect(obj).to.include.nested.property('c.m', 'o');\n-  });\n-\n-  it('should set value using number path', function() {\n-    var obj = getTestObj();\n-    objectPath.set(obj.b.d, 0, 'o');\n-    expect(obj).to.have.nested.property('b.d.0', 'o');\n-  });\n-\n-  it('should set value under deep object', function() {\n-    var obj = getTestObj();\n-    objectPath.set(obj, 'b.c', 'o');\n-    expect(obj).to.have.nested.property('b.c', 'o');\n-    obj = getTestObj();\n-    objectPath.set(obj, ['b','c'], 'o');\n-    expect(obj).to.have.nested.property('b.c', 'o');\n-  });\n-\n-  it('should set value under array', function() {\n-    var obj = getTestObj();\n-    objectPath.set(obj, 'b.e.1.g', 'f');\n-    expect(obj).to.have.nested.property('b.e.1.g', 'f');\n-    obj = getTestObj();\n-    objectPath.set(obj, ['b','e',1,'g'], 'f');\n-    expect(obj).to.have.nested.property('b.e.1.g', 'f');\n+    }\n+    objectPath.set(obj, ['a.b', 'looks.like'], 2)\n+    expect(objectPath.get(obj, ['a.b', 'looks.like'])).to.be.equal(2)\n+  })\n+\n+  it('should set value under shallow object', function () {\n+    var obj = getTestObj()\n+    objectPath.set(obj, 'c', {m: 'o'})\n+    expect(obj).to.include.nested.property('c.m', 'o')\n+    obj = getTestObj()\n+    objectPath.set(obj, ['c'], {m: 'o'})\n+    expect(obj).to.include.nested.property('c.m', 'o')\n+  })\n+\n+  it('should set value using number path', function () {\n+    var obj = getTestObj()\n+    objectPath.set(obj.b.d, 0, 'o')\n+    expect(obj).to.have.nested.property('b.d.0', 'o')\n+  })\n+\n+  it('should set value under deep object', function () {\n+    var obj = getTestObj()\n+    objectPath.set(obj, 'b.c', 'o')\n+    expect(obj).to.have.nested.property('b.c', 'o')\n+    obj = getTestObj()\n+    objectPath.set(obj, ['b', 'c'], 'o')\n+    expect(obj).to.have.nested.property('b.c', 'o')\n+  })\n+\n+  it('should set value under array', function () {\n+    var obj = getTestObj()\n+    objectPath.set(obj, 'b.e.1.g', 'f')\n+    expect(obj).to.have.nested.property('b.e.1.g', 'f')\n+    obj = getTestObj()\n+    objectPath.set(obj, ['b', 'e', 1, 'g'], 'f')\n+    expect(obj).to.have.nested.property('b.e.1.g', 'f')\n \n     obj = {}\n-    objectPath.set(obj, 'b.0', 'a');\n-    objectPath.set(obj, 'b.1', 'b');\n-    expect(obj.b).to.be.deep.equal(['a', 'b']);\n-  });\n-\n-  it('should create intermediate objects', function() {\n-    var obj = getTestObj();\n-    objectPath.set(obj, 'c.d.e.f', 'l');\n-    expect(obj).to.have.nested.property('c.d.e.f', 'l');\n-    obj = getTestObj();\n-    objectPath.set(obj, ['c','d','e','f'], 'l');\n-    expect(obj).to.have.nested.property('c.d.e.f', 'l');\n-  });\n-\n-  it('should create intermediate arrays', function() {\n-    var obj = getTestObj();\n-    objectPath.set(obj, 'c.0.1.m', 'l');\n-    expect(obj.c).to.be.an('array');\n-    expect(obj.c[0]).to.be.an('array');\n-    expect(obj).to.have.nested.property('c.0.1.m', 'l');\n-    obj = getTestObj();\n-    objectPath.set(obj, ['c','0', 1,'m'], 'l');\n-    expect(obj.c).to.be.an('object');\n-    expect(obj.c[0]).to.be.an('array');\n-    expect(obj).to.have.nested.property('c.0.1.m', 'l');\n-  });\n-\n-  it('should set value under integer-like key', function() {\n-    var obj = getTestObj();\n-    objectPath.set(obj, '1a', 'foo');\n-    expect(obj).to.have.nested.property('1a', 'foo');\n-    obj = getTestObj();\n-    objectPath.set(obj, ['1a'], 'foo');\n-    expect(obj).to.have.nested.property('1a', 'foo');\n-  });\n-\n-  it('should set value under empty array', function() {\n-    var obj = [];\n-    objectPath.set(obj, [0], 'foo');\n-    expect(obj[0]).to.be.equal('foo');\n-    obj = [];\n-    objectPath.set(obj, '0', 'foo');\n-    expect(obj[0]).to.be.equal('foo');\n-  });\n-});\n-\n-\n-describe('push', function() {\n-  it('should push value to existing array using unicode key', function() {\n-    var obj = getTestObj();\n-    objectPath.push(obj, 'b.\\u1290c', 'l');\n-    expect(obj).to.have.nested.property('b.\\u1290c.0', 'l');\n-    objectPath.push(obj, ['b','\\u1290c'], 'l');\n-    expect(obj).to.have.nested.property('b.\\u1290c.1', 'l');\n-  });\n-\n-  it('should push value to existing array using dot key', function() {\n-    var obj = getTestObj();\n-    objectPath.push(obj, ['b','z.d'], 'l');\n-    expect(objectPath.get(obj, ['b','z.d', 0])).to.be.equal('l');\n-  });\n-\n-  it('should push value to existing array', function() {\n-    var obj = getTestObj();\n-    objectPath.push(obj, 'b.c', 'l');\n-    expect(obj).to.have.nested.property('b.c.0', 'l');\n-    obj = getTestObj();\n-    objectPath.push(obj, ['b','c'], 'l');\n-    expect(obj).to.have.nested.property('b.c.0', 'l');\n-  });\n-\n-  it('should push value to new array', function() {\n-    var obj = getTestObj();\n-    objectPath.push(obj, 'b.h', 'l');\n-    expect(obj).to.have.nested.property('b.h.0', 'l');\n-    obj = getTestObj();\n-    objectPath.push(obj, ['b','h'], 'l');\n-    expect(obj).to.have.nested.property('b.h.0', 'l');\n-  });\n-\n-  it('should push value to existing array using number path', function() {\n-    var obj = getTestObj();\n-    objectPath.push(obj.b.e, 0, 'l');\n-    expect(obj).to.have.nested.property('b.e.0.0', 'l');\n-  });\n-\n-});\n-\n-\n-describe('ensureExists', function() {\n-  it('should create the path if it does not exists', function() {\n-    var obj = getTestObj();\n-    var oldVal = objectPath.ensureExists(obj, 'b.g.1.l', 'test');\n-    expect(oldVal).to.not.exist;\n-    expect(obj).to.have.nested.property('b.g.1.l', 'test');\n-    oldVal = objectPath.ensureExists(obj, 'b.g.1.l', 'test1');\n-    expect(oldVal).to.be.equal('test');\n-    expect(obj).to.have.nested.property('b.g.1.l', 'test');\n-    oldVal = objectPath.ensureExists(obj, 'b.\\u8210', 'ok');\n-    expect(oldVal).to.not.exist;\n-    expect(obj).to.have.nested.property('b.\\u8210', 'ok');\n-    oldVal = objectPath.ensureExists(obj, ['b','dot.dot'], 'ok');\n-    expect(oldVal).to.not.exist;\n-    expect(objectPath.get(obj, ['b','dot.dot'])).to.be.equal('ok');\n-  });\n-\n-\n-  it('should return the object if path is empty', function() {\n-    var obj = getTestObj();\n-    expect(objectPath.ensureExists(obj, [], 'test')).to.have.property('a', 'b');\n-  });\n-\n-  it('Issue #26', function() {\n-    var any = {};\n-    objectPath.ensureExists(any, ['1','1'], {});\n-    expect(any).to.be.an('object');\n-    expect(any[1]).to.be.an('object');\n-    expect(any[1][1]).to.be.an('object');\n-  });\n-});\n-\n-describe('coalesce', function(){\n-  it('should return the first non-undefined value', function(){\n+    objectPath.set(obj, 'b.0', 'a')\n+    objectPath.set(obj, 'b.1', 'b')\n+    expect(obj.b).to.be.deep.equal(['a', 'b'])\n+  })\n+\n+  it('should create intermediate objects', function () {\n+    var obj = getTestObj()\n+    objectPath.set(obj, 'c.d.e.f', 'l')\n+    expect(obj).to.have.nested.property('c.d.e.f', 'l')\n+    obj = getTestObj()\n+    objectPath.set(obj, ['c', 'd', 'e', 'f'], 'l')\n+    expect(obj).to.have.nested.property('c.d.e.f', 'l')\n+  })\n+\n+  it('should create intermediate arrays', function () {\n+    var obj = getTestObj()\n+    objectPath.set(obj, 'c.0.1.m', 'l')\n+    expect(obj.c).to.be.an('array')\n+    expect(obj.c[0]).to.be.an('array')\n+    expect(obj).to.have.nested.property('c.0.1.m', 'l')\n+    obj = getTestObj()\n+    objectPath.set(obj, ['c', '0', 1, 'm'], 'l')\n+    expect(obj.c).to.be.an('object')\n+    expect(obj.c[0]).to.be.an('array')\n+    expect(obj).to.have.nested.property('c.0.1.m', 'l')\n+  })\n+\n+  it('should set value under integer-like key', function () {\n+    var obj = getTestObj()\n+    objectPath.set(obj, '1a', 'foo')\n+    expect(obj).to.have.nested.property('1a', 'foo')\n+    obj = getTestObj()\n+    objectPath.set(obj, ['1a'], 'foo')\n+    expect(obj).to.have.nested.property('1a', 'foo')\n+  })\n+\n+  it('should set value under empty array', function () {\n+    var obj = []\n+    objectPath.set(obj, [0], 'foo')\n+    expect(obj[0]).to.be.equal('foo')\n+    obj = []\n+    objectPath.set(obj, '0', 'foo')\n+    expect(obj[0]).to.be.equal('foo')\n+  })\n+\n+  it('[security] should not set magic properties in default mode', function () {\n+    objectPath.set({}, '__proto__.injected', 'this is bad')\n+    expect(Object.prototype.injected).to.be.undefined\n+\n+    function Clazz() {}\n+    Clazz.prototype.test = 'original'\n+\n+    objectPath.set(new Clazz(), '__proto__.test', 'this is bad')\n+    expect(Clazz.prototype.test).to.be.equal('original')\n+\n+    objectPath.set(new Clazz(), 'constructor.prototype.test', 'this is bad')\n+    expect(Clazz.prototype.test).to.be.equal('original')\n+  })\n+\n+  it('[security] should throw an exception if trying to set magic properties in inheritedProps mode', function () {\n+    expect(function() {objectPath.withInheritedProps.set({}, '__proto__.injected', 'this is bad')})\n+      .to.throw('For security reasons')\n+    expect(Object.prototype.injected).to.be.undefined\n+\n+    function Clazz() {}\n+    Clazz.prototype.test = 'original'\n+\n+    expect(function() {objectPath.withInheritedProps.set(new Clazz(), '__proto__.test', 'this is bad')})\n+      .to.throw('For security reasons')\n+    expect(Clazz.prototype.test).to.be.equal('original')\n+\n+    expect(function() {objectPath.withInheritedProps.set(new Clazz(), 'constructor.prototype.test', 'this is bad')})\n+      .to.throw('For security reasons')\n+    expect(Clazz.prototype.test).to.be.equal('original')\n+\n+    const obj = {}\n+    expect(function() {objectPath.withInheritedProps.set(obj, 'constructor.prototype.injected', 'this is OK')})\n+      .to.throw('For security reasons')\n+    expect(Object.prototype.injected).to.be.undefined\n+  })\n+})\n+\n+\n+describe('push', function () {\n+  it('should push value to existing array using unicode key', function () {\n+    var obj = getTestObj()\n+    objectPath.push(obj, 'b.\\u1290c', 'l')\n+    expect(obj).to.have.nested.property('b.\\u1290c.0', 'l')\n+    objectPath.push(obj, ['b', '\\u1290c'], 'l')\n+    expect(obj).to.have.nested.property('b.\\u1290c.1', 'l')\n+  })\n+\n+  it('should push value to existing array using dot key', function () {\n+    var obj = getTestObj()\n+    objectPath.push(obj, ['b', 'z.d'], 'l')\n+    expect(objectPath.get(obj, ['b', 'z.d', 0])).to.be.equal('l')\n+  })\n+\n+  it('should push value to existing array', function () {\n+    var obj = getTestObj()\n+    objectPath.push(obj, 'b.c', 'l')\n+    expect(obj).to.have.nested.property('b.c.0', 'l')\n+    obj = getTestObj()\n+    objectPath.push(obj, ['b', 'c'], 'l')\n+    expect(obj).to.have.nested.property('b.c.0', 'l')\n+  })\n+\n+  it('should push value to new array', function () {\n+    var obj = getTestObj()\n+    objectPath.push(obj, 'b.h', 'l')\n+    expect(obj).to.have.nested.property('b.h.0', 'l')\n+    obj = getTestObj()\n+    objectPath.push(obj, ['b', 'h'], 'l')\n+    expect(obj).to.have.nested.property('b.h.0', 'l')\n+  })\n+\n+  it('should push value to existing array using number path', function () {\n+    var obj = getTestObj()\n+    objectPath.push(obj.b.e, 0, 'l')\n+    expect(obj).to.have.nested.property('b.e.0.0', 'l')\n+  })\n+\n+})\n+\n+\n+describe('ensureExists', function () {\n+  it('should create the path if it does not exists', function () {\n+    var obj = getTestObj()\n+    var oldVal = objectPath.ensureExists(obj, 'b.g.1.l', 'test')\n+    expect(oldVal).to.not.exist\n+    expect(obj).to.have.nested.property('b.g.1.l', 'test')\n+    oldVal = objectPath.ensureExists(obj, 'b.g.1.l', 'test1')\n+    expect(oldVal).to.be.equal('test')\n+    expect(obj).to.have.nested.property('b.g.1.l', 'test')\n+    oldVal = objectPath.ensureExists(obj, 'b.\\u8210', 'ok')\n+    expect(oldVal).to.not.exist\n+    expect(obj).to.have.nested.property('b.\\u8210', 'ok')\n+    oldVal = objectPath.ensureExists(obj, ['b', 'dot.dot'], 'ok')\n+    expect(oldVal).to.not.exist\n+    expect(objectPath.get(obj, ['b', 'dot.dot'])).to.be.equal('ok')\n+  })\n+\n+\n+  it('should return the object if path is empty', function () {\n+    var obj = getTestObj()\n+    expect(objectPath.ensureExists(obj, [], 'test')).to.have.property('a', 'b')\n+  })\n+\n+  it('Issue #26', function () {\n+    var any = {}\n+    objectPath.ensureExists(any, ['1', '1'], {})\n+    expect(any).to.be.an('object')\n+    expect(any[1]).to.be.an('object')\n+    expect(any[1][1]).to.be.an('object')\n+  })\n+})\n+\n+describe('coalesce', function () {\n+  it('should return the first non-undefined value', function () {\n     var obj = {\n       should: {have: 'prop'}\n-    };\n+    }\n \n     expect(objectPath.coalesce(obj, [\n       'doesnt.exist',\n-      ['might','not','exist'],\n+      ['might', 'not', 'exist'],\n       'should.have'\n-    ])).to.equal('prop');\n-  });\n+    ])).to.equal('prop')\n+  })\n \n-  it('should work with falsy values (null, 0, \\'\\', false)', function(){\n+  it('should work with falsy values (null, 0, \\'\\', false)', function () {\n     var obj = {\n       is: {\n         false: false,\n         null: null,\n         empty: '',\n         zero: 0\n       }\n-    };\n+    }\n \n     expect(objectPath.coalesce(obj, [\n       'doesnt.exist',\n       'is.zero'\n-    ])).to.equal(0);\n+    ])).to.equal(0)\n \n     expect(objectPath.coalesce(obj, [\n       'doesnt.exist',\n       'is.false'\n-    ])).to.equal(false);\n+    ])).to.equal(false)\n \n     expect(objectPath.coalesce(obj, [\n       'doesnt.exist',\n       'is.null'\n-    ])).to.equal(null);\n+    ])).to.equal(null)\n \n     expect(objectPath.coalesce(obj, [\n       'doesnt.exist',\n       'is.empty'\n-    ])).to.equal('');\n-  });\n+    ])).to.equal('')\n+  })\n \n-  it('returns defaultValue if no paths found', function(){\n+  it('returns defaultValue if no paths found', function () {\n     var obj = {\n       doesnt: 'matter'\n-    };\n+    }\n \n-    expect(objectPath.coalesce(obj, ['some.inexistant','path',['on','object']], 'false')).to.equal('false');\n-  });\n+    expect(objectPath.coalesce(obj, ['some.inexistant', 'path', ['on', 'object']], 'false')).to.equal('false')\n+  })\n \n-  it('works with unicode and dot keys', function(){\n+  it('works with unicode and dot keys', function () {\n     var obj = {\n       '\\u7591': true,\n       'dot.dot': false\n-    };\n+    }\n \n-    expect(objectPath.coalesce(obj, ['1', '\\u7591', 'a.b'])).to.equal(true);\n-    expect(objectPath.coalesce(obj, ['1', ['dot.dot'], '\\u7591'])).to.equal(false);\n-  });\n-});\n+    expect(objectPath.coalesce(obj, ['1', '\\u7591', 'a.b'])).to.equal(true)\n+    expect(objectPath.coalesce(obj, ['1', ['dot.dot'], '\\u7591'])).to.equal(false)\n+  })\n+})\n \n-describe('empty', function(){\n-  it('should ignore invalid arguments safely', function(){\n-    var obj = {};\n-    expect(objectPath.empty()).to.equal(void 0);\n-    expect(objectPath.empty(obj, 'path')).to.equal(void 0);\n-    expect(objectPath.empty(obj, '')).to.equal(void 0);\n+describe('empty', function () {\n+  it('should ignore invalid arguments safely', function () {\n+    var obj = {}\n+    expect(objectPath.empty()).to.equal(void 0)\n+    expect(objectPath.empty(obj, 'path')).to.equal(void 0)\n+    expect(objectPath.empty(obj, '')).to.equal(void 0)\n \n-    obj.path = true;\n+    obj.path = true\n \n-    expect(objectPath.empty(obj, 'inexistant')).to.equal(void 0);\n+    expect(objectPath.empty(obj, 'inexistant')).to.equal(void 0)\n \n-    expect(objectPath.empty(null, 'path')).to.equal(void 0);\n-    expect(objectPath.empty(void 0, 'path')).to.equal(void 0);\n-  });\n+    expect(objectPath.empty(null, 'path')).to.equal(void 0)\n+    expect(objectPath.empty(void 0, 'path')).to.equal(void 0)\n+  })\n \n-  it('should empty each path according to their types', function(){\n-    function Instance(){\n-      this.notOwn = true;\n+  it('should empty each path according to their types', function () {\n+    function Instance () {\n+      this.notOwn = true\n     }\n \n     /*istanbul ignore next: not part of code */\n-    Instance.prototype.test = function(){};\n+    Instance.prototype.test = function () {\n+    }\n     /*istanbul ignore next: not part of code */\n-    Instance.prototype.arr = [];\n+    Instance.prototype.arr = []\n \n     var\n       obj = {\n         string: 'some string',\n-        array: ['some','array',[1,2,3]],\n+        array: ['some', 'array', [1, 2, 3]],\n         number: 21,\n         boolean: true,\n         object: {\n-          some:'property',\n+          some: 'property',\n           sub: {\n             'property': true\n           },\n           nullProp: null,\n           undefinedProp: void 0\n         },\n         instance: new Instance()\n-      };\n+      }\n \n     /*istanbul ignore next: not part of code */\n-    obj['function'] = function(){};\n+    obj['function'] = function () {\n+    }\n \n-    objectPath.empty(obj, ['array','2']);\n-    expect(obj.array[2]).to.deep.equal([]);\n+    objectPath.empty(obj, ['array', '2'])\n+    expect(obj.array[2]).to.deep.equal([])\n \n-    objectPath.empty(obj, 'object.sub');\n-    expect(obj.object.sub).to.deep.equal({});\n+    objectPath.empty(obj, 'object.sub')\n+    expect(obj.object.sub).to.deep.equal({})\n \n-    objectPath.empty(obj, 'object.nullProp');\n-    expect(obj.object.nullProp).to.equal(null);\n+    objectPath.empty(obj, 'object.nullProp')\n+    expect(obj.object.nullProp).to.equal(null)\n \n-    objectPath.empty(obj, 'object.undefinedProp');\n-    expect(obj.object.undefinedProp).to.equal(void 0);\n-    expect(obj.object).to.have.property('undefinedProp');\n+    objectPath.empty(obj, 'object.undefinedProp')\n+    expect(obj.object.undefinedProp).to.equal(void 0)\n+    expect(obj.object).to.have.property('undefinedProp')\n \n-    objectPath.empty(obj, 'object.notAProp');\n-    expect(obj.object.notAProp).to.equal(void 0);\n-    expect(obj.object).to.not.have.property('notAProp');\n+    objectPath.empty(obj, 'object.notAProp')\n+    expect(obj.object.notAProp).to.equal(void 0)\n+    expect(obj.object).to.not.have.property('notAProp')\n \n-    objectPath.empty(obj, 'instance.test');\n+    objectPath.empty(obj, 'instance.test')\n     //instance.test is not own property, so it shouldn't be emptied\n-    expect(obj.instance.test).to.be.a('function');\n-    expect(Instance.prototype.test).to.be.a('function');\n-\n-    objectPath.empty(obj, 'string');\n-    objectPath.empty(obj, 'number');\n-    objectPath.empty(obj, 'boolean');\n-    objectPath.empty(obj, 'function');\n-    objectPath.empty(obj, 'array');\n-    objectPath.empty(obj, 'object');\n-    objectPath.empty(obj, 'instance');\n-\n-    expect(obj.string).to.equal('');\n-    expect(obj.array).to.deep.equal([]);\n-    expect(obj.number).to.equal(0);\n-    expect(obj.boolean).to.equal(false);\n-    expect(obj.object).to.deep.equal({});\n-    expect(obj.instance.notOwn).to.be.an('undefined');\n-    expect(obj.instance.arr).to.be.an('array');\n-    expect(obj['function']).to.equal(null);\n-  });\n-});\n-\n-describe('del', function(){\n-  it('should work with number path', function(){\n-    var obj = getTestObj();\n-    objectPath.del(obj.b.d, 1);\n-    expect(obj.b.d).to.deep.equal(['a']);\n-  });\n-\n-  it('should remove null and undefined props (but not explode on nested)', function(){\n-    var obj = { nullProp: null, undefinedProp: void 0 };\n-    expect(obj).to.have.property('nullProp');\n-    expect(obj).to.have.property('undefinedProp');\n-\n-    objectPath.del(obj, 'nullProp.foo');\n-    objectPath.del(obj, 'undefinedProp.bar');\n-    expect(obj).to.have.property('nullProp');\n-    expect(obj).to.have.property('undefinedProp');\n-    expect(obj).to.deep.equal({ nullProp: null, undefinedProp: void 0 });\n-\n-    objectPath.del(obj, 'nullProp');\n-    objectPath.del(obj, 'undefinedProp');\n-    expect(obj).to.not.have.property('nullProp');\n-    expect(obj).to.not.have.property('undefinedProp');\n-    expect(obj).to.deep.equal({});\n-  });\n-\n-  it('should delete deep paths', function(){\n-    var obj = getTestObj();\n-\n-    expect(objectPath.del(obj)).to.be.equal(obj);\n-\n-    objectPath.set(obj, 'b.g.1.0', 'test');\n-    objectPath.set(obj, 'b.g.1.1', 'test');\n-    objectPath.set(obj, 'b.h.az', 'test');\n-    objectPath.set(obj, 'b.\\ubeef', 'test');\n-    objectPath.set(obj, ['b','dot.dot'], 'test');\n-\n-    expect(obj).to.have.nested.property('b.g.1.0','test');\n-    expect(obj).to.have.nested.property('b.g.1.1','test');\n-    expect(obj).to.have.nested.property('b.h.az','test');\n-    expect(obj).to.have.nested.property('b.\\ubeef','test');\n-\n-    objectPath.del(obj, 'b.h.az');\n-    expect(obj).to.not.have.nested.property('b.h.az');\n-    expect(obj).to.have.nested.property('b.h');\n-\n-    objectPath.del(obj, 'b.g.1.1');\n-    expect(obj).to.not.have.nested.property('b.g.1.1');\n-    expect(obj).to.have.nested.property('b.g.1.0','test');\n-\n-    objectPath.del(obj, 'b.\\ubeef');\n-    expect(obj).to.not.have.nested.property('b.\\ubeef');\n-\n-    objectPath.del(obj, ['b','dot.dot']);\n-    expect(objectPath.get(obj, ['b','dot.dot'])).to.be.equal(void 0);\n-\n-    objectPath.del(obj, ['b','g','1','0']);\n-    expect(obj).to.not.have.nested.property('b.g.1.0');\n-    expect(obj).to.have.nested.property('b.g.1');\n-\n-    expect(objectPath.del(obj, ['b'])).to.not.have.nested.property('b.g');\n-    expect(obj).to.be.deep.equal({'a':'b'});\n-  });\n-\n-  it('should remove items from existing array', function(){\n-    var obj = getTestObj();\n-\n-    objectPath.del(obj, 'b.d.0');\n-    expect(obj.b.d).to.have.length(1);\n-    expect(obj.b.d).to.be.deep.equal(['b']);\n-\n-    objectPath.del(obj, 'b.d.0');\n-    expect(obj.b.d).to.have.length(0);\n-    expect(obj.b.d).to.be.deep.equal([]);\n-  });\n-});\n-\n-describe('insert', function(){\n-  it('should insert value into existing array', function(){\n-    var obj = getTestObj();\n-\n-    objectPath.insert(obj, 'b.c', 'asdf');\n-    expect(obj).to.have.nested.property('b.c.0', 'asdf');\n-    expect(obj).to.not.have.nested.property('b.c.1');\n-  });\n-\n-  it('should create intermediary array', function(){\n-    var obj = getTestObj();\n-\n-    objectPath.insert(obj, 'b.c.0', 'asdf');\n-    expect(obj).to.have.nested.property('b.c.0.0', 'asdf');\n-  });\n-\n-  it('should insert in another index', function(){\n-    var obj = getTestObj();\n-\n-    objectPath.insert(obj, 'b.d', 'asdf', 1);\n-    expect(obj).to.have.nested.property('b.d.1', 'asdf');\n-    expect(obj).to.have.nested.property('b.d.0', 'a');\n-    expect(obj).to.have.nested.property('b.d.2', 'b');\n-  });\n-\n-  it('should handle sparse array', function(){\n-    var obj = getTestObj();\n-    obj.b.d = new Array(4);\n-    obj.b.d[0] = 'a';\n-    obj.b.d[1] = 'b';\n-\n-    objectPath.insert(obj, 'b.d', 'asdf', 3);\n+    expect(obj.instance.test).to.be.a('function')\n+    expect(Instance.prototype.test).to.be.a('function')\n+\n+    objectPath.empty(obj, 'string')\n+    objectPath.empty(obj, 'number')\n+    objectPath.empty(obj, 'boolean')\n+    objectPath.empty(obj, 'function')\n+    objectPath.empty(obj, 'array')\n+    objectPath.empty(obj, 'object')\n+    objectPath.empty(obj, 'instance')\n+\n+    expect(obj.string).to.equal('')\n+    expect(obj.array).to.deep.equal([])\n+    expect(obj.number).to.equal(0)\n+    expect(obj.boolean).to.equal(false)\n+    expect(obj.object).to.deep.equal({})\n+    expect(obj.instance.notOwn).to.be.an('undefined')\n+    expect(obj.instance.arr).to.be.an('array')\n+    expect(obj['function']).to.equal(null)\n+  })\n+})\n+\n+describe('del', function () {\n+  it('should work with number path', function () {\n+    var obj = getTestObj()\n+    objectPath.del(obj.b.d, 1)\n+    expect(obj.b.d).to.deep.equal(['a'])\n+  })\n+\n+  it('should remove null and undefined props (but not explode on nested)', function () {\n+    var obj = {nullProp: null, undefinedProp: void 0}\n+    expect(obj).to.have.property('nullProp')\n+    expect(obj).to.have.property('undefinedProp')\n+\n+    objectPath.del(obj, 'nullProp.foo')\n+    objectPath.del(obj, 'undefinedProp.bar')\n+    expect(obj).to.have.property('nullProp')\n+    expect(obj).to.have.property('undefinedProp')\n+    expect(obj).to.deep.equal({nullProp: null, undefinedProp: void 0})\n+\n+    objectPath.del(obj, 'nullProp')\n+    objectPath.del(obj, 'undefinedProp')\n+    expect(obj).to.not.have.property('nullProp')\n+    expect(obj).to.not.have.property('undefinedProp')\n+    expect(obj).to.deep.equal({})\n+  })\n+\n+  it('should delete deep paths', function () {\n+    var obj = getTestObj()\n+\n+    expect(objectPath.del(obj)).to.be.equal(obj)\n+\n+    objectPath.set(obj, 'b.g.1.0', 'test')\n+    objectPath.set(obj, 'b.g.1.1', 'test')\n+    objectPath.set(obj, 'b.h.az', 'test')\n+    objectPath.set(obj, 'b.\\ubeef', 'test')\n+    objectPath.set(obj, ['b', 'dot.dot'], 'test')\n+\n+    expect(obj).to.have.nested.property('b.g.1.0', 'test')\n+    expect(obj).to.have.nested.property('b.g.1.1', 'test')\n+    expect(obj).to.have.nested.property('b.h.az', 'test')\n+    expect(obj).to.have.nested.property('b.\\ubeef', 'test')\n+\n+    objectPath.del(obj, 'b.h.az')\n+    expect(obj).to.not.have.nested.property('b.h.az')\n+    expect(obj).to.have.nested.property('b.h')\n+\n+    objectPath.del(obj, 'b.g.1.1')\n+    expect(obj).to.not.have.nested.property('b.g.1.1')\n+    expect(obj).to.have.nested.property('b.g.1.0', 'test')\n+\n+    objectPath.del(obj, 'b.\\ubeef')\n+    expect(obj).to.not.have.nested.property('b.\\ubeef')\n+\n+    objectPath.del(obj, ['b', 'dot.dot'])\n+    expect(objectPath.get(obj, ['b', 'dot.dot'])).to.be.equal(void 0)\n+\n+    objectPath.del(obj, ['b', 'g', '1', '0'])\n+    expect(obj).to.not.have.nested.property('b.g.1.0')\n+    expect(obj).to.have.nested.property('b.g.1')\n+\n+    expect(objectPath.del(obj, ['b'])).to.not.have.nested.property('b.g')\n+    expect(obj).to.be.deep.equal({'a': 'b'})\n+  })\n+\n+  it('should remove items from existing array', function () {\n+    var obj = getTestObj()\n+\n+    objectPath.del(obj, 'b.d.0')\n+    expect(obj.b.d).to.have.length(1)\n+    expect(obj.b.d).to.be.deep.equal(['b'])\n+\n+    objectPath.del(obj, 'b.d.0')\n+    expect(obj.b.d).to.have.length(0)\n+    expect(obj.b.d).to.be.deep.equal([])\n+  })\n+})\n+\n+describe('insert', function () {\n+  it('should insert value into existing array', function () {\n+    var obj = getTestObj()\n+\n+    objectPath.insert(obj, 'b.c', 'asdf')\n+    expect(obj).to.have.nested.property('b.c.0', 'asdf')\n+    expect(obj).to.not.have.nested.property('b.c.1')\n+  })\n+\n+  it('should create intermediary array', function () {\n+    var obj = getTestObj()\n+\n+    objectPath.insert(obj, 'b.c.0', 'asdf')\n+    expect(obj).to.have.nested.property('b.c.0.0', 'asdf')\n+  })\n+\n+  it('should insert in another index', function () {\n+    var obj = getTestObj()\n+\n+    objectPath.insert(obj, 'b.d', 'asdf', 1)\n+    expect(obj).to.have.nested.property('b.d.1', 'asdf')\n+    expect(obj).to.have.nested.property('b.d.0', 'a')\n+    expect(obj).to.have.nested.property('b.d.2', 'b')\n+  })\n+\n+  it('should handle sparse array', function () {\n+    var obj = getTestObj()\n+    obj.b.d = new Array(4)\n+    obj.b.d[0] = 'a'\n+    obj.b.d[1] = 'b'\n+\n+    objectPath.insert(obj, 'b.d', 'asdf', 3)\n     expect(obj.b.d).to.have.members([\n       'a',\n       'b',\n       ,\n       ,\n       'asdf'\n-    ]);\n-  });\n-});\n+    ])\n+  })\n+})\n \n describe('has', function () {\n   it('should return false for empty object', function () {\n-    expect(objectPath.has({}, 'a')).to.be.equal(false);\n-  });\n+    expect(objectPath.has({}, 'a')).to.be.equal(false)\n+  })\n \n   it('should handle empty paths properly', function () {\n-    var obj = getTestObj();\n-    expect(objectPath.has(obj, '')).to.be.equal(false);\n-    expect(objectPath.has(obj, [''])).to.be.equal(false);\n+    var obj = getTestObj()\n+    expect(objectPath.has(obj, '')).to.be.equal(false)\n+    expect(objectPath.has(obj, [''])).to.be.equal(false)\n     obj[''] = 1\n-    expect(objectPath.has(obj, '')).to.be.equal(true);\n-    expect(objectPath.has(obj, [''])).to.be.equal(true);\n-\n-    expect(objectPath.has(obj, [])).to.be.equal(true);\n-    expect(objectPath.has(null, [])).to.be.equal(false);\n-  });\n-\n-  it('should test under shallow object', function() {\n-    var obj = getTestObj();\n-    expect(objectPath.has(obj, 'a')).to.be.equal(true);\n-    expect(objectPath.has(obj, ['a'])).to.be.equal(true);\n-    expect(objectPath.has(obj, 'z')).to.be.equal(false);\n-    expect(objectPath.has(obj, ['z'])).to.be.equal(false);\n-  });\n-\n-  it('should work with number path', function() {\n-    var obj = getTestObj();\n-    expect(objectPath.has(obj.b.d, 0)).to.be.equal(true);\n-    expect(objectPath.has(obj.b, 0)).to.be.equal(false);\n-    expect(objectPath.has(obj.b.d, 10)).to.be.equal(false);\n-    expect(objectPath.has(obj.b, 10)).to.be.equal(false);\n-  });\n-\n-  it('should test under deep object', function() {\n-    var obj = getTestObj();\n-    expect(objectPath.has(obj, 'b.f')).to.be.equal(true);\n-    expect(objectPath.has(obj, ['b','f'])).to.be.equal(true);\n-    expect(objectPath.has(obj, 'b.g')).to.be.equal(false);\n-    expect(objectPath.has(obj, ['b','g'])).to.be.equal(false);\n-  });\n-\n-  it('should test value under array', function() {\n+    expect(objectPath.has(obj, '')).to.be.equal(true)\n+    expect(objectPath.has(obj, [''])).to.be.equal(true)\n+\n+    expect(objectPath.has(obj, [])).to.be.equal(true)\n+    expect(objectPath.has(null, [])).to.be.equal(false)\n+  })\n+\n+  it('should test under shallow object', function () {\n+    var obj = getTestObj()\n+    expect(objectPath.has(obj, 'a')).to.be.equal(true)\n+    expect(objectPath.has(obj, ['a'])).to.be.equal(true)\n+    expect(objectPath.has(obj, 'z')).to.be.equal(false)\n+    expect(objectPath.has(obj, ['z'])).to.be.equal(false)\n+  })\n+\n+  it('should work with number path', function () {\n+    var obj = getTestObj()\n+    expect(objectPath.has(obj.b.d, 0)).to.be.equal(true)\n+    expect(objectPath.has(obj.b, 0)).to.be.equal(false)\n+    expect(objectPath.has(obj.b.d, 10)).to.be.equal(false)\n+    expect(objectPath.has(obj.b, 10)).to.be.equal(false)\n+  })\n+\n+  it('should test under deep object', function () {\n+    var obj = getTestObj()\n+    expect(objectPath.has(obj, 'b.f')).to.be.equal(true)\n+    expect(objectPath.has(obj, ['b', 'f'])).to.be.equal(true)\n+    expect(objectPath.has(obj, 'b.g')).to.be.equal(false)\n+    expect(objectPath.has(obj, ['b', 'g'])).to.be.equal(false)\n+  })\n+\n+  it('should test value under array', function () {\n     var obj = {\n       b: ['a']\n-    };\n+    }\n     obj.b[3] = {o: 'a'}\n-    expect(objectPath.has(obj, 'b.0')).to.be.equal(true);\n-    expect(objectPath.has(obj, 'b.1')).to.be.equal(true);\n-    expect(objectPath.has(obj, 'b.3.o')).to.be.equal(true);\n-    expect(objectPath.has(obj, 'b.3.qwe')).to.be.equal(false);\n-    expect(objectPath.has(obj, 'b.4')).to.be.equal(false);\n-  });\n-\n-  it('should test the value under array deep', function() {\n-    var obj = getTestObj();\n-    expect(objectPath.has(obj, 'b.e.1.f')).to.be.equal(true);\n-    expect(objectPath.has(obj, ['b','e',1,'f'])).to.be.equal(true);\n-    expect(objectPath.has(obj, 'b.e.1.f.g.h.i')).to.be.equal(false);\n-    expect(objectPath.has(obj, ['b','e',1,'f','g','h','i'])).to.be.equal(false);\n-  });\n-\n-  it('should test the value under integer-like key', function() {\n-    var obj = { '1a': 'foo' };\n-    expect(objectPath.has(obj, '1a')).to.be.equal(true);\n-    expect(objectPath.has(obj, ['1a'])).to.be.equal(true);\n-  });\n-\n-  it('should distinct nonexistent key and key = undefined', function() {\n-    var obj = {};\n-    expect(objectPath.has(obj, 'key')).to.be.equal(false);\n-\n-    obj.key = undefined;\n-    expect(objectPath.has(obj, 'key')).to.be.equal(true);\n-  });\n-\n-  it('should work with deep undefined/null values', function() {\n-    var obj = {};\n-    expect(objectPath.has(obj, 'missing.test')).to.be.equal(false);\n-\n-    obj.missing = null;\n-    expect(objectPath.has(obj, 'missing.test')).to.be.equal(false);\n+    expect(objectPath.has(obj, 'b.0')).to.be.equal(true)\n+    expect(objectPath.has(obj, 'b.1')).to.be.equal(true)\n+    expect(objectPath.has(obj, 'b.3.o')).to.be.equal(true)\n+    expect(objectPath.has(obj, 'b.3.qwe')).to.be.equal(false)\n+    expect(objectPath.has(obj, 'b.4')).to.be.equal(false)\n+  })\n+\n+  it('should test the value under array deep', function () {\n+    var obj = getTestObj()\n+    expect(objectPath.has(obj, 'b.e.1.f')).to.be.equal(true)\n+    expect(objectPath.has(obj, ['b', 'e', 1, 'f'])).to.be.equal(true)\n+    expect(objectPath.has(obj, 'b.e.1.f.g.h.i')).to.be.equal(false)\n+    expect(objectPath.has(obj, ['b', 'e', 1, 'f', 'g', 'h', 'i'])).to.be.equal(false)\n+  })\n+\n+  it('should test the value under integer-like key', function () {\n+    var obj = {'1a': 'foo'}\n+    expect(objectPath.has(obj, '1a')).to.be.equal(true)\n+    expect(objectPath.has(obj, ['1a'])).to.be.equal(true)\n+  })\n+\n+  it('should distinct nonexistent key and key = undefined', function () {\n+    var obj = {}\n+    expect(objectPath.has(obj, 'key')).to.be.equal(false)\n+\n+    obj.key = undefined\n+    expect(objectPath.has(obj, 'key')).to.be.equal(true)\n+  })\n+\n+  it('should work with deep undefined/null values', function () {\n+    var obj = {}\n+    expect(objectPath.has(obj, 'missing.test')).to.be.equal(false)\n+\n+    obj.missing = null\n+    expect(objectPath.has(obj, 'missing.test')).to.be.equal(false)\n \n     obj.sparseArray = [1, undefined, 3]\n-    expect(objectPath.has(obj, 'sparseArray.1.test')).to.be.equal(false);\n-  });\n-});\n-\n+    expect(objectPath.has(obj, 'sparseArray.1.test')).to.be.equal(false)\n+  })\n+})\n \n \n describe('bind object', function () {\n   // just get one scenario from each feature, so whole functionality is proxied well\n-  it('should return the value under shallow object', function() {\n-    var obj = getTestObj();\n-    var model = objectPath(obj);\n-    expect(model.get('a')).to.be.equal('b');\n-    expect(model.get(['a'])).to.be.equal('b');\n-  });\n-\n-  it('should set value under shallow object', function() {\n-    var obj = getTestObj();\n-    var model = objectPath(obj);\n-    model.set('c', {m: 'o'});\n-    expect(obj).to.have.nested.property('c.m', 'o');\n-    obj = getTestObj();\n-    model = objectPath(obj);\n-    model.set(['c'], {m: 'o'});\n-    expect(obj).to.have.nested.property('c.m', 'o');\n-  });\n-\n-  it('should push value to existing array', function() {\n-    var obj = getTestObj();\n-    var model = objectPath(obj);\n-    model.push('b.c', 'l');\n-    expect(obj).to.have.nested.property('b.c.0', 'l');\n-    obj = getTestObj();\n-    model = objectPath(obj);\n-    model.push(['b','c'], 'l');\n-    expect(obj).to.have.nested.property('b.c.0', 'l');\n-  });\n-\n-  it('should create the path if it does not exists', function() {\n-    var obj = getTestObj();\n-    var model = objectPath(obj);\n-    var oldVal = model.ensureExists('b.g.1.l', 'test');\n-    expect(oldVal).to.not.exist;\n-    expect(obj).to.have.nested.property('b.g.1.l', 'test');\n-    oldVal = model.ensureExists('b.g.1.l', 'test1');\n-    expect(oldVal).to.be.equal('test');\n-    expect(obj).to.have.nested.property('b.g.1.l', 'test');\n-  });\n-\n-  it('should return the first non-undefined value', function(){\n+  it('should return the value under shallow object', function () {\n+    var obj = getTestObj()\n+    var model = objectPath(obj)\n+    expect(model.get('a')).to.be.equal('b')\n+    expect(model.get(['a'])).to.be.equal('b')\n+  })\n+\n+  it('should set value under shallow object', function () {\n+    var obj = getTestObj()\n+    var model = objectPath(obj)\n+    model.set('c', {m: 'o'})\n+    expect(obj).to.have.nested.property('c.m', 'o')\n+    obj = getTestObj()\n+    model = objectPath(obj)\n+    model.set(['c'], {m: 'o'})\n+    expect(obj).to.have.nested.property('c.m', 'o')\n+  })\n+\n+  it('should push value to existing array', function () {\n+    var obj = getTestObj()\n+    var model = objectPath(obj)\n+    model.push('b.c', 'l')\n+    expect(obj).to.have.nested.property('b.c.0', 'l')\n+    obj = getTestObj()\n+    model = objectPath(obj)\n+    model.push(['b', 'c'], 'l')\n+    expect(obj).to.have.nested.property('b.c.0', 'l')\n+  })\n+\n+  it('should create the path if it does not exists', function () {\n+    var obj = getTestObj()\n+    var model = objectPath(obj)\n+    var oldVal = model.ensureExists('b.g.1.l', 'test')\n+    expect(oldVal).to.not.exist\n+    expect(obj).to.have.nested.property('b.g.1.l', 'test')\n+    oldVal = model.ensureExists('b.g.1.l', 'test1')\n+    expect(oldVal).to.be.equal('test')\n+    expect(obj).to.have.nested.property('b.g.1.l', 'test')\n+  })\n+\n+  it('should return the first non-undefined value', function () {\n     var obj = {\n       should: {have: 'prop'}\n-    };\n-    var model = objectPath(obj);\n+    }\n+    var model = objectPath(obj)\n \n     expect(model.coalesce([\n       'doesnt.exist',\n-      ['might','not','exist'],\n+      ['might', 'not', 'exist'],\n       'should.have'\n-    ])).to.equal('prop');\n-  });\n+    ])).to.equal('prop')\n+  })\n \n-  it('should empty each path according to their types', function(){\n-    function Instance(){\n-      this.notOwn = true;\n+  it('should empty each path according to their types', function () {\n+    function Instance () {\n+      this.notOwn = true\n     }\n \n     /*istanbul ignore next: not part of code */\n-    Instance.prototype.test = function(){};\n+    Instance.prototype.test = function () {\n+    }\n     /*istanbul ignore next: not part of code */\n-    Instance.prototype.arr = [];\n+    Instance.prototype.arr = []\n \n     var\n       obj = {\n         string: 'some string',\n-        array: ['some','array',[1,2,3]],\n+        array: ['some', 'array', [1, 2, 3]],\n         number: 21,\n         boolean: true,\n         object: {\n-          some:'property',\n+          some: 'property',\n           sub: {\n             'property': true\n           }\n         },\n         instance: new Instance()\n-      };\n+      }\n \n     /*istanbul ignore next: not part of code */\n-    obj['function'] = function(){};\n+    obj['function'] = function () {\n+    }\n \n-    var model = objectPath(obj);\n+    var model = objectPath(obj)\n \n-    model.empty(['array','2']);\n-    expect(obj.array[2]).to.deep.equal([]);\n+    model.empty(['array', '2'])\n+    expect(obj.array[2]).to.deep.equal([])\n \n-    model.empty('object.sub');\n-    expect(obj.object.sub).to.deep.equal({});\n+    model.empty('object.sub')\n+    expect(obj.object.sub).to.deep.equal({})\n \n-    model.empty('instance.test');\n+    model.empty('instance.test')\n     //instance.test is not own property so it shouldn't be emptied\n-    expect(obj.instance.test).to.be.a('function');\n-    expect(Instance.prototype.test).to.be.a('function');\n-\n-    model.empty('string');\n-    model.empty('number');\n-    model.empty('boolean');\n-    model.empty('function');\n-    model.empty('array');\n-    model.empty('object');\n-    model.empty('instance');\n-\n-    expect(obj.string).to.equal('');\n-    expect(obj.array).to.deep.equal([]);\n-    expect(obj.number).to.equal(0);\n-    expect(obj.boolean).to.equal(false);\n-    expect(obj.object).to.deep.equal({});\n-    expect(obj.instance.notOwn).to.be.an('undefined');\n-    expect(obj.instance.arr).to.be.an('array');\n-    expect(obj['function']).to.equal(null);\n-  });\n-\n-  it('should delete deep paths', function(){\n-    var obj = getTestObj();\n-    var model = objectPath(obj);\n-\n-    expect(model.del()).to.be.equal(obj);\n-\n-    model.set('b.g.1.0', 'test');\n-    model.set('b.g.1.1', 'test');\n-    model.set('b.h.az', 'test');\n-\n-    expect(obj).to.have.nested.property('b.g.1.0','test');\n-    expect(obj).to.have.nested.property('b.g.1.1','test');\n-    expect(obj).to.have.nested.property('b.h.az','test');\n-\n-    model.del('b.h.az');\n-    expect(obj).to.not.have.nested.property('b.h.az');\n-    expect(obj).to.have.nested.property('b.h');\n-\n-    model.del('b.g.1.1');\n-    expect(obj).to.not.have.nested.property('b.g.1.1');\n-    expect(obj).to.have.nested.property('b.g.1.0','test');\n-\n-    model.del(['b','g','1','0']);\n-    expect(obj).to.not.have.nested.property('b.g.1.0');\n-    expect(obj).to.have.nested.property('b.g.1');\n-\n-    expect(model.del(['b'])).to.not.have.nested.property('b.g');\n-    expect(obj).to.be.deep.equal({'a':'b'});\n-  });\n-\n-  it('should insert value into existing array', function(){\n-    var obj = getTestObj();\n-    var model = objectPath(obj);\n-\n-    model.insert('b.c', 'asdf');\n-    expect(obj).to.have.nested.property('b.c.0', 'asdf');\n-    expect(obj).to.not.have.nested.property('b.c.1');\n-  });\n-\n-  it('should test under shallow object', function() {\n-    var obj = getTestObj();\n-    var model = objectPath(obj);\n-\n-    expect(model.has('a')).to.be.equal(true);\n-    expect(model.has(['a'])).to.be.equal(true);\n-    expect(model.has('z')).to.be.equal(false);\n-    expect(model.has(['z'])).to.be.equal(false);\n-  });\n-});\n+    expect(obj.instance.test).to.be.a('function')\n+    expect(Instance.prototype.test).to.be.a('function')\n+\n+    model.empty('string')\n+    model.empty('number')\n+    model.empty('boolean')\n+    model.empty('function')\n+    model.empty('array')\n+    model.empty('object')\n+    model.empty('instance')\n+\n+    expect(obj.string).to.equal('')\n+    expect(obj.array).to.deep.equal([])\n+    expect(obj.number).to.equal(0)\n+    expect(obj.boolean).to.equal(false)\n+    expect(obj.object).to.deep.equal({})\n+    expect(obj.instance.notOwn).to.be.an('undefined')\n+    expect(obj.instance.arr).to.be.an('array')\n+    expect(obj['function']).to.equal(null)\n+  })\n+\n+  it('should delete deep paths', function () {\n+    var obj = getTestObj()\n+    var model = objectPath(obj)\n+\n+    expect(model.del()).to.be.equal(obj)\n+\n+    model.set('b.g.1.0', 'test')\n+    model.set('b.g.1.1', 'test')\n+    model.set('b.h.az', 'test')\n+\n+    expect(obj).to.have.nested.property('b.g.1.0', 'test')\n+    expect(obj).to.have.nested.property('b.g.1.1', 'test')\n+    expect(obj).to.have.nested.property('b.h.az', 'test')\n+\n+    model.del('b.h.az')\n+    expect(obj).to.not.have.nested.property('b.h.az')\n+    expect(obj).to.have.nested.property('b.h')\n+\n+    model.del('b.g.1.1')\n+    expect(obj).to.not.have.nested.property('b.g.1.1')\n+    expect(obj).to.have.nested.property('b.g.1.0', 'test')\n+\n+    model.del(['b', 'g', '1', '0'])\n+    expect(obj).to.not.have.nested.property('b.g.1.0')\n+    expect(obj).to.have.nested.property('b.g.1')\n+\n+    expect(model.del(['b'])).to.not.have.nested.property('b.g')\n+    expect(obj).to.be.deep.equal({'a': 'b'})\n+  })\n+\n+  it('should insert value into existing array', function () {\n+    var obj = getTestObj()\n+    var model = objectPath(obj)\n+\n+    model.insert('b.c', 'asdf')\n+    expect(obj).to.have.nested.property('b.c.0', 'asdf')\n+    expect(obj).to.not.have.nested.property('b.c.1')\n+  })\n+\n+  it('should test under shallow object', function () {\n+    var obj = getTestObj()\n+    var model = objectPath(obj)\n+\n+    expect(model.has('a')).to.be.equal(true)\n+    expect(model.has(['a'])).to.be.equal(true)\n+    expect(model.has('z')).to.be.equal(false)\n+    expect(model.has(['z'])).to.be.equal(false)\n+  })\n+})\n \n describe('Don\\'t access not own properties [default]', function () {\n-  it('should not get a not own property', function() {\n-    var Obj = function() {};\n-    Obj.prototype.notOwn = {a: 'a'};\n-    var obj = new Obj();\n+  it('should not get a not own property', function () {\n+    var Obj = function () {\n+    }\n+    Obj.prototype.notOwn = {a: 'a'}\n+    var obj = new Obj()\n \n     expect(objectPath.get(obj, 'notOwn')).to.be.undefined\n-  });\n+  })\n \n-  it('should set a not own property on the instance (not the prototype)', function() {\n+  it('should set a not own property on the instance (not the prototype)', function () {\n     var proto = {\n       notOwn: {}\n     }\n     var obj = Object.create(proto)\n \n-    objectPath.set(obj, 'notOwn.test', 'a');\n-    expect(obj.notOwn.test).to.be.equal('a');\n-    expect(proto.notOwn).to.be.deep.equal({});\n-  });\n+    objectPath.set(obj, 'notOwn.test', 'a')\n+    expect(obj.notOwn.test).to.be.equal('a')\n+    expect(proto.notOwn).to.be.deep.equal({})\n+  })\n \n-  it('has should return false on a not own property', function() {\n+  it('has should return false on a not own property', function () {\n     var proto = {\n       notOwn: {a: 'a'}\n     }\n     var obj = Object.create(proto)\n \n \n-    expect(objectPath.has(obj, 'notOwn')).to.be.false;\n-    expect(objectPath.has(obj, 'notOwn.a')).to.be.false;\n-  });\n+    expect(objectPath.has(obj, 'notOwn')).to.be.false\n+    expect(objectPath.has(obj, 'notOwn.a')).to.be.false\n+  })\n \n-  it('empty should not empty on a not own property', function() {\n+  it('empty should not empty on a not own property', function () {\n     var proto = {\n       notOwn: {a: 'a'}\n     }\n-    var obj = Object.create(proto);\n+    var obj = Object.create(proto)\n \n-    objectPath.empty(obj, 'notOwn');\n-    expect(proto.notOwn).to.be.deep.equal({a: 'a'});\n-    expect(obj.notOwn).to.be.deep.equal({a: 'a'});\n-  });\n+    objectPath.empty(obj, 'notOwn')\n+    expect(proto.notOwn).to.be.deep.equal({a: 'a'})\n+    expect(obj.notOwn).to.be.deep.equal({a: 'a'})\n+  })\n \n-  it('del should not delete not own property', function() {\n+  it('del should not delete not own property', function () {\n     var proto = {\n       notOwn: {a: 'a'}\n     }\n-    var obj = Object.create(proto);\n+    var obj = Object.create(proto)\n \n-    objectPath.del(obj, 'notOwn.a');\n-    expect(proto.notOwn).to.be.deep.equal({a: 'a'});\n+    objectPath.del(obj, 'notOwn.a')\n+    expect(proto.notOwn).to.be.deep.equal({a: 'a'})\n     //expect(obj.notOwn).to.be.deep.equal({a: 'a'});\n     //objectPath.del(obj, 'notOwn');\n     //expect(proto).to.be.deep.equal({notOwn: {a: 'a'}});\n     //expect(obj).to.be.deep.equal({notOwn: {a: 'a'}});\n-  });\n-});\n+  })\n+})\n \n describe('Access own properties [optional]', function () {\n-  it('should get a not own property', function() {\n-    var Obj = function() {};\n-    Obj.prototype.notOwn = {a: 'a'};\n-    var obj = new Obj();\n+  it('should get a not own property', function () {\n+    var Obj = function () {\n+    }\n+    Obj.prototype.notOwn = {a: 'a'}\n+    var obj = new Obj()\n \n     expect(objectPath.withInheritedProps.get(obj, 'notOwn.a')).to.be.equal('a')\n-  });\n+  })\n \n-  it('should set a deep not own property on the prototype (if exists)', function() {\n+  it('should set a deep not own property on the prototype (if exists)', function () {\n     var proto = {\n       notOwn: {}\n     }\n     var obj = Object.create(proto)\n \n-    objectPath.withInheritedProps.set(obj, 'notOwn.test', 'a');\n-    expect(obj.notOwn.test).to.be.equal('a');\n-    expect(proto.notOwn).to.be.deep.equal({test: 'a'});\n-  });\n+    objectPath.withInheritedProps.set(obj, 'notOwn.test', 'a')\n+    expect(obj.notOwn.test).to.be.equal('a')\n+    expect(proto.notOwn).to.be.deep.equal({test: 'a'})\n+  })\n \n \n-  it('has should return true on a not own property', function() {\n+  it('has should return true on a not own property', function () {\n     var proto = {\n       notOwn: {a: 'a'}\n     }\n     var obj = Object.create(proto)\n \n-    expect(objectPath.withInheritedProps.has(obj, 'notOwn')).to.be.true;\n-    expect(objectPath.withInheritedProps.has(obj, 'notOwn.a')).to.be.true;\n-  });\n+    expect(objectPath.withInheritedProps.has(obj, 'notOwn')).to.be.true\n+    expect(objectPath.withInheritedProps.has(obj, 'notOwn.a')).to.be.true\n+  })\n \n-  it('empty should empty a not own property', function() {\n+  it('empty should empty a not own property', function () {\n     var proto = {\n       notOwn: {a: 'a'}\n     }\n-    var obj = Object.create(proto);\n+    var obj = Object.create(proto)\n \n-    objectPath.withInheritedProps.empty(obj, 'notOwn');\n-    expect(proto.notOwn).to.be.deep.equal({});\n-    expect(obj.notOwn).to.be.deep.equal({});\n-  });\n+    objectPath.withInheritedProps.empty(obj, 'notOwn')\n+    expect(proto.notOwn).to.be.deep.equal({})\n+    expect(obj.notOwn).to.be.deep.equal({})\n+  })\n \n-  it('del should delete a not own property', function() {\n+  it('del should delete a not own property', function () {\n     var proto = {\n       notOwn: {a: 'a'}\n     }\n-    var obj = Object.create(proto);\n+    var obj = Object.create(proto)\n \n-    objectPath.withInheritedProps.del(obj, 'notOwn.a');\n-    expect(proto.notOwn).to.be.deep.equal({});\n+    objectPath.withInheritedProps.del(obj, 'notOwn.a')\n+    expect(proto.notOwn).to.be.deep.equal({})\n     //expect(obj.notOwn).to.be.deep.equal({});\n-    objectPath.withInheritedProps.del(obj, 'notOwn');\n+    objectPath.withInheritedProps.del(obj, 'notOwn')\n     //expect(proto).to.be.deep.equal({notOwn: {}});\n     //expect(obj).to.be.deep.equal({notOwn: {}});\n-  });\n-});\n+  })\n+})"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e6bb638ffdd431176701b3e9024f80050d0ef0a6",
            "date": "2021-09-16T11:00:33Z",
            "author_login": "mariocasciaro"
          },
          {
            "sha": "4f0903fd7c832d12ccbe0d9c3d7e25d985e9e884",
            "date": "2021-09-16T11:00:15Z",
            "author_login": "mariocasciaro"
          },
          {
            "sha": "43a926f5bcba44e522456b0e2b4b341de32c4a19",
            "date": "2021-08-27T14:48:36Z",
            "author_login": "mariocasciaro"
          },
          {
            "sha": "3864273ee91712b0ea49e1f6553fd954195f8664",
            "date": "2021-08-27T14:48:27Z",
            "author_login": "mariocasciaro"
          },
          {
            "sha": "94f92d8932fce12eeff853116646160477c6ce11",
            "date": "2021-08-27T14:39:11Z",
            "author_login": "mariocasciaro"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.7,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:H/A:H",
    "cwe_id": "CWE-20",
    "description": "A prototype pollution vulnerability has been found in `object-path` <= 0.11.4 affecting the `set()` method. The vulnerability is limited to the `includeInheritedProps` mode (if version >= 0.11.0 is used), which has to be explicitly enabled by creating a new instance of `object-path` and setting the option `includeInheritedProps: true`, or by using the default `withInheritedProps` instance. The default operating mode is not affected by the vulnerability if version >= 0.11.0 is used. Any usage of `set()` in versions < 0.11.0 is vulnerable. The issue is fixed in object-path version 0.11.5 As a workaround, don't use the `includeInheritedProps: true` options or the `withInheritedProps` instance if using a version >= 0.11.0.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-10-19T22:15:13.017",
    "last_modified": "2024-11-21T05:05:12.483",
    "fix_date": "2020-10-10T16:25:50Z"
  },
  "references": [
    {
      "url": "https://github.com/mariocasciaro/object-path/commit/2be3354c6c46215c7635eb1b76d80f1319403c68",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/mariocasciaro/object-path/security/advisories/GHSA-cwx2-736x-mf6w",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/mariocasciaro/object-path/commit/2be3354c6c46215c7635eb1b76d80f1319403c68",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/mariocasciaro/object-path/security/advisories/GHSA-cwx2-736x-mf6w",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:06.185120",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "object-path",
    "owner": "mariocasciaro",
    "created_at": "2013-09-20T01:00:11Z",
    "updated_at": "2024-12-29T00:32:12Z",
    "pushed_at": "2023-01-06T15:12:32Z",
    "size": 432,
    "stars": 1062,
    "forks": 84,
    "open_issues": 34,
    "watchers": 1062,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "JavaScript": 50591
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T16:47:27.726829"
  }
}