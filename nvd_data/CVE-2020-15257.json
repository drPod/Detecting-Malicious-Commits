{
  "cve_id": "CVE-2020-15257",
  "github_data": {
    "repository": "containerd/containerd",
    "fix_commit": "4a4bb851f5da563ff6e68a83dc837c7699c469ad",
    "related_commits": [
      "4a4bb851f5da563ff6e68a83dc837c7699c469ad",
      "4a4bb851f5da563ff6e68a83dc837c7699c469ad"
    ],
    "patch_url": "https://github.com/containerd/containerd/commit/4a4bb851f5da563ff6e68a83dc837c7699c469ad.patch",
    "fix_commit_details": {
      "sha": "4a4bb851f5da563ff6e68a83dc837c7699c469ad",
      "commit_date": "2020-11-30T18:32:18Z",
      "author": {
        "login": "dmcgowan",
        "type": "User",
        "stats": {
          "total_commits": 1775,
          "average_weekly_commits": 3.69022869022869,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 348
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-36xw-fx78-c5r4",
        "length": 81,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 315,
        "additions": 260,
        "deletions": 55
      },
      "files": [
        {
          "filename": "cmd/containerd-shim/main_unix.go",
          "status": "modified",
          "additions": 12,
          "deletions": 4,
          "patch": "@@ -71,7 +71,7 @@ var (\n func init() {\n \tflag.BoolVar(&debugFlag, \"debug\", false, \"enable debug output in logs\")\n \tflag.StringVar(&namespaceFlag, \"namespace\", \"\", \"namespace that owns the shim\")\n-\tflag.StringVar(&socketFlag, \"socket\", \"\", \"abstract socket path to serve\")\n+\tflag.StringVar(&socketFlag, \"socket\", \"\", \"socket path to serve\")\n \tflag.StringVar(&addressFlag, \"address\", \"\", \"grpc address back to main containerd\")\n \tflag.StringVar(&workdirFlag, \"workdir\", \"\", \"path used to storge large temporary data\")\n \tflag.StringVar(&runtimeRootFlag, \"runtime-root\", process.RuncRoot, \"root directory for the runtime\")\n@@ -202,10 +202,18 @@ func serve(ctx context.Context, server *ttrpc.Server, path string) error {\n \t\tf.Close()\n \t\tpath = \"[inherited from parent]\"\n \t} else {\n-\t\tif len(path) > 106 {\n-\t\t\treturn errors.Errorf(\"%q: unix socket path too long (> 106)\", path)\n+\t\tconst (\n+\t\t\tabstractSocketPrefix = \"\\x00\"\n+\t\t\tsocketPathLimit      = 106\n+\t\t)\n+\t\tp := strings.TrimPrefix(path, \"unix://\")\n+\t\tif len(p) == len(path) {\n+\t\t\tp = abstractSocketPrefix + p\n \t\t}\n-\t\tl, err = net.Listen(\"unix\", \"\\x00\"+path)\n+\t\tif len(p) > socketPathLimit {\n+\t\t\treturn errors.Errorf(\"%q: unix socket path too long (> %d)\", p, socketPathLimit)\n+\t\t}\n+\t\tl, err = net.Listen(\"unix\", p)\n \t}\n \tif err != nil {\n \t\treturn err"
        },
        {
          "filename": "cmd/ctr/commands/shim/shim.go",
          "status": "modified",
          "additions": 5,
          "deletions": 3,
          "patch": "@@ -24,6 +24,7 @@ import (\n \t\"io/ioutil\"\n \t\"net\"\n \t\"path/filepath\"\n+\t\"strings\"\n \n \t\"github.com/containerd/console\"\n \t\"github.com/containerd/containerd/cmd/ctr/commands\"\n@@ -240,10 +241,11 @@ func getTaskService(context *cli.Context) (task.TaskService, error) {\n \ts1 := filepath.Join(string(filepath.Separator), \"containerd-shim\", ns, id, \"shim.sock\")\n \t// this should not error, ctr always get a default ns\n \tctx := namespaces.WithNamespace(gocontext.Background(), ns)\n-\ts2, _ := shim.SocketAddress(ctx, id)\n+\ts2, _ := shim.SocketAddress(ctx, context.GlobalString(\"address\"), id)\n+\ts2 = strings.TrimPrefix(s2, \"unix://\")\n \n-\tfor _, socket := range []string{s1, s2} {\n-\t\tconn, err := net.Dial(\"unix\", \"\\x00\"+socket)\n+\tfor _, socket := range []string{s2, \"\\x00\" + s1} {\n+\t\tconn, err := net.Dial(\"unix\", socket)\n \t\tif err == nil {\n \t\t\tclient := ttrpc.NewClient(conn)\n "
        },
        {
          "filename": "runtime/v1/linux/bundle.go",
          "status": "modified",
          "additions": 11,
          "deletions": 4,
          "patch": "@@ -91,7 +91,7 @@ func ShimRemote(c *Config, daemonAddress, cgroup string, exitHandler func()) Shi\n \treturn func(b *bundle, ns string, ropts *runctypes.RuncOptions) (shim.Config, client.Opt) {\n \t\tconfig := b.shimConfig(ns, c, ropts)\n \t\treturn config,\n-\t\t\tclient.WithStart(c.Shim, b.shimAddress(ns), daemonAddress, cgroup, c.ShimDebug, exitHandler)\n+\t\t\tclient.WithStart(c.Shim, b.shimAddress(ns, daemonAddress), daemonAddress, cgroup, c.ShimDebug, exitHandler)\n \t}\n }\n \n@@ -117,6 +117,11 @@ func (b *bundle) NewShimClient(ctx context.Context, namespace string, getClientO\n \n // Delete deletes the bundle from disk\n func (b *bundle) Delete() error {\n+\taddress, _ := b.loadAddress()\n+\tif address != \"\" {\n+\t\t// we don't care about errors here\n+\t\tclient.RemoveSocket(address)\n+\t}\n \terr := atomicDelete(b.path)\n \tif err == nil {\n \t\treturn atomicDelete(b.workDir)\n@@ -133,9 +138,11 @@ func (b *bundle) legacyShimAddress(namespace string) string {\n \treturn filepath.Join(string(filepath.Separator), \"containerd-shim\", namespace, b.id, \"shim.sock\")\n }\n \n-func (b *bundle) shimAddress(namespace string) string {\n-\td := sha256.Sum256([]byte(filepath.Join(namespace, b.id)))\n-\treturn filepath.Join(string(filepath.Separator), \"containerd-shim\", fmt.Sprintf(\"%x.sock\", d))\n+const socketRoot = \"/run/containerd\"\n+\n+func (b *bundle) shimAddress(namespace, socketPath string) string {\n+\td := sha256.Sum256([]byte(filepath.Join(socketPath, namespace, b.id)))\n+\treturn fmt.Sprintf(\"unix://%s/%x\", filepath.Join(socketRoot, \"s\"), d)\n }\n \n func (b *bundle) loadAddress() (string, error) {"
        },
        {
          "filename": "runtime/v1/shim/client/client.go",
          "status": "modified",
          "additions": 82,
          "deletions": 10,
          "patch": "@@ -59,9 +59,17 @@ func WithStart(binary, address, daemonAddress, cgroup string, debug bool, exitHa\n \treturn func(ctx context.Context, config shim.Config) (_ shimapi.ShimService, _ io.Closer, err error) {\n \t\tsocket, err := newSocket(address)\n \t\tif err != nil {\n-\t\t\treturn nil, nil, err\n+\t\t\tif !eaddrinuse(err) {\n+\t\t\t\treturn nil, nil, err\n+\t\t\t}\n+\t\t\tif err := RemoveSocket(address); err != nil {\n+\t\t\t\treturn nil, nil, errors.Wrap(err, \"remove already used socket\")\n+\t\t\t}\n+\t\t\tif socket, err = newSocket(address); err != nil {\n+\t\t\t\treturn nil, nil, err\n+\t\t\t}\n \t\t}\n-\t\tdefer socket.Close()\n+\n \t\tf, err := socket.File()\n \t\tif err != nil {\n \t\t\treturn nil, nil, errors.Wrapf(err, \"failed to get fd for socket %s\", address)\n@@ -108,6 +116,8 @@ func WithStart(binary, address, daemonAddress, cgroup string, debug bool, exitHa\n \t\t\tif stderrLog != nil {\n \t\t\t\tstderrLog.Close()\n \t\t\t}\n+\t\t\tsocket.Close()\n+\t\t\tRemoveSocket(address)\n \t\t}()\n \t\tlog.G(ctx).WithFields(logrus.Fields{\n \t\t\t\"pid\":     cmd.Process.Pid,\n@@ -142,6 +152,26 @@ func WithStart(binary, address, daemonAddress, cgroup string, debug bool, exitHa\n \t}\n }\n \n+func eaddrinuse(err error) bool {\n+\tcause := errors.Cause(err)\n+\tnetErr, ok := cause.(*net.OpError)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\tif netErr.Op != \"listen\" {\n+\t\treturn false\n+\t}\n+\tsyscallErr, ok := netErr.Err.(*os.SyscallError)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\terrno, ok := syscallErr.Err.(syscall.Errno)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn errno == syscall.EADDRINUSE\n+}\n+\n // setupOOMScore gets containerd's oom score and adds +1 to it\n // to ensure a shim has a lower* score than the daemons\n func setupOOMScore(shimPid int) error {\n@@ -214,31 +244,73 @@ func writeFile(path, address string) error {\n \treturn os.Rename(tempPath, path)\n }\n \n+const (\n+\tabstractSocketPrefix = \"\\x00\"\n+\tsocketPathLimit      = 106\n+)\n+\n+type socket string\n+\n+func (s socket) isAbstract() bool {\n+\treturn !strings.HasPrefix(string(s), \"unix://\")\n+}\n+\n+func (s socket) path() string {\n+\tpath := strings.TrimPrefix(string(s), \"unix://\")\n+\t// if there was no trim performed, we assume an abstract socket\n+\tif len(path) == len(s) {\n+\t\tpath = abstractSocketPrefix + path\n+\t}\n+\treturn path\n+}\n+\n func newSocket(address string) (*net.UnixListener, error) {\n-\tif len(address) > 106 {\n-\t\treturn nil, errors.Errorf(\"%q: unix socket path too long (> 106)\", address)\n+\tif len(address) > socketPathLimit {\n+\t\treturn nil, errors.Errorf(\"%q: unix socket path too long (> %d)\", address, socketPathLimit)\n+\t}\n+\tvar (\n+\t\tsock = socket(address)\n+\t\tpath = sock.path()\n+\t)\n+\tif !sock.isAbstract() {\n+\t\tif err := os.MkdirAll(filepath.Dir(path), 0600); err != nil {\n+\t\t\treturn nil, errors.Wrapf(err, \"%s\", path)\n+\t\t}\n \t}\n-\tl, err := net.Listen(\"unix\", \"\\x00\"+address)\n+\tl, err := net.Listen(\"unix\", path)\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"failed to listen to abstract unix socket %q\", address)\n+\t\treturn nil, errors.Wrapf(err, \"failed to listen to unix socket %q (abstract: %t)\", address, sock.isAbstract())\n+\t}\n+\tif err := os.Chmod(path, 0600); err != nil {\n+\t\tl.Close()\n+\t\treturn nil, err\n \t}\n \n \treturn l.(*net.UnixListener), nil\n }\n \n+// RemoveSocket removes the socket at the specified address if\n+// it exists on the filesystem\n+func RemoveSocket(address string) error {\n+\tsock := socket(address)\n+\tif !sock.isAbstract() {\n+\t\treturn os.Remove(sock.path())\n+\t}\n+\treturn nil\n+}\n+\n func connect(address string, d func(string, time.Duration) (net.Conn, error)) (net.Conn, error) {\n \treturn d(address, 100*time.Second)\n }\n \n-func annonDialer(address string, timeout time.Duration) (net.Conn, error) {\n-\taddress = strings.TrimPrefix(address, \"unix://\")\n-\treturn dialer.Dialer(\"\\x00\"+address, timeout)\n+func anonDialer(address string, timeout time.Duration) (net.Conn, error) {\n+\treturn dialer.Dialer(socket(address).path(), timeout)\n }\n \n // WithConnect connects to an existing shim\n func WithConnect(address string, onClose func()) Opt {\n \treturn func(ctx context.Context, config shim.Config) (shimapi.ShimService, io.Closer, error) {\n-\t\tconn, err := connect(address, annonDialer)\n+\t\tconn, err := connect(address, anonDialer)\n \t\tif err != nil {\n \t\t\treturn nil, nil, err\n \t\t}"
        },
        {
          "filename": "runtime/v2/runc/v1/service.go",
          "status": "modified",
          "additions": 14,
          "deletions": 4,
          "patch": "@@ -131,20 +131,26 @@ func (s *service) StartShim(ctx context.Context, id, containerdBinary, container\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n-\taddress, err := shim.SocketAddress(ctx, id)\n+\taddress, err := shim.SocketAddress(ctx, containerdAddress, id)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n \tsocket, err := shim.NewSocket(address)\n \tif err != nil {\n-\t\treturn \"\", err\n+\t\tif !shim.SocketEaddrinuse(err) {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tif err := shim.RemoveSocket(address); err != nil {\n+\t\t\treturn \"\", errors.Wrap(err, \"remove already used socket\")\n+\t\t}\n+\t\tif socket, err = shim.NewSocket(address); err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n \t}\n-\tdefer socket.Close()\n \tf, err := socket.File()\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n-\tdefer f.Close()\n \n \tcmd.ExtraFiles = append(cmd.ExtraFiles, f)\n \n@@ -153,6 +159,7 @@ func (s *service) StartShim(ctx context.Context, id, containerdBinary, container\n \t}\n \tdefer func() {\n \t\tif err != nil {\n+\t\t\t_ = shim.RemoveSocket(address)\n \t\t\tcmd.Process.Kill()\n \t\t}\n \t}()\n@@ -551,6 +558,9 @@ func (s *service) Connect(ctx context.Context, r *taskAPI.ConnectRequest) (*task\n func (s *service) Shutdown(ctx context.Context, r *taskAPI.ShutdownRequest) (*ptypes.Empty, error) {\n \ts.cancel()\n \tclose(s.events)\n+\tif address, err := shim.ReadAddress(\"address\"); err == nil {\n+\t\t_ = shim.RemoveSocket(address)\n+\t}\n \treturn empty, nil\n }\n "
        },
        {
          "filename": "runtime/v2/runc/v2/service.go",
          "status": "modified",
          "additions": 33,
          "deletions": 10,
          "patch": "@@ -25,7 +25,6 @@ import (\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n-\t\"strings\"\n \t\"sync\"\n \t\"syscall\"\n \t\"time\"\n@@ -105,6 +104,10 @@ func New(ctx context.Context, id string, publisher shim.Publisher, shutdown func\n \t\treturn nil, errors.Wrap(err, \"failed to initialized platform behavior\")\n \t}\n \tgo s.forward(ctx, publisher)\n+\n+\tif address, err := shim.ReadAddress(\"address\"); err == nil {\n+\t\ts.shimAddress = address\n+\t}\n \treturn s, nil\n }\n \n@@ -124,7 +127,8 @@ type service struct {\n \n \tcontainers map[string]*runc.Container\n \n-\tcancel func()\n+\tshimAddress string\n+\tcancel      func()\n }\n \n func newCommand(ctx context.Context, id, containerdBinary, containerdAddress, containerdTTRPCAddress string) (*exec.Cmd, error) {\n@@ -183,30 +187,48 @@ func (s *service) StartShim(ctx context.Context, id, containerdBinary, container\n \t\t\tbreak\n \t\t}\n \t}\n-\taddress, err := shim.SocketAddress(ctx, grouping)\n+\taddress, err := shim.SocketAddress(ctx, containerdAddress, grouping)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n+\n \tsocket, err := shim.NewSocket(address)\n \tif err != nil {\n-\t\tif strings.Contains(err.Error(), \"address already in use\") {\n+\t\t// the only time where this would happen is if there is a bug and the socket\n+\t\t// was not cleaned up in the cleanup method of the shim or we are using the\n+\t\t// grouping functionality where the new process should be run with the same\n+\t\t// shim as an existing container\n+\t\tif !shim.SocketEaddrinuse(err) {\n+\t\t\treturn \"\", errors.Wrap(err, \"create new shim socket\")\n+\t\t}\n+\t\tif shim.CanConnect(address) {\n \t\t\tif err := shim.WriteAddress(\"address\", address); err != nil {\n-\t\t\t\treturn \"\", err\n+\t\t\t\treturn \"\", errors.Wrap(err, \"write existing socket for shim\")\n \t\t\t}\n \t\t\treturn address, nil\n \t\t}\n-\t\treturn \"\", err\n+\t\tif err := shim.RemoveSocket(address); err != nil {\n+\t\t\treturn \"\", errors.Wrap(err, \"remove pre-existing socket\")\n+\t\t}\n+\t\tif socket, err = shim.NewSocket(address); err != nil {\n+\t\t\treturn \"\", errors.Wrap(err, \"try create new shim socket 2x\")\n+\t\t}\n \t}\n-\tdefer socket.Close()\n+\tdefer func() {\n+\t\tif retErr != nil {\n+\t\t\tsocket.Close()\n+\t\t\t_ = shim.RemoveSocket(address)\n+\t\t}\n+\t}()\n \tf, err := socket.File()\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n-\tdefer f.Close()\n \n \tcmd.ExtraFiles = append(cmd.ExtraFiles, f)\n \n \tif err := cmd.Start(); err != nil {\n+\t\tf.Close()\n \t\treturn \"\", err\n \t}\n \tdefer func() {\n@@ -273,7 +295,6 @@ func (s *service) Cleanup(ctx context.Context) (*taskAPI.DeleteResponse, error)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\n \truntime, err := runc.ReadRuntime(path)\n \tif err != nil {\n \t\treturn nil, err\n@@ -652,7 +673,9 @@ func (s *service) Shutdown(ctx context.Context, r *taskAPI.ShutdownRequest) (*pt\n \tif s.platform != nil {\n \t\ts.platform.Close()\n \t}\n-\n+\tif s.shimAddress != \"\" {\n+\t\t_ = shim.RemoveSocket(s.shimAddress)\n+\t}\n \treturn empty, nil\n }\n "
        },
        {
          "filename": "runtime/v2/shim/shim.go",
          "status": "modified",
          "additions": 6,
          "deletions": 3,
          "patch": "@@ -104,7 +104,7 @@ func parseFlags() {\n \tflag.BoolVar(&versionFlag, \"v\", false, \"show the shim version and exit\")\n \tflag.StringVar(&namespaceFlag, \"namespace\", \"\", \"namespace that owns the shim\")\n \tflag.StringVar(&idFlag, \"id\", \"\", \"id of the task\")\n-\tflag.StringVar(&socketFlag, \"socket\", \"\", \"abstract socket path to serve\")\n+\tflag.StringVar(&socketFlag, \"socket\", \"\", \"socket path to serve\")\n \tflag.StringVar(&bundlePath, \"bundle\", \"\", \"path to the bundle if not workdir\")\n \n \tflag.StringVar(&addressFlag, \"address\", \"\", \"grpc address back to main containerd\")\n@@ -195,7 +195,6 @@ func run(id string, initFunc Init, config Config) error {\n \tctx = context.WithValue(ctx, OptsKey{}, Opts{BundlePath: bundlePath, Debug: debugFlag})\n \tctx = log.WithLogger(ctx, log.G(ctx).WithField(\"runtime\", id))\n \tctx, cancel := context.WithCancel(ctx)\n-\n \tservice, err := initFunc(ctx, idFlag, publisher, cancel)\n \tif err != nil {\n \t\treturn err\n@@ -300,11 +299,15 @@ func serve(ctx context.Context, server *ttrpc.Server, path string) error {\n \t\treturn err\n \t}\n \tgo func() {\n-\t\tdefer l.Close()\n \t\tif err := server.Serve(ctx, l); err != nil &&\n \t\t\t!strings.Contains(err.Error(), \"use of closed network connection\") {\n \t\t\tlogrus.WithError(err).Fatal(\"containerd-shim: ttrpc server failure\")\n \t\t}\n+\t\tl.Close()\n+\t\tif address, err := ReadAddress(\"address\"); err == nil {\n+\t\t\t_ = RemoveSocket(address)\n+\t\t}\n+\n \t}()\n \treturn nil\n }"
        },
        {
          "filename": "runtime/v2/shim/shim_unix.go",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -58,15 +58,15 @@ func serveListener(path string) (net.Listener, error) {\n \t\tl, err = net.FileListener(os.NewFile(3, \"socket\"))\n \t\tpath = \"[inherited from parent]\"\n \t} else {\n-\t\tif len(path) > 106 {\n-\t\t\treturn nil, errors.Errorf(\"%q: unix socket path too long (> 106)\", path)\n+\t\tif len(path) > socketPathLimit {\n+\t\t\treturn nil, errors.Errorf(\"%q: unix socket path too long (> %d)\", path, socketPathLimit)\n \t\t}\n-\t\tl, err = net.Listen(\"unix\", \"\\x00\"+path)\n+\t\tl, err = net.Listen(\"unix\", path)\n \t}\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tlogrus.WithField(\"socket\", path).Debug(\"serving api on abstract socket\")\n+\tlogrus.WithField(\"socket\", path).Debug(\"serving api on socket\")\n \treturn l, nil\n }\n "
        },
        {
          "filename": "runtime/v2/shim/util.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -169,7 +169,7 @@ func WriteAddress(path, address string) error {\n // ErrNoAddress is returned when the address file has no content\n var ErrNoAddress = errors.New(\"no shim address\")\n \n-// ReadAddress returns the shim's abstract socket address from the path\n+// ReadAddress returns the shim's socket address from the path\n func ReadAddress(path string) (string, error) {\n \tpath, err := filepath.Abs(path)\n \tif err != nil {"
        },
        {
          "filename": "runtime/v2/shim/util_unix.go",
          "status": "modified",
          "additions": 86,
          "deletions": 12,
          "patch": "@@ -35,7 +35,10 @@ import (\n \t\"github.com/pkg/errors\"\n )\n \n-const shimBinaryFormat = \"containerd-shim-%s-%s\"\n+const (\n+\tshimBinaryFormat = \"containerd-shim-%s-%s\"\n+\tsocketPathLimit  = 106\n+)\n \n func getSysProcAttr() *syscall.SysProcAttr {\n \treturn &syscall.SysProcAttr{\n@@ -63,20 +66,21 @@ func AdjustOOMScore(pid int) error {\n \treturn nil\n }\n \n-// SocketAddress returns an abstract socket address\n-func SocketAddress(ctx context.Context, id string) (string, error) {\n+const socketRoot = \"/run/containerd\"\n+\n+// SocketAddress returns a socket address\n+func SocketAddress(ctx context.Context, socketPath, id string) (string, error) {\n \tns, err := namespaces.NamespaceRequired(ctx)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n-\td := sha256.Sum256([]byte(filepath.Join(ns, id)))\n-\treturn filepath.Join(string(filepath.Separator), \"containerd-shim\", fmt.Sprintf(\"%x.sock\", d)), nil\n+\td := sha256.Sum256([]byte(filepath.Join(socketPath, ns, id)))\n+\treturn fmt.Sprintf(\"unix://%s/%x\", filepath.Join(socketRoot, \"s\"), d), nil\n }\n \n-// AnonDialer returns a dialer for an abstract socket\n+// AnonDialer returns a dialer for a socket\n func AnonDialer(address string, timeout time.Duration) (net.Conn, error) {\n-\taddress = strings.TrimPrefix(address, \"unix://\")\n-\treturn dialer.Dialer(\"\\x00\"+address, timeout)\n+\treturn dialer.Dialer(socket(address).path(), timeout)\n }\n \n func AnonReconnectDialer(address string, timeout time.Duration) (net.Conn, error) {\n@@ -85,12 +89,82 @@ func AnonReconnectDialer(address string, timeout time.Duration) (net.Conn, error\n \n // NewSocket returns a new socket\n func NewSocket(address string) (*net.UnixListener, error) {\n-\tif len(address) > 106 {\n-\t\treturn nil, errors.Errorf(\"%q: unix socket path too long (> 106)\", address)\n+\tvar (\n+\t\tsock = socket(address)\n+\t\tpath = sock.path()\n+\t)\n+\tif !sock.isAbstract() {\n+\t\tif err := os.MkdirAll(filepath.Dir(path), 0600); err != nil {\n+\t\t\treturn nil, errors.Wrapf(err, \"%s\", path)\n+\t\t}\n \t}\n-\tl, err := net.Listen(\"unix\", \"\\x00\"+address)\n+\tl, err := net.Listen(\"unix\", path)\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"failed to listen to abstract unix socket %q\", address)\n+\t\treturn nil, err\n+\t}\n+\tif err := os.Chmod(path, 0600); err != nil {\n+\t\tos.Remove(sock.path())\n+\t\tl.Close()\n+\t\treturn nil, err\n \t}\n \treturn l.(*net.UnixListener), nil\n }\n+\n+const abstractSocketPrefix = \"\\x00\"\n+\n+type socket string\n+\n+func (s socket) isAbstract() bool {\n+\treturn !strings.HasPrefix(string(s), \"unix://\")\n+}\n+\n+func (s socket) path() string {\n+\tpath := strings.TrimPrefix(string(s), \"unix://\")\n+\t// if there was no trim performed, we assume an abstract socket\n+\tif len(path) == len(s) {\n+\t\tpath = abstractSocketPrefix + path\n+\t}\n+\treturn path\n+}\n+\n+// RemoveSocket removes the socket at the specified address if\n+// it exists on the filesystem\n+func RemoveSocket(address string) error {\n+\tsock := socket(address)\n+\tif !sock.isAbstract() {\n+\t\treturn os.Remove(sock.path())\n+\t}\n+\treturn nil\n+}\n+\n+// SocketEaddrinuse returns true if the provided error is caused by the\n+// EADDRINUSE error number\n+func SocketEaddrinuse(err error) bool {\n+\tnetErr, ok := err.(*net.OpError)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\tif netErr.Op != \"listen\" {\n+\t\treturn false\n+\t}\n+\tsyscallErr, ok := netErr.Err.(*os.SyscallError)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\terrno, ok := syscallErr.Err.(syscall.Errno)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn errno == syscall.EADDRINUSE\n+}\n+\n+// CanConnect returns true if the socket provided at the address\n+// is accepting new connections\n+func CanConnect(address string) bool {\n+\tconn, err := AnonDialer(address, 100*time.Millisecond)\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\tconn.Close()\n+\treturn true\n+}"
        },
        {
          "filename": "runtime/v2/shim/util_windows.go",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -79,3 +79,9 @@ func AnonDialer(address string, timeout time.Duration) (net.Conn, error) {\n \t\treturn c, nil\n \t}\n }\n+\n+// RemoveSocket removes the socket at the specified address if\n+// it exists on the filesystem\n+func RemoveSocket(address string) error {\n+\treturn nil\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 7,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "432d32cd9dc739c04441202b6287063e67bdec3e",
            "date": "2025-01-14T14:08:26Z",
            "author_login": "fuweid"
          },
          {
            "sha": "d44d76186391365d6e251527bbbe5007e5c760b6",
            "date": "2025-01-14T07:56:05Z",
            "author_login": "samuelkarp"
          },
          {
            "sha": "04bac22dfc99d0d9991ba33e4b05b7d85bd86548",
            "date": "2025-01-14T07:27:22Z",
            "author_login": "AkihiroSuda"
          },
          {
            "sha": "b87d67fcc2795b662c6445f7960242e24e743cbd",
            "date": "2025-01-14T07:26:35Z",
            "author_login": "samuelkarp"
          },
          {
            "sha": "bdc847f1eb535a6728b6db3f2619d2a5ed0edbb9",
            "date": "2025-01-14T06:01:10Z",
            "author_login": "dmcgowan"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.2,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N",
    "cwe_id": "CWE-669",
    "description": "containerd is an industry-standard container runtime and is available as a daemon for Linux and Windows. In containerd before versions 1.3.9 and 1.4.3, the containerd-shim API is improperly exposed to host network containers. Access controls for the shim\u2019s API socket verified that the connecting process had an effective UID of 0, but did not otherwise restrict access to the abstract Unix domain socket. This would allow malicious containers running in the same network namespace as the shim, with an effective UID of 0 but otherwise reduced privileges, to cause new processes to be run with elevated privileges. This vulnerability has been fixed in containerd 1.3.9 and 1.4.3. Users should update to these versions as soon as they are released. It should be noted that containers started with an old version of containerd-shim should be stopped and restarted, as running containers will continue to be vulnerable even after an upgrade. If you are not providing the ability for untrusted users to start containers in the same network namespace as the shim (typically the \"host\" network namespace, for example with docker run --net=host or hostNetwork: true in a Kubernetes pod) and run with an effective UID of 0, you are not vulnerable to this issue. If you are running containers with a vulnerable configuration, you can deny access to all abstract sockets with AppArmor by adding a line similar to deny unix addr=@**, to your policy. It is best practice to run containers with a reduced set of privileges, with a non-zero UID, and with isolated namespaces. The containerd maintainers strongly advise against sharing namespaces with the host. Reducing the set of isolation mechanisms used for a container necessarily increases that container's privilege, regardless of what container runtime is used for running that container.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-12-01T03:15:11.257",
    "last_modified": "2024-11-21T05:05:12.617",
    "fix_date": "2020-11-30T18:32:18Z"
  },
  "references": [
    {
      "url": "https://github.com/containerd/containerd/commit/4a4bb851f5da563ff6e68a83dc837c7699c469ad",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/containerd/containerd/releases/tag/v1.4.3",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/containerd/containerd/security/advisories/GHSA-36xw-fx78-c5r4",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LNKXLOLZWO5FMAPX63ZL7JNKTNNT5NQD/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202105-33",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2021/dsa-4865",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/containerd/containerd/commit/4a4bb851f5da563ff6e68a83dc837c7699c469ad",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/containerd/containerd/releases/tag/v1.4.3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/containerd/containerd/security/advisories/GHSA-36xw-fx78-c5r4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LNKXLOLZWO5FMAPX63ZL7JNKTNNT5NQD/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202105-33",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2021/dsa-4865",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:08.484862",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "containerd",
    "owner": "containerd",
    "created_at": "2015-11-13T00:27:43Z",
    "updated_at": "2025-01-14T14:43:38Z",
    "pushed_at": "2025-01-14T14:43:31Z",
    "size": 158285,
    "stars": 17816,
    "forks": 3512,
    "open_issues": 357,
    "watchers": 17816,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release/1.0",
      "release/1.1",
      "release/1.2",
      "release/1.3",
      "release/1.4",
      "release/1.5",
      "release/1.6",
      "release/1.7",
      "release/2.0"
    ],
    "languages": {
      "Go": 5381141,
      "Shell": 94349,
      "Makefile": 26121,
      "PowerShell": 6191,
      "jq": 4089,
      "Dockerfile": 3995
    },
    "commit_activity": {
      "total_commits_last_year": 1314,
      "avg_commits_per_week": 25.26923076923077,
      "days_active_last_year": 277
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:50:55.249369"
  }
}