{
  "cve_id": "CVE-2020-15270",
  "github_data": {
    "repository": "parse-community/parse-server",
    "fix_commit": "78b59fb26b1c36e3cdbd42ba9fec025003267f58",
    "related_commits": [
      "78b59fb26b1c36e3cdbd42ba9fec025003267f58",
      "78b59fb26b1c36e3cdbd42ba9fec025003267f58"
    ],
    "patch_url": "https://github.com/parse-community/parse-server/commit/78b59fb26b1c36e3cdbd42ba9fec025003267f58.patch",
    "fix_commit_details": {
      "sha": "78b59fb26b1c36e3cdbd42ba9fec025003267f58",
      "commit_date": "2020-10-21T23:32:07Z",
      "author": {
        "login": "davimacedo",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-2xm2-xj2q-qgpj",
        "length": 139,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 74,
        "additions": 62,
        "deletions": 12
      },
      "files": [
        {
          "filename": "spec/ParseLiveQuery.spec.js",
          "status": "modified",
          "additions": 42,
          "deletions": 0,
          "patch": "@@ -784,6 +784,48 @@ describe('ParseLiveQuery', function () {\n     });\n   });\n \n+  it('should not broadcast event to client with invalid session token - avisory GHSA-2xm2-xj2q-qgpj', async done => {\n+    await reconfigureServer({\n+      liveQuery: {\n+        classNames: ['TestObject'],\n+      },\n+      liveQueryServerOptions: {\n+        cacheTimeout: 100,\n+      },\n+      startLiveQueryServer: true,\n+      verbose: false,\n+      silent: true,\n+      cacheTTL: 100,\n+    });\n+    const user = new Parse.User();\n+    user.setUsername('username');\n+    user.setPassword('password');\n+    await user.signUp();\n+    const obj1 = new Parse.Object('TestObject');\n+    const obj1ACL = new Parse.ACL();\n+    obj1ACL.setPublicReadAccess(false);\n+    obj1ACL.setReadAccess(user, true);\n+    obj1.setACL(obj1ACL);\n+    const obj2 = new Parse.Object('TestObject');\n+    const obj2ACL = new Parse.ACL();\n+    obj2ACL.setPublicReadAccess(false);\n+    obj2ACL.setReadAccess(user, true);\n+    obj2.setACL(obj2ACL);\n+    const query = new Parse.Query('TestObject');\n+    const subscription = await query.subscribe();\n+    subscription.on('create', obj => {\n+      if (obj.id !== obj1.id) {\n+        done.fail('should not fire');\n+      }\n+    });\n+    await obj1.save();\n+    await Parse.User.logOut();\n+    await new Promise(resolve => setTimeout(resolve, 200));\n+    await obj2.save();\n+    await new Promise(resolve => setTimeout(resolve, 200));\n+    done();\n+  });\n+\n   afterEach(async function (done) {\n     const client = await Parse.CoreManager.getLiveQueryController().getDefaultLiveQueryClient();\n     client.close();"
        },
        {
          "filename": "src/LiveQuery/ParseLiveQueryServer.js",
          "status": "modified",
          "additions": 7,
          "deletions": 5,
          "patch": "@@ -30,10 +30,11 @@ class ParseLiveQueryServer {\n   // The subscriber we use to get object update from publisher\n   subscriber: Object;\n \n-  constructor(server: any, config: any = {}) {\n+  constructor(server: any, config: any = {}, parseServerConfig: any = {}) {\n     this.server = server;\n     this.clients = new Map();\n     this.subscriptions = new Map();\n+    this.config = config;\n \n     config.appId = config.appId || Parse.applicationId;\n     config.masterKey = config.masterKey || Parse.masterKey;\n@@ -54,13 +55,15 @@ class ParseLiveQueryServer {\n \n     // The cache controller is a proper cache controller\n     // with access to User and Roles\n-    this.cacheController = getCacheController(config);\n+    this.cacheController = getCacheController(parseServerConfig);\n+\n+    config.cacheTimeout = config.cacheTimeout || 5 * 1000; // 5s\n \n     // This auth cache stores the promises for each auth resolution.\n     // The main benefit is to be able to reuse the same user / session token resolution.\n     this.authCache = new LRU({\n       max: 500, // 500 concurrent\n-      maxAge: 60 * 60 * 1000, // 1h\n+      maxAge: config.cacheTimeout,\n     });\n     // Initialize websocket server\n     this.parseWebSocketServer = new ParseWebSocketServer(\n@@ -510,12 +513,11 @@ class ParseLiveQueryServer {\n         // There was an error with the session token\n         const result = {};\n         if (error && error.code === Parse.Error.INVALID_SESSION_TOKEN) {\n-          // Store a resolved promise with the error for 10 minutes\n           result.error = error;\n           this.authCache.set(\n             sessionToken,\n             Promise.resolve(result),\n-            60 * 10 * 1000\n+            this.config.cacheTimeout\n           );\n         } else {\n           this.authCache.del(sessionToken);"
        },
        {
          "filename": "src/Options/Definitions.js",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -478,7 +478,7 @@ module.exports.LiveQueryServerOptions = {\n   cacheTimeout: {\n     env: 'PARSE_LIVE_QUERY_SERVER_CACHE_TIMEOUT',\n     help:\n-      \"Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 30 * 24 * 60 * 60 * 1000 ms (~30 days).\",\n+      \"Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 5 * 1000 ms (5 seconds).\",\n     action: parsers.numberParser('cacheTimeout'),\n   },\n   keyPairs: {"
        },
        {
          "filename": "src/Options/docs.js",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -100,7 +100,7 @@\n /**\n  * @interface LiveQueryServerOptions\n  * @property {String} appId This string should match the appId in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same appId.\n- * @property {Number} cacheTimeout Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 30 * 24 * 60 * 60 * 1000 ms (~30 days).\n+ * @property {Number} cacheTimeout Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 5 * 1000 ms (5 seconds).\n  * @property {Any} keyPairs A JSON object that serves as a whitelist of keys. It is used for validating clients when they try to connect to the LiveQuery server. Check the following Security section and our protocol specification for details.\n  * @property {String} logLevel This string defines the log level of the LiveQuery server. We support VERBOSE, INFO, ERROR, NONE, defaults to INFO.\n  * @property {String} masterKey This string should match the masterKey in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same masterKey."
        },
        {
          "filename": "src/Options/index.js",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -260,7 +260,7 @@ export interface LiveQueryServerOptions {\n   keyPairs: ?any;\n   /* Number of milliseconds between ping/pong frames. The WebSocket server sends ping/pong frames to the clients to keep the WebSocket alive. This value defines the interval of the ping/pong frame from the server to clients, defaults to 10 * 1000 ms (10 s).*/\n   websocketTimeout: ?number;\n-  /* Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 30 * 24 * 60 * 60 * 1000 ms (~30 days).*/\n+  /* Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 5 * 1000 ms (5 seconds).*/\n   cacheTimeout: ?number;\n   /* This string defines the log level of the LiveQuery server. We support VERBOSE, INFO, ERROR, NONE, defaults to INFO.*/\n   logLevel: ?string;"
        },
        {
          "filename": "src/ParseServer.js",
          "status": "modified",
          "additions": 10,
          "deletions": 4,
          "patch": "@@ -298,7 +298,8 @@ class ParseServer {\n     if (options.startLiveQueryServer || options.liveQueryServerOptions) {\n       this.liveQueryServer = ParseServer.createLiveQueryServer(\n         server,\n-        options.liveQueryServerOptions\n+        options.liveQueryServerOptions,\n+        options\n       );\n     }\n     /* istanbul ignore next */\n@@ -324,16 +325,21 @@ class ParseServer {\n    * Helper method to create a liveQuery server\n    * @static\n    * @param {Server} httpServer an optional http server to pass\n-   * @param {LiveQueryServerOptions} config options fot he liveQueryServer\n+   * @param {LiveQueryServerOptions} config options for the liveQueryServer\n+   * @param {ParseServerOptions} options options for the ParseServer\n    * @returns {ParseLiveQueryServer} the live query server instance\n    */\n-  static createLiveQueryServer(httpServer, config: LiveQueryServerOptions) {\n+  static createLiveQueryServer(\n+    httpServer,\n+    config: LiveQueryServerOptions,\n+    options: ParseServerOptions\n+  ) {\n     if (!httpServer || (config && config.port)) {\n       var app = express();\n       httpServer = require('http').createServer(app);\n       httpServer.listen(config.port);\n     }\n-    return new ParseLiveQueryServer(httpServer, config);\n+    return new ParseLiveQueryServer(httpServer, config, options);\n   }\n \n   static verifyServerUrl(callback) {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 4,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "970528ddff49d7e66bc41a876f043953ab075baa",
            "date": "2025-01-14T21:39:11Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "ad0a7bc0ba1823ada299a6476402420fdc4c4467",
            "date": "2025-01-14T18:51:58Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "28b3edee4e76679dedee9fe115283110fd952678",
            "date": "2025-01-13T15:19:51Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "1b61cab81c4206ce135f1239f17a53dabbc698d7",
            "date": "2025-01-13T14:47:17Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "a0efad88d2177f027ee3709beba13282a6ca9d35",
            "date": "2025-01-12T20:55:48Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-672",
    "description": "Parse Server (npm package parse-server) broadcasts events to all clients without checking if the session token is valid. This allows clients with expired sessions to still receive subscription objects. It is not possible to create subscription objects with invalid session tokens. The issue is not patched.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-10-22T22:15:12.063",
    "last_modified": "2024-11-21T05:05:14.230",
    "fix_date": "2020-10-21T23:32:07Z"
  },
  "references": [
    {
      "url": "https://github.com/parse-community/parse-server/commit/78b59fb26b1c36e3cdbd42ba9fec025003267f58",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-2xm2-xj2q-qgpj",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://npmjs.com/parse-server",
      "source": "security-advisories@github.com",
      "tags": [
        "Product",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/commit/78b59fb26b1c36e3cdbd42ba9fec025003267f58",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-2xm2-xj2q-qgpj",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://npmjs.com/parse-server",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:06.192478",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "parse-server",
    "owner": "parse-community",
    "created_at": "2016-01-28T18:29:14Z",
    "updated_at": "2025-01-13T16:51:06Z",
    "pushed_at": "2025-01-14T11:16:34Z",
    "size": 73208,
    "stars": 20994,
    "forks": 4781,
    "open_issues": 474,
    "watchers": 20994,
    "has_security_policy": false,
    "default_branch": "alpha",
    "protected_branches": [
      "alpha",
      "beta",
      "release",
      "release-4.x.x",
      "release-5.x.x",
      "release-6.x.x",
      "release-7.x.x"
    ],
    "languages": {
      "JavaScript": 4248231,
      "HTML": 25876,
      "Shell": 7825,
      "Handlebars": 2113,
      "Dockerfile": 1211
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:26:59.166995"
  }
}