{
  "cve_id": "CVE-2020-15861",
  "github_data": {
    "repository": "net-snmp/net-snmp",
    "fix_commit": "4fd9a450444a434a993bc72f7c3486ccce41f602",
    "related_commits": [
      "4fd9a450444a434a993bc72f7c3486ccce41f602",
      "4fd9a450444a434a993bc72f7c3486ccce41f602"
    ],
    "patch_url": "https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602.patch",
    "fix_commit_details": {
      "sha": "4fd9a450444a434a993bc72f7c3486ccce41f602",
      "commit_date": "2019-05-22T07:56:21Z",
      "author": {
        "login": "bvanassche",
        "type": "User",
        "stats": {
          "total_commits": 3901,
          "average_weekly_commits": 5.509887005649717,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 366
        }
      },
      "commit_message": {
        "title": "CHANGES: snmpd: Stop reading and writing the mib_indexes/* files",
        "length": 290,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 211,
        "additions": 4,
        "deletions": 207
      },
      "files": [
        {
          "filename": ".gitignore",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -75,7 +75,6 @@ Makefile\n man/*.[1358]\n man/default_store.3.h\n man/manaliases\n-mibs/.index\n mk/\n module_tmp_header.h\n net-snmp-5*"
        },
        {
          "filename": "include/net-snmp/library/mib.h",
          "status": "modified",
          "additions": 0,
          "deletions": 3,
          "patch": "@@ -124,9 +124,6 @@ SOFTWARE.\n     NETSNMP_IMPORT\n     char            *netsnmp_get_mib_directory(void);\n     void            netsnmp_fixup_mib_directory(void);\n-    void            netsnmp_mibindex_load( void );\n-    char *          netsnmp_mibindex_lookup( const char * );\n-    FILE *          netsnmp_mibindex_new( const char * );\n     int             sprint_realloc_description(u_char ** buf, size_t * buf_len,\n                                 size_t * out_len, int allow_realloc,\n                                 oid * objid, size_t objidlen, int width);"
        },
        {
          "filename": "include/net-snmp/library/parse.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -201,7 +201,7 @@ SOFTWARE.\n #endif\n     void            netsnmp_init_mib_internals(void);\n     void            unload_all_mibs(void);\n-    int             add_mibfile(const char*, const char*, FILE *);\n+    int             add_mibfile(const char*, const char*);\n     int             which_module(const char *);\n     NETSNMP_IMPORT\n     char           *module_name(int, char *);"
        },
        {
          "filename": "snmplib/mib.c",
          "status": "modified",
          "additions": 1,
          "deletions": 147,
          "patch": "@@ -2720,7 +2720,6 @@ netsnmp_init_mib(void)\n     env_var = strdup(netsnmp_get_mib_directory());\n     if (!env_var)\n         return;\n-    netsnmp_mibindex_load();\n \n     DEBUGMSGTL((\"init_mib\",\n                 \"Seen MIBDIRS: Looking in '%s' for mib dirs ...\\n\",\n@@ -2740,7 +2739,7 @@ netsnmp_init_mib(void)\n         else\n             entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n         while (entry) {\n-            add_mibfile(entry, NULL, NULL);\n+            add_mibfile(entry, NULL);\n             entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n         }\n     }\n@@ -2891,142 +2890,6 @@ init_mib(void)\n #endif\n \n \n-/*\n- * Handle MIB indexes centrally\n- */\n-static int _mibindex     = 0;   /* Last index in use */\n-static int _mibindex_max = 0;   /* Size of index array */\n-char     **_mibindexes   = NULL;\n-\n-int _mibindex_add( const char *dirname, int i );\n-void\n-netsnmp_mibindex_load( void )\n-{\n-    DIR *dir;\n-    struct dirent *file;\n-    FILE *fp;\n-    char tmpbuf[ 300];\n-    char tmpbuf2[300];\n-    int  i;\n-    char *cp;\n-\n-    /*\n-     * Open the MIB index directory, or create it (empty)\n-     */\n-    snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes\",\n-              get_persistent_directory());\n-    tmpbuf[sizeof(tmpbuf)-1] = 0;\n-    dir = opendir( tmpbuf );\n-    if ( dir == NULL ) {\n-        DEBUGMSGTL((\"mibindex\", \"load: (new)\\n\"));\n-        mkdirhier( tmpbuf, NETSNMP_AGENT_DIRECTORY_MODE, 0);\n-        return;\n-    }\n-\n-    /*\n-     * Create a list of which directory each file refers to\n-     */\n-    while ((file = readdir( dir ))) {\n-        if ( !isdigit((unsigned char)(file->d_name[0])))\n-            continue;\n-        i = atoi( file->d_name );\n-\n-        snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n-              get_persistent_directory(), i );\n-        tmpbuf[sizeof(tmpbuf)-1] = 0;\n-        fp = fopen( tmpbuf, \"r\" );\n-        if (!fp)\n-            continue;\n-        cp = fgets( tmpbuf2, sizeof(tmpbuf2), fp );\n-        fclose( fp );\n-        if ( !cp ) {\n-            DEBUGMSGTL((\"mibindex\", \"Empty MIB index (%d)\\n\", i));\n-            continue;\n-        }\n-        if ( strncmp( tmpbuf2, \"DIR \", 4 ) != 0 ) {\n-            DEBUGMSGTL((\"mibindex\", \"Malformed MIB index (%d)\\n\", i));\n-            continue;\n-        }\n-        tmpbuf2[strlen(tmpbuf2)-1] = 0;\n-        DEBUGMSGTL((\"mibindex\", \"load: (%d) %s\\n\", i, tmpbuf2));\n-        (void)_mibindex_add( tmpbuf2+4, i );  /* Skip 'DIR ' */\n-    }\n-    closedir( dir );\n-}\n-\n-char *\n-netsnmp_mibindex_lookup( const char *dirname )\n-{\n-    int i;\n-    static char tmpbuf[300];\n-\n-    for (i=0; i<_mibindex; i++) {\n-        if ( _mibindexes[i] &&\n-             strcmp( _mibindexes[i], dirname ) == 0) {\n-             snprintf(tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n-                      get_persistent_directory(), i);\n-             tmpbuf[sizeof(tmpbuf)-1] = 0;\n-             DEBUGMSGTL((\"mibindex\", \"lookup: %s (%d) %s\\n\", dirname, i, tmpbuf ));\n-             return tmpbuf;\n-        }\n-    }\n-    DEBUGMSGTL((\"mibindex\", \"lookup: (none)\\n\"));\n-    return NULL;\n-}\n-\n-int\n-_mibindex_add( const char *dirname, int i )\n-{\n-    const int old_mibindex_max = _mibindex_max;\n-\n-    DEBUGMSGTL((\"mibindex\", \"add: %s (%d)\\n\", dirname, i ));\n-    if ( i == -1 )\n-        i = _mibindex++;\n-    if ( i >= _mibindex_max ) {\n-        /*\n-         * If the index array is full (or non-existent)\n-         *   then expand (or create) it\n-         */\n-        _mibindex_max = i + 10;\n-        _mibindexes = realloc(_mibindexes,\n-                              _mibindex_max * sizeof(_mibindexes[0]));\n-        netsnmp_assert(_mibindexes);\n-        memset(_mibindexes + old_mibindex_max, 0,\n-               (_mibindex_max - old_mibindex_max) * sizeof(_mibindexes[0]));\n-    }\n-\n-    _mibindexes[ i ] = strdup( dirname );\n-    if ( i >= _mibindex )\n-        _mibindex = i+1;\n-\n-    DEBUGMSGTL((\"mibindex\", \"add: %d/%d/%d\\n\", i, _mibindex, _mibindex_max ));\n-    return i;\n-}\n-    \n-FILE *\n-netsnmp_mibindex_new( const char *dirname )\n-{\n-    FILE *fp;\n-    char  tmpbuf[300];\n-    char *cp;\n-    int   i;\n-\n-    cp = netsnmp_mibindex_lookup( dirname );\n-    if (!cp) {\n-        i  = _mibindex_add( dirname, -1 );\n-        snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n-                  get_persistent_directory(), i );\n-        tmpbuf[sizeof(tmpbuf)-1] = 0;\n-        cp = tmpbuf;\n-    }\n-    DEBUGMSGTL((\"mibindex\", \"new: %s (%s)\\n\", dirname, cp ));\n-    fp = fopen( cp, \"w\" );\n-    if (fp)\n-        fprintf( fp, \"DIR %s\\n\", dirname );\n-    return fp;\n-}\n-\n-\n /**\n  * Unloads all mibs.\n  */\n@@ -3041,15 +2904,6 @@ shutdown_mib(void)\n     }\n     tree_head = NULL;\n     Mib = NULL;\n-    if (_mibindexes) {\n-        int i;\n-        for (i = 0; i < _mibindex; ++i)\n-            SNMP_FREE(_mibindexes[i]);\n-        free(_mibindexes);\n-        _mibindex = 0;\n-        _mibindex_max = 0;\n-        _mibindexes = NULL;\n-    }\n     if (Prefix != NULL && Prefix != &Standard_Prefix[0])\n         SNMP_FREE(Prefix);\n     if (Prefix)"
        },
        {
          "filename": "snmplib/parse.c",
          "status": "modified",
          "additions": 2,
          "deletions": 55,
          "patch": "@@ -607,8 +607,6 @@ static int     read_module_replacements(const char *);\n static int     read_import_replacements(const char *,\n                                          struct module_import *);\n \n-static void     new_module(const char *, const char *);\n-\n static struct node *merge_parse_objectid(struct node *, FILE *, char *);\n static struct index_list *getIndexes(FILE * fp, struct index_list **);\n static struct varbind_list *getVarbinds(FILE * fp, struct varbind_list **);\n@@ -4859,7 +4857,7 @@ snmp_get_token(FILE * fp, char *token, int maxtlen)\n #endif /* NETSNMP_FEATURE_REMOVE_PARSE_GET_TOKEN */\n \n int\n-add_mibfile(const char* tmpstr, const char* d_name, FILE *ip )\n+add_mibfile(const char* tmpstr, const char* d_name)\n {\n     FILE           *fp;\n     char            token[MAXTOKEN], token2[MAXTOKEN];\n@@ -4884,8 +4882,6 @@ add_mibfile(const char* tmpstr, const char* d_name, FILE *ip )\n      */\n     if (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {\n         new_module(token, tmpstr);\n-        if (ip)\n-            fprintf(ip, \"%s %s\\n\", token, d_name);\n         fclose(fp);\n         return 0;\n     } else {\n@@ -4977,71 +4973,22 @@ static int scan_directory(char ***result, const char *dirname)\n int\n add_mibdir(const char *dirname)\n {\n-    FILE           *ip;\n     const char     *oldFile = File;\n     char          **filenames;\n     int             count = 0;\n     int             filename_count, i;\n-#if !(defined(WIN32) || defined(cygwin))\n-    char           *token;\n-    char space;\n-    char newline;\n-    struct stat     dir_stat, idx_stat;\n-    char            tmpstr[300];\n-    char            tmpstr1[300];\n-#endif\n \n     DEBUGMSGTL((\"parse-mibs\", \"Scanning directory %s\\n\", dirname));\n-#if !(defined(WIN32) || defined(cygwin))\n-    token = netsnmp_mibindex_lookup( dirname );\n-    if (token && stat(token, &idx_stat) == 0 && stat(dirname, &dir_stat) == 0) {\n-        if (dir_stat.st_mtime < idx_stat.st_mtime) {\n-            DEBUGMSGTL((\"parse-mibs\", \"The index is good\\n\"));\n-            if ((ip = fopen(token, \"r\")) != NULL) {\n-                fgets(tmpstr, sizeof(tmpstr), ip); /* Skip dir line */\n-                while (fscanf(ip, \"%127s%c%299[^\\n]%c\", token, &space, tmpstr,\n-\t\t    &newline) == 4) {\n-\n-\t\t    /*\n-\t\t     * If an overflow of the token or tmpstr buffers has been\n-\t\t     * found log a message and break out of the while loop,\n-\t\t     * thus the rest of the file tokens will be ignored.\n-\t\t     */\n-\t\t    if (space != ' ' || newline != '\\n') {\n-\t\t\tsnmp_log(LOG_ERR,\n-\t\t\t    \"add_mibdir: strings scanned in from %s/%s \" \\\n-\t\t\t    \"are too large.  count = %d\\n \", dirname,\n-\t\t\t    \".index\", count);\n-\t\t\t    break;\n-\t\t    }\n-\t\t   \n-\t\t    snprintf(tmpstr1, sizeof(tmpstr1), \"%s/%s\", dirname, tmpstr);\n-                    tmpstr1[ sizeof(tmpstr1)-1 ] = 0;\n-                    new_module(token, tmpstr1);\n-                    count++;\n-                }\n-                fclose(ip);\n-                return count;\n-            } else\n-                DEBUGMSGTL((\"parse-mibs\", \"Can't read index\\n\"));\n-        } else\n-            DEBUGMSGTL((\"parse-mibs\", \"Index outdated\\n\"));\n-    } else\n-        DEBUGMSGTL((\"parse-mibs\", \"No index\\n\"));\n-#endif\n \n     filename_count = scan_directory(&filenames, dirname);\n \n     if (filename_count >= 0) {\n-        ip = netsnmp_mibindex_new(dirname);\n         for (i = 0; i < filename_count; i++) {\n-            if (add_mibfile(filenames[i], strrchr(filenames[i], '/'), ip) == 0)\n+            if (add_mibfile(filenames[i], strrchr(filenames[i], '/')) == 0)\n                 count++;\n \t    free(filenames[i]);\n         }\n         File = oldFile;\n-        if (ip)\n-            fclose(ip);\n         free(filenames);\n         return (count);\n     }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "1c6e66b3122b7fd878d17f40664adf831d1a2c7a",
            "date": "2024-12-18T05:40:40Z",
            "author_login": "orgads"
          },
          {
            "sha": "d17282ed842364d83be83d1a45ad95dd986cdb0a",
            "date": "2024-12-17T10:03:57Z",
            "author_login": "orgads"
          },
          {
            "sha": "59c0c1a2b8787fbfa0975549f41e64d31c5c2b60",
            "date": "2024-12-17T20:36:35Z",
            "author_login": "bvanassche"
          },
          {
            "sha": "75829eb857f2468001050fda26af843bcb9475db",
            "date": "2024-12-17T18:59:59Z",
            "author_login": "orgads"
          },
          {
            "sha": "46980afe4a4b5ce9820bd4419064d18e28fe215b",
            "date": "2024-12-11T15:56:25Z",
            "author_login": "bvanassche"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.8,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-59",
    "description": "Net-SNMP through 5.7.3 allows Escalation of Privileges because of UNIX symbolic link (symlink) following.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-08-20T01:17:13.837",
    "last_modified": "2024-11-21T05:06:19.790",
    "fix_date": "2019-05-22T07:56:21Z"
  },
  "references": [
    {
      "url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=966599",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/net-snmp/net-snmp/issues/145",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202008-12",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20200904-0001/",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://usn.ubuntu.com/4471-1/",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=966599",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/net-snmp/net-snmp/issues/145",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202008-12",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20200904-0001/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://usn.ubuntu.com/4471-1/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:03.800933",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "net-snmp",
    "owner": "net-snmp",
    "created_at": "2018-04-09T19:19:27Z",
    "updated_at": "2025-01-13T17:42:11Z",
    "pushed_at": "2024-12-20T00:11:20Z",
    "size": 75523,
    "stars": 352,
    "forks": 224,
    "open_issues": 310,
    "watchers": 352,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 15335594,
      "Perl": 796786,
      "Shell": 669123,
      "M4": 216800,
      "Makefile": 96403,
      "XS": 64753,
      "Python": 32626,
      "Batchfile": 13387,
      "Mathematica": 7281,
      "OpenEdge ABL": 7281,
      "C++": 7003
    },
    "commit_activity": {
      "total_commits_last_year": 155,
      "avg_commits_per_week": 2.980769230769231,
      "days_active_last_year": 64
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T12:54:50.687765"
  }
}