{
  "cve_id": "CVE-2020-15945",
  "github_data": {
    "repository": "lua/lua",
    "fix_commit": "a2195644d89812e5b157ce7bac35543e06db05e3",
    "related_commits": [
      "a2195644d89812e5b157ce7bac35543e06db05e3",
      "a2195644d89812e5b157ce7bac35543e06db05e3"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "a2195644d89812e5b157ce7bac35543e06db05e3",
      "commit_date": "2020-07-17T14:01:05Z",
      "author": {
        "login": "roberto-ieru",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fixed bug: invalid 'oldpc' when returning to a function",
        "length": 491,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 57,
        "additions": 36,
        "deletions": 21
      },
      "files": [
        {
          "filename": "ldebug.c",
          "status": "modified",
          "additions": 25,
          "deletions": 16,
          "patch": "@@ -33,10 +33,8 @@\n \n #define noLuaClosure(f)\t\t((f) == NULL || (f)->c.tt == LUA_VCCL)\n \n-\n-/* Active Lua function (given call info) */\n-#define ci_func(ci)\t\t(clLvalue(s2v((ci)->func)))\n-\n+/* inverse of 'pcRel' */\n+#define invpcRel(pc, p)\t\t((p)->code + (pc) + 1)\n \n static const char *funcnamefromcode (lua_State *L, CallInfo *ci,\n                                     const char **name);\n@@ -127,20 +125,18 @@ static void settraps (CallInfo *ci) {\n /*\n ** This function can be called during a signal, under \"reasonable\"\n ** assumptions.\n-** Fields 'oldpc', 'basehookcount', and 'hookcount' (set by\n-** 'resethookcount') are for debug only, and it is no problem if they\n-** get arbitrary values (causes at most one wrong hook call). 'hookmask'\n-** is an atomic value. We assume that pointers are atomic too (e.g., gcc\n-** ensures that for all platforms where it runs). Moreover, 'hook' is\n-** always checked before being called (see 'luaD_hook').\n+** Fields 'basehookcount' and 'hookcount' (set by 'resethookcount')\n+** are for debug only, and it is no problem if they get arbitrary\n+** values (causes at most one wrong hook call). 'hookmask' is an atomic\n+** value. We assume that pointers are atomic too (e.g., gcc ensures that\n+** for all platforms where it runs). Moreover, 'hook' is always checked\n+** before being called (see 'luaD_hook').\n */\n LUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {\n   if (func == NULL || mask == 0) {  /* turn off hooks? */\n     mask = 0;\n     func = NULL;\n   }\n-  if (isLua(L->ci))\n-    L->oldpc = L->ci->u.l.savedpc;\n   L->hook = func;\n   L->basehookcount = count;\n   resethookcount(L);\n@@ -795,10 +791,24 @@ static int changedline (const Proto *p, int oldpc, int newpc) {\n }\n \n \n+/*\n+** Traces the execution of a Lua function. Called before the execution\n+** of each opcode, when debug is on. 'L->oldpc' stores the last\n+** instruction traced, to detect line changes. When entering a new\n+** function, 'npci' will be zero and will test as a new line without\n+** the need for 'oldpc'; so, 'oldpc' does not need to be initialized\n+** before. Some exceptional conditions may return to a function without\n+** updating 'oldpc'. In that case, 'oldpc' may be invalid; if so, it is\n+** reset to zero.  (A wrong but valid 'oldpc' at most causes an extra\n+** call to a line hook.)\n+*/\n int luaG_traceexec (lua_State *L, const Instruction *pc) {\n   CallInfo *ci = L->ci;\n   lu_byte mask = L->hookmask;\n+  const Proto *p = ci_func(ci)->p;\n   int counthook;\n+  /* 'L->oldpc' may be invalid; reset it in this case */\n+  int oldpc = (L->oldpc < p->sizecode) ? L->oldpc : 0;\n   if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  /* no hooks? */\n     ci->u.l.trap = 0;  /* don't need to stop again */\n     return 0;  /* turn off 'trap' */\n@@ -819,15 +829,14 @@ int luaG_traceexec (lua_State *L, const Instruction *pc) {\n   if (counthook)\n     luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  /* call count hook */\n   if (mask & LUA_MASKLINE) {\n-    const Proto *p = ci_func(ci)->p;\n     int npci = pcRel(pc, p);\n     if (npci == 0 ||  /* call linehook when enter a new function, */\n-        pc <= L->oldpc ||  /* when jump back (loop), or when */\n-        changedline(p, pcRel(L->oldpc, p), npci)) {  /* enter new line */\n+        pc <= invpcRel(oldpc, p) ||  /* when jump back (loop), or when */\n+        changedline(p, oldpc, npci)) {  /* enter new line */\n       int newline = luaG_getfuncline(p, npci);\n       luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  /* call line hook */\n     }\n-    L->oldpc = pc;  /* 'pc' of last call to line hook */\n+    L->oldpc = npci;  /* 'pc' of last call to line hook */\n   }\n   if (L->status == LUA_YIELD) {  /* did hook yield? */\n     if (counthook)"
        },
        {
          "filename": "ldebug.h",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -13,6 +13,11 @@\n \n #define pcRel(pc, p)\t(cast_int((pc) - (p)->code) - 1)\n \n+\n+/* Active Lua function (given call info) */\n+#define ci_func(ci)\t\t(clLvalue(s2v((ci)->func)))\n+\n+\n #define resethookcount(L)\t(L->hookcount = L->basehookcount)\n \n /*"
        },
        {
          "filename": "ldo.c",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -327,7 +327,7 @@ static StkId rethook (lua_State *L, CallInfo *ci, StkId firstres, int nres) {\n   ptrdiff_t oldtop = savestack(L, L->top);  /* hook may change top */\n   int delta = 0;\n   if (isLuacode(ci)) {\n-    Proto *p = clLvalue(s2v(ci->func))->p;\n+    Proto *p = ci_func(ci)->p;\n     if (p->is_vararg)\n       delta = ci->u.l.nextraargs + p->numparams + 1;\n     if (L->top < ci->top)\n@@ -340,8 +340,8 @@ static StkId rethook (lua_State *L, CallInfo *ci, StkId firstres, int nres) {\n     luaD_hook(L, LUA_HOOKRET, -1, ftransfer, nres);  /* call it */\n     ci->func -= delta;\n   }\n-  if (isLua(ci->previous))\n-    L->oldpc = ci->previous->u.l.savedpc;  /* update 'oldpc' */\n+  if (isLua(ci = ci->previous))\n+    L->oldpc = pcRel(ci->u.l.savedpc, ci_func(ci)->p);  /* update 'oldpc' */\n   return restorestack(L, oldtop);\n }\n "
        },
        {
          "filename": "lstate.c",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -301,6 +301,7 @@ static void preinit_thread (lua_State *L, global_State *g) {\n   L->openupval = NULL;\n   L->status = LUA_OK;\n   L->errfunc = 0;\n+  L->oldpc = 0;\n }\n \n "
        },
        {
          "filename": "lstate.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -286,7 +286,6 @@ struct lua_State {\n   StkId top;  /* first free slot in the stack */\n   global_State *l_G;\n   CallInfo *ci;  /* call info for current function */\n-  const Instruction *oldpc;  /* last pc traced */\n   StkId stack_last;  /* last free slot in the stack */\n   StkId stack;  /* stack base */\n   UpVal *openupval;  /* list of open upvalues in this stack */\n@@ -297,6 +296,7 @@ struct lua_State {\n   volatile lua_Hook hook;\n   ptrdiff_t errfunc;  /* current error handling function (stack index) */\n   l_uint32 nCcalls;  /* number of allowed nested C calls - 'nci' */\n+  int oldpc;  /* last pc traced */\n   int stacksize;\n   int basehookcount;\n   int hookcount;"
        },
        {
          "filename": "lvm.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1794,7 +1794,7 @@ void luaV_execute (lua_State *L, CallInfo *ci) {\n         ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));\n         if (trap) {\n           luaD_hookcall(L, ci);\n-          L->oldpc = pc + 1;  /* next opcode will be seen as a \"new\" line */\n+          L->oldpc = 1;  /* next opcode will be seen as a \"new\" line */\n         }\n         updatebase(ci);  /* function has new base after adjustment */\n         vmbreak;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "3cdd49c94a8feed94853ba3a6adaa556fb34fd8d",
            "date": "2025-01-14T19:24:46Z",
            "author_login": "roberto-ieru"
          },
          {
            "sha": "10e931da82268a9d190c17a9bdb9b1a4b48c2947",
            "date": "2025-01-13T14:23:07Z",
            "author_login": "roberto-ieru"
          },
          {
            "sha": "4b107a87760ee5f85185a904c9088ca476b94be5",
            "date": "2025-01-10T18:27:17Z",
            "author_login": "roberto-ieru"
          },
          {
            "sha": "429761d7d29226dd0c220de9fdc7c28ea54d95c0",
            "date": "2025-01-10T18:14:01Z",
            "author_login": "roberto-ieru"
          },
          {
            "sha": "915c29f8bd0d4b0435a4b51a6c7913f5e170d09e",
            "date": "2025-01-10T18:11:54Z",
            "author_login": "roberto-ieru"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": null,
    "description": "Lua through 5.4.0 has a segmentation fault in changedline in ldebug.c (e.g., when called by luaG_traceexec) because it incorrectly expects that an oldpc value is always updated upon a return of the flow of control to a function.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-07-24T21:15:34.553",
    "last_modified": "2024-11-21T05:06:30.630",
    "fix_date": "2020-07-17T14:01:05Z"
  },
  "references": [
    {
      "url": "http://lua-users.org/lists/lua-l/2020-07/msg00123.html",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/lua/lua/commit/a2195644d89812e5b157ce7bac35543e06db05e3",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lua-users.org/lists/lua-l/2020-07/msg00123.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/lua/lua/commit/a2195644d89812e5b157ce7bac35543e06db05e3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:01.377202",
    "processing_status": "enhanced"
  }
}