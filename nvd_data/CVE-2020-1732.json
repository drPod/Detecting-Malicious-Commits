{
  "cve_id": "CVE-2020-1732",
  "github_data": {
    "repository": "wildfly-security/soteria",
    "fix_commit": "c2479f8c39d7d661341fdcaff7f5e97c5eea1a54",
    "related_commits": [
      "c2479f8c39d7d661341fdcaff7f5e97c5eea1a54",
      "c2479f8c39d7d661341fdcaff7f5e97c5eea1a54"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "c2479f8c39d7d661341fdcaff7f5e97c5eea1a54",
      "commit_date": "2020-02-14T16:57:21Z",
      "author": {
        "login": "fjuma",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #1 from darranl/CVE-2020-1732",
        "length": 142,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 144,
        "additions": 75,
        "deletions": 69
      },
      "files": [
        {
          "filename": "impl/src/main/java/org/glassfish/soteria/mechanisms/jaspic/DefaultAuthConfigProvider.java",
          "status": "modified",
          "additions": 8,
          "deletions": 7,
          "patch": "@@ -17,6 +17,7 @@\n package org.glassfish.soteria.mechanisms.jaspic;\n \n import java.util.Map;\n+import java.util.function.Supplier;\n \n import javax.security.auth.callback.CallbackHandler;\n import javax.security.auth.message.AuthException;\n@@ -30,23 +31,23 @@\n /**\n  * This class functions as a kind of factory-factory for {@link ServerAuthConfig} instances, which are by themselves factories\n  * for {@link ServerAuthContext} instances, which are delegates for the actual {@link ServerAuthModule} (SAM) that we're after.\n- * \n+ *\n  * @author Arjan Tijms\n  */\n public class DefaultAuthConfigProvider implements AuthConfigProvider {\n \n     private static final String CALLBACK_HANDLER_PROPERTY_NAME = \"authconfigprovider.client.callbackhandler\";\n \n     private Map<String, String> providerProperties;\n-    private ServerAuthModule serverAuthModule;\n+    private Supplier<ServerAuthModule> serverAuthModuleSupplier;\n \n-    public DefaultAuthConfigProvider(ServerAuthModule serverAuthModule) {\n-        this.serverAuthModule = serverAuthModule;\n+    public DefaultAuthConfigProvider(Supplier<ServerAuthModule> serverAuthModuleSupplier) {\n+        this.serverAuthModuleSupplier = serverAuthModuleSupplier;\n     }\n \n     /**\n      * Constructor with signature and implementation that's required by API.\n-     * \n+     *\n      * @param properties provider properties\n      * @param factory the auth config factory\n      */\n@@ -72,7 +73,7 @@ public DefaultAuthConfigProvider(Map<String, String> properties, AuthConfigFacto\n     public ServerAuthConfig getServerAuthConfig(String layer, String appContext, CallbackHandler handler) throws AuthException,\n         SecurityException {\n         return new DefaultServerAuthConfig(layer, appContext, handler == null ? createDefaultCallbackHandler() : handler,\n-            providerProperties, serverAuthModule);\n+            providerProperties, serverAuthModuleSupplier);\n     }\n \n     @Override\n@@ -89,7 +90,7 @@ public void refresh() {\n      * Creates a default callback handler via the system property \"authconfigprovider.client.callbackhandler\", as seemingly\n      * required by the API (API uses wording \"may\" create default handler). TODO: Isn't\n      * \"authconfigprovider.client.callbackhandler\" JBoss specific?\n-     * \n+     *\n      * @return\n      * @throws AuthException\n      */"
        },
        {
          "filename": "impl/src/main/java/org/glassfish/soteria/mechanisms/jaspic/DefaultServerAuthConfig.java",
          "status": "modified",
          "additions": 6,
          "deletions": 5,
          "patch": "@@ -17,6 +17,7 @@\n package org.glassfish.soteria.mechanisms.jaspic;\n \n import java.util.Map;\n+import java.util.function.Supplier;\n \n import javax.security.auth.Subject;\n import javax.security.auth.callback.CallbackHandler;\n@@ -29,7 +30,7 @@\n /**\n  * This class functions as a kind of factory for {@link ServerAuthContext} instances, which are delegates for the actual\n  * {@link ServerAuthModule} (SAM) that we're after.\n- * \n+ *\n  * @author Arjan Tijms\n  */\n public class DefaultServerAuthConfig implements ServerAuthConfig {\n@@ -38,21 +39,21 @@ public class DefaultServerAuthConfig implements ServerAuthConfig {\n     private String appContext;\n     private CallbackHandler handler;\n     private Map<String, String> providerProperties;\n-    private ServerAuthModule serverAuthModule;\n+    private Supplier<ServerAuthModule> serverAuthModuleSupplier;\n \n     public DefaultServerAuthConfig(String layer, String appContext, CallbackHandler handler,\n-        Map<String, String> providerProperties, ServerAuthModule serverAuthModule) {\n+        Map<String, String> providerProperties, Supplier<ServerAuthModule> serverAuthModuleSupplier) {\n         this.layer = layer;\n         this.appContext = appContext;\n         this.handler = handler;\n         this.providerProperties = providerProperties;\n-        this.serverAuthModule = serverAuthModule;\n+        this.serverAuthModuleSupplier = serverAuthModuleSupplier;\n     }\n \n     @Override\n     public ServerAuthContext getAuthContext(String authContextID, Subject serviceSubject,\n         @SuppressWarnings(\"rawtypes\") Map properties) throws AuthException {\n-        return new DefaultServerAuthContext(handler, serverAuthModule);\n+        return new DefaultServerAuthContext(handler, serverAuthModuleSupplier);\n     }\n \n     // ### The methods below mostly just return what has been passed into the"
        },
        {
          "filename": "impl/src/main/java/org/glassfish/soteria/mechanisms/jaspic/DefaultServerAuthContext.java",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -17,6 +17,7 @@\n package org.glassfish.soteria.mechanisms.jaspic;\n \n import java.util.Collections;\n+import java.util.function.Supplier;\n \n import javax.security.auth.Subject;\n import javax.security.auth.callback.CallbackHandler;\n@@ -34,15 +35,15 @@\n  * <p>\n  * Since this simple example only has a single SAM, we delegate directly to that one. Note that this {@link ServerAuthContext}\n  * and the {@link ServerAuthModule} (SAM) share a common base interface: {@link ServerAuth}.\n- * \n+ *\n  * @author Arjan Tijms\n  */\n public class DefaultServerAuthContext implements ServerAuthContext {\n \n     private final ServerAuthModule serverAuthModule;\n \n-    public DefaultServerAuthContext(CallbackHandler handler, ServerAuthModule serverAuthModule) throws AuthException {\n-        this.serverAuthModule = serverAuthModule;\n+    public DefaultServerAuthContext(CallbackHandler handler, Supplier<ServerAuthModule> serverAuthModuleSupplier) throws AuthException {\n+        this.serverAuthModule = serverAuthModuleSupplier.get();\n         serverAuthModule.initialize(null, null, handler, Collections.<String, String> emptyMap());\n     }\n "
        },
        {
          "filename": "impl/src/main/java/org/glassfish/soteria/mechanisms/jaspic/Jaspic.java",
          "status": "modified",
          "additions": 38,
          "deletions": 35,
          "patch": "@@ -25,6 +25,7 @@\n import java.security.PrivilegedAction;\n import java.util.List;\n import java.util.Set;\n+import java.util.function.Supplier;\n \n import javax.security.enterprise.AuthenticationStatus;\n import javax.security.auth.Subject;\n@@ -43,42 +44,44 @@\n import javax.servlet.http.HttpServletRequest;\n import javax.servlet.http.HttpServletResponse;\n \n+import org.glassfish.soteria.cdi.spi.CDIPerRequestInitializer;\n+\n /**\n  * A set of utility methods for using the JASPIC API\n- * \n+ *\n  * @author Arjan Tijms\n  *\n  */\n public final class Jaspic {\n-\t\n+\n \tpublic static final String IS_AUTHENTICATION = \"org.glassfish.soteria.security.message.request.authentication\";\n \tpublic static final String IS_AUTHENTICATION_FROM_FILTER = \"org.glassfish.soteria.security.message.request.authenticationFromFilter\";\n \tpublic static final String IS_SECURE_RESPONSE = \"org.glassfish.soteria.security.message.request.secureResponse\";\n \tpublic static final String IS_REFRESH = \"org.glassfish.soteria.security.message.request.isRefresh\";\n \tpublic static final String DID_AUTHENTICATION = \"org.glassfish.soteria.security.message.request.didAuthentication\";\n-\t\n+\n \tpublic static final String AUTH_PARAMS = \"org.glassfish.soteria.security.message.request.authParams\";\n-\t\n+\n \tpublic static final String LOGGEDIN_USERNAME = \"org.glassfish.soteria.security.message.loggedin.username\";\n \tpublic static final String LOGGEDIN_ROLES = \"org.glassfish.soteria.security.message.loggedin.roles\";\n \tpublic static final String LAST_AUTH_STATUS = \"org.glassfish.soteria.security.message.authStatus\";\n-\t\n+\n \tpublic static final String CONTEXT_REGISTRATION_ID = \"org.glassfish.soteria.security.message.registrationId\";\n-\t\n+\n \t// Key in the MessageInfo Map that when present AND set to true indicated a protected resource is being accessed.\n \t// When the resource is not protected, GlassFish omits the key altogether. WebSphere does insert the key and sets\n \t// it to false.\n \tprivate static final String IS_MANDATORY = \"javax.security.auth.message.MessagePolicy.isMandatory\";\n \tprivate static final String REGISTER_SESSION = \"javax.servlet.http.registerSession\";\n \n \tprivate Jaspic() {}\n-\t\n+\n \tpublic static boolean authenticate(HttpServletRequest request, HttpServletResponse response, AuthenticationParameters authParameters) {\n \t\ttry {\n \t\t    // JASPIC 1.1 does not have any way to distinguish between a\n \t\t    // SAM called at start of a request or following request#authenticate.\n \t\t    // See https://java.net/jira/browse/JASPIC_SPEC-5\n-\t\t    \n+\n \t\t    // We now add this as a request attribute instead, but should better\n \t\t    // be the MessageInfo map\n \t\t\trequest.setAttribute(IS_AUTHENTICATION, true);\n@@ -101,10 +104,10 @@ public static AuthenticationParameters getAuthParameters(HttpServletRequest requ\n \t\tif (authParameters == null) {\n \t\t\tauthParameters = new AuthenticationParameters();\n \t\t}\n-\t\t\n+\n \t\treturn authParameters;\n \t}\n-\t\n+\n \tpublic static void logout(HttpServletRequest request, HttpServletResponse response) {\n \t\ttry {\n \t\t\trequest.logout();\n@@ -131,21 +134,21 @@ public Void run() {\n \tpublic static boolean isRegisterSession(MessageInfo messageInfo) {\n \t\treturn Boolean.valueOf((String)messageInfo.getMap().get(REGISTER_SESSION));\n \t}\n-\t\n+\n \tpublic static boolean isProtectedResource(MessageInfo messageInfo) {\n \t\treturn Boolean.valueOf((String) messageInfo.getMap().get(IS_MANDATORY));\n \t}\n-\t\n+\n \t@SuppressWarnings(\"unchecked\")\n \tpublic static void setRegisterSession(MessageInfo messageInfo, String username, Set<String> roles) {\n \t\tmessageInfo.getMap().put(\"javax.servlet.http.registerSession\", TRUE.toString());\n-\t\t\n+\n \t\tHttpServletRequest request = (HttpServletRequest) messageInfo.getRequestMessage();\n \t\trequest.setAttribute(LOGGEDIN_USERNAME, username);\n \t\t// TODO: check for existing roles and add\n \t\trequest.setAttribute(LOGGEDIN_ROLES, roles);\n \t}\n-\t\n+\n \tpublic static boolean isAuthenticationRequest(HttpServletRequest request) {\n \t\treturn TRUE.equals(request.getAttribute(IS_AUTHENTICATION));\n \t}\n@@ -202,70 +205,70 @@ public static AuthStatus fromAuthenticationStatus(AuthenticationStatus authentic\n \t            throw new IllegalStateException(\"Unhandled status:\" + authenticationStatus.name());\n \t    }\n \t}\n-\t\n+\n \t/**\n \t * Should be called when the callback handler is used with the intention that an actual\n \t * user is going to be authenticated (as opposed to using the handler for the \"do nothing\" protocol\n \t * which uses the unauthenticated identity).\n-\t * \n+\t *\n \t * @param request The involved HTTP servlet request.\n-\t * \n+\t *\n \t */\n \tpublic static void setDidAuthentication(HttpServletRequest request) {\n \t\trequest.setAttribute(DID_AUTHENTICATION, TRUE);\n \t}\n-\t\n+\n \t/**\n \t * Gets the app context ID from the servlet context.\n-\t * \n+\t *\n \t * <p>\n \t * The app context ID is the ID that JASPIC associates with the given application.\n \t * In this case that given application is the web application corresponding to the\n \t * ServletContext.\n-\t * \n+\t *\n \t * @param context the servlet context for which to obtain the JASPIC app context ID\n \t * @return the app context ID for the web application corresponding to the given context\n \t */\n \tpublic static String getAppContextID(ServletContext context) {\n \t\treturn context.getVirtualServerName() + \" \" + context.getContextPath();\n \t}\n-\t\n+\n \t/**\n \t * Registers a server auth module as the one and only module for the application corresponding to\n \t * the given servlet context.\n-\t * \n+\t *\n \t * <p>\n \t * This will override any other modules that have already been registered, either via proprietary\n \t * means or using the standard API.\n-\t * \n-\t * @param serverAuthModule the server auth module to be registered\n+\t *\n+\t * @param cdiPerRequestInitializer A {@link CDIPerRequestInitializer} to pass to the {@link ServerAuthModule}\n \t * @param servletContext the context of the app for which the module is registered\n \t * @return A String identifier assigned by an underlying factory corresponding to an underlying factory-factory-factory registration\n \t */\n-\tpublic static String registerServerAuthModule(ServerAuthModule serverAuthModule, ServletContext servletContext) {\n-\t\t\n+\tpublic static String registerServerAuthModule(CDIPerRequestInitializer cdiPerRequestInitializer, ServletContext servletContext) {\n+\n \t    // Register the factory-factory-factory for the SAM\n \t    String registrationId = AccessController.doPrivileged(new PrivilegedAction<String>() {\n \t        public String run() {\n \t            return AuthConfigFactory.getFactory().registerConfigProvider(\n-\t                    new DefaultAuthConfigProvider(serverAuthModule),\n-\t                    \"HttpServlet\", \n-\t                    getAppContextID(servletContext), \n+\t                    new DefaultAuthConfigProvider(() -> new HttpBridgeServerAuthModule(cdiPerRequestInitializer)),\n+\t                    \"HttpServlet\",\n+\t                    getAppContextID(servletContext),\n \t                    \"Default single SAM authentication config provider\");\n \t        }\n \t    });\n-\t\t\n+\n \t\t// Remember the registration ID returned by the factory, so we can unregister the JASPIC module when the web module\n \t\t// is undeployed. JASPIC being the low level API that it is won't do this automatically.\n \t\tservletContext.setAttribute(CONTEXT_REGISTRATION_ID, registrationId);\n-\t\t\n+\n \t\treturn registrationId;\n \t}\n-\t\n+\n \t/**\n \t * Deregisters the server auth module (and encompassing wrappers/factories) that was previously registered via a call\n \t * to registerServerAuthModule.\n-\t * \n+\t *\n \t * @param servletContext the context of the app for which the module is deregistered\n \t */\n \tpublic static void deregisterServerAuthModule(ServletContext servletContext) {\n@@ -278,6 +281,6 @@ public Boolean run() {\n \t\t\t});\n \t\t}\n \t}\n-\t\n-\t\n+\n+\n }"
        },
        {
          "filename": "impl/src/main/java/org/glassfish/soteria/servlet/SamRegistrationInstaller.java",
          "status": "modified",
          "additions": 19,
          "deletions": 19,
          "patch": "@@ -39,80 +39,80 @@\n import org.glassfish.soteria.mechanisms.jaspic.Jaspic;\n \n /**\n- * If an HttpAuthenticationMechanism implementation has been found on the classpath, this \n+ * If an HttpAuthenticationMechanism implementation has been found on the classpath, this\n  * initializer installs a bridge SAM that delegates the validateRequest, secureResponse and\n  * cleanSubject methods from the SAM to the HttpAuthenticationMechanism.\n- * \n+ *\n  * <p>\n  * The bridge SAM uses <code>CDI.current()</code> to obtain the HttpAuthenticationMechanism, therefore\n  * fully enabling CDI in the implementation of that interface.\n- * \n+ *\n  * @author Arjan Tijms\n  *\n  */\n public class SamRegistrationInstaller implements ServletContainerInitializer, ServletContextListener {\n-    \n+\n     private static final Logger logger =  Logger.getLogger(SamRegistrationInstaller.class.getName());\n \n     @Override\n     public void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException {\n \n         // Obtain a reference to the CdiExtension that was used to see if\n         // there's an enabled bean\n-        \n+\n         CDI<Object> cdi;\n         try {\n             cdi = CDI.current();\n-            \n+\n             if (logger.isLoggable(INFO)) {\n                 String version = getClass().getPackage().getImplementationVersion();\n                 logger.log(INFO, \"Initializing Soteria {0} for context ''{1}''\", new Object[]{version, ctx.getContextPath()});\n             }\n-            \n+\n         } catch (IllegalStateException e) {\n-            // On GlassFish 4.1.1/Payara 4.1.1.161 CDI is not initialized (org.jboss.weld.Container#initialize is not called), \n+            // On GlassFish 4.1.1/Payara 4.1.1.161 CDI is not initialized (org.jboss.weld.Container#initialize is not called),\n             // and calling CDI.current() will throw an exception. It's no use to continue then.\n             // TODO: Do we need to find out *why* the default module does not have CDI initialized?\n             logger.log(FINEST, \"CDI not available for app context id: \" + Jaspic.getAppContextID(ctx), e);\n-            \n+\n             return;\n         }\n-        \n+\n         CdiExtension cdiExtension = cdi.select(CdiExtension.class).get();\n \n         if (cdiExtension.isHttpAuthenticationMechanismFound()) {\n \n             // A SAM must be registered at this point, since the programmatically added\n             // Listener is for some reason restricted (not allow) from calling\n             // getVirtualServerName. At this point we're still allowed to call this.\n-            \n+\n             // TODO: Ask the Servlet EG to address this? Is there any ground for this restriction???\n-            \n+\n             CDIPerRequestInitializer cdiPerRequestInitializer = null;\n-            \n+\n             if (!isEmpty(System.getProperty(\"wlp.server.name\"))) {\n                 // Hardcode server check for now. TODO: design/implement proper service loader/SPI for this\n                 cdiPerRequestInitializer = new LibertyCDIPerRequestInitializer();\n                 logger.log(INFO, \"Running on Liberty - installing CDI request scope activator\");\n             }\n-            \n-            registerServerAuthModule(new HttpBridgeServerAuthModule(cdiPerRequestInitializer), ctx);\n-          \n+\n+            registerServerAuthModule(cdiPerRequestInitializer, ctx);\n+\n             // Add a listener so we can process the context destroyed event, which is needed\n             // to de-register the SAM correctly.\n             ctx.addListener(this);\n         }\n \n     }\n-    \n+\n     @Override\n     public void contextInitialized(ServletContextEvent sce) {\n        // noop\n     }\n-    \n+\n     @Override\n     public void contextDestroyed(ServletContextEvent sce) {\n         deregisterServerAuthModule(sce.getServletContext());\n     }\n-    \n+\n }"
        }
      ],
      "file_patterns": {
        "security_files": 3,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 9
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "45da9c735e9fbd9131c7e43daae09359b2cb0215",
            "date": "2022-12-02T14:28:39Z",
            "author_login": "Skyllarr"
          },
          {
            "sha": "82d9b7a10ac0a919223dc9ca86edc7a6a9429b60",
            "date": "2022-12-02T14:18:48Z",
            "author_login": "Skyllarr"
          },
          {
            "sha": "94d8d6e7baf715a1bac550bbb2807bbfc4c5a192",
            "date": "2022-12-01T11:35:21Z",
            "author_login": "Skyllarr"
          },
          {
            "sha": "c1c10def64aac6226ebb05bffd4ee9ac2a36531e",
            "date": "2022-11-17T15:07:13Z",
            "author_login": "Skyllarr"
          },
          {
            "sha": "37eb07462f09bdb62ee53cd1761951b64cff5e9f",
            "date": "2020-02-14T17:02:45Z",
            "author_login": "darranl"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.2,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:N",
    "cwe_id": "CWE-284",
    "description": "A flaw was found in Soteria before 1.0.1, in a way that multiple requests occurring concurrently causing security identity corruption across concurrent threads when using EE Security with WildFly Elytron which can lead to the possibility of being handled using the identity from another request.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-05-04T17:15:12.357",
    "last_modified": "2024-11-21T05:11:15.877",
    "fix_date": "2020-02-14T16:57:21Z"
  },
  "references": [
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2020-1732",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/wildfly-security/soteria/commit/c2479f8c39d7d661341fdcaff7f5e97c5eea1a54",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2020-1732",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/wildfly-security/soteria/commit/c2479f8c39d7d661341fdcaff7f5e97c5eea1a54",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:44.972402",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "soteria",
    "owner": "wildfly-security",
    "created_at": "2020-02-14T15:43:06Z",
    "updated_at": "2022-12-01T11:35:26Z",
    "pushed_at": "2022-12-02T14:34:04Z",
    "size": 259,
    "stars": 0,
    "forks": 2,
    "open_issues": 0,
    "watchers": 0,
    "has_security_policy": false,
    "default_branch": "1.0.1-jbossorg-x",
    "protected_branches": [],
    "languages": {
      "Java": 590771,
      "HTML": 1571
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T07:40:13.065958"
  }
}