{
  "cve_id": "CVE-2020-24371",
  "github_data": {
    "repository": "lua/lua",
    "fix_commit": "a6da1472c0c5e05ff249325f979531ad51533110",
    "related_commits": [
      "a6da1472c0c5e05ff249325f979531ad51533110",
      "a6da1472c0c5e05ff249325f979531ad51533110"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "a6da1472c0c5e05ff249325f979531ad51533110",
      "commit_date": "2020-07-27T13:26:20Z",
      "author": {
        "login": "roberto-ieru",
        "type": "User",
        "stats": {
          "total_commits": 5548,
          "average_weekly_commits": 3.372644376899696,
          "total_additions": 217047,
          "total_deletions": 161720,
          "weeks_active": 1125
        }
      },
      "commit_message": {
        "title": "Fixed bug: barriers cannot be active during sweep",
        "length": 317,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 76,
        "additions": 59,
        "deletions": 17
      },
      "files": [
        {
          "filename": "lgc.c",
          "status": "modified",
          "additions": 32,
          "deletions": 16,
          "patch": "@@ -181,14 +181,17 @@ static int iscleared (global_State *g, const GCObject *o) {\n \n \n /*\n-** barrier that moves collector forward, that is, mark the white object\n-** 'v' being pointed by the black object 'o'. (If in sweep phase, clear\n-** the black object to white [sweep it] to avoid other barrier calls for\n-** this same object.) In the generational mode, 'v' must also become\n-** old, if 'o' is old; however, it cannot be changed directly to OLD,\n-** because it may still point to non-old objects. So, it is marked as\n-** OLD0. In the next cycle it will become OLD1, and in the next it\n-** will finally become OLD (regular old).\n+** Barrier that moves collector forward, that is, marks the white object\n+** 'v' being pointed by the black object 'o'.  In the generational\n+** mode, 'v' must also become old, if 'o' is old; however, it cannot\n+** be changed directly to OLD, because it may still point to non-old\n+** objects. So, it is marked as OLD0. In the next cycle it will become\n+** OLD1, and in the next it will finally become OLD (regular old). By\n+** then, any object it points to will also be old.  If called in the\n+** incremental sweep phase, it clears the black object to white (sweep\n+** it) to avoid other barrier calls for this same object. (That cannot\n+** be done is generational mode, as its sweep does not distinguish\n+** whites from deads.)\n */\n void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n   global_State *g = G(L);\n@@ -202,7 +205,8 @@ void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n   }\n   else {  /* sweep phase */\n     lua_assert(issweepphase(g));\n-    makewhite(g, o);  /* mark main obj. as white to avoid other barriers */\n+    if (g->gckind == KGC_INC)  /* incremental mode? */\n+      makewhite(g, o);  /* mark 'o' as white to avoid other barriers */\n   }\n }\n \n@@ -324,10 +328,15 @@ static lu_mem markbeingfnz (global_State *g) {\n \n \n /*\n-** Mark all values stored in marked open upvalues from non-marked threads.\n-** (Values from marked threads were already marked when traversing the\n-** thread.) Remove from the list threads that no longer have upvalues and\n-** not-marked threads.\n+** For each non-marked thread, simulates a barrier between each open\n+** upvalue and its value. (If the thread is collected, the value will be\n+** assigned to the upvalue, but then it can be too late for the barrier\n+** to act. The \"barrier\" does not need to check colors: A non-marked\n+** thread must be young; upvalues cannot be older than their threads; so\n+** any visited upvalue must be young too.) Also removes the thread from\n+** the list, as it was already visited. Removes also threads with no\n+** upvalues, as they have nothing to be checked. (If the thread gets an\n+** upvalue later, it will be linked in the list again.)\n */\n static int remarkupvals (global_State *g) {\n   lua_State *thread;\n@@ -340,9 +349,11 @@ static int remarkupvals (global_State *g) {\n       p = &thread->twups;  /* keep marked thread with upvalues in the list */\n     else {  /* thread is not marked or without upvalues */\n       UpVal *uv;\n+      lua_assert(!isold(thread) || thread->openupval == NULL);\n       *p = thread->twups;  /* remove thread from the list */\n       thread->twups = thread;  /* mark that it is out of list */\n       for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {\n+        lua_assert(getage(uv) <= getage(thread));\n         work++;\n         if (!iswhite(uv))  /* upvalue already visited? */\n           markvalue(g, uv->v);  /* mark its value */\n@@ -995,6 +1006,9 @@ static void sweep2old (lua_State *L, GCObject **p) {\n ** during the sweep. So, any white object must be dead.) For\n ** non-dead objects, advance their ages and clear the color of\n ** new objects. (Old objects keep their colors.)\n+** The ages of G_TOUCHED1 and G_TOUCHED2 objects will advance\n+** in 'correctgraylist'. (That function will also remove objects\n+** turned white here from any gray list.)\n */\n static GCObject **sweepgen (lua_State *L, global_State *g, GCObject **p,\n                             GCObject *limit) {\n@@ -1055,16 +1069,16 @@ static GCObject **correctgraylist (GCObject **p) {\n           lua_assert(isgray(curr));\n           gray2black(curr);  /* make it black, for next barrier */\n           changeage(curr, G_TOUCHED1, G_TOUCHED2);\n-          p = next;  /* go to next element */\n+          p = next;  /* keep it in the list and go to next element */\n         }\n-        else {  /* not touched in this cycle */\n+        else {  /* everything else is removed */\n+          /* white objects are simply removed */\n           if (!iswhite(curr)) {  /* not white? */\n             lua_assert(isold(curr));\n             if (getage(curr) == G_TOUCHED2)  /* advance from G_TOUCHED2... */\n               changeage(curr, G_TOUCHED2, G_OLD);  /* ... to G_OLD */\n             gray2black(curr);  /* make it black */\n           }\n-          /* else, object is white: just remove it from this list */\n           *p = *next;  /* remove 'curr' from gray list */\n         }\n         break;\n@@ -1143,6 +1157,7 @@ static void youngcollection (lua_State *L, global_State *g) {\n   atomic(L);\n \n   /* sweep nursery and get a pointer to its last live element */\n+  g->gcstate = GCSswpallgc;\n   psurvival = sweepgen(L, g, &g->allgc, g->survival);\n   /* sweep 'survival' and 'old' */\n   sweepgen(L, g, psurvival, g->reallyold);\n@@ -1166,6 +1181,7 @@ static void youngcollection (lua_State *L, global_State *g) {\n \n static void atomic2gen (lua_State *L, global_State *g) {\n   /* sweep all elements making them old */\n+  g->gcstate = GCSswpallgc;\n   sweep2old(L, &g->allgc);\n   /* everything alive now is old */\n   g->reallyold = g->old = g->survival = g->allgc;"
        },
        {
          "filename": "testes/gengc.lua",
          "status": "modified",
          "additions": 27,
          "deletions": 1,
          "patch": "@@ -57,13 +57,39 @@ do   -- bug in 5.4.0\n   local obj = {}     -- create a new object\n   collectgarbage(\"step\", 0)   -- make it a survival\n   assert(not T or T.gcage(obj) == \"survival\")\n-  setmetatable(obj, {__gc = gcf, x = \"ok\"})   -- create its metatable\n+  setmetatable(obj, {__gc = gcf, x = \"+\"})   -- create its metatable\n   assert(not T or T.gcage(getmetatable(obj)) == \"new\")\n   obj = nil   -- clear object\n   collectgarbage(\"step\", 0)   -- will call obj's finalizer\n end\n \n \n+do   -- another bug in 5.4.0\n+  local old = {10}\n+  collectgarbage()   -- make 'old' old\n+  local co = coroutine.create(\n+    function ()\n+      local x = nil\n+      local f = function ()\n+                  return x[1]\n+                end\n+      x = coroutine.yield(f)\n+      coroutine.yield()\n+    end\n+  )\n+  local _, f = coroutine.resume(co)   -- create closure over 'x' in coroutine\n+  collectgarbage(\"step\", 0)   -- make upvalue a survival\n+  old[1] = {\"hello\"}    -- 'old' go to grayagain as 'touched1'\n+  coroutine.resume(co, {123})     -- its value will be new\n+  co = nil\n+  collectgarbage(\"step\", 0)   -- hit the barrier\n+  assert(f() == 123 and old[1][1] == \"hello\")\n+  collectgarbage(\"step\", 0)   -- run the collector once more\n+  -- make sure old[1] was not collected\n+  assert(f() == 123 and old[1][1] == \"hello\")\n+end\n+\n+\n if T == nil then\n   (Message or print)('\\n >>> testC not active: \\z\n                              skipping some generational tests <<<\\n')"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "3cdd49c94a8feed94853ba3a6adaa556fb34fd8d",
            "date": "2025-01-14T19:24:46Z",
            "author_login": "roberto-ieru"
          },
          {
            "sha": "10e931da82268a9d190c17a9bdb9b1a4b48c2947",
            "date": "2025-01-13T14:23:07Z",
            "author_login": "roberto-ieru"
          },
          {
            "sha": "4b107a87760ee5f85185a904c9088ca476b94be5",
            "date": "2025-01-10T18:27:17Z",
            "author_login": "roberto-ieru"
          },
          {
            "sha": "429761d7d29226dd0c220de9fdc7c28ea54d95c0",
            "date": "2025-01-10T18:14:01Z",
            "author_login": "roberto-ieru"
          },
          {
            "sha": "915c29f8bd0d4b0435a4b51a6c7913f5e170d09e",
            "date": "2025-01-10T18:11:54Z",
            "author_login": "roberto-ieru"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-763",
    "description": "lgc.c in Lua 5.4.0 mishandles the interaction between barriers and the sweep phase, leading to a memory access violation involving collectgarbage.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-08-17T17:15:13.927",
    "last_modified": "2024-11-21T05:14:41.293",
    "fix_date": "2020-07-27T13:26:20Z"
  },
  "references": [
    {
      "url": "https://github.com/lua/lua/commit/a6da1472c0c5e05ff249325f979531ad51533110",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.lua.org/bugs.html#5.4.0-10",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Patch",
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/lua/lua/commit/a6da1472c0c5e05ff249325f979531ad51533110",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.lua.org/bugs.html#5.4.0-10",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Release Notes",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:03.796518",
    "processing_status": "enhanced"
  }
}