{
  "cve_id": "CVE-2020-25792",
  "github_data": {
    "repository": "bodil/sized-chunks",
    "fix_commit": "3ae48bd463c1af41c24b96b84079946f51f51e3c",
    "related_commits": [
      "3ae48bd463c1af41c24b96b84079946f51f51e3c",
      "3ae48bd463c1af41c24b96b84079946f51f51e3c"
    ],
    "patch_url": "https://github.com/bodil/sized-chunks/commit/3ae48bd463c1af41c24b96b84079946f51f51e3c.patch",
    "fix_commit_details": {
      "sha": "3ae48bd463c1af41c24b96b84079946f51f51e3c",
      "commit_date": "2021-02-12T12:21:25Z",
      "author": {
        "login": "kornelski",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #14 from vorner/inline-array-align",
        "length": 90,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 128,
        "additions": 117,
        "deletions": 11
      },
      "files": [
        {
          "filename": "src/inline_array/mod.rs",
          "status": "modified",
          "additions": 117,
          "deletions": 11,
          "patch": "@@ -11,7 +11,6 @@ use core::cmp::Ordering;\n use core::fmt::{Debug, Error, Formatter};\n use core::hash::{Hash, Hasher};\n use core::iter::FromIterator;\n-use core::marker::PhantomData;\n use core::mem::{self, MaybeUninit};\n use core::ops::{Deref, DerefMut};\n use core::ptr;\n@@ -25,7 +24,7 @@ pub use self::iter::{Drain, Iter};\n /// This works like a vector, but allocated on the stack (and thus marginally\n /// faster than `Vec`), with the allocated space exactly matching the size of\n /// the given type `T`. The vector consists of a `usize` tracking its current\n-/// length, followed by zero or more elements of type `A`. The capacity is thus\n+/// length and zero or more elements of type `A`. The capacity is thus\n /// `( size_of::<T>() - size_of::<usize>() ) / size_of::<A>()`. This could lead\n /// to situations where the capacity is zero, if `size_of::<A>()` is greater\n /// than `size_of::<T>() - size_of::<usize>()`, which is not an error and\n@@ -72,9 +71,37 @@ pub use self::iter::{Drain, Iter};\n ///\n /// Both of these will have the same size, and we can swap the `Inline` case out\n /// with the `Full` case once the `InlineArray` runs out of capacity.\n+#[repr(C)]\n pub struct InlineArray<A, T> {\n+    // Alignment tricks\n+    //\n+    // We need both the usize header and data to be properly aligned in memory. We do a few tricks\n+    // to handle that.\n+    //\n+    // * An alignment is always power of 2. Therefore, with a pair of alignments, one is always\n+    //   a multiple of the other (one way or the other).\n+    // * A struct is aligned to at least the max alignment of each of its fields.\n+    // * A repr(C) struct follows the order of fields and pushes each as close to the previous one\n+    //   as allowed by alignment.\n+    //\n+    // By placing two \"fake\" fields that have 0 size, but an alignment first, we make sure that all\n+    // 3 start at the beginning of the struct and that all of them are aligned to their maximum\n+    // alignment.\n+    //\n+    // Furthermore, because we don't know if usize or A has bigger alignment, we decide on case by\n+    // case basis if the header or the elements go first. By placing the one with higher alignment\n+    // requirements first, we align that one and the other one will be aligned \"automatically\" when\n+    // placed just after it.\n+    //\n+    // To the best of our knowledge, this is all guaranteed by the compiler. But just to make sure,\n+    // we have bunch of asserts in the constructor to check; as these are invariants enforced by\n+    // the compiler, it should be trivial for it to remove the checks so they are for free (if we\n+    // are correct) or will save us (if we are not).\n+    //\n+    // Additionally, the [A; 0] serves as a form of PhantomData.\n+    _header_align: [usize; 0],\n+    _data_align: [A; 0],\n     data: MaybeUninit<T>,\n-    phantom: PhantomData<A>,\n }\n \n const fn capacity(host_size: usize, header_size: usize, element_size: usize) -> usize {\n@@ -89,32 +116,67 @@ impl<A, T> InlineArray<A, T> {\n     const HOST_SIZE: usize = mem::size_of::<T>();\n     const ELEMENT_SIZE: usize = mem::size_of::<A>();\n     const HEADER_SIZE: usize = mem::size_of::<usize>();\n+    // Do we place the header before the elements or the other way around?\n+    const HEADER_FIRST: bool = mem::align_of::<usize>() >= mem::align_of::<A>();\n+    // Note: one of the following is always 0\n+    // How many usizes to skip before the first element?\n+    const ELEMENT_SKIP: usize = Self::HEADER_FIRST as usize;\n+    // How many elements to skip before the header\n+    const HEADER_SKIP: usize = Self::CAPACITY * (1 - Self::ELEMENT_SKIP);\n \n     /// The maximum number of elements the `InlineArray` can hold.\n     pub const CAPACITY: usize = capacity(Self::HOST_SIZE, Self::HEADER_SIZE, Self::ELEMENT_SIZE);\n \n     #[inline]\n     #[must_use]\n     unsafe fn len_const(&self) -> *const usize {\n-        (&self.data) as *const _ as *const usize\n+        let ptr = self\n+            .data\n+            .as_ptr()\n+            .cast::<A>()\n+            .add(Self::HEADER_SKIP)\n+            .cast::<usize>();\n+        debug_assert!(ptr as usize % mem::align_of::<usize>() == 0);\n+        ptr\n     }\n \n     #[inline]\n     #[must_use]\n     pub(crate) unsafe fn len_mut(&mut self) -> *mut usize {\n-        (&mut self.data) as *mut _ as *mut usize\n+        let ptr = self\n+            .data\n+            .as_mut_ptr()\n+            .cast::<A>()\n+            .add(Self::HEADER_SKIP)\n+            .cast::<usize>();\n+        debug_assert!(ptr as usize % mem::align_of::<usize>() == 0);\n+        ptr\n     }\n \n     #[inline]\n     #[must_use]\n     pub(crate) unsafe fn data(&self) -> *const A {\n-        self.len_const().add(1) as *const _ as *const A\n+        let ptr = self\n+            .data\n+            .as_ptr()\n+            .cast::<usize>()\n+            .add(Self::ELEMENT_SKIP)\n+            .cast::<A>();\n+        debug_assert!(ptr as usize % mem::align_of::<A>() == 0);\n+        ptr\n     }\n \n     #[inline]\n     #[must_use]\n     unsafe fn data_mut(&mut self) -> *mut A {\n-        self.len_mut().add(1) as *mut _ as *mut A\n+        let ptr = self\n+            .data\n+            .as_mut_ptr()\n+            .cast::<usize>()\n+            .add(Self::ELEMENT_SKIP)\n+            .cast::<A>();\n+        debug_assert!(ptr as usize % mem::align_of::<A>() == 0);\n+        ptr\n     }\n \n     #[inline]\n@@ -164,12 +226,36 @@ impl<A, T> InlineArray<A, T> {\n     #[inline]\n     #[must_use]\n     pub fn new() -> Self {\n-        debug_assert!(Self::HOST_SIZE > Self::HEADER_SIZE);\n+        assert!(Self::HOST_SIZE > Self::HEADER_SIZE);\n         let mut self_ = Self {\n+            _header_align: [],\n+            _data_align: [],\n             data: MaybeUninit::uninit(),\n-            phantom: PhantomData,\n         };\n-        unsafe { *self_.len_mut() = 0 }\n+        // Sanity check our assumptions about what is guaranteed by the compiler. If we are right,\n+        // these should completely optimize out of the resulting binary.\n+        assert_eq!(\n+            &self_ as *const _ as usize,\n+            self_.data.as_ptr() as usize,\n+            \"Padding at the start of struct\",\n+        );\n+        assert_eq!(mem::size_of::<Self>(), mem::size_of::<T>());\n+        assert_eq!(\n+            self_.data.as_ptr() as usize % mem::align_of::<usize>(),\n+            0,\n+            \"Unaligned header\"\n+        );\n+        assert_eq!(\n+            self_.data.as_ptr() as usize % mem::align_of::<A>(),\n+            0,\n+            \"Unaligned elements\"\n+        );\n+        assert!(\n+            mem::align_of::<A>() % mem::align_of::<usize>() == 0\n+                || mem::align_of::<usize>() % mem::align_of::<A>() == 0\n+        );\n+        assert!(Self::ELEMENT_SKIP == 0 || Self::HEADER_SKIP == 0);\n+        unsafe { ptr::write(self_.len_mut(), 0usize) };\n         self_\n     }\n \n@@ -270,7 +356,7 @@ impl<A, T> InlineArray<A, T> {\n \n     #[inline]\n     unsafe fn drop_contents(&mut self) {\n-        ptr::drop_in_place::<[A]>(&mut **self)\n+        ptr::drop_in_place::<[A]>(&mut **self) // uses DerefMut\n     }\n \n     /// Discard the contents of the array.\n@@ -516,4 +602,24 @@ mod test {\n         assert_eq!(65536, chunk.len());\n         assert_eq!(Some(()), chunk.pop());\n     }\n+\n+    #[test]\n+    fn low_align_base() {\n+        let mut chunk: InlineArray<String, [u8; 512]> = InlineArray::new();\n+        chunk.push(\"Hello\".to_owned());\n+        assert_eq!(chunk[0], \"Hello\");\n+    }\n+\n+    #[test]\n+    fn big_align_elem() {\n+        #[repr(align(256))]\n+        struct BigAlign(usize);\n+\n+        let mut chunk: InlineArray<BigAlign, [usize; 256]> = InlineArray::new();\n+        chunk.push(BigAlign(42));\n+        assert_eq!(\n+            chunk.get(0).unwrap() as *const _ as usize % mem::align_of::<BigAlign>(),\n+            0\n+        );\n+    }\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2e3b05c9f5b49f79de669a6010d604c185bc0c15",
            "date": "2022-04-29T16:07:02Z",
            "author_login": "bodil"
          },
          {
            "sha": "5516c689e0c149efd82f2430dfc022c087ce4a0b",
            "date": "2022-04-29T16:06:36Z",
            "author_login": "bodil"
          },
          {
            "sha": "27a7cb02b08d26e62714e8204886f24a0d9586e8",
            "date": "2022-04-29T16:05:57Z",
            "author_login": "bodil"
          },
          {
            "sha": "fd7d154d63e5a287d0c15f0728e0359fc98fe1ee",
            "date": "2021-09-22T16:36:12Z",
            "author_login": "kornelski"
          },
          {
            "sha": "70b90d36e6d05cc0416896d4b041a6af1bb93d40",
            "date": "2021-07-09T22:03:56Z",
            "author_login": "kornelski"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-129",
    "description": "An issue was discovered in the sized-chunks crate through 0.6.2 for Rust. In the Chunk implementation, the array size is not checked when constructed with pair().",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-09-19T21:15:12.267",
    "last_modified": "2024-11-21T05:18:47.450",
    "fix_date": "2021-02-12T12:21:25Z"
  },
  "references": [
    {
      "url": "https://github.com/bodil/sized-chunks/commit/3ae48bd463c1af41c24b96b84079946f51f51e3c",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/bodil/sized-chunks/issues/11",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0041.html",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/bodil/sized-chunks/commit/3ae48bd463c1af41c24b96b84079946f51f51e3c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/bodil/sized-chunks/issues/11",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0041.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:06.142285",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "sized-chunks",
    "owner": "bodil",
    "created_at": "2019-02-19T17:29:45Z",
    "updated_at": "2023-05-16T13:21:33Z",
    "pushed_at": "2022-04-29T16:07:12Z",
    "size": 230,
    "stars": 25,
    "forks": 9,
    "open_issues": 1,
    "watchers": 25,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Rust": 187830
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mpl-2.0"
    },
    "collected_at": "2025-01-14T16:29:27.727780"
  }
}