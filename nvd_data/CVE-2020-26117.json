{
  "cve_id": "CVE-2020-26117",
  "github_data": {
    "repository": "TigerVNC/tigervnc",
    "fix_commit": "20dea801e747318525a5859fe4f37c52b05310cb",
    "related_commits": [
      "20dea801e747318525a5859fe4f37c52b05310cb",
      "7399eab79a4365434d26494fa1628ce1eb91562b",
      "b30f10c681ec87720cff85d490f67098568a9cba",
      "f029745f63ac7d22fb91639b2cb5b3ab56134d6e",
      "20dea801e747318525a5859fe4f37c52b05310cb",
      "7399eab79a4365434d26494fa1628ce1eb91562b",
      "b30f10c681ec87720cff85d490f67098568a9cba",
      "f029745f63ac7d22fb91639b2cb5b3ab56134d6e"
    ],
    "patch_url": "https://github.com/TigerVNC/tigervnc/commit/20dea801e747318525a5859fe4f37c52b05310cb.patch",
    "fix_commit_details": {
      "sha": "20dea801e747318525a5859fe4f37c52b05310cb",
      "commit_date": "2020-09-08T08:13:32Z",
      "author": {
        "login": "bphinz",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Properly store certificate exceptions in Java viewer",
        "length": 530,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 164,
        "additions": 101,
        "deletions": 63
      },
      "files": [
        {
          "filename": "java/com/tigervnc/rfb/CSecurityTLS.java",
          "status": "modified",
          "additions": 101,
          "deletions": 63,
          "patch": "@@ -107,12 +107,6 @@ public static void setDefaults()\n       X509CRL.setDefaultStr(getDefaultCRL());\n   }\n \n-// FIXME:\n-// Need to shutdown the connection cleanly\n-\n-// FIXME?\n-// add a finalizer method that calls shutdown\n-\n   public boolean processMsg(CConnection cc) {\n     is = (FdInStream)cc.getInStream();\n     os = (FdOutStream)cc.getOutStream();\n@@ -269,8 +263,13 @@ public void checkServerTrusted(X509Certificate[] chain, String authType)\n     {\n       Collection<? extends Certificate> certs = null;\n       X509Certificate cert = chain[0];\n+      String pk =\n+        Base64.getEncoder().encodeToString(cert.getPublicKey().getEncoded());\n       try {\n         cert.checkValidity();\n+        verifyHostname(cert);\n+      } catch(CertificateParsingException e) {\n+        throw new SystemException(e.getMessage());\n       } catch(CertificateNotYetValidException e) {\n         throw new AuthFailureException(\"server certificate has not been activated\");\n       } catch(CertificateExpiredException e) {\n@@ -279,73 +278,111 @@ public void checkServerTrusted(X509Certificate[] chain, String authType)\n \t\t\t      \"do you want to continue?\"))\n           throw new AuthFailureException(\"server certificate has expired\");\n       }\n-      String thumbprint = getThumbprint(cert);\n       File vncDir = new File(FileUtils.getVncHomeDir());\n-      File certFile = new File(vncDir, \"x509_savedcerts.pem\");\n-      CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-      if (vncDir.exists() && certFile.exists() && certFile.canRead()) {\n-        InputStream certStream = new MyFileInputStream(certFile);\n-        certs = cf.generateCertificates(certStream);\n-        for (Certificate c : certs)\n-          if (thumbprint.equals(getThumbprint((X509Certificate)c)))\n-            return;\n-      }\n+      if (!vncDir.exists())\n+        throw new AuthFailureException(\"Could not obtain VNC home directory \"+\n+                                       \"path for known hosts storage\");\n+      File dbPath = new File(vncDir, \"x509_known_hosts\");\n+      String info =\n+        \"  Subject: \"+cert.getSubjectX500Principal().getName()+\"\\n\"+\n+        \"  Issuer: \"+cert.getIssuerX500Principal().getName()+\"\\n\"+\n+        \"  Serial Number: \"+cert.getSerialNumber()+\"\\n\"+\n+        \"  Version: \"+cert.getVersion()+\"\\n\"+\n+        \"  Signature Algorithm: \"+cert.getPublicKey().getAlgorithm()+\"\\n\"+\n+        \"  Not Valid Before: \"+cert.getNotBefore()+\"\\n\"+\n+        \"  Not Valid After: \"+cert.getNotAfter()+\"\\n\"+\n+        \"  SHA-1 Fingerprint: \"+getThumbprint(cert)+\"\\n\";\n       try {\n-        verifyHostname(cert);\n+        if (dbPath.exists()) {\n+          FileReader db = new FileReader(dbPath);\n+          BufferedReader dbBuf = new BufferedReader(db);\n+          String line;\n+          String server = client.getServerName().toLowerCase();\n+          while ((line = dbBuf.readLine())!=null) {\n+            String fields[] = line.split(\"\\\\|\");\n+            if (fields.length==6) {\n+              if (server.equals(fields[2]) && pk.equals(fields[5])) {\n+                vlog.debug(\"Server certificate found in known hosts file\");\n+                dbBuf.close();\n+                return;\n+              } else if (server.equals(fields[2]) && !pk.equals(fields[5]) ||\n+                         !server.equals(fields[2]) && pk.equals(fields[5])) {\n+                throw new CertStoreException();\n+              }\n+            }\n+          }\n+          dbBuf.close();\n+        }\n         tm.checkServerTrusted(chain, authType);\n+      } catch (IOException e) {\n+        throw new AuthFailureException(\"Could not load known hosts database\");\n+      } catch (CertStoreException e) {\n+        vlog.debug(\"Server host key mismatch\");\n+        vlog.debug(info);\n+        String text =\n+          \"This host is previously known with a different \"+\n+          \"certificate, and the new certificate has been \"+\n+          \"signed by an unknown authority\\n\"+\n+          \"\\n\"+info+\"\\n\"+\n+          \"Someone could be trying to impersonate the site and you should not continue.\\n\"+\n+          \"\\n\"+\n+          \"Do you want to make an exception for this server?\";\n+        if (!msg.showMsgBox(YES_NO_OPTION, \"Unexpected certificate issuer\", text))\n+          throw new AuthFailureException(\"Unexpected certificate issuer\");\n+        store_pubkey(dbPath, client.getServerName().toLowerCase(), pk);\n       } catch (java.lang.Exception e) {\n         if (e.getCause() instanceof CertPathBuilderException) {\n-          String certinfo =\n+          vlog.debug(\"Server host not previously known\");\n+          vlog.debug(info);\n+          String text =\n             \"This certificate has been signed by an unknown authority\\n\"+\n+            \"\\n\"+info+\"\\n\"+\n+            \"Someone could be trying to impersonate the site and you should not continue.\\n\"+\n             \"\\n\"+\n-            \"  Subject: \"+cert.getSubjectX500Principal().getName()+\"\\n\"+\n-            \"  Issuer: \"+cert.getIssuerX500Principal().getName()+\"\\n\"+\n-            \"  Serial Number: \"+cert.getSerialNumber()+\"\\n\"+\n-            \"  Version: \"+cert.getVersion()+\"\\n\"+\n-            \"  Signature Algorithm: \"+cert.getPublicKey().getAlgorithm()+\"\\n\"+\n-            \"  Not Valid Before: \"+cert.getNotBefore()+\"\\n\"+\n-            \"  Not Valid After: \"+cert.getNotAfter()+\"\\n\"+\n-            \"  SHA1 Fingerprint: \"+getThumbprint(cert)+\"\\n\"+\n-            \"\\n\"+\n-            \"Do you want to save it and continue?\";\n-          if (!msg.showMsgBox(YES_NO_OPTION, \"certificate issuer unknown\",\n-                certinfo)) {\n-            throw new AuthFailureException(\"certificate issuer unknown\");\n-          }\n-          if (certs == null || !certs.contains(cert)) {\n-            byte[] der = cert.getEncoded();\n-            String pem = Base64.getEncoder().encodeToString(der);\n-            pem = pem.replaceAll(\"(.{64})\", \"$1\\n\");\n-            FileWriter fw = null;\n-            try {\n-              if (!vncDir.exists())\n-                vncDir.mkdir();\n-              if (!certFile.exists() && !certFile.createNewFile()) {\n-                vlog.error(\"Certificate save failed.\");\n-              } else {\n-                fw = new FileWriter(certFile.getAbsolutePath(), true);\n-                fw.write(\"-----BEGIN CERTIFICATE-----\\n\");\n-                fw.write(pem+\"\\n\");\n-                fw.write(\"-----END CERTIFICATE-----\\n\");\n-              }\n-            } catch (IOException ioe) {\n-              msg.showMsgBox(OK_OPTION, \"certificate save failed\",\n-                             \"Could not save the certificate\");\n-            } finally {\n-              try {\n-                if (fw != null)\n-                  fw.close();\n-              } catch(IOException ioe2) {\n-                throw new Exception(ioe2.getMessage());\n-              }\n-            }\n-          }\n+            \"Do you want to make an exception for this server?\";\n+          if (!msg.showMsgBox(YES_NO_OPTION, \"Unknown certificate issuer\", text))\n+            throw new AuthFailureException(\"Unknown certificate issuer\");\n+          store_pubkey(dbPath, client.getServerName().toLowerCase(), pk);\n         } else {\n           throw new SystemException(e.getMessage());\n         }\n       }\n     }\n \n+    private void store_pubkey(File dbPath, String serverName, String pk)\n+    {\n+      ArrayList<String> lines = new ArrayList<String>();\n+      File vncDir = new File(FileUtils.getVncHomeDir());\n+      try {\n+        if (dbPath.exists()) {\n+          FileReader db = new FileReader(dbPath);\n+          BufferedReader dbBuf = new BufferedReader(db);\n+          String line;\n+          while ((line = dbBuf.readLine())!=null) {\n+            String fields[] = line.split(\"\\\\|\");\n+            if (fields.length==6)\n+              if (!serverName.equals(fields[2]) && !pk.equals(fields[5]))\n+                lines.add(line);\n+          }\n+          dbBuf.close();\n+        }\n+      } catch (IOException e) {\n+        throw new AuthFailureException(\"Could not load known hosts database\");\n+      }\n+      try {\n+        if (!dbPath.exists())\n+          dbPath.createNewFile();\n+        FileWriter fw = new FileWriter(dbPath.getAbsolutePath(), false);\n+        Iterator i = lines.iterator();\n+        while (i.hasNext())\n+          fw.write((String)i.next()+\"\\n\");\n+        fw.write(\"|g0|\"+serverName+\"|*|0|\"+pk+\"\\n\");\n+        fw.close();\n+      } catch (IOException e) {\n+        vlog.error(\"Failed to store server certificate to known hosts database\");\n+      }\n+    }\n+\n     public X509Certificate[] getAcceptedIssuers ()\n     {\n       return tm.getAcceptedIssuers();\n@@ -399,12 +436,13 @@ private void verifyHostname(X509Certificate cert)\n         }\n         Object[] answer = {\"YES\", \"NO\"};\n         int ret = JOptionPane.showOptionDialog(null,\n-          \"Hostname verification failed. Do you want to continue?\",\n-          \"Hostname Verification Failure\",\n+          \"Hostname (\"+client.getServerName()+\") does not match the\"+\n+          \" server certificate, do you want to continue?\",\n+          \"Certificate hostname mismatch\",\n           JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,\n           null, answer, answer[0]);\n         if (ret != JOptionPane.YES_OPTION)\n-          throw new WarningException(\"Hostname verification failed.\");\n+          throw new WarningException(\"Certificate hostname mismatch.\");\n       } catch (CertificateParsingException e) {\n         throw new SystemException(e.getMessage());\n       } catch (InvalidNameException e) {"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "a91699ec469846816ddb7b1b670d660d923ff022",
            "date": "2025-01-14T15:35:02Z",
            "author_login": "CendioOssman"
          },
          {
            "sha": "9881fe0b18fc6d182d22470c0ac363e945192ca2",
            "date": "2025-01-14T15:11:46Z",
            "author_login": "CendioOssman"
          },
          {
            "sha": "fc645a833310161c0c97d5a2ccb937dd66280f14",
            "date": "2025-01-14T15:21:46Z",
            "author_login": "CendioOssman"
          },
          {
            "sha": "d43cd3eaa7daf64c8e9236a62e89efcaf806f80d",
            "date": "2025-01-14T15:18:39Z",
            "author_login": "CendioOssman"
          },
          {
            "sha": "65d1771dfc3d1e0c0efd046dc373dc978c037c86",
            "date": "2025-01-14T15:17:55Z",
            "author_login": "CendioOssman"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-295",
    "description": "In rfb/CSecurityTLS.cxx and rfb/CSecurityTLS.java in TigerVNC before 1.11.0, viewers mishandle TLS certificate exceptions. They store the certificates as authorities, meaning that the owner of a certificate could impersonate any server after a client had added an exception.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-09-27T04:15:11.650",
    "last_modified": "2024-11-21T05:19:16.850",
    "fix_date": "2020-09-08T08:13:32Z"
  },
  "references": [
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2020-10/msg00025.html",
      "source": "cve@mitre.org",
      "tags": [
        "Broken Link",
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2020-11/msg00024.html",
      "source": "cve@mitre.org",
      "tags": [
        "Broken Link",
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.opensuse.org/show_bug.cgi?id=1176733",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/TigerVNC/tigervnc/commit/20dea801e747318525a5859fe4f37c52b05310cb",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/TigerVNC/tigervnc/commit/7399eab79a4365434d26494fa1628ce1eb91562b",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/TigerVNC/tigervnc/commit/b30f10c681ec87720cff85d490f67098568a9cba",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/TigerVNC/tigervnc/commit/f029745f63ac7d22fb91639b2cb5b3ab56134d6e",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/TigerVNC/tigervnc/releases/tag/v1.11.0",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2020/10/msg00007.html",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2020-10/msg00025.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Broken Link",
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2020-11/msg00024.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Broken Link",
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.opensuse.org/show_bug.cgi?id=1176733",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/TigerVNC/tigervnc/commit/20dea801e747318525a5859fe4f37c52b05310cb",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/TigerVNC/tigervnc/commit/7399eab79a4365434d26494fa1628ce1eb91562b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/TigerVNC/tigervnc/commit/b30f10c681ec87720cff85d490f67098568a9cba",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/TigerVNC/tigervnc/commit/f029745f63ac7d22fb91639b2cb5b3ab56134d6e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/TigerVNC/tigervnc/releases/tag/v1.11.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2020/10/msg00007.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:06.156165",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "tigervnc",
    "owner": "TigerVNC",
    "created_at": "2014-06-25T12:48:26Z",
    "updated_at": "2025-01-14T11:44:26Z",
    "pushed_at": "2025-01-14T11:44:21Z",
    "size": 25050,
    "stars": 5359,
    "forks": 970,
    "open_issues": 175,
    "watchers": 5359,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 2105004,
      "Java": 1745894,
      "C": 1008908,
      "CMake": 70519,
      "Roff": 50879,
      "Makefile": 32567,
      "Objective-C++": 17412,
      "Perl": 12443,
      "Shell": 11196,
      "Objective-C": 1780,
      "Python": 1378
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T13:43:04.443892"
  }
}