{
  "cve_id": "CVE-2020-26216",
  "github_data": {
    "repository": "TYPO3/Fluid",
    "fix_commit": "f20db4e74cf9803c6cffca2ed2f03e1b0b89d0dc",
    "related_commits": [
      "f20db4e74cf9803c6cffca2ed2f03e1b0b89d0dc",
      "f20db4e74cf9803c6cffca2ed2f03e1b0b89d0dc"
    ],
    "patch_url": "https://github.com/TYPO3/Fluid/commit/f20db4e74cf9803c6cffca2ed2f03e1b0b89d0dc.patch",
    "fix_commit_details": {
      "sha": "f20db4e74cf9803c6cffca2ed2f03e1b0b89d0dc",
      "commit_date": "2020-10-29T16:15:43Z",
      "author": {
        "login": "NamelessCoder",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "[SECURITY] Introduce selective argument escaping",
        "length": 925,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 343,
        "additions": 275,
        "deletions": 68
      },
      "files": [
        {
          "filename": "src/Core/Parser/Configuration.php",
          "status": "modified",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -12,6 +12,10 @@\n  */\n class Configuration\n {\n+    /**\n+     * @var bool\n+     */\n+    protected $viewHelperArgumentEscapingEnabled = true;\n \n     /**\n      * Generic interceptors registered with the configuration.\n@@ -27,6 +31,22 @@ class Configuration\n      */\n     protected $escapingInterceptors = [];\n \n+    /**\n+     * @return bool\n+     */\n+    public function isViewHelperArgumentEscapingEnabled()\n+    {\n+        return $this->viewHelperArgumentEscapingEnabled;\n+    }\n+\n+    /**\n+     * @param bool $viewHelperArgumentEscapingEnabled\n+     */\n+    public function setViewHelperArgumentEscapingEnabled($viewHelperArgumentEscapingEnabled): void\n+    {\n+        $this->viewHelperArgumentEscapingEnabled = (bool) $viewHelperArgumentEscapingEnabled;\n+    }\n+\n     /**\n      * Adds an interceptor to apply to values coming from object accessors.\n      *"
        },
        {
          "filename": "src/Core/Parser/TemplateParser.php",
          "status": "modified",
          "additions": 41,
          "deletions": 12,
          "patch": "@@ -489,7 +489,7 @@ protected function objectAccessorHandler(ParsingState $state, $objectAccessorStr\n                 }\n                 $viewHelper = $viewHelperResolver->createViewHelperInstance($singleMatch['NamespaceIdentifier'], $singleMatch['MethodIdentifier']);\n                 if (strlen($singleMatch['ViewHelperArguments']) > 0) {\n-                    $arguments = $this->recursiveArrayHandler($singleMatch['ViewHelperArguments'], $viewHelper);\n+                    $arguments = $this->recursiveArrayHandler($state, $singleMatch['ViewHelperArguments'], $viewHelper);\n                 } else {\n                     $arguments = [];\n                 }\n@@ -563,28 +563,43 @@ protected function parseArguments($argumentsString, ViewHelperInterface $viewHel\n         $undeclaredArguments = [];\n         $matches = [];\n         if (preg_match_all(Patterns::$SPLIT_PATTERN_TAGARGUMENTS, $argumentsString, $matches, PREG_SET_ORDER) > 0) {\n-            $escapingEnabledBackup = $this->escapingEnabled;\n-            $this->escapingEnabled = false;\n             foreach ($matches as $singleMatch) {\n                 $argument = $singleMatch['Argument'];\n                 $value = $this->unquoteString($singleMatch['ValueQuoted']);\n-                $argumentsObjectTree[$argument] = $this->buildArgumentObjectTree($value);\n+                $escapingEnabledBackup = $this->escapingEnabled;\n                 if (isset($argumentDefinitions[$argument])) {\n                     $argumentDefinition = $argumentDefinitions[$argument];\n-                    if ($argumentDefinition->getType() === 'boolean' || $argumentDefinition->getType() === 'bool') {\n+                    $this->escapingEnabled = $this->escapingEnabled && $this->isArgumentEscaped($viewHelper, $argumentDefinition);\n+                    $isBoolean = $argumentDefinition->getType() === 'boolean' || $argumentDefinition->getType() === 'bool';\n+                    $argumentsObjectTree[$argument] = $this->buildArgumentObjectTree($value);\n+                    if ($isBoolean) {\n                         $argumentsObjectTree[$argument] = new BooleanNode($argumentsObjectTree[$argument]);\n                     }\n                 } else {\n-                    $undeclaredArguments[$argument] = $argumentsObjectTree[$argument];\n+                    $this->escapingEnabled = false;\n+                    $undeclaredArguments[$argument] = $this->buildArgumentObjectTree($value);\n                 }\n+                $this->escapingEnabled = $escapingEnabledBackup;\n             }\n-            $this->escapingEnabled = $escapingEnabledBackup;\n         }\n         $this->abortIfRequiredArgumentsAreMissing($argumentDefinitions, $argumentsObjectTree);\n         $viewHelper->validateAdditionalArguments($undeclaredArguments);\n         return $argumentsObjectTree + $undeclaredArguments;\n     }\n \n+    protected function isArgumentEscaped(ViewHelperInterface $viewHelper, ArgumentDefinition $argumentDefinition = null)\n+    {\n+        $hasDefinition = $argumentDefinition instanceof ArgumentDefinition;\n+        $isBoolean = $hasDefinition && ($argumentDefinition->getType() === 'boolean' || $argumentDefinition->getType() === 'bool');\n+        $escapingEnabled = $this->configuration->isViewHelperArgumentEscapingEnabled();\n+        $isArgumentEscaped = $hasDefinition && $argumentDefinition->getEscape() === true;\n+        $isContentArgument = $hasDefinition && method_exists($viewHelper, 'resolveContentArgumentName') && $argumentDefinition->getName() === $viewHelper->resolveContentArgumentName();\n+        if ($isContentArgument) {\n+            return !$isBoolean && ($viewHelper->isChildrenEscapingEnabled() || $isArgumentEscaped);\n+        }\n+        return !$isBoolean && $escapingEnabled && $isArgumentEscaped;\n+    }\n+\n     /**\n      * Build up an argument object tree for the string in $argumentString.\n      * This builds up the tree for a single argument value.\n@@ -664,7 +679,7 @@ protected function textAndShorthandSyntaxHandler(ParsingState $state, $text, $co\n                 && preg_match(Patterns::$SCAN_PATTERN_SHORTHANDSYNTAX_ARRAYS, $section, $matchedVariables) > 0\n             ) {\n                 // We only match arrays if we are INSIDE viewhelper arguments\n-                $this->arrayHandler($state, $this->recursiveArrayHandler($matchedVariables['Array']));\n+                $this->arrayHandler($state, $this->recursiveArrayHandler($state, $matchedVariables['Array']));\n             } else {\n                 // We ask custom ExpressionNode instances from ViewHelperResolver\n                 // if any match our expression:\n@@ -737,12 +752,13 @@ protected function arrayHandler(ParsingState $state, $arrayText)\n      * - Variables\n      * - sub-arrays\n      *\n+     * @param ParsingState $state\n      * @param string $arrayText Array text\n      * @param ViewHelperInterface|null $viewHelper ViewHelper instance - passed only if the array is a collection of arguments for an inline ViewHelper\n      * @return NodeInterface[] the array node built up\n      * @throws Exception\n      */\n-    protected function recursiveArrayHandler($arrayText, ViewHelperInterface $viewHelper = null)\n+    protected function recursiveArrayHandler(ParsingState $state, $arrayText, ViewHelperInterface $viewHelper = null)\n     {\n         $undeclaredArguments = [];\n         $argumentDefinitions = [];\n@@ -755,14 +771,25 @@ protected function recursiveArrayHandler($arrayText, ViewHelperInterface $viewHe\n             foreach ($matches as $singleMatch) {\n                 $arrayKey = $this->unquoteString($singleMatch['Key']);\n                 $assignInto = &$arrayToBuild;\n-                if (!isset($argumentDefinitions[$arrayKey])) {\n+                $isBoolean = false;\n+                $argumentDefinition = null;\n+                if (isset($argumentDefinitions[$arrayKey])) {\n+                    $argumentDefinition = $argumentDefinitions[$arrayKey];\n+                    $isBoolean = $argumentDefinitions[$arrayKey]->getType() === 'boolean' || $argumentDefinitions[$arrayKey]->getType() === 'bool';\n+                } else {\n                     $assignInto = &$undeclaredArguments;\n                 }\n \n+                $escapingEnabledBackup = $this->escapingEnabled;\n+                $this->escapingEnabled = $this->escapingEnabled && $viewHelper instanceof ViewHelperInterface && $this->isArgumentEscaped($viewHelper, $argumentDefinition);\n+\n                 if (array_key_exists('Subarray', $singleMatch) && !empty($singleMatch['Subarray'])) {\n-                    $assignInto[$arrayKey] = new ArrayNode($this->recursiveArrayHandler($singleMatch['Subarray']));\n+                    $assignInto[$arrayKey] = new ArrayNode($this->recursiveArrayHandler($state, $singleMatch['Subarray']));\n                 } elseif (!empty($singleMatch['VariableIdentifier'])) {\n                     $assignInto[$arrayKey] = new ObjectAccessorNode($singleMatch['VariableIdentifier']);\n+                    if ($viewHelper instanceof ViewHelperInterface && !$isBoolean) {\n+                        $this->callInterceptor($assignInto[$arrayKey], InterceptorInterface::INTERCEPT_OBJECTACCESSOR, $state);\n+                    }\n                 } elseif (array_key_exists('Number', $singleMatch) && (!empty($singleMatch['Number']) || $singleMatch['Number'] === '0')) {\n                     // Note: this method of casting picks \"int\" when value is a natural number and \"float\" if any decimals are found. See also NumericNode.\n                     $assignInto[$arrayKey] = $singleMatch['Number'] + 0;\n@@ -771,9 +798,11 @@ protected function recursiveArrayHandler($arrayText, ViewHelperInterface $viewHe\n                     $assignInto[$arrayKey] = $this->buildArgumentObjectTree($argumentString);\n                 }\n \n-                if (isset($argumentDefinitions[$arrayKey]) && ($argumentDefinitions[$arrayKey]->getType() === 'boolean' || $argumentDefinitions[$arrayKey]->getType() === 'bool')) {\n+                if ($isBoolean) {\n                     $assignInto[$arrayKey] = new BooleanNode($assignInto[$arrayKey]);\n                 }\n+\n+                $this->escapingEnabled = $escapingEnabledBackup;\n             }\n         }\n         if ($viewHelper instanceof ViewHelperInterface) {"
        },
        {
          "filename": "src/Core/ViewHelper/AbstractConditionViewHelper.php",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -42,8 +42,8 @@ abstract class AbstractConditionViewHelper extends AbstractViewHelper\n      */\n     public function initializeArguments()\n     {\n-        $this->registerArgument('then', 'mixed', 'Value to be returned if the condition if met.', false);\n-        $this->registerArgument('else', 'mixed', 'Value to be returned if the condition if not met.', false);\n+        $this->registerArgument('then', 'mixed', 'Value to be returned if the condition if met.', false, null, true);\n+        $this->registerArgument('else', 'mixed', 'Value to be returned if the condition if not met.', false, null, true);\n     }\n \n     /**"
        },
        {
          "filename": "src/Core/ViewHelper/AbstractViewHelper.php",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -158,19 +158,20 @@ public function isOutputEscapingEnabled()\n      * @param string $description Description of the argument\n      * @param boolean $required If TRUE, argument is required. Defaults to FALSE.\n      * @param mixed $defaultValue Default value of argument\n+     * @param bool|null $escape Can be toggled to TRUE to force escaping of variables and inline syntax passed as argument value.\n      * @return \\TYPO3Fluid\\Fluid\\Core\\ViewHelper\\AbstractViewHelper $this, to allow chaining.\n      * @throws Exception\n      * @api\n      */\n-    protected function registerArgument($name, $type, $description, $required = false, $defaultValue = null)\n+    protected function registerArgument($name, $type, $description, $required = false, $defaultValue = null, $escape = null)\n     {\n         if (array_key_exists($name, $this->argumentDefinitions)) {\n             throw new Exception(\n                 'Argument \"' . $name . '\" has already been defined, thus it should not be defined again.',\n                 1253036401\n             );\n         }\n-        $this->argumentDefinitions[$name] = new ArgumentDefinition($name, $type, $description, $required, $defaultValue);\n+        $this->argumentDefinitions[$name] = new ArgumentDefinition($name, $type, $description, $required, $defaultValue, $escape);\n         return $this;\n     }\n \n@@ -184,19 +185,20 @@ protected function registerArgument($name, $type, $description, $required = fals\n      * @param string $description Description of the argument\n      * @param boolean $required If TRUE, argument is required. Defaults to FALSE.\n      * @param mixed $defaultValue Default value of argument\n+     * @param bool|null $escape Can be toggled to TRUE to force escaping of variables and inline syntax passed as argument value.\n      * @return \\TYPO3Fluid\\Fluid\\Core\\ViewHelper\\AbstractViewHelper $this, to allow chaining.\n      * @throws Exception\n      * @api\n      */\n-    protected function overrideArgument($name, $type, $description, $required = false, $defaultValue = null)\n+    protected function overrideArgument($name, $type, $description, $required = false, $defaultValue = null, $escape = null)\n     {\n         if (!array_key_exists($name, $this->argumentDefinitions)) {\n             throw new Exception(\n                 'Argument \"' . $name . '\" has not been defined, thus it can\\'t be overridden.',\n                 1279212461\n             );\n         }\n-        $this->argumentDefinitions[$name] = new ArgumentDefinition($name, $type, $description, $required, $defaultValue);\n+        $this->argumentDefinitions[$name] = new ArgumentDefinition($name, $type, $description, $required, $defaultValue, $escape);\n         return $this;\n     }\n "
        },
        {
          "filename": "src/Core/ViewHelper/ArgumentDefinition.php",
          "status": "modified",
          "additions": 26,
          "deletions": 1,
          "patch": "@@ -47,6 +47,21 @@ class ArgumentDefinition\n      */\n     protected $defaultValue = null;\n \n+    /**\n+     * Escaping instruction, in line with $this->escapeOutput / $this->escapeChildren on ViewHelpers.\n+     *\n+     * A value of NULL means \"use default behavior\" (which is to escape nodes contained in the value).\n+     *\n+     * A value of TRUE means \"escape unless escaping is disabled\" (e.g. if argument is used in a ViewHelper nested\n+     * within f:format.raw which disables escaping, the argument will not be escaped).\n+     *\n+     * A value of FALSE means \"never escape argument\" (as in behavior of f:format.raw, which supports both passing\n+     * argument as actual argument or as tag content, but wants neither to be escaped).\n+     *\n+     * @var bool|null\n+     */\n+    protected $escape = null;\n+\n     /**\n      * Constructor for this argument definition.\n      *\n@@ -55,14 +70,16 @@ class ArgumentDefinition\n      * @param string $description Description of argument\n      * @param boolean $required TRUE if argument is required\n      * @param mixed $defaultValue Default value\n+     * @param bool|null $escape Whether or not argument is escaped, or uses default escaping behavior (see class var comment)\n      */\n-    public function __construct($name, $type, $description, $required, $defaultValue = null)\n+    public function __construct($name, $type, $description, $required, $defaultValue = null, $escape = null)\n     {\n         $this->name = $name;\n         $this->type = $type;\n         $this->description = $description;\n         $this->required = $required;\n         $this->defaultValue = $defaultValue;\n+        $this->escape = $escape;\n     }\n \n     /**\n@@ -114,4 +131,12 @@ public function getDefaultValue()\n     {\n         return $this->defaultValue;\n     }\n+\n+    /**\n+     * @return bool|null\n+     */\n+    public function getEscape()\n+    {\n+        return $this->escape;\n+    }\n }"
        },
        {
          "filename": "src/Core/ViewHelper/TagBuilder.php",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -191,6 +191,9 @@ public function ignoreEmptyAttributes($ignoreEmptyAttributes)\n      */\n     public function addAttribute($attributeName, $attributeValue, $escapeSpecialCharacters = true)\n     {\n+        if ($escapeSpecialCharacters) {\n+            $attributeName = htmlspecialchars($attributeName);\n+        }\n         if ($attributeName === 'data' && (is_array($attributeValue) || $attributeValue instanceof \\Traversable)) {\n             foreach ($attributeValue as $name => $value) {\n                 $this->addAttribute('data-' . $name, $value, $escapeSpecialCharacters);"
        },
        {
          "filename": "src/Core/ViewHelper/Traits/CompileWithContentArgumentAndRenderStatic.php",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -116,7 +116,7 @@ protected function buildRenderChildrenClosure()\n     /**\n      * @return string\n      */\n-    protected function resolveContentArgumentName()\n+    public function resolveContentArgumentName()\n     {\n         if (empty($this->contentArgumentName)) {\n             $registeredArguments = call_user_func_array([$this, 'prepareArguments'], []);"
        },
        {
          "filename": "src/ViewHelpers/Format/RawViewHelper.php",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -64,7 +64,7 @@ class RawViewHelper extends AbstractViewHelper\n      */\n     public function initializeArguments()\n     {\n-        $this->registerArgument('value', 'mixed', 'The value to output');\n+        $this->registerArgument('value', 'mixed', 'The value to output', false, null, false);\n     }\n \n     /**"
        },
        {
          "filename": "tests/Functional/Cases/Escaping/EscapingTest.php",
          "status": "modified",
          "additions": 146,
          "deletions": 41,
          "patch": "@@ -7,6 +7,7 @@\n use TYPO3Fluid\\Fluid\\Core\\ViewHelper\\ViewHelperInterface;\n use TYPO3Fluid\\Fluid\\Tests\\Functional\\BaseFunctionalTestCase;\n use TYPO3Fluid\\Fluid\\Tests\\Functional\\Fixtures\\ViewHelpers\\MutableTestViewHelper;\n+use TYPO3Fluid\\Fluid\\Tests\\Functional\\Fixtures\\ViewHelpers\\TagBasedTestViewHelper;\n use TYPO3Fluid\\Fluid\\Tests\\Functional\\Fixtures\\ViewHelpers\\TestViewHelperResolver;\n use TYPO3Fluid\\Fluid\\Tests\\Unit\\Core\\Rendering\\RenderingContextFixture;\n use TYPO3Fluid\\Fluid\\View\\TemplateView;\n@@ -64,13 +65,13 @@ public function testWithEscapingBehaviorsNullWithoutContentOrOutputArguments()\n \n     public function testWithEscapingBehaviorsNullWithOutputArgument()\n     {\n+        // When both escapeOutput and escapeChildren are null, output escaping is enabled and children escaping is disabled (because output is escaped there is no need to escsape children explicitly).\n+        // The case therefore escapes both static HTML and variables/inline in arguments.\n         $viewHelper = (new MutableTestViewHelper())->withOutputArgument();\n         $this->assertSame(self::ESCAPED_WRAPPED, $this->renderCode($viewHelper, '<test:test output=\"<div>{value}</div>\" />'), 'Tag with variable and static HTML');\n         $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '<test:test output=\"{value}\" />'), 'Tag with variable');\n         $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '{test:test(output: value)}'), 'Inline output argument');\n-\n-        // TODO: possible undesired behavior, double encoded variable\n-        $this->assertSame('&lt;div&gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&lt;/div&gt;', $this->renderCode($viewHelper, '{test:test(output: \"<div>{value}</div>\")}'), 'Inline with static HTML');\n+        $this->assertSame(self::ESCAPED_WRAPPED, $this->renderCode($viewHelper, '{test:test(output: \"<div>{value}</div>\")}'), 'Inline with static HTML');\n     }\n \n     public function testWithEscapingBehaviorsNullWithContentArgument()\n@@ -83,6 +84,7 @@ public function testWithEscapingBehaviorsNullWithContentArgument()\n     /*\n      * Escape children = false\n      * Escape output = null\n+     * Escape argument = null\n      */\n \n     public function testWithEscapChildrenFalseWithoutContentOrOutputArguments()\n@@ -102,22 +104,23 @@ public function testWithEscapChildrenFalseWithContentArgument()\n \n     public function testWithEscapeChildrenFalseWithOutputArgument()\n     {\n+        // Output argument is not escaped (it is not a content argument) because output escaping is OFF. Developer who wrote ViewHelper would be responsible for escaping.\n         $viewHelper = (new MutableTestViewHelper())->withOutputArgument()->withEscapeChildren(false);\n         $this->assertSame(self::ESCAPED_WRAPPED, $this->renderCode($viewHelper, '<test:test output=\"<div>{value}</div>\" />'), 'Tag with variable and static HTML');\n         $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '<test:test output=\"{value}\" />'), 'Tag child variable');\n         $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '{test:test(output: value)}'), 'Inline output argument');\n-\n-        // TODO: possible undesired behavior, double encoded variable\n-        $this->assertSame('&lt;div&gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&lt;/div&gt;', $this->renderCode($viewHelper, '{test:test(output: \"<div>{value}</div>\")}'), 'Inline with static HTML');\n+        $this->assertSame(self::ESCAPED_WRAPPED, $this->renderCode($viewHelper, '{test:test(output: \"<div>{value}</div>\")}'), 'Inline with static HTML');\n     }\n \n     /*\n      * Escape children = null\n      * Escape output = false\n+     * Escape arguments = false\n      */\n \n     public function testWithEscapOutputFalseWithoutContentOrOutputArguments()\n     {\n+        // Child content and content argument are treated the same based on escape-children state. Children escaping is ON because escape output is OFF and escape children has no decision.\n         $viewHelper = (new MutableTestViewHelper())->withEscapeOutput(false);\n         $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '{value -> test:test()}'), 'Inline pass of variable');\n         $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '<test:test>{value}</test:test>'), 'Tag child variable');\n@@ -128,39 +131,34 @@ public function testWithEscapOutputFalseWithoutContentOrOutputArguments()\n \n     public function testWithEscapeOutputFalseWithContentArgument()\n     {\n-        $viewHelper = (new MutableTestViewHelper())->withContentArgument()->withEscapeOutput(false);\n+        // Child content and content argument are treated the same based on escape-children state. Children escaping is ON because escape output is OFF and escape children has no decision.\n+        $viewHelper = (new MutableTestViewHelper())->withContentArgument(false)->withEscapeOutput(false);\n         $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '{value -> test:test()}'), 'Inline pass of variable');\n-\n-        // TODO: security case - argument must be escaped!\n-        #$this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '{test:test(content: value)}'), 'Inline pass of variable');\n-\n-        // TODO: inconsistent case - argument is quoted and is escaped, which does not happen if the argument is NOT quoted\n-        $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '{test:test(content: \"{value}\")}'), 'Inline pass of variable');\n-\n+        $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '{test:test(content: value)}'), 'Inline variable in argument');\n+        $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '{test:test(content: \"{value}\")}'), 'Inline pass of variable, quoted');\n         $this->assertSame(self::ESCAPED_WRAPPED_STATIC_PROTECTED, $this->renderCode($viewHelper, '<test:test><div>{value}</div></test:test>'), 'Tag child variable with static HTML');\n     }\n \n     public function testWithEscapeOutputFalseWithOutputArgument()\n     {\n-        $viewHelper = (new MutableTestViewHelper())->withOutputArgument()->withEscapeOutput(false);\n+        // Output argument is not escaped (it is not a content argument) because output escaping is OFF. Developer who wrote ViewHelper would be responsible for escaping.\n+        $viewHelper = (new MutableTestViewHelper())->withOutputArgument(false)->withEscapeOutput(false);\n         $this->assertSame(self::UNESCAPED_WRAPPED, $this->renderCode($viewHelper, '<test:test output=\"<div>{value}</div>\" />'), 'Tag with variable and static HTML');\n         $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '<test:test output=\"{value}\" />'), 'Tag child variable');\n         $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '{test:test(output: value)}'), 'Inline output argument');\n-\n-        // TODO: inconsistent case - argument is quoted and is escaped, which does not happen if the argument is NOT quoted\n-        $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '{test:test(output: \"{value}\")}'), 'Inline output argument');\n-\n-        // TODO: possibly undesired behavior, escapes argument though output should be unescaped / children should be escaped but value is not passed as child\n-        $this->assertSame(self::ESCAPED_WRAPPED_STATIC_PROTECTED, $this->renderCode($viewHelper, '{test:test(output: \"<div>{value}</div>\")}'), 'Inline with static HTML');\n+        $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '{test:test(output: \"{value}\")}'), 'Inline output argument');\n+        $this->assertSame(self::UNESCAPED_WRAPPED, $this->renderCode($viewHelper, '{test:test(output: \"<div>{value}</div>\")}'), 'Inline with static HTML');\n     }\n \n     /*\n      * Escape children = true\n      * Escape output = false\n+     * Escape arguments = false\n      */\n \n     public function testWithEscapOutputFalseWithEscapeChildrenTrueWithoutContentOrOutputArguments()\n     {\n+        // Output is escaped because children are escaped. Children are escaped because escape-output is OFF and no explicit decision is made for escape-children, causing escape-children to be ON.\n         $viewHelper = (new MutableTestViewHelper())->withEscapeOutput(false)->withEscapeChildren(true);\n         $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '{value -> test:test()}'), 'Inline pass of variable');\n         $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '<test:test>{value}</test:test>'), 'Tag child variable');\n@@ -169,34 +167,31 @@ public function testWithEscapOutputFalseWithEscapeChildrenTrueWithoutContentOrOu\n \n     public function testWithEscapeOutputFalseWithEscapeChildrenTrueWithContentArgument()\n     {\n-        $viewHelper = (new MutableTestViewHelper())->withContentArgument()->withEscapeOutput(false)->withEscapeChildren(true);\n+        // Child content is escaped because escape-output is OFF but an explicit decision for escape-children has been made to turn it ON.\n+        $viewHelper = (new MutableTestViewHelper())->withContentArgument(false)->withEscapeOutput(false)->withEscapeChildren(true);\n         $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '{value -> test:test()}'), 'Inline pass of variable');\n         $this->assertSame(self::ESCAPED_WRAPPED_STATIC_PROTECTED, $this->renderCode($viewHelper, '<test:test><div>{value}</div></test:test>'), 'Tag child variable with static HTML');\n     }\n \n     public function testWithEscapeOutputFalseWithEscapeChildrenTrueWithOutputArgument()\n     {\n-        $viewHelper = (new MutableTestViewHelper())->withOutputArgument()->withEscapeOutput(false)->withEscapeChildren(true);\n+        // Output argument is not escaped (it is not a content argument) because escape-output is OFF and escape-children is not considered (it is an argument, not a child). Developer who wrote ViewHelper would be responsible for escaping.\n+        $viewHelper = (new MutableTestViewHelper())->withOutputArgument(false)->withEscapeOutput(false)->withEscapeChildren(true);\n         $this->assertSame(self::UNESCAPED_WRAPPED, $this->renderCode($viewHelper, '<test:test output=\"<div>{value}</div>\" />'), 'Tag with variable and static HTML');\n         $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '<test:test output=\"{value}\" />'), 'Tag child variable');\n-\n-        // TODO: security case - argument must be escaped!\n-        #$this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '{test:test(output: value)}'), 'Inline output argument');\n-\n-        // TODO: inconsistent case - argument is quoted and is escaped, which does not happen if the argument is NOT quoted\n-        $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '{test:test(output: \"{value}\")}'), 'Inline output argument');\n-\n-        // TODO: possibly undesired behavior, escapes argument though output should be unescaped and value is not passed as child\n-        $this->assertSame(self::ESCAPED_WRAPPED_STATIC_PROTECTED, $this->renderCode($viewHelper, '{test:test(output: \"<div>{value}</div>\")}'), 'Inline with static HTML');\n+        $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '{test:test(output: \"{value}\")}'), 'Inline output argument');\n+        $this->assertSame(self::UNESCAPED_WRAPPED, $this->renderCode($viewHelper, '{test:test(output: \"<div>{value}</div>\")}'), 'Inline with static HTML');\n     }\n \n     /*\n      * Escape children = false\n      * Escape output = false\n+     * Escape arguments = false\n      */\n \n     public function testWithEscapOutputFalseWithEscapeChildrenFalseWithoutContentOrOutputArguments()\n     {\n+        // Nothing is escaped because all escaping is off.\n         $viewHelper = (new MutableTestViewHelper())->withEscapeOutput(false)->withEscapeChildren(false);\n         $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '{value -> test:test()}'), 'Inline pass of variable');\n         $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '<test:test>{value}</test:test>'), 'Tag child variable');\n@@ -205,25 +200,135 @@ public function testWithEscapOutputFalseWithEscapeChildrenFalseWithoutContentOrO\n \n     public function testWithEscapeOutputFalseWithEscapeChildrenFalseWithContentArgument()\n     {\n-        $viewHelper = (new MutableTestViewHelper())->withContentArgument()->withEscapeOutput(false)->withEscapeChildren(false);\n+        // Child variable is not escaped because all escaping is off, including specific argument escaping.\n+        $viewHelper = (new MutableTestViewHelper())->withContentArgument(false)->withEscapeOutput(false)->withEscapeChildren(false);\n         $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '{value -> test:test()}'), 'Inline pass of variable');\n         $this->assertSame(self::UNESCAPED_WRAPPED, $this->renderCode($viewHelper, '<test:test><div>{value}</div></test:test>'), 'Tag child variable with static HTML');\n     }\n \n     public function testWithEscapeOutputFalseWithEscapeChildrenFalseWithOutputArgument()\n     {\n-        $viewHelper = (new MutableTestViewHelper())->withOutputArgument()->withEscapeOutput(false)->withEscapeChildren(false);\n+        // Argument is not escaped because all escaping is off, including specific argument escaping.\n+        $viewHelper = (new MutableTestViewHelper())->withOutputArgument(false)->withEscapeOutput(false)->withEscapeChildren(false);\n         $this->assertSame(self::UNESCAPED_WRAPPED, $this->renderCode($viewHelper, '<test:test output=\"<div>{value}</div>\" />'), 'Tag with variable and static HTML');\n         $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '<test:test output=\"{value}\" />'), 'Tag child variable');\n         $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '{test:test(output: value)}'), 'Inline output argument');\n+        $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '{f:if(condition: 1, then: value)}'), 'Inline output argument (f:if)');\n+        $this->assertSame(self::UNESCAPED_WRAPPED, $this->renderCode($viewHelper, '{test:test(output: \"<div>{value}</div>\")}'), 'Inline with static HTML');\n+    }\n \n-        // TODO: expected to break after introducing mandatory argument escaping on f:if then+else\n-        $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '{f:if(condition: 1, then: value)}'), 'Inline output argument (f:if)');\n+    /*\n+     * Escape children = false\n+     * Escape output = false\n+     * Escape arguments = null\n+     */\n \n-        // TODO: possibly undesired behavior, escapes argument though output should be unescaped and value is not passed as child\n+    public function testWithEscapeOutputFalseWithEscapeChildrenFalseWithEscapeArgumentNullWithContentArgument()\n+    {\n+        // All escaping is off, output will not be escaped\n+        $viewHelper = (new MutableTestViewHelper())->withContentArgument(null)->withEscapeOutput(false)->withEscapeChildren(false);\n+        $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '{value -> test:test()}'), 'Inline pass of variable');\n+        $this->assertSame(self::UNESCAPED_WRAPPED, $this->renderCode($viewHelper, '<test:test><div>{value}</div></test:test>'), 'Tag child variable with static HTML');\n+    }\n+\n+    public function testWithEscapeOutputFalseWithEscapeChildrenFalseWithEscapeArgumentNullWithOutputArgument()\n+    {\n+        // All escaping is off, output will not be escaped\n+        $viewHelper = (new MutableTestViewHelper())->withOutputArgument(null)->withEscapeOutput(false)->withEscapeChildren(false);\n+        $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '<test:test output=\"{value}\" />'), 'Tag child variable');\n+        $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '{test:test(output: value)}'), 'Inline output argument');\n+        $this->assertSame(self::UNESCAPED_WRAPPED, $this->renderCode($viewHelper, '<test:test output=\"<div>{value}</div>\" />'), 'Tag with variable and static HTML');\n+        $this->assertSame(self::UNESCAPED_WRAPPED, $this->renderCode($viewHelper, '{test:test(output: \"<div>{value}</div>\")}'), 'Inline with static HTML');\n+    }\n+\n+    /*\n+     * Escape children = false\n+     * Escape output = false\n+     * Escape arguments = true\n+     */\n+\n+    public function testWithEscapeOutputFalseWithEscapeChildrenFalseWithEscapeArgumentTrueWithContentArgument()\n+    {\n+        // Child variable is not escaped because both output and child escaping is off.\n+        $viewHelper = (new MutableTestViewHelper())->withContentArgument(true)->withEscapeOutput(false)->withEscapeChildren(false);\n+        $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '{value -> test:test()}'), 'Inline pass of variable');\n+        $this->assertSame(self::UNESCAPED_WRAPPED, $this->renderCode($viewHelper, '<test:test><div>{value}</div></test:test>'), 'Tag child variable with static HTML');\n+    }\n+\n+    public function testWithEscapeOutputFalseWithEscapeChildrenFalseWithEscapeArgumentTrueWithOutputArgument()\n+    {\n+        // Output argument is escaped despite both escape-output and escape-children being OFF, because argument was explicitly requested to be escaped.\n+        $viewHelper = (new MutableTestViewHelper())->withOutputArgument(true)->withEscapeOutput(false)->withEscapeChildren(false);\n+        $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '<test:test output=\"{value}\" />'), 'Tag child variable');\n+        $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '{test:test(output: value)}'), 'Inline output argument');\n+        $this->assertSame(self::ESCAPED_WRAPPED_STATIC_PROTECTED, $this->renderCode($viewHelper, '<test:test output=\"<div>{value}</div>\" />'), 'Tag with variable and static HTML');\n         $this->assertSame(self::ESCAPED_WRAPPED_STATIC_PROTECTED, $this->renderCode($viewHelper, '{test:test(output: \"<div>{value}</div>\")}'), 'Inline with static HTML');\n     }\n \n+    /*\n+     * Escape children = true\n+     * Escape output = false\n+     * Escape arguments = null\n+     */\n+\n+    public function testEscapeContentArgumentWithEscapeChildrenTrueWithEscapeOutputOffEscapesArgument()\n+    {\n+        // Content argument is escaped because because escape-output is OFF but escape-children is ON and content argument is treated as child.\n+        $viewHelper = (new MutableTestViewHelper())->withEscapeChildren(true)->withEscapeOutput(false)->withContentArgument(null);\n+        $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '{value -> test:test()}'), 'Inline pass of variable');\n+        $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '{test:test(content: value)}'), 'Inline with content argument');\n+        $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '<test:test content=\"{value}\" />'), 'Tag with content argument');\n+        $this->assertSame(self::ESCAPED, $this->renderCode($viewHelper, '<test:test>{value}</test:test>'), 'Tag with child variable');\n+    }\n+\n+    /*\n+     * Disabling otherwise enabled escaping\n+     */\n+\n+    public function testArgumentNotEscapedIfDisabledByFormatRawButNormallyWouldBeEscapedByOutputEscaping()\n+    {\n+        // Output is not escaped because VH is surrounded by f:format.raw, overriding escape-output, escape-children and escaping flag in ArgumentDefinition.\n+        $viewHelper = (new MutableTestViewHelper())->withEscapeOutput(true)->withEscapeChildren(true)->withContentArgument(true);\n+        $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '<f:format.raw>{value -> test:test()}</f:format.raw>'), 'Inline pass of variable surrounded by format.raw');\n+        $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '{value -> test:test() -> f:format.raw()}'), 'Inline pass of variable chained with format.raw');\n+    }\n+\n+    public function testArgumentNotEscapedEvenIfArgumentRequestedEscapedBecauseChainingWithFormatRawOverridesArgumentEscaping()\n+    {\n+        // Content argument is not escaped, despite flag in ArgumentDefinition, because argument is chained with f:format.raw which overrides argument escaping.\n+        $viewHelper = (new MutableTestViewHelper())->withEscapeOutput(false)->withEscapeChildren(false)->withContentArgument(true);\n+        $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '<test:test content=\"{value -> f:format.raw()}\" />'), 'Tag with argument chained with format.raw');\n+        $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '{test:test(content: \"{value -> f:format.raw()}\")}'), 'Inline with argument chained with format.raw');\n+    }\n+\n+    public function testArgumentNotEscapedIfDisabledByFormatRawButNormallyWouldBeEscapedByArgumentEscaping()\n+    {\n+        // Child is not escaped because VH is surrounded by f:format.raw, overriding escaping flag in ArgumentDefinition.\n+        $viewHelper = (new MutableTestViewHelper())->withEscapeOutput(false)->withEscapeChildren(false);\n+        $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '<f:format.raw>{value -> test:test()}</f:format.raw>'), 'Inline pass of variable surrounded by format.raw');\n+        $this->assertSame(self::UNESCAPED, $this->renderCode($viewHelper, '{value -> test:test() -> f:format.raw()}'), 'Inline pass of variable chained with format.raw');\n+    }\n+\n+    /*\n+     * TagBasedViewHelper attribute escaping\n+     */\n+\n+    public function testTagBasedViewHelperEscapesAttributes()\n+    {\n+        // Tag ViewHelper attributes are always escaped; the only way to disable this escaping is for the VH to manually add the attribute and explicitly disable conversion of special HTML chars.\n+        $viewHelper = new TagBasedTestViewHelper();\n+        $this->assertSame('<div class=\"' . self::ESCAPED . '\" />', $this->renderCode($viewHelper, '<test:test class=\"{value}\" />'), 'Tag attribute is escaped');\n+        $this->assertSame('<div data-foo=\"' . self::ESCAPED . '\" />', $this->renderCode($viewHelper, '<test:test data=\"{foo: value}\" />'), 'Tag data attribute values are escaped');\n+        $this->assertSame('<div foo=\"' . self::ESCAPED . '\" />', $this->renderCode($viewHelper, '<test:test additionalAttributes=\"{foo: value}\" />'), 'Tag additional attributes values are escaped');\n+        $this->assertSame('<div data-&gt;' . self::ESCAPED . '&lt;=\"1\" />', $this->renderCode($viewHelper, '<test:test data=\\'{\"><script>alert(1)</script><\": 1}\\' />'), 'Tag data attribute keys are escaped');\n+        $this->assertSame('<div &gt;' . self::ESCAPED . '&lt;=\"1\" />', $this->renderCode($viewHelper, '<test:test additionalAttributes=\\'{\"><script>alert(1)</script><\": 1}\\' />'), 'Tag additional attributes keys are escaped');\n+\n+        // Disabled: bug detected, handleAdditionalArguments on AbstractTagBasedViewHelper does assign the tag attribute, but following this call,\n+        // the initialize() method is called which resets the TagBuilder and in turn removes the data- prefixed attributes which are then not re-assigned.\n+        // Regression caused by https://github.com/TYPO3/Fluid/pull/419.\n+        //$this->assertSame('<div data-foo=\"' . self::ESCAPED . '\" />', $this->renderCode($viewHelper, '<test:test data-foo=\"{value}\" />'), 'Tag unregistered data attribute is escaped');\n+    }\n+\n     /**\n      * @return array\n      */\n@@ -279,11 +384,11 @@ public function getTemplateCodeFixturesAndExpectations()\n                 ['<strong>Bla</strong>'],\n                 ['&lt;strong&gt;Bla&lt;/strong&gt;'],\n             ],\n-            'EscapeChildrenEnabledAndEscapeOutputDisabled: Inline syntax with argument in quotes, does encode variable value (encoded before passed to VH)' => [\n+            'EscapeChildrenEnabledAndEscapeOutputDisabled: Inline syntax with argument in quotes, does not encode variable value' => [\n                 '{test:escapeChildrenEnabledAndEscapeOutputDisabled(content: \\'{settings.test}\\')}',\n                 $this->variables,\n-                ['&lt;strong&gt;Bla&lt;/strong&gt;'],\n                 ['<strong>Bla</strong>'],\n+                ['&lt;strong&gt;Bla&lt;/strong&gt;'],\n             ],\n             'EscapeChildrenEnabledAndEscapeOutputDisabled: Tag syntax with nested inline syntax and children rendering, does not encode variable value' => [\n                 '<test:escapeChildrenEnabledAndEscapeOutputDisabled content=\"{settings.test -> test:escapeChildrenEnabledAndEscapeOutputDisabled()}\" />',\n@@ -327,11 +432,11 @@ public function getTemplateCodeFixturesAndExpectations()\n                 ['<strong>Bla</strong>'],\n                 ['&lt;strong&gt;Bla&lt;/strong&gt;'],\n             ],\n-            'EscapeChildrenDisabledAndEscapeOutputDisabled: Inline syntax with argument in quotes, does encode variable value (encoded before passed to VH)' => [\n+            'EscapeChildrenDisabledAndEscapeOutputDisabled: Inline syntax with argument in quotes, does not encode variable value' => [\n                 '{test:escapeChildrenDisabledAndEscapeOutputDisabled(content: \\'{settings.test}\\')}',\n                 $this->variables,\n-                ['&lt;strong&gt;Bla&lt;/strong&gt;'],\n                 ['<strong>Bla</strong>'],\n+                ['&lt;strong&gt;Bla&lt;/strong&gt;'],\n             ],\n             'EscapeChildrenDisabledAndEscapeOutputDisabled: Tag syntax with nested inline syntax and children rendering, does not encode variable value' => [\n                 '<test:escapeChildrenDisabledAndEscapeOutputDisabled content=\"{settings.test -> test:escapeChildrenDisabledAndEscapeOutputDisabled()}\" />',"
        },
        {
          "filename": "tests/Functional/Fixtures/ViewHelpers/MutableTestViewHelper.php",
          "status": "modified",
          "additions": 9,
          "deletions": 4,
          "patch": "@@ -24,24 +24,24 @@ public function setEscapeOutput($escapeOutput): void\n         $this->escapeOutput = $escapeOutput;\n     }\n \n-    public function registerArgument($name, $type, $description, $required = false, $defaultValue = null)\n+    public function registerArgument($name, $type, $description, $required = false, $defaultValue = null, $escaped = null)\n     {\n-        return parent::registerArgument($name, $type, $description, $required, $defaultValue);\n+        return parent::registerArgument($name, $type, $description, $required, $defaultValue, $escaped);\n     }\n \n     public function withContentArgument($escaped = null): self\n     {\n         // TODO: set escaping behavior if $escaped !== null\n         $clone = clone $this;\n-        $clone->registerArgument('content', 'string', 'Content argument');\n+        $clone->registerArgument('content', 'string', 'Content argument', false, null, $escaped);\n         return $clone;\n     }\n \n     public function withOutputArgument($escaped = null): self\n     {\n         // TODO: set escaping behavior if $escaped !== null\n         $clone = clone $this;\n-        $clone->registerArgument('output', 'string', 'Content argument', true);\n+        $clone->registerArgument('output', 'string', 'Content argument', true, null, $escaped);\n         return $clone;\n     }\n \n@@ -59,6 +59,11 @@ public function withEscapeOutput($escapeOutput): self\n         return $clone;\n     }\n \n+    public function resolveContentArgumentName()\n+    {\n+        return 'content';\n+    }\n+\n     public function render()\n     {\n         $argumentDefinitions = $this->prepareArguments();"
        },
        {
          "filename": "tests/Functional/Fixtures/ViewHelpers/TagBasedTestViewHelper.php",
          "status": "added",
          "additions": 17,
          "deletions": 0,
          "patch": "@@ -0,0 +1,17 @@\n+<?php\n+namespace TYPO3Fluid\\Fluid\\Tests\\Functional\\Fixtures\\ViewHelpers;\n+\n+use TYPO3Fluid\\Fluid\\Core\\ViewHelper\\AbstractTagBasedViewHelper;\n+\n+class TagBasedTestViewHelper extends AbstractTagBasedViewHelper\n+{\n+    public function prepareArguments()\n+    {\n+        // Override to avoid the static cache of registered ViewHelper arguments; will always return\n+        // only those arguments that are registered in this particular instance.\n+        $this->argumentDefinitions = [];\n+        $this->registerUniversalTagAttributes();\n+        $this->initializeArguments();\n+        return $this->argumentDefinitions;\n+    }\n+}\n\\ No newline at end of file"
        },
        {
          "filename": "tests/Unit/Core/Parser/TemplateParserTest.php",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -450,7 +450,7 @@ public function objectAccessorHandlerCallsInitializeViewHelperAndAddItToStackIfV\n         );\n         $templateParser->setRenderingContext(new RenderingContextFixture());\n         $templateParser->expects($this->at(0))->method('recursiveArrayHandler')\n-            ->with('arguments: {0: \\'foo\\'}')->will($this->returnValue(['arguments' => ['foo']]));\n+            ->with($mockState, 'arguments: {0: \\'foo\\'}')->will($this->returnValue(['arguments' => ['foo']]));\n         $templateParser->expects($this->at(1))->method('initializeViewHelperAndAddItToStack')\n             ->with($mockState, 'f', 'format.printf', ['arguments' => ['foo']])->will($this->returnValue(true));\n         $templateParser->expects($this->at(2))->method('initializeViewHelperAndAddItToStack')\n@@ -1004,6 +1004,7 @@ public function dataProviderRecursiveArrayHandler()\n      */\n     public function testRecursiveArrayHandler($string, $expected)\n     {\n+        $state = new ParsingState();\n         $resolver = $this->getMock(ViewHelperResolver::class, ['isNamespaceIgnored']);\n         $resolver->expects($this->any())->method('isNamespaceIgnored')->willReturn(true);\n         $context = new RenderingContextFixture();\n@@ -1013,7 +1014,7 @@ public function testRecursiveArrayHandler($string, $expected)\n         $templateParser->setRenderingContext($context);\n         $method = new \\ReflectionMethod($templateParser, 'recursiveArrayHandler');\n         $method->setAccessible(true);\n-        $result = $method->invokeArgs($templateParser, [$string]);\n+        $result = $method->invokeArgs($templateParser, [$state, $string]);\n \n         $this->assertEquals($expected, $result);\n     }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 7,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "ece4e1e21b0db4ad3e89bba163f6ad33be0cecbe",
            "date": "2024-11-21T11:32:51Z",
            "author_login": "lolli42"
          },
          {
            "sha": "a013dfdc1b99c1b33a9e7fa41ecc10daada9249c",
            "date": "2024-11-20T02:16:00Z",
            "author_login": "lolli42"
          },
          {
            "sha": "5535e1fab578513a53dbfc6599993b9896aa04a3",
            "date": "2024-11-20T01:54:43Z",
            "author_login": "lolli42"
          },
          {
            "sha": "b3866017b7e3a7030644894e5173f30afceab43e",
            "date": "2024-11-20T01:40:23Z",
            "author_login": "lolli42"
          },
          {
            "sha": "336e10a1ea5730b2f8c2163b13c06572a282430d",
            "date": "2024-11-20T01:29:01Z",
            "author_login": "lolli42"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.0,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:N",
    "cwe_id": "CWE-79",
    "description": "TYPO3 Fluid before versions 2.0.8, 2.1.7, 2.2.4, 2.3.7, 2.4.4, 2.5.11 and 2.6.10 is vulnerable to Cross-Site Scripting. Three XSS vulnerabilities have been detected in Fluid: 1. TagBasedViewHelper allowed XSS through maliciously crafted additionalAttributes arrays by creating keys with attribute-closing quotes followed by HTML. When rendering such attributes, TagBuilder would not escape the keys. 2. ViewHelpers which used the CompileWithContentArgumentAndRenderStatic trait, and which declared escapeOutput = false, would receive the content argument in unescaped format. 3. Subclasses of AbstractConditionViewHelper would receive the then and else arguments in unescaped format. Update to versions 2.0.8, 2.1.7, 2.2.4, 2.3.7, 2.4.4, 2.5.11 or 2.6.10 of this typo3fluid/fluid package that fix the problem described. More details are available in the linked advisory.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-11-17T21:15:12.427",
    "last_modified": "2024-11-21T05:19:33.160",
    "fix_date": "2020-10-29T16:15:43Z"
  },
  "references": [
    {
      "url": "https://github.com/TYPO3/Fluid/commit/f20db4e74cf9803c6cffca2ed2f03e1b0b89d0dc",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/TYPO3/Fluid/security/advisories/GHSA-hpjm-3ww5-6cpf",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://typo3.org/security/advisory/typo3-core-sa-2020-009",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/TYPO3/Fluid/commit/f20db4e74cf9803c6cffca2ed2f03e1b0b89d0dc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/TYPO3/Fluid/security/advisories/GHSA-hpjm-3ww5-6cpf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://typo3.org/security/advisory/typo3-core-sa-2020-009",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:08.465442",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "Fluid",
    "owner": "TYPO3",
    "created_at": "2015-08-13T15:04:55Z",
    "updated_at": "2024-12-05T18:45:45Z",
    "pushed_at": "2024-12-08T15:30:28Z",
    "size": 5443,
    "stars": 154,
    "forks": 93,
    "open_issues": 49,
    "watchers": 154,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "2.0",
      "2.1",
      "2.2",
      "2.3",
      "2.4",
      "2.5",
      "2.6",
      "2.7",
      "2.8",
      "2.9",
      "2.10",
      "2.11",
      "2.12",
      "2.13",
      "2.14",
      "2.15",
      "2.16",
      "main"
    ],
    "languages": {
      "PHP": 1098049,
      "HTML": 2980
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-3.0"
    },
    "collected_at": "2025-01-14T17:02:12.607084"
  }
}