{
  "cve_id": "CVE-2020-26233",
  "github_data": {
    "repository": "microsoft/Git-Credential-Manager-Core",
    "fix_commit": "61c0388e064babb3b4e60d3ec269e8a07ab3bc76",
    "related_commits": [
      "61c0388e064babb3b4e60d3ec269e8a07ab3bc76",
      "61c0388e064babb3b4e60d3ec269e8a07ab3bc76"
    ],
    "patch_url": "https://github.com/microsoft/Git-Credential-Manager-Core/commit/61c0388e064babb3b4e60d3ec269e8a07ab3bc76.patch",
    "fix_commit_details": {
      "sha": "61c0388e064babb3b4e60d3ec269e8a07ab3bc76",
      "commit_date": "2020-11-17T12:19:55Z",
      "author": {
        "login": "mjcheetham",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merged PR 585167: [Security] Enumerate the PATH environment variable to locate programs on Windows",
        "length": 735,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 186,
        "additions": 141,
        "deletions": 45
      },
      "files": [
        {
          "filename": "src/shared/Microsoft.Git.CredentialManager.Tests/EnvironmentTests.cs",
          "status": "added",
          "additions": 71,
          "deletions": 0,
          "patch": "@@ -0,0 +1,71 @@\n+using System.Collections.Generic;\n+using Microsoft.Git.CredentialManager.Interop.Windows;\n+using Microsoft.Git.CredentialManager.Tests.Objects;\n+using Xunit;\n+\n+namespace Microsoft.Git.CredentialManager.Tests\n+{\n+    public class EnvironmentTests\n+    {\n+        [PlatformFact(Platforms.Windows)]\n+        public void WindowsEnvironment_TryLocateExecutable_NotExists_ReturnFalse()\n+        {\n+            string pathVar = @\"C:\\Users\\john.doe\\bin;C:\\Windows\\system32;C:\\Windows\";\n+            string execName = \"foo.exe\";\n+            var fs = new TestFileSystem();\n+            var envars = new Dictionary<string, string> {[\"PATH\"] = pathVar};\n+            var env = new WindowsEnvironment(fs, envars);\n+\n+            bool actualResult = env.TryLocateExecutable(execName, out string actualPath);\n+\n+            Assert.False(actualResult);\n+            Assert.Null(actualPath);\n+        }\n+\n+        [PlatformFact(Platforms.Windows)]\n+        public void WindowsEnvironment_TryLocateExecutable_Windows_Exists_ReturnTrueAndPath()\n+        {\n+            string pathVar = @\"C:\\Users\\john.doe\\bin;C:\\Windows\\system32;C:\\Windows\";\n+            string execName = \"foo.exe\";\n+            string expectedPath = @\"C:\\Windows\\system32\\foo.exe\";\n+            var fs = new TestFileSystem\n+            {\n+                Files = new Dictionary<string, byte[]>\n+                {\n+                    [@\"C:\\Windows\\system32\\foo.exe\"] = new byte[0],\n+                }\n+            };\n+            var envars = new Dictionary<string, string> {[\"PATH\"] = pathVar};\n+            var env = new WindowsEnvironment(fs, envars);\n+\n+            bool actualResult = env.TryLocateExecutable(execName, out string actualPath);\n+\n+            Assert.True(actualResult);\n+            Assert.Equal(expectedPath, actualPath);\n+        }\n+\n+        [PlatformFact(Platforms.Windows)]\n+        public void WindowsEnvironment_TryLocateExecutable_Windows_ExistsMultiple_ReturnTrueAndFirstPath()\n+        {\n+            string pathVar = @\"C:\\Users\\john.doe\\bin;C:\\Windows\\system32;C:\\Windows\";\n+            string execName = \"foo.exe\";\n+            string expectedPath = @\"C:\\Users\\john.doe\\bin\\foo.exe\";\n+            var fs = new TestFileSystem\n+            {\n+                Files = new Dictionary<string, byte[]>\n+                {\n+                    [@\"C:\\Users\\john.doe\\bin\\foo.exe\"] = new byte[0],\n+                    [@\"C:\\Windows\\system32\\foo.exe\"] = new byte[0],\n+                    [@\"C:\\Windows\\foo.exe\"] = new byte[0],\n+                }\n+            };\n+            var envars = new Dictionary<string, string> {[\"PATH\"] = pathVar};\n+            var env = new WindowsEnvironment(fs, envars);\n+\n+            bool actualResult = env.TryLocateExecutable(execName, out string actualPath);\n+\n+            Assert.True(actualResult);\n+            Assert.Equal(expectedPath, actualPath);\n+        }\n+    }\n+}"
        },
        {
          "filename": "src/shared/Microsoft.Git.CredentialManager/CommandContext.cs",
          "status": "modified",
          "additions": 26,
          "deletions": 3,
          "patch": "@@ -1,6 +1,7 @@\n // Copyright (c) Microsoft Corporation. All rights reserved.\n // Licensed under the MIT license.\n using System;\n+using System.IO;\n using Microsoft.Git.CredentialManager.Interop.Linux;\n using Microsoft.Git.CredentialManager.Interop.MacOS;\n using Microsoft.Git.CredentialManager.Interop.Posix;\n@@ -86,9 +87,10 @@ public CommandContext()\n                 SystemPrompts     = new WindowsSystemPrompts();\n                 Environment       = new WindowsEnvironment(FileSystem);\n                 Terminal          = new WindowsTerminal(Trace);\n+                string gitPath    = GetGitPath(Environment, FileSystem);\n                 Git               = new GitProcess(\n                                             Trace,\n-                                            Environment.LocateExecutable(\"git.exe\"),\n+                                            gitPath,\n                                             FileSystem.GetCurrentDirectory()\n                                         );\n                 Settings          = new Settings(Environment, Git);\n@@ -101,9 +103,10 @@ public CommandContext()\n                 SystemPrompts     = new MacOSSystemPrompts();\n                 Environment       = new PosixEnvironment(FileSystem);\n                 Terminal          = new PosixTerminal(Trace);\n+                string gitPath    = GetGitPath(Environment, FileSystem);\n                 Git               = new GitProcess(\n                                             Trace,\n-                                            Environment.LocateExecutable(\"git\"),\n+                                            gitPath,\n                                             FileSystem.GetCurrentDirectory()\n                                         );\n                 Settings          = new Settings(Environment, Git);\n@@ -117,9 +120,10 @@ public CommandContext()\n                 SystemPrompts     = new LinuxSystemPrompts();\n                 Environment       = new PosixEnvironment(FileSystem);\n                 Terminal          = new PosixTerminal(Trace);\n+                string gitPath    = GetGitPath(Environment, FileSystem);\n                 Git               = new GitProcess(\n                                             Trace,\n-                                            Environment.LocateExecutable(\"git\"),\n+                                            gitPath,\n                                             FileSystem.GetCurrentDirectory()\n                                         );\n                 Settings          = new Settings(Environment, Git);\n@@ -140,6 +144,25 @@ public CommandContext()\n             SystemPrompts.ParentWindowId = Settings.ParentWindowId;\n         }\n \n+        private static string GetGitPath(IEnvironment environment, IFileSystem fileSystem)\n+        {\n+            string programName = PlatformUtils.IsWindows() ? \"git.exe\" : \"git\";\n+\n+            // Use the GIT_EXEC_PATH environment variable if set\n+            if (environment.Variables.TryGetValue(Constants.EnvironmentVariables.GitExecutablePath,\n+                out string gitExecPath))\n+            {\n+                string candidatePath = Path.Combine(gitExecPath, programName);\n+                if (fileSystem.FileExists(candidatePath))\n+                {\n+                    return candidatePath;\n+                }\n+            }\n+\n+            // Otherwise try to locate the git(.exe) on the current PATH\n+            return environment.LocateExecutable(programName);\n+        }\n+\n         #region ICommandContext\n \n         public ISettings Settings { get; }"
        },
        {
          "filename": "src/shared/Microsoft.Git.CredentialManager/Constants.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -56,6 +56,7 @@ public static class EnvironmentVariables\n             public const string GcmCredNamespace      = \"GCM_NAMESPACE\";\n             public const string GcmCredentialStore    = \"GCM_CREDENTIAL_STORE\";\n             public const string GcmPlaintextStorePath = \"GCM_PLAINTEXT_STORE_PATH\";\n+            public const string GitExecutablePath     = \"GIT_EXEC_PATH\";\n         }\n \n         public static class Http"
        },
        {
          "filename": "src/shared/Microsoft.Git.CredentialManager/EnvironmentBase.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -2,6 +2,7 @@\n // Licensed under the MIT license.\n using System;\n using System.Collections.Generic;\n+using System.IO;\n using System.Linq;\n \n namespace Microsoft.Git.CredentialManager"
        },
        {
          "filename": "src/shared/Microsoft.Git.CredentialManager/InternalsVisibleTo.cs",
          "status": "added",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -0,0 +1,4 @@\n+using System.Runtime.CompilerServices;\n+\n+[assembly: InternalsVisibleTo(\"Microsoft.Git.CredentialManager.Tests\")]\n+"
        },
        {
          "filename": "src/shared/Microsoft.Git.CredentialManager/Interop/Posix/PosixEnvironment.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -33,6 +33,8 @@ protected override string[] SplitPathVariable(string value)\n \n         public override bool TryLocateExecutable(string program, out string path)\n         {\n+            // The \"which\" utility scans over the PATH and does not include the current working directory\n+            // (unlike the equivalent \"where.exe\" on Windows), which is exactly what we want. Let's use it.\n             const string whichPath = \"/usr/bin/which\";\n             var psi = new ProcessStartInfo(whichPath, program)\n             {"
        },
        {
          "filename": "src/shared/Microsoft.Git.CredentialManager/Interop/Windows/WindowsEnvironment.cs",
          "status": "modified",
          "additions": 20,
          "deletions": 25,
          "patch": "@@ -11,9 +11,14 @@ namespace Microsoft.Git.CredentialManager.Interop.Windows\n {\n     public class WindowsEnvironment : EnvironmentBase\n     {\n-        public WindowsEnvironment(IFileSystem fileSystem) : base(fileSystem)\n+        public WindowsEnvironment(IFileSystem fileSystem)\n+            : this(fileSystem, GetCurrentVariables()) { }\n+\n+        internal WindowsEnvironment(IFileSystem fileSystem, IReadOnlyDictionary<string, string> variables)\n+            : base(fileSystem)\n         {\n-            Variables = GetCurrentVariables();\n+            EnsureArgument.NotNull(variables, nameof(variables));\n+            Variables = variables;\n         }\n \n         #region EnvironmentBase\n@@ -67,34 +72,24 @@ public override void RemoveDirectoryFromPath(string directoryPath, EnvironmentVa\n \n         public override bool TryLocateExecutable(string program, out string path)\n         {\n-            string wherePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), \"where.exe\");\n-            var psi = new ProcessStartInfo(wherePath, program)\n-            {\n-                UseShellExecute = false,\n-                RedirectStandardOutput = true\n-            };\n-\n-            using (var where = new Process {StartInfo = psi})\n+            // Don't use \"where.exe\" on Windows as this includes the current working directory\n+            // and we don't want to enumerate this location; only the PATH.\n+            if (Variables.TryGetValue(\"PATH\", out string pathValue))\n             {\n-                where.Start();\n-                where.WaitForExit();\n-\n-                switch (where.ExitCode)\n+                string[] paths = SplitPathVariable(pathValue);\n+                foreach (var basePath in paths)\n                 {\n-                    case 0: // found\n-                        string stdout = where.StandardOutput.ReadToEnd();\n-                        string[] results = stdout.Split(new[] {'\\r', '\\n'}, StringSplitOptions.RemoveEmptyEntries);\n-                        path = results.First();\n+                    string candidatePath = Path.Combine(basePath, program);\n+                    if (FileSystem.FileExists(candidatePath))\n+                    {\n+                        path = candidatePath;\n                         return true;\n-\n-                    case 1: // not found\n-                        path = null;\n-                        return false;\n-\n-                    default:\n-                        throw new Exception($\"Unknown error locating '{program}' using where.exe. Exit code: {where.ExitCode}.\");\n+                    }\n                 }\n             }\n+\n+            path = null;\n+            return false;\n         }\n \n         #endregion"
        },
        {
          "filename": "src/shared/TestInfrastructure/Objects/TestCommandContext.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -20,7 +20,7 @@ public TestCommandContext()\n             CredentialStore = new TestCredentialStore();\n             HttpClientFactory = new TestHttpClientFactory();\n             Git = new TestGit();\n-            Environment = new TestEnvironment();\n+            Environment = new TestEnvironment(FileSystem);\n             SystemPrompts = new TestSystemPrompts();\n \n             Settings = new TestSettings {Environment = Environment, GitConfiguration = Git.GlobalConfiguration};"
        },
        {
          "filename": "src/shared/TestInfrastructure/Objects/TestEnvironment.cs",
          "status": "modified",
          "additions": 15,
          "deletions": 16,
          "patch": "@@ -9,12 +9,15 @@ namespace Microsoft.Git.CredentialManager.Tests.Objects\n {\n     public class TestEnvironment : IEnvironment\n     {\n+        private readonly IFileSystem _fileSystem;\n         private readonly IEqualityComparer<string> _pathComparer;\n         private readonly IEqualityComparer<string> _envarComparer;\n         private readonly string _envPathSeparator;\n \n-        public TestEnvironment(string envPathSeparator = null, IEqualityComparer<string> pathComparer = null, IEqualityComparer<string> envarComparer = null)\n+        public TestEnvironment(IFileSystem fileSystem = null, string envPathSeparator = null, IEqualityComparer<string> pathComparer = null, IEqualityComparer<string> envarComparer = null)\n         {\n+            _fileSystem = fileSystem ?? new TestFileSystem();\n+\n             // Use the current platform separators and comparison types by default\n             _envPathSeparator = envPathSeparator ?? (PlatformUtils.IsWindows() ? \";\" : \":\");\n \n@@ -28,16 +31,12 @@ public TestEnvironment(string envPathSeparator = null, IEqualityComparer<string>\n                                 ? StringComparer.Ordinal\n                                 : StringComparer.OrdinalIgnoreCase);\n \n-            _envPathSeparator = envPathSeparator;\n             Variables = new Dictionary<string, string>(_envarComparer);\n-            WhichFiles = new Dictionary<string, ICollection<string>>(_pathComparer);\n             Symlinks = new Dictionary<string, string>(_pathComparer);\n         }\n \n         public IDictionary<string, string> Variables { get; set; }\n \n-        public IDictionary<string, ICollection<string>> WhichFiles { get; set; }\n-\n         public IDictionary<string, string> Symlinks { get; set; }\n \n         public IList<string> Path\n@@ -82,18 +81,18 @@ public void RemoveDirectoryFromPath(string directoryPath, EnvironmentVariableTar\n \n         public bool TryLocateExecutable(string program, out string path)\n         {\n-            if (WhichFiles.TryGetValue(program, out ICollection<string> paths))\n+            if (Variables.TryGetValue(\"PATH\", out string pathValue))\n             {\n-                path = paths.First();\n-                return true;\n-            }\n-\n-            if (!System.IO.Path.HasExtension(program) && PlatformUtils.IsWindows())\n-            {\n-                // If we're testing on a Windows platform, don't have a file extension, and were unable to locate\n-                // the executable file.. try appending .exe.\n-                path = WhichFiles.TryGetValue($\"{program}.exe\", out paths) ? paths.First() : null;\n-                return !(path is null);\n+                string[] paths = pathValue.Split(new[]{_envPathSeparator}, StringSplitOptions.None);\n+                foreach (var basePath in paths)\n+                {\n+                    string candidatePath = System.IO.Path.Combine(basePath, program);\n+                    if (_fileSystem.FileExists(candidatePath))\n+                    {\n+                        path = candidatePath;\n+                        return true;\n+                    }\n+                }\n             }\n \n             path = null;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 5,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "21fda9f0826c8aaaa740cdc2f95438e0aebcd86b",
            "date": "2025-01-03T16:36:56Z",
            "author_login": "mjcheetham"
          },
          {
            "sha": "235d63649e820a26cb1c8d8f028b790a847d51fa",
            "date": "2024-12-27T20:14:20Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "2e505a6f7eb09144496039ee6585356c3d328be8",
            "date": "2024-12-09T10:54:30Z",
            "author_login": "mjcheetham"
          },
          {
            "sha": "4e26608e2d1bcce2de6de3499c73278c16eb4879",
            "date": "2024-12-09T10:54:06Z",
            "author_login": "mjcheetham"
          },
          {
            "sha": "b378f2a63637ae647e60d04035c34e8b3dd544e1",
            "date": "2024-11-15T20:06:34Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:C/C:H/I:H/A:N",
    "cwe_id": "CWE-706",
    "description": "Git Credential Manager Core (GCM Core) is a secure Git credential helper built on .NET Core that runs on Windows and macOS. In Git Credential Manager Core before version 2.0.289, when recursively cloning a Git repository on Windows with submodules, Git will first clone the top-level repository and then recursively clone all submodules by starting new Git processes from the top-level working directory. If a malicious git.exe executable is present in the top-level repository then this binary will be started by Git Credential Manager Core when attempting to read configuration, and not git.exe as found on the %PATH%. This only affects GCM Core on Windows, not macOS or Linux-based distributions. GCM Core version 2.0.289 contains the fix for this vulnerability, and is available from the project's GitHub releases page. GCM Core 2.0.289 is also bundled in the latest Git for Windows release; version 2.29.2(3). As a workaround, users should avoid recursively cloning untrusted repositories with the --recurse-submodules option.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-12-08T20:15:15.447",
    "last_modified": "2024-11-21T05:19:36.610",
    "fix_date": "2020-11-17T12:19:55Z"
  },
  "references": [
    {
      "url": "https://blog.blazeinfosec.com/attack-of-the-clones-2-git-command-client-remote-code-execution-strikes-back/",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://git-scm.com/docs/git-clone#Documentation/git-clone.txt---recurse-submodulesltpathspecgt",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/microsoft/Git-Credential-Manager-Core/commit/61c0388e064babb3b4e60d3ec269e8a07ab3bc76",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/microsoft/Git-Credential-Manager-Core/releases/tag/v2.0.289-beta",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/microsoft/Git-Credential-Manager-Core/security/advisories/GHSA-2gq7-ww4j-3m76",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://blog.blazeinfosec.com/attack-of-the-clones-2-git-command-client-remote-code-execution-strikes-back/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://git-scm.com/docs/git-clone#Documentation/git-clone.txt---recurse-submodulesltpathspecgt",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/microsoft/Git-Credential-Manager-Core/commit/61c0388e064babb3b4e60d3ec269e8a07ab3bc76",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/microsoft/Git-Credential-Manager-Core/releases/tag/v2.0.289-beta",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/microsoft/Git-Credential-Manager-Core/security/advisories/GHSA-2gq7-ww4j-3m76",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:08.497201",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "git-credential-manager",
    "owner": "microsoft",
    "created_at": "2018-11-20T14:50:07Z",
    "updated_at": "2025-01-14T13:43:34Z",
    "pushed_at": "2025-01-08T20:35:34Z",
    "size": 6598,
    "stars": 7135,
    "forks": 1896,
    "open_issues": 120,
    "watchers": 7135,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release"
    ],
    "languages": {
      "C#": 1785074,
      "Shell": 30540,
      "Inno Setup": 4085,
      "HTML": 3256,
      "PowerShell": 2611
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T17:28:58.846075"
  }
}