{
  "cve_id": "CVE-2020-26244",
  "github_data": {
    "repository": "OpenIDC/pyoidc",
    "fix_commit": "62f8d753fa17c8b1f29f8be639cf0b33afb02498",
    "related_commits": [
      "62f8d753fa17c8b1f29f8be639cf0b33afb02498",
      "62f8d753fa17c8b1f29f8be639cf0b33afb02498"
    ],
    "patch_url": "https://github.com/OpenIDC/pyoidc/commit/62f8d753fa17c8b1f29f8be639cf0b33afb02498.patch",
    "fix_commit_details": {
      "sha": "62f8d753fa17c8b1f29f8be639cf0b33afb02498",
      "commit_date": "2020-12-01T10:22:03Z",
      "author": {
        "login": "tpazderka",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-4fjv-pmhg-3rfg",
        "length": 59,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 422,
        "additions": 392,
        "deletions": 30
      },
      "files": [
        {
          "filename": "src/oic/oic/__init__.py",
          "status": "modified",
          "additions": 14,
          "deletions": 2,
          "patch": "@@ -44,6 +44,7 @@\n from oic.oauth2.message import ErrorResponse\n from oic.oauth2.message import Message\n from oic.oauth2.message import MessageFactory\n+from oic.oauth2.message import WrongSigningAlgorithm\n from oic.oauth2.util import get_or_post\n from oic.oic.message import SCOPE2CLAIMS\n from oic.oic.message import AccessTokenResponse\n@@ -1432,7 +1433,13 @@ def sign_enc_algs(self, typ):\n         return resp\n \n     def _verify_id_token(\n-        self, id_token, nonce=\"\", acr_values=None, auth_time=0, max_age=0\n+        self,\n+        id_token,\n+        nonce=\"\",\n+        acr_values=None,\n+        auth_time=0,\n+        max_age=0,\n+        response_type=\"\",\n     ):\n         \"\"\"\n         Verify IdToken.\n@@ -1465,6 +1472,11 @@ def _verify_id_token(\n         if _now > id_token[\"exp\"]:\n             raise OtherError(\"Passed best before date\")\n \n+        if response_type != [\"code\"] and id_token.jws_header[\"alg\"] == \"none\":\n+            raise WrongSigningAlgorithm(\n+                \"none is not allowed outside Authorization Flow.\"\n+            )\n+\n         if (\n             self.id_token_max_age\n             and _now > int(id_token[\"iat\"]) + self.id_token_max_age\n@@ -1491,7 +1503,7 @@ def verify_id_token(self, id_token, authn_req):\n         except KeyError:\n             pass\n \n-        for param in [\"acr_values\", \"max_age\"]:\n+        for param in [\"acr_values\", \"max_age\", \"response_type\"]:\n             try:\n                 kwa[param] = authn_req[param]\n             except KeyError:"
        },
        {
          "filename": "src/oic/oic/consumer.py",
          "status": "modified",
          "additions": 29,
          "deletions": 7,
          "patch": "@@ -3,6 +3,8 @@\n import warnings\n from typing import Dict\n from typing import Optional\n+from typing import Tuple\n+from typing import Union\n \n from oic import rndstr\n from oic.exception import AuthzError\n@@ -22,6 +24,7 @@\n from oic.oic.message import BackChannelLogoutRequest\n from oic.oic.message import Claims\n from oic.oic.message import ClaimsRequest\n+from oic.oic.message import IdToken\n from oic.utils import http_util\n from oic.utils.sanitize import sanitize\n from oic.utils.sdb import DictSessionBackend\n@@ -340,6 +343,7 @@ def begin(self, scope=\"\", response_type=\"\", use_nonce=False, path=\"\", **kwargs):\n         if self.debug:\n             _log_info(\"Redirecting to: %s\" % location)\n \n+        self.authz_req[areq[\"state\"]] = areq\n         return sid, location\n \n     def _parse_authz(self, query=\"\", **kwargs):\n@@ -364,7 +368,16 @@ def _parse_authz(self, query=\"\", **kwargs):\n         self.redirect_uris = [self.sdb[_state][\"redirect_uris\"]]\n         return aresp, _state\n \n-    def parse_authz(self, query=\"\", **kwargs):\n+    def parse_authz(\n+        self, query=\"\", **kwargs\n+    ) -> Union[\n+        http_util.BadRequest,\n+        Tuple[\n+            Optional[AuthorizationResponse],\n+            Optional[AccessTokenResponse],\n+            Optional[IdToken],\n+        ],\n+    ]:\n         \"\"\"\n         Parse authorization response from server.\n \n@@ -375,17 +388,20 @@ def parse_authz(self, query=\"\", **kwargs):\n         [\"id_token\"]\n         [\"id_token\", \"token\"]\n         [\"token\"]\n-\n-        :return: A AccessTokenResponse instance\n         \"\"\"\n         _log_info = logger.info\n         logger.debug(\"- authorization -\")\n \n+        # FIXME: This shouldn't be here... We should rather raise a sepcific Client error\n+        # That would simplify the return value of this function\n+        # and drop bunch of assertions from tests added in this commit.\n         if not query:\n             return http_util.BadRequest(\"Missing query\")\n \n         _log_info(\"response: %s\" % sanitize(query))\n \n+        if \"algs\" not in kwargs:\n+            kwargs[\"algs\"] = self.sign_enc_algs(\"id_token\")\n         if \"code\" in self.consumer_config[\"response_type\"]:\n             aresp, _state = self._parse_authz(query, **kwargs)\n \n@@ -410,9 +426,10 @@ def parse_authz(self, query=\"\", **kwargs):\n                 except KeyError:\n                     pass\n \n-            return aresp, atr, idt\n         elif \"token\" in self.consumer_config[\"response_type\"]:  # implicit flow\n             _log_info(\"Expect Access Token Response\")\n+            aresp = None\n+            _state = None\n             atr = self.parse_response(\n                 AccessTokenResponse,\n                 info=query,\n@@ -423,8 +440,8 @@ def parse_authz(self, query=\"\", **kwargs):\n             if isinstance(atr, ErrorResponse):\n                 raise TokenError(atr.get(\"error\"), atr)\n \n-            idt = None\n-            return None, atr, idt\n+            idt = atr.get(\"id_token\")\n+\n         else:  # only id_token\n             aresp, _state = self._parse_authz(query, **kwargs)\n \n@@ -437,8 +454,13 @@ def parse_authz(self, query=\"\", **kwargs):\n                     session_update(self.sso_db, _state, \"smid\", idt[\"sid\"])\n                 except KeyError:\n                     pass\n+            # Null the aresp as only id_token should be returned\n+            aresp = atr = None\n \n-            return None, None, idt\n+        # Verify the IdToken if it was present\n+        if idt is not None:\n+            self.verify_id_token(idt, self.authz_req.get(_state or atr[\"state\"]))\n+        return aresp, atr, idt\n \n     def complete(self, state):\n         \"\"\""
        },
        {
          "filename": "src/oic/oic/message.py",
          "status": "modified",
          "additions": 12,
          "deletions": 5,
          "patch": "@@ -313,17 +313,19 @@ def verify_id_token(instance, check_hash=False, **kwargs):\n \n     if check_hash:\n         _alg = idt.jws_header[\"alg\"]\n-        # What if _alg == 'none'\n-\n-        hfunc = \"HS\" + _alg[-3:]\n+        if _alg != \"none\":\n+            hfunc = \"HS\" + _alg[-3:]\n+        else:\n+            # This is allowed only for `code` and it needs to be checked by a Client\n+            hfunc = None\n \n-        if \"access_token\" in instance:\n+        if \"access_token\" in instance and hfunc is not None:\n             if \"at_hash\" not in idt:\n                 raise MissingRequiredAttribute(\"Missing at_hash property\", idt)\n             if idt[\"at_hash\"] != jws.left_hash(instance[\"access_token\"], hfunc):\n                 raise AtHashError(\"Failed to verify access_token hash\", idt)\n \n-        if \"code\" in instance:\n+        if \"code\" in instance and hfunc is not None:\n             if \"c_hash\" not in idt:\n                 raise MissingRequiredAttribute(\"Missing c_hash property\", idt)\n             if idt[\"c_hash\"] != jws.left_hash(instance[\"code\"], hfunc):\n@@ -780,6 +782,11 @@ def verify(self, **kwargs):\n         else:\n             if (_iat + _storage_time) < (_now - _skew):\n                 raise IATError(\"Issued too long ago\")\n+            if _now < (_iat - _skew):\n+                raise IATError(\"Issued in the future\")\n+\n+        if _exp < _iat:\n+            raise EXPError(\"Invalid expiration time\")\n \n         return True\n "
        },
        {
          "filename": "tests/test_oic_consumer.py",
          "status": "modified",
          "additions": 249,
          "deletions": 8,
          "patch": "@@ -10,12 +10,14 @@\n from jwkest.jwk import SYMKey\n \n from oic.oauth2.message import MissingSigningKey\n+from oic.oauth2.message import WrongSigningAlgorithm\n from oic.oic import DEF_SIGN_ALG\n from oic.oic import Server\n from oic.oic import response_types_to_grant_types\n from oic.oic.consumer import IGNORE\n from oic.oic.consumer import Consumer\n from oic.oic.consumer import clean_response\n+from oic.oic.message import AccessTokenRequest\n from oic.oic.message import AccessTokenResponse\n from oic.oic.message import AuthorizationResponse\n from oic.oic.message import IdToken\n@@ -147,6 +149,9 @@ def setup_consumer(self, session_db_factory):\n         self.consumer.userinfo_endpoint = \"https://example.com/userinfo\"  # type: ignore\n         self.consumer.client_secret = \"hemlig\"\n         self.consumer.secret_type = \"basic\"\n+        self.consumer.provider_info = ProviderConfigurationResponse(\n+            issuer=\"https://example.com\"\n+        )  # abs min\n \n     def test_backup_keys(self):\n         keys = self.consumer.__dict__.keys()\n@@ -326,6 +331,7 @@ def test_parse_authz(self):\n         self.consumer._backup(_state)\n \n         part = self.consumer.parse_authz(query=result.headers[\"location\"])\n+        assert isinstance(part, tuple)\n         atr = part[0]\n         assert part[1] is None\n         assert part[2] is None\n@@ -359,6 +365,7 @@ def test_parse_authz_implicit(self):\n             )\n \n         part = self.consumer.parse_authz(query=result.headers[\"location\"])\n+        assert isinstance(part, tuple)\n         assert part[0] is None\n         atr = part[1]\n         assert part[2] is None\n@@ -440,6 +447,7 @@ def test_complete_auth_token(self):\n \n         parsed = urlparse(result.headers[\"location\"])\n         part = self.consumer.parse_authz(query=parsed.query)\n+        assert isinstance(part, tuple)\n         auth = part[0]\n         acc = part[1]\n         assert part[2] is None\n@@ -456,8 +464,67 @@ def test_complete_auth_token_idtoken(self):\n         _state = \"state0\"\n         self.consumer.consumer_config[\"response_type\"] = [\"id_token\", \"token\"]\n         self.consumer.registration_response = RegistrationResponse(\n-            id_token_signed_response_alg=\"RS256\"\n+            id_token_signed_response_alg=\"HS256\"\n+        )\n+        self.consumer.authz_req = {}  # Store AuthzReq with state as key\n+\n+        args = {\n+            \"client_id\": self.consumer.client_id,\n+            \"response_type\": self.consumer.consumer_config[\"response_type\"],\n+            \"scope\": [\"openid\"],\n+            \"nonce\": \"nonce\",\n+        }\n+        token = IdToken(\n+            iss=\"https://example.com\",\n+            aud=\"client_1\",\n+            sub=\"some_sub\",\n+            exp=1565348600,\n+            iat=1565348300,\n+            nonce=\"nonce\",\n+        )\n+        location = (\n+            \"https://example.com/cb?state=state0&access_token=token&token_type=bearer&\"\n+            \"scope=openid&id_token={}\".format(\n+                token.to_jwt(key=[SYMKey(key=\"hemlig\")], algorithm=\"HS256\")\n+            )\n+        )\n+        with responses.RequestsMock() as rsps:\n+            rsps.add(\n+                responses.GET,\n+                \"https://example.com/authorization\",\n+                status=302,\n+                headers={\"location\": location},\n+            )\n+            result = self.consumer.do_authorization_request(\n+                state=_state, request_args=args\n+            )\n+            query = parse_qs(urlparse(result.request.url).query)\n+            assert query[\"client_id\"] == [\"client_1\"]\n+            assert query[\"scope\"] == [\"openid\"]\n+            assert query[\"response_type\"] == [\"id_token token\"]\n+            assert query[\"state\"] == [\"state0\"]\n+            assert query[\"nonce\"] == [\"nonce\"]\n+            assert query[\"redirect_uri\"] == [\"https://example.com/cb\"]\n+\n+        parsed = urlparse(result.headers[\"location\"])\n+\n+        with freeze_time(\"2019-08-09 11:00:00\"):\n+            part = self.consumer.parse_authz(query=parsed.query)\n+        assert isinstance(part, tuple)\n+        auth = part[0]\n+        atr = part[1]\n+        idt = part[2]\n+\n+        assert auth is None\n+        assert isinstance(atr, AccessTokenResponse)\n+        assert _eq(\n+            atr.keys(), [\"access_token\", \"id_token\", \"token_type\", \"state\", \"scope\"]\n         )\n+        assert isinstance(idt, IdToken)\n+\n+    def test_complete_auth_token_idtoken_no_alg_config(self):\n+        _state = \"state0\"\n+        self.consumer.consumer_config[\"response_type\"] = [\"id_token\", \"token\"]\n         self.consumer.provider_info = ProviderConfigurationResponse(\n             issuer=\"https://example.com\"\n         )  # abs min\n@@ -480,7 +547,7 @@ def test_complete_auth_token_idtoken(self):\n         location = (\n             \"https://example.com/cb?state=state0&access_token=token&token_type=bearer&\"\n             \"scope=openid&id_token={}\".format(\n-                token.to_jwt(key=KC_RSA.keys(), algorithm=\"RS256\")\n+                token.to_jwt(key=[SYMKey(key=\"hemlig\")], algorithm=\"HS256\")\n             )\n         )\n         with responses.RequestsMock() as rsps:\n@@ -504,23 +571,196 @@ def test_complete_auth_token_idtoken(self):\n         parsed = urlparse(result.headers[\"location\"])\n \n         with freeze_time(\"2019-08-09 11:00:00\"):\n-            part = self.consumer.parse_authz(\n-                query=parsed.query, algs=self.consumer.sign_enc_algs(\"id_token\")\n-            )\n+            part = self.consumer.parse_authz(query=parsed.query, algs={\"sign\": \"HS256\"})\n+        assert isinstance(part, tuple)\n         auth = part[0]\n         atr = part[1]\n-        assert part[2] is None\n+        idt = part[2]\n \n         assert auth is None\n         assert isinstance(atr, AccessTokenResponse)\n         assert _eq(\n             atr.keys(), [\"access_token\", \"id_token\", \"token_type\", \"state\", \"scope\"]\n         )\n+        assert isinstance(idt, IdToken)\n+\n+    def test_complete_auth_token_idtoken_none_cipher_code(self):\n+        _state = \"state0\"\n+        self.consumer.consumer_config[\"response_type\"] = [\"code\"]\n+        self.consumer.registration_response = RegistrationResponse(\n+            id_token_signed_response_alg=\"none\"\n+        )\n+        self.consumer.provider_info = ProviderConfigurationResponse(\n+            issuer=\"https://example.com\"\n+        )  # abs min\n+        self.consumer.authz_req = {}  # Store AuthzReq with state as key\n+        self.consumer.sdb[_state] = {\"redirect_uris\": []}\n+\n+        args = {\n+            \"client_id\": self.consumer.client_id,\n+            \"response_type\": self.consumer.consumer_config[\"response_type\"],\n+            \"scope\": [\"openid\"],\n+            \"nonce\": \"nonce\",\n+        }\n+        token = IdToken(\n+            iss=\"https://example.com\",\n+            aud=\"client_1\",\n+            sub=\"some_sub\",\n+            exp=1565348600,\n+            iat=1565348300,\n+            nonce=\"nonce\",\n+            at_hash=\"aaa\",\n+        )\n+        # Downgrade the algorithm to `none`\n+        location = (\n+            \"https://example.com/cb?state=state0&access_token=token&token_type=bearer&\"\n+            \"scope=openid&id_token={}\".format(\n+                token.to_jwt(key=KC_RSA.keys(), algorithm=\"none\")\n+            )\n+        )\n+        with responses.RequestsMock() as rsps:\n+            rsps.add(\n+                responses.GET,\n+                \"https://example.com/authorization\",\n+                status=302,\n+                headers={\"location\": location},\n+            )\n+            result = self.consumer.do_authorization_request(\n+                state=_state, request_args=args\n+            )\n+            query = parse_qs(urlparse(result.request.url).query)\n+            assert query[\"client_id\"] == [\"client_1\"]\n+            assert query[\"scope\"] == [\"openid\"]\n+            assert query[\"response_type\"] == [\"code\"]\n+            assert query[\"state\"] == [\"state0\"]\n+            assert query[\"nonce\"] == [\"nonce\"]\n+            assert query[\"redirect_uri\"] == [\"https://example.com/cb\"]\n+\n+        parsed = urlparse(result.headers[\"location\"])\n+\n+        with freeze_time(\"2019-08-09 11:00:00\"):\n+            part = self.consumer.parse_authz(query=parsed.query)\n+        assert isinstance(part, tuple)\n+        auth = part[0]\n+        atr = part[1]\n+        idt = part[2]\n+\n+        assert isinstance(auth, AuthorizationResponse)\n+        assert isinstance(atr, AccessTokenResponse)\n+        assert _eq(\n+            atr.keys(), [\"access_token\", \"id_token\", \"token_type\", \"state\", \"scope\"]\n+        )\n+        assert isinstance(idt, IdToken)\n+\n+    def test_complete_auth_token_idtoken_none_cipher_token(self):\n+        _state = \"state0\"\n+        self.consumer.consumer_config[\"response_type\"] = [\"token\"]\n+        self.consumer.registration_response = RegistrationResponse(\n+            id_token_signed_response_alg=\"none\"\n+        )\n+        self.consumer.provider_info = ProviderConfigurationResponse(\n+            issuer=\"https://example.com\"\n+        )  # abs min\n+        self.consumer.authz_req = {}  # Store AuthzReq with state as key\n+        self.consumer.sdb[_state] = {\"redirect_uris\": []}\n+\n+        args = {\n+            \"client_id\": self.consumer.client_id,\n+            \"response_type\": self.consumer.consumer_config[\"response_type\"],\n+            \"scope\": [\"openid\"],\n+            \"nonce\": \"nonce\",\n+        }\n+        token = IdToken(\n+            iss=\"https://example.com\",\n+            aud=\"client_1\",\n+            sub=\"some_sub\",\n+            exp=1565348600,\n+            iat=1565348300,\n+            nonce=\"nonce\",\n+        )\n+        # Downgrade the algorithm to `none`\n+        location = (\n+            \"https://example.com/cb?state=state0&access_token=token&token_type=bearer&\"\n+            \"scope=openid&id_token={}\".format(\n+                token.to_jwt(key=KC_RSA.keys(), algorithm=\"none\")\n+            )\n+        )\n+        with responses.RequestsMock() as rsps:\n+            rsps.add(\n+                responses.GET,\n+                \"https://example.com/authorization\",\n+                status=302,\n+                headers={\"location\": location},\n+            )\n+            result = self.consumer.do_authorization_request(\n+                state=_state, request_args=args\n+            )\n+            query = parse_qs(urlparse(result.request.url).query)\n+            assert query[\"client_id\"] == [\"client_1\"]\n+            assert query[\"scope\"] == [\"openid\"]\n+            assert query[\"response_type\"] == [\"token\"]\n+            assert query[\"state\"] == [\"state0\"]\n+            assert query[\"nonce\"] == [\"nonce\"]\n+            assert query[\"redirect_uri\"] == [\"https://example.com/cb\"]\n+\n+        parsed = urlparse(result.headers[\"location\"])\n \n         with freeze_time(\"2019-08-09 11:00:00\"):\n-            self.consumer.verify_id_token(\n-                atr[\"id_token\"], self.consumer.authz_req[atr[\"state\"]]\n+            with pytest.raises(WrongSigningAlgorithm):\n+                self.consumer.parse_authz(query=parsed.query)\n+\n+    def test_complete_auth_token_idtoken_cipher_downgrade(self):\n+        _state = \"state0\"\n+        self.consumer.consumer_config[\"response_type\"] = [\"id_token\", \"token\"]\n+        self.consumer.provider_info = ProviderConfigurationResponse(\n+            issuer=\"https://example.com\"\n+        )  # abs min\n+        self.consumer.authz_req = {}  # Store AuthzReq with state as key\n+\n+        args = {\n+            \"client_id\": self.consumer.client_id,\n+            \"response_type\": self.consumer.consumer_config[\"response_type\"],\n+            \"scope\": [\"openid\"],\n+            \"nonce\": \"nonce\",\n+        }\n+        token = IdToken(\n+            iss=\"https://example.com\",\n+            aud=\"client_1\",\n+            sub=\"some_sub\",\n+            exp=1565348600,\n+            iat=1565348300,\n+            nonce=\"nonce\",\n+        )\n+        # Downgrade the algorithm to `none`\n+        location = (\n+            \"https://example.com/cb?state=state0&access_token=token&token_type=bearer&\"\n+            \"scope=openid&id_token={}\".format(\n+                token.to_jwt(key=KC_RSA.keys(), algorithm=\"none\")\n+            )\n+        )\n+        with responses.RequestsMock() as rsps:\n+            rsps.add(\n+                responses.GET,\n+                \"https://example.com/authorization\",\n+                status=302,\n+                headers={\"location\": location},\n+            )\n+            result = self.consumer.do_authorization_request(\n+                state=_state, request_args=args\n             )\n+            query = parse_qs(urlparse(result.request.url).query)\n+            assert query[\"client_id\"] == [\"client_1\"]\n+            assert query[\"scope\"] == [\"openid\"]\n+            assert query[\"response_type\"] == [\"id_token token\"]\n+            assert query[\"state\"] == [\"state0\"]\n+            assert query[\"nonce\"] == [\"nonce\"]\n+            assert query[\"redirect_uri\"] == [\"https://example.com/cb\"]\n+\n+        parsed = urlparse(result.headers[\"location\"])\n+\n+        with freeze_time(\"2019-08-09 11:00:00\"):\n+            with pytest.raises(WrongSigningAlgorithm):\n+                self.consumer.parse_authz(query=parsed.query)\n \n     def test_userinfo(self):\n         _state = \"state0\"\n@@ -920,6 +1160,7 @@ def test_get_session_management_id(self):\n         self.consumer.sdb[_state] = {\"redirect_uris\": [\"https://example.org/cb\"]}\n         resp = AuthorizationResponse(id_token=_signed_jwt, state=_state)\n         self.consumer.consumer_config[\"response_type\"] = [\"id_token\"]\n+        self.consumer.authz_req[_state] = AccessTokenRequest(nonce=\"KUEYfRM2VzKDaaKD\")\n         self.consumer.parse_authz(resp.to_urlencoded())\n         assert self.consumer.sso_db[\"state\"][\"smid\"] == smid\n         assert session_get(self.consumer.sso_db, \"smid\", smid) == [_state]"
        },
        {
          "filename": "tests/test_oic_consumer_logout.py",
          "status": "modified",
          "additions": 15,
          "deletions": 6,
          "patch": "@@ -159,13 +159,16 @@ def test_logout_with_sub(self):\n             \"openid\", \"code\", path=\"https://example.com\"\n         )\n         resp = self.provider.authorization_endpoint(request=request_location)\n-        aresp = self.consumer.parse_authz(resp.message)\n+        part = self.consumer.parse_authz(resp.message)\n+        assert isinstance(part, tuple)\n+        aresp = part[0]\n+        assert aresp\n \n         assert self.consumer.sdb[sid][\"issuer\"] == self.provider.baseurl\n \n         # Simulate an accesstoken request\n         areq = AccessTokenRequest(\n-            code=aresp[0][\"code\"],\n+            code=aresp[\"code\"],\n             client_id=CLIENT_ID,\n             redirect_uri=\"http://example.com/authz\",\n             client_secret=self.consumer.client_secret,\n@@ -228,13 +231,16 @@ def test_logout_without_sub(self):\n             \"openid\", \"code\", path=\"https://example.com\"\n         )\n         resp = self.provider.authorization_endpoint(request=request_location)\n-        aresp = self.consumer.parse_authz(resp.message)\n+        part = self.consumer.parse_authz(resp.message)\n+        assert isinstance(part, tuple)\n+        aresp = part[0]\n+        assert aresp\n \n         assert self.consumer.sdb[sid][\"issuer\"] == self.provider.baseurl\n \n         # Simulate an accesstoken request\n         areq = AccessTokenRequest(\n-            code=aresp[0][\"code\"],\n+            code=aresp[\"code\"],\n             client_id=CLIENT_ID,\n             redirect_uri=\"http://example.com/authz\",\n             client_secret=self.consumer.client_secret,\n@@ -308,13 +314,16 @@ def test_sso_db_dict(self):\n             \"openid\", \"code\", path=\"https://example.com\"\n         )\n         resp = self.provider.authorization_endpoint(request=request_location)\n-        aresp = _consumer.parse_authz(resp.message)\n+        part = _consumer.parse_authz(resp.message)\n+        assert isinstance(part, tuple)\n+        aresp = part[0]\n+        assert aresp\n \n         assert _consumer.sdb[sid][\"issuer\"] == self.provider.baseurl\n \n         # Simulate an accesstoken request\n         areq = AccessTokenRequest(\n-            code=aresp[0][\"code\"],\n+            code=aresp[\"code\"],\n             client_id=CLIENT_ID,\n             redirect_uri=\"http://example.com/authz\",\n             client_secret=_consumer.client_secret,"
        },
        {
          "filename": "tests/test_oic_message.py",
          "status": "modified",
          "additions": 66,
          "deletions": 0,
          "patch": "@@ -5,6 +5,7 @@\n from urllib.parse import urlencode\n \n import pytest\n+from freezegun import freeze_time\n from jwkest import BadSignature\n from jwkest.jwk import SYMKey\n from jwkest.jws import left_hash\n@@ -24,7 +25,9 @@\n from oic.oic.message import BackChannelLogoutRequest\n from oic.oic.message import CHashError\n from oic.oic.message import Claims\n+from oic.oic.message import EXPError\n from oic.oic.message import FrontChannelLogoutRequest\n+from oic.oic.message import IATError\n from oic.oic.message import IdToken\n from oic.oic.message import LogoutToken\n from oic.oic.message import OpenIDSchema\n@@ -609,6 +612,69 @@ def test_token_type(self):\n             at.verify()\n \n \n+class TestIdToken(object):\n+    \"\"\"Unittests for IdToken class.\"\"\"\n+\n+    @freeze_time(\"2020-01-01 11:00:00\")\n+    def test_verify_iat_in_future(self):\n+        now = time_util.utc_time_sans_frac()\n+\n+        idt = IdToken(\n+            **{\n+                \"sub\": \"553df2bcf909104751cfd8b2\",\n+                \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n+                \"auth_time\": 1441364872,\n+                \"azp\": \"554295ce3770612820620000\",\n+                \"at_hash\": \"L4Ign7TCAD_EppRbHAuCyw\",\n+                \"iat\": now + 7200,\n+                \"exp\": now + 3600,\n+                \"iss\": \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n+            }\n+        )\n+\n+        with pytest.raises(IATError):\n+            idt.verify()\n+\n+    @freeze_time(\"2020-01-01 11:00:00\")\n+    def test_verify_iat_in_future_expired(self):\n+        now = time_util.utc_time_sans_frac()\n+\n+        idt = IdToken(\n+            **{\n+                \"sub\": \"553df2bcf909104751cfd8b2\",\n+                \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n+                \"auth_time\": 1441364872,\n+                \"azp\": \"554295ce3770612820620000\",\n+                \"at_hash\": \"L4Ign7TCAD_EppRbHAuCyw\",\n+                \"iat\": now + 3600,\n+                \"exp\": now,\n+                \"iss\": \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n+            }\n+        )\n+\n+        with pytest.raises(EXPError):\n+            idt.verify(skew=7200)\n+\n+    @freeze_time(\"2020-01-01 11:00:00\")\n+    def test_verify_iat_in_future_skew(self):\n+        now = time_util.utc_time_sans_frac()\n+\n+        idt = IdToken(\n+            **{\n+                \"sub\": \"553df2bcf909104751cfd8b2\",\n+                \"aud\": [\"5542958437706128204e0000\", \"554295ce3770612820620000\"],\n+                \"auth_time\": 1441364872,\n+                \"azp\": \"554295ce3770612820620000\",\n+                \"at_hash\": \"L4Ign7TCAD_EppRbHAuCyw\",\n+                \"iat\": now + 7200,\n+                \"exp\": now + 7600,\n+                \"iss\": \"https://sso.qa.7pass.ctf.prosiebensat1.com\",\n+            }\n+        )\n+\n+        idt.verify(skew=7200)\n+\n+\n def test_id_token():\n     _now = time_util.utc_time_sans_frac()\n "
        },
        {
          "filename": "tests/test_oic_provider.py",
          "status": "modified",
          "additions": 7,
          "deletions": 2,
          "patch": "@@ -38,6 +38,7 @@\n from oic.oic.message import IdToken\n from oic.oic.message import Message\n from oic.oic.message import OpenIDSchema\n+from oic.oic.message import ProviderConfigurationResponse\n from oic.oic.message import RefreshAccessTokenRequest\n from oic.oic.message import RegistrationRequest\n from oic.oic.message import RegistrationResponse\n@@ -224,6 +225,9 @@ def create_provider(self, session_db_factory):\n         self.cons.keyjar.import_jwks(\n             self.provider.keyjar.export_jwks(), self.cons.issuer\n         )\n+        self.cons.provider_info = ProviderConfigurationResponse(\n+            issuer=SERVER_INFO[\"issuer\"]\n+        )\n \n         self.cons2 = Consumer(\n             {}, CONSUMER_CONFIG.copy(), CLIENT_CONFIG_2, server_info=SERVER_INFO\n@@ -373,6 +377,7 @@ def test_authenticated(self):\n \n         part = self.cons.parse_authz(query=resp.message)\n \n+        assert isinstance(part, tuple)\n         aresp = part[0]\n         assert part[1] is None\n         assert part[2] is None\n@@ -410,9 +415,10 @@ def test_authenticated_hybrid(self):\n \n         part = self.cons.parse_authz(resp.message)\n \n+        assert isinstance(part, tuple)\n         aresp = part[0]\n         assert part[1] is None\n-        assert part[2] is not None\n+        id_token = part[2]\n \n         assert isinstance(aresp, AuthorizationResponse)\n         assert _eq(aresp.keys(), [\"scope\", \"state\", \"id_token\", \"client_id\", \"code\"])\n@@ -421,7 +427,6 @@ def test_authenticated_hybrid(self):\n             self.cons.grant[_state].keys(),\n             [\"code\", \"id_token\", \"tokens\", \"exp_in\", \"grant_expiration_time\", \"seed\"],\n         )\n-        id_token = part[2]\n         assert isinstance(id_token, IdToken)\n         assert _eq(\n             id_token.keys(),"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "9307f7d7cdaaf4b7d2d737adb6b3bf5862dc4f1f",
            "date": "2025-01-13T09:35:16Z",
            "author_login": "tpazderka"
          },
          {
            "sha": "3223b9fd8c6a62dd71f640407fd90b8046c50e02",
            "date": "2025-01-10T09:42:33Z",
            "author_login": "tpazderka"
          },
          {
            "sha": "0bd1eadcefc5ccb7ef6c69d9b631537a7d3cfe30",
            "date": "2024-11-27T09:29:48Z",
            "author_login": "tpazderka"
          },
          {
            "sha": "ad2eb88c6a5147c1979edda442b9703525eec8cc",
            "date": "2024-11-19T09:19:05Z",
            "author_login": "tpazderka"
          },
          {
            "sha": "59b2965dc8f5f487ba24d148911ac2999d7bbb57",
            "date": "2024-11-19T09:09:34Z",
            "author_login": "tpazderka"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-325",
    "description": "Python oic is a Python OpenID Connect implementation. In Python oic before version 1.2.1, there are several related cryptographic issues affecting client implementations that use the library. The issues are: 1) The IdToken signature algorithm was not checked automatically, but only if the expected algorithm was passed in as a kwarg. 2) JWA `none` algorithm was allowed in all flows. 3) oic.consumer.Consumer.parse_authz returns an unverified IdToken. The verification of the token was left to the discretion of the implementator. 4) iat claim was not checked for sanity (i.e. it could be in the future). These issues are patched in version 1.2.1.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-12-02T20:15:13.430",
    "last_modified": "2024-11-21T05:19:38.187",
    "fix_date": "2020-12-01T10:22:03Z"
  },
  "references": [
    {
      "url": "https://github.com/OpenIDC/pyoidc/commit/62f8d753fa17c8b1f29f8be639cf0b33afb02498",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenIDC/pyoidc/releases/tag/1.2.1",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenIDC/pyoidc/security/advisories/GHSA-4fjv-pmhg-3rfg",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://pypi.org/project/oic/",
      "source": "security-advisories@github.com",
      "tags": [
        "Product",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenIDC/pyoidc/commit/62f8d753fa17c8b1f29f8be639cf0b33afb02498",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenIDC/pyoidc/releases/tag/1.2.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenIDC/pyoidc/security/advisories/GHSA-4fjv-pmhg-3rfg",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://pypi.org/project/oic/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:08.487217",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "pyoidc",
    "owner": "OpenIDC",
    "created_at": "2011-11-10T08:28:04Z",
    "updated_at": "2025-01-13T09:35:22Z",
    "pushed_at": "2025-01-13T09:35:19Z",
    "size": 8326,
    "stars": 719,
    "forks": 259,
    "open_issues": 74,
    "watchers": 719,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Python": 1466168,
      "JavaScript": 132438,
      "Mako": 40054,
      "HTML": 5179,
      "Dockerfile": 4776,
      "Shell": 3535,
      "Makefile": 2446,
      "Jinja": 1642,
      "Elixir": 1461,
      "CSS": 157
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T21:42:37.247318"
  }
}