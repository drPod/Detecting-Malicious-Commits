{
  "cve_id": "CVE-2020-26247",
  "github_data": {
    "repository": "sparklemotion/nokogiri",
    "fix_commit": "9c87439d9afa14a365ff13e73adc809cb2c3d97b",
    "related_commits": [
      "9c87439d9afa14a365ff13e73adc809cb2c3d97b",
      "9c87439d9afa14a365ff13e73adc809cb2c3d97b"
    ],
    "patch_url": "https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b.patch",
    "fix_commit_details": {
      "sha": "9c87439d9afa14a365ff13e73adc809cb2c3d97b",
      "commit_date": "2020-11-23T05:47:02Z",
      "author": {
        "login": "flavorjones",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "feat: XML::Schema and RelaxNG creation accept optional ParseOptions",
        "length": 412,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 226,
        "additions": 182,
        "deletions": 44
      },
      "files": [
        {
          "filename": "ext/java/nokogiri/XmlRelaxng.java",
          "status": "modified",
          "additions": 9,
          "deletions": 2,
          "patch": "@@ -56,6 +56,7 @@\n import org.jruby.RubyClass;\n import org.jruby.anno.JRubyClass;\n import org.jruby.runtime.ThreadContext;\n+import org.jruby.runtime.builtin.IRubyObject;\n import org.w3c.dom.Document;\n import org.xml.sax.ErrorHandler;\n import org.xml.sax.SAXException;\n@@ -78,11 +79,17 @@ private void setVerifier(Verifier verifier) {\n         this.verifier = verifier;\n     }\n     \n-    static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source) {\n+    static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source, IRubyObject parseOptions) {\n         Ruby runtime = context.getRuntime();\n         XmlRelaxng xmlRelaxng = (XmlRelaxng) NokogiriService.XML_RELAXNG_ALLOCATOR.allocate(runtime, klazz);\n+\n+        if (parseOptions == null) {\n+            parseOptions = defaultParseOptions(context.getRuntime());\n+        }\n+\n         xmlRelaxng.setInstanceVariable(\"@errors\", runtime.newEmptyArray());\n-        \n+        xmlRelaxng.setInstanceVariable(\"@parse_options\", parseOptions);\n+\n         try {\n             Schema schema = xmlRelaxng.getSchema(source, context);\n             xmlRelaxng.setVerifier(schema.newVerifier());"
        },
        {
          "filename": "ext/java/nokogiri/XmlSchema.java",
          "status": "modified",
          "additions": 34,
          "deletions": 13,
          "patch": "@@ -106,10 +106,16 @@ private void setValidator(Validator validator) {\n         this.validator = validator;\n     }\n \n-    static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source) {\n+    static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source, IRubyObject parseOptions) {\n         Ruby runtime = context.getRuntime();\n         XmlSchema xmlSchema = (XmlSchema) NokogiriService.XML_SCHEMA_ALLOCATOR.allocate(runtime, klazz);\n+\n+        if (parseOptions == null) {\n+            parseOptions = defaultParseOptions(context.getRuntime());\n+        }\n+\n         xmlSchema.setInstanceVariable(\"@errors\", runtime.newEmptyArray());\n+        xmlSchema.setInstanceVariable(\"@parse_options\", parseOptions);\n \n         try {\n             SchemaErrorHandler error_handler = new SchemaErrorHandler(context.getRuntime(), (RubyArray)xmlSchema.getInstanceVariable(\"@errors\"));\n@@ -121,14 +127,24 @@ static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, So\n         }\n     }\n \n+    protected static IRubyObject defaultParseOptions(Ruby runtime) {\n+        return ((RubyClass)runtime.getClassFromPath(\"Nokogiri::XML::ParseOptions\")).getConstant(\"DEFAULT_SCHEMA\");\n+    }\n+\n     /*\n      * call-seq:\n      *  from_document(doc)\n      *\n      * Create a new Schema from the Nokogiri::XML::Document +doc+\n      */\n-    @JRubyMethod(meta=true)\n-    public static IRubyObject from_document(ThreadContext context, IRubyObject klazz, IRubyObject document) {\n+    @JRubyMethod(meta=true, required=1, optional=1)\n+    public static IRubyObject from_document(ThreadContext context, IRubyObject klazz, IRubyObject[] args) {\n+        IRubyObject document = args[0];\n+        IRubyObject parseOptions = null;\n+        if (args.length > 1) {\n+            parseOptions = args[1];\n+        }\n+\n         XmlDocument doc = ((XmlDocument) ((XmlNode) document).document(context));\n \n         RubyArray errors = (RubyArray) doc.getInstanceVariable(\"@errors\");\n@@ -144,25 +160,30 @@ public static IRubyObject from_document(ThreadContext context, IRubyObject klazz\n             source.setSystemId(uri.convertToString().asJavaString());\n         }\n \n-        return getSchema(context, (RubyClass)klazz, source);\n+        return getSchema(context, (RubyClass)klazz, source, parseOptions);\n     }\n \n-    private static IRubyObject getSchema(ThreadContext context, RubyClass klazz, Source source) {\n+    @JRubyMethod(meta=true, required=1, optional=1)\n+    public static IRubyObject read_memory(ThreadContext context, IRubyObject klazz, IRubyObject[] args) {\n+        IRubyObject content = args[0];\n+        IRubyObject parseOptions = null;\n+        if (args.length > 1) {\n+            parseOptions = args[1];\n+        }\n+        String data = content.convertToString().asJavaString();\n+        return getSchema(context, (RubyClass) klazz, new StreamSource(new StringReader(data)), parseOptions);\n+    }\n+\n+    private static IRubyObject getSchema(ThreadContext context, RubyClass klazz, Source source, IRubyObject parseOptions) {\n         String moduleName = klazz.getName();\n         if (\"Nokogiri::XML::Schema\".equals(moduleName)) {\n-            return XmlSchema.createSchemaInstance(context, klazz, source);\n+            return XmlSchema.createSchemaInstance(context, klazz, source, parseOptions);\n         } else if (\"Nokogiri::XML::RelaxNG\".equals(moduleName)) {\n-            return XmlRelaxng.createSchemaInstance(context, klazz, source);\n+            return XmlRelaxng.createSchemaInstance(context, klazz, source, parseOptions);\n         }\n         return context.getRuntime().getNil();\n     }\n \n-    @JRubyMethod(meta=true)\n-    public static IRubyObject read_memory(ThreadContext context, IRubyObject klazz, IRubyObject content) {\n-        String data = content.convertToString().asJavaString();\n-        return getSchema(context, (RubyClass) klazz, new StreamSource(new StringReader(data)));\n-    }\n-\n     @JRubyMethod(visibility=Visibility.PRIVATE)\n     public IRubyObject validate_document(ThreadContext context, IRubyObject document) {\n         return validate_document_or_file(context, (XmlDocument)document);"
        },
        {
          "filename": "ext/nokogiri/xml_relax_ng.c",
          "status": "modified",
          "additions": 28,
          "deletions": 11,
          "patch": "@@ -53,16 +53,24 @@ static VALUE validate_document(VALUE self, VALUE document)\n  *\n  * Create a new RelaxNG from the contents of +string+\n  */\n-static VALUE read_memory(VALUE klass, VALUE content)\n+static VALUE read_memory(int argc, VALUE *argv, VALUE klass)\n {\n-  xmlRelaxNGParserCtxtPtr ctx = xmlRelaxNGNewMemParserCtxt(\n-      (const char *)StringValuePtr(content),\n-      (int)RSTRING_LEN(content)\n-  );\n+  VALUE content;\n+  VALUE parse_options;\n+  xmlRelaxNGParserCtxtPtr ctx;\n   xmlRelaxNGPtr schema;\n-  VALUE errors = rb_ary_new();\n+  VALUE errors;\n   VALUE rb_schema;\n+  int scanned_args = 0;\n+\n+  scanned_args = rb_scan_args(argc, argv, \"11\", &content, &parse_options);\n+  if (scanned_args == 1) {\n+    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n+  }\n \n+  ctx = xmlRelaxNGNewMemParserCtxt((const char *)StringValuePtr(content), (int)RSTRING_LEN(content));\n+\n+  errors = rb_ary_new();\n   xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n \n #ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n@@ -90,6 +98,7 @@ static VALUE read_memory(VALUE klass, VALUE content)\n \n   rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n   rb_iv_set(rb_schema, \"@errors\", errors);\n+  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n \n   return rb_schema;\n }\n@@ -100,18 +109,25 @@ static VALUE read_memory(VALUE klass, VALUE content)\n  *\n  * Create a new RelaxNG schema from the Nokogiri::XML::Document +doc+\n  */\n-static VALUE from_document(VALUE klass, VALUE document)\n+static VALUE from_document(int argc, VALUE *argv, VALUE klass)\n {\n+  VALUE document;\n+  VALUE parse_options;\n   xmlDocPtr doc;\n   xmlRelaxNGParserCtxtPtr ctx;\n   xmlRelaxNGPtr schema;\n   VALUE errors;\n   VALUE rb_schema;\n+  int scanned_args = 0;\n+\n+  scanned_args = rb_scan_args(argc, argv, \"11\", &document, &parse_options);\n \n   Data_Get_Struct(document, xmlDoc, doc);\n+  doc = doc->doc; /* In case someone passes us a node. ugh. */\n \n-  /* In case someone passes us a node. ugh. */\n-  doc = doc->doc;\n+  if (scanned_args == 1) {\n+    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n+  }\n \n   ctx = xmlRelaxNGNewDocParserCtxt(doc);\n \n@@ -143,6 +159,7 @@ static VALUE from_document(VALUE klass, VALUE document)\n \n   rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n   rb_iv_set(rb_schema, \"@errors\", errors);\n+  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n \n   return rb_schema;\n }\n@@ -156,7 +173,7 @@ void init_xml_relax_ng()\n \n   cNokogiriXmlRelaxNG = klass;\n \n-  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n-  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n+  rb_define_singleton_method(klass, \"read_memory\", read_memory, -1);\n+  rb_define_singleton_method(klass, \"from_document\", from_document, -1);\n   rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n }"
        },
        {
          "filename": "ext/nokogiri/xml_schema.c",
          "status": "modified",
          "additions": 34,
          "deletions": 12,
          "patch": "@@ -93,23 +93,34 @@ static VALUE validate_file(VALUE self, VALUE rb_filename)\n  *\n  * Create a new Schema from the contents of +string+\n  */\n-static VALUE read_memory(VALUE klass, VALUE content)\n+static VALUE read_memory(int argc, VALUE *argv, VALUE klass)\n {\n+  VALUE content;\n+  VALUE parse_options;\n+  int parse_options_int;\n+  xmlSchemaParserCtxtPtr ctx;\n   xmlSchemaPtr schema;\n-  xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt(\n-      (const char *)StringValuePtr(content),\n-      (int)RSTRING_LEN(content)\n-  );\n+  VALUE errors;\n   VALUE rb_schema;\n-  VALUE errors = rb_ary_new();\n+  int scanned_args = 0;\n+\n+  scanned_args = rb_scan_args(argc, argv, \"11\", &content, &parse_options);\n+  if (scanned_args == 1) {\n+    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n+  }\n+  parse_options_int = (int)NUM2INT(rb_funcall(parse_options, rb_intern(\"to_i\"), 0));\n+\n+  ctx = xmlSchemaNewMemParserCtxt((const char *)StringValuePtr(content), (int)RSTRING_LEN(content));\n+\n+  errors = rb_ary_new();\n   xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n \n #ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n   xmlSchemaSetParserStructuredErrors(\n     ctx,\n     Nokogiri_error_array_pusher,\n     (void *)errors\n-  );\n+    );\n #endif\n \n    schema = xmlSchemaParse(ctx);\n@@ -129,6 +140,7 @@ static VALUE read_memory(VALUE klass, VALUE content)\n \n   rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n   rb_iv_set(rb_schema, \"@errors\", errors);\n+  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n \n   return rb_schema;\n }\n@@ -164,18 +176,27 @@ static int has_blank_nodes_p(VALUE cache)\n  *\n  * Create a new Schema from the Nokogiri::XML::Document +doc+\n  */\n-static VALUE from_document(VALUE klass, VALUE document)\n+static VALUE from_document(int argc, VALUE *argv, VALUE klass)\n {\n+  VALUE document;\n+  VALUE parse_options;\n+  int parse_options_int;\n   xmlDocPtr doc;\n   xmlSchemaParserCtxtPtr ctx;\n   xmlSchemaPtr schema;\n   VALUE errors;\n   VALUE rb_schema;\n+  int scanned_args = 0;\n+\n+  scanned_args = rb_scan_args(argc, argv, \"11\", &document, &parse_options);\n \n   Data_Get_Struct(document, xmlDoc, doc);\n+  doc = doc->doc; /* In case someone passes us a node. ugh. */\n \n-  /* In case someone passes us a node. ugh. */\n-  doc = doc->doc;\n+  if (scanned_args == 1) {\n+    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n+  }\n+  parse_options_int = (int)NUM2INT(rb_funcall(parse_options, rb_intern(\"to_i\"), 0));\n \n   if (has_blank_nodes_p(DOC_NODE_CACHE(doc))) {\n     rb_raise(rb_eArgError, \"Creating a schema from a document that has blank nodes exposed to Ruby is dangerous\");\n@@ -211,6 +232,7 @@ static VALUE from_document(VALUE klass, VALUE document)\n \n   rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n   rb_iv_set(rb_schema, \"@errors\", errors);\n+  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n \n   return rb_schema;\n \n@@ -226,8 +248,8 @@ void init_xml_schema()\n \n   cNokogiriXmlSchema = klass;\n \n-  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n-  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n+  rb_define_singleton_method(klass, \"read_memory\", read_memory, -1);\n+  rb_define_singleton_method(klass, \"from_document\", from_document, -1);\n \n   rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n   rb_define_private_method(klass, \"validate_file\",     validate_file, 1);"
        },
        {
          "filename": "lib/nokogiri/xml/parse_options.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -73,6 +73,8 @@ class ParseOptions\n       DEFAULT_XML  = RECOVER | NONET\n       # the default options used for parsing HTML documents\n       DEFAULT_HTML = RECOVER | NOERROR | NOWARNING | NONET\n+      # the default options used for parsing XML schemas\n+      DEFAULT_SCHEMA = NONET\n \n       attr_accessor :options\n       def initialize options = STRICT"
        },
        {
          "filename": "lib/nokogiri/xml/relax_ng.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -5,8 +5,8 @@ class << self\n       ###\n       # Create a new Nokogiri::XML::RelaxNG document from +string_or_io+.\n       # See Nokogiri::XML::RelaxNG for an example.\n-      def RelaxNG string_or_io\n-        RelaxNG.new(string_or_io)\n+      def RelaxNG(string_or_io, options = ParseOptions::DEFAULT_SCHEMA)\n+        RelaxNG.new(string_or_io, options)\n       end\n     end\n "
        },
        {
          "filename": "lib/nokogiri/xml/schema.rb",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -5,8 +5,8 @@ class << self\n       ###\n       # Create a new Nokogiri::XML::Schema object using a +string_or_io+\n       # object.\n-      def Schema string_or_io\n-        Schema.new(string_or_io)\n+      def Schema(string_or_io, options = ParseOptions::DEFAULT_SCHEMA)\n+        Schema.new(string_or_io, options)\n       end\n     end\n \n@@ -30,12 +30,14 @@ def Schema string_or_io\n     class Schema\n       # Errors while parsing the schema file\n       attr_accessor :errors\n+      # The Nokogiri::XML::ParseOptions used to parse the schema\n+      attr_accessor :parse_options\n \n       ###\n       # Create a new Nokogiri::XML::Schema object using a +string_or_io+\n       # object.\n-      def self.new string_or_io\n-        from_document Nokogiri::XML(string_or_io)\n+      def self.new string_or_io, options = ParseOptions::DEFAULT_SCHEMA\n+        from_document(Nokogiri::XML(string_or_io), options)\n       end\n \n       ###"
        },
        {
          "filename": "test/xml/test_relax_ng.rb",
          "status": "modified",
          "additions": 34,
          "deletions": 0,
          "patch": "@@ -26,6 +26,40 @@ def test_parse_with_io\n         assert_equal 0, xsd.errors.length\n       end\n \n+      def test_constructor_method_with_parse_options\n+        schema = Nokogiri::XML::RelaxNG(File.read(ADDRESS_SCHEMA_FILE))\n+        assert_equal Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA, schema.parse_options\n+\n+        schema = Nokogiri::XML::RelaxNG(File.read(ADDRESS_SCHEMA_FILE), Nokogiri::XML::ParseOptions.new.recover)\n+        assert_equal Nokogiri::XML::ParseOptions.new.recover, schema.parse_options\n+      end\n+\n+      def test_new_with_parse_options\n+        schema = Nokogiri::XML::RelaxNG.new(File.read(ADDRESS_SCHEMA_FILE))\n+        assert_equal Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA, schema.parse_options\n+\n+        schema = Nokogiri::XML::RelaxNG.new(File.read(ADDRESS_SCHEMA_FILE), Nokogiri::XML::ParseOptions.new.recover)\n+        assert_equal Nokogiri::XML::ParseOptions.new.recover, schema.parse_options\n+      end\n+\n+      def test_from_document_with_parse_options\n+        schema = Nokogiri::XML::RelaxNG.from_document(Nokogiri::XML::Document.parse(File.read(ADDRESS_SCHEMA_FILE)))\n+        assert_equal Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA, schema.parse_options\n+\n+        schema = Nokogiri::XML::RelaxNG.from_document(Nokogiri::XML::Document.parse(File.read(ADDRESS_SCHEMA_FILE)),\n+                                                      Nokogiri::XML::ParseOptions.new.recover)\n+        assert_equal Nokogiri::XML::ParseOptions.new.recover, schema.parse_options\n+      end\n+\n+      def test_read_memory_with_parse_options\n+        schema = Nokogiri::XML::RelaxNG.read_memory(File.read(ADDRESS_SCHEMA_FILE))\n+        assert_equal Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA, schema.parse_options\n+\n+        schema = Nokogiri::XML::RelaxNG.read_memory(File.read(ADDRESS_SCHEMA_FILE),\n+                                                    Nokogiri::XML::ParseOptions.new.recover)\n+        assert_equal Nokogiri::XML::ParseOptions.new.recover, schema.parse_options\n+      end\n+\n       def test_parse_with_errors\n         xml = File.read(ADDRESS_SCHEMA_FILE).sub(/name=\"/, 'name=')\n         assert_raises(Nokogiri::XML::SyntaxError) {"
        },
        {
          "filename": "test/xml/test_schema.rb",
          "status": "modified",
          "additions": 33,
          "deletions": 0,
          "patch": "@@ -109,6 +109,39 @@ def test_new\n         assert_instance_of Nokogiri::XML::Schema, xsd\n       end\n \n+      def test_schema_method_with_parse_options\n+        schema = Nokogiri::XML::Schema(File.read(PO_SCHEMA_FILE))\n+        assert_equal Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA, schema.parse_options\n+\n+        schema = Nokogiri::XML::Schema(File.read(PO_SCHEMA_FILE), Nokogiri::XML::ParseOptions.new.recover)\n+        assert_equal Nokogiri::XML::ParseOptions.new.recover, schema.parse_options\n+      end\n+\n+      def test_schema_new_with_parse_options\n+        schema = Nokogiri::XML::Schema.new(File.read(PO_SCHEMA_FILE))\n+        assert_equal Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA, schema.parse_options\n+\n+        schema = Nokogiri::XML::Schema.new(File.read(PO_SCHEMA_FILE), Nokogiri::XML::ParseOptions.new.recover)\n+        assert_equal Nokogiri::XML::ParseOptions.new.recover, schema.parse_options\n+      end\n+\n+      def test_schema_from_document_with_parse_options\n+        schema = Nokogiri::XML::Schema.from_document(Nokogiri::XML::Document.parse(File.read(PO_SCHEMA_FILE)))\n+        assert_equal Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA, schema.parse_options\n+\n+        schema = Nokogiri::XML::Schema.from_document(Nokogiri::XML::Document.parse(File.read(PO_SCHEMA_FILE)),\n+                                                     Nokogiri::XML::ParseOptions.new.recover)\n+        assert_equal Nokogiri::XML::ParseOptions.new.recover, schema.parse_options\n+      end\n+\n+      def test_schema_read_memory_with_parse_options\n+        schema = Nokogiri::XML::Schema.read_memory(File.read(PO_SCHEMA_FILE))\n+        assert_equal Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA, schema.parse_options\n+\n+        schema = Nokogiri::XML::Schema.read_memory(File.read(PO_SCHEMA_FILE), Nokogiri::XML::ParseOptions.new.recover)\n+        assert_equal Nokogiri::XML::ParseOptions.new.recover, schema.parse_options\n+      end\n+\n       def test_parse_with_io\n         xsd = nil\n         File.open(PO_SCHEMA_FILE, \"rb\") { |f|"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e3750182bc1a46572afd256ae53cc80802cf6759",
            "date": "2025-01-13T16:21:09Z",
            "author_login": "flavorjones"
          },
          {
            "sha": "148dda460759453c1e595c6b6ef6d95f15264743",
            "date": "2025-01-10T15:10:51Z",
            "author_login": "flavorjones"
          },
          {
            "sha": "adc292e5ca0da0db5bde29a241c5057b443593e8",
            "date": "2025-01-10T14:38:07Z",
            "author_login": "flavorjones"
          },
          {
            "sha": "c5cd95a8b1f59e1318906c9f4b8980c48306908b",
            "date": "2025-01-06T19:44:15Z",
            "author_login": "flavorjones"
          },
          {
            "sha": "af5b1b0590e2f365763d1801a4a5106198b47a53",
            "date": "2025-01-06T16:47:04Z",
            "author_login": "flavorjones"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 2.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-611",
    "description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri before version 1.11.0.rc4 there is an XXE vulnerability. XML Schemas parsed by Nokogiri::XML::Schema are trusted by default, allowing external resources to be accessed over the network, potentially enabling XXE or SSRF attacks. This behavior is counter to the security policy followed by Nokogiri maintainers, which is to treat all input as untrusted by default whenever possible. This is fixed in Nokogiri version 1.11.0.rc4.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-12-30T19:15:12.920",
    "last_modified": "2024-11-21T05:19:38.553",
    "fix_date": "2020-11-23T05:47:02Z"
  },
  "references": [
    {
      "url": "https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sparklemotion/nokogiri/releases/tag/v1.11.0.rc4",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sparklemotion/nokogiri/security/advisories/GHSA-vr8q-g5c7-m54m",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://hackerone.com/reports/747489",
      "source": "security-advisories@github.com",
      "tags": [
        "Permissions Required"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2021/06/msg00007.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2022/10/msg00018.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://rubygems.org/gems/nokogiri",
      "source": "security-advisories@github.com",
      "tags": [
        "Product",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202208-29",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sparklemotion/nokogiri/releases/tag/v1.11.0.rc4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sparklemotion/nokogiri/security/advisories/GHSA-vr8q-g5c7-m54m",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://hackerone.com/reports/747489",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Permissions Required"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2021/06/msg00007.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2022/10/msg00018.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://rubygems.org/gems/nokogiri",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202208-29",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:10.551435",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "nokogiri",
    "owner": "sparklemotion",
    "created_at": "2008-07-14T15:34:32Z",
    "updated_at": "2025-01-13T16:21:33Z",
    "pushed_at": "2025-01-13T16:21:28Z",
    "size": 38122,
    "stars": 6162,
    "forks": 905,
    "open_issues": 88,
    "watchers": 6162,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "v1.4.x",
      "v1.5.x",
      "v1.6.4.x",
      "v1.6.6.x"
    ],
    "languages": {
      "C": 1480966,
      "Ruby": 1281868,
      "Java": 657572,
      "C++": 273316,
      "HTML": 97438,
      "Ragel": 97111,
      "Shell": 7585,
      "Dockerfile": 6888,
      "Yacc": 6793,
      "Makefile": 5853,
      "REXX": 1965,
      "XSLT": 1868,
      "CSS": 422,
      "sed": 354
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:05:48.604878"
  }
}