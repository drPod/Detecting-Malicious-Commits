{
  "cve_id": "CVE-2020-26257",
  "github_data": {
    "repository": "matrix-org/synapse",
    "fix_commit": "3ce2f303f15f6ac3dc352298972dc6e04d9b7a8b",
    "related_commits": [
      "3ce2f303f15f6ac3dc352298972dc6e04d9b7a8b",
      "3ce2f303f15f6ac3dc352298972dc6e04d9b7a8b"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "3ce2f303f15f6ac3dc352298972dc6e04d9b7a8b",
      "commit_date": "2020-11-19T10:05:33Z",
      "author": {
        "login": "richvdh",
        "type": "User",
        "stats": {
          "total_commits": 3503,
          "average_weekly_commits": 6.404021937842779,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 303
        }
      },
      "commit_message": {
        "title": "Consistently use room_id from federation request body (#8776)",
        "length": 510,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 103,
        "additions": 49,
        "deletions": 54
      },
      "files": [
        {
          "filename": "changelog.d/8776.bugfix",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+Fix a bug in some federation APIs which could lead to unexpected behaviour if different parameters were set in the URI and the request body."
        },
        {
          "filename": "synapse/federation/federation_server.py",
          "status": "modified",
          "additions": 10,
          "deletions": 13,
          "patch": "@@ -49,6 +49,7 @@\n from synapse.federation.persistence import TransactionActions\n from synapse.federation.units import Edu, Transaction\n from synapse.http.endpoint import parse_server_name\n+from synapse.http.servlet import assert_params_in_dict\n from synapse.logging.context import (\n     make_deferred_yieldable,\n     nested_logging_context,\n@@ -391,7 +392,7 @@ async def _process_edu(edu_dict):\n             TRANSACTION_CONCURRENCY_LIMIT,\n         )\n \n-    async def on_context_state_request(\n+    async def on_room_state_request(\n         self, origin: str, room_id: str, event_id: str\n     ) -> Tuple[int, Dict[str, Any]]:\n         origin_host, _ = parse_server_name(origin)\n@@ -514,11 +515,12 @@ async def on_invite_request(\n         return {\"event\": ret_pdu.get_pdu_json(time_now)}\n \n     async def on_send_join_request(\n-        self, origin: str, content: JsonDict, room_id: str\n+        self, origin: str, content: JsonDict\n     ) -> Dict[str, Any]:\n         logger.debug(\"on_send_join_request: content: %s\", content)\n \n-        room_version = await self.store.get_room_version(room_id)\n+        assert_params_in_dict(content, [\"room_id\"])\n+        room_version = await self.store.get_room_version(content[\"room_id\"])\n         pdu = event_from_pdu_json(content, room_version)\n \n         origin_host, _ = parse_server_name(origin)\n@@ -547,12 +549,11 @@ async def on_make_leave_request(\n         time_now = self._clock.time_msec()\n         return {\"event\": pdu.get_pdu_json(time_now), \"room_version\": room_version}\n \n-    async def on_send_leave_request(\n-        self, origin: str, content: JsonDict, room_id: str\n-    ) -> dict:\n+    async def on_send_leave_request(self, origin: str, content: JsonDict) -> dict:\n         logger.debug(\"on_send_leave_request: content: %s\", content)\n \n-        room_version = await self.store.get_room_version(room_id)\n+        assert_params_in_dict(content, [\"room_id\"])\n+        room_version = await self.store.get_room_version(content[\"room_id\"])\n         pdu = event_from_pdu_json(content, room_version)\n \n         origin_host, _ = parse_server_name(origin)\n@@ -748,12 +749,8 @@ async def exchange_third_party_invite(\n         )\n         return ret\n \n-    async def on_exchange_third_party_invite_request(\n-        self, room_id: str, event_dict: Dict\n-    ):\n-        ret = await self.handler.on_exchange_third_party_invite_request(\n-            room_id, event_dict\n-        )\n+    async def on_exchange_third_party_invite_request(self, event_dict: Dict):\n+        ret = await self.handler.on_exchange_third_party_invite_request(event_dict)\n         return ret\n \n     async def check_server_matches_acl(self, server_name: str, room_id: str):"
        },
        {
          "filename": "synapse/federation/transport/server.py",
          "status": "modified",
          "additions": 33,
          "deletions": 35,
          "patch": "@@ -440,13 +440,13 @@ async def on_GET(self, origin, content, query, event_id):\n \n \n class FederationStateV1Servlet(BaseFederationServlet):\n-    PATH = \"/state/(?P<context>[^/]*)/?\"\n+    PATH = \"/state/(?P<room_id>[^/]*)/?\"\n \n-    # This is when someone asks for all data for a given context.\n-    async def on_GET(self, origin, content, query, context):\n-        return await self.handler.on_context_state_request(\n+    # This is when someone asks for all data for a given room.\n+    async def on_GET(self, origin, content, query, room_id):\n+        return await self.handler.on_room_state_request(\n             origin,\n-            context,\n+            room_id,\n             parse_string_from_args(query, \"event_id\", None, required=False),\n         )\n \n@@ -463,16 +463,16 @@ async def on_GET(self, origin, content, query, room_id):\n \n \n class FederationBackfillServlet(BaseFederationServlet):\n-    PATH = \"/backfill/(?P<context>[^/]*)/?\"\n+    PATH = \"/backfill/(?P<room_id>[^/]*)/?\"\n \n-    async def on_GET(self, origin, content, query, context):\n+    async def on_GET(self, origin, content, query, room_id):\n         versions = [x.decode(\"ascii\") for x in query[b\"v\"]]\n         limit = parse_integer_from_args(query, \"limit\", None)\n \n         if not limit:\n             return 400, {\"error\": \"Did not include limit param\"}\n \n-        return await self.handler.on_backfill_request(origin, context, versions, limit)\n+        return await self.handler.on_backfill_request(origin, room_id, versions, limit)\n \n \n class FederationQueryServlet(BaseFederationServlet):\n@@ -487,9 +487,9 @@ async def on_GET(self, origin, content, query, query_type):\n \n \n class FederationMakeJoinServlet(BaseFederationServlet):\n-    PATH = \"/make_join/(?P<context>[^/]*)/(?P<user_id>[^/]*)\"\n+    PATH = \"/make_join/(?P<room_id>[^/]*)/(?P<user_id>[^/]*)\"\n \n-    async def on_GET(self, origin, _content, query, context, user_id):\n+    async def on_GET(self, origin, _content, query, room_id, user_id):\n         \"\"\"\n         Args:\n             origin (unicode): The authenticated server_name of the calling server\n@@ -511,24 +511,24 @@ async def on_GET(self, origin, _content, query, context, user_id):\n             supported_versions = [\"1\"]\n \n         content = await self.handler.on_make_join_request(\n-            origin, context, user_id, supported_versions=supported_versions\n+            origin, room_id, user_id, supported_versions=supported_versions\n         )\n         return 200, content\n \n \n class FederationMakeLeaveServlet(BaseFederationServlet):\n-    PATH = \"/make_leave/(?P<context>[^/]*)/(?P<user_id>[^/]*)\"\n+    PATH = \"/make_leave/(?P<room_id>[^/]*)/(?P<user_id>[^/]*)\"\n \n-    async def on_GET(self, origin, content, query, context, user_id):\n-        content = await self.handler.on_make_leave_request(origin, context, user_id)\n+    async def on_GET(self, origin, content, query, room_id, user_id):\n+        content = await self.handler.on_make_leave_request(origin, room_id, user_id)\n         return 200, content\n \n \n class FederationV1SendLeaveServlet(BaseFederationServlet):\n     PATH = \"/send_leave/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"\n \n     async def on_PUT(self, origin, content, query, room_id, event_id):\n-        content = await self.handler.on_send_leave_request(origin, content, room_id)\n+        content = await self.handler.on_send_leave_request(origin, content)\n         return 200, (200, content)\n \n \n@@ -538,43 +538,43 @@ class FederationV2SendLeaveServlet(BaseFederationServlet):\n     PREFIX = FEDERATION_V2_PREFIX\n \n     async def on_PUT(self, origin, content, query, room_id, event_id):\n-        content = await self.handler.on_send_leave_request(origin, content, room_id)\n+        content = await self.handler.on_send_leave_request(origin, content)\n         return 200, content\n \n \n class FederationEventAuthServlet(BaseFederationServlet):\n-    PATH = \"/event_auth/(?P<context>[^/]*)/(?P<event_id>[^/]*)\"\n+    PATH = \"/event_auth/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"\n \n-    async def on_GET(self, origin, content, query, context, event_id):\n-        return await self.handler.on_event_auth(origin, context, event_id)\n+    async def on_GET(self, origin, content, query, room_id, event_id):\n+        return await self.handler.on_event_auth(origin, room_id, event_id)\n \n \n class FederationV1SendJoinServlet(BaseFederationServlet):\n-    PATH = \"/send_join/(?P<context>[^/]*)/(?P<event_id>[^/]*)\"\n+    PATH = \"/send_join/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"\n \n-    async def on_PUT(self, origin, content, query, context, event_id):\n-        # TODO(paul): assert that context/event_id parsed from path actually\n+    async def on_PUT(self, origin, content, query, room_id, event_id):\n+        # TODO(paul): assert that room_id/event_id parsed from path actually\n         #   match those given in content\n-        content = await self.handler.on_send_join_request(origin, content, context)\n+        content = await self.handler.on_send_join_request(origin, content)\n         return 200, (200, content)\n \n \n class FederationV2SendJoinServlet(BaseFederationServlet):\n-    PATH = \"/send_join/(?P<context>[^/]*)/(?P<event_id>[^/]*)\"\n+    PATH = \"/send_join/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"\n \n     PREFIX = FEDERATION_V2_PREFIX\n \n-    async def on_PUT(self, origin, content, query, context, event_id):\n-        # TODO(paul): assert that context/event_id parsed from path actually\n+    async def on_PUT(self, origin, content, query, room_id, event_id):\n+        # TODO(paul): assert that room_id/event_id parsed from path actually\n         #   match those given in content\n-        content = await self.handler.on_send_join_request(origin, content, context)\n+        content = await self.handler.on_send_join_request(origin, content)\n         return 200, content\n \n \n class FederationV1InviteServlet(BaseFederationServlet):\n-    PATH = \"/invite/(?P<context>[^/]*)/(?P<event_id>[^/]*)\"\n+    PATH = \"/invite/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"\n \n-    async def on_PUT(self, origin, content, query, context, event_id):\n+    async def on_PUT(self, origin, content, query, room_id, event_id):\n         # We don't get a room version, so we have to assume its EITHER v1 or\n         # v2. This is \"fine\" as the only difference between V1 and V2 is the\n         # state resolution algorithm, and we don't use that for processing\n@@ -589,12 +589,12 @@ async def on_PUT(self, origin, content, query, context, event_id):\n \n \n class FederationV2InviteServlet(BaseFederationServlet):\n-    PATH = \"/invite/(?P<context>[^/]*)/(?P<event_id>[^/]*)\"\n+    PATH = \"/invite/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"\n \n     PREFIX = FEDERATION_V2_PREFIX\n \n-    async def on_PUT(self, origin, content, query, context, event_id):\n-        # TODO(paul): assert that context/event_id parsed from path actually\n+    async def on_PUT(self, origin, content, query, room_id, event_id):\n+        # TODO(paul): assert that room_id/event_id parsed from path actually\n         #   match those given in content\n \n         room_version = content[\"room_version\"]\n@@ -616,9 +616,7 @@ class FederationThirdPartyInviteExchangeServlet(BaseFederationServlet):\n     PATH = \"/exchange_third_party_invite/(?P<room_id>[^/]*)\"\n \n     async def on_PUT(self, origin, content, query, room_id):\n-        content = await self.handler.on_exchange_third_party_invite_request(\n-            room_id, content\n-        )\n+        content = await self.handler.on_exchange_third_party_invite_request(content)\n         return 200, content\n \n "
        },
        {
          "filename": "synapse/handlers/federation.py",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -55,6 +55,7 @@\n from synapse.events.snapshot import EventContext\n from synapse.events.validator import EventValidator\n from synapse.handlers._base import BaseHandler\n+from synapse.http.servlet import assert_params_in_dict\n from synapse.logging.context import (\n     make_deferred_yieldable,\n     nested_logging_context,\n@@ -2686,20 +2687,19 @@ async def exchange_third_party_invite(\n             )\n \n     async def on_exchange_third_party_invite_request(\n-        self, room_id: str, event_dict: JsonDict\n+        self, event_dict: JsonDict\n     ) -> None:\n         \"\"\"Handle an exchange_third_party_invite request from a remote server\n \n         The remote server will call this when it wants to turn a 3pid invite\n         into a normal m.room.member invite.\n \n         Args:\n-            room_id: The ID of the room.\n-\n-            event_dict (dict[str, Any]): Dictionary containing the event body.\n+            event_dict: Dictionary containing the event body.\n \n         \"\"\"\n-        room_version = await self.store.get_room_version_id(room_id)\n+        assert_params_in_dict(event_dict, [\"room_id\"])\n+        room_version = await self.store.get_room_version_id(event_dict[\"room_id\"])\n \n         # NB: event_dict has a particular specced format we might need to fudge\n         # if we change event formats too much."
        },
        {
          "filename": "tests/handlers/test_federation.py",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -59,7 +59,6 @@ def test_exchange_revoked_invite(self):\n         )\n \n         d = self.handler.on_exchange_third_party_invite_request(\n-            room_id=room_id,\n             event_dict={\n                 \"type\": EventTypes.Member,\n                 \"room_id\": room_id,"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 5,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "be65a8ec0195955c15fdb179c9158b187638e39a",
            "date": "2023-12-13T14:50:56Z",
            "author_login": "wrjlewis"
          },
          {
            "sha": "66fc265578f4501307edcac2514892ecdf791fc9",
            "date": "2023-12-13T14:47:34Z",
            "author_login": "wrjlewis"
          },
          {
            "sha": "025951bc3b6ddc0a6487ac045cc00a35a9d7eaaa",
            "date": "2023-12-13T14:46:11Z",
            "author_login": "erikjohnston"
          },
          {
            "sha": "70c020b532821f898aaa07c35c5d5ab59055ae1c",
            "date": "2023-12-12T20:32:48Z",
            "author_login": "erikjohnston"
          },
          {
            "sha": "e1f8440c8959719a417fbf1bdda11406cfdf523d",
            "date": "2023-11-21T19:26:47Z",
            "author_login": "clokep"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-79",
    "description": "Matrix is an ecosystem for open federated Instant Messaging and VoIP. Synapse is a reference \"homeserver\" implementation of Matrix. A malicious or poorly-implemented homeserver can inject malformed events into a room by specifying a different room id in the path of a `/send_join`, `/send_leave`, `/invite` or `/exchange_third_party_invite` request. This can lead to a denial of service in which future events will not be correctly sent to other servers over federation. This affects any server which accepts federation requests from untrusted servers. The Matrix Synapse reference implementation before version 1.23.1 the implementation is vulnerable to this injection attack. Issue is fixed in version 1.23.1. As a workaround homeserver administrators could limit access to the federation API to trusted servers (for example via `federation_domain_whitelist`).",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-12-09T19:15:11.500",
    "last_modified": "2024-11-21T05:19:40.667",
    "fix_date": "2020-11-19T10:05:33Z"
  },
  "references": [
    {
      "url": "https://github.com/matrix-org/synapse/blob/develop/CHANGES.md#synapse-1231-2020-12-09",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/commit/3ce2f303f15f6ac3dc352298972dc6e04d9b7a8b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/pull/8776",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/security/advisories/GHSA-hxmp-pqch-c8mm",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/DBTIU3ZNBFWZ56V4X7JIAD33V5H2GOMC/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/QR4MMYZKX5N5GYGH4H5LBUUC5TLAFHI7/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/matrix-org/synapse/blob/develop/CHANGES.md#synapse-1231-2020-12-09",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/commit/3ce2f303f15f6ac3dc352298972dc6e04d9b7a8b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/pull/8776",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/security/advisories/GHSA-hxmp-pqch-c8mm",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/DBTIU3ZNBFWZ56V4X7JIAD33V5H2GOMC/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/QR4MMYZKX5N5GYGH4H5LBUUC5TLAFHI7/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:10.506242",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "synapse",
    "owner": "matrix-org",
    "created_at": "2014-08-11T15:51:42Z",
    "updated_at": "2025-01-25T11:19:08Z",
    "pushed_at": "2024-04-26T15:47:23Z",
    "size": 429495,
    "stars": 11852,
    "forks": 2122,
    "open_issues": 1529,
    "watchers": 11852,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [],
    "languages": {
      "Python": 11907179,
      "Rust": 95720,
      "HTML": 64571,
      "Shell": 59187,
      "Perl": 28191,
      "Nix": 12267,
      "Dockerfile": 12096,
      "JavaScript": 11988,
      "Jinja": 7942,
      "CSS": 6211,
      "Makefile": 634,
      "Gherkin": 308,
      "Lua": 241
    },
    "commit_activity": {
      "total_commits_last_year": 1,
      "avg_commits_per_week": 0.019230769230769232,
      "days_active_last_year": 1
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:39:36.627913"
  }
}