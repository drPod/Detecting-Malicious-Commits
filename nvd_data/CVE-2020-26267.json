{
  "cve_id": "CVE-2020-26267",
  "github_data": {
    "repository": "tensorflow/tensorflow",
    "fix_commit": "ebc70b7a592420d3d2f359e4b1694c236b82c7ae",
    "related_commits": [
      "ebc70b7a592420d3d2f359e4b1694c236b82c7ae",
      "ebc70b7a592420d3d2f359e4b1694c236b82c7ae"
    ],
    "patch_url": "https://github.com/tensorflow/tensorflow/commit/ebc70b7a592420d3d2f359e4b1694c236b82c7ae.patch",
    "fix_commit_details": {
      "sha": "ebc70b7a592420d3d2f359e4b1694c236b82c7ae",
      "commit_date": "2020-12-07T19:15:21Z",
      "author": {
        "login": "mihaimaruseac",
        "type": "User",
        "stats": {
          "total_commits": 1590,
          "average_weekly_commits": 3.3125,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 214
        }
      },
      "commit_message": {
        "title": "Validate that `DataFormat*` attributes form a permutation.",
        "length": 690,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 168,
        "additions": 161,
        "deletions": 7
      },
      "files": [
        {
          "filename": "tensorflow/core/kernels/data_format_ops.cc",
          "status": "modified",
          "additions": 65,
          "deletions": 7,
          "patch": "@@ -18,16 +18,52 @@ limitations under the License.\n #define EIGEN_USE_THREADS\n \n #include \"tensorflow/core/kernels/data_format_ops.h\"\n+\n+#include <map>\n+\n #include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n #include \"tensorflow/core/framework/op_kernel.h\"\n #include \"tensorflow/core/framework/register_types.h\"\n #include \"tensorflow/core/framework/tensor.h\"\n+#include \"tensorflow/core/platform/errors.h\"\n \n namespace tensorflow {\n \n typedef Eigen::ThreadPoolDevice CPUDevice;\n typedef Eigen::GpuDevice GPUDevice;\n \n+// Ensure that `src` and `dst` define a valid permutation.\n+// Ops defined in this file assume that user specifies a permutation via two\n+// string attributes. This check validates that these attributes properly define\n+// it to prevent security vulnerabilities.\n+static bool IsValidPermutation(const std::string& src, const std::string& dst) {\n+  if (src.size() != dst.size()) {\n+    return false;\n+  }\n+\n+  std::map<char, bool> characters;\n+\n+  // Every character in `src` must be present only once\n+  for (const auto c : src) {\n+    if (characters[c]) {\n+      return false;\n+    }\n+    characters[c] = true;\n+  }\n+\n+  // Every character in `dst` must show up in `src` exactly once\n+  for (const auto c : dst) {\n+    if (!characters[c]) {\n+      return false;\n+    }\n+    characters[c] = false;\n+  }\n+\n+  // At this point, characters[] has been switched to true and false exactly\n+  // once for all character in `src` (and `dst`) so we have a valid permutation\n+  return true;\n+}\n+\n template <typename Device, typename T>\n class DataFormatDimMapOp : public OpKernel {\n  public:\n@@ -38,15 +74,19 @@ class DataFormatDimMapOp : public OpKernel {\n     string dst_format;\n     OP_REQUIRES_OK(context, context->GetAttr(\"dst_format\", &dst_format));\n     OP_REQUIRES(context, src_format.size() == 4 || src_format.size() == 5,\n-                errors::InvalidArgument(strings::StrCat(\n-                    \"Source format must of length 4 or 5, received \"\n+                errors::InvalidArgument(\n+                    \"Source format must be of length 4 or 5, received \"\n                     \"src_format = \",\n-                    src_format)));\n+                    src_format));\n+    OP_REQUIRES(context, dst_format.size() == 4 || dst_format.size() == 5,\n+                errors::InvalidArgument(\"Destination format must be of length \"\n+                                        \"4 or 5, received dst_format = \",\n+                                        dst_format));\n     OP_REQUIRES(\n-        context, dst_format.size() == 4 || dst_format.size() == 5,\n-        errors::InvalidArgument(strings::StrCat(\n-            \"Destination format must of length 4 or 5, received dst_format = \",\n-            dst_format)));\n+        context, IsValidPermutation(src_format, dst_format),\n+        errors::InvalidArgument(\n+            \"Destination and source format must determine a permutation, got \",\n+            src_format, \" and \", dst_format));\n     dst_idx_ = Tensor(DT_INT32, {static_cast<int64>(src_format.size())});\n     for (int i = 0; i < src_format.size(); ++i) {\n       for (int j = 0; j < dst_format.size(); ++j) {\n@@ -78,8 +118,22 @@ class DataFormatVecPermuteOp : public OpKernel {\n       : OpKernel(context) {\n     string src_format;\n     OP_REQUIRES_OK(context, context->GetAttr(\"src_format\", &src_format));\n+    OP_REQUIRES(context, src_format.size() == 4 || src_format.size() == 5,\n+                errors::InvalidArgument(\n+                    \"Source format must be of length 4 or 5, received \"\n+                    \"src_format = \",\n+                    src_format));\n     string dst_format;\n     OP_REQUIRES_OK(context, context->GetAttr(\"dst_format\", &dst_format));\n+    OP_REQUIRES(context, dst_format.size() == 4 || dst_format.size() == 5,\n+                errors::InvalidArgument(\"Destination format must be of length \"\n+                                        \"4 or 5, received dst_format = \",\n+                                        dst_format));\n+    OP_REQUIRES(\n+        context, IsValidPermutation(src_format, dst_format),\n+        errors::InvalidArgument(\n+            \"Destination and source format must determine a permutation, got \",\n+            src_format, \" and \", dst_format));\n     src_format_ = src_format;\n     dst_format_ = dst_format;\n   }\n@@ -127,6 +181,10 @@ class DataFormatVecPermuteOp : public OpKernel {\n       };\n       keep_only_spatial_dimensions(&src_format_str);\n       keep_only_spatial_dimensions(&dst_format_str);\n+      OP_REQUIRES(context,\n+                  src_format_str.size() == 2 && dst_format_str.size() == 2,\n+                  errors::InvalidArgument(\n+                      \"Format specifier must contain H and W for 2D case\"));\n     }\n     ComputeDstIndex(src_format_str, dst_format_str, input.dims(), &dst_idx);\n "
        },
        {
          "filename": "tensorflow/python/ops/nn_test.py",
          "status": "modified",
          "additions": 96,
          "deletions": 0,
          "patch": "@@ -27,6 +27,7 @@\n from tensorflow.python.eager import def_function\n from tensorflow.python.framework import constant_op\n from tensorflow.python.framework import dtypes\n+from tensorflow.python.framework import errors\n from tensorflow.python.framework import ops\n from tensorflow.python.framework import tensor_spec\n from tensorflow.python.framework import test_util\n@@ -1260,6 +1261,7 @@ def testDNHWCtoWHDCN(self):\n       y_val = self.evaluate(y)\n       self.assertAllEqual(y_val, y_val_expected)\n \n+  @test_util.disable_xla(\"XLA catches the error and rethrows as different one\")\n   def testArbitraryASCII(self):\n     x_val = [-4, -3, -2, -1, 0, 1, 2, 3]\n     y_val_expected = [3, 2, 1, 0, 3, 2, 1, 0]\n@@ -1269,6 +1271,46 @@ def testArbitraryASCII(self):\n       y_val = self.evaluate(y)\n       self.assertAllEqual(y_val, y_val_expected)\n \n+  @test_util.disable_xla(\"XLA catches the error and rethrows as different one\")\n+  def testInvalidLength(self):\n+    x = [-4, -3, -2, -1, 0, 1, 2, 3]\n+    with self.assertRaisesRegex(errors.InvalidArgumentError,\n+                                \"Source format must be of length 4 or 5\"):\n+      op = nn_ops.data_format_dim_map(\n+          x, src_format=\"12345678\", dst_format=\"87654321\")\n+      with test_util.use_gpu():\n+        self.evaluate(op)\n+\n+  @test_util.disable_xla(\"XLA catches the error and rethrows as different one\")\n+  def testDuplicateSrc(self):\n+    x = [-4, -3, -2, -1, 0, 1, 2, 3]\n+    with self.assertRaisesRegex(\n+        errors.InvalidArgumentError,\n+        \"Destination and source format must determine a permutation\"):\n+      op = nn_ops.data_format_dim_map(x, src_format=\"1233\", dst_format=\"4321\")\n+      with test_util.use_gpu():\n+        self.evaluate(op)\n+\n+  @test_util.disable_xla(\"XLA catches the error and rethrows as different one\")\n+  def testDuplicateDst(self):\n+    x = [-4, -3, -2, -1, 0, 1, 2, 3]\n+    with self.assertRaisesRegex(\n+        errors.InvalidArgumentError,\n+        \"Destination and source format must determine a permutation\"):\n+      op = nn_ops.data_format_dim_map(x, src_format=\"1234\", dst_format=\"3321\")\n+      with test_util.use_gpu():\n+        self.evaluate(op)\n+\n+  @test_util.disable_xla(\"XLA catches the error and rethrows as different one\")\n+  def testExtraSpecifiers(self):\n+    x = [-4, -3, -2, -1, 0, 1, 2, 3]\n+    with self.assertRaisesRegex(\n+        errors.InvalidArgumentError,\n+        \"Destination and source format must determine a permutation\"):\n+      op = nn_ops.data_format_dim_map(x, src_format=\"1234\", dst_format=\"5321\")\n+      with test_util.use_gpu():\n+        self.evaluate(op)\n+\n \n class DataFormatVectorPermuteTest(test_lib.TestCase):\n \n@@ -1370,6 +1412,60 @@ def testNCHWToNHWC2D(self):\n       y_val = self.evaluate(y)\n       self.assertAllEqual(y_val, [[7, 4], [4, 5], [5, 1], [9, 3]])\n \n+  @test_util.disable_xla(\"XLA catches the error and rethrows as different one\")\n+  def testInvalidLength(self):\n+    x = [0, 1, 2, 3]\n+    with self.assertRaisesRegex(errors.InvalidArgumentError,\n+                                \"Source format must be of length 4 or 5\"):\n+      op = nn_ops.data_format_vec_permute(\n+          x, src_format=\"12345678\", dst_format=\"87654321\")\n+      with test_util.use_gpu():\n+        self.evaluate(op)\n+\n+  @test_util.disable_xla(\"XLA catches the error and rethrows as different one\")\n+  def testDuplicateSrc(self):\n+    x = [0, 1, 2, 3]\n+    with self.assertRaisesRegex(\n+        errors.InvalidArgumentError,\n+        \"Destination and source format must determine a permutation\"):\n+      op = nn_ops.data_format_vec_permute(\n+          x, src_format=\"1233\", dst_format=\"4321\")\n+      with test_util.use_gpu():\n+        self.evaluate(op)\n+\n+  @test_util.disable_xla(\"XLA catches the error and rethrows as different one\")\n+  def testDuplicateDst(self):\n+    x = [0, 1, 2, 3]\n+    with self.assertRaisesRegex(\n+        errors.InvalidArgumentError,\n+        \"Destination and source format must determine a permutation\"):\n+      op = nn_ops.data_format_vec_permute(\n+          x, src_format=\"1234\", dst_format=\"3321\")\n+      with test_util.use_gpu():\n+        self.evaluate(op)\n+\n+  @test_util.disable_xla(\"XLA catches the error and rethrows as different one\")\n+  def testExtraSpecifiers(self):\n+    x = [0, 1, 2, 3]\n+    with self.assertRaisesRegex(\n+        errors.InvalidArgumentError,\n+        \"Destination and source format must determine a permutation\"):\n+      op = nn_ops.data_format_vec_permute(\n+          x, src_format=\"1234\", dst_format=\"5321\")\n+      with test_util.use_gpu():\n+        self.evaluate(op)\n+\n+  @test_util.disable_xla(\"XLA catches the error and rethrows as different one\")\n+  def test2DNoWH(self):\n+    x = [[0, 1], [2, 3]]\n+    with self.assertRaisesRegex(\n+        errors.InvalidArgumentError,\n+        \"Format specifier must contain H and W for 2D case\"):\n+      op = nn_ops.data_format_vec_permute(\n+          x, src_format=\"1234\", dst_format=\"4321\")\n+      with test_util.use_gpu():\n+        self.evaluate(op)\n+\n \n @test_util.run_all_in_graph_and_eager_modes\n class AvgPoolTest(test_lib.TestCase):"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "fd41705e0ad7a123a9d01b8be2a3b34b3266493e",
            "date": "2025-01-14T13:33:52Z",
            "author_login": "loislo"
          },
          {
            "sha": "af5275c5731565cbf2a2c01ee418a8cf62388431",
            "date": "2025-01-14T12:48:20Z",
            "author_login": "akuegel"
          },
          {
            "sha": "ee156c15e5d1cd7d2bd85885e7fd2bf7e143c2c3",
            "date": "2025-01-14T12:46:22Z",
            "author_login": "pifon2a"
          },
          {
            "sha": "bd43a8255ce9e203b740bcdc09e8f79d3a26f887",
            "date": "2025-01-14T12:33:02Z",
            "author_login": "metaflow"
          },
          {
            "sha": "8003fb40987f176d35364da2af8fcdfab339349e",
            "date": "2025-01-14T11:27:47Z",
            "author_login": "vwbaker"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.4,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:L",
    "cwe_id": "CWE-125",
    "description": "In affected versions of TensorFlow the tf.raw_ops.DataFormatVecPermute API does not validate the src_format and dst_format attributes. The code assumes that these two arguments define a permutation of NHWC. This can result in uninitialized memory accesses, read outside of bounds and even crashes. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-12-10T23:15:12.723",
    "last_modified": "2024-11-21T05:19:42.457",
    "fix_date": "2020-12-07T19:15:21Z"
  },
  "references": [
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/ebc70b7a592420d3d2f359e4b1694c236b82c7ae",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-c9f3-9wfr-wgh7",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/ebc70b7a592420d3d2f359e4b1694c236b82c7ae",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-c9f3-9wfr-wgh7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:10.508940",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "tensorflow",
    "owner": "tensorflow",
    "created_at": "2015-11-07T01:19:20Z",
    "updated_at": "2025-01-14T12:53:26Z",
    "pushed_at": "2025-01-14T12:53:14Z",
    "size": 1120707,
    "stars": 187254,
    "forks": 74432,
    "open_issues": 6569,
    "watchers": 187254,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 101199988,
      "Python": 45779571,
      "MLIR": 10763008,
      "HTML": 7662661,
      "Starlark": 7430486,
      "Go": 2171370,
      "C": 1288066,
      "Java": 1178817,
      "Jupyter Notebook": 805736,
      "Shell": 701425,
      "Objective-C++": 279654,
      "Objective-C": 169202,
      "CMake": 148610,
      "Smarty": 121630,
      "Swift": 81659,
      "Dockerfile": 37903,
      "C#": 13585,
      "Batchfile": 12126,
      "Ruby": 8898,
      "Perl": 7536,
      "Roff": 5034,
      "Cython": 3899,
      "Makefile": 2845,
      "CSS": 2761,
      "Vim Snippet": 58
    },
    "commit_activity": {
      "total_commits_last_year": 15729,
      "avg_commits_per_week": 302.4807692307692,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:54:01.412891"
  }
}