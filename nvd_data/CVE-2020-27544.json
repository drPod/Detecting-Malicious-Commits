{
  "cve_id": "CVE-2020-27544",
  "github_data": {
    "repository": "FoldingAtHome/fah-control",
    "fix_commit": "9b619ae64443997948a36dda01b420578de1af77",
    "related_commits": [
      "9b619ae64443997948a36dda01b420578de1af77",
      "9b619ae64443997948a36dda01b420578de1af77"
    ],
    "patch_url": "https://github.com/FoldingAtHome/fah-control/commit/9b619ae64443997948a36dda01b420578de1af77.patch",
    "fix_commit_details": {
      "sha": "9b619ae64443997948a36dda01b420578de1af77",
      "commit_date": "2020-09-22T05:37:40Z",
      "author": {
        "login": "jcoffland",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Use PYONDecoder instead of eval()",
        "length": 33,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 221,
        "additions": 220,
        "deletions": 1
      },
      "files": [
        {
          "filename": "fah/Connection.py",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -27,8 +27,10 @@\n import time\n import sys\n import traceback\n+import json\n \n from fah.util import OrderedDict\n+from fah.util import PYONDecoder\n \n if sys.platform == 'win32':\n     from ctypes import windll\n@@ -204,7 +206,7 @@ def queue_command(self, command):\n \n     def parse_message(self, version, type, data):\n         try:\n-            msg = eval(data, {}, {})\n+            msg = json.loads(data, cls = PYONDecoder)\n             #if debug: print 'MSG:', type, msg\n             self.messages.append((version, type, msg))\n             self.last_message = time.time()"
        },
        {
          "filename": "fah/util/PYONDecoder.py",
          "status": "added",
          "additions": 216,
          "deletions": 0,
          "patch": "@@ -0,0 +1,216 @@\n+################################################################################\n+#                                                                              #\n+#                    Folding@Home Client Control (FAHControl)                  #\n+#                   Copyright (C) 2016-2020 foldingathome.org                  #\n+#                  Copyright (C) 2010-2016 Stanford University                 #\n+#                                                                              #\n+#      This program is free software: you can redistribute it and/or modify    #\n+#      it under the terms of the GNU General Public License as published by    #\n+#       the Free Software Foundation, either version 3 of the License, or      #\n+#                      (at your option) any later version.                     #\n+#                                                                              #\n+#        This program is distributed in the hope that it will be useful,       #\n+#         but WITHOUT ANY WARRANTY; without even the implied warranty of       #\n+#         MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        #\n+#                  GNU General Public License for more details.                #\n+#                                                                              #\n+#       You should have received a copy of the GNU General Public License      #\n+#     along with this program.  If not, see <http://www.gnu.org/licenses/>.    #\n+#                                                                              #\n+################################################################################\n+\n+import re\n+import json\n+import sys\n+\n+\n+NUMBER_RE = re.compile(r'(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?',\n+                       (re.VERBOSE | re.MULTILINE | re.DOTALL))\n+FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL\n+STRINGCHUNK = re.compile(r'(.*?)([\"\\\\\\x00-\\x1f])', FLAGS)\n+BACKSLASH = {\n+  '\"': u'\"', '\\\\': u'\\\\', '/': u'/',\n+  'b': u'\\b', 'f': u'\\f', 'n': u'\\n', 'r': u'\\r', 't': u'\\t',\n+}\n+\n+DEFAULT_ENCODING = \"utf-8\"\n+\n+\n+def linecol(doc, pos):\n+  lineno = doc.count('\\n', 0, pos) + 1\n+  if lineno == 1:\n+    colno = pos + 1\n+  else:\n+    colno = pos - doc.rindex('\\n', 0, pos)\n+  return lineno, colno\n+\n+\n+def errmsg(msg, doc, pos, end=None):\n+  # Note that this function is called from _json\n+  lineno, colno = linecol(doc, pos)\n+  if end is None:\n+    fmt = '{0}: line {1} column {2} (char {3})'\n+    return fmt.format(msg, lineno, colno, pos)\n+\n+  endlineno, endcolno = linecol(doc, end)\n+  fmt = '{0}: line {1} column {2} - line {3} column {4} (char {5} - {6})'\n+  return fmt.format(msg, lineno, colno, endlineno, endcolno, pos, end)\n+\n+\n+def _decode_uXXXX(s, pos):\n+  esc = s[pos + 1:pos + 5]\n+\n+  if len(esc) == 4 and esc[1] not in 'xX':\n+    try:\n+      return int(esc, 16)\n+    except ValueError: pass\n+\n+  msg = \"Invalid \\\\uXXXX escape\"\n+  raise ValueError(errmsg(msg, s, pos))\n+\n+\n+def pyon_scanstring(s, end, encoding = None, strict = True,\n+                    _b = BACKSLASH, _m = STRINGCHUNK.match):\n+  \"\"\"Scan the string s for a JSON string. End is the index of the\n+  character in s after the quote that started the JSON string.\n+  Unescapes all valid JSON string escape sequences and raises ValueError\n+  on attempt to decode an invalid string. If strict is False then literal\n+  control characters are allowed in the string.\n+  Returns a tuple of the decoded string and the index of the character in s\n+  after the end quote.\"\"\"\n+  if encoding is None: encoding = DEFAULT_ENCODING\n+  chunks = []\n+  _append = chunks.append\n+  begin = end - 1\n+\n+  while True:\n+    chunk = _m(s, end)\n+    if chunk is None:\n+      raise ValueError(\n+        errmsg(\"Unterminated string starting at\", s, begin))\n+\n+    end = chunk.end()\n+    content, terminator = chunk.groups()\n+\n+    # Content is contains zero or more unescaped string characters\n+    if content:\n+      if not isinstance(content, unicode):\n+        content = unicode(content, encoding)\n+      _append(content)\n+\n+    # Terminator is the end of string, a literal control character,\n+    # or a backslash denoting that an escape sequence follows\n+    if terminator == '\"': break\n+    elif terminator != '\\\\':\n+      if strict:\n+        msg = \"Invalid control character {0!r} at\".format(terminator)\n+        raise ValueError(errmsg(msg, s, end))\n+      else:\n+        _append(terminator)\n+        continue\n+\n+    try:\n+      esc = s[end]\n+    except IndexError:\n+      raise ValueError(errmsg(\"Unterminated string starting at\", s, begin))\n+\n+    # If not a unicode escape sequence, must be in the lookup table\n+    if esc != 'u' and esc != 'x':\n+      try:\n+        char = _b[esc]\n+      except KeyError:\n+        msg = \"Invalid \\\\escape: \" + repr(esc)\n+        raise ValueError(errmsg(msg, s, end))\n+      end += 1\n+\n+    elif esc == 'x':\n+      # Hex escape sequence\n+      try:\n+        code = s[end + 1: end + 3]\n+        char = code.decode('hex')\n+      except:\n+        raise ValueError(errmsg('Invalid \\\\escape: ' + repr(code), s, end))\n+\n+      end += 3\n+\n+    else:\n+      # Unicode escape sequence\n+      uni = _decode_uXXXX(s, end)\n+      end += 5\n+      # Check for surrogate pair on UCS-4 systems\n+      if sys.maxunicode > 65535 and \\\n+         0xd800 <= uni <= 0xdbff and s[end:end + 2] == '\\\\u':\n+        uni2 = _decode_uXXXX(s, end + 1)\n+        if 0xdc00 <= uni2 <= 0xdfff:\n+          uni = 0x10000 + (((uni - 0xd800) << 10) | (uni2 - 0xdc00))\n+          end += 6\n+      char = unichr(uni)\n+\n+    # Append the unescaped character\n+    _append(char)\n+\n+  return u''.join(chunks), end\n+\n+\n+\n+def make_pyon_scanner(context):\n+  parse_object = context.parse_object\n+  parse_array = context.parse_array\n+  parse_string = context.parse_string\n+  match_number = NUMBER_RE.match\n+  strict = context.strict\n+  parse_float = context.parse_float\n+  parse_int = context.parse_int\n+  parse_constant = context.parse_constant\n+  object_hook = context.object_hook\n+  object_pairs_hook = context.object_pairs_hook\n+\n+\n+  def scan_once(string, idx):\n+    try:\n+        nextchar = string[idx]\n+    except IndexError:\n+      raise StopIteration(idx)\n+\n+    if nextchar == '\"': return parse_string(string, idx + 1, 'utf-8', strict)\n+    elif nextchar == '{':\n+      return parse_object((string, idx + 1), 'utf-8', strict, scan_once,\n+                          object_hook, object_pairs_hook)\n+    elif nextchar == '[':\n+      return parse_array((string, idx + 1), scan_once)\n+    elif nextchar == 'N' and string[idx:idx + 4] == 'None':\n+      return None, idx + 4\n+    elif nextchar == 'T' and string[idx:idx + 4] == 'True':\n+      return True, idx + 4\n+    elif nextchar == 'F' and string[idx:idx + 5] == 'False':\n+      return False, idx + 5\n+\n+    m = match_number(string, idx)\n+    if m is not None:\n+      integer, frac, exp = m.groups()\n+      if frac or exp:\n+        res = parse_float(integer + (frac or '') + (exp or ''))\n+      else: res = parse_int(integer)\n+\n+      return res, m.end()\n+\n+    elif nextchar == 'N' and string[idx:idx + 3] == 'NaN':\n+      return parse_constant('NaN'), idx + 3\n+\n+    elif nextchar == 'I' and string[idx:idx + 8] == 'Infinity':\n+      return parse_constant('Infinity'), idx + 8\n+\n+    elif nextchar == '-' and string[idx:idx + 9] == '-Infinity':\n+      return parse_constant('-Infinity'), idx + 9\n+\n+    else: raise StopIteration(idx)\n+\n+\n+  return scan_once\n+\n+\n+class PYONDecoder(json.JSONDecoder):\n+  def __init__(self, *args, **kwargs):\n+    json.JSONDecoder.__init__(self, *args, **kwargs)\n+    self.parse_string = pyon_scanstring\n+    self.scan_once = make_pyon_scanner(self)"
        },
        {
          "filename": "fah/util/__init__.py",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -29,6 +29,7 @@\n from EntryValidator import *\n from PasswordValidator import *\n from OrderedDict import *\n+from PYONDecoder import *\n \n \n def parse_bool(x):"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "a1127e00f2b88cd9c50a1f4dbee2d8eb53efaf0d",
            "date": "2023-08-06T11:21:48Z",
            "author_login": "jcoffland"
          },
          {
            "sha": "1597fe4d04158220eb9a8aea515c81ba62d2af6c",
            "date": "2021-08-04T23:44:38Z",
            "author_login": "jcoffland"
          },
          {
            "sha": "2d272e2e53adb654261caabfe7ce8ee40ffb0b6e",
            "date": "2021-08-04T01:06:11Z",
            "author_login": "kbernhagen"
          },
          {
            "sha": "7016206a9e623ae95d78440035fa87c8319a2a8f",
            "date": "2020-12-02T21:41:06Z",
            "author_login": "jcoffland"
          },
          {
            "sha": "924d24c72356129ec4f1a2a6c1dc8044d7a3c440",
            "date": "2020-12-02T05:34:41Z",
            "author_login": "kbernhagen"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": null,
    "description": "An issue was discovered in FoldingAtHome Client Advanced Control GUI before commit 9b619ae64443997948a36dda01b420578de1af77, allows remote attackers to execute arbitrary code via crafted payload to function parse_message in file Connection.py.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-08-11T14:15:10.973",
    "last_modified": "2024-11-21T05:21:21.697",
    "fix_date": "2020-09-22T05:37:40Z"
  },
  "references": [
    {
      "url": "https://github.com/FoldingAtHome/fah-control/commit/9b619ae64443997948a36dda01b420578de1af77",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/FoldingAtHome/fah-control/commit/9b619ae64443997948a36dda01b420578de1af77",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:06.422320",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "fah-control",
    "owner": "FoldingAtHome",
    "created_at": "2013-03-29T01:29:13Z",
    "updated_at": "2024-12-07T20:39:03Z",
    "pushed_at": "2023-08-06T11:21:48Z",
    "size": 3419,
    "stars": 120,
    "forks": 44,
    "open_issues": 31,
    "watchers": 120,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Python": 735364,
      "Shell": 2178,
      "Rich Text Format": 749
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-14T14:06:39.329262"
  }
}