{
  "cve_id": "CVE-2020-27673",
  "github_data": {
    "repository": "torvalds/linux",
    "fix_commit": "e99502f76271d6bc4e374fe368c50c67a1fd3070",
    "related_commits": [
      "e99502f76271d6bc4e374fe368c50c67a1fd3070",
      "e99502f76271d6bc4e374fe368c50c67a1fd3070"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "e99502f76271d6bc4e374fe368c50c67a1fd3070",
      "commit_date": "2020-09-07T13:47:30Z",
      "author": {
        "login": "jgross1",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "xen/events: defer eoi in case of excessive number of events",
        "length": 1258,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 248,
        "additions": 216,
        "deletions": 32
      },
      "files": [
        {
          "filename": "Documentation/admin-guide/kernel-parameters.txt",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -5828,6 +5828,14 @@\n \t\t\timprove timer resolution at the expense of processing\n \t\t\tmore timer interrupts.\n \n+\txen.event_eoi_delay=\t[XEN]\n+\t\t\tHow long to delay EOI handling in case of event\n+\t\t\tstorms (jiffies). Default is 10.\n+\n+\txen.event_loop_timeout=\t[XEN]\n+\t\t\tAfter which time (jiffies) the event handling loop\n+\t\t\tshould start to delay EOI handling. Default is 2.\n+\n \tnopv=\t\t[X86,XEN,KVM,HYPER_V,VMWARE]\n \t\t\tDisables the PV optimizations forcing the guest to run\n \t\t\tas generic guest with no PV drivers. Currently support"
        },
        {
          "filename": "drivers/xen/events/events_2l.c",
          "status": "modified",
          "additions": 2,
          "deletions": 5,
          "patch": "@@ -161,7 +161,7 @@ static inline xen_ulong_t active_evtchns(unsigned int cpu,\n  * a bitset of words which contain pending event bits.  The second\n  * level is a bitset of pending events themselves.\n  */\n-static void evtchn_2l_handle_events(unsigned cpu)\n+static void evtchn_2l_handle_events(unsigned cpu, struct evtchn_loop_ctrl *ctrl)\n {\n \tint irq;\n \txen_ulong_t pending_words;\n@@ -242,10 +242,7 @@ static void evtchn_2l_handle_events(unsigned cpu)\n \n \t\t\t/* Process port. */\n \t\t\tport = (word_idx * BITS_PER_EVTCHN_WORD) + bit_idx;\n-\t\t\tirq = get_evtchn_to_irq(port);\n-\n-\t\t\tif (irq != -1)\n-\t\t\t\tgeneric_handle_irq(irq);\n+\t\t\thandle_irq_for_port(port, ctrl);\n \n \t\t\tbit_idx = (bit_idx + 1) % BITS_PER_EVTCHN_WORD;\n "
        },
        {
          "filename": "drivers/xen/events/events_base.c",
          "status": "modified",
          "additions": 184,
          "deletions": 5,
          "patch": "@@ -35,6 +35,8 @@\n #include <linux/pci.h>\n #include <linux/spinlock.h>\n #include <linux/cpuhotplug.h>\n+#include <linux/atomic.h>\n+#include <linux/ktime.h>\n \n #ifdef CONFIG_X86\n #include <asm/desc.h>\n@@ -65,6 +67,15 @@\n \n #include \"events_internal.h\"\n \n+#undef MODULE_PARAM_PREFIX\n+#define MODULE_PARAM_PREFIX \"xen.\"\n+\n+static uint __read_mostly event_loop_timeout = 2;\n+module_param(event_loop_timeout, uint, 0644);\n+\n+static uint __read_mostly event_eoi_delay = 10;\n+module_param(event_eoi_delay, uint, 0644);\n+\n const struct evtchn_ops *evtchn_ops;\n \n /*\n@@ -88,6 +99,7 @@ static DEFINE_RWLOCK(evtchn_rwlock);\n  * irq_mapping_update_lock\n  *   evtchn_rwlock\n  *     IRQ-desc lock\n+ *       percpu eoi_list_lock\n  */\n \n static LIST_HEAD(xen_irq_list_head);\n@@ -120,6 +132,8 @@ static struct irq_chip xen_pirq_chip;\n static void enable_dynirq(struct irq_data *data);\n static void disable_dynirq(struct irq_data *data);\n \n+static DEFINE_PER_CPU(unsigned int, irq_epoch);\n+\n static void clear_evtchn_to_irq_row(unsigned row)\n {\n \tunsigned col;\n@@ -399,17 +413,120 @@ void notify_remote_via_irq(int irq)\n }\n EXPORT_SYMBOL_GPL(notify_remote_via_irq);\n \n+struct lateeoi_work {\n+\tstruct delayed_work delayed;\n+\tspinlock_t eoi_list_lock;\n+\tstruct list_head eoi_list;\n+};\n+\n+static DEFINE_PER_CPU(struct lateeoi_work, lateeoi);\n+\n+static void lateeoi_list_del(struct irq_info *info)\n+{\n+\tstruct lateeoi_work *eoi = &per_cpu(lateeoi, info->eoi_cpu);\n+\tunsigned long flags;\n+\n+\tspin_lock_irqsave(&eoi->eoi_list_lock, flags);\n+\tlist_del_init(&info->eoi_list);\n+\tspin_unlock_irqrestore(&eoi->eoi_list_lock, flags);\n+}\n+\n+static void lateeoi_list_add(struct irq_info *info)\n+{\n+\tstruct lateeoi_work *eoi = &per_cpu(lateeoi, info->eoi_cpu);\n+\tstruct irq_info *elem;\n+\tu64 now = get_jiffies_64();\n+\tunsigned long delay;\n+\tunsigned long flags;\n+\n+\tif (now < info->eoi_time)\n+\t\tdelay = info->eoi_time - now;\n+\telse\n+\t\tdelay = 1;\n+\n+\tspin_lock_irqsave(&eoi->eoi_list_lock, flags);\n+\n+\tif (list_empty(&eoi->eoi_list)) {\n+\t\tlist_add(&info->eoi_list, &eoi->eoi_list);\n+\t\tmod_delayed_work_on(info->eoi_cpu, system_wq,\n+\t\t\t\t    &eoi->delayed, delay);\n+\t} else {\n+\t\tlist_for_each_entry_reverse(elem, &eoi->eoi_list, eoi_list) {\n+\t\t\tif (elem->eoi_time <= info->eoi_time)\n+\t\t\t\tbreak;\n+\t\t}\n+\t\tlist_add(&info->eoi_list, &elem->eoi_list);\n+\t}\n+\n+\tspin_unlock_irqrestore(&eoi->eoi_list_lock, flags);\n+}\n+\n static void xen_irq_lateeoi_locked(struct irq_info *info)\n {\n \tevtchn_port_t evtchn;\n+\tunsigned int cpu;\n \n \tevtchn = info->evtchn;\n-\tif (!VALID_EVTCHN(evtchn))\n+\tif (!VALID_EVTCHN(evtchn) || !list_empty(&info->eoi_list))\n \t\treturn;\n \n+\tcpu = info->eoi_cpu;\n+\tif (info->eoi_time && info->irq_epoch == per_cpu(irq_epoch, cpu)) {\n+\t\tlateeoi_list_add(info);\n+\t\treturn;\n+\t}\n+\n+\tinfo->eoi_time = 0;\n \tunmask_evtchn(evtchn);\n }\n \n+static void xen_irq_lateeoi_worker(struct work_struct *work)\n+{\n+\tstruct lateeoi_work *eoi;\n+\tstruct irq_info *info;\n+\tu64 now = get_jiffies_64();\n+\tunsigned long flags;\n+\n+\teoi = container_of(to_delayed_work(work), struct lateeoi_work, delayed);\n+\n+\tread_lock_irqsave(&evtchn_rwlock, flags);\n+\n+\twhile (true) {\n+\t\tspin_lock(&eoi->eoi_list_lock);\n+\n+\t\tinfo = list_first_entry_or_null(&eoi->eoi_list, struct irq_info,\n+\t\t\t\t\t\teoi_list);\n+\n+\t\tif (info == NULL || now < info->eoi_time) {\n+\t\t\tspin_unlock(&eoi->eoi_list_lock);\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tlist_del_init(&info->eoi_list);\n+\n+\t\tspin_unlock(&eoi->eoi_list_lock);\n+\n+\t\tinfo->eoi_time = 0;\n+\n+\t\txen_irq_lateeoi_locked(info);\n+\t}\n+\n+\tif (info)\n+\t\tmod_delayed_work_on(info->eoi_cpu, system_wq,\n+\t\t\t\t    &eoi->delayed, info->eoi_time - now);\n+\n+\tread_unlock_irqrestore(&evtchn_rwlock, flags);\n+}\n+\n+static void xen_cpu_init_eoi(unsigned int cpu)\n+{\n+\tstruct lateeoi_work *eoi = &per_cpu(lateeoi, cpu);\n+\n+\tINIT_DELAYED_WORK(&eoi->delayed, xen_irq_lateeoi_worker);\n+\tspin_lock_init(&eoi->eoi_list_lock);\n+\tINIT_LIST_HEAD(&eoi->eoi_list);\n+}\n+\n void xen_irq_lateeoi(unsigned int irq, unsigned int eoi_flags)\n {\n \tstruct irq_info *info;\n@@ -429,6 +546,7 @@ EXPORT_SYMBOL_GPL(xen_irq_lateeoi);\n static void xen_irq_init(unsigned irq)\n {\n \tstruct irq_info *info;\n+\n #ifdef CONFIG_SMP\n \t/* By default all event channels notify CPU#0. */\n \tcpumask_copy(irq_get_affinity_mask(irq), cpumask_of(0));\n@@ -443,6 +561,7 @@ static void xen_irq_init(unsigned irq)\n \n \tset_info_for_irq(irq, info);\n \n+\tINIT_LIST_HEAD(&info->eoi_list);\n \tlist_add_tail(&info->list, &xen_irq_list_head);\n }\n \n@@ -498,6 +617,9 @@ static void xen_free_irq(unsigned irq)\n \n \twrite_lock_irqsave(&evtchn_rwlock, flags);\n \n+\tif (!list_empty(&info->eoi_list))\n+\t\tlateeoi_list_del(info);\n+\n \tlist_del(&info->list);\n \n \tset_info_for_irq(irq, NULL);\n@@ -1358,17 +1480,66 @@ void xen_send_IPI_one(unsigned int cpu, enum ipi_vector vector)\n \tnotify_remote_via_irq(irq);\n }\n \n+struct evtchn_loop_ctrl {\n+\tktime_t timeout;\n+\tunsigned count;\n+\tbool defer_eoi;\n+};\n+\n+void handle_irq_for_port(evtchn_port_t port, struct evtchn_loop_ctrl *ctrl)\n+{\n+\tint irq;\n+\tstruct irq_info *info;\n+\n+\tirq = get_evtchn_to_irq(port);\n+\tif (irq == -1)\n+\t\treturn;\n+\n+\t/*\n+\t * Check for timeout every 256 events.\n+\t * We are setting the timeout value only after the first 256\n+\t * events in order to not hurt the common case of few loop\n+\t * iterations. The 256 is basically an arbitrary value.\n+\t *\n+\t * In case we are hitting the timeout we need to defer all further\n+\t * EOIs in order to ensure to leave the event handling loop rather\n+\t * sooner than later.\n+\t */\n+\tif (!ctrl->defer_eoi && !(++ctrl->count & 0xff)) {\n+\t\tktime_t kt = ktime_get();\n+\n+\t\tif (!ctrl->timeout) {\n+\t\t\tkt = ktime_add_ms(kt,\n+\t\t\t\t\t  jiffies_to_msecs(event_loop_timeout));\n+\t\t\tctrl->timeout = kt;\n+\t\t} else if (kt > ctrl->timeout) {\n+\t\t\tctrl->defer_eoi = true;\n+\t\t}\n+\t}\n+\n+\tinfo = info_for_irq(irq);\n+\n+\tif (ctrl->defer_eoi) {\n+\t\tinfo->eoi_cpu = smp_processor_id();\n+\t\tinfo->irq_epoch = __this_cpu_read(irq_epoch);\n+\t\tinfo->eoi_time = get_jiffies_64() + event_eoi_delay;\n+\t}\n+\n+\tgeneric_handle_irq(irq);\n+}\n+\n static void __xen_evtchn_do_upcall(void)\n {\n \tstruct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);\n \tint cpu = smp_processor_id();\n+\tstruct evtchn_loop_ctrl ctrl = { 0 };\n \n \tread_lock(&evtchn_rwlock);\n \n \tdo {\n \t\tvcpu_info->evtchn_upcall_pending = 0;\n \n-\t\txen_evtchn_handle_events(cpu);\n+\t\txen_evtchn_handle_events(cpu, &ctrl);\n \n \t\tBUG_ON(!irqs_disabled());\n \n@@ -1377,6 +1548,13 @@ static void __xen_evtchn_do_upcall(void)\n \t} while (vcpu_info->evtchn_upcall_pending);\n \n \tread_unlock(&evtchn_rwlock);\n+\n+\t/*\n+\t * Increment irq_epoch only now to defer EOIs only for\n+\t * xen_irq_lateeoi() invocations occurring from inside the loop\n+\t * above.\n+\t */\n+\t__this_cpu_inc(irq_epoch);\n }\n \n void xen_evtchn_do_upcall(struct pt_regs *regs)\n@@ -1825,16 +2003,15 @@ void xen_setup_callback_vector(void) {}\n static inline void xen_alloc_callback_vector(void) {}\n #endif\n \n-#undef MODULE_PARAM_PREFIX\n-#define MODULE_PARAM_PREFIX \"xen.\"\n-\n static bool fifo_events = true;\n module_param(fifo_events, bool, 0);\n \n static int xen_evtchn_cpu_prepare(unsigned int cpu)\n {\n \tint ret = 0;\n \n+\txen_cpu_init_eoi(cpu);\n+\n \tif (evtchn_ops->percpu_init)\n \t\tret = evtchn_ops->percpu_init(cpu);\n \n@@ -1861,6 +2038,8 @@ void __init xen_init_IRQ(void)\n \tif (ret < 0)\n \t\txen_evtchn_2l_init();\n \n+\txen_cpu_init_eoi(smp_processor_id());\n+\n \tcpuhp_setup_state_nocalls(CPUHP_XEN_EVTCHN_PREPARE,\n \t\t\t\t  \"xen/evtchn:prepare\",\n \t\t\t\t  xen_evtchn_cpu_prepare, xen_evtchn_cpu_dead);"
        },
        {
          "filename": "drivers/xen/events/events_fifo.c",
          "status": "modified",
          "additions": 11,
          "deletions": 19,
          "patch": "@@ -275,19 +275,9 @@ static uint32_t clear_linked(volatile event_word_t *word)\n \treturn w & EVTCHN_FIFO_LINK_MASK;\n }\n \n-static void handle_irq_for_port(evtchn_port_t port)\n-{\n-\tint irq;\n-\n-\tirq = get_evtchn_to_irq(port);\n-\tif (irq != -1)\n-\t\tgeneric_handle_irq(irq);\n-}\n-\n-static void consume_one_event(unsigned cpu,\n+static void consume_one_event(unsigned cpu, struct evtchn_loop_ctrl *ctrl,\n \t\t\t      struct evtchn_fifo_control_block *control_block,\n-\t\t\t      unsigned priority, unsigned long *ready,\n-\t\t\t      bool drop)\n+\t\t\t      unsigned priority, unsigned long *ready)\n {\n \tstruct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);\n \tuint32_t head;\n@@ -320,16 +310,17 @@ static void consume_one_event(unsigned cpu,\n \t\tclear_bit(priority, ready);\n \n \tif (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {\n-\t\tif (unlikely(drop))\n+\t\tif (unlikely(!ctrl))\n \t\t\tpr_warn(\"Dropping pending event for port %u\\n\", port);\n \t\telse\n-\t\t\thandle_irq_for_port(port);\n+\t\t\thandle_irq_for_port(port, ctrl);\n \t}\n \n \tq->head[priority] = head;\n }\n \n-static void __evtchn_fifo_handle_events(unsigned cpu, bool drop)\n+static void __evtchn_fifo_handle_events(unsigned cpu,\n+\t\t\t\t\tstruct evtchn_loop_ctrl *ctrl)\n {\n \tstruct evtchn_fifo_control_block *control_block;\n \tunsigned long ready;\n@@ -341,14 +332,15 @@ static void __evtchn_fifo_handle_events(unsigned cpu, bool drop)\n \n \twhile (ready) {\n \t\tq = find_first_bit(&ready, EVTCHN_FIFO_MAX_QUEUES);\n-\t\tconsume_one_event(cpu, control_block, q, &ready, drop);\n+\t\tconsume_one_event(cpu, ctrl, control_block, q, &ready);\n \t\tready |= xchg(&control_block->ready, 0);\n \t}\n }\n \n-static void evtchn_fifo_handle_events(unsigned cpu)\n+static void evtchn_fifo_handle_events(unsigned cpu,\n+\t\t\t\t      struct evtchn_loop_ctrl *ctrl)\n {\n-\t__evtchn_fifo_handle_events(cpu, false);\n+\t__evtchn_fifo_handle_events(cpu, ctrl);\n }\n \n static void evtchn_fifo_resume(void)\n@@ -416,7 +408,7 @@ static int evtchn_fifo_percpu_init(unsigned int cpu)\n \n static int evtchn_fifo_percpu_deinit(unsigned int cpu)\n {\n-\t__evtchn_fifo_handle_events(cpu, true);\n+\t__evtchn_fifo_handle_events(cpu, NULL);\n \treturn 0;\n }\n "
        },
        {
          "filename": "drivers/xen/events/events_internal.h",
          "status": "modified",
          "additions": 11,
          "deletions": 3,
          "patch": "@@ -30,11 +30,15 @@ enum xen_irq_type {\n  */\n struct irq_info {\n \tstruct list_head list;\n+\tstruct list_head eoi_list;\n \tint refcnt;\n \tenum xen_irq_type type;\t/* type */\n \tunsigned irq;\n \tevtchn_port_t evtchn;\t/* event channel */\n \tunsigned short cpu;\t/* cpu bound */\n+\tunsigned short eoi_cpu;\t/* EOI must happen on this cpu */\n+\tunsigned int irq_epoch;\t/* If eoi_cpu valid: irq_epoch of event */\n+\tu64 eoi_time;\t\t/* Time in jiffies when to EOI. */\n \n \tunion {\n \t\tunsigned short virq;\n@@ -53,6 +57,8 @@ struct irq_info {\n #define PIRQ_SHAREABLE\t(1 << 1)\n #define PIRQ_MSI_GROUP\t(1 << 2)\n \n+struct evtchn_loop_ctrl;\n+\n struct evtchn_ops {\n \tunsigned (*max_channels)(void);\n \tunsigned (*nr_channels)(void);\n@@ -67,7 +73,7 @@ struct evtchn_ops {\n \tvoid (*mask)(evtchn_port_t port);\n \tvoid (*unmask)(evtchn_port_t port);\n \n-\tvoid (*handle_events)(unsigned cpu);\n+\tvoid (*handle_events)(unsigned cpu, struct evtchn_loop_ctrl *ctrl);\n \tvoid (*resume)(void);\n \n \tint (*percpu_init)(unsigned int cpu);\n@@ -78,6 +84,7 @@ extern const struct evtchn_ops *evtchn_ops;\n \n extern int **evtchn_to_irq;\n int get_evtchn_to_irq(evtchn_port_t evtchn);\n+void handle_irq_for_port(evtchn_port_t port, struct evtchn_loop_ctrl *ctrl);\n \n struct irq_info *info_for_irq(unsigned irq);\n unsigned cpu_from_irq(unsigned irq);\n@@ -135,9 +142,10 @@ static inline void unmask_evtchn(evtchn_port_t port)\n \treturn evtchn_ops->unmask(port);\n }\n \n-static inline void xen_evtchn_handle_events(unsigned cpu)\n+static inline void xen_evtchn_handle_events(unsigned cpu,\n+\t\t\t\t\t    struct evtchn_loop_ctrl *ctrl)\n {\n-\treturn evtchn_ops->handle_events(cpu);\n+\treturn evtchn_ops->handle_events(cpu, ctrl);\n }\n \n static inline void xen_evtchn_resume(void)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "aa22f4da2a46b484a257d167c67a2adc1b7aaf68",
            "date": "2025-01-26T00:23:38Z",
            "author_login": "torvalds"
          },
          {
            "sha": "eda061cccd146fcbe71051bb4aa5a8672b71216e",
            "date": "2025-01-26T00:19:10Z",
            "author_login": "torvalds"
          },
          {
            "sha": "08de7f9d4d39fd9aa5e747a13acc891214fa2d5f",
            "date": "2025-01-26T00:12:07Z",
            "author_login": "torvalds"
          },
          {
            "sha": "647d69605c70368d54fc012fce8a43e8e5955b04",
            "date": "2025-01-26T00:03:40Z",
            "author_login": "torvalds"
          },
          {
            "sha": "184a0997fb77f4a9527fc867fcd16806776c27ce",
            "date": "2025-01-25T23:59:46Z",
            "author_login": "torvalds"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": null,
    "description": "An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. Guest OS users can cause a denial of service (host OS hang) via a high rate of events to dom0, aka CID-e99502f76271.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-10-22T21:15:14.013",
    "last_modified": "2024-11-21T05:21:38.377",
    "fix_date": "2020-09-07T13:47:30Z"
  },
  "references": [
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2020-10/msg00075.html",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2020-11/msg00025.html",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2021/01/19/6",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=e99502f76271d6bc4e374fe368c50c67a1fd3070",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/e99502f76271d6bc4e374fe368c50c67a1fd3070",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2020/12/msg00015.html",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2020/12/msg00027.html",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202011-06",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://xenbits.xen.org/xsa/advisory-332.html",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2020-10/msg00075.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://lists.opensuse.org/opensuse-security-announce/2020-11/msg00025.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2021/01/19/6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=e99502f76271d6bc4e374fe368c50c67a1fd3070",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/e99502f76271d6bc4e374fe368c50c67a1fd3070",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2020/12/msg00015.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2020/12/msg00027.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202011-06",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://xenbits.xen.org/xsa/advisory-332.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:06.191895",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "linux",
    "owner": "torvalds",
    "created_at": "2011-09-04T22:48:12Z",
    "updated_at": "2025-01-14T12:39:03Z",
    "pushed_at": "2025-01-13T17:27:04Z",
    "size": 5361369,
    "stars": 185823,
    "forks": 54743,
    "open_issues": 437,
    "watchers": 185823,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1326937103,
      "Assembly": 9568292,
      "Shell": 5072004,
      "Python": 2974128,
      "Makefile": 2713905,
      "Perl": 1253637,
      "Rust": 807711,
      "Roff": 202277,
      "C++": 173382,
      "SmPL": 165946,
      "Yacc": 127472,
      "Lex": 71321,
      "Awk": 69539,
      "Jinja": 30138,
      "UnrealScript": 16848,
      "Gherkin": 10172,
      "M4": 3329,
      "MATLAB": 2482,
      "sed": 2433,
      "Clojure": 2411,
      "XS": 1239,
      "RPC": 962
    },
    "commit_activity": {
      "total_commits_last_year": 46007,
      "avg_commits_per_week": 884.75,
      "days_active_last_year": 359
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T12:53:59.486675"
  }
}