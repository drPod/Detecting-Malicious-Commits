{
  "cve_id": "CVE-2020-28097",
  "github_data": {
    "repository": "torvalds/linux",
    "fix_commit": "973c096f6a85e5b5f2a295126ba6928d9a6afd45",
    "related_commits": [
      "973c096f6a85e5b5f2a295126ba6928d9a6afd45",
      "973c096f6a85e5b5f2a295126ba6928d9a6afd45"
    ],
    "patch_url": "https://github.com/torvalds/linux/commit/973c096f6a85e5b5f2a295126ba6928d9a6afd45.patch",
    "fix_commit_details": {
      "sha": "973c096f6a85e5b5f2a295126ba6928d9a6afd45",
      "commit_date": "2020-09-09T21:53:50Z",
      "author": {
        "login": "torvalds",
        "type": "User",
        "stats": {
          "total_commits": 38386,
          "average_weekly_commits": 32.28427249789739,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 880
        }
      },
      "commit_message": {
        "title": "vgacon: remove software scrollback support",
        "length": 1416,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 271,
        "additions": 1,
        "deletions": 270
      },
      "files": [
        {
          "filename": "arch/powerpc/configs/pasemi_defconfig",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -108,7 +108,6 @@ CONFIG_FB_NVIDIA=y\n CONFIG_FB_NVIDIA_I2C=y\n CONFIG_FB_RADEON=y\n # CONFIG_LCD_CLASS_DEVICE is not set\n-CONFIG_VGACON_SOFT_SCROLLBACK=y\n CONFIG_LOGO=y\n CONFIG_SOUND=y\n CONFIG_SND=y"
        },
        {
          "filename": "arch/powerpc/configs/ppc6xx_defconfig",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -743,7 +743,6 @@ CONFIG_FB_TRIDENT=m\n CONFIG_FB_SM501=m\n CONFIG_FB_IBM_GXT4500=y\n CONFIG_LCD_PLATFORM=m\n-CONFIG_VGACON_SOFT_SCROLLBACK=y\n CONFIG_FRAMEBUFFER_CONSOLE=y\n CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y\n CONFIG_LOGO=y"
        },
        {
          "filename": "arch/x86/configs/i386_defconfig",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -186,7 +186,6 @@ CONFIG_DRM_I915=y\n CONFIG_FB_MODE_HELPERS=y\n CONFIG_FB_TILEBLITTING=y\n CONFIG_FB_EFI=y\n-CONFIG_VGACON_SOFT_SCROLLBACK=y\n CONFIG_LOGO=y\n # CONFIG_LOGO_LINUX_MONO is not set\n # CONFIG_LOGO_LINUX_VGA16 is not set"
        },
        {
          "filename": "arch/x86/configs/x86_64_defconfig",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -181,7 +181,6 @@ CONFIG_DRM_I915=y\n CONFIG_FB_MODE_HELPERS=y\n CONFIG_FB_TILEBLITTING=y\n CONFIG_FB_EFI=y\n-CONFIG_VGACON_SOFT_SCROLLBACK=y\n CONFIG_LOGO=y\n # CONFIG_LOGO_LINUX_MONO is not set\n # CONFIG_LOGO_LINUX_VGA16 is not set"
        },
        {
          "filename": "drivers/video/console/Kconfig",
          "status": "modified",
          "additions": 0,
          "deletions": 46,
          "patch": "@@ -22,52 +22,6 @@ config VGA_CONSOLE\n \n \t  Say Y.\n \n-config VGACON_SOFT_SCROLLBACK\n-       bool \"Enable Scrollback Buffer in System RAM\"\n-       depends on VGA_CONSOLE\n-       default n\n-       help\n-\t The scrollback buffer of the standard VGA console is located in\n-\t the VGA RAM.  The size of this RAM is fixed and is quite small.\n-\t If you require a larger scrollback buffer, this can be placed in\n-\t System RAM which is dynamically allocated during initialization.\n-\t Placing the scrollback buffer in System RAM will slightly slow\n-\t down the console.\n-\n-\t If you want this feature, say 'Y' here and enter the amount of\n-\t RAM to allocate for this buffer.  If unsure, say 'N'.\n-\n-config VGACON_SOFT_SCROLLBACK_SIZE\n-       int \"Scrollback Buffer Size (in KB)\"\n-       depends on VGACON_SOFT_SCROLLBACK\n-       range 1 1024\n-       default \"64\"\n-       help\n-\t  Enter the amount of System RAM to allocate for scrollback\n-\t  buffers of VGA consoles. Each 64KB will give you approximately\n-\t  16 80x25 screenfuls of scrollback buffer.\n-\n-config VGACON_SOFT_SCROLLBACK_PERSISTENT_ENABLE_BY_DEFAULT\n-\tbool \"Persistent Scrollback History for each console by default\"\n-\tdepends on VGACON_SOFT_SCROLLBACK\n-\tdefault n\n-\thelp\n-\t  Say Y here if the scrollback history should persist by default when\n-\t  switching between consoles. Otherwise, the scrollback history will be\n-\t  flushed each time the console is switched. This feature can also be\n-\t  enabled using the boot command line parameter\n-\t  'vgacon.scrollback_persistent=1'.\n-\n-\t  This feature might break your tool of choice to flush the scrollback\n-\t  buffer, e.g. clear(1) will work fine but Debian's clear_console(1)\n-\t  will be broken, which might cause security issues.\n-\t  You can use the escape sequence \\e[3J instead if this feature is\n-\t  activated.\n-\n-\t  Note that a buffer of VGACON_SOFT_SCROLLBACK_SIZE is taken for each\n-\t  created tty device.\n-\t  So if you use a RAM-constrained system, say N here.\n-\n config MDA_CONSOLE\n \tdepends on !M68K && !PARISC && ISA\n \ttristate \"MDA text console (dual-headed)\""
        },
        {
          "filename": "drivers/video/console/vgacon.c",
          "status": "modified",
          "additions": 1,
          "deletions": 220,
          "patch": "@@ -165,214 +165,6 @@ static inline void vga_set_mem_top(struct vc_data *c)\n \twrite_vga(12, (c->vc_visible_origin - vga_vram_base) / 2);\n }\n \n-#ifdef CONFIG_VGACON_SOFT_SCROLLBACK\n-/* software scrollback */\n-struct vgacon_scrollback_info {\n-\tvoid *data;\n-\tint tail;\n-\tint size;\n-\tint rows;\n-\tint cnt;\n-\tint cur;\n-\tint save;\n-\tint restore;\n-};\n-\n-static struct vgacon_scrollback_info *vgacon_scrollback_cur;\n-static struct vgacon_scrollback_info vgacon_scrollbacks[MAX_NR_CONSOLES];\n-static bool scrollback_persistent = \\\n-\tIS_ENABLED(CONFIG_VGACON_SOFT_SCROLLBACK_PERSISTENT_ENABLE_BY_DEFAULT);\n-module_param_named(scrollback_persistent, scrollback_persistent, bool, 0000);\n-MODULE_PARM_DESC(scrollback_persistent, \"Enable persistent scrollback for all vga consoles\");\n-\n-static void vgacon_scrollback_reset(int vc_num, size_t reset_size)\n-{\n-\tstruct vgacon_scrollback_info *scrollback = &vgacon_scrollbacks[vc_num];\n-\n-\tif (scrollback->data && reset_size > 0)\n-\t\tmemset(scrollback->data, 0, reset_size);\n-\n-\tscrollback->cnt  = 0;\n-\tscrollback->tail = 0;\n-\tscrollback->cur  = 0;\n-}\n-\n-static void vgacon_scrollback_init(int vc_num)\n-{\n-\tint pitch = vga_video_num_columns * 2;\n-\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n-\tint rows = size / pitch;\n-\tvoid *data;\n-\n-\tdata = kmalloc_array(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE, 1024,\n-\t\t\t     GFP_NOWAIT);\n-\n-\tvgacon_scrollbacks[vc_num].data = data;\n-\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n-\n-\tvgacon_scrollback_cur->rows = rows - 1;\n-\tvgacon_scrollback_cur->size = rows * pitch;\n-\n-\tvgacon_scrollback_reset(vc_num, size);\n-}\n-\n-static void vgacon_scrollback_switch(int vc_num)\n-{\n-\tif (!scrollback_persistent)\n-\t\tvc_num = 0;\n-\n-\tif (!vgacon_scrollbacks[vc_num].data) {\n-\t\tvgacon_scrollback_init(vc_num);\n-\t} else {\n-\t\tif (scrollback_persistent) {\n-\t\t\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n-\t\t} else {\n-\t\t\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n-\n-\t\t\tvgacon_scrollback_reset(vc_num, size);\n-\t\t}\n-\t}\n-}\n-\n-static void vgacon_scrollback_startup(void)\n-{\n-\tvgacon_scrollback_cur = &vgacon_scrollbacks[0];\n-\tvgacon_scrollback_init(0);\n-}\n-\n-static void vgacon_scrollback_update(struct vc_data *c, int t, int count)\n-{\n-\tvoid *p;\n-\n-\tif (!vgacon_scrollback_cur->data || !vgacon_scrollback_cur->size ||\n-\t    c->vc_num != fg_console)\n-\t\treturn;\n-\n-\tp = (void *) (c->vc_origin + t * c->vc_size_row);\n-\n-\twhile (count--) {\n-\t\tif ((vgacon_scrollback_cur->tail + c->vc_size_row) >\n-\t\t    vgacon_scrollback_cur->size)\n-\t\t\tvgacon_scrollback_cur->tail = 0;\n-\n-\t\tscr_memcpyw(vgacon_scrollback_cur->data +\n-\t\t\t    vgacon_scrollback_cur->tail,\n-\t\t\t    p, c->vc_size_row);\n-\n-\t\tvgacon_scrollback_cur->cnt++;\n-\t\tp += c->vc_size_row;\n-\t\tvgacon_scrollback_cur->tail += c->vc_size_row;\n-\n-\t\tif (vgacon_scrollback_cur->tail >= vgacon_scrollback_cur->size)\n-\t\t\tvgacon_scrollback_cur->tail = 0;\n-\n-\t\tif (vgacon_scrollback_cur->cnt > vgacon_scrollback_cur->rows)\n-\t\t\tvgacon_scrollback_cur->cnt = vgacon_scrollback_cur->rows;\n-\n-\t\tvgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;\n-\t}\n-}\n-\n-static void vgacon_restore_screen(struct vc_data *c)\n-{\n-\tc->vc_origin = c->vc_visible_origin;\n-\tvgacon_scrollback_cur->save = 0;\n-\n-\tif (!vga_is_gfx && !vgacon_scrollback_cur->restore) {\n-\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n-\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n-\t\t\t    vga_vram_size : c->vc_screenbuf_size);\n-\t\tvgacon_scrollback_cur->restore = 1;\n-\t\tvgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;\n-\t}\n-}\n-\n-static void vgacon_scrolldelta(struct vc_data *c, int lines)\n-{\n-\tint start, end, count, soff;\n-\n-\tif (!lines) {\n-\t\tvgacon_restore_screen(c);\n-\t\treturn;\n-\t}\n-\n-\tif (!vgacon_scrollback_cur->data)\n-\t\treturn;\n-\n-\tif (!vgacon_scrollback_cur->save) {\n-\t\tvgacon_cursor(c, CM_ERASE);\n-\t\tvgacon_save_screen(c);\n-\t\tc->vc_origin = (unsigned long)c->vc_screenbuf;\n-\t\tvgacon_scrollback_cur->save = 1;\n-\t}\n-\n-\tvgacon_scrollback_cur->restore = 0;\n-\tstart = vgacon_scrollback_cur->cur + lines;\n-\tend = start + abs(lines);\n-\n-\tif (start < 0)\n-\t\tstart = 0;\n-\n-\tif (start > vgacon_scrollback_cur->cnt)\n-\t\tstart = vgacon_scrollback_cur->cnt;\n-\n-\tif (end < 0)\n-\t\tend = 0;\n-\n-\tif (end > vgacon_scrollback_cur->cnt)\n-\t\tend = vgacon_scrollback_cur->cnt;\n-\n-\tvgacon_scrollback_cur->cur = start;\n-\tcount = end - start;\n-\tsoff = vgacon_scrollback_cur->tail -\n-\t\t((vgacon_scrollback_cur->cnt - end) * c->vc_size_row);\n-\tsoff -= count * c->vc_size_row;\n-\n-\tif (soff < 0)\n-\t\tsoff += vgacon_scrollback_cur->size;\n-\n-\tcount = vgacon_scrollback_cur->cnt - start;\n-\n-\tif (count > c->vc_rows)\n-\t\tcount = c->vc_rows;\n-\n-\tif (count) {\n-\t\tint copysize;\n-\n-\t\tint diff = c->vc_rows - count;\n-\t\tvoid *d = (void *) c->vc_visible_origin;\n-\t\tvoid *s = (void *) c->vc_screenbuf;\n-\n-\t\tcount *= c->vc_size_row;\n-\t\t/* how much memory to end of buffer left? */\n-\t\tcopysize = min(count, vgacon_scrollback_cur->size - soff);\n-\t\tscr_memcpyw(d, vgacon_scrollback_cur->data + soff, copysize);\n-\t\td += copysize;\n-\t\tcount -= copysize;\n-\n-\t\tif (count) {\n-\t\t\tscr_memcpyw(d, vgacon_scrollback_cur->data, count);\n-\t\t\td += count;\n-\t\t}\n-\n-\t\tif (diff)\n-\t\t\tscr_memcpyw(d, s, diff * c->vc_size_row);\n-\t} else\n-\t\tvgacon_cursor(c, CM_MOVE);\n-}\n-\n-static void vgacon_flush_scrollback(struct vc_data *c)\n-{\n-\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n-\n-\tvgacon_scrollback_reset(c->vc_num, size);\n-}\n-#else\n-#define vgacon_scrollback_startup(...) do { } while (0)\n-#define vgacon_scrollback_init(...)    do { } while (0)\n-#define vgacon_scrollback_update(...)  do { } while (0)\n-#define vgacon_scrollback_switch(...)  do { } while (0)\n-\n static void vgacon_restore_screen(struct vc_data *c)\n {\n \tif (c->vc_origin != c->vc_visible_origin)\n@@ -386,11 +178,6 @@ static void vgacon_scrolldelta(struct vc_data *c, int lines)\n \tvga_set_mem_top(c);\n }\n \n-static void vgacon_flush_scrollback(struct vc_data *c)\n-{\n-}\n-#endif /* CONFIG_VGACON_SOFT_SCROLLBACK */\n-\n static const char *vgacon_startup(void)\n {\n \tconst char *display_desc = NULL;\n@@ -573,10 +360,7 @@ static const char *vgacon_startup(void)\n \tvgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;\n \tvgacon_yres = vga_scan_lines;\n \n-\tif (!vga_init_done) {\n-\t\tvgacon_scrollback_startup();\n-\t\tvga_init_done = true;\n-\t}\n+\tvga_init_done = true;\n \n \treturn display_desc;\n }\n@@ -869,7 +653,6 @@ static int vgacon_switch(struct vc_data *c)\n \t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n \t}\n \n-\tvgacon_scrollback_switch(c->vc_num);\n \treturn 0;\t\t/* Redrawing not needed */\n }\n \n@@ -1386,7 +1169,6 @@ static bool vgacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,\n \toldo = c->vc_origin;\n \tdelta = lines * c->vc_size_row;\n \tif (dir == SM_UP) {\n-\t\tvgacon_scrollback_update(c, t, lines);\n \t\tif (c->vc_scr_end + delta >= vga_vram_end) {\n \t\t\tscr_memcpyw((u16 *) vga_vram_base,\n \t\t\t\t    (u16 *) (oldo + delta),\n@@ -1450,7 +1232,6 @@ const struct consw vga_con = {\n \t.con_save_screen = vgacon_save_screen,\n \t.con_build_attr = vgacon_build_attr,\n \t.con_invert_region = vgacon_invert_region,\n-\t.con_flush_scrollback = vgacon_flush_scrollback,\n };\n EXPORT_SYMBOL(vga_con);\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 5,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7f5b6a8ec18e3add4c74682f60b90c31bdf849f2",
            "date": "2025-01-14T19:32:14Z",
            "author_login": "torvalds"
          },
          {
            "sha": "c3812b15000cc5b7b17c7238f8b12f6a22df0b1d",
            "date": "2025-01-14T18:07:40Z",
            "author_login": "torvalds"
          },
          {
            "sha": "79a1d390f879563119bf2848b621bc7eed228c7d",
            "date": "2025-01-14T17:54:57Z",
            "author_login": "torvalds"
          },
          {
            "sha": "c45323b7560ec87c37c729b703c86ee65f136d75",
            "date": "2025-01-13T17:03:18Z",
            "author_login": "torvalds"
          },
          {
            "sha": "34c8e74cd6667ef5da90d448a1af702c4b873bd3",
            "date": "2025-01-13T08:52:08Z",
            "author_login": "YageGeng"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.9,
    "cvss_vector": "CVSS:3.1/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
    "cwe_id": "CWE-125",
    "description": "The vgacon subsystem in the Linux kernel before 5.8.10 mishandles software scrollback. There is a vgacon_scrolldelta out-of-bounds read, aka CID-973c096f6a85.",
    "attack_vector": "PHYSICAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-06-24T12:15:07.780",
    "last_modified": "2024-11-21T05:22:21.650",
    "fix_date": "2020-09-09T21:53:50Z"
  },
  "references": [
    {
      "url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.8.10",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=973c096f6a85e5b5f2a295126ba6928d9a6afd45",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/973c096f6a85e5b5f2a295126ba6928d9a6afd45",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://seclists.org/oss-sec/2020/q3/176",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20210805-0001/",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.8.10",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=973c096f6a85e5b5f2a295126ba6928d9a6afd45",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/torvalds/linux/commit/973c096f6a85e5b5f2a295126ba6928d9a6afd45",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://seclists.org/oss-sec/2020/q3/176",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20210805-0001/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:59.755337",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "linux",
    "owner": "torvalds",
    "created_at": "2011-09-04T22:48:12Z",
    "updated_at": "2025-01-14T12:39:03Z",
    "pushed_at": "2025-01-13T17:27:04Z",
    "size": 5361369,
    "stars": 185823,
    "forks": 54743,
    "open_issues": 437,
    "watchers": 185823,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1326937103,
      "Assembly": 9568292,
      "Shell": 5072004,
      "Python": 2974128,
      "Makefile": 2713905,
      "Perl": 1253637,
      "Rust": 807711,
      "Roff": 202277,
      "C++": 173382,
      "SmPL": 165946,
      "Yacc": 127472,
      "Lex": 71321,
      "Awk": 69539,
      "Jinja": 30138,
      "UnrealScript": 16848,
      "Gherkin": 10172,
      "M4": 3329,
      "MATLAB": 2482,
      "sed": 2433,
      "Clojure": 2411,
      "XS": 1239,
      "RPC": 962
    },
    "commit_activity": {
      "total_commits_last_year": 46007,
      "avg_commits_per_week": 884.75,
      "days_active_last_year": 359
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T12:53:59.486675"
  }
}