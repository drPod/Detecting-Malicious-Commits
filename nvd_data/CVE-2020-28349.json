{
  "cve_id": "CVE-2020-28349",
  "github_data": {
    "repository": "brocaar/chirpstack-network-server",
    "fix_commit": "874fc1a9b01045ebe8a340f0bb01ed19e8256e60",
    "related_commits": [
      "874fc1a9b01045ebe8a340f0bb01ed19e8256e60",
      "f996bb0c6c85281b5658f59ff09db1b4a73db453",
      "874fc1a9b01045ebe8a340f0bb01ed19e8256e60",
      "f996bb0c6c85281b5658f59ff09db1b4a73db453"
    ],
    "patch_url": "https://github.com/brocaar/chirpstack-network-server/commit/874fc1a9b01045ebe8a340f0bb01ed19e8256e60.patch",
    "fix_commit_details": {
      "sha": "874fc1a9b01045ebe8a340f0bb01ed19e8256e60",
      "commit_date": "2020-07-09T06:45:02Z",
      "author": {
        "login": "brocaar",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Improve error handling of unknown gateways.",
        "length": 43,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 99,
        "additions": 51,
        "deletions": 48
      },
      "files": [
        {
          "filename": "internal/gateway/rx_info.go",
          "status": "modified",
          "additions": 29,
          "deletions": 42,
          "patch": "@@ -25,68 +25,53 @@ import (\n //   - add the gateway location\n //   - set the FPGA id if available\n //   - decrypt the fine-timestamp (if available and AES key is set)\n-func UpdateMetaDataInRxInfoSet(ctx context.Context, db sqlx.Queryer, rxInfo []*gw.UplinkRXInfo) error {\n-\tfor i := range rxInfo {\n-\t\tid := helpers.GetGatewayID(rxInfo[i])\n+func UpdateMetaDataInRxInfoSet(ctx context.Context, db sqlx.Queryer, rxInfoSet []*gw.UplinkRXInfo) []*gw.UplinkRXInfo {\n+\tvar out []*gw.UplinkRXInfo\n+\n+\tfor i := range rxInfoSet {\n+\t\trxInfo := rxInfoSet[i]\n+\n+\t\tid := helpers.GetGatewayID(rxInfo)\n \t\tg, err := storage.GetAndCacheGateway(ctx, db, id)\n \t\tif err != nil {\n-\t\t\tlog.WithFields(log.Fields{\n-\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n-\t\t\t\t\"gateway_id\": id,\n-\t\t\t}).WithError(err).Error(\"get gateway error\")\n+\t\t\tif errors.Cause(err) == storage.ErrDoesNotExist {\n+\t\t\t\tlog.WithFields(log.Fields{\n+\t\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n+\t\t\t\t\t\"gateway_id\": id,\n+\t\t\t\t}).Warning(\"uplink received by unknown gateway\")\n+\t\t\t} else {\n+\t\t\t\tlog.WithFields(log.Fields{\n+\t\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n+\t\t\t\t\t\"gateway_id\": id,\n+\t\t\t\t}).WithError(err).Error(\"get gateway error\")\n+\t\t\t}\n \t\t\tcontinue\n \t\t}\n \n \t\t// set gateway location\n-\t\trxInfo[i].Location = &common.Location{\n+\t\trxInfo.Location = &common.Location{\n \t\t\tLatitude:  g.Location.Latitude,\n \t\t\tLongitude: g.Location.Longitude,\n \t\t\tAltitude:  g.Altitude,\n \t\t}\n \n \t\tvar board storage.GatewayBoard\n-\t\tif int(rxInfo[i].Board) < len(g.Boards) {\n-\t\t\tboard = g.Boards[int(rxInfo[i].Board)]\n+\t\tif int(rxInfo.Board) < len(g.Boards) {\n+\t\t\tboard = g.Boards[int(rxInfo.Board)]\n \t\t}\n \n \t\t// set FPGA ID\n \t\t// this is useful when the AES decryption key is not set as it\n \t\t// indicates which key to use for decryption\n-\t\tif rxInfo[i].FineTimestampType == gw.FineTimestampType_ENCRYPTED && board.FPGAID != nil {\n-\t\t\ttsInfo := rxInfo[i].GetEncryptedFineTimestamp()\n-\t\t\tif tsInfo == nil {\n-\t\t\t\tlog.WithFields(log.Fields{\n-\t\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n-\t\t\t\t\t\"gateway_id\": id,\n-\t\t\t\t}).Error(\"encrypted_fine_timestamp must not be nil\")\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n+\t\tif tsInfo := rxInfo.GetEncryptedFineTimestamp(); tsInfo != nil && board.FPGAID != nil {\n \t\t\tif len(tsInfo.FpgaId) == 0 {\n \t\t\t\ttsInfo.FpgaId = board.FPGAID[:]\n \t\t\t}\n \t\t}\n \n \t\t// decrypt fine-timestamp when the AES key is known\n-\t\tif rxInfo[i].FineTimestampType == gw.FineTimestampType_ENCRYPTED && board.FineTimestampKey != nil {\n-\t\t\ttsInfo := rxInfo[i].GetEncryptedFineTimestamp()\n-\t\t\tif tsInfo == nil {\n-\t\t\t\tlog.WithFields(log.Fields{\n-\t\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n-\t\t\t\t\t\"gateway_id\": id,\n-\t\t\t\t}).Error(\"encrypted_fine_timestamp must not be nil\")\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\tif rxInfo[i].Time == nil {\n-\t\t\t\tlog.WithFields(log.Fields{\n-\t\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n-\t\t\t\t\t\"gateway_id\": id,\n-\t\t\t\t}).Error(\"time must not be nil\")\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\trxTime, err := ptypes.Timestamp(rxInfo[i].Time)\n+\t\tif tsInfo := rxInfo.GetEncryptedFineTimestamp(); tsInfo != nil && board.FineTimestampKey != nil {\n+\t\t\trxTime, err := ptypes.Timestamp(rxInfo.GetTime())\n \t\t\tif err != nil {\n \t\t\t\tlog.WithFields(log.Fields{\n \t\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n@@ -103,14 +88,16 @@ func UpdateMetaDataInRxInfoSet(ctx context.Context, db sqlx.Queryer, rxInfo []*g\n \t\t\t\tcontinue\n \t\t\t}\n \n-\t\t\trxInfo[i].FineTimestampType = gw.FineTimestampType_PLAIN\n-\t\t\trxInfo[i].FineTimestamp = &gw.UplinkRXInfo_PlainFineTimestamp{\n+\t\t\trxInfo.FineTimestampType = gw.FineTimestampType_PLAIN\n+\t\t\trxInfo.FineTimestamp = &gw.UplinkRXInfo_PlainFineTimestamp{\n \t\t\t\tPlainFineTimestamp: &plainTS,\n \t\t\t}\n \t\t}\n+\n+\t\tout = append(out, rxInfo)\n \t}\n \n-\treturn nil\n+\treturn out\n }\n \n func decryptFineTimestamp(key lorawan.AES128Key, rxTime time.Time, ts gw.EncryptedFineTimestamp) (gw.PlainFineTimestamp, error) {"
        },
        {
          "filename": "internal/gateway/stats/stats.go",
          "status": "modified",
          "additions": 14,
          "deletions": 1,
          "patch": "@@ -18,6 +18,8 @@ import (\n \tloraband \"github.com/brocaar/lorawan/band\"\n )\n \n+var ErrAbort = errors.New(\"abort\")\n+\n type statsContext struct {\n \tctx          context.Context\n \tgateway      storage.Gateway\n@@ -40,6 +42,9 @@ func Handle(ctx context.Context, stats gw.GatewayStats) error {\n \n \tfor _, t := range tasks {\n \t\tif err := t(&sctx); err != nil {\n+\t\t\tif err == ErrAbort {\n+\t\t\t\treturn nil\n+\t\t\t}\n \t\t\treturn err\n \t\t}\n \t}\n@@ -51,7 +56,15 @@ func getGateway(ctx *statsContext) error {\n \tgatewayID := helpers.GetGatewayID(&ctx.gatewayStats)\n \tgw, err := storage.GetAndCacheGateway(ctx.ctx, storage.DB(), gatewayID)\n \tif err != nil {\n-\t\treturn errors.Wrap(err, \"get gateway error\")\n+\t\tif errors.Cause(err) == storage.ErrDoesNotExist {\n+\t\t\tlog.WithFields(log.Fields{\n+\t\t\t\t\"ctx_id\":     ctx.ctx.Value(logging.ContextIDKey),\n+\t\t\t\t\"gateway_id\": gatewayID,\n+\t\t\t}).Warning(\"gateway/stats: stats received by unknown gateway\")\n+\t\t\treturn ErrAbort\n+\t\t} else {\n+\t\t\treturn errors.Wrap(err, \"get gateway error\")\n+\t\t}\n \t}\n \n \tctx.gateway = gw"
        },
        {
          "filename": "internal/uplink/uplink.go",
          "status": "modified",
          "additions": 8,
          "deletions": 5,
          "patch": "@@ -178,6 +178,14 @@ func collectUplinkFrames(ctx context.Context, uplinkFrame gw.UplinkFrame) error\n }\n \n func handleCollectedUplink(ctx context.Context, uplinkFrame gw.UplinkFrame, rxPacket models.RXPacket) error {\n+\t// update the gateway meta-data\n+\trxPacket.RXInfoSet = gateway.UpdateMetaDataInRxInfoSet(ctx, storage.DB(), rxPacket.RXInfoSet)\n+\n+\t// Return if the RXInfoSet is empty.\n+\tif len(rxPacket.RXInfoSet) == 0 {\n+\t\treturn nil\n+\t}\n+\n \tvar uplinkIDs []uuid.UUID\n \tfor _, p := range rxPacket.RXInfoSet {\n \t\tuplinkIDs = append(uplinkIDs, helpers.GetUplinkID(p))\n@@ -189,11 +197,6 @@ func handleCollectedUplink(ctx context.Context, uplinkFrame gw.UplinkFrame, rxPa\n \t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n \t}).Info(\"uplink: frame(s) collected\")\n \n-\t// update the gateway meta-data\n-\tif err := gateway.UpdateMetaDataInRxInfoSet(ctx, storage.DB(), rxPacket.RXInfoSet); err != nil {\n-\t\tlog.WithError(err).Error(\"uplink: update gateway meta-data in rx-info set error\")\n-\t}\n-\n \t// log the frame for each receiving gateway.\n \tif err := framelog.LogUplinkFrameForGateways(ctx, ns.UplinkFrameLog{\n \t\tPhyPayload: uplinkFrame.PhyPayload,"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "072461791961702aa1f00f788f81fadb2f7df0e7",
            "date": "2023-07-03T12:29:38Z",
            "author_login": "brocaar"
          },
          {
            "sha": "880656ff20c491e0eb24d3d169f80ad066365740",
            "date": "2023-04-03T11:45:07Z",
            "author_login": "brocaar"
          },
          {
            "sha": "f49e4e5399cab00a1d7c9f030ea6f377b8564242",
            "date": "2023-04-03T11:36:54Z",
            "author_login": "brocaar"
          },
          {
            "sha": "2a287fa6cf45b5982dd7e64658260fa9d916360b",
            "date": "2023-04-03T11:36:07Z",
            "author_login": "fancar"
          },
          {
            "sha": "370565abc8167bc2272b076b1af44e81d23c24cd",
            "date": "2023-01-24T15:28:45Z",
            "author_login": "brocaar"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-20",
    "description": "An inaccurate frame deduplication process in ChirpStack Network Server 3.9.0 allows a malicious gateway to perform uplink Denial of Service via malformed frequency attributes in CollectAndCallOnceCollect in internal/uplink/collect.go. NOTE: the vendor's position is that there are no \"guarantees that allowing untrusted LoRa gateways to the network should still result in a secure network.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-11-09T01:15:13.710",
    "last_modified": "2024-11-21T05:22:39.030",
    "fix_date": "2020-07-09T06:45:02Z"
  },
  "references": [
    {
      "url": "https://github.com/brocaar/chirpstack-network-server/commit/874fc1a9b01045ebe8a340f0bb01ed19e8256e60",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/brocaar/chirpstack-network-server/commit/f996bb0c6c85281b5658f59ff09db1b4a73db453",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.cyberark.com/resources/threat-research-blog/lorawan-mqtt-what-to-know-when-securing-your-iot-network",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/brocaar/chirpstack-network-server/commit/874fc1a9b01045ebe8a340f0bb01ed19e8256e60",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/brocaar/chirpstack-network-server/commit/f996bb0c6c85281b5658f59ff09db1b4a73db453",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.cyberark.com/resources/threat-research-blog/lorawan-mqtt-what-to-know-when-securing-your-iot-network",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:08.453218",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "chirpstack-network-server",
    "owner": "brocaar",
    "created_at": "2015-12-27T14:26:38Z",
    "updated_at": "2025-01-04T15:04:51Z",
    "pushed_at": "2024-08-10T17:43:48Z",
    "size": 8993,
    "stars": 1501,
    "forks": 547,
    "open_issues": 42,
    "watchers": 1501,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Go": 1339740,
      "Shell": 5554,
      "Makefile": 1723,
      "Dockerfile": 692
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T23:07:40.286763"
  }
}