{
  "cve_id": "CVE-2020-35535",
  "github_data": {
    "repository": "LibRaw/LibRaw",
    "fix_commit": "c243f4539233053466c1309bde606815351bee81",
    "related_commits": [
      "c243f4539233053466c1309bde606815351bee81",
      "c243f4539233053466c1309bde606815351bee81"
    ],
    "patch_url": "https://github.com/LibRaw/LibRaw/commit/c243f4539233053466c1309bde606815351bee81.patch",
    "fix_commit_details": {
      "sha": "c243f4539233053466c1309bde606815351bee81",
      "commit_date": "2020-05-10T17:48:24Z",
      "author": {
        "login": "alextutubalin",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "additional checks in parseSonySRF",
        "length": 66,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 90,
        "additions": 62,
        "deletions": 28
      },
      "files": [
        {
          "filename": "src/metadata/sony.cpp",
          "status": "modified",
          "additions": 62,
          "deletions": 28,
          "patch": "@@ -1799,6 +1799,14 @@ void LibRaw::parseSonySR2(uchar *cbuf_SR2, unsigned SR2SubIFDOffset,\n   float num;\n   int i;\n   int WBCTC_count;\n+#define CHECKBUFFER_N(offset,N)                                     \\\n+  do                                                                \\\n+  {                                                                 \\\n+    if ((((offset) + (N)) > SR2SubIFDLength) || ((offset) < 0))     \\\n+      return;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+  CHECKBUFFER_N(0, 2);\n   entries = sget2(cbuf_SR2);\n   if (entries > 1000)\n     return;\n@@ -1812,43 +1820,52 @@ void LibRaw::parseSonySR2(uchar *cbuf_SR2, unsigned SR2SubIFDOffset,\n       if (dng_writer == nonDNG) {\n         switch (tag_id) {\n         case 0x7300:\n-          FORC4 cblack[c] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset + tag_dataunitlen * 4,0);\n+\t\t\tFORC4 cblack[c] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n           TagProcessed = 1;\n           break;\n         case 0x7303:\n-          FORC4 cam_mul[GRBG_2_RGBG(c)] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset + tag_dataunitlen * 4, 0);\n+\t\t\tFORC4 cam_mul[GRBG_2_RGBG(c)] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n           TagProcessed = 1;\n           break;\n         case 0x7310:\n-          FORC4 cblack[RGGB_2_RGBG(c)] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset + tag_dataunitlen * 4, 0);\n+\t\t\tFORC4 cblack[RGGB_2_RGBG(c)] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n           i = cblack[3];\n           FORC3 if (i > cblack[c]) i = cblack[c];\n           FORC4 cblack[c] -= i;\n           black = i;\n           TagProcessed = 1;\n           break;\n         case 0x7313:\n-          FORC4 cam_mul[RGGB_2_RGBG(c)] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset + tag_dataunitlen * 4, 0);\n+\t\t\tFORC4 cam_mul[RGGB_2_RGBG(c)] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n           TagProcessed = 1;\n           break;\n         case 0x74a0:\n-          ilm.MaxAp4MaxFocal = sgetreal(tag_type, cbuf_SR2 + tag_dataoffset);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset, 4);\n+\t\t\tilm.MaxAp4MaxFocal = sgetreal(tag_type, cbuf_SR2 + tag_dataoffset);\n           TagProcessed = 1;\n           break;\n         case 0x74a1:\n-          ilm.MaxAp4MinFocal = sgetreal(tag_type, cbuf_SR2 + tag_dataoffset);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset, 4);\n+\t\t\tilm.MaxAp4MinFocal = sgetreal(tag_type, cbuf_SR2 + tag_dataoffset);\n           TagProcessed = 1;\n           break;\n         case 0x74a2:\n-          ilm.MaxFocal = sgetreal(tag_type, cbuf_SR2 + tag_dataoffset);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset, 4);\n+\t\t\tilm.MaxFocal = sgetreal(tag_type, cbuf_SR2 + tag_dataoffset);\n           TagProcessed = 1;\n           break;\n         case 0x74a3:\n-          ilm.MinFocal = sgetreal(tag_type, cbuf_SR2 + tag_dataoffset);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset, 4);\n+\t\t\tilm.MinFocal = sgetreal(tag_type, cbuf_SR2 + tag_dataoffset);\n           TagProcessed = 1;\n           break;\n         case 0x7800:\n-          for (i = 0; i < 3; i++)\n+\t\t\tCHECKBUFFER_N(tag_dataoffset + tag_dataunitlen * 8, 2);\n+\t\t  for (i = 0; i < 3; i++)\n           {\n             num = 0.0;\n             for (c = 0; c < 3; c++)\n@@ -1865,12 +1882,14 @@ void LibRaw::parseSonySR2(uchar *cbuf_SR2, unsigned SR2SubIFDOffset,\n         case 0x787f:\n           if (tag_datalen == 3)\n           {\n-            FORC3 imgdata.color.linear_max[c] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\t  CHECKBUFFER_N(tag_dataoffset + tag_dataunitlen * 2, 2);\n+\t\t\t  FORC3 imgdata.color.linear_max[c] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n             imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n           }\n           else if (tag_datalen == 1)\n           {\n-            imgdata.color.linear_max[0] = imgdata.color.linear_max[1] =\n+\t\t\t  CHECKBUFFER_N(tag_dataoffset, 2);\n+\t\t\t  imgdata.color.linear_max[0] = imgdata.color.linear_max[1] =\n                 imgdata.color.linear_max[2] = imgdata.color.linear_max[3] =\n                     sget2(cbuf_SR2 + tag_dataoffset);\n           }\n@@ -1884,37 +1903,44 @@ void LibRaw::parseSonySR2(uchar *cbuf_SR2, unsigned SR2SubIFDOffset,\n           i = tag_id - 0x7480;\n           if (Sony_SR2_wb_list[i] > 255) {\n             icWBCCTC[WBCTC_count][0] = Sony_SR2_wb_list[i];\n-            FORC3 icWBCCTC[WBCTC_count][c + 1] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset + tag_dataunitlen * 2, 2);\n+\t\t\tFORC3 icWBCCTC[WBCTC_count][c + 1] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n             icWBCCTC[WBCTC_count][4] = icWBCCTC[WBCTC_count][2];\n             WBCTC_count++;\n           } else {\n-            FORC3 icWBC[Sony_SR2_wb_list[i]][c] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\t  CHECKBUFFER_N(tag_dataoffset + tag_dataunitlen * 2, 2);\n+\t\t\t  FORC3 icWBC[Sony_SR2_wb_list[i]][c] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n             icWBC[Sony_SR2_wb_list[i]][3] = icWBC[Sony_SR2_wb_list[i]][1];\n           }\n         } else if ((tag_id >= 0x7820) && (tag_id <= 0x782d)) {\n           i = tag_id - 0x7820;\n           if (Sony_SR2_wb_list1[i] > 255) {\n             icWBCCTC[WBCTC_count][0] = Sony_SR2_wb_list1[i];\n-            FORC3 icWBCCTC[WBCTC_count][c + 1] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset + tag_dataunitlen * 2, 2);\n+\t\t\tFORC3 icWBCCTC[WBCTC_count][c + 1] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n             icWBCCTC[WBCTC_count][4] = icWBCCTC[WBCTC_count][2];\n             if (Sony_SR2_wb_list1[i] == 3200) {\n               FORC3 icWBC[LIBRAW_WBI_StudioTungsten][c] = icWBCCTC[WBCTC_count][c + 1];\n               icWBC[LIBRAW_WBI_StudioTungsten][3] = icWBC[LIBRAW_WBI_StudioTungsten][1];\n             }\n             WBCTC_count++;\n           } else {\n-            FORC3 icWBC[Sony_SR2_wb_list1[i]][c] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\t  CHECKBUFFER_N(tag_dataoffset + tag_dataunitlen * 2, 2);\n+\t\t\t  FORC3 icWBC[Sony_SR2_wb_list1[i]][c] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n             icWBC[Sony_SR2_wb_list1[i]][3] = icWBC[Sony_SR2_wb_list1[i]][1];\n           }\n         } else if (tag_id == 0x7302) {\n-          FORC4 icWBC[LIBRAW_WBI_Auto][GRBG_2_RGBG(c)] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset + tag_dataunitlen * 3, 2);\n+\t\t\tFORC4 icWBC[LIBRAW_WBI_Auto][GRBG_2_RGBG(c)] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n         } else if (tag_id == 0x7312) {\n-          FORC4 icWBC[LIBRAW_WBI_Auto][RGGB_2_RGBG(c)] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset + tag_dataunitlen * 3, 2);\n+\t\t\tFORC4 icWBC[LIBRAW_WBI_Auto][RGGB_2_RGBG(c)] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n         }\n       }\n     }\n   }\n }\n+#undef CHECKBUFFER_N\n \n void LibRaw::parseSonySRF(unsigned len)\n {\n@@ -1935,10 +1961,10 @@ void LibRaw::parseSonySRF(unsigned len)\n   INT64 srf_offset, tag_offset, tag_data, tag_dataoffset;\n   int tag_dataunitlen;\n   uchar *srf_buf;\n-  short entries;\n+  ushort entries;\n   unsigned tag_id, tag_type, tag_datalen;\n \n-  srf_buf = (uchar *)malloc(len);\n+  srf_buf = (uchar *)malloc(len+64);\n   fread(srf_buf, len, 1, ifp);\n \n   offset += srf_buf[offset] << 2;\n@@ -1995,9 +2021,11 @@ void LibRaw::parseSonySRF(unsigned len)\n                    &tag_offset, &tag_id, &tag_type, &tag_dataoffset,\n                    &tag_datalen, &tag_dataunitlen) == 0) {\n       if (tag_id == 0x0000) {\n-        SRF2Key = sget4(srf_buf + tag_dataoffset);\n+\t\t  CHECKBUFFER_SGET4(tag_dataoffset);\n+\t\t  SRF2Key = sget4(srf_buf + tag_dataoffset);\n       } else if (tag_id == 0x0001) {\n-        RawDataKey = sget4(srf_buf + tag_dataoffset);\n+\t\t  CHECKBUFFER_SGET4(tag_dataoffset);\n+\t\t  RawDataKey = sget4(srf_buf + tag_dataoffset);\n       }\n     } else goto restore_after_parseSonySRF;\n   }\n@@ -2019,20 +2047,22 @@ void LibRaw::parseSonySRF(unsigned len)\n   tag_offset = offset;\n \n   while (entries--) {\n-    if (tiff_sget (save, srf_buf, len,\n+\t  if (tiff_sget(save, srf_buf, len,\n                    &tag_offset, &tag_id, &tag_type, &tag_dataoffset,\n                    &tag_datalen, &tag_dataunitlen) == 0) {\n       if ((tag_id >= 0x00c0) && (tag_id <= 0x00ce)) {\n         i = (tag_id - 0x00c0) % 3;\n         nWB = (tag_id - 0x00c0) / 3;\n-        icWBC[Sony_SRF_wb_list[nWB]][i] = sget4(srf_buf + tag_dataoffset);\n+\t\tCHECKBUFFER_SGET4(tag_dataoffset);\n+\t\ticWBC[Sony_SRF_wb_list[nWB]][i] = sget4(srf_buf + tag_dataoffset);\n         if (i == 1) {\n           icWBC[Sony_SRF_wb_list[nWB]][3] =\n             icWBC[Sony_SRF_wb_list[nWB]][i];\n         }\n       } else if ((tag_id >= 0x00d0) && (tag_id <= 0x00d2)) {\n         i = (tag_id - 0x00d0) % 3;\n-        cam_mul[i] = sget4(srf_buf + tag_dataoffset);\n+\t\tCHECKBUFFER_SGET4(tag_dataoffset);\n+\t\tcam_mul[i] = sget4(srf_buf + tag_dataoffset);\n         if (i == 1) {\n           cam_mul[3] = cam_mul[i];\n         }\n@@ -2044,16 +2074,20 @@ void LibRaw::parseSonySRF(unsigned len)\n         0x0005  RawDataLength\n         */\n       case 0x0043:\n-        ilm.MaxAp4MaxFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n+\t\t  CHECKBUFFER_SGET4(tag_dataoffset); // need to add extra space\n+\t\t  ilm.MaxAp4MaxFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n         break;\n       case 0x0044:\n-         ilm.MaxAp4MinFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n+\t\t  CHECKBUFFER_SGET4(tag_dataoffset);\n+\t\t  ilm.MaxAp4MinFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n         break;\n       case 0x0045:\n-        ilm.MinFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n+\t\t  CHECKBUFFER_SGET4(tag_dataoffset);\n+\t\t  ilm.MinFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n         break;\n       case 0x0046:\n-        ilm.MaxFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n+\t\t  CHECKBUFFER_SGET4(tag_dataoffset);\n+\t\t  ilm.MaxFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n         break;\n       }\n     } else goto restore_after_parseSonySRF;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "cc118c1c1869e2559dbd0c7639d219154cc46e40",
            "date": "2024-11-30T15:36:46Z",
            "author_login": "alextutubalin"
          },
          {
            "sha": "9bcb8a1d9593ba67e4eb67fed716efc5e1353d5c",
            "date": "2024-09-18T09:07:43Z",
            "author_login": "alextutubalin"
          },
          {
            "sha": "bf1a9140e0d032c0f3d5eccbe2b7aa4e7167e287",
            "date": "2024-09-16T08:49:24Z",
            "author_login": "alextutubalin"
          },
          {
            "sha": "77a46b31978a2381e61df524dc9b6670a1f22321",
            "date": "2024-09-16T08:45:25Z",
            "author_login": "alextutubalin"
          },
          {
            "sha": "4f5a4cfb3724eb57386efad362b998b68a10eba7",
            "date": "2024-09-14T17:32:15Z",
            "author_login": "alextutubalin"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-125",
    "description": "In LibRaw, there is an out-of-bounds read vulnerability within the \"LibRaw::parseSonySRF()\" function (libraw\\src\\metadata\\sony.cpp) when processing srf files.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-09-01T18:15:09.027",
    "last_modified": "2024-11-21T05:27:31.240",
    "fix_date": "2020-05-10T17:48:24Z"
  },
  "references": [
    {
      "url": "https://github.com/LibRaw/LibRaw/commit/c243f4539233053466c1309bde606815351bee81",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/LibRaw/LibRaw/issues/283",
      "source": "secalert@redhat.com",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/LibRaw/LibRaw/commit/c243f4539233053466c1309bde606815351bee81",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/LibRaw/LibRaw/issues/283",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:39.070033",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "LibRaw",
    "owner": "LibRaw",
    "created_at": "2010-10-11T18:01:13Z",
    "updated_at": "2025-01-14T03:39:50Z",
    "pushed_at": "2024-11-30T15:42:21Z",
    "size": 14433,
    "stars": 1172,
    "forks": 287,
    "open_issues": 2,
    "watchers": 1172,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 2012970,
      "C": 18819,
      "M4": 8267,
      "QMake": 6245,
      "Makefile": 5329,
      "Shell": 1869,
      "Perl": 1289
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:49:33.251436"
  }
}