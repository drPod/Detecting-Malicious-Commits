{
  "cve_id": "CVE-2020-35538",
  "github_data": {
    "repository": "libjpeg-turbo/libjpeg-turbo",
    "fix_commit": "9120a247436e84c0b4eea828cb11e8f665fcde30",
    "related_commits": [
      "9120a247436e84c0b4eea828cb11e8f665fcde30",
      "9120a247436e84c0b4eea828cb11e8f665fcde30"
    ],
    "patch_url": "https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30.patch",
    "fix_commit_details": {
      "sha": "9120a247436e84c0b4eea828cb11e8f665fcde30",
      "commit_date": "2020-07-24T02:24:38Z",
      "author": {
        "login": "dcommander",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix jpeg_skip_scanlines() segfault w/merged upsamp",
        "length": 1080,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 187,
        "additions": 134,
        "deletions": 53
      },
      "files": [
        {
          "filename": "ChangeLog.md",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -7,6 +7,12 @@\n platforms when using any of the YUV encoding/compression/decompression/decoding\n methods in the TurboJPEG Java API.\n \n+2. Fixed segfaults or \"Corrupt JPEG data: premature end of data segment\" errors\n+in `jpeg_skip_scanlines()` that occurred when decompressing 4:2:2 or 4:2:0 JPEG\n+images using the merged (non-fancy) upsampling algorithms (that is, when\n+setting `cinfo.do_fancy_upsampling` to `FALSE`.)  2.0.0[6] was a similar fix,\n+but it did not cover all cases.\n+\n \n 2.0.5\n ====="
        },
        {
          "filename": "jdapistd.c",
          "status": "modified",
          "additions": 64,
          "deletions": 8,
          "patch": "@@ -4,7 +4,7 @@\n  * This file was part of the Independent JPEG Group's software:\n  * Copyright (C) 1994-1996, Thomas G. Lane.\n  * libjpeg-turbo Modifications:\n- * Copyright (C) 2010, 2015-2018, D. R. Commander.\n+ * Copyright (C) 2010, 2015-2018, 2020, D. R. Commander.\n  * Copyright (C) 2015, Google, Inc.\n  * For conditions of distribution and use, see the accompanying README.ijg\n  * file.\n@@ -21,6 +21,8 @@\n #include \"jinclude.h\"\n #include \"jdmainct.h\"\n #include \"jdcoefct.h\"\n+#include \"jdmaster.h\"\n+#include \"jdmerge.h\"\n #include \"jdsample.h\"\n #include \"jmemsys.h\"\n \n@@ -304,6 +306,16 @@ noop_quantize(j_decompress_ptr cinfo, JSAMPARRAY input_buf,\n }\n \n \n+/* Dummy postprocessing function used by jpeg_skip_scanlines() */\n+LOCAL(void)\n+noop_post_process (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n+                   JDIMENSION *in_row_group_ctr,\n+                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n+                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n+{\n+}\n+\n+\n /*\n  * In some cases, it is best to call jpeg_read_scanlines() and discard the\n  * output, rather than skipping the scanlines, because this allows us to\n@@ -316,11 +328,17 @@ LOCAL(void)\n read_and_discard_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n {\n   JDIMENSION n;\n+  my_master_ptr master = (my_master_ptr)cinfo->master;\n   void (*color_convert) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                          JDIMENSION input_row, JSAMPARRAY output_buf,\n                          int num_rows) = NULL;\n   void (*color_quantize) (j_decompress_ptr cinfo, JSAMPARRAY input_buf,\n                           JSAMPARRAY output_buf, int num_rows) = NULL;\n+  void (*post_process_data) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n+                             JDIMENSION *in_row_group_ctr,\n+                             JDIMENSION in_row_groups_avail,\n+                             JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\n+                             JDIMENSION out_rows_avail) = NULL;\n \n   if (cinfo->cconvert && cinfo->cconvert->color_convert) {\n     color_convert = cinfo->cconvert->color_convert;\n@@ -332,6 +350,12 @@ read_and_discard_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n     cinfo->cquantize->color_quantize = noop_quantize;\n   }\n \n+  if (master->using_merged_upsample && cinfo->post &&\n+      cinfo->post->post_process_data) {\n+    post_process_data = cinfo->post->post_process_data;\n+    cinfo->post->post_process_data = noop_post_process;\n+  }\n+\n   for (n = 0; n < num_lines; n++)\n     jpeg_read_scanlines(cinfo, NULL, 1);\n \n@@ -340,6 +364,9 @@ read_and_discard_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n \n   if (color_quantize)\n     cinfo->cquantize->color_quantize = color_quantize;\n+\n+  if (post_process_data)\n+    cinfo->post->post_process_data = post_process_data;\n }\n \n \n@@ -382,7 +409,7 @@ jpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n {\n   my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n   my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_master_ptr master = (my_master_ptr)cinfo->master;\n   JDIMENSION i, x;\n   int y;\n   JDIMENSION lines_per_iMCU_row, lines_left_in_iMCU_row, lines_after_iMCU_row;\n@@ -445,8 +472,16 @@ jpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n     main_ptr->buffer_full = FALSE;\n     main_ptr->rowgroup_ctr = 0;\n     main_ptr->context_state = CTX_PREPARE_FOR_IMCU;\n-    upsample->next_row_out = cinfo->max_v_samp_factor;\n-    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+    if (master->using_merged_upsample) {\n+      my_merged_upsample_ptr upsample =\n+        (my_merged_upsample_ptr)cinfo->upsample;\n+      upsample->spare_full = FALSE;\n+      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+    } else {\n+      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+      upsample->next_row_out = cinfo->max_v_samp_factor;\n+      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+    }\n   }\n \n   /* Skipping is much simpler when context rows are not required. */\n@@ -458,8 +493,16 @@ jpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n       cinfo->output_scanline += lines_left_in_iMCU_row;\n       main_ptr->buffer_full = FALSE;\n       main_ptr->rowgroup_ctr = 0;\n-      upsample->next_row_out = cinfo->max_v_samp_factor;\n-      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+      if (master->using_merged_upsample) {\n+        my_merged_upsample_ptr upsample =\n+          (my_merged_upsample_ptr)cinfo->upsample;\n+        upsample->spare_full = FALSE;\n+        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+      } else {\n+        my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+        upsample->next_row_out = cinfo->max_v_samp_factor;\n+        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+      }\n     }\n   }\n \n@@ -494,7 +537,14 @@ jpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n       cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;\n       increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n     }\n-    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+    if (master->using_merged_upsample) {\n+      my_merged_upsample_ptr upsample =\n+        (my_merged_upsample_ptr)cinfo->upsample;\n+      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+    } else {\n+      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+    }\n     return num_lines;\n   }\n \n@@ -535,7 +585,13 @@ jpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n    * bit odd, since \"rows_to_go\" seems to be redundantly keeping track of\n    * output_scanline.\n    */\n-  upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+  if (master->using_merged_upsample) {\n+    my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n+    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+  } else {\n+    my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+  }\n \n   /* Always skip the requested number of lines. */\n   return num_lines;"
        },
        {
          "filename": "jdmerge.c",
          "status": "modified",
          "additions": 9,
          "deletions": 37,
          "patch": "@@ -5,7 +5,7 @@\n  * Copyright (C) 1994-1996, Thomas G. Lane.\n  * libjpeg-turbo Modifications:\n  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB\n- * Copyright (C) 2009, 2011, 2014-2015, D. R. Commander.\n+ * Copyright (C) 2009, 2011, 2014-2015, 2020, D. R. Commander.\n  * Copyright (C) 2013, Linaro Limited.\n  * For conditions of distribution and use, see the accompanying README.ijg\n  * file.\n@@ -40,41 +40,13 @@\n #define JPEG_INTERNALS\n #include \"jinclude.h\"\n #include \"jpeglib.h\"\n+#include \"jdmerge.h\"\n #include \"jsimd.h\"\n #include \"jconfigint.h\"\n \n #ifdef UPSAMPLE_MERGING_SUPPORTED\n \n \n-/* Private subobject */\n-\n-typedef struct {\n-  struct jpeg_upsampler pub;    /* public fields */\n-\n-  /* Pointer to routine to do actual upsampling/conversion of one row group */\n-  void (*upmethod) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n-                    JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);\n-\n-  /* Private state for YCC->RGB conversion */\n-  int *Cr_r_tab;                /* => table for Cr to R conversion */\n-  int *Cb_b_tab;                /* => table for Cb to B conversion */\n-  JLONG *Cr_g_tab;              /* => table for Cr to G conversion */\n-  JLONG *Cb_g_tab;              /* => table for Cb to G conversion */\n-\n-  /* For 2:1 vertical sampling, we produce two output rows at a time.\n-   * We need a \"spare\" row buffer to hold the second output row if the\n-   * application provides just a one-row buffer; we also use the spare\n-   * to discard the dummy last row if the image height is odd.\n-   */\n-  JSAMPROW spare_row;\n-  boolean spare_full;           /* T if spare buffer is occupied */\n-\n-  JDIMENSION out_row_width;     /* samples per output row */\n-  JDIMENSION rows_to_go;        /* counts rows remaining in image */\n-} my_upsampler;\n-\n-typedef my_upsampler *my_upsample_ptr;\n-\n #define SCALEBITS       16      /* speediest right-shift on some machines */\n #define ONE_HALF        ((JLONG)1 << (SCALEBITS - 1))\n #define FIX(x)          ((JLONG)((x) * (1L << SCALEBITS) + 0.5))\n@@ -189,7 +161,7 @@ typedef my_upsampler *my_upsample_ptr;\n LOCAL(void)\n build_ycc_rgb_table(j_decompress_ptr cinfo)\n {\n-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n   int i;\n   JLONG x;\n   SHIFT_TEMPS\n@@ -232,7 +204,7 @@ build_ycc_rgb_table(j_decompress_ptr cinfo)\n METHODDEF(void)\n start_pass_merged_upsample(j_decompress_ptr cinfo)\n {\n-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n \n   /* Mark the spare buffer empty */\n   upsample->spare_full = FALSE;\n@@ -254,7 +226,7 @@ merged_2v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                    JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n /* 2:1 vertical sampling case: may need a spare row. */\n {\n-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n   JSAMPROW work_ptrs[2];\n   JDIMENSION num_rows;          /* number of rows returned to caller */\n \n@@ -305,7 +277,7 @@ merged_1v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                    JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n /* 1:1 vertical sampling case: much easier, never need a spare row. */\n {\n-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n \n   /* Just do the upsampling. */\n   (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,\n@@ -566,11 +538,11 @@ h2v2_merged_upsample_565D(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n GLOBAL(void)\n jinit_merged_upsampler(j_decompress_ptr cinfo)\n {\n-  my_upsample_ptr upsample;\n+  my_merged_upsample_ptr upsample;\n \n-  upsample = (my_upsample_ptr)\n+  upsample = (my_merged_upsample_ptr)\n     (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n-                                sizeof(my_upsampler));\n+                                sizeof(my_merged_upsampler));\n   cinfo->upsample = (struct jpeg_upsampler *)upsample;\n   upsample->pub.start_pass = start_pass_merged_upsample;\n   upsample->pub.need_context_rows = FALSE;"
        },
        {
          "filename": "jdmerge.h",
          "status": "added",
          "additions": 47,
          "deletions": 0,
          "patch": "@@ -0,0 +1,47 @@\n+/*\n+ * jdmerge.h\n+ *\n+ * This file was part of the Independent JPEG Group's software:\n+ * Copyright (C) 1994-1996, Thomas G. Lane.\n+ * libjpeg-turbo Modifications:\n+ * Copyright (C) 2020, D. R. Commander.\n+ * For conditions of distribution and use, see the accompanying README.ijg\n+ * file.\n+ */\n+\n+#define JPEG_INTERNALS\n+#include \"jpeglib.h\"\n+\n+#ifdef UPSAMPLE_MERGING_SUPPORTED\n+\n+\n+/* Private subobject */\n+\n+typedef struct {\n+  struct jpeg_upsampler pub;    /* public fields */\n+\n+  /* Pointer to routine to do actual upsampling/conversion of one row group */\n+  void (*upmethod) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n+                    JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);\n+\n+  /* Private state for YCC->RGB conversion */\n+  int *Cr_r_tab;                /* => table for Cr to R conversion */\n+  int *Cb_b_tab;                /* => table for Cb to B conversion */\n+  JLONG *Cr_g_tab;              /* => table for Cr to G conversion */\n+  JLONG *Cb_g_tab;              /* => table for Cb to G conversion */\n+\n+  /* For 2:1 vertical sampling, we produce two output rows at a time.\n+   * We need a \"spare\" row buffer to hold the second output row if the\n+   * application provides just a one-row buffer; we also use the spare\n+   * to discard the dummy last row if the image height is odd.\n+   */\n+  JSAMPROW spare_row;\n+  boolean spare_full;           /* T if spare buffer is occupied */\n+\n+  JDIMENSION out_row_width;     /* samples per output row */\n+  JDIMENSION rows_to_go;        /* counts rows remaining in image */\n+} my_merged_upsampler;\n+\n+typedef my_merged_upsampler *my_merged_upsample_ptr;\n+\n+#endif /* UPSAMPLE_MERGING_SUPPORTED */"
        },
        {
          "filename": "jdmrg565.c",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -5,7 +5,7 @@\n  * Copyright (C) 1994-1996, Thomas G. Lane.\n  * libjpeg-turbo Modifications:\n  * Copyright (C) 2013, Linaro Limited.\n- * Copyright (C) 2014-2015, 2018, D. R. Commander.\n+ * Copyright (C) 2014-2015, 2018, 2020, D. R. Commander.\n  * For conditions of distribution and use, see the accompanying README.ijg\n  * file.\n  *\n@@ -19,7 +19,7 @@ h2v1_merged_upsample_565_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                                   JDIMENSION in_row_group_ctr,\n                                   JSAMPARRAY output_buf)\n {\n-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n   register int y, cred, cgreen, cblue;\n   int cb, cr;\n   register JSAMPROW outptr;\n@@ -90,7 +90,7 @@ h2v1_merged_upsample_565D_internal(j_decompress_ptr cinfo,\n                                    JDIMENSION in_row_group_ctr,\n                                    JSAMPARRAY output_buf)\n {\n-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n   register int y, cred, cgreen, cblue;\n   int cb, cr;\n   register JSAMPROW outptr;\n@@ -163,7 +163,7 @@ h2v2_merged_upsample_565_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                                   JDIMENSION in_row_group_ctr,\n                                   JSAMPARRAY output_buf)\n {\n-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n   register int y, cred, cgreen, cblue;\n   int cb, cr;\n   register JSAMPROW outptr0, outptr1;\n@@ -259,7 +259,7 @@ h2v2_merged_upsample_565D_internal(j_decompress_ptr cinfo,\n                                    JDIMENSION in_row_group_ctr,\n                                    JSAMPARRAY output_buf)\n {\n-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n   register int y, cred, cgreen, cblue;\n   int cb, cr;\n   register JSAMPROW outptr0, outptr1;"
        },
        {
          "filename": "jdmrgext.c",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -4,7 +4,7 @@\n  * This file was part of the Independent JPEG Group's software:\n  * Copyright (C) 1994-1996, Thomas G. Lane.\n  * libjpeg-turbo Modifications:\n- * Copyright (C) 2011, 2015, D. R. Commander.\n+ * Copyright (C) 2011, 2015, 2020, D. R. Commander.\n  * For conditions of distribution and use, see the accompanying README.ijg\n  * file.\n  *\n@@ -25,7 +25,7 @@ h2v1_merged_upsample_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                               JDIMENSION in_row_group_ctr,\n                               JSAMPARRAY output_buf)\n {\n-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n   register int y, cred, cgreen, cblue;\n   int cb, cr;\n   register JSAMPROW outptr;\n@@ -97,7 +97,7 @@ h2v2_merged_upsample_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                               JDIMENSION in_row_group_ctr,\n                               JSAMPARRAY output_buf)\n {\n-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n   register int y, cred, cgreen, cblue;\n   int cb, cr;\n   register JSAMPROW outptr0, outptr1;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e0e18dea5433e600ea92d60814f13efa40a0d7dd",
            "date": "2024-12-18T17:50:38Z",
            "author_login": "dcommander"
          },
          {
            "sha": "cc095fee7b73b6d8dcbeadbc2926a4712be704db",
            "date": "2024-12-18T14:39:53Z",
            "author_login": "dcommander"
          },
          {
            "sha": "20ade4dea9589515a69793e447a6c6220b464535",
            "date": "2024-12-12T20:39:26Z",
            "author_login": "dcommander"
          },
          {
            "sha": "c3446d64d704375039482daf637ac59e7f8bdb26",
            "date": "2024-12-12T16:01:53Z",
            "author_login": "dcommander"
          },
          {
            "sha": "84fa3bc0930dc014f7b50c82ad48925cfd786841",
            "date": "2024-12-11T22:39:02Z",
            "author_login": "dcommander"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-476",
    "description": "A crafted input file could cause a null pointer dereference in jcopy_sample_rows() when processed by libjpeg-turbo.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-08-31T16:15:09.040",
    "last_modified": "2024-11-21T05:27:31.440",
    "fix_date": "2020-07-24T02:24:38Z"
  },
  "references": [
    {
      "url": "https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libjpeg-turbo/libjpeg-turbo/issues/441",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libjpeg-turbo/libjpeg-turbo/issues/441",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:39.062504",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "libjpeg-turbo",
    "owner": "libjpeg-turbo",
    "created_at": "2015-07-27T07:11:54Z",
    "updated_at": "2025-01-14T05:03:54Z",
    "pushed_at": "2024-12-18T21:39:04Z",
    "size": 21014,
    "stars": 3835,
    "forks": 1037,
    "open_issues": 20,
    "watchers": 3835,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "1.0.x",
      "1.1.x",
      "1.2.x",
      "1.3.x",
      "1.4.x",
      "1.5.x",
      "2.0.x",
      "2.1.x",
      "3.0.x",
      "ijg.lossless",
      "ijg",
      "main"
    ],
    "languages": {
      "C": 3381386,
      "Assembly": 1683277,
      "HTML": 528105,
      "Java": 321248,
      "CMake": 160300,
      "C++": 48443,
      "Shell": 34197,
      "CSS": 22360,
      "JavaScript": 19458
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T18:01:04.605765"
  }
}