{
  "cve_id": "CVE-2020-36315",
  "github_data": {
    "repository": "relic-toolkit/relic",
    "fix_commit": "76c9a1fdf19d9e92e566a77376673e522aae9f80",
    "related_commits": [
      "76c9a1fdf19d9e92e566a77376673e522aae9f80",
      "76c9a1fdf19d9e92e566a77376673e522aae9f80"
    ],
    "patch_url": "https://github.com/relic-toolkit/relic/commit/76c9a1fdf19d9e92e566a77376673e522aae9f80.patch",
    "fix_commit_details": {
      "sha": "76c9a1fdf19d9e92e566a77376673e522aae9f80",
      "commit_date": "2020-08-01T23:53:19Z",
      "author": {
        "login": "dfaranha",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix #154 and #155 by inverting the padding check logic and being more rigorous.",
        "length": 79,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 234,
        "additions": 117,
        "deletions": 117
      },
      "files": [
        {
          "filename": "src/cp/relic_cp_rsa.c",
          "status": "modified",
          "additions": 117,
          "deletions": 117,
          "patch": "@@ -129,7 +129,7 @@\n  */\n static int pad_basic(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n \tuint8_t pad = 0;\n-\tint result = RLC_OK;\n+\tint result = RLC_ERR;\n \tbn_t t;\n \n \tRLC_TRY {\n@@ -146,27 +146,27 @@ static int pad_basic(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n \t\t\t\tbn_add_dig(m, m, RSA_PAD);\n \t\t\t\t/* Make room for the real message. */\n \t\t\t\tbn_lsh(m, m, m_len * 8);\n+\t\t\t\tresult = RLC_OK;\n \t\t\t\tbreak;\n \t\t\tcase RSA_DEC:\n \t\t\tcase RSA_VER:\n \t\t\tcase RSA_VER_HASH:\n \t\t\t\t/* EB = 00 | FF | D. */\n \t\t\t\tm_len = k_len - 1;\n \t\t\t\tbn_rsh(t, m, 8 * m_len);\n-\t\t\t\tif (!bn_is_zero(t)) {\n-\t\t\t\t\tresult = RLC_ERR;\n-\t\t\t\t}\n-\t\t\t\t*p_len = 1;\n-\t\t\t\tdo {\n-\t\t\t\t\t(*p_len)++;\n-\t\t\t\t\tm_len--;\n-\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n-\t\t\t\t\tpad = (uint8_t)t->dp[0];\n-\t\t\t\t} while (pad == 0 && m_len > 0);\n-\t\t\t\tif (pad != RSA_PAD) {\n-\t\t\t\t\tresult = RLC_ERR;\n+\t\t\t\tif (bn_is_zero(t)) {\n+\t\t\t\t\t*p_len = 1;\n+\t\t\t\t\tdo {\n+\t\t\t\t\t\t(*p_len)++;\n+\t\t\t\t\t\tm_len--;\n+\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n+\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n+\t\t\t\t\t} while (pad == 0 && m_len > 0);\n+\t\t\t\t\tif (pad == RSA_PAD) {\n+\t\t\t\t\t\tresult = RLC_OK;\n+\t\t\t\t\t}\n+\t\t\t\t\tbn_mod_2b(m, m, (k_len - *p_len) * 8);\n \t\t\t\t}\n-\t\t\t\tbn_mod_2b(m, m, (k_len - *p_len) * 8);\n \t\t\t\tbreak;\n \t\t}\n \t}\n@@ -251,7 +251,7 @@ static uint8_t *hash_id(int md, int *len) {\n  */\n static int pad_pkcs1(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n \tuint8_t *id, pad = 0;\n-\tint len, result = RLC_OK;\n+\tint len, result = RLC_ERR;\n \tbn_t t;\n \n \tbn_null(t);\n@@ -278,29 +278,28 @@ static int pad_pkcs1(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n \t\t\t\tbn_add_dig(m, m, 0);\n \t\t\t\t/* Make room for the real message. */\n \t\t\t\tbn_lsh(m, m, m_len * 8);\n+\t\t\t\tresult = RLC_OK;\n \t\t\t\tbreak;\n \t\t\tcase RSA_DEC:\n \t\t\t\tm_len = k_len - 1;\n \t\t\t\tbn_rsh(t, m, 8 * m_len);\n-\t\t\t\tif (!bn_is_zero(t)) {\n-\t\t\t\t\tresult = RLC_ERR;\n-\t\t\t\t}\n-\n-\t\t\t\t*p_len = m_len;\n-\t\t\t\tm_len--;\n-\t\t\t\tbn_rsh(t, m, 8 * m_len);\n-\t\t\t\tpad = (uint8_t)t->dp[0];\n-\t\t\t\tif (pad != RSA_PUB) {\n-\t\t\t\t\tresult = RLC_ERR;\n-\t\t\t\t}\n-\t\t\t\tdo {\n+\t\t\t\tif (bn_is_zero(t)) {\n+\t\t\t\t\t*p_len = m_len;\n \t\t\t\t\tm_len--;\n \t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n \t\t\t\t\tpad = (uint8_t)t->dp[0];\n-\t\t\t\t} while (pad != 0 && m_len > 0);\n-\t\t\t\t/* Remove padding and trailing zero. */\n-\t\t\t\t*p_len -= (m_len - 1);\n-\t\t\t\tbn_mod_2b(m, m, (k_len - *p_len) * 8);\n+\t\t\t\t\tif (pad == RSA_PUB) {\n+\t\t\t\t\t\tdo {\n+\t\t\t\t\t\t\tm_len--;\n+\t\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n+\t\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n+\t\t\t\t\t\t} while (pad != 0 && m_len > 0);\n+\t\t\t\t\t\t/* Remove padding and trailing zero. */\n+\t\t\t\t\t\t*p_len -= (m_len - 1);\n+\t\t\t\t\t\tbn_mod_2b(m, m, (k_len - *p_len) * 8);\n+\t\t\t\t\t\tresult = (m_len > 0 ? RLC_OK : RLC_ERR);\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase RSA_SIG:\n \t\t\t\t/* EB = 00 | 01 | PS | 00 | D. */\n@@ -321,6 +320,7 @@ static int pad_pkcs1(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n \t\t\t\tbn_add(m, m, t);\n \t\t\t\t/* Make room for the real message. */\n \t\t\t\tbn_lsh(m, m, m_len * 8);\n+\t\t\t\tresult = RLC_OK;\n \t\t\t\tbreak;\n \t\t\tcase RSA_SIG_HASH:\n \t\t\t\t/* EB = 00 | 01 | PS | 00 | D. */\n@@ -337,65 +337,65 @@ static int pad_pkcs1(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n \t\t\t\tbn_add_dig(m, m, 0);\n \t\t\t\t/* Make room for the real message. */\n \t\t\t\tbn_lsh(m, m, m_len * 8);\n+\t\t\t\tresult = RLC_OK;\n \t\t\t\tbreak;\n \t\t\tcase RSA_VER:\n \t\t\t\tm_len = k_len - 1;\n \t\t\t\tbn_rsh(t, m, 8 * m_len);\n-\t\t\t\tif (!bn_is_zero(t)) {\n-\t\t\t\t\tresult = RLC_ERR;\n-\t\t\t\t}\n-\t\t\t\tm_len--;\n-\t\t\t\tbn_rsh(t, m, 8 * m_len);\n-\t\t\t\tpad = (uint8_t)t->dp[0];\n-\t\t\t\tif (pad != RSA_PRV) {\n-\t\t\t\t\tresult = RLC_ERR;\n-\t\t\t\t}\n-\t\t\t\tdo {\n+\t\t\t\tif (bn_is_zero(t)) {\n \t\t\t\t\tm_len--;\n \t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n \t\t\t\t\tpad = (uint8_t)t->dp[0];\n-\t\t\t\t} while (pad != 0 && m_len > 0);\n-\t\t\t\tif (m_len == 0) {\n-\t\t\t\t\tresult = RLC_ERR;\n-\t\t\t\t}\n-\t\t\t\t/* Remove padding and trailing zero. */\n-\t\t\t\tid = hash_id(MD_MAP, &len);\n-\t\t\t\tm_len -= len;\n-\n-\t\t\t\tbn_rsh(t, m, m_len * 8);\n-\t\t\t\tint r = 0;\n-\t\t\t\tfor (int i = 0; i < len; i++) {\n-\t\t\t\t\tpad = (uint8_t)t->dp[0];\n-\t\t\t\t\tr |= pad - id[len - i - 1];\n-\t\t\t\t\tbn_rsh(t, t, 8);\n+\t\t\t\t\tif (pad == RSA_PRV) {\n+\t\t\t\t\t\tint counter = 0;\n+\t\t\t\t\t\tdo {\n+\t\t\t\t\t\t\tcounter++;\n+\t\t\t\t\t\t\tm_len--;\n+\t\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n+\t\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n+\t\t\t\t\t\t} while (pad == RSA_PAD && m_len > 0);\n+\t\t\t\t\t\t/* Remove padding and trailing zero. */\n+\t\t\t\t\t\tid = hash_id(MD_MAP, &len);\n+\t\t\t\t\t\tm_len -= len;\n+\n+\t\t\t\t\t\tbn_rsh(t, m, m_len * 8);\n+\t\t\t\t\t\tint r = 0;\n+\t\t\t\t\t\tfor (int i = 0; i < len; i++) {\n+\t\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n+\t\t\t\t\t\t\tr |= pad ^ id[len - i - 1];\n+\t\t\t\t\t\t\tbn_rsh(t, t, 8);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t*p_len = k_len - m_len;\n+\t\t\t\t\t\tbn_mod_2b(m, m, m_len * 8);\n+\t\t\t\t\t\tif (r && m_len > 0 && counter >= 8) {\n+\t\t\t\t\t\t\tresult = RLC_OK;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\t*p_len = k_len - m_len;\n-\t\t\t\tbn_mod_2b(m, m, m_len * 8);\n-\t\t\t\tresult = (r == 0 ? RLC_OK : RLC_ERR);\n \t\t\t\tbreak;\n \t\t\tcase RSA_VER_HASH:\n \t\t\t\tm_len = k_len - 1;\n \t\t\t\tbn_rsh(t, m, 8 * m_len);\n-\t\t\t\tif (!bn_is_zero(t)) {\n-\t\t\t\t\tresult = RLC_ERR;\n-\t\t\t\t}\n-\t\t\t\tm_len--;\n-\t\t\t\tbn_rsh(t, m, 8 * m_len);\n-\t\t\t\tpad = (uint8_t)t->dp[0];\n-\t\t\t\tif (pad != RSA_PRV) {\n-\t\t\t\t\tresult = RLC_ERR;\n-\t\t\t\t}\n-\t\t\t\tdo {\n+\t\t\t\tif (bn_is_zero(t)) {\n \t\t\t\t\tm_len--;\n \t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n \t\t\t\t\tpad = (uint8_t)t->dp[0];\n-\t\t\t\t} while (pad != 0 && m_len > 0);\n-\t\t\t\tif (m_len == 0) {\n-\t\t\t\t\tresult = RLC_ERR;\n+\t\t\t\t\tif (pad == RSA_PRV) {\n+\t\t\t\t\t\tint counter = 0;\n+\t\t\t\t\t\tdo {\n+\t\t\t\t\t\t\tcounter++;\n+\t\t\t\t\t\t\tm_len--;\n+\t\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n+\t\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n+\t\t\t\t\t\t} while (pad == RSA_PAD && m_len > 0);\n+\t\t\t\t\t\t/* Remove padding and trailing zero. */\n+\t\t\t\t\t\t*p_len = k_len - m_len;\n+\t\t\t\t\t\tbn_mod_2b(m, m, m_len * 8);\n+\t\t\t\t\t\tif (m_len > 0 && counter >= 8) {\n+\t\t\t\t\t\t\tresult = RLC_OK;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\t/* Remove padding and trailing zero. */\n-\t\t\t\t*p_len = k_len - m_len;\n-\t\t\t\tbn_mod_2b(m, m, m_len * 8);\n \t\t\t\tbreak;\n \t\t}\n \t}\n@@ -426,7 +426,7 @@ static int pad_pkcs2(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n         uint8_t pad, h1[RLC_MD_LEN], h2[RLC_MD_LEN];\n         /* MSVC does not allow dynamic stack arrays */\n         uint8_t *mask = RLC_ALLOCA(uint8_t, k_len);\n-\tint result = RLC_OK;\n+\tint result = RLC_ERR;\n \tbn_t t;\n \n \tbn_null(t);\n@@ -445,6 +445,7 @@ static int pad_pkcs2(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n \t\t\t\tbn_add_dig(m, m, 0x01);\n \t\t\t\t/* Make room for the real message. */\n \t\t\t\tbn_lsh(m, m, m_len * 8);\n+\t\t\t\tresult = RLC_OK;\n \t\t\t\tbreak;\n \t\t\tcase RSA_ENC_FIN:\n \t\t\t\t/* EB = 00 | maskedSeed | maskedDB. */\n@@ -463,47 +464,44 @@ static int pad_pkcs2(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n \t\t\t\tbn_lsh(t, t, 8 * (k_len - RLC_MD_LEN - 1));\n \t\t\t\tbn_add(t, t, m);\n \t\t\t\tbn_copy(m, t);\n+\t\t\t\tresult = RLC_OK;\n \t\t\t\tbreak;\n \t\t\tcase RSA_DEC:\n \t\t\t\tm_len = k_len - 1;\n \t\t\t\tbn_rsh(t, m, 8 * m_len);\n-\t\t\t\tif (!bn_is_zero(t)) {\n-\t\t\t\t\tresult = RLC_ERR;\n-\t\t\t\t}\n-\t\t\t\tm_len -= RLC_MD_LEN;\n-\t\t\t\tbn_rsh(t, m, 8 * m_len);\n-\t\t\t\tbn_write_bin(h1, RLC_MD_LEN, t);\n-\t\t\t\tbn_mod_2b(m, m, 8 * m_len);\n-\t\t\t\tbn_write_bin(mask, m_len, m);\n-\t\t\t\tmd_mgf(h2, RLC_MD_LEN, mask, m_len);\n-\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n-\t\t\t\t\th1[i] ^= h2[i];\n-\t\t\t\t}\n-\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n-\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n-\t\t\t\tfor (int i = 0; i < t->used; i++) {\n-\t\t\t\t\tm->dp[i] ^= t->dp[i];\n-\t\t\t\t}\n-\t\t\t\tm_len -= RLC_MD_LEN;\n-\t\t\t\tbn_rsh(t, m, 8 * m_len);\n-\t\t\t\tbn_write_bin(h2, RLC_MD_LEN, t);\n-\t\t\t\tmd_map(h1, NULL, 0);\n-\t\t\t\tpad = 0;\n-\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n-\t\t\t\t\tpad |= h1[i] - h2[i];\n-\t\t\t\t}\n-\t\t\t\tif (result == RLC_OK) {\n-\t\t\t\t\tresult = (pad ? RLC_ERR : RLC_OK);\n-\t\t\t\t}\n-\t\t\t\tbn_mod_2b(m, m, 8 * m_len);\n-\t\t\t\t*p_len = bn_size_bin(m);\n-\t\t\t\t(*p_len)--;\n-\t\t\t\tbn_rsh(t, m, *p_len * 8);\n-\t\t\t\tif (bn_cmp_dig(t, 1) != RLC_EQ) {\n-\t\t\t\t\tresult = RLC_ERR;\n+\t\t\t\tif (bn_is_zero(t)) {\n+\t\t\t\t\tm_len -= RLC_MD_LEN;\n+\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n+\t\t\t\t\tbn_write_bin(h1, RLC_MD_LEN, t);\n+\t\t\t\t\tbn_mod_2b(m, m, 8 * m_len);\n+\t\t\t\t\tbn_write_bin(mask, m_len, m);\n+\t\t\t\t\tmd_mgf(h2, RLC_MD_LEN, mask, m_len);\n+\t\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n+\t\t\t\t\t\th1[i] ^= h2[i];\n+\t\t\t\t\t}\n+\t\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n+\t\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n+\t\t\t\t\tfor (int i = 0; i < t->used; i++) {\n+\t\t\t\t\t\tm->dp[i] ^= t->dp[i];\n+\t\t\t\t\t}\n+\t\t\t\t\tm_len -= RLC_MD_LEN;\n+\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n+\t\t\t\t\tbn_write_bin(h2, RLC_MD_LEN, t);\n+\t\t\t\t\tmd_map(h1, NULL, 0);\n+\t\t\t\t\tpad = 0;\n+\t\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n+\t\t\t\t\t\tpad |= h1[i] ^ h2[i];\n+\t\t\t\t\t}\n+\t\t\t\t\tbn_mod_2b(m, m, 8 * m_len);\n+\t\t\t\t\t*p_len = bn_size_bin(m);\n+\t\t\t\t\t(*p_len)--;\n+\t\t\t\t\tbn_rsh(t, m, *p_len * 8);\n+\t\t\t\t\tif (pad == 0 && bn_cmp_dig(t, 1) == RLC_EQ) {\n+\t\t\t\t\t\tresult = RLC_OK;\n+\t\t\t\t\t}\n+\t\t\t\t\tbn_mod_2b(m, m, *p_len * 8);\n+\t\t\t\t\t*p_len = k_len - *p_len;\n \t\t\t\t}\n-\t\t\t\tbn_mod_2b(m, m, *p_len * 8);\n-\t\t\t\t*p_len = k_len - *p_len;\n \t\t\t\tbreak;\n \t\t\tcase RSA_SIG:\n \t\t\tcase RSA_SIG_HASH:\n@@ -512,6 +510,7 @@ static int pad_pkcs2(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n \t\t\t\tbn_lsh(m, m, 64);\n \t\t\t\t/* Make room for the real message. */\n \t\t\t\tbn_lsh(m, m, RLC_MD_LEN * 8);\n+\t\t\t\tresult = RLC_OK;\n \t\t\t\tbreak;\n \t\t\tcase RSA_SIG_FIN:\n \t\t\t\tmemset(mask, 0, 8);\n@@ -529,16 +528,17 @@ static int pad_pkcs2(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n \t\t\t\tfor (int i = m_len - 1; i < 8 * k_len; i++) {\n \t\t\t\t\tbn_set_bit(m, i, 0);\n \t\t\t\t}\n+\t\t\t\tresult = RLC_OK;\n \t\t\t\tbreak;\n \t\t\tcase RSA_VER:\n \t\t\tcase RSA_VER_HASH:\n \t\t\t\tbn_mod_2b(t, m, 8);\n-\t\t\t\tif (bn_cmp_dig(t, RSA_PSS) != RLC_EQ) {\n-\t\t\t\t\tresult = RLC_ERR;\n-\t\t\t\t} else {\n+\t\t\t\tpad = (uint8_t)t->dp[0];\n+\t\t\t\tif (pad == RSA_PSS) {\n+\t\t\t\t\tint r = 1;\n \t\t\t\t\tfor (int i = m_len; i < 8 * k_len; i++) {\n \t\t\t\t\t\tif (bn_get_bit(m, i) != 0) {\n-\t\t\t\t\t\t\tresult = RLC_ERR;\n+\t\t\t\t\t\t\tr = 0;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tbn_rsh(m, m, 8);\n@@ -555,8 +555,8 @@ static int pad_pkcs2(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n \t\t\t\t\tfor (int i = m_len - 1; i < 8 * k_len; i++) {\n \t\t\t\t\t\tbn_set_bit(m, i - ((RLC_MD_LEN + 1) * 8), 0);\n \t\t\t\t\t}\n-\t\t\t\t\tif (!bn_is_zero(m)) {\n-\t\t\t\t\t\tresult = RLC_ERR;\n+\t\t\t\t\tif (r == 1 && bn_is_zero(m)) {\n+\t\t\t\t\t\tresult = RLC_OK;\n \t\t\t\t\t}\n \t\t\t\t\tbn_read_bin(m, h2, RLC_MD_LEN);\n \t\t\t\t\t*p_len = k_len - RLC_MD_LEN;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "eef556aada450b16b84b85d08642d1cfc45c6e0c",
            "date": "2025-01-11T16:51:59Z",
            "author_login": "dfaranha"
          },
          {
            "sha": "0612d807ebbc554d97b19fc6791a8dcd4264ed91",
            "date": "2025-01-10T13:50:48Z",
            "author_login": "dfaranha"
          },
          {
            "sha": "216ca40e62af772f9333ed4df7894e41e47f42ca",
            "date": "2024-12-30T01:37:58Z",
            "author_login": "dfaranha"
          },
          {
            "sha": "782be63ce7a40f83441a9715395018e39c860d21",
            "date": "2024-12-30T01:11:31Z",
            "author_login": "dfaranha"
          },
          {
            "sha": "c48ba4ffc9a36489fe7b21aef889ed8be45516d0",
            "date": "2024-12-30T00:22:49Z",
            "author_login": "dfaranha"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
    "cwe_id": "CWE-327",
    "description": "In RELIC before 2020-08-01, RSA PKCS#1 v1.5 signature forgery can occur because certain checks of the padding (and of the first two bytes) are inadequate. NOTE: this requires that a low public exponent (such as 3) is being used. The product, by default, does not generate RSA keys with such a low number.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-04-07T21:15:15.870",
    "last_modified": "2024-11-21T05:29:15.320",
    "fix_date": "2020-08-01T23:53:19Z"
  },
  "references": [
    {
      "url": "https://github.com/relic-toolkit/relic/",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/relic-toolkit/relic/commit/76c9a1fdf19d9e92e566a77376673e522aae9f80",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/relic-toolkit/relic/issues/154",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/relic-toolkit/relic/tree/32eb4c257fc80328061d66639b1cdb35dbed51a2",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/relic-toolkit/relic/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/relic-toolkit/relic/commit/76c9a1fdf19d9e92e566a77376673e522aae9f80",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/relic-toolkit/relic/issues/154",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/relic-toolkit/relic/tree/32eb4c257fc80328061d66639b1cdb35dbed51a2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:33.520408",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "relic",
    "owner": "relic-toolkit",
    "created_at": "2014-08-18T21:34:41Z",
    "updated_at": "2025-01-14T13:21:01Z",
    "pushed_at": "2025-01-11T16:52:03Z",
    "size": 16538,
    "stars": 467,
    "forks": 180,
    "open_issues": 11,
    "watchers": 467,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C": 5269206,
      "Assembly": 960652,
      "CMake": 81455,
      "Shell": 33388,
      "C++": 29345
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:06:57.084712"
  }
}