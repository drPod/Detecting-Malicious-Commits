{
  "cve_id": "CVE-2020-36599",
  "github_data": {
    "repository": "omniauth/omniauth",
    "fix_commit": "43a396f181ef7d0ed2ec8291c939c95e3ed3ff00",
    "related_commits": [
      "43a396f181ef7d0ed2ec8291c939c95e3ed3ff00",
      "43a396f181ef7d0ed2ec8291c939c95e3ed3ff00"
    ],
    "patch_url": "https://github.com/omniauth/omniauth/commit/43a396f181ef7d0ed2ec8291c939c95e3ed3ff00.patch",
    "fix_commit_details": {
      "sha": "43a396f181ef7d0ed2ec8291c939c95e3ed3ff00",
      "commit_date": "2020-12-10T15:10:02Z",
      "author": {
        "login": "BobbyMcWho",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge branch '2_0-indev' into fix-path-prefix-when-redirecting-on-failure",
        "length": 73,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 589,
        "additions": 468,
        "deletions": 121
      },
      "files": [
        {
          "filename": ".github/workflows/main.yml",
          "status": "added",
          "additions": 74,
          "deletions": 0,
          "patch": "@@ -0,0 +1,74 @@\n+# This workflow uses actions that are not certified by GitHub.\n+# They are provided by a third-party and are governed by\n+# separate terms of service, privacy policy, and support\n+# documentation.\n+# This workflow will download a prebuilt Ruby version, install dependencies and run tests with Rake\n+# For more information see: https://github.com/marketplace/actions/setup-ruby-jruby-and-truffleruby\n+\n+name: Ruby\n+\n+on:\n+  push:\n+    branches: [ master ]\n+  pull_request:\n+    branches: [ master ]\n+\n+jobs:\n+  test:\n+    runs-on: ubuntu-18.04\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        os: [ubuntu, macos]\n+        ruby: [2.5, 2.6, 2.7, head, debug, truffleruby, truffleruby-head]\n+    steps:\n+    - uses: actions/checkout@v2\n+    - name: Set up Ruby\n+      uses: ruby/setup-ruby@v1\n+      with:\n+        ruby-version: ${{ matrix.ruby }}\n+        bundler-cache: true\n+    - name: Install dependencies\n+      run: bundle install\n+    - name: Run tests\n+      run: bundle exec rake\n+  test-jruby:\n+    runs-on: ubuntu-18.04\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        os: [ubuntu, macos]\n+        jruby: [jruby, jruby-head]\n+    steps:\n+    - uses: actions/checkout@v2\n+    - name: Set up Ruby\n+      uses: ruby/setup-ruby@v1\n+      with:\n+        ruby-version: ${{ matrix.jruby }}\n+        bundler-cache: true\n+    - name: Install dependencies\n+      env:\n+        JRUBY_OPTS: --debug\n+      run: bundle install\n+    - name: Run tests\n+      env:\n+        JRUBY_OPTS: --debug\n+      run: bundle exec rake\n+  coveralls:\n+    runs-on: ubuntu-18.04\n+    steps:\n+    - uses: actions/checkout@v2\n+    - name: Set up Ruby\n+      uses: ruby/setup-ruby@v1\n+      with:\n+        ruby-version: 2.5\n+        bundler-cache: true\n+    - name: Install dependencies\n+      run: bundle install\n+    - name: Run tests\n+      run: bundle exec rake\n+    - name: Coveralls GitHub Action\n+      uses: coverallsapp/github-action@v1.1.2\n+      with:\n+        github-token: ${{ secrets.github_token }}\n+        path-to-lcov: './coverage/lcov/omniauth.lcov'"
        },
        {
          "filename": ".gitignore",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -10,3 +10,4 @@ doc/*\n log/*\n measurement/*\n pkg/*\n+.DS_Store"
        },
        {
          "filename": ".travis.yml",
          "status": "removed",
          "additions": 0,
          "deletions": 25,
          "patch": "@@ -1,25 +0,0 @@\n-bundler_args: --without development\n-before_install:\n-  - gem uninstall -v '>= 2' -i $(rvm gemdir)@global -ax bundler || true\n-  - gem install bundler -v '1.17.3'\n-install:\n- - bundle _1.17.3_ install --jobs=3 --retry=3\n-cache: bundler\n-env:\n-  global:\n-    - JRUBY_OPTS=\"$JRUBY_OPTS --debug\"\n-language: ruby\n-rvm:\n-  - jruby-9000\n-  - 2.2.9\n-  - 2.3.5\n-  - 2.4.4\n-  - 2.5.3\n-  - jruby-head\n-  - ruby-head\n-matrix:\n-  allow_failures:\n-    - rvm: jruby-head\n-    - rvm: ruby-head\n-  fast_finish: true\n-sudo: false"
        },
        {
          "filename": "Gemfile",
          "status": "modified",
          "additions": 5,
          "deletions": 4,
          "patch": "@@ -1,6 +1,6 @@\n source 'https://rubygems.org'\n \n-gem 'jruby-openssl', '~> 0.9.19', :platforms => :jruby\n+gem 'jruby-openssl', '~> 0.10.5', :platforms => :jruby\n gem 'rake', '>= 12.0'\n gem 'yard', '>= 0.9.11'\n \n@@ -12,16 +12,17 @@ group :development do\n end\n \n group :test do\n-  gem 'coveralls', :require => false\n+  gem 'coveralls_reborn', '~> 0.19.0', require: false\n   gem 'hashie', '>= 3.4.6', '~> 4.0.0', :platforms => [:jruby_18]\n-  gem 'json', '~> 2.0.3', :platforms => %i[jruby_18 jruby_19 ruby_19]\n+  gem 'json', '~> 2.3.0', :platforms => %i[jruby_18 jruby_19 ruby_19]\n   gem 'mime-types', '~> 3.1', :platforms => [:jruby_18]\n   gem 'rack', '>= 2.0.6', :platforms => %i[jruby_18 jruby_19 ruby_19 ruby_20 ruby_21]\n   gem 'rack-test'\n   gem 'rest-client', '~> 2.0.0', :platforms => [:jruby_18]\n   gem 'rspec', '~> 3.5.0'\n   gem 'rubocop', '>= 0.58.2', '< 0.69.0', :platforms => %i[ruby_20 ruby_21 ruby_22 ruby_23 ruby_24]\n-  gem 'tins', '~> 1.13.0', :platforms => %i[jruby_18 jruby_19 ruby_19]\n+  gem 'simplecov-lcov'\n+  gem 'tins', '~> 1.13', :platforms => %i[jruby_18 jruby_19 ruby_19]\n end\n \n gemspec"
        },
        {
          "filename": "README.md",
          "status": "modified",
          "additions": 13,
          "deletions": 11,
          "patch": "@@ -2,9 +2,8 @@\n \n [![Gem Version](http://img.shields.io/gem/v/omniauth.svg)][gem]\n [![Build Status](http://img.shields.io/travis/omniauth/omniauth.svg)][travis]\n-[![Code Climate](http://img.shields.io/codeclimate/github/omniauth/omniauth.svg)][codeclimate]\n+[![Code Climate](https://api.codeclimate.com/v1/badges/ffd33970723587806744/maintainability)][codeclimate]\n [![Coverage Status](http://img.shields.io/coveralls/omniauth/omniauth.svg)][coveralls]\n-[![Security](https://hakiri.io/github/omniauth/omniauth/master.svg)](https://hakiri.io/github/omniauth/omniauth/master)\n \n [gem]: https://rubygems.org/gems/omniauth\n [travis]: http://travis-ci.org/omniauth/omniauth\n@@ -32,8 +31,8 @@ development and easily swap in other strategies later.\n ## Getting Started\n Each OmniAuth strategy is a Rack Middleware. That means that you can use\n it the same way that you use any other Rack middleware. For example, to\n-use the built-in Developer strategy in a Sinatra application I might do\n-this:\n+use the built-in Developer strategy in a Sinatra application you might\n+do this:\n \n ```ruby\n require 'sinatra'\n@@ -45,7 +44,7 @@ class MyApplication < Sinatra::Base\n end\n ```\n \n-Because OmniAuth is built for *multi-provider* authentication, I may\n+Because OmniAuth is built for *multi-provider* authentication, you may\n want to leave room to run multiple strategies. For this, the built-in\n `OmniAuth::Builder` class gives you an easy way to specify multiple\n strategies. Note that there is **no difference** between the following\n@@ -82,18 +81,21 @@ environment of a request to `/auth/:provider/callback`. This hash\n contains as much information about the user as OmniAuth was able to\n glean from the utilized strategy. You should set up an endpoint in your\n application that matches to the callback URL and then performs whatever\n-steps are necessary for your application. For example, in a Rails app I\n-would add a line in my `routes.rb` file like this:\n+steps are necessary for your application. For example, in a Rails app\n+you would add a line in your `routes.rb` file like this:\n \n ```ruby\n-get '/auth/:provider/callback', to: 'sessions#create'\n+post '/auth/:provider/callback', to: 'sessions#create'\n ```\n \n-And I might then have a `SessionsController` with code that looks\n+And you might then have a `SessionsController` with code that looks\n something like this:\n \n ```ruby\n class SessionsController < ApplicationController\n+  # If you're using a strategy that POSTs during callback, you'll need to skip the authenticity token check for the callback action only. \n+  skip_before_action :verify_authenticity_token, only: :create\n+\n   def create\n     @user = User.find_or_create_from_auth_hash(auth_hash)\n     self.current_user = @user\n@@ -108,7 +110,7 @@ class SessionsController < ApplicationController\n end\n ```\n \n-The `omniauth.auth` key in the environment hash gives me my\n+The `omniauth.auth` key in the environment hash provides an\n Authentication Hash which will contain information about the just\n authenticated user including a unique id, the strategy they just used\n for authentication, and personal details such as name and email address\n@@ -163,7 +165,7 @@ a `session_store.rb` initializer, add `use ActionDispatch::Session::CookieStore`\n and have sessions functioning as normal.\n \n To be clear: sessions may work, but your session options will be ignored\n-(i.e the session key will default to `_session_id`).  Instead of the\n+(i.e. the session key will default to `_session_id`).  Instead of the\n initializer, you'll have to set the relevant options somewhere\n before your middleware is built (like `application.rb`) and pass them to your\n preferred middleware, like this:"
        },
        {
          "filename": "lib/omniauth.rb",
          "status": "modified",
          "additions": 18,
          "deletions": 6,
          "patch": "@@ -15,6 +15,7 @@ module Strategies\n   autoload :Form,     'omniauth/form'\n   autoload :AuthHash, 'omniauth/auth_hash'\n   autoload :FailureEndpoint, 'omniauth/failure_endpoint'\n+  autoload :AuthenticityTokenProtection, 'omniauth/authenticity_token_protection'\n \n   def self.strategies\n     @strategies ||= []\n@@ -29,20 +30,22 @@ def self.default_logger\n       logger\n     end\n \n-    def self.defaults\n+    def self.defaults # rubocop:disable MethodLength\n       @defaults ||= {\n         :camelizations => {},\n         :path_prefix => '/auth',\n         :on_failure => OmniAuth::FailureEndpoint,\n         :failure_raise_out_environments => ['development'],\n+        :request_validation_phase => OmniAuth::AuthenticityTokenProtection,\n         :before_request_phase   => nil,\n         :before_callback_phase  => nil,\n         :before_options_phase   => nil,\n         :form_css => Form::DEFAULT_CSS,\n         :test_mode => false,\n         :logger => default_logger,\n-        :allowed_request_methods => %i[get post],\n-        :mock_auth => {:default => AuthHash.new('provider' => 'default', 'uid' => '1234', 'info' => {'name' => 'Example User'})}\n+        :allowed_request_methods => %i[post],\n+        :mock_auth => {:default => AuthHash.new('provider' => 'default', 'uid' => '1234', 'info' => {'name' => 'Example User'})},\n+        :silence_get_warning => false\n       }\n     end\n \n@@ -74,6 +77,14 @@ def before_options_phase(&block)\n       end\n     end\n \n+    def request_validation_phase(&block)\n+      if block_given?\n+        @request_validation_phase = block\n+      else\n+        @request_validation_phase\n+      end\n+    end\n+\n     def before_request_phase(&block)\n       if block_given?\n         @before_request_phase = block\n@@ -111,8 +122,9 @@ def add_camelization(name, camelized)\n       camelizations[name.to_s] = camelized.to_s\n     end\n \n-    attr_writer :on_failure, :before_callback_phase, :before_options_phase, :before_request_phase\n-    attr_accessor :failure_raise_out_environments, :path_prefix, :allowed_request_methods, :form_css, :test_mode, :mock_auth, :full_host, :camelizations, :logger\n+    attr_writer :on_failure, :before_callback_phase, :before_options_phase, :before_request_phase, :request_validation_phase\n+    attr_accessor :failure_raise_out_environments, :path_prefix, :allowed_request_methods, :form_css,\n+                  :test_mode, :mock_auth, :full_host, :camelizations, :logger, :silence_get_warning\n   end\n \n   def self.config\n@@ -159,7 +171,7 @@ def camelize(word, first_letter_in_uppercase = true)\n       if first_letter_in_uppercase\n         word.to_s.gsub(%r{/(.?)}) { '::' + Regexp.last_match[1].upcase }.gsub(/(^|_)(.)/) { Regexp.last_match[2].upcase }\n       else\n-        word.first + camelize(word)[1..-1]\n+        camelize(word).tap { |w| w[0] = w[0].downcase }\n       end\n     end\n   end"
        },
        {
          "filename": "lib/omniauth/authenticity_token_protection.rb",
          "status": "added",
          "additions": 30,
          "deletions": 0,
          "patch": "@@ -0,0 +1,30 @@\n+require 'rack-protection'\n+\n+module OmniAuth\n+  class AuthenticityError < StandardError; end\n+  class AuthenticityTokenProtection < Rack::Protection::AuthenticityToken\n+    def initialize(options = {})\n+      @options = default_options.merge(options)\n+    end\n+\n+    def self.call(env)\n+      new.call!(env)\n+    end\n+\n+    def call!(env)\n+      return if accepts?(env)\n+\n+      instrument env\n+      react env\n+    end\n+\n+  private\n+\n+    def deny(_env)\n+      OmniAuth.logger.send(:warn, \"Attack prevented by #{self.class}\")\n+      raise AuthenticityError.new(options[:message])\n+    end\n+\n+    alias default_reaction deny\n+  end\n+end"
        },
        {
          "filename": "lib/omniauth/builder.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -31,7 +31,7 @@ def provider(klass, *args, &block)\n         middleware = klass\n       else\n         begin\n-          middleware = OmniAuth::Strategies.const_get(OmniAuth::Utils.camelize(klass.to_s).to_s)\n+          middleware = OmniAuth::Strategies.const_get(OmniAuth::Utils.camelize(klass.to_s).to_s, false)\n         rescue NameError\n           raise(LoadError.new(\"Could not find matching strategy for #{klass.inspect}. You may need to install an additional gem (such as omniauth-#{klass}).\"))\n         end"
        },
        {
          "filename": "lib/omniauth/failure_endpoint.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -27,7 +27,8 @@ def raise_out!\n \n     def redirect_to_failure\n       message_key = env['omniauth.error.type']\n-      new_path = \"#{env['SCRIPT_NAME']}#{strategy_path_prefix}/failure?message=#{message_key}#{origin_query_param}#{strategy_name_query_param}\"\n+\n+      new_path = \"#{env['SCRIPT_NAME']}#{strategy_path_prefix}/failure?message=#{Rack::Utils.escape(message_key)}#{origin_query_param}#{strategy_name_query_param}\"\n       Rack::Response.new(['302 Moved'], 302, 'Location' => new_path).finish\n     end\n "
        },
        {
          "filename": "lib/omniauth/strategy.rb",
          "status": "modified",
          "additions": 47,
          "deletions": 15,
          "patch": "@@ -180,18 +180,44 @@ def call!(env) # rubocop:disable CyclomaticComplexity, PerceivedComplexity\n         raise(error)\n       end\n \n+      warn_if_using_get\n+\n       @env = env\n       @env['omniauth.strategy'] = self if on_auth_path?\n \n       return mock_call!(env) if OmniAuth.config.test_mode\n-      return options_call if on_auth_path? && options_request?\n-      return request_call if on_request_path? && OmniAuth.config.allowed_request_methods.include?(request.request_method.downcase.to_sym)\n-      return callback_call if on_callback_path?\n-      return other_phase if respond_to?(:other_phase)\n+\n+      begin\n+        return options_call if on_auth_path? && options_request?\n+        return request_call if on_request_path? && OmniAuth.config.allowed_request_methods.include?(request.request_method.downcase.to_sym)\n+        return callback_call if on_callback_path?\n+        return other_phase if respond_to?(:other_phase)\n+      rescue StandardError => e\n+        return fail!(e.message, e)\n+      end\n \n       @app.call(env)\n     end\n \n+    def warn_if_using_get\n+      return unless OmniAuth.config.allowed_request_methods.include?(:get)\n+      return if OmniAuth.config.silence_get_warning\n+\n+      log :warn, <<-WARN\n+  You are using GET as an allowed request method for OmniAuth. This may leave\n+  you open to CSRF attacks. As of v2.0.0, OmniAuth by default allows only POST\n+  to its own routes. You should review the following resources to guide your\n+  mitigation:\n+  https://github.com/omniauth/omniauth/wiki/Resolving-CVE-2015-9284\n+  https://github.com/omniauth/omniauth/issues/960\n+  https://nvd.nist.gov/vuln/detail/CVE-2015-9284\n+  https://github.com/omniauth/omniauth/pull/809\n+\n+  You can ignore this warning by setting:\n+  OmniAuth.config.silence_get_warning = true\n+      WARN\n+    end\n+\n     # Responds to an OPTIONS request.\n     def options_call\n       OmniAuth.config.before_options_phase.call(env) if OmniAuth.config.before_options_phase\n@@ -202,17 +228,19 @@ def options_call\n     # Performs the steps necessary to run the request phase of a strategy.\n     def request_call # rubocop:disable CyclomaticComplexity, MethodLength, PerceivedComplexity\n       setup_phase\n-      log :info, 'Request phase initiated.'\n+      log :debug, 'Request phase initiated.'\n \n       # store query params from the request url, extracted in the callback_phase\n       session['omniauth.params'] = request.GET\n+\n+      OmniAuth.config.request_validation_phase.call(env) if OmniAuth.config.request_validation_phase\n       OmniAuth.config.before_request_phase.call(env) if OmniAuth.config.before_request_phase\n \n       if options.form.respond_to?(:call)\n-        log :info, 'Rendering form from supplied Rack endpoint.'\n+        log :debug, 'Rendering form from supplied Rack endpoint.'\n         options.form.call(env)\n       elsif options.form\n-        log :info, 'Rendering form from underlying application.'\n+        log :debug, 'Rendering form from underlying application.'\n         call_app!\n       elsif !options.origin_param\n         request_phase\n@@ -225,12 +253,14 @@ def request_call # rubocop:disable CyclomaticComplexity, MethodLength, Perceived\n \n         request_phase\n       end\n+    rescue OmniAuth::AuthenticityError => e\n+      fail!(:authenticity_error, e)\n     end\n \n     # Performs the steps necessary to run the callback phase of a strategy.\n     def callback_call\n       setup_phase\n-      log :info, 'Callback phase initiated.'\n+      log :debug, 'Callback phase initiated.'\n       @env['omniauth.origin'] = session.delete('omniauth.origin')\n       @env['omniauth.origin'] = nil if env['omniauth.origin'] == ''\n       @env['omniauth.params'] = session.delete('omniauth.params') || {}\n@@ -312,10 +342,10 @@ def mock_callback_call\n     # underlying application. This will default to `/auth/:provider/setup`.\n     def setup_phase\n       if options[:setup].respond_to?(:call)\n-        log :info, 'Setup endpoint detected, running now.'\n+        log :debug, 'Setup endpoint detected, running now.'\n         options[:setup].call(env)\n       elsif options[:setup]\n-        log :info, 'Calling through to underlying application for setup.'\n+        log :debug, 'Calling through to underlying application for setup.'\n         setup_env = env.merge('PATH_INFO' => setup_path, 'REQUEST_METHOD' => 'GET')\n         call_app!(setup_env)\n       end\n@@ -345,11 +375,13 @@ def extra\n     end\n \n     def auth_hash\n-      hash = AuthHash.new(:provider => name, :uid => uid)\n-      hash.info = info unless skip_info?\n-      hash.credentials = credentials if credentials\n-      hash.extra = extra if extra\n-      hash\n+      credentials_data = credentials\n+      extra_data = extra\n+      AuthHash.new(:provider => name, :uid => uid).tap do |auth|\n+        auth.info = info unless skip_info?\n+        auth.credentials = credentials_data if credentials_data\n+        auth.extra = extra_data if extra_data\n+      end\n     end\n \n     # Determines whether or not user info should be retrieved. This"
        },
        {
          "filename": "lib/omniauth/version.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,3 +1,3 @@\n module OmniAuth\n-  VERSION = '1.9.0'.freeze\n+  VERSION = '1.9.1'.freeze\n end"
        },
        {
          "filename": "omniauth.gemspec",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -7,7 +7,8 @@ require 'omniauth/version'\n Gem::Specification.new do |spec|\n   spec.add_dependency 'hashie', ['>= 3.4.6']\n   spec.add_dependency 'rack', ['>= 1.6.2', '< 3']\n-  spec.add_development_dependency 'bundler', '~> 1.14'\n+  spec.add_development_dependency 'bundler', '~> 2.0'\n+  spec.add_dependency 'rack-protection'\n   spec.add_development_dependency 'rake', '~> 12.0'\n   spec.authors       = ['Michael Bleigh', 'Erik Michaels-Ober', 'Tom Milewski']\n   spec.description   = 'A generalized Rack framework for multiple-provider authentication.'"
        },
        {
          "filename": "spec/helper.rb",
          "status": "modified",
          "additions": 8,
          "deletions": 3,
          "patch": "@@ -1,16 +1,20 @@\n if RUBY_VERSION >= '1.9'\n   require 'simplecov'\n   require 'coveralls'\n+  require 'simplecov-lcov'\n+\n+  SimpleCov::Formatter::LcovFormatter.config.report_with_single_file = true\n \n   SimpleCov.formatters = [\n     SimpleCov::Formatter::HTMLFormatter,\n+    SimpleCov::Formatter::LcovFormatter,\n     Coveralls::SimpleCov::Formatter\n   ]\n \n   SimpleCov.start do\n     add_filter ['/spec/', '/vendor/', 'strategy_macros.rb']\n     minimum_coverage(92.5)\n-    maximum_coverage_drop(0.01)\n+    maximum_coverage_drop(0.05)\n   end\n end\n \n@@ -20,6 +24,7 @@\n require 'omniauth/test'\n \n OmniAuth.config.logger = Logger.new('/dev/null')\n+OmniAuth.config.request_validation_phase = nil\n \n RSpec.configure do |config|\n   config.include Rack::Test::Methods\n@@ -45,7 +50,7 @@ def initialize(*args, &block)\n \n   def request_phase\n     options[:mutate_on_request].call(options) if options[:mutate_on_request]\n-    @fail = fail!(options[:failure]) if options[:failure]\n+    @fail = fail!(options[:failure], options[:failure_exception]) if options[:failure]\n     @last_env = env\n     return @fail if @fail\n \n@@ -54,7 +59,7 @@ def request_phase\n \n   def callback_phase\n     options[:mutate_on_callback].call(options) if options[:mutate_on_callback]\n-    @fail = fail!(options[:failure]) if options[:failure]\n+    @fail = fail!(options[:failure], options[:failure_exception]) if options[:failure]\n     @last_env = env\n     return @fail if @fail\n "
        },
        {
          "filename": "spec/omniauth/auth_hash_spec.rb",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -13,6 +13,10 @@\n     expect(subject.weird_field.info).to eq 'string'\n   end\n \n+  it 'has a subkey_class' do\n+    expect(OmniAuth::AuthHash.subkey_class).to eq Hashie::Mash\n+  end\n+\n   describe '#valid?' do\n     subject { OmniAuth::AuthHash.new(:uid => '123', :provider => 'example', :info => {:name => 'Steven'}) }\n \n@@ -111,6 +115,10 @@\n       end\n     end\n \n+    it 'has a subkey_class' do\n+      expect(OmniAuth::AuthHash::InfoHash.subkey_class).to eq Hashie::Mash\n+    end\n+\n     require 'hashie/version'\n     if Gem::Version.new(Hashie::VERSION) >= Gem::Version.new('3.5.1')\n       context 'with Hashie 3.5.1+' do"
        },
        {
          "filename": "spec/omniauth/builder_spec.rb",
          "status": "modified",
          "additions": 11,
          "deletions": 1,
          "patch": "@@ -3,7 +3,7 @@\n describe OmniAuth::Builder do\n   describe '#provider' do\n     it 'translates a symbol to a constant' do\n-      expect(OmniAuth::Strategies).to receive(:const_get).with('MyStrategy').and_return(Class.new)\n+      expect(OmniAuth::Strategies).to receive(:const_get).with('MyStrategy', false).and_return(Class.new)\n       OmniAuth::Builder.new(nil) do\n         provider :my_strategy\n       end\n@@ -26,6 +26,16 @@ class ExampleClass; end\n         end\n       end.to raise_error(LoadError, 'Could not find matching strategy for :lorax. You may need to install an additional gem (such as omniauth-lorax).')\n     end\n+\n+    it \"doesn't translate a symbol to a top-level constant\" do\n+      class MyStrategy; end\n+\n+      expect do\n+        OmniAuth::Builder.new(nil) do\n+          provider :my_strategy\n+        end\n+      end.to raise_error(LoadError, 'Could not find matching strategy for :my_strategy. You may need to install an additional gem (such as omniauth-my_strategy).')\n+    end\n   end\n \n   describe '#options' do"
        },
        {
          "filename": "spec/omniauth/failure_endpoint_spec.rb",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -60,5 +60,10 @@\n       _, head, = *subject.call(env)\n       expect(head['Location']).to be_include('&origin=%2Forigin-example')\n     end\n+\n+    it 'escapes the message key' do\n+      _, head = *subject.call(env.merge('omniauth.error.type' => 'Connection refused!'))\n+      expect(head['Location']).to be_include('message=Connection+refused%21')\n+    end\n   end\n end"
        },
        {
          "filename": "spec/omniauth/form_spec.rb",
          "status": "modified",
          "additions": 32,
          "deletions": 1,
          "patch": "@@ -7,7 +7,8 @@\n     end\n \n     it 'evaluates in the instance when called with a block and no argument' do\n-      OmniAuth::Form.build { |f| expect(f.class).to eq(OmniAuth::Form) }\n+      f = OmniAuth::Form.build { @html = '<h1>OmniAuth</h1>' }\n+      expect(f.instance_variable_get(:@html)).to eq('<h1>OmniAuth</h1>')\n     end\n   end\n \n@@ -20,4 +21,34 @@\n       expect(OmniAuth::Form.new(:title => 'Something Cool').to_html).to be_include('<h1>Something Cool</h1>')\n     end\n   end\n+\n+  describe '#password_field' do\n+    it 'adds a labeled input field' do\n+      form = OmniAuth::Form.new.password_field('pass', 'password')\n+      form_html = form.to_html\n+      expect(form_html).to include('<label for=\\'password\\'>pass:</label>')\n+      expect(form_html).to include('<input type=\\'password\\' id=\\'password\\' name=\\'password\\'/>')\n+    end\n+  end\n+\n+  describe '#html' do\n+    it 'appends to the html body' do\n+      form = OmniAuth::Form.build { @html = '<p></p>' }\n+      form.html('<h1></h1>')\n+\n+      expect(form.instance_variable_get(:@html)).to eq '<p></p><h1></h1>'\n+    end\n+  end\n+\n+  describe 'fieldset' do\n+    it 'creates a fieldset with options' do\n+      form = OmniAuth::Form.new\n+      options = {:style => 'color: red', :id => 'fieldSetId'}\n+      expected = \"<fieldset style='color: red' id='fieldSetId'>\\n  <legend>legendary</legend>\\n\\n</fieldset>\"\n+\n+      form.fieldset('legendary', options) {}\n+\n+      expect(form.to_html).to include expected\n+    end\n+  end\n end"
        },
        {
          "filename": "spec/omniauth/key_store_spec.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -25,6 +25,7 @@\n \n     it 'does not log anything to the console' do\n       stub_const('Hashie::VERSION', version)\n+      allow(OmniAuth::KeyStore).to receive(:respond_to?).with(:disable_warnings).and_return(false)\n       OmniAuth::KeyStore.override_logging\n       expect(logger).not_to receive(:info)\n       OmniAuth::KeyStore.new(:id => 1234)"
        },
        {
          "filename": "spec/omniauth/strategies/developer_spec.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -10,7 +10,7 @@\n   end\n \n   context 'request phase' do\n-    before(:each) { get '/auth/developer' }\n+    before(:each) { post '/auth/developer' }\n \n     it 'displays a form' do\n       expect(last_response.status).to eq(200)"
        },
        {
          "filename": "spec/omniauth/strategy_spec.rb",
          "status": "modified",
          "additions": 171,
          "deletions": 40,
          "patch": "@@ -2,7 +2,7 @@\n \n def make_env(path = '/auth/test', props = {})\n   {\n-    'REQUEST_METHOD' => 'GET',\n+    'REQUEST_METHOD' => 'POST',\n     'PATH_INFO' => path,\n     'rack.session' => {},\n     'rack.input' => StringIO.new('test=true')\n@@ -32,6 +32,12 @@ def make_env(path = '/auth/test', props = {})\n     end\n   end\n \n+  describe 'user_info' do\n+    it 'should default to an empty hash' do\n+      expect(fresh_strategy.new(app, :skip_info => true).user_info).to eq({})\n+    end\n+  end\n+\n   describe '.configure' do\n     subject do\n       c = Class.new\n@@ -63,6 +69,29 @@ def make_env(path = '/auth/test', props = {})\n     end\n   end\n \n+  describe '#fail!' do\n+    it 'provides exception information when one is provided' do\n+      env = make_env\n+      exception = RuntimeError.new('No session!')\n+\n+      expect(OmniAuth.logger).to receive(:error).with(\n+        \"(test) Authentication failure! failed: #{exception.class}, #{exception.message}\"\n+      )\n+\n+      ExampleStrategy.new(app, :failure => :failed, :failure_exception => exception).call(env)\n+    end\n+\n+    it 'provides a generic message when not provided an exception' do\n+      env = make_env\n+\n+      expect(OmniAuth.logger).to receive(:error).with(\n+        '(test) Authentication failure! Some Issue encountered.'\n+      )\n+\n+      ExampleStrategy.new(app, :failure => 'Some Issue').call(env)\n+    end\n+  end\n+\n   describe '#skip_info?' do\n     it 'is true if options.skip_info is true' do\n       expect(ExampleStrategy.new(app, :skip_info => true)).to be_skip_info\n@@ -173,19 +202,25 @@ def make_env(path = '/auth/test', props = {})\n     end\n     let(:instance) { subject.new(app) }\n \n-    it 'calls through to uid and info' do\n+    it 'calls through to uid, info, credentials, and extra' do\n       expect(instance).to receive(:uid)\n       expect(instance).to receive(:info)\n+      expect(instance).to receive(:credentials).and_return(expires: true).once\n+      expect(instance).to receive(:extra).and_return(something: 'else').once\n       instance.auth_hash\n     end\n \n     it 'returns an AuthHash' do\n       allow(instance).to receive(:uid).and_return('123')\n       allow(instance).to receive(:info).and_return(:name => 'Hal Awesome')\n+      allow(instance).to receive(:credentials).and_return(expires: true)\n+      allow(instance).to receive(:extra).and_return(something: 'else')\n       hash = instance.auth_hash\n       expect(hash).to be_kind_of(OmniAuth::AuthHash)\n       expect(hash.uid).to eq('123')\n       expect(hash.info.name).to eq('Hal Awesome')\n+      expect(hash.credentials.expires).to eq(true)\n+      expect(hash.extra.something).to eq('else')\n     end\n   end\n \n@@ -242,7 +277,9 @@ def make_env(path = '/auth/test', props = {})\n   describe '#redirect' do\n     it 'uses javascript if :iframe is true' do\n       response = ExampleStrategy.new(app, :iframe => true).redirect('http://abc.com')\n-      expect(response.last.body.first).to be_include('top.location.href')\n+      expected_body = \"<script type='text/javascript' charset='utf-8'>top.location.href = 'http://abc.com';</script>\"\n+\n+      expect(response.last).to include(expected_body)\n     end\n   end\n \n@@ -310,32 +347,41 @@ def make_env(path = '/auth/test', props = {})\n       context 'disabled' do\n         it 'does not set omniauth.origin' do\n           @options = {:origin_param => false}\n-          expect { strategy.call(make_env('/auth/test', 'QUERY_STRING' => 'return=/foo')) }.to raise_error('Request Phase')\n+          expect(strategy).to receive(:fail!).with('Request Phase', kind_of(StandardError))\n+\n+          strategy.call(make_env('/auth/test', 'QUERY_STRING' => 'return=/foo'))\n           expect(strategy.last_env['rack.session']['omniauth.origin']).to eq(nil)\n         end\n       end\n \n       context 'custom' do\n         it 'sets from a custom param' do\n           @options = {:origin_param => 'return'}\n-          expect { strategy.call(make_env('/auth/test', 'QUERY_STRING' => 'return=/foo')) }.to raise_error('Request Phase')\n+          expect(strategy).to receive(:fail!).with('Request Phase', kind_of(StandardError))\n+\n+          strategy.call(make_env('/auth/test', 'QUERY_STRING' => 'return=/foo'))\n           expect(strategy.last_env['rack.session']['omniauth.origin']).to eq('/foo')\n         end\n       end\n \n       context 'default flow' do\n         it 'is set on the request phase' do\n-          expect { strategy.call(make_env('/auth/test', 'HTTP_REFERER' => 'http://example.com/origin')) }.to raise_error('Request Phase')\n+          expect(strategy).to receive(:fail!).with(\"Request Phase\", kind_of(StandardError))\n+          strategy.call(make_env('/auth/test', 'HTTP_REFERER' => 'http://example.com/origin'))\n+\n           expect(strategy.last_env['rack.session']['omniauth.origin']).to eq('http://example.com/origin')\n         end\n \n         it 'is turned into an env variable on the callback phase' do\n-          expect { strategy.call(make_env('/auth/test/callback', 'rack.session' => {'omniauth.origin' => 'http://example.com/origin'})) }.to raise_error('Callback Phase')\n+          expect(strategy).to receive(:fail!).with(\"Callback Phase\", kind_of(StandardError))\n+          strategy.call(make_env('/auth/test/callback', 'rack.session' => {'omniauth.origin' => 'http://example.com/origin'}))\n+\n           expect(strategy.last_env['omniauth.origin']).to eq('http://example.com/origin')\n         end\n \n         it 'sets from the params if provided' do\n-          expect { strategy.call(make_env('/auth/test', 'QUERY_STRING' => 'origin=/foo')) }.to raise_error('Request Phase')\n+          expect(strategy).to receive(:fail!).with('Request Phase', kind_of(StandardError))\n+          strategy.call(make_env('/auth/test', 'QUERY_STRING' => 'origin=/foo'))\n           expect(strategy.last_env['rack.session']['omniauth.origin']).to eq('/foo')\n         end\n \n@@ -348,7 +394,9 @@ def make_env(path = '/auth/test', props = {})\n         context 'with script_name' do\n           it 'is set on the request phase, containing full path' do\n             env = {'HTTP_REFERER' => 'http://example.com/sub_uri/origin', 'SCRIPT_NAME' => '/sub_uri'}\n-            expect { strategy.call(make_env('/auth/test', env)) }.to raise_error('Request Phase')\n+            expect(strategy).to receive(:fail!).with('Request Phase', kind_of(StandardError))\n+\n+            strategy.call(make_env('/auth/test', env))\n             expect(strategy.last_env['rack.session']['omniauth.origin']).to eq('http://example.com/sub_uri/origin')\n           end\n \n@@ -357,8 +405,9 @@ def make_env(path = '/auth/test', props = {})\n               'rack.session' => {'omniauth.origin' => 'http://example.com/sub_uri/origin'},\n               'SCRIPT_NAME' => '/sub_uri'\n             }\n+            expect(strategy).to receive(:fail!).with('Callback Phase', kind_of(StandardError))\n \n-            expect { strategy.call(make_env('/auth/test/callback', env)) }.to raise_error('Callback Phase')\n+            strategy.call(make_env('/auth/test/callback', env))\n             expect(strategy.last_env['omniauth.origin']).to eq('http://example.com/sub_uri/origin')\n           end\n         end\n@@ -367,34 +416,41 @@ def make_env(path = '/auth/test', props = {})\n \n     context 'default paths' do\n       it 'uses the default request path' do\n-        expect { strategy.call(make_env) }.to raise_error('Request Phase')\n+        expect(strategy).to receive(:fail!).with('Request Phase', kind_of(StandardError))\n+        strategy.call(make_env)\n       end\n \n       it 'is case insensitive on request path' do\n-        expect { strategy.call(make_env('/AUTH/Test')) }.to raise_error('Request Phase')\n+        expect(strategy).to receive(:fail!).with('Request Phase', kind_of(StandardError))\n+        strategy.call(make_env('/AUTH/Test'))\n       end\n \n       it 'is case insensitive on callback path' do\n-        expect { strategy.call(make_env('/AUTH/TeSt/CaLlBAck')) }.to raise_error('Callback Phase')\n+        expect(strategy).to receive(:fail!).with('Callback Phase', kind_of(StandardError))\n+        strategy.call(make_env('/AUTH/TeSt/CaLlBAck'))\n       end\n \n       it 'uses the default callback path' do\n-        expect { strategy.call(make_env('/auth/test/callback')) }.to raise_error('Callback Phase')\n+        expect(strategy).to receive(:fail!).with('Callback Phase', kind_of(StandardError))\n+        strategy.call(make_env('/auth/test/callback'))\n       end\n \n       it 'strips trailing spaces on request' do\n-        expect { strategy.call(make_env('/auth/test/')) }.to raise_error('Request Phase')\n+        expect(strategy).to receive(:fail!).with('Request Phase', kind_of(StandardError))\n+        strategy.call(make_env('/auth/test/'))\n       end\n \n       it 'strips trailing spaces on callback' do\n-        expect { strategy.call(make_env('/auth/test/callback/')) }.to raise_error('Callback Phase')\n+        expect(strategy).to receive(:fail!).with('Callback Phase', kind_of(StandardError))\n+        strategy.call(make_env('/auth/test/callback/'))\n       end\n \n       context 'callback_url' do\n         it 'uses the default callback_path' do\n           expect(strategy).to receive(:full_host).and_return('http://example.com')\n+          expect(strategy).to receive(:fail!).with('Request Phase', kind_of(StandardError))\n \n-          expect { strategy.call(make_env) }.to raise_error('Request Phase')\n+          strategy.call(make_env)\n \n           expect(strategy.callback_url).to eq('http://example.com/auth/test/callback')\n         end\n@@ -434,12 +490,15 @@ def make_env(path = '/auth/test', props = {})\n     context 'dynamic paths' do\n       it 'runs the request phase if the custom request path evaluator is truthy' do\n         @options = {:request_path => lambda { |_env| true }}\n-        expect { strategy.call(make_env('/asoufibasfi')) }.to raise_error('Request Phase')\n+        expect(strategy).to receive(:fail!).with('Request Phase', kind_of(StandardError))\n+        strategy.call(make_env('/asoufibasfi'))\n       end\n \n       it 'runs the callback phase if the custom callback path evaluator is truthy' do\n         @options = {:callback_path => lambda { |_env| true }}\n-        expect { strategy.call(make_env('/asoufiasod')) }.to raise_error('Callback Phase')\n+        expect(strategy).to receive(:fail!).with('Callback Phase', kind_of(StandardError))\n+\n+        strategy.call(make_env('/asoufiasod'))\n       end\n \n       it 'provides a custom callback path if request_path evals to a string' do\n@@ -449,29 +508,35 @@ def make_env(path = '/auth/test', props = {})\n \n       it 'correctly reports the callback path when the custom callback path evaluator is truthy' do\n         strategy_instance = ExampleStrategy.new(app, :callback_path => lambda { |env| env['PATH_INFO'] == '/auth/bish/bosh/callback' })\n+        strategy_instance.should_receive(:fail!).with('Callback Phase', kind_of(StandardError))\n \n-        expect { strategy_instance.call(make_env('/auth/bish/bosh/callback')) }.to raise_error('Callback Phase')\n+        strategy_instance.call(make_env('/auth/bish/bosh/callback'))\n         expect(strategy_instance.callback_path).to eq('/auth/bish/bosh/callback')\n       end\n     end\n \n     context 'custom paths' do\n       it 'uses a custom request_path if one is provided' do\n         @options = {:request_path => '/awesome'}\n-        expect { strategy.call(make_env('/awesome')) }.to raise_error('Request Phase')\n+        expect(strategy).to receive(:fail!).with('Request Phase', kind_of(StandardError))\n+\n+        strategy.call(make_env('/awesome'))\n       end\n \n       it 'uses a custom callback_path if one is provided' do\n         @options = {:callback_path => '/radical'}\n-        expect { strategy.call(make_env('/radical')) }.to raise_error('Callback Phase')\n+        expect(strategy).to receive(:fail!).with('Callback Phase', kind_of(StandardError))\n+\n+        strategy.call(make_env('/radical'))\n       end\n \n       context 'callback_url' do\n         it 'uses a custom callback_path if one is provided' do\n           @options = {:callback_path => '/radical'}\n           expect(strategy).to receive(:full_host).and_return('http://example.com')\n+          expect(strategy).to receive(:fail!).with('Callback Phase', kind_of(StandardError))\n \n-          expect { strategy.call(make_env('/radical')) }.to raise_error('Callback Phase')\n+          strategy.call(make_env('/radical'))\n \n           expect(strategy.callback_url).to eq('http://example.com/radical')\n         end\n@@ -494,18 +559,20 @@ def make_env(path = '/auth/test', props = {})\n       end\n \n       it 'uses a custom prefix for request' do\n-        expect { strategy.call(make_env('/wowzers/test')) }.to raise_error('Request Phase')\n+        expect(strategy).to receive(:fail!).with('Request Phase', kind_of(StandardError))\n+        strategy.call(make_env('/wowzers/test'))\n       end\n \n       it 'uses a custom prefix for callback' do\n-        expect { strategy.call(make_env('/wowzers/test/callback')) }.to raise_error('Callback Phase')\n+        expect(strategy).to receive(:fail!).with('Callback Phase', kind_of(StandardError))\n+        strategy.call(make_env('/wowzers/test/callback'))\n       end\n \n       context 'callback_url' do\n         it 'uses a custom prefix' do\n           expect(strategy).to receive(:full_host).and_return('http://example.com')\n-\n-          expect { strategy.call(make_env('/wowzers/test')) }.to raise_error('Request Phase')\n+          expect(strategy).to receive(:fail!).with('Request Phase', kind_of(StandardError))\n+          strategy.call(make_env('/wowzers/test'))\n \n           expect(strategy.callback_url).to eq('http://example.com/wowzers/test/callback')\n         end\n@@ -522,20 +589,21 @@ def make_env(path = '/auth/test', props = {})\n     end\n \n     context 'request method restriction' do\n-      before do\n-        OmniAuth.config.allowed_request_methods = [:post]\n+      before(:context) do\n+        OmniAuth.config.allowed_request_methods = %i[put post]\n       end\n \n       it 'does not allow a request method of the wrong type' do\n-        expect { strategy.call(make_env) }.not_to raise_error\n+        expect { strategy.call(make_env('/auth/test', 'REQUEST_METHOD' => 'GET')) }.not_to raise_error\n       end\n \n       it 'allows a request method of the correct type' do\n-        expect { strategy.call(make_env('/auth/test', 'REQUEST_METHOD' => 'POST')) }.to raise_error('Request Phase')\n+        expect(strategy).to receive(:fail!).with('Request Phase', kind_of(StandardError))\n+        strategy.call(make_env('/auth/test'))\n       end\n \n-      after do\n-        OmniAuth.config.allowed_request_methods = %i[get post]\n+      after(:context) do\n+        OmniAuth.config.allowed_request_methods = %i[post]\n       end\n     end\n \n@@ -546,7 +614,7 @@ def make_env(path = '/auth/test', props = {})\n         end\n \n         it 'sets the Allow header properly' do\n-          expect(response[1]['Allow']).to eq('GET, POST')\n+          expect(response[1]['Allow']).to eq('POST')\n         end\n       end\n \n@@ -577,14 +645,16 @@ def make_env(path = '/auth/test', props = {})\n         it 'does not affect original options' do\n           @options[:test_option] = true\n           @options[:mutate_on_request] = proc { |options| options.delete(:test_option) }\n-          expect { strategy.call(make_env) }.to raise_error('Request Phase')\n+\n+          strategy.call(make_env)\n           expect(strategy.options).to have_key(:test_option)\n         end\n \n         it 'does not affect deep options' do\n           @options[:deep_option] = {:test_option => true}\n           @options[:mutate_on_request] = proc { |options| options[:deep_option].delete(:test_option) }\n-          expect { strategy.call(make_env) }.to raise_error('Request Phase')\n+\n+          strategy.call(make_env)\n           expect(strategy.options[:deep_option]).to have_key(:test_option)\n         end\n       end\n@@ -593,14 +663,16 @@ def make_env(path = '/auth/test', props = {})\n         it 'does not affect original options' do\n           @options[:test_option] = true\n           @options[:mutate_on_callback] = proc { |options| options.delete(:test_option) }\n-          expect { strategy.call(make_env('/auth/test/callback', 'REQUEST_METHOD' => 'POST')) }.to raise_error('Callback Phase')\n+\n+          strategy.call(make_env('/auth/test/callback', 'REQUEST_METHOD' => 'POST'))\n           expect(strategy.options).to have_key(:test_option)\n         end\n \n         it 'does not affect deep options' do\n           @options[:deep_option] = {:test_option => true}\n           @options[:mutate_on_callback] = proc { |options| options[:deep_option].delete(:test_option) }\n-          expect { strategy.call(make_env('/auth/test/callback', 'REQUEST_METHOD' => 'POST')) }.to raise_error('Callback Phase')\n+\n+          strategy.call(make_env('/auth/test/callback', 'REQUEST_METHOD' => 'POST'))\n           expect(strategy.options[:deep_option]).to have_key(:test_option)\n         end\n       end\n@@ -653,8 +725,8 @@ def make_env(path = '/auth/test', props = {})\n       end\n \n       it 'maintains host and port' do\n-        response = strategy.call(make_env('/auth/test', 'rack.url_scheme' => 'http', 'HTTP_HOST' => 'example.org', 'SERVER_PORT' => 3000))\n-        expect(response[1]['Location']).to eq('http://example.org:3000/auth/test/callback')\n+        response = strategy.call(make_env('/auth/test', 'rack.url_scheme' => 'http', 'SERVER_NAME' => 'example.org', 'SERVER_PORT' => 9292))\n+        expect(response[1]['Location']).to eq('http://example.org:9292/auth/test/callback')\n       end\n \n       it 'maintains query string parameters' do\n@@ -807,6 +879,65 @@ def make_env(path = '/auth/test', props = {})\n         OmniAuth.config.test_mode = false\n       end\n     end\n+\n+    context 'authenticity validation' do\n+      let(:app) { lambda { |_env| [200, {}, ['reached our target']] } }\n+      let(:strategy) { ExampleStrategy.new(app, :request_path => '/auth/test') }\n+      before do\n+        OmniAuth.config.request_validation_phase = OmniAuth::AuthenticityTokenProtection\n+      end\n+\n+      context 'with default POST only request methods' do\n+        let!(:csrf_token) { SecureRandom.base64(32) }\n+        let(:escaped_token) { URI.encode_www_form_component(csrf_token, Encoding::UTF_8) }\n+\n+        it 'allows a request with matching authenticity_token' do\n+          expect(strategy).to receive(:fail!).with('Request Phase', kind_of(StandardError))\n+\n+          post_env = make_env('/auth/test', 'rack.session' => {:csrf => csrf_token}, 'rack.input' => StringIO.new(\"authenticity_token=#{escaped_token}\"))\n+          strategy.call(post_env)\n+        end\n+\n+        it 'does not allow a request without a matching authenticity token' do\n+          post_env = make_env('/auth/test', 'rack.input' => StringIO.new(\"authenticity_token=#{escaped_token}\"))\n+          expect(strategy.call(post_env)[0]).to eq(302)\n+          expect(strategy.call(post_env)[2]).to eq(['302 Moved'])\n+        end\n+      end\n+\n+      context 'with allowed GET' do\n+        before(:context) do\n+          @old_allowed_request_methods = OmniAuth.config.allowed_request_methods\n+          OmniAuth.config.allowed_request_methods = %i[post get]\n+        end\n+\n+        it 'allows a request without authenticity token' do\n+          expect(strategy).to receive(:fail!).with('Request Phase', kind_of(StandardError))\n+\n+          get_env = make_env('/auth/test', 'REQUEST_METHOD' => 'GET')\n+          strategy.call(get_env)\n+        end\n+\n+        after(:context) do\n+          OmniAuth.config.allowed_request_methods = @old_allowed_request_methods\n+        end\n+      end\n+\n+      after do\n+        OmniAuth.config.request_validation_phase = nil\n+      end\n+    end\n+\n+    it 'calls fail! when encountering an unhandled exception' do\n+      strategy.stub(:request_phase).and_raise(Errno::ECONNREFUSED)\n+      expect(strategy).to receive(:fail!).with('Connection refused', kind_of(Errno::ECONNREFUSED))\n+      strategy.call(make_env)\n+    end\n+\n+    it 'redirects to the fail! result when encountering an unhandled exception' do\n+      OmniAuth.config.test_mode = false\n+      expect(strategy.call(make_env).first).to eq 302\n+    end\n   end\n \n   context 'setup phase' do"
        },
        {
          "filename": "spec/omniauth_spec.rb",
          "status": "modified",
          "additions": 37,
          "deletions": 10,
          "patch": "@@ -26,20 +26,22 @@ class ExampleStrategy\n     end\n \n     before do\n-      @old_path_prefix           = OmniAuth.config.path_prefix\n-      @old_on_failure            = OmniAuth.config.on_failure\n-      @old_before_callback_phase = OmniAuth.config.before_callback_phase\n-      @old_before_options_phase  = OmniAuth.config.before_options_phase\n-      @old_before_request_phase  = OmniAuth.config.before_request_phase\n+      @old_path_prefix              = OmniAuth.config.path_prefix\n+      @old_on_failure               = OmniAuth.config.on_failure\n+      @old_before_callback_phase    = OmniAuth.config.before_callback_phase\n+      @old_before_options_phase     = OmniAuth.config.before_options_phase\n+      @old_before_request_phase     = OmniAuth.config.before_request_phase\n+      @old_request_validation_phase = OmniAuth.config.request_validation_phase\n     end\n \n     after do\n       OmniAuth.configure do |config|\n-        config.path_prefix           = @old_path_prefix\n-        config.on_failure            = @old_on_failure\n-        config.before_callback_phase = @old_before_callback_phase\n-        config.before_options_phase  = @old_before_options_phase\n-        config.before_request_phase  = @old_before_request_phase\n+        config.path_prefix              = @old_path_prefix\n+        config.on_failure               = @old_on_failure\n+        config.before_callback_phase    = @old_before_callback_phase\n+        config.before_options_phase     = @old_before_options_phase\n+        config.before_request_phase     = @old_before_request_phase\n+        config.request_validation_phase = @old_request_validation_phase\n       end\n     end\n \n@@ -88,6 +90,15 @@ class ExampleStrategy\n       expect(OmniAuth.config.before_callback_phase.call).to eq('heyhey')\n     end\n \n+    it 'is able to set request_validation_phase' do\n+      OmniAuth.configure do |config|\n+        config.request_validation_phase do\n+          'validated'\n+        end\n+      end\n+      expect(OmniAuth.config.request_validation_phase.call).to eq('validated')\n+    end\n+\n     describe 'mock auth' do\n       before do\n         @auth_hash = {:uid => '12345', :info => {:name => 'Joe', :email => 'joe@example.com'}}\n@@ -128,6 +139,13 @@ class ExampleStrategy\n   end\n \n   describe '::Utils' do\n+    describe 'form_css' do\n+      it 'returns a style tag with the configured form_css' do\n+        allow(OmniAuth).to receive(:config).and_return(double(:form_css => 'css.css'))\n+        expect(OmniAuth::Utils.form_css).to eq \"<style type='text/css'>css.css</style>\"\n+      end\n+    end\n+\n     describe '.deep_merge' do\n       it 'combines hashes' do\n         expect(OmniAuth::Utils.deep_merge({'abc' => {'def' => 123}}, 'abc' => {'foo' => 'bar'})).to eq('abc' => {'def' => 123, 'foo' => 'bar'})\n@@ -148,6 +166,15 @@ class ExampleStrategy\n         OmniAuth.config.add_camelization('oauth', 'OAuth')\n         expect(OmniAuth::Utils.camelize(:oauth)).to eq('OAuth')\n       end\n+\n+      it 'doesn\\'t uppercase the first letter when passed false' do\n+        expect(OmniAuth::Utils.camelize('apple_jack', false)).to eq('appleJack')\n+      end\n+\n+      it 'replaces / with ::' do\n+        expect(OmniAuth::Utils.camelize('apple_jack/cereal')).to eq('AppleJack::Cereal')\n+        expect(OmniAuth::Utils.camelize('apple_jack/cereal', false)).to eq('appleJack::Cereal')\n+      end\n     end\n   end\n end"
        }
      ],
      "file_patterns": {
        "security_files": 15,
        "config_files": 2,
        "dependency_files": 1,
        "test_files": 0,
        "unique_directories": 7,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e23567ac860f4adfb425db226d68a03235078941",
            "date": "2024-08-06T13:43:54Z",
            "author_login": "BobbyMcWho"
          },
          {
            "sha": "c2ebe5bffb0fbb906e726f205f69fb00fe5a2e05",
            "date": "2024-08-06T13:31:41Z",
            "author_login": "BobbyMcWho"
          },
          {
            "sha": "35f69b1f3a2830e997447c954c6aa5ea361a3099",
            "date": "2024-08-06T13:29:05Z",
            "author_login": "BobbyMcWho"
          },
          {
            "sha": "2d93b5381d2d3b2659bbfd80254652ed37ae0276",
            "date": "2024-08-06T09:28:26Z",
            "author_login": "TastyPi"
          },
          {
            "sha": "767a8b03beaf4e05a4aacb054931d6007e0f48e6",
            "date": "2024-08-05T05:34:10Z",
            "author_login": "mame"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-116",
    "description": "lib/omniauth/failure_endpoint.rb in OmniAuth before 1.9.2 (and before 2.0) does not escape the message_key value.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-08-18T23:15:08.187",
    "last_modified": "2024-11-21T05:29:51.683",
    "fix_date": "2020-12-10T15:10:02Z"
  },
  "references": [
    {
      "url": "https://github.com/omniauth/omniauth/commit/43a396f181ef7d0ed2ec8291c939c95e3ed3ff00#diff-575abda9deb9b1a77bf534e898a923029b9a61e991d626db88dc6e8b34260aa2",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://rubygems.org/gems/omniauth/versions/1.9.2",
      "source": "cve@mitre.org",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/omniauth/omniauth/commit/43a396f181ef7d0ed2ec8291c939c95e3ed3ff00#diff-575abda9deb9b1a77bf534e898a923029b9a61e991d626db88dc6e8b34260aa2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://rubygems.org/gems/omniauth/versions/1.9.2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:14.238861",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "omniauth",
    "owner": "omniauth",
    "created_at": "2010-03-30T20:34:32Z",
    "updated_at": "2025-01-13T23:48:11Z",
    "pushed_at": "2024-08-06T13:43:54Z",
    "size": 3048,
    "stars": 7925,
    "forks": 981,
    "open_issues": 98,
    "watchers": 7925,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Ruby": 102849,
      "CSS": 1591
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T15:12:53.245344"
  }
}