{
  "cve_id": "CVE-2020-4045",
  "github_data": {
    "repository": "ssbc/ssb-db",
    "fix_commit": "43334d0871c9cc6220e0f6d6338499060f7761d4",
    "related_commits": [
      "43334d0871c9cc6220e0f6d6338499060f7761d4",
      "43334d0871c9cc6220e0f6d6338499060f7761d4"
    ],
    "patch_url": "https://github.com/ssbc/ssb-db/commit/43334d0871c9cc6220e0f6d6338499060f7761d4.patch",
    "fix_commit_details": {
      "sha": "43334d0871c9cc6220e0f6d6338499060f7761d4",
      "commit_date": "2020-06-11T02:36:12Z",
      "author": {
        "login": "mixmix",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-mpgr-2cx9-327h",
        "length": 83,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 202,
        "additions": 151,
        "deletions": 51
      },
      "files": [
        {
          "filename": "README.md",
          "status": "modified",
          "additions": 5,
          "deletions": 3,
          "patch": "@@ -278,10 +278,12 @@ you may receive a old message in real time - but for old messages, it makes sens\n \n all standard options are supported.\n \n-### db.createUserStream ({id: feed_id, lt,lte,gt,gte: sequence, reverse,old,live,raw: boolean, limit: number})\n+### db.createUserStream ({id: feed_id, lt,lte,gt,gte: sequence, reverse,old,live,raw: boolean, limit: number, private: boolean})\n \n-`createUserStream` is like `createHistoryStream`, except all options are supported. Local access is allowed, but not\n-remote anonymous access. `createUserStream` does decrypt private messages.\n+`createUserStream` is like `createHistoryStream`, except all options are\n+supported. Local access is allowed, but not remote anonymous access.\n+`createUserStream` can decrypt private messages if you pass the option\n+`{ private: true }`.\n \n ### db.links({source: feedId?, dest: feedId|msgId|blobId?, rel: string?, meta: true?, keys: true?, values: false?, live:false?, reverse: false?}) -> PullSource\n "
        },
        {
          "filename": "create.js",
          "status": "modified",
          "additions": 16,
          "deletions": 3,
          "patch": "@@ -84,8 +84,8 @@ module.exports = function create (path, opts, keys) {\n         if (err) return cb(err)\n \n         if (!isPrivate) {\n-          if (meta) cb(null, { key, value: data.value, timestamp: data.timestamp })\n-          else cb(null, data.value)\n+          if (meta) cb(null, { key, value: u.originalValue(data.value), timestamp: data.timestamp })\n+          else cb(null, u.originalValue(data.value))\n         }\n         else {\n           const result = db._unbox(data, unbox)\n@@ -133,12 +133,25 @@ module.exports = function create (path, opts, keys) {\n   }\n \n   db.createRawLogStream = function (opts) {\n-    return db.stream(opts)\n+    return pull(\n+      db.stream(opts),\n+      pull.map(({ seq, value }) => {\n+        return { seq, value: u.originalData(value) }\n+      })\n+    )\n   }\n \n   // pull in the features that are needed to pass the tests\n   // and that sbot, etc uses but are slow.\n   extras(db, opts, keys)\n+  // - adds indexes: links, feed, time\n+  // - adds methods:\n+  //   - db.createLogStream\n+  //   - db.createFeedStream\n+  //   - db.creareUserStream\n+  //   - db.latest\n+  //   - db.latestSequence\n+  //   - db.getLatest\n \n   // writeStream - used in (legacy) replication.\n   db.createWriteStream = function (cb) {"
        },
        {
          "filename": "index.js",
          "status": "modified",
          "additions": 26,
          "deletions": 32,
          "patch": "@@ -5,7 +5,9 @@ var osenv      = require('osenv')\n var mkdirp     = require('mkdirp')\n var rimraf     = require('rimraf')\n var valid      = require('./lib/validators')\n-var pkg        = require('./package.json')\n+var version    = require('./package.json').version\n+var help       = require('./help')\n+\n const pull = require('pull-stream')\n const pullNotify = require('pull-notify')\n const pullCat = require('pull-cat')\n@@ -35,7 +37,7 @@ var manifest = {\n   status: 'sync',\n   getVectorClock: 'async',\n   version: 'sync',\n-  help: 'sync',\n+  help: 'sync'\n }\n \n module.exports = {\n@@ -106,42 +108,23 @@ module.exports = {\n     ssb.since(sequenceNotifier)\n \n     return self = {\n-      id                       : feed.id,\n       keys                     : opts.keys,\n+      id                       : feed.id,\n \n-      ready                    : function () {\n-        return ssb.ready.value\n-      },\n-\n-      progress                 : function () {\n-        return ssb.progress\n+      whoami                   : () => {\n+        return { id: feed.id }\n       },\n-\n-      status                   : function () {\n+      version                  : () => version,\n+      ready                    : () => ssb.ready.value,\n+      progress                 : () => ssb.progress,\n+      status                   : () => {\n         return {\n-          progress: self.progress(),\n+          progress: ssb.progress,\n           db: ssb.status,\n           sync: since()\n         }\n       },\n \n-      version                  : function () {\n-        return pkg.version\n-      },\n-\n-      createSequenceStream: () => {\n-        // If the initial value is `undefined` we want it to be `-1`.\n-        // This is because `-1` is a magic sequence number for an empty log.\n-        const initialValue = ssb.since.value !== undefined\n-          ? ssb.since.value\n-          : -1\n-        \n-        return pullCat([\n-          pull.values([initialValue]),\n-          sequenceNotifier.listen()\n-        ])\n-      },\n-\n       //temporary!\n       _flumeUse                : function (name, flumeview) {\n         ssb.use(name, flumeview)\n@@ -164,20 +147,31 @@ module.exports = {\n       getLatest                : valid.async(ssb.getLatest, 'feedId'),\n       latestSequence           : valid.async(ssb.latestSequence, 'feedId'),\n       createFeed               : ssb.createFeed,\n-      whoami                   : function () { return { id: feed.id } },\n       createFeedStream         : valid.source(ssb.createFeedStream, 'readStreamOpts?'),\n       createHistoryStream      : valid.source(ssb.createHistoryStream, ['createHistoryStreamOpts'], ['feedId', 'number?', 'boolean?']),\n       createLogStream          : valid.source(ssb.createLogStream, 'readStreamOpts?'),\n       createUserStream         : valid.source(ssb.createUserStream, 'createUserStreamOpts'),\n+      createSequenceStream     : () => {\n+        // If the initial value is `undefined` we want it to be `-1`.\n+        // This is because `-1` is a magic sequence number for an empty log.\n+        const initialValue = ssb.since.value !== undefined\n+          ? ssb.since.value\n+          : -1\n+\n+        return pullCat([\n+          pull.values([initialValue]),\n+          sequenceNotifier.listen()\n+        ])\n+      },\n       links                    : valid.source(ssb.links, 'linksOpts'),\n-      sublevel                 : ssb.sublevel,\n+      // sublevel                 : ssb.sublevel, // Disabled as does not appear to be used\n       messagesByType           : valid.source(ssb.messagesByType, 'string|messagesByTypeOpts'),\n       createWriteStream        : ssb.createWriteStream,\n       getVectorClock           : ssb.getVectorClock,\n       getAtSequence            : ssb.getAtSequence,\n       addBoxer                 : ssb.addBoxer,\n       addUnboxer               : ssb.addUnboxer,\n-      help                     : function () { return require('./help') }\n+      help                     : () => help\n     }\n   }\n }"
        },
        {
          "filename": "test/box-unbox.js",
          "status": "modified",
          "additions": 81,
          "deletions": 13,
          "patch": "@@ -3,11 +3,12 @@ var tape = require('tape')\n var pull = require('pull-stream')\n var ssbKeys = require('ssb-keys')\n var box1 = require('ssb-private1/box1')\n+const { promisify } = require('util')\n \n var createSSB = require('./create-ssb')\n var { originalValue } = require('../util')\n \n-module.exports = function (opts) {\n+module.exports = function () {\n   var alice = ssbKeys.generate()\n   var bob = ssbKeys.generate()\n   var charles = ssbKeys.generate()\n@@ -34,13 +35,12 @@ module.exports = function (opts) {\n   tape('error when trying to encrypt without boxer', (t) => {\n     t.plan(2);\n     const darlene = ssbKeys.generate()\n-    const darleneSSB = createSSB('test-ssb-darlene', { keys: darlene })\n     const darleneFeed = ssb.createFeed(darlene)\n     darleneFeed.add(\n       { type: \"error\", recps: [alice, darlene] },\n       (err, msg) => {\n-\tt.ok(err);\n-\tt.notOk(msg);\n+        t.ok(err);\n+        t.notOk(msg);\n         t.end()\n       })\n   })\n@@ -52,7 +52,7 @@ module.exports = function (opts) {\n     var postObserved\n     var listener = ssb.post(msg => { postObserved = msg })\n \n-    feed.add(boxed, function (err, msg) {\n+    feed.add(boxed, function (err) {\n       if (err) throw err\n       t.notOk(err)\n \n@@ -145,7 +145,7 @@ module.exports = function (opts) {\n     var listener = ssb.post(msg => { postObserved = msg })\n \n     // secret message sent to self\n-    feed.add({ type: 'secret2', secret: \"it's a secret!\", recps: feed.id }, function (err, msg) {\n+    feed.add({ type: 'secret2', secret: \"it's a secret!\", recps: feed.id }, function (err) {\n       if (err) throw err\n       t.notOk(err)\n \n@@ -165,7 +165,7 @@ module.exports = function (opts) {\n           )\n \n           listener()\n-          t.true(typeof postObserved.value.content === 'string', 'post obs messages should not be decrypted')\n+          t.true(typeof postObserved.value.content === 'string', 'db.post obs messages should not be decrypted')\n \n           t.end()\n         })\n@@ -264,7 +264,7 @@ module.exports = function (opts) {\n   })\n \n   tape('addUnboxer (simple)', function (t) {\n-    const unboxer = function (ciphertext, value) {\n+    const unboxer = function (ciphertext) {\n       if (!ciphertext.endsWith('.box.hah')) return\n \n       const base64 = ciphertext.replace('.box.hah', '')\n@@ -301,12 +301,12 @@ module.exports = function (opts) {\n           done()\n         }, 500)\n       },\n-      key: function (ciphertext, value) {\n+      key: function (ciphertext) {\n         if (!ciphertext.endsWith('.box.hah')) return\n \n         return '\"the msgKey\"'\n       },\n-      value: function (ciphertext, msgKey) {\n+      value: function (ciphertext) {\n         const base64 = ciphertext.replace('.box.hah', '')\n         return JSON.parse(\n           Buffer.from(base64, 'base64').toString('utf8')\n@@ -319,19 +319,87 @@ module.exports = function (opts) {\n     const content = {\n       type: 'poke',\n       reason: 'why not',\n-      recps: [ '!test' ]\n+      recps: [ '!test' ],\n+      myFriend: alice.id// Necessary to test links()\n     }\n     const ciphertext = Buffer.from(JSON.stringify(content)).toString('base64') + '.box.hah'\n \n     feed.publish(ciphertext, (_, msg) => {\n       t.true(initDone, 'unboxer completed initialisation before publish')\n \n-      ssb.get({ id: msg.key, private: true, meta: true }, (err, msg) => {\n-        if (err) throw err\n+      ssb.get({ id: msg.key, private: true, meta: true }, async (err, msg) => {\n+        t.error(err)\n \n         t.true(initDone, 'unboxer completed initialisation before get')\n         t.deepEqual(msg.value.content, content, 'auto unboxing works')\n+\n+        const assertBoxed = (methodName, message) => {\n+          if (typeof message.key === 'string') {\n+            t.equal(message.key, msg.key, `${methodName}() returned correct message`)\n+            t.equal(typeof message.value.content, 'string', `${methodName}() does not unbox by default`)\n+          } else {\n+            t.equal(typeof message.content, 'string', `${methodName}() does not unbox by default`)\n+          }\n+        }\n+\n+        const assertBoxedAsync = async (methodName, options) => {\n+          assertBoxed(methodName, await promisify(ssb[methodName])(options))\n+          if (typeof options === 'object' && Array.isArray(options) === false) {\n+            assertBoxed(methodName, await promisify(ssb[methodName])({ ...options, private: false } ))\n+          }\n+        }\n+\n+        // This tests the default behavior of `ssb.get()`, which should never\n+        // decrypt messages by default. This is **very important**.\n+        await assertBoxedAsync('get', msg.key)\n+        await assertBoxedAsync('get', { id: msg.key })\n+        await assertBoxedAsync('get', { id: msg.key, meta: true })\n+        await assertBoxedAsync('getAtSequence', [msg.value.author, msg.value.sequence])\n+        await assertBoxedAsync('getLatest', msg.value.author)\n+\n+        const assertBoxedSourceOnce = (methodName, options) => new Promise((resolve) => {\n+          pull(\n+            ssb[methodName](options),\n+            pull.collect((err, val) => {\n+              t.error(err, `${methodName}() does not error`)\n+              switch (methodName) {\n+                case 'createRawLogStream':\n+                  assertBoxed(methodName, val[0].value)\n+                  break;\n+                case 'createFeedStream':\n+                case 'createUserStream':\n+                case 'messagesByType':\n+                  // Apparently some methods take `{ private: false }` to mean\n+                  // \"don't return any private messages\". :/\n+                  if (options.private === undefined) {\n+                    assertBoxed(methodName, val[0].value)\n+                  }\n+                  break\n+                default:\n+                  assertBoxed(methodName, val[0])\n+              }\n+              resolve()\n+            })\n+          )\n+        })\n+\n+        // Test the default **and** `{ private: false }`.\n+        const assertBoxedSource = async (methodName, options) => {\n+          await assertBoxedSourceOnce(methodName, options)\n+          await assertBoxedSourceOnce(methodName, { ...options, private: false })\n+        }\n+\n+        await assertBoxedSource('createLogStream', { limit: 1, reverse: true })\n+        await assertBoxedSource('createHistoryStream', { id: msg.value.author, seq: msg.value.sequence, reverse: true})\n+        await assertBoxedSource('messagesByType', { type: 'poke', limit: 1, reverse: true })\n+        await assertBoxedSource('createFeedStream', { id: msg.value.author, seq: msg.value.sequence, reverse: true})\n+        await assertBoxedSource('createUserStream', { id: msg.value.author, seq: msg.value.sequence, reverse: true})\n+        await assertBoxedSource('links', { source: msg.value.author, limit: 1, values: true})\n+        await assertBoxedSource('createRawLogStream', { source: msg.value.author, limit: 1, reverse: true, values: true})\n+        // createRawLogStream currently not exported as a method\n+\n         t.end()\n+\n       })\n     })\n   })"
        },
        {
          "filename": "test/manifest.js",
          "status": "added",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -0,0 +1,23 @@\n+'use strict'\n+var tape = require('tape')\n+var { manifest, init } = require('../')\n+\n+module.exports = function () {\n+  tape('manifest', t => {\n+    const _api = {}\n+    const opts = {\n+      path: `/tmp/ssb-manifest-test-${Date.now()}-${Math.random()}`\n+    }\n+    const api = init(_api, opts)\n+\n+    Object.keys(api).forEach(m => console.log(m))\n+\n+    Object.keys(manifest).forEach(method => {\n+      t.equal(typeof api[method], 'function', `api.${method}`)\n+    })\n+\n+    t.end()\n+  })\n+}\n+\n+if (!module.parent) { module.exports({}) }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "18ce13af132456434ad62340784fe2b456c14a8c",
            "date": "2022-09-08T12:37:10Z",
            "author_login": "soapdog"
          },
          {
            "sha": "4c8a8b503df80e407e4cfb0167633f39a4a3377b",
            "date": "2021-09-14T22:39:19Z",
            "author_login": "mixmix"
          },
          {
            "sha": "e1c53e05541443ad1a2503f6566a5f5cfcde32f9",
            "date": "2021-09-14T22:38:16Z",
            "author_login": "mixmix"
          },
          {
            "sha": "9a161d46e6bee905336b0466eae096a7814b704e",
            "date": "2021-09-14T05:10:29Z",
            "author_login": "mixmix"
          },
          {
            "sha": "b74c9c7d312ab247781d8237f8436668dde03af8",
            "date": "2021-06-02T18:06:48Z",
            "author_login": "staltz"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-200",
    "description": "SSB-DB version 20.0.0 has an information disclosure vulnerability. The get() method is supposed to only decrypt messages when you explicitly ask it to, but there is a bug where it's decrypting any message that it can. This means that it is returning the decrypted content of private messages, which a malicious peer could use to get access to private data. This only affects peers running SSB-DB@20.0.0 who also have private messages, and is only known to be exploitable if you're also running SSB-OOO (default in SSB-Server), which exposes a thin wrapper around get() to anonymous peers. This is fixed in version 20.0.1. Note that users of SSB-Server verion 16.0.0 should upgrade to 16.0.1 to get the fixed version of SSB-DB.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-06-11T22:15:10.083",
    "last_modified": "2024-11-21T05:32:12.867",
    "fix_date": "2020-06-11T02:36:12Z"
  },
  "references": [
    {
      "url": "https://github.com/ssbc/ssb-db/commit/43334d0871c9cc6220e0f6d6338499060f7761d4",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ssbc/ssb-db/security/advisories/GHSA-mpgr-2cx9-327h",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ssbc/ssb-db/commit/43334d0871c9cc6220e0f6d6338499060f7761d4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ssbc/ssb-db/security/advisories/GHSA-mpgr-2cx9-327h",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:47.848108",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "ssb-db",
    "owner": "ssbc",
    "created_at": "2014-05-10T22:42:14Z",
    "updated_at": "2025-01-07T14:21:28Z",
    "pushed_at": "2024-07-13T11:53:16Z",
    "size": 1213,
    "stars": 1171,
    "forks": 75,
    "open_issues": 14,
    "watchers": 1171,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "JavaScript": 129499
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T21:59:36.525148"
  }
}