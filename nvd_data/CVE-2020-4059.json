{
  "cve_id": "CVE-2020-4059",
  "github_data": {
    "repository": "mikaelbr/mversion",
    "fix_commit": "6c76c9efd27c7ff5a5c6f187e8b7a435c4722338",
    "related_commits": [
      "6c76c9efd27c7ff5a5c6f187e8b7a435c4722338",
      "6c76c9efd27c7ff5a5c6f187e8b7a435c4722338"
    ],
    "patch_url": "https://github.com/mikaelbr/mversion/commit/6c76c9efd27c7ff5a5c6f187e8b7a435c4722338.patch",
    "fix_commit_details": {
      "sha": "6c76c9efd27c7ff5a5c6f187e8b7a435c4722338",
      "commit_date": "2020-06-15T16:14:37Z",
      "author": {
        "login": "mikaelbr",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fixes missing shell escape for git commit message",
        "length": 49,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 241,
        "additions": 141,
        "deletions": 100
      },
      "files": [
        {
          "filename": "lib/git.js",
          "status": "modified",
          "additions": 37,
          "deletions": 28,
          "patch": "@@ -1,62 +1,71 @@\n-var contra = require('contra'),\n-    path = require('path'),\n-    fUtils = require('./files'),\n-    cp = require('child_process');\n-\n-var gitApp = 'git', gitExtra = { env: process.env };\n+var contra = require(\"contra\"),\n+  path = require(\"path\"),\n+  fUtils = require(\"./files\"),\n+  cp = require(\"child_process\");\n \n+var gitApp = \"git\",\n+  gitExtra = { env: process.env };\n \n var escapeQuotes = function (str) {\n-  if (typeof str === 'string') {\n-    return str.replace(/([\"$`\\\\])/g, '\\\\$1');\n+  if (typeof str === \"string\") {\n+    return '\"' + str.replace(/([\"'$`\\\\])/g, \"\\\\$1\") + '\"';\n   } else {\n     return str;\n   }\n };\n \n module.exports.isRepositoryClean = function (callback) {\n-  cp.exec(gitApp + ' ' + [ 'ls-files', '-m' ].join(' '), gitExtra, function (er, stdout, stderr) {\n+  cp.exec(gitApp + \" \" + [\"ls-files\", \"-m\"].join(\" \"), gitExtra, function (\n+    er,\n+    stdout,\n+    stderr\n+  ) {\n     // makeCommit parly inspired and taken from NPM version module\n-    var lines = stdout.trim().split('\\n').filter(function (line) {\n-      var file = path.basename(line.replace(/.{1,2}\\s+/, ''));\n-      return line.trim() && !line.match(/^\\?\\? /) && !fUtils.isPackageFile(line);\n-    }).map(function (line) {\n-      return line.trim()\n-    });\n+    var lines = stdout\n+      .trim()\n+      .split(\"\\n\")\n+      .filter(function (line) {\n+        var file = path.basename(line.replace(/.{1,2}\\s+/, \"\"));\n+        return (\n+          line.trim() && !line.match(/^\\?\\? /) && !fUtils.isPackageFile(line)\n+        );\n+      })\n+      .map(function (line) {\n+        return line.trim();\n+      });\n \n     if (lines.length) {\n-      return callback(new Error('Git working directory not clean.\\n'+lines.join('\\n')));\n+      return callback(\n+        new Error(\"Git working directory not clean.\\n\" + lines.join(\"\\n\"))\n+      );\n     }\n     return callback();\n   });\n };\n \n module.exports.checkout = function (callback) {\n-  cp.exec(gitApp + ' checkout -- .', gitExtra, callback);\n+  cp.exec(gitApp + \" checkout -- .\", gitExtra, callback);\n };\n \n module.exports.commit = function (files, message, newVer, tagName, callback) {\n-  message = message.replace('%s', newVer).replace('\"', '').replace(\"'\", '');\n-  files = files.map(function (file) {\n-    return '\"' + escapeQuotes(file) + '\"';\n-  }).join(' ');\n+  message = escapeQuotes(message.replace(\"%s\", newVer));\n+  files = files.map(escapeQuotes).join(\" \");\n   var functionSeries = [\n     function (done) {\n-      cp.exec(gitApp + ' add ' + files, gitExtra, done);\n+      cp.exec(gitApp + \" add \" + files, gitExtra, done);\n     },\n \n     function (done) {\n-      cp.exec([gitApp, 'commit', '-m', '\"' + message + '\"'].join(' '), gitExtra, done);\n+      cp.exec([gitApp, \"commit\", \"-m\", message].join(\" \"), gitExtra, done);\n     },\n \n     function (done) {\n       cp.exec(\n-        [\n-          gitApp, 'tag', '-a', tagName, '-m', '\"' + message + '\"'\n-        ].join(' '),\n-        gitExtra, done\n+        [gitApp, \"tag\", \"-a\", tagName, \"-m\", message].join(\" \"),\n+        gitExtra,\n+        done\n       );\n-    }\n+    },\n   ];\n   contra.series(functionSeries, callback);\n };"
        },
        {
          "filename": "tests/git_test.js",
          "status": "modified",
          "additions": 104,
          "deletions": 72,
          "patch": "@@ -1,17 +1,17 @@\n-var version = require('../'),\n-    assert = require('assert'),\n-    fs = require('fs'),\n-    vinylFs = require('vinyl-fs'),\n-    path = require('path'),\n-    cp = require('child_process'),\n-    File = require('vinyl'),\n-    through = require('through2'),\n-    fUtil = require('../lib/files'),\n-    git = require('../lib/git');\n-\n-describe('git', function () {\n-  var filename = 'package.json';\n-  var expectedPath = path.join(__dirname, './fixtures/', filename);\n+var version = require(\"../\"),\n+  assert = require(\"assert\"),\n+  fs = require(\"fs\"),\n+  vinylFs = require(\"vinyl-fs\"),\n+  path = require(\"path\"),\n+  cp = require(\"child_process\"),\n+  File = require(\"vinyl\"),\n+  through = require(\"through2\"),\n+  fUtil = require(\"../lib/files\"),\n+  git = require(\"../lib/git\");\n+\n+describe(\"git\", function () {\n+  var filename = \"package.json\";\n+  var expectedPath = path.join(__dirname, \"./fixtures/\", filename);\n   var expectedContent = fs.readFileSync(expectedPath);\n \n   var original = fUtil.loadFiles;\n@@ -21,19 +21,19 @@ describe('git', function () {\n   var originalCommit = git.commit;\n   var originalCheckout = git.checkout;\n \n-  before(function ()\u00a0{\n+  before(function () {\n     vinylFs.dest = function () {\n       return through.obj(function (file, enc, next) {\n         this.push(file);\n         next();\n       });\n-    }\n+    };\n \n     var expectedFile = new File({\n       base: __dirname,\n       cwd: __dirname,\n       path: expectedPath,\n-      contents: expectedContent\n+      contents: expectedContent,\n     });\n \n     fUtil.loadFiles = function () {\n@@ -57,130 +57,162 @@ describe('git', function () {\n     cp.exec = exec;\n   });\n \n-  describe('#Update()', function(){\n-    it('should return error on unclean git repository when commit is given', function (done) {\n+  describe(\"#Update()\", function () {\n+    it(\"should return error on unclean git repository when commit is given\", function (done) {\n       git.isRepositoryClean = function (cb) {\n-        return cb(new Error('Not clean'));\n+        return cb(new Error(\"Not clean\"));\n       };\n \n-      version.update({\n-        version: '1.0.0',\n-        commitMessage: 'Message'\n-      }, function (err, data) {\n-        assert.ok(err);\n-        assert.equal(err.message, 'Not clean', 'Error message should be set by isRepositoryClean');\n+      version.update(\n+        {\n+          version: \"1.0.0\",\n+          commitMessage: \"Message\",\n+        },\n+        function (err, data) {\n+          assert.ok(err);\n+          assert.equal(\n+            err.message,\n+            \"Not clean\",\n+            \"Error message should be set by isRepositoryClean\"\n+          );\n+\n+          done();\n+        }\n+      );\n+    });\n \n+    it(\"should return NOT error on unclean git repository when no commit message is given\", function (done) {\n+      git.isRepositoryClean = function (cb) {\n+        return cb(new Error(\"Not clean\"));\n+      };\n+\n+      version.update(\"1.0.0\", function (err, data) {\n+        assert.ifError(err);\n         done();\n       });\n     });\n \n-    it('should return NOT error on unclean git repository when no commit message is given', function (done) {\n+    it(\"should sanitize commit message\", function (done) {\n       git.isRepositoryClean = function (cb) {\n-        return cb(new Error('Not clean'));\n+        return cb(null);\n       };\n \n-      version.update('1.0.0', function (err, data) {\n-        assert.ifError(err);\n+      cp.exec = function (cmd, extra, cb) {\n+        if (cmd.indexOf(\"-a\") === -1) return cb(null);\n+        assert.equal('git tag -a v1.0.0 -m \"Message \\\\`touch file\\\\`\"', cmd);\n         done();\n+      };\n+\n+      version.update({\n+        version: \"1.0.0\",\n+        commitMessage: \"Message `touch file`\",\n       });\n     });\n \n-    it('should get updated version sent to commit when commit message is given', function (done) {\n+    it(\"should get updated version sent to commit when commit message is given\", function (done) {\n       git.isRepositoryClean = function (cb) {\n         return cb(null);\n       };\n \n       git.commit = function (files, message, newVer, tagName, callback) {\n-        assert.equal(message, 'Message');\n-        assert.equal(newVer, '1.0.0');\n+        assert.equal(message, \"Message\");\n+        assert.equal(newVer, \"1.0.0\");\n         assert.equal(files[0], expectedPath);\n-        assert.equal(tagName, 'v1.0.0');\n+        assert.equal(tagName, \"v1.0.0\");\n         return callback(null);\n       };\n \n-      version.update({\n-        version: '1.0.0',\n-        commitMessage: 'Message'\n-      }, function (err, data) {\n-        assert.ifError(err);\n-        done();\n-      });\n+      version.update(\n+        {\n+          version: \"1.0.0\",\n+          commitMessage: \"Message\",\n+        },\n+        function (err, data) {\n+          assert.ifError(err);\n+          done();\n+        }\n+      );\n     });\n \n-    it('should be able to override tagName', function (done) {\n+    it(\"should be able to override tagName\", function (done) {\n       git.isRepositoryClean = function (cb) {\n         return cb(null);\n       };\n \n       git.commit = function (files, message, newVer, tagName, callback) {\n-        assert.equal(tagName, 'v1.0.0-src');\n+        assert.equal(tagName, \"v1.0.0-src\");\n         return callback(null);\n       };\n \n-      version.update({\n-        version: '1.0.0',\n-        commitMessage: 'Message',\n-        tagName: 'v%s-src'\n-      }, function (err, data) {\n-        assert.ifError(err);\n-        done();\n-      });\n+      version.update(\n+        {\n+          version: \"1.0.0\",\n+          commitMessage: \"Message\",\n+          tagName: \"v%s-src\",\n+        },\n+        function (err, data) {\n+          assert.ifError(err);\n+          done();\n+        }\n+      );\n     });\n \n-    it('should get flag defining if v-prefix should be used or not', function (done) {\n+    it(\"should get flag defining if v-prefix should be used or not\", function (done) {\n       git.isRepositoryClean = function (cb) {\n         return cb(null);\n       };\n \n       git.commit = function (files, message, newVer, noPrefix, callback) {\n-        assert.ok(noPrefix, 'No prefix should be true');\n+        assert.ok(noPrefix, \"No prefix should be true\");\n         return callback(null);\n       };\n \n-      version.update({\n-        version: '1.0.0',\n-        commitMessage: 'Message',\n-        noPrefix: true\n-      }, function (err, data) {\n-        assert.ifError(err);\n-        done();\n-      });\n+      version.update(\n+        {\n+          version: \"1.0.0\",\n+          commitMessage: \"Message\",\n+          noPrefix: true,\n+        },\n+        function (err, data) {\n+          assert.ifError(err);\n+          done();\n+        }\n+      );\n     });\n \n-    it('should make tag with v-prefix per default', function (done) {\n+    it(\"should make tag with v-prefix per default\", function (done) {\n       git.isRepositoryClean = function (cb) {\n         return cb(null);\n       };\n \n       cp.exec = function (cmd, extra, cb) {\n-        if (cmd.indexOf('-a') === -1) return cb(null);\n+        if (cmd.indexOf(\"-a\") === -1) return cb(null);\n         assert.equal('git tag -a v1.0.0 -m \"Message\"', cmd);\n         done();\n       };\n \n       version.update({\n-        version: '1.0.0',\n-        commitMessage: 'Message'\n+        version: \"1.0.0\",\n+        commitMessage: \"Message\",\n       });\n     });\n \n-    it('should make tag without v-prefix if specified', function (done) {\n+    it(\"should make tag without v-prefix if specified\", function (done) {\n       git.isRepositoryClean = function (cb) {\n         return cb(null);\n       };\n \n       cp.exec = function (cmd, extra, cb) {\n-        if (cmd.indexOf('-a') === -1) return cb(null);\n+        if (cmd.indexOf(\"-a\") === -1) return cb(null);\n         assert.equal('git tag -a 1.0.0 -m \"Message\"', cmd);\n         done();\n       };\n \n       version.update({\n-        version: '1.0.0',\n-        commitMessage: 'Message',\n-        noPrefix: true\n+        version: \"1.0.0\",\n+        commitMessage: \"Message\",\n+        noPrefix: true,\n       });\n     });\n   });\n-\n-});\n\\ No newline at end of file\n+});"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "3119ce1f3d09f64939e1d70323d4aac9be6978fc",
            "date": "2023-02-09T19:46:00Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "070e35571f91a7a7b03c338d3511be4128fc2fc1",
            "date": "2023-02-09T19:45:42Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "4e0bc6228443efa8e09be276e5a5453a5fb76492",
            "date": "2023-02-09T19:44:14Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "dc92f67e151b44ab76134698549bfa081f9f7d71",
            "date": "2023-02-09T19:43:37Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "0870a4bc6511642736800d18967d2c73f93243d0",
            "date": "2023-02-09T19:43:15Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
    "cwe_id": "CWE-77",
    "description": "In mversion before 2.0.0, there is a command injection vulnerability. This issue may lead to remote code execution if a client of the library calls the vulnerable method with untrusted input. This vulnerability is patched by version 2.0.0. Previous releases are deprecated in npm. As a workaround, make sure to escape git commit messages when using the commitMessage option for the update function.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-06-18T20:15:10.760",
    "last_modified": "2024-11-21T05:32:14.177",
    "fix_date": "2020-06-15T16:14:37Z"
  },
  "references": [
    {
      "url": "https://github.com/mikaelbr/mversion/commit/6c76c9efd27c7ff5a5c6f187e8b7a435c4722338",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/mikaelbr/mversion/security/advisories/GHSA-qjg4-w4c6-f6c6",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/mikaelbr/mversion/commit/6c76c9efd27c7ff5a5c6f187e8b7a435c4722338",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/mikaelbr/mversion/security/advisories/GHSA-qjg4-w4c6-f6c6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:47.861661",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "mversion",
    "owner": "mikaelbr",
    "created_at": "2013-04-30T13:51:30Z",
    "updated_at": "2024-01-12T02:19:47Z",
    "pushed_at": "2023-07-01T00:07:10Z",
    "size": 552,
    "stars": 201,
    "forks": 19,
    "open_issues": 14,
    "watchers": 201,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "JavaScript": 45138
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T14:14:23.407274"
  }
}