{
  "cve_id": "CVE-2020-5234",
  "github_data": {
    "repository": "neuecc/MessagePack-CSharp",
    "fix_commit": "56fa86219d01d0a183babbbbcb34abbdea588a02",
    "related_commits": [
      "56fa86219d01d0a183babbbbcb34abbdea588a02",
      "f88684078698386df02204f13faeff098a61f007",
      "56fa86219d01d0a183babbbbcb34abbdea588a02",
      "f88684078698386df02204f13faeff098a61f007"
    ],
    "patch_url": "https://github.com/neuecc/MessagePack-CSharp/commit/56fa86219d01d0a183babbbbcb34abbdea588a02.patch",
    "fix_commit_details": {
      "sha": "56fa86219d01d0a183babbbbcb34abbdea588a02",
      "commit_date": "2020-01-30T23:32:36Z",
      "author": {
        "login": "AArnott",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge security fixes in for v2.1",
        "length": 32,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 3043,
        "additions": 2605,
        "deletions": 438
      },
      "files": [
        {
          "filename": "README.md",
          "status": "modified",
          "additions": 32,
          "deletions": 2,
          "patch": "@@ -527,6 +527,27 @@ MessagePack.Formatters.TypelessFormatter.BindToType = typeName =>\n };\n ```\n \n+## <a name=\"security\"></a>Security\n+\n+Deserializing data from an untrusted source can introduce security vulnerabilities to your application.\n+Depending on the settings used during deserialization, untrusted data may be able to execute arbitrary code or a denial of service attack.\n+Untrusted data might come from over the Internet over an unauthenticated connection, from the local disk if it may have been tampered with, or many other sources.\n+\n+When deserializing untrusted data, put MessagePack into a more secure mode by configuring your `MessagePackSerializerOptions.Security` property:\n+\n+```cs\n+var options = MessagePackSerializerOptions.Standard\n+    .WithSecurity(MessagePackSecurity.UntrustedData);\n+\n+// Pass the options explicitly for the greatest control.\n+T object = MessagePackSerializer.Deserialize<T>(data, options);\n+\n+// Or set the security level as the default.\n+MessagePackSerializer.DefaultOptions = options;\n+```\n+\n+You should also avoid the Typeless serializer/formatters/resolvers for untrusted data as that opens the door for the untrusted data to potentially deserialize unanticipated types that can compromise security.\n+\n ## Performance\n \n Benchmarks comparing to other serializers run on `Windows 10 Pro x64 Intel Core i7-6700K 4.00GHz, 32GB RAM`. Benchmark code is [here](https://github.com/neuecc/ZeroFormatter/tree/master/sandbox/PerformanceComparison) - and there [version info](https://github.com/neuecc/ZeroFormatter/blob/bc63cb925d/sandbox/PerformanceComparison/packages.config), ZeroFormatter and [FlatBuffers](https://google.github.io/flatbuffers/) has infinitely fast deserializer so ignore deserialize performance.\n@@ -950,13 +971,22 @@ public class FileInfoFormatter<T> : IMessagePackFormatter<FileInfo>\n             return null;\n         }\n \n+        options.Security.DepthStep(ref reader);\n+\n         var path = reader.ReadString();\n+\n+        reader.Depth--;\n         return new FileInfo(path);\n     }\n }\n ```\n \n-Your custom formatters must be discoverable via some `IFormatterResolver`. Learn more in our [resolvers](#resolvers).\n+The `DepthStep` and `Depth--` statements provide a level of security while deserializing untrusted data\n+that might otherwise be able to execute a denial of service attack by sending messagepack data that would\n+deserialize into a very deep object graph leading to a `StackOverflowException` that would crash the process.\n+This pair of statements should surround the bulk of any `IMessagePackFormatter<T>.Deserialize` method.\n+\n+Your custom formatters must be discoverable via some `IFormatterResolver`. Learn more in our [resolvers](#resolvers) section.\n \n You can see many other samples from [builtin formatters](https://github.com/neuecc/MessagePack-CSharp/tree/master/src/MessagePack/Formatters).\n \n@@ -1300,7 +1330,7 @@ Because strict-AOT environments such as Xamarin and Unity IL2CPP forbid runtime\n \n If you want to avoid the upfront dynamic generation cost or you need to run on Xamarin or Unity, you need AOT code generation. `mpc` (MessagePackCompiler) is the code generator of MessagePack for C#. mpc uses [Roslyn](https://github.com/dotnet/roslyn) to analyze source code.\n \n-In the first, mpc requires [.NET Core 3 Runtime](https://dotnet.microsoft.com/download), the easiest way to acquire and run mpc is as a dotnet tool. \n+In the first, mpc requires [.NET Core 3 Runtime](https://dotnet.microsoft.com/download), the easiest way to acquire and run mpc is as a dotnet tool.\n \n ```\n dotnet tool install --global MessagePack.Generator"
        },
        {
          "filename": "sandbox/DynamicCodeDumper/DynamicCodeDumper.csproj",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -30,6 +30,9 @@\n     <Compile Include=\"..\\..\\src\\MessagePack.UnityClient\\Assets\\Scripts\\MessagePack\\Internal\\AutomataDictionary.cs\">\n       <Link>Code\\AutomataDictionary.cs</Link>\n     </Compile>\n+    <Compile Include=\"..\\..\\src\\MessagePack.UnityClient\\Assets\\Scripts\\MessagePack\\Internal\\ThreadsafeTypeKeyHashTable.cs\">\n+      <Link>Code\\ThreadsafeTypeKeyHashTable.cs</Link>\n+    </Compile>\n     <Compile Include=\"..\\..\\src\\MessagePack.UnityClient\\Assets\\Scripts\\MessagePack\\Internal\\ByteArrayStringHashTable.cs\">\n       <Link>Code\\ByteArrayStringHashTable.cs</Link>\n     </Compile>\n@@ -66,6 +69,15 @@\n     <Compile Include=\"..\\..\\src\\MessagePack.UnityClient\\Assets\\Scripts\\MessagePack\\MessagePackSerializerOptions.cs\">\n       <Link>Code\\MessagePackSerializerOptions.cs</Link>\n     </Compile>\n+    <Compile Include=\"..\\..\\src\\MessagePack.UnityClient\\Assets\\Scripts\\MessagePack\\MessagePackSecurity.cs\">\n+      <Link>Code\\MessagePackSecurity.cs</Link>\n+    </Compile>\n+    <Compile Include=\"..\\..\\src\\MessagePack.UnityClient\\Assets\\Scripts\\MessagePack\\HashCode.cs\">\n+      <Link>Code\\HashCode.cs</Link>\n+    </Compile>\n+    <Compile Include=\"..\\..\\src\\MessagePack.UnityClient\\Assets\\Scripts\\MessagePack\\BitOperations.cs\">\n+      <Link>Code\\BitOperations.cs</Link>\n+    </Compile>\n     <Compile Include=\"..\\..\\src\\MessagePack.UnityClient\\Assets\\Scripts\\MessagePack\\MessagePackCompression.cs\">\n       <Link>Code\\MessagePackCompression.cs</Link>\n     </Compile>"
        },
        {
          "filename": "sandbox/Sandbox/Generated.cs",
          "status": "modified",
          "additions": 110,
          "deletions": 0,
          "patch": "@@ -378,6 +378,7 @@ public void Serialize(ref MessagePackWriter writer, global::IMessageBody value,\n                 throw new InvalidOperationException(\"Invalid Union data was detected. Type:global::IMessageBody\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             var key = reader.ReadInt32();\n \n             if (!this.keyToJumpMap.TryGetValue(key, out key))\n@@ -402,6 +403,7 @@ public void Serialize(ref MessagePackWriter writer, global::IMessageBody value,\n                     break;\n             }\n \n+            reader.Depth--;\n             return result;\n         }\n     }\n@@ -489,6 +491,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.IIVersion\n                 throw new InvalidOperationException(\"Invalid Union data was detected. Type:global::SharedData.IIVersioningUnion\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             var key = reader.ReadInt32();\n \n             if (!this.keyToJumpMap.TryGetValue(key, out key))\n@@ -507,6 +510,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.IIVersion\n                     break;\n             }\n \n+            reader.Depth--;\n             return result;\n         }\n     }\n@@ -577,6 +581,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.IUnionChe\n                 throw new InvalidOperationException(\"Invalid Union data was detected. Type:global::SharedData.IUnionChecker\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             var key = reader.ReadInt32();\n \n             if (!this.keyToJumpMap.TryGetValue(key, out key))\n@@ -604,6 +609,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.IUnionChe\n                     break;\n             }\n \n+            reader.Depth--;\n             return result;\n         }\n     }\n@@ -674,6 +680,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.IUnionChe\n                 throw new InvalidOperationException(\"Invalid Union data was detected. Type:global::SharedData.IUnionChecker2\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             var key = reader.ReadInt32();\n \n             if (!this.keyToJumpMap.TryGetValue(key, out key))\n@@ -701,6 +708,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.IUnionChe\n                     break;\n             }\n \n+            reader.Depth--;\n             return result;\n         }\n     }\n@@ -761,6 +769,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.IUnionSam\n                 throw new InvalidOperationException(\"Invalid Union data was detected. Type:global::SharedData.IUnionSample\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             var key = reader.ReadInt32();\n \n             if (!this.keyToJumpMap.TryGetValue(key, out key))\n@@ -782,6 +791,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.IUnionSam\n                     break;\n             }\n \n+            reader.Depth--;\n             return result;\n         }\n     }\n@@ -842,6 +852,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.RootUnion\n                 throw new InvalidOperationException(\"Invalid Union data was detected. Type:global::SharedData.RootUnionType\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             var key = reader.ReadInt32();\n \n             if (!this.keyToJumpMap.TryGetValue(key, out key))\n@@ -863,6 +874,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.RootUnion\n                     break;\n             }\n \n+            reader.Depth--;\n             return result;\n         }\n     }\n@@ -926,6 +938,7 @@ public void Serialize(ref MessagePackWriter writer, global::Abcdefg.Efcdigjl.Ate\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty__ = default(int);\n@@ -947,6 +960,7 @@ public void Serialize(ref MessagePackWriter writer, global::Abcdefg.Efcdigjl.Ate\n \n             var ____result = new global::Abcdefg.Efcdigjl.Ateatatea.Hgfagfafgad.TnonodsfarnoiuAtatqaga();\n             ____result.MyProperty = __MyProperty__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -1016,6 +1030,7 @@ public void Serialize(ref MessagePackWriter writer, global::ArrayTestTest value,\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty0__ = default(int[]);\n@@ -1067,6 +1082,7 @@ public void Serialize(ref MessagePackWriter writer, global::ArrayTestTest value,\n             ____result.MyProperty4 = __MyProperty4__;\n             ____result.MyProperty5 = __MyProperty5__;\n             ____result.MyProperty6 = __MyProperty6__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -1132,6 +1148,7 @@ public void Serialize(ref MessagePackWriter writer, global::ComplexModel value,\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadMapHeader();\n             var __AdditionalProperty__ = default(global::System.Collections.Generic.IDictionary<string, string>);\n@@ -1182,6 +1199,7 @@ public void Serialize(ref MessagePackWriter writer, global::ComplexModel value,\n             ____result.Id = __Id__;\n             ____result.Name = __Name__;\n             ____result.UpdatedOn = __UpdatedOn__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -1210,6 +1228,7 @@ public void Serialize(ref MessagePackWriter writer, global::GlobalMan value, glo\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty__ = default(int);\n@@ -1231,6 +1250,7 @@ public void Serialize(ref MessagePackWriter writer, global::GlobalMan value, glo\n \n             var ____result = new global::GlobalMan();\n             ____result.MyProperty = __MyProperty__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -1262,6 +1282,7 @@ public void Serialize(ref MessagePackWriter writer, global::Message value, globa\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __UserId__ = default(int);\n@@ -1298,6 +1319,7 @@ public void Serialize(ref MessagePackWriter writer, global::Message value, globa\n             ____result.RoomId = __RoomId__;\n             ____result.PostTime = __PostTime__;\n             ____result.Body = __Body__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -1327,6 +1349,7 @@ public void Serialize(ref MessagePackWriter writer, global::QuestMessageBody val\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __QuestId__ = default(int);\n@@ -1353,6 +1376,7 @@ public void Serialize(ref MessagePackWriter writer, global::QuestMessageBody val\n             var ____result = new global::QuestMessageBody();\n             ____result.QuestId = __QuestId__;\n             ____result.Text = __Text__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -1418,6 +1442,7 @@ public void Serialize(ref MessagePackWriter writer, global::SimpleModel value, g\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadMapHeader();\n             var __Id__ = default(int);\n@@ -1469,6 +1494,7 @@ public void Serialize(ref MessagePackWriter writer, global::SimpleModel value, g\n             ____result.CreatedOn = __CreatedOn__;\n             ____result.Precision = __Precision__;\n             ____result.Money = __Money__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -1497,6 +1523,7 @@ public void Serialize(ref MessagePackWriter writer, global::StampMessageBody val\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __StampId__ = default(int);\n@@ -1518,6 +1545,7 @@ public void Serialize(ref MessagePackWriter writer, global::StampMessageBody val\n \n             var ____result = new global::StampMessageBody();\n             ____result.StampId = __StampId__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -1546,6 +1574,7 @@ public void Serialize(ref MessagePackWriter writer, global::TextMessageBody valu\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __Text__ = default(string);\n@@ -1567,6 +1596,7 @@ public void Serialize(ref MessagePackWriter writer, global::TextMessageBody valu\n \n             var ____result = new global::TextMessageBody();\n             ____result.Text = __Text__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -1679,6 +1709,7 @@ public void Serialize(ref MessagePackWriter writer, global::PerfBenchmarkDotNet.\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadMapHeader();\n             var __MyProperty1__ = default(int);\n@@ -1746,6 +1777,7 @@ public void Serialize(ref MessagePackWriter writer, global::PerfBenchmarkDotNet.\n             ____result.MyProperty7 = __MyProperty7__;\n             ____result.MyProperty8 = __MyProperty8__;\n             ____result.MyProperty9 = __MyProperty9__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -1824,6 +1856,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.ArrayOpti\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty0__ = default(int);\n@@ -1920,6 +1953,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.ArrayOpti\n             ____result.MyPropevrty13 = __MyPropevrty13__;\n             ____result.MyProperty14 = __MyProperty14__;\n             ____result.MyProperty15 = __MyProperty15__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -1948,6 +1982,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.BarClass\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __OPQ__ = default(string);\n@@ -1969,6 +2004,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.BarClass\n \n             var ____result = new global::SharedData.BarClass();\n             ____result.OPQ = __OPQ__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -1998,6 +2034,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Callback1\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __X__ = default(int);\n@@ -2020,6 +2057,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Callback1\n             var ____result = new global::SharedData.Callback1(__X__);\n             ____result.X = __X__;\n             ____result.OnAfterDeserialize();\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2049,6 +2087,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Callback1\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __X__ = default(int);\n@@ -2071,6 +2110,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Callback1\n             var ____result = new global::SharedData.Callback1_2(__X__);\n             ____result.X = __X__;\n             ((IMessagePackSerializationCallbackReceiver)____result).OnAfterDeserialize();\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2111,6 +2151,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Callback2\n                 throw new InvalidOperationException(\"typecode is null, struct not supported\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadMapHeader();\n             var __X__ = default(int);\n@@ -2139,6 +2180,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Callback2\n             var ____result = new global::SharedData.Callback2(__X__);\n             ____result.X = __X__;\n             ____result.OnAfterDeserialize();\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2179,6 +2221,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Callback2\n                 throw new InvalidOperationException(\"typecode is null, struct not supported\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadMapHeader();\n             var __X__ = default(int);\n@@ -2207,6 +2250,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Callback2\n             var ____result = new global::SharedData.Callback2_2(__X__);\n             ____result.X = __X__;\n             ((IMessagePackSerializationCallbackReceiver)____result).OnAfterDeserialize();\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2234,6 +2278,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Empty1 va\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n \n@@ -2250,6 +2295,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Empty1 va\n             }\n \n             var ____result = new global::SharedData.Empty1();\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2291,6 +2337,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Empty2 va\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadMapHeader();\n \n@@ -2313,6 +2360,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Empty2 va\n             }\n \n             var ____result = new global::SharedData.Empty2();\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2340,6 +2388,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.EmptyClas\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n \n@@ -2356,6 +2405,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.EmptyClas\n             }\n \n             var ____result = new global::SharedData.EmptyClass();\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2377,6 +2427,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.EmptyStru\n                 throw new InvalidOperationException(\"typecode is null, struct not supported\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n \n@@ -2393,6 +2444,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.EmptyStru\n             }\n \n             var ____result = new global::SharedData.EmptyStruct();\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2423,6 +2475,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.FirstSimp\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __Prop1__ = default(int);\n@@ -2454,6 +2507,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.FirstSimp\n             ____result.Prop1 = __Prop1__;\n             ____result.Prop2 = __Prop2__;\n             ____result.Prop3 = __Prop3__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2482,6 +2536,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.FooClass\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __XYZ__ = default(int);\n@@ -2503,6 +2558,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.FooClass\n \n             var ____result = new global::SharedData.FooClass();\n             ____result.XYZ = __XYZ__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2532,6 +2588,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.HolderV0\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty1__ = default(global::SharedData.Version0);\n@@ -2558,6 +2615,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.HolderV0\n             var ____result = new global::SharedData.HolderV0();\n             ____result.MyProperty1 = __MyProperty1__;\n             ____result.After = __After__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2587,6 +2645,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.HolderV1\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty1__ = default(global::SharedData.Version1);\n@@ -2613,6 +2672,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.HolderV1\n             var ____result = new global::SharedData.HolderV1();\n             ____result.MyProperty1 = __MyProperty1__;\n             ____result.After = __After__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2642,6 +2702,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.HolderV2\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty1__ = default(global::SharedData.Version2);\n@@ -2668,6 +2729,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.HolderV2\n             var ____result = new global::SharedData.HolderV2();\n             ____result.MyProperty1 = __MyProperty1__;\n             ____result.After = __After__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2698,6 +2760,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.MyClass v\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty1__ = default(int);\n@@ -2729,6 +2792,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.MyClass v\n             ____result.MyProperty1 = __MyProperty1__;\n             ____result.MyProperty2 = __MyProperty2__;\n             ____result.MyProperty3 = __MyProperty3__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2760,6 +2824,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.MySubUnio\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __One__ = default(int);\n@@ -2781,6 +2846,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.MySubUnio\n \n             var ____result = new global::SharedData.MySubUnion1();\n             ____result.One = __One__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2808,6 +2874,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.MySubUnio\n                 throw new InvalidOperationException(\"typecode is null, struct not supported\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __Two__ = default(int);\n@@ -2829,6 +2896,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.MySubUnio\n \n             var ____result = new global::SharedData.MySubUnion2();\n             ____result.Two = __Two__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2859,6 +2927,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.MySubUnio\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __Three__ = default(int);\n@@ -2880,6 +2949,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.MySubUnio\n \n             var ____result = new global::SharedData.MySubUnion3();\n             ____result.Three = __Three__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2909,6 +2979,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.MySubUnio\n                 throw new InvalidOperationException(\"typecode is null, struct not supported\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __Four__ = default(int);\n@@ -2930,6 +3001,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.MySubUnio\n \n             var ____result = new global::SharedData.MySubUnion4();\n             ____result.Four = __Four__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -2958,6 +3030,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.NestParen\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty__ = default(int);\n@@ -2979,6 +3052,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.NestParen\n \n             var ____result = new global::SharedData.NestParent.NestContract();\n             ____result.MyProperty = __MyProperty__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -3007,6 +3081,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.NonEmpty1\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty__ = default(int);\n@@ -3028,6 +3103,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.NonEmpty1\n \n             var ____result = new global::SharedData.NonEmpty1();\n             ____result.MyProperty = __MyProperty__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -3073,6 +3149,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.NonEmpty2\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadMapHeader();\n             var __MyProperty__ = default(int);\n@@ -3100,6 +3177,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.NonEmpty2\n \n             var ____result = new global::SharedData.NonEmpty2();\n             ____result.MyProperty = __MyProperty__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -3134,6 +3212,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.SimpleInt\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __Prop1__ = default(int);\n@@ -3185,6 +3264,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.SimpleInt\n             ____result.Prop5 = __Prop5__;\n             ____result.Prop6 = __Prop6__;\n             ____result.BytesSpecial = __BytesSpecial__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -3238,6 +3318,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.SimpleStr\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadMapHeader();\n             var __Prop1__ = default(int);\n@@ -3275,6 +3356,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.SimpleStr\n             ____result.Prop1 = __Prop1__;\n             ____result.Prop2 = __Prop2__;\n             ____result.Prop3 = __Prop3__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -3299,6 +3381,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.SimpleStr\n                 throw new InvalidOperationException(\"typecode is null, struct not supported\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __X__ = default(int);\n@@ -3330,6 +3413,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.SimpleStr\n             ____result.X = __X__;\n             ____result.Y = __Y__;\n             ____result.BytesSpecial = __BytesSpecial__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -3373,6 +3457,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.SimpleStr\n                 throw new InvalidOperationException(\"typecode is null, struct not supported\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadMapHeader();\n             var __X__ = default(int);\n@@ -3405,6 +3490,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.SimpleStr\n             var ____result = new global::SharedData.SimpleStructStringKeyData();\n             ____result.X = __X__;\n             ____result.Y = __Y__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -3434,6 +3520,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.SubUnionT\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty1__ = default(int);\n@@ -3460,6 +3547,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.SubUnionT\n             var ____result = new global::SharedData.SubUnionType1();\n             ____result.MyProperty1 = __MyProperty1__;\n             ____result.MyProperty = __MyProperty__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -3489,6 +3577,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.SubUnionT\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty2__ = default(int);\n@@ -3515,6 +3604,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.SubUnionT\n             var ____result = new global::SharedData.SubUnionType2();\n             ____result.MyProperty2 = __MyProperty2__;\n             ____result.MyProperty = __MyProperty__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -3545,6 +3635,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.UnVersion\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty__ = default(int);\n@@ -3571,6 +3662,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.UnVersion\n             var ____result = new global::SharedData.UnVersionBlockTest();\n             ____result.MyProperty = __MyProperty__;\n             ____result.MyProperty2 = __MyProperty2__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -3594,6 +3686,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Vector2 v\n                 throw new InvalidOperationException(\"typecode is null, struct not supported\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __X__ = default(float);\n@@ -3618,6 +3711,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Vector2 v\n             }\n \n             var ____result = new global::SharedData.Vector2(__X__, __Y__);\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -3642,6 +3736,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Vector3Li\n                 throw new InvalidOperationException(\"typecode is null, struct not supported\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __x__ = default(float);\n@@ -3673,6 +3768,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Vector3Li\n             ____result.x = __x__;\n             ____result.y = __y__;\n             ____result.z = __z__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -3696,6 +3792,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.VectorLik\n                 throw new InvalidOperationException(\"typecode is null, struct not supported\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __x__ = default(float);\n@@ -3722,6 +3819,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.VectorLik\n             var ____result = new global::SharedData.VectorLike2(__x__, __y__);\n             ____result.x = __x__;\n             ____result.y = __y__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -3753,6 +3851,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Version0\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty1__ = default(int);\n@@ -3774,6 +3873,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Version0\n \n             var ____result = new global::SharedData.Version0();\n             ____result.MyProperty1 = __MyProperty1__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -3807,6 +3907,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Version1\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty1__ = default(int);\n@@ -3838,6 +3939,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Version1\n             ____result.MyProperty1 = __MyProperty1__;\n             ____result.MyProperty2 = __MyProperty2__;\n             ____result.MyProperty3 = __MyProperty3__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -3873,6 +3975,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Version2\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty1__ = default(int);\n@@ -3909,6 +4012,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Version2\n             ____result.MyProperty2 = __MyProperty2__;\n             ____result.MyProperty3 = __MyProperty3__;\n             ____result.MyProperty5 = __MyProperty5__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -3939,6 +4043,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.VersionBl\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __MyProperty__ = default(int);\n@@ -3970,6 +4075,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.VersionBl\n             ____result.MyProperty = __MyProperty__;\n             ____result.UnknownBlock = __UnknownBlock__;\n             ____result.MyProperty2 = __MyProperty2__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -4005,6 +4111,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Versionin\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __FV__ = default(int);\n@@ -4026,6 +4133,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.Versionin\n \n             var ____result = new global::SharedData.VersioningUnion();\n             ____result.FV = __FV__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }\n@@ -4055,6 +4163,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.WithIndex\n                 return null;\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n             var length = reader.ReadArrayHeader();\n             var __Data1__ = default(int);\n@@ -4081,6 +4190,7 @@ public void Serialize(ref MessagePackWriter writer, global::SharedData.WithIndex\n             var ____result = new global::SharedData.WithIndexer();\n             ____result.Data1 = __Data1__;\n             ____result.Data2 = __Data2__;\n+            reader.Depth--;\n             return ____result;\n         }\n     }"
        },
        {
          "filename": "src/MessagePack.GeneratorCore/Generator/FormatterTemplate.cs",
          "status": "modified",
          "additions": 7,
          "deletions": 7,
          "patch": "@@ -1,10 +1,10 @@\n \ufeff// ------------------------------------------------------------------------------\n // <auto-generated>\n-//     \u3053\u306e\u30b3\u30fc\u30c9\u306f\u30c4\u30fc\u30eb\u306b\u3088\u3063\u3066\u751f\u6210\u3055\u308c\u307e\u3057\u305f\u3002\n-//     \u30e9\u30f3\u30bf\u30a4\u30e0 \u30d0\u30fc\u30b8\u30e7\u30f3: 16.0.0.0\n+//     This code was generated by a tool.\n+//     Runtime Version: 16.0.0.0\n //  \n-//     \u3053\u306e\u30d5\u30a1\u30a4\u30eb\u3078\u306e\u5909\u66f4\u306f\u3001\u6b63\u3057\u304f\u306a\u3044\u52d5\u4f5c\u306e\u539f\u56e0\u306b\u306a\u308b\u53ef\u80fd\u6027\u304c\u3042\u308a\u3001\n-//     \u30b3\u30fc\u30c9\u304c\u518d\u751f\u6210\u3055\u308c\u308b\u3068\u5931\u308f\u308c\u307e\u3059\u3002\n+//     Changes to this file may cause incorrect behavior and will be lost if\n+//     the code is regenerated.\n // </auto-generated>\n // ------------------------------------------------------------------------------\n namespace MessagePackCompiler.Generator\n@@ -136,8 +136,8 @@ namespace \");\n             this.Write(\"                throw new InvalidOperationException(\\\"typecode is null, struct not\" +\n                     \" supported\\\");\\r\\n\");\n  } \n-            this.Write(\"            }\\r\\n\\r\\n            IFormatterResolver formatterResolver = options.Resol\" +\n-                    \"ver;\\r\\n\");\n+            this.Write(\"            }\\r\\n\\r\\n            options.Security.DepthStep(ref reader);\\r\\n           \" +\n+                    \" IFormatterResolver formatterResolver = options.Resolver;\\r\\n\");\n  if(objInfo.IsStringKey) { \n             this.Write(\"            var length = reader.ReadMapHeader();\\r\\n\");\n  } else { \n@@ -191,7 +191,7 @@ namespace \");\n  } else if(objInfo.HasIMessagePackSerializationCallbackReceiver) { \n             this.Write(\"            ____result.OnAfterDeserialize();\\r\\n\");\n  } \n-            this.Write(\"            return ____result;\\r\\n        }\\r\\n    }\\r\\n\");\n+            this.Write(\"            reader.Depth--;\\r\\n            return ____result;\\r\\n        }\\r\\n    }\\r\\n\");\n  } \n             this.Write(@\"}\n "
        },
        {
          "filename": "src/MessagePack.GeneratorCore/Generator/FormatterTemplate.tt",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -102,6 +102,7 @@ namespace <#= Namespace #>\n <# } #>\n             }\n \n+            options.Security.DepthStep(ref reader);\n             IFormatterResolver formatterResolver = options.Resolver;\n <# if(objInfo.IsStringKey) { #>\n             var length = reader.ReadMapHeader();\n@@ -148,6 +149,7 @@ namespace <#= Namespace #>\n <# } else if(objInfo.HasIMessagePackSerializationCallbackReceiver) { #>\n             ____result.OnAfterDeserialize();\n <# } #>\n+            reader.Depth--;\n             return ____result;\n         }\n     }"
        },
        {
          "filename": "src/MessagePack.GeneratorCore/Generator/UnionTemplate.cs",
          "status": "modified",
          "additions": 10,
          "deletions": 8,
          "patch": "@@ -1,10 +1,10 @@\n \ufeff// ------------------------------------------------------------------------------\n // <auto-generated>\n-//     \u3053\u306e\u30b3\u30fc\u30c9\u306f\u30c4\u30fc\u30eb\u306b\u3088\u3063\u3066\u751f\u6210\u3055\u308c\u307e\u3057\u305f\u3002\n-//     \u30e9\u30f3\u30bf\u30a4\u30e0 \u30d0\u30fc\u30b8\u30e7\u30f3: 16.0.0.0\n+//     This code was generated by a tool.\n+//     Runtime Version: 16.0.0.0\n //  \n-//     \u3053\u306e\u30d5\u30a1\u30a4\u30eb\u3078\u306e\u5909\u66f4\u306f\u3001\u6b63\u3057\u304f\u306a\u3044\u52d5\u4f5c\u306e\u539f\u56e0\u306b\u306a\u308b\u53ef\u80fd\u6027\u304c\u3042\u308a\u3001\n-//     \u30b3\u30fc\u30c9\u304c\u518d\u751f\u6210\u3055\u308c\u308b\u3068\u5931\u308f\u308c\u307e\u3059\u3002\n+//     Changes to this file may cause incorrect behavior and will be lost if\n+//     the code is regenerated.\n // </auto-generated>\n // ------------------------------------------------------------------------------\n namespace MessagePackCompiler.Generator\n@@ -112,9 +112,10 @@ namespace \");\n             {\n                 throw new InvalidOperationException(\"\"Invalid Union data was detected. Type:\");\n             this.Write(this.ToStringHelper.ToStringWithCulture(info.FullName));\n-            this.Write(\"\\\");\\r\\n            }\\r\\n\\r\\n            var key = reader.ReadInt32();\\r\\n\\r\\n            if\" +\n-                    \" (!this.keyToJumpMap.TryGetValue(key, out key))\\r\\n            {\\r\\n                \" +\n-                    \"key = -1;\\r\\n            }\\r\\n\\r\\n            \");\n+            this.Write(\"\\\");\\r\\n            }\\r\\n\\r\\n            options.Security.DepthStep(ref reader);\\r\\n      \" +\n+                    \"      var key = reader.ReadInt32();\\r\\n\\r\\n            if (!this.keyToJumpMap.TryGet\" +\n+                    \"Value(key, out key))\\r\\n            {\\r\\n                key = -1;\\r\\n            }\\r\\n\\r\" +\n+                    \"\\n            \");\n             this.Write(this.ToStringHelper.ToStringWithCulture(info.FullName));\n             this.Write(\" result = null;\\r\\n            switch (key)\\r\\n            {\\r\\n\");\n  for(var i = 0; i < info.SubTypes.Length; i++) { var item = info.SubTypes[i]; \n@@ -127,7 +128,8 @@ namespace \");\n             this.Write(\">().Deserialize(ref reader, options);\\r\\n                    break;\\r\\n\");\n  } \n             this.Write(\"                default:\\r\\n                    reader.Skip();\\r\\n                   \" +\n-                    \" break;\\r\\n            }\\r\\n\\r\\n            return result;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\");\n+                    \" break;\\r\\n            }\\r\\n\\r\\n            reader.Depth--;\\r\\n            return result\" +\n+                    \";\\r\\n        }\\r\\n    }\\r\\n\\r\\n\");\n  } \n             this.Write(@\"\n }"
        },
        {
          "filename": "src/MessagePack.GeneratorCore/Generator/UnionTemplate.tt",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -81,6 +81,7 @@ namespace <#= Namespace #>\n                 throw new InvalidOperationException(\"Invalid Union data was detected. Type:<#= info.FullName #>\");\n             }\n \n+            options.Security.DepthStep(ref reader);\n             var key = reader.ReadInt32();\n \n             if (!this.keyToJumpMap.TryGetValue(key, out key))\n@@ -101,6 +102,7 @@ namespace <#= Namespace #>\n                     break;\n             }\n \n+            reader.Depth--;\n             return result;\n         }\n     }"
        },
        {
          "filename": "src/MessagePack.ImmutableCollection/Formatters.cs",
          "status": "modified",
          "additions": 14,
          "deletions": 6,
          "patch": "@@ -45,9 +45,17 @@ public ImmutableArray<T> Deserialize(ref MessagePackReader reader, MessagePackSe\n                 var len = reader.ReadArrayHeader();\n \n                 ImmutableArray<T>.Builder builder = ImmutableArray.CreateBuilder<T>(len);\n-                for (int i = 0; i < len; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n                 {\n-                    builder.Add(formatter.Deserialize(ref reader, options));\n+                    for (int i = 0; i < len; i++)\n+                    {\n+                        builder.Add(formatter.Deserialize(ref reader, options));\n+                    }\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n                 }\n \n                 return builder.ToImmutable();\n@@ -92,7 +100,7 @@ protected override ImmutableDictionary<TKey, TValue> Complete(ImmutableDictionar\n \n         protected override ImmutableDictionary<TKey, TValue>.Builder Create(int count, MessagePackSerializerOptions options)\n         {\n-            return ImmutableDictionary.CreateBuilder<TKey, TValue>();\n+            return ImmutableDictionary.CreateBuilder<TKey, TValue>(options.Security.GetEqualityComparer<TKey>());\n         }\n \n         protected override ImmutableDictionary<TKey, TValue>.Enumerator GetSourceEnumerator(ImmutableDictionary<TKey, TValue> source)\n@@ -115,7 +123,7 @@ protected override ImmutableHashSet<T> Complete(ImmutableHashSet<T>.Builder inte\n \n         protected override ImmutableHashSet<T>.Builder Create(int count, MessagePackSerializerOptions options)\n         {\n-            return ImmutableHashSet.CreateBuilder<T>();\n+            return ImmutableHashSet.CreateBuilder<T>(options.Security.GetEqualityComparer<T>());\n         }\n \n         protected override ImmutableHashSet<T>.Enumerator GetSourceEnumerator(ImmutableHashSet<T> source)\n@@ -240,7 +248,7 @@ protected override IImmutableDictionary<TKey, TValue> Complete(ImmutableDictiona\n \n         protected override ImmutableDictionary<TKey, TValue>.Builder Create(int count, MessagePackSerializerOptions options)\n         {\n-            return ImmutableDictionary.CreateBuilder<TKey, TValue>();\n+            return ImmutableDictionary.CreateBuilder<TKey, TValue>(options.Security.GetEqualityComparer<TKey>());\n         }\n     }\n \n@@ -258,7 +266,7 @@ protected override IImmutableSet<T> Complete(ImmutableHashSet<T>.Builder interme\n \n         protected override ImmutableHashSet<T>.Builder Create(int count, MessagePackSerializerOptions options)\n         {\n-            return ImmutableHashSet.CreateBuilder<T>();\n+            return ImmutableHashSet.CreateBuilder<T>(options.Security.GetEqualityComparer<T>());\n         }\n     }\n "
        },
        {
          "filename": "src/MessagePack.ReactiveProperty/Formatters.cs",
          "status": "modified",
          "additions": 51,
          "deletions": 19,
          "patch": "@@ -147,9 +147,17 @@ public ReactiveProperty<T> Deserialize(ref MessagePackReader reader, MessagePack\n \n                 IScheduler scheduler = ReactivePropertySchedulerMapper.GetScheduler(schedulerId);\n \n-                T v = options.Resolver.GetFormatterWithVerify<T>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T v = options.Resolver.GetFormatterWithVerify<T>().Deserialize(ref reader, options);\n \n-                return new ReactiveProperty<T>(scheduler, v, mode);\n+                    return new ReactiveProperty<T>(scheduler, v, mode);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -186,14 +194,22 @@ public IReactiveProperty<T> Deserialize(ref MessagePackReader reader, MessagePac\n         {\n             var length = reader.ReadArrayHeader();\n \n-            switch (length)\n+            options.Security.DepthStep(ref reader);\n+            try\n             {\n-                case 2:\n-                    return ReactivePropertyResolver.Instance.GetFormatterWithVerify<ReactivePropertySlim<T>>().Deserialize(ref reader, options);\n-                case 3:\n-                    return ReactivePropertyResolver.Instance.GetFormatterWithVerify<ReactiveProperty<T>>().Deserialize(ref reader, options);\n-                default:\n-                    throw new InvalidOperationException(\"Invalid ReactiveProperty or ReactivePropertySlim data.\");\n+                switch (length)\n+                {\n+                    case 2:\n+                        return ReactivePropertyResolver.Instance.GetFormatterWithVerify<ReactivePropertySlim<T>>().Deserialize(ref reader, options);\n+                    case 3:\n+                        return ReactivePropertyResolver.Instance.GetFormatterWithVerify<ReactiveProperty<T>>().Deserialize(ref reader, options);\n+                    default:\n+                        throw new InvalidOperationException(\"Invalid ReactiveProperty or ReactivePropertySlim data.\");\n+                }\n+            }\n+            finally\n+            {\n+                reader.Depth--;\n             }\n         }\n     }\n@@ -230,14 +246,22 @@ public IReadOnlyReactiveProperty<T> Deserialize(ref MessagePackReader reader, Me\n         {\n             var length = reader.ReadArrayHeader();\n \n-            switch (length)\n+            options.Security.DepthStep(ref reader);\n+            try\n             {\n-                case 2:\n-                    return ReactivePropertyResolver.Instance.GetFormatterWithVerify<ReactivePropertySlim<T>>().Deserialize(ref reader, options);\n-                case 3:\n-                    return ReactivePropertyResolver.Instance.GetFormatterWithVerify<ReactiveProperty<T>>().Deserialize(ref reader, options);\n-                default:\n-                    throw new InvalidOperationException(\"Invalid ReactiveProperty or ReactivePropertySlim data.\");\n+                switch (length)\n+                {\n+                    case 2:\n+                        return ReactivePropertyResolver.Instance.GetFormatterWithVerify<ReactivePropertySlim<T>>().Deserialize(ref reader, options);\n+                    case 3:\n+                        return ReactivePropertyResolver.Instance.GetFormatterWithVerify<ReactiveProperty<T>>().Deserialize(ref reader, options);\n+                    default:\n+                        throw new InvalidOperationException(\"Invalid ReactiveProperty or ReactivePropertySlim data.\");\n+                }\n+            }\n+            finally\n+            {\n+                reader.Depth--;\n             }\n         }\n     }\n@@ -339,11 +363,19 @@ public ReactivePropertySlim<T> Deserialize(ref MessagePackReader reader, Message\n                     throw new InvalidOperationException(\"Invalid ReactivePropertySlim data.\");\n                 }\n \n-                var mode = (ReactivePropertyMode)reader.ReadInt32();\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    var mode = (ReactivePropertyMode)reader.ReadInt32();\n \n-                T v = options.Resolver.GetFormatterWithVerify<T>().Deserialize(ref reader, options);\n+                    T v = options.Resolver.GetFormatterWithVerify<T>().Deserialize(ref reader, options);\n \n-                return new ReactivePropertySlim<T>(v, mode);\n+                    return new ReactivePropertySlim<T>(v, mode);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/MessagePack/BitOperations.cs",
          "status": "added",
          "additions": 36,
          "deletions": 0,
          "patch": "@@ -0,0 +1,36 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+// See the LICENSE file in the project root for more information.\n+// <auto-generated />\n+\n+#if !NETCOREAPP\n+\n+using System.Runtime.CompilerServices;\n+\n+// Some routines inspired by the Stanford Bit Twiddling Hacks by Sean Eron Anderson:\n+// http://graphics.stanford.edu/~seander/bithacks.html\n+\n+namespace System.Numerics\n+{\n+    /// <summary>\n+    /// Utility methods for intrinsic bit-twiddling operations.\n+    /// The methods use hardware intrinsics when available on the underlying platform,\n+    /// otherwise they use optimized software fallbacks.\n+    /// </summary>\n+    internal static class BitOperations\n+    {\n+        /// <summary>\n+        /// Rotates the specified value left by the specified number of bits.\n+        /// Similar in behavior to the x86 instruction ROL.\n+        /// </summary>\n+        /// <param name=\"value\">The value to rotate.</param>\n+        /// <param name=\"offset\">The number of bits to rotate by.\n+        /// Any value outside the range [0..31] is treated as congruent mod 32.</param>\n+        /// <returns>The rotated value.</returns>\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        public static uint RotateLeft(uint value, int offset)\n+            => (value << offset) | (value >> (32 - offset));\n+   }\n+}\n+\n+#endif"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/MessagePack/Formatters/CollectionFormatter.cs",
          "status": "modified",
          "additions": 96,
          "deletions": 32,
          "patch": "@@ -49,10 +49,18 @@ public T[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOption\n \n                 var len = reader.ReadArrayHeader();\n                 var array = new T[len];\n-                for (int i = 0; i < array.Length; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n                 {\n-                    reader.CancellationToken.ThrowIfCancellationRequested();\n-                    array[i] = formatter.Deserialize(ref reader, options);\n+                    for (int i = 0; i < array.Length; i++)\n+                    {\n+                        reader.CancellationToken.ThrowIfCancellationRequested();\n+                        array[i] = formatter.Deserialize(ref reader, options);\n+                    }\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n                 }\n \n                 return array;\n@@ -160,10 +168,18 @@ public List<T> Deserialize(ref MessagePackReader reader, MessagePackSerializerOp\n \n                 var len = reader.ReadArrayHeader();\n                 var list = new List<T>((int)len);\n-                for (int i = 0; i < len; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n                 {\n-                    reader.CancellationToken.ThrowIfCancellationRequested();\n-                    list.Add(formatter.Deserialize(ref reader, options));\n+                    for (int i = 0; i < len; i++)\n+                    {\n+                        reader.CancellationToken.ThrowIfCancellationRequested();\n+                        list.Add(formatter.Deserialize(ref reader, options));\n+                    }\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n                 }\n \n                 return list;\n@@ -253,10 +269,18 @@ public TCollection Deserialize(ref MessagePackReader reader, MessagePackSerializ\n                 var len = reader.ReadArrayHeader();\n \n                 TIntermediate list = this.Create(len, options);\n-                for (int i = 0; i < len; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n                 {\n-                    reader.CancellationToken.ThrowIfCancellationRequested();\n-                    this.Add(list, i, formatter.Deserialize(ref reader, options), options);\n+                    for (int i = 0; i < len; i++)\n+                    {\n+                        reader.CancellationToken.ThrowIfCancellationRequested();\n+                        this.Add(list, i, formatter.Deserialize(ref reader, options), options);\n+                    }\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n                 }\n \n                 return this.Complete(list);\n@@ -426,7 +450,7 @@ protected override HashSet<T> Complete(HashSet<T> intermediateCollection)\n \n         protected override HashSet<T> Create(int count, MessagePackSerializerOptions options)\n         {\n-            return new HashSet<T>();\n+            return new HashSet<T>(options.Security.GetEqualityComparer<T>());\n         }\n \n         protected override HashSet<T>.Enumerator GetSourceEnumerator(HashSet<T> source)\n@@ -577,9 +601,17 @@ public IGrouping<TKey, TElement> Deserialize(ref MessagePackReader reader, Messa\n                     throw new MessagePackSerializationException(\"Invalid Grouping format.\");\n                 }\n \n-                TKey key = options.Resolver.GetFormatterWithVerify<TKey>().Deserialize(ref reader, options);\n-                IEnumerable<TElement> value = options.Resolver.GetFormatterWithVerify<IEnumerable<TElement>>().Deserialize(ref reader, options);\n-                return new Grouping<TKey, TElement>(key, value);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    TKey key = options.Resolver.GetFormatterWithVerify<TKey>().Deserialize(ref reader, options);\n+                    IEnumerable<TElement> value = options.Resolver.GetFormatterWithVerify<IEnumerable<TElement>>().Deserialize(ref reader, options);\n+                    return new Grouping<TKey, TElement>(key, value);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -708,10 +740,18 @@ public T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions\n             var count = reader.ReadArrayHeader();\n \n             var list = new T();\n-            for (int i = 0; i < count; i++)\n+            options.Security.DepthStep(ref reader);\n+            try\n             {\n-                reader.CancellationToken.ThrowIfCancellationRequested();\n-                list.Add(formatter.Deserialize(ref reader, options));\n+                for (int i = 0; i < count; i++)\n+                {\n+                    reader.CancellationToken.ThrowIfCancellationRequested();\n+                    list.Add(formatter.Deserialize(ref reader, options));\n+                }\n+            }\n+            finally\n+            {\n+                reader.Depth--;\n             }\n \n             return list;\n@@ -756,10 +796,18 @@ public IList Deserialize(ref MessagePackReader reader, MessagePackSerializerOpti\n             var count = reader.ReadArrayHeader();\n \n             var list = new object[count];\n-            for (int i = 0; i < count; i++)\n+            options.Security.DepthStep(ref reader);\n+            try\n+            {\n+                for (int i = 0; i < count; i++)\n+                {\n+                    reader.CancellationToken.ThrowIfCancellationRequested();\n+                    list[i] = formatter.Deserialize(ref reader, options);\n+                }\n+            }\n+            finally\n             {\n-                reader.CancellationToken.ThrowIfCancellationRequested();\n-                list[i] = formatter.Deserialize(ref reader, options);\n+                reader.Depth--;\n             }\n \n             return list;\n@@ -799,13 +847,21 @@ public T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions\n \n             var count = reader.ReadMapHeader();\n \n-            var dict = new T();\n-            for (int i = 0; i < count; i++)\n+            var dict = CollectionHelpers<T, IEqualityComparer>.CreateHashCollection(count, options.Security.GetEqualityComparer());\n+            options.Security.DepthStep(ref reader);\n+            try\n             {\n-                reader.CancellationToken.ThrowIfCancellationRequested();\n-                var key = formatter.Deserialize(ref reader, options);\n-                var value = formatter.Deserialize(ref reader, options);\n-                dict.Add(key, value);\n+                for (int i = 0; i < count; i++)\n+                {\n+                    reader.CancellationToken.ThrowIfCancellationRequested();\n+                    var key = formatter.Deserialize(ref reader, options);\n+                    var value = formatter.Deserialize(ref reader, options);\n+                    dict.Add(key, value);\n+                }\n+            }\n+            finally\n+            {\n+                reader.Depth--;\n             }\n \n             return dict;\n@@ -850,13 +906,21 @@ public IDictionary Deserialize(ref MessagePackReader reader, MessagePackSerializ\n \n             var count = reader.ReadMapHeader();\n \n-            var dict = new Dictionary<object, object>(count);\n-            for (int i = 0; i < count; i++)\n+            var dict = new Dictionary<object, object>(count, options.Security.GetEqualityComparer<object>());\n+            options.Security.DepthStep(ref reader);\n+            try\n+            {\n+                for (int i = 0; i < count; i++)\n+                {\n+                    reader.CancellationToken.ThrowIfCancellationRequested();\n+                    var key = formatter.Deserialize(ref reader, options);\n+                    var value = formatter.Deserialize(ref reader, options);\n+                    dict.Add(key, value);\n+                }\n+            }\n+            finally\n             {\n-                reader.CancellationToken.ThrowIfCancellationRequested();\n-                var key = formatter.Deserialize(ref reader, options);\n-                var value = formatter.Deserialize(ref reader, options);\n-                dict.Add(key, value);\n+                reader.Depth--;\n             }\n \n             return dict;\n@@ -944,7 +1008,7 @@ protected override ISet<T> Complete(HashSet<T> intermediateCollection)\n \n         protected override HashSet<T> Create(int count, MessagePackSerializerOptions options)\n         {\n-            return new HashSet<T>();\n+            return new HashSet<T>(options.Security.GetEqualityComparer<T>());\n         }\n     }\n "
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/MessagePack/Formatters/CollectionHelpers`2.cs",
          "status": "added",
          "additions": 52,
          "deletions": 0,
          "patch": "@@ -0,0 +1,52 @@\n+// Copyright (c) All contributors. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Linq.Expressions;\n+\n+namespace MessagePack.Formatters\n+{\n+    /// <summary>\n+    /// Provides general helpers for creating collections (including dictionaries).\n+    /// </summary>\n+    /// <typeparam name=\"TCollection\">The concrete type of collection to create.</typeparam>\n+    /// <typeparam name=\"TEqualityComparer\">The type of equality comparer that we would hope to pass into the collection's constructor.</typeparam>\n+    internal static class CollectionHelpers<TCollection, TEqualityComparer>\n+        where TCollection : new()\n+    {\n+        /// <summary>\n+        /// The delegate that will create the collection, if the typical (int count, IEqualityComparer{T} equalityComparer) constructor was found.\n+        /// </summary>\n+        private static Func<int, TEqualityComparer, TCollection> collectionCreator;\n+\n+        /// <summary>\n+        /// Initializes static members of the <see cref=\"CollectionHelpers{TCollection, TEqualityComparer}\"/> class.\n+        /// </summary>\n+        /// <remarks>\n+        /// Initializes a delegate that is optimized to create a collection of a given size and using the given equality comparer, if possible.\n+        /// </remarks>\n+        static CollectionHelpers()\n+        {\n+            var ctor = typeof(TCollection).GetConstructor(new Type[] { typeof(int), typeof(TEqualityComparer) });\n+            if (ctor != null)\n+            {\n+                ParameterExpression param1 = Expression.Parameter(typeof(int), \"count\");\n+                ParameterExpression param2 = Expression.Parameter(typeof(TEqualityComparer), \"equalityComparer\");\n+                NewExpression body = Expression.New(ctor, param1, param2);\n+                collectionCreator = Expression.Lambda<Func<int, TEqualityComparer, TCollection>>(body, param1, param2).Compile();\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Initializes a new instance of the <typeparamref name=\"TCollection\"/> collection.\n+        /// </summary>\n+        /// <param name=\"count\">The number of elements the collection should be prepared to receive.</param>\n+        /// <param name=\"equalityComparer\">The equality comparer to initialize the collection with.</param>\n+        /// <returns>The newly initialized collection.</returns>\n+        /// <remarks>\n+        /// Use of the <paramref name=\"count\"/> and <paramref name=\"equalityComparer\"/> are a best effort.\n+        /// If we can't find a constructor on the collection in the expected shape, we'll just instantiate the collection with its default constructor.\n+        /// </remarks>\n+        internal static TCollection CreateHashCollection(int count, TEqualityComparer equalityComparer) => collectionCreator != null ? collectionCreator.Invoke(count, equalityComparer) : new TCollection();\n+    }\n+}"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/MessagePack/Formatters/DictionaryFormatter.cs",
          "status": "modified",
          "additions": 20,
          "deletions": 11,
          "patch": "@@ -5,6 +5,7 @@\n using System.Collections.Concurrent;\n using System.Collections.Generic;\n using System.Collections.ObjectModel;\n+using System.Reflection;\n \n #pragma warning disable SA1649 // File name should match first type name\n \n@@ -83,14 +84,22 @@ public TDictionary Deserialize(ref MessagePackReader reader, MessagePackSerializ\n                 var len = reader.ReadMapHeader();\n \n                 TIntermediate dict = this.Create(len, options);\n-                for (int i = 0; i < len; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n                 {\n-                    reader.CancellationToken.ThrowIfCancellationRequested();\n-                    TKey key = keyFormatter.Deserialize(ref reader, options);\n+                    for (int i = 0; i < len; i++)\n+                    {\n+                        reader.CancellationToken.ThrowIfCancellationRequested();\n+                        TKey key = keyFormatter.Deserialize(ref reader, options);\n \n-                    TValue value = valueFormatter.Deserialize(ref reader, options);\n+                        TValue value = valueFormatter.Deserialize(ref reader, options);\n \n-                    this.Add(dict, i, key, value, options);\n+                        this.Add(dict, i, key, value, options);\n+                    }\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n                 }\n \n                 return this.Complete(dict);\n@@ -142,7 +151,7 @@ protected override Dictionary<TKey, TValue> Complete(Dictionary<TKey, TValue> in\n \n         protected override Dictionary<TKey, TValue> Create(int count, MessagePackSerializerOptions options)\n         {\n-            return new Dictionary<TKey, TValue>(count);\n+            return new Dictionary<TKey, TValue>(count, options.Security.GetEqualityComparer<TKey>());\n         }\n \n         protected override Dictionary<TKey, TValue>.Enumerator GetSourceEnumerator(Dictionary<TKey, TValue> source)\n@@ -161,7 +170,7 @@ protected override void Add(TDictionary collection, int index, TKey key, TValue\n \n         protected override TDictionary Create(int count, MessagePackSerializerOptions options)\n         {\n-            return new TDictionary();\n+            return CollectionHelpers<TDictionary, IEqualityComparer<TKey>>.CreateHashCollection(count, options.Security.GetEqualityComparer<TKey>());\n         }\n     }\n \n@@ -174,7 +183,7 @@ protected override void Add(Dictionary<TKey, TValue> collection, int index, TKey\n \n         protected override Dictionary<TKey, TValue> Create(int count, MessagePackSerializerOptions options)\n         {\n-            return new Dictionary<TKey, TValue>(count);\n+            return new Dictionary<TKey, TValue>(count, options.Security.GetEqualityComparer<TKey>());\n         }\n \n         protected override IDictionary<TKey, TValue> Complete(Dictionary<TKey, TValue> intermediateCollection)\n@@ -233,7 +242,7 @@ protected override ReadOnlyDictionary<TKey, TValue> Complete(Dictionary<TKey, TV\n \n         protected override Dictionary<TKey, TValue> Create(int count, MessagePackSerializerOptions options)\n         {\n-            return new Dictionary<TKey, TValue>(count);\n+            return new Dictionary<TKey, TValue>(count, options.Security.GetEqualityComparer<TKey>());\n         }\n     }\n \n@@ -251,7 +260,7 @@ protected override IReadOnlyDictionary<TKey, TValue> Complete(Dictionary<TKey, T\n \n         protected override Dictionary<TKey, TValue> Create(int count, MessagePackSerializerOptions options)\n         {\n-            return new Dictionary<TKey, TValue>(count);\n+            return new Dictionary<TKey, TValue>(count, options.Security.GetEqualityComparer<TKey>());\n         }\n     }\n \n@@ -265,7 +274,7 @@ protected override void Add(ConcurrentDictionary<TKey, TValue> collection, int i\n         protected override ConcurrentDictionary<TKey, TValue> Create(int count, MessagePackSerializerOptions options)\n         {\n             // concurrent dictionary can't access defaultConcurrecyLevel so does not use count overload.\n-            return new ConcurrentDictionary<TKey, TValue>();\n+            return new ConcurrentDictionary<TKey, TValue>(options.Security.GetEqualityComparer<TKey>());\n         }\n     }\n }"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/MessagePack/Formatters/MultiDimensionalArrayFormatter.cs",
          "status": "modified",
          "additions": 76,
          "deletions": 52,
          "patch": "@@ -66,20 +66,28 @@ public void Serialize(ref MessagePackWriter writer, T[,] value, MessagePackSeria\n \n                 var i = 0;\n                 var j = -1;\n-                for (int loop = 0; loop < maxLen; loop++)\n+                options.Security.DepthStep(ref reader);\n+                try\n                 {\n-                    reader.CancellationToken.ThrowIfCancellationRequested();\n-                    if (j < jLength - 1)\n+                    for (int loop = 0; loop < maxLen; loop++)\n                     {\n-                        j++;\n+                        reader.CancellationToken.ThrowIfCancellationRequested();\n+                        if (j < jLength - 1)\n+                        {\n+                            j++;\n+                        }\n+                        else\n+                        {\n+                            j = 0;\n+                            i++;\n+                        }\n+\n+                        array[i, j] = formatter.Deserialize(ref reader, options);\n                     }\n-                    else\n-                    {\n-                        j = 0;\n-                        i++;\n-                    }\n-\n-                    array[i, j] = formatter.Deserialize(ref reader, options);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n                 }\n \n                 return array;\n@@ -145,26 +153,34 @@ public void Serialize(ref MessagePackWriter writer, T[,,] value, MessagePackSeri\n                 var i = 0;\n                 var j = 0;\n                 var k = -1;\n-                for (int loop = 0; loop < maxLen; loop++)\n+                options.Security.DepthStep(ref reader);\n+                try\n                 {\n-                    reader.CancellationToken.ThrowIfCancellationRequested();\n-                    if (k < kLength - 1)\n+                    for (int loop = 0; loop < maxLen; loop++)\n                     {\n-                        k++;\n+                        reader.CancellationToken.ThrowIfCancellationRequested();\n+                        if (k < kLength - 1)\n+                        {\n+                            k++;\n+                        }\n+                        else if (j < jLength - 1)\n+                        {\n+                            k = 0;\n+                            j++;\n+                        }\n+                        else\n+                        {\n+                            k = 0;\n+                            j = 0;\n+                            i++;\n+                        }\n+\n+                        array[i, j, k] = formatter.Deserialize(ref reader, options);\n                     }\n-                    else if (j < jLength - 1)\n-                    {\n-                        k = 0;\n-                        j++;\n-                    }\n-                    else\n-                    {\n-                        k = 0;\n-                        j = 0;\n-                        i++;\n-                    }\n-\n-                    array[i, j, k] = formatter.Deserialize(ref reader, options);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n                 }\n \n                 return array;\n@@ -233,33 +249,41 @@ public void Serialize(ref MessagePackWriter writer, T[,,,] value, MessagePackSer\n                 var j = 0;\n                 var k = 0;\n                 var l = -1;\n-                for (int loop = 0; loop < maxLen; loop++)\n+                options.Security.DepthStep(ref reader);\n+                try\n                 {\n-                    reader.CancellationToken.ThrowIfCancellationRequested();\n-                    if (l < lLength - 1)\n-                    {\n-                        l++;\n-                    }\n-                    else if (k < kLength - 1)\n-                    {\n-                        l = 0;\n-                        k++;\n-                    }\n-                    else if (j < jLength - 1)\n+                    for (int loop = 0; loop < maxLen; loop++)\n                     {\n-                        l = 0;\n-                        k = 0;\n-                        j++;\n+                        reader.CancellationToken.ThrowIfCancellationRequested();\n+                        if (l < lLength - 1)\n+                        {\n+                            l++;\n+                        }\n+                        else if (k < kLength - 1)\n+                        {\n+                            l = 0;\n+                            k++;\n+                        }\n+                        else if (j < jLength - 1)\n+                        {\n+                            l = 0;\n+                            k = 0;\n+                            j++;\n+                        }\n+                        else\n+                        {\n+                            l = 0;\n+                            k = 0;\n+                            j = 0;\n+                            i++;\n+                        }\n+\n+                        array[i, j, k, l] = formatter.Deserialize(ref reader, options);\n                     }\n-                    else\n-                    {\n-                        l = 0;\n-                        k = 0;\n-                        j = 0;\n-                        i++;\n-                    }\n-\n-                    array[i, j, k, l] = formatter.Deserialize(ref reader, options);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n                 }\n \n                 return array;"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/MessagePack/Formatters/PrimitiveObjectFormatter.cs",
          "status": "modified",
          "additions": 24,
          "deletions": 7,
          "patch": "@@ -14,6 +14,7 @@ public sealed class PrimitiveObjectFormatter : IMessagePackFormatter<object>\n \n         private static readonly Dictionary<Type, int> TypeToJumpCode = new Dictionary<Type, int>()\n         {\n+            // When adding types whose size exceeds 32-bits, add support in MessagePackSecurity.GetHashCollisionResistantEqualityComparer<T>()\n             { typeof(Boolean), 0 },\n             { typeof(Char), 1 },\n             { typeof(SByte), 2 },\n@@ -283,9 +284,17 @@ public object Deserialize(ref MessagePackReader reader, MessagePackSerializerOpt\n \n                         IMessagePackFormatter<object> objectFormatter = resolver.GetFormatter<object>();\n                         var array = new object[length];\n-                        for (int i = 0; i < length; i++)\n+                        options.Security.DepthStep(ref reader);\n+                        try\n                         {\n-                            array[i] = objectFormatter.Deserialize(ref reader, options);\n+                            for (int i = 0; i < length; i++)\n+                            {\n+                                array[i] = objectFormatter.Deserialize(ref reader, options);\n+                            }\n+                        }\n+                        finally\n+                        {\n+                            reader.Depth--;\n                         }\n \n                         return array;\n@@ -296,14 +305,22 @@ public object Deserialize(ref MessagePackReader reader, MessagePackSerializerOpt\n                         var length = reader.ReadMapHeader();\n \n                         IMessagePackFormatter<object> objectFormatter = resolver.GetFormatter<object>();\n-                        var hash = new Dictionary<object, object>(length);\n-                        for (int i = 0; i < length; i++)\n+                        var hash = new Dictionary<object, object>(length, options.Security.GetEqualityComparer<object>());\n+                        options.Security.DepthStep(ref reader);\n+                        try\n                         {\n-                            var key = objectFormatter.Deserialize(ref reader, options);\n+                            for (int i = 0; i < length; i++)\n+                            {\n+                                var key = objectFormatter.Deserialize(ref reader, options);\n \n-                            var value = objectFormatter.Deserialize(ref reader, options);\n+                                var value = objectFormatter.Deserialize(ref reader, options);\n \n-                            hash.Add(key, value);\n+                                hash.Add(key, value);\n+                            }\n+                        }\n+                        finally\n+                        {\n+                            reader.Depth--;\n                         }\n \n                         return hash;"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/MessagePack/Formatters/StandardClassLibraryFormatter.cs",
          "status": "modified",
          "additions": 23,
          "deletions": 7,
          "patch": "@@ -368,9 +368,17 @@ public KeyValuePair<TKey, TValue> Deserialize(ref MessagePackReader reader, Mess\n             }\n \n             IFormatterResolver resolver = options.Resolver;\n-            TKey key = resolver.GetFormatterWithVerify<TKey>().Deserialize(ref reader, options);\n-            TValue value = resolver.GetFormatterWithVerify<TValue>().Deserialize(ref reader, options);\n-            return new KeyValuePair<TKey, TValue>(key, value);\n+            options.Security.DepthStep(ref reader);\n+            try\n+            {\n+                TKey key = resolver.GetFormatterWithVerify<TKey>().Deserialize(ref reader, options);\n+                TValue value = resolver.GetFormatterWithVerify<TValue>().Deserialize(ref reader, options);\n+                return new KeyValuePair<TKey, TValue>(key, value);\n+            }\n+            finally\n+            {\n+                reader.Depth--;\n+            }\n         }\n     }\n \n@@ -573,10 +581,18 @@ public Lazy<T> Deserialize(ref MessagePackReader reader, MessagePackSerializerOp\n             }\n             else\n             {\n-                // deserialize immediately(no delay, because capture byte[] causes memory leak)\n-                IFormatterResolver resolver = options.Resolver;\n-                T v = resolver.GetFormatterWithVerify<T>().Deserialize(ref reader, options);\n-                return new Lazy<T>(() => v);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    // deserialize immediately(no delay, because capture byte[] causes memory leak)\n+                    IFormatterResolver resolver = options.Resolver;\n+                    T v = resolver.GetFormatterWithVerify<T>().Deserialize(ref reader, options);\n+                    return new Lazy<T>(() => v);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/MessagePack/HashCode.cs",
          "status": "added",
          "additions": 481,
          "deletions": 0,
          "patch": "@@ -0,0 +1,481 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+// See the LICENSE file in the project root for more information.\n+// <auto-generated />\n+\n+/*\n+\n+The xxHash32 implementation is based on the code published by Yann Collet:\n+https://raw.githubusercontent.com/Cyan4973/xxHash/5c174cfa4e45a42f94082dc0d4539b39696afea1/xxhash.c\n+\n+  xxHash - Fast Hash algorithm\n+  Copyright (C) 2012-2016, Yann Collet\n+\n+  BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)\n+\n+  Redistribution and use in source and binary forms, with or without\n+  modification, are permitted provided that the following conditions are\n+  met:\n+\n+  * Redistributions of source code must retain the above copyright\n+  notice, this list of conditions and the following disclaimer.\n+  * Redistributions in binary form must reproduce the above\n+  copyright notice, this list of conditions and the following disclaimer\n+  in the documentation and/or other materials provided with the\n+  distribution.\n+\n+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+  You can contact the author at :\n+  - xxHash homepage: http://www.xxhash.com\n+  - xxHash source repository : https://github.com/Cyan4973/xxHash\n+\n+*/\n+\n+#if !NETCOREAPP\n+\n+using System.Collections.Generic;\n+using System.ComponentModel;\n+using System.Numerics;\n+using System.Runtime.CompilerServices;\n+using System.Security.Cryptography;\n+\n+namespace System\n+{\n+    // xxHash32 is used for the hash code.\n+    // https://github.com/Cyan4973/xxHash\n+\n+    internal struct HashCode\n+    {\n+        private static readonly uint s_seed = GenerateGlobalSeed();\n+\n+        private const uint Prime1 = 2654435761U;\n+        private const uint Prime2 = 2246822519U;\n+        private const uint Prime3 = 3266489917U;\n+        private const uint Prime4 = 668265263U;\n+        private const uint Prime5 = 374761393U;\n+\n+        private uint _v1, _v2, _v3, _v4;\n+        private uint _queue1, _queue2, _queue3;\n+        private uint _length;\n+\n+        private static uint GenerateGlobalSeed()\n+        {\n+            var bytes = new byte[4];\n+            using (var rng = RandomNumberGenerator.Create())\n+            {\n+                rng.GetBytes(bytes);\n+            }\n+\n+            return BitConverter.ToUInt32(bytes, 0);\n+        }\n+\n+        public static int Combine<T1>(T1 value1)\n+        {\n+            unchecked\n+            {\n+                // Provide a way of diffusing bits from something with a limited\n+                // input hash space. For example, many enums only have a few\n+                // possible hashes, only using the bottom few bits of the code. Some\n+                // collections are built on the assumption that hashes are spread\n+                // over a larger space, so diffusing the bits may help the\n+                // collection work more efficiently.\n+\n+                uint hc1 = (uint)(value1?.GetHashCode() ?? 0);\n+\n+                uint hash = MixEmptyState();\n+                hash += 4;\n+\n+                hash = QueueRound(hash, hc1);\n+\n+                hash = MixFinal(hash);\n+                return (int)hash;\n+            }\n+        }\n+\n+        public static int Combine<T1, T2>(T1 value1, T2 value2)\n+        {\n+            unchecked\n+            {\n+                uint hc1 = (uint)(value1?.GetHashCode() ?? 0);\n+                uint hc2 = (uint)(value2?.GetHashCode() ?? 0);\n+\n+                uint hash = MixEmptyState();\n+                hash += 8;\n+\n+                hash = QueueRound(hash, hc1);\n+                hash = QueueRound(hash, hc2);\n+\n+                hash = MixFinal(hash);\n+                return (int)hash;\n+            }\n+        }\n+\n+        public static int Combine<T1, T2, T3>(T1 value1, T2 value2, T3 value3)\n+        {\n+            unchecked\n+            {\n+                uint hc1 = (uint)(value1?.GetHashCode() ?? 0);\n+                uint hc2 = (uint)(value2?.GetHashCode() ?? 0);\n+                uint hc3 = (uint)(value3?.GetHashCode() ?? 0);\n+\n+                uint hash = MixEmptyState();\n+                hash += 12;\n+\n+                hash = QueueRound(hash, hc1);\n+                hash = QueueRound(hash, hc2);\n+                hash = QueueRound(hash, hc3);\n+\n+                hash = MixFinal(hash);\n+                return (int)hash;\n+            }\n+        }\n+\n+        public static int Combine<T1, T2, T3, T4>(T1 value1, T2 value2, T3 value3, T4 value4)\n+        {\n+            unchecked\n+            {\n+                uint hc1 = (uint)(value1?.GetHashCode() ?? 0);\n+                uint hc2 = (uint)(value2?.GetHashCode() ?? 0);\n+                uint hc3 = (uint)(value3?.GetHashCode() ?? 0);\n+                uint hc4 = (uint)(value4?.GetHashCode() ?? 0);\n+\n+                Initialize(out uint v1, out uint v2, out uint v3, out uint v4);\n+\n+                v1 = Round(v1, hc1);\n+                v2 = Round(v2, hc2);\n+                v3 = Round(v3, hc3);\n+                v4 = Round(v4, hc4);\n+\n+                uint hash = MixState(v1, v2, v3, v4);\n+                hash += 16;\n+\n+                hash = MixFinal(hash);\n+                return (int)hash;\n+            }\n+        }\n+\n+        public static int Combine<T1, T2, T3, T4, T5>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5)\n+        {\n+            unchecked\n+            {\n+                uint hc1 = (uint)(value1?.GetHashCode() ?? 0);\n+                uint hc2 = (uint)(value2?.GetHashCode() ?? 0);\n+                uint hc3 = (uint)(value3?.GetHashCode() ?? 0);\n+                uint hc4 = (uint)(value4?.GetHashCode() ?? 0);\n+                uint hc5 = (uint)(value5?.GetHashCode() ?? 0);\n+\n+                Initialize(out uint v1, out uint v2, out uint v3, out uint v4);\n+\n+                v1 = Round(v1, hc1);\n+                v2 = Round(v2, hc2);\n+                v3 = Round(v3, hc3);\n+                v4 = Round(v4, hc4);\n+\n+                uint hash = MixState(v1, v2, v3, v4);\n+                hash += 20;\n+\n+                hash = QueueRound(hash, hc5);\n+\n+                hash = MixFinal(hash);\n+                return (int)hash;\n+            }\n+        }\n+\n+        public static int Combine<T1, T2, T3, T4, T5, T6>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6)\n+        {\n+            unchecked\n+            {\n+                uint hc1 = (uint)(value1?.GetHashCode() ?? 0);\n+                uint hc2 = (uint)(value2?.GetHashCode() ?? 0);\n+                uint hc3 = (uint)(value3?.GetHashCode() ?? 0);\n+                uint hc4 = (uint)(value4?.GetHashCode() ?? 0);\n+                uint hc5 = (uint)(value5?.GetHashCode() ?? 0);\n+                uint hc6 = (uint)(value6?.GetHashCode() ?? 0);\n+\n+                Initialize(out uint v1, out uint v2, out uint v3, out uint v4);\n+\n+                v1 = Round(v1, hc1);\n+                v2 = Round(v2, hc2);\n+                v3 = Round(v3, hc3);\n+                v4 = Round(v4, hc4);\n+\n+                uint hash = MixState(v1, v2, v3, v4);\n+                hash += 24;\n+\n+                hash = QueueRound(hash, hc5);\n+                hash = QueueRound(hash, hc6);\n+\n+                hash = MixFinal(hash);\n+                return (int)hash;\n+            }\n+        }\n+\n+        public static int Combine<T1, T2, T3, T4, T5, T6, T7>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7)\n+        {\n+            unchecked\n+            {\n+                uint hc1 = (uint)(value1?.GetHashCode() ?? 0);\n+                uint hc2 = (uint)(value2?.GetHashCode() ?? 0);\n+                uint hc3 = (uint)(value3?.GetHashCode() ?? 0);\n+                uint hc4 = (uint)(value4?.GetHashCode() ?? 0);\n+                uint hc5 = (uint)(value5?.GetHashCode() ?? 0);\n+                uint hc6 = (uint)(value6?.GetHashCode() ?? 0);\n+                uint hc7 = (uint)(value7?.GetHashCode() ?? 0);\n+\n+                Initialize(out uint v1, out uint v2, out uint v3, out uint v4);\n+\n+                v1 = Round(v1, hc1);\n+                v2 = Round(v2, hc2);\n+                v3 = Round(v3, hc3);\n+                v4 = Round(v4, hc4);\n+\n+                uint hash = MixState(v1, v2, v3, v4);\n+                hash += 28;\n+\n+                hash = QueueRound(hash, hc5);\n+                hash = QueueRound(hash, hc6);\n+                hash = QueueRound(hash, hc7);\n+\n+                hash = MixFinal(hash);\n+                return (int)hash;\n+            }\n+        }\n+\n+        public static int Combine<T1, T2, T3, T4, T5, T6, T7, T8>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8)\n+        {\n+            unchecked\n+            {\n+                uint hc1 = (uint)(value1?.GetHashCode() ?? 0);\n+                uint hc2 = (uint)(value2?.GetHashCode() ?? 0);\n+                uint hc3 = (uint)(value3?.GetHashCode() ?? 0);\n+                uint hc4 = (uint)(value4?.GetHashCode() ?? 0);\n+                uint hc5 = (uint)(value5?.GetHashCode() ?? 0);\n+                uint hc6 = (uint)(value6?.GetHashCode() ?? 0);\n+                uint hc7 = (uint)(value7?.GetHashCode() ?? 0);\n+                uint hc8 = (uint)(value8?.GetHashCode() ?? 0);\n+\n+                Initialize(out uint v1, out uint v2, out uint v3, out uint v4);\n+\n+                v1 = Round(v1, hc1);\n+                v2 = Round(v2, hc2);\n+                v3 = Round(v3, hc3);\n+                v4 = Round(v4, hc4);\n+\n+                v1 = Round(v1, hc5);\n+                v2 = Round(v2, hc6);\n+                v3 = Round(v3, hc7);\n+                v4 = Round(v4, hc8);\n+\n+                uint hash = MixState(v1, v2, v3, v4);\n+                hash += 32;\n+\n+                hash = MixFinal(hash);\n+                return (int)hash;\n+            }\n+        }\n+\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        private static void Initialize(out uint v1, out uint v2, out uint v3, out uint v4)\n+        {\n+            unchecked\n+            {\n+                v1 = s_seed + Prime1 + Prime2;\n+                v2 = s_seed + Prime2;\n+                v3 = s_seed;\n+                v4 = s_seed - Prime1;\n+            }\n+        }\n+\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        private static uint Round(uint hash, uint input)\n+        {\n+            unchecked\n+            {\n+                return BitOperations.RotateLeft(hash + input * Prime2, 13) * Prime1;\n+            }\n+        }\n+\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        private static uint QueueRound(uint hash, uint queuedValue)\n+        {\n+            unchecked\n+            {\n+                return BitOperations.RotateLeft(hash + queuedValue * Prime3, 17) * Prime4;\n+            }\n+        }\n+\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        private static uint MixState(uint v1, uint v2, uint v3, uint v4)\n+        {\n+            unchecked\n+            {\n+                return BitOperations.RotateLeft(v1, 1) + BitOperations.RotateLeft(v2, 7) + BitOperations.RotateLeft(v3, 12) + BitOperations.RotateLeft(v4, 18);\n+            }\n+        }\n+\n+        private static uint MixEmptyState()\n+        {\n+            unchecked\n+            {\n+                return s_seed + Prime5;\n+            }\n+        }\n+\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        private static uint MixFinal(uint hash)\n+        {\n+            unchecked\n+            {\n+                hash ^= hash >> 15;\n+                hash *= Prime2;\n+                hash ^= hash >> 13;\n+                hash *= Prime3;\n+                hash ^= hash >> 16;\n+                return hash;\n+            }\n+        }\n+\n+        public void Add<T>(T value)\n+        {\n+            Add(value?.GetHashCode() ?? 0);\n+        }\n+\n+        public void Add<T>(T value, IEqualityComparer<T> comparer)\n+        {\n+            Add(comparer != null ? comparer.GetHashCode(value) : (value?.GetHashCode() ?? 0));\n+        }\n+\n+        private void Add(int value)\n+        {\n+            unchecked\n+            {\n+                // The original xxHash works as follows:\n+                // 0. Initialize immediately. We can't do this in a struct (no\n+                //    default ctor).\n+                // 1. Accumulate blocks of length 16 (4 uints) into 4 accumulators.\n+                // 2. Accumulate remaining blocks of length 4 (1 uint) into the\n+                //    hash.\n+                // 3. Accumulate remaining blocks of length 1 into the hash.\n+\n+                // There is no need for #3 as this type only accepts ints. _queue1,\n+                // _queue2 and _queue3 are basically a buffer so that when\n+                // ToHashCode is called we can execute #2 correctly.\n+\n+                // We need to initialize the xxHash32 state (_v1 to _v4) lazily (see\n+                // #0) nd the last place that can be done if you look at the\n+                // original code is just before the first block of 16 bytes is mixed\n+                // in. The xxHash32 state is never used for streams containing fewer\n+                // than 16 bytes.\n+\n+                // To see what's really going on here, have a look at the Combine\n+                // methods.\n+\n+                uint val = (uint)value;\n+\n+                // Storing the value of _length locally shaves of quite a few bytes\n+                // in the resulting machine code.\n+                uint previousLength = _length++;\n+                uint position = previousLength % 4;\n+\n+                // Switch can't be inlined.\n+\n+                if (position == 0)\n+                    _queue1 = val;\n+                else if (position == 1)\n+                    _queue2 = val;\n+                else if (position == 2)\n+                    _queue3 = val;\n+                else // position == 3\n+                {\n+                    if (previousLength == 3)\n+                        Initialize(out _v1, out _v2, out _v3, out _v4);\n+\n+                    _v1 = Round(_v1, _queue1);\n+                    _v2 = Round(_v2, _queue2);\n+                    _v3 = Round(_v3, _queue3);\n+                    _v4 = Round(_v4, val);\n+                }\n+            }\n+        }\n+\n+        public int ToHashCode()\n+        {\n+            unchecked\n+            {\n+                // Storing the value of _length locally shaves of quite a few bytes\n+                // in the resulting machine code.\n+                uint length = _length;\n+\n+                // position refers to the *next* queue position in this method, so\n+                // position == 1 means that _queue1 is populated; _queue2 would have\n+                // been populated on the next call to Add.\n+                uint position = length % 4;\n+\n+                // If the length is less than 4, _v1 to _v4 don't contain anything\n+                // yet. xxHash32 treats this differently.\n+\n+                uint hash = length < 4 ? MixEmptyState() : MixState(_v1, _v2, _v3, _v4);\n+\n+                // _length is incremented once per Add(Int32) and is therefore 4\n+                // times too small (xxHash length is in bytes, not ints).\n+\n+                hash += length * 4;\n+\n+                // Mix what remains in the queue\n+\n+                // Switch can't be inlined right now, so use as few branches as\n+                // possible by manually excluding impossible scenarios (position > 1\n+                // is always false if position is not > 0).\n+                if (position > 0)\n+                {\n+                    hash = QueueRound(hash, _queue1);\n+                    if (position > 1)\n+                    {\n+                        hash = QueueRound(hash, _queue2);\n+                        if (position > 2)\n+                            hash = QueueRound(hash, _queue3);\n+                    }\n+                }\n+\n+                hash = MixFinal(hash);\n+                return (int)hash;\n+            }\n+        }\n+\n+#pragma warning disable 0809\n+        // Obsolete member 'memberA' overrides non-obsolete member 'memberB'.\n+        // Disallowing GetHashCode and Equals is by design\n+\n+        // * We decided to not override GetHashCode() to produce the hash code\n+        //   as this would be weird, both naming-wise as well as from a\n+        //   behavioral standpoint (GetHashCode() should return the object's\n+        //   hash code, not the one being computed).\n+\n+        // * Even though ToHashCode() can be called safely multiple times on\n+        //   this implementation, it is not part of the contract. If the\n+        //   implementation has to change in the future we don't want to worry\n+        //   about people who might have incorrectly used this type.\n+\n+        [Obsolete(\"HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.\", error: true)]\n+        [EditorBrowsable(EditorBrowsableState.Never)]\n+        public override int GetHashCode() => throw new NotSupportedException();\n+\n+        [Obsolete(\"HashCode is a mutable struct and should not be compared with other HashCodes.\", error: true)]\n+        [EditorBrowsable(EditorBrowsableState.Never)]\n+        public override bool Equals(object obj) => throw new NotSupportedException();\n+#pragma warning restore 0809\n+    }\n+}\n+\n+#endif"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/MessagePack/MessagePackReader.cs",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -38,6 +38,7 @@ ref partial struct MessagePackReader\n         public MessagePackReader(ReadOnlyMemory<byte> memory)\n         {\n             this.reader = new SequenceReader<byte>(memory);\n+            this.Depth = 0;\n         }\n \n         /// <summary>\n@@ -47,13 +48,19 @@ public MessagePackReader(ReadOnlyMemory<byte> memory)\n         public MessagePackReader(in ReadOnlySequence<byte> readOnlySequence)\n         {\n             this.reader = new SequenceReader<byte>(readOnlySequence);\n+            this.Depth = 0;\n         }\n \n         /// <summary>\n         /// Gets or sets the cancellation token for this deserialization operation.\n         /// </summary>\n         public CancellationToken CancellationToken { get; set; }\n \n+        /// <summary>\n+        /// Gets or sets the present depth of the object graph being deserialized.\n+        /// </summary>\n+        public int Depth { get; set; }\n+\n         /// <summary>\n         /// Gets the <see cref=\"ReadOnlySequence{T}\"/> originally supplied to the constructor.\n         /// </summary>\n@@ -110,6 +117,7 @@ public byte NextCode\n         public MessagePackReader Clone(in ReadOnlySequence<byte> readOnlySequence) => new MessagePackReader(readOnlySequence)\n         {\n             CancellationToken = this.CancellationToken,\n+            Depth = this.Depth,\n         };\n \n         /// <summary>"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/MessagePack/MessagePackSecurity.cs",
          "status": "added",
          "additions": 399,
          "deletions": 0,
          "patch": "@@ -0,0 +1,399 @@\n+\ufeff// Copyright (c) All contributors. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Reflection;\n+using System.Runtime.ExceptionServices;\n+using MessagePack.Formatters;\n+using MessagePack.Internal;\n+\n+namespace MessagePack\n+{\n+    /// <summary>\n+    /// Settings related to security, particularly relevant when deserializing data from untrusted sources.\n+    /// </summary>\n+    public class MessagePackSecurity\n+    {\n+        /// <summary>\n+        /// Gets an instance preconfigured with settings that omit all protections. Useful for deserializing fully-trusted and valid msgpack sequences.\n+        /// </summary>\n+        public static readonly MessagePackSecurity TrustedData = new MessagePackSecurity();\n+\n+        /// <summary>\n+        /// Gets an instance preconfigured with protections applied with reasonable settings for deserializing untrusted msgpack sequences.\n+        /// </summary>\n+        public static readonly MessagePackSecurity UntrustedData = new MessagePackSecurity\n+        {\n+            HashCollisionResistant = true,\n+            MaximumObjectGraphDepth = 500,\n+        };\n+\n+        private readonly ObjectFallbackEqualityComparer objectFallbackEqualityComparer;\n+\n+        private MessagePackSecurity()\n+        {\n+            this.objectFallbackEqualityComparer = new ObjectFallbackEqualityComparer(this);\n+        }\n+\n+        /// <summary>\n+        /// Initializes a new instance of the <see cref=\"MessagePackSecurity\"/> class\n+        /// with properties copied from a provided template.\n+        /// </summary>\n+        /// <param name=\"copyFrom\">The template to copy from.</param>\n+        protected MessagePackSecurity(MessagePackSecurity copyFrom)\n+        {\n+            if (copyFrom is null)\n+            {\n+                throw new ArgumentNullException(nameof(copyFrom));\n+            }\n+\n+            this.HashCollisionResistant = copyFrom.HashCollisionResistant;\n+            this.MaximumObjectGraphDepth = copyFrom.MaximumObjectGraphDepth;\n+        }\n+\n+        /// <summary>\n+        /// Gets a value indicating whether data to be deserialized is untrusted and thus should not be allowed to create\n+        /// dictionaries or other hash-based collections unless the hashed type has a hash collision resistant implementation available.\n+        /// This can mitigate some denial of service attacks when deserializing untrusted code.\n+        /// </summary>\n+        /// <value>\n+        /// The value is <c>false</c> for <see cref=\"TrustedData\"/> and <c>true</c> for <see cref=\"UntrustedData\"/>.\n+        /// </value>\n+        public bool HashCollisionResistant { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the maximum depth of an object graph that may be deserialized.\n+        /// </summary>\n+        /// <remarks>\n+        /// <para>\n+        /// This value can be reduced to avoid a stack overflow that would crash the process when deserializing a msgpack sequence designed to cause deep recursion.\n+        /// A very short callstack on a thread with 1MB of total stack space might deserialize ~2000 nested arrays before crashing due to a stack overflow.\n+        /// Since stack space occupied may vary by the kind of object deserialized, a conservative value for this property to defend against stack overflow attacks might be 500.\n+        /// </para>\n+        /// </remarks>\n+        public int MaximumObjectGraphDepth { get; private set; } = int.MaxValue;\n+\n+        /// <summary>\n+        /// Gets a copy of these options with the <see cref=\"MaximumObjectGraphDepth\"/> property set to a new value.\n+        /// </summary>\n+        /// <param name=\"maximumObjectGraphDepth\">The new value for the <see cref=\"MaximumObjectGraphDepth\"/> property.</param>\n+        /// <returns>The new instance; or the original if the value is unchanged.</returns>\n+        public MessagePackSecurity WithMaximumObjectGraphDepth(int maximumObjectGraphDepth)\n+        {\n+            if (this.MaximumObjectGraphDepth == maximumObjectGraphDepth)\n+            {\n+                return this;\n+            }\n+\n+            var clone = this.Clone();\n+            clone.MaximumObjectGraphDepth = maximumObjectGraphDepth;\n+            return clone;\n+        }\n+\n+        /// <summary>\n+        /// Gets a copy of these options with the <see cref=\"HashCollisionResistant\"/> property set to a new value.\n+        /// </summary>\n+        /// <param name=\"hashCollisionResistant\">The new value for the <see cref=\"HashCollisionResistant\"/> property.</param>\n+        /// <returns>The new instance; or the original if the value is unchanged.</returns>\n+        public MessagePackSecurity WithHashCollisionResistant(bool hashCollisionResistant)\n+        {\n+            if (this.HashCollisionResistant == hashCollisionResistant)\n+            {\n+                return this;\n+            }\n+\n+            var clone = this.Clone();\n+            clone.HashCollisionResistant = hashCollisionResistant;\n+            return clone;\n+        }\n+\n+        /// <summary>\n+        /// Gets an <see cref=\"IEqualityComparer{T}\"/> that is suitable to use with a hash-based collection.\n+        /// </summary>\n+        /// <typeparam name=\"T\">The type of key that will be hashed in the collection.</typeparam>\n+        /// <returns>The <see cref=\"IEqualityComparer{T}\"/> to use.</returns>\n+        /// <remarks>\n+        /// When <see cref=\"HashCollisionResistant\"/> is active, this will be a collision resistant instance which may reject certain key types.\n+        /// When <see cref=\"HashCollisionResistant\"/> is not active, this will be <see cref=\"EqualityComparer{T}.Default\"/>.\n+        /// </remarks>\n+        public IEqualityComparer<T> GetEqualityComparer<T>()\n+        {\n+            return this.HashCollisionResistant ? GetHashCollisionResistantEqualityComparer<T>() : EqualityComparer<T>.Default;\n+        }\n+\n+        /// <summary>\n+        /// Gets an <see cref=\"IEqualityComparer\"/> that is suitable to use with a hash-based collection.\n+        /// </summary>\n+        /// <returns>The <see cref=\"IEqualityComparer\"/> to use.</returns>\n+        /// <remarks>\n+        /// When <see cref=\"HashCollisionResistant\"/> is active, this will be a collision resistant instance which may reject certain key types.\n+        /// When <see cref=\"HashCollisionResistant\"/> is not active, this will be <see cref=\"EqualityComparer{T}.Default\"/>.\n+        /// </remarks>\n+        public IEqualityComparer GetEqualityComparer()\n+        {\n+            return this.HashCollisionResistant ? GetHashCollisionResistantEqualityComparer() : EqualityComparer<object>.Default;\n+        }\n+\n+        /// <summary>\n+        /// Returns a hash collision resistant equality comparer.\n+        /// </summary>\n+        /// <typeparam name=\"T\">The type of key that will be hashed in the collection.</typeparam>\n+        /// <returns>A hash collision resistant equality comparer.</returns>\n+        protected virtual IEqualityComparer<T> GetHashCollisionResistantEqualityComparer<T>()\n+        {\n+            // For anything 32-bits and under, our fallback base secure hasher is usually adequate since it makes the hash unpredictable.\n+            // We should have special implementations for any value that is larger than 32-bits in order to make sure\n+            // that all the data gets hashed securely rather than trivially and predictably compressed into 32-bits before being hashed.\n+            // We also have to specially handle some 32-bit types (e.g. float) where multiple in-memory representations should hash to the same value.\n+            // Any type supported by the PrimitiveObjectFormatter should be added here if supporting it as a key in a collection makes sense.\n+            return\n+                // 32-bits or smaller:\n+                typeof(T) == typeof(bool) ? CollisionResistantHasher<T>.Instance :\n+                typeof(T) == typeof(char) ? CollisionResistantHasher<T>.Instance :\n+                typeof(T) == typeof(sbyte) ? CollisionResistantHasher<T>.Instance :\n+                typeof(T) == typeof(byte) ? CollisionResistantHasher<T>.Instance :\n+                typeof(T) == typeof(short) ? CollisionResistantHasher<T>.Instance :\n+                typeof(T) == typeof(ushort) ? CollisionResistantHasher<T>.Instance :\n+                typeof(T) == typeof(int) ? CollisionResistantHasher<T>.Instance :\n+                typeof(T) == typeof(uint) ? CollisionResistantHasher<T>.Instance :\n+\n+                // Larger than 32-bits (or otherwise require special handling):\n+                typeof(T) == typeof(long) ? (IEqualityComparer<T>)Int64EqualityComparer.Instance :\n+                typeof(T) == typeof(ulong) ? (IEqualityComparer<T>)UInt64EqualityComparer.Instance :\n+                typeof(T) == typeof(float) ? (IEqualityComparer<T>)SingleEqualityComparer.Instance :\n+                typeof(T) == typeof(double) ? (IEqualityComparer<T>)DoubleEqualityComparer.Instance :\n+                typeof(T) == typeof(string) ? (IEqualityComparer<T>)StringEqualityComparer.Instance :\n+                typeof(T) == typeof(Guid) ? (IEqualityComparer<T>)GuidEqualityComparer.Instance :\n+                typeof(T) == typeof(DateTime) ? (IEqualityComparer<T>)DateTimeEqualityComparer.Instance :\n+                typeof(T) == typeof(DateTimeOffset) ? (IEqualityComparer<T>)DateTimeOffsetEqualityComparer.Instance :\n+                typeof(T) == typeof(object) ? (IEqualityComparer<T>)this.objectFallbackEqualityComparer :\n+\n+                // Any type we don't explicitly whitelist here shouldn't be allowed to use as the key in a hash-based collection since it isn't known to be hash resistant.\n+                // This method can of course be overridden to add more hash collision resistant type support, or the deserializing party can indicate that the data is Trusted\n+                // so that this method doesn't even get called.\n+                throw new TypeAccessException($\"No hash-resistant equality comparer available for type: {typeof(T)}\");\n+        }\n+\n+        /// <summary>\n+        /// Checks the depth of the deserializing graph and increments it by 1.\n+        /// </summary>\n+        /// <param name=\"reader\">The reader that is involved in deserialization.</param>\n+        /// <remarks>\n+        /// Callers should decrement <see cref=\"MessagePackReader.Depth\"/> after exiting that edge in the graph.\n+        /// </remarks>\n+        /// <exception cref=\"InsufficientExecutionStackException\">Thrown if <see cref=\"MessagePackReader.Depth\"/> is already at or exceeds <see cref=\"MaximumObjectGraphDepth\"/>.</exception>\n+        /// <remarks>\n+        /// Rather than wrap the body of every <see cref=\"IMessagePackFormatter{T}.Deserialize\"/> method,\n+        /// this should wrap *calls* to these methods. They need not appear in pure \"thunk\" methods that simply delegate the deserialization to another formatter.\n+        /// In this way, we can avoid repeatedly incrementing and decrementing the counter when deserializing each element of a collection.\n+        /// </remarks>\n+        public void DepthStep(ref MessagePackReader reader)\n+        {\n+            if (reader.Depth >= this.MaximumObjectGraphDepth)\n+            {\n+                throw new InsufficientExecutionStackException($\"This msgpack sequence has an object graph that exceeds the maximum depth allowed of {MaximumObjectGraphDepth}.\");\n+            }\n+\n+            reader.Depth++;\n+        }\n+\n+        /// <summary>\n+        /// Returns a hash collision resistant equality comparer.\n+        /// </summary>\n+        /// <returns>A hash collision resistant equality comparer.</returns>\n+        protected virtual IEqualityComparer GetHashCollisionResistantEqualityComparer() => (IEqualityComparer)this.GetHashCollisionResistantEqualityComparer<object>();\n+\n+        /// <summary>\n+        /// Creates a new instance that is a copy of this one.\n+        /// </summary>\n+        /// <remarks>\n+        /// Derived types should override this method to instantiate their own derived type.\n+        /// </remarks>\n+        protected virtual MessagePackSecurity Clone() => new MessagePackSecurity(this);\n+\n+        /// <summary>\n+        /// A hash collision resistant implementation of <see cref=\"IEqualityComparer{T}\"/>.\n+        /// </summary>\n+        /// <typeparam name=\"T\">The type of key that will be hashed.</typeparam>\n+        private class CollisionResistantHasher<T> : IEqualityComparer<T>, IEqualityComparer\n+        {\n+            internal static readonly CollisionResistantHasher<T> Instance = new CollisionResistantHasher<T>();\n+\n+            public bool Equals(T x, T y) => EqualityComparer<T>.Default.Equals(x, y);\n+\n+            bool IEqualityComparer.Equals(object x, object y) => ((IEqualityComparer)EqualityComparer<T>.Default).Equals(x, y);\n+\n+            public int GetHashCode(object obj) => this.GetHashCode((T)obj);\n+\n+            public virtual int GetHashCode(T value) => HashCode.Combine(value);\n+        }\n+\n+        /// <summary>\n+        /// A special hash-resistent equality comparer that defers picking the actual implementation\n+        /// till it can check the runtime type of each value to be hashed.\n+        /// </summary>\n+        private class ObjectFallbackEqualityComparer : IEqualityComparer<object>, IEqualityComparer\n+        {\n+            private static readonly MethodInfo GetHashCollisionResistantEqualityComparerOpenGenericMethod = typeof(MessagePackSecurity).GetTypeInfo().DeclaredMethods.Single(m => m.Name == nameof(MessagePackSecurity.GetHashCollisionResistantEqualityComparer) && m.IsGenericMethod);\n+            private readonly MessagePackSecurity security;\n+            private readonly ThreadsafeTypeKeyHashTable<IEqualityComparer> equalityComparerCache = new ThreadsafeTypeKeyHashTable<IEqualityComparer>();\n+\n+            internal ObjectFallbackEqualityComparer(MessagePackSecurity security)\n+            {\n+                this.security = security ?? throw new ArgumentNullException(nameof(security));\n+            }\n+\n+            bool IEqualityComparer<object>.Equals(object x, object y) => EqualityComparer<object>.Default.Equals(x, y);\n+\n+            bool IEqualityComparer.Equals(object x, object y) => ((IEqualityComparer)EqualityComparer<object>.Default).Equals(x, y);\n+\n+            public int GetHashCode(object value)\n+            {\n+                if (value is null)\n+                {\n+                    return 0;\n+                }\n+\n+                Type valueType = value.GetType();\n+\n+                // Take care to avoid recursion.\n+                if (valueType == typeof(object))\n+                {\n+                    // We can trust object.GetHashCode() to be collision resistant.\n+                    return value.GetHashCode();\n+                }\n+\n+                if (!equalityComparerCache.TryGetValue(valueType, out IEqualityComparer equalityComparer))\n+                {\n+                    try\n+                    {\n+                        equalityComparer = (IEqualityComparer)GetHashCollisionResistantEqualityComparerOpenGenericMethod.MakeGenericMethod(valueType).Invoke(this.security, Array.Empty<object>());\n+                    }\n+                    catch (TargetInvocationException ex)\n+                    {\n+                        ExceptionDispatchInfo.Capture(ex.InnerException).Throw();\n+                    }\n+\n+                    equalityComparerCache.TryAdd(valueType, equalityComparer);\n+                }\n+\n+                return equalityComparer.GetHashCode(value);\n+            }\n+        }\n+\n+        private class UInt64EqualityComparer : CollisionResistantHasher<ulong>\n+        {\n+            internal static new readonly UInt64EqualityComparer Instance = new UInt64EqualityComparer();\n+\n+            public override int GetHashCode(ulong value) => HashCode.Combine((uint)(value >> 32), unchecked((uint)value));\n+        }\n+\n+        private class Int64EqualityComparer : CollisionResistantHasher<long>\n+        {\n+            internal static new readonly Int64EqualityComparer Instance = new Int64EqualityComparer();\n+\n+            public override int GetHashCode(long value) => HashCode.Combine((int)(value >> 32), unchecked((int)value));\n+        }\n+\n+        private class SingleEqualityComparer : CollisionResistantHasher<float>\n+        {\n+            internal static new readonly SingleEqualityComparer Instance = new SingleEqualityComparer();\n+\n+            public override unsafe int GetHashCode(float value)\n+            {\n+                // Special check for 0.0 so that the hash of 0.0 and -0.0 will equal.\n+                if (value == 0.0f)\n+                {\n+                    return HashCode.Combine(0);\n+                }\n+\n+                // Standardize on the binary representation of NaN prior to hashing.\n+                if (float.IsNaN(value))\n+                {\n+                    value = float.NaN;\n+                }\n+\n+                long l = *(long*)&value;\n+                return HashCode.Combine((int)(l >> 32), unchecked((int)l));\n+            }\n+        }\n+\n+        private class DoubleEqualityComparer : CollisionResistantHasher<double>\n+        {\n+            internal static new readonly DoubleEqualityComparer Instance = new DoubleEqualityComparer();\n+\n+            public override unsafe int GetHashCode(double value)\n+            {\n+                // Special check for 0.0 so that the hash of 0.0 and -0.0 will equal.\n+                if (value == 0.0)\n+                {\n+                    return HashCode.Combine(0);\n+                }\n+\n+                // Standardize on the binary representation of NaN prior to hashing.\n+                if (double.IsNaN(value))\n+                {\n+                    value = double.NaN;\n+                }\n+\n+                long l = *(long*)&value;\n+                return HashCode.Combine((int)(l >> 32), unchecked((int)l));\n+            }\n+        }\n+\n+        private class GuidEqualityComparer : CollisionResistantHasher<Guid>\n+        {\n+            internal static new readonly GuidEqualityComparer Instance = new GuidEqualityComparer();\n+\n+            public override unsafe int GetHashCode(Guid value)\n+            {\n+                var hash = default(HashCode);\n+                int* pGuid = (int*)&value;\n+                for (int i = 0; i < sizeof(Guid) / sizeof(int); i++)\n+                {\n+                    hash.Add(pGuid[i]);\n+                }\n+\n+                return hash.ToHashCode();\n+            }\n+        }\n+\n+        private class StringEqualityComparer : CollisionResistantHasher<string>\n+        {\n+            internal static new readonly StringEqualityComparer Instance = new StringEqualityComparer();\n+\n+            public override int GetHashCode(string value)\n+            {\n+#if NETCOREAPP\n+                // .NET Core already has a secure string hashing function. Just use it.\n+                return value?.GetHashCode() ?? 0;\n+#else\n+                var hash = default(HashCode);\n+                for (int i = 0; i < value.Length; i++)\n+                {\n+                    hash.Add(value[i]);\n+                }\n+\n+                return hash.ToHashCode();\n+#endif\n+            }\n+        }\n+\n+        private class DateTimeEqualityComparer : CollisionResistantHasher<DateTime>\n+        {\n+            internal static new readonly DateTimeEqualityComparer Instance = new DateTimeEqualityComparer();\n+\n+            public override unsafe int GetHashCode(DateTime value) => HashCode.Combine((int)(value.Ticks >> 32), unchecked((int)value.Ticks), value.Kind);\n+        }\n+\n+        private class DateTimeOffsetEqualityComparer : CollisionResistantHasher<DateTimeOffset>\n+        {\n+            internal static new readonly DateTimeOffsetEqualityComparer Instance = new DateTimeOffsetEqualityComparer();\n+\n+            public override unsafe int GetHashCode(DateTimeOffset value) => HashCode.Combine((int)(value.UtcTicks >> 32), unchecked((int)value.UtcTicks));\n+        }\n+    }\n+}"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/MessagePack/MessagePackSerializer.Json.cs",
          "status": "modified",
          "additions": 52,
          "deletions": 35,
          "patch": "@@ -98,17 +98,17 @@ public static void ConvertToJson(ref MessagePackReader reader, TextWriter jsonWr\n                                 return;\n                             }\n \n-                            ToJsonCore(ref scratchReader, jsonWriter);\n+                            ToJsonCore(ref scratchReader, jsonWriter, options);\n                         }\n                         else\n                         {\n-                            ToJsonCore(ref reader, jsonWriter);\n+                            ToJsonCore(ref reader, jsonWriter, options);\n                         }\n                     }\n                 }\n                 else\n                 {\n-                    ToJsonCore(ref reader, jsonWriter);\n+                    ToJsonCore(ref reader, jsonWriter, options);\n                 }\n             }\n             catch (Exception ex)\n@@ -265,7 +265,7 @@ private static uint FromJsonCore(TinyJsonReader jr, ref MessagePackWriter writer\n             return count;\n         }\n \n-        private static void ToJsonCore(ref MessagePackReader reader, TextWriter writer)\n+        private static void ToJsonCore(ref MessagePackReader reader, TextWriter writer, MessagePackSerializerOptions options)\n         {\n             MessagePackType type = reader.NextMessagePackType;\n             switch (type)\n@@ -305,56 +305,73 @@ private static void ToJsonCore(ref MessagePackReader reader, TextWriter writer)\n                 case MessagePackType.Array:\n                     {\n                         int length = reader.ReadArrayHeader();\n-                        writer.Write(\"[\");\n-                        for (int i = 0; i < length; i++)\n+                        options.Security.DepthStep(ref reader);\n+                        try\n                         {\n-                            ToJsonCore(ref reader, writer);\n-\n-                            if (i != length - 1)\n+                            writer.Write(\"[\");\n+                            for (int i = 0; i < length; i++)\n                             {\n-                                writer.Write(\",\");\n+                                ToJsonCore(ref reader, writer, options);\n+\n+                                if (i != length - 1)\n+                                {\n+                                    writer.Write(\",\");\n+                                }\n                             }\n+\n+                            writer.Write(\"]\");\n+                        }\n+                        finally\n+                        {\n+                            reader.Depth--;\n                         }\n \n-                        writer.Write(\"]\");\n                         return;\n                     }\n \n                 case MessagePackType.Map:\n                     {\n                         int length = reader.ReadMapHeader();\n-                        writer.Write(\"{\");\n-                        for (int i = 0; i < length; i++)\n+                        options.Security.DepthStep(ref reader);\n+                        try\n                         {\n-                            // write key\n+                            writer.Write(\"{\");\n+                            for (int i = 0; i < length; i++)\n                             {\n-                                MessagePackType keyType = reader.NextMessagePackType;\n-                                if (keyType == MessagePackType.String || keyType == MessagePackType.Binary)\n+                                // write key\n                                 {\n-                                    ToJsonCore(ref reader, writer);\n+                                    MessagePackType keyType = reader.NextMessagePackType;\n+                                    if (keyType == MessagePackType.String || keyType == MessagePackType.Binary)\n+                                    {\n+                                        ToJsonCore(ref reader, writer, options);\n+                                    }\n+                                    else\n+                                    {\n+                                        writer.Write(\"\\\"\");\n+                                        ToJsonCore(ref reader, writer, options);\n+                                        writer.Write(\"\\\"\");\n+                                    }\n                                 }\n-                                else\n+\n+                                writer.Write(\":\");\n+\n+                                // write body\n                                 {\n-                                    writer.Write(\"\\\"\");\n-                                    ToJsonCore(ref reader, writer);\n-                                    writer.Write(\"\\\"\");\n+                                    ToJsonCore(ref reader, writer, options);\n                                 }\n-                            }\n-\n-                            writer.Write(\":\");\n \n-                            // write body\n-                            {\n-                                ToJsonCore(ref reader, writer);\n+                                if (i != length - 1)\n+                                {\n+                                    writer.Write(\",\");\n+                                }\n                             }\n \n-                            if (i != length - 1)\n-                            {\n-                                writer.Write(\",\");\n-                            }\n+                            writer.Write(\"}\");\n+                        }\n+                        finally\n+                        {\n+                            reader.Depth--;\n                         }\n-\n-                        writer.Write(\"}\");\n \n                         return;\n                     }\n@@ -375,7 +392,7 @@ private static void ToJsonCore(ref MessagePackReader reader, TextWriter writer)\n                         var privateBuilder = new StringBuilder();\n                         var typeNameTokenBuilder = new StringBuilder();\n                         SequencePosition positionBeforeTypeNameRead = reader.Position;\n-                        ToJsonCore(ref reader, new StringWriter(typeNameTokenBuilder));\n+                        ToJsonCore(ref reader, new StringWriter(typeNameTokenBuilder), options);\n                         int typeNameReadSize = (int)reader.Sequence.Slice(positionBeforeTypeNameRead, reader.Position).Length;\n                         if (extHeader.Length > typeNameReadSize)\n                         {\n@@ -386,7 +403,7 @@ private static void ToJsonCore(ref MessagePackReader reader, TextWriter writer)\n                                 privateBuilder.Append(\"{\");\n                             }\n \n-                            ToJsonCore(ref reader, new StringWriter(privateBuilder));\n+                            ToJsonCore(ref reader, new StringWriter(privateBuilder), options);\n \n                             // insert type name token to start of object map or array\n                             if (typeInside != MessagePackType.Array)"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/MessagePack/MessagePackSerializerOptions.cs",
          "status": "modified",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -59,6 +59,7 @@ protected MessagePackSerializerOptions(MessagePackSerializerOptions copyFrom)\n             this.OldSpec = copyFrom.OldSpec;\n             this.OmitAssemblyVersion = copyFrom.OmitAssemblyVersion;\n             this.AllowAssemblyVersionMismatch = copyFrom.AllowAssemblyVersionMismatch;\n+            this.Security = copyFrom.Security;\n         }\n \n         /// <summary>\n@@ -104,6 +105,14 @@ protected MessagePackSerializerOptions(MessagePackSerializerOptions copyFrom)\n         /// <value>The default value is <c>false</c>.</value>\n         public bool AllowAssemblyVersionMismatch { get; private set; }\n \n+        /// <summary>\n+        /// Gets the security-related options for deserializing messagepack sequences.\n+        /// </summary>\n+        /// <value>\n+        /// The default value is to use <see cref=\"MessagePackSecurity.TrustedData\"/>.\n+        /// </value>\n+        public MessagePackSecurity Security { get; private set; } = MessagePackSecurity.TrustedData;\n+\n         /// <summary>\n         /// Gets a type given a string representation of the type.\n         /// </summary>\n@@ -228,6 +237,28 @@ public MessagePackSerializerOptions WithAllowAssemblyVersionMismatch(bool allowA\n             return result;\n         }\n \n+        /// <summary>\n+        /// Gets a copy of these options with the <see cref=\"Security\"/> property set to a new value.\n+        /// </summary>\n+        /// <param name=\"security\">The new value for the <see cref=\"Security\"/> property.</param>\n+        /// <returns>The new instance; or the original if the value is unchanged.</returns>\n+        public MessagePackSerializerOptions WithSecurity(MessagePackSecurity security)\n+        {\n+            if (security is null)\n+            {\n+                throw new ArgumentNullException(nameof(security));\n+            }\n+\n+            if (this.Security == security)\n+            {\n+                return this;\n+            }\n+\n+            var result = this.Clone();\n+            result.Security = security;\n+            return result;\n+        }\n+\n         /// <summary>\n         /// Creates a clone of this instance with the same properties set.\n         /// </summary>"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/MessagePack/Resolvers/DynamicObjectResolver.cs",
          "status": "modified",
          "additions": 22,
          "deletions": 4,
          "patch": "@@ -849,7 +849,7 @@ private static void EmitSerializeValue(ILGenerator il, TypeInfo type, ObjectSeri\n         private static void BuildDeserialize(Type type, ObjectSerializationInfo info, ILGenerator il, Func<int, ObjectSerializationInfo.EmittableMember, Action> tryEmitLoadCustomFormatter, int firstArgIndex)\n         {\n             var reader = new ArgumentField(il, firstArgIndex, @ref: true);\n-            var argResolver = new ArgumentField(il, firstArgIndex + 1);\n+            var argOptions = new ArgumentField(il, firstArgIndex + 1);\n \n             // if(reader.TryReadNil()) { return null; }\n             Label falseLabel = il.DefineLabel();\n@@ -870,6 +870,12 @@ private static void BuildDeserialize(Type type, ObjectSerializationInfo info, IL\n \n             il.MarkLabel(falseLabel);\n \n+            // options.Security.DepthStep(ref reader);\n+            argOptions.EmitLoad();\n+            il.EmitCall(getSecurityFromOptions);\n+            reader.EmitLdarg();\n+            il.EmitCall(securityDepthStep);\n+\n             // var length = ReadMapHeader(ref byteSequence);\n             LocalBuilder length = il.DeclareLocal(typeof(int)); // [loc:1]\n             reader.EmitLdarg();\n@@ -939,7 +945,7 @@ private static void BuildDeserialize(Type type, ObjectSerializationInfo info, IL\n \n             // IFormatterResolver resolver = options.Resolver;\n             LocalBuilder localResolver = il.DeclareLocal(typeof(IFormatterResolver));\n-            argResolver.EmitLoad();\n+            argOptions.EmitLoad();\n             il.EmitCall(getResolverFromOptions);\n             il.EmitStloc(localResolver);\n \n@@ -975,7 +981,7 @@ private static void BuildDeserialize(Type type, ObjectSerializationInfo info, IL\n                             var i = x.Value;\n                             if (infoList[i].MemberInfo != null)\n                             {\n-                                EmitDeserializeValue(il, infoList[i], i, tryEmitLoadCustomFormatter, reader, argResolver, localResolver);\n+                                EmitDeserializeValue(il, infoList[i], i, tryEmitLoadCustomFormatter, reader, argOptions, localResolver);\n                                 il.Emit(OpCodes.Br, loopEnd);\n                             }\n                             else\n@@ -1031,7 +1037,7 @@ private static void BuildDeserialize(Type type, ObjectSerializationInfo info, IL\n                         if (item.MemberInfo != null)\n                         {\n                             il.MarkLabel(item.SwitchLabel);\n-                            EmitDeserializeValue(il, item, i++, tryEmitLoadCustomFormatter, reader, argResolver, localResolver);\n+                            EmitDeserializeValue(il, item, i++, tryEmitLoadCustomFormatter, reader, argOptions, localResolver);\n                             il.Emit(OpCodes.Br, loopEnd);\n                         }\n                     }\n@@ -1077,6 +1083,14 @@ private static void BuildDeserialize(Type type, ObjectSerializationInfo info, IL\n                 }\n             }\n \n+            // reader.Depth--;\n+            reader.EmitLdarg();\n+            il.Emit(OpCodes.Dup);\n+            il.EmitCall(readerDepthGet);\n+            il.Emit(OpCodes.Ldc_I4_1);\n+            il.Emit(OpCodes.Sub_Ovf);\n+            il.EmitCall(readerDepthSet);\n+\n             if (info.IsStruct)\n             {\n                 il.Emit(OpCodes.Ldloc, structLocal);\n@@ -1226,6 +1240,10 @@ private static bool IsOptimizeTargetType(Type type)\n \n         private static readonly MethodInfo getFormatterWithVerify = typeof(FormatterResolverExtensions).GetRuntimeMethods().First(x => x.Name == nameof(FormatterResolverExtensions.GetFormatterWithVerify));\n         private static readonly MethodInfo getResolverFromOptions = typeof(MessagePackSerializerOptions).GetRuntimeProperty(nameof(MessagePackSerializerOptions.Resolver)).GetMethod;\n+        private static readonly MethodInfo getSecurityFromOptions = typeof(MessagePackSerializerOptions).GetRuntimeProperty(nameof(MessagePackSerializerOptions.Security)).GetMethod;\n+        private static readonly MethodInfo securityDepthStep = typeof(MessagePackSecurity).GetRuntimeMethod(nameof(MessagePackSecurity.DepthStep), new[] { typeof(MessagePackReader).MakeByRefType() });\n+        private static readonly MethodInfo readerDepthGet = typeof(MessagePackReader).GetRuntimeProperty(nameof(MessagePackReader.Depth)).GetMethod;\n+        private static readonly MethodInfo readerDepthSet = typeof(MessagePackReader).GetRuntimeProperty(nameof(MessagePackReader.Depth)).SetMethod;\n         private static readonly Func<Type, MethodInfo> getSerialize = t => typeof(IMessagePackFormatter<>).MakeGenericType(t).GetRuntimeMethod(nameof(IMessagePackFormatter<int>.Serialize), new[] { typeof(MessagePackWriter).MakeByRefType(), t, typeof(MessagePackSerializerOptions) });\n         private static readonly Func<Type, MethodInfo> getDeserialize = t => typeof(IMessagePackFormatter<>).MakeGenericType(t).GetRuntimeMethod(nameof(IMessagePackFormatter<int>.Deserialize), new[] { refMessagePackReader, typeof(MessagePackSerializerOptions) });\n         //// static readonly ConstructorInfo dictionaryConstructor = typeof(ByteArrayStringHashTable).GetTypeInfo().DeclaredConstructors.First(x => { var p = x.GetParameters(); return p.Length == 1 && p[0].ParameterType == typeof(int); });"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/MessagePack/T4/ForceSizePrimitiveFormatter.cs",
          "status": "modified",
          "additions": 70,
          "deletions": 14,
          "patch": "@@ -97,9 +97,17 @@ public Int16[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOp\n             {\n                 var len = reader.ReadArrayHeader();\n                 var array = new Int16[len];\n-                for (int i = 0; i < array.Length; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n                 {\n-                    array[i] = reader.ReadInt16();\n+                    for (int i = 0; i < array.Length; i++)\n+                    {\n+                        array[i] = reader.ReadInt16();\n+                    }\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n                 }\n \n                 return array;\n@@ -193,9 +201,17 @@ public Int32[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOp\n             {\n                 var len = reader.ReadArrayHeader();\n                 var array = new Int32[len];\n-                for (int i = 0; i < array.Length; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    for (int i = 0; i < array.Length; i++)\n+                    {\n+                        array[i] = reader.ReadInt32();\n+                    }\n+                }\n+                finally\n                 {\n-                    array[i] = reader.ReadInt32();\n+                    reader.Depth--;\n                 }\n \n                 return array;\n@@ -289,9 +305,17 @@ public Int64[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOp\n             {\n                 var len = reader.ReadArrayHeader();\n                 var array = new Int64[len];\n-                for (int i = 0; i < array.Length; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n                 {\n-                    array[i] = reader.ReadInt64();\n+                    for (int i = 0; i < array.Length; i++)\n+                    {\n+                        array[i] = reader.ReadInt64();\n+                    }\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n                 }\n \n                 return array;\n@@ -385,9 +409,17 @@ public UInt16[] Deserialize(ref MessagePackReader reader, MessagePackSerializerO\n             {\n                 var len = reader.ReadArrayHeader();\n                 var array = new UInt16[len];\n-                for (int i = 0; i < array.Length; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    for (int i = 0; i < array.Length; i++)\n+                    {\n+                        array[i] = reader.ReadUInt16();\n+                    }\n+                }\n+                finally\n                 {\n-                    array[i] = reader.ReadUInt16();\n+                    reader.Depth--;\n                 }\n \n                 return array;\n@@ -481,9 +513,17 @@ public UInt32[] Deserialize(ref MessagePackReader reader, MessagePackSerializerO\n             {\n                 var len = reader.ReadArrayHeader();\n                 var array = new UInt32[len];\n-                for (int i = 0; i < array.Length; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    for (int i = 0; i < array.Length; i++)\n+                    {\n+                        array[i] = reader.ReadUInt32();\n+                    }\n+                }\n+                finally\n                 {\n-                    array[i] = reader.ReadUInt32();\n+                    reader.Depth--;\n                 }\n \n                 return array;\n@@ -577,9 +617,17 @@ public UInt64[] Deserialize(ref MessagePackReader reader, MessagePackSerializerO\n             {\n                 var len = reader.ReadArrayHeader();\n                 var array = new UInt64[len];\n-                for (int i = 0; i < array.Length; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n                 {\n-                    array[i] = reader.ReadUInt64();\n+                    for (int i = 0; i < array.Length; i++)\n+                    {\n+                        array[i] = reader.ReadUInt64();\n+                    }\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n                 }\n \n                 return array;\n@@ -725,9 +773,17 @@ public SByte[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOp\n             {\n                 var len = reader.ReadArrayHeader();\n                 var array = new SByte[len];\n-                for (int i = 0; i < array.Length; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    for (int i = 0; i < array.Length; i++)\n+                    {\n+                        array[i] = reader.ReadSByte();\n+                    }\n+                }\n+                finally\n                 {\n-                    array[i] = reader.ReadSByte();\n+                    reader.Depth--;\n                 }\n \n                 return array;"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/MessagePack/T4/TupleFormatter.cs",
          "status": "modified",
          "additions": 111,
          "deletions": 47,
          "patch": "@@ -43,9 +43,17 @@ public Tuple<T1> Deserialize(ref MessagePackReader reader, MessagePackSerializer\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n \n-                return new Tuple<T1>(item1);\n+                    return new Tuple<T1>(item1);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -83,10 +91,18 @@ public Tuple<T1, T2> Deserialize(ref MessagePackReader reader, MessagePackSerial\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n \n-                return new Tuple<T1, T2>(item1, item2);\n+                    return new Tuple<T1, T2>(item1, item2);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -125,11 +141,19 @@ public Tuple<T1, T2, T3> Deserialize(ref MessagePackReader reader, MessagePackSe\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n \n-                return new Tuple<T1, T2, T3>(item1, item2, item3);\n+                    return new Tuple<T1, T2, T3>(item1, item2, item3);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -169,12 +193,20 @@ public Tuple<T1, T2, T3, T4> Deserialize(ref MessagePackReader reader, MessagePa\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n \n-                return new Tuple<T1, T2, T3, T4>(item1, item2, item3, item4);\n+                    return new Tuple<T1, T2, T3, T4>(item1, item2, item3, item4);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -215,13 +247,21 @@ public Tuple<T1, T2, T3, T4, T5> Deserialize(ref MessagePackReader reader, Messa\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n-                T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n \n-                return new Tuple<T1, T2, T3, T4, T5>(item1, item2, item3, item4, item5);\n+                    return new Tuple<T1, T2, T3, T4, T5>(item1, item2, item3, item4, item5);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -263,14 +303,22 @@ public Tuple<T1, T2, T3, T4, T5, T6> Deserialize(ref MessagePackReader reader, M\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n-                T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n-                T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n-\n-                return new Tuple<T1, T2, T3, T4, T5, T6>(item1, item2, item3, item4, item5, item6);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n+                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n+\n+                    return new Tuple<T1, T2, T3, T4, T5, T6>(item1, item2, item3, item4, item5, item6);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -313,15 +361,23 @@ public Tuple<T1, T2, T3, T4, T5, T6, T7> Deserialize(ref MessagePackReader reade\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n-                T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n-                T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n-                T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);\n-\n-                return new Tuple<T1, T2, T3, T4, T5, T6, T7>(item1, item2, item3, item4, item5, item6, item7);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n+                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n+                    T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);\n+\n+                    return new Tuple<T1, T2, T3, T4, T5, T6, T7>(item1, item2, item3, item4, item5, item6, item7);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -365,16 +421,24 @@ public Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> Deserialize(ref MessagePackReade\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n-                T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n-                T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n-                T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);\n-                TRest item8 = resolver.GetFormatterWithVerify<TRest>().Deserialize(ref reader, options);\n-\n-                return new Tuple<T1, T2, T3, T4, T5, T6, T7, TRest>(item1, item2, item3, item4, item5, item6, item7, item8);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n+                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n+                    T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);\n+                    TRest item8 = resolver.GetFormatterWithVerify<TRest>().Deserialize(ref reader, options);\n+\n+                    return new Tuple<T1, T2, T3, T4, T5, T6, T7, TRest>(item1, item2, item3, item4, item5, item6, item7, item8);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/MessagePack/T4/ValueTupleFormatter.cs",
          "status": "modified",
          "additions": 111,
          "deletions": 47,
          "patch": "@@ -36,9 +36,17 @@ public ValueTuple<T1> Deserialize(ref MessagePackReader reader, MessagePackSeria\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n \n-                return new ValueTuple<T1>(item1);\n+                    return new ValueTuple<T1>(item1);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -69,10 +77,18 @@ public ValueTuple<T1, T2> Deserialize(ref MessagePackReader reader, MessagePackS\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n \n-                return new ValueTuple<T1, T2>(item1, item2);\n+                    return new ValueTuple<T1, T2>(item1, item2);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -104,11 +120,19 @@ public ValueTuple<T1, T2, T3> Deserialize(ref MessagePackReader reader, MessageP\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n \n-                return new ValueTuple<T1, T2, T3>(item1, item2, item3);\n+                    return new ValueTuple<T1, T2, T3>(item1, item2, item3);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -141,12 +165,20 @@ public ValueTuple<T1, T2, T3, T4> Deserialize(ref MessagePackReader reader, Mess\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n \n-                return new ValueTuple<T1, T2, T3, T4>(item1, item2, item3, item4);\n+                    return new ValueTuple<T1, T2, T3, T4>(item1, item2, item3, item4);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -180,13 +212,21 @@ public ValueTuple<T1, T2, T3, T4, T5> Deserialize(ref MessagePackReader reader,\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n-                T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n \n-                return new ValueTuple<T1, T2, T3, T4, T5>(item1, item2, item3, item4, item5);\n+                    return new ValueTuple<T1, T2, T3, T4, T5>(item1, item2, item3, item4, item5);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -221,14 +261,22 @@ public ValueTuple<T1, T2, T3, T4, T5, T6> Deserialize(ref MessagePackReader read\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n-                T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n-                T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n-\n-                return new ValueTuple<T1, T2, T3, T4, T5, T6>(item1, item2, item3, item4, item5, item6);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n+                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n+\n+                    return new ValueTuple<T1, T2, T3, T4, T5, T6>(item1, item2, item3, item4, item5, item6);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -264,15 +312,23 @@ public ValueTuple<T1, T2, T3, T4, T5, T6, T7> Deserialize(ref MessagePackReader\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n-                T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n-                T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n-                T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);\n-\n-                return new ValueTuple<T1, T2, T3, T4, T5, T6, T7>(item1, item2, item3, item4, item5, item6, item7);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n+                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n+                    T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);\n+\n+                    return new ValueTuple<T1, T2, T3, T4, T5, T6, T7>(item1, item2, item3, item4, item5, item6, item7);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -310,16 +366,24 @@ public ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> Deserialize(ref MessagePack\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n-                T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n-                T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n-                T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);\n-                TRest item8 = resolver.GetFormatterWithVerify<TRest>().Deserialize(ref reader, options);\n-\n-                return new ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>(item1, item2, item3, item4, item5, item6, item7, item8);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n+                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n+                    T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);\n+                    TRest item8 = resolver.GetFormatterWithVerify<TRest>().Deserialize(ref reader, options);\n+\n+                    return new ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>(item1, item2, item3, item4, item5, item6, item7, item8);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/Tests/ShareTests/MessagePackReaderTests.cs",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -252,6 +252,17 @@ public void ReadRaw()\n             Assert.True(reader.End);\n         }\n \n+        [Fact]\n+        public void Depth()\n+        {\n+            var reader = new MessagePackReader(Encode((ref MessagePackWriter w) => w.Write(1.23)));\n+            Assert.Equal(0, reader.Depth);\n+            reader.Depth++;\n+            Assert.Equal(1, reader.Depth);\n+            reader.Depth--;\n+            Assert.Equal(0, reader.Depth);\n+        }\n+\n         [Fact]\n         public void Read_CheckOperations_WithNoBytesLeft()\n         {"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/Tests/ShareTests/MessagePackSecurityTests.cs",
          "status": "added",
          "additions": 178,
          "deletions": 0,
          "patch": "@@ -0,0 +1,178 @@\n+\ufeff// Copyright (c) All contributors. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Runtime.Serialization;\n+using MessagePack;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+public class MessagePackSecurityTests\n+{\n+    public MessagePackSecurityTests(ITestOutputHelper logger)\n+    {\n+        Logger = logger;\n+    }\n+\n+    public ITestOutputHelper Logger { get; }\n+\n+    [Fact]\n+    public void Untrusted()\n+    {\n+        Assert.True(MessagePackSecurity.UntrustedData.HashCollisionResistant);\n+    }\n+\n+    [Fact]\n+    public void Trusted()\n+    {\n+        Assert.False(MessagePackSecurity.TrustedData.HashCollisionResistant);\n+    }\n+\n+    [Fact]\n+    public void WithHashCollisionResistant()\n+    {\n+        Assert.Same(MessagePackSecurity.TrustedData, MessagePackSecurity.TrustedData.WithHashCollisionResistant(false));\n+        Assert.True(MessagePackSecurity.TrustedData.WithHashCollisionResistant(true).HashCollisionResistant);\n+    }\n+\n+    [Fact]\n+    public void EqualityComparer_CollisionResistance_Int64()\n+    {\n+        const long value1 = 0x100000001;\n+        const long value2 = 0x200000002;\n+        var eq = MessagePackSecurity.UntrustedData.GetEqualityComparer<long>();\n+        Assert.Equal(EqualityComparer<long>.Default.GetHashCode(value1), EqualityComparer<long>.Default.GetHashCode(value2)); // demonstrate insecurity\n+        Assert.NotEqual(eq.GetHashCode(value1), eq.GetHashCode(value2));\n+    }\n+\n+    [Fact]\n+    public void EqualityComparer_CollisionResistance_Guid()\n+    {\n+        Guid value1 = new Guid(new byte[] { 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1 });\n+        Guid value2 = new Guid(new byte[] { 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2 });\n+        var eq = MessagePackSecurity.UntrustedData.GetEqualityComparer<Guid>();\n+#if NETCOREAPP // We contrived the two GUIDs to force a collision on .NET Core. NETFx's algorithm is slightly different.\n+        Assert.Equal(EqualityComparer<Guid>.Default.GetHashCode(value1), EqualityComparer<Guid>.Default.GetHashCode(value2)); // demonstrate insecurity\n+#endif\n+        Assert.NotEqual(eq.GetHashCode(value1), eq.GetHashCode(value2));\n+    }\n+\n+    [Fact]\n+    public unsafe void EqualityComparer_Single()\n+    {\n+        var eq = MessagePackSecurity.UntrustedData.GetEqualityComparer<float>();\n+        Assert.Equal(eq.GetHashCode(0.0f), eq.GetHashCode(-0.0f));\n+\n+        // Try multiple forms of NaN\n+        float nan1, nan2;\n+        *(uint*)&nan1 = 0xFFC00001;\n+        *(uint*)&nan2 = 0xFF800001;\n+\n+        Assert.True(float.IsNaN(nan1));\n+        Assert.True(float.IsNaN(nan2));\n+#if NETCOREAPP // .NET Framework had a bug where these would not be equal\n+        Assert.Equal(nan1.GetHashCode(), nan2.GetHashCode());\n+#endif\n+        Assert.Equal(eq.GetHashCode(nan1), eq.GetHashCode(nan2));\n+        Assert.Equal(eq.GetHashCode(float.NaN), eq.GetHashCode(-float.NaN));\n+\n+        // Try various other clearly different numbers\n+        Assert.NotEqual(eq.GetHashCode(1.0f), eq.GetHashCode(-1.0f));\n+        Assert.NotEqual(eq.GetHashCode(1.0f), eq.GetHashCode(2.0f));\n+    }\n+\n+    [Fact]\n+    public unsafe void EqualityComparer_Double()\n+    {\n+        var eq = MessagePackSecurity.UntrustedData.GetEqualityComparer<double>();\n+        Assert.Equal(eq.GetHashCode(0.0), eq.GetHashCode(-0.0));\n+\n+        // Try multiple forms of NaN\n+        double nan1, nan2;\n+        *(ulong*)&nan1 = 0xFFF8000000000001;\n+        *(ulong*)&nan2 = 0xFFF8000000000002;\n+\n+        Assert.True(double.IsNaN(nan1));\n+        Assert.True(double.IsNaN(nan2));\n+#if NETCOREAPP // .NET Framework had a bug where these would not be equal\n+        Assert.Equal(nan1.GetHashCode(), nan2.GetHashCode());\n+#endif\n+        Assert.Equal(eq.GetHashCode(nan1), eq.GetHashCode(nan2));\n+        Assert.Equal(eq.GetHashCode(double.NaN), eq.GetHashCode(-double.NaN));\n+\n+        // Try various other clearly different numbers\n+        Assert.NotEqual(eq.GetHashCode(1.0), eq.GetHashCode(-1.0));\n+        Assert.NotEqual(eq.GetHashCode(1.0), eq.GetHashCode(2.0));\n+    }\n+\n+    [Fact]\n+    public void EqualityComparer_ObjectFallback()\n+    {\n+        var eq = MessagePackSecurity.UntrustedData.GetEqualityComparer<object>();\n+\n+        Assert.Equal(eq.GetHashCode(null), eq.GetHashCode(null));\n+        Assert.NotEqual(eq.GetHashCode(null), eq.GetHashCode(new object()));\n+\n+        Assert.Equal(eq.GetHashCode(\"hi\"), eq.GetHashCode(\"hi\"));\n+        Assert.NotEqual(eq.GetHashCode(\"hi\"), eq.GetHashCode(\"bye\"));\n+\n+        Assert.Equal(eq.GetHashCode(true), eq.GetHashCode(true));\n+        Assert.NotEqual(eq.GetHashCode(true), eq.GetHashCode(false));\n+\n+        var o = new object();\n+        Assert.Equal(eq.GetHashCode(o), eq.GetHashCode(o));\n+        Assert.NotEqual(eq.GetHashCode(o), eq.GetHashCode(new object()));\n+    }\n+\n+    /// <summary>\n+    /// Verifies that arbitrary other types not known to be hash safe will be rejected.\n+    /// </summary>\n+    [Fact]\n+    public void EqualityComparer_ObjectFallback_UnsupportedType()\n+    {\n+        var eq = MessagePackSecurity.UntrustedData.GetEqualityComparer<object>();\n+        var ex = Assert.Throws<TypeAccessException>(() => eq.GetHashCode(new AggregateException()));\n+        this.Logger.WriteLine(ex.ToString());\n+    }\n+\n+    [Fact]\n+    public void TypelessFormatterWithUntrustedData_SafeKeys()\n+    {\n+        var data = new\n+        {\n+            A = (byte)3,\n+            B = new Dictionary<object, byte>\n+            {\n+                { \"C\", 15 },\n+            },\n+            D = new string[] { \"E\", \"F\" },\n+        };\n+        byte[] msgpack = MessagePackSerializer.Serialize(data);\n+        var deserialized = (IDictionary<object, object>)MessagePackSerializer.Deserialize<object>(msgpack, MessagePackSerializerOptions.Standard.WithSecurity(MessagePackSecurity.UntrustedData));\n+        Assert.Equal(data.A, deserialized[\"A\"]);\n+        Assert.Equal(data.B[\"C\"], ((Dictionary<object, object>)deserialized[\"B\"])[\"C\"]);\n+        Assert.Equal(data.D, deserialized[\"D\"]);\n+    }\n+\n+    [Fact]\n+    public void TypelessFormatterWithUntrustedData_UnsafeKeys()\n+    {\n+        var data = new\n+        {\n+            B = new Dictionary<object, byte>\n+            {\n+                { new ArbitraryType(), 15 },\n+            },\n+        };\n+        byte[] msgpack = MessagePackSerializer.Serialize(data);\n+        var ex = Assert.Throws<MessagePackSerializationException>(() => MessagePackSerializer.Deserialize<object>(msgpack, MessagePackSerializerOptions.Standard.WithSecurity(MessagePackSecurity.UntrustedData)));\n+        Assert.IsType<TypeAccessException>(ex.InnerException);\n+        this.Logger.WriteLine(ex.ToString());\n+    }\n+\n+    [DataContract]\n+    public class ArbitraryType\n+    {\n+    }\n+}"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/Tests/ShareTests/MessagePackSerializerOptionsTests.cs",
          "status": "modified",
          "additions": 42,
          "deletions": 7,
          "patch": "@@ -12,7 +12,8 @@ public class MessagePackSerializerOptionsTests\n         .WithAllowAssemblyVersionMismatch(true)\n         .WithOmitAssemblyVersion(true)\n         .WithResolver(BuiltinResolver.Instance)\n-        .WithOldSpec(false);\n+        .WithOldSpec(false)\n+        .WithSecurity(MySecurityOptions.Instance);\n \n     [Fact]\n     public void AllowAssemblyVersionMismatch()\n@@ -45,10 +46,17 @@ public void OldSpec()\n     [Fact]\n     public void Resolver()\n     {\n-        Assert.Same((object)StandardResolver.Instance, (object)MessagePackSerializerOptions.Standard.Resolver);\n+        Assert.Same(StandardResolver.Instance, MessagePackSerializerOptions.Standard.Resolver);\n         Assert.Same(BuiltinResolver.Instance, MessagePackSerializerOptions.Standard.WithResolver(BuiltinResolver.Instance).Resolver);\n     }\n \n+    [Fact]\n+    public void Security()\n+    {\n+        Assert.Same(MessagePackSecurity.TrustedData, MessagePackSerializerOptions.Standard.Security);\n+        Assert.Same(MessagePackSecurity.UntrustedData, MessagePackSerializerOptions.Standard.WithSecurity(MessagePackSecurity.UntrustedData).Security);\n+    }\n+\n     [Fact]\n     public void WithOldSpec_PreservesOtherProperties()\n     {\n@@ -57,7 +65,8 @@ public void WithOldSpec_PreservesOtherProperties()\n         Assert.Equal(NonDefaultOptions.Compression, mutated.Compression);\n         Assert.Equal(NonDefaultOptions.AllowAssemblyVersionMismatch, mutated.AllowAssemblyVersionMismatch);\n         Assert.Equal(NonDefaultOptions.OmitAssemblyVersion, mutated.OmitAssemblyVersion);\n-        Assert.Same((object)NonDefaultOptions.Resolver, (object)mutated.Resolver);\n+        Assert.Same(NonDefaultOptions.Resolver, mutated.Resolver);\n+        Assert.Same(MySecurityOptions.Instance, mutated.Security);\n     }\n \n     [Fact]\n@@ -68,7 +77,8 @@ public void WithLZ4Compression_PreservesOtherProperties()\n         Assert.Equal(NonDefaultOptions.OldSpec, mutated.OldSpec);\n         Assert.Equal(NonDefaultOptions.AllowAssemblyVersionMismatch, mutated.AllowAssemblyVersionMismatch);\n         Assert.Equal(NonDefaultOptions.OmitAssemblyVersion, mutated.OmitAssemblyVersion);\n-        Assert.Same((object)NonDefaultOptions.Resolver, (object)mutated.Resolver);\n+        Assert.Same(NonDefaultOptions.Resolver, mutated.Resolver);\n+        Assert.Same(MySecurityOptions.Instance, mutated.Security);\n     }\n \n     [Fact]\n@@ -79,7 +89,8 @@ public void WithAllowAssemblyVersionMismatch_PreservesOtherProperties()\n         Assert.Equal(NonDefaultOptions.Compression, mutated.Compression);\n         Assert.Equal(NonDefaultOptions.OldSpec, mutated.OldSpec);\n         Assert.Equal(NonDefaultOptions.OmitAssemblyVersion, mutated.OmitAssemblyVersion);\n-        Assert.Same((object)NonDefaultOptions.Resolver, (object)mutated.Resolver);\n+        Assert.Same(NonDefaultOptions.Resolver, mutated.Resolver);\n+        Assert.Same(MySecurityOptions.Instance, mutated.Security);\n     }\n \n     [Fact]\n@@ -90,17 +101,41 @@ public void WithOmitAssemblyVersion_PreservesOtherProperties()\n         Assert.Equal(NonDefaultOptions.Compression, mutated.Compression);\n         Assert.Equal(NonDefaultOptions.OldSpec, mutated.OldSpec);\n         Assert.Equal(NonDefaultOptions.AllowAssemblyVersionMismatch, mutated.AllowAssemblyVersionMismatch);\n-        Assert.Same((object)NonDefaultOptions.Resolver, (object)mutated.Resolver);\n+        Assert.Same(NonDefaultOptions.Resolver, mutated.Resolver);\n+        Assert.Same(MySecurityOptions.Instance, mutated.Security);\n     }\n \n     [Fact]\n     public void WithResolver_PreservesOtherProperties()\n     {\n         var mutated = NonDefaultOptions.WithResolver(ContractlessStandardResolver.Instance);\n-        Assert.Same((object)ContractlessStandardResolver.Instance, (object)mutated.Resolver);\n+        Assert.Same(ContractlessStandardResolver.Instance, mutated.Resolver);\n+        Assert.Equal(NonDefaultOptions.Compression, mutated.Compression);\n+        Assert.Equal(NonDefaultOptions.OldSpec, mutated.OldSpec);\n+        Assert.Equal(NonDefaultOptions.AllowAssemblyVersionMismatch, mutated.AllowAssemblyVersionMismatch);\n+        Assert.Equal(NonDefaultOptions.OmitAssemblyVersion, mutated.OmitAssemblyVersion);\n+        Assert.Same(MySecurityOptions.Instance, mutated.Security);\n+    }\n+\n+    [Fact]\n+    public void WithSecurity_PreservesOtherProperties()\n+    {\n+        var mutated = NonDefaultOptions.WithSecurity(MessagePackSecurity.TrustedData);\n+        Assert.Same(MessagePackSecurity.TrustedData, mutated.Security);\n+        Assert.Same(NonDefaultOptions.Resolver, mutated.Resolver);\n         Assert.Equal(NonDefaultOptions.Compression, mutated.Compression);\n         Assert.Equal(NonDefaultOptions.OldSpec, mutated.OldSpec);\n         Assert.Equal(NonDefaultOptions.AllowAssemblyVersionMismatch, mutated.AllowAssemblyVersionMismatch);\n         Assert.Equal(NonDefaultOptions.OmitAssemblyVersion, mutated.OmitAssemblyVersion);\n     }\n+\n+    private class MySecurityOptions : MessagePackSecurity\n+    {\n+        internal static readonly MySecurityOptions Instance = new MySecurityOptions();\n+\n+        private MySecurityOptions()\n+            : base(TrustedData)\n+        {\n+        }\n+    }\n }"
        },
        {
          "filename": "src/MessagePack.UnityClient/Assets/Scripts/Tests/ShareTests/MessagePackSerializerTest.cs",
          "status": "modified",
          "additions": 122,
          "deletions": 0,
          "patch": "@@ -2,13 +2,17 @@\n // Licensed under the MIT license. See LICENSE file in the project root for full license information.\n \n using System;\n+using System.Buffers;\n using System.Collections.Generic;\n using System.IO;\n using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Runtime.Serialization;\n using System.Text;\n using System.Threading.Tasks;\n using MessagePack.Resolvers;\n using Microsoft;\n+using MsgPack.Serialization;\n using Nerdbank.Streams;\n using SharedData;\n using Xunit;\n@@ -200,6 +204,124 @@ public async Task SerializeAndDeserializeAsync_MultipleValues_SeekableStream(boo\n             Assert.Equal(2, await MessagePackSerializer.DeserializeAsync<int>(stream));\n             Assert.Equal(3, await MessagePackSerializer.DeserializeAsync<int>(stream));\n         }\n+\n+        [Theory]\n+        [InlineData(true)]\n+        [InlineData(false)]\n+        public void StackDepthCheck_Arrays(bool convertToJson)\n+        {\n+            var (sequence, options) = StackDepthCheck_Helper((ref MessagePackWriter writer) => writer.WriteArrayHeader(1));\n+            if (convertToJson)\n+            {\n+                AssertConvertToJsonRecursionCheckThrows(sequence, options);\n+            }\n+            else\n+            {\n+                AssertDeserializationRecursionCheckThrows(sequence, options);\n+            }\n+        }\n+\n+        [Theory]\n+        [InlineData(true)]\n+        [InlineData(false)]\n+        public void StackDepthCheck_Maps(bool convertToJson)\n+        {\n+            var (sequence, options) = StackDepthCheck_Helper((ref MessagePackWriter writer) =>\n+            {\n+                writer.WriteMapHeader(1);\n+                writer.Write(1);\n+            });\n+            if (convertToJson)\n+            {\n+                AssertConvertToJsonRecursionCheckThrows(sequence, options);\n+            }\n+            else\n+            {\n+                AssertDeserializationRecursionCheckThrows(sequence, options);\n+            }\n+        }\n+\n+        [Fact]\n+        public void StackDepthCheck_DynamicObjectResolver()\n+        {\n+            var graph = new RecursiveObjectGraph\n+            {\n+                Child1 = new RecursiveObjectGraph\n+                {\n+                    Child1 = new RecursiveObjectGraph { },\n+                },\n+                Child2 = new RecursiveObjectGraph\n+                {\n+                    Child1 = new RecursiveObjectGraph { },\n+                },\n+                Child3 = new RecursiveObjectGraph\n+                {\n+                    Child1 = new RecursiveObjectGraph { },\n+                },\n+            };\n+            byte[] msgpack = MessagePackSerializer.Serialize(graph, MessagePackSerializerOptions.Standard);\n+\n+            var options = MessagePackSerializerOptions.Standard.WithSecurity(MessagePackSecurity.UntrustedData.WithMaximumObjectGraphDepth(3));\n+            MessagePackSerializer.Deserialize<RecursiveObjectGraph>(msgpack, options);\n+\n+            options = MessagePackSerializerOptions.Standard.WithSecurity(MessagePackSecurity.UntrustedData.WithMaximumObjectGraphDepth(2));\n+            var ex = Assert.Throws<MessagePackSerializationException>(() => MessagePackSerializer.Deserialize<RecursiveObjectGraph>(msgpack, options));\n+            Assert.IsType<InsufficientExecutionStackException>(ex.InnerException);\n+        }\n+\n+        private delegate void WriterHelper(ref MessagePackWriter writer);\n+\n+        private static (ReadOnlySequence<byte> Sequence, MessagePackSerializerOptions Options) StackDepthCheck_Helper(WriterHelper recursiveWriteOperation)\n+        {\n+            const int maxDepth = 3;\n+            var options = MessagePackSerializerOptions.Standard\n+                .WithSecurity(MessagePackSecurity.UntrustedData.WithMaximumObjectGraphDepth(maxDepth));\n+\n+            var sequence = new Sequence<byte>();\n+            var writer = new MessagePackWriter(sequence);\n+            for (int i = 0; i <= maxDepth; i++)\n+            {\n+                recursiveWriteOperation(ref writer);\n+            }\n+\n+            writer.Write(1);\n+            writer.Flush();\n+\n+            return (sequence.AsReadOnlySequence, options);\n+        }\n+\n+        private static void AssertDeserializationRecursionCheckThrows(ReadOnlySequence<byte> sequence, MessagePackSerializerOptions options)\n+        {\n+            var ex = Assert.Throws<MessagePackSerializationException>(() =>\n+            {\n+                var reader = new MessagePackReader(sequence);\n+                return MessagePackSerializer.Deserialize<object>(ref reader, options);\n+            });\n+            Assert.IsType<InsufficientExecutionStackException>(ex.InnerException);\n+        }\n+\n+        private static void AssertConvertToJsonRecursionCheckThrows(ReadOnlySequence<byte> sequence, MessagePackSerializerOptions options)\n+        {\n+            var ex = Assert.Throws<MessagePackSerializationException>(() =>\n+            {\n+                var reader = new MessagePackReader(sequence);\n+                MessagePackSerializer.ConvertToJson(ref reader, new StringWriter(), options);\n+            });\n+            Assert.IsType<InsufficientExecutionStackException>(ex.InnerException);\n+        }\n+\n+        [DataContract]\n+        public class RecursiveObjectGraph\n+        {\n+            [DataMember]\n+            public RecursiveObjectGraph Child1 { get; set; }\n+\n+            [DataMember]\n+            public RecursiveObjectGraph Child2 { get; set; }\n+\n+            [DataMember]\n+            public RecursiveObjectGraph Child3 { get; set; }\n+        }\n     }\n \n     internal class StreamWrapper : Stream"
        },
        {
          "filename": "src/MessagePack/Formatters/ForceSizePrimitiveFormatter.cs",
          "status": "modified",
          "additions": 70,
          "deletions": 14,
          "patch": "@@ -97,9 +97,17 @@ public Int16[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOp\n             {\n                 var len = reader.ReadArrayHeader();\n                 var array = new Int16[len];\n-                for (int i = 0; i < array.Length; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n                 {\n-                    array[i] = reader.ReadInt16();\n+                    for (int i = 0; i < array.Length; i++)\n+                    {\n+                        array[i] = reader.ReadInt16();\n+                    }\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n                 }\n \n                 return array;\n@@ -193,9 +201,17 @@ public Int32[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOp\n             {\n                 var len = reader.ReadArrayHeader();\n                 var array = new Int32[len];\n-                for (int i = 0; i < array.Length; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    for (int i = 0; i < array.Length; i++)\n+                    {\n+                        array[i] = reader.ReadInt32();\n+                    }\n+                }\n+                finally\n                 {\n-                    array[i] = reader.ReadInt32();\n+                    reader.Depth--;\n                 }\n \n                 return array;\n@@ -289,9 +305,17 @@ public Int64[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOp\n             {\n                 var len = reader.ReadArrayHeader();\n                 var array = new Int64[len];\n-                for (int i = 0; i < array.Length; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n                 {\n-                    array[i] = reader.ReadInt64();\n+                    for (int i = 0; i < array.Length; i++)\n+                    {\n+                        array[i] = reader.ReadInt64();\n+                    }\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n                 }\n \n                 return array;\n@@ -385,9 +409,17 @@ public UInt16[] Deserialize(ref MessagePackReader reader, MessagePackSerializerO\n             {\n                 var len = reader.ReadArrayHeader();\n                 var array = new UInt16[len];\n-                for (int i = 0; i < array.Length; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    for (int i = 0; i < array.Length; i++)\n+                    {\n+                        array[i] = reader.ReadUInt16();\n+                    }\n+                }\n+                finally\n                 {\n-                    array[i] = reader.ReadUInt16();\n+                    reader.Depth--;\n                 }\n \n                 return array;\n@@ -481,9 +513,17 @@ public UInt32[] Deserialize(ref MessagePackReader reader, MessagePackSerializerO\n             {\n                 var len = reader.ReadArrayHeader();\n                 var array = new UInt32[len];\n-                for (int i = 0; i < array.Length; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    for (int i = 0; i < array.Length; i++)\n+                    {\n+                        array[i] = reader.ReadUInt32();\n+                    }\n+                }\n+                finally\n                 {\n-                    array[i] = reader.ReadUInt32();\n+                    reader.Depth--;\n                 }\n \n                 return array;\n@@ -577,9 +617,17 @@ public UInt64[] Deserialize(ref MessagePackReader reader, MessagePackSerializerO\n             {\n                 var len = reader.ReadArrayHeader();\n                 var array = new UInt64[len];\n-                for (int i = 0; i < array.Length; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n                 {\n-                    array[i] = reader.ReadUInt64();\n+                    for (int i = 0; i < array.Length; i++)\n+                    {\n+                        array[i] = reader.ReadUInt64();\n+                    }\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n                 }\n \n                 return array;\n@@ -725,9 +773,17 @@ public SByte[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOp\n             {\n                 var len = reader.ReadArrayHeader();\n                 var array = new SByte[len];\n-                for (int i = 0; i < array.Length; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    for (int i = 0; i < array.Length; i++)\n+                    {\n+                        array[i] = reader.ReadSByte();\n+                    }\n+                }\n+                finally\n                 {\n-                    array[i] = reader.ReadSByte();\n+                    reader.Depth--;\n                 }\n \n                 return array;"
        },
        {
          "filename": "src/MessagePack/Formatters/ForceSizePrimitiveFormatter.tt",
          "status": "modified",
          "additions": 10,
          "deletions": 2,
          "patch": "@@ -123,9 +123,17 @@ namespace MessagePack.Formatters\n             {\n                 var len = reader.ReadArrayHeader();\n                 var array = new <#= t.Name #>[len];\n-                for (int i = 0; i < array.Length; i++)\n+                options.Security.DepthStep(ref reader);\n+                try\n                 {\n-                    array[i] = reader.Read<#= t.Name #>();\n+                    for (int i = 0; i < array.Length; i++)\n+                    {\n+                        array[i] = reader.Read<#= t.Name #>();\n+                    }\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n                 }\n \n                 return array;"
        },
        {
          "filename": "src/MessagePack/Formatters/TupleFormatter.cs",
          "status": "modified",
          "additions": 111,
          "deletions": 47,
          "patch": "@@ -43,9 +43,17 @@ public Tuple<T1> Deserialize(ref MessagePackReader reader, MessagePackSerializer\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n \n-                return new Tuple<T1>(item1);\n+                    return new Tuple<T1>(item1);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -83,10 +91,18 @@ public Tuple<T1, T2> Deserialize(ref MessagePackReader reader, MessagePackSerial\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n \n-                return new Tuple<T1, T2>(item1, item2);\n+                    return new Tuple<T1, T2>(item1, item2);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -125,11 +141,19 @@ public Tuple<T1, T2, T3> Deserialize(ref MessagePackReader reader, MessagePackSe\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n \n-                return new Tuple<T1, T2, T3>(item1, item2, item3);\n+                    return new Tuple<T1, T2, T3>(item1, item2, item3);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -169,12 +193,20 @@ public Tuple<T1, T2, T3, T4> Deserialize(ref MessagePackReader reader, MessagePa\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n \n-                return new Tuple<T1, T2, T3, T4>(item1, item2, item3, item4);\n+                    return new Tuple<T1, T2, T3, T4>(item1, item2, item3, item4);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -215,13 +247,21 @@ public Tuple<T1, T2, T3, T4, T5> Deserialize(ref MessagePackReader reader, Messa\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n-                T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n \n-                return new Tuple<T1, T2, T3, T4, T5>(item1, item2, item3, item4, item5);\n+                    return new Tuple<T1, T2, T3, T4, T5>(item1, item2, item3, item4, item5);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -263,14 +303,22 @@ public Tuple<T1, T2, T3, T4, T5, T6> Deserialize(ref MessagePackReader reader, M\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n-                T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n-                T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n-\n-                return new Tuple<T1, T2, T3, T4, T5, T6>(item1, item2, item3, item4, item5, item6);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n+                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n+\n+                    return new Tuple<T1, T2, T3, T4, T5, T6>(item1, item2, item3, item4, item5, item6);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -313,15 +361,23 @@ public Tuple<T1, T2, T3, T4, T5, T6, T7> Deserialize(ref MessagePackReader reade\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n-                T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n-                T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n-                T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);\n-\n-                return new Tuple<T1, T2, T3, T4, T5, T6, T7>(item1, item2, item3, item4, item5, item6, item7);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n+                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n+                    T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);\n+\n+                    return new Tuple<T1, T2, T3, T4, T5, T6, T7>(item1, item2, item3, item4, item5, item6, item7);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -365,16 +421,24 @@ public Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> Deserialize(ref MessagePackReade\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n-                T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n-                T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n-                T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);\n-                TRest item8 = resolver.GetFormatterWithVerify<TRest>().Deserialize(ref reader, options);\n-\n-                return new Tuple<T1, T2, T3, T4, T5, T6, T7, TRest>(item1, item2, item3, item4, item5, item6, item7, item8);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n+                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n+                    T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);\n+                    TRest item8 = resolver.GetFormatterWithVerify<TRest>().Deserialize(ref reader, options);\n+\n+                    return new Tuple<T1, T2, T3, T4, T5, T6, T7, TRest>(item1, item2, item3, item4, item5, item6, item7, item8);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }"
        },
        {
          "filename": "src/MessagePack/Formatters/TupleFormatter.tt",
          "status": "modified",
          "additions": 10,
          "deletions": 2,
          "patch": "@@ -57,11 +57,19 @@ namespace MessagePack.Formatters\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n <# for(var j = 1; j <= i; j++) { #>\n-                <#= toT(j) #> item<#= j #> = resolver.GetFormatterWithVerify<<#= toT(j) #>>().Deserialize(ref reader, options);\n+                    <#= toT(j) #> item<#= j #> = resolver.GetFormatterWithVerify<<#= toT(j) #>>().Deserialize(ref reader, options);\n <# } #>\n \n-                return new Tuple<<#= ts #>>(<#= string.Join(\", \", Enumerable.Range(1, i).Select(x => \"item\" + x)) #>);\n+                    return new Tuple<<#= ts #>>(<#= string.Join(\", \", Enumerable.Range(1, i).Select(x => \"item\" + x)) #>);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }"
        },
        {
          "filename": "src/MessagePack/Formatters/ValueTupleFormatter.cs",
          "status": "modified",
          "additions": 111,
          "deletions": 47,
          "patch": "@@ -36,9 +36,17 @@ public ValueTuple<T1> Deserialize(ref MessagePackReader reader, MessagePackSeria\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n \n-                return new ValueTuple<T1>(item1);\n+                    return new ValueTuple<T1>(item1);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -69,10 +77,18 @@ public ValueTuple<T1, T2> Deserialize(ref MessagePackReader reader, MessagePackS\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n \n-                return new ValueTuple<T1, T2>(item1, item2);\n+                    return new ValueTuple<T1, T2>(item1, item2);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -104,11 +120,19 @@ public ValueTuple<T1, T2, T3> Deserialize(ref MessagePackReader reader, MessageP\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n \n-                return new ValueTuple<T1, T2, T3>(item1, item2, item3);\n+                    return new ValueTuple<T1, T2, T3>(item1, item2, item3);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -141,12 +165,20 @@ public ValueTuple<T1, T2, T3, T4> Deserialize(ref MessagePackReader reader, Mess\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n \n-                return new ValueTuple<T1, T2, T3, T4>(item1, item2, item3, item4);\n+                    return new ValueTuple<T1, T2, T3, T4>(item1, item2, item3, item4);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -180,13 +212,21 @@ public ValueTuple<T1, T2, T3, T4, T5> Deserialize(ref MessagePackReader reader,\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n-                T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n \n-                return new ValueTuple<T1, T2, T3, T4, T5>(item1, item2, item3, item4, item5);\n+                    return new ValueTuple<T1, T2, T3, T4, T5>(item1, item2, item3, item4, item5);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -221,14 +261,22 @@ public ValueTuple<T1, T2, T3, T4, T5, T6> Deserialize(ref MessagePackReader read\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n-                T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n-                T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n-\n-                return new ValueTuple<T1, T2, T3, T4, T5, T6>(item1, item2, item3, item4, item5, item6);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n+                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n+\n+                    return new ValueTuple<T1, T2, T3, T4, T5, T6>(item1, item2, item3, item4, item5, item6);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -264,15 +312,23 @@ public ValueTuple<T1, T2, T3, T4, T5, T6, T7> Deserialize(ref MessagePackReader\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n-                T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n-                T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n-                T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);\n-\n-                return new ValueTuple<T1, T2, T3, T4, T5, T6, T7>(item1, item2, item3, item4, item5, item6, item7);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n+                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n+                    T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);\n+\n+                    return new ValueTuple<T1, T2, T3, T4, T5, T6, T7>(item1, item2, item3, item4, item5, item6, item7);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }\n@@ -310,16 +366,24 @@ public ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> Deserialize(ref MessagePack\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n-                T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n-                T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n-                T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n-                T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n-                T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n-                T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n-                T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);\n-                TRest item8 = resolver.GetFormatterWithVerify<TRest>().Deserialize(ref reader, options);\n-\n-                return new ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>(item1, item2, item3, item4, item5, item6, item7, item8);\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n+                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);\n+                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);\n+                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);\n+                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);\n+                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);\n+                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);\n+                    T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);\n+                    TRest item8 = resolver.GetFormatterWithVerify<TRest>().Deserialize(ref reader, options);\n+\n+                    return new ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>(item1, item2, item3, item4, item5, item6, item7, item8);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }"
        },
        {
          "filename": "src/MessagePack/Formatters/ValueTupleFormatter.tt",
          "status": "modified",
          "additions": 10,
          "deletions": 2,
          "patch": "@@ -51,11 +51,19 @@ namespace MessagePack.Formatters\n                 }\n \n                 IFormatterResolver resolver = options.Resolver;\n+                options.Security.DepthStep(ref reader);\n+                try\n+                {\n <# for(var j = 1; j <= i; j++) { #>\n-                <#= toT(j) #> item<#= j #> = resolver.GetFormatterWithVerify<<#= toT(j) #>>().Deserialize(ref reader, options);\n+                    <#= toT(j) #> item<#= j #> = resolver.GetFormatterWithVerify<<#= toT(j) #>>().Deserialize(ref reader, options);\n <# } #>\n \n-                return new ValueTuple<<#= ts #>>(<#= string.Join(\", \", Enumerable.Range(1, i).Select(x => \"item\" + x)) #>);\n+                    return new ValueTuple<<#= ts #>>(<#= string.Join(\", \", Enumerable.Range(1, i).Select(x => \"item\" + x)) #>);\n+                }\n+                finally\n+                {\n+                    reader.Depth--;\n+                }\n             }\n         }\n     }"
        },
        {
          "filename": "src/MessagePack/PublicAPI.Unshipped.txt",
          "status": "modified",
          "additions": 19,
          "deletions": 1,
          "patch": "@@ -3,12 +3,30 @@ MessagePack.Formatters.InterfaceCollectionFormatter2<T>\n MessagePack.Formatters.InterfaceCollectionFormatter2<T>.InterfaceCollectionFormatter2() -> void\n MessagePack.Formatters.InterfaceListFormatter2<T>\n MessagePack.Formatters.InterfaceListFormatter2<T>.InterfaceListFormatter2() -> void\n+MessagePack.MessagePackReader.Depth.get -> int\n+MessagePack.MessagePackReader.Depth.set -> void\n MessagePack.MessagePackReader.ReadDateTime(MessagePack.ExtensionHeader header) -> System.DateTime\n MessagePack.MessagePackReader.TryReadArrayHeader(out int count) -> bool\n MessagePack.MessagePackReader.TryReadExtensionFormatHeader(out MessagePack.ExtensionHeader extensionHeader) -> bool\n MessagePack.MessagePackReader.TryReadMapHeader(out int count) -> bool\n+MessagePack.MessagePackSecurity\n+MessagePack.MessagePackSecurity.DepthStep(ref MessagePack.MessagePackReader reader) -> void\n+MessagePack.MessagePackSecurity.GetEqualityComparer() -> System.Collections.IEqualityComparer\n+MessagePack.MessagePackSecurity.GetEqualityComparer<T>() -> System.Collections.Generic.IEqualityComparer<T>\n+MessagePack.MessagePackSecurity.HashCollisionResistant.get -> bool\n+MessagePack.MessagePackSecurity.MaximumObjectGraphDepth.get -> int\n+MessagePack.MessagePackSecurity.MessagePackSecurity(MessagePack.MessagePackSecurity copyFrom) -> void\n+MessagePack.MessagePackSecurity.WithHashCollisionResistant(bool hashCollisionResistant) -> MessagePack.MessagePackSecurity\n+MessagePack.MessagePackSecurity.WithMaximumObjectGraphDepth(int maximumObjectGraphDepth) -> MessagePack.MessagePackSecurity\n+MessagePack.MessagePackSerializerOptions.Security.get -> MessagePack.MessagePackSecurity\n+MessagePack.MessagePackSerializerOptions.WithSecurity(MessagePack.MessagePackSecurity security) -> MessagePack.MessagePackSerializerOptions\n MessagePack.MessagePackStreamReader.DiscardBufferedData() -> void\n MessagePack.MessagePackStreamReader.MessagePackStreamReader(System.IO.Stream stream, bool leaveOpen) -> void\n MessagePack.MessagePackStreamReader.ReadArrayAsync(System.Threading.CancellationToken cancellationToken) -> System.Collections.Generic.IAsyncEnumerable<System.Buffers.ReadOnlySequence<byte>>\n MessagePack.MessagePackWriter.WriteBinHeader(int length) -> void\n-MessagePack.MessagePackWriter.WriteStringHeader(int byteCount) -> void\n\\ No newline at end of file\n+MessagePack.MessagePackWriter.WriteStringHeader(int byteCount) -> void\n+static readonly MessagePack.MessagePackSecurity.TrustedData -> MessagePack.MessagePackSecurity\n+static readonly MessagePack.MessagePackSecurity.UntrustedData -> MessagePack.MessagePackSecurity\n+virtual MessagePack.MessagePackSecurity.Clone() -> MessagePack.MessagePackSecurity\n+virtual MessagePack.MessagePackSecurity.GetHashCollisionResistantEqualityComparer() -> System.Collections.IEqualityComparer\n+virtual MessagePack.MessagePackSecurity.GetHashCollisionResistantEqualityComparer<T>() -> System.Collections.Generic.IEqualityComparer<T>"
        },
        {
          "filename": "tests/MessagePack.Tests/ExtensionTests/ImmutableCollectionTest.cs",
          "status": "modified",
          "additions": 19,
          "deletions": 18,
          "patch": "@@ -1,15 +1,8 @@\n \ufeff// Copyright (c) All contributors. All rights reserved.\n // Licensed under the MIT license. See LICENSE file in the project root for full license information.\n \n-using System;\n using System.Collections.Generic;\n using System.Collections.Immutable;\n-using System.Linq;\n-using System.Text;\n-using System.Threading.Tasks;\n-using MessagePack.Formatters;\n-using MessagePack.ImmutableCollection;\n-using MessagePack.Resolvers;\n using Xunit;\n \n namespace MessagePack.Tests.ExtensionTests\n@@ -24,20 +17,28 @@ private T Convert<T>(T value)\n \n         public static object[][] CollectionTestData = new object[][]\n         {\n-            new object[] { ImmutableList<int>.Empty.AddRange(new[] { 1, 10, 100 }), null },\n-            new object[] { ImmutableDictionary<int, int>.Empty.AddRange(new Dictionary<int, int> { { 1, 10 }, { 2, 10 }, { 3, 100 } }), null },\n-            new object[] { ImmutableHashSet<int>.Empty.Add(1).Add(10).Add(100), null },\n-            new object[] { ImmutableSortedDictionary<int, int>.Empty.AddRange(new Dictionary<int, int> { { 1, 10 }, { 2, 10 }, { 3, 100 } }), null },\n-            new object[] { ImmutableSortedSet<int>.Empty.Add(1).Add(10).Add(100), null },\n-            new object[] { ImmutableQueue<int>.Empty.Enqueue(1).Enqueue(10).Enqueue(100), null },\n-            new object[] { ImmutableStack<int>.Empty.Push(1).Push(10).Push(100), null },\n+            new object[] { true, ImmutableList<int>.Empty.AddRange(new[] { 1, 10, 100 }), null },\n+            new object[] { false, ImmutableDictionary<int, int>.Empty.AddRange(new Dictionary<int, int> { { 1, 10 }, { 2, 10 }, { 3, 100 } }), null },\n+            new object[] { false, ImmutableHashSet<int>.Empty.Add(1).Add(10).Add(100), null },\n+            new object[] { true, ImmutableSortedDictionary<int, int>.Empty.AddRange(new Dictionary<int, int> { { 1, 10 }, { 2, 10 }, { 3, 100 } }), null },\n+            new object[] { true, ImmutableSortedSet<int>.Empty.Add(1).Add(10).Add(100), null },\n+            new object[] { true, ImmutableQueue<int>.Empty.Enqueue(1).Enqueue(10).Enqueue(100), null },\n+            new object[] { true, ImmutableStack<int>.Empty.Push(1).Push(10).Push(100), null },\n         };\n \n         [Theory]\n         [MemberData(nameof(CollectionTestData))]\n-        public void ConcreteCollectionTest<T>(T x, T y)\n+        public void ConcreteCollectionTest<T>(bool ordered, T x, T y)\n         {\n-            this.Convert(x).IsStructuralEqual(x);\n+            if (ordered)\n+            {\n+                this.Convert(x).IsStructuralEqual(x);\n+            }\n+            else\n+            {\n+                this.Convert(x).IsStructuralEqualIgnoreCollectionOrder(x);\n+            }\n+\n             this.Convert(y).IsStructuralEqual(y);\n         }\n \n@@ -51,8 +52,8 @@ public void InterfaceCollectionTest()\n             IImmutableStack<int> e = ImmutableStack<int>.Empty.Push(1).Push(10).Push(100);\n \n             this.Convert(a).IsStructuralEqual(a);\n-            this.Convert(b).IsStructuralEqual(b);\n-            this.Convert(c).IsStructuralEqual(c);\n+            this.Convert(b).IsStructuralEqualIgnoreCollectionOrder(b);\n+            this.Convert(c).IsStructuralEqualIgnoreCollectionOrder(c);\n             this.Convert(d).IsStructuralEqual(d);\n             this.Convert(e).IsStructuralEqual(e);\n "
        },
        {
          "filename": "tests/MessagePack.Tests/Utils/ChainingAssertion.Xunit.cs",
          "status": "modified",
          "additions": 40,
          "deletions": 0,
          "patch": "@@ -366,6 +366,46 @@ public ReflectAccessor(T target, string name)\n \n         #region StructuralEqual\n \n+        public static void IsStructuralEqualIgnoreCollectionOrder(this object actual, object expected)\n+        {\n+            if (object.ReferenceEquals(actual, expected))\n+            {\n+                return;\n+            }\n+\n+            if (actual == null)\n+            {\n+                throw new AssertException(\"actual is null\");\n+            }\n+\n+            if (expected == null)\n+            {\n+                throw new AssertException(\"actual is not null\");\n+            }\n+\n+            Assert.Equal(expected.GetType(), actual.GetType());\n+\n+            var actualCollection = (ICollection)actual;\n+            var expectedCollection = (ICollection)expected;\n+\n+            Assert.Equal(expectedCollection.Count, actualCollection.Count);\n+            var names = new[] { actual.GetType().Name };\n+            foreach (var expectedEntry in expectedCollection)\n+            {\n+                bool matchFound = false;\n+                foreach (var actualEntry in actualCollection)\n+                {\n+                    if (StructuralEqual(actualEntry, expectedEntry, names).IsEquals)\n+                    {\n+                        matchFound = true;\n+                        break;\n+                    }\n+                }\n+\n+                Assert.True(matchFound);\n+            }\n+        }\n+\n         /// <summary>Assert by deep recursive value equality compare.</summary>\n         public static void IsStructuralEqual(this object actual, object expected, string message = \"\")\n         {"
        }
      ],
      "file_patterns": {
        "security_files": 2,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 6,
        "unique_directories": 15,
        "max_directory_depth": 6
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "eec61d68f3e3518dfe4dd8353aa62863cd527e6b",
            "date": "2025-01-09T15:57:30Z",
            "author_login": "AArnott"
          },
          {
            "sha": "cc0f394389edc492ea7d55e3a2c8c2aabd614524",
            "date": "2025-01-08T12:56:57Z",
            "author_login": "AArnott"
          },
          {
            "sha": "8373710fb0ae4bb453737f773b930401d8500c31",
            "date": "2024-12-26T09:09:17Z",
            "author_login": "github-actions[bot]"
          },
          {
            "sha": "fb8fac0d4ddde463a11d38fddd0e7da2bac97322",
            "date": "2024-12-26T09:02:48Z",
            "author_login": "neuecc"
          },
          {
            "sha": "e0e3237126ea2c74a525aea06e83cd90dc3d599a",
            "date": "2024-12-26T08:59:10Z",
            "author_login": "neuecc"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-121",
    "description": "MessagePack for C# and Unity before version 1.9.11 and 2.1.90 has a vulnerability where untrusted data can lead to DoS attack due to hash collisions and stack overflow. Review the linked GitHub Security Advisory for more information and remediation steps.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-01-31T18:15:11.860",
    "last_modified": "2024-11-21T05:33:43.930",
    "fix_date": "2020-01-30T23:32:36Z"
  },
  "references": [
    {
      "url": "https://github.com/neuecc/MessagePack-CSharp/commit/56fa86219d01d0a183babbbbcb34abbdea588a02",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/neuecc/MessagePack-CSharp/commit/f88684078698386df02204f13faeff098a61f007",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/neuecc/MessagePack-CSharp/issues/810",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/neuecc/MessagePack-CSharp/security/advisories/GHSA-7q36-4xx7-xcxf",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/neuecc/MessagePack-CSharp/commit/56fa86219d01d0a183babbbbcb34abbdea588a02",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/neuecc/MessagePack-CSharp/commit/f88684078698386df02204f13faeff098a61f007",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/neuecc/MessagePack-CSharp/issues/810",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/neuecc/MessagePack-CSharp/security/advisories/GHSA-7q36-4xx7-xcxf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:37.506041",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "MessagePack-CSharp",
    "owner": "neuecc",
    "created_at": "2017-02-13T00:58:41Z",
    "updated_at": "2025-01-14T13:03:22Z",
    "pushed_at": "2025-01-09T15:57:33Z",
    "size": 12595,
    "stars": 5928,
    "forks": 710,
    "open_issues": 77,
    "watchers": 5928,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C#": 3741869,
      "PowerShell": 37192,
      "Dockerfile": 897,
      "Batchfile": 646,
      "Visual Basic .NET": 274
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:40:29.894764"
  }
}