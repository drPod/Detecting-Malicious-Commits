{
  "cve_id": "CVE-2020-5242",
  "github_data": {
    "repository": "openhab/openhab-addons",
    "fix_commit": "4c4cb664f2e2c3866aadf117d22fb54aa8dd0031",
    "related_commits": [
      "4c4cb664f2e2c3866aadf117d22fb54aa8dd0031",
      "4c4cb664f2e2c3866aadf117d22fb54aa8dd0031"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "4c4cb664f2e2c3866aadf117d22fb54aa8dd0031",
      "commit_date": "2020-02-19T18:34:16Z",
      "author": {
        "login": "J-N-K",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-w698-693g-23hv",
        "length": 460,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 592,
        "additions": 397,
        "deletions": 195
      },
      "files": [
        {
          "filename": "bundles/org.openhab.binding.exec/README.md",
          "status": "modified",
          "additions": 10,
          "deletions": 3,
          "patch": "@@ -8,8 +8,17 @@ Currently, the binding supports a single type of Thing, being the `command` Thin\n \n ## Binding Configuration\n \n-The binding does not require any specific configuration.\n+For security reasons all commands need to be whitelisted.\n+Allowed commands need to be added to the `misc/exec.whitelist` file in the configuration directory.\n+Every command needs to be on a separate line.\n \n+Example:\n+\n+```shell\n+/bin/echo \"Hello world!\"\n+/usr/local/bin/apcaccess status\n+php ./configurations/scripts/script.php %2$s\n+```\n \n **Linux:**\n Note that the commands are executed in the context and with the privileges of the process running the Java Virtual Machine.\n@@ -27,7 +36,6 @@ It is not advised to run the virtual machine as superuser/root.\n The \"command\" Thing requires the command to execute on the shell.\n Optionally one can specify:\n \n-\n - `transform` - A [transformation](https://www.openhab.org/docs/configuration/transformations.html) to apply on the execution result string.\n - `interval` - An interval, in seconds, the command will be repeatedly executed. Default is 60 seconds, set to 0 to avoid automatic repetition.\n - `timeout` - A time-out, in seconds, the execution of the command will time out, and lastly,\n@@ -39,7 +47,6 @@ For each shell command, a separate Thing has to be defined.\n Thing exec:command:uniquename [command=\"/command/to/execute here\", interval=15, timeout=5, autorun=false]\n ```\n \n-\n The `command` itself can be enhanced using the well known syntax of the [Java formatter class syntax](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax).\n The following parameters are automatically added:\n "
        },
        {
          "filename": "bundles/org.openhab.binding.exec/src/main/java/org/openhab/binding/exec/internal/ExecBindingConstants.java",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -13,17 +13,19 @@\n package org.openhab.binding.exec.internal;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n import org.eclipse.smarthome.core.thing.ThingTypeUID;\n \n+import java.io.File;\n+\n /**\n- * The {@link ExecBinding} class defines common constants, which are\n+ * The {@link ExecBindingConstants} class defines common constants, which are\n  * used across the whole binding.\n  *\n  * @author Karel Goderis - Initial contribution\n  */\n @NonNullByDefault\n public class ExecBindingConstants {\n-\n     public static final String BINDING_ID = \"exec\";\n \n     // List of all Thing Type UIDs\n@@ -35,5 +37,4 @@ public class ExecBindingConstants {\n     public static final String EXIT = \"exit\";\n     public static final String RUN = \"run\";\n     public static final String LAST_EXECUTION = \"lastexecution\";\n-\n }"
        },
        {
          "filename": "bundles/org.openhab.binding.exec/src/main/java/org/openhab/binding/exec/internal/ExecHandlerFactory.java",
          "status": "modified",
          "additions": 17,
          "deletions": 7,
          "patch": "@@ -12,11 +12,6 @@\n  */\n package org.openhab.binding.exec.internal;\n \n-import static org.openhab.binding.exec.internal.ExecBindingConstants.THING_COMMAND;\n-\n-import java.util.Collections;\n-import java.util.Set;\n-\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.smarthome.core.thing.Thing;\n@@ -25,7 +20,16 @@\n import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n import org.openhab.binding.exec.internal.handler.ExecHandler;\n+import org.osgi.service.component.annotations.Activate;\n import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import static org.openhab.binding.exec.internal.ExecBindingConstants.THING_COMMAND;\n \n /**\n  * The {@link ExecHandlerFactory} is responsible for creating things and thing\n@@ -36,8 +40,14 @@\n @NonNullByDefault\n @Component(service = ThingHandlerFactory.class, configurationPid = \"binding.exec\")\n public class ExecHandlerFactory extends BaseThingHandlerFactory {\n-\n     private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_COMMAND);\n+    private final Logger logger = LoggerFactory.getLogger(ExecHandlerFactory.class);\n+    private final ExecWhitelistWatchService execWhitelistWatchService;\n+\n+    @Activate\n+    public ExecHandlerFactory(@Reference ExecWhitelistWatchService execWhitelistWatchService) {\n+        this.execWhitelistWatchService = execWhitelistWatchService;\n+    }\n \n     @Override\n     public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n@@ -49,7 +59,7 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n \n         if (thingTypeUID.equals(THING_COMMAND)) {\n-            return new ExecHandler(thing);\n+            return new ExecHandler(thing, execWhitelistWatchService);\n         }\n \n         return null;"
        },
        {
          "filename": "bundles/org.openhab.binding.exec/src/main/java/org/openhab/binding/exec/internal/ExecWhitelistWatchService.java",
          "status": "added",
          "additions": 81,
          "deletions": 0,
          "patch": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.exec.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.service.AbstractWatchService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.WatchEvent;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static java.nio.file.StandardWatchEventKinds.*;\n+\n+/**\n+ * The {@link ExecWhitelistWatchService} provides a whitelist check for exec commands\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@Component(service = ExecWhitelistWatchService.class)\n+@NonNullByDefault\n+public class ExecWhitelistWatchService extends AbstractWatchService {\n+    private static final String COMMAND_WHITELIST_PATH = ConfigConstants.getConfigFolder() + File.separator + \"misc\";\n+    private static final String COMMAND_WHITELIST_FILE = \"exec.whitelist\";\n+    private final Set<String> commandWhitelist = new HashSet<>();\n+\n+    @Activate\n+    public ExecWhitelistWatchService() {\n+        super(COMMAND_WHITELIST_PATH);\n+    }\n+\n+    @Override\n+    protected boolean watchSubDirectories() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected WatchEvent.Kind<?>[] getWatchEventKinds(@Nullable Path directory) {\n+        return new WatchEvent.Kind<?>[] { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };\n+    }\n+\n+    @Override\n+    protected void processWatchEvent(@Nullable WatchEvent<?> event,  WatchEvent.@Nullable Kind<?> kind, @Nullable Path path) {\n+        if (path.endsWith(COMMAND_WHITELIST_FILE)) {\n+            commandWhitelist.clear();\n+            try  {\n+                Files.lines(path).forEach(commandWhitelist::add);\n+                logger.debug(\"Updated command whitelist: {}\", commandWhitelist);\n+            } catch (IOException e) {\n+                logger.warn(\"Cannot read whitelist file, exec binding commands won't be processed: {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a command is whitelisted\n+     *\n+     * @param command the command to check alias\n+     * @return true if whitelisted, false if not\n+     */\n+    public boolean isWhitelisted(String command) {\n+        return commandWhitelist.contains(command);\n+    }\n+}"
        },
        {
          "filename": "bundles/org.openhab.binding.exec/src/main/java/org/openhab/binding/exec/internal/handler/ExecHandler.java",
          "status": "modified",
          "additions": 160,
          "deletions": 167,
          "patch": "@@ -12,22 +12,6 @@\n  */\n package org.openhab.binding.exec.internal.handler;\n \n-import static org.openhab.binding.exec.internal.ExecBindingConstants.*;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.math.BigDecimal;\n-import java.time.ZonedDateTime;\n-import java.util.Arrays;\n-import java.util.Calendar;\n-import java.util.IllegalFormatException;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.regex.PatternSyntaxException;\n-\n import org.apache.commons.lang.StringUtils;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n@@ -44,17 +28,35 @@\n import org.eclipse.smarthome.core.transform.TransformationService;\n import org.eclipse.smarthome.core.types.Command;\n import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.exec.internal.ExecWhitelistWatchService;\n import org.osgi.framework.BundleContext;\n import org.osgi.framework.FrameworkUtil;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.IllegalFormatException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.openhab.binding.exec.internal.ExecBindingConstants.*;\n+\n /**\n  * The {@link ExecHandler} is responsible for handling commands, which are\n  * sent to one of the channels.\n  *\n  * @author Karel Goderis - Initial contribution\n  * @author Constantin Piber - Added better argument support (delimiter and pass to shell)\n+ * @author Jan N. Klug - Add command whitelist check\n  */\n @NonNullByDefault\n public class ExecHandler extends BaseThingHandler {\n@@ -68,6 +70,7 @@ public class ExecHandler extends BaseThingHandler {\n      */\n     public static final String[] SHELL_WINDOWS = new String[] { \"cmd\" };\n     public static final String[] SHELL_NIX = new String[] { \"sh\", \"bash\", \"zsh\", \"csh\" };\n+    private final ExecWhitelistWatchService execWhitelistWatchService;\n \n     private Logger logger = LoggerFactory.getLogger(ExecHandler.class);\n \n@@ -88,9 +91,10 @@ public class ExecHandler extends BaseThingHandler {\n \n     private static Runtime rt = Runtime.getRuntime();\n \n-    public ExecHandler(Thing thing) {\n+    public ExecHandler(Thing thing, ExecWhitelistWatchService execWhitelistWatchService) {\n         super(thing);\n         this.bundleContext = FrameworkUtil.getBundle(ExecHandler.class).getBundleContext();\n+        this.execWhitelistWatchService = execWhitelistWatchService;\n     }\n \n     @Override\n@@ -101,18 +105,18 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n             if (channelUID.getId().equals(RUN)) {\n                 if (command instanceof OnOffType) {\n                     if (command == OnOffType.ON) {\n-                        scheduler.schedule(periodicExecutionRunnable, 0, TimeUnit.SECONDS);\n+                        scheduler.schedule(this::execute, 0, TimeUnit.SECONDS);\n                     }\n                 }\n             } else if (channelUID.getId().equals(INPUT)) {\n                 if (command instanceof StringType) {\n                     String previousInput = lastInput;\n                     lastInput = command.toString();\n                     if (lastInput != null && !lastInput.equals(previousInput)) {\n-                        if (getConfig().get(AUTORUN) != null && ((Boolean) getConfig().get(AUTORUN)).booleanValue()) {\n+                        if (getConfig().get(AUTORUN) != null && ((Boolean) getConfig().get(AUTORUN))) {\n                             logger.trace(\"Executing command '{}' after a change of the input channel to '{}'\",\n                                     getConfig().get(COMMAND), lastInput);\n-                            scheduler.schedule(periodicExecutionRunnable, 0, TimeUnit.SECONDS);\n+                            scheduler.schedule(this::execute, 0, TimeUnit.SECONDS);\n                         }\n                     }\n                 }\n@@ -123,11 +127,10 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n     @Override\n     public void initialize() {\n         if (executionJob == null || executionJob.isCancelled()) {\n-            if (((BigDecimal) getConfig().get(INTERVAL)) != null\n-                    && ((BigDecimal) getConfig().get(INTERVAL)).intValue() > 0) {\n+            if ((getConfig().get(INTERVAL)) != null && ((BigDecimal) getConfig().get(INTERVAL))\n+                    .intValue() > 0) {\n                 int pollingInterval = ((BigDecimal) getConfig().get(INTERVAL)).intValue();\n-                executionJob = scheduler.scheduleWithFixedDelay(periodicExecutionRunnable, 0, pollingInterval,\n-                        TimeUnit.SECONDS);\n+                executionJob = scheduler.scheduleWithFixedDelay(this::execute, 0, pollingInterval, TimeUnit.SECONDS);\n             }\n         }\n \n@@ -142,166 +145,161 @@ public void dispose() {\n         }\n     }\n \n-    protected Runnable periodicExecutionRunnable = new Runnable() {\n+    public void execute() {\n+        String commandLine = (String) getConfig().get(COMMAND);\n+        if (!execWhitelistWatchService.isWhitelisted(commandLine)) {\n+            logger.warn(\"Tried to execute '{}', but it is not contained in whitelist.\", commandLine);\n+            return;\n+        }\n \n-        @Override\n-        public void run() {\n-            String commandLine = (String) getConfig().get(COMMAND);\n+        int timeOut = 60000;\n+        if ((getConfig().get(TIME_OUT)) != null) {\n+            timeOut = ((BigDecimal) getConfig().get(TIME_OUT)).intValue() * 1000;\n+        }\n \n-            int timeOut = 60000;\n-            if (((BigDecimal) getConfig().get(TIME_OUT)) != null) {\n-                timeOut = ((BigDecimal) getConfig().get(TIME_OUT)).intValue() * 1000;\n-            }\n+        if (commandLine != null && !commandLine.isEmpty()) {\n+            updateState(RUN, OnOffType.ON);\n \n-            if (commandLine != null && !commandLine.isEmpty()) {\n-                updateState(RUN, OnOffType.ON);\n+            // For some obscure reason, when using Apache Common Exec, or using a straight implementation of\n+            // Runtime.Exec(), on Mac OS X (Yosemite and El Capitan), there seems to be a lock race condition\n+            // randomly appearing (on UNIXProcess) *when* one tries to gobble up the stdout and sterr output of the\n+            // subprocess in separate threads. It seems to be common \"wisdom\" to do that in separate threads, but\n+            // only when keeping everything between .exec() and .waitfor() in the same thread, this lock race\n+            // condition seems to go away. This approach of not reading the outputs in separate threads *might* be a\n+            // problem for external commands that generate a lot of output, but this will be dependent on the limits\n+            // of the underlying operating system.\n \n-                // For some obscure reason, when using Apache Common Exec, or using a straight implementation of\n-                // Runtime.Exec(), on Mac OS X (Yosemite and El Capitan), there seems to be a lock race condition\n-                // randomly appearing (on UNIXProcess) *when* one tries to gobble up the stdout and sterr output of the\n-                // subprocess in separate threads. It seems to be common \"wisdom\" to do that in separate threads, but\n-                // only when keeping everything between .exec() and .waitfor() in the same thread, this lock race\n-                // condition seems to go away. This approach of not reading the outputs in separate threads *might* be a\n-                // problem for external commands that generate a lot of output, but this will be dependent on the limits\n-                // of the underlying operating system.\n+            try {\n+                if (lastInput != null) {\n+                    commandLine = String.format(commandLine, Calendar.getInstance().getTime(), lastInput);\n+                } else {\n+                    commandLine = String.format(commandLine, Calendar.getInstance().getTime());\n+                }\n+            } catch (IllegalFormatException e) {\n+                logger.warn(\n+                        \"An exception occurred while formatting the command line with the current time and input values : '{}'\",\n+                        e.getMessage());\n+                updateState(RUN, OnOffType.OFF);\n+                updateState(OUTPUT, new StringType(e.getMessage()));\n+                return;\n+            }\n \n+            String[] cmdArray;\n+            String[] shell;\n+            if (commandLine.contains(CMD_LINE_DELIMITER)) {\n+                logger.debug(\"Splitting by '{}'\", CMD_LINE_DELIMITER);\n                 try {\n-                    if (lastInput != null) {\n-                        commandLine = String.format(commandLine, Calendar.getInstance().getTime(), lastInput);\n-                    } else {\n-                        commandLine = String.format(commandLine, Calendar.getInstance().getTime());\n-                    }\n-                } catch (IllegalFormatException e) {\n-                    logger.warn(\n-                            \"An exception occurred while formatting the command line with the current time and input values : '{}'\",\n-                            e.getMessage());\n+                    cmdArray = commandLine.split(CMD_LINE_DELIMITER);\n+                } catch (PatternSyntaxException e) {\n+                    logger.warn(\"An exception occurred while splitting '{}' : '{}'\", commandLine, e.getMessage());\n                     updateState(RUN, OnOffType.OFF);\n+                    updateState(OUTPUT, new StringType(e.getMessage()));\n                     return;\n                 }\n-\n-                String[] cmdArray;\n-                String[] shell;\n-                if (commandLine.contains(CMD_LINE_DELIMITER)) {\n-                    logger.debug(\"Splitting by '{}'\", CMD_LINE_DELIMITER);\n-                    try {\n-                        cmdArray = commandLine.split(CMD_LINE_DELIMITER);\n-                    } catch (PatternSyntaxException e) {\n-                        logger.warn(\"An exception occurred while splitting '{}' : '{}'\", commandLine, e.getMessage());\n+            } else {\n+                // Invoke shell with 'c' option and pass string\n+                logger.debug(\"Passing to shell for parsing command.\");\n+                switch (getOperatingSystemType()) {\n+                    case WINDOWS:\n+                        shell = SHELL_WINDOWS;\n+                        logger.debug(\"OS: WINDOWS ({})\", getOperatingSystemName());\n+                        cmdArray = createCmdArray(shell, \"/c\", commandLine);\n+                        break;\n+                    case LINUX:\n+                    case MAC:\n+                    case SOLARIS:\n+                        // assume sh is present, should all be POSIX-compliant\n+                        shell = SHELL_NIX;\n+                        logger.debug(\"OS: *NIX ({})\", getOperatingSystemName());\n+                        cmdArray = createCmdArray(shell, \"-c\", commandLine);\n+                        break;\n+                    default:\n+                        logger.debug(\"OS: Unknown ({})\", getOperatingSystemName());\n+                        logger.warn(\"OS {} not supported, please manually split commands!\", getOperatingSystemName());\n                         updateState(RUN, OnOffType.OFF);\n-                        updateState(OUTPUT, new StringType(e.getMessage()));\n+                        updateState(OUTPUT, new StringType(\"OS not supported, please manually split commands!\"));\n                         return;\n-                    }\n-                } else {\n-                    // Invoke shell with 'c' option and pass string\n-                    logger.debug(\"Passing to shell for parsing command.\");\n-                    switch (getOperatingSystemType()) {\n-                        case WINDOWS:\n-                            shell = SHELL_WINDOWS;\n-                            logger.debug(\"OS: WINDOWS ({})\", getOperatingSystemName());\n-                            cmdArray = createCmdArray(shell, \"/c\", commandLine);\n-                            break;\n-\n-                        case LINUX:\n-                        case MAC:\n-                        case SOLARIS:\n-                            // assume sh is present, should all be POSIX-compliant\n-                            shell = SHELL_NIX;\n-                            logger.debug(\"OS: *NIX ({})\", getOperatingSystemName());\n-                            cmdArray = createCmdArray(shell, \"-c\", commandLine);\n-\n-                        default:\n-                            logger.debug(\"OS: Unknown ({})\", getOperatingSystemName());\n-                            logger.warn(\"OS {} not supported, please manually split commands!\",\n-                                    getOperatingSystemName());\n-                            updateState(RUN, OnOffType.OFF);\n-                            updateState(OUTPUT, new StringType(\"OS not supported, please manually split commands!\"));\n-                            return;\n-                    }\n                 }\n+            }\n \n-                if (cmdArray.length == 0) {\n-                    logger.trace(\"Empty command received, not executing\");\n-                    return;\n-                }\n+            if (cmdArray.length == 0) {\n+                logger.trace(\"Empty command received, not executing\");\n+                return;\n+            }\n \n-                logger.trace(\"The command to be executed will be '{}'\", Arrays.asList(cmdArray));\n+            logger.trace(\"The command to be executed will be '{}'\", Arrays.asList(cmdArray));\n \n-                Process proc = null;\n-                try {\n-                    proc = rt.exec(cmdArray);\n-                } catch (Exception e) {\n-                    logger.warn(\"An exception occurred while executing '{}' : '{}'\", Arrays.asList(cmdArray),\n-                            e.getMessage());\n-                    updateState(RUN, OnOffType.OFF);\n-                    updateState(OUTPUT, new StringType(e.getMessage()));\n-                    return;\n-                }\n+            Process proc;\n+            try {\n+                proc = rt.exec(cmdArray);\n+            } catch (Exception e) {\n+                logger.warn(\"An exception occurred while executing '{}' : '{}'\", Arrays.asList(cmdArray),\n+                        e.getMessage());\n+                updateState(RUN, OnOffType.OFF);\n+                updateState(OUTPUT, new StringType(e.getMessage()));\n+                return;\n+            }\n \n-                StringBuilder outputBuilder = new StringBuilder();\n-                StringBuilder errorBuilder = new StringBuilder();\n+            StringBuilder outputBuilder = new StringBuilder();\n+            StringBuilder errorBuilder = new StringBuilder();\n \n-                try (InputStreamReader isr = new InputStreamReader(proc.getInputStream());\n-                        BufferedReader br = new BufferedReader(isr)) {\n-                    String line = null;\n-                    while ((line = br.readLine()) != null) {\n-                        outputBuilder.append(line).append(\"\\n\");\n-                        logger.debug(\"Exec [{}]: '{}'\", \"OUTPUT\", line);\n-                    }\n-                    isr.close();\n-                } catch (IOException e) {\n-                    logger.warn(\"An exception occurred while reading the stdout when executing '{}' : '{}'\",\n-                            commandLine, e.getMessage());\n+            try (InputStreamReader isr = new InputStreamReader(proc.getInputStream());\n+                    BufferedReader br = new BufferedReader(isr)) {\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    outputBuilder.append(line).append(\"\\n\");\n+                    logger.debug(\"Exec [{}]: '{}'\", \"OUTPUT\", line);\n                 }\n+            } catch (IOException e) {\n+                logger.warn(\"An exception occurred while reading the stdout when executing '{}' : '{}'\", commandLine,\n+                        e.getMessage());\n+            }\n \n-                try (InputStreamReader isr = new InputStreamReader(proc.getErrorStream());\n-                        BufferedReader br = new BufferedReader(isr)) {\n-                    String line = null;\n-                    while ((line = br.readLine()) != null) {\n-                        errorBuilder.append(line).append(\"\\n\");\n-                        logger.debug(\"Exec [{}]: '{}'\", \"ERROR\", line);\n-                    }\n-                    isr.close();\n-                } catch (IOException e) {\n-                    logger.warn(\"An exception occurred while reading the stderr when executing '{}' : '{}'\",\n-                            commandLine, e.getMessage());\n+            try (InputStreamReader isr = new InputStreamReader(proc.getErrorStream());\n+                    BufferedReader br = new BufferedReader(isr)) {\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    errorBuilder.append(line).append(\"\\n\");\n+                    logger.debug(\"Exec [{}]: '{}'\", \"ERROR\", line);\n                 }\n+            } catch (IOException e) {\n+                logger.warn(\"An exception occurred while reading the stderr when executing '{}' : '{}'\", commandLine,\n+                        e.getMessage());\n+            }\n \n-                boolean exitVal = false;\n-                try {\n-                    exitVal = proc.waitFor(timeOut, TimeUnit.MILLISECONDS);\n-                } catch (InterruptedException e) {\n-                    logger.warn(\"An exception occurred while waiting for the process ('{}') to finish : '{}'\",\n-                            commandLine, e.getMessage());\n-                }\n+            boolean exitVal = false;\n+            try {\n+                exitVal = proc.waitFor(timeOut, TimeUnit.MILLISECONDS);\n+            } catch (InterruptedException e) {\n+                logger.warn(\"An exception occurred while waiting for the process ('{}') to finish : '{}'\", commandLine,\n+                        e.getMessage());\n+            }\n \n-                if (!exitVal) {\n-                    logger.warn(\"Forcibly termininating the process ('{}') after a timeout of {} ms\", commandLine,\n-                            timeOut);\n-                    proc.destroyForcibly();\n-                }\n+            if (!exitVal) {\n+                logger.warn(\"Forcibly termininating the process ('{}') after a timeout of {} ms\", commandLine, timeOut);\n+                proc.destroyForcibly();\n+            }\n \n-                updateState(RUN, OnOffType.OFF);\n-                updateState(EXIT, new DecimalType(proc.exitValue()));\n+            updateState(RUN, OnOffType.OFF);\n+            updateState(EXIT, new DecimalType(proc.exitValue()));\n \n-                outputBuilder.append(errorBuilder.toString());\n+            outputBuilder.append(errorBuilder.toString());\n \n-                outputBuilder.append(errorBuilder.toString());\n+            outputBuilder.append(errorBuilder.toString());\n \n-                String transformedResponse = StringUtils.chomp(outputBuilder.toString());\n-                String transformation = (String) getConfig().get(TRANSFORM);\n+            String transformedResponse = StringUtils.chomp(outputBuilder.toString());\n+            String transformation = (String) getConfig().get(TRANSFORM);\n \n-                if (transformation != null && transformation.length() > 0) {\n-                    transformedResponse = transformResponse(transformedResponse, transformation);\n-                }\n+            if (transformation != null && transformation.length() > 0) {\n+                transformedResponse = transformResponse(transformedResponse, transformation);\n+            }\n \n-                updateState(OUTPUT, new StringType(transformedResponse));\n+            updateState(OUTPUT, new StringType(transformedResponse));\n \n-                DateTimeType stampType = new DateTimeType(ZonedDateTime.now());\n-                updateState(LAST_EXECUTION, stampType);\n-            }\n+            DateTimeType stampType = new DateTimeType(ZonedDateTime.now());\n+            updateState(LAST_EXECUTION, stampType);\n         }\n-\n-    };\n+    }\n \n     protected @Nullable String transformResponse(String response, String transformation) {\n         String transformedResponse;\n@@ -311,8 +309,8 @@ public void run() {\n             String transformationType = parts[0];\n             String transformationFunction = parts[1];\n \n-            TransformationService transformationService = TransformationHelper.getTransformationService(bundleContext,\n-                    transformationType);\n+            TransformationService transformationService = TransformationHelper\n+                    .getTransformationService(bundleContext, transformationType);\n             if (transformationService != null) {\n                 transformedResponse = transformationService.transform(transformationFunction, response);\n             } else {\n@@ -343,8 +341,8 @@ protected String[] splitTransformationConfig(String transformation) {\n         Matcher matcher = EXTRACT_FUNCTION_PATTERN.matcher(transformation);\n \n         if (!matcher.matches()) {\n-            throw new IllegalArgumentException(\"given transformation function '\" + transformation\n-                    + \"' does not follow the expected pattern '<function>(<pattern>)'\");\n+            throw new IllegalArgumentException(\n+                    \"given transformation function '\" + transformation + \"' does not follow the expected pattern '<function>(<pattern>)'\");\n         }\n         matcher.reset();\n \n@@ -361,8 +359,8 @@ protected String[] splitTransformationConfig(String transformation) {\n      * or (if command already starts with one of the shells) splits by space.\n      *\n      * @param shell (path), picks to first one to execute the command\n-     * @param \"c\"-option string\n-     * @param command to execute\n+     * @param cOption \"c\"-option string\n+     * @param commandLine to execute\n      * @return command array\n      */\n     protected String[] createCmdArray(String[] shell, String cOption, String commandLine) {\n@@ -396,13 +394,8 @@ protected String[] createCmdArray(String[] shell, String cOption, String command\n      * @author Constantin Piber (for Memin) - Initial contribution\n      */\n     public enum OS {\n-        WINDOWS,\n-        LINUX,\n-        MAC,\n-        SOLARIS,\n-        UNKNOWN,\n-        NOT_SET\n-    };\n+        WINDOWS, LINUX, MAC, SOLARIS, UNKNOWN, NOT_SET\n+    }\n \n     private static OS os = OS.NOT_SET;\n "
        },
        {
          "filename": "bundles/org.openhab.transform.exec/README.md",
          "status": "modified",
          "additions": 13,
          "deletions": 1,
          "patch": "@@ -7,6 +7,18 @@ In the given command line the placeholder `%s` is substituted with the input val\n \n The external program must either be in the executable search path of the server process, or an absolute path has to be used.\n \n+For security reasons all commands need to be whitelisted.\n+Allowed commands need to be added to the `misc/exec.whitelist` file in the configuration directory.\n+Every command needs to be on a separate line.\n+\n+Example:\n+\n+```shell\n+/bin/date -v1d -v+1m -v-1d -v-%s\n+numfmt --to=iec-i --suffix=B --padding=7 %s\n+\n+```\n+\n ## Examples\n \n ### General Setup\n@@ -51,7 +63,7 @@ Or replace it with\n numfmt --to=iec-i --suffix=B --padding=7 %s\n ```\n \n-When the input argument for `%s` is 1234567 it will return the bytes formated in a better readable form\n+When the input argument for `%s` is 1234567 it will return the bytes formatted in a better readable form\n \n ```shell\n 1.2MiB"
        },
        {
          "filename": "bundles/org.openhab.transform.exec/src/main/java/org/openhab/transform/exec/internal/ExecTransformationService.java",
          "status": "modified",
          "additions": 16,
          "deletions": 6,
          "patch": "@@ -17,35 +17,46 @@\n import org.eclipse.smarthome.core.transform.TransformationException;\n import org.eclipse.smarthome.core.transform.TransformationService;\n import org.eclipse.smarthome.io.net.exec.ExecUtil;\n+import org.osgi.service.component.annotations.Activate;\n import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n  * The implementation of {@link TransformationService} which transforms the\n  * input by command line.\n  *\n- * @author Pauli Anttila\n+ * @author Pauli Anttila - Initial contribution\n+ * @author Jan N. Klug - added command whitelist service\n  */\n @NonNullByDefault\n @Component(immediate = true, property = { \"smarthome.transform=EXEC\" })\n public class ExecTransformationService implements TransformationService {\n-\n     private final Logger logger = LoggerFactory.getLogger(ExecTransformationService.class);\n+    private final ExecTransformationWhitelistWatchService execTransformationWhitelistWatchService;\n+\n+    @Activate\n+    public ExecTransformationService(\n+            @Reference ExecTransformationWhitelistWatchService execTransformationWhitelistWatchService) {\n+        this.execTransformationWhitelistWatchService = execTransformationWhitelistWatchService; }\n \n     /**\n      * Transforms the input <code>source</code> by the command line.\n      *\n-     * @param commandLine the command to execute. Command line should contain %s string,\n-     *                        which will be replaced by the input data.\n-     * @param source      the input to transform\n+     * @param commandLine the command to execute. Command line should contain %s string, which will be replaced by the input data.\n+     * @param source the input to transform\n      */\n     @Override\n     public @Nullable String transform(String commandLine, String source) throws TransformationException {\n         if (commandLine == null || source == null) {\n             throw new TransformationException(\"the given parameters 'commandLine' and 'source' must not be null\");\n         }\n \n+        if (!execTransformationWhitelistWatchService.isWhitelisted(commandLine)) {\n+            logger.warn(\"Tried to execute '{}', but it is not contained in whitelist.\", commandLine);\n+            return null;\n+        }\n         logger.debug(\"about to transform '{}' by the commandline '{}'\", source, commandLine);\n \n         long startTime = System.currentTimeMillis();\n@@ -56,5 +67,4 @@ public class ExecTransformationService implements TransformationService {\n \n         return result;\n     }\n-\n }"
        },
        {
          "filename": "bundles/org.openhab.transform.exec/src/main/java/org/openhab/transform/exec/internal/ExecTransformationWhitelistWatchService.java",
          "status": "added",
          "additions": 81,
          "deletions": 0,
          "patch": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.transform.exec.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.service.AbstractWatchService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.WatchEvent;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static java.nio.file.StandardWatchEventKinds.*;\n+\n+/**\n+ * The {@link ExecTransformationWhitelistWatchService} provides a whitelist check for exec commands\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@Component(service = ExecTransformationWhitelistWatchService.class)\n+@NonNullByDefault\n+public class ExecTransformationWhitelistWatchService extends AbstractWatchService {\n+    private static final String COMMAND_WHITELIST_PATH = ConfigConstants.getConfigFolder() + File.separator + \"misc\";\n+    private static final String COMMAND_WHITELIST_FILE = \"exec.whitelist\";\n+    private final Set<String> commandWhitelist = new HashSet<>();\n+\n+    @Activate\n+    public ExecTransformationWhitelistWatchService() {\n+        super(COMMAND_WHITELIST_PATH);\n+    }\n+\n+    @Override\n+    protected boolean watchSubDirectories() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected WatchEvent.Kind<?>[] getWatchEventKinds(@Nullable Path directory) {\n+        return new WatchEvent.Kind<?>[] { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };\n+    }\n+\n+    @Override\n+    protected void processWatchEvent(@Nullable WatchEvent<?> event,  WatchEvent.@Nullable Kind<?> kind, @Nullable Path path) {\n+        if (path.endsWith(COMMAND_WHITELIST_FILE)) {\n+            commandWhitelist.clear();\n+            try  {\n+                Files.lines(path).forEach(commandWhitelist::add);\n+                logger.debug(\"Updated command whitelist: {}\", commandWhitelist);\n+            } catch (IOException e) {\n+                logger.warn(\"Cannot read whitelist file, exec transformations won't be processed: {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a command is whitelisted\n+     *\n+     * @param command the command to check alias\n+     * @return true if whitelisted, false if not\n+     */\n+    public boolean isWhitelisted(String command) {\n+        return commandWhitelist.contains(command);\n+    }\n+}"
        },
        {
          "filename": "bundles/org.openhab.transform.exec/src/main/java/org/openhab/transform/exec/internal/profiles/ExecTransformationProfile.java",
          "status": "modified",
          "additions": 15,
          "deletions": 8,
          "patch": "@@ -13,6 +13,7 @@\n package org.openhab.transform.exec.internal.profiles;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.smarthome.core.library.types.StringType;\n import org.eclipse.smarthome.core.thing.profiles.ProfileCallback;\n import org.eclipse.smarthome.core.thing.profiles.ProfileContext;\n@@ -31,7 +32,6 @@\n  * Profile to offer the ExecTransformationservice on a ItemChannelLink\n  *\n  * @author Stefan Triller - initial contribution\n- *\n  */\n @NonNullByDefault\n public class ExecTransformationProfile implements StateProfile {\n@@ -47,10 +47,8 @@ public class ExecTransformationProfile implements StateProfile {\n     private static final String FUNCTION_PARAM = \"function\";\n     private static final String SOURCE_FORMAT_PARAM = \"sourceFormat\";\n \n-    @NonNullByDefault({})\n-    private final String function;\n-    @NonNullByDefault({})\n-    private final String sourceFormat;\n+    private @Nullable String function;\n+    private @Nullable String sourceFormat;\n \n     public ExecTransformationProfile(ProfileCallback callback, ProfileContext context, TransformationService service) {\n         this.service = service;\n@@ -61,6 +59,7 @@ public ExecTransformationProfile(ProfileCallback callback, ProfileContext contex\n \n         logger.debug(\"Profile configured with '{}'='{}', '{}'={}\", FUNCTION_PARAM, paramFunction, SOURCE_FORMAT_PARAM,\n                 paramSource);\n+\n         // SOURCE_FORMAT_PARAM is an advanced parameter and we assume \"%s\" if it is not set\n         if (paramSource == null) {\n             paramSource = \"%s\";\n@@ -117,11 +116,19 @@ public void onStateUpdateFromHandler(State state) {\n \n     private Type transformState(Type state) {\n         String result = state.toFullString();\n-        try {\n-            result = TransformationHelper.transform(service, function, sourceFormat, state.toFullString());\n-        } catch (TransformationException e) {\n+        String function = this.function;\n+        String sourceFormat = this.sourceFormat;\n+\n+        if (function == null || sourceFormat == null) {\n             logger.warn(\"Could not transform state '{}' with function '{}' and format '{}'\", state, function,\n                     sourceFormat);\n+        } else {\n+            try {\n+                result = TransformationHelper.transform(service, function, sourceFormat, state.toFullString());\n+            } catch (TransformationException e) {\n+                logger.warn(\"Could not transform state '{}' with function '{}' and format '{}'\", state, function,\n+                        sourceFormat);\n+            }\n         }\n         StringType resultType = new StringType(result);\n         logger.debug(\"Transformed '{}' into '{}'\", state, resultType);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 6,
        "max_directory_depth": 11
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "09cf1b15af8b82f72f908721fb9537b0efacb978",
            "date": "2025-01-25T22:14:03Z",
            "author_login": "openhab-bot"
          },
          {
            "sha": "9f4deaf9103eb5f9d229a8036d55e5b59fa688e0",
            "date": "2025-01-25T13:54:52Z",
            "author_login": "jlaur"
          },
          {
            "sha": "dfb322b12c93a2a92475c3b355d5e62fea9862a1",
            "date": "2025-01-25T13:51:01Z",
            "author_login": "jlaur"
          },
          {
            "sha": "29e909eeea89d116214ffcf12e75d374cbb415fd",
            "date": "2025-01-24T22:06:33Z",
            "author_login": "jlaur"
          },
          {
            "sha": "00d15574db601ec36d5bb4b9e0fb1fb19fbb9416",
            "date": "2025-01-24T20:13:54Z",
            "author_login": "alexf2015"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.7,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:N",
    "cwe_id": "CWE-284",
    "description": "openHAB before 2.5.2 allow a remote attacker to use REST calls to install the EXEC binding or EXEC transformation service and execute arbitrary commands on the system with the privileges of the user running openHAB. Starting with version 2.5.2 all commands need to be whitelisted in a local file which cannot be changed via REST calls.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-02-20T23:15:20.723",
    "last_modified": "2024-11-21T05:33:44.923",
    "fix_date": "2020-02-19T18:34:16Z"
  },
  "references": [
    {
      "url": "https://github.com/openhab/openhab-addons/commit/4c4cb664f2e2c3866aadf117d22fb54aa8dd0031",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/openhab/openhab-addons/security/advisories/GHSA-w698-693g-23hv",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/openhab/openhab-addons/commit/4c4cb664f2e2c3866aadf117d22fb54aa8dd0031",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/openhab/openhab-addons/security/advisories/GHSA-w698-693g-23hv",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:39.860127",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "openhab-addons",
    "owner": "openhab",
    "created_at": "2014-05-13T19:41:58Z",
    "updated_at": "2025-01-25T22:31:13Z",
    "pushed_at": "2025-01-25T22:14:08Z",
    "size": 351437,
    "stars": 1918,
    "forks": 3618,
    "open_issues": 662,
    "watchers": 1918,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "2.5.x",
      "3.0.x",
      "3.1.x",
      "3.2.x",
      "3.4.x",
      "4.0.x",
      "4.1.x",
      "4.2.x",
      "4.3.x",
      "main"
    ],
    "languages": {
      "Java": 62597754,
      "JavaScript": 557917,
      "CSS": 421234,
      "HTML": 133419,
      "Groovy": 45923,
      "C++": 30357,
      "C": 18836,
      "Awk": 9404,
      "XSLT": 6282,
      "Python": 4218,
      "Shell": 1702,
      "Batchfile": 1466
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "epl-2.0"
    },
    "collected_at": "2025-01-26T08:24:11.514316"
  }
}