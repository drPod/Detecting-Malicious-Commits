{
  "cve_id": "CVE-2020-5251",
  "github_data": {
    "repository": "parse-community/parse-server",
    "fix_commit": "3a3a5eee5ffa48da1352423312cb767de14de269",
    "related_commits": [
      "3a3a5eee5ffa48da1352423312cb767de14de269",
      "3a3a5eee5ffa48da1352423312cb767de14de269"
    ],
    "patch_url": "https://github.com/parse-community/parse-server/commit/3a3a5eee5ffa48da1352423312cb767de14de269.patch",
    "fix_commit_details": {
      "sha": "3a3a5eee5ffa48da1352423312cb767de14de269",
      "commit_date": "2020-03-02T23:46:01Z",
      "author": {
        "login": "acinader",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-h4mf-75hf-67w4",
        "length": 635,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 215,
        "additions": 212,
        "deletions": 3
      },
      "files": [
        {
          "filename": "spec/RegexVulnerabilities.spec.js",
          "status": "added",
          "additions": 198,
          "deletions": 0,
          "patch": "@@ -0,0 +1,198 @@\n+const request = require('../lib/request');\n+\n+const serverURL = 'http://localhost:8378/1';\n+const headers = {\n+  'Content-Type': 'application/json',\n+};\n+const keys = {\n+  _ApplicationId: 'test',\n+  _JavaScriptKey: 'test',\n+};\n+const emailAdapter = {\n+  sendVerificationEmail: () => Promise.resolve(),\n+  sendPasswordResetEmail: () => Promise.resolve(),\n+  sendMail: () => {},\n+};\n+const appName = 'test';\n+const publicServerURL = 'http://localhost:8378/1';\n+\n+describe('Regex Vulnerabilities', function() {\n+  beforeEach(async function() {\n+    await reconfigureServer({\n+      verifyUserEmails: true,\n+      emailAdapter,\n+      appName,\n+      publicServerURL,\n+    });\n+\n+    const signUpResponse = await request({\n+      url: `${serverURL}/users`,\n+      method: 'POST',\n+      headers,\n+      body: JSON.stringify({\n+        ...keys,\n+        _method: 'POST',\n+        username: 'someemail@somedomain.com',\n+        password: 'somepassword',\n+        email: 'someemail@somedomain.com',\n+      }),\n+    });\n+    this.objectId = signUpResponse.data.objectId;\n+    this.sessionToken = signUpResponse.data.sessionToken;\n+    this.partialSessionToken = this.sessionToken.slice(0, 3);\n+  });\n+\n+  describe('on session token', function() {\n+    it('should not work with regex', async function() {\n+      try {\n+        await request({\n+          url: `${serverURL}/users/me`,\n+          method: 'POST',\n+          headers,\n+          body: JSON.stringify({\n+            ...keys,\n+            _SessionToken: {\n+              $regex: this.partialSessionToken,\n+            },\n+            _method: 'GET',\n+          }),\n+        });\n+        fail('should not work');\n+      } catch (e) {\n+        expect(e.data.code).toEqual(209);\n+        expect(e.data.error).toEqual('Invalid session token');\n+      }\n+    });\n+\n+    it('should work with plain token', async function() {\n+      const meResponse = await request({\n+        url: `${serverURL}/users/me`,\n+        method: 'POST',\n+        headers,\n+        body: JSON.stringify({\n+          ...keys,\n+          _SessionToken: this.sessionToken,\n+          _method: 'GET',\n+        }),\n+      });\n+      expect(meResponse.data.objectId).toEqual(this.objectId);\n+      expect(meResponse.data.sessionToken).toEqual(this.sessionToken);\n+    });\n+  });\n+\n+  describe('on verify e-mail', function() {\n+    beforeEach(async function() {\n+      const userQuery = new Parse.Query(Parse.User);\n+      this.user = await userQuery.get(this.objectId, { useMasterKey: true });\n+    });\n+\n+    it('should not work with regex', async function() {\n+      expect(this.user.get('emailVerified')).toEqual(false);\n+      await request({\n+        url: `${serverURL}/apps/test/verify_email?username=someemail@somedomain.com&token[$regex]=`,\n+        method: 'GET',\n+      });\n+      await this.user.fetch({ useMasterKey: true });\n+      expect(this.user.get('emailVerified')).toEqual(false);\n+    });\n+\n+    it('should work with plain token', async function() {\n+      expect(this.user.get('emailVerified')).toEqual(false);\n+      // It should work\n+      await request({\n+        url: `${serverURL}/apps/test/verify_email?username=someemail@somedomain.com&token=${this.user.get(\n+          '_email_verify_token'\n+        )}`,\n+        method: 'GET',\n+      });\n+      await this.user.fetch({ useMasterKey: true });\n+      expect(this.user.get('emailVerified')).toEqual(true);\n+    });\n+  });\n+\n+  describe('on password reset', function() {\n+    beforeEach(async function() {\n+      this.user = await Parse.User.logIn(\n+        'someemail@somedomain.com',\n+        'somepassword'\n+      );\n+    });\n+\n+    it('should not work with regex', async function() {\n+      expect(this.user.id).toEqual(this.objectId);\n+      await request({\n+        url: `${serverURL}/requestPasswordReset`,\n+        method: 'POST',\n+        headers,\n+        body: JSON.stringify({\n+          ...keys,\n+          _method: 'POST',\n+          email: 'someemail@somedomain.com',\n+        }),\n+      });\n+      await this.user.fetch({ useMasterKey: true });\n+      const passwordResetResponse = await request({\n+        url: `${serverURL}/apps/test/request_password_reset?username=someemail@somedomain.com&token[$regex]=`,\n+        method: 'GET',\n+      });\n+      expect(passwordResetResponse.status).toEqual(302);\n+      expect(passwordResetResponse.headers.location).toMatch(\n+        `\\\\/invalid\\\\_link\\\\.html`\n+      );\n+      await request({\n+        url: `${serverURL}/apps/test/request_password_reset`,\n+        method: 'POST',\n+        body: {\n+          token: { $regex: '' },\n+          username: 'someemail@somedomain.com',\n+          new_password: 'newpassword',\n+        },\n+      });\n+      try {\n+        await Parse.User.logIn('someemail@somedomain.com', 'newpassword');\n+        fail('should not work');\n+      } catch (e) {\n+        expect(e.code).toEqual(101);\n+        expect(e.message).toEqual('Invalid username/password.');\n+      }\n+    });\n+\n+    it('should work with plain token', async function() {\n+      expect(this.user.id).toEqual(this.objectId);\n+      await request({\n+        url: `${serverURL}/requestPasswordReset`,\n+        method: 'POST',\n+        headers,\n+        body: JSON.stringify({\n+          ...keys,\n+          _method: 'POST',\n+          email: 'someemail@somedomain.com',\n+        }),\n+      });\n+      await this.user.fetch({ useMasterKey: true });\n+      const token = this.user.get('_perishable_token');\n+      const passwordResetResponse = await request({\n+        url: `${serverURL}/apps/test/request_password_reset?username=someemail@somedomain.com&token=${token}`,\n+        method: 'GET',\n+      });\n+      expect(passwordResetResponse.status).toEqual(302);\n+      expect(passwordResetResponse.headers.location).toMatch(\n+        `\\\\/choose\\\\_password\\\\?token\\\\=${token}\\\\&`\n+      );\n+      await request({\n+        url: `${serverURL}/apps/test/request_password_reset`,\n+        method: 'POST',\n+        body: {\n+          token,\n+          username: 'someemail@somedomain.com',\n+          new_password: 'newpassword',\n+        },\n+      });\n+      const userAgain = await Parse.User.logIn(\n+        'someemail@somedomain.com',\n+        'newpassword'\n+      );\n+      expect(userAgain.id).toEqual(this.objectId);\n+    });\n+  });\n+});"
        },
        {
          "filename": "src/Routers/PublicAPIRouter.js",
          "status": "modified",
          "additions": 10,
          "deletions": 3,
          "patch": "@@ -11,7 +11,10 @@ const views = path.resolve(__dirname, '../../views');\n \n export class PublicAPIRouter extends PromiseRouter {\n   verifyEmail(req) {\n-    const { token, username } = req.query;\n+    const { username, token: rawToken } = req.query;\n+    const token =\n+      rawToken && typeof rawToken !== 'string' ? rawToken.toString() : rawToken;\n+\n     const appId = req.params.appId;\n     const config = Config.get(appId);\n \n@@ -122,7 +125,9 @@ export class PublicAPIRouter extends PromiseRouter {\n       return this.missingPublicServerURL();\n     }\n \n-    const { username, token } = req.query;\n+    const { username, token: rawToken } = req.query;\n+    const token =\n+      rawToken && typeof rawToken !== 'string' ? rawToken.toString() : rawToken;\n \n     if (!username || !token) {\n       return this.invalidLink(req);\n@@ -158,7 +163,9 @@ export class PublicAPIRouter extends PromiseRouter {\n       return this.missingPublicServerURL();\n     }\n \n-    const { username, token, new_password } = req.body;\n+    const { username, new_password, token: rawToken } = req.body;\n+    const token =\n+      rawToken && typeof rawToken !== 'string' ? rawToken.toString() : rawToken;\n \n     if ((!username || !token || !new_password) && req.xhr === false) {\n       return this.invalidLink(req);"
        },
        {
          "filename": "src/middlewares.js",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -105,6 +105,10 @@ export function handleParseHeaders(req, res, next) {\n     }\n   }\n \n+  if (info.sessionToken && typeof info.sessionToken !== 'string') {\n+    info.sessionToken = info.sessionToken.toString();\n+  }\n+\n   if (info.clientVersion) {\n     info.clientSDK = ClientSDK.fromString(info.clientVersion);\n   }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "28b3edee4e76679dedee9fe115283110fd952678",
            "date": "2025-01-13T15:19:51Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "1b61cab81c4206ce135f1239f17a53dabbc698d7",
            "date": "2025-01-13T14:47:17Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "a0efad88d2177f027ee3709beba13282a6ca9d35",
            "date": "2025-01-12T20:55:48Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "bb1daafef0f5f0b6a9c9b33c9d7e0529fd49afbf",
            "date": "2025-01-12T18:53:43Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "3f0f29b4dfaf6038cb0f0dd205cfa8e1cf92c0c4",
            "date": "2025-01-12T14:04:34Z",
            "author_login": "semantic-release-bot"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.7,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:N",
    "cwe_id": "CWE-285",
    "description": "In parser-server before version 4.1.0, you can fetch all the users objects, by using regex in the NoSQL query. Using the NoSQL, you can use a regex on sessionToken and find valid accounts this way.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-03-04T15:15:13.210",
    "last_modified": "2024-11-21T05:33:46.063",
    "fix_date": "2020-03-02T23:46:01Z"
  },
  "references": [
    {
      "url": "https://github.com/parse-community/parse-server/commit/3a3a5eee5ffa48da1352423312cb767de14de269",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-h4mf-75hf-67w4",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/commit/3a3a5eee5ffa48da1352423312cb767de14de269",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-h4mf-75hf-67w4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:39.875738",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "parse-server",
    "owner": "parse-community",
    "created_at": "2016-01-28T18:29:14Z",
    "updated_at": "2025-01-13T16:51:06Z",
    "pushed_at": "2025-01-14T11:16:34Z",
    "size": 73208,
    "stars": 20994,
    "forks": 4781,
    "open_issues": 474,
    "watchers": 20994,
    "has_security_policy": false,
    "default_branch": "alpha",
    "protected_branches": [
      "alpha",
      "beta",
      "release",
      "release-4.x.x",
      "release-5.x.x",
      "release-6.x.x",
      "release-7.x.x"
    ],
    "languages": {
      "JavaScript": 4248231,
      "HTML": 25876,
      "Shell": 7825,
      "Handlebars": 2113,
      "Dockerfile": 1211
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:26:59.166995"
  }
}