{
  "cve_id": "CVE-2020-5261",
  "github_data": {
    "repository": "Sustainsys/Saml2",
    "fix_commit": "e58e0a1aff2b1ead6aca080b7cdced55ee6d5241",
    "related_commits": [
      "e58e0a1aff2b1ead6aca080b7cdced55ee6d5241",
      "e58e0a1aff2b1ead6aca080b7cdced55ee6d5241"
    ],
    "patch_url": "https://github.com/Sustainsys/Saml2/commit/e58e0a1aff2b1ead6aca080b7cdced55ee6d5241.patch",
    "fix_commit_details": {
      "sha": "e58e0a1aff2b1ead6aca080b7cdced55ee6d5241",
      "commit_date": "2020-03-18T07:01:41Z",
      "author": {
        "login": "AndersAbel",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix token replay detection",
        "length": 53,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 90,
        "additions": 55,
        "deletions": 35
      },
      "files": [
        {
          "filename": "Sustainsys.Saml2/Configuration/SPOptions.cs",
          "status": "modified",
          "additions": 31,
          "deletions": 12,
          "patch": "@@ -1,5 +1,7 @@\n-\ufeffusing Sustainsys.Saml2.Metadata;\n+\ufeffusing Microsoft.IdentityModel.Tokens;\n+using Sustainsys.Saml2.Metadata;\n using Sustainsys.Saml2.Saml2P;\n+using Sustainsys.Saml2.Tokens;\n using System;\n using System.Collections.Concurrent;\n using System.Collections.Generic;\n@@ -22,7 +24,7 @@ public class SPOptions\n         /// </summary>\n         public SPOptions()\n         {\n-\t\t\tMetadataCacheDuration = new XsdDuration(hours: 1);\n+            MetadataCacheDuration = new XsdDuration(hours: 1);\n             Compatibility = new Compatibility();\n             OutboundSigningAlgorithm = XmlHelpers.GetDefaultSigningAlgorithmName();\n             MinIncomingSigningAlgorithm = XmlHelpers.GetDefaultSigningAlgorithmName();\n@@ -102,7 +104,7 @@ public Saml2PSecurityTokenHandler Saml2PSecurityTokenHandler\n                 // Capture in a local variable to prevent race conditions. Reads and writes\n                 // of references are atomic so there is no need for a lock.\n                 var value = saml2PSecurityTokenHandler;\n-                if(value == null)\n+                if (value == null)\n                 {\n                     // Set the saved value, but don't trust it - still use a local var for the return.\n                     saml2PSecurityTokenHandler = value = new Saml2PSecurityTokenHandler(this);\n@@ -112,7 +114,7 @@ public Saml2PSecurityTokenHandler Saml2PSecurityTokenHandler\n             }\n             set\n             {\n-                saml2PSecurityTokenHandler = value; \n+                saml2PSecurityTokenHandler = value;\n             }\n         }\n \n@@ -135,7 +137,7 @@ public EntityId EntityId\n             }\n             set\n             {\n-                if(saml2PSecurityTokenHandler != null)\n+                if (saml2PSecurityTokenHandler != null)\n                 {\n                     throw new InvalidOperationException(\"Can't change entity id when a token handler has been instantiated.\");\n                 }\n@@ -157,7 +159,7 @@ public string ModulePath\n             }\n             set\n             {\n-                if(value == null)\n+                if (value == null)\n                 {\n                     throw new ArgumentNullException(nameof(value));\n                 }\n@@ -212,7 +214,7 @@ public ICollection<ContactPerson> Contacts\n         }\n \n         readonly ICollection<AttributeConsumingService> attributeConsumingServices\n-\t\t\t= new List<AttributeConsumingService>();\n+            = new List<AttributeConsumingService>();\n \n         /// <summary>\n         /// Collection of attribute consuming services for the service provider.\n@@ -292,7 +294,7 @@ public ReadOnlyCollection<ServiceCertificate> MetadataCertificates\n                 var futureBothCertExists = metaDataCertificates\n                     .Any(c => c.Status == CertificateStatus.Future && c.Use == CertificateUse.Both);\n \n-                foreach(var cert in metaDataCertificates)\n+                foreach (var cert in metaDataCertificates)\n                 {\n                     // Just like we stop publishing Encryption cert immediately when a Future one is added,\n                     // in the case of a \"Both\" cert we should switch the current use to Signing so that Idp's stop sending\n@@ -358,7 +360,7 @@ private IEnumerable<ServiceCertificate> PublishableServiceCertificates\n         /// overriden for each <see cref=\"IdentityProvider\"/>.\n         /// </summary>\n         public string OutboundSigningAlgorithm { get; set; }\n-        \n+\n         /// <summary>\n         /// Metadata flag that we want assertions to be signed.\n         /// </summary>\n@@ -379,7 +381,7 @@ private IEnumerable<ServiceCertificate> PublishableServiceCertificates\n         public Compatibility Compatibility { get; set; }\n \n         private string minIncomingSigningAlgorithm;\n-        \n+\n         /// <summary>\n         /// Minimum accepted signature algorithm for any incoming messages.\n         /// </summary>\n@@ -391,7 +393,7 @@ public string MinIncomingSigningAlgorithm\n             }\n             set\n             {\n-                if(!XmlHelpers.KnownSigningAlgorithms.Contains(value))\n+                if (!XmlHelpers.KnownSigningAlgorithms.Contains(value))\n                 {\n                     throw new ArgumentException(\"The signing algorithm \" + value +\n                         \" is unknown or not supported by the current .NET Framework.\");\n@@ -404,5 +406,22 @@ public string MinIncomingSigningAlgorithm\n         /// Adapter to logging framework of hosting application.\n         /// </summary>\n         public ILoggerAdapter Logger { get; set; }\n-    }\n+\n+        private ITokenReplayCache tokenReplayCache;\n+        public ITokenReplayCache TokenReplayCache \n+        { \n+            get\n+            {\n+                if(tokenReplayCache == null)\n+                {\n+                    tokenReplayCache = new TokenReplayCache();\n+                }\n+                return tokenReplayCache;\n+            }\n+            set\n+            {\n+                tokenReplayCache = value;\n+            }\n+        }\n+}\n }"
        },
        {
          "filename": "Sustainsys.Saml2/SAML2P/Saml2PSecurityTokenHandler.cs",
          "status": "modified",
          "additions": 21,
          "deletions": 17,
          "patch": "@@ -28,19 +28,6 @@ public Saml2PSecurityTokenHandler(SPOptions spOptions)\n \t\t\tSerializer = new Saml2PSerializer(spOptions);\n \t\t}\n \n-\t\t// Overridden to fix the fact that the base class version uses NotBefore as the token replay expiry time\n-\t\t// Due to the fact that we can't override the ValidateToken function (it's overridden in the base class!)\n-\t\t// we have to parse the token again.\n-\t\t// This can be removed when:\n-\t\t// https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/898\n-\t\t// is fixed.\n-\t\tprotected override void ValidateTokenReplay(DateTime? expirationTime, string securityToken, TokenValidationParameters validationParameters)\n-\t\t{\n-\t\t\tvar saml2Token = ReadSaml2Token(securityToken);\n-\t\t\tbase.ValidateTokenReplay(saml2Token.Assertion.Conditions.NotOnOrAfter,\n-\t\t\t\tsecurityToken, validationParameters);\n-\t\t}\n-\n \t\t// TODO: needed with Microsoft.identitymodel?\n \t\t/// <summary>\n \t\t/// Process authentication statement from SAML assertion. WIF chokes if the authentication statement \n@@ -84,10 +71,27 @@ protected override void ProcessAuthenticationStatement(Saml2AuthenticationStatem\n             }\n         }\n \n-\t\tprotected override Saml2SecurityToken ValidateSignature(string token, TokenValidationParameters validationParameters)\n+\t\t// Override and build our own logic. The problem is ValidateTokenReplay that serializes the token back. And that\n+\t\t// breaks because it expects some optional values to be present.\n+\t\tpublic override ClaimsPrincipal ValidateToken(string token, TokenValidationParameters validationParameters, out Microsoft.IdentityModel.Tokens.SecurityToken validatedToken)\n \t\t{\n-\t\t\t// Just skip signature validation -- we do this elsewhere\n-\t\t\treturn ReadSaml2Token(token);\n+\t\t\tvar samlToken = ReadSaml2Token(token);\n+\n+\t\t\tValidateConditions(samlToken, validationParameters);\n+\t\t\tValidateSubject(samlToken, validationParameters);\n+\n+\t\t\tvar issuer = ValidateIssuer(samlToken.Issuer, samlToken, validationParameters);\n+\n+\t\t\t// Just using the assertion id for token replay. As that is part of the signed value it cannot\n+\t\t\t// be altered by someone replaying the token.\n+\t\t\tValidateTokenReplay(samlToken.Assertion.Conditions.NotOnOrAfter, samlToken.Assertion.Id.Value, validationParameters);\n+\n+\t\t\t// ValidateIssuerSecurityKey not called - we have our own signature validation.\n+\n+\t\t\tvalidatedToken = samlToken;\n+\t\t\tvar identity = CreateClaimsIdentity(samlToken, issuer, validationParameters);\n+\n+\t\t\treturn new ClaimsPrincipal(identity);\n \t\t}\n-    }\n+\t}\n }"
        },
        {
          "filename": "Sustainsys.Saml2/SAML2P/Saml2Response.cs",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -597,6 +597,9 @@ private IEnumerable<ClaimsIdentity> CreateClaims(IOptions options, IdentityProvi\n \t\t\tvalidationParameters.RequireSignedTokens = false;\n \t\t\tvalidationParameters.ValidateIssuer = false;\n             validationParameters.ValidAudience = options.SPOptions.EntityId.Id;\n+            validationParameters.RequireAudience = false; // Audience restriction optional in SAML2 spec.\n+            validationParameters.TokenReplayCache = options.SPOptions.TokenReplayCache;\n+            validationParameters.ValidateTokenReplay = true;\n \n             options.Notifications.Unsafe.TokenValidationParametersCreated(validationParameters, idp, XmlElement);\n "
        },
        {
          "filename": "Tests/Tests.Shared/Saml2P/Saml2ResponseTests.cs",
          "status": "modified",
          "additions": 0,
          "deletions": 4,
          "patch": "@@ -1918,8 +1918,6 @@ public void Saml2Response_GetClaims_ThrowsOnWeakSigningAlgoritm()\n         [TestMethod]\n         public void Saml2Response_GetClaims_ThrowsOnReplayAssertionId()\n         {\n-            Assert.Inconclusive(\"Deliberately ignored test for now\");\n-\n             var response =\n             @\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\"?>\n             <saml2p:Response xmlns:saml2p=\"\"urn:oasis:names:tc:SAML:2.0:protocol\"\"\n@@ -1955,8 +1953,6 @@ public void Saml2Response_GetClaims_ThrowsOnReplayAssertionId()\n         [TestMethod]\n         public void Saml2Response_GetClaims_ThrowsOnReplayAssertionIdSameConfig()\n         {\n-            Assert.Inconclusive(\"Ingored for now\");\n-\n             var response =\n             @\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\"?>\n             <saml2p:Response xmlns:saml2p=\"\"urn:oasis:names:tc:SAML:2.0:protocol\"\""
        },
        {
          "filename": "Tests/Tests.Shared/WebSSO/Saml2ArtifactBindingTests.cs",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -139,8 +139,6 @@ public void Saml2ArtifactBinding_Unbind_FromGet_ArtifactIsntHashOfEntityId()\n                 null,\n                 new StoredRequestState(issuer, null, null, null));\n \n-            StubServer.LastArtifactResolutionSoapActionHeader = null;\n-\n             var result = Saml2Binding.Get(Saml2BindingType.Artifact).Unbind(r, StubFactory.CreateOptions());\n \n             var xmlDocument = XmlHelpers.XmlDocumentFromString("
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7acac85ce60e5e486fcc033f8a47bf67513dd0a6",
            "date": "2024-12-05T08:00:18Z",
            "author_login": "AndersAbel"
          },
          {
            "sha": "50654a7b3b41aaf4889e4256311aaf6860dd986c",
            "date": "2024-05-16T07:38:33Z",
            "author_login": "AndersAbel"
          },
          {
            "sha": "9e96e5901fa1125553ab85bd6f765147ebfc0ee7",
            "date": "2024-05-15T12:00:21Z",
            "author_login": "AndersAbel"
          },
          {
            "sha": "425891b702065682c81a11e0886ae74590bb0818",
            "date": "2024-03-12T18:30:35Z",
            "author_login": "FinHorsley"
          },
          {
            "sha": "735b748716f8fca1ec0e897d5e17204fa5a9c513",
            "date": "2024-02-12T21:15:08Z",
            "author_login": "AndersAbel"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.2,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:N",
    "cwe_id": "CWE-294",
    "description": "Saml2 Authentication services for ASP.NET (NuGet package Sustainsys.Saml2) greater than 2.0.0, and less than version 2.5.0 has a faulty implementation of Token Replay Detection. Token Replay Detection is an important defence in depth measure for Single Sign On solutions. The 2.5.0 version is patched. Note that version 1.0.1 is not affected. It has a correct Token Replay Implementation and is safe to use. Saml2 Authentication services for ASP.NET (NuGet package Sustainsys.Saml2) greater than 2.0.0, and less than version 2.5.0 have a faulty implementation of Token Replay Detection. Token Replay Detection is an important defense measure for Single Sign On solutions. The 2.5.0 version is patched. Note that version 1.0.1 and prior versions are not affected. These versions have a correct Token Replay Implementation and are safe to use.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-03-25T02:15:11.427",
    "last_modified": "2024-11-21T05:33:47.420",
    "fix_date": "2020-03-18T07:01:41Z"
  },
  "references": [
    {
      "url": "https://github.com/Sustainsys/Saml2/commit/e58e0a1aff2b1ead6aca080b7cdced55ee6d5241",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Sustainsys/Saml2/issues/711",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Sustainsys/Saml2/security/advisories/GHSA-g6j2-ch25-5mmv",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Sustainsys/Saml2/commit/e58e0a1aff2b1ead6aca080b7cdced55ee6d5241",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Sustainsys/Saml2/issues/711",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Sustainsys/Saml2/security/advisories/GHSA-g6j2-ch25-5mmv",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:42.283742",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "Saml2",
    "owner": "Sustainsys",
    "created_at": "2013-09-16T10:36:25Z",
    "updated_at": "2025-01-10T09:23:54Z",
    "pushed_at": "2024-12-05T08:00:18Z",
    "size": 10193,
    "stars": 966,
    "forks": 605,
    "open_issues": 97,
    "watchers": 966,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "develop"
    ],
    "languages": {
      "C#": 226493,
      "HTML": 659
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:55:51.490796"
  }
}