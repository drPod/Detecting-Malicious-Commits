{
  "cve_id": "CVE-2020-5268",
  "github_data": {
    "repository": "Sustainsys/Saml2",
    "fix_commit": "e58e0a1aff2b1ead6aca080b7cdced55ee6d5241",
    "related_commits": [
      "e58e0a1aff2b1ead6aca080b7cdced55ee6d5241",
      "e58e0a1aff2b1ead6aca080b7cdced55ee6d5241"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "e58e0a1aff2b1ead6aca080b7cdced55ee6d5241",
      "commit_date": "2020-03-18T07:01:41Z",
      "author": {
        "login": "AndersAbel",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix token replay detection",
        "length": 53,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 90,
        "additions": 55,
        "deletions": 35
      },
      "files": [
        {
          "filename": "Sustainsys.Saml2/Configuration/SPOptions.cs",
          "status": "modified",
          "additions": 31,
          "deletions": 12,
          "patch": "@@ -1,5 +1,7 @@\n-\ufeffusing Sustainsys.Saml2.Metadata;\n+\ufeffusing Microsoft.IdentityModel.Tokens;\n+using Sustainsys.Saml2.Metadata;\n using Sustainsys.Saml2.Saml2P;\n+using Sustainsys.Saml2.Tokens;\n using System;\n using System.Collections.Concurrent;\n using System.Collections.Generic;\n@@ -22,7 +24,7 @@ public class SPOptions\n         /// </summary>\n         public SPOptions()\n         {\n-\t\t\tMetadataCacheDuration = new XsdDuration(hours: 1);\n+            MetadataCacheDuration = new XsdDuration(hours: 1);\n             Compatibility = new Compatibility();\n             OutboundSigningAlgorithm = XmlHelpers.GetDefaultSigningAlgorithmName();\n             MinIncomingSigningAlgorithm = XmlHelpers.GetDefaultSigningAlgorithmName();\n@@ -102,7 +104,7 @@ public Saml2PSecurityTokenHandler Saml2PSecurityTokenHandler\n                 // Capture in a local variable to prevent race conditions. Reads and writes\n                 // of references are atomic so there is no need for a lock.\n                 var value = saml2PSecurityTokenHandler;\n-                if(value == null)\n+                if (value == null)\n                 {\n                     // Set the saved value, but don't trust it - still use a local var for the return.\n                     saml2PSecurityTokenHandler = value = new Saml2PSecurityTokenHandler(this);\n@@ -112,7 +114,7 @@ public Saml2PSecurityTokenHandler Saml2PSecurityTokenHandler\n             }\n             set\n             {\n-                saml2PSecurityTokenHandler = value; \n+                saml2PSecurityTokenHandler = value;\n             }\n         }\n \n@@ -135,7 +137,7 @@ public EntityId EntityId\n             }\n             set\n             {\n-                if(saml2PSecurityTokenHandler != null)\n+                if (saml2PSecurityTokenHandler != null)\n                 {\n                     throw new InvalidOperationException(\"Can't change entity id when a token handler has been instantiated.\");\n                 }\n@@ -157,7 +159,7 @@ public string ModulePath\n             }\n             set\n             {\n-                if(value == null)\n+                if (value == null)\n                 {\n                     throw new ArgumentNullException(nameof(value));\n                 }\n@@ -212,7 +214,7 @@ public ICollection<ContactPerson> Contacts\n         }\n \n         readonly ICollection<AttributeConsumingService> attributeConsumingServices\n-\t\t\t= new List<AttributeConsumingService>();\n+            = new List<AttributeConsumingService>();\n \n         /// <summary>\n         /// Collection of attribute consuming services for the service provider.\n@@ -292,7 +294,7 @@ public ReadOnlyCollection<ServiceCertificate> MetadataCertificates\n                 var futureBothCertExists = metaDataCertificates\n                     .Any(c => c.Status == CertificateStatus.Future && c.Use == CertificateUse.Both);\n \n-                foreach(var cert in metaDataCertificates)\n+                foreach (var cert in metaDataCertificates)\n                 {\n                     // Just like we stop publishing Encryption cert immediately when a Future one is added,\n                     // in the case of a \"Both\" cert we should switch the current use to Signing so that Idp's stop sending\n@@ -358,7 +360,7 @@ private IEnumerable<ServiceCertificate> PublishableServiceCertificates\n         /// overriden for each <see cref=\"IdentityProvider\"/>.\n         /// </summary>\n         public string OutboundSigningAlgorithm { get; set; }\n-        \n+\n         /// <summary>\n         /// Metadata flag that we want assertions to be signed.\n         /// </summary>\n@@ -379,7 +381,7 @@ private IEnumerable<ServiceCertificate> PublishableServiceCertificates\n         public Compatibility Compatibility { get; set; }\n \n         private string minIncomingSigningAlgorithm;\n-        \n+\n         /// <summary>\n         /// Minimum accepted signature algorithm for any incoming messages.\n         /// </summary>\n@@ -391,7 +393,7 @@ public string MinIncomingSigningAlgorithm\n             }\n             set\n             {\n-                if(!XmlHelpers.KnownSigningAlgorithms.Contains(value))\n+                if (!XmlHelpers.KnownSigningAlgorithms.Contains(value))\n                 {\n                     throw new ArgumentException(\"The signing algorithm \" + value +\n                         \" is unknown or not supported by the current .NET Framework.\");\n@@ -404,5 +406,22 @@ public string MinIncomingSigningAlgorithm\n         /// Adapter to logging framework of hosting application.\n         /// </summary>\n         public ILoggerAdapter Logger { get; set; }\n-    }\n+\n+        private ITokenReplayCache tokenReplayCache;\n+        public ITokenReplayCache TokenReplayCache \n+        { \n+            get\n+            {\n+                if(tokenReplayCache == null)\n+                {\n+                    tokenReplayCache = new TokenReplayCache();\n+                }\n+                return tokenReplayCache;\n+            }\n+            set\n+            {\n+                tokenReplayCache = value;\n+            }\n+        }\n+}\n }"
        },
        {
          "filename": "Sustainsys.Saml2/SAML2P/Saml2PSecurityTokenHandler.cs",
          "status": "modified",
          "additions": 21,
          "deletions": 17,
          "patch": "@@ -28,19 +28,6 @@ public Saml2PSecurityTokenHandler(SPOptions spOptions)\n \t\t\tSerializer = new Saml2PSerializer(spOptions);\n \t\t}\n \n-\t\t// Overridden to fix the fact that the base class version uses NotBefore as the token replay expiry time\n-\t\t// Due to the fact that we can't override the ValidateToken function (it's overridden in the base class!)\n-\t\t// we have to parse the token again.\n-\t\t// This can be removed when:\n-\t\t// https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/898\n-\t\t// is fixed.\n-\t\tprotected override void ValidateTokenReplay(DateTime? expirationTime, string securityToken, TokenValidationParameters validationParameters)\n-\t\t{\n-\t\t\tvar saml2Token = ReadSaml2Token(securityToken);\n-\t\t\tbase.ValidateTokenReplay(saml2Token.Assertion.Conditions.NotOnOrAfter,\n-\t\t\t\tsecurityToken, validationParameters);\n-\t\t}\n-\n \t\t// TODO: needed with Microsoft.identitymodel?\n \t\t/// <summary>\n \t\t/// Process authentication statement from SAML assertion. WIF chokes if the authentication statement \n@@ -84,10 +71,27 @@ protected override void ProcessAuthenticationStatement(Saml2AuthenticationStatem\n             }\n         }\n \n-\t\tprotected override Saml2SecurityToken ValidateSignature(string token, TokenValidationParameters validationParameters)\n+\t\t// Override and build our own logic. The problem is ValidateTokenReplay that serializes the token back. And that\n+\t\t// breaks because it expects some optional values to be present.\n+\t\tpublic override ClaimsPrincipal ValidateToken(string token, TokenValidationParameters validationParameters, out Microsoft.IdentityModel.Tokens.SecurityToken validatedToken)\n \t\t{\n-\t\t\t// Just skip signature validation -- we do this elsewhere\n-\t\t\treturn ReadSaml2Token(token);\n+\t\t\tvar samlToken = ReadSaml2Token(token);\n+\n+\t\t\tValidateConditions(samlToken, validationParameters);\n+\t\t\tValidateSubject(samlToken, validationParameters);\n+\n+\t\t\tvar issuer = ValidateIssuer(samlToken.Issuer, samlToken, validationParameters);\n+\n+\t\t\t// Just using the assertion id for token replay. As that is part of the signed value it cannot\n+\t\t\t// be altered by someone replaying the token.\n+\t\t\tValidateTokenReplay(samlToken.Assertion.Conditions.NotOnOrAfter, samlToken.Assertion.Id.Value, validationParameters);\n+\n+\t\t\t// ValidateIssuerSecurityKey not called - we have our own signature validation.\n+\n+\t\t\tvalidatedToken = samlToken;\n+\t\t\tvar identity = CreateClaimsIdentity(samlToken, issuer, validationParameters);\n+\n+\t\t\treturn new ClaimsPrincipal(identity);\n \t\t}\n-    }\n+\t}\n }"
        },
        {
          "filename": "Sustainsys.Saml2/SAML2P/Saml2Response.cs",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -597,6 +597,9 @@ private IEnumerable<ClaimsIdentity> CreateClaims(IOptions options, IdentityProvi\n \t\t\tvalidationParameters.RequireSignedTokens = false;\n \t\t\tvalidationParameters.ValidateIssuer = false;\n             validationParameters.ValidAudience = options.SPOptions.EntityId.Id;\n+            validationParameters.RequireAudience = false; // Audience restriction optional in SAML2 spec.\n+            validationParameters.TokenReplayCache = options.SPOptions.TokenReplayCache;\n+            validationParameters.ValidateTokenReplay = true;\n \n             options.Notifications.Unsafe.TokenValidationParametersCreated(validationParameters, idp, XmlElement);\n "
        },
        {
          "filename": "Tests/Tests.Shared/Saml2P/Saml2ResponseTests.cs",
          "status": "modified",
          "additions": 0,
          "deletions": 4,
          "patch": "@@ -1918,8 +1918,6 @@ public void Saml2Response_GetClaims_ThrowsOnWeakSigningAlgoritm()\n         [TestMethod]\n         public void Saml2Response_GetClaims_ThrowsOnReplayAssertionId()\n         {\n-            Assert.Inconclusive(\"Deliberately ignored test for now\");\n-\n             var response =\n             @\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\"?>\n             <saml2p:Response xmlns:saml2p=\"\"urn:oasis:names:tc:SAML:2.0:protocol\"\"\n@@ -1955,8 +1953,6 @@ public void Saml2Response_GetClaims_ThrowsOnReplayAssertionId()\n         [TestMethod]\n         public void Saml2Response_GetClaims_ThrowsOnReplayAssertionIdSameConfig()\n         {\n-            Assert.Inconclusive(\"Ingored for now\");\n-\n             var response =\n             @\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\"?>\n             <saml2p:Response xmlns:saml2p=\"\"urn:oasis:names:tc:SAML:2.0:protocol\"\""
        },
        {
          "filename": "Tests/Tests.Shared/WebSSO/Saml2ArtifactBindingTests.cs",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -139,8 +139,6 @@ public void Saml2ArtifactBinding_Unbind_FromGet_ArtifactIsntHashOfEntityId()\n                 null,\n                 new StoredRequestState(issuer, null, null, null));\n \n-            StubServer.LastArtifactResolutionSoapActionHeader = null;\n-\n             var result = Saml2Binding.Get(Saml2BindingType.Artifact).Unbind(r, StubFactory.CreateOptions());\n \n             var xmlDocument = XmlHelpers.XmlDocumentFromString("
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7acac85ce60e5e486fcc033f8a47bf67513dd0a6",
            "date": "2024-12-05T08:00:18Z",
            "author_login": "AndersAbel"
          },
          {
            "sha": "50654a7b3b41aaf4889e4256311aaf6860dd986c",
            "date": "2024-05-16T07:38:33Z",
            "author_login": "AndersAbel"
          },
          {
            "sha": "9e96e5901fa1125553ab85bd6f765147ebfc0ee7",
            "date": "2024-05-15T12:00:21Z",
            "author_login": "AndersAbel"
          },
          {
            "sha": "425891b702065682c81a11e0886ae74590bb0818",
            "date": "2024-03-12T18:30:35Z",
            "author_login": "FinHorsley"
          },
          {
            "sha": "735b748716f8fca1ec0e897d5e17204fa5a9c513",
            "date": "2024-02-12T21:15:08Z",
            "author_login": "AndersAbel"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:L/A:N",
    "cwe_id": "CWE-303",
    "description": "In Saml2 Authentication Services for ASP.NET versions before 1.0.2, and between 2.0.0 and 2.6.0, there is a vulnerability in how tokens are validated in some cases. Saml2 tokens are usually used as bearer tokens - a caller that presents a token is assumed to be the subject of the token. There is also support in the Saml2 protocol for issuing tokens that is tied to a subject through other means, e.g. holder-of-key where possession of a private key must be proved. The Sustainsys.Saml2 library incorrectly treats all incoming tokens as bearer tokens, even though they have another subject confirmation method specified. This could be used by an attacker that could get access to Saml2 tokens with another subject confirmation method than bearer. The attacker could then use such a token to create a log in session. This vulnerability is patched in versions 1.0.2 and 2.7.0.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-04-21T17:15:13.053",
    "last_modified": "2024-11-21T05:33:48.237",
    "fix_date": "2020-03-18T07:01:41Z"
  },
  "references": [
    {
      "url": "https://github.com/Sustainsys/Saml2/commit/e58e0a1aff2b1ead6aca080b7cdced55ee6d5241",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Sustainsys/Saml2/issues/712",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Sustainsys/Saml2/security/advisories/GHSA-9475-xg6m-j7pw",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.nuget.org/packages/Sustainsys.Saml2/",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Sustainsys/Saml2/commit/e58e0a1aff2b1ead6aca080b7cdced55ee6d5241",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Sustainsys/Saml2/issues/712",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Sustainsys/Saml2/security/advisories/GHSA-9475-xg6m-j7pw",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.nuget.org/packages/Sustainsys.Saml2/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:44.950829",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "Saml2",
    "owner": "Sustainsys",
    "created_at": "2013-09-16T10:36:25Z",
    "updated_at": "2025-01-22T19:53:21Z",
    "pushed_at": "2024-12-05T08:00:18Z",
    "size": 10193,
    "stars": 968,
    "forks": 605,
    "open_issues": 96,
    "watchers": 968,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "develop"
    ],
    "languages": {
      "C#": 226493,
      "HTML": 659
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T07:35:03.218014"
  }
}