{
  "cve_id": "CVE-2020-5303",
  "github_data": {
    "repository": "tendermint/tendermint",
    "fix_commit": "e2d6859afd7dba4cf97c7f7d412e7d8fc908d1cd",
    "related_commits": [
      "e2d6859afd7dba4cf97c7f7d412e7d8fc908d1cd",
      "e2d6859afd7dba4cf97c7f7d412e7d8fc908d1cd"
    ],
    "patch_url": "https://github.com/tendermint/tendermint/commit/e2d6859afd7dba4cf97c7f7d412e7d8fc908d1cd.patch",
    "fix_commit_details": {
      "sha": "e2d6859afd7dba4cf97c7f7d412e7d8fc908d1cd",
      "commit_date": "2020-04-03T11:37:20Z",
      "author": {
        "login": "melekes",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "p2p: limit the number of incoming connections",
        "length": 109,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 66,
        "additions": 64,
        "deletions": 2
      },
      "files": [
        {
          "filename": "node/node.go",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -471,6 +471,11 @@ func createTransport(\n \t}\n \n \tp2p.MultiplexTransportConnFilters(connFilters...)(transport)\n+\n+\t// Limit the number of incoming connections.\n+\tmax := config.P2P.MaxNumInboundPeers + len(splitAndTrimEmpty(config.P2P.UnconditionalPeerIDs, \",\", \" \"))\n+\tp2p.MultiplexTransportMaxIncomingConnections(max)(transport)\n+\n \treturn transport, peerFilters\n }\n "
        },
        {
          "filename": "p2p/transport.go",
          "status": "modified",
          "additions": 14,
          "deletions": 2,
          "patch": "@@ -7,6 +7,7 @@ import (\n \t\"time\"\n \n \t\"github.com/pkg/errors\"\n+\t\"golang.org/x/net/netutil\"\n \n \t\"github.com/tendermint/tendermint/crypto\"\n \t\"github.com/tendermint/tendermint/p2p/conn\"\n@@ -122,11 +123,18 @@ func MultiplexTransportResolver(resolver IPResolver) MultiplexTransportOption {\n \treturn func(mt *MultiplexTransport) { mt.resolver = resolver }\n }\n \n+// MultiplexTransportMaxIncomingConnections sets the maximum number of\n+// simultaneous connections (incoming). Default: 0 (unlimited)\n+func MultiplexTransportMaxIncomingConnections(n int) MultiplexTransportOption {\n+\treturn func(mt *MultiplexTransport) { mt.maxIncomingConnections = n }\n+}\n+\n // MultiplexTransport accepts and dials tcp connections and upgrades them to\n // multiplexed peers.\n type MultiplexTransport struct {\n-\tnetAddr  NetAddress\n-\tlistener net.Listener\n+\tnetAddr                NetAddress\n+\tlistener               net.Listener\n+\tmaxIncomingConnections int // see MaxIncomingConnections\n \n \tacceptc chan accept\n \tclosec  chan struct{}\n@@ -240,6 +248,10 @@ func (mt *MultiplexTransport) Listen(addr NetAddress) error {\n \t\treturn err\n \t}\n \n+\tif mt.maxIncomingConnections > 0 {\n+\t\tln = netutil.LimitListener(ln, mt.maxIncomingConnections)\n+\t}\n+\n \tmt.netAddr = addr\n \tmt.listener = ln\n "
        },
        {
          "filename": "p2p/transport_test.go",
          "status": "modified",
          "additions": 45,
          "deletions": 0,
          "patch": "@@ -5,6 +5,7 @@ import (\n \t\"math/rand\"\n \t\"net\"\n \t\"reflect\"\n+\t\"strings\"\n \t\"testing\"\n \t\"time\"\n \n@@ -134,6 +135,50 @@ func TestTransportMultiplexConnFilterTimeout(t *testing.T) {\n \t}\n }\n \n+func TestTransportMultiplexMaxIncomingConnections(t *testing.T) {\n+\tmt := newMultiplexTransport(\n+\t\temptyNodeInfo(),\n+\t\tNodeKey{\n+\t\t\tPrivKey: ed25519.GenPrivKey(),\n+\t\t},\n+\t)\n+\tid := mt.nodeKey.ID()\n+\n+\tMultiplexTransportMaxIncomingConnections(0)(mt)\n+\n+\taddr, err := NewNetAddressString(IDAddressString(id, \"127.0.0.1:0\"))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif err := mt.Listen(*addr); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\terrc := make(chan error)\n+\n+\tgo func() {\n+\t\taddr := NewNetAddress(id, mt.listener.Addr())\n+\n+\t\t_, err := addr.Dial()\n+\t\tif err != nil {\n+\t\t\terrc <- err\n+\t\t\treturn\n+\t\t}\n+\n+\t\tclose(errc)\n+\t}()\n+\n+\tif err := <-errc; err != nil {\n+\t\tt.Errorf(\"connection failed: %v\", err)\n+\t}\n+\n+\t_, err = mt.Accept(peerConfig{})\n+\tif err == nil || !strings.Contains(err.Error(), \"connection reset by peer\") {\n+\t\tt.Errorf(\"expected connection reset by peer error, got %v\", err)\n+\t}\n+}\n+\n func TestTransportMultiplexAcceptMultiple(t *testing.T) {\n \tmt := testSetupMultiplexTransport(t)\n \tladdr := NewNetAddress(mt.nodeKey.ID(), mt.listener.Addr())"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "35581cf54ec436b8c37fabb43fdaa3f48339a170",
            "date": "2023-02-02T21:35:52Z",
            "author_login": "jaekwon"
          },
          {
            "sha": "64747b2b184184ecba4f4bffc54ffbcb47cfbcb0",
            "date": "2023-01-05T21:16:29Z",
            "author_login": "jaekwon"
          },
          {
            "sha": "014cdcf09844d48f6d30f3e520034b7edffd9670",
            "date": "2022-11-22T12:42:46Z",
            "author_login": "thanethomson"
          },
          {
            "sha": "08e5d0bf78c4becdfab0d9e5197e7adca4120b69",
            "date": "2022-11-21T11:05:35Z",
            "author_login": "thanethomson"
          },
          {
            "sha": "c645fd0b71cca2fa0ff1f597591f325e3c0ab905",
            "date": "2022-11-15T19:57:57Z",
            "author_login": "thanethomson"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-789",
    "description": "Tendermint before versions 0.33.3, 0.32.10, and 0.31.12 has a denial-of-service vulnerability. Tendermint does not limit the number of P2P connection requests. For each p2p connection, it allocates XXX bytes. Even though this memory is garbage collected once the connection is terminated (due to duplicate IP or reaching a maximum number of inbound peers), temporary memory spikes can lead to OOM (Out-Of-Memory) exceptions. Additionally, Tendermint does not reclaim activeID of a peer after it's removed in Mempool reactor. This does not happen all the time. It only happens when a connection fails (for any reason) before the Peer is created and added to all reactors. RemovePeer is therefore called before AddPeer, which leads to always growing memory (activeIDs map). The activeIDs map has a maximum size of 65535 and the node will panic if this map reaches the maximum. An attacker can create a lot of connection attempts (exploiting above denial of service), which ultimately will lead to the node panicking. These issues are patched in Tendermint 0.33.3 and 0.32.10.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2020-04-10T19:15:13.290",
    "last_modified": "2024-11-21T05:33:52.313",
    "fix_date": "2020-04-03T11:37:20Z"
  },
  "references": [
    {
      "url": "https://github.com/tendermint/tendermint/commit/e2d6859afd7dba4cf97c7f7d412e7d8fc908d1cd",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tendermint/tendermint/security/advisories/GHSA-v24h-pjjv-mcp6",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://hackerone.com/reports/820317",
      "source": "security-advisories@github.com",
      "tags": [
        "Permissions Required",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tendermint/tendermint/commit/e2d6859afd7dba4cf97c7f7d412e7d8fc908d1cd",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tendermint/tendermint/security/advisories/GHSA-v24h-pjjv-mcp6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://hackerone.com/reports/820317",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Permissions Required",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:42.326098",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "tendermint",
    "owner": "tendermint",
    "created_at": "2014-05-14T23:21:35Z",
    "updated_at": "2025-01-13T20:11:21Z",
    "pushed_at": "2024-12-27T00:20:39Z",
    "size": 150233,
    "stars": 5739,
    "forks": 2086,
    "open_issues": 20,
    "watchers": 5739,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Go": 3979011,
      "TeX": 332482,
      "TLA": 228722,
      "Shell": 27771,
      "Python": 25606,
      "Makefile": 17042,
      "Jinja": 13466,
      "Dockerfile": 6422,
      "HCL": 2065,
      "HTML": 787
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T17:02:01.644376"
  }
}