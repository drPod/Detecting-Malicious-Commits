{
  "cve_id": "CVE-2020-7212",
  "github_data": {
    "repository": "urllib3/urllib3",
    "fix_commit": "a74c9cfbaed9f811e7563cfc3dce894928e0221a",
    "related_commits": [
      "a74c9cfbaed9f811e7563cfc3dce894928e0221a",
      "a74c9cfbaed9f811e7563cfc3dce894928e0221a"
    ],
    "patch_url": "https://github.com/urllib3/urllib3/commit/a74c9cfbaed9f811e7563cfc3dce894928e0221a.patch",
    "fix_commit_details": {
      "sha": "a74c9cfbaed9f811e7563cfc3dce894928e0221a",
      "commit_date": "2019-04-28T19:19:42Z",
      "author": {
        "login": "sethmlarson",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Percent-encode invalid characters with request target (#1586)",
        "length": 61,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 88,
        "additions": 76,
        "deletions": 12
      },
      "files": [
        {
          "filename": "CHANGES.rst",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -6,6 +6,9 @@ dev (master)\n \n * Change ``is_ipaddress`` to not detect IPvFuture addresses. (Pull #1583)\n \n+* Change ``parse_url`` to percent-encode invalid characters within the\n+  path, query, and target components. (Pull #1586)\n+\n \n 1.25.1 (2019-04-24)\n -------------------"
        },
        {
          "filename": "src/urllib3/util/url.py",
          "status": "modified",
          "additions": 48,
          "deletions": 10,
          "patch": "@@ -6,6 +6,7 @@\n from ..packages import six, rfc3986\n from ..packages.rfc3986.exceptions import RFC3986Exception, ValidationError\n from ..packages.rfc3986.validators import Validator\n+from ..packages.rfc3986 import abnf_regexp, normalizers, compat, misc\n \n \n url_attrs = ['scheme', 'auth', 'host', 'port', 'path', 'query', 'fragment']\n@@ -17,6 +18,9 @@\n # Regex for detecting URLs with schemes. RFC 3986 Section 3.1\n SCHEME_REGEX = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+\\-]*:|/)\")\n \n+PATH_CHARS = abnf_regexp.UNRESERVED_CHARS_SET | abnf_regexp.SUB_DELIMITERS_SET | {':', '@', '/'}\n+QUERY_CHARS = FRAGMENT_CHARS = PATH_CHARS | {'?'}\n+\n \n class Url(namedtuple('Url', url_attrs)):\n     \"\"\"\n@@ -136,6 +140,37 @@ def split_first(s, delims):\n     return s[:min_idx], s[min_idx + 1:], min_delim\n \n \n+def _encode_invalid_chars(component, allowed_chars, encoding='utf-8'):\n+    \"\"\"Percent-encodes a URI component without reapplying\n+    onto an already percent-encoded component. Based on\n+    rfc3986.normalizers.encode_component()\n+    \"\"\"\n+    if component is None:\n+        return component\n+\n+    # Try to see if the component we're encoding is already percent-encoded\n+    # so we can skip all '%' characters but still encode all others.\n+    percent_encodings = len(normalizers.PERCENT_MATCHER.findall(\n+                            compat.to_str(component, encoding)))\n+\n+    uri_bytes = component.encode('utf-8', 'surrogatepass')\n+    is_percent_encoded = percent_encodings == uri_bytes.count(b'%')\n+\n+    encoded_component = bytearray()\n+\n+    for i in range(0, len(uri_bytes)):\n+        # Will return a single character bytestring on both Python 2 & 3\n+        byte = uri_bytes[i:i+1]\n+        byte_ord = ord(byte)\n+        if ((is_percent_encoded and byte == b'%')\n+                or (byte_ord < 128 and byte.decode() in allowed_chars)):\n+            encoded_component.extend(byte)\n+            continue\n+        encoded_component.extend('%{0:02x}'.format(byte_ord).encode().upper())\n+\n+    return encoded_component.decode(encoding)\n+\n+\n def parse_url(url):\n     \"\"\"\n     Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n@@ -160,8 +195,6 @@ def parse_url(url):\n         return Url()\n \n     is_string = not isinstance(url, six.binary_type)\n-    if not is_string:\n-        url = url.decode(\"utf-8\")\n \n     # RFC 3986 doesn't like URLs that have a host but don't start\n     # with a scheme and we support URLs like that so we need to\n@@ -171,11 +204,6 @@ def parse_url(url):\n     if not SCHEME_REGEX.search(url):\n         url = \"//\" + url\n \n-    try:\n-        iri_ref = rfc3986.IRIReference.from_string(url, encoding=\"utf-8\")\n-    except (ValueError, RFC3986Exception):\n-        six.raise_from(LocationParseError(url), None)\n-\n     def idna_encode(name):\n         if name and any([ord(x) > 128 for x in name]):\n             try:\n@@ -188,8 +216,18 @@ def idna_encode(name):\n                 raise LocationParseError(u\"Name '%s' is not a valid IDNA label\" % name)\n         return name\n \n-    has_authority = iri_ref.authority is not None\n-    uri_ref = iri_ref.encode(idna_encoder=idna_encode)\n+    try:\n+        split_iri = misc.IRI_MATCHER.match(compat.to_str(url)).groupdict()\n+        iri_ref = rfc3986.IRIReference(\n+            split_iri['scheme'], split_iri['authority'],\n+            _encode_invalid_chars(split_iri['path'], PATH_CHARS),\n+            _encode_invalid_chars(split_iri['query'], QUERY_CHARS),\n+            _encode_invalid_chars(split_iri['fragment'], FRAGMENT_CHARS)\n+        )\n+        has_authority = iri_ref.authority is not None\n+        uri_ref = iri_ref.encode(idna_encoder=idna_encode)\n+    except (ValueError, RFC3986Exception):\n+        return six.raise_from(LocationParseError(url), None)\n \n     # rfc3986 strips the authority if it's invalid\n     if has_authority and uri_ref.authority is None:\n@@ -209,7 +247,7 @@ def idna_encode(name):\n             *validator.COMPONENT_NAMES\n         ).validate(uri_ref)\n     except ValidationError:\n-        six.raise_from(LocationParseError(url), None)\n+        return six.raise_from(LocationParseError(url), None)\n \n     # For the sake of backwards compatibility we put empty\n     # string values for path if there are any defined values"
        },
        {
          "filename": "test/test_util.py",
          "status": "modified",
          "additions": 25,
          "deletions": 2,
          "patch": "@@ -135,8 +135,15 @@ def test_invalid_host(self, location):\n         'http://user\\\\@google.com',\n         'http://google\\\\.com',\n         'user\\\\@google.com',\n-        'http://google.com#fragment#',\n         'http://user@user@google.com/',\n+\n+        # Invalid IDNA labels\n+        u'http://\\uD7FF.com',\n+        u'http://\u2764\ufe0f',\n+\n+        # Unicode surrogates\n+        u'http://\\uD800.com',\n+        u'http://\\uDC00.com',\n     ])\n     def test_invalid_url(self, url):\n         with pytest.raises(LocationParseError):\n@@ -149,6 +156,15 @@ def test_invalid_url(self, url):\n         ('HTTPS://Example.Com/?Key=Value', 'https://example.com/?Key=Value'),\n         ('Https://Example.Com/#Fragment', 'https://example.com/#Fragment'),\n         ('[::Ff%etH0%Ff]/%ab%Af', '[::ff%25etH0%Ff]/%AB%AF'),\n+\n+        # Invalid characters for the query/fragment getting encoded\n+        ('http://google.com/p[]?parameter[]=\\\"hello\\\"#fragment#',\n+         'http://google.com/p%5B%5D?parameter%5B%5D=%22hello%22#fragment%23'),\n+\n+        # Percent encoding isn't applied twice despite '%' being invalid\n+        # but the percent encoding is still normalized.\n+        ('http://google.com/p%5B%5d?parameter%5b%5D=%22hello%22#fragment%23',\n+         'http://google.com/p%5B%5D?parameter%5B%5D=%22hello%22#fragment%23')\n     ])\n     def test_parse_url_normalization(self, url, expected_normalized_url):\n         \"\"\"Assert parse_url normalizes the scheme/host, and only the scheme/host\"\"\"\n@@ -214,7 +230,14 @@ def test_parse_url_normalization(self, url, expected_normalized_url):\n \n         # Uppercase IRI\n         (u'http://K\u00f6nigsg\u00e4\u00dfchen.de/stra\u00dfe',\n-         Url('http', host='xn--knigsgchen-b4a3dun.de', path='/stra%C3%9Fe'))\n+         Url('http', host='xn--knigsgchen-b4a3dun.de', path='/stra%C3%9Fe')),\n+\n+        # Unicode Surrogates\n+        (u'http://google.com/\\uD800', Url('http', host='google.com', path='%ED%A0%80')),\n+        (u'http://google.com?q=\\uDC00',\n+         Url('http', host='google.com', path='', query='q=%ED%B0%80')),\n+        (u'http://google.com#\\uDC00',\n+         Url('http', host='google.com', path='', fragment='%ED%B0%80')),\n     ]\n \n     @pytest.mark.parametrize("
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "f5f876c985faa063c5ff40cb97f20fc021be6a98",
            "date": "2025-01-13T09:34:59Z",
            "author_login": "graingert"
          },
          {
            "sha": "c82d8e506abff905e366ea72ef62c65eed584b17",
            "date": "2025-01-10T10:32:20Z",
            "author_login": "s-t-e-v-e-n-k"
          },
          {
            "sha": "1111e6c8fc3764c523ff9cd1d128ef7b864fbc79",
            "date": "2024-12-30T15:04:28Z",
            "author_login": "carlsmedstad"
          },
          {
            "sha": "4eb7c11f027c740bb44a0af0000f220ce498752f",
            "date": "2024-12-28T16:13:11Z",
            "author_login": "illia-v"
          },
          {
            "sha": "2aea62b62ecdafe830f39468fc67f834dc58419f",
            "date": "2024-12-24T06:45:08Z",
            "author_login": "pquentin"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "The _encode_invalid_chars function in util/url.py in the urllib3 library 1.25.2 through 1.25.7 for Python allows a denial of service (CPU consumption) because of an inefficient algorithm. The percent_encodings array contains all matches of percent encodings. It is not deduplicated. For a URL of length N, the size of percent_encodings may be up to O(N). The next step (normalize existing percent-encoded bytes) also takes up to O(N) for each step, so the total time is O(N^2). If percent_encodings were deduplicated, the time to compute _encode_invalid_chars would be O(kN), where k is at most 484 ((10+6*2)^2).",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-03-06T20:15:12.707",
    "last_modified": "2024-11-21T05:36:50.467",
    "fix_date": "2019-04-28T19:19:42Z"
  },
  "references": [
    {
      "url": "https://github.com/urllib3/urllib3/blob/master/CHANGES.rst",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/urllib3/urllib3/commit/a74c9cfbaed9f811e7563cfc3dce894928e0221a",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://pypi.org/project/urllib3/1.25.8/",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/urllib3/urllib3/blob/master/CHANGES.rst",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/urllib3/urllib3/commit/a74c9cfbaed9f811e7563cfc3dce894928e0221a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://pypi.org/project/urllib3/1.25.8/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:00:39.880775",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "urllib3",
    "owner": "urllib3",
    "created_at": "2011-09-18T18:08:28Z",
    "updated_at": "2025-01-13T09:35:04Z",
    "pushed_at": "2025-01-13T09:34:59Z",
    "size": 7450,
    "stars": 3821,
    "forks": 1168,
    "open_issues": 132,
    "watchers": 3821,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "1.24-series",
      "1.25-series",
      "1.26.x",
      "2.0.x",
      "main",
      "misleading-error-truncated-response",
      "release",
      "sethmlarson-patch-1",
      "v2"
    ],
    "languages": {
      "Python": 1105360,
      "HTML": 8754,
      "JavaScript": 3655,
      "Shell": 183,
      "Gherkin": 66
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T16:00:06.286934"
  }
}