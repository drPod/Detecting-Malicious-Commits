{
  "cve_id": "CVE-2020-8929",
  "github_data": {
    "repository": "google/tink",
    "fix_commit": "93d839a5865b9d950dffdc9d0bc99b71280a8899",
    "related_commits": [
      "93d839a5865b9d950dffdc9d0bc99b71280a8899",
      "93d839a5865b9d950dffdc9d0bc99b71280a8899"
    ],
    "patch_url": "https://github.com/google/tink/commit/93d839a5865b9d950dffdc9d0bc99b71280a8899.patch",
    "fix_commit_details": {
      "sha": "93d839a5865b9d950dffdc9d0bc99b71280a8899",
      "commit_date": "2020-10-12T23:02:38Z",
      "author": {
        "login": "sophieschmieg",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fixing ciphertext malleability issue in Java caused by storing the ciphertext prefix in a hashmap keyed by UTF8 encoded strings, instead of byte arrays, leading to the ability to retrieve keys with IDs that happen to be invalid Unicode strings with a changed ID.",
        "length": 292,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 114,
        "additions": 94,
        "deletions": 20
      },
      "files": [
        {
          "filename": "java_src/src/main/java/com/google/crypto/tink/BUILD.bazel",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -478,6 +478,7 @@ java_library(\n     deps = [\n         \":crypto_format\",\n         \"//proto:tink_java_proto\",\n+        \"//src/main/java/com/google/crypto/tink/subtle:hex\",\n     ],\n )\n \n@@ -487,6 +488,7 @@ android_library(\n     deps = [\n         \":crypto_format-android\",\n         \"//proto:tink_java_proto_lite\",\n+        \"//src/main/java/com/google/crypto/tink/subtle:hex\",\n     ],\n )\n "
        },
        {
          "filename": "java_src/src/main/java/com/google/crypto/tink/PrimitiveSet.java",
          "status": "modified",
          "additions": 47,
          "deletions": 7,
          "patch": "@@ -19,7 +19,7 @@\n import com.google.crypto.tink.proto.KeyStatusType;\n import com.google.crypto.tink.proto.Keyset;\n import com.google.crypto.tink.proto.OutputPrefixType;\n-import java.nio.charset.Charset;\n+import com.google.crypto.tink.subtle.Hex;\n import java.security.GeneralSecurityException;\n import java.util.ArrayList;\n import java.util.Arrays;\n@@ -49,7 +49,6 @@\n  * @since 1.0.0\n  */\n public final class PrimitiveSet<P> {\n-  private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n   /**\n    * A single entry in the set. In addition to the actual primitive it holds also some extra\n    * information about the primitive.\n@@ -117,7 +116,7 @@ public List<Entry<P>> getRawPrimitives() {\n \n   /** @return the entries with primitive identifed by {@code identifier}. */\n   public List<Entry<P>> getPrimitive(final byte[] identifier) {\n-    List<Entry<P>> found = primitives.get(new String(identifier, UTF_8));\n+    List<Entry<P>> found = primitives.get(new Prefix(identifier));\n     return found != null ? found : Collections.<Entry<P>>emptyList();\n   }\n \n@@ -136,8 +135,8 @@ public Collection<List<Entry<P>>> getAll() {\n    * prefix). This allows quickly retrieving the list of primitives sharing some particular prefix.\n    * Because all RAW keys are using an empty prefix, this also quickly allows retrieving them.\n    */\n-  private ConcurrentMap<java.lang.String, List<Entry<P>>> primitives =\n-      new ConcurrentHashMap<java.lang.String, List<Entry<P>>>();\n+  private final ConcurrentMap<Prefix, List<Entry<P>>> primitives =\n+      new ConcurrentHashMap<Prefix, List<Entry<P>>>();\n \n   private Entry<P> primary;\n   private final Class<P> primitiveClass;\n@@ -185,8 +184,8 @@ public Entry<P> addPrimitive(final P primitive, Keyset.Key key)\n             key.getKeyId());\n     List<Entry<P>> list = new ArrayList<Entry<P>>();\n     list.add(entry);\n-    // Cannot use [] as keys in hash map, convert to string.\n-    String identifier = new String(entry.getIdentifier(), UTF_8);\n+    // Cannot use [] as keys in hash map, convert to Prefix wrapper class.\n+    Prefix identifier = new Prefix(entry.getIdentifier());\n     List<Entry<P>> existing = primitives.put(identifier, Collections.unmodifiableList(list));\n     if (existing != null) {\n       List<Entry<P>> newList = new ArrayList<Entry<P>>();\n@@ -200,4 +199,45 @@ public Entry<P> addPrimitive(final P primitive, Keyset.Key key)\n   public Class<P> getPrimitiveClass() {\n     return primitiveClass;\n   }\n+\n+  private static class Prefix implements Comparable<Prefix> {\n+    private final byte[] prefix;\n+\n+    private Prefix(byte[] prefix) {\n+      this.prefix = Arrays.copyOf(prefix, prefix.length);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Arrays.hashCode(prefix);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (!(o instanceof Prefix)) {\n+        return false;\n+      }\n+      Prefix other = (Prefix) o;\n+      return Arrays.equals(prefix, other.prefix);\n+    }\n+\n+    @Override\n+    public int compareTo(Prefix o) {\n+      if (prefix.length != o.prefix.length) {\n+        return prefix.length - o.prefix.length;\n+      }\n+      for (int i = 0; i < prefix.length; i++) {\n+        if (prefix[i] != o.prefix[i]) {\n+          return prefix[i] - o.prefix[i];\n+        }\n+      }\n+      return 0;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return Hex.encode(prefix);\n+    }\n+  }\n+\n }"
        },
        {
          "filename": "java_src/src/test/java/com/google/crypto/tink/BUILD.bazel",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -172,6 +172,7 @@ java_test(\n         \"//src/main/java/com/google/crypto/tink:crypto_format\",\n         \"//src/main/java/com/google/crypto/tink:mac\",\n         \"//src/main/java/com/google/crypto/tink:primitive_set\",\n+        \"//src/main/java/com/google/crypto/tink/subtle:hex\",\n         \"//src/main/java/com/google/crypto/tink/testing:test_util\",\n         \"@maven//:com_google_truth_truth\",\n         \"@maven//:junit_junit\","
        },
        {
          "filename": "java_src/src/test/java/com/google/crypto/tink/PrimitiveSetTest.java",
          "status": "modified",
          "additions": 44,
          "deletions": 13,
          "patch": "@@ -18,14 +18,15 @@\n \n import static com.google.common.truth.Truth.assertThat;\n import static com.google.crypto.tink.testing.TestUtil.assertExceptionContains;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.fail;\n \n import com.google.crypto.tink.proto.KeyStatusType;\n import com.google.crypto.tink.proto.Keyset.Key;\n import com.google.crypto.tink.proto.OutputPrefixType;\n-import java.nio.charset.Charset;\n+import com.google.crypto.tink.subtle.Hex;\n import java.security.GeneralSecurityException;\n import java.util.ArrayList;\n import java.util.List;\n@@ -36,7 +37,6 @@\n /** Tests for PrimitiveSet. */\n @RunWith(JUnit4.class)\n public class PrimitiveSetTest {\n-  private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n \n   private static class DummyMac1 implements Mac {\n     public DummyMac1() {}\n@@ -91,36 +91,34 @@ public void testBasicFunctionality() throws Exception {\n             .build();\n     pset.addPrimitive(new DummyMac1(), key3);\n \n-    assertEquals(3, pset.getAll().size());\n+    assertThat(pset.getAll()).hasSize(3);\n \n     List<PrimitiveSet.Entry<Mac>> entries = pset.getPrimitive(key1);\n-    assertEquals(1, entries.size());\n+    assertThat(entries).hasSize(1);\n     PrimitiveSet.Entry<Mac> entry = entries.get(0);\n     assertEquals(\n-        DummyMac1.class.getSimpleName(),\n-        new String(entry.getPrimitive().computeMac(null), \"UTF-8\"));\n+        DummyMac1.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));\n     assertEquals(KeyStatusType.ENABLED, entry.getStatus());\n     assertEquals(CryptoFormat.TINK_START_BYTE, entry.getIdentifier()[0]);\n     assertArrayEquals(CryptoFormat.getOutputPrefix(key1), entry.getIdentifier());\n     assertEquals(entry.getKeyId(), 1);\n \n     entries = pset.getPrimitive(key2);\n-    assertEquals(1, entries.size());\n+    assertThat(entries).hasSize(1);\n     entry = entries.get(0);\n     assertEquals(\n         DummyMac2.class.getSimpleName(),\n-        new String(entry.getPrimitive().computeMac(null), \"UTF-8\"));\n+        new String(entry.getPrimitive().computeMac(null), UTF_8));\n     assertEquals(KeyStatusType.ENABLED, entry.getStatus());\n-    assertEquals(0, entry.getIdentifier().length);\n+    assertThat(entry.getIdentifier()).isEmpty();\n     assertArrayEquals(CryptoFormat.getOutputPrefix(key2), entry.getIdentifier());\n     assertEquals(2, entry.getKeyId());\n \n     entries = pset.getPrimitive(key3);\n-    assertEquals(1, entries.size());\n+    assertThat(entries).hasSize(1);\n     entry = entries.get(0);\n     assertEquals(\n-        DummyMac1.class.getSimpleName(),\n-        new String(entry.getPrimitive().computeMac(null), \"UTF-8\"));\n+        DummyMac1.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));\n     assertEquals(KeyStatusType.ENABLED, entry.getStatus());\n     assertEquals(CryptoFormat.LEGACY_START_BYTE, entry.getIdentifier()[0]);\n     assertArrayEquals(CryptoFormat.getOutputPrefix(key3), entry.getIdentifier());\n@@ -129,7 +127,7 @@ public void testBasicFunctionality() throws Exception {\n     entry = pset.getPrimary();\n     assertEquals(\n         DummyMac2.class.getSimpleName(),\n-        new String(entry.getPrimitive().computeMac(null), \"UTF-8\"));\n+        new String(entry.getPrimitive().computeMac(null), UTF_8));\n     assertEquals(KeyStatusType.ENABLED, entry.getStatus());\n     assertArrayEquals(CryptoFormat.getOutputPrefix(key2), entry.getIdentifier());\n     assertEquals(2, entry.getKeyId());\n@@ -276,4 +274,37 @@ public void testAddPrimive_WithDisabledKey_shouldFail() throws Exception {\n       assertExceptionContains(e, \"only ENABLED key is allowed\");\n     }\n   }\n+\n+  @Test\n+  public void testPrefix_isUnique() throws Exception {\n+    PrimitiveSet<Mac> pset = PrimitiveSet.newPrimitiveSet(Mac.class);\n+    Key key1 =\n+        Key.newBuilder()\n+            .setKeyId(0xffffffff)\n+            .setStatus(KeyStatusType.ENABLED)\n+            .setOutputPrefixType(OutputPrefixType.TINK)\n+            .build();\n+    pset.addPrimitive(new DummyMac1(), key1);\n+    Key key2 =\n+        Key.newBuilder()\n+            .setKeyId(0xffffffdf)\n+            .setStatus(KeyStatusType.ENABLED)\n+            .setOutputPrefixType(OutputPrefixType.RAW)\n+            .build();\n+    pset.setPrimary(pset.addPrimitive(new DummyMac2(), key2));\n+    Key key3 =\n+        Key.newBuilder()\n+            .setKeyId(0xffffffef)\n+            .setStatus(KeyStatusType.ENABLED)\n+            .setOutputPrefixType(OutputPrefixType.LEGACY)\n+            .build();\n+    pset.addPrimitive(new DummyMac1(), key3);\n+\n+    assertThat(pset.getAll()).hasSize(3);\n+\n+    assertThat(pset.getPrimitive(Hex.decode(\"01ffffffff\"))).hasSize(1);\n+    assertThat(pset.getPrimitive(Hex.decode(\"01ffffffef\"))).isEmpty();\n+    assertThat(pset.getPrimitive(Hex.decode(\"00ffffffff\"))).isEmpty();\n+    assertThat(pset.getPrimitive(Hex.decode(\"00ffffffef\"))).hasSize(1);\n+  }\n }"
        }
      ],
      "file_patterns": {
        "security_files": 4,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 8
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "1f4cd38874ec0be85f5aa55ba86d95d18c3fd965",
            "date": "2024-04-17T10:22:21Z",
            "author_login": "copybara-github"
          },
          {
            "sha": "d847e39b94a071e15aec8d11eff6dd82fe491149",
            "date": "2024-04-17T08:30:49Z",
            "author_login": "ioannanedelcu"
          },
          {
            "sha": "1798b7cd0cfbcb99688e9f2b7818f607b10eaefd",
            "date": "2024-04-16T22:14:55Z",
            "author_login": "willinois"
          },
          {
            "sha": "93258511594033e2bb9f0baf20aed4bb8cca28b0",
            "date": "2024-04-16T17:02:11Z",
            "author_login": "ioannanedelcu"
          },
          {
            "sha": "3e4e908dec09d7e24d0b849c071736613477cec6",
            "date": "2024-04-16T16:58:00Z",
            "author_login": "ioannanedelcu"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
    "cwe_id": "CWE-176",
    "description": "A mis-handling of invalid unicode characters in the Java implementation of Tink versions prior to 1.5 allows an attacker to change the ID part of a ciphertext, which result in the creation of a second ciphertext that can decrypt to the same plaintext. This can be a problem with encrypting deterministic AEAD with a single key, and rely on a unique ciphertext-per-plaintext.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2020-10-19T13:15:13.437",
    "last_modified": "2024-11-21T05:39:41.533",
    "fix_date": "2020-10-12T23:02:38Z"
  },
  "references": [
    {
      "url": "https://github.com/google/tink/commit/93d839a5865b9d950dffdc9d0bc99b71280a8899",
      "source": "cve-coordination@google.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/google/tink/security/advisories/GHSA-g5vf-v6wf-7w2r",
      "source": "cve-coordination@google.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/google/tink/commit/93d839a5865b9d950dffdc9d0bc99b71280a8899",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/google/tink/security/advisories/GHSA-g5vf-v6wf-7w2r",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:06.182797",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "tink",
    "owner": "google",
    "created_at": "2014-06-06T16:21:09Z",
    "updated_at": "2025-01-14T10:33:21Z",
    "pushed_at": "2024-04-17T11:08:35Z",
    "size": 61010,
    "stars": 13516,
    "forks": 1182,
    "open_issues": 0,
    "watchers": 13516,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Java": 7943291,
      "C++": 7469617,
      "Go": 2836883,
      "Starlark": 1842512,
      "Python": 900365,
      "CMake": 373311,
      "Shell": 223633,
      "C": 17279,
      "Ruby": 556
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:59:25.487865"
  }
}