{
  "cve_id": "CVE-2021-21240",
  "github_data": {
    "repository": "httplib2/httplib2",
    "fix_commit": "bd9ee252c8f099608019709e22c0d705e98d26bc",
    "related_commits": [
      "bd9ee252c8f099608019709e22c0d705e98d26bc",
      "bd9ee252c8f099608019709e22c0d705e98d26bc"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "bd9ee252c8f099608019709e22c0d705e98d26bc",
      "commit_date": "2021-01-06T14:13:38Z",
      "author": {
        "login": "temoto",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "parse auth headers using pyparsing instead of regexp",
        "length": 153,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 1611,
        "additions": 579,
        "deletions": 1032
      },
      "files": [
        {
          "filename": "python2/httplib2/__init__.py",
          "status": "modified",
          "additions": 107,
          "deletions": 386,
          "patch": "@@ -61,6 +61,8 @@\n         import socks\n     except (ImportError, AttributeError):\n         socks = None\n+from httplib2 import auth\n+from httplib2.error import *\n \n # Build the appropriate socket wrapper for ssl\n ssl = None\n@@ -75,9 +77,7 @@\n     ssl_CertificateError = getattr(ssl, \"CertificateError\", None)\n \n \n-def _ssl_wrap_socket(\n-    sock, key_file, cert_file, disable_validation, ca_certs, ssl_version, hostname, key_password\n-):\n+def _ssl_wrap_socket(sock, key_file, cert_file, disable_validation, ca_certs, ssl_version, hostname, key_password):\n     if disable_validation:\n         cert_reqs = ssl.CERT_NONE\n     else:\n@@ -101,12 +101,7 @@ def _ssl_wrap_socket(\n         if key_password:\n             raise NotSupportedOnThisPlatform(\"Certificate with password is not supported.\")\n         return ssl.wrap_socket(\n-            sock,\n-            keyfile=key_file,\n-            certfile=cert_file,\n-            cert_reqs=cert_reqs,\n-            ca_certs=ca_certs,\n-            ssl_version=ssl_version,\n+            sock, keyfile=key_file, certfile=cert_file, cert_reqs=cert_reqs, ca_certs=ca_certs, ssl_version=ssl_version,\n         )\n \n \n@@ -277,6 +272,7 @@ class NotRunningAppEngineEnvironment(HttpLib2Error):\n DEFAULT_MAX_REDIRECTS = 5\n \n from httplib2 import certs\n+\n CA_CERTS = certs.where()\n \n # Which headers are hop-by-hop headers by default\n@@ -365,26 +361,17 @@ def safename(filename):\n \n \n def _normalize_headers(headers):\n-    return dict(\n-        [\n-            (key.lower(), NORMALIZE_SPACE.sub(value, \" \").strip())\n-            for (key, value) in headers.iteritems()\n-        ]\n-    )\n+    return dict([(key.lower(), NORMALIZE_SPACE.sub(value, \" \").strip()) for (key, value) in headers.iteritems()])\n \n \n def _parse_cache_control(headers):\n     retval = {}\n     if \"cache-control\" in headers:\n         parts = headers[\"cache-control\"].split(\",\")\n         parts_with_args = [\n-            tuple([x.strip().lower() for x in part.split(\"=\", 1)])\n-            for part in parts\n-            if -1 != part.find(\"=\")\n-        ]\n-        parts_wo_args = [\n-            (name.strip().lower(), 1) for name in parts if -1 == name.find(\"=\")\n+            tuple([x.strip().lower() for x in part.split(\"=\", 1)]) for part in parts if -1 != part.find(\"=\")\n         ]\n+        parts_wo_args = [(name.strip().lower(), 1) for name in parts if -1 == name.find(\"=\")]\n         retval = dict(parts_with_args + parts_wo_args)\n     return retval\n \n@@ -395,55 +382,6 @@ def _parse_cache_control(headers):\n # Set to true to turn on, usefull for testing servers.\n USE_WWW_AUTH_STRICT_PARSING = 0\n \n-# In regex below:\n-#    [^\\0-\\x1f\\x7f-\\xff()<>@,;:\\\\\\\"/[\\]?={} \\t]+             matches a \"token\" as defined by HTTP\n-#    \"(?:[^\\0-\\x08\\x0A-\\x1f\\x7f-\\xff\\\\\\\"]|\\\\[\\0-\\x7f])*?\"    matches a \"quoted-string\" as defined by HTTP, when LWS have already been replaced by a single space\n-# Actually, as an auth-param value can be either a token or a quoted-string, they are combined in a single pattern which matches both:\n-#    \\\"?((?<=\\\")(?:[^\\0-\\x1f\\x7f-\\xff\\\\\\\"]|\\\\[\\0-\\x7f])*?(?=\\\")|(?<!\\\")[^\\0-\\x08\\x0A-\\x1f\\x7f-\\xff()<>@,;:\\\\\\\"/[\\]?={} \\t]+(?!\\\"))\\\"?\n-WWW_AUTH_STRICT = re.compile(\n-    r\"^(?:\\s*(?:,\\s*)?([^\\0-\\x1f\\x7f-\\xff()<>@,;:\\\\\\\"/[\\]?={} \\t]+)\\s*=\\s*\\\"?((?<=\\\")(?:[^\\0-\\x08\\x0A-\\x1f\\x7f-\\xff\\\\\\\"]|\\\\[\\0-\\x7f])*?(?=\\\")|(?<!\\\")[^\\0-\\x1f\\x7f-\\xff()<>@,;:\\\\\\\"/[\\]?={} \\t]+(?!\\\"))\\\"?)(.*)$\"\n-)\n-WWW_AUTH_RELAXED = re.compile(\n-    r\"^(?:\\s*(?:,\\s*)?([^ \\t\\r\\n=]+)\\s*=\\s*\\\"?((?<=\\\")(?:[^\\\\\\\"]|\\\\.)*?(?=\\\")|(?<!\\\")[^ \\t\\r\\n,]+(?!\\\"))\\\"?)(.*)$\"\n-)\n-UNQUOTE_PAIRS = re.compile(r\"\\\\(.)\")\n-\n-\n-def _parse_www_authenticate(headers, headername=\"www-authenticate\"):\n-    \"\"\"Returns a dictionary of dictionaries, one dict\n-    per auth_scheme.\"\"\"\n-    retval = {}\n-    if headername in headers:\n-        try:\n-\n-            authenticate = headers[headername].strip()\n-            www_auth = (\n-                USE_WWW_AUTH_STRICT_PARSING and WWW_AUTH_STRICT or WWW_AUTH_RELAXED\n-            )\n-            while authenticate:\n-                # Break off the scheme at the beginning of the line\n-                if headername == \"authentication-info\":\n-                    (auth_scheme, the_rest) = (\"digest\", authenticate)\n-                else:\n-                    (auth_scheme, the_rest) = authenticate.split(\" \", 1)\n-                # Now loop over all the key value pairs that come after the scheme,\n-                # being careful not to roll into the next scheme\n-                match = www_auth.search(the_rest)\n-                auth_params = {}\n-                while match:\n-                    if match and len(match.groups()) == 3:\n-                        (key, value, the_rest) = match.groups()\n-                        auth_params[key.lower()] = UNQUOTE_PAIRS.sub(\n-                            r\"\\1\", value\n-                        )  # '\\\\'.join([x.replace('\\\\', '') for x in value.split('\\\\\\\\')])\n-                    match = www_auth.search(the_rest)\n-                retval[auth_scheme.lower()] = auth_params\n-                authenticate = the_rest.strip()\n-\n-        except ValueError:\n-            raise MalformedHeader(\"WWW-Authenticate\")\n-    return retval\n-\n \n # TODO: add current time as _entry_disposition argument to avoid sleep in tests\n def _entry_disposition(response_headers, request_headers):\n@@ -478,10 +416,7 @@ def _entry_disposition(response_headers, request_headers):\n     cc = _parse_cache_control(request_headers)\n     cc_response = _parse_cache_control(response_headers)\n \n-    if (\n-        \"pragma\" in request_headers\n-        and request_headers[\"pragma\"].lower().find(\"no-cache\") != -1\n-    ):\n+    if \"pragma\" in request_headers and request_headers[\"pragma\"].lower().find(\"no-cache\") != -1:\n         retval = \"TRANSPARENT\"\n         if \"cache-control\" not in request_headers:\n             request_headers[\"cache-control\"] = \"no-cache\"\n@@ -540,8 +475,7 @@ def _decompressContent(response, new_content):\n     except (IOError, zlib.error):\n         content = \"\"\n         raise FailedToDecompressContent(\n-            _(\"Content purported to be compressed with %s but failed to decompress.\")\n-            % response.get(\"content-encoding\"),\n+            _(\"Content purported to be compressed with %s but failed to decompress.\") % response.get(\"content-encoding\"),\n             response,\n             content,\n         )\n@@ -587,17 +521,12 @@ def _updateCache(request_headers, response_headers, content, cache, cachekey):\n \n \n def _cnonce():\n-    dig = _md5(\n-        \"%s:%s\"\n-        % (time.ctime(), [\"0123456789\"[random.randrange(0, 9)] for i in range(20)])\n-    ).hexdigest()\n+    dig = _md5(\"%s:%s\" % (time.ctime(), [\"0123456789\"[random.randrange(0, 9)] for i in range(20)])).hexdigest()\n     return dig[:16]\n \n \n def _wsse_username_token(cnonce, iso_now, password):\n-    return base64.b64encode(\n-        _sha(\"%s%s%s\" % (cnonce, iso_now, password)).digest()\n-    ).strip()\n+    return base64.b64encode(_sha(\"%s%s%s\" % (cnonce, iso_now, password)).digest()).strip()\n \n \n # For credentials we need two things, first\n@@ -610,9 +539,7 @@ def _wsse_username_token(cnonce, iso_now, password):\n \n \n class Authentication(object):\n-    def __init__(\n-        self, credentials, host, request_uri, headers, response, content, http\n-    ):\n+    def __init__(self, credentials, host, request_uri, headers, response, content, http):\n         (scheme, authority, path, query, fragment) = parse_uri(request_uri)\n         self.path = path\n         self.host = host\n@@ -645,55 +572,32 @@ def response(self, response, content):\n \n \n class BasicAuthentication(Authentication):\n-    def __init__(\n-        self, credentials, host, request_uri, headers, response, content, http\n-    ):\n-        Authentication.__init__(\n-            self, credentials, host, request_uri, headers, response, content, http\n-        )\n+    def __init__(self, credentials, host, request_uri, headers, response, content, http):\n+        Authentication.__init__(self, credentials, host, request_uri, headers, response, content, http)\n \n     def request(self, method, request_uri, headers, content):\n         \"\"\"Modify the request headers to add the appropriate\n         Authorization header.\"\"\"\n-        headers[\"authorization\"] = (\n-            \"Basic \" + base64.b64encode(\"%s:%s\" % self.credentials).strip()\n-        )\n+        headers[\"authorization\"] = \"Basic \" + base64.b64encode(\"%s:%s\" % self.credentials).strip()\n \n \n class DigestAuthentication(Authentication):\n     \"\"\"Only do qop='auth' and MD5, since that\n     is all Apache currently implements\"\"\"\n \n-    def __init__(\n-        self, credentials, host, request_uri, headers, response, content, http\n-    ):\n-        Authentication.__init__(\n-            self, credentials, host, request_uri, headers, response, content, http\n-        )\n-        challenge = _parse_www_authenticate(response, \"www-authenticate\")\n-        self.challenge = challenge[\"digest\"]\n+    def __init__(self, credentials, host, request_uri, headers, response, content, http):\n+        Authentication.__init__(self, credentials, host, request_uri, headers, response, content, http)\n+        self.challenge = auth._parse_www_authenticate(response, \"www-authenticate\")[\"digest\"]\n         qop = self.challenge.get(\"qop\", \"auth\")\n-        self.challenge[\"qop\"] = (\n-            (\"auth\" in [x.strip() for x in qop.split()]) and \"auth\" or None\n-        )\n+        self.challenge[\"qop\"] = (\"auth\" in [x.strip() for x in qop.split()]) and \"auth\" or None\n         if self.challenge[\"qop\"] is None:\n-            raise UnimplementedDigestAuthOptionError(\n-                _(\"Unsupported value for qop: %s.\" % qop)\n-            )\n+            raise UnimplementedDigestAuthOptionError(_(\"Unsupported value for qop: %s.\" % qop))\n         self.challenge[\"algorithm\"] = self.challenge.get(\"algorithm\", \"MD5\").upper()\n         if self.challenge[\"algorithm\"] != \"MD5\":\n             raise UnimplementedDigestAuthOptionError(\n                 _(\"Unsupported value for algorithm: %s.\" % self.challenge[\"algorithm\"])\n             )\n-        self.A1 = \"\".join(\n-            [\n-                self.credentials[0],\n-                \":\",\n-                self.challenge[\"realm\"],\n-                \":\",\n-                self.credentials[1],\n-            ]\n-        )\n+        self.A1 = \"\".join([self.credentials[0], \":\", self.challenge[\"realm\"], \":\", self.credentials[1],])\n         self.challenge[\"nc\"] = 1\n \n     def request(self, method, request_uri, headers, content, cnonce=None):\n@@ -734,17 +638,13 @@ def request(self, method, request_uri, headers, content, cnonce=None):\n \n     def response(self, response, content):\n         if \"authentication-info\" not in response:\n-            challenge = _parse_www_authenticate(response, \"www-authenticate\").get(\n-                \"digest\", {}\n-            )\n+            challenge = auth._parse_www_authenticate(response, \"www-authenticate\").get(\"digest\", {})\n             if \"true\" == challenge.get(\"stale\"):\n                 self.challenge[\"nonce\"] = challenge[\"nonce\"]\n                 self.challenge[\"nc\"] = 1\n                 return True\n         else:\n-            updated_challenge = _parse_www_authenticate(\n-                response, \"authentication-info\"\n-            ).get(\"digest\", {})\n+            updated_challenge = auth._parse_authentication_info(response, \"authentication-info\")\n \n             if \"nextnonce\" in updated_challenge:\n                 self.challenge[\"nonce\"] = updated_challenge[\"nextnonce\"]\n@@ -757,13 +657,9 @@ class HmacDigestAuthentication(Authentication):\n \n     __author__ = \"Thomas Broyer (t.broyer@ltgt.net)\"\n \n-    def __init__(\n-        self, credentials, host, request_uri, headers, response, content, http\n-    ):\n-        Authentication.__init__(\n-            self, credentials, host, request_uri, headers, response, content, http\n-        )\n-        challenge = _parse_www_authenticate(response, \"www-authenticate\")\n+    def __init__(self, credentials, host, request_uri, headers, response, content, http):\n+        Authentication.__init__(self, credentials, host, request_uri, headers, response, content, http)\n+        challenge = auth._parse_www_authenticate(response, \"www-authenticate\")\n         self.challenge = challenge[\"hmacdigest\"]\n         # TODO: self.challenge['domain']\n         self.challenge[\"reason\"] = self.challenge.get(\"reason\", \"unauthorized\")\n@@ -782,10 +678,7 @@ def __init__(\n         self.challenge[\"pw-algorithm\"] = self.challenge.get(\"pw-algorithm\", \"SHA-1\")\n         if self.challenge[\"pw-algorithm\"] not in [\"SHA-1\", \"MD5\"]:\n             raise UnimplementedHmacDigestAuthOptionError(\n-                _(\n-                    \"Unsupported value for pw-algorithm: %s.\"\n-                    % self.challenge[\"pw-algorithm\"]\n-                )\n+                _(\"Unsupported value for pw-algorithm: %s.\" % self.challenge[\"pw-algorithm\"])\n             )\n         if self.challenge[\"algorithm\"] == \"HMAC-MD5\":\n             self.hashmod = _md5\n@@ -799,11 +692,7 @@ def __init__(\n             [\n                 self.credentials[0],\n                 \":\",\n-                self.pwhashmod.new(\n-                    \"\".join([self.credentials[1], self.challenge[\"salt\"]])\n-                )\n-                .hexdigest()\n-                .lower(),\n+                self.pwhashmod.new(\"\".join([self.credentials[1], self.challenge[\"salt\"]])).hexdigest().lower(),\n                 \":\",\n                 self.challenge[\"realm\"],\n             ]\n@@ -817,16 +706,8 @@ def request(self, method, request_uri, headers, content):\n         headers_val = \"\".join([headers[k] for k in keys])\n         created = time.strftime(\"%Y-%m-%dT%H:%M:%SZ\", time.gmtime())\n         cnonce = _cnonce()\n-        request_digest = \"%s:%s:%s:%s:%s\" % (\n-            method,\n-            request_uri,\n-            cnonce,\n-            self.challenge[\"snonce\"],\n-            headers_val,\n-        )\n-        request_digest = (\n-            hmac.new(self.key, request_digest, self.hashmod).hexdigest().lower()\n-        )\n+        request_digest = \"%s:%s:%s:%s:%s\" % (method, request_uri, cnonce, self.challenge[\"snonce\"], headers_val,)\n+        request_digest = hmac.new(self.key, request_digest, self.hashmod).hexdigest().lower()\n         headers[\"authorization\"] = (\n             'HMACDigest username=\"%s\", realm=\"%s\", snonce=\"%s\",'\n             ' cnonce=\"%s\", uri=\"%s\", created=\"%s\", '\n@@ -843,9 +724,7 @@ def request(self, method, request_uri, headers, content):\n         )\n \n     def response(self, response, content):\n-        challenge = _parse_www_authenticate(response, \"www-authenticate\").get(\n-            \"hmacdigest\", {}\n-        )\n+        challenge = auth._parse_www_authenticate(response, \"www-authenticate\").get(\"hmacdigest\", {})\n         if challenge.get(\"reason\") in [\"integrity\", \"stale\"]:\n             return True\n         return False\n@@ -860,12 +739,8 @@ class WsseAuthentication(Authentication):\n     challenge but instead requiring your client to telepathically know that\n     their endpoint is expecting WSSE profile=\"UsernameToken\".\"\"\"\n \n-    def __init__(\n-        self, credentials, host, request_uri, headers, response, content, http\n-    ):\n-        Authentication.__init__(\n-            self, credentials, host, request_uri, headers, response, content, http\n-        )\n+    def __init__(self, credentials, host, request_uri, headers, response, content, http):\n+        Authentication.__init__(self, credentials, host, request_uri, headers, response, content, http)\n \n     def request(self, method, request_uri, headers, content):\n         \"\"\"Modify the request headers to add the appropriate\n@@ -874,22 +749,20 @@ def request(self, method, request_uri, headers, content):\n         iso_now = time.strftime(\"%Y-%m-%dT%H:%M:%SZ\", time.gmtime())\n         cnonce = _cnonce()\n         password_digest = _wsse_username_token(cnonce, iso_now, self.credentials[1])\n-        headers[\"X-WSSE\"] = (\n-            'UsernameToken Username=\"%s\", PasswordDigest=\"%s\", '\n-            'Nonce=\"%s\", Created=\"%s\"'\n-        ) % (self.credentials[0], password_digest, cnonce, iso_now)\n+        headers[\"X-WSSE\"] = ('UsernameToken Username=\"%s\", PasswordDigest=\"%s\", ' 'Nonce=\"%s\", Created=\"%s\"') % (\n+            self.credentials[0],\n+            password_digest,\n+            cnonce,\n+            iso_now,\n+        )\n \n \n class GoogleLoginAuthentication(Authentication):\n-    def __init__(\n-        self, credentials, host, request_uri, headers, response, content, http\n-    ):\n+    def __init__(self, credentials, host, request_uri, headers, response, content, http):\n         from urllib import urlencode\n \n-        Authentication.__init__(\n-            self, credentials, host, request_uri, headers, response, content, http\n-        )\n-        challenge = _parse_www_authenticate(response, \"www-authenticate\")\n+        Authentication.__init__(self, credentials, host, request_uri, headers, response, content, http)\n+        challenge = auth._parse_www_authenticate(response, \"www-authenticate\")\n         service = challenge[\"googlelogin\"].get(\"service\", \"xapi\")\n         # Bloggger actually returns the service in the challenge\n         # For the rest we guess based on the URI\n@@ -899,12 +772,7 @@ def __init__(\n         # elif request_uri.find(\"spreadsheets\") > 0:\n         #    service = \"wise\"\n \n-        auth = dict(\n-            Email=credentials[0],\n-            Passwd=credentials[1],\n-            service=service,\n-            source=headers[\"user-agent\"],\n-        )\n+        auth = dict(Email=credentials[0], Passwd=credentials[1], service=service, source=headers[\"user-agent\"],)\n         resp, content = self.http.request(\n             \"https://www.google.com/accounts/ClientLogin\",\n             method=\"POST\",\n@@ -941,9 +809,7 @@ class FileCache(object):\n     be running on the same cache.\n     \"\"\"\n \n-    def __init__(\n-        self, cache, safe=safename\n-    ):  # use safe=lambda x: md5.new(x).hexdigest() for the old behavior\n+    def __init__(self, cache, safe=safename):  # use safe=lambda x: md5.new(x).hexdigest() for the old behavior\n         self.cache = cache\n         self.safe = safe\n         if not os.path.exists(cache):\n@@ -991,6 +857,7 @@ def iter(self, domain):\n class KeyCerts(Credentials):\n     \"\"\"Identical to Credentials except that\n     name/password are mapped to key/cert.\"\"\"\n+\n     def add(self, key, cert, domain, password):\n         self.credentials.append((domain.lower(), key, cert, password))\n \n@@ -1010,14 +877,7 @@ class ProxyInfo(object):\n     bypass_hosts = ()\n \n     def __init__(\n-        self,\n-        proxy_type,\n-        proxy_host,\n-        proxy_port,\n-        proxy_rdns=True,\n-        proxy_user=None,\n-        proxy_pass=None,\n-        proxy_headers=None,\n+        self, proxy_type, proxy_host, proxy_port, proxy_rdns=True, proxy_user=None, proxy_pass=None, proxy_headers=None,\n     ):\n         \"\"\"Args:\n \n@@ -1165,14 +1025,18 @@ def connect(self):\n         \"\"\"Connect to the host and port specified in __init__.\"\"\"\n         # Mostly verbatim from httplib.py.\n         if self.proxy_info and socks is None:\n-            raise ProxiesUnavailableError(\n-                \"Proxy support missing but proxy use was requested!\"\n-            )\n+            raise ProxiesUnavailableError(\"Proxy support missing but proxy use was requested!\")\n         if self.proxy_info and self.proxy_info.isgood():\n             use_proxy = True\n-            proxy_type, proxy_host, proxy_port, proxy_rdns, proxy_user, proxy_pass, proxy_headers = (\n-                self.proxy_info.astuple()\n-            )\n+            (\n+                proxy_type,\n+                proxy_host,\n+                proxy_port,\n+                proxy_rdns,\n+                proxy_user,\n+                proxy_pass,\n+                proxy_headers,\n+            ) = self.proxy_info.astuple()\n \n             host = proxy_host\n             port = proxy_port\n@@ -1190,13 +1054,7 @@ def connect(self):\n                 if use_proxy:\n                     self.sock = socks.socksocket(af, socktype, proto)\n                     self.sock.setproxy(\n-                        proxy_type,\n-                        proxy_host,\n-                        proxy_port,\n-                        proxy_rdns,\n-                        proxy_user,\n-                        proxy_pass,\n-                        proxy_headers,\n+                        proxy_type, proxy_host, proxy_port, proxy_rdns, proxy_user, proxy_pass, proxy_headers,\n                     )\n                 else:\n                     self.sock = socket.socket(af, socktype, proto)\n@@ -1210,16 +1068,7 @@ def connect(self):\n                     if use_proxy:\n                         print(\n                             \"proxy: %s ************\"\n-                            % str(\n-                                (\n-                                    proxy_host,\n-                                    proxy_port,\n-                                    proxy_rdns,\n-                                    proxy_user,\n-                                    proxy_pass,\n-                                    proxy_headers,\n-                                )\n-                            )\n+                            % str((proxy_host, proxy_port, proxy_rdns, proxy_user, proxy_pass, proxy_headers,))\n                         )\n                 if use_proxy:\n                     self.sock.connect((self.host, self.port) + sa[2:])\n@@ -1232,16 +1081,7 @@ def connect(self):\n                     if use_proxy:\n                         print(\n                             \"proxy: %s\"\n-                            % str(\n-                                (\n-                                    proxy_host,\n-                                    proxy_port,\n-                                    proxy_rdns,\n-                                    proxy_user,\n-                                    proxy_pass,\n-                                    proxy_headers,\n-                                )\n-                            )\n+                            % str((proxy_host, proxy_port, proxy_rdns, proxy_user, proxy_pass, proxy_headers,))\n                         )\n                 if self.sock:\n                     self.sock.close()\n@@ -1348,9 +1188,15 @@ def connect(self):\n \n         if self.proxy_info and self.proxy_info.isgood():\n             use_proxy = True\n-            proxy_type, proxy_host, proxy_port, proxy_rdns, proxy_user, proxy_pass, proxy_headers = (\n-                self.proxy_info.astuple()\n-            )\n+            (\n+                proxy_type,\n+                proxy_host,\n+                proxy_port,\n+                proxy_rdns,\n+                proxy_user,\n+                proxy_pass,\n+                proxy_headers,\n+            ) = self.proxy_info.astuple()\n \n             host = proxy_host\n             port = proxy_port\n@@ -1369,13 +1215,7 @@ def connect(self):\n                     sock = socks.socksocket(family, socktype, proto)\n \n                     sock.setproxy(\n-                        proxy_type,\n-                        proxy_host,\n-                        proxy_port,\n-                        proxy_rdns,\n-                        proxy_user,\n-                        proxy_pass,\n-                        proxy_headers,\n+                        proxy_type, proxy_host, proxy_port, proxy_rdns, proxy_user, proxy_pass, proxy_headers,\n                     )\n                 else:\n                     sock = socket.socket(family, socktype, proto)\n@@ -1403,32 +1243,18 @@ def connect(self):\n                     if use_proxy:\n                         print(\n                             \"proxy: %s\"\n-                            % str(\n-                                (\n-                                    proxy_host,\n-                                    proxy_port,\n-                                    proxy_rdns,\n-                                    proxy_user,\n-                                    proxy_pass,\n-                                    proxy_headers,\n-                                )\n-                            )\n+                            % str((proxy_host, proxy_port, proxy_rdns, proxy_user, proxy_pass, proxy_headers,))\n                         )\n                 if not self.disable_ssl_certificate_validation:\n                     cert = self.sock.getpeercert()\n                     hostname = self.host.split(\":\", 0)[0]\n                     if not self._ValidateCertificateHostname(cert, hostname):\n                         raise CertificateHostnameMismatch(\n-                            \"Server presented certificate that does not match \"\n-                            \"host %s: %s\" % (hostname, cert),\n+                            \"Server presented certificate that does not match \" \"host %s: %s\" % (hostname, cert),\n                             hostname,\n                             cert,\n                         )\n-            except (\n-                ssl_SSLError,\n-                ssl_CertificateError,\n-                CertificateHostnameMismatch,\n-            ) as e:\n+            except (ssl_SSLError, ssl_CertificateError, CertificateHostnameMismatch,) as e:\n                 if sock:\n                     sock.close()\n                 if self.sock:\n@@ -1451,16 +1277,7 @@ def connect(self):\n                     if use_proxy:\n                         print(\n                             \"proxy: %s\"\n-                            % str(\n-                                (\n-                                    proxy_host,\n-                                    proxy_port,\n-                                    proxy_rdns,\n-                                    proxy_user,\n-                                    proxy_pass,\n-                                    proxy_headers,\n-                                )\n-                            )\n+                            % str((proxy_host, proxy_port, proxy_rdns, proxy_user, proxy_pass, proxy_headers,))\n                         )\n                 if self.sock:\n                     self.sock.close()\n@@ -1478,15 +1295,8 @@ def connect(self):\n \n \n def _new_fixed_fetch(validate_certificate):\n-\n     def fixed_fetch(\n-        url,\n-        payload=None,\n-        method=\"GET\",\n-        headers={},\n-        allow_truncated=False,\n-        follow_redirects=True,\n-        deadline=None,\n+        url, payload=None, method=\"GET\", headers={}, allow_truncated=False, follow_redirects=True, deadline=None,\n     ):\n         return fetch(\n             url,\n@@ -1523,9 +1333,7 @@ def __init__(\n         disable_ssl_certificate_validation=False,\n         ssl_version=None,\n     ):\n-        httplib.HTTPConnection.__init__(\n-            self, host, port=port, strict=strict, timeout=timeout\n-        )\n+        httplib.HTTPConnection.__init__(self, host, port=port, strict=strict, timeout=timeout)\n \n \n class AppEngineHttpsConnection(httplib.HTTPSConnection):\n@@ -1552,23 +1360,19 @@ def __init__(\n         if key_password:\n             raise NotSupportedOnThisPlatform(\"Certificate with password is not supported.\")\n         httplib.HTTPSConnection.__init__(\n-            self,\n-            host,\n-            port=port,\n-            key_file=key_file,\n-            cert_file=cert_file,\n-            strict=strict,\n-            timeout=timeout,\n+            self, host, port=port, key_file=key_file, cert_file=cert_file, strict=strict, timeout=timeout,\n         )\n         self._fetch = _new_fixed_fetch(not disable_ssl_certificate_validation)\n \n \n # Use a different connection object for Google App Engine Standard Environment.\n def is_gae_instance():\n-    server_software = os.environ.get('SERVER_SOFTWARE', '')\n-    if (server_software.startswith('Google App Engine/') or\n-        server_software.startswith('Development/') or\n-        server_software.startswith('testutil/')):\n+    server_software = os.environ.get(\"SERVER_SOFTWARE\", \"\")\n+    if (\n+        server_software.startswith(\"Google App Engine/\")\n+        or server_software.startswith(\"Development/\")\n+        or server_software.startswith(\"testutil/\")\n+    ):\n         return True\n     return False\n \n@@ -1578,6 +1382,7 @@ def is_gae_instance():\n         raise NotRunningAppEngineEnvironment()\n \n     from google.appengine.api import apiproxy_stub_map\n+\n     if apiproxy_stub_map.apiproxy.GetStub(\"urlfetch\") is None:\n         raise ImportError\n \n@@ -1716,13 +1521,11 @@ def _auth_from_challenge(self, host, request_uri, headers, response, content):\n         \"\"\"A generator that creates Authorization objects\n            that can be applied to requests.\n         \"\"\"\n-        challenges = _parse_www_authenticate(response, \"www-authenticate\")\n+        challenges = auth._parse_www_authenticate(response, \"www-authenticate\")\n         for cred in self.credentials.iter(host):\n             for scheme in AUTH_SCHEME_ORDER:\n                 if scheme in challenges:\n-                    yield AUTH_SCHEME_CLASSES[scheme](\n-                        cred, host, request_uri, headers, response, content, self\n-                    )\n+                    yield AUTH_SCHEME_CLASSES[scheme](cred, host, request_uri, headers, response, content, self)\n \n     def add_credentials(self, name, password, domain=\"\"):\n         \"\"\"Add a name and password that will be used\n@@ -1818,79 +1621,48 @@ def _conn_request(self, conn, request_uri, method, body, headers):\n         return (response, content)\n \n     def _request(\n-        self,\n-        conn,\n-        host,\n-        absolute_uri,\n-        request_uri,\n-        method,\n-        body,\n-        headers,\n-        redirections,\n-        cachekey,\n+        self, conn, host, absolute_uri, request_uri, method, body, headers, redirections, cachekey,\n     ):\n         \"\"\"Do the actual request using the connection object\n         and also follow one level of redirects if necessary\"\"\"\n \n-        auths = [\n-            (auth.depth(request_uri), auth)\n-            for auth in self.authorizations\n-            if auth.inscope(host, request_uri)\n-        ]\n+        auths = [(auth.depth(request_uri), auth) for auth in self.authorizations if auth.inscope(host, request_uri)]\n         auth = auths and sorted(auths)[0][1] or None\n         if auth:\n             auth.request(method, request_uri, headers, body)\n \n-        (response, content) = self._conn_request(\n-            conn, request_uri, method, body, headers\n-        )\n+        (response, content) = self._conn_request(conn, request_uri, method, body, headers)\n \n         if auth:\n             if auth.response(response, body):\n                 auth.request(method, request_uri, headers, body)\n-                (response, content) = self._conn_request(\n-                    conn, request_uri, method, body, headers\n-                )\n+                (response, content) = self._conn_request(conn, request_uri, method, body, headers)\n                 response._stale_digest = 1\n \n         if response.status == 401:\n-            for authorization in self._auth_from_challenge(\n-                host, request_uri, headers, response, content\n-            ):\n+            for authorization in self._auth_from_challenge(host, request_uri, headers, response, content):\n                 authorization.request(method, request_uri, headers, body)\n-                (response, content) = self._conn_request(\n-                    conn, request_uri, method, body, headers\n-                )\n+                (response, content) = self._conn_request(conn, request_uri, method, body, headers)\n                 if response.status != 401:\n                     self.authorizations.append(authorization)\n                     authorization.response(response, body)\n                     break\n \n-        if (\n-            self.follow_all_redirects\n-            or method in self.safe_methods\n-            or response.status in (303, 308)\n-        ):\n+        if self.follow_all_redirects or method in self.safe_methods or response.status in (303, 308):\n             if self.follow_redirects and response.status in self.redirect_codes:\n                 # Pick out the location header and basically start from the beginning\n                 # remembering first to strip the ETag header and decrement our 'depth'\n                 if redirections:\n                     if \"location\" not in response and response.status != 300:\n                         raise RedirectMissingLocation(\n-                            _(\n-                                \"Redirected but the response is missing a Location: header.\"\n-                            ),\n-                            response,\n-                            content,\n+                            _(\"Redirected but the response is missing a Location: header.\"), response, content,\n                         )\n                     # Fix-up relative redirects (which violate an RFC 2616 MUST)\n                     if \"location\" in response:\n                         location = response[\"location\"]\n                         (scheme, authority, path, query, fragment) = parse_uri(location)\n                         if authority == None:\n-                            response[\"location\"] = urlparse.urljoin(\n-                                absolute_uri, location\n-                            )\n+                            response[\"location\"] = urlparse.urljoin(absolute_uri, location)\n                     if response.status == 308 or (response.status == 301 and method in self.safe_methods):\n                         response[\"-x-permanent-redirect-url\"] = response[\"location\"]\n                         if \"content-location\" not in response:\n@@ -1900,10 +1672,7 @@ def _request(\n                         del headers[\"if-none-match\"]\n                     if \"if-modified-since\" in headers:\n                         del headers[\"if-modified-since\"]\n-                    if (\n-                        \"authorization\" in headers\n-                        and not self.forward_authorization_headers\n-                    ):\n+                    if \"authorization\" in headers and not self.forward_authorization_headers:\n                         del headers[\"authorization\"]\n                     if \"location\" in response:\n                         location = response[\"location\"]\n@@ -1915,18 +1684,12 @@ def _request(\n                             redirect_method = \"GET\"\n                             body = None\n                         (response, content) = self.request(\n-                            location,\n-                            method=redirect_method,\n-                            body=body,\n-                            headers=headers,\n-                            redirections=redirections - 1,\n+                            location, method=redirect_method, body=body, headers=headers, redirections=redirections - 1,\n                         )\n                         response.previous = old_response\n                 else:\n                     raise RedirectLimit(\n-                        \"Redirected more times than rediection_limit allows.\",\n-                        response,\n-                        content,\n+                        \"Redirected more times than rediection_limit allows.\", response, content,\n                     )\n             elif response.status in [200, 203] and method in self.safe_methods:\n                 # Don't cache 206's since we aren't going to handle byte range requests\n@@ -1944,13 +1707,7 @@ def _normalize_headers(self, headers):\n     # including all socket.* and httplib.* exceptions.\n \n     def request(\n-        self,\n-        uri,\n-        method=\"GET\",\n-        body=None,\n-        headers=None,\n-        redirections=DEFAULT_MAX_REDIRECTS,\n-        connection_type=None,\n+        self, uri, method=\"GET\", body=None, headers=None, redirections=DEFAULT_MAX_REDIRECTS, connection_type=None,\n     ):\n         \"\"\" Performs a single HTTP request.\n \n@@ -1973,7 +1730,7 @@ def request(\n         being and instance of the 'Response' class, the second being\n         a string that contains the response entity body.\n         \"\"\"\n-        conn_key = ''\n+        conn_key = \"\"\n \n         try:\n             if headers is None:\n@@ -2094,9 +1851,7 @@ def request(\n                     # Should cached permanent redirects be counted in our redirection count? For now, yes.\n                     if redirections <= 0:\n                         raise RedirectLimit(\n-                            \"Redirected more times than rediection_limit allows.\",\n-                            {},\n-                            \"\",\n+                            \"Redirected more times than rediection_limit allows.\", {}, \"\",\n                         )\n                     (response, new_content) = self.request(\n                         info[\"-x-permanent-redirect-url\"],\n@@ -2127,27 +1882,15 @@ def request(\n                         return (response, content)\n \n                     if entry_disposition == \"STALE\":\n-                        if (\n-                            \"etag\" in info\n-                            and not self.ignore_etag\n-                            and not \"if-none-match\" in headers\n-                        ):\n+                        if \"etag\" in info and not self.ignore_etag and not \"if-none-match\" in headers:\n                             headers[\"if-none-match\"] = info[\"etag\"]\n                         if \"last-modified\" in info and not \"last-modified\" in headers:\n                             headers[\"if-modified-since\"] = info[\"last-modified\"]\n                     elif entry_disposition == \"TRANSPARENT\":\n                         pass\n \n                     (response, new_content) = self._request(\n-                        conn,\n-                        authority,\n-                        uri,\n-                        request_uri,\n-                        method,\n-                        body,\n-                        headers,\n-                        redirections,\n-                        cachekey,\n+                        conn, authority, uri, request_uri, method, body, headers, redirections, cachekey,\n                     )\n \n                 if response.status == 304 and method == \"GET\":\n@@ -2161,9 +1904,7 @@ def request(\n                     merged_response = Response(info)\n                     if hasattr(response, \"_stale_digest\"):\n                         merged_response._stale_digest = response._stale_digest\n-                    _updateCache(\n-                        headers, merged_response, content, self.cache, cachekey\n-                    )\n+                    _updateCache(headers, merged_response, content, self.cache, cachekey)\n                     response = merged_response\n                     response.status = 200\n                     response.fromcache = True\n@@ -2181,15 +1922,7 @@ def request(\n                     content = \"\"\n                 else:\n                     (response, content) = self._request(\n-                        conn,\n-                        authority,\n-                        uri,\n-                        request_uri,\n-                        method,\n-                        body,\n-                        headers,\n-                        redirections,\n-                        cachekey,\n+                        conn, authority, uri, request_uri, method, body, headers, redirections, cachekey,\n                     )\n         except Exception as e:\n             is_timeout = isinstance(e, socket.timeout)\n@@ -2206,23 +1939,11 @@ def request(\n                     response.reason = str(e)\n                 elif is_timeout:\n                     content = \"Request Timeout\"\n-                    response = Response(\n-                        {\n-                            \"content-type\": \"text/plain\",\n-                            \"status\": \"408\",\n-                            \"content-length\": len(content),\n-                        }\n-                    )\n+                    response = Response({\"content-type\": \"text/plain\", \"status\": \"408\", \"content-length\": len(content),})\n                     response.reason = \"Request Timeout\"\n                 else:\n                     content = str(e)\n-                    response = Response(\n-                        {\n-                            \"content-type\": \"text/plain\",\n-                            \"status\": \"400\",\n-                            \"content-length\": len(content),\n-                        }\n-                    )\n+                    response = Response({\"content-type\": \"text/plain\", \"status\": \"400\", \"content-length\": len(content),})\n                     response.reason = \"Bad Request\"\n             else:\n                 raise"
        },
        {
          "filename": "python2/httplib2/auth.py",
          "status": "added",
          "additions": 61,
          "deletions": 0,
          "patch": "@@ -0,0 +1,61 @@\n+import base64\n+import re\n+\n+import pyparsing as pp\n+\n+from .error import *\n+\n+UNQUOTE_PAIRS = re.compile(r\"\\\\(.)\")\n+unquote = lambda s, l, t: UNQUOTE_PAIRS.sub(r\"\\1\", t[0][1:-1])\n+\n+# https://tools.ietf.org/html/rfc7235#section-1.2\n+# https://tools.ietf.org/html/rfc7235#appendix-B\n+tchar = \"!#$%&'*+-.^_`|~\" + pp.nums + pp.alphas\n+token = pp.Word(tchar).setName(\"token\")\n+token68 = pp.Combine(pp.Word(\"-._~+/\" + pp.nums + pp.alphas) + pp.ZeroOrMore(\"=\")).setName(\"token68\")\n+\n+quoted_string = pp.dblQuotedString.copy().setName(\"quoted-string\").setParseAction(unquote)\n+auth_param_name = token.copy().setName(\"auth-param-name\").addParseAction(pp.downcaseTokens)\n+auth_param = auth_param_name + pp.Suppress(\"=\") + (token ^ quoted_string)\n+params = pp.Dict(pp.delimitedList(pp.Group(auth_param)))\n+\n+scheme = token(\"scheme\")\n+challenge = scheme + (token68(\"token\") ^ params(\"params\"))\n+\n+authentication_info = params.copy()\n+www_authenticate = pp.delimitedList(pp.Group(challenge))\n+\n+\n+def _parse_authentication_info(headers, headername=\"authentication-info\"):\n+    \"\"\"https://tools.ietf.org/html/rfc7615\n+    \"\"\"\n+    header = headers.get(headername, \"\").strip()\n+    if not header:\n+        return {}\n+    try:\n+        parsed = authentication_info.parseString(header)\n+    except pp.ParseException as ex:\n+        # print(ex.explain(ex))\n+        raise MalformedHeader(headername)\n+\n+    return parsed.asDict()\n+\n+\n+def _parse_www_authenticate(headers, headername=\"www-authenticate\"):\n+    \"\"\"Returns a dictionary of dictionaries, one dict per auth_scheme.\"\"\"\n+    header = headers.get(headername, \"\").strip()\n+    if not header:\n+        return {}\n+    try:\n+        parsed = www_authenticate.parseString(header)\n+    except pp.ParseException as ex:\n+        # print(ex.explain(ex))\n+        raise MalformedHeader(headername)\n+\n+    retval = {\n+        challenge[\"scheme\"].lower(): challenge[\"params\"].asDict()\n+        if \"params\" in challenge\n+        else {\"token\": challenge.get(\"token\")}\n+        for challenge in parsed\n+    }\n+    return retval"
        },
        {
          "filename": "python2/httplib2/error.py",
          "status": "added",
          "additions": 48,
          "deletions": 0,
          "patch": "@@ -0,0 +1,48 @@\n+# All exceptions raised here derive from HttpLib2Error\n+class HttpLib2Error(Exception):\n+    pass\n+\n+\n+# Some exceptions can be caught and optionally\n+# be turned back into responses.\n+class HttpLib2ErrorWithResponse(HttpLib2Error):\n+    def __init__(self, desc, response, content):\n+        self.response = response\n+        self.content = content\n+        HttpLib2Error.__init__(self, desc)\n+\n+\n+class RedirectMissingLocation(HttpLib2ErrorWithResponse):\n+    pass\n+\n+\n+class RedirectLimit(HttpLib2ErrorWithResponse):\n+    pass\n+\n+\n+class FailedToDecompressContent(HttpLib2ErrorWithResponse):\n+    pass\n+\n+\n+class UnimplementedDigestAuthOptionError(HttpLib2ErrorWithResponse):\n+    pass\n+\n+\n+class UnimplementedHmacDigestAuthOptionError(HttpLib2ErrorWithResponse):\n+    pass\n+\n+\n+class MalformedHeader(HttpLib2Error):\n+    pass\n+\n+\n+class RelativeURIError(HttpLib2Error):\n+    pass\n+\n+\n+class ServerNotFoundError(HttpLib2Error):\n+    pass\n+\n+\n+class ProxiesUnavailableError(HttpLib2Error):\n+    pass"
        },
        {
          "filename": "python3/httplib2/__init__.py",
          "status": "modified",
          "additions": 126,
          "deletions": 423,
          "patch": "@@ -49,6 +49,8 @@\n     # TODO: remove this fallback and copypasted socksipy module upon py2/3 merge,\n     # idea is to have soft-dependency on any compatible module called socks\n     from . import socks\n+from . import auth\n+from .error import *\n from .iri2uri import iri2uri\n \n \n@@ -79,56 +81,6 @@ def has_timeout(timeout):\n RETRIES = 2\n \n \n-# All exceptions raised here derive from HttpLib2Error\n-class HttpLib2Error(Exception):\n-    pass\n-\n-\n-# Some exceptions can be caught and optionally\n-# be turned back into responses.\n-class HttpLib2ErrorWithResponse(HttpLib2Error):\n-    def __init__(self, desc, response, content):\n-        self.response = response\n-        self.content = content\n-        HttpLib2Error.__init__(self, desc)\n-\n-\n-class RedirectMissingLocation(HttpLib2ErrorWithResponse):\n-    pass\n-\n-\n-class RedirectLimit(HttpLib2ErrorWithResponse):\n-    pass\n-\n-\n-class FailedToDecompressContent(HttpLib2ErrorWithResponse):\n-    pass\n-\n-\n-class UnimplementedDigestAuthOptionError(HttpLib2ErrorWithResponse):\n-    pass\n-\n-\n-class UnimplementedHmacDigestAuthOptionError(HttpLib2ErrorWithResponse):\n-    pass\n-\n-\n-class MalformedHeader(HttpLib2Error):\n-    pass\n-\n-\n-class RelativeURIError(HttpLib2Error):\n-    pass\n-\n-\n-class ServerNotFoundError(HttpLib2Error):\n-    pass\n-\n-\n-class ProxiesUnavailableError(HttpLib2Error):\n-    pass\n-\n-\n # Open Items:\n # -----------\n \n@@ -169,28 +121,31 @@ class ProxiesUnavailableError(HttpLib2Error):\n \n \n from httplib2 import certs\n+\n CA_CERTS = certs.where()\n \n # PROTOCOL_TLS is python 3.5.3+. PROTOCOL_SSLv23 is deprecated.\n # Both PROTOCOL_TLS and PROTOCOL_SSLv23 are equivalent and means:\n # > Selects the highest protocol version that both the client and server support.\n # > Despite the name, this option can select \u201cTLS\u201d protocols as well as \u201cSSL\u201d.\n # source: https://docs.python.org/3.5/library/ssl.html#ssl.PROTOCOL_TLS\n-DEFAULT_TLS_VERSION = getattr(ssl, \"PROTOCOL_TLS\", None) or getattr(\n-    ssl, \"PROTOCOL_SSLv23\"\n-)\n+DEFAULT_TLS_VERSION = getattr(ssl, \"PROTOCOL_TLS\", None) or getattr(ssl, \"PROTOCOL_SSLv23\")\n+\n \n def _build_ssl_context(\n-    disable_ssl_certificate_validation, ca_certs, cert_file=None, key_file=None,\n-    maximum_version=None, minimum_version=None, key_password=None,\n+    disable_ssl_certificate_validation,\n+    ca_certs,\n+    cert_file=None,\n+    key_file=None,\n+    maximum_version=None,\n+    minimum_version=None,\n+    key_password=None,\n ):\n     if not hasattr(ssl, \"SSLContext\"):\n         raise RuntimeError(\"httplib2 requires Python 3.2+ for ssl.SSLContext\")\n \n     context = ssl.SSLContext(DEFAULT_TLS_VERSION)\n-    context.verify_mode = (\n-        ssl.CERT_NONE if disable_ssl_certificate_validation else ssl.CERT_REQUIRED\n-    )\n+    context.verify_mode = ssl.CERT_NONE if disable_ssl_certificate_validation else ssl.CERT_REQUIRED\n \n     # SSLContext.maximum_version and SSLContext.minimum_version are python 3.7+.\n     # source: https://docs.python.org/3/library/ssl.html#ssl.SSLContext.maximum_version\n@@ -288,10 +243,7 @@ def safename(filename):\n def _normalize_headers(headers):\n     return dict(\n         [\n-            (\n-                _convert_byte_str(key).lower(),\n-                NORMALIZE_SPACE.sub(_convert_byte_str(value), \" \").strip(),\n-            )\n+            (_convert_byte_str(key).lower(), NORMALIZE_SPACE.sub(_convert_byte_str(value), \" \").strip(),)\n             for (key, value) in headers.items()\n         ]\n     )\n@@ -308,13 +260,9 @@ def _parse_cache_control(headers):\n     if \"cache-control\" in headers:\n         parts = headers[\"cache-control\"].split(\",\")\n         parts_with_args = [\n-            tuple([x.strip().lower() for x in part.split(\"=\", 1)])\n-            for part in parts\n-            if -1 != part.find(\"=\")\n-        ]\n-        parts_wo_args = [\n-            (name.strip().lower(), 1) for name in parts if -1 == name.find(\"=\")\n+            tuple([x.strip().lower() for x in part.split(\"=\", 1)]) for part in parts if -1 != part.find(\"=\")\n         ]\n+        parts_wo_args = [(name.strip().lower(), 1) for name in parts if -1 == name.find(\"=\")]\n         retval = dict(parts_with_args + parts_wo_args)\n     return retval\n \n@@ -325,53 +273,6 @@ def _parse_cache_control(headers):\n # Set to true to turn on, useful for testing servers.\n USE_WWW_AUTH_STRICT_PARSING = 0\n \n-# In regex below:\n-#    [^\\0-\\x1f\\x7f-\\xff()<>@,;:\\\\\\\"/[\\]?={} \\t]+             matches a \"token\" as defined by HTTP\n-#    \"(?:[^\\0-\\x08\\x0A-\\x1f\\x7f-\\xff\\\\\\\"]|\\\\[\\0-\\x7f])*?\"    matches a \"quoted-string\" as defined by HTTP, when LWS have already been replaced by a single space\n-# Actually, as an auth-param value can be either a token or a quoted-string, they are combined in a single pattern which matches both:\n-#    \\\"?((?<=\\\")(?:[^\\0-\\x1f\\x7f-\\xff\\\\\\\"]|\\\\[\\0-\\x7f])*?(?=\\\")|(?<!\\\")[^\\0-\\x08\\x0A-\\x1f\\x7f-\\xff()<>@,;:\\\\\\\"/[\\]?={} \\t]+(?!\\\"))\\\"?\n-WWW_AUTH_STRICT = re.compile(\n-    r\"^(?:\\s*(?:,\\s*)?([^\\0-\\x1f\\x7f-\\xff()<>@,;:\\\\\\\"/[\\]?={} \\t]+)\\s*=\\s*\\\"?((?<=\\\")(?:[^\\0-\\x08\\x0A-\\x1f\\x7f-\\xff\\\\\\\"]|\\\\[\\0-\\x7f])*?(?=\\\")|(?<!\\\")[^\\0-\\x1f\\x7f-\\xff()<>@,;:\\\\\\\"/[\\]?={} \\t]+(?!\\\"))\\\"?)(.*)$\"\n-)\n-WWW_AUTH_RELAXED = re.compile(\n-    r\"^(?:\\s*(?:,\\s*)?([^ \\t\\r\\n=]+)\\s*=\\s*\\\"?((?<=\\\")(?:[^\\\\\\\"]|\\\\.)*?(?=\\\")|(?<!\\\")[^ \\t\\r\\n,]+(?!\\\"))\\\"?)(.*)$\"\n-)\n-UNQUOTE_PAIRS = re.compile(r\"\\\\(.)\")\n-\n-\n-def _parse_www_authenticate(headers, headername=\"www-authenticate\"):\n-    \"\"\"Returns a dictionary of dictionaries, one dict\n-    per auth_scheme.\"\"\"\n-    retval = {}\n-    if headername in headers:\n-        try:\n-            authenticate = headers[headername].strip()\n-            www_auth = (\n-                USE_WWW_AUTH_STRICT_PARSING and WWW_AUTH_STRICT or WWW_AUTH_RELAXED\n-            )\n-            while authenticate:\n-                # Break off the scheme at the beginning of the line\n-                if headername == \"authentication-info\":\n-                    (auth_scheme, the_rest) = (\"digest\", authenticate)\n-                else:\n-                    (auth_scheme, the_rest) = authenticate.split(\" \", 1)\n-                # Now loop over all the key value pairs that come after the scheme,\n-                # being careful not to roll into the next scheme\n-                match = www_auth.search(the_rest)\n-                auth_params = {}\n-                while match:\n-                    if match and len(match.groups()) == 3:\n-                        (key, value, the_rest) = match.groups()\n-                        auth_params[key.lower()] = UNQUOTE_PAIRS.sub(\n-                            r\"\\1\", value\n-                        )  # '\\\\'.join([x.replace('\\\\', '') for x in value.split('\\\\\\\\')])\n-                    match = www_auth.search(the_rest)\n-                retval[auth_scheme.lower()] = auth_params\n-                authenticate = the_rest.strip()\n-        except ValueError:\n-            raise MalformedHeader(\"WWW-Authenticate\")\n-    return retval\n-\n \n def _entry_disposition(response_headers, request_headers):\n     \"\"\"Determine freshness from the Date, Expires and Cache-Control headers.\n@@ -405,10 +306,7 @@ def _entry_disposition(response_headers, request_headers):\n     cc = _parse_cache_control(request_headers)\n     cc_response = _parse_cache_control(response_headers)\n \n-    if (\n-        \"pragma\" in request_headers\n-        and request_headers[\"pragma\"].lower().find(\"no-cache\") != -1\n-    ):\n+    if \"pragma\" in request_headers and request_headers[\"pragma\"].lower().find(\"no-cache\") != -1:\n         retval = \"TRANSPARENT\"\n         if \"cache-control\" not in request_headers:\n             request_headers[\"cache-control\"] = \"no-cache\"\n@@ -467,8 +365,7 @@ def _decompressContent(response, new_content):\n     except (IOError, zlib.error):\n         content = \"\"\n         raise FailedToDecompressContent(\n-            _(\"Content purported to be compressed with %s but failed to decompress.\")\n-            % response.get(\"content-encoding\"),\n+            _(\"Content purported to be compressed with %s but failed to decompress.\") % response.get(\"content-encoding\"),\n             response,\n             content,\n         )\n@@ -484,9 +381,7 @@ def _write_headers(self):\n                 print(v.encode(maxlinelen=self._maxheaderlen), file=self._fp)\n             else:\n                 # email.Header got lots of smarts, so use it.\n-                headers = header.Header(\n-                    v, maxlinelen=self._maxheaderlen, charset=\"utf-8\", header_name=h\n-                )\n+                headers = header.Header(v, maxlinelen=self._maxheaderlen, charset=\"utf-8\", header_name=h)\n                 print(headers.encode(), file=self._fp)\n         # A blank line always separates headers from body.\n         print(file=self._fp)\n@@ -531,27 +426,22 @@ def _updateCache(request_headers, response_headers, content, cache, cachekey):\n                 header_str = info.as_string()\n \n             header_str = re.sub(\"\\r(?!\\n)|(?<!\\r)\\n\", \"\\r\\n\", header_str)\n-            text = b\"\".join(\n-                [status_header.encode(\"utf-8\"), header_str.encode(\"utf-8\"), content]\n-            )\n+            text = b\"\".join([status_header.encode(\"utf-8\"), header_str.encode(\"utf-8\"), content])\n \n             cache.set(cachekey, text)\n \n \n def _cnonce():\n     dig = _md5(\n-        (\n-            \"%s:%s\"\n-            % (time.ctime(), [\"0123456789\"[random.randrange(0, 9)] for i in range(20)])\n-        ).encode(\"utf-8\")\n+        (\"%s:%s\" % (time.ctime(), [\"0123456789\"[random.randrange(0, 9)] for i in range(20)])).encode(\"utf-8\")\n     ).hexdigest()\n     return dig[:16]\n \n \n def _wsse_username_token(cnonce, iso_now, password):\n-    return base64.b64encode(\n-        _sha((\"%s%s%s\" % (cnonce, iso_now, password)).encode(\"utf-8\")).digest()\n-    ).strip().decode(\"utf-8\")\n+    return (\n+        base64.b64encode(_sha((\"%s%s%s\" % (cnonce, iso_now, password)).encode(\"utf-8\")).digest()).strip().decode(\"utf-8\")\n+    )\n \n \n # For credentials we need two things, first\n@@ -564,9 +454,7 @@ def _wsse_username_token(cnonce, iso_now, password):\n \n \n class Authentication(object):\n-    def __init__(\n-        self, credentials, host, request_uri, headers, response, content, http\n-    ):\n+    def __init__(self, credentials, host, request_uri, headers, response, content, http):\n         (scheme, authority, path, query, fragment) = parse_uri(request_uri)\n         self.path = path\n         self.host = host\n@@ -620,12 +508,8 @@ def __bool__(self):\n \n \n class BasicAuthentication(Authentication):\n-    def __init__(\n-        self, credentials, host, request_uri, headers, response, content, http\n-    ):\n-        Authentication.__init__(\n-            self, credentials, host, request_uri, headers, response, content, http\n-        )\n+    def __init__(self, credentials, host, request_uri, headers, response, content, http):\n+        Authentication.__init__(self, credentials, host, request_uri, headers, response, content, http)\n \n     def request(self, method, request_uri, headers, content):\n         \"\"\"Modify the request headers to add the appropriate\n@@ -639,36 +523,19 @@ class DigestAuthentication(Authentication):\n     \"\"\"Only do qop='auth' and MD5, since that\n     is all Apache currently implements\"\"\"\n \n-    def __init__(\n-        self, credentials, host, request_uri, headers, response, content, http\n-    ):\n-        Authentication.__init__(\n-            self, credentials, host, request_uri, headers, response, content, http\n-        )\n-        challenge = _parse_www_authenticate(response, \"www-authenticate\")\n-        self.challenge = challenge[\"digest\"]\n+    def __init__(self, credentials, host, request_uri, headers, response, content, http):\n+        Authentication.__init__(self, credentials, host, request_uri, headers, response, content, http)\n+        self.challenge = auth._parse_www_authenticate(response, \"www-authenticate\")[\"digest\"]\n         qop = self.challenge.get(\"qop\", \"auth\")\n-        self.challenge[\"qop\"] = (\n-            (\"auth\" in [x.strip() for x in qop.split()]) and \"auth\" or None\n-        )\n+        self.challenge[\"qop\"] = (\"auth\" in [x.strip() for x in qop.split()]) and \"auth\" or None\n         if self.challenge[\"qop\"] is None:\n-            raise UnimplementedDigestAuthOptionError(\n-                _(\"Unsupported value for qop: %s.\" % qop)\n-            )\n+            raise UnimplementedDigestAuthOptionError(_(\"Unsupported value for qop: %s.\" % qop))\n         self.challenge[\"algorithm\"] = self.challenge.get(\"algorithm\", \"MD5\").upper()\n         if self.challenge[\"algorithm\"] != \"MD5\":\n             raise UnimplementedDigestAuthOptionError(\n                 _(\"Unsupported value for algorithm: %s.\" % self.challenge[\"algorithm\"])\n             )\n-        self.A1 = \"\".join(\n-            [\n-                self.credentials[0],\n-                \":\",\n-                self.challenge[\"realm\"],\n-                \":\",\n-                self.credentials[1],\n-            ]\n-        )\n+        self.A1 = \"\".join([self.credentials[0], \":\", self.challenge[\"realm\"], \":\", self.credentials[1],])\n         self.challenge[\"nc\"] = 1\n \n     def request(self, method, request_uri, headers, content, cnonce=None):\n@@ -709,17 +576,13 @@ def request(self, method, request_uri, headers, content, cnonce=None):\n \n     def response(self, response, content):\n         if \"authentication-info\" not in response:\n-            challenge = _parse_www_authenticate(response, \"www-authenticate\").get(\n-                \"digest\", {}\n-            )\n+            challenge = auth._parse_www_authenticate(response, \"www-authenticate\").get(\"digest\", {})\n             if \"true\" == challenge.get(\"stale\"):\n                 self.challenge[\"nonce\"] = challenge[\"nonce\"]\n                 self.challenge[\"nc\"] = 1\n                 return True\n         else:\n-            updated_challenge = _parse_www_authenticate(\n-                response, \"authentication-info\"\n-            ).get(\"digest\", {})\n+            updated_challenge = auth._parse_authentication_info(response, \"authentication-info\")\n \n             if \"nextnonce\" in updated_challenge:\n                 self.challenge[\"nonce\"] = updated_challenge[\"nextnonce\"]\n@@ -732,13 +595,9 @@ class HmacDigestAuthentication(Authentication):\n \n     __author__ = \"Thomas Broyer (t.broyer@ltgt.net)\"\n \n-    def __init__(\n-        self, credentials, host, request_uri, headers, response, content, http\n-    ):\n-        Authentication.__init__(\n-            self, credentials, host, request_uri, headers, response, content, http\n-        )\n-        challenge = _parse_www_authenticate(response, \"www-authenticate\")\n+    def __init__(self, credentials, host, request_uri, headers, response, content, http):\n+        Authentication.__init__(self, credentials, host, request_uri, headers, response, content, http)\n+        challenge = auth._parse_www_authenticate(response, \"www-authenticate\")\n         self.challenge = challenge[\"hmacdigest\"]\n         # TODO: self.challenge['domain']\n         self.challenge[\"reason\"] = self.challenge.get(\"reason\", \"unauthorized\")\n@@ -757,10 +616,7 @@ def __init__(\n         self.challenge[\"pw-algorithm\"] = self.challenge.get(\"pw-algorithm\", \"SHA-1\")\n         if self.challenge[\"pw-algorithm\"] not in [\"SHA-1\", \"MD5\"]:\n             raise UnimplementedHmacDigestAuthOptionError(\n-                _(\n-                    \"Unsupported value for pw-algorithm: %s.\"\n-                    % self.challenge[\"pw-algorithm\"]\n-                )\n+                _(\"Unsupported value for pw-algorithm: %s.\" % self.challenge[\"pw-algorithm\"])\n             )\n         if self.challenge[\"algorithm\"] == \"HMAC-MD5\":\n             self.hashmod = _md5\n@@ -774,11 +630,7 @@ def __init__(\n             [\n                 self.credentials[0],\n                 \":\",\n-                self.pwhashmod.new(\n-                    \"\".join([self.credentials[1], self.challenge[\"salt\"]])\n-                )\n-                .hexdigest()\n-                .lower(),\n+                self.pwhashmod.new(\"\".join([self.credentials[1], self.challenge[\"salt\"]])).hexdigest().lower(),\n                 \":\",\n                 self.challenge[\"realm\"],\n             ]\n@@ -792,16 +644,8 @@ def request(self, method, request_uri, headers, content):\n         headers_val = \"\".join([headers[k] for k in keys])\n         created = time.strftime(\"%Y-%m-%dT%H:%M:%SZ\", time.gmtime())\n         cnonce = _cnonce()\n-        request_digest = \"%s:%s:%s:%s:%s\" % (\n-            method,\n-            request_uri,\n-            cnonce,\n-            self.challenge[\"snonce\"],\n-            headers_val,\n-        )\n-        request_digest = (\n-            hmac.new(self.key, request_digest, self.hashmod).hexdigest().lower()\n-        )\n+        request_digest = \"%s:%s:%s:%s:%s\" % (method, request_uri, cnonce, self.challenge[\"snonce\"], headers_val,)\n+        request_digest = hmac.new(self.key, request_digest, self.hashmod).hexdigest().lower()\n         headers[\"authorization\"] = (\n             'HMACDigest username=\"%s\", realm=\"%s\", snonce=\"%s\",'\n             ' cnonce=\"%s\", uri=\"%s\", created=\"%s\", '\n@@ -818,9 +662,7 @@ def request(self, method, request_uri, headers, content):\n         )\n \n     def response(self, response, content):\n-        challenge = _parse_www_authenticate(response, \"www-authenticate\").get(\n-            \"hmacdigest\", {}\n-        )\n+        challenge = auth._parse_www_authenticate(response, \"www-authenticate\").get(\"hmacdigest\", {})\n         if challenge.get(\"reason\") in [\"integrity\", \"stale\"]:\n             return True\n         return False\n@@ -835,12 +677,8 @@ class WsseAuthentication(Authentication):\n     challenge but instead requiring your client to telepathically know that\n     their endpoint is expecting WSSE profile=\"UsernameToken\".\"\"\"\n \n-    def __init__(\n-        self, credentials, host, request_uri, headers, response, content, http\n-    ):\n-        Authentication.__init__(\n-            self, credentials, host, request_uri, headers, response, content, http\n-        )\n+    def __init__(self, credentials, host, request_uri, headers, response, content, http):\n+        Authentication.__init__(self, credentials, host, request_uri, headers, response, content, http)\n \n     def request(self, method, request_uri, headers, content):\n         \"\"\"Modify the request headers to add the appropriate\n@@ -849,22 +687,20 @@ def request(self, method, request_uri, headers, content):\n         iso_now = time.strftime(\"%Y-%m-%dT%H:%M:%SZ\", time.gmtime())\n         cnonce = _cnonce()\n         password_digest = _wsse_username_token(cnonce, iso_now, self.credentials[1])\n-        headers[\"X-WSSE\"] = (\n-            'UsernameToken Username=\"%s\", PasswordDigest=\"%s\", '\n-            'Nonce=\"%s\", Created=\"%s\"'\n-        ) % (self.credentials[0], password_digest, cnonce, iso_now)\n+        headers[\"X-WSSE\"] = ('UsernameToken Username=\"%s\", PasswordDigest=\"%s\", ' 'Nonce=\"%s\", Created=\"%s\"') % (\n+            self.credentials[0],\n+            password_digest,\n+            cnonce,\n+            iso_now,\n+        )\n \n \n class GoogleLoginAuthentication(Authentication):\n-    def __init__(\n-        self, credentials, host, request_uri, headers, response, content, http\n-    ):\n+    def __init__(self, credentials, host, request_uri, headers, response, content, http):\n         from urllib.parse import urlencode\n \n-        Authentication.__init__(\n-            self, credentials, host, request_uri, headers, response, content, http\n-        )\n-        challenge = _parse_www_authenticate(response, \"www-authenticate\")\n+        Authentication.__init__(self, credentials, host, request_uri, headers, response, content, http)\n+        challenge = auth._parse_www_authenticate(response, \"www-authenticate\")\n         service = challenge[\"googlelogin\"].get(\"service\", \"xapi\")\n         # Bloggger actually returns the service in the challenge\n         # For the rest we guess based on the URI\n@@ -874,12 +710,7 @@ def __init__(\n         # elif request_uri.find(\"spreadsheets\") > 0:\n         #    service = \"wise\"\n \n-        auth = dict(\n-            Email=credentials[0],\n-            Passwd=credentials[1],\n-            service=service,\n-            source=headers[\"user-agent\"],\n-        )\n+        auth = dict(Email=credentials[0], Passwd=credentials[1], service=service, source=headers[\"user-agent\"],)\n         resp, content = self.http.request(\n             \"https://www.google.com/accounts/ClientLogin\",\n             method=\"POST\",\n@@ -916,9 +747,7 @@ class FileCache(object):\n     be running on the same cache.\n     \"\"\"\n \n-    def __init__(\n-        self, cache, safe=safename\n-    ):  # use safe=lambda x: md5.new(x).hexdigest() for the old behavior\n+    def __init__(self, cache, safe=safename):  # use safe=lambda x: md5.new(x).hexdigest() for the old behavior\n         self.cache = cache\n         self.safe = safe\n         if not os.path.exists(cache):\n@@ -966,6 +795,7 @@ def iter(self, domain):\n class KeyCerts(Credentials):\n     \"\"\"Identical to Credentials except that\n     name/password are mapped to key/cert.\"\"\"\n+\n     def add(self, key, cert, domain, password):\n         self.credentials.append((domain.lower(), key, cert, password))\n \n@@ -985,14 +815,7 @@ class ProxyInfo(object):\n     bypass_hosts = ()\n \n     def __init__(\n-        self,\n-        proxy_type,\n-        proxy_host,\n-        proxy_port,\n-        proxy_rdns=True,\n-        proxy_user=None,\n-        proxy_pass=None,\n-        proxy_headers=None,\n+        self, proxy_type, proxy_host, proxy_port, proxy_rdns=True, proxy_user=None, proxy_pass=None, proxy_headers=None,\n     ):\n         \"\"\"Args:\n \n@@ -1015,7 +838,15 @@ def __init__(\n             proxy_user = proxy_user.decode()\n         if isinstance(proxy_pass, bytes):\n             proxy_pass = proxy_pass.decode()\n-        self.proxy_type, self.proxy_host, self.proxy_port, self.proxy_rdns, self.proxy_user, self.proxy_pass, self.proxy_headers = (\n+        (\n+            self.proxy_type,\n+            self.proxy_host,\n+            self.proxy_port,\n+            self.proxy_rdns,\n+            self.proxy_user,\n+            self.proxy_pass,\n+            self.proxy_headers,\n+        ) = (\n             proxy_type,\n             proxy_host,\n             proxy_port,\n@@ -1149,14 +980,18 @@ def __init__(self, host, port=None, timeout=None, proxy_info=None):\n     def connect(self):\n         \"\"\"Connect to the host and port specified in __init__.\"\"\"\n         if self.proxy_info and socks is None:\n-            raise ProxiesUnavailableError(\n-                \"Proxy support missing but proxy use was requested!\"\n-            )\n+            raise ProxiesUnavailableError(\"Proxy support missing but proxy use was requested!\")\n         if self.proxy_info and self.proxy_info.isgood() and self.proxy_info.applies_to(self.host):\n             use_proxy = True\n-            proxy_type, proxy_host, proxy_port, proxy_rdns, proxy_user, proxy_pass, proxy_headers = (\n-                self.proxy_info.astuple()\n-            )\n+            (\n+                proxy_type,\n+                proxy_host,\n+                proxy_port,\n+                proxy_rdns,\n+                proxy_user,\n+                proxy_pass,\n+                proxy_headers,\n+            ) = self.proxy_info.astuple()\n \n             host = proxy_host\n             port = proxy_port\n@@ -1175,35 +1010,19 @@ def connect(self):\n                 if use_proxy:\n                     self.sock = socks.socksocket(af, socktype, proto)\n                     self.sock.setproxy(\n-                        proxy_type,\n-                        proxy_host,\n-                        proxy_port,\n-                        proxy_rdns,\n-                        proxy_user,\n-                        proxy_pass,\n+                        proxy_type, proxy_host, proxy_port, proxy_rdns, proxy_user, proxy_pass,\n                     )\n                 else:\n                     self.sock = socket.socket(af, socktype, proto)\n                     self.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n                 if has_timeout(self.timeout):\n                     self.sock.settimeout(self.timeout)\n                 if self.debuglevel > 0:\n-                    print(\n-                        \"connect: ({0}, {1}) ************\".format(self.host, self.port)\n-                    )\n+                    print(\"connect: ({0}, {1}) ************\".format(self.host, self.port))\n                     if use_proxy:\n                         print(\n                             \"proxy: {0} ************\".format(\n-                                str(\n-                                    (\n-                                        proxy_host,\n-                                        proxy_port,\n-                                        proxy_rdns,\n-                                        proxy_user,\n-                                        proxy_pass,\n-                                        proxy_headers,\n-                                    )\n-                                )\n+                                str((proxy_host, proxy_port, proxy_rdns, proxy_user, proxy_pass, proxy_headers,))\n                             )\n                         )\n \n@@ -1215,16 +1034,7 @@ def connect(self):\n                     if use_proxy:\n                         print(\n                             \"proxy: {0}\".format(\n-                                str(\n-                                    (\n-                                        proxy_host,\n-                                        proxy_port,\n-                                        proxy_rdns,\n-                                        proxy_user,\n-                                        proxy_pass,\n-                                        proxy_headers,\n-                                    )\n-                                )\n+                                str((proxy_host, proxy_port, proxy_rdns, proxy_user, proxy_pass, proxy_headers,))\n                             )\n                         )\n                 if self.sock:\n@@ -1268,15 +1078,16 @@ def __init__(\n             self.proxy_info = proxy_info(\"https\")\n \n         context = _build_ssl_context(\n-            self.disable_ssl_certificate_validation, self.ca_certs, cert_file, key_file,\n-            maximum_version=tls_maximum_version, minimum_version=tls_minimum_version,\n+            self.disable_ssl_certificate_validation,\n+            self.ca_certs,\n+            cert_file,\n+            key_file,\n+            maximum_version=tls_maximum_version,\n+            minimum_version=tls_minimum_version,\n             key_password=key_password,\n         )\n         super(HTTPSConnectionWithTimeout, self).__init__(\n-            host,\n-            port=port,\n-            timeout=timeout,\n-            context=context,\n+            host, port=port, timeout=timeout, context=context,\n         )\n         self.key_file = key_file\n         self.cert_file = cert_file\n@@ -1286,9 +1097,15 @@ def connect(self):\n         \"\"\"Connect to a host on a given (SSL) port.\"\"\"\n         if self.proxy_info and self.proxy_info.isgood() and self.proxy_info.applies_to(self.host):\n             use_proxy = True\n-            proxy_type, proxy_host, proxy_port, proxy_rdns, proxy_user, proxy_pass, proxy_headers = (\n-                self.proxy_info.astuple()\n-            )\n+            (\n+                proxy_type,\n+                proxy_host,\n+                proxy_port,\n+                proxy_rdns,\n+                proxy_user,\n+                proxy_pass,\n+                proxy_headers,\n+            ) = self.proxy_info.astuple()\n \n             host = proxy_host\n             port = proxy_port\n@@ -1309,12 +1126,7 @@ def connect(self):\n                     sock = socks.socksocket(family, socktype, proto)\n \n                     sock.setproxy(\n-                        proxy_type,\n-                        proxy_host,\n-                        proxy_port,\n-                        proxy_rdns,\n-                        proxy_user,\n-                        proxy_pass,\n+                        proxy_type, proxy_host, proxy_port, proxy_rdns, proxy_user, proxy_pass,\n                     )\n                 else:\n                     sock = socket.socket(family, socktype, proto)\n@@ -1326,10 +1138,7 @@ def connect(self):\n                 self.sock = self._context.wrap_socket(sock, server_hostname=self.host)\n \n                 # Python 3.3 compatibility: emulate the check_hostname behavior\n-                if (\n-                    not hasattr(self._context, \"check_hostname\")\n-                    and not self.disable_ssl_certificate_validation\n-                ):\n+                if not hasattr(self._context, \"check_hostname\") and not self.disable_ssl_certificate_validation:\n                     try:\n                         ssl.match_hostname(self.sock.getpeercert(), self.host)\n                     except Exception:\n@@ -1342,16 +1151,7 @@ def connect(self):\n                     if use_proxy:\n                         print(\n                             \"proxy: {0}\".format(\n-                                str(\n-                                    (\n-                                        proxy_host,\n-                                        proxy_port,\n-                                        proxy_rdns,\n-                                        proxy_user,\n-                                        proxy_pass,\n-                                        proxy_headers,\n-                                    )\n-                                )\n+                                str((proxy_host, proxy_port, proxy_rdns, proxy_user, proxy_pass, proxy_headers,))\n                             )\n                         )\n             except (ssl.SSLError, ssl.CertificateError) as e:\n@@ -1370,16 +1170,7 @@ def connect(self):\n                     if use_proxy:\n                         print(\n                             \"proxy: {0}\".format(\n-                                str(\n-                                    (\n-                                        proxy_host,\n-                                        proxy_port,\n-                                        proxy_rdns,\n-                                        proxy_user,\n-                                        proxy_pass,\n-                                        proxy_headers,\n-                                    )\n-                                )\n+                                str((proxy_host, proxy_port, proxy_rdns, proxy_user, proxy_pass, proxy_headers,))\n                             )\n                         )\n                 if self.sock:\n@@ -1523,13 +1314,11 @@ def _auth_from_challenge(self, host, request_uri, headers, response, content):\n         \"\"\"A generator that creates Authorization objects\n            that can be applied to requests.\n         \"\"\"\n-        challenges = _parse_www_authenticate(response, \"www-authenticate\")\n+        challenges = auth._parse_www_authenticate(response, \"www-authenticate\")\n         for cred in self.credentials.iter(host):\n             for scheme in AUTH_SCHEME_ORDER:\n                 if scheme in challenges:\n-                    yield AUTH_SCHEME_CLASSES[scheme](\n-                        cred, host, request_uri, headers, response, content, self\n-                    )\n+                    yield AUTH_SCHEME_CLASSES[scheme](cred, host, request_uri, headers, response, content, self)\n \n     def add_credentials(self, name, password, domain=\"\"):\n         \"\"\"Add a name and password that will be used\n@@ -1563,9 +1352,7 @@ def _conn_request(self, conn, request_uri, method, body, headers):\n                 conn.close()\n                 raise ServerNotFoundError(\"Unable to find the server at %s\" % conn.host)\n             except socket.error as e:\n-                errno_ = (\n-                    e.args[0].errno if isinstance(e.args[0], socket.error) else e.errno\n-                )\n+                errno_ = e.args[0].errno if isinstance(e.args[0], socket.error) else e.errno\n                 if errno_ in (errno.ENETUNREACH, errno.EADDRNOTAVAIL) and i < RETRIES:\n                     continue  # retry on potentially transient errors\n                 raise\n@@ -1624,79 +1411,48 @@ def _conn_request(self, conn, request_uri, method, body, headers):\n         return (response, content)\n \n     def _request(\n-        self,\n-        conn,\n-        host,\n-        absolute_uri,\n-        request_uri,\n-        method,\n-        body,\n-        headers,\n-        redirections,\n-        cachekey,\n+        self, conn, host, absolute_uri, request_uri, method, body, headers, redirections, cachekey,\n     ):\n         \"\"\"Do the actual request using the connection object\n         and also follow one level of redirects if necessary\"\"\"\n \n-        auths = [\n-            (auth.depth(request_uri), auth)\n-            for auth in self.authorizations\n-            if auth.inscope(host, request_uri)\n-        ]\n+        auths = [(auth.depth(request_uri), auth) for auth in self.authorizations if auth.inscope(host, request_uri)]\n         auth = auths and sorted(auths)[0][1] or None\n         if auth:\n             auth.request(method, request_uri, headers, body)\n \n-        (response, content) = self._conn_request(\n-            conn, request_uri, method, body, headers\n-        )\n+        (response, content) = self._conn_request(conn, request_uri, method, body, headers)\n \n         if auth:\n             if auth.response(response, body):\n                 auth.request(method, request_uri, headers, body)\n-                (response, content) = self._conn_request(\n-                    conn, request_uri, method, body, headers\n-                )\n+                (response, content) = self._conn_request(conn, request_uri, method, body, headers)\n                 response._stale_digest = 1\n \n         if response.status == 401:\n-            for authorization in self._auth_from_challenge(\n-                host, request_uri, headers, response, content\n-            ):\n+            for authorization in self._auth_from_challenge(host, request_uri, headers, response, content):\n                 authorization.request(method, request_uri, headers, body)\n-                (response, content) = self._conn_request(\n-                    conn, request_uri, method, body, headers\n-                )\n+                (response, content) = self._conn_request(conn, request_uri, method, body, headers)\n                 if response.status != 401:\n                     self.authorizations.append(authorization)\n                     authorization.response(response, body)\n                     break\n \n-        if (\n-            self.follow_all_redirects\n-            or method in self.safe_methods\n-            or response.status in (303, 308)\n-        ):\n+        if self.follow_all_redirects or method in self.safe_methods or response.status in (303, 308):\n             if self.follow_redirects and response.status in self.redirect_codes:\n                 # Pick out the location header and basically start from the beginning\n                 # remembering first to strip the ETag header and decrement our 'depth'\n                 if redirections:\n                     if \"location\" not in response and response.status != 300:\n                         raise RedirectMissingLocation(\n-                            _(\n-                                \"Redirected but the response is missing a Location: header.\"\n-                            ),\n-                            response,\n-                            content,\n+                            _(\"Redirected but the response is missing a Location: header.\"), response, content,\n                         )\n                     # Fix-up relative redirects (which violate an RFC 2616 MUST)\n                     if \"location\" in response:\n                         location = response[\"location\"]\n                         (scheme, authority, path, query, fragment) = parse_uri(location)\n                         if authority == None:\n-                            response[\"location\"] = urllib.parse.urljoin(\n-                                absolute_uri, location\n-                            )\n+                            response[\"location\"] = urllib.parse.urljoin(absolute_uri, location)\n                     if response.status == 308 or (response.status == 301 and (method in self.safe_methods)):\n                         response[\"-x-permanent-redirect-url\"] = response[\"location\"]\n                         if \"content-location\" not in response:\n@@ -1706,10 +1462,7 @@ def _request(\n                         del headers[\"if-none-match\"]\n                     if \"if-modified-since\" in headers:\n                         del headers[\"if-modified-since\"]\n-                    if (\n-                        \"authorization\" in headers\n-                        and not self.forward_authorization_headers\n-                    ):\n+                    if \"authorization\" in headers and not self.forward_authorization_headers:\n                         del headers[\"authorization\"]\n                     if \"location\" in response:\n                         location = response[\"location\"]\n@@ -1721,18 +1474,12 @@ def _request(\n                             redirect_method = \"GET\"\n                             body = None\n                         (response, content) = self.request(\n-                            location,\n-                            method=redirect_method,\n-                            body=body,\n-                            headers=headers,\n-                            redirections=redirections - 1,\n+                            location, method=redirect_method, body=body, headers=headers, redirections=redirections - 1,\n                         )\n                         response.previous = old_response\n                 else:\n                     raise RedirectLimit(\n-                        \"Redirected more times than redirection_limit allows.\",\n-                        response,\n-                        content,\n+                        \"Redirected more times than redirection_limit allows.\", response, content,\n                     )\n             elif response.status in [200, 203] and method in self.safe_methods:\n                 # Don't cache 206's since we aren't going to handle byte range requests\n@@ -1750,13 +1497,7 @@ def _normalize_headers(self, headers):\n     # including all socket.* and httplib.* exceptions.\n \n     def request(\n-        self,\n-        uri,\n-        method=\"GET\",\n-        body=None,\n-        headers=None,\n-        redirections=DEFAULT_MAX_REDIRECTS,\n-        connection_type=None,\n+        self, uri, method=\"GET\", body=None, headers=None, redirections=DEFAULT_MAX_REDIRECTS, connection_type=None,\n     ):\n         \"\"\" Performs a single HTTP request.\n The 'uri' is the URI of the HTTP resource and can begin\n@@ -1778,7 +1519,7 @@ def request(\n being and instance of the 'Response' class, the second being\n a string that contains the response entity body.\n         \"\"\"\n-        conn_key = ''\n+        conn_key = \"\"\n \n         try:\n             if headers is None:\n@@ -1847,9 +1588,7 @@ def request(\n                         info = email.message_from_bytes(info)\n                         for k, v in info.items():\n                             if v.startswith(\"=?\") and v.endswith(\"?=\"):\n-                                info.replace_header(\n-                                    k, str(*email.header.decode_header(v)[0])\n-                                )\n+                                info.replace_header(k, str(*email.header.decode_header(v)[0]))\n                     except (IndexError, ValueError):\n                         self.cache.delete(cachekey)\n                         cachekey = None\n@@ -1896,9 +1635,7 @@ def request(\n                     # Should cached permanent redirects be counted in our redirection count? For now, yes.\n                     if redirections <= 0:\n                         raise RedirectLimit(\n-                            \"Redirected more times than redirection_limit allows.\",\n-                            {},\n-                            \"\",\n+                            \"Redirected more times than redirection_limit allows.\", {}, \"\",\n                         )\n                     (response, new_content) = self.request(\n                         info[\"-x-permanent-redirect-url\"],\n@@ -1929,27 +1666,15 @@ def request(\n                         return (response, content)\n \n                     if entry_disposition == \"STALE\":\n-                        if (\n-                            \"etag\" in info\n-                            and not self.ignore_etag\n-                            and not \"if-none-match\" in headers\n-                        ):\n+                        if \"etag\" in info and not self.ignore_etag and not \"if-none-match\" in headers:\n                             headers[\"if-none-match\"] = info[\"etag\"]\n                         if \"last-modified\" in info and not \"last-modified\" in headers:\n                             headers[\"if-modified-since\"] = info[\"last-modified\"]\n                     elif entry_disposition == \"TRANSPARENT\":\n                         pass\n \n                     (response, new_content) = self._request(\n-                        conn,\n-                        authority,\n-                        uri,\n-                        request_uri,\n-                        method,\n-                        body,\n-                        headers,\n-                        redirections,\n-                        cachekey,\n+                        conn, authority, uri, request_uri, method, body, headers, redirections, cachekey,\n                     )\n \n                 if response.status == 304 and method == \"GET\":\n@@ -1963,9 +1688,7 @@ def request(\n                     merged_response = Response(info)\n                     if hasattr(response, \"_stale_digest\"):\n                         merged_response._stale_digest = response._stale_digest\n-                    _updateCache(\n-                        headers, merged_response, content, self.cache, cachekey\n-                    )\n+                    _updateCache(headers, merged_response, content, self.cache, cachekey)\n                     response = merged_response\n                     response.status = 200\n                     response.fromcache = True\n@@ -1983,15 +1706,7 @@ def request(\n                     content = b\"\"\n                 else:\n                     (response, content) = self._request(\n-                        conn,\n-                        authority,\n-                        uri,\n-                        request_uri,\n-                        method,\n-                        body,\n-                        headers,\n-                        redirections,\n-                        cachekey,\n+                        conn, authority, uri, request_uri, method, body, headers, redirections, cachekey,\n                     )\n         except Exception as e:\n             is_timeout = isinstance(e, socket.timeout)\n@@ -2008,23 +1723,11 @@ def request(\n                     response.reason = str(e)\n                 elif isinstance(e, socket.timeout):\n                     content = b\"Request Timeout\"\n-                    response = Response(\n-                        {\n-                            \"content-type\": \"text/plain\",\n-                            \"status\": \"408\",\n-                            \"content-length\": len(content),\n-                        }\n-                    )\n+                    response = Response({\"content-type\": \"text/plain\", \"status\": \"408\", \"content-length\": len(content),})\n                     response.reason = \"Request Timeout\"\n                 else:\n                     content = str(e).encode(\"utf-8\")\n-                    response = Response(\n-                        {\n-                            \"content-type\": \"text/plain\",\n-                            \"status\": \"400\",\n-                            \"content-length\": len(content),\n-                        }\n-                    )\n+                    response = Response({\"content-type\": \"text/plain\", \"status\": \"400\", \"content-length\": len(content),})\n                     response.reason = \"Bad Request\"\n             else:\n                 raise"
        },
        {
          "filename": "python3/httplib2/auth.py",
          "status": "added",
          "additions": 61,
          "deletions": 0,
          "patch": "@@ -0,0 +1,61 @@\n+import base64\n+import re\n+\n+import pyparsing as pp\n+\n+from .error import *\n+\n+UNQUOTE_PAIRS = re.compile(r\"\\\\(.)\")\n+unquote = lambda s, l, t: UNQUOTE_PAIRS.sub(r\"\\1\", t[0][1:-1])\n+\n+# https://tools.ietf.org/html/rfc7235#section-1.2\n+# https://tools.ietf.org/html/rfc7235#appendix-B\n+tchar = \"!#$%&'*+-.^_`|~\" + pp.nums + pp.alphas\n+token = pp.Word(tchar).setName(\"token\")\n+token68 = pp.Combine(pp.Word(\"-._~+/\" + pp.nums + pp.alphas) + pp.ZeroOrMore(\"=\")).setName(\"token68\")\n+\n+quoted_string = pp.dblQuotedString.copy().setName(\"quoted-string\").setParseAction(unquote)\n+auth_param_name = token.copy().setName(\"auth-param-name\").addParseAction(pp.downcaseTokens)\n+auth_param = auth_param_name + pp.Suppress(\"=\") + (token ^ quoted_string)\n+params = pp.Dict(pp.delimitedList(pp.Group(auth_param)))\n+\n+scheme = token(\"scheme\")\n+challenge = scheme + (token68(\"token\") ^ params(\"params\"))\n+\n+authentication_info = params.copy()\n+www_authenticate = pp.delimitedList(pp.Group(challenge))\n+\n+\n+def _parse_authentication_info(headers, headername=\"authentication-info\"):\n+    \"\"\"https://tools.ietf.org/html/rfc7615\n+    \"\"\"\n+    header = headers.get(headername, \"\").strip()\n+    if not header:\n+        return {}\n+    try:\n+        parsed = authentication_info.parseString(header)\n+    except pp.ParseException as ex:\n+        # print(ex.explain(ex))\n+        raise MalformedHeader(headername)\n+\n+    return parsed.asDict()\n+\n+\n+def _parse_www_authenticate(headers, headername=\"www-authenticate\"):\n+    \"\"\"Returns a dictionary of dictionaries, one dict per auth_scheme.\"\"\"\n+    header = headers.get(headername, \"\").strip()\n+    if not header:\n+        return {}\n+    try:\n+        parsed = www_authenticate.parseString(header)\n+    except pp.ParseException as ex:\n+        # print(ex.explain(ex))\n+        raise MalformedHeader(headername)\n+\n+    retval = {\n+        challenge[\"scheme\"].lower(): challenge[\"params\"].asDict()\n+        if \"params\" in challenge\n+        else {\"token\": challenge.get(\"token\")}\n+        for challenge in parsed\n+    }\n+    return retval"
        },
        {
          "filename": "python3/httplib2/error.py",
          "status": "added",
          "additions": 48,
          "deletions": 0,
          "patch": "@@ -0,0 +1,48 @@\n+# All exceptions raised here derive from HttpLib2Error\n+class HttpLib2Error(Exception):\n+    pass\n+\n+\n+# Some exceptions can be caught and optionally\n+# be turned back into responses.\n+class HttpLib2ErrorWithResponse(HttpLib2Error):\n+    def __init__(self, desc, response, content):\n+        self.response = response\n+        self.content = content\n+        HttpLib2Error.__init__(self, desc)\n+\n+\n+class RedirectMissingLocation(HttpLib2ErrorWithResponse):\n+    pass\n+\n+\n+class RedirectLimit(HttpLib2ErrorWithResponse):\n+    pass\n+\n+\n+class FailedToDecompressContent(HttpLib2ErrorWithResponse):\n+    pass\n+\n+\n+class UnimplementedDigestAuthOptionError(HttpLib2ErrorWithResponse):\n+    pass\n+\n+\n+class UnimplementedHmacDigestAuthOptionError(HttpLib2ErrorWithResponse):\n+    pass\n+\n+\n+class MalformedHeader(HttpLib2Error):\n+    pass\n+\n+\n+class RelativeURIError(HttpLib2Error):\n+    pass\n+\n+\n+class ServerNotFoundError(HttpLib2Error):\n+    pass\n+\n+\n+class ProxiesUnavailableError(HttpLib2Error):\n+    pass"
        },
        {
          "filename": "requirements.txt",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+pyparsing>=2.4.2,<3 # TODO include v3 after dropping Python2 support"
        },
        {
          "filename": "script/release",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -210,11 +210,11 @@ assert_tree_clean() {\n \n version_check() {\n \tlocal need=$1\n-\tlocal version_setup=$(fgrep 'VERSION =' setup.py |tr -d \" '\\\"\" |cut -d\\= -f2)\n-\tlocal version_py2=$(cd python2 ; python2 -Es -c 'import httplib2;print(httplib2.__version__)')\n-\tlocal version_py3=$(cd python3 ; python3 -Es -c 'import httplib2;print(httplib2.__version__)')\n+\tlocal version_setup=$(python setup.py --version)\n+\tlocal version_py2=$(python -Es -c \"$(egrep '^__version__' python2/httplib2/__init__.py);print(__version__)\")\n+\tlocal version_py3=$(python -Es -c \"$(egrep '^__version__' python3/httplib2/__init__.py);print(__version__)\")\n \tif [[ \"$version_setup\" != \"$need\" ]] ; then\n-\t\techo \"error: setup.py VERSION=$version_setup expected=$need\" >&1\n+\t\techo \"error: setup.py version=$version_setup expected=$need\" >&1\n \t\texit 1\n \tfi\n \tif [[ \"$version_py2\" != \"$need\" ]] ; then"
        },
        {
          "filename": "script/test",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -65,8 +65,8 @@ main() {\n install_check_version() {\n \tlocal pip=\"$1\"\n \t$pip install dist/httplib2*\n-\tversion_source=$(cd python3 ; python3 -Es -c 'import httplib2;print(httplib2.__version__)')\n-\tversion_installed=$($pip show httplib2 |fgrep Version |cut -d' ' -f2)\n+\tversion_source=$(python setup.py --version)\n+\tversion_installed=$($pip show httplib2 |fgrep Version: |cut -d' ' -f2)\n \tif [[ \"$version_source\" != \"$version_installed\" ]] ; then\n \t\techo \"error: installed package version=$version_installed does not match source=$version_source\" >&2\n \t\texit 1"
        },
        {
          "filename": "setup.py",
          "status": "modified",
          "additions": 7,
          "deletions": 5,
          "patch": "@@ -14,19 +14,20 @@ class TestCommand(setuptools.command.test.test):\n     def run_tests(self):\n         # pytest may be not installed yet\n         import pytest\n-        args = ['--forked', '--fulltrace', '--no-cov', 'tests/']\n+\n+        args = [\"--forked\", \"--fulltrace\", \"--no-cov\", \"tests/\"]\n         if self.test_suite:\n-            args += ['-k', self.test_suite]\n-        sys.stderr.write('setup.py:test run pytest {}\\n'.format(' '.join(args)))\n+            args += [\"-k\", self.test_suite]\n+        sys.stderr.write(\"setup.py:test run pytest {}\\n\".format(\" \".join(args)))\n         errno = pytest.main(args)\n         sys.exit(errno)\n \n \n def read_requirements(name):\n     project_root = os.path.dirname(os.path.abspath(__file__))\n-    with open(os.path.join(project_root, name), 'rb') as f:\n+    with open(os.path.join(project_root, name), \"rb\") as f:\n         # remove whitespace and comments\n-        g = (line.decode('utf-8').lstrip().split('#', 1)[0].rstrip() for line in f)\n+        g = (line.decode(\"utf-8\").lstrip().split(\"#\", 1)[0].rstrip() for line in f)\n         return [l for l in g if l]\n \n \n@@ -85,6 +86,7 @@ def read_requirements(name):\n     package_dir=pkgdir,\n     packages=[\"httplib2\"],\n     package_data={\"httplib2\": [\"*.txt\"]},\n+    install_requires=read_requirements(\"requirements.txt\"),\n     tests_require=read_requirements(\"requirements-test.txt\"),\n     cmdclass={\"test\": TestCommand},\n     classifiers=["
        },
        {
          "filename": "tests/__init__.py",
          "status": "modified",
          "additions": 31,
          "deletions": 83,
          "patch": "@@ -119,9 +119,9 @@ def parse_http_message(kind, buf):\n     msg = kind()\n     msg.raw = start_line\n     if kind is HttpRequest:\n-        assert re.match(\n-            br\".+ HTTP/\\d\\.\\d\\r\\n$\", start_line\n-        ), \"Start line does not look like HTTP request: \" + repr(start_line)\n+        assert re.match(br\".+ HTTP/\\d\\.\\d\\r\\n$\", start_line), \"Start line does not look like HTTP request: \" + repr(\n+            start_line\n+        )\n         msg.method, msg.uri, msg.proto = start_line.rstrip().decode().split(\" \", 2)\n         assert msg.proto.startswith(\"HTTP/\"), repr(start_line)\n     elif kind is HttpResponse:\n@@ -201,14 +201,7 @@ class MockHTTPConnection(object):\n     \"\"\"\n \n     def __init__(\n-        self,\n-        host,\n-        port=None,\n-        key_file=None,\n-        cert_file=None,\n-        strict=None,\n-        timeout=None,\n-        proxy_info=None,\n+        self, host, port=None, key_file=None, cert_file=None, strict=None, timeout=None, proxy_info=None,\n     ):\n         self.host = host\n         self.port = port\n@@ -240,14 +233,7 @@ class MockHTTPBadStatusConnection(object):\n     num_calls = 0\n \n     def __init__(\n-        self,\n-        host,\n-        port=None,\n-        key_file=None,\n-        cert_file=None,\n-        strict=None,\n-        timeout=None,\n-        proxy_info=None,\n+        self, host, port=None, key_file=None, cert_file=None, strict=None, timeout=None, proxy_info=None,\n     ):\n         self.host = host\n         self.port = port\n@@ -328,11 +314,7 @@ def server_socket_thread(srv):\n                     # at least in other/connection_close test\n                     # should not be a problem since socket would close upon garbage collection\n             if gcounter[0] > request_count:\n-                gresult[0] = Exception(\n-                    \"Request count expected={0} actual={1}\".format(\n-                        request_count, gcounter[0]\n-                    )\n-                )\n+                gresult[0] = Exception(\"Request count expected={0} actual={1}\".format(request_count, gcounter[0]))\n         except Exception as e:\n             # traceback.print_exc caused IOError: concurrent operation on sys.stderr.close() under setup.py test\n             print(traceback.format_exc(), file=sys.stderr)\n@@ -458,21 +440,12 @@ def http_response_bytes(\n     if add_etag:\n         headers.setdefault(\"etag\", '\"{0}\"'.format(hashlib.md5(body).hexdigest()))\n     header_string = \"\".join(\"{0}: {1}\\r\\n\".format(k, v) for k, v in headers.items())\n-    if (\n-        not undefined_body_length\n-        and proto != \"HTTP/1.0\"\n-        and \"content-length\" not in headers\n-    ):\n-        raise Exception(\n-            \"httplib2.tests.http_response_bytes: client could not figure response body length\"\n-        )\n+    if not undefined_body_length and proto != \"HTTP/1.0\" and \"content-length\" not in headers:\n+        raise Exception(\"httplib2.tests.http_response_bytes: client could not figure response body length\")\n     if str(status).isdigit():\n         status = \"{} {}\".format(status, http_client.responses[status])\n     response = (\n-        \"{proto} {status}\\r\\n{headers}\\r\\n\".format(\n-            proto=proto, status=status, headers=header_string\n-        ).encode()\n-        + body\n+        \"{proto} {status}\\r\\n{headers}\\r\\n\".format(proto=proto, status=status, headers=header_string).encode() + body\n     )\n     return response\n \n@@ -526,21 +499,6 @@ def server_reflect(**kwargs):\n     return server_request(http_handler, **kwargs)\n \n \n-def http_parse_auth(s):\n-    \"\"\"https://tools.ietf.org/html/rfc7235#section-2.1\n-    \"\"\"\n-    scheme, rest = s.split(\" \", 1)\n-    result = {}\n-    while True:\n-        m = httplib2.WWW_AUTH_RELAXED.search(rest)\n-        if not m:\n-            break\n-        if len(m.groups()) == 3:\n-            key, value, rest = m.groups()\n-            result[key.lower()] = httplib2.UNQUOTE_PAIRS.sub(r\"\\1\", value)\n-    return result\n-\n-\n def store_request_response(out):\n     def wrapper(fun):\n         @functools.wraps(fun)\n@@ -609,14 +567,19 @@ def http_reflect_with_auth_handler(request):\n         auth_header = request.headers.get(\"authorization\", \"\")\n         if not auth_header:\n             return deny()\n-        if \" \" not in auth_header:\n+        try:\n+            auth_parsed = httplib2.auth._parse_www_authenticate(request.headers, \"authorization\")\n+            print(\"debug: auth_parsed\", auth_parsed)\n+        except httplib2.error.MalformedHeader:\n+            print(\"debug: auth header error\")\n             return http_response_bytes(status=400, body=b\"authorization header syntax error\")\n-        scheme, data = auth_header.split(\" \", 1)\n-        scheme = scheme.lower()\n+        scheme = auth_header.split(\" \", 1)[0].lower()\n+        print(\"debug: first auth scheme='{}'\".format(scheme))\n         if scheme != allow_scheme:\n             return deny(body=b\"must use different auth scheme\")\n+        auth_info = auth_parsed[scheme]\n         if scheme == \"basic\":\n-            decoded = base64.b64decode(data).decode()\n+            decoded = base64.b64decode(auth_info[\"token\"]).decode()\n             username, password = decoded.split(\":\", 1)\n             if (username, password) in allow_credentials:\n                 return make_http_reflect()(request)\n@@ -630,7 +593,6 @@ def http_reflect_with_auth_handler(request):\n                 gserver_nonce[0] = nextnonce\n                 gnextnonce[0] = None\n             server_nonce_current = gserver_nonce[0]\n-            auth_info = http_parse_auth(data)\n             client_cnonce = auth_info.get(\"cnonce\", \"\")\n             client_nc = auth_info.get(\"nc\", \"\")\n             client_nonce = auth_info.get(\"nonce\", \"\")\n@@ -651,45 +613,30 @@ def http_reflect_with_auth_handler(request):\n                 return deny(body=b\"auth-info nc missing\")\n             if client_opaque != server_opaque:\n                 return deny(\n-                    body=\"auth-info opaque mismatch expected={} actual={}\".format(\n-                        server_opaque, client_opaque\n-                    ).encode()\n+                    body=\"auth-info opaque mismatch expected={} actual={}\".format(server_opaque, client_opaque).encode()\n                 )\n             for allow_username, allow_password in allow_credentials:\n-                ha1 = hasher(\n-                    \":\".join((allow_username, realm, allow_password)).encode()\n-                ).hexdigest()\n+                ha1 = hasher(\":\".join((allow_username, realm, allow_password)).encode()).hexdigest()\n                 allow_response = hasher(\n-                    \":\".join(\n-                        (ha1, client_nonce, client_nc, client_cnonce, client_qop, ha2)\n-                    ).encode()\n+                    \":\".join((ha1, client_nonce, client_nc, client_cnonce, client_qop, ha2)).encode()\n                 ).hexdigest()\n                 rspauth_ha2 = hasher(\":{}\".format(request.uri).encode()).hexdigest()\n                 rspauth = hasher(\n-                    \":\".join(\n-                        (\n-                            ha1,\n-                            client_nonce,\n-                            client_nc,\n-                            client_cnonce,\n-                            client_qop,\n-                            rspauth_ha2,\n-                        )\n-                    ).encode()\n+                    \":\".join((ha1, client_nonce, client_nc, client_cnonce, client_qop, rspauth_ha2,)).encode()\n                 ).hexdigest()\n                 if auth_info.get(\"response\", \"\") == allow_response:\n                     # TODO: fix or remove doubtful comment\n                     # do we need to save nc only on success?\n                     glastnc[0] = client_nc\n                     allow_headers = {\n-                        \"authentication-info\": \" \".join(\n+                        \"authentication-info\": \", \".join(filter(None,\n                             (\n                                 'nextnonce=\"{}\"'.format(nextnonce) if nextnonce else \"\",\n                                 \"qop={}\".format(client_qop),\n                                 'rspauth=\"{}\"'.format(rspauth),\n                                 'cnonce=\"{}\"'.format(client_cnonce),\n                                 \"nc={}\".format(client_nc),\n-                            )\n+                            ))\n                         ).strip()\n                     }\n                     return make_http_reflect(headers=allow_headers)(request)\n@@ -698,11 +645,12 @@ def http_reflect_with_auth_handler(request):\n             x_wsse = request.headers.get(\"x-wsse\", \"\")\n             if x_wsse.count(\",\") != 3:\n                 return http_response_bytes(status=400, body=b\"x-wsse header syntax error\")\n-            auth_info = http_parse_auth(x_wsse)\n-            client_username = auth_info.get(\"username\", \"\")\n-            client_nonce = auth_info.get(\"nonce\", \"\")\n-            client_created = auth_info.get(\"created\", \"\")\n-            client_digest = auth_info.get(\"passworddigest\", \"\")\n+            wsse_params = httplib2.auth._parse_www_authenticate(request.headers, \"x-wsse\").get(\"usernametoken\", {})\n+            print(\"debug: wsse_params\", wsse_params)\n+            client_username = wsse_params.get(\"username\", \"\")\n+            client_nonce = wsse_params.get(\"nonce\", \"\")\n+            client_created = wsse_params.get(\"created\", \"\")\n+            client_digest = wsse_params.get(\"passworddigest\", \"\")\n             allow_password = None\n             for allow_username, allow_password in allow_credentials:\n                 if client_username == allow_username:\n@@ -712,7 +660,7 @@ def http_reflect_with_auth_handler(request):\n \n             digest = hashlib.sha1(\"\".join((client_nonce, client_created, allow_password)).encode(\"utf-8\")).digest()\n             digest_b64 = base64.b64encode(digest).decode()\n-            print(\"$$$ check client={} == real={}\".format(client_digest, digest_b64))\n+            print(\"debug: check client={} == real={}\".format(client_digest, digest_b64))\n             if client_digest == digest_b64:\n                 return make_http_reflect()(request)\n "
        },
        {
          "filename": "tests/test_auth.py",
          "status": "modified",
          "additions": 83,
          "deletions": 129,
          "patch": "@@ -1,3 +1,5 @@\n+import time\n+\n import httplib2\n import pytest\n import tests\n@@ -26,9 +28,7 @@ def test_basic():\n     # Test Basic Authentication\n     http = httplib2.Http()\n     password = tests.gen_password()\n-    handler = tests.http_reflect_with_auth(\n-        allow_scheme=\"basic\", allow_credentials=((\"joe\", password),)\n-    )\n+    handler = tests.http_reflect_with_auth(allow_scheme=\"basic\", allow_credentials=((\"joe\", password),))\n     with tests.server_request(handler, request_count=3) as uri:\n         response, content = http.request(uri, \"GET\")\n         assert response.status == 401\n@@ -41,9 +41,7 @@ def test_basic_for_domain():\n     # Test Basic Authentication\n     http = httplib2.Http()\n     password = tests.gen_password()\n-    handler = tests.http_reflect_with_auth(\n-        allow_scheme=\"basic\", allow_credentials=((\"joe\", password),)\n-    )\n+    handler = tests.http_reflect_with_auth(allow_scheme=\"basic\", allow_credentials=((\"joe\", password),))\n     with tests.server_request(handler, request_count=4) as uri:\n         response, content = http.request(uri, \"GET\")\n         assert response.status == 401\n@@ -62,9 +60,7 @@ def test_basic_two_credentials():\n     password1 = tests.gen_password()\n     password2 = tests.gen_password()\n     allowed = [(\"joe\", password1)]  # exploit shared mutable list\n-    handler = tests.http_reflect_with_auth(\n-        allow_scheme=\"basic\", allow_credentials=allowed\n-    )\n+    handler = tests.http_reflect_with_auth(allow_scheme=\"basic\", allow_credentials=allowed)\n     with tests.server_request(handler, request_count=7) as uri:\n         http.add_credentials(\"fred\", password2)\n         response, content = http.request(uri, \"GET\")\n@@ -81,9 +77,7 @@ def test_digest():\n     # Test that we support Digest Authentication\n     http = httplib2.Http()\n     password = tests.gen_password()\n-    handler = tests.http_reflect_with_auth(\n-        allow_scheme=\"digest\", allow_credentials=((\"joe\", password),)\n-    )\n+    handler = tests.http_reflect_with_auth(allow_scheme=\"digest\", allow_credentials=((\"joe\", password),))\n     with tests.server_request(handler, request_count=3) as uri:\n         response, content = http.request(uri, \"GET\")\n         assert response.status == 401\n@@ -99,25 +93,24 @@ def test_digest_next_nonce_nc():\n     password = tests.gen_password()\n     grenew_nonce = [None]\n     handler = tests.http_reflect_with_auth(\n-        allow_scheme=\"digest\",\n-        allow_credentials=((\"joe\", password),),\n-        out_renew_nonce=grenew_nonce,\n+        allow_scheme=\"digest\", allow_credentials=((\"joe\", password),), out_renew_nonce=grenew_nonce,\n     )\n     with tests.server_request(handler, request_count=5) as uri:\n         http.add_credentials(\"joe\", password)\n         response1, _ = http.request(uri, \"GET\")\n-        info = httplib2._parse_www_authenticate(response1, \"authentication-info\")\n+        info = httplib2.auth._parse_authentication_info(response1)\n+        print(\"debug: response1 authentication-info: {}\\nparsed: {}\".format(response1.get(\"authentication-info\"), info))\n         assert response1.status == 200\n-        assert info.get(\"digest\", {}).get(\"nc\") == \"00000001\", info\n+        assert info.get(\"nc\") == \"00000001\", info\n         assert not info.get(\"digest\", {}).get(\"nextnonce\"), info\n         response2, _ = http.request(uri, \"GET\")\n-        info2 = httplib2._parse_www_authenticate(response2, \"authentication-info\")\n-        assert info2.get(\"digest\", {}).get(\"nc\") == \"00000002\", info2\n+        info2 = httplib2.auth._parse_authentication_info(response2)\n+        assert info2.get(\"nc\") == \"00000002\", info2\n         grenew_nonce[0]()\n         response3, content = http.request(uri, \"GET\")\n-        info3 = httplib2._parse_www_authenticate(response3, \"authentication-info\")\n+        info3 = httplib2.auth._parse_authentication_info(response3)\n         assert response3.status == 200\n-        assert info3.get(\"digest\", {}).get(\"nc\") == \"00000001\", info3\n+        assert info3.get(\"nc\") == \"00000001\", info3\n \n \n def test_digest_auth_stale():\n@@ -136,17 +129,13 @@ def test_digest_auth_stale():\n         http.add_credentials(\"joe\", password)\n         response, _ = http.request(uri, \"GET\")\n         assert response.status == 200\n-        info = httplib2._parse_www_authenticate(\n-            requests[0][1].headers, \"www-authenticate\"\n-        )\n+        info = httplib2.auth._parse_www_authenticate(requests[0][1].headers, \"www-authenticate\")\n         grenew_nonce[0]()\n         response, _ = http.request(uri, \"GET\")\n         assert response.status == 200\n         assert not response.fromcache\n         assert getattr(response, \"_stale_digest\", False)\n-        info2 = httplib2._parse_www_authenticate(\n-            requests[2][1].headers, \"www-authenticate\"\n-        )\n+        info2 = httplib2.auth._parse_www_authenticate(requests[2][1].headers, \"www-authenticate\")\n         nonce1 = info.get(\"digest\", {}).get(\"nonce\", \"\")\n         nonce2 = info2.get(\"digest\", {}).get(\"nonce\", \"\")\n         assert nonce1 != \"\"\n@@ -160,73 +149,33 @@ def test_digest_auth_stale():\n         ({}, {}),\n         ({\"www-authenticate\": \"\"}, {}),\n         (\n-            {\n-                \"www-authenticate\": 'Test realm=\"test realm\" , foo=foo ,bar=\"bar\", baz=baz,qux=qux'\n-            },\n-            {\n-                \"test\": {\n-                    \"realm\": \"test realm\",\n-                    \"foo\": \"foo\",\n-                    \"bar\": \"bar\",\n-                    \"baz\": \"baz\",\n-                    \"qux\": \"qux\",\n-                }\n-            },\n+            {\"www-authenticate\": 'Test realm=\"test realm\" , foo=foo ,bar=\"bar\", baz=baz,qux=qux'},\n+            {\"test\": {\"realm\": \"test realm\", \"foo\": \"foo\", \"bar\": \"bar\", \"baz\": \"baz\", \"qux\": \"qux\"}},\n         ),\n         (\n             {\"www-authenticate\": 'T*!%#st realm=to*!%#en, to*!%#en=\"quoted string\"'},\n             {\"t*!%#st\": {\"realm\": \"to*!%#en\", \"to*!%#en\": \"quoted string\"}},\n         ),\n-        (\n-            {\"www-authenticate\": 'Test realm=\"a \\\\\"test\\\\\" realm\"'},\n-            {\"test\": {\"realm\": 'a \"test\" realm'}},\n-        ),\n+        ({\"www-authenticate\": 'Test realm=\"a \\\\\"test\\\\\" realm\"'}, {\"test\": {\"realm\": 'a \"test\" realm'}},),\n         ({\"www-authenticate\": 'Basic realm=\"me\"'}, {\"basic\": {\"realm\": \"me\"}}),\n-        (\n-            {\"www-authenticate\": 'Basic realm=\"me\", algorithm=\"MD5\"'},\n-            {\"basic\": {\"realm\": \"me\", \"algorithm\": \"MD5\"}},\n-        ),\n-        (\n-            {\"www-authenticate\": 'Basic realm=\"me\", algorithm=MD5'},\n-            {\"basic\": {\"realm\": \"me\", \"algorithm\": \"MD5\"}},\n-        ),\n-        (\n-            {\"www-authenticate\": 'Basic realm=\"me\",other=\"fred\" '},\n-            {\"basic\": {\"realm\": \"me\", \"other\": \"fred\"}},\n-        ),\n+        ({\"www-authenticate\": 'Basic realm=\"me\", algorithm=\"MD5\"'}, {\"basic\": {\"realm\": \"me\", \"algorithm\": \"MD5\"}},),\n+        ({\"www-authenticate\": 'Basic realm=\"me\", algorithm=MD5'}, {\"basic\": {\"realm\": \"me\", \"algorithm\": \"MD5\"}},),\n+        ({\"www-authenticate\": 'Basic realm=\"me\",other=\"fred\" '}, {\"basic\": {\"realm\": \"me\", \"other\": \"fred\"}},),\n         ({\"www-authenticate\": 'Basic REAlm=\"me\" '}, {\"basic\": {\"realm\": \"me\"}}),\n         (\n-            {\n-                \"www-authenticate\": 'Digest realm=\"digest1\", qop=\"auth,auth-int\", nonce=\"7102dd2\", opaque=\"e9517f\"'\n-            },\n-            {\n-                \"digest\": {\n-                    \"realm\": \"digest1\",\n-                    \"qop\": \"auth,auth-int\",\n-                    \"nonce\": \"7102dd2\",\n-                    \"opaque\": \"e9517f\",\n-                }\n-            },\n+            {\"www-authenticate\": 'Digest realm=\"digest1\", qop=\"auth,auth-int\", nonce=\"7102dd2\", opaque=\"e9517f\"'},\n+            {\"digest\": {\"realm\": \"digest1\", \"qop\": \"auth,auth-int\", \"nonce\": \"7102dd2\", \"opaque\": \"e9517f\"}},\n         ),\n-        # multiple schema choice\n+        # comma between schemas (glue for multiple headers with same name)\n         (\n-            {\n-                \"www-authenticate\": 'Digest realm=\"multi-d\", nonce=\"8b11d0f6\", opaque=\"cc069c\" Basic realm=\"multi-b\" '\n-            },\n-            {\n-                \"digest\": {\"realm\": \"multi-d\", \"nonce\": \"8b11d0f6\", \"opaque\": \"cc069c\"},\n-                \"basic\": {\"realm\": \"multi-b\"},\n-            },\n+            {\"www-authenticate\": 'Digest realm=\"2-comma-d\", qop=\"auth-int\", nonce=\"c0c8ff1\", Basic realm=\"2-comma-b\"'},\n+            {\"digest\": {\"realm\": \"2-comma-d\", \"qop\": \"auth-int\", \"nonce\": \"c0c8ff1\"}, \"basic\": {\"realm\": \"2-comma-b\"}},\n         ),\n-        # FIXME\n-        # comma between schemas (glue for multiple headers with same name)\n-        # ({'www-authenticate': 'Digest realm=\"2-comma-d\", qop=\"auth-int\", nonce=\"c0c8ff1\", Basic realm=\"2-comma-b\"'},\n-        #  {'digest': {'realm': '2-comma-d', 'qop': 'auth-int', 'nonce': 'c0c8ff1'},\n-        #   'basic': {'realm': '2-comma-b'}}),\n-        # FIXME\n         # comma between schemas + WSSE (glue for multiple headers with same name)\n-        # ({'www-authenticate': 'Digest realm=\"com3d\", Basic realm=\"com3b\", WSSE realm=\"com3w\", profile=\"token\"'},\n-        #  {'digest': {'realm': 'com3d'}, 'basic': {'realm': 'com3b'}, 'wsse': {'realm': 'com3w', profile': 'token'}}),\n+        (\n+            {\"www-authenticate\": 'Digest realm=\"com3d\", Basic realm=\"com3b\", WSSE realm=\"com3w\", profile=\"token\"'},\n+            {\"digest\": {\"realm\": \"com3d\"}, \"basic\": {\"realm\": \"com3b\"}, \"wsse\": {\"realm\": \"com3w\", \"profile\": \"token\"}},\n+        ),\n         # FIXME\n         # multiple syntax figures\n         # ({'www-authenticate':\n@@ -237,19 +186,10 @@ def test_digest_auth_stale():\n         #   'wsse': {'realm': 'very', 'profile': 'UsernameToken'}}),\n         # more quote combos\n         (\n-            {\n-                \"www-authenticate\": 'Digest realm=\"myrealm\", nonce=\"KBAA=3\", algorithm=MD5, qop=\"auth\", stale=true'\n-            },\n-            {\n-                \"digest\": {\n-                    \"realm\": \"myrealm\",\n-                    \"nonce\": \"KBAA=3\",\n-                    \"algorithm\": \"MD5\",\n-                    \"qop\": \"auth\",\n-                    \"stale\": \"true\",\n-                }\n-            },\n+            {\"www-authenticate\": 'Digest realm=\"myrealm\", nonce=\"KBAA=3\", algorithm=MD5, qop=\"auth\", stale=true'},\n+            {\"digest\": {\"realm\": \"myrealm\", \"nonce\": \"KBAA=3\", \"algorithm\": \"MD5\", \"qop\": \"auth\", \"stale\": \"true\"}},\n         ),\n+        ({\"www-authenticate\": \"Basic param='single quote'\"}, {\"basic\": {\"param\": \"'single\"}}),\n     ),\n     ids=lambda data: str(data[0]),\n )\n@@ -259,40 +199,67 @@ def test_parse_www_authenticate_correct(data, strict):\n     # FIXME: move strict to parse argument\n     httplib2.USE_WWW_AUTH_STRICT_PARSING = strict\n     try:\n-        assert httplib2._parse_www_authenticate(headers) == info\n+        assert httplib2.auth._parse_www_authenticate(headers) == info\n     finally:\n         httplib2.USE_WWW_AUTH_STRICT_PARSING = 0\n \n \n-def test_parse_www_authenticate_malformed():\n+@pytest.mark.parametrize(\n+    \"data\",\n+    (({\"www-authenticate\": 'OAuth \"Facebook Platform\" \"invalid_token\" \"Invalid OAuth access token.\"'}, None),),\n+    ids=lambda data: str(data[0]),\n+)\n+def test_parse_www_authenticate_malformed(data):\n     # TODO: test (and fix) header value 'barbqwnbm-bb...:asd' leads to dead loop\n-    with tests.assert_raises(httplib2.MalformedHeader):\n-        httplib2._parse_www_authenticate(\n-            {\n-                \"www-authenticate\": 'OAuth \"Facebook Platform\" \"invalid_token\" \"Invalid OAuth access token.\"'\n-            }\n-        )\n+    headers, info = data\n+    try:\n+        result = httplib2.auth._parse_www_authenticate(headers)\n+    except httplib2.error.MalformedHeader:\n+        assert info is None, \"unexpected MalformedHeader\"\n+    else:\n+        assert result == info\n+        assert info is not None, \"expected parsing error\"\n+\n+\n+def test_parse_www_authenticate_complexity():\n+    # TODO just use time.process_time() after python2 support is removed\n+    process_time = getattr(time, \"process_time\", time.time)\n+\n+    def check(size):\n+        header = {\"www-authenticate\": 'scheme {0}key=value,{0}quoted=\"foo=bar\"'.format(\" \\t\" * size)}\n+        tbegin = process_time()\n+        result = httplib2.auth._parse_www_authenticate(header)\n+        tend = process_time()\n+        assert result == {\"scheme\": {\"key\": \"value\", \"quoted\": \"foo=bar\"}}\n+        elapsed_us = round((tend * 1e6) - (tbegin * 1e6), 0)\n+        return elapsed_us\n+\n+    n1, n2, repeat = 50, 100, 7\n+    time1 = min(check(n1) for _ in range(repeat))\n+    time2 = min(check(n2) for _ in range(repeat))\n+    speed1 = round(time1 / n1, 1)\n+    speed2 = round(time2 / n2, 1)\n+    expect2 = round(speed1 * (float(n2) / n1), 1)\n+    error = round(speed2 / expect2, 1)\n+    print(\"x{}: time={}us speed={} us/op\".format(n1, time1, speed1))\n+    print(\"x{}: time={}us speed={} us/op expected={} us/op error={}\".format(n2, time2, speed2, expect2, error))\n+    assert error < 2, \"_parse_www_authenticate scales too fast\"\n \n \n def test_digest_object():\n     credentials = (\"joe\", \"password\")\n     host = None\n     request_uri = \"/test/digest/\"\n     headers = {}\n-    response = {\n-        \"www-authenticate\": 'Digest realm=\"myrealm\", nonce=\"KBAA=35\", algorithm=MD5, qop=\"auth\"'\n-    }\n+    response = {\"www-authenticate\": 'Digest realm=\"myrealm\", nonce=\"KBAA=35\", algorithm=MD5, qop=\"auth\"'}\n     content = b\"\"\n \n-    d = httplib2.DigestAuthentication(\n-        credentials, host, request_uri, headers, response, content, None\n-    )\n+    d = httplib2.DigestAuthentication(credentials, host, request_uri, headers, response, content, None)\n     d.request(\"GET\", request_uri, headers, content, cnonce=\"33033375ec278a46\")\n     our_request = \"authorization: \" + headers[\"authorization\"]\n     working_request = (\n         'authorization: Digest username=\"joe\", realm=\"myrealm\", '\n-        'nonce=\"KBAA=35\", uri=\"/test/digest/\"'\n-        + ', algorithm=MD5, response=\"de6d4a123b80801d0e94550411b6283f\", '\n+        'nonce=\"KBAA=35\", uri=\"/test/digest/\"' + ', algorithm=MD5, response=\"de6d4a123b80801d0e94550411b6283f\", '\n         'qop=auth, nc=00000001, cnonce=\"33033375ec278a46\"'\n     )\n     assert our_request == working_request\n@@ -304,14 +271,11 @@ def test_digest_object_with_opaque():\n     request_uri = \"/digest/opaque/\"\n     headers = {}\n     response = {\n-        \"www-authenticate\": 'Digest realm=\"myrealm\", nonce=\"30352fd\", algorithm=MD5, '\n-        'qop=\"auth\", opaque=\"atestopaque\"'\n+        \"www-authenticate\": 'Digest realm=\"myrealm\", nonce=\"30352fd\", algorithm=MD5, ' 'qop=\"auth\", opaque=\"atestopaque\"'\n     }\n     content = \"\"\n \n-    d = httplib2.DigestAuthentication(\n-        credentials, host, request_uri, headers, response, content, None\n-    )\n+    d = httplib2.DigestAuthentication(credentials, host, request_uri, headers, response, content, None)\n     d.request(\"GET\", request_uri, headers, content, cnonce=\"5ec2\")\n     our_request = \"authorization: \" + headers[\"authorization\"]\n     working_request = (\n@@ -329,15 +293,10 @@ def test_digest_object_stale():\n     request_uri = \"/digest/stale/\"\n     headers = {}\n     response = httplib2.Response({})\n-    response[\"www-authenticate\"] = (\n-        'Digest realm=\"myrealm\", nonce=\"bd669f\", '\n-        'algorithm=MD5, qop=\"auth\", stale=true'\n-    )\n+    response[\"www-authenticate\"] = 'Digest realm=\"myrealm\", nonce=\"bd669f\", ' 'algorithm=MD5, qop=\"auth\", stale=true'\n     response.status = 401\n     content = b\"\"\n-    d = httplib2.DigestAuthentication(\n-        credentials, host, request_uri, headers, response, content, None\n-    )\n+    d = httplib2.DigestAuthentication(credentials, host, request_uri, headers, response, content, None)\n     # Returns true to force a retry\n     assert d.response(response, content)\n \n@@ -348,15 +307,10 @@ def test_digest_object_auth_info():\n     request_uri = \"/digest/nextnonce/\"\n     headers = {}\n     response = httplib2.Response({})\n-    response[\"www-authenticate\"] = (\n-        'Digest realm=\"myrealm\", nonce=\"barney\", '\n-        'algorithm=MD5, qop=\"auth\", stale=true'\n-    )\n+    response[\"www-authenticate\"] = 'Digest realm=\"myrealm\", nonce=\"barney\", ' 'algorithm=MD5, qop=\"auth\", stale=true'\n     response[\"authentication-info\"] = 'nextnonce=\"fred\"'\n     content = b\"\"\n-    d = httplib2.DigestAuthentication(\n-        credentials, host, request_uri, headers, response, content, None\n-    )\n+    d = httplib2.DigestAuthentication(credentials, host, request_uri, headers, response, content, None)\n     # Returns true to force a retry\n     assert not d.response(response, content)\n     assert d.challenge[\"nonce\"] == \"fred\""
        }
      ],
      "file_patterns": {
        "security_files": 3,
        "config_files": 0,
        "dependency_files": 1,
        "test_files": 3,
        "unique_directories": 5,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "09eee8a81f552cbaa74f603f2dd9bcc3311ff6d7",
            "date": "2023-03-21T22:23:06Z",
            "author_login": "temoto"
          },
          {
            "sha": "c980460d5c26fd1c33502f6011e0e715604ca8f4",
            "date": "2023-01-19T17:53:50Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "c452006da5731f3935b417f727d6acbfa9a85d5d",
            "date": "2023-01-18T04:04:52Z",
            "author_login": "temoto"
          },
          {
            "sha": "8398b5f054873105497aaa7054cdceee5c00f42c",
            "date": "2023-01-18T03:56:44Z",
            "author_login": "temoto"
          },
          {
            "sha": "941fa81403295dff62eef7a169453e5308b92055",
            "date": "2022-11-17T16:41:11Z",
            "author_login": "ziollek"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "httplib2 is a comprehensive HTTP client library for Python. In httplib2 before version 0.19.0, a malicious server which responds with long series of \"\\xa0\" characters in the \"www-authenticate\" header may cause Denial of Service (CPU burn while parsing header) of the httplib2 client accessing said server. This is fixed in version 0.19.0 which contains a new implementation of auth headers parsing using the pyparsing library.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-02-08T20:15:12.197",
    "last_modified": "2024-11-21T05:47:50.650",
    "fix_date": "2021-01-06T14:13:38Z"
  },
  "references": [
    {
      "url": "https://github.com/httplib2/httplib2/commit/bd9ee252c8f099608019709e22c0d705e98d26bc",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/httplib2/httplib2/pull/182",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/httplib2/httplib2/security/advisories/GHSA-93xj-8mrv-444m",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://pypi.org/project/httplib2",
      "source": "security-advisories@github.com",
      "tags": [
        "Product",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/httplib2/httplib2/commit/bd9ee252c8f099608019709e22c0d705e98d26bc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/httplib2/httplib2/pull/182",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/httplib2/httplib2/security/advisories/GHSA-93xj-8mrv-444m",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://pypi.org/project/httplib2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:13.188160",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "httplib2",
    "owner": "httplib2",
    "created_at": "2016-03-02T22:59:52Z",
    "updated_at": "2025-01-09T14:38:26Z",
    "pushed_at": "2024-08-05T09:47:16Z",
    "size": 3797,
    "stars": 489,
    "forks": 184,
    "open_issues": 63,
    "watchers": 489,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Python": 341521,
      "HTML": 61479,
      "TeX": 20241,
      "Shell": 12694,
      "CSS": 9779
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T08:23:27.735542"
  }
}