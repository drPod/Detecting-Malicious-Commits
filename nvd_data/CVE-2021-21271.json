{
  "cve_id": "CVE-2021-21271",
  "github_data": {
    "repository": "tendermint/tendermint",
    "fix_commit": "a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76",
    "related_commits": [
      "a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76",
      "a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76",
      "commit_date": "2021-01-13T18:21:25Z",
      "author": {
        "login": "cmwaters",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "use correct source of evidence time",
        "length": 206,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 301,
        "additions": 205,
        "deletions": 96
      },
      "files": [
        {
          "filename": "consensus/byzantine_test.go",
          "status": "modified",
          "additions": 66,
          "deletions": 0,
          "patch": "@@ -154,6 +154,72 @@ func TestByzantinePrevoteEquivocation(t *testing.T) {\n \t\t}\n \t}\n \n+\t// introducing a lazy proposer means that the time of the block committed is different to the\n+\t// timestamp that the other nodes have. This tests to ensure that the evidence that finally gets\n+\t// proposed will have a valid timestamp\n+\tlazyProposer := css[1]\n+\n+\tlazyProposer.decideProposal = func(height int64, round int32) {\n+\t\tlazyProposer.Logger.Info(\"Lazy Proposer proposing condensed commit\")\n+\t\tif lazyProposer.privValidator == nil {\n+\t\t\tpanic(\"entered createProposalBlock with privValidator being nil\")\n+\t\t}\n+\n+\t\tvar commit *types.Commit\n+\t\tswitch {\n+\t\tcase lazyProposer.Height == lazyProposer.state.InitialHeight:\n+\t\t\t// We're creating a proposal for the first block.\n+\t\t\t// The commit is empty, but not nil.\n+\t\t\tcommit = types.NewCommit(0, 0, types.BlockID{}, nil)\n+\t\tcase lazyProposer.LastCommit.HasTwoThirdsMajority():\n+\t\t\t// Make the commit from LastCommit\n+\t\t\tcommit = lazyProposer.LastCommit.MakeCommit()\n+\t\tdefault: // This shouldn't happen.\n+\t\t\tlazyProposer.Logger.Error(\"enterPropose: Cannot propose anything: No commit for the previous block\")\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// omit the last signature in the commit\n+\t\tcommit.Signatures[len(commit.Signatures)-1] = types.NewCommitSigAbsent()\n+\n+\t\tif lazyProposer.privValidatorPubKey == nil {\n+\t\t\t// If this node is a validator & proposer in the current round, it will\n+\t\t\t// miss the opportunity to create a block.\n+\t\t\tlazyProposer.Logger.Error(fmt.Sprintf(\"enterPropose: %v\", errPubKeyIsNotSet))\n+\t\t\treturn\n+\t\t}\n+\t\tproposerAddr := lazyProposer.privValidatorPubKey.Address()\n+\n+\t\tblock, blockParts := lazyProposer.blockExec.CreateProposalBlock(\n+\t\t\tlazyProposer.Height, lazyProposer.state, commit, proposerAddr,\n+\t\t)\n+\n+\t\t// Flush the WAL. Otherwise, we may not recompute the same proposal to sign,\n+\t\t// and the privValidator will refuse to sign anything.\n+\t\tif err := lazyProposer.wal.FlushAndSync(); err != nil {\n+\t\t\tlazyProposer.Logger.Error(\"Error flushing to disk\")\n+\t\t}\n+\n+\t\t// Make proposal\n+\t\tpropBlockID := types.BlockID{Hash: block.Hash(), PartSetHeader: blockParts.Header()}\n+\t\tproposal := types.NewProposal(height, round, lazyProposer.ValidRound, propBlockID)\n+\t\tp := proposal.ToProto()\n+\t\tif err := lazyProposer.privValidator.SignProposal(lazyProposer.state.ChainID, p); err == nil {\n+\t\t\tproposal.Signature = p.Signature\n+\n+\t\t\t// send proposal and block parts on internal msg queue\n+\t\t\tlazyProposer.sendInternalMessage(msgInfo{&ProposalMessage{proposal}, \"\"})\n+\t\t\tfor i := 0; i < int(blockParts.Total()); i++ {\n+\t\t\t\tpart := blockParts.GetPart(i)\n+\t\t\t\tlazyProposer.sendInternalMessage(msgInfo{&BlockPartMessage{lazyProposer.Height, lazyProposer.Round, part}, \"\"})\n+\t\t\t}\n+\t\t\tlazyProposer.Logger.Info(\"Signed proposal\", \"height\", height, \"round\", round, \"proposal\", proposal)\n+\t\t\tlazyProposer.Logger.Debug(fmt.Sprintf(\"Signed proposal block: %v\", block))\n+\t\t} else if !lazyProposer.replayMode {\n+\t\t\tlazyProposer.Logger.Error(\"enterPropose: Error signing proposal\", \"height\", height, \"round\", round, \"err\", err)\n+\t\t}\n+\t}\n+\n \t// start the consensus reactors\n \tfor i := 0; i < nValidators; i++ {\n \t\ts := reactors[i].conS.GetState()"
        },
        {
          "filename": "consensus/state.go",
          "status": "modified",
          "additions": 8,
          "deletions": 18,
          "patch": "@@ -73,9 +73,8 @@ type txNotifier interface {\n \n // interface to the evidence pool\n type evidencePool interface {\n-\t// Adds consensus based evidence to the evidence pool. This function differs to\n-\t// AddEvidence by bypassing verification and adding it immediately to the pool\n-\tAddEvidenceFromConsensus(types.Evidence) error\n+\t// reports conflicting votes to the evidence pool to be processed into evidence\n+\tReportConflictingVotes(voteA, voteB *types.Vote)\n }\n \n // State handles execution of the consensus algorithm.\n@@ -1865,21 +1864,12 @@ func (cs *State) tryAddVote(vote *types.Vote, peerID p2p.ID) (bool, error) {\n \t\t\t\t\tvote.Type)\n \t\t\t\treturn added, err\n \t\t\t}\n-\t\t\tvar timestamp time.Time\n-\t\t\tif voteErr.VoteA.Height == cs.state.InitialHeight {\n-\t\t\t\ttimestamp = cs.state.LastBlockTime // genesis time\n-\t\t\t} else {\n-\t\t\t\ttimestamp = sm.MedianTime(cs.LastCommit.MakeCommit(), cs.LastValidators)\n-\t\t\t}\n-\t\t\t// form duplicate vote evidence from the conflicting votes and send it across to the\n-\t\t\t// evidence pool\n-\t\t\tev := types.NewDuplicateVoteEvidence(voteErr.VoteA, voteErr.VoteB, timestamp, cs.Validators)\n-\t\t\tevidenceErr := cs.evpool.AddEvidenceFromConsensus(ev)\n-\t\t\tif evidenceErr != nil {\n-\t\t\t\tcs.Logger.Error(\"Failed to add evidence to the evidence pool\", \"err\", evidenceErr)\n-\t\t\t} else {\n-\t\t\t\tcs.Logger.Debug(\"Added evidence to the evidence pool\", \"ev\", ev)\n-\t\t\t}\n+\t\t\t// report conflicting votes to the evidence pool\n+\t\t\tcs.evpool.ReportConflictingVotes(voteErr.VoteA, voteErr.VoteB)\n+\t\t\tcs.Logger.Info(\"Found and sent conflicting votes to the evidence pool\",\n+\t\t\t\t\"VoteA\", voteErr.VoteA,\n+\t\t\t\t\"VoteB\", voteErr.VoteB,\n+\t\t\t)\n \t\t\treturn added, err\n \t\t} else if err == types.ErrVoteNonDeterministicSignature {\n \t\t\tcs.Logger.Debug(\"Vote has non-deterministic signature\", \"err\", err)"
        },
        {
          "filename": "evidence/pool.go",
          "status": "modified",
          "additions": 112,
          "deletions": 44,
          "patch": "@@ -41,10 +41,10 @@ type Pool struct {\n \tmtx sync.Mutex\n \t// latest state\n \tstate sm.State\n-\t// evidence from consensus if buffered to this slice, awaiting until the next height\n+\t// evidence from consensus is buffered to this slice, awaiting until the next height\n \t// before being flushed to the pool. This prevents broadcasting and proposing of\n \t// evidence before the height with which the evidence happened is finished.\n-\tconsensusBuffer []types.Evidence\n+\tconsensusBuffer []duplicateVoteSet\n \n \tpruningHeight int64\n \tpruningTime   time.Time\n@@ -66,7 +66,7 @@ func NewPool(evidenceDB dbm.DB, stateDB sm.Store, blockStore BlockStore) (*Pool,\n \t\tlogger:          log.NewNopLogger(),\n \t\tevidenceStore:   evidenceDB,\n \t\tevidenceList:    clist.New(),\n-\t\tconsensusBuffer: make([]types.Evidence, 0),\n+\t\tconsensusBuffer: make([]duplicateVoteSet, 0),\n \t}\n \n \t// if pending evidence already in db, in event of prior failure, then check for expiration,\n@@ -96,31 +96,30 @@ func (evpool *Pool) PendingEvidence(maxBytes int64) ([]types.Evidence, int64) {\n \treturn evidence, size\n }\n \n-// Update pulls the latest state to be used for expiration and evidence params and then prunes all expired evidence\n+// Update takes both the new state and the evidence committed at that height and performs\n+// the following operations:\n+// 1. Take any conflicting votes from consensus and use the state's LastBlockTime to form\n+//    DuplicateVoteEvidence and add it to the pool.\n+// 2. Update the pool's state which contains evidence params relating to expiry.\n+// 3. Moves pending evidence that has now been committed into the committed pool.\n+// 4. Removes any expired evidence based on both height and time.\n func (evpool *Pool) Update(state sm.State, ev types.EvidenceList) {\n \t// sanity check\n \tif state.LastBlockHeight <= evpool.state.LastBlockHeight {\n \t\tpanic(fmt.Sprintf(\n-\t\t\t\"Failed EvidencePool.Update new state height is less than or equal to previous state height: %d <= %d\",\n+\t\t\t\"failed EvidencePool.Update new state height is less than or equal to previous state height: %d <= %d\",\n \t\t\tstate.LastBlockHeight,\n \t\t\tevpool.state.LastBlockHeight,\n \t\t))\n \t}\n-\tevpool.logger.Info(\"Updating evidence pool\", \"last_block_height\", state.LastBlockHeight,\n+\tevpool.logger.Debug(\"Updating evidence pool\", \"last_block_height\", state.LastBlockHeight,\n \t\t\"last_block_time\", state.LastBlockTime)\n \n-\tevpool.logger.Info(\n-\t\t\"updating evidence pool\",\n-\t\t\"last_block_height\", state.LastBlockHeight,\n-\t\t\"last_block_time\", state.LastBlockTime,\n-\t)\n-\n-\tevpool.mtx.Lock()\n-\t// flush awaiting evidence from consensus into pool\n-\tevpool.flushConsensusBuffer()\n+\t// flush conflicting vote pairs from the buffer, producing DuplicateVoteEvidence and\n+\t// adding it to the pool\n+\tevpool.processConsensusBuffer(state)\n \t// update state\n-\tevpool.state = state\n-\tevpool.mtx.Unlock()\n+\tevpool.updateState(state)\n \n \t// move committed evidence out from the pending pool and into the committed pool\n \tevpool.markEvidenceAsCommitted(ev)\n@@ -138,7 +137,7 @@ func (evpool *Pool) AddEvidence(ev types.Evidence) error {\n \n \t// We have already verified this piece of evidence - no need to do it again\n \tif evpool.isPending(ev) {\n-\t\tevpool.logger.Info(\"Evidence already pending, ignoring this one\", \"ev\", ev)\n+\t\tevpool.logger.Debug(\"Evidence already pending, ignoring this one\", \"ev\", ev)\n \t\treturn nil\n \t}\n \n@@ -169,25 +168,22 @@ func (evpool *Pool) AddEvidence(ev types.Evidence) error {\n \treturn nil\n }\n \n-// AddEvidenceFromConsensus should be exposed only to the consensus reactor so it can add evidence\n-// to the pool directly without the need for verification.\n-func (evpool *Pool) AddEvidenceFromConsensus(ev types.Evidence) error {\n-\n-\t// we already have this evidence, log this but don't return an error.\n-\tif evpool.isPending(ev) {\n-\t\tevpool.logger.Info(\"Evidence already pending, ignoring this one\", \"ev\", ev)\n-\t\treturn nil\n-\t}\n-\n-\t// add evidence to a buffer which will pass the evidence to the pool at the following height.\n-\t// This avoids the issue of some nodes verifying and proposing evidence at a height where the\n-\t// block hasn't been committed on cause others to potentially fail.\n+// ReportConflictingVotes takes two conflicting votes and forms duplicate vote evidence,\n+// adding it eventually to the evidence pool.\n+//\n+// Duplicate vote attacks happen before the block is committed and the timestamp is\n+// finalized, thus the evidence pool holds these votes in a buffer, forming the\n+// evidence from them once consensus at that height has been reached and `Update()` with\n+// the new state called.\n+//\n+// Votes are not verified.\n+func (evpool *Pool) ReportConflictingVotes(voteA, voteB *types.Vote) {\n \tevpool.mtx.Lock()\n \tdefer evpool.mtx.Unlock()\n-\tevpool.consensusBuffer = append(evpool.consensusBuffer, ev)\n-\tevpool.logger.Info(\"received new evidence of byzantine behavior from consensus\", \"evidence\", ev)\n-\n-\treturn nil\n+\tevpool.consensusBuffer = append(evpool.consensusBuffer, duplicateVoteSet{\n+\t\tVoteA: voteA,\n+\t\tVoteB: voteB,\n+\t})\n }\n \n // CheckEvidence takes an array of evidence from a block and verifies all the evidence there.\n@@ -208,7 +204,7 @@ func (evpool *Pool) CheckEvidence(evList types.EvidenceList) error {\n \n \t\t\terr := evpool.verify(ev)\n \t\t\tif err != nil {\n-\t\t\t\treturn &types.ErrInvalidEvidence{Evidence: ev, Reason: err}\n+\t\t\t\treturn err\n \t\t\t}\n \n \t\t\tif err := evpool.addPendingEvidence(ev); err != nil {\n@@ -380,7 +376,7 @@ func (evpool *Pool) removePendingEvidence(evidence types.Evidence) {\n \t\tevpool.logger.Error(\"Unable to delete pending evidence\", \"err\", err)\n \t} else {\n \t\tatomic.AddUint32(&evpool.evidenceSize, ^uint32(0))\n-\t\tevpool.logger.Info(\"Deleted pending evidence\", \"evidence\", evidence)\n+\t\tevpool.logger.Debug(\"Deleted pending evidence\", \"evidence\", evidence)\n \t}\n }\n \n@@ -507,19 +503,91 @@ func (evpool *Pool) removeEvidenceFromList(\n \t}\n }\n \n-// flushConsensusBuffer moves the evidence produced from consensus into the evidence pool\n-// and list so that it can be broadcasted and proposed\n-func (evpool *Pool) flushConsensusBuffer() {\n-\tfor _, ev := range evpool.consensusBuffer {\n-\t\tif err := evpool.addPendingEvidence(ev); err != nil {\n+func (evpool *Pool) updateState(state sm.State) {\n+\tevpool.mtx.Lock()\n+\tdefer evpool.mtx.Unlock()\n+\tevpool.state = state\n+}\n+\n+// processConsensusBuffer converts all the duplicate votes witnessed from consensus\n+// into DuplicateVoteEvidence. It sets the evidence timestamp to the block height\n+// from the most recently committed block.\n+// Evidence is then added to the pool so as to be ready to be broadcasted and proposed.\n+func (evpool *Pool) processConsensusBuffer(state sm.State) {\n+\tevpool.mtx.Lock()\n+\tdefer evpool.mtx.Unlock()\n+\tfor _, voteSet := range evpool.consensusBuffer {\n+\n+\t\t// Check the height of the conflicting votes and fetch the corresponding time and validator set\n+\t\t// to produce the valid evidence\n+\t\tvar dve *types.DuplicateVoteEvidence\n+\t\tswitch {\n+\t\tcase voteSet.VoteA.Height == state.LastBlockHeight:\n+\t\t\tdve = types.NewDuplicateVoteEvidence(\n+\t\t\t\tvoteSet.VoteA,\n+\t\t\t\tvoteSet.VoteB,\n+\t\t\t\tstate.LastBlockTime,\n+\t\t\t\tstate.LastValidators,\n+\t\t\t)\n+\n+\t\tcase voteSet.VoteA.Height < state.LastBlockHeight:\n+\t\t\tvalSet, err := evpool.stateDB.LoadValidators(voteSet.VoteA.Height)\n+\t\t\tif err != nil {\n+\t\t\t\tevpool.logger.Error(\"failed to load validator set for conflicting votes\", \"height\",\n+\t\t\t\t\tvoteSet.VoteA.Height, \"err\", err,\n+\t\t\t\t)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tblockMeta := evpool.blockStore.LoadBlockMeta(voteSet.VoteA.Height)\n+\t\t\tif blockMeta == nil {\n+\t\t\t\tevpool.logger.Error(\"failed to load block time for conflicting votes\", \"height\", voteSet.VoteA.Height)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdve = types.NewDuplicateVoteEvidence(\n+\t\t\t\tvoteSet.VoteA,\n+\t\t\t\tvoteSet.VoteB,\n+\t\t\t\tblockMeta.Header.Time,\n+\t\t\t\tvalSet,\n+\t\t\t)\n+\n+\t\tdefault:\n+\t\t\t// evidence pool shouldn't expect to get votes from consensus of a height that is above the current\n+\t\t\t// state. If this error is seen then perhaps consider keeping the votes in the buffer and retry\n+\t\t\t// in following heights\n+\t\t\tevpool.logger.Error(\"inbound duplicate votes from consensus are of a greater height than current state\",\n+\t\t\t\t\"duplicate vote height\", voteSet.VoteA.Height,\n+\t\t\t\t\"state.LastBlockHeight\", state.LastBlockHeight)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// check if we already have this evidence\n+\t\tif evpool.isPending(dve) {\n+\t\t\tevpool.logger.Debug(\"evidence already pending; ignoring\", \"evidence\", dve)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// check that the evidence is not already committed on chain\n+\t\tif evpool.isCommitted(dve) {\n+\t\t\tevpool.logger.Debug(\"evidence already committed; ignoring\", \"evidence\", dve)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif err := evpool.addPendingEvidence(dve); err != nil {\n \t\t\tevpool.logger.Error(\"failed to flush evidence from consensus buffer to pending list: %w\", err)\n \t\t\tcontinue\n \t\t}\n \n-\t\tevpool.evidenceList.PushBack(ev)\n+\t\tevpool.evidenceList.PushBack(dve)\n+\n+\t\tevpool.logger.Info(\"verified new evidence of byzantine behavior\", \"evidence\", dve)\n \t}\n \t// reset consensus buffer\n-\tevpool.consensusBuffer = make([]types.Evidence, 0)\n+\tevpool.consensusBuffer = make([]duplicateVoteSet, 0)\n+}\n+\n+type duplicateVoteSet struct {\n+\tVoteA *types.Vote\n+\tVoteB *types.Vote\n }\n \n func bytesToEv(evBytes []byte) (types.Evidence, error) {"
        },
        {
          "filename": "evidence/pool_test.go",
          "status": "modified",
          "additions": 11,
          "deletions": 12,
          "patch": "@@ -144,12 +144,17 @@ func TestAddExpiredEvidence(t *testing.T) {\n \t}\n }\n \n-func TestAddEvidenceFromConsensus(t *testing.T) {\n+func TestReportConflictingVotes(t *testing.T) {\n \tvar height int64 = 10\n-\tpool, val := defaultTestPool(height)\n-\tev := types.NewMockDuplicateVoteEvidenceWithValidator(height, defaultEvidenceTime, val, evidenceChainID)\n \n-\trequire.NoError(t, pool.AddEvidenceFromConsensus(ev))\n+\tpool, pv := defaultTestPool(height)\n+\tval := types.NewValidator(pv.PrivKey.PubKey(), 10)\n+\tev := types.NewMockDuplicateVoteEvidenceWithValidator(height+1, defaultEvidenceTime, pv, evidenceChainID)\n+\n+\tpool.ReportConflictingVotes(ev.VoteA, ev.VoteB)\n+\n+\t// shouldn't be able to submit the same evidence twice\n+\tpool.ReportConflictingVotes(ev.VoteA, ev.VoteB)\n \n \t// evidence from consensus should not be added immediately but reside in the consensus buffer\n \tevList, evSize := pool.PendingEvidence(defaultEvidenceMaxBytes)\n@@ -162,19 +167,13 @@ func TestAddEvidenceFromConsensus(t *testing.T) {\n \t// move to next height and update state and evidence pool\n \tstate := pool.State()\n \tstate.LastBlockHeight++\n+\tstate.LastBlockTime = ev.Time()\n+\tstate.LastValidators = types.NewValidatorSet([]*types.Validator{val})\n \tpool.Update(state, []types.Evidence{})\n \n \t// should be able to retrieve evidence from pool\n \tevList, _ = pool.PendingEvidence(defaultEvidenceMaxBytes)\n \trequire.Equal(t, []types.Evidence{ev}, evList)\n-\n-\t// shouldn't be able to submit the same evidence twice\n-\trequire.NoError(t, pool.AddEvidenceFromConsensus(ev))\n-\tstate = pool.State()\n-\tstate.LastBlockHeight++\n-\tpool.Update(state, []types.Evidence{})\n-\tevList2, _ := pool.PendingEvidence(defaultEvidenceMaxBytes)\n-\trequire.Equal(t, evList, evList2)\n }\n \n func TestEvidencePoolUpdate(t *testing.T) {"
        },
        {
          "filename": "node/node_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -265,8 +265,7 @@ func TestCreateProposalBlock(t *testing.T) {\n \tfor currentBytes <= maxEvidenceBytes {\n \t\tev := types.NewMockDuplicateVoteEvidenceWithValidator(height, time.Now(), privVals[0], \"test-chain\")\n \t\tcurrentBytes += int64(len(ev.Bytes()))\n-\t\terr := evidencePool.AddEvidenceFromConsensus(ev)\n-\t\trequire.NoError(t, err)\n+\t\tevidencePool.ReportConflictingVotes(ev.VoteA, ev.VoteB)\n \t}\n \n \tevList, size := evidencePool.PendingEvidence(state.ConsensusParams.Evidence.MaxBytes)"
        },
        {
          "filename": "state/services.go",
          "status": "modified",
          "additions": 4,
          "deletions": 6,
          "patch": "@@ -53,9 +53,7 @@ type EmptyEvidencePool struct{}\n func (EmptyEvidencePool) PendingEvidence(maxBytes int64) (ev []types.Evidence, size int64) {\n \treturn nil, 0\n }\n-func (EmptyEvidencePool) AddEvidence(types.Evidence) error              { return nil }\n-func (EmptyEvidencePool) Update(State, types.EvidenceList)              {}\n-func (EmptyEvidencePool) CheckEvidence(evList types.EvidenceList) error { return nil }\n-func (EmptyEvidencePool) AddEvidenceFromConsensus(evidence types.Evidence) error {\n-\treturn nil\n-}\n+func (EmptyEvidencePool) AddEvidence(types.Evidence) error                { return nil }\n+func (EmptyEvidencePool) Update(State, types.EvidenceList)                {}\n+func (EmptyEvidencePool) CheckEvidence(evList types.EvidenceList) error   { return nil }\n+func (EmptyEvidencePool) ReportConflictingVotes(voteA, voteB *types.Vote) {}"
        },
        {
          "filename": "test/maverick/consensus/state.go",
          "status": "modified",
          "additions": 3,
          "deletions": 14,
          "patch": "@@ -465,9 +465,8 @@ type txNotifier interface {\n \n // interface to the evidence pool\n type evidencePool interface {\n-\t// Adds consensus based evidence to the evidence pool where time is the time\n-\t// of the block where the offense occurred and the validator set is the current one.\n-\tAddEvidenceFromConsensus(evidence types.Evidence) error\n+\t// reports conflicting votes to the evidence pool to be processed into evidence\n+\tReportConflictingVotes(voteA, voteB *types.Vote)\n }\n \n //----------------------------------------\n@@ -1767,17 +1766,7 @@ func (cs *State) tryAddVote(vote *types.Vote, peerID p2p.ID) (bool, error) {\n \t\t\t\t\tvote.Type)\n \t\t\t\treturn added, err\n \t\t\t}\n-\t\t\tvar timestamp time.Time\n-\t\t\tif voteErr.VoteA.Height == cs.state.InitialHeight {\n-\t\t\t\ttimestamp = cs.state.LastBlockTime // genesis time\n-\t\t\t} else {\n-\t\t\t\ttimestamp = sm.MedianTime(cs.LastCommit.MakeCommit(), cs.LastValidators)\n-\t\t\t}\n-\t\t\tev := types.NewDuplicateVoteEvidence(voteErr.VoteA, voteErr.VoteB, timestamp, cs.Validators)\n-\t\t\tevidenceErr := cs.evpool.AddEvidenceFromConsensus(ev)\n-\t\t\tif evidenceErr != nil {\n-\t\t\t\tcs.Logger.Error(\"Failed to add evidence to the evidence pool\", \"err\", evidenceErr)\n-\t\t\t}\n+\t\t\tcs.evpool.ReportConflictingVotes(voteErr.VoteA, voteErr.VoteB)\n \t\t\treturn added, err\n \t\t} else if err == types.ErrVoteNonDeterministicSignature {\n \t\t\tcs.Logger.Debug(\"Vote has non-deterministic signature\", \"err\", err)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 5,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "35581cf54ec436b8c37fabb43fdaa3f48339a170",
            "date": "2023-02-02T21:35:52Z",
            "author_login": "jaekwon"
          },
          {
            "sha": "64747b2b184184ecba4f4bffc54ffbcb47cfbcb0",
            "date": "2023-01-05T21:16:29Z",
            "author_login": "jaekwon"
          },
          {
            "sha": "014cdcf09844d48f6d30f3e520034b7edffd9670",
            "date": "2022-11-22T12:42:46Z",
            "author_login": "thanethomson"
          },
          {
            "sha": "08e5d0bf78c4becdfab0d9e5197e7adca4120b69",
            "date": "2022-11-21T11:05:35Z",
            "author_login": "thanethomson"
          },
          {
            "sha": "c645fd0b71cca2fa0ff1f597591f325e3c0ab905",
            "date": "2022-11-15T19:57:57Z",
            "author_login": "thanethomson"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "Tendermint Core is an open source Byzantine Fault Tolerant (BFT) middleware that takes a state transition machine - written in any programming language - and securely replicates it on many machines. Tendermint Core v0.34.0 introduced a new way of handling evidence of misbehavior. As part of this, we added a new Timestamp field to Evidence structs. This timestamp would be calculated using the same algorithm that is used when a block is created and proposed. (This algorithm relies on the timestamp of the last commit from this specific block.) In Tendermint Core v0.34.0-v0.34.2, the consensus reactor is responsible for forming DuplicateVoteEvidence whenever double signs are observed. However, the current block is still \u201cin flight\u201d when it is being formed by the consensus reactor. It hasn\u2019t been finalized through network consensus yet. This means that different nodes in the network may observe different \u201clast commits\u201d when assigning a timestamp to DuplicateVoteEvidence. In turn, different nodes could form DuplicateVoteEvidence objects at the same height but with different timestamps. One DuplicateVoteEvidence object (with one timestamp) will then eventually get finalized in the block, but this means that any DuplicateVoteEvidence with a different timestamp is considered invalid. Any node that formed invalid DuplicateVoteEvidence will continue to propose invalid evidence; its peers may see this, and choose to disconnect from this node. This bug means that double signs are DoS vectors in Tendermint Core v0.34.0-v0.34.2. Tendermint Core v0.34.3 is a security release which fixes this bug. As of v0.34.3, DuplicateVoteEvidence is no longer formed by the consensus reactor; rather, the consensus reactor passes the Votes themselves into the EvidencePool, which is now responsible for forming DuplicateVoteEvidence. The EvidencePool has timestamp info that should be consistent across the network, which means that DuplicateVoteEvidence formed in this reactor should have consistent timestamps. This release changes the API between the consensus and evidence reactors.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-01-26T21:15:12.503",
    "last_modified": "2024-11-21T05:47:54.117",
    "fix_date": "2021-01-13T18:21:25Z"
  },
  "references": [
    {
      "url": "https://github.com/tendermint/tendermint/blob/v0.34.3/CHANGELOG.md#v0.34.3",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tendermint/tendermint/commit/a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tendermint/tendermint/security/advisories/GHSA-p658-8693-mhvg",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tendermint/tendermint/blob/v0.34.3/CHANGELOG.md#v0.34.3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tendermint/tendermint/commit/a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tendermint/tendermint/security/advisories/GHSA-p658-8693-mhvg",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:13.169566",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "tendermint",
    "owner": "tendermint",
    "created_at": "2014-05-14T23:21:35Z",
    "updated_at": "2025-01-25T17:18:00Z",
    "pushed_at": "2024-12-27T00:20:39Z",
    "size": 150233,
    "stars": 5745,
    "forks": 2085,
    "open_issues": 20,
    "watchers": 5745,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Go": 3979011,
      "TeX": 332482,
      "TLA": 228722,
      "Shell": 27771,
      "Python": 25606,
      "Makefile": 17042,
      "Jinja": 13466,
      "Dockerfile": 6422,
      "HCL": 2065,
      "HTML": 787
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T08:07:36.744862"
  }
}