{
  "cve_id": "CVE-2021-21273",
  "github_data": {
    "repository": "matrix-org/synapse",
    "fix_commit": "30fba6210834a4ecd91badf0c8f3eb278b72e746",
    "related_commits": [
      "30fba6210834a4ecd91badf0c8f3eb278b72e746",
      "30fba6210834a4ecd91badf0c8f3eb278b72e746"
    ],
    "patch_url": "https://github.com/matrix-org/synapse/commit/30fba6210834a4ecd91badf0c8f3eb278b72e746.patch",
    "fix_commit_details": {
      "sha": "30fba6210834a4ecd91badf0c8f3eb278b72e746",
      "commit_date": "2020-12-02T16:09:24Z",
      "author": {
        "login": "clokep",
        "type": "User",
        "stats": {
          "total_commits": 1430,
          "average_weekly_commits": 2.623853211009174,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 192
        }
      },
      "commit_message": {
        "title": "Apply an IP range blacklist to push and key revocation requests. (#8821)",
        "length": 488,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 291,
        "additions": 176,
        "deletions": 115
      },
      "files": [
        {
          "filename": "changelog.d/8821.bugfix",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+Apply the `federation_ip_range_blacklist` to push and key revocation requests."
        },
        {
          "filename": "docs/sample_config.yaml",
          "status": "modified",
          "additions": 8,
          "deletions": 6,
          "patch": "@@ -642,17 +642,19 @@ acme:\n #  - nyc.example.com\n #  - syd.example.com\n \n-# Prevent federation requests from being sent to the following\n-# blacklist IP address CIDR ranges. If this option is not specified, or\n-# specified with an empty list, no ip range blacklist will be enforced.\n+# Prevent outgoing requests from being sent to the following blacklisted IP address\n+# CIDR ranges. If this option is not specified, or specified with an empty list,\n+# no IP range blacklist will be enforced.\n #\n-# As of Synapse v1.4.0 this option also affects any outbound requests to identity\n-# servers provided by user input.\n+# The blacklist applies to the outbound requests for federation, identity servers,\n+# push servers, and for checking key validitity for third-party invite events.\n #\n # (0.0.0.0 and :: are always blacklisted, whether or not they are explicitly\n # listed here, since they correspond to unroutable addresses.)\n #\n-federation_ip_range_blacklist:\n+# This option replaces federation_ip_range_blacklist in Synapse v1.24.0.\n+#\n+ip_range_blacklist:\n   - '127.0.0.0/8'\n   - '10.0.0.0/8'\n   - '172.16.0.0/12'"
        },
        {
          "filename": "synapse/app/generic_worker.py",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -266,7 +266,6 @@ def __init__(self, hs):\n         super().__init__(hs)\n         self.hs = hs\n         self.is_mine_id = hs.is_mine_id\n-        self.http_client = hs.get_simple_http_client()\n \n         self._presence_enabled = hs.config.use_presence\n "
        },
        {
          "filename": "synapse/config/federation.py",
          "status": "modified",
          "additions": 25,
          "deletions": 15,
          "patch": "@@ -36,22 +36,30 @@ def read_config(self, config, **kwargs):\n             for domain in federation_domain_whitelist:\n                 self.federation_domain_whitelist[domain] = True\n \n-        self.federation_ip_range_blacklist = config.get(\n-            \"federation_ip_range_blacklist\", []\n-        )\n+        ip_range_blacklist = config.get(\"ip_range_blacklist\", [])\n \n         # Attempt to create an IPSet from the given ranges\n         try:\n-            self.federation_ip_range_blacklist = IPSet(\n-                self.federation_ip_range_blacklist\n-            )\n-\n-            # Always blacklist 0.0.0.0, ::\n-            self.federation_ip_range_blacklist.update([\"0.0.0.0\", \"::\"])\n+            self.ip_range_blacklist = IPSet(ip_range_blacklist)\n+        except Exception as e:\n+            raise ConfigError(\"Invalid range(s) provided in ip_range_blacklist: %s\" % e)\n+        # Always blacklist 0.0.0.0, ::\n+        self.ip_range_blacklist.update([\"0.0.0.0\", \"::\"])\n+\n+        # The federation_ip_range_blacklist is used for backwards-compatibility\n+        # and only applies to federation and identity servers. If it is not given,\n+        # default to ip_range_blacklist.\n+        federation_ip_range_blacklist = config.get(\n+            \"federation_ip_range_blacklist\", ip_range_blacklist\n+        )\n+        try:\n+            self.federation_ip_range_blacklist = IPSet(federation_ip_range_blacklist)\n         except Exception as e:\n             raise ConfigError(\n                 \"Invalid range(s) provided in federation_ip_range_blacklist: %s\" % e\n             )\n+        # Always blacklist 0.0.0.0, ::\n+        self.federation_ip_range_blacklist.update([\"0.0.0.0\", \"::\"])\n \n         federation_metrics_domains = config.get(\"federation_metrics_domains\") or []\n         validate_config(\n@@ -76,17 +84,19 @@ def generate_config_section(self, config_dir_path, server_name, **kwargs):\n         #  - nyc.example.com\n         #  - syd.example.com\n \n-        # Prevent federation requests from being sent to the following\n-        # blacklist IP address CIDR ranges. If this option is not specified, or\n-        # specified with an empty list, no ip range blacklist will be enforced.\n+        # Prevent outgoing requests from being sent to the following blacklisted IP address\n+        # CIDR ranges. If this option is not specified, or specified with an empty list,\n+        # no IP range blacklist will be enforced.\n         #\n-        # As of Synapse v1.4.0 this option also affects any outbound requests to identity\n-        # servers provided by user input.\n+        # The blacklist applies to the outbound requests for federation, identity servers,\n+        # push servers, and for checking key validitity for third-party invite events.\n         #\n         # (0.0.0.0 and :: are always blacklisted, whether or not they are explicitly\n         # listed here, since they correspond to unroutable addresses.)\n         #\n-        federation_ip_range_blacklist:\n+        # This option replaces federation_ip_range_blacklist in Synapse v1.24.0.\n+        #\n+        ip_range_blacklist:\n           - '127.0.0.0/8'\n           - '10.0.0.0/8'\n           - '172.16.0.0/12'"
        },
        {
          "filename": "synapse/crypto/keyring.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -578,7 +578,7 @@ class PerspectivesKeyFetcher(BaseV2KeyFetcher):\n     def __init__(self, hs):\n         super().__init__(hs)\n         self.clock = hs.get_clock()\n-        self.client = hs.get_http_client()\n+        self.client = hs.get_federation_http_client()\n         self.key_servers = self.config.key_servers\n \n     async def get_keys(self, keys_to_fetch):\n@@ -748,7 +748,7 @@ class ServerKeyFetcher(BaseV2KeyFetcher):\n     def __init__(self, hs):\n         super().__init__(hs)\n         self.clock = hs.get_clock()\n-        self.client = hs.get_http_client()\n+        self.client = hs.get_federation_http_client()\n \n     async def get_keys(self, keys_to_fetch):\n         \"\"\""
        },
        {
          "filename": "synapse/federation/federation_server.py",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -845,7 +845,6 @@ class FederationHandlerRegistry:\n \n     def __init__(self, hs: \"HomeServer\"):\n         self.config = hs.config\n-        self.http_client = hs.get_simple_http_client()\n         self.clock = hs.get_clock()\n         self._instance_name = hs.get_instance_name()\n "
        },
        {
          "filename": "synapse/federation/transport/client.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -35,7 +35,7 @@ class TransportLayerClient:\n \n     def __init__(self, hs):\n         self.server_name = hs.hostname\n-        self.client = hs.get_http_client()\n+        self.client = hs.get_federation_http_client()\n \n     @log_function\n     def get_room_state_ids(self, destination, room_id, event_id):"
        },
        {
          "filename": "synapse/handlers/federation.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -140,7 +140,7 @@ def __init__(self, hs: \"HomeServer\"):\n         self._message_handler = hs.get_message_handler()\n         self._server_notices_mxid = hs.config.server_notices_mxid\n         self.config = hs.config\n-        self.http_client = hs.get_simple_http_client()\n+        self.http_client = hs.get_proxied_blacklisted_http_client()\n         self._instance_name = hs.get_instance_name()\n         self._replication = hs.get_replication_data_handler()\n "
        },
        {
          "filename": "synapse/handlers/identity.py",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -46,13 +46,13 @@ class IdentityHandler(BaseHandler):\n     def __init__(self, hs):\n         super().__init__(hs)\n \n+        # An HTTP client for contacting trusted URLs.\n         self.http_client = SimpleHttpClient(hs)\n-        # We create a blacklisting instance of SimpleHttpClient for contacting identity\n-        # servers specified by clients\n+        # An HTTP client for contacting identity servers specified by clients.\n         self.blacklisting_http_client = SimpleHttpClient(\n             hs, ip_blacklist=hs.config.federation_ip_range_blacklist\n         )\n-        self.federation_http_client = hs.get_http_client()\n+        self.federation_http_client = hs.get_federation_http_client()\n         self.hs = hs\n \n     async def threepid_from_creds("
        },
        {
          "filename": "synapse/http/client.py",
          "status": "modified",
          "additions": 32,
          "deletions": 14,
          "patch": "@@ -125,7 +125,7 @@ def _scheduler(x):\n     return _scheduler\n \n \n-class IPBlacklistingResolver:\n+class _IPBlacklistingResolver:\n     \"\"\"\n     A proxy for reactor.nameResolver which only produces non-blacklisted IP\n     addresses, preventing DNS rebinding attacks on URL preview.\n@@ -199,6 +199,35 @@ def resolutionComplete() -> None:\n         return r\n \n \n+@implementer(IReactorPluggableNameResolver)\n+class BlacklistingReactorWrapper:\n+    \"\"\"\n+    A Reactor wrapper which will prevent DNS resolution to blacklisted IP\n+    addresses, to prevent DNS rebinding.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        reactor: IReactorPluggableNameResolver,\n+        ip_whitelist: Optional[IPSet],\n+        ip_blacklist: IPSet,\n+    ):\n+        self._reactor = reactor\n+\n+        # We need to use a DNS resolver which filters out blacklisted IP\n+        # addresses, to prevent DNS rebinding.\n+        self._nameResolver = _IPBlacklistingResolver(\n+            self._reactor, ip_whitelist, ip_blacklist\n+        )\n+\n+    def __getattr__(self, attr: str) -> Any:\n+        # Passthrough to the real reactor except for the DNS resolver.\n+        if attr == \"nameResolver\":\n+            return self._nameResolver\n+        else:\n+            return getattr(self._reactor, attr)\n+\n+\n class BlacklistingAgentWrapper(Agent):\n     \"\"\"\n     An Agent wrapper which will prevent access to IP addresses being accessed\n@@ -292,22 +321,11 @@ def __init__(\n         self.user_agent = self.user_agent.encode(\"ascii\")\n \n         if self._ip_blacklist:\n-            real_reactor = hs.get_reactor()\n             # If we have an IP blacklist, we need to use a DNS resolver which\n             # filters out blacklisted IP addresses, to prevent DNS rebinding.\n-            nameResolver = IPBlacklistingResolver(\n-                real_reactor, self._ip_whitelist, self._ip_blacklist\n+            self.reactor = BlacklistingReactorWrapper(\n+                hs.get_reactor(), self._ip_whitelist, self._ip_blacklist\n             )\n-\n-            @implementer(IReactorPluggableNameResolver)\n-            class Reactor:\n-                def __getattr__(_self, attr):\n-                    if attr == \"nameResolver\":\n-                        return nameResolver\n-                    else:\n-                        return getattr(real_reactor, attr)\n-\n-            self.reactor = Reactor()\n         else:\n             self.reactor = hs.get_reactor()\n "
        },
        {
          "filename": "synapse/http/federation/matrix_federation_agent.py",
          "status": "modified",
          "additions": 12,
          "deletions": 4,
          "patch": "@@ -16,7 +16,7 @@\n import urllib.parse\n from typing import List, Optional\n \n-from netaddr import AddrFormatError, IPAddress\n+from netaddr import AddrFormatError, IPAddress, IPSet\n from zope.interface import implementer\n \n from twisted.internet import defer\n@@ -31,6 +31,7 @@\n from twisted.web.iweb import IAgent, IAgentEndpointFactory, IBodyProducer\n \n from synapse.crypto.context_factory import FederationPolicyForHTTPS\n+from synapse.http.client import BlacklistingAgentWrapper\n from synapse.http.federation.srv_resolver import Server, SrvResolver\n from synapse.http.federation.well_known_resolver import WellKnownResolver\n from synapse.logging.context import make_deferred_yieldable, run_in_background\n@@ -70,6 +71,7 @@ def __init__(\n         reactor: IReactorCore,\n         tls_client_options_factory: Optional[FederationPolicyForHTTPS],\n         user_agent: bytes,\n+        ip_blacklist: IPSet,\n         _srv_resolver: Optional[SrvResolver] = None,\n         _well_known_resolver: Optional[WellKnownResolver] = None,\n     ):\n@@ -90,12 +92,18 @@ def __init__(\n         self.user_agent = user_agent\n \n         if _well_known_resolver is None:\n+            # Note that the name resolver has already been wrapped in a\n+            # IPBlacklistingResolver by MatrixFederationHttpClient.\n             _well_known_resolver = WellKnownResolver(\n                 self._reactor,\n-                agent=Agent(\n+                agent=BlacklistingAgentWrapper(\n+                    Agent(\n+                        self._reactor,\n+                        pool=self._pool,\n+                        contextFactory=tls_client_options_factory,\n+                    ),\n                     self._reactor,\n-                    pool=self._pool,\n-                    contextFactory=tls_client_options_factory,\n+                    ip_blacklist=ip_blacklist,\n                 ),\n                 user_agent=self.user_agent,\n             )"
        },
        {
          "filename": "synapse/http/matrixfederationclient.py",
          "status": "modified",
          "additions": 8,
          "deletions": 18,
          "patch": "@@ -26,11 +26,10 @@\n from canonicaljson import encode_canonical_json\n from prometheus_client import Counter\n from signedjson.sign import sign_json\n-from zope.interface import implementer\n \n from twisted.internet import defer\n from twisted.internet.error import DNSLookupError\n-from twisted.internet.interfaces import IReactorPluggableNameResolver, IReactorTime\n+from twisted.internet.interfaces import IReactorTime\n from twisted.internet.task import _EPSILON, Cooperator\n from twisted.web.http_headers import Headers\n from twisted.web.iweb import IBodyProducer, IResponse\n@@ -45,7 +44,7 @@\n from synapse.http import QuieterFileBodyProducer\n from synapse.http.client import (\n     BlacklistingAgentWrapper,\n-    IPBlacklistingResolver,\n+    BlacklistingReactorWrapper,\n     encode_query_args,\n     readBodyToFile,\n )\n@@ -221,31 +220,22 @@ def __init__(self, hs, tls_client_options_factory):\n         self.signing_key = hs.signing_key\n         self.server_name = hs.hostname\n \n-        real_reactor = hs.get_reactor()\n-\n         # We need to use a DNS resolver which filters out blacklisted IP\n         # addresses, to prevent DNS rebinding.\n-        nameResolver = IPBlacklistingResolver(\n-            real_reactor, None, hs.config.federation_ip_range_blacklist\n+        self.reactor = BlacklistingReactorWrapper(\n+            hs.get_reactor(), None, hs.config.federation_ip_range_blacklist\n         )\n \n-        @implementer(IReactorPluggableNameResolver)\n-        class Reactor:\n-            def __getattr__(_self, attr):\n-                if attr == \"nameResolver\":\n-                    return nameResolver\n-                else:\n-                    return getattr(real_reactor, attr)\n-\n-        self.reactor = Reactor()\n-\n         user_agent = hs.version_string\n         if hs.config.user_agent_suffix:\n             user_agent = \"%s %s\" % (user_agent, hs.config.user_agent_suffix)\n         user_agent = user_agent.encode(\"ascii\")\n \n         self.agent = MatrixFederationAgent(\n-            self.reactor, tls_client_options_factory, user_agent\n+            self.reactor,\n+            tls_client_options_factory,\n+            user_agent,\n+            hs.config.federation_ip_range_blacklist,\n         )\n \n         # Use a BlacklistingAgentWrapper to prevent circumventing the IP"
        },
        {
          "filename": "synapse/push/httppusher.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -100,7 +100,7 @@ def __init__(self, hs, pusherdict):\n         if \"url\" not in self.data:\n             raise PusherConfigException(\"'url' required in data for HTTP pusher\")\n         self.url = self.data[\"url\"]\n-        self.http_client = hs.get_proxied_http_client()\n+        self.http_client = hs.get_proxied_blacklisted_http_client()\n         self.data_minus_url = {}\n         self.data_minus_url.update(self.data)\n         del self.data_minus_url[\"url\"]"
        },
        {
          "filename": "synapse/rest/media/v1/media_repository.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -66,7 +66,7 @@ class MediaRepository:\n     def __init__(self, hs):\n         self.hs = hs\n         self.auth = hs.get_auth()\n-        self.client = hs.get_http_client()\n+        self.client = hs.get_federation_http_client()\n         self.clock = hs.get_clock()\n         self.server_name = hs.hostname\n         self.store = hs.get_datastore()"
        },
        {
          "filename": "synapse/server.py",
          "status": "modified",
          "additions": 29,
          "deletions": 7,
          "patch": "@@ -350,16 +350,45 @@ def get_http_client_context_factory(self) -> IPolicyForHTTPS:\n \n     @cache_in_self\n     def get_simple_http_client(self) -> SimpleHttpClient:\n+        \"\"\"\n+        An HTTP client with no special configuration.\n+        \"\"\"\n         return SimpleHttpClient(self)\n \n     @cache_in_self\n     def get_proxied_http_client(self) -> SimpleHttpClient:\n+        \"\"\"\n+        An HTTP client that uses configured HTTP(S) proxies.\n+        \"\"\"\n+        return SimpleHttpClient(\n+            self,\n+            http_proxy=os.getenvb(b\"http_proxy\"),\n+            https_proxy=os.getenvb(b\"HTTPS_PROXY\"),\n+        )\n+\n+    @cache_in_self\n+    def get_proxied_blacklisted_http_client(self) -> SimpleHttpClient:\n+        \"\"\"\n+        An HTTP client that uses configured HTTP(S) proxies and blacklists IPs\n+        based on the IP range blacklist.\n+        \"\"\"\n         return SimpleHttpClient(\n             self,\n+            ip_blacklist=self.config.ip_range_blacklist,\n             http_proxy=os.getenvb(b\"http_proxy\"),\n             https_proxy=os.getenvb(b\"HTTPS_PROXY\"),\n         )\n \n+    @cache_in_self\n+    def get_federation_http_client(self) -> MatrixFederationHttpClient:\n+        \"\"\"\n+        An HTTP client for federation.\n+        \"\"\"\n+        tls_client_options_factory = context_factory.FederationPolicyForHTTPS(\n+            self.config\n+        )\n+        return MatrixFederationHttpClient(self, tls_client_options_factory)\n+\n     @cache_in_self\n     def get_room_creation_handler(self) -> RoomCreationHandler:\n         return RoomCreationHandler(self)\n@@ -514,13 +543,6 @@ def get_filtering(self) -> Filtering:\n     def get_pusherpool(self) -> PusherPool:\n         return PusherPool(self)\n \n-    @cache_in_self\n-    def get_http_client(self) -> MatrixFederationHttpClient:\n-        tls_client_options_factory = context_factory.FederationPolicyForHTTPS(\n-            self.config\n-        )\n-        return MatrixFederationHttpClient(self, tls_client_options_factory)\n-\n     @cache_in_self\n     def get_media_repository_resource(self) -> MediaRepositoryResource:\n         # build the media repo resource. This indirects through the HomeServer"
        },
        {
          "filename": "tests/api/test_filtering.py",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -50,7 +50,9 @@ def setUp(self):\n         self.mock_http_client.put_json = DeferredMockCallable()\n \n         hs = yield setup_test_homeserver(\n-            self.addCleanup, http_client=self.mock_http_client, keyring=Mock(),\n+            self.addCleanup,\n+            federation_http_client=self.mock_http_client,\n+            keyring=Mock(),\n         )\n \n         self.filtering = hs.get_filtering()"
        },
        {
          "filename": "tests/app/test_frontend_proxy.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -23,7 +23,7 @@ class FrontendProxyTests(HomeserverTestCase):\n     def make_homeserver(self, reactor, clock):\n \n         hs = self.setup_test_homeserver(\n-            http_client=None, homeserver_to_use=GenericWorkerServer\n+            federation_http_client=None, homeserver_to_use=GenericWorkerServer\n         )\n \n         return hs"
        },
        {
          "filename": "tests/app/test_openid_listener.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -27,7 +27,7 @@\n class FederationReaderOpenIDListenerTests(HomeserverTestCase):\n     def make_homeserver(self, reactor, clock):\n         hs = self.setup_test_homeserver(\n-            http_client=None, homeserver_to_use=GenericWorkerServer\n+            federation_http_client=None, homeserver_to_use=GenericWorkerServer\n         )\n         return hs\n \n@@ -84,7 +84,7 @@ def test_openid_listener(self, names, expectation):\n class SynapseHomeserverOpenIDListenerTests(HomeserverTestCase):\n     def make_homeserver(self, reactor, clock):\n         hs = self.setup_test_homeserver(\n-            http_client=None, homeserver_to_use=SynapseHomeServer\n+            federation_http_client=None, homeserver_to_use=SynapseHomeServer\n         )\n         return hs\n "
        },
        {
          "filename": "tests/crypto/test_keyring.py",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -315,7 +315,7 @@ async def get_keys2(keys_to_fetch):\n class ServerKeyFetcherTestCase(unittest.HomeserverTestCase):\n     def make_homeserver(self, reactor, clock):\n         self.http_client = Mock()\n-        hs = self.setup_test_homeserver(http_client=self.http_client)\n+        hs = self.setup_test_homeserver(federation_http_client=self.http_client)\n         return hs\n \n     def test_get_keys_from_server(self):\n@@ -395,7 +395,9 @@ def make_homeserver(self, reactor, clock):\n             }\n         ]\n \n-        return self.setup_test_homeserver(http_client=self.http_client, config=config)\n+        return self.setup_test_homeserver(\n+            federation_http_client=self.http_client, config=config\n+        )\n \n     def build_perspectives_response(\n         self, server_name: str, signing_key: SigningKey, valid_until_ts: int,"
        },
        {
          "filename": "tests/handlers/test_device.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -27,7 +27,7 @@\n \n class DeviceTestCase(unittest.HomeserverTestCase):\n     def make_homeserver(self, reactor, clock):\n-        hs = self.setup_test_homeserver(\"server\", http_client=None)\n+        hs = self.setup_test_homeserver(\"server\", federation_http_client=None)\n         self.handler = hs.get_device_handler()\n         self.store = hs.get_datastore()\n         return hs\n@@ -229,7 +229,7 @@ def _record_user(\n \n class DehydrationTestCase(unittest.HomeserverTestCase):\n     def make_homeserver(self, reactor, clock):\n-        hs = self.setup_test_homeserver(\"server\", http_client=None)\n+        hs = self.setup_test_homeserver(\"server\", federation_http_client=None)\n         self.handler = hs.get_device_handler()\n         self.registration = hs.get_registration_handler()\n         self.auth = hs.get_auth()"
        },
        {
          "filename": "tests/handlers/test_directory.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -42,7 +42,7 @@ def register_query_handler(query_type, handler):\n         self.mock_registry.register_query_handler = register_query_handler\n \n         hs = self.setup_test_homeserver(\n-            http_client=None,\n+            federation_http_client=None,\n             resource_for_federation=Mock(),\n             federation_client=self.mock_federation,\n             federation_registry=self.mock_registry,"
        },
        {
          "filename": "tests/handlers/test_federation.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -37,7 +37,7 @@ class FederationTestCase(unittest.HomeserverTestCase):\n     ]\n \n     def make_homeserver(self, reactor, clock):\n-        hs = self.setup_test_homeserver(http_client=None)\n+        hs = self.setup_test_homeserver(federation_http_client=None)\n         self.handler = hs.get_federation_handler()\n         self.store = hs.get_datastore()\n         return hs"
        },
        {
          "filename": "tests/handlers/test_presence.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -463,7 +463,7 @@ class PresenceJoinTestCase(unittest.HomeserverTestCase):\n \n     def make_homeserver(self, reactor, clock):\n         hs = self.setup_test_homeserver(\n-            \"server\", http_client=None, federation_sender=Mock()\n+            \"server\", federation_http_client=None, federation_sender=Mock()\n         )\n         return hs\n "
        },
        {
          "filename": "tests/handlers/test_profile.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -44,7 +44,7 @@ def register_query_handler(query_type, handler):\n \n         hs = yield setup_test_homeserver(\n             self.addCleanup,\n-            http_client=None,\n+            federation_http_client=None,\n             resource_for_federation=Mock(),\n             federation_client=self.mock_federation,\n             federation_server=Mock(),"
        },
        {
          "filename": "tests/handlers/test_typing.py",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -70,7 +70,7 @@ def make_homeserver(self, reactor, clock):\n \n         hs = self.setup_test_homeserver(\n             notifier=Mock(),\n-            http_client=mock_federation_client,\n+            federation_http_client=mock_federation_client,\n             keyring=mock_keyring,\n             replication_streams={},\n         )\n@@ -192,7 +192,7 @@ def test_started_typing_remote_send(self):\n             )\n         )\n \n-        put_json = self.hs.get_http_client().put_json\n+        put_json = self.hs.get_federation_http_client().put_json\n         put_json.assert_called_once_with(\n             \"farm\",\n             path=\"/_matrix/federation/v1/send/1000000\",\n@@ -270,7 +270,7 @@ def test_stopped_typing(self):\n \n         self.on_new_event.assert_has_calls([call(\"typing_key\", 1, rooms=[ROOM_ID])])\n \n-        put_json = self.hs.get_http_client().put_json\n+        put_json = self.hs.get_federation_http_client().put_json\n         put_json.assert_called_once_with(\n             \"farm\",\n             path=\"/_matrix/federation/v1/send/1000000\","
        },
        {
          "filename": "tests/http/federation/test_matrix_federation_agent.py",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -17,6 +17,7 @@\n from mock import Mock\n \n import treq\n+from netaddr import IPSet\n from service_identity import VerificationError\n from zope.interface import implementer\n \n@@ -103,6 +104,7 @@ def setUp(self):\n             reactor=self.reactor,\n             tls_client_options_factory=self.tls_factory,\n             user_agent=\"test-agent\",  # Note that this is unused since _well_known_resolver is provided.\n+            ip_blacklist=IPSet(),\n             _srv_resolver=self.mock_resolver,\n             _well_known_resolver=self.well_known_resolver,\n         )\n@@ -736,6 +738,7 @@ def test_get_well_known_unsigned_cert(self):\n             reactor=self.reactor,\n             tls_client_options_factory=tls_factory,\n             user_agent=b\"test-agent\",  # This is unused since _well_known_resolver is passed below.\n+            ip_blacklist=IPSet(),\n             _srv_resolver=self.mock_resolver,\n             _well_known_resolver=WellKnownResolver(\n                 self.reactor,"
        },
        {
          "filename": "tests/push/test_http.py",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -49,7 +49,9 @@ def post_json_get_json(url, body):\n         config = self.default_config()\n         config[\"start_pushers\"] = True\n \n-        hs = self.setup_test_homeserver(config=config, proxied_http_client=m)\n+        hs = self.setup_test_homeserver(\n+            config=config, proxied_blacklisted_http_client=m\n+        )\n \n         return hs\n "
        },
        {
          "filename": "tests/replication/_base.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -67,7 +67,7 @@ def prepare(self, reactor, clock, hs):\n         # Make a new HomeServer object for the worker\n         self.reactor.lookups[\"testserv\"] = \"1.2.3.4\"\n         self.worker_hs = self.setup_test_homeserver(\n-            http_client=None,\n+            federation_http_client=None,\n             homeserver_to_use=GenericWorkerServer,\n             config=self._get_worker_hs_config(),\n             reactor=self.reactor,\n@@ -264,7 +264,7 @@ def make_worker_hs(\n             worker_app: Type of worker, e.g. `synapse.app.federation_sender`.\n             extra_config: Any extra config to use for this instances.\n             **kwargs: Options that get passed to `self.setup_test_homeserver`,\n-                useful to e.g. pass some mocks for things like `http_client`\n+                useful to e.g. pass some mocks for things like `federation_http_client`\n \n         Returns:\n             The new worker HomeServer instance."
        },
        {
          "filename": "tests/replication/test_federation_sender_shard.py",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -50,7 +50,7 @@ def test_send_event_single_sender(self):\n         self.make_worker_hs(\n             \"synapse.app.federation_sender\",\n             {\"send_federation\": True},\n-            http_client=mock_client,\n+            federation_http_client=mock_client,\n         )\n \n         user = self.register_user(\"user\", \"pass\")\n@@ -81,7 +81,7 @@ def test_send_event_sharded(self):\n                 \"worker_name\": \"sender1\",\n                 \"federation_sender_instances\": [\"sender1\", \"sender2\"],\n             },\n-            http_client=mock_client1,\n+            federation_http_client=mock_client1,\n         )\n \n         mock_client2 = Mock(spec=[\"put_json\"])\n@@ -93,7 +93,7 @@ def test_send_event_sharded(self):\n                 \"worker_name\": \"sender2\",\n                 \"federation_sender_instances\": [\"sender1\", \"sender2\"],\n             },\n-            http_client=mock_client2,\n+            federation_http_client=mock_client2,\n         )\n \n         user = self.register_user(\"user2\", \"pass\")\n@@ -144,7 +144,7 @@ def test_send_typing_sharded(self):\n                 \"worker_name\": \"sender1\",\n                 \"federation_sender_instances\": [\"sender1\", \"sender2\"],\n             },\n-            http_client=mock_client1,\n+            federation_http_client=mock_client1,\n         )\n \n         mock_client2 = Mock(spec=[\"put_json\"])\n@@ -156,7 +156,7 @@ def test_send_typing_sharded(self):\n                 \"worker_name\": \"sender2\",\n                 \"federation_sender_instances\": [\"sender1\", \"sender2\"],\n             },\n-            http_client=mock_client2,\n+            federation_http_client=mock_client2,\n         )\n \n         user = self.register_user(\"user3\", \"pass\")"
        },
        {
          "filename": "tests/replication/test_pusher_shard.py",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -98,7 +98,7 @@ def test_send_push_single_worker(self):\n         self.make_worker_hs(\n             \"synapse.app.pusher\",\n             {\"start_pushers\": True},\n-            proxied_http_client=http_client_mock,\n+            proxied_blacklisted_http_client=http_client_mock,\n         )\n \n         event_id = self._create_pusher_and_send_msg(\"user\")\n@@ -133,7 +133,7 @@ def test_send_push_multiple_workers(self):\n                 \"worker_name\": \"pusher1\",\n                 \"pusher_instances\": [\"pusher1\", \"pusher2\"],\n             },\n-            proxied_http_client=http_client_mock1,\n+            proxied_blacklisted_http_client=http_client_mock1,\n         )\n \n         http_client_mock2 = Mock(spec_set=[\"post_json_get_json\"])\n@@ -148,7 +148,7 @@ def test_send_push_multiple_workers(self):\n                 \"worker_name\": \"pusher2\",\n                 \"pusher_instances\": [\"pusher1\", \"pusher2\"],\n             },\n-            proxied_http_client=http_client_mock2,\n+            proxied_blacklisted_http_client=http_client_mock2,\n         )\n \n         # We choose a user name that we know should go to pusher1."
        },
        {
          "filename": "tests/rest/admin/test_admin.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -210,7 +210,7 @@ def write_to(r):\n         }\n         config[\"media_storage_providers\"] = [provider_config]\n \n-        hs = self.setup_test_homeserver(config=config, http_client=client)\n+        hs = self.setup_test_homeserver(config=config, federation_http_client=client)\n \n         return hs\n "
        },
        {
          "filename": "tests/rest/client/v1/test_presence.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -38,7 +38,7 @@ def make_homeserver(self, reactor, clock):\n \n         hs = self.setup_test_homeserver(\n             \"red\",\n-            http_client=None,\n+            federation_http_client=None,\n             federation_client=Mock(),\n             presence_handler=presence_handler,\n         )"
        },
        {
          "filename": "tests/rest/client/v1/test_profile.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -63,7 +63,7 @@ def setUp(self):\n         hs = yield setup_test_homeserver(\n             self.addCleanup,\n             \"test\",\n-            http_client=None,\n+            federation_http_client=None,\n             resource_for_client=self.mock_resource,\n             federation=Mock(),\n             federation_client=Mock(),"
        },
        {
          "filename": "tests/rest/client/v1/test_rooms.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -45,7 +45,7 @@ class RoomBase(unittest.HomeserverTestCase):\n     def make_homeserver(self, reactor, clock):\n \n         self.hs = self.setup_test_homeserver(\n-            \"red\", http_client=None, federation_client=Mock(),\n+            \"red\", federation_http_client=None, federation_client=Mock(),\n         )\n \n         self.hs.get_federation_handler = Mock()"
        },
        {
          "filename": "tests/rest/client/v1/test_typing.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -39,7 +39,7 @@ class RoomTypingTestCase(unittest.HomeserverTestCase):\n     def make_homeserver(self, reactor, clock):\n \n         hs = self.setup_test_homeserver(\n-            \"red\", http_client=None, federation_client=Mock(),\n+            \"red\", federation_http_client=None, federation_client=Mock(),\n         )\n \n         self.event_source = hs.get_event_sources().sources[\"typing\"]"
        },
        {
          "filename": "tests/rest/key/v2/test_remote_key_resource.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -39,7 +39,7 @@\n class BaseRemoteKeyResourceTestCase(unittest.HomeserverTestCase):\n     def make_homeserver(self, reactor, clock):\n         self.http_client = Mock()\n-        return self.setup_test_homeserver(http_client=self.http_client)\n+        return self.setup_test_homeserver(federation_http_client=self.http_client)\n \n     def create_test_resource(self):\n         return create_resource_tree(\n@@ -172,7 +172,7 @@ def prepare(self, reactor, clock, homeserver):\n             }\n         ]\n         self.hs2 = self.setup_test_homeserver(\n-            http_client=self.http_client2, config=config\n+            federation_http_client=self.http_client2, config=config\n         )\n \n         # wire up outbound POST /key/v2/query requests from hs2 so that they"
        },
        {
          "filename": "tests/rest/media/v1/test_media_storage.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -214,7 +214,7 @@ def write_to(r):\n         }\n         config[\"media_storage_providers\"] = [provider_config]\n \n-        hs = self.setup_test_homeserver(config=config, http_client=client)\n+        hs = self.setup_test_homeserver(config=config, federation_http_client=client)\n \n         return hs\n "
        },
        {
          "filename": "tests/storage/test_e2e_room_keys.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -26,7 +26,7 @@\n \n class E2eRoomKeysHandlerTestCase(unittest.HomeserverTestCase):\n     def make_homeserver(self, reactor, clock):\n-        hs = self.setup_test_homeserver(\"server\", http_client=None)\n+        hs = self.setup_test_homeserver(\"server\", federation_http_client=None)\n         self.store = hs.get_datastore()\n         return hs\n "
        },
        {
          "filename": "tests/storage/test_purge.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -27,7 +27,7 @@ class PurgeTests(HomeserverTestCase):\n     servlets = [room.register_servlets]\n \n     def make_homeserver(self, reactor, clock):\n-        hs = self.setup_test_homeserver(\"server\", http_client=None)\n+        hs = self.setup_test_homeserver(\"server\", federation_http_client=None)\n         return hs\n \n     def prepare(self, reactor, clock, hs):"
        },
        {
          "filename": "tests/storage/test_redaction.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -34,7 +34,7 @@ def make_homeserver(self, reactor, clock):\n         config = self.default_config()\n         config[\"redaction_retention_period\"] = \"30d\"\n         return self.setup_test_homeserver(\n-            resource_for_federation=Mock(), http_client=None, config=config\n+            resource_for_federation=Mock(), federation_http_client=None, config=config\n         )\n \n     def prepare(self, reactor, clock, hs):"
        },
        {
          "filename": "tests/storage/test_roommember.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -36,7 +36,7 @@ class RoomMemberStoreTestCase(unittest.HomeserverTestCase):\n \n     def make_homeserver(self, reactor, clock):\n         hs = self.setup_test_homeserver(\n-            resource_for_federation=Mock(), http_client=None\n+            resource_for_federation=Mock(), federation_http_client=None\n         )\n         return hs\n "
        },
        {
          "filename": "tests/test_federation.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -37,7 +37,7 @@ def setUp(self):\n         self.hs_clock = Clock(self.reactor)\n         self.homeserver = setup_test_homeserver(\n             self.addCleanup,\n-            http_client=self.http_client,\n+            federation_http_client=self.http_client,\n             clock=self.hs_clock,\n             reactor=self.reactor,\n         )"
        },
        {
          "filename": "tests/test_server.py",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -38,7 +38,10 @@ def setUp(self):\n         self.reactor = ThreadedMemoryReactorClock()\n         self.hs_clock = Clock(self.reactor)\n         self.homeserver = setup_test_homeserver(\n-            self.addCleanup, http_client=None, clock=self.hs_clock, reactor=self.reactor\n+            self.addCleanup,\n+            federation_http_client=None,\n+            clock=self.hs_clock,\n+            reactor=self.reactor,\n         )\n \n     def test_handler_for_request(self):"
        }
      ],
      "file_patterns": {
        "security_files": 4,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 28,
        "unique_directories": 26,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "be65a8ec0195955c15fdb179c9158b187638e39a",
            "date": "2023-12-13T14:50:56Z",
            "author_login": "wrjlewis"
          },
          {
            "sha": "66fc265578f4501307edcac2514892ecdf791fc9",
            "date": "2023-12-13T14:47:34Z",
            "author_login": "wrjlewis"
          },
          {
            "sha": "025951bc3b6ddc0a6487ac045cc00a35a9d7eaaa",
            "date": "2023-12-13T14:46:11Z",
            "author_login": "erikjohnston"
          },
          {
            "sha": "70c020b532821f898aaa07c35c5d5ab59055ae1c",
            "date": "2023-12-12T20:32:48Z",
            "author_login": "erikjohnston"
          },
          {
            "sha": "e1f8440c8959719a417fbf1bdda11406cfdf523d",
            "date": "2023-11-21T19:26:47Z",
            "author_login": "clokep"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:L/A:N",
    "cwe_id": "CWE-601",
    "description": "Synapse is a Matrix reference homeserver written in python (pypi package matrix-synapse). Matrix is an ecosystem for open federated Instant Messaging and VoIP. In Synapse before version 1.25.0, requests to user provided domains were not restricted to external IP addresses when calculating the key validity for third-party invite events and sending push notifications. This could cause Synapse to make requests to internal infrastructure. The type of request was not controlled by the user, although limited modification of request bodies was possible. For the most thorough protection server administrators should remove the deprecated `federation_ip_range_blacklist` from their settings after upgrading to Synapse v1.25.0 which will result in Synapse using the improved default IP address restrictions. See the new `ip_range_blacklist` and `ip_range_whitelist` settings if more specific control is necessary.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2021-02-26T18:15:12.143",
    "last_modified": "2024-11-21T05:47:54.387",
    "fix_date": "2020-12-02T16:09:24Z"
  },
  "references": [
    {
      "url": "https://github.com/matrix-org/synapse/commit/30fba6210834a4ecd91badf0c8f3eb278b72e746",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/pull/8821",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/releases/tag/v1.25.0",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/security/advisories/GHSA-v936-j8gp-9q3p",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TNNAJOZNMVMXM6AS7RFFKB4QLUJ4IFEY/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/matrix-org/synapse/commit/30fba6210834a4ecd91badf0c8f3eb278b72e746",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/pull/8821",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/releases/tag/v1.25.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/security/advisories/GHSA-v936-j8gp-9q3p",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TNNAJOZNMVMXM6AS7RFFKB4QLUJ4IFEY/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:16.809117",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "synapse",
    "owner": "matrix-org",
    "created_at": "2014-08-11T15:51:42Z",
    "updated_at": "2025-01-14T04:04:49Z",
    "pushed_at": "2024-04-26T15:47:23Z",
    "size": 429495,
    "stars": 11851,
    "forks": 2122,
    "open_issues": 1529,
    "watchers": 11851,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [],
    "languages": {
      "Python": 11907179,
      "Rust": 95720,
      "HTML": 64571,
      "Shell": 59187,
      "Perl": 28191,
      "Nix": 12267,
      "Dockerfile": 12096,
      "JavaScript": 11988,
      "Jinja": 7942,
      "CSS": 6211,
      "Makefile": 634,
      "Gherkin": 308,
      "Lua": 241
    },
    "commit_activity": {
      "total_commits_last_year": 1,
      "avg_commits_per_week": 0.019230769230769232,
      "days_active_last_year": 1
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:52:33.725944"
  }
}