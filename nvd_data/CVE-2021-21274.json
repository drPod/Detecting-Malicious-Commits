{
  "cve_id": "CVE-2021-21274",
  "github_data": {
    "repository": "matrix-org/synapse",
    "fix_commit": "ff5c4da1289cb5e097902b3e55b771be342c29d6",
    "related_commits": [
      "ff5c4da1289cb5e097902b3e55b771be342c29d6",
      "ff5c4da1289cb5e097902b3e55b771be342c29d6"
    ],
    "patch_url": "https://github.com/matrix-org/synapse/commit/ff5c4da1289cb5e097902b3e55b771be342c29d6.patch",
    "fix_commit_details": {
      "sha": "ff5c4da1289cb5e097902b3e55b771be342c29d6",
      "commit_date": "2020-12-16T22:25:24Z",
      "author": {
        "login": "clokep",
        "type": "User",
        "stats": {
          "total_commits": 1430,
          "average_weekly_commits": 2.623853211009174,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 192
        }
      },
      "commit_message": {
        "title": "Add a maximum size for well-known lookups. (#8950)",
        "length": 50,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 98,
        "additions": 80,
        "deletions": 18
      },
      "files": [
        {
          "filename": "changelog.d/8950.misc",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+Add a maximum size of 50 kilobytes to .well-known lookups."
        },
        {
          "filename": "synapse/http/client.py",
          "status": "modified",
          "additions": 18,
          "deletions": 14,
          "patch": "@@ -720,11 +720,14 @@ async def get_file(\n \n         try:\n             length = await make_deferred_yieldable(\n-                readBodyToFile(response, output_stream, max_size)\n+                read_body_with_max_size(response, output_stream, max_size)\n+            )\n+        except BodyExceededMaxSize:\n+            SynapseError(\n+                502,\n+                \"Requested file is too large > %r bytes\" % (max_size,),\n+                Codes.TOO_LARGE,\n             )\n-        except SynapseError:\n-            # This can happen e.g. because the body is too large.\n-            raise\n         except Exception as e:\n             raise SynapseError(502, (\"Failed to download remote body: %s\" % e)) from e\n \n@@ -748,7 +751,11 @@ def _timeout_to_request_timed_out_error(f: Failure):\n     return f\n \n \n-class _ReadBodyToFileProtocol(protocol.Protocol):\n+class BodyExceededMaxSize(Exception):\n+    \"\"\"The maximum allowed size of the HTTP body was exceeded.\"\"\"\n+\n+\n+class _ReadBodyWithMaxSizeProtocol(protocol.Protocol):\n     def __init__(\n         self, stream: BinaryIO, deferred: defer.Deferred, max_size: Optional[int]\n     ):\n@@ -761,13 +768,7 @@ def dataReceived(self, data: bytes) -> None:\n         self.stream.write(data)\n         self.length += len(data)\n         if self.max_size is not None and self.length >= self.max_size:\n-            self.deferred.errback(\n-                SynapseError(\n-                    502,\n-                    \"Requested file is too large > %r bytes\" % (self.max_size,),\n-                    Codes.TOO_LARGE,\n-                )\n-            )\n+            self.deferred.errback(BodyExceededMaxSize())\n             self.deferred = defer.Deferred()\n             self.transport.loseConnection()\n \n@@ -782,12 +783,15 @@ def connectionLost(self, reason: Failure) -> None:\n             self.deferred.errback(reason)\n \n \n-def readBodyToFile(\n+def read_body_with_max_size(\n     response: IResponse, stream: BinaryIO, max_size: Optional[int]\n ) -> defer.Deferred:\n     \"\"\"\n     Read a HTTP response body to a file-object. Optionally enforcing a maximum file size.\n \n+    If the maximum file size is reached, the returned Deferred will resolve to a\n+    Failure with a BodyExceededMaxSize exception.\n+\n     Args:\n         response: The HTTP response to read from.\n         stream: The file-object to write to.\n@@ -798,7 +802,7 @@ def readBodyToFile(\n     \"\"\"\n \n     d = defer.Deferred()\n-    response.deliverBody(_ReadBodyToFileProtocol(stream, d, max_size))\n+    response.deliverBody(_ReadBodyWithMaxSizeProtocol(stream, d, max_size))\n     return d\n \n "
        },
        {
          "filename": "synapse/http/federation/well_known_resolver.py",
          "status": "modified",
          "additions": 23,
          "deletions": 2,
          "patch": "@@ -15,17 +15,19 @@\n import logging\n import random\n import time\n+from io import BytesIO\n from typing import Callable, Dict, Optional, Tuple\n \n import attr\n \n from twisted.internet import defer\n from twisted.internet.interfaces import IReactorTime\n-from twisted.web.client import RedirectAgent, readBody\n+from twisted.web.client import RedirectAgent\n from twisted.web.http import stringToDatetime\n from twisted.web.http_headers import Headers\n from twisted.web.iweb import IAgent, IResponse\n \n+from synapse.http.client import BodyExceededMaxSize, read_body_with_max_size\n from synapse.logging.context import make_deferred_yieldable\n from synapse.util import Clock, json_decoder\n from synapse.util.caches.ttlcache import TTLCache\n@@ -53,6 +55,9 @@\n # lower bound for .well-known cache period\n WELL_KNOWN_MIN_CACHE_PERIOD = 5 * 60\n \n+# The maximum size (in bytes) to allow a well-known file to be.\n+WELL_KNOWN_MAX_SIZE = 50 * 1024  # 50 KiB\n+\n # Attempt to refetch a cached well-known N% of the TTL before it expires.\n # e.g. if set to 0.2 and we have a cached entry with a TTL of 5mins, then\n # we'll start trying to refetch 1 minute before it expires.\n@@ -229,6 +234,9 @@ async def _make_well_known_request(\n             server_name: name of the server, from the requested url\n             retry: Whether to retry the request if it fails.\n \n+        Raises:\n+            _FetchWellKnownFailure if we fail to lookup a result\n+\n         Returns:\n             Returns the response object and body. Response may be a non-200 response.\n         \"\"\"\n@@ -250,7 +258,11 @@ async def _make_well_known_request(\n                         b\"GET\", uri, headers=Headers(headers)\n                     )\n                 )\n-                body = await make_deferred_yieldable(readBody(response))\n+                body_stream = BytesIO()\n+                await make_deferred_yieldable(\n+                    read_body_with_max_size(response, body_stream, WELL_KNOWN_MAX_SIZE)\n+                )\n+                body = body_stream.getvalue()\n \n                 if 500 <= response.code < 600:\n                     raise Exception(\"Non-200 response %s\" % (response.code,))\n@@ -259,6 +271,15 @@ async def _make_well_known_request(\n             except defer.CancelledError:\n                 # Bail if we've been cancelled\n                 raise\n+            except BodyExceededMaxSize:\n+                # If the well-known file was too large, do not keep attempting\n+                # to download it, but consider it a temporary error.\n+                logger.warning(\n+                    \"Requested .well-known file for %s is too large > %r bytes\",\n+                    server_name.decode(\"ascii\"),\n+                    WELL_KNOWN_MAX_SIZE,\n+                )\n+                raise _FetchWellKnownFailure(temporary=True)\n             except Exception as e:\n                 if not retry or i >= WELL_KNOWN_RETRY_ATTEMPTS:\n                     logger.info(\"Error fetching %s: %s\", uri_str, e)"
        },
        {
          "filename": "synapse/http/matrixfederationclient.py",
          "status": "modified",
          "additions": 11,
          "deletions": 2,
          "patch": "@@ -37,16 +37,19 @@\n import synapse.metrics\n import synapse.util.retryutils\n from synapse.api.errors import (\n+    Codes,\n     FederationDeniedError,\n     HttpResponseException,\n     RequestSendFailed,\n+    SynapseError,\n )\n from synapse.http import QuieterFileBodyProducer\n from synapse.http.client import (\n     BlacklistingAgentWrapper,\n     BlacklistingReactorWrapper,\n+    BodyExceededMaxSize,\n     encode_query_args,\n-    readBodyToFile,\n+    read_body_with_max_size,\n )\n from synapse.http.federation.matrix_federation_agent import MatrixFederationAgent\n from synapse.logging.context import make_deferred_yieldable\n@@ -975,9 +978,15 @@ async def get_file(\n         headers = dict(response.headers.getAllRawHeaders())\n \n         try:\n-            d = readBodyToFile(response, output_stream, max_size)\n+            d = read_body_with_max_size(response, output_stream, max_size)\n             d.addTimeout(self.default_timeout, self.reactor)\n             length = await make_deferred_yieldable(d)\n+        except BodyExceededMaxSize:\n+            msg = \"Requested file is too large > %r bytes\" % (max_size,)\n+            logger.warning(\n+                \"{%s} [%s] %s\", request.txn_id, request.destination, msg,\n+            )\n+            SynapseError(502, msg, Codes.TOO_LARGE)\n         except Exception as e:\n             logger.warning(\n                 \"{%s} [%s] Error reading response: %s\","
        },
        {
          "filename": "tests/http/federation/test_matrix_federation_agent.py",
          "status": "modified",
          "additions": 27,
          "deletions": 0,
          "patch": "@@ -36,6 +36,7 @@\n from synapse.http.federation.matrix_federation_agent import MatrixFederationAgent\n from synapse.http.federation.srv_resolver import Server\n from synapse.http.federation.well_known_resolver import (\n+    WELL_KNOWN_MAX_SIZE,\n     WellKnownResolver,\n     _cache_period_from_headers,\n )\n@@ -1107,6 +1108,32 @@ def test_well_known_cache_with_temp_failure(self):\n         r = self.successResultOf(fetch_d)\n         self.assertEqual(r.delegated_server, None)\n \n+    def test_well_known_too_large(self):\n+        \"\"\"A well-known query that returns a result which is too large should be rejected.\"\"\"\n+        self.reactor.lookups[\"testserv\"] = \"1.2.3.4\"\n+\n+        fetch_d = defer.ensureDeferred(\n+            self.well_known_resolver.get_well_known(b\"testserv\")\n+        )\n+\n+        # there should be an attempt to connect on port 443 for the .well-known\n+        clients = self.reactor.tcpClients\n+        self.assertEqual(len(clients), 1)\n+        (host, port, client_factory, _timeout, _bindAddress) = clients.pop(0)\n+        self.assertEqual(host, \"1.2.3.4\")\n+        self.assertEqual(port, 443)\n+\n+        self._handle_well_known_connection(\n+            client_factory,\n+            expected_sni=b\"testserv\",\n+            response_headers={b\"Cache-Control\": b\"max-age=1000\"},\n+            content=b'{ \"m.server\": \"' + (b\"a\" * WELL_KNOWN_MAX_SIZE) + b'\" }',\n+        )\n+\n+        # The result is sucessful, but disabled delegation.\n+        r = self.successResultOf(fetch_d)\n+        self.assertIsNone(r.delegated_server)\n+\n     def test_srv_fallbacks(self):\n         \"\"\"Test that other SRV results are tried if the first one fails.\n         \"\"\""
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "be65a8ec0195955c15fdb179c9158b187638e39a",
            "date": "2023-12-13T14:50:56Z",
            "author_login": "wrjlewis"
          },
          {
            "sha": "66fc265578f4501307edcac2514892ecdf791fc9",
            "date": "2023-12-13T14:47:34Z",
            "author_login": "wrjlewis"
          },
          {
            "sha": "025951bc3b6ddc0a6487ac045cc00a35a9d7eaaa",
            "date": "2023-12-13T14:46:11Z",
            "author_login": "erikjohnston"
          },
          {
            "sha": "70c020b532821f898aaa07c35c5d5ab59055ae1c",
            "date": "2023-12-12T20:32:48Z",
            "author_login": "erikjohnston"
          },
          {
            "sha": "e1f8440c8959719a417fbf1bdda11406cfdf523d",
            "date": "2023-11-21T19:26:47Z",
            "author_login": "clokep"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-400",
    "description": "Synapse is a Matrix reference homeserver written in python (pypi package matrix-synapse). Matrix is an ecosystem for open federated Instant Messaging and VoIP. In Synapse before version 1.25.0, a malicious homeserver could redirect requests to their .well-known file to a large file. This can lead to a denial of service attack where homeservers will consume significantly more resources when requesting the .well-known file of a malicious homeserver. This affects any server which accepts federation requests from untrusted servers. Issue is resolved in version 1.25.0. As a workaround the `federation_domain_whitelist` setting can be used to restrict the homeservers communicated with over federation.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-02-26T18:15:12.237",
    "last_modified": "2024-11-21T05:47:54.520",
    "fix_date": "2020-12-16T22:25:24Z"
  },
  "references": [
    {
      "url": "https://github.com/matrix-org/synapse/commit/ff5c4da1289cb5e097902b3e55b771be342c29d6",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/pull/8950",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/releases/tag/v1.25.0",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/security/advisories/GHSA-2hwx-mjrm-v3g8",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TNNAJOZNMVMXM6AS7RFFKB4QLUJ4IFEY/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/matrix-org/synapse/commit/ff5c4da1289cb5e097902b3e55b771be342c29d6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/pull/8950",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/releases/tag/v1.25.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/security/advisories/GHSA-2hwx-mjrm-v3g8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TNNAJOZNMVMXM6AS7RFFKB4QLUJ4IFEY/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:16.809287",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "synapse",
    "owner": "matrix-org",
    "created_at": "2014-08-11T15:51:42Z",
    "updated_at": "2025-01-14T04:04:49Z",
    "pushed_at": "2024-04-26T15:47:23Z",
    "size": 429495,
    "stars": 11851,
    "forks": 2122,
    "open_issues": 1529,
    "watchers": 11851,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [],
    "languages": {
      "Python": 11907179,
      "Rust": 95720,
      "HTML": 64571,
      "Shell": 59187,
      "Perl": 28191,
      "Nix": 12267,
      "Dockerfile": 12096,
      "JavaScript": 11988,
      "Jinja": 7942,
      "CSS": 6211,
      "Makefile": 634,
      "Gherkin": 308,
      "Lua": 241
    },
    "commit_activity": {
      "total_commits_last_year": 1,
      "avg_commits_per_week": 0.019230769230769232,
      "days_active_last_year": 1
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:52:33.725944"
  }
}