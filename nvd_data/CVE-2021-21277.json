{
  "cve_id": "CVE-2021-21277",
  "github_data": {
    "repository": "peerigon/angular-expressions",
    "fix_commit": "07edb62902b1f6127b3dcc013da61c6316dd0bf1",
    "related_commits": [
      "07edb62902b1f6127b3dcc013da61c6316dd0bf1",
      "07edb62902b1f6127b3dcc013da61c6316dd0bf1"
    ],
    "patch_url": "https://github.com/peerigon/angular-expressions/commit/07edb62902b1f6127b3dcc013da61c6316dd0bf1.patch",
    "fix_commit_details": {
      "sha": "07edb62902b1f6127b3dcc013da61c6316dd0bf1",
      "commit_date": "2021-01-29T10:36:19Z",
      "author": {
        "login": "edi9999",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix Security Vulnerability by using hasOwnProperty defensively",
        "length": 62,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 138,
        "additions": 90,
        "deletions": 48
      },
      "files": [
        {
          "filename": "CHANGELOG.md",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -1,3 +1,7 @@\n+### 1.1.2\n+\n+- Disallow access to prototype chain (CVE-2021-21277)\n+\n ### 1.1.1\n \n Previous version was published with ES6 feature, now the published JS uses ES5 only\n@@ -18,7 +22,7 @@ function validChars(ch) {\n }\n evaluate = compile(\"\u00eatre_embarass\u00e9\", {\n   isIdentifierStart: validChars,\n-  isIdentifierContinue: validChars\n+  isIdentifierContinue: validChars,\n });\n \n evaluate({ \u00eatre_embarass\u00e9: \"Ping\" });"
        },
        {
          "filename": "lib/parse.js",
          "status": "modified",
          "additions": 57,
          "deletions": 44,
          "patch": "@@ -1694,44 +1694,6 @@ var isAutoBootstrapAllowed = allowAutoBootstrap(window.document);\n    </file>\n  </example>\n  */\n-function angularInit(element, bootstrap) {\n-\tvar appElement,\n-\t\tmodule,\n-\t\tconfig = {};\n-\n-\t// The element `element` has priority over any other element.\n-\tforEach(ngAttrPrefixes, function (prefix) {\n-\t\tvar name = prefix + \"app\";\n-\n-\t\tif (!appElement && element.hasAttribute && element.hasAttribute(name)) {\n-\t\t\tappElement = element;\n-\t\t\tmodule = element.getAttribute(name);\n-\t\t}\n-\t});\n-\tforEach(ngAttrPrefixes, function (prefix) {\n-\t\tvar name = prefix + \"app\";\n-\t\tvar candidate;\n-\n-\t\tif (\n-\t\t\t!appElement &&\n-\t\t\t(candidate = element.querySelector(\"[\" + name.replace(\":\", \"\\\\:\") + \"]\"))\n-\t\t) {\n-\t\t\tappElement = candidate;\n-\t\t\tmodule = candidate.getAttribute(name);\n-\t\t}\n-\t});\n-\tif (appElement) {\n-\t\tif (!isAutoBootstrapAllowed) {\n-\t\t\twindow.console.error(\n-\t\t\t\t\"Angular: disabling automatic bootstrap. <script> protocol indicates \" +\n-\t\t\t\t\t\"an extension, document.location.href does not match.\"\n-\t\t\t);\n-\t\t\treturn;\n-\t\t}\n-\t\tconfig.strictDi = getNgAttribute(appElement, \"strict-di\") !== null;\n-\t\tbootstrap(appElement, module ? [module] : [], config);\n-\t}\n-}\n \n /**\n  * @ngdoc function\n@@ -3232,11 +3194,12 @@ ASTCompiler.prototype = {\n \t\t\tintoId = intoId || this.nextId();\n \t\t\tthis.if_(\n \t\t\t\t\"i\",\n-\t\t\t\tthis.lazyAssign(intoId, this.computedMember(\"i\", ast.watchId)),\n+\t\t\t\tthis.lazyAssign(intoId, this.unsafeComputedMember(\"i\", ast.watchId)),\n \t\t\t\tthis.lazyRecurse(ast, intoId, nameId, recursionFn, create, true)\n \t\t\t);\n \t\t\treturn;\n \t\t}\n+\n \t\tswitch (ast.type) {\n \t\t\tcase AST.Program:\n \t\t\t\tforEach(ast.body, function (expression, pos) {\n@@ -3356,11 +3319,20 @@ ASTCompiler.prototype = {\n \t\t\t\t\tundefined,\n \t\t\t\t\tfunction () {\n \t\t\t\t\t\tvar member = null;\n+\t\t\t\t\t\tconst inAssignment = self.current().inAssignment;\n \t\t\t\t\t\tif (ast.computed) {\n \t\t\t\t\t\t\tright = self.nextId();\n-\t\t\t\t\t\t\tmember = self.computedMember(left, right);\n+\t\t\t\t\t\t\tif (inAssignment || self.state.computing === \"assign\") {\n+\t\t\t\t\t\t\t\tmember = self.unsafeComputedMember(left, right);\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tmember = self.computedMember(left, right);\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tmember = self.nonComputedMember(left, ast.property.name);\n+\t\t\t\t\t\t\tif (inAssignment || self.state.computing === \"assign\") {\n+\t\t\t\t\t\t\t\tmember = self.unsafeNonComputedMember(left, ast.property.name);\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tmember = self.nonComputedMember(left, ast.property.name);\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tright = ast.property.name;\n \t\t\t\t\t\t}\n \n@@ -3447,7 +3419,13 @@ ASTCompiler.prototype = {\n \t\t\t\t\t\t\t\tif (left.name) {\n \t\t\t\t\t\t\t\t\tvar x = self.member(left.context, left.name, left.computed);\n \t\t\t\t\t\t\t\t\texpression =\n-\t\t\t\t\t\t\t\t\t\tx + \".call(\" + [left.context].concat(args).join(\",\") + \")\";\n+\t\t\t\t\t\t\t\t\t\t\"(\" +\n+\t\t\t\t\t\t\t\t\t\tx +\n+\t\t\t\t\t\t\t\t\t\t\" === null ? null : \" +\n+\t\t\t\t\t\t\t\t\t\tself.unsafeMember(left.context, left.name, left.computed) +\n+\t\t\t\t\t\t\t\t\t\t\".call(\" +\n+\t\t\t\t\t\t\t\t\t\t[left.context].concat(args).join(\",\") +\n+\t\t\t\t\t\t\t\t\t\t\"))\";\n \t\t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\t\texpression = right + \"(\" + args.join(\",\") + \")\";\n \t\t\t\t\t\t\t\t}\n@@ -3464,6 +3442,7 @@ ASTCompiler.prototype = {\n \t\t\tcase AST.AssignmentExpression:\n \t\t\t\tright = this.nextId();\n \t\t\t\tleft = {};\n+\t\t\t\tself.current().inAssignment = true;\n \t\t\t\tthis.recurse(\n \t\t\t\t\tast.left,\n \t\t\t\t\tundefined,\n@@ -3489,9 +3468,13 @@ ASTCompiler.prototype = {\n \t\t\t\t\t\t\t\trecursionFn(intoId || expression);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t);\n+\t\t\t\t\t\tself.current().inAssignment = false;\n+\t\t\t\t\t\tself.recurse(ast.right, right);\n+\t\t\t\t\t\tself.current().inAssignment = true;\n \t\t\t\t\t},\n \t\t\t\t\t1\n \t\t\t\t);\n+\t\t\t\tself.current().inAssignment = false;\n \t\t\t\tbreak;\n \t\t\tcase AST.ArrayExpression:\n \t\t\t\targs = [];\n@@ -3532,7 +3515,10 @@ ASTCompiler.prototype = {\n \t\t\t\t\t\t}\n \t\t\t\t\t\tright = self.nextId();\n \t\t\t\t\t\tself.recurse(property.value, right);\n-\t\t\t\t\t\tself.assign(self.member(intoId, left, property.computed), right);\n+\t\t\t\t\t\tself.assign(\n+\t\t\t\t\t\t\tself.unsafeMember(intoId, left, property.computed),\n+\t\t\t\t\t\t\tright\n+\t\t\t\t\t\t);\n \t\t\t\t\t});\n \t\t\t\t} else {\n \t\t\t\t\tforEach(ast.properties, function (property) {\n@@ -3666,9 +3652,35 @@ ASTCompiler.prototype = {\n \t\treturn expr;\n \t},\n \n-\tcomputedMember: function (left, right) {\n+\tunsafeComputedMember: function (left, right) {\n \t\treturn left + \"[\" + right + \"]\";\n \t},\n+\tunsafeNonComputedMember: function (left, right) {\n+\t\treturn this.nonComputedMember(left, right);\n+\t},\n+\n+\tcomputedMember: function (left, right) {\n+\t\tif (this.state.computing === \"assign\") {\n+\t\t\treturn this.unsafeComputedMember(left, right);\n+\t\t}\n+\t\t// return left + \"[\" + right + \"]\";\n+\t\treturn (\n+\t\t\t\"(\" +\n+\t\t\tleft +\n+\t\t\t\".hasOwnProperty(\" +\n+\t\t\tright +\n+\t\t\t\") ? \" +\n+\t\t\tleft +\n+\t\t\t\"[\" +\n+\t\t\tright +\n+\t\t\t\"] : null)\"\n+\t\t);\n+\t},\n+\n+\tunsafeMember: function (left, right, computed) {\n+\t\tif (computed) return this.unsafeComputedMember(left, right);\n+\t\treturn this.unsafeNonComputedMember(left, right);\n+\t},\n \n \tmember: function (left, right, computed) {\n \t\tif (computed) return this.computedMember(left, right);\n@@ -3827,6 +3839,7 @@ ASTInterpreter.prototype = {\n \t\t\t\t\tright = ast.property.name;\n \t\t\t\t}\n \t\t\t\tif (ast.computed) right = this.recurse(ast.property);\n+\n \t\t\t\treturn ast.computed\n \t\t\t\t\t? this.computedMember(left, right, context, create)\n \t\t\t\t\t: this.nonComputedMember(left, right, context, create);"
        },
        {
          "filename": "test/main.test.js",
          "status": "modified",
          "additions": 28,
          "deletions": 3,
          "patch": "@@ -152,6 +152,32 @@ describe(\"expressions\", function () {\n \t\t\t});\n \t\t});\n \n+\t\tdescribe(\"Security\", function () {\n+\t\t\tit(\"should not leak\", function () {\n+\t\t\t\tevaluate = compile(\n+\t\t\t\t\t\"''['c'+'onstructor']['c'+'onstructor']('return process;')()\"\n+\t\t\t\t);\n+\t\t\t\tconst result = evaluate({});\n+\t\t\t\texpect(result).to.equal(undefined);\n+\t\t\t});\n+\n+\t\t\tit(\"should not leak indirectly with string concatenation\", function () {\n+\t\t\t\tevaluate = compile(\n+\t\t\t\t\t\"a = null; a = ''['c'+'onstructor']['c'+'onstructor']; a = a('return process;'); a();\"\n+\t\t\t\t);\n+\t\t\t\tconst result = evaluate({});\n+\t\t\t\texpect(result).to.equal(undefined);\n+\t\t\t});\n+\n+\t\t\tit(\"should not leak indirectly with literal string\", function () {\n+\t\t\t\tevaluate = compile(\n+\t\t\t\t\t\"a = null; a = ''['constructor']['constructor']; a = a('return process;'); a();\"\n+\t\t\t\t);\n+\t\t\t\tconst result = evaluate({});\n+\t\t\t\texpect(result).to.equal(undefined);\n+\t\t\t});\n+\t\t});\n+\n \t\tdescribe(\"when evaluating dot-notated assignments\", function () {\n \t\t\tit(\"should set the new value on scope\", function () {\n \t\t\t\tevaluate = compile(\"island.pirate.name = 'St\u00f6rtebeker'\");\n@@ -468,7 +494,7 @@ describe(\"expressions\", function () {\n \n \t\tit(\"should not leak with computed prop\", function () {\n \t\t\tevaluate = compile(\"a['split']\");\n-\t\t\texpect(evaluate({ a: \"\" })).to.eql(undefined);\n+\t\t\texpect(evaluate({ a: \"\" })).to.eql(null);\n \t\t});\n \n \t\tit(\"should allow to read string length\", function () {\n@@ -487,8 +513,7 @@ describe(\"expressions\", function () {\n \t\t// \tevaluate(scope);\n \t\t// \texpect(scope.name.split).to.be.a(\"function\");\n \t\t// });\n-\t\t//\n-\t\t//\n+\n \t\tit(\"should work with __proto__\", function () {\n \t\t\tevaluate = compile(\"__proto__\");\n \t\t\texpect(evaluate({})).to.eql(undefined);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "bcc88ba5f0c677a9c5c341ac2723ff10c0b4b67d",
            "date": "2024-12-13T20:09:41Z",
            "author_login": "edi9999"
          },
          {
            "sha": "f7f0d99f8b6c9ff7ac546269546d2ad4ac88a86a",
            "date": "2024-12-13T20:08:44Z",
            "author_login": "edi9999"
          },
          {
            "sha": "e422a8c9abd22c7c450131f89283515f68893daa",
            "date": "2024-12-10T13:20:59Z",
            "author_login": "edi9999"
          },
          {
            "sha": "97f7ad94006156eeb97fc942332578b6cfbf8eef",
            "date": "2024-12-10T13:18:04Z",
            "author_login": "edi9999"
          },
          {
            "sha": "c0bf5433d88b4527b4670153ff258378f3ef4ff3",
            "date": "2024-11-25T21:06:14Z",
            "author_login": "edi9999"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:H/A:N",
    "cwe_id": "CWE-74",
    "description": "angular-expressions is \"angular's nicest part extracted as a standalone module for the browser and node\". In angular-expressions before version 1.1.2 there is a vulnerability which allows Remote Code Execution if you call \"expressions.compile(userControlledInput)\" where \"userControlledInput\" is text that comes from user input. The security of the package could be bypassed by using a more complex payload, using a \".constructor.constructor\" technique. In terms of impact: If running angular-expressions in the browser, an attacker could run any browser script when the application code calls expressions.compile(userControlledInput). If running angular-expressions on the server, an attacker could run any Javascript expression, thus gaining Remote Code Execution. This is fixed in version 1.1.2 of angular-expressions A temporary workaround might be either to disable user-controlled input that will be fed into angular-expressions in your application or allow only following characters in the userControlledInput.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-02-01T15:15:13.340",
    "last_modified": "2024-11-21T05:47:54.963",
    "fix_date": "2021-01-29T10:36:19Z"
  },
  "references": [
    {
      "url": "http://blog.angularjs.org/2016/09/angular-16-expression-sandbox-removal.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Broken Link",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/peerigon/angular-expressions/commit/07edb62902b1f6127b3dcc013da61c6316dd0bf1",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/peerigon/angular-expressions/security/advisories/GHSA-j6px-jwvv-vpwq",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://www.npmjs.com/package/angular-expressions",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "http://blog.angularjs.org/2016/09/angular-16-expression-sandbox-removal.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Broken Link",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/peerigon/angular-expressions/commit/07edb62902b1f6127b3dcc013da61c6316dd0bf1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/peerigon/angular-expressions/security/advisories/GHSA-j6px-jwvv-vpwq",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://www.npmjs.com/package/angular-expressions",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:13.176134",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "angular-expressions",
    "owner": "peerigon",
    "created_at": "2014-03-12T00:01:12Z",
    "updated_at": "2024-12-13T20:09:53Z",
    "pushed_at": "2024-12-13T20:09:49Z",
    "size": 1032,
    "stars": 95,
    "forks": 23,
    "open_issues": 2,
    "watchers": 95,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "JavaScript": 107601,
      "Shell": 1864,
      "TypeScript": 1016
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "unlicense"
    },
    "collected_at": "2025-01-14T17:07:55.969867"
  }
}