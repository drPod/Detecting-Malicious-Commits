{
  "cve_id": "CVE-2021-21284",
  "github_data": {
    "repository": "moby/moby",
    "fix_commit": "64bd4485b3a66a597c02c95f5776395e540b2c7c",
    "related_commits": [
      "64bd4485b3a66a597c02c95f5776395e540b2c7c",
      "64bd4485b3a66a597c02c95f5776395e540b2c7c"
    ],
    "patch_url": "https://github.com/moby/moby/commit/64bd4485b3a66a597c02c95f5776395e540b2c7c.patch",
    "fix_commit_details": {
      "sha": "64bd4485b3a66a597c02c95f5776395e540b2c7c",
      "commit_date": "2021-02-02T16:49:34Z",
      "author": {
        "login": "tiborvass",
        "type": "User",
        "stats": {
          "total_commits": 1006,
          "average_weekly_commits": 1.6044657097288677,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 239
        }
      },
      "commit_message": {
        "title": "Merge pull request #41964 from thaJeztah/CVE-2021-21284_master",
        "length": 158,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 140,
        "additions": 69,
        "deletions": 71
      },
      "files": [
        {
          "filename": "daemon/container_operations_unix.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -466,5 +466,5 @@ func (daemon *Daemon) setupContainerMountsRoot(c *container.Container) error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\treturn idtools.MkdirAllAndChown(p, 0700, daemon.idMapping.RootPair())\n+\treturn idtools.MkdirAllAndChown(p, 0701, idtools.CurrentIdentity())\n }"
        },
        {
          "filename": "daemon/create.go",
          "status": "modified",
          "additions": 2,
          "deletions": 4,
          "patch": "@@ -194,12 +194,10 @@ func (daemon *Daemon) create(opts createOpts) (retC *container.Container, retErr\n \t}\n \tctr.RWLayer = rwLayer\n \n-\trootIDs := daemon.idMapping.RootPair()\n-\n-\tif err := idtools.MkdirAndChown(ctr.Root, 0700, rootIDs); err != nil {\n+\tif err := idtools.MkdirAndChown(ctr.Root, 0701, idtools.CurrentIdentity()); err != nil {\n \t\treturn nil, err\n \t}\n-\tif err := idtools.MkdirAndChown(ctr.CheckpointDir(), 0700, rootIDs); err != nil {\n+\tif err := idtools.MkdirAndChown(ctr.CheckpointDir(), 0700, idtools.CurrentIdentity()); err != nil {\n \t\treturn nil, err\n \t}\n "
        },
        {
          "filename": "daemon/daemon.go",
          "status": "modified",
          "additions": 4,
          "deletions": 6,
          "patch": "@@ -795,7 +795,7 @@ func NewDaemon(ctx context.Context, config *config.Config, pluginStore *plugin.S\n \t}\n \n \t// set up the tmpDir to use a canonical path\n-\ttmp, err := prepareTempDir(config.Root, rootIDs)\n+\ttmp, err := prepareTempDir(config.Root)\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"Unable to get the TempDir under %s: %s\", config.Root, err)\n \t}\n@@ -861,7 +861,7 @@ func NewDaemon(ctx context.Context, config *config.Config, pluginStore *plugin.S\n \t}\n \n \tdaemonRepo := filepath.Join(config.Root, \"containers\")\n-\tif err := idtools.MkdirAllAndChown(daemonRepo, 0700, rootIDs); err != nil {\n+\tif err := idtools.MkdirAllAndChown(daemonRepo, 0701, idtools.CurrentIdentity()); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -1374,7 +1374,7 @@ func (daemon *Daemon) Subnets() ([]net.IPNet, []net.IPNet) {\n // prepareTempDir prepares and returns the default directory to use\n // for temporary files.\n // If it doesn't exist, it is created. If it exists, its content is removed.\n-func prepareTempDir(rootDir string, rootIdentity idtools.Identity) (string, error) {\n+func prepareTempDir(rootDir string) (string, error) {\n \tvar tmpDir string\n \tif tmpDir = os.Getenv(\"DOCKER_TMPDIR\"); tmpDir == \"\" {\n \t\ttmpDir = filepath.Join(rootDir, \"tmp\")\n@@ -1392,9 +1392,7 @@ func prepareTempDir(rootDir string, rootIdentity idtools.Identity) (string, erro\n \t\t\t}\n \t\t}\n \t}\n-\t// We don't remove the content of tmpdir if it's not the default,\n-\t// it may hold things that do not belong to us.\n-\treturn tmpDir, idtools.MkdirAllAndChown(tmpDir, 0700, rootIdentity)\n+\treturn tmpDir, idtools.MkdirAllAndChown(tmpDir, 0700, idtools.CurrentIdentity())\n }\n \n func (daemon *Daemon) setGenericResources(conf *config.Config) error {"
        },
        {
          "filename": "daemon/daemon_unix.go",
          "status": "modified",
          "additions": 10,
          "deletions": 4,
          "patch": "@@ -1196,7 +1196,7 @@ func setupRemappedRoot(config *config.Config) (*idtools.IdentityMapping, error)\n \treturn &idtools.IdentityMapping{}, nil\n }\n \n-func setupDaemonRoot(config *config.Config, rootDir string, rootIdentity idtools.Identity) error {\n+func setupDaemonRoot(config *config.Config, rootDir string, remappedRoot idtools.Identity) error {\n \tconfig.Root = rootDir\n \t// the docker root metadata directory needs to have execute permissions for all users (g+x,o+x)\n \t// so that syscalls executing as non-root, operating on subdirectories of the graph root\n@@ -1221,10 +1221,16 @@ func setupDaemonRoot(config *config.Config, rootDir string, rootIdentity idtools\n \t// a new subdirectory with ownership set to the remapped uid/gid (so as to allow\n \t// `chdir()` to work for containers namespaced to that uid/gid)\n \tif config.RemappedRoot != \"\" {\n-\t\tconfig.Root = filepath.Join(rootDir, fmt.Sprintf(\"%d.%d\", rootIdentity.UID, rootIdentity.GID))\n+\t\tid := idtools.CurrentIdentity()\n+\t\t// First make sure the current root dir has the correct perms.\n+\t\tif err := idtools.MkdirAllAndChown(config.Root, 0701, id); err != nil {\n+\t\t\treturn errors.Wrapf(err, \"could not create or set daemon root permissions: %s\", config.Root)\n+\t\t}\n+\n+\t\tconfig.Root = filepath.Join(rootDir, fmt.Sprintf(\"%d.%d\", remappedRoot.UID, remappedRoot.GID))\n \t\tlogrus.Debugf(\"Creating user namespaced daemon root: %s\", config.Root)\n \t\t// Create the root directory if it doesn't exist\n-\t\tif err := idtools.MkdirAllAndChown(config.Root, 0700, rootIdentity); err != nil {\n+\t\tif err := idtools.MkdirAllAndChown(config.Root, 0701, id); err != nil {\n \t\t\treturn fmt.Errorf(\"Cannot create daemon root: %s: %v\", config.Root, err)\n \t\t}\n \t\t// we also need to verify that any pre-existing directories in the path to\n@@ -1237,7 +1243,7 @@ func setupDaemonRoot(config *config.Config, rootDir string, rootIdentity idtools\n \t\t\tif dirPath == \"/\" {\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tif !idtools.CanAccess(dirPath, rootIdentity) {\n+\t\t\tif !idtools.CanAccess(dirPath, remappedRoot) {\n \t\t\t\treturn fmt.Errorf(\"a subdirectory in your graphroot path (%s) restricts access to the remapped root uid/gid; please fix by allowing 'o+x' permissions on existing directories\", config.Root)\n \t\t\t}\n \t\t}"
        },
        {
          "filename": "daemon/graphdriver/aufs/aufs.go",
          "status": "modified",
          "additions": 3,
          "deletions": 6,
          "patch": "@@ -129,18 +129,15 @@ func Init(root string, options []string, uidMaps, gidMaps []idtools.IDMap) (grap\n \t\tlocker:    locker.New(),\n \t}\n \n-\trootUID, rootGID, err := idtools.GetRootUIDGID(uidMaps, gidMaps)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n+\tcurrentID := idtools.CurrentIdentity()\n \t// Create the root aufs driver dir\n-\tif err := idtools.MkdirAllAndChown(root, 0700, idtools.Identity{UID: rootUID, GID: rootGID}); err != nil {\n+\tif err := idtools.MkdirAllAndChown(root, 0701, currentID); err != nil {\n \t\treturn nil, err\n \t}\n \n \t// Populate the dir structure\n \tfor _, p := range paths {\n-\t\tif err := idtools.MkdirAllAndChown(path.Join(root, p), 0700, idtools.Identity{UID: rootUID, GID: rootGID}); err != nil {\n+\t\tif err := idtools.MkdirAllAndChown(path.Join(root, p), 0701, currentID); err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t}"
        },
        {
          "filename": "daemon/graphdriver/btrfs/btrfs.go",
          "status": "modified",
          "additions": 3,
          "deletions": 7,
          "patch": "@@ -70,11 +70,7 @@ func Init(home string, options []string, uidMaps, gidMaps []idtools.IDMap) (grap\n \t\treturn nil, graphdriver.ErrPrerequisites\n \t}\n \n-\trootUID, rootGID, err := idtools.GetRootUIDGID(uidMaps, gidMaps)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tif err := idtools.MkdirAllAndChown(home, 0700, idtools.Identity{UID: rootUID, GID: rootGID}); err != nil {\n+\tif err := idtools.MkdirAllAndChown(home, 0701, idtools.CurrentIdentity()); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -525,7 +521,7 @@ func (d *Driver) Create(id, parent string, opts *graphdriver.CreateOpts) error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tif err := idtools.MkdirAllAndChown(subvolumes, 0700, idtools.Identity{UID: rootUID, GID: rootGID}); err != nil {\n+\tif err := idtools.MkdirAllAndChown(subvolumes, 0701, idtools.CurrentIdentity()); err != nil {\n \t\treturn err\n \t}\n \tif parent == \"\" {\n@@ -560,7 +556,7 @@ func (d *Driver) Create(id, parent string, opts *graphdriver.CreateOpts) error {\n \t\tif err := d.setStorageSize(path.Join(subvolumes, id), driver); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif err := idtools.MkdirAllAndChown(quotas, 0700, idtools.Identity{UID: rootUID, GID: rootGID}); err != nil {\n+\t\tif err := idtools.MkdirAllAndChown(quotas, 0700, idtools.CurrentIdentity()); err != nil {\n \t\t\treturn err\n \t\t}\n \t\tif err := ioutil.WriteFile(path.Join(quotas, id), []byte(fmt.Sprint(driver.options.size)), 0644); err != nil {"
        },
        {
          "filename": "daemon/graphdriver/fuse-overlayfs/fuseoverlayfs.go",
          "status": "modified",
          "additions": 5,
          "deletions": 9,
          "patch": "@@ -88,12 +88,7 @@ func Init(home string, options []string, uidMaps, gidMaps []idtools.IDMap) (grap\n \t\treturn nil, graphdriver.ErrNotSupported\n \t}\n \n-\trootUID, rootGID, err := idtools.GetRootUIDGID(uidMaps, gidMaps)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\t// Create the driver home dir\n-\tif err := idtools.MkdirAllAndChown(path.Join(home, linkDir), 0700, idtools.Identity{UID: rootUID, GID: rootGID}); err != nil {\n+\tif err := idtools.MkdirAllAndChown(path.Join(home, linkDir), 0701, idtools.CurrentIdentity()); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -178,10 +173,11 @@ func (d *Driver) create(id, parent string, opts *graphdriver.CreateOpts) (retErr\n \t}\n \troot := idtools.Identity{UID: rootUID, GID: rootGID}\n \n-\tif err := idtools.MkdirAllAndChown(path.Dir(dir), 0700, root); err != nil {\n+\tcurrentID := idtools.CurrentIdentity()\n+\tif err := idtools.MkdirAllAndChown(path.Dir(dir), 0701, currentID); err != nil {\n \t\treturn err\n \t}\n-\tif err := idtools.MkdirAndChown(dir, 0700, root); err != nil {\n+\tif err := idtools.MkdirAndChown(dir, 0701, currentID); err != nil {\n \t\treturn err\n \t}\n \n@@ -215,7 +211,7 @@ func (d *Driver) create(id, parent string, opts *graphdriver.CreateOpts) (retErr\n \t\treturn nil\n \t}\n \n-\tif err := idtools.MkdirAndChown(path.Join(dir, workDirName), 0700, root); err != nil {\n+\tif err := idtools.MkdirAndChown(path.Join(dir, workDirName), 0701, currentID); err != nil {\n \t\treturn err\n \t}\n "
        },
        {
          "filename": "daemon/graphdriver/overlay/overlay.go",
          "status": "modified",
          "additions": 7,
          "deletions": 9,
          "patch": "@@ -156,12 +156,8 @@ func Init(home string, options []string, uidMaps, gidMaps []idtools.IDMap) (grap\n \t\tlogrus.WithField(\"storage-driver\", \"overlay\").Warn(overlayutils.ErrDTypeNotSupported(\"overlay\", backingFs))\n \t}\n \n-\trootUID, rootGID, err := idtools.GetRootUIDGID(uidMaps, gidMaps)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n \t// Create the driver home dir\n-\tif err := idtools.MkdirAllAndChown(home, 0700, idtools.Identity{UID: rootUID, GID: rootGID}); err != nil {\n+\tif err := idtools.MkdirAllAndChown(home, 0701, idtools.CurrentIdentity()); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -265,10 +261,11 @@ func (d *Driver) Create(id, parent string, opts *graphdriver.CreateOpts) (retErr\n \t}\n \troot := idtools.Identity{UID: rootUID, GID: rootGID}\n \n-\tif err := idtools.MkdirAllAndChown(path.Dir(dir), 0700, root); err != nil {\n+\tcurrentID := idtools.CurrentIdentity()\n+\tif err := idtools.MkdirAllAndChown(path.Dir(dir), 0701, currentID); err != nil {\n \t\treturn err\n \t}\n-\tif err := idtools.MkdirAndChown(dir, 0700, root); err != nil {\n+\tif err := idtools.MkdirAndChown(dir, 0701, currentID); err != nil {\n \t\treturn err\n \t}\n \n@@ -281,6 +278,7 @@ func (d *Driver) Create(id, parent string, opts *graphdriver.CreateOpts) (retErr\n \n \t// Toplevel images are just a \"root\" dir\n \tif parent == \"\" {\n+\t\t// This must be 0755 otherwise unprivileged users will in the container will not be able to read / in the container\n \t\treturn idtools.MkdirAndChown(path.Join(dir, \"root\"), 0755, root)\n \t}\n \n@@ -301,7 +299,7 @@ func (d *Driver) Create(id, parent string, opts *graphdriver.CreateOpts) (retErr\n \t\tif err := idtools.MkdirAndChown(path.Join(dir, \"work\"), 0700, root); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\treturn ioutil.WriteFile(path.Join(dir, \"lower-id\"), []byte(parent), 0666)\n+\t\treturn ioutil.WriteFile(path.Join(dir, \"lower-id\"), []byte(parent), 0600)\n \t}\n \n \t// Otherwise, copy the upper and the lower-id from the parent\n@@ -311,7 +309,7 @@ func (d *Driver) Create(id, parent string, opts *graphdriver.CreateOpts) (retErr\n \t\treturn err\n \t}\n \n-\tif err := ioutil.WriteFile(path.Join(dir, \"lower-id\"), lowerID, 0666); err != nil {\n+\tif err := ioutil.WriteFile(path.Join(dir, \"lower-id\"), lowerID, 0600); err != nil {\n \t\treturn err\n \t}\n "
        },
        {
          "filename": "daemon/graphdriver/overlay2/overlay.go",
          "status": "modified",
          "additions": 4,
          "deletions": 8,
          "patch": "@@ -165,12 +165,7 @@ func Init(home string, options []string, uidMaps, gidMaps []idtools.IDMap) (grap\n \t\tlogger.Warn(overlayutils.ErrDTypeNotSupported(\"overlay2\", backingFs))\n \t}\n \n-\trootUID, rootGID, err := idtools.GetRootUIDGID(uidMaps, gidMaps)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\t// Create the driver home dir\n-\tif err := idtools.MkdirAllAndChown(path.Join(home, linkDir), 0700, idtools.Identity{UID: rootUID, GID: rootGID}); err != nil {\n+\tif err := idtools.MkdirAllAndChown(path.Join(home, linkDir), 0701, idtools.CurrentIdentity()); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -339,11 +334,12 @@ func (d *Driver) create(id, parent string, opts *graphdriver.CreateOpts) (retErr\n \t\treturn err\n \t}\n \troot := idtools.Identity{UID: rootUID, GID: rootGID}\n+\tcurrent := idtools.CurrentIdentity()\n \n-\tif err := idtools.MkdirAllAndChown(path.Dir(dir), 0700, root); err != nil {\n+\tif err := idtools.MkdirAllAndChown(path.Dir(dir), 0701, current); err != nil {\n \t\treturn err\n \t}\n-\tif err := idtools.MkdirAndChown(dir, 0700, root); err != nil {\n+\tif err := idtools.MkdirAndChown(dir, 0701, current); err != nil {\n \t\treturn err\n \t}\n "
        },
        {
          "filename": "daemon/graphdriver/vfs/driver.go",
          "status": "modified",
          "additions": 2,
          "deletions": 3,
          "patch": "@@ -38,8 +38,7 @@ func Init(home string, options []string, uidMaps, gidMaps []idtools.IDMap) (grap\n \t\treturn nil, err\n \t}\n \n-\trootIDs := d.idMapping.RootPair()\n-\tif err := idtools.MkdirAllAndChown(home, 0700, rootIDs); err != nil {\n+\tif err := idtools.MkdirAllAndChown(home, 0701, idtools.CurrentIdentity()); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -141,7 +140,7 @@ func (d *Driver) Create(id, parent string, opts *graphdriver.CreateOpts) error {\n func (d *Driver) create(id, parent string, size uint64) error {\n \tdir := d.dir(id)\n \trootIDs := d.idMapping.RootPair()\n-\tif err := idtools.MkdirAllAndChown(filepath.Dir(dir), 0700, rootIDs); err != nil {\n+\tif err := idtools.MkdirAllAndChown(filepath.Dir(dir), 0701, idtools.CurrentIdentity()); err != nil {\n \t\treturn err\n \t}\n \tif err := idtools.MkdirAndChown(dir, 0755, rootIDs); err != nil {"
        },
        {
          "filename": "daemon/graphdriver/zfs/zfs.go",
          "status": "modified",
          "additions": 1,
          "deletions": 5,
          "patch": "@@ -104,11 +104,7 @@ func Init(base string, opt []string, uidMaps, gidMaps []idtools.IDMap) (graphdri\n \t\treturn nil, fmt.Errorf(\"BUG: zfs get all -t filesystem -rHp '%s' should contain '%s'\", options.fsName, options.fsName)\n \t}\n \n-\trootUID, rootGID, err := idtools.GetRootUIDGID(uidMaps, gidMaps)\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"Failed to get root uid/guid: %v\", err)\n-\t}\n-\tif err := idtools.MkdirAllAndChown(base, 0700, idtools.Identity{UID: rootUID, GID: rootGID}); err != nil {\n+\tif err := idtools.MkdirAllAndChown(base, 0701, idtools.CurrentIdentity()); err != nil {\n \t\treturn nil, fmt.Errorf(\"Failed to create '%s': %v\", base, err)\n \t}\n "
        },
        {
          "filename": "pkg/idtools/idtools.go",
          "status": "modified",
          "additions": 8,
          "deletions": 3,
          "patch": "@@ -35,13 +35,13 @@ const (\n \n // MkdirAllAndChown creates a directory (include any along the path) and then modifies\n // ownership to the requested uid/gid.  If the directory already exists, this\n-// function will still change ownership to the requested uid/gid pair.\n+// function will still change ownership and permissions.\n func MkdirAllAndChown(path string, mode os.FileMode, owner Identity) error {\n \treturn mkdirAs(path, mode, owner, true, true)\n }\n \n // MkdirAndChown creates a directory and then modifies ownership to the requested uid/gid.\n-// If the directory already exists, this function still changes ownership.\n+// If the directory already exists, this function still changes ownership and permissions.\n // Note that unlike os.Mkdir(), this function does not return IsExist error\n // in case path already exists.\n func MkdirAndChown(path string, mode os.FileMode, owner Identity) error {\n@@ -50,7 +50,7 @@ func MkdirAndChown(path string, mode os.FileMode, owner Identity) error {\n \n // MkdirAllAndChownNew creates a directory (include any along the path) and then modifies\n // ownership ONLY of newly created directories to the requested uid/gid. If the\n-// directories along the path exist, no change of ownership will be performed\n+// directories along the path exist, no change of ownership or permissions will be performed\n func MkdirAllAndChownNew(path string, mode os.FileMode, owner Identity) error {\n \treturn mkdirAs(path, mode, owner, true, false)\n }\n@@ -234,3 +234,8 @@ func parseSubidFile(path, username string) (ranges, error) {\n \n \treturn rangeList, s.Err()\n }\n+\n+// CurrentIdentity returns the identity of the current process\n+func CurrentIdentity() Identity {\n+\treturn Identity{UID: os.Getuid(), GID: os.Getegid()}\n+}"
        },
        {
          "filename": "pkg/idtools/idtools_unix.go",
          "status": "modified",
          "additions": 10,
          "deletions": 4,
          "patch": "@@ -40,7 +40,7 @@ func mkdirAs(path string, mode os.FileMode, owner Identity, mkAll, chownExisting\n \t\t}\n \n \t\t// short-circuit--we were called with an existing directory and chown was requested\n-\t\treturn lazyChown(path, owner.UID, owner.GID, stat)\n+\t\treturn setPermissions(path, mode, owner.UID, owner.GID, stat)\n \t}\n \n \tif os.IsNotExist(err) {\n@@ -71,7 +71,7 @@ func mkdirAs(path string, mode os.FileMode, owner Identity, mkAll, chownExisting\n \t// even if it existed, we will chown the requested path + any subpaths that\n \t// didn't exist when we called MkdirAll\n \tfor _, pathComponent := range paths {\n-\t\tif err := lazyChown(pathComponent, owner.UID, owner.GID, nil); err != nil {\n+\t\tif err := setPermissions(pathComponent, mode, owner.UID, owner.GID, nil); err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n@@ -213,17 +213,23 @@ func callGetent(database, key string) (io.Reader, error) {\n \treturn bytes.NewReader(out), nil\n }\n \n-// lazyChown performs a chown only if the uid/gid don't match what's requested\n+// setPermissions performs a chown/chmod only if the uid/gid don't match what's requested\n // Normally a Chown is a no-op if uid/gid match, but in some cases this can still cause an error, e.g. if the\n // dir is on an NFS share, so don't call chown unless we absolutely must.\n-func lazyChown(p string, uid, gid int, stat *system.StatT) error {\n+// Likewise for setting permissions.\n+func setPermissions(p string, mode os.FileMode, uid, gid int, stat *system.StatT) error {\n \tif stat == nil {\n \t\tvar err error\n \t\tstat, err = system.Stat(p)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n+\tif os.FileMode(stat.Mode()).Perm() != mode.Perm() {\n+\t\tif err := os.Chmod(p, mode.Perm()); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n \tif stat.UID() == uint32(uid) && stat.GID() == uint32(gid) {\n \t\treturn nil\n \t}"
        },
        {
          "filename": "volume/local/local.go",
          "status": "modified",
          "additions": 9,
          "deletions": 2,
          "patch": "@@ -50,7 +50,7 @@ type activeMount struct {\n func New(scope string, rootIdentity idtools.Identity) (*Root, error) {\n \trootDirectory := filepath.Join(scope, volumesPathName)\n \n-\tif err := idtools.MkdirAllAndChown(rootDirectory, 0700, rootIdentity); err != nil {\n+\tif err := idtools.MkdirAllAndChown(rootDirectory, 0701, idtools.CurrentIdentity()); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -153,8 +153,15 @@ func (r *Root) Create(name string, opts map[string]string) (volume.Volume, error\n \t}\n \n \tpath := r.DataPath(name)\n+\tvolRoot := filepath.Dir(path)\n+\t// Root dir does not need to be accessed by the remapped root\n+\tif err := idtools.MkdirAllAndChown(volRoot, 0701, idtools.CurrentIdentity()); err != nil {\n+\t\treturn nil, errors.Wrapf(errdefs.System(err), \"error while creating volume root path '%s'\", volRoot)\n+\t}\n+\n+\t// Remapped root does need access to the data path\n \tif err := idtools.MkdirAllAndChown(path, 0755, r.rootIdentity); err != nil {\n-\t\treturn nil, errors.Wrapf(errdefs.System(err), \"error while creating volume path '%s'\", path)\n+\t\treturn nil, errors.Wrapf(errdefs.System(err), \"error while creating volume data path '%s'\", path)\n \t}\n \n \tvar err error"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 10,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "04b03cfc0a99f50088ac9c811a9992e5b05463bc",
            "date": "2025-01-14T14:26:28Z",
            "author_login": "thaJeztah"
          },
          {
            "sha": "80d14859a294ed08b8cce92f5f2075e96f677f74",
            "date": "2025-01-14T13:34:18Z",
            "author_login": "thaJeztah"
          },
          {
            "sha": "5b1b62058feeef6717758a29235bca5815bb62ea",
            "date": "2025-01-14T12:58:23Z",
            "author_login": "thaJeztah"
          },
          {
            "sha": "d60f164e21361989ea33b01a9de3b47ad14fd13e",
            "date": "2025-01-14T12:47:01Z",
            "author_login": "thaJeztah"
          },
          {
            "sha": "a78b84c212be1eb9a5d8ddf72227660e4abc1215",
            "date": "2025-01-14T09:59:46Z",
            "author_login": "thaJeztah"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.8,
    "cvss_vector": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:C/C:N/I:H/A:N",
    "cwe_id": "CWE-22",
    "description": "In Docker before versions 9.03.15, 20.10.3 there is a vulnerability involving the --userns-remap option in which access to remapped root allows privilege escalation to real root. When using \"--userns-remap\", if the root user in the remapped namespace has access to the host filesystem they can modify files under \"/var/lib/docker/<remapping>\" that cause writing files with extended privileges. Versions 20.10.3 and 19.03.15 contain patches that prevent privilege escalation from remapped user.",
    "attack_vector": "ADJACENT_NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-02-02T18:15:11.827",
    "last_modified": "2024-11-21T05:47:55.867",
    "fix_date": "2021-02-02T16:49:34Z"
  },
  "references": [
    {
      "url": "https://docs.docker.com/engine/release-notes/#20103",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/moby/moby/commit/64bd4485b3a66a597c02c95f5776395e540b2c7c",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/moby/moby/releases/tag/v19.03.15",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/moby/moby/releases/tag/v20.10.3",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/moby/moby/security/advisories/GHSA-7452-xqpj-6rpc",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202107-23",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20210226-0005/",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2021/dsa-4865",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://docs.docker.com/engine/release-notes/#20103",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/moby/moby/commit/64bd4485b3a66a597c02c95f5776395e540b2c7c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/moby/moby/releases/tag/v19.03.15",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/moby/moby/releases/tag/v20.10.3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/moby/moby/security/advisories/GHSA-7452-xqpj-6rpc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202107-23",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20210226-0005/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2021/dsa-4865",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:13.178992",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "moby",
    "owner": "moby",
    "created_at": "2013-01-18T18:10:57Z",
    "updated_at": "2025-01-14T12:58:30Z",
    "pushed_at": "2025-01-14T12:58:23Z",
    "size": 224938,
    "stars": 68998,
    "forks": 18677,
    "open_issues": 3533,
    "watchers": 68998,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "1.12.x",
      "1.13.x",
      "17.03.x",
      "17.04.x",
      "17.05.x",
      "19.03",
      "20.10",
      "22.06",
      "23.0",
      "24.0",
      "25.0",
      "26.0",
      "26.1",
      "27.x",
      "master"
    ],
    "languages": {
      "Go": 10171312,
      "Shell": 157078,
      "Dockerfile": 56212,
      "PowerShell": 31839,
      "Makefile": 9923,
      "Python": 7179,
      "C": 4815,
      "HCL": 3897,
      "Assembly": 81
    },
    "commit_activity": {
      "total_commits_last_year": 2581,
      "avg_commits_per_week": 49.63461538461539,
      "days_active_last_year": 295
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:08:15.569963"
  }
}