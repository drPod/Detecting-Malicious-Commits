{
  "cve_id": "CVE-2021-21294",
  "github_data": {
    "repository": "http4s/http4s",
    "fix_commit": "987d6589ef79545b9bb2324ac4bdebf82d9a0171",
    "related_commits": [
      "987d6589ef79545b9bb2324ac4bdebf82d9a0171",
      "987d6589ef79545b9bb2324ac4bdebf82d9a0171"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "987d6589ef79545b9bb2324ac4bdebf82d9a0171",
      "commit_date": "2021-02-02T15:51:01Z",
      "author": {
        "login": "rossabaker",
        "type": "User",
        "stats": {
          "total_commits": 7501,
          "average_weekly_commits": 11.944267515923567,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 451
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-xhv5-w9c5-2r2w",
        "length": 78,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 1474,
        "additions": 765,
        "deletions": 709
      },
      "files": [
        {
          "filename": "blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala",
          "status": "modified",
          "additions": 11,
          "deletions": 14,
          "patch": "@@ -38,7 +38,6 @@ import org.http4s.blaze.channel.{\n   SocketConnection\n }\n import org.http4s.blaze.channel.nio1.NIO1SocketServerGroup\n-import org.http4s.blaze.channel.nio2.NIO2SocketServerGroup\n import org.http4s.blaze.http.http2.server.ALPNServerSelector\n import org.http4s.blaze.pipeline.LeafBuilder\n import org.http4s.blaze.pipeline.stages.SSLStage\n@@ -86,13 +85,13 @@ import scodec.bits.ByteVector\n   *    this is necessary to recover totality from the error condition.\n   * @param banner: Pretty log to display on server start. An empty sequence\n   *    such as Nil disables this\n+  * @param maxConnections: The maximum number of client connections that may be active at any time.\n   */\n-class BlazeServerBuilder[F[_]](\n+class BlazeServerBuilder[F[_]] private (\n     socketAddress: InetSocketAddress,\n     executionContext: ExecutionContext,\n     responseHeaderTimeout: Duration,\n     idleTimeout: Duration,\n-    isNio2: Boolean,\n     connectorPoolSize: Int,\n     bufferSize: Int,\n     selectorThreadFactory: ThreadFactory,\n@@ -105,6 +104,7 @@ class BlazeServerBuilder[F[_]](\n     httpApp: HttpApp[F],\n     serviceErrorHandler: ServiceErrorHandler[F],\n     banner: immutable.Seq[String],\n+    maxConnections: Int,\n     val channelOptions: ChannelOptions\n )(implicit protected val F: Async[F])\n     extends ServerBuilder[F]\n@@ -118,7 +118,6 @@ class BlazeServerBuilder[F[_]](\n       executionContext: ExecutionContext = executionContext,\n       idleTimeout: Duration = idleTimeout,\n       responseHeaderTimeout: Duration = responseHeaderTimeout,\n-      isNio2: Boolean = isNio2,\n       connectorPoolSize: Int = connectorPoolSize,\n       bufferSize: Int = bufferSize,\n       selectorThreadFactory: ThreadFactory = selectorThreadFactory,\n@@ -131,14 +130,14 @@ class BlazeServerBuilder[F[_]](\n       httpApp: HttpApp[F] = httpApp,\n       serviceErrorHandler: ServiceErrorHandler[F] = serviceErrorHandler,\n       banner: immutable.Seq[String] = banner,\n+      maxConnections: Int = maxConnections,\n       channelOptions: ChannelOptions = channelOptions\n   ): Self =\n     new BlazeServerBuilder(\n       socketAddress,\n       executionContext,\n       responseHeaderTimeout,\n       idleTimeout,\n-      isNio2,\n       connectorPoolSize,\n       bufferSize,\n       selectorThreadFactory,\n@@ -151,6 +150,7 @@ class BlazeServerBuilder[F[_]](\n       httpApp,\n       serviceErrorHandler,\n       banner,\n+      maxConnections,\n       channelOptions\n     )\n \n@@ -219,8 +219,6 @@ class BlazeServerBuilder[F[_]](\n   def withSelectorThreadFactory(selectorThreadFactory: ThreadFactory): Self =\n     copy(selectorThreadFactory = selectorThreadFactory)\n \n-  def withNio2(isNio2: Boolean): Self = copy(isNio2 = isNio2)\n-\n   def withWebSockets(enableWebsockets: Boolean): Self =\n     copy(enableWebSockets = enableWebsockets)\n \n@@ -247,6 +245,9 @@ class BlazeServerBuilder[F[_]](\n   def withChunkBufferMaxSize(chunkBufferMaxSize: Int): BlazeServerBuilder[F] =\n     copy(chunkBufferMaxSize = chunkBufferMaxSize)\n \n+  def withMaxConnections(maxConnections: Int): BlazeServerBuilder[F] =\n+    copy(maxConnections = maxConnections)\n+\n   private def pipelineFactory(\n       scheduler: TickWheelExecutor,\n       engineConfig: Option[(SSLContext, SSLEngine => Unit)],\n@@ -343,12 +344,8 @@ class BlazeServerBuilder[F[_]](\n       else address\n \n     val mkFactory: Resource[F, ServerChannelGroup] = Resource.make(F.delay {\n-      if (isNio2)\n-        NIO2SocketServerGroup\n-          .fixedGroup(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory)\n-      else\n-        NIO1SocketServerGroup\n-          .fixedGroup(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory)\n+      NIO1SocketServerGroup\n+        .fixed(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory, maxConnections)\n     })(factory => F.delay(factory.closeGroup()))\n \n     def mkServerChannel(\n@@ -415,7 +412,6 @@ object BlazeServerBuilder {\n       executionContext = executionContext,\n       responseHeaderTimeout = defaults.ResponseTimeout,\n       idleTimeout = defaults.IdleTimeout,\n-      isNio2 = false,\n       connectorPoolSize = DefaultPoolSize,\n       bufferSize = 64 * 1024,\n       selectorThreadFactory = defaultThreadSelectorFactory,\n@@ -428,6 +424,7 @@ object BlazeServerBuilder {\n       httpApp = defaultApp[F],\n       serviceErrorHandler = DefaultServiceErrorHandler[F],\n       banner = defaults.Banner,\n+      maxConnections = defaults.MaxConnections,\n       channelOptions = ChannelOptions(Vector.empty)\n     )\n "
        },
        {
          "filename": "build.sbt",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -83,7 +83,6 @@ lazy val core = libraryProject(\"core\")\n   .enablePlugins(\n     BuildInfoPlugin,\n     MimeLoaderPlugin,\n-    NowarnCompatPlugin,\n   )\n   .settings(\n     description := \"Core http4s library for servers and clients\",\n@@ -113,7 +112,6 @@ lazy val core = libraryProject(\"core\")\n       )\n     },\n     unusedCompileDependenciesFilter -= moduleFilter(\"org.scala-lang\", \"scala-reflect\"),\n-    Compile / packageBin / mappings ~= { _.filterNot(_._2.startsWith(\"scala/\")) },\n   )\n \n lazy val laws = libraryProject(\"laws\")\n@@ -175,7 +173,6 @@ lazy val tests = libraryProject(\"tests\")\n   .dependsOn(core, specs2 % \"test->test\")\n \n lazy val server = libraryProject(\"server\")\n-  .enablePlugins(NowarnCompatPlugin)\n   .settings(\n     description := \"Base library for building http4s servers\",\n     startYear := Some(2014),\n@@ -209,7 +206,6 @@ lazy val prometheusMetrics = libraryProject(\"prometheus-metrics\")\n   )\n \n lazy val client = libraryProject(\"client\")\n-  .enablePlugins(NowarnCompatPlugin)\n   .settings(\n     description := \"Base library for building http4s clients\",\n     startYear := Some(2014),\n@@ -286,6 +282,10 @@ lazy val blazeServer = libraryProject(\"blaze-server\")\n   .settings(\n     description := \"blaze implementation for http4s servers\",\n     startYear := Some(2014),\n+    mimaBinaryIssueFilters ++= Seq(\n+      // privat constructor with new parameter\n+      ProblemFilters.exclude[DirectMissingMethodProblem](\"org.http4s.server.blaze.BlazeServerBuilder.this\")\n+    )\n   )\n   .dependsOn(blazeCore % \"compile;test->test\", server % \"compile;test->test\")\n "
        },
        {
          "filename": "client/src/test/scala/org/http4s/client/middleware/FollowRedirectSuite.scala",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -73,7 +73,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {\n     val req = Request[IO](PUT, uri\"http://localhost/303\").withEntity(\"foo\")\n     client\n       .run(req)\n-      .use { case Ok(resp) =>\n+      .use { case resp =>\n         resp.headers.get(CIString(\"X-Original-Content-Length\")).map(_.value).pure[IO]\n       }\n       .map(_.get)\n@@ -128,7 +128,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {\n       Header(\"Authorization\", \"Bearer s3cr3t\"))\n     client\n       .run(req)\n-      .use { case Ok(resp) =>\n+      .use { case resp =>\n         resp.headers.get(CIString(\"X-Original-Authorization\")).map(_.value).pure[IO]\n       }\n       .assertEquals(Some(\"\"))\n@@ -141,7 +141,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {\n       Header(\"Authorization\", \"Bearer s3cr3t\"))\n     client\n       .run(req)\n-      .use { case Ok(resp) =>\n+      .use { case resp =>\n         resp.headers.get(CIString(\"X-Original-Authorization\")).map(_.value).pure[IO]\n       }\n       .assertEquals(Some(\"Bearer s3cr3t\"))\n@@ -150,7 +150,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {\n   test(\"FollowRedirect should Record the intermediate URIs\") {\n     client\n       .run(Request[IO](uri = uri\"http://localhost/loop/0\"))\n-      .use { case Ok(resp) =>\n+      .use { resp =>\n         IO.pure(FollowRedirect.getRedirectUris(resp))\n       }\n       .assertEquals(\n@@ -164,7 +164,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {\n   test(\"FollowRedirect should Not add any URIs when there are no redirects\") {\n     client\n       .run(Request[IO](uri = uri\"http://localhost/loop/100\"))\n-      .use { case Ok(resp) =>\n+      .use { case resp =>\n         IO.pure(FollowRedirect.getRedirectUris(resp))\n       }\n       .assertEquals(List.empty[Uri])"
        },
        {
          "filename": "core/src/main/scala-2.12/scala/annotation/nowarn.scala",
          "status": "removed",
          "additions": 0,
          "deletions": 22,
          "patch": "@@ -1,22 +0,0 @@\n-/*\n- * Copyright 2013 http4s.org\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package scala.annotation\n-\n-/** Shims Scala 2.13.2's `@nowarn` so it compiles on Scala 2.12.\n-  * Silencer has rudimentary support.\n-  */\n-class nowarn(val value: String = \"\") extends StaticAnnotation"
        },
        {
          "filename": "core/src/main/scala/org/http4s/Uri.scala",
          "status": "modified",
          "additions": 334,
          "deletions": 353,
          "patch": "@@ -170,7 +170,7 @@ object Uri extends UriPlatform {\n \n   /** Decodes the String to a [[Uri]] using the RFC 3986 uri decoding specification */\n   def fromString(s: String): ParseResult[Uri] =\n-    ParseResult.fromParser(uriReferenceUtf8, \"Invalid URI\")(s)\n+    ParseResult.fromParser(Parser.uriReferenceUtf8, \"Invalid URI\")(s)\n \n   /** Parses a String to a [[Uri]] according to RFC 3986.  If decoding\n     *  fails, throws a [[ParseFailure]].\n@@ -181,118 +181,9 @@ object Uri extends UriPlatform {\n   def unsafeFromString(s: String): Uri =\n     fromString(s).valueOr(throw _)\n \n-  /* hier-part   = \"//\" authority path-abempty\n-   *             / path-absolute\n-   *             / path-rootless\n-   *             / path-empty\n-   */\n-  def hierPart(cs: JCharset): Parser0[(Option[Authority], Path)] = {\n-    import P.string\n-    import Authority.{parser => authority}\n-    import Path.{pathAbempty, pathAbsolute, pathEmpty, pathRootless}\n-    val rel: P[(Option[Authority], Path)] = (string(\"//\") *> authority(cs) ~ pathAbempty).map {\n-      case (a, p) => (Some(a), p)\n-    }\n-    P.oneOf0(\n-      rel :: pathAbsolute.map((None, _)) :: pathRootless.map((None, _)) :: pathEmpty.map(\n-        (None, _)) :: Nil)\n-  }\n-\n-  /* absolute-URI  = scheme \":\" hier-part [ \"?\" query ] */\n-  private[http4s] def absoluteUri(cs: JCharset): P[Uri] = {\n-    import cats.parse.Parser.char\n-    import Uri.Scheme.{parser => scheme}\n-    import Query.{parser => query}\n-\n-    (scheme ~ (char(':') *> hierPart(cs)) ~ (char('?') *> query).?).map { case ((s, (a, p)), q) =>\n-      Uri(scheme = Some(s), authority = a, path = p, query = q.getOrElse(Query.empty))\n-    }\n-  }\n-\n-  private[http4s] def parser(cs: JCharset): P[Uri] = {\n-    import cats.parse.Parser.char\n-    import Uri.Scheme.{parser => scheme}\n-    import Query.{parser => query}\n-    import Fragment.{parser => fragment}\n-\n-    (scheme ~ (char(':') *> hierPart(cs)) ~ (char('?') *> query).? ~ (char('#') *> fragment).?)\n-      .map { case (((s, (a, p)), q), f) =>\n-        Uri(\n-          scheme = Some(s),\n-          authority = a,\n-          path = p,\n-          query = q.getOrElse(Query.empty),\n-          fragment = f)\n-      }\n-  }\n-\n-  /* relative-part = \"//\" authority path-abempty\n-                   / path-absolute\n-                   / path-noscheme\n-                   / path-empty\n-   */\n-  private[http4s] def relativePart(cs: JCharset): Parser0[(Option[Authority], Path)] = {\n-    import cats.parse.Parser.string\n-    import Authority.{parser => authority}\n-    import Path.{pathAbempty, pathAbsolute, pathEmpty, pathNoscheme}\n-\n-    P.oneOf0(\n-      ((string(\"//\") *> authority(cs) ~ pathAbempty).map { case (a, p) =>\n-        (Some(a), p)\n-      }) :: (pathAbsolute.map((None, _))) :: (pathNoscheme.map((None, _))) :: (pathEmpty.map(\n-        (None, _))) :: Nil)\n-  }\n-\n-  /* relative-ref  = relative-part [ \"?\" query ] [ \"#\" fragment ] */\n-  private[http4s] def relativeRef(cs: JCharset): Parser0[Uri] = {\n-    import cats.parse.Parser.char\n-    import Query.{parser => query}\n-    import Fragment.{parser => fragment}\n-\n-    (relativePart(cs) ~ (char('?') *> query).? ~ (char('#') *> fragment).?).map {\n-      case (((a, p), q), f) =>\n-        Uri(scheme = None, authority = a, path = p, query = q.getOrElse(Query.empty), fragment = f)\n-    }\n-  }\n-\n-  private[http4s] lazy val uriReferenceUtf8: Parser0[Uri] = uriReference(StandardCharsets.UTF_8)\n-  private[http4s] def uriReference(cs: JCharset): Parser0[Uri] =\n-    parser(cs).backtrack.orElse(relativeRef(cs))\n-\n   /** Decodes the String to a [[Uri]] using the RFC 7230 section 5.3 uri decoding specification */\n   def requestTarget(s: String): ParseResult[Uri] =\n-    ParseResult.fromParser(requestTargetParser, \"Invalid request target\")(s)\n-\n-  /* request-target = origin-form\n-                    / absolute-form\n-                    / authority-form\n-                    / asterisk-form\n-   */\n-  private lazy val requestTargetParser: Parser0[Uri] = {\n-    import cats.parse.Parser.{char, oneOf0}\n-    import Authority.{parser => authority}\n-    import Path.absolutePath\n-    import Query.{parser => query}\n-\n-    /* origin-form    = absolute-path [ \"?\" query ] */\n-    val originForm: P[Uri] =\n-      (absolutePath ~ (char('?') *> query).?).map { case (p, q) =>\n-        Uri(scheme = None, authority = None, path = p, query = q.getOrElse(Query.empty))\n-      }\n-\n-    /* absolute-form = absolute-URI */\n-    def absoluteForm: P[Uri] = absoluteUri(StandardCharsets.UTF_8)\n-\n-    /* authority-form = authority */\n-    val authorityForm: Parser0[Uri] =\n-      authority(StandardCharsets.UTF_8).map(a => Uri(authority = Some(a)))\n-\n-    /* asterisk-form = \"*\" */\n-    val asteriskForm: P[Uri] =\n-      char('*').as(Uri(path = Path.Asterisk))\n-\n-    oneOf0(originForm :: absoluteForm :: authorityForm :: asteriskForm :: Nil)\n-  }\n+    ParseResult.fromParser(Parser.requestTargetParser, \"Invalid request target\")(s)\n \n   /** A [[org.http4s.Uri]] may begin with a scheme name that refers to a\n     * specification for assigning identifiers within that scheme.\n@@ -302,7 +193,7 @@ object Uri extends UriPlatform {\n     *\n     * @see [[https://tools.ietf.org/html/rfc3986#section-3.1 RFC 3986, Section 3.1, Scheme]]\n     */\n-  final class Scheme private (val value: String) extends Ordered[Scheme] {\n+  final class Scheme private[http4s] (val value: String) extends Ordered[Scheme] {\n     override def equals(o: Any) =\n       o match {\n         case that: Scheme => this.value.equalsIgnoreCase(that.value)\n@@ -330,27 +221,12 @@ object Uri extends UriPlatform {\n     def parse(s: String): ParseResult[Scheme] = fromString(s)\n \n     def fromString(s: String): ParseResult[Scheme] =\n-      ParseResult.fromParser(parser, \"Invalid scheme\")(s)\n+      ParseResult.fromParser(Parser.scheme, \"Invalid scheme\")(s)\n \n     /** Like `fromString`, but throws on invalid input */\n     def unsafeFromString(s: String): Scheme =\n       fromString(s).fold(throw _, identity)\n \n-    /* scheme      = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" ) */\n-    private[http4s] val parser: P[Scheme] = {\n-      import cats.parse.Parser.{charIn, not, string}\n-      import Rfc3986.{alpha, digit}\n-\n-      val unary = alpha.orElse(digit).orElse(charIn(\"+-.\"))\n-\n-      (string(\"https\") <* not(unary))\n-        .as(https)\n-        .backtrack\n-        .orElse((string(\"http\") <* not(unary)).as(http))\n-        .backtrack\n-        .orElse((alpha *> unary.rep0).string.map(new Scheme(_)))\n-    }\n-\n     implicit val http4sOrderForScheme: Order[Scheme] =\n       Order.fromComparable\n     implicit val http4sShowForScheme: Show[Scheme] =\n@@ -367,18 +243,6 @@ object Uri extends UriPlatform {\n \n   type Fragment = String\n \n-  object Fragment {\n-    import cats.parse.Parser.charIn\n-    import Rfc3986.pchar\n-\n-    /* fragment    = *( pchar / \"/\" / \"?\" )\n-     *\n-     * Not URL decoded.\n-     */\n-    private[http4s] val parser: Parser0[Fragment] =\n-      pchar.orElse(charIn(\"/?\")).rep0.string\n-  }\n-\n   final case class Authority(\n       userInfo: Option[UserInfo] = None,\n       host: Host = RegName(\"localhost\"),\n@@ -395,16 +259,6 @@ object Uri extends UriPlatform {\n   }\n \n   object Authority {\n-    import cats.parse.Parser.{char}\n-    import UserInfo.{parser => userinfo}\n-    import Host.{parser => host}\n-    import Port.{parser => port}\n-\n-    /* authority   = [ userinfo \"@\" ] host [ \":\" port ] */\n-    def parser(cs: JCharset): Parser0[Authority] =\n-      ((userinfo(cs) <* char('@')).backtrack.? ~ host ~ (char(':') *> port).?).map {\n-        case ((ui, h), p) => Authority(userInfo = ui, host = h, port = p.flatten)\n-      }\n \n     implicit val catsInstancesForHttp4sAuthority\n         : Hash[Authority] with Order[Authority] with Show[Authority] =\n@@ -544,28 +398,6 @@ object Uri extends UriPlatform {\n \n       val empty: Segment = Segment(\"\")\n \n-      import cats.parse.Parser.char\n-      import Rfc3986.{pchar, pctEncoded, subDelims, unreserved}\n-\n-      /* segment       = *pchar */\n-      lazy val segment: Parser0[Segment] =\n-        pchar.rep0.string.map(new Segment(_))\n-\n-      /* segment-nz    = 1*pchar */\n-      lazy val segmentNz: P[Segment] =\n-        pchar.rep.string.map(new Segment(_))\n-\n-      /* segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / \"@\" )\n-                     ; non-zero-length segment without any colon \":\" */\n-      lazy val segmentNzNc: P[Segment] =\n-        unreserved\n-          .orElse(pctEncoded)\n-          .orElse(subDelims)\n-          .orElse(char('@'))\n-          .rep\n-          .string\n-          .map(new Segment(_))\n-\n       implicit val http4sInstancesForSegment: Order[Segment] =\n         new Order[Segment] {\n           def compare(x: Segment, y: Segment): Int =\n@@ -621,70 +453,6 @@ object Uri extends UriPlatform {\n         def combine(x: Path, y: Path): Path = x.concat(y)\n       }\n \n-    import cats.parse.Parser.{char, pure}\n-    import Segment.{segment, segmentNz, segmentNzNc}\n-\n-    /* path-abempty  = *( \"/\" segment ) */\n-    lazy val pathAbempty: cats.parse.Parser0[Path] =\n-      (char('/') *> segment).rep0.map {\n-        case Nil => Path.empty\n-        case List(Segment.empty) => Path.Root\n-        case segments =>\n-          val segmentsV = segments.toVector\n-          if (segmentsV.last.isEmpty)\n-            Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)\n-          else\n-            Path(segmentsV, absolute = true, endsWithSlash = false)\n-      }\n-\n-    /* path-absolute = \"/\" [ segment-nz *( \"/\" segment ) ] */\n-    lazy val pathAbsolute: P[Path] =\n-      (char('/') *> (segmentNz ~ (char('/') *> segment).rep0).?).map {\n-        case Some((head, tail)) =>\n-          val segmentsV = head +: tail.toVector\n-          if (segmentsV.last.isEmpty)\n-            Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)\n-          else\n-            Path(segmentsV, absolute = true, endsWithSlash = false)\n-        case None =>\n-          Path.Root\n-      }\n-\n-    /* path-rootless = segment-nz *( \"/\" segment ) */\n-    lazy val pathRootless: P[Path] =\n-      (segmentNz ~ (char('/') *> segment).rep0).map { case (head, tail) =>\n-        val segmentsV = head +: tail.toVector\n-        if (segmentsV.last.isEmpty)\n-          Path(segmentsV.dropRight(1), absolute = false, endsWithSlash = true)\n-        else\n-          Path(segmentsV, absolute = false, endsWithSlash = false)\n-      }\n-\n-    /* path-empty    = 0<pchar> */\n-    lazy val pathEmpty: Parser0[Path] =\n-      pure(Path.empty)\n-\n-    /* path-noscheme = segment-nz-nc *( \"/\" segment ) */\n-    lazy val pathNoscheme: P[Path] =\n-      (segmentNzNc ~ (char('/') *> segment).rep0).map { case (head, tail) =>\n-        val segmentsV = head +: tail.toVector\n-        if (segmentsV.last.isEmpty)\n-          Path(segmentsV.dropRight(1), absolute = false, endsWithSlash = true)\n-        else\n-          Path(segmentsV, absolute = false, endsWithSlash = false)\n-      }\n-\n-    /* absolute-path = 1*( \"/\" segment ) */\n-    lazy val absolutePath: P[Path] =\n-      (char('/') *> segment).rep.map {\n-        case NonEmptyList(Segment.empty, Nil) => Path.Root\n-        case segments =>\n-          val segmentsV = segments.toList.toVector\n-          if (segmentsV.last.isEmpty)\n-            Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)\n-          else\n-            Path(segmentsV, absolute = true, endsWithSlash = false)\n-      }\n   }\n \n   /** The userinfo subcomponent may consist of a user name and,\n@@ -718,19 +486,7 @@ object Uri extends UriPlatform {\n \n     /** Parses a userInfo from a string percent-encoded in a specific charset. */\n     def fromStringWithCharset(s: String, cs: JCharset): ParseResult[UserInfo] =\n-      ParseResult.fromParser(parser(cs), \"Invalid userinfo\")(s)\n-\n-    /* userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" ) */\n-    private[http4s] def parser(cs: JCharset): cats.parse.Parser0[UserInfo] = {\n-      import cats.parse.Parser.{char, charIn, oneOf}\n-      import Rfc3986.{pctEncoded, subDelims, unreserved}\n-\n-      val username = oneOf(unreserved :: pctEncoded :: subDelims :: Nil).rep0.string\n-      val password = oneOf(unreserved :: pctEncoded :: subDelims :: charIn(':') :: Nil).rep0.string\n-      (username ~ (char(':') *> password).?).map { case (u, p) =>\n-        UserInfo(decode(u, cs), p.map(decode(_, cs)))\n-      }\n-    }\n+      ParseResult.fromParser(Parser.userinfo(cs), \"Invalid userinfo\")(s)\n \n     implicit val http4sInstancesForUserInfo\n         : HttpCodec[UserInfo] with Order[UserInfo] with Hash[UserInfo] with Show[UserInfo] =\n@@ -776,22 +532,6 @@ object Uri extends UriPlatform {\n   }\n \n   object Host {\n-    /* host          = IP-literal / IPv4address / reg-name */\n-    val parser: Parser0[Host] = {\n-      import cats.parse.Parser.char\n-      import Ipv4Address.{parser => ipv4Address}\n-      import Ipv6Address.{parser => ipv6Address}\n-      import RegName.{parser => regName}\n-\n-      // TODO This isn't in the 0.21 model.\n-      /* IPvFuture     = \"v\" 1*HEXDIG \".\" 1*( unreserved / sub-delims / \":\" ) */\n-      val ipVFuture: P[Nothing] = P.fail\n-\n-      /* IP-literal    = \"[\" ( IPv6address / IPvFuture  ) \"]\" */\n-      val ipLiteral = char('[') *> ipv6Address.orElse(ipVFuture) <* char(']')\n-\n-      ipLiteral.orElse(ipv4Address.backtrack).orElse(regName)\n-    }\n \n     implicit val catsInstancesForHttp4sUriHost: Hash[Host] with Order[Host] with Show[Host] =\n       new Hash[Host] with Order[Host] with Show[Host] {\n@@ -877,7 +617,7 @@ object Uri extends UriPlatform {\n \n   object Ipv4Address {\n     def fromString(s: String): ParseResult[Ipv4Address] =\n-      ParseResult.fromParser(parser, \"Invalid IPv4 Address\")(s)\n+      ParseResult.fromParser(Parser.ipv4Address, \"Invalid IPv4 Address\")(s)\n \n     /** Like `fromString`, but throws on invalid input */\n     def unsafeFromString(s: String): Ipv4Address =\n@@ -899,9 +639,6 @@ object Uri extends UriPlatform {\n           throw bug(s\"Inet4Address.getAddress not exactly four bytes: ${array}\")\n       }\n \n-    private[http4s] val parser: P[Ipv4Address] =\n-      Rfc3986.ipv4Bytes.map { case (a, b, c, d) => Ipv4Address(a, b, c, d) }\n-\n     implicit val http4sInstancesForIpv4Address: HttpCodec[Ipv4Address]\n       with Order[Ipv4Address]\n       with Hash[Ipv4Address]\n@@ -1016,7 +753,7 @@ object Uri extends UriPlatform {\n \n   object Ipv6Address {\n     def fromString(s: String): ParseResult[Ipv6Address] =\n-      ParseResult.fromParser(parser, \"Invalid IPv6 address\")(s)\n+      ParseResult.fromParser(Parser.ipv6Address, \"Invalid IPv6 address\")(s)\n \n     /** Like `fromString`, but throws on invalid input */\n     def unsafeFromString(s: String): Ipv6Address =\n@@ -1058,60 +795,6 @@ object Uri extends UriPlatform {\n       }\n     }\n \n-    private[http4s] val parser: P[Ipv6Address] = {\n-      import cats.parse.Parser.{char, string}\n-      import cats.parse.Parser\n-      import Rfc3986.{hexdig, ipv4Bytes}\n-\n-      def toIpv6(lefts: collection.Seq[Short], rights: collection.Seq[Short]): Ipv6Address =\n-        lefts ++ collection.Seq.fill(8 - lefts.size - rights.size)(0.toShort) ++ rights match {\n-          case collection.Seq(a, b, c, d, e, f, g, h) =>\n-            Ipv6Address(a, b, c, d, e, f, g, h)\n-        }\n-\n-      val h16: P[Short] =\n-        (hexdig ~ hexdig.? ~ hexdig.? ~ hexdig.?).string.map { (s: String) =>\n-          java.lang.Integer.parseInt(s, 16).toShort\n-        }\n-\n-      val colon = char(':')\n-      val doubleColon = string(\"::\").void\n-      val h16Colon = h16 <* colon\n-\n-      val parsedIpv4Bytes = ipv4Bytes.map { case (a: Byte, b: Byte, c: Byte, d: Byte) =>\n-        List(((a << 8) | b).toShort, ((c << 8) | d).toShort)\n-      }\n-\n-      def rightsWithIpv4(n: Int) = (1 to n)\n-        .map { i =>\n-          (h16Colon.repExactlyAs[List[Short]](i) ~ parsedIpv4Bytes).backtrack.map { case (l, r) =>\n-            l ++ r\n-          }\n-        }\n-        .foldLeft(parsedIpv4Bytes.backtrack)(_ | _)\n-\n-      val ls32: P[List[Short]] = {\n-        val option1 = ((h16 <* colon.void) ~ h16).map(t => List(t._1, t._2))\n-        option1.backtrack.orElse(parsedIpv4Bytes)\n-      }\n-\n-      val fullIpv6WihtOptionalIpv4 = (h16Colon.repExactlyAs[List[Short]](6) ~ ls32)\n-        .map { case (ls: List[Short], rs) => toIpv6(ls.toList, rs) }\n-\n-      val shortIpv6WithIpv4 = for {\n-        lefts <- h16.repSep0(0, 5, colon).with1 <* doubleColon\n-        rights <- rightsWithIpv4(4 - lefts.size)\n-      } yield toIpv6(lefts, rights)\n-\n-      val shortIpv6 = for {\n-        lefts <- h16.repSep0(0, 7, colon).with1 <* doubleColon\n-        rights <-\n-          if (6 - lefts.size > 0)(h16.repSep0(0, 6 - lefts.size, colon)) else Parser.pure(Nil)\n-      } yield toIpv6(lefts, rights)\n-\n-      fullIpv6WihtOptionalIpv4.backtrack.orElse(shortIpv6WithIpv4.backtrack).orElse(shortIpv6)\n-    }\n-\n     implicit val http4sInstancesForIpv6Address: HttpCodec[Ipv6Address]\n       with Order[Ipv6Address]\n       with Hash[Ipv6Address]\n@@ -1140,18 +823,6 @@ object Uri extends UriPlatform {\n   object RegName {\n     def apply(name: String): RegName = new RegName(CIString(name))\n \n-    /* reg-name    = *( unreserved / pct-encoded / sub-delims) */\n-    val parser: Parser0[RegName] = {\n-      import Rfc3986.{pctEncoded, subDelims, unreserved}\n-\n-      unreserved\n-        .orElse(pctEncoded)\n-        .orElse(subDelims)\n-        .rep0\n-        .string\n-        .map(s => RegName(CIString(decode(s))))\n-    }\n-\n     implicit val catsInstancesForHttp4sUriRegName\n         : Hash[RegName] with Order[RegName] with Show[RegName] =\n       new Hash[RegName] with Order[RegName] with Show[RegName] {\n@@ -1166,23 +837,6 @@ object Uri extends UriPlatform {\n       }\n   }\n \n-  object Port {\n-    /* port        = *DIGIT\n-     *\n-     * Limitation: we only parse up to Int. The spec allows bigint!\n-     */\n-    private[http4s] val parser: Parser0[Option[Int]] = {\n-      import Rfc3986.digit\n-\n-      digit.rep0.string.mapFilter {\n-        case \"\" => Some(None)\n-        case s =>\n-          try Some(Some(s.toInt))\n-          catch { case _: NumberFormatException => None }\n-      }\n-    }\n-  }\n-\n   /** Resolve a relative Uri reference, per RFC 3986 sec 5.2\n     */\n   def resolve(base: Uri, reference: Uri): Uri = {\n@@ -1398,4 +1052,331 @@ object Uri extends UriPlatform {\n       override def show(t: Uri): String =\n         t.renderString\n     }\n+\n+  private[http4s] object Parser {\n+    /* port        = *DIGIT\n+     *\n+     * Limitation: we only parse up to Int. The spec allows bigint!\n+     */\n+    private[http4s] val port: Parser0[Option[Int]] = {\n+      import Rfc3986.digit\n+\n+      digit.rep0.string.mapFilter {\n+        case \"\" => Some(None)\n+        case s =>\n+          try Some(Some(s.toInt))\n+          catch { case _: NumberFormatException => None }\n+      }\n+    }\n+\n+    /* reg-name    = *( unreserved / pct-encoded / sub-delims) */\n+    private[http4s] val regName: Parser0[Uri.RegName] = {\n+      import Rfc3986.{pctEncoded, subDelims, unreserved}\n+\n+      unreserved\n+        .orElse(pctEncoded)\n+        .orElse(subDelims)\n+        .rep0\n+        .string\n+        .map(s => Uri.RegName(CIString(Uri.decode(s))))\n+    }\n+\n+    private[http4s] val ipv6Address: P[Uri.Ipv6Address] = {\n+      import cats.parse.Parser.{char, string}\n+      import Rfc3986.{hexdig, ipv4Bytes}\n+\n+      def toIpv6(lefts: collection.Seq[Short], rights: collection.Seq[Short]): Uri.Ipv6Address =\n+        lefts ++ collection.Seq.fill(8 - lefts.size - rights.size)(0.toShort) ++ rights match {\n+          case collection.Seq(a, b, c, d, e, f, g, h) =>\n+            Uri.Ipv6Address(a, b, c, d, e, f, g, h)\n+        }\n+\n+      val h16: P[Short] =\n+        (hexdig ~ hexdig.? ~ hexdig.? ~ hexdig.?).string.map { (s: String) =>\n+          java.lang.Integer.parseInt(s, 16).toShort\n+        }\n+\n+      val colon = char(':')\n+      val doubleColon = string(\"::\").void\n+      val h16Colon = h16 <* colon\n+\n+      val parsedIpv4Bytes = ipv4Bytes.map { case (a: Byte, b: Byte, c: Byte, d: Byte) =>\n+        List(((a << 8) | b).toShort, ((c << 8) | d).toShort)\n+      }\n+\n+      def rightsWithIpv4(n: Int) = (1 to n)\n+        .map { i =>\n+          (h16Colon.repExactlyAs[List[Short]](i) ~ parsedIpv4Bytes).backtrack.map { case (l, r) =>\n+            l ++ r\n+          }\n+        }\n+        .foldLeft(parsedIpv4Bytes.backtrack)(_ | _)\n+\n+      val ls32: P[List[Short]] = {\n+        val option1 = ((h16 <* colon.void) ~ h16).map(t => List(t._1, t._2))\n+        option1.backtrack.orElse(parsedIpv4Bytes)\n+      }\n+\n+      val fullIpv6WihtOptionalIpv4 = (h16Colon.repExactlyAs[List[Short]](6) ~ ls32)\n+        .map { case (ls: List[Short], rs) => toIpv6(ls.toList, rs) }\n+\n+      val shortIpv6WithIpv4 = for {\n+        lefts <- h16.repSep0(0, 5, colon).with1 <* doubleColon\n+        rights <- rightsWithIpv4(4 - lefts.size)\n+      } yield toIpv6(lefts, rights)\n+\n+      val shortIpv6 = for {\n+        lefts <- h16.repSep0(0, 7, colon).with1 <* doubleColon\n+        rights <-\n+          if (6 - lefts.size > 0)(h16.repSep0(0, 6 - lefts.size, colon)) else P.pure(Nil)\n+      } yield toIpv6(lefts, rights)\n+\n+      fullIpv6WihtOptionalIpv4.backtrack.orElse(shortIpv6WithIpv4.backtrack).orElse(shortIpv6)\n+    }\n+\n+    private[http4s] val ipv4Address: P[Uri.Ipv4Address] =\n+      Rfc3986.ipv4Bytes.map { case (a, b, c, d) => Uri.Ipv4Address(a, b, c, d) }\n+\n+    /* host          = IP-literal / IPv4address / reg-name */\n+    private[http4s] val host: Parser0[Uri.Host] = {\n+      import cats.parse.Parser.char\n+\n+      // TODO This isn't in the 0.21 model.\n+      /* IPvFuture     = \"v\" 1*HEXDIG \".\" 1*( unreserved / sub-delims / \":\" ) */\n+      val ipVFuture: P[Nothing] = P.fail\n+\n+      /* IP-literal    = \"[\" ( IPv6address / IPvFuture  ) \"]\" */\n+      val ipLiteral = char('[') *> ipv6Address.orElse(ipVFuture) <* char(']')\n+\n+      ipLiteral.orElse(ipv4Address.backtrack).orElse(regName)\n+    }\n+\n+    /* userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" ) */\n+    private[http4s] def userinfo(cs: JCharset): Parser0[Uri.UserInfo] = {\n+      import cats.parse.Parser.{char, charIn, oneOf}\n+      import Rfc3986.{pctEncoded, subDelims, unreserved}\n+\n+      val username = oneOf(unreserved :: pctEncoded :: subDelims :: Nil).rep0.string\n+      val password = oneOf(unreserved :: pctEncoded :: subDelims :: charIn(':') :: Nil).rep0.string\n+      (username ~ (char(':') *> password).?).map { case (u, p) =>\n+        Uri.UserInfo(Uri.decode(u, cs), p.map(Uri.decode(_, cs)))\n+      }\n+    }\n+\n+    /* segment       = *pchar */\n+    private[http4s] val segment: Parser0[Uri.Path.Segment] =\n+      Rfc3986.pchar.rep0.string.map(Uri.Path.Segment.encoded)\n+\n+    /* segment-nz    = 1*pchar */\n+    private[http4s] val segmentNz: P[Uri.Path.Segment] =\n+      Rfc3986.pchar.rep.string.map(Uri.Path.Segment.encoded)\n+\n+    /* segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / \"@\" )\n+                   ; non-zero-length segment without any colon \":\" */\n+    private[http4s] val segmentNzNc: P[Uri.Path.Segment] =\n+      Rfc3986.unreserved\n+        .orElse(Rfc3986.pctEncoded)\n+        .orElse(Rfc3986.subDelims)\n+        .orElse(P.char('@'))\n+        .rep\n+        .string\n+        .map(Uri.Path.Segment.encoded(_))\n+\n+    import cats.parse.Parser.{char, pure}\n+\n+    /* path-abempty  = *( \"/\" segment ) */\n+    private[http4s] val pathAbempty: Parser0[Uri.Path] =\n+      (char('/') *> segment).rep0.map {\n+        case Nil => Uri.Path.empty\n+        case List(Uri.Path.Segment.empty) => Uri.Path.Root\n+        case segments =>\n+          val segmentsV = segments.toVector\n+          if (segmentsV.last.isEmpty)\n+            Uri.Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)\n+          else\n+            Uri.Path(segmentsV, absolute = true, endsWithSlash = false)\n+      }\n+\n+    /* path-absolute = \"/\" [ segment-nz *( \"/\" segment ) ] */\n+    private[http4s] val pathAbsolute: P[Uri.Path] =\n+      (char('/') *> (segmentNz ~ (char('/') *> segment).rep0).?).map {\n+        case Some((head, tail)) =>\n+          val segmentsV = head +: tail.toVector\n+          if (segmentsV.last.isEmpty)\n+            Uri.Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)\n+          else\n+            Uri.Path(segmentsV, absolute = true, endsWithSlash = false)\n+        case None =>\n+          Uri.Path.Root\n+      }\n+\n+    /* path-rootless = segment-nz *( \"/\" segment ) */\n+    private[http4s] val pathRootless: P[Uri.Path] =\n+      (segmentNz ~ (char('/') *> segment).rep0).map { case (head, tail) =>\n+        val segmentsV = head +: tail.toVector\n+        if (segmentsV.last.isEmpty)\n+          Uri.Path(segmentsV.dropRight(1), absolute = false, endsWithSlash = true)\n+        else\n+          Uri.Path(segmentsV, absolute = false, endsWithSlash = false)\n+      }\n+\n+    /* path-empty    = 0<pchar> */\n+    private[http4s] val pathEmpty: Parser0[Uri.Path] =\n+      pure(Uri.Path.empty)\n+\n+    /* path-noscheme = segment-nz-nc *( \"/\" segment ) */\n+    private[http4s] val pathNoscheme: P[Uri.Path] =\n+      (segmentNzNc ~ (char('/') *> segment).rep0).map { case (head, tail) =>\n+        val segmentsV = head +: tail.toVector\n+        if (segmentsV.last.isEmpty)\n+          Uri.Path(segmentsV.dropRight(1), absolute = false, endsWithSlash = true)\n+        else\n+          Uri.Path(segmentsV, absolute = false, endsWithSlash = false)\n+      }\n+\n+    /* absolute-path = 1*( \"/\" segment ) */\n+    private[http4s] val absolutePath: P[Uri.Path] =\n+      (char('/') *> segment).rep.map {\n+        case NonEmptyList(Uri.Path.Segment.empty, Nil) => Uri.Path.Root\n+        case segments =>\n+          val segmentsV = segments.toList.toVector\n+          if (segmentsV.last.isEmpty)\n+            Uri.Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)\n+          else\n+            Uri.Path(segmentsV, absolute = true, endsWithSlash = false)\n+      }\n+\n+    /* authority   = [ userinfo \"@\" ] host [ \":\" port ] */\n+    private[http4s] def authority(cs: JCharset): Parser0[Uri.Authority] =\n+      ((userinfo(cs) <* char('@')).backtrack.? ~ host ~ (char(':') *> port).?).map {\n+        case ((ui, h), p) => Uri.Authority(userInfo = ui, host = h, port = p.flatten)\n+      }\n+\n+    /* fragment    = *( pchar / \"/\" / \"?\" )\n+     *\n+     * Not URL decoded.\n+     */\n+    private[http4s] val fragment: Parser0[Uri.Fragment] =\n+      Rfc3986.pchar.orElse(P.charIn(\"/?\")).rep0.string\n+\n+    /* scheme      = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" ) */\n+    private[http4s] val scheme: P[Uri.Scheme] = {\n+      import cats.parse.Parser.{charIn, not, string}\n+      import Rfc3986.{alpha, digit}\n+\n+      val unary = alpha.orElse(digit).orElse(charIn(\"+-.\"))\n+\n+      (string(\"https\") <* not(unary))\n+        .as(Uri.Scheme.https)\n+        .backtrack\n+        .orElse((string(\"http\") <* not(unary)).as(Uri.Scheme.http))\n+        .backtrack\n+        .orElse((alpha *> unary.rep0).string.map(new Uri.Scheme(_)))\n+    }\n+\n+    /* request-target = origin-form\n+                      / absolute-form\n+                      / authority-form\n+                      / asterisk-form\n+     */\n+    private[http4s] val requestTargetParser: Parser0[Uri] = {\n+      import cats.parse.Parser.{char, oneOf0}\n+      import Query.{parser => query}\n+\n+      /* origin-form    = absolute-path [ \"?\" query ] */\n+      val originForm: P[Uri] =\n+        (absolutePath ~ (char('?') *> query).?).map { case (p, q) =>\n+          Uri(scheme = None, authority = None, path = p, query = q.getOrElse(Query.empty))\n+        }\n+\n+      /* absolute-form = absolute-URI */\n+      def absoluteForm: P[Uri] = absoluteUri(StandardCharsets.UTF_8)\n+\n+      /* authority-form = authority */\n+      val authorityForm: Parser0[Uri] =\n+        authority(StandardCharsets.UTF_8).map(a => Uri(authority = Some(a)))\n+\n+      /* asterisk-form = \"*\" */\n+      val asteriskForm: P[Uri] =\n+        char('*').as(Uri(path = Uri.Path.Asterisk))\n+\n+      oneOf0(originForm :: absoluteForm :: authorityForm :: asteriskForm :: Nil)\n+    }\n+\n+    /* hier-part   = \"//\" authority path-abempty\n+     *             / path-absolute\n+     *             / path-rootless\n+     *             / path-empty\n+     */\n+    def hierPart(cs: JCharset): Parser0[(Option[Uri.Authority], Uri.Path)] = {\n+      import P.string\n+      val rel: P[(Option[Uri.Authority], Uri.Path)] =\n+        (string(\"//\") *> authority(cs) ~ pathAbempty).map { case (a, p) =>\n+          (Some(a), p)\n+        }\n+      P.oneOf0(\n+        rel :: pathAbsolute.map((None, _)) :: pathRootless.map((None, _)) :: pathEmpty.map(\n+          (None, _)) :: Nil)\n+    }\n+\n+    /* absolute-URI  = scheme \":\" hier-part [ \"?\" query ] */\n+    private[http4s] def absoluteUri(cs: JCharset): P[Uri] = {\n+      import cats.parse.Parser.char\n+      import Query.{parser => query}\n+\n+      (scheme ~ (char(':') *> hierPart(cs)) ~ (char('?') *> query).?).map { case ((s, (a, p)), q) =>\n+        Uri(scheme = Some(s), authority = a, path = p, query = q.getOrElse(Query.empty))\n+      }\n+    }\n+\n+    private[http4s] def uri(cs: JCharset): P[Uri] = {\n+      import cats.parse.Parser.char\n+      import Query.{parser => query}\n+\n+      (scheme ~ (char(':') *> hierPart(cs)) ~ (char('?') *> query).? ~ (char('#') *> fragment).?)\n+        .map { case (((s, (a, p)), q), f) =>\n+          Uri(\n+            scheme = Some(s),\n+            authority = a,\n+            path = p,\n+            query = q.getOrElse(Query.empty),\n+            fragment = f)\n+        }\n+    }\n+\n+    /* relative-part = \"//\" authority path-abempty\n+                     / path-absolute\n+                     / path-noscheme\n+                     / path-empty\n+     */\n+    private[http4s] def relativePart(cs: JCharset): Parser0[(Option[Uri.Authority], Uri.Path)] = {\n+      import cats.parse.Parser.string\n+\n+      P.oneOf0(\n+        ((string(\"//\") *> authority(cs) ~ pathAbempty).map { case (a, p) =>\n+          (Some(a), p)\n+        }) :: (pathAbsolute.map((None, _))) :: (pathNoscheme.map((None, _))) :: (pathEmpty.map(\n+          (None, _))) :: Nil)\n+    }\n+\n+    /* relative-ref  = relative-part [ \"?\" query ] [ \"#\" fragment ] */\n+    private[http4s] def relativeRef(cs: JCharset): Parser0[Uri] = {\n+      import cats.parse.Parser.char\n+      import Query.{parser => query}\n+\n+      (relativePart(cs) ~ (char('?') *> query).? ~ (char('#') *> fragment).?).map {\n+        case (((a, p), q), f) =>\n+          Uri(\n+            scheme = None,\n+            authority = a,\n+            path = p,\n+            query = q.getOrElse(Query.empty),\n+            fragment = f)\n+      }\n+    }\n+\n+    private[http4s] val uriReferenceUtf8: Parser0[Uri] = uriReference(StandardCharsets.UTF_8)\n+    private[http4s] def uriReference(cs: JCharset): Parser0[Uri] =\n+      uri(cs).backtrack.orElse(relativeRef(cs))\n+  }\n }"
        },
        {
          "filename": "core/src/main/scala/org/http4s/headers/Content-Location.scala",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -23,9 +23,9 @@ import java.nio.charset.StandardCharsets\n object `Content-Location` extends HeaderKey.Internal[`Content-Location`] with HeaderKey.Singleton {\n   override def parse(s: String): ParseResult[`Content-Location`] =\n     ParseResult.fromParser(parser, \"Invalid Content-Location\")(s)\n-  private[http4s] val parser = Uri\n+  private[http4s] val parser = Uri.Parser\n     .absoluteUri(StandardCharsets.ISO_8859_1)\n-    .orElse(Uri.relativeRef(StandardCharsets.ISO_8859_1))\n+    .orElse(Uri.Parser.relativeRef(StandardCharsets.ISO_8859_1))\n     .map(`Content-Location`(_))\n }\n "
        },
        {
          "filename": "core/src/main/scala/org/http4s/headers/Forwarded.scala",
          "status": "modified",
          "additions": 4,
          "deletions": 5,
          "patch": "@@ -22,7 +22,6 @@ import cats.syntax.either._\n import org.http4s._\n import org.http4s.util.{Renderable, Writer}\n import cats.parse.{Numbers, Parser0, Rfc5234, Parser => P}\n-import org.http4s.Uri.{Ipv4Address, Ipv6Address}\n import org.http4s.internal.parsing.Rfc7230\n \n import java.util.Locale\n@@ -122,8 +121,8 @@ object Forwarded\n       val nodeName: P[Node.Name] =\n         P.oneOf[Node.Name](\n           List(\n-            Ipv4Address.parser.map(Node.Name.Ipv4),\n-            Ipv6Address.parser\n+            Uri.Parser.ipv4Address.map(Node.Name.Ipv4),\n+            Uri.Parser.ipv6Address\n               .between(P.char('['), P.char(']'))\n               .map(Node.Name.Ipv6),\n             P.string(\"unknown\").as(Node.Name.Unknown),\n@@ -193,7 +192,7 @@ object Forwarded\n \n       // ** RFC3986 **\n       // port = *DIGIT\n-      (Uri.Host.parser ~ (P.char(':') *> port).?)\n+      (Uri.Parser.host ~ (P.char(':') *> port).?)\n         .map { case (h, p) => apply(h, p.flatten) }\n     }\n   }\n@@ -308,7 +307,7 @@ object Forwarded\n     // [RFC3986]\n \n     val host = Host.parser\n-    val proto = Uri.Scheme.parser\n+    val proto = Uri.Parser.scheme\n     val node = Node.parser\n \n     val forwardedPair = P.oneOf("
        },
        {
          "filename": "core/src/main/scala/org/http4s/headers/Host.scala",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -29,12 +29,11 @@ object Host extends HeaderKey.Internal[Host] with HeaderKey.Singleton {\n     ParseResult.fromParser(parser, \"Invalid Host\")(s)\n \n   private[http4s] val parser = {\n-    import Uri.Host.{parser => host}\n     val port = Parser.string(\":\") *> Rfc3986.digit.rep.string.mapFilter { s =>\n       Try(s.toInt).toOption\n     }\n \n-    (host ~ port.?).map { case (host, port) =>\n+    (Uri.Parser.host ~ port.?).map { case (host, port) =>\n       Host(host.value, port)\n     }\n   }"
        },
        {
          "filename": "core/src/main/scala/org/http4s/headers/Link.scala",
          "status": "modified",
          "additions": 2,
          "deletions": 4,
          "patch": "@@ -38,12 +38,10 @@ object Link extends HeaderKey.Internal[Link] with HeaderKey.Recurring {\n     final case class Type(value: MediaRange) extends LinkParam\n \n     // https://tools.ietf.org/html/rfc3986#section-4.1\n-    val linkValue: Parser0[LinkValue] = {\n-      import Uri._\n-      uriReference(StandardCharsets.UTF_8).map { uri =>\n+    val linkValue: Parser0[LinkValue] =\n+      Uri.Parser.uriReference(StandardCharsets.UTF_8).map { uri =>\n         headers.LinkValue(uri)\n       }\n-    }\n \n     val linkParam: Parser0[LinkParam] = {\n       val relParser = (string(\"rel=\") *> token.orElse(quotedString))"
        },
        {
          "filename": "core/src/main/scala/org/http4s/headers/Location.scala",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -23,9 +23,9 @@ import java.nio.charset.StandardCharsets\n object Location extends HeaderKey.Internal[Location] with HeaderKey.Singleton {\n   override def parse(s: String): ParseResult[Location] =\n     ParseResult.fromParser(parser, \"Invalid Location\")(s)\n-  private[http4s] val parser = Uri\n+  private[http4s] val parser = Uri.Parser\n     .absoluteUri(StandardCharsets.ISO_8859_1)\n-    .orElse(Uri.relativeRef(StandardCharsets.ISO_8859_1))\n+    .orElse(Uri.Parser.relativeRef(StandardCharsets.ISO_8859_1))\n     .map(Location(_))\n }\n "
        },
        {
          "filename": "core/src/main/scala/org/http4s/headers/Origin.scala",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -75,8 +75,8 @@ object Origin extends HeaderKey.Internal[Origin] with HeaderKey.Singleton {\n       .string\n       .map(Uri.Scheme.unsafeFromString)\n     val stringHost = until(char(':').orElse(`end`)).map(RegName.apply)\n-    val bracketedIpv6 = char('[') *> Uri.Ipv6Address.parser <* char(']')\n-    val host = List(bracketedIpv6, Uri.Ipv4Address.parser, stringHost).reduceLeft(_ orElse _)\n+    val bracketedIpv6 = char('[') *> Uri.Parser.ipv6Address <* char(']')\n+    val host = List(bracketedIpv6, Uri.Parser.ipv4Address, stringHost).reduceLeft(_ orElse _)\n     val port = char(':') *> digit.rep.string.map(_.toInt)\n     val nullHost = (string(\"null\") *> `end`).orElse(`end`).as(Origin.Null)\n "
        },
        {
          "filename": "core/src/main/scala/org/http4s/headers/Referer.scala",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -23,9 +23,9 @@ import java.nio.charset.StandardCharsets\n object Referer extends HeaderKey.Internal[Referer] with HeaderKey.Singleton {\n   override def parse(s: String): ParseResult[Referer] =\n     ParseResult.fromParser(parser, \"Invalid Referer\")(s)\n-  private[http4s] val parser = Uri\n+  private[http4s] val parser = Uri.Parser\n     .absoluteUri(StandardCharsets.ISO_8859_1)\n-    .orElse(Uri.relativeRef(StandardCharsets.ISO_8859_1))\n+    .orElse(Uri.Parser.relativeRef(StandardCharsets.ISO_8859_1))\n     .map(Referer(_))\n }\n "
        },
        {
          "filename": "core/src/main/scala/org/http4s/headers/X-Forwarded-For.scala",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -29,7 +29,7 @@ object `X-Forwarded-For` extends HeaderKey.Internal[`X-Forwarded-For`] with Head\n   private[http4s] val parser: Parser[`X-Forwarded-For`] =\n     Rfc7230\n       .headerRep1(\n-        (Uri.Ipv4Address.parser.map(_.toInet4Address).backtrack | Uri.Ipv6Address.parser.map(\n+        (Uri.Parser.ipv4Address.map(_.toInet4Address).backtrack | Uri.Parser.ipv6Address.map(\n           _.toInet6Address)).map(s => Some(s)) | (Parser.string(\"unknown\").as(None)))\n       .map(`X-Forwarded-For`.apply)\n }"
        },
        {
          "filename": "ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala",
          "status": "modified",
          "additions": 42,
          "deletions": 30,
          "patch": "@@ -22,14 +22,15 @@ import cats.effect._\n import scala.concurrent.duration._\n import org.http4s.ProductId\n import org.http4s.client._\n-import org.http4s.headers.{Connection, `User-Agent`}\n import org.typelevel.keypool._\n import org.typelevel.log4cats.Logger\n import org.typelevel.log4cats.slf4j.Slf4jLogger\n import fs2.io.tcp.SocketGroup\n import fs2.io.tcp.SocketOptionMapping\n import fs2.io.tls._\n import scala.concurrent.duration.Duration\n+import org.http4s.headers.{Connection, `User-Agent`}\n+import org.http4s.ember.client.internal.ClientHelpers\n \n final class EmberClientBuilder[F[_]: Async] private (\n     private val tlsContextOpt: Option[TLSContext],\n@@ -40,6 +41,7 @@ final class EmberClientBuilder[F[_]: Async] private (\n     private val logger: Logger[F],\n     val chunkSize: Int,\n     val maxResponseHeaderSize: Int,\n+    private val idleConnectionTime: Duration,\n     val timeout: Duration,\n     val additionalSocketOptions: List[SocketOptionMapping[_]],\n     val userAgent: Option[`User-Agent`]\n@@ -54,6 +56,7 @@ final class EmberClientBuilder[F[_]: Async] private (\n       logger: Logger[F] = self.logger,\n       chunkSize: Int = self.chunkSize,\n       maxResponseHeaderSize: Int = self.maxResponseHeaderSize,\n+      idleConnectionTime: Duration = self.idleConnectionTime,\n       timeout: Duration = self.timeout,\n       additionalSocketOptions: List[SocketOptionMapping[_]] = self.additionalSocketOptions,\n       userAgent: Option[`User-Agent`] = self.userAgent\n@@ -67,6 +70,7 @@ final class EmberClientBuilder[F[_]: Async] private (\n       logger = logger,\n       chunkSize = chunkSize,\n       maxResponseHeaderSize = maxResponseHeaderSize,\n+      idleConnectionTime = idleConnectionTime,\n       timeout = timeout,\n       additionalSocketOptions = additionalSocketOptions,\n       userAgent = userAgent\n@@ -81,11 +85,14 @@ final class EmberClientBuilder[F[_]: Async] private (\n   def withMaxTotal(maxTotal: Int) = copy(maxTotal = maxTotal)\n   def withMaxPerKey(maxPerKey: RequestKey => Int) = copy(maxPerKey = maxPerKey)\n   def withIdleTimeInPool(idleTimeInPool: Duration) = copy(idleTimeInPool = idleTimeInPool)\n+  def withIdleConnectionTime(idleConnectionTime: Duration) =\n+    copy(idleConnectionTime = idleConnectionTime)\n \n   def withLogger(logger: Logger[F]) = copy(logger = logger)\n   def withChunkSize(chunkSize: Int) = copy(chunkSize = chunkSize)\n   def withMaxResponseHeaderSize(maxResponseHeaderSize: Int) =\n     copy(maxResponseHeaderSize = maxResponseHeaderSize)\n+\n   def withTimeout(timeout: Duration) = copy(timeout = timeout)\n   def withAdditionalSocketOptions(additionalSocketOptions: List[SocketOptionMapping[_]]) =\n     copy(additionalSocketOptions = additionalSocketOptions)\n@@ -122,7 +129,7 @@ final class EmberClientBuilder[F[_]: Async] private (\n                 socket.endOfInput.attempt.void >>\n                 socket.endOfOutput.attempt.void >>\n                 socket.close.attempt.void >>\n-                shutdown\n+                shutdown.attempt.void\n             }\n           )\n           .withDefaultReuseState(Reusable.DontReuse)\n@@ -132,9 +139,9 @@ final class EmberClientBuilder[F[_]: Async] private (\n           .withOnReaperException(_ => Applicative[F].unit)\n       pool <- builder.build\n     } yield {\n-      val client = Client[F](request =>\n+      val client = Client[F] { request =>\n         for {\n-          managed <- pool.take(RequestKey.fromRequest(request))\n+          managed <- ClientHelpers.getValidManaged(pool, request)\n           _ <- Resource.eval(\n             pool.state.flatMap { poolState =>\n               logger.trace(\n@@ -143,31 +150,34 @@ final class EmberClientBuilder[F[_]: Async] private (\n             }\n           )\n           responseResource <-\n-            org.http4s.ember.client.internal.ClientHelpers\n-              .request[F](\n-                request,\n-                managed.value._1,\n-                managed.canBeReused,\n-                chunkSize,\n-                maxResponseHeaderSize,\n-                timeout,\n-                userAgent\n-              )\n-              .map(response =>\n-                // TODO If Response Body has a take(1).compile.drain - would leave rest of bytes in root stream for next caller\n-                response.copy(body = response.body.onFinalizeCaseWeak {\n-                  case Resource.ExitCase.Succeeded =>\n-                    val requestClose = request.headers.get(Connection).exists(_.hasClose)\n-                    val responseClose = response.isChunked || response.headers\n-                      .get(Connection)\n-                      .exists(_.hasClose)\n-\n-                    if (requestClose || responseClose) Sync[F].unit\n-                    else managed.canBeReused.set(Reusable.Reuse)\n-                  case Resource.ExitCase.Canceled => Sync[F].unit\n-                  case Resource.ExitCase.Errored(_) => Sync[F].unit\n-                }))\n-        } yield responseResource)\n+            Resource.eval(\n+              ClientHelpers\n+                .request[F](\n+                  request,\n+                  managed.value._1,\n+                  managed.canBeReused,\n+                  chunkSize,\n+                  maxResponseHeaderSize,\n+                  idleConnectionTime,\n+                  timeout,\n+                  userAgent\n+                )\n+                .map(response =>\n+                  // TODO If Response Body has a take(1).compile.drain - would leave rest of bytes in root stream for next caller\n+                  response.copy(body = response.body.onFinalizeCaseWeak {\n+                    case Resource.ExitCase.Succeeded =>\n+                      val requestClose = request.headers.get(Connection).exists(_.hasClose)\n+                      val responseClose = response.isChunked || response.headers\n+                        .get(Connection)\n+                        .exists(_.hasClose)\n+\n+                      if (requestClose || responseClose) Sync[F].unit\n+                      else managed.canBeReused.set(Reusable.Reuse)\n+                    case Resource.ExitCase.Canceled => Sync[F].unit\n+                    case Resource.ExitCase.Errored(_) => Sync[F].unit\n+                  })))\n+        } yield responseResource\n+      }\n       new EmberClient[F](client, pool)\n     }\n }\n@@ -184,6 +194,7 @@ object EmberClientBuilder {\n       logger = Slf4jLogger.getLogger[F],\n       chunkSize = Defaults.chunkSize,\n       maxResponseHeaderSize = Defaults.maxResponseHeaderSize,\n+      idleConnectionTime = Defaults.idleConnectionTime,\n       timeout = Defaults.timeout,\n       additionalSocketOptions = Defaults.additionalSocketOptions,\n       userAgent = Defaults.userAgent\n@@ -193,7 +204,8 @@ object EmberClientBuilder {\n     val acgFixedThreadPoolSize: Int = 100\n     val chunkSize: Int = 32 * 1024\n     val maxResponseHeaderSize: Int = 4096\n-    val timeout: Duration = 60.seconds\n+    val idleConnectionTime = org.http4s.client.defaults.RequestTimeout\n+    val timeout: Duration = org.http4s.client.defaults.RequestTimeout\n \n     // Pool Settings\n     val maxPerKey = { (_: RequestKey) =>"
        },
        {
          "filename": "ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala",
          "status": "modified",
          "additions": 37,
          "deletions": 38,
          "patch": "@@ -17,7 +17,6 @@\n package org.http4s.ember.client.internal\n \n import org.http4s.ember.client._\n-import fs2.concurrent._\n import fs2.io.tcp._\n import fs2.io.Network\n import cats._\n@@ -31,12 +30,12 @@ import org.http4s._\n import org.http4s.client.RequestKey\n import org.typelevel.ci.CIString\n import _root_.org.http4s.ember.core.{Encoder, Parser}\n-import _root_.org.http4s.ember.core.Util.readWithTimeout\n import _root_.fs2.io.tcp.SocketGroup\n import _root_.fs2.io.tls._\n-import org.typelevel.keypool.Reusable\n+import org.typelevel.keypool._\n import javax.net.ssl.SNIHostName\n import org.http4s.headers.{Connection, Date, `User-Agent`}\n+import _root_.org.http4s.ember.core.Util.durationToFinite\n \n private[client] object ClientHelpers {\n   def requestToSocketWithKey[F[_]: Sync: Network](\n@@ -86,55 +85,34 @@ private[client] object ClientHelpers {\n       reuseable: Ref[F, Reusable],\n       chunkSize: Int,\n       maxResponseHeaderSize: Int,\n+      idleTimeout: Duration,\n       timeout: Duration,\n       userAgent: Option[`User-Agent`]\n-  ): Resource[F, Response[F]] = {\n-    def realtime: Resource[F, FiniteDuration] = Resource.liftK[F](Sync[F].realTime)\n+  ): F[Response[F]] = {\n \n     def writeRequestToSocket(\n         req: Request[F],\n         socket: Socket[F],\n-        timeout: Option[FiniteDuration]): Resource[F, Unit] =\n+        timeout: Option[FiniteDuration]): F[Unit] =\n       Encoder\n         .reqToBytes(req)\n         .through(socket.writes(timeout))\n         .compile\n-        .resource\n         .drain\n \n-    def onNoTimeout(req: Request[F], socket: Socket[F]): Resource[F, Response[F]] =\n-      writeRequestToSocket(req, socket, None) >>\n-        Parser.Response.parser(maxResponseHeaderSize)(\n-          socket.reads(chunkSize, None)\n-        )\n-\n-    def onTimeout(\n-        req: Request[F],\n-        socket: Socket[F],\n-        fin: FiniteDuration): Resource[F, Response[F]] =\n-      for {\n-        start <- realtime\n-        _ <- writeRequestToSocket(req, socket, Option(fin))\n-        timeoutSignal <- Resource.eval(SignallingRef[F, Boolean](true))\n-        sent <- realtime\n-        remains = fin - (sent - start)\n-        resp <- Parser.Response.parser[F](maxResponseHeaderSize)(\n-          readWithTimeout(socket, start.toMillis, remains, timeoutSignal.get, chunkSize)\n-        )\n-        _ <- Resource.eval(timeoutSignal.set(false).void)\n-      } yield resp\n-\n-    def writeRead(req: Request[F]) =\n-      timeout match {\n-        case t: FiniteDuration => onTimeout(req, requestKeySocket.socket, t)\n-        case _ => onNoTimeout(req, requestKeySocket.socket)\n+    def writeRead(req: Request[F]): F[Response[F]] =\n+      writeRequestToSocket(req, requestKeySocket.socket, durationToFinite(idleTimeout)) >> {\n+        Parser.Response\n+          .parser(maxResponseHeaderSize, durationToFinite(timeout))(\n+            requestKeySocket.socket.reads(chunkSize, durationToFinite(idleTimeout))\n+          )\n+          .map(_._1)\n       }\n \n     for {\n-      processedReq <- Resource.eval(preprocessRequest(request, userAgent))\n+      processedReq <- preprocessRequest(request, userAgent)\n       resp <- writeRead(processedReq)\n-      processedResp <- postProcessResponse(processedReq, resp, reuseable)\n-    } yield processedResp\n+    } yield postProcessResponse(processedReq, resp, reuseable)\n   }\n \n   private[internal] def preprocessRequest[F[_]: Monad: Clock](\n@@ -154,7 +132,7 @@ private[client] object ClientHelpers {\n   private[internal] def postProcessResponse[F[_]: Concurrent](\n       req: Request[F],\n       resp: Response[F],\n-      canBeReused: Ref[F, Reusable]): Resource[F, Response[F]] = {\n+      canBeReused: Ref[F, Reusable]): Response[F] = {\n     val out = resp.copy(\n       body = resp.body.onFinalizeCaseWeak {\n         case Resource.ExitCase.Succeeded =>\n@@ -167,7 +145,7 @@ private[client] object ClientHelpers {\n         case Resource.ExitCase.Errored(_) => Applicative[F].unit\n       }\n     )\n-    Resource.pure[F, Response[F]](out)\n+    out\n   }\n \n   // https://github.com/http4s/http4s/blob/main/blaze-client/src/main/scala/org/http4s/client/blaze/Http1Support.scala#L86\n@@ -178,4 +156,25 @@ private[client] object ClientHelpers {\n         val host = auth.host.value\n         Sync[F].delay(new InetSocketAddress(host, port))\n     }\n+\n+  // Assumes that the request doesn't have fancy finalizers besides shutting down the pool\n+  private[client] def getValidManaged[F[_]: Sync](\n+      pool: KeyPool[F, RequestKey, (RequestKeySocket[F], F[Unit])],\n+      request: Request[F]): Resource[F, Managed[F, (RequestKeySocket[F], F[Unit])]] =\n+    pool.take(RequestKey.fromRequest(request)).flatMap { managed =>\n+      Resource\n+        .eval(managed.value._1.socket.isOpen)\n+        .ifM(\n+          managed.pure[Resource[F, *]],\n+          // Already Closed,\n+          // The Resource Scopes Aren't doing us anything\n+          // if we have max removed from pool we will need to revisit\n+          if (managed.isReused) {\n+            Resource.eval(managed.canBeReused.set(Reusable.DontReuse)) >>\n+              getValidManaged(pool, request)\n+          } else\n+            Resource.eval(Sync[F].raiseError(\n+              new java.net.SocketException(\"Fresh connection from pool was not open\")))\n+        )\n+    }\n }"
        },
        {
          "filename": "ember-client/src/test/scala/org/http4s/ember/client/internal/ClientHelpersSpec.scala",
          "status": "modified",
          "additions": 26,
          "deletions": 30,
          "patch": "@@ -101,18 +101,17 @@ class ClientHelpersSpec extends Http4sSpec with CatsEffect {\n       for {\n         reuse <- Ref[IO].of(Reusable.DontReuse: Reusable)\n \n-        testResult <-\n+        resp =\n           ClientHelpers\n             .postProcessResponse(\n               Request[IO](),\n               Response[IO](),\n               reuse\n             )\n-            .use { resp =>\n-              resp.body.compile.drain >>\n-                reuse.get.map { case r =>\n-                  r must beEqualTo(Reusable.Reuse)\n-                }\n+        testResult <-\n+          resp.body.compile.drain >>\n+            reuse.get.map { case r =>\n+              r must beEqualTo(Reusable.Reuse)\n             }\n       } yield testResult\n     }\n@@ -121,37 +120,36 @@ class ClientHelpersSpec extends Http4sSpec with CatsEffect {\n       for {\n         reuse <- Ref[IO].of(Reusable.DontReuse: Reusable)\n \n-        testResult <-\n+        _ =\n           ClientHelpers\n             .postProcessResponse(\n               Request[IO](),\n               Response[IO](),\n               reuse\n             )\n-            .use { _ =>\n-              reuse.get.map { case r =>\n-                r must beEqualTo(Reusable.DontReuse)\n-              }\n-            }\n+\n+        testResult <-\n+          reuse.get.map { case r =>\n+            r must beEqualTo(Reusable.DontReuse)\n+          }\n       } yield testResult\n     }\n \n     \"do not reuse when error encountered running stream\" in {\n       for {\n         reuse <- Ref[IO].of(Reusable.DontReuse: Reusable)\n \n-        testResult <-\n+        resp =\n           ClientHelpers\n             .postProcessResponse(\n               Request[IO](),\n               Response[IO](body = fs2.Stream.raiseError[IO](new Throwable(\"Boo!\"))),\n               reuse\n             )\n-            .use { resp =>\n-              resp.body.compile.drain.attempt >>\n-                reuse.get.map { case r =>\n-                  r must beEqualTo(Reusable.DontReuse)\n-                }\n+        testResult <-\n+          resp.body.compile.drain.attempt >>\n+            reuse.get.map { case r =>\n+              r must beEqualTo(Reusable.DontReuse)\n             }\n       } yield testResult\n     }\n@@ -186,18 +184,17 @@ class ClientHelpersSpec extends Http4sSpec with CatsEffect {\n       for {\n         reuse <- Ref[IO].of(Reusable.DontReuse: Reusable)\n \n-        testResult <-\n+        resp =\n           ClientHelpers\n             .postProcessResponse(\n               Request[IO](headers = Headers.of(Connection(NonEmptyList.of(CIString(\"close\"))))),\n               Response[IO](),\n               reuse\n             )\n-            .use { resp =>\n-              resp.body.compile.drain >>\n-                reuse.get.map { case r =>\n-                  r must beEqualTo(Reusable.DontReuse)\n-                }\n+        testResult <-\n+          resp.body.compile.drain >>\n+            reuse.get.map { case r =>\n+              r must beEqualTo(Reusable.DontReuse)\n             }\n       } yield testResult\n     }\n@@ -206,18 +203,17 @@ class ClientHelpersSpec extends Http4sSpec with CatsEffect {\n       for {\n         reuse <- Ref[IO].of(Reusable.DontReuse: Reusable)\n \n-        testResult <-\n+        resp =\n           ClientHelpers\n             .postProcessResponse(\n               Request[IO](),\n               Response[IO](headers = Headers.of(Connection(NonEmptyList.of(CIString(\"close\"))))),\n               reuse\n             )\n-            .use { resp =>\n-              resp.body.compile.drain >>\n-                reuse.get.map { case r =>\n-                  r must beEqualTo(Reusable.DontReuse)\n-                }\n+        testResult <-\n+          resp.body.compile.drain >>\n+            reuse.get.map { case r =>\n+              r must beEqualTo(Reusable.DontReuse)\n             }\n       } yield testResult\n     }"
        },
        {
          "filename": "ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -29,6 +29,7 @@ private[ember] object Encoder {\n \n   def respToBytes[F[_]](resp: Response[F], writeBufferSize: Int = 32 * 1024): Stream[F, Byte] = {\n     var chunked = resp.isChunked\n+    // resp.status.isEntityAllowed TODO\n     val initSection = {\n       var appliedContentLength = false\n       val stringBuilder = new StringBuilder()\n@@ -68,6 +69,9 @@ private[ember] object Encoder {\n         .flatMap(Stream.chunk)\n   }\n \n+  private val NoPayloadMethods: Set[Method] =\n+    Set(Method.GET, Method.DELETE, Method.CONNECT, Method.TRACE)\n+\n   def reqToBytes[F[_]](req: Request[F], writeBufferSize: Int = 32 * 1024): Stream[F, Byte] = {\n     var chunked = req.isChunked\n     val initSection = {\n@@ -103,7 +107,7 @@ private[ember] object Encoder {\n         ()\n       }\n \n-      if (!chunked && !appliedContentLength) {\n+      if (!chunked && !appliedContentLength && !NoPayloadMethods.contains(req.method)) {\n         stringBuilder.append(chunkedTansferEncodingHeaderRaw).append(CRLF)\n         chunked = true\n         ()"
        },
        {
          "filename": "ember-core/src/main/scala/org/http4s/ember/core/Parser.scala",
          "status": "modified",
          "additions": 68,
          "deletions": 37,
          "patch": "@@ -24,6 +24,7 @@ import fs2._\n import org.http4s._\n import scala.annotation.switch\n import scala.collection.mutable\n+import scala.concurrent.duration.FiniteDuration\n \n private[ember] object Parser {\n \n@@ -192,6 +193,8 @@ private[ember] object Parser {\n \n     object ReqPrelude {\n \n+      val emptyStreamError = ParsePreludeError(\"Cannot Parse Empty Stream\", None, None, None, None)\n+\n       def parsePrelude[F[_]: MonadThrow](\n           s: Stream[F, Byte],\n           maxHeaderLength: Int,\n@@ -205,26 +208,34 @@ private[ember] object Parser {\n             }\n             ReqPrelude.preludeInSection(next) match {\n               case ParsePreludeComplete(m, u, h, rest) =>\n-                Pull.pure((m, u, h, Stream.chunk(Chunk.array(rest)) ++ tl))\n-              case t @ ParsePreludeError(_, _, _, _) => Pull.raiseError[F](t)\n+                val out = if (rest.isEmpty) tl else Stream.chunk(Chunk.array(rest)) ++ tl\n+                Pull.pure((m, u, h, out))\n+              case t @ ParsePreludeError(_, _, _, _, _) => Pull.raiseError[F](t)\n               case p @ ParsePreludeIncomlete(_, _, method, uri, httpVersion) =>\n                 if (next.size <= maxHeaderLength)\n                   parsePrelude(tl, maxHeaderLength, p.some)\n                 else\n                   Pull.raiseError[F](\n                     ParsePreludeError(\n-                      new Throwable(\"Reached Max Header Length Looking for Request Prelude\"),\n+                      \"Reached Max Header Length Looking for Request Prelude\",\n+                      None,\n                       method,\n                       uri,\n                       httpVersion))\n             }\n           case None =>\n-            Pull.raiseError[F](\n-              ParsePreludeError(\n-                new Throwable(\"Reached Ended of Stream Looking for Request Prelude\"),\n-                acc.flatMap(_.method),\n-                acc.flatMap(_.uri),\n-                acc.flatMap(_.httpVersion)))\n+            acc match {\n+              case None => Pull.raiseError(emptyStreamError)\n+              case Some(incomplete) if incomplete.bv.isEmpty => Pull.raiseError(emptyStreamError)\n+              case Some(incomplete) =>\n+                Pull.raiseError(\n+                  ParsePreludeError(\n+                    s\"Unexpected EOF - $incomplete\",\n+                    None,\n+                    incomplete.method,\n+                    incomplete.uri,\n+                    incomplete.httpVersion))\n+            }\n         }\n \n       // sealed trait ParsePreludeState\n@@ -236,14 +247,16 @@ private[ember] object Parser {\n       private val lf: Byte = '\\n'.toByte\n \n       sealed trait ParsePreludeResult\n-      final case class ParsePreludeError(\n-          throwable: Throwable,\n+      case class ParsePreludeError(\n+          message: String,\n+          caused: Option[Throwable],\n           method: Option[Method],\n           uri: Option[Uri],\n           httpVersion: Option[HttpVersion]\n-      ) extends Throwable(\n-            s\"Parse Prelude Error Encountered - Partially Decoded: $method $uri $httpVersion\",\n-            throwable)\n+      ) extends Exception(\n+            s\"Parse Prelude Error Encountered - Message: $message - Partially Decoded: $method $uri $httpVersion\",\n+            caused.orNull\n+          )\n           with ParsePreludeResult\n       final case class ParsePreludeIncomlete(\n           idx: Int,\n@@ -322,7 +335,8 @@ private[ember] object Parser {\n \n         if (throwable != null)\n           ParsePreludeError(\n-            throwable,\n+            throwable.getMessage(),\n+            Option(throwable),\n             Option(method),\n             Option(uri),\n             Option(httpVersion)\n@@ -334,9 +348,10 @@ private[ember] object Parser {\n       }\n     }\n \n-    def parser[F[_]: Concurrent](maxHeaderLength: Int)(s: Stream[F, Byte]): F[Request[F]] =\n+    def parser[F[_]: Concurrent: Temporal](maxHeaderLength: Int, timeout: Option[FiniteDuration])(\n+        s: Stream[F, Byte]): F[(Request[F], Stream[F, Byte])] =\n       Deferred[F, Headers].flatMap { trailers =>\n-        ReqPrelude\n+        val baseStream = ReqPrelude\n           .parsePrelude[F](s, maxHeaderLength, None)\n           .flatMap { case (method, uri, httpVersion, rest) =>\n             HeaderP.parseHeaders(rest, maxHeaderLength, None).flatMap {\n@@ -356,22 +371,25 @@ private[ember] object Parser {\n                   else\n                     baseReq.withBodyStream(rest.take(contentLength.getOrElse(0L)))\n \n-                Pull.output1(req)\n+                Pull.output1((req, rest))\n             }\n           }\n           .stream\n           .take(1)\n-          .compile\n-          .lastOrError\n-      }\n \n+        val action = baseStream.compile.lastOrError\n+        timeout match {\n+          case None => action\n+          case Some(timeout) => Temporal[F].timeout(action, timeout)\n+        }\n+      }\n   }\n \n   object Response {\n-    def parser[F[_]: Concurrent](maxHeaderLength: Int)(\n-        s: Stream[F, Byte]): Resource[F, Response[F]] =\n-      Resource.eval(Deferred[F, Headers]).flatMap { trailers =>\n-        RespPrelude\n+    def parser[F[_]: Concurrent: Temporal](maxHeaderLength: Int, timeout: Option[FiniteDuration])(\n+        s: Stream[F, Byte]): F[(Response[F], Stream[F, Byte])] =\n+      Deferred[F, Headers].flatMap { trailers =>\n+        val base = RespPrelude\n           .parsePrelude(s, maxHeaderLength, None)\n           .flatMap { case (httpVersion, status, s) =>\n             HeaderP.parseHeaders(s, maxHeaderLength, None).flatMap {\n@@ -389,18 +407,20 @@ private[ember] object Parser {\n                         rest.through(ChunkedEncoding.decode(maxHeaderLength, trailers)))\n                   else\n                     baseResp.withBodyStream(rest.take(contentLength.getOrElse(0L)))\n-                Pull.output1(resp)\n+                Pull.output1((resp, rest))\n             }\n           }\n           .stream\n           .take(1)\n-          .compile\n-          .resource\n-          .lastOrError\n+\n+        val action = base.compile.lastOrError\n+        timeout.fold(action)(duration => Temporal[F].timeout(action, duration))\n       }\n \n     object RespPrelude {\n \n+      val emptyStreamError = RespPreludeError(\"Cannot Parse Empty Stream\", None)\n+\n       def parsePrelude[F[_]: MonadThrow](\n           s: Stream[F, Byte],\n           maxHeaderLength: Int,\n@@ -415,19 +435,28 @@ private[ember] object Parser {\n             preludeInSection(next) match {\n               case RespPreludeComplete(httpVersion, status, rest) =>\n                 Pull.pure((httpVersion, status, Stream.chunk(Chunk.array(rest)) ++ tl))\n-              case t @ RespPreludeError(_) => Pull.raiseError[F](t)\n+              case t @ RespPreludeError(_, _) => Pull.raiseError[F](t)\n               case RespPreludeIncomplete =>\n                 if (next.size <= maxHeaderLength)\n                   parsePrelude(tl, maxHeaderLength, next.some)\n                 else\n                   Pull.raiseError[F](\n                     RespPreludeError(\n-                      new Throwable(\"Reached Max Header Length Looking for Response Prelude\")))\n+                      \"Reached Max Header Length Looking for Response Prelude\",\n+                      None))\n             }\n           case None =>\n-            Pull.raiseError[F](\n-              RespPreludeError(\n-                new Throwable(\"Reached Ended of Stream Looking for Response Prelude\")))\n+            acc match {\n+              case None => Pull.raiseError(emptyStreamError)\n+              case Some(incomplete) if incomplete.isEmpty => Pull.raiseError(emptyStreamError)\n+              case Some(_) =>\n+                Pull.raiseError[F](\n+                  RespPreludeError(\n+                    \"Unexpectedly Reached Ended of Stream Looking for Response Prelude\",\n+                    None)\n+                )\n+            }\n+\n         }\n \n       private val space = ' '.toByte\n@@ -438,8 +467,10 @@ private[ember] object Parser {\n       case class RespPreludeComplete(httpVersion: HttpVersion, status: Status, rest: Array[Byte])\n           extends RespPreludeResult\n       case object RespPreludeIncomplete extends RespPreludeResult\n-      case class RespPreludeError(cause: Throwable)\n-          extends Throwable(s\"Received Error while parsing prelude - ${cause.getMessage}\", cause)\n+      case class RespPreludeError(message: String, cause: Option[Throwable])\n+          extends Throwable(\n+            s\"Received Error while parsing prelude - Message: $message - ${cause.map(_.getMessage)}\",\n+            cause.orNull)\n           with RespPreludeResult\n \n       // HTTP/1.1 200 OK\n@@ -501,7 +532,7 @@ private[ember] object Parser {\n           idx += 1\n         }\n \n-        if (throwable != null) RespPreludeError(throwable)\n+        if (throwable != null) RespPreludeError(\"Encounterd Error parsing\", Option(throwable))\n         if (httpVersion != null && status != null)\n           RespPreludeComplete(httpVersion, status, bv.drop(idx))\n         else RespPreludeIncomplete"
        },
        {
          "filename": "ember-core/src/main/scala/org/http4s/ember/core/Util.scala",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -79,4 +79,10 @@ private[ember] object Util {\n         )\n     go(timeout)\n   }\n+\n+  def durationToFinite(duration: Duration): Option[FiniteDuration] = duration match {\n+    case f: FiniteDuration => Some(f)\n+    case _ => None\n+  }\n+\n }"
        },
        {
          "filename": "ember-core/src/test/scala/org/http4s/ember/core/EncoderSuite.scala",
          "status": "modified",
          "additions": 3,
          "deletions": 16,
          "patch": "@@ -19,6 +19,7 @@ package ember.core\n \n import cats.syntax.all._\n import cats.effect.{IO, Sync}\n+import org.http4s.headers.`Content-Length`\n \n class EncoderSuite extends Http4sSuite {\n   private object Helpers {\n@@ -48,9 +49,6 @@ class EncoderSuite extends Http4sSuite {\n     val expected =\n       \"\"\"GET / HTTP/1.1\n       |Host: www.google.com\n-      |Transfer-Encoding: chunked\n-      |\n-      |0\n       |\n       |\"\"\".stripMargin\n \n@@ -81,9 +79,6 @@ class EncoderSuite extends Http4sSuite {\n       \"\"\"GET / HTTP/1.1\n         |Host: www.google.com\n         |foo: bar\n-        |Transfer-Encoding: chunked\n-        |\n-        |0\n         |\n         |\"\"\".stripMargin\n     Helpers.encodeRequestRig(req).assertEquals(expected)\n@@ -97,9 +92,6 @@ class EncoderSuite extends Http4sSuite {\n     val expected =\n       \"\"\"GET /path?query HTTP/1.1\n         |Host: www.example.com\n-        |Transfer-Encoding: chunked\n-        |\n-        |0\n         |\n         |\"\"\".stripMargin\n     Helpers.encodeRequestRig(req).assertEquals(expected)\n@@ -114,22 +106,17 @@ class EncoderSuite extends Http4sSuite {\n     val expected =\n       \"\"\"GET / HTTP/1.1\n         |Host: example.org:8080\n-        |Transfer-Encoding: chunked\n-        |\n-        |0\n         |\n         |\"\"\".stripMargin\n     Helpers.encodeRequestRig(req).assertEquals(expected)\n   }\n \n   test(\"respToBytes should encode a no body response correctly\") {\n-    val resp = Response[IO](Status.Ok)\n+    val resp = Response[IO](Status.Ok).putHeaders(`Content-Length`.zero)\n \n     val expected =\n       \"\"\"HTTP/1.1 200 OK\n-      |Transfer-Encoding: chunked\n-      |\n-      |0\n+      |Content-Length: 0\n       |\n       |\"\"\".stripMargin\n "
        },
        {
          "filename": "ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala",
          "status": "modified",
          "additions": 25,
          "deletions": 14,
          "patch": "@@ -35,24 +35,25 @@ class ParsingSpec extends Specification {\n     def httpifyString(s: String): String = s.replace(\"\\n\", \"\\r\\n\")\n \n     // Only for Use with Text Requests\n-    def parseRequestRig[F[_]: Concurrent](s: String): F[Request[F]] = {\n+    def parseRequestRig[F[_]: Concurrent: Temporal](s: String): F[Request[F]] = {\n       val byteStream: Stream[F, Byte] = Stream\n         .emit(s)\n         .covary[F]\n         .map(httpifyString)\n         .through(fs2.text.utf8Encode[F])\n \n-      Parser.Request.parser[F](Int.MaxValue)(byteStream)\n+      Parser.Request.parser[F](Int.MaxValue, None)(byteStream).map(_._1)\n     }\n \n-    def parseResponseRig[F[_]: Concurrent](s: String): Resource[F, Response[F]] = {\n+    def parseResponseRig[F[_]: Concurrent: Temporal](s: String): Resource[F, Response[F]] = {\n       val byteStream: Stream[F, Byte] = Stream\n         .emit(s)\n         .covary[F]\n         .map(httpifyString)\n         .through(fs2.text.utf8Encode[F])\n \n-      Parser.Response.parser[F](Int.MaxValue)(byteStream)\n+      val action = Parser.Response.parser[F](Int.MaxValue, None)(byteStream).map(_._1) //(logger)\n+      Resource.liftF(action)\n     }\n \n     def forceScopedParsing[F[_]: Concurrent](s: String): Stream[F, Byte] = {\n@@ -153,19 +154,29 @@ class ParsingSpec extends Specification {\n \n     \"handle a response that requires multiple chunks to be read\" in {\n       val defaultMaxHeaderLength = 4096\n-      val raw =\n+      val raw1 =\n         \"\"\"HTTP/1.1 200 OK\n           |Content-type: application/json\n           |Content-Length: 2\n           |\n-          |{}\n+          |{\"\"\".stripMargin\n+\n+      val raw2 = \"\"\"}\n           |\"\"\".stripMargin\n+      val http1 = Helpers.httpifyString(raw1)\n+\n+      val http2 = Helpers.httpifyString(raw2)\n+      val encoded = (Stream(http1) ++ Stream(http2)).through(fs2.text.utf8Encode)\n \n       (for {\n         parsed <-\n           Parser.Response\n-            .parser[IO](defaultMaxHeaderLength)(Helpers.forceScopedParsing[IO](raw))\n-            .use { resp =>\n+            .parser[IO](defaultMaxHeaderLength, None)(\n+              encoded\n+              //Helpers.forceScopedParsing[IO](raw) // Cuts off `}` in current test. Why?\n+              // I don't follow what the rig is testing vs this.\n+            ) //(logger)\n+            .flatMap { case (resp, _) =>\n               resp.body.through(text.utf8Decode).compile.string\n             }\n       } yield parsed must_== \"{}\").unsafeRunSync()\n@@ -181,8 +192,8 @@ class ParsingSpec extends Specification {\n       val baseBv = ByteVector.fromBase64(base).get\n \n       Parser.Response\n-        .parser[IO](defaultMaxHeaderLength)(Stream.chunk(Chunk.byteVector(baseBv)))\n-        .use { resp =>\n+        .parser[IO](defaultMaxHeaderLength, None)(Stream.chunk(Chunk.byteVector(baseBv)))\n+        .flatMap { case (resp, _) =>\n           resp.body.through(text.utf8Decode).compile.string\n \n         }\n@@ -216,8 +227,8 @@ class ParsingSpec extends Specification {\n           Stream.chunk(Chunk.array(s.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1))))\n \n       Parser.Response\n-        .parser[IO](defaultMaxHeaderLength)(byteStream)\n-        .use { resp =>\n+        .parser[IO](defaultMaxHeaderLength, None)(byteStream)\n+        .flatMap { case (resp, _) =>\n           resp.body.through(text.utf8Decode).compile.string.map { body =>\n             body must beEqualTo(\"MozillaDeveloperNetwork\")\n           }\n@@ -248,8 +259,8 @@ class ParsingSpec extends Specification {\n           Stream.chunk(Chunk.array(s.getBytes(java.nio.charset.StandardCharsets.US_ASCII))))\n \n       Parser.Response\n-        .parser[IO](defaultMaxHeaderLength)(byteStream)\n-        .use { resp =>\n+        .parser[IO](defaultMaxHeaderLength, None)(byteStream)\n+        .flatMap { case (resp, _) =>\n           for {\n             body <- resp.body.through(text.utf8Decode).compile.string\n             trailers <- resp.trailerHeaders"
        },
        {
          "filename": "ember-server/src/main/scala/org/http4s/ember/server/EmberServerBuilder.scala",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -148,6 +148,7 @@ final class EmberServerBuilder[F[_]: Async] private (\n       )\n       _ <- Resource.make(Applicative[F].unit)(_ => shutdown.await)\n       _ <- Resource.eval(ready.get.rethrow)\n+      _ <- Resource.eval(logger.info(s\"Ember-Server service bound to address: $bindAddress\"))\n     } yield new Server {\n       def address: InetSocketAddress = bindAddress\n       def isSecure: Boolean = tlsInfoOpt.isDefined\n@@ -197,7 +198,7 @@ object EmberServerBuilder {\n         : (Option[Request[F]], Response[F], Throwable) => F[Unit] = {\n       case _: (Option[Request[F]], Response[F], Throwable) => Applicative[F].unit\n     }\n-    val maxConcurrency: Int = Int.MaxValue\n+    val maxConcurrency: Int = server.defaults.MaxConnections\n     val receiveBufferSize: Int = 256 * 1024\n     val maxHeaderSize: Int = server.defaults.MaxHeadersSize\n     val requestHeaderReceiveTimeout: Duration = 5.seconds"
        },
        {
          "filename": "ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala",
          "status": "modified",
          "additions": 138,
          "deletions": 112,
          "patch": "@@ -16,8 +16,8 @@\n \n package org.http4s.ember.server.internal\n \n+import cats._\n import fs2._\n-import fs2.concurrent._\n import fs2.io.tcp._\n import fs2.io.tls._\n import fs2.io.Network\n@@ -29,10 +29,9 @@ import org.http4s._\n import org.http4s.headers.{Connection, Date}\n import org.typelevel.ci.CIString\n import _root_.org.http4s.ember.core.{Encoder, Parser}\n-import _root_.org.http4s.ember.core.Util.readWithTimeout\n import _root_.org.typelevel.log4cats.Logger\n import cats.data.NonEmptyList\n-\n+import _root_.org.http4s.ember.core.Util.durationToFinite\n private[server] object ServerHelpers {\n \n   private val closeCi = CIString(\"close\")\n@@ -54,116 +53,14 @@ private[server] object ServerHelpers {\n       // Defaults\n       errorHandler: Throwable => F[Response[F]],\n       onWriteFailure: (Option[Request[F]], Response[F], Throwable) => F[Unit],\n-      maxConcurrency: Int = Int.MaxValue,\n-      receiveBufferSize: Int = 256 * 1024,\n-      maxHeaderSize: Int = 10 * 1024,\n-      requestHeaderReceiveTimeout: Duration = 5.seconds,\n-      idleTimeout: Duration = 60.seconds,\n+      maxConcurrency: Int,\n+      receiveBufferSize: Int,\n+      maxHeaderSize: Int,\n+      requestHeaderReceiveTimeout: Duration,\n+      idleTimeout: Duration,\n       additionalSocketOptions: List[SocketOptionMapping[_]] = List.empty,\n       logger: Logger[F]\n   )(implicit F: Temporal[F], N: Network[F]): Stream[F, Nothing] = {\n-    def socketReadRequest(\n-        socket: Socket[F],\n-        requestHeaderReceiveTimeout: Duration,\n-        receiveBufferSize: Int,\n-        isReused: Boolean\n-    ): F[Request[F]] = {\n-      val (initial, readDuration) = (requestHeaderReceiveTimeout, idleTimeout, isReused) match {\n-        case (fin: FiniteDuration, idle: FiniteDuration, true) => (true, idle + fin)\n-        case (fin: FiniteDuration, _, false) => (true, fin)\n-        case _ => (false, Duration.Zero)\n-      }\n-\n-      SignallingRef[F, Boolean](initial).flatMap { timeoutSignal =>\n-        F.realTime\n-          .flatMap(now =>\n-            Parser.Request\n-              .parser(maxHeaderSize)(\n-                readWithTimeout[F](\n-                  socket,\n-                  now.toMillis,\n-                  readDuration,\n-                  timeoutSignal.get,\n-                  receiveBufferSize)\n-              )\n-              .flatMap { req =>\n-                timeoutSignal.set(false).as(req)\n-              })\n-      }\n-    }\n-\n-    def upgradeSocket(\n-        socketInit: Socket[F],\n-        tlsInfoOpt: Option[(TLSContext, TLSParameters)]): Resource[F, Socket[F]] =\n-      tlsInfoOpt.fold(socketInit.pure[Resource[F, *]]) { case (context, params) =>\n-        context\n-          .server(socketInit, params, { (s: String) => logger.trace(s) }.some)\n-          .widen[Socket[F]]\n-      }\n-\n-    def runApp(socket: Socket[F], isReused: Boolean): F[(Request[F], Response[F])] =\n-      for {\n-        req <- socketReadRequest(socket, requestHeaderReceiveTimeout, receiveBufferSize, isReused)\n-        resp <- httpApp\n-          .run(req)\n-          .handleErrorWith(errorHandler)\n-          .handleError(_ => serverFailure.covary[F])\n-      } yield (req, resp)\n-\n-    def send(socket: Socket[F])(request: Option[Request[F]], resp: Response[F]): F[Unit] =\n-      Encoder\n-        .respToBytes[F](resp)\n-        .through(socket.writes())\n-        .compile\n-        .drain\n-        .attempt\n-        .flatMap {\n-          case Left(err) => onWriteFailure(request, resp, err)\n-          case Right(()) => F.unit\n-        }\n-\n-    def postProcessResponse(req: Request[F], resp: Response[F]): F[Response[F]] = {\n-      val reqHasClose = req.headers.exists {\n-        // We know this is raw because we have not parsed any headers in the underlying alg.\n-        // If Headers are being parsed into processed for in ParseHeaders this is incorrect.\n-        case Header.Raw(name, values) => name == connectionCi && values.contains(closeCi.toString)\n-        case _ => false\n-      }\n-      val connection: Connection =\n-        if (reqHasClose) close\n-        else keepAlive\n-      for {\n-        date <- HttpDate.current[F].map(Date(_))\n-      } yield resp.withHeaders(Headers.of(date, connection) ++ resp.headers)\n-    }\n-\n-    def withUpgradedSocket(socket: Socket[F]): Stream[F, Nothing] =\n-      (Stream(false) ++ Stream(true).repeat)\n-        .flatMap { isReused =>\n-          Stream\n-            .eval(runApp(socket, isReused).attempt)\n-            .evalMap {\n-              case Right((req, resp)) =>\n-                postProcessResponse(req, resp).map(resp => (req, resp).asRight[Throwable])\n-              case other => other.pure[F]\n-            }\n-            .evalTap {\n-              case Right((request, response)) => send(socket)(Some(request), response)\n-              case Left(err) =>\n-                errorHandler(err)\n-                  .handleError(_ => serverFailure.covary[F])\n-                  .flatMap(send(socket)(None, _))\n-            }\n-        }\n-        .takeWhile {\n-          case Left(_) => false\n-          case Right((req, resp)) =>\n-            !(\n-              req.headers.get(Connection).exists(_.hasClose) ||\n-                resp.headers.get(Connection).exists(_.hasClose)\n-            )\n-        }\n-        .drain\n \n     val server: Stream[F, Resource[F, Socket[F]]] =\n       Stream\n@@ -179,10 +76,139 @@ private[server] object ServerHelpers {\n       .map { connect =>\n         shutdown.trackConnection >>\n           Stream\n-            .resource(connect.flatMap(upgradeSocket(_, tlsInfoOpt)))\n-            .flatMap(withUpgradedSocket(_))\n+            .resource(connect.flatMap(upgradeSocket(_, tlsInfoOpt, logger)))\n+            .flatMap(\n+              runConnection(\n+                _,\n+                logger,\n+                idleTimeout,\n+                receiveBufferSize,\n+                maxHeaderSize,\n+                requestHeaderReceiveTimeout,\n+                httpApp,\n+                errorHandler,\n+                onWriteFailure))\n       }\n \n     StreamForking.forking(streams, maxConcurrency)\n   }\n+\n+  // private[internal] def reachedEndError[F[_]: Sync](\n+  //     socket: Socket[F],\n+  //     idleTimeout: Duration,\n+  //     receiveBufferSize: Int): Stream[F, Byte] =\n+  //   Stream.repeatEval(socket.read(receiveBufferSize, durationToFinite(idleTimeout))).flatMap {\n+  //     case None =>\n+  //       Stream.raiseError(new EOFException(\"Unexpected EOF - socket.read returned None\") with NoStackTrace)\n+  //     case Some(value) => Stream.chunk(value)\n+  //   }\n+\n+  private[internal] def upgradeSocket[F[_]: Concurrent: Network](\n+      socketInit: Socket[F],\n+      tlsInfoOpt: Option[(TLSContext, TLSParameters)],\n+      logger: Logger[F]\n+  ): Resource[F, Socket[F]] =\n+    tlsInfoOpt.fold(socketInit.pure[Resource[F, *]]) { case (context, params) =>\n+      context\n+        .server(socketInit, params, { (s: String) => logger.trace(s) }.some)\n+        .widen[Socket[F]]\n+    }\n+\n+  private[internal] def runApp[F[_]: Concurrent: Temporal](\n+      incoming: Stream[F, Byte],\n+      maxHeaderSize: Int,\n+      requestHeaderReceiveTimeout: Duration,\n+      httpApp: HttpApp[F],\n+      errorHandler: Throwable => F[Response[F]]): F[(Request[F], Response[F], Stream[F, Byte])] =\n+    for {\n+      tup <- Parser.Request.parser(maxHeaderSize, durationToFinite(requestHeaderReceiveTimeout))(\n+        incoming)\n+      (req, rest) = tup\n+      resp <- httpApp\n+        .run(req)\n+        .handleErrorWith(errorHandler)\n+        .handleError(_ => serverFailure.covary[F])\n+    } yield (req, resp, rest)\n+\n+  private[internal] def send[F[_]: Concurrent](socket: Socket[F])(\n+      request: Option[Request[F]],\n+      resp: Response[F],\n+      idleTimeout: Duration,\n+      onWriteFailure: (Option[Request[F]], Response[F], Throwable) => F[Unit]): F[Unit] =\n+    Encoder\n+      .respToBytes[F](resp)\n+      .through(socket.writes(durationToFinite(idleTimeout)))\n+      .compile\n+      .drain\n+      .attempt\n+      .flatMap {\n+        case Left(err) => onWriteFailure(request, resp, err)\n+        case Right(()) => Applicative[F].unit\n+      }\n+\n+  private[internal] def postProcessResponse[F[_]: Temporal: Monad](\n+      req: Request[F],\n+      resp: Response[F]): F[Response[F]] = {\n+    val reqHasClose = req.headers.exists {\n+      // We know this is raw because we have not parsed any headers in the underlying alg.\n+      // If Headers are being parsed into processed for in ParseHeaders this is incorrect.\n+      case Header.Raw(name, values) => name == connectionCi && values.contains(closeCi.toString)\n+      case _ => false\n+    }\n+    val connection: Connection =\n+      if (reqHasClose) close\n+      else keepAlive\n+    for {\n+      date <- HttpDate.current[F].map(Date(_))\n+    } yield resp.withHeaders(Headers.of(date, connection) ++ resp.headers)\n+  }\n+\n+  private[internal] def runConnection[F[_]: Concurrent: Temporal](\n+      socket: Socket[F],\n+      logger: Logger[F],\n+      idleTimeout: Duration,\n+      receiveBufferSize: Int,\n+      maxHeaderSize: Int,\n+      requestHeaderReceiveTimeout: Duration,\n+      httpApp: HttpApp[F],\n+      errorHandler: Throwable => F[org.http4s.Response[F]],\n+      onWriteFailure: (Option[Request[F]], Response[F], Throwable) => F[Unit]\n+  ): Stream[F, Nothing] = {\n+    val _ = logger\n+    Stream\n+      .unfoldLoopEval(socket.reads(receiveBufferSize, durationToFinite(idleTimeout)))(s =>\n+        runApp(s, maxHeaderSize, requestHeaderReceiveTimeout, httpApp, errorHandler).attempt.map {\n+          case Right((req, resp, rest)) => (Right((req, resp)), Some(rest))\n+          case Left(e) => (Left(e), None)\n+        })\n+      .evalMap {\n+        case Right((req, resp)) =>\n+          postProcessResponse(req, resp).map(resp => (req, resp).asRight[Throwable])\n+        case other => other.pure[F]\n+      }\n+      .evalTap {\n+        case Right((request, response)) =>\n+          send(socket)(Some(request), response, idleTimeout, onWriteFailure)\n+        case Left(err) =>\n+          err match {\n+            case req: Parser.Request.ReqPrelude.ParsePreludeError\n+                if req == Parser.Request.ReqPrelude.emptyStreamError =>\n+              Applicative[F].unit\n+            case err =>\n+              errorHandler(err)\n+                .handleError(_ => serverFailure.covary[F])\n+                .flatMap(send(socket)(None, _, idleTimeout, onWriteFailure))\n+          }\n+      }\n+      .takeWhile {\n+        case Left(_) => false\n+        case Right((req, resp)) =>\n+          !(\n+            req.headers.get(Connection).exists(_.hasClose) ||\n+              resp.headers.get(Connection).exists(_.hasClose)\n+          )\n+      }\n+      .drain ++ Stream.eval(socket.close).drain\n+  }\n+\n }"
        },
        {
          "filename": "project/Http4sPlugin.scala",
          "status": "modified",
          "additions": 4,
          "deletions": 6,
          "patch": "@@ -23,8 +23,8 @@ object Http4sPlugin extends AutoPlugin {\n \n   override def requires = Http4sOrgPlugin\n \n-  val scala_213 = \"2.13.3\"\n-  val scala_212 = \"2.12.12\"\n+  val scala_213 = \"2.13.4\"\n+  val scala_212 = \"2.12.13\"\n \n   override lazy val globalSettings = Seq(\n     isCi := sys.env.get(\"CI\").isDefined\n@@ -78,8 +78,6 @@ object Http4sPlugin extends AutoPlugin {\n     // Incompatible with latest circe: https://github.com/circe/circe/pull/1591\n     dependencyUpdatesFilter -= moduleFilter(name = \"jawn*\", revision = \"1.0.2\"),\n     dependencyUpdatesFilter -= moduleFilter(name = \"jawn*\", revision = \"1.0.3\"),\n-    // https://github.com/scalacenter/scalafix/issues/1299\n-    dependencyUpdatesFilter -= moduleFilter(name = \"scalafix-core\", revision = \"0.9.24\"),\n \n     excludeFilter.in(headerSources) := HiddenFileFilter ||\n       new FileFilter {\n@@ -286,7 +284,7 @@ object Http4sPlugin extends AutoPlugin {\n     // error-prone merge conflicts in the dependencies below.\n     val argonaut = \"6.3.3\"\n     val asyncHttpClient = \"2.12.2\"\n-    val blaze = \"0.14.14\"\n+    val blaze = \"0.14.15\"\n     val boopickle = \"1.3.3\"\n     val caseInsensitive = \"1.0.0-RC2\"\n     val cats = \"2.3.1\"\n@@ -315,7 +313,7 @@ object Http4sPlugin extends AutoPlugin {\n     val netty = \"4.1.58.Final\"\n     val okio = \"2.10.0\"\n     val okhttp = \"4.9.1\"\n-    val playJson = \"2.9.2\"\n+    val playJson = \"2.10.0-RC1\"\n     val prometheusClient = \"0.10.0\"\n     val reactiveStreams = \"1.0.3\"\n     val quasiquotes = \"2.1.0\""
        },
        {
          "filename": "project/plugins.sbt",
          "status": "modified",
          "additions": 2,
          "deletions": 3,
          "patch": "@@ -3,13 +3,12 @@ libraryDependencies += \"ch.qos.logback\" % \"logback-classic\" % \"1.2.3\"\n // https://github.com/coursier/coursier/issues/450\n classpathTypes += \"maven-plugin\"\n \n-addSbtPlugin(\"ch.epfl.lamp\"               %  \"sbt-dotty\"                 % \"0.5.1\")\n-addSbtPlugin(\"ch.epfl.scala\"              %  \"sbt-scalafix\"              % \"0.9.23\")\n+addSbtPlugin(\"ch.epfl.scala\"              %  \"sbt-scalafix\"              % \"0.9.25\")\n addSbtPlugin(\"com.earldouglas\"            %  \"xsbt-web-plugin\"           % \"4.2.1\")\n addSbtPlugin(\"com.eed3si9n\"               %  \"sbt-buildinfo\"             % \"0.10.0\")\n addSbtPlugin(\"com.eed3si9n\"               %  \"sbt-unidoc\"                % \"0.4.3\")\n addSbtPlugin(\"com.github.tkawachi\"        %  \"sbt-doctest\"               % \"0.9.9\")\n-addSbtPlugin(\"org.http4s\"                 %  \"sbt-http4s-org\"            % \"0.7.1\")\n+addSbtPlugin(\"org.http4s\"                 %  \"sbt-http4s-org\"            % \"0.7.2\")\n addSbtPlugin(\"com.timushev.sbt\"           %  \"sbt-updates\"               % \"0.5.1\")\n addSbtPlugin(\"com.typesafe.sbt\"           %  \"sbt-ghpages\"               % \"0.6.3\")\n addSbtPlugin(\"com.typesafe.sbt\"           %  \"sbt-site\"                  % \"1.4.1\")"
        },
        {
          "filename": "server/src/main/scala/org/http4s/server/package.scala",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -51,6 +51,9 @@ package object server {\n \n     /** Default max size of all headers. */\n     val MaxHeadersSize: Int = 40 * 1024\n+\n+    /** Default max connections */\n+    val MaxConnections: Int = 1024\n   }\n \n   object ServerRequestKeys {"
        },
        {
          "filename": "tests/src/test/scala/org/http4s/parser/UriParserSpec.scala",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -43,7 +43,7 @@ class UriParserSpec extends Http4sSpec {\n       } yield f + \"::\" + b)\n \n       foreach(v) { s =>\n-        Ipv6Address.parser.string.parseAll(s) must beRight(s)\n+        Uri.Parser.ipv6Address.string.parseAll(s) must beRight(s)\n       }\n     }\n "
        },
        {
          "filename": "website/src/hugo/content/changelog.md",
          "status": "modified",
          "additions": 33,
          "deletions": 2,
          "patch": "@@ -20,7 +20,13 @@ it.\n \n * [#4306](https://github.com/http4s/http4s/pull/4306): Update the copyright notice to 2021.\n \n-# v0.22.0-M2\n+# v0.22.0-M2 (2021-02-02)\n+\n+This release fixes a [High Severity vulnerability](https://github.com/http4s/http4s/security/advisories/GHSA-xhv5-w9c5-2r2w) in blaze-server.\n+\n+## http4s-blaze-server\n+\n+* [GHSA-xhv5-w9c5-2r2w](https://github.com/http4s/http4s/security/advisories/GHSA-xhv5-w9c5-2r2w): Additionally to the fix in v0.21.17, drops support for NIO2.\n \n ## http4s-core\n \n@@ -31,6 +37,7 @@ it.\n ### Breaking changes\n \n * [#4259](https://github.com/http4s/http4s/pull/4259): Regenerate `MimeDb` from the IANA database. This shifts around some constants in a binary incompatible way, but almost nobody will notice.\n+* [#4327](https://github.com/http4s/http4s/pull/4237): Shifted the parsers around in `Uri` to prevent deadlocks that appeared since M1.  This should not be visible, but is binary breaking.\n \n ## http4s-prometheus\n \n@@ -42,9 +49,26 @@ it.\n \n * jawn-fs2-1.0.1\n * keypool-0.3.0-RC1 (moved to `org.typelevel`)\n+* play-json-2.10.0-RC1\n * simpleclient-0.10.0 (Prometheus)\n \n-# v0.21.17\n+# v0.21.17 (2021-02-02)\n+\n+This release fixes a [High Severity vulnerability](https://github.com/http4s/http4s/security/advisories/GHSA-xhv5-w9c5-2r2w) in blaze-server.\n+\n+## http4s-blaze-server\n+\n+### Security patches\n+\n+* [GHSA-xhv5-w9c5-2r2w](https://github.com/http4s/http4s/security/advisories/GHSA-xhv5-w9c5-2r2w): blaze-core, a library underlying http4s-blaze-server, accepts connections without bound.  Each connection claims a file handle, a scarce resource, leading to a denial of service vector.\n+\n+  `BlazeServerBuilder` now has a `maxConnections` property, limiting the number of concurrent connections.  The cap is not applied to the NIO2 socket server, which is now deprecated. \n+\n+## http4s-ember-core\n+\n+### Enhancements\n+\n+* [#4331](https://github.com/http4s/http4s/pull/4331): Don't render an empty chunked payload if a request has neither a `Content-Length` or `Transfer-Encoding` and the method is one of `GET`, `DELETE`, `CONNECT`, or `TRACE`. It is undefined behavior for those methods to send payloads.\n \n ## http4s-ember-server\n \n@@ -57,6 +81,12 @@ it.\n * [#4244](https://github.com/http4s/http4s/pull/4244): Internal refactoring of how the stream of server connections is parallelized and terminated.\n * [#4287](https://github.com/http4s/http4s/pull/4287): Replace `onError: Throwable => Response[F]` with `withErrorHandler: PartialFunction[Thrwable, F[Response[F]]`.  Error handling is invoked earlier, allowing custom responses to parsing and timeout failures.\n \n+## http4s-ember-client\n+\n+### Enhancements\n+\n+* [#4301](https://github.com/http4s/http4s/pull/4301): Add an `idleConnectionTime` to `EmberClientBuilder`. Discard stale connections from the pool and try to acquire a new one.\n+\n ## http4s-servlet\n \n ### Bugfixes\n@@ -69,6 +99,7 @@ it.\n \n ## Dependency upgrades\n \n+* blaze-0.14.15\n * okhttp-4.9.1\n \n # v1.0.0-M13 (2021-01-25)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 5,
        "unique_directories": 17,
        "max_directory_depth": 9
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "81fc34a53b22e0789e702a73014de0ddf92c0e5c",
            "date": "2025-01-17T02:37:50Z",
            "author_login": "rossabaker"
          },
          {
            "sha": "87c05aedc17b460510e72019dbaf06bcb375a84a",
            "date": "2025-01-17T02:29:00Z",
            "author_login": "rossabaker"
          },
          {
            "sha": "8501afc9fbcb90138df71e6f19de3d26eb80f66f",
            "date": "2025-01-14T12:19:21Z",
            "author_login": "http4s-steward[bot]"
          },
          {
            "sha": "060163d496502767e10b14094cd09b4211606b07",
            "date": "2025-01-14T07:52:16Z",
            "author_login": "http4s-steward[bot]"
          },
          {
            "sha": "3aace932e204b9743e2126ef5530df6d8af82d54",
            "date": "2025-01-07T09:14:14Z",
            "author_login": "danicheg"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "Http4s (http4s-blaze-server) is a minimal, idiomatic Scala interface for HTTP services. Http4s before versions 0.21.17, 0.22.0-M2, and 1.0.0-M14 have a vulnerability which can lead to a denial-of-service. Blaze-core, a library underlying http4s-blaze-server, accepts connections unboundedly on its selector pool. This has the net effect of amplifying degradation in services that are unable to handle their current request load, since incoming connections are still accepted and added to an unbounded queue. Each connection allocates a socket handle, which drains a scarce OS resource. This can also confound higher level circuit breakers which work based on detecting failed connections. http4s provides a general \"MaxActiveRequests\" middleware mechanism for limiting open connections, but it is enforced inside the Blaze accept loop, after the connection is accepted and the socket opened. Thus, the limit only prevents the number of connections which can be simultaneously processed, not the number of connections which can be held open. In 0.21.17, 0.22.0-M2, and 1.0.0-M14, a new \"maxConnections\" property, with a default value of 1024, has been added to the `BlazeServerBuilder`. Setting the value to a negative number restores unbounded behavior, but is strongly disrecommended. The NIO2 backend does not respect `maxConnections`. Its use is now deprecated in http4s-0.21, and the option is removed altogether starting in http4s-0.22. There are several possible workarounds described in the refrenced GitHub Advisory GHSA-xhv5-w9c5-2r2w.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-02-02T22:15:12.387",
    "last_modified": "2024-11-21T05:47:57.380",
    "fix_date": "2021-02-02T15:51:01Z"
  },
  "references": [
    {
      "url": "https://github.com/http4s/blaze/security/advisories/GHSA-xmw9-q7x9-j5qc",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/http4s/http4s/commit/987d6589ef79545b9bb2324ac4bdebf82d9a0171",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/http4s/http4s/security/advisories/GHSA-xhv5-w9c5-2r2w",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/http4s/blaze/security/advisories/GHSA-xmw9-q7x9-j5qc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/http4s/http4s/commit/987d6589ef79545b9bb2324ac4bdebf82d9a0171",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/http4s/http4s/security/advisories/GHSA-xhv5-w9c5-2r2w",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:13.181059",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "http4s",
    "owner": "http4s",
    "created_at": "2012-03-12T04:41:20Z",
    "updated_at": "2025-01-24T12:57:20Z",
    "pushed_at": "2025-01-26T07:25:35Z",
    "size": 95885,
    "stars": 2558,
    "forks": 791,
    "open_issues": 337,
    "watchers": 2558,
    "has_security_policy": false,
    "default_branch": "series/0.23",
    "protected_branches": [
      "main",
      "release-0.15.x",
      "release-0.16.x",
      "release-0.17.x",
      "release-0.18.x",
      "series/0.20",
      "series/0.21",
      "series/0.22",
      "series/0.23"
    ],
    "languages": {
      "Scala": 3083537,
      "Nix": 1141,
      "HTML": 19,
      "Shell": 10
    },
    "commit_activity": {
      "total_commits_last_year": 524,
      "avg_commits_per_week": 10.076923076923077,
      "days_active_last_year": 170
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:47:07.878018"
  }
}