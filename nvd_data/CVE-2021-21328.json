{
  "cve_id": "CVE-2021-21328",
  "github_data": {
    "repository": "vapor/vapor",
    "fix_commit": "e3aa712508db2854ac0ab905696c65fd88fa7e23",
    "related_commits": [
      "e3aa712508db2854ac0ab905696c65fd88fa7e23",
      "e3aa712508db2854ac0ab905696c65fd88fa7e23"
    ],
    "patch_url": "https://github.com/vapor/vapor/commit/e3aa712508db2854ac0ab905696c65fd88fa7e23.patch",
    "fix_commit_details": {
      "sha": "e3aa712508db2854ac0ab905696c65fd88fa7e23",
      "commit_date": "2021-02-22T16:17:49Z",
      "author": {
        "login": "0xTim",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-gcj9-jj38-hwmc",
        "length": 1327,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 363,
        "additions": 349,
        "deletions": 14
      },
      "files": [
        {
          "filename": "NOTICES.txt",
          "status": "added",
          "additions": 21,
          "deletions": 0,
          "patch": "@@ -0,0 +1,21 @@\n+\n+//===----------------------------------------------------------------------===//\n+//\n+// This source file is part of the Vapor open source project\n+//\n+// Copyright (c) 2017-2021 Vapor project authors\n+// Licensed under MIT\n+//\n+// See LICENSE for license information\n+//\n+// SPDX-License-Identifier: MIT\n+//\n+//===----------------------------------------------------------------------===//\n+\n+This product contains a derivation of the TestMetrics test implementation\n+from Swift Metrics.\n+\n+  * LICENSE (Apache License 2.0):\n+    * https://www.apache.org/licenses/LICENSE-2.0\n+  * HOMEPAGE:\n+    * https://github.com/apple/swift-metrics"
        },
        {
          "filename": "Sources/Vapor/Responder/DefaultResponder.swift",
          "status": "modified",
          "additions": 24,
          "deletions": 14,
          "patch": "@@ -41,13 +41,10 @@ internal struct DefaultResponder: Responder {\n     public func respond(to request: Request) -> EventLoopFuture<Response> {\n         let startTime = DispatchTime.now().uptimeNanoseconds\n         let response: EventLoopFuture<Response>\n-        let path: String\n         if let cachedRoute = self.getRoute(for: request) {\n-            path = cachedRoute.route.description\n             request.route = cachedRoute.route\n             response = cachedRoute.responder.respond(to: request)\n         } else {\n-            path = request.url.path\n             response = self.notFoundResponder.respond(to: request)\n         }\n         return response.always { result in\n@@ -60,7 +57,6 @@ internal struct DefaultResponder: Responder {\n             }\n             self.updateMetrics(\n                 for: request,\n-                path: path,\n                 startTime: startTime,\n                 statusCode: status.code\n             )\n@@ -83,25 +79,39 @@ internal struct DefaultResponder: Responder {\n     /// Records the requests metrics.\n     private func updateMetrics(\n         for request: Request,\n-        path: String,\n         startTime: UInt64,\n         statusCode: UInt\n     ) {\n-        let counterDimensions = [\n-            (\"method\", request.method.string),\n-            (\"path\", path),\n+        let pathForMetrics: String\n+        if let route = request.route {\n+            // We don't use route.description here to avoid duplicating the method in the path\n+            pathForMetrics = \"/\\(route.path.map { \"\\($0)\" }.joined(separator: \"/\"))\"\n+        } else {\n+            // If the route is undefined (i.e. a 404 and not something like /users/:userID\n+            // We rewrite the path and the method to undefined to avoid DOSing the\n+            // application and any downstream metrics systems. Otherwise an attacker\n+            // could spam the service with unlimited requests and exhaust the system\n+            // with unlimited timers/counters\n+            pathForMetrics = \"vapor_route_undefined\"\n+        }\n+        let methodForMetrics: String\n+        if request.route == nil {\n+            methodForMetrics = \"undefined\"\n+        } else {\n+            methodForMetrics = request.method.string\n+        }\n+        let dimensions = [\n+            (\"method\", methodForMetrics),\n+            (\"path\", pathForMetrics),\n             (\"status\", statusCode.description),\n         ]\n-        Counter(label: \"http_requests_total\", dimensions: counterDimensions).increment()\n+        Counter(label: \"http_requests_total\", dimensions: dimensions).increment()\n         if statusCode >= 500 {\n-            Counter(label: \"http_request_errors_total\", dimensions: counterDimensions).increment()\n+            Counter(label: \"http_request_errors_total\", dimensions: dimensions).increment()\n         }\n         Timer(\n             label: \"http_request_duration_seconds\",\n-            dimensions: [\n-                (\"method\", request.method.string),\n-                (\"path\", path)\n-            ],\n+            dimensions: dimensions,\n             preferredDisplayUnit: .seconds\n         ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)\n     }"
        },
        {
          "filename": "Tests/VaporTests/MetricsTests.swift",
          "status": "added",
          "additions": 126,
          "deletions": 0,
          "patch": "@@ -0,0 +1,126 @@\n+import XCTVapor\n+import Vapor\n+import Metrics\n+@testable import CoreMetrics\n+\n+class MetricsTests: XCTestCase {\n+    func testMetricsIncreasesCounter() {\n+        let metrics = CapturingMetricsSystem()\n+        MetricsSystem.bootstrapInternal(metrics)\n+\n+        let app = Application(.testing)\n+        defer { app.shutdown() }\n+\n+        struct User: Content {\n+            let id: Int\n+            let name: String\n+        }\n+\n+        app.routes.get(\"users\", \":userID\") { req -> User in\n+            let userID = try req.parameters.require(\"userID\", as: Int.self)\n+            if userID == 1 {\n+                return User(id: 1, name: \"Tim\")\n+            } else {\n+                throw Abort(.notFound)\n+            }\n+        }\n+\n+        XCTAssertNoThrow(try app.testable().test(.GET, \"/users/1\") { res in\n+            XCTAssertEqual(res.status, .ok)\n+            let resData = try res.content.decode(User.self)\n+            XCTAssertEqual(resData.id, 1)\n+            XCTAssertEqual(metrics.counters.count, 1)\n+            let counter = metrics.counters[\"http_requests_total\"] as! TestCounter\n+            print(counter.dimensions)\n+            let pathDimension = try XCTUnwrap(counter.dimensions.first(where: { $0.0 == \"path\"}))\n+            XCTAssertEqual(pathDimension.1, \"/users/:userID\")\n+            XCTAssertNil(counter.dimensions.first(where: { $0.0 == \"path\" && $0.1 == \"/users/1\" }))\n+            let methodDimension = try XCTUnwrap(counter.dimensions.first(where: { $0.0 == \"method\"}))\n+            XCTAssertEqual(methodDimension.1, \"GET\")\n+            let status = try XCTUnwrap(counter.dimensions.first(where: { $0.0 == \"status\"}))\n+            XCTAssertEqual(status.1, \"200\")\n+\n+            let timer = metrics.timers[\"http_request_duration_seconds\"] as! TestTimer\n+            let timerPathDimension = try XCTUnwrap(timer.dimensions.first(where: { $0.0 == \"path\"}))\n+            XCTAssertEqual(timerPathDimension.1, \"/users/:userID\")\n+            let timerMethodDimension = try XCTUnwrap(timer.dimensions.first(where: { $0.0 == \"method\"}))\n+            XCTAssertEqual(timerMethodDimension.1, \"GET\")\n+            let timerStatusDimension = try XCTUnwrap(timer.dimensions.first(where: { $0.0 == \"status\"}))\n+            XCTAssertEqual(timerStatusDimension.1, \"200\")\n+        })\n+    }\n+\n+    func testID404DoesntSpamMetrics() {\n+        let metrics = CapturingMetricsSystem()\n+        MetricsSystem.bootstrapInternal(metrics)\n+\n+        let app = Application(.testing)\n+        defer { app.shutdown() }\n+\n+        struct User: Content {\n+            let id: Int\n+            let name: String\n+        }\n+\n+        app.routes.get(\"users\", \":userID\") { req -> User in\n+            let userID = try req.parameters.require(\"userID\", as: Int.self)\n+            if userID == 1 {\n+                return User(id: 1, name: \"Tim\")\n+            } else {\n+                throw Abort(.notFound)\n+            }\n+        }\n+\n+        XCTAssertNoThrow(try app.testable().test(.GET, \"/users/2\") { res in\n+            XCTAssertEqual(res.status, .notFound)\n+            let counter = metrics.counters[\"http_requests_total\"] as! TestCounter\n+            let pathDimension = try XCTUnwrap(counter.dimensions.first(where: { $0.0 == \"path\"}))\n+            XCTAssertEqual(pathDimension.1, \"/users/:userID\")\n+            let methodDimension = try XCTUnwrap(counter.dimensions.first(where: { $0.0 == \"method\"}))\n+            XCTAssertEqual(methodDimension.1, \"GET\")\n+            let status = try XCTUnwrap(counter.dimensions.first(where: { $0.0 == \"status\"}))\n+            XCTAssertEqual(status.1, \"404\")\n+            XCTAssertNil(counter.dimensions.first(where: { $0.1 == \"200\" }))\n+            XCTAssertNil(counter.dimensions.first(where: { $0.0 == \"path\" && $0.1 == \"/users/1\" }))\n+\n+            let timer = metrics.timers[\"http_request_duration_seconds\"] as! TestTimer\n+            let timerPathDimension = try XCTUnwrap(timer.dimensions.first(where: { $0.0 == \"path\"}))\n+            XCTAssertEqual(timerPathDimension.1, \"/users/:userID\")\n+            let timerMethodDimension = try XCTUnwrap(timer.dimensions.first(where: { $0.0 == \"method\"}))\n+            XCTAssertEqual(timerMethodDimension.1, \"GET\")\n+            let timerStatusDimension = try XCTUnwrap(timer.dimensions.first(where: { $0.0 == \"status\"}))\n+            XCTAssertEqual(timerStatusDimension.1, \"404\")\n+            XCTAssertNil(timer.dimensions.first(where: { $0.1 == \"200\" }))\n+        })\n+    }\n+\n+    func test404RewritesPathForMetricsToAvoidDOSAttack()  {\n+        let metrics = CapturingMetricsSystem()\n+        MetricsSystem.bootstrapInternal(metrics)\n+\n+        let app = Application(.testing)\n+        defer { app.shutdown() }\n+\n+        XCTAssertNoThrow(try app.testable().test(.GET, \"/not/found\") { res in\n+            XCTAssertEqual(res.status, .notFound)\n+            XCTAssertEqual(metrics.counters.count, 1)\n+            let counter = metrics.counters[\"http_requests_total\"] as! TestCounter\n+            let pathDimension = try XCTUnwrap(counter.dimensions.first(where: { $0.0 == \"path\"}))\n+            XCTAssertEqual(pathDimension.1, \"vapor_route_undefined\")\n+            let methodDimension = try XCTUnwrap(counter.dimensions.first(where: { $0.0 == \"method\"}))\n+            XCTAssertEqual(methodDimension.1, \"undefined\")\n+            let status = try XCTUnwrap(counter.dimensions.first(where: { $0.0 == \"status\"}))\n+            XCTAssertEqual(status.1, \"404\")\n+\n+            let timer = metrics.timers[\"http_request_duration_seconds\"] as! TestTimer\n+            let timerPathDimension = try XCTUnwrap(timer.dimensions.first(where: { $0.0 == \"path\"}))\n+            XCTAssertEqual(timerPathDimension.1, \"vapor_route_undefined\")\n+            let timerMethodDimension = try XCTUnwrap(timer.dimensions.first(where: { $0.0 == \"method\"}))\n+            XCTAssertEqual(timerMethodDimension.1, \"undefined\")\n+            let timerStatusDimension = try XCTUnwrap(timer.dimensions.first(where: { $0.0 == \"status\"}))\n+            XCTAssertEqual(timerStatusDimension.1, \"404\")\n+            XCTAssertNil(timer.dimensions.first(where: { $0.1 == \"200\" }))\n+        })\n+    }\n+}\n+"
        },
        {
          "filename": "Tests/VaporTests/Utilities/CapturingMetricsSystem.swift",
          "status": "added",
          "additions": 178,
          "deletions": 0,
          "patch": "@@ -0,0 +1,178 @@\n+// ===----------------------------------------------------------------------===##\n+//\n+//  This source file is part of the Vapor open source project\n+//\n+//  Copyright (c) 2017-2021 Vapor project authors\n+//  Licensed under MIT\n+//\n+//  See LICENSE for license information\n+//\n+//  SPDX-License-Identifier: MIT\n+//\n+// ===----------------------------------------------------------------------===##\n+// This was adapted from Swift Metrics's TestMetrics.swift code.\n+// The license for the original work is reproduced below. See NOTICES.txt for\n+// more.\n+\n+import Metrics\n+import Foundation\n+import NIOConcurrencyHelpers\n+\n+/// Metrics factory which allows inspecting recorded metrics programmatically.\n+/// Only intended for tests of the Metrics API itself.\n+internal final class CapturingMetricsSystem: MetricsFactory {\n+    private let lock = Lock()\n+    var counters = [String: CounterHandler]()\n+    var recorders = [String: RecorderHandler]()\n+    var timers = [String: TimerHandler]()\n+\n+    public func makeCounter(label: String, dimensions: [(String, String)]) -> CounterHandler {\n+        return self.make(label: label, dimensions: dimensions, registry: &self.counters, maker: TestCounter.init)\n+    }\n+\n+    public func makeRecorder(label: String, dimensions: [(String, String)], aggregate: Bool) -> RecorderHandler {\n+        let maker = { (label: String, dimensions: [(String, String)]) -> RecorderHandler in\n+            TestRecorder(label: label, dimensions: dimensions, aggregate: aggregate)\n+        }\n+        return self.make(label: label, dimensions: dimensions, registry: &self.recorders, maker: maker)\n+    }\n+\n+    public func makeTimer(label: String, dimensions: [(String, String)]) -> TimerHandler {\n+        return self.make(label: label, dimensions: dimensions, registry: &self.timers, maker: TestTimer.init)\n+    }\n+\n+    private func make<Item>(label: String, dimensions: [(String, String)], registry: inout [String: Item], maker: (String, [(String, String)]) -> Item) -> Item {\n+        return self.lock.withLock {\n+            let item = maker(label, dimensions)\n+            registry[label] = item\n+            return item\n+        }\n+    }\n+\n+    func destroyCounter(_ handler: CounterHandler) {\n+        if let testCounter = handler as? TestCounter {\n+            self.counters.removeValue(forKey: testCounter.label)\n+        }\n+    }\n+\n+    func destroyRecorder(_ handler: RecorderHandler) {\n+        if let testRecorder = handler as? TestRecorder {\n+            self.recorders.removeValue(forKey: testRecorder.label)\n+        }\n+    }\n+\n+    func destroyTimer(_ handler: TimerHandler) {\n+        if let testTimer = handler as? TestTimer {\n+            self.timers.removeValue(forKey: testTimer.label)\n+        }\n+    }\n+}\n+\n+internal class TestCounter: CounterHandler, Equatable {\n+    let id: String\n+    let label: String\n+    let dimensions: [(String, String)]\n+\n+    let lock = Lock()\n+    var values = [(Date, Int64)]()\n+\n+    init(label: String, dimensions: [(String, String)]) {\n+        self.id = UUID().uuidString\n+        self.label = label\n+        self.dimensions = dimensions\n+    }\n+\n+    func increment(by amount: Int64) {\n+        self.lock.withLock {\n+            self.values.append((Date(), amount))\n+        }\n+        print(\"adding \\(amount) to \\(self.label)\")\n+    }\n+\n+    func reset() {\n+        self.lock.withLock {\n+            self.values = []\n+        }\n+        print(\"resetting \\(self.label)\")\n+    }\n+\n+    public static func == (lhs: TestCounter, rhs: TestCounter) -> Bool {\n+        return lhs.id == rhs.id\n+    }\n+}\n+\n+internal class TestRecorder: RecorderHandler, Equatable {\n+    let id: String\n+    let label: String\n+    let dimensions: [(String, String)]\n+    let aggregate: Bool\n+\n+    let lock = Lock()\n+    var values = [(Date, Double)]()\n+\n+    init(label: String, dimensions: [(String, String)], aggregate: Bool) {\n+        self.id = UUID().uuidString\n+        self.label = label\n+        self.dimensions = dimensions\n+        self.aggregate = aggregate\n+    }\n+\n+    func record(_ value: Int64) {\n+        self.record(Double(value))\n+    }\n+\n+    func record(_ value: Double) {\n+        self.lock.withLock {\n+            values.append((Date(), value))\n+        }\n+        print(\"recording \\(value) in \\(self.label)\")\n+    }\n+\n+    public static func == (lhs: TestRecorder, rhs: TestRecorder) -> Bool {\n+        return lhs.id == rhs.id\n+    }\n+}\n+\n+internal class TestTimer: TimerHandler, Equatable {\n+    let id: String\n+    let label: String\n+    var displayUnit: TimeUnit?\n+    let dimensions: [(String, String)]\n+\n+    let lock = Lock()\n+    var values = [(Date, Int64)]()\n+\n+    init(label: String, dimensions: [(String, String)]) {\n+        self.id = UUID().uuidString\n+        self.label = label\n+        self.displayUnit = nil\n+        self.dimensions = dimensions\n+    }\n+\n+    func preferDisplayUnit(_ unit: TimeUnit) {\n+        self.lock.withLock {\n+            self.displayUnit = unit\n+        }\n+    }\n+\n+    func retriveValueInPreferredUnit(atIndex i: Int) -> Double {\n+        return self.lock.withLock {\n+            let value = values[i].1\n+            guard let displayUnit = self.displayUnit else {\n+                return Double(value)\n+            }\n+            return Double(value) / Double(displayUnit.scaleFromNanoseconds)\n+        }\n+    }\n+\n+    func recordNanoseconds(_ duration: Int64) {\n+        self.lock.withLock {\n+            values.append((Date(), duration))\n+        }\n+        print(\"recording \\(duration) \\(self.label)\")\n+    }\n+\n+    public static func == (lhs: TestTimer, rhs: TestTimer) -> Bool {\n+        return lhs.id == rhs.id\n+    }\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "eafbca78d0ced81a127c94f3703fc3fc76827963",
            "date": "2025-01-14T13:15:43Z",
            "author_login": "weissi"
          },
          {
            "sha": "4d7456c0d4b33ef82783a90ecfeae33a52a3972a",
            "date": "2024-12-30T18:52:00Z",
            "author_login": "WilliamFernsV3"
          },
          {
            "sha": "73dfe634f04945285054b261369cd93f5100b44c",
            "date": "2024-12-28T12:23:23Z",
            "author_login": "gwynne"
          },
          {
            "sha": "4c5d467a96fc4c64f6279327d8fd1e1600e85bc5",
            "date": "2024-12-26T15:37:40Z",
            "author_login": "MahdiBM"
          },
          {
            "sha": "1f29415ed888a942bb23486ca9e422123a07e70f",
            "date": "2024-12-21T01:33:12Z",
            "author_login": "MahdiBM"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-400",
    "description": "Vapor is a web framework for Swift. In Vapor before version 4.40.1, there is a DoS attack against anyone who Bootstraps a metrics backend for their Vapor app. The following is the attack vector: 1. send unlimited requests against a vapor instance with different paths. this will create unlimited counters and timers, which will eventually drain the system. 2. downstream services might suffer from this attack as well by being spammed with error paths. This has been patched in 4.40.1. The `DefaultResponder` will rewrite any undefined route paths for to `vapor_route_undefined` to avoid unlimited counters.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-02-26T02:15:12.713",
    "last_modified": "2024-11-21T05:48:01.900",
    "fix_date": "2021-02-22T16:17:49Z"
  },
  "references": [
    {
      "url": "https://github.com/vapor/vapor/commit/e3aa712508db2854ac0ab905696c65fd88fa7e23",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vapor/vapor/releases/tag/4.40.1",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vapor/vapor/security/advisories/GHSA-gcj9-jj38-hwmc",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vapor.codes/",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/vapor/vapor/commit/e3aa712508db2854ac0ab905696c65fd88fa7e23",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vapor/vapor/releases/tag/4.40.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vapor/vapor/security/advisories/GHSA-gcj9-jj38-hwmc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vapor.codes/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:16.807452",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "vapor",
    "owner": "vapor",
    "created_at": "2016-01-18T22:37:52Z",
    "updated_at": "2025-01-14T13:38:54Z",
    "pushed_at": "2025-01-14T13:15:50Z",
    "size": 17155,
    "stars": 24729,
    "forks": 1453,
    "open_issues": 95,
    "watchers": 24729,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "3",
      "main"
    ],
    "languages": {
      "Swift": 1446558,
      "C": 38624,
      "HTML": 67
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T14:50:15.643999"
  }
}