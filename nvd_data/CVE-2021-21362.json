{
  "cve_id": "CVE-2021-21362",
  "github_data": {
    "repository": "minio/minio",
    "fix_commit": "039f59b552319fcc2f83631bb421a7d4b82bc482",
    "related_commits": [
      "039f59b552319fcc2f83631bb421a7d4b82bc482",
      "039f59b552319fcc2f83631bb421a7d4b82bc482"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "039f59b552319fcc2f83631bb421a7d4b82bc482",
      "commit_date": "2021-03-03T16:47:08Z",
      "author": {
        "login": "harshavardhana",
        "type": "User",
        "stats": {
          "total_commits": 4375,
          "average_weekly_commits": 8.162313432835822,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 491
        }
      },
      "commit_message": {
        "title": "fix: missing user policy enforcement in PostPolicyHandler (#11682)",
        "length": 66,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 87,
        "additions": 63,
        "deletions": 24
      },
      "files": [
        {
          "filename": "cmd/auth-handler.go",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -185,12 +185,12 @@ func getSessionToken(r *http.Request) (token string) {\n // Fetch claims in the security token returned by the client, doesn't return\n // errors - upon errors the returned claims map will be empty.\n func mustGetClaimsFromToken(r *http.Request) map[string]interface{} {\n-\tclaims, _ := getClaimsFromToken(r, getSessionToken(r))\n+\tclaims, _ := getClaimsFromToken(getSessionToken(r))\n \treturn claims\n }\n \n // Fetch claims in the security token returned by the client.\n-func getClaimsFromToken(r *http.Request, token string) (map[string]interface{}, error) {\n+func getClaimsFromToken(token string) (map[string]interface{}, error) {\n \tclaims := xjwt.NewMapClaims()\n \tif token == \"\" {\n \t\treturn claims.Map(), nil\n@@ -237,7 +237,7 @@ func getClaimsFromToken(r *http.Request, token string) (map[string]interface{},\n \t\tif err != nil {\n \t\t\t// Base64 decoding fails, we should log to indicate\n \t\t\t// something is malforming the request sent by client.\n-\t\t\tlogger.LogIf(r.Context(), err, logger.Application)\n+\t\t\tlogger.LogIf(GlobalContext, err, logger.Application)\n \t\t\treturn nil, errAuthentication\n \t\t}\n \t\tclaims.MapClaims[iampolicy.SessionPolicyName] = string(spBytes)\n@@ -258,7 +258,7 @@ func checkClaimsFromToken(r *http.Request, cred auth.Credentials) (map[string]in\n \tif subtle.ConstantTimeCompare([]byte(token), []byte(cred.SessionToken)) != 1 {\n \t\treturn nil, ErrInvalidToken\n \t}\n-\tclaims, err := getClaimsFromToken(r, token)\n+\tclaims, err := getClaimsFromToken(token)\n \tif err != nil {\n \t\treturn nil, toAPIErrorCode(r.Context(), err)\n \t}"
        },
        {
          "filename": "cmd/bucket-handlers.go",
          "status": "modified",
          "additions": 46,
          "deletions": 6,
          "patch": "@@ -17,6 +17,7 @@\n package cmd\n \n import (\n+\t\"crypto/subtle\"\n \t\"encoding/base64\"\n \t\"encoding/xml\"\n \t\"fmt\"\n@@ -25,7 +26,6 @@ import (\n \t\"net/textproto\"\n \t\"net/url\"\n \t\"path\"\n-\t\"path/filepath\"\n \t\"sort\"\n \t\"strconv\"\n \t\"strings\"\n@@ -337,7 +337,7 @@ func (api objectAPIHandlers) ListBucketsHandler(w http.ResponseWriter, r *http.R\n \n \t\t// err will be nil here as we already called this function\n \t\t// earlier in this request.\n-\t\tclaims, _ := getClaimsFromToken(r, getSessionToken(r))\n+\t\tclaims, _ := getClaimsFromToken(getSessionToken(r))\n \t\tn := 0\n \t\t// Use the following trick to filter in place\n \t\t// https://github.com/golang/go/wiki/SliceTricks#filter-in-place\n@@ -797,13 +797,15 @@ func (api objectAPIHandlers) PostPolicyBucketHandler(w http.ResponseWriter, r *h\n \t\twriteErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrMissingContentLength), r.URL, guessIsBrowserReq(r))\n \t\treturn\n \t}\n+\n \tresource, err := getResource(r.URL.Path, r.Host, globalDomainNames)\n \tif err != nil {\n \t\twriteErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL, guessIsBrowserReq(r))\n \t\treturn\n \t}\n-\t// Make sure that the URL  does not contain object name.\n-\tif bucket != filepath.Clean(resource[1:]) {\n+\n+\t// Make sure that the URL does not contain object name.\n+\tif bucket != path.Clean(resource[1:]) {\n \t\twriteErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrMethodNotAllowed), r.URL, guessIsBrowserReq(r))\n \t\treturn\n \t}\n@@ -846,7 +848,6 @@ func (api objectAPIHandlers) PostPolicyBucketHandler(w http.ResponseWriter, r *h\n \tdefer fileBody.Close()\n \n \tformValues.Set(\"Bucket\", bucket)\n-\n \tif fileName != \"\" && strings.Contains(formValues.Get(\"Key\"), \"${filename}\") {\n \t\t// S3 feature to replace ${filename} found in Key form field\n \t\t// by the filename attribute passed in multipart\n@@ -866,12 +867,51 @@ func (api objectAPIHandlers) PostPolicyBucketHandler(w http.ResponseWriter, r *h\n \t}\n \n \t// Verify policy signature.\n-\terrCode := doesPolicySignatureMatch(formValues)\n+\tcred, errCode := doesPolicySignatureMatch(formValues)\n \tif errCode != ErrNone {\n \t\twriteErrorResponse(ctx, w, errorCodes.ToAPIErr(errCode), r.URL, guessIsBrowserReq(r))\n \t\treturn\n \t}\n \n+\t// Once signature is validated, check if the user has\n+\t// explicit permissions for the user.\n+\t{\n+\t\ttoken := formValues.Get(xhttp.AmzSecurityToken)\n+\t\tif token != \"\" && cred.AccessKey == \"\" {\n+\t\t\twriteErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrNoAccessKey), r.URL, guessIsBrowserReq(r))\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif cred.IsServiceAccount() && token == \"\" {\n+\t\t\ttoken = cred.SessionToken\n+\t\t}\n+\n+\t\tif subtle.ConstantTimeCompare([]byte(token), []byte(cred.SessionToken)) != 1 {\n+\t\t\twriteErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidToken), r.URL, guessIsBrowserReq(r))\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Extract claims if any.\n+\t\tclaims, err := getClaimsFromToken(token)\n+\t\tif err != nil {\n+\t\t\twriteErrorResponse(ctx, w, toAPIError(ctx, err), r.URL, guessIsBrowserReq(r))\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n+\t\t\tAccountName:     cred.AccessKey,\n+\t\t\tAction:          iampolicy.PutObjectAction,\n+\t\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n+\t\t\tBucketName:      bucket,\n+\t\t\tObjectName:      object,\n+\t\t\tIsOwner:         globalActiveCred.AccessKey == cred.AccessKey,\n+\t\t\tClaims:          claims,\n+\t\t}) {\n+\t\t\twriteErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL, guessIsBrowserReq(r))\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n \tpolicyBytes, err := base64.StdEncoding.DecodeString(formValues.Get(\"Policy\"))\n \tif err != nil {\n \t\twriteErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrMalformedPOSTRequest), r.URL, guessIsBrowserReq(r))"
        },
        {
          "filename": "cmd/signature-v2.go",
          "status": "modified",
          "additions": 4,
          "deletions": 6,
          "patch": "@@ -75,20 +75,18 @@ const (\n \n // AWS S3 Signature V2 calculation rule is give here:\n // http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html#RESTAuthenticationStringToSign\n-\n-func doesPolicySignatureV2Match(formValues http.Header) APIErrorCode {\n-\tcred := globalActiveCred\n+func doesPolicySignatureV2Match(formValues http.Header) (auth.Credentials, APIErrorCode) {\n \taccessKey := formValues.Get(xhttp.AmzAccessKeyID)\n \tcred, _, s3Err := checkKeyValid(accessKey)\n \tif s3Err != ErrNone {\n-\t\treturn s3Err\n+\t\treturn cred, s3Err\n \t}\n \tpolicy := formValues.Get(\"Policy\")\n \tsignature := formValues.Get(xhttp.AmzSignatureV2)\n \tif !compareSignatureV2(signature, calculateSignatureV2(policy, cred.SecretKey)) {\n-\t\treturn ErrSignatureDoesNotMatch\n+\t\treturn cred, ErrSignatureDoesNotMatch\n \t}\n-\treturn ErrNone\n+\treturn cred, ErrNone\n }\n \n // Escape encodedQuery string into unescaped list of query params, returns error"
        },
        {
          "filename": "cmd/signature-v2_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -265,7 +265,7 @@ func TestDoesPolicySignatureV2Match(t *testing.T) {\n \t\tformValues.Set(\"Awsaccesskeyid\", test.accessKey)\n \t\tformValues.Set(\"Signature\", test.signature)\n \t\tformValues.Set(\"Policy\", test.policy)\n-\t\terrCode := doesPolicySignatureV2Match(formValues)\n+\t\t_, errCode := doesPolicySignatureV2Match(formValues)\n \t\tif errCode != test.errCode {\n \t\t\tt.Fatalf(\"(%d) expected to get %s, instead got %s\", i+1, niceError(test.errCode), niceError(errCode))\n \t\t}"
        },
        {
          "filename": "cmd/signature-v4.go",
          "status": "modified",
          "additions": 7,
          "deletions": 6,
          "patch": "@@ -39,6 +39,7 @@ import (\n \t\"github.com/minio/minio-go/v7/pkg/s3utils\"\n \t\"github.com/minio/minio-go/v7/pkg/set\"\n \txhttp \"github.com/minio/minio/cmd/http\"\n+\t\"github.com/minio/minio/pkg/auth\"\n )\n \n // AWS Signature Version '4' constants.\n@@ -149,7 +150,7 @@ func getSignature(signingKey []byte, stringToSign string) string {\n }\n \n // Check to see if Policy is signed correctly.\n-func doesPolicySignatureMatch(formValues http.Header) APIErrorCode {\n+func doesPolicySignatureMatch(formValues http.Header) (auth.Credentials, APIErrorCode) {\n \t// For SignV2 - Signature field will be valid\n \tif _, ok := formValues[\"Signature\"]; ok {\n \t\treturn doesPolicySignatureV2Match(formValues)\n@@ -169,19 +170,19 @@ func compareSignatureV4(sig1, sig2 string) bool {\n // doesPolicySignatureMatch - Verify query headers with post policy\n //     - http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-HTTPPOSTConstructPolicy.html\n // returns ErrNone if the signature matches.\n-func doesPolicySignatureV4Match(formValues http.Header) APIErrorCode {\n+func doesPolicySignatureV4Match(formValues http.Header) (auth.Credentials, APIErrorCode) {\n \t// Server region.\n \tregion := globalServerRegion\n \n \t// Parse credential tag.\n \tcredHeader, s3Err := parseCredentialHeader(\"Credential=\"+formValues.Get(xhttp.AmzCredential), region, serviceS3)\n \tif s3Err != ErrNone {\n-\t\treturn s3Err\n+\t\treturn auth.Credentials{}, s3Err\n \t}\n \n \tcred, _, s3Err := checkKeyValid(credHeader.accessKey)\n \tif s3Err != ErrNone {\n-\t\treturn s3Err\n+\t\treturn cred, s3Err\n \t}\n \n \t// Get signing key.\n@@ -192,11 +193,11 @@ func doesPolicySignatureV4Match(formValues http.Header) APIErrorCode {\n \n \t// Verify signature.\n \tif !compareSignatureV4(newSignature, formValues.Get(xhttp.AmzSignature)) {\n-\t\treturn ErrSignatureDoesNotMatch\n+\t\treturn cred, ErrSignatureDoesNotMatch\n \t}\n \n \t// Success.\n-\treturn ErrNone\n+\treturn cred, ErrNone\n }\n \n // doesPresignedSignatureMatch - Verify query headers with presigned signature"
        },
        {
          "filename": "cmd/signature-v4_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -84,7 +84,7 @@ func TestDoesPolicySignatureMatch(t *testing.T) {\n \n \t// Run each test case individually.\n \tfor i, testCase := range testCases {\n-\t\tcode := doesPolicySignatureMatch(testCase.form)\n+\t\t_, code := doesPolicySignatureMatch(testCase.form)\n \t\tif code != testCase.expected {\n \t\t\tt.Errorf(\"(%d) expected to get %s, instead got %s\", i, niceError(testCase.expected), niceError(code))\n \t\t}"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c5d19ecebb67952ea69bae6a5495f394b42896c3",
            "date": "2025-01-24T19:27:43Z",
            "author_login": "harshavardhana"
          },
          {
            "sha": "ed29a525b398aa57e9ff419806796e61b44873d7",
            "date": "2025-01-21T10:10:10Z",
            "author_login": "harshavardhana"
          },
          {
            "sha": "020c46cd3c2841fa2bc0608de1f83d2d43d5c485",
            "date": "2025-01-21T09:44:32Z",
            "author_login": "minio-trusted"
          },
          {
            "sha": "827004cd6d3da8f49a5320c94ae74ae128156ed6",
            "date": "2025-01-20T14:49:07Z",
            "author_login": "klauspost"
          },
          {
            "sha": "779ec8f0d423ee8114ef752628f4208c69c78445",
            "date": "2025-01-19T23:13:17Z",
            "author_login": "harshavardhana"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.7,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:H/A:N",
    "cwe_id": "CWE-285",
    "description": "MinIO is an open-source high performance object storage service and it is API compatible with Amazon S3 cloud storage service. In MinIO before version RELEASE.2021-03-04T00-53-13Z it is possible to bypass a readOnly policy by creating a temporary 'mc share upload' URL. Everyone is impacted who uses MinIO multi-users. This is fixed in version RELEASE.2021-03-04T00-53-13Z. As a workaround, one can disable uploads with `Content-Type: multipart/form-data` as mentioned in the S3 API RESTObjectPOST docs by using a proxy in front of MinIO.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-03-08T19:15:13.443",
    "last_modified": "2024-11-21T05:48:12.000",
    "fix_date": "2021-03-03T16:47:08Z"
  },
  "references": [
    {
      "url": "https://github.com/minio/minio/commit/039f59b552319fcc2f83631bb421a7d4b82bc482",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/minio/minio/pull/11682",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/minio/minio/releases/tag/RELEASE.2021-03-04T00-53-13Z",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/minio/minio/security/advisories/GHSA-hq5j-6r98-9m8v",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/minio/minio/commit/039f59b552319fcc2f83631bb421a7d4b82bc482",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/minio/minio/pull/11682",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/minio/minio/releases/tag/RELEASE.2021-03-04T00-53-13Z",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/minio/minio/security/advisories/GHSA-hq5j-6r98-9m8v",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:16.825569",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "minio",
    "owner": "minio",
    "created_at": "2015-01-14T19:23:58Z",
    "updated_at": "2025-01-26T06:11:32Z",
    "pushed_at": "2025-01-24T19:27:43Z",
    "size": 132274,
    "stars": 49715,
    "forks": 5636,
    "open_issues": 35,
    "watchers": 49715,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master",
      "release"
    ],
    "languages": {
      "Go": 8678603,
      "Shell": 71969,
      "Makefile": 11634,
      "Mustache": 6628,
      "Smarty": 872,
      "Dockerfile": 229
    },
    "commit_activity": {
      "total_commits_last_year": 893,
      "avg_commits_per_week": 17.173076923076923,
      "days_active_last_year": 266
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "agpl-3.0"
    },
    "collected_at": "2025-01-26T08:11:02.719445"
  }
}