{
  "cve_id": "CVE-2021-21378",
  "github_data": {
    "repository": "envoyproxy/envoy",
    "fix_commit": "ea39e3cba652bcc4b11bb0d5c62b017e584d2e5a",
    "related_commits": [
      "ea39e3cba652bcc4b11bb0d5c62b017e584d2e5a",
      "ea39e3cba652bcc4b11bb0d5c62b017e584d2e5a"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "ea39e3cba652bcc4b11bb0d5c62b017e584d2e5a",
      "commit_date": "2021-02-26T00:49:10Z",
      "author": {
        "login": "qiwzhang",
        "type": "User",
        "stats": {
          "total_commits": 73,
          "average_weekly_commits": 0.16478555304740405,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 62
        }
      },
      "commit_message": {
        "title": "jwt_authn: fix a bug where JWT with wrong issuer is allowed in allow_missing case (#15194)",
        "length": 411,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 35,
        "additions": 22,
        "deletions": 13
      },
      "files": [
        {
          "filename": "docs/root/version_history/current.rst",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -58,6 +58,7 @@ Bug Fixes\n * grpc_http_bridge: the downstream HTTP status is now correctly set for trailers-only responses from the upstream.\n * http: disallowing \"host:\" in request_headers_to_add for behavioral consistency with rejecting :authority header. This behavior can be temporarily reverted by setting `envoy.reloadable_features.treat_host_like_authority` to false.\n * http: reverting a behavioral change where upstream connect timeouts were temporarily treated differently from other connection failures. The change back to the original behavior can be temporarily reverted by setting `envoy.reloadable_features.treat_upstream_connect_timeout_as_connect_failure` to false.\n+* jwt_authn: reject requests with a proper error if JWT has the wrong issuer when allow_missing is used. Before this change, the requests are accepted.\n * listener: prevent crashing when an unknown listener config proto is received and debug logging is enabled.\n * overload: fix a bug that can cause use-after-free when one scaled timer disables another one with the same duration.\n * sni: as the server name in sni should be case-insensitive, envoy will convert the server name as lower case first before any other process inside envoy."
        },
        {
          "filename": "source/extensions/filters/http/jwt_authn/verifier.cc",
          "status": "modified",
          "additions": 7,
          "deletions": 8,
          "patch": "@@ -301,17 +301,16 @@ class AnyVerifierImpl : public BaseGroupVerifierImpl {\n     // Then wait for all children to be done.\n     if (++completion_state.number_completed_children_ == verifiers_.size()) {\n       // Aggregate all children status into a final status.\n-      // JwtMissing should be treated differently than other failure status\n-      // since it simply means there is not Jwt token for the required provider.\n-      // If there is a failure status other than JwtMissing in the children,\n-      // it should be used as the final status.\n+      // JwtMissed and JwtUnknownIssuer should be treated differently than other errors.\n+      // JwtMissed means not Jwt token for the required provider.\n+      // JwtUnknownIssuer means wrong issuer for the required provider.\n       Status final_status = Status::JwtMissed;\n       for (const auto& it : verifiers_) {\n-        // If a Jwt is extracted from a location not specified by the required provider,\n-        // the authenticator returns JwtUnknownIssuer. It should be treated the same as\n-        // JwtMissed.\n+        // Prefer errors which are not JwtMissed nor JwtUnknownIssuer.\n+        // Prefer JwtUnknownIssuer between JwtMissed and JwtUnknownIssuer.\n         Status child_status = context.getCompletionState(it.get()).status_;\n-        if (child_status != Status::JwtMissed && child_status != Status::JwtUnknownIssuer) {\n+        if ((child_status != Status::JwtMissed && child_status != Status::JwtUnknownIssuer) ||\n+            final_status == Status::JwtMissed) {\n           final_status = child_status;\n         }\n       }"
        },
        {
          "filename": "test/extensions/filters/http/jwt_authn/all_verifier_test.cc",
          "status": "modified",
          "additions": 11,
          "deletions": 2,
          "patch": "@@ -197,7 +197,7 @@ TEST_F(SingleAllowMissingInOrListTest, BadJwt) {\n }\n \n TEST_F(SingleAllowMissingInOrListTest, MissingIssToken) {\n-  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n+  EXPECT_CALL(mock_cb_, onComplete(Status::JwtUnknownIssuer));\n   auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ES256WithoutIssToken}};\n   context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n   verifier_->verify(context_);\n@@ -471,6 +471,15 @@ TEST_F(AllowMissingInOrListTest, OtherGoodJwt) {\n   EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n }\n \n+TEST_F(AllowMissingInOrListTest, WrongIssuer) {\n+  EXPECT_CALL(mock_cb_, onComplete(Status::JwtUnknownIssuer));\n+  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, OtherGoodToken}};\n+  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n+  verifier_->verify(context_);\n+  // x-other JWT should be ignored.\n+  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n+}\n+\n TEST_F(AllowMissingInOrListTest, BadAndGoodJwts) {\n   EXPECT_CALL(mock_cb_, onComplete(Status::JwtVerificationFail));\n   auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, NonExistKidToken},\n@@ -589,7 +598,7 @@ TEST_F(AllowMissingInAndOfOrListTest, TwoGoodJwts) {\n }\n \n TEST_F(AllowMissingInAndOfOrListTest, GoodAndBadJwts) {\n-  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n+  EXPECT_CALL(mock_cb_, onComplete(Status::JwtUnknownIssuer));\n   // Use the token with example.com issuer for x-other.\n   auto headers =\n       Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, GoodToken}};"
        },
        {
          "filename": "test/extensions/filters/http/jwt_authn/group_verifier_test.cc",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -582,8 +582,8 @@ TEST_F(GroupVerifierTest, TestRequiresAnyWithAllowMissingButFailed) {\n   callbacks_[\"other_provider\"](Status::JwtExpired);\n }\n \n-// Test RequiresAny with two providers and allow_missing, but OK\n-TEST_F(GroupVerifierTest, TestRequiresAnyWithAllowMissingButOk) {\n+// Test RequiresAny with two providers and allow_missing, but one returns JwtUnknownIssuer\n+TEST_F(GroupVerifierTest, TestRequiresAnyWithAllowMissingButUnknownIssuer) {\n   TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n   proto_config_.mutable_rules(0)\n       ->mutable_requires()\n@@ -592,7 +592,7 @@ TEST_F(GroupVerifierTest, TestRequiresAnyWithAllowMissingButOk) {\n       ->mutable_allow_missing();\n \n   createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n-  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n+  EXPECT_CALL(mock_cb_, onComplete(Status::JwtUnknownIssuer));\n \n   auto headers = Http::TestRequestHeaderMapImpl{};\n   context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);"
        }
      ],
      "file_patterns": {
        "security_files": 3,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 3,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "38a7619e5c5d23d279e75ca1bb67a55d1e3d766f",
            "date": "2025-01-26T08:27:27Z",
            "author_login": "ae-govau"
          },
          {
            "sha": "5f7ee8585fd3324925fa694030ce127db746f9ed",
            "date": "2025-01-26T08:12:00Z",
            "author_login": "antoniovleonti"
          },
          {
            "sha": "ad2a1c700b1cc6c8b1581bc3e2990d696501f105",
            "date": "2025-01-24T15:25:19Z",
            "author_login": "asedeno"
          },
          {
            "sha": "969348a552e76101e5dadde6b8f65694a5198fdf",
            "date": "2025-01-24T11:36:03Z",
            "author_login": "zirain"
          },
          {
            "sha": "2a9c998e1732f07f597acfa10c23342730c8fdc4",
            "date": "2025-01-24T11:11:22Z",
            "author_login": "krinkinmu"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.2,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N",
    "cwe_id": "CWE-287",
    "description": "Envoy is a cloud-native high-performance edge/middle/service proxy. In Envoy version 1.17.0 an attacker can bypass authentication by presenting a JWT token with an issuer that is not in the provider list when Envoy's JWT Authentication filter is configured with the `allow_missing` requirement under `requires_any` due to a mistake in implementation. Envoy's JWT Authentication filter can be configured with the `allow_missing` requirement that will be satisfied if JWT is missing (JwtMissed error) and fail if JWT is presented or invalid. Due to a mistake in implementation, a JwtUnknownIssuer error was mistakenly converted to JwtMissed when `requires_any` was configured. So if `allow_missing` was configured under `requires_any`, an attacker can bypass authentication by presenting a JWT token with an issuer that is not in the provider list. Integrity may be impacted depending on configuration if the JWT token is used to protect against writes or modifications. This regression was introduced on 2020/11/12 in PR 13839 which fixed handling `allow_missing` under RequiresAny in a JwtRequirement (see issue 13458). The AnyVerifier aggregates the children verifiers' results into a final status where JwtMissing is the default error. However, a JwtUnknownIssuer was mistakenly treated the same as a JwtMissing error and the resulting final aggregation was the default JwtMissing. As a result, `allow_missing` would allow a JWT token with an unknown issuer status. This is fixed in version 1.17.1 by PR 15194. The fix works by preferring JwtUnknownIssuer over a JwtMissing error, fixing the accidental conversion and bypass with `allow_missing`. A user could detect whether a bypass occurred if they have Envoy logs enabled with debug verbosity. Users can enable component level debug logs for JWT. The JWT filter logs will indicate that there is a request with a JWT token and a failure that the JWT token is missing.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-03-11T03:15:12.163",
    "last_modified": "2024-11-21T05:48:14.037",
    "fix_date": "2021-02-26T00:49:10Z"
  },
  "references": [
    {
      "url": "https://github.com/envoyproxy/envoy/commit/ea39e3cba652bcc4b11bb0d5c62b017e584d2e5a",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/pull/15194",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-4996-m8hf-hj27",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/commit/ea39e3cba652bcc4b11bb0d5c62b017e584d2e5a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/pull/15194",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-4996-m8hf-hj27",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:16.834257",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "envoy",
    "owner": "envoyproxy",
    "created_at": "2016-08-08T15:07:24Z",
    "updated_at": "2025-01-26T06:15:25Z",
    "pushed_at": "2025-01-24T15:25:20Z",
    "size": 241791,
    "stars": 25373,
    "forks": 4864,
    "open_issues": 1660,
    "watchers": 25373,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C++": 48447088,
      "Starlark": 3112278,
      "Java": 1321815,
      "Python": 604443,
      "Assembly": 327095,
      "Kotlin": 309606,
      "Swift": 250537,
      "Shell": 231950,
      "Go": 183281,
      "Rust": 107631,
      "JavaScript": 66339,
      "C": 61597,
      "Objective-C++": 55490,
      "Objective-C": 48840,
      "Jinja": 47798,
      "Smarty": 3528,
      "CSS": 2927,
      "HTML": 1522,
      "Emacs Lisp": 966,
      "Dockerfile": 960,
      "Thrift": 748,
      "PureBasic": 472,
      "Batchfile": 439,
      "Makefile": 303
    },
    "commit_activity": {
      "total_commits_last_year": 3237,
      "avg_commits_per_week": 62.25,
      "days_active_last_year": 300
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:41:58.674890"
  }
}