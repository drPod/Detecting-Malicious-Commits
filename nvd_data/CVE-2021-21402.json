{
  "cve_id": "CVE-2021-21402",
  "github_data": {
    "repository": "jellyfin/jellyfin",
    "fix_commit": "0183ef8e89195f420c48d2600bc0b72f6d3a7fd7",
    "related_commits": [
      "0183ef8e89195f420c48d2600bc0b72f6d3a7fd7",
      "0183ef8e89195f420c48d2600bc0b72f6d3a7fd7"
    ],
    "patch_url": "https://github.com/jellyfin/jellyfin/commit/0183ef8e89195f420c48d2600bc0b72f6d3a7fd7.patch",
    "fix_commit_details": {
      "sha": "0183ef8e89195f420c48d2600bc0b72f6d3a7fd7",
      "commit_date": "2021-03-21T23:12:14Z",
      "author": {
        "login": "joshuaboniface",
        "type": "User",
        "stats": {
          "total_commits": 1057,
          "average_weekly_commits": 1.696629213483146,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 156
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-wg4c-c9g9-rxhx",
        "length": 211,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 70,
        "additions": 61,
        "deletions": 9
      },
      "files": [
        {
          "filename": "Jellyfin.Api/Controllers/HlsSegmentController.cs",
          "status": "modified",
          "additions": 20,
          "deletions": 3,
          "patch": "@@ -63,7 +63,13 @@ public ActionResult GetHlsAudioSegmentLegacy([FromRoute, Required] string itemId\n         {\n             // TODO: Deprecate with new iOS app\n             var file = segmentId + Path.GetExtension(Request.Path);\n-            file = Path.Combine(_serverConfigurationManager.GetTranscodePath(), file);\n+            var transcodePath = _serverConfigurationManager.GetTranscodePath();\n+            file = Path.GetFullPath(Path.Combine(transcodePath, file));\n+            var fileDir = Path.GetDirectoryName(file);\n+            if (string.IsNullOrEmpty(fileDir) || !fileDir.StartsWith(transcodePath))\n+            {\n+                return BadRequest(\"Invalid segment.\");\n+            }\n \n             return FileStreamResponseHelpers.GetStaticFileResult(file, MimeTypes.GetMimeType(file)!, false, HttpContext);\n         }\n@@ -83,7 +89,13 @@ public ActionResult GetHlsAudioSegmentLegacy([FromRoute, Required] string itemId\n         public ActionResult GetHlsPlaylistLegacy([FromRoute, Required] string itemId, [FromRoute, Required] string playlistId)\n         {\n             var file = playlistId + Path.GetExtension(Request.Path);\n-            file = Path.Combine(_serverConfigurationManager.GetTranscodePath(), file);\n+            var transcodePath = _serverConfigurationManager.GetTranscodePath();\n+            file = Path.GetFullPath(Path.Combine(transcodePath, file));\n+            var fileDir = Path.GetDirectoryName(file);\n+            if (string.IsNullOrEmpty(fileDir) || !fileDir.StartsWith(transcodePath) || Path.GetExtension(file) != \".m3u8\")\n+            {\n+                return BadRequest(\"Invalid segment.\");\n+            }\n \n             return GetFileResult(file, file);\n         }\n@@ -132,7 +144,12 @@ public ActionResult GetHlsVideoSegmentLegacy(\n             var file = segmentId + Path.GetExtension(Request.Path);\n             var transcodeFolderPath = _serverConfigurationManager.GetTranscodePath();\n \n-            file = Path.Combine(transcodeFolderPath, file);\n+            file = Path.GetFullPath(Path.Combine(transcodeFolderPath, file));\n+            var fileDir = Path.GetDirectoryName(file);\n+            if (string.IsNullOrEmpty(fileDir) || !fileDir.StartsWith(transcodeFolderPath))\n+            {\n+                return BadRequest(\"Invalid segment.\");\n+            }\n \n             var normalizedPlaylistId = playlistId;\n "
        },
        {
          "filename": "Jellyfin.Api/Controllers/ImageByNameController.cs",
          "status": "modified",
          "additions": 20,
          "deletions": 3,
          "patch": "@@ -74,14 +74,19 @@ public ActionResult GetGeneralImage([FromRoute, Required] string name, [FromRout\n                 : type;\n \n             var path = BaseItem.SupportedImageExtensions\n-                .Select(i => Path.Combine(_applicationPaths.GeneralPath, name, filename + i))\n+                .Select(i => Path.GetFullPath(Path.Combine(_applicationPaths.GeneralPath, name, filename + i)))\n                 .FirstOrDefault(System.IO.File.Exists);\n \n             if (path == null)\n             {\n                 return NotFound();\n             }\n \n+            if (!path.StartsWith(_applicationPaths.GeneralPath))\n+            {\n+                return BadRequest(\"Invalid image path.\");\n+            }\n+\n             var contentType = MimeTypes.GetMimeType(path);\n             return File(System.IO.File.OpenRead(path), contentType);\n         }\n@@ -163,27 +168,39 @@ public ActionResult GetMediaInfoImage(\n         /// <returns>A <see cref=\"FileStreamResult\"/> containing the image contents on success, or a <see cref=\"NotFoundResult\"/> if the image could not be found.</returns>\n         private ActionResult GetImageFile(string basePath, string theme, string? name)\n         {\n-            var themeFolder = Path.Combine(basePath, theme);\n+            var themeFolder = Path.GetFullPath(Path.Combine(basePath, theme));\n+\n             if (Directory.Exists(themeFolder))\n             {\n                 var path = BaseItem.SupportedImageExtensions.Select(i => Path.Combine(themeFolder, name + i))\n                     .FirstOrDefault(System.IO.File.Exists);\n \n                 if (!string.IsNullOrEmpty(path) && System.IO.File.Exists(path))\n                 {\n+                    if (!path.StartsWith(basePath))\n+                    {\n+                        return BadRequest(\"Invalid image path.\");\n+                    }\n+\n                     var contentType = MimeTypes.GetMimeType(path);\n+\n                     return PhysicalFile(path, contentType);\n                 }\n             }\n \n-            var allFolder = Path.Combine(basePath, \"all\");\n+            var allFolder = Path.GetFullPath(Path.Combine(basePath, \"all\"));\n             if (Directory.Exists(allFolder))\n             {\n                 var path = BaseItem.SupportedImageExtensions.Select(i => Path.Combine(allFolder, name + i))\n                     .FirstOrDefault(System.IO.File.Exists);\n \n                 if (!string.IsNullOrEmpty(path) && System.IO.File.Exists(path))\n                 {\n+                    if (!path.StartsWith(basePath))\n+                    {\n+                        return BadRequest(\"Invalid image path.\");\n+                    }\n+\n                     var contentType = MimeTypes.GetMimeType(path);\n                     return PhysicalFile(path, contentType);\n                 }"
        },
        {
          "filename": "MediaBrowser.Providers/Subtitles/SubtitleManager.cs",
          "status": "modified",
          "additions": 21,
          "deletions": 3,
          "patch": "@@ -205,12 +205,30 @@ private async Task TrySaveSubtitle(\n \n                 if (saveInMediaFolder)\n                 {\n-                    savePaths.Add(Path.Combine(video.ContainingFolderPath, saveFileName));\n+                    var mediaFolderPath = Path.GetFullPath(Path.Combine(video.ContainingFolderPath, saveFileName));\n+                    // TODO: Add some error handling to the API user: return BadRequest(\"Could not save subtitle, bad path.\");\n+                    if (mediaFolderPath.StartsWith(video.ContainingFolderPath))\n+                    {\n+                        savePaths.Add(mediaFolderPath);\n+                    }\n                 }\n \n-                savePaths.Add(Path.Combine(video.GetInternalMetadataPath(), saveFileName));\n+                var internalPath = Path.GetFullPath(Path.Combine(video.GetInternalMetadataPath(), saveFileName));\n+\n+                // TODO: Add some error to the user: return BadRequest(\"Could not save subtitle, bad path.\");\n+                if (internalPath.StartsWith(video.GetInternalMetadataPath()))\n+                {\n+                    savePaths.Add(internalPath);\n+                }\n \n-                await TrySaveToFiles(memoryStream, savePaths).ConfigureAwait(false);\n+                if (savePaths.Count > 0)\n+                {\n+                    await TrySaveToFiles(memoryStream, savePaths).ConfigureAwait(false);\n+                }\n+                else\n+                {\n+                    _logger.LogError(\"An uploaded subtitle could not be saved because the resulting paths were invalid.\");\n+                }\n             }\n         }\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "85e0cad5f3a58668e0dca02b6cb501d2cdcf4a06",
            "date": "2025-01-13T10:07:44Z",
            "author_login": "Bond-009"
          },
          {
            "sha": "0409849cc7dc01b68376a45354e9922dd58fae5b",
            "date": "2025-01-12T04:22:57Z",
            "author_login": "marudosurdo"
          },
          {
            "sha": "4c1a47bc5311c0d15c3ffd42b0c0080a5ae77536",
            "date": "2025-01-11T20:26:51Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "fb5da641f418f5e696d3d021fa3638bde456e981",
            "date": "2025-01-11T16:37:28Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "fd3057b54957a8980acf90ade54d38341e6d695d",
            "date": "2025-01-11T16:37:13Z",
            "author_login": "nielsvanvelzen"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.7,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N",
    "cwe_id": "CWE-22",
    "description": "Jellyfin is a Free Software Media System. In Jellyfin before version 10.7.1, with certain endpoints, well crafted requests will allow arbitrary file read from a Jellyfin server's file system. This issue is more prevalent when Windows is used as the host OS. Servers that are exposed to the public Internet are potentially at risk. This is fixed in version 10.7.1. As a workaround, users may be able to restrict some access by enforcing strict security permissions on their filesystem, however, it is recommended to update as soon as possible.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-03-23T20:15:13.120",
    "last_modified": "2024-11-21T05:48:17.040",
    "fix_date": "2021-03-21T23:12:14Z"
  },
  "references": [
    {
      "url": "https://github.com/jellyfin/jellyfin/commit/0183ef8e89195f420c48d2600bc0b72f6d3a7fd7",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/jellyfin/jellyfin/releases/tag/v10.7.1",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/jellyfin/jellyfin/security/advisories/GHSA-wg4c-c9g9-rxhx",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/jellyfin/jellyfin/commit/0183ef8e89195f420c48d2600bc0b72f6d3a7fd7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/jellyfin/jellyfin/releases/tag/v10.7.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/jellyfin/jellyfin/security/advisories/GHSA-wg4c-c9g9-rxhx",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:16.857400",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "jellyfin",
    "owner": "jellyfin",
    "created_at": "2018-12-09T06:36:45Z",
    "updated_at": "2025-01-14T17:21:41Z",
    "pushed_at": "2025-01-14T14:01:31Z",
    "size": 65488,
    "stars": 36462,
    "forks": 3298,
    "open_issues": 607,
    "watchers": 36462,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master",
      "release-10.1.0",
      "release-10.2.z",
      "release-10.3.z",
      "release-10.4.z",
      "release-10.5.z",
      "release-10.6.z",
      "release-10.7.z",
      "release-10.8.z",
      "release-10.9.z",
      "release-10.10.z"
    ],
    "languages": {
      "C#": 8009710,
      "HTML": 20081,
      "Shell": 3658,
      "CSS": 329
    },
    "commit_activity": {
      "total_commits_last_year": 1480,
      "avg_commits_per_week": 28.46153846153846,
      "days_active_last_year": 314
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T17:23:28.929778"
  }
}