{
  "cve_id": "CVE-2021-21413",
  "github_data": {
    "repository": "laverdet/isolated-vm",
    "fix_commit": "2646e6c1558bac66285daeab54c7d490ed332b15",
    "related_commits": [
      "2646e6c1558bac66285daeab54c7d490ed332b15",
      "27151bfecc260e96714443613880e3b2e6596704",
      "2646e6c1558bac66285daeab54c7d490ed332b15",
      "27151bfecc260e96714443613880e3b2e6596704"
    ],
    "patch_url": "https://github.com/laverdet/isolated-vm/commit/2646e6c1558bac66285daeab54c7d490ed332b15.patch",
    "fix_commit_details": {
      "sha": "2646e6c1558bac66285daeab54c7d490ed332b15",
      "commit_date": "2021-03-20T19:40:07Z",
      "author": {
        "login": "laverdet",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Don't invoke accessors or proxies via Reference functions",
        "length": 57,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 370,
        "additions": 249,
        "deletions": 121
      },
      "files": [
        {
          "filename": "CHANGELOG.md",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,8 +1,9 @@\n ## v4.0.0\n - `Callback` class addeed.\n-- When possible, `reference.get()` will return a function proxy instead of a `Reference`.\n+- When possible, `reference.get()` will return a function delegate instead of a `Reference`.\n - `reference.get()` will no longer return inherited properties by default.\n - `result` property on `eval` and `evalClosure` has been removed. The result is now just the return\n value.\n - All `isolated-vm` class prototypes, and most instances are frozen.\n - `isolate.cpuTime` and `isolate.wallTime` now return bigints.\n+- Proxies and accessors are no longer tolerated via `reference.get`, and related functions."
        },
        {
          "filename": "README.md",
          "status": "modified",
          "additions": 3,
          "deletions": 6,
          "patch": "@@ -344,7 +344,7 @@ A instance of [`Reference`](#class-reference-transferable) is a pointer to a val\n ##### `new ivm.Reference(value, options)`\n * `value` - The value to create a reference to.\n * `options` *[object]*\n-  * `inheritUnsafe` *[boolean]* - If enabled then the `get` family of functions will follow the\n+  * `unsafeInherit` *[boolean]* - If enabled then the `get` family of functions will follow the\n     object's prototype chain. References created with this option should never be given to untrusted\n     code.\n \n@@ -388,7 +388,6 @@ all attempts to access the reference will throw an error.\n ##### `reference.deleteIgnored(property)`\n ##### `reference.deleteSync(property)`\n * `property` *[transferable]* - The property to access on this object.\n-* **return** `true` or `false`\n \n Delete a property from this reference, as if using `delete reference[property]`\n \n@@ -401,17 +400,15 @@ Delete a property from this reference, as if using `delete reference[property]`\n \n Will access a reference as if using `reference[property]` and transfer the value out.\n \n+If the object is a proxy, or if the property is a getter, this method will throw.\n+\n ##### `reference.set(property, value, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n ##### `reference.setIgnored(property, value, options)`\n ##### `reference.setSync(property, value, options)`\n * `property` *[transferable]* - The property to set on this object.\n * `value` *[transferable]* - The value to set on this object.\n * `options` *[object]*\n \t* [`{ ...TransferOptions }`](#transferoptions)\n-* **return** `true` or `false`\n-\n-Returns a boolean indicating whether or not this operation succeeded. I'm actually not really sure\n-when `false` would be returned, I'm just giving you the result back straight from the v8 API.\n \n ##### `reference.apply(receiver, arguments, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n ##### `reference.applyIgnored(receiver, arguments, options)`"
        },
        {
          "filename": "isolated-vm.d.ts",
          "status": "modified",
          "additions": 17,
          "deletions": 15,
          "patch": "@@ -9,10 +9,12 @@ declare module \"isolated-vm\" {\n \t\t| Context\n \t\t| Script\n \t\t| ExternalCopy<any>\n+\t\t| Callback<any>\n \t\t| Copy<any>\n \t\t| Reference<any>\n \t\t| Dereference<any>\n \t\t| Module\n+\t\t| ((...args: any[]) => any)\n \t\t| typeof import(\"isolated-vm\");\n \n \t/**\n@@ -284,7 +286,7 @@ declare module \"isolated-vm\" {\n \t */\n \texport class Reference<T = any> {\n \t\tprivate __ivm_reference: T;\n-\t\tconstructor(value: T, options?: { inheritUnsafe?: boolean });\n+\t\tconstructor(value: T, options?: { unsafeInherit?: boolean });\n \n \t\t/**\n \t\t * This is the typeof the referenced value, and is available at any time\n@@ -331,31 +333,29 @@ declare module \"isolated-vm\" {\n \t\t/**\n \t\t * Delete a property from this reference, as if using `delete reference[property]`\n \t\t */\n-\t\t delete(property: keyof T): Promise<boolean>;\n+\t\t delete(property: keyof T): Promise<void>;\n \t\t deleteIgnored(property: keyof T): void;\n-\t\t deleteSync(property: keyof T): boolean;\n+\t\t deleteSync(property: keyof T): void;\n \n \t\t/**\n \t\t * Will access a reference as if using reference[property] and return a reference to that value.\n+\t\t *\n+\t\t * If the object is a proxy, or if the property is a getter, this method will throw.\n \t\t */\n \t\tget<Options extends TransferOptions, Key extends keyof T>(\n-\t\t\tproperty: Key, options?: Options): ResultTypeAsync<Options & AsReference, T[Key]>;\n+\t\t\tproperty: Key, options?: Options): ResultTypeAsync<Options & FallbackReference, T[Key]>;\n \t\tgetSync<Options extends TransferOptions, Key extends keyof T>(\n-\t\t\tproperty: Key, options?: Options): ResultTypeSync<Options & AsReference, T[Key]>;\n+\t\t\tproperty: Key, options?: Options): ResultTypeSync<Options & FallbackReference, T[Key]>;\n \n \t\t/**\n \t\t * Will access a reference as if using reference[property] and return a reference to that value.\n-\t\t *\n-\t\t * @return {boolean} Indicating whether or not this operation succeeded. I'm actually not really\n-\t\t * sure when false would be returned, I'm just giving you the result back straight from the v8\n-\t\t * API.\n \t\t */\n \t\tset<Options extends TransferOptions, Key extends keyof T>(\n-\t\t\tproperty: Key, value: ArgumentType<Options, T[Key]>, options?: Options): Promise<boolean>;\n+\t\t\tproperty: Key, value: ArgumentType<Options, T[Key]>, options?: Options): Promise<void>;\n \t\tsetIgnored<Options extends TransferOptions, Key extends keyof T>(\n \t\t\tproperty: Key, value: ArgumentType<Options, T[Key]>, options?: Options): void;\n \t\tsetSync<Options extends TransferOptions, Key extends keyof T>(\n-\t\t\tproperty: Key, value: ArgumentType<Options, T[Key]>, options?: Options): boolean;\n+\t\t\tproperty: Key, value: ArgumentType<Options, T[Key]>, options?: Options): void;\n \n \t\t/**\n \t\t * Will attempt to invoke an object as if it were a function. If the return\n@@ -366,17 +366,17 @@ declare module \"isolated-vm\" {\n \t\t\treceiver?: ArgumentType<Options['arguments'], ApplyArgumentThis<T>>,\n \t\t\targuments?: ArgumentsTypeBidirectional<Options, ApplyArguments<T>>,\n \t\t\toptions?: Options\n-\t\t): ResultTypeBidirectionalAsync<Options & ApplyAsReference, ApplyResult<T>>;\n+\t\t): ResultTypeBidirectionalAsync<Options & FallbackReference, ApplyResult<T>>;\n \t\tapplyIgnored<Options extends ReferenceApplyOptions>(\n \t\t\treceiver?: ArgumentType<Options['arguments'], ApplyArgumentThis<T>>,\n-\t\t\targuments?: ArgumentsTypeBidirectional<Options & ApplyAsReference, ApplyArguments<T>>,\n+\t\t\targuments?: ArgumentsTypeBidirectional<Options & FallbackReference, ApplyArguments<T>>,\n \t\t\toptions?: Options\n \t\t): void;\n \t\tapplySync<Options extends ReferenceApplyOptions>(\n \t\t\treceiver?: ArgumentType<Options['arguments'], ApplyArgumentThis<T>>,\n \t\t\targuments?: ArgumentsTypeBidirectional<Options, ApplyArguments<T>>,\n \t\t\toptions?: Options\n-\t\t): ResultTypeBidirectionalSync<Options & ApplyAsReference, ApplyResult<T>>;\n+\t\t): ResultTypeBidirectionalSync<Options & FallbackReference, ApplyResult<T>>;\n \n \t\t/**\n \t\t * `applySyncPromise` is a special version of `applySync` which may only be invoked on functions\n@@ -392,7 +392,7 @@ declare module \"isolated-vm\" {\n \t\t\treceiver?: ArgumentType<Options['arguments'], ApplyArgumentThis<T>>,\n \t\t\targuments?: ArgumentsTypeBidirectional<Options, ApplyArguments<T>>,\n \t\t\toptions?: Options\n-\t\t): ResultTypeBidirectionalSync<Options & ApplyAsReference, ApplyResult<T>>;\n+\t\t): ResultTypeBidirectionalSync<Options & FallbackReference, ApplyResult<T>>;\n \t}\n \n \t/**\n@@ -707,6 +707,7 @@ declare module \"isolated-vm\" {\n \ttype AsCopy = { copy: true };\n \ttype AsExternal = { externalCopy: true };\n \ttype AsReference = { reference: true };\n+\ttype FallbackReference = { _reference: true };\n \ttype ApplyAsReference = { result: AsReference };\n \ttype WithTransfer = AsCopy | AsExternal | AsReference;\n \n@@ -727,6 +728,7 @@ declare module \"isolated-vm\" {\n \t\tOptions extends AsReference ? Reference<Result> :\n \t\tResult extends Transferable ? Result :\n \t\tResult extends void ? void :\n+\t\tOptions extends FallbackReference ? Reference<Result> :\n \t\tTransferable;\n \ttype ResultTypeAsync<Options extends TransferOptions, Result = any> = Promise<ResultTypeBase<Options, Result>>;\n \ttype ResultTypeSync<Options extends TransferOptions, Result = any> = CheckPromise<Options, ResultTypeBase<Options, Result>>;"
        },
        {
          "filename": "src/isolate/strings.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -58,7 +58,6 @@ class StringTable {\n \t\tString function{\"function\"};\n \t\tString global{\"global\"};\n \t\tString ignored{\"ignored\"};\n-\t\tString inheritUnsafe{\"inheritUnsafe\"};\n \t\tString inspector{\"inspector\"};\n \t\tString isolateIsDisposed{\"Isolate is disposed\"};\n \t\tString isolatedVm{\"isolated-vm\"};\n@@ -82,6 +81,7 @@ class StringTable {\n \t\tString transferList{\"transferList\"};\n \t\tString transferOut{\"transferOut\"};\n \t\tString undefined{\"undefined\"};\n+\t\tString unsafeInherit{\"unsafeInherit\"};\n \n \t\tString does_zap_garbage{\"does_zap_garbage\"};\n \t\tString externally_allocated_size{\"externally_allocated_size\"};"
        },
        {
          "filename": "src/module/reference_handle.cc",
          "status": "modified",
          "additions": 112,
          "deletions": 82,
          "patch": "@@ -127,7 +127,7 @@ auto ReferenceHandle::Definition() -> Local<FunctionTemplate> {\n }\n \n auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n-\tauto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);\n+\tauto inherit = ReadOption<bool>(options, StringTable::Get().unsafeInherit, false);\n \treturn std::make_unique<ReferenceHandle>(value, inherit);\n }\n \n@@ -426,99 +426,138 @@ auto ReferenceHandle::Copy() -> Local<Value> {\n }\n \n /**\n- * Get a property from this reference, returned as another reference\n+ * Base class for get, set, and delete runners\n  */\n-class GetRunner : public ThreePhaseTask {\n+class AccessorRunner : public ThreePhaseTask {\n \tpublic:\n-\t\tGetRunner(\n-\t\t\tconst ReferenceHandle& that,\n-\t\t\tLocal<Value> key_handle,\n-\t\t\tMaybeLocal<Object> maybe_options,\n-\t\t\tbool inherit\n-\t\t) :\n-\t\t\t\tcontext{that.context},\n-\t\t\t\treference{that.reference},\n-\t\t\t\toptions{maybe_options, inherit ?\n-\t\t\t\t\tTransferOptions::Type::DeepReference : TransferOptions::Type::Reference},\n-\t\t\t\tinherit{inherit} {\n-\t\t\tthat.CheckDisposed();\n-\t\t\tkey = ExternalCopy::CopyIfPrimitive(key_handle);\n-\t\t\tif (!key) {\n+\t\tAccessorRunner(ReferenceHandle& target, Local<Value> key_handle) :\n+\t\tcontext{target.context},\n+\t\ttarget{target.reference},\n+\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)} {\n+\t\t\ttarget.CheckDisposed();\n+\t\t\tif (!key || (!key_handle->IsName() && !key_handle->IsUint32())) {\n \t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n+\t\t\t} else if (target.type_of != decltype(target.type_of)::Object) {\n+\t\t\t\tthrow RuntimeTypeError(\"Reference is not an object\");\n+\t\t\t}\n+\t\t}\n+\n+\tprotected:\n+\t\tauto GetTargetAndAlsoCheckForProxy() -> Local<Object> {\n+\t\t\tauto object = Local<Object>::Cast(Deref(target));\n+\t\t\tif (HasProxy(object)) {\n+\t\t\t\tthrow RuntimeTypeError(\"Object is or has proxy\");\n+\t\t\t}\n+\t\t\treturn object;\n+\t\t}\n+\n+\t\tauto GetKey(Local<Context> context) -> Local<Name> {\n+\t\t\tauto key_inner = key->CopyInto();\n+\t\t\treturn (key_inner->IsString() || key_inner->IsSymbol()) ?\n+\t\t\t\tkey_inner.As<Name>() : Unmaybe(key_inner->ToString(context)).As<Name>();\n+\t\t}\n+\n+\t\tRemoteHandle<Context> context;\n+\n+\tprivate:\n+\t\tstatic auto HasProxy(Local<Object> object) -> bool {\n+\t\t\tif (object->IsProxy()) {\n+\t\t\t\treturn true;\n+\t\t\t} else {\n+\t\t\t\tauto proto = object->GetPrototype();\n+\t\t\t\tif (proto->IsNullOrUndefined()) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn HasProxy(proto.As<Object>());\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n+\t\tRemoteHandle<Value> target;\n+\t\tunique_ptr<ExternalCopy> key;\n+};\n+\n+/**\n+ * Get a property from this reference, returned as another reference\n+ */\n+class GetRunner final : public AccessorRunner {\n+\tpublic:\n+\t\tGetRunner(ReferenceHandle& target, Local<Value> key_handle, MaybeLocal<Object> maybe_options) :\n+\t\tAccessorRunner{target, key_handle},\n+\t\toptions{maybe_options, target.inherit ?\n+\t\t\tTransferOptions::Type::DeepReference : TransferOptions::Type::Reference},\n+\t\tinherit{target.inherit} {}\n+\n \t\tvoid Phase2() final {\n-\t\t\tLocal<Context> context_handle = Deref(context);\n-\t\t\tContext::Scope context_scope{context_handle};\n-\t\t\tLocal<Value> key_inner = key->CopyInto();\n-\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n-\t\t\tbool allow = [&]() {\n-\t\t\t\tif (!inherit) {\n-\t\t\t\t\tif (key_inner->IsName()) {\n-\t\t\t\t\t\treturn Unmaybe(object->HasRealNamedProperty(context_handle, key_inner.As<Name>()));\n-\t\t\t\t\t} else if (key_inner->IsNumber()) {\n-\t\t\t\t\t\treturn Unmaybe(object->HasRealIndexedProperty(context_handle, HandleCast<uint32_t>(key_inner)));\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\treturn false;\n-\t\t\t\t\t}\n+\t\t\t// Setup\n+\t\t\tauto* isolate = Isolate::GetCurrent();\n+\t\t\tauto context = Deref(this->context);\n+\t\t\tContext::Scope context_scope{context};\n+\t\t\tauto name = GetKey(context);\n+\t\t\tauto object = GetTargetAndAlsoCheckForProxy();\n+\n+\t\t\t// Get property\n+\t\t\tret = TransferOut([&]() {\n+\t\t\t\tif (inherit) {\n+\t\t\t\t\t// To avoid accessors I guess we have to walk the prototype chain ourselves\n+\t\t\t\t\tauto target = object;\n+\t\t\t\t\tdo {\n+\t\t\t\t\t\tif (Unmaybe(target->HasOwnProperty(context, name))) {\n+\t\t\t\t\t\t\tif (Unmaybe(target->HasRealNamedCallbackProperty(context, name))) {\n+\t\t\t\t\t\t\t\tthrow RuntimeTypeError(\"Property is getter\");\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn Unmaybe(target->GetRealNamedProperty(context, name));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tauto next = target->GetPrototype();\n+\t\t\t\t\t\tif (next->IsNullOrUndefined()) {\n+\t\t\t\t\t\t\treturn Undefined(isolate).As<Value>();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\ttarget = next.As<Object>();\n+\t\t\t\t\t} while (true);\n+\t\t\t\t} else if (!Unmaybe(object->HasOwnProperty(context, name))) {\n+\t\t\t\t\treturn Undefined(isolate).As<Value>();\n+\t\t\t\t} else if (Unmaybe(object->HasRealNamedCallbackProperty(context, name))) {\n+\t\t\t\t\tthrow RuntimeTypeError(\"Property is getter\");\n+\t\t\t\t} else {\n+\t\t\t\t\treturn Unmaybe(object->Get(context, name));\n \t\t\t\t}\n-\t\t\t\treturn true;\n-\t\t\t}();\n-\t\t\tLocal<Value> value = allow ?\n-\t\t\t\tUnmaybe(object->Get(context_handle, key_inner)) :\n-\t\t\t\tUndefined(Isolate::GetCurrent()).As<Value>();\n-\t\t\tret = TransferOut(value, options);\n+\t\t\t}(), options);\n \t\t}\n \n \t\tauto Phase3() -> Local<Value> final {\n \t\t\treturn ret->TransferIn();\n \t\t}\n \n \tprivate:\n-\t\tunique_ptr<ExternalCopy> key;\n-\t\tRemoteHandle<Context> context;\n-\t\tRemoteHandle<Value> reference;\n \t\tunique_ptr<Transferable> ret;\n \t\tTransferOptions options;\n \t\tbool inherit;\n };\n template <int async>\n auto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n-\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);\n+\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options);\n }\n \n /**\n  * Delete a property on this reference\n  */\n-class DeleteRunner : public ThreePhaseTask {\n+class DeleteRunner final : public AccessorRunner {\n \tpublic:\n \t\tDeleteRunner(ReferenceHandle& that, Local<Value> key_handle) :\n-\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n-\t\t\t\tcontext{that.context},\n-\t\t\t\treference{that.reference} {\n-\t\t\tthat.CheckDisposed();\n-\t\t\tif (!key) {\n-\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n-\t\t\t}\n-\t\t}\n+\t\tAccessorRunner{that, key_handle} {}\n \n \t\tvoid Phase2() final {\n-\t\t\tLocal<Context> context_handle = Deref(context);\n-\t\t\tContext::Scope context_scope{context_handle};\n-\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n-\t\t\tresult = Unmaybe(object->Delete(context_handle, key->CopyInto()));\n+\t\t\tauto context = Deref(this->context);\n+\t\t\tContext::Scope context_scope{context};\n+\t\t\tauto object = GetTargetAndAlsoCheckForProxy();\n+\t\t\tif (!Unmaybe(object->Delete(context, GetKey(context)))) {\n+\t\t\t\tthrow RuntimeTypeError(\"Delete failed\");\n+\t\t\t}\n \t\t}\n \n \t\tauto Phase3() -> Local<Value> final {\n-\t\t\treturn Boolean::New(Isolate::GetCurrent(), result);\n+\t\t\treturn Undefined(Isolate::GetCurrent());\n \t\t}\n-\n-\tprivate:\n-\t\tunique_ptr<ExternalCopy> key;\n-\t\tRemoteHandle<Context> context;\n-\t\tRemoteHandle<Value> reference;\n-\t\tbool result = false;\n };\n template <int async>\n auto ReferenceHandle::Delete(Local<Value> key_handle) -> Local<Value> {\n@@ -528,45 +567,36 @@ auto ReferenceHandle::Delete(Local<Value> key_handle) -> Local<Value> {\n /**\n  * Attempt to set a property on this reference\n  */\n-class SetRunner : public ThreePhaseTask {\n+class SetRunner final : public AccessorRunner {\n \tpublic:\n \t\tSetRunner(\n \t\t\tReferenceHandle& that,\n \t\t\tLocal<Value> key_handle,\n \t\t\tLocal<Value> val_handle,\n \t\t\tMaybeLocal<Object> maybe_options\n \t\t) :\n-\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n-\t\t\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})},\n-\t\t\t\tcontext{that.context},\n-\t\t\t\treference{that.reference} {\n-\t\t\tthat.CheckDisposed();\n-\t\t\tif (!key) {\n-\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n-\t\t\t}\n-\t\t}\n+\t\tAccessorRunner{that, key_handle},\n+\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})} {}\n \n \t\tvoid Phase2() final {\n-\t\t\tLocal<Context> context_handle = Deref(context);\n-\t\t\tContext::Scope context_scope{context_handle};\n-\t\t\tLocal<Value> key_inner = key->CopyInto();\n-\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n+\t\t\tauto context = Deref(this->context);\n+\t\t\tContext::Scope context_scope{context};\n+\t\t\tauto name = GetKey(context);\n+\t\t\tauto object = GetTargetAndAlsoCheckForProxy();\n \t\t\t// Delete key before transferring in, potentially freeing up some v8 heap\n-\t\t\tUnmaybe(object->Delete(context_handle, key_inner));\n-\t\t\tLocal<Value> val_inner = val->TransferIn();\n-\t\t\tdid_set = Unmaybe(object->Set(context_handle, key_inner, val_inner));\n+\t\t\tUnmaybe(object->Delete(context, name));\n+\t\t\tauto val_inner = val->TransferIn();\n+\t\t\tif (!Unmaybe(object->CreateDataProperty(context, GetKey(context), val_inner))) {\n+\t\t\t\tthrow RuntimeTypeError(\"Set failed\");\n+\t\t\t}\n \t\t}\n \n \t\tauto Phase3() -> Local<Value> final {\n-\t\t\treturn Boolean::New(Isolate::GetCurrent(), did_set);\n+\t\t\treturn Undefined(Isolate::GetCurrent());\n \t\t}\n \n \tprivate:\n-\t\tunique_ptr<ExternalCopy> key;\n \t\tunique_ptr<Transferable> val;\n-\t\tRemoteHandle<Context> context;\n-\t\tRemoteHandle<Value> reference;\n-\t\tbool did_set = false;\n };\n template <int async>\n auto ReferenceHandle::Set(Local<Value> key_handle, Local<Value> val_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {"
        },
        {
          "filename": "src/module/reference_handle.h",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -13,6 +13,7 @@ namespace detail {\n  * Holds common data for ReferenceHandle and ReferenceHandleTransferable\n  */\n class ReferenceData {\n+\tfriend class AccessorRunner;\n \tpublic:\n \t\tenum class TypeOf { Null, Undefined, Number, String, Boolean, Object, Function };\n \n@@ -41,9 +42,8 @@ class ReferenceData {\n class ReferenceHandle : public TransferableHandle, public detail::ReferenceData {\n \tfriend class ApplyRunner;\n \tfriend class CopyRunner;\n+\tfriend class AccessorRunner;\n \tfriend class GetRunner;\n-\tfriend class DeleteRunner;\n-\tfriend class SetRunner;\n \tpublic:\n \t\tusing TypeOf = detail::ReferenceData::TypeOf;\n "
        },
        {
          "filename": "tests/reference.js",
          "status": "modified",
          "additions": 112,
          "deletions": 14,
          "patch": "@@ -1,22 +1,120 @@\n+'use strict';\n const ivm = require('isolated-vm');\n-const { strictEqual } = require('assert');\n+const { strictEqual, throws } = require('assert');\n+let trap = false;\n \n-const foo = { foo: 1 };\n-const bar = Object.create(foo);\n-bar.bar = 2;\n-const etc = Object.create(bar);\n-etc.etc = bar;\n {\n-\tconst ref = new ivm.Reference(etc);\n-\tstrictEqual(ref.getSync('bar'), undefined);\n-\tstrictEqual(ref.getSync('etc').getSync('foo'), undefined);\n-\tstrictEqual(ref.getSync('etc').getSync('bar'), 2);\n+\t// Set up inheritance\n+\tconst foo = { foo: 1 };\n+\tconst bar = Object.create(foo);\n+\tbar.bar = 2;\n+\tconst etc = Object.create(bar);\n+\tetc.etc = bar;\n+\n+\t{\n+\t\t// Test without inheritance\n+\t\tconst ref = new ivm.Reference(etc);\n+\t\tstrictEqual(ref.getSync('bar'), undefined);\n+\t\tstrictEqual(ref.getSync('etc').getSync('foo'), undefined);\n+\t\tstrictEqual(ref.getSync('etc').getSync('bar'), 2);\n+\t\tref.setSync('prop', 1);\n+\t\tstrictEqual(ref.getSync('prop'), 1);\n+\t\tref.deleteSync('prop');\n+\t\tstrictEqual(ref.getSync('prop'), undefined);\n+\t}\n+\n+\t{\n+\t\t// Test with inheritance\n+\t\tconst ref = new ivm.Reference(etc, { unsafeInherit: true });\n+\t\tstrictEqual(ref.getSync('bar'), 2);\n+\t\tstrictEqual(ref.getSync('etc').getSync('foo'), 1);\n+\t\tstrictEqual(ref.getSync('etc').getSync('bar'), 2);\n+\t\tref.getSync('etc').setSync('prop', 1);\n+\t\tref.setSync('prop', 2);\n+\t\tstrictEqual(ref.getSync('prop'), 2);\n+\t\tref.deleteSync('prop');\n+\t\tstrictEqual(ref.getSync('prop'), 1);\n+\t}\n+}\n+\n+{\n+\t// Set up getter / setters\n+\tlet setter = 0;\n+\tconst foo = {\n+\t\tget str() { trap = true; return 'got' },\n+\t\tset str(_) { trap = true },\n+\t};\n+\tObject.defineProperty(foo, 0, {\n+\t\tget() { trap = true; return 'got' },\n+\t\tset() { trap = true },\n+\t});\n+\n+\t{\n+\t\t// Test plain accessors\n+\t\tconst ref = new ivm.Reference(foo);\n+\t\tthrows(() => ref.getSync('str'));\n+\t\tthrows(() => ref.getSync(0));\n+\t\tthrows(() => ref.setSync(0, undefined));\n+\t}\n+\n+\t{\n+\t\t// Test accessors + inheritance\n+\t\tconst ref = new ivm.Reference(Object.create(foo), { unsafeInherit: true });\n+\t\tthrows(() => ref.getSync('str'));\n+\t\tref.setSync('str', undefined);\n+\t\tthrows(() => ref.getSync(0));\n+\t}\n+}\n+\n+{\n+\t// Set up evil proxy\n+\tconst val = { prop: 1 };\n+\tconst prox = new Proxy(val, {\n+\t\tget() { trap = true },\n+    set() { trap = true },\n+    getOwnPropertyDescriptor() { trap = true },\n+    getPrototypeOf() { trap = true },\n+    has() { trap = true },\n+    ownKeys() { trap = true },\n+\t});\n+\tconst inherited = Object.create(prox);\n+\n+\t{\n+\t\t// Test proxy\n+\t\tconst ref = new ivm.Reference(prox);\n+\t\tthrows(() => ref.getSync('prop'));\n+\t}\n+\n+\t{\n+\t\t// Test inherited proxy\n+\t\tconst ref = new ivm.Reference(inherited);\n+\t\tthrows(() => ref.getSync('prop'),);\n+\t}\n+\n+\t{\n+\t\t// Test deep inherited proxy\n+\t\tconst ref = new ivm.Reference(inherited, { unsafeInherit: true });\n+\t\tthrows(() => ref.getSync('prop'));\n+\t}\n }\n+\n {\n-\tconst ref = new ivm.Reference(etc, { inheritUnsafe: true });\n-\tstrictEqual(ref.getSync('bar'), 2);\n-\tstrictEqual(ref.getSync('etc').getSync('foo'), 1);\n-\tstrictEqual(ref.getSync('etc').getSync('bar'), 2);\n+\t// Test Array (numeric indices)\n+\tconst val = [ 1, 2, 3 ];\n+\tObject.defineProperty(val, 1, { get() { trap = true; return 'got' }});\n+\tconst ref = new ivm.Reference(val);\n+\tstrictEqual(ref.getSync(0), 1);\n+\tthrows(() => ref.getSync(1));\n }\n \n+{\n+\t// Test ArrayBuffer (numeric indices)\n+\tconst val = new Uint8Array([ 1, 2, 3 ]);\n+\tconst ref = new ivm.Reference(val);\n+\tstrictEqual(ref.getSync(0), 1);\n+}\n+\n+if (trap) {\n+\tconsole.log('fail');\n+}\n console.log('pass');"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "623a18dea0fae8f524ba1a8f333ce97eea11f195",
            "date": "2024-12-10T14:55:11Z",
            "author_login": "laverdet"
          },
          {
            "sha": "e1801d3a37b74eebf41bc30357482eb82c06420d",
            "date": "2024-12-10T14:54:09Z",
            "author_login": "laverdet"
          },
          {
            "sha": "29796283e96382e6ca846c5316685a73e46e5561",
            "date": "2024-12-08T10:36:13Z",
            "author_login": "laverdet"
          },
          {
            "sha": "8c92fd002fe28c4a0f32f02a213bb955e4a70f8e",
            "date": "2024-11-25T19:45:50Z",
            "author_login": "laverdet"
          },
          {
            "sha": "89bd5d290c1ff2a4877bb12e40ea6e02774df5d0",
            "date": "2024-11-18T20:21:42Z",
            "author_login": "paulrutter"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.0,
    "cvss_vector": "CVSS:3.1/AV:A/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:N",
    "cwe_id": "CWE-913",
    "description": "isolated-vm is a library for nodejs which gives you access to v8's Isolate interface. Versions of isolated-vm before v4.0.0 have API pitfalls which may make it easy for implementers to expose supposed secure isolates to the permissions of the main nodejs isolate. Reference objects allow access to the underlying reference's full prototype chain. In an environment where the implementer has exposed a Reference instance to an attacker they would be able to use it to acquire a Reference to the nodejs context's Function object. Similar application-specific attacks could be possible by modifying the local prototype of other API objects. Access to NativeModule objects could allow an attacker to load and run native code from anywhere on the filesystem. If combined with, for example, a file upload API this would allow for arbitrary code execution. This is addressed in v4.0.0 through a series of related changes.",
    "attack_vector": "ADJACENT_NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2021-03-30T23:15:14.190",
    "last_modified": "2024-11-21T05:48:18.633",
    "fix_date": "2021-03-20T19:40:07Z"
  },
  "references": [
    {
      "url": "https://github.com/laverdet/isolated-vm/blob/main/CHANGELOG.md#v400",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/laverdet/isolated-vm/commit/2646e6c1558bac66285daeab54c7d490ed332b15",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/laverdet/isolated-vm/commit/27151bfecc260e96714443613880e3b2e6596704",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/laverdet/isolated-vm/security/advisories/GHSA-mmhj-4w6j-76h7",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/laverdet/isolated-vm/blob/main/CHANGELOG.md#v400",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/laverdet/isolated-vm/commit/2646e6c1558bac66285daeab54c7d490ed332b15",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/laverdet/isolated-vm/commit/27151bfecc260e96714443613880e3b2e6596704",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/laverdet/isolated-vm/security/advisories/GHSA-mmhj-4w6j-76h7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:33.504654",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "isolated-vm",
    "owner": "laverdet",
    "created_at": "2017-05-20T05:08:47Z",
    "updated_at": "2025-01-14T09:47:26Z",
    "pushed_at": "2024-12-10T14:55:39Z",
    "size": 1406,
    "stars": 2255,
    "forks": 156,
    "open_issues": 74,
    "watchers": 2255,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C++": 367859,
      "JavaScript": 77002,
      "Python": 3751,
      "C": 1172
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "isc"
    },
    "collected_at": "2025-01-14T17:54:35.964272"
  }
}