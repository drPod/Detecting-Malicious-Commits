{
  "cve_id": "CVE-2021-23270",
  "github_data": {
    "repository": "ericpaulbishop/gargoyle",
    "fix_commit": "24afe944a6ffff53d84a748384e276a4e95912ec",
    "related_commits": [
      "24afe944a6ffff53d84a748384e276a4e95912ec",
      "24afe944a6ffff53d84a748384e276a4e95912ec"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "24afe944a6ffff53d84a748384e276a4e95912ec",
      "commit_date": "2021-01-20T07:05:51Z",
      "author": {
        "login": "lantis1008",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix IPv6 routing loops",
        "length": 22,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 249,
        "additions": 249,
        "deletions": 0
      },
      "files": [
        {
          "filename": "patches-generic/601-odhcp6c-CNVD-C-2021-04732.patch",
          "status": "added",
          "additions": 118,
          "deletions": 0,
          "patch": "@@ -0,0 +1,118 @@\n+--- /dev/null\n++++ b/package/network/ipv6/odhcp6c/patches/001-ra-align-ifindex-resolving.patch\n+@@ -0,0 +1,52 @@\n++From 2b6959dfe2095402e004b63d9aca9900c074abb6 Mon Sep 17 00:00:00 2001\n++From: Hans Dedecker <dedeckeh@gmail.com>\n++Date: Wed, 6 Jan 2021 21:15:49 +0100\n++Subject: [PATCH] ra: align ifindex resolving\n++\n++Use ioctl SIOCGIFINDEX to resolve ifindex similar as in init_dhcpv6\n++\n++Signed-off-by: Hans Dedecker <dedeckeh@gmail.com>\n++---\n++ src/ra.c | 10 +++++++---\n++ 1 file changed, 7 insertions(+), 3 deletions(-)\n++\n++diff --git a/src/ra.c b/src/ra.c\n++index 337c0bd..32a3097 100644\n++--- a/src/ra.c\n+++++ b/src/ra.c\n++@@ -27,6 +27,7 @@\n++ \n++ #include <net/if.h>\n++ #include <arpa/inet.h>\n+++#include <sys/ioctl.h>\n++ #include <sys/socket.h>\n++ #include <sys/types.h>\n++ #include <netinet/in.h>\n++@@ -76,6 +77,8 @@ static void ra_send_rs(int signal __attribute__((unused)));\n++ int ra_init(const char *ifname, const struct in6_addr *ifid,\n++ \t\tunsigned int options, unsigned int holdoff_interval)\n++ {\n+++\tstruct ifreq ifr;\n+++\n++ \tra_options = options;\n++ \tra_holdoff_interval = holdoff_interval;\n++ \n++@@ -84,11 +87,12 @@ int ra_init(const char *ifname, const struct in6_addr *ifid,\n++ \tif (sock < 0)\n++ \t\tgoto failure;\n++ \n++-\tif_index = if_nametoindex(ifname);\n++-\tif (!if_index)\n+++\tmemset(&ifr, 0, sizeof(ifr));\n+++\tstrncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name) - 1);\n+++\tif (ioctl(sock, SIOCGIFINDEX, &ifr) < 0)\n++ \t\tgoto failure;\n++ \n++-\tstrncpy(if_name, ifname, sizeof(if_name) - 1);\n+++\tif_index = ifr.ifr_ifindex;\n++ \tlladdr = *ifid;\n++ \n++ \trtnl = socket(AF_NETLINK, SOCK_DGRAM | SOCK_CLOEXEC, NETLINK_ROUTE);\n++-- \n++2.20.1\n++\n+--- /dev/null\n++++ b/package/network/ipv6/odhcp6c/patches/002-ra-fix-routing-loop-ppp-links.patch\n+@@ -0,0 +1,60 @@\n++From 53f07e90b7f1da6977143a488dd5cb73a33b233b Mon Sep 17 00:00:00 2001\n++From: Hans Dedecker <dedeckeh@gmail.com>\n++Date: Sat, 9 Jan 2021 21:17:48 +0100\n++Subject: [PATCH] ra: fix routing loop on point to point links\n++\n++For point-to-point links (e.g. PPP) don't create a link prefix route\n++when receiving a prefix information option with the on-link flag set.\n++Point-to-point links are non shared media and as such a destination\n++IPv6 address cannot be on-link.\n++If a link prefix route points to a point-to-point link it can trigger\n++a routing loop if the destination IPv6 address belongs to the prefix.\n++If such a packet is received and not directed to a local IPv6 address\n++it will be routed to the point-to-point link due to the link prefix route;\n++the upstream ISP router will route the IPv6 packet back due to the assigned\n++prefix route creating a \"ping pong\" effect\n++\n++Signed-off-by: Hans Dedecker <dedeckeh@gmail.com>\n++---\n++ src/ra.c | 11 ++++++++++-\n++ 1 file changed, 10 insertions(+), 1 deletion(-)\n++\n++diff --git a/src/ra.c b/src/ra.c\n++index 32a3097..4e6dd64 100644\n++--- a/src/ra.c\n+++++ b/src/ra.c\n++@@ -51,6 +51,7 @@\n++ #include \"ra.h\"\n++ \n++ static bool nocarrier = false;\n+++static bool ptp_link = false;\n++ \n++ static int sock = -1, rtnl = -1;\n++ static int if_index = 0;\n++@@ -87,6 +88,13 @@ int ra_init(const char *ifname, const struct in6_addr *ifid,\n++ \tif (sock < 0)\n++ \t\tgoto failure;\n++ \n+++\tmemset(&ifr, 0, sizeof(ifr));\n+++\tstrncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name) - 1);\n+++\tif (ioctl(sock, SIOCGIFFLAGS, &ifr) < 0)\n+++\t\tgoto failure;\n+++\n+++\tptp_link = !!(ifr.ifr_flags & IFF_POINTOPOINT);\n+++\n++ \tmemset(&ifr, 0, sizeof(ifr));\n++ \tstrncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name) - 1);\n++ \tif (ioctl(sock, SIOCGIFINDEX, &ifr) < 0)\n++@@ -488,7 +496,8 @@ bool ra_process(void)\n++ \t\t\t\t\t\t|| entry->valid < entry->preferred)\n++ \t\t\t\t\tcontinue;\n++ \n++-\t\t\t\tif (pinfo->nd_opt_pi_flags_reserved & ND_OPT_PI_FLAG_ONLINK)\n+++\t\t\t\tif ((pinfo->nd_opt_pi_flags_reserved & ND_OPT_PI_FLAG_ONLINK) &&\n+++\t\t\t\t    !ptp_link)\n++ \t\t\t\t\tchanged |= odhcp6c_update_entry(STATE_RA_ROUTE, entry,\n++ \t\t\t\t\t\t\t\t\t7200, ra_holdoff_interval);\n++ \n++-- \n++2.20.1\n++"
        },
        {
          "filename": "patches-generic/602-netifd-CNVD-C-2021-04732.patch",
          "status": "added",
          "additions": 131,
          "deletions": 0,
          "patch": "@@ -0,0 +1,131 @@\n+--- /dev/null\n++++ b/package/network/config/netifd/patches/001-interface_ip-add-unreachable-route-offlink-address.patch\n+@@ -0,0 +1,128 @@\n++From c00c8335d6188daa326ecfe5a62da15a9b9987e1 Mon Sep 17 00:00:00 2001\n++From: Hans Dedecker <dedeckeh@gmail.com>\n++Date: Sat, 9 Jan 2021 21:18:45 +0100\n++Subject: [PATCH] interface-ip: add unreachable route if address is offlink\n++\n++In order to avoid a routing loop add an unreachable route for the\n++address prefix is the offlink flag is set for an address.\n++This fixes a routing loop which is currently present on point-to-point\n++links (e.g PPP) when the wan interface is assigned a globally unique\n++prefix (e.g. 2001:db8:1:0::/64) from which an IPv6 address is picked\n++and installed on the wan interface\n++(e.g. 2001:db8:1:0:5054:ff:feab:d87c/64)\n++\n++The prefix route 2001:db8:1::/64 would be present in the routing table\n++which will route any packet with as destination 2001:db8:1::/64 to the wan\n++interface and would be routed back by the upstream router due to the\n++wan interface due to the assigned global unique prefix.\n++Besides not installing the prefix route 2001:db8:1::/64 on point-to-point links\n++adding an unreachable route is required to avoid the routing loop.\n++\n++Signed-off-by: Hans Dedecker <dedeckeh@gmail.com>\n++---\n++ interface-ip.c | 69 ++++++++++++++++++++++++++++++++++++++++++++++++++\n++ 1 file changed, 69 insertions(+)\n++\n++diff --git a/interface-ip.c b/interface-ip.c\n++index 3768000..1444fbf 100644\n++--- a/interface-ip.c\n+++++ b/interface-ip.c\n++@@ -684,6 +684,22 @@ interface_update_proto_addr(struct vlist_tree *tree,\n++ \t\t\tif (!(a_old->flags & DEVADDR_EXTERNAL)) {\n++ \t\t\t\tinterface_handle_subnet_route(iface, a_old, false);\n++ \t\t\t\tsystem_del_address(dev, a_old);\n+++\n+++\t\t\t\tif ((a_old->flags & DEVADDR_OFFLINK) && (a_old->mask < (v6 ? 128 : 32))) {\n+++\t\t\t\t\tstruct device_route route;\n+++\n+++\t\t\t\t\tmemset(&route, 0, sizeof(route));\n+++\t\t\t\t\troute.flags = v6 ? DEVADDR_INET6 : DEVADDR_INET4;\n+++\t\t\t\t\troute.metric = INT32_MAX;\n+++\t\t\t\t\troute.mask = a_old->mask;\n+++\t\t\t\t\troute.addr = a_old->addr;\n+++\n+++\t\t\t\t\tclear_if_addr(&route.addr, route.mask);\n+++\n+++\t\t\t\t\t/* Delete null-route */\n+++\t\t\t\t\tsystem_del_route(NULL, &route);\n+++\t\t\t\t}\n+++\n++ \t\t\t}\n++ \t\t}\n++ \t\tfree(a_old->pclass);\n++@@ -708,6 +724,26 @@ interface_update_proto_addr(struct vlist_tree *tree,\n++ \t\t\t}\n++ \n++ \t\t\tif (!keep) {\n+++\t\t\t\tif (!(a_new->flags & DEVADDR_EXTERNAL) &&\n+++\t\t\t\t    (a_new->flags & DEVADDR_OFFLINK) &&\n+++\t\t\t\t    (a_new->mask < (v6 ? 128 : 32))) {\n+++\t\t\t\t\tstruct device_route route;\n+++\n+++\t\t\t\t\tmemset(&route, 0, sizeof(route));\n+++\t\t\t\t\troute.flags = v6 ? DEVADDR_INET6 : DEVADDR_INET4;\n+++\t\t\t\t\troute.metric = INT32_MAX;\n+++\t\t\t\t\troute.mask = a_new->mask;\n+++\t\t\t\t\troute.addr = a_new->addr;\n+++\n+++\t\t\t\t\tclear_if_addr(&route.addr, route.mask);\n+++\n+++\t\t\t\t\t/*\n+++\t\t\t\t\t * In case off link is specifed as address property\n+++\t\t\t\t\t * add null-route to avoid routing loops\n+++\t\t\t\t\t */\n+++\t\t\t\t\tsystem_add_route(NULL, &route);\n+++\t\t\t\t}\n+++\n++ \t\t\t\tif (a_new->policy_table)\n++ \t\t\t\t\tinterface_add_addr_rules(a_new, true);\n++ \t\t\t}\n++@@ -1578,12 +1614,45 @@ void interface_ip_set_enabled(struct interface_ip_settings *ip, bool enabled)\n++ \t\t\tif (iface->metric || addr->policy_table)\n++ \t\t\t\tinterface_handle_subnet_route(iface, addr, true);\n++ \n+++\t\t\tif ((addr->flags & DEVADDR_OFFLINK) && (addr->mask < (v6 ? 128 : 32))) {\n+++\t\t\t\tstruct device_route route;\n+++\n+++\t\t\t\tmemset(&route, 0, sizeof(route));\n+++\t\t\t\troute.flags = v6 ? DEVADDR_INET6 : DEVADDR_INET4;\n+++\t\t\t\troute.metric = INT32_MAX;\n+++\t\t\t\troute.mask = addr->mask;\n+++\t\t\t\troute.addr = addr->addr;\n+++\n+++\t\t\t\tclear_if_addr(&route.addr, route.mask);\n+++\n+++\t\t\t\t/*\n+++\t\t\t\t * In case off link is specifed as address property\n+++\t\t\t\t * add null-route to avoid routing loops\n+++\t\t\t\t */\n+++\t\t\t\tsystem_add_route(NULL, &route);\n+++\t\t\t}\n+++\n++ \t\t\tif (addr->policy_table)\n++ \t\t\t\tinterface_add_addr_rules(addr, true);\n++ \t\t} else {\n++ \t\t\tinterface_handle_subnet_route(iface, addr, false);\n++ \t\t\tsystem_del_address(dev, addr);\n++ \n+++\t\t\tif ((addr->flags & DEVADDR_OFFLINK) && (addr->mask < (v6 ? 128 : 32))) {\n+++\t\t\t\tstruct device_route route;\n+++\n+++\t\t\t\tmemset(&route, 0, sizeof(route));\n+++\t\t\t\troute.flags = v6 ? DEVADDR_INET6 : DEVADDR_INET4;\n+++\t\t\t\troute.metric = INT32_MAX;\n+++\t\t\t\troute.mask = addr->mask;\n+++\t\t\t\troute.addr = addr->addr;\n+++\n+++\t\t\t\tclear_if_addr(&route.addr, route.mask);\n+++\n+++\t\t\t\t/* Delete null-route */\n+++\t\t\t\tsystem_del_route(NULL, &route);\n+++\t\t\t}\n+++\n++ \t\t\tif (addr->policy_table)\n++ \t\t\t\tinterface_add_addr_rules(addr, false);\n++ \t\t}\n++-- \n++2.20.1\n++"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "ae547ce5113ce1c6e260112bcdcab9f41e3e7ab8",
            "date": "2024-02-08T11:43:37Z",
            "author_login": "lantis1008"
          },
          {
            "sha": "dab78a4944da75011919b66688b13d1d5c965fb8",
            "date": "2024-02-08T11:42:19Z",
            "author_login": "lantis1008"
          },
          {
            "sha": "f3f58097270cb2daf3aca0e71d4112b0c1b4031e",
            "date": "2023-12-23T03:37:54Z",
            "author_login": "lantis1008"
          },
          {
            "sha": "ab2fd33fadfe3b30ff9ee96aaeec5cce08337ed3",
            "date": "2023-12-22T04:06:57Z",
            "author_login": "lantis1008"
          },
          {
            "sha": "3ab22859cda22754594aa652296c8af5d2541eb2",
            "date": "2023-12-14T21:01:15Z",
            "author_login": "obsy"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-834",
    "description": "In Gargoyle OS 1.12.0, when IPv6 is used, a routing loop can occur that generates excessive network traffic between an affected device and its upstream ISP's router. This occurs when a link prefix route points to a point-to-point link, a destination IPv6 address belongs to the prefix and is not a local IPv6 address, and a router advertisement is received with at least one global unique IPv6 prefix for which the on-link flag is set.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-04-12T19:15:14.517",
    "last_modified": "2024-11-21T05:51:28.313",
    "fix_date": "2021-01-20T07:05:51Z"
  },
  "references": [
    {
      "url": "https://github.com/ericpaulbishop/gargoyle/commit/24afe944a6ffff53d84a748384e276a4e95912ec",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ericpaulbishop/gargoyle/commit/24afe944a6ffff53d84a748384e276a4e95912ec",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:33.526419",
    "processing_status": "enhanced"
  }
}