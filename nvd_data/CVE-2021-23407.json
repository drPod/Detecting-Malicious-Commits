{
  "cve_id": "CVE-2021-23407",
  "github_data": {
    "repository": "trannamtrung1st/elFinder.Net.Core",
    "fix_commit": "5498c8a86b76ef089cfbd7ef8be014b61fa11c73",
    "related_commits": [
      "5498c8a86b76ef089cfbd7ef8be014b61fa11c73",
      "5498c8a86b76ef089cfbd7ef8be014b61fa11c73"
    ],
    "patch_url": "https://github.com/trannamtrung1st/elFinder.Net.Core/commit/5498c8a86b76ef089cfbd7ef8be014b61fa11c73.patch",
    "fix_commit_details": {
      "sha": "5498c8a86b76ef089cfbd7ef8be014b61fa11c73",
      "commit_date": "2021-07-01T11:12:30Z",
      "author": {
        "login": "trung-tran-sts",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Finish security patch 1.2.4",
        "length": 27,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 219,
        "additions": 179,
        "deletions": 40
      },
      "files": [
        {
          "filename": "elFinder.Net.Core/Demos/elFinder.Net.AdvancedDemo/Startup.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -39,7 +39,7 @@ public static string MapPath(string path, string basePath = null)\n             }\n \n             path = path.Replace(\"~/\", \"\").TrimStart('/').Replace('/', '\\\\');\n-            return PathHelper.GetFullPath(basePath, path);\n+            return PathHelper.GetFullPath(Path.Combine(basePath, path));\n         }\n \n         public IConfiguration Configuration { get; }"
        },
        {
          "filename": "elFinder.Net.Core/Demos/elFinder.Net.Demo31/Startup.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -9,6 +9,7 @@\n using Microsoft.Extensions.DependencyInjection;\n using Microsoft.Extensions.Hosting;\n using System.Collections.Generic;\n+using System.IO;\n \n namespace elFinder.Net.Demo31\n {\n@@ -30,7 +31,7 @@ public static string MapPath(string path, string basePath = null)\n             }\n \n             path = path.Replace(\"~/\", \"\").TrimStart('/').Replace('/', '\\\\');\n-            return PathHelper.GetFullPath(basePath, path);\n+            return PathHelper.GetFullPath(Path.Combine(basePath, path));\n         }\n \n         public IConfiguration Configuration { get; }"
        },
        {
          "filename": "elFinder.Net.Core/elFinder.Net.Core/Connector.cs",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -374,6 +374,13 @@ protected virtual async Task<ConnectorResult> ProcessCoreAsync(ConnectorCommand\n                             if (targetPath.IsDirectory)\n                                 throw new NotFileException();\n \n+                            if (putCmd.Encoding == \"hash\")\n+                            {\n+                                putCmd.ContentPath = await ParsePathAsync(putCmd.Content, cancellationToken: cancellationToken);\n+                                if (putCmd.ContentPath.IsDirectory)\n+                                    throw new NotFileException();\n+                            }\n+\n                             var putResp = await putCmd.TargetPath.Volume.Driver.PutAsync(putCmd, cancellationToken);\n                             return ConnectorResult.Success(putResp);\n                         }"
        },
        {
          "filename": "elFinder.Net.Core/elFinder.Net.Core/Exceptions/InvalidDirNameException.cs",
          "status": "added",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -0,0 +1,15 @@\n+\ufeffusing elFinder.Net.Core.Models.Response;\n+\n+namespace elFinder.Net.Core.Exceptions\n+{\n+    public class InvalidDirNameException : ConnectorException\n+    {\n+        public InvalidDirNameException()\n+        {\n+            ErrorResponse = new ErrorResponse(this)\n+            {\n+                error = ErrorResponse.InvalidDirName\n+            };\n+        }\n+    }\n+}"
        },
        {
          "filename": "elFinder.Net.Core/elFinder.Net.Core/Exceptions/InvalidFileNameException.cs",
          "status": "added",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -0,0 +1,15 @@\n+\ufeffusing elFinder.Net.Core.Models.Response;\n+\n+namespace elFinder.Net.Core.Exceptions\n+{\n+    public class InvalidFileNameException : ConnectorException\n+    {\n+        public InvalidFileNameException()\n+        {\n+            ErrorResponse = new ErrorResponse(this)\n+            {\n+                error = ErrorResponse.InvalidFileName\n+            };\n+        }\n+    }\n+}"
        },
        {
          "filename": "elFinder.Net.Core/elFinder.Net.Core/Models/Command/PutCommand.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -4,5 +4,7 @@ public class PutCommand : TargetCommand\n     {\n         public string Content { get; set; }\n         public string Encoding { get; set; }\n+\n+        public PathInfo ContentPath { get; set; }\n     }\n }"
        },
        {
          "filename": "elFinder.Net.Core/elFinder.Net.Core/Models/PathInfo.cs",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -1,17 +1,23 @@\n-\ufeffnamespace elFinder.Net.Core\n+\ufeffusing elFinder.Net.Core.Exceptions;\n+\n+namespace elFinder.Net.Core\n {\n     public class PathInfo\n     {\n         public PathInfo(string path, IVolume volume, IFile file, string hashedTarget) : this(path, volume, hashedTarget, false)\n         {\n             File = file;\n             FileSystem = file;\n+\n+            if (!volume.Own(FileSystem)) throw new PermissionDeniedException(\"Volume must own this path\");\n         }\n \n         public PathInfo(string path, IVolume volume, IDirectory dir, string hashedTarget) : this(path, volume, hashedTarget, true)\n         {\n             Directory = dir;\n             FileSystem = dir;\n+\n+            if (!volume.Own(FileSystem)) throw new PermissionDeniedException(\"Volume must own this path\");\n         }\n \n         private PathInfo(string path, IVolume volume, string hashedTarget, bool isDirectory)"
        },
        {
          "filename": "elFinder.Net.Core/elFinder.Net.Core/Models/Response/ErrorResponse.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -84,6 +84,8 @@ public static ErrorResponse Unknown(Exception ex)\n         public const string CommandNoSupport = \"errCmdNoSupport\";\n         public const string NotFile = \"errNotFile\";\n         public const string UploadFile = \"errUploadFile\";\n+        public const string InvalidFileName = \"errInvName\";\n+        public const string InvalidDirName = \"errInvDirname\";\n         #endregion\n     }\n }"
        },
        {
          "filename": "elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/Extensions/IDirectoryExtensions.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,4 +1,5 @@\n \ufeffusing elFinder.Net.Core;\n+using elFinder.Net.Drivers.FileSystem.Helpers;\n using System;\n using System.IO;\n using System.Linq;\n@@ -22,7 +23,7 @@ public static async Task<string> GetCopyNameAsync(this IDirectory directory, str\n             }\n \n             string newName = $\"{name}{suffix}\";\n-            if (!Directory.Exists(Path.Combine(directory.Parent.FullName, newName)))\n+            if (!Directory.Exists(PathHelper.SafelyCombine(directory.Parent.FullName, directory.Parent.FullName, newName)))\n                 return newName;\n             else\n             {"
        },
        {
          "filename": "elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/Extensions/IFileExtensions.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,4 +1,5 @@\n \ufeffusing elFinder.Net.Core;\n+using elFinder.Net.Drivers.FileSystem.Helpers;\n using System;\n using System.IO;\n using System.Linq;\n@@ -23,7 +24,7 @@ public static async Task<string> GetCopyNameAsync(this IFile file, string suffix\n             }\n \n             string newName = $\"{name}{suffix}{extension}\";\n-            if (!File.Exists(Path.Combine(file.DirectoryName, newName)))\n+            if (!File.Exists(PathHelper.SafelyCombine(file.DirectoryName, file.DirectoryName, newName)))\n                 return newName;\n             else\n             {"
        },
        {
          "filename": "elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/FileSystemDirectory.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -251,7 +251,7 @@ public virtual Task<IDirectory> RenameAsync(string newName, bool verify = true,\n \n             if (verify && !this.CanRename()) throw new PermissionDeniedException();\n \n-            var newPath = PathHelper.GetFullPath(Parent.FullName, newName);\n+            var newPath = PathHelper.GetFullPath(PathHelper.SafelyCombine(Parent.FullName, Parent.FullName, newName));\n             directoryInfo.MoveTo(newPath);\n             return Task.FromResult<IDirectory>(new FileSystemDirectory(newPath, volume));\n         }"
        },
        {
          "filename": "elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/FileSystemDriver.cs",
          "status": "modified",
          "additions": 79,
          "deletions": 23,
          "patch": "@@ -29,6 +29,7 @@ namespace elFinder.Net.Drivers.FileSystem\n     public class FileSystemDriver : IDriver\n     {\n         public const string DefaultThumbExt = \".png\";\n+        private static readonly char[] InvalidFileNameChars = Path.GetInvalidFileNameChars();\n \n         protected readonly IPathParser pathParser;\n         protected readonly IPictureEditor pictureEditor;\n@@ -127,6 +128,9 @@ public virtual async Task<MkdirResponse> MkdirAsync(MkdirCommand cmd, Cancellati\n         {\n             cancellationToken.ThrowIfCancellationRequested();\n \n+            if (!IsObjectNameValid(cmd.Name))\n+                throw new InvalidDirNameException();\n+\n             var mkdirResp = new MkdirResponse();\n             var targetPath = cmd.TargetPath;\n             var volume = targetPath.Volume;\n@@ -136,7 +140,8 @@ public virtual async Task<MkdirResponse> MkdirAsync(MkdirCommand cmd, Cancellati\n \n             if (!string.IsNullOrEmpty(cmd.Name))\n             {\n-                var newDir = new FileSystemDirectory(Path.Combine(targetPath.Directory.FullName, cmd.Name), volume);\n+                var newDir = new FileSystemDirectory(PathHelper.SafelyCombine(targetPath.Directory.FullName,\n+                    targetPath.Directory.FullName, cmd.Name), volume);\n \n                 OnBeforeMakeDir?.Invoke(this, newDir);\n                 await newDir.CreateAsync(cancellationToken: cancellationToken);\n@@ -149,7 +154,8 @@ public virtual async Task<MkdirResponse> MkdirAsync(MkdirCommand cmd, Cancellati\n             foreach (string dir in cmd.Dirs)\n             {\n                 string dirName = dir.StartsWith(\"/\") ? dir.Substring(1) : dir;\n-                var newDir = new FileSystemDirectory(Path.Combine(targetPath.Directory.FullName, dirName), volume);\n+                var newDir = new FileSystemDirectory(PathHelper.SafelyCombine(targetPath.Directory.FullName,\n+                    targetPath.Directory.FullName, dirName), volume);\n \n                 OnBeforeMakeDir?.Invoke(this, newDir);\n                 await newDir.CreateAsync(cancellationToken: cancellationToken);\n@@ -170,13 +176,17 @@ public virtual async Task<MkfileResponse> MkfileAsync(MkfileCommand cmd, Cancell\n         {\n             cancellationToken.ThrowIfCancellationRequested();\n \n+            if (!IsObjectNameValid(cmd.Name))\n+                throw new InvalidFileNameException();\n+\n             var targetPath = cmd.TargetPath;\n             var volume = targetPath.Volume;\n             var targetHash = targetPath.HashedTarget;\n \n             if (!targetPath.Directory.CanCreateObject()) throw new PermissionDeniedException();\n \n-            var newFile = new FileSystemFile(Path.Combine(targetPath.Directory.FullName, cmd.Name), volume);\n+            var newFile = new FileSystemFile(PathHelper.SafelyCombine(targetPath.Directory.FullName,\n+                targetPath.Directory.FullName, cmd.Name), volume);\n \n             OnBeforeMakeFile?.Invoke(this, newFile);\n             await newFile.CreateAsync(cancellationToken: cancellationToken);\n@@ -355,6 +365,11 @@ public virtual async Task<RenameResponse> RenameAsync(RenameCommand cmd, Cancell\n             var targetPath = cmd.TargetPath;\n             var volume = targetPath.Volume;\n \n+            if (!IsObjectNameValid(cmd.Name))\n+                if (targetPath.IsDirectory)\n+                    throw new InvalidDirNameException();\n+                else throw new InvalidFileNameException();\n+\n             if (targetPath.IsDirectory)\n             {\n                 var prevName = targetPath.Directory.Name;\n@@ -466,6 +481,15 @@ public virtual async Task<UploadResponse> UploadAsync(UploadCommand cmd, Cancell\n         {\n             cancellationToken.ThrowIfCancellationRequested();\n \n+            if (cmd.Name.Any(name => !IsObjectNameValid(name)))\n+                throw new InvalidFileNameException();\n+\n+            if (cmd.Renames.Any(name => !IsObjectNameValid(name)))\n+                throw new InvalidFileNameException();\n+\n+            if (!IsObjectNameValid(cmd.Suffix))\n+                throw new InvalidFileNameException();\n+\n             var uploadResp = new UploadResponse();\n             var targetPath = cmd.TargetPath;\n             var volume = targetPath.Volume;\n@@ -513,7 +537,7 @@ public virtual async Task<UploadResponse> UploadAsync(UploadCommand cmd, Cancell\n                     if (!dest.CanCreateObject())\n                         throw new PermissionDeniedException($\"Permission denied: {volume.GetRelativePath(dest)}\");\n \n-                    string uploadFullName = Path.Combine(dest.FullName, Path.GetFileName(formFile.FileName));\n+                    string uploadFullName = PathHelper.SafelyCombine(dest.FullName, dest.FullName, Path.GetFileName(formFile.FileName));\n                     var uploadFileInfo = new FileSystemFile(uploadFullName, volume);\n                     var isOverwrite = false;\n \n@@ -524,7 +548,7 @@ public virtual async Task<UploadResponse> UploadAsync(UploadCommand cmd, Cancell\n                             var fileNameWithoutExt = Path.GetFileNameWithoutExtension(formFile.FileName);\n                             var ext = Path.GetExtension(formFile.FileName);\n                             var backupName = $\"{fileNameWithoutExt}{cmd.Suffix}{ext}\";\n-                            var fullBakName = Path.Combine(uploadFileInfo.Parent.FullName, backupName);\n+                            var fullBakName = PathHelper.SafelyCombine(uploadFileInfo.Parent.FullName, uploadFileInfo.Parent.FullName, backupName);\n                             var bakFile = new FileSystemFile(fullBakName, volume);\n \n                             if (await bakFile.ExistsAsync)\n@@ -541,7 +565,7 @@ public virtual async Task<UploadResponse> UploadAsync(UploadCommand cmd, Cancell\n                         else if (cmd.Overwrite == 0 || (cmd.Overwrite == null && !volume.UploadOverwrite))\n                         {\n                             string newName = await uploadFileInfo.GetCopyNameAsync(cmd.Suffix, cancellationToken: cancellationToken);\n-                            uploadFullName = Path.Combine(uploadFileInfo.DirectoryName, newName);\n+                            uploadFullName = PathHelper.SafelyCombine(uploadFileInfo.DirectoryName, uploadFileInfo.DirectoryName, newName);\n                             uploadFileInfo = new FileSystemFile(uploadFullName, volume);\n                             isOverwrite = false;\n                         }\n@@ -715,6 +739,12 @@ public virtual async Task<PasteResponse> PasteAsync(PasteCommand cmd, Cancellati\n         {\n             cancellationToken.ThrowIfCancellationRequested();\n \n+            if (cmd.Renames.Any(name => !IsObjectNameValid(name)))\n+                throw new InvalidFileNameException();\n+\n+            if (!IsObjectNameValid(cmd.Suffix))\n+                throw new InvalidFileNameException();\n+\n             var pasteResp = new PasteResponse();\n             var isCut = cmd.Cut == 1;\n             var dstPath = cmd.DstPath;\n@@ -726,14 +756,14 @@ public virtual async Task<PasteResponse> PasteAsync(PasteCommand cmd, Cancellati\n                 if (src.IsDirectory)\n                 {\n                     IDirectory pastedDir;\n-                    var newDest = Path.Combine(dstPath.Directory.FullName, src.Directory.Name);\n+                    var newDest = PathHelper.SafelyCombine(dstPath.Directory.FullName, dstPath.Directory.FullName, src.Directory.Name);\n                     var newDestDir = new FileSystemDirectory(newDest, dstPath.Volume);\n                     var exists = await newDestDir.ExistsAsync;\n \n                     if (exists && cmd.Renames.Contains(newDestDir.Name))\n                     {\n                         var backupName = $\"{newDestDir.Name}{cmd.Suffix}\";\n-                        var fullBakName = Path.Combine(newDestDir.Parent.FullName, backupName);\n+                        var fullBakName = PathHelper.SafelyCombine(newDestDir.Parent.FullName, newDestDir.Parent.FullName, backupName);\n                         var bakDir = new FileSystemDirectory(fullBakName, newDestDir.Volume);\n \n                         if (await bakDir.ExistsAsync)\n@@ -790,7 +820,7 @@ public virtual async Task<PasteResponse> PasteAsync(PasteCommand cmd, Cancellati\n                 {\n                     IFile pastedFile;\n                     var file = src.File;\n-                    var newDest = Path.Combine(dstPath.Directory.FullName, file.Name);\n+                    var newDest = PathHelper.SafelyCombine(dstPath.Directory.FullName, dstPath.Directory.FullName, file.Name);\n                     var newDestFile = new FileSystemFile(newDest, dstPath.Volume);\n                     var exists = await newDestFile.ExistsAsync;\n \n@@ -799,7 +829,7 @@ public virtual async Task<PasteResponse> PasteAsync(PasteCommand cmd, Cancellati\n                         var fileNameWithoutExt = Path.GetFileNameWithoutExtension(newDestFile.Name);\n                         var ext = Path.GetExtension(newDestFile.Name);\n                         var backupName = $\"{fileNameWithoutExt}{cmd.Suffix}{ext}\";\n-                        var fullBakName = Path.Combine(newDestFile.Parent.FullName, backupName);\n+                        var fullBakName = PathHelper.SafelyCombine(newDestFile.Parent.FullName, newDestFile.Parent.FullName, backupName);\n                         var bakFile = new FileSystemFile(fullBakName, newDestFile.Volume);\n \n                         if (await bakFile.ExistsAsync)\n@@ -846,7 +876,7 @@ public virtual async Task<DuplicateResponse> DuplicateAsync(DuplicateCommand cmd\n                 if (src.IsDirectory)\n                 {\n                     var newName = await src.Directory.GetCopyNameAsync(cancellationToken: cancellationToken);\n-                    var newDest = Path.Combine(src.Directory.Parent.FullName, newName);\n+                    var newDest = PathHelper.SafelyCombine(src.Directory.Parent.FullName, src.Directory.Parent.FullName, newName);\n \n                     OnBeforeCopy?.Invoke(this, (src.Directory, newDest, true));\n                     var dupDir = await CopyToAsync(src.Directory, newDest, dstVolume, copyOverwrite: false, cancellationToken: cancellationToken);\n@@ -906,21 +936,24 @@ public virtual async Task<ArchiveResponse> ArchiveAsync(ArchiveCommand cmd, Canc\n         {\n             cancellationToken.ThrowIfCancellationRequested();\n \n+            if (!IsObjectNameValid(cmd.Name))\n+                throw new InvalidFileNameException();\n+\n             if (cmd.Type != MediaTypeNames.Application.Zip)\n                 throw new ArchiveTypeException();\n \n             var archiveResp = new ArchiveResponse();\n             var targetPath = cmd.TargetPath;\n             var volume = cmd.TargetPath.Volume;\n-            var directoryInfo = targetPath.Directory;\n+            var directory = targetPath.Directory;\n \n             var filename = cmd.Name ?? targetPath.Directory.Name;\n             var zipExt = $\".{FileExtensions.Zip}\";\n \n             if (!filename.EndsWith(zipExt))\n                 filename += zipExt;\n \n-            var archivePath = Path.Combine(directoryInfo.FullName, filename);\n+            var archivePath = PathHelper.SafelyCombine(directory.FullName, directory.FullName, filename);\n             var newFile = new FileSystemFile(archivePath, volume);\n \n             if (!await newFile.CanArchiveToAsync())\n@@ -979,7 +1012,7 @@ public virtual async Task<ExtractResponse> ExtractAsync(ExtractCommand cmd, Canc\n \n             if (makedir)\n             {\n-                fromPath = Path.Combine(fromPath, Path.GetFileNameWithoutExtension(targetPath.File.Name));\n+                fromPath = PathHelper.SafelyCombine(fromPath, fromPath, Path.GetFileNameWithoutExtension(targetPath.File.Name));\n                 fromDir = new FileSystemDirectory(fromPath, volume);\n \n                 if (!await fromDir.CanExtractToAsync())\n@@ -1005,7 +1038,8 @@ public virtual async Task<ExtractResponse> ExtractAsync(ExtractCommand cmd, Canc\n             {\n                 foreach (ZipArchiveEntry entry in archive.Entries)\n                 {\n-                    string fullName = PathHelper.GetFullPathNormalized(fromPath, entry.FullName);\n+                    string fullName = PathHelper.GetFullPathNormalized(\n+                        PathHelper.SafelyCombine(fromPath, fromPath, entry.FullName));\n \n                     if (string.IsNullOrEmpty(entry.Name))\n                     {\n@@ -1101,6 +1135,17 @@ public virtual async Task<PutResponse> PutAsync(PutCommand cmd, CancellationToke\n                     }\n                 }\n             }\n+            else if (cmd.Encoding == \"hash\")\n+            {\n+                Func<Task<Stream>> openStreamFunc = async () => await cmd.ContentPath.File.OpenReadAsync(cancellationToken: cancellationToken);\n+\n+                OnBeforeWriteStream?.Invoke(this, (openStreamFunc, targetFile));\n+                using (var readStream = await openStreamFunc())\n+                {\n+                    await targetFile.OverwriteAsync(readStream, cancellationToken: cancellationToken);\n+                }\n+                OnAfterWriteStream?.Invoke(this, (openStreamFunc, targetFile));\n+            }\n             else\n             {\n                 OnBeforeWriteContent?.Invoke(this, (cmd.Content, cmd.Encoding, targetFile));\n@@ -1268,15 +1313,19 @@ public virtual async Task<FileResponse> ZipdlRawAsync(ZipdlCommand cmd, Cancella\n         {\n             cancellationToken.ThrowIfCancellationRequested();\n \n+            if (!IsObjectNameValid(cmd.DownloadFileName))\n+                throw new InvalidFileNameException();\n+\n             var archiveFile = await zipDownloadPathProvider.ParseArchiveFileKeyAsync(cmd.ArchiveFileKey);\n             var tempFileInfo = new FileInfo(archiveFile);\n-            var memStream = new MemoryStream();\n \n+            if (!tempFileInfo.Exists) throw new PermissionDeniedException($\"Malformed key\");\n+\n+            var memStream = new MemoryStream();\n             using (var fileStream = tempFileInfo.OpenRead())\n             {\n                 await fileStream.CopyToAsync(memStream, StreamConstants.DefaultBufferSize, cancellationToken: cancellationToken);\n             }\n-\n             tempFileInfo.Delete();\n             memStream.Position = 0;\n \n@@ -1402,6 +1451,11 @@ public IDirectory CreateDirectory(string fullPath, IVolume volume)\n             return new FileSystemDirectory(fullPath, volume);\n         }\n \n+        protected bool IsObjectNameValid(string name)\n+        {\n+            return name == null || !name.Any(ch => InvalidFileNameChars.Contains(ch));\n+        }\n+\n         protected virtual async Task<IFile> SafeCopyToAsync(IFile file, string newDir,\n             IVolume destVolume, bool copyOverwrite = true, string suffix = null,\n             CancellationToken cancellationToken = default)\n@@ -1410,7 +1464,7 @@ protected virtual async Task<IFile> SafeCopyToAsync(IFile file, string newDir,\n \n             if (!file.CanCopy()) throw new PermissionDeniedException();\n \n-            string newPath = Path.Combine(newDir, file.Name);\n+            string newPath = PathHelper.SafelyCombine(newDir, newDir, file.Name);\n             IFile newFile = new FileSystemFile(newPath, destVolume);\n             var isOverwrite = true;\n \n@@ -1419,7 +1473,7 @@ protected virtual async Task<IFile> SafeCopyToAsync(IFile file, string newDir,\n                 if (!copyOverwrite)\n                 {\n                     var newName = await newFile.GetCopyNameAsync(suffix, cancellationToken: cancellationToken);\n-                    newPath = Path.Combine(newDir, newName);\n+                    newPath = PathHelper.SafelyCombine(newDir, newDir, newName);\n                     isOverwrite = false;\n                 }\n             }\n@@ -1439,15 +1493,15 @@ protected virtual async Task<IFile> SafeMoveToAsync(IFile file, string newDir,\n \n             if (!file.CanMove()) throw new PermissionDeniedException();\n \n-            string newPath = Path.Combine(newDir, file.Name);\n+            string newPath = PathHelper.SafelyCombine(newDir, newDir, file.Name);\n             IFile newFile = new FileSystemFile(newPath, destVolume);\n \n             if (await newFile.ExistsAsync)\n             {\n                 if (!copyOverwrite)\n                 {\n                     var newName = await newFile.GetCopyNameAsync(suffix, cancellationToken: cancellationToken);\n-                    newPath = Path.Combine(newDir, newName);\n+                    newPath = PathHelper.SafelyCombine(newDir, newDir, newName);\n                 }\n                 else\n                 {\n@@ -1506,7 +1560,8 @@ protected virtual async Task<IDirectory> CopyToAsync(IDirectory directory, strin\n \n                 foreach (var dir in await currentDir.GetDirectoriesAsync(cancellationToken: cancellationToken))\n                 {\n-                    var newDir = new FileSystemDirectory(Path.Combine(currentNewDest.FullName, dir.Name), directory.Volume);\n+                    var newDir = new FileSystemDirectory(PathHelper.SafelyCombine(\n+                        currentNewDest.FullName, currentNewDest.FullName, dir.Name), currentNewDest.Volume);\n                     queue.Enqueue((dir, newDir));\n                 }\n \n@@ -1550,7 +1605,8 @@ protected virtual async Task<IDirectory> MergeAsync(IDirectory srcDir, string ne\n \n                 foreach (var dir in await currentDir.GetDirectoriesAsync(cancellationToken: cancellationToken))\n                 {\n-                    var newDir = new FileSystemDirectory(Path.Combine(currentNewDest.FullName, dir.Name), srcDir.Volume);\n+                    var newDir = new FileSystemDirectory(PathHelper.SafelyCombine(\n+                        currentNewDest.FullName, currentNewDest.FullName, dir.Name), currentNewDest.Volume);\n                     queue.Enqueue((dir, newDir));\n                 }\n "
        },
        {
          "filename": "elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/FileSystemFile.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -209,7 +209,7 @@ public virtual Task<IFile> RenameAsync(string newName, bool verify = true, Cance\n \n             if (verify && !this.CanRename()) throw new PermissionDeniedException();\n \n-            var newPath = PathHelper.GetFullPath(Parent.FullName, newName);\n+            var newPath = PathHelper.GetFullPath(PathHelper.SafelyCombine(Parent.FullName, Parent.FullName, newName));\n             fileInfo.MoveTo(newPath);\n             return Task.FromResult<IFile>(new FileSystemFile(newPath, volume));\n         }"
        },
        {
          "filename": "elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/Helpers/PathHelper.cs",
          "status": "modified",
          "additions": 20,
          "deletions": 6,
          "patch": "@@ -1,24 +1,38 @@\n-\ufeffusing System.IO;\n+\ufeffusing elFinder.Net.Core.Exceptions;\n+using System.IO;\n \n namespace elFinder.Net.Drivers.FileSystem.Helpers\n {\n     public static class PathHelper\n     {\n-        public static string GetFullPath(params string[] paths)\n+        private static readonly char[] SeparatorChars = new[] { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar };\n+\n+        public static string GetFullPath(string path)\n         {\n-            var fullPath = Path.GetFullPath(Path.Combine(paths));\n+            var fullPath = Path.GetFullPath(path);\n             return fullPath;\n         }\n \n-        public static string GetFullPathNormalized(params string[] paths)\n+        public static string GetFullPathNormalized(string path)\n         {\n-            var fullPath = Path.GetFullPath(Path.Combine(paths)).TrimEnd(Path.DirectorySeparatorChar);\n+            var fullPath = Path.GetFullPath(path).TrimEnd(SeparatorChars);\n             return fullPath;\n         }\n \n         public static string NormalizePath(string fullPath)\n         {\n-            return fullPath.TrimEnd(Path.DirectorySeparatorChar);\n+            return fullPath.TrimEnd(SeparatorChars);\n+        }\n+\n+        public static string SafelyCombine(string fromParent, params string[] paths)\n+        {\n+            var finalPath = Path.GetFullPath(Path.Combine(paths))\n+                .Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);\n+\n+            if (!finalPath.StartsWith(fromParent.TrimEnd(SeparatorChars) + Path.DirectorySeparatorChar))\n+                throw new PermissionDeniedException(\"Path must be inside parent\");\n+\n+            return finalPath;\n         }\n     }\n }"
        },
        {
          "filename": "elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/IZipDownloadPathProvider.cs",
          "status": "modified",
          "additions": 23,
          "deletions": 4,
          "patch": "@@ -1,4 +1,8 @@\n-\ufeffusing System.IO;\n+\ufeffusing elFinder.Net.Core.Exceptions;\n+using System;\n+using System.IO;\n+using System.Security.Cryptography;\n+using System.Text;\n using System.Threading.Tasks;\n \n namespace elFinder.Net.Drivers.FileSystem\n@@ -11,19 +15,34 @@ public interface IZipDownloadPathProvider\n \n     public class TempZipDownloadPathProvider : IZipDownloadPathProvider\n     {\n+        private readonly HMAC _hmac = new HMACSHA256();\n+        private static readonly string Postfix = '_' + nameof(elFinder);\n+\n         public Task<(string ArchiveFilePath, string ArchiveFileKey)> GetFileForArchivingAsync()\n         {\n-            var tempFile = Path.GetTempFileName();\n+            var bytes = Encoding.UTF8.GetBytes(Path.GetTempFileName() + Guid.NewGuid().ToString());\n+            var tempFile = Path.Combine(Path.GetTempPath(),\n+                BitConverter.ToString(_hmac.ComputeHash(bytes)).Replace(\"-\", string.Empty) + Postfix);\n             var tempFileName = Path.GetFileName(tempFile);\n-\n             return Task.FromResult((tempFile, tempFileName));\n         }\n \n         public Task<string> ParseArchiveFileKeyAsync(string archiveFileKey)\n         {\n             var tempDirPath = Path.GetTempPath();\n \n-            return Task.FromResult(Path.Combine(tempDirPath, archiveFileKey));\n+            if (Path.IsPathRooted(archiveFileKey)) throw new PermissionDeniedException(\"Malformed key\");\n+\n+            var fullPath = Path.GetFullPath(Path.Combine(tempDirPath, archiveFileKey));\n+            if (!fullPath.StartsWith(tempDirPath.EndsWith($\"{Path.DirectorySeparatorChar}\")\n+                ? tempDirPath : (tempDirPath + Path.DirectorySeparatorChar)))\n+                throw new PermissionDeniedException(\"Malformed key\");\n+\n+            var fileName = Path.GetFileName(fullPath);\n+            if (!fileName.EndsWith(Postfix))\n+                throw new PermissionDeniedException(\"Malformed key\");\n+\n+            return Task.FromResult(fullPath);\n         }\n     }\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 10,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "9718cb5bba676cc47666d21ed28dac81eca00bbd",
            "date": "2023-01-14T02:46:03Z",
            "author_login": "trannamtrung1st"
          },
          {
            "sha": "abb2d3ad263904f967447d5dcfaa116837d4cc62",
            "date": "2022-05-17T13:43:55Z",
            "author_login": "trannamtrung1st"
          },
          {
            "sha": "1cb06756ef161bac5f2f2beccdafe91aa2191fcc",
            "date": "2022-05-17T13:42:01Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "ce0bc93fb42b36ac2dda2ef78e8c9d766fb98f67",
            "date": "2022-04-30T16:46:04Z",
            "author_login": "trannamtrung1st"
          },
          {
            "sha": "258ca553b7b5d638228d26bbbdeeb3d391338915",
            "date": "2022-04-30T16:25:04Z",
            "author_login": "trannamtrung1st"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-22",
    "description": "This affects the package elFinder.Net.Core from 0 and before 1.2.4. The user-controlled file name is not properly sanitized before it is used to create a file system path.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-07-14T17:15:07.870",
    "last_modified": "2024-11-21T05:51:39.717",
    "fix_date": "2021-07-01T11:12:30Z"
  },
  "references": [
    {
      "url": "https://github.com/trannamtrung1st/elFinder.Net.Core/commit/5498c8a86b76ef089cfbd7ef8be014b61fa11c73",
      "source": "report@snyk.io",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/trannamtrung1st/elFinder.Net.Core/releases/tag/all-1.2.4",
      "source": "report@snyk.io",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://snyk.io/vuln/SNYK-DOTNET-ELFINDERNETCORE-1315152",
      "source": "report@snyk.io",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/trannamtrung1st/elFinder.Net.Core/commit/5498c8a86b76ef089cfbd7ef8be014b61fa11c73",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/trannamtrung1st/elFinder.Net.Core/releases/tag/all-1.2.4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://snyk.io/vuln/SNYK-DOTNET-ELFINDERNETCORE-1315152",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:02.306161",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "elFinder.Net.Core",
    "owner": "trannamtrung1st",
    "created_at": "2021-04-03T14:43:09Z",
    "updated_at": "2024-09-25T01:35:06Z",
    "pushed_at": "2023-01-14T02:46:03Z",
    "size": 218,
    "stars": 12,
    "forks": 8,
    "open_issues": 1,
    "watchers": 12,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C#": 442836,
      "HTML": 23681,
      "CSS": 2692,
      "JavaScript": 452
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T20:13:06.289243"
  }
}