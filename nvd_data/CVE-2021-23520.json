{
  "cve_id": "CVE-2021-23520",
  "github_data": {
    "repository": "juce-framework/JUCE",
    "fix_commit": "2e874e80cba0152201aff6a4d0dc407997d10a7f",
    "related_commits": [
      "2e874e80cba0152201aff6a4d0dc407997d10a7f",
      "2e874e80cba0152201aff6a4d0dc407997d10a7f"
    ],
    "patch_url": "https://github.com/juce-framework/JUCE/commit/2e874e80cba0152201aff6a4d0dc407997d10a7f.patch",
    "fix_commit_details": {
      "sha": "2e874e80cba0152201aff6a4d0dc407997d10a7f",
      "commit_date": "2022-01-10T16:40:32Z",
      "author": {
        "login": "szarvas",
        "type": "User",
        "stats": {
          "total_commits": 357,
          "average_weekly_commits": 0.5136690647482014,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 136
        }
      },
      "commit_message": {
        "title": "ZipFile:  Add path checks to uncompressEntry()",
        "length": 46,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 111,
        "additions": 105,
        "deletions": 6
      },
      "files": [
        {
          "filename": "modules/juce_core/files/juce_TemporaryFile.cpp",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -105,7 +105,7 @@ bool TemporaryFile::deleteTemporaryFile() const\n     // Have a few attempts at deleting the file before giving up..\r\n     for (int i = 5; --i >= 0;)\r\n     {\r\n-        if (temporaryFile.deleteFile())\r\n+        if (temporaryFile.isDirectory() ? temporaryFile.deleteRecursively() : temporaryFile.deleteFile())\r\n             return true;\r\n \r\n         Thread::sleep (50);\r"
        },
        {
          "filename": "modules/juce_core/zip/juce_ZipFile.cpp",
          "status": "modified",
          "additions": 85,
          "deletions": 5,
          "patch": "@@ -122,6 +122,19 @@ static int64 findCentralDirectoryFileHeader (InputStream& input, int& numEntries\n     return 0;\r\n }\r\n \r\n+static bool hasSymbolicPart (const File& root, const File& f)\r\n+{\r\n+    jassert (root == f || f.isAChildOf (root));\r\n+\r\n+    for (auto p = f; p != root; p = p.getParentDirectory())\r\n+    {\r\n+        if (p.isSymbolicLink())\r\n+            return true;\r\n+    }\r\n+\r\n+    return false;\r\n+}\r\n+\r\n //==============================================================================\r\n struct ZipFile::ZipInputStream  : public InputStream\r\n {\r\n@@ -400,6 +413,14 @@ Result ZipFile::uncompressTo (const File& targetDirectory,\n }\r\n \r\n Result ZipFile::uncompressEntry (int index, const File& targetDirectory, bool shouldOverwriteFiles)\r\n+{\r\n+    return uncompressEntry (index,\r\n+                            targetDirectory,\r\n+                            shouldOverwriteFiles ? OverwriteFiles::yes : OverwriteFiles::no,\r\n+                            FollowSymlinks::no);\r\n+}\r\n+\r\n+Result ZipFile::uncompressEntry (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks followSymlinks)\r\n {\r\n     auto* zei = entries.getUnchecked (index);\r\n \r\n@@ -414,6 +435,9 @@ Result ZipFile::uncompressEntry (int index, const File& targetDirectory, bool sh\n \r\n     auto targetFile = targetDirectory.getChildFile (entryPath);\r\n \r\n+    if (! targetFile.isAChildOf (targetDirectory))\r\n+        return Result::fail (\"Entry \" + entryPath + \" is outside the target directory\");\r\n+\r\n     if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\r\n         return targetFile.createDirectory(); // (entry is a directory, not a file)\r\n \r\n@@ -424,13 +448,16 @@ Result ZipFile::uncompressEntry (int index, const File& targetDirectory, bool sh\n \r\n     if (targetFile.exists())\r\n     {\r\n-        if (! shouldOverwriteFiles)\r\n+        if (overwriteFiles == OverwriteFiles::no)\r\n             return Result::ok();\r\n \r\n         if (! targetFile.deleteFile())\r\n             return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n     }\r\n \r\n+    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory, targetFile.getParentDirectory()))\r\n+        return Result::fail (\"Parent directory leads through symlink for target file: \" + targetFile.getFullPathName());\r\n+\r\n     if (! targetFile.getParentDirectory().createDirectory())\r\n         return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\r\n \r\n@@ -649,12 +676,9 @@ struct ZIPTests   : public UnitTest\n         : UnitTest (\"ZIP\", UnitTestCategories::compression)\r\n     {}\r\n \r\n-    void runTest() override\r\n+    static MemoryBlock createZipMemoryBlock (const StringArray& entryNames)\r\n     {\r\n-        beginTest (\"ZIP\");\r\n-\r\n         ZipFile::Builder builder;\r\n-        StringArray entryNames { \"first\", \"second\", \"third\" };\r\n         HashMap<String, MemoryBlock> blocks;\r\n \r\n         for (auto& entryName : entryNames)\r\n@@ -669,8 +693,61 @@ struct ZIPTests   : public UnitTest\n         MemoryBlock data;\r\n         MemoryOutputStream mo (data, false);\r\n         builder.writeToStream (mo, nullptr);\r\n+\r\n+        return data;\r\n+    }\r\n+\r\n+    void runZipSlipTest()\r\n+    {\r\n+        const std::map<String, bool> testCases = { { \"a\",                    true  },\r\n+#if JUCE_WINDOWS\r\n+                                                   { \"C:/b\",                 false },\r\n+#else\r\n+                                                   { \"/b\",                   false },\r\n+#endif\r\n+                                                   { \"c/d\",                  true  },\r\n+                                                   { \"../e/f\",               false },\r\n+                                                   { \"../../g/h\",            false },\r\n+                                                   { \"i/../j\",               true  },\r\n+                                                   { \"k/l/../\",              true  },\r\n+                                                   { \"m/n/../../\",           false },\r\n+                                                   { \"o/p/../../../\",        false } };\r\n+\r\n+        StringArray entryNames;\r\n+\r\n+        for (const auto& testCase : testCases)\r\n+            entryNames.add (testCase.first);\r\n+\r\n+        TemporaryFile tmpDir;\r\n+        tmpDir.getFile().createDirectory();\r\n+        auto data = createZipMemoryBlock (entryNames);\r\n         MemoryInputStream mi (data, false);\r\n+        ZipFile zip (mi);\r\n+\r\n+        for (int i = 0; i < zip.getNumEntries(); ++i)\r\n+        {\r\n+            const auto result = zip.uncompressEntry (i, tmpDir.getFile());\r\n+            const auto caseIt = testCases.find (zip.getEntry (i)->filename);\r\n \r\n+            if (caseIt != testCases.end())\r\n+            {\r\n+                expect (result.wasOk() == caseIt->second,\r\n+                        zip.getEntry (i)->filename + \" was unexpectedly \" + (result.wasOk() ? \"OK\" : \"not OK\"));\r\n+            }\r\n+            else\r\n+            {\r\n+                expect (false);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    void runTest() override\r\n+    {\r\n+        beginTest (\"ZIP\");\r\n+\r\n+        StringArray entryNames { \"first\", \"second\", \"third\" };\r\n+        auto data = createZipMemoryBlock (entryNames);\r\n+        MemoryInputStream mi (data, false);\r\n         ZipFile zip (mi);\r\n \r\n         expectEquals (zip.getNumEntries(), entryNames.size());\r\n@@ -681,6 +758,9 @@ struct ZIPTests   : public UnitTest\n             std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\r\n             expectEquals (input->readEntireStreamAsString(), entryName);\r\n         }\r\n+\r\n+        beginTest (\"ZipSlip\");\r\n+        runZipSlipTest();\r\n     }\r\n };\r\n \r"
        },
        {
          "filename": "modules/juce_core/zip/juce_ZipFile.h",
          "status": "modified",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -179,6 +179,25 @@ class JUCE_API  ZipFile\n                             const File& targetDirectory,\r\n                             bool shouldOverwriteFiles = true);\r\n \r\n+    enum class OverwriteFiles { no, yes };\r\n+    enum class FollowSymlinks { no, yes };\r\n+\r\n+    /** Uncompresses one of the entries from the zip file.\r\n+\r\n+        This will expand the entry and write it in a target directory. The entry's path is used to\r\n+        determine which subfolder of the target should contain the new file.\r\n+\r\n+        @param index                the index of the entry to uncompress - this must be a valid index\r\n+                                    between 0 and (getNumEntries() - 1).\r\n+        @param targetDirectory      the root folder to uncompress into\r\n+        @param overwriteFiles       whether to overwrite existing files with similarly-named ones\r\n+        @param followSymlinks       whether to follow symlinks inside the target directory\r\n+        @returns success if all the files are successfully unzipped\r\n+    */\r\n+    Result uncompressEntry (int index,\r\n+                            const File& targetDirectory,\r\n+                            OverwriteFiles overwriteFiles,\r\n+                            FollowSymlinks followSymlinks);\r\n \r\n     //==============================================================================\r\n     /** Used to create a new zip file.\r"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "51a8a6d7aeae7326956d747737ccf1575e61e209",
            "date": "2025-01-10T09:30:47Z",
            "author_login": "tpoole"
          },
          {
            "sha": "4820fe7cda5d8202ddeffb4fd4b824ccb447e5a3",
            "date": "2025-01-10T09:25:04Z",
            "author_login": "tpoole"
          },
          {
            "sha": "f1a6f299c9226ccbc51dee85c822cceb23214d52",
            "date": "2025-01-10T09:30:00Z",
            "author_login": "tpoole"
          },
          {
            "sha": "0baffff1820a37b71eba73cc113b887e9e2debdb",
            "date": "2025-01-10T09:29:00Z",
            "author_login": "tpoole"
          },
          {
            "sha": "7e8b2b25ae76a1f48a26130147a1b51e1f875530",
            "date": "2025-01-10T09:25:04Z",
            "author_login": "tpoole"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-22",
    "description": "The package juce-framework/juce before 6.1.5 are vulnerable to Arbitrary File Write via Archive Extraction (Zip Slip) via the ZipFile::uncompressEntry function in juce_ZipFile.cpp. This vulnerability is triggered when the archive is extracted upon calling uncompressTo() on a ZipFile object.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-01-31T11:15:07.820",
    "last_modified": "2024-11-21T05:51:49.020",
    "fix_date": "2022-01-10T16:40:32Z"
  },
  "references": [
    {
      "url": "https://github.com/juce-framework/JUCE/commit/2e874e80cba0152201aff6a4d0dc407997d10a7f",
      "source": "report@snyk.io",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://snyk.io/research/zip-slip-vulnerability",
      "source": "report@snyk.io",
      "tags": [
        "Exploit",
        "Technical Description",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://snyk.io/vuln/SNYK-UNMANAGED-JUCEFRAMEWORKJUCE-2388607",
      "source": "report@snyk.io",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/juce-framework/JUCE/commit/2e874e80cba0152201aff6a4d0dc407997d10a7f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://snyk.io/research/zip-slip-vulnerability",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Technical Description",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://snyk.io/vuln/SNYK-UNMANAGED-JUCEFRAMEWORKJUCE-2388607",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:57.096269",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "JUCE",
    "owner": "juce-framework",
    "created_at": "2012-03-31T11:19:43Z",
    "updated_at": "2025-01-14T04:18:24Z",
    "pushed_at": "2025-01-13T17:22:37Z",
    "size": 270384,
    "stars": 6815,
    "forks": 1772,
    "open_issues": 396,
    "watchers": 6815,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "develop",
      "master"
    ],
    "languages": {
      "C++": 39806501,
      "C": 8398001,
      "CMake": 1349430,
      "Objective-C++": 1110986,
      "Java": 163264,
      "Objective-C": 101508,
      "Makefile": 79027,
      "JavaScript": 22333,
      "Python": 5460,
      "Batchfile": 1771,
      "HTML": 982
    },
    "commit_activity": {
      "total_commits_last_year": 797,
      "avg_commits_per_week": 15.326923076923077,
      "days_active_last_year": 207
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:40:16.123308"
  }
}