{
  "cve_id": "CVE-2021-23792",
  "github_data": {
    "repository": "haraldk/TwelveMonkeys",
    "fix_commit": "da4efe98bf09e1cce91b7633cb251958a200fc80",
    "related_commits": [
      "da4efe98bf09e1cce91b7633cb251958a200fc80",
      "da4efe98bf09e1cce91b7633cb251958a200fc80"
    ],
    "patch_url": "https://github.com/haraldk/TwelveMonkeys/commit/da4efe98bf09e1cce91b7633cb251958a200fc80.patch",
    "fix_commit_details": {
      "sha": "da4efe98bf09e1cce91b7633cb251958a200fc80",
      "commit_date": "2021-12-10T12:41:05Z",
      "author": {
        "login": "haraldk",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Avoid fetching external resources in XMPReader.",
        "length": 47,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 211,
        "additions": 172,
        "deletions": 39
      },
      "files": [
        {
          "filename": "imageio/imageio-metadata/src/main/java/com/twelvemonkeys/imageio/metadata/xmp/XMPReader.java",
          "status": "modified",
          "additions": 54,
          "deletions": 27,
          "patch": "@@ -30,11 +30,21 @@\n \n package com.twelvemonkeys.imageio.metadata.xmp;\n \n-import com.twelvemonkeys.imageio.metadata.Directory;\n-import com.twelvemonkeys.imageio.metadata.Entry;\n-import com.twelvemonkeys.imageio.metadata.MetadataReader;\n-import com.twelvemonkeys.imageio.util.IIOUtil;\n-import com.twelvemonkeys.lang.Validate;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.imageio.IIOException;\n+import javax.imageio.stream.ImageInputStream;\n+import javax.xml.XMLConstants;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n import org.w3c.dom.Document;\n import org.w3c.dom.NamedNodeMap;\n import org.w3c.dom.Node;\n@@ -43,13 +53,11 @@\n import org.xml.sax.SAXException;\n import org.xml.sax.helpers.DefaultHandler;\n \n-import javax.imageio.IIOException;\n-import javax.imageio.stream.ImageInputStream;\n-import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n-import java.io.IOException;\n-import java.util.*;\n+import com.twelvemonkeys.imageio.metadata.Directory;\n+import com.twelvemonkeys.imageio.metadata.Entry;\n+import com.twelvemonkeys.imageio.metadata.MetadataReader;\n+import com.twelvemonkeys.imageio.util.IIOUtil;\n+import com.twelvemonkeys.lang.Validate;\n \n /**\n  * XMPReader\n@@ -67,10 +75,9 @@ public final class XMPReader extends MetadataReader {\n     public Directory read(final ImageInputStream input) throws IOException {\n         Validate.notNull(input, \"input\");\n \n-        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n-        factory.setNamespaceAware(true);\n-\n         try {\n+            DocumentBuilderFactory factory = createDocumentBuilderFactory();\n+\n             // TODO: Consider parsing using SAX?\n             // TODO: Determine encoding and parse using a Reader...\n             // TODO: Refactor scanner to return inputstream?\n@@ -79,9 +86,6 @@ public Directory read(final ImageInputStream input) throws IOException {\n             builder.setErrorHandler(new DefaultHandler());\n             Document document = builder.parse(new InputSource(IIOUtil.createStreamAdapter(input)));\n \n-//            XMLSerializer serializer = new XMLSerializer(System.err, System.getProperty(\"file.encoding\"));\n-//            serializer.serialize(document);\n-\n             String toolkit = getToolkit(document);\n             Node rdfRoot = document.getElementsByTagNameNS(XMP.NS_RDF, \"RDF\").item(0);\n             NodeList descriptions = document.getElementsByTagNameNS(XMP.NS_RDF, \"Description\");\n@@ -92,10 +96,33 @@ public Directory read(final ImageInputStream input) throws IOException {\n             throw new IIOException(e.getMessage(), e);\n         }\n         catch (ParserConfigurationException e) {\n-            throw new RuntimeException(e); // TODO: Or IOException?\n+            throw new RuntimeException(e);\n         }\n     }\n \n+    private DocumentBuilderFactory createDocumentBuilderFactory() throws ParserConfigurationException {\n+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+        factory.setNamespaceAware(true);\n+\n+        // Security: Disable XInclude & expanding entity references (\"bombs\"), not needed for XMP\n+        factory.setXIncludeAware(false);\n+        factory.setExpandEntityReferences(false);\n+\n+        // Security: Enable \"secure processing\", to prevent DoS attacks\n+        factory.setAttribute(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n+\n+        // Security: Remove possibility to access external DTDs or Schema, not needed for XMP\n+        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n+        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n+\n+        // Security: Disable loading of external DTD and entities, not needed for XMP\n+        factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+        factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+        factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+\n+        return factory;\n+    }\n+\n     private String getToolkit(Document document) {\n         NodeList xmpmeta = document.getElementsByTagNameNS(XMP.NS_X, \"xmpmeta\");\n \n@@ -109,7 +136,7 @@ private String getToolkit(Document document) {\n     }\n \n     private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, String toolkit) {\n-        Map<String, List<Entry>> subdirs = new LinkedHashMap<String, List<Entry>>();\n+        Map<String, List<Entry>> subdirs = new LinkedHashMap<>();\n \n         for (Node desc : asIterable(pNodes)) {\n             if (desc.getParentNode() != pParentNode) {\n@@ -127,7 +154,7 @@ private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, S\n                 // Lookup\n                 List<Entry> dir = subdirs.get(node.getNamespaceURI());\n                 if (dir == null) {\n-                    dir = new ArrayList<Entry>();\n+                    dir = new ArrayList<>();\n                     subdirs.put(node.getNamespaceURI(), dir);\n                 }\n \n@@ -139,7 +166,7 @@ private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, S\n                 else {\n                     // TODO: This method contains loads of duplication an should be cleaned up...\n                     // Support attribute short-hand syntax\n-                    Map<String, List<Entry>> subsubdirs = new LinkedHashMap<String, List<Entry>>();\n+                    Map<String, List<Entry>> subsubdirs = new LinkedHashMap<>();\n \n                     parseAttributesForKnownElements(subsubdirs, node);\n \n@@ -161,7 +188,7 @@ private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, S\n             }\n         }\n \n-        List<Directory> entries = new ArrayList<Directory>(subdirs.size());\n+        List<Directory> entries = new ArrayList<>(subdirs.size());\n \n         // TODO: Should we still allow asking for a subdirectory by item id?\n         for (Map.Entry<String, List<Entry>> entry : subdirs.entrySet()) {\n@@ -179,7 +206,7 @@ private boolean isResourceType(Node node) {\n \n     private RDFDescription parseAsResource(Node node) {\n         // See: http://www.w3.org/TR/REC-rdf-syntax/#section-Syntax-parsetype-resource\n-        List<Entry> entries = new ArrayList<Entry>();\n+        List<Entry> entries = new ArrayList<>();\n \n         for (Node child : asIterable(node.getChildNodes())) {\n             if (child.getNodeType() != Node.ELEMENT_NODE) {\n@@ -204,7 +231,7 @@ private void parseAttributesForKnownElements(Map<String, List<Entry>> subdirs, N\n             List<Entry> dir = subdirs.get(attr.getNamespaceURI());\n \n             if (dir == null) {\n-                dir = new ArrayList<Entry>();\n+                dir = new ArrayList<>();\n                 subdirs.put(attr.getNamespaceURI(), dir);\n             }\n \n@@ -216,7 +243,7 @@ private Object getChildTextValue(final Node node) {\n         for (Node child : asIterable(node.getChildNodes())) {\n             if (XMP.NS_RDF.equals(child.getNamespaceURI()) && \"Alt\".equals(child.getLocalName())) {\n                 // Support for <rdf:Alt><rdf:li> -> return a Map<String, Object> keyed on xml:lang\n-                Map<String, Object> alternatives = new LinkedHashMap<String, Object>();\n+                Map<String, Object> alternatives = new LinkedHashMap<>();\n                 for (Node alternative : asIterable(child.getChildNodes())) {\n                     if (XMP.NS_RDF.equals(alternative.getNamespaceURI()) && \"li\".equals(alternative.getLocalName())) {\n                         NamedNodeMap attributes = alternative.getAttributes();\n@@ -230,7 +257,7 @@ private Object getChildTextValue(final Node node) {\n             else if (XMP.NS_RDF.equals(child.getNamespaceURI()) && (\"Seq\".equals(child.getLocalName()) || \"Bag\".equals(child.getLocalName()))) {\n                 // Support for <rdf:Seq><rdf:li> -> return array\n                 // Support for <rdf:Bag><rdf:li> -> return array/unordered collection (how can a serialized collection not have order?)\n-                List<Object> seq = new ArrayList<Object>();\n+                List<Object> seq = new ArrayList<>();\n \n                 for (Node sequence : asIterable(child.getChildNodes())) {\n                     if (XMP.NS_RDF.equals(sequence.getNamespaceURI()) && \"li\".equals(sequence.getLocalName())) {"
        },
        {
          "filename": "imageio/imageio-metadata/src/test/java/com/twelvemonkeys/imageio/metadata/xmp/XMPReaderTest.java",
          "status": "modified",
          "additions": 83,
          "deletions": 12,
          "patch": "@@ -30,26 +30,32 @@\n \n package com.twelvemonkeys.imageio.metadata.xmp;\n \n-import com.twelvemonkeys.imageio.metadata.CompoundDirectory;\n-import com.twelvemonkeys.imageio.metadata.Directory;\n-import com.twelvemonkeys.imageio.metadata.Entry;\n-import com.twelvemonkeys.imageio.metadata.MetadataReaderAbstractTest;\n-\n-import org.junit.Test;\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n \n-import javax.imageio.ImageIO;\n-import javax.imageio.stream.ImageInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.nio.charset.StandardCharsets;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Iterator;\n \n-import static org.hamcrest.CoreMatchers.instanceOf;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n+import javax.imageio.ImageIO;\n+import javax.imageio.stream.ImageInputStream;\n+\n+import org.junit.Test;\n+\n+import com.twelvemonkeys.imageio.metadata.CompoundDirectory;\n+import com.twelvemonkeys.imageio.metadata.Directory;\n+import com.twelvemonkeys.imageio.metadata.Entry;\n+import com.twelvemonkeys.imageio.metadata.MetadataReaderAbstractTest;\n \n /**\n  * XMPReaderTest\n@@ -483,4 +489,69 @@ public void testRDFAttributeSyntaxCompoundDirectoryContentEXIF() throws IOExcept\n         assertThat(exif.getEntryById(\"http://ns.adobe.com/exif/1.0/PixelYDimension\"), hasValue(\"550\"));\n         assertThat(exif.getEntryById(\"http://ns.adobe.com/exif/1.0/NativeDigest\"), hasValue(\"36864,40960,40961,37121,37122,40962,40963,37510,40964,36867,36868,33434,33437,34850,34852,34855,34856,37377,37378,37379,37380,37381,37382,37383,37384,37385,37386,37396,41483,41484,41486,41487,41488,41492,41493,41495,41728,41729,41730,41985,41986,41987,41988,41989,41990,41991,41992,41993,41994,41995,41996,42016,0,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,20,22,23,24,25,26,27,28,30;A7F21D25E2C562F152B2C4ECC9E534DA\"));\n     }\n+\n+    @Test(timeout = 1500L)\n+    public void testNoExternalRequest() throws Exception {\n+        // TODO: Use dynamic port?\n+        try (HTTPServer server = new HTTPServer(7777)) {\n+            try {\n+                createReader().read(getResourceAsIIS(\"/xmp/xmp-jpeg-xxe.xml\"));\n+            } catch (IOException ioe) {\n+                if (ioe.getMessage().contains(\"501\")) {\n+                    throw new AssertionError(\"Reading should not cause external requests\", ioe);\n+                }\n+\n+                // Any other exception is a bug (but might happen if the parser does not support certain features)\n+                throw ioe;\n+            }\n+        }\n+    }\n+\n+    private static class HTTPServer implements AutoCloseable {\n+        private final ServerSocket server;\n+        private final Thread thread;\n+\n+        HTTPServer(int port) throws IOException {\n+            server = new ServerSocket(port, 1);\n+            thread = new Thread(new Runnable() {\n+                @Override public void run() {\n+                    serve();\n+                }\n+            });\n+            thread.start();\n+        }\n+\n+        private void serve() {\n+            try {\n+                Socket client = server.accept();\n+\n+                // Get the input stream, don't care about the request\n+                try (InputStream inputStream = client.getInputStream()) {\n+                    while (inputStream.available() > 0) {\n+                        if (inputStream.read() == -1) {\n+                            break;\n+                        }\n+                    }\n+\n+                    // Answer with 501, this will cause the client to throw IOException\n+                    try (OutputStream outputStream = client.getOutputStream()) {\n+                        outputStream.write(\"HTTP/1.0 501 Not Implemented\\r\\n\\r\\n\".getBytes(StandardCharsets.UTF_8));\n+                    }\n+                }\n+            }\n+            catch (IOException e) {\n+                if (server.isClosed() && e instanceof SocketException) {\n+                    // Socket closed due to server close, all good\n+                    return;\n+                }\n+\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override public void close() throws Exception {\n+            server.close();\n+            thread.join(); // It's advised against throwing InterruptedException here, but this is not production code...\n+        }\n+    }\n }"
        },
        {
          "filename": "imageio/imageio-metadata/src/test/resources/xmp/xmp-jpeg-xxe.xml",
          "status": "added",
          "additions": 35,
          "deletions": 0,
          "patch": "@@ -0,0 +1,35 @@\n+<?xpacket begin='\ufeff' id='W5M0MpCehiHzreSzNTczkc9d'?><!DOCTYPE root [<!ENTITY % ext SYSTEM 'http://localhost:7777/xxx'> %ext;]>\n+<x:xmpmeta xmlns:x='adobe:ns:meta/' x:xmptk='Image::ExifTool 10.16'>\n+<rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'>\n+\n+ <rdf:Description rdf:about=''\n+  xmlns:xmpMM='http://ns.adobe.com/xap/1.0/mm/'>\n+  <xmpMM:InstanceID>xmp.iid:7EDC21BF-371B-4189-90AF-C83A54A6A190</xmpMM:InstanceID>\n+ </rdf:Description>\n+</rdf:RDF>\n+</x:xmpmeta>\n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+                                                                                                    \n+<?xpacket end='w'?>\n\\ No newline at end of file"
        }
      ],
      "file_patterns": {
        "security_files": 2,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 3,
        "max_directory_depth": 10
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d39418eca21fefd7ec5b30c2aabdd1ae38e5fcff",
            "date": "2025-01-13T08:10:57Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "cbbc2bc6fe663f1347681a8e3e9b19880c4feb84",
            "date": "2025-01-10T08:23:02Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "b0b423de4f8c6cd6d581caf9ffb9cac56ca95324",
            "date": "2024-12-23T09:01:56Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "1c4ec8d20e68bea63486884c2f7a589e82502a10",
            "date": "2024-12-18T08:33:34Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "ec99a8ce1f38b132b7ffc0c5917295ccf5f5a316",
            "date": "2024-12-18T08:33:31Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
    "cwe_id": "CWE-611",
    "description": "The package com.twelvemonkeys.imageio:imageio-metadata before 3.7.1 are vulnerable to XML External Entity (XXE) Injection due to an insecurely initialized XML parser for reading XMP Metadata. An attacker can exploit this vulnerability if they are able to supply a file (e.g. when an online profile picture is processed) with a malicious XMP segment. If the XMP metadata of the uploaded image is parsed, then the XXE vulnerability is triggered.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-05-06T20:15:07.863",
    "last_modified": "2024-11-21T05:51:53.387",
    "fix_date": "2021-12-10T12:41:05Z"
  },
  "references": [
    {
      "url": "https://github.com/haraldk/TwelveMonkeys/commit/da4efe98bf09e1cce91b7633cb251958a200fc80",
      "source": "report@snyk.io",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://snyk.io/vuln/SNYK-JAVA-COMTWELVEMONKEYSIMAGEIO-2316763",
      "source": "report@snyk.io",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/haraldk/TwelveMonkeys/commit/da4efe98bf09e1cce91b7633cb251958a200fc80",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://snyk.io/vuln/SNYK-JAVA-COMTWELVEMONKEYSIMAGEIO-2316763",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:07.090695",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "TwelveMonkeys",
    "owner": "haraldk",
    "created_at": "2009-09-03T17:44:28Z",
    "updated_at": "2025-01-13T09:26:57Z",
    "pushed_at": "2025-01-13T09:27:00Z",
    "size": 299531,
    "stars": 1930,
    "forks": 318,
    "open_issues": 54,
    "watchers": 1930,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Java": 6546057,
      "C++": 32416,
      "HTML": 12047,
      "CSS": 976
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T22:27:48.204084"
  }
}