{
  "cve_id": "CVE-2021-24117",
  "github_data": {
    "repository": "dingelish/rust-base64",
    "fix_commit": "a554b7ae880553db6dde8a387101a093911d5b2a",
    "related_commits": [
      "a554b7ae880553db6dde8a387101a093911d5b2a",
      "a554b7ae880553db6dde8a387101a093911d5b2a"
    ],
    "patch_url": "https://github.com/dingelish/rust-base64/commit/a554b7ae880553db6dde8a387101a093911d5b2a.patch",
    "fix_commit_details": {
      "sha": "a554b7ae880553db6dde8a387101a093911d5b2a",
      "commit_date": "2021-01-18T06:29:18Z",
      "author": {
        "login": "dingelish",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix",
        "length": 3,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 97,
        "additions": 91,
        "deletions": 6
      },
      "files": [
        {
          "filename": "Cargo.toml",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -25,6 +25,7 @@ structopt = \"0.3\"\n default = [\"std\"]\n alloc = []\n std = []\n+slow_but_safe = []\n \n [profile.bench]\n # Useful for better disassembly when using `perf record` and `perf annotate`"
        },
        {
          "filename": "src/decode.rs",
          "status": "modified",
          "additions": 36,
          "deletions": 0,
          "patch": "@@ -444,6 +444,18 @@ fn write_u64(output: &mut [u8], value: u64) {\n     output[..8].copy_from_slice(&value.to_be_bytes());\n }\n \n+#[cfg(feature = \"slow_but_safe\")]\n+fn decode_aligned(b64ch: u8, decode_table: &[u8; 256]) -> u8 {\n+    let mut result: u8 = 0x00;\n+    let mut mask: u8;\n+    let idx: [u8;2] = [ b64ch % 64, b64ch % 64 + 64];\n+    for i in 0..2  {\n+        mask = 0xFF ^ (((idx[i] == b64ch) as i8 - 1) as u8);\n+        result = result | (decode_table[idx[i] as usize] & mask);\n+    }\n+    result\n+}\n+\n /// Decode 8 bytes of input into 6 bytes of output. 8 bytes of output will be written, but only the\n /// first 6 of those contain meaningful data.\n ///\n@@ -463,13 +475,19 @@ fn decode_chunk(\n ) -> Result<(), DecodeError> {\n     let mut accum: u64;\n \n+    #[cfg(not(feature = \"slow_but_safe\"))]\n     let morsel = decode_table[input[0] as usize];\n+    #[cfg(feature = \"slow_but_safe\")]\n+    let morsel = decode_aligned(input[0], decode_table);\n     if morsel == tables::INVALID_VALUE {\n         return Err(DecodeError::InvalidByte(index_at_start_of_input, input[0]));\n     }\n     accum = (morsel as u64) << 58;\n \n+    #[cfg(not(feature = \"slow_but_safe\"))]\n     let morsel = decode_table[input[1] as usize];\n+    #[cfg(feature = \"slow_but_safe\")]\n+    let morsel = decode_aligned(input[1], decode_table);\n     if morsel == tables::INVALID_VALUE {\n         return Err(DecodeError::InvalidByte(\n             index_at_start_of_input + 1,\n@@ -478,7 +496,10 @@ fn decode_chunk(\n     }\n     accum |= (morsel as u64) << 52;\n \n+    #[cfg(not(feature = \"slow_but_safe\"))]\n     let morsel = decode_table[input[2] as usize];\n+    #[cfg(feature = \"slow_but_safe\")]\n+    let morsel = decode_aligned(input[2], decode_table);\n     if morsel == tables::INVALID_VALUE {\n         return Err(DecodeError::InvalidByte(\n             index_at_start_of_input + 2,\n@@ -487,7 +508,10 @@ fn decode_chunk(\n     }\n     accum |= (morsel as u64) << 46;\n \n+    #[cfg(not(feature = \"slow_but_safe\"))]\n     let morsel = decode_table[input[3] as usize];\n+    #[cfg(feature = \"slow_but_safe\")]\n+    let morsel = decode_aligned(input[3], decode_table);\n     if morsel == tables::INVALID_VALUE {\n         return Err(DecodeError::InvalidByte(\n             index_at_start_of_input + 3,\n@@ -496,7 +520,10 @@ fn decode_chunk(\n     }\n     accum |= (morsel as u64) << 40;\n \n+    #[cfg(not(feature = \"slow_but_safe\"))]\n     let morsel = decode_table[input[4] as usize];\n+    #[cfg(feature = \"slow_but_safe\")]\n+    let morsel = decode_aligned(input[4], decode_table);\n     if morsel == tables::INVALID_VALUE {\n         return Err(DecodeError::InvalidByte(\n             index_at_start_of_input + 4,\n@@ -505,7 +532,10 @@ fn decode_chunk(\n     }\n     accum |= (morsel as u64) << 34;\n \n+    #[cfg(not(feature = \"slow_but_safe\"))]\n     let morsel = decode_table[input[5] as usize];\n+    #[cfg(feature = \"slow_but_safe\")]\n+    let morsel = decode_aligned(input[5], decode_table);\n     if morsel == tables::INVALID_VALUE {\n         return Err(DecodeError::InvalidByte(\n             index_at_start_of_input + 5,\n@@ -514,7 +544,10 @@ fn decode_chunk(\n     }\n     accum |= (morsel as u64) << 28;\n \n+    #[cfg(not(feature = \"slow_but_safe\"))]\n     let morsel = decode_table[input[6] as usize];\n+    #[cfg(feature = \"slow_but_safe\")]\n+    let morsel = decode_aligned(input[6], decode_table);\n     if morsel == tables::INVALID_VALUE {\n         return Err(DecodeError::InvalidByte(\n             index_at_start_of_input + 6,\n@@ -523,7 +556,10 @@ fn decode_chunk(\n     }\n     accum |= (morsel as u64) << 22;\n \n+    #[cfg(not(feature = \"slow_but_safe\"))]\n     let morsel = decode_table[input[7] as usize];\n+    #[cfg(feature = \"slow_but_safe\")]\n+    let morsel = decode_aligned(input[7], decode_table);\n     if morsel == tables::INVALID_VALUE {\n         return Err(DecodeError::InvalidByte(\n             index_at_start_of_input + 7,"
        },
        {
          "filename": "src/lib.rs",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -138,12 +138,12 @@ impl CharacterSet {\n \n     fn decode_table(self) -> &'static [u8; 256] {\n         match self {\n-            CharacterSet::Standard => tables::STANDARD_DECODE,\n-            CharacterSet::UrlSafe => tables::URL_SAFE_DECODE,\n-            CharacterSet::Crypt => tables::CRYPT_DECODE,\n-            CharacterSet::Bcrypt => tables::BCRYPT_DECODE,\n-            CharacterSet::ImapMutf7 => tables::IMAP_MUTF7_DECODE,\n-            CharacterSet::BinHex => tables::BINHEX_DECODE,\n+            CharacterSet::Standard => &tables::STANDARD_DECODE_HOLDER.data,\n+            CharacterSet::UrlSafe => &tables::URL_SAFE_DECODE_HOLDER.data,\n+            CharacterSet::Crypt => &tables::CRYPT_DECODE_HOLDER.data,\n+            CharacterSet::Bcrypt => &tables::BCRYPT_DECODE_HOLDER.data,\n+            CharacterSet::ImapMutf7 => &tables::IMAP_MUTF7_DECODE_HOLDER.data,\n+            CharacterSet::BinHex => &tables::BINHEX_DECODE_HOLDER.data,\n         }\n     }\n }"
        },
        {
          "filename": "src/tables.rs",
          "status": "modified",
          "additions": 48,
          "deletions": 0,
          "patch": "@@ -1,3 +1,35 @@\n+//#[repr(align(64))]\n+//pub struct StructStandardEncode { pub data: [u8; 64] }\n+#[repr(align(64))]\n+pub struct StructStandardDecode { pub data: [u8; 256] }\n+//#[repr(align(64))]\n+//pub struct StructUrlSafeEncode { pub data: [u8; 64] }\n+#[repr(align(64))]\n+pub struct StructUrlSafeDecode { pub data: [u8; 256] }\n+//#[repr(align(64))]\n+//pub struct StructCryptEncode { pub data: [u8; 64] }\n+#[repr(align(64))]\n+pub struct StructCryptDecode { pub data: [u8; 256] }\n+//#[repr(align(64))]\n+//pub struct StructBcryptEncode { pub data: [u8; 64] }\n+#[repr(align(64))]\n+pub struct StructBcryptDecode { pub data: [u8; 256] }\n+//#[repr(align(64))]\n+//pub struct StructImapMutf7Encode { pub data: [u8; 64] }\n+#[repr(align(64))]\n+pub struct StructImapMutf7Decode { pub data: [u8; 256] }\n+//#[repr(align(64))]\n+//pub struct StructBinhexEncode { pub data: [u8; 64] }\n+#[repr(align(64))]\n+pub struct StructBinhexDecode { pub data: [u8; 256] }\n+\n+pub const STANDARD_DECODE_HOLDER: StructStandardDecode = StructStandardDecode { data: *STANDARD_DECODE };\n+pub const URL_SAFE_DECODE_HOLDER: StructUrlSafeDecode = StructUrlSafeDecode { data: *URL_SAFE_DECODE };\n+pub const CRYPT_DECODE_HOLDER: StructCryptDecode = StructCryptDecode { data: *CRYPT_DECODE };\n+pub const BCRYPT_DECODE_HOLDER: StructBcryptDecode = StructBcryptDecode { data: *BCRYPT_DECODE };\n+pub const IMAP_MUTF7_DECODE_HOLDER: StructImapMutf7Decode = StructImapMutf7Decode { data: *IMAP_MUTF7_DECODE };\n+pub const BINHEX_DECODE_HOLDER: StructBinhexDecode = StructBinhexDecode { data: *BINHEX_DECODE };\n+\n pub const INVALID_VALUE: u8 = 255;\n #[rustfmt::skip]\n pub const STANDARD_ENCODE: &[u8; 64] = &[\n@@ -1955,3 +1987,19 @@ pub const BINHEX_DECODE: &[u8; 256] = &[\n     INVALID_VALUE, // input 254 (0xFE)\n     INVALID_VALUE, // input 255 (0xFF)\n ];\n+\n+#[test]\n+fn alignment_check() {\n+    let p: *const u8 = STANDARD_DECODE_HOLDER.data.as_ptr();\n+    assert_eq!((p as u64) % 64, 0);\n+    let p: *const u8 = URL_SAFE_DECODE_HOLDER.data.as_ptr();\n+    assert_eq!((p as u64) % 64, 0);\n+    let p: *const u8 = CRYPT_DECODE_HOLDER.data.as_ptr();\n+    assert_eq!((p as u64) % 64, 0);\n+    let p: *const u8 = BCRYPT_DECODE_HOLDER.data.as_ptr();\n+    assert_eq!((p as u64) % 64, 0);\n+    let p: *const u8 = IMAP_MUTF7_DECODE_HOLDER.data.as_ptr();\n+    assert_eq!((p as u64) % 64, 0);\n+    let p: *const u8 = BINHEX_DECODE_HOLDER.data.as_ptr();\n+    assert_eq!((p as u64) % 64, 0);\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 1,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "48e6225ac1fb55b086bdb12e60df8bb86b9439e4",
            "date": "2021-02-01T19:16:39Z",
            "author_login": "dingelish"
          },
          {
            "sha": "a554b7ae880553db6dde8a387101a093911d5b2a",
            "date": "2021-01-18T06:29:18Z",
            "author_login": "dingelish"
          },
          {
            "sha": "b4fc91325ec985e2a18e83e95a3c08eebd636af4",
            "date": "2020-09-30T15:20:02Z",
            "author_login": "marshallpierce"
          },
          {
            "sha": "bba4c5d11e3b5f0974d7d126342e0ca67bb4cc1f",
            "date": "2020-09-30T15:18:07Z",
            "author_login": "marshallpierce"
          },
          {
            "sha": "42967320b3c675c8ae5d3d46dd6e6aea4a7fc970",
            "date": "2020-09-30T14:30:45Z",
            "author_login": "marshallpierce"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-203",
    "description": "In Apache Teaclave Rust SGX SDK 1.1.3, a side-channel vulnerability in base64 PEM file decoding allows system-level (administrator) attackers to obtain information about secret RSA keys via a controlled-channel and side-channel attack on software running in isolated environments that can be single stepped, especially Intel SGX.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-07-14T14:15:08.810",
    "last_modified": "2024-11-21T05:52:23.567",
    "fix_date": "2021-01-18T06:29:18Z"
  },
  "references": [
    {
      "url": "https://docs.rs/crate/sgx_tstd/1.1.1",
      "source": "cve@mitre.org",
      "tags": [
        "Product",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/UzL-ITS/util-lookup/blob/main/cve-vulnerability-publication.md",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/dingelish/rust-base64/commit/a554b7ae880553db6dde8a387101a093911d5b2a",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://docs.rs/crate/sgx_tstd/1.1.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/UzL-ITS/util-lookup/blob/main/cve-vulnerability-publication.md",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/dingelish/rust-base64/commit/a554b7ae880553db6dde8a387101a093911d5b2a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:02.305667",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "rust-base64",
    "owner": "dingelish",
    "created_at": "2020-12-14T21:46:59Z",
    "updated_at": "2021-02-01T19:16:48Z",
    "pushed_at": "2021-02-01T19:16:45Z",
    "size": 477,
    "stars": 0,
    "forks": 0,
    "open_issues": 0,
    "watchers": 0,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Rust": 245332
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T23:03:16.178518"
  }
}