{
  "cve_id": "CVE-2021-25981",
  "github_data": {
    "repository": "debiki/talkyard",
    "fix_commit": "b0310df019887f3464895529c773bc7d85ddcf34",
    "related_commits": [
      "b0310df019887f3464895529c773bc7d85ddcf34",
      "b0712915d8a22a20b09a129924e8a29c25ae5761",
      "b0310df019887f3464895529c773bc7d85ddcf34",
      "b0712915d8a22a20b09a129924e8a29c25ae5761"
    ],
    "patch_url": "https://github.com/debiki/talkyard/commit/b0310df019887f3464895529c773bc7d85ddcf34.patch",
    "fix_commit_details": {
      "sha": "b0310df019887f3464895529c773bc7d85ddcf34",
      "commit_date": "2021-07-08T09:56:09Z",
      "author": {
        "login": "kajmagnus",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Better session ids, 5 parts, feature flag to enable.",
        "length": 52,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 4191,
        "additions": 3833,
        "deletions": 358
      },
      "files": [
        {
          "filename": "appsv/model/src/main/scala/com/debiki/core/Prelude.scala",
          "status": "modified",
          "additions": 141,
          "deletions": 16,
          "patch": "@@ -23,7 +23,7 @@ import java.{util => ju}\n import java.{security => js}\n import org.apache.commons.codec.{binary => acb}\n import org.scalactic.{ErrorMessage, Or}\n-import play.api.libs.json.{JsNumber, JsObject, JsString}\n+import play.api.libs.json._\n \n import scala.collection.mutable\n import scala.util.Try\n@@ -64,13 +64,27 @@ object Prelude {   CLEAN_UP; RENAME // to BugDie and re-export the interesting\n   // Should get rid of this version:\n   def warnDbgDie(errorMsg: String): Unit = { warnDbgDie(\"\", errorMsg) }\n \n-  def warnDbgDieIf(test: => Bo, errorCode: St, details: St): U = {\n+  def warnDevDieIf(test: => Bo, errorCode: St, details: St = \"\"): U =\n+    warnDbgDieIf(test, errorCode, details)\n+\n+  RENAME // to ..DevDie..?\n+  def warnDbgDieIf(test: => Bo, errorCode: St, details: St = \"\"): U = {\n     if (test) {\n       warnDbgDie(errorCode, details)\n     }\n   }\n \n+  def warnDevDieUnless(test: => Bo, errorCode: St, details: St = \"\"): U = {\n+    if (!test) {\n+      warnDbgDie(errorCode, details)\n+    }\n+  }\n+\n   def warnDbgDie(errorCode: St, warningMsg: St): U = {\n+    warnDevDie(errorCode, warningMsg)\n+  }\n+\n+  def warnDevDie(errorCode: St, warningMsg: St = \"\"): U = {\n     if (true) {\n       // Fail hard in debug mode so this error will be fixed.\n       throw new AssertionError(s\"$warningMsg [$errorCode]\")\n@@ -582,13 +596,34 @@ object Prelude {   CLEAN_UP; RENAME // to BugDie and re-export the interesting\n   }\n \n \n-  /** Generates a 130 bit string, almost 26 chars long since each char in a 32 chars\n-    * alphabet has 5 bits (but we use 36 chars here).\n+  /** Generates a by default 130 bits entropy string, almost 26 chars long since\n+    * each char in a 32 chars alphabet has 5 bits (but we use 36 chars here).\n     * Wikipedia says: \"128-bit keys are commonly used and considered very strong\".\n     * Here: http://en.wikipedia.org/wiki/Key_(cryptography)\n     */\n-  def nextRandomString(): String =\n-    new java.math.BigInteger(130, _random).toString(36) // 0..9, a..z\n+  def nextRandomString(bitsEntropy: i32 = 130, base36: Bo = true,\n+          base64UrlSafe: Bo = false): St = {\n+    require(base36 != base64UrlSafe)\n+    if (base36) {\n+      // Hmm the resulting length is a bit random \u2014 if the BigInteger happens to start\n+      // with 0, the base 36 encoding will be shorter (leading zeroes are excluded).\n+      val bigInt = new java.math.BigInteger(bitsEntropy, _random)\n+      bigInt.toString(36) // 0..9, a..z\n+    }\n+    else {\n+      assert(base64UrlSafe)\n+      // Divisible by 8, so byte aligned \u2014 _random operates on bytes.\n+      assert(bitsEntropy % 8 == 0)\n+      // Divisible by 6, so always result in same length Base64 repr.\n+      assert(bitsEntropy % 6 == 0)\n+      val numBytes = bitsEntropy / 8\n+      val bytesArray = new Array[Byte](numBytes)\n+      _random.nextBytes(bytesArray)\n+      val res = acb.Base64.encodeBase64URLSafeString(bytesArray)\n+      assert(res.length * 6 == bitsEntropy)\n+      res\n+    }\n+  }\n \n   // COULD split this in a random string function, and other id generation\n   // functions, with string length adjusted, depending on how the random\n@@ -648,12 +683,26 @@ object Prelude {   CLEAN_UP; RENAME // to BugDie and re-export the interesting\n   def saltAndHashEmail: St => St = saltAndHash(hashLengthEmail) _\n   def saltAndHashIp: St => St = saltAndHash(hashLengthIp) _\n \n-  SECURITY; COULD // use SHA-256 instead.\n-  private def mdSha1 = js.MessageDigest.getInstance(\"SHA-1\") // not thread safe\n+  SECURITY; COULD_OPTIMIZE // use BLAKE3 instead.\n+  private def mdSha1: js.MessageDigest = js.MessageDigest.getInstance(\"SHA-1\") // not thread safe\n+\n+  /// SHA-512/256 is faster and stronger than SHA-224 (not in a way that matters, but anyway).\n+  /// And BLAKE3 has a 256 bits output too by default.\n+  private def mdSha512: js.MessageDigest =\n+    js.MessageDigest.getInstance(\"SHA-512\") // not thread safe\n \n   def hashSha1Base64UrlSafe(text: String): String =\n     acb.Base64.encodeBase64URLSafeString(mdSha1.digest(text.getBytes(\"UTF-8\")))\n \n+  def hashSha512FirstHalf32Bytes(text: St): Array[i8] = {\n+    // I think this isn't the real SHA512/256, but this'll be ok too.\n+    // SHA-512/256 not incl in Java 8.\n+    // Later: Use BLAKE3, the Rust implementation, call from Java.\n+    val res = mdSha512.digest(text.getBytes(\"UTF-8\"))\n+    assert(res.length == 32 * 2)\n+    res take 32\n+  }\n+\n \n   /* ------  Move to a 'security' package?    [406MRED256]\n   def base32EncodeSecretKey(key: javax.crypto.SecretKey): St = {\n@@ -789,25 +838,52 @@ object Prelude {   CLEAN_UP; RENAME // to BugDie and re-export the interesting\n   private val AToZUnderscoreRegex = \"^[a-zA-Z_]*$\".r\n   private val VariableNameRegex = \"^[a-zA-Z_][a-zA-Z0-9_]*$\".r\n   private val AlNumWithAl = \"^[a-zA-Z0-9_]*[a-zA-Z_][a-zA-Z0-9_]*$\".r\n+  private val AlNumDashRegex = \"^[a-zA-Z0-9_-]*$\".r\n \n   /** Checks that all fields names are okay variable names,\n     * and that all values are numbers, or also okay variable names.\n     * Just to avoid any unexpected things like some kind of injection.\n     */\n-  def anyWeirdJsObjField(obj: JsObject, maxLength: Int): Option[String] = {\n+  def anyWeirdJsObjField(obj: JsObject, maxLength: i32,\n+           allowHeaderNameValues: Bo = false): Opt[St] = {\n+    unimplIf(allowHeaderNameValues, \"TyE50MFEDJ4601\")\n     for ((fieldName, fieldValue) <- obj.fields) {\n-      if (fieldName.isEmpty) return Some(\"Empty field name\")\n-      if (!fieldName.isOkVariableName) return Some(s\"Weird field name: $fieldName\")\n-      if (fieldName.length > maxLength) return Some(s\"Too long field name: $fieldName\")\n+      if (fieldName.isEmpty)\n+        return Some(\"Empty field name\")\n+\n+      if (allowHeaderNameValues) {\n+        if (!fieldName.isOkHeaderName)\n+          return Some(s\"Weird header name: '$fieldName' [TyE0HDRNAME]\")\n+      }\n+      else {\n+        if (!fieldName.isOkVariableName)\n+          return Some(s\"Weird field name: '$fieldName' [TyE0VARNAME]\")\n+      }\n+\n+      if (fieldName.length > maxLength)\n+        return Some(s\"Too long field name: '$fieldName' [TyE2LNGFLDNM]\")\n+\n       fieldValue match {\n         case _: JsNumber =>\n           // Fine\n         case s: JsString =>\n-          if (s.value.isEmpty) return Some(s\"Empty value for field $fieldName\")\n-          if (!s.value.isOkVariableName) return Some(s\"Bad value for field $fieldName: $fieldValue\")\n-          if (s.value.length > maxLength) return Some(s\"Too long field value, $fieldName: $fieldValue\")\n+          if (s.value.isEmpty)\n+            return Some(s\"Empty value for field $fieldName\")\n+\n+          if (allowHeaderNameValues) {\n+            // Don't allow newlines in value?\n+            unimpl(\"TyE50MFEDJ4602\")\n+          }\n+          else if (!s.value.isOkVariableName) {\n+            return Some(s\"Bad value for field $fieldName: '$fieldValue'\")\n+          }\n+\n+          if (s.value.length > maxLength)\n+            return Some(s\"Too long field value, $fieldName: '$fieldValue'\")\n+\n         case _ =>\n-          return Some(s\"Value of field $fieldName is weird\")\n+          return Some(s\"Value of field $fieldName is not a nummer or string; it is a ${\n+            classNameOf(fieldValue)} [TyEFIELDVALTYP]\")\n       }\n     }\n     None\n@@ -818,6 +894,52 @@ object Prelude {   CLEAN_UP; RENAME // to BugDie and re-export the interesting\n   def anyWeirdJsObjField(obj: JsObject): Option[String] =\n     anyWeirdJsObjField(obj, maxLength = 100)\n \n+  def jsObjectSize(obj: JsObject, depth: i32 = 0): i32 = {\n+    TESTS_MISSING\n+    var size = 0\n+    for ((fieldName, value) <- obj.fields) {\n+      size += fieldName.length + jsValueSize(value, depth = depth + 1)\n+    }\n+    size\n+  }\n+\n+  private def jsValueSize(value: JsValue, depth: i32 = 0): i32 = {\n+    TESTS_MISSING\n+    if (depth > 10)\n+      return Int.MaxValue // for now\n+    value match {\n+      case JsNull => 4\n+      case _: JsBoolean => 4\n+      case _: JsNumber => 4 // let's just guess 4 bytes. Or log-10?\n+      case s: JsString => s.value.length\n+      case _: JsArray =>\n+        // What about infinitely deeply nested empty arrays in arrays! Would be size 0 :-(\n+        Int.MaxValue // for now\n+        // a.value.foldLeft(0)((len, v) => {\n+        //   jsValueSize(v, sizeThisFar + len, maxAllowedSize, depth = depth + 1)\n+        // })\n+      case _: JsObject =>\n+        Int.MaxValue // for now\n+        //jsObjectSize(o)\n+      case _ =>\n+        // What's this?\n+        assert(false)\n+        Int.MaxValue\n+    }\n+  }\n+\n+  // Move to where?\n+  val JsEmptyObj2: JsObject = JsObject(Nil)\n+\n+  /*\n+  def mapKeyValuesTotalLength(map: Map[St, Any], depth: i32 = 0): i32 = {\n+    var size = 0\n+    for ((fieldName, value) <- map) {\n+      size += fieldName.length + jsValueSize(value, depth = depth + 1)\n+      // or:   + value match { case n: some-number: ...  case s: St => s.length  case _ => no! }\n+    }\n+    size\n+  } */\n \n   /**\n    * Pimps `String` with `matches(regex): Boolean` and `misses(regex)`\n@@ -874,6 +996,9 @@ object Prelude {   CLEAN_UP; RENAME // to BugDie and re-export the interesting\n     def isOkVariableName: Boolean =\n       VariableNameRegex.pattern.matcher(underlying).matches\n \n+    def isOkHeaderName: Bo =\n+      underlying.nonEmpty && AlNumDashRegex.pattern.matcher(underlying).matches\n+\n     def isAlNum: Bo =\n       underlying.forall(charIsAzOrNum)\n "
        },
        {
          "filename": "appsv/model/src/main/scala/com/debiki/core/Site.scala",
          "status": "modified",
          "additions": 30,
          "deletions": 5,
          "patch": "@@ -72,6 +72,34 @@ object Site {\n }\n \n \n+trait SiteTrait {\n+  def id: SiteId\n+  def pubId: PubSiteId\n+  def status: SiteStatus\n+  def featureFlags: St\n+\n+  def isTestSite: Bo = id <= Site.MaxTestSiteId\n+\n+  def isFeatureEnabled(ffName: St, serverFeatureFlags: St): Bo = {\n+    val offName = \"0\" + ffName  // zero  \u2014 same as when disabling options in Vim\n+    val enabledWholeServer = serverFeatureFlags.contains(ffName)\n+    val disabledWholeServer = serverFeatureFlags.contains(offName)\n+    val enabledThisSite = featureFlags.contains(ffName)\n+    val disabledThisSite = featureFlags.contains(offName)\n+    val enabledSomewhere = enabledWholeServer || enabledThisSite\n+    val disabledSomewhere = disabledWholeServer || disabledThisSite\n+    // By default a feature flag is not enabled, and can be enabled in a   [ff_on_off]\n+    // specific site only via this.featureFlags. So, if a feature has been\n+    // disabled explicitly in the whole server, then, that overrides\n+    // it being enabled per site (so it'll be disabled everywhere) (Otherwise\n+    // disabledWholeServer would be pointless.)\n+    // However, if a feature is enabled by default (for all sites), then,\n+    // a site can disable it.\n+    enabledSomewhere && !disabledSomewhere\n+  }\n+}\n+\n+\n /**\n   * @param hostname \u2014 doesn't include any port number.\n   */\n@@ -81,8 +109,7 @@ case class SiteBrief(\n   hostname: Opt[St],\n   status: SiteStatus,\n   featureFlags: St,\n-) {\n-  def isTestSite: Bo = id <= Site.MaxTestSiteId\n+) extends SiteTrait {\n }\n \n \n@@ -217,7 +244,7 @@ case class Site(  // Remove? Use SiteBrief or SiteDetailed instead?\n   readLimitsMultiplier: Opt[f32],\n   logLimitsMultiplier: Opt[f32],\n   createLimitsMultiplier: Opt[f32],\n-  ) extends SiteIdHostnames with SiteLimitsMultipliers {\n+  ) extends SiteIdHostnames with SiteLimitsMultipliers with SiteTrait {\n \n   // Reqiure at most 1 canonical host.\n   //require((0 /: hosts)(_ + (if (_.isCanonical) 1 else 0)) <= 1)\n@@ -227,8 +254,6 @@ case class Site(  // Remove? Use SiteBrief or SiteDetailed instead?\n \n   def allHostnames: Seq[St] = hostnames.map(_.hostname)\n \n-  def isTestSite: Bo = id <= MaxTestSiteId\n-\n   def brief: SiteBrief =\n     SiteBrief(id, pubId, canonicalHostname.map(_.hostname), status,\n           featureFlags = featureFlags)"
        },
        {
          "filename": "appsv/model/src/main/scala/com/debiki/core/SiteTransaction.scala",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -450,6 +450,15 @@ trait SiteTransaction {   RENAME // to SiteTx \u2014 already started with a type Si\n   def nextMemberId: UserId\n   def insertMember(user: UserInclDetails): Unit\n \n+\n+  def loadSession(part1Maybe2Or3: Opt[St] = None, part4HttpOnly: Opt[St] = None,\n+        maybeActiveOnly: Bo = false): Opt[TySessionInDbMaybeBad]\n+  def loadOneOrTwoSessions(part1Maybe2Or3: Opt[St], part4HttpOnly: Opt[St],\n+        maybeActiveOnly: Bo): ImmSeq[TySessionInDbMaybeBad]\n+  def loadActiveSessions(patId: PatId): ImmSeq[TySessionInDbMaybeBad]\n+  def insertValidSession(session: TySession): U\n+  def upsertSession(session: TySessionInDbMaybeBad): U\n+\n   def tryLoginAsMember(loginAttempt: MemberLoginAttempt, requireVerifiedEmail: Boolean)\n         : Hopefully[MemberLoginGrant]\n   def loginAsGuest(loginAttempt: GuestLoginAttempt): GuestLoginResult"
        },
        {
          "filename": "appsv/model/src/main/scala/com/debiki/core/SystemTransaction.scala",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -109,6 +109,7 @@ trait SystemTransaction {  RENAME // to SysTx, started already\n \n   // ----- The janitor: Old stuff deletion\n \n+  def deletePersonalDataFromOldSessions(): U\n   def deletePersonalDataFromOldAuditLogEntries(): Unit\n   def deletePersonalDataFromOldSpamCheckTasks(): Unit\n   def deleteOldUnusedUploads(): Unit = { /* ... later ... */ }"
        },
        {
          "filename": "appsv/model/src/main/scala/com/debiki/core/TySession.scala",
          "status": "added",
          "additions": 234,
          "deletions": 0,
          "patch": "@@ -0,0 +1,234 @@\n+package com.debiki.core\n+\n+import com.debiki.core.Prelude._\n+import play.api.libs.json.JsObject\n+\n+\n+/** The session id is split into 5 parts in 3 cookies: a not-HttpOnly cookie,\n+  * a HttpOnly and a HttpOnly SameSite=Strict cookie.  [cookie_theory]\n+  *\n+  * Each one of the 5 parts is, entropy wise, strong enough, on its own.\n+  * To do more \"important\" things, more parts are needed. Whilst\n+  * the first parts, not-HttpOnly, make Talkyard work also in blog comments iframes\n+  * where cookies tend to not work.\n+  *\n+  * If expiredAt or deletedAt is set, the session cannot be used.\n+  * A session can be both expired and deleted (if it gets deleted just when it expires).\n+  *\n+  * @param patId\n+  * @param createdAt\n+  * @param deletedAt\n+  * @param expiredAt \u2014 updated lazily, on use. So, even if the\n+  *   current time is past the createdAt + expiration time, expiredAt might be unset\n+  *   \u2014 but when pat tries to use the session again, the server will notice it has\n+  *   expired, and update expiredAt, thereby terminating the session.\n+  * @param version\n+  * @param startIp \u2014 where the user was, when hen started the session.\n+  * @param startBrowserId\n+  * @param startHeaders \u2014 some relevant headers from the request that created the session.\n+  * @param part1CompId \u2014 comparation id, not really secret.\n+  * @param part2HashForEmbgStorage\n+  * @param part3HashForDirJs\n+  * @param part4HashHttpOnly\n+  * @param part5HashStrict\n+  */\n+case class TySessionInDbMaybeBad(\n+  patId: PatId,\n+  createdAt: When,\n+  deletedAt: Opt[When],\n+  expiredAt: Opt[When],\n+  version: i32,\n+  startIp: Opt[IpAdr],\n+  startBrowserId: Opt[BrowserIdSt],\n+  startHeaders: JsObject,\n+  part1CompId: St,\n+  part2HashForEmbgStorage: Array[i8],\n+  part3HashForDirJs: Array[i8],\n+  part4HashHttpOnly: Array[i8],\n+  part5HashStrict: Array[i8]) {\n+\n+  def isValidNow(now: When, expireIdleAfterMins: i32): Bo =\n+    wasValidJustRecently && !expiresNow(now, expireIdleAfterMins = expireIdleAfterMins)\n+\n+  def wasValidJustRecently: Bo = !isDeleted && !hasExpired\n+\n+  def isDeleted: Bo = deletedAt.isDefined\n+  def hasExpired: Bo = expiredAt.isDefined\n+\n+  def expiresNow(now: When, expireIdleAfterMins: i32): Bo = {\n+    val expiresAt = createdAt.millis + expireIdleAfterMins * MillisPerMinute\n+    expiresAt <= now.millis\n+  }\n+\n+\n+  /// We lookup the session by part 1, and part 2 is required \u2014 so 1 and 2 are never absent.\n+  def copyAsValid(part2: St, part3: Opt[St], part4: Opt[St], part5: Opt[St])\n+          : TySession = {\n+    dieIf(expiredAt.isDefined || deletedAt.isDefined, \"TyESESS0VALID\")\n+    TySession(\n+          patId = patId,\n+          createdAt = createdAt,\n+          version = version,\n+          startIp = startIp,\n+          startBrowserId = startBrowserId,\n+          startHeaders = startHeaders,\n+          part1CompId = part1CompId,\n+          part2ForEmbgStorage = part2,\n+          part2Hash = part2HashForEmbgStorage,\n+          part3ForDirJs = part3,\n+          part3Hash = part3HashForDirJs,\n+          part4HttpOnly = part4,\n+          part4Hash = part4HashHttpOnly,\n+          part5Strict = part5,\n+          part5Hash = part5HashStrict)\n+  }\n+}\n+\n+\n+/** Later, more fields, see:\n+  * https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#session-id-content-or-value\n+  *\n+  * @param patId\n+  * @param createdAt\n+  * @param version\n+  * @param part1CompId\n+  * @param part2ForEmbgStorage\n+  * @param part2Hash\n+  * @param part3ForDirJs\n+  * @param part3Hash\n+  * @param part4HttpOnly\n+  * @param part4Hash\n+  * @param part5Strict\n+  * @param part5Hash\n+  * @param isApiCall COULD split TySession into ClientSession and SingleApiReqSession maybe?\n+  */\n+case class TySession(\n+  patId: PatId,\n+  createdAt: When,\n+  version: i32,\n+  startIp: Opt[IpAdr],\n+  startBrowserId: Opt[BrowserIdSt],\n+  startHeaders: JsObject,\n+  part1CompId: St,\n+  part2ForEmbgStorage: St,\n+  part2Hash: Array[i8],\n+  part3ForDirJs: Opt[St],\n+  part3Hash: Array[i8],\n+  part4HttpOnly: Opt[St],\n+  part4Hash: Array[i8],\n+  part5Strict: Opt[St],\n+  part5Hash: Array[i8],\n+  isApiCall: Bo = false) {\n+\n+  import TySession._\n+  require(version == 1, \"TyE30MFEW25MMR\")\n+\n+  require(jsObjectSize(startHeaders) < MaxSessionHeadersSize, \"TyE4MW2AP7J\")\n+\n+  require(part1CompId.length  == SidLengthCharsPart1, s\"Len pt 1: ${part1CompId.length}\")\n+\n+  require(part2Hash.length == SidHashLengthBytes, s\"Len pt 2 hash: ${part2Hash.length}\")\n+  require(part2ForEmbgStorage.length == SidLengthCharsPart2,\n+        s\"Len pt 2: ${part2ForEmbgStorage.length}\")\n+\n+  require(part3Hash.length == SidHashLengthBytes, s\"Len pt 3 hash: ${part3Hash.length}\")\n+  require(part3ForDirJs.forall(_.length == SidLengthCharsPart3),\n+        s\"Len pt 3: ${part3ForDirJs.map(_.length)}\")\n+\n+  require(part4Hash.length == SidHashLengthBytes, s\"Len pt 4 hash: ${part4Hash.length}\")\n+  require(part4HttpOnly.forall(_.length == SidLengthCharsPart4),\n+        s\"Len pt 4: ${part4HttpOnly.map(_.length)}\")\n+\n+  require(part5Hash.length == SidHashLengthBytes, s\"Len pt 5 hash: ${part5Hash.length}\")\n+  require(part5Strict.forall(_.length == SidLengthCharsPart5),\n+        s\"Len pt 5: ${part5Strict.map(_.length)}\")\n+\n+  if (com.debiki.core.isDevOrTest) {\n+    import com.debiki.core.Prelude.{hashSha512FirstHalf32Bytes => hash}\n+    dieIf(!hash(part2ForEmbgStorage).sameElements(part2Hash), \"TyEBADHASH02\")\n+    dieIf(part3ForDirJs.exists(!hash(_).sameElements(part3Hash)), \"TyEBADHASH03\")\n+    dieIf(part4HttpOnly.exists(!hash(_).sameElements(part4Hash)), \"TyEBADHASH04\")\n+    dieIf(part5Strict.exists(!hash(_).sameElements(part5Hash)), \"TyEBADHASH05\")\n+  }\n+\n+  def part1And2: St = part1CompId + part2ForEmbgStorage\n+\n+  def part3Absent: Bo = part3ForDirJs.isEmpty\n+  def part4Absent: Bo = part4HttpOnly.isEmpty\n+  def part4Present: Bo = !part4Absent\n+  def part5Absent: Bo = part5Strict.isEmpty\n+}\n+\n+\n+\n+object TySession {\n+\n+  val CurVersion = 1\n+\n+  // A random Base64 char is 6 bits entropy (with a good rand gen).\n+  val SidEntropyPerChar: i32 = 6\n+  val SidCharsetBase: i32 = 64\n+\n+  // These long session ids might seem like a bit overkill \u2014 OWASP writes that 64 bits\n+  // entropy is enough, that's about 11 chars in Base64.  [sid_part1]\n+  // https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#session-id-entropy\n+  //\n+  // However, parts 1, 2 are for embedded comments, and for optionally saving in\n+  // the localStorage of embedding pages (e.g. blog posts) which is more risky.\n+  // If indeed parts 1 and 2 get compromised, we can still rely on part 3 alone\n+  // \u2014 it's 144 bits entropy > 64.\n+  //\n+  val SidLengthCharsPart1: i32 = 16\n+  val SidLengthCharsPart2: i32 = 24\n+  val SidLengthCharsPart3: i32 = 24\n+  val SidLengthCharsPart4: i32 = 24\n+  val SidLengthCharsPart5: i32 = 16\n+\n+  val SidLengthCharsPart12: i32 =\n+      SidLengthCharsPart1 +\n+      SidLengthCharsPart2\n+\n+  val SidLengthCharsPart123: i32 =\n+      SidLengthCharsPart12 +\n+      SidLengthCharsPart3\n+\n+  val SidLengthCharsTotal: i32 =\n+        SidLengthCharsPart123 +\n+        SidLengthCharsPart4 +\n+        SidLengthCharsPart5\n+\n+  val ApiSecretPart1 = \"API_SID_PT_1_pad\"          // 16 chars\n+  val ApiSecretPart2 = \"API_SID_PT_2_pad_24_abcd\"  // 24 chars\n+  val ApiSecretPart12: St = ApiSecretPart1 + ApiSecretPart2\n+\n+  // BLAKE3 and SHA-512/256 have 256 bits output size = 32 bytes.\n+  val SidHashLengthBytes = 32\n+\n+  // (Part 3, 4, 5 not included in an API call TySession, so the hashes\n+  // can be set to whatever. But part 2 is always included; the real hash is needed.)\n+  val DummyHash: Array[i8] = Array.fill(SidHashLengthBytes)(0.asInstanceOf[i8])\n+  val DummyHashPart2: Array[i8] = hashSha512FirstHalf32Bytes(ApiSecretPart2)\n+\n+  val MaxSessionHeadersSize = 1000\n+\n+  def singleApiCallSession(asPatId: PatId): TySession =\n+    TySession(\n+          patId = asPatId,\n+          // Maybe use now() instead? Shouldn't ever matter.\n+          createdAt = When.Genesis,\n+          version = CurVersion,\n+          startIp = None,\n+          startBrowserId = None,\n+          startHeaders = JsObject.empty,\n+          part1CompId = ApiSecretPart1,\n+          part2ForEmbgStorage = ApiSecretPart2,\n+          part2Hash = DummyHashPart2,\n+          part3ForDirJs = None,\n+          part3Hash = DummyHash,\n+          part4HttpOnly = None,\n+          part4Hash = DummyHash,\n+          part5Strict = None,\n+          part5Hash = DummyHash,\n+          isApiCall = true)\n+\n+}"
        },
        {
          "filename": "appsv/model/src/main/scala/com/debiki/core/package.scala",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -99,6 +99,7 @@ package object core {\n   def isDevOrTest: Bo = Prelude.isDevOrTest\n   def isProd: Bo = Prelude.isProd\n \n+  type SidSt = St   // [Scala_3] opaque type\n   type SignOnId = St   // [Scala_3] opaque type   change to SsoId?\n   type SsoId = SignOnId   // [Scala_3] opaque type   change to SsoId?\n \n@@ -666,6 +667,8 @@ package object core {\n   type ReqrId = Who // RENAME to ReqrIds? (with an ...s)\n                     // ... because is more than one id (user id, ip, bowser id cookie, etc)\n \n+  type BrowserIdSt = St  // [Scala_3] opaque type\n+\n   RENAME // to ReqrId? = \"Requester id\" and that's what it is: the user id plus hens browser id data.\n   // I find \"who\" being confusing as to whom it refers to.\n   case class Who(id: UserId, browserIdData: BrowserIdData) {\n@@ -1617,5 +1620,6 @@ package object core {\n \n   def GRAPH_DATABASE = () // Some queries are inefficient and require lots of code, when using a\n                           // relational database \u2014 but are simple and fast, with a graph database.\n+  def CHECK_AUTHN_STRENGTH = ()\n }\n "
        },
        {
          "filename": "appsv/rdb/src/main/scala/com/debiki/dao/rdb/CreateSiteSystemDaoMixin.scala",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -226,6 +226,7 @@ trait CreateSiteSystemDaoMixin extends SystemTransaction {  // RENAME to SystemS\n       delete from usernames3 where site_id = ?\n       delete from user_emails3 where site_id = ?\n       delete from group_participants3 where site_id = ?\n+      delete from sessions_t where site_id_c = ?\n       delete from users3 where site_id = ?\n       \"\"\").trim.split(\"\\n\").toBuffer\n "
        },
        {
          "filename": "appsv/rdb/src/main/scala/com/debiki/dao/rdb/Rdb.scala",
          "status": "modified",
          "additions": 17,
          "deletions": 0,
          "patch": "@@ -117,6 +117,13 @@ object Rdb {\n     def orNullJson: AnyRef = opt.getOrElse(Null(js.Types.OTHER))\n   }\n \n+  implicit class PimpJsObjWithNullIfEmpty(jsOb: JsObject) {\n+    def orNullIfEmpty: AnyRef = {\n+      if (jsOb.value.isEmpty) Null(js.Types.OTHER)\n+      else jsOb\n+    }\n+  }\n+\n   /*\n   implicit class PimpOptionWithNullArray(opt: Option[ ? ]) {\n     def orNullArray: AnyRef = opt.getOrElse(Null(js.Types.ARRAY))\n@@ -330,6 +337,16 @@ object Rdb {\n     else Some(When.fromMillis(timestamp.getTime))\n   }\n \n+  def getByteArray(rs: js.ResultSet, column: St): Array[i8] = {\n+    val bytes = rs.getBytes(column)\n+    dieIf(bytes eq null, \"TyERSNULLBYTES\", s\"Column $column is null, should be a bytea\")\n+    bytes\n+  }\n+\n+  def getOptByteArray(rs: js.ResultSet, column: St): Opt[Array[i8]] = {\n+    Opt(rs.getBytes(column))\n+  }\n+\n   def getOptArrayOfStrings(rs: js.ResultSet, column: String): Option[immutable.Seq[String]] = {\n     val sqlArray: js.Array = rs.getArray(column)\n     if (sqlArray eq null) return None"
        },
        {
          "filename": "appsv/rdb/src/main/scala/com/debiki/dao/rdb/RdbSiteTransaction.scala",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -50,6 +50,7 @@ class RdbSiteTransaction(var siteId: SiteId, val daoFactory: RdbDaoFactory, val\n   with SearchSiteDaoMixin\n   with SpamCheckQueueDaoMixin\n   with AuthnSiteTxMixin\n+  with SessionsRdbMixin\n   with UserSiteDaoMixin\n   with EmailAddressesSiteDaoMixin\n   with UsernamesSiteDaoMixin"
        },
        {
          "filename": "appsv/rdb/src/main/scala/com/debiki/dao/rdb/RdbSystemTransaction.scala",
          "status": "modified",
          "additions": 33,
          "deletions": 0,
          "patch": "@@ -895,6 +895,37 @@ class RdbSystemTransaction(\n   val SomeMonthsAgo = 5\n   val SomeYearsAgo = 5\n \n+  def deletePersonalDataFromOldSessions(): U = {\n+    TESTS_MISSING\n+    PRIVACY; COULD // make x months below configurable\n+    /*\n+    val deleteABitStatement = s\"\"\"\n+          update sessions_t set\n+            start_ip_c = start_ip_c & inet '255.255.255.0',\n+            start_headers_c = null\n+            -- start_browser_id_c = hash(..)\n+            forgotten_c = 1\n+          where\n+            forgotten_c = 0 and                    -- needs new col\n+            least(deleted_at_c, expired_at_c) < ?  -- needs ix  [sess_deleted_ix]\n+          \"\"\"\n+    runUpdate(deleteABitStatement, List(now.minusMonths(SomeMonthsAgo).asTimestamp))\n+\n+    val deleteMoreStatement = s\"\"\"\n+          update sessions_t set\n+            start_ip_c = start_ip_c & inet '255.255.0.0',\n+            start_headers_c = null,\n+            start_browser_id_c = null,\n+            forgotten_c = 2\n+          where\n+            forgotten_c = 1 and                    -- needs new col\n+            least(deleted_at_c, expired_at_c) < ?  -- needs ix\n+          \"\"\"\n+    runUpdate(deleteMoreStatement, List(now.minusMonths(SomeYearsAgo).asTimestamp))\n+    */\n+  }\n+\n+\n   def deletePersonalDataFromOldAuditLogEntries() {\n     TESTS_MISSING\n \n@@ -920,6 +951,7 @@ class RdbSystemTransaction(\n         forgotten = 0 and\n         done_at < ?\n       \"\"\"\n+\n     runUpdate(deleteABitStatement, List(now.minusMonths(SomeMonthsAgo).asTimestamp))\n \n     PRIVACY; COULD // make x years below configurable\n@@ -1049,6 +1081,7 @@ class RdbSystemTransaction(\n       delete from usernames3\n       delete from user_emails3\n       delete from group_participants3\n+      delete from sessions_t\n       delete from users3\n       delete from hosts3\n       delete from sites3"
        },
        {
          "filename": "appsv/rdb/src/main/scala/com/debiki/dao/rdb/SessionsRdbMixin.scala",
          "status": "added",
          "additions": 234,
          "deletions": 0,
          "patch": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2021 Kaj Magnus Lindberg\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as\n+ * published by the Free Software Foundation, either version 3 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.debiki.dao.rdb\n+\n+import com.debiki.core._\n+import com.debiki.core.Prelude._\n+import Rdb._\n+import RdbUtil._\n+import java.sql.{ResultSet => j_ResultSet, SQLException => j_SQLException}\n+import collection.{mutable => mut}\n+\n+\n+\n+/** Manages user sessions. But why are sessions stored in Postgres, not Redis?\n+  * For security reasons. It's good to be able to:\n+  * - Look up all current sessions by a certain user.\n+  * - Look up all sessions by ip addr.\n+  * - List sessions by time and user / ip.\n+  * - Remember if a session's ip address changes (could be suspicious \u2014 is there\n+  *   enough time for the person to travel to the new location?).\n+  * - Delete some or all of a user's session, and remember who did this and when.\n+  * - Delete all posts made by a session \u2014 in case someone got pwned.\n+  *\n+  * All that would be doable in Redis, but it's simpler, in Postgres. And,\n+  * combined with an app server in-process mem cache, this approach can also be made\n+  * faster than Redis (which is an out of process mem cache, slower).\n+  *\n+  * Maybe some time later, sessions will need to be temporarily buffered in Redis\n+  * or elsewhere somehow, and only written to Postgres every once in a while\n+  * (except for when logging out \u2014 that'd get persisted immediately).\n+  * Or even some other type of storage.  But that's in the distant future.\n+  */\n+trait SessionsRdbMixin extends SiteTransaction {\n+  self: RdbSiteTransaction =>\n+\n+\n+    /// This loads also sessions that have expired, but whose expired_at_c\n+    /// column hasn't been updated yet. \u2014 That's why there's \"Maybe\" in the\n+    /// val name \u2014 sessions that are *maybe* still active.\n+    private val AndMaybeActiveOnlySql =\n+      \"and deleted_at_c is null and expired_at_c is null\"\n+\n+  def loadSession(part1Maybe2Or3: Opt[St] = None, part4HttpOnly: Opt[St] = None,\n+        maybeActiveOnly: Bo = false)\n+        : Opt[TySessionInDbMaybeBad] = {\n+    dieIf(part1Maybe2Or3.isDefined == part4HttpOnly.isDefined, \"TyE50MG24SMP\")\n+    val part1OrHash4 = part4HttpOnly.map(hashSha512FirstHalf32Bytes) getOrElse {\n+      // Compare with part 1 only (not 2 or 3).\n+      part1Maybe2Or3.getOrDie(\"TyE603MWEG657\") take TySession.SidLengthCharsPart1\n+    }\n+\n+    val andMaybeActiveOnlySql =\n+          if (maybeActiveOnly) AndMaybeActiveOnlySql else \"\"\n+\n+    // Test, part 4: sso-test  TyT4ABKRW0268.TyTESESS123GONE\n+    // Test, part 1: All the time, whenever logged in.\n+\n+    val colName = if (part1Maybe2Or3.isDefined) \"part_1_comp_id_c\" else \"hash_4_http_only_c\"\n+    val query = s\"\"\"\n+          select * from sessions_t\n+          where site_id_c = ?\n+            and $colName = ?\n+            $andMaybeActiveOnlySql \"\"\"\n+    runQueryFindOneOrNone(query, List(siteId.asAnyRef, part1OrHash4), parseSession)\n+  }\n+\n+\n+  def loadOneOrTwoSessions(part1Maybe2Or3: Opt[St], part4HttpOnly: Opt[St],\n+        maybeActiveOnly: Bo = false): ImmSeq[TySessionInDbMaybeBad] = {\n+    if (part1Maybe2Or3.isEmpty && part4HttpOnly.isEmpty)\n+      return Vec.empty\n+\n+    val values = MutArrBuf[AnyRef]()\n+    values.append(siteId.asAnyRef)\n+\n+    val partOneEq = part1Maybe2Or3 map { part1Etc =>\n+      // Skip part 2 and 3.\n+      values.append(part1Etc take TySession.SidLengthCharsPart1)\n+      \"part_1_comp_id_c = ?\"\n+    } getOrElse \"\"\n+\n+    val or =\n+          if (part1Maybe2Or3.isEmpty || part4HttpOnly.isEmpty) \"\"\n+          else \"or\"\n+\n+    val partFourEq = part4HttpOnly map { part4 =>\n+      values.append(hashSha512FirstHalf32Bytes(part4))\n+      \"hash_4_http_only_c = ?\"\n+    } getOrElse \"\"\n+\n+    val andMaybeActiveOnlySql =\n+          if (maybeActiveOnly) AndMaybeActiveOnlySql else \"\"\n+\n+    val query = s\"\"\"\n+          select * from sessions_t\n+          where site_id_c = ? and ($partOneEq $or $partFourEq) $andMaybeActiveOnlySql\"\"\"\n+\n+    runQueryFindMany(query, values.toList, parseSession)\n+  }\n+\n+\n+  def loadActiveSessions(patId: PatId): ImmSeq[TySessionInDbMaybeBad] = {\n+    val query = s\"\"\"\n+          -- ix: sessions_i_patid_createdat_active\n+          select * from sessions_t\n+          where site_id_c = ?\n+            and pat_id_c = ?\n+            and deleted_at_c is null\n+            and expired_at_c is null\n+          order by created_at_c desc  \"\"\"\n+    runQueryFindMany(query, List(siteId.asAnyRef, patId.asAnyRef), parseSession)\n+  }\n+\n+\n+  def insertValidSession(session: TySession): U = {\n+    dieIf(session.part1CompId == TySession.ApiSecretPart1, \"TyE7P02MRED1\")\n+    dieIf(session.part2Hash sameElements TySession.DummyHashPart2, \"TyE7P02MRED2\")\n+\n+    val statement = s\"\"\"\n+          insert into sessions_t (\n+              site_id_c,\n+              pat_id_c,\n+              created_at_c,\n+              deleted_at_c,\n+              expired_at_c,\n+              version_c,\n+              start_ip_c,\n+              start_headers_c,\n+              start_browser_id_c,\n+              part_1_comp_id_c,\n+              hash_2_for_embg_storage_c,\n+              hash_3_for_dir_js_c,\n+              hash_4_http_only_c,\n+              hash_5_strict_c)\n+          values (?, ?, ?, null, null, ?, ?::inet, ?, ?, ?, ?, ?, ?, ?)  \"\"\"\n+\n+    val values = List(\n+          siteId.asAnyRef,\n+          session.patId.asAnyRef,\n+          session.createdAt.asTimestamp,\n+          session.version.asAnyRef,\n+          session.startIp.orNullVarchar,\n+          session.startHeaders.orNullIfEmpty,\n+          session.startBrowserId.orNullVarchar,\n+          session.part1CompId,\n+          session.part2Hash,\n+          session.part3Hash,\n+          session.part4Hash,\n+          session.part5Hash)\n+\n+    runUpdateSingleRow(statement, values)\n+  }\n+\n+\n+  def upsertSession(session: TySessionInDbMaybeBad): U = {\n+    dieIf(session.part1CompId == TySession.ApiSecretPart1, \"TyE7P02MRED3\")\n+    dieIf(session.part2HashForEmbgStorage sameElements TySession.DummyHashPart2, \"TyE7P02MRED4\")\n+\n+    // Inserting expired sessions can be useful if restoring from a backup.\n+    val statement = \"\"\"\n+          insert into sessions_t (\n+              site_id_c,\n+              pat_id_c,\n+              created_at_c,\n+              deleted_at_c,\n+              expired_at_c,\n+              version_c,\n+              start_ip_c,\n+              start_headers_c,\n+              start_browser_id_c,\n+              part_1_comp_id_c,\n+              hash_2_for_embg_storage_c,\n+              hash_3_for_dir_js_c,\n+              hash_4_http_only_c,\n+              hash_5_strict_c)\n+          values (?, ?, ?, ?, ?, ?, ?::inet, ?, ?, ?, ?, ?, ?, ?)\n+          on conflict (site_id_c, pat_id_c, created_at_c)   -- pk\n+          do update set\n+              deleted_at_c = least(sessions_t.deleted_at_c, excluded.deleted_at_c),\n+              expired_at_c = least(sessions_t.expired_at_c, excluded.expired_at_c)  \"\"\"\n+\n+    val values = List(\n+          siteId.asAnyRef,\n+          session.patId.asAnyRef,\n+          session.createdAt.asTimestamp,\n+          session.deletedAt.orNullTimestamp,\n+          session.expiredAt.orNullTimestamp,\n+          session.version.asAnyRef,\n+          session.startIp.orNullVarchar,\n+          session.startHeaders.orNullIfEmpty,\n+          session.startBrowserId.noneIfBlank.orNullVarchar,\n+          session.part1CompId,\n+          session.part2HashForEmbgStorage,\n+          session.part3HashForDirJs,\n+          session.part4HashHttpOnly,\n+          session.part5HashStrict)\n+\n+    runUpdateSingleRow(statement, values)\n+  }\n+\n+\n+  private def parseSession(rs: j_ResultSet): TySessionInDbMaybeBad = {\n+    TySessionInDbMaybeBad(\n+          patId =  getInt32(rs, \"pat_id_c\"),\n+          createdAt = getWhen(rs, \"created_at_c\"),\n+          deletedAt = getOptWhen(rs, \"deleted_at_c\"),\n+          expiredAt = getOptWhen(rs, \"expired_at_c\"),\n+          version = getInt(rs, \"version_c\"),\n+          startIp = getOptString(rs, \"start_ip_c\"),\n+          startHeaders = getOptJsObject(rs, \"start_headers_c\") getOrElse JsEmptyObj2,\n+          startBrowserId = getOptString(rs, \"start_browser_id_c\"),\n+          part1CompId = getString(rs, \"part_1_comp_id_c\"),\n+          part2HashForEmbgStorage = getByteArray(rs, \"hash_2_for_embg_storage_c\"),\n+          part3HashForDirJs = getByteArray(rs, \"hash_3_for_dir_js_c\"),\n+          part4HashHttpOnly = getByteArray(rs, \"hash_4_http_only_c\"),\n+          part5HashStrict = getByteArray(rs, \"hash_5_strict_c\"))\n+  }\n+\n+}"
        },
        {
          "filename": "appsv/server/controllers/DebugTestController.scala",
          "status": "modified",
          "additions": 9,
          "deletions": 6,
          "patch": "@@ -41,6 +41,7 @@ import scala.concurrent.Future._\n import scala.util.Try\n import talkyard.server.TyLogging\n import talkyard.server.JsX._\n+import talkyard.server.authn.MinAuthnStrength\n \n \n /** Intended for troubleshooting, via the browser, and helps running End-to-End tests.\n@@ -55,7 +56,8 @@ class DebugTestController @Inject()(cc: ControllerComponents, edContext: EdConte\n   /** If a JS error happens in the browser, it'll post the error message to this\n     * endpoint, which logs it, so we'll get to know about client side errors.\n     */\n-  def logBrowserErrors: Action[JsValue] = PostJsonAction(RateLimits.BrowserError, maxBytes = 10000) {\n+  def logBrowserErrors: Action[JsValue] = PostJsonAction(\n+        RateLimits.BrowserError, MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 10000) {\n         request =>\n     val allErrorMessages = request.body.as[Seq[String]]\n     // If there are super many errors, perhaps all of them is the same error. Don't log too many.\n@@ -298,15 +300,16 @@ class DebugTestController @Inject()(cc: ControllerComponents, edContext: EdConte\n         request =>\n     throwForbiddenIf(globals.isProd, \"TyE502KUJ5\",\n         \"I only do this, in Prod mode, when an odd number of \" +\n-          \"Phoenix birds sleep at my fireplace\")\n+          \"Phoenix birds sleep at my fireplace, and more than one\")\n     val key = (request.body \\ \"key\").as[String]\n     context.globals.redisClient.del(key)\n     Ok\n   }\n \n \n-  def skipRateLimitsForThisSite: Action[JsValue] =\n-        PostJsonAction(RateLimits.BrowserError, maxBytes = 150) { request =>\n+  def skipRateLimitsForThisSite: Action[JsValue] = PostJsonAction(\n+        RateLimits.BrowserError, MinAuthnStrength.E2eTestPassword, maxBytes = 150) {\n+            request =>\n     val okE2ePassword = context.security.hasOkE2eTestPassword(request.underlying)\n     throwForbiddenIf(globals.isProd && !okE2ePassword,\n       \"TyE8WTHFJ25\", \"I only do this, in Prod mode, if I can see two moons from \" +\n@@ -332,8 +335,8 @@ class DebugTestController @Inject()(cc: ControllerComponents, edContext: EdConte\n   }\n \n \n-  def addAdminNotice: Action[JsValue] =\n-        PostJsonAction(RateLimits.BrowserError, maxBytes = 50) { request =>\n+  def addAdminNotice: Action[JsValue] = PostJsonAction(\n+        RateLimits.BrowserError, MinAuthnStrength.E2eTestPassword, maxBytes = 50) { request =>\n     val okE2ePassword = context.security.hasOkE2eTestPassword(request.underlying)\n     throwForbiddenIf(globals.isProd && !okE2ePassword, \"TyE60MRGP35\", \"E2e pwd missing\")\n     import request.body"
        },
        {
          "filename": "appsv/server/controllers/DraftsController.scala",
          "status": "modified",
          "additions": 14,
          "deletions": 5,
          "patch": "@@ -27,9 +27,10 @@ import ed.server.http._\n import javax.inject.Inject\n import play.api.libs.json._\n import play.api.mvc._\n-import scala.util.Try\n import scala.collection.immutable\n import talkyard.server.JsX.JsDraft\n+import talkyard.server.authn.MinAuthnStrength\n+\n \n \n class DraftsController @Inject()(cc: ControllerComponents, edContext: EdContext)\n@@ -39,7 +40,8 @@ class DraftsController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   import context.security.{throwNoUnless, throwIndistinguishableNotFound}\n \n \n-  def upsertDraft: Action[JsValue] = PostJsonAction(RateLimits.DraftSomething, maxBytes = MaxPostSize) {\n+  def upsertDraft: Action[JsValue] = PostJsonAction(RateLimits.DraftSomething,\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = MaxPostSize) {\n         request: JsonPostRequest =>\n     upsertDraftImpl(request.body, request)\n   }\n@@ -48,7 +50,8 @@ class DraftsController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   /** In the browser, navigator.sendBeacon insists on sending plain text. So need this text handler.\n     */\n   def upsertDraftBeacon: Action[String] = PostTextAction(\n-        RateLimits.DraftSomething, maxBytes = MaxPostSize) { request =>\n+        RateLimits.DraftSomething,\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = MaxPostSize) { request =>\n     val bodyXsrfTokenRemoved = request.body.dropWhile(_ != '\\n') // [7GKW20TD]\n     val json = Json.parse(bodyXsrfTokenRemoved)\n     upsertDraftImpl(json, request)\n@@ -79,6 +82,8 @@ class DraftsController @Inject()(cc: ControllerComponents, edContext: EdContext)\n     draft = draft.copy(\n       byUserId = requester.id)  // [602KDGRE20]\n \n+    CHECK_AUTHN_STRENGTH\n+\n     // Early access control, if possible:\n     //\n     if (draft.isNewTopic) {\n@@ -184,13 +189,15 @@ class DraftsController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   }\n \n \n-  def deleteDrafts: Action[JsValue] = PostJsonAction(RateLimits.DraftSomething, maxBytes = 1000) {\n+  def deleteDrafts: Action[JsValue] = PostJsonAction(RateLimits.DraftSomething,\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 1000) {\n         request: JsonPostRequest =>\n     deleteDraftsImpl(request.body, request)\n   }\n \n \n-  def deleteDraftsBeacon: Action[String] = PostTextAction(RateLimits.DraftSomething, maxBytes = 1000) {\n+  def deleteDraftsBeacon: Action[String] = PostTextAction(RateLimits.DraftSomething,\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 1000) {\n         request: ApiRequest[String] =>\n     val bodyXsrfTokenRemoved = request.body.dropWhile(_ != '\\n') // [7GKW20TD]\n     val json = Json.parse(bodyXsrfTokenRemoved)\n@@ -202,6 +209,8 @@ class DraftsController @Inject()(cc: ControllerComponents, edContext: EdContext)\n     import request.{dao, theRequester => requester}\n     val byUserId = requester.id\n     val draftNrs = json.as[Seq[DraftNr]]\n+\n+    CHECK_AUTHN_STRENGTH\n     dao.readWriteTransaction { tx =>\n       draftNrs.foreach(nr => tx.deleteDraft(byUserId, nr))\n     }"
        },
        {
          "filename": "appsv/server/controllers/EditController.scala",
          "status": "modified",
          "additions": 33,
          "deletions": 10,
          "patch": "@@ -32,6 +32,7 @@ import EditController._\n import debiki.onebox.LinkPreviewRenderer\n import scala.concurrent.ExecutionContext\n import talkyard.server.JsX.{JsDraft, JsDraftOrNull, JsStringOrNull}\n+import talkyard.server.authn.MinAuthnStrength\n import org.scalactic.{Good, Or, Bad}\n \n \n@@ -47,8 +48,10 @@ class EditController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   REFACTOR // Move to DraftController?\n   def loadDraftAndGuidelines(writingWhat: Int, draftType: Int, pageRole: Int,\n         categoryId: Option[Int], toUserId: Option[UserId],\n-        pageId: Option[String], postNr: Option[Int]): Action[Unit] =\n-      GetActionRateLimited(RateLimits.ReadsFromDb) { request =>\n+        pageId: Option[String], postNr: Option[Int],\n+        ): Action[Unit] =\n+            GetActionRateLimited(\n+              RateLimits.ReadsFromDb, MinAuthnStrength.EmbeddingStorageSid12) { request =>\n \n     import request.{dao, requester}\n \n@@ -80,7 +83,9 @@ class EditController @Inject()(cc: ControllerComponents, edContext: EdContext)\n           postNr = postNr))\n     }\n \n-    val drafts = requester flatMap { theRequester =>\n+    CHECK_AUTHN_STRENGTH\n+\n+    val drafts: ImmSeq[Draft] = requester flatMap { theRequester =>\n       anyDraftLocator map { draftLocator =>\n         dao.readOnlyTransaction { tx =>\n           tx.loadDraftsByLocator(theRequester.id, draftLocator)\n@@ -128,15 +133,17 @@ class EditController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   /** Sends back a post's current CommonMark source to the browser.\n     * SHOULD change to pageId + postId (not postNr)  [idnotnr]\n     */\n-  def loadDraftAndText(pageId: String, postNr: Int): Action[Unit] =\n-        GetActionRateLimited(RateLimits.ReadsFromDb) { request =>\n+  def loadDraftAndText(pageId: String, postNr: Int): Action[Unit] = GetActionRateLimited(\n+        RateLimits.ReadsFromDb, MinAuthnStrength.EmbeddingStorageSid12) { request =>\n \n     import request.{dao, theRequester => requester}\n \n     val pageMeta = dao.getPageMeta(pageId) getOrElse throwIndistinguishableNotFound(\"EdE4JBR01\")\n     val post = dao.loadPost(pageId, postNr) getOrElse throwIndistinguishableNotFound(\"EdE0DK9WY3\")\n     val categoriesRootLast = dao.getAncestorCategoriesRootLast(pageMeta.categoryId)\n \n+    CHECK_AUTHN_STRENGTH\n+\n     throwNoUnless(Authz.mayEditPost(\n       request.theUserAndLevels, dao.getOnesGroupIds(request.theUser),\n       post, pageMeta, dao.getAnyPrivateGroupTalkMembers(pageMeta),\n@@ -169,7 +176,8 @@ class EditController @Inject()(cc: ControllerComponents, edContext: EdContext)\n \n   /** Edits posts.\n     */\n-  def edit: Action[JsValue] = PostJsonAction(RateLimits.EditPost, maxBytes = MaxPostSize) {\n+  def edit: Action[JsValue] = PostJsonAction(RateLimits.EditPost,\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = MaxPostSize) {\n         request: JsonPostRequest =>\n     import request.{dao, body}\n     val pageId = (body \\ \"pageId\").as[PageId]\n@@ -200,6 +208,8 @@ class EditController @Inject()(cc: ControllerComponents, edContext: EdContext)\n \n     val categoriesRootLast = dao.getAncestorCategoriesRootLast(pageMeta.categoryId)\n \n+    CHECK_AUTHN_STRENGTH\n+\n     throwNoUnless(Authz.mayEditPost(\n       request.theUserAndLevels, dao.getOnesGroupIds(request.theUser),\n       post, pageMeta, dao.getAnyPrivateGroupTalkMembers(pageMeta),\n@@ -232,7 +242,8 @@ class EditController @Inject()(cc: ControllerComponents, edContext: EdContext)\n     * then creates and returns sanitized onebox html.\n     */\n   def fetchLinkPreview(url: St, curPageId: PageId, inline: Bo): Action[U] =\n-        AsyncGetActionRateLimited(RateLimits.FetchLinkPreview) { request =>\n+        AsyncGetActionRateLimited(\n+            RateLimits.FetchLinkPreview, MinAuthnStrength.EmbeddingStorageSid12) { request =>\n     import edContext.globals\n     import request.{siteId, requesterOrUnknown}\n \n@@ -261,6 +272,8 @@ class EditController @Inject()(cc: ControllerComponents, edContext: EdContext)\n     // text and then later the server tries to render a link preview,\n     // possibly as part of a rerender / reindex-things background job.\n \n+    CHECK_AUTHN_STRENGTH\n+\n     val renderer = new LinkPreviewRenderer(\n           globals, siteId = siteId, mayHttpFetch = true,\n           requesterId = requesterOrUnknown.id)\n@@ -291,7 +304,11 @@ class EditController @Inject()(cc: ControllerComponents, edContext: EdContext)\n \n \n   def loadPostRevisions(postId: PostId, revisionNr: String): Action[Unit] =\n-        GetActionRateLimited(RateLimits.ExpensiveGetRequest) { request =>\n+        GetActionRateLimited(RateLimits.ExpensiveGetRequest,\n+            MinAuthnStrength.EmbeddingStorageSid12) { request =>\n+\n+    CHECK_AUTHN_STRENGTH\n+\n     val revisionNrInt =\n       if (revisionNr == \"LastRevision\") PostRevision.LastRevisionMagicNr\n       else revisionNr.toIntOption getOrElse throwBadRequest(\"EdE8UFMW2\", \"Bad revision nr\")\n@@ -327,7 +344,8 @@ class EditController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   }\n \n \n-  def deletePost: Action[JsValue] = PostJsonAction(RateLimits.DeletePost, maxBytes = 5000) { request =>\n+  def deletePost: Action[JsValue] = PostJsonAction(RateLimits.DeletePost,\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 5000) { request =>\n     import request.dao\n     val pageId = (request.body \\ \"pageId\").as[PageId]\n     val postNr = (request.body \\ \"postNr\").as[PostNr]\n@@ -337,6 +355,8 @@ class EditController @Inject()(cc: ControllerComponents, edContext: EdContext)\n       if (repliesToo) PostStatusAction.DeleteTree\n       else PostStatusAction.DeletePost(clearFlags = false)\n \n+    CHECK_AUTHN_STRENGTH\n+\n     val result = dao.changePostStatus(postNr, pageId = pageId, action, userId = request.theUserId)\n \n     OkSafeJson(Json.obj(\n@@ -349,14 +369,17 @@ class EditController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   }\n \n \n-  def movePost: Action[JsValue] = StaffPostJsonAction(maxBytes = 300) { request =>\n+  def movePost: Action[JsValue] = StaffPostJsonAction(\n+          MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 300) { request =>\n     val pageId = (request.body \\ \"pageId\").as[PageId]   // apparently not used\n     val postId = (request.body \\ \"postId\").as[PostId]   // id not nr\n     val newHost = (request.body \\ \"newHost\").asOpt[String] // ignore for now though\n     val newSiteId = (request.body \\ \"newSiteId\").asOpt[SiteId] // ignore for now though\n     val newPageId = (request.body \\ \"newPageId\").as[PageId]\n     val newParentNr = (request.body \\ \"newParentNr\").asOpt[PostNr].getOrElse(PageParts.BodyNr)\n \n+    CHECK_AUTHN_STRENGTH\n+\n     val (_, storePatch) = request.dao.movePostIfAuth(PagePostId(pageId, postId),\n       newParent = PagePostNr(newPageId, newParentNr), moverId = request.theMember.id,\n       request.theBrowserIdData)"
        },
        {
          "filename": "appsv/server/controllers/EmbeddedTopicsController.scala",
          "status": "modified",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -49,6 +49,13 @@ class EmbeddedTopicsController @Inject()(cc: ControllerComponents, edContext: Ed\n   }\n \n \n+  /** If in iframe, either no cookies get included, or all \u2014 so won't\n+    * run into problems with just parts of the session id being present,\n+    * and we can leave the authn strength at the default, MinAuthnStrength.Normal.\n+    *\n+    * Might need to ask the user to click a button in the iframe, triggering\n+    * iOS to show a dialog where the user can let the iframe use cookies.  [ios_itp]\n+    */\n   def showTopic(embeddingUrl: String, discussionId: Option[AltPageId],   // [5BRW02]\n           edPageId: Option[PageId], category: Option[Ref], scriptV: Opt[St]): Action[U] =\n       AsyncGetActionMaybeSkipCookies(avoidCookies = true) { request =>\n@@ -124,6 +131,16 @@ class EmbeddedTopicsController @Inject()(cc: ControllerComponents, edContext: Ed\n           a specific id, you can use the data-discussion-id=\"...\" html attribute in\n           the Talkyard html code snippet in your blog.\"\"\")\n \n+        CHECK_AUTHN_STRENGTH // done just above. Some time later, maybe also\n+        // some per category checks?\n+        // Apparently Safari can pop up a dialog where the user can let the iframe\n+        // use cookies, if hen interacts with the iframe. So, if a blog comments\n+        // discussion requires authn to read, Ty could show a button in the iframe,\n+        // like, \"Click to authenticate\"?\n+        // Then, if clicking, Safari would ask if the iframe was allowed to use cookies,\n+        // and (if answering Yes), one would get logged in directly, if there were\n+        // cookies already?  [ios_itp]\n+\n         val (maySee, debugCode) = dao.maySeePageUseCache(pageMeta, request.requester)\n         if (!maySee)\n           security.throwIndistinguishableNotFound(debugCode)\n@@ -133,6 +150,7 @@ class EmbeddedTopicsController @Inject()(cc: ControllerComponents, edContext: Ed\n \n         val pageRequest = new PageRequest[Unit](\n           request.site,\n+          request.anyTySession,\n           sid = request.sid,\n           xsrfToken = request.xsrfToken,\n           browserId = request.browserId,"
        },
        {
          "filename": "appsv/server/controllers/FlagController.scala",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -25,6 +25,7 @@ import javax.inject.Inject\n import play.api.mvc._\n import ed.server.auth.Authz\n import play.api.libs.json.JsValue\n+import talkyard.server.authn.MinAuthnStrength\n \n \n \n@@ -36,7 +37,8 @@ class FlagController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   import context.security._\n \n \n-  def flagPost: Action[JsValue] = PostJsonAction(RateLimits.FlagPost, maxBytes = 2000) { request =>\n+  def flagPost: Action[JsValue] = PostJsonAction(RateLimits.FlagPost,\n+          MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 2000) { request =>\n     import request.{body, dao}\n     SHOULD // change from page-id + post-nr to post-id.\n     val pageId = (body \\ \"pageId\").as[PageId]\n@@ -57,6 +59,8 @@ class FlagController @Inject()(cc: ControllerComponents, edContext: EdContext)\n     val post = dao.loadPost(pageId, postNr) getOrElse throwIndistinguishableNotFound(\"EdE5PJB2R8\")\n     val categoriesRootLast = dao.getAncestorCategoriesRootLast(pageMeta.categoryId)\n \n+    CHECK_AUTHN_STRENGTH\n+\n     throwNoUnless(Authz.mayFlagPost(\n       request.theMember, dao.getOnesGroupIds(request.theUser),\n       post, pageMeta, dao.getAnyPrivateGroupTalkMembers(pageMeta),"
        },
        {
          "filename": "appsv/server/controllers/ImpersonateController.scala",
          "status": "modified",
          "additions": 13,
          "deletions": 10,
          "patch": "@@ -48,7 +48,7 @@ class ImpersonateController @Inject()(cc: ControllerComponents, edContext: EdCon\n   val MaxKeyAgeSeconds = 3600\n \n   // This stuff is used client side too. [8AXFC0J2]\n-  private val ImpersonationCookieName = \"esCoImp\"\n+  private val ImpersonationCookieName = \"esCoImp\"  ; SECURITY ; SHOULD // add a HttpOnly cookie too? & delete. Both cookies required.\n   private val FieldSeparator = '.'\n   private val ViewAsGroupOnly = \"VAO\"\n   private val ImpersonateRealUser = \"IRU\"\n@@ -111,7 +111,7 @@ class ImpersonateController @Inject()(cc: ControllerComponents, edContext: EdCon\n       throwForbidden(\"EsE8YKW3\", s\"Wrong site id: ${request.siteId}, should go to site $siteId\")\n \n     // ? mark as online ?\n-    val (_, _, sidAndXsrfCookies) = createSessionIdAndXsrfToken(siteId, userId)\n+    val (_, _, sidAndXsrfCookies) = createSessionIdAndXsrfToken(request, userId)\n     Redirect(\"/\").withCookies(sidAndXsrfCookies: _*)\n   }\n \n@@ -144,11 +144,11 @@ class ImpersonateController @Inject()(cc: ControllerComponents, edContext: EdCon\n     dieIf(anyUserId.isDefined && viewAsOnly, \"EdE6WKT0S\")\n \n     val sidAndXsrfCookies = anyUserId.toList flatMap { userId =>\n-      createSessionIdAndXsrfToken(request.siteId, userId)._3\n+      createSessionIdAndXsrfToken(request, userId)._3\n     }\n \n-    val logoutCookie =\n-      if (anyUserId.isEmpty) Seq(DiscardingSessionCookie)\n+    val logoutCookies =\n+      if (anyUserId.isEmpty) DiscardingSessionCookies\n       else Nil\n \n     val impCookie = makeImpersonationCookie(request.siteId, viewAsOnly, request.theUserId)\n@@ -160,7 +160,7 @@ class ImpersonateController @Inject()(cc: ControllerComponents, edContext: EdCon\n     // time events isn't the purpose of view-site-as.  The client should resubscribe\n     // the requester to hens *own* notfs, once done impersonating, though.\n \n-    Ok.withCookies(newCookies: _*).discardingCookies(logoutCookie: _*)\n+    Ok.withCookies(newCookies: _*).discardingCookies(logoutCookies: _*)\n   }\n \n \n@@ -182,19 +182,22 @@ class ImpersonateController @Inject()(cc: ControllerComponents, edContext: EdCon\n         // What's this? Clicking Stop Impersonating, but no such cookie?\n         // Maybe clicking twice in different tabs? Anyway, feels\n         // better to log out, so as not to accidentally stay logged in somehow.\n-        LoginController.doLogout(request, redirectIfMayNotSeeUrlPath = None)\n+        LoginController.doLogout(request, redirectIfMayNotSeeUrlPath = None,\n+              wasImpersonating = true)\n       case Some(cookieValue) =>\n         val response =\n           checkHashElseGetAgeAndUserId(cookieValue) match {\n             case Bad(r) => r\n             case Good((secondsAgo, oldUserId)) =>\n-              // Ignore old impersonation cookies, in case they're leaked somehow.\n+                // Ignore old impersonation cookies, in case they're leaked somehow.\n                 if (secondsAgo > MaxBecomeOldUserSeconds || oldUserId == NoUserId) {\n-                  LoginController.doLogout(request, redirectIfMayNotSeeUrlPath = None)\n+                  LoginController.doLogout(request, redirectIfMayNotSeeUrlPath = None,\n+                        wasImpersonating = true)\n                 }\n                 else {\n                   // Restore the old user id.\n-                  val (_, _, sidAndXsrfCookies) = createSessionIdAndXsrfToken(request.siteId, oldUserId)\n+                  val (_, _, sidAndXsrfCookies) =\n+                        createSessionIdAndXsrfToken(request, oldUserId)\n                   Ok.withCookies(sidAndXsrfCookies: _*)\n                 }\n           }"
        },
        {
          "filename": "appsv/server/controllers/InviteController.scala",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -254,7 +254,7 @@ class InviteController @Inject()(cc: ControllerComponents, edContext: EdContext)\n       secretKey, request.theBrowserIdData)\n \n     dao.pubSub.userIsActive(request.siteId, newUser.briefUser, request.theBrowserIdData)\n-    val (_, _, sidAndXsrfCookies) = createSessionIdAndXsrfToken(request.siteId, newUser.id)\n+    val (_, _, sidAndXsrfCookies) = createSessionIdAndXsrfToken(request, newUser.id)\n     val newSessionCookies = sidAndXsrfCookies\n \n     if (!alreadyAccepted) {"
        },
        {
          "filename": "appsv/server/controllers/LoginAsGuestController.scala",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -95,7 +95,7 @@ class LoginAsGuestController @Inject()(cc: ControllerComponents, edContext: EdCo\n       val guestUser = dao.loginAsGuest(loginAttempt)\n \n       val (sid, _, sidAndXsrfCookies) =\n-        security.createSessionIdAndXsrfToken(request.siteId, guestUser.id)\n+            security.createSessionIdAndXsrfToken(request, guestUser.id)\n \n       var responseJson = Json.obj(  // ts: AuthnResponse\n         \"userCreatedAndLoggedIn\" -> JsTrue,"
        },
        {
          "filename": "appsv/server/controllers/LoginController.scala",
          "status": "modified",
          "additions": 13,
          "deletions": 7,
          "patch": "@@ -36,7 +36,7 @@ class LoginController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   extends EdController(cc, edContext) {\n \n   import context.globals\n-  import context.security.DiscardingSessionCookie\n+  import context.security.DiscardingSessionCookies\n   import LoginController._\n \n \n@@ -122,20 +122,26 @@ class LoginController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   }\n \n \n-  /** Clears login related cookies and OpenID and OpenAuth stuff, unsubscribes\n-    * from any event channel.\n+  /** Clears session cookies and ends the session server side too; unsubscribes\n+    * from any websockets channel.\n     */\n   def logout(currentUrlPath: Opt[St]): Action[U] = GetActionAllowAnyone { request =>\n-    doLogout(request, redirectIfMayNotSeeUrlPath = currentUrlPath)\n+    SECURITY // optionally log out from all devices?\n+    doLogout(request, redirectIfMayNotSeeUrlPath = currentUrlPath,\n+          wasImpersonating = false)\n   }\n \n \n-  def doLogout(request: GetRequest, redirectIfMayNotSeeUrlPath: Opt[St]): Result = {\n+  def doLogout(request: GetRequest, redirectIfMayNotSeeUrlPath: Opt[St],\n+          wasImpersonating: Bo): Result = {\n     import request.{dao, requester, siteSettings}\n \n+    AUDIT_LOG // session id destruction\n+\n     requester foreach { theRequester =>\n-      request.dao.logout(theRequester, bumpLastSeen = true)\n+      request.dao.logout(theRequester, bumpLastSeen = !wasImpersonating)\n     }\n+    dao.terminateSessionForCurReq(request.underlying)\n \n     val goToNext: Opt[St] = siteSettings.effSsoLogoutAllRedirUrl orElse {\n       redirectIfMayNotSeeUrlPath flatMap { urlPath =>\n@@ -162,7 +168,7 @@ class LoginController @Inject()(cc: ControllerComponents, edContext: EdContext)\n       }\n \n     // Keep the xsrf cookie, so the login dialog will work.\n-    response.discardingCookies(DiscardingSessionCookie)\n+    response.discardingCookies(DiscardingSessionCookies: _*)\n   }\n \n "
        },
        {
          "filename": "appsv/server/controllers/LoginWithOpenAuthController.scala",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -182,6 +182,7 @@ class LoginWithOpenAuthController @Inject()(cc: ControllerComponents, edContext:\n   private val MayCreateUserCookieName = \"dwCoMayCreateUser\"\n   private val AuthStateCookieName = \"dwCoOAuth2State\"\n \n+  // Discard these also if logging in with username + password?  [clear_aun_cookies]\n   private val CookiesToDiscardAfterLogin: Seq[DiscardingCookie] = Seq(\n     ReturnToUrlCookieName,\n     ReturnToSiteOriginTokenCookieName,\n@@ -1592,6 +1593,7 @@ class LoginWithOpenAuthController @Inject()(cc: ControllerComponents, edContext:\n     // missing. But supporting page reload here requires fairly many mini fixes,\n     // and maybe is marginally worse for security? since then someone else,\n     // e.g. an \"evil\" tech support person, can ask for and reuse the url?\n+    // [.clearing_cookies] [clear_aun_cookies]\n     result.discardingCookies(CookiesToDiscardAfterLogin: _*)\n   }\n \n@@ -1605,7 +1607,7 @@ class LoginWithOpenAuthController @Inject()(cc: ControllerComponents, edContext:\n         authnState: OngoingAuthnState): Result = {\n \n     request.dao.pubSub.userIsActive(request.siteId, member, request.theBrowserIdData)\n-    val (sid, _, sidAndXsrfCookies) = createSessionIdAndXsrfToken(siteId, member.id)\n+    val (sid, _, sidAndXsrfCookies) = createSessionIdAndXsrfToken(request, member.id)\n \n     var maybeCannotUseCookies =\n       request.headers.get(EdSecurity.AvoidCookiesHeaderName) is EdSecurity.Avoid\n@@ -1948,6 +1950,8 @@ class LoginWithOpenAuthController @Inject()(cc: ControllerComponents, edContext:\n         anyContinueToUrl = Some(authnState.returnToUrl)))\n     }\n \n+    // This not needed? These cookies, and many more, already cleared at the\n+    // end of the caller, tryLoginOrShowCreateUserDialog()  [.clearing_cookies].\n     result.discardingCookies(\n       DiscardingSecureCookie(IsInLoginWindowCookieName),\n       DiscardingSecureCookie(ReturnToUrlCookieName))"
        },
        {
          "filename": "appsv/server/controllers/LoginWithPasswordController.scala",
          "status": "modified",
          "additions": 9,
          "deletions": 16,
          "patch": "@@ -125,7 +125,8 @@ class LoginWithPasswordController @Inject()(cc: ControllerComponents, edContext:\n     }\n \n     dao.pubSub.userIsActive(request.siteId, loginGrant.user, request.theBrowserIdData)\n-    val (sid, _, sidAndXsrfCookies) = createSessionIdAndXsrfToken(request.siteId, loginGrant.user.id)\n+    val (sid, _, sidAndXsrfCookies) =\n+          createSessionIdAndXsrfToken(request, loginGrant.user.id)\n     (sid, sidAndXsrfCookies)\n   }\n \n@@ -138,7 +139,7 @@ class LoginWithPasswordController @Inject()(cc: ControllerComponents, edContext:\n         allowAnyone = true) { request: JsonPostRequest =>\n \n     // A bit dupl code. [2FKD05]\n-    import request.body\n+    import request.{body, dao}\n \n     val fullName = (body \\ \"fullName\").asOptStringNoneIfBlank\n     val emailAddress = (body \\ \"email\").as[String].trim\n@@ -150,18 +151,6 @@ class LoginWithPasswordController @Inject()(cc: ControllerComponents, edContext:\n     val maybeCannotUseCookies =\n       request.headers.get(EdSecurity.AvoidCookiesHeaderName) is EdSecurity.Avoid\n \n-    CLEAN_UP // remove daoFor, use request.dao instead. Just look in the logs that this'll\n-    // work fine for sure (shouldn't be any \"TyEWEIRDDAO\" in the logs).\n-    val dao = daoFor(request.request)\n-    if (dao.siteId != request.dao.siteId) {\n-      if (globals.isProd) {\n-        logger.warn(\"Weird: dao.siteId != request.dao.siteId  [TyEWEIRDDAO]\")\n-      }\n-      else {\n-        die(\"TyE305AKTFWJ2\", \"Wrong dao, *harmmless* but why?\")\n-      }\n-    }\n-\n     val siteSettings = dao.getWholeSiteSettings()\n \n     val itsDisabled = \"Creation of local password accounts is disabled\"\n@@ -257,7 +246,8 @@ class LoginWithPasswordController @Inject()(cc: ControllerComponents, edContext:\n         else {\n           dieIf(newMember.email.isEmpty && requireVerifiedEmail, \"EdE2GKF06\")\n           dao.pubSub.userIsActive(request.siteId, newMember, request.theBrowserIdData)\n-          val (sid, _, sidAndXsrfCookies) = createSessionIdAndXsrfToken(dao.siteId, newMember.id)\n+          val (sid, _, sidAndXsrfCookies) =\n+                createSessionIdAndXsrfToken(request, newMember.id)\n           (Some(sid), sidAndXsrfCookies)\n         }\n       }\n@@ -290,6 +280,9 @@ class LoginWithPasswordController @Inject()(cc: ControllerComponents, edContext:\n         \"emailVerifiedAndLoggedIn\" -> JsBoolean(emailVerifiedAt.isDefined),\n         \"weakSessionId\" -> JsString(weakSessionId))\n \n+      COULD_OPTIMIZE // Clear login related cookies? [clear_aun_cookies]\n+      // Done already in the OAuth login controller; it clears these: CookiesToDiscardAfterLogin.\n+\n       OkSafeJson(responseJson).withCookies(loginCookies: _*)\n     }\n   }\n@@ -352,7 +345,7 @@ class LoginWithPasswordController @Inject()(cc: ControllerComponents, edContext:\n         (Nil, Some(returnToUrl + s\"#talkyardOneTimeLoginSecret=$loginSecret\"))\n       }\n       else {\n-        val (_, _, sidAndXsrfCookies) = createSessionIdAndXsrfToken(request.siteId, user.id)\n+        val (_, _, sidAndXsrfCookies) = createSessionIdAndXsrfToken(request, user.id)\n         val anyReturnToUrl: Option[String] =\n           if (returnToUrl.nonEmpty) Some(returnToUrl) else None\n         (sidAndXsrfCookies, anyReturnToUrl)"
        },
        {
          "filename": "appsv/server/controllers/ReplyController.scala",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -28,6 +28,7 @@ import javax.inject.Inject\n import play.api._\n import play.api.libs.json.{JsObject, JsString, JsValue, Json}\n import play.api.mvc._\n+import talkyard.server.authn.MinAuthnStrength\n \n \n /** Saves replies. Lazily creates pages for embedded discussions\n@@ -39,7 +40,8 @@ class ReplyController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   import context.security.{throwNoUnless, throwIndistinguishableNotFound}\n \n \n-  def handleReply: Action[JsValue] = PostJsonAction(RateLimits.PostReply, maxBytes = MaxPostSize) {\n+  def handleReply: Action[JsValue] = PostJsonAction(RateLimits.PostReply,\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = MaxPostSize) {\n         request: JsonPostRequest =>\n     import request.{body, dao, theRequester => requester}\n     val anyPageId = (body \\ \"pageId\").asOpt[PageId]\n@@ -70,6 +72,8 @@ class ReplyController @Inject()(cc: ControllerComponents, edContext: EdContext)\n     }\n     val categoriesRootLast = dao.getAncestorCategoriesRootLast(pageMeta.categoryId)\n \n+    CHECK_AUTHN_STRENGTH\n+\n     throwNoUnless(Authz.mayPostReply(\n       request.theUserAndLevels, dao.getOnesGroupIds(request.theUser),\n       postType, pageMeta, replyToPosts, dao.getAnyPrivateGroupTalkMembers(pageMeta),"
        },
        {
          "filename": "appsv/server/controllers/ResetPasswordController.scala",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -213,7 +213,7 @@ class ResetPasswordController @Inject()(cc: ControllerComponents, edContext: EdC\n \n     // Log the user in and show password changed message.\n     request.dao.pubSub.userIsActive(request.siteId, loginGrant.user, request.theBrowserIdData)\n-    val (_, _, sidAndXsrfCookies) = createSessionIdAndXsrfToken(request.siteId, loginGrant.user.id)\n+    val (_, _, sidAndXsrfCookies) = createSessionIdAndXsrfToken(request, loginGrant.user.id)\n     val newSessionCookies = sidAndXsrfCookies\n     CSP_MISSING\n     Ok(views.html.resetpassword.passwordHasBeenChanged(SiteTpi(request)))"
        },
        {
          "filename": "appsv/server/controllers/UserController.scala",
          "status": "modified",
          "additions": 48,
          "deletions": 19,
          "patch": "@@ -37,7 +37,7 @@ import javax.inject.Inject\n import org.scalactic.{Bad, Good}\n import talkyard.server.JsX\n import talkyard.server.JsX._\n-import talkyard.server.p_Result\n+import talkyard.server.authn.MinAuthnStrength\n import talkyard.server.TyLogging\n \n \n@@ -104,7 +104,8 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n \n   /** Loads a member or group, incl details, or a guest (then there are no details).\n     */\n-  def loadUserAnyDetails(who: String): Action[Unit] = GetAction { request =>\n+  def loadUserAnyDetails(who: St): Action[U] = GetActionRateLimited(\n+          RateLimits.ReadsFromDb, MinAuthnStrength.EmbeddingStorageSid12) { request =>\n     import request.{dao, requesterOrUnknown}\n     // First try looking up by `who` as a  numeric user id. If won't work,\n     // lookup by `who` as username instead.\n@@ -130,6 +131,9 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n \n     val tagTypes: Seq[TagType] = dao.getTagTypesForTags(tags)\n \n+    // Maybe incl less data if embedded?\n+    CHECK_AUTHN_STRENGTH\n+\n     // Maybe? No, stats is ok to show? Could possibly add another conf val, hmm.\n     /*val stats =\n       if (maySeeActivity(userId, request.requester, request.dao)) anyStatsJson\n@@ -369,7 +373,7 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n \n   def downloadPersonalData(userId: UserId): Action[Unit] = GetActionRateLimited(\n         RateLimits.DownloaPersonalData) { request: GetRequest =>\n-      import request.{dao, theRequester => requester}\n+    import request.{dao, theRequester => requester}\n     throwForbiddenIf(userId != requester.id && !requester.isAdmin,\n       \"TyE2PKAQX8\", \"Cannot download someone else's data\")\n \n@@ -395,6 +399,10 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n         tx.loadUserEmailAddresses(userId).filterNot(_.emailAddress == member.primaryEmailAddress)\n       val otherEmailsJson = JsArray(otherEmailAddresses.map(ea => JsString(ea.emailAddress)))\n \n+      // To do: Incl old expired sessions too? Or maybe that should be a separate\n+      // endpoint. [gdpr]\n+      val sessions = dao.listPatsSessions(userId)\n+\n       val identities: Seq[Identity] = tx.loadIdentities(userId)\n       val identitiesJson = JsArray(identities map {\n         case oauthId: OpenAuthIdentity =>\n@@ -442,7 +450,8 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n         \"trustLevel\" -> JsString(member.effectiveTrustLevel.toString),\n         \"identities\" -> identitiesJson,\n         \"statistics\" -> statsJson,\n-        \"browserIdDataRecentFirst\" -> browserIdDataJson)\n+        \"browserIdDataRecentFirst\" -> browserIdDataJson,\n+        \"sessions\" -> sessions.map(s => JsSession(s, inclPart1 = false)))\n     }\n \n     OkSafeJson(result)\n@@ -890,7 +899,11 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n \n   /** If not staff, returns a summary only.\n     */\n-  def loadAuthorBlocks(postId: Int): Action[Unit] = GetAction { request =>\n+  def loadAuthorBlocks(postId: Int): Action[Unit] = GetActionRateLimited(\n+        RateLimits.ReadsFromDb, MinAuthnStrength.EmbeddingStorageSid12) { request =>\n+\n+    CHECK_AUTHN_STRENGTH\n+\n     val blocks: Seq[Block] = request.dao.loadAuthorBlocks(postId)\n     var json = blocksSummaryJson(blocks, request.ctime)\n     if (request.user.exists(_.isStaff)) {\n@@ -954,7 +967,8 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   }\n \n \n-  def loadMyPageData(pageIds: St): Action[U] = GetAction { request =>\n+  def loadMyPageData(pageIds: St): Action[U] = GetAction2(RateLimits.ReadsFromDb,\n+        MinAuthnStrength.EmbeddingStorageSid12) { request =>\n     import request.dao\n     QUICK; COULD_OPTIMIZE // don't use String.split('') \u2014 it sometimes creates a regex.\n     // Review the whole code base. // Use Guava's Splitter instead.\n@@ -983,6 +997,8 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n       return dao.jsonMaker.userNoPageToJson(request)\n     }\n \n+    CHECK_AUTHN_STRENGTH\n+\n     val pagePath = request.dao.getPagePath(pageId) getOrElse {\n       // The page was apparently deleted some microseconds ago.\n       return dao.jsonMaker.userNoPageToJson(request)\n@@ -995,6 +1011,7 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n     val pageRequest = new PageRequest(\n       request.site,\n       sid = request.sid,\n+      anyTySession = request.anyTySession,\n       xsrfToken = request.xsrfToken,\n       browserId = request.browserId,\n       user = request.user,\n@@ -1024,7 +1041,7 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n \n \n   def trackReadingProgress: Action[JsValue] = PostJsonAction(RateLimits.TrackReadingActivity,\n-        maxBytes = 1000) { request =>\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 1000) { request =>\n     import request.{dao, theRequester}\n     val readMoreResult = trackReadingProgressImpl(request, request.body)\n     val result =\n@@ -1033,6 +1050,8 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n         // Posts related to some notifications were seen. Update the notifications, client side,\n         // so they'll get un-highlighted, since the posts they are about, have now been seen.\n \n+        CHECK_AUTHN_STRENGTH // Skip the notifications, if in embedded iframe?\n+\n         // dupl line [8AKBR0]\n         val notfsAndCounts = dao.loadNotificationsSkipReviewTasks(\n           theRequester.id, upToWhen = None, request.who, unseenFirst = true, limit = 20)\n@@ -1053,7 +1072,7 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   /** In the browser, navigator.sendBeacon insists on sending plain text. So need this text handler.\n     */\n   def trackReadingProgressText: Action[String] = PostTextAction(RateLimits.TrackReadingActivity,\n-        maxBytes = 1000) { request =>\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 1000) { request =>\n     val bodyXsrfTokenRemoved = request.body.dropWhile(_ != '\\n') // [7GKW20TD]\n     val json = Json.parse(bodyXsrfTokenRemoved)\n     trackReadingProgressImpl(request, json)\n@@ -1101,6 +1120,8 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n       throwForbidden(\"TyE5RKPW025\", s\"Bad post nr, smaller than BodyNr: $badNr\")\n     }\n \n+    CHECK_AUTHN_STRENGTH // + may see?\n+\n     logger.trace(\n       s\"s$siteId, page $anyPageId: Post nrs read: $postNrsRead, seconds reading: $secondsReading\")\n \n@@ -1188,24 +1209,24 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   }\n \n \n-  def markAllNotfsAsSeen(): Action[JsValue] = PostJsonAction(RateLimits.MarkNotfAsSeen, 200) {\n-        request =>\n+  def markAllNotfsAsSeen(): Action[JsValue] = PostJsonAction(RateLimits.MarkNotfAsSeen,\n+        maxBytes = 200) { request =>\n     request.dao.markAllNotfsAsSeen(request.theUserId)\n     loadNotificationsImpl(request.theUserId, upToWhen = None, request)\n   }\n \n \n-  def markNotificationAsSeen(): Action[JsValue] = PostJsonAction(RateLimits.MarkNotfAsSeen, 200) {\n-        request =>\n+  def markNotificationAsSeen(): Action[JsValue] = PostJsonAction(RateLimits.MarkNotfAsSeen,\n+        maxBytes = 200) { request =>\n     import request.{dao, theRequesterId}\n     val notfId = (request.body \\ \"notfId\").as[NotificationId]\n     dao.markNotificationAsSeen(theRequesterId, notfId)\n     Ok\n   }\n \n \n-  def snoozeNotifications(): Action[JsValue] =\n-          PostJsonAction(RateLimits.ConfigUser, 200) { request =>\n+  def snoozeNotifications(): Action[JsValue] = PostJsonAction(RateLimits.ConfigUser,\n+        maxBytes = 200) { request =>\n     import request.{dao, theRequesterId}\n     val untilWhen: Option[When] =\n           (request.body \\ \"untilMins\").as[JsValue] match {\n@@ -1219,8 +1240,8 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   }\n \n \n-  def saveContentNotfPref: Action[JsValue] = PostJsonAction(RateLimits.ConfigUser, maxBytes = 500) {\n-        request =>\n+  def saveContentNotfPref: Action[JsValue] = PostJsonAction(RateLimits.ConfigUser,\n+          MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 500) { request =>\n     import request.{dao, theRequester => requester}\n     val body = request.body\n     val memberId = (body \\ \"memberId\").as[MemberId]\n@@ -1280,6 +1301,8 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n                 notfLevel = newNotfLevel.getOrElse(NotfLevel.DoesNotMatterHere)))\n             .getOrIfFailure(ex => throwBadRequest(\"TyE2ABKRP0\", ex.getMessage))\n \n+    CHECK_AUTHN_STRENGTH\n+\n     if (newNotfLevel.isDefined) {\n       dao.savePageNotfPrefIfAuZ(newPref, request.who)\n     }\n@@ -1352,7 +1375,9 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n \n \n   SECURITY // don't allow if user listing disabled, & isn't staff [8FKU2A4]\n-  def listAllUsers(usernamePrefix: String): Action[Unit] = GetAction { request =>\n+  CHECK_AUTHN_STRENGTH // maybe sometimes not allowed from embedded comments pages?\n+  def listAllUsers(usernamePrefix: St): Action[U] = GetActionRateLimited(\n+          RateLimits.ReadsFromDb, MinAuthnStrength.EmbeddingStorageSid12) { request =>\n     // Authorization check: Is a member? Add MemberGetAction?\n     request.theMember\n \n@@ -1362,6 +1387,7 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n \n \n   SECURITY // user listing disabled? [8FKU2A4]\n+  CHECK_AUTHN_STRENGTH // maybe sometimes not allowed from embedded comments pages?\n   def listMembersPubApi(usernamePrefix: String, usersOnly: Boolean)\n         : Action[Unit] = GetAction { request =>\n     // Allowed also if not logged in \u2014 so can use from a non-Talkyard client,\n@@ -1399,7 +1425,8 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   /** Listing usernames on a particular page is okay, if one may see the page\n     * \u2014 however, listing all usernames for the whole site, isn't always okay. [8FKU2A4]\n     */\n-  def listUsernames(pageId: PageId, prefix: String): Action[Unit] = GetAction { request =>\n+  def listUsernames(pageId: PageId, prefix: St): Action[U] = GetActionRateLimited(\n+          RateLimits.ReadsFromDb, MinAuthnStrength.EmbeddingStorageSid12) { request =>\n     import request.dao\n \n     val pageMeta = dao.getPageMeta(pageId) getOrElse throwIndistinguishableNotFound(\"EdE4Z0B8P5\")\n@@ -1410,6 +1437,8 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n     // \u2014 someone who don't want strangers and new members to see hens profile \u2014\n     // then, would need to exclude those accounts here.\n \n+    CHECK_AUTHN_STRENGTH  // disallow if just sid part 1+2 but not embedded page\n+\n     throwNoUnless(Authz.maySeePage(\n       pageMeta, request.user, dao.getGroupIdsOwnFirst(request.user),\n       dao.getAnyPrivateGroupTalkMembers(pageMeta), categoriesRootLast,\n@@ -1584,7 +1613,7 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n     val anonNNN = dao.deleteUser(userId, request.who)\n     val response = OkSafeJsValue(JsString(anonNNN.username))\n     // Log the user out, if hen deleted hens own account.\n-    if (isOneself) response.discardingCookies(context.security.DiscardingSessionCookie)\n+    if (isOneself) response.discardingCookies(context.security.DiscardingSessionCookies: _*)\n     else response\n   }\n "
        },
        {
          "filename": "appsv/server/controllers/ViewPageController.scala",
          "status": "modified",
          "additions": 20,
          "deletions": 7,
          "patch": "@@ -29,10 +29,10 @@ import scala.concurrent.Future\n import ed.server.{EdContext, EdController, RenderedPage}\n import javax.inject.Inject\n import ViewPageController._\n-import debiki.dao.{UsersOnlineStuff, NoUsersOnlineStuff}\n+import debiki.dao.NoUsersOnlineStuff\n import ed.server.auth.MaySeeOrWhyNot\n-import ed.server.security.EdSecurity\n import talkyard.server.authn.LoginReason\n+import talkyard.server.authn.MinAuthnStrength\n import talkyard.server.JsX.JsObjOrNull\n \n \n@@ -53,6 +53,7 @@ class ViewPageController @Inject()(cc: ControllerComponents, edContext: EdContex\n \n \n \n+  CHECK_AUTHN_STRENGTH\n   def loadPost(pageId: PageId, postNr: PostNr): Action[Unit] = GetActionAllowAnyone { request =>\n     // Similar to getPageAsJsonImpl and getPageAsHtmlImpl, keep in sync. [7PKW0YZ2]\n \n@@ -69,6 +70,7 @@ class ViewPageController @Inject()(cc: ControllerComponents, edContext: EdContex\n         throwForbidden(\"EdE4F8WV0\", \"Account not approved\")\n     }\n \n+    // & sid leveL?\n     val (maySeeResult, debugCode) = dao.maySeePostUseCache(pageId, postNr, request.user)\n     maySeeResult match {\n       case MaySeeOrWhyNot.YesMaySee =>\n@@ -103,6 +105,7 @@ class ViewPageController @Inject()(cc: ControllerComponents, edContext: EdContex\n     * Good for analytics and understanding what the users do at the site?\n     * The SPA stuff is just an optimization.\n     */\n+  CHECK_AUTHN_STRENGTH\n   def viewPage(path: String): Action[Unit] = AsyncGetActionAllowAnyone { request =>\n     if (request.queryString.get(\"json\").isDefined) {\n       getPageAsJson(path, request)\n@@ -185,6 +188,7 @@ class ViewPageController @Inject()(cc: ControllerComponents, edContext: EdContex\n \n     val pageRequest = new PageRequest[Unit](\n       request.site,\n+      request.anyTySession,\n       sid = request.sid,\n       xsrfToken = request.xsrfToken,\n       browserId = request.browserId,\n@@ -242,8 +246,9 @@ class ViewPageController @Inject()(cc: ControllerComponents, edContext: EdContex\n   }\n \n \n-  def markPageAsSeen(pageId: PageId): Action[JsValue] = PostJsonAction(NoRateLimits, maxBytes = 2) {\n-        request =>\n+  def markPageAsSeen(pageId: PageId): Action[JsValue] = PostJsonAction(NoRateLimits,\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 2) { request =>\n+    CHECK_AUTHN_STRENGTH\n     val watchbar = request.dao.getOrCreateWatchbar(request.theUserId)\n     val newWatchbar = watchbar.markPageAsSeen(pageId)\n     request.dao.saveWatchbar(request.theUserId, newWatchbar)\n@@ -303,9 +308,15 @@ class ViewPageController @Inject()(cc: ControllerComponents, edContext: EdContex\n                 die(\"DwE7KEWK2\", \"Both not approved and approved\")\n             }\n         }\n-        var forbidden = ForbiddenResult(s\"TyM0APPR_-$code\", message)\n-        if (logout) forbidden = forbidden.discardingCookies(security.DiscardingSessionCookie)\n-        return Future.successful(forbidden)\n+        var forbiddenResp = ForbiddenResult(s\"TyM0APPR_-$code\", message)\n+        if (logout) {\n+          COULD_OPTIMIZE // do these two in the same tx:\n+          dao.logout(request.theReqer, bumpLastSeen = true)\n+          dao.terminateSessionForCurReq(request.underlying)\n+\n+          forbiddenResp = forbiddenResp.discardingCookies(security.DiscardingSessionCookies: _*)\n+        }\n+        return Future.successful(forbiddenResp)\n       }\n     }\n \n@@ -350,6 +361,7 @@ class ViewPageController @Inject()(cc: ControllerComponents, edContext: EdContex\n \n     val pageRequest = new PageRequest[Unit](\n       request.site,\n+      request.anyTySession,\n       sid = request.sid,\n       xsrfToken = request.xsrfToken,\n       browserId = request.browserId,\n@@ -544,6 +556,7 @@ object ViewPageController {\n \n     new DummyPageRequest(\n       request.site,\n+      request.anyTySession,\n       sid = request.sid,\n       xsrfToken = request.xsrfToken,\n       browserId = request.browserId,"
        },
        {
          "filename": "appsv/server/controllers/VoteController.scala",
          "status": "modified",
          "additions": 11,
          "deletions": 3,
          "patch": "@@ -29,6 +29,8 @@ import javax.inject.Inject\n import play.api.libs.json._\n import play.api.mvc.{Action, ControllerComponents}\n import talkyard.server.JsX.{JsUser, JsStringOrNull}\n+import talkyard.server.authn.MinAuthnStrength\n+\n \n \n /** Handles votes, e.g. \"I like this comment\" or \"this comment is faulty\" votes.\n@@ -46,8 +48,9 @@ class VoteController @Inject()(cc: ControllerComponents, edContext: EdContext)\n     *   action: \"CreateVote\"  # or \"DeleteVote\"\n     *   postIdsRead: [1, 9, 53, 82]\n     */\n-  def handleVotes: Action[JsValue] = PostJsonAction(RateLimits.RatePost, maxBytes = 500) {\n-        request: JsonPostRequest =>\n+  def handleVotes: Action[JsValue] = PostJsonAction(RateLimits.RatePost,\n+          MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 500) {\n+          request: JsonPostRequest =>\n     import request.{body, dao, theRequester => requester}\n     val anyPageId = (body \\ \"pageId\").asOpt[PageId]\n \n@@ -100,6 +103,8 @@ class VoteController @Inject()(cc: ControllerComponents, edContext: EdContext)\n           anyEmbeddingUrl = anyEmbeddingUrl, lazyCreatePageInCatId = lazyCreatePageInCatId,\n           request)\n \n+    CHECK_AUTHN_STRENGTH\n+\n     if (delete) {\n       dao.deleteVoteIfAuZ(pageId, postNr, voteType, voterId = request.theUser.id)\n     }\n@@ -124,12 +129,15 @@ class VoteController @Inject()(cc: ControllerComponents, edContext: EdContext)\n   }\n \n \n-  def loadVoters(postId: PostId, voteType: Int): Action[Unit] = GetAction { request =>\n+  def loadVoters(postId: PostId, voteType: Int): Action[U] = GetActionRateLimited(\n+          RateLimits.ReadsFromDb, MinAuthnStrength.EmbeddingStorageSid12) { request =>\n     import request.{dao, requester}\n \n     val pageMeta: PageMeta = dao.getThePageMetaForPostId(postId)\n     val categoriesRootLast = dao.getAncestorCategoriesRootLast(pageMeta.categoryId)\n \n+    CHECK_AUTHN_STRENGTH\n+\n     throwNoUnless(Authz.maySeePage(\n       pageMeta, requester,\n       dao.getGroupIdsOwnFirst(requester),"
        },
        {
          "filename": "appsv/server/debiki/JsonUtils.scala",
          "status": "modified",
          "additions": 50,
          "deletions": 12,
          "patch": "@@ -74,18 +74,47 @@ object JsonUtils {   MOVE // to talkyard.server.parser.JsonParSer\n     }\n   }\n \n+  def parseJson(jsonSt: St): JsValue = {\n+    // Play uses JacksonJson.parseJsValue, see: play.api.libs.json.\n+    // which throws: IOException, JsonParseException, JsonMappingException,\n+    // and the latter are subclasses of IOException.\n+    try Json.parse(jsonSt)\n+    catch {\n+      case ex: java.io.IOException =>\n+        throwBadJson(\"TyEPARSJSN\", s\"Cannot parse text as json: ${ex.getMessage}\")\n+    }\n+  }\n+\n   def asJsObject(json: JsValue, what: St): JsObject =\n     json match {\n       case o: JsObject => o\n-      case _ => throwBadJson(\"TyE0JSOBJ\", s\"$what is not a JsObject\")\n+      case x => throwBadJson(\"TyE0JSOBJ\", s\"$what is not a JsObject, it is a: ${classNameOf(x)}\")\n     }\n \n   def asJsArray(json: JsValue, what: St): Seq[JsValue] =\n     json match {\n       case a: JsArray => a.value\n-      case _ => throwBadJson(\"TyE0JSARR\", s\"$what is not a JsArray\")\n+      case x => throwBadJson(\"TyE0JSARR\", s\"$what is not a JsArray, it is a: ${classNameOf(x)}\")\n     }\n \n+  def asInt64(json: JsValue, what: St): i64 =\n+    json match {\n+      case n: JsNumber =>\n+        try n.value.toLongExact\n+        catch {\n+          case _: java.lang.ArithmeticException =>\n+            throwBadJson(\"TyE0JSINT64\", s\"$what does not fit in a 64 bit integer\")\n+        }\n+      case x =>\n+        throwBadJson(\"TyE0JSNUM\", s\"$what is not a JsNumber, it is a: ${classNameOf(x)}\")\n+    }\n+\n+  def asInt32(json: JsValue, what: St, min: Opt[i32] = None,\n+          max: Opt[i32] = None): i32 = {\n+    val int64 = asInt64(json, what)\n+    int64To32ThrowIfOutOfRange(int64, what, min = min, max = max)\n+  }\n+\n   def parseJsObject(json: JsValue, fieldName: St): JsObject =\n     readJsObject(json, fieldName)\n \n@@ -122,9 +151,9 @@ object JsonUtils {   MOVE // to talkyard.server.parser.JsonParSer\n     }\n   }\n \n-  def parseOptJsArray(jv: JsValue, fieldName: St): Opt[JsArray] =\n+  def parseOptJsArray(jv: JsValue, fieldName: St): Opt[IndexedSeq[JsValue]] =\n     (jv \\ fieldName).toOption map {\n-      case a: JsArray => a\n+      case a: JsArray => a.value\n       case JsNull => return None\n       case bad =>\n         throwBadJson(\n@@ -355,19 +384,28 @@ object JsonUtils {   MOVE // to talkyard.server.parser.JsonParSer\n \n   def readOptInt(json: JsValue, fieldName: String, altName: String = \"\",\n           min: Opt[i32] = None, max: Opt[i32] = None): Option[Int] = {\n-    readOptLong(json, fieldName).orElse(readOptLong(json, altName)) map { valueAsLong =>\n-      val maxVal = max getOrElse Int.MaxValue\n-      val minVal = min getOrElse Int.MinValue\n-      if (valueAsLong > maxVal)\n-        throwBadJson(\"TyEJSNGTMX\", s\"$fieldName too large: $valueAsLong, max is: $maxVal\")\n-      if (valueAsLong < minVal)\n-        throwBadJson(\"TyEJSNLTMN\", s\"$fieldName too small: $valueAsLong, min is: $minVal\")\n-      valueAsLong.toInt\n+    val firstFieldValue = readOptLong(json, fieldName)\n+    firstFieldValue.orElse(readOptLong(json, altName)) map { valueAsLong =>\n+      val usedName = if (firstFieldValue.isDefined) fieldName else altName\n+      int64To32ThrowIfOutOfRange(valueAsLong, usedName, min = min, max = max)\n     }\n   }\n \n+  private def int64To32ThrowIfOutOfRange(valueAsLong: i64, name: St, min: Opt[i32] = None,\n+        max: Opt[i32] = None): i32 = {\n+    val maxVal = max getOrElse Int.MaxValue\n+    val minVal = min getOrElse Int.MinValue\n+    if (valueAsLong > maxVal)\n+      throwBadJson(\"TyEJSNGTMX\", s\"$name too large: $valueAsLong, max is: $maxVal\")\n+    if (valueAsLong < minVal)\n+      throwBadJson(\"TyEJSNLTMN\", s\"$name too small: $valueAsLong, min is: $minVal\")\n+    valueAsLong.toInt\n+  }\n \n   def readLong(json: JsValue, fieldName: String): Long =\n+    parseInt64(json, fieldName)\n+\n+  def parseInt64(json: JsValue, fieldName: St): i64 =\n     readOptLong(json, fieldName) getOrElse throwMissing(\"EsE6Y8FW2\", fieldName)\n \n   def parseOptLong(json: JsValue, fieldName: St): Opt[i64] ="
        },
        {
          "filename": "appsv/server/debiki/ReactJson.scala",
          "status": "modified",
          "additions": 13,
          "deletions": 3,
          "patch": "@@ -24,6 +24,7 @@ import debiki.dao._\n import ed.server.auth.ForumAuthzContext\n import ed.server.auth.Authz\n import ed.server.http._\n+import ed.server.security.{SidStatus, SidOk}\n import java.{lang => jl, util => ju}\n import org.jsoup.Jsoup\n import org.jsoup.nodes.{Element => jsoup_Element}\n@@ -793,7 +794,7 @@ class JsonMaker(dao: SiteDao) {\n     val site = if (requester.isStaffOrCoreMember) dao.getSite else None\n \n     dao.readOnlyTransaction { tx =>\n-      requestersJsonImpl(requester, pageRequest.pageId, watchbarWithTitles,\n+      requestersJsonImpl(pageRequest.sid, requester, pageRequest.pageId, watchbarWithTitles,\n             restrTopicsCatsLinks, permissions, permsOnSiteTooMany,\n             unapprovedPostAuthorIds, myGroupsEveryoneLast, site, tx)\n     }\n@@ -816,15 +817,16 @@ class JsonMaker(dao: SiteDao) {\n     val site = if (requester.isStaffOrCoreMember) dao.getSite else None\n \n     dao.readOnlyTransaction { tx =>\n-      requestersJsonImpl(requester, anyPageId = None, watchbarWithTitles,\n+      requestersJsonImpl(request.sid, requester, anyPageId = None, watchbarWithTitles,\n             RestrTopicsCatsLinks(JsArray(), Nil, Nil, Nil, Set.empty),\n             permissions, permsOnSiteTooMany,\n             unapprovedPostAuthorIds = Set.empty, myGroupsEveryoneLast, site, tx)\n     }\n   }\n \n \n-  private def requestersJsonImpl(requester: Participant, anyPageId: Option[PageId],\n+  private def requestersJsonImpl(\n+        sid: SidStatus, requester: Participant, anyPageId: Option[PageId],\n         watchbar: WatchbarWithTitles, restrTopicsCatsLinks: RestrTopicsCatsLinks,\n         permissions: Seq[PermsOnPages], permsOnSiteTooMany: PermsOnSite,\n         unapprovedPostAuthorIds: Set[UserId],\n@@ -938,9 +940,17 @@ class JsonMaker(dao: SiteDao) {\n             \"marksByPostId\" -> JsObject(Nil)))\n     }\n \n+    // Parts 2 and other parts are all long enough themselves,  so we can include\n+    // part 1 in generated html pages. [sid_part1]\n+    val sidPart1: JsValue = sid match {\n+      case s: SidOk => JsString(s.part1CompId)\n+      case _ => JsNull\n+    }\n+\n     // Somewhat dupl code, (2WB4G7) and [B28JG4].\n     var json = Json.obj(\n       \"dbgSrc\" -> \"4JKW7A0\",\n+      \"mySidPart1\" -> sidPart1,\n       \"id\" -> JsNumber(requester.id),\n       \"userId\" -> JsNumber(requester.id), // try to remove, use 'id' instead\n       \"username\" -> JsStringOrNull(requester.anyUsername),"
        },
        {
          "filename": "appsv/server/debiki/dao/SiteDao.scala",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -126,6 +126,7 @@ class SiteDao(\n   with SpecialContentDao\n   with ed.server.auth.AuthzSiteDaoMixin\n   with talkyard.server.authn.AuthnSiteDaoMixin\n+  with talkyard.server.sess.SessionSiteDaoMixin\n   with ForumDao\n   with CategoriesDao\n   with PagesDao\n@@ -315,6 +316,9 @@ class SiteDao(\n     dbDao2.readOnlySiteTransaction(siteId, mustBeSerializable = true) { fn(_) }\n \n   def readOnlyTransactionTryReuse[R](anyTx: Option[SiteTransaction])(fn: SiteTransaction => R): R =\n+    readTxTryReuse(anyTx)(fn)\n+\n+  def readTxTryReuse[R](anyTx: Opt[SiteTx])(fn: SiteTx => R): R =\n     anyTx match {\n       case Some(tx) => fn(tx)\n       case None => readOnlyTransaction(fn)"
        },
        {
          "filename": "appsv/server/debiki/dao/SystemDao.scala",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -702,6 +702,12 @@ class SystemDao(\n \n   // ----- The janitor actor\n \n+  def deletePersonalDataFromOldSessions(): U = {\n+    writeTxLockAllSites { tx =>\n+      tx.deletePersonalDataFromOldSessions()\n+    }\n+  }\n+\n   def deletePersonalDataFromOldAuditLogEntries(): U = {\n     writeTxLockAllSites { tx =>\n       tx.deletePersonalDataFromOldAuditLogEntries()"
        },
        {
          "filename": "appsv/server/debiki/dao/UserDao.scala",
          "status": "modified",
          "additions": 25,
          "deletions": 8,
          "patch": "@@ -364,7 +364,7 @@ trait UserDao {\n     val cappedDays = math.min(numDays, 365 * 110)\n     val now = globals.now()\n \n-    val user = readWriteTransaction { tx =>\n+    writeTx { (tx, staleStuff) =>\n       var user = tx.loadTheUserInclDetails(userId)\n       if (user.isAdmin)\n         throwForbidden(\"DwE4KEF24\", \"Cannot suspend admins\")\n@@ -375,11 +375,14 @@ trait UserDao {\n         suspendedTill = Some(suspendedTill),\n         suspendedById = Some(suspendedById),\n         suspendedReason = Some(reason.trim))\n+\n       tx.updateUserInclDetails(user)\n-      user\n-    }\n+      staleStuff.addPatIds(Set(userId))\n \n-    logout(user.noDetails, bumpLastSeen = false)\n+      logout(user.noDetails, bumpLastSeen = false, anyTx = Some(tx, staleStuff))\n+      terminateSessions(  // [end_sess]\n+            forPatId = user.id, all = true, anyTx = Some(tx, staleStuff))\n+    }\n   }\n \n \n@@ -758,12 +761,19 @@ trait UserDao {\n   }\n \n \n-  def logout(pat: Pat, bumpLastSeen: Bo): U = {\n-    readWriteTransaction { tx =>\n+  def logout(pat: Pat, bumpLastSeen: Bo, anyTx: Opt[(SiteTx, StaleStuff)] = None): U = {\n+    if (bumpLastSeen) writeTxTryReuse(anyTx) { (tx, staleStuff) =>\n       addUserStats(UserStats(pat.id, lastSeenAt = tx.now))(tx)\n+      staleStuff.addPatIds(Set(pat.id))\n     }\n+\n+    UX; COULD // Maybe a WebSocket channel should remember which session & browser it\n+    // got started from? Rather than only what user. So can disconnect the right browser,\n+    // instead of all the user's browsers. For example, if impersonating,\n+    // then, this'll disconnect all current channels of the real person,\n+    // and mark hen as away (maybe incorrectly).\n+    // [which_ws_session]\n     pubSub.unsubscribeUser(siteId, pat)\n-    removeUserFromMemCache(pat.id)\n   }\n \n \n@@ -2190,7 +2200,7 @@ trait UserDao {\n     * - EdT5WKBWQ2\n     */\n   def deleteUser(userId: UserId, byWho: Who): UserInclDetails = {\n-    val (user, usersGroupIds) = readWriteTransaction { tx =>\n+    val (user, usersGroupIds) = writeTx { (tx, staleStuff) =>\n       tx.deferConstraints()\n \n       val deleter = tx.loadTheParticipant(byWho.id)\n@@ -2284,6 +2294,9 @@ trait UserDao {\n       tx.removeDeletedMemberFromAllPages(userId)\n       tx.removeDeletedMemberFromAllGroups(userId)\n \n+      // logout(..) done below.  [end_sess]\n+      terminateSessions(forPatId = userId, all = true, anyTx = Some(tx, staleStuff))\n+\n       // Clear the page cache, by clearing all caches.\n       emptyCacheImpl(tx)  ; SHOULD_OPTIMIZE // use staleStuff.addPagesWithVisiblePostsBy() instead\n \n@@ -2296,7 +2309,11 @@ trait UserDao {\n     // (this not needed, since cleared the site cache just above. Do anyway.)\n     uncacheOnesGroupIds(Seq(userId))\n     uncacheGroupsMemberLists(usersGroupIds)\n+\n+    // Or just call:  logout(user, bumpLastSeen = false)\n+    pubSub.unsubscribeUser(siteId, user.briefUser)\n     removeUserFromMemCache(userId)\n+    // terminateSessions() done above.\n \n     user\n   }"
        },
        {
          "filename": "appsv/server/ed/server/EdAppLoader.scala",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -106,6 +106,7 @@ class EdAppComponents(appLoaderContext: ApplicationLoader.Context)\n     new _root_.controllers.SpecialContentController(cc, context),\n     new _root_.controllers.ModerationController(cc, context),\n     new _root_.controllers.UserController(cc, context),\n+    new talkyard.server.sess.SessionController(cc, context),\n     new _root_.controllers.UnsubscriptionController(cc, context),\n     new ed.server.summaryemails.UnsubFromSummariesController(cc, context),\n     new _root_.controllers.InviteController(cc, context),"
        },
        {
          "filename": "appsv/server/ed/server/EdController.scala",
          "status": "modified",
          "additions": 39,
          "deletions": 21,
          "patch": "@@ -11,6 +11,7 @@ import play.api.libs.json.JsValue\n import play.api.mvc._\n import play.{api => p}\n import scala.concurrent.{ExecutionContext, Future}\n+import talkyard.server.authn.MinAuthnStrength\n \n \n \n@@ -30,34 +31,51 @@ class EdController(cc: ControllerComponents, val context: EdContext)\n     PlainApiAction(cc.parsers.empty, NoRateLimits, avoidCookies = avoidCookies).async(f)\n \n   def AsyncGetActionAllowAnyone(f: GetRequest => Future[Result]): mvc.Action[Unit] =\n-    PlainApiAction(cc.parsers.empty, NoRateLimits, allowAnyone = true).async(f)\n+    PlainApiAction(cc.parsers.empty, NoRateLimits, MinAuthnStrength.EmbeddingStorageSid12,\n+          allowAnyone = true).async(f)\n \n   def AsyncGetActionIsLogin(f: GetRequest => Future[Result]): mvc.Action[Unit] =\n     PlainApiAction(cc.parsers.empty, NoRateLimits, isLogin = true).async(f)\n \n   def AsyncGetActionIsLoginRateLimited(f: GetRequest => Future[Result]): mvc.Action[Unit] =\n     PlainApiAction(cc.parsers.empty, RateLimits.Login, isLogin = true).async(f)\n \n-  def AsyncGetActionRateLimited(rateLimits: RateLimits)(f: GetRequest => Future[Result])\n+  def AsyncGetActionRateLimited(rateLimits: RateLimits,\n+        minAuthnStrength: MinAuthnStrength = MinAuthnStrength.Normal,\n+        )(f: GetRequest => Future[Result])\n         : mvc.Action[Unit] =\n-    PlainApiAction(cc.parsers.empty, rateLimits).async(f)\n+    PlainApiAction(cc.parsers.empty, rateLimits, minAuthnStrength).async(f)\n \n+  @deprecated(\"Use GetActionRateLimited instead, remove this, and rename it to this\", \"\")\n   def GetAction(f: GetRequest => Result): Action[Unit] =\n     PlainApiAction(cc.parsers.empty, NoRateLimits)(f)\n \n+  def GetAction2(  // use GetActionRateLimited instead!\n+        rateLimits: RateLimits,\n+        minAuthnStrength: MinAuthnStrength = MinAuthnStrength.Normal,\n+        )(f: GetRequest => Result): Action[Unit] =\n+    PlainApiAction(cc.parsers.empty, rateLimits, minAuthnStrength)(f)\n+\n+  SECURITY; COULD // let MinAuthnStrength be a param, so it's more explicitly visible\n+  // in the endpoint fn declaration, here and everywhere \u2014 don't let EmbeddedHalfSidOld\n+  // be the default anywhere?\n   def GetActionAllowAnyone(f: GetRequest => Result): Action[Unit] =\n-    PlainApiAction(cc.parsers.empty, NoRateLimits, allowAnyone = true)(f)\n+    PlainApiAction(cc.parsers.empty, NoRateLimits, MinAuthnStrength.EmbeddingStorageSid12,\n+          allowAnyone = true)(f)\n \n   def GetActionAllowAnyoneRateLimited(rateLimits: RateLimits, avoidCookies: Boolean = false)\n         (f: GetRequest => Result): Action[Unit] =\n-    PlainApiAction(cc.parsers.empty, rateLimits, allowAnyone = true, avoidCookies = avoidCookies)(f)\n+    PlainApiAction(cc.parsers.empty, rateLimits, MinAuthnStrength.EmbeddingStorageSid12,\n+          allowAnyone = true, avoidCookies = avoidCookies)(f)\n \n   def GetActionIsLogin(f: GetRequest => Result): Action[Unit] =\n     PlainApiAction(cc.parsers.empty, NoRateLimits, isLogin = true)(f)\n \n-  def GetActionRateLimited(rateLimits: RateLimits = RateLimits.ExpensiveGetRequest,\n+  def GetActionRateLimited(\n+        rateLimits: RateLimits = RateLimits.ExpensiveGetRequest,\n+        minAuthnStrength: MinAuthnStrength = MinAuthnStrength.Normal,\n         allowAnyone: Boolean = false)(f: GetRequest => Result): Action[Unit] =\n-    PlainApiAction(cc.parsers.empty, rateLimits, allowAnyone = allowAnyone)(f)\n+    PlainApiAction(cc.parsers.empty, rateLimits, minAuthnStrength, allowAnyone = allowAnyone)(f)\n \n   def StaffGetAction(f: GetRequest => Result): Action[Unit] =\n     PlainApiActionStaffOnly(cc.parsers.empty)(f)\n@@ -91,11 +109,13 @@ class EdController(cc: ControllerComponents, val context: EdContext)\n     PlainApiAction(cc.parsers.json(maxLength = maxBytes),\n       rateLimits, allowAnyone = allowAnyone, avoidCookies = avoidCookies).async(f)\n \n-  def PostJsonAction(rateLimits: RateLimits, maxBytes: Int,\n+  def PostJsonAction(rateLimits: RateLimits,\n+        minAuthnStrength: MinAuthnStrength = MinAuthnStrength.Normal,\n+        maxBytes: Int,\n         allowAnyone: Boolean = false, isLogin: Boolean = false)(\n         f: JsonPostRequest => Result): Action[JsValue] =\n     PlainApiAction(cc.parsers.json(maxLength = maxBytes),\n-      rateLimits, allowAnyone = allowAnyone, isLogin = isLogin)(f)\n+        rateLimits, minAuthnStrength, allowAnyone = allowAnyone, isLogin = isLogin)(f)\n \n   def AsyncUserPostJsonAction(rateLimits: RateLimits, maxBytes: i32,\n         avoidCookies: Bo = false)(\n@@ -108,15 +128,19 @@ class EdController(cc: ControllerComponents, val context: EdContext)\n     PlainApiAction(cc.parsers.json(maxLength = maxBytes),\n       rateLimits, authnUsersOnly = true)(f)\n \n-  def PostTextAction(rateLimits: RateLimits, maxBytes: Int, allowAnyone: Boolean = false)(\n+  def PostTextAction(rateLimits: RateLimits,\n+        minAuthnStrength: MinAuthnStrength = MinAuthnStrength.Normal,\n+        maxBytes: Int, allowAnyone: Boolean = false)(\n         f: ApiRequest[String] => Result): Action[String] =\n     PlainApiAction(cc.parsers.text(maxLength = maxBytes),\n-      rateLimits, allowAnyone = allowAnyone)(f)\n+      rateLimits, minAuthnStrength, allowAnyone = allowAnyone)(f)\n \n   SECURITY // add rate limits for staff too\n-  def StaffPostJsonAction(maxBytes: Int)(f: JsonPostRequest => Result): Action[JsValue] =\n+  def StaffPostJsonAction(\n+        minAuthnStrength: MinAuthnStrength = MinAuthnStrength.Normal,\n+        maxBytes: Int)(f: JsonPostRequest => Result): Action[JsValue] =\n     PlainApiActionStaffOnly(\n-      cc.parsers.json(maxLength = maxBytes))(f)\n+      cc.parsers.json(maxLength = maxBytes), minAuthnStrength)(f)\n \n   SECURITY // add rate limits for admins \u2014 use AdminPostJsonAction2, then remove this & rm '2' from name.\n   def AdminPostJsonAction(maxBytes: Int)(f: JsonPostRequest => Result): Action[JsValue] =\n@@ -156,17 +180,11 @@ class EdController(cc: ControllerComponents, val context: EdContext)\n   // ----- Site id lookup\n \n \n-  def originOf(request: DebikiRequest[_]) =\n+  def originOf(request: DebikiRequest[_]): St =\n     globals.originOf(request.underlying)\n \n-  def originOf(request: RequestHeader) =\n+  def originOf(request: RequestHeader): St =\n     globals.originOf(request)\n \n \n-  def daoFor(request: Request[_]) = {\n-    val site = globals.lookupSiteOrThrow(originOf(request))\n-    globals.siteDao(site.id)\n-  }\n-\n-\n }"
        },
        {
          "filename": "appsv/server/ed/server/auth/AuthzSiteDaoMixin.scala",
          "status": "modified",
          "additions": 5,
          "deletions": 2,
          "patch": "@@ -215,9 +215,12 @@ trait AuthzSiteDaoMixin {\n \n \n   /** Returns true/false, + iff false, a why-forbidden debug reason code.\n+    *\n+    * Also needs any authn strength? Maybe: WhoInfo = ReqerInfo = Opt[(Pat, Opt[AuthnStrength])]?\n+    * Maybe Opt[(Pat, AuthnStrength)] where AuthnStrength can be [InternalJob], instead of None?\n     */\n-  def maySeePostUseCache(pageId: PageId, postNr: PostNr, user: Option[Participant])\n-        : (MaySeeOrWhyNot, String) = {\n+  def maySeePostUseCache(pageId: PageId, postNr: PostNr, user: Opt[Pat])\n+        : (MaySeeOrWhyNot, St) = {\n     maySeePostImpl(pageId, postNr, user, anyPost = None, anyTx = None)\n   }\n "
        },
        {
          "filename": "appsv/server/ed/server/http/DebikiRequest.scala",
          "status": "modified",
          "additions": 5,
          "deletions": 2,
          "patch": "@@ -51,6 +51,10 @@ abstract class AuthnReqHeader extends SomethingToRateLimit {\n   private def globals = dao.context.globals\n \n   def site: SiteBrief\n+\n+  def anyTySession: Opt[TySession]\n+  def tySession: TySession = anyTySession getOrElse throwForbidden(\"TyE0SESS\", \"Not logged in\")\n+\n   def sid: SidStatus\n   def xsrfToken: XsrfOk\n   def browserId: Option[BrowserId]\n@@ -79,7 +83,7 @@ abstract class AuthnReqHeader extends SomethingToRateLimit {\n   }\n \n   def isViaApiSecret: Boolean = sid match { // should be case obj AuthnMethod.ApiSecret instead? [5BKRH02]\n-    case SidOk(\"_api_secret_\", 0, _) => true\n+    case SidOk(TySession.ApiSecretPart12, 0, _) => true\n     case _ => false\n   }\n \n@@ -165,7 +169,6 @@ abstract class AuthnReqHeader extends SomethingToRateLimit {\n   def isGuest: Boolean = user.exists(_.isGuest)\n   def isStaff: Boolean = user.exists(_.isStaff)\n \n-  def session: mvc.Session = request.session\n \n   def ip: IpAddress = security.realOrFakeIpOf(request)\n "
        },
        {
          "filename": "appsv/server/ed/server/http/PageRequest.scala",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -37,6 +37,7 @@ import play.api.mvc.Request\n   */\n class PageRequest[A](\n   val site: SiteBrief,\n+  val anyTySession: Opt[TySession],\n   val sid: SidStatus,\n   val xsrfToken: XsrfOk,\n   val browserId: Option[BrowserId],\n@@ -140,6 +141,7 @@ class PageRequest[A](\n   */\n class DummyPageRequest[A](\n   siteIdAndCanonicalHostname: SiteBrief,\n+  anyTySession: Opt[TySession],\n   sid: SidStatus,\n   xsrfToken: XsrfOk,\n   browserId: Option[BrowserId],\n@@ -149,7 +151,7 @@ class DummyPageRequest[A](\n   pageMeta: PageMeta,\n   dao: SiteDao,\n   request: Request[A]) extends PageRequest[A](\n-    siteIdAndCanonicalHostname, sid, xsrfToken, browserId, user, pageExists,\n+    siteIdAndCanonicalHostname, anyTySession, sid, xsrfToken, browserId, user, pageExists,\n     pagePath, Some(pageMeta), altPageId = None, embeddingUrl = None,\n     dao = dao, request = request) {\n "
        },
        {
          "filename": "appsv/server/ed/server/http/PlainApiActions.scala",
          "status": "modified",
          "additions": 114,
          "deletions": 40,
          "patch": "@@ -34,9 +34,10 @@ import scala.collection.mutable\n import play.api.http.{HeaderNames => p_HNs}\n import play.api.mvc.{Results => p_Results}\n import talkyard.server.TyLogging\n+import talkyard.server.authn.MinAuthnStrength\n \n \n-/** Play Framework Actions for requests to Debiki's HTTP API.\n+/** Play Framework Actions for requests to Talkyard's HTTP API.\n   */\n class PlainApiActions(\n   val safeActions: SafeActions,\n@@ -46,29 +47,37 @@ class PlainApiActions(\n \n   import EdHttp._\n   import security.DiscardingSecureCookie\n-  import security.DiscardingSessionCookie\n+  import security.DiscardingSessionCookies\n   import safeActions.ExceptionAction\n \n-  def PlainApiAction[B](parser: BodyParser[B],\n-        rateLimits: RateLimits, allowAnyone: Bo = false, isLogin: Bo = false,\n+  def PlainApiAction[B](\n+        parser: BodyParser[B],\n+        rateLimits: RateLimits,\n+        minAuthnStrength: MinAuthnStrength = MinAuthnStrength.Normal,\n+        allowAnyone: Bo = false,\n+        isLogin: Bo = false,\n         authnUsersOnly: Bo = false,\n-        avoidCookies: Bo = false, skipXsrfCheck: Bo = false)\n-        : ActionBuilder[ApiRequest, B] =\n-    PlainApiActionImpl(parser, rateLimits,\n+        avoidCookies: Bo = false,\n+        skipXsrfCheck: Bo = false,\n+        ): ActionBuilder[ApiRequest, B] =\n+    PlainApiActionImpl(parser, rateLimits, minAuthnStrength = minAuthnStrength,\n         authnUsersOnly = authnUsersOnly,\n         allowAnyone = allowAnyone, isLogin = isLogin, avoidCookies = avoidCookies,\n         skipXsrfCheck = skipXsrfCheck)\n \n-  def PlainApiActionStaffOnly[B](parser: BodyParser[B]): ActionBuilder[ApiRequest, B] =\n-    PlainApiActionImpl(parser, NoRateLimits, staffOnly = true)\n+  def PlainApiActionStaffOnly[B](\n+          parser: BodyParser[B],\n+          minAuthnStrength: MinAuthnStrength = MinAuthnStrength.Normal,\n+          ): ActionBuilder[ApiRequest, B] =\n+    PlainApiActionImpl(parser, NoRateLimits, minAuthnStrength, staffOnly = true)\n \n   def PlainApiActionAdminOnly[B](rateLimits: RateLimits, parser: BodyParser[B])\n         : ActionBuilder[ApiRequest, B] =\n     PlainApiActionImpl(parser, rateLimits, adminOnly = true)\n \n   def PlainApiActionApiSecretOnly[B](rateLimits: RateLimits, parser: BodyParser[B])\n         : ActionBuilder[ApiRequest, B] =\n-    PlainApiActionImpl(parser, rateLimits, viaApiSecretOnly = true)\n+    PlainApiActionImpl(parser, rateLimits, MinAuthnStrength.ApiSecret, viaApiSecretOnly = true)\n \n   def PlainApiActionSuperAdminOnly[B](parser: BodyParser[B])\n         : ActionBuilder[ApiRequest, B] =\n@@ -87,6 +96,7 @@ class PlainApiActions(\n     */\n   def PlainApiActionImpl[B](aParser: BodyParser[B],\n         rateLimits: RateLimits,\n+        minAuthnStrength: MinAuthnStrength = MinAuthnStrength.Normal,\n         adminOnly: Boolean = false,\n         staffOnly: Boolean = false,\n         authnUsersOnly: Bo = false,\n@@ -277,7 +287,8 @@ class PlainApiActions(\n \n         val sysbot = dao.getTheUser(SysbotUserId)\n         return runBlockIfAuthOk(request, site, dao, Some(sysbot),\n-              SidOk(\"_api_secret_\", 0, Some(SysbotUserId)),\n+              Some(TySession.singleApiCallSession(asPatId = SysbotUserId)),\n+              SidOk(TySession.ApiSecretPart12, 0, Some(SysbotUserId)),\n               XsrfOk(\"_email_webhook_\"), None, block)\n       }\n \n@@ -327,8 +338,11 @@ class PlainApiActions(\n       // if isn't sysbot.\n \n       runBlockIfAuthOk(request, site, dao, Some(user),\n+          Some(TySession.singleApiCallSession(asPatId = user.id)),\n           // SECURITY minor: Less error prone with a Bool field instead of this magic string.\n-          SidOk(\"_api_secret_\", 0, Some(user.id)), XsrfOk(\"_api_secret_\"), None, block)\n+          // ... getting fixed, see TySession just above, [btr_sid].\n+          SidOk(TySession.ApiSecretPart12, 0, Some(user.id)),\n+          XsrfOk(TySession.ApiSecretPart12), None, block)\n     }\n \n \n@@ -338,11 +352,11 @@ class PlainApiActions(\n           block: ApiRequest[A] => Future[Result]): Future[Result] = {\n \n       // Why avoid cookies? In an embedded comments iframe, cookies frequently get blocked\n-      // by Privacy Badger or iOS or browser settings for 3rd-party-cookies.\n+      // by iOS ITP or FF ETP or browser settings for 3rd-party-cookies.\n       // The embedded comments show-page etc endpoints sets avoidCookies,\n       // so we know, here, that we should avoid setting any cookies.  [NOCOOKIES]\n       // And, for subsequent requests \u2014 to *other* endpoints \u2014 the browser Javascript code sets\n-      // the AvoidCookiesHeaderName header, so we won't froget that we should avoid cookies here.\n+      // the AvoidCookiesHeaderName header, so we won't forget that we should avoid cookies here.\n       val hasCookiesAlready = request.cookies.exists(_.name != \"esCoE2eTestPassword\")\n       val maySetCookies = hasCookiesAlready || {   // TODO\n         val shallAvoid = avoidCookies || {\n@@ -358,7 +372,9 @@ class PlainApiActions(\n \n       val expireIdleAfterMins = siteSettings.expireIdleAfterMins\n \n-      val (actualSidStatus, xsrfOk, newCookies) = corsInfo match {\n+      val CheckSidAndXsrfResult(\n+              anyTySession, actualSidStatus, xsrfOk, newCookies, delFancySidCookies) =\n+            corsInfo match {\n         case ci: CorsInfo.OkayCrossOrigin =>\n           // Cross-origin requests with credentials (i.e. session id cookie)\n           // not yet tested and thought thrown.\n@@ -370,17 +386,19 @@ class PlainApiActions(\n           // cross-origin requests.\n           // Currently only publicly accessible data can be seen, since proceeding\n           // with no session id.\n-          (SidAbsent, XsrfOk(\"cors_no_xsrf\"), Nil)\n+          CheckSidAndXsrfResult(\n+                None, SidAbsent, XsrfOk(\"cors_no_xsrf\"), Nil, Nil)\n \n-        case _: CorsInfo.SameOrigins | CorsInfo.NotCorsNoOriginHeader =>\n+        case ci =>\n+          dieIf(ci.isCrossOrigin, \"TyEJ2503TKHJ\")\n           security.checkSidAndXsrfToken(\n-                request, anyRequestBody = Some(request.body), siteId = site.id,\n+                request, anyRequestBody = Some(request.body), site, dao,\n                 expireIdleAfterMins, maySetCookies = maySetCookies,\n                 skipXsrfCheck = skipXsrfCheck)\n       }\n \n       // Ignore and delete any broken or expired session id cookie.\n-      val (mendedSidStatus, deleteSidCookie) =\n+      val (mendedSidStatus, deleteAllSidCookies) =\n         if (actualSidStatus.canUse) (actualSidStatus, false)\n         else (SidAbsent, true)\n \n@@ -411,33 +429,40 @@ class PlainApiActions(\n                 }\n \n           runBlockIfAuthOk(request, site, dao, anyUserMaybeSuspended,\n-                mendedSidStatus, xsrfOk, anyBrowserId, block)\n+                anyTySession, mendedSidStatus, xsrfOk, anyBrowserId, block)\n         }\n         catch {\n+          // CLEAN_UP have getUserBySessionId() return an error instead of throwing\n           case _: LoginNotFoundException =>\n             // This might happen if I manually deleted stuff from the\n             // database during development, or if the server has fallbacked\n             // to a standby database.\n+            // (Does it make sense to delete any related session from sessions_t?)\n             throw ResultException(InternalErrorResult2(i\"\"\"\n               |Internal error, please try again. For example, reload the page. [DwE034ZQ3]\n               |\n               |Details: A certain login id has become invalid. I just gave you a new id,\n               |but you will probably need to login again.\"\"\")\n-              .discardingCookies(DiscardingSessionCookie))\n+              .discardingCookies(DiscardingSessionCookies: _*))\n         }\n \n       val resultOkSid =\n-        if (newCookies.isEmpty && newBrowserIdCookie.isEmpty && !deleteSidCookie) {\n+        if (newCookies.isEmpty && newBrowserIdCookie.isEmpty && !deleteAllSidCookies\n+              && delFancySidCookies.isEmpty) {\n           resultOldCookies\n         }\n         else {\n           resultOldCookies.map({ result =>\n             var resultWithCookies = result\n-              .withCookies(newCookies ::: newBrowserIdCookie: _*)\n-              .withHeaders(safeActions.MakeInternetExplorerSaveIframeCookiesHeader)\n-            if (deleteSidCookie) {\n+                  .withCookies(newCookies ::: newBrowserIdCookie: _*)\n+                  .withHeaders(safeActions.MakeInternetExplorerSaveIframeCookiesHeader)\n+            if (deleteAllSidCookies) {\n+              resultWithCookies =\n+                    resultWithCookies.discardingCookies(DiscardingSessionCookies: _*)\n+            }\n+            else if (delFancySidCookies.nonEmpty) {\n               resultWithCookies =\n-                resultWithCookies.discardingCookies(DiscardingSessionCookie)\n+                    resultWithCookies.discardingCookies(delFancySidCookies: _*)\n             }\n             resultWithCookies\n           })(executionContext)\n@@ -448,27 +473,37 @@ class PlainApiActions(\n \n \n     private def runBlockIfAuthOk[A](request: Request[A], site: SiteBrief, dao: SiteDao,\n-          anyUserMaybeSuspended: Option[Participant], sidStatus: SidStatus,\n+          anyUserMaybeSuspended: Option[Participant],\n+          anyTySession: Opt[TySession], sidStatus: SidStatus,\n           xsrfOk: XsrfOk, browserId: Option[BrowserId], block: ApiRequest[A] => Future[Result])\n           : Future[Result] = {\n \n       // Maybe the user was logged in in two different browsers, and deleted hens account\n-      // in one browser and got logged out there, only.\n-      if (anyUserMaybeSuspended.exists(_.isDeleted))\n+      // in one browser and got logged out, when this request was going on already?\n+      if (anyUserMaybeSuspended.exists(_.isDeleted)) {\n+        // A race. Any session already deleted by UserDao [end_sess],\n+        dieIf(dao.listPatsSessions(anyUserMaybeSuspended.get.id).nonEmpty, \"TyESTILLSID01\")\n         return Future.successful(\n-          ForbiddenResult(\"TyEUSRDLD\", \"That account has been deleted\")\n-            .discardingCookies(DiscardingSessionCookie))\n+              ForbiddenResult(\"TyEUSRDLD\", \"That account has been deleted\")\n+                  .discardingCookies(DiscardingSessionCookies: _*))\n+      }\n \n       val isSuspended = anyUserMaybeSuspended.exists(_.isSuspendedAt(new ju.Date))\n \n-      if (isSuspended && request.method != \"GET\")\n+      if (isSuspended && request.method != \"GET\") {\n+        // A race. Any session already deleted by UserDao [end_sess],\n+        dieIf(dao.listPatsSessions(anyUserMaybeSuspended.get.id).nonEmpty, \"TyESTILLSID02\")\n         return Future.successful(\n-            ForbiddenResult(\"TyESUSPENDED_\", \"Your account has been suspended\")\n-              .discardingCookies(DiscardingSessionCookie))\n+              ForbiddenResult(\"TyESUSPENDED_\", \"Your account has been suspended\")\n+                  .discardingCookies(DiscardingSessionCookies: _*))\n+      }\n \n       val anyUser =\n-        if (isSuspended) None\n-        else anyUserMaybeSuspended\n+            if (!isSuspended) anyUserMaybeSuspended\n+            else {\n+              // If suspended, one can still see publicly visible things.\n+              None\n+            }\n \n       // Re the !superAdminOnly test: Do allow access for superadmin endpoints,\n       // so they can reactivate this site, in case this site is the superadmin site itself.\n@@ -494,6 +529,43 @@ class PlainApiActions(\n       if (adminOnly && !anyUser.exists(_.isAdmin) && !isLogin)\n         throwLoginAsAdmin(request)\n \n+      // Some staffOnly endpoints are okay with an embedded session \u2014 namely\n+      // if moderating embedded comments [mod_emb_coms_sid]. But admin endpoints always\n+      // need the full session id (not just parts 1+2+3, but also part 4 HttpOnly).\n+      dieIf((adminOnly || superAdminOnly) && !minAuthnStrength.fullSidRequired, \"TyE502MGE6M1\")\n+\n+      if (anyTySession.exists(_.isApiCall)) {\n+        // Fine, we've checked an API secret, no session parts needed.\n+        assert(anyTySession.get.part1CompId == TySession.ApiSecretPart1, \"TyE502MEG5\")\n+      }\n+      else if (anyTySession.forall(_.part4Present)) {\n+        // Then either 1) the user isn't logged in; there is no session \u2014 that's fine;\n+        // we'll do authZ checks later; some endpoints (e.g. for logging in) are accessible\n+        // also if not logged in.\n+        // Or 2) the user is logged in, and this request does include the HttpOnly\n+        // session part \u2014 all fine.\n+      }\n+      else if (minAuthnStrength.fullSidRequired || staffOnly || adminOnly || superAdminOnly) {\n+        // Part 4 HttpOnly is required, but is missing.  Dupl code [btr_sid_part_4]\n+        assert(anyTySession.isDefined, \"TyE04MWG245\")\n+        assert(anyTySession.get.part4Absent, \"TyE04MWG246\")\n+        val tryFancySid = site.isFeatureEnabled(\"ffTryNewSid\", globals.config.featureFlags)\n+        val onlyFancySid = site.isFeatureEnabled(\"ffUseNewSid\", globals.config.featureFlags)\n+        val doUseFancySid = onlyFancySid || tryFancySid\n+        if (doUseFancySid) {\n+          throwForbidden(\"TyEWEAKSID_\",\n+                s\"Please log out and log in, to get a complete session id \u2014 \\n\" +\n+                s\"this endpoint, ${request.path}, requires the HttpOnly part of the session id\")\n+        }\n+      }\n+      else {\n+        // Part 4 of the session is missing, and the current endpoint doesn't need part 4\n+        // (such endpoints are for embedded discussions \u2014 then, cookies don't work (they\n+        // generally don't work in iframes), so we're getting only session parts 1+2(+3) via\n+        // javascript and custom HTTP headers).\n+        dieUnless(anyTySession.exists(_.part4Absent), \"TyE70MWEG25SM\")\n+      }\n+\n       if (superAdminOnly) {\n         globals.config.superAdmin.siteIdString match {\n           case Some(siteId) if site.id.toString == siteId =>\n@@ -590,7 +662,7 @@ class PlainApiActions(\n       }\n \n       val apiRequest = ApiRequest[A](\n-        site, sidStatus, xsrfOk, browserId, anyUser, dao, request)\n+        site, anyTySession, sidStatus, xsrfOk, browserId, anyUser, dao, request)\n \n       rateLimiter.rateLimit(rateLimits, apiRequest)\n \n@@ -646,9 +718,11 @@ class PlainApiActions(\n       })(executionContext)\n \n       if (isSuspended) {\n-        // BUG: (old? can still happen?) We won't get here if e.g. a 403 Forbidden exception\n-        // was thrown because 'anyUser' was set to None. How solve that?\n-        result = result.map(_.discardingCookies(DiscardingSessionCookie))(executionContext)\n+        // Harmless \"problem\": This code won't run, if we started handling the request,\n+        // but then an exception got thrown (e.g. a 404 Access Denied ResultException,\n+        // see above).  Then, the cookies won't get deleted \u2014 which doesn't really matter,\n+        // since they're unusable; session deleted server side already.  [btr_sid]\n+        result = result.map(_.discardingCookies(DiscardingSessionCookies: _*))(executionContext)\n       }\n       result\n     }"
        },
        {
          "filename": "appsv/server/ed/server/http/package.scala",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -32,21 +32,23 @@ package object http {\n \n   case class AuthnReqHeaderImpl(\n     site: SiteBrief,\n+    anyTySession: Opt[TySession],\n     sid: SidStatus,\n     xsrfToken: XsrfOk,\n-    browserId: Option[BrowserId],\n-    user: Option[Participant],\n+    browserId: Opt[BrowserId],\n+    user: Opt[Pat],\n     dao: SiteDao,\n     request: RequestHeader) extends AuthnReqHeader {\n   }\n \n \n   case class ApiRequest[A](   // RENAME to AuthnReqImpl\n     site: SiteBrief,\n+    anyTySession: Opt[TySession],\n     sid: SidStatus,\n     xsrfToken: XsrfOk,\n-    browserId: Option[BrowserId],\n-    user: Option[Participant],\n+    browserId: Opt[BrowserId],\n+    user: Opt[Pat],\n     dao: SiteDao,\n     request: Request[A]) extends DebikiRequest[A] {\n   }"
        },
        {
          "filename": "appsv/server/ed/server/jobs/Janitor.scala",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -112,6 +112,7 @@ class JanitorActor(val globals: Globals) extends Actor {\n \n   private def findAndDeleteOldStuff(): Unit = {\n     val dao = globals.systemDao\n+    dao.deletePersonalDataFromOldSessions()\n     dao.deletePersonalDataFromOldAuditLogEntries()\n     dao.deletePersonalDataFromOldSpamCheckTasks()\n     dao.deleteOldUnusedUploads()"
        },
        {
          "filename": "appsv/server/ed/server/pubsub/SubscriberController.scala",
          "status": "modified",
          "additions": 28,
          "deletions": 11,
          "patch": "@@ -25,11 +25,12 @@ import debiki._\n import talkyard.server.JsX\n import ed.server.{EdContext, EdController}\n import ed.server.http._\n+import ed.server.security.CheckSidAndXsrfResult\n import javax.inject.Inject\n import org.scalactic.{Bad, Good, Or}\n import play.{api => p}\n import p.libs.json.{JsValue, Json}\n-import p.mvc.{Action, ControllerComponents, RequestHeader, Result}\n+import p.mvc.{Action, ControllerComponents, RequestHeader => play_RequestHeader, Result}\n import scala.concurrent.Future\n import talkyard.server.TyLogging\n import talkyard.server.RichResult\n@@ -46,14 +47,14 @@ class SubscriberController @Inject()(cc: ControllerComponents, tyCtx: EdContext)\n \n \n   def webSocket: p.mvc.WebSocket = p.mvc.WebSocket.acceptOrResult[JsValue, JsValue] {\n-        request: RequestHeader =>\n+        request: play_RequestHeader =>\n     webSocketImpl(request)\n       // map { if  Left[Result = Problem ... log to admin problem log ?  }\n       // [ADMERRLOG]\n   }\n \n \n-  private def webSocketImpl(request: RequestHeader): Future[Either[\n+  private def webSocketImpl(request: play_RequestHeader): Future[Either[\n         // Either an error response, if we reject the connection.\n         Result,\n         // Or an In and Out stream, for talking with the client.\n@@ -111,7 +112,7 @@ class SubscriberController @Inject()(cc: ControllerComponents, tyCtx: EdContext)\n \n \n \n-  private def authenticateWebSocket(site: SiteBrief, request: RequestHeader)\n+  private def authenticateWebSocket(site: SiteBrief, request: play_RequestHeader)\n         : AuthnReqHeaderImpl Or Result = {\n     import tyCtx.security\n \n@@ -138,12 +139,14 @@ class SubscriberController @Inject()(cc: ControllerComponents, tyCtx: EdContext)\n     // We check the xsrf token later \u2014 since a WebSocket upgrade request\n     // cannot have a request body or custom header with xsrf token.\n     // (checkSidAndXsrfToken() won't throw for GET requests. [GETNOTHROW])\n-    val (sessionId, xsrfOk, newCookies) =\n+    val CheckSidAndXsrfResult(anyTySession, sessionId, xsrfOk, newCookies, delFancySidCookies) =\n           security.checkSidAndXsrfToken(\n-                request, anyRequestBody = None, siteId = site.id,\n+                request, anyRequestBody = None, site, dao,\n                 expireIdleAfterMins = expireIdleAfterMins, maySetCookies = false,\n                 skipXsrfCheck = false)\n \n+    COULD // delete any delFancySidCookies.\n+\n     // Needs to have a cookie already. [WSXSRF]\n     dieIf(newCookies.nonEmpty, \"TyE503RKDJL2\")\n     throwForbiddenIf(xsrfOk.value.isEmpty, \"TyEWS0XSRFCO\", \"No xsrf cookie\")\n@@ -155,7 +158,22 @@ class SubscriberController @Inject()(cc: ControllerComponents, tyCtx: EdContext)\n     if (sessionId.userId.isEmpty)\n       return Bad(ForbiddenResult(\"TyEWS0SID\", \"No session id\"))\n \n-    // For now, let's require a browser id cookie \u2014\u00a0then, *in some cases* simpler\n+    // For now, let's require part 4 HttpOnly to use WebSocket. And some time later\n+    // maybe reconsider, and e.g. allow live updates of embedded comments.\n+    if (anyTySession.exists(_.part4Absent)) {\n+      // Dupl code [btr_sid_part_4]\n+      val tryFancySid = site.isFeatureEnabled(\"ffTryNewSid\", globals.config.featureFlags)\n+      val onlyFancySid = site.isFeatureEnabled(\"ffUseNewSid\", globals.config.featureFlags)\n+      val doUseFancySid = onlyFancySid || tryFancySid\n+      if (doUseFancySid) {\n+        UNTESTED\n+        throwForbidden(\"TyEWEAKSIDWS\",\n+              s\"Please log out and log in, to get a complete session id \u2014 \\n\" +\n+              s\"WebSockets, ${request.path}, requires the HttpOnly part of the session id\")\n+      }\n+    }\n+\n+    // For now, let's require a browser id cookie \u2014 then, *in some cases* simpler\n     // to detect WebSocket abuse or attacks? (Also see: [GETLOGIN] \u2014 an id cookie\n     // needs to be set also via GET requests, if they're for logging in.)\n     val anyBrowserId = security.getAnyBrowserId(request)\n@@ -180,17 +198,16 @@ class SubscriberController @Inject()(cc: ControllerComponents, tyCtx: EdContext)\n \n     if (requesterMaybeSuspended.isDeleted)\n       return Bad(ForbiddenResult(\"TyEWSUSRDLD\", \"User account deleted\")\n-          .discardingCookies(security.DiscardingSessionCookie))\n-          // + discard browser id co too   *edit:* Why?\n+          .discardingCookies(security.DiscardingSessionCookies: _*))\n \n     val isSuspended = requesterMaybeSuspended.isSuspendedAt(new java.util.Date)\n     if (isSuspended)\n       return Bad(ForbiddenResult(\"TyEWSSUSPENDED\", \"Your account has been suspended\")\n-          .discardingCookies(security.DiscardingSessionCookie))\n+          .discardingCookies(security.DiscardingSessionCookies: _*))\n \n     val requester = requesterMaybeSuspended\n \n-    val authnReq = AuthnReqHeaderImpl(site, sessionId, xsrfOk,\n+    val authnReq = AuthnReqHeaderImpl(site, anyTySession, sessionId, xsrfOk,\n           anyBrowserId, Some(requester), dao, request)\n \n     Good(authnReq)"
        },
        {
          "filename": "appsv/server/ed/server/security/package.scala",
          "status": "modified",
          "additions": 514,
          "deletions": 81,
          "patch": "@@ -1,5 +1,5 @@\n /**\n- * Copyright (C) 2011-2017 Kaj Magnus Lindberg\n+ * Copyright (c) 2011-2017, 2021 Kaj Magnus Lindberg\n  *\n  * This program is free software: you can redistribute it and/or modify\n  * it under the terms of the GNU Affero General Public License as\n@@ -18,7 +18,6 @@\n package ed.server.security\n \n import com.debiki.core._\n-import com.debiki.core.isDevOrTest\n import com.debiki.core.Prelude._\n import debiki.{EdHttp, EffectiveSettings, Globals}\n import ed.server.http.{DebikiRequest, JsonOrFormDataBody}\n@@ -27,8 +26,11 @@ import scala.util.Try\n import EdSecurity._\n import ed.server.auth.MayMaybe\n import play.api.http.{HeaderNames => p_HNs}\n+import play.api.libs.json.{JsObject, JsString, JsValue}\n import talkyard.server.TyLogger\n-\n+import talkyard.server.sess.SessionSiteDaoMixin\n+import talkyard.server.http\n+import ed.server.http.AuthnReqHeader\n \n \n sealed abstract class XsrfStatus { def isOk = false }\n@@ -44,6 +46,28 @@ case class XsrfOk(value: String) extends XsrfStatus {\n }\n \n \n+private case class CheckSidResult(\n+  anyTySession: Opt[TySession],\n+  sidStatus: SidStatus,\n+  createCookies: List[Cookie] = Nil,\n+  discardCookies: List[DiscardingCookie] = Nil)\n+\n+\n+private object CheckSidResult {\n+  def noSession(\n+        sidStatus: SidStatus,\n+        // discardAllSessionCookies: Bo = false,\n+        discardCookies: List[DiscardingCookie] = Nil): CheckSidResult = {\n+    dieIf(sidStatus.canUse && sidStatus != SidAbsent, \"TyE2MFKJ063I\")\n+    //dieIf(discardAllSessionCookies && discardCookies.nonEmpty, \"TyE2MFKJ0632\")\n+    CheckSidResult(\n+          anyTySession = None, sidStatus, discardCookies = discardCookies)\n+          /* Cannot access here:\n+              if (discardAllSessionCookies) EdSecurity.DiscardingSessionCookies.toList\n+              else discardCookies) */\n+  }\n+}\n+\n \n // RENAME to AuthnMethod,\n // and AuthnMethod.ApiSecret [5BKRH02], SidOk \u2013> SessionId, None, BadSessionIdFormat, BadSessionIdHash?\n@@ -59,15 +83,32 @@ case object SidAbsent extends SidStatus {\n \n case object SidBadFormat extends SidStatus\n case object SidBadHash extends SidStatus\n-case class SidExpired(minutesOld: Long, maxAgeMins: Long) extends SidStatus\n+case class SidExpired(\n+  minutesOld: i64,\n+  maxAgeMins: i64,\n+  wasForPatId: Opt[PatId]) extends SidStatus\n+\n+case class SidDeleted(\n+  value: St,\n+  wasForPatId: Opt[PatId]) extends SidStatus {\n+}\n \n \n \n+// CLEAN_UP REFACTOR REMOVE this class? Use only TySession instead.\n case class SidOk(\n+  // If fancy sid, is part 1 + 2 = 16 + 24 = 40 chars.\n   value: String,\n   ageInMillis: Long,\n   override val userId: Option[UserId]) extends SidStatus {\n \n+  // We should never include session id part 3 \u2014 so check that the length is just part 1 + 2\n+  // or that there's a '.' \u2014 then it's an old silly sid.\n+  dieIf(value.length != TySession.SidLengthCharsPart12 && !value.contains('.'),\n+        \"TyEBADSID12LEN\", s\"Bad session id parts 1 + 2: '$value'\")\n+\n+  def part1CompId: St = value take TySession.SidLengthCharsPart1\n+\n   override def canUse = true\n }\n \n@@ -81,6 +122,13 @@ case class SidOk(\n case class BrowserId(cookieValue: String, isNew: Boolean)\n \n \n+case class CheckSidAndXsrfResult(\n+  anyTySession: Opt[TySession],\n+  sidStatus: SidStatus,\n+  xsrfStatus: XsrfOk,\n+  cookiesToAdd: List[Cookie],\n+  cookiesToDelete: List[DiscardingCookie])\n+\n \n object EdSecurity {\n \n@@ -114,6 +162,11 @@ object EdSecurity {\n     */\n   val SessionIdCookieName = \"dwCoSid\"\n \n+  // See TySession [cookie_theory].\n+  val SessionIdPart123CookieName = \"TyCoSid123\"\n+  val SessionIdPart4HttpOnlyCookieName = \"TyCoSid4\"\n+  val SessionIdPart5StrictCookieName = \"TyCoSid5\"\n+\n   /** Don't rename. Is used by AngularJS: AngularJS copies the value of\n     * this cookie to the HTTP header just above.\n     * See: http://docs.angularjs.org/api/ng.$http, search for \"XSRF-TOKEN\".\n@@ -341,22 +394,59 @@ class EdSecurity(globals: Globals) {\n    * but not here (the WebSocket upgrade request has no body, no custom headers).\n    */\n   def checkSidAndXsrfToken[A](request: RequestHeader, anyRequestBody: Option[A],\n-        siteId: SiteId, expireIdleAfterMins: i64, maySetCookies: Bo, skipXsrfCheck: Bo)\n-        : (SidStatus, XsrfOk, List[Cookie]) = {\n+        site: SiteBrief, dao: SessionSiteDaoMixin,\n+        expireIdleAfterMins: i64, maySetCookies: Bo, skipXsrfCheck: Bo)\n+        : CheckSidAndXsrfResult = {\n+\n+\n+    // ----- Check session id\n \n     val expireIdleAfterMillis: Long = expireIdleAfterMins * MillisPerMinute\n \n     // If we cannot use cookies, then the sid is sent in a header. [NOCOOKIES]\n-    val anySessionIdCookieValue: Opt[St] = urlDecodeCookie(SessionIdCookieName, request)\n-    val anySessionId: Opt[St] =\n-          anySessionIdCookieValue orElse request.headers.get(SessionIdHeaderName)\n+    val anySillySidInCookie: Opt[St] = urlDecodeCookie(SessionIdCookieName, request)\n+    val anySidHeaderValue: Opt[St] = request.headers.get(SessionIdHeaderName)\n+    val (anySillySidInHeader, anyFancySidPart12Maybe3InHeader) = anySidHeaderValue match {\n+      case None => (None, None)\n+      case Some(value) =>\n+        if (value.contains('.')) {\n+          // It's the old silly sid.\n+          (Some(value), None)\n+        }\n+        else {\n+          // It's the new fancy sid (Base64, no '.'), not the old silly sid.\n+          (None, Some(value))\n+        }\n+    }\n+\n+    val anySillySid = anySillySidInCookie orElse anySillySidInHeader\n+\n+    // New better sid:  [btr_sid]\n+    val anyFancySidPart123CookieVal = urlDecodeCookie(SessionIdPart123CookieName, request)\n+    val anyFancySidPart12Maybe3: Opt[St] =\n+                            anyFancySidPart123CookieVal orElse anyFancySidPart12Maybe3InHeader\n+    val anyFancySidPart4: Opt[St] = urlDecodeCookie(SessionIdPart4HttpOnlyCookieName, request)\n+    val anyFancySidPart5: Opt[St] = urlDecodeCookie(SessionIdPart5StrictCookieName, request)\n \n     val now = globals.now()\n \n-    val sessionIdStatus: SidStatus =\n-          anySessionId.map(\n-            checkSessionId(siteId, _, now, expireIdleAfterMillis = expireIdleAfterMillis)\n-            ) getOrElse SidAbsent\n+    val checkSidResult: CheckSidResult =\n+          checkSessionId(\n+                site,\n+                anySillySid = anySillySid,\n+                anyFancySidPart12Maybe3 = anyFancySidPart12Maybe3,\n+                anyFancySidPart4 = anyFancySidPart4,\n+                anyFancySidPart5 = anyFancySidPart5,\n+                dao,\n+                now,\n+                expireIdleAfterMillis = expireIdleAfterMillis)\n+\n+    val sessionIdStatus = checkSidResult.sidStatus\n+    val upgrToFancySidCookies = checkSidResult.createCookies\n+    val deleteFancySidCookies = checkSidResult.discardCookies  // rename? deleteFancySidCookies\n+\n+\n+    // ----- Check xsrf token\n \n     // On GET requests, simply accept the value of the xsrf cookie.\n     // (On POST requests, however, we check the xsrf form input value)\n@@ -365,12 +455,12 @@ class EdSecurity(globals: Globals) {\n     val isGet = request.method == \"GET\"\n     val isPost = request.method == \"POST\"\n     val cookies = request.cookies // nice to see in debugger\n-    val maybeCredentials = cookies.nonEmpty ||\n-          // There's also the session id header, SessionIdHeaderName\n-          // (for embedded discussions, cookies then usually won't work).\n-          sessionIdStatus != SidAbsent\n+    val maybeCredentials = cookies.nonEmpty || anySidHeaderValue.isDefined\n+    val definitelyNoCreds = !maybeCredentials\n+    dieIf(definitelyNoCreds && sessionIdStatus != SidAbsent,\n+          \"TyE50RMEG24\", s\"No creds, still, session id != SidAbsent: $sessionIdStatus\")\n \n-    val sidXsrfNewCookies: (SidStatus, XsrfOk, List[Cookie]) =\n+    val (xsrf, newCookies): (XsrfOk, List[Cookie]) = {\n       if (isGet || skipXsrfCheck) {\n         // Accept this request, and create new XSRF token if needed.\n         // Don't throw anything (for now at least). [GETNOTHROW]\n@@ -396,8 +486,7 @@ class EdSecurity(globals: Globals) {\n             val cookie = urlEncodeCookie(XsrfCookieName, newXsrfOk.value)\n             (newXsrfOk, List(cookie))\n           }\n-\n-        (sessionIdStatus, xsrfOk, anyNewXsrfCookie)\n+        (xsrfOk, anyNewXsrfCookie)\n       }\n       else if (!isPost) {\n         // Sometimes people do `curl -I http://...` which sends a HEAD\n@@ -411,12 +500,13 @@ class EdSecurity(globals: Globals) {\n               \"TyE_REQUEST_METHOD__HEAD__NOT_ALLOWED\", details)\n         throwForbidden( \"TyE_REQUEST_METHOD_NOT_ALLOWED\", details)\n       }\n-      else if (isPost && !maybeCredentials) {\n+      else if (isPost && definitelyNoCreds) {\n         // This might be from a backend server, fetching publicly available data.\n         // Example: An Electron or iOS app, calling /-/v0/search, to show\n         // in-app help.\n         // No credentials are included in the request, so there's no xsrf risk.\n-        (SidAbsent, XsrfOk(\"_no_creds_\"), Nil)\n+        dieIf(sessionIdStatus != SidAbsent, \"TyE502MWEG\")\n+        (XsrfOk(\"\"), Nil)\n       }\n       else {\n         // Reject this request if the XSRF token is invalid,\n@@ -441,12 +531,18 @@ class EdSecurity(globals: Globals) {\n         } getOrElse\n             throwForbidden(\"TyE0XSRFTKN_\", \"No xsrf token\")\n \n+        val gotAnyCookie =\n+              anySillySidInCookie.isDefined ||\n+              anyFancySidPart123CookieVal.isDefined ||\n+              anyFancySidPart4.isDefined ||\n+              anyFancySidPart5.isDefined\n+\n         val xsrfOk = {\n           val xsrfStatus =\n-            checkXsrfToken(\n-              xsrfToken, anyXsrfCookieValue,\n-              thereIsASidCookie = anySessionIdCookieValue.isDefined,\n-              now, expireIdleAfterMillis = expireIdleAfterMillis)\n+                checkXsrfToken(\n+                    xsrfToken, anyXsrfCookieValue,\n+                    thereIsASidCookie = gotAnyCookie,\n+                    now, expireIdleAfterMillis = expireIdleAfterMillis)\n \n           def helpText(theProblem: String, nowHaveOrWillGet: String): String = i\"\"\"\n             |Security issue: $theProblem. Please try again:\n@@ -511,24 +607,32 @@ class EdSecurity(globals: Globals) {\n           xsrfStatus.asInstanceOf[XsrfOk]\n         }\n \n-        CLEAN_UP // simplify this weird match-case!  & don't take & \"return\"\n-        // sessionIdStatus for no reason all the time.\n-        val r = sessionIdStatus match {\n-          case s: SidOk => (s, xsrfOk, Nil)\n-          case SidAbsent => (SidAbsent, xsrfOk, Nil)\n-          case s: SidExpired => (s, xsrfOk, Nil)\n-          case _ =>\n+        sessionIdStatus match {\n+          case SidBadFormat | SidBadHash =>\n             throw ResultException(\n               ForbiddenResult(\"TyEBADSID\", \"Bad session ID\",\n                   \"You can try again \u2014 I just deleted the bad session ID.\")\n                 .discardingCookies(\n-                  DiscardingSessionCookie))\n+                      DiscardingSessionCookies: _*))\n+          case _ => // fine\n         }\n-        dieIf(isDevOrTest && r != (sessionIdStatus, xsrfOk, Nil), \"TyE205RKPG36\")\n-        r\n+\n+        (xsrfOk, Nil)\n       }\n+    }\n+\n+    dieIf(upgrToFancySidCookies.nonEmpty && deleteFancySidCookies.nonEmpty, \"TyE5A6MRE25\")\n+\n+    val allCookiesToAdd =\n+          if (!maySetCookies) Nil\n+          else upgrToFancySidCookies:::newCookies\n \n-    sidXsrfNewCookies\n+    CheckSidAndXsrfResult(\n+          checkSidResult.anyTySession,  // [btr_sid]\n+          sessionIdStatus,  // old, will remove later\n+          xsrf,\n+          cookiesToAdd = allCookiesToAdd,\n+          cookiesToDelete = deleteFancySidCookies)\n   }\n \n \n@@ -675,95 +779,401 @@ class EdSecurity(globals: Globals) {\n   }\n \n \n-  def createSessionIdAndXsrfToken(siteId: SiteId, userId: UserId): (SidOk, XsrfOk, List[Cookie]) = {\n-    COULD_OPTIMIZE // pass settings or a dao to here instead? so won't need to create this 2nd one.\n-                    // (the caller always already has one)\n-    val dao = globals.siteDao(siteId)\n+\n+  def createSessionIdAndXsrfToken(req: AuthnReqHeader, userId: PatId)\n+        : (SidOk, XsrfOk, List[Cookie]) = {\n+\n+    AUDIT_LOG // Maybe log session id creation?\n+\n+    val site = req.site\n+    val dao = req.dao\n+\n+    val tryFancySid = site.isFeatureEnabled(\"ffTryNewSid\", globals.config.featureFlags)\n+    val useFancySid = site.isFeatureEnabled(\"ffUseNewSid\", globals.config.featureFlags)\n \n     val ppt = dao.getParticipant(userId)\n     throwForbiddenIf(ppt.exists(_.isGroup), \"TyELGIGRP\", \"Cannot login as a group\")  // [imp-groups]\n \n     val settings = dao.getWholeSiteSettings()\n     val expireIdleAfterSecs = settings.expireIdleAfterMins * 60\n \n-    // Note that the xsrf token is created using the non-base64 encoded cookie value.\n-    val sidOk = createSessionId(siteId, userId)\n     val xsrfOk = createXsrfToken()\n-    UX; SECURITY; SHOULD // use HttpOnly cookies \u2014 otherwise Safari will delete the cookie\n-    // after 7 days. See: https://webkit.org/blog/8613/intelligent-tracking-prevention-2-1/\n-    // the \"Client-Side Cookies Capped to 7 Days of Storage\", section, and sub section\n-    // \"Will This Change Log Users Out?\" \u2014 cookies that are Secure and HttpOnly aren't deleted.\n-    // This means the client can no longer look at the session cookie, to find out if one is\n-    // logged in? Could add JS variables instead.  [NOCOOKIES]\n+    val xsrfCookie = urlEncodeCookie(XsrfCookieName, xsrfOk.value,\n+          maxAgeSecs = Some(expireIdleAfterSecs + XsrfAliveExtraSeconds))\n+\n+    // New better sid  [btr_sid]\n+    // ----------------------------------------\n+\n+    if (tryFancySid || useFancySid) {\n+      val (newSidCookies, session) = genAndSaveFancySid(req, patId = userId,\n+            expireIdleAfterSecs = expireIdleAfterSecs, dao.now(),\n+            dao.asInstanceOf[SessionSiteDaoMixin])\n+      val sidOk = SidOk(session.part1And2, ageInMillis = 0, Some(userId))\n+      return (sidOk, xsrfOk, xsrfCookie :: newSidCookies)\n+    }\n+\n+    // Old style sid  (signed cookie)\n+    // ----------------------------------------\n+\n+    var sidOk = createSessionId(site, userId)\n     val sidCookie = urlEncodeCookie(SessionIdCookieName, sidOk.value,\n       maxAgeSecs = Some(expireIdleAfterSecs))\n-    val xsrfCookie = urlEncodeCookie(XsrfCookieName, xsrfOk.value,\n-      maxAgeSecs = Some(expireIdleAfterSecs + XsrfAliveExtraSeconds))\n+\n+    COULD_OPTIMIZE // use ArrBuf\n     (sidOk, xsrfOk, sidCookie::xsrfCookie::Nil)\n   }\n \n \n-  private val HashLength: Int = 15\n-  private def secretSalt = globals.applicationSecret\n+  private def genAndSaveFancySid(req: AuthnReqHeader, patId: PatId, expireIdleAfterSecs: i32,\n+          now: When, dao: SessionSiteDaoMixin): (List[Cookie], TySession) = {\n+\n+    import com.debiki.core.{TySession => S}\n+    val totalEntropy = S.SidLengthCharsTotal * S.SidEntropyPerChar\n+    assert(totalEntropy == 96 + 144 + 144 + 144 + 96)\n+    val wholeSid = nextRandomString(totalEntropy, base36 = false, base64UrlSafe = true)\n+    dieIf(wholeSid.length != S.SidLengthCharsTotal, \"TyESIDLEN538RMD\",\n+          s\"Generated a ${wholeSid.length} chars session id, but should be ${\n+          S.SidLengthCharsTotal} chars long. Here it is: '$wholeSid' (won't get used)\")\n+\n+    val lenUpTo1 = S.SidLengthCharsPart1\n+    val lenUpTo2 = lenUpTo1 + S.SidLengthCharsPart2\n+    val lenUpTo3 = lenUpTo2 + S.SidLengthCharsPart3\n+    val lenUpTo4 = lenUpTo3 + S.SidLengthCharsPart4\n+\n+    val part1 = wholeSid.substring(0, lenUpTo1)\n+    val part2 = wholeSid.substring(lenUpTo1, lenUpTo2)\n+    val part3 = wholeSid.substring(lenUpTo2, lenUpTo3)\n+    val part4 = wholeSid.substring(lenUpTo3, lenUpTo4)\n+    val part5 = wholeSid.substring(lenUpTo4, S.SidLengthCharsTotal)\n+\n+    assert(part1.length == S.SidLengthCharsPart1)\n+    assert(part2.length == S.SidLengthCharsPart2)\n+    assert(part3.length == S.SidLengthCharsPart3)\n+    assert(part4.length == S.SidLengthCharsPart4)\n+    assert(part5.length == S.SidLengthCharsPart5)\n+\n+    val newSidPart123Cookie = urlEncodeCookie(\n+          SessionIdPart123CookieName, part1 + part2 + part3,\n+          maxAgeSecs = Some(expireIdleAfterSecs), httpOnly = false)\n+\n+    val newSidPart4Cookie = urlEncodeCookie(\n+          SessionIdPart4HttpOnlyCookieName, part4,\n+          maxAgeSecs = Some(expireIdleAfterSecs), httpOnly = true)\n+\n+    val newSidPart5Cookie = urlEncodeCookie(\n+          SessionIdPart5StrictCookieName, part5,\n+          maxAgeSecs = Some(expireIdleAfterSecs), httpOnly = true, sameSiteStrict = true)\n+\n+    val startHeaders = {\n+      import http.{HeaderNamesLowercase => H}\n+      // New & nice:\n+      val chUserAgent = req.headers.get(H.ClientHintUserAgent).trimNoneIfBlank\n+      val chUaMobile = req.headers.get(H.ClientHintUaMobile).trimNoneIfBlank\n+      val chUaPlatform = req.headers.get(H.ClientHintUaPlatform).trimNoneIfBlank\n+      // Old & verbose:\n+      val userAgent = req.headers.get(H.UserAgent).trimNoneIfBlank\n+\n+      val mapBuilder = Map.newBuilder[St, JsValue]\n+      val maxLen = 200 // header max length. 200 is a lot?\n+      val mobLen = 20  // should be just \"?0\" or \"?1\"\n+      chUserAgent.foreach(v => mapBuilder += H.ClientHintUserAgent -> JsString(v take maxLen))\n+      chUaMobile.foreach(v => mapBuilder += H.ClientHintUaMobile -> JsString(v take mobLen))\n+      chUaPlatform.foreach(v => mapBuilder += H.ClientHintUaPlatform -> JsString(v take maxLen))\n+\n+      // Skip the verbose User-Agent header if we got the new & better client hint header.\n+      if (chUserAgent.isEmpty) {\n+        userAgent.foreach(v => mapBuilder += H.UserAgent -> JsString(v take maxLen))\n+      }\n+      JsObject(mapBuilder.result)\n+    }\n+\n+    val session = TySession(\n+          patId = patId,\n+          createdAt = now,\n+          version = TySession.CurVersion,\n+          startIp = Some(req.ip),\n+          startBrowserId = req.browserId.map(_.cookieValue),\n+          startHeaders = startHeaders,\n+          part1CompId = part1,\n+          part2ForEmbgStorage = part2,\n+          part2Hash = hashSha512FirstHalf32Bytes(part2),\n+          part3ForDirJs = Some(part3),\n+          part3Hash = hashSha512FirstHalf32Bytes(part3),\n+          part4HttpOnly = Some(part4),\n+          part4Hash = hashSha512FirstHalf32Bytes(part4),\n+          part5Strict = Some(part5),\n+          part5Hash = hashSha512FirstHalf32Bytes(part5))\n+\n+    dao.insertValidSession(session)\n+\n+    (List(newSidPart123Cookie, newSidPart4Cookie, newSidPart5Cookie), session)\n+  }\n \n \n-  private def checkSessionId(siteId: SiteId, value: String, now: When, expireIdleAfterMillis: Long)\n-      : SidStatus = {\n+  // 15 chars is 90 bits entropy (15 * 6 bits, using Base64) \u2014 that's more than enough:\n+  // https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html\n+  // >  The session ID value must provide at least 64 bits of entropy\n+  // 11 chars is 66 bits entropy (with a perfect rand num gen).\n+  private val HashLength: i32 = 15\n+\n+  private def secretSalt: St = globals.applicationSecret\n+\n+\n+  private def checkSessionId(\n+        site: SiteBrief,\n+        anySillySid: Opt[St],\n+        anyFancySidPart12Maybe3: Opt[St],\n+        anyFancySidPart4: Opt[St],\n+        anyFancySidPart5: Opt[St],\n+        dao: SessionSiteDaoMixin,\n+        now: When,\n+        expireIdleAfterMillis: i64): CheckSidResult = {\n+\n+    val hasFancySid = anyFancySidPart12Maybe3.isDefined || anyFancySidPart4.isDefined ||\n+          anyFancySidPart5.isDefined\n+    val useOnlyFancySid = site.isFeatureEnabled(\"ffUseNewSid\", globals.config.featureFlags)\n+    val tryFancySid = site.isFeatureEnabled(\"ffTryNewSid\", globals.config.featureFlags)\n+\n+    if (useOnlyFancySid || (tryFancySid && hasFancySid)) {\n+      var result = checkFancySessionId(anyPart12Maybe3 = anyFancySidPart12Maybe3,\n+            anyPart4 = anyFancySidPart4, anyPart5 = anyFancySidPart5,\n+            dao, now, expireIdleAfterMillis = expireIdleAfterMillis)\n+      if (anySillySid.isDefined) {\n+        result = result.copy(\n+              discardCookies = DiscardingSillySidCookie :: result.discardCookies)\n+      }\n+      result\n+    }\n+    else {\n+      var result = checkSillySessionId(site, anySillySid, dao, now, expireIdleAfterMillis)\n+      if (hasFancySid) {\n+        result = result.copy(\n+              discardCookies = DiscardingFancySidCookies ::: result.discardCookies)\n+      }\n+      result\n+    }\n+  }\n+\n+\n+  private def checkFancySessionId(  // [btr_sid]\n+        anyPart12Maybe3: Opt[St], anyPart4: Opt[St], anyPart5: Opt[St],\n+        dao: SessionSiteDaoMixin, now: When,\n+        expireIdleAfterMillis: i64): CheckSidResult = {\n+\n+    val anySession = anyPart12Maybe3 flatMap dao.getSessionByPart1\n+\n+    val session: TySessionInDbMaybeBad = anySession getOrElse {\n+      // If pat has logged out client side, when offline, the not-HttpOnly session parts\n+      // would be gone, whilst we'd still get the 4th and 5th parts in HttpOnly cookies.\n+      // If so, we should delete the session server side too \u2014\n+      // so, let's look it up by part 4 \u2014 there's an index on part 4 (not part 5), because\n+      // part 4 should always be present, if part 5 is present (part 4 is SameSite Lax,\n+      // part 5 Strict).\n+\n+      // Maybe maybe Safari will sometimes mistakenly auto clear localStorage?\n+      // See [ios_itp] in maybe-later.txt.\n+\n+      anyPart4.flatMap(dao.getSessionByPart4HttpOnly(_, maybeActiveOnly = true)) foreach { s =>\n+        // Test: sso-test  TyT4ABKRW0268.TyTESESS123GONE\n+        AUDIT_LOG // client side logout\n+        val sessionDeleted = s.copy(deletedAt = Some(now))\n+        dao.updateSession(sessionDeleted)\n+      }\n+\n+      // Session gone. Delete any cookies.\n+      val gotCookies = anyPart12Maybe3.isDefined || anyPart4.isDefined || anyPart5.isDefined\n+\n+      return CheckSidResult.noSession(\n+            SidAbsent,\n+            discardCookies = if (gotCookies) DiscardingFancySidCookies else Nil)\n+    }\n+\n+    import TySession._\n+\n+    val thePart12Maybe3: St = anyPart12Maybe3 getOrDie \"TyE3MG70QFM2\"\n+    val thePart2: St = thePart12Maybe3.substring(SidLengthCharsPart1, SidLengthCharsPart12)\n+    val hashPart2: Array[i8] = hashSha512FirstHalf32Bytes(thePart2)\n+    val part3IsPresent = thePart12Maybe3.length > TySession.SidLengthCharsPart12\n+    val anyPart3: Opt[St] =\n+          if (!part3IsPresent) None\n+          else Some(thePart12Maybe3.substring(SidLengthCharsPart12, SidLengthCharsPart123))\n+\n+    val anyPart3Hash = anyPart3.map(hashSha512FirstHalf32Bytes)\n+    val anyPart4Hash = anyPart4.map(hashSha512FirstHalf32Bytes)\n+    val anyPart5Hash = anyPart5.map(hashSha512FirstHalf32Bytes)\n+\n+    // Part 2, and 3, 4, 5 if present, must be from the same session.\n+    // We've checked part 1 already \u2014 we found the session via part 1.\n+\n+    val badPart2 = !hashPart2.sameElements(session.part2HashForEmbgStorage)\n+    val badPart3 = anyPart3Hash.map(_ sameElements session.part3HashForDirJs) is false\n+    val badPart4 = anyPart4Hash.map(_ sameElements session.part4HashHttpOnly) is false\n+    val badPart5 = anyPart5Hash.map(_ sameElements session.part5HashStrict) is false\n+\n+    if (badPart2 || badPart3 || badPart4 || badPart5) {\n+      AUDIT_LOG // this is suspicious?\n+\n+      val sessionDeleted = session.copy(deletedAt = Some(now))\n+      dao.updateSession(sessionDeleted)\n+\n+      // Maybe part 4 is from another older/newer session somehow? That'd be weird.\n+      // Then, invalidate that session too.\n+      // (Since parts 123 are not-HttpOnly, but parts 4 and 5 are HttpOnly,\n+      // they could get out of sync maybe because of some unknown bug, or if a script\n+      // or a person manipulates their cookies.)\n+      if (badPart4) {\n+        COULD_OPTIMIZE // We've hashed part 4 above, need not do again in\n+        // SessionsRdbMixin.loadSession().\n+        dao.getSessionByPart4HttpOnly(anyPart4.get, maybeActiveOnly = true) foreach {\n+              differentSession =>\n+          // The database should prevent any parts being the same (unique indexes,\n+          // on parts 1 and 4, but not 2, 3 or 5).\n+          AUDIT_LOG // that we're deleting another session?\n+          UNTESTED ; TESTS_MISSING  // TyTSESSHALFBAD\n+\n+          warnDevDieIf(differentSession.part1CompId == session.part1CompId, \"TyE603MSEJ56\")\n+          warnDevDieUnless(differentSession.part4HashHttpOnly sameElements\n+                session.part4HashHttpOnly, \"TyE603MSEJ56\")\n+\n+          val differentSessionDeleted = differentSession.copy(deletedAt = Some(now))\n+          dao.updateSession(differentSessionDeleted)\n+        }\n+      }\n+\n+      return CheckSidResult.noSession(SidAbsent, discardCookies = DiscardingSessionCookies)\n+    }\n+\n+    if (session.isDeleted || session.hasExpired)\n+      return CheckSidResult.noSession(SidAbsent, discardCookies = DiscardingSessionCookies)\n+\n+    // Did the session expire just now?  [lazy_expire_sessions]\n+    //\n+    // Maybe instead:\n+    // val justExpired = session.expiresNow(now, expireIdleAfterMillis / MillisPerMinute)\n+\n+    UX; SHOULD // bump lastSeenAt somehow, and add idle time to that? [bump_sid_last_use]\n+\n+    val expiresAt = expireIdleAfterMillis + session.createdAt.millis\n+    if (expiresAt < now.millis) {\n+      AUDIT_LOG // session lazy-expired\n+      // Then don't allow using the session any more, even if the server time gets\n+      // changed back to before when it expired.\n+      val sessionExpired = session.copy(expiredAt = Some(now))\n+      dao.updateSession(sessionExpired)\n+      // or use SidExpired instead of SidAbsent. But why?\n+      return CheckSidResult.noSession(SidAbsent, discardCookies = DiscardingSessionCookies)\n+    }\n+\n+    val sidOk = SidOk(value = thePart12Maybe3.take(SidLengthCharsPart12),\n+          ageInMillis = now.millis - session.createdAt.millis,\n+          userId = Some(session.patId))\n+\n+    CheckSidResult(\n+          Some(session.copyAsValid(\n+              // Parts 3, 4, 5 are optional. (Parts 1 and 2? We found the session via part 1,\n+              // and part 2 is required, and we have compared it with the session\n+              // in the database already, above.)\n+              part2 = thePart2,\n+              part3 = anyPart3,\n+              part4 = anyPart4,\n+              part5 = anyPart5)),\n+          sidOk)\n+  }\n+\n+\n+  private def checkSillySessionId(site: SiteBrief, anyOldSid: Opt[St],\n+        dao: SessionSiteDaoMixin, now: When,\n+        expireIdleAfterMillis: i64): CheckSidResult = {\n+\n+    val value = anyOldSid getOrElse {\n+      return CheckSidResult.noSession(SidAbsent)\n+    }\n+\n     // Example value: 88-F7sAzB0yaaX.1312629782081.1c3n0fgykm  - no, obsolete\n-    if (value.length <= HashLength) return SidBadFormat\n+    if (value.length <= HashLength)\n+      return CheckSidResult.noSession(SidBadFormat)\n+\n     val (hash, dotUseridDateRandom) = value splitAt HashLength\n     val realHash = hashSha1Base64UrlSafe(\n-      s\"$secretSalt.$siteId$dotUseridDateRandom\") take HashLength\n-    if (hash != realHash) return SidBadHash\n-    dotUseridDateRandom.drop(1).split('.') match {\n+      s\"$secretSalt.${site.id}$dotUseridDateRandom\") take HashLength\n+\n+    if (hash != realHash)\n+      return CheckSidResult.noSession(SidBadHash)\n+\n+    val oldOkSid = dotUseridDateRandom.drop(1).split('.') match {\n       case Array(userIdString, dateStr, randVal) =>\n         val userId: Option[UserId] =\n           if (userIdString.isEmpty) None\n           else Try(userIdString.toInt).toOption orElse {\n-            return SidBadFormat\n+            return CheckSidResult.noSession(SidBadFormat)\n           }\n         val ageMillis = now.millis - dateStr.toLong\n         UX; BUG; COULD; // [EXPIREIDLE] this also expires *active* sessions. Instead,\n         // lookup the user, and consider only time elapsed, since hens last visit.\n         // ... Need to have a SiteDao here then. And pass the Participant back to the\n         // caller, so it won't have to look it up again.\n         // Not urgent though \u2014 no one will notice: by default, one stays logged in 1 year [7AKR04].\n-        if (ageMillis > expireIdleAfterMillis)\n-          return SidExpired(\n-            minutesOld = ageMillis / MillisPerMinute,\n-            maxAgeMins = expireIdleAfterMillis / MillisPerMinute)\n+        if (ageMillis > expireIdleAfterMillis) {\n+          val expiredSid = SidExpired(\n+                  minutesOld = ageMillis / MillisPerMinute,\n+                  maxAgeMins = expireIdleAfterMillis / MillisPerMinute,\n+                  wasForPatId = userId)\n+          return CheckSidResult.noSession(expiredSid)\n+        }\n         SidOk(\n           value = value,\n           ageInMillis = ageMillis,\n           userId = userId)\n       case _ => SidBadFormat\n     }\n+\n+    var newSidCookies: List[Cookie] = Nil\n+\n+    // Upgrade old sid to new style sid:  [btr_sid]\n+    // ----------------------------------------\n+\n+    /* Maybe skip this. Hard to test?\n+    if ((tryFancySid || useFancySid) && oldOkSid.userId.isDefined) {\n+      val dao = anyDao getOrDie \"TyE50FREN68\"\n+      val patId = oldOkSid.userId getOrDie \"TyE602MTEGPH\"\n+      val settings = dao.getWholeSiteSettings()\n+      val expireIdleAfterSecs = settings.expireIdleAfterMins * 60\n+      val (newCookies, sidPart1, sidPart2) =\n+            genAndSaveFancySid(patId = patId, expireIdleAfterSecs, dao.redisCache,\n+                isOldUpgraded = true)\n+      // cookies = newSidPart1Cookie::newSidPart2Cookie::cookies\n+      result = SidOk(sidPart1,\n+            expireIdleAfterSecs * 1000, Some(patId))\n+      newSidCookies = newCookies\n+    }\n+    */\n+\n+    CheckSidResult(anyTySession = None, oldOkSid, createCookies = newSidCookies)\n   }\n \n \n-  private def createSessionId(siteId: SiteId, userId: UserId): SidOk = {\n-    // For now, create a SID value and *parse* it to get a SidOk.\n-    // This is stupid and inefficient.\n+  @deprecated(\"Now\", \"Use the fancy session id instead.\")\n+  private def createSessionId(site: SiteBrief, userId: PatId): SidOk = {\n     val now = globals.now()\n-    val uid = \"\" // for now\n     val useridDateRandom =\n          userId +\".\"+\n          now.millis +\".\"+\n          (nextRandomString() take 10)\n+\n     // If the site id wasn't included in the hash, then an admin from site A could\n     // login as admin at site B, if they have the same user id and username.\n     val saltedHash = hashSha1Base64UrlSafe(\n-      s\"$secretSalt.$siteId.$useridDateRandom\") take HashLength\n-    val value = s\"$saltedHash.$useridDateRandom\"\n+      s\"$secretSalt.${site.id}.$useridDateRandom\") take HashLength\n \n-    checkSessionId(siteId, value, now, expireIdleAfterMillis = Long.MaxValue).asInstanceOf[SidOk]\n+    val value = s\"$saltedHash.$useridDateRandom\"\n+    SidOk(value, ageInMillis = 0, Some(userId))\n   }\n \n \n   // ----- Secure cookies\n \n-  def SecureCookie(name: String, value: String, maxAgeSeconds: Option[Int] = None,\n-        httpOnly: Boolean = false) =\n+  def SecureCookie(name: St, value: St, maxAgeSeconds: Opt[i32] = None,\n+        httpOnly: Bo = false): Cookie =\n     Cookie(\n       name,\n       value,\n@@ -783,6 +1193,8 @@ class EdSecurity(globals: Globals) {\n     */\n   private def anySameSiteCookieValue(): Option[Cookie.SameSite] = {  // [SAMESITE]\n     // SameSite.None only works with https.\n+    SECURITY // Remove this? No longer needed \u2014 instead, session parts 1-5,\n+    // and 5 is always strict.\n     if (globals.secure && globals.config.sameSiteNone) {\n       Some(Cookie.SameSite.None)\n     }\n@@ -798,7 +1210,20 @@ class EdSecurity(globals: Globals) {\n   def DiscardingSecureCookie(name: String) =\n     DiscardingCookie(name, secure = globals.secure)\n \n-  def DiscardingSessionCookie: DiscardingCookie = DiscardingSecureCookie(SessionIdCookieName)\n+  def DiscardingSessionCookies: List[DiscardingCookie] =\n+    List(DiscardingSecureCookie(SessionIdCookieName),\n+        DiscardingSecureCookie(SessionIdPart123CookieName),\n+        DiscardingSecureCookie(SessionIdPart4HttpOnlyCookieName),\n+        DiscardingSecureCookie(SessionIdPart5StrictCookieName))\n+\n+  def DiscardingSillySidCookie: DiscardingCookie =\n+    DiscardingSecureCookie(SessionIdCookieName)\n+\n+  def DiscardingFancySidCookies: List[DiscardingCookie] =\n+    List(DiscardingSecureCookie(SessionIdPart123CookieName),\n+        DiscardingSecureCookie(SessionIdPart4HttpOnlyCookieName),\n+        DiscardingSecureCookie(SessionIdPart5StrictCookieName))\n+\n   // Maybe also always delete:  ImpersonationCookieName  ?\n   // Well, things work fine anyway as of now (Mars 2020).\n \n@@ -809,25 +1234,33 @@ class EdSecurity(globals: Globals) {\n   // then it is surrounded with quotes.\n   // the jQuery cookie plugin however expects an urlencoded value:\n   // 2. urlEncode(value) results in these cookies being sent:\n-  //    Set-Cookie: dwCoUserEmail=\"kajmagnus79%40gmail.com\";Path=/\n-  //    Set-Cookie: dwCoUserName=\"Kaj%20Magnus\";Path=/\n+  //    Set-Cookie: dwCoUserEmail=\"someone%40exaple.com\";Path=/\n+  //    Set-Cookie: dwCoUserName=\"space%20text\";Path=/\n   // No encoding results in these cookies:\n-  //    Set-Cookie: dwCoUserEmail=kajmagnus79@gmail.com;Path=/\n-  //    Set-Cookie: dwCoUserName=\"Kaj Magnus\";Path=/\n+  //    Set-Cookie: dwCoUserEmail=someone@example.com;Path=/\n+  //    Set-Cookie: dwCoUserName=\"space text\";Path=/\n   // So it seems a % encoded string is surrounded with double quotes, by\n   // javax.servlet.http.Cookie? Why? Not needed!, '%' is safe.\n   // So I've modified jquery-cookie.js to remove double quotes when\n   // reading cookie values.\n-  private def urlEncodeCookie(name: String, value: String, maxAgeSecs: Option[Int] = None) =\n+  private def urlEncodeCookie(name: St, value: St, maxAgeSecs: Opt[i32] = None,\n+        httpOnly: Bo = false, sameSiteStrict: Bo = false) =\n     Cookie(\n       name = name,\n       value = urlEncode(convertEvil(value)),  // see comment above\n       maxAge = maxAgeSecs,\n       path = \"/\",\n+      // Don't set \u2014 if set to, say, example.com, then, vulnerabilities at\n+      // www.example.com might allow an attacker to get access to cookies\n+      // from secure.example.com\n+      // https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#domain-and-path-attributes\n       domain = None,\n       secure = globals.secure,\n-      sameSite = anySameSiteCookieValue(),\n-      httpOnly = false)\n+      sameSite =\n+            // If debugging on localhost over http, does Strict work?\n+            if (sameSiteStrict) Some(Cookie.SameSite.Strict)\n+            else anySameSiteCookieValue(),\n+      httpOnly = httpOnly)\n \n \n   /** Extracts any browser id cookie from the request, or creates it if absent"
        },
        {
          "filename": "appsv/server/talkyard/server/JsX.scala",
          "status": "modified",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -310,6 +310,24 @@ object JsX {   RENAME // to JsonPaSe\n   }\n \n \n+  /// ts: Session\n+  def JsSession(sess: TySessionInDbMaybeBad, inclPart1: Bo = true): JsObject = {\n+    // Don't include the actual session id. (That is, exclude parts 2 \u2013 5. *Could* maybe\n+    // theoretically include them, since they're hashes, but bad idea, and not needed.)\n+    var json = Json.obj(\n+          \"patId\" -> sess.patId,\n+          \"createdAt\" -> JsWhenMs(sess.createdAt),\n+          \"deletedAt\" -> JsWhenMsOrNull(sess.deletedAt),\n+          \"expiredAt\" -> JsWhenMsOrNull(sess.expiredAt),\n+          \"version\" -> JsNumber(sess.version),\n+          \"startHeaders\" -> sess.startHeaders)\n+    if (inclPart1) {\n+      json += \"part1\" -> JsString(sess.part1CompId)\n+    }\n+    json\n+  }\n+\n+\n   def JsUserStats(stats: UserStats, isStaffOrSelf: Boolean): JsObject = {\n     val tourTipsIds: immutable.Seq[String] = stats.tourTipsSeen getOrElse Nil\n     var result = Json.obj("
        },
        {
          "filename": "appsv/server/talkyard/server/api/QueryDoController.scala",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -81,8 +81,8 @@ class QueryDoController @Inject()(cc: ControllerComponents, edContext: EdContext\n       val listQueryJsOb = parseOptJsObject(jsOb, \"listQuery\")\n       val searchQueryJsOb = parseOptJsObject(jsOb, \"searchQuery\")\n       // Any nested queries or actions? (E.g. for fine grained transaction control.)\n-      val nestedQueries: Opt[JsArray] = parseOptJsArray(jsVal, \"manyQueries\")\n-      val nestedActions: Opt[JsArray] = parseOptJsArray(jsVal, \"doActions\")\n+      val nestedQueries: Opt[IndexedSeq[JsValue]] = parseOptJsArray(jsVal, \"manyQueries\")\n+      val nestedActions: Opt[IndexedSeq[JsValue]] = parseOptJsArray(jsVal, \"doActions\")\n \n       val anyQueryDefined =\n             getQueryJsOb.isDefined || listQueryJsOb.isDefined ||"
        },
        {
          "filename": "appsv/server/talkyard/server/authn/SsoAuthnController.scala",
          "status": "modified",
          "additions": 4,
          "deletions": 5,
          "patch": "@@ -104,14 +104,14 @@ class SsoAuthnController @Inject()(cc: ControllerComponents, edContext: EdContex\n \n         val user = dao.getTheUser(userId)\n         dao.pubSub.userIsActive(siteId, user, request.theBrowserIdData)\n-        val (sid, _, sidAndXsrfCookies) = security.createSessionIdAndXsrfToken(siteId, user.id)\n+        val (sid, _, sidAndXsrfCookies) =\n+              security.createSessionIdAndXsrfToken(request, user.id)\n \n         val response = if (request.isAjax) {\n           // As of 2019-12: This is embedded comments login, when 3rd party cookies blocked. [306KUD244]\n           SECURITY // a session cookie will get attached too \u2014\u00a0would be good if it could\n           // be deleted server side. [serversid]\n           OkSafeJson(Json.obj(\n-            // Not yet weak but later. [weaksid]\n             \"weakSessionId\" -> JsString(sid.value)))  // [NOCOOKIES]\n         }\n         else {\n@@ -241,11 +241,10 @@ class SsoAuthnController @Inject()(cc: ControllerComponents, edContext: EdContex\n           upsertUser(extUser, req, mayOnlyInsertNotUpdate = true)\n \n     val (sid, _, _) =\n-          security.createSessionIdAndXsrfToken(siteId, user.id)\n+          security.createSessionIdAndXsrfToken(req, user.id)\n \n     OkSafeJson(Json.obj(\n-      // Not yet weak but later. [weaksid]  [NOCOOKIES]\n-      \"weakSessionId\" -> JsString(sid.value)))\n+      \"weakSessionId\" -> JsString(sid.value)))  // [NOCOOKIES]\n   }\n \n "
        },
        {
          "filename": "appsv/server/talkyard/server/authn/package.scala",
          "status": "modified",
          "additions": 76,
          "deletions": 0,
          "patch": "@@ -33,6 +33,82 @@ package object authn {   REFACTOR; MOVE // most of this to an object UserInfoPar\n     case object LoginToAdministrate extends LoginReason(24)\n   }\n \n+  sealed abstract class MinAuthnStrength(val IntVal: i32, val fullSidRequired: Bo = true) {\n+    def toInt: i32 = IntVal\n+  }\n+\n+\n+  // RENAME to AuthnStrength? And a *param* name can be minAuthnStrength instead?\n+  // Then, AuthnStrength.[InternalJob] makes sense, otherwise not.\n+  //\n+  object MinAuthnStrength {\n+\n+    // No session id needed \u2014 instead, we check an e2e test secret, for each request.\n+    case object E2eTestPassword extends MinAuthnStrength(10, fullSidRequired = false)\n+\n+    // No session id needed \u2014 instead, we check an API secret, for each request.\n+    case object ApiSecret extends MinAuthnStrength(15, fullSidRequired = false)\n+\n+    /// Parts 1 and 2 of old embedded sessions might have been cached in localStorage\n+    /// in the embedding website, and if the embedding website has security vulnerabilities,\n+    /// an attacker might have gained access to those parts of the session.\n+    /// Therefore, those parts of the session should give access only to\n+    /// embedded comments \u2014 like, posting comments, editing one's comments,\n+    /// or (for mods) moderating embedded comments [mod_emb_coms_sid],\n+    /// but nothing else. Then, if a blog has security vulnerabilities, only\n+    /// the blog comments would be affected \u2014 but not any Talkyard forum on its own\n+    /// sub domain (for organizations with both a forum and blog comments),\n+    /// or any user accounts or email addresses.\n+    ///\n+    /// This could also be configurable, so the site admins could choose to always\n+    /// require session part 3, or even require people to interact with the comments\n+    /// iframe, trying to make iOS Safari ITP understand that the comments aren't\n+    /// a tracker, and allow cookies \u2014 then, the server would get the HttpOnly\n+    /// cookies. [ios_itp]\n+    ///\n+    case object EmbeddingStorageSid12 extends MinAuthnStrength(20, fullSidRequired = false)\n+\n+    /// The embedded sid can be refreshed by popping up a window directly\n+    /// against the Talkyard server \u2014 then, the session id part 3, in a cookie, would\n+    /// be accessible to the javascript in the popup, which could send it to the iframes.\n+    /// Or the app server could reply and include parts 1, 2, 3 in the response.\n+    /// But only sids part 1+2 (without part 3), would get rejected (since they're\n+    /// less safe, see EmbeddingStorageSid12 above). Part 3 would be temporarily\n+    /// remembered only in the iframes, never accessible to the embedd*ing* website,\n+    //case object EmbeddedIframeSid123 extends MinAuthnStrength(30, part3Required = true)\n+\n+    //case object EmbeddedIframeSid123Recent extends MinAuthnStrength(35, part3Required = true)\n+\n+    /// Apart from requiring HttpOnly cookies (session id part 4), what Normal\n+    /// authentication is, would be community specific. Some communities might be ok\n+    /// with password authn \u2014 whilst others might want 2 or 3 factor authn,\n+    /// and/or SameSite Strict cookies.\n+    case object Normal extends MinAuthnStrength(40)\n+\n+    /// Like Normal, but must have authenticated recently. Could protect against\n+    /// someone grabbing another person's laptop, running away, and then 5 minutes later\n+    /// trying to change the other person's email address to hens own \u2014 this wouldn't work,\n+    /// since hen would need to authenticate again first (so has authenticated just recently).\n+    //case object NormalRecent extends MinAuthnStrength(45)\n+\n+    /// A community can optionally require stronger authentication, for some endpoints\n+    /// (or maybe even some specific parts of a community?), or custom groups, mods or admins.\n+    /// By default, Strong is the same as Normal \u2014 the site admins would need to\n+    /// specify somehow what Strong means, in their community's case. Maybe\n+    /// OTP + 2FA could be a default? Or should WebAuthn be the default Strong method?\n+    /// (Unlike 2FA in general, WebAuthn works against phishing.)\n+    //case object Strong extends MinAuthnStrength(50)\n+\n+    /// Like Strong, but must have authenticated recently \u2014 say, within the last X minutes\n+    /// (and X is community specific).\n+    /// For things like changing one's email address or deleting one's account.\n+    //case object StrongRecent extends MinAuthnStrength(55)\n+\n+    /// Maybe useful if min-auth-strength fn gets called by an internal background job?\n+    // case object [InternalJob] extends MinAuthnStrength(99)\n+  }\n+\n+\n   // Aliases for better readability.\n   type JoinOrLeave = AddOrRemove\n   val Join: Add.type = Add"
        },
        {
          "filename": "appsv/server/talkyard/server/http/package.scala",
          "status": "added",
          "additions": 56,
          "deletions": 0,
          "patch": "@@ -0,0 +1,56 @@\n+package talkyard.server\n+\n+import com.debiki.core._\n+import play.api.http.{HeaderNames => play_HeaderNames}\n+\n+package object http {\n+\n+  val UserAgentHeaderNormalLength = 100\n+\n+\n+  object HeaderNamesLowercase {\n+\n+    val UserAgent: St = play_HeaderNames.USER_AGENT.toLowerCase\n+\n+    val AcceptCH = \"accept-ch\"\n+\n+    // ----- User Agent\n+\n+    // The user agent related headers are:\n+    // - User-Agent\n+    // - Sec-CH-UA-Mobile    e.g. \"?0\"\n+    // - Sec-CH-UA-Platform  e.g. \"Linux\"\n+    // - Sec-CH-UA     e.g. \"Google Chrome\";v=\"95\", \"Chromium\";v=\"95\", \";Not A Brand\";v=\"99\"\n+\n+    // Sec-CH-UA, e.g. \"Google Chrome\";v=\"95\", \"Chromium\";v=\"95\", \";Not A Brand\";v=\"99\"\n+    val ClientHintUserAgent = \"sec-ch-ua\"\n+\n+    // Sec-CH-UA-Mobile: \"?0\" or \"?1\"\n+    val ClientHintUaMobile = \"sec-ch-ua-mobile\"\n+\n+    // Sec-CH-UA-Platform: e.g. \"Linux\"\n+    val ClientHintUaPlatform = \"sec-ch-ua-platform\"\n+\n+    val ClientHintHeaders: Vec[St] = Vec(\n+          ClientHintUserAgent,\n+          ClientHintUaMobile,\n+          ClientHintUaPlatform)\n+\n+    val ClientHintHeadersAndUserAgent: Vec[St] =\n+          ClientHintHeaders :+ UserAgent\n+\n+    // ----- Network related\n+\n+    val SaveData = \"save-data\"\n+\n+    // Effective connection type: slow-2g, 2g, 3g, 4g.\n+    val Ect = \"ect\"\n+\n+    // Approximate round trip time in millis, including application server processing time.\n+    val Rtt = \"rtt\"\n+\n+    // Approximate bandwidth of the client's connection to the server, in Mbps.\n+    val Downlink = \"downlink\"\n+  }\n+\n+}"
        },
        {
          "filename": "appsv/server/talkyard/server/sess/SessionController.scala",
          "status": "added",
          "additions": 90,
          "deletions": 0,
          "patch": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) 2021 Kaj Magnus Lindberg\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as\n+ * published by the Free Software Foundation, either version 3 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package talkyard.server.sess\n+\n+import com.debiki.core._\n+import debiki.RateLimits\n+import debiki.dao.SiteDao\n+import debiki.EdHttp._\n+import ed.server.{EdContext, EdController}\n+import controllers.Utils.OkApiJson\n+import play.api.libs.json._\n+import javax.inject.Inject\n+import play.api.mvc.{Action, ControllerComponents}\n+import talkyard.server.JsX._\n+import debiki.JsonUtils._\n+\n+\n+class SessionController @Inject()(cc: ControllerComponents, edContext: EdContext)\n+  extends EdController(cc, edContext) {\n+\n+\n+  def listSessions(patId: PatId): Action[U] = GetAction { req =>\n+    import req.{dao, theRequester => reqer}\n+    throwForbiddenIfMayNot(\"view\", dao, reqer, patId)\n+    val activeSessions = dao.listPatsSessions(patId)\n+    val json = Json.obj(\"sessions\" -> JsArray(activeSessions.map(s => JsSession(s))))\n+    OkApiJson(json)\n+  }\n+\n+\n+  def terminateSessions: Action[JsValue] = PostJsonAction(RateLimits.ConfigUser,\n+        maxBytes = 2000) { req =>\n+    import req.{dao, theRequester => reqer}\n+\n+    val body = asJsObject(req.body, \"The request body\")\n+    val forPatId = parseInt32(body, \"forPatId\")\n+\n+    throwForbiddenIfMayNot(\"terminate\", dao, reqer, forPatId)\n+\n+    val terminateAllOthers: Bo = parseOptBo(body, \"all\") getOrElse false\n+    val allButNot = if (!terminateAllOthers) None else Some(req.tySession.createdAt)\n+\n+    val sessionsStartedAtArr: Seq[JsValue] = parseOptJsArray(\n+          body, \"sessionsStartedAt\") getOrElse Nil\n+\n+    val startTimesMs: Seq[When] = sessionsStartedAtArr map { jsVal =>\n+      When.fromMillis(asInt64(jsVal, \"Session start date-time\"))\n+    }\n+\n+    throwBadReqIf(startTimesMs.nonEmpty && allButNot.isDefined, \"TyE4MWJ0202\",\n+          \"Don't specify both 'all' and 'sessionsStartedAt'\")\n+\n+    throwBadReqIf(startTimesMs.isEmpty && allButNot.isEmpty, \"TyE4MWJ0203\",\n+          \"Specify one of 'all' and 'sessionsStartedAt'\")\n+\n+    val terminatedSessions = dao.terminateSessions(\n+          forPatId, thoseStartedAt = startTimesMs, allButNot)\n+\n+    val json = Json.obj(\n+        \"terminatedSessions\" -> JsArray(terminatedSessions.map(s => JsSession(s))))\n+\n+    OkApiJson(json)\n+  }\n+\n+\n+  private def throwForbiddenIfMayNot(doWhat: St, dao: SiteDao, reqer: Pat, patId: PatId): U = {\n+    throwForbiddenIf(reqer.id != patId && !reqer.isStaff, \"TyE0YOURSESS\",\n+          s\"Cannot $doWhat other people's sessions\")\n+    val pat = dao.getTheParticipant(patId)\n+    throwForbiddenIf(pat.isAdmin && !reqer.isAdmin, \"TyEADMINSESS_\",\n+          s\"Cannot $doWhat an admin's sessions\")\n+  }\n+\n+}\n+"
        },
        {
          "filename": "appsv/server/talkyard/server/sess/SessionSiteDaoMixin.scala",
          "status": "added",
          "additions": 165,
          "deletions": 0,
          "patch": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2021 Kaj Magnus Lindberg\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as\n+ * published by the Free Software Foundation, either version 3 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package talkyard.server.sess\n+\n+import com.debiki.core._\n+import com.debiki.core.Prelude._\n+import debiki.EdHttp.urlDecodeCookie\n+import debiki.dao.SiteDao\n+import talkyard.server.dao.StaleStuff\n+\n+\n+\n+trait SessionSiteDaoMixin {\n+  self: SiteDao =>\n+\n+\n+  def listPatsSessions(patId: PatId): ImmSeq[TySessionInDbMaybeBad] = {\n+    val sessionsMaybeBad = readTx(_.loadActiveSessions(patId))\n+    SECURITY; COULD // also incl recently ended sessions:\n+    //val recentlyActiveSessions = readTx(_.loadRecentlyEndedSessions(patId, limit = 10)) ?\n+\n+    // Lazy-mark as expired sessions that has just expired.  [lazy_expire_sessions]\n+    val settings = getWholeSiteSettings()\n+    val now = this.now()\n+    val (justExpiredSessions, activeSessions) = sessionsMaybeBad.partition(\n+          _.expiresNow(now, expireIdleAfterMins = settings.expireIdleAfterMins))\n+    for (session <- justExpiredSessions) {\n+      val sessionExpired = session.copy(expiredAt = Some(now))\n+      updateSession(sessionExpired)\n+    }\n+\n+    activeSessions\n+  }\n+\n+  def getSessionByPart1(part1Maybe2Or3: St): Opt[TySessionInDbMaybeBad] = {\n+    readTx(_.loadSession(part1Maybe2Or3 = Some(part1Maybe2Or3)))\n+     // + cache\n+  }\n+\n+\n+  /// If maybeActiveOnly, won't load sessions that have been terminated for sure,\n+  /// but does load sessions that might have expired, but that has not yet been\n+  /// marked as expired in the database.\n+  ///\n+  def getSessionByPart4HttpOnly(part4: St, maybeActiveOnly: Bo): Opt[TySessionInDbMaybeBad] = {\n+    readTx(_.loadSession(part4HttpOnly = Some(part4), maybeActiveOnly = maybeActiveOnly))\n+     // + cache\n+  }\n+\n+\n+  def insertValidSession(session: TySession): U = {\n+    writeTx { (tx, _) =>\n+     tx.insertValidSession(session)\n+     // + cache\n+    }\n+  }\n+\n+\n+  def updateSession(session: TySessionInDbMaybeBad): U = {\n+    writeTx { (tx, _) =>\n+     tx.upsertSession(session)\n+\n+     // + uncache\n+    }\n+  }\n+\n+\n+  def terminateSessionForCurReq(req: play.api.mvc.RequestHeader): U = {\n+    REFACTOR // Move these cookie names \u2014 and their whole file \u2014 to this pkg.\n+    // Thereafter, can remove this import.\n+    import ed.server.security.EdSecurity._\n+\n+    val sidPart12Maybe3FromHeader: Opt[St] = req.headers.get(SessionIdHeaderName)\n+    val sidPart123FromCookie: Opt[St] =\n+          urlDecodeCookie(SessionIdPart123CookieName, req)\n+\n+    val sidPart4FromCookie: Opt[St] =\n+          urlDecodeCookie(SessionIdPart4HttpOnlyCookieName, req)\n+\n+    // Maybe some day some bug can cause the browser to send two different\n+    // session part 1 values. Then we'd better delete both sessions.\n+    sidPart12Maybe3FromHeader foreach { partsInHeader =>\n+      val twoDifferentPart1 = sidPart123FromCookie.exists(!_.startsWith(partsInHeader))\n+      if (twoDifferentPart1) {\n+        AUDIT_LOG // Is this weird? A script might have has tampered with the cookie\n+        // or header?  For now, to catch bugs:\n+        warnDevDie(\"TyE70MWEPG246\")\n+      }\n+      terminateAnySession(\n+            sidPart1Maybe2Or3 = Some(partsInHeader),\n+            sidPart4 = None)\n+    }\n+\n+    terminateAnySession(\n+          sidPart1Maybe2Or3 = sidPart123FromCookie,\n+          sidPart4 = sidPart4FromCookie)\n+  }\n+\n+\n+  private def terminateAnySession(sidPart1Maybe2Or3: Opt[St], sidPart4: Opt[St]): U = {\n+    writeTx { (tx, _) =>\n+      val sessions = tx.loadOneOrTwoSessions(sidPart1Maybe2Or3, part4HttpOnly = sidPart4,\n+            maybeActiveOnly = true)\n+      assert(sessions.forall(_.wasValidJustRecently))  // could remove the filter() below\n+      val terminatedSessions =\n+            sessions.filter(_.wasValidJustRecently)\n+                .map(_.copy(deletedAt = Some(tx.now)))\n+      terminatedSessions foreach tx.upsertSession\n+\n+       // + uncache\n+    }\n+    AUDIT_LOG // 0, 1 or 2 sessions got terminated.\n+  }\n+\n+\n+  /// Returns any sessions that got terminated; isDeleted will be Some(current-time).\n+  /// This might include sessions that expired just moments ago \u2014 they'll\n+  /// be both expiredAt = Some(..) and deletedAt = Some(..).\n+  ///\n+  def terminateSessions(forPatId: PatId, thoseStartedAt: Seq[When] = Nil,\n+          allExceptFor: Opt[When] = None, all: Bo = false,\n+          anyTx: Opt[(SiteTx, StaleStuff)] = None)\n+          : ImmSeq[TySessionInDbMaybeBad] = {\n+\n+    dieIf(all && thoseStartedAt.nonEmpty, \"TyE60MWEPJ22\")\n+    dieIf(all && allExceptFor.isDefined, \"TyE60MWEPJ23\")\n+    dieIf(thoseStartedAt.nonEmpty && allExceptFor.isDefined, \"TyE60MWEPJ24\")\n+\n+    val sessionsMaybeBad = readTxTryReuse(anyTx.map(_._1))(_.loadActiveSessions(forPatId))\n+    val sessionsToEnd = sessionsMaybeBad filter { sess =>\n+      warnDevDieIf(!sess.wasValidJustRecently, \"TyE5MWJY20X\")\n+      all || thoseStartedAt.contains(sess.createdAt) ||\n+            allExceptFor.isSomethingButNot(sess.createdAt)\n+    }\n+\n+    val now = anyTx.map(_._1.now) getOrElse this.now()\n+    val terminatedSessions = sessionsToEnd.map(_.copy(deletedAt = Some(now)))\n+\n+    if (terminatedSessions.nonEmpty) {\n+      writeTxTryReuse(anyTx) { (tx, _) =>\n+        terminatedSessions foreach tx.upsertSession\n+\n+        // + uncache\n+      }\n+    }\n+\n+    terminatedSessions\n+  }\n+\n+}"
        },
        {
          "filename": "client/app-head/head-bundle.ts",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -289,7 +289,7 @@ if (!eds.isInEmbeddedEditor) {\n var debiki = { internal: {}, v0: { util: {}} };\n \n // Talkyard per page load session data (if we avoid cookies). [NOCOOKIES]   rename to  tyd?  see above *@\n-// Maybe store this in Myself instead? Next to Myself.mySidPart1ForJs? [sess_in_me]\n+// Maybe store this in Me instead? Next to Me.mySidPart1? [sess_in_me]\n // And remove typs.\n var typs: PageSession = {\n   xsrfTokenIfNoCookies: _volatileData.xsrfTokenIfNoCookies,"
        },
        {
          "filename": "client/app-more/login/login-dialog.more.ts",
          "status": "modified",
          "additions": 10,
          "deletions": 2,
          "patch": "@@ -167,7 +167,7 @@ const LoginDialog = createClassAndFactory({\n         anyReturnToUrl,\n         preventClose: preventClose || loginReason === LoginReason.AuthnRequiredToRead ||\n             loginReason === LoginReason.LoginToAdministrate,\n-        isLoggedIn: !!getSetCookie('dwCoSid'),\n+        isLoggedIn: store.me.isLoggedIn,\n       });\n   },\n \n@@ -246,6 +246,14 @@ const LoginDialog = createClassAndFactory({\n       anyReturnToUrl: null,\n       isLoggedIn: null,\n     });\n+    /* COULD_OPTIMIZE: Clear these cookies, maybe all authn cookies? [clear_aun_cookies]\n+     * Clear cookies both server side \u2014 and from here too, in case closing the dialog\n+     * without logging in?\n+     * (This close() runs also after the create-user dialog, via:\n+     * closeDialog('CloseAllLoginDialogs'))\n+    getSetCookie('dwCoIsInLoginWindow', null);\n+    getSetCookie('TyCoAvoidCookies', null);\n+     */\n   },\n \n   setChildDialog: function(childDialog) {\n@@ -553,7 +561,7 @@ const LoginDialogContent = createClassAndFactory({\n     if (anySsoUrl) {\n       // Maybe incl username and id in __html_encoded_volatile_json__ ?\n       // Not always done in login window.\n-      const hasSid = getSetCookie('dwCoSid');\n+      const hasSid = me_hasSid();\n       const loggedInButMayNotAccess = !hasSid ? null : r.p({},\n         \"You're logged in but seems you cannot access this part of the site \" +  // I18N\n         \"(if it exists). \" +"
        },
        {
          "filename": "client/app-more/topbar/my-menu.more.ts",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -41,6 +41,7 @@ export const MyMenuContent = createFactory({\n       dialogClassName: 'e_ByeD',\n       tiny: true,\n       body: t.LogOut + '?',\n+      // + \"[x] Log out from all devices\"  \u2014 if there're other sessions as well\n       primaryButtonTitle: t.YesBye,\n       secondaryButonTitle: t.Cancel,\n       onCloseOk: function(whichButton) {"
        },
        {
          "filename": "client/app-more/users/user-preferences.more.ts",
          "status": "modified",
          "additions": 126,
          "deletions": 0,
          "patch": "@@ -32,6 +32,7 @@ import EmailInput = debiki2.util.EmailInput;\n const aboutPathSeg = 'about';\n const notfsPathSeg = 'notifications';\n const privacyPathSeg = 'privacy';\n+const securityPathSeg = 'security';\n const uiPathSeg = 'ui';\n const accountPathSeg = 'account';  // [4JKT28TS]\n \n@@ -44,6 +45,7 @@ export const UserPreferences = createFactory({\n     const prefsPathSlash = pathTo(user) + SlashPrefsSlash;\n     const aboutPath = prefsPathSlash + aboutPathSeg;\n     const privacyPath = prefsPathSlash + privacyPathSeg;\n+    const securityPath = prefsPathSlash + securityPathSeg;\n     const uiPath = prefsPathSlash + uiPathSeg;\n     const emailsLoginsPath = prefsPathSlash + accountPathSeg;\n     const location = this.props.location;\n@@ -70,6 +72,7 @@ export const UserPreferences = createFactory({\n       Route({ path: '(.*)/' + aboutPathSeg, exact: true, render: () => AboutTab(childProps) }),\n       Route({ path: '(.*)/' + notfsPathSeg, exact: true, render: () => NotfPrefsTab(childProps) }),\n       Route({ path: '(.*)/' + privacyPathSeg, exact: true, render: () => PrivacyPrefsTab(childProps) }),\n+      Route({ path: '(.*)/' + securityPathSeg, exact: true, render: () => SecurityPrefsTab(childProps) }),\n       Route({ path: '(.*)/' + accountPathSeg, exact: true, render: (ps) =>\n           user.isGroup\n             ? AccountTabForGroup({ ...childProps, ...ps })\n@@ -95,6 +98,8 @@ export const UserPreferences = createFactory({\n                   to: prefsPathSlash + notfsPathSeg, className: 's_UP_Prf_Nav_NtfsL' }, t.Notifications),\n               isGroupGuestOrBuiltIn ? null : LiNavLink({\n                   to: privacyPath, className: 'e_UP_Prf_Nav_PrivL' }, t.upp.Privacy),\n+              isGroupGuestOrBuiltIn ? null : LiNavLink({\n+                  to: securityPath, className: 'e_UP_Prf_Nav_SecL' }, t.upp.Security),\n               isGuestOrBuiltIn ? null : LiNavLink({\n                   to: emailsLoginsPath, className: 's_UP_Prf_Nav_EmLgL' }, t.upp.Account),\n               !isNormalMember ? null : LiNavLink({\n@@ -785,6 +790,127 @@ const PrivacyPrefsTab = createFactory({\n });\n \n \n+\n+const SecurityPrefsTab = React.createFactory<any>(function(props: {\n+        user: UserInclDetails, store: Store }) {\n+\n+  const store = props.store;\n+  const user = props.user;\n+\n+  const [sessionsOrNull, setSessions] = React.useState<Session[] | N>(null);\n+\n+  // Break out hook? [my_cur_id]\n+  const me = store.me;\n+  const myIdRef = React.useRef(me.id);\n+\n+  React.useEffect(() => {\n+    myIdRef.current = me.id;\n+    listPatsSessions();\n+    return () => myIdRef.current = null;\n+  }, []);//, [me.id, user.id]);\n+\n+  function listPatsSessions() {\n+    // If one is admin, then, `me` can be !== `user`.\n+    Server.listSessions(user.id, (resp: ListSessionsResponse) => {\n+      if (myIdRef.current !== me.id) return;\n+      // Show most recent first.\n+      const sessionsByTime = [...resp.sessions].sort(\n+              function(a,b ) { return b.createdAt - a.createdAt; });\n+      setSessions(sessionsByTime);\n+    });\n+  }\n+\n+  if (!sessionsOrNull)\n+    return r.p({}, t.Loading);\n+\n+  const sessions: Session[] = sessionsOrNull;\n+  let numActive = 0;\n+\n+  const sessionItems = sessions.map((session: Session) => {\n+    if (!session.deletedAt && !session.expiredAt) numActive += 1;\n+    return r.li({ key: session.createdAt },\n+        SessionInfo(session, endSession, me));\n+  });\n+\n+  function endSession(ps: { session?: Session, all?: true }) {\n+    const sessionsStartedAt = ps.session && [ps.session.createdAt];\n+    Server.terminateSessions({ forPatId: user.id, sessionsStartedAt, all: ps.all },\n+            (resp: TerminateSessionsResponse) => {\n+      if (myIdRef.current !== me.id) return;\n+      // Is sorted by time already, see sort(..) above.\n+      const sessionsAfter = arr_replaceMany(sessions,\n+              resp.terminatedSessions, (s: Session) => s.createdAt);\n+      setSessions(sessionsAfter);\n+    });\n+  }\n+\n+  const isMyOnlySession = me.id === user.id && numActive === 1;\n+\n+  const logOutEverywhereBtn = !numActive || isMyOnlySession ? null :\n+      Button({ className: 'c_SessL_EndAllB', onClick: () => endSession({ all: true })},\n+          \"Log out everywhere (but not here)\");   // I18N\n+\n+  return (\n+    r.div({},\n+      // Later: \"You're logged in on these devices:\"\n+      // Or: \"You are logged in on these devices, or were recently:\"\n+      // Or: \"Active or recently active devices:\"  ?\n+      r.h2({}, \"Active sessions:\"),  // I18N\n+      r.ol({ className: 'c_SessL' }, sessionItems),\n+      sessionItems.length ? null : r.p({}, \"None\"), // I18N\n+      logOutEverywhereBtn,\n+      ));\n+});\n+\n+\n+function SessionInfo(session: Session, endSessionFn: (ps: { session: Session }) => V, me: Me) {\n+  const createdAt: St = new Date(session.createdAt).toISOString();\n+  let activeOrEnded: St;\n+\n+  let deletedAt = session.deletedAt;\n+  let expiredAt = session.expiredAt;\n+  if (deletedAt && expiredAt) {\n+    if (deletedAt <= expiredAt) expiredAt = null;\n+    else deletedAt = null;\n+  }\n+\n+  const isCurrent = me.mySidPart1 !== session.part1 ? '' :\n+          \" \u2014 this session, here\";\n+\n+  let terminateBtn: RElm | U;\n+  let activeOrEndedClass = 'c_SessL_Sess-Ended';\n+\n+  if (deletedAt) {\n+    activeOrEnded = \" \u2014 got deleted at \" + new Date(deletedAt).toISOString();\n+  }\n+  else if (expiredAt) {\n+    activeOrEnded = \" \u2014 expired at \" + new Date(expiredAt).toISOString();\n+  }\n+  else {\n+    activeOrEnded = isCurrent ? '' : \" \u2014 currently active\";\n+    activeOrEndedClass = 'c_SessL_Sess-Active';\n+\n+    // Skip logout button for the current session. It's better if one stays logged\n+    // in and can see that the relevant sessions got terminated properly. And\n+    // thereafter click Log Out in one's username menu. (Or?)\n+    terminateBtn = me.mySidPart1 === session.part1 ? null :\n+          Button({ className: 'c_SessL_Sess_EndB',\n+              onClick: () => endSessionFn({ session }) }, \"Log out\");  // I18N\n+  }\n+\n+  let debugJson = null;\n+  // @ifdef DEBUG\n+  debugJson = r.pre({}, JSON.stringify(session, undefined, 3));\n+  // @endif\n+\n+  return r.div({ className: 'c_SessL_Sess ' + activeOrEndedClass },\n+      r.span({}, \"Session started at \" + createdAt + isCurrent + activeOrEnded),\n+      debugJson,\n+      terminateBtn);\n+}\n+\n+\n+\n const AccountTabForGroup = React.createFactory<any>(function(props: { member: Group, store: Store }) {\n   const me: Myself = props.store.me;\n   const group: Group = props.member;"
        },
        {
          "filename": "client/app-slim/ReactActions.ts",
          "status": "modified",
          "additions": 9,
          "deletions": 2,
          "patch": "@@ -81,8 +81,13 @@ export function loadMyself(afterwardsCallback?: () => Vo) {\n   Server.loadMyself((anyMe: Me | NU, stuffForMe?: StuffForMe) => {\n     // @ifdef DEBUG\n     // Might happen if there was no weakSessionId, and also, no cookie.\n-    dieIf(!anyMe, 'TyE4032SMH57');\n+    // Or if our session just got terminated from another device?\n+    // To try to make this happen, see /^sessions/ in tests-map.txt.\n+    dieIf(!anyMe, 'Server.loadMyself() returned me = null [TyE4032SMH57]');\n     // @endif\n+    // Maybe?: if (!anyMe) return;\n+    // Or?: if (!anyMe) logoutClientSideOnly()\n+\n     const newMe = anyMe as Me;\n     if (isInSomeEmbCommentsIframe()) {\n       // Tell the embedded comments or embedded editor iframe that we just logged in,\n@@ -140,13 +145,15 @@ export function newUserAccountCreated() {\n // Together with Server.deleteTempSessId() and Server.rememberTempSession().\n \n \n+/// Not currently in use? But maybe call this one instead of\n+/// Server.logoutServerAndClientSide() drectly?\n export function logout() {\n   Server.logoutServerAndClientSide();\n }\n \n \n export function logoutClientSideOnly(ps: { goTo?: St, skipSend?: Bo } = {}) {\n-  Server.deleteTempSessId();\n+  Server.deleteTempSessId();  // [is_logging_out]\n \n   ReactDispatcher.handleViewAction({\n     actionType: actionTypes.Logout"
        },
        {
          "filename": "client/app-slim/Server.ts",
          "status": "modified",
          "additions": 46,
          "deletions": 8,
          "patch": "@@ -1153,6 +1153,27 @@ export function loginWithOneTimeSecret(oneTimeLoginSecret: string,\n }\n \n \n+/// Returns parts 1 and 2 of any current session id, maybe 3. (Parts 4 and 5 are HttpOnly\n+/// cookies, not accessible here.)\n+///\n+export function getCurSid12Maybe3(): St | N {  // [ts_authn_modl]\n+  const store: Store = debiki2.ReactStore.allData();\n+  const cookieName =\n+          debiki2.store_isFeatFlagOn(store, 'ffUseNewSid') ? 'TyCoSid123' : 'dwCoSid';\n+  let sid = getSetCookie(cookieName);\n+  if (!sid) {\n+    // Cannot use store.me.mySidPart1 \u2014 we might not yet have loaded\n+    // the current user from the server; store.me might be stale.\n+    const typs: PageSession = getMainWin().typs;\n+    // This might not include part 3 (won't, if we're in an embedded comments\n+    // iframe, and didn't login or resume via a popup win directly against the\n+    // server so we could access cookie TyCoSid123, which includes part 3).\n+    sid = typs.weakSessionId;\n+  }\n+  return sid || null;\n+}\n+\n+\n export function rememberTempSession(ps: { weakSessionId: St }) {  // [ts_authn_modl]\n   const onOk = function() {};\n   makeUpdNoCookiesTempSessionIdFn(onOk)(ps);\n@@ -1181,13 +1202,15 @@ function makeUpdNoCookiesTempSessionIdFn<R>(  // [ts_authn_modl]\n \n \n export function deleteTempSessId() {  // [ts_authn_modl]\n+  // Need not delete store.me.mySidPart1 \u2014 we'll reload the page anyway. [is_logging_out]\n   const mainWin = getMainWin();\n   const typs: PageSession = mainWin.typs;\n   delete typs.weakSessionId;\n   delete typs.sessType;\n   try {\n     // Can this throw?\n     getSetCookie('dwCoSid', null);\n+    getSetCookie('TyCoSid123', null);\n   }\n   catch (ex) {\n     // Just in case.\n@@ -1283,10 +1306,9 @@ export function listCompleteUsers(whichUsers, success: (users: UserInclDetailsWi\n type UserAcctRespHandler = (response: UserAccountResponse) => void;\n \n \n-export function loadEmailAddressesAndLoginMethods(userId: UserId, success: UserAcctRespHandler) {\n-  get(`/-/load-email-addrs-login-methods?userId=${userId}`, response => {\n-    success(response);\n-  });\n+export function loadEmailAddressesAndLoginMethods(userId: UserId, onOk: UserAcctRespHandler,\n+          onErr?: (resp: A) => V) {\n+  get(`/-/load-email-addrs-login-methods?userId=${userId}`, onOk, onErr);\n }\n \n \n@@ -1303,8 +1325,9 @@ export function resendEmailAddrVerifEmail(userId: UserId, emailAddress: string)\n   }, { userId, emailAddress });\n }\n \n-export function addEmailAddresses(userId: UserId, emailAddress: string, success: UserAcctRespHandler) {\n-  postJsonSuccess('/-/add-email-address', success, { userId, emailAddress });\n+export function addEmailAddresses(userId: UserId, emailAddress: St, onOk: UserAcctRespHandler,\n+        onErr: (resp: A) => V) {\n+  postJsonSuccess('/-/add-email-address', onOk, onErr, { userId, emailAddress });\n }\n \n \n@@ -1350,8 +1373,9 @@ export function editMember(userId: UserId, doWhat: EditMemberAction, success: ()\n }\n \n \n-export function suspendUser(userId: UserId, numDays: number, reason: string, success: () => void) {\n-  postJsonSuccess('/-/suspend-user', success, {\n+export function suspendUser(userId: UserId, numDays: Nr, reason: St, onOk: () => V,\n+        onErr: (resp: A) => V) {\n+  postJsonSuccess('/-/suspend-user', onOk, onErr, {\n     userId: userId,\n     numDays: numDays,\n     reason: reason\n@@ -1491,6 +1515,20 @@ export function loadMyself(onOk: (me: Me | NU, stuffForMe?: StuffForMe) => Vo) {\n         function (resp: { me?: Me, stuffForMe?: StuffForMe }) {\n     onOk(resp.me, resp.stuffForMe);\n   });\n+    // onErr(() => send 'failedToLogin' to parent frame)  [forget_sid12]\n+}\n+\n+\n+export function listSessions(patId: PatId, onOk: (resp: ListSessionsResponse) => V,\n+        onErr: () => V) {\n+  get(`/-/list-sessions?patId=${patId}`, onOk, onErr);\n+}\n+\n+\n+export function terminateSessions(\n+        ps: { forPatId: PatId, sessionsStartedAt?: WhenMs[], all?: true },\n+        onOk: (response: TerminateSessionsResponse) => V, onErr: () => V) {\n+  postJsonSuccess(`/-/terminate-sessions`, onOk, ps, onErr);\n }\n \n "
        },
        {
          "filename": "client/app-slim/if-in-iframe.ts",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -111,6 +111,7 @@ function onMessage(event) {\n         mainWin.typs.weakSessionId = eventData.weakSessionId;\n         typs.weakSessionId = eventData.weakSessionId;\n         // This sends 'justLoggedIn' to other iframes, so they'll get updated too.\n+        // Reply 'failedToLogin' if login failed  [forget_sid12]\n         ReactActions.loadMyself();\n       }\n       else {\n@@ -124,9 +125,9 @@ function onMessage(event) {\n       // makeUpdNoCookiesTempSessionIdFn() or in the 'case:' just above, lets check:\n       // @ifdef DEBUG\n       const mainWin: MainWin = getMainWin();\n-      if (!mainWin.typs.weakSessionId && !getSetCookie('dwCoSid')) {\n+      if (!me_hasSid()) {\n         logAndDebugDie(`justLoggedIn but not logged in? ` +\n-            `No cookie, no typs.weakSessionId. ` +\n+            `No session cookie, no typs.weakSessionId. ` +\n             `This frame name: ${window.name}, ` +\n             `main frame name: ${mainWin.name}, ` +\n             `this is main frame: ${window === mainWin}, ` +\n@@ -142,6 +143,9 @@ function onMessage(event) {\n       // @endif\n       ReactActions.setNewMe(eventData.user, eventData.stuffForMe);\n       break;\n+    case 'logoutServerAndClientSide':\n+      Server.logoutServerAndClientSide();\n+      break;\n     case 'logoutClientSideOnly':\n       // Sent from the comments iframe one logged out in, to the editor iframe\n       // and other comments iframes."
        },
        {
          "filename": "client/app-slim/login/login-if-needed.ts",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -288,6 +288,7 @@ export function continueAfterLogin(anyReturnToUrl?: string) {\n             \"continue in?  [TyEOPNRGONE]\", { mayClose: false });\n       }\n       else {\n+        // We've remembered any weakSessionId already, see [5028KTDN306].\n         window.opener['debiki'].internal.handleLoginResponse({ status: 'LoginOk' });\n         // Close this popup window \u2014 we'll continue in the main window.\n         close();"
        },
        {
          "filename": "client/app-slim/me-getters.ts",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -30,6 +30,16 @@\n //------------------------------------------------------------------------------\n \n \n+/// I can haz session id?\n+///\n+export function me_hasSid(): Bo {\n+  return !!(\n+        getSetCookie('dwCoSid') ||        // old\n+        getSetCookie('TyCoSid123') ||     // new, better  [btr_sid]\n+        getMainWin().typs.weakSessionId); // if cookies don't work\n+}\n+\n+\n export function me_isAuthenticated(me: Myself): boolean {\n   return me.id && me.id >= MinMemberId;\n }"
        },
        {
          "filename": "client/app-slim/model.ts",
          "status": "modified",
          "additions": 29,
          "deletions": 1,
          "patch": "@@ -35,7 +35,7 @@ interface PageSession  {\n   //\n   // ADD_TO_DOCS\n   //\n-  weakSessionId?: St;\n+  weakSessionId?: St;  // RENAME to sid12Maybe3 ?\n \n   // If the session is for an embedded comments iframe. REMOVE incl in sid instead, somehow.\n   sessType?: SessionType.AutoTokenSiteCustomSso;\n@@ -73,6 +73,10 @@ interface CheckboxEvent {\n   };\n }\n \n+/// Either compares two items (if function.length === 2) or compares\n+/// a field value (if length === 1).\n+type ArrItemIsSameFn<Item> = ((a: Item, b: Item) => Bo) | ((it: Item) => any);\n+\n type ValueOk<T> = {\n   value?: T;\n   isOk?: boolean;\n@@ -480,6 +484,9 @@ interface OwnPageNotfPrefs {  // RENAME to MembersPageNotfPrefs?\n type Myself = Me; // renaming to Me\n interface Me extends OwnPageNotfPrefs {   // + extends Pat?\n   dbgSrc?: string;\n+  // This is not the whole session id \u2014 it's the first 16 chars only [sid_part1];\n+  // the remaining parts have (a lot) more entropy than necessary.\n+  mySidPart1?: St | N;\n   id?: UserId;\n   isStranger?: Bo;\n   // missing?: isGuest?: Bo\n@@ -565,6 +572,17 @@ interface StuffForMe {\n }\n \n \n+interface Session {\n+  patId: PatId;\n+  createdAt: WhenMs;\n+  version: Nr,\n+  startHeaders: { [name: St]: St };\n+  part1: St;\n+  deletedAt?: WhenMs;\n+  expiredAt?: WhenMs;\n+}\n+\n+\n interface GroupPerms {\n   maxUploadBytes?: Nr;\n   allowedUplExts?: St;\n@@ -2398,6 +2416,16 @@ interface LoadPatVvbResponse {\n }\n \n \n+interface ListSessionsResponse {\n+  sessions: Session[];\n+}\n+\n+\n+interface TerminateSessionsResponse {\n+  terminatedSessions: Session[];\n+}\n+\n+\n // COULD also load info about whether the user may apply and approve the edits.\n interface LoadDraftAndTextResponse {\n   pageId: PageId;"
        },
        {
          "filename": "client/app-slim/oop-methods.ts",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -750,8 +750,12 @@ export function settings_selectTopicType(settings: SettingsVisibleClientSide, me\n \n \n export function store_isFeatFlagOn(store: Store, featureFlag: St): Bo {\n-  return _.includes(store.siteFeatureFlags, featureFlag) ||\n+  const offFlag = '0' + featureFlag;\n+  const isOn = _.includes(store.siteFeatureFlags, featureFlag) ||\n          _.includes(store.serverFeatureFlags, featureFlag);\n+  const isOff = _.includes(store.siteFeatureFlags, offFlag) ||\n+         _.includes(store.serverFeatureFlags, offFlag);\n+  return isOn && !isOff;   // [ff_on_off]\n }\n \n "
        },
        {
          "filename": "client/app-slim/prelude.ts",
          "status": "modified",
          "additions": 41,
          "deletions": 1,
          "patch": "@@ -43,7 +43,7 @@ declare function smoothScroll(elem: Element, x: number, y: number,\n     durationMs?: number, onDone?: () => void);\n \n // Defined in client/third-party/get-set-cookie.js.\n-declare function getSetCookie(cookieName: string, value?: string, options?: any): string;\n+declare function getSetCookie(cookieName: St, value?: St, options?: Ay): St | Nl;\n \n \n // backw compat, later, do once per file instead (don't want a global 'r').\n@@ -517,6 +517,7 @@ export function firstDefinedOf(x, y, z?) {\n \n \n /** Like _.groupBy but keeps just one value per key.\n+    RENAME to arr_groupByKeepOne ?\n   */\n export function groupByKeepOne<V>(vs: V[], fn: (v: V) => number): { [key: number]: V } {\n   const manyById: { [key: number]: V[] } = _.groupBy(vs, fn);\n@@ -525,8 +526,47 @@ export function groupByKeepOne<V>(vs: V[], fn: (v: V) => number): { [key: number\n }\n \n \n+export function arr_replaceMany<Item>(\n+        arr: Item[], newerItems: Item[], isSame: ArrItemIsSameFn<Item>): Item[] {\n+  const newArr = [...arr];\n+  arr_replaceManyInPl(newArr, newerItems, isSame);\n+  return newArr;\n+}\n+\n+\n+export function arr_replaceManyInPl<Item>(\n+        arr: Item[], newerItems: Item[], isSame: ArrItemIsSameFn<Item>) {\n+  for (const newerItem of newerItems) {\n+    arr_replaceOneInPl(arr, newerItem, isSame);\n+  }\n+}\n+\n+\n+export function arr_replaceOneInPl<Item>(\n+        arr: Item[], newerItem: Item, isSame: ArrItemIsSameFn<Item>) {\n+  const fnLen = isSame.length;\n+  // @ifdef DEBUG\n+  dieIf(fnLen < 1 || 2 < fnLen, 'TyE60MEPWH32');\n+  // @endif\n+\n+  const getFieldVal = fnLen === 1 ? isSame as ((item: Item) => A) : undefined;\n+  const newerFieldVal = getFieldVal && getFieldVal(newerItem);\n+\n+  const ix = _.findIndex(arr, function(oldItem) {\n+    if (getFieldVal) return getFieldVal(oldItem) === newerFieldVal;\n+    else return isSame(oldItem, newerItem);\n+  });\n+\n+  if (ix >= 0) {\n+    arr[ix] = newerItem;\n+  }\n+}\n+\n+\n // Finds and replaces (in-place) the first item with item.id = replacement.id.\n // Dies, if there's not matching item.\n+// REFACTOR use arr_replaceOneInPl & x => x.id  instead.\n+// + add an IfNotFound.ThenDie/ThenAppend/ThenIgnore param? Default to ThenDie?\n export function replaceById(itemsWithId: any[], replacement) {\n   // @ifdef DEBUG\n   dieIf(isNullOrUndefined(replacement.id), 'EdE4GJTH02');"
        },
        {
          "filename": "client/app-slim/slim-bundle.d.ts",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -189,6 +189,14 @@ declare namespace debiki2 {\n   var createClassAndFactory: any; // don't use \u2014 I'm renaming to createFactory\n   function createFactory<P, S = any>(compSpec: React.ComponentSpec<P, S>): React.Factory<any>;\n \n+  function arr_replaceMany<Item>(arr: Item[],\n+        newerItems: Item[], isSame: ArrItemIsSameFn<Item>): Item[];\n+\n+  function arr_replaceManyInPl<Item>(arr: Item[],\n+        newerItems: Item[], isSame: ArrItemIsSameFn<Item>);\n+\n+  function arr_replaceOneInPl<Item>(arr: Item[],\n+        newerItem: Item, isSame: ArrItemIsSameFn<Item>);\n \n   function replaceById(itemsWithId: any[], replacement);\n   function deleteById(itemsWithId: any[], id);\n@@ -314,6 +322,7 @@ declare namespace debiki2 {\n   function page_isPrivateGroup(pageRole: PageRole): boolean;\n   function pageRole_iconClass(pageRole: PageRole): string;\n \n+  function me_hasSid(): Bo;\n   function me_uiPrefs(me: Myself): UiPrefs;\n   function pp_snoozeLeftMs(me: Myself): number;\n   function member_isBuiltIn(member: Member): boolean;"
        },
        {
          "filename": "client/app-slim/start-page.ts",
          "status": "modified",
          "additions": 40,
          "deletions": 3,
          "patch": "@@ -18,13 +18,15 @@\n /// <reference path=\"prelude.ts\" />\n /// <reference path=\"init-all-react-roots.ts\" />\n /// <reference path=\"link-previews.ts\" />\n+/// <reference path=\"oop-methods.ts\" />\n \n \n const d = { i: debiki.internal };\n \n const logM = debiki2.logM;\n const logE = debiki2.logE;\n \n+\n let pageStarted: undefined | true;\n const scriptLoadDoneCallbacks = [];\n debiki.scriptLoad = {  // RENAME to tyd.afterStarted(...) ?\n@@ -62,16 +64,50 @@ debiki.nowServiceWorkerIsRightVersion = function() {\n const allPostsNotTitleSelector = '.debiki .dw-p:not(.dw-p-ttl)';\n \n \n+\n function handleLoginInOtherBrowserTab() {\n-  const currentUser = debiki2.ReactStore.getMe();\n+  const store: Store = debiki2.ReactStore.allData();\n+  const me: Myself = store.me;\n+\n+  // New style session id:  [btr_sid]\n+  // ------------------------------------------\n+  if (debiki2.store_isFeatFlagOn(store, 'ffUseNewSid')) {\n+    const sidParts123 = debiki2.Server.getCurSid12Maybe3();\n+    const stillTheSameSid = sidParts123\n+          ? me.mySidPart1 && sidParts123.startsWith(me.mySidPart1)\n+          : !me.mySidPart1;\n+    if (!stillTheSameSid) {\n+      if (sidParts123) {\n+        // The human has logged in.\n+        if (me.mySidPart1) {\n+          // The human was already logged in. Then it's good to reload the page so\n+          // stuff related to the previous user, disappears from the browser memory.\n+          location.reload();\n+        }\n+        else {\n+          // The human wasn't logged in. We can load the human's data without page reload.\n+          debiki2.ReactActions.loadMyself();\n+        }\n+      }\n+      else {\n+        // The human was logged in, but has now logged out. (This reloads the\n+        // page, or loads a new page, and forgets all in-mem state.)\n+        debiki2.ReactActions.logoutClientSideOnly();\n+      }\n+    }\n+    return;\n+  }\n+\n+  // Old style session id:\n+  // ------------------------------------------\n   const sessionId = getSetCookie('dwCoSid');\n-  if (currentUser.isLoggedIn) {\n+  if (me.isLoggedIn) {\n     if (sessionId) {\n       // Session id example: (parts: hash, user id, name, login time, random value)\n       // 'Y1pBlH7vY4JW9A.11.Magnus.1316266102779.15gl0p4xf7'\n       const parts = sessionId.split('.');\n       const newUserIdString = parts[1];\n-      if (currentUser.userId !== parseInt(newUserIdString)) {\n+      if (me.id !== parseInt(newUserIdString)) {\n         // We've logged in as another user in another browser tab.\n         debiki2.ReactActions.loadMyself();\n       }\n@@ -94,6 +130,7 @@ function handleLoginInOtherBrowserTab() {\n }\n \n \n+\n function registerEventHandlersFireLoginOut() {\n   // If the user switches browser tab, s/he might logout and login\n   // in another tab. That'd invalidate all xsrf tokens on this page,"
        },
        {
          "filename": "client/app-slim/translations.d.ts",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -668,6 +668,7 @@ interface TalkyardTranslations {\n     DraftsEtc: string;\n     About: string;\n     Privacy: string;\n+    Security: string;\n     Account: string;\n     Interface: string;\n "
        },
        {
          "filename": "client/embedded-comments/blog-comments.ts",
          "status": "modified",
          "additions": 45,
          "deletions": 10,
          "patch": "@@ -221,23 +221,22 @@ mutationObserver.observe(document.body, { subtree: true, childList: true });\n \n \n \n-// We store a weak session in localStorage, if 3rd party cookies disabled.\n-// It's fairly ok to use localStorage in our case, see:\n-//   ../../docs/session-in-local-storage.md\n+// For the user to stay logged in, Ty can store not the whole but parts 1 and 2 of\n+// the session id in localStorage, if 3rd party cookies disabled.\n+// See docs/ty-security.adoc for more about sessions and parts 1, 2, 3, 4 and 5.\n+// [NOCOOKIES] Parts 1 and 2 don't let the user do much more than accessing and\n+// posting blog comments, and moderating blog comments if hen's a moderator\n+// (but won't give access to, for example, the admin area).\n+// Some more things to do: [restrict_sid_part_2_more].  [sid_part_3]\n //\n-// [NOCOOKIES] [weaksid] ADD_TO_DOCS The session is (will be) \"weak\", in\n-// the sense that, even if you're admin, you cannot use it to go to the admin area\n-// and do things there. Then instead you need to login directly to the Talkyard\n-// server, rather than on the embedding site via the iframe \u2014 so an XSS\n-// vulnerability on the embedding site (the blog) cannot give admin access.\n-\n let someStorage: Storage | undefined;\n let tempObjStorage;\n \n // Just *looking* at localStorage throws an exception, if cookies blocked,\n // so need try-catch.\n try {\n   someStorage = localStorage;\n+  window.addEventListener('storage', onLocalStorageChanged);\n }\n catch {\n }\n@@ -264,6 +263,24 @@ const theStorage: Storage = someStorage || {\n } as Storage;\n \n \n+let curSessItemInStorage: St | Nl = null;\n+\n+function onLocalStorageChanged() {\n+  // Maybe we logged out in another browser tab?\n+  /* First fix: [forget_sid12]\n+  const maybeNewSessItem: St | Nl = theStorage.getItem('talkyardSession');\n+  if (curSessItemInStorage !== maybeNewSessItem) {\n+    if (maybeNewSessItem) {\n+      sendToComments(['resumeWeakSession', maybeNewSessItem]);\n+    }\n+    else {\n+      sendToComments(['logoutServerAndClientSide', null]);\n+      sendToEditor(['logoutClientSideOnly', null]);\n+    }\n+    curSessItemInStorage = maybeNewSessItem;\n+  } */\n+}\n+\n \n addEventListener('scroll', messageCommentsIframeNewWinTopSize);\n addEventListener('message', onMessage, false);\n@@ -863,7 +880,11 @@ function onMessage(event) {\n         let sessionStr;\n         try {\n           sessionStr = theStorage.getItem('talkyardSession');\n+          // Skip this hereafter?! [btr_sid] Do afterwards instead, if is now invalid.\n+          // Because otherwise we'd get logged out in other tabs \u2014 they listen to localStorage.\n+          // The iframe can send back a 'failedToLogin' instead?  [forget_sid12]\n           theStorage.removeItem('talkyardSession');  // see above (3548236)\n+          curSessItemInStorage = null;\n         }\n         catch (ex) {\n           logW(`Error getting 'talkyardSession' from theStorage [TyEGETWKSID]`, ex);\n@@ -936,6 +957,16 @@ function onMessage(event) {\n     case 'justLoggedIn':\n       const u = eventData.user || {};\n       logM(`Logged in as ${u.username || u.fullName} in iframe`);\n+      // @ifdef DEBUG\n+      // Here, session id part 3 must not be included \u2014 it must not be seen\n+      // by the embedding website (only by code directly on the Talkyard domain).\n+      // So, the length should be:  SidLengthCharsPart1 + SidLengthCharsPart2 = 16 + 24\n+      // for the new fancy sessions. Whilst the old silly sids include a '.' dot.\n+      if (eventData.weakSessionId && eventData.weakSessionId.length !== 16 + 24\n+            && eventData.weakSessionId.indexOf('.') === -1)\n+        throw Error(`tySid12 should be 16 + 24 = ${16 + 24} chars but is ${\n+                eventData.weakSessionId.length} chars [TyEBADSID12LEN]`);\n+      // @endif\n       if (eventData.rememberEmbSess) try {\n         const item = {\n           pubSiteId: eventData.pubSiteId,\n@@ -960,7 +991,10 @@ function onMessage(event) {\n           // This re-inserts our session (3548236), if we just sent a 'resumeWeakSession'\n           // message to the iframe and then removed it from theStorage  \u2014 because\n           // the comments iframe sends back 'justLoggedIn', after having logged in.\n-          theStorage.setItem('talkyardSession', JSON.stringify(item));\n+          curSessItemInStorage = JSON.stringify(item);\n+          theStorage.setItem('talkyardSession', curSessItemInStorage);\n+\n+          // ! Need a 'failedToLogin' if login failed  [forget_sid12]\n         }\n       }\n       catch (ex) {\n@@ -973,6 +1007,7 @@ function onMessage(event) {\n       logM(`Logged out`);\n       try {\n         theStorage.removeItem('talkyardSession');\n+        curSessItemInStorage = null;\n       }\n       catch (ex) {\n         logW(`Error removing 'talkyardSession' from  theStorage [TyERMWKSID]`, ex);"
        },
        {
          "filename": "client/types-and-const-enums.ts",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -33,12 +33,14 @@\n //\n type U = undefined;\n type Vo = void; // but not 'V' because that's sometimes a 'V'alue template param.\n+type V  = void; // ... hmm but really really not often. Let's use 'Va' for such templ params?\n type Nl = null; // but not 'Nu' because that could be \"Number\".\n type N = null;  // ... hmm I don't think so. One letter U and N for undef & null,\n                 // ... and 2 letters for \"real\" datatypes \u2014 easy to remember?\n                 // \"Nl\" is actually a bit hard to read! (the 'l')\n type Ay = any;  // but not 'An' because that sounds like 'an'. Upd: Skip this. Use 'any',\n                 // should try to long term do away with all 'any' anyway.\n+type A = any;   // Why not A! Let's use 'A'.\n type Bo = boolean;\n type Nr = number;\n type St = string;\n@@ -132,8 +134,6 @@ const enum SessionType {\n   SiteCustomOSaml = 4,\n   SiteCustomSso = 5,\n \n-  ApiSecret =  // instead of SidOk(\"_api_secret_\", ..)\n-\n   EmailSecret = 8,\n   BackupCode = 9,\n "
        },
        {
          "filename": "conf/routes",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -163,6 +163,10 @@ POST  /-/remove-email-address   controllers.UserController.removeUserEmail\n GET   /-/confirm-email-address  controllers.UserController.confirmOneMoreEmailAddress(confirmationEmailId)\n POST  /-/resend-email-addr-verif-email controllers.UserController.resendEmailAddrVerifEmail\n \n+GET   /-/list-sessions          talkyard.server.sess.SessionController.listSessions(patId: Int)\n+POST  /-/terminate-sessions     talkyard.server.sess.SessionController.terminateSessions\n+# Maybe move /-/logout to SessionController?\n+\n GET   /-/unsubscribe            controllers.UnsubscriptionController.showForm(emailId)\n POST  /-/unsubscribe            controllers.UnsubscriptionController.handleForm(emailId)\n GET   /-/unsubscribed           controllers.UnsubscriptionController.showHasBeenUnsubscribed()"
        },
        {
          "filename": "docs/maybe-do-later.txt",
          "status": "modified",
          "additions": 17,
          "deletions": 2,
          "patch": "@@ -92,6 +92,9 @@ Privacy Badger doesn't like transient session cookies, currently.\n So maybe change from csrf Double Submit Cookie, to Encrypted Token Pattern?\n https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#Encrypted_Token_Patternp\n \n+[gdpr]\n+New table: sessions_t, impl fn deletePersonalDataFromOldSessions().  [sess_deleted_ix]\n+\n [pps]\n Rename User to Participant and User to Member.  Participant = Guest or Member, Member = User or Group.\n Rename variables named like \"member\" to \"user\", \"memberOrGroup\" to \"member\", \"user\" to \"participant\"\n@@ -558,8 +561,11 @@ Server side sesison ids, maybe in Redis? So can log ppl out, without having acce\n to their browsers to delete session cookies.\n (Also see [offline-first] above: need two cookies.)\n Include session type (e.g. pwd, oauth, email secret, sso, emb sso) in sid:s,\n-see: SessionType.AutoTokenSiteCustomSso, and: SidOk(\"_api_secret_\".\n-Also see: [weaksid].\n+see: SessionType.AutoTokenSiteCustomSso, and: SidOk(TySession.ApiSecretPart12, ..)\n+Also see: [weaksid]. [which_ws_session]\n+Add [sess_deleted_ix]\n+And [btr_sid].\n+Missing:  [forget_sid12] [restrict_sid_part_2_more] [bump_sid_last_use]\n \n [sess_in_me]\n Store xsrf token and any sid-part-1 in Me, instead of win.typs?\n@@ -867,6 +873,15 @@ About how to write docs:\n Problems that happen only on iOS Safari (and Chrome, but all browsers are basically\n Safari on iOS). When works elsewhere, this might be bugs in iOS Safari.\n \n+[ios_itp]\n+Trigger happy tracking prevention produces problems.\n+Maybe maybe Safari [ios_itp] will sometimes mistake email verification links\n+or SSO url params, for being click trackers \u2014 e.g. Talkyard's\n+#talkyardOneTimeLoginSecret=... hash fragment param. See:\n+https://webkit.org/blog/9521/intelligent-tracking-prevention-2-3/\n+\u2014 then, Safari would delete the Ty session parts 1+2 from localStorage,\n+after a day.\n+https://www.cookiestatus.com/safari/\n \n [default_plugins]\n KaTeX for Maths (VSCode supports KaTeX, and Docusaurus too:"
        },
        {
          "filename": "docs/naming-notes.md",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -4,6 +4,7 @@ Talkyard Naming Notes\n `ttt` means Test the test. That is, some [assertion in a test] that doesn't test\n the real Talkyard code \u2014 instead, it tests the test code. (There's no `tttt`)\n \n+`reidr` means \"Re-Enter Iframe in case you just Debug-Reloaded the page\".\n \n ### People\n "
        },
        {
          "filename": "docs/tests-map.txt",
          "status": "modified",
          "additions": 40,
          "deletions": 0,
          "patch": "@@ -239,6 +239,34 @@ impersonate:\n different users -\n   login, logout, switch user:  almost all tests\n \n+sessions:\n+  list one's active sessions,\n+  terminate one's other sessions:\n+            - d.sessions-logout-elsewhere.4br.ts  TyTESESLGOSELF\n+  staff can terminate others' sessions:\n+            - d.sessions-staff-logout-others.4br  TyTESESLGOOTR\n+  mods cannot terminate admins sessions:\n+            - TESTS_MISSING  TyTESESTERMADM\n+            - d.sessions-staff-logout-others.4br  TyTESESLGOOTR  TyEADMINSESS_\n+  require session part 4,\n+  a stolen embdding storage sid part 1+2 is pretty useless:\n+            - embcom.sessions-emb-sess-cannot-moderate.3br  TyTEECSESS0MOD\n+  require part 4 HttpOnly for admin stuff:\n+            - TESTS_MISSING\n+  require part 4 HttpOnly for non-embedded comments stuff:\n+            - TESTS_MISSING, and partly UNIMPL\n+  part 123 gone, client side offline logout:\n+            - sso-test  TyT4ABKRW0268.TyTESESS123GONE\n+            - TESTS_MISSING could add tests for this specifically\n+  part 123 bad,\n+  part 4 or 5 bad or gone:\n+            - TESTS_MISSING  TyTSESSHALFBAD\n+  sorted by recently active first, on one's user page:\n+            - TESTS_MISSING\n+  session terminated if user suspended or deleted:  [.del_susp_usr]\n+            - TESTS_MISSING\n+\n+\n navigation:\n   from anywhere, to anywhere:\n           - navigation-as-stranger.test.ts  TyT5WKAB024\n@@ -251,6 +279,8 @@ navigation:\n             - tags-basic.2br  TyTE2ETAGSBSC.TyTNAVUSR2PG\n   from user profile posts list to page:\n             - badges-basic.2br  TyTE2EBADGESBSC.TyTNAVUSR2PO\n+  from page to one's active sessions list:\n+            - d.sessions-logout-elsewhere.4br  TyTESESLGOSELF\n \n profile page, user:\n   upload photo:  (8PK2)\n@@ -354,6 +384,8 @@ security:\n             - embcom.comment-counts.2br.cors.test.ts   TyTE2ECOMCOUNTS\n             - embcom.manyframes.comment-counts.2br.cors  TyTE2EMNYFRCOMCNTS\n \n+deleted users:  [.del_susp_usr]\n+            - SEC_TEST_MISSING\n suspended users:\n   gets no email notfs,\n   websocket gets disconnected,\n@@ -1010,6 +1042,9 @@ admin:\n   members tab:\n     really many members:\n           - many-users-mention-list-join-group.2browsers.test.ts   TESTS_MISSING  TyT60295KTDT\n+  terminate someone else's sessions:\n+            - d.sessions-staff-logout-others.4br  TyTESESLGOOTR\n+\n \n moderation,\n approve before,\n@@ -1328,6 +1363,11 @@ live notifications -\n           - promote-demote-by-staff-join-leave-chats.2br.test.ts  TyTE2E5H3GFRVK\n   disconnected from chat, if removed from chat:\n           - SEC_TESTS_MISSING  TyT6P03MRKD\n+  no more WebSocket messages,\n+    if account deleted,\n+    or if suspended,\n+    or session terminated:\n+          - SEC_TESTS_MISSING  TyTE0MOREWSMSG\n   presence:\n             - tags-badges-not-missing.2br  TyTETAGS0MISNG.TyTPRESENCE01\n             - TESTS_MISSING  could add more, also for going offline"
        },
        {
          "filename": "s/impl/tyd-e2e-tests.ts",
          "status": "modified",
          "additions": 14,
          "deletions": 1,
          "patch": "@@ -245,7 +245,7 @@ function runE2eTests(): U | ExitCode | 'TestsCancelled' {\n \n   const skipAlways = ['!UNIMPL', '!-impl.', '!imp-exp-imp-exp-site'];\n   const skipEmbAndAlways = ['!embcom', '!embedded-', '!embforum.', ...skipAlways]\n-  const skip2And3Browsers = ['!.2br', '!.3br'];\n+  const skip2And3Browsers = ['!.2br', '!.3br', '!.4br'];  // and skip 4 as well\n \n \n   // ----- 1 browser\n@@ -293,6 +293,19 @@ function runE2eTests(): U | ExitCode | 'TestsCancelled' {\n   });\n \n \n+  // ----- 4 browsers\n+\n+  // Just these, currently:\n+  // d.sessions-logout-elsewhere.4br  TyTESESLGOSELF\n+  // d.sessions-staff-logout-others.4br  TyTESESLGOOTR\n+\n+  next = ['.4br', ...skipEmbAndAlways];\n+\n+  withSpecsMatching(next, (specs: St[]): ExitCode => {\n+    return runWdioInForeground(specs, '--4browsers');   // UNTESTED\n+  });\n+\n+\n   // ----- 1 browser, embedded comments\n \n   const skip23BrAndUnusualEmb = ['!b3c.', '!gatsby', '!embforum.',"
        },
        {
          "filename": "s/run-e2e-tests.sh",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -310,6 +310,9 @@ function runAllE2eTests {\n   $r s/wdio --only navigation-as-stranger $args\n   # Also:  embedded-comments-navigation-as-guest  further below.\n \n+  $r s/wdio-7 --only d.sessions-logout-elsewhere.4br --cd -i $args\n+  $r s/wdio-7 --only d.sessions-staff-logout-others.4br --cd -i $args\n+\n   $r s/wdio --only hide-unhide-tips.2br $args\n   $r s/wdio-7 --only show-admin-notices.2br --cd -i $args\n \n@@ -647,6 +650,9 @@ function runAllE2eTests {\n   $r s/wdio-7     --only embcom.manyframes.js-api.2br --cd -i $args\n   $r s/wdio-7     --only embcom.manyframes.comment-counts.2br.cors --cd -i $args\n \n+  # Stealing an embedded session id\n+  $r s/wdio-7     --only embcom.sessions-emb-sess-cannot-moderate.3br --cd -i $args\n+\n \n \n   if [ -n \"$http_server_pid\" ]; then"
        },
        {
          "filename": "tests/app/debiki/dao/UserStatsAppSpec.scala",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -123,6 +123,10 @@ class UserStatsAppSpec extends DaoAppSuite() {\n     \"... logs out, last-seen stats get updated\" in {\n       playTimeMillis(1000)\n       dao.logout(member1, bumpLastSeen = true)\n+\n+      // Maybe better end any sessions \u2014 although aren't any.\n+      dao.terminateSessions(forPatId = member1.id, all = true)\n+\n       val stats = loadUserStats(member1.id)(dao)\n       stats mustBe initialStats.copy(lastSeenAt = currentTime)\n     }"
        },
        {
          "filename": "tests/e2e-wdio7/specs/d.sessions-logout-elsewhere.4br.e2e.ts",
          "status": "added",
          "additions": 243,
          "deletions": 0,
          "patch": "@@ -0,0 +1,243 @@\n+/// <reference path=\"../test-types.ts\"/>\n+\n+import * as _ from 'lodash';\n+import assert from '../utils/ty-assert';\n+import server from '../utils/server';\n+import { buildSite } from '../utils/site-builder';\n+import { TyE2eTestBrowser } from '../utils/ty-e2e-test-browser';\n+\n+let brA: TyE2eTestBrowser;\n+let brB: TyE2eTestBrowser;\n+let brC: TyE2eTestBrowser;\n+let brD: TyE2eTestBrowser;\n+let owen: Member;\n+let owen_brA: TyE2eTestBrowser;\n+let owen_brB: TyE2eTestBrowser;\n+let owen_brC: TyE2eTestBrowser;\n+let maja: Member;\n+let maja_brD: TyE2eTestBrowser;\n+\n+let site: IdAddress;\n+let forum: TwoCatsTestForum;\n+\n+\n+\n+describe(`d.sessions-logout-elsewhere.4br  TyTESESLGOSELF`, () => {\n+\n+  it(`Construct site`, async () => {\n+    const builder = buildSite();\n+    forum = builder.addTwoCatsForum({\n+      title: \"Some E2E Test\",\n+      members: ['owen', 'maja'],\n+    });\n+\n+    brA = new TyE2eTestBrowser(wdioBrowserA, 'brA');\n+    brB = new TyE2eTestBrowser(wdioBrowserB, 'brB');\n+    brC = new TyE2eTestBrowser(wdioBrowserC, 'brC');\n+    brD = new TyE2eTestBrowser(wdioBrowserD, 'brD');\n+\n+    owen = forum.members.owen;\n+    owen_brA = brA;\n+    owen_brB = brB;\n+    owen_brC = brC;\n+\n+    maja = forum.members.maja;\n+    maja_brD = brD;\n+\n+    assert.refEq(builder.getSite(), forum.siteData);\n+  });\n+\n+  it(`Import site`, async () => {\n+    site = server.importSiteData(forum.siteData);\n+    server.skipRateLimits(site.id);\n+  });\n+\n+\n+  it(`Owen logs in to the admin area, in browser A ...`, async () => {\n+    await owen_brA.adminArea.settings.login.goHere(site.origin, { loginAs: owen });\n+  });\n+  it(`... and to the forum, in browser B`, async () => {\n+    await owen_brB.go2(site.origin);\n+    await owen_brB.complex.loginWithPasswordViaTopbar(owen);\n+  });\n+  it(`... and C`, async () => {\n+    await owen_brC.go2(site.origin);\n+    await owen_brC.complex.loginWithPasswordViaTopbar(owen);\n+  });\n+\n+\n+  it(`Maja logs in, in browser D`, async () => {\n+    await maja_brD.go2(site.origin);\n+    await maja_brD.complex.loginWithPasswordViaTopbar(maja);\n+  });\n+\n+\n+  it(`Owen starts editing admin settings in browser A, without saving`, async () => {\n+    await owen_brA.adminArea.settings.login.setApproveUsers(true);\n+  });\n+  it(`... and starts composing a new topic in browser B`, async () => {\n+    await owen_brB.forumButtons.clickCreateTopic();\n+    await owen_brB.editor.editTitle(\"Title\");\n+    await owen_brB.editor.editText(\"Text\");\n+  });\n+\n+\n+  // ----- List active sessions\n+\n+  it(`In browser C, Owen navigates to his profile page`, async () => {\n+    await owen_brC.topbar.clickGoToProfile();\n+  });\n+  it(`... the active sessions list`, async () => {\n+    await owen_brC.userProfilePage.tabs.switchToPreferences();\n+    await owen_brC.userProfilePage.preferences.tabs.switchToSecurity();\n+  });\n+\n+  it(`Owen sees 3 active sessions`, async () => {\n+    const counts = await owen_brC.userProfilePage.preferences.security.countSessions();\n+    assert.deepEq(counts, { numActive: 3, numEnded: 0 });\n+  });\n+\n+\n+  // ----- Terminate all one's other sessions\n+\n+  it(`Owen treminates all sessions except for browser C`, async () => {\n+    await owen_brC.userProfilePage.preferences.security.terminateAllSessions();\n+  });\n+\n+  it(`... now he sees one active session, and 2 terminated sessions`, async () => {\n+    // It takes a while for the server to reply, and the UI to update.\n+    await owen_brC.userProfilePage.preferences.security.waitForSessions({\n+            numActive: 1, numEnded: 2 });\n+  });\n+  it(`... after page reload ...`, async () => {\n+    await owen_brC.refresh2();\n+    await owen_brC.userProfilePage.preferences.security.waitForLoaded();\n+  });\n+  it(`... the terminated sessions are gone \u2014 terminated sessions aren't shown`, async () => {\n+    const counts = await owen_brC.userProfilePage.preferences.security.countSessions();\n+    assert.deepEq(counts, { numActive: 1, numEnded: 0 });\n+  });\n+\n+\n+  // ----- Cannot use terminated sessions\n+\n+  it(`In browser A, Owen tries to save the admin settings`, async () => {\n+    await owen_brA.adminArea.settings.clickSaveAll({ willFail: true });\n+  });\n+  it(`... there's an error: Owen isn't logged in as admin (in brA)`, async () => {\n+    await owen_brA.serverErrorDialog.waitForNotLoggedInAsAdminError();\n+  });\n+  it(`... after page refresh, he sees the login dialog (in brA)`, async () => {\n+    await owen_brA.refresh2();\n+    await owen_brA.loginDialog.waitAssertFullScreen();\n+  });\n+\n+  it(`In browser B, Owen tries to save the topic`, async () => {\n+    await owen_brB.editor.save();\n+  });\n+  it(`... there's a not-logged-in error in brB`, async () => {\n+    await owen_brB.serverErrorDialog.waitForNotLoggedInError();\n+  });\n+  it(`... after page refresh, he sees he's logged out in brB`, async () => {\n+    await owen_brB.refresh2();\n+    await owen_brB.topbar.waitUntilLoginButtonVisible();\n+  });\n+\n+\n+  // ----- Login again\n+\n+  it(`Owen logs in again, in browser B`, async () => {\n+    await owen_brB.complex.loginWithPasswordViaTopbar(owen);\n+  });\n+  it(`... and logs in to his sessions list page, in browser A ...`, async () => {\n+    await owen_brA.userProfilePage.preferences.security.goHere(owen.username, { loginAs: owen });\n+  });\n+\n+  it(`There are again 3 active sessions`, async () => {\n+    const counts = await owen_brA.userProfilePage.preferences.security.countSessions();\n+    assert.deepEq(counts, { numActive: 3, numEnded: 0 });\n+  });\n+\n+\n+  // ----- Session sort order\n+\n+  it(`... Owen's brA session is in the middle   TESTS_MISSING\n+              because sessions are sorted by created-at currently`, async () => {\n+  });\n+\n+\n+  // ----- Terminate a specific session\n+\n+  it(`Owen terminates the oldest session, the one in brC`, async () => {\n+    await owen_brA.userProfilePage.preferences.security.terminateOldestSession();\n+  });\n+  it(`... thereafter, 2 active and 1 teminated sessions listed`, async () => {\n+    await owen_brA.userProfilePage.preferences.security.waitForSessions({\n+            numActive: 2, numEnded: 1 });\n+  });\n+  it(`ttt: There're 2 terminate-session buttons: One to terminate \"all\", and one\n+              to terminate the one and only other session`, async () => {\n+    const n = await owen_brA.userProfilePage.preferences.security.numEndSessionButtonsVisible();\n+    assert.eq(n, 2);\n+  });\n+\n+  it(`Now, in brC, Owen tries to switch to the Drafts Etc tab`, async () => {\n+    await owen_brC.userProfilePage.tabs.switchToDraftsEtc({ willFail: true });\n+  });\n+  it(`... there's an error: He's no longer logged in, in that browser`, async () => {\n+    await owen_brC.serverErrorDialog.waitForNotLoggedInError();\n+  });\n+  it(`... after reload ...`, async () => {\n+    await owen_brC.refresh2();\n+  });\n+  it(`... the login button appears`, async () => {\n+    await owen_brC.topbar.waitUntilLoginButtonVisible();\n+  });\n+\n+\n+  // ----- One's other sessions still work\n+\n+  it(`But in brB, Owen is still logged in: He can submit a topic`, async () => {\n+    await owen_brB.complex.createAndSaveTopic({ title: \"Owen's Topic\", body: \"Text.\" });\n+  });\n+  it(`... and after reload ...`, async () => {\n+    await owen_brB.refresh2();\n+  });\n+  it(`... he's still logged in \u2014 sees his username menu`, async () => {\n+    assert.eq(await owen_brB.topbar.getMyUsername(), owen.username);\n+  });\n+\n+\n+  // ----- Other users not affected\n+\n+  it(`Maja is still logged in \u2014 she can post a topic`, async () => {\n+    await maja_brD.complex.createAndSaveTopic({ title: \"Maja's Topic\", body: \"Text.\" });\n+  });\n+  it(`... and reload the page`, async () => {\n+    await maja_brD.refresh2();\n+  });\n+  it(`... she still sees her username \u2014 she's still logged in`, async () => {\n+    await maja_brD.topbar.assertMyUsernameMatches(maja.username);\n+  });\n+\n+\n+  // ----- Session disappears from list, after logging out in other browser\n+\n+  it(`Owen logs out in browser B`, async () => {\n+    await owen_brB.topbar.clickLogout();\n+  });\n+\n+  it(`... and reloads the session list in browser A`, async () => {\n+    await owen_brA.refresh2();\n+  });\n+  it(`... now there's just one active session \u2014 his current session, brA`, async () => {\n+    const counts = await owen_brA.userProfilePage.preferences.security.countSessions();\n+    assert.deepEq(counts, { numActive: 1, numEnded: 0 });\n+  });\n+\n+  it(`There's no end-session button \u2014 cannot end one's current session here`, async () => {\n+    const n = await owen_brA.userProfilePage.preferences.security.numEndSessionButtonsVisible();\n+    assert.eq(n, 0);\n+  });\n+\n+});"
        },
        {
          "filename": "tests/e2e-wdio7/specs/d.sessions-staff-logout-others.4br.e2e.ts",
          "status": "added",
          "additions": 299,
          "deletions": 0,
          "patch": "@@ -0,0 +1,299 @@\n+/// <reference path=\"../test-types.ts\"/>\n+\n+import * as _ from 'lodash';\n+import assert from '../utils/ty-assert';\n+import server from '../utils/server';\n+import { buildSite } from '../utils/site-builder';\n+import { TyE2eTestBrowser } from '../utils/ty-e2e-test-browser';\n+import settings from '../utils/settings';\n+\n+let brA: TyE2eTestBrowser;\n+let brB: TyE2eTestBrowser;\n+let brC: TyE2eTestBrowser;\n+let brD: TyE2eTestBrowser;\n+let owen: Member;\n+let owen_brB: TyE2eTestBrowser;\n+let mons: Member;\n+let mons_brA: TyE2eTestBrowser;\n+let maja: Member;\n+let maja_brB: TyE2eTestBrowser;\n+let mallory: Member;\n+let mallory_brC: TyE2eTestBrowser;\n+let mallory_brD: TyE2eTestBrowser;\n+\n+let site: IdAddress;\n+let forum: TwoCatsTestForum;\n+\n+\n+\n+describe(`d.sessions-staff-logout-others.4br  TyTESESLGOOTR`, () => {\n+\n+  it(`Construct site`, async () => {\n+    const builder = buildSite();\n+    forum = builder.addTwoCatsForum({\n+      title: \"Some E2E Test\",\n+      members: ['owen', 'maja', 'mons', 'mallory'],\n+    });\n+\n+    brA = new TyE2eTestBrowser(wdioBrowserA, 'brA');\n+    brB = new TyE2eTestBrowser(wdioBrowserB, 'brB');\n+    brC = new TyE2eTestBrowser(wdioBrowserC, 'brC');\n+    brD = new TyE2eTestBrowser(wdioBrowserD, 'brD');\n+\n+    owen = forum.members.owen;\n+    owen_brB = brB;\n+\n+    mons = forum.members.mons;\n+    mons_brA = brA;\n+\n+    maja = forum.members.maja;\n+    maja_brB = brB;\n+\n+    mallory = forum.members.mallory;\n+    mallory_brC = brC;\n+    mallory_brD = brD;\n+\n+    assert.refEq(builder.getSite(), forum.siteData);\n+  });\n+\n+  it(`Import site`, async () => {\n+    site = server.importSiteData(forum.siteData);\n+    server.skipRateLimits(site.id);\n+  });\n+\n+\n+  // ----- (Maja and Mallory log in)\n+\n+  it(`Maja logs in, in browser B`, async () => {\n+    await maja_brB.go2(site.origin);\n+    await maja_brB.complex.loginWithPasswordViaTopbar(maja);\n+  });\n+\n+  it(`Mallory too, in browser C ...`, async () => {\n+    await mallory_brC.go2(site.origin);\n+    await mallory_brC.complex.loginWithPasswordViaTopbar(mallory);\n+  });\n+\n+  it(`Mallory logs in in browser D too`, async () => {\n+    await mallory_brD.userProfilePage.preferences.goHere(\n+            mallory.username, { origin: site.origin });\n+    await mallory_brD.complex.loginWithPasswordViaTopbar(mallory);\n+  });\n+  it(`... starts editing his name`, async () => {\n+    await mallory_brD.userProfilePage.preferences.setFullName('Admin of Admins');\n+  });\n+\n+\n+  // ----- Cannot view someone else's sessions (unless one is mod)\n+\n+  it(`Mallory types the URL path to Maja's Security tab, in his other browser, C`, async () => {\n+    await mallory_brC.userProfilePage.preferences.security.goHere(maja);\n+  });\n+\n+  it(`... there's nothing here to see \u2014 cannot view others' sessions`, async () => {\n+    await mallory_brC.userProfilePage.waitForTabsVisible();\n+    assert.not(await mallory_brC.userProfilePage.tabs.isPreferencesTabDisplayed());\n+    assert.not(await mallory_brC.userProfilePage.preferences.tabs.isSecurityTabDisplayed());\n+  });\n+\n+  it(`Mallory returns to the forum topic list instead (in browser C)`, async () => {\n+    await mallory_brC.topbar.clickBack();\n+  });\n+\n+\n+  // ----- A mod terminates a specific session\n+\n+  it(`Moderator Mons goes to Mallory's profile page`, async () => {\n+    await mons_brA.userProfilePage.preferences.goHere(mallory.username, { origin: site.origin });\n+    await mons_brA.complex.loginWithPasswordViaTopbar(mons);\n+  });\n+  it(`... sees the Preferences tab  ttt`, async () => {\n+    await mons_brA.userProfilePage.waitForTabsVisible();\n+    // ttt \u2014 see assert.not(..) above.\n+    assert.that(await mons_brA.userProfilePage.tabs.isPreferencesTabDisplayed());\n+  });\n+  it(`... and the About and Security tab`, async () => {\n+    await mons_brA.userProfilePage.preferences.tabs.waitForAboutTabDisplayed();\n+    // ttt \u2014 see assert.not(..) above.\n+    assert.that(await mons_brA.userProfilePage.preferences.tabs.isSecurityTabDisplayed());\n+  });\n+  it(`... switches to the Security tab`, async () => {\n+    await mons_brA.userProfilePage.preferences.tabs.switchToSecurity();\n+  });\n+\n+  it(`Mons sees Mallory's 2 sessions`, async () => {\n+    const num = await mons_brA.userProfilePage.preferences.security.countSessions();\n+    assert.deepEq(num, { numActive: 2, numEnded: 0 });\n+  });\n+\n+  it(`Mons terminates Mallory's newest session (that's browser D)`, async () => {\n+    await mons_brA.userProfilePage.preferences.security.terminateNewestSession();\n+  });\n+\n+  it(`... afterwards, he sees one active and one terminated session`, async () => {\n+    await mons_brA.userProfilePage.preferences.security.waitForSessions({\n+            numActive: 1, numEnded: 1 });\n+  });\n+\n+\n+  // ----- Cannot use a terminated session\n+\n+  it(`Mallory tries to save his username (in browser D)`, async () => {\n+    await mallory_brD.userProfilePage.preferences.clickSave();\n+  });\n+  it(`... there's an error: Mallory isn't logged in (now in brD)`, async () => {\n+    await mallory_brD.serverErrorDialog.waitForNotLoggedInError();\n+  });\n+  it(`... after page refresh ...`, async () => {\n+    await mallory_brD.refresh2();\n+  });\n+  it(`... he sees the login button (in brD)`, async () => {\n+    await mallory_brD.me.waitUntilKnowsNotLoggedIn();\n+    await mallory_brD.topbar.waitUntilLoginButtonVisible();  // ttt\n+  });\n+\n+  it(`In browser C, Mallory is still logged in \u2014 he posts a new topic`, async () => {\n+    await mallory_brC.complex.createAndSaveTopic({\n+          title: \"Mallory's Place\", body: \"This is my palace, I, the Admin of Admins\" });\n+  });\n+\n+\n+  // ----- (Logging in again)\n+\n+  it(`Mallory logs in again in browser D`, async () => {\n+    await mallory_brD.complex.loginWithPasswordViaTopbar(mallory);\n+  });\n+\n+\n+  // ----- A mod terminates all a user's sessions\n+\n+  it(`Mons refreshes the sessions list`, async () => {\n+    await mons_brA.refresh2();\n+  });\n+\n+  it(`... sees Mallory is back, two active sessions`, async () => {\n+    const num = await mons_brA.userProfilePage.preferences.security.countSessions();\n+    assert.deepEq(num, { numActive: 2, numEnded: 0 });\n+  });\n+\n+  it(`... there're terminate buttons for all sessions, plus an all-in-one-click`, async () => {\n+    const n = await mons_brA.userProfilePage.preferences.security.numEndSessionButtonsVisible();\n+    assert.eq(n, 2 + 1);\n+  });\n+\n+  it(`Mons terminates all Mallory's sessions`, async () => {\n+    await mons_brA.userProfilePage.preferences.security.terminateAllSessions();\n+  });\n+\n+  it(`... afterwards, no more active sessions, 2 terminated`, async () => {\n+    await mons_brA.userProfilePage.preferences.security.waitForSessions({\n+            numActive: 0, numEnded: 2 });\n+  });\n+\n+  it(`... no more terminate buttons`, async () => {\n+    const n = await mons_brA.userProfilePage.preferences.security.numEndSessionButtonsVisible();\n+    assert.eq(n, 0);\n+  });\n+\n+\n+  // ----- Cannot use the terminated sessions\n+\n+  it(`Mallory tries to reply to and agree with himself (in brC)`, async () => {\n+    await mallory_brC.topic.clickReplyToOrigPost();\n+  });\n+  it(`... but there's a not-logged-in error`, async () => {\n+    await mallory_brC.serverErrorDialog.waitForNotLoggedInError();\n+  });\n+  it(`... after page refresh ...`, async () => {\n+    await mallory_brC.refresh2();\n+  });\n+  it(`... he sees he's logged out, sees the login button`, async () => {\n+    await mallory_brC.me.waitUntilKnowsNotLoggedIn();\n+    await mallory_brC.topbar.waitUntilLoginButtonVisible();  // ttt\n+  });\n+\n+  it(`He's logged out in the other browser, brD, too`, async () => {\n+    await mallory_brD.refresh2();\n+    await mallory_brD.me.waitUntilKnowsNotLoggedIn();\n+  });\n+\n+\n+  // ----- Other users not affected\n+\n+  it(`Maja is still logged in: She can submit a topic`, async () => {\n+    await maja_brB.complex.createAndSaveTopic({ title: \"Important about cream\",\n+            body: \"Is milk cream the healthiest dinner, with or without sugar\" });\n+  });\n+\n+  it(`... and after reload ...`, async () => {\n+    await maja_brB.refresh2();\n+  });\n+\n+  it(`... she's still logged in \u2014 sees her username menu`, async () => {\n+    assert.eq(await maja_brB.topbar.getMyUsername(), maja.username);\n+  });\n+\n+\n+  // ----- Mods cannot terminate admins' sessions\n+\n+  it(`Owen logs in`, async () => {\n+    await maja_brB.topbar.clickLogout();\n+    await owen_brB.complex.loginWithPasswordViaTopbar(owen);\n+  });\n+\n+  it(`Mons goes to Owen's profile page, the Preferences tab`, async () => {\n+    await mons_brA.userProfilePage.preferences.goHere(owen.username);\n+  });\n+\n+  it(`... sees the About tab to the left ...`, async () => {\n+    await mons_brA.userProfilePage.preferences.tabs.waitForAboutTabDisplayed();\n+  });\n+  it(`... but there's no Security tab! Cannot view admin's sessions  UNIMPL TESTS_MISSING TyTESESTERMADM`, async () => {\n+    // hmm there is, but it won't work.\n+    //assert.not(await mons_brA.userProfilePage.preferences.tabs.isSecurityTabDisplayed());\n+  });\n+\n+  it(`Mons instead types the URL path to Owen's Security tab`, async () => {\n+    await mons_brA.userProfilePage.preferences.security.goHere(owen);\n+  });\n+  it(`... there's an error: he's not allowed to view an admin's sessions`, async () => {\n+    await mons_brA.serverErrorDialog.waitAndAssertTextMatches('TyEADMINSESS_');\n+    await mons_brA.serverErrorDialog.close();\n+  });\n+\n+\n+  // ----- Admins can terminate mods' sessions\n+\n+  it(`Owen jumps to Mon's Security tab`, async () => {\n+    await owen_brB.userProfilePage.preferences.security.goHere(mons);\n+  });\n+\n+  it(`... logs Mons out`, async () => {\n+    await owen_brB.userProfilePage.preferences.security.terminateAllSessions();\n+  });\n+\n+  it(`... now there's 1 terminated session`, async () => {\n+    await owen_brB.userProfilePage.preferences.security.waitForSessions({\n+            numActive: 0, numEnded: 1 });\n+  });\n+\n+\n+  // ----- Session won't work afterwards\n+\n+  it(`Mons tries to view invites Owen has sent`, async () => {\n+    await mons_brA.userProfilePage.switchToInvites({ willFail: true });\n+  });\n+  it(`... but there's a not-logged-in error`, async () => {\n+    await mons_brA.serverErrorDialog.waitForNotLoggedInError();\n+  });\n+  it(`... Mons reloads the page ...`, async () => {\n+    await mons_brA.refresh2();\n+  });\n+  it(`... Mons sees he's logged out, sees the login button`, async () => {\n+    await mons_brA.me.waitUntilKnowsNotLoggedIn();\n+    await mons_brA.topbar.waitUntilLoginButtonVisible();  // ttt\n+  });\n+  \n+\n+});\n+"
        },
        {
          "filename": "tests/e2e-wdio7/specs/embcom.expimpjson.import-tests-impl.ts",
          "status": "modified",
          "additions": 8,
          "deletions": 2,
          "patch": "@@ -215,9 +215,15 @@ function constructEmbCommentsImportTest(testName: string, variants: {\n         await owensBrowser.waitForExist('.e_RstrDne');\n       });\n \n-      it(`Owen remains logged in?  Or needs to login again?`, async () => {\n+      it(`Owen reloads the page, as per the instructions ...`, async () => {\n         await owensBrowser.refresh();\n-        // Hmm, currently:\n+      });\n+\n+      it(`... needs to log in again \u2014 sessions_t curently not exported`, async () => {\n+        await owensBrowser.loginDialog.loginWithPassword(owen);\n+      });\n+\n+      it(`... he's Owen again`, async () => {\n         await owensBrowser.topbar.assertMyUsernameMatches(owen.username);\n       });\n     }"
        },
        {
          "filename": "tests/e2e-wdio7/specs/embcom.sessions-emb-sess-cannot-moderate.3br.e2e.ts",
          "status": "added",
          "additions": 332,
          "deletions": 0,
          "patch": "@@ -0,0 +1,332 @@\n+/// <reference path=\"../test-types.ts\"/>\n+\n+import * as _ from 'lodash';\n+import assert from '../utils/ty-assert';\n+import * as fs from 'fs';\n+import server from '../utils/server';\n+import * as utils from '../utils/utils';\n+import { buildSite } from '../utils/site-builder';\n+import { TyE2eTestBrowser } from '../utils/ty-e2e-test-browser';\n+import { logMessage, j2s, logBoring } from '../utils/log-and-die';\n+import c from '../test-constants';\n+import { IsWhere } from '../test-types';\n+\n+let brA: TyE2eTestBrowser;\n+let brB: TyE2eTestBrowser;\n+let brC: TyE2eTestBrowser;\n+let owen: Member;\n+let owen_brA: TyE2eTestBrowser;\n+let alice: Member;\n+let alice_brC: TyE2eTestBrowser;\n+let mons: Member;\n+let mons_brA: TyE2eTestBrowser;\n+let maja: Member;\n+let maja_brA: TyE2eTestBrowser;\n+let mallory: Member;\n+let mallory_brB: TyE2eTestBrowser;\n+\n+// Try to remember to update, if adding more users?\n+const majasUserId = 104;\n+\n+const weakSidErrCode = 'TyEWEAKSID_';  // move to test constants?\n+\n+const localHostname = 'comments-for-e2e-test-stealembs-localhost-8080';\n+const embeddingOrigin = 'http://e2e-test-stealembs.localhost:8080';\n+let embeddingPageSlug = 'emb-sess-stealer.html';\n+let embeddingPageUrl = embeddingOrigin + '/' + embeddingPageSlug;\n+\n+let site: IdAddress;\n+let forum: TwoCatsTestForum;\n+\n+let monsLocalStorageSessionJsonSt = '';\n+\n+let stolenSidPart1And2WasMons = '';\n+\n+let stolenSidPart1OnlyWasOwens = '';\n+let stolenSidPart1And2WasOwens = '';\n+\n+\n+describe(`embcom.sessions-emb-sess-cannot-moderate.3br  TyTEECSESS0MOD`, () => {\n+\n+  it(`Construct site`, async () => {\n+    const builder = buildSite();\n+    forum = builder.addTwoCatsForum({\n+      title: \"Emb Comments Sessions Cannot Moderate\",\n+      members: ['owen', 'alice', 'mons', 'maja', 'mallory'],\n+    });\n+\n+    builder.getSite().meta.localHostname = localHostname;\n+    builder.getSite().settings.allowEmbeddingFrom = embeddingOrigin;\n+\n+    brA = new TyE2eTestBrowser(wdioBrowserA, 'brA');\n+    brB = new TyE2eTestBrowser(wdioBrowserB, 'brB');\n+    brC = new TyE2eTestBrowser(wdioBrowserC, 'brC');\n+\n+    owen = forum.members.owen;\n+    owen_brA = brA;\n+\n+    mons = forum.members.mons;\n+    mons_brA = brA;\n+\n+    maja = forum.members.maja;\n+    maja_brA = brA;\n+\n+    mallory = forum.members.mallory;\n+    mallory_brB = brB;\n+\n+    alice = forum.members.alice;\n+    alice_brC = brC;\n+\n+    assert.refEq(builder.getSite(), forum.siteData);\n+  });\n+\n+  it(`Import site`, async () => {\n+    site = server.importSiteData(forum.siteData);\n+    server.skipRateLimits(site.id);\n+  });\n+\n+\n+  it(`Create embedding pages`, () => {\n+    const dir = 'target';\n+    fs.writeFileSync(`${dir}/${embeddingPageSlug}`, makeHtml('aaa', '#800'));\n+    function makeHtml(pageName: St, bgColor: St): St {\n+      return utils.makeEmbeddedCommentsHtml({\n+              pageName, discussionId: '', localHostname, bgColor});\n+    }\n+  });\n+\n+\n+  it(`Mons goes to a dangerous embedding page (in browser A)\n+            with an xss attack that lets Mallory steal session part 1 and 2`, async () => {\n+    await mons_brA.go2(embeddingPageUrl);\n+  });\n+\n+  it(`... Mons logs in`, async () => {\n+    await mons_brA.complex.loginIfNeededViaMetabar(mons);\n+  });\n+\n+  it(`Mallory steals the session via the xss attack`, async () => {\n+    monsLocalStorageSessionJsonSt = await mons_brA.execute(function() {\n+      return localStorage.getItem('talkyardSession');\n+    });\n+\n+    stolenSidPart1And2WasMons = JSON.parse(monsLocalStorageSessionJsonSt).weakSessionId;\n+\n+    logMessage(`Mallory stole Mons' session: \"${monsLocalStorageSessionJsonSt}\",\n+        part 1 + 2: \"${stolenSidPart1And2WasMons}\"`);\n+  });\n+\n+\n+  it(`Mallory goes to the embedding page, in his own browser B`, async () => {\n+    await mallory_brB.go2(embeddingPageUrl);\n+  });\n+\n+  it(`... puts the stolen session in localStorage`, async () => {\n+    await mallory_brB.execute(function(s) {\n+      localStorage.setItem('talkyardSession', s);\n+    }, monsLocalStorageSessionJsonSt);\n+  });\n+\n+  it(`... reloads`, async () => {\n+    await mallory_brB.refresh2();\n+  });\n+\n+  it(`... now Mallory is logged in as Mons \u2014 but with session id parts 1+2 only`, async () => {\n+    await mallory_brB.switchToEmbeddedCommentsIrame();\n+    assert.eq(await mallory_brB.metabar.getMyUsernameInclAt(), '@' + mons.username);\n+  });\n+\n+  it(`Bad 1, will work: Mallory posts a comment`, async () => {\n+    await mallory_brB.complex.replyToEmbeddingBlogPost(\n+            \"Hi I'm Mons no I'm not yes_no_yes_you_guess\");\n+  });\n+\n+  let resp;\n+\n+  it(`Bad 2, won't work: Mallory tries to suspend Maja`, async () => {\n+    await mallory_brB.switchToEmbCommentsIframeIfNeeded(); // reidr\n+    resp = await mallory_brB.hackServer.suspendUser(majasUserId);\n+  });\n+  it(`Bad 2: ... the server refuses`, async () => {\n+    assert.not(resp.serverSaysOk);  // ttt\n+    assert.that(resp.serverSaysError);\n+  });\n+  it(`Bad 2: ... there's an error dialog`, async () => {\n+    await mallory_brB.serverErrorDialog.waitAndAssertTextMatches(weakSidErrCode);\n+    await mallory_brB.serverErrorDialog.close();\n+  });\n+\n+  it(`Bad 3: Mallory then tries to add his own email addr to Mon's account`, async () => {\n+    await mallory_brB.switchToEmbCommentsIframeIfNeeded();  // reidr\n+    resp = await mallory_brB.hackServer.addEmailAddresses(\"mallory@x.co\");\n+  });\n+  it(`Bad 3: ... the server refuses`, async () => {\n+    assert.not(resp.serverSaysOk);  // ttt\n+    assert.that(resp.serverSaysError);\n+  });\n+  it(`Bad 3: ... there's an error dialog`, async () => {\n+    await mallory_brB.serverErrorDialog.waitAndAssertTextMatches(weakSidErrCode);\n+    await mallory_brB.serverErrorDialog.close();\n+  });\n+\n+\n+  it(`Bad 4: Mallory tries to list Mons' email addresses`, async () => {\n+    await mallory_brB.switchToEmbCommentsIframeIfNeeded();  // reidr\n+    resp = await mallory_brB.hackServer.loadEmailAddressesAndLoginMethods();\n+  });\n+  it(`Bad 4: ... the server refuses`, async () => {\n+    assert.not(resp.serverSaysOk);  // ttt\n+    assert.that(resp.serverSaysError);\n+  });\n+  it(`Bad 4: ... there's another error dialog`, async () => {\n+    await mallory_brB.serverErrorDialog.waitAndAssertTextMatches(weakSidErrCode);\n+    await mallory_brB.serverErrorDialog.close();\n+  });\n+\n+\n+  it(`Good 4: Mons also cannot list his email addresses from inside the iframe`, async () => {\n+    await mons_brA.switchToEmbCommentsIframeIfNeeded();  // reidr\n+    resp = await mons_brA.hackServer.loadEmailAddressesAndLoginMethods();\n+  });\n+  it(`Good 4: ... the server says no to Mons too`, async () => {\n+    assert.not(resp.serverSaysOk);  // ttt\n+    assert.that(resp.serverSaysError);\n+  });\n+  it(`Good 4: ... Mons also gets an error dialog`, async () => {\n+    await mons_brA.serverErrorDialog.waitAndAssertTextMatches(weakSidErrCode);\n+    await mons_brA.serverErrorDialog.close();\n+  });\n+\n+\n+  /*\n+  it(`Bad 5: Mallory tries to download Mons' personal data  TESTS_MISSING`, async () => {\n+    await mallory_brB.switchToEmbCommentsIframeIfNeeded();  // reidr\n+    resp = await mallory_brB.hackServer.  ?? ();\n+  });\n+  it(`Bad 5: ... the server refuses`, async () => {\n+    assert.not(resp.serverSaysOk);  // ttt\n+    assert.that(resp.serverSaysError);\n+  });\n+  it(`Bad 5: ... there's another error dialog`, async () => {\n+    await mallory_brB.serverErrorDialog.waitAndAssertTextMatches(weakSidErrCode);\n+    await mallory_brB.serverErrorDialog.close();\n+  });\n+  */\n+\n+  let monsUserId: Nr | U;\n+\n+  it(`Mallory remembers Mons' user id`, async () => {\n+    monsUserId = await mallory_brB.hackServer.getMyUserId();\n+    logBoring(`Mons' user id is: ${monsUserId}`);\n+  });\n+\n+\n+\n+  it(`Mallory click-opens Mons' profile in a new tab`, async () => {\n+    await mallory_brB.metabar.openMyProfilePageInNewTab();\n+  });\n+\n+  it(`... but in the new tab, he's not logged in \u2014 cookies missing`, async () => {\n+    await mallory_brB.swithToOtherTabOrWindow();\n+    await mallory_brB.me.waitUntilKnowsNotLoggedIn();\n+  });\n+\n+\n+  it(`Mons, though, can click his name ...`, async () => {\n+    await mons_brA.switchToEmbCommentsIframeIfNeeded();\n+    await mons_brA.metabar.openMyProfilePageInNewTab();\n+  });\n+\n+  it(`... and in the new tab, he *is* logged in`, async () => {\n+    await mons_brA.swithToOtherTabOrWindow();\n+    await mons_brA.me.waitUntilLoggedIn();\n+    await mons_brA.topbar.assertMyUsernameMatches(mons.username);\n+  });\n+\n+  it(`Mons checks his email addresses`, async () => {\n+    await mons_brA.userProfilePage.tabs.switchToPreferences();\n+    await mons_brA.userProfilePage.preferences.tabs.switchToAccount();\n+  });\n+\n+  it(`... no new address has been added`, async () => {\n+    const adrs: St[] =\n+            await mons_brA.userProfilePage.preferences.emailsLogins.getAllEmailAddresses();\n+    assert.deepEq(adrs, [mons.emailAddress]);\n+  });\n+\n+\n+  it(`Mallory uses the stolen session parts 1+2, in the new tab`, async () => {\n+    await mallory_brB.hackServer.setSidPart12ViaJs(stolenSidPart1And2WasMons, { inCookie: true });\n+  });\n+\n+  it(`... now Mallory has a cookie for session parts 1+2`, async () => {\n+    const sids = await mallory_brB.hackServer.getSids();\n+    logMessage(`getSids() says: ${j2s(sids)}`);\n+    assert.greaterThan(sids.sidCookiePart123.length, 30);\n+  });\n+\n+  it(`Mallory reloads, tries to use the parts 1+2 cookie`, async () => {\n+    await mallory_brB.refresh2({ isWhere: IsWhere.External });\n+  });\n+  it(`... but there's an error: SID part 3 missing`, async () => {\n+    const source = await mallory_brB.getPageSource();\n+    assert.includes(source, weakSidErrCode);\n+  });\n+\n+\n+  let monsDataUrl: St | U;\n+  let monsContentUrl: St | U;\n+\n+  it(`Mallory constructs links to Mons' personal data and Mons' posts`, async () => {\n+    monsDataUrl = mallory_brB.user.genDownloadPersonalDataUrl(monsUserId);\n+    monsContentUrl = mallory_brB.user.genDownloadPersonalContentUrl(monsUserId);\n+  });\n+\n+  it(`Mallory then tries to fetch Mons' personal data`, async () => {\n+    await mallory_brB.go2(monsDataUrl, { willBeWhere: IsWhere.External });\n+  });\n+  it(`... this not allowed \u2014 session id part 3 missing`, async () => {\n+    const source = await mallory_brB.getPageSource();\n+    assert.includes(source, weakSidErrCode);\n+  });\n+\n+  it(`Mons, though, can download his data \u2014 he has SID part 3 HttpOnly`, async () => {\n+    await mons_brA.go2(monsDataUrl, { willBeWhere: IsWhere.External });\n+  });\n+  it(`... his name and emai (among other things) are in the JSON`, async () => {\n+    const source = await mons_brA.getPageSource();\n+    assert.includes(source, mons.username);\n+    assert.includes(source, mons.emailAddress);\n+    assert.excludes(source, weakSidErrCode);\n+  });\n+\n+\n+  it(`Mallory tries to fetch Mon's posts`, async () => {\n+    await mallory_brB.go2(monsContentUrl, { willBeWhere: IsWhere.External });\n+  });\n+  it(`... also not allowed \u2014 session id part 3 missing`, async () => {\n+    const source = await mallory_brB.getPageSource();\n+    assert.includes(source, weakSidErrCode);\n+  });\n+\n+  it(`Mons can download his posts \u2014 he has SID part 3 HttpOnly`, async () => {\n+    await mons_brA.go2(monsContentUrl, { willBeWhere: IsWhere.External });\n+  });\n+  it(`... Mallory's post, made with the stolen SID part 1+2, is in the JSON`, async () => {\n+    const source = await mons_brA.getPageSource();\n+    assert.includes(source, 'yes_no_yes_you_guess');\n+    assert.excludes(source, weakSidErrCode);\n+  });\n+\n+\n+  /* Maybe?\n+  it(`... but when Mallory tries to use the sid, the server clears all session cookies\n+            \u2014 it notices that part 3, HttpOnly, is missing`, async () => {\n+  });\n+\n+  it(`The server also ends the session \u2014 since something is amiss`, async () => {\n+  });\n+  */\n+\n+});\n+"
        },
        {
          "filename": "tests/e2e-wdio7/test-types.ts",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -19,6 +19,7 @@ declare global {\n   const wdioBrowserA: WebdriverIOAsync.MultiRemoteBrowser;\n   const wdioBrowserB: WebdriverIOAsync.MultiRemoteBrowser | U;\n   const wdioBrowserC: WebdriverIOAsync.MultiRemoteBrowser | U;\n+  const wdioBrowserD: WebdriverIOAsync.MultiRemoteBrowser | U;\n \n   type Sel = St // selector\n   type SelOrEl = St | WebdriverIO.Element;\n@@ -32,7 +33,7 @@ export const enum IsWhere {\n \n   EmbFirst = 3,\n   EmbeddingPage = 3,\n-  EmbCommentsIframe = 4,\n+  EmbCommentsIframe = 4,  // hmm could add an enum value for EmbSessionIframe\n   EmbEditorIframe = 5,\n   EmbLast = 5,\n "
        },
        {
          "filename": "tests/e2e-wdio7/test-types2.ts",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -806,6 +806,16 @@ interface EmailMatchResult {\n }\n \n \n+export type ServerSays = ServerSaysOk | ServerSaysError;\n+\n+export interface ServerSaysOk {\n+  serverSaysOk: A;\n+}\n+\n+export interface  ServerSaysError {\n+  serverSaysError: A;\n+}\n+\n // Right now, constraints like >= 1 aren't supported in Typescript, but this works, and, in test\n // cases, probably won't ever need larger numbers?\n type IntAtLeastOne = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19;"
        },
        {
          "filename": "tests/e2e-wdio7/utils/settings-exp-def.ts",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -96,6 +96,12 @@ if (args['2br'] || args['2browsers']) {\n if (args['3br'] || args['3browsers']) {\n   settings.numBrowsers = 3;\n }\n+if (args['4br'] || args['4browsers']) {\n+  settings.numBrowsers = 4;\n+}\n+if (args['5br'] || args['5browsers'] || args['6br'] || args['6browsers']) {\n+  die(`E2e tests with 5 or 6 browsers isn't supported. [TyE2MNYBROWSRS]`);\n+}\n \n if (args.cd || args.chromedrier) {\n   settings.useChromedriver = true;"
        },
        {
          "filename": "tests/e2e-wdio7/utils/ty-e2e-test-browser.ts",
          "status": "modified",
          "additions": 308,
          "deletions": 13,
          "patch": "@@ -1,5 +1,6 @@\n import * as _ from 'lodash';\n import { IsWhere, isWhere_isInIframe } from '../test-types';\n+import { ServerSays } from '../test-types2';\n import { SiteType, NewSiteOwnerType } from '../test-constants';\n \n \n@@ -130,6 +131,16 @@ interface WaitAndClickPs extends WaitPs {\n type WaitForClickableResult = 'Clickable' | 'NotClickable';\n type ClickResult = 'Clicked' | 'CouldNotClick';\n \n+interface SidFieldsParts {\n+  sidFieldParts12Maybe3?: St;\n+}\n+\n+interface SidParts extends SidFieldsParts {\n+  sidCookiePart123?: St;\n+  sidCookiePart4?: St;\n+  sidCookiePart5?: St;\n+}\n+\n \n function isBlank(x: string): boolean {\n   return _.isEmpty(x) || !x.trim();\n@@ -267,7 +278,8 @@ export class TyE2eTestBrowser {\n   #br: WebdriverIOAsync.Browser;\n   #name: St;\n \n-  constructor(aWdioBrowser: WebdriverIOAsync.Browser, name: 'brA' | 'brB' | 'brC' | 'brAll') {\n+  constructor(aWdioBrowser: WebdriverIOAsync.Browser,\n+          name: 'brA' | 'brB' | 'brC' | 'brD' | 'brAll') {\n     dieIf(!aWdioBrowser?.getPageSource,\n         `Error creating Wdio browser '${name}', this is not a browser: ${\n                 JSON.stringify(aWdioBrowser)}  [TyE2E7J02SAD35]`\n@@ -410,7 +422,7 @@ export class TyE2eTestBrowser {\n       return await this.#br.execute.apply(this.#br, arguments);\n     }\n \n-    async executeAsync<T>(script: ((...args: any[]) => T), ...args: any[]): Pr<T> {\n+    async executeAsync<T>(script: ((...args: any[]) => V), ...args: any[]): Pr<T> {\n       return await this.#br.executeAsync.apply(this.#br, arguments);\n     }\n \n@@ -768,6 +780,16 @@ export class TyE2eTestBrowser {\n       },\n     }\n \n+    user = {\n+      genDownloadPersonalDataUrl: (userId: PatId): St => {\n+        return '/-/download-personal-data?userId=' + userId;\n+      },\n+\n+      genDownloadPersonalContentUrl: (userId: PatId): St => {\n+        return '/-/download-my-content?authorId=' + userId;\n+      },\n+    }\n+\n \n \n     newSite = {\n@@ -1189,7 +1211,8 @@ export class TyE2eTestBrowser {\n \n \n     async switchToEmbeddedCommentsIrame(ps: {\n-            waitForContent?: false, discId?: St, theresOnlyOne?: true } = {}) {\n+            waitForContent?: false, discId?: St, theresOnlyOne?: true,\n+            theSessionIdIframe?: true } = {}) {\n       if (ps.discId) {\n         this.useCommentsIframe({ discussionId: ps.discId });\n       }\n@@ -1200,7 +1223,10 @@ export class TyE2eTestBrowser {\n       // Let's wait for the editor iframe, so Reply buttons etc will work.\n       await this.waitForExist('iframe#ed-embedded-editor');\n       let commentsIframeSelector = '';\n-      if (this.#useCommentsIframe?.discussionId) {\n+      if (ps.theSessionIdIframe) {\n+        commentsIframeSelector = 'iframe#talkyard-session';\n+      }\n+      else if (this.#useCommentsIframe?.discussionId) {\n         commentsIframeSelector =\n                 `.talkyard-comments[data-discussion-id=\"${\n                         this.#useCommentsIframe.discussionId}\"] iframe`;\n@@ -1732,8 +1758,8 @@ export class TyE2eTestBrowser {\n     }\n \n \n-    async waitAndClickLast(selector: St): Pr<ClickResult> {\n-      return await this.waitAndClickNth(selector, -1);\n+    async waitAndClickLast(selector: St, ps: { needScroll?: Bo } = {}): Pr<ClickResult> {\n+      return await this.waitAndClickNth(selector, -1, ps);\n     }\n \n \n@@ -1778,17 +1804,18 @@ export class TyE2eTestBrowser {\n \n     // For one this.#br at a time only.\n     // n starts on 1 not 0. -1 clicks the last, -2 the last but one etc.\n-    async waitAndClickNth(selector: string, n: number): Pr<ClickResult> {   // BUG will only scroll the 1st elem into view [05YKTDTH4]\n-      dieIf(n <= 0, \"n starts on 1, change from 0 to 1 please\");\n-      logWarningIf(n !== 1,\n+    async waitAndClickNth(selector: St, n: Nr, ps: { needScroll?: Bo } = {}): Pr<ClickResult> {   // BUG will only scroll the 1st elem into view [05YKTDTH4]\n+      dieIf(n === 0, \"n starts on 1, change from 0 to 1 please (or -1 to click the last item)\");\n+      logWarningIf(n !== 1 && ps.needScroll !== false,\n           `n = ${n} !== 1, won't scroll into view before trying to click, maybe will miss:  ${selector} [05YKTDTH4]`);\n \n       // Currently always throws if couldn't click \u2014 timeoutIsFine isn't set.\n       if (await this._waitForClickable(selector) !== 'Clickable')\n         return 'CouldNotClick';\n \n       const elems = await this.$$(selector);\n-      tyAssert.ok(elems.length >= n, `Elem ${n} missing: Only ${elems.length} elems match: ${selector}`);\n+      tyAssert.ok(elems.length >= Math.abs(n),\n+            `Elem ${n} missing: Only ${elems.length} elems match: ${selector}`);\n       const index = n > 0\n           ? n - 1\n           : elems.length - (-n); // count from the end\n@@ -7159,16 +7186,35 @@ export class TyE2eTestBrowser {\n         await this.waitUntilLoadingOverlayGone();\n       },\n \n-      switchToInvites: async () => {\n+      switchToInvites: async (ps: { willFail?: true } = {}) => {\n         await this.waitAndClick('.e_InvTabB');\n-        await this.invitedUsersList.waitUntilLoaded();\n+        if (!ps.willFail) {\n+          await this.invitedUsersList.waitUntilLoaded();\n+        }\n       },\n \n       waitForTabsVisible: async () => {\n         // The activity tab is always visible, if the notfs tab can possibly be visible.\n         await this.waitForVisible('.e_UP_ActivityB');\n       },\n \n+      tabs: {\n+        switchToDraftsEtc: async (ps: { willFail?: true } = {}) => {\n+          await this.waitAndClick('.e_UP_DrftsB');\n+          if (!ps.willFail) {\n+            await this.waitUntilLoadingOverlayGone();\n+            await this.userProfilePage.draftsEtc.waitUntilLoaded();\n+          }\n+        },\n+\n+        isPreferencesTabDisplayed: async (): Pr<Bo> => {\n+          return await this.isDisplayed('#e2eUP_PrefsB');\n+        },\n+        switchToPreferences: async () => {\n+          await this.userProfilePage.clickGoToPreferences();\n+        },\n+      },\n+\n       isInvitesTabVisible: async (): Pr<Bo> => {\n         await this.userProfilePage.waitForTabsVisible();\n         return await this.isVisible('.e_InvTabB');\n@@ -7486,8 +7532,33 @@ export class TyE2eTestBrowser {\n           await this.userProfilePage._goHere(username, ps, '/preferences');\n         },\n \n-        switchToEmailsLogins: async () => {  // RENAME to tabToAccount\n+        tabs: {\n+          waitForAboutTabDisplayed: async (): Pr<Bo> => {\n+            return await this.waitForDisplayed('.s_UP_Prf_Nav_AbtL');\n+          },\n+          switchToAbout: async (ps: { willFail?: true } = {}) => {\n+            await this.waitAndClick('.s_UP_Prf_Nav_AbtL');\n+            if (!ps.willFail) {\n+              await this.waitForVisible('.e_UP_Prefs_FN');\n+            }\n+          },\n+\n+          switchToAccount: async (ps: { /*willFail?: true*/ } = {}) => {\n+            await this.userProfilePage.preferences.switchToEmailsLogins();\n+          },\n+\n+          isSecurityTabDisplayed: async (): Pr<Bo> => {\n+            return await this.isDisplayed('.e_UP_Prf_Nav_SecL');\n+          },\n+          switchToSecurity: async () => {\n+            await this.waitAndClick('.e_UP_Prf_Nav_SecL');\n+            await this.userProfilePage.preferences.security.waitForLoaded();\n+          },\n+        },\n+\n+        switchToEmailsLogins: async () => {  // MOVE to tabs.switchToAccount() instead (above)\n           await this.waitAndClick('.s_UP_Prf_Nav_EmLgL');\n+          // Break out fn:  waitForLoaded();  ?\n           if ((await this.urlPath()).startsWith(c.UsersUrlPrefix)) {\n             // Wait for user emails loaded.\n             await this.waitForVisible('.s_UP_EmLg_EmL');\n@@ -7592,6 +7663,55 @@ export class TyE2eTestBrowser {\n           },\n         },\n \n+        security: {\n+          goHere: async (viewWho: St | Member, ps: { isGroup?: true, origin?: St,\n+                    loginAs?: Member } = {}) => {\n+            const username = _.isString(viewWho) ? viewWho : viewWho.username;\n+            await this.userProfilePage._goHere(username, ps, '/preferences/security');\n+            if (ps.loginAs) {\n+              await this.complex.loginWithPasswordViaTopbar(ps.loginAs);\n+            }\n+          },\n+\n+          waitForLoaded: async (): Pr<V> => {\n+            await this.waitForVisible('.c_SessL');  // or waitForExist? works if not logged in\n+          },\n+\n+          waitForSessions: async (ps: { numActive: Nr, numEnded: Nr }): Pr<V> => {\n+            let numNow;\n+            await this.waitUntil(async () => {\n+              numNow = await this.userProfilePage.preferences.security.countSessions();\n+              return _.isEqual(numNow, ps);\n+            }, {\n+              message: () => `Waiting for ${j2s(ps)} sessions, currently: ${j2s(numNow)}`,\n+            })\n+          },\n+\n+          countSessions: async (): Pr<{ numActive: Nr, numEnded: Nr }> => {\n+            const numEnded = await this.count('.c_SessL_Sess-Ended');\n+            const numActive = await this.count('.c_SessL_Sess-Active');\n+            return { numEnded, numActive };\n+          },\n+\n+          numEndSessionButtonsVisible: async (): Pr<Nr> => {\n+            const num = await this.count('.c_SessL_Sess_EndB');\n+            return num + await this.count('.c_SessL_EndAllB');\n+          },\n+\n+          terminateNewestSession: async (): Pr<V> => {\n+            await this.waitAndClickFirst('.c_SessL_Sess_EndB');\n+          },\n+\n+          terminateOldestSession: async (): Pr<V> => {\n+            await this.scrollToBottom();\n+            await this.waitAndClickLast('.c_SessL_Sess_EndB', { needScroll: false });\n+          },\n+\n+          terminateAllSessions: async (): Pr<V> => {\n+            await this.waitAndClick('.c_SessL_EndAllB');\n+          },\n+        },\n+\n         emailsLogins: {   // RENAME to `account`\n           goHere: async (username: St, ps: { isGroup?: true, origin?: St } = {}) => {\n             await this.userProfilePage._goHere(username, ps, '/preferences/account');\n@@ -7601,6 +7721,17 @@ export class TyE2eTestBrowser {\n             return await this.waitAndGetVisibleText('.s_UP_EmLg_EmL_It_Em');\n           },\n \n+          getAllEmailAddresses: async (): Pr<St[]> => {\n+            await this.waitForDisplayed('.s_UP_EmLg_EmL_It_Em');\n+            const elms = await this.$$('.s_UP_EmLg_EmL_It_Em');\n+            const adrs = [];\n+            for (const el of elms) {\n+              const text = await el.getText();\n+              adrs.push(text);\n+            }\n+            return adrs;\n+          },\n+\n           waitUntilEmailAddressListed: async (addrRegexStr: St,\n                   opts: { shallBeVerified?: Bo } = {}) => {\n             const verified = opts.shallBeVerified ? '.e_EmVerfd' : (\n@@ -9663,4 +9794,168 @@ export class TyE2eTestBrowser {\n       },\n     }},\n   }\n+\n+\n+  /// For hacking into Talkyard, doing weird things.\n+  ///\n+  hackServer = {\n+    setSidPart12ViaJs: async (value: St, ps: { inCookie?: true, inField?: true }): Pr<V> => {\n+      await this.execute(function(value, ps) {\n+        if (ps.inCookie) {\n+          console.debug(`Setting cookie TyCoSid123 = \"${value}\" ...`);\n+          window['getSetCookie']('TyCoSid123', value);\n+          console.debug(`Done.`);\n+        }\n+        if (ps.inField) {\n+          try {\n+            console.debug(`Setting getMainWin().typs.weakSessionId = \"${value}\" ...`);\n+            window['debiki2'].getMainWin().typs.weakSessionId = value;\n+            console.debug(`Done.`);\n+          }\n+          catch (ex) {\n+            console.error(ex);  // logs nothing?\n+          }\n+        }\n+      }, value, ps);\n+    },\n+\n+\n+    getSidPart12Maybe3ViaJs: async (ps: { inCookie?: true, inField?: true })\n+          : Pr<SidFieldsParts | U> => {\n+      dieIf(!!ps.inCookie == !!ps.inField, \"TyE50MEPW24\");\n+      const anyValue = await this.#br.execute(function(ps) {\n+        let result: SidFieldsParts | U;\n+        if (ps.inCookie) {\n+          die(`Unimpl: Getting cookie TyCoSid123...`);\n+          result = {\n+            // sidCookiePart123ViaJs: window['getSetCookie']('TyCoSid123'),\n+          };\n+          console.debug(`Done.`);\n+        }\n+        if (ps.inField) {\n+          try {\n+            console.debug(`Getting getMainWin().typs.weakSessionId...`);\n+            result = {\n+              sidFieldParts12Maybe3: window['debiki2'].getMainWin().typs.weakSessionId,\n+            };\n+            console.debug(`Done.`);\n+          }\n+          catch (ex) {\n+            console.error(ex);  // logs nothing?\n+          }\n+        }\n+        console.debug(`Returning: \"${result}`);\n+        return result;\n+      }, ps);\n+      return anyValue;\n+    },\n+\n+    getSids: async (): Pr<SidParts> => {\n+      const result: SidParts = await this.hackServer.getSidPart12Maybe3ViaJs({ inField: true });\n+      const sidCookies = await this.#br.getCookies(\n+              ['TyCoSid123', 'TyCoSid4', 'TyCoSid5']);\n+      for (const cookie of sidCookies) {\n+        const resultFieldName =\n+                cookie.name === 'TyCoSid123' ? 'sidCookiePart123' : (\n+                cookie.name === 'TyCoSid4' ? 'sidCookiePart4' : (\n+                cookie.name === 'TyCoSid5' ? 'sidCookiePart5' : die('TyE503MEGE2')));\n+        result[resultFieldName] = cookie.value;\n+      }\n+      return result;\n+    },\n+\n+    getMyUserId: async (): Pr<PatId> => {\n+      return await this.execute(function() {\n+        const store = window['theStore'];\n+        return store.me.id;\n+      });\n+    },\n+\n+    loadEmailAddressesAndLoginMethods: async (): Pr<ServerSays> => {\n+      const result: ServerSays = await this.executeAsync<ServerSays>(function(done) {\n+        const store = window['theStore'];\n+        const me = store.me;\n+        // Calls:  `/-/load-email-addrs-login-methods?userId=${userId}`\n+        window['debiki2'].Server.loadEmailAddressesAndLoginMethods(me.id, function(resp) {\n+          console.debug(`OK response: ${JSON.stringify(resp)}`);\n+          done({ serverSaysOk: resp });\n+        }, function(resp) {\n+          console.debug(`Error response: ${JSON.stringify(resp)}`);\n+          done({ serverSaysError: resp });\n+        });\n+      });\n+      console.debug(`Result: ${j2s(result)}`);\n+      return result;\n+    },\n+\n+    addEmailAddresses: async (newAdr: St): Pr<ServerSays> => {\n+      const result: ServerSays = await this.executeAsync<ServerSays>(function(newAdr, done) {\n+        const store = window['theStore'];\n+        const me = store.me;\n+        // Calls:  /-/add-email-address\n+        // handled by:  UserController.addUserEmail().\n+        window['debiki2'].Server.addEmailAddresses(me.id, newAdr, function(resp) {\n+          console.debug(`OK response: ${JSON.stringify(resp)}`);\n+          done({ serverSaysOk: resp });\n+        }, function(resp) {\n+          console.debug(`Error response: ${JSON.stringify(resp)}`);\n+          done({ serverSaysError: resp });\n+        });\n+      }, newAdr);\n+      console.debug(`Result: ${j2s(result)}`);\n+      return result;\n+    },\n+\n+    /* Currently not needed, maybe later?:\n+\n+    tryChangeMyEmail: async (newAdr: St): Pr<{ emailAddresses } | { error }> => {\n+      const resp: A = await this.executeAsync(function(newAdr, done) {\n+        const store = window['theStore'];\n+        const me = store.me;\n+        // Calls: /-/set-primary-email-address\n+        // handled by: UserController.setPrimaryEmailAddresses().\n+        window['debiki2'].Server.setPrimaryEmailAddresses(me.id, newAdr, function(resp) {\n+          console.debug(`Emails after: ${JSON.stringify(resp)}`);\n+          done(resp);\n+        });\n+      }, newAdr);\n+      console.debug(`Emails after: ${JSON.stringify(resp)}`);\n+      return resp;\n+    },\n+\n+    tryChangeMyPrefs: async (newAdr: St): Pr<V> => {\n+      const meAfter = await this.executeAsync(function(newAdr, done) {\n+        const store = window['theStore'];\n+        const me = store.me;\n+        window['debiki2'].Server.saveAboutPatPrefs({\n+          userId: me.id,\n+          emailAddress: newAdr,\n+          username: me.username,\n+          emailPref: 5, // ReceiveAlways  (whatever)\n+        }, false, // isGroup\n+        function(patAfter) { // onOk\n+          done(patAfter);\n+        });\n+      }, newAdr);\n+    }, */\n+\n+    suspendUser: async (userId: PatId): Pr<ServerSays> => {\n+      const result: ServerSays = await this.executeAsync(function(userId, done) {\n+        // Calls:  /-/suspend-user\n+        // handled by:  UserController.suspendUser().\n+        window['debiki2'].Server.suspendUser(userId, 123, \"No reason\",\n+              function onOk(resp) {\n+                console.debug(`OK response: ${JSON.stringify(resp)}`);\n+                done({ serverSaysOk: resp });\n+              },\n+              function onErr(resp) {\n+                console.debug(`Error response: ${JSON.stringify(resp)}`);\n+                done({ serverSaysError: resp });\n+              });\n+      }, userId);\n+      console.debug(`Result: ${j2s(result)}`);\n+      return result;\n+    },\n+  };\n+\n }"
        },
        {
          "filename": "tests/e2e-wdio7/wdio.conf.ts",
          "status": "modified",
          "additions": 12,
          "deletions": 4,
          "patch": "@@ -740,11 +740,13 @@ const browserName = config.capabilities[0].browserName;\n // 2br and 3br is how many browsers the tests need \u2014 2 or 3 browsers, default 1.\n const onlyAndSpec = (settings.only || '') + ((settings as any).spec || '');\n const needsNumBrowsers =\n+    onlyAndSpec.indexOf('4br') >= 0 || settings.numBrowsers >= 4\n+        ? 4 : (\n     onlyAndSpec.indexOf('3br') >= 0 || settings.numBrowsers >= 3\n-        ? 3\n-        : (onlyAndSpec.indexOf('2br') >= 0 || settings.numBrowsers === 2\n-            ? 2\n-            : 1);\n+        ? 3 : (\n+    onlyAndSpec.indexOf('2br') >= 0 || settings.numBrowsers === 2\n+        ? 2\n+        : 1));\n \n if (needsNumBrowsers >= 2) {\n   const theCaps = config.capabilities[0];\n@@ -767,6 +769,12 @@ if (needsNumBrowsers >= 2) {\n     };\n   };\n \n+  if (needsNumBrowsers >= 4) {\n+    config.capabilities.wdioBrowserD = {\n+      capabilities: { ...theCaps }\n+    };\n+  };\n+\n   console.log(`I'll start ${needsNumBrowsers}${maybeInvisible} ${browserName} browsers.`);\n }\n else {"
        },
        {
          "filename": "tests/e2e/specs/admin-user-suspend.2browsers.test.ts",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -104,6 +104,9 @@ describe(\"admin-user-suspend [TyT5GKQSG2]\", function() {\n     mariasBrowser.editor.cancel();\n   });\n \n+  // TESTS_MISSING: should not get any more live updates via WebSocket  TyTE0MOREWSMSG\n+  // Or is that better done in a separate e2e test file?\n+\n   it(\"... Now, she cannot login (was logged out by the server)\", function() {\n     mariasBrowser.refresh();\n     mariasBrowser.acceptAnyAlert(2);  // for some reason, up to 2 alerts"
        },
        {
          "filename": "tests/e2e/specs/sso-test.2browsers.test.ts",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -126,6 +126,11 @@ describe(\"sso-test  TyT4ABKRW0268\", () => {\n \n   it(\"... he logs out\", () => {\n     owensBrowser.deleteCookie('dwCoSid');\n+    // Deleting any session id cookie, logs us out.  Only cookie TyCoSid123\n+    // is not-HttpOnly and can be deleted, so let's delete it.\n+    // What! This is Webdriver.io, which can delete all cookies. But whatever,\n+    // let's delete 123 only, that's enough.\n+    owensBrowser.deleteCookie('TyCoSid123');  // TyTESESS123GONE\n     owensBrowser.refresh();\n   });\n "
        },
        {
          "filename": "translations/en_US/i18n.ts",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -783,6 +783,7 @@ var t_en_US: TalkyardTranslations = t = {\n     DraftsEtc: \"Drafts etc\",\n     About: \"About\",\n     Privacy: \"Privacy\",\n+    Security: \"Security\",\n     Account: \"Account\",\n     Interface: \"Interface\",\n "
        }
      ],
      "file_patterns": {
        "security_files": 7,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 16,
        "unique_directories": 34,
        "max_directory_depth": 9
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7d1e783011ee95c7716c834d1a71117e2bec121f",
            "date": "2024-12-31T15:05:44Z",
            "author_login": "kajmagnus"
          },
          {
            "sha": "1f1c92bc5a99e46dc90be1f93cf84a75fc6e2cca",
            "date": "2024-12-31T09:44:45Z",
            "author_login": "kajmagnus"
          },
          {
            "sha": "e1713cd1a187f5e4a7f285d6946bc7d3d82ca350",
            "date": "2024-12-31T09:44:13Z",
            "author_login": "kajmagnus"
          },
          {
            "sha": "4577faa66162a43700b5ea3a7294aeb26c953878",
            "date": "2024-12-30T22:16:49Z",
            "author_login": "kajmagnus"
          },
          {
            "sha": "38c4dc2672cbab1ec612acfc28ac4d515f226c1e",
            "date": "2024-12-30T22:16:49Z",
            "author_login": "kajmagnus"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-613",
    "description": "In Talkyard, regular versions v0.2021.20 through v0.2021.33 and dev versions v0.2021.20 through v0.2021.34, are vulnerable to Insufficient Session Expiration. This may allow an attacker to reuse the admin\u2019s still-valid session token even when logged-out, to gain admin privileges, given the attacker is able to obtain that token (via other, hypothetical attacks)",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-01-03T07:15:06.943",
    "last_modified": "2024-11-21T05:55:43.607",
    "fix_date": "2021-07-08T09:56:09Z"
  },
  "references": [
    {
      "url": "https://github.com/debiki/talkyard/commit/b0310df019887f3464895529c773bc7d85ddcf34",
      "source": "vulnerabilitylab@mend.io",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/debiki/talkyard/commit/b0712915d8a22a20b09a129924e8a29c25ae5761",
      "source": "vulnerabilitylab@mend.io",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.whitesourcesoftware.com/vulnerability-database/CVE-2021-25981",
      "source": "vulnerabilitylab@mend.io",
      "tags": [
        "Patch",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/debiki/talkyard/commit/b0310df019887f3464895529c773bc7d85ddcf34",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/debiki/talkyard/commit/b0712915d8a22a20b09a129924e8a29c25ae5761",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.whitesourcesoftware.com/vulnerability-database/CVE-2021-25981",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory",
        "VDB Entry"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:37.043272",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "talkyard",
    "owner": "debiki",
    "created_at": "2013-06-08T03:46:12Z",
    "updated_at": "2025-01-14T03:36:37Z",
    "pushed_at": "2025-01-02T22:46:26Z",
    "size": 50100,
    "stars": 1725,
    "forks": 128,
    "open_issues": 95,
    "watchers": 1725,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "TypeScript": 6264209,
      "Scala": 5003320,
      "PLpgSQL": 449935,
      "Stylus": 277056,
      "JavaScript": 171332,
      "HTML": 134211,
      "Shell": 114518,
      "Makefile": 27357,
      "Lua": 16461,
      "Nix": 10586,
      "LiveScript": 10539,
      "Dockerfile": 6627,
      "Handlebars": 6041,
      "C": 1924,
      "Java": 1242,
      "Rust": 1017
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "agpl-3.0"
    },
    "collected_at": "2025-01-14T21:28:05.405786"
  }
}