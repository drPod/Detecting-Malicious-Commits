{
  "cve_id": "CVE-2021-27736",
  "github_data": {
    "repository": "FusionAuth/fusionauth-samlv2",
    "fix_commit": "c66fb689d50010662f705d5b585c6388ce555dbd",
    "related_commits": [
      "c66fb689d50010662f705d5b585c6388ce555dbd",
      "c66fb689d50010662f705d5b585c6388ce555dbd"
    ],
    "patch_url": "https://github.com/FusionAuth/fusionauth-samlv2/commit/c66fb689d50010662f705d5b585c6388ce555dbd.patch",
    "fix_commit_details": {
      "sha": "c66fb689d50010662f705d5b585c6388ce555dbd",
      "commit_date": "2021-02-07T02:10:15Z",
      "author": {
        "login": "robotdan",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Refactor utility methods into SAMLTools, add tests.",
        "length": 51,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 790,
        "additions": 580,
        "deletions": 210
      },
      "files": [
        {
          "filename": "fusionauth-samlv2.iml",
          "status": "modified",
          "additions": 2,
          "deletions": 3,
          "patch": "@@ -6,7 +6,7 @@\n     <exclude-output />\n     <content url=\"file://$MODULE_DIR$\">\n       <sourceFolder url=\"file://$MODULE_DIR$/src/main/java\" isTestSource=\"false\" />\n-      <sourceFolder url=\"file://$MODULE_DIR$/src/main/resources\" isTestSource=\"false\" />\n+      <sourceFolder url=\"file://$MODULE_DIR$/src/main/resources\" type=\"java-resource\" />\n       <sourceFolder url=\"file://$MODULE_DIR$/src/test/java\" isTestSource=\"true\" />\n       <sourceFolder url=\"file://$MODULE_DIR$/src/test/resources\" isTestSource=\"true\" />\n       <excludeFolder url=\"file://$MODULE_DIR$/.gradle\" />\n@@ -136,5 +136,4 @@\n       </library>\n     </orderEntry>\n   </component>\n-</module>\n-\n+</module>\n\\ No newline at end of file"
        },
        {
          "filename": "src/main/java/io/fusionauth/samlv2/service/DefaultSAMLv2Service.java",
          "status": "modified",
          "additions": 17,
          "deletions": 192,
          "patch": "@@ -15,11 +15,7 @@\n  */\n package io.fusionauth.samlv2.service;\n \n-import javax.xml.bind.JAXBContext;\n import javax.xml.bind.JAXBElement;\n-import javax.xml.bind.JAXBException;\n-import javax.xml.bind.Marshaller;\n-import javax.xml.bind.Unmarshaller;\n import javax.xml.crypto.KeySelector;\n import javax.xml.crypto.MarshalException;\n import javax.xml.crypto.dsig.CanonicalizationMethod;\n@@ -37,19 +33,7 @@\n import javax.xml.crypto.dsig.keyinfo.X509Data;\n import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;\n import javax.xml.crypto.dsig.spec.TransformParameterSpec;\n-import javax.xml.datatype.XMLGregorianCalendar;\n-import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n-import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n-import javax.xml.transform.dom.DOMSource;\n-import javax.xml.transform.stream.StreamResult;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.StringWriter;\n import java.io.UnsupportedEncodingException;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n@@ -59,8 +43,6 @@\n import java.security.PrivateKey;\n import java.security.Signature;\n import java.security.cert.Certificate;\n-import java.security.cert.CertificateException;\n-import java.security.cert.CertificateFactory;\n import java.security.cert.X509Certificate;\n import java.time.ZoneOffset;\n import java.time.ZonedDateTime;\n@@ -75,9 +57,6 @@\n import java.util.UUID;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n-import java.util.zip.DataFormatException;\n-import java.util.zip.Deflater;\n-import java.util.zip.Inflater;\n \n import com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;\n import io.fusionauth.samlv2.domain.Algorithm;\n@@ -89,7 +68,6 @@\n import io.fusionauth.samlv2.domain.MetaData;\n import io.fusionauth.samlv2.domain.MetaData.IDPMetaData;\n import io.fusionauth.samlv2.domain.MetaData.SPMetaData;\n-import io.fusionauth.samlv2.domain.NameID;\n import io.fusionauth.samlv2.domain.NameIDFormat;\n import io.fusionauth.samlv2.domain.ResponseStatus;\n import io.fusionauth.samlv2.domain.SAMLException;\n@@ -128,6 +106,7 @@\n import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.StatusType;\n import io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.KeyInfoType;\n import io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.X509DataType;\n+import io.fusionauth.samlv2.util.SAMLTools;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Attr;\n@@ -136,7 +115,16 @@\n import org.w3c.dom.NamedNodeMap;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n-import org.xml.sax.SAXException;\n+import static io.fusionauth.samlv2.util.SAMLTools.convertToZonedDateTime;\n+import static io.fusionauth.samlv2.util.SAMLTools.decodeAndInflate;\n+import static io.fusionauth.samlv2.util.SAMLTools.marshallToBytes;\n+import static io.fusionauth.samlv2.util.SAMLTools.marshallToDocument;\n+import static io.fusionauth.samlv2.util.SAMLTools.marshallToString;\n+import static io.fusionauth.samlv2.util.SAMLTools.newDocumentFromBytes;\n+import static io.fusionauth.samlv2.util.SAMLTools.parseNameId;\n+import static io.fusionauth.samlv2.util.SAMLTools.toXMLGregorianCalendar;\n+import static io.fusionauth.samlv2.util.SAMLTools.toZonedDateTime;\n+import static io.fusionauth.samlv2.util.SAMLTools.unmarshallFromDocument;\n \n /**\n  * Default implementation of the SAML service.\n@@ -411,7 +399,7 @@ public String buildRedirectAuthnRequest(AuthenticationRequest request, String re\n \n   @Override\n   public MetaData parseMetaData(String metaDataXML) throws SAMLException {\n-    Document document = parseFromBytes(metaDataXML.getBytes(StandardCharsets.UTF_8));\n+    Document document = newDocumentFromBytes(metaDataXML.getBytes(StandardCharsets.UTF_8));\n     EntityDescriptorType root = unmarshallFromDocument(document, EntityDescriptorType.class);\n     MetaData metaData = new MetaData();\n     metaData.id = root.getID();\n@@ -450,7 +438,7 @@ public MetaData parseMetaData(String metaDataXML) throws SAMLException {\n         metaData.idp.certificates = idp.getKeyDescriptor()\n                                        .stream()\n                                        .filter(kd -> kd.getUse() == KeyTypes.SIGNING)\n-                                       .map(this::toCertificate)\n+                                       .map(SAMLTools::toCertificate)\n                                        .filter(Objects::nonNull)\n                                        .collect(Collectors.toList());\n       } catch (IllegalArgumentException e) {\n@@ -532,7 +520,7 @@ public AuthenticationResponse parseResponse(String encodedResponse, boolean veri\n     byte[] decodedResponse = Base64.getMimeDecoder().decode(encodedResponse);\n     response.rawResponse = new String(decodedResponse, StandardCharsets.UTF_8);\n \n-    Document document = parseFromBytes(decodedResponse);\n+    Document document = newDocumentFromBytes(decodedResponse);\n     if (verifySignature) {\n       verifySignature(document, keySelector);\n     }\n@@ -613,7 +601,7 @@ public AuthenticationResponse parseResponse(String encodedResponse, boolean veri\n               AttributeType attributeType = (AttributeType) attributeObject;\n               String name = attributeType.getName();\n               List<Object> attributeValues = attributeType.getAttributeValue();\n-              List<String> values = attributeValues.stream().map(this::attributeToString).collect(Collectors.toList());\n+              List<String> values = attributeValues.stream().map(SAMLTools::attributeToString).collect(Collectors.toList());\n               response.assertion.attributes.computeIfAbsent(name, k -> new ArrayList<>()).addAll(values);\n             } else {\n               throw new SAMLException(\"This library currently doesn't support encrypted attributes\");\n@@ -646,24 +634,6 @@ private void addKeyDescriptors(SSODescriptorType descriptor, List<Certificate> c\n     });\n   }\n \n-  private String attributeToString(Object attribute) {\n-    if (attribute == null) {\n-      return null;\n-    }\n-\n-    if (attribute instanceof Number) {\n-      return attribute.toString();\n-    } else if (attribute instanceof String) {\n-      return (String) attribute;\n-    } else if (attribute instanceof Element) {\n-      return ((Element) attribute).getTextContent();\n-    } else {\n-      logger.warn(\"This library currently doesn't handle attributes of type [\" + attribute.getClass() + \"]\");\n-    }\n-\n-    return null;\n-  }\n-\n   private String buildPostAuthnRequest(AuthnRequestType authnRequest, boolean sign, PrivateKey privateKey,\n                                        X509Certificate certificate,\n                                        Algorithm algorithm, String xmlSignatureC14nMethod) throws SAMLException {\n@@ -687,7 +657,7 @@ private String buildRedirectAuthnRequest(AuthnRequestType authnRequest, String r\n                                            PrivateKey key, Algorithm algorithm) throws SAMLException {\n     try {\n       byte[] xml = marshallToBytes(PROTOCOL_OBJECT_FACTORY.createAuthnRequest(authnRequest), AuthnRequestType.class);\n-      String encodedResult = deflateAndEncode(xml);\n+      String encodedResult = SAMLTools.deflateAndEncode(xml);\n       String parameters = \"SAMLRequest=\" + URLEncoder.encode(encodedResult, \"UTF-8\");\n       if (relayState != null) {\n         parameters += \"&RelayState=\" + URLEncoder.encode(relayState, \"UTF-8\");\n@@ -711,43 +681,6 @@ private String buildRedirectAuthnRequest(AuthnRequestType authnRequest, String r\n     }\n   }\n \n-  private ZonedDateTime convertToZonedDateTime(XMLGregorianCalendar cal) {\n-    return cal != null ? cal.toGregorianCalendar().toZonedDateTime() : null;\n-  }\n-\n-  private byte[] decodeAndInflate(String encodedRequest) throws SAMLException {\n-    byte[] bytes = Base64.getMimeDecoder().decode(encodedRequest);\n-    Inflater inflater = new Inflater(true);\n-    inflater.setInput(bytes);\n-    inflater.finished();\n-\n-    try {\n-      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-      byte[] result = new byte[bytes.length];\n-      while (!inflater.finished()) {\n-        int length = inflater.inflate(result);\n-        if (length > 0) {\n-          baos.write(result, 0, length);\n-        }\n-      }\n-\n-      return baos.toByteArray();\n-    } catch (DataFormatException e) {\n-      throw new SAMLException(\"Invalid AuthnRequest. Inflating the bytes failed.\", e);\n-    }\n-  }\n-\n-  private String deflateAndEncode(byte[] result) {\n-    Deflater deflater = new Deflater(Deflater.DEFLATED, true);\n-    deflater.setInput(result);\n-    deflater.finish();\n-    byte[] deflatedResult = new byte[result.length];\n-    int length = deflater.deflate(deflatedResult);\n-    deflater.end();\n-    byte[] src = Arrays.copyOf(deflatedResult, length);\n-    return Base64.getEncoder().encodeToString(src);\n-  }\n-\n   private void fixIDs(Element element) {\n     NamedNodeMap attributes = element.getAttributes();\n     for (int i = 0; i < attributes.getLength(); i++) {\n@@ -766,42 +699,6 @@ private void fixIDs(Element element) {\n     }\n   }\n \n-  private <T> byte[] marshallToBytes(JAXBElement<T> object, Class<T> type) throws SAMLException {\n-    try {\n-      JAXBContext context = JAXBContext.newInstance(type);\n-      Marshaller marshaller = context.createMarshaller();\n-      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-      marshaller.marshal(object, baos);\n-      return baos.toByteArray();\n-    } catch (JAXBException e) {\n-      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to bytes.\", e);\n-    }\n-  }\n-\n-  @SuppressWarnings(\"SameParameterValue\")\n-  private <T> Document marshallToDocument(JAXBElement<T> object, Class<T> type) throws SAMLException {\n-    try {\n-      JAXBContext context = JAXBContext.newInstance(type);\n-      Marshaller marshaller = context.createMarshaller();\n-      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n-      dbf.setNamespaceAware(true);\n-      DocumentBuilder db = dbf.newDocumentBuilder();\n-      Document document = db.newDocument();\n-      marshaller.marshal(object, document);\n-      return document;\n-    } catch (JAXBException | ParserConfigurationException e) {\n-      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to DOM.\", e);\n-    }\n-  }\n-\n-  private String marshallToString(Document document) throws TransformerException {\n-    StringWriter sw = new StringWriter();\n-    TransformerFactory tf = TransformerFactory.newInstance();\n-    Transformer transformer = tf.newTransformer();\n-    transformer.transform(new DOMSource(document), new StreamResult(sw));\n-    return sw.toString();\n-  }\n-\n   private SubjectConfirmation parseConfirmation(SubjectConfirmationType subjectConfirmationType) {\n     SubjectConfirmation subjectConfirmation = new SubjectConfirmation();\n     SubjectConfirmationDataType data = subjectConfirmationType.getSubjectConfirmationData();\n@@ -818,32 +715,14 @@ private SubjectConfirmation parseConfirmation(SubjectConfirmationType subjectCon\n     return subjectConfirmation;\n   }\n \n-  private Document parseFromBytes(byte[] bytes) throws SAMLException {\n-    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n-    documentBuilderFactory.setNamespaceAware(true);\n-    try {\n-      DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n-      return builder.parse(new ByteArrayInputStream(bytes));\n-    } catch (ParserConfigurationException | SAXException | IOException e) {\n-      throw new SAMLException(\"Unable to parse SAML v2.0 authentication response\", e);\n-    }\n-  }\n-\n-  private NameID parseNameId(NameIDType element) {\n-    NameID nameId = new NameID();\n-    nameId.format = NameIDFormat.fromSAMLFormat(element.getFormat());\n-    nameId.id = element.getValue();\n-    return nameId;\n-  }\n-\n   private AuthnRequestParseResult parseRequest(byte[] xmlBytes) throws SAMLException {\n     String xml = new String(xmlBytes, StandardCharsets.UTF_8);\n     if (logger.isDebugEnabled()) {\n       logger.debug(\"SAMLRequest XML is\\n{}\", xml);\n     }\n \n     AuthnRequestParseResult result = new AuthnRequestParseResult();\n-    result.document = parseFromBytes(xmlBytes);\n+    result.document = newDocumentFromBytes(xmlBytes);\n     result.authnRequest = unmarshallFromDocument(result.document, AuthnRequestType.class);\n     result.request = new AuthenticationRequest();\n     result.request.xml = xml;\n@@ -907,60 +786,6 @@ private AuthnRequestType toAuthnRequest(AuthenticationRequest request, String ve\n     return authnRequest;\n   }\n \n-  private Certificate toCertificate(KeyDescriptorType keyDescriptorType) {\n-    try {\n-      List<Object> keyData = keyDescriptorType.getKeyInfo().getContent();\n-      for (Object keyDatum : keyData) {\n-        if (keyDatum instanceof JAXBElement<?>) {\n-          JAXBElement<?> element = (JAXBElement<?>) keyDatum;\n-          if (element.getDeclaredType() == X509DataType.class) {\n-            X509DataType cert = (X509DataType) element.getValue();\n-            List<Object> certData = cert.getX509IssuerSerialOrX509SKIOrX509SubjectName();\n-            for (Object certDatum : certData) {\n-              element = (JAXBElement<?>) certDatum;\n-              if (element.getName().getLocalPart().equals(\"X509Certificate\")) {\n-                byte[] certBytes = (byte[]) element.getValue();\n-                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-                return cf.generateCertificate(new ByteArrayInputStream(certBytes));\n-              }\n-            }\n-          }\n-        }\n-      }\n-\n-      return null;\n-    } catch (CertificateException e) {\n-      throw new IllegalArgumentException(e);\n-    }\n-  }\n-\n-  private XMLGregorianCalendar toXMLGregorianCalendar(ZonedDateTime instant) {\n-    if (instant == null) {\n-      return null;\n-    }\n-\n-    return new XMLGregorianCalendarImpl(GregorianCalendar.from(instant));\n-  }\n-\n-  private ZonedDateTime toZonedDateTime(XMLGregorianCalendar instant) {\n-    if (instant == null) {\n-      return null;\n-    }\n-\n-    return instant.toGregorianCalendar().toZonedDateTime();\n-  }\n-\n-  private <T> T unmarshallFromDocument(Document document, Class<T> type) throws SAMLException {\n-    try {\n-      JAXBContext context = JAXBContext.newInstance(type);\n-      Unmarshaller unmarshaller = context.createUnmarshaller();\n-      JAXBElement<T> element = unmarshaller.unmarshal(document, type);\n-      return element.getValue();\n-    } catch (JAXBException e) {\n-      throw new SAMLException(\"Unable to unmarshall SAML response\", e);\n-    }\n-  }\n-\n   private void verifySignature(Document document, KeySelector keySelector) throws SAMLException {\n     // Fix the IDs in the entire document per the suggestions at http://stackoverflow.com/questions/17331187/xml-dig-sig-error-after-upgrade-to-java7u25\n     fixIDs(document.getDocumentElement());"
        },
        {
          "filename": "src/main/java/io/fusionauth/samlv2/util/SAMLTools.java",
          "status": "added",
          "additions": 442,
          "deletions": 0,
          "patch": "@@ -0,0 +1,442 @@\n+/*\n+ * Copyright (c) 2021, Inversoft Inc., All Rights Reserved\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied. See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ */\n+package io.fusionauth.samlv2.util;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.datatype.XMLGregorianCalendar;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+import javax.xml.validation.Validator;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.net.URL;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.GregorianCalendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.Inflater;\n+\n+import com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;\n+import io.fusionauth.samlv2.domain.NameID;\n+import io.fusionauth.samlv2.domain.NameIDFormat;\n+import io.fusionauth.samlv2.domain.SAMLException;\n+import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.NameIDType;\n+import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.KeyDescriptorType;\n+import io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.X509DataType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.ErrorHandler;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXNotRecognizedException;\n+import org.xml.sax.SAXNotSupportedException;\n+import org.xml.sax.SAXParseException;\n+import static javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING;\n+\n+/**\n+ * @author Daniel DeGroff\n+ */\n+public class SAMLTools {\n+  private static final Map<String, Boolean> FactoryAttributes = new HashMap<>();\n+\n+  private static final Logger logger = LoggerFactory.getLogger(SAMLTools.class);\n+\n+  static {\n+    FactoryAttributes.put(\"http://xml.org/sax/features/external-general-entities\", false);\n+    FactoryAttributes.put(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+    FactoryAttributes.put(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n+    FactoryAttributes.put(\"http://javax.xml.XMLConstants/feature/secure-processing\", true);\n+    FactoryAttributes.put(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+    FactoryAttributes.put(\"http://apache.org/xml/features/nonvalidating/load-dtd-grammar\", false);\n+  }\n+\n+  /**\n+   * Convert an attribute to a string.\n+   *\n+   * @param attribute the attribute in object form\n+   * @return a string version of the attribute.\n+   */\n+  public static String attributeToString(Object attribute) {\n+    if (attribute == null) {\n+      return null;\n+    }\n+\n+    if (attribute instanceof Number) {\n+      return attribute.toString();\n+    } else if (attribute instanceof String) {\n+      return (String) attribute;\n+    } else if (attribute instanceof Element) {\n+      return ((Element) attribute).getTextContent();\n+    } else {\n+      logger.warn(\"This library currently doesn't handle attributes of type [\" + attribute.getClass() + \"]\");\n+    }\n+\n+    return null;\n+  }\n+\n+  /**\n+   * Convert a calendar object of type <code>XMLGregorianCalendar</code> to a ZonedDateTime.\n+   *\n+   * @param cal a calendar object\n+   * @return a zoned date time object\n+   */\n+  public static ZonedDateTime convertToZonedDateTime(XMLGregorianCalendar cal) {\n+    return cal != null ? cal.toGregorianCalendar().toZonedDateTime() : null;\n+  }\n+\n+  /**\n+   * Decode and inflate the encoded request.\n+   *\n+   * @param encodedRequest the encoded request\n+   * @return a decoded and inflated request as bytes\n+   * @throws SAMLException if $%#! goes south\n+   */\n+  public static byte[] decodeAndInflate(String encodedRequest) throws SAMLException {\n+    byte[] bytes = Base64.getMimeDecoder().decode(encodedRequest);\n+    Inflater inflater = new Inflater(true);\n+    inflater.setInput(bytes);\n+    inflater.finished();\n+\n+    try {\n+      ByteArrayOutputStream os = new ByteArrayOutputStream();\n+      byte[] result = new byte[bytes.length];\n+      while (!inflater.finished()) {\n+        int length = inflater.inflate(result);\n+        if (length > 0) {\n+          os.write(result, 0, length);\n+        }\n+      }\n+\n+      return os.toByteArray();\n+    } catch (DataFormatException e) {\n+      throw new SAMLException(\"Invalid AuthnRequest. Inflating the bytes failed.\", e);\n+    }\n+  }\n+\n+  /**\n+   * Deflate and encode the provided byte array.\n+   *\n+   * @param bytes the byte array to deflate and encode.\n+   * @return an encoded string\n+   */\n+  public static String deflateAndEncode(byte[] bytes) {\n+    Deflater deflater = new Deflater(Deflater.DEFLATED, true);\n+    deflater.setInput(bytes);\n+    deflater.finish();\n+    byte[] deflatedResult = new byte[bytes.length];\n+    int length = deflater.deflate(deflatedResult);\n+    deflater.end();\n+    byte[] src = Arrays.copyOf(deflatedResult, length);\n+    return Base64.getEncoder().encodeToString(src);\n+  }\n+\n+  /**\n+   * Serialize the JAXBElement to a byte array.\n+   *\n+   * @param object the JAXB element.\n+   * @param type   the class of the element.\n+   * @param <T>    the type of the element.\n+   * @return a byte array\n+   * @throws SAMLException if $%#! goes south.\n+   */\n+  public static <T> byte[] marshallToBytes(JAXBElement<T> object, Class<T> type) throws SAMLException {\n+    try {\n+      JAXBContext context = JAXBContext.newInstance(type);\n+      Marshaller marshaller = context.createMarshaller();\n+      ByteArrayOutputStream os = new ByteArrayOutputStream();\n+      marshaller.marshal(object, os);\n+      return os.toByteArray();\n+    } catch (JAXBException e) {\n+      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to bytes.\", e);\n+    }\n+  }\n+\n+  /**\n+   * Marshall the JAXB element to a Document.\n+   *\n+   * @param object the JAXB element.\n+   * @param type   the class of the element.\n+   * @param <T>    the type of the element.\n+   * @return a document\n+   * @throws SAMLException if $%#! goes south\n+   */\n+  public static <T> Document marshallToDocument(JAXBElement<T> object, Class<T> type) throws SAMLException {\n+    try {\n+      JAXBContext context = JAXBContext.newInstance(type);\n+      Marshaller marshaller = context.createMarshaller();\n+      Document document = newDocumentBuilder().newDocument();\n+      marshaller.marshal(object, document);\n+\n+      return document;\n+    } catch (JAXBException | SAMLException e) {\n+      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to DOM.\", e);\n+    }\n+  }\n+\n+  /**\n+   * Serialize the provided document.\n+   *\n+   * @param document the document to serialize.\n+   * @return a string form of the serialized document.\n+   */\n+  public static String marshallToString(Document document) throws TransformerException {\n+    StringWriter sw = new StringWriter();\n+    TransformerFactory tf = TransformerFactory.newInstance();\n+    Transformer transformer = tf.newTransformer();\n+    transformer.transform(new DOMSource(document), new StreamResult(sw));\n+    return sw.toString();\n+  }\n+\n+  /**\n+   * Return a new document builder\n+   *\n+   * @return a document builder\n+   * @throws SAMLException if $%#! goes south\n+   */\n+  public static DocumentBuilder newDocumentBuilder() throws SAMLException {\n+    // https://cheatsheetseries.owasp.org/cheatsheets/SAML_Security_Cheat_Sheet.html\n+    // https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#SAXTransformerFactory\n+    // https://web-in-security.blogspot.com/2014/11/detecting-and-exploiting-xxe-in-saml.html\n+\n+    try {\n+      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n+      dbf.setNamespaceAware(true);\n+\n+      // Do not expand entity references\n+      dbf.setExpandEntityReferences(false);\n+\n+      // Set default attributes\n+      for (String key : FactoryAttributes.keySet()) {\n+        try {\n+          dbf.setAttribute(key, FactoryAttributes.get(key));\n+        } catch (IllegalArgumentException e) {\n+          // The parser may not recognize this attribute.\n+          logger.debug(\"Failed to set attribute [\" + key + \"=\" + FactoryAttributes.get(key) + \"]. This may be expected if the parser does not recognize this attribute.\", e);\n+        }\n+      }\n+\n+      // Enabling 'secure processing' disables loading of external DTD and external Schema.\n+      // - See constructor body on line 177 of DocumentBuilderImpl.\n+      dbf.setFeature(FEATURE_SECURE_PROCESSING, true);\n+\n+      return dbf.newDocumentBuilder();\n+    } catch (ParserConfigurationException e) {\n+      throw new SAMLException(\"Unable to configure the DocumentBuilderFactory with feature [\" + FEATURE_SECURE_PROCESSING + \"].\", e);\n+    }\n+  }\n+\n+  /**\n+   * Parse the provided bytes into a document.\n+   *\n+   * @param bytes the bytes\n+   * @return a document\n+   * @throws SAMLException if $%#! goes south\n+   */\n+  public static Document newDocumentFromBytes(byte[] bytes) throws SAMLException {\n+    try {\n+      return newDocumentBuilder().parse(new ByteArrayInputStream(bytes));\n+    } catch (SAXException | IOException e) {\n+      throw new SAMLException(\"Unable to parse SAML v2.0 authentication response\", e);\n+    }\n+  }\n+\n+  /**\n+   * Parse a NameIdType element and return a NameID enum.\n+   *\n+   * @param element the nameId element\n+   * @return a nameId enum value\n+   */\n+  public static NameID parseNameId(NameIDType element) {\n+    NameID nameId = new NameID();\n+    nameId.format = NameIDFormat.fromSAMLFormat(element.getFormat());\n+    nameId.id = element.getValue();\n+    return nameId;\n+  }\n+\n+  /**\n+   * Convert a key descriptor type to a certificate\n+   *\n+   * @param keyDescriptorType the key descriptor type\n+   * @return a certificate or null if it could not be converted.\n+   */\n+  public static Certificate toCertificate(KeyDescriptorType keyDescriptorType) {\n+    try {\n+      List<Object> keyData = keyDescriptorType.getKeyInfo().getContent();\n+      for (Object keyDatum : keyData) {\n+        if (keyDatum instanceof JAXBElement<?>) {\n+          JAXBElement<?> element = (JAXBElement<?>) keyDatum;\n+          if (element.getDeclaredType() == X509DataType.class) {\n+            X509DataType cert = (X509DataType) element.getValue();\n+            List<Object> certData = cert.getX509IssuerSerialOrX509SKIOrX509SubjectName();\n+            for (Object certDatum : certData) {\n+              element = (JAXBElement<?>) certDatum;\n+              if (element.getName().getLocalPart().equals(\"X509Certificate\")) {\n+                byte[] certBytes = (byte[]) element.getValue();\n+                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+                return cf.generateCertificate(new ByteArrayInputStream(certBytes));\n+              }\n+            }\n+          }\n+        }\n+      }\n+\n+      return null;\n+    } catch (CertificateException e) {\n+      throw new IllegalArgumentException(e);\n+    }\n+  }\n+\n+  /**\n+   * Convert a ZonedDateTime instant to an XMlGregorianCalendar object.\n+   *\n+   * @param instant the instant\n+   * @return a calendar object.\n+   */\n+  public static XMLGregorianCalendar toXMLGregorianCalendar(ZonedDateTime instant) {\n+    if (instant == null) {\n+      return null;\n+    }\n+\n+    return new XMLGregorianCalendarImpl(GregorianCalendar.from(instant));\n+  }\n+\n+  /**\n+   * Convert an XMLGregorianCalendar instant to a ZoneDateTime instant\n+   *\n+   * @param instant the instant\n+   * @return a ZoneDateTime object\n+   */\n+  public static ZonedDateTime toZonedDateTime(XMLGregorianCalendar instant) {\n+    if (instant == null) {\n+      return null;\n+    }\n+\n+    return instant.toGregorianCalendar().toZonedDateTime();\n+  }\n+\n+  /**\n+   * Convert a document to a JAXB Element\n+   *\n+   * @param document the XML document\n+   * @param type     the class of the JAXB element to marshal the document to\n+   * @param <T>      the type\n+   * @return an object of type T\n+   * @throws SAMLException if $%#! goes south\n+   */\n+  public static <T> T unmarshallFromDocument(Document document, Class<T> type) throws SAMLException {\n+    try {\n+      JAXBContext context = JAXBContext.newInstance(type);\n+      Unmarshaller unmarshaller = context.createUnmarshaller();\n+      JAXBElement<T> element = unmarshaller.unmarshal(document, type);\n+      return element.getValue();\n+    } catch (JAXBException e) {\n+      throw new SAMLException(\"Unable to unmarshall SAML response\", e);\n+    }\n+  }\n+\n+  /**\n+   * Validate the document.\n+   *\n+   * @param document  the document\n+   * @param schemaURI the schema URI\n+   * @param errors    the errors object used to collect all errors from the validator.\n+   * @return true if the validation was successful, false otherwise.\n+   * @throws SAMLException if $%#! goes south\n+   */\n+  public static boolean validate(Document document, URL schemaURI, SchemaValidationErrors errors) throws SAMLException {\n+    Schema schema;\n+    try {\n+      schema = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI).newSchema(schemaURI);\n+    } catch (SAXException e) {\n+      throw new SAMLException(\"An invalid schema was requested. Schema [\" + schemaURI + \"].\", e);\n+    }\n+\n+    Validator validator = schema.newValidator();\n+    validator.setErrorHandler(errors);\n+\n+    // Disable external DTD while validating.\n+    try {\n+      validator.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n+    } catch (SAXNotRecognizedException | SAXNotSupportedException ignore) {\n+      // Not supported by the parser\n+    }\n+\n+    // Disable external Schema while validating.\n+    try {\n+      validator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n+    } catch (SAXNotRecognizedException | SAXNotSupportedException ignore) {\n+      // Not supported by the parser\n+    }\n+\n+    Source source = new DOMSource(document);\n+    try {\n+      validator.validate(source);\n+    } catch (IOException | SAXException e) {\n+      throw new SAMLException(\"Failed to validate the document source.\", e);\n+    }\n+\n+    return errors.error.isEmpty() && errors.fatal.isEmpty() && errors.warning.isEmpty();\n+  }\n+\n+  public static class SchemaValidationErrors implements ErrorHandler {\n+    public final List<SAXParseException> error = new ArrayList<>();\n+\n+    public final List<SAXParseException> fatal = new ArrayList<>();\n+\n+    public final List<SAXParseException> warning = new ArrayList<>();\n+\n+    @Override\n+    public void error(SAXParseException exception) {\n+      error.add(exception);\n+    }\n+\n+    @Override\n+    public void fatalError(SAXParseException exception) {\n+      fatal.add(exception);\n+    }\n+\n+    @Override\n+    public void warning(SAXParseException exception) {\n+      warning.add(exception);\n+    }\n+  }\n+}"
        },
        {
          "filename": "src/test/java/io/fusionauth/samlv2/service/DefaultSAMLv2ServiceTest.java",
          "status": "modified",
          "additions": 68,
          "deletions": 0,
          "patch": "@@ -24,13 +24,16 @@\n import javax.xml.parsers.DocumentBuilder;\n import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n+import java.io.BufferedWriter;\n import java.io.ByteArrayInputStream;\n+import java.io.FileWriter;\n import java.io.IOException;\n import java.io.InputStream;\n import java.math.BigInteger;\n import java.net.URLDecoder;\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n+import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.security.KeyFactory;\n import java.security.KeyPair;\n@@ -60,6 +63,7 @@\n import io.fusionauth.samlv2.domain.SAMLException;\n import io.fusionauth.samlv2.domain.SignatureLocation;\n import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.AuthnRequestType;\n+import io.fusionauth.samlv2.util.SAMLTools;\n import org.testng.annotations.BeforeClass;\n import org.testng.annotations.DataProvider;\n import org.testng.annotations.Test;\n@@ -256,6 +260,70 @@ public void parseRequest_compassSecurity() throws Exception {\n     assertEquals(request.version, \"2.0\");\n   }\n \n+  @Test\n+  public void parseRequest_expandedEntity() throws Exception {\n+    // Expanded entity, fail. The entity definition is within the DOCTYPE, which is not allowed, the error will be with regards to the DOCTYPE.\n+    try {\n+      DefaultSAMLv2Service service = new DefaultSAMLv2Service();\n+      byte[] xml = Files.readAllBytes(Paths.get(\"src/test/xml/authn-request-expanded-entity.xml\"));\n+      String deflated = SAMLTools.deflateAndEncode(xml);\n+      AuthenticationRequest request = service.parseRequestRedirectBinding(deflated, null, authRequest -> new TestRedirectBindingSignatureHelper());\n+      fail(\"Expected an exception because we are declaring a DOCTYPE and expanding an entity. The issuer is now set to [\" + request.issuer + \"] which is not good.\");\n+    } catch (SAMLException e) {\n+      assertEquals(e.getMessage(), \"Unable to parse SAML v2.0 authentication response\");\n+      assertEquals(e.getCause().getClass().getCanonicalName(), \"org.xml.sax.SAXParseException\");\n+      assertEquals(e.getCause().getMessage(), \"DOCTYPE is disallowed when the feature \\\"http://apache.org/xml/features/disallow-doctype-decl\\\" set to true.\");\n+    }\n+  }\n+\n+  @Test\n+  public void parseRequest_externalDTD() throws Exception {\n+    // Load an external DTD, fail, this is defined within the DOCTYPE, so the error will be with regards to the DOCTYPE.\n+    Path tempFile = null;\n+    try {\n+      tempFile = Files.createTempFile(\"readThisFile\", \".tmp\");\n+      try (BufferedWriter writer = new BufferedWriter(new FileWriter(tempFile.toFile()))) {\n+        writer.write(\"You've been pwned.\");\n+      }\n+\n+      DefaultSAMLv2Service service = new DefaultSAMLv2Service();\n+      byte[] xml = Files.readAllBytes(Paths.get(\"src/test/xml/authn-request-external-dtd.xml\"));\n+\n+      // Set the filename in the XML\n+      String xmlString = new String(xml);\n+      xmlString = xmlString.replace(\"{{tempFile}}\", tempFile.toFile().getAbsolutePath());\n+      xml = xmlString.getBytes(StandardCharsets.UTF_8);\n+\n+      String deflated = SAMLTools.deflateAndEncode(xml);\n+      AuthenticationRequest request = service.parseRequestRedirectBinding(deflated, null, authRequest -> new TestRedirectBindingSignatureHelper());\n+      fail(\"Expected an exception because we are declaring a DOCTYPE. The issuer is now set to [\" + request.issuer + \"] which is not good.\");\n+    } catch (SAMLException e) {\n+      assertEquals(e.getMessage(), \"Unable to parse SAML v2.0 authentication response\");\n+      assertEquals(e.getCause().getClass().getCanonicalName(), \"org.xml.sax.SAXParseException\");\n+      assertEquals(e.getCause().getMessage(), \"DOCTYPE is disallowed when the feature \\\"http://apache.org/xml/features/disallow-doctype-decl\\\" set to true.\");\n+    } finally {\n+      if (tempFile != null) {\n+        Files.deleteIfExists(tempFile);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void parseRequest_hasDocType() throws Exception {\n+    // Has DOCTYPE, fail. No DOCTYPE for you!\n+    try {\n+      DefaultSAMLv2Service service = new DefaultSAMLv2Service();\n+      byte[] xml = Files.readAllBytes(Paths.get(\"src/test/xml/authn-request-has-doctype.xml\"));\n+      String deflated = SAMLTools.deflateAndEncode(xml);\n+      service.parseRequestRedirectBinding(deflated, null, authRequest -> new TestRedirectBindingSignatureHelper());\n+      fail(\"expected an exception because we are declaring a DOCTYPE\");\n+    } catch (SAMLException e) {\n+      assertEquals(e.getMessage(), \"Unable to parse SAML v2.0 authentication response\");\n+      assertEquals(e.getCause().getClass().getCanonicalName(), \"org.xml.sax.SAXParseException\");\n+      assertEquals(e.getCause().getMessage(), \"DOCTYPE is disallowed when the feature \\\"http://apache.org/xml/features/disallow-doctype-decl\\\" set to true.\");\n+    }\n+  }\n+\n   @Test(dataProvider = \"maxLineLength\")\n   public void parseRequest_includeLineReturns(int maxLineLength) throws Exception {\n     String xml = new String(Files.readAllBytes(Paths.get(\"src/test/xml/authn-request-control.xml\")));"
        },
        {
          "filename": "src/test/xml/authn-request-expanded-entity.xml",
          "status": "added",
          "additions": 17,
          "deletions": 0,
          "patch": "@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!DOCTYPE foo [ <!ENTITY x \"You've been pwned.\" >]>\n+<samlp:AuthnRequest xmlns:samlp=\"urn:oasis:names:tc:SAML:2.0:protocol\"\n+                    xmlns:saml=\"urn:oasis:names:tc:SAML:2.0:assertion\"\n+                    ID=\"_809707f0030a5d00620c9d9df97f627afe9dcc24\"\n+                    Version=\"2.0\"\n+                    ProviderName=\"SP test\"\n+                    IssueInstant=\"2014-07-16T23:52:45Z\"\n+                    Destination=\"http://idp.example.com/SSOService.php\"\n+                    ProtocolBinding=\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\"\n+                    AssertionConsumerServiceURL=\"http://sp.example.com/demo1/index.php?acs\">\n+  <saml:Issuer>&x;</saml:Issuer>\n+  <samlp:NameIDPolicy Format=\"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\" AllowCreate=\"true\"/>\n+  <samlp:RequestedAuthnContext Comparison=\"exact\">\n+    <saml:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport</saml:AuthnContextClassRef>\n+  </samlp:RequestedAuthnContext>\n+</samlp:AuthnRequest>\n\\ No newline at end of file"
        },
        {
          "filename": "src/test/xml/authn-request-external-dtd.xml",
          "status": "added",
          "additions": 17,
          "deletions": 0,
          "patch": "@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"{{tempFile}}\" >]>\n+<samlp:AuthnRequest xmlns:samlp=\"urn:oasis:names:tc:SAML:2.0:protocol\"\n+                    xmlns:saml=\"urn:oasis:names:tc:SAML:2.0:assertion\"\n+                    ID=\"_809707f0030a5d00620c9d9df97f627afe9dcc24\"\n+                    Version=\"2.0\"\n+                    ProviderName=\"SP test\"\n+                    IssueInstant=\"2014-07-16T23:52:45Z\"\n+                    Destination=\"http://idp.example.com/SSOService.php\"\n+                    ProtocolBinding=\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\"\n+                    AssertionConsumerServiceURL=\"http://sp.example.com/demo1/index.php?acs\">\n+  <saml:Issuer>&xxe;</saml:Issuer>\n+  <samlp:NameIDPolicy Format=\"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\" AllowCreate=\"true\"/>\n+  <samlp:RequestedAuthnContext Comparison=\"exact\">\n+    <saml:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport</saml:AuthnContextClassRef>\n+  </samlp:RequestedAuthnContext>\n+</samlp:AuthnRequest>\n\\ No newline at end of file"
        },
        {
          "filename": "src/test/xml/authn-request-has-doctype.xml",
          "status": "added",
          "additions": 17,
          "deletions": 0,
          "patch": "@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!DOCTYPE MyDocType >\n+<samlp:AuthnRequest xmlns:samlp=\"urn:oasis:names:tc:SAML:2.0:protocol\"\n+                    xmlns:saml=\"urn:oasis:names:tc:SAML:2.0:assertion\"\n+                    ID=\"_809707f0030a5d00620c9d9df97f627afe9dcc24\"\n+                    Version=\"2.0\"\n+                    ProviderName=\"SP test\"\n+                    IssueInstant=\"2014-07-16T23:52:45Z\"\n+                    Destination=\"http://idp.example.com/SSOService.php\"\n+                    ProtocolBinding=\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\"\n+                    AssertionConsumerServiceURL=\"http://sp.example.com/demo1/index.php?acs\">\n+  <saml:Issuer>http://sp.example.com/demo1/metadata.php</saml:Issuer>\n+  <samlp:NameIDPolicy Format=\"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\" AllowCreate=\"true\"/>\n+  <samlp:RequestedAuthnContext Comparison=\"exact\">\n+    <saml:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport</saml:AuthnContextClassRef>\n+  </samlp:RequestedAuthnContext>\n+</samlp:AuthnRequest>\n\\ No newline at end of file"
        },
        {
          "filename": "src/test/xml/metadata.xml",
          "status": "modified",
          "additions": 0,
          "deletions": 15,
          "patch": "@@ -1,18 +1,3 @@\n-<!--\n-  ~ Copyright (c) 2019, Inversoft Inc., All Rights Reserved\n-  ~\n-  ~ Licensed under the Apache License, Version 2.0 (the \"License\");\n-  ~ you may not use this file except in compliance with the License.\n-  ~ You may obtain a copy of the License at\n-  ~\n-  ~   http://www.apache.org/licenses/LICENSE-2.0\n-  ~\n-  ~ Unless required by applicable law or agreed to in writing,\n-  ~ software distributed under the License is distributed on an\n-  ~ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n-  ~ either express or implied. See the License for the specific\n-  ~ language governing permissions and limitations under the License.\n-  -->\n <EntityDescriptor xmlns=\"urn:oasis:names:tc:SAML:2.0:metadata\" ID=\"_258d6b11-8d5b-4da6-9f05-9b481e4a5ea8\" entityID=\"https://sts.windows.net/c2150111-3c44-4508-9f08-790cb4032a23/\">\n   <Signature xmlns=\"http://www.w3.org/2000/09/xmldsig#\">\n     <SignedInfo>"
        }
      ],
      "file_patterns": {
        "security_files": 7,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 5,
        "unique_directories": 5,
        "max_directory_depth": 7
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b11137a8ca02b986b54988a886dffd4aaf434dac",
            "date": "2024-12-16T21:48:58Z",
            "author_login": "spwitt"
          },
          {
            "sha": "8075fa6e7e66c1df9c101d57768677fb4fb6e9b0",
            "date": "2024-12-10T13:58:39Z",
            "author_login": "spwitt"
          },
          {
            "sha": "a3095da47d314f3e7a859da7623ac5b2d05fefa6",
            "date": "2024-07-29T15:25:43Z",
            "author_login": "mmanes"
          },
          {
            "sha": "1a3f4eb25cca8651bc04b0ac78e36a6b3443a43e",
            "date": "2024-07-29T14:55:08Z",
            "author_login": "mooreds"
          },
          {
            "sha": "3a8686c79d22da9881d6a69c5dbe7b7b33e9ef79",
            "date": "2024-07-28T05:57:25Z",
            "author_login": "fusionauth-platform-team"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-611",
    "description": "FusionAuth fusionauth-samlv2 before 0.5.4 allows XXE attacks via a forged AuthnRequest or LogoutRequest because parseFromBytes uses javax.xml.parsers.DocumentBuilderFactory unsafely.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-04-22T14:15:09.123",
    "last_modified": "2024-11-21T05:58:29.113",
    "fix_date": "2021-02-07T02:10:15Z"
  },
  "references": [
    {
      "url": "https://github.com/FusionAuth/fusionauth-samlv2/commit/c66fb689d50010662f705d5b585c6388ce555dbd",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/FusionAuth/fusionauth-samlv2/compare/0.5.3...0.5.4",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.compass-security.com/fileadmin/Research/Advisories/2021-03_CSNC-2021-004_FusionAuth_SAML_Library_XML_External_Entity.txt",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/FusionAuth/fusionauth-samlv2/commit/c66fb689d50010662f705d5b585c6388ce555dbd",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/FusionAuth/fusionauth-samlv2/compare/0.5.3...0.5.4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.compass-security.com/fileadmin/Research/Advisories/2021-03_CSNC-2021-004_FusionAuth_SAML_Library_XML_External_Entity.txt",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:33.549685",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "fusionauth-samlv2",
    "owner": "FusionAuth",
    "created_at": "2013-06-27T19:30:47Z",
    "updated_at": "2024-12-16T21:49:03Z",
    "pushed_at": "2024-12-16T21:55:57Z",
    "size": 540,
    "stars": 9,
    "forks": 2,
    "open_issues": 0,
    "watchers": 9,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Java": 882512
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:36:21.645866"
  }
}