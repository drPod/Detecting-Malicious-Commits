{
  "cve_id": "CVE-2021-29463",
  "github_data": {
    "repository": "Exiv2/exiv2",
    "fix_commit": "783b3a6ff15ed6f82a8f8e6c8a6f3b84a9b04d4b",
    "related_commits": [
      "783b3a6ff15ed6f82a8f8e6c8a6f3b84a9b04d4b",
      "783b3a6ff15ed6f82a8f8e6c8a6f3b84a9b04d4b"
    ],
    "patch_url": "https://github.com/Exiv2/exiv2/commit/783b3a6ff15ed6f82a8f8e6c8a6f3b84a9b04d4b.patch",
    "fix_commit_details": {
      "sha": "783b3a6ff15ed6f82a8f8e6c8a6f3b84a9b04d4b",
      "commit_date": "2021-04-19T17:06:00Z",
      "author": {
        "login": "kevinbackhouse",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Improve bound checking in WebPImage::doWriteMetadata()",
        "length": 54,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 41,
        "additions": 30,
        "deletions": 11
      },
      "files": [
        {
          "filename": "src/webpimage.cpp",
          "status": "modified",
          "additions": 30,
          "deletions": 11,
          "patch": "@@ -145,7 +145,7 @@ namespace Exiv2 {\n         DataBuf chunkId(WEBP_TAG_SIZE+1);\n         chunkId.pData_ [WEBP_TAG_SIZE] = '\\0';\n \n-        io_->read(data, WEBP_TAG_SIZE * 3);\n+        readOrThrow(*io_, data, WEBP_TAG_SIZE * 3, Exiv2::kerCorruptedMetadata);\n         uint64_t filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian);\n \n         /* Set up header */\n@@ -185,20 +185,28 @@ namespace Exiv2 {\n          case we have any exif or xmp data, also check\n          for any chunks with alpha frame/layer set */\n         while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n-            io_->read(chunkId.pData_, WEBP_TAG_SIZE);\n-            io_->read(size_buff, WEBP_TAG_SIZE);\n-            long size = Exiv2::getULong(size_buff, littleEndian);\n+            readOrThrow(*io_, chunkId.pData_, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);\n+            readOrThrow(*io_, size_buff, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);\n+            const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);\n+\n+            // Check that `size_u32` is safe to cast to `long`.\n+            enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),\n+                    Exiv2::kerCorruptedMetadata);\n+            const long size = static_cast<long>(size_u32);\n             DataBuf payload(size);\n-            io_->read(payload.pData_, payload.size_);\n-            byte c;\n-            if ( payload.size_ % 2 ) io_->read(&c,1);\n+            readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n+            if ( payload.size_ % 2 ) {\n+              byte c;\n+              readOrThrow(*io_, &c, 1, Exiv2::kerCorruptedMetadata);\n+            }\n \n             /* Chunk with information about features\n              used in the file. */\n             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_vp8x) {\n                 has_vp8x = true;\n             }\n             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_size) {\n+                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n                 has_size = true;\n                 byte size_buf[WEBP_TAG_SIZE];\n \n@@ -227,6 +235,7 @@ namespace Exiv2 {\n             }\n #endif\n             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_size) {\n+                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n                 has_size = true;\n                 byte size_buf[2];\n \n@@ -244,11 +253,13 @@ namespace Exiv2 {\n \n             /* Chunk with with lossless image data. */\n             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_alpha) {\n+                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n                 if ((payload.pData_[4] & WEBP_VP8X_ALPHA_BIT) == WEBP_VP8X_ALPHA_BIT) {\n                     has_alpha = true;\n                 }\n             }\n             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_size) {\n+                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n                 has_size = true;\n                 byte size_buf_w[2];\n                 byte size_buf_h[3];\n@@ -276,11 +287,13 @@ namespace Exiv2 {\n \n             /* Chunk with animation frame. */\n             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_alpha) {\n+                enforce(size >= 6, Exiv2::kerCorruptedMetadata);\n                 if ((payload.pData_[5] & 0x2) == 0x2) {\n                     has_alpha = true;\n                 }\n             }\n             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_size) {\n+                enforce(size >= 12, Exiv2::kerCorruptedMetadata);\n                 has_size = true;\n                 byte size_buf[WEBP_TAG_SIZE];\n \n@@ -309,16 +322,22 @@ namespace Exiv2 {\n \n         io_->seek(12, BasicIo::beg);\n         while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n-            io_->read(chunkId.pData_, 4);\n-            io_->read(size_buff, 4);\n+            readOrThrow(*io_, chunkId.pData_, 4, Exiv2::kerCorruptedMetadata);\n+            readOrThrow(*io_, size_buff, 4, Exiv2::kerCorruptedMetadata);\n+\n+            const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);\n \n-            long size = Exiv2::getULong(size_buff, littleEndian);\n+            // Check that `size_u32` is safe to cast to `long`.\n+            enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),\n+                    Exiv2::kerCorruptedMetadata);\n+            const long size = static_cast<long>(size_u32);\n \n             DataBuf payload(size);\n-            io_->read(payload.pData_, size);\n+            readOrThrow(*io_, payload.pData_, size, Exiv2::kerCorruptedMetadata);\n             if ( io_->tell() % 2 ) io_->seek(+1,BasicIo::cur); // skip pad\n \n             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X)) {\n+                enforce(size >= 1, Exiv2::kerCorruptedMetadata);\n                 if (has_icc){\n                     payload.pData_[0] |= WEBP_VP8X_ICC_BIT;\n                 } else {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "a1b65bbddb1b10c4525b267af7f806408afd8b09",
            "date": "2025-01-13T18:45:29Z",
            "author_login": "kamiccolo"
          },
          {
            "sha": "cf64c2cca727195b5ee27f3438916dec3830a0d4",
            "date": "2025-01-12T05:43:43Z",
            "author_login": "neheb"
          },
          {
            "sha": "289eb76313f866aad94cc0cdf187a86be41b2046",
            "date": "2023-11-26T20:48:52Z",
            "author_login": "neheb"
          },
          {
            "sha": "9635d6fbbe19ab5f09649056b1cd6631396ddef2",
            "date": "2025-01-07T22:09:12Z",
            "author_login": "neheb"
          },
          {
            "sha": "0c7b34b1baf9673da86f109ec50cb4eeb36f4e99",
            "date": "2025-01-07T03:44:17Z",
            "author_login": "neheb"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.3,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N",
    "cwe_id": "CWE-125",
    "description": "Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. An out-of-bounds read was found in Exiv2 versions v0.27.3 and earlier. The out-of-bounds read is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to cause a denial of service by crashing Exiv2, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as `insert`. The bug is fixed in version v0.27.4.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-04-30T19:15:07.143",
    "last_modified": "2024-11-21T06:01:09.907",
    "fix_date": "2021-04-19T17:06:00Z"
  },
  "references": [
    {
      "url": "https://github.com/Exiv2/exiv2/commit/783b3a6ff15ed6f82a8f8e6c8a6f3b84a9b04d4b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Exiv2/exiv2/security/advisories/GHSA-5p8g-9xf3-gfrr",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/K3HKXR6JOVKMBE4HY4FDXNVZGNCQG6T3/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NDMZTVQAZSMLPTDVDYLBHAAF7I5QXVYQ/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202312-06",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/Exiv2/exiv2/commit/783b3a6ff15ed6f82a8f8e6c8a6f3b84a9b04d4b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Exiv2/exiv2/security/advisories/GHSA-5p8g-9xf3-gfrr",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/K3HKXR6JOVKMBE4HY4FDXNVZGNCQG6T3/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NDMZTVQAZSMLPTDVDYLBHAAF7I5QXVYQ/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202312-06",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:57.060012",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "exiv2",
    "owner": "Exiv2",
    "created_at": "2017-04-27T17:25:13Z",
    "updated_at": "2025-01-13T23:55:45Z",
    "pushed_at": "2025-01-14T10:46:44Z",
    "size": 127560,
    "stars": 962,
    "forks": 285,
    "open_issues": 173,
    "watchers": 962,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "0.25",
      "0.26",
      "0.27-maintenance",
      "0.28.x",
      "main",
      "old-master"
    ],
    "languages": {
      "C++": 4307014,
      "Python": 937259,
      "CMake": 69364,
      "C": 36920,
      "Meson": 13972,
      "Shell": 8085,
      "Batchfile": 914,
      "CodeQL": 599,
      "QMake": 392,
      "sed": 370
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:14:17.965961"
  }
}