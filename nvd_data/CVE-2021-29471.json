{
  "cve_id": "CVE-2021-29471",
  "github_data": {
    "repository": "matrix-org/synapse",
    "fix_commit": "03318a766cac9f8b053db2214d9c332a977d226c",
    "related_commits": [
      "03318a766cac9f8b053db2214d9c332a977d226c",
      "03318a766cac9f8b053db2214d9c332a977d226c"
    ],
    "patch_url": "https://github.com/matrix-org/synapse/commit/03318a766cac9f8b053db2214d9c332a977d226c.patch",
    "fix_commit_details": {
      "sha": "03318a766cac9f8b053db2214d9c332a977d226c",
      "commit_date": "2021-05-11T09:47:23Z",
      "author": {
        "login": "richvdh",
        "type": "User",
        "stats": {
          "total_commits": 3503,
          "average_weekly_commits": 6.427522935779817,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 303
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-x345-32rc-8h85",
        "length": 891,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 364,
        "additions": 296,
        "deletions": 68
      },
      "files": [
        {
          "filename": "synapse/config/tls.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -17,7 +17,7 @@\n import warnings\n from datetime import datetime\n from hashlib import sha256\n-from typing import List, Optional\n+from typing import List, Optional, Pattern\n \n from unpaddedbase64 import encode_base64\n \n@@ -124,7 +124,7 @@ def read_config(self, config: dict, config_dir_path: str, **kwargs):\n             fed_whitelist_entries = []\n \n         # Support globs (*) in whitelist values\n-        self.federation_certificate_verification_whitelist = []  # type: List[str]\n+        self.federation_certificate_verification_whitelist = []  # type: List[Pattern]\n         for entry in fed_whitelist_entries:\n             try:\n                 entry_regex = glob_to_regex(entry.encode(\"ascii\").decode(\"ascii\"))"
        },
        {
          "filename": "synapse/push/push_rule_evaluator.py",
          "status": "modified",
          "additions": 3,
          "deletions": 52,
          "patch": "@@ -19,6 +19,7 @@\n \n from synapse.events import EventBase\n from synapse.types import UserID\n+from synapse.util import glob_to_regex, re_word_boundary\n from synapse.util.caches.lrucache import LruCache\n \n logger = logging.getLogger(__name__)\n@@ -183,7 +184,7 @@ def _contains_display_name(self, display_name: str) -> bool:\n         r = regex_cache.get((display_name, False, True), None)\n         if not r:\n             r1 = re.escape(display_name)\n-            r1 = _re_word_boundary(r1)\n+            r1 = re_word_boundary(r1)\n             r = re.compile(r1, flags=re.IGNORECASE)\n             regex_cache[(display_name, False, True)] = r\n \n@@ -212,64 +213,14 @@ def _glob_matches(glob: str, value: str, word_boundary: bool = False) -> bool:\n     try:\n         r = regex_cache.get((glob, True, word_boundary), None)\n         if not r:\n-            r = _glob_to_re(glob, word_boundary)\n+            r = glob_to_regex(glob, word_boundary)\n             regex_cache[(glob, True, word_boundary)] = r\n         return bool(r.search(value))\n     except re.error:\n         logger.warning(\"Failed to parse glob to regex: %r\", glob)\n         return False\n \n \n-def _glob_to_re(glob: str, word_boundary: bool) -> Pattern:\n-    \"\"\"Generates regex for a given glob.\n-\n-    Args:\n-        glob\n-        word_boundary: Whether to match against word boundaries or entire string.\n-    \"\"\"\n-    if IS_GLOB.search(glob):\n-        r = re.escape(glob)\n-\n-        r = r.replace(r\"\\*\", \".*?\")\n-        r = r.replace(r\"\\?\", \".\")\n-\n-        # handle [abc], [a-z] and [!a-z] style ranges.\n-        r = GLOB_REGEX.sub(\n-            lambda x: (\n-                \"[%s%s]\" % (x.group(1) and \"^\" or \"\", x.group(2).replace(r\"\\\\\\-\", \"-\"))\n-            ),\n-            r,\n-        )\n-        if word_boundary:\n-            r = _re_word_boundary(r)\n-\n-            return re.compile(r, flags=re.IGNORECASE)\n-        else:\n-            r = \"^\" + r + \"$\"\n-\n-            return re.compile(r, flags=re.IGNORECASE)\n-    elif word_boundary:\n-        r = re.escape(glob)\n-        r = _re_word_boundary(r)\n-\n-        return re.compile(r, flags=re.IGNORECASE)\n-    else:\n-        r = \"^\" + re.escape(glob) + \"$\"\n-        return re.compile(r, flags=re.IGNORECASE)\n-\n-\n-def _re_word_boundary(r: str) -> str:\n-    \"\"\"\n-    Adds word boundary characters to the start and end of an\n-    expression to require that the match occur as a whole word,\n-    but do so respecting the fact that strings starting or ending\n-    with non-word characters will change word boundaries.\n-    \"\"\"\n-    # we can't use \\b as it chokes on unicode. however \\W seems to be okay\n-    # as shorthand for [^0-9A-Za-z_].\n-    return r\"(^|\\W)%s(\\W|$)\" % (r,)\n-\n-\n def _flatten_dict(\n     d: Union[EventBase, dict],\n     prefix: Optional[List[str]] = None,"
        },
        {
          "filename": "synapse/util/__init__.py",
          "status": "modified",
          "additions": 47,
          "deletions": 14,
          "patch": "@@ -15,6 +15,7 @@\n import json\n import logging\n import re\n+from typing import Pattern\n \n import attr\n from frozendict import frozendict\n@@ -26,6 +27,9 @@\n logger = logging.getLogger(__name__)\n \n \n+_WILDCARD_RUN = re.compile(r\"([\\?\\*]+)\")\n+\n+\n def _reject_invalid_json(val):\n     \"\"\"Do not allow Infinity, -Infinity, or NaN values in JSON.\"\"\"\n     raise ValueError(\"Invalid JSON value: '%s'\" % val)\n@@ -158,25 +162,54 @@ def log_failure(failure, msg, consumeErrors=True):\n         return failure\n \n \n-def glob_to_regex(glob):\n+def glob_to_regex(glob: str, word_boundary: bool = False) -> Pattern:\n     \"\"\"Converts a glob to a compiled regex object.\n \n-    The regex is anchored at the beginning and end of the string.\n-\n     Args:\n-        glob (str)\n+        glob: pattern to match\n+        word_boundary: If True, the pattern will be allowed to match at word boundaries\n+           anywhere in the string. Otherwise, the pattern is anchored at the start and\n+           end of the string.\n \n     Returns:\n-        re.RegexObject\n+        compiled regex pattern\n     \"\"\"\n-    res = \"\"\n-    for c in glob:\n-        if c == \"*\":\n-            res = res + \".*\"\n-        elif c == \"?\":\n-            res = res + \".\"\n+\n+    # Patterns with wildcards must be simplified to avoid performance cliffs\n+    # - The glob `?**?**?` is equivalent to the glob `???*`\n+    # - The glob `???*` is equivalent to the regex `.{3,}`\n+    chunks = []\n+    for chunk in _WILDCARD_RUN.split(glob):\n+        # No wildcards? re.escape()\n+        if not _WILDCARD_RUN.match(chunk):\n+            chunks.append(re.escape(chunk))\n+            continue\n+\n+        # Wildcards? Simplify.\n+        qmarks = chunk.count(\"?\")\n+        if \"*\" in chunk:\n+            chunks.append(\".{%d,}\" % qmarks)\n         else:\n-            res = res + re.escape(c)\n+            chunks.append(\".{%d}\" % qmarks)\n+\n+    res = \"\".join(chunks)\n \n-    # \\A anchors at start of string, \\Z at end of string\n-    return re.compile(r\"\\A\" + res + r\"\\Z\", re.IGNORECASE)\n+    if word_boundary:\n+        res = re_word_boundary(res)\n+    else:\n+        # \\A anchors at start of string, \\Z at end of string\n+        res = r\"\\A\" + res + r\"\\Z\"\n+\n+    return re.compile(res, re.IGNORECASE)\n+\n+\n+def re_word_boundary(r: str) -> str:\n+    \"\"\"\n+    Adds word boundary characters to the start and end of an\n+    expression to require that the match occur as a whole word,\n+    but do so respecting the fact that strings starting or ending\n+    with non-word characters will change word boundaries.\n+    \"\"\"\n+    # we can't use \\b as it chokes on unicode. however \\W seems to be okay\n+    # as shorthand for [^0-9A-Za-z_].\n+    return r\"(^|\\W)%s(\\W|$)\" % (r,)"
        },
        {
          "filename": "tests/federation/test_federation_server.py",
          "status": "modified",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -74,6 +74,25 @@ def test_block_ip_literals(self):\n         self.assertFalse(server_matches_acl_event(\"[1:2::]\", e))\n         self.assertTrue(server_matches_acl_event(\"1:2:3:4\", e))\n \n+    def test_wildcard_matching(self):\n+        e = _create_acl_event({\"allow\": [\"good*.com\"]})\n+        self.assertTrue(\n+            server_matches_acl_event(\"good.com\", e),\n+            \"* matches 0 characters\",\n+        )\n+        self.assertTrue(\n+            server_matches_acl_event(\"GOOD.COM\", e),\n+            \"pattern is case-insensitive\",\n+        )\n+        self.assertTrue(\n+            server_matches_acl_event(\"good.aa.com\", e),\n+            \"* matches several characters, including '.'\",\n+        )\n+        self.assertFalse(\n+            server_matches_acl_event(\"ishgood.com\", e),\n+            \"pattern does not allow prefixes\",\n+        )\n+\n \n class StateQueryTests(unittest.FederatingHomeserverTestCase):\n "
        },
        {
          "filename": "tests/push/test_push_rule_evaluator.py",
          "status": "modified",
          "additions": 166,
          "deletions": 0,
          "patch": "@@ -12,6 +12,8 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n+from typing import Any, Dict\n+\n from synapse.api.room_versions import RoomVersions\n from synapse.events import FrozenEvent\n from synapse.push import push_rule_evaluator\n@@ -66,6 +68,170 @@ def test_display_name(self):\n         # A display name with spaces should work fine.\n         self.assertTrue(evaluator.matches(condition, \"@user:test\", \"foo bar\"))\n \n+    def _assert_matches(\n+        self, condition: Dict[str, Any], content: Dict[str, Any], msg=None\n+    ) -> None:\n+        evaluator = self._get_evaluator(content)\n+        self.assertTrue(evaluator.matches(condition, \"@user:test\", \"display_name\"), msg)\n+\n+    def _assert_not_matches(\n+        self, condition: Dict[str, Any], content: Dict[str, Any], msg=None\n+    ) -> None:\n+        evaluator = self._get_evaluator(content)\n+        self.assertFalse(\n+            evaluator.matches(condition, \"@user:test\", \"display_name\"), msg\n+        )\n+\n+    def test_event_match_body(self):\n+        \"\"\"Check that event_match conditions on content.body work as expected\"\"\"\n+\n+        # if the key is `content.body`, the pattern matches substrings.\n+\n+        # non-wildcards should match\n+        condition = {\n+            \"kind\": \"event_match\",\n+            \"key\": \"content.body\",\n+            \"pattern\": \"foobaz\",\n+        }\n+        self._assert_matches(\n+            condition,\n+            {\"body\": \"aaa FoobaZ zzz\"},\n+            \"patterns should match and be case-insensitive\",\n+        )\n+        self._assert_not_matches(\n+            condition,\n+            {\"body\": \"aa xFoobaZ yy\"},\n+            \"pattern should only match at word boundaries\",\n+        )\n+        self._assert_not_matches(\n+            condition,\n+            {\"body\": \"aa foobazx yy\"},\n+            \"pattern should only match at word boundaries\",\n+        )\n+\n+        # wildcards should match\n+        condition = {\n+            \"kind\": \"event_match\",\n+            \"key\": \"content.body\",\n+            \"pattern\": \"f?o*baz\",\n+        }\n+\n+        self._assert_matches(\n+            condition,\n+            {\"body\": \"aaa FoobarbaZ zzz\"},\n+            \"* should match string and pattern should be case-insensitive\",\n+        )\n+        self._assert_matches(\n+            condition, {\"body\": \"aa foobaz yy\"}, \"* should match 0 characters\"\n+        )\n+        self._assert_not_matches(\n+            condition, {\"body\": \"aa fobbaz yy\"}, \"? should not match 0 characters\"\n+        )\n+        self._assert_not_matches(\n+            condition, {\"body\": \"aa fiiobaz yy\"}, \"? should not match 2 characters\"\n+        )\n+        self._assert_not_matches(\n+            condition,\n+            {\"body\": \"aa xfooxbaz yy\"},\n+            \"pattern should only match at word boundaries\",\n+        )\n+        self._assert_not_matches(\n+            condition,\n+            {\"body\": \"aa fooxbazx yy\"},\n+            \"pattern should only match at word boundaries\",\n+        )\n+\n+        # test backslashes\n+        condition = {\n+            \"kind\": \"event_match\",\n+            \"key\": \"content.body\",\n+            \"pattern\": r\"f\\oobaz\",\n+        }\n+        self._assert_matches(\n+            condition,\n+            {\"body\": r\"F\\oobaz\"},\n+            \"backslash should match itself\",\n+        )\n+        condition = {\n+            \"kind\": \"event_match\",\n+            \"key\": \"content.body\",\n+            \"pattern\": r\"f\\?obaz\",\n+        }\n+        self._assert_matches(\n+            condition,\n+            {\"body\": r\"F\\oobaz\"},\n+            r\"? after \\ should match any character\",\n+        )\n+\n+    def test_event_match_non_body(self):\n+        \"\"\"Check that event_match conditions on other keys work as expected\"\"\"\n+\n+        # if the key is anything other than 'content.body', the pattern must match the\n+        # whole value.\n+\n+        # non-wildcards should match\n+        condition = {\n+            \"kind\": \"event_match\",\n+            \"key\": \"content.value\",\n+            \"pattern\": \"foobaz\",\n+        }\n+        self._assert_matches(\n+            condition,\n+            {\"value\": \"FoobaZ\"},\n+            \"patterns should match and be case-insensitive\",\n+        )\n+        self._assert_not_matches(\n+            condition,\n+            {\"value\": \"xFoobaZ\"},\n+            \"pattern should only match at the start/end of the value\",\n+        )\n+        self._assert_not_matches(\n+            condition,\n+            {\"value\": \"FoobaZz\"},\n+            \"pattern should only match at the start/end of the value\",\n+        )\n+\n+        # wildcards should match\n+        condition = {\n+            \"kind\": \"event_match\",\n+            \"key\": \"content.value\",\n+            \"pattern\": \"f?o*baz\",\n+        }\n+        self._assert_matches(\n+            condition,\n+            {\"value\": \"FoobarbaZ\"},\n+            \"* should match string and pattern should be case-insensitive\",\n+        )\n+        self._assert_matches(\n+            condition, {\"value\": \"foobaz\"}, \"* should match 0 characters\"\n+        )\n+        self._assert_not_matches(\n+            condition, {\"value\": \"fobbaz\"}, \"? should not match 0 characters\"\n+        )\n+        self._assert_not_matches(\n+            condition, {\"value\": \"fiiobaz\"}, \"? should not match 2 characters\"\n+        )\n+        self._assert_not_matches(\n+            condition,\n+            {\"value\": \"xfooxbaz\"},\n+            \"pattern should only match at the start/end of the value\",\n+        )\n+        self._assert_not_matches(\n+            condition,\n+            {\"value\": \"fooxbazx\"},\n+            \"pattern should only match at the start/end of the value\",\n+        )\n+        self._assert_not_matches(\n+            condition,\n+            {\"value\": \"x\\nfooxbaz\"},\n+            \"pattern should not match after a newline\",\n+        )\n+        self._assert_not_matches(\n+            condition,\n+            {\"value\": \"fooxbaz\\nx\"},\n+            \"pattern should not match before a newline\",\n+        )\n+\n     def test_no_body(self):\n         \"\"\"Not having a body shouldn't break the evaluator.\"\"\"\n         evaluator = self._get_evaluator({})"
        },
        {
          "filename": "tests/util/test_glob_to_regex.py",
          "status": "added",
          "additions": 59,
          "deletions": 0,
          "patch": "@@ -0,0 +1,59 @@\n+# Copyright 2021 The Matrix.org Foundation C.I.C.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from synapse.util import glob_to_regex\n+\n+from tests.unittest import TestCase\n+\n+\n+class GlobToRegexTestCase(TestCase):\n+    def test_literal_match(self):\n+        \"\"\"patterns without wildcards should match\"\"\"\n+        pat = glob_to_regex(\"foobaz\")\n+        self.assertTrue(\n+            pat.match(\"FoobaZ\"), \"patterns should match and be case-insensitive\"\n+        )\n+        self.assertFalse(\n+            pat.match(\"x foobaz\"), \"pattern should not match at word boundaries\"\n+        )\n+\n+    def test_wildcard_match(self):\n+        pat = glob_to_regex(\"f?o*baz\")\n+\n+        self.assertTrue(\n+            pat.match(\"FoobarbaZ\"),\n+            \"* should match string and pattern should be case-insensitive\",\n+        )\n+        self.assertTrue(pat.match(\"foobaz\"), \"* should match 0 characters\")\n+        self.assertFalse(pat.match(\"fooxaz\"), \"the character after * must match\")\n+        self.assertFalse(pat.match(\"fobbaz\"), \"? should not match 0 characters\")\n+        self.assertFalse(pat.match(\"fiiobaz\"), \"? should not match 2 characters\")\n+\n+    def test_multi_wildcard(self):\n+        \"\"\"patterns with multiple wildcards in a row should match\"\"\"\n+        pat = glob_to_regex(\"**baz\")\n+        self.assertTrue(pat.match(\"agsgsbaz\"), \"** should match any string\")\n+        self.assertTrue(pat.match(\"baz\"), \"** should match the empty string\")\n+        self.assertEqual(pat.pattern, r\"\\A.{0,}baz\\Z\")\n+\n+        pat = glob_to_regex(\"*?baz\")\n+        self.assertTrue(pat.match(\"agsgsbaz\"), \"*? should match any string\")\n+        self.assertTrue(pat.match(\"abaz\"), \"*? should match a single char\")\n+        self.assertFalse(pat.match(\"baz\"), \"*? should not match the empty string\")\n+        self.assertEqual(pat.pattern, r\"\\A.{1,}baz\\Z\")\n+\n+        pat = glob_to_regex(\"a?*?*?baz\")\n+        self.assertTrue(pat.match(\"a g baz\"), \"?*?*? should match 3 chars\")\n+        self.assertFalse(pat.match(\"a..baz\"), \"?*?*? should not match 2 chars\")\n+        self.assertTrue(pat.match(\"a.gg.baz\"), \"?*?*? should match 4 chars\")\n+        self.assertEqual(pat.pattern, r\"\\Aa.{3,}baz\\Z\")"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 6,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "be65a8ec0195955c15fdb179c9158b187638e39a",
            "date": "2023-12-13T14:50:56Z",
            "author_login": "wrjlewis"
          },
          {
            "sha": "66fc265578f4501307edcac2514892ecdf791fc9",
            "date": "2023-12-13T14:47:34Z",
            "author_login": "wrjlewis"
          },
          {
            "sha": "025951bc3b6ddc0a6487ac045cc00a35a9d7eaaa",
            "date": "2023-12-13T14:46:11Z",
            "author_login": "erikjohnston"
          },
          {
            "sha": "70c020b532821f898aaa07c35c5d5ab59055ae1c",
            "date": "2023-12-12T20:32:48Z",
            "author_login": "erikjohnston"
          },
          {
            "sha": "e1f8440c8959719a417fbf1bdda11406cfdf523d",
            "date": "2023-11-21T19:26:47Z",
            "author_login": "clokep"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.7,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-400",
    "description": "Synapse is a Matrix reference homeserver written in python (pypi package matrix-synapse). Matrix is an ecosystem for open federated Instant Messaging and VoIP. In Synapse before version 1.33.2 \"Push rules\" can specify conditions under which they will match, including `event_match`, which matches event content against a pattern including wildcards. Certain patterns can cause very poor performance in the matching engine, leading to a denial-of-service when processing moderate length events. The issue is patched in version 1.33.2. A potential workaround might be to prevent users from making custom push rules, by blocking such requests at a reverse-proxy.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2021-05-11T15:15:08.507",
    "last_modified": "2024-11-21T06:01:11.337",
    "fix_date": "2021-05-11T09:47:23Z"
  },
  "references": [
    {
      "url": "https://github.com/matrix-org/synapse/commit/03318a766cac9f8b053db2214d9c332a977d226c",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/releases/tag/v1.33.2",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/security/advisories/GHSA-x345-32rc-8h85",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TNNAJOZNMVMXM6AS7RFFKB4QLUJ4IFEY/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/matrix-org/synapse/commit/03318a766cac9f8b053db2214d9c332a977d226c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/releases/tag/v1.33.2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/synapse/security/advisories/GHSA-x345-32rc-8h85",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TNNAJOZNMVMXM6AS7RFFKB4QLUJ4IFEY/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:57.074438",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "synapse",
    "owner": "matrix-org",
    "created_at": "2014-08-11T15:51:42Z",
    "updated_at": "2025-01-14T04:04:49Z",
    "pushed_at": "2024-04-26T15:47:23Z",
    "size": 429495,
    "stars": 11851,
    "forks": 2122,
    "open_issues": 1529,
    "watchers": 11851,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [],
    "languages": {
      "Python": 11907179,
      "Rust": 95720,
      "HTML": 64571,
      "Shell": 59187,
      "Perl": 28191,
      "Nix": 12267,
      "Dockerfile": 12096,
      "JavaScript": 11988,
      "Jinja": 7942,
      "CSS": 6211,
      "Makefile": 634,
      "Gherkin": 308,
      "Lua": 241
    },
    "commit_activity": {
      "total_commits_last_year": 1,
      "avg_commits_per_week": 0.019230769230769232,
      "days_active_last_year": 1
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:52:33.725944"
  }
}