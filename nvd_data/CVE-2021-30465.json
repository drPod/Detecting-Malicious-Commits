{
  "cve_id": "CVE-2021-30465",
  "github_data": {
    "repository": "opencontainers/runc",
    "fix_commit": "0ca91f44f1664da834bc61115a849b56d22f595f",
    "related_commits": [
      "0ca91f44f1664da834bc61115a849b56d22f595f",
      "0ca91f44f1664da834bc61115a849b56d22f595f"
    ],
    "patch_url": "https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f.patch",
    "fix_commit_details": {
      "sha": "0ca91f44f1664da834bc61115a849b56d22f595f",
      "commit_date": "2021-04-01T19:00:31Z",
      "author": {
        "login": "cyphar",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "rootfs: add mount destination validation",
        "length": 2569,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 365,
        "additions": 229,
        "deletions": 136
      },
      "files": [
        {
          "filename": "libcontainer/container_linux.go",
          "status": "modified",
          "additions": 16,
          "deletions": 9,
          "patch": "@@ -1217,7 +1217,6 @@ func (c *linuxContainer) makeCriuRestoreMountpoints(m *configs.Mount) error {\n \t\tif err := checkProcMount(c.config.Rootfs, dest, \"\"); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tm.Destination = dest\n \t\tif err := os.MkdirAll(dest, 0755); err != nil {\n \t\t\treturn err\n \t\t}\n@@ -1257,13 +1256,16 @@ func (c *linuxContainer) prepareCriuRestoreMounts(mounts []*configs.Mount) error\n \tumounts := []string{}\n \tdefer func() {\n \t\tfor _, u := range umounts {\n-\t\t\tif e := unix.Unmount(u, unix.MNT_DETACH); e != nil {\n-\t\t\t\tif e != unix.EINVAL {\n-\t\t\t\t\t// Ignore EINVAL as it means 'target is not a mount point.'\n-\t\t\t\t\t// It probably has already been unmounted.\n-\t\t\t\t\tlogrus.Warnf(\"Error during cleanup unmounting of %q (%v)\", u, e)\n+\t\t\t_ = utils.WithProcfd(c.config.Rootfs, u, func(procfd string) error {\n+\t\t\t\tif e := unix.Unmount(procfd, unix.MNT_DETACH); e != nil {\n+\t\t\t\t\tif e != unix.EINVAL {\n+\t\t\t\t\t\t// Ignore EINVAL as it means 'target is not a mount point.'\n+\t\t\t\t\t\t// It probably has already been unmounted.\n+\t\t\t\t\t\tlogrus.Warnf(\"Error during cleanup unmounting of %s (%s): %v\", procfd, u, e)\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t}\n+\t\t\t\treturn nil\n+\t\t\t})\n \t\t}\n \t}()\n \tfor _, m := range mounts {\n@@ -1281,8 +1283,13 @@ func (c *linuxContainer) prepareCriuRestoreMounts(mounts []*configs.Mount) error\n \t\t\t// because during initial container creation mounts are\n \t\t\t// set up in the order they are configured.\n \t\t\tif m.Device == \"bind\" {\n-\t\t\t\tif err := unix.Mount(m.Source, m.Destination, \"\", unix.MS_BIND|unix.MS_REC, \"\"); err != nil {\n-\t\t\t\t\treturn errorsf.Wrapf(err, \"unable to bind mount %q to %q\", m.Source, m.Destination)\n+\t\t\t\tif err := utils.WithProcfd(c.config.Rootfs, m.Destination, func(procfd string) error {\n+\t\t\t\t\tif err := unix.Mount(m.Source, procfd, \"\", unix.MS_BIND|unix.MS_REC, \"\"); err != nil {\n+\t\t\t\t\t\treturn errorsf.Wrapf(err, \"unable to bind mount %q to %q (through %q)\", m.Source, m.Destination, procfd)\n+\t\t\t\t\t}\n+\t\t\t\t\treturn nil\n+\t\t\t\t}); err != nil {\n+\t\t\t\t\treturn err\n \t\t\t\t}\n \t\t\t\tumounts = append(umounts, m.Destination)\n \t\t\t}"
        },
        {
          "filename": "libcontainer/rootfs_linux.go",
          "status": "modified",
          "additions": 124,
          "deletions": 127,
          "patch": "@@ -25,6 +25,7 @@ import (\n \tlibcontainerUtils \"github.com/opencontainers/runc/libcontainer/utils\"\n \t\"github.com/opencontainers/runtime-spec/specs-go\"\n \t\"github.com/opencontainers/selinux/go-selinux/label\"\n+\t\"github.com/sirupsen/logrus\"\n \t\"golang.org/x/sys/unix\"\n )\n \n@@ -228,8 +229,6 @@ func prepareBindMount(m *configs.Mount, rootfs string) error {\n \tif err := checkProcMount(rootfs, dest, m.Source); err != nil {\n \t\treturn err\n \t}\n-\t// update the mount with the correct dest after symlinks are resolved.\n-\tm.Destination = dest\n \tif err := createIfNotExists(dest, stat.IsDir()); err != nil {\n \t\treturn err\n \t}\n@@ -266,18 +265,21 @@ func mountCgroupV1(m *configs.Mount, c *mountConfig) error {\n \t\t\tif err := os.MkdirAll(subsystemPath, 0755); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n-\t\t\tflags := defaultMountFlags\n-\t\t\tif m.Flags&unix.MS_RDONLY != 0 {\n-\t\t\t\tflags = flags | unix.MS_RDONLY\n-\t\t\t}\n-\t\t\tcgroupmount := &configs.Mount{\n-\t\t\t\tSource:      \"cgroup\",\n-\t\t\t\tDevice:      \"cgroup\", // this is actually fstype\n-\t\t\t\tDestination: subsystemPath,\n-\t\t\t\tFlags:       flags,\n-\t\t\t\tData:        filepath.Base(subsystemPath),\n-\t\t\t}\n-\t\t\tif err := mountNewCgroup(cgroupmount); err != nil {\n+\t\t\tif err := utils.WithProcfd(c.root, b.Destination, func(procfd string) error {\n+\t\t\t\tflags := defaultMountFlags\n+\t\t\t\tif m.Flags&unix.MS_RDONLY != 0 {\n+\t\t\t\t\tflags = flags | unix.MS_RDONLY\n+\t\t\t\t}\n+\t\t\t\tvar (\n+\t\t\t\t\tsource = \"cgroup\"\n+\t\t\t\t\tdata   = filepath.Base(subsystemPath)\n+\t\t\t\t)\n+\t\t\t\tif data == \"systemd\" {\n+\t\t\t\t\tdata = cgroups.CgroupNamePrefix + data\n+\t\t\t\t\tsource = \"systemd\"\n+\t\t\t\t}\n+\t\t\t\treturn unix.Mount(source, procfd, \"cgroup\", uintptr(flags), data)\n+\t\t\t}); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t} else {\n@@ -307,33 +309,79 @@ func mountCgroupV2(m *configs.Mount, c *mountConfig) error {\n \tif err := os.MkdirAll(dest, 0755); err != nil {\n \t\treturn err\n \t}\n-\tif err := unix.Mount(m.Source, dest, \"cgroup2\", uintptr(m.Flags), m.Data); err != nil {\n-\t\t// when we are in UserNS but CgroupNS is not unshared, we cannot mount cgroup2 (#2158)\n-\t\tif err == unix.EPERM || err == unix.EBUSY {\n-\t\t\tsrc := fs2.UnifiedMountpoint\n-\t\t\tif c.cgroupns && c.cgroup2Path != \"\" {\n-\t\t\t\t// Emulate cgroupns by bind-mounting\n-\t\t\t\t// the container cgroup path rather than\n-\t\t\t\t// the whole /sys/fs/cgroup.\n-\t\t\t\tsrc = c.cgroup2Path\n-\t\t\t}\n-\t\t\terr = unix.Mount(src, dest, \"\", uintptr(m.Flags)|unix.MS_BIND, \"\")\n-\t\t\tif err == unix.ENOENT && c.rootlessCgroups {\n-\t\t\t\terr = nil\n+\treturn utils.WithProcfd(c.root, m.Destination, func(procfd string) error {\n+\t\tif err := unix.Mount(m.Source, procfd, \"cgroup2\", uintptr(m.Flags), m.Data); err != nil {\n+\t\t\t// when we are in UserNS but CgroupNS is not unshared, we cannot mount cgroup2 (#2158)\n+\t\t\tif err == unix.EPERM || err == unix.EBUSY {\n+\t\t\t\tsrc := fs2.UnifiedMountpoint\n+\t\t\t\tif c.cgroupns && c.cgroup2Path != \"\" {\n+\t\t\t\t\t// Emulate cgroupns by bind-mounting\n+\t\t\t\t\t// the container cgroup path rather than\n+\t\t\t\t\t// the whole /sys/fs/cgroup.\n+\t\t\t\t\tsrc = c.cgroup2Path\n+\t\t\t\t}\n+\t\t\t\terr = unix.Mount(src, procfd, \"\", uintptr(m.Flags)|unix.MS_BIND, \"\")\n+\t\t\t\tif err == unix.ENOENT && c.rootlessCgroups {\n+\t\t\t\t\terr = nil\n+\t\t\t\t}\n \t\t\t}\n \t\t\treturn err\n \t\t}\n+\t\treturn nil\n+\t})\n+}\n+\n+func doTmpfsCopyUp(m *configs.Mount, rootfs, mountLabel string) (Err error) {\n+\t// Set up a scratch dir for the tmpfs on the host.\n+\ttmpdir, err := prepareTmp(\"/tmp\")\n+\tif err != nil {\n+\t\treturn newSystemErrorWithCause(err, \"tmpcopyup: failed to setup tmpdir\")\n+\t}\n+\tdefer cleanupTmp(tmpdir)\n+\ttmpDir, err := ioutil.TempDir(tmpdir, \"runctmpdir\")\n+\tif err != nil {\n+\t\treturn newSystemErrorWithCause(err, \"tmpcopyup: failed to create tmpdir\")\n+\t}\n+\tdefer os.RemoveAll(tmpDir)\n+\n+\t// Configure the *host* tmpdir as if it's the container mount. We change\n+\t// m.Destination since we are going to mount *on the host*.\n+\toldDest := m.Destination\n+\tm.Destination = tmpDir\n+\terr = mountPropagate(m, \"/\", mountLabel)\n+\tm.Destination = oldDest\n+\tif err != nil {\n \t\treturn err\n \t}\n-\treturn nil\n+\tdefer func() {\n+\t\tif Err != nil {\n+\t\t\tif err := unix.Unmount(tmpDir, unix.MNT_DETACH); err != nil {\n+\t\t\t\tlogrus.Warnf(\"tmpcopyup: failed to unmount tmpdir on error: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\treturn utils.WithProcfd(rootfs, m.Destination, func(procfd string) (Err error) {\n+\t\t// Copy the container data to the host tmpdir. We append \"/\" to force\n+\t\t// CopyDirectory to resolve the symlink rather than trying to copy the\n+\t\t// symlink itself.\n+\t\tif err := fileutils.CopyDirectory(procfd+\"/\", tmpDir); err != nil {\n+\t\t\treturn fmt.Errorf(\"tmpcopyup: failed to copy %s to %s (%s): %w\", m.Destination, procfd, tmpDir, err)\n+\t\t}\n+\t\t// Now move the mount into the container.\n+\t\tif err := unix.Mount(tmpDir, procfd, \"\", unix.MS_MOVE, \"\"); err != nil {\n+\t\t\treturn fmt.Errorf(\"tmpcopyup: failed to move mount %s to %s (%s): %w\", tmpDir, procfd, m.Destination, err)\n+\t\t}\n+\t\treturn nil\n+\t})\n }\n \n func mountToRootfs(m *configs.Mount, c *mountConfig) error {\n \trootfs := c.root\n \tmountLabel := c.label\n-\tdest := m.Destination\n-\tif !strings.HasPrefix(dest, rootfs) {\n-\t\tdest = filepath.Join(rootfs, dest)\n+\tdest, err := securejoin.SecureJoin(rootfs, m.Destination)\n+\tif err != nil {\n+\t\treturn err\n \t}\n \n \tswitch m.Device {\n@@ -364,53 +412,21 @@ func mountToRootfs(m *configs.Mount, c *mountConfig) error {\n \t\t}\n \t\treturn label.SetFileLabel(dest, mountLabel)\n \tcase \"tmpfs\":\n-\t\tcopyUp := m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP\n-\t\ttmpDir := \"\"\n-\t\t// dest might be an absolute symlink, so it needs\n-\t\t// to be resolved under rootfs.\n-\t\tdest, err := securejoin.SecureJoin(rootfs, m.Destination)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tm.Destination = dest\n \t\tstat, err := os.Stat(dest)\n \t\tif err != nil {\n \t\t\tif err := os.MkdirAll(dest, 0755); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}\n-\t\tif copyUp {\n-\t\t\ttmpdir, err := prepareTmp(\"/tmp\")\n-\t\t\tif err != nil {\n-\t\t\t\treturn newSystemErrorWithCause(err, \"tmpcopyup: failed to setup tmpdir\")\n-\t\t\t}\n-\t\t\tdefer cleanupTmp(tmpdir)\n-\t\t\ttmpDir, err = ioutil.TempDir(tmpdir, \"runctmpdir\")\n-\t\t\tif err != nil {\n-\t\t\t\treturn newSystemErrorWithCause(err, \"tmpcopyup: failed to create tmpdir\")\n-\t\t\t}\n-\t\t\tdefer os.RemoveAll(tmpDir)\n-\t\t\tm.Destination = tmpDir\n+\n+\t\tif m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP {\n+\t\t\terr = doTmpfsCopyUp(m, rootfs, mountLabel)\n+\t\t} else {\n+\t\t\terr = mountPropagate(m, rootfs, mountLabel)\n \t\t}\n-\t\tif err := mountPropagate(m, rootfs, mountLabel); err != nil {\n+\t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif copyUp {\n-\t\t\tif err := fileutils.CopyDirectory(dest, tmpDir); err != nil {\n-\t\t\t\terrMsg := fmt.Errorf(\"tmpcopyup: failed to copy %s to %s: %v\", dest, tmpDir, err)\n-\t\t\t\tif err1 := unix.Unmount(tmpDir, unix.MNT_DETACH); err1 != nil {\n-\t\t\t\t\treturn newSystemErrorWithCausef(err1, \"tmpcopyup: %v: failed to unmount\", errMsg)\n-\t\t\t\t}\n-\t\t\t\treturn errMsg\n-\t\t\t}\n-\t\t\tif err := unix.Mount(tmpDir, dest, \"\", unix.MS_MOVE, \"\"); err != nil {\n-\t\t\t\terrMsg := fmt.Errorf(\"tmpcopyup: failed to move mount %s to %s: %v\", tmpDir, dest, err)\n-\t\t\t\tif err1 := unix.Unmount(tmpDir, unix.MNT_DETACH); err1 != nil {\n-\t\t\t\t\treturn newSystemErrorWithCausef(err1, \"tmpcopyup: %v: failed to unmount\", errMsg)\n-\t\t\t\t}\n-\t\t\t\treturn errMsg\n-\t\t\t}\n-\t\t}\n \t\tif stat != nil {\n \t\t\tif err = os.Chmod(dest, stat.Mode()); err != nil {\n \t\t\t\treturn err\n@@ -454,19 +470,9 @@ func mountToRootfs(m *configs.Mount, c *mountConfig) error {\n \t\t}\n \t\treturn mountCgroupV1(m, c)\n \tdefault:\n-\t\t// ensure that the destination of the mount is resolved of symlinks at mount time because\n-\t\t// any previous mounts can invalidate the next mount's destination.\n-\t\t// this can happen when a user specifies mounts within other mounts to cause breakouts or other\n-\t\t// evil stuff to try to escape the container's rootfs.\n-\t\tvar err error\n-\t\tif dest, err = securejoin.SecureJoin(rootfs, m.Destination); err != nil {\n-\t\t\treturn err\n-\t\t}\n \t\tif err := checkProcMount(rootfs, dest, m.Source); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\t// update the mount with the correct dest after symlinks are resolved.\n-\t\tm.Destination = dest\n \t\tif err := os.MkdirAll(dest, 0755); err != nil {\n \t\t\treturn err\n \t\t}\n@@ -649,15 +655,17 @@ func createDevices(config *configs.Config) error {\n \treturn nil\n }\n \n-func bindMountDeviceNode(dest string, node *devices.Device) error {\n+func bindMountDeviceNode(rootfs, dest string, node *devices.Device) error {\n \tf, err := os.Create(dest)\n \tif err != nil && !os.IsExist(err) {\n \t\treturn err\n \t}\n \tif f != nil {\n \t\tf.Close()\n \t}\n-\treturn unix.Mount(node.Path, dest, \"bind\", unix.MS_BIND, \"\")\n+\treturn utils.WithProcfd(rootfs, dest, func(procfd string) error {\n+\t\treturn unix.Mount(node.Path, procfd, \"bind\", unix.MS_BIND, \"\")\n+\t})\n }\n \n // Creates the device node in the rootfs of the container.\n@@ -666,18 +674,21 @@ func createDeviceNode(rootfs string, node *devices.Device, bind bool) error {\n \t\t// The node only exists for cgroup reasons, ignore it here.\n \t\treturn nil\n \t}\n-\tdest := filepath.Join(rootfs, node.Path)\n+\tdest, err := securejoin.SecureJoin(rootfs, node.Path)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tif err := os.MkdirAll(filepath.Dir(dest), 0755); err != nil {\n \t\treturn err\n \t}\n \tif bind {\n-\t\treturn bindMountDeviceNode(dest, node)\n+\t\treturn bindMountDeviceNode(rootfs, dest, node)\n \t}\n \tif err := mknodDevice(dest, node); err != nil {\n \t\tif os.IsExist(err) {\n \t\t\treturn nil\n \t\t} else if os.IsPermission(err) {\n-\t\t\treturn bindMountDeviceNode(dest, node)\n+\t\t\treturn bindMountDeviceNode(rootfs, dest, node)\n \t\t}\n \t\treturn err\n \t}\n@@ -1024,61 +1035,47 @@ func writeSystemProperty(key, value string) error {\n }\n \n func remount(m *configs.Mount, rootfs string) error {\n-\tvar (\n-\t\tdest = m.Destination\n-\t)\n-\tif !strings.HasPrefix(dest, rootfs) {\n-\t\tdest = filepath.Join(rootfs, dest)\n-\t}\n-\treturn unix.Mount(m.Source, dest, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")\n+\treturn utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n+\t\treturn unix.Mount(m.Source, procfd, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")\n+\t})\n }\n \n // Do the mount operation followed by additional mounts required to take care\n-// of propagation flags.\n+// of propagation flags. This will always be scoped inside the container rootfs.\n func mountPropagate(m *configs.Mount, rootfs string, mountLabel string) error {\n \tvar (\n-\t\tdest  = m.Destination\n \t\tdata  = label.FormatMountLabel(m.Data, mountLabel)\n \t\tflags = m.Flags\n \t)\n-\tif libcontainerUtils.CleanPath(dest) == \"/dev\" {\n-\t\tflags &= ^unix.MS_RDONLY\n-\t}\n-\n-\t// Mount it rw to allow chmod operation. A remount will be performed\n-\t// later to make it ro if set.\n-\tif m.Device == \"tmpfs\" {\n+\t// Delay mounting the filesystem read-only if we need to do further\n+\t// operations on it. We need to set up files in \"/dev\" and tmpfs mounts may\n+\t// need to be chmod-ed after mounting. The mount will be remounted ro later\n+\t// in finalizeRootfs() if necessary.\n+\tif libcontainerUtils.CleanPath(m.Destination) == \"/dev\" || m.Device == \"tmpfs\" {\n \t\tflags &= ^unix.MS_RDONLY\n \t}\n \n-\tcopyUp := m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP\n-\tif !(copyUp || strings.HasPrefix(dest, rootfs)) {\n-\t\tdest = filepath.Join(rootfs, dest)\n-\t}\n-\n-\tif err := unix.Mount(m.Source, dest, m.Device, uintptr(flags), data); err != nil {\n-\t\treturn err\n-\t}\n-\n-\tfor _, pflag := range m.PropagationFlags {\n-\t\tif err := unix.Mount(\"\", dest, \"\", uintptr(pflag), \"\"); err != nil {\n-\t\t\treturn err\n+\t// Because the destination is inside a container path which might be\n+\t// mutating underneath us, we verify that we are actually going to mount\n+\t// inside the container with WithProcfd() -- mounting through a procfd\n+\t// mounts on the target.\n+\tif err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n+\t\treturn unix.Mount(m.Source, procfd, m.Device, uintptr(flags), data)\n+\t}); err != nil {\n+\t\treturn fmt.Errorf(\"mount through procfd: %w\", err)\n+\t}\n+\t// We have to apply mount propagation flags in a separate WithProcfd() call\n+\t// because the previous call invalidates the passed procfd -- the mount\n+\t// target needs to be re-opened.\n+\tif err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n+\t\tfor _, pflag := range m.PropagationFlags {\n+\t\t\tif err := unix.Mount(\"\", procfd, \"\", uintptr(pflag), \"\"); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n \t\t}\n-\t}\n-\treturn nil\n-}\n-\n-func mountNewCgroup(m *configs.Mount) error {\n-\tvar (\n-\t\tdata   = m.Data\n-\t\tsource = m.Source\n-\t)\n-\tif data == \"systemd\" {\n-\t\tdata = cgroups.CgroupNamePrefix + data\n-\t\tsource = \"systemd\"\n-\t}\n-\tif err := unix.Mount(source, m.Destination, m.Device, uintptr(m.Flags), data); err != nil {\n-\t\treturn err\n+\t\treturn nil\n+\t}); err != nil {\n+\t\treturn fmt.Errorf(\"change mount propagation through procfd: %w\", err)\n \t}\n \treturn nil\n }"
        },
        {
          "filename": "libcontainer/utils/utils.go",
          "status": "modified",
          "additions": 54,
          "deletions": 0,
          "patch": "@@ -3,12 +3,15 @@ package utils\n import (\n \t\"encoding/binary\"\n \t\"encoding/json\"\n+\t\"fmt\"\n \t\"io\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"unsafe\"\n \n+\t\"github.com/cyphar/filepath-securejoin\"\n \t\"golang.org/x/sys/unix\"\n )\n \n@@ -88,6 +91,57 @@ func CleanPath(path string) string {\n \treturn filepath.Clean(path)\n }\n \n+// stripRoot returns the passed path, stripping the root path if it was\n+// (lexicially) inside it. Note that both passed paths will always be treated\n+// as absolute, and the returned path will also always be absolute. In\n+// addition, the paths are cleaned before stripping the root.\n+func stripRoot(root, path string) string {\n+\t// Make the paths clean and absolute.\n+\troot, path = CleanPath(\"/\"+root), CleanPath(\"/\"+path)\n+\tswitch {\n+\tcase path == root:\n+\t\tpath = \"/\"\n+\tcase root == \"/\":\n+\t\t// do nothing\n+\tcase strings.HasPrefix(path, root+\"/\"):\n+\t\tpath = strings.TrimPrefix(path, root+\"/\")\n+\t}\n+\treturn CleanPath(\"/\" + path)\n+}\n+\n+// WithProcfd runs the passed closure with a procfd path (/proc/self/fd/...)\n+// corresponding to the unsafePath resolved within the root. Before passing the\n+// fd, this path is verified to have been inside the root -- so operating on it\n+// through the passed fdpath should be safe. Do not access this path through\n+// the original path strings, and do not attempt to use the pathname outside of\n+// the passed closure (the file handle will be freed once the closure returns).\n+func WithProcfd(root, unsafePath string, fn func(procfd string) error) error {\n+\t// Remove the root then forcefully resolve inside the root.\n+\tunsafePath = stripRoot(root, unsafePath)\n+\tpath, err := securejoin.SecureJoin(root, unsafePath)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"resolving path inside rootfs failed: %v\", err)\n+\t}\n+\n+\t// Open the target path.\n+\tfh, err := os.OpenFile(path, unix.O_PATH|unix.O_CLOEXEC, 0)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"open o_path procfd: %w\", err)\n+\t}\n+\tdefer fh.Close()\n+\n+\t// Double-check the path is the one we expected.\n+\tprocfd := \"/proc/self/fd/\" + strconv.Itoa(int(fh.Fd()))\n+\tif realpath, err := os.Readlink(procfd); err != nil {\n+\t\treturn fmt.Errorf(\"procfd verification failed: %w\", err)\n+\t} else if realpath != path {\n+\t\treturn fmt.Errorf(\"possibly malicious path detected -- refusing to operate on %s\", realpath)\n+\t}\n+\n+\t// Run the closure.\n+\treturn fn(procfd)\n+}\n+\n // SearchLabels searches a list of key-value pairs for the provided key and\n // returns the corresponding value. The pairs must be separated with '='.\n func SearchLabels(labels []string, query string) string {"
        },
        {
          "filename": "libcontainer/utils/utils_test.go",
          "status": "modified",
          "additions": 35,
          "deletions": 0,
          "patch": "@@ -143,3 +143,38 @@ func TestCleanPath(t *testing.T) {\n \t\tt.Errorf(\"expected to receive '/foo' and received %s\", path)\n \t}\n }\n+\n+func TestStripRoot(t *testing.T) {\n+\tfor _, test := range []struct {\n+\t\troot, path, out string\n+\t}{\n+\t\t// Works with multiple components.\n+\t\t{\"/a/b\", \"/a/b/c\", \"/c\"},\n+\t\t{\"/hello/world\", \"/hello/world/the/quick-brown/fox\", \"/the/quick-brown/fox\"},\n+\t\t// '/' must be a no-op.\n+\t\t{\"/\", \"/a/b/c\", \"/a/b/c\"},\n+\t\t// Must be the correct order.\n+\t\t{\"/a/b\", \"/a/c/b\", \"/a/c/b\"},\n+\t\t// Must be at start.\n+\t\t{\"/abc/def\", \"/foo/abc/def/bar\", \"/foo/abc/def/bar\"},\n+\t\t// Must be a lexical parent.\n+\t\t{\"/foo/bar\", \"/foo/barSAMECOMPONENT\", \"/foo/barSAMECOMPONENT\"},\n+\t\t// Must only strip the root once.\n+\t\t{\"/foo/bar\", \"/foo/bar/foo/bar/baz\", \"/foo/bar/baz\"},\n+\t\t// Deal with .. in a fairly sane way.\n+\t\t{\"/foo/bar\", \"/foo/bar/../baz\", \"/foo/baz\"},\n+\t\t{\"/foo/bar\", \"../../../../../../foo/bar/baz\", \"/baz\"},\n+\t\t{\"/foo/bar\", \"/../../../../../../foo/bar/baz\", \"/baz\"},\n+\t\t{\"/foo/bar/../baz\", \"/foo/baz/bar\", \"/bar\"},\n+\t\t{\"/foo/bar/../baz\", \"/foo/baz/../bar/../baz/./foo\", \"/foo\"},\n+\t\t// All paths are made absolute before stripping.\n+\t\t{\"foo/bar\", \"/foo/bar/baz/bee\", \"/baz/bee\"},\n+\t\t{\"/foo/bar\", \"foo/bar/baz/beef\", \"/baz/beef\"},\n+\t\t{\"foo/bar\", \"foo/bar/baz/beets\", \"/baz/beets\"},\n+\t} {\n+\t\tgot := stripRoot(test.root, test.path)\n+\t\tif got != test.out {\n+\t\t\tt.Errorf(\"stripRoot(%q, %q) -- got %q, expected %q\", test.root, test.path, got, test.out)\n+\t\t}\n+\t}\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "610aa88ab201f289c05c2e262912d0630f46eb35",
            "date": "2025-01-10T20:23:22Z",
            "author_login": "kolyshkin"
          },
          {
            "sha": "4120935737a51cbf23676977cc8bf0b6717702f1",
            "date": "2025-01-09T10:45:31Z",
            "author_login": "lifubang"
          },
          {
            "sha": "06f1e0765576dcf6d8c2ef5e56d309618310992c",
            "date": "2024-06-23T23:31:57Z",
            "author_login": "kolyshkin"
          },
          {
            "sha": "6171da60058fe58c6bd2f2a4ae8be381cfc12cce",
            "date": "2024-12-23T01:32:02Z",
            "author_login": "kolyshkin"
          },
          {
            "sha": "c49b89168140c70dc1badd17d5ed361788898fe9",
            "date": "2024-12-21T19:52:25Z",
            "author_login": "kolyshkin"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-362",
    "description": "runc before 1.0.0-rc95 allows a Container Filesystem Breakout via Directory Traversal. To exploit the vulnerability, an attacker must be able to create multiple containers with a fairly specific mount configuration. The problem occurs via a symlink-exchange attack that relies on a race condition.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2021-05-27T13:15:08.077",
    "last_modified": "2024-11-21T06:03:58.593",
    "fix_date": "2021-04-01T19:00:31Z"
  },
  "references": [
    {
      "url": "http://www.openwall.com/lists/oss-security/2021/05/19/2",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2021/05/19/2",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.opensuse.org/show_bug.cgi?id=1185405",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/releases",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/security/advisories/GHSA-c3xm-pvg7-gh7r",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2023/03/msg00023.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/35ZW6NBZSBH5PWIT7JU4HXOXGFVDCOHH/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4HOARVIT47RULTTFWAU7XBG4WY6TDDHV/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202107-26",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20210708-0003/",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2021/05/19/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2021/05/19/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.opensuse.org/show_bug.cgi?id=1185405",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/releases",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/security/advisories/GHSA-c3xm-pvg7-gh7r",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2023/03/msg00023.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/35ZW6NBZSBH5PWIT7JU4HXOXGFVDCOHH/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4HOARVIT47RULTTFWAU7XBG4WY6TDDHV/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202107-26",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20210708-0003/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:57.125549",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "runc",
    "owner": "opencontainers",
    "created_at": "2015-06-05T23:30:45Z",
    "updated_at": "2025-01-14T11:33:23Z",
    "pushed_at": "2025-01-13T07:56:10Z",
    "size": 21572,
    "stars": 12051,
    "forks": 2130,
    "open_issues": 365,
    "watchers": 12051,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-1.0",
      "release-1.1",
      "release-1.2"
    ],
    "languages": {
      "Go": 1253070,
      "Shell": 305324,
      "C": 45119,
      "Makefile": 7226,
      "Dockerfile": 2644,
      "Ruby": 2035
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:26:33.730029"
  }
}