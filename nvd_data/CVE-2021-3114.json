{
  "cve_id": "CVE-2021-3114",
  "github_data": {
    "repository": "golang/go",
    "fix_commit": "d95ca9138026cbe40e0857d76a81a16d03230871",
    "related_commits": [
      "d95ca9138026cbe40e0857d76a81a16d03230871",
      "d95ca9138026cbe40e0857d76a81a16d03230871"
    ],
    "patch_url": "https://github.com/golang/go/commit/d95ca9138026cbe40e0857d76a81a16d03230871.patch",
    "fix_commit_details": {
      "sha": "d95ca9138026cbe40e0857d76a81a16d03230871",
      "commit_date": "2021-01-08T02:56:58Z",
      "author": {
        "login": "FiloSottile",
        "type": "User",
        "stats": {
          "total_commits": 596,
          "average_weekly_commits": 0.6765039727582293,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 207
        }
      },
      "commit_message": {
        "title": "crypto/elliptic: fix P-224 field reduction",
        "length": 2250,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 318,
        "additions": 298,
        "deletions": 20
      },
      "files": [
        {
          "filename": "src/crypto/elliptic/p224.go",
          "status": "modified",
          "additions": 26,
          "deletions": 15,
          "patch": "@@ -386,21 +386,25 @@ func p224Invert(out, in *p224FieldElement) {\n // p224Contract converts a FieldElement to its unique, minimal form.\n //\n // On entry, in[i] < 2**29\n-// On exit, in[i] < 2**28\n+// On exit, out[i] < 2**28 and out < p\n func p224Contract(out, in *p224FieldElement) {\n \tcopy(out[:], in[:])\n \n+\t// First, carry the bits above 28 to the higher limb.\n \tfor i := 0; i < 7; i++ {\n \t\tout[i+1] += out[i] >> 28\n \t\tout[i] &= bottom28Bits\n \t}\n \ttop := out[7] >> 28\n \tout[7] &= bottom28Bits\n \n+\t// Use the reduction identity to carry the overflow.\n+\t//\n+\t//   a + top * 2\u00b2\u00b2\u2074 = a + top * 2\u2079\u2076 - top\n \tout[0] -= top\n \tout[3] += top << 12\n \n-\t// We may just have made out[i] negative. So we carry down. If we made\n+\t// We may just have made out[0] negative. So we carry down. If we made\n \t// out[0] negative then we know that out[3] is sufficiently positive\n \t// because we just added to it.\n \tfor i := 0; i < 3; i++ {\n@@ -425,13 +429,12 @@ func p224Contract(out, in *p224FieldElement) {\n \t// There are two cases to consider for out[3]:\n \t//   1) The first time that we eliminated top, we didn't push out[3] over\n \t//      2**28. In this case, the partial carry chain didn't change any values\n-\t//      and top is zero.\n+\t//      and top is now zero.\n \t//   2) We did push out[3] over 2**28 the first time that we eliminated top.\n-\t//      The first value of top was in [0..16), therefore, prior to eliminating\n-\t//      the first top, 0xfff1000 <= out[3] <= 0xfffffff. Therefore, after\n-\t//      overflowing and being reduced by the second carry chain, out[3] <=\n-\t//      0xf000. Thus it cannot have overflowed when we eliminated top for the\n-\t//      second time.\n+\t//      The first value of top was in [0..2], therefore, after overflowing\n+\t//      and being reduced by the second carry chain, out[3] <= 2<<12 - 1.\n+\t// In both cases, out[3] cannot have overflowed when we eliminated top for\n+\t// the second time.\n \n \t// Again, we may just have made out[0] negative, so do the same carry down.\n \t// As before, if we made out[0] negative then we know that out[3] is\n@@ -470,12 +473,11 @@ func p224Contract(out, in *p224FieldElement) {\n \tbottom3NonZero |= bottom3NonZero >> 1\n \tbottom3NonZero = uint32(int32(bottom3NonZero<<31) >> 31)\n \n-\t// Everything depends on the value of out[3].\n-\t//    If it's > 0xffff000 and top4AllOnes != 0 then the whole value is >= p\n-\t//    If it's = 0xffff000 and top4AllOnes != 0 and bottom3NonZero != 0,\n-\t//      then the whole value is >= p\n+\t// Assuming top4AllOnes != 0, everything depends on the value of out[3].\n+\t//    If it's > 0xffff000 then the whole value is > p\n+\t//    If it's = 0xffff000 and bottom3NonZero != 0, then the whole value is >= p\n \t//    If it's < 0xffff000, then the whole value is < p\n-\tn := out[3] - 0xffff000\n+\tn := 0xffff000 - out[3]\n \tout3Equal := n\n \tout3Equal |= out3Equal >> 16\n \tout3Equal |= out3Equal >> 8\n@@ -484,8 +486,8 @@ func p224Contract(out, in *p224FieldElement) {\n \tout3Equal |= out3Equal >> 1\n \tout3Equal = ^uint32(int32(out3Equal<<31) >> 31)\n \n-\t// If out[3] > 0xffff000 then n's MSB will be zero.\n-\tout3GT := ^uint32(int32(n) >> 31)\n+\t// If out[3] > 0xffff000 then n's MSB will be one.\n+\tout3GT := uint32(int32(n) >> 31)\n \n \tmask := top4AllOnes & ((out3Equal & bottom3NonZero) | out3GT)\n \tout[0] -= 1 & mask\n@@ -494,6 +496,15 @@ func p224Contract(out, in *p224FieldElement) {\n \tout[5] -= 0xfffffff & mask\n \tout[6] -= 0xfffffff & mask\n \tout[7] -= 0xfffffff & mask\n+\n+\t// Do one final carry down, in case we made out[0] negative. One of\n+\t// out[0..3] needs to be positive and able to absorb the -1 or the value\n+\t// would have been < p, and the subtraction wouldn't have happened.\n+\tfor i := 0; i < 3; i++ {\n+\t\tmask := uint32(int32(out[i]) >> 31)\n+\t\tout[i] += (1 << 28) & mask\n+\t\tout[i+1] -= 1 & mask\n+\t}\n }\n \n // Group element functions."
        },
        {
          "filename": "src/crypto/elliptic/p224_test.go",
          "status": "modified",
          "additions": 272,
          "deletions": 5,
          "patch": "@@ -6,7 +6,11 @@ package elliptic\n \n import (\n \t\"math/big\"\n+\t\"math/bits\"\n+\t\"math/rand\"\n+\t\"reflect\"\n \t\"testing\"\n+\t\"testing/quick\"\n )\n \n var toFromBigTests = []string{\n@@ -21,16 +25,16 @@ func p224AlternativeToBig(in *p224FieldElement) *big.Int {\n \tret := new(big.Int)\n \ttmp := new(big.Int)\n \n-\tfor i := uint(0); i < 8; i++ {\n+\tfor i := len(in) - 1; i >= 0; i-- {\n+\t\tret.Lsh(ret, 28)\n \t\ttmp.SetInt64(int64(in[i]))\n-\t\ttmp.Lsh(tmp, 28*i)\n \t\tret.Add(ret, tmp)\n \t}\n-\tret.Mod(ret, p224.P)\n+\tret.Mod(ret, P224().Params().P)\n \treturn ret\n }\n \n-func TestToFromBig(t *testing.T) {\n+func TestP224ToFromBig(t *testing.T) {\n \tfor i, test := range toFromBigTests {\n \t\tn, _ := new(big.Int).SetString(test, 16)\n \t\tvar x p224FieldElement\n@@ -41,7 +45,270 @@ func TestToFromBig(t *testing.T) {\n \t\t}\n \t\tq := p224AlternativeToBig(&x)\n \t\tif n.Cmp(q) != 0 {\n-\t\t\tt.Errorf(\"#%d: %x != %x (alternative)\", i, n, m)\n+\t\t\tt.Errorf(\"#%d: %x != %x (alternative)\", i, n, q)\n \t\t}\n \t}\n }\n+\n+// quickCheckConfig32 will make each quickcheck test run (32 * -quickchecks)\n+// times. The default value of -quickchecks is 100.\n+var quickCheckConfig32 = &quick.Config{MaxCountScale: 32}\n+\n+// weirdLimbs can be combined to generate a range of edge-case field elements.\n+var weirdLimbs = [...]uint32{\n+\t0, 1, (1 << 29) - 1,\n+\t(1 << 12), (1 << 12) - 1,\n+\t(1 << 28), (1 << 28) - 1,\n+}\n+\n+func generateLimb(rand *rand.Rand) uint32 {\n+\tconst bottom29Bits = 0x1fffffff\n+\tn := rand.Intn(len(weirdLimbs) + 3)\n+\tswitch n {\n+\tcase len(weirdLimbs):\n+\t\t// Random value.\n+\t\treturn uint32(rand.Int31n(1 << 29))\n+\tcase len(weirdLimbs) + 1:\n+\t\t// Sum of two values.\n+\t\tk := generateLimb(rand) + generateLimb(rand)\n+\t\treturn k & bottom29Bits\n+\tcase len(weirdLimbs) + 2:\n+\t\t// Difference of two values.\n+\t\tk := generateLimb(rand) - generateLimb(rand)\n+\t\treturn k & bottom29Bits\n+\tdefault:\n+\t\treturn weirdLimbs[n]\n+\t}\n+}\n+\n+func (p224FieldElement) Generate(rand *rand.Rand, size int) reflect.Value {\n+\treturn reflect.ValueOf(p224FieldElement{\n+\t\tgenerateLimb(rand),\n+\t\tgenerateLimb(rand),\n+\t\tgenerateLimb(rand),\n+\t\tgenerateLimb(rand),\n+\t\tgenerateLimb(rand),\n+\t\tgenerateLimb(rand),\n+\t\tgenerateLimb(rand),\n+\t\tgenerateLimb(rand),\n+\t})\n+}\n+\n+func isInBounds(x *p224FieldElement) bool {\n+\treturn bits.Len32(x[0]) <= 29 &&\n+\t\tbits.Len32(x[1]) <= 29 &&\n+\t\tbits.Len32(x[2]) <= 29 &&\n+\t\tbits.Len32(x[3]) <= 29 &&\n+\t\tbits.Len32(x[4]) <= 29 &&\n+\t\tbits.Len32(x[5]) <= 29 &&\n+\t\tbits.Len32(x[6]) <= 29 &&\n+\t\tbits.Len32(x[7]) <= 29\n+}\n+\n+func TestP224Mul(t *testing.T) {\n+\tmulMatchesBigInt := func(a, b, out p224FieldElement) bool {\n+\t\tvar tmp p224LargeFieldElement\n+\t\tp224Mul(&out, &a, &b, &tmp)\n+\n+\t\texp := new(big.Int).Mul(p224AlternativeToBig(&a), p224AlternativeToBig(&b))\n+\t\texp.Mod(exp, P224().Params().P)\n+\t\tgot := p224AlternativeToBig(&out)\n+\t\tif exp.Cmp(got) != 0 || !isInBounds(&out) {\n+\t\t\tt.Logf(\"a = %x\", a)\n+\t\t\tt.Logf(\"b = %x\", b)\n+\t\t\tt.Logf(\"p224Mul(a, b) = %x = %v\", out, got)\n+\t\t\tt.Logf(\"a * b = %v\", exp)\n+\t\t\treturn false\n+\t\t}\n+\n+\t\treturn true\n+\t}\n+\n+\ta := p224FieldElement{0xfffffff, 0xfffffff, 0xf00ffff, 0x20f, 0x0, 0x0, 0x0, 0x0}\n+\tb := p224FieldElement{1, 0, 0, 0, 0, 0, 0, 0}\n+\tif !mulMatchesBigInt(a, b, p224FieldElement{}) {\n+\t\tt.Fail()\n+\t}\n+\n+\tif err := quick.Check(mulMatchesBigInt, quickCheckConfig32); err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n+func TestP224Square(t *testing.T) {\n+\tsquareMatchesBigInt := func(a, out p224FieldElement) bool {\n+\t\tvar tmp p224LargeFieldElement\n+\t\tp224Square(&out, &a, &tmp)\n+\n+\t\texp := p224AlternativeToBig(&a)\n+\t\texp.Mul(exp, exp)\n+\t\texp.Mod(exp, P224().Params().P)\n+\t\tgot := p224AlternativeToBig(&out)\n+\t\tif exp.Cmp(got) != 0 || !isInBounds(&out) {\n+\t\t\tt.Logf(\"a = %x\", a)\n+\t\t\tt.Logf(\"p224Square(a, b) = %x = %v\", out, got)\n+\t\t\tt.Logf(\"a * a = %v\", exp)\n+\t\t\treturn false\n+\t\t}\n+\n+\t\treturn true\n+\t}\n+\n+\tif err := quick.Check(squareMatchesBigInt, quickCheckConfig32); err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n+func TestP224Add(t *testing.T) {\n+\taddMatchesBigInt := func(a, b, out p224FieldElement) bool {\n+\t\tp224Add(&out, &a, &b)\n+\n+\t\texp := new(big.Int).Add(p224AlternativeToBig(&a), p224AlternativeToBig(&b))\n+\t\texp.Mod(exp, P224().Params().P)\n+\t\tgot := p224AlternativeToBig(&out)\n+\t\tif exp.Cmp(got) != 0 {\n+\t\t\tt.Logf(\"a = %x\", a)\n+\t\t\tt.Logf(\"b = %x\", b)\n+\t\t\tt.Logf(\"p224Add(a, b) = %x = %v\", out, got)\n+\t\t\tt.Logf(\"a + b = %v\", exp)\n+\t\t\treturn false\n+\t\t}\n+\n+\t\treturn true\n+\t}\n+\n+\tif err := quick.Check(addMatchesBigInt, quickCheckConfig32); err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n+func TestP224Reduce(t *testing.T) {\n+\treduceMatchesBigInt := func(a p224FieldElement) bool {\n+\t\tout := a\n+\t\t// TODO: generate higher values for functions like p224Reduce that are\n+\t\t// expected to work with higher input bounds.\n+\t\tp224Reduce(&out)\n+\n+\t\texp := p224AlternativeToBig(&a)\n+\t\tgot := p224AlternativeToBig(&out)\n+\t\tif exp.Cmp(got) != 0 || !isInBounds(&out) {\n+\t\t\tt.Logf(\"a = %x = %v\", a, exp)\n+\t\t\tt.Logf(\"p224Reduce(a) = %x = %v\", out, got)\n+\t\t\treturn false\n+\t\t}\n+\n+\t\treturn true\n+\t}\n+\n+\tif err := quick.Check(reduceMatchesBigInt, quickCheckConfig32); err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n+func TestP224Contract(t *testing.T) {\n+\tcontractMatchesBigInt := func(a, out p224FieldElement) bool {\n+\t\tp224Contract(&out, &a)\n+\n+\t\texp := p224AlternativeToBig(&a)\n+\t\tgot := p224AlternativeToBig(&out)\n+\t\tif exp.Cmp(got) != 0 {\n+\t\t\tt.Logf(\"a = %x = %v\", a, exp)\n+\t\t\tt.Logf(\"p224Contract(a) = %x = %v\", out, got)\n+\t\t\treturn false\n+\t\t}\n+\n+\t\t// Check that out < P.\n+\t\tfor i := range p224P {\n+\t\t\tk := 8 - i - 1\n+\t\t\tif out[k] > p224P[k] {\n+\t\t\t\tt.Logf(\"p224Contract(a) = %x\", out)\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tif out[k] < p224P[k] {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t\tt.Logf(\"p224Contract(a) = %x\", out)\n+\t\treturn false\n+\t}\n+\n+\tif !contractMatchesBigInt(p224P, p224FieldElement{}) {\n+\t\tt.Error(\"p224Contract(p) is broken\")\n+\t}\n+\tpMinus1 := p224FieldElement{0, 0, 0, 0xffff000, 0xfffffff, 0xfffffff, 0xfffffff, 0xfffffff}\n+\tif !contractMatchesBigInt(pMinus1, p224FieldElement{}) {\n+\t\tt.Error(\"p224Contract(p - 1) is broken\")\n+\t}\n+\t// Check that we can handle input above p, but lowest limb zero.\n+\ta := p224FieldElement{0, 1, 0, 0xffff000, 0xfffffff, 0xfffffff, 0xfffffff, 0xfffffff}\n+\tif !contractMatchesBigInt(a, p224FieldElement{}) {\n+\t\tt.Error(\"p224Contract(p + 2\u00b2\u2078) is broken\")\n+\t}\n+\t// Check that we can handle input above p, but lowest three limbs zero.\n+\tb := p224FieldElement{0, 0, 0, 0xffff001, 0xfffffff, 0xfffffff, 0xfffffff, 0xfffffff}\n+\tif !contractMatchesBigInt(b, p224FieldElement{}) {\n+\t\tt.Error(\"p224Contract(p + 2\u2078\u2074) is broken\")\n+\t}\n+\n+\tif err := quick.Check(contractMatchesBigInt, quickCheckConfig32); err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n+func TestP224IsZero(t *testing.T) {\n+\tif got := p224IsZero(&p224FieldElement{}); got != 1 {\n+\t\tt.Errorf(\"p224IsZero(0) = %d, expected 1\", got)\n+\t}\n+\tif got := p224IsZero((*p224FieldElement)(&p224P)); got != 1 {\n+\t\tt.Errorf(\"p224IsZero(p) = %d, expected 1\", got)\n+\t}\n+\tif got := p224IsZero(&p224FieldElement{1}); got != 0 {\n+\t\tt.Errorf(\"p224IsZero(1) = %d, expected 0\", got)\n+\t}\n+\n+\tisZeroMatchesBigInt := func(a p224FieldElement) bool {\n+\t\tisZero := p224IsZero(&a)\n+\n+\t\tbig := p224AlternativeToBig(&a)\n+\t\tif big.Sign() == 0 && isZero != 1 {\n+\t\t\treturn false\n+\t\t}\n+\t\tif big.Sign() != 0 && isZero != 0 {\n+\t\t\treturn false\n+\t\t}\n+\t\treturn true\n+\t}\n+\n+\tif err := quick.Check(isZeroMatchesBigInt, quickCheckConfig32); err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n+func TestP224Invert(t *testing.T) {\n+\tvar out p224FieldElement\n+\n+\tp224Invert(&out, &p224FieldElement{})\n+\tif got := p224IsZero(&out); got != 1 {\n+\t\tt.Errorf(\"p224Invert(0) = %x, expected 0\", out)\n+\t}\n+\n+\tp224Invert(&out, (*p224FieldElement)(&p224P))\n+\tif got := p224IsZero(&out); got != 1 {\n+\t\tt.Errorf(\"p224Invert(p) = %x, expected 0\", out)\n+\t}\n+\n+\tp224Invert(&out, &p224FieldElement{1})\n+\tp224Contract(&out, &out)\n+\tif out != (p224FieldElement{1}) {\n+\t\tt.Errorf(\"p224Invert(1) = %x, expected 1\", out)\n+\t}\n+\n+\tvar tmp p224LargeFieldElement\n+\ta := p224FieldElement{1, 2, 3, 4, 5, 6, 7, 8}\n+\tp224Invert(&out, &a)\n+\tp224Mul(&out, &out, &a, &tmp)\n+\tp224Contract(&out, &out)\n+\tif out != (p224FieldElement{1}) {\n+\t\tt.Errorf(\"p224Invert(a) * a = %x, expected 1\", out)\n+\t}\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 2,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "bd80d8956f3062d2b2bff2d7da6b879dfa909f12",
            "date": "2025-01-14T04:00:14Z",
            "author_login": "rsc"
          },
          {
            "sha": "4fa61d6f9c9c7c3a5e74472f1cfb9c12eed1a368",
            "date": "2025-01-14T13:22:08Z",
            "author_login": "rsc"
          },
          {
            "sha": "c5e205e928bd4b70c90698b5ca1dd583a8036864",
            "date": "2025-01-14T00:21:29Z",
            "author_login": "randall77"
          },
          {
            "sha": "befc43655b6d93f0be883222fbb3fde5768892c1",
            "date": "2025-01-13T17:11:22Z",
            "author_login": "cuishuang"
          },
          {
            "sha": "c83f2ca4b3964917adc3b06f661785cc6b53792d",
            "date": "2025-01-14T14:58:32Z",
            "author_login": "ianlancetaylor"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N",
    "cwe_id": "CWE-682",
    "description": "In Go before 1.14.14 and 1.15.x before 1.15.7, crypto/elliptic/p224.go can generate incorrect outputs, related to an underflow of the lowest limb during the final complete reduction in the P-224 field.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-01-26T18:16:27.567",
    "last_modified": "2024-11-21T06:20:54.640",
    "fix_date": "2021-01-08T02:56:58Z"
  },
  "references": [
    {
      "url": "https://github.com/golang/go/commit/d95ca9138026cbe40e0857d76a81a16d03230871",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://groups.google.com/g/golang-announce/c/mperVMGa98w",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2021/03/msg00014.html",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2021/03/msg00015.html",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YWAYJGXWC232SG3UR3TR574E6BP3OSQQ/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202208-02",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20210219-0001/",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2021/dsa-4848",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/golang/go/commit/d95ca9138026cbe40e0857d76a81a16d03230871",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://groups.google.com/g/golang-announce/c/mperVMGa98w",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2021/03/msg00014.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2021/03/msg00015.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YWAYJGXWC232SG3UR3TR574E6BP3OSQQ/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202208-02",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20210219-0001/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2021/dsa-4848",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:13.168205",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "go",
    "owner": "golang",
    "created_at": "2014-08-19T04:33:40Z",
    "updated_at": "2025-01-14T13:58:25Z",
    "pushed_at": "2025-01-13T19:19:33Z",
    "size": 385472,
    "stars": 125082,
    "forks": 17781,
    "open_issues": 9602,
    "watchers": 125082,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "dev.boringcrypto.go1.8",
      "dev.boringcrypto.go1.9",
      "dev.boringcrypto.go1.10",
      "dev.boringcrypto.go1.11",
      "dev.boringcrypto.go1.12",
      "dev.boringcrypto.go1.13",
      "dev.boringcrypto.go1.14",
      "dev.boringcrypto.go1.15",
      "dev.boringcrypto.go1.16",
      "dev.boringcrypto.go1.17",
      "dev.boringcrypto.go1.18",
      "dev.boringcrypto",
      "dev.cc",
      "dev.cmdgo",
      "dev.coretypes",
      "dev.debug",
      "dev.fuzz",
      "dev.garbage",
      "dev.gcfe",
      "dev.go2go",
      "dev.inline",
      "dev.link",
      "dev.power64",
      "dev.regabi",
      "dev.ssa",
      "dev.tls",
      "dev.typealias",
      "dev.typeparams",
      "dev.types",
      "dev.unified"
    ],
    "languages": {
      "Go": 47823232,
      "Assembly": 3216144,
      "HTML": 2621355,
      "C": 122435,
      "Shell": 64551,
      "Perl": 32036,
      "JavaScript": 20759,
      "Python": 19317,
      "Batchfile": 9485,
      "Dockerfile": 3563,
      "Makefile": 1868,
      "Awk": 450
    },
    "commit_activity": {
      "total_commits_last_year": 2897,
      "avg_commits_per_week": 55.71153846153846,
      "days_active_last_year": 341
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T14:07:55.970395"
  }
}