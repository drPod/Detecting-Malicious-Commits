{
  "cve_id": "CVE-2021-32020",
  "github_data": {
    "repository": "FreeRTOS/FreeRTOS-Kernel",
    "fix_commit": "c7a9a01c94987082b223d3e59969ede64363da63",
    "related_commits": [
      "c7a9a01c94987082b223d3e59969ede64363da63",
      "c7a9a01c94987082b223d3e59969ede64363da63"
    ],
    "patch_url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63.patch",
    "fix_commit_details": {
      "sha": "c7a9a01c94987082b223d3e59969ede64363da63",
      "commit_date": "2020-12-07T18:36:27Z",
      "author": {
        "login": "cobusve",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Improve heap2 bounds checking (#224)",
        "length": 84,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 100,
        "additions": 66,
        "deletions": 34
      },
      "files": [
        {
          "filename": "portable/MemMang/heap_1.c",
          "status": "modified",
          "additions": 13,
          "deletions": 6,
          "patch": "@@ -22,7 +22,6 @@\n  * https://www.FreeRTOS.org\r\n  * https://github.com/FreeRTOS\r\n  *\r\n- * 1 tab == 4 spaces!\r\n  */\r\n \r\n \r\n@@ -72,13 +71,20 @@ void * pvPortMalloc( size_t xWantedSize )\n     void * pvReturn = NULL;\r\n     static uint8_t * pucAlignedHeap = NULL;\r\n \r\n-    /* Ensure that blocks are always aligned to the required number of bytes. */\r\n+    /* Ensure that blocks are always aligned. */\r\n     #if ( portBYTE_ALIGNMENT != 1 )\r\n         {\r\n             if( xWantedSize & portBYTE_ALIGNMENT_MASK )\r\n             {\r\n-                /* Byte alignment required. */\r\n-                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n+                /* Byte alignment required. Check for overflow. */\r\n+                if ( (xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) )) > xWantedSize )\r\n+                {\r\n+                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n+                } \r\n+                else \r\n+                {\r\n+                    xWantedSize = 0;\r\n+                }\r\n             }\r\n         }\r\n     #endif\r\n@@ -91,8 +97,9 @@ void * pvPortMalloc( size_t xWantedSize )\n             pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\r\n         }\r\n \r\n-        /* Check there is enough room left for the allocation. */\r\n-        if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\r\n+        /* Check there is enough room left for the allocation and. */\r\n+        if( ( xWantedSize > 0 ) && /* valid size */\r\n+            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\r\n             ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */\r\n         {\r\n             /* Return the next free byte then increment the index past this\r"
        },
        {
          "filename": "portable/MemMang/heap_2.c",
          "status": "modified",
          "additions": 17,
          "deletions": 7,
          "patch": "@@ -22,7 +22,6 @@\n  * https://www.FreeRTOS.org\r\n  * https://github.com/FreeRTOS\r\n  *\r\n- * 1 tab == 4 spaces!\r\n  */\r\n \r\n /*\r\n@@ -132,21 +131,32 @@ void * pvPortMalloc( size_t xWantedSize )\n             xHeapHasBeenInitialised = pdTRUE;\r\n         }\r\n \r\n-        /* The wanted size is increased so it can contain a BlockLink_t\r\n+        /* The wanted size must be increased so it can contain a BlockLink_t\r\n          * structure in addition to the requested amount of bytes. */\r\n-        if( xWantedSize > 0 )\r\n+        if( ( xWantedSize > 0 ) && \r\n+            ( ( xWantedSize + heapSTRUCT_SIZE ) >  xWantedSize ) ) /* Overflow check */\r\n         {\r\n             xWantedSize += heapSTRUCT_SIZE;\r\n \r\n-            /* Ensure that blocks are always aligned to the required number of bytes. */\r\n-            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )\r\n+            /* Byte alignment required. Check for overflow. */\r\n+            if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) \r\n+                    > xWantedSize )\r\n             {\r\n-                /* Byte alignment required. */\r\n                 xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n+                configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );\r\n             }\r\n+            else\r\n+            {\r\n+                xWantedSize = 0;\r\n+            }       \r\n+        }\r\n+        else \r\n+        {\r\n+            xWantedSize = 0; \r\n         }\r\n \r\n-        if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )\r\n+\r\n+        if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\r\n         {\r\n             /* Blocks are stored in byte order - traverse the list from the start\r\n              * (smallest) block until one of adequate size is found. */\r"
        },
        {
          "filename": "portable/MemMang/heap_4.c",
          "status": "modified",
          "additions": 20,
          "deletions": 12,
          "patch": "@@ -136,34 +136,42 @@ void * pvPortMalloc( size_t xWantedSize )\n          * kernel, so it must be free. */\r\n         if( ( xWantedSize & xBlockAllocatedBit ) == 0 )\r\n         {\r\n-            /* The wanted size is increased so it can contain a BlockLink_t\r\n+            /* The wanted size must be increased so it can contain a BlockLink_t\r\n              * structure in addition to the requested amount of bytes. */\r\n-            if( xWantedSize > 0 )\r\n+            if( ( xWantedSize > 0 ) && \r\n+                ( ( xWantedSize + xHeapStructSize ) >  xWantedSize ) ) /* Overflow check */\r\n             {\r\n                 xWantedSize += xHeapStructSize;\r\n \r\n-                /* Ensure that blocks are always aligned to the required number\r\n-                 * of bytes. */\r\n+                /* Ensure that blocks are always aligned. */\r\n                 if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )\r\n                 {\r\n-                    /* Byte alignment required. */\r\n-                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n-                    configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );\r\n+                    /* Byte alignment required. Check for overflow. */\r\n+                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) \r\n+                            > xWantedSize )\r\n+                    {\r\n+                        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n+                        configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );\r\n+                    }\r\n+                    else\r\n+                    {\r\n+                        xWantedSize = 0;\r\n+                    }  \r\n                 }\r\n                 else\r\n                 {\r\n                     mtCOVERAGE_TEST_MARKER();\r\n                 }\r\n-            }\r\n-            else\r\n+            } \r\n+            else \r\n             {\r\n-                mtCOVERAGE_TEST_MARKER();\r\n+                xWantedSize = 0;\r\n             }\r\n \r\n             if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\r\n             {\r\n                 /* Traverse the list from the start\t(lowest address) block until\r\n-                 * one\tof adequate size is found. */\r\n+                 * one of adequate size is found. */\r\n                 pxPreviousBlock = &xStart;\r\n                 pxBlock = xStart.pxNextFreeBlock;\r\n \r\n@@ -174,7 +182,7 @@ void * pvPortMalloc( size_t xWantedSize )\n                 }\r\n \r\n                 /* If the end marker was reached then a block of adequate size\r\n-                 * was\tnot found. */\r\n+                 * was not found. */\r\n                 if( pxBlock != pxEnd )\r\n                 {\r\n                     /* Return the memory space pointed to - jumping over the\r"
        },
        {
          "filename": "portable/MemMang/heap_5.c",
          "status": "modified",
          "additions": 16,
          "deletions": 9,
          "patch": "@@ -22,7 +22,6 @@\n  * https://www.FreeRTOS.org\r\n  * https://github.com/FreeRTOS\r\n  *\r\n- * 1 tab == 4 spaces!\r\n  */\r\n \r\n /*\r\n@@ -150,16 +149,24 @@ void * pvPortMalloc( size_t xWantedSize )\n         {\r\n             /* The wanted size is increased so it can contain a BlockLink_t\r\n              * structure in addition to the requested amount of bytes. */\r\n-            if( xWantedSize > 0 )\r\n+            if( ( xWantedSize > 0 ) && \r\n+                ( ( xWantedSize + xHeapStructSize ) >  xWantedSize ) ) /* Overflow check */\r\n             {\r\n                 xWantedSize += xHeapStructSize;\r\n \r\n-                /* Ensure that blocks are always aligned to the required number\r\n-                 * of bytes. */\r\n+                /* Ensure that blocks are always aligned */\r\n                 if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )\r\n                 {\r\n-                    /* Byte alignment required. */\r\n-                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n+                    /* Byte alignment required. Check for overflow */\r\n+                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) >\r\n+                         xWantedSize )\r\n+                    {\r\n+                        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n+                    } \r\n+                    else \r\n+                    {\r\n+                        xWantedSize = 0;\r\n+                    }\r\n                 }\r\n                 else\r\n                 {\r\n@@ -168,13 +175,13 @@ void * pvPortMalloc( size_t xWantedSize )\n             }\r\n             else\r\n             {\r\n-                mtCOVERAGE_TEST_MARKER();\r\n+                xWantedSize = 0;\r\n             }\r\n \r\n             if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\r\n             {\r\n                 /* Traverse the list from the start\t(lowest address) block until\r\n-                 * one\tof adequate size is found. */\r\n+                 * one of adequate size is found. */\r\n                 pxPreviousBlock = &xStart;\r\n                 pxBlock = xStart.pxNextFreeBlock;\r\n \r\n@@ -185,7 +192,7 @@ void * pvPortMalloc( size_t xWantedSize )\n                 }\r\n \r\n                 /* If the end marker was reached then a block of adequate size\r\n-                 * was\tnot found. */\r\n+                 * was not found. */\r\n                 if( pxBlock != pxEnd )\r\n                 {\r\n                     /* Return the memory space pointed to - jumping over the\r"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "78e0cc778ae01100ce7ca0eaf838567cd19f9720",
            "date": "2025-01-14T05:20:52Z",
            "author_login": "AhmedIsmail02"
          },
          {
            "sha": "c38427eea442b5a58b0b95ad88ff769be3abcc0d",
            "date": "2025-01-13T22:48:10Z",
            "author_login": "creiter64"
          },
          {
            "sha": "3a7b3082cfce01ffba07b9be1398795b8307b05a",
            "date": "2025-01-06T05:35:53Z",
            "author_login": "IotaHydrae"
          },
          {
            "sha": "e55bde213348c8911205f81e89016dd4ba2ba79d",
            "date": "2024-12-30T09:11:52Z",
            "author_login": "jiladahe1997"
          },
          {
            "sha": "f05244a8d55b23428c4a8c097d375d12a9d6e30d",
            "date": "2024-12-30T08:58:49Z",
            "author_login": "felixvanoost"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-119",
    "description": "The kernel in Amazon Web Services FreeRTOS before 10.4.3 has insufficient bounds checking during management of heap memory.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-05-03T22:15:08.697",
    "last_modified": "2024-11-21T06:06:43.763",
    "fix_date": "2020-12-07T18:36:27Z"
  },
  "references": [
    {
      "url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:57.061659",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "FreeRTOS-Kernel",
    "owner": "FreeRTOS",
    "created_at": "2019-09-09T16:28:01Z",
    "updated_at": "2025-01-14T05:20:58Z",
    "pushed_at": "2025-01-14T05:20:52Z",
    "size": 119555,
    "stars": 2942,
    "forks": 1179,
    "open_issues": 24,
    "watchers": 2942,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "smp"
    ],
    "languages": {
      "C": 13512620,
      "Assembly": 1346270,
      "CMake": 75487,
      "Python": 9730,
      "Batchfile": 6591
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T17:10:09.806841"
  }
}