{
  "cve_id": "CVE-2021-32439",
  "github_data": {
    "repository": "gpac/gpac",
    "fix_commit": "77ed81c069e10b3861d88f72e1c6be1277ee7eae",
    "related_commits": [
      "77ed81c069e10b3861d88f72e1c6be1277ee7eae",
      "77ed81c069e10b3861d88f72e1c6be1277ee7eae"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "77ed81c069e10b3861d88f72e1c6be1277ee7eae",
      "commit_date": "2021-04-30T09:30:41Z",
      "author": {
        "login": "jeanlf",
        "type": "User",
        "stats": {
          "total_commits": 11743,
          "average_weekly_commits": 11.501469147894221,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 833
        }
      },
      "commit_message": {
        "title": "fixed #1774 (fuzz)",
        "length": 18,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 74,
        "additions": 44,
        "deletions": 30
      },
      "files": [
        {
          "filename": "src/isomedia/stbl_write.c",
          "status": "modified",
          "additions": 44,
          "deletions": 30,
          "patch": "@@ -37,11 +37,20 @@ gf_realloc low, which greatly impacts performances for large files*/\n \n #ifndef GPAC_DISABLE_ISOM_WRITE\n \n+\n+#define CHECK_PACK(_e) \\\n+\tif (!nb_pack) nb_pack = 1; \\\n+\telse if ((s32) nb_pack < 0) { \\\n+\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Too many samples %u in packed sample\\n\", nb_pack)); \\\n+\t\treturn _e; \\\n+\t}\n+\n+\n //adds a DTS in the table and get the sample number of this new sample\n //we could return an error if a sample with the same DTS already exists\n //but this is not true for QT or MJ2K, only for MP4...\n //we assume the authoring tool tries to create a compliant MP4 file.\n-GF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 LastAUDefDuration, u32 nb_packed_samples)\n+GF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 LastAUDefDuration, u32 nb_pack)\n {\n \tu32 i, j, sampNum;\n \tu64 *DTSs, curDTS;\n@@ -54,8 +63,9 @@ GF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 Last\n \tstts->r_FirstSampleInEntry = 0;\n \n \t*sampleNumber = 0;\n-\tif (!nb_packed_samples)\n-\t\tnb_packed_samples=1;\n+\n+\tCHECK_PACK(GF_BAD_PARAM)\n+\n \n \t//if we don't have an entry, that's the first one...\n \tif (!stts->nb_entries) {\n@@ -65,10 +75,10 @@ GF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 Last\n \t\tstts->nb_entries = 1;\n \t\tstts->entries = gf_malloc(sizeof(GF_SttsEntry));\n \t\tif (!stts->entries) return GF_OUT_OF_MEM;\n-\t\tstts->entries[0].sampleCount = nb_packed_samples;\n-\t\tstts->entries[0].sampleDelta = (nb_packed_samples>1) ? 0 : LastAUDefDuration;\n+\t\tstts->entries[0].sampleCount = nb_pack;\n+\t\tstts->entries[0].sampleDelta = (nb_pack>1) ? 0 : LastAUDefDuration;\n \t\t(*sampleNumber) = 1;\n-\t\tstts->w_currentSampleNum = nb_packed_samples;\n+\t\tstts->w_currentSampleNum = nb_pack;\n \t\treturn GF_OK;\n \t}\n \t//check the last DTS - we allow 0-duration samples (same DTS)\n@@ -83,12 +93,12 @@ GF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 Last\n \t\tif ((DTS == stts->w_LastDTS + ent->sampleDelta)\n \t\t\t//for raw audio, consider (dts==last_dts) and (dts==last_dts+2*delta) as sample append to cope with\n \t\t\t//timescale vs samplerate precision\n-\t\t\t|| ((nb_packed_samples>1) && ((DTS == stts->w_LastDTS) || (DTS == stts->w_LastDTS + 2*ent->sampleDelta) ))\n+\t\t\t|| ((nb_pack>1) && ((DTS == stts->w_LastDTS) || (DTS == stts->w_LastDTS + 2*ent->sampleDelta) ))\n \t\t) {\n \t\t\t(*sampleNumber) = stts->w_currentSampleNum + 1;\n-\t\t\tent->sampleCount += nb_packed_samples;\n-\t\t\tstts->w_currentSampleNum += nb_packed_samples;\n-\t\t\tstts->w_LastDTS = DTS + ent->sampleDelta * (nb_packed_samples-1);\n+\t\t\tent->sampleCount += nb_pack;\n+\t\t\tstts->w_currentSampleNum += nb_pack;\n+\t\t\tstts->w_LastDTS = DTS + ent->sampleDelta * (nb_pack-1);\n \t\t\treturn GF_OK;\n \t\t}\n \t\t//we need to split the entry\n@@ -118,7 +128,7 @@ GF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 Last\n \t\t//we definitely need to split the entry ;)\n \t\tent->sampleCount --;\n \n-\t\tif (nb_packed_samples>1)\n+\t\tif (nb_pack>1)\n \t\t\tnb_extra = 1;\n \n \t\tif (stts->alloc_size <= stts->nb_entries + nb_extra) {\n@@ -134,7 +144,7 @@ GF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 Last\n \t\tent = &stts->entries[stts->nb_entries];\n \t\tstts->nb_entries++;\n \n-\t\tif (nb_packed_samples==1) {\n+\t\tif (nb_pack==1) {\n \t\t\tent->sampleCount = 2;\n \t\t\tent->sampleDelta = (u32) (DTS - stts->w_LastDTS);\n \t\t\tstts->w_LastDTS = DTS;\n@@ -149,11 +159,11 @@ GF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 Last\n \t\tent = &stts->entries[stts->nb_entries];\n \t\tstts->nb_entries++;\n \n-\t\tent->sampleCount = nb_packed_samples;\n+\t\tent->sampleCount = nb_pack;\n \t\tent->sampleDelta = nb_extra;\n \t\tstts->w_LastDTS = DTS;\n \t\t(*sampleNumber) = stts->w_currentSampleNum + 1;\n-\t\tstts->w_currentSampleNum += nb_packed_samples;\n+\t\tstts->w_currentSampleNum += nb_pack;\n \t\treturn GF_OK;\n \t}\n \n@@ -393,32 +403,34 @@ GF_Err stbl_unpackCTS(GF_SampleTableBox *stbl)\n }\n \n //add size\n-GF_Err stbl_AddSize(GF_SampleSizeBox *stsz, u32 sampleNumber, u32 size, u32 nb_pack_samples)\n+GF_Err stbl_AddSize(GF_SampleSizeBox *stsz, u32 sampleNumber, u32 size, u32 nb_pack)\n {\n \tu32 i, k;\n \tu32 *newSizes;\n \tif (!stsz /*|| !size */ || !sampleNumber) return GF_BAD_PARAM;\n \n \tif (sampleNumber > stsz->sampleCount + 1) return GF_BAD_PARAM;\n \n-\tif (!nb_pack_samples) nb_pack_samples = 1;\n-\telse if (nb_pack_samples>1)\n-\t\tsize /= nb_pack_samples;\n+\tCHECK_PACK(GF_BAD_PARAM)\n+\n+\tif (nb_pack>1)\n+\t\tsize /= nb_pack;\n+\n \n \t//all samples have the same size\n \tif (stsz->sizes == NULL) {\n \t\t//1 first sample added in NON COMPACT MODE\n \t\tif (! stsz->sampleCount && (stsz->type != GF_ISOM_BOX_TYPE_STZ2) ) {\n-\t\t\tstsz->sampleCount = nb_pack_samples;\n+\t\t\tstsz->sampleCount = nb_pack;\n \t\t\tstsz->sampleSize = size;\n \t\t\treturn GF_OK;\n \t\t}\n \t\t//2- sample has the same size\n \t\tif (stsz->sampleSize == size) {\n-\t\t\tstsz->sampleCount += nb_pack_samples;\n+\t\t\tstsz->sampleCount += nb_pack;\n \t\t\treturn GF_OK;\n \t\t}\n-\t\tif (nb_pack_samples>1) {\n+\t\tif (nb_pack>1) {\n \t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Inserting packed samples with different sizes is not yet supported\\n\" ));\n \t\t\treturn GF_NOT_SUPPORTED;\n \t\t}\n@@ -698,7 +710,7 @@ GF_Err stbl_AddShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber, u32 shadowNumber\n }\n \n //used in edit/write, where sampleNumber == chunkNumber\n-GF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset, u32 nb_pack_samples)\n+GF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset, u32 nb_pack)\n {\n \tGF_SampleTableBox *stbl;\n \tGF_ChunkOffsetBox *stco;\n@@ -713,8 +725,7 @@ GF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIn\n \tstsc = stbl->SampleToChunk;\n \n //\tif (stsc->w_lastSampleNumber + 1 < sampleNumber ) return GF_BAD_PARAM;\n-\tif (!nb_pack_samples)\n-\t\tnb_pack_samples = 1;\n+\tCHECK_PACK(GF_BAD_PARAM)\n \n \tif (!stsc->nb_entries || (stsc->nb_entries + 2 >= stsc->alloc_size)) {\n \t\tif (!stsc->alloc_size) stsc->alloc_size = 1;\n@@ -730,7 +741,7 @@ GF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIn\n \t\tif (stsc->nb_entries) stsc->entries[stsc->nb_entries-1].nextChunk = stsc->w_lastChunkNumber;\n \n \t\tnew_chunk_idx = stsc->w_lastChunkNumber;\n-\t\tstsc->w_lastSampleNumber = sampleNumber + nb_pack_samples-1;\n+\t\tstsc->w_lastSampleNumber = sampleNumber + nb_pack-1;\n \t\tstsc->nb_entries += 1;\n \t} else {\n \t\tu32 cur_samp = 1;\n@@ -785,11 +796,11 @@ GF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIn\n \t}\n \tent->isEdited = (Media_IsSelfContained(mdia, StreamDescIndex)) ? 1 : 0;\n \tent->sampleDescriptionIndex = StreamDescIndex;\n-\tent->samplesPerChunk = nb_pack_samples;\n+\tent->samplesPerChunk = nb_pack;\n \tent->nextChunk = ent->firstChunk+1;\n \n \t//OK, now if we've inserted a chunk, update the sample to chunk info...\n-\tif (sampleNumber + nb_pack_samples - 1 == stsc->w_lastSampleNumber) {\n+\tif (sampleNumber + nb_pack - 1 == stsc->w_lastSampleNumber) {\n \t\tif (stsc->nb_entries)\n \t\t\tstsc->entries[stsc->nb_entries-1].nextChunk = ent->firstChunk;\n \n@@ -1596,7 +1607,8 @@ GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)\n {\n \tGF_TimeToSampleBox *stts = stbl->TimeToSample;\n \n-\tif (!nb_pack) nb_pack = 1;\n+\tCHECK_PACK(GF_ISOM_INVALID_FILE)\n+\n \tif (stts->nb_entries) {\n \t\tif (stts->entries[stts->nb_entries-1].sampleDelta == duration) {\n \t\t\tstts->entries[stts->nb_entries-1].sampleCount += nb_pack;\n@@ -1619,7 +1631,7 @@ GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)\n GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)\n {\n \tu32 i;\n-\tif (!nb_pack) nb_pack = 1;\n+\tCHECK_PACK(GF_ISOM_INVALID_FILE)\n \n \tif (!stbl->SampleSize->sampleCount) {\n \t\tstbl->SampleSize->sampleSize = size;\n@@ -1630,11 +1642,13 @@ GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)\n \t\tstbl->SampleSize->sampleCount += nb_pack;\n \t\treturn GF_OK;\n \t}\n+\n \tif (!stbl->SampleSize->sizes || (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)) {\n \t\tBool init_table = (stbl->SampleSize->sizes==NULL) ? 1 : 0;\n \t\tALLOC_INC(stbl->SampleSize->alloc_size);\n-\t\tif (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)\n+\t\tif (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size) {\n \t\t\tstbl->SampleSize->alloc_size = stbl->SampleSize->sampleCount+nb_pack;\n+\t\t}\n \n \t\tstbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*stbl->SampleSize->alloc_size);\n \t\tif (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c5d9ff66f5774d9c2abef9069544b3a5228227c0",
            "date": "2025-01-23T17:17:00Z",
            "author_login": "rbouqueau"
          },
          {
            "sha": "ca802c463137bd497be16a623aa24eeea3a7b448",
            "date": "2025-01-23T14:31:26Z",
            "author_login": "aureliendavid"
          },
          {
            "sha": "ea54ea8df17e408119fd5d9aca5582b0d712c369",
            "date": "2025-01-23T14:31:03Z",
            "author_login": "aureliendavid"
          },
          {
            "sha": "5ff728a44c4a71eae0ae0ff4bb494e52beb68ac7",
            "date": "2025-01-23T14:34:18Z",
            "author_login": "jeanlf"
          },
          {
            "sha": "7529a44d9797a640672e25c3dbb6247e1e30ab6b",
            "date": "2025-01-09T13:57:28Z",
            "author_login": "jeanlf"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.8,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-120",
    "description": "Buffer overflow in the stbl_AppendSize function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-08-11T20:15:09.013",
    "last_modified": "2024-11-21T06:07:03.453",
    "fix_date": "2021-04-30T09:30:41Z"
  },
  "references": [
    {
      "url": "https://github.com/gpac/gpac/commit/77ed81c069e10b3861d88f72e1c6be1277ee7eae",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/gpac/gpac/issues/1774",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/gpac/gpac/commit/77ed81c069e10b3861d88f72e1c6be1277ee7eae",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/gpac/gpac/issues/1774",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:05.064202",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "gpac",
    "owner": "gpac",
    "created_at": "2014-05-03T11:29:57Z",
    "updated_at": "2025-01-24T03:35:30Z",
    "pushed_at": "2025-01-25T22:34:55Z",
    "size": 148900,
    "stars": 2868,
    "forks": 541,
    "open_issues": 87,
    "watchers": 2868,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 29236526,
      "JavaScript": 1166250,
      "C++": 591365,
      "Roff": 570704,
      "Python": 185337,
      "Makefile": 105620,
      "HTML": 100652,
      "Java": 92437,
      "GLSL": 90260,
      "Objective-C": 24884,
      "Shell": 21810,
      "NSIS": 17560,
      "Rez": 13704,
      "CSS": 4998,
      "Batchfile": 4898,
      "Dockerfile": 3216,
      "Nix": 1229
    },
    "commit_activity": {
      "total_commits_last_year": 1277,
      "avg_commits_per_week": 24.557692307692307,
      "days_active_last_year": 239
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-2.1"
    },
    "collected_at": "2025-01-26T07:37:36.451192"
  }
}