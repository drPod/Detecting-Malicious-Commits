{
  "cve_id": "CVE-2021-32677",
  "github_data": {
    "repository": "tiangolo/fastapi",
    "fix_commit": "fa7e3c996edf2d5482fff8f9d890ac2390dede4d",
    "related_commits": [
      "fa7e3c996edf2d5482fff8f9d890ac2390dede4d",
      "fa7e3c996edf2d5482fff8f9d890ac2390dede4d"
    ],
    "patch_url": "https://github.com/tiangolo/fastapi/commit/fa7e3c996edf2d5482fff8f9d890ac2390dede4d.patch",
    "fix_commit_details": {
      "sha": "fa7e3c996edf2d5482fff8f9d890ac2390dede4d",
      "commit_date": "2021-06-07T10:46:18Z",
      "author": {
        "login": "patrickkwang",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "\ud83d\udc1b Check Content-Type request header before assuming JSON (#2118)",
        "length": 190,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 104,
        "additions": 92,
        "deletions": 12
      },
      "files": [
        {
          "filename": "fastapi/routing.py",
          "status": "modified",
          "additions": 16,
          "deletions": 3,
          "patch": "@@ -1,4 +1,5 @@\n import asyncio\n+import email.message\n import enum\n import inspect\n import json\n@@ -36,7 +37,7 @@\n )\n from pydantic import BaseModel\n from pydantic.error_wrappers import ErrorWrapper, ValidationError\n-from pydantic.fields import ModelField\n+from pydantic.fields import ModelField, Undefined\n from starlette import routing\n from starlette.concurrency import run_in_threadpool\n from starlette.exceptions import HTTPException\n@@ -174,14 +175,26 @@ def get_request_handler(\n \n     async def app(request: Request) -> Response:\n         try:\n-            body = None\n+            body: Any = None\n             if body_field:\n                 if is_body_form:\n                     body = await request.form()\n                 else:\n                     body_bytes = await request.body()\n                     if body_bytes:\n-                        body = await request.json()\n+                        json_body: Any = Undefined\n+                        content_type_value = request.headers.get(\"content-type\")\n+                        if content_type_value:\n+                            message = email.message.Message()\n+                            message[\"content-type\"] = content_type_value\n+                            if message.get_content_maintype() == \"application\":\n+                                subtype = message.get_content_subtype()\n+                                if subtype == \"json\" or subtype.endswith(\"+json\"):\n+                                    json_body = await request.json()\n+                        if json_body != Undefined:\n+                            body = json_body\n+                        else:\n+                            body = body_bytes\n         except json.JSONDecodeError as e:\n             raise RequestValidationError([ErrorWrapper(e, (\"body\", e.pos))], body=e.doc)\n         except Exception as e:"
        },
        {
          "filename": "tests/test_tutorial/test_body/test_tutorial001.py",
          "status": "modified",
          "additions": 75,
          "deletions": 9,
          "patch": "@@ -173,25 +173,91 @@ def test_post_body(path, body, expected_status, expected_response):\n \n \n def test_post_broken_body():\n-    response = client.post(\"/items/\", data={\"name\": \"Foo\", \"price\": 50.5})\n+    response = client.post(\n+        \"/items/\",\n+        headers={\"content-type\": \"application/json\"},\n+        data=\"{some broken json}\",\n+    )\n     assert response.status_code == 422, response.text\n     assert response.json() == {\n         \"detail\": [\n             {\n+                \"loc\": [\"body\", 1],\n+                \"msg\": \"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)\",\n+                \"type\": \"value_error.jsondecode\",\n                 \"ctx\": {\n-                    \"colno\": 1,\n-                    \"doc\": \"name=Foo&price=50.5\",\n+                    \"msg\": \"Expecting property name enclosed in double quotes\",\n+                    \"doc\": \"{some broken json}\",\n+                    \"pos\": 1,\n                     \"lineno\": 1,\n-                    \"msg\": \"Expecting value\",\n-                    \"pos\": 0,\n+                    \"colno\": 2,\n                 },\n-                \"loc\": [\"body\", 0],\n-                \"msg\": \"Expecting value: line 1 column 1 (char 0)\",\n-                \"type\": \"value_error.jsondecode\",\n             }\n         ]\n     }\n+\n+\n+def test_post_form_for_json():\n+    response = client.post(\"/items/\", data={\"name\": \"Foo\", \"price\": 50.5})\n+    assert response.status_code == 422, response.text\n+    assert response.json() == {\n+        \"detail\": [\n+            {\n+                \"loc\": [\"body\"],\n+                \"msg\": \"value is not a valid dict\",\n+                \"type\": \"type_error.dict\",\n+            }\n+        ]\n+    }\n+\n+\n+def test_explicit_content_type():\n+    response = client.post(\n+        \"/items/\",\n+        data='{\"name\": \"Foo\", \"price\": 50.5}',\n+        headers={\"Content-Type\": \"application/json\"},\n+    )\n+    assert response.status_code == 200, response.text\n+\n+\n+def test_geo_json():\n+    response = client.post(\n+        \"/items/\",\n+        data='{\"name\": \"Foo\", \"price\": 50.5}',\n+        headers={\"Content-Type\": \"application/geo+json\"},\n+    )\n+    assert response.status_code == 200, response.text\n+\n+\n+def test_wrong_headers():\n+    data = '{\"name\": \"Foo\", \"price\": 50.5}'\n+    invalid_dict = {\n+        \"detail\": [\n+            {\n+                \"loc\": [\"body\"],\n+                \"msg\": \"value is not a valid dict\",\n+                \"type\": \"type_error.dict\",\n+            }\n+        ]\n+    }\n+\n+    response = client.post(\"/items/\", data=data, headers={\"Content-Type\": \"text/plain\"})\n+    assert response.status_code == 422, response.text\n+    assert response.json() == invalid_dict\n+\n+    response = client.post(\n+        \"/items/\", data=data, headers={\"Content-Type\": \"application/geo+json-seq\"}\n+    )\n+    assert response.status_code == 422, response.text\n+    assert response.json() == invalid_dict\n+    response = client.post(\n+        \"/items/\", data=data, headers={\"Content-Type\": \"application/not-really-json\"}\n+    )\n+    assert response.status_code == 422, response.text\n+    assert response.json() == invalid_dict\n+\n+\n+def test_other_exceptions():\n     with patch(\"json.loads\", side_effect=Exception):\n         response = client.post(\"/items/\", json={\"test\": \"test2\"})\n         assert response.status_code == 400, response.text\n-    assert response.json() == {\"detail\": \"There was an error parsing the body\"}"
        },
        {
          "filename": "tests/test_tutorial/test_custom_request_and_route/test_tutorial001.py",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -25,6 +25,7 @@ def test_gzip_request(compress):\n     if compress:\n         data = gzip.compress(data)\n         headers[\"Content-Encoding\"] = \"gzip\"\n+    headers[\"Content-Type\"] = \"application/json\"\n     response = client.post(\"/sum\", data=data, headers=headers)\n     assert response.json() == {\"sum\": n}\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2612fa3e9d17fe74c97029b55b5d64be2d38400f",
            "date": "2025-01-13T13:36:46Z",
            "author_login": "invalid-email-address"
          },
          {
            "sha": "5d18ae0d902111bca76fabe6d136adafce2b4daf",
            "date": "2025-01-13T13:36:23Z",
            "author_login": "gerry-sabar"
          },
          {
            "sha": "09a0295bf3bd604eb0acd7eb1f9d9cd4852f3805",
            "date": "2025-01-10T20:31:39Z",
            "author_login": "invalid-email-address"
          },
          {
            "sha": "cda85623fbd58b10c7670557094588eaebef34d8",
            "date": "2025-01-10T20:31:13Z",
            "author_login": "guspan-tanadi"
          },
          {
            "sha": "62be4a1600b29d3bcf717fa0b14a55ab1d5b7e57",
            "date": "2025-01-10T13:33:58Z",
            "author_login": "invalid-email-address"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.2,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:H/A:N",
    "cwe_id": "CWE-352",
    "description": "FastAPI is a web framework for building APIs with Python 3.6+ based on standard Python type hints. FastAPI versions lower than 0.65.2 that used cookies for authentication in path operations that received JSON payloads sent by browsers were vulnerable to a Cross-Site Request Forgery (CSRF) attack. In versions lower than 0.65.2, FastAPI would try to read the request payload as JSON even if the content-type header sent was not set to application/json or a compatible JSON media type (e.g. application/geo+json). A request with a content type of text/plain containing JSON data would be accepted and the JSON data would be extracted. Requests with content type text/plain are exempt from CORS preflights, for being considered Simple requests. The browser will execute them right away including cookies, and the text content could be a JSON string that would be parsed and accepted by the FastAPI application. This is fixed in FastAPI 0.65.2. The request data is now parsed as JSON only if the content-type header is application/json or another JSON compatible media type like application/geo+json. It's best to upgrade to the latest FastAPI, but if updating is not possible then a middleware or a dependency that checks the content-type header and aborts the request if it is not application/json or another JSON compatible content type can act as a mitigating workaround.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-06-09T18:15:08.553",
    "last_modified": "2024-11-21T06:07:30.713",
    "fix_date": "2021-06-07T10:46:18Z"
  },
  "references": [
    {
      "url": "https://github.com/tiangolo/fastapi/commit/fa7e3c996edf2d5482fff8f9d890ac2390dede4d",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tiangolo/fastapi/security/advisories/GHSA-8h2j-cgx8-6xv7",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/MATAWX25TYKNEKLDMKWNLYDB34UWTROA/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/tiangolo/fastapi/commit/fa7e3c996edf2d5482fff8f9d890ac2390dede4d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tiangolo/fastapi/security/advisories/GHSA-8h2j-cgx8-6xv7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/MATAWX25TYKNEKLDMKWNLYDB34UWTROA/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:59.721139",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "fastapi",
    "owner": "tiangolo",
    "created_at": "2018-12-08T08:21:47Z",
    "updated_at": "2025-01-14T13:56:12Z",
    "pushed_at": "2025-01-13T17:52:13Z",
    "size": 25186,
    "stars": 79515,
    "forks": 6807,
    "open_issues": 324,
    "watchers": 79515,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Python": 3776614,
      "JavaScript": 1066,
      "Shell": 452,
      "HTML": 235,
      "CSS": 25
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T14:26:47.886853"
  }
}