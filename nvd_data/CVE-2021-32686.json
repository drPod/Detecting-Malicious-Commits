{
  "cve_id": "CVE-2021-32686",
  "github_data": {
    "repository": "pjsip/pjproject",
    "fix_commit": "d5f95aa066f878b0aef6a64e60b61e8626e664cd",
    "related_commits": [
      "d5f95aa066f878b0aef6a64e60b61e8626e664cd",
      "d5f95aa066f878b0aef6a64e60b61e8626e664cd"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "d5f95aa066f878b0aef6a64e60b61e8626e664cd",
      "commit_date": "2021-07-23T03:49:21Z",
      "author": {
        "login": "nanangizz",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-cv8x-p47p-99wr",
        "length": 602,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 115,
        "additions": 95,
        "deletions": 20
      },
      "files": [
        {
          "filename": "pjlib/src/pj/ssl_sock_imp_common.c",
          "status": "modified",
          "additions": 35,
          "deletions": 12,
          "patch": "@@ -255,6 +255,8 @@ static pj_bool_t on_handshake_complete(pj_ssl_sock_t *ssock,\n \n     /* Accepting */\n     if (ssock->is_server) {\n+\tpj_bool_t ret = PJ_TRUE;\n+\n \tif (status != PJ_SUCCESS) {\n \t    /* Handshake failed in accepting, destroy our self silently. */\n \n@@ -272,6 +274,12 @@ static pj_bool_t on_handshake_complete(pj_ssl_sock_t *ssock,\n \t\t      status);\n \t    }\n \n+\t    /* Decrement ref count of parent */\n+\t    if (ssock->parent->param.grp_lock) {\n+\t\tpj_grp_lock_dec_ref(ssock->parent->param.grp_lock);\n+\t\tssock->parent = NULL;\n+\t    }\n+\n \t    /* Originally, this is a workaround for ticket #985. However,\n \t     * a race condition may occur in multiple worker threads\n \t     * environment when we are destroying SSL objects while other\n@@ -315,23 +323,29 @@ static pj_bool_t on_handshake_complete(pj_ssl_sock_t *ssock,\n \n \t    return PJ_FALSE;\n \t}\n+\n \t/* Notify application the newly accepted SSL socket */\n \tif (ssock->param.cb.on_accept_complete2) {\n-\t    pj_bool_t ret;\n \t    ret = (*ssock->param.cb.on_accept_complete2) \n \t\t    (ssock->parent, ssock, (pj_sockaddr_t*)&ssock->rem_addr, \n \t\t    pj_sockaddr_get_len((pj_sockaddr_t*)&ssock->rem_addr), \n \t\t    status);\n-\t    if (ret == PJ_FALSE)\n-\t\treturn PJ_FALSE;\t\n \t} else if (ssock->param.cb.on_accept_complete) {\n-\t    pj_bool_t ret;\n \t    ret = (*ssock->param.cb.on_accept_complete)\n \t\t      (ssock->parent, ssock, (pj_sockaddr_t*)&ssock->rem_addr,\n \t\t       pj_sockaddr_get_len((pj_sockaddr_t*)&ssock->rem_addr));\n-\t    if (ret == PJ_FALSE)\n-\t\treturn PJ_FALSE;\n \t}\n+\n+\t/* Decrement ref count of parent and reset parent (we don't need it\n+\t * anymore, right?).\n+\t */\n+\tif (ssock->parent->param.grp_lock) {\n+\t    pj_grp_lock_dec_ref(ssock->parent->param.grp_lock);\n+\t    ssock->parent = NULL;\n+\t}\n+\n+\tif (ret == PJ_FALSE)\n+\t    return PJ_FALSE;\n     }\n \n     /* Connecting */\n@@ -930,9 +944,13 @@ static pj_bool_t ssock_on_accept_complete (pj_ssl_sock_t *ssock_parent,\n     if (status != PJ_SUCCESS)\n \tgoto on_return;\n \n+    /* Set parent and add ref count (avoid parent destroy during handshake) */\n+    ssock->parent = ssock_parent;\n+    if (ssock->parent->param.grp_lock)\n+\tpj_grp_lock_add_ref(ssock->parent->param.grp_lock);\n+\n     /* Update new SSL socket attributes */\n     ssock->sock = newsock;\n-    ssock->parent = ssock_parent;\n     ssock->is_server = PJ_TRUE;\n     if (ssock_parent->cert) {\n \tstatus = pj_ssl_sock_set_certificate(ssock, ssock->pool, \n@@ -957,16 +975,20 @@ static pj_bool_t ssock_on_accept_complete (pj_ssl_sock_t *ssock_parent,\n     ssock->asock_rbuf = (void**)pj_pool_calloc(ssock->pool, \n \t\t\t\t\t       ssock->param.async_cnt,\n \t\t\t\t\t       sizeof(void*));\n-    if (!ssock->asock_rbuf)\n-        return PJ_ENOMEM;\n+    if (!ssock->asock_rbuf) {\n+\tstatus = PJ_ENOMEM;\n+\tgoto on_return;\n+    }\n \n     for (i = 0; i<ssock->param.async_cnt; ++i) {\n \tssock->asock_rbuf[i] = (void*) pj_pool_alloc(\n \t\t\t\t\t    ssock->pool, \n \t\t\t\t\t    ssock->param.read_buffer_size + \n \t\t\t\t\t    sizeof(read_data_t*));\n-        if (!ssock->asock_rbuf[i])\n-            return PJ_ENOMEM;\n+\tif (!ssock->asock_rbuf[i]) {\n+\t    status = PJ_ENOMEM;\n+\t    goto on_return;\n+\t}\n     }\n \n     /* If listener socket has group lock, automatically create group lock\n@@ -980,7 +1002,7 @@ static pj_bool_t ssock_on_accept_complete (pj_ssl_sock_t *ssock_parent,\n \t    goto on_return;\n \n \tpj_grp_lock_add_ref(glock);\n-\tasock_cfg.grp_lock = ssock->param.grp_lock = glock;\n+\tssock->param.grp_lock = glock;\n \tpj_grp_lock_add_handler(ssock->param.grp_lock, ssock->pool, ssock,\n \t\t\t\tssl_on_destroy);\n     }\n@@ -1008,6 +1030,7 @@ static pj_bool_t ssock_on_accept_complete (pj_ssl_sock_t *ssock_parent,\n \n     /* Create active socket */\n     pj_activesock_cfg_default(&asock_cfg);\n+    asock_cfg.grp_lock = ssock->param.grp_lock;\n     asock_cfg.async_cnt = ssock->param.async_cnt;\n     asock_cfg.concurrency = ssock->param.concurrency;\n     asock_cfg.whole_data = PJ_TRUE;"
        },
        {
          "filename": "pjlib/src/pj/ssl_sock_ossl.c",
          "status": "modified",
          "additions": 38,
          "deletions": 7,
          "patch": "@@ -327,7 +327,8 @@ static pj_status_t STATUS_FROM_SSL_ERR(char *action, pj_ssl_sock_t *ssock,\n \tERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n     }\n \n-    ssock->last_err = err;\n+    if (ssock)\n+\tssock->last_err = err;\n     return GET_STATUS_FROM_SSL_ERR(err);\n }\n \n@@ -344,7 +345,8 @@ static pj_status_t STATUS_FROM_SSL_ERR2(char *action, pj_ssl_sock_t *ssock,\n     /* Dig for more from OpenSSL error queue */\n     SSLLogErrors(action, ret, err, len, ssock);\n \n-    ssock->last_err = ssl_err;\n+    if (ssock)\n+\tssock->last_err = ssl_err;\n     return GET_STATUS_FROM_SSL_ERR(ssl_err);\n }\n \n@@ -786,6 +788,13 @@ static pj_status_t init_openssl(void)\n \n     /* Create OpenSSL application data index for SSL socket */\n     sslsock_idx = SSL_get_ex_new_index(0, \"SSL socket\", NULL, NULL, NULL);\n+    if (sslsock_idx == -1) {\n+\tstatus = STATUS_FROM_SSL_ERR2(\"Init\", NULL, -1, ERR_get_error(), 0);\n+\tPJ_LOG(1,(THIS_FILE,\n+\t       \"Fatal error: failed to get application data index for \"\n+\t       \"SSL socket\"));\n+\treturn status;\n+    }\n \n #if defined(PJ_SSL_SOCK_OSSL_USE_THREAD_CB) && \\\n     PJ_SSL_SOCK_OSSL_USE_THREAD_CB != 0 && OPENSSL_VERSION_NUMBER < 0x10100000L\n@@ -819,21 +828,36 @@ static int password_cb(char *buf, int num, int rwflag, void *user_data)\n }\n \n \n-/* SSL password callback. */\n+/* SSL certificate verification result callback.\n+ * Note that this callback seems to be always called from library worker\n+ * thread, e.g: active socket on_read_complete callback, which should have\n+ * already been equipped with race condition avoidance mechanism (should not\n+ * be destroyed while callback is being invoked).\n+ */\n static int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)\n {\n-    pj_ssl_sock_t *ssock;\n-    SSL *ossl_ssl;\n+    pj_ssl_sock_t *ssock = NULL;\n+    SSL *ossl_ssl = NULL;\n     int err;\n \n     /* Get SSL instance */\n     ossl_ssl = X509_STORE_CTX_get_ex_data(x509_ctx, \n \t\t\t\t    SSL_get_ex_data_X509_STORE_CTX_idx());\n-    pj_assert(ossl_ssl);\n+    if (!ossl_ssl) {\n+\tPJ_LOG(1,(THIS_FILE,\n+\t\t  \"SSL verification callback failed to get SSL instance\"));\n+\tgoto on_return;\n+    }\n \n     /* Get SSL socket instance */\n     ssock = SSL_get_ex_data(ossl_ssl, sslsock_idx);\n-    pj_assert(ssock);\n+    if (!ssock) {\n+\t/* SSL socket may have been destroyed */\n+\tPJ_LOG(1,(THIS_FILE,\n+\t\t  \"SSL verification callback failed to get SSL socket \"\n+\t\t  \"instance (sslsock_idx=%d).\", sslsock_idx));\n+\tgoto on_return;\n+    }\n \n     /* Store verification status */\n     err = X509_STORE_CTX_get_error(x509_ctx);\n@@ -911,6 +935,7 @@ static int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)\n     if (PJ_FALSE == ssock->param.verify_peer)\n \tpreverify_ok = 1;\n \n+on_return:\n     return preverify_ok;\n }\n \n@@ -1474,6 +1499,12 @@ static void ssl_destroy(pj_ssl_sock_t *ssock)\n static void ssl_reset_sock_state(pj_ssl_sock_t *ssock)\n {\n     ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n+\n+    /* Detach from SSL instance */\n+    if (ossock->ossl_ssl) {\n+\tSSL_set_ex_data(ossock->ossl_ssl, sslsock_idx, NULL);\n+    }\n+\n     /**\n      * Avoid calling SSL_shutdown() if handshake wasn't completed.\n      * OpenSSL 1.0.2f complains if SSL_shutdown() is called during an"
        },
        {
          "filename": "pjsip/src/pjsip/sip_transport_tls.c",
          "status": "modified",
          "additions": 22,
          "deletions": 1,
          "patch": "@@ -1333,9 +1333,26 @@ static pj_bool_t on_accept_complete2(pj_ssl_sock_t *ssock,\n     PJ_UNUSED_ARG(src_addr_len);\n \n     listener = (struct tls_listener*) pj_ssl_sock_get_user_data(ssock);\n+    if (!listener) {\n+\t/* Listener already destroyed, e.g: after TCP accept but before SSL\n+\t * handshake is completed.\n+\t */\n+\tif (new_ssock && accept_status == PJ_SUCCESS) {\n+\t    /* Close the SSL socket if the accept op is successful */\n+\t    PJ_LOG(4,(THIS_FILE,\n+\t\t      \"Incoming TLS connection from %s (sock=%d) is discarded \"\n+\t\t      \"because listener is already destroyed\",\n+\t\t      pj_sockaddr_print(src_addr, addr, sizeof(addr), 3),\n+\t\t      new_ssock));\n+\n+\t    pj_ssl_sock_close(new_ssock);\n+\t}\n+\n+\treturn PJ_FALSE;\n+    }\n \n     if (accept_status != PJ_SUCCESS) {\n-\tif (listener && listener->tls_setting.on_accept_fail_cb) {\n+\tif (listener->tls_setting.on_accept_fail_cb) {\n \t    pjsip_tls_on_accept_fail_param param;\n \t    pj_ssl_sock_info ssi;\n \n@@ -1358,6 +1375,8 @@ static pj_bool_t on_accept_complete2(pj_ssl_sock_t *ssock,\n     PJ_ASSERT_RETURN(new_ssock, PJ_TRUE);\n \n     if (!listener->is_registered) {\n+\tpj_ssl_sock_close(new_ssock);\n+\n \tif (listener->tls_setting.on_accept_fail_cb) {\n \t    pjsip_tls_on_accept_fail_param param;\n \t    pj_bzero(&param, sizeof(param));\n@@ -1409,6 +1428,8 @@ static pj_bool_t on_accept_complete2(pj_ssl_sock_t *ssock,\n \t\t\t ssl_info.grp_lock, &tls);\n     \n     if (status != PJ_SUCCESS) {\n+\tpj_ssl_sock_close(new_ssock);\n+\n \tif (listener->tls_setting.on_accept_fail_cb) {\n \t    pjsip_tls_on_accept_fail_param param;\n \t    pj_bzero(&param, sizeof(param));"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "a89917e5addc990252b4ebde7fbb3da89742b21f",
            "date": "2025-01-24T06:49:59Z",
            "author_login": "sauwming"
          },
          {
            "sha": "377a80cefe6647bccce3915840b4b238ba523be3",
            "date": "2025-01-24T06:48:31Z",
            "author_login": "nanangizz"
          },
          {
            "sha": "de3f2e1e64fca8ef48bda3774caeae6cabd306f0",
            "date": "2025-01-24T02:20:28Z",
            "author_login": "sauwming"
          },
          {
            "sha": "cdb129406a126335fc1008e386aef7b4a3342013",
            "date": "2025-01-23T03:01:27Z",
            "author_login": "sauwming"
          },
          {
            "sha": "0899186444ac5d0cff9a5198cb1d4c754a45aacf",
            "date": "2025-01-22T05:22:12Z",
            "author_login": "nanangizz"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-362",
    "description": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In PJSIP before version 2.11.1, there are a couple of issues found in the SSL socket. First, a race condition between callback and destroy, due to the accepted socket having no group lock. Second, the SSL socket parent/listener may get destroyed during handshake. Both issues were reported to happen intermittently in heavy load TLS connections. They cause a crash, resulting in a denial of service. These are fixed in version 2.11.1.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2021-07-23T22:15:08.373",
    "last_modified": "2024-11-21T06:07:31.830",
    "fix_date": "2021-07-23T03:49:21Z"
  },
  "references": [
    {
      "url": "https://github.com/pjsip/pjproject/commit/d5f95aa066f878b0aef6a64e60b61e8626e664cd",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/pjsip/pjproject/pull/2716",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/pjsip/pjproject/releases/tag/2.11.1",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-cv8x-p47p-99wr",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202210-37",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2021/dsa-4999",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/pjsip/pjproject/commit/d5f95aa066f878b0aef6a64e60b61e8626e664cd",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/pjsip/pjproject/pull/2716",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/pjsip/pjproject/releases/tag/2.11.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-cv8x-p47p-99wr",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202210-37",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2021/dsa-4999",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:02.333902",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "pjproject",
    "owner": "pjsip",
    "created_at": "2016-01-24T05:00:33Z",
    "updated_at": "2025-01-24T06:50:04Z",
    "pushed_at": "2025-01-25T04:42:48Z",
    "size": 45463,
    "stars": 2170,
    "forks": 813,
    "open_issues": 15,
    "watchers": 2170,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 15271741,
      "C++": 1658626,
      "Python": 553465,
      "Shell": 395169,
      "Objective-C": 327121,
      "C#": 141563,
      "Makefile": 115036,
      "Java": 114622,
      "Mathematica": 86105,
      "SWIG": 41289,
      "Swift": 38034,
      "CSS": 21213,
      "Kotlin": 17696,
      "Rust": 4860,
      "Objective-C++": 3801,
      "HTML": 3320,
      "QMake": 3180,
      "Batchfile": 1805,
      "QML": 1121,
      "Pan": 288,
      "Prolog": 25
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-26T07:47:22.881148"
  }
}