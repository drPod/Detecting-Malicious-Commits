{
  "cve_id": "CVE-2021-32701",
  "github_data": {
    "repository": "ory/oathkeeper",
    "fix_commit": "1f9f625c1a49e134ae2299ee95b8cf158feec932",
    "related_commits": [
      "1f9f625c1a49e134ae2299ee95b8cf158feec932",
      "1f9f625c1a49e134ae2299ee95b8cf158feec932"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "1f9f625c1a49e134ae2299ee95b8cf158feec932",
      "commit_date": "2021-06-22T13:02:29Z",
      "author": {
        "login": "aeneasr",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-qvp4-rpmr-xwrr",
        "length": 274,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 588,
        "additions": 402,
        "deletions": 186
      },
      "files": [
        {
          "filename": ".circleci/config.yml",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -30,8 +30,9 @@ jobs:\n       - golangci/install\n       - golangci/lint\n       - run: go install github.com/ory/go-acc github.com/mattn/goveralls\n-      - run: go-acc -o coverage.txt ./... -- -failfast -timeout=20m\n-      - run: test -z \"$CIRCLE_PR_NUMBER\" && goveralls -service=circle-ci -coverprofile=coverage.txt -repotoken=$COVERALLS_REPO_TOKEN || echo \"forks are not allowed to push to coveralls\"\n+      - run: go-acc -o coverage.out ./... -- -failfast -timeout=20m\n+      - run: |\n+          bash <(curl -s https://codecov.io/bash)\n       - run: ./test/e2e/run.sh\n       - run: ./test/reload/run.sh\n "
        },
        {
          "filename": "Makefile",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -18,6 +18,9 @@ define make-go-dependency\n endef\n $(foreach dep, $(GO_DEPENDENCIES), $(eval $(call make-go-dependency, $(dep))))\n \n+node_modules: package.json package-lock.json\n+\t\tnpm i\n+\n .bin/clidoc: go.mod\n \t\tgo build -o .bin/clidoc ./cmd/clidoc/.\n "
        },
        {
          "filename": "docs/docs/CHANGELOG.md",
          "status": "modified",
          "additions": 125,
          "deletions": 137,
          "patch": "@@ -25,16 +25,16 @@ custom_edit_url: null\n   The remote authorizers may have useful context from user's permissions. So\n   with this changes, custom authorizers using remote and remote_json can return\n   some useful headers to be forward into the AuthenticationSession, meaning that\n-  these headers will be passed to upstream services.\n-  For example, an user containing scopes/branches inside an organization profile\n-  has some level of data addressed to him. In this case, the upstream service\n-  need to know that, and \"filter\" the data according to his \"branch_id\". The\n-  permission that is given to the user (and the remote authorizers manages) has\n-  a record of the \"branch_id\", for the following responses will be returned as\n-  status code 200 (if granted) and containing a header like X-Branch-Id.\n-  The upstream service receives the X-Branch-Id and does your thing.\n-  The configuration requires to configure a list of \"allowed headers\" returning\n-  from remote authorizer, that will be accepted in the pipeline.\n+  these headers will be passed to upstream services. For example, an user\n+  containing scopes/branches inside an organization profile has some level of\n+  data addressed to him. In this case, the upstream service need to know that,\n+  and \"filter\" the data according to his \"branch_id\". The permission that is\n+  given to the user (and the remote authorizers manages) has a record of the\n+  \"branch_id\", for the following responses will be returned as status code 200\n+  (if granted) and containing a header like X-Branch-Id. The upstream service\n+  receives the X-Branch-Id and does your thing. The configuration requires to\n+  configure a list of \"allowed headers\" returning from remote authorizer, that\n+  will be accepted in the pipeline.\n - Add request header in match context\n   ([#719](https://github.com/ory/oathkeeper/issues/719))\n   ([22b0dbe](https://github.com/ory/oathkeeper/commit/22b0dbe6495b9f57206dc8fb2335e1c81906e27d)),\n@@ -104,9 +104,11 @@ Web Token debuggability, and resolves other issues.\n \n - Add dotnet sdk ([#683](https://github.com/ory/oathkeeper/issues/683))\n   ([05ae925](https://github.com/ory/oathkeeper/commit/05ae9259414882015f30cc8d5c01e64afb65afbc)):\n+\n   - docs: add dotnet sdk\n \n   - docs: add dotnet sdk versioned\n+\n - Change forum to discussions readme\n   ([#690](https://github.com/ory/oathkeeper/issues/690))\n   ([d942c04](https://github.com/ory/oathkeeper/commit/d942c043aa2370b87e0dd822440ad39d809755f9))\n@@ -137,8 +139,8 @@ Web Token debuggability, and resolves other issues.\n - Additional JWT auth debug information\n   ([#681](https://github.com/ory/oathkeeper/issues/681))\n   ([d08ab50](https://github.com/ory/oathkeeper/commit/d08ab5034b80736701fb38ee1e55d12c63fd06b2)),\n-  closes [#668](https://github.com/ory/oathkeeper/issues/668):\n-  JWT Claims added to error details field.\n+  closes [#668](https://github.com/ory/oathkeeper/issues/668): JWT Claims added\n+  to error details field.\n - Adds audience into Extra at oAuth2 introspection\n   ([#480](https://github.com/ory/oathkeeper/issues/480))\n   ([c9faecc](https://github.com/ory/oathkeeper/commit/c9faecc5d32800537f07e8e05f9c8872e609c3f9))\n@@ -168,9 +170,9 @@ autogen: pin v0.38.9-beta.1.pre.3 release commit\n - Make glob patterns match only one path segment.\n   ([#664](https://github.com/ory/oathkeeper/issues/664))\n   ([c711aac](https://github.com/ory/oathkeeper/commit/c711aacc5fc29664e3825e087557e7baf4e47aa8)),\n-  closes [#630](https://github.com/ory/oathkeeper/issues/630):\n-  This makes `/` also a separator as well as the presumably default value of\n-  `.`. This allows using <\\*> for matching only one path segment.\n+  closes [#630](https://github.com/ory/oathkeeper/issues/630): This makes `/`\n+  also a separator as well as the presumably default value of `.`. This allows\n+  using <\\*> for matching only one path segment.\n \n ### Code Generation\n \n@@ -427,11 +429,10 @@ This release stabilizes several features and resolves a couple of bugs.\n - Add url_param config option to redirect error handler.\n   ([#520](https://github.com/ory/oathkeeper/issues/520))\n   ([b5bb3bc](https://github.com/ory/oathkeeper/commit/b5bb3bc6b88ea8b26d53f03477fce1b74f113b97)),\n-  closes [#511](https://github.com/ory/oathkeeper/issues/511):\n-  This change introduces a url_param config option for redirect error handler.\n-  If it contains a url paramter name, the redirect url will have this parameter\n-  set, containing the current url (from which Oathkeeper has redirected the\n-  user).\n+  closes [#511](https://github.com/ory/oathkeeper/issues/511): This change\n+  introduces a url_param config option for redirect error handler. If it\n+  contains a url paramter name, the redirect url will have this parameter set,\n+  containing the current url (from which Oathkeeper has redirected the user).\n   This can be useful in passing the return_to url to Kratos, so user can be\n   redirected to the page they initially wanted to access after a successfull\n   sign in.\n@@ -570,9 +571,8 @@ No backwards incompatible changes have been introduced.\n   back. This can include the Content-Length header which describes the request\n   body or response. Including the original request Content-Length causes issues\n   for the decission endpoint client if the response body doesn't match the exact\n-  size.\n-  This change makes sure the Content-Length doesn't get included in the response\n-  body and adds a test to prevent future regressions.\n+  size. This change makes sure the Content-Length doesn't get included in the\n+  response body and adds a test to prevent future regressions.\n - Respect retry in token introspection\n   ([#410](https://github.com/ory/oathkeeper/issues/410))\n   ([88f7b69](https://github.com/ory/oathkeeper/commit/88f7b69c9ff252ddc3dbe960155883ec98115fd0))\n@@ -644,18 +644,17 @@ No backwards incompatible changes have been introduced.\n \n - Add cache to hydrator ([#418](https://github.com/ory/oathkeeper/issues/418))\n   ([1ae6e7a](https://github.com/ory/oathkeeper/commit/1ae6e7a958d602533f54cada5d231bcf1bace093)),\n-  closes [#417](https://github.com/ory/oathkeeper/issues/417):\n-  This patch introduces new configuration parameters that allow the hydrator\n-  mutator to cache requests.\n+  closes [#417](https://github.com/ory/oathkeeper/issues/417): This patch\n+  introduces new configuration parameters that allow the hydrator mutator to\n+  cache requests.\n - Add new remote authorizer that uses request body and headers\n   ([#416](https://github.com/ory/oathkeeper/issues/416))\n   ([3a20637](https://github.com/ory/oathkeeper/commit/3a206376c0ec4d72d5d6ec66c2d738199a24e0c6)):\n   This pull request implements a new authorizer that sends the original request\n   body as body to the remote endpoint. This allows the remote endpoint to take\n-  the body into account in its decision.\n-  The current remote_json authorizer does not have the ability to send the\n-  request body of the request to authorize. This means this cannot be taken into\n-  account while checking permissions.\n+  the body into account in its decision. The current remote_json authorizer does\n+  not have the ability to send the request body of the request to authorize.\n+  This means this cannot be taken into account while checking permissions.\n   Providing the request body as part of the JSON payload won't always work as\n   JSON cannot handle binary data.\n - Add prometheus docs ([#427](https://github.com/ory/oathkeeper/issues/427))\n@@ -730,22 +729,20 @@ https://github.com/ory/oathkeeper/pull/358/commits/fd16ceb230a1b14ebb01a147d2d70\n - SendOAuth2 introspection scope only when strategy is none\n   ([#379](https://github.com/ory/oathkeeper/issues/379))\n   ([5e0c8dc](https://github.com/ory/oathkeeper/commit/5e0c8dcdc4a64662f59372a488ec633bcdbc0d85)),\n-  closes [#377](https://github.com/ory/oathkeeper/issues/377):\n-  This patch removes the `scope` key from the OAuth2 Introspection request body\n-  when a scope strategy other than `none` is set for the OAuth2 Introspection\n-  handler. If the scope strategy is `none`, the `scope` key is included in the\n-  body.\n+  closes [#377](https://github.com/ory/oathkeeper/issues/377): This patch\n+  removes the `scope` key from the OAuth2 Introspection request body when a\n+  scope strategy other than `none` is set for the OAuth2 Introspection handler.\n+  If the scope strategy is `none`, the `scope` key is included in the body.\n - Token expiration error in tests\n   ([#390](https://github.com/ory/oathkeeper/issues/390))\n   ([9c07a73](https://github.com/ory/oathkeeper/commit/9c07a7349cdf560c0ba29a637aaec93021757d27))\n - **docker:** Improve docker-compose example\n   ([#325](https://github.com/ory/oathkeeper/issues/325))\n   ([1247381](https://github.com/ory/oathkeeper/commit/12473815dad3fcbc57ea102dd982170960adb9f6)),\n-  closes [#324](https://github.com/ory/oathkeeper/issues/324):\n-  Add a new file 'Dockerfile-dc' which will primarily be used by Docker Compose\n-  to build docker images. Unlike the existing Dockerfile which depends on the\n-  Makefile to build the binary, this Dockerfile copies the source code and\n-  builds the binary.\n+  closes [#324](https://github.com/ory/oathkeeper/issues/324): Add a new file\n+  'Dockerfile-dc' which will primarily be used by Docker Compose to build docker\n+  images. Unlike the existing Dockerfile which depends on the Makefile to build\n+  the binary, this Dockerfile copies the source code and builds the binary.\n   Oathkeeper has gone through a couple of changes since the initial draft of the\n   docker compose file, considering these changes and the newly introduced\n   Dockerfile in the previous commit, make these changes to the\n@@ -815,8 +812,8 @@ https://github.com/ory/oathkeeper/pull/358/commits/fd16ceb230a1b14ebb01a147d2d70\n   ([d9eed10](https://github.com/ory/oathkeeper/commit/d9eed10abd43eb41362fcc0f36e47a6f88658835))\n - Update README.md ([#375](https://github.com/ory/oathkeeper/issues/375))\n   ([313d2fe](https://github.com/ory/oathkeeper/commit/313d2fe99f699c441e6f8e24abb096e239a17f83)),\n-  closes [#374](https://github.com/ory/oathkeeper/issues/374):\n-  Fixed link to Envoy configuration page and added link to AWS API Gateway.\n+  closes [#374](https://github.com/ory/oathkeeper/issues/374): Fixed link to\n+  Envoy configuration page and added link to AWS API Gateway.\n - Updates issue and pull request templates\n   ([#382](https://github.com/ory/oathkeeper/issues/382))\n   ([484c406](https://github.com/ory/oathkeeper/commit/484c406785c2633feee3cb9179a94147085cadd6))\n@@ -878,10 +875,9 @@ docs: Regenerate and update changelog\n - **rule:** Add glob matching strategy\n   ([#334](https://github.com/ory/oathkeeper/issues/334))\n   ([5f983ab](https://github.com/ory/oathkeeper/commit/5f983ab118ce784a49a38e6024b99b8791907d4b)),\n-  closes [#321](https://github.com/ory/oathkeeper/issues/321):\n-  This patch adds the ability to choose a matching strategy and adds a\n-  glob-based matching strategy to the available options (regex is still the\n-  default).\n+  closes [#321](https://github.com/ory/oathkeeper/issues/321): This patch adds\n+  the ability to choose a matching strategy and adds a glob-based matching\n+  strategy to the available options (regex is still the default).\n \n ### Unclassified\n \n@@ -1020,22 +1016,21 @@ Update CHANGELOG [ci skip]\n   closes [#333](https://github.com/ory/oathkeeper/issues/333)\n - authn/cookie_session: Add subject_from modifier (#336)\n   ([6723fb8](https://github.com/ory/oathkeeper/commit/6723fb834c386b72e9525d2dfd661e684bd915d3)),\n-  closes [#336](https://github.com/ory/oathkeeper/issues/336):\n-  The subject_from modifier is a GJSON path that points to the `subject` field.\n-  Useful if the upstream API does not return a `{\"subject\": \"...\"}` format.\n+  closes [#336](https://github.com/ory/oathkeeper/issues/336): The subject_from\n+  modifier is a GJSON path that points to the `subject` field. Useful if the\n+  upstream API does not return a `{\"subject\": \"...\"}` format.\n - authn/cookie_session: Add extra_from modifier (#335)\n   ([ee2b9e7](https://github.com/ory/oathkeeper/commit/ee2b9e743f4f6c56563d791947ffb592cc13394e)),\n-  closes [#335](https://github.com/ory/oathkeeper/issues/335):\n-  The extra_from modifier is a GJSON path that points to the extra field. Useful\n-  if the upstream API does not return a `{\"subject\": \"...\", \"extra\": \"...\"}`\n-  format.\n+  closes [#335](https://github.com/ory/oathkeeper/issues/335): The extra_from\n+  modifier is a GJSON path that points to the extra field. Useful if the\n+  upstream API does not return a `{\"subject\": \"...\", \"extra\": \"...\"}` format.\n - pipeline/authn: Add tests for cookie sources in jwt and oauth2_intro (#330)\n   (#331)\n   ([7516eed](https://github.com/ory/oathkeeper/commit/7516eedc1ea97242a18225365898e0cbeafcffbf)),\n   closes [#330](https://github.com/ory/oathkeeper/issues/330)\n   [#331](https://github.com/ory/oathkeeper/issues/331)\n-  [#330](https://github.com/ory/oathkeeper/issues/330):\n-  Also updates the schemas to add missing cookie config element.\n+  [#330](https://github.com/ory/oathkeeper/issues/330): Also updates the schemas\n+  to add missing cookie config element.\n \n # [0.34.0-beta.1](https://github.com/ory/oathkeeper/compare/v0.33.1-beta.1...v0.34.0-beta.1) (2019-12-26)\n \n@@ -1056,26 +1051,25 @@ Prepare v0.34.0-beta.1+oryOS.14 release\n   ([96f77b2](https://github.com/ory/oathkeeper/commit/96f77b24d8adb160d5c2c3db2f2432e206b99c77))\n - pipe/err: Improve IP and MIME matching (#323)\n   ([7e6f636](https://github.com/ory/oathkeeper/commit/7e6f6369f4acc33211d78f2acb1036c610286c2c)),\n-  closes [#323](https://github.com/ory/oathkeeper/issues/323):\n-  Previously, MIME matching respected the request's wildcards which lead to\n-  multiple handlers feeling responsible for a particular request. Now, wildcards\n-  coming from the HTTP Request itself are interpreted literally.\n-  Additionally, ORY Oathkeeper respected the X-Forwarded-For HTTP Header for\n-  matching remote IP addresses. This behavior is now turned off by default\n-  because clients were able to fake this header otherwise. It can explicitly be\n-  turned on by setting\n+  closes [#323](https://github.com/ory/oathkeeper/issues/323): Previously, MIME\n+  matching respected the request's wildcards which lead to multiple handlers\n+  feeling responsible for a particular request. Now, wildcards coming from the\n+  HTTP Request itself are interpreted literally. Additionally, ORY Oathkeeper\n+  respected the X-Forwarded-For HTTP Header for matching remote IP addresses.\n+  This behavior is now turned off by default because clients were able to fake\n+  this header otherwise. It can explicitly be turned on by setting\n   `config.when.#.request.remote_ip.RespectForwardedForHeader: true`.\n - Add customizable error handlers (#322)\n   ([4033321](https://github.com/ory/oathkeeper/commit/4033321b13671de8d0d5a42846a4e19d6065db62)),\n   closes [#322](https://github.com/ory/oathkeeper/issues/322)\n   [#204](https://github.com/ory/oathkeeper/issues/204)\n   [#252](https://github.com/ory/oathkeeper/issues/252)\n-  [#119](https://github.com/ory/oathkeeper/issues/119):\n-  This patch adds a new feature called error handlers. It allows to define the\n-  error handling logic globally and per rule. It is now possible, for example,\n-  to return a JSON response for `Accept: application/json` requests and a HTTP\n-  Redirect response for requests that are coming from a user.\n-  This also resolves several issues, as noted below:\n+  [#119](https://github.com/ory/oathkeeper/issues/119): This patch adds a new\n+  feature called error handlers. It allows to define the error handling logic\n+  globally and per rule. It is now possible, for example, to return a JSON\n+  response for `Accept: application/json` requests and a HTTP Redirect response\n+  for requests that are coming from a user. This also resolves several issues,\n+  as noted below:\n \n # [0.33.1-beta.1](https://github.com/ory/oathkeeper/compare/v0.33.0-beta.1...v0.33.1-beta.1) (2019-12-18)\n \n@@ -1103,9 +1097,8 @@ docs: Incorporates changes from version v0.33.0-beta.1-12-g0dd3fe3 [ci skip]\n   ([3e7936a](https://github.com/ory/oathkeeper/commit/3e7936a41150f367003c81c208910fdb77f556d9)),\n   closes [#320](https://github.com/ory/oathkeeper/issues/320)\n   [#305](https://github.com/ory/oathkeeper/issues/305)\n-  [#317](https://github.com/ory/oathkeeper/issues/317):\n-  Previously, some keys did not respect the values set in the environment\n-  variables.\n+  [#317](https://github.com/ory/oathkeeper/issues/317): Previously, some keys\n+  did not respect the values set in the environment variables.\n - Add alpine-based Docker image (#318)\n   ([815951b](https://github.com/ory/oathkeeper/commit/815951bb039937acc7be3f8b1b2bb06fe9ecac90)),\n   closes [#318](https://github.com/ory/oathkeeper/issues/318)\n@@ -1114,24 +1107,23 @@ docs: Incorporates changes from version v0.33.0-beta.1-12-g0dd3fe3 [ci skip]\n   ([f60f525](https://github.com/ory/oathkeeper/commit/f60f52538ff6e66ea98afc89c6c6557ab8c5f93f)),\n   closes [#316](https://github.com/ory/oathkeeper/issues/316)\n   [#244](https://github.com/ory/oathkeeper/issues/244)\n-  [#242](https://github.com/ory/oathkeeper/issues/242):\n-  Adds details such as the HTTP Method, User Agent, Subject, and other\n-  information to the logging output of both the reverse proxy and the decision\n-  API.\n+  [#242](https://github.com/ory/oathkeeper/issues/242): Adds details such as the\n+  HTTP Method, User Agent, Subject, and other information to the logging output\n+  of both the reverse proxy and the decision API.\n - Health endpoints now emit TRACE logs\n   ([#314](https://github.com/ory/oathkeeper/issues/314))\n   ([9036f8e](https://github.com/ory/oathkeeper/commit/9036f8eec3f264f7bcae46b44286367b8521802a)),\n-  closes [#283](https://github.com/ory/oathkeeper/issues/283):\n-  Remove health endpoints from the logs to make monitoring easier. Setting\n-  `log_level` to `trace` will show these calls.\n+  closes [#283](https://github.com/ory/oathkeeper/issues/283): Remove health\n+  endpoints from the logs to make monitoring easier. Setting `log_level` to\n+  `trace` will show these calls.\n - Improve session endpoint debugability\n   ([#315](https://github.com/ory/oathkeeper/issues/315))\n   ([2718639](https://github.com/ory/oathkeeper/commit/27186396ccff4ee3a7f8f0a4c703263fcc55afae)),\n   closes [#300](https://github.com/ory/oathkeeper/issues/300)\n - Resolve matcher cache ([#313](https://github.com/ory/oathkeeper/issues/313))\n   ([1519632](https://github.com/ory/oathkeeper/commit/15196326d2436c2d849d955bf5050766ae6dff0c)),\n-  closes [#291](https://github.com/ory/oathkeeper/issues/291):\n-  A bug caused the rule matcher to not cache the regular expression result.\n+  closes [#291](https://github.com/ory/oathkeeper/issues/291): A bug caused the\n+  rule matcher to not cache the regular expression result.\n - Use bearer splitting when header is set to Authorization\n   ([#311](https://github.com/ory/oathkeeper/issues/311))\n   ([464fa31](https://github.com/ory/oathkeeper/commit/464fa319e84953835b71e16360bab3016b8bfc64)),\n@@ -1208,9 +1200,9 @@ docs: Incorporates changes from version v0.32.0-beta.1-13-g1910bbe [ci skip]\n   closes [#276](https://github.com/ory/oathkeeper/issues/276)\n   [#270](https://github.com/ory/oathkeeper/issues/270)\n   [#279](https://github.com/ory/oathkeeper/issues/279)\n-  [#280](https://github.com/ory/oathkeeper/issues/280):\n-  This patch automatically binds environment variables to configuration keys.\n-  This patch resolves several issues:\n+  [#280](https://github.com/ory/oathkeeper/issues/280): This patch automatically\n+  binds environment variables to configuration keys. This patch resolves several\n+  issues:\n - Dereference config schema and resolve issues (#282)\n   ([8cf6868](https://github.com/ory/oathkeeper/commit/8cf6868b3e925e686769d43c912d5e52c6589a9b)),\n   closes [#282](https://github.com/ory/oathkeeper/issues/282)\n@@ -1245,16 +1237,16 @@ docs: Incorporates changes from version v0.30.0-beta.1 [ci skip]\n - pipeline/authn: Add token_from config to introspection and jwt (#271)\n   ([fc85ac8](https://github.com/ory/oathkeeper/commit/fc85ac854c3fb4cdd96bbae650f7355400431eac)),\n   closes [#271](https://github.com/ory/oathkeeper/issues/271)\n-  [#257](https://github.com/ory/oathkeeper/issues/257):\n-  Add additional optional configuration to jwt and oauth2_introspection\n-  authenticators allowing to set from where (which header or query parameter)\n-  the token should be received. The configuration is a token_from field in\n-  per-rule-configuration, as described in a linked issue.\n+  [#257](https://github.com/ory/oathkeeper/issues/257): Add additional optional\n+  configuration to jwt and oauth2_introspection authenticators allowing to set\n+  from where (which header or query parameter) the token should be received. The\n+  configuration is a token_from field in per-rule-configuration, as described in\n+  a linked issue.\n - Add migration capabilities\n   ([#268](https://github.com/ory/oathkeeper/issues/268))\n   ([bc74e72](https://github.com/ory/oathkeeper/commit/bc74e726712c77955d2013979770c2724af17f20)),\n-  closes [#266](https://github.com/ory/oathkeeper/issues/266):\n-  Adds the ability to modify rules with backwards compatibility.\n+  closes [#266](https://github.com/ory/oathkeeper/issues/266): Adds the ability\n+  to modify rules with backwards compatibility.\n - Force auth style in oauth2 client credentials authn\n   ([#267](https://github.com/ory/oathkeeper/issues/267))\n   ([97d7890](https://github.com/ory/oathkeeper/commit/97d789097b47b50117421f8f4ebd32182de4195c)),\n@@ -1427,18 +1419,17 @@ ci: Automate schema confiugration sync\n   ([717d7f7](https://github.com/ory/oathkeeper/commit/717d7f748abe61014653f3c6519c4aef019d1969))\n - Watch configuration and access rule changes (#217)\n   ([a078e89](https://github.com/ory/oathkeeper/commit/a078e891e2fe97bdb6ce8a2264f629a179c9116e)),\n-  closes [#217](https://github.com/ory/oathkeeper/issues/217):\n-  This patch allows oathkeeper to re-load any changes made to the configuraiton\n-  file and/or the access rules to be reloaded without a restart.\n-  Some configuration keys like serve._, log._, profiling however require a\n-  restart.\n+  closes [#217](https://github.com/ory/oathkeeper/issues/217): This patch allows\n+  oathkeeper to re-load any changes made to the configuraiton file and/or the\n+  access rules to be reloaded without a restart. Some configuration keys like\n+  serve._, log._, profiling however require a restart.\n - Create FUNDING.yml\n   ([d7da8e2](https://github.com/ory/oathkeeper/commit/d7da8e296205e183140c18ba3cc6269334476a2b))\n - Add support for rules in YAML format (#213)\n   ([67face6](https://github.com/ory/oathkeeper/commit/67face611b9f19ed9b6606931c9b7a82df769154)),\n-  closes [#213](https://github.com/ory/oathkeeper/issues/213):\n-  This commit adds support for defining access rules in YAML format, in addition\n-  to existing JSON format.\n+  closes [#213](https://github.com/ory/oathkeeper/issues/213): This commit adds\n+  support for defining access rules in YAML format, in addition to existing JSON\n+  format.\n \n # [0.16.0-beta.5](https://github.com/ory/oathkeeper/compare/v0.16.0-beta.4...v0.16.0-beta.5) (2019-06-28)\n \n@@ -1465,8 +1456,8 @@ authenticator: Add cookie session authenticator (#211)\n   closes [#208](https://github.com/ory/oathkeeper/issues/208)\n - Update config.yaml (#204)\n   ([effe9c0](https://github.com/ory/oathkeeper/commit/effe9c025c3a25edf88bc3791ec27cb01e128a1a)),\n-  closes [#204](https://github.com/ory/oathkeeper/issues/204):\n-  There's no DSN in oathkeeper\n+  closes [#204](https://github.com/ory/oathkeeper/issues/204): There's no DSN in\n+  oathkeeper\n \n # [0.16.0-beta.4](https://github.com/ory/oathkeeper/compare/v0.16.0-beta.3...v0.16.0-beta.4) (2019-05-28)\n \n@@ -1499,11 +1490,10 @@ Closes #199\n - Properly declare negroni middleware\n   ([#200](https://github.com/ory/oathkeeper/issues/200))\n   ([9d3dc54](https://github.com/ory/oathkeeper/commit/9d3dc54e1350fa74fb126cc4761462e83d86548f)),\n-  closes [#199](https://github.com/ory/oathkeeper/issues/199):\n-  Previously, negroni.With was mistakenly used to add middleware onto the stack.\n-  The proper method however is negroni.Use.\n-  This patch fixes the use of negroni.With and resolves issues around logging\n-  and the decisions endpoint.\n+  closes [#199](https://github.com/ory/oathkeeper/issues/199): Previously,\n+  negroni.With was mistakenly used to add middleware onto the stack. The proper\n+  method however is negroni.Use. This patch fixes the use of negroni.With and\n+  resolves issues around logging and the decisions endpoint.\n \n # [0.16.0-beta.3](https://github.com/ory/oathkeeper/compare/v0.15.2...v0.16.0-beta.3) (2019-05-19)\n \n@@ -1631,10 +1621,10 @@ Signed-off-by: aeneasr <aeneas@ory.sh>\n - Use scp,scope,scopes in jwt authenticator\n   ([#162](https://github.com/ory/oathkeeper/issues/162))\n   ([eebc2f4](https://github.com/ory/oathkeeper/commit/eebc2f44e3e42b7af653f91d9345111e0a280401)),\n-  closes [#138](https://github.com/ory/oathkeeper/issues/138):\n-  Previously, the JWT authenticator only used the \"scope\" claim to retrieve\n-  scope values from a JWT. Now, \"scp\", \"scope\", \"scopes\" are supported as string\n-  arrays and strings separated by spaces.\n+  closes [#138](https://github.com/ory/oathkeeper/issues/138): Previously, the\n+  JWT authenticator only used the \"scope\" claim to retrieve scope values from a\n+  JWT. Now, \"scp\", \"scope\", \"scopes\" are supported as string arrays and strings\n+  separated by spaces.\n \n # [0.14.2+oryOS.10](https://github.com/ory/oathkeeper/compare/v0.14.1+oryOS.10...v0.14.2+oryOS.10) (2018-12-13)\n \n@@ -1792,14 +1782,13 @@ Signed-off-by: aeneasr <aeneas@ory.sh>\n   ([032d88e](https://github.com/ory/oathkeeper/commit/032d88ea8dee24506d277d22b7f4aaef2a502fa7))\n - Add endpoint for answering access requests directly\n   ([d211641](https://github.com/ory/oathkeeper/commit/d2116410edf1f5089427858727f155bc0aa4313c)),\n-  closes [#42](https://github.com/ory/oathkeeper/issues/42):\n-  This patch adds endpoint `/judge` to `oathkeeper serve api`. The `/judge`\n-  endpoint mimics the behavior of `oathkeeper serve proxy` but instead of\n-  forwarding the request to the upstream server, the endpoint answers directly\n-  with a HTTP response.\n-  The HTTP response returns status code 200 if the request should be allowed and\n-  any other status code (e.g. 401, 403) if not.\n-  Assuming you are making the following request:\n+  closes [#42](https://github.com/ory/oathkeeper/issues/42): This patch adds\n+  endpoint `/judge` to `oathkeeper serve api`. The `/judge` endpoint mimics the\n+  behavior of `oathkeeper serve proxy` but instead of forwarding the request to\n+  the upstream server, the endpoint answers directly with a HTTP response. The\n+  HTTP response returns status code 200 if the request should be allowed and any\n+  other status code (e.g. 401, 403) if not. Assuming you are making the\n+  following request:\n   ```\n   PUT /judge/my-service/whatever HTTP/1.1\n   Host: oathkeeper-api:4456\n@@ -1830,9 +1819,9 @@ Signed-off-by: aeneasr <aeneas@ory.sh>\n   ([#132](https://github.com/ory/oathkeeper/issues/132))\n   ([b3718ce](https://github.com/ory/oathkeeper/commit/b3718ce56d4bcfe4610806ae6b15382226adab75)):\n   Add environment parameters (and description) to configure timeout settings of\n-  a server handled proxy requests.\n-  It will help prevent a case of unexpected closing a client connection if an\n-  upstream request is executing more than default timeout.\n+  a server handled proxy requests. It will help prevent a case of unexpected\n+  closing a client connection if an upstream request is executing more than\n+  default timeout.\n - Add JWT authenticator\n   ([61625bc](https://github.com/ory/oathkeeper/commit/61625bccebe0b478b980c66a29894dc1ffe48b0a))\n - Add NodeJS SDK ([#94](https://github.com/ory/oathkeeper/issues/94))\n@@ -1889,9 +1878,9 @@ Signed-off-by: aeneasr <aeneas@ory.sh>\n - Improve compatibility with ORY Hydra 1.0.0-beta.8\n   ([#108](https://github.com/ory/oathkeeper/issues/108))\n   ([296e012](https://github.com/ory/oathkeeper/commit/296e01254b50b645fae67e51aa668d39652b0778)),\n-  closes [#101](https://github.com/ory/oathkeeper/issues/101):\n-  This patch improves compatibility with ORY Hydra 1.0.0-beta.8 and updates\n-  vendored dependencies.\n+  closes [#101](https://github.com/ory/oathkeeper/issues/101): This patch\n+  improves compatibility with ORY Hydra 1.0.0-beta.8 and updates vendored\n+  dependencies.\n - Improve hydra integration tests\n   ([e8b7a58](https://github.com/ory/oathkeeper/commit/e8b7a586c5fcb86efddf57d4f2f97a0ff915b869))\n - Improve refresh subroutines\n@@ -1916,10 +1905,9 @@ Signed-off-by: aeneasr <aeneas@ory.sh>\n   ([2e024f9](https://github.com/ory/oathkeeper/commit/2e024f91640bf4182d1b1a6fb143d77c523f4596))\n - Properly handle conflicts on PUT and POST\n   ([83b591d](https://github.com/ory/oathkeeper/commit/83b591d8cf3d180ad9d48a72bd92ffdb3a8192ac)),\n-  closes [#38](https://github.com/ory/oathkeeper/issues/38):\n-  Previously, PUT and POST did not result in errors (409) when non-existing\n-  resources were modified, or existing resources were created. This patch\n-  resolves that.\n+  closes [#38](https://github.com/ory/oathkeeper/issues/38): Previously, PUT and\n+  POST did not result in errors (409) when non-existing resources were modified,\n+  or existing resources were created. This patch resolves that.\n - Refactors Oathkeeper into new ecosystem\n   ([#60](https://github.com/ory/oathkeeper/issues/60))\n   ([7acfbca](https://github.com/ory/oathkeeper/commit/7acfbcaca36645a984baded2dc3cbb689154ef8c))\n@@ -1974,9 +1962,9 @@ Signed-off-by: aeneasr <aeneas@ory.sh>\n   ([3f259da](https://github.com/ory/oathkeeper/commit/3f259da7766eb6a42b54bb3a6f3ddeb49d9363a1))\n - Resolves an issue with cached matchers\n   ([951da25](https://github.com/ory/oathkeeper/commit/951da251e3e862f2d0a1e5076c028a481f0235dd)),\n-  closes [#73](https://github.com/ory/oathkeeper/issues/73):\n-  This patch resolves an issue where updates would not properly propagate. This\n-  caused deleted rules to still be available in the proxy.\n+  closes [#73](https://github.com/ory/oathkeeper/issues/73): This patch resolves\n+  an issue where updates would not properly propagate. This caused deleted rules\n+  to still be available in the proxy.\n - Resolves issues with broken tests\n   ([6604045](https://github.com/ory/oathkeeper/commit/6604045191446baca03791940ddf746aed4799d1))\n - Resolves naming issues and updates readme\n@@ -1989,12 +1977,11 @@ Signed-off-by: aeneasr <aeneas@ory.sh>\n   closes [#80](https://github.com/ory/oathkeeper/issues/80)\n - Reduces setup complexity by making strategies configurable\n   ([6626f8f](https://github.com/ory/oathkeeper/commit/6626f8f2aa98f8ee05e5b1f63c1b698083f9ae78)),\n-  closes [#71](https://github.com/ory/oathkeeper/issues/71):\n-  This patch adds another ID Token signing algorithm (HS256) which is easier to\n-  set up as it does not rely on ORY Hydra but instead on a shared secret.\n-  Additionally the ability to specify which ID Token singing algorithm to use\n-  has been added. Environmental variables to configure the behvaiour have been\n-  added as well.\n+  closes [#71](https://github.com/ory/oathkeeper/issues/71): This patch adds\n+  another ID Token signing algorithm (HS256) which is easier to set up as it\n+  does not rely on ORY Hydra but instead on a shared secret. Additionally the\n+  ability to specify which ID Token singing algorithm to use has been added.\n+  Environmental variables to configure the behvaiour have been added as well.\n   Further, the ORY Keto Warden Authorizer strategy is now optional and disabled\n   when the environment variable `AUTHORIZER_KETO_WARDEN_KETO_URL` is empty.\n - Updates to ORY Hydra v1.0.0-beta.2\n@@ -2346,6 +2333,7 @@ Build oathekeeper docker image statically (#14)\n - Build oathekeeper docker image statically (#14)\n   ([dbd2037](https://github.com/ory/oathkeeper/commit/dbd2037b56b6104b79607b20394be0e9a30e67e1)),\n   closes [#14](https://github.com/ory/oathkeeper/issues/14):\n+\n   - Build oathekeeper docker image statically\n \n   - Build oathekeeper docker image statically"
        },
        {
          "filename": "docs/docs/pipeline/authn.md",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -622,6 +622,10 @@ was granted the requested scope.\n   - `ttl` (string) - Can override the default behaviour of using the token exp\n     time, and specify a set time to live for the token in the cache.\n \n+Please note that caching will not be used if the scope strategy is `none` and\n+`required_scope` is not empty. In that case, the configured introspection URL\n+will always be called and is expected to check if the scope is valid or not.\n+\n ```yaml\n # Global configuration file oathkeeper.yml\n authenticators:"
        },
        {
          "filename": "driver/configuration/provider.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -6,6 +6,7 @@ import (\n \t\"time\"\n \n \t\"github.com/gobuffalo/packr/v2\"\n+\n \t\"github.com/ory/fosite\"\n \t\"github.com/ory/x/tracing\"\n "
        },
        {
          "filename": "pipeline/authn/authenticator_oauth2_introspection.go",
          "status": "modified",
          "additions": 68,
          "deletions": 46,
          "patch": "@@ -11,6 +11,8 @@ import (\n \t\"sync\"\n \t\"time\"\n \n+\t\"github.com/ory/fosite\"\n+\n \t\"github.com/dgraph-io/ristretto\"\n \n \t\"github.com/opentracing/opentracing-go\"\n@@ -94,31 +96,37 @@ type AuthenticatorOAuth2IntrospectionResult struct {\n \tTokenUse  string                 `json:\"token_use\"`\n }\n \n-func (a *AuthenticatorOAuth2Introspection) tokenFromCache(config *AuthenticatorOAuth2IntrospectionConfiguration, token string) (*AuthenticatorOAuth2IntrospectionResult, bool) {\n+func (a *AuthenticatorOAuth2Introspection) tokenFromCache(config *AuthenticatorOAuth2IntrospectionConfiguration, token string, ss fosite.ScopeStrategy) *AuthenticatorOAuth2IntrospectionResult {\n \tif !config.Cache.Enabled {\n-\t\treturn nil, false\n+\t\treturn nil\n+\t}\n+\n+\tif ss == nil && len(config.Scopes) > 0 {\n+\t\treturn nil\n \t}\n \n \titem, found := a.tokenCache.Get(token)\n \tif !found {\n-\t\treturn nil, false\n+\t\treturn nil\n \t}\n \n-\ti := item.(*AuthenticatorOAuth2IntrospectionResult)\n-\texpires := time.Unix(i.Expires, 0)\n-\tif expires.Before(time.Now()) {\n-\t\ta.tokenCache.Del(token)\n-\t\treturn nil, false\n+\ti, ok := item.(*AuthenticatorOAuth2IntrospectionResult)\n+\tif !ok {\n+\t\treturn nil\n \t}\n \n-\treturn i, true\n+\treturn i\n }\n \n-func (a *AuthenticatorOAuth2Introspection) tokenToCache(config *AuthenticatorOAuth2IntrospectionConfiguration, i *AuthenticatorOAuth2IntrospectionResult, token string) {\n+func (a *AuthenticatorOAuth2Introspection) tokenToCache(config *AuthenticatorOAuth2IntrospectionConfiguration, i *AuthenticatorOAuth2IntrospectionResult, token string, ss fosite.ScopeStrategy) {\n \tif !config.Cache.Enabled {\n \t\treturn\n \t}\n \n+\tif ss == nil && len(config.Scopes) > 0 {\n+\t\treturn\n+\t}\n+\n \tif a.cacheTTL != nil {\n \t\ta.tokenCache.SetWithTTL(token, i, 1, *a.cacheTTL)\n \t} else {\n@@ -145,7 +153,7 @@ func (a *AuthenticatorOAuth2Introspection) traceRequest(ctx context.Context, req\n \text.HTTPUrl.Set(clientSpan, urlStr)\n \text.HTTPMethod.Set(clientSpan, req.Method)\n \n-\ttracer.Inject(clientSpan.Context(), opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(req.Header))\n+\t_ = tracer.Inject(clientSpan.Context(), opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(req.Header))\n \treturn clientSpan.Finish\n }\n \n@@ -160,12 +168,14 @@ func (a *AuthenticatorOAuth2Introspection) Authenticate(r *http.Request, session\n \t\treturn errors.WithStack(ErrAuthenticatorNotResponsible)\n \t}\n \n-\tss := a.c.ToScopeStrategy(cf.ScopeStrategy, \"authenticators.oauth2_introspection.scope_strategy\")\n+\tss := a.c.ToScopeStrategy(cf.ScopeStrategy, \"authenticators.oauth2_introspection.config.scope_strategy\")\n \n-\ti, ok := a.tokenFromCache(cf, token)\n-\tif !ok {\n-\t\tbody := url.Values{\"token\": {token}}\n+\ti := a.tokenFromCache(cf, token, ss)\n \n+\t// If the token can not be found, and the scope strategy is nil, and the required scope list\n+\t// is not empty, then we can not use the cache.\n+\tif i == nil {\n+\t\tbody := url.Values{\"token\": {token}}\n \t\tif ss == nil {\n \t\t\tbody.Add(\"scope\", strings.Join(cf.Scopes, \" \"))\n \t\t}\n@@ -174,6 +184,7 @@ func (a *AuthenticatorOAuth2Introspection) Authenticate(r *http.Request, session\n \t\tif err != nil {\n \t\t\treturn errors.WithStack(err)\n \t\t}\n+\n \t\tfor key, value := range cf.IntrospectionRequestHeaders {\n \t\t\tintrospectReq.Header.Set(key, value)\n \t\t}\n@@ -199,48 +210,52 @@ func (a *AuthenticatorOAuth2Introspection) Authenticate(r *http.Request, session\n \t\tif err := json.NewDecoder(resp.Body).Decode(&i); err != nil {\n \t\t\treturn errors.WithStack(err)\n \t\t}\n+\t}\n \n-\t\tif len(i.TokenUse) > 0 && i.TokenUse != \"access_token\" {\n-\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Use of introspected token is not an access token but \\\"%s\\\"\", i.TokenUse)))\n-\t\t}\n+\tif len(i.TokenUse) > 0 && i.TokenUse != \"access_token\" {\n+\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Use of introspected token is not an access token but \\\"%s\\\"\", i.TokenUse)))\n+\t}\n \n-\t\tif !i.Active {\n-\t\t\treturn errors.WithStack(helper.ErrUnauthorized.WithReason(\"Access token i says token is not active\"))\n-\t\t}\n+\tif !i.Active {\n+\t\treturn errors.WithStack(helper.ErrUnauthorized.WithReason(\"Access token is not active\"))\n+\t}\n \n-\t\tfor _, audience := range cf.Audience {\n-\t\t\tif !stringslice.Has(i.Audience, audience) {\n-\t\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Token audience is not intended for target audience %s\", audience)))\n-\t\t\t}\n+\tif i.Expires > 0 && time.Unix(i.Expires, 0).Before(time.Now()) {\n+\t\treturn errors.WithStack(helper.ErrUnauthorized.WithReason(\"Access token expired\"))\n+\t}\n+\n+\tfor _, audience := range cf.Audience {\n+\t\tif !stringslice.Has(i.Audience, audience) {\n+\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Token audience is not intended for target audience %s\", audience)))\n \t\t}\n+\t}\n \n-\t\tif len(cf.Issuers) > 0 {\n-\t\t\tif !stringslice.Has(cf.Issuers, i.Issuer) {\n-\t\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Token issuer does not match any trusted issuer\")))\n-\t\t\t}\n+\tif len(cf.Issuers) > 0 {\n+\t\tif !stringslice.Has(cf.Issuers, i.Issuer) {\n+\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Token issuer does not match any trusted issuer\")))\n \t\t}\n+\t}\n \n-\t\tif ss != nil {\n-\t\t\tfor _, scope := range cf.Scopes {\n-\t\t\t\tif !ss(strings.Split(i.Scope, \" \"), scope) {\n-\t\t\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Scope %s was not granted\", scope)))\n-\t\t\t\t}\n+\tif ss != nil {\n+\t\tfor _, scope := range cf.Scopes {\n+\t\t\tif !ss(strings.Split(i.Scope, \" \"), scope) {\n+\t\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Scope %s was not granted\", scope)))\n \t\t\t}\n \t\t}\n+\t}\n \n-\t\tif len(i.Extra) == 0 {\n-\t\t\ti.Extra = map[string]interface{}{}\n-\t\t}\n+\ta.tokenToCache(cf, i, token, ss)\n \n-\t\ti.Extra[\"username\"] = i.Username\n-\t\ti.Extra[\"client_id\"] = i.ClientID\n-\t\ti.Extra[\"scope\"] = i.Scope\n+\tif len(i.Extra) == 0 {\n+\t\ti.Extra = map[string]interface{}{}\n+\t}\n \n-\t\tif len(i.Audience) != 0 {\n-\t\t\ti.Extra[\"aud\"] = i.Audience\n-\t\t}\n+\ti.Extra[\"username\"] = i.Username\n+\ti.Extra[\"client_id\"] = i.ClientID\n+\ti.Extra[\"scope\"] = i.Scope\n \n-\t\ta.tokenToCache(cf, i, token)\n+\tif len(i.Audience) != 0 {\n+\t\ti.Extra[\"aud\"] = i.Audience\n \t}\n \n \tsession.Subject = i.Subject\n@@ -324,15 +339,22 @@ func (a *AuthenticatorOAuth2Introspection) Config(config json.RawMessage) (*Auth\n \t}\n \n \tif a.tokenCache == nil {\n+\t\tcost := int64(c.Cache.MaxCost)\n+\t\tif cost == 0 {\n+\t\t\tcost = 100000000\n+\t\t}\n \t\ta.logger.Debugf(\"Creating cache with max cost: %d\", c.Cache.MaxCost)\n-\t\tcache, _ := ristretto.NewCache(&ristretto.Config{\n+\t\tcache, err := ristretto.NewCache(&ristretto.Config{\n \t\t\t// This will hold about 1000 unique mutation responses.\n \t\t\tNumCounters: 10000,\n \t\t\t// Allocate a max\n-\t\t\tMaxCost: int64(c.Cache.MaxCost),\n+\t\t\tMaxCost: cost,\n \t\t\t// This is a best-practice value.\n \t\t\tBufferItems: 64,\n \t\t})\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n \n \t\ta.tokenCache = cache\n \t}"
        },
        {
          "filename": "pipeline/authn/authenticator_oauth2_introspection_test.go",
          "status": "modified",
          "additions": 198,
          "deletions": 1,
          "patch": "@@ -25,7 +25,11 @@ import (\n \t\"fmt\"\n \t\"net/http\"\n \t\"net/http/httptest\"\n+\t\"sync\"\n \t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/ory/x/assertx\"\n \n \t\"github.com/julienschmidt/httprouter\"\n \t\"github.com/stretchr/testify/assert\"\n@@ -48,7 +52,6 @@ func TestAuthenticatorOAuth2Introspection(t *testing.T) {\n \tassert.Equal(t, \"oauth2_introspection\", a.GetID())\n \n \tt.Run(\"method=authenticate\", func(t *testing.T) {\n-\n \t\tfor k, tc := range []struct {\n \t\t\td              string\n \t\t\tsetup          func(*testing.T, *httprouter.Router)\n@@ -574,6 +577,200 @@ func TestAuthenticatorOAuth2Introspection(t *testing.T) {\n \t\t}\n \t})\n \n+\tt.Run(\"method=authenticate-with-cache\", func(t *testing.T) {\n+\t\tviper.Set(\"authenticators.oauth2_introspection.config.cache.enabled\", true)\n+\t\tt.Cleanup(func() {\n+\t\t\tviper.Set(\"authenticators.oauth2_introspection.config.cache.enabled\", false)\n+\t\t})\n+\n+\t\tvar didNotUseCache sync.WaitGroup\n+\n+\t\tsetup := func(t *testing.T, config string) []byte {\n+\t\t\trouter := httprouter.New()\n+\t\t\trouter.POST(\"/oauth2/introspect\", func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {\n+\t\t\t\tdefer didNotUseCache.Done()\n+\t\t\t\trequire.NoError(t, r.ParseForm())\n+\t\t\t\tswitch r.Form.Get(\"token\") {\n+\t\t\t\tcase \"inactive-scope-b\":\n+\t\t\t\t\trequire.NoError(t, json.NewEncoder(w).Encode(&AuthenticatorOAuth2IntrospectionResult{\n+\t\t\t\t\t\tActive: false,\n+\t\t\t\t\t}))\n+\t\t\t\tcase \"another-active-scope-a\":\n+\t\t\t\t\tfallthrough\n+\t\t\t\tcase \"active-scope-a\":\n+\t\t\t\t\tif r.Form.Get(\"scope\") != \"\" && r.Form.Get(\"scope\") != \"scope-a\" {\n+\t\t\t\t\t\trequire.NoError(t, json.NewEncoder(w).Encode(&AuthenticatorOAuth2IntrospectionResult{\n+\t\t\t\t\t\t\tActive: false,\n+\t\t\t\t\t\t}))\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\trequire.NoError(t, json.NewEncoder(w).Encode(&AuthenticatorOAuth2IntrospectionResult{\n+\t\t\t\t\t\tActive:   true,\n+\t\t\t\t\t\tScope:    \"scope-a\",\n+\t\t\t\t\t\tSubject:  \"subject\",\n+\t\t\t\t\t\tAudience: []string{\"audience\"},\n+\t\t\t\t\t\tIssuer:   \"foo\",\n+\t\t\t\t\t\tUsername: \"username\",\n+\t\t\t\t\t\tExpires:  time.Now().Add(time.Second).Unix(),\n+\t\t\t\t\t\tExtra:    map[string]interface{}{\"extra\": \"foo\"},\n+\t\t\t\t\t}))\n+\t\t\t\tcase \"refresh-token\":\n+\t\t\t\t\trequire.NoError(t, json.NewEncoder(w).Encode(&AuthenticatorOAuth2IntrospectionResult{\n+\t\t\t\t\t\tActive:   true,\n+\t\t\t\t\t\tScope:    \"scope-a\",\n+\t\t\t\t\t\tSubject:  \"subject\",\n+\t\t\t\t\t\tAudience: []string{\"audience\"},\n+\t\t\t\t\t\tIssuer:   \"foo\",\n+\t\t\t\t\t\tUsername: \"username\",\n+\t\t\t\t\t\tTokenUse: \"refresh_token\",\n+\t\t\t\t\t\tExtra:    map[string]interface{}{\"extra\": \"foo\"},\n+\t\t\t\t\t}))\n+\t\t\t\tdefault:\n+\t\t\t\t\trequire.NoError(t, json.NewEncoder(w).Encode(&AuthenticatorOAuth2IntrospectionResult{\n+\t\t\t\t\t\tActive: false,\n+\t\t\t\t\t}))\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\tts := httptest.NewServer(router)\n+\t\t\tt.Cleanup(ts.Close)\n+\n+\t\t\tconfig, err = sjson.Set(config, \"introspection_url\", ts.URL+\"/oauth2/introspect\")\n+\t\t\trequire.NoError(t, err)\n+\t\t\tconfig, err = sjson.Set(config, \"pre_authorization.token_url\", ts.URL+\"/oauth2/token\")\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\treturn []byte(config)\n+\t\t}\n+\n+\t\tt.Run(\"case=with none scope strategy\", func(t *testing.T) {\n+\t\t\tviper.Set(\"authenticators.oauth2_introspection.config.scope_strategy\", \"none\")\n+\t\t\tr := &http.Request{Header: http.Header{\"Authorization\": {\"bearer active-scope-a\"}}}\n+\t\t\texpected := new(AuthenticationSession)\n+\t\t\tt.Run(\"case=initial request succeeds\", func(t *testing.T) {\n+\t\t\t\tconfig := setup(t, `{ \"required_scope\": [\"scope-a\"], \"trusted_issuers\": [\"foo\", \"bar\"], \"target_audience\": [\"audience\"] }`)\n+\n+\t\t\t\tdidNotUseCache.Add(1)\n+\t\t\t\terr = a.Authenticate(r, expected, config, nil)\n+\t\t\t\tdidNotUseCache.Wait()\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t})\n+\n+\t\t\t// We expect to use the cache here because we are not interested to validate the scope. Usually we would\n+\t\t\t// expect to make the upstream call if the upstream has to validate the scope.\n+\t\t\tt.Run(\"case=second request does use cache because no scope was requested and strategy is nil\", func(t *testing.T) {\n+\t\t\t\tconfig := setup(t, `{ \"trusted_issuers\": [\"foo\", \"bar\"], \"target_audience\": [\"audience\"] }`)\n+\t\t\t\tsess := new(AuthenticationSession)\n+\n+\t\t\t\terr = a.Authenticate(r, sess, config, nil)\n+\t\t\t\tdidNotUseCache.Wait() // Would result in a panic if wg.done was called!\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tassertx.EqualAsJSON(t, expected, sess)\n+\t\t\t})\n+\n+\t\t\tt.Run(\"case=second request does not use cache because scope strategy is disabled and scope was requested request succeeds\", func(t *testing.T) {\n+\t\t\t\tconfig := setup(t, `{ \"required_scope\": [\"scope-a\"], \"trusted_issuers\": [\"foo\", \"bar\"], \"target_audience\": [\"audience\"] }`)\n+\t\t\t\tsess := new(AuthenticationSession)\n+\n+\t\t\t\tdidNotUseCache.Add(1)\n+\t\t\t\terr = a.Authenticate(r, sess, config, nil)\n+\t\t\t\tdidNotUseCache.Wait()\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tassertx.EqualAsJSON(t, expected, sess)\n+\t\t\t})\n+\n+\t\t\tt.Run(\"case=request fails because we requested a scope which the upstream does not validate\", func(t *testing.T) {\n+\t\t\t\tconfig := setup(t, `{ \"required_scope\": [\"scope-b\"], \"trusted_issuers\": [\"foo\", \"bar\"], \"target_audience\": [\"audience\"] }`)\n+\t\t\t\tsess := new(AuthenticationSession)\n+\n+\t\t\t\tdidNotUseCache.Add(1)\n+\t\t\t\terr = a.Authenticate(r, sess, config, nil)\n+\t\t\t\tdidNotUseCache.Wait()\n+\t\t\t\trequire.Error(t, err)\n+\t\t\t})\n+\t\t})\n+\n+\t\tt.Run(\"case=does not use cache for refresh tokens\", func(t *testing.T) {\n+\t\t\tfor _, strategy := range []string{\"wildcard\", \"none\"} {\n+\t\t\t\tt.Run(\"scope_strategy=\"+strategy, func(t *testing.T) {\n+\t\t\t\t\tviper.Set(\"authenticators.oauth2_introspection.config.scope_strategy\", strategy)\n+\t\t\t\t\tr := &http.Request{Header: http.Header{\"Authorization\": {\"bearer refresh_token\"}}}\n+\t\t\t\t\texpected := new(AuthenticationSession)\n+\n+\t\t\t\t\t// The initial request\n+\t\t\t\t\tconfig := setup(t, `{ \"required_scope\": [\"scope-a\"], \"trusted_issuers\": [\"foo\", \"bar\"], \"target_audience\": [\"audience\"] }`)\n+\n+\t\t\t\t\t// Also doesn't use the cache the second time\n+\t\t\t\t\tdidNotUseCache.Add(2)\n+\t\t\t\t\trequire.Error(t, a.Authenticate(r, expected, config, nil))\n+\t\t\t\t\trequire.Error(t, a.Authenticate(r, expected, config, nil))\n+\t\t\t\t\tdidNotUseCache.Wait()\n+\t\t\t\t})\n+\t\t\t}\n+\t\t})\n+\n+\t\tt.Run(\"case=with a scope scope strategy\", func(t *testing.T) {\n+\t\t\tviper.Set(\"authenticators.oauth2_introspection.config.scope_strategy\", \"wildcard\")\n+\t\t\tr := &http.Request{Header: http.Header{\"Authorization\": {\"bearer another-active-scope-a\"}}}\n+\t\t\texpected := new(AuthenticationSession)\n+\n+\t\t\t// The initial request\n+\t\t\tconfig := setup(t, `{ \"required_scope\": [\"scope-a\"], \"trusted_issuers\": [\"foo\", \"bar\"], \"target_audience\": [\"audience\"] }`)\n+\n+\t\t\tdidNotUseCache.Add(1)\n+\t\t\trequire.NoError(t, a.Authenticate(r, expected, config, nil))\n+\t\t\tdidNotUseCache.Wait()\n+\n+\t\t\tt.Run(\"case=request succeeds and uses the cache\", func(t *testing.T) {\n+\t\t\t\tconfig := setup(t, `{ \"trusted_issuers\": [\"foo\", \"bar\"], \"target_audience\": [\"audience\"] }`)\n+\t\t\t\tsess := new(AuthenticationSession)\n+\n+\t\t\t\terr = a.Authenticate(r, sess, config, nil)\n+\t\t\t\tdidNotUseCache.Wait()\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tassertx.EqualAsJSON(t, expected, sess)\n+\t\t\t})\n+\n+\t\t\tt.Run(\"case=request the initial request which also passes\", func(t *testing.T) {\n+\t\t\t\tconfig := setup(t, `{ \"required_scope\": [\"scope-a\"], \"trusted_issuers\": [\"foo\", \"bar\"], \"target_audience\": [\"audience\"] }`)\n+\t\t\t\tsess := new(AuthenticationSession)\n+\n+\t\t\t\terr = a.Authenticate(r, sess, config, nil)\n+\t\t\t\tdidNotUseCache.Wait()\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tassertx.EqualAsJSON(t, expected, sess)\n+\t\t\t})\n+\n+\t\t\tt.Run(\"case=requests a scope the token does not have\", func(t *testing.T) {\n+\t\t\t\trequire.Error(t, a.Authenticate(r, new(AuthenticationSession),\n+\t\t\t\t\tsetup(t, `{ \"required_scope\": [\"scope-b\"], \"trusted_issuers\": [\"foo\", \"bar\"], \"target_audience\": [\"audience\"] }`),\n+\t\t\t\t\tnil))\n+\t\t\t\tdidNotUseCache.Wait()\n+\t\t\t})\n+\n+\t\t\tt.Run(\"case=requests an audience which the token does not have\", func(t *testing.T) {\n+\t\t\t\trequire.Error(t, a.Authenticate(r, new(AuthenticationSession),\n+\t\t\t\t\tsetup(t, `{ \"required_scope\": [\"scope-a\"], \"trusted_issuers\": [\"foo\", \"bar\"], \"target_audience\": [\"not-audience\"] }`),\n+\t\t\t\t\tnil))\n+\t\t\t\tdidNotUseCache.Wait()\n+\t\t\t})\n+\n+\t\t\tt.Run(\"case=does not trust the issuer\", func(t *testing.T) {\n+\t\t\t\trequire.Error(t, a.Authenticate(r, new(AuthenticationSession),\n+\t\t\t\t\tsetup(t, `{ \"required_scope\": [\"scope-a\"], \"trusted_issuers\": [\"not-foo\", \"bar\"], \"target_audience\": [\"audience\"] }`),\n+\t\t\t\t\tnil))\n+\t\t\t\tdidNotUseCache.Wait()\n+\t\t\t})\n+\n+\t\t\tt.Run(\"case=respects the expiry time\", func(t *testing.T) {\n+\t\t\t\tsetup(t, `{ \"required_scope\": [\"scope-a\"], \"trusted_issuers\": [\"foo\", \"bar\"], \"target_audience\": [\"audience\"] }`)\n+\t\t\t\trequire.NoError(t, a.Authenticate(r, new(AuthenticationSession), config, nil))\n+\t\t\t\ttime.Sleep(time.Second)\n+\t\t\t\trequire.Error(t, a.Authenticate(r, new(AuthenticationSession), config, nil))\n+\t\t\t\tdidNotUseCache.Wait()\n+\t\t\t})\n+\t\t})\n+\t})\n+\n \tt.Run(\"method=validate\", func(t *testing.T) {\n \t\tviper.Set(configuration.ViperKeyAuthenticatorOAuth2TokenIntrospectionIsEnabled, false)\n \t\trequire.Error(t, a.Validate(json.RawMessage(`{\"introspection_url\":\"\"}`)))"
        }
      ],
      "file_patterns": {
        "security_files": 3,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 6,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "5aac663d0b34dc2d59a08fb81d206849f44e2dfd",
            "date": "2025-01-10T16:19:05Z",
            "author_login": "ory-bot"
          },
          {
            "sha": "de75458b8e84e3e7b0fb051d8a7da193f14112ce",
            "date": "2025-01-10T16:09:49Z",
            "author_login": "ory-bot"
          },
          {
            "sha": "cd58b5bdeff197155d4dd870f9dbb3d23ac7f602",
            "date": "2025-01-02T14:05:40Z",
            "author_login": "ory-bot"
          },
          {
            "sha": "b9231efe943553a57ecb0524dbe77464fd609445",
            "date": "2025-01-02T13:56:26Z",
            "author_login": "ory-bot"
          },
          {
            "sha": "517f326ac077bafc0c0bae76e9a489c5e3b4271f",
            "date": "2025-01-02T12:47:54Z",
            "author_login": "ory-bot"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-863",
    "description": "ORY Oathkeeper is an Identity & Access Proxy (IAP) and Access Control Decision API that authorizes HTTP requests based on sets of Access Rules. When you make a request to an endpoint that requires the scope `foo` using an access token granted with that `foo` scope, introspection will be valid and that token will be cached. The problem comes when a second requests to an endpoint that requires the scope `bar` is made before the cache has expired. Whether the token is granted or not to the `bar` scope, introspection will be valid. A patch will be released with `v0.38.12-beta.1`. Per default, caching is disabled for the `oauth2_introspection` authenticator. When caching is disabled, this vulnerability does not exist. The cache is checked in [`func (a *AuthenticatorOAuth2Introspection) Authenticate(...)`](https://github.com/ory/oathkeeper/blob/6a31df1c3779425e05db1c2a381166b087cb29a4/pipeline/authn/authenticator_oauth2_introspection.go#L152). From [`tokenFromCache()`](https://github.com/ory/oathkeeper/blob/6a31df1c3779425e05db1c2a381166b087cb29a4/pipeline/authn/authenticator_oauth2_introspection.go#L97) it seems that it only validates the token expiration date, but ignores whether the token has or not the proper scopes. The vulnerability was introduced in PR #424. During review, we failed to require appropriate test coverage by the submitter which is the primary reason that the vulnerability passed the review process.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-06-22T20:15:08.727",
    "last_modified": "2024-11-21T06:07:33.667",
    "fix_date": "2021-06-22T13:02:29Z"
  },
  "references": [
    {
      "url": "https://github.com/ory/oathkeeper/commit/1f9f625c1a49e134ae2299ee95b8cf158feec932",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ory/oathkeeper/pull/424",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ory/oathkeeper/security/advisories/GHSA-qvp4-rpmr-xwrr",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ory/oathkeeper/commit/1f9f625c1a49e134ae2299ee95b8cf158feec932",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ory/oathkeeper/pull/424",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ory/oathkeeper/security/advisories/GHSA-qvp4-rpmr-xwrr",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:59.751451",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "oathkeeper",
    "owner": "ory",
    "created_at": "2017-09-25T11:04:45Z",
    "updated_at": "2025-01-24T19:43:45Z",
    "pushed_at": "2025-01-10T16:20:05Z",
    "size": 1315636,
    "stars": 3302,
    "forks": 359,
    "open_issues": 82,
    "watchers": 3302,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Go": 684583,
      "Mustache": 90778,
      "Shell": 21026,
      "Makefile": 3393
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T08:29:53.736424"
  }
}