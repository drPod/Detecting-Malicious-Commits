{
  "cve_id": "CVE-2021-32730",
  "github_data": {
    "repository": "xwiki/xwiki-platform",
    "fix_commit": "0a36dbcc5421d450366580217a47cc44d32f7257",
    "related_commits": [
      "0a36dbcc5421d450366580217a47cc44d32f7257",
      "0a36dbcc5421d450366580217a47cc44d32f7257"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "0a36dbcc5421d450366580217a47cc44d32f7257",
      "commit_date": "2021-03-03T14:51:46Z",
      "author": {
        "login": "surli",
        "type": "User",
        "stats": {
          "total_commits": 1946,
          "average_weekly_commits": 2.0355648535564854,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 284
        }
      },
      "commit_message": {
        "title": "XWIKI-18315: Bad check in reset password form.",
        "length": 46,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 127,
        "additions": 67,
        "deletions": 60
      },
      "files": [
        {
          "filename": "xwiki-platform-core/xwiki-platform-oldcore/src/main/resources/ApplicationResources.properties",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -1629,6 +1629,7 @@ core.register.password=Password\n core.register.passwordRepeat=Confirm Password\n core.register.email=Email Address\n core.register.submit=Register\n+core.register.badCSRF=Bad CSRF token.\n \n # User account validation\n core.users.activation.validationKey.label=Validation key:"
        },
        {
          "filename": "xwiki-platform-core/xwiki-platform-web/src/main/webapp/templates/register_macros.vm",
          "status": "modified",
          "additions": 66,
          "deletions": 60,
          "patch": "@@ -172,6 +172,7 @@ $xwiki.get('ssfx').use('uicomponents/widgets/validation/livevalidation.css', tru\n     #end\n   #end\n   </dl>\n+  <input type=\"hidden\" name=\"form_token\" value=\"$services.csrf.getToken()\" \u2215>\n   #generateJavascript($fields)\n #end\n ##\n@@ -311,74 +312,79 @@ $xwiki.get('ssfx').use('uicomponents/widgets/validation/livevalidation.css', tru\n #macro(validateFields, $fields, $request)\n   #set ($allFieldsValid = true)\n   #set ($allFieldsErrors = [])\n-  #foreach($field in $fields)\n-    #if($field.get('validate') && $field.get('name'))\n-      #set($fieldName = $field.get('name'))\n-      #set($validate = $field.get('validate'))\n-      #set($error = '')\n-      #set($value = $request.get($fieldName))\n-      #if(\"$!value\" != '' || $field.get('type') == 'html')\n-      ##\n-      ## mustMatch validation\n-        #if($error == '' && $validate.get('mustMatch'))\n-          #set($mustMatch = $validate.get('mustMatch'))\n-          #if($mustMatch.get('name') && $mustMatch.get('failureMessage'))\n-            #if($request.get($fieldName) != $request.get($mustMatch.get('name')))\n-              #set($error = $mustMatch.get('failureMessage'))\n+  #if (!$services.csrf.isTokenValid($request.form_token))\n+    #set ($allFieldsValid = false)\n+    #set ($discard = $allFieldsErrors.add($services.localization.render('core.register.badCSRF')))\n+  #else\n+    #foreach($field in $fields)\n+      #if($field.get('validate') && $field.get('name'))\n+        #set($fieldName = $field.get('name'))\n+        #set($validate = $field.get('validate'))\n+        #set($error = '')\n+        #set($value = $request.get($fieldName))\n+        #if(\"$!value\" != '' || $field.get('type') == 'html')\n+        ##\n+        ## mustMatch validation\n+          #if($error == '' && $validate.get('mustMatch'))\n+            #set($mustMatch = $validate.get('mustMatch'))\n+            #if($mustMatch.get('name') && $mustMatch.get('failureMessage'))\n+              #if($request.get($fieldName) != $request.get($mustMatch.get('name')))\n+                #set($error = $mustMatch.get('failureMessage'))\n+              #end\n+            #else\n+            ERROR: In field: ${fieldName}: mustMatch validation required both name\n+            (of field which this field must match) and failureMessage.\n             #end\n-          #else\n-          ERROR: In field: ${fieldName}: mustMatch validation required both name\n-          (of field which this field must match) and failureMessage.\n           #end\n-        #end\n-      ##\n-      ## Regex validation\n-      ## We won't bother with regex validation if there is no entry, that would defeat the purpose of 'mandatory'\n-        #if($error == '' && $validate.get('regex') && $value && $value != '')\n-          #set($regex = $validate.get('regex'))\n-          #validateRegex($value, $fieldName, $regex, $error)\n-        #end\n-      ## List of regex validation\n-        #if($error == '' && $validate.get('regexes') && $value && $value != '')\n-          #set($regexes = $validate.get('regexes'))\n-          #foreach ($regex in $regexes)\n+        ##\n+        ## Regex validation\n+        ## We won't bother with regex validation if there is no entry, that would defeat the purpose of 'mandatory'\n+          #if($error == '' && $validate.get('regex') && $value && $value != '')\n+            #set($regex = $validate.get('regex'))\n             #validateRegex($value, $fieldName, $regex, $error)\n           #end\n-        #end\n-      ##\n-      ## If regex and mustMatch validation passed, try programmatic validation\n-        #if($error == '' && $validate.get('programmaticValidation'))\n-          #set($pv = $validate.get('programmaticValidation'))\n-          #if($pv.get('code') && $pv.get('failureMessage'))\n-            #set($pvReturn = \"#evaluate($pv.get('code'))\")\n-            #if($pvReturn.indexOf('failed') != -1)\n-              #set($error = $pv.get('failureMessage'))\n+        ## List of regex validation\n+          #if($error == '' && $validate.get('regexes') && $value && $value != '')\n+            #set($regexes = $validate.get('regexes'))\n+            #foreach ($regex in $regexes)\n+              #validateRegex($value, $fieldName, $regex, $error)\n             #end\n-          #else\n-          ERROR: In field: ${fieldName}: programmaticValidation requires code and failureMessage\n           #end\n-        #end\n-      #else\n-      ##\n-      ## If no content, check if content is mandatory\n-        #if($validate.get('mandatory'))\n-          #set($mandatory = $validate.get('mandatory'))\n-          #if($mandatory.get('failureMessage'))\n-            #set($error = $mandatory.get('failureMessage'))\n-          #else\n-          ERROR: In field: ${fieldName}: mandatory validation requires a failureMessage\n+        ##\n+        ## If regex and mustMatch validation passed, try programmatic validation\n+          #if($error == '' && $validate.get('programmaticValidation'))\n+            #set($pv = $validate.get('programmaticValidation'))\n+            #if($pv.get('code') && $pv.get('failureMessage'))\n+              #set($pvReturn = \"#evaluate($pv.get('code'))\")\n+              #if($pvReturn.indexOf('failed') != -1)\n+                #set($error = $pv.get('failureMessage'))\n+              #end\n+            #else\n+            ERROR: In field: ${fieldName}: programmaticValidation requires code and failureMessage\n+            #end\n+          #end\n+        #else\n+        ##\n+        ## If no content, check if content is mandatory\n+          #if($validate.get('mandatory'))\n+            #set($mandatory = $validate.get('mandatory'))\n+            #if($mandatory.get('failureMessage'))\n+              #set($error = $mandatory.get('failureMessage'))\n+            #else\n+            ERROR: In field: ${fieldName}: mandatory validation requires a failureMessage\n+            #end\n           #end\n         #end\n-      #end\n-      #if($error != '')\n-        #set($discard = $field.put('error', $error))\n-        #set ($discard = $allFieldsErrors.add($error))\n-        #set($allFieldsValid = false)\n-      #end\n-    #elseif(!$field.get('name'))\n-    ERROR: Field with no name.\n-    #end##if(validate)\n-  #end##loop\n+        #if($error != '')\n+          #set($discard = $field.put('error', $error))\n+          #set ($discard = $allFieldsErrors.add($error))\n+          #set($allFieldsValid = false)\n+        #end\n+      #elseif(!$field.get('name'))\n+      ERROR: Field with no name.\n+      #end##if(validate)\n+    #end##loop\n+  #end ## CSRF check\n #end##macro\n \n #*"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 6
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "20d352276c008c8ea2a1cf1ea9ceb84193098477",
            "date": "2025-01-25T19:15:09Z",
            "author_login": "mflorea"
          },
          {
            "sha": "e29b630b2d5a42b6f12ed3f0e4f59bd078f8a0f7",
            "date": "2025-01-24T07:34:53Z",
            "author_login": "mflorea"
          },
          {
            "sha": "023144daf732d04b085c2423ebd4552edd09ac5c",
            "date": "2025-01-24T15:44:30Z",
            "author_login": "Sereza7"
          },
          {
            "sha": "a46579427dc202957d623b8e69a6a894243c6690",
            "date": "2025-01-21T16:53:45Z",
            "author_login": "Sereza7"
          },
          {
            "sha": "3d661180a9075925c3d2d75816356925f32ae89d",
            "date": "2025-01-21T16:13:46Z",
            "author_login": "Sereza7"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.7,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-352",
    "description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. A cross-site request forgery vulnerability exists in versions prior to 12.10.5, and in versions 13.0 through 13.1. It's possible for forge an URL that, when accessed by an admin, will reset the password of any user in XWiki. The problem has been patched in XWiki 12.10.5 and 13.2RC1. As a workaround, it is possible to apply the patch manually by modifying the `register_macros.vm` template.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-07-01T18:15:07.733",
    "last_modified": "2024-11-21T06:07:37.037",
    "fix_date": "2021-03-03T14:51:46Z"
  },
  "references": [
    {
      "url": "https://github.com/xwiki/xwiki-platform/commit/0a36dbcc5421d450366580217a47cc44d32f7257",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-v9j2-q4q5-cxh4",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://jira.xwiki.org/browse/XWIKI-18315",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/xwiki/xwiki-platform/commit/0a36dbcc5421d450366580217a47cc44d32f7257",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-v9j2-q4q5-cxh4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://jira.xwiki.org/browse/XWIKI-18315",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:59.770047",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "xwiki-platform",
    "owner": "xwiki",
    "created_at": "2011-03-10T13:26:41Z",
    "updated_at": "2025-01-25T19:23:49Z",
    "pushed_at": "2025-01-25T19:23:45Z",
    "size": 563394,
    "stars": 1035,
    "forks": 555,
    "open_issues": 143,
    "watchers": 1035,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Java": 34352251,
      "JavaScript": 2404688,
      "HTML": 388086,
      "Less": 318876,
      "AspectJ": 280487,
      "Vue": 222987,
      "CSS": 115582,
      "XSLT": 109285,
      "Clean": 44054,
      "Shell": 32569,
      "Batchfile": 14604,
      "Python": 5046,
      "Groovy": 3012,
      "AMPL": 1296
    },
    "commit_activity": {
      "total_commits_last_year": 1743,
      "avg_commits_per_week": 33.51923076923077,
      "days_active_last_year": 261
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-2.1"
    },
    "collected_at": "2025-01-26T07:34:26.816515"
  }
}