{
  "cve_id": "CVE-2021-32769",
  "github_data": {
    "repository": "micronaut-projects/micronaut-core",
    "fix_commit": "a0cfeb13bf1ef5d692d16d4a3b91b34b7456bb11",
    "related_commits": [
      "a0cfeb13bf1ef5d692d16d4a3b91b34b7456bb11",
      "a0cfeb13bf1ef5d692d16d4a3b91b34b7456bb11"
    ],
    "patch_url": "https://github.com/micronaut-projects/micronaut-core/commit/a0cfeb13bf1ef5d692d16d4a3b91b34b7456bb11.patch",
    "fix_commit_details": {
      "sha": "a0cfeb13bf1ef5d692d16d4a3b91b34b7456bb11",
      "commit_date": "2021-07-14T16:35:31Z",
      "author": {
        "login": "graemerocher",
        "type": "User",
        "stats": {
          "total_commits": 4816,
          "average_weekly_commits": 11.980099502487562,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 297
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-cjx7-399x-p2rj",
        "length": 267,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 227,
        "additions": 159,
        "deletions": 68
      },
      "files": [
        {
          "filename": "core/src/main/java/io/micronaut/core/io/file/DefaultFileSystemResourceLoader.java",
          "status": "modified",
          "additions": 46,
          "deletions": 11,
          "patch": "@@ -28,6 +28,7 @@\n import java.util.Optional;\n import java.util.stream.Stream;\n \n+\n /**\n  * Loads resources from the file system.\n  *\n@@ -36,54 +37,67 @@\n  */\n public class DefaultFileSystemResourceLoader implements FileSystemResourceLoader {\n \n-    private final Optional<Path> baseDirPath;\n+    private final Path baseDirPath;\n+    private final boolean baseExists;\n \n     /**\n      * Default constructor.\n      */\n     public DefaultFileSystemResourceLoader() {\n-        this.baseDirPath = Optional.empty();\n+        this.baseDirPath = null;\n+        this.baseExists = true;\n     }\n \n     /**\n      * @param baseDirPath The base directory\n      */\n     public DefaultFileSystemResourceLoader(File baseDirPath) {\n-        this.baseDirPath = Optional.of(baseDirPath.toPath());\n+        this(baseDirPath.toPath().normalize());\n     }\n \n     /**\n      * @param path The path\n      */\n     public DefaultFileSystemResourceLoader(String path) {\n-        this.baseDirPath = Optional.of(Paths.get(normalize(path)));\n+        this(Paths.get(normalize(path)));\n     }\n \n     /**\n      * @param path The path\n      */\n     public DefaultFileSystemResourceLoader(Path path) {\n-        this.baseDirPath = Optional.of(path);\n+        Path baseDirPath;\n+        try {\n+            baseDirPath = path.normalize().toRealPath();\n+        } catch (IOException e) {\n+            baseDirPath = null;\n+        }\n+        this.baseExists = baseDirPath != null;\n+        this.baseDirPath = baseDirPath;\n     }\n \n     @Override\n     public Optional<InputStream> getResourceAsStream(String path) {\n         Path filePath = getFilePath(normalize(path));\n-        try {\n-            return Optional.of(Files.newInputStream(filePath));\n-        } catch (IOException e) {\n-            return Optional.empty();\n+        if (isResolvableFile(filePath)) {\n+            try {\n+                return Optional.of(Files.newInputStream(filePath));\n+            } catch (IOException e) {\n+                return Optional.empty();\n+            }\n         }\n+        return Optional.empty();\n     }\n \n     @Override\n     public Optional<URL> getResource(String path) {\n         Path filePath = getFilePath(normalize(path));\n-        if (Files.exists(filePath) && Files.isReadable(filePath) && !Files.isDirectory(filePath)) {\n+        if (isResolvableFile(filePath)) {\n             try {\n                 URL url = filePath.toUri().toURL();\n                 return Optional.of(url);\n             } catch (MalformedURLException e) {\n+                // ignore\n             }\n         }\n         return Optional.empty();\n@@ -103,6 +117,10 @@ public ResourceLoader forBase(String basePath) {\n         return new DefaultFileSystemResourceLoader(basePath);\n     }\n \n+    private boolean isResolvableFile(Path filePath) {\n+        return startsWithBase(filePath) && Files.exists(filePath) && Files.isReadable(filePath) && !Files.isDirectory(filePath);\n+    }\n+\n     @SuppressWarnings(\"MagicNumber\")\n     private static String normalize(String path) {\n         if (path == null) {\n@@ -115,6 +133,23 @@ private static String normalize(String path) {\n     }\n \n     private Path getFilePath(String path) {\n-        return baseDirPath.map(dir -> dir.resolve(path)).orElseGet(() -> Paths.get(path));\n+        if (baseDirPath != null) {\n+            return baseDirPath.resolve(path);\n+        } else {\n+            return Paths.get(path);\n+        }\n+    }\n+\n+    private boolean startsWithBase(Path path) {\n+        if (baseDirPath != null) {\n+            Path relativePath;\n+            try {\n+                relativePath = baseDirPath.resolve(path).toRealPath();\n+                return relativePath.startsWith(baseDirPath);\n+            } catch (IOException e) {\n+                return false;\n+            }\n+        }\n+        return baseExists;\n     }\n }"
        },
        {
          "filename": "core/src/main/java/io/micronaut/core/io/scan/DefaultClassPathResourceLoader.java",
          "status": "modified",
          "additions": 72,
          "deletions": 38,
          "patch": "@@ -44,8 +44,10 @@ public class DefaultClassPathResourceLoader implements ClassPathResourceLoader {\n \n     private final ClassLoader classLoader;\n     private final String basePath;\n+    private final URL baseURL;\n     private final Map<String, Boolean> isDirectoryCache = new ConcurrentLinkedHashMap.Builder<String, Boolean>()\n             .maximumWeightedCapacity(50).build();\n+    private final boolean missingPath;\n \n     /**\n      * Default constructor.\n@@ -65,6 +67,8 @@ public DefaultClassPathResourceLoader(ClassLoader classLoader) {\n     public DefaultClassPathResourceLoader(ClassLoader classLoader, String basePath) {\n         this.classLoader = classLoader;\n         this.basePath = normalize(basePath);\n+        this.baseURL = basePath != null ? classLoader.getResource(normalize(basePath)) : null;\n+        this.missingPath = basePath != null && baseURL == null;\n     }\n \n     /**\n@@ -75,61 +79,83 @@ public DefaultClassPathResourceLoader(ClassLoader classLoader, String basePath)\n      */\n     @Override\n     public Optional<InputStream> getResourceAsStream(String path) {\n+        if (missingPath) {\n+            return Optional.empty();\n+        }\n+\n         URL url = classLoader.getResource(prefixPath(path));\n         if (url != null) {\n-            try {\n-                URI uri = url.toURI();\n-                if (uri.getScheme().equals(\"jar\")) {\n-                    synchronized (DefaultClassPathResourceLoader.class) {\n-                        FileSystem fileSystem = null;\n-                        try {\n+            if (startsWithBase(url)) {\n+                try {\n+                    URI uri = url.toURI();\n+                    if (uri.getScheme().equals(\"jar\")) {\n+                        synchronized (DefaultClassPathResourceLoader.class) {\n+                            FileSystem fileSystem = null;\n                             try {\n-                                fileSystem = FileSystems.getFileSystem(uri);\n-                            } catch (FileSystemNotFoundException e) {\n-                                //no-op\n-                            }\n-                            if (fileSystem == null || !fileSystem.isOpen()) {\n                                 try {\n-                                    fileSystem = FileSystems.newFileSystem(uri, Collections.emptyMap(), classLoader);\n-                                } catch (FileSystemAlreadyExistsException e) {\n                                     fileSystem = FileSystems.getFileSystem(uri);\n+                                } catch (FileSystemNotFoundException e) {\n+                                    //no-op\n                                 }\n-                            }\n-                            Path pathObject = fileSystem.getPath(path);\n-                            if (Files.isDirectory(pathObject)) {\n-                                return Optional.empty();\n-                            }\n-                            return Optional.of(new ByteArrayInputStream(Files.readAllBytes(pathObject)));\n-                        } finally {\n-                            if (fileSystem != null && fileSystem.isOpen()) {\n-                                try {\n-                                    fileSystem.close();\n-                                } catch (IOException e) {\n-                                    if (LOG.isDebugEnabled()) {\n-                                        LOG.debug(\"Error shutting down JAR file system [\" + fileSystem + \"]: \" + e.getMessage(), e);\n+                                if (fileSystem == null || !fileSystem.isOpen()) {\n+                                    try {\n+                                        fileSystem = FileSystems.newFileSystem(uri, Collections.emptyMap(), classLoader);\n+                                    } catch (FileSystemAlreadyExistsException e) {\n+                                        fileSystem = FileSystems.getFileSystem(uri);\n+                                    }\n+                                }\n+                                Path pathObject = fileSystem.getPath(path);\n+                                if (Files.isDirectory(pathObject)) {\n+                                    return Optional.empty();\n+                                }\n+                                return Optional.of(new ByteArrayInputStream(Files.readAllBytes(pathObject)));\n+                            } finally {\n+                                if (fileSystem != null && fileSystem.isOpen()) {\n+                                    try {\n+                                        fileSystem.close();\n+                                    } catch (IOException e) {\n+                                        if (LOG.isDebugEnabled()) {\n+                                            LOG.debug(\"Error shutting down JAR file system [\" + fileSystem + \"]: \" + e.getMessage(), e);\n+                                        }\n                                     }\n                                 }\n                             }\n                         }\n+                    } else if (uri.getScheme().equals(\"file\")) {\n+                        Path pathObject = Paths.get(uri);\n+                        if (Files.isDirectory(pathObject)) {\n+                            return Optional.empty();\n+                        }\n+                        return Optional.of(Files.newInputStream(pathObject));\n                     }\n-                } else if (uri.getScheme().equals(\"file\")) {\n-                    Path pathObject = Paths.get(uri);\n-                    if (Files.isDirectory(pathObject)) {\n-                        return Optional.empty();\n+                } catch (URISyntaxException | IOException | ProviderNotFoundException e) {\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"Error establishing whether path is a directory: \" + e.getMessage(), e);\n                     }\n-                    return Optional.of(Files.newInputStream(pathObject));\n-                }\n-            } catch (URISyntaxException | IOException | ProviderNotFoundException e) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Error establishing whether path is a directory: \" + e.getMessage(), e);\n                 }\n             }\n         }\n         // fallback to less sophisticated approach\n         if (path.indexOf('.') == -1) {\n             return Optional.empty();\n         }\n-        return Optional.ofNullable(classLoader.getResourceAsStream(prefixPath(path)));\n+        final URL u = getResource(path).orElse(null);\n+        if (u != null) {\n+            try {\n+                return Optional.of(u.openStream());\n+            } catch (IOException e) {\n+                // fallback to empty\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private boolean startsWithBase(URL url) {\n+        if (baseURL == null) {\n+            return true;\n+        } else {\n+            return url.toExternalForm().startsWith(baseURL.toExternalForm());\n+        }\n     }\n \n     /**\n@@ -140,11 +166,17 @@ public Optional<InputStream> getResourceAsStream(String path) {\n      */\n     @Override\n     public Optional<URL> getResource(String path) {\n+        if (missingPath) {\n+            return Optional.empty();\n+        }\n+\n         boolean isDirectory = isDirectory(path);\n \n         if (!isDirectory) {\n             URL url = classLoader.getResource(prefixPath(path));\n-            return Optional.ofNullable(url);\n+            if (url != null && startsWithBase(url)) {\n+                return Optional.of(url);\n+            }\n         }\n         return Optional.empty();\n     }\n@@ -166,7 +198,9 @@ public Stream<URL> getResources(String path) {\n         Stream.Builder<URL> builder = Stream.builder();\n         while (all.hasMoreElements()) {\n             URL url = all.nextElement();\n-            builder.accept(url);\n+            if (startsWithBase(url)) {\n+                builder.accept(url);\n+            }\n         }\n         return builder.build();\n     }"
        },
        {
          "filename": "core/src/test/groovy/io/micronaut/core/io/ClasspathResourceLoaderSpec.groovy",
          "status": "modified",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -40,4 +40,23 @@ class ClasspathResourceLoaderSpec extends Specification {\n         \"classpath:/foo\" | \"classpath:/bar.txt\"\n         \"classpath:foo\"  | \"classpath:/bar.txt\"\n     }\n+\n+    void \"test resolving a classpath resource with a relative path\"() {\n+        given:\n+        ClassPathResourceLoader loader = new DefaultClassPathResourceLoader(getClass().getClassLoader(), base)\n+\n+        expect:\n+        loader.getResource(resource).isPresent() == present\n+        loader.getResourceAsStream(resource).map({ InputStream io -> io.close(); io})\n+                .isPresent() == present\n+        loader.getResources(resource).findFirst().isPresent() == present\n+\n+        where:\n+        base             | resource                                        | present\n+        \"classpath:foo\"  | \"classpath:../foo/bar.txt\"                      | true\n+        \"classpath:foo\"  | \"classpath:../other/../foo/bar.txt\"             | true\n+        \"classpath:foo\"  | \"classpath:../foo/../other/shouldNotAccess.txt\" | false\n+        \"classpath:foo\"  | \"classpath:../other/shouldNotAccess.txt\"        | false\n+        \"classpath:foo\"  | \"classpath:foo/../../other/shouldNotAccess.txt\" | false\n+    }\n }"
        },
        {
          "filename": "core/src/test/groovy/io/micronaut/core/io/FileSystemResourceLoaderSpec.groovy",
          "status": "modified",
          "additions": 16,
          "deletions": 12,
          "patch": "@@ -18,25 +18,29 @@ package io.micronaut.core.io\n import io.micronaut.core.io.file.DefaultFileSystemResourceLoader\n import io.micronaut.core.io.file.FileSystemResourceLoader\n import spock.lang.Specification\n-\n-import java.nio.file.Paths\n+import spock.lang.Unroll\n \n class FileSystemResourceLoaderSpec extends Specification {\n \n-    void \"test resolving a resource\"() {\n+    @Unroll\n+    void \"test resolving a resource for #base and #resource\"() {\n         given:\n-        FileSystemResourceLoader loader = new DefaultFileSystemResourceLoader(base)\n+        DefaultFileSystemResourceLoader loader = new DefaultFileSystemResourceLoader(base)\n \n         expect:\n-        !loader.getResource(resource).isPresent()\n+        loader.getResource(resource).isPresent() == presentViaResolver\n+        new File(loader.normalize(base), loader.normalize(resource)).exists() == presentOnDisk\n \n         where:\n-        base        | resource\n-        \".\"         | \"src\"\n-        \".\"         | \"file:src/main\"\n-        \"src\"       | \"main\"\n-        \"file:src\"  | \"main\"\n-        \"file:src\"  | \"file:main\"\n-        \"file:src\"  | \"file:/main\"\n+        base                      | resource                   | presentViaResolver   | presentOnDisk\n+        \".\"                       | \"src\"                      | false                | true\n+        \".\"                       | \"file:src/main\"            | false                | true\n+        \"src\"                     | \"main\"                     | false                | true\n+        \"file:src\"                | \"main\"                     | false                | true\n+        \"file:src\"                | \"file:main\"                | false                | true\n+        \"file:src\"                | \"file:/main\"               | false                | true\n+        \"src/test/resources\"      | \"foo/bar.txt\"              | true                 | true\n+        \"file:src/test/resources\" | \"../resources/foo/bar.txt\" | true                 | true\n+        \"file:src/test/resources\" | \"../../../build.gradle\"    | false                | true\n     }\n }"
        },
        {
          "filename": "core/src/test/resources/other/shouldNotAccess.txt",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "inject/src/main/java/io/micronaut/context/env/DefaultEnvironment.java",
          "status": "modified",
          "additions": 4,
          "deletions": 5,
          "patch": "@@ -453,7 +453,7 @@ protected List<PropertySource> readPropertySourceListFromFiles(String files) {\n                             }\n                             order++;\n                         } else {\n-                            throw new ConfigurationException(\"Unsupported properties file format: \" + fileName);\n+                            throw new ConfigurationException(\"Unsupported properties file format: \" + filePath);\n                         }\n                     }\n                 }\n@@ -583,12 +583,11 @@ private void loadPropertySourceFromLoader(String name, PropertySourceLoader prop\n      * @param fileName             Name of the file to be used as property source name\n      * @param filePath             Absolute file path\n      * @param propertySourceLoader The appropriate property source loader\n-     * @throws ConfigurationException If unable to find the appropriate property soruce loader for the given file\n+     * @throws ConfigurationException If unable to find the appropriate property source loader for the given file\n      */\n     private Optional<Map<String, Object>> readPropertiesFromLoader(String fileName, String filePath, PropertySourceLoader propertySourceLoader) throws ConfigurationException {\n-        ResourceResolver resourceResolver = new ResourceResolver();\n-        Optional<ResourceLoader> resourceLoader = resourceResolver.getSupportingLoader(filePath);\n-        ResourceLoader loader = resourceLoader.orElse(FileSystemResourceLoader.defaultLoader());\n+        ResourceLoader loader = new ResourceResolver().getSupportingLoader(filePath)\n+                .orElse(FileSystemResourceLoader.defaultLoader());\n         try {\n             Optional<InputStream> inputStream = loader.getResourceAsStream(filePath);\n             if (inputStream.isPresent()) {"
        },
        {
          "filename": "inject/src/test/groovy/io/micronaut/context/env/DefaultEnvironmentSpec.groovy",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -130,7 +130,7 @@ class DefaultEnvironmentSpec extends Specification {\n \n         then: \"should throw exception\"\n         def e = thrown(ConfigurationException)\n-        e.message == \"Unsupported properties file format: \" + NameUtils.filename(unsupportedFile.absolutePath)\n+        e.message == \"Unsupported properties file format: \" + unsupportedFile.absolutePath\n \n         when: \"file from system property source loader does not override the key\"\n         System.setProperty(\"foo.baz\", \"10\")\n@@ -197,7 +197,7 @@ class DefaultEnvironmentSpec extends Specification {\n \n         then: \"should throw exception\"\n         def e = thrown(ConfigurationException)\n-        e.message == \"Unsupported properties file format: \" + NameUtils.filename(unsupportedFile.absolutePath)\n+        e.message == \"Unsupported properties file format: \" + unsupportedFile.absolutePath\n \n         when: \"file from system property source loader does not override the key\"\n         System.setProperty(\"foo.baz\", \"10\")"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 6,
        "max_directory_depth": 9
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2806d7ec499ab48bf6fd78d8fc5e56c6d6e9d549",
            "date": "2025-01-14T17:05:53Z",
            "author_login": "dstepanov"
          },
          {
            "sha": "2e6dc9f1b0c2f6b5dfdc528af850706184c52c35",
            "date": "2025-01-14T14:41:12Z",
            "author_login": "dstepanov"
          },
          {
            "sha": "40f5e30ab6ec7ac3b353472007d29035fa1599bd",
            "date": "2025-01-14T14:40:28Z",
            "author_login": "graemerocher"
          },
          {
            "sha": "b3459e3667c1ceb8bf1d3776743d5c47d3648bf6",
            "date": "2025-01-13T11:59:20Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "7cf4f3117e8c9ee8ca5ffffbbb64bae5731ed53b",
            "date": "2025-01-13T10:19:38Z",
            "author_login": "dstepanov"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-22",
    "description": "Micronaut is a JVM-based, full stack Java framework designed for building JVM applications. A path traversal vulnerability exists in versions prior to 2.5.9. With a basic configuration, it is possible to access any file from a filesystem, using \"/../../\" in the URL. This occurs because Micronaut does not restrict file access to configured paths. The vulnerability is patched in version 2.5.9. As a workaround, do not use `**` in mapping, use only `*`, which exposes only flat structure of a directory not allowing traversal. If using Linux, another workaround is to run micronaut in chroot.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-07-16T19:15:07.893",
    "last_modified": "2024-11-21T06:07:42.297",
    "fix_date": "2021-07-14T16:35:31Z"
  },
  "references": [
    {
      "url": "https://github.com/micronaut-projects/micronaut-core/commit/a0cfeb13bf1ef5d692d16d4a3b91b34b7456bb11",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/micronaut-projects/micronaut-core/security/advisories/GHSA-cjx7-399x-p2rj",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/micronaut-projects/micronaut-core/commit/a0cfeb13bf1ef5d692d16d4a3b91b34b7456bb11",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/micronaut-projects/micronaut-core/security/advisories/GHSA-cjx7-399x-p2rj",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:02.311793",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "micronaut-core",
    "owner": "micronaut-projects",
    "created_at": "2018-03-07T12:05:08Z",
    "updated_at": "2025-01-14T17:06:00Z",
    "pushed_at": "2025-01-14T17:07:39Z",
    "size": 106282,
    "stars": 6127,
    "forks": 1079,
    "open_issues": 780,
    "watchers": 6127,
    "has_security_policy": false,
    "default_branch": "4.8.x",
    "protected_branches": [
      "1.0.x",
      "1.1.x",
      "1.2.x",
      "1.3.x",
      "2.0.x",
      "2.1.x",
      "2.2.x",
      "2.3.x",
      "2.4.x",
      "2.5.x",
      "3.0.x",
      "3.1.x",
      "3.2.x",
      "3.3.x",
      "3.4.x",
      "3.5.x",
      "3.6.x",
      "3.7.x",
      "3.8.x",
      "3.9.x",
      "3.10.x",
      "4.0.x",
      "4.1.x",
      "4.2.x",
      "4.3.x",
      "4.4.x",
      "4.5.x",
      "4.6.x",
      "4.7.x",
      "4.8.x"
    ],
    "languages": {
      "Java": 13164790,
      "Groovy": 7091019,
      "Kotlin": 1679941,
      "HTML": 143,
      "Shell": 14
    },
    "commit_activity": {
      "total_commits_last_year": 809,
      "avg_commits_per_week": 15.557692307692308,
      "days_active_last_year": 212
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T19:52:45.165020"
  }
}