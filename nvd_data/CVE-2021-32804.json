{
  "cve_id": "CVE-2021-32804",
  "github_data": {
    "repository": "npm/node-tar",
    "fix_commit": "1f036ca23f64a547bdd6c79c1a44bc62e8115da4",
    "related_commits": [
      "1f036ca23f64a547bdd6c79c1a44bc62e8115da4",
      "1f036ca23f64a547bdd6c79c1a44bc62e8115da4"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "1f036ca23f64a547bdd6c79c1a44bc62e8115da4",
      "commit_date": "2021-07-23T22:27:25Z",
      "author": {
        "login": "isaacs",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix: strip absolute paths more comprehensively",
        "length": 46,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 77,
        "additions": 57,
        "deletions": 20
      },
      "files": [
        {
          "filename": "lib/strip-absolute-path.js",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+// unix absolute paths are also absolute on win32, so we use this for both\n+const { isAbsolute, parse } = require('path').win32\n+\n+// returns [root, stripped]\n+module.exports = path => {\n+  let r = ''\n+  while (isAbsolute(path)) {\n+    // windows will think that //x/y/z has a \"root\" of //x/y/\n+    const root = path.charAt(0) === '/' ? '/' : parse(path).root\n+    path = path.substr(root.length)\n+    r += root\n+  }\n+  return [r, path]\n+}"
        },
        {
          "filename": "lib/unpack.js",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -14,6 +14,7 @@ const path = require('path')\n const mkdir = require('./mkdir.js')\n const wc = require('./winchars.js')\n const pathReservations = require('./path-reservations.js')\n+const stripAbsolutePath = require('./strip-absolute-path.js')\n \n const ONENTRY = Symbol('onEntry')\n const CHECKFS = Symbol('checkFs')\n@@ -224,11 +225,10 @@ class Unpack extends Parser {\n \n       // absolutes on posix are also absolutes on win32\n       // so we only need to test this one to get both\n-      if (path.win32.isAbsolute(p)) {\n-        const parsed = path.win32.parse(p)\n-        entry.path = p.substr(parsed.root.length)\n-        const r = parsed.root\n-        this.warn('TAR_ENTRY_INFO', `stripping ${r} from absolute path`, {\n+      const [root, stripped] = stripAbsolutePath(p)\n+      if (root) {\n+        entry.path = stripped\n+        this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\n           entry,\n           path: p,\n         })"
        },
        {
          "filename": "lib/write-entry.js",
          "status": "modified",
          "additions": 13,
          "deletions": 10,
          "patch": "@@ -23,6 +23,7 @@ const CLOSE = Symbol('close')\n const MODE = Symbol('mode')\n const warner = require('./warn-mixin.js')\n const winchars = require('./winchars.js')\n+const stripAbsolutePath = require('./strip-absolute-path.js')\n \n const modeFix = require('./mode-fix.js')\n \n@@ -52,12 +53,12 @@ const WriteEntry = warner(class WriteEntry extends MiniPass {\n       this.on('warn', opt.onwarn)\n \n     let pathWarn = false\n-    if (!this.preservePaths && path.win32.isAbsolute(p)) {\n-      // absolutes on posix are also absolutes on win32\n-      // so we only need to test this one to get both\n-      const parsed = path.win32.parse(p)\n-      this.path = p.substr(parsed.root.length)\n-      pathWarn = parsed.root\n+    if (!this.preservePaths) {\n+      const [root, stripped] = stripAbsolutePath(this.path)\n+      if (root) {\n+        this.path = stripped\n+        pathWarn = root\n+      }\n     }\n \n     this.win32 = !!opt.win32 || process.platform === 'win32'\n@@ -351,10 +352,12 @@ const WriteEntryTar = warner(class WriteEntryTar extends MiniPass {\n       this.on('warn', opt.onwarn)\n \n     let pathWarn = false\n-    if (path.isAbsolute(this.path) && !this.preservePaths) {\n-      const parsed = path.parse(this.path)\n-      pathWarn = parsed.root\n-      this.path = this.path.substr(parsed.root.length)\n+    if (!this.preservePaths) {\n+      const [root, stripped] = stripAbsolutePath(this.path)\n+      if (root) {\n+        this.path = stripped\n+        pathWarn = root\n+      }\n     }\n \n     this.remain = readEntry.size"
        },
        {
          "filename": "test/strip-absolute-path.js",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+const t = require('tap')\n+const stripAbsolutePath = require('../lib/strip-absolute-path.js')\n+\n+const cases = {\n+  '/': ['/', ''],\n+  '////': ['////', ''],\n+  'c:///a/b/c': ['c:///', 'a/b/c'],\n+  '\\\\\\\\foo\\\\bar\\\\baz': ['\\\\\\\\foo\\\\bar\\\\', 'baz'],\n+  '//foo//bar//baz': ['//', 'foo//bar//baz'],\n+  'c:\\\\c:\\\\c:\\\\c:\\\\\\\\d:\\\\e/f/g': ['c:\\\\c:\\\\c:\\\\c:\\\\\\\\d:\\\\', 'e/f/g'],\n+}\n+\n+for (const [input, [root, stripped]] of Object.entries(cases))\n+  t.strictSame(stripAbsolutePath(input), [root, stripped], input)"
        },
        {
          "filename": "test/unpack.js",
          "status": "modified",
          "additions": 5,
          "deletions": 2,
          "patch": "@@ -776,14 +776,17 @@ t.test('absolute paths', t => {\n   })\n \n   const absolute = path.resolve(dir, 'd/i/r/absolute')\n+  const root = path.parse(absolute).root\n+  const extraAbsolute = root + root + root + absolute\n+  t.ok(path.isAbsolute(extraAbsolute))\n   t.ok(path.isAbsolute(absolute))\n   const parsed = path.parse(absolute)\n   const relative = absolute.substr(parsed.root.length)\n   t.notOk(path.isAbsolute(relative))\n \n   const data = makeTar([\n     {\n-      path: absolute,\n+      path: extraAbsolute,\n       type: 'File',\n       size: 1,\n       atime: new Date('1979-07-01T19:10:00.000Z'),\n@@ -798,7 +801,7 @@ t.test('absolute paths', t => {\n   t.test('warn and correct', t => {\n     const check = t => {\n       t.match(warnings, [[\n-        'stripping / from absolute path',\n+        `stripping ${root}${root}${root}${root} from absolute path`,\n         { path: absolute, code: 'TAR_ENTRY_INFO' },\n       ]])\n       t.ok(fs.lstatSync(path.resolve(dir, relative)).isFile(), 'is file')"
        },
        {
          "filename": "test/write-entry.js",
          "status": "modified",
          "additions": 6,
          "deletions": 3,
          "patch": "@@ -385,7 +385,10 @@ t.test('nonexistent file', t => {\n })\n \n t.test('absolute path', t => {\n-  const f = path.resolve(files, '512-bytes.txt')\n+  const absolute = path.resolve(files, '512-bytes.txt')\n+  const { root } = path.parse(absolute)\n+  const f = root + root + root + absolute\n+  const warn = root + root + root + root\n   t.test('preservePaths=false strict=false', t => {\n     const warnings = []\n     const ws = new WriteEntry(f, {\n@@ -398,13 +401,13 @@ t.test('absolute path', t => {\n       out = Buffer.concat(out)\n       t.equal(out.length, 1024)\n       t.match(warnings, [[\n-        'TAR_ENTRY_INFO', /stripping .* from absolute path/, { path: f },\n+        'TAR_ENTRY_INFO', `stripping ${warn} from absolute path`, { path: f },\n       ]])\n \n       t.match(ws.header, {\n         cksumValid: true,\n         needPax: false,\n-        path: f.replace(/^(\\/|[a-z]:\\\\\\\\)/, ''),\n+        path: f.replace(/^(\\/|[a-z]:\\\\\\\\){4}/, ''),\n         mode: 0o644,\n         size: 512,\n         linkpath: null,"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d3cd4392d4a35a8f1e10287a07e57da6ae079e78",
            "date": "2024-08-14T16:04:53Z",
            "author_login": "isaacs"
          },
          {
            "sha": "02f883aa4d3336c023fb826d4ba11dde01c7f338",
            "date": "2024-08-14T16:03:40Z",
            "author_login": "isaacs"
          },
          {
            "sha": "206fcf91b01fae95ae859b8f3254bfd88744602a",
            "date": "2024-07-26T04:33:27Z",
            "author_login": "isaacs"
          },
          {
            "sha": "bf13718dc6b6636a234327122e8df05df52674d3",
            "date": "2024-07-26T04:32:21Z",
            "author_login": "isaacs"
          },
          {
            "sha": "68a685b30eadddad71cec56bc136bd276fa7e7f6",
            "date": "2024-07-24T23:57:43Z",
            "author_login": "isaacs"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.2,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N",
    "cwe_id": "CWE-22",
    "description": "The npm package \"tar\" (aka node-tar) before versions 6.1.1, 5.0.6, 4.4.14, and 3.3.2 has a arbitrary File Creation/Overwrite vulnerability due to insufficient absolute path sanitization. node-tar aims to prevent extraction of absolute file paths by turning absolute paths into relative paths when the `preservePaths` flag is not set to `true`. This is achieved by stripping the absolute path root from any absolute file paths contained in a tar file. For example `/home/user/.bashrc` would turn into `home/user/.bashrc`. This logic was insufficient when file paths contained repeated path roots such as `////home/user/.bashrc`. `node-tar` would only strip a single path root from such paths. When given an absolute file path with repeating path roots, the resulting path (e.g. `///home/user/.bashrc`) would still resolve to an absolute path, thus allowing arbitrary file creation and overwrite. This issue was addressed in releases 3.2.2, 4.4.14, 5.0.6 and 6.1.1. Users may work around this vulnerability without upgrading by creating a custom `onentry` method which sanitizes the `entry.path` or a `filter` method which removes entries with absolute paths. See referenced GitHub Advisory for details. Be aware of CVE-2021-32803 which fixes a similar bug in later versions of tar.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-08-03T19:15:08.410",
    "last_modified": "2024-11-21T06:07:46.800",
    "fix_date": "2021-07-23T22:27:25Z"
  },
  "references": [
    {
      "url": "https://cert-portal.siemens.com/productcert/pdf/ssa-389290.pdf",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/npm/node-tar/commit/1f036ca23f64a547bdd6c79c1a44bc62e8115da4",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/npm/node-tar/security/advisories/GHSA-3jfq-g458-7qm9",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.npmjs.com/advisories/1770",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.npmjs.com/package/tar",
      "source": "security-advisories@github.com",
      "tags": [
        "Product",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpuoct2021.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://cert-portal.siemens.com/productcert/pdf/ssa-389290.pdf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/npm/node-tar/commit/1f036ca23f64a547bdd6c79c1a44bc62e8115da4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/npm/node-tar/security/advisories/GHSA-3jfq-g458-7qm9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.npmjs.com/advisories/1770",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.npmjs.com/package/tar",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpuoct2021.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:02.356736",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "node-tar",
    "owner": "npm",
    "created_at": "2011-03-27T22:17:23Z",
    "updated_at": "2025-01-21T15:48:04Z",
    "pushed_at": "2024-08-14T16:04:55Z",
    "size": 10002,
    "stars": 851,
    "forks": 185,
    "open_issues": 18,
    "watchers": 851,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "JavaScript": 271712,
      "TypeScript": 211914
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "isc"
    },
    "collected_at": "2025-01-26T08:28:43.744804"
  }
}