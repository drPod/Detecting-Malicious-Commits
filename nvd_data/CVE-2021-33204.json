{
  "cve_id": "CVE-2021-33204",
  "github_data": {
    "repository": "pgpartman/pg_partman",
    "fix_commit": "0b6565ad378c358f8a6cd1d48ddc482eb7f854d3",
    "related_commits": [
      "0b6565ad378c358f8a6cd1d48ddc482eb7f854d3",
      "0b6565ad378c358f8a6cd1d48ddc482eb7f854d3"
    ],
    "patch_url": "https://github.com/pgpartman/pg_partman/commit/0b6565ad378c358f8a6cd1d48ddc482eb7f854d3.patch",
    "fix_commit_details": {
      "sha": "0b6565ad378c358f8a6cd1d48ddc482eb7f854d3",
      "commit_date": "2021-05-11T17:28:02Z",
      "author": {
        "login": "keithf4",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "v4.5.1 Fix security vulnerability and id sub-partitioning. See CHANGELOG for more details.",
        "length": 90,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 2227,
        "additions": 2206,
        "deletions": 21
      },
      "files": [
        {
          "filename": "CHANGELOG.txt",
          "status": "modified",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -1,3 +1,16 @@\n+4.5.1\n+NEW FEATURES\n+============\n+-- Allow relation options set on the template table to be inherited on the child table. As of PG13 and earlier, relation options set on the parent are not being set on the child tables. Unknown if PG14 will handle this yet or not (Github PR #348).\n+\n+BUG FIXES\n+=========\n+-- Fixed security issue that could allow arbitrary code execution using SECURITY DEFINER functions. Set explicit search_path to avoid this. Thanks to Github user @tapioaiven of Aiven Ltd for reporting the issue.\n+\n+-- Fixed several bugs in sub-partitioning when using a mixture of epoch and regular integer partitioning in the same partition set (Github Issue #357).\n+\n+\n+\n 4.5.0\n NEW FEATURES\n ============"
        },
        {
          "filename": "META.json",
          "status": "modified",
          "additions": 7,
          "deletions": 7,
          "patch": "@@ -1,9 +1,9 @@\n {\n     \"name\": \"pg_partman\",\n     \"abstract\": \"Extension to manage partitioned tables by time or ID\",\n-    \"version\": \"4.5.0\",\n+    \"version\": \"4.5.1\",\n     \"maintainer\": [ \n-        \"Keith Fiske <keith@omniti.com>\"\n+        \"Keith Fiske <keith@keithf4.com>\"\n     ],\n     \"license\": \"postgresql\",\n     \"generated_by\": \"Keith Fiske\",\n@@ -20,19 +20,19 @@\n     },\n     \"provides\": {\n         \"pg_partman\": {\n-            \"file\": \"sql/pg_partman--4.5.0.sql\",\n+            \"file\": \"sql/pg_partman--4.5.1.sql\",\n             \"docfile\": \"doc/pg_partman.md\",\n-            \"version\": \"4.5.0\",\n+            \"version\": \"4.5.1\",\n             \"abstract\": \"Extension to manage partitioned tables by time or ID\"\n         }\n     },\n     \"resources\": {\n         \"bugtracker\": {\n-            \"web\": \"https://github.com/keithf4/pg_partman/issues\"\n+            \"web\": \"https://github.com/pgpartman/pg_partman/issues\"\n         },\n         \"repository\": {\n-            \"url\": \"git://github.com/keithf4/pg_partman.git\" ,\n-            \"web\": \"https://github.com/keithf4/pg_partman\",\n+            \"url\": \"git://github.com/pgpartman/pg_partman.git\" ,\n+            \"web\": \"https://github.com/pgpartman/pg_partman\",\n             \"type\": \"git\"\n         }\n     },    "
        },
        {
          "filename": "pg_partman.control",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,3 +1,3 @@\n-default_version = '4.5.0'\n+default_version = '4.5.1'\n comment = 'Extension to manage partitioned tables by time or ID'\n relocatable = false"
        },
        {
          "filename": "sql/functions/check_name_length.sql",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -1,5 +1,6 @@\n CREATE FUNCTION @extschema@.check_name_length (p_object_name text, p_suffix text DEFAULT NULL, p_table_partition boolean DEFAULT FALSE) RETURNS text\n     LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER\n+    SET search_path TO pg_catalog, pg_temp\n     AS $$\n DECLARE\n     v_new_length    int;"
        },
        {
          "filename": "sql/functions/create_parent.sql",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -32,6 +32,7 @@ v_datetime_string               text;\n v_default_partition             text;\n v_higher_control_type           text;\n v_higher_parent_control         text;\n+v_higher_parent_epoch           text;\n v_higher_parent_schema          text := split_part(p_parent_table, '.', 1);\n v_higher_parent_table           text := split_part(p_parent_table, '.', 2);\n v_id_interval                   bigint;\n@@ -562,8 +563,8 @@ IF v_control_type = 'id' AND p_epoch = 'none' THEN\n             JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n             WHERE n.nspname = v_higher_parent_schema::name\n             AND c.relname = v_higher_parent_table::name\n-        ) SELECT n.nspname, c.relname, p.control\n-        INTO v_higher_parent_schema, v_higher_parent_table, v_higher_parent_control\n+        ) SELECT n.nspname, c.relname, p.control, p.epoch\n+        INTO v_higher_parent_schema, v_higher_parent_table, v_higher_parent_control, v_higher_parent_epoch\n         FROM pg_catalog.pg_class c\n         JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n         JOIN top_oid t ON c.oid = t.top_parent_oid\n@@ -572,7 +573,7 @@ IF v_control_type = 'id' AND p_epoch = 'none' THEN\n         IF v_higher_parent_table IS NOT NULL THEN\n             SELECT general_type INTO v_higher_control_type\n             FROM @extschema@.check_control_type(v_higher_parent_schema, v_higher_parent_table, v_higher_parent_control);\n-            IF v_higher_control_type <> 'id' THEN\n+            IF v_higher_control_type <> 'id' or (v_higher_control_type = 'id' AND v_higher_parent_epoch <> 'none') THEN\n                 -- The parent above the p_parent_table parameter is not partitioned by ID\n                 --   so don't check for max values in parents that aren't partitioned by ID.\n                 -- This avoids missing child tables in subpartition sets that have differing ID data"
        },
        {
          "filename": "sql/functions/create_sub_parent.sql",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -176,7 +176,7 @@ LOOP\n             RAISE EXCEPTION 'Due to conflicting data boundaries between ISO weeks and any larger interval of time, pg_partman cannot support a sub-partition interval of weekly';\n         END IF;\n \n-    ELSIF v_control_parent_type = 'id' AND v_control_sub_type = 'id' THEN\n+    ELSIF v_control_parent_type = 'id' AND v_control_sub_type = 'id' AND v_parent_epoch = 'none' AND p_epoch = 'none' THEN\n         IF p_interval::bigint >= v_parent_interval::bigint THEN\n             EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_old_search_path, 'false');\n             RAISE EXCEPTION 'Sub-partition interval cannot be greater than or equal to the given parent interval';"
        },
        {
          "filename": "sql/functions/inherit_template_properties.sql",
          "status": "modified",
          "additions": 22,
          "deletions": 8,
          "patch": "@@ -14,6 +14,7 @@ v_inherit_fk            boolean;\n v_parent_index_list     record;\n v_parent_oid            oid;\n v_parent_table          text;\n+v_relopt                record;\n v_sql                   text;\n v_template_oid          oid;\n v_template_schemaname   text;\n@@ -119,14 +120,14 @@ IF current_setting('server_version_num')::int >= 100000 THEN\n \n                 IF v_parent_index_list.indisprimary AND v_index_list.indisprimary THEN\n                     IF v_parent_index_list.indkey_names = v_index_list.indkey_names THEN\n-                        RAISE DEBUG 'Ignoring duplicate primary key on template table: % ', v_index_list.indkey_names;\n+                        RAISE DEBUG 'inherit_template_properties: Ignoring duplicate primary key on template table: % ', v_index_list.indkey_names;\n                         v_dupe_found := true;\n                         CONTINUE; -- only continue within this nested loop\n                     END IF;\n                 END IF;\n \n                 IF v_parent_index_list.statement = v_index_list.statement THEN\n-                    RAISE DEBUG 'Ignoring duplicate index on template table: %', v_index_list.statement;\n+                    RAISE DEBUG 'inherit_template_properties: Ignoring duplicate index on template table: %', v_index_list.statement;\n                     v_dupe_found := true;\n                     CONTINUE; -- only continue within this nested loop\n                 END IF;\n@@ -147,7 +148,7 @@ IF current_setting('server_version_num')::int >= 100000 THEN\n             IF v_index_list.tablespace_name IS NOT NULL THEN\n                 v_sql := v_sql || format(' USING INDEX TABLESPACE %I', v_index_list.tablespace_name);\n             END IF;\n-            RAISE DEBUG 'Create pk: %', v_sql;\n+            RAISE DEBUG 'inherit_template_properties: Create pk: %', v_sql;\n             EXECUTE v_sql;\n         ELSE\n             -- statement column should be just the portion of the index definition that defines what it actually is\n@@ -156,7 +157,7 @@ IF current_setting('server_version_num')::int >= 100000 THEN\n                 v_sql := v_sql || format(' TABLESPACE %I', v_index_list.tablespace_name);\n             END IF;\n \n-            RAISE DEBUG 'Create index: %', v_sql;\n+            RAISE DEBUG 'inherit_template_properties: Create index: %', v_sql;\n             EXECUTE v_sql;\n \n         END IF;\n@@ -176,7 +177,7 @@ IF current_setting('server_version_num')::int >= 100000 AND current_setting('ser\n             AND contype = 'f'\n         LOOP\n             v_sql := format('ALTER TABLE %I.%I ADD %s', v_child_schema, v_child_tablename, v_fk_list.constraint_def);\n-            RAISE DEBUG 'Create FK: %', v_sql;\n+            RAISE DEBUG 'inherit_template_properties: Create FK: %', v_sql;\n             EXECUTE v_sql;\n         END LOOP;\n     END IF;\n@@ -186,7 +187,7 @@ END IF;\n -- Tablespace inheritance on PG11 and earlier\n IF current_setting('server_version_num')::int < 120000 AND v_template_tablespace IS NOT NULL THEN\n     v_sql := format('ALTER TABLE %I.%I SET TABLESPACE %I', v_child_schema, v_child_tablename, v_template_tablespace);\n-    RAISE DEBUG 'Alter tablespace: %', v_sql;\n+    RAISE DEBUG 'inherit_template_properties: Alter tablespace: %', v_sql;\n     EXECUTE v_sql;\n END IF;\n \n@@ -206,14 +207,27 @@ AND c.relname = v_child_tablename::name;\n \n IF v_template_unlogged = 'u' AND v_child_unlogged = 'p'  THEN\n     v_sql := format ('ALTER TABLE %I.%I SET UNLOGGED', v_child_schema, v_child_tablename);\n-    RAISE DEBUG 'Alter UNLOGGED: %', v_sql;\n+    RAISE DEBUG 'inherit_template_properties: Alter UNLOGGED: %', v_sql;\n     EXECUTE v_sql;     \n ELSIF v_template_unlogged = 'p' AND v_child_unlogged = 'u'  THEN\n     v_sql := format ('ALTER TABLE %I.%I SET LOGGED', v_child_schema, v_child_tablename);\n-    RAISE DEBUG 'Alter UNLOGGED: %', v_sql;\n+    RAISE DEBUG 'inherit_template_properties: Alter UNLOGGED: %', v_sql;\n     EXECUTE v_sql;     \n END IF;\n \n+-- Relation options are not being inherited for PG <= 13\n+FOR v_relopt IN\n+    SELECT unnest(reloptions) as value\n+    FROM pg_catalog.pg_class\n+    WHERE oid = v_template_oid\n+LOOP\n+    v_sql := format('ALTER TABLE %I.%I SET (%s)'\n+                    , v_child_schema\n+                    , v_child_tablename\n+                    , v_relopt.value);\n+    RAISE DEBUG 'inherit_template_properties: Set relopts: %', v_sql;\n+    EXECUTE v_sql;\n+END LOOP;\n RETURN true;\n \n END"
        },
        {
          "filename": "sql/tables/tables.sql",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -142,6 +142,7 @@ CHECK (@extschema@.check_automatic_maintenance_value(sub_automatic_maintenance))\n  */\n CREATE FUNCTION @extschema@.check_epoch_type (p_type text) RETURNS boolean\n     LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER\n+    SET search_path TO pg_catalog, pg_temp\n     AS $$\n DECLARE\n v_result    boolean;\n@@ -165,6 +166,7 @@ CHECK (@extschema@.check_epoch_type(sub_epoch));\n  */\n CREATE OR REPLACE FUNCTION @extschema@.check_partition_type (p_type text) RETURNS boolean\n     LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER\n+    SET search_path TO pg_catalog, pg_temp\n     AS $$\n DECLARE\n v_result    boolean;\n@@ -174,6 +176,7 @@ BEGIN\n END\n $$;\n \n+\n ALTER TABLE @extschema@.part_config\n ADD CONSTRAINT part_config_type_check \n CHECK (@extschema@.check_partition_type(partition_type));"
        },
        {
          "filename": "test/test_native/generated_col/test-time-daily-generated.sql",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,6 +1,6 @@\n -- ########## TIME DAILY TESTS ##########\n -- Other tests: \n-    -- Test using default template table. Initial child tables will have no indexes. New tables after template has indexes added should.\n+    -- Test generated always columns\n \n \\set ON_ERROR_ROLLBACK 1\n \\set ON_ERROR_STOP true"
        },
        {
          "filename": "test/test_native/test-time-epoch-id-subpart-native.sql",
          "status": "added",
          "additions": 778,
          "deletions": 0,
          "patch": "@@ -0,0 +1,778 @@\n+-- ########## TIME PARENT / ID SUBPARENT NATIVE TESTS ##########\n+-- Leaving pk/fk test out of this one so it can be used to test the native support in 11+\n+\n+\\set ON_ERROR_ROLLBACK 1\n+\\set ON_ERROR_STOP true\n+\n+BEGIN;\n+SELECT set_config('search_path','partman, public',false);\n+\n+SELECT plan(306);\n+CREATE SCHEMA partman_test;\n+\n+-- Add back primary key when native supports it\n+--CREATE TABLE partman_test.time_taptest_table (col1 int primary key, col2 text, col3 timestamptz NOT NULL DEFAULT now());\n+CREATE TABLE partman_test.time_taptest_table (\n+    col1 int \n+    , col2 text\n+    , col3 int NOT NULL DEFAULT extract('epoch' from CURRENT_TIMESTAMP)::int) \n+    PARTITION BY RANGE (col3);\n+CREATE TABLE partman_test.undo_taptest (LIKE partman_test.time_taptest_table INCLUDING ALL);\n+\n+SELECT create_parent('partman_test.time_taptest_table', 'col3', 'native', 'daily', p_epoch := 'seconds');\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(1,10), extract('epoch' from CURRENT_TIMESTAMP)::int);\n+\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'), 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||' exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||' exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||' exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||' exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||' exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||' does not exist');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||' exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||' exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||' exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||' exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'5 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'5 days'::interval, 'YYYY_MM_DD')||' does not exist');\n+\n+-- Restore back when native supports primary key\n+--SELECT col_is_pk('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'), ARRAY['col1'], \n+--    'Check for primary key in time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'));\n+--SELECT col_is_pk('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD'), ARRAY['col1'], \n+--    'Check for primary key in time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD'));\n+--SELECT col_is_pk('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD'), ARRAY['col1'], \n+--    'Check for primary key in time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD'));\n+--SELECT col_is_pk('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD'), ARRAY['col1'], \n+--    'Check for primary key in time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD'));\n+--SELECT col_is_pk('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD'), ARRAY['col1'], \n+--    'Check for primary key in time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD'));\n+--SELECT col_is_pk('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'), ARRAY['col1'], \n+--    'Check for primary key in time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'));\n+--SELECT col_is_pk('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD'), ARRAY['col1'], \n+--    'Check for primary key in time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD'));\n+--SELECT col_is_pk('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD'), ARRAY['col1'], \n+--    'Check for primary key in time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD'));\n+--SELECT col_is_pk('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD'), ARRAY['col1'], \n+--    'Check for primary key in time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD'));\n+--SELECT col_is_pk('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD'), ARRAY['col1'], \n+--    'Check for primary key in time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD'));\n+\n+SELECT is_empty('SELECT * FROM ONLY partman_test.time_taptest_table', 'Check that parent table has had data moved to partition');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table', ARRAY[10], 'Check count from parent table');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'), \n+    ARRAY[10], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'));\n+\n+-- Create subpartition \n+SELECT partman.create_sub_parent('partman_test.time_taptest_table', 'col1', 'native', '20', p_native_check := 'yes');\n+--Reinsert data due to child table destruction\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(1,10), extract('epoch' from CURRENT_TIMESTAMP)::int);\n+\n+SELECT is_empty('SELECT * FROM ONLY partman_test.time_taptest_table', 'Check that parent table has had no data inserted to it');\n+SELECT is_empty('SELECT * FROM ONLY partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'), \n+    'Check that subparent table has had no data inserted to it');\n+SELECT results_eq('SELECT count(*)::int FROM ONLY partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p0', ARRAY[10], \n+    'Check count from partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p0');\n+\n+SELECT is_partitioned('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'), 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||' is natively partitioned');\n+SELECT is_partitioned('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||' is natively partitioned');\n+SELECT is_partitioned('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||' is natively partitioned');\n+SELECT is_partitioned('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||' is natively partitioned');\n+SELECT is_partitioned('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||' is natively partitioned');\n+SELECT isnt_partitioned('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||' is not natively partitioned');\n+SELECT is_partitioned('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||' is natively partitioned');\n+SELECT is_partitioned('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||' is natively partitioned');\n+SELECT is_partitioned('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||' is natively partitioned');\n+SELECT is_partitioned('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||' is natively partitioned');\n+SELECT isnt_partitioned('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'5 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'5 days'::interval, 'YYYY_MM_DD')||' is not natively partitioned');\n+\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p0', 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p20', 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p40', 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p60', 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p80', 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p100', 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p100 does not exist');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p100 does not exist');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p0 does not exist');\n+\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p100 does not exist');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'5 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'5 days'::interval, 'YYYY_MM_DD')||'_p0 does not exist');\n+\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(11,35), extract('epoch' from CURRENT_TIMESTAMP)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(1,35), extract('epoch' from CURRENT_TIMESTAMP + '1 day'::interval)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(1,35), extract('epoch' from CURRENT_TIMESTAMP + '2 days'::interval)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(1,35), extract('epoch' from CURRENT_TIMESTAMP + '3 days'::interval)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(1,35), extract('epoch' from CURRENT_TIMESTAMP + '4 days'::interval)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(1,35), extract('epoch' from CURRENT_TIMESTAMP - '1 day'::interval)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(1,35), extract('epoch' from CURRENT_TIMESTAMP - '2 days'::interval)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(1,35), extract('epoch' from CURRENT_TIMESTAMP - '3 days'::interval)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(1,35), extract('epoch' from CURRENT_TIMESTAMP - '4 days'::interval)::int);\n+\n+SELECT run_maintenance();\n+\n+-- Check row counts from all levels\n+SELECT is_empty('SELECT * FROM ONLY partman_test.time_taptest_table', 'Check that parent table has no data');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table', ARRAY[315], 'Check count from parent table');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'), \n+    ARRAY[35], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD'), \n+    ARRAY[35], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD'), \n+    ARRAY[35], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD'), \n+    ARRAY[35], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD'), \n+    ARRAY[35], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD'), \n+    ARRAY[35], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD'), \n+    ARRAY[35], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD'), \n+    ARRAY[35], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD'), \n+    ARRAY[35], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[16], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[16], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[16], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[16], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[16], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[16], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[16], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[16], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[16], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p20');\n+\n+-- Check that new serial child partition was created for each time sub-parent\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p100', 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p100 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p100 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p100 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p100 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p100 exists');\n+UPDATE part_config SET premake = 5, optimize_trigger = 5 WHERE parent_table = 'partman_test.time_taptest_table';\n+\n+SELECT run_maintenance();\n+\n+-- Check for +5,+6,+7,+8,+9 days (since +4 days data exists) new subparent & children. Should only have 0,20,40,60,80 because subparent is empty and starting from zero\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p100 does not exist');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'6 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'6 days'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'6 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'6 days'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'6 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'6 days'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'6 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'6 days'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'6 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'6 days'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'6 days'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'6 days'::interval, 'YYYY_MM_DD')||'_p100 does not exist');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'7 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'7 days'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'7 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'7 days'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'7 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'7 days'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'7 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'7 days'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'7 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'7 days'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'7 days'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'7 days'::interval, 'YYYY_MM_DD')||'_p100 does not exist');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'8 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'8 days'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'8 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'8 days'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'8 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'8 days'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'8 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'8 days'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'8 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'8 days'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'8 days'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'8 days'::interval, 'YYYY_MM_DD')||'_p100 does not exist');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'9 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'9 days'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'9 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'9 days'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'9 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'9 days'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'9 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'9 days'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'9 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'9 days'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'9 days'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'9 days'::interval, 'YYYY_MM_DD')||'_p100 does not exist');\n+\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'10 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'10 days'::interval, 'YYYY_MM_DD')||'_p0 does not exist');\n+\n+\n+-- insert batch 2\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(36,50), extract('epoch' from CURRENT_TIMESTAMP)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(36,50), extract('epoch' from CURRENT_TIMESTAMP + '1 day'::interval)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(36,50), extract('epoch' from CURRENT_TIMESTAMP + '2 days'::interval)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(36,50), extract('epoch' from CURRENT_TIMESTAMP + '3 days'::interval)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(36,50), extract('epoch' from CURRENT_TIMESTAMP + '4 days'::interval)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(1,50), extract('epoch' from CURRENT_TIMESTAMP + '5 days'::interval)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(36,50), extract('epoch' from CURRENT_TIMESTAMP - '1 day'::interval)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(36,50), extract('epoch' from CURRENT_TIMESTAMP - '2 days'::interval)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(36,50), extract('epoch' from CURRENT_TIMESTAMP - '3 days'::interval)::int);\n+INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(36,50), extract('epoch' from CURRENT_TIMESTAMP - '4 days'::interval)::int);\n+SELECT run_maintenance();\n+\n+-- All sub partition sets should be the same now\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p100 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p120', 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p120 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p120', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p120 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p120', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p120 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p120', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p120 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p120', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p120 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p120', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p120 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p120', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p120 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p120', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p120 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p120', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p120 exists');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p120', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p120 exists');\n+\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p140', 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p140 does not exist');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p140', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p140 does not exist');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p140', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p140 does not exist');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p140', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p140 does not exist');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p140', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p140 does not exist');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p140', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p140 does not exist');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p140', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p140 does not exist');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p140', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p140 does not exist');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p140', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p140 does not exist');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p140', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p140 does not exist');\n+\n+-- Check row counts from all levels\n+SELECT is_empty('SELECT * FROM ONLY partman_test.time_taptest_table', 'Check that parent table has no data');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table', ARRAY[500], 'Check count from parent table');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'), \n+    ARRAY[50], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD'), \n+    ARRAY[50], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD'), \n+    ARRAY[50], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD'), \n+    ARRAY[50], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD'), \n+    ARRAY[50], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD'), \n+    ARRAY[50], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD'), \n+    ARRAY[50], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD'), \n+    ARRAY[50], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD'), \n+    ARRAY[50], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD'), \n+    ARRAY[50], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD'));\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[20], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p40', \n+    ARRAY[11], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p40');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[20], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p40', \n+    ARRAY[11], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p40');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[20], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    ARRAY[11], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p40');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[20], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    ARRAY[11], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p40');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[20], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    ARRAY[11], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p40');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[20], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    ARRAY[11], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p40');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[20], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p40', \n+    ARRAY[11], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p40');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[20], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    ARRAY[11], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p40');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[20], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    ARRAY[11], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p40');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    ARRAY[19], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p0');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    ARRAY[20], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p20');\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    ARRAY[11], 'Check count from time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p40');\n+\n+-- Insert data outside of id subpartition scope, but still in top time partition scope\n+-- Re-add this when default partition is supported\n+--INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(200,210), CURRENT_TIMESTAMP);\n+--INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(200,210), CURRENT_TIMESTAMP + '1 day'::interval);\n+--INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(200,210), CURRENT_TIMESTAMP + '2 days'::interval);\n+--INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(200,210), CURRENT_TIMESTAMP + '3 days'::interval);\n+--INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(200,210), CURRENT_TIMESTAMP + '4 days'::interval);\n+--INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(200,210), CURRENT_TIMESTAMP + '5 days'::interval);\n+--INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(200,210), CURRENT_TIMESTAMP - '1 day'::interval);\n+--INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(200,210), CURRENT_TIMESTAMP - '2 days'::interval);\n+--INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(200,210), CURRENT_TIMESTAMP - '3 days'::interval);\n+--INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(200,210), CURRENT_TIMESTAMP - '4 days'::interval);\n+--SELECT is_empty('SELECT * FROM ONLY partman_test.time_taptest_table', 'Check that top parent table has no data even tho sub-parents should now have some.');\n+--SELECT results_eq('SELECT count(*)::int FROM ONLY partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'), \n+--    ARRAY[11], 'Check count from ONLY time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'));\n+--SELECT results_eq('SELECT count(*)::int FROM ONLY partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD'), \n+--    ARRAY[11], 'Check count from ONLY time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||' (out of scope test)');\n+--SELECT results_eq('SELECT count(*)::int FROM ONLY partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD'), \n+--    ARRAY[11], 'Check count from ONLY time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||' (out of scope test)');\n+--SELECT results_eq('SELECT count(*)::int FROM ONLY partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD'), \n+--    ARRAY[11], 'Check count from ONLY time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||' (out of scope test)');\n+--SELECT results_eq('SELECT count(*)::int FROM ONLY partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD'), \n+--    ARRAY[11], 'Check count from ONLY time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||' (out of scope test)');\n+--SELECT results_eq('SELECT count(*)::int FROM ONLY partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD'), \n+--    ARRAY[11], 'Check count from ONLY time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||' (out of scope test)');\n+--SELECT results_eq('SELECT count(*)::int FROM ONLY partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD'), \n+--    ARRAY[11], 'Check count from ONLY time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||' (out of scope test)');\n+--SELECT results_eq('SELECT count(*)::int FROM ONLY partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD'), \n+--    ARRAY[11], 'Check count from ONLY time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||' (out of scope test)');\n+--SELECT results_eq('SELECT count(*)::int FROM ONLY partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD'), \n+--    ARRAY[11], 'Check count from ONLY time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||' (out of scope test)');\n+--SELECT results_eq('SELECT count(*)::int FROM ONLY partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD'), \n+--    ARRAY[11], 'Check count from ONLY time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||' (out of scope test)');\n+\n+-- Insert data outside top time partition scope\n+--INSERT INTO partman_test.time_taptest_table (col1, col3) VALUES (generate_series(211,220), CURRENT_TIMESTAMP - '20 days'::interval);\n+--SELECT results_eq('SELECT count(*)::int FROM ONLY partman_test.time_taptest_table', ARRAY[10], 'Check count from ONLY time_taptest_table (out of scope test)');\n+-- Remove above data so that retention can be tested\n+--DELETE FROM partman_test.time_taptest_table WHERE col1 >= 200 and col1 <= 220;\n+\n+-- END section for testing default partition\n+\n+-- Test dropping without retention set\n+SELECT drop_partition_id ('partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'), '20', p_keep_table := false);\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p0', 'Check that partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p0 was dropped with direct drop call');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p20', 'Check that partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p20 was not dropped with direct drop call');\n+\n+UPDATE part_config SET retention = '2 days', retention_keep_table = false WHERE parent_table = 'partman_test.time_taptest_table';\n+UPDATE part_config SET retention = '25', retention_keep_table = false WHERE parent_table = 'partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD');\n+UPDATE part_config SET retention = '25', retention_keep_table = false WHERE parent_table = 'partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD');\n+UPDATE part_config SET retention = '25', retention_keep_table = false WHERE parent_table = 'partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD');\n+UPDATE part_config SET retention = '25', retention_keep_table = false WHERE parent_table = 'partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD');\n+UPDATE part_config SET retention = '25', retention_keep_table = false WHERE parent_table = 'partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD');\n+UPDATE part_config SET retention = '25', retention_keep_table = false WHERE parent_table = 'partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 days'::interval, 'YYYY_MM_DD');\n+UPDATE part_config SET retention = '25', retention_keep_table = false WHERE parent_table = 'partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD');\n+UPDATE part_config SET retention = '25', retention_keep_table = false WHERE parent_table = 'partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD');\n+UPDATE part_config SET retention = '25', retention_keep_table = false WHERE parent_table = 'partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD');\n+\n+-- Test dropping with it set\n+SELECT drop_partition_id ('partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD'), p_keep_table := false);\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p0', 'Check that partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p0 was dropped with direct drop call');\n+SELECT has_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p20', 'Check that partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p20 was not dropped with direct drop call');\n+\n+-- Test retention with run_maintenance()\n+SELECT run_maintenance();\n+\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||' was dropped');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p0 was dropped');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p20 was dropped');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p40 was dropped');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p60 was dropped');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p80 was dropped');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p100 was dropped');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p120', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p120 was dropped');\n+\n+SELECT is_empty('SELECT parent_table FROM part_config WHERE parent_table = ''time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'''',\n+        'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||' was removed from part_config');\n+SELECT is_empty('SELECT parent_table FROM part_config WHERE parent_table = ''time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p0''',\n+        'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p0 was removed from part_config');\n+SELECT is_empty('SELECT parent_table FROM part_config WHERE parent_table = ''time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p20''',\n+        'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p20 was removed from part_config');\n+SELECT is_empty('SELECT parent_table FROM part_config WHERE parent_table = ''time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p40''',\n+        'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p40 was removed from part_config');\n+SELECT is_empty('SELECT parent_table FROM part_config WHERE parent_table = ''time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p60''',\n+        'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p60 was removed from part_config');\n+SELECT is_empty('SELECT parent_table FROM part_config WHERE parent_table = ''time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p80''',\n+        'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p80 was removed from part_config');\n+SELECT is_empty('SELECT parent_table FROM part_config WHERE parent_table = ''time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p100''',\n+        'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p100 was removed from part_config');\n+SELECT is_empty('SELECT parent_table FROM part_config WHERE parent_table = ''time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p120''',\n+        'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'3 days'::interval, 'YYYY_MM_DD')||'_p120 was removed from part_config');\n+\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD'), \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||' was dropped');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p0 was dropped');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p20 was dropped');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p40 was dropped');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p60 was dropped');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p80 was dropped');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p100 was dropped');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p120', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p120 was dropped');\n+\n+\n+SELECT is_empty('SELECT parent_table FROM part_config WHERE parent_table = ''time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'''',\n+        'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||' was removed from part_config');\n+SELECT is_empty('SELECT parent_table FROM part_config WHERE parent_table = ''time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p0''',\n+        'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p0 was removed from part_config');\n+SELECT is_empty('SELECT parent_table FROM part_config WHERE parent_table = ''time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p20''',\n+        'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p20 was removed from part_config');\n+SELECT is_empty('SELECT parent_table FROM part_config WHERE parent_table = ''time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p40''',\n+        'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p40 was removed from part_config');\n+SELECT is_empty('SELECT parent_table FROM part_config WHERE parent_table = ''time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p60''',\n+        'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p60 was removed from part_config');\n+SELECT is_empty('SELECT parent_table FROM part_config WHERE parent_table = ''time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p80''',\n+        'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p80 was removed from part_config');\n+SELECT is_empty('SELECT parent_table FROM part_config WHERE parent_table = ''time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p100''',\n+        'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p100 was removed from part_config');\n+SELECT is_empty('SELECT parent_table FROM part_config WHERE parent_table = ''time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p120''',\n+        'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'4 days'::interval, 'YYYY_MM_DD')||'_p120 was removed from part_config');\n+\n+-- First undo all subpartitions\n+SELECT undo_partition('partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD'), 20, p_target_table := 'partman_test.undo_taptest', p_keep_table := false);\n+SELECT undo_partition('partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD'), 20, p_target_table := 'partman_test.undo_taptest', p_keep_table := false);\n+SELECT undo_partition('partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD'), 20, p_target_table := 'partman_test.undo_taptest', p_keep_table := false);\n+SELECT undo_partition('partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD'), 20, p_target_table := 'partman_test.undo_taptest', p_keep_table := false);\n+SELECT undo_partition('partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD'), 20, p_target_table := 'partman_test.undo_taptest', p_keep_table := false);\n+SELECT undo_partition('partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD'), 20, p_target_table := 'partman_test.undo_taptest', p_keep_table := false);\n+SELECT undo_partition('partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'6 days'::interval, 'YYYY_MM_DD'), 20, p_target_table := 'partman_test.undo_taptest', p_keep_table := false);\n+SELECT undo_partition('partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'7 days'::interval, 'YYYY_MM_DD'), 20, p_target_table := 'partman_test.undo_taptest', p_keep_table := false);\n+SELECT undo_partition('partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'8 days'::interval, 'YYYY_MM_DD'), 20, p_target_table := 'partman_test.undo_taptest', p_keep_table := false);\n+SELECT undo_partition('partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'9 days'::interval, 'YYYY_MM_DD'), 20, p_target_table := 'partman_test.undo_taptest', p_keep_table := false);\n+SELECT undo_partition('partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD'), 20, p_target_table := 'partman_test.undo_taptest', p_keep_table := false);\n+SELECT undo_partition('partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD'), 20, p_target_table := 'partman_test.undo_taptest', p_keep_table := false);\n+\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p0', 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p20', 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p40', 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p60', 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p80', 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p100', 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p100 does not exist');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'_p100 does not exist');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p100 does not exist');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p0 does not exist');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p0', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p0 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p20', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p20 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p40', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p40 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p60', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p60 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p80', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p80 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'_p100 does not exist');\n+\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p100', 'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'_p100 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'_p100 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'_p100 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'_p100 exists');\n+SELECT hasnt_table('partman_test', 'time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p100', \n+    'Check time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'_p100 exists');\n+\n+SELECT is_empty('SELECT parent_table from part_config where parent_table = ''partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||'''', \n+    'Check that partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP, 'YYYY_MM_DD')||' was removed from part_config');\n+SELECT is_empty('SELECT parent_table from part_config where parent_table = ''partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||'''', \n+    'Check that partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD')||' was removed from part_config');\n+SELECT is_empty('SELECT parent_table from part_config where parent_table = ''partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||'''', \n+    'Check that partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD')||' was removed from part_config');\n+SELECT is_empty('SELECT parent_table from part_config where parent_table = ''partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||'''', \n+    'Check that partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD')||' was removed from part_config');\n+SELECT is_empty('SELECT parent_table from part_config where parent_table = ''partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||'''', \n+    'Check that partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD')||' was removed from part_config');\n+SELECT is_empty('SELECT parent_table from part_config where parent_table = ''partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||'''', \n+    'Check that partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD')||' was removed from part_config');\n+SELECT is_empty('SELECT parent_table from part_config where parent_table = ''partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'6 days'::interval, 'YYYY_MM_DD')||'''', \n+    'Check that partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'6 days'::interval, 'YYYY_MM_DD')||' was removed from part_config');\n+SELECT is_empty('SELECT parent_table from part_config where parent_table = ''partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'7 days'::interval, 'YYYY_MM_DD')||'''', \n+    'Check that partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'7 days'::interval, 'YYYY_MM_DD')||' was removed from part_config');\n+SELECT is_empty('SELECT parent_table from part_config where parent_table = ''partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'8 days'::interval, 'YYYY_MM_DD')||'''', \n+    'Check that partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'8 days'::interval, 'YYYY_MM_DD')||' was removed from part_config');\n+SELECT is_empty('SELECT parent_table from part_config where parent_table = ''partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'9 days'::interval, 'YYYY_MM_DD')||'''', \n+    'Check that partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'9 days'::interval, 'YYYY_MM_DD')||' was removed from part_config');\n+SELECT is_empty('SELECT parent_table from part_config where parent_table = ''partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||'''', \n+    'Check that partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD')||' was removed from part_config');\n+SELECT is_empty('SELECT parent_table from part_config where parent_table = ''partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||'''', \n+    'Check that partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD')||' was removed from part_config');\n+\n+SELECT results_eq('SELECT count(*)::int FROM ONLY partman_test.time_taptest_table', ARRAY[0], 'Check that top parent is still empty');\n+-- Rows are missing data for col1 values 1-19 due to retention drop above\n+-- REDO this when default is supported to move data there\n+--SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD'), ARRAY[31], 'Check data got move to partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'1 day'::interval, 'YYYY_MM_DD') );\n+--SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD'), ARRAY[31], 'Check data got move to partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'2 days'::interval, 'YYYY_MM_DD') );\n+--SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD'), ARRAY[31], 'Check data got move to partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'3 days'::interval, 'YYYY_MM_DD') );\n+--SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD'), ARRAY[31], 'Check data got move to partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'4 days'::interval, 'YYYY_MM_DD') );\n+--SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD'), ARRAY[31], 'Check data got move to partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP+'5 days'::interval, 'YYYY_MM_DD') );\n+--SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD'), ARRAY[31], 'Check data got move to partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'1 day'::interval, 'YYYY_MM_DD') );\n+--SELECT results_eq('SELECT count(*)::int FROM partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD'), ARRAY[31], 'Check data got move to partman_test.time_taptest_table_p'||to_char(CURRENT_TIMESTAMP-'2 days'::interval, 'YYYY_MM_DD') );\n+\n+SELECT results_eq('SELECT count(*)::int FROM partman_test.undo_taptest', ARRAY[248], 'Check count from target of undo_partition');\n+\n+--Unable to undo_partition any further because col1 is duplicated in child tables, but parent key has it as a primary key. So done testing! :D\n+\n+SELECT * FROM finish();\n+ROLLBACK;"
        },
        {
          "filename": "updates/pg_partman--4.5.0--4.5.1.sql",
          "status": "added",
          "additions": 1375,
          "deletions": 0,
          "patch": "@@ -0,0 +1,1375 @@\n+-- Allow relation options set on the template table to be inherited on the child table. As of PG13 and earlier, relation options set on the parent are not being set on the child tables. Unknown if PG14 will handle this yet or not (Github PR #348).\n+-- Fixed security issue that could allow arbitrary code execution using SECURITY DEFINER functions. Set explicit search_path to avoid this. Thanks to Github user @tapioaiven of Aiven Ltd for reporting the issue.\n+-- Fixed several bugs in sub-partitioning when using a mixture of epoch and regular integer partitioning in the same partition set (Github Issue #357).\n+\n+\n+CREATE OR REPLACE FUNCTION @extschema@.inherit_template_properties (p_parent_table text, p_child_schema text, p_child_tablename text) RETURNS boolean\n+    LANGUAGE plpgsql \n+    AS $$\n+DECLARE\n+\n+v_child_relkind         char;\n+v_child_schema          text;\n+v_child_tablename       text;\n+v_child_unlogged        char;\n+v_dupe_found            boolean := false;\n+v_fk_list               record;\n+v_index_list            record;\n+v_inherit_fk            boolean;\n+v_parent_index_list     record;\n+v_parent_oid            oid;\n+v_parent_table          text;\n+v_relopt                record;\n+v_sql                   text;\n+v_template_oid          oid;\n+v_template_schemaname   text;\n+v_template_table        text;\n+v_template_tablename    name;\n+v_template_tablespace   name;\n+v_template_unlogged     char;\n+\n+BEGIN\n+/*\n+ * Function to inherit the properties of the template table to newly created child tables.\n+ * Currently used for PostgreSQL 10 to inherit indexes and FKs since that is not natively available\n+ * For PG11, used to inherit non-partition-key unique indexes & primary keys\n+ */\n+\n+SELECT parent_table, template_table, inherit_fk\n+INTO v_parent_table, v_template_table, v_inherit_fk\n+FROM @extschema@.part_config\n+WHERE parent_table = p_parent_table;\n+IF v_parent_table IS NULL THEN\n+    RAISE EXCEPTION 'Given parent table has no configuration in pg_partman: %', p_parent_table;\n+ELSIF v_template_table IS NULL THEN\n+    RAISE EXCEPTION 'No template table set in configuration for given parent table: %', p_parent_table;\n+END IF;\n+\n+SELECT c.oid INTO v_parent_oid\n+FROM pg_catalog.pg_class c\n+JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid\n+WHERE n.nspname = split_part(p_parent_table, '.', 1)::name\n+AND c.relname = split_part(p_parent_table, '.', 2)::name;\n+    IF v_parent_oid IS NULL THEN\n+        RAISE EXCEPTION 'Unable to find given parent table in system catalogs: %', p_parent_table;\n+    END IF;\n+ \n+SELECT n.nspname, c.relname, c.relkind INTO v_child_schema, v_child_tablename, v_child_relkind\n+FROM pg_catalog.pg_class c\n+JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid\n+WHERE n.nspname = p_child_schema::name\n+AND c.relname = p_child_tablename::name;\n+    IF v_child_tablename IS NULL THEN\n+        RAISE EXCEPTION 'Unable to find given child table in system catalogs: %.%', v_child_schema, v_child_tablename;\n+    END IF;\n+       \n+IF v_child_relkind = 'p' THEN\n+    -- Subpartitioned parent, do not apply properties\n+    RAISE DEBUG 'inherit_template_properties: found given child is subpartition parent, so properties not inherited';\n+    RETURN false;\n+END IF;\n+\n+v_template_schemaname := split_part(v_template_table, '.', 1)::name;\n+v_template_tablename :=  split_part(v_template_table, '.', 2)::name;\n+\n+SELECT c.oid, ts.spcname INTO v_template_oid, v_template_tablespace\n+FROM pg_catalog.pg_class c\n+JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid\n+LEFT OUTER JOIN pg_catalog.pg_tablespace ts ON c.reltablespace = ts.oid\n+WHERE n.nspname = v_template_schemaname\n+AND c.relname = v_template_tablename;\n+    IF v_template_oid IS NULL THEN\n+        RAISE EXCEPTION 'Unable to find configured template table in system catalogs: %', v_template_table;\n+    END IF;\n+\n+-- Index creation (Required for all indexes in PG10. Only for non-unique, non-partition key indexes in PG11)\n+IF current_setting('server_version_num')::int >= 100000 THEN\n+    FOR v_index_list IN \n+        SELECT\n+        array_to_string(regexp_matches(pg_get_indexdef(indexrelid), ' USING .*'),',') AS statement\n+        , i.indisprimary\n+        , i.indisunique\n+        , ( SELECT array_agg( a.attname ORDER by x.r )\n+            FROM pg_catalog.pg_attribute a\n+            JOIN ( SELECT k, row_number() over () as r\n+                    FROM unnest(i.indkey) k ) as x\n+            ON a.attnum = x.k AND a.attrelid = i.indrelid\n+        ) AS indkey_names\n+        , c.relname AS index_name\n+        , ts.spcname AS tablespace_name\n+        FROM pg_catalog.pg_index i\n+        JOIN pg_catalog.pg_class c ON i.indexrelid = c.oid\n+        LEFT OUTER JOIN pg_catalog.pg_tablespace ts ON c.reltablespace = ts.oid\n+        WHERE i.indrelid = v_template_oid\n+        AND i.indisvalid\n+        ORDER BY 1\n+    LOOP\n+        v_dupe_found := false;\n+\n+        IF current_setting('server_version_num')::int >= 110000 THEN\n+            FOR v_parent_index_list IN \n+                SELECT\n+                array_to_string(regexp_matches(pg_get_indexdef(indexrelid), ' USING .*'),',') AS statement\n+                , i.indisprimary\n+                , ( SELECT array_agg( a.attname ORDER by x.r )\n+                    FROM pg_catalog.pg_attribute a\n+                    JOIN ( SELECT k, row_number() over () as r\n+                            FROM unnest(i.indkey) k ) as x\n+                    ON a.attnum = x.k AND a.attrelid = i.indrelid\n+                ) AS indkey_names\n+                FROM pg_catalog.pg_index i\n+                WHERE i.indrelid = v_parent_oid\n+                AND i.indisvalid\n+                ORDER BY 1\n+            LOOP\n+\n+                IF v_parent_index_list.indisprimary AND v_index_list.indisprimary THEN\n+                    IF v_parent_index_list.indkey_names = v_index_list.indkey_names THEN\n+                        RAISE DEBUG 'inherit_template_properties: Ignoring duplicate primary key on template table: % ', v_index_list.indkey_names;\n+                        v_dupe_found := true;\n+                        CONTINUE; -- only continue within this nested loop\n+                    END IF;\n+                END IF;\n+\n+                IF v_parent_index_list.statement = v_index_list.statement THEN\n+                    RAISE DEBUG 'inherit_template_properties: Ignoring duplicate index on template table: %', v_index_list.statement;\n+                    v_dupe_found := true;\n+                    CONTINUE; -- only continue within this nested loop\n+                END IF;\n+\n+            END LOOP; -- end parent index loop\n+        END IF; -- End PG11 check\n+\n+        IF v_dupe_found = true THEN\n+            -- Only used in PG11 and should skip trying to create indexes that already existed on the parent\n+            CONTINUE;\n+        END IF;\n+\n+        IF v_index_list.indisprimary THEN\n+            v_sql := format('ALTER TABLE %I.%I ADD PRIMARY KEY (%s)'\n+                            , v_child_schema\n+                            , v_child_tablename\n+                            , '\"' || array_to_string(v_index_list.indkey_names, '\",\"') || '\"');\n+            IF v_index_list.tablespace_name IS NOT NULL THEN\n+                v_sql := v_sql || format(' USING INDEX TABLESPACE %I', v_index_list.tablespace_name);\n+            END IF;\n+            RAISE DEBUG 'inherit_template_properties: Create pk: %', v_sql;\n+            EXECUTE v_sql;\n+        ELSE\n+            -- statement column should be just the portion of the index definition that defines what it actually is\n+            v_sql := format('CREATE %s INDEX ON %I.%I %s', CASE WHEN v_index_list.indisunique = TRUE THEN 'UNIQUE' ELSE '' END, v_child_schema, v_child_tablename, v_index_list.statement);\n+            IF v_index_list.tablespace_name IS NOT NULL THEN\n+                v_sql := v_sql || format(' TABLESPACE %I', v_index_list.tablespace_name);\n+            END IF;\n+\n+            RAISE DEBUG 'inherit_template_properties: Create index: %', v_sql;\n+            EXECUTE v_sql;\n+\n+        END IF;\n+\n+    END LOOP;\n+END IF; \n+-- End index creation\n+\n+-- Foreign key creation (PG10 only)\n+IF current_setting('server_version_num')::int >= 100000 AND current_setting('server_version_num')::int < 110000 THEN\n+    IF v_inherit_fk THEN\n+        FOR v_fk_list IN \n+            SELECT pg_get_constraintdef(con.oid) AS constraint_def\n+            FROM pg_catalog.pg_constraint con\n+            JOIN pg_catalog.pg_class c ON con.conrelid = c.oid\n+            WHERE c.oid = v_template_oid\n+            AND contype = 'f'\n+        LOOP\n+            v_sql := format('ALTER TABLE %I.%I ADD %s', v_child_schema, v_child_tablename, v_fk_list.constraint_def);\n+            RAISE DEBUG 'inherit_template_properties: Create FK: %', v_sql;\n+            EXECUTE v_sql;\n+        END LOOP;\n+    END IF;\n+END IF;\n+-- End foreign key creation\n+\n+-- Tablespace inheritance on PG11 and earlier\n+IF current_setting('server_version_num')::int < 120000 AND v_template_tablespace IS NOT NULL THEN\n+    v_sql := format('ALTER TABLE %I.%I SET TABLESPACE %I', v_child_schema, v_child_tablename, v_template_tablespace);\n+    RAISE DEBUG 'inherit_template_properties: Alter tablespace: %', v_sql;\n+    EXECUTE v_sql;\n+END IF;\n+\n+-- UNLOGGED status. Currently waiting on final stance of how native will handle this property being changed for its children. \n+-- See release notes for v4.2.0\n+SELECT relpersistence INTO v_template_unlogged\n+FROM pg_catalog.pg_class c\n+JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid\n+WHERE n.nspname = v_template_schemaname\n+AND c.relname = v_template_tablename;\n+\n+SELECT relpersistence INTO v_child_unlogged\n+FROM pg_catalog.pg_class c\n+JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid\n+WHERE n.nspname = v_child_schema::name\n+AND c.relname = v_child_tablename::name;\n+\n+IF v_template_unlogged = 'u' AND v_child_unlogged = 'p'  THEN\n+    v_sql := format ('ALTER TABLE %I.%I SET UNLOGGED', v_child_schema, v_child_tablename);\n+    RAISE DEBUG 'inherit_template_properties: Alter UNLOGGED: %', v_sql;\n+    EXECUTE v_sql;     \n+ELSIF v_template_unlogged = 'p' AND v_child_unlogged = 'u'  THEN\n+    v_sql := format ('ALTER TABLE %I.%I SET LOGGED', v_child_schema, v_child_tablename);\n+    RAISE DEBUG 'inherit_template_properties: Alter UNLOGGED: %', v_sql;\n+    EXECUTE v_sql;     \n+END IF;\n+\n+-- Relation options are not being inherited for PG <= 13\n+FOR v_relopt IN\n+    SELECT unnest(reloptions) as value\n+    FROM pg_catalog.pg_class\n+    WHERE oid = v_template_oid\n+LOOP\n+    v_sql := format('ALTER TABLE %I.%I SET (%s)'\n+                    , v_child_schema\n+                    , v_child_tablename\n+                    , v_relopt.value);\n+    RAISE DEBUG 'inherit_template_properties: Set relopts: %', v_sql;\n+    EXECUTE v_sql;\n+END LOOP;\n+RETURN true;\n+\n+END\n+$$;\n+\n+\n+CREATE OR REPLACE FUNCTION @extschema@.check_name_length (p_object_name text, p_suffix text DEFAULT NULL, p_table_partition boolean DEFAULT FALSE) RETURNS text\n+    LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER\n+    SET search_path TO pg_catalog, pg_temp\n+    AS $$\n+DECLARE\n+    v_new_length    int;\n+    v_new_name      text;\n+BEGIN\n+/*\n+ * Truncate the name of the given object if it is greater than the postgres default max (63 characters).\n+ * Also appends given suffix and schema if given and truncates the name so that the entire suffix will fit.\n+ * Returns original name (with suffix if given) if it doesn't require truncation\n+ * Retains SECURITY DEFINER since it is called by trigger functions and did not want to break installations prior to 4.0.0\n+ */\n+\n+IF p_table_partition IS TRUE AND (p_suffix IS NULL) THEN\n+    RAISE EXCEPTION 'Table partition name requires a suffix value';\n+END IF;\n+\n+IF p_table_partition THEN  -- 61 characters to account for _p in partition name\n+    IF char_length(p_object_name) + char_length(p_suffix) >= 61 THEN\n+        v_new_length := 61 - char_length(p_suffix);\n+        v_new_name := substring(p_object_name from 1 for v_new_length) || '_p' || p_suffix; \n+    ELSE\n+        v_new_name := p_object_name||'_p'||p_suffix;\n+    END IF;\n+ELSE\n+    IF char_length(p_object_name) + char_length(COALESCE(p_suffix, '')) >= 63 THEN\n+        v_new_length := 63 - char_length(COALESCE(p_suffix, ''));\n+        v_new_name := substring(p_object_name from 1 for v_new_length) || COALESCE(p_suffix, ''); \n+    ELSE\n+        v_new_name := p_object_name||COALESCE(p_suffix, '');\n+    END IF;\n+END IF;\n+\n+RETURN v_new_name;\n+\n+END\n+$$;\n+\n+\n+CREATE OR REPLACE FUNCTION @extschema@.create_sub_parent(\n+    p_top_parent text\n+    , p_control text\n+    , p_type text\n+    , p_interval text\n+    , p_native_check text DEFAULT NULL\n+    , p_constraint_cols text[] DEFAULT NULL \n+    , p_premake int DEFAULT 4\n+    , p_start_partition text DEFAULT NULL\n+    , p_inherit_fk boolean DEFAULT true\n+    , p_epoch text DEFAULT 'none' \n+    , p_upsert text DEFAULT ''\n+    , p_trigger_return_null boolean DEFAULT true\n+    , p_jobmon boolean DEFAULT true) \n+RETURNS boolean\n+    LANGUAGE plpgsql \n+    AS $$\n+DECLARE\n+\n+v_child_interval        interval;\n+v_child_start_id        bigint;\n+v_child_start_time      timestamptz;\n+v_control               text;\n+v_control_parent_type   text;\n+v_control_sub_type      text;\n+v_last_partition        text;\n+v_new_search_path       text := '@extschema@,pg_temp';\n+v_old_search_path       text;\n+v_parent_epoch          text;\n+v_parent_interval       text;\n+v_parent_relkind        char;\n+v_parent_schema         text;\n+v_parent_tablename      text;\n+v_parent_type           text;\n+v_part_col              text;\n+v_partition_id_array    bigint[];\n+v_partition_time_array  timestamptz[];\n+v_relkind               char;\n+v_recreate_child        boolean := false;\n+v_row                   record;\n+v_row_last_part         record;\n+v_run_maint             boolean;\n+v_sql                   text;\n+v_success               boolean := false;\n+v_template_table        text;\n+v_top_type              text;\n+\n+BEGIN\n+/*\n+ * Create a partition set that is a subpartition of an already existing partition set.\n+ * Given the parent table of any current partition set, it will turn all existing children into parent tables of their own partition sets\n+ *      using the configuration options given as parameters to this function.\n+ * Uses another config table that allows for turning all future child partitions into a new parent automatically.\n+ */\n+\n+SELECT n.nspname, c.relname, c.relkind INTO v_parent_schema, v_parent_tablename, v_parent_relkind\n+FROM pg_catalog.pg_class c\n+JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid\n+WHERE n.nspname = split_part(p_top_parent, '.', 1)::name\n+AND c.relname = split_part(p_top_parent, '.', 2)::name;\n+    IF v_parent_tablename IS NULL THEN\n+        RAISE EXCEPTION 'Unable to find given parent table in system catalogs. Please create parent table first: %', p_top_parent;\n+    END IF;\n+\n+IF NOT @extschema@.check_partition_type(p_type) THEN\n+    RAISE EXCEPTION '% is not a valid partitioning type', p_type;\n+END IF;\n+\n+IF v_parent_relkind = 'p' AND p_type <> 'native' THEN\n+    RAISE EXCEPTION 'Cannot create a non-native sub-partition of a native parent table. All levels of a sub-partition set must be either all native or all non-native';\n+END IF;\n+ \n+SELECT partition_type, partition_interval, control, automatic_maintenance, epoch, template_table\n+INTO v_parent_type, v_parent_interval, v_control, v_run_maint, v_parent_epoch, v_template_table\n+FROM @extschema@.part_config \n+WHERE parent_table = p_top_parent;\n+IF v_parent_type IS NULL THEN\n+    RAISE EXCEPTION 'Cannot subpartition a table that is not managed by pg_partman already. Given top parent table not found in @extschema@.part_config: %', p_top_parent;\n+END IF;\n+\n+IF p_type = 'native' AND (lower(p_native_check) <> 'yes' OR p_native_check IS NULL) THEN\n+    RAISE EXCEPTION 'The sub-partitioning of a natively partitioned table is a DESTRUCTIVE process unless all child tables are already natively subpartitioned. All child tables, and therefore ALL DATA, may be destroyed since the parent table must be declared as partitioned on first creation and cannot be altered later. See docs for more info. Set p_native_check parameter to \"yes\" if you are sure this is ok.';\n+END IF;\n+\n+IF p_upsert <> '' THEN\n+    IF current_setting('server_version_num')::int < 90500 THEN\n+        RAISE EXCEPTION 'INSERT ... ON CONFLICT (UPSERT) feature is only supported in PostgreSQL 9.5 and later';\n+    END IF;\n+    IF p_type = 'native' THEN\n+        RAISE EXCEPTION 'Native partitioning does not currently support upsert. Use pg_partman''s partitioning methods instead if this is required';\n+    END IF;\n+END IF;\n+\n+SELECT general_type INTO v_control_parent_type FROM @extschema@.check_control_type(v_parent_schema, v_parent_tablename, v_control);\n+\n+SELECT current_setting('search_path') INTO v_old_search_path;\n+EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_new_search_path, 'false');\n+\n+-- Add the given parameters to the part_config_sub table first in case create_partition_* functions are called below \n+-- All sub-partition parents must use the same template table for native partitioning, so ensure the one from the given parent is obtained and used.\n+INSERT INTO @extschema@.part_config_sub (\n+    sub_parent\n+    , sub_control\n+    , sub_partition_type\n+    , sub_partition_interval\n+    , sub_constraint_cols\n+    , sub_premake\n+    , sub_inherit_fk\n+    , sub_automatic_maintenance\n+    , sub_epoch\n+    , sub_upsert\n+    , sub_jobmon\n+    , sub_trigger_return_null\n+    , sub_template_table)\n+VALUES (\n+    p_top_parent\n+    , p_control\n+    , p_type\n+    , p_interval\n+    , p_constraint_cols\n+    , p_premake\n+    , p_inherit_fk\n+    , 'on' \n+    , p_epoch\n+    , p_upsert\n+    , p_jobmon\n+    , p_trigger_return_null\n+    , v_template_table);\n+\n+FOR v_row IN \n+    -- Loop through all current children to turn them into partitioned tables\n+    SELECT partition_schemaname AS child_schema, partition_tablename AS child_tablename FROM @extschema@.show_partitions(p_top_parent)\n+LOOP\n+\n+    SELECT general_type INTO v_control_sub_type FROM @extschema@.check_control_type(v_row.child_schema, v_row.child_tablename, p_control);\n+\n+    SELECT c.relkind INTO v_relkind\n+    FROM pg_catalog.pg_class c\n+    JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid\n+    WHERE n.nspname = v_row.child_schema\n+    AND c.relname = v_row.child_tablename;\n+\n+    -- If both parent and sub-parent are the same partition type (time/id), ensure boundaries of sub-parent are within parent\n+    IF (v_control_parent_type = 'time' AND v_control_sub_type = 'time') OR\n+       (v_control_parent_type = 'id' AND v_parent_epoch <> 'none' AND v_control_sub_type = 'id' AND p_epoch <> 'none') THEN\n+        CASE\n+            WHEN p_interval = 'yearly' THEN\n+                v_child_interval := '1 year';\n+            WHEN p_interval = 'quarterly' THEN\n+                v_child_interval := '3 months';\n+            WHEN p_interval = 'monthly' THEN\n+                v_child_interval := '1 month';\n+            WHEN p_interval  = 'weekly' THEN\n+                v_child_interval := '1 week';\n+            WHEN p_interval = 'daily' THEN\n+                v_child_interval := '1 day';\n+            WHEN p_interval = 'hourly' THEN\n+                v_child_interval := '1 hour';\n+            WHEN p_interval = 'half-hour' THEN\n+                v_child_interval := '30 mins';\n+            WHEN p_interval = 'quarter-hour' THEN\n+                v_child_interval := '15 mins';\n+            ELSE\n+                v_child_interval := p_interval::interval;\n+                IF v_child_interval < '1 second'::interval THEN\n+                    RAISE EXCEPTION 'Partitioning interval must be 1 second or greater';\n+                END IF;\n+        END CASE;\n+\n+        IF v_child_interval >= v_parent_interval::interval THEN\n+            EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_old_search_path, 'false');\n+            RAISE EXCEPTION 'Sub-partition interval cannot be greater than or equal to the given parent interval';\n+        END IF;\n+        IF v_child_interval = '1 week' AND v_parent_interval::interval > '1 week'::interval THEN\n+            EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_old_search_path, 'false');\n+            RAISE EXCEPTION 'Due to conflicting data boundaries between ISO weeks and any larger interval of time, pg_partman cannot support a sub-partition interval of weekly';\n+        END IF;\n+\n+    ELSIF v_control_parent_type = 'id' AND v_control_sub_type = 'id' AND v_parent_epoch = 'none' AND p_epoch = 'none' THEN\n+        IF p_interval::bigint >= v_parent_interval::bigint THEN\n+            EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_old_search_path, 'false');\n+            RAISE EXCEPTION 'Sub-partition interval cannot be greater than or equal to the given parent interval';\n+        END IF;\n+    END IF;\n+      \n+    IF p_type = 'native' THEN\n+        IF v_relkind <> 'p' THEN \n+            -- Not natively partitioned already. Drop it and recreate as such.\n+            RAISE WARNING 'Child table % is not natively partitioned. Dropping and recreating with native partitioning'\n+                            , v_row.child_schema||'.'||v_row.child_tablename;\n+            SELECT child_start_time, child_start_id INTO v_child_start_time, v_child_start_id\n+            FROM @extschema@.show_partition_info(v_row.child_schema||'.'||v_row.child_tablename\n+                                                    , v_parent_interval\n+                                                    , p_top_parent);\n+            EXECUTE format('DROP TABLE %I.%I', v_row.child_schema, v_row.child_tablename);\n+            v_recreate_child := true;\n+\n+            IF v_child_start_id IS NOT NULL THEN\n+                v_partition_id_array[0] := v_child_start_id;\n+                PERFORM @extschema@.create_partition_id(p_top_parent, v_partition_id_array, true, p_start_partition);\n+            ELSIF v_child_start_time IS NOT NULL THEN\n+                v_partition_time_array[0] := v_child_start_time;\n+                PERFORM @extschema@.create_partition_time(p_top_parent, v_partition_time_array, true, p_start_partition);\n+            END IF;\n+        ELSE\n+            SELECT a.attname\n+            INTO v_part_col\n+            FROM pg_attribute a\n+            JOIN pg_class c ON a.attrelid = c.oid\n+            JOIN pg_namespace n ON c.relnamespace = n.oid\n+            WHERE n.nspname = v_row.child_schema::name\n+            AND c.relname = v_row.child_tablename::name\n+            AND attnum IN (SELECT unnest(partattrs) FROM pg_partitioned_table p WHERE a.attrelid = p.partrelid);\n+\n+            IF p_control <> v_part_col THEN\n+                RAISE EXCEPTION 'Attempted to natively sub-partition an existing table that has the partition column (%) defined differently than the control column given (%)', v_part_col, p_control;\n+            ELSE -- Child table is already natively subpartitioned properly. Skip the rest.\n+                CONTINUE;\n+            END IF;\n+        END IF; -- end 'p' relkind check\n+\n+    END IF; -- end native check\n+\n+    IF v_recreate_child = false THEN\n+    -- Always call create_parent() if child table wasn't recreated above.\n+    -- If it was, the create_partition_*() functions called above also call create_parent if any of the tables\n+    --  it creates are in the part_config_sub table. Since it was inserted there above,\n+    --  it should call it appropriately\n+        v_sql := format('SELECT @extschema@.create_parent(\n+                 p_parent_table := %L\n+                , p_control := %L\n+                , p_type := %L\n+                , p_interval := %L\n+                , p_constraint_cols := %L\n+                , p_premake := %L\n+                , p_automatic_maintenance := %L\n+                , p_start_partition := %L\n+                , p_inherit_fk := %L\n+                , p_epoch := %L\n+                , p_upsert := %L\n+                , p_trigger_return_null := %L\n+                , p_template_table := %L\n+                , p_jobmon := %L)'\n+            , v_row.child_schema||'.'||v_row.child_tablename\n+            , p_control\n+            , p_type\n+            , p_interval\n+            , p_constraint_cols\n+            , p_premake\n+            , 'on'\n+            , p_start_partition\n+            , p_inherit_fk\n+            , p_epoch\n+            , p_upsert\n+            , p_trigger_return_null\n+            , v_template_table\n+            , p_jobmon);\n+        EXECUTE v_sql;\n+    END IF; -- end recreate check\n+\n+END LOOP;\n+\n+v_success := true;\n+\n+EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_old_search_path, 'false');\n+\n+RETURN v_success;\n+\n+END\n+$$;\n+\n+\n+CREATE OR REPLACE FUNCTION @extschema@.check_epoch_type (p_type text) RETURNS boolean\n+    LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER\n+    SET search_path TO pg_catalog, pg_temp\n+    AS $$\n+DECLARE\n+v_result    boolean;\n+BEGIN\n+    SELECT p_type IN ('none', 'seconds', 'milliseconds') INTO v_result;\n+    RETURN v_result;\n+END\n+$$;\n+\n+\n+CREATE OR REPLACE FUNCTION @extschema@.check_partition_type (p_type text) RETURNS boolean\n+    LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER\n+    SET search_path TO pg_catalog, pg_temp\n+    AS $$\n+DECLARE\n+v_result    boolean;\n+BEGIN\n+    SELECT p_type IN ('partman', 'time-custom', 'native') INTO v_result;\n+    RETURN v_result;\n+END\n+$$;\n+\n+\n+CREATE OR REPLACE FUNCTION @extschema@.create_parent(\n+    p_parent_table text\n+    , p_control text\n+    , p_type text\n+    , p_interval text\n+    , p_constraint_cols text[] DEFAULT NULL \n+    , p_premake int DEFAULT 4\n+    , p_automatic_maintenance text DEFAULT 'on' \n+    , p_start_partition text DEFAULT NULL\n+    , p_inherit_fk boolean DEFAULT true\n+    , p_epoch text DEFAULT 'none' \n+    , p_upsert text DEFAULT ''\n+    , p_publications text[] DEFAULT NULL\n+    , p_trigger_return_null boolean DEFAULT true\n+    , p_template_table text DEFAULT NULL\n+    , p_jobmon boolean DEFAULT true) \n+RETURNS boolean \n+    LANGUAGE plpgsql \n+    AS $$\n+DECLARE\n+\n+ex_context                      text;\n+ex_detail                       text;\n+ex_hint                         text;\n+ex_message                      text;\n+v_partattrs                     smallint[];\n+v_base_timestamp                timestamptz;\n+v_count                         int := 1;\n+v_control_type                  text;\n+v_control_exact_type            text;\n+v_datetime_string               text;\n+v_default_partition             text;\n+v_higher_control_type           text;\n+v_higher_parent_control         text;\n+v_higher_parent_epoch           text;\n+v_higher_parent_schema          text := split_part(p_parent_table, '.', 1);\n+v_higher_parent_table           text := split_part(p_parent_table, '.', 2);\n+v_id_interval                   bigint;\n+v_inherit_privileges            boolean := false;\n+v_job_id                        bigint;\n+v_jobmon_schema                 text;\n+v_last_partition_created        boolean;\n+v_max                           bigint;\n+v_native_sub_control            text;\n+v_notnull                       boolean;\n+v_new_search_path               text := '@extschema@,pg_temp';\n+v_old_search_path               text;\n+v_parent_owner                  text;\n+v_parent_partition_id           bigint;\n+v_parent_partition_timestamp    timestamptz;\n+v_parent_schema                 text;\n+v_parent_tablename              text;\n+v_parent_tablespace             text;\n+v_part_col                      text;\n+v_part_type                     text;\n+v_partition_time                timestamptz;\n+v_partition_time_array          timestamptz[];\n+v_partition_id_array            bigint[];\n+v_partstrat                     char;\n+v_publication_exists            text;\n+v_row                           record;\n+v_sql                           text;\n+v_start_time                    timestamptz;\n+v_starting_partition_id         bigint;\n+v_step_id                       bigint;\n+v_step_overflow_id              bigint;\n+v_sub_parent                    text;\n+v_success                       boolean := false;\n+v_template_schema               text;\n+v_template_tablename            text;\n+v_time_interval                 interval;\n+v_top_datetime_string           text;\n+v_top_parent_schema             text := split_part(p_parent_table, '.', 1);\n+v_top_parent_table              text := split_part(p_parent_table, '.', 2);\n+v_unlogged                      char;\n+\n+BEGIN\n+/*\n+ * Function to turn a table into the parent of a partition set\n+ */\n+\n+IF position('.' in p_parent_table) = 0  THEN\n+    RAISE EXCEPTION 'Parent table must be schema qualified';\n+END IF;\n+\n+IF p_upsert <> '' THEN\n+    IF current_setting('server_version_num')::int < 90500 THEN\n+        RAISE EXCEPTION 'INSERT ... ON CONFLICT (UPSERT) feature is only supported in PostgreSQL 9.5 and later';\n+    END IF;\n+    IF p_type = 'native' THEN\n+        RAISE EXCEPTION 'Native partitioning does not currently support upsert. Use pg_partman''s partitioning methods instead if this is required';\n+    END IF;\n+END IF;\n+\n+SELECT n.nspname, c.relname, t.spcname, c.relpersistence\n+INTO v_parent_schema, v_parent_tablename, v_parent_tablespace, v_unlogged\n+FROM pg_catalog.pg_class c\n+JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid\n+LEFT OUTER JOIN pg_catalog.pg_tablespace t ON c.reltablespace = t.oid\n+WHERE n.nspname = split_part(p_parent_table, '.', 1)::name\n+AND c.relname = split_part(p_parent_table, '.', 2)::name;\n+    IF v_parent_tablename IS NULL THEN\n+        RAISE EXCEPTION 'Unable to find given parent table in system catalogs. Please create parent table first: %', p_parent_table;\n+    END IF;\n+    \n+SELECT attnotnull INTO v_notnull \n+FROM pg_catalog.pg_attribute a\n+JOIN pg_catalog.pg_class c ON a.attrelid = c.oid\n+JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid\n+WHERE c.relname = v_parent_tablename::name\n+AND n.nspname = v_parent_schema::name\n+AND a.attname = p_control::name;\n+    IF p_type <> 'native' AND (v_notnull = false OR v_notnull IS NULL) THEN\n+        RAISE EXCEPTION 'Control column given (%) for parent table (%) does not exist or must be set to NOT NULL', p_control, p_parent_table;\n+    END IF;\n+\n+SELECT general_type, exact_type INTO v_control_type, v_control_exact_type\n+FROM @extschema@.check_control_type(v_parent_schema, v_parent_tablename, p_control);\n+\n+IF v_control_type IS NULL THEN\n+    RAISE EXCEPTION 'pg_partman only supports partitioning of data types that are integer or date/timestamp. Supplied column is of type %', v_control_exact_type;\n+END IF;\n+\n+IF (p_epoch <> 'none' AND v_control_type <> 'id') THEN\n+    RAISE EXCEPTION 'p_epoch can only be used with an integer based control column and does not work for native partitioning';\n+END IF;\n+\n+\n+IF NOT @extschema@.check_partition_type(p_type) THEN\n+    RAISE EXCEPTION '% is not a valid partitioning type for pg_partman', p_type;\n+END IF;\n+\n+IF p_type = 'native' THEN\n+\n+    IF current_setting('server_version_num')::int < 100000 THEN\n+        RAISE EXCEPTION 'Native partitioning only available in PostgreSQL versions 10.0+';\n+    END IF;\n+    -- Check if given parent table has been already set up as a partitioned table and is ranged\n+    SELECT p.partstrat, partattrs INTO v_partstrat, v_partattrs\n+    FROM pg_catalog.pg_partitioned_table p\n+    JOIN pg_catalog.pg_class c ON p.partrelid = c.oid\n+    JOIN pg_namespace n ON c.relnamespace = n.oid\n+    WHERE n.nspname = v_parent_schema::name \n+    AND c.relname = v_parent_tablename::name;\n+\n+    IF v_partstrat <> 'r' OR v_partstrat IS NULL THEN\n+        RAISE EXCEPTION 'When using native partitioning, you must have created the given parent table as ranged (not list) partitioned already. Ex: CREATE TABLE ... PARTITION BY RANGE ...)';\n+    END IF;\n+\n+    IF array_length(v_partattrs, 1) > 1 THEN\n+        RAISE NOTICE 'pg_partman only supports single column native partitioning at this time. Found % columns in given parent definition.', array_length(v_partattrs, 1);\n+    END IF;\n+\n+    SELECT a.attname, t.typname\n+    INTO v_part_col, v_part_type\n+    FROM pg_attribute a\n+    JOIN pg_class c ON a.attrelid = c.oid\n+    JOIN pg_namespace n ON c.relnamespace = n.oid\n+    JOIN pg_type t ON a.atttypid = t.oid\n+    WHERE n.nspname = v_parent_schema::name\n+    AND c.relname = v_parent_tablename::name\n+    AND attnum IN (SELECT unnest(partattrs) FROM pg_partitioned_table p WHERE a.attrelid = p.partrelid);\n+\n+    IF p_control <> v_part_col OR v_control_exact_type <> v_part_type THEN\n+        RAISE EXCEPTION 'Control column and type given in arguments (%, %) does not match the control column and type of the given native partition set (%, %)', p_control, v_control_exact_type, v_part_col, v_part_type;\n+    END IF;\n+\n+    -- Check that control column is a usable type for pg_partman.\n+    IF v_control_type NOT IN ('time', 'id') THEN\n+        RAISE EXCEPTION 'Only date/time or integer types are allowed for the control column with native partitioning.';\n+    END IF;\n+\n+    -- Table to handle properties not natively inherited yet (indexes, fks, etc)\n+    IF p_template_table IS NULL THEN\n+        v_template_schema := '@extschema@';\n+        v_template_tablename := @extschema@.check_name_length('template_'||v_parent_schema||'_'||v_parent_tablename);\n+        EXECUTE format('CREATE TABLE IF NOT EXISTS %I.%I (LIKE %I.%I)', '@extschema@', v_template_tablename, v_parent_schema, v_parent_tablename);\n+\n+        SELECT pg_get_userbyid(c.relowner) INTO v_parent_owner \n+        FROM pg_catalog.pg_class c\n+        JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid\n+        WHERE n.nspname = v_parent_schema::name \n+        AND c.relname = v_parent_tablename::name;\n+\n+        EXECUTE format('ALTER TABLE %I.%I OWNER TO %I'\n+                , '@extschema@' \n+                , v_template_tablename \n+                , v_parent_owner);\n+    ELSE\n+        SELECT n.nspname, c.relname INTO v_template_schema, v_template_tablename\n+        FROM pg_catalog.pg_class c\n+        JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid\n+        WHERE n.nspname = split_part(p_template_table, '.', 1)::name\n+        AND c.relname = split_part(p_template_table, '.', 2)::name;\n+            IF v_template_tablename IS NULL THEN\n+                RAISE EXCEPTION 'Unable to find given template table in system catalogs (%). Please create template table first or leave parameter NULL to have a default one created for you.', p_parent_table;\n+            END IF;\n+    END IF;\n+\n+ELSE -- if not native \n+\n+    IF current_setting('server_version_num')::int >= 100000 THEN\n+        SELECT p.partstrat INTO v_partstrat\n+        FROM pg_catalog.pg_partitioned_table p\n+        JOIN pg_catalog.pg_class c ON p.partrelid = c.oid\n+        JOIN pg_namespace n ON c.relnamespace = n.oid\n+        WHERE n.nspname = v_parent_schema::name \n+        AND c.relname = v_parent_tablename::name;\n+    END IF;\n+\n+    IF v_partstrat IS NOT NULL THEN\n+        RAISE EXCEPTION 'Given parent table has been set up with native partitioning therefore cannot be used with pg_partman''s other partitioning types. Either recreate table non-native or set the type argument to ''native''';\n+    END IF;\n+\n+END IF; -- end if \"native\" check\n+\n+\n+IF p_publications IS NOT NULL THEN\n+    IF current_setting('server_version_num')::int < 100000 THEN\n+        RAISE EXCEPTION 'p_publications argument not null but CREATE PUBLICATION is only available in PostgreSQL versions 10.0+';\n+    END IF;\n+    IF p_publications = '{}' THEN\n+        RAISE EXCEPTION 'p_publications cannot be an empty set';\n+    END IF;\n+    FOR v_row IN \n+        SELECT unnest(p_publications) AS pubname\n+    LOOP\n+        SELECT pubname INTO v_publication_exists FROM pg_catalog.pg_publication where pubname = v_row.pubname::name;\n+        IF v_publication_exists IS NULL THEN\n+            RAISE EXCEPTION 'Given publication name (%) does not exist in system catalog. Ensure it is created first.', v_row.pubname;\n+        END IF;\n+    END LOOP;\n+END IF;\n+\n+-- Only inherit parent ownership/privileges on non-native sets by default\n+-- This is false by default so initial partition set creation doesn't require superuser.\n+IF p_type = 'native' THEN\n+    v_inherit_privileges = false;\n+ELSE\n+    v_inherit_privileges  = true;\n+END IF;\n+\n+SELECT current_setting('search_path') INTO v_old_search_path;\n+IF p_jobmon THEN\n+    SELECT nspname INTO v_jobmon_schema FROM pg_catalog.pg_namespace n, pg_catalog.pg_extension e WHERE e.extname = 'pg_jobmon'::name AND e.extnamespace = n.oid;\n+    IF v_jobmon_schema IS NOT NULL THEN\n+        v_new_search_path := '@extschema@,'||v_jobmon_schema||',pg_temp';\n+    END IF;\n+END IF;\n+EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_new_search_path, 'false');\n+\n+EXECUTE format('LOCK TABLE %I.%I IN ACCESS EXCLUSIVE MODE', v_parent_schema, v_parent_tablename);\n+\n+IF v_jobmon_schema IS NOT NULL THEN\n+    v_job_id := add_job(format('PARTMAN SETUP PARENT: %s', p_parent_table));\n+    v_step_id := add_step(v_job_id, format('Creating initial partitions on new parent table: %s', p_parent_table));\n+END IF;\n+\n+-- If this parent table has siblings that are also partitioned (subpartitions), ensure this parent gets added to part_config_sub table so future maintenance will subpartition it\n+-- Just doing in a loop to avoid having to assign a bunch of variables (should only run once, if at all; constraint should enforce only one value.)\n+FOR v_row IN \n+    WITH parent_table AS (\n+        SELECT h.inhparent AS parent_oid\n+        FROM pg_catalog.pg_inherits h\n+        JOIN pg_catalog.pg_class c ON h.inhrelid = c.oid\n+        JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid\n+        WHERE c.relname = v_parent_tablename::name\n+        AND n.nspname = v_parent_schema::name\n+    ), sibling_children AS (\n+        SELECT i.inhrelid::regclass::text AS tablename \n+        FROM pg_inherits i\n+        JOIN parent_table p ON i.inhparent = p.parent_oid\n+    )\n+    -- This column list must be kept consistent between: \n+    --   create_parent, check_subpart_sameconfig, create_partition_id, create_partition_time, dump_partitioned_table_definition and table definition\n+    SELECT DISTINCT sub_partition_type\n+        , sub_control\n+        , sub_partition_interval\n+        , sub_constraint_cols\n+        , sub_premake\n+        , sub_inherit_fk\n+        , sub_retention\n+        , sub_retention_schema\n+        , sub_retention_keep_table\n+        , sub_retention_keep_index\n+        , sub_automatic_maintenance\n+        , sub_epoch\n+        , sub_optimize_trigger\n+        , sub_optimize_constraint\n+        , sub_infinite_time_partitions\n+        , sub_jobmon\n+        , sub_trigger_exception_handling\n+        , sub_upsert\n+        , sub_trigger_return_null\n+        , sub_template_table\n+        , sub_inherit_privileges\n+        , sub_constraint_valid\n+        , sub_subscription_refresh\n+    FROM @extschema@.part_config_sub a\n+    JOIN sibling_children b on a.sub_parent = b.tablename LIMIT 1\n+LOOP\n+    INSERT INTO @extschema@.part_config_sub (\n+        sub_parent\n+        , sub_partition_type\n+        , sub_control\n+        , sub_partition_interval\n+        , sub_constraint_cols\n+        , sub_premake\n+        , sub_inherit_fk\n+        , sub_retention\n+        , sub_retention_schema\n+        , sub_retention_keep_table\n+        , sub_retention_keep_index\n+        , sub_automatic_maintenance\n+        , sub_epoch\n+        , sub_optimize_trigger\n+        , sub_optimize_constraint\n+        , sub_infinite_time_partitions\n+        , sub_jobmon\n+        , sub_trigger_exception_handling\n+        , sub_upsert\n+        , sub_trigger_return_null\n+        , sub_template_table\n+        , sub_inherit_privileges\n+        , sub_constraint_valid\n+        , sub_subscription_refresh)\n+    VALUES (\n+        p_parent_table\n+        , v_row.sub_partition_type\n+        , v_row.sub_control\n+        , v_row.sub_partition_interval\n+        , v_row.sub_constraint_cols\n+        , v_row.sub_premake\n+        , v_row.sub_inherit_fk\n+        , v_row.sub_retention\n+        , v_row.sub_retention_schema\n+        , v_row.sub_retention_keep_table\n+        , v_row.sub_retention_keep_index\n+        , v_row.sub_automatic_maintenance\n+        , v_row.sub_epoch\n+        , v_row.sub_optimize_trigger\n+        , v_row.sub_optimize_constraint\n+        , v_row.sub_infinite_time_partitions\n+        , v_row.sub_jobmon\n+        , v_row.sub_trigger_exception_handling\n+        , v_row.sub_upsert\n+        , v_row.sub_trigger_return_null\n+        , v_row.sub_template_table\n+        , v_row.sub_inherit_privileges\n+        , v_row.sub_constraint_valid\n+        , v_row.sub_subscription_refresh);\n+\n+    -- Set this equal to sibling configs so that newly created child table \n+    -- privileges are set properly below during initial setup.\n+    -- This setting is special because it applies immediately to the new child \n+    -- tables of a given parent, not just during maintenance like most other settings.\n+    v_inherit_privileges = v_row.sub_inherit_privileges;\n+END LOOP;\n+\n+IF v_control_type = 'time' OR (v_control_type = 'id' AND p_epoch <> 'none') THEN\n+\n+    CASE\n+        WHEN p_interval = 'yearly' THEN\n+            v_time_interval := '1 year';\n+        WHEN p_interval = 'quarterly' THEN\n+            v_time_interval := '3 months';\n+        WHEN p_interval = 'monthly' THEN\n+            v_time_interval := '1 month';\n+        WHEN p_interval  = 'weekly' THEN\n+            v_time_interval := '1 week';\n+        WHEN p_interval = 'daily' THEN\n+            v_time_interval := '1 day';\n+        WHEN p_interval = 'hourly' THEN\n+            v_time_interval := '1 hour';\n+        WHEN p_interval = 'half-hour' THEN\n+            v_time_interval := '30 mins';\n+        WHEN p_interval = 'quarter-hour' THEN\n+            v_time_interval := '15 mins';\n+        ELSE\n+            IF p_type <> 'native' THEN\n+                -- Reset for use as part_config type value below\n+                p_type = 'time-custom';\n+            END IF;\n+            v_time_interval := p_interval::interval;\n+            IF v_time_interval < '1 second'::interval THEN\n+                RAISE EXCEPTION 'Partitioning interval must be 1 second or greater';\n+            END IF;\n+    END CASE;\n+\n+   -- First partition is either the min premake or p_start_partition\n+    v_start_time := COALESCE(p_start_partition::timestamptz, CURRENT_TIMESTAMP - (v_time_interval * p_premake));\n+\n+    IF v_time_interval >= '1 year' THEN\n+        v_base_timestamp := date_trunc('year', v_start_time);\n+        IF v_time_interval >= '10 years' THEN\n+            v_base_timestamp := date_trunc('decade', v_start_time);\n+            IF v_time_interval >= '100 years' THEN\n+                v_base_timestamp := date_trunc('century', v_start_time);\n+                IF v_time_interval >= '1000 years' THEN\n+                    v_base_timestamp := date_trunc('millennium', v_start_time);\n+                END IF; -- 1000\n+            END IF; -- 100\n+        END IF; -- 10\n+    END IF; -- 1\n+\n+    v_datetime_string := 'YYYY';\n+    IF v_time_interval < '1 year' THEN\n+        IF p_interval = 'quarterly' THEN\n+            v_base_timestamp := date_trunc('quarter', v_start_time);\n+            v_datetime_string = 'YYYY\"q\"Q';\n+        ELSE\n+            v_base_timestamp := date_trunc('month', v_start_time); \n+            v_datetime_string := v_datetime_string || '_MM';\n+        END IF;\n+        IF v_time_interval < '1 month' THEN\n+            IF p_interval = 'weekly' THEN\n+                v_base_timestamp := date_trunc('week', v_start_time);\n+                v_datetime_string := 'IYYY\"w\"IW';\n+            ELSE \n+                v_base_timestamp := date_trunc('day', v_start_time);\n+                v_datetime_string := v_datetime_string || '_DD';\n+            END IF;\n+            IF v_time_interval < '1 day' THEN\n+                v_base_timestamp := date_trunc('hour', v_start_time);\n+                v_datetime_string := v_datetime_string || '_HH24MI';\n+                IF v_time_interval < '1 minute' THEN\n+                    v_base_timestamp := date_trunc('minute', v_start_time);\n+                    v_datetime_string := v_datetime_string || 'SS';\n+                END IF; -- minute\n+            END IF; -- day\n+        END IF; -- month\n+    END IF; -- year\n+\n+    v_partition_time_array := array_append(v_partition_time_array, v_base_timestamp);\n+    LOOP\n+        -- If current loop value is less than or equal to the value of the max premake, add time to array.\n+        IF (v_base_timestamp + (v_time_interval * v_count)) < (CURRENT_TIMESTAMP + (v_time_interval * p_premake)) THEN\n+            BEGIN\n+                v_partition_time := (v_base_timestamp + (v_time_interval * v_count))::timestamptz;\n+                v_partition_time_array := array_append(v_partition_time_array, v_partition_time);\n+            EXCEPTION WHEN datetime_field_overflow THEN\n+                RAISE WARNING 'Attempted partition time interval is outside PostgreSQL''s supported time range. \n+                    Child partition creation after time % skipped', v_partition_time;\n+                v_step_overflow_id := add_step(v_job_id, 'Attempted partition time interval is outside PostgreSQL''s supported time range.');\n+                PERFORM update_step(v_step_overflow_id, 'CRITICAL', 'Child partition creation after time '||v_partition_time||' skipped');\n+                CONTINUE;\n+            END;\n+        ELSE\n+            EXIT; -- all needed partitions added to array. Exit the loop.\n+        END IF;\n+        v_count := v_count + 1;\n+    END LOOP;\n+\n+    INSERT INTO @extschema@.part_config (\n+        parent_table\n+        , partition_type\n+        , partition_interval\n+        , epoch\n+        , control\n+        , premake\n+        , constraint_cols\n+        , datetime_string\n+        , automatic_maintenance\n+        , inherit_fk\n+        , jobmon \n+        , upsert\n+        , trigger_return_null\n+        , template_table\n+        , publications\n+        , inherit_privileges)\n+    VALUES (\n+        p_parent_table\n+        , p_type\n+        , v_time_interval\n+        , p_epoch\n+        , p_control\n+        , p_premake\n+        , p_constraint_cols\n+        , v_datetime_string\n+        , p_automatic_maintenance\n+        , p_inherit_fk\n+        , p_jobmon\n+        , p_upsert\n+        , p_trigger_return_null\n+        , v_template_schema||'.'||v_template_tablename\n+        , p_publications\n+        , v_inherit_privileges); \n+\n+    RAISE DEBUG 'create_parent: v_partition_time_array: %', v_partition_time_array;\n+\n+    v_last_partition_created := @extschema@.create_partition_time(p_parent_table, v_partition_time_array, false);\n+\n+    IF v_last_partition_created = false THEN \n+        -- This can happen with subpartitioning when future or past partitions prevent child creation because they're out of range of the parent\n+        -- First see if this parent is a subpartition managed by pg_partman\n+        WITH top_oid AS (\n+            SELECT i.inhparent AS top_parent_oid\n+            FROM pg_catalog.pg_inherits i\n+            JOIN pg_catalog.pg_class c ON c.oid = i.inhrelid\n+            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n+            WHERE c.relname = v_parent_tablename::name\n+            AND n.nspname = v_parent_schema::name\n+        ) SELECT n.nspname, c.relname \n+        INTO v_top_parent_schema, v_top_parent_table \n+        FROM pg_catalog.pg_class c\n+        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n+        JOIN top_oid t ON c.oid = t.top_parent_oid\n+        JOIN @extschema@.part_config p ON p.parent_table = n.nspname||'.'||c.relname;\n+\n+        IF v_top_parent_table IS NOT NULL THEN\n+            -- If so create the lowest possible partition that is within the boundary of the parent\n+            SELECT child_start_time INTO v_parent_partition_timestamp FROM @extschema@.show_partition_info(p_parent_table, p_parent_table := v_top_parent_schema||'.'||v_top_parent_table);\n+            IF v_base_timestamp >= v_parent_partition_timestamp THEN\n+                WHILE v_base_timestamp >= v_parent_partition_timestamp LOOP\n+                    v_base_timestamp := v_base_timestamp - v_time_interval;\n+                END LOOP;\n+                v_base_timestamp := v_base_timestamp + v_time_interval; -- add one back since while loop set it one lower than is needed\n+            ELSIF v_base_timestamp < v_parent_partition_timestamp THEN\n+                WHILE v_base_timestamp < v_parent_partition_timestamp LOOP\n+                    v_base_timestamp := v_base_timestamp + v_time_interval;\n+                END LOOP;\n+                -- Don't need to remove one since new starting time will fit in top parent interval\n+            END IF;\n+            v_partition_time_array := NULL;\n+            v_partition_time_array := array_append(v_partition_time_array, v_base_timestamp);\n+            v_last_partition_created := @extschema@.create_partition_time(p_parent_table, v_partition_time_array, false);\n+        ELSE\n+            RAISE WARNING 'No child tables created. Check that all child tables did not already exist and may not have been part of partition set. Given parent has still been configured with pg_partman, but may not have expected children. Please review schema and config to confirm things are ok.';\n+\n+            IF v_jobmon_schema IS NOT NULL THEN\n+                PERFORM update_step(v_step_id, 'OK', 'Done');\n+                IF v_step_overflow_id IS NOT NULL THEN\n+                    PERFORM fail_job(v_job_id);\n+                ELSE\n+                    PERFORM close_job(v_job_id);\n+                END IF;\n+            END IF;\n+\n+            EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_old_search_path, 'false');\n+\n+            RETURN v_success;\n+        END IF; \n+    END IF; -- End v_last_partition IF\n+\n+    IF v_jobmon_schema IS NOT NULL THEN\n+        PERFORM update_step(v_step_id, 'OK', format('Time partitions premade: %s', p_premake));\n+    END IF;\n+\n+END IF;\n+\n+IF v_control_type = 'id' AND p_epoch = 'none' THEN\n+    v_id_interval := p_interval::bigint;\n+    IF p_type <> 'native' AND v_id_interval < 10 THEN\n+        RAISE EXCEPTION 'Interval for serial, non-native partitioning must be greater than or equal to 10';\n+    END IF;\n+\n+    -- Check if parent table is a subpartition of an already existing id partition set managed by pg_partman. \n+    WHILE v_higher_parent_table IS NOT NULL LOOP -- initially set in DECLARE\n+        WITH top_oid AS (\n+            SELECT i.inhparent AS top_parent_oid\n+            FROM pg_catalog.pg_inherits i\n+            JOIN pg_catalog.pg_class c ON c.oid = i.inhrelid\n+            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n+            WHERE n.nspname = v_higher_parent_schema::name\n+            AND c.relname = v_higher_parent_table::name\n+        ) SELECT n.nspname, c.relname, p.control, p.epoch\n+        INTO v_higher_parent_schema, v_higher_parent_table, v_higher_parent_control, v_higher_parent_epoch\n+        FROM pg_catalog.pg_class c\n+        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n+        JOIN top_oid t ON c.oid = t.top_parent_oid\n+        JOIN @extschema@.part_config p ON p.parent_table = n.nspname||'.'||c.relname;\n+\n+        IF v_higher_parent_table IS NOT NULL THEN\n+            SELECT general_type INTO v_higher_control_type\n+            FROM @extschema@.check_control_type(v_higher_parent_schema, v_higher_parent_table, v_higher_parent_control);\n+            IF v_higher_control_type <> 'id' or (v_higher_control_type = 'id' AND v_higher_parent_epoch <> 'none') THEN\n+                -- The parent above the p_parent_table parameter is not partitioned by ID\n+                --   so don't check for max values in parents that aren't partitioned by ID.\n+                -- This avoids missing child tables in subpartition sets that have differing ID data\n+                EXIT;\n+            END IF;\n+            -- v_top_parent initially set in DECLARE\n+            v_top_parent_schema := v_higher_parent_schema;\n+            v_top_parent_table := v_higher_parent_table;\n+        END IF;\n+    END LOOP;\n+\n+    -- If custom start partition is set, use that.\n+    -- If custom start is not set and there is already data, start partitioning with the highest current value and ensure it's grabbed from highest top parent table\n+    IF p_start_partition IS NOT NULL THEN\n+        v_max := p_start_partition::bigint;\n+    ELSE\n+        v_sql := format('SELECT COALESCE(max(%I)::bigint, 0) FROM %I.%I LIMIT 1'\n+                    , p_control\n+                    , v_top_parent_schema\n+                    , v_top_parent_table);\n+        EXECUTE v_sql INTO v_max;\n+    END IF;\n+\n+    v_starting_partition_id := v_max - (v_max % v_id_interval);\n+    FOR i IN 0..p_premake LOOP\n+        -- Only make previous partitions if ID value is less than the starting value and positive (and custom start partition wasn't set)\n+        IF p_start_partition IS NULL AND \n+            (v_starting_partition_id - (v_id_interval*i)) > 0 AND \n+            (v_starting_partition_id - (v_id_interval*i)) < v_starting_partition_id \n+        THEN\n+            v_partition_id_array = array_append(v_partition_id_array, (v_starting_partition_id - v_id_interval*i));\n+        END IF; \n+        v_partition_id_array = array_append(v_partition_id_array, (v_id_interval*i) + v_starting_partition_id);\n+    END LOOP;\n+\n+    INSERT INTO @extschema@.part_config (\n+        parent_table\n+        , partition_type\n+        , partition_interval\n+        , control\n+        , premake\n+        , constraint_cols\n+        , automatic_maintenance\n+        , inherit_fk\n+        , jobmon\n+        , upsert\n+        , trigger_return_null\n+        , template_table\n+        , publications\n+        , inherit_privileges)\n+    VALUES (\n+        p_parent_table\n+        , p_type\n+        , v_id_interval\n+        , p_control\n+        , p_premake\n+        , p_constraint_cols\n+        , p_automatic_maintenance \n+        , p_inherit_fk\n+        , p_jobmon\n+        , p_upsert\n+        , p_trigger_return_null\n+        , v_template_schema||'.'||v_template_tablename\n+        , p_publications\n+        , v_inherit_privileges); \n+\n+    v_last_partition_created := @extschema@.create_partition_id(p_parent_table, v_partition_id_array, false);\n+\n+    IF v_last_partition_created = false THEN\n+        -- This can happen with subpartitioning when future or past partitions prevent child creation because they're out of range of the parent\n+        -- See if it's actually a subpartition of a parent id partition\n+        WITH top_oid AS (\n+            SELECT i.inhparent AS top_parent_oid\n+            FROM pg_catalog.pg_inherits i\n+            JOIN pg_catalog.pg_class c ON c.oid = i.inhrelid\n+            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n+            WHERE c.relname = v_parent_tablename::name\n+            AND n.nspname = v_parent_schema::name\n+        ) SELECT n.nspname||'.'||c.relname\n+        INTO v_top_parent_table\n+        FROM pg_catalog.pg_class c\n+        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n+        JOIN top_oid t ON c.oid = t.top_parent_oid\n+        JOIN @extschema@.part_config p ON p.parent_table = n.nspname||'.'||c.relname;\n+\n+        IF v_top_parent_table IS NOT NULL THEN\n+            -- Create the lowest possible partition that is within the boundary of the parent\n+             SELECT child_start_id INTO v_parent_partition_id FROM @extschema@.show_partition_info(p_parent_table, p_parent_table := v_top_parent_table);\n+            IF v_starting_partition_id >= v_parent_partition_id THEN\n+                WHILE v_starting_partition_id >= v_parent_partition_id LOOP\n+                    v_starting_partition_id := v_starting_partition_id - v_id_interval;\n+                END LOOP;\n+                v_starting_partition_id := v_starting_partition_id + v_id_interval; -- add one back since while loop set it one lower than is needed\n+            ELSIF v_starting_partition_id < v_parent_partition_id THEN\n+                WHILE v_starting_partition_id < v_parent_partition_id LOOP\n+                    v_starting_partition_id := v_starting_partition_id + v_id_interval;\n+                END LOOP;\n+                -- Don't need to remove one since new starting id will fit in top parent interval\n+            END IF;\n+            v_partition_id_array = NULL;\n+            v_partition_id_array = array_append(v_partition_id_array, v_starting_partition_id);\n+            v_last_partition_created := @extschema@.create_partition_id(p_parent_table, v_partition_id_array, false);\n+        ELSE\n+            -- Currently unknown edge case if code gets here\n+            RAISE WARNING 'No child tables created. Check that all child tables did not already exist and may not have been part of partition set. Given parent has still been configured with pg_partman, but may not have expected children. Please review schema and config to confirm things are ok.';\n+            IF v_jobmon_schema IS NOT NULL THEN\n+                PERFORM update_step(v_step_id, 'OK', 'Done');\n+                IF v_step_overflow_id IS NOT NULL THEN\n+                    PERFORM fail_job(v_job_id);\n+                ELSE\n+                    PERFORM close_job(v_job_id);\n+                END IF;\n+            END IF;\n+\n+            EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_old_search_path, 'false');\n+\n+            RETURN v_success;\n+        END IF;\n+    END IF; -- End v_last_partition_created IF\n+\n+END IF; -- End IF id\n+\n+IF p_type = 'native' AND current_setting('server_version_num')::int >= 110000 THEN\n+    -- Add default partition to native sets in PG11+\n+\n+    v_default_partition := @extschema@.check_name_length(v_parent_tablename, '_default', FALSE);\n+    v_sql := 'CREATE'; \n+\n+    -- Left this here as reminder to revisit once native figures out how it is handling changing unlogged stats\n+    -- Currently handed via template table below\n+    /* \n+    IF v_unlogged = 'u' THEN\n+         v_sql := v_sql ||' UNLOGGED';\n+    END IF;\n+    */\n+\n+    -- Same INCLUDING list is used in create_partition_*(). INDEXES is handled when partition is attached if it's supported.\n+    v_sql := v_sql || format(' TABLE %I.%I (LIKE %I.%I INCLUDING DEFAULTS INCLUDING CONSTRAINTS INCLUDING STORAGE INCLUDING COMMENTS '\n+        , v_parent_schema, v_default_partition, v_parent_schema, v_parent_tablename);\n+    IF current_setting('server_version_num')::int >= 120000 THEN\n+        v_sql := v_sql || ' INCLUDING GENERATED ';\n+    END IF;\n+    v_sql := v_sql || ')';\n+    EXECUTE v_sql;\n+    v_sql := format('ALTER TABLE %I.%I ATTACH PARTITION %I.%I DEFAULT'\n+        , v_parent_schema, v_parent_tablename, v_parent_schema, v_default_partition);\n+    EXECUTE v_sql;\n+\n+    IF current_setting('server_version_num')::int >= 120000 AND v_parent_tablespace IS NOT NULL THEN\n+        -- Tablespace managed via inherit_template_properties() call below if PG11 or earliser\n+        EXECUTE format('ALTER TABLE %I.%I SET TABLESPACE %I', v_parent_schema, v_default_partition, v_parent_tablespace);\n+    END IF;\n+\n+    -- Manage template inherited properies\n+    PERFORM @extschema@.inherit_template_properties(p_parent_table, v_parent_schema, v_default_partition);\n+\n+END IF;\n+\n+IF p_type <> 'native' THEN\n+    IF v_jobmon_schema IS NOT NULL  THEN\n+        v_step_id := add_step(v_job_id, 'Creating partition function');\n+    END IF;\n+    IF v_control_type = 'time' OR (v_control_type = 'id' AND p_epoch <> 'none') THEN\n+        PERFORM @extschema@.create_function_time(p_parent_table, v_job_id);\n+        IF v_jobmon_schema IS NOT NULL THEN\n+            PERFORM update_step(v_step_id, 'OK', 'Time function created');\n+        END IF;\n+    ELSIF v_control_type = 'id' THEN\n+        PERFORM @extschema@.create_function_id(p_parent_table, v_job_id);  \n+        IF v_jobmon_schema IS NOT NULL THEN\n+            PERFORM update_step(v_step_id, 'OK', 'ID function created');\n+        END IF;\n+    END IF;\n+\n+    IF v_jobmon_schema IS NOT NULL THEN\n+        v_step_id := add_step(v_job_id, 'Creating partition trigger');\n+    END IF;\n+    PERFORM @extschema@.create_trigger(p_parent_table);\n+END IF; -- end native check\n+\n+\n+IF v_jobmon_schema IS NOT NULL THEN\n+    PERFORM update_step(v_step_id, 'OK', 'Done');\n+    IF v_step_overflow_id IS NOT NULL THEN\n+        PERFORM fail_job(v_job_id);\n+    ELSE\n+        PERFORM close_job(v_job_id);\n+    END IF;\n+END IF;\n+\n+EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_old_search_path, 'false');\n+\n+v_success := true;\n+\n+RETURN v_success;\n+\n+EXCEPTION\n+    WHEN OTHERS THEN\n+        GET STACKED DIAGNOSTICS ex_message = MESSAGE_TEXT,\n+                                ex_context = PG_EXCEPTION_CONTEXT,\n+                                ex_detail = PG_EXCEPTION_DETAIL,\n+                                ex_hint = PG_EXCEPTION_HINT;\n+        IF v_jobmon_schema IS NOT NULL THEN\n+            IF v_job_id IS NULL THEN\n+                EXECUTE format('SELECT %I.add_job(''PARTMAN CREATE PARENT: %s'')', v_jobmon_schema, p_parent_table) INTO v_job_id;\n+                EXECUTE format('SELECT %I.add_step(%s, ''Partition creation for table '||p_parent_table||' failed'')', v_jobmon_schema, v_job_id, p_parent_table) INTO v_step_id;\n+            ELSIF v_step_id IS NULL THEN\n+                EXECUTE format('SELECT %I.add_step(%s, ''EXCEPTION before first step logged'')', v_jobmon_schema, v_job_id) INTO v_step_id;\n+            END IF;\n+            EXECUTE format('SELECT %I.update_step(%s, ''CRITICAL'', %L)', v_jobmon_schema, v_step_id, 'ERROR: '||coalesce(SQLERRM,'unknown'));\n+            EXECUTE format('SELECT %I.fail_job(%s)', v_jobmon_schema, v_job_id);\n+        END IF;\n+        RAISE EXCEPTION '%\n+CONTEXT: %\n+DETAIL: %\n+HINT: %', ex_message, ex_context, ex_detail, ex_hint;\n+END\n+$$;\n+"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 6,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "949bf56861d58ca8bf84d23ff5677025bfcf5bb6",
            "date": "2025-01-03T14:49:34Z",
            "author_login": "keithf4"
          },
          {
            "sha": "1192e933232a0ecc1b960470316f1fffa05a8da3",
            "date": "2025-01-02T18:15:11Z",
            "author_login": "keithf4"
          },
          {
            "sha": "0723b31735329a1e0fd0a6b752bb143f4a101e64",
            "date": "2024-12-31T23:19:20Z",
            "author_login": "keithf4"
          },
          {
            "sha": "120f73089752ce990af845005db069bafaad8052",
            "date": "2024-12-31T22:39:50Z",
            "author_login": "keithf4"
          },
          {
            "sha": "5bf3ee2b1016f31b6f1026b3414c00ae83726157",
            "date": "2024-12-31T22:32:32Z",
            "author_login": "keithf4"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": null,
    "description": "In the pg_partman (aka PG Partition Manager) extension before 4.5.1 for PostgreSQL, arbitrary code execution can be achieved via SECURITY DEFINER functions because an explicit search_path is not set.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-05-19T17:15:07.537",
    "last_modified": "2024-11-21T06:08:30.637",
    "fix_date": "2021-05-11T17:28:02Z"
  },
  "references": [
    {
      "url": "https://github.com/pgpartman/pg_partman/commit/0b6565ad378c358f8a6cd1d48ddc482eb7f854d3",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/pgpartman/pg_partman/compare/v4.5.0...v4.5.1",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20210625-0006/",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/pgpartman/pg_partman/commit/0b6565ad378c358f8a6cd1d48ddc482eb7f854d3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/pgpartman/pg_partman/compare/v4.5.0...v4.5.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20210625-0006/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:57.108791",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "pg_partman",
    "owner": "pgpartman",
    "created_at": "2012-09-05T05:04:46Z",
    "updated_at": "2025-01-14T08:27:37Z",
    "pushed_at": "2025-01-03T14:49:49Z",
    "size": 3377,
    "stars": 2173,
    "forks": 285,
    "open_issues": 39,
    "watchers": 2173,
    "has_security_policy": false,
    "default_branch": "development",
    "protected_branches": [
      "development",
      "master-old"
    ],
    "languages": {
      "PLpgSQL": 8755093,
      "Python": 21525,
      "C": 19820,
      "Makefile": 1269
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:48:07.167996"
  }
}