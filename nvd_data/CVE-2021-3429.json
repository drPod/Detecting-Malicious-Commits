{
  "cve_id": "CVE-2021-3429",
  "github_data": {
    "repository": "canonical/cloud-init",
    "fix_commit": "b794d426b9ab43ea9d6371477466070d86e10668",
    "related_commits": [
      "b794d426b9ab43ea9d6371477466070d86e10668",
      "b794d426b9ab43ea9d6371477466070d86e10668"
    ],
    "patch_url": "https://github.com/canonical/cloud-init/commit/b794d426b9ab43ea9d6371477466070d86e10668.patch",
    "fix_commit_details": {
      "sha": "b794d426b9ab43ea9d6371477466070d86e10668",
      "commit_date": "2021-03-19T14:06:42Z",
      "author": {
        "login": "OddBloke",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "write passwords only to serial console, lock down cloud-init-output.log (#847)",
        "length": 1390,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 189,
        "additions": 173,
        "deletions": 16
      },
      "files": [
        {
          "filename": "cloudinit/config/cc_set_passwords.py",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -78,7 +78,6 @@\n \"\"\"\n \n import re\n-import sys\n \n from cloudinit.distros import ug_util\n from cloudinit import log as logging\n@@ -214,7 +213,9 @@ def handle(_name, cfg, cloud, log, args):\n         if len(randlist):\n             blurb = (\"Set the following 'random' passwords\\n\",\n                      '\\n'.join(randlist))\n-            sys.stderr.write(\"%s\\n%s\\n\" % blurb)\n+            util.multi_log(\n+                \"%s\\n%s\\n\" % blurb, stderr=False, fallback_to_stdout=False\n+            )\n \n         if expire:\n             expired_users = []"
        },
        {
          "filename": "cloudinit/config/tests/test_set_passwords.py",
          "status": "modified",
          "additions": 30,
          "deletions": 10,
          "patch": "@@ -74,10 +74,6 @@ class TestSetPasswordsHandle(CiTestCase):\n \n     with_logs = True\n \n-    def setUp(self):\n-        super(TestSetPasswordsHandle, self).setUp()\n-        self.add_patch('cloudinit.config.cc_set_passwords.sys.stderr', 'm_err')\n-\n     def test_handle_on_empty_config(self, *args):\n         \"\"\"handle logs that no password has changed when config is empty.\"\"\"\n         cloud = self.tmp_cloud(distro='ubuntu')\n@@ -129,10 +125,12 @@ def test_bsd_calls_custom_pw_cmds_to_set_and_expire_passwords(\n             mock.call(['pw', 'usermod', 'ubuntu', '-p', '01-Jan-1970'])],\n             m_subp.call_args_list)\n \n+    @mock.patch(MODPATH + \"util.multi_log\")\n     @mock.patch(MODPATH + \"util.is_BSD\")\n     @mock.patch(MODPATH + \"subp.subp\")\n-    def test_handle_on_chpasswd_list_creates_random_passwords(self, m_subp,\n-                                                              m_is_bsd):\n+    def test_handle_on_chpasswd_list_creates_random_passwords(\n+        self, m_subp, m_is_bsd, m_multi_log\n+    ):\n         \"\"\"handle parses command set random passwords.\"\"\"\n         m_is_bsd.return_value = False\n         cloud = self.tmp_cloud(distro='ubuntu')\n@@ -146,10 +144,32 @@ def test_handle_on_chpasswd_list_creates_random_passwords(self, m_subp,\n         self.assertIn(\n             'DEBUG: Handling input for chpasswd as list.',\n             self.logs.getvalue())\n-        self.assertNotEqual(\n-            [mock.call(['chpasswd'],\n-             '\\n'.join(valid_random_pwds) + '\\n')],\n-            m_subp.call_args_list)\n+\n+        self.assertEqual(1, m_subp.call_count)\n+        args, _kwargs = m_subp.call_args\n+        self.assertEqual([\"chpasswd\"], args[0])\n+\n+        stdin = args[1]\n+        user_pass = {\n+            user: password\n+            for user, password\n+            in (line.split(\":\") for line in stdin.splitlines())\n+        }\n+\n+        self.assertEqual(1, m_multi_log.call_count)\n+        self.assertEqual(\n+            mock.call(mock.ANY, stderr=False, fallback_to_stdout=False),\n+            m_multi_log.call_args\n+        )\n+\n+        self.assertEqual(set([\"root\", \"ubuntu\"]), set(user_pass.keys()))\n+        written_lines = m_multi_log.call_args[0][0].splitlines()\n+        for password in user_pass.values():\n+            for line in written_lines:\n+                if password in line:\n+                    break\n+            else:\n+                self.fail(\"Password not emitted to console\")\n \n \n # vi: ts=4 expandtab"
        },
        {
          "filename": "cloudinit/tests/test_util.py",
          "status": "modified",
          "additions": 56,
          "deletions": 0,
          "patch": "@@ -851,4 +851,60 @@ def test_static_parameters_are_passed(self, m_write_file):\n         assert \"ab\" == kwargs[\"omode\"]\n \n \n+@mock.patch(\"cloudinit.util.grp.getgrnam\")\n+@mock.patch(\"cloudinit.util.os.setgid\")\n+@mock.patch(\"cloudinit.util.os.umask\")\n+class TestRedirectOutputPreexecFn:\n+    \"\"\"This tests specifically the preexec_fn used in redirect_output.\"\"\"\n+\n+    @pytest.fixture(params=[\"outfmt\", \"errfmt\"])\n+    def preexec_fn(self, request):\n+        \"\"\"A fixture to gather the preexec_fn used by redirect_output.\n+\n+        This enables simpler direct testing of it, and parameterises any tests\n+        using it to cover both the stdout and stderr code paths.\n+        \"\"\"\n+        test_string = \"| piped output to invoke subprocess\"\n+        if request.param == \"outfmt\":\n+            args = (test_string, None)\n+        elif request.param == \"errfmt\":\n+            args = (None, test_string)\n+        with mock.patch(\"cloudinit.util.subprocess.Popen\") as m_popen:\n+            util.redirect_output(*args)\n+\n+        assert 1 == m_popen.call_count\n+        _args, kwargs = m_popen.call_args\n+        assert \"preexec_fn\" in kwargs, \"preexec_fn not passed to Popen\"\n+        return kwargs[\"preexec_fn\"]\n+\n+    def test_preexec_fn_sets_umask(\n+        self, m_os_umask, _m_setgid, _m_getgrnam, preexec_fn\n+    ):\n+        \"\"\"preexec_fn should set a mask that avoids world-readable files.\"\"\"\n+        preexec_fn()\n+\n+        assert [mock.call(0o037)] == m_os_umask.call_args_list\n+\n+    def test_preexec_fn_sets_group_id_if_adm_group_present(\n+        self, _m_os_umask, m_setgid, m_getgrnam, preexec_fn\n+    ):\n+        \"\"\"We should setgrp to adm if present, so files are owned by them.\"\"\"\n+        fake_group = mock.Mock(gr_gid=mock.sentinel.gr_gid)\n+        m_getgrnam.return_value = fake_group\n+\n+        preexec_fn()\n+\n+        assert [mock.call(\"adm\")] == m_getgrnam.call_args_list\n+        assert [mock.call(mock.sentinel.gr_gid)] == m_setgid.call_args_list\n+\n+    def test_preexec_fn_handles_absent_adm_group_gracefully(\n+        self, _m_os_umask, m_setgid, m_getgrnam, preexec_fn\n+    ):\n+        \"\"\"We should handle an absent adm group gracefully.\"\"\"\n+        m_getgrnam.side_effect = KeyError(\"getgrnam(): name not found: 'adm'\")\n+\n+        preexec_fn()\n+\n+        assert 0 == m_setgid.call_count\n+\n # vi: ts=4 expandtab"
        },
        {
          "filename": "cloudinit/util.py",
          "status": "modified",
          "additions": 34,
          "deletions": 4,
          "patch": "@@ -359,7 +359,7 @@ def find_modules(root_dir):\n \n \n def multi_log(text, console=True, stderr=True,\n-              log=None, log_level=logging.DEBUG):\n+              log=None, log_level=logging.DEBUG, fallback_to_stdout=True):\n     if stderr:\n         sys.stderr.write(text)\n     if console:\n@@ -368,7 +368,7 @@ def multi_log(text, console=True, stderr=True,\n             with open(conpath, 'w') as wfh:\n                 wfh.write(text)\n                 wfh.flush()\n-        else:\n+        elif fallback_to_stdout:\n             # A container may lack /dev/console (arguably a container bug).  If\n             # it does not exist, then write output to stdout.  this will result\n             # in duplicate stderr and stdout messages if stderr was True.\n@@ -623,6 +623,26 @@ def redirect_output(outfmt, errfmt, o_out=None, o_err=None):\n     if not o_err:\n         o_err = sys.stderr\n \n+    # pylint: disable=subprocess-popen-preexec-fn\n+    def set_subprocess_umask_and_gid():\n+        \"\"\"Reconfigure umask and group ID to create output files securely.\n+\n+        This is passed to subprocess.Popen as preexec_fn, so it is executed in\n+        the context of the newly-created process.  It:\n+\n+        * sets the umask of the process so created files aren't world-readable\n+        * if an adm group exists in the system, sets that as the process' GID\n+          (so that the created file(s) are owned by root:adm)\n+        \"\"\"\n+        os.umask(0o037)\n+        try:\n+            group_id = grp.getgrnam(\"adm\").gr_gid\n+        except KeyError:\n+            # No adm group, don't set a group\n+            pass\n+        else:\n+            os.setgid(group_id)\n+\n     if outfmt:\n         LOG.debug(\"Redirecting %s to %s\", o_out, outfmt)\n         (mode, arg) = outfmt.split(\" \", 1)\n@@ -632,7 +652,12 @@ def redirect_output(outfmt, errfmt, o_out=None, o_err=None):\n                 owith = \"wb\"\n             new_fp = open(arg, owith)\n         elif mode == \"|\":\n-            proc = subprocess.Popen(arg, shell=True, stdin=subprocess.PIPE)\n+            proc = subprocess.Popen(\n+                arg,\n+                shell=True,\n+                stdin=subprocess.PIPE,\n+                preexec_fn=set_subprocess_umask_and_gid,\n+            )\n             new_fp = proc.stdin\n         else:\n             raise TypeError(\"Invalid type for output format: %s\" % outfmt)\n@@ -654,7 +679,12 @@ def redirect_output(outfmt, errfmt, o_out=None, o_err=None):\n                 owith = \"wb\"\n             new_fp = open(arg, owith)\n         elif mode == \"|\":\n-            proc = subprocess.Popen(arg, shell=True, stdin=subprocess.PIPE)\n+            proc = subprocess.Popen(\n+                arg,\n+                shell=True,\n+                stdin=subprocess.PIPE,\n+                preexec_fn=set_subprocess_umask_and_gid,\n+            )\n             new_fp = proc.stdin\n         else:\n             raise TypeError(\"Invalid type for error format: %s\" % errfmt)"
        },
        {
          "filename": "tests/integration_tests/modules/test_set_password.py",
          "status": "modified",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -116,6 +116,30 @@ def test_random_passwords_set_correctly(self, class_client):\n         # Which are not the same\n         assert shadow_users[\"harry\"] != shadow_users[\"dick\"]\n \n+    def test_random_passwords_not_stored_in_cloud_init_output_log(\n+        self, class_client\n+    ):\n+        \"\"\"We should not emit passwords to the in-instance log file.\n+\n+        LP: #1918303\n+        \"\"\"\n+        cloud_init_output = class_client.read_from_file(\n+            \"/var/log/cloud-init-output.log\"\n+        )\n+        assert \"dick:\" not in cloud_init_output\n+        assert \"harry:\" not in cloud_init_output\n+\n+    def test_random_passwords_emitted_to_serial_console(self, class_client):\n+        \"\"\"We should emit passwords to the serial console. (LP: #1918303)\"\"\"\n+        try:\n+            console_log = class_client.instance.console_log()\n+        except NotImplementedError:\n+            # Assume that an exception here means that we can't use the console\n+            # log\n+            pytest.skip(\"NotImplementedError when requesting console log\")\n+        assert \"dick:\" in console_log\n+        assert \"harry:\" in console_log\n+\n     def test_explicit_password_set_correctly(self, class_client):\n         \"\"\"Test that an explicitly-specified password is set correctly.\"\"\"\n         shadow_users, _ = self._fetch_and_parse_etc_shadow(class_client)"
        },
        {
          "filename": "tests/integration_tests/test_logging.py",
          "status": "added",
          "additions": 22,
          "deletions": 0,
          "patch": "@@ -0,0 +1,22 @@\n+\"\"\"Integration tests relating to cloud-init's logging.\"\"\"\n+\n+\n+class TestVarLogCloudInitOutput:\n+    \"\"\"Integration tests relating to /var/log/cloud-init-output.log.\"\"\"\n+\n+    def test_var_log_cloud_init_output_not_world_readable(self, client):\n+        \"\"\"\n+        The log can contain sensitive data, it shouldn't be world-readable.\n+\n+        LP: #1918303\n+        \"\"\"\n+        # Check the file exists\n+        assert client.execute(\"test -f /var/log/cloud-init-output.log\").ok\n+\n+        # Check its permissions are as we expect\n+        perms, user, group = client.execute(\n+            \"stat -c %a:%U:%G /var/log/cloud-init-output.log\"\n+        ).split(\":\")\n+        assert \"640\" == perms\n+        assert \"root\" == user\n+        assert \"adm\" == group"
        },
        {
          "filename": "tests/unittests/test_util.py",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -572,6 +572,10 @@ def test_logs_go_to_stdout_if_console_does_not_exist(self):\n         util.multi_log(logged_string)\n         self.assertEqual(logged_string, self.stdout.getvalue())\n \n+    def test_logs_dont_go_to_stdout_if_fallback_to_stdout_is_false(self):\n+        util.multi_log('something', fallback_to_stdout=False)\n+        self.assertEqual('', self.stdout.getvalue())\n+\n     def test_logs_go_to_log_if_given(self):\n         log = mock.MagicMock()\n         logged_string = 'something very important'"
        }
      ],
      "file_patterns": {
        "security_files": 3,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 5,
        "unique_directories": 7,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "6cdf51ad5aa498e77126c330dc71b6578d710629",
            "date": "2025-01-13T19:39:48Z",
            "author_login": "holmanb"
          },
          {
            "sha": "38acce473626dc749dfb8bf3602e294df554c781",
            "date": "2025-01-10T18:02:52Z",
            "author_login": "ani-sinha"
          },
          {
            "sha": "1e719e3c190d2b94a4e2d7451ab13319b5944068",
            "date": "2025-01-08T22:43:33Z",
            "author_login": "holmanb"
          },
          {
            "sha": "f97e5fbc4ca23549cea01116af7f64bd670e2a9a",
            "date": "2025-01-07T19:40:43Z",
            "author_login": "TheRealFalcon"
          },
          {
            "sha": "168f821e106e8950fef0702a81c178d8e5a95924",
            "date": "2025-01-07T19:39:37Z",
            "author_login": "TheRealFalcon"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-532",
    "description": "When instructing cloud-init to set a random password for a new user account, versions before 21.2 would write that password to the world-readable log file /var/log/cloud-init-output.log. This could allow a local user to log in as another user.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-04-19T22:15:10.137",
    "last_modified": "2024-11-21T06:21:29.237",
    "fix_date": "2021-03-19T14:06:42Z"
  },
  "references": [
    {
      "url": "https://github.com/canonical/cloud-init/commit/b794d426b9ab43ea9d6371477466070d86e10668",
      "source": "security@ubuntu.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/canonical/cloud-init/commit/b794d426b9ab43ea9d6371477466070d86e10668",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:11.816413",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "cloud-init",
    "owner": "canonical",
    "created_at": "2014-10-08T15:54:41Z",
    "updated_at": "2025-01-14T05:07:02Z",
    "pushed_at": "2025-01-13T22:09:48Z",
    "size": 39098,
    "stars": 3065,
    "forks": 897,
    "open_issues": 555,
    "watchers": 3065,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Python": 6253678,
      "Shell": 146302,
      "Makefile": 4390
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:04:56.926675"
  }
}