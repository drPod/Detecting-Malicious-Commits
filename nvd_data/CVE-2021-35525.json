{
  "cve_id": "CVE-2021-35525",
  "github_data": {
    "repository": "roehling/postsrsd",
    "fix_commit": "077be98d8c8a9847e4ae0c7dc09e7474cbe27db2",
    "related_commits": [
      "077be98d8c8a9847e4ae0c7dc09e7474cbe27db2",
      "077be98d8c8a9847e4ae0c7dc09e7474cbe27db2"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "077be98d8c8a9847e4ae0c7dc09e7474cbe27db2",
      "commit_date": "2021-03-21T14:27:55Z",
      "author": {
        "login": "roehling",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "SECURITY: Fix DoS on overly long input from Postfix",
        "length": 762,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 96,
        "additions": 69,
        "deletions": 27
      },
      "files": [
        {
          "filename": "postsrsd.c",
          "status": "modified",
          "additions": 33,
          "deletions": 23,
          "patch": "@@ -645,7 +645,7 @@ int main(int argc, char **argv)\n     while (TRUE)\n     {\n         int conn;\n-        FILE *fp;\n+        FILE *fp_read, *fp_write;\n         char linebuf[1024], *line;\n         char keybuf[1024], *key;\n \n@@ -674,47 +674,57 @@ int main(int argc, char **argv)\n                      * daemon process from restarting */\n                     for (i = 0; i < socket_count; ++i)\n                         close(sockets[i]);\n-\n-                    fp = fdopen(conn, \"r+\");\n-                    if (fp == NULL)\n-                        exit(EXIT_FAILURE);\n-                    fds[0].fd = conn;\n-                    fds[0].events = POLLIN;\n-                    if (poll(fds, 1, timeout * 1000) <= 0)\n+                    /* create separate input/output streams */\n+                    fp_read = fdopen(conn, \"r\");\n+                    if (fp_read == NULL)\n+                        return EXIT_FAILURE;\n+                    fp_write = fdopen(dup(conn), \"w\");\n+                    if (fp_write == NULL)\n                         return EXIT_FAILURE;\n-                    line = fgets(linebuf, sizeof(linebuf), fp);\n-                    while (line)\n+                    errno = 0;\n+                    alarm(timeout);\n+                    if (errno != 0)\n+                        return EXIT_FAILURE;\n+                    while ((line = fgets(linebuf, sizeof(linebuf), fp_read)))\n                     {\n-                        fseek(fp, 0, SEEK_CUR); /* Workaround for Solaris */\n                         char *token;\n+                        alarm(0);\n+                        if (strlen(line) >= sizeof(linebuf) - 1)\n+                        {\n+                            fprintf(fp_write, \"500 Invalid request\\n\");\n+                            fflush(fp_write);\n+                            return EXIT_FAILURE;\n+                        }\n                         token = strtok(line, \" \\r\\n\");\n                         if (token == NULL || strcmp(token, \"get\") != 0)\n                         {\n-                            fprintf(fp, \"500 Invalid request\\n\");\n-                            fflush(fp);\n+                            fprintf(fp_write, \"500 Invalid request\\n\");\n+                            fflush(fp_write);\n                             return EXIT_FAILURE;\n                         }\n                         token = strtok(NULL, \"\\r\\n\");\n                         if (!token)\n                         {\n-                            fprintf(fp, \"500 Invalid request\\n\");\n-                            fflush(fp);\n+                            fprintf(fp_write, \"500 Invalid request\\n\");\n+                            fflush(fp_write);\n                             return EXIT_FAILURE;\n                         }\n                         key = url_decode(keybuf, sizeof(keybuf), token);\n                         if (!key)\n                         {\n-                            fprintf(fp, \"500 Invalid request\\n\");\n-                            fflush(fp);\n+                            fprintf(fp_write, \"500 Invalid request\\n\");\n+                            fflush(fp_write);\n                             return EXIT_FAILURE;\n                         }\n-                        handler[sc](srs, fp, key, domain, excludes);\n-                        fflush(fp);\n-                        if (poll(fds, 1, timeout * 1000) <= 0)\n-                            break;\n-                        line = fgets(linebuf, sizeof(linebuf), fp);\n+                        handler[sc](srs, fp_write, key, domain, excludes);\n+                        fflush(fp_write);\n+                        errno = 0;\n+                        alarm(timeout);\n+                        if (errno != 0)\n+                            return EXIT_FAILURE;\n                     }\n-                    fclose(fp);\n+                    fclose(fp_write);\n+                    fclose(fp_read);\n                     return EXIT_SUCCESS;\n                 }\n                 close(conn);"
        },
        {
          "filename": "run_postsrsd_tests.bats",
          "status": "modified",
          "additions": 36,
          "deletions": 4,
          "patch": "@@ -3,7 +3,7 @@\n \n if [ ! -x \"$POSTSRSD\" ]\n then\n-\tfor builddir in . build* obj*\n+\tfor builddir in . build* obj* _build*\n \tdo\n \t\tif [ -x \"${builddir}/postsrsd\" ]\n \t\tthen\n@@ -15,7 +15,7 @@ fi\n if [ ! -x \"$POSTSRSD\" ]\n then\n \tcat>&2 <<- EOF\n-\tcannot find postsrsd executable (looked in ., build*, obj*)\n+\tcannot find postsrsd executable (looked in ., build*, obj*, _build*)\n \tplease build the executable first, or set the POSTSRSD\n \tenvironment variable if it is in a different location.\n \n@@ -26,12 +26,19 @@ fi\n LANG=C.UTF-8\n \n \n+fillchar()\n+{\n+        local count=\"$1\"\n+        local char=\"$2\"\n+        eval 'printf \"'\"$char\"'%.0s\" {1..'\"$count\"'}'\n+}\n+\n start_postsrsd_at()\n {\n \techo 'tops3cr3t' > \"$BATS_TMPDIR/postsrsd.secret\"\n \tlocal faketime=\"$1\"\n \tshift\n-\tfaketime \"${faketime}\" ${POSTSRSD} -D -f 10001 -r 10002 -p \"$BATS_TMPDIR/postsrsd.pid\" -s \"$BATS_TMPDIR/postsrsd.secret\" -d example.com \"$@\"\n+\tfaketime \"${faketime}\" ${POSTSRSD} -D -t1 -f 10001 -r 10002 -p \"$BATS_TMPDIR/postsrsd.pid\" -s \"$BATS_TMPDIR/postsrsd.secret\" -d example.com \"$@\"\n }\n \n stop_postsrsd()\n@@ -159,7 +166,7 @@ teardown()\n \t[[ \"$line\" =~ ^\"500 Domain excluded\" ]]\n }\n \n-@test \"SRS invalid requests\" {\n+@test \"Malformed or invalid requests\" {\n \tstart_postsrsd_at \"2020-01-01 00:01:00 UTC\"\n \texec 9<>/dev/tcp/127.0.0.1/10001\n \techo>&9 \"get\"\n@@ -173,4 +180,29 @@ teardown()\n \techo>&9 \"get encoding%error@otherdomain.com\"\n \tread<&9 line\n \t[[ \"$line\" =~ ^500 ]]\n+\texec 9<>/dev/tcp/127.0.0.1/10001\n+\t# Try to overflow the input buffer\n+\techo>&9 \"get too_long@`fillchar 1024 a`.com\"\n+\tread<&9 line\n+\t[[ \"$line\" =~ ^500 ]]\n+}\n+\n+@test \"Pipelining multiple requests\" {\n+\tstart_postsrsd_at \"2020-01-01 00:01:00 UTC\"\n+\texec 9<>/dev/tcp/127.0.0.1/10001\n+\t# Send two requests at once and see if PostSRSd answers both\n+\techo>&9 -e \"get test@domain1.com\\nget test@domain2.com\"\n+\tread<&9 line\n+\t[[ \"$line\" =~ ^200 ]]\n+\tread<&9 line\n+\t[[ \"$line\" =~ ^200 ]]\n+}\n+\n+@test \"Session timeout\" {\n+\tstart_postsrsd_at \"2020-01-01 00:01:00 UTC\"\n+\texec 9<>/dev/tcp/127.0.0.1/10001\n+\t# Wait until PostSRSd disconnects due to inactivity\n+\tsleep 2\n+\techo >&9 \"get test@example.com\"\n+\t! read <&9 line\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "6c6bf1b2ba8f9eba678823e6f8d6ba108d66424e",
            "date": "2024-11-28T12:09:30Z",
            "author_login": "roehling"
          },
          {
            "sha": "baa7f671fbc32218bb83bcae3e50748b2c3046aa",
            "date": "2024-11-28T11:33:03Z",
            "author_login": "roehling"
          },
          {
            "sha": "9acb88a511bc28b1c2ed3cfbd9aa2c5ace45d30b",
            "date": "2024-10-01T07:02:12Z",
            "author_login": "pre-commit-ci[bot]"
          },
          {
            "sha": "634b5903575ff7f6704c5d08a59e6f4c63b22aa0",
            "date": "2024-07-23T08:26:27Z",
            "author_login": "roehling"
          },
          {
            "sha": "3def248512660ef353382ce00a8fa42d00c2c878",
            "date": "2024-07-23T08:18:11Z",
            "author_login": "roehling"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": null,
    "description": "PostSRSd before 1.11 allows a denial of service (subprocess hang) if Postfix sends certain long data fields such as multiple concatenated email addresses. NOTE: the PostSRSd maintainer acknowledges \"theoretically, this error should never occur ... I'm not sure if there's a reliable way to trigger this condition by an external attacker, but it is a security bug in PostSRSd nevertheless.\"",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-06-28T18:15:08.030",
    "last_modified": "2024-11-21T06:12:26.560",
    "fix_date": "2021-03-21T14:27:55Z"
  },
  "references": [
    {
      "url": "https://bugs.gentoo.org/793674",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/roehling/postsrsd/commit/077be98d8c8a9847e4ae0c7dc09e7474cbe27db2",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/roehling/postsrsd/releases/tag/1.11",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202107-08",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugs.gentoo.org/793674",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/roehling/postsrsd/commit/077be98d8c8a9847e4ae0c7dc09e7474cbe27db2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/roehling/postsrsd/releases/tag/1.11",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202107-08",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:01:59.762570",
    "processing_status": "enhanced"
  }
}