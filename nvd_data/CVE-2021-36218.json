{
  "cve_id": "CVE-2021-36218",
  "github_data": {
    "repository": "skalenetwork/sgxwallet",
    "fix_commit": "77425c862ad20cd270d42c54f3d63e1eb4e02195",
    "related_commits": [
      "77425c862ad20cd270d42c54f3d63e1eb4e02195",
      "77425c862ad20cd270d42c54f3d63e1eb4e02195"
    ],
    "patch_url": "https://github.com/skalenetwork/sgxwallet/commit/77425c862ad20cd270d42c54f3d63e1eb4e02195.patch",
    "fix_commit_details": {
      "sha": "77425c862ad20cd270d42c54f3d63e1eb4e02195",
      "commit_date": "2020-09-08T12:30:59Z",
      "author": {
        "login": "kladkogex",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "SKALE-3205-restart",
        "length": 18,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 288,
        "additions": 131,
        "deletions": 157
      },
      "files": [
        {
          "filename": "BLSCrypto.cpp",
          "status": "modified",
          "additions": 5,
          "deletions": 4,
          "patch": "@@ -86,7 +86,7 @@ void carray2Hex(const unsigned char *d, uint64_t _len, char *_hexArray,\n \n     CHECK_STATE(_hexArrayLen > 2 * _len);\n \n-    for (int j = 0; j < _len; j++) {\n+    for (uint64_t j = 0; j < _len; j++) {\n         _hexArray[j * 2] = hexval[((d[j] >> 4) & 0xF)];\n         _hexArray[j * 2 + 1] = hexval[(d[j]) & 0x0F];\n     }\n@@ -105,7 +105,7 @@ bool hex2carray(const char *_hex, uint64_t *_bin_len,\n     CHECK_STATE(_bin_len)\n \n \n-    int len = strnlen(_hex, 2 * _max_length + 1);\n+    uint64_t len = strnlen(_hex, 2 * _max_length + 1);\n \n     CHECK_STATE(len != 2 * _max_length + 1);\n \n@@ -117,7 +117,7 @@ bool hex2carray(const char *_hex, uint64_t *_bin_len,\n \n     *_bin_len = len / 2;\n \n-    for (int i = 0; i < len / 2; i++) {\n+    for (uint64_t i = 0; i < len / 2; i++) {\n         int high = char2int((char) _hex[i * 2]);\n         int low = char2int((char) _hex[i * 2 + 1]);\n \n@@ -247,7 +247,8 @@ string encryptBLSKeyShare2Hex(int *errStatus, char *err_string, const char *_key\n \n     strncpy(keyArray->data(), _key, BUF_LEN);\n     *errStatus = 0;\n-    unsigned int encryptedLen = 0;\n+\n+    uint64_t encryptedLen = 0;\n \n     sgx_status_t status = trustedEncryptKeyAES(eid, errStatus, errMsg.data(), keyArray->data(), encryptedKey->data(), &encryptedLen);\n "
        },
        {
          "filename": "DKGCrypto.cpp",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -135,13 +135,13 @@ string convertG2ToString(const libff::alt_bn128_G2 &elem, int base, const string\n string gen_dkg_poly(int _t) {\n     vector<char> errMsg(BUF_LEN, 0);\n     int errStatus = 0;\n-    uint32_t enc_len = 0;\n+    uint64_t enc_len = 0;\n \n     vector <uint8_t> encrypted_dkg_secret(BUF_LEN, 0);\n \n+    sgx_status_t status = trustedGenDkgSecretAES(\n+            eid, &errStatus,errMsg.data(), encrypted_dkg_secret.data(), &enc_len, _t);\n \n-\n-    sgx_status_t status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encrypted_dkg_secret.data(), &enc_len, _t);\n     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n \n     uint64_t length = enc_len;;\n@@ -214,7 +214,7 @@ getSecretShares(const string &_polyName, const char *_encryptedPolyHex, const ve\n \n     for (int i = 0; i < _n; i++) {\n         vector <uint8_t> encryptedSkey(BUF_LEN, 0);\n-        uint32_t decLen;\n+        uint64_t decLen;\n         vector<char> currentShare(193, 0);\n         vector<char> sShareG2(320, 0);\n \n@@ -300,7 +300,7 @@ bool createBLSShare(const string &blsKeyName, const char *s_shares, const char *\n         throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");\n     }\n \n-    uint32_t enc_bls_len = 0;\n+    uint64_t enc_bls_len = 0;\n \n     sgx_status_t status = trustedCreateBlsKeyAES(eid, &errStatus, errMsg.data(), s_shares, encr_key, decKeyLen, encr_bls_key,\n                                                  &enc_bls_len);"
        },
        {
          "filename": "ECDSACrypto.cpp",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -54,7 +54,7 @@ vector <string> genECDSAKey() {\n     vector<char> pub_key_x(BUF_LEN, 0);\n     vector<char> pub_key_y(BUF_LEN, 0);\n \n-    uint32_t enc_len = 0;\n+    uint64_t enc_len = 0;\n \n     sgx_status_t status = trustedGenerateEcdsaKeyAES(eid, &errStatus,\n                                         errMsg.data(), encr_pr_key.data(), &enc_len,"
        },
        {
          "filename": "SEKManager.cpp",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -52,7 +52,7 @@ bool case_insensitive_match(string s1, string s2) {\n void create_test_key() {\n     int errStatus = 0;\n     vector<char> errMsg(1024, 0);\n-    uint32_t enc_len;\n+    uint64_t enc_len;\n \n     SAFE_UINT8_BUF(encrypted_key, BUF_LEN);\n \n@@ -109,7 +109,7 @@ shared_ptr <vector<uint8_t>> check_and_set_SEK(const string &SEK) {\n \n     auto encrypted_SEK = make_shared < vector < uint8_t >> (BUF_LEN, 0);\n \n-    uint32_t l = 0;\n+    uint64_t l = 0;\n \n     sgx_status_t status = trustedSetSEK_backup(eid, &err_status, errMsg.data(), encrypted_SEK->data(), &l,\n                                                SEK.c_str());\n@@ -127,7 +127,7 @@ void gen_SEK() {\n     vector<char> errMsg(1024, 0);\n     int err_status = 0;\n     vector <uint8_t> encrypted_SEK(1024, 0);\n-    uint32_t enc_len = 0;\n+    uint64_t enc_len = 0;\n \n     SAFE_CHAR_BUF(SEK, 65);\n "
        },
        {
          "filename": "SGXWalletServer.cpp",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -563,7 +563,7 @@ Json::Value SGXWalletServer::calculateAllBLSPublicKeysImpl(const Json::Value& pu\n \n         vector<string> public_keys = calculateAllBlsPublicKeys(public_shares);\n \n-        if (public_keys.size() != n) {\n+        if (public_keys.size() != (uint64_t)n) {\n             throw SGXException(UNKNOWN_ERROR, \"\");\n         }\n "
        },
        {
          "filename": "secure_enclave/AESUtils.c",
          "status": "modified",
          "additions": 31,
          "deletions": 67,
          "patch": "@@ -27,12 +27,24 @@\n #include \"stdlib.h\"\n #include <string.h>\n \n+\n #include \"AESUtils.h\"\n \n sgx_aes_gcm_128bit_key_t AES_key;\n sgx_aes_gcm_128bit_key_t AES_DH_key;\n \n-int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen) {\n+\n+#define SAFE_CHAR_BUF(__X__, __Y__)  ;char __X__ [ __Y__ ]; memset(__X__, 0, __Y__);\n+\n+int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrBufLen, unsigned  char type,\n+                unsigned char decryptable, uint64_t* resultLen) {\n+\n+\n+\n+    if (!type) {\n+        LOG_ERROR(\"Null type in AES_encrypt\");\n+        return -1;\n+    }\n \n     if (!message) {\n         LOG_ERROR(\"Null message in AES_encrypt\");\n@@ -46,19 +58,31 @@ int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen) {\n \n     uint64_t len = strlen(message) + 1;\n \n-    if (len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrLen ) {\n+    if (2 + len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrBufLen ) {\n         LOG_ERROR(\"Output buffer too small\");\n         return -3;\n     }\n \n+    SAFE_CHAR_BUF(fullMessage, len + 2);\n+\n+    fullMessage[0] = type;\n+    fullMessage[1] = decryptable;\n+\n+    strncpy(fullMessage + 2, message, len );\n+\n+    len = len + 2;\n+    message = fullMessage;\n+\n     sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);\n \n-    sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, strlen(message),\n+    sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, len,\n                                                      encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE,\n                                                      encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n                                                      NULL, 0,\n                                                      (sgx_aes_gcm_128bit_tag_t *) encr_message);\n \n+    *resultLen = len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n+\n     return status;\n }\n \n@@ -96,78 +120,18 @@ int AES_decrypt(uint8_t *encr_message, uint64_t length, char *message, uint64_t\n                                                    NULL, 0,\n                                                    (sgx_aes_gcm_128bit_tag_t *)encr_message);\n \n-  return status;\n-}\n-\n-\n-\n-\n-int AES_encrypt_DH(char *message, uint8_t *encr_message, uint64_t encrLen) {\n-\n-    if (!message) {\n-        LOG_ERROR(\"Null message in AES_encrypt_DH\");\n-        return -1;\n-    }\n-\n-    if (!encr_message) {\n-        LOG_ERROR(\"Null encr message in AES_encrypt_DH\");\n-        return -2;\n-    }\n-\n-    uint64_t len = strlen(message) + 1;\n-\n-    if (len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrLen ) {\n-        LOG_ERROR(\"Output buffer too small\");\n-        return -3;\n-    }\n-\n-    sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);\n-\n-    sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_DH_key, (uint8_t*)message, strlen(message),\n-                                                     encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE,\n-                                                     encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n-                                                     NULL, 0,\n-                                                     (sgx_aes_gcm_128bit_tag_t *) encr_message);\n+  for (int i = 2; i < strlen(message) + 1; i++) {\n+      message[i - 2 ] = message[i];\n+  }\n \n-    return status;\n+  return status;\n }\n \n-int AES_decrypt_DH(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) {\n \n-    if (!message) {\n-        LOG_ERROR(\"Null message in AES_encrypt_DH\");\n-        return -1;\n-    }\n-\n-    if (!encr_message) {\n-        LOG_ERROR(\"Null encr message in AES_encrypt_DH\");\n-        return -2;\n-    }\n-\n-\n-    if (length < SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE) {\n-        LOG_ERROR(\"length < SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE\");\n-        return -1;\n-    }\n \n \n \n-    uint64_t len = length - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE;\n \n-    if (msgLen < len) {\n-        LOG_ERROR(\"Output buffer not large enough\");\n-        return -2;\n-    }\n-\n-    sgx_status_t status = sgx_rijndael128GCM_decrypt(&AES_DH_key,\n-                                                     encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, len,\n-                                                     (unsigned char*) message,\n-                                                     encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n-                                                     NULL, 0,\n-                                                     (sgx_aes_gcm_128bit_tag_t *)encr_message);\n-\n-    return status;\n-}\n \n \n "
        },
        {
          "filename": "secure_enclave/AESUtils.h",
          "status": "modified",
          "additions": 10,
          "deletions": 1,
          "patch": "@@ -27,13 +27,22 @@\n extern sgx_aes_gcm_128bit_key_t AES_key;\n extern sgx_aes_gcm_128bit_key_t AES_DH_key;\n \n-int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen);\n+int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen,\n+                unsigned char type, unsigned char decryptable, uint64_t* resultLen);\n int AES_decrypt(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) ;\n \n int AES_encrypt_DH(char *message, uint8_t *encr_message, uint64_t encrLen);\n int AES_decrypt_DH(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) ;\n \n void derive_DH_Key();\n \n+#define ECDSA '1'\n+#define BLS '2'\n+#define DKG '3'\n+\n+#define DECRYPTABLE '1'\n+#define NON_DECRYPTABLE '2'\n+\n+\n \n #endif //SGXD_AESUTILS_H"
        },
        {
          "filename": "secure_enclave/secure_enclave.c",
          "status": "modified",
          "additions": 52,
          "deletions": 53,
          "patch": "@@ -122,7 +122,7 @@ unsigned char *globalRandom = NULL;\n         abort(); \\\n     } else {called = true;};\n \n-void trustedEnclaveInit(uint32_t _logLevel) {\n+void trustedEnclaveInit(uint64_t _logLevel) {\n     CALL_ONCE\n     LOG_INFO(__FUNCTION__);\n \n@@ -232,7 +232,7 @@ void get_global_random(unsigned char *_randBuff, uint64_t _size) {\n \n \n void sealHexSEK(int *errStatus, char *errString,\n-                        uint8_t *encrypted_sek, uint32_t *enc_len, char *sek_hex) {\n+                        uint8_t *encrypted_sek, uint64_t *enc_len, char *sek_hex) {\n     CALL_ONCE\n     LOG_INFO(__FUNCTION__);\n     INIT_ERROR_STATE\n@@ -255,15 +255,15 @@ void sealHexSEK(int *errStatus, char *errString,\n                                            (sgx_sealed_data_t *) encrypted_sek);\n     CHECK_STATUS(\"seal SEK failed after SEK generation\");\n \n-    uint32_t encrypt_text_length = sgx_get_encrypt_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n+    uint64_t encrypt_text_length = sgx_get_encrypt_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n \n     CHECK_STATE(encrypt_text_length = plaintextLen);\n \n \n     SAFE_CHAR_BUF(unsealedKey, BUF_LEN);\n     uint32_t decLen = BUF_LEN;\n \n-    uint32_t add_text_length = sgx_get_add_mac_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n+    uint64_t add_text_length = sgx_get_add_mac_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n     CHECK_STATE(add_text_length == 0);\n     CHECK_STATE(sgx_is_within_enclave(encrypted_sek,sizeof(sgx_sealed_data_t)));\n     status = sgx_unseal_data((const sgx_sealed_data_t *)encrypted_sek, NULL, NULL,\n@@ -279,7 +279,7 @@ void sealHexSEK(int *errStatus, char *errString,\n }\n \n void trustedGenerateSEK(int *errStatus, char *errString,\n-                        uint8_t *encrypted_sek, uint32_t *enc_len, char *sek_hex) {\n+                        uint8_t *encrypted_sek, uint64_t *enc_len, char *sek_hex) {\n     CALL_ONCE\n     LOG_INFO(__FUNCTION__);\n     INIT_ERROR_STATE\n@@ -341,7 +341,7 @@ void trustedSetSEK(int *errStatus, char *errString, uint8_t *encrypted_sek) {\n }\n \n void trustedSetSEK_backup(int *errStatus, char *errString,\n-                          uint8_t *encrypted_sek, uint32_t *enc_len, const char *sek_hex) {\n+                          uint8_t *encrypted_sek, uint64_t *enc_len, const char *sek_hex) {\n     CALL_ONCE\n     LOG_INFO(__FUNCTION__);\n     INIT_ERROR_STATE\n@@ -370,7 +370,7 @@ void trustedSetSEK_backup(int *errStatus, char *errString,\n \n \n void trustedGenerateEcdsaKeyAES(int *errStatus, char *errString,\n-                                uint8_t *encryptedPrivateKey, uint32_t *enc_len, char *pub_key_x, char *pub_key_y) {\n+                                uint8_t *encryptedPrivateKey, uint64_t *enc_len, char *pub_key_x, char *pub_key_y) {\n     LOG_INFO(__FUNCTION__);\n     INIT_ERROR_STATE\n \n@@ -410,22 +410,21 @@ void trustedGenerateEcdsaKeyAES(int *errStatus, char *errString,\n     }\n     strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);\n \n-    SAFE_CHAR_BUF(skey_str, ECDSA_SKEY_LEN);SAFE_CHAR_BUF(arr_skey_str, mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2);\n+    SAFE_CHAR_BUF(skey_str, BUF_LEN);\n+    SAFE_CHAR_BUF(arr_skey_str, mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2);\n     mpz_get_str(arr_skey_str, ECDSA_SKEY_BASE, skey);\n     n_zeroes = 64 - strlen(arr_skey_str);\n     for (int i = 0; i < n_zeroes; i++) {\n         skey_str[i] = '0';\n     }\n     strncpy(skey_str + n_zeroes, arr_skey_str, 65 - n_zeroes);\n-    skey_str[ECDSA_SKEY_LEN - 1] = 0;\n     snprintf(errString, BUF_LEN, \"skey len is %d\\n\", (int) strlen(skey_str));\n \n-    int status = AES_encrypt((char *) skey_str, encryptedPrivateKey, BUF_LEN);\n+    int status = AES_encrypt((char *) skey_str, encryptedPrivateKey, BUF_LEN,\n+                             ECDSA, NON_DECRYPTABLE, enc_len);\n     CHECK_STATUS(\"ecdsa private key encryption failed\");\n \n-    *enc_len = strlen(skey_str) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n-\n-    status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, ECDSA_SKEY_LEN);\n+    status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, BUF_LEN);\n \n     CHECK_STATUS2(\"ecdsa private key decr failed with status %d\");\n \n@@ -439,11 +438,11 @@ void trustedGenerateEcdsaKeyAES(int *errStatus, char *errString,\n }\n \n void trustedGetPublicEcdsaKeyAES(int *errStatus, char *errString,\n-                                 uint8_t *encryptedPrivateKey, uint32_t enc_len, char *pub_key_x, char *pub_key_y) {\n+                                 uint8_t *encryptedPrivateKey, uint64_t enc_len, char *pub_key_x, char *pub_key_y) {\n     LOG_DEBUG(__FUNCTION__);\n     INIT_ERROR_STATE\n \n-    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n+    SAFE_CHAR_BUF(skey, BUF_LEN);\n \n     mpz_t privateKeyMpz;\n     mpz_init(privateKeyMpz);\n@@ -455,7 +454,7 @@ void trustedGetPublicEcdsaKeyAES(int *errStatus, char *errString,\n     CHECK_STATE(pub_key_x);\n     CHECK_STATE(pub_key_y);\n \n-    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);\n+    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);\n     CHECK_STATUS2(\"AES_decrypt failed with status %d\");\n \n     skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE] = '\\0';\n@@ -515,7 +514,7 @@ void trustedGetPublicEcdsaKeyAES(int *errStatus, char *errString,\n \n static uint64_t sigCounter = 0;\n \n-void trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t enc_len,\n+void trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t enc_len,\n                          const char *hash, char *sigR, char *sigS, uint8_t *sig_v, int base) {\n     LOG_DEBUG(__FUNCTION__);\n \n@@ -526,15 +525,15 @@ void trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPriv\n     CHECK_STATE(sigR);\n     CHECK_STATE(sigS);\n \n-    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n+    SAFE_CHAR_BUF(skey, BUF_LEN);\n \n     mpz_t privateKeyMpz;\n     mpz_init(privateKeyMpz);\n     mpz_t msgMpz;\n     mpz_init(msgMpz);\n     signature sign = signature_init();\n \n-    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);\n+    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);\n \n     CHECK_STATUS2(\"aes decrypt failed with status %d\");\n \n@@ -600,7 +599,7 @@ void trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPriv\n \n \n void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,\n-                          uint32_t enc_len, char *key) {\n+                          uint64_t enc_len, char *key) {\n \n     LOG_DEBUG(__FUNCTION__);\n     INIT_ERROR_STATE\n@@ -610,7 +609,7 @@ void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPri\n \n     *errStatus = -9;\n \n-    int status = AES_decrypt_DH(encryptedPrivateKey, enc_len, key, 3072);\n+    int status = AES_decrypt(encryptedPrivateKey, enc_len, key, 3072);\n \n     if (status != 0) {\n         *errStatus = status;\n@@ -636,7 +635,7 @@ void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPri\n \n \n void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,\n-                          uint8_t *encryptedPrivateKey, uint32_t *enc_len) {\n+                          uint8_t *encryptedPrivateKey, uint64_t *enc_len) {\n     LOG_INFO(__FUNCTION__);\n \n     *errString = 0;\n@@ -647,15 +646,14 @@ void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,\n \n     *errStatus = UNKNOWN_ERROR;\n \n-    int status = AES_encrypt_DH((char *)key, encryptedPrivateKey, BUF_LEN);\n+    int status = AES_encrypt((char *)key, encryptedPrivateKey, BUF_LEN,\n+                             DKG, DECRYPTABLE, enc_len);\n \n     CHECK_STATUS2(\"AES encrypt failed with status %d\");\n \n-    *enc_len = strlen(key) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n-\n     SAFE_CHAR_BUF(decryptedKey, BUF_LEN);\n \n-    status = AES_decrypt_DH(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);\n+    status = AES_decrypt(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);\n \n     CHECK_STATUS2(\"trustedDecryptKey failed with status %d\");\n \n@@ -671,6 +669,8 @@ void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,\n \n     if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {\n         snprintf(errString, BUF_LEN, \"Decrypted key does not match original key\");\n+        LOG_ERROR(key);\n+        LOG_ERROR(decryptedKey);\n         LOG_ERROR(errString);\n         goto clean;\n     }\n@@ -684,7 +684,7 @@ void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,\n \n \n void trustedBlsSignMessageAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,\n-                              uint32_t enc_len, char *_hashX,\n+                              uint64_t enc_len, char *_hashX,\n                               char *_hashY, char *signature) {\n     LOG_DEBUG(__FUNCTION__);\n     INIT_ERROR_STATE\n@@ -726,7 +726,7 @@ void trustedBlsSignMessageAES(int *errStatus, char *errString, uint8_t *encrypte\n }\n \n void\n-trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t *enc_len, size_t _t) {\n+trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t *enc_len, size_t _t) {\n     LOG_INFO(__FUNCTION__);\n     INIT_ERROR_STATE\n \n@@ -738,11 +738,12 @@ trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_s\n \n     CHECK_STATUS(\"gen_dkg_poly failed\")\n \n-    status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN);\n+    status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN,\n+                         DKG, DECRYPTABLE, enc_len);\n \n     CHECK_STATUS(\"SGX AES encrypt DKG poly failed\");\n \n-    *enc_len = strlen(dkg_secret) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n+\n \n     SAFE_CHAR_BUF(decr_dkg_secret, DKG_BUFER_LENGTH);\n \n@@ -768,7 +769,7 @@ trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_s\n \n void\n trustedDecryptDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret,\n-                           uint32_t enc_len,\n+                           uint64_t enc_len,\n                            uint8_t *decrypted_dkg_secret) {\n     LOG_INFO(__FUNCTION__);\n     INIT_ERROR_STATE\n@@ -790,7 +791,7 @@ trustedDecryptDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_d\n }\n \n \n-void trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint32_t enc_len) {\n+void trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint64_t enc_len) {\n     LOG_INFO(__FUNCTION__);\n     INIT_ERROR_STATE\n \n@@ -810,14 +811,14 @@ void trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *enc\n     LOG_INFO(\"SGX call completed\");\n }\n \n-void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint32_t *dec_len,\n+void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint64_t *dec_len,\n                                        char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n,\n                                        uint8_t ind) {\n \n     LOG_INFO(__FUNCTION__);\n     INIT_ERROR_STATE\n \n-    uint32_t enc_len;\n+    uint64_t enc_len;\n     int status;\n \n     CHECK_STATE(encrypted_skey);\n@@ -827,29 +828,29 @@ void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t\n \n     LOG_DEBUG(__FUNCTION__);\n \n-    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n+    SAFE_CHAR_BUF(skey, BUF_LEN);\n \n     SAFE_CHAR_BUF(pub_key_x, BUF_LEN);SAFE_CHAR_BUF(pub_key_y, BUF_LEN);\n \n     trustedGenerateEcdsaKeyAES(&status, errString, encrypted_skey, &enc_len, pub_key_x, pub_key_y);\n \n     CHECK_STATUS(\"trustedGenerateEcdsaKeyAES failed\");\n \n-    status = AES_decrypt(encrypted_skey, enc_len, skey, ECDSA_SKEY_LEN);\n+    status = AES_decrypt(encrypted_skey, enc_len, skey, BUF_LEN);\n \n     skey[ECDSA_SKEY_LEN - 1] = 0;\n \n     CHECK_STATUS2(\"AES_decrypt failed (in trustedGetEncryptedSecretShareAES) with status %d\");\n \n     *dec_len = enc_len;\n \n-    SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);\n+    SAFE_CHAR_BUF(common_key, BUF_LEN);\n \n     status = gen_session_key(skey, pub_keyB, common_key);\n \n     CHECK_STATUS(\"gen_session_key failed\")\n \n-    SAFE_CHAR_BUF(s_share, ECDSA_SKEY_LEN);\n+    SAFE_CHAR_BUF(s_share, BUF_LEN);\n \n     status = calc_secret_share(getThreadLocalDecryptedDkgPoly(), s_share, _t, _n, ind);\n     CHECK_STATUS(\"calc secret share failed\")\n@@ -858,7 +859,7 @@ void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t\n     status = calc_secret_shareG2(s_share, s_shareG2);\n     CHECK_STATUS(\"invalid decr secret share\");\n \n-    SAFE_CHAR_BUF(cypher, ECDSA_SKEY_LEN);\n+    SAFE_CHAR_BUF(cypher, BUF_LEN);\n     status=xor_encrypt(common_key, s_share, cypher);\n \n     CHECK_STATUS(\"xor_encrypt failed\")\n@@ -875,7 +876,7 @@ void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t\n     LOG_INFO(\"SGX call completed\");\n }\n \n-void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t enc_len,\n+void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t enc_len,\n                                char *public_shares,\n                                unsigned _t, unsigned _n) {\n     LOG_INFO(__FUNCTION__);\n@@ -913,26 +914,26 @@ void trustedDkgVerifyAES(int *errStatus, char *errString, const char *public_sha\n     CHECK_STATE(s_share);\n     CHECK_STATE(encryptedPrivateKey);\n \n-    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n+    SAFE_CHAR_BUF(skey,BUF_LEN);\n \n     mpz_t s;\n     mpz_init(s);\n \n-    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);\n+    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);\n \n     CHECK_STATUS2(\"AES_decrypt failed (in trustedDkgVerifyAES) with status %d\");\n \n-    SAFE_CHAR_BUF(encr_sshare, ECDSA_SKEY_LEN);\n+    SAFE_CHAR_BUF(encr_sshare, BUF_LEN);\n \n     strncpy(encr_sshare, s_share, ECDSA_SKEY_LEN - 1);\n \n-    SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);\n+    SAFE_CHAR_BUF(common_key, BUF_LEN);\n \n     status = session_key_recover(skey, s_share, common_key);\n \n     CHECK_STATUS(\"session_key_recover failed\");\n \n-    SAFE_CHAR_BUF(decr_sshare, ECDSA_SKEY_LEN);\n+    SAFE_CHAR_BUF(decr_sshare, BUF_LEN);\n \n     status=xor_decrypt(common_key, encr_sshare, decr_sshare);\n \n@@ -954,7 +955,7 @@ void trustedDkgVerifyAES(int *errStatus, char *errString, const char *public_sha\n \n void trustedCreateBlsKeyAES(int *errStatus, char *errString, const char *s_shares,\n                             uint8_t *encryptedPrivateKey, uint64_t key_len, uint8_t *encr_bls_key,\n-                            uint32_t *enc_bls_key_len) {\n+                            uint64_t *enc_bls_key_len) {\n \n     LOG_INFO(__FUNCTION__);\n \n@@ -964,7 +965,7 @@ void trustedCreateBlsKeyAES(int *errStatus, char *errString, const char *s_share\n     CHECK_STATE(encryptedPrivateKey);\n     CHECK_STATE(encr_bls_key);\n \n-    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n+    SAFE_CHAR_BUF(skey, BUF_LEN);\n \n     mpz_t sum;\n     mpz_init(sum);\n@@ -978,7 +979,7 @@ void trustedCreateBlsKeyAES(int *errStatus, char *errString, const char *s_share\n     mpz_init(bls_key);\n \n \n-    int status = AES_decrypt(encryptedPrivateKey, key_len, skey, ECDSA_SKEY_LEN);\n+    int status = AES_decrypt(encryptedPrivateKey, key_len, skey, BUF_LEN);\n     CHECK_STATUS2(\"aes decrypt failed with status %d\");\n \n     skey[ECDSA_SKEY_LEN - 1] = 0;\n@@ -1038,12 +1039,10 @@ void trustedCreateBlsKeyAES(int *errStatus, char *errString, const char *s_share\n     strncpy(key_share + n_zeroes, arr_skey_str, 65 - n_zeroes);\n     key_share[BLS_KEY_LENGTH - 1] = 0;\n \n-    status = AES_encrypt(key_share, encr_bls_key, BUF_LEN);\n+    status = AES_encrypt(key_share, encr_bls_key, BUF_LEN, BLS, NON_DECRYPTABLE, enc_bls_key_len);\n \n     CHECK_STATUS2(\"aes encrypt bls private key failed with status %d \");\n \n-    *enc_bls_key_len = strlen(key_share) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n-\n     SET_SUCCESS\n     clean:\n \n@@ -1064,9 +1063,9 @@ trustedGetBlsPubKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivat\n     CHECK_STATE(bls_pub_key);\n     CHECK_STATE(encryptedPrivateKey);\n \n-    SAFE_CHAR_BUF(skey_hex, ECDSA_SKEY_LEN);\n+    SAFE_CHAR_BUF(skey_hex, BUF_LEN);\n \n-    int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, ECDSA_SKEY_LEN);\n+    int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, BUF_LEN);\n \n     CHECK_STATUS2(\"AES decrypt failed %d\");\n "
        },
        {
          "filename": "secure_enclave/secure_enclave.edl",
          "status": "modified",
          "additions": 15,
          "deletions": 15,
          "patch": "@@ -11,14 +11,14 @@ enclave {\n \ttrusted {\n \t\tinclude \"sgx_tgmp.h\"\n \n-\t\tpublic void trustedEnclaveInit(uint32_t _logLevel);\n+\t\tpublic void trustedEnclaveInit(uint64_t _logLevel);\n \n \n         public void trustedGenerateSEK(\n                                 [out] int *errStatus,\n                                 [out, count = SMALL_BUF_SIZE] char *err_string,\n                                 [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_SEK,\n-                                [out] uint32_t *enc_len,\n+                                [out] uint64_t *enc_len,\n                                 [out, count = 65] char* hex_SEK);\n \n         public void trustedSetSEK(\n@@ -30,30 +30,30 @@ enclave {\n                                 [out] int *errStatus,\n                                 [out, count = SMALL_BUF_SIZE] char *err_string,\n                                 [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_SEK,\n-                                [out] uint32_t *enc_len,\n+                                [out] uint64_t *enc_len,\n                                 [in, string] const char* SEK_hex);\n \n         public void trustedGenerateEcdsaKeyAES (\n                                 [out] int *errStatus,\n                                 [out, count = SMALL_BUF_SIZE] char* err_string,\n                                 [out, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n-                                [out] uint32_t *enc_len,\n+                                [out] uint64_t *enc_len,\n                                 [out, count = SMALL_BUF_SIZE] char * pub_key_x,\n                                 [out, count = SMALL_BUF_SIZE] char * pub_key_y);\n \n         public void trustedGetPublicEcdsaKeyAES(\n                                 [out] int *errStatus,\n                                 [out, count = SMALL_BUF_SIZE] char* err_string,\n                                 [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n-                                uint32_t dec_len,\n+                                uint64_t dec_len,\n                                 [out, count = SMALL_BUF_SIZE] char * pub_key_x,\n                                 [out, count = SMALL_BUF_SIZE] char * pub_key_y);\n \n         public void trustedEcdsaSignAES(\n                                 [out] int *errStatus,\n                                 [out, count = SMALL_BUF_SIZE] char* err_string,\n                                 [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n-                                uint32_t enc_len,\n+                                uint64_t enc_len,\n                                 [in, string] const char* hash,\n                                 [out, count = SMALL_BUF_SIZE] char* sig_r,\n                                 [out, count = SMALL_BUF_SIZE] char* sig_s,\n@@ -65,40 +65,40 @@ enclave {\n                                 [out, count = SMALL_BUF_SIZE] char* err_string,\n                                 [in, count = SMALL_BUF_SIZE] const char* key,\n                                 [out, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n-                                [out] uint32_t *enc_len);\n+                                [out] uint64_t *enc_len);\n \n         public void trustedDecryptKeyAES (\n                                 [out] int *errStatus,\n                                 [out, count = SMALL_BUF_SIZE] char* err_string,\n                                 [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n-                                uint32_t enc_len,\n+                                uint64_t enc_len,\n                                 [out, count = SMALL_BUF_SIZE] char* key );\n \n         public void trustedGenDkgSecretAES (\n                                 [out] int *errStatus,\n                                 [out, count = SMALL_BUF_SIZE] char* err_string,\n                                 [out, count = 3072] uint8_t* encrypted_dkg_secret,\n-                                [out] uint32_t * enc_len, size_t _t);\n+                                [out] uint64_t * enc_len, size_t _t);\n \n         public void trustedDecryptDkgSecretAES (\n                                 [out] int *errStatus,\n                                 [out, count = SMALL_BUF_SIZE] char* err_string,\n                                 [in, count = 3050] uint8_t* encrypted_dkg_secret,\n-                                uint32_t enc_len,\n+                                uint64_t enc_len,\n                                 [out, count = 3072] uint8_t* decrypted_dkg_secret\n                                 );\n \n         public void trustedSetEncryptedDkgPolyAES(\n                                 [out] int *errStatus,\n                                 [out, count = SMALL_BUF_SIZE] char* err_string,\n                                 [in, count = 3050] uint8_t* encrypted_poly,\n-                                uint32_t enc_len);\n+                                uint64_t enc_len);\n \n         public void trustedGetEncryptedSecretShareAES(\n                                 [out]int *errStatus,\n                                 [out, count = SMALL_BUF_SIZE] char *err_string,\n                                 [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_skey,\n-                                [out] uint32_t* dec_len,\n+                                [out] uint64_t* dec_len,\n                                 [out, count = 193] char* result_str,\n                                 [out, count = 320] char* s_shareG2,\n                                 [in, string] char* pub_keyB,\n@@ -110,7 +110,7 @@ enclave {\n                                 [out] int *errStatus,\n                                 [out, count = SMALL_BUF_SIZE] char* err_string,\n                                 [in, count = 3050] uint8_t* encrypted_dkg_secret,\n-                                uint32_t enc_len,\n+                                uint64_t enc_len,\n                                 [out, count = 10000] char* public_shares,\n                                 unsigned _t,\n                                 unsigned _n);\n@@ -133,13 +133,13 @@ enclave {\n                                 [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                 uint64_t key_len,\n                                 [out, count = SMALL_BUF_SIZE] uint8_t * encr_bls_key,\n-                                [out] uint32_t *enc_bls_key_len);\n+                                [out] uint64_t *enc_bls_key_len);\n \n         public void trustedBlsSignMessageAES (\n                                 [out] int *errStatus,\n                                 [out, count = TINY_BUF_SIZE] char* err_string,\n                                 [in, count = TINY_BUF_SIZE] uint8_t* encrypted_key,\n-                                uint32_t enc_len,\n+                                uint64_t enc_len,\n                                 [in, string] char* hashX ,\n                                 [in, string] char* hashY,\n                                 [out, count = SMALL_BUF_SIZE] char* signature);"
        },
        {
          "filename": "testw.cpp",
          "status": "modified",
          "additions": 8,
          "deletions": 7,
          "patch": "@@ -127,7 +127,7 @@ TEST_CASE_METHOD(TestFixture, \"ECDSA AES keygen and signature test\", \"[ecdsa-aes\n     vector<char> pubKeyX(BUF_LEN, 0);\n     vector<char> pubKeyY(BUF_LEN, 0);\n \n-    uint32_t encLen = 0;\n+    uint64_t encLen = 0;\n     PRINT_SRC_LINE\n     auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,\n                                              pubKeyX.data(),\n@@ -160,7 +160,7 @@ TEST_CASE_METHOD(TestFixture, \"ECDSA AES key gen\", \"[ecdsa-aes-key-gen]\") {\n     vector <uint8_t> encrPrivKey(BUF_LEN, 0);\n     vector<char> pubKeyX(BUF_LEN, 0);\n     vector<char> pubKeyY(BUF_LEN, 0);\n-    uint32_t encLen = 0;\n+    uint64_t encLen = 0;\n     PRINT_SRC_LINE\n     auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,\n                                              pubKeyX.data(),\n@@ -177,7 +177,8 @@ TEST_CASE_METHOD(TestFixture, \"ECDSA AES get public key\", \"[ecdsa-aes-get-pub-ke\n     vector <uint8_t> encPrivKey(BUF_LEN, 0);\n     vector<char> pubKeyX(BUF_LEN, 0);\n     vector<char> pubKeyY(BUF_LEN, 0);\n-    uint32_t encLen = 0;\n+\n+    uint64_t encLen = 0;\n \n     PRINT_SRC_LINE\n     auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encPrivKey.data(), &encLen, pubKeyX.data(),\n@@ -291,7 +292,7 @@ TEST_CASE_METHOD(TestFixture, \"DKG AES gen test\", \"[dkg-aes-gen]\") {\n     vector<char> errMsg(BUF_LEN, 0);\n \n     int errStatus = 0;\n-    uint32_t encLen = 0;\n+    uint64_t encLen = 0;\n \n     PRINT_SRC_LINE\n     auto status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encryptedDKGSecret.data(), &encLen, 32);\n@@ -314,7 +315,7 @@ TEST_CASE_METHOD(TestFixture, \"DKG AES public shares test\", \"[dkg-aes-pub-shares\n     vector<char> errMsg(BUF_LEN, 0);\n \n     int errStatus = 0;\n-    uint32_t encLen = 0;\n+    uint64_t encLen = 0;\n \n     unsigned t = 32, n = 32;\n     PRINT_SRC_LINE\n@@ -363,7 +364,7 @@ TEST_CASE_METHOD(TestFixture, \"DKG AES encrypted secret shares test\", \"[dkg-aes-\n     vector<char> result(BUF_LEN, 0);\n \n     int errStatus = 0;\n-    uint32_t encLen = 0;\n+    uint64_t encLen = 0;\n \n     vector <uint8_t> encryptedDKGSecret(BUF_LEN, 0);\n     PRINT_SRC_LINE\n@@ -694,7 +695,7 @@ TEST_CASE_METHOD(TestFixture, \"AES_DKG test\", \"[aes-dkg]\") {\n TEST_CASE_METHOD(TestFixture, \"AES encrypt/decrypt\", \"[aes-encrypt-decrypt]\") {\n     int errStatus = 0;\n     vector<char> errMsg(BUF_LEN, 0);\n-    uint32_t encLen;\n+    uint64_t encLen;\n     string key = SAMPLE_AES_KEY;\n     vector <uint8_t> encrypted_key(BUF_LEN, 0);\n "
        }
      ],
      "file_patterns": {
        "security_files": 3,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "76b6046503c0a8d07aefbeb70e0b2e6f6222ae54",
            "date": "2024-12-27T11:21:06Z",
            "author_login": "olehnikolaiev"
          },
          {
            "sha": "a2b886ecd0049b6cb0ccc65af02826715936d4e7",
            "date": "2024-12-26T18:24:46Z",
            "author_login": "olehnikolaiev"
          },
          {
            "sha": "e70a4c914fddac3b6c80812a50e8404bbcf9c7a3",
            "date": "2024-12-16T17:00:41Z",
            "author_login": "olehnikolaiev"
          },
          {
            "sha": "d9e1d8c608bc46864aa2e9c43feb52d7b454084a",
            "date": "2024-11-28T12:34:15Z",
            "author_login": "olehnikolaiev"
          },
          {
            "sha": "40dc30a2c723434929a0e9486c5a3b687d34d805",
            "date": "2024-11-27T18:46:37Z",
            "author_login": "olehnikolaiev"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-787",
    "description": "An issue was discovered in SKALE sgxwallet 1.58.3. sgx_disp_ippsAES_GCMEncrypt allows an out-of-bounds write, resulting in a segfault and compromised enclave. This issue describes a buffer overflow, which was resolved prior to v1.77.0 and not reproducible in latest sgxwallet v1.77.0",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-09-27T14:15:08.490",
    "last_modified": "2024-11-21T06:13:20.063",
    "fix_date": "2020-09-08T12:30:59Z"
  },
  "references": [
    {
      "url": "https://github.com/skalenetwork/sgxwallet/commit/77425c862ad20cd270d42c54f3d63e1eb4e02195",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/skalenetwork/sgxwallet/releases",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/skalenetwork/sgxwallet/commit/77425c862ad20cd270d42c54f3d63e1eb4e02195",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/skalenetwork/sgxwallet/releases",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:07.789340",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "sgxwallet",
    "owner": "skalenetwork",
    "created_at": "2019-09-04T07:46:31Z",
    "updated_at": "2024-12-27T11:21:11Z",
    "pushed_at": "2024-12-27T11:37:11Z",
    "size": 196100,
    "stars": 64,
    "forks": 36,
    "open_issues": 19,
    "watchers": 64,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "404-add-support-of-ubuntu-2204",
      "MANY_THREADS",
      "SECURE_ENCLAVE_CHANGES",
      "architecture-docs",
      "beta",
      "develop",
      "master",
      "more-logs-bls-sign",
      "stable",
      "update-README"
    ],
    "languages": {
      "Shell": 976100,
      "C++": 449449,
      "C": 124759,
      "Makefile": 45058,
      "M4": 21210,
      "Python": 13354,
      "CMake": 2456,
      "Dockerfile": 522
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "agpl-3.0"
    },
    "collected_at": "2025-01-14T16:33:21.965523"
  }
}