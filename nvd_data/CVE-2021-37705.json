{
  "cve_id": "CVE-2021-37705",
  "github_data": {
    "repository": "microsoft/onefuzz",
    "fix_commit": "2fcb4998887959b4fa11894a068d689189742cb1",
    "related_commits": [
      "2fcb4998887959b4fa11894a068d689189742cb1",
      "2fcb4998887959b4fa11894a068d689189742cb1"
    ],
    "patch_url": "https://github.com/microsoft/onefuzz/commit/2fcb4998887959b4fa11894a068d689189742cb1.patch",
    "fix_commit_details": {
      "sha": "2fcb4998887959b4fa11894a068d689189742cb1",
      "commit_date": "2021-08-13T18:50:54Z",
      "author": {
        "login": "bmc-msft",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-q5vh-6whw-x745",
        "length": 352,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 224,
        "additions": 193,
        "deletions": 31
      },
      "files": [
        {
          "filename": "docs/webhook_events.md",
          "status": "modified",
          "additions": 26,
          "deletions": 1,
          "patch": "@@ -641,7 +641,10 @@ Each event will be submitted via HTTP POST to the user provided URL.\n         \"admins\": [\n             \"00000000-0000-0000-0000-000000000000\"\n         ],\n-        \"allow_pool_management\": true\n+        \"allow_pool_management\": true,\n+        \"allowed_aad_tenants\": [\n+            \"00000000-0000-0000-0000-000000000000\"\n+        ]\n     }\n }\n ```\n@@ -665,8 +668,19 @@ Each event will be submitted via HTTP POST to the user provided URL.\n                     \"default\": true,\n                     \"title\": \"Allow Pool Management\",\n                     \"type\": \"boolean\"\n+                },\n+                \"allowed_aad_tenants\": {\n+                    \"items\": {\n+                        \"format\": \"uuid\",\n+                        \"type\": \"string\"\n+                    },\n+                    \"title\": \"Allowed Aad Tenants\",\n+                    \"type\": \"array\"\n                 }\n             },\n+            \"required\": [\n+                \"allowed_aad_tenants\"\n+            ],\n             \"title\": \"InstanceConfig\",\n             \"type\": \"object\"\n         }\n@@ -5599,8 +5613,19 @@ Each event will be submitted via HTTP POST to the user provided URL.\n                     \"default\": true,\n                     \"title\": \"Allow Pool Management\",\n                     \"type\": \"boolean\"\n+                },\n+                \"allowed_aad_tenants\": {\n+                    \"items\": {\n+                        \"format\": \"uuid\",\n+                        \"type\": \"string\"\n+                    },\n+                    \"title\": \"Allowed Aad Tenants\",\n+                    \"type\": \"array\"\n                 }\n             },\n+            \"required\": [\n+                \"allowed_aad_tenants\"\n+            ],\n             \"title\": \"InstanceConfig\",\n             \"type\": \"object\"\n         },"
        },
        {
          "filename": "src/api-service/__app__/info/__init__.py",
          "status": "modified",
          "additions": 10,
          "deletions": 1,
          "patch": "@@ -14,11 +14,12 @@\n     get_instance_id,\n     get_subscription,\n )\n+from ..onefuzzlib.endpoint_authorization import call_if_user\n from ..onefuzzlib.request import ok\n from ..onefuzzlib.versions import versions\n \n \n-def main(req: func.HttpRequest) -> func.HttpResponse:\n+def get(req: func.HttpRequest) -> func.HttpResponse:\n     response = ok(\n         Info(\n             resource_group=get_base_resource_group(),\n@@ -32,3 +33,11 @@ def main(req: func.HttpRequest) -> func.HttpResponse:\n     )\n \n     return response\n+\n+\n+def main(req: func.HttpRequest) -> func.HttpResponse:\n+    methods = {\"GET\": get}\n+    method = methods[req.method]\n+    result = call_if_user(req, method)\n+\n+    return result"
        },
        {
          "filename": "src/api-service/__app__/negotiate/__init__.py",
          "status": "modified",
          "additions": 18,
          "deletions": 5,
          "patch": "@@ -5,6 +5,8 @@\n \n import azure.functions as func\n \n+from ..onefuzzlib.endpoint_authorization import call_if_user\n+\n # This endpoint handles the signalr negotation\n # As we do not differentiate from clients at this time, we pass the Functions runtime\n # provided connection straight to the client\n@@ -14,8 +16,19 @@\n \n \n def main(req: func.HttpRequest, connectionInfoJson: str) -> func.HttpResponse:\n-    return func.HttpResponse(\n-        connectionInfoJson,\n-        status_code=200,\n-        headers={\"Content-type\": \"application/json\"},\n-    )\n+    # NOTE: this is a sub-method because the call_if* do not support callbacks with\n+    # additional arguments at this time.  Once call_if* supports additional arguments,\n+    # this should be made a generic function\n+    def post(req: func.HttpRequest) -> func.HttpResponse:\n+        return func.HttpResponse(\n+            connectionInfoJson,\n+            status_code=200,\n+            headers={\"Content-type\": \"application/json\"},\n+        )\n+\n+    methods = {\"POST\": post}\n+    method = methods[req.method]\n+\n+    result = call_if_user(req, method)\n+\n+    return result"
        },
        {
          "filename": "src/api-service/__app__/onefuzzlib/config.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -25,7 +25,7 @@ def key_fields(cls) -> Tuple[str, Optional[str]]:\n     def fetch(cls) -> \"InstanceConfig\":\n         entry = cls.get(get_instance_name())\n         if entry is None:\n-            entry = cls()\n+            entry = cls(allowed_aad_tenants=[])\n             entry.save()\n         return entry\n "
        },
        {
          "filename": "src/api-service/__app__/onefuzzlib/user_credentials.py",
          "status": "modified",
          "additions": 24,
          "deletions": 2,
          "patch": "@@ -3,14 +3,18 @@\n # Copyright (c) Microsoft Corporation.\n # Licensed under the MIT License.\n \n-from typing import Optional\n+import logging\n+from typing import List, Optional\n from uuid import UUID\n \n import azure.functions as func\n import jwt\n+from memoization import cached\n from onefuzztypes.enums import ErrorCode\n from onefuzztypes.models import Error, Result, UserInfo\n \n+from .config import InstanceConfig\n+\n \n def get_bearer_token(request: func.HttpRequest) -> Optional[str]:\n     auth: str = request.headers.get(\"Authorization\", None)\n@@ -39,6 +43,13 @@ def get_auth_token(request: func.HttpRequest) -> Optional[str]:\n     return str(token_header)\n \n \n+@cached(ttl=60)\n+def get_allowed_tenants() -> List[str]:\n+    config = InstanceConfig.fetch()\n+    entries = [f\"https://sts.windows.net/{x}/\" for x in config.allowed_aad_tenants]\n+    return entries\n+\n+\n def parse_jwt_token(request: func.HttpRequest) -> Result[UserInfo]:\n     \"\"\"Obtains the Access Token from the Authorization Header\"\"\"\n     token_str = get_auth_token(request)\n@@ -48,9 +59,20 @@ def parse_jwt_token(request: func.HttpRequest) -> Result[UserInfo]:\n             errors=[\"unable to find authorization token\"],\n         )\n \n-    # This token has already been verified by the azure authentication layer\n+    # The JWT token has already been verified by the azure authentication layer,\n+    # but we need to verify the tenant is as we expect.\n     token = jwt.decode(token_str, options={\"verify_signature\": False})\n \n+    if \"iss\" not in token:\n+        return Error(\n+            code=ErrorCode.INVALID_REQUEST, errors=[\"missing issuer from token\"]\n+        )\n+\n+    tenants = get_allowed_tenants()\n+    if token[\"iss\"] not in tenants:\n+        logging.error(\"issuer not from allowed tenant: %s - %s\", token[\"iss\"], tenants)\n+        return Error(code=ErrorCode.INVALID_REQUEST, errors=[\"unauthorized AAD issuer\"])\n+\n     application_id = UUID(token[\"appid\"]) if \"appid\" in token else None\n     object_id = UUID(token[\"oid\"]) if \"oid\" in token else None\n     upn = token.get(\"upn\")"
        },
        {
          "filename": "src/api-service/tests/test_auth_check.py",
          "status": "modified",
          "additions": 42,
          "deletions": 11,
          "patch": "@@ -5,7 +5,7 @@\n \n import os\n import unittest\n-from uuid import uuid4\n+from uuid import UUID, uuid4\n \n from onefuzztypes.models import UserInfo\n \n@@ -25,29 +25,41 @@ def test_modify_config(self) -> None:\n         user2 = uuid4()\n \n         # no admins set\n-        self.assertTrue(can_modify_config_impl(InstanceConfig(), UserInfo()))\n+        self.assertTrue(\n+            can_modify_config_impl(\n+                InstanceConfig(allowed_aad_tenants=[UUID(int=0)]), UserInfo()\n+            )\n+        )\n \n         # with oid, but no admin\n         self.assertTrue(\n-            can_modify_config_impl(InstanceConfig(), UserInfo(object_id=user1))\n+            can_modify_config_impl(\n+                InstanceConfig(allowed_aad_tenants=[UUID(int=0)]),\n+                UserInfo(object_id=user1),\n+            )\n         )\n \n         # is admin\n         self.assertTrue(\n             can_modify_config_impl(\n-                InstanceConfig(admins=[user1]), UserInfo(object_id=user1)\n+                InstanceConfig(allowed_aad_tenants=[UUID(int=0)], admins=[user1]),\n+                UserInfo(object_id=user1),\n             )\n         )\n \n         # no user oid set\n         self.assertFalse(\n-            can_modify_config_impl(InstanceConfig(admins=[user1]), UserInfo())\n+            can_modify_config_impl(\n+                InstanceConfig(allowed_aad_tenants=[UUID(int=0)], admins=[user1]),\n+                UserInfo(),\n+            )\n         )\n \n         # not an admin\n         self.assertFalse(\n             can_modify_config_impl(\n-                InstanceConfig(admins=[user1]), UserInfo(object_id=user2)\n+                InstanceConfig(allowed_aad_tenants=[UUID(int=0)], admins=[user1]),\n+                UserInfo(object_id=user2),\n             )\n         )\n \n@@ -58,36 +70,55 @@ def test_manage_pools(self) -> None:\n         # by default, any can modify\n         self.assertIsNone(\n             check_can_manage_pools_impl(\n-                InstanceConfig(allow_pool_management=True), UserInfo()\n+                InstanceConfig(\n+                    allowed_aad_tenants=[UUID(int=0)], allow_pool_management=True\n+                ),\n+                UserInfo(),\n             )\n         )\n \n         # with oid, but no admin\n         self.assertIsNone(\n             check_can_manage_pools_impl(\n-                InstanceConfig(allow_pool_management=True), UserInfo(object_id=user1)\n+                InstanceConfig(\n+                    allowed_aad_tenants=[UUID(int=0)], allow_pool_management=True\n+                ),\n+                UserInfo(object_id=user1),\n             )\n         )\n \n         # is admin\n         self.assertIsNone(\n             check_can_manage_pools_impl(\n-                InstanceConfig(allow_pool_management=False, admins=[user1]),\n+                InstanceConfig(\n+                    allowed_aad_tenants=[UUID(int=0)],\n+                    allow_pool_management=False,\n+                    admins=[user1],\n+                ),\n                 UserInfo(object_id=user1),\n             )\n         )\n \n         # no user oid set\n         self.assertIsNotNone(\n             check_can_manage_pools_impl(\n-                InstanceConfig(allow_pool_management=False, admins=[user1]), UserInfo()\n+                InstanceConfig(\n+                    allowed_aad_tenants=[UUID(int=0)],\n+                    allow_pool_management=False,\n+                    admins=[user1],\n+                ),\n+                UserInfo(),\n             )\n         )\n \n         # not an admin\n         self.assertIsNotNone(\n             check_can_manage_pools_impl(\n-                InstanceConfig(allow_pool_management=False, admins=[user1]),\n+                InstanceConfig(\n+                    allowed_aad_tenants=[UUID(int=0)],\n+                    allow_pool_management=False,\n+                    admins=[user1],\n+                ),\n                 UserInfo(object_id=user2),\n             )\n         )"
        },
        {
          "filename": "src/deployment/azuredeploy.json",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -821,6 +821,10 @@\n         \"scaleset-identity\": {\n             \"type\": \"string\",\n             \"value\": \"[variables('scaleset_identity')]\"\n+        },\n+        \"tenant_id\": {\n+            \"type\": \"string\",\n+            \"value\": \"[subscription().tenantId]\"\n         }\n     }\n }"
        },
        {
          "filename": "src/deployment/deploy.py",
          "status": "modified",
          "additions": 20,
          "deletions": 4,
          "patch": "@@ -72,7 +72,7 @@\n     set_app_audience,\n     update_pool_registration,\n )\n-from set_admins import update_admins\n+from set_admins import update_admins, update_allowed_aad_tenants\n \n # Found by manually assigning the User.Read permission to application\n # registration in the admin portal. The values are in the manifest under\n@@ -130,7 +130,8 @@ def __init__(\n         multi_tenant_domain: str,\n         upgrade: bool,\n         subscription_id: Optional[str],\n-        admins: List[UUID]\n+        admins: List[UUID],\n+        allowed_aad_tenants: List[UUID],\n     ):\n         self.subscription_id = subscription_id\n         self.resource_group = resource_group\n@@ -161,6 +162,7 @@ def __init__(\n         self.export_appinsights = export_appinsights\n         self.log_service_principal = log_service_principal\n         self.admins = admins\n+        self.allowed_aad_tenants = allowed_aad_tenants\n \n         machine = platform.machine()\n         system = platform.system()\n@@ -560,13 +562,20 @@ def apply_migrations(self) -> None:\n         table_service = TableService(account_name=name, account_key=key)\n         migrate(table_service, self.migrations)\n \n-    def set_admins(self) -> None:\n+    def set_instance_config(self) -> None:\n         name = self.results[\"deploy\"][\"func-name\"][\"value\"]\n         key = self.results[\"deploy\"][\"func-key\"][\"value\"]\n+        tenant = UUID(self.results[\"deploy\"][\"tenant_id\"][\"value\"])\n         table_service = TableService(account_name=name, account_key=key)\n+\n         if self.admins:\n             update_admins(table_service, self.application_name, self.admins)\n \n+        tenants = self.allowed_aad_tenants\n+        if tenant not in tenants:\n+            tenants.append(tenant)\n+        update_allowed_aad_tenants(table_service, self.application_name, tenants)\n+\n     def create_queues(self) -> None:\n         logger.info(\"creating eventgrid destination queue\")\n \n@@ -926,7 +935,7 @@ def main() -> None:\n \n     full_deployment_states = rbac_only_states + [\n         (\"apply_migrations\", Client.apply_migrations),\n-        (\"set_admins\", Client.set_admins),\n+        (\"set_instance_config\", Client.set_instance_config),\n         (\"queues\", Client.create_queues),\n         (\"eventgrid\", Client.create_eventgrid),\n         (\"tools\", Client.upload_tools),\n@@ -1038,6 +1047,12 @@ def main() -> None:\n         nargs=\"*\",\n         help=\"set the list of administrators (by OID in AAD)\",\n     )\n+    parser.add_argument(\n+        \"--allowed_aad_tenants\",\n+        type=UUID,\n+        nargs=\"*\",\n+        help=\"Set additional AAD tenants beyond the tenant the app is deployed in\",\n+    )\n \n     args = parser.parse_args()\n \n@@ -1066,6 +1081,7 @@ def main() -> None:\n         upgrade=args.upgrade,\n         subscription_id=args.subscription_id,\n         admins=args.set_admins,\n+        allowed_aad_tenants=args.allowed_aad_tenants or [],\n     )\n     if args.verbose:\n         level = logging.DEBUG"
        },
        {
          "filename": "src/deployment/set_admins.py",
          "status": "modified",
          "additions": 23,
          "deletions": 2,
          "patch": "@@ -20,6 +20,21 @@ def create_if_missing(table_service: TableService) -> None:\n         table_service.create_table(TABLE_NAME)\n \n \n+def update_allowed_aad_tenants(\n+    table_service: TableService, resource_group: str, tenants: List[UUID]\n+) -> None:\n+    create_if_missing(table_service)\n+    as_str = [str(x) for x in tenants]\n+    table_service.insert_or_merge_entity(\n+        TABLE_NAME,\n+        {\n+            \"PartitionKey\": resource_group,\n+            \"RowKey\": resource_group,\n+            \"allowed_aad_tenants\": json.dumps(as_str),\n+        },\n+    )\n+\n+\n def update_admins(\n     table_service: TableService, resource_group: str, admins: List[UUID]\n ) -> None:\n@@ -43,7 +58,8 @@ def main() -> None:\n     parser = argparse.ArgumentParser(formatter_class=formatter)\n     parser.add_argument(\"resource_group\")\n     parser.add_argument(\"storage_account\")\n-    parser.add_argument(\"admins\", type=UUID, nargs=\"*\")\n+    parser.add_argument(\"--admins\", type=UUID, nargs=\"*\")\n+    parser.add_argument(\"--allowed_aad_tenants\", type=UUID, nargs=\"*\")\n     args = parser.parse_args()\n \n     client = get_client_from_cli_profile(StorageManagementClient)\n@@ -53,7 +69,12 @@ def main() -> None:\n     table_service = TableService(\n         account_name=args.storage_account, account_key=storage_keys.keys[0].value\n     )\n-    update_admins(table_service, args.resource_group, args.admins)\n+    if args.admins:\n+        update_admins(table_service, args.resource_group, args.admins)\n+    if args.allowed_aad_tenants:\n+        update_allowed_aad_tenants(\n+            table_service, args.resource_group, args.allowed_aad_tenants\n+        )\n \n \n if __name__ == \"__main__\":"
        },
        {
          "filename": "src/pytypes/extra/generate-docs.py",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -258,7 +258,11 @@ def main() -> None:\n         EventFileAdded(container=Container(\"container-name\"), filename=\"example.txt\"),\n         EventNodeHeartbeat(machine_id=UUID(int=0), pool_name=PoolName(\"example\")),\n         EventTaskHeartbeat(task_id=UUID(int=0), job_id=UUID(int=0), config=task_config),\n-        EventInstanceConfigUpdated(config=InstanceConfig(admins=[UUID(int=0)])),\n+        EventInstanceConfigUpdated(\n+            config=InstanceConfig(\n+                admins=[UUID(int=0)], allowed_aad_tenants=[UUID(int=0)]\n+            )\n+        ),\n     ]\n \n     # works around `mypy` not handling that Union has `__args__`"
        },
        {
          "filename": "src/pytypes/onefuzztypes/models.py",
          "status": "modified",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -802,6 +802,8 @@ class InstanceConfig(BaseModel):\n     # if set, only admins can manage pools or scalesets\n     allow_pool_management: bool = Field(default=True)\n \n+    allowed_aad_tenants: List[UUID]\n+\n     def update(self, config: \"InstanceConfig\") -> None:\n         for field in config.__fields__:\n             # If no admins are set, then ignore setting admins\n@@ -817,5 +819,16 @@ def check_admins(cls, value: Optional[List[UUID]]) -> Optional[List[UUID]]:\n             raise ValueError(\"admins must be None or contain at least one UUID\")\n         return value\n \n+    # At the moment, this only checks allowed_aad_tenants, however adding\n+    # support for 3rd party JWT validation is anticipated in a future release.\n+    @root_validator()\n+    def check_instance_config(cls, values: Any) -> Any:\n+        if \"allowed_aad_tenants\" not in values:\n+            raise ValueError(\"missing allowed_aad_tenants\")\n+\n+        if not len(values[\"allowed_aad_tenants\"]):\n+            raise ValueError(\"allowed_aad_tenants must not be empty\")\n+        return values\n+\n \n _check_hotfix()"
        },
        {
          "filename": "src/pytypes/tests/test_instance_config_update.py",
          "status": "modified",
          "additions": 7,
          "deletions": 3,
          "patch": "@@ -11,9 +11,13 @@\n \n class TestInstanceConfig(unittest.TestCase):\n     def test_with_admins(self) -> None:\n-        no_admins = InstanceConfig(admins=None)\n-        with_admins = InstanceConfig(admins=[UUID(int=0)])\n-        with_admins_2 = InstanceConfig(admins=[UUID(int=1)])\n+        no_admins = InstanceConfig(admins=None, allowed_aad_tenants=[UUID(int=0)])\n+        with_admins = InstanceConfig(\n+            admins=[UUID(int=0)], allowed_aad_tenants=[UUID(int=0)]\n+        )\n+        with_admins_2 = InstanceConfig(\n+            admins=[UUID(int=1)], allowed_aad_tenants=[UUID(int=0)]\n+        )\n \n         no_admins.update(with_admins)\n         self.assertEqual(no_admins.admins, None)"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 3,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 9,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "82fffbe8adc047f055cb4fddcae17e9e1244423e",
            "date": "2023-10-31T21:19:19Z",
            "author_login": "nharper285"
          },
          {
            "sha": "ca6f3cdfd9318cf0bccf01c2ca61242cfe0a91f4",
            "date": "2023-10-31T20:56:29Z",
            "author_login": "nharper285"
          },
          {
            "sha": "902557f78c8fa1288bc6112eebd8ecaea31e668f",
            "date": "2023-10-31T16:23:21Z",
            "author_login": "chkeita"
          },
          {
            "sha": "d50fd48a8b36cd0f902d79457b8dcd3d56832c8b",
            "date": "2023-10-30T17:21:33Z",
            "author_login": "tevoinea"
          },
          {
            "sha": "72d775f4455765c0c42ca779092e4237e8c2d699",
            "date": "2023-10-27T20:44:27Z",
            "author_login": "nharper285"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 10.0,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:L",
    "cwe_id": "CWE-285",
    "description": "OneFuzz is an open source self-hosted Fuzzing-As-A-Service platform. Starting with OneFuzz 2.12.0 or greater, an incomplete authorization check allows an authenticated user from any Azure Active Directory tenant to make authorized API calls to a vulnerable OneFuzz instance. To be vulnerable, a OneFuzz deployment must be both version 2.12.0 or greater and deployed with the non-default --multi_tenant_domain option. This can result in read/write access to private data such as software vulnerability and crash information, security testing tools and proprietary code and symbols. Via authorized API calls, this also enables tampering with existing data and unauthorized code execution on Azure compute resources. This issue is resolved starting in release 2.31.0, via the addition of application-level check of the bearer token's `issuer` against an administrator-configured allowlist. As a workaround users can restrict access to the tenant of a deployed OneFuzz instance < 2.31.0 by redeploying in the default configuration, which omits the `--multi_tenant_domain` option.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-08-13T21:15:06.973",
    "last_modified": "2024-11-21T06:15:45.053",
    "fix_date": "2021-08-13T18:50:54Z"
  },
  "references": [
    {
      "url": "https://github.com/microsoft/onefuzz/commit/2fcb4998887959b4fa11894a068d689189742cb1",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/microsoft/onefuzz/pull/1153",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/microsoft/onefuzz/releases/tag/2.31.0",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/microsoft/onefuzz/security/advisories/GHSA-q5vh-6whw-x745",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://pypi.org/project/onefuzz/",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/microsoft/onefuzz/commit/2fcb4998887959b4fa11894a068d689189742cb1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/microsoft/onefuzz/pull/1153",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/microsoft/onefuzz/releases/tag/2.31.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/microsoft/onefuzz/security/advisories/GHSA-q5vh-6whw-x745",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://pypi.org/project/onefuzz/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:05.082746",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "onefuzz",
    "owner": "microsoft",
    "created_at": "2020-07-27T22:23:30Z",
    "updated_at": "2025-01-04T17:01:20Z",
    "pushed_at": "2023-11-01T09:22:49Z",
    "size": 22622,
    "stars": 2824,
    "forks": 198,
    "open_issues": 233,
    "watchers": 2824,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C#": 1317249,
      "Rust": 1283341,
      "Python": 598800,
      "Shell": 32921,
      "Bicep": 29918,
      "C": 18040,
      "PowerShell": 15691,
      "Dockerfile": 3740,
      "Makefile": 3710,
      "C++": 215
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T17:12:59.645800"
  }
}