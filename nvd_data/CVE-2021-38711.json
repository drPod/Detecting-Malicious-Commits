{
  "cve_id": "CVE-2021-38711",
  "github_data": {
    "repository": "jgm/gitit",
    "fix_commit": "eed32638f4f6e3b2f4b8a9a04c4b72001acf9ad8",
    "related_commits": [
      "eed32638f4f6e3b2f4b8a9a04c4b72001acf9ad8",
      "eed32638f4f6e3b2f4b8a9a04c4b72001acf9ad8"
    ],
    "patch_url": "https://github.com/jgm/gitit/commit/eed32638f4f6e3b2f4b8a9a04c4b72001acf9ad8.patch",
    "fix_commit_details": {
      "sha": "eed32638f4f6e3b2f4b8a9a04c4b72001acf9ad8",
      "commit_date": "2021-08-12T22:39:57Z",
      "author": {
        "login": "jgm",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Remove the Export feature.",
        "length": 176,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 393,
        "additions": 9,
        "deletions": 384
      },
      "files": [
        {
          "filename": "README.markdown",
          "status": "modified",
          "additions": 4,
          "deletions": 5,
          "patch": "@@ -7,10 +7,9 @@ files are stored in a [git], [darcs], or [mercurial] repository\n and may be modified either by using the VCS's command-line tools or\n through the wiki's web interface. By default, pandoc's extended version\n of markdown is used as a markup language, but reStructuredText, LaTeX, HTML,\n-DocBook, or Emacs Org-mode markup can also be used. Pages can be exported in a\n-number of different formats, including LaTeX, RTF, OpenOffice ODT, and\n-MediaWiki markup.  Gitit can be configured to display TeX math (using\n-[texmath]) and highlighted source code (using [highlighting-kate]).\n+DocBook, or Emacs Org-mode markup can also be used.  Gitit can\n+be configured to display TeX math (using [texmath]) and\n+highlighted source code (using [highlighting-kate]).\n \n Other features include\n \n@@ -411,7 +410,7 @@ Caching\n By default, gitit does not cache content.  If your wiki receives a lot of\n traffic or contains pages that are slow to render, you may want to activate\n caching.  To do this, set the configuration option `use-cache` to `yes`.\n-By default, rendered pages, highlighted source files, and exported PDFs\n+By default, rendered pages, and highlighted source files\n will be cached in the `cache` directory. (Another directory can be\n specified by setting the `cache-dir` configuration option.)\n "
        },
        {
          "filename": "data/default.conf",
          "status": "modified",
          "additions": 1,
          "deletions": 8,
          "patch": "@@ -266,16 +266,9 @@ feed-days: 14\n feed-refresh-time: 60\n # number of minutes to cache feeds before refreshing\n \n-pdf-export: no\n-# if yes, PDF will appear in export options. PDF will be created using\n-# pdflatex, which must be installed and in the path. Note that PDF\n-# exports create significant additional server load.\n-\n pandoc-user-data:\n # if a directory is specified, this will be searched for pandoc\n-# customizations. These can include a templates/ directory for custom\n-# templates for various export formats, an S5 directory for custom\n-# S5 styles, and a reference.odt for ODT exports. If no directory is\n+# customizations.  If no directory is\n # specified, $HOME/.pandoc will be searched. See pandoc's README for\n # more information.\n "
        },
        {
          "filename": "data/templates/pagetools.st",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -9,6 +9,5 @@\n       <li><a href=\"$base$/_feed$pageUrl$\" type=\"application/atom+xml\" rel=\"alternate\" title=\"This page's ATOM Feed\">Atom feed</a> <img alt=\"feed icon\" src=\"$base$/img/icons/feed.png\"/></li>\n       $endif$\n     </ul>\n-    $exportbox$\n   </fieldset>\n </div>"
        },
        {
          "filename": "gitit.cabal",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -115,7 +115,6 @@ Library\n                      Network.Gitit.Authentication.Github,\n                      Network.Gitit.Util, Network.Gitit.Server\n                      Network.Gitit.Cache, Network.Gitit.State,\n-                     Network.Gitit.Export,\n                      Network.Gitit.Handlers,\n                      Network.Gitit.Plugins, Network.Gitit.Rpxnow,\n                      Network.Gitit.Page, Network.Gitit.Feed,"
        },
        {
          "filename": "src/Network/Gitit.hs",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -199,7 +199,6 @@ wikiHandlers =\n           authenticate ForModify (unlessNoDelete deletePage showPage) ]\n   , dir \"_preview\" preview\n   , guardIndex >> indexPage\n-  , guardCommand \"export\" >> exportPage\n   , method POST >> guardCommand \"cancel\" >> showPage\n   , method POST >> guardCommand \"update\" >>\n       authenticate ForModify (unlessNoEdit updatePage showPage)"
        },
        {
          "filename": "src/Network/Gitit/Cache.hs",
          "status": "modified",
          "additions": 1,
          "deletions": 12,
          "patch": "@@ -41,23 +41,13 @@ import Control.Monad.Trans (liftIO)\n import Text.Pandoc.UTF8 (encodePath)\n \n -- | Expire a cached file, identified by its filename in the filestore.\n--- If there is an associated exported PDF, expire it too.\n -- Returns () after deleting a file from the cache, fails if no cached file.\n expireCachedFile :: String -> GititServerPart ()\n expireCachedFile file = do\n   cfg <- getConfig\n   let target = encodePath $ cacheDir cfg </> file\n   exists <- liftIO $ doesFileExist target\n-  when exists $ liftIO $ do\n-    liftIO $ removeFile target\n-    expireCachedPDF target (defaultExtension cfg)\n-\n-expireCachedPDF :: String -> String -> IO ()\n-expireCachedPDF file ext = \n-  when (takeExtension file == \".\" ++ ext) $ do\n-    let pdfname = file ++ \".export.pdf\"\n-    exists <- doesFileExist pdfname\n-    when exists $ removeFile pdfname\n+  when exists $ liftIO $ liftIO $ removeFile target\n \n lookupCache :: String -> GititServerPart (Maybe (UTCTime, B.ByteString))\n lookupCache file = do\n@@ -84,4 +74,3 @@ cacheContents file contents = do\n   liftIO $ do\n     createDirectoryIfMissing True targetDir\n     B.writeFile target contents\n-    expireCachedPDF target (defaultExtension cfg)"
        },
        {
          "filename": "src/Network/Gitit/Config.hs",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -130,7 +130,6 @@ extractConfig cp = do\n       cfWikiTitle <- get cp \"DEFAULT\" \"wiki-title\"\n       cfFeedDays <- get cp \"DEFAULT\" \"feed-days\"\n       cfFeedRefreshTime <- get cp \"DEFAULT\" \"feed-refresh-time\"\n-      cfPDFExport <- get cp \"DEFAULT\" \"pdf-export\"\n       cfPandocUserData <- get cp \"DEFAULT\" \"pandoc-user-data\"\n       cfXssSanitize <- get cp \"DEFAULT\" \"xss-sanitize\"\n       cfRecentActivityDays <- get cp \"DEFAULT\" \"recent-activity-days\"\n@@ -232,7 +231,6 @@ extractConfig cp = do\n         , wikiTitle            = cfWikiTitle\n         , feedDays             = readNumber \"feed-days\" cfFeedDays\n         , feedRefreshTime      = readNumber \"feed-refresh-time\" cfFeedRefreshTime\n-        , pdfExport            = cfPDFExport\n         , pandocUserData       = if null cfPandocUserData\n                                     then Nothing\n                                     else Just cfPandocUserData"
        },
        {
          "filename": "src/Network/Gitit/ContentTransformer.hs",
          "status": "modified",
          "additions": 0,
          "deletions": 27,
          "patch": "@@ -31,7 +31,6 @@ module Network.Gitit.ContentTransformer\n   , showRawPage\n   , showFileAsText\n   , showPage\n-  , exportPage\n   , showHighlightedSource\n   , showFile\n   , preview\n@@ -45,7 +44,6 @@ module Network.Gitit.ContentTransformer\n   , textResponse\n   , mimeFileResponse\n   , mimeResponse\n-  , exportPandoc\n   , applyWikiTemplate\n   -- * Content-type transformation combinators\n   , pageToWikiPandoc\n@@ -79,7 +77,6 @@ import Data.List (stripPrefix)\n import Data.Maybe (isNothing, mapMaybe)\n import Data.Semigroup ((<>))\n import Network.Gitit.Cache (lookupCache, cacheContents)\n-import Network.Gitit.Export (exportFormats)\n import Network.Gitit.Framework hiding (uriPath)\n import Network.Gitit.Layout\n import Network.Gitit.Page (stringToPage)\n@@ -186,10 +183,6 @@ showFileAsText = runFileTransformer rawTextResponse\n showPage :: Handler\n showPage = runPageTransformer htmlViaPandoc\n \n--- | Responds with page exported into selected format.\n-exportPage :: Handler\n-exportPage = runPageTransformer exportViaPandoc\n-\n -- | Responds with highlighted source code.\n showHighlightedSource :: Handler\n showHighlightedSource = runFileTransformer highlightRawSource\n@@ -220,15 +213,6 @@ applyPreCommitPlugins = runPageTransformer . applyPreCommitTransforms\n rawTextResponse :: ContentTransformer Response\n rawTextResponse = rawContents >>= textResponse\n \n--- | Responds with a wiki page in the format specified\n--- by the @format@ parameter.\n-exportViaPandoc :: ContentTransformer Response\n-exportViaPandoc = rawContents >>=\n-                  maybe mzero return >>=\n-                  contentsToPage >>=\n-                  pageToWikiPandoc >>=\n-                  exportPandoc\n-\n -- | Responds with a wiki page. Uses the cache when\n -- possible and caches the rendered page when appropriate.\n htmlViaPandoc :: ContentTransformer Response\n@@ -322,17 +306,6 @@ mimeResponse :: Monad m\n mimeResponse c mimeType =\n   return . setContentType mimeType . toResponse $ c\n \n--- | Converts Pandoc to response using format specified in parameters.\n-exportPandoc :: Pandoc -> ContentTransformer Response\n-exportPandoc doc = do\n-  params <- getParams\n-  page <- getPageName\n-  cfg <- lift getConfig\n-  let format = pFormat params\n-  case lookup format (exportFormats cfg) of\n-       Nothing     -> error $ \"Unknown export format: \" ++ format\n-       Just writer -> lift (writer page doc)\n-\n -- | Adds the sidebar, page tabs, and other elements of the wiki page\n -- layout to the raw content.\n applyWikiTemplate :: Html -> ContentTransformer Response"
        },
        {
          "filename": "src/Network/Gitit/Export.hs",
          "status": "removed",
          "additions": 0,
          "deletions": 307,
          "patch": "@@ -1,307 +0,0 @@\n-{-# LANGUAGE OverloadedStrings #-}\n-{-# LANGUAGE FlexibleContexts #-}\n-{-\n-Copyright (C) 2009 John MacFarlane <jgm@berkeley.edu>\n-\n-This program is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2 of the License, or\n-(at your option) any later version.\n-\n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; if not, write to the Free Software\n-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n--}\n-\n-{- Functions for exporting wiki pages in various formats.\n--}\n-\n-module Network.Gitit.Export ( exportFormats ) where\n-import Control.Exception (throwIO)\n-import Text.Pandoc hiding (HTMLMathMethod(..), getDataFileName)\n-import qualified Text.Pandoc as Pandoc\n-import Text.Pandoc.PDF (makePDF)\n-import Text.Pandoc.SelfContained as SelfContained\n-import qualified Text.Pandoc.UTF8 as UTF8\n-import qualified Data.Map as M\n-import Network.Gitit.Server\n-import Network.Gitit.Framework (pathForPage)\n-import Network.Gitit.State (getConfig)\n-import Network.Gitit.Types\n-import Network.Gitit.Cache (cacheContents, lookupCache)\n-import Text.DocTemplates as DT\n-import Control.Monad.Trans (liftIO)\n-import Control.Monad (unless)\n-import Text.XHtml (noHtml)\n-import qualified Data.ByteString as B\n-import qualified Data.ByteString.Lazy as L\n-import System.FilePath ((</>), takeDirectory)\n-import System.Environment (setEnv)\n-import System.Directory (doesFileExist)\n-import Text.HTML.SanitizeXSS\n-import Data.ByteString.Lazy (fromStrict)\n-import Data.Text (Text)\n-import qualified Data.Text as T\n-import Data.Text.Encoding (encodeUtf8)\n-import Data.List (isPrefixOf)\n-import Skylighting (styleToCss, pygments)\n-import System.IO.Temp (withSystemTempDirectory)\n-import Paths_gitit (getDataFileName)\n-\n-defaultRespOptions :: WriterOptions\n-defaultRespOptions = def { writerHighlightStyle = Just pygments }\n-\n-respondX :: String -> String -> String\n-          -> (WriterOptions -> Pandoc -> PandocIO L.ByteString)\n-          -> WriterOptions -> String -> Pandoc -> Handler\n-respondX templ mimetype ext fn opts page doc = do\n-  cfg <- getConfig\n-  doc' <- if ext `elem` [\"odt\",\"pdf\",\"beamer\",\"epub\",\"docx\",\"rtf\"]\n-             then fixURLs page doc\n-             else return doc\n-  doc'' <- liftIO $ runIO $ do\n-        setUserDataDir $ pandocUserData cfg\n-        compiledTemplate <- compileDefaultTemplate (T.pack templ)\n-        fn opts{ writerTemplate = Just compiledTemplate } doc'\n-  either (liftIO . throwIO)\n-         (ok . setContentType mimetype .\n-           (if null ext then id else setFilename (page ++ \".\" ++ ext)) .\n-            toResponseBS B.empty)\n-         doc''\n-\n-respondS :: String -> String -> String -> (WriterOptions -> Pandoc -> PandocIO Text)\n-          -> WriterOptions -> String -> Pandoc -> Handler\n-respondS templ mimetype ext fn =\n-  respondX templ mimetype ext (\\o d -> fromStrict . encodeUtf8 <$> fn o d)\n-\n-respondSlides :: String -> (WriterOptions -> Pandoc -> PandocIO Text) -> String -> Pandoc -> Handler\n-respondSlides templ fn page doc = do\n-    cfg <- getConfig\n-    let math = case mathMethod cfg of\n-                   MathML       -> Pandoc.MathML\n-                   WebTeX u     -> Pandoc.WebTeX $ T.pack u\n-                   _            -> Pandoc.PlainMath\n-    let opts' = defaultRespOptions { writerIncremental = True\n-                                   , writerHTMLMathMethod = math}\n-    -- We sanitize the body only, to protect against XSS attacks.\n-    -- (Sanitizing the whole HTML page would strip out javascript\n-    -- needed for the slides.)  We then pass the body into the\n-    -- slide template using the 'body' variable.\n-    Pandoc meta blocks <- fixURLs page doc\n-    docOrError <- liftIO $ runIO $ do\n-          setUserDataDir $ pandocUserData cfg\n-          body' <- writeHtml5String opts' (Pandoc meta blocks) -- just body\n-          let body'' = T.unpack\n-                       $ (if xssSanitize cfg then sanitizeBalance else id)\n-                       $ body'\n-          let setVariable key val (DT.Context ctx) =\n-                DT.Context $ M.insert (T.pack key) (toVal (T.pack val)) ctx\n-          variables' <- if mathMethod cfg == MathML\n-                          then do\n-                              s <- readDataFile \"MathMLinHTML.js\"\n-                              return $ setVariable \"mathml-script\"\n-                                         (UTF8.toString s) mempty\n-                          else return mempty\n-          compiledTemplate <- compileDefaultTemplate (T.pack templ)\n-          dzcore <- if templ == \"dzslides\"\n-                      then do\n-                        dztempl <- readDataFile $ \"dzslides\" </> \"template.html\"\n-                        return $ unlines\n-                            $ dropWhile (not . isPrefixOf \"<!-- {{{{ dzslides core\")\n-                            $ lines $ UTF8.toString dztempl\n-                      else return \"\"\n-          let opts'' = opts'{\n-                             writerVariables =\n-                               setVariable \"body\" body'' $\n-                               setVariable \"dzslides-core\" dzcore $\n-                               setVariable \"highlighting-css\" pygmentsCss\n-                               $ variables'\n-                            ,writerTemplate = Just compiledTemplate }\n-          h <- fn opts'' (Pandoc meta [])\n-          makeSelfContained h\n-    either (liftIO . throwIO)\n-           (ok . setContentType \"text/html;charset=UTF-8\" .\n-             (setFilename (page ++ \".html\")) .\n-             toResponseBS B.empty . L.fromStrict . UTF8.fromText)\n-           docOrError\n-\n-respondLaTeX :: String -> Pandoc -> Handler\n-respondLaTeX = respondS \"latex\" \"application/x-latex\" \"tex\"\n-  writeLaTeX defaultRespOptions\n-\n-respondConTeXt :: String -> Pandoc -> Handler\n-respondConTeXt = respondS \"context\" \"application/x-context\" \"tex\"\n-  writeConTeXt defaultRespOptions\n-\n-\n-respondRTF :: String -> Pandoc -> Handler\n-respondRTF = respondX \"rtf\" \"application/rtf\" \"rtf\"\n-  (\\o d -> L.fromStrict . UTF8.fromText <$> writeRTF o d) defaultRespOptions\n-\n-respondRST :: String -> Pandoc -> Handler\n-respondRST = respondS \"rst\" \"text/plain; charset=utf-8\" \"\"\n-  writeRST defaultRespOptions{writerReferenceLinks = True}\n-\n-respondMarkdown :: String -> Pandoc -> Handler\n-respondMarkdown = respondS \"markdown\" \"text/plain; charset=utf-8\" \"\"\n-  writeMarkdown defaultRespOptions{writerReferenceLinks = True}\n-\n-respondCommonMark :: String -> Pandoc -> Handler\n-respondCommonMark = respondS \"commonmark\" \"text/plain; charset=utf-8\" \"\"\n-  writeCommonMark defaultRespOptions{writerReferenceLinks = True}\n-\n-respondPlain :: String -> Pandoc -> Handler\n-respondPlain = respondS \"plain\" \"text/plain; charset=utf-8\" \"\"\n-  writePlain defaultRespOptions\n-\n-respondMan :: String -> Pandoc -> Handler\n-respondMan = respondS \"man\" \"text/plain; charset=utf-8\" \"\"\n-  writeMan defaultRespOptions\n-\n-respondTexinfo :: String -> Pandoc -> Handler\n-respondTexinfo = respondS \"texinfo\" \"application/x-texinfo\" \"texi\"\n-  writeTexinfo defaultRespOptions\n-\n-respondDocbook :: String -> Pandoc -> Handler\n-respondDocbook = respondS \"docbook\" \"application/docbook+xml\" \"xml\"\n-  writeDocbook5 defaultRespOptions\n-\n-respondOrg :: String -> Pandoc -> Handler\n-respondOrg = respondS \"org\" \"text/plain; charset=utf-8\" \"\"\n-  writeOrg defaultRespOptions\n-\n-respondICML :: String -> Pandoc -> Handler\n-respondICML = respondX \"icml\" \"application/xml; charset=utf-8\" \"\"\n-              (\\o d -> L.fromStrict . UTF8.fromText <$> writeICML o d)\n-                         defaultRespOptions\n-\n-respondTextile :: String -> Pandoc -> Handler\n-respondTextile = respondS \"textile\" \"text/plain; charset=utf-8\" \"\"\n-  writeTextile defaultRespOptions\n-\n-respondAsciiDoc :: String -> Pandoc -> Handler\n-respondAsciiDoc = respondS \"asciidoc\" \"text/plain; charset=utf-8\" \"\"\n-  writeAsciiDoc defaultRespOptions\n-\n-respondMediaWiki :: String -> Pandoc -> Handler\n-respondMediaWiki = respondS \"mediawiki\" \"text/plain; charset=utf-8\" \"\"\n-  writeMediaWiki defaultRespOptions\n-\n-respondODT :: String -> Pandoc -> Handler\n-respondODT = respondX \"opendocument\" \"application/vnd.oasis.opendocument.text\"\n-              \"odt\" writeODT defaultRespOptions\n-\n-respondEPUB :: String -> Pandoc -> Handler\n-respondEPUB = respondX \"html\" \"application/epub+zip\" \"epub\" writeEPUB3\n-               defaultRespOptions\n-\n-respondDocx :: String -> Pandoc -> Handler\n-respondDocx = respondX \"native\"\n-  \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\"\n-  \"docx\" writeDocx defaultRespOptions\n-\n-respondPDF :: Bool -> String -> Pandoc -> Handler\n-respondPDF useBeamer page old_pndc = fixURLs page old_pndc >>= \\pndc -> do\n-  cfg <- getConfig\n-  unless (pdfExport cfg) $ error \"PDF export disabled\"\n-  let cacheName = pathForPage page (defaultExtension cfg) ++ \".export.pdf\"\n-  cached <- if useCache cfg\n-               then lookupCache cacheName\n-               else return Nothing\n-  pdf' <- case cached of\n-            Just (_modtime, bs) -> return $ Right $ L.fromChunks [bs]\n-            Nothing -> liftIO $\n-                withSystemTempDirectory \"gitit\" $ \\tmpdir -> do\n-              let toc = tableOfContents cfg\n-              -- ensure that LaTeX \\include commands can't include\n-              -- files outside the working directory, e.g. /etc/passwd:\n-              writeFile (tmpdir </> \"texmf.cnf\")\n-                \"openout_any = p\\nopenin_any = p\\n\"\n-              setEnv \"TEXMFCNF\" (tmpdir ++ \":\")\n-              res <- runIO $ do\n-                setUserDataDir $ pandocUserData cfg\n-                setInputFiles [baseUrl cfg]\n-                let templ = if useBeamer then \"beamer\" else \"latex\"\n-                compiledTemplate <- compileDefaultTemplate templ\n-                makePDF \"pdflatex\" [] (if useBeamer then writeBeamer else writeLaTeX)\n-                  defaultRespOptions{ writerTemplate = Just compiledTemplate\n-                                    , writerTableOfContents = toc } pndc\n-              either (liftIO . throwIO) return res\n-\n-  case pdf' of\n-       Left logOutput' -> simpleErrorHandler (\"PDF creation failed:\\n\"\n-                           ++ UTF8.toStringLazy logOutput')\n-       Right pdfBS -> do\n-              case cached of\n-                Nothing ->\n-                     cacheContents cacheName $ B.concat . L.toChunks $ pdfBS\n-                _ -> return ()\n-              ok $ setContentType \"application/pdf\" $ setFilename (page ++ \".pdf\") $\n-                        (toResponse noHtml) {rsBody = pdfBS}\n-\n--- | When we create a PDF or ODT from a Gitit page, we need to fix the URLs of any\n--- images on the page. Those URLs will often be relative to the staticDir, but the\n--- PDF or ODT processor only understands paths relative to the working directory.\n---\n--- Because the working directory will not in general be the root of the gitit instance\n--- at the time the Pandoc is fed to e.g. pdflatex, this function replaces the URLs of\n--- images in the staticDir with their correct absolute file path.\n-fixURLs :: String -> Pandoc -> GititServerPart Pandoc\n-fixURLs page pndc = do\n-    cfg <- getConfig\n-    defaultStatic <- liftIO $ getDataFileName $ \"data\" </> \"static\"\n-\n-    let static = staticDir cfg\n-    let repoPath = repositoryPath cfg\n-\n-    let go (Image attr ils (url, title)) = do\n-           fixedURL <- fixURL $ T.unpack url\n-           return $ Image attr ils (T.pack fixedURL, title)\n-        go x                        = return x\n-\n-        fixURL ('/':url) = resolve url\n-        fixURL url       = resolve $ takeDirectory page </> url\n-\n-        resolve p = do\n-           sp <- doesFileExist $ static </> p\n-           dsp <- doesFileExist $ defaultStatic </> p\n-           return (if sp then static </> p\n-                   else (if dsp then defaultStatic </> p\n-                         else repoPath </> p))\n-    liftIO $ bottomUpM go pndc\n-\n-exportFormats :: Config -> [(String, String -> Pandoc -> Handler)]\n-exportFormats cfg = if pdfExport cfg\n-                       then (\"PDF\", respondPDF False) :\n-                            (\"Beamer\", respondPDF True) :\n-                            rest\n-                       else rest\n-   where rest = [ (\"LaTeX\",     respondLaTeX)     -- (description, writer)\n-                , (\"ConTeXt\",   respondConTeXt)\n-                , (\"Texinfo\",   respondTexinfo)\n-                , (\"reST\",      respondRST)\n-                , (\"Markdown\",  respondMarkdown)\n-                , (\"CommonMark\",respondCommonMark)\n-                , (\"Plain text\",respondPlain)\n-                , (\"MediaWiki\", respondMediaWiki)\n-                , (\"Org-mode\",  respondOrg)\n-                , (\"ICML\",      respondICML)\n-                , (\"Textile\",   respondTextile)\n-                , (\"AsciiDoc\",  respondAsciiDoc)\n-                , (\"Man page\",  respondMan)\n-                , (\"DocBook\",   respondDocbook)\n-                , (\"DZSlides\",  respondSlides \"dzslides\" writeDZSlides)\n-                , (\"Slidy\",     respondSlides \"slidy\" writeSlidy)\n-                , (\"S5\",        respondSlides \"s5\" writeS5)\n-                , (\"EPUB\",      respondEPUB)\n-                , (\"ODT\",       respondODT)\n-                , (\"DOCX\",      respondDocx)\n-                , (\"RTF\",       respondRTF) ]\n-\n-pygmentsCss :: String\n-pygmentsCss = styleToCss pygments"
        },
        {
          "filename": "src/Network/Gitit/Handlers.hs",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -42,7 +42,6 @@ module Network.Gitit.Handlers (\n                       , showPage\n                       , showPageDiff\n                       , showFileDiff\n-                      , exportPage\n                       , updatePage\n                       , editPage\n                       , deletePage\n@@ -61,7 +60,7 @@ import Network.Gitit.Feed (filestoreToXmlFeed, FeedConfig(..))\n import Network.Gitit.Util (orIfNull)\n import Network.Gitit.Cache (expireCachedFile, lookupCache, cacheContents)\n import Network.Gitit.ContentTransformer (showRawPage, showFileAsText, showPage,\n-        exportPage, showHighlightedSource, preview, applyPreCommitPlugins)\n+        showHighlightedSource, preview, applyPreCommitPlugins)\n import Network.Gitit.Page (readCategories)\n import qualified Control.Exception as E\n import System.FilePath"
        },
        {
          "filename": "src/Network/Gitit/Layout.hs",
          "status": "modified",
          "additions": 1,
          "deletions": 15,
          "patch": "@@ -31,12 +31,11 @@ import Network.Gitit.Server\n import Network.Gitit.Framework\n import Network.Gitit.State\n import Network.Gitit.Types\n-import Network.Gitit.Export (exportFormats)\n import Network.HTTP (urlEncodeVars)\n import qualified Text.StringTemplate as T\n import Text.XHtml hiding ( (</>), dir, method, password, rev )\n import Text.XHtml.Strict ( stringToHtmlString )\n-import Data.Maybe (isNothing, isJust, fromJust)\n+import Data.Maybe (isNothing)\n \n defaultPageLayout :: PageLayout\n defaultPageLayout = PageLayout\n@@ -111,8 +110,6 @@ filledPageTemplate base' cfg layout htmlContents templ =\n                    maybe id (T.setAttribute \"markuphelp\") (pgMarkupHelp layout) .\n                    setBoolAttr \"printable\" (pgPrintable layout) .\n                    maybe id (T.setAttribute \"revision\") rev .\n-                   T.setAttribute \"exportbox\"\n-                       (renderHtmlFragment $  exportBox base' cfg page rev) .\n                    (if null (pgTabs layout) then id else T.setAttribute \"tabs\"\n                        (renderHtmlFragment tabs)) .\n                    (\\f x xs -> if null xs then x else f xs) (T.setAttribute \"messages\") id (pgMessages layout) .\n@@ -122,17 +119,6 @@ filledPageTemplate base' cfg layout htmlContents templ =\n                    templ\n \n \n-exportBox :: String -> Config -> String -> Maybe String -> Html\n-exportBox base' cfg page rev | not (isSourceCode page) =\n-  gui (base' ++ urlForPage page) ! [identifier \"exportbox\"] <<\n-    ([ textfield \"revision\" ! [thestyle \"display: none;\",\n-         value (fromJust rev)] | isJust rev ] ++\n-     [ select ! [name \"format\"] <<\n-         map ((\\f -> option ! [value f] << f) . fst) (exportFormats cfg)\n-     , primHtmlChar \"nbsp\"\n-     , submit \"export\" \"Export\" ])\n-exportBox _ _ _ _ = noHtml\n-\n -- auxiliary functions:\n \n linkForTab :: (Tab -> Html -> Html) -> String -> String -> Maybe String -> Tab -> Html"
        },
        {
          "filename": "src/Network/Gitit/Types.hs",
          "status": "modified",
          "additions": 1,
          "deletions": 3,
          "patch": "@@ -204,8 +204,6 @@ data Config = Config {\n   feedDays             :: Integer,\n   -- | Number of minutes to cache feeds before refreshing\n   feedRefreshTime      :: Integer,\n-  -- | Allow PDF export?\n-  pdfExport            :: Bool,\n   -- | Directory to search for pandoc customizations\n   pandocUserData       :: Maybe FilePath,\n   -- | Filter HTML through xss-sanitize\n@@ -467,7 +465,7 @@ instance FromData Command where\n        return $ case map fst pairs `intersect` commandList of\n                  []          -> Command Nothing\n                  (c:_)       -> Command $ Just c\n-               where commandList = [\"update\", \"cancel\", \"export\"]\n+               where commandList = [\"update\", \"cancel\"]\n \n -- | State for a single wiki.\n data WikiState = WikiState {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 5,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "75161c97dd294e28ab22b7a862dc93bffe1f9988",
            "date": "2025-01-13T20:03:11Z",
            "author_login": "jgm"
          },
          {
            "sha": "5a2fb64440f51ce23196d9cd5523438f390fa108",
            "date": "2025-01-13T20:00:18Z",
            "author_login": "jgm"
          },
          {
            "sha": "bb0aeee16000c0b648b423260a42c771f3bef02a",
            "date": "2025-01-13T19:59:35Z",
            "author_login": "jgm"
          },
          {
            "sha": "fe3f6525725a03c2fb468502d82db496ad37db7c",
            "date": "2025-01-13T19:57:41Z",
            "author_login": "jgm"
          },
          {
            "sha": "e620c22c158019813505fdd89a667f0c34eab72d",
            "date": "2025-01-13T19:57:15Z",
            "author_login": "jgm"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-552",
    "description": "In gitit before 0.15.0.0, the Export feature can be exploited to leak information from files.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-08-16T04:15:07.350",
    "last_modified": "2024-11-21T06:17:57.813",
    "fix_date": "2021-08-12T22:39:57Z"
  },
  "references": [
    {
      "url": "https://github.com/jgm/gitit/commit/eed32638f4f6e3b2f4b8a9a04c4b72001acf9ad8",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/jgm/gitit/compare/0.14.0.0...0.15.0.0",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/jgm/gitit/commit/eed32638f4f6e3b2f4b8a9a04c4b72001acf9ad8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/jgm/gitit/compare/0.14.0.0...0.15.0.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Release Notes",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:05.083295",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "gitit",
    "owner": "jgm",
    "created_at": "2008-11-07T07:38:49Z",
    "updated_at": "2025-01-13T20:03:28Z",
    "pushed_at": "2025-01-13T20:03:24Z",
    "size": 2226,
    "stars": 2166,
    "forks": 226,
    "open_issues": 208,
    "watchers": 2166,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Haskell": 276973,
      "JavaScript": 100494,
      "CSS": 20160,
      "StringTemplate": 4891,
      "Roff": 3779,
      "Shell": 2052,
      "TeX": 1747,
      "HTML": 1091,
      "Makefile": 123
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T20:00:52.446857"
  }
}