{
  "cve_id": "CVE-2021-39197",
  "github_data": {
    "repository": "BetterErrors/better_errors",
    "fix_commit": "8e8e796bfbde4aa088741823c8a3fc6df2089bb0",
    "related_commits": [
      "8e8e796bfbde4aa088741823c8a3fc6df2089bb0",
      "8e8e796bfbde4aa088741823c8a3fc6df2089bb0"
    ],
    "patch_url": "https://github.com/BetterErrors/better_errors/commit/8e8e796bfbde4aa088741823c8a3fc6df2089bb0.patch",
    "fix_commit_details": {
      "sha": "8e8e796bfbde4aa088741823c8a3fc6df2089bb0",
      "commit_date": "2020-09-15T17:18:15Z",
      "author": {
        "login": "RobinDaugherty",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #474 from BetterErrors/feature/add-csrf-to-requests",
        "length": 112,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 266,
        "additions": 192,
        "deletions": 74
      },
      "files": [
        {
          "filename": "lib/better_errors/error_page.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -26,7 +26,7 @@ def id\n       @id ||= SecureRandom.hex(8)\n     end\n \n-    def render(template_name = \"main\")\n+    def render(template_name = \"main\", csrf_token = nil)\n       binding.eval(self.class.template(template_name).src)\n     rescue => e\n       # Fix the backtrace, which doesn't identify the template that failed (within Better Errors)."
        },
        {
          "filename": "lib/better_errors/middleware.rb",
          "status": "modified",
          "additions": 38,
          "deletions": 8,
          "patch": "@@ -1,5 +1,6 @@\n require \"json\"\n require \"ipaddr\"\n+require \"securerandom\"\n require \"set\"\n require \"rack\"\n \n@@ -39,6 +40,8 @@ def self.allow_ip!(addr)\n     allow_ip! \"127.0.0.0/8\"\n     allow_ip! \"::1/128\" rescue nil # windows ruby doesn't have ipv6 support\n \n+    CSRF_TOKEN_COOKIE_NAME = 'BetterErrors-CSRF-Token'\n+\n     # A new instance of BetterErrors::Middleware\n     #\n     # @param app      The Rack app/middleware to wrap with Better Errors\n@@ -89,11 +92,14 @@ def protected_app_call(env)\n     end\n \n     def show_error_page(env, exception=nil)\n+      request = Rack::Request.new(env)\n+      csrf_token = request.cookies[CSRF_TOKEN_COOKIE_NAME] || SecureRandom.uuid\n+\n       type, content = if @error_page\n         if text?(env)\n           [ 'plain', @error_page.render('text') ]\n         else\n-          [ 'html', @error_page.render ]\n+          [ 'html', @error_page.render('main', csrf_token) ]\n         end\n       else\n         [ 'html', no_errors_page ]\n@@ -104,12 +110,22 @@ def show_error_page(env, exception=nil)\n         status_code = ActionDispatch::ExceptionWrapper.new(env, exception).status_code\n       end\n \n-      [status_code, { \"Content-Type\" => \"text/#{type}; charset=utf-8\" }, [content]]\n+      response = Rack::Response.new(content, status_code, { \"Content-Type\" => \"text/#{type}; charset=utf-8\" })\n+\n+      unless request.cookies[CSRF_TOKEN_COOKIE_NAME]\n+        response.set_cookie(CSRF_TOKEN_COOKIE_NAME, value: csrf_token, httponly: true, same_site: :strict)\n+      end\n+\n+      # In older versions of Rack, the body returned here is actually a Rack::BodyProxy which seems to be a bug.\n+      # (It contains status, headers and body and does not act like an array of strings.)\n+      # Since we already have status code and body here, there's no need to use the ones in the Rack::Response.\n+      (_status_code, headers, _body) = response.finish\n+      [status_code, headers, [content]]\n     end\n \n     def text?(env)\n       env[\"HTTP_X_REQUESTED_WITH\"] == \"XMLHttpRequest\" ||\n-      !env[\"HTTP_ACCEPT\"].to_s.include?('html')\n+        !env[\"HTTP_ACCEPT\"].to_s.include?('html')\n     end\n \n     def log_exception\n@@ -133,9 +149,15 @@ def internal_call(env, opts)\n       return no_errors_json_response unless @error_page\n       return invalid_error_json_response if opts[:id] != @error_page.id\n \n-      env[\"rack.input\"].rewind\n-      response = @error_page.send(\"do_#{opts[:method]}\", JSON.parse(env[\"rack.input\"].read))\n-      [200, { \"Content-Type\" => \"text/plain; charset=utf-8\" }, [JSON.dump(response)]]\n+      request = Rack::Request.new(env)\n+      return invalid_csrf_token_json_response unless request.cookies[CSRF_TOKEN_COOKIE_NAME]\n+\n+      request.body.rewind\n+      body = JSON.parse(request.body.read)\n+      return invalid_csrf_token_json_response unless request.cookies[CSRF_TOKEN_COOKIE_NAME] == body['csrfToken']\n+\n+      response = @error_page.send(\"do_#{opts[:method]}\", body)\n+      [200, { \"Content-Type\" => \"application/json; charset=utf-8\" }, [JSON.dump(response)]]\n     end\n \n     def no_errors_page\n@@ -157,18 +179,26 @@ def no_errors_json_response\n         \"The application has been restarted since this page loaded, \" +\n           \"or the framework is reloading all gems before each request \"\n       end\n-      [200, { \"Content-Type\" => \"text/plain; charset=utf-8\" }, [JSON.dump(\n+      [200, { \"Content-Type\" => \"application/json; charset=utf-8\" }, [JSON.dump(\n         error: 'No exception information available',\n         explanation: explanation,\n       )]]\n     end\n \n     def invalid_error_json_response\n-      [200, { \"Content-Type\" => \"text/plain; charset=utf-8\" }, [JSON.dump(\n+      [200, { \"Content-Type\" => \"application/json; charset=utf-8\" }, [JSON.dump(\n         error: \"Session expired\",\n         explanation: \"This page was likely opened from a previous exception, \" +\n           \"and the exception is no longer available in memory.\",\n       )]]\n     end\n+\n+    def invalid_csrf_token_json_response\n+      [200, { \"Content-Type\" => \"application/json; charset=utf-8\" }, [JSON.dump(\n+        error: \"Invalid CSRF Token\",\n+        explanation: \"The browser session might have been cleared, \" +\n+          \"or something went wrong.\",\n+      )]]\n+    end\n   end\n end"
        },
        {
          "filename": "lib/better_errors/templates/main.erb",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -800,6 +800,7 @@\n (function() {\n \n     var OID = \"<%= id %>\";\n+    var csrfToken = \"<%= csrf_token %>\";\n \n     var previousFrame = null;\n     var previousFrameInfo = null;\n@@ -810,6 +811,7 @@\n         var req = new XMLHttpRequest();\n         req.open(\"POST\", \"//\" + window.location.host + <%== uri_prefix.gsub(\"<\", \"&lt;\").inspect %> + \"/__better_errors/\" + OID + \"/\" + method, true);\n         req.setRequestHeader(\"Content-Type\", \"application/json\");\n+        opts.csrfToken = csrfToken;\n         req.send(JSON.stringify(opts));\n         req.onreadystatechange = function() {\n             if(req.readyState == 4) {"
        },
        {
          "filename": "spec/better_errors/middleware_spec.rb",
          "status": "modified",
          "additions": 151,
          "deletions": 65,
          "patch": "@@ -4,9 +4,14 @@ module BetterErrors\n   describe Middleware do\n     let(:app) { Middleware.new(->env { \":)\" }) }\n     let(:exception) { RuntimeError.new(\"oh no :(\") }\n+    let(:status) { response_env[0] }\n+    let(:headers) { response_env[1] }\n+    let(:body) { response_env[2].join }\n \n-    it \"passes non-error responses through\" do\n-      expect(app.call({})).to eq(\":)\")\n+    context 'when the application raises no exception' do\n+      it \"passes non-error responses through\" do\n+        expect(app.call({})).to eq(\":)\")\n+      end\n     end\n \n     it \"calls the internal methods\" do\n@@ -24,11 +29,6 @@ module BetterErrors\n       app.call(\"PATH_INFO\" => \"/__better_errors/\")\n     end\n \n-    it \"shows the error page on any subfolder path\" do\n-      expect(app).to receive :show_error_page\n-      app.call(\"PATH_INFO\" => \"/any_sub/folder/path/__better_errors/\")\n-    end\n-\n     it \"doesn't show the error page to a non-local address\" do\n       expect(app).not_to receive :better_errors_call\n       app.call(\"REMOTE_ADDR\" => \"1.2.3.4\")\n@@ -62,34 +62,71 @@ module BetterErrors\n       expect { app.call(\"REMOTE_ADDR\" => \"0:0:0:0:0:0:0:1%0\" ) }.to_not raise_error\n     end\n \n-    context \"when requesting the /__better_errors manually\" do\n-      let(:app) { Middleware.new(->env { \":)\" }) }\n+    context \"when /__better_errors is requested directly\" do\n+      let(:response_env) { app.call(\"PATH_INFO\" => \"/__better_errors\") }\n \n-      it \"shows that no errors have been recorded\" do\n-        status, headers, body = app.call(\"PATH_INFO\" => \"/__better_errors\")\n-        expect(body.join).to match /No errors have been recorded yet./\n-      end\n+      context \"when no error has been recorded since startup\" do\n+        it \"shows that no errors have been recorded\" do\n+          expect(body).to match /No errors have been recorded yet./\n+        end\n \n-      it 'does not attempt to use ActionDispatch::ExceptionWrapper with a nil exception' do\n-        ad_ew = double(\"ActionDispatch::ExceptionWrapper\")\n-        stub_const('ActionDispatch::ExceptionWrapper', ad_ew)\n-        expect(ad_ew).to_not receive :new\n+        it 'does not attempt to use ActionDispatch::ExceptionWrapper on the nil exception' do\n+          ad_ew = double(\"ActionDispatch::ExceptionWrapper\")\n+          stub_const('ActionDispatch::ExceptionWrapper', ad_ew)\n+          expect(ad_ew).to_not receive :new\n+\n+          response_env\n+        end\n+\n+        context 'when requested inside a subfolder path' do\n+          let(:response_env) { app.call(\"PATH_INFO\" => \"/any_sub/folder/__better_errors\") }\n \n-        status, headers, body = app.call(\"PATH_INFO\" => \"/__better_errors\")\n+          it \"shows that no errors have been recorded\" do\n+            expect(body).to match /No errors have been recorded yet./\n+          end\n+        end\n       end\n \n-      it \"shows that no errors have been recorded on any subfolder path\" do\n-        status, headers, body = app.call(\"PATH_INFO\" => \"/any_sub/folder/path/__better_errors\")\n-        expect(body.join).to match /No errors have been recorded yet./\n+      context 'when an error has been recorded' do\n+        let(:app) {\n+          Middleware.new(->env do\n+            # Only raise on the first request\n+            raise exception unless @already_raised\n+            @already_raised = true\n+          end)\n+        }\n+        before do\n+          app.call({})\n+        end\n+\n+        it 'returns the information of the most recent error' do\n+          expect(body).to include(\"oh no :(\")\n+        end\n+\n+        it 'does not attempt to use ActionDispatch::ExceptionWrapper' do\n+          ad_ew = double(\"ActionDispatch::ExceptionWrapper\")\n+          stub_const('ActionDispatch::ExceptionWrapper', ad_ew)\n+          expect(ad_ew).to_not receive :new\n+\n+          response_env\n+        end\n+\n+        context 'when inside a subfolder path' do\n+          let(:response_env) { app.call(\"PATH_INFO\" => \"/any_sub/folder/__better_errors\") }\n+\n+          it \"shows the error page on any subfolder path\" do\n+            expect(app).to receive :show_error_page\n+            app.call(\"PATH_INFO\" => \"/any_sub/folder/path/__better_errors/\")\n+          end\n+        end\n       end\n     end\n \n     context \"when handling an error\" do\n       let(:app) { Middleware.new(->env { raise exception }) }\n+      let(:response_env) { app.call({}) }\n \n       it \"returns status 500\" do\n-        status, headers, body = app.call({})\n-\n         expect(status).to eq(500)\n       end\n \n@@ -109,11 +146,9 @@ module BetterErrors\n         }\n \n         it \"shows the exception as-is\" do\n-          status, _, body = app.call({})\n-\n           expect(status).to eq(500)\n-          expect(body.join).to match(/\\n> Second Exception\\n/)\n-          expect(body.join).not_to match(/\\n> First Exception\\n/)\n+          expect(body).to match(/\\n> Second Exception\\n/)\n+          expect(body).not_to match(/\\n> First Exception\\n/)\n         end\n       end\n \n@@ -135,11 +170,9 @@ def initialize(message, original_exception = nil)\n           }\n \n           it \"shows the original exception instead of the last-raised one\" do\n-            status, _, body = app.call({})\n-\n             expect(status).to eq(500)\n-            expect(body.join).not_to match(/Second Exception/)\n-            expect(body.join).to match(/First Exception/)\n+            expect(body).not_to match(/Second Exception/)\n+            expect(body).to match(/First Exception/)\n           end\n         end\n \n@@ -151,41 +184,68 @@ def initialize(message, original_exception = nil)\n           }\n \n           it \"shows the exception as-is\" do\n-            status, _, body = app.call({})\n-\n             expect(status).to eq(500)\n-            expect(body.join).to match(/The Exception/)\n+            expect(body).to match(/The Exception/)\n           end\n         end\n       end\n \n       it \"returns ExceptionWrapper's status_code\" do\n         ad_ew = double(\"ActionDispatch::ExceptionWrapper\")\n-        allow(ad_ew).to receive('new').with({}, exception) { double(\"ExceptionWrapper\", status_code: 404) }\n+        allow(ad_ew).to receive('new').with(anything, exception) { double(\"ExceptionWrapper\", status_code: 404) }\n         stub_const('ActionDispatch::ExceptionWrapper', ad_ew)\n \n-        status, headers, body = app.call({})\n-\n         expect(status).to eq(404)\n       end\n \n       it \"returns UTF-8 error pages\" do\n-        status, headers, body = app.call({})\n-\n         expect(headers[\"Content-Type\"]).to match /charset=utf-8/\n       end\n \n-      it \"returns text pages by default\" do\n-        status, headers, body = app.call({})\n-\n+      it \"returns text content by default\" do\n         expect(headers[\"Content-Type\"]).to match /text\\/plain/\n       end\n \n-      it \"returns HTML pages by default\" do\n-        # Chrome's 'Accept' header looks similar this.\n-        status, headers, body = app.call(\"HTTP_ACCEPT\" => \"text/html,application/xhtml+xml;q=0.9,*/*\")\n+      context 'when a CSRF token cookie is not specified' do\n+        it 'includes a newly-generated CSRF token cookie' do\n+          expect(headers).to include(\n+            'Set-Cookie' => /BetterErrors-CSRF-Token=[-a-z0-9]+; HttpOnly; SameSite=Strict/\n+          )\n+        end\n+      end\n+\n+      context 'when a CSRF token cookie is specified' do\n+        let(:response_env) { app.call({ 'HTTP_COOKIE' => 'BetterErrors-CSRF-Token=abc123' }) }\n+\n+        it 'does not set a new CSRF token cookie' do\n+          expect(headers).not_to include('Set-Cookie')\n+        end\n+      end\n+\n+      context 'when the Accept header specifies HTML first' do\n+        let(:response_env) { app.call(\"HTTP_ACCEPT\" => \"text/html,application/xhtml+xml;q=0.9,*/*\") }\n+\n+        it \"returns HTML content\" do\n+          expect(headers[\"Content-Type\"]).to match /text\\/html/\n+        end\n+\n+        it 'includes the newly-generated CSRF token in the body of the page' do\n+          matches = headers['Set-Cookie'].match(/BetterErrors-CSRF-Token=(?<tok>[-a-z0-9]+); HttpOnly; SameSite=Strict/)\n+          expect(body).to include(matches[:tok])\n+        end\n \n-        expect(headers[\"Content-Type\"]).to match /text\\/html/\n+        context 'when a CSRF token cookie is specified' do\n+          let(:response_env) {\n+            app.call({\n+              'HTTP_COOKIE' => 'BetterErrors-CSRF-Token=csrfTokenGHI',\n+              \"HTTP_ACCEPT\" => \"text/html,application/xhtml+xml;q=0.9,*/*\",\n+            })\n+          }\n+\n+          it 'includes that CSRF token in the body of the page' do\n+            expect(body).to include('csrfTokenGHI')\n+          end\n+        end\n       end\n \n       context 'the logger' do\n@@ -196,7 +256,7 @@ def initialize(message, original_exception = nil)\n \n         it \"receives the exception as a fatal message\" do\n           expect(logger).to receive(:fatal).with(/RuntimeError/)\n-          app.call({})\n+          response_env\n         end\n \n         context 'when Rails is being used' do\n@@ -208,7 +268,7 @@ def initialize(message, original_exception = nil)\n             expect(logger).to receive(:fatal) do |message|\n               expect(message).to_not match(/rspec-core/)\n             end\n-            app.call({})\n+            response_env\n           end\n         end\n         context 'when Rails is not being used' do\n@@ -220,27 +280,23 @@ def initialize(message, original_exception = nil)\n             expect(logger).to receive(:fatal) do |message|\n               expect(message).to match(/rspec-core/)\n             end\n-            app.call({})\n+            response_env\n           end\n         end\n       end\n     end\n \n     context \"requesting the variables for a specific frame\" do\n       let(:env) { {} }\n-      let(:result) {\n-        app.call(\n-          \"PATH_INFO\" => \"/__better_errors/#{id}/#{method}\",\n-          # This is a POST request, and this is the body of the request.\n-          \"rack.input\" => StringIO.new('{\"index\": 0}'),\n-        )\n+      let(:response_env) {\n+        app.call(request_env)\n       }\n-      let(:status) { result[0] }\n-      let(:headers) { result[1] }\n-      let(:body) { result[2].join }\n+      let(:request_env) {\n+        Rack::MockRequest.env_for(\"/__better_errors/#{id}/variables\", input: StringIO.new(JSON.dump(request_body_data)))\n+      }\n+      let(:request_body_data) { {\"index\": 0} }\n       let(:json_body) { JSON.parse(body) }\n       let(:id) { 'abcdefg' }\n-      let(:method) { 'variables' }\n \n       context 'when no errors have been recorded' do\n         it 'returns a JSON error' do\n@@ -291,14 +347,44 @@ def initialize(message, original_exception = nil)\n           end\n         end\n \n-        context 'and it matches the request', :focus do\n+        context 'and its ID matches the requested ID' do\n           let(:id) { error_page.id }\n \n-          it 'returns a JSON error' do\n-            expect(error_page).to receive(:do_variables).and_return(html: \"<content>\")\n-            expect(json_body).to match(\n-              'html' => '<content>',\n-            )\n+          context 'when the body csrfToken matches the CSRF token cookie' do\n+            let(:request_body_data) { { \"index\" => 0, \"csrfToken\" => \"csrfToken123\" } }\n+            before do\n+              request_env[\"HTTP_COOKIE\"] = \"BetterErrors-CSRF-Token=csrfToken123\"\n+            end\n+\n+            it 'returns the HTML content' do\n+              expect(error_page).to receive(:do_variables).and_return(html: \"<content>\")\n+              expect(json_body).to match(\n+                'html' => '<content>',\n+              )\n+            end\n+          end\n+\n+          context 'when the body csrfToken does not match the CSRF token cookie' do\n+            let(:request_body_data) { {\"index\": 0, \"csrfToken\": \"csrfToken123\"} }\n+            before do\n+              request_env[\"HTTP_COOKIE\"] = \"BetterErrors-CSRF-Token=csrfToken456\"\n+            end\n+\n+            it 'returns a JSON error' do\n+              expect(json_body).to match(\n+                'error' => 'Invalid CSRF Token',\n+                'explanation' => /session might have been cleared/,\n+              )\n+            end\n+          end\n+\n+          context 'when there is no CSRF token in the request' do\n+            it 'returns a JSON error' do\n+              expect(json_body).to match(\n+                'error' => 'Invalid CSRF Token',\n+                'explanation' => /session might have been cleared/,\n+              )\n+            end\n           end\n         end\n       end"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "fde3b7025db17b5cda13fcf8d08dfb3f76e189f6",
            "date": "2023-06-14T15:41:14Z",
            "author_login": "RobinDaugherty"
          },
          {
            "sha": "8b1e2c9f33a93fe58d24539159ba126375e4b2aa",
            "date": "2023-06-14T16:47:15Z",
            "author_login": "RobinDaugherty"
          },
          {
            "sha": "6f2d1ead80d5e3d9c2cb4a58cc3d9e49636ae6b7",
            "date": "2023-05-11T17:28:21Z",
            "author_login": "jackjennings"
          },
          {
            "sha": "55ce4f69be35f652e4b967ad2f720ec4d6c5c72f",
            "date": "2023-04-28T15:59:41Z",
            "author_login": "haileys"
          },
          {
            "sha": "b5be43dd4e4806b1eab873072cf57fe3b46a5203",
            "date": "2023-04-28T15:56:49Z",
            "author_login": "haileys"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N",
    "cwe_id": "CWE-352",
    "description": "better_errors is an open source replacement for the standard Rails error page with more information rich error pages. It is also usable outside of Rails in any Rack app as Rack middleware. better_errors prior to 2.8.0 did not implement CSRF protection for its internal requests. It also did not enforce the correct \"Content-Type\" header for these requests, which allowed a cross-origin \"simple request\" to be made without CORS protection. These together left an application with better_errors enabled open to cross-origin attacks. As a developer tool, better_errors documentation strongly recommends addition only to the `development` bundle group, so this vulnerability should only affect development environments. Please ensure that your project limits better_errors to the `development` group (or the non-Rails equivalent). Starting with release 2.8.x, CSRF protection is enforced. It is recommended that you upgrade to the latest release, or minimally to \"~> 2.8.3\". There are no known workarounds to mitigate the risk of using older releases of better_errors.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2021-09-07T18:15:07.473",
    "last_modified": "2024-11-21T06:18:52.210",
    "fix_date": "2020-09-15T17:18:15Z"
  },
  "references": [
    {
      "url": "https://github.com/BetterErrors/better_errors/commit/8e8e796bfbde4aa088741823c8a3fc6df2089bb0",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/BetterErrors/better_errors/discussions/507",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/BetterErrors/better_errors/pull/474",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/BetterErrors/better_errors/security/advisories/GHSA-w3j4-76qw-wwjm",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/BetterErrors/better_errors/commit/8e8e796bfbde4aa088741823c8a3fc6df2089bb0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/BetterErrors/better_errors/discussions/507",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/BetterErrors/better_errors/pull/474",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/BetterErrors/better_errors/security/advisories/GHSA-w3j4-76qw-wwjm",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:05.139549",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "better_errors",
    "owner": "BetterErrors",
    "created_at": "2012-12-08T11:02:18Z",
    "updated_at": "2025-01-10T15:00:41Z",
    "pushed_at": "2024-07-09T08:00:44Z",
    "size": 1494,
    "stars": 6874,
    "forks": 437,
    "open_issues": 69,
    "watchers": 6874,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Ruby": 106586,
      "SCSS": 24734,
      "HTML": 19540
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T18:51:08.050936"
  }
}