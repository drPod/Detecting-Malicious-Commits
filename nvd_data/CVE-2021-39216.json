{
  "cve_id": "CVE-2021-39216",
  "github_data": {
    "repository": "bytecodealliance/wasmtime",
    "fix_commit": "101998733b74624cbd348a2366d05760b40181f3",
    "related_commits": [
      "101998733b74624cbd348a2366d05760b40181f3",
      "101998733b74624cbd348a2366d05760b40181f3"
    ],
    "patch_url": "https://github.com/bytecodealliance/wasmtime/commit/101998733b74624cbd348a2366d05760b40181f3.patch",
    "fix_commit_details": {
      "sha": "101998733b74624cbd348a2366d05760b40181f3",
      "commit_date": "2021-09-17T17:27:29Z",
      "author": {
        "login": "fitzgen",
        "type": "User",
        "stats": {
          "total_commits": 994,
          "average_weekly_commits": 2.1655773420479303,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 212
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-v4cp-h94r-m7xf",
        "length": 103,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 771,
        "additions": 665,
        "deletions": 106
      },
      "files": [
        {
          "filename": "cranelift/wasm/src/environ/dummy.rs",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -688,8 +688,8 @@ impl<'data> ModuleEnvironment<'data> for DummyEnvironment {\n                 WasmType::FuncRef | WasmType::ExternRef | WasmType::ExnRef => reference_type,\n             })\n         };\n-        sig.params.extend(wasm.params.iter().map(&mut cvt));\n-        sig.returns.extend(wasm.returns.iter().map(&mut cvt));\n+        sig.params.extend(wasm.params().iter().map(&mut cvt));\n+        sig.returns.extend(wasm.returns().iter().map(&mut cvt));\n         self.info.signatures.push(sig);\n         Ok(())\n     }"
        },
        {
          "filename": "crates/cranelift/src/compiler.rs",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -465,7 +465,7 @@ impl Compiler {\n \n         // Compute the size of the values vector. The vmctx and caller vmctx are passed separately.\n         let value_size = mem::size_of::<u128>();\n-        let values_vec_len = (value_size * cmp::max(ty.params.len(), ty.returns.len())) as u32;\n+        let values_vec_len = (value_size * cmp::max(ty.params().len(), ty.returns().len())) as u32;\n \n         let mut context = Context::new();\n         context.func =\n@@ -486,7 +486,7 @@ impl Compiler {\n \n         let values_vec_ptr_val = builder.ins().stack_addr(pointer_type, ss, 0);\n         let mflags = MemFlags::trusted();\n-        for i in 0..ty.params.len() {\n+        for i in 0..ty.params().len() {\n             let val = builder.func.dfg.block_params(block0)[i + 2];\n             builder\n                 .ins()\n@@ -508,7 +508,7 @@ impl Compiler {\n \n         let mflags = MemFlags::trusted();\n         let mut results = Vec::new();\n-        for (i, r) in ty.returns.iter().enumerate() {\n+        for (i, r) in ty.returns().iter().enumerate() {\n             let load = builder.ins().load(\n                 value_type(isa, *r),\n                 mflags,"
        },
        {
          "filename": "crates/cranelift/src/lib.rs",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -220,8 +220,8 @@ fn wasmtime_call_conv(isa: &dyn TargetIsa) -> CallConv {\n /// above.\n fn push_types(isa: &dyn TargetIsa, sig: &mut ir::Signature, wasm: &WasmFuncType) {\n     let cvt = |ty: &WasmType| ir::AbiParam::new(value_type(isa, *ty));\n-    sig.params.extend(wasm.params.iter().map(&cvt));\n-    sig.returns.extend(wasm.returns.iter().map(&cvt));\n+    sig.params.extend(wasm.params().iter().map(&cvt));\n+    sig.returns.extend(wasm.returns().iter().map(&cvt));\n }\n \n /// Returns the corresponding cranelift type for the provided wasm type."
        },
        {
          "filename": "crates/environ/src/module_environ.rs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -608,7 +608,7 @@ impl<'data> ModuleEnvironment<'data> {\n                         .funcs\n                         .push(FunctionMetadata {\n                             locals: locals.into_boxed_slice(),\n-                            params: sig.params.iter().cloned().map(|i| i.into()).collect(),\n+                            params: sig.params().iter().cloned().map(|i| i.into()).collect(),\n                         });\n                 }\n                 body.allow_memarg64(self.features.memory64);"
        },
        {
          "filename": "crates/fuzzing/src/generators/table_ops.rs",
          "status": "modified",
          "additions": 200,
          "deletions": 42,
          "patch": "@@ -18,7 +18,7 @@ pub struct TableOps {\n \n const NUM_PARAMS_RANGE: Range<u8> = 1..10;\n const TABLE_SIZE_RANGE: Range<u32> = 1..100;\n-const MAX_OPS: usize = 1000;\n+const MAX_OPS: usize = 100;\n \n impl TableOps {\n     /// Get the number of parameters this module's \"run\" function takes.\n@@ -49,9 +49,46 @@ impl TableOps {\n     pub fn to_wasm_binary(&self) -> Vec<u8> {\n         let mut module = Module::new();\n \n+        // Encode the types for all functions that we are using.\n+        let mut types = TypeSection::new();\n+\n+        // 0: \"gc\"\n+        types.function(\n+            vec![],\n+            // Return a bunch of stuff from `gc` so that we exercise GCing when\n+            // there is return pointer space allocated on the stack. This is\n+            // especially important because the x64 backend currently\n+            // dynamically adjusts the stack pointer for each call that uses\n+            // return pointers rather than statically allocating space in the\n+            // stack frame.\n+            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],\n+        );\n+\n+        // 1: \"run\"\n+        let mut params: Vec<ValType> = Vec::with_capacity(self.num_params() as usize);\n+        for _i in 0..self.num_params() {\n+            params.push(ValType::ExternRef);\n+        }\n+        let results = vec![];\n+        types.function(params, results);\n+\n+        // 2: `take_refs`\n+        types.function(\n+            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],\n+            vec![],\n+        );\n+\n+        // 3: `make_refs`\n+        types.function(\n+            vec![],\n+            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],\n+        );\n+\n         // Import the GC function.\n         let mut imports = ImportSection::new();\n         imports.import(\"\", Some(\"gc\"), EntityType::Function(0));\n+        imports.import(\"\", Some(\"take_refs\"), EntityType::Function(2));\n+        imports.import(\"\", Some(\"make_refs\"), EntityType::Function(3));\n \n         // Define our table.\n         let mut tables = TableSection::new();\n@@ -61,32 +98,24 @@ impl TableOps {\n             maximum: None,\n         });\n \n-        // Encode the types for all functions that we are using.\n-        let mut types = TypeSection::new();\n-        types.function(vec![], vec![]); // 0: \"gc\"\n-        let mut params: Vec<ValType> = Vec::with_capacity(self.num_params() as usize);\n-        for _i in 0..self.num_params() {\n-            params.push(ValType::ExternRef);\n-        }\n-        let results = vec![];\n-        types.function(params, results); // 1: \"run\"\n-\n         // Define the \"run\" function export.\n         let mut functions = FunctionSection::new();\n         functions.function(1);\n \n         let mut exports = ExportSection::new();\n-        exports.export(\"run\", Export::Function(1));\n+        exports.export(\"run\", Export::Function(3));\n \n-        let mut params: Vec<(u32, ValType)> = Vec::with_capacity(self.num_params() as usize);\n-        for _i in 0..self.num_params() {\n-            params.push((0, ValType::ExternRef));\n-        }\n-        let mut func = Function::new(params);\n+        // Give ourselves one scratch local that we can use in various `TableOp`\n+        // implementations.\n+        let mut func = Function::new(vec![(1, ValType::ExternRef)]);\n \n+        func.instruction(Instruction::Loop(wasm_encoder::BlockType::Empty));\n         for op in self.ops.iter().take(MAX_OPS) {\n-            op.insert(&mut func);\n+            op.insert(&mut func, self.num_params() as u32, self.table_size());\n         }\n+        func.instruction(Instruction::Br(0));\n+        func.instruction(Instruction::End);\n+        func.instruction(Instruction::End);\n \n         let mut code = CodeSection::new();\n         code.function(&func);\n@@ -105,38 +134,110 @@ impl TableOps {\n \n #[derive(Arbitrary, Debug)]\n pub(crate) enum TableOp {\n-    // `(call 0)`\n+    // `call $gc; drop; drop; drop;`\n     Gc,\n     // `(drop (table.get x))`\n     Get(i32),\n     // `(table.set x (local.get y))`\n     SetFromParam(i32, u32),\n     // `(table.set x (table.get y))`\n     SetFromGet(i32, i32),\n+    // `call $make_refs; table.set x; table.set y; table.set z`\n+    SetFromMake(i32, i32, i32),\n+    // `call $make_refs; drop; drop; drop;`\n+    Make,\n+    // `local.get x; local.get y; local.get z; call $take_refs`\n+    TakeFromParams(u32, u32, u32),\n+    // `table.get x; table.get y; table.get z; call $take_refs`\n+    TakeFromGet(i32, i32, i32),\n+    // `call $make_refs; call $take_refs`\n+    TakeFromMake,\n+    // `call $gc; call $take_refs`\n+    TakeFromGc,\n }\n \n impl TableOp {\n-    fn insert(&self, func: &mut Function) {\n+    fn insert(&self, func: &mut Function, num_params: u32, table_size: u32) {\n+        assert!(num_params > 0);\n+        assert!(table_size > 0);\n+\n+        // Add one to make sure that out of bounds table accesses are possible,\n+        // but still rare.\n+        let table_mod = table_size as i32 + 1;\n+\n         match self {\n             Self::Gc => {\n                 func.instruction(Instruction::Call(0));\n+                func.instruction(Instruction::Drop);\n+                func.instruction(Instruction::Drop);\n+                func.instruction(Instruction::Drop);\n             }\n             Self::Get(x) => {\n-                func.instruction(Instruction::I32Const(*x));\n+                func.instruction(Instruction::I32Const(*x % table_mod));\n                 func.instruction(Instruction::TableGet { table: 0 });\n                 func.instruction(Instruction::Drop);\n             }\n             Self::SetFromParam(x, y) => {\n-                func.instruction(Instruction::I32Const(*x));\n-                func.instruction(Instruction::LocalGet(*y));\n+                func.instruction(Instruction::I32Const(*x % table_mod));\n+                func.instruction(Instruction::LocalGet(*y % num_params));\n                 func.instruction(Instruction::TableSet { table: 0 });\n             }\n             Self::SetFromGet(x, y) => {\n-                func.instruction(Instruction::I32Const(*x));\n-                func.instruction(Instruction::I32Const(*y));\n+                func.instruction(Instruction::I32Const(*x % table_mod));\n+                func.instruction(Instruction::I32Const(*y % table_mod));\n                 func.instruction(Instruction::TableGet { table: 0 });\n                 func.instruction(Instruction::TableSet { table: 0 });\n             }\n+            Self::SetFromMake(x, y, z) => {\n+                func.instruction(Instruction::Call(2));\n+\n+                func.instruction(Instruction::LocalSet(num_params));\n+                func.instruction(Instruction::I32Const(*x % table_mod));\n+                func.instruction(Instruction::LocalGet(num_params));\n+                func.instruction(Instruction::TableSet { table: 0 });\n+\n+                func.instruction(Instruction::LocalSet(num_params));\n+                func.instruction(Instruction::I32Const(*y % table_mod));\n+                func.instruction(Instruction::LocalGet(num_params));\n+                func.instruction(Instruction::TableSet { table: 0 });\n+\n+                func.instruction(Instruction::LocalSet(num_params));\n+                func.instruction(Instruction::I32Const(*z % table_mod));\n+                func.instruction(Instruction::LocalGet(num_params));\n+                func.instruction(Instruction::TableSet { table: 0 });\n+            }\n+            TableOp::Make => {\n+                func.instruction(Instruction::Call(2));\n+                func.instruction(Instruction::Drop);\n+                func.instruction(Instruction::Drop);\n+                func.instruction(Instruction::Drop);\n+            }\n+            TableOp::TakeFromParams(x, y, z) => {\n+                func.instruction(Instruction::LocalGet(x % num_params));\n+                func.instruction(Instruction::LocalGet(y % num_params));\n+                func.instruction(Instruction::LocalGet(z % num_params));\n+                func.instruction(Instruction::Call(1));\n+            }\n+            TableOp::TakeFromGet(x, y, z) => {\n+                func.instruction(Instruction::I32Const(*x % table_mod));\n+                func.instruction(Instruction::TableGet { table: 0 });\n+\n+                func.instruction(Instruction::I32Const(*y % table_mod));\n+                func.instruction(Instruction::TableGet { table: 0 });\n+\n+                func.instruction(Instruction::I32Const(*z % table_mod));\n+                func.instruction(Instruction::TableGet { table: 0 });\n+\n+                func.instruction(Instruction::Call(1));\n+            }\n+            TableOp::TakeFromMake => {\n+                func.instruction(Instruction::Call(2));\n+                func.instruction(Instruction::Call(1));\n+            }\n+            Self::TakeFromGc => {\n+                func.instruction(Instruction::Call(0));\n+                func.instruction(Instruction::Call(1));\n+            }\n         }\n     }\n }\n@@ -148,38 +249,95 @@ mod tests {\n     #[test]\n     fn test_wat_string() {\n         let ops = TableOps {\n-            num_params: 2,\n-            table_size: 10,\n+            num_params: 5,\n+            table_size: 20,\n             ops: vec![\n                 TableOp::Gc,\n                 TableOp::Get(0),\n                 TableOp::SetFromParam(1, 2),\n                 TableOp::SetFromGet(3, 4),\n+                TableOp::SetFromMake(5, 6, 7),\n+                TableOp::Make,\n+                TableOp::TakeFromParams(8, 9, 10),\n+                TableOp::TakeFromGet(11, 12, 13),\n+                TableOp::TakeFromMake,\n             ],\n         };\n \n         let expected = r#\"\n (module\n   (type (;0;) (func))\n-  (type (;1;) (func (param externref externref)))\n+  (type (;1;) (func (param externref externref externref externref externref)))\n+  (type (;2;) (func (param externref externref externref)))\n+  (type (;3;) (func (result externref externref externref)))\n   (import \"\" \"gc\" (func (;0;) (type 0)))\n-  (func (;1;) (type 1) (param externref externref)\n-    call 0\n-    i32.const 0\n-    table.get 0\n-    drop\n-    i32.const 1\n-    local.get 2\n-    table.set 0\n-    i32.const 3\n-    i32.const 4\n-    table.get 0\n-    table.set 0)\n-  (table (;0;) 10 externref)\n-  (export \"run\" (func 1)))\n+  (import \"\" \"take_refs\" (func (;1;) (type 2)))\n+  (import \"\" \"make_refs\" (func (;2;) (type 3)))\n+  (func (;3;) (type 1) (param externref externref externref externref externref)\n+    (local externref i32)\n+    i32.const 100\n+    local.set 6\n+    loop  ;; label = @1\n+      call 0\n+      i32.const 0\n+      table.get 0\n+      drop\n+      i32.const 1\n+      local.get 2\n+      table.set 0\n+      i32.const 3\n+      i32.const 4\n+      table.get 0\n+      table.set 0\n+      call 2\n+      local.set 5\n+      i32.const 5\n+      local.get 5\n+      table.set 0\n+      local.set 5\n+      i32.const 6\n+      local.get 5\n+      table.set 0\n+      local.set 5\n+      i32.const 7\n+      local.get 5\n+      table.set 0\n+      call 2\n+      drop\n+      drop\n+      drop\n+      local.get 3\n+      local.get 4\n+      local.get 0\n+      call 1\n+      i32.const 11\n+      table.get 0\n+      i32.const 12\n+      table.get 0\n+      i32.const 13\n+      table.get 0\n+      call 1\n+      call 2\n+      call 1\n+      local.get 6\n+      i32.const -1\n+      i32.add\n+      local.tee 6\n+      br_if 0 (;@1;)\n+    end)\n+  (table (;0;) 20 externref)\n+  (export \"run\" (func 3)))\n \"#;\n+        eprintln!(\"expected WAT = {}\", expected);\n+\n         let actual = ops.to_wasm_binary();\n+        if let Err(e) = wasmparser::validate(&actual) {\n+            panic!(\"TableOps should generate valid Wasm; got error: {}\", e);\n+        }\n+\n         let actual = wasmprinter::print_bytes(&actual).unwrap();\n+        eprintln!(\"actual WAT = {}\", actual);\n+\n         assert_eq!(actual.trim(), expected.trim());\n     }\n }"
        },
        {
          "filename": "crates/fuzzing/src/oracles.rs",
          "status": "modified",
          "additions": 97,
          "deletions": 10,
          "patch": "@@ -514,16 +514,17 @@ pub fn table_ops(\n ) {\n     let _ = env_logger::try_init();\n \n+    let expected_drops = Arc::new(AtomicUsize::new(ops.num_params() as usize));\n     let num_dropped = Arc::new(AtomicUsize::new(0));\n \n     {\n         let mut config = fuzz_config.to_wasmtime();\n         config.wasm_reference_types(true);\n+        config.consume_fuel(true);\n+\n         let engine = Engine::new(&config).unwrap();\n         let mut store = create_store(&engine);\n-        if fuzz_config.consume_fuel {\n-            store.add_fuel(u64::max_value()).unwrap();\n-        }\n+        store.add_fuel(100).unwrap();\n \n         let wasm = ops.to_wasm_binary();\n         log_wasm(&wasm);\n@@ -532,18 +533,104 @@ pub fn table_ops(\n             Err(_) => return,\n         };\n \n+        let mut linker = Linker::new(&engine);\n+\n         // To avoid timeouts, limit the number of explicit GCs we perform per\n         // test case.\n         const MAX_GCS: usize = 5;\n \n         let num_gcs = AtomicUsize::new(0);\n-        let gc = Func::wrap(&mut store, move |mut caller: Caller<'_, StoreLimits>| {\n-            if num_gcs.fetch_add(1, SeqCst) < MAX_GCS {\n-                caller.gc();\n-            }\n-        });\n+        linker\n+            .define(\n+                \"\",\n+                \"gc\",\n+                // NB: use `Func::new` so that this can still compile on the old x86\n+                // backend, where `IntoFunc` isn't implemented for multi-value\n+                // returns.\n+                Func::new(\n+                    &mut store,\n+                    FuncType::new(\n+                        vec![],\n+                        vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],\n+                    ),\n+                    {\n+                        let num_dropped = num_dropped.clone();\n+                        let expected_drops = expected_drops.clone();\n+                        move |mut caller: Caller<'_, StoreLimits>, _params, results| {\n+                            if num_gcs.fetch_add(1, SeqCst) < MAX_GCS {\n+                                caller.gc();\n+                            }\n+\n+                            expected_drops.fetch_add(3, SeqCst);\n+                            results[0] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            results[1] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            results[2] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            Ok(())\n+                        }\n+                    },\n+                ),\n+            )\n+            .unwrap();\n+\n+        linker\n+            .func_wrap(\"\", \"take_refs\", {\n+                let expected_drops = expected_drops.clone();\n+                move |a: Option<ExternRef>, b: Option<ExternRef>, c: Option<ExternRef>| {\n+                    // Do the assertion on each ref's inner data, even though it\n+                    // all points to the same atomic, so that if we happen to\n+                    // run into a use-after-free bug with one of these refs we\n+                    // are more likely to trigger a segfault.\n+                    if let Some(a) = a {\n+                        let a = a.data().downcast_ref::<CountDrops>().unwrap();\n+                        assert!(a.0.load(SeqCst) <= expected_drops.load(SeqCst));\n+                    }\n+                    if let Some(b) = b {\n+                        let b = b.data().downcast_ref::<CountDrops>().unwrap();\n+                        assert!(b.0.load(SeqCst) <= expected_drops.load(SeqCst));\n+                    }\n+                    if let Some(c) = c {\n+                        let c = c.data().downcast_ref::<CountDrops>().unwrap();\n+                        assert!(c.0.load(SeqCst) <= expected_drops.load(SeqCst));\n+                    }\n+                }\n+            })\n+            .unwrap();\n+\n+        linker\n+            .define(\n+                \"\",\n+                \"make_refs\",\n+                // NB: use `Func::new` so that this can still compile on the old\n+                // x86 backend, where `IntoFunc` isn't implemented for\n+                // multi-value returns.\n+                Func::new(\n+                    &mut store,\n+                    FuncType::new(\n+                        vec![],\n+                        vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],\n+                    ),\n+                    {\n+                        let num_dropped = num_dropped.clone();\n+                        let expected_drops = expected_drops.clone();\n+                        move |_caller, _params, results| {\n+                            expected_drops.fetch_add(3, SeqCst);\n+                            results[0] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            results[1] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            results[2] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            Ok(())\n+                        }\n+                    },\n+                ),\n+            )\n+            .unwrap();\n \n-        let instance = Instance::new(&mut store, &module, &[gc.into()]).unwrap();\n+        let instance = linker.instantiate(&mut store, &module).unwrap();\n         let run = instance.get_func(&mut store, \"run\").unwrap();\n \n         let args: Vec<_> = (0..ops.num_params())\n@@ -552,7 +639,7 @@ pub fn table_ops(\n         let _ = run.call(&mut store, &args);\n     }\n \n-    assert_eq!(num_dropped.load(SeqCst), ops.num_params() as usize);\n+    assert_eq!(num_dropped.load(SeqCst), expected_drops.load(SeqCst));\n     return;\n \n     struct CountDrops(Arc<AtomicUsize>);"
        },
        {
          "filename": "crates/runtime/src/externref.rs",
          "status": "modified",
          "additions": 55,
          "deletions": 2,
          "patch": "@@ -489,7 +489,7 @@ type TableElem = UnsafeCell<Option<VMExternRef>>;\n ///\n /// Under the covers, this is a simple bump allocator that allows duplicate\n /// entries. Deduplication happens at GC time.\n-#[repr(C)] // `alloc` must be the first member, it's accessed from JIT code\n+#[repr(C)] // `alloc` must be the first member, it's accessed from JIT code.\n pub struct VMExternRefActivationsTable {\n     /// Structures used to perform fast bump allocation of storage of externref\n     /// values.\n@@ -521,9 +521,14 @@ pub struct VMExternRefActivationsTable {\n     /// inside-a-Wasm-frame roots, and doing a GC could lead to freeing one of\n     /// those missed roots, and use after free.\n     stack_canary: Option<usize>,\n+\n+    /// A debug-only field for asserting that we are in a region of code where\n+    /// GC is okay to preform.\n+    #[cfg(debug_assertions)]\n+    gc_okay: bool,\n }\n \n-#[repr(C)] // this is accessed from JTI code\n+#[repr(C)] // This is accessed from JIT code.\n struct VMExternRefTableAlloc {\n     /// Bump-allocation finger within the `chunk`.\n     ///\n@@ -573,6 +578,8 @@ impl VMExternRefActivationsTable {\n             over_approximated_stack_roots: HashSet::with_capacity(Self::CHUNK_SIZE),\n             precise_stack_roots: HashSet::with_capacity(Self::CHUNK_SIZE),\n             stack_canary: None,\n+            #[cfg(debug_assertions)]\n+            gc_okay: true,\n         }\n     }\n \n@@ -581,6 +588,14 @@ impl VMExternRefActivationsTable {\n         (0..size).map(|_| UnsafeCell::new(None)).collect()\n     }\n \n+    /// Get the available capacity in the bump allocation chunk.\n+    #[inline]\n+    pub fn bump_capacity_remaining(&self) -> usize {\n+        let end = self.alloc.end.as_ptr() as usize;\n+        let next = unsafe { *self.alloc.next.get() };\n+        end - next.as_ptr() as usize\n+    }\n+\n     /// Try and insert a `VMExternRef` into this table.\n     ///\n     /// This is a fast path that only succeeds when the bump chunk has the\n@@ -624,6 +639,9 @@ impl VMExternRefActivationsTable {\n         externref: VMExternRef,\n         module_info_lookup: &dyn ModuleInfoLookup,\n     ) {\n+        #[cfg(debug_assertions)]\n+        assert!(self.gc_okay);\n+\n         if let Err(externref) = self.try_insert(externref) {\n             self.gc_and_insert_slow(externref, module_info_lookup);\n         }\n@@ -644,6 +662,20 @@ impl VMExternRefActivationsTable {\n             .insert(VMExternRefWithTraits(externref));\n     }\n \n+    /// Insert a reference into the table, without ever performing GC.\n+    #[inline]\n+    pub fn insert_without_gc(&mut self, externref: VMExternRef) {\n+        if let Err(externref) = self.try_insert(externref) {\n+            self.insert_slow_without_gc(externref);\n+        }\n+    }\n+\n+    #[inline(never)]\n+    fn insert_slow_without_gc(&mut self, externref: VMExternRef) {\n+        self.over_approximated_stack_roots\n+            .insert(VMExternRefWithTraits(externref));\n+    }\n+\n     fn num_filled_in_bump_chunk(&self) -> usize {\n         let next = unsafe { *self.alloc.next.get() };\n         let bytes_unused = (self.alloc.end.as_ptr() as usize) - (next.as_ptr() as usize);\n@@ -742,6 +774,24 @@ impl VMExternRefActivationsTable {\n     pub fn set_stack_canary(&mut self, canary: Option<usize>) {\n         self.stack_canary = canary;\n     }\n+\n+    /// Set whether it is okay to GC or not right now.\n+    ///\n+    /// This is provided as a helper for enabling various debug-only assertions\n+    /// and checking places where the `wasmtime-runtime` user expects there not\n+    /// to be any GCs.\n+    #[inline]\n+    pub fn set_gc_okay(&mut self, okay: bool) -> bool {\n+        #[cfg(debug_assertions)]\n+        {\n+            return std::mem::replace(&mut self.gc_okay, okay);\n+        }\n+        #[cfg(not(debug_assertions))]\n+        {\n+            let _ = okay;\n+            return true;\n+        }\n+    }\n }\n \n /// Used by the runtime to lookup information about a module given a\n@@ -807,6 +857,9 @@ pub unsafe fn gc(\n ) {\n     log::debug!(\"start GC\");\n \n+    #[cfg(debug_assertions)]\n+    assert!(externref_activations_table.gc_okay);\n+\n     debug_assert!({\n         // This set is only non-empty within this function. It is built up when\n         // walking the stack and interpreting stack maps, and then drained back"
        },
        {
          "filename": "crates/types/src/lib.rs",
          "status": "modified",
          "additions": 53,
          "deletions": 16,
          "patch": "@@ -87,29 +87,66 @@ impl fmt::Display for WasmType {\n /// WebAssembly function type -- equivalent of `wasmparser`'s FuncType.\n #[derive(Debug, Clone, Eq, PartialEq, Hash, Serialize, Deserialize)]\n pub struct WasmFuncType {\n+    params: Box<[WasmType]>,\n+    externref_params_count: usize,\n+    returns: Box<[WasmType]>,\n+    externref_returns_count: usize,\n+}\n+\n+impl WasmFuncType {\n+    #[inline]\n+    pub fn new(params: Box<[WasmType]>, returns: Box<[WasmType]>) -> Self {\n+        let externref_params_count = params.iter().filter(|p| **p == WasmType::ExternRef).count();\n+        let externref_returns_count = params.iter().filter(|r| **r == WasmType::ExternRef).count();\n+        WasmFuncType {\n+            params,\n+            externref_params_count,\n+            returns,\n+            externref_returns_count,\n+        }\n+    }\n+\n     /// Function params types.\n-    pub params: Box<[WasmType]>,\n+    #[inline]\n+    pub fn params(&self) -> &[WasmType] {\n+        &self.params\n+    }\n+\n+    /// How many `externref`s are in this function's params?\n+    #[inline]\n+    pub fn externref_params_count(&self) -> usize {\n+        self.externref_params_count\n+    }\n+\n     /// Returns params types.\n-    pub returns: Box<[WasmType]>,\n+    #[inline]\n+    pub fn returns(&self) -> &[WasmType] {\n+        &self.returns\n+    }\n+\n+    /// How many `externref`s are in this function's returns?\n+    #[inline]\n+    pub fn externref_returns_count(&self) -> usize {\n+        self.externref_returns_count\n+    }\n }\n \n impl TryFrom<wasmparser::FuncType> for WasmFuncType {\n     type Error = WasmError;\n     fn try_from(ty: wasmparser::FuncType) -> Result<Self, Self::Error> {\n-        Ok(Self {\n-            params: ty\n-                .params\n-                .into_vec()\n-                .into_iter()\n-                .map(WasmType::try_from)\n-                .collect::<Result<_, Self::Error>>()?,\n-            returns: ty\n-                .returns\n-                .into_vec()\n-                .into_iter()\n-                .map(WasmType::try_from)\n-                .collect::<Result<_, Self::Error>>()?,\n-        })\n+        let params = ty\n+            .params\n+            .into_vec()\n+            .into_iter()\n+            .map(WasmType::try_from)\n+            .collect::<Result<_, Self::Error>>()?;\n+        let returns = ty\n+            .returns\n+            .into_vec()\n+            .into_iter()\n+            .map(WasmType::try_from)\n+            .collect::<Result<_, Self::Error>>()?;\n+        Ok(Self::new(params, returns))\n     }\n }\n "
        },
        {
          "filename": "crates/wasmtime/src/func.rs",
          "status": "modified",
          "additions": 28,
          "deletions": 2,
          "patch": "@@ -774,6 +774,21 @@ impl Func {\n \n             let mut values_vec = vec![0; max(params.len(), ty.results().len())];\n \n+            // Whenever we pass `externref`s from host code to Wasm code, they\n+            // go into the `VMExternRefActivationsTable`. But the table might be\n+            // at capacity already, so check for that. If it is at capacity\n+            // (unlikely) then do a GC to free up space. This is necessary\n+            // because otherwise we would either keep filling up the bump chunk\n+            // and making it larger and larger or we would always take the slow\n+            // path when inserting references into the table.\n+            if ty.as_wasm_func_type().externref_params_count()\n+                > store\n+                    .externref_activations_table()\n+                    .bump_capacity_remaining()\n+            {\n+                store.gc();\n+            }\n+\n             // Store the argument values into `values_vec`.\n             let param_tys = ty.params();\n             for ((arg, slot), ty) in params.iter().cloned().zip(&mut values_vec).zip(param_tys) {\n@@ -788,7 +803,7 @@ impl Func {\n                     bail!(\"cross-`Store` values are not currently supported\");\n                 }\n                 unsafe {\n-                    arg.write_value_to(store, slot);\n+                    arg.write_value_without_gc(store, slot);\n                 }\n             }\n \n@@ -871,6 +886,17 @@ impl Func {\n         let (params, results) = val_vec.split_at_mut(nparams);\n         func(caller.sub_caller(), params, results)?;\n \n+        // See the comment in `Func::call_impl`'s `write_params` function.\n+        if ty.as_wasm_func_type().externref_returns_count()\n+            > caller\n+                .store\n+                .0\n+                .externref_activations_table()\n+                .bump_capacity_remaining()\n+        {\n+            caller.store.gc();\n+        }\n+\n         // Unlike our arguments we need to dynamically check that the return\n         // values produced are correct. There could be a bug in `func` that\n         // produces the wrong number, wrong types, or wrong stores of\n@@ -887,7 +913,7 @@ impl Func {\n                 ));\n             }\n             unsafe {\n-                ret.write_value_to(caller.store.0, values_vec.add(i));\n+                ret.write_value_without_gc(caller.store.0, values_vec.add(i));\n             }\n         }\n "
        },
        {
          "filename": "crates/wasmtime/src/func/typed.rs",
          "status": "modified",
          "additions": 93,
          "deletions": 8,
          "patch": "@@ -1,5 +1,5 @@\n use super::{invoke_wasm_and_catch_traps, HostAbi};\n-use crate::store::StoreOpaque;\n+use crate::store::{AutoAssertNoGc, StoreOpaque};\n use crate::{AsContextMut, ExternRef, Func, StoreContextMut, Trap, ValType};\n use anyhow::{bail, Result};\n use std::marker;\n@@ -115,15 +115,33 @@ where\n         store: &mut StoreContextMut<'_, T>,\n         params: Params,\n     ) -> Result<Results, Trap> {\n+        // See the comment in `Func::call_impl`'s `write_params` function.\n+        if params.externrefs_count()\n+            > store\n+                .0\n+                .externref_activations_table()\n+                .bump_capacity_remaining()\n+        {\n+            store.gc();\n+        }\n+\n         // Validate that all runtime values flowing into this store indeed\n         // belong within this store, otherwise it would be unsafe for store\n         // values to cross each other.\n-        let params = match params.into_abi(store.0) {\n-            Some(abi) => abi,\n-            None => {\n-                return Err(Trap::new(\n-                    \"attempt to pass cross-`Store` value to Wasm as function argument\",\n-                ))\n+\n+        let params = {\n+            // GC is not safe here, since we move refs into the activations\n+            // table but don't hold a strong reference onto them until we enter\n+            // the Wasm frame and they get referenced from the stack maps.\n+            let mut store = AutoAssertNoGc::new(&mut **store.as_context_mut().0);\n+\n+            match params.into_abi(&mut store) {\n+                Some(abi) => abi,\n+                None => {\n+                    return Err(Trap::new(\n+                        \"attempt to pass cross-`Store` value to Wasm as function argument\",\n+                    ))\n+                }\n             }\n         };\n \n@@ -183,6 +201,8 @@ pub unsafe trait WasmTy: Send {\n     #[doc(hidden)]\n     fn compatible_with_store(&self, store: &StoreOpaque) -> bool;\n     #[doc(hidden)]\n+    fn is_externref(&self) -> bool;\n+    #[doc(hidden)]\n     fn into_abi(self, store: &mut StoreOpaque) -> Self::Abi;\n     #[doc(hidden)]\n     unsafe fn from_abi(abi: Self::Abi, store: &mut StoreOpaque) -> Self;\n@@ -201,6 +221,10 @@ macro_rules! primitives {\n                 true\n             }\n             #[inline]\n+            fn is_externref(&self) -> bool {\n+                false\n+            }\n+            #[inline]\n             fn into_abi(self, _store: &mut StoreOpaque) -> Self::Abi {\n                 self\n             }\n@@ -234,12 +258,46 @@ unsafe impl WasmTy for Option<ExternRef> {\n         true\n     }\n \n+    #[inline]\n+    fn is_externref(&self) -> bool {\n+        true\n+    }\n+\n     #[inline]\n     fn into_abi(self, store: &mut StoreOpaque) -> Self::Abi {\n         if let Some(x) = self {\n             let abi = x.inner.as_raw();\n             unsafe {\n-                store.insert_vmexternref(x.inner);\n+                // NB: We _must not_ trigger a GC when passing refs from host\n+                // code into Wasm (e.g. returned from a host function or passed\n+                // as arguments to a Wasm function). After insertion into the\n+                // table, this reference is no longer rooted. If multiple\n+                // references are being sent from the host into Wasm and we\n+                // allowed GCs during insertion, then the following events could\n+                // happen:\n+                //\n+                // * Reference A is inserted into the activations\n+                //   table. This does not trigger a GC, but does fill the table\n+                //   to capacity.\n+                //\n+                // * The caller's reference to A is removed. Now the only\n+                //   reference to A is from the activations table.\n+                //\n+                // * Reference B is inserted into the activations table. Because\n+                //   the table is at capacity, a GC is triggered.\n+                //\n+                // * A is reclaimed because the only reference keeping it alive\n+                //   was the activation table's reference (it isn't inside any\n+                //   Wasm frames on the stack yet, so stack scanning and stack\n+                //   maps don't increment its reference count).\n+                //\n+                // * We transfer control to Wasm, giving it A and B. Wasm uses\n+                //   A. That's a use after free.\n+                //\n+                // In conclusion, to prevent uses after free, we cannot GC\n+                // during this insertion.\n+                let mut store = AutoAssertNoGc::new(store);\n+                store.insert_vmexternref_without_gc(x.inner);\n             }\n             abi\n         } else {\n@@ -276,6 +334,11 @@ unsafe impl WasmTy for Option<Func> {\n         }\n     }\n \n+    #[inline]\n+    fn is_externref(&self) -> bool {\n+        false\n+    }\n+\n     #[inline]\n     fn into_abi(self, store: &mut StoreOpaque) -> Self::Abi {\n         if let Some(f) = self {\n@@ -299,10 +362,16 @@ unsafe impl WasmTy for Option<Func> {\n pub unsafe trait WasmParams: Send {\n     #[doc(hidden)]\n     type Abi: Copy;\n+\n     #[doc(hidden)]\n     fn typecheck(params: impl ExactSizeIterator<Item = crate::ValType>) -> Result<()>;\n+\n+    #[doc(hidden)]\n+    fn externrefs_count(&self) -> usize;\n+\n     #[doc(hidden)]\n     fn into_abi(self, store: &mut StoreOpaque) -> Option<Self::Abi>;\n+\n     #[doc(hidden)]\n     unsafe fn invoke<R: WasmResults>(\n         func: *const VMFunctionBody,\n@@ -323,10 +392,17 @@ where\n     fn typecheck(params: impl ExactSizeIterator<Item = crate::ValType>) -> Result<()> {\n         <(T,) as WasmParams>::typecheck(params)\n     }\n+\n+    #[inline]\n+    fn externrefs_count(&self) -> usize {\n+        T::is_externref(self) as usize\n+    }\n+\n     #[inline]\n     fn into_abi(self, store: &mut StoreOpaque) -> Option<Self::Abi> {\n         <(T,) as WasmParams>::into_abi((self,), store)\n     }\n+\n     unsafe fn invoke<R: WasmResults>(\n         func: *const VMFunctionBody,\n         vmctx1: *mut VMContext,\n@@ -365,6 +441,15 @@ macro_rules! impl_wasm_params {\n                 }\n             }\n \n+            #[inline]\n+            fn externrefs_count(&self) -> usize {\n+                let ($(ref $t,)*) = self;\n+                0 $(\n+                    + $t.is_externref() as usize\n+                )*\n+            }\n+\n+\n             #[inline]\n             fn into_abi(self, _store: &mut StoreOpaque) -> Option<Self::Abi> {\n                 let ($($t,)*) = self;"
        },
        {
          "filename": "crates/wasmtime/src/store.rs",
          "status": "modified",
          "additions": 63,
          "deletions": 3,
          "patch": "@@ -290,6 +290,67 @@ unsafe impl Send for AsyncState {}\n #[cfg(feature = \"async\")]\n unsafe impl Sync for AsyncState {}\n \n+/// An RAII type to automatically mark a region of code as unsafe for GC.\n+pub(crate) struct AutoAssertNoGc<T>\n+where\n+    T: std::ops::DerefMut<Target = StoreOpaque>,\n+{\n+    #[cfg(debug_assertions)]\n+    prev_okay: bool,\n+    store: T,\n+}\n+\n+impl<T> AutoAssertNoGc<T>\n+where\n+    T: std::ops::DerefMut<Target = StoreOpaque>,\n+{\n+    pub fn new(mut store: T) -> Self {\n+        #[cfg(debug_assertions)]\n+        {\n+            let prev_okay = store.externref_activations_table.set_gc_okay(false);\n+            return AutoAssertNoGc { store, prev_okay };\n+        }\n+        #[cfg(not(debug_assertions))]\n+        {\n+            return AutoAssertNoGc { store };\n+        }\n+    }\n+}\n+\n+impl<T> std::ops::Deref for AutoAssertNoGc<T>\n+where\n+    T: std::ops::DerefMut<Target = StoreOpaque>,\n+{\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.store\n+    }\n+}\n+\n+impl<T> std::ops::DerefMut for AutoAssertNoGc<T>\n+where\n+    T: std::ops::DerefMut<Target = StoreOpaque>,\n+{\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.store\n+    }\n+}\n+\n+impl<T> Drop for AutoAssertNoGc<T>\n+where\n+    T: std::ops::DerefMut<Target = StoreOpaque>,\n+{\n+    fn drop(&mut self) {\n+        #[cfg(debug_assertions)]\n+        {\n+            self.store\n+                .externref_activations_table\n+                .set_gc_okay(self.prev_okay);\n+        }\n+    }\n+}\n+\n /// Used to associate instances with the store.\n ///\n /// This is needed to track if the instance was allocated explicitly with the on-demand\n@@ -1083,9 +1144,8 @@ impl StoreOpaque {\n         &*self.interrupts as *const VMInterrupts as *mut VMInterrupts\n     }\n \n-    pub unsafe fn insert_vmexternref(&mut self, r: VMExternRef) {\n-        self.externref_activations_table\n-            .insert_with_gc(r, &self.modules)\n+    pub unsafe fn insert_vmexternref_without_gc(&mut self, r: VMExternRef) {\n+        self.externref_activations_table.insert_without_gc(r);\n     }\n \n     #[inline]"
        },
        {
          "filename": "crates/wasmtime/src/types.rs",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -230,21 +230,21 @@ impl FuncType {\n         results: impl IntoIterator<Item = ValType>,\n     ) -> FuncType {\n         FuncType {\n-            sig: WasmFuncType {\n-                params: params.into_iter().map(|t| t.to_wasm_type()).collect(),\n-                returns: results.into_iter().map(|t| t.to_wasm_type()).collect(),\n-            },\n+            sig: WasmFuncType::new(\n+                params.into_iter().map(|t| t.to_wasm_type()).collect(),\n+                results.into_iter().map(|t| t.to_wasm_type()).collect(),\n+            ),\n         }\n     }\n \n     /// Returns the list of parameter types for this function.\n     pub fn params(&self) -> impl ExactSizeIterator<Item = ValType> + '_ {\n-        self.sig.params.iter().map(ValType::from_wasm_type)\n+        self.sig.params().iter().map(ValType::from_wasm_type)\n     }\n \n     /// Returns the list of result types for this function.\n     pub fn results(&self) -> impl ExactSizeIterator<Item = ValType> + '_ {\n-        self.sig.returns.iter().map(ValType::from_wasm_type)\n+        self.sig.returns().iter().map(ValType::from_wasm_type)\n     }\n \n     pub(crate) fn as_wasm_func_type(&self) -> &WasmFuncType {"
        },
        {
          "filename": "crates/wasmtime/src/values.rs",
          "status": "modified",
          "additions": 9,
          "deletions": 9,
          "patch": "@@ -93,17 +93,17 @@ impl Val {\n         }\n     }\n \n-    pub(crate) unsafe fn write_value_to(&self, store: &mut StoreOpaque, p: *mut u128) {\n-        match self {\n-            Val::I32(i) => ptr::write(p as *mut i32, *i),\n-            Val::I64(i) => ptr::write(p as *mut i64, *i),\n-            Val::F32(u) => ptr::write(p as *mut u32, *u),\n-            Val::F64(u) => ptr::write(p as *mut u64, *u),\n-            Val::V128(b) => ptr::write(p as *mut u128, *b),\n+    pub(crate) unsafe fn write_value_without_gc(&self, store: &mut StoreOpaque, p: *mut u128) {\n+        match *self {\n+            Val::I32(i) => ptr::write(p as *mut i32, i),\n+            Val::I64(i) => ptr::write(p as *mut i64, i),\n+            Val::F32(u) => ptr::write(p as *mut u32, u),\n+            Val::F64(u) => ptr::write(p as *mut u64, u),\n+            Val::V128(b) => ptr::write(p as *mut u128, b),\n             Val::ExternRef(None) => ptr::write(p, 0),\n-            Val::ExternRef(Some(x)) => {\n+            Val::ExternRef(Some(ref x)) => {\n                 let externref_ptr = x.inner.as_raw();\n-                store.insert_vmexternref(x.inner.clone());\n+                store.insert_vmexternref_without_gc(x.clone().inner);\n                 ptr::write(p as *mut *mut u8, externref_ptr)\n             }\n             Val::FuncRef(f) => ptr::write("
        },
        {
          "filename": "tests/all/gc.rs",
          "status": "modified",
          "additions": 53,
          "deletions": 0,
          "patch": "@@ -424,3 +424,56 @@ fn global_init_no_leak() -> anyhow::Result<()> {\n \n     Ok(())\n }\n+\n+#[test]\n+fn no_gc_middle_of_args() -> anyhow::Result<()> {\n+    let (mut store, module) = ref_types_module(\n+        r#\"\n+            (module\n+                (import \"\" \"return_some\" (func $return (result externref externref externref)))\n+                (import \"\" \"take_some\" (func $take (param externref externref externref)))\n+                (func (export \"run\")\n+                    (local i32)\n+                    i32.const 1000\n+                    local.set 0\n+                    loop\n+                        call $return\n+                        call $take\n+                        local.get 0\n+                        i32.const -1\n+                        i32.add\n+                        local.tee 0\n+                        br_if 0\n+                    end\n+                )\n+            )\n+        \"#,\n+    )?;\n+\n+    let mut linker = Linker::new(store.engine());\n+    linker.func_wrap(\"\", \"return_some\", || {\n+        (\n+            Some(ExternRef::new(\"a\".to_string())),\n+            Some(ExternRef::new(\"b\".to_string())),\n+            Some(ExternRef::new(\"c\".to_string())),\n+        )\n+    })?;\n+    linker.func_wrap(\n+        \"\",\n+        \"take_some\",\n+        |a: Option<ExternRef>, b: Option<ExternRef>, c: Option<ExternRef>| {\n+            let a = a.unwrap();\n+            let b = b.unwrap();\n+            let c = c.unwrap();\n+            assert_eq!(a.data().downcast_ref::<String>().unwrap(), \"a\");\n+            assert_eq!(b.data().downcast_ref::<String>().unwrap(), \"b\");\n+            assert_eq!(c.data().downcast_ref::<String>().unwrap(), \"c\");\n+        },\n+    )?;\n+\n+    let instance = linker.instantiate(&mut store, &module)?;\n+    let func = instance.get_typed_func::<(), (), _>(&mut store, \"run\")?;\n+    func.call(&mut store, ())?;\n+\n+    Ok(())\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 10,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "75f7b2bed7b2c4360a1a01fdfdb2cfaac9b0b6ae",
            "date": "2025-01-14T15:49:21Z",
            "author_login": "nilsmartel"
          },
          {
            "sha": "e4fd50d1e27f3ba3d4757b85547d55f585d446f9",
            "date": "2025-01-14T01:28:53Z",
            "author_login": "alexcrichton"
          },
          {
            "sha": "8659e11c4ad12512defd6213de0a9d73f8ae6732",
            "date": "2025-01-14T00:47:04Z",
            "author_login": "fitzgen"
          },
          {
            "sha": "84f381fa1bc5c00438108d16fb14657a2c76a182",
            "date": "2025-01-13T22:31:43Z",
            "author_login": "saulecabrera"
          },
          {
            "sha": "a6a08570216d5c42b1c1fc9699fe5b9ae214f27e",
            "date": "2025-01-13T21:05:07Z",
            "author_login": "alexcrichton"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.3,
    "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:H",
    "cwe_id": "CWE-416",
    "description": "Wasmtime is an open source runtime for WebAssembly & WASI. In Wasmtime from version 0.19.0 and before version 0.30.0 there was a use-after-free bug when passing `externref`s from the host to guest Wasm content. To trigger the bug, you have to explicitly pass multiple `externref`s from the host to a Wasm instance at the same time, either by passing multiple `externref`s as arguments from host code to a Wasm function, or returning multiple `externref`s to Wasm from a multi-value return function defined in the host. If you do not have host code that matches one of these shapes, then you are not impacted. If Wasmtime's `VMExternRefActivationsTable` became filled to capacity after passing the first `externref` in, then passing in the second `externref` could trigger a garbage collection. However the first `externref` is not rooted until we pass control to Wasm, and therefore could be reclaimed by the collector if nothing else was holding a reference to it or otherwise keeping it alive. Then, when control was passed to Wasm after the garbage collection, Wasm could use the first `externref`, which at this point has already been freed. We have reason to believe that the effective impact of this bug is relatively small because usage of `externref` is currently quite rare. The bug has been fixed, and users should upgrade to Wasmtime 0.30.0. If you cannot upgrade Wasmtime yet, you can avoid the bug by disabling reference types support in Wasmtime by passing `false` to `wasmtime::Config::wasm_reference_types`.",
    "attack_vector": "LOCAL",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2021-09-17T20:15:07.703",
    "last_modified": "2024-11-21T06:18:55.553",
    "fix_date": "2021-09-17T17:27:29Z"
  },
  "references": [
    {
      "url": "https://crates.io/crates/wasmtime",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/bytecodealliance/wasmtime/commit/101998733b74624cbd348a2366d05760b40181f3",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-v4cp-h94r-m7xf",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WAVBRYDDUIY2ZR3K3FO4BVYJKIMJ5TP7/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/Z2Z33FTXFQ6EOINVEQIP4DFBG53G5XIY/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://crates.io/crates/wasmtime",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/bytecodealliance/wasmtime/commit/101998733b74624cbd348a2366d05760b40181f3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-v4cp-h94r-m7xf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WAVBRYDDUIY2ZR3K3FO4BVYJKIMJ5TP7/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/Z2Z33FTXFQ6EOINVEQIP4DFBG53G5XIY/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:07.765503",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "wasmtime",
    "owner": "bytecodealliance",
    "created_at": "2017-08-29T14:01:55Z",
    "updated_at": "2025-01-14T09:40:55Z",
    "pushed_at": "2025-01-14T01:52:50Z",
    "size": 111616,
    "stars": 15702,
    "forks": 1345,
    "open_issues": 787,
    "watchers": 15702,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-0.32.0",
      "release-0.33.0",
      "release-0.34.0",
      "release-0.35.0",
      "release-0.36.0",
      "release-0.37.0",
      "release-0.38.0",
      "release-0.39.0",
      "release-0.40.0",
      "release-1.0.0",
      "release-2.0.0",
      "release-3.0.0",
      "release-4.0.0",
      "release-5.0.0",
      "release-6.0.0",
      "release-7.0.0",
      "release-8.0.0",
      "release-9.0.0"
    ],
    "languages": {
      "Rust": 19224087,
      "WebAssembly": 6773216,
      "Common Lisp": 1793054,
      "C": 257019,
      "JavaScript": 24116,
      "Shell": 23820,
      "C++": 21050,
      "CMake": 7205,
      "OCaml": 6903,
      "Assembly": 4165,
      "Dockerfile": 2564,
      "Makefile": 1432,
      "CSS": 303
    },
    "commit_activity": {
      "total_commits_last_year": 1586,
      "avg_commits_per_week": 30.5,
      "days_active_last_year": 278
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:32:42.127815"
  }
}