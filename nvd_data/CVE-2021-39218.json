{
  "cve_id": "CVE-2021-39218",
  "github_data": {
    "repository": "bytecodealliance/wasmtime",
    "fix_commit": "398a73f0dd862dbe703212ebae8e34036a18c11c",
    "related_commits": [
      "398a73f0dd862dbe703212ebae8e34036a18c11c",
      "398a73f0dd862dbe703212ebae8e34036a18c11c"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "398a73f0dd862dbe703212ebae8e34036a18c11c",
      "commit_date": "2021-09-17T17:28:50Z",
      "author": {
        "login": "fitzgen",
        "type": "User",
        "stats": {
          "total_commits": 1000,
          "average_weekly_commits": 2.1691973969631237,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 213
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-4873-36h9-wv49",
        "length": 83,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 100,
        "additions": 52,
        "deletions": 48
      },
      "files": [
        {
          "filename": "crates/wasmtime/src/module/registry.rs",
          "status": "modified",
          "additions": 52,
          "deletions": 48,
          "patch": "@@ -122,61 +122,65 @@ impl ModuleInfo for RegisteredModule {\n         let info = self.module.func_info(index);\n \n         // Do a binary search to find the stack map for the given offset.\n-        //\n-        // Because GC safepoints are technically only associated with a single\n-        // PC, we should ideally only care about `Ok(index)` values returned\n-        // from the binary search. However, safepoints are inserted right before\n-        // calls, and there are two things that can disturb the PC/offset\n-        // associated with the safepoint versus the PC we actually use to query\n-        // for the stack map:\n-        //\n-        // 1. The `backtrace` crate gives us the PC in a frame that will be\n-        //    *returned to*, and where execution will continue from, rather than\n-        //    the PC of the call we are currently at. So we would need to\n-        //    disassemble one instruction backwards to query the actual PC for\n-        //    the stack map.\n-        //\n-        //    TODO: One thing we *could* do to make this a little less error\n-        //    prone, would be to assert/check that the nearest GC safepoint\n-        //    found is within `max_encoded_size(any kind of call instruction)`\n-        //    our queried PC for the target architecture.\n-        //\n-        // 2. Cranelift's stack maps only handle the stack, not\n-        //    registers. However, some references that are arguments to a call\n-        //    may need to be in registers. In these cases, what Cranelift will\n-        //    do is:\n-        //\n-        //      a. spill all the live references,\n-        //      b. insert a GC safepoint for those references,\n-        //      c. reload the references into registers, and finally\n-        //      d. make the call.\n-        //\n-        //    Step (c) adds drift between the GC safepoint and the location of\n-        //    the call, which is where we actually walk the stack frame and\n-        //    collect its live references.\n-        //\n-        //    Luckily, the spill stack slots for the live references are still\n-        //    up to date, so we can still find all the on-stack roots.\n-        //    Furthermore, we do not have a moving GC, so we don't need to worry\n-        //    whether the following code will reuse the references in registers\n-        //    (which would not have been updated to point to the moved objects)\n-        //    or reload from the stack slots (which would have been updated to\n-        //    point to the moved objects).\n-\n         let index = match info\n             .stack_maps\n             .binary_search_by_key(&func_offset, |i| i.code_offset)\n         {\n-            // Exact hit.\n+            // Found it.\n             Ok(i) => i,\n \n-            // `Err(0)` means that the associated stack map would have been the\n-            // first element in the array if this pc had an associated stack\n-            // map, but this pc does not have an associated stack map. This can\n-            // only happen inside a Wasm frame if there are no live refs at this\n-            // pc.\n+            // No stack map associated with this PC.\n+            //\n+            // Because we know we are in Wasm code, and we must be at some kind\n+            // of call/safepoint, then the Cranelift backend must have avoided\n+            // emitting a stack map for this location because no refs were live.\n+            #[cfg(not(feature = \"old-x86-backend\"))]\n+            Err(_) => return None,\n+\n+            // ### Old x86_64 backend specific code.\n+            //\n+            // Because GC safepoints are technically only associated with a\n+            // single PC, we should ideally only care about `Ok(index)` values\n+            // returned from the binary search. However, safepoints are inserted\n+            // right before calls, and there are two things that can disturb the\n+            // PC/offset associated with the safepoint versus the PC we actually\n+            // use to query for the stack map:\n+            //\n+            // 1. The `backtrace` crate gives us the PC in a frame that will be\n+            //    *returned to*, and where execution will continue from, rather than\n+            //    the PC of the call we are currently at. So we would need to\n+            //    disassemble one instruction backwards to query the actual PC for\n+            //    the stack map.\n+            //\n+            //    TODO: One thing we *could* do to make this a little less error\n+            //    prone, would be to assert/check that the nearest GC safepoint\n+            //    found is within `max_encoded_size(any kind of call instruction)`\n+            //    our queried PC for the target architecture.\n+            //\n+            // 2. Cranelift's stack maps only handle the stack, not\n+            //    registers. However, some references that are arguments to a call\n+            //    may need to be in registers. In these cases, what Cranelift will\n+            //    do is:\n+            //\n+            //      a. spill all the live references,\n+            //      b. insert a GC safepoint for those references,\n+            //      c. reload the references into registers, and finally\n+            //      d. make the call.\n+            //\n+            //    Step (c) adds drift between the GC safepoint and the location of\n+            //    the call, which is where we actually walk the stack frame and\n+            //    collect its live references.\n+            //\n+            //    Luckily, the spill stack slots for the live references are still\n+            //    up to date, so we can still find all the on-stack roots.\n+            //    Furthermore, we do not have a moving GC, so we don't need to worry\n+            //    whether the following code will reuse the references in registers\n+            //    (which would not have been updated to point to the moved objects)\n+            //    or reload from the stack slots (which would have been updated to\n+            //    point to the moved objects).\n+            #[cfg(feature = \"old-x86-backend\")]\n             Err(0) => return None,\n-\n+            #[cfg(feature = \"old-x86-backend\")]\n             Err(i) => i - 1,\n         };\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "5dfccc078bb3dcad152d37013dde8067f197e6e7",
            "date": "2025-01-24T23:25:57Z",
            "author_login": "alexcrichton"
          },
          {
            "sha": "4dd7cd6ea25f1c37123f6ffed5f160c799b28d91",
            "date": "2025-01-24T22:47:49Z",
            "author_login": "alexcrichton"
          },
          {
            "sha": "1ad7a4f66c236b9354bfbcbe58762aef81973156",
            "date": "2025-01-24T21:09:37Z",
            "author_login": "jeffcharles"
          },
          {
            "sha": "b131a1a5c341ea1d2ff2d0f74db15fe45ec6435f",
            "date": "2025-01-24T18:55:41Z",
            "author_login": "pchickey"
          },
          {
            "sha": "38a47d20aec6b3eb0de107575a547d053838064b",
            "date": "2025-01-24T18:04:22Z",
            "author_login": "dicej"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.3,
    "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:H",
    "cwe_id": "CWE-125",
    "description": "Wasmtime is an open source runtime for WebAssembly & WASI. In Wasmtime from version 0.26.0 and before version 0.30.0 is affected by a memory unsoundness vulnerability. There was an invalid free and out-of-bounds read and write bug when running Wasm that uses `externref`s in Wasmtime. To trigger this bug, Wasmtime needs to be running Wasm that uses `externref`s, the host creates non-null `externrefs`, Wasmtime performs a garbage collection (GC), and there has to be a Wasm frame on the stack that is at a GC safepoint where there are no live references at this safepoint, and there is a safepoint with live references earlier in this frame's function. Under this scenario, Wasmtime would incorrectly use the GC stack map for the safepoint from earlier in the function instead of the empty safepoint. This would result in Wasmtime treating arbitrary stack slots as `externref`s that needed to be rooted for GC. At the *next* GC, it would be determined that nothing was referencing these bogus `externref`s (because nothing could ever reference them, because they are not really `externref`s) and then Wasmtime would deallocate them and run `<ExternRef as Drop>::drop` on them. This results in a free of memory that is not necessarily on the heap (and shouldn't be freed at this moment even if it was), as well as potential out-of-bounds reads and writes. Even though support for `externref`s (via the reference types proposal) is enabled by default, unless you are creating non-null `externref`s in your host code or explicitly triggering GCs, you cannot be affected by this bug. We have reason to believe that the effective impact of this bug is relatively small because usage of `externref` is currently quite rare. This bug has been patched and users should upgrade to Wasmtime version 0.30.0. If you cannot upgrade Wasmtime at this time, you can avoid this bug by disabling the reference types proposal by passing `false` to `wasmtime::Config::wasm_reference_types`.",
    "attack_vector": "LOCAL",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2021-09-17T21:15:07.417",
    "last_modified": "2024-11-21T06:18:55.883",
    "fix_date": "2021-09-17T17:28:50Z"
  },
  "references": [
    {
      "url": "https://crates.io/crates/wasmtime",
      "source": "security-advisories@github.com",
      "tags": [
        "Product",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/bytecodealliance/wasmtime/commit/398a73f0dd862dbe703212ebae8e34036a18c11c",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-4873-36h9-wv49",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WAVBRYDDUIY2ZR3K3FO4BVYJKIMJ5TP7/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/Z2Z33FTXFQ6EOINVEQIP4DFBG53G5XIY/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://crates.io/crates/wasmtime",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/bytecodealliance/wasmtime/commit/398a73f0dd862dbe703212ebae8e34036a18c11c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-4873-36h9-wv49",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WAVBRYDDUIY2ZR3K3FO4BVYJKIMJ5TP7/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/Z2Z33FTXFQ6EOINVEQIP4DFBG53G5XIY/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:07.766229",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "wasmtime",
    "owner": "bytecodealliance",
    "created_at": "2017-08-29T14:01:55Z",
    "updated_at": "2025-01-26T07:38:59Z",
    "pushed_at": "2025-01-25T23:17:45Z",
    "size": 113099,
    "stars": 15742,
    "forks": 1350,
    "open_issues": 788,
    "watchers": 15742,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-0.32.0",
      "release-0.33.0",
      "release-0.34.0",
      "release-0.35.0",
      "release-0.36.0",
      "release-0.37.0",
      "release-0.38.0",
      "release-0.39.0",
      "release-0.40.0",
      "release-1.0.0",
      "release-2.0.0",
      "release-3.0.0",
      "release-4.0.0",
      "release-5.0.0",
      "release-6.0.0",
      "release-7.0.0"
    ],
    "languages": {
      "Rust": 20734012,
      "WebAssembly": 6982626,
      "Common Lisp": 1798160,
      "C": 257032,
      "Shell": 24641,
      "JavaScript": 23214,
      "C++": 21050,
      "CMake": 7205,
      "OCaml": 6903,
      "Assembly": 4165,
      "Dockerfile": 3431,
      "Makefile": 1432,
      "CSS": 303
    },
    "commit_activity": {
      "total_commits_last_year": 1619,
      "avg_commits_per_week": 31.134615384615383,
      "days_active_last_year": 276
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T08:22:23.254347"
  }
}