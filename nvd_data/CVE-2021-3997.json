{
  "cve_id": "CVE-2021-3997",
  "github_data": {
    "repository": "systemd/systemd",
    "fix_commit": "5b1cf7a9be37e20133c0208005274ce4a5b5c6a1",
    "related_commits": [
      "5b1cf7a9be37e20133c0208005274ce4a5b5c6a1",
      "5b1cf7a9be37e20133c0208005274ce4a5b5c6a1"
    ],
    "patch_url": "https://github.com/systemd/systemd/commit/5b1cf7a9be37e20133c0208005274ce4a5b5c6a1.patch",
    "fix_commit_details": {
      "sha": "5b1cf7a9be37e20133c0208005274ce4a5b5c6a1",
      "commit_date": "2021-11-30T21:29:05Z",
      "author": {
        "login": "keszybz",
        "type": "User",
        "stats": {
          "total_commits": 10662,
          "average_weekly_commits": 9.37730870712401,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 600
        }
      },
      "commit_message": {
        "title": "shared/rm-rf: loop over nested directories instead of instead of recursing",
        "length": 1072,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 159,
        "additions": 112,
        "deletions": 47
      },
      "files": [
        {
          "filename": "src/shared/rm-rf.c",
          "status": "modified",
          "additions": 112,
          "deletions": 47,
          "patch": "@@ -52,7 +52,6 @@ static int patch_dirfd_mode(\n }\n \n int unlinkat_harder(int dfd, const char *filename, int unlink_flags, RemoveFlags remove_flags) {\n-\n         mode_t old_mode;\n         int r;\n \n@@ -116,12 +115,13 @@ int fstatat_harder(int dfd,\n         return 0;\n }\n \n-static int rm_rf_children_inner(\n+static int rm_rf_inner_child(\n                 int fd,\n                 const char *fname,\n                 int is_dir,\n                 RemoveFlags flags,\n-                const struct stat *root_dev) {\n+                const struct stat *root_dev,\n+                bool allow_recursion) {\n \n         struct stat st;\n         int r, q = 0;\n@@ -141,9 +141,7 @@ static int rm_rf_children_inner(\n         }\n \n         if (is_dir) {\n-                _cleanup_close_ int subdir_fd = -1;\n-\n-                /* if root_dev is set, remove subdirectories only if device is same */\n+                /* If root_dev is set, remove subdirectories only if device is same */\n                 if (root_dev && st.st_dev != root_dev->st_dev)\n                         return 0;\n \n@@ -155,7 +153,6 @@ static int rm_rf_children_inner(\n                         return 0;\n \n                 if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n-\n                         /* This could be a subvolume, try to remove it */\n \n                         r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n@@ -169,13 +166,16 @@ static int rm_rf_children_inner(\n                                 return 1;\n                 }\n \n-                subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n+                if (!allow_recursion)\n+                        return -EISDIR;\n+\n+                int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                 if (subdir_fd < 0)\n                         return -errno;\n \n                 /* We pass REMOVE_PHYSICAL here, to avoid doing the fstatfs() to check the file system type\n                  * again for each directory */\n-                q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);\n+                q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);\n \n         } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                 return 0;\n@@ -188,62 +188,127 @@ static int rm_rf_children_inner(\n         return 1;\n }\n \n+typedef struct TodoEntry {\n+        DIR *dir;         /* A directory that we were operating on. */\n+        char *dirname;    /* The filename of that directory itself. */\n+} TodoEntry;\n+\n+static void free_todo_entries(TodoEntry **todos) {\n+        for (TodoEntry *x = *todos; x && x->dir; x++) {\n+                closedir(x->dir);\n+                free(x->dirname);\n+        }\n+\n+        freep(todos);\n+}\n+\n int rm_rf_children(\n                 int fd,\n                 RemoveFlags flags,\n                 const struct stat *root_dev) {\n \n-        _cleanup_closedir_ DIR *d = NULL;\n+        _cleanup_(free_todo_entries) TodoEntry *todos = NULL;\n+        size_t n_todo = 0;\n+        _cleanup_free_ char *dirname = NULL; /* Set when we are recursing and want to delete ourselves */\n         int ret = 0, r;\n \n-        assert(fd >= 0);\n+        /* Return the first error we run into, but nevertheless try to go on.\n+         * The passed fd is closed in all cases, including on failure. */\n+\n+        for (;;) {  /* This loop corresponds to the directory nesting level. */\n+                _cleanup_closedir_ DIR *d = NULL;\n+\n+                if (n_todo > 0) {\n+                        /* We know that we are in recursion here, because n_todo is set.\n+                         * We need to remove the inner directory we were operating on. */\n+                        assert(dirname);\n+                        r = unlinkat_harder(dirfd(todos[n_todo-1].dir), dirname, AT_REMOVEDIR, flags);\n+                        if (r < 0 && r != -ENOENT && ret == 0)\n+                                ret = r;\n+                        dirname = mfree(dirname);\n+\n+                        /* And now let's back out one level up */\n+                        n_todo --;\n+                        d = TAKE_PTR(todos[n_todo].dir);\n+                        dirname = TAKE_PTR(todos[n_todo].dirname);\n+\n+                        assert(d);\n+                        fd = dirfd(d); /* Retrieve the file descriptor from the DIR object */\n+                        assert(fd >= 0);\n+                } else {\n+        next_fd:\n+                        assert(fd >= 0);\n+                        d = fdopendir(fd);\n+                        if (!d) {\n+                                safe_close(fd);\n+                                return -errno;\n+                        }\n+                        fd = dirfd(d); /* We donated the fd to fdopendir(). Let's make sure we sure we have\n+                                        * the right descriptor even if it were to internally invalidate the\n+                                        * one we passed. */\n+\n+                        if (!(flags & REMOVE_PHYSICAL)) {\n+                                struct statfs sfs;\n+\n+                                if (fstatfs(fd, &sfs) < 0)\n+                                        return -errno;\n+\n+                                if (is_physical_fs(&sfs)) {\n+                                        /* We refuse to clean physical file systems with this call, unless\n+                                         * explicitly requested. This is extra paranoia just to be sure we\n+                                         * never ever remove non-state data. */\n+\n+                                        _cleanup_free_ char *path = NULL;\n+\n+                                        (void) fd_get_path(fd, &path);\n+                                        return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n+                                                               \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",\n+                                                               strna(path));\n+                                }\n+                        }\n+                }\n \n-        /* This returns the first error we run into, but nevertheless tries to go on. This closes the passed\n-         * fd, in all cases, including on failure. */\n+                FOREACH_DIRENT_ALL(de, d, return -errno) {\n+                        int is_dir;\n \n-        d = fdopendir(fd);\n-        if (!d) {\n-                safe_close(fd);\n-                return -errno;\n-        }\n+                        if (dot_or_dot_dot(de->d_name))\n+                                continue;\n \n-        if (!(flags & REMOVE_PHYSICAL)) {\n-                struct statfs sfs;\n+                        is_dir = de->d_type == DT_UNKNOWN ? -1 : de->d_type == DT_DIR;\n \n-                if (fstatfs(dirfd(d), &sfs) < 0)\n-                        return -errno;\n+                        r = rm_rf_inner_child(fd, de->d_name, is_dir, flags, root_dev, false);\n+                        if (r == -EISDIR) {\n+                                /* Push the current working state onto the todo list */\n \n-                if (is_physical_fs(&sfs)) {\n-                        /* We refuse to clean physical file systems with this call, unless explicitly\n-                         * requested. This is extra paranoia just to be sure we never ever remove non-state\n-                         * data. */\n+                                 if (!GREEDY_REALLOC0(todos, n_todo + 2))\n+                                         return log_oom();\n \n-                        _cleanup_free_ char *path = NULL;\n+                                 _cleanup_free_ char *newdirname = strdup(de->d_name);\n+                                 if (!newdirname)\n+                                         return log_oom();\n \n-                        (void) fd_get_path(fd, &path);\n-                        return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n-                                               \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",\n-                                               strna(path));\n-                }\n-        }\n+                                 int newfd = openat(fd, de->d_name,\n+                                                    O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n+                                 if (newfd >= 0) {\n+                                         todos[n_todo++] = (TodoEntry) { TAKE_PTR(d), TAKE_PTR(dirname) };\n+                                         fd = newfd;\n+                                         dirname = TAKE_PTR(newdirname);\n \n-        FOREACH_DIRENT_ALL(de, d, return -errno) {\n-                int is_dir;\n+                                         goto next_fd;\n \n-                if (dot_or_dot_dot(de->d_name))\n-                        continue;\n+                                 } else if (errno != -ENOENT && ret == 0)\n+                                         ret = -errno;\n \n-                is_dir =\n-                        de->d_type == DT_UNKNOWN ? -1 :\n-                        de->d_type == DT_DIR;\n+                        } else if (r < 0 && r != -ENOENT && ret == 0)\n+                                ret = r;\n+                }\n \n-                r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);\n-                if (r < 0 && r != -ENOENT && ret == 0)\n-                        ret = r;\n-        }\n+                if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(fd) < 0 && ret >= 0)\n+                        ret = -errno;\n \n-        if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)\n-                ret = -errno;\n+                if (n_todo == 0)\n+                        break;\n+        }\n \n         return ret;\n }\n@@ -335,5 +400,5 @@ int rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n         if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                 return -EINVAL;\n \n-        return rm_rf_children_inner(fd, name, -1, flags, NULL);\n+        return rm_rf_inner_child(fd, name, -1, flags, NULL, true);\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "05932f4768bc329f933774eef9a2286f706d3673",
            "date": "2025-01-14T12:53:26Z",
            "author_login": "DaanDeMeyer"
          },
          {
            "sha": "f54390de87919e70419618e3cd0b555c2f938808",
            "date": "2025-01-14T09:03:24Z",
            "author_login": "poettering"
          },
          {
            "sha": "67317693203595ef1ba1d69fc538545c56cba645",
            "date": "2025-01-14T14:19:56Z",
            "author_login": "killermoehre"
          },
          {
            "sha": "015a3b8cb1d40d420eaa961e27cdee463f57f8a0",
            "date": "2024-11-18T19:13:40Z",
            "author_login": "seaeunlee"
          },
          {
            "sha": "857ddc2e55302de0fa187b33f0e9468917903912",
            "date": "2025-01-14T13:39:58Z",
            "author_login": "poettering"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-674",
    "description": "A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-08-23T20:15:08.670",
    "last_modified": "2024-11-21T06:23:20.623",
    "fix_date": "2021-11-30T21:29:05Z"
  },
  "references": [
    {
      "url": "https://access.redhat.com/security/cve/CVE-2021-3997",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2024639",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/systemd/systemd/commit/5b1cf7a9be37e20133c0208005274ce4a5b5c6a1",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202305-15",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://www.openwall.com/lists/oss-security/2022/01/10/2",
      "source": "secalert@redhat.com",
      "tags": [
        "Exploit",
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/security/cve/CVE-2021-3997",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2024639",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/systemd/systemd/commit/5b1cf7a9be37e20133c0208005274ce4a5b5c6a1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202305-15",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://www.openwall.com/lists/oss-security/2022/01/10/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Mailing List",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:14.288603",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "systemd",
    "owner": "systemd",
    "created_at": "2015-03-25T15:27:27Z",
    "updated_at": "2025-01-14T13:00:10Z",
    "pushed_at": "2025-01-14T13:16:44Z",
    "size": 450244,
    "stars": 13580,
    "forks": 3864,
    "open_issues": 2657,
    "watchers": 13580,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "v256-stable",
      "v257-stable"
    ],
    "languages": {
      "C": 34823898,
      "Python": 2089949,
      "Shell": 1595116,
      "Meson": 462137,
      "SmPL": 32042,
      "HTML": 23536,
      "C++": 10998,
      "Awk": 2537,
      "Emacs Lisp": 1187,
      "Vim Script": 825,
      "Dockerfile": 156,
      "GDB": 92,
      "sed": 72
    },
    "commit_activity": {
      "total_commits_last_year": 7985,
      "avg_commits_per_week": 153.55769230769232,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T13:21:47.408729"
  }
}