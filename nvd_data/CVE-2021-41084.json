{
  "cve_id": "CVE-2021-41084",
  "github_data": {
    "repository": "http4s/http4s",
    "fix_commit": "d02007db1da4f8f3df2dbf11f1db9ac7afc3f9d8",
    "related_commits": [
      "d02007db1da4f8f3df2dbf11f1db9ac7afc3f9d8",
      "d02007db1da4f8f3df2dbf11f1db9ac7afc3f9d8"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "d02007db1da4f8f3df2dbf11f1db9ac7afc3f9d8",
      "commit_date": "2021-09-21T13:03:00Z",
      "author": {
        "login": "rossabaker",
        "type": "User",
        "stats": {
          "total_commits": 7501,
          "average_weekly_commits": 11.944267515923567,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 451
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-5vcm-3xc3-w7x3",
        "length": 79,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 848,
        "additions": 656,
        "deletions": 192
      },
      "files": [
        {
          "filename": "blaze-client/src/main/scala/org/http4s/blaze/client/Http1Connection.scala",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -33,6 +33,7 @@ import org.http4s.blazecore.{Http1Stage, IdleTimeoutStage}\n import org.http4s.blazecore.util.Http1Writer\n import org.http4s.client.RequestKey\n import org.http4s.headers.{Connection, Host, `Content-Length`, `User-Agent`}\n+import org.http4s.internal.CharPredicate\n import org.http4s.util.{StringWriter, Writer}\n import org.typelevel.vault._\n import scala.annotation.tailrec\n@@ -432,6 +433,8 @@ private final class Http1Connection[F[_]](\n       else\n         Left(new IllegalArgumentException(\"Host header required for HTTP/1.1 request\"))\n     else if (req.uri.path == Uri.Path.empty) Right(req.withUri(req.uri.copy(path = Uri.Path.Root)))\n+    else if (req.uri.path.renderString.exists(ForbiddenUriCharacters))\n+      Left(new IllegalArgumentException(s\"Invalid URI path: ${req.uri.path}\"))\n     else Right(req) // All appears to be well\n   }\n \n@@ -473,4 +476,6 @@ private object Http1Connection {\n       writer\n     } else writer\n   }\n+\n+  private val ForbiddenUriCharacters = CharPredicate(0x0.toChar, ' ', '\\r', '\\n')\n }"
        },
        {
          "filename": "blaze-core/src/main/scala/org/http4s/blazecore/Http1Stage.scala",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -293,17 +293,19 @@ object Http1Stage {\n       Future.successful(buffer)\n     } else CachedEmptyBufferThunk\n \n-  /** Encodes the headers into the Writer. Does not encode `Transfer-Encoding` or\n-    * `Content-Length` headers, which are left for the body encoder. Adds\n-    * `Date` header if one is missing and this is a server response.\n+  /** Encodes the headers into the Writer. Does not encode\n+    * `Transfer-Encoding` or `Content-Length` headers, which are left\n+    * for the body encoder. Does not encode headers with invalid\n+    * names. Adds `Date` header if one is missing and this is a server\n+    * response.\n     *\n     * Note: this method is very niche but useful for both server and client.\n     */\n   def encodeHeaders(headers: Iterable[Header.Raw], rr: Writer, isServer: Boolean): Unit = {\n     var dateEncoded = false\n     val dateName = Header[Date].name\n     headers.foreach { h =>\n-      if (h.name != `Transfer-Encoding`.name && h.name != `Content-Length`.name) {\n+      if (h.name != `Transfer-Encoding`.name && h.name != `Content-Length`.name && h.isNameValid) {\n         if (isServer && h.name == dateName) dateEncoded = true\n         rr << h << \"\\r\\n\"\n       }"
        },
        {
          "filename": "blaze-server/src/main/scala/org/http4s/blaze/server/Http1ServerStage.scala",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -222,7 +222,7 @@ private[blaze] class Http1ServerStage[F[_]](\n       resp: Response[F],\n       bodyCleanup: () => Future[ByteBuffer]): Unit = {\n     val rr = new StringWriter(512)\n-    rr << req.httpVersion << ' ' << resp.status.code << ' ' << resp.status.reason << \"\\r\\n\"\n+    rr << req.httpVersion << ' ' << resp.status << \"\\r\\n\"\n \n     Http1Stage.encodeHeaders(resp.headers.headers, rr, isServer = true)\n "
        },
        {
          "filename": "blaze-server/src/test/scala/org/http4s/blaze/server/Http1ServerStageSpec.scala",
          "status": "modified",
          "additions": 75,
          "deletions": 31,
          "patch": "@@ -19,7 +19,7 @@ package blaze\n package server\n \n import cats.data.Kleisli\n-import cats.syntax.eq._\n+import cats.syntax.all._\n import cats.effect._\n import cats.effect.kernel.Deferred\n import cats.effect.std.Dispatcher\n@@ -535,35 +535,79 @@ class Http1ServerStageSpec extends Http4sSuite {\n     }\n   }\n \n-  fixture.test(\"Http1ServerStage: don't deadlock TickWheelExecutor with uncancelable request\") {\n-    tw =>\n-      val reqUncancelable = List(\"GET /uncancelable HTTP/1.0\\r\\n\\r\\n\")\n-      val reqCancelable = List(\"GET /cancelable HTTP/1.0\\r\\n\\r\\n\")\n-\n-      (for {\n-        uncancelableStarted <- Deferred[IO, Unit]\n-        uncancelableCanceled <- Deferred[IO, Unit]\n-        cancelableStarted <- Deferred[IO, Unit]\n-        cancelableCanceled <- Deferred[IO, Unit]\n-        app = HttpApp[IO] {\n-          case req if req.pathInfo === path\"/uncancelable\" =>\n-            uncancelableStarted.complete(()) *>\n-              IO.uncancelable { poll =>\n-                poll(uncancelableCanceled.complete(())) *>\n-                  cancelableCanceled.get\n-              }.as(Response[IO]())\n-          case _ =>\n-            cancelableStarted.complete(()) *> IO.never.guarantee(\n-              cancelableCanceled.complete(()).void)\n-        }\n-        head <- IO(runRequest(tw, reqUncancelable, app))\n-        _ <- uncancelableStarted.get\n-        _ <- uncancelableCanceled.get\n-        _ <- IO(head.sendInboundCommand(Disconnected))\n-        head2 <- IO(runRequest(tw, reqCancelable, app))\n-        _ <- cancelableStarted.get\n-        _ <- IO(head2.sendInboundCommand(Disconnected))\n-        _ <- cancelableCanceled.get\n-      } yield ()).assert\n+  fixture.test(\"Prevent response splitting attacks on status reason phrase\") { tw =>\n+    val rawReq = \"GET /?reason=%0D%0AEvil:true%0D%0A HTTP/1.0\\r\\n\\r\\n\"\n+    val head = runRequest(\n+      tw,\n+      List(rawReq),\n+      HttpApp { req =>\n+        Response[IO](Status.NoContent.withReason(req.params(\"reason\"))).pure[IO]\n+      })\n+    head.result.map { buff =>\n+      val (_, headers, _) = ResponseParser.parseBuffer(buff)\n+      assertEquals(headers.find(_.name === ci\"Evil\"), None)\n+    }\n+  }\n+\n+  fixture.test(\"Prevent response splitting attacks on field name\") { tw =>\n+    val rawReq = \"GET /?fieldName=Fine:%0D%0AEvil:true%0D%0A HTTP/1.0\\r\\n\\r\\n\"\n+    val head = runRequest(\n+      tw,\n+      List(rawReq),\n+      HttpApp { req =>\n+        Response[IO](Status.NoContent).putHeaders(req.params(\"fieldName\") -> \"oops\").pure[IO]\n+      })\n+    head.result.map { buff =>\n+      val (_, headers, _) = ResponseParser.parseBuffer(buff)\n+      assertEquals(headers.find(_.name === ci\"Evil\"), None)\n+    }\n+  }\n+\n+  fixture.test(\"Prevent response splitting attacks on field value\") { tw =>\n+    val rawReq = \"GET /?fieldValue=%0D%0AEvil:true%0D%0A HTTP/1.0\\r\\n\\r\\n\"\n+    val head = runRequest(\n+      tw,\n+      List(rawReq),\n+      HttpApp { req =>\n+        Response[IO](Status.NoContent)\n+          .putHeaders(\"X-Oops\" -> req.params(\"fieldValue\"))\n+          .pure[IO]\n+      })\n+    head.result.map { buff =>\n+      val (_, headers, _) = ResponseParser.parseBuffer(buff)\n+      assertEquals(headers.find(_.name === ci\"Evil\"), None)\n+    }\n+\n+    fixture.test(\"Http1ServerStage: don't deadlock TickWheelExecutor with uncancelable request\") {\n+      tw =>\n+        val reqUncancelable = List(\"GET /uncancelable HTTP/1.0\\r\\n\\r\\n\")\n+        val reqCancelable = List(\"GET /cancelable HTTP/1.0\\r\\n\\r\\n\")\n+\n+        (for {\n+          uncancelableStarted <- Deferred[IO, Unit]\n+          uncancelableCanceled <- Deferred[IO, Unit]\n+          cancelableStarted <- Deferred[IO, Unit]\n+          cancelableCanceled <- Deferred[IO, Unit]\n+          app = HttpApp[IO] {\n+            case req if req.pathInfo === path\"/uncancelable\" =>\n+              uncancelableStarted.complete(()) *>\n+                IO.uncancelable { poll =>\n+                  poll(uncancelableCanceled.complete(())) *>\n+                    cancelableCanceled.get\n+                }.as(Response[IO]())\n+            case _ =>\n+              cancelableStarted.complete(()) *> IO.never.guarantee(\n+                cancelableCanceled.complete(()).void)\n+          }\n+          head <- IO(runRequest(tw, reqUncancelable, app))\n+          _ <- uncancelableStarted.get\n+          _ <- uncancelableCanceled.get\n+          _ <- IO(head.sendInboundCommand(Disconnected))\n+          head2 <- IO(runRequest(tw, reqCancelable, app))\n+          _ <- cancelableStarted.get\n+          _ <- IO(head2.sendInboundCommand(Disconnected))\n+          _ <- cancelableCanceled.get\n+        } yield ()).assert\n+    }\n   }\n }"
        },
        {
          "filename": "build.sbt",
          "status": "modified",
          "additions": 0,
          "deletions": 10,
          "patch": "@@ -448,12 +448,6 @@ lazy val emberServer = libraryProject(\"ember-server\", CrossType.Full, List(JVMPl\n       log4catsSlf4j.value,\n       javaWebSocket % Test\n     ),\n-    mimaBinaryIssueFilters ++= Seq(\n-      ProblemFilters.exclude[DirectMissingMethodProblem](\"org.http4s.ember.server.EmberServerBuilder#Defaults.maxConcurrency\"),\n-      ProblemFilters.exclude[DirectMissingMethodProblem](\"org.http4s.ember.server.internal.ServerHelpers.isKeepAlive\"),\n-      ProblemFilters.exclude[DirectMissingMethodProblem](\"org.http4s.ember.server.EmberServerBuilder#Defaults.maxConcurrency\"),\n-      ProblemFilters.exclude[IncompatibleMethTypeProblem](\"org.http4s.ember.server.internal.ServerHelpers.runApp\")\n-    ),\n     Test / parallelExecution := false\n   )\n   .jsSettings(\n@@ -475,9 +469,6 @@ lazy val emberClient = libraryProject(\"ember-client\", CrossType.Full, List(JVMPl\n     description := \"ember implementation for http4s clients\",\n     startYear := Some(2019),\n     libraryDependencies += keypool.value,\n-    mimaBinaryIssueFilters := Seq(\n-      ProblemFilters.exclude[DirectMissingMethodProblem](\"org.http4s.ember.client.EmberClientBuilder.this\")\n-    )\n   )\n   .jvmSettings(libraryDependencies += log4catsSlf4j.value)\n   .jsSettings(\n@@ -508,7 +499,6 @@ lazy val blazeClient = libraryProject(\"blaze-client\")\n   .settings(\n     description := \"blaze implementation for http4s clients\",\n     startYear := Some(2014),\n-    mimaBinaryIssueFilters ++= Seq()\n   )\n   .dependsOn(blazeCore % \"compile;test->test\", client % \"compile;test->test\")\n "
        },
        {
          "filename": "client/shared/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala",
          "status": "modified",
          "additions": 53,
          "deletions": 2,
          "patch": "@@ -19,15 +19,16 @@ package client\n \n import cats.effect._\n import cats.syntax.all._\n-import com.comcast.ip4s.Host\n-import com.comcast.ip4s.SocketAddress\n+import com.comcast.ip4s.{Host, SocketAddress}\n import fs2._\n import org.http4s.client.dsl.Http4sClientDsl\n import org.http4s.client.testroutes.GetRoutes\n import org.http4s.dsl.io._\n+import org.http4s.implicits._\n import org.http4s.multipart.Multipart\n import org.http4s.multipart.Part\n import org.http4s.server.Server\n+import org.typelevel.ci._\n \n import java.util.Arrays\n import java.util.Locale\n@@ -117,6 +118,56 @@ abstract class ClientRouteTestBattery(name: String) extends Http4sSuite with Htt\n     }\n   }\n \n+  test(\"Mitigates request splitting attack in URI path\") {\n+    for {\n+      uri <- url(\"/\").map(\n+        _.withPath(Uri.Path(Vector(Uri.Path.Segment.encoded(\n+          \"request-splitting HTTP/1.0\\r\\nEvil:true\\r\\nHide-Protocol-Version:\")))))\n+      req = Request[IO](uri = uri)\n+      c <- client()\n+      status <- c.status(req).handleError(_ => Status.Ok)\n+    } yield assertEquals(status, Status.Ok)\n+  }\n+\n+  test(\"Mitigates request splitting attack in URI RegName\") {\n+    for {\n+      srv <- server()\n+      address = srv.address\n+      hostname = address.host.toString\n+      port = address.port.value\n+      req = Request[IO](\n+        uri = Uri(\n+          authority = Uri\n+            .Authority(None, Uri.RegName(s\"${hostname}\\r\\nEvil:true\\r\\n\"), port = port.some)\n+            .some,\n+          path = path\"/request-splitting\"))\n+      c <- client()\n+      status <- c.status(req).handleError(_ => Status.Ok)\n+    } yield assertEquals(status, Status.Ok)\n+  }\n+\n+  test(\"Mitigates request splitting attack in field name\") {\n+\n+    for {\n+      srv <- server()\n+      uri <- url(\"/request-splitting\")\n+      req = Request[IO](uri = uri)\n+        .putHeaders(Header.Raw(ci\"Fine:\\r\\nEvil:true\\r\\n\", \"oops\"))\n+      c <- client()\n+      status <- c.status(req).handleError(_ => Status.Ok)\n+    } yield assertEquals(status, Status.Ok)\n+  }\n+\n+  test(\"Mitigates request splitting attack in field value\") {\n+    for {\n+      uri <- url(\"/request-splitting\")\n+      req = Request[IO](uri = uri)\n+        .putHeaders(Header.Raw(ci\"X-Carrier\", \"\\r\\nEvil:true\\r\\n\"))\n+      c <- client()\n+      status <- c.status(req).handleError(_ => Status.Ok)\n+    } yield assertEquals(status, Status.Ok)\n+  }\n+\n   private def checkResponse(rec: Response[IO], expected: Response[IO]): IO[Boolean] = {\n     // This isn't a generically safe normalization for all header, but\n     // it's close enough for our purposes"
        },
        {
          "filename": "core/shared/src/main/scala/org/http4s/Header.scala",
          "status": "modified",
          "additions": 20,
          "deletions": 3,
          "patch": "@@ -20,7 +20,8 @@ import cats.{Foldable, Hash, Order, Semigroup, Show}\n import cats.data.NonEmptyList\n import cats.syntax.all._\n import org.typelevel.ci.CIString\n-import org.http4s.util.{Renderer, Writer}\n+import org.http4s.internal.CharPredicate\n+import org.http4s.util.{Renderer, StringWriter, Writer}\n import cats.data.Ior\n \n /** Typeclass representing an HTTP header, which all the http4s\n@@ -49,6 +50,17 @@ trait Header[A, T <: Header.Type] {\n object Header {\n   final case class Raw(val name: CIString, val value: String) {\n     override def toString: String = s\"${name}: ${value}\"\n+\n+    /** True if [[name]] is a valid field-name per RFC7230.  Where it\n+      * is not, the header may be dropped by the backend.\n+      */\n+    def isNameValid: Boolean =\n+      name.toString.nonEmpty && name.toString.forall(FieldNamePredicate)\n+\n+    def sanitizedValue: String = {\n+      val w = new StringWriter\n+      w.sanitize(_ << value).result\n+    }\n   }\n \n   object Raw {\n@@ -66,8 +78,10 @@ object Header {\n           case c => c\n         }\n \n-      def render(writer: Writer, h: Raw): writer.type =\n-        writer << h.name << ':' << ' ' << h.value\n+      def render(writer: Writer, h: Raw): writer.type = {\n+        writer << h.name << ':' << ' '\n+        writer.sanitize(_ << h.value)\n+      }\n     }\n   }\n \n@@ -235,4 +249,7 @@ object Header {\n           }\n       }\n   }\n+\n+  private val FieldNamePredicate =\n+    CharPredicate(\"!#$%&'*+-.^_`|~`\") ++ CharPredicate.AlphaNum\n }"
        },
        {
          "filename": "core/shared/src/main/scala/org/http4s/Status.scala",
          "status": "modified",
          "additions": 91,
          "deletions": 69,
          "patch": "@@ -18,6 +18,7 @@ package org.http4s\n \n import cats.{Order, Show}\n import org.http4s.Status.ResponseClass\n+import org.http4s.internal.CharPredicate\n import org.http4s.util.Renderable\n \n /** Representation of the HTTP response code and reason\n@@ -48,7 +49,13 @@ sealed abstract case class Status private (code: Int)(\n \n   def withReason(reason: String): Status = Status(code, reason, isEntityAllowed)\n \n-  override def render(writer: org.http4s.util.Writer): writer.type = writer << code << ' ' << reason\n+  /** A sanitized [[reason]] phrase. Blank if reason is invalid per\n+    * RFC7230, otherwise equivalent to reason.\n+    */\n+  def sanitizedReason: String = \"\"\n+\n+  override def render(writer: org.http4s.util.Writer): writer.type =\n+    writer << code << ' ' << sanitizedReason\n \n   /** Helpers for for matching against a [[Response]] */\n   def unapply[F[_]](msg: Response[F]): Option[Response[F]] =\n@@ -58,8 +65,23 @@ sealed abstract case class Status private (code: Int)(\n object Status {\n   import Registry._\n \n+  private val ReasonPhrasePredicate =\n+    CharPredicate(\"\\t \") ++ CharPredicate(0x21.toChar to 0x7e.toChar) ++ CharPredicate(\n+      0x80.toChar to Char.MaxValue)\n+\n   def apply(code: Int, reason: String = \"\", isEntityAllowed: Boolean = true): Status =\n-    new Status(code)(reason, isEntityAllowed) {}\n+    new Status(code)(reason, isEntityAllowed) {\n+      override lazy val sanitizedReason =\n+        if (reason.forall(ReasonPhrasePredicate))\n+          reason\n+        else\n+          \"\"\n+    }\n+\n+  private def trust(code: Int, reason: String, isEntityAllowed: Boolean = true): Status =\n+    new Status(code)(reason, isEntityAllowed) {\n+      override val sanitizedReason = reason\n+    }\n \n   sealed trait ResponseClass {\n     def isSuccess: Boolean\n@@ -85,7 +107,7 @@ object Status {\n     withRangeCheck(code) {\n       lookup(code) match {\n         case right: Right[_, _] => right\n-        case _ => ParseResult.success(Status(code, \"\"))\n+        case _ => ParseResult.success(trust(code, \"\"))\n       }\n     }\n \n@@ -130,74 +152,74 @@ object Status {\n   /** Status code list taken from http://www.iana.org/assignments/http-status-codes/http-status-codes.xml\n     */\n   // scalastyle:off magic.number\n-  val Continue: Status = register(Status(100, \"Continue\", isEntityAllowed = false))\n+  val Continue: Status = register(trust(100, \"Continue\", isEntityAllowed = false))\n   val SwitchingProtocols: Status = register(\n-    Status(101, \"Switching Protocols\", isEntityAllowed = false))\n-  val Processing: Status = register(Status(102, \"Processing\", isEntityAllowed = false))\n-  val EarlyHints: Status = register(Status(103, \"Early Hints\", isEntityAllowed = false))\n-\n-  val Ok: Status = register(Status(200, \"OK\"))\n-  val Created: Status = register(Status(201, \"Created\"))\n-  val Accepted: Status = register(Status(202, \"Accepted\"))\n-  val NonAuthoritativeInformation: Status = register(Status(203, \"Non-Authoritative Information\"))\n-  val NoContent: Status = register(Status(204, \"No Content\", isEntityAllowed = false))\n-  val ResetContent: Status = register(Status(205, \"Reset Content\", isEntityAllowed = false))\n-  val PartialContent: Status = register(Status(206, \"Partial Content\"))\n-  val MultiStatus: Status = register(Status(207, \"Multi-Status\"))\n-  val AlreadyReported: Status = register(Status(208, \"Already Reported\"))\n-  val IMUsed: Status = register(Status(226, \"IM Used\"))\n-\n-  val MultipleChoices: Status = register(Status(300, \"Multiple Choices\"))\n-  val MovedPermanently: Status = register(Status(301, \"Moved Permanently\"))\n-  val Found: Status = register(Status(302, \"Found\"))\n-  val SeeOther: Status = register(Status(303, \"See Other\"))\n-  val NotModified: Status = register(Status(304, \"Not Modified\", isEntityAllowed = false))\n-  val UseProxy: Status = register(Status(305, \"Use Proxy\"))\n-  val TemporaryRedirect: Status = register(Status(307, \"Temporary Redirect\"))\n-  val PermanentRedirect: Status = register(Status(308, \"Permanent Redirect\"))\n-\n-  val BadRequest: Status = register(Status(400, \"Bad Request\"))\n-  val Unauthorized: Status = register(Status(401, \"Unauthorized\"))\n-  val PaymentRequired: Status = register(Status(402, \"Payment Required\"))\n-  val Forbidden: Status = register(Status(403, \"Forbidden\"))\n-  val NotFound: Status = register(Status(404, \"Not Found\"))\n-  val MethodNotAllowed: Status = register(Status(405, \"Method Not Allowed\"))\n-  val NotAcceptable: Status = register(Status(406, \"Not Acceptable\"))\n-  val ProxyAuthenticationRequired: Status = register(Status(407, \"Proxy Authentication Required\"))\n-  val RequestTimeout: Status = register(Status(408, \"Request Timeout\"))\n-  val Conflict: Status = register(Status(409, \"Conflict\"))\n-  val Gone: Status = register(Status(410, \"Gone\"))\n-  val LengthRequired: Status = register(Status(411, \"Length Required\"))\n-  val PreconditionFailed: Status = register(Status(412, \"Precondition Failed\"))\n-  val PayloadTooLarge: Status = register(Status(413, \"Payload Too Large\"))\n-  val UriTooLong: Status = register(Status(414, \"URI Too Long\"))\n-  val UnsupportedMediaType: Status = register(Status(415, \"Unsupported Media Type\"))\n-  val RangeNotSatisfiable: Status = register(Status(416, \"Range Not Satisfiable\"))\n-  val ExpectationFailed: Status = register(Status(417, \"Expectation Failed\"))\n-  val ImATeapot: Status = register(Status(418, \"I'm A Teapot\"))\n-  val MisdirectedRequest: Status = register(Status(421, \"Misdirected Request\"))\n-  val UnprocessableEntity: Status = register(Status(422, \"Unprocessable Entity\"))\n-  val Locked: Status = register(Status(423, \"Locked\"))\n-  val FailedDependency: Status = register(Status(424, \"Failed Dependency\"))\n-  val TooEarly: Status = register(Status(425, \"Too Early\"))\n-  val UpgradeRequired: Status = register(Status(426, \"Upgrade Required\"))\n-  val PreconditionRequired: Status = register(Status(428, \"Precondition Required\"))\n-  val TooManyRequests: Status = register(Status(429, \"Too Many Requests\"))\n-  val RequestHeaderFieldsTooLarge: Status = register(Status(431, \"Request Header Fields Too Large\"))\n-  val UnavailableForLegalReasons: Status = register(Status(451, \"Unavailable For Legal Reasons\"))\n-\n-  val InternalServerError: Status = register(Status(500, \"Internal Server Error\"))\n-  val NotImplemented: Status = register(Status(501, \"Not Implemented\"))\n-  val BadGateway: Status = register(Status(502, \"Bad Gateway\"))\n-  val ServiceUnavailable: Status = register(Status(503, \"Service Unavailable\"))\n-  val GatewayTimeout: Status = register(Status(504, \"Gateway Timeout\"))\n-  val HttpVersionNotSupported: Status = register(Status(505, \"HTTP Version not supported\"))\n-  val VariantAlsoNegotiates: Status = register(Status(506, \"Variant Also Negotiates\"))\n-  val InsufficientStorage: Status = register(Status(507, \"Insufficient Storage\"))\n-  val LoopDetected: Status = register(Status(508, \"Loop Detected\"))\n-  val NotExtended: Status = register(Status(510, \"Not Extended\"))\n+    trust(101, \"Switching Protocols\", isEntityAllowed = false))\n+  val Processing: Status = register(trust(102, \"Processing\", isEntityAllowed = false))\n+  val EarlyHints: Status = register(trust(103, \"Early Hints\", isEntityAllowed = false))\n+\n+  val Ok: Status = register(trust(200, \"OK\"))\n+  val Created: Status = register(trust(201, \"Created\"))\n+  val Accepted: Status = register(trust(202, \"Accepted\"))\n+  val NonAuthoritativeInformation: Status = register(trust(203, \"Non-Authoritative Information\"))\n+  val NoContent: Status = register(trust(204, \"No Content\", isEntityAllowed = false))\n+  val ResetContent: Status = register(trust(205, \"Reset Content\", isEntityAllowed = false))\n+  val PartialContent: Status = register(trust(206, \"Partial Content\"))\n+  val MultiStatus: Status = register(trust(207, \"Multi-Status\"))\n+  val AlreadyReported: Status = register(trust(208, \"Already Reported\"))\n+  val IMUsed: Status = register(trust(226, \"IM Used\"))\n+\n+  val MultipleChoices: Status = register(trust(300, \"Multiple Choices\"))\n+  val MovedPermanently: Status = register(trust(301, \"Moved Permanently\"))\n+  val Found: Status = register(trust(302, \"Found\"))\n+  val SeeOther: Status = register(trust(303, \"See Other\"))\n+  val NotModified: Status = register(trust(304, \"Not Modified\", isEntityAllowed = false))\n+  val UseProxy: Status = register(trust(305, \"Use Proxy\"))\n+  val TemporaryRedirect: Status = register(trust(307, \"Temporary Redirect\"))\n+  val PermanentRedirect: Status = register(trust(308, \"Permanent Redirect\"))\n+\n+  val BadRequest: Status = register(trust(400, \"Bad Request\"))\n+  val Unauthorized: Status = register(trust(401, \"Unauthorized\"))\n+  val PaymentRequired: Status = register(trust(402, \"Payment Required\"))\n+  val Forbidden: Status = register(trust(403, \"Forbidden\"))\n+  val NotFound: Status = register(trust(404, \"Not Found\"))\n+  val MethodNotAllowed: Status = register(trust(405, \"Method Not Allowed\"))\n+  val NotAcceptable: Status = register(trust(406, \"Not Acceptable\"))\n+  val ProxyAuthenticationRequired: Status = register(trust(407, \"Proxy Authentication Required\"))\n+  val RequestTimeout: Status = register(trust(408, \"Request Timeout\"))\n+  val Conflict: Status = register(trust(409, \"Conflict\"))\n+  val Gone: Status = register(trust(410, \"Gone\"))\n+  val LengthRequired: Status = register(trust(411, \"Length Required\"))\n+  val PreconditionFailed: Status = register(trust(412, \"Precondition Failed\"))\n+  val PayloadTooLarge: Status = register(trust(413, \"Payload Too Large\"))\n+  val UriTooLong: Status = register(trust(414, \"URI Too Long\"))\n+  val UnsupportedMediaType: Status = register(trust(415, \"Unsupported Media Type\"))\n+  val RangeNotSatisfiable: Status = register(trust(416, \"Range Not Satisfiable\"))\n+  val ExpectationFailed: Status = register(trust(417, \"Expectation Failed\"))\n+  val ImATeapot: Status = register(trust(418, \"I'm A Teapot\"))\n+  val MisdirectedRequest: Status = register(trust(421, \"Misdirected Request\"))\n+  val UnprocessableEntity: Status = register(trust(422, \"Unprocessable Entity\"))\n+  val Locked: Status = register(trust(423, \"Locked\"))\n+  val FailedDependency: Status = register(trust(424, \"Failed Dependency\"))\n+  val TooEarly: Status = register(trust(425, \"Too Early\"))\n+  val UpgradeRequired: Status = register(trust(426, \"Upgrade Required\"))\n+  val PreconditionRequired: Status = register(trust(428, \"Precondition Required\"))\n+  val TooManyRequests: Status = register(trust(429, \"Too Many Requests\"))\n+  val RequestHeaderFieldsTooLarge: Status = register(trust(431, \"Request Header Fields Too Large\"))\n+  val UnavailableForLegalReasons: Status = register(trust(451, \"Unavailable For Legal Reasons\"))\n+\n+  val InternalServerError: Status = register(trust(500, \"Internal Server Error\"))\n+  val NotImplemented: Status = register(trust(501, \"Not Implemented\"))\n+  val BadGateway: Status = register(trust(502, \"Bad Gateway\"))\n+  val ServiceUnavailable: Status = register(trust(503, \"Service Unavailable\"))\n+  val GatewayTimeout: Status = register(trust(504, \"Gateway Timeout\"))\n+  val HttpVersionNotSupported: Status = register(trust(505, \"HTTP Version not supported\"))\n+  val VariantAlsoNegotiates: Status = register(trust(506, \"Variant Also Negotiates\"))\n+  val InsufficientStorage: Status = register(trust(507, \"Insufficient Storage\"))\n+  val LoopDetected: Status = register(trust(508, \"Loop Detected\"))\n+  val NotExtended: Status = register(trust(510, \"Not Extended\"))\n   val NetworkAuthenticationRequired: Status = register(\n-    Status(511, \"Network Authentication Required\"))\n+    trust(511, \"Network Authentication Required\"))\n   // scalastyle:on magic.number\n \n   implicit val http4sOrderForStatus: Order[Status] = Order.fromOrdering[Status]"
        },
        {
          "filename": "core/shared/src/main/scala/org/http4s/internal/package.scala",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -285,4 +285,15 @@ package object internal {\n       tail: Eval[Int]*\n   ): Int =\n     reduceComparisons_(NonEmptyChain(Eval.now(head), tail: _*))\n+\n+  private[http4s] def appendSanitized(sb: StringBuilder, s: String): Unit = {\n+    val start = sb.length\n+    sb.append(s)\n+    for (i <- start until sb.length) {\n+      val c = sb.charAt(i)\n+      if (c == 0x0.toChar || c == '\\r' || c == '\\n') {\n+        sb.setCharAt(i, ' ')\n+      }\n+    }\n+  }\n }"
        },
        {
          "filename": "core/shared/src/main/scala/org/http4s/util/Renderable.scala",
          "status": "modified",
          "additions": 50,
          "deletions": 2,
          "patch": "@@ -143,7 +143,7 @@ object Writer {\n }\n \n /** Efficiently accumulate [[Renderable]] representations */\n-trait Writer {\n+trait Writer { self =>\n   def append(s: String): this.type\n   def append(ci: CIString): this.type = append(ci.toString)\n   def append(char: Char): this.type = append(char.toString)\n@@ -242,12 +242,30 @@ trait Writer {\n   final def <<(int: Int): this.type = append(int)\n   final def <<(long: Long): this.type = append(long)\n   final def <<[T: Renderer](r: T): this.type = append(r)\n+\n+  def sanitize(f: Writer => Writer): this.type = {\n+    val w = new Writer {\n+      def append(s: String): this.type = {\n+        s.foreach(append(_))\n+        this\n+      }\n+      override def append(c: Char): this.type = {\n+        if (c == 0x0.toChar || c == '\\r' || c == '\\n')\n+          self.append(' ')\n+        else\n+          self.append(c)\n+        this\n+      }\n+    }\n+    f(w)\n+    this\n+  }\n }\n \n /** [[Writer]] that will result in a `String`\n   * @param size initial buffer size of the underlying `StringBuilder`\n   */\n-class StringWriter(size: Int = StringWriter.InitialCapacity) extends Writer {\n+class StringWriter(size: Int = StringWriter.InitialCapacity) extends Writer { self =>\n   private val sb = new java.lang.StringBuilder(size)\n \n   def append(s: String): this.type = { sb.append(s); this }\n@@ -257,6 +275,31 @@ class StringWriter(size: Int = StringWriter.InitialCapacity) extends Writer {\n   override def append(int: Int): this.type = { sb.append(int); this }\n   override def append(long: Long): this.type = { sb.append(long); this }\n \n+  override def sanitize(f: Writer => Writer): this.type = {\n+    val w = new Writer {\n+      def append(s: String): this.type = {\n+        val start = sb.length\n+        self.append(s)\n+        for (i <- start until sb.length) {\n+          val c = sb.charAt(i)\n+          if (c == 0x0.toChar || c == '\\r' || c == '\\n') {\n+            sb.setCharAt(i, ' ')\n+          }\n+        }\n+        this\n+      }\n+      override def append(c: Char): this.type = {\n+        if (c == 0x0.toChar || c == '\\r' || c == '\\n')\n+          self.append(' ')\n+        else\n+          self.append(c)\n+        this\n+      }\n+    }\n+    f(w)\n+    this\n+  }\n+\n   def result: String = sb.toString\n }\n \n@@ -272,4 +315,9 @@ private[http4s] class HeaderLengthCountingWriter extends Writer {\n     length = length + s.length\n     this\n   }\n+\n+  override def sanitize(f: Writer => Writer): this.type = {\n+    f(this)\n+    this\n+  }\n }"
        },
        {
          "filename": "ember-client/shared/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala",
          "status": "modified",
          "additions": 2,
          "deletions": 3,
          "patch": "@@ -126,7 +126,7 @@ final class EmberClientBuilder[F[_]: Async] private (\n       tlsContextOptWithDefault <- Resource.eval(\n         tlsContextOpt.fold(Network[F].tlsContext.system.attempt.map(_.toOption))(_.some.pure[F]))\n       builder =\n-        KeyPoolBuilder\n+        KeyPool.Builder\n           .apply[F, RequestKey, EmberConnection[F]](\n             (requestKey: RequestKey) =>\n               EmberConnection(\n@@ -138,11 +138,10 @@ final class EmberClientBuilder[F[_]: Async] private (\n                     sg,\n                     additionalSocketOptions\n                   )) <* logger.trace(s\"Created Connection - RequestKey: ${requestKey}\"),\n-            { case connection =>\n+            (connection: EmberConnection[F]) =>\n               logger.trace(\n                 s\"Shutting Down Connection - RequestKey: ${connection.keySocket.requestKey}\") >>\n                 connection.cleanup\n-            }\n           )\n           .withDefaultReuseState(Reusable.DontReuse)\n           .withIdleTimeAllowedInPool(idleTimeInPool)"
        },
        {
          "filename": "ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala",
          "status": "modified",
          "additions": 70,
          "deletions": 54,
          "patch": "@@ -16,9 +16,11 @@\n \n package org.http4s.ember.core\n \n+import cats.ApplicativeThrow\n import fs2._\n import org.http4s._\n import org.http4s.headers.{Host, `Content-Length`}\n+import org.http4s.internal.{CharPredicate, appendSanitized}\n import java.nio.charset.StandardCharsets\n \n private[ember] object Encoder {\n@@ -49,12 +51,14 @@ private[ember] object Encoder {\n \n       // Apply each header followed by a CRLF\n       resp.headers.foreach { h =>\n-        stringBuilder\n-          .append(h.name)\n-          .append(\": \")\n-          .append(h.value)\n-          .append(CRLF)\n-        ()\n+        if (h.isNameValid) {\n+          stringBuilder\n+            .append(h.name)\n+            .append(\": \")\n+          appendSanitized(stringBuilder, h.value)\n+          stringBuilder.append(CRLF)\n+          ()\n+        }\n       }\n       if (!chunked && !appliedContentLength && resp.status.isEntityAllowed) {\n         stringBuilder.append(chunkedTansferEncodingHeaderRaw).append(CRLF)\n@@ -77,61 +81,73 @@ private[ember] object Encoder {\n   private val NoPayloadMethods: Set[Method] =\n     Set(Method.GET, Method.DELETE, Method.CONNECT, Method.TRACE)\n \n-  def reqToBytes[F[_]](req: Request[F], writeBufferSize: Int = 32 * 1024): Stream[F, Byte] = {\n-    var chunked = req.isChunked\n-    val initSection = {\n-      var appliedContentLength = false\n-      val stringBuilder = new StringBuilder()\n+  def reqToBytes[F[_]: ApplicativeThrow](\n+      req: Request[F],\n+      writeBufferSize: Int = 32 * 1024): Stream[F, Byte] = {\n+    val uriOriginFormString = req.uri.toOriginForm.renderString\n \n-      // Request-Line   = Method SP Request-URI SP HTTP-Version CRLF\n-      stringBuilder\n-        .append(req.method.renderString)\n-        .append(SPACE)\n-        .append(req.uri.toOriginForm.renderString)\n-        .append(SPACE)\n-        .append(req.httpVersion.renderString)\n-        .append(CRLF)\n+    if (uriOriginFormString.exists(ForbiddenUriCharacters)) {\n+      Stream.raiseError(new IllegalArgumentException(s\"Invalid URI: ${uriOriginFormString}\"))\n+    } else {\n+      var chunked = req.isChunked\n+      val initSection = {\n+        var appliedContentLength = false\n+        val stringBuilder = new StringBuilder()\n \n-      // Host From Uri Becomes Header if not already present in headers\n-      if (req.headers.get[Host].isEmpty)\n-        req.uri.authority.foreach { auth =>\n-          stringBuilder\n-            .append(\"Host: \")\n-            .append(auth.renderString)\n-            .append(CRLF)\n-        }\n+        // Request-Line   = Method SP Request-URI SP HTTP-Version CRLF\n+        stringBuilder\n+          .append(req.method.renderString)\n+          .append(SPACE)\n+          .append(uriOriginFormString)\n+          .append(SPACE)\n+          .append(req.httpVersion.renderString)\n+          .append(CRLF)\n \n-      req.headers\n-        .get[`Content-Length`]\n-        .foreach { _ =>\n-          appliedContentLength = true\n+        // Host From Uri Becomes Header if not already present in headers\n+        if (req.headers.get[Host].isEmpty)\n+          req.uri.authority.foreach { auth =>\n+            stringBuilder\n+              .append(\"Host: \")\n+              .append(auth.renderString)\n+              .append(CRLF)\n+          }\n+\n+        req.headers\n+          .get[`Content-Length`]\n+          .foreach { _ =>\n+            appliedContentLength = true\n+          }\n+\n+        // Apply each header followed by a CRLF\n+        req.headers.foreach { h =>\n+          if (h.isNameValid) {\n+            stringBuilder\n+              .append(h.name)\n+              .append(\": \")\n+            appendSanitized(stringBuilder, h.value)\n+            stringBuilder.append(CRLF)\n+            ()\n+          }\n         }\n \n-      // Apply each header followed by a CRLF\n-      req.headers.foreach { h =>\n-        stringBuilder\n-          .append(h.name)\n-          .append(\": \")\n-          .append(h.value)\n-          .append(CRLF)\n-        ()\n-      }\n+        if (!chunked && !appliedContentLength && !NoPayloadMethods.contains(req.method)) {\n+          stringBuilder.append(chunkedTansferEncodingHeaderRaw).append(CRLF)\n+          chunked = true\n+          ()\n+        }\n \n-      if (!chunked && !appliedContentLength && !NoPayloadMethods.contains(req.method)) {\n-        stringBuilder.append(chunkedTansferEncodingHeaderRaw).append(CRLF)\n-        chunked = true\n-        ()\n+        // Final CRLF terminates headers and signals body to follow.\n+        stringBuilder.append(CRLF)\n+        stringBuilder.toString.getBytes(StandardCharsets.ISO_8859_1)\n       }\n-\n-      // Final CRLF terminates headers and signals body to follow.\n-      stringBuilder.append(CRLF)\n-      stringBuilder.toString.getBytes(StandardCharsets.ISO_8859_1)\n+      if (chunked)\n+        Stream.chunk(Chunk.array(initSection)) ++ req.body.through(ChunkedEncoding.encode[F])\n+      else\n+        (Stream.chunk(Chunk.array(initSection)) ++ req.body)\n+          .chunkMin(writeBufferSize)\n+          .flatMap(Stream.chunk)\n     }\n-    if (chunked)\n-      Stream.chunk(Chunk.array(initSection)) ++ req.body.through(ChunkedEncoding.encode[F])\n-    else\n-      (Stream.chunk(Chunk.array(initSection)) ++ req.body)\n-        .chunkMin(writeBufferSize)\n-        .flatMap(Stream.chunk)\n   }\n+\n+  private val ForbiddenUriCharacters = CharPredicate(0x0.toChar, ' ', '\\r', '\\n')\n }"
        },
        {
          "filename": "ember-core/src/test/scala/org/http4s/ember/core/RequestSplittingSuite.scala",
          "status": "added",
          "additions": 65,
          "deletions": 0,
          "patch": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2019 http4s.org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.http4s\n+package ember.core\n+\n+import cats.effect.{Concurrent, IO}\n+import cats.implicits._\n+import org.typelevel.ci._\n+\n+class RequestSplittingSuite extends Http4sSuite {\n+  def attack[F[_]](req: Request[F])(implicit F: Concurrent[F]): F[Response[F]] =\n+    for {\n+      reqBytes <- Encoder\n+        .reqToBytes(req)\n+        .compile\n+        .to(Array)\n+      _ = println(new String(reqBytes))\n+      app = HttpApp[F] { req =>\n+        (req.headers.get(ci\"Evil\") match {\n+          case Some(_) => Response[F](Status.InternalServerError)\n+          case None => Response[F](Status.Ok)\n+        }).pure[F]\n+      }\n+      result <- Parser.Request.parser[F](1024)(reqBytes, F.pure(None))\n+      (req0, _) = result\n+      resp <- app(req0)\n+    } yield resp\n+\n+  test(\"Prevent request splitting attacks on URI path\") {\n+    val req = Request[IO](uri = Uri(path =\n+      Uri.Path.Root / Uri.Path.Segment.encoded(\" HTTP/1.0\\r\\nEvil:true\\r\\nHide-Protocol-Version:\")))\n+    attack(req).intercept[IllegalArgumentException]\n+  }\n+\n+  test(\"Prevent request splitting attacks on URI regname\") {\n+    val req = Request[IO](uri = Uri(\n+      authority = Uri.Authority(None, Uri.RegName(\"example.com\\r\\nEvil:true\\r\\n\")).some,\n+      path = Uri.Path.Root))\n+    attack(req).map(_.status).assertEquals(Status.Ok)\n+  }\n+\n+  test(\"Prevent request splitting attacks on field name\") {\n+    val req = Request[IO]().putHeaders(Header.Raw(ci\"Fine:\\r\\nEvil:true\\r\\n\", \"oops\"))\n+    attack(req).map(_.status).assertEquals(Status.Ok)\n+  }\n+\n+  test(\"Prevent request splitting attacks on field value\") {\n+    val req = Request[IO]().putHeaders(Header.Raw(ci\"X-Carrier\", \"\\r\\nEvil:true\\r\\n\"))\n+    attack(req).map(_.status).assertEquals(Status.Ok)\n+  }\n+}"
        },
        {
          "filename": "ember-core/src/test/scala/org/http4s/ember/core/ResponseSplittingSuite.scala",
          "status": "added",
          "additions": 67,
          "deletions": 0,
          "patch": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2019 http4s.org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.http4s\n+package ember.core\n+\n+import cats.effect.{Concurrent, IO}\n+import cats.implicits._\n+import org.http4s.implicits._\n+import org.typelevel.ci._\n+\n+class ResponseSplittingSuite extends Http4sSuite {\n+  def attack[F[_]](app: HttpApp[F], req: Request[F])(implicit F: Concurrent[F]): F[Response[F]] =\n+    for {\n+      resp <- app(req)\n+      respBytes <- Encoder\n+        .respToBytes(resp)\n+        .compile\n+        .to(Array)\n+      result <- Parser.Response.parser[F](1024)(respBytes, F.pure(None))\n+    } yield (result._1)\n+\n+  test(\"Prevent response splitting attacks on status reason phrase\") {\n+    val app = HttpApp[IO] { req =>\n+      Response(Status.NoContent.withReason(req.params(\"reason\"))).pure[IO]\n+    }\n+    val req = Request[IO](uri = uri\"/?reason=%0D%0AEvil:true%0D%0A\")\n+    attack(app, req).map { resp =>\n+      assertEquals(resp.headers.headers.find(_.name === ci\"Evil\"), None)\n+    }\n+  }\n+\n+  test(\"Prevent response splitting attacks on field name\") {\n+    val app = HttpApp[IO] { req =>\n+      Response(Status.NoContent).putHeaders(req.params(\"fieldName\") -> \"oops\").pure[IO]\n+    }\n+    val req = Request[IO](uri = uri\"/?fieldName=Fine:%0D%0AEvil:true%0D%0A\")\n+    attack(app, req).map { resp =>\n+      assertEquals(resp.headers.headers.find(_.name === ci\"Evil\"), None)\n+    }\n+  }\n+\n+  test(\"Prevent response splitting attacks on field value\") {\n+    val app = HttpApp[IO] { req =>\n+      Response[IO](Status.NoContent)\n+        .putHeaders(\"X-Oops\" -> req.params(\"fieldValue\"))\n+        .pure[IO]\n+    }\n+    val req = Request[IO](uri = uri\"/?fieldValue=%0D%0AEvil:true%0D%0A\")\n+    attack(app, req).map { resp =>\n+      assertEquals(resp.headers.headers.find(_.name === ci\"Evil\"), None)\n+    }\n+  }\n+}"
        },
        {
          "filename": "jetty-client/src/main/scala/org/http4s/jetty/client/JettyClient.scala",
          "status": "modified",
          "additions": 8,
          "deletions": 4,
          "patch": "@@ -44,12 +44,15 @@ object JettyClient {\n         Client[F] { req =>\n           Resource.suspend(F.async[Resource[F, Response[F]]] { cb =>\n             F.bracket(StreamRequestContentProvider()) { dcp =>\n-              val jReq = toJettyRequest(client, req, dcp)\n-              for {\n+              (for {\n+                jReq <- F.catchNonFatal(toJettyRequest(client, req, dcp))\n                 rl <- ResponseListener(cb)\n                 _ <- F.delay(jReq.send(rl))\n                 _ <- dcp.write(req)\n-              } yield Option.empty[F[Unit]]\n+              } yield Option.empty[F[Unit]]).recover { case e =>\n+                cb(Left(e))\n+                Option.empty[F[Unit]]\n+              }\n             } { dcp =>\n               F.delay(dcp.close())\n             }\n@@ -89,7 +92,8 @@ object JettyClient {\n         }\n       )\n \n-    for (h <- request.headers.headers) jReq.header(h.name.toString, h.value)\n+    for (h <- request.headers.headers if h.isNameValid)\n+      jReq.header(h.name.toString, h.value)\n     jReq.content(dcp)\n   }\n }"
        },
        {
          "filename": "laws/src/main/scala/org/http4s/laws/discipline/ArbitraryInstances.scala",
          "status": "modified",
          "additions": 24,
          "deletions": 5,
          "patch": "@@ -33,7 +33,6 @@ import java.nio.charset.{Charset => NioCharset}\n import java.time._\n import java.util.Locale\n import org.http4s.headers._\n-import org.http4s.laws.discipline.ArbitraryInstances.genAlphaToken\n import org.http4s.syntax.literals._\n import org.scalacheck._\n import org.scalacheck.Arbitrary.{arbitrary => getArbitrary}\n@@ -48,6 +47,8 @@ import scala.concurrent.Future\n import scala.util.Try\n \n private[http4s] trait ArbitraryInstances extends Ip4sArbitraryInstances {\n+  import ArbitraryInstances._\n+\n   private implicit class ParseResultSyntax[A](self: ParseResult[A]) {\n     def yolo: A = self.valueOr(e => sys.error(e.toString))\n   }\n@@ -155,12 +156,12 @@ private[http4s] trait ArbitraryInstances extends Ip4sArbitraryInstances {\n \n   val genCustomStatus = for {\n     code <- genValidStatusCode\n-    reason <- getArbitrary[String]\n-  } yield Status.fromIntAndReason(code, reason).yolo\n+    reason <- genCustomStatusReason\n+  } yield Status.fromInt(code).yolo.withReason(reason)\n \n   implicit val http4sTestingArbitraryForStatus: Arbitrary[Status] = Arbitrary(\n     frequency(\n-      10 -> genStandardStatus,\n+      4 -> genStandardStatus,\n       1 -> genCustomStatus\n     ))\n   implicit val http4sTestingCogenForStatus: Cogen[Status] =\n@@ -579,7 +580,7 @@ private[http4s] trait ArbitraryInstances extends Ip4sArbitraryInstances {\n   implicit val http4sTestingArbitraryForRawHeader: Arbitrary[Header.Raw] =\n     Arbitrary {\n       for {\n-        token <- genToken\n+        token <- frequency(8 -> genToken, 1 -> asciiStr, 1 -> getArbitrary[String])\n         value <- genFieldValue\n       } yield Header.Raw(CIString(token), value)\n     }\n@@ -1010,4 +1011,22 @@ object ArbitraryInstances extends ArbitraryInstances {\n   implicit val http4sTestingCogenForResponsePrelude: Cogen[ResponsePrelude] =\n     Cogen[(Headers, HttpVersion, Status)].contramap(value =>\n       (value.headers, value.httpVersion, value.status))\n+  val genCustomStatusReason: Gen[String] = {\n+    val word = poisson(5).flatMap(stringOfN(_, alphaChar))\n+    val normal = poisson(3).flatMap(listOfN(_, word)).map(_.mkString(\" \"))\n+    val exotic = stringOf(\n+      frequency(\n+        1 -> '\\t',\n+        1 -> const(' '),\n+        94 -> asciiPrintableChar\n+      ))\n+    val unsanitizedAscii = asciiStr\n+    val unsanitized = getArbitrary[String]\n+    oneOf(\n+      normal,\n+      exotic,\n+      unsanitizedAscii,\n+      unsanitized\n+    )\n+  }\n }"
        },
        {
          "filename": "project/Http4sPlugin.scala",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -256,7 +256,7 @@ object Http4sPlugin extends AutoPlugin {\n     val jawn = \"1.2.0\"\n     val jawnFs2 = \"2.1.0\"\n     val jetty = \"9.4.43.v20210629\"\n-    val keypool = \"0.4.6\"\n+    val keypool = \"0.4.7\"\n     val literally = \"1.0.2\"\n     val logback = \"1.2.5\"\n     val log4cats = \"2.1.1\""
        },
        {
          "filename": "scalafix/rules/src/main/scala/fix/v0_22.scala",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -30,6 +30,6 @@ class v0_22 extends SemanticRule(\"v0_22\") {\n       \"org.http4s.client.okhttp\" -> \"org.http4s.okhttp.client\",\n       \"org.http4s.client.asynchttpclient\" -> \"org.http4s.asynchttpclient\",\n       \"org.http4s.client.blaze\" -> \"org.http4s.blaze.client\",\n-      \"org.http4s.server.blaze\" -> \"org.http4s.blaze.server\",\n+      \"org.http4s.server.blaze\" -> \"org.http4s.blaze.server\"\n     )\n }"
        },
        {
          "filename": "scripts/scaffold_server.js",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -53,8 +53,14 @@ http.createServer(async (req, res) => {\n         res.end();\n         break;\n       default:\n-        res.statusCode = 404;\n+        if (req.url.startsWith('/request-splitting')) {\n+          res.statusCode = req.headers['Evil'] ? 500 : 200;\n+        }\n+        else {\n+          res.statusCode = 404;\n+        }\n         res.end();\n+        break;\n     }\n   } else if (req.method === 'POST') {\n     req.on('data', (chunk) => {"
        },
        {
          "filename": "server-testing/src/test/scala/org/http4s/server/ServerRouteTestBattery.scala",
          "status": "modified",
          "additions": 9,
          "deletions": 1,
          "patch": "@@ -18,12 +18,14 @@ package org.http4s.server\n \n import cats.effect.IO\n import cats.effect.kernel.Resource\n+import cats.syntax.all._\n import org.http4s.HttpApp\n import org.http4s.Method\n import org.http4s.Response\n import org.http4s.Status\n import org.http4s.client.ClientRouteTestBattery\n import org.http4s.client.testroutes.GetRoutes\n+import org.typelevel.ci._\n \n abstract class ServerRouteTestBattery(name: String) extends ClientRouteTestBattery(name) {\n \n@@ -38,7 +40,13 @@ object ServerRouteTestBattery {\n \n   val App: HttpApp[IO] = HttpApp[IO] { request =>\n     val get = Some(request).filter(_.method == Method.GET).flatMap { r =>\n-      GetRoutes.getPaths.get(r.uri.path.toString)\n+      r.uri.path.toString match {\n+        case p if p.startsWith(\"/request-splitting\") =>\n+          if (r.headers.get(ci\"Evil\").isDefined) IO(Response[IO](Status.InternalServerError)).some\n+          else IO(Response[IO](Status.Ok)).some\n+        case p =>\n+          GetRoutes.getPaths.get(r.uri.path.toString)\n+      }\n     }\n \n     val post = Some(request).filter(_.method == Method.POST).map { r =>"
        },
        {
          "filename": "tests/shared/src/test/scala/org/http4s/HeaderSuite.scala",
          "status": "modified",
          "additions": 22,
          "deletions": 0,
          "patch": "@@ -17,8 +17,10 @@\n package org.http4s\n \n import cats.kernel.laws.discipline.OrderTests\n+import java.nio.charset.StandardCharsets.ISO_8859_1\n import org.http4s.headers._\n import org.http4s.laws.discipline.ArbitraryInstances._\n+import org.scalacheck.Prop._\n \n class HeaderSuite extends munit.DisciplineSuite {\n   test(\"Headers should Equate same headers\") {\n@@ -54,4 +56,24 @@ class HeaderSuite extends munit.DisciplineSuite {\n   test(\"Order instance for Header should be lawful\") {\n     checkAll(\"Order[Header]\", OrderTests[Header.Raw].order)\n   }\n+\n+  test(\"isNameValid\") {\n+    forAll { (h: Header.Raw) =>\n+      val tchar =\n+        Set(0x21.toChar to 0x7e.toChar: _*).diff(Set(\"\\\"(),/:;<=>?@[\\\\]{}\": _*)).map(_.toByte)\n+      assertEquals(\n+        h.isNameValid,\n+        h.name.toString.nonEmpty && h.name.toString.getBytes(ISO_8859_1).forall(tchar),\n+        h.name)\n+    }\n+  }\n+\n+  private val ProhibitedFieldValueChars = Set(0x0.toChar, '\\r', '\\n')\n+\n+  test(\"sanitizes prohibited header characters\") {\n+    forAll { (h: Header.Raw) =>\n+      val s = h.sanitizedValue\n+      assert(!s.exists(ProhibitedFieldValueChars), s)\n+    }\n+  }\n }"
        },
        {
          "filename": "tests/shared/src/test/scala/org/http4s/StatusSpec.scala",
          "status": "modified",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -18,6 +18,7 @@ package org.http4s\n \n import org.http4s.laws.discipline.arbitrary._\n import cats.kernel.laws.discipline.OrderTests\n+import java.nio.charset.StandardCharsets\n import org.http4s.Status._\n import org.scalacheck.Gen\n import org.scalacheck.Prop.{forAll, propBoolean}\n@@ -114,6 +115,20 @@ class StatusSpec extends Http4sSuite {\n     assertEquals(getStatus(NotFound.code, \"Not Found\").reason, \"Not Found\")\n   }\n \n+  test(\"all known status have a reason\") {\n+    Status.registered.foreach { status =>\n+      assert(status.renderString.drop(4).nonEmpty, status.renderString)\n+    }\n+  }\n+\n+  test(\"rendering sanitizes statuses\") {\n+    forAll { (s: Status) =>\n+      s.renderString\n+        .getBytes(StandardCharsets.ISO_8859_1)\n+        .forall(b => b == ' ' || b == '\\t' || (b >= 0x21 && b <= 0x7e) || ((b & 0xff) > 0x80))\n+    }\n+  }\n+\n   private def getStatus(code: Int) =\n     fromInt(code) match {\n       case Right(s) => s"
        },
        {
          "filename": "tests/src/test/scala/org/http4s/internal/StringWriterSuite.scala",
          "status": "added",
          "additions": 53,
          "deletions": 0,
          "patch": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2013 http4s.org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.http4s\n+package util\n+\n+import org.scalacheck.Arbitrary.arbitrary\n+import org.scalacheck.Gen._\n+import org.scalacheck.Prop._\n+\n+class StringWriterSuite extends Http4sSuite {\n+\n+  test(\"sanitize works on chars\") {\n+    val sw = new StringWriter\n+    sw.sanitize(_ << 'x' << 0x0.toChar << '\\r' << '\\n' << 'x')\n+    assertEquals(\"x   x\", sw.result)\n+  }\n+\n+  test(\"sanitize works on strings\") {\n+    val sw = new StringWriter\n+    sw.sanitize(_ << \"x\\u0000\\r\\nx\")\n+    assertEquals(\"x   x\", sw.result)\n+  }\n+\n+  test(\"sanitizes between appends\") {\n+    val forbiddenChars = Set(0x0.toChar, '\\r', '\\n')\n+    val unsanitaryGen = stringOf(oneOf(oneOf(forbiddenChars), arbitrary[Char]))\n+    forAll(arbitrary[String], unsanitaryGen, arbitrary[String]) {\n+      (s1: String, s2: String, s3: String) =>\n+        s2.exists(forbiddenChars) ==> {\n+          val sw = new StringWriter\n+          (sw << s1).sanitize(_ << s2) << s3\n+          val s = sw.result\n+          assert(s.startsWith(s1))\n+          assert(s.endsWith(s3))\n+          assert(!s.drop(s1.length).dropRight(s3.length).exists(forbiddenChars))\n+        }\n+    }\n+  }\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 8,
        "unique_directories": 20,
        "max_directory_depth": 9
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "81fc34a53b22e0789e702a73014de0ddf92c0e5c",
            "date": "2025-01-17T02:37:50Z",
            "author_login": "rossabaker"
          },
          {
            "sha": "87c05aedc17b460510e72019dbaf06bcb375a84a",
            "date": "2025-01-17T02:29:00Z",
            "author_login": "rossabaker"
          },
          {
            "sha": "8501afc9fbcb90138df71e6f19de3d26eb80f66f",
            "date": "2025-01-14T12:19:21Z",
            "author_login": "http4s-steward[bot]"
          },
          {
            "sha": "060163d496502767e10b14094cd09b4211606b07",
            "date": "2025-01-14T07:52:16Z",
            "author_login": "http4s-steward[bot]"
          },
          {
            "sha": "3aace932e204b9743e2126ef5530df6d8af82d54",
            "date": "2025-01-07T09:14:14Z",
            "author_login": "danicheg"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.7,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:N",
    "cwe_id": "CWE-918",
    "description": "http4s is an open source scala interface for HTTP. In affected versions http4s is vulnerable to response-splitting or request-splitting attacks when untrusted user input is used to create any of the following fields: Header names (`Header.name`\u00e5), Header values (`Header.value`), Status reason phrases (`Status.reason`), URI paths (`Uri.Path`), URI authority registered names (`URI.RegName`) (through 0.21). This issue has been resolved in versions 0.21.30, 0.22.5, 0.23.4, and 1.0.0-M27 perform the following. As a matter of practice http4s services and client applications should sanitize any user input in the aforementioned fields before returning a request or response to the backend. The carriage return, newline, and null characters are the most threatening.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2021-09-21T18:15:07.427",
    "last_modified": "2024-11-21T06:25:25.353",
    "fix_date": "2021-09-21T13:03:00Z"
  },
  "references": [
    {
      "url": "https://github.com/http4s/http4s/commit/d02007db1da4f8f3df2dbf11f1db9ac7afc3f9d8",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/http4s/http4s/security/advisories/GHSA-5vcm-3xc3-w7x3",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#fields.values",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://owasp.org/www-community/attacks/HTTP_Response_Splitting",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/http4s/http4s/commit/d02007db1da4f8f3df2dbf11f1db9ac7afc3f9d8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/http4s/http4s/security/advisories/GHSA-5vcm-3xc3-w7x3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#fields.values",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://owasp.org/www-community/attacks/HTTP_Response_Splitting",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:07.781716",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "http4s",
    "owner": "http4s",
    "created_at": "2012-03-12T04:41:20Z",
    "updated_at": "2025-01-24T12:57:20Z",
    "pushed_at": "2025-01-26T07:25:35Z",
    "size": 95885,
    "stars": 2558,
    "forks": 791,
    "open_issues": 337,
    "watchers": 2558,
    "has_security_policy": false,
    "default_branch": "series/0.23",
    "protected_branches": [
      "main",
      "release-0.15.x",
      "release-0.16.x",
      "release-0.17.x",
      "release-0.18.x",
      "series/0.20",
      "series/0.21",
      "series/0.22",
      "series/0.23"
    ],
    "languages": {
      "Scala": 3083537,
      "Nix": 1141,
      "HTML": 19,
      "Shell": 10
    },
    "commit_activity": {
      "total_commits_last_year": 524,
      "avg_commits_per_week": 10.076923076923077,
      "days_active_last_year": 170
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:47:07.878018"
  }
}