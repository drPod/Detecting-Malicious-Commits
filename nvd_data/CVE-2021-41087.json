{
  "cve_id": "CVE-2021-41087",
  "github_data": {
    "repository": "in-toto/in-toto-golang",
    "fix_commit": "f2c57d1e0f15e3ffbeac531829c696b72ecc4290",
    "related_commits": [
      "f2c57d1e0f15e3ffbeac531829c696b72ecc4290",
      "f2c57d1e0f15e3ffbeac531829c696b72ecc4290"
    ],
    "patch_url": "https://github.com/in-toto/in-toto-golang/commit/f2c57d1e0f15e3ffbeac531829c696b72ecc4290.patch",
    "fix_commit_details": {
      "sha": "f2c57d1e0f15e3ffbeac531829c696b72ecc4290",
      "commit_date": "2021-09-21T20:50:06Z",
      "author": {
        "login": "adityasaky",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-vrxp-mg9f-hwf3",
        "length": 89,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 863,
        "additions": 682,
        "deletions": 181
      },
      "files": [
        {
          "filename": "in_toto/match.go",
          "status": "added",
          "additions": 228,
          "deletions": 0,
          "patch": "@@ -0,0 +1,228 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found at https://golang.org/LICENSE.\n+\n+// this is a modified version of path.Match that removes handling of path separators\n+\n+package in_toto\n+\n+import (\n+\t\"errors\"\n+\t\"unicode/utf8\"\n+)\n+\n+// errBadPattern indicates a pattern was malformed.\n+var errBadPattern = errors.New(\"syntax error in pattern\")\n+\n+// match reports whether name matches the shell pattern.\n+// The pattern syntax is:\n+//\n+//\tpattern:\n+//\t\t{ term }\n+//\tterm:\n+//\t\t'*'         matches any sequence of non-/ characters\n+//\t\t'?'         matches any single non-/ character\n+//\t\t'[' [ '^' ] { character-range } ']'\n+//\t\t            character class (must be non-empty)\n+//\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n+//\t\t'\\\\' c      matches character c\n+//\n+//\tcharacter-range:\n+//\t\tc           matches character c (c != '\\\\', '-', ']')\n+//\t\t'\\\\' c      matches character c\n+//\t\tlo '-' hi   matches character c for lo <= c <= hi\n+//\n+// Match requires pattern to match all of name, not just a substring.\n+// The only possible returned error is ErrBadPattern, when pattern\n+// is malformed.\n+//\n+func match(pattern, name string) (matched bool, err error) {\n+Pattern:\n+\tfor len(pattern) > 0 {\n+\t\tvar star bool\n+\t\tvar chunk string\n+\t\tstar, chunk, pattern = scanChunk(pattern)\n+\t\tif star && chunk == \"\" {\n+\t\t\t// Trailing * matches everything\n+\t\t\treturn true, nil\n+\t\t}\n+\t\t// Look for match at current position.\n+\t\tt, ok, err := matchChunk(chunk, name)\n+\t\t// if we're the last chunk, make sure we've exhausted the name\n+\t\t// otherwise we'll give a false result even if we could still match\n+\t\t// using the star\n+\t\tif ok && (len(t) == 0 || len(pattern) > 0) {\n+\t\t\tname = t\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn false, err\n+\t\t}\n+\t\tif star {\n+\t\t\t// Look for match skipping i+1 bytes.\n+\t\t\tfor i := 0; i < len(name); i++ {\n+\t\t\t\tt, ok, err := matchChunk(chunk, name[i+1:])\n+\t\t\t\tif ok {\n+\t\t\t\t\t// if we're the last chunk, make sure we exhausted the name\n+\t\t\t\t\tif len(pattern) == 0 && len(t) > 0 {\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t\tname = t\n+\t\t\t\t\tcontinue Pattern\n+\t\t\t\t}\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn false, err\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t// Before returning false with no error,\n+\t\t// check that the remainder of the pattern is syntactically valid.\n+\t\tfor len(pattern) > 0 {\n+\t\t\t_, chunk, pattern = scanChunk(pattern)\n+\t\t\tif _, _, err := matchChunk(chunk, \"\"); err != nil {\n+\t\t\t\treturn false, err\n+\t\t\t}\n+\t\t}\n+\t\treturn false, nil\n+\t}\n+\treturn len(name) == 0, nil\n+}\n+\n+// scanChunk gets the next segment of pattern, which is a non-star string\n+// possibly preceded by a star.\n+func scanChunk(pattern string) (star bool, chunk, rest string) {\n+\tfor len(pattern) > 0 && pattern[0] == '*' {\n+\t\tpattern = pattern[1:]\n+\t\tstar = true\n+\t}\n+\tinrange := false\n+\tvar i int\n+Scan:\n+\tfor i = 0; i < len(pattern); i++ {\n+\t\tswitch pattern[i] {\n+\t\tcase '\\\\':\n+\t\t\t// error check handled in matchChunk: bad pattern.\n+\t\t\tif i+1 < len(pattern) {\n+\t\t\t\ti++\n+\t\t\t}\n+\t\tcase '[':\n+\t\t\tinrange = true\n+\t\tcase ']':\n+\t\t\tinrange = false\n+\t\tcase '*':\n+\t\t\tif !inrange {\n+\t\t\t\tbreak Scan\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn star, pattern[0:i], pattern[i:]\n+}\n+\n+// matchChunk checks whether chunk matches the beginning of s.\n+// If so, it returns the remainder of s (after the match).\n+// Chunk is all single-character operators: literals, char classes, and ?.\n+func matchChunk(chunk, s string) (rest string, ok bool, err error) {\n+\t// failed records whether the match has failed.\n+\t// After the match fails, the loop continues on processing chunk,\n+\t// checking that the pattern is well-formed but no longer reading s.\n+\tfailed := false\n+\tfor len(chunk) > 0 {\n+\t\tif !failed && len(s) == 0 {\n+\t\t\tfailed = true\n+\t\t}\n+\t\tswitch chunk[0] {\n+\t\tcase '[':\n+\t\t\t// character class\n+\t\t\tvar r rune\n+\t\t\tif !failed {\n+\t\t\t\tvar n int\n+\t\t\t\tr, n = utf8.DecodeRuneInString(s)\n+\t\t\t\ts = s[n:]\n+\t\t\t}\n+\t\t\tchunk = chunk[1:]\n+\t\t\t// possibly negated\n+\t\t\tnegated := false\n+\t\t\tif len(chunk) > 0 && chunk[0] == '^' {\n+\t\t\t\tnegated = true\n+\t\t\t\tchunk = chunk[1:]\n+\t\t\t}\n+\t\t\t// parse all ranges\n+\t\t\tmatch := false\n+\t\t\tnrange := 0\n+\t\t\tfor {\n+\t\t\t\tif len(chunk) > 0 && chunk[0] == ']' && nrange > 0 {\n+\t\t\t\t\tchunk = chunk[1:]\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tvar lo, hi rune\n+\t\t\t\tif lo, chunk, err = getEsc(chunk); err != nil {\n+\t\t\t\t\treturn \"\", false, err\n+\t\t\t\t}\n+\t\t\t\thi = lo\n+\t\t\t\tif chunk[0] == '-' {\n+\t\t\t\t\tif hi, chunk, err = getEsc(chunk[1:]); err != nil {\n+\t\t\t\t\t\treturn \"\", false, err\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif lo <= r && r <= hi {\n+\t\t\t\t\tmatch = true\n+\t\t\t\t}\n+\t\t\t\tnrange++\n+\t\t\t}\n+\t\t\tif match == negated {\n+\t\t\t\tfailed = true\n+\t\t\t}\n+\n+\t\tcase '?':\n+\t\t\tif !failed {\n+\t\t\t\t_, n := utf8.DecodeRuneInString(s)\n+\t\t\t\ts = s[n:]\n+\t\t\t}\n+\t\t\tchunk = chunk[1:]\n+\n+\t\tcase '\\\\':\n+\t\t\tchunk = chunk[1:]\n+\t\t\tif len(chunk) == 0 {\n+\t\t\t\treturn \"\", false, errBadPattern\n+\t\t\t}\n+\t\t\tfallthrough\n+\n+\t\tdefault:\n+\t\t\tif !failed {\n+\t\t\t\tif chunk[0] != s[0] {\n+\t\t\t\t\tfailed = true\n+\t\t\t\t}\n+\t\t\t\ts = s[1:]\n+\t\t\t}\n+\t\t\tchunk = chunk[1:]\n+\t\t}\n+\t}\n+\tif failed {\n+\t\treturn \"\", false, nil\n+\t}\n+\treturn s, true, nil\n+}\n+\n+// getEsc gets a possibly-escaped character from chunk, for a character class.\n+func getEsc(chunk string) (r rune, nchunk string, err error) {\n+\tif len(chunk) == 0 || chunk[0] == '-' || chunk[0] == ']' {\n+\t\terr = errBadPattern\n+\t\treturn\n+\t}\n+\tif chunk[0] == '\\\\' {\n+\t\tchunk = chunk[1:]\n+\t\tif len(chunk) == 0 {\n+\t\t\terr = errBadPattern\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tr, n := utf8.DecodeRuneInString(chunk)\n+\tif r == utf8.RuneError && n == 1 {\n+\t\terr = errBadPattern\n+\t}\n+\tnchunk = chunk[n:]\n+\tif len(nchunk) == 0 {\n+\t\terr = errBadPattern\n+\t}\n+\treturn\n+}"
        },
        {
          "filename": "in_toto/match_test.go",
          "status": "added",
          "additions": 85,
          "deletions": 0,
          "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found at https://golang.org/LICENSE.\n+\n+// this is a modified version of path.Match that removes handling of path separators\n+\n+package in_toto\n+\n+import \"testing\"\n+\n+type MatchTest struct {\n+\tpattern, s string\n+\tmatch      bool\n+\terr        error\n+}\n+\n+var matchTests = []MatchTest{\n+\t{\"*\", \"foo/bar\", true, nil},\n+\t{\"abc\", \"abc\", true, nil},\n+\t{\"*\", \"abc\", true, nil},\n+\t{\"*c\", \"abc\", true, nil},\n+\t{\"a*\", \"a\", true, nil},\n+\t{\"a*\", \"abc\", true, nil},\n+\t{\"a*\", \"ab/c\", true, nil},\n+\t{\"a*/b\", \"abc/b\", true, nil},\n+\t{\"a*/b\", \"a/c/b\", true, nil},\n+\t{\"a*b*c*d*e*/f\", \"axbxcxdxe/f\", true, nil},\n+\t{\"a*b*c*d*e*/f\", \"axbxcxdxexxx/f\", true, nil},\n+\t{\"a*b*c*d*e*/f\", \"axbxcxdxe/xxx/f\", true, nil},\n+\t{\"a*b*c*d*e*/f\", \"axbxcxdxexxx/fff\", false, nil},\n+\t{\"a*b?c*x\", \"abxbbxdbxebxczzx\", true, nil},\n+\t{\"a*b?c*x\", \"abxbbxdbxebxczzy\", false, nil},\n+\t{\"ab[c]\", \"abc\", true, nil},\n+\t{\"ab[b-d]\", \"abc\", true, nil},\n+\t{\"ab[e-g]\", \"abc\", false, nil},\n+\t{\"ab[^c]\", \"abc\", false, nil},\n+\t{\"ab[^b-d]\", \"abc\", false, nil},\n+\t{\"ab[^e-g]\", \"abc\", true, nil},\n+\t{\"a\\\\*b\", \"a*b\", true, nil},\n+\t{\"a\\\\*b\", \"ab\", false, nil},\n+\t{\"a?b\", \"a\u263ab\", true, nil},\n+\t{\"a[^a]b\", \"a\u263ab\", true, nil},\n+\t{\"a???b\", \"a\u263ab\", false, nil},\n+\t{\"a[^a][^a][^a]b\", \"a\u263ab\", false, nil},\n+\t{\"[a-\u03b6]*\", \"\u03b1\", true, nil},\n+\t{\"*[a-\u03b6]\", \"A\", false, nil},\n+\t{\"a?b\", \"a/b\", true, nil},\n+\t{\"a*b\", \"a/b\", true, nil},\n+\t{\"[\\\\]a]\", \"]\", true, nil},\n+\t{\"[\\\\-]\", \"-\", true, nil},\n+\t{\"[x\\\\-]\", \"x\", true, nil},\n+\t{\"[x\\\\-]\", \"-\", true, nil},\n+\t{\"[x\\\\-]\", \"z\", false, nil},\n+\t{\"[\\\\-x]\", \"x\", true, nil},\n+\t{\"[\\\\-x]\", \"-\", true, nil},\n+\t{\"[\\\\-x]\", \"a\", false, nil},\n+\t{\"[]a]\", \"]\", false, errBadPattern},\n+\t{\"[-]\", \"-\", false, errBadPattern},\n+\t{\"[x-]\", \"x\", false, errBadPattern},\n+\t{\"[x-]\", \"-\", false, errBadPattern},\n+\t{\"[x-]\", \"z\", false, errBadPattern},\n+\t{\"[-x]\", \"x\", false, errBadPattern},\n+\t{\"[-x]\", \"-\", false, errBadPattern},\n+\t{\"[-x]\", \"a\", false, errBadPattern},\n+\t{\"\\\\\", \"a\", false, errBadPattern},\n+\t{\"[a-b-c]\", \"a\", false, errBadPattern},\n+\t{\"[\", \"a\", false, errBadPattern},\n+\t{\"[^\", \"a\", false, errBadPattern},\n+\t{\"[^bc\", \"a\", false, errBadPattern},\n+\t{\"a[\", \"a\", false, errBadPattern},\n+\t{\"a[\", \"ab\", false, errBadPattern},\n+\t{\"a[\", \"x\", false, errBadPattern},\n+\t{\"a/b[\", \"x\", false, errBadPattern},\n+\t{\"a[\\\\\", \"x\", false, errBadPattern},\n+\t{\"*x\", \"xxx\", true, nil},\n+}\n+\n+func TestMatch(t *testing.T) {\n+\tfor _, tt := range matchTests {\n+\t\tok, err := match(tt.pattern, tt.s)\n+\t\tif ok != tt.match || err != tt.err {\n+\t\t\tt.Errorf(\"Match(%#q, %#q) = %v, %v want %v, %v\", tt.pattern, tt.s, ok, err, tt.match, tt.err)\n+\t\t}\n+\t}\n+}"
        },
        {
          "filename": "in_toto/util.go",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -2,7 +2,6 @@ package in_toto\n \n import (\n \t\"fmt\"\n-\t\"path/filepath\"\n )\n \n /*\n@@ -89,7 +88,7 @@ non-match plus a warning is printed.\n func (s Set) Filter(pattern string) Set {\n \tres := NewSet()\n \tfor elem := range s {\n-\t\tmatched, err := filepath.Match(pattern, elem)\n+\t\tmatched, err := match(pattern, elem)\n \t\tif err != nil {\n \t\t\tfmt.Printf(\"WARNING: %s, pattern was '%s'\\n\", err, pattern)\n \t\t\tcontinue"
        },
        {
          "filename": "in_toto/verifylib.go",
          "status": "modified",
          "additions": 34,
          "deletions": 9,
          "patch": "@@ -11,6 +11,7 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n+\t\"path\"\n \tosPath \"path\"\n \t\"path/filepath\"\n \t\"reflect\"\n@@ -94,17 +95,35 @@ func verifyMatchRule(ruleData map[string]string,\n \tswitch ruleData[\"dstType\"] {\n \tcase \"materials\":\n \t\tdstArtifacts = dstLinkMb.Signed.(Link).Materials\n-\n \tcase \"products\":\n \t\tdstArtifacts = dstLinkMb.Signed.(Link).Products\n \t}\n \n+\t// cleanup paths in pattern and artifact maps\n+\tif ruleData[\"pattern\"] != \"\" {\n+\t\truleData[\"pattern\"] = path.Clean(ruleData[\"pattern\"])\n+\t}\n+\tfor k := range srcArtifacts {\n+\t\tif path.Clean(k) != k {\n+\t\t\tsrcArtifacts[path.Clean(k)] = srcArtifacts[k]\n+\t\t\tdelete(srcArtifacts, k)\n+\t\t}\n+\t}\n+\tfor k := range dstArtifacts {\n+\t\tif path.Clean(k) != k {\n+\t\t\tdstArtifacts[path.Clean(k)] = dstArtifacts[k]\n+\t\t\tdelete(dstArtifacts, k)\n+\t\t}\n+\t}\n+\n \t// Normalize optional source and destination prefixes, i.e. if\n \t// there is a prefix, then add a trailing slash if not there yet\n \tfor _, prefix := range []string{\"srcPrefix\", \"dstPrefix\"} {\n-\t\tif ruleData[prefix] != \"\" &&\n-\t\t\t!strings.HasSuffix(ruleData[prefix], \"/\") {\n-\t\t\truleData[prefix] += \"/\"\n+\t\tif ruleData[prefix] != \"\" {\n+\t\t\truleData[prefix] = path.Clean(ruleData[prefix])\n+\t\t\tif !strings.HasSuffix(ruleData[prefix], \"/\") {\n+\t\t\t\truleData[prefix] += \"/\"\n+\t\t\t}\n \t\t}\n \t}\n \t// Iterate over queue and mark consumed artifacts\n@@ -114,14 +133,14 @@ func verifyMatchRule(ruleData map[string]string,\n \t\tsrcBasePath := strings.TrimPrefix(srcPath, ruleData[\"srcPrefix\"])\n \n \t\t// Ignore artifacts not matched by rule pattern\n-\t\tmatched, err := filepath.Match(ruleData[\"pattern\"], srcBasePath)\n+\t\tmatched, err := match(ruleData[\"pattern\"], srcBasePath)\n \t\tif err != nil || !matched {\n \t\t\tcontinue\n \t\t}\n \n \t\t// Construct corresponding destination artifact path, i.e.\n \t\t// an optional destination prefix plus the source base path\n-\t\tdstPath := osPath.Join(ruleData[\"dstPrefix\"], srcBasePath)\n+\t\tdstPath := path.Clean(osPath.Join(ruleData[\"dstPrefix\"], srcBasePath))\n \n \t\t// Try to find the corresponding destination artifact\n \t\tdstArtifact, exists := dstArtifacts[dstPath]\n@@ -202,8 +221,14 @@ func VerifyArtifacts(items []interface{},\n \t\t// All other rules only require the material or product paths (without\n \t\t// hashes). We extract them from the corresponding maps and store them as\n \t\t// sets for convenience in further processing\n-\t\tmaterialPaths := NewSet(InterfaceKeyStrings(materials)...)\n-\t\tproductPaths := NewSet(InterfaceKeyStrings(products)...)\n+\t\tmaterialPaths := NewSet()\n+\t\tfor _, p := range InterfaceKeyStrings(materials) {\n+\t\t\tmaterialPaths.Add(path.Clean(p))\n+\t\t}\n+\t\tproductPaths := NewSet()\n+\t\tfor _, p := range InterfaceKeyStrings(products) {\n+\t\t\tproductPaths.Add(path.Clean(p))\n+\t\t}\n \n \t\t// For `create`, `delete` and `modify` rules we prepare sets of artifacts\n \t\t// (without hashes) that were created, deleted or modified in the current\n@@ -269,7 +294,7 @@ func VerifyArtifacts(items []interface{},\n \n \t\t\t\t// Apply rule pattern to filter queued artifacts that are up for rule\n \t\t\t\t// specific consumption\n-\t\t\t\tfiltered := queue.Filter(ruleData[\"pattern\"])\n+\t\t\t\tfiltered := queue.Filter(path.Clean(ruleData[\"pattern\"]))\n \n \t\t\t\tvar consumed Set\n \t\t\t\tswitch ruleData[\"type\"] {"
        },
        {
          "filename": "in_toto/verifylib_test.go",
          "status": "modified",
          "additions": 334,
          "deletions": 170,
          "patch": "@@ -253,191 +253,355 @@ func TestRunInspections(t *testing.T) {\n \t}\n }\n \n-func TestVerifyArtifacts(t *testing.T) {\n-\titems := []interface{}{\n-\t\tStep{\n-\t\t\tSupplyChainItem: SupplyChainItem{\n-\t\t\t\tName: \"foo\",\n-\t\t\t\tExpectedMaterials: [][]string{\n-\t\t\t\t\t{\"DELETE\", \"foo-delete\"},\n-\t\t\t\t\t{\"MODIFY\", \"foo-modify\"},\n-\t\t\t\t\t{\"MATCH\", \"foo-match\", \"WITH\", \"MATERIALS\", \"FROM\", \"foo\"}, // not-modify\n-\t\t\t\t\t{\"ALLOW\", \"foo-allow\"},\n-\t\t\t\t\t{\"DISALLOW\", \"*\"},\n+func TestVerifyArtifact(t *testing.T) {\n+\tvar testCases = []struct {\n+\t\tname      string\n+\t\titem      []interface{}\n+\t\tmetadata  map[string]Metablock\n+\t\texpectErr string\n+\t}{\n+\t\t{\n+\t\t\tname: \"Verify artifacts\",\n+\t\t\titem: []interface{}{\n+\t\t\t\tStep{\n+\t\t\t\t\tSupplyChainItem: SupplyChainItem{\n+\t\t\t\t\t\tName: \"foo\",\n+\t\t\t\t\t\tExpectedMaterials: [][]string{\n+\t\t\t\t\t\t\t{\"DELETE\", \"foo-delete\"},\n+\t\t\t\t\t\t\t{\"MODIFY\", \"foo-modify\"},\n+\t\t\t\t\t\t\t{\"MATCH\", \"foo-match\", \"WITH\", \"MATERIALS\", \"FROM\", \"foo\"}, // not-modify\n+\t\t\t\t\t\t\t{\"ALLOW\", \"foo-allow\"},\n+\t\t\t\t\t\t\t{\"DISALLOW\", \"*\"},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tExpectedProducts: [][]string{\n+\t\t\t\t\t\t\t{\"CREATE\", \"foo-create\"},\n+\t\t\t\t\t\t\t{\"MODIFY\", \"foo-modify\"},\n+\t\t\t\t\t\t\t{\"MATCH\", \"foo-match\", \"WITH\", \"MATERIALS\", \"FROM\", \"foo\"}, // not-modify\n+\t\t\t\t\t\t\t{\"REQUIRE\", \"foo-allow\"},\n+\t\t\t\t\t\t\t{\"ALLOW\", \"foo-allow\"},\n+\t\t\t\t\t\t\t{\"DISALLOW\", \"*\"},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n \t\t\t\t},\n-\t\t\t\tExpectedProducts: [][]string{\n-\t\t\t\t\t{\"CREATE\", \"foo-create\"},\n-\t\t\t\t\t{\"MODIFY\", \"foo-modify\"},\n-\t\t\t\t\t{\"MATCH\", \"foo-match\", \"WITH\", \"MATERIALS\", \"FROM\", \"foo\"}, // not-modify\n-\t\t\t\t\t{\"REQUIRE\", \"foo-allow\"},\n-\t\t\t\t\t{\"ALLOW\", \"foo-allow\"},\n-\t\t\t\t\t{\"DISALLOW\", \"*\"},\n+\t\t\t},\n+\t\t\tmetadata: map[string]Metablock{\n+\t\t\t\t\"foo\": {\n+\t\t\t\t\tSigned: Link{\n+\t\t\t\t\t\tName: \"foo\",\n+\t\t\t\t\t\tMaterials: map[string]interface{}{\n+\t\t\t\t\t\t\t\"foo-delete\": map[string]interface{}{\"sha265\": \"abc\"},\n+\t\t\t\t\t\t\t\"foo-modify\": map[string]interface{}{\"sha265\": \"abc\"},\n+\t\t\t\t\t\t\t\"foo-match\":  map[string]interface{}{\"sha265\": \"abc\"},\n+\t\t\t\t\t\t\t\"foo-allow\":  map[string]interface{}{\"sha265\": \"abc\"},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tProducts: map[string]interface{}{\n+\t\t\t\t\t\t\t\"foo-create\": map[string]interface{}{\"sha265\": \"abc\"},\n+\t\t\t\t\t\t\t\"foo-modify\": map[string]interface{}{\"sha265\": \"abcdef\"},\n+\t\t\t\t\t\t\t\"foo-match\":  map[string]interface{}{\"sha265\": \"abc\"},\n+\t\t\t\t\t\t\t\"foo-allow\":  map[string]interface{}{\"sha265\": \"abc\"},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n \t\t\t\t},\n \t\t\t},\n+\t\t\texpectErr: \"\",\n \t\t},\n-\t}\n-\n-\titemsMetadata := map[string]Metablock{\n-\t\t\"foo\": {\n-\t\t\tSigned: Link{\n-\t\t\t\tName: \"foo\",\n-\t\t\t\tMaterials: map[string]interface{}{\n-\t\t\t\t\t\"foo-delete\": map[string]interface{}{\"sha265\": \"abc\"},\n-\t\t\t\t\t\"foo-modify\": map[string]interface{}{\"sha265\": \"abc\"},\n-\t\t\t\t\t\"foo-match\":  map[string]interface{}{\"sha265\": \"abc\"},\n-\t\t\t\t\t\"foo-allow\":  map[string]interface{}{\"sha265\": \"abc\"},\n+\t\t{\n+\t\t\tname: \"Verify match with relative paths\",\n+\t\t\titem: []interface{}{\n+\t\t\t\tStep{\n+\t\t\t\t\tSupplyChainItem: SupplyChainItem{\n+\t\t\t\t\t\tName: \"foo\",\n+\t\t\t\t\t\tExpectedMaterials: [][]string{\n+\t\t\t\t\t\t\t{\"MATCH\", \"*\", \"WITH\", \"PRODUCTS\", \"FROM\", \"bar\"},\n+\t\t\t\t\t\t\t{\"DISALLOW\", \"*\"},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tmetadata: map[string]Metablock{\n+\t\t\t\t\"foo\": {\n+\t\t\t\t\tSigned: Link{\n+\t\t\t\t\t\tName: \"foo\",\n+\t\t\t\t\t\tMaterials: map[string]interface{}{\n+\t\t\t\t\t\t\t\"./foo.d/foo.py\": map[string]interface{}{\"sha265\": \"abc\"},\n+\t\t\t\t\t\t\t\"bar.d/bar.py\":   map[string]interface{}{\"sha265\": \"abc\"},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\t\"bar\": {\n+\t\t\t\t\tSigned: Link{\n+\t\t\t\t\t\tName: \"bar\",\n+\t\t\t\t\t\tProducts: map[string]interface{}{\n+\t\t\t\t\t\t\t\"foo.d/foo.py\":          map[string]interface{}{\"sha265\": \"abc\"},\n+\t\t\t\t\t\t\t\"./baz/../bar.d/bar.py\": map[string]interface{}{\"sha265\": \"abc\"},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectErr: \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Verify match detection of hash mismatch\",\n+\t\t\titem: []interface{}{\n+\t\t\t\tStep{\n+\t\t\t\t\tSupplyChainItem: SupplyChainItem{\n+\t\t\t\t\t\tName: \"foo\",\n+\t\t\t\t\t\tExpectedMaterials: [][]string{\n+\t\t\t\t\t\t\t{\"MATCH\", \"*\", \"WITH\", \"PRODUCTS\", \"FROM\", \"bar\"},\n+\t\t\t\t\t\t\t{\"DISALLOW\", \"*\"},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tmetadata: map[string]Metablock{\n+\t\t\t\t\"foo\": {\n+\t\t\t\t\tSigned: Link{\n+\t\t\t\t\t\tName: \"foo\",\n+\t\t\t\t\t\tMaterials: map[string]interface{}{\n+\t\t\t\t\t\t\t\"foo.d/foo.py\": map[string]interface{}{\"sha265\": \"abc\"},\n+\t\t\t\t\t\t\t\"bar.d/bar.py\": map[string]interface{}{\"sha265\": \"def\"}, // modified by mitm\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n \t\t\t\t},\n-\t\t\t\tProducts: map[string]interface{}{\n-\t\t\t\t\t\"foo-create\": map[string]interface{}{\"sha265\": \"abc\"},\n-\t\t\t\t\t\"foo-modify\": map[string]interface{}{\"sha265\": \"abcdef\"},\n-\t\t\t\t\t\"foo-match\":  map[string]interface{}{\"sha265\": \"abc\"},\n-\t\t\t\t\t\"foo-allow\":  map[string]interface{}{\"sha265\": \"abc\"},\n+\t\t\t\t\"bar\": {\n+\t\t\t\t\tSigned: Link{\n+\t\t\t\t\t\tName: \"bar\",\n+\t\t\t\t\t\tProducts: map[string]interface{}{\n+\t\t\t\t\t\t\t\"foo.d/foo.py\": map[string]interface{}{\"sha265\": \"abc\"},\n+\t\t\t\t\t\t\t\"bar.d/bar.py\": map[string]interface{}{\"sha265\": \"abc\"},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n \t\t\t\t},\n \t\t\t},\n+\t\t\texpectErr: \"materials [bar.d/bar.py] disallowed by rule\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Item must be one of step or inspection\",\n+\t\t\titem:      []interface{}{nil},\n+\t\t\tmetadata:  map[string]Metablock{},\n+\t\t\texpectErr: \"item of invalid type\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Can't find link metadata for step\",\n+\t\t\titem:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\"}}},\n+\t\t\tmetadata:  map[string]Metablock{},\n+\t\t\texpectErr: \"could not find metadata\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Can't find link metadata for inspection\",\n+\t\t\titem:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\"}}},\n+\t\t\tmetadata:  map[string]Metablock{},\n+\t\t\texpectErr: \"could not find metadata\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Wrong step expected material\",\n+\t\t\titem:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedMaterials: [][]string{{\"INVALID\", \"rule\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\"}}},\n+\t\t\texpectErr: \"rule format\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Wrong step expected product\",\n+\t\t\titem:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedProducts: [][]string{{\"INVALID\", \"rule\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\"}}},\n+\t\t\texpectErr: \"rule format\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Wrong inspection expected material\",\n+\t\t\titem:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedMaterials: [][]string{{\"INVALID\", \"rule\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\"}}},\n+\t\t\texpectErr: \"rule format\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Wrong inspection expected product\",\n+\t\t\titem:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedProducts: [][]string{{\"INVALID\", \"rule\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\"}}},\n+\t\t\texpectErr: \"rule format\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Disallowed material in step\",\n+\t\t\titem:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedMaterials: [][]string{{\"DISALLOW\", \"*\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectErr: \"materials [foo.py] disallowed by rule\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Disallowed product in step\",\n+\t\t\titem:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedProducts: [][]string{{\"DISALLOW\", \"*\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Products: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectErr: \"products [foo.py] disallowed by rule\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Disallowed material in inspection\",\n+\t\t\titem:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedMaterials: [][]string{{\"DISALLOW\", \"*\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectErr: \"materials [foo.py] disallowed by rule\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Disallowed product in inspection\",\n+\t\t\titem:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedProducts: [][]string{{\"DISALLOW\", \"*\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Products: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectErr: \"products [foo.py] disallowed by rule\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Required but missing material in step\",\n+\t\t\titem:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedMaterials: [][]string{{\"REQUIRE\", \"foo\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectErr: \"materials in REQUIRE 'foo'\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Required but missing product in step\",\n+\t\t\titem:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedProducts: [][]string{{\"REQUIRE\", \"foo\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Products: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectErr: \"products in REQUIRE 'foo'\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Required but missing material in inspection\",\n+\t\t\titem:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedMaterials: [][]string{{\"REQUIRE\", \"foo\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectErr: \"materials in REQUIRE 'foo'\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Required but missing product in inspection\",\n+\t\t\titem:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedProducts: [][]string{{\"REQUIRE\", \"foo\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Products: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectErr: \"products in REQUIRE 'foo'\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Disallowed subdirectory material in step\",\n+\t\t\titem:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedMaterials: [][]string{{\"DISALLOW\", \"*\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"dir/foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectErr: \"materials [dir/foo.py] disallowed by rule\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Disallowed subdirectory product in step\",\n+\t\t\titem:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedProducts: [][]string{{\"DISALLOW\", \"*\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Products: map[string]interface{}{\"dir/foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectErr: \"products [dir/foo.py] disallowed by rule\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Disallowed subdirectory material in inspection\",\n+\t\t\titem:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedMaterials: [][]string{{\"DISALLOW\", \"*\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"dir/foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectErr: \"materials [dir/foo.py] disallowed by rule\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Disallowed subdirectory product in inspection\",\n+\t\t\titem:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedProducts: [][]string{{\"DISALLOW\", \"*\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Products: map[string]interface{}{\"dir/foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectErr: \"products [dir/foo.py] disallowed by rule\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Consuming filename material in step\",\n+\t\t\titem:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedMaterials: [][]string{{\"ALLOW\", \"foo.py\"}, {\"DISALLOW\", \"*\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"./bar/..//foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectErr: \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Consuming filename product in step\",\n+\t\t\titem:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedProducts: [][]string{{\"ALLOW\", \"foo.py\"}, {\"DISALLOW\", \"*\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Products: map[string]interface{}{\"./bar/..//foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectErr: \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Consuming filename material in inspection\",\n+\t\t\titem:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedMaterials: [][]string{{\"ALLOW\", \"foo.py\"}, {\"DISALLOW\", \"*\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"./bar/..//foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectErr: \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Consuming filename product in inspection\",\n+\t\t\titem:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedProducts: [][]string{{\"ALLOW\", \"foo.py\"}, {\"DISALLOW\", \"*\"}}}}},\n+\t\t\tmetadata:  map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Products: map[string]interface{}{\"./bar/..//foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectErr: \"\",\n \t\t},\n \t}\n \n-\terr := VerifyArtifacts(items, itemsMetadata)\n-\tif err != nil {\n-\t\tt.Errorf(\"VerifyArtifacts returned '%s', expected no error\", err)\n+\tfor _, tt := range testCases {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\terr := VerifyArtifacts(tt.item, tt.metadata)\n+\t\t\tif (err == nil && tt.expectErr != \"\") ||\n+\t\t\t\t(err != nil && tt.expectErr == \"\") ||\n+\t\t\t\t(err != nil && !strings.Contains(err.Error(), tt.expectErr)) {\n+\t\t\t\tt.Errorf(\"VerifyArtifacts returned '%s', expected '%s' error\",\n+\t\t\t\t\terr, tt.expectErr)\n+\t\t\t}\n+\t\t})\n \t}\n }\n \n-func TestVerifyArtifactErrors(t *testing.T) {\n-\t// Test error cases for combinations of Step and Inspection items and\n-\t// material and product rules:\n-\t// - Item must be one of step or inspection\n-\t// - Can't find link metadata for step\n-\t// - Can't find link metadata for inspection\n-\t// - Wrong step expected material\n-\t// - Wrong step expected product\n-\t// - Wrong inspection expected material\n-\t// - Wrong inspection expected product\n-\t// - Disallowed material in step\n-\t// - Disallowed product in step\n-\t// - Disallowed material in inspection\n-\t// - Disallowed product in inspection\n-\t// - Required but missing material in step\n-\t// - Required but missing product in step\n-\t// - Required but missing material in inspection\n-\t// - Required but missing product in inspection\n-\titems := [][]interface{}{\n-\t\t{nil},\n-\t\t{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\"}}},\n-\t\t{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\"}}},\n-\t\t{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedMaterials: [][]string{{\"INVALID\", \"rule\"}}}}},\n-\t\t{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedProducts: [][]string{{\"INVALID\", \"rule\"}}}}},\n-\t\t{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedMaterials: [][]string{{\"INVALID\", \"rule\"}}}}},\n-\t\t{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedProducts: [][]string{{\"INVALID\", \"rule\"}}}}},\n-\t\t{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedMaterials: [][]string{{\"DISALLOW\", \"*\"}}}}},\n-\t\t{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedProducts: [][]string{{\"DISALLOW\", \"*\"}}}}},\n-\t\t{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedMaterials: [][]string{{\"DISALLOW\", \"*\"}}}}},\n-\t\t{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedProducts: [][]string{{\"DISALLOW\", \"*\"}}}}},\n-\t\t{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedMaterials: [][]string{{\"REQUIRE\", \"foo\"}}}}},\n-\t\t{Step{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedProducts: [][]string{{\"REQUIRE\", \"foo\"}}}}},\n-\t\t{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedMaterials: [][]string{{\"REQUIRE\", \"foo\"}}}}},\n-\t\t{Inspection{SupplyChainItem: SupplyChainItem{Name: \"foo\", ExpectedProducts: [][]string{{\"REQUIRE\", \"foo\"}}}}},\n-\t}\n-\titemsMetadata := []map[string]Metablock{\n-\t\t{},\n-\t\t{},\n-\t\t{},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\"}}},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\"}}},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\"}}},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\"}}},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\", Products: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\", Products: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\", Products: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\", Products: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n-\t}\n-\terrorPart := []string{\n-\t\t\"item of invalid type\",\n-\t\t\"could not find metadata\",\n-\t\t\"could not find metadata\",\n-\t\t\"rule format\",\n-\t\t\"rule format\",\n-\t\t\"rule format\",\n-\t\t\"rule format\",\n-\t\t\"materials [foo.py] disallowed by rule\",\n-\t\t\"products [foo.py] disallowed by rule\",\n-\t\t\"materials [foo.py] disallowed by rule\",\n-\t\t\"products [foo.py] disallowed by rule\",\n-\t\t\"materials in REQUIRE 'foo'\",\n-\t\t\"products in REQUIRE 'foo'\",\n-\t\t\"materials in REQUIRE 'foo'\",\n-\t\t\"products in REQUIRE 'foo'\",\n-\t}\n-\n-\tfor i := 0; i < len(items); i++ {\n-\t\terr := VerifyArtifacts(items[i], itemsMetadata[i])\n-\t\tif err == nil || !strings.Contains(err.Error(), errorPart[i]) {\n-\t\t\tt.Errorf(\"VerifyArtifacts returned '%s', expected '%s' error\",\n-\t\t\t\terr, errorPart[i])\n-\t\t}\n+func TestVerifyMatchRule(t *testing.T) {\n+\tvar testCases = []struct {\n+\t\tname        string\n+\t\trule        map[string]string\n+\t\tsrcArtifact map[string]interface{}\n+\t\titem        map[string]Metablock\n+\t\texpectSet   Set\n+\t}{\n+\t\t{\n+\t\t\tname:        \"Can't find destination link (invalid rule)\",\n+\t\t\trule:        map[string]string{},\n+\t\t\tsrcArtifact: map[string]interface{}{},\n+\t\t\titem:        map[string]Metablock{},\n+\t\t\texpectSet:   NewSet(),\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"Can't find destination link (empty metadata map)\",\n+\t\t\trule:        map[string]string{\"pattern\": \"*\", \"dstName\": \"foo\", \"dstType\": \"materials\"},\n+\t\t\tsrcArtifact: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}},\n+\t\t\titem:        map[string]Metablock{},\n+\t\t\texpectSet:   NewSet(),\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"Match material foo.py\",\n+\t\t\trule:        map[string]string{\"pattern\": \"*\", \"dstName\": \"foo\", \"dstType\": \"materials\"},\n+\t\t\tsrcArtifact: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}},\n+\t\t\titem:        map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectSet:   NewSet(\"foo.py\"),\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"Match material foo.py with foo.d/foo.py\",\n+\t\t\trule:        map[string]string{\"pattern\": \"*\", \"dstName\": \"foo\", \"dstType\": \"materials\", \"dstPrefix\": \"foo.d\"},\n+\t\t\tsrcArtifact: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}},\n+\t\t\titem:        map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.d/foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectSet:   NewSet(\"foo.py\"),\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"Match material foo.d/foo.py with foo.py\",\n+\t\t\trule:        map[string]string{\"pattern\": \"*\", \"dstName\": \"foo\", \"dstType\": \"materials\", \"srcPrefix\": \"foo.d\"},\n+\t\t\tsrcArtifact: map[string]interface{}{\"foo.d/foo.py\": map[string]interface{}{\"sha265\": \"abc\"}},\n+\t\t\titem:        map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectSet:   NewSet(\"foo.d/foo.py\"),\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"Don't match material (different name)\",\n+\t\t\trule:        map[string]string{\"pattern\": \"*\", \"dstName\": \"foo\", \"dstType\": \"materials\"},\n+\t\t\tsrcArtifact: map[string]interface{}{\"bar.py\": map[string]interface{}{\"sha265\": \"abc\"}},\n+\t\t\titem:        map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectSet:   NewSet(),\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"Don't match material (different hash)\",\n+\t\t\trule:        map[string]string{\"pattern\": \"*\", \"dstName\": \"foo\", \"dstType\": \"materials\"},\n+\t\t\tsrcArtifact: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"dead\"}},\n+\t\t\titem:        map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectSet:   NewSet(),\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"Match material in sub-directories dir/foo.py\",\n+\t\t\trule:        map[string]string{\"pattern\": \"*\", \"dstName\": \"foo\", \"dstType\": \"materials\"},\n+\t\t\tsrcArtifact: map[string]interface{}{\"bar/foo.py\": map[string]interface{}{\"sha265\": \"abc\"}},\n+\t\t\titem:        map[string]Metablock{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"bar/foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n+\t\t\texpectSet:   NewSet(\"bar/foo.py\"),\n+\t\t},\n \t}\n-}\n \n-func TestVerifyMatchRule(t *testing.T) {\n-\t// Test MatchRule queue processing:\n-\t// - Can't find destination link (invalid rule) -> queue unmodified (empty)\n-\t// - Can't find destination link (empty metadata map) -> queue unmodified\n-\t// - Match material foo.py -> remove from queue\n-\t// - Match material foo.py with foo.d/foo.py -> remove from queue\n-\t// - Match material foo.d/foo.py with foo.py -> remove from queue\n-\t// - Don't match material (different name) -> queue unmodified\n-\t// - Don't match material (different hash) -> queue unmodified\n-\truleData := []map[string]string{\n-\t\t{},\n-\t\t{\"pattern\": \"*\", \"dstName\": \"foo\", \"dstType\": \"materials\"},\n-\t\t{\"pattern\": \"*\", \"dstName\": \"foo\", \"dstType\": \"materials\"},\n-\t\t{\"pattern\": \"*\", \"dstName\": \"foo\", \"dstType\": \"materials\", \"dstPrefix\": \"foo.d\"},\n-\t\t{\"pattern\": \"*\", \"dstName\": \"foo\", \"dstType\": \"materials\", \"srcPrefix\": \"foo.d\"},\n-\t\t{\"pattern\": \"*\", \"dstName\": \"foo\", \"dstType\": \"materials\"},\n-\t\t{\"pattern\": \"*\", \"dstName\": \"foo\", \"dstType\": \"materials\"},\n-\t}\n-\tsrcArtifacts := []map[string]interface{}{\n-\t\t{},\n-\t\t{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}},\n-\t\t{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}},\n-\t\t{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}},\n-\t\t{\"foo.d/foo.py\": map[string]interface{}{\"sha265\": \"abc\"}},\n-\t\t{\"foo.py\": map[string]interface{}{\"sha265\": \"dead\"}},\n-\t\t{\"bar.py\": map[string]interface{}{\"sha265\": \"abc\"}},\n-\t}\n-\t// queue[i] = InterfaceKeyStrings(srcArtifacts[i])\n-\titemsMetadata := []map[string]Metablock{\n-\t\t{},\n-\t\t{},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.d/foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n-\t\t{\"foo\": {Signed: Link{Name: \"foo\", Materials: map[string]interface{}{\"foo.py\": map[string]interface{}{\"sha265\": \"abc\"}}}}},\n-\t}\n-\texpected := []Set{\n-\t\tNewSet(),\n-\t\tNewSet(),\n-\t\tNewSet(\"foo.py\"),\n-\t\tNewSet(\"foo.py\"),\n-\t\tNewSet(\"foo.d/foo.py\"),\n-\t\tNewSet(),\n-\t\tNewSet(),\n-\t}\n-\n-\tfor i := 0; i < len(ruleData); i++ {\n-\n-\t\tqueue := NewSet(InterfaceKeyStrings(srcArtifacts[i])...)\n-\t\tresult := verifyMatchRule(ruleData[i], srcArtifacts[i], queue,\n-\t\t\titemsMetadata[i])\n-\t\tif !reflect.DeepEqual(result, expected[i]) {\n-\t\t\tt.Errorf(\"verifyMatchRule returned '%s', expected '%s'\", result,\n-\t\t\t\texpected[i])\n-\t\t}\n+\tfor _, tt := range testCases {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tqueue := NewSet(InterfaceKeyStrings(tt.srcArtifact)...)\n+\t\t\tresult := verifyMatchRule(tt.rule, tt.srcArtifact, queue, tt.item)\n+\t\t\tif !reflect.DeepEqual(result, tt.expectSet) {\n+\t\t\t\tt.Errorf(\"verifyMatchRule returned '%s', expected '%s'\", result, tt.expectSet)\n+\t\t\t}\n+\t\t})\n \t}\n }\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "575002203bd543db4b9ab4723016e8fe21627c49",
            "date": "2025-01-13T16:06:34Z",
            "author_login": "adityasaky"
          },
          {
            "sha": "3b64f12ba922b09684a6db1f9ac21fdd37463d84",
            "date": "2025-01-13T14:18:01Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "c9fba9a70836e4aae1d24391d11c26c481db9331",
            "date": "2025-01-06T16:29:08Z",
            "author_login": "adityasaky"
          },
          {
            "sha": "320dd2a06e2db96bedefa1d92111385a63d83770",
            "date": "2025-01-06T14:18:13Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "443bf72e2549aca182c5a1ed4f2d7f1a7a8ae0ee",
            "date": "2024-12-19T14:11:58Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.6,
    "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:C/C:N/I:H/A:N",
    "cwe_id": "CWE-345",
    "description": "in-toto-golang is a go implementation of the in-toto framework to protect software supply chain integrity. In affected versions authenticated attackers posing as functionaries (i.e., within a trusted set of users for a layout) are able to create attestations that may bypass DISALLOW rules in the same layout. An attacker with access to trusted private keys, may issue an attestation that contains a disallowed artifact by including path traversal semantics (e.g., foo vs dir/../foo). Exploiting this vulnerability is dependent on the specific policy applied. The problem has been fixed in version 0.3.0.",
    "attack_vector": "LOCAL",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2021-09-21T21:15:07.203",
    "last_modified": "2024-11-21T06:25:25.790",
    "fix_date": "2021-09-21T20:50:06Z"
  },
  "references": [
    {
      "url": "https://github.com/in-toto/in-toto-golang/commit/f2c57d1e0f15e3ffbeac531829c696b72ecc4290",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/in-toto/in-toto-golang/security/advisories/GHSA-vrxp-mg9f-hwf3",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/in-toto/in-toto-golang/commit/f2c57d1e0f15e3ffbeac531829c696b72ecc4290",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/in-toto/in-toto-golang/security/advisories/GHSA-vrxp-mg9f-hwf3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:07.782299",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "in-toto-golang",
    "owner": "in-toto",
    "created_at": "2018-10-15T15:18:06Z",
    "updated_at": "2025-01-13T16:06:39Z",
    "pushed_at": "2025-01-13T16:06:37Z",
    "size": 2400,
    "stars": 133,
    "forks": 51,
    "open_issues": 31,
    "watchers": 133,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Go": 407850,
      "Makefile": 7391,
      "Shell": 2214,
      "Dockerfile": 407
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:38:31.566754"
  }
}