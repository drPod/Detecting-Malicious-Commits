{
  "cve_id": "CVE-2021-41097",
  "github_data": {
    "repository": "aurelia/path",
    "fix_commit": "7c4e235433a4a2df9acc313fbe891758084fdec1",
    "related_commits": [
      "7c4e235433a4a2df9acc313fbe891758084fdec1",
      "7c4e235433a4a2df9acc313fbe891758084fdec1"
    ],
    "patch_url": "https://github.com/aurelia/path/commit/7c4e235433a4a2df9acc313fbe891758084fdec1.patch",
    "fix_commit_details": {
      "sha": "7c4e235433a4a2df9acc313fbe891758084fdec1",
      "commit_date": "2021-06-09T06:30:20Z",
      "author": {
        "login": "bigopon",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix: security issue gh closes #44",
        "length": 33,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 666,
        "additions": 351,
        "deletions": 315
      },
      "files": [
        {
          "filename": "src/index.ts",
          "status": "renamed",
          "additions": 7,
          "deletions": 4,
          "patch": "@@ -158,7 +158,7 @@ function buildParam(key: string, value: any, traditional?: boolean): Array<strin\n * @param traditional Boolean Use the old URI template standard (RFC6570)\n * @returns The generated query string, excluding leading '?'.\n */\n-export function buildQueryString(params: Object, traditional?: Boolean): string {\n+export function buildQueryString(params?: Object, traditional?: boolean): string {\n   let pairs = [];\n   let keys = Object.keys(params || {}).sort();\n   for (let i = 0, len = keys.length; i < len; i++) {\n@@ -203,16 +203,19 @@ function processScalarParam(existedParam: Object, value: Object): Object {\n * @param keys Collection of keys related to this parameter.\n * @param value Parameter value to append.\n */\n-function parseComplexParam(queryParams: Object, keys: Object, value: any): void {\n+function parseComplexParam(queryParams: Object, keys: (string | number)[], value: any): void {\n   let currentParams = queryParams;\n   let keysLastIndex = keys.length - 1;\n   for (let j = 0; j <= keysLastIndex; j++) {\n-    let key = keys[j] === '' ? currentParams.length : keys[j];\n+    let key = keys[j] === '' ? (currentParams as any).length : keys[j];\n+    if (key === '__proto__') {\n+      throw new Error('Prototype pollution detected.');\n+    }\n     if (j < keysLastIndex) {\n       // The value has to be an array or a false value\n       // It can happen that the value is no array if the key was repeated with traditional style like `list=1&list[]=2`\n       let prevValue = !currentParams[key] || typeof currentParams[key] === 'object' ? currentParams[key] : [currentParams[key]];\n-      currentParams = currentParams[key] = prevValue || (isNaN(keys[j + 1]) ? {} : []);\n+      currentParams = currentParams[key] = prevValue || (isNaN(keys[j + 1] as number) ? {} : []);\n     } else {\n       currentParams = currentParams[key] = value;\n     }"
        },
        {
          "filename": "test/path.spec.js",
          "status": "removed",
          "additions": 0,
          "deletions": 311,
          "patch": "@@ -1,311 +0,0 @@\n-import { relativeToFile, join, parseQueryString, buildQueryString } from '../src/index';\n-\n-describe('relativeToFile', () => {\n-  it('can make a dot path relative to a simple file', () => {\n-    var file = 'some/file.html';\n-    var path = './other/module';\n-\n-    expect(relativeToFile(path, file)).toBe('some/other/module');\n-  });\n-\n-  it('can make a dot path relative to an absolute file', () => {\n-    var file = 'http://durandal.io/some/file.html';\n-    var path = './other/module';\n-\n-    expect(relativeToFile(path, file)).toBe('http://durandal.io/some/other/module');\n-  });\n-\n-  it('can make a double dot path relative to an absolute file', () => {\n-    var file = 'http://durandal.io/some/file.html';\n-    var path = '../other/module';\n-\n-    expect(relativeToFile(path, file)).toBe('http://durandal.io/other/module');\n-  });\n-\n-  it('returns path if null file provided', () => {\n-    var file = null;\n-    var path = 'module';\n-\n-    expect(relativeToFile(path, file)).toBe('module');\n-  });\n-\n-  it('returns path if empty file provided', () => {\n-    var file = '';\n-    var path = 'module';\n-\n-    expect(relativeToFile(path, file)).toBe('module');\n-  });\n-});\n-\n-describe('join', () => {\n-  it('can combine two simple paths', () => {\n-    var path1 = 'one';\n-    var path2 = 'two';\n-\n-    expect(join(path1, path2)).toBe('one/two');\n-  });\n-\n-  it('can combine an absolute path and a simple path', () => {\n-    var path1 = '/one';\n-    var path2 = 'two';\n-\n-    expect(join(path1, path2)).toBe('/one/two');\n-  });\n-\n-  it('can combine an absolute path and a simple path with slash', () => {\n-    var path1 = '/one';\n-    var path2 = '/two';\n-\n-    expect(join(path1, path2)).toBe('/one/two');\n-  });\n-\n-  it('can combine a single slash and a simple path', () => {\n-    var path1 = '/';\n-    var path2 = 'two';\n-\n-    expect(join(path1, path2)).toBe('/two');\n-  });\n-\n-  it('can combine a single slash and a simple path with slash', () => {\n-    var path1 = '/';\n-    var path2 = '/two';\n-\n-    expect(join(path1, path2)).toBe('/two');\n-  });\n-\n-  it('can combine an absolute path with protocol and a simple path', () => {\n-    var path1 = 'http://durandal.io';\n-    var path2 = 'two';\n-\n-    expect(join(path1, path2)).toBe('http://durandal.io/two');\n-  });\n-\n-  it('can combine an absolute path with protocol and a simple path with slash', () => {\n-    var path1 = 'http://durandal.io';\n-    var path2 = '/two';\n-\n-    expect(join(path1, path2)).toBe('http://durandal.io/two');\n-  });\n-\n-  it('can combine an absolute path and a simple path with a dot', () => {\n-    var path1 = 'http://durandal.io';\n-    var path2 = './two';\n-\n-    expect(join(path1, path2)).toBe('http://durandal.io/two');\n-  });\n-\n-  it('can combine a simple path and a relative path', () => {\n-    var path1 = 'one';\n-    var path2 = '../two';\n-\n-    expect(join(path1, path2)).toBe('two');\n-  });\n-\n-  it('can combine an absolute path and a relative path', () => {\n-    var path1 = 'http://durandal.io/somewhere';\n-    var path2 = '../two';\n-\n-    expect(join(path1, path2)).toBe('http://durandal.io/two');\n-  });\n-\n-  it('can combine a protocol independent path and a simple path', () => {\n-    var path1 = '//durandal.io';\n-    var path2 = 'two';\n-\n-    expect(join(path1, path2)).toBe('//durandal.io/two');\n-  });\n-\n-  it('can combine a protocol independent path and a simple path with slash', () => {\n-    var path1 = '//durandal.io';\n-    var path2 = '/two';\n-\n-    expect(join(path1, path2)).toBe('//durandal.io/two');\n-  });\n-\n-  it('can combine a protocol independent path and a simple path with a dot', () => {\n-    var path1 = '//durandal.io';\n-    var path2 = './two';\n-\n-    expect(join(path1, path2)).toBe('//durandal.io/two');\n-  });\n-\n-  it('can combine a protocol independent path and a relative path', () => {\n-    var path1 = '//durandal.io/somewhere';\n-    var path2 = '../two';\n-\n-    expect(join(path1, path2)).toBe('//durandal.io/two');\n-  });\n-\n-  it('can combine a complex path and a relative path', () => {\n-    var path1 = 'one/three';\n-    var path2 = '../two';\n-\n-    expect(join(path1, path2)).toBe('one/two');\n-  });\n-\n-  it('returns path2 if path1 null', () => {\n-    var path1 = null;\n-    var path2 = 'two';\n-\n-    expect(join(path1, path2)).toBe('two');\n-  });\n-\n-  it('returns path2 if path1 empty', () => {\n-    var path1 = '';\n-    var path2 = 'two';\n-\n-    expect(join(path1, path2)).toBe('two');\n-  });\n-\n-  it('returns path1 if path2 null', () => {\n-    var path1 = 'one';\n-    var path2 = null;\n-\n-    expect(join(path1, path2)).toBe('one');\n-  });\n-\n-  it('returns path1 if path2 empty', () => {\n-    var path1 = 'one';\n-    var path2 = '';\n-\n-    expect(join(path1, path2)).toBe('one');\n-  });\n-\n-  it('should retain leading .. in path1', () => {\n-    var path1 = '../one';\n-    var path2 = './two';\n-\n-    expect(join(path1, path2)).toBe('../one/two');\n-  });\n-\n-  it('should retain consecutive leading .. in path1', () => {\n-    var path1 = '../../one';\n-    var path2 = './two';\n-\n-    expect(join(path1, path2)).toBe('../../one/two');\n-  });\n-\n-  it('should handle .. in path1 and path2', () => {\n-    var path1 = '../../one';\n-    var path2 = '../two';\n-\n-    expect(join(path1, path2)).toBe('../../two');\n-  });\n-\n-  it('should merge .. in path1 and path2', () => {\n-    var path1 = '../../one';\n-    var path2 = '../../two';\n-\n-    expect(join(path1, path2)).toBe('../../../two');\n-  });\n-\n-  it('should retain consecutive leading .. but not other .. in path1', () => {\n-    var path1 = '../../one/../three';\n-    var path2 = './two';\n-\n-    expect(join(path1, path2)).toBe('../../three/two');\n-  });\n-\n-  it('should respect a trailing slash', () => {\n-    var path1 = 'one/';\n-    var path2 = 'two/';\n-\n-    expect(join(path1, path2)).toBe('one/two/');\n-  });\n-\n-  it('should respect file:/// protocol with three slashes (empty host)', () => {\n-    var path1 = 'file:///one';\n-    var path2 = '/two';\n-\n-    expect(join(path1, path2)).toBe('file:///one/two');\n-  });\n-\n-  it('should respect file:// protocol with two slashes (host given)', () => {\n-    var path1 = 'file://localhost:8080';\n-    var path2 = '/two';\n-\n-    expect(join(path1, path2)).toBe('file://localhost:8080/two');\n-  });\n-\n-  it('should allow scheme-relative URL that uses colons in the path', () => {\n-    var path1 = '//localhost/one:/';\n-    var path2 = '/two';\n-\n-    expect(join(path1, path2)).toBe('//localhost/one:/two');\n-  });\n-\n-  it('should not add more than two leading slashes to http:// protocol', () => {\n-    var path1 = 'http:///';\n-    var path2 = '/two';\n-\n-    expect(join(path1, path2)).toBe('http://two');\n-  });\n-});\n-\n-describe('query strings', () => {\n-  it('should build query strings', () => {\n-    let gen = buildQueryString;\n-\n-    expect(gen()).toBe('');\n-    expect(gen(null)).toBe('');\n-    expect(gen({})).toBe('');\n-    expect(gen({ a: null })).toBe('');\n-\n-    expect(gen({ '': 'a' })).toBe('=a');\n-    expect(gen({ a: 'b' })).toBe('a=b');\n-    expect(gen({ a: 'b', c: 'd' })).toBe('a=b&c=d');\n-    expect(gen({ a: 'b', c: 'd' }, true)).toBe('a=b&c=d');\n-    expect(gen({ a: 'b', c: null })).toBe('a=b');\n-    expect(gen({ a: 'b', c: null }, true)).toBe('a=b');\n-\n-    expect(gen({ a: ['b', 'c'] })).toBe('a%5B%5D=b&a%5B%5D=c');\n-    expect(gen({ a: ['b', 'c'] }, true)).toBe('a=b&a=c');\n-    expect(gen({ '&': ['b', 'c'] })).toBe('%26%5B%5D=b&%26%5B%5D=c');\n-    expect(gen({ '&': ['b', 'c'] }, true)).toBe('%26=b&%26=c');\n-\n-    expect(gen({ a: '&' })).toBe('a=%26');\n-    expect(gen({ '&': 'a' })).toBe('%26=a');\n-    expect(gen({ a: true })).toBe('a=true');\n-    expect(gen({ '$test': true })).toBe('$test=true');\n-\n-    expect(gen({ obj: { a: 5, b: \"str\", c: false } })).toBe('obj%5Ba%5D=5&obj%5Bb%5D=str&obj%5Bc%5D=false');\n-    expect(gen({ obj: { a: 5, b: \"str\", c: false } }, true)).toBe('obj=%5Bobject%20Object%5D');\n-    expect(gen({ obj:{ a: 5, b: undefined}})).toBe('obj%5Ba%5D=5');\n-\n-    expect(gen({a: {b: ['c','d', ['f', 'g']]}})).toBe('a%5Bb%5D%5B%5D=c&a%5Bb%5D%5B%5D=d&a%5Bb%5D%5B2%5D%5B%5D=f&a%5Bb%5D%5B2%5D%5B%5D=g');\n-    expect(gen({a: {b: ['c','d', ['f', 'g']]}}, true)).toBe('a=%5Bobject%20Object%5D');\n-    expect(gen({a: ['c','d', ['f', 'g']]}, true)).toBe('a=c&a=d&a=f%2Cg');\n-    expect(gen({a: ['c','d', {f: 'g'}]}, true)).toBe('a=c&a=d&a=%5Bobject%20Object%5D');\n-  });\n-\n-  it('should parse query strings', () => {\n-    let parse = parseQueryString;\n-\n-    expect(parse('')).toEqual({});\n-    expect(parse('=')).toEqual({});\n-    expect(parse('&')).toEqual({});\n-    expect(parse('?')).toEqual({});\n-\n-    expect(parse('a')).toEqual({ a: true });\n-    expect(parse('a&b')).toEqual({ a: true, b: true });\n-    expect(parse('a=')).toEqual({ a: '' });\n-    expect(parse('a=&b=')).toEqual({ a: '', b: '' });\n-\n-    expect(parse('a=b')).toEqual({ a: 'b' });\n-    expect(parse('a=b&c=d')).toEqual({ a: 'b', c: 'd' });\n-    expect(parse('a=b&&c=d')).toEqual({ a: 'b', c: 'd' });\n-    expect(parse('a=b&a=c')).toEqual({ a: ['b', 'c'] });\n-\n-    expect(parse('a=b&c=d=')).toEqual({ a: 'b', c: 'd' });\n-    expect(parse('a=b&c=d==')).toEqual({ a: 'b', c: 'd' });\n-\n-    expect(parse('a=%26')).toEqual({ a: '&' });\n-    expect(parse('%26=a')).toEqual({ '&': 'a' });\n-    expect(parse('%26[]=b&%26[]=c')).toEqual({ '&': ['b', 'c'] });\n-\n-    expect(parse('a[b]=c&a[d]=e')).toEqual({a: {b: 'c', d: 'e'}});\n-    expect(parse('a[b][c][d]=e')).toEqual({a: {b: {c: {d: 'e'}}}});\n-    expect(parse('a[b][]=c&a[b][]=d&a[b][2][]=f&a[b][2][]=g')).toEqual({a: {b: ['c','d', ['f', 'g']]}});\n-    expect(parse('a[0]=b')).toEqual({a: ['b']});\n-  });\n-});"
        },
        {
          "filename": "test/path.spec.ts",
          "status": "added",
          "additions": 344,
          "deletions": 0,
          "patch": "@@ -0,0 +1,344 @@\n+import { relativeToFile, join, parseQueryString, buildQueryString } from '../src/index';\n+import assert from 'assert';\n+\n+const expect = (input: any) => {\n+  return {\n+    toBe: (output: any) => {\n+      assert.strictEqual(input, output);\n+    },\n+    toEqual: (output: any) => {\n+      assert.deepStrictEqual(input, output)\n+    }\n+  }\n+}\n+\n+describe('relativeToFile', () => {\n+  it('can make a dot path relative to a simple file', () => {\n+    const file = 'some/file.html';\n+    const path = './other/module';\n+\n+    expect(relativeToFile(path, file)).toBe('some/other/module');\n+  });\n+\n+  it('can make a dot path relative to an absolute file', () => {\n+    const file = 'http://durandal.io/some/file.html';\n+    const path = './other/module';\n+\n+    expect(relativeToFile(path, file)).toBe('http://durandal.io/some/other/module');\n+  });\n+\n+  it('can make a double dot path relative to an absolute file', () => {\n+    const file = 'http://durandal.io/some/file.html';\n+    const path = '../other/module';\n+\n+    expect(relativeToFile(path, file)).toBe('http://durandal.io/other/module');\n+  });\n+\n+  it('returns path if null file provided', () => {\n+    const file = null;\n+    const path = 'module';\n+\n+    expect(relativeToFile(path, file)).toBe('module');\n+  });\n+\n+  it('returns path if empty file provided', () => {\n+    const file = '';\n+    const path = 'module';\n+\n+    expect(relativeToFile(path, file)).toBe('module');\n+  });\n+});\n+\n+describe('join', () => {\n+  it('can combine two simple paths', () => {\n+    const path1 = 'one';\n+    const path2 = 'two';\n+\n+    expect(join(path1, path2)).toBe('one/two');\n+  });\n+\n+  it('can combine an absolute path and a simple path', () => {\n+    const path1 = '/one';\n+    const path2 = 'two';\n+\n+    expect(join(path1, path2)).toBe('/one/two');\n+  });\n+\n+  it('can combine an absolute path and a simple path with slash', () => {\n+    const path1 = '/one';\n+    const path2 = '/two';\n+\n+    expect(join(path1, path2)).toBe('/one/two');\n+  });\n+\n+  it('can combine a single slash and a simple path', () => {\n+    const path1 = '/';\n+    const path2 = 'two';\n+\n+    expect(join(path1, path2)).toBe('/two');\n+  });\n+\n+  it('can combine a single slash and a simple path with slash', () => {\n+    const path1 = '/';\n+    const path2 = '/two';\n+\n+    expect(join(path1, path2)).toBe('/two');\n+  });\n+\n+  it('can combine an absolute path with protocol and a simple path', () => {\n+    const path1 = 'http://durandal.io';\n+    const path2 = 'two';\n+\n+    expect(join(path1, path2)).toBe('http://durandal.io/two');\n+  });\n+\n+  it('can combine an absolute path with protocol and a simple path with slash', () => {\n+    const path1 = 'http://durandal.io';\n+    const path2 = '/two';\n+\n+    expect(join(path1, path2)).toBe('http://durandal.io/two');\n+  });\n+\n+  it('can combine an absolute path and a simple path with a dot', () => {\n+    const path1 = 'http://durandal.io';\n+    const path2 = './two';\n+\n+    expect(join(path1, path2)).toBe('http://durandal.io/two');\n+  });\n+\n+  it('can combine a simple path and a relative path', () => {\n+    const path1 = 'one';\n+    const path2 = '../two';\n+\n+    expect(join(path1, path2)).toBe('two');\n+  });\n+\n+  it('can combine an absolute path and a relative path', () => {\n+    const path1 = 'http://durandal.io/somewhere';\n+    const path2 = '../two';\n+\n+    expect(join(path1, path2)).toBe('http://durandal.io/two');\n+  });\n+\n+  it('can combine a protocol independent path and a simple path', () => {\n+    const path1 = '//durandal.io';\n+    const path2 = 'two';\n+\n+    expect(join(path1, path2)).toBe('//durandal.io/two');\n+  });\n+\n+  it('can combine a protocol independent path and a simple path with slash', () => {\n+    const path1 = '//durandal.io';\n+    const path2 = '/two';\n+\n+    expect(join(path1, path2)).toBe('//durandal.io/two');\n+  });\n+\n+  it('can combine a protocol independent path and a simple path with a dot', () => {\n+    const path1 = '//durandal.io';\n+    const path2 = './two';\n+\n+    expect(join(path1, path2)).toBe('//durandal.io/two');\n+  });\n+\n+  it('can combine a protocol independent path and a relative path', () => {\n+    const path1 = '//durandal.io/somewhere';\n+    const path2 = '../two';\n+\n+    expect(join(path1, path2)).toBe('//durandal.io/two');\n+  });\n+\n+  it('can combine a complex path and a relative path', () => {\n+    const path1 = 'one/three';\n+    const path2 = '../two';\n+\n+    expect(join(path1, path2)).toBe('one/two');\n+  });\n+\n+  it('returns path2 if path1 null', () => {\n+    const path1 = null;\n+    const path2 = 'two';\n+\n+    expect(join(path1, path2)).toBe('two');\n+  });\n+\n+  it('returns path2 if path1 empty', () => {\n+    const path1 = '';\n+    const path2 = 'two';\n+\n+    expect(join(path1, path2)).toBe('two');\n+  });\n+\n+  it('returns path1 if path2 null', () => {\n+    const path1 = 'one';\n+    const path2 = null;\n+\n+    expect(join(path1, path2)).toBe('one');\n+  });\n+\n+  it('returns path1 if path2 empty', () => {\n+    const path1 = 'one';\n+    const path2 = '';\n+\n+    expect(join(path1, path2)).toBe('one');\n+  });\n+\n+  it('should retain leading .. in path1', () => {\n+    const path1 = '../one';\n+    const path2 = './two';\n+\n+    expect(join(path1, path2)).toBe('../one/two');\n+  });\n+\n+  it('should retain consecutive leading .. in path1', () => {\n+    const path1 = '../../one';\n+    const path2 = './two';\n+\n+    expect(join(path1, path2)).toBe('../../one/two');\n+  });\n+\n+  it('should handle .. in path1 and path2', () => {\n+    const path1 = '../../one';\n+    const path2 = '../two';\n+\n+    expect(join(path1, path2)).toBe('../../two');\n+  });\n+\n+  it('should merge .. in path1 and path2', () => {\n+    const path1 = '../../one';\n+    const path2 = '../../two';\n+\n+    expect(join(path1, path2)).toBe('../../../two');\n+  });\n+\n+  it('should retain consecutive leading .. but not other .. in path1', () => {\n+    const path1 = '../../one/../three';\n+    const path2 = './two';\n+\n+    expect(join(path1, path2)).toBe('../../three/two');\n+  });\n+\n+  it('should respect a trailing slash', () => {\n+    const path1 = 'one/';\n+    const path2 = 'two/';\n+\n+    expect(join(path1, path2)).toBe('one/two/');\n+  });\n+\n+  it('should respect file:/// protocol with three slashes (empty host)', () => {\n+    const path1 = 'file:///one';\n+    const path2 = '/two';\n+\n+    expect(join(path1, path2)).toBe('file:///one/two');\n+  });\n+\n+  it('should respect file:// protocol with two slashes (host given)', () => {\n+    const path1 = 'file://localhost:8080';\n+    const path2 = '/two';\n+\n+    expect(join(path1, path2)).toBe('file://localhost:8080/two');\n+  });\n+\n+  it('should allow scheme-relative URL that uses colons in the path', () => {\n+    const path1 = '//localhost/one:/';\n+    const path2 = '/two';\n+\n+    expect(join(path1, path2)).toBe('//localhost/one:/two');\n+  });\n+\n+  it('should not add more than two leading slashes to http:// protocol', () => {\n+    const path1 = 'http:///';\n+    const path2 = '/two';\n+\n+    expect(join(path1, path2)).toBe('http://two');\n+  });\n+});\n+\n+describe('query strings', () => {\n+  interface IBuildTestCase {\n+    input: any;\n+    traditional?: boolean;\n+    output: string;\n+  }\n+  const testCases: IBuildTestCase[] = [\n+    { input: undefined, output: '' },\n+    { input: null, output: '' },\n+    { input: {}, output: '' },\n+    { input: { a: null }, output: '' },\n+    { input: { '': 'a' }, output: '=a' },\n+    { input: { a: 'b' }, output: 'a=b' },\n+    { input: { a: 'b', c: 'd' }, output: 'a=b&c=d' },\n+    { input: { a: 'b', c: 'd' }, traditional: true, output: 'a=b&c=d' },\n+    { input: { a: 'b', c: null }, output: 'a=b' },\n+    { input: { a: 'b', c: null }, traditional: true, output: 'a=b' },\n+    { input: { a: ['b', 'c'] }, output: 'a%5B%5D=b&a%5B%5D=c' },\n+    { input: { a: ['b', 'c'] }, traditional: true, output: 'a=b&a=c' },\n+    { input: { '&': ['b', 'c'] }, output: '%26%5B%5D=b&%26%5B%5D=c' },\n+    { input: { '&': ['b', 'c'] }, traditional: true, output: '%26=b&%26=c' },\n+\n+    { input: { a: '&' }, output: 'a=%26' },\n+    { input: { '&': 'a' }, output: '%26=a' },\n+    { input: { a: true }, output: 'a=true' },\n+    { input: { '$test': true }, output: '$test=true' },\n+\n+    { input: { obj: { a: 5, b: \"str\", c: false } }, output: 'obj%5Ba%5D=5&obj%5Bb%5D=str&obj%5Bc%5D=false' },\n+    { input: { obj: { a: 5, b: \"str\", c: false } }, traditional: true, output: 'obj=%5Bobject%20Object%5D' },\n+    { input: { obj: { a: 5, b: undefined } }, output: 'obj%5Ba%5D=5' },\n+\n+    { input: { a: { b: ['c', 'd', ['f', 'g']] } }, output: 'a%5Bb%5D%5B%5D=c&a%5Bb%5D%5B%5D=d&a%5Bb%5D%5B2%5D%5B%5D=f&a%5Bb%5D%5B2%5D%5B%5D=g' },\n+    { input: { a: { b: ['c', 'd', ['f', 'g']] } }, traditional: true, output: 'a=%5Bobject%20Object%5D' },\n+    { input: { a: ['c', 'd', ['f', 'g']] }, traditional: true, output: 'a=c&a=d&a=f%2Cg' },\n+    { input: { a: ['c', 'd', { f: 'g' }] }, traditional: true, output: 'a=c&a=d&a=%5Bobject%20Object%5D' },\n+  ];\n+\n+  testCases.forEach(({ input, output, traditional }) => {\n+    it(`builds ${input instanceof Object ? JSON.stringify(input) : input} to \"${output}\"`, () => {\n+      expect(buildQueryString(input, traditional)).toBe(output);\n+    });\n+  });\n+\n+  interface IParseTestCase {\n+    input: string;\n+    output: any;\n+  }\n+\n+  const parseTestCases: IParseTestCase[] = [\n+    { input: '', output: {} },\n+    { input: '=', output: {} },\n+    { input: '&', output: {} },\n+    { input: '?', output: {} },\n+\n+    { input: 'a', output: { a: true } },\n+    { input: 'a&b', output: { a: true, b: true } },\n+    { input: 'a=', output: { a: '' } },\n+    { input: 'a=&b=', output: { a: '', b: '' } },\n+\n+    { input: 'a=b', output: { a: 'b' } },\n+    { input: 'a=b&c=d', output: { a: 'b', c: 'd' } },\n+    { input: 'a=b&&c=d', output: { a: 'b', c: 'd' } },\n+    { input: 'a=b&a=c', output: { a: ['b', 'c'] } },\n+\n+    { input: 'a=b&c=d=', output: { a: 'b', c: 'd' } },\n+    { input: 'a=b&c=d==', output: { a: 'b', c: 'd' } },\n+\n+    { input: 'a=%26', output: { a: '&' } },\n+    { input: '%26=a', output: { '&': 'a' } },\n+    { input: '%26[]=b&%26[]=c', output: { '&': ['b', 'c'] } },\n+\n+    { input: 'a[b]=c&a[d]=e', output: { a: { b: 'c', d: 'e' } } },\n+    { input: 'a[b][c][d]=e', output: { a: { b: { c: { d: 'e' } } } } },\n+    { input: 'a[b][]=c&a[b][]=d&a[b][2][]=f&a[b][2][]=g', output: { a: { b: ['c', 'd', ['f', 'g']] } } },\n+    { input: 'a[0]=b', output: { a: ['b'] } },\n+  ];\n+\n+  parseTestCases.forEach(({ input, output }) => {\n+    it(`parses ${input} to \"${JSON.stringify(output)}\"`, () => {\n+      expect(parseQueryString(input)).toEqual(output);\n+    });\n+  });\n+\n+  it('does not pollute prototype', () => {\n+    const path1 = '__proto__[asdf]=asdf';\n+    assert.throws(() => parseQueryString(path1), 'Prototype pollution detected');\n+  });\n+});"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c7c5674dc9a2f4bc17b47c45a740684655d8980a",
            "date": "2024-08-11T12:41:14Z",
            "author_login": "bigopon"
          },
          {
            "sha": "919e13412722f6fb05e4d26254651495e41fa8e1",
            "date": "2024-08-11T12:37:14Z",
            "author_login": "raiseandfall"
          },
          {
            "sha": "eda8d02e3813f2049b26384c58927b34cab302d6",
            "date": "2024-08-11T12:16:26Z",
            "author_login": "bigopon"
          },
          {
            "sha": "aec9d4c9fd1a3c38d61cb1e6fbe46d154b615dd6",
            "date": "2022-06-02T11:37:15Z",
            "author_login": "bigopon"
          },
          {
            "sha": "5032373dd9f8c04edbb302b06bd0df3123b15c79",
            "date": "2022-04-10T00:20:26Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-1321",
    "description": "aurelia-path is part of the Aurelia platform and contains utilities for path manipulation. There is a prototype pollution vulnerability in aurelia-path before version 1.1.7. The vulnerability exposes Aurelia application that uses `aurelia-path` package to parse a string. The majority of this will be Aurelia applications that employ the `aurelia-router` package. An example is this could allow an attacker to change the prototype of base object class `Object` by tricking an application to parse the following URL: `https://aurelia.io/blog/?__proto__[asdf]=asdf`. The problem is patched in version `1.1.7`.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-09-27T18:15:08.443",
    "last_modified": "2024-11-21T06:25:27.567",
    "fix_date": "2021-06-09T06:30:20Z"
  },
  "references": [
    {
      "url": "https://github.com/aurelia/path/commit/7c4e235433a4a2df9acc313fbe891758084fdec1",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/aurelia/path/issues/44",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/aurelia/path/releases/tag/1.1.7",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/aurelia/path/security/advisories/GHSA-3c9c-2p65-qvwv",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.npmjs.com/package/aurelia-path",
      "source": "security-advisories@github.com",
      "tags": [
        "Product",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/aurelia/path/commit/7c4e235433a4a2df9acc313fbe891758084fdec1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/aurelia/path/issues/44",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/aurelia/path/releases/tag/1.1.7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/aurelia/path/security/advisories/GHSA-3c9c-2p65-qvwv",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.npmjs.com/package/aurelia-path",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:07.790393",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "path",
    "owner": "aurelia",
    "created_at": "2014-12-09T19:54:58Z",
    "updated_at": "2024-08-11T12:43:41Z",
    "pushed_at": "2024-12-18T17:07:30Z",
    "size": 445,
    "stars": 21,
    "forks": 28,
    "open_issues": 5,
    "watchers": 21,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "TypeScript": 19908,
      "JavaScript": 3812
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T19:56:12.446483"
  }
}