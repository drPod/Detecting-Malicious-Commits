{
  "cve_id": "CVE-2021-41098",
  "github_data": {
    "repository": "sparklemotion/nokogiri",
    "fix_commit": "5bf729ff3cc84709ee3c3248c981584088bf9f6d",
    "related_commits": [
      "5bf729ff3cc84709ee3c3248c981584088bf9f6d",
      "5bf729ff3cc84709ee3c3248c981584088bf9f6d"
    ],
    "patch_url": "https://github.com/sparklemotion/nokogiri/commit/5bf729ff3cc84709ee3c3248c981584088bf9f6d.patch",
    "fix_commit_details": {
      "sha": "5bf729ff3cc84709ee3c3248c981584088bf9f6d",
      "commit_date": "2021-09-26T21:44:03Z",
      "author": {
        "login": "flavorjones",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #2328 from sparklemotion/flavorjones-GHSA-2rr5-8q37-2w7h_main",
        "length": 118,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 1672,
        "additions": 804,
        "deletions": 868
      },
      "files": [
        {
          "filename": "ext/java/nokogiri/Html4SaxPushParser.java",
          "status": "modified",
          "additions": 14,
          "deletions": 19,
          "patch": "@@ -1,31 +1,26 @@\n package nokogiri;\n \n-import static nokogiri.XmlSaxPushParser.terminateExecution;\n-import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n-import static org.jruby.runtime.Helpers.invoke;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.InputStream;\n-import java.io.IOException;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.FutureTask;\n-import java.util.concurrent.ThreadFactory;\n-\n-import nokogiri.internals.*;\n-\n+import nokogiri.internals.ClosedStreamException;\n+import nokogiri.internals.NokogiriBlockingQueueInputStream;\n+import nokogiri.internals.NokogiriHelpers;\n+import nokogiri.internals.ParserContext;\n import org.jruby.Ruby;\n import org.jruby.RubyClass;\n import org.jruby.RubyObject;\n import org.jruby.anno.JRubyClass;\n import org.jruby.anno.JRubyMethod;\n-import org.jruby.exceptions.RaiseException;\n import org.jruby.runtime.ThreadContext;\n import org.jruby.runtime.builtin.IRubyObject;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.concurrent.*;\n+\n+import static nokogiri.XmlSaxPushParser.terminateExecution;\n+import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n+import static org.jruby.runtime.Helpers.invoke;\n+\n /**\n  * Class for Nokogiri::HTML4::SAX::PushParser\n  *\n@@ -134,7 +129,7 @@ public class Html4SaxPushParser extends RubyObject\n \n     if (!options.recover && parserTask.getErrorCount() > errorCount0) {\n       terminateTask(context.runtime);\n-      throw parserTask.getLastError();\n+      throw parserTask.getLastError().toThrowable();\n     }\n \n     return this;"
        },
        {
          "filename": "ext/java/nokogiri/XmlSaxParserContext.java",
          "status": "modified",
          "additions": 31,
          "deletions": 93,
          "patch": "@@ -1,33 +1,23 @@\n package nokogiri;\n \n-import static org.jruby.runtime.Helpers.invoke;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-\n+import nokogiri.internals.*;\n import org.apache.xerces.parsers.AbstractSAXParser;\n import org.jruby.Ruby;\n import org.jruby.RubyClass;\n import org.jruby.RubyFixnum;\n-import org.jruby.RubyModule;\n-import org.jruby.RubyObjectAdapter;\n import org.jruby.anno.JRubyClass;\n import org.jruby.anno.JRubyMethod;\n import org.jruby.exceptions.RaiseException;\n-import org.jruby.javasupport.JavaEmbedUtils;\n+import org.jruby.runtime.Helpers;\n import org.jruby.runtime.ThreadContext;\n import org.jruby.runtime.builtin.IRubyObject;\n-import org.xml.sax.ContentHandler;\n-import org.xml.sax.ErrorHandler;\n import org.xml.sax.SAXException;\n-import org.xml.sax.SAXNotRecognizedException;\n-import org.xml.sax.SAXNotSupportedException;\n import org.xml.sax.SAXParseException;\n \n-import nokogiri.internals.NokogiriHandler;\n-import nokogiri.internals.NokogiriHelpers;\n-import nokogiri.internals.ParserContext;\n-import nokogiri.internals.XmlSaxParser;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import static org.jruby.runtime.Helpers.invoke;\n \n /**\n  * Base class for the SAX parsers.\n@@ -51,6 +41,7 @@ public class XmlSaxParserContext extends ParserContext\n   protected AbstractSAXParser parser;\n \n   protected NokogiriHandler handler;\n+  protected NokogiriErrorHandler errorHandler;\n   private boolean replaceEntities = true;\n   private boolean recovery = false;\n \n@@ -168,31 +159,12 @@ public class XmlSaxParserContext extends ParserContext\n     return (XmlSaxParserContext) NokogiriService.XML_SAXPARSER_CONTEXT_ALLOCATOR.allocate(runtime, klazz);\n   }\n \n-  /**\n-   * Set a property of the underlying parser.\n-   */\n-  protected void\n-  setProperty(String key, Object val)\n-  throws SAXNotRecognizedException, SAXNotSupportedException\n-  {\n-    parser.setProperty(key, val);\n-  }\n-\n-  protected void\n-  setContentHandler(ContentHandler handler)\n-  {\n-    parser.setContentHandler(handler);\n-  }\n-\n-  protected void\n-  setErrorHandler(ErrorHandler handler)\n-  {\n-    parser.setErrorHandler(handler);\n-  }\n-\n   public final NokogiriHandler\n   getNokogiriHandler() { return handler; }\n \n+  public final NokogiriErrorHandler\n+  getNokogiriErrorHandler() { return errorHandler; }\n+\n   /**\n    * Perform any initialization prior to parsing with the handler\n    * <code>handlerRuby</code>. Convenience hook for subclasses.\n@@ -223,6 +195,17 @@ public class XmlSaxParserContext extends ParserContext\n     parser.parse(getInputSource());\n   }\n \n+  protected static Options\n+  defaultParseOptions(ThreadContext context)\n+  {\n+    return new ParserContext.Options(\n+             RubyFixnum.fix2long(Helpers.invoke(context,\n+                                 ((RubyClass)context.getRuntime().getClassFromPath(\"Nokogiri::XML::ParseOptions\"))\n+                                 .getConstant(\"DEFAULT_XML\"),\n+                                 \"to_i\"))\n+           );\n+  }\n+\n   @JRubyMethod\n   public IRubyObject\n   parse_with(ThreadContext context, IRubyObject handlerRuby)\n@@ -233,14 +216,19 @@ public class XmlSaxParserContext extends ParserContext\n       throw runtime.newArgumentError(\"argument must respond_to document\");\n     }\n \n-    NokogiriHandler handler = this.handler = new NokogiriHandler(runtime, handlerRuby);\n-    preParse(runtime, handlerRuby, handler);\n+    /* TODO: how should we pass in parse options? */\n+    ParserContext.Options options = defaultParseOptions(context);\n+\n+    errorHandler = new NokogiriStrictErrorHandler(runtime, options.noError, options.noWarning);\n+    handler = new NokogiriHandler(runtime, handlerRuby, errorHandler);\n \n-    setContentHandler(handler);\n-    setErrorHandler(handler);\n+    preParse(runtime, handlerRuby, handler);\n+    parser.setContentHandler(handler);\n+    parser.setErrorHandler(handler);\n+    parser.setEntityResolver(new NokogiriEntityResolver(runtime, errorHandler, options));\n \n     try {\n-      setProperty(\"http://xml.org/sax/properties/lexical-handler\", handler);\n+      parser.setProperty(\"http://xml.org/sax/properties/lexical-handler\", handler);\n     } catch (Exception ex) {\n       throw runtime.newRuntimeError(\"Problem while creating XML SAX Parser: \" + ex.toString());\n     }\n@@ -270,8 +258,6 @@ public class XmlSaxParserContext extends ParserContext\n \n     postParse(runtime, handlerRuby, handler);\n \n-    //maybeTrimLeadingAndTrailingWhitespace(context, handlerRuby);\n-\n     return runtime.getNil();\n   }\n \n@@ -319,53 +305,6 @@ public class XmlSaxParserContext extends ParserContext\n     return context.runtime.newBoolean(recovery);\n   }\n \n-  /**\n-   * If the handler's document is a FragmentHandler, attempt to trim\n-   * leading and trailing whitespace.\n-   *\n-   * This is a bit hackish and depends heavily on the internals of\n-   * FragmentHandler.\n-   */\n-  protected void\n-  maybeTrimLeadingAndTrailingWhitespace(ThreadContext context, IRubyObject parser)\n-  {\n-    RubyObjectAdapter adapter = JavaEmbedUtils.newObjectAdapter();\n-    RubyModule mod = context.getRuntime().getClassFromPath(\"Nokogiri::XML::FragmentHandler\");\n-\n-    IRubyObject handler = adapter.getInstanceVariable(parser, \"@document\");\n-    if (handler == null || handler.isNil() || !adapter.isKindOf(handler, mod)) {\n-      return;\n-    }\n-    IRubyObject stack = adapter.getInstanceVariable(handler, \"@stack\");\n-    if (stack == null || stack.isNil()) {\n-      return;\n-    }\n-    // doc is finally a DocumentFragment whose nodes we can check\n-    IRubyObject doc = adapter.callMethod(stack, \"first\");\n-    if (doc == null || doc.isNil()) {\n-      return;\n-    }\n-\n-    IRubyObject children;\n-\n-    for (;;) {\n-      children = adapter.callMethod(doc, \"children\");\n-      IRubyObject first = adapter.callMethod(children, \"first\");\n-      if (NokogiriHelpers.isBlank(first)) { adapter.callMethod(first, \"unlink\"); }\n-      else { break; }\n-    }\n-\n-    for (;;) {\n-      children = adapter.callMethod(doc, \"children\");\n-      IRubyObject last = adapter.callMethod(children, \"last\");\n-      if (NokogiriHelpers.isBlank(last)) { adapter.callMethod(last, \"unlink\"); }\n-      else { break; }\n-    }\n-\n-    // While we have a document, normalize it.\n-    ((XmlNode) doc).normalize();\n-  }\n-\n   @JRubyMethod(name = \"column\")\n   public IRubyObject\n   column(ThreadContext context)\n@@ -383,5 +322,4 @@ public class XmlSaxParserContext extends ParserContext\n     if (number == null) { return context.getRuntime().getNil(); }\n     return RubyFixnum.newFixnum(context.getRuntime(), number.longValue());\n   }\n-\n }"
        },
        {
          "filename": "ext/java/nokogiri/XmlSaxPushParser.java",
          "status": "modified",
          "additions": 17,
          "deletions": 25,
          "patch": "@@ -1,32 +1,24 @@\n package nokogiri;\n \n-import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n-import static org.jruby.runtime.Helpers.invoke;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.FutureTask;\n-import java.util.concurrent.ThreadFactory;\n-\n+import nokogiri.internals.*;\n import org.jruby.Ruby;\n import org.jruby.RubyClass;\n+import org.jruby.RubyException;\n import org.jruby.RubyObject;\n import org.jruby.anno.JRubyClass;\n import org.jruby.anno.JRubyMethod;\n import org.jruby.exceptions.RaiseException;\n import org.jruby.runtime.ThreadContext;\n import org.jruby.runtime.builtin.IRubyObject;\n \n-import nokogiri.internals.ClosedStreamException;\n-import nokogiri.internals.NokogiriBlockingQueueInputStream;\n-import nokogiri.internals.NokogiriHandler;\n-import nokogiri.internals.NokogiriHelpers;\n-import nokogiri.internals.ParserContext;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.concurrent.*;\n+\n+import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n+import static org.jruby.runtime.Helpers.invoke;\n \n /**\n  * Class for Nokogiri::XML::SAX::PushParser\n@@ -159,7 +151,8 @@ public class XmlSaxPushParser extends RubyObject\n \n     if (!options.recover && parserTask.getErrorCount() > errorCount0) {\n       terminateTask(context.runtime);\n-      throw ex = parserTask.getLastError();\n+      ex = parserTask.getLastError().toThrowable();\n+      throw ex;\n     }\n \n     return this;\n@@ -278,16 +271,15 @@ static class ParserTask extends ParserContext.ParserTask<XmlSaxParserContext>\n     getErrorCount()\n     {\n       // check for null because thread may not have started yet\n-      if (parser.getNokogiriHandler() == null) { return 0; }\n-      return parser.getNokogiriHandler().getErrorCount();\n+      if (parser.getNokogiriErrorHandler() == null) { return 0; }\n+      return parser.getNokogiriErrorHandler().getErrors().size();\n     }\n \n-    synchronized final RaiseException\n+    synchronized final RubyException\n     getLastError()\n     {\n-      return parser.getNokogiriHandler().getLastError();\n+      List<RubyException> errors = parser.getNokogiriErrorHandler().getErrors();\n+      return errors.get(errors.size() - 1);\n     }\n-\n   }\n-\n }"
        },
        {
          "filename": "ext/java/nokogiri/internals/NokogiriEntityResolver.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -85,7 +85,7 @@ public class NokogiriEntityResolver implements EntityResolver2\n   private void\n   addError(String errorMessage)\n   {\n-    if (handler != null) { handler.errors.add(new Exception(errorMessage)); }\n+    if (handler != null) { handler.addError(new Exception(errorMessage)); }\n   }\n \n   /**"
        },
        {
          "filename": "ext/java/nokogiri/internals/NokogiriErrorHandler.java",
          "status": "modified",
          "additions": 29,
          "deletions": 8,
          "patch": "@@ -1,11 +1,15 @@\n package nokogiri.internals;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n+import nokogiri.XmlSyntaxError;\n import org.apache.xerces.xni.parser.XMLErrorHandler;\n+import org.jruby.Ruby;\n+import org.jruby.RubyException;\n+import org.jruby.exceptions.RaiseException;\n import org.xml.sax.ErrorHandler;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n /**\n  * Super class of error handlers.\n  *\n@@ -17,23 +21,40 @@\n  */\n public abstract class NokogiriErrorHandler implements ErrorHandler, XMLErrorHandler\n {\n-  protected final List<Exception> errors;\n+  private final Ruby runtime;\n+  protected final List<RubyException> errors;\n   protected boolean noerror;\n   protected boolean nowarning;\n \n   public\n-  NokogiriErrorHandler(boolean noerror, boolean nowarning)\n+  NokogiriErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n   {\n-    this.errors = new ArrayList<Exception>(4);\n+    this.runtime = runtime;\n+    this.errors = new ArrayList<RubyException>(4);\n     this.noerror = noerror;\n     this.nowarning = nowarning;\n   }\n \n-  List<Exception>\n+  public List<RubyException>\n   getErrors() { return errors; }\n \n   public void\n-  addError(Exception ex) { errors.add(ex); }\n+  addError(Exception ex)\n+  {\n+    addError(XmlSyntaxError.createXMLSyntaxError(runtime, ex));\n+  }\n+\n+  public void\n+  addError(RubyException ex)\n+  {\n+    errors.add(ex);\n+  }\n+\n+  public void\n+  addError(RaiseException ex)\n+  {\n+    addError(ex.getException());\n+  }\n \n   protected boolean\n   usesNekoHtml(String domain)"
        },
        {
          "filename": "ext/java/nokogiri/internals/NokogiriHandler.java",
          "status": "modified",
          "additions": 6,
          "deletions": 24,
          "patch": "@@ -38,25 +38,19 @@ public class NokogiriHandler extends DefaultHandler2 implements XmlDeclHandler\n   private final Ruby runtime;\n   private final RubyClass attrClass;\n   private final IRubyObject object;\n-\n-  /**\n-   * Stores parse errors with the most-recent error last.\n-   *\n-   * TODO: should these be stored in the document 'errors' array?\n-   * Currently only string messages are stored there.\n-   */\n-  private final LinkedList<RaiseException> errors = new LinkedList<RaiseException>();\n+  private NokogiriErrorHandler errorHandler;\n \n   private Locator locator;\n   private boolean needEmptyAttrCheck;\n \n   public\n-  NokogiriHandler(Ruby runtime, IRubyObject object)\n+  NokogiriHandler(Ruby runtime, IRubyObject object, NokogiriErrorHandler errorHandler)\n   {\n     assert object != null;\n     this.runtime = runtime;\n     this.attrClass = (RubyClass) runtime.getClassFromPath(\"Nokogiri::XML::SAX::Parser::Attribute\");\n     this.object = object;\n+    this.errorHandler = errorHandler;\n     charactersBuilder = new StringBuilder();\n     String objectName = object.getMetaClass().getName();\n     if (\"Nokogiri::HTML4::SAX::Parser\".equals(objectName)) { needEmptyAttrCheck = true; }\n@@ -253,9 +247,9 @@ public class NokogiriHandler extends DefaultHandler2 implements XmlDeclHandler\n     try {\n       final String msg = ex.getMessage();\n       call(\"error\", runtime.newString(msg == null ? \"\" : msg));\n-      addError(XmlSyntaxError.createError(runtime, ex).toThrowable());\n+      errorHandler.addError(ex);\n     } catch (RaiseException e) {\n-      addError(e);\n+      errorHandler.addError(e);\n       throw e;\n     }\n   }\n@@ -282,22 +276,10 @@ public class NokogiriHandler extends DefaultHandler2 implements XmlDeclHandler\n     call(\"warning\", runtime.newString(msg == null ? \"\" : msg));\n   }\n \n-  protected synchronized void\n-  addError(RaiseException e)\n-  {\n-    errors.add(e);\n-  }\n-\n   public synchronized int\n   getErrorCount()\n   {\n-    return errors.size();\n-  }\n-\n-  public synchronized RaiseException\n-  getLastError()\n-  {\n-    return errors.getLast();\n+    return errorHandler.getErrors().size();\n   }\n \n   private void"
        },
        {
          "filename": "ext/java/nokogiri/internals/NokogiriNonStrictErrorHandler.java",
          "status": "modified",
          "additions": 9,
          "deletions": 8,
          "patch": "@@ -1,6 +1,7 @@\n package nokogiri.internals;\n \n import org.apache.xerces.xni.parser.XMLParseException;\n+import org.jruby.Ruby;\n import org.xml.sax.SAXException;\n import org.xml.sax.SAXParseException;\n \n@@ -13,21 +14,21 @@\n public class NokogiriNonStrictErrorHandler extends NokogiriErrorHandler\n {\n   public\n-  NokogiriNonStrictErrorHandler(boolean noerror, boolean nowarning)\n+  NokogiriNonStrictErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n   {\n-    super(noerror, nowarning);\n+    super(runtime, noerror, nowarning);\n   }\n \n   public void\n   warning(SAXParseException ex) throws SAXException\n   {\n-    errors.add(ex);\n+    addError(ex);\n   }\n \n   public void\n   error(SAXParseException ex) throws SAXException\n   {\n-    errors.add(ex);\n+    addError(ex);\n   }\n \n   public void\n@@ -38,7 +39,7 @@ public class NokogiriNonStrictErrorHandler extends NokogiriErrorHandler\n     // found in the prolog, instead it will keep calling this method and we'll\n     // keep inserting the error in the document errors array until we run\n     // out of memory\n-    errors.add(ex);\n+    addError(ex);\n     String message = ex.getMessage();\n \n     // The problem with Xerces is that some errors will cause the\n@@ -53,19 +54,19 @@ public class NokogiriNonStrictErrorHandler extends NokogiriErrorHandler\n   public void\n   error(String domain, String key, XMLParseException e)\n   {\n-    errors.add(e);\n+    addError(e);\n   }\n \n   public void\n   fatalError(String domain, String key, XMLParseException e)\n   {\n-    errors.add(e);\n+    addError(e);\n   }\n \n   public void\n   warning(String domain, String key, XMLParseException e)\n   {\n-    errors.add(e);\n+    addError(e);\n   }\n \n   /*"
        },
        {
          "filename": "ext/java/nokogiri/internals/NokogiriNonStrictErrorHandler4NekoHtml.java",
          "status": "modified",
          "additions": 10,
          "deletions": 9,
          "patch": "@@ -1,6 +1,7 @@\n package nokogiri.internals;\n \n import org.apache.xerces.xni.parser.XMLParseException;\n+import org.jruby.Ruby;\n import org.xml.sax.SAXException;\n import org.xml.sax.SAXParseException;\n \n@@ -20,15 +21,15 @@ public class NokogiriNonStrictErrorHandler4NekoHtml extends NokogiriErrorHandler\n {\n \n   public\n-  NokogiriNonStrictErrorHandler4NekoHtml(boolean nowarning)\n+  NokogiriNonStrictErrorHandler4NekoHtml(Ruby runtime, boolean nowarning)\n   {\n-    super(false, nowarning);\n+    super(runtime, false, nowarning);\n   }\n \n   public\n-  NokogiriNonStrictErrorHandler4NekoHtml(boolean noerror, boolean nowarning)\n+  NokogiriNonStrictErrorHandler4NekoHtml(Ruby runtime, boolean noerror, boolean nowarning)\n   {\n-    super(noerror, nowarning);\n+    super(runtime, noerror, nowarning);\n   }\n \n   public void\n@@ -40,13 +41,13 @@ public class NokogiriNonStrictErrorHandler4NekoHtml extends NokogiriErrorHandler\n   public void\n   error(SAXParseException ex) throws SAXException\n   {\n-    errors.add(ex);\n+    addError(ex);\n   }\n \n   public void\n   fatalError(SAXParseException ex) throws SAXException\n   {\n-    errors.add(ex);\n+    addError(ex);\n   }\n \n   /**\n@@ -64,7 +65,7 @@ public class NokogiriNonStrictErrorHandler4NekoHtml extends NokogiriErrorHandler\n   public void\n   error(String domain, String key, XMLParseException e)\n   {\n-    errors.add(e);\n+    addError(e);\n   }\n \n   /**\n@@ -82,7 +83,7 @@ public class NokogiriNonStrictErrorHandler4NekoHtml extends NokogiriErrorHandler\n   public void\n   fatalError(String domain, String key, XMLParseException e)\n   {\n-    errors.add(e);\n+    addError(e);\n   }\n \n   /**\n@@ -100,7 +101,7 @@ public class NokogiriNonStrictErrorHandler4NekoHtml extends NokogiriErrorHandler\n   public void\n   warning(String domain, String key, XMLParseException e)\n   {\n-    errors.add(e);\n+    addError(e);\n   }\n \n }"
        },
        {
          "filename": "ext/java/nokogiri/internals/NokogiriStrictErrorHandler.java",
          "status": "modified",
          "additions": 7,
          "deletions": 6,
          "patch": "@@ -1,6 +1,7 @@\n package nokogiri.internals;\n \n import org.apache.xerces.xni.parser.XMLParseException;\n+import org.jruby.Ruby;\n import org.xml.sax.SAXException;\n import org.xml.sax.SAXParseException;\n \n@@ -14,23 +15,23 @@\n public class NokogiriStrictErrorHandler extends NokogiriErrorHandler\n {\n   public\n-  NokogiriStrictErrorHandler(boolean noerror, boolean nowarning)\n+  NokogiriStrictErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n   {\n-    super(noerror, nowarning);\n+    super(runtime, noerror, nowarning);\n   }\n \n   public void\n   warning(SAXParseException spex) throws SAXException\n   {\n     if (!nowarning) { throw spex; }\n-    else { errors.add(spex); }\n+    else { addError(spex); }\n   }\n \n   public void\n   error(SAXParseException spex) throws SAXException\n   {\n     if (!noerror) { throw spex; }\n-    else { errors.add(spex); }\n+    else { addError(spex); }\n   }\n \n   public void\n@@ -43,7 +44,7 @@ public class NokogiriStrictErrorHandler extends NokogiriErrorHandler\n   error(String domain, String key, XMLParseException e) throws XMLParseException\n   {\n     if (!noerror) { throw e; }\n-    else { errors.add(e); }\n+    else { addError(e); }\n   }\n \n   public void\n@@ -56,6 +57,6 @@ public class NokogiriStrictErrorHandler extends NokogiriErrorHandler\n   warning(String domain, String key, XMLParseException e) throws XMLParseException\n   {\n     if (!nowarning) { throw e; }\n-    if (!usesNekoHtml(domain)) { errors.add(e); }\n+    if (!usesNekoHtml(domain)) { addError(e); }\n   }\n }"
        },
        {
          "filename": "ext/java/nokogiri/internals/XmlDomParserContext.java",
          "status": "modified",
          "additions": 16,
          "deletions": 25,
          "patch": "@@ -1,30 +1,24 @@\n package nokogiri.internals;\n \n-import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n-import static nokogiri.internals.NokogiriHelpers.isBlank;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n+import nokogiri.XmlDocument;\n+import nokogiri.XmlDtd;\n+import nokogiri.XmlSyntaxError;\n import org.apache.xerces.parsers.DOMParser;\n-import org.jruby.Ruby;\n-import org.jruby.RubyArray;\n-import org.jruby.RubyClass;\n-import org.jruby.RubyFixnum;\n+import org.jruby.*;\n import org.jruby.exceptions.RaiseException;\n-import org.jruby.runtime.ThreadContext;\n import org.jruby.runtime.Helpers;\n+import org.jruby.runtime.ThreadContext;\n import org.jruby.runtime.builtin.IRubyObject;\n import org.w3c.dom.Document;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n import org.xml.sax.SAXException;\n \n-import nokogiri.NokogiriService;\n-import nokogiri.XmlDocument;\n-import nokogiri.XmlDtd;\n-import nokogiri.XmlSyntaxError;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static nokogiri.internals.NokogiriHelpers.isBlank;\n \n /**\n  * Parser class for XML DOM processing. This class actually parses XML document\n@@ -48,7 +42,6 @@ public class XmlDomParserContext extends ParserContext\n   protected static final String FEATURE_NOT_EXPAND_ENTITY =\n     \"http://apache.org/xml/features/dom/create-entity-ref-nodes\";\n   protected static final String FEATURE_VALIDATION = \"http://xml.org/sax/features/validation\";\n-  private static final String XINCLUDE_FEATURE_ID = \"http://apache.org/xml/features/xinclude\";\n   private static final String SECURITY_MANAGER = \"http://apache.org/xml/properties/security-manager\";\n \n   protected ParserContext.Options options;\n@@ -69,17 +62,17 @@ public class XmlDomParserContext extends ParserContext\n     this.options = new ParserContext.Options(RubyFixnum.fix2long(options));\n     java_encoding = NokogiriHelpers.getValidEncodingOrNull(encoding);\n     ruby_encoding = encoding;\n-    initErrorHandler();\n+    initErrorHandler(runtime);\n     initParser(runtime);\n   }\n \n   protected void\n-  initErrorHandler()\n+  initErrorHandler(Ruby runtime)\n   {\n     if (options.recover) {\n-      errorHandler = new NokogiriNonStrictErrorHandler(options.noError, options.noWarning);\n+      errorHandler = new NokogiriNonStrictErrorHandler(runtime, options.noError, options.noWarning);\n     } else {\n-      errorHandler = new NokogiriStrictErrorHandler(options.noError, options.noWarning);\n+      errorHandler = new NokogiriStrictErrorHandler(runtime, options.noError, options.noWarning);\n     }\n   }\n \n@@ -161,12 +154,10 @@ public class XmlDomParserContext extends ParserContext\n   mapErrors(ThreadContext context, NokogiriErrorHandler errorHandler)\n   {\n     final Ruby runtime = context.runtime;\n-    final List<Exception> errors = errorHandler.getErrors();\n+    final List<RubyException> errors = errorHandler.getErrors();\n     final IRubyObject[] errorsAry = new IRubyObject[errors.size()];\n     for (int i = 0; i < errors.size(); i++) {\n-      XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(runtime);\n-      xmlSyntaxError.setException(errors.get(i));\n-      errorsAry[i] = xmlSyntaxError;\n+      errorsAry[i] = errors.get(i);\n     }\n     return runtime.newArrayNoCopy(errorsAry);\n   }"
        },
        {
          "filename": "test/xml/sax/test_parser.rb",
          "status": "modified",
          "additions": 455,
          "deletions": 418,
          "patch": "@@ -2,425 +2,462 @@\n \n require \"helper\"\n \n-module Nokogiri\n-  module XML\n-    module SAX\n-      class TestParser < Nokogiri::SAX::TestCase\n-        def setup\n-          super\n-          @parser = XML::SAX::Parser.new(Doc.new)\n-        end\n-\n-        def test_parser_context_yielded_io\n-          doc = Doc.new\n-          parser = XML::SAX::Parser.new(doc)\n-          xml = \"<foo a='&amp;b'/>\"\n-\n-          block_called = false\n-          parser.parse(StringIO.new(xml)) do |ctx|\n-            block_called = true\n-            ctx.replace_entities = true\n-          end\n-\n-          assert(block_called)\n-\n-          assert_equal([[\"foo\", [[\"a\", \"&b\"]]]], doc.start_elements)\n-        end\n-\n-        def test_parser_context_yielded_in_memory\n-          doc = Doc.new\n-          parser = XML::SAX::Parser.new(doc)\n-          xml = \"<foo a='&amp;b'/>\"\n-\n-          block_called = false\n-          parser.parse(xml) do |ctx|\n-            block_called = true\n-            ctx.replace_entities = true\n-          end\n-\n-          assert(block_called)\n-\n-          assert_equal([[\"foo\", [[\"a\", \"&b\"]]]], doc.start_elements)\n-        end\n-\n-        def test_empty_decl\n-          parser = XML::SAX::Parser.new(Doc.new)\n-\n-          xml = \"<root />\"\n-          parser.parse(xml)\n-          assert(parser.document.start_document_called, xml)\n-          assert_nil(parser.document.xmldecls, xml)\n-        end\n-\n-        def test_xml_decl\n-          [\n-            ['<?xml version=\"1.0\" ?>', [\"1.0\"]],\n-            ['<?xml version=\"1.0\" encoding=\"UTF-8\" ?>', [\"1.0\", \"UTF-8\"]],\n-            ['<?xml version=\"1.0\" standalone=\"yes\"?>', [\"1.0\", \"yes\"]],\n-            ['<?xml version=\"1.0\" standalone=\"no\"?>', [\"1.0\", \"no\"]],\n-            ['<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>', [\"1.0\", \"UTF-8\", \"no\"]],\n-            ['<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?>', [\"1.0\", \"ISO-8859-1\", \"yes\"]],\n-          ].each do |decl, value|\n-            parser = XML::SAX::Parser.new(Doc.new)\n-\n-            xml = \"#{decl}\\n<root />\"\n-            parser.parse(xml)\n-            assert(parser.document.start_document_called, xml)\n-            assert_equal(value, parser.document.xmldecls, xml)\n-          end\n-        end\n-\n-        def test_parse_empty\n-          assert_raises(RuntimeError) do\n-            @parser.parse(\"\")\n-          end\n-        end\n-\n-        def test_namespace_declaration_order_is_saved\n-          @parser.parse(<<~eoxml)\n-            <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>\n-              <a foo:bar='hello' />\n-            </root>\n-          eoxml\n-          assert_equal(2, @parser.document.start_elements_namespace.length)\n-          el = @parser.document.start_elements_namespace.first\n-          namespaces = el.last\n-          assert_equal([\"foo\", \"http://foo.example.com/\"], namespaces.first)\n-          assert_equal([nil, \"http://example.com/\"], namespaces.last)\n-        end\n-\n-        def test_bad_document_calls_error_handler\n-          @parser.parse(\"<foo><bar></foo>\")\n-          assert(@parser.document.errors)\n-          assert(@parser.document.errors.length > 0)\n-        end\n-\n-        def test_namespace_are_super_fun_to_parse\n-          @parser.parse(<<~eoxml)\n-            <root xmlns:foo='http://foo.example.com/'>\n-              <a foo:bar='hello' />\n-              <b xmlns:foo='http://bar.example.com/'>\n-                <a foo:bar='hello' />\n-              </b>\n-              <foo:bar>hello world</foo:bar>\n-            </root>\n-          eoxml\n-\n-          assert(@parser.document.start_elements_namespace.length > 0)\n-          el = @parser.document.start_elements_namespace[1]\n-          assert_equal(\"a\", el.first)\n-          assert_equal(1, el[1].length)\n-\n-          attribute = el[1].first\n-          assert_equal(\"bar\", attribute.localname)\n-          assert_equal(\"foo\", attribute.prefix)\n-          assert_equal(\"hello\", attribute.value)\n-          assert_equal(\"http://foo.example.com/\", attribute.uri)\n-        end\n-\n-        def test_sax_v1_namespace_attribute_declarations\n-          @parser.parse(<<~eoxml)\n-            <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>\n-              <a foo:bar='hello' />\n-              <b xmlns:foo='http://bar.example.com/'>\n-                <a foo:bar='hello' />\n-              </b>\n-              <foo:bar>hello world</foo:bar>\n-            </root>\n-          eoxml\n-          assert(@parser.document.start_elements.length > 0)\n-          elm = @parser.document.start_elements.first\n-          assert_equal(\"root\", elm.first)\n-          assert(elm[1].include?([\"xmlns:foo\", \"http://foo.example.com/\"]))\n-          assert(elm[1].include?([\"xmlns\", \"http://example.com/\"]))\n-        end\n-\n-        def test_sax_v1_namespace_nodes\n-          @parser.parse(<<~eoxml)\n-            <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>\n-              <a foo:bar='hello' />\n-              <b xmlns:foo='http://bar.example.com/'>\n-                <a foo:bar='hello' />\n-              </b>\n-              <foo:bar>hello world</foo:bar>\n-            </root>\n-          eoxml\n-          assert_equal(5, @parser.document.start_elements.length)\n-          assert(@parser.document.start_elements.map(&:first).include?(\"foo:bar\"))\n-          assert(@parser.document.end_elements.map(&:first).include?(\"foo:bar\"))\n-        end\n-\n-        def test_start_is_called_without_namespace\n-          @parser.parse(<<~eoxml)\n-            <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>\n-            <foo:f><bar></foo:f>\n-            </root>\n-          eoxml\n-          assert_equal([\"root\", \"foo:f\", \"bar\"],\n-                       @parser.document.start_elements.map(&:first))\n-        end\n-\n-        def test_parser_sets_encoding\n-          parser = XML::SAX::Parser.new(Doc.new, \"UTF-8\")\n-          assert_equal(\"UTF-8\", parser.encoding)\n-        end\n-\n-        def test_errors_set_after_parsing_bad_dom\n-          doc = Nokogiri::XML(\"<foo><bar></foo>\")\n-          assert(doc.errors)\n-\n-          @parser.parse(\"<foo><bar></foo>\")\n-          assert(@parser.document.errors)\n-          assert(@parser.document.errors.length > 0)\n-\n-          doc.errors.each do |error|\n-            assert_equal(\"UTF-8\", error.message.encoding.name)\n-          end\n-\n-          # when using JRuby Nokogiri, more errors will be generated as the DOM\n-          # parser continue to parse an ill formed document, while the sax parser\n-          # will stop at the first error\n-          unless Nokogiri.jruby?\n-            assert_equal(doc.errors.length, @parser.document.errors.length)\n-          end\n-        end\n-\n-        def test_parse_with_memory_argument\n-          @parser.parse(File.read(XML_FILE))\n-          assert(@parser.document.cdata_blocks.length > 0)\n-        end\n-\n-        def test_parse_with_io_argument\n-          File.open(XML_FILE, \"rb\") do |f|\n-            @parser.parse(f)\n-          end\n-          assert(@parser.document.cdata_blocks.length > 0)\n-        end\n-\n-        def test_parse_io\n-          call_parse_io_with_encoding(\"UTF-8\")\n-        end\n-\n-        # issue #828\n-        def test_parse_io_lower_case_encoding\n-          call_parse_io_with_encoding(\"utf-8\")\n-        end\n-\n-        def call_parse_io_with_encoding(encoding)\n-          File.open(XML_FILE, \"rb\") do |f|\n-            @parser.parse_io(f, encoding)\n-          end\n-          assert(@parser.document.cdata_blocks.length > 0)\n-\n-          called = false\n-          @parser.document.start_elements.flatten.each do |thing|\n-            assert_equal(\"UTF-8\", thing.encoding.name)\n-            called = true\n-          end\n-          assert(called)\n-\n-          called = false\n-          @parser.document.end_elements.flatten.each do |thing|\n-            assert_equal(\"UTF-8\", thing.encoding.name)\n-            called = true\n-          end\n-          assert(called)\n-\n-          called = false\n-          @parser.document.data.each do |thing|\n-            assert_equal(\"UTF-8\", thing.encoding.name)\n-            called = true\n-          end\n-          assert(called)\n-\n-          called = false\n-          @parser.document.comments.flatten.each do |thing|\n-            assert_equal(\"UTF-8\", thing.encoding.name)\n-            called = true\n-          end\n-          assert(called)\n-\n-          called = false\n-          @parser.document.cdata_blocks.flatten.each do |thing|\n-            assert_equal(\"UTF-8\", thing.encoding.name)\n-            called = true\n-          end\n-          assert(called)\n-        end\n-\n-        def test_parse_file\n-          @parser.parse_file(XML_FILE)\n-\n-          assert_raises(ArgumentError) do\n-            @parser.parse_file(nil)\n-          end\n-\n-          assert_raises(Errno::ENOENT) do\n-            @parser.parse_file(\"\")\n-          end\n-          assert_raises(Errno::EISDIR) do\n-            @parser.parse_file(File.expand_path(File.dirname(__FILE__)))\n-          end\n-        end\n-\n-        def test_render_parse_nil_param\n-          assert_raises(ArgumentError) { @parser.parse_memory(nil) }\n-        end\n-\n-        def test_bad_encoding_args\n-          assert_raises(ArgumentError) { XML::SAX::Parser.new(Doc.new, \"not an encoding\") }\n-          assert_raises(ArgumentError) { @parser.parse_io(StringIO.new(\"<root/>\"), \"not an encoding\") }\n-        end\n-\n-        def test_ctag\n-          @parser.parse_memory(<<~eoxml)\n-            <p id=\"asdfasdf\">\n-              <![CDATA[ This is a comment ]]>\n-              Paragraph 1\n-            </p>\n-          eoxml\n-          assert_equal([\" This is a comment \"], @parser.document.cdata_blocks)\n-        end\n-\n-        def test_comment\n-          @parser.parse_memory(<<~eoxml)\n-            <p id=\"asdfasdf\">\n-              <!-- This is a comment -->\n-              Paragraph 1\n-            </p>\n-          eoxml\n-          assert_equal([\" This is a comment \"], @parser.document.comments)\n-        end\n-\n-        def test_characters\n-          @parser.parse_memory(<<~eoxml)\n-            <p id=\"asdfasdf\">Paragraph 1</p>\n-          eoxml\n-          assert_equal([\"Paragraph 1\"], @parser.document.data)\n-        end\n-\n-        def test_end_document\n-          @parser.parse_memory(<<~eoxml)\n-            <p id=\"asdfasdf\">Paragraph 1</p>\n-          eoxml\n-          assert(@parser.document.end_document_called)\n-        end\n-\n-        def test_end_element\n-          @parser.parse_memory(<<~eoxml)\n-            <p id=\"asdfasdf\">Paragraph 1</p>\n-          eoxml\n-          assert_equal([[\"p\"]], @parser.document.end_elements)\n-        end\n-\n-        def test_start_element_attrs\n-          @parser.parse_memory(<<~eoxml)\n-            <p id=\"asdfasdf\">Paragraph 1</p>\n-          eoxml\n-          assert_equal([[\"p\", [[\"id\", \"asdfasdf\"]]]], @parser.document.start_elements)\n-        end\n-\n-        def test_start_element_attrs_include_namespaces\n-          @parser.parse_memory(<<~eoxml)\n-            <p xmlns:foo='http://foo.example.com/'>Paragraph 1</p>\n-          eoxml\n-          assert_equal([[\"p\", [[\"xmlns:foo\", \"http://foo.example.com/\"]]]],\n-                       @parser.document.start_elements)\n-        end\n-\n-        def test_processing_instruction\n-          @parser.parse_memory(<<~eoxml)\n-            <?xml-stylesheet href=\"a.xsl\" type=\"text/xsl\"?>\n-            <?xml version=\"1.0\"?>\n-          eoxml\n-          assert_equal([[\"xml-stylesheet\", 'href=\"a.xsl\" type=\"text/xsl\"']],\n-                       @parser.document.processing_instructions)\n-        end\n-\n-        def test_parse_document\n-          skip_unless_libxml2(\"JRuby SAXParser only parses well-formed XML documents\")\n-          @parser.parse_memory(<<~eoxml)\n-            <p>Paragraph 1</p>\n-            <p>Paragraph 2</p>\n-          eoxml\n-        end\n-\n-        def test_parser_attributes\n-          xml = <<~eoxml\n-            <?xml version=\"1.0\" ?><root><foo a=\"&amp;b\" c=\"&gt;d\" /></root>\n-          eoxml\n-\n-          block_called = false\n-          @parser.parse(xml) do |ctx|\n-            block_called = true\n-            ctx.replace_entities = true\n-          end\n-\n-          assert(block_called)\n-\n-          assert_equal([[\"root\", []], [\"foo\", [[\"a\", \"&b\"], [\"c\", \">d\"]]]], @parser.document.start_elements)\n-        end\n-\n-        def test_recovery_from_incorrect_xml\n-          xml = <<~eoxml\n-            <?xml version=\"1.0\" ?><Root><Data><?xml version='1.0'?><Item>hey</Item></Data><Data><Item>hey yourself</Item></Data></Root>\n-          eoxml\n-\n-          block_called = false\n-          @parser.parse(xml) do |ctx|\n-            block_called = true\n-            ctx.recovery = true\n-          end\n-\n-          assert(block_called)\n-\n-          assert_equal([[\"Root\", []], [\"Data\", []], [\"Item\", []], [\"Data\", []], [\"Item\", []]],\n-                       @parser.document.start_elements)\n-        end\n-\n-        def test_square_bracket_in_text # issue 1261\n-          xml = <<~eoxml\n-            <tu tuid=\"87dea04cf60af103ff09d1dba36ae820\" segtype=\"block\">\n-              <prop type=\"x-smartling-string-variant\">en:#:home_page:#:stories:#:[6]:#:name</prop>\n-              <tuv xml:lang=\"en-US\"><seg>Sandy S.</seg></tuv>\n-            </tu>\n-          eoxml\n-          @parser.parse(xml)\n-          assert_includes(@parser.document.data, \"en:#:home_page:#:stories:#:[6]:#:name\")\n-        end\n-\n-        def test_large_cdata_is_handled\n-          # see #2132 and https://gitlab.gnome.org/GNOME/libxml2/-/issues/200\n-          skip(\"Upstream libxml2 <= 2.9.10 needs to be patched\") if Nokogiri::VersionInfo.instance.libxml2_using_system?\n-\n-          template = <<~EOF\n-            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-            <soapenv:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:ns=\"http://example.com\">\n-               <soapenv:Header>\n-                  <AuthHeader xsi:type=\"ns:vAuthHeader\">\n-                  <userName xsi:type=\"xsd:string\">gorilla</userName>\n-                  <password xsi:type=\"xsd:string\">secret</password>\n-                </AuthHeader>\n-               </soapenv:Header>\n-              <soapenv:Body>\n-                <ns:checkToken soapenv:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">\n-                  <checkToken xsi:type=\"xsd:string\"><![CDATA[%s]]></checkToken>\n-                </ns:checkToken>\n-               </soapenv:Body>\n-            </soapenv:Envelope>\n-          EOF\n-\n-          factor = 10\n-          huge_data = \"a\" * (1024 * 1024 * factor)\n-          xml = StringIO.new(template % (huge_data))\n-\n-          handler = Nokogiri::SAX::TestCase::Doc.new\n-          parser = Nokogiri::XML::SAX::Parser.new(handler)\n-          parser.parse(xml)\n-\n-          assert_predicate(handler.errors, :empty?)\n-        end\n+class Nokogiri::SAX::TestCase\n+  describe Nokogiri::XML::SAX::Parser do\n+    let(:parser) { Nokogiri::XML::SAX::Parser.new(Doc.new) }\n+\n+    it :test_parser_context_yielded_io do\n+      doc = Doc.new\n+      parser = Nokogiri::XML::SAX::Parser.new(doc)\n+      xml = \"<foo a='&amp;b'/>\"\n+\n+      block_called = false\n+      parser.parse(StringIO.new(xml)) do |ctx|\n+        block_called = true\n+        ctx.replace_entities = true\n       end\n+\n+      assert(block_called)\n+\n+      assert_equal([[\"foo\", [[\"a\", \"&b\"]]]], doc.start_elements)\n+    end\n+\n+    it :test_parser_context_yielded_in_memory do\n+      doc = Doc.new\n+      parser = Nokogiri::XML::SAX::Parser.new(doc)\n+      xml = \"<foo a='&amp;b'/>\"\n+\n+      block_called = false\n+      parser.parse(xml) do |ctx|\n+        block_called = true\n+        ctx.replace_entities = true\n+      end\n+\n+      assert(block_called)\n+\n+      assert_equal([[\"foo\", [[\"a\", \"&b\"]]]], doc.start_elements)\n+    end\n+\n+    it :test_empty_decl do\n+      parser = Nokogiri::XML::SAX::Parser.new(Doc.new)\n+\n+      xml = \"<root />\"\n+      parser.parse(xml)\n+      assert(parser.document.start_document_called, xml)\n+      assert_nil(parser.document.xmldecls, xml)\n+    end\n+\n+    it :test_xml_decl do\n+      [\n+        ['<?xml version=\"1.0\" ?>', [\"1.0\"]],\n+        ['<?xml version=\"1.0\" encoding=\"UTF-8\" ?>', [\"1.0\", \"UTF-8\"]],\n+        ['<?xml version=\"1.0\" standalone=\"yes\"?>', [\"1.0\", \"yes\"]],\n+        ['<?xml version=\"1.0\" standalone=\"no\"?>', [\"1.0\", \"no\"]],\n+        ['<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>', [\"1.0\", \"UTF-8\", \"no\"]],\n+        ['<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?>', [\"1.0\", \"ISO-8859-1\", \"yes\"]],\n+      ].each do |decl, value|\n+        parser = Nokogiri::XML::SAX::Parser.new(Doc.new)\n+\n+        xml = \"#{decl}\\n<root />\"\n+        parser.parse(xml)\n+        assert(parser.document.start_document_called, xml)\n+        assert_equal(value, parser.document.xmldecls, xml)\n+      end\n+    end\n+\n+    it :test_parse_empty do\n+      assert_raises(RuntimeError) do\n+        parser.parse(\"\")\n+      end\n+    end\n+\n+    it :test_namespace_declaration_order_is_saved do\n+      parser.parse(<<~EOF)\n+        <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>\n+          <a foo:bar='hello' />\n+        </root>\n+      EOF\n+      assert_equal(2, parser.document.start_elements_namespace.length)\n+      el = parser.document.start_elements_namespace.first\n+      namespaces = el.last\n+      assert_equal([\"foo\", \"http://foo.example.com/\"], namespaces.first)\n+      assert_equal([nil, \"http://example.com/\"], namespaces.last)\n+    end\n+\n+    it :test_bad_document_calls_error_handler do\n+      parser.parse(\"<foo><bar></foo>\")\n+      assert(parser.document.errors)\n+      assert(parser.document.errors.length > 0)\n+    end\n+\n+    it :test_namespace_are_super_fun_to_parse do\n+      parser.parse(<<~EOF)\n+        <root xmlns:foo='http://foo.example.com/'>\n+          <a foo:bar='hello' />\n+          <b xmlns:foo='http://bar.example.com/'>\n+            <a foo:bar='hello' />\n+          </b>\n+          <foo:bar>hello world</foo:bar>\n+        </root>\n+      EOF\n+\n+      assert(parser.document.start_elements_namespace.length > 0)\n+      el = parser.document.start_elements_namespace[1]\n+      assert_equal(\"a\", el.first)\n+      assert_equal(1, el[1].length)\n+\n+      attribute = el[1].first\n+      assert_equal(\"bar\", attribute.localname)\n+      assert_equal(\"foo\", attribute.prefix)\n+      assert_equal(\"hello\", attribute.value)\n+      assert_equal(\"http://foo.example.com/\", attribute.uri)\n+    end\n+\n+    it :test_sax_v1_namespace_attribute_declarations do\n+      parser.parse(<<~EOF)\n+        <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>\n+          <a foo:bar='hello' />\n+          <b xmlns:foo='http://bar.example.com/'>\n+            <a foo:bar='hello' />\n+          </b>\n+          <foo:bar>hello world</foo:bar>\n+        </root>\n+      EOF\n+      assert(parser.document.start_elements.length > 0)\n+      elm = parser.document.start_elements.first\n+      assert_equal(\"root\", elm.first)\n+      assert(elm[1].include?([\"xmlns:foo\", \"http://foo.example.com/\"]))\n+      assert(elm[1].include?([\"xmlns\", \"http://example.com/\"]))\n+    end\n+\n+    it :test_sax_v1_namespace_nodes do\n+      parser.parse(<<~EOF)\n+        <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>\n+          <a foo:bar='hello' />\n+          <b xmlns:foo='http://bar.example.com/'>\n+            <a foo:bar='hello' />\n+          </b>\n+          <foo:bar>hello world</foo:bar>\n+        </root>\n+      EOF\n+      assert_equal(5, parser.document.start_elements.length)\n+      assert(parser.document.start_elements.map(&:first).include?(\"foo:bar\"))\n+      assert(parser.document.end_elements.map(&:first).include?(\"foo:bar\"))\n+    end\n+\n+    it :test_start_is_called_without_namespace do\n+      parser.parse(<<~EOF)\n+        <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>\n+        <foo:f><bar></foo:f>\n+        </root>\n+      EOF\n+      assert_equal(\n+        [\"root\", \"foo:f\", \"bar\"],\n+        parser.document.start_elements.map(&:first)\n+      )\n+    end\n+\n+    it :test_parser_sets_encoding do\n+      parser = Nokogiri::XML::SAX::Parser.new(Doc.new, \"UTF-8\")\n+      assert_equal(\"UTF-8\", parser.encoding)\n+    end\n+\n+    it :test_errors_set_after_parsing_bad_dom do\n+      doc = Nokogiri::XML(\"<foo><bar></foo>\")\n+      assert(doc.errors)\n+\n+      parser.parse(\"<foo><bar></foo>\")\n+      assert(parser.document.errors)\n+      assert(parser.document.errors.length > 0)\n+\n+      doc.errors.each do |error|\n+        assert_equal(\"UTF-8\", error.message.encoding.name)\n+      end\n+\n+      # when using JRuby Nokogiri, more errors will be generated as the DOM\n+      # parser continue to parse an ill formed document, while the sax parser\n+      # will stop at the first error\n+      unless Nokogiri.jruby?\n+        assert_equal(doc.errors.length, parser.document.errors.length)\n+      end\n+    end\n+\n+    it :test_parse_with_memory_argument do\n+      parser.parse(File.read(XML_FILE))\n+      assert(parser.document.cdata_blocks.length > 0)\n+    end\n+\n+    it :test_parse_with_io_argument do\n+      File.open(XML_FILE, \"rb\") do |f|\n+        parser.parse(f)\n+      end\n+      assert(parser.document.cdata_blocks.length > 0)\n+    end\n+\n+    it :test_parse_io do\n+      call_parse_io_with_encoding(\"UTF-8\")\n+    end\n+\n+    # issue #828\n+    it :test_parse_io_lower_case_encoding do\n+      call_parse_io_with_encoding(\"utf-8\")\n+    end\n+\n+    def call_parse_io_with_encoding(encoding)\n+      File.open(XML_FILE, \"rb\") do |f|\n+        parser.parse_io(f, encoding)\n+      end\n+      assert(parser.document.cdata_blocks.length > 0)\n+\n+      called = false\n+      parser.document.start_elements.flatten.each do |thing|\n+        assert_equal(\"UTF-8\", thing.encoding.name)\n+        called = true\n+      end\n+      assert(called)\n+\n+      called = false\n+      parser.document.end_elements.flatten.each do |thing|\n+        assert_equal(\"UTF-8\", thing.encoding.name)\n+        called = true\n+      end\n+      assert(called)\n+\n+      called = false\n+      parser.document.data.each do |thing|\n+        assert_equal(\"UTF-8\", thing.encoding.name)\n+        called = true\n+      end\n+      assert(called)\n+\n+      called = false\n+      parser.document.comments.flatten.each do |thing|\n+        assert_equal(\"UTF-8\", thing.encoding.name)\n+        called = true\n+      end\n+      assert(called)\n+\n+      called = false\n+      parser.document.cdata_blocks.flatten.each do |thing|\n+        assert_equal(\"UTF-8\", thing.encoding.name)\n+        called = true\n+      end\n+      assert(called)\n+    end\n+\n+    it :test_parse_file do\n+      parser.parse_file(XML_FILE)\n+\n+      assert_raises(ArgumentError) do\n+        parser.parse_file(nil)\n+      end\n+\n+      assert_raises(Errno::ENOENT) do\n+        parser.parse_file(\"\")\n+      end\n+      assert_raises(Errno::EISDIR) do\n+        parser.parse_file(File.expand_path(File.dirname(__FILE__)))\n+      end\n+    end\n+\n+    it :test_render_parse_nil_param do\n+      assert_raises(ArgumentError) { parser.parse_memory(nil) }\n+    end\n+\n+    it :test_bad_encoding_args do\n+      assert_raises(ArgumentError) { Nokogiri::XML::SAX::Parser.new(Doc.new, \"not an encoding\") }\n+      assert_raises(ArgumentError) { parser.parse_io(StringIO.new(\"<root/>\"), \"not an encoding\") }\n+    end\n+\n+    it :test_ctag do\n+      parser.parse_memory(<<~EOF)\n+        <p id=\"asdfasdf\">\n+          <![CDATA[ This is a comment ]]>\n+          Paragraph 1\n+        </p>\n+      EOF\n+      assert_equal([\" This is a comment \"], parser.document.cdata_blocks)\n+    end\n+\n+    it :test_comment do\n+      parser.parse_memory(<<~EOF)\n+        <p id=\"asdfasdf\">\n+          <!-- This is a comment -->\n+          Paragraph 1\n+        </p>\n+      EOF\n+      assert_equal([\" This is a comment \"], parser.document.comments)\n+    end\n+\n+    it :test_characters do\n+      parser.parse_memory(<<~EOF)\n+        <p id=\"asdfasdf\">Paragraph 1</p>\n+      EOF\n+      assert_equal([\"Paragraph 1\"], parser.document.data)\n+    end\n+\n+    it :test_end_document do\n+      parser.parse_memory(<<~EOF)\n+        <p id=\"asdfasdf\">Paragraph 1</p>\n+      EOF\n+      assert(parser.document.end_document_called)\n+    end\n+\n+    it :test_end_element do\n+      parser.parse_memory(<<~EOF)\n+        <p id=\"asdfasdf\">Paragraph 1</p>\n+      EOF\n+      assert_equal([[\"p\"]], parser.document.end_elements)\n+    end\n+\n+    it :test_start_element_attrs do\n+      parser.parse_memory(<<~EOF)\n+        <p id=\"asdfasdf\">Paragraph 1</p>\n+      EOF\n+      assert_equal([[\"p\", [[\"id\", \"asdfasdf\"]]]], parser.document.start_elements)\n+    end\n+\n+    it :test_start_element_attrs_include_namespaces do\n+      parser.parse_memory(<<~EOF)\n+        <p xmlns:foo='http://foo.example.com/'>Paragraph 1</p>\n+      EOF\n+      assert_equal(\n+        [[\"p\", [[\"xmlns:foo\", \"http://foo.example.com/\"]]]],\n+        parser.document.start_elements\n+      )\n+    end\n+\n+    it :test_processing_instruction do\n+      parser.parse_memory(<<~EOF)\n+        <?xml-stylesheet href=\"a.xsl\" type=\"text/xsl\"?>\n+        <?xml version=\"1.0\"?>\n+      EOF\n+      assert_equal(\n+        [[\"xml-stylesheet\", 'href=\"a.xsl\" type=\"text/xsl\"']],\n+        parser.document.processing_instructions\n+      )\n+    end\n+\n+    it :test_parse_document do\n+      skip_unless_libxml2(\"JRuby SAXParser only parses well-formed XML documents\")\n+      parser.parse_memory(<<~EOF)\n+        <p>Paragraph 1</p>\n+        <p>Paragraph 2</p>\n+      EOF\n+    end\n+\n+    it :test_parser_attributes do\n+      xml = <<~EOF\n+        <?xml version=\"1.0\" ?><root><foo a=\"&amp;b\" c=\"&gt;d\" /></root>\n+      EOF\n+\n+      block_called = false\n+      parser.parse(xml) do |ctx|\n+        block_called = true\n+        ctx.replace_entities = true\n+      end\n+\n+      assert(block_called)\n+\n+      assert_equal(\n+        [[\"root\", []], [\"foo\", [[\"a\", \"&b\"], [\"c\", \">d\"]]]], parser.document.start_elements\n+      )\n+    end\n+\n+    it :test_recovery_from_incorrect_xml do\n+      xml = <<~EOF\n+        <?xml version=\"1.0\" ?><Root><Data><?xml version='1.0'?><Item>hey</Item></Data><Data><Item>hey yourself</Item></Data></Root>\n+      EOF\n+\n+      block_called = false\n+      parser.parse(xml) do |ctx|\n+        block_called = true\n+        ctx.recovery = true\n+      end\n+\n+      assert(block_called)\n+\n+      assert_equal(\n+        [[\"Root\", []], [\"Data\", []], [\"Item\", []], [\"Data\", []], [\"Item\", []]],\n+        parser.document.start_elements\n+      )\n+    end\n+\n+    it :test_square_bracket_in_text do\n+      # issue 1261\n+      xml = <<~EOF\n+        <tu tuid=\"87dea04cf60af103ff09d1dba36ae820\" segtype=\"block\">\n+          <prop type=\"x-smartling-string-variant\">en:#:home_page:#:stories:#:[6]:#:name</prop>\n+          <tuv xml:lang=\"en-US\"><seg>Sandy S.</seg></tuv>\n+        </tu>\n+      EOF\n+      parser.parse(xml)\n+      assert_includes(parser.document.data, \"en:#:home_page:#:stories:#:[6]:#:name\")\n+    end\n+\n+    it :test_large_cdata_is_handled do\n+      # see #2132 and https://gitlab.gnome.org/GNOME/libxml2/-/issues/200\n+      skip(\"Upstream libxml2 <= 2.9.10 needs to be patched\") if Nokogiri::VersionInfo.instance.libxml2_using_system?\n+\n+      template = <<~EOF\n+        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+        <soapenv:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:ns=\"http://example.com\">\n+           <soapenv:Header>\n+              <AuthHeader xsi:type=\"ns:vAuthHeader\">\n+              <userName xsi:type=\"xsd:string\">gorilla</userName>\n+              <password xsi:type=\"xsd:string\">secret</password>\n+            </AuthHeader>\n+           </soapenv:Header>\n+          <soapenv:Body>\n+            <ns:checkToken soapenv:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">\n+              <checkToken xsi:type=\"xsd:string\"><![CDATA[%s]]></checkToken>\n+            </ns:checkToken>\n+           </soapenv:Body>\n+        </soapenv:Envelope>\n+      EOF\n+\n+      factor = 10\n+      huge_data = \"a\" * (1024 * 1024 * factor)\n+      xml = StringIO.new(template % huge_data)\n+\n+      handler = Nokogiri::SAX::TestCase::Doc.new\n+      parser = Nokogiri::XML::SAX::Parser.new(handler)\n+      parser.parse(xml)\n+\n+      assert_predicate(handler.errors, :empty?)\n+    end\n+\n+    it \"does not resolve entities by default\" do\n+      xml = <<~EOF\n+        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+        <!DOCTYPE doc [\n+          <!ENTITY local SYSTEM \"file:///#{File.expand_path(__FILE__)}\">\n+          <!ENTITY custom \"resolved>\n+        ]>\n+        <doc><foo>&local;</foo><foo>&custom;</foo></doc>\n+      EOF\n+\n+      doc = Doc.new\n+      parser = Nokogiri::XML::SAX::Parser.new(doc)\n+      parser.parse(xml)\n+\n+      assert_nil(doc.data)\n+    end\n+\n+    it \"does not resolve network external entities by default\" do\n+      xml = <<~EOF\n+        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+        <!DOCTYPE doc [\n+          <!ENTITY remote SYSTEM \"http://0.0.0.0:8080/evil.dtd\">\n+        ]>\n+        <doc><foo>&remote;</foo></doc>\n+      EOF\n+\n+      doc = Doc.new\n+      parser = Nokogiri::XML::SAX::Parser.new(doc)\n+      parser.parse(xml)\n+\n+      assert_nil(doc.data)\n     end\n   end\n end"
        },
        {
          "filename": "test/xml/sax/test_push_parser.rb",
          "status": "modified",
          "additions": 209,
          "deletions": 232,
          "patch": "@@ -1,266 +1,243 @@\n # -*- coding: utf-8 -*-\n+# frozen_string_literal: true\n \n require \"helper\"\n \n-module Nokogiri\n-  module XML\n-    module SAX\n-      class TestPushParser < Nokogiri::SAX::TestCase\n-        def setup\n-          super\n-          @parser = XML::SAX::PushParser.new(Doc.new)\n-        end\n-\n-        def test_exception\n-          assert_raises(SyntaxError) do\n-            @parser << \"<foo /><foo />\"\n-          end\n-\n-          assert_raises(SyntaxError) do\n-            @parser << nil\n-          end\n-        end\n+class Nokogiri::SAX::TestCase\n+  describe Nokogiri::XML::SAX::PushParser do\n+    let(:parser) { Nokogiri::XML::SAX::PushParser.new(Doc.new) }\n \n-        def test_early_finish\n-          @parser << \"<foo>\"\n-          assert_raises(SyntaxError) do\n-            @parser.finish\n-          end\n-        end\n+    it :test_exception do\n+      assert_raises(Nokogiri::XML::SyntaxError) do\n+        parser << \"<foo /><foo />\"\n+      end\n \n-        def test_write_last_chunk\n-          @parser << \"<foo>\"\n-          @parser.write \"</foo>\", true\n-          assert_equal [[\"foo\", []]], @parser.document.start_elements\n-          assert_equal [[\"foo\"]], @parser.document.end_elements\n-        end\n+      assert_raises(Nokogiri::XML::SyntaxError) do\n+        parser << nil\n+      end\n+    end\n \n-        def test_empty_doc\n-          @parser.options |= XML::ParseOptions::RECOVER\n-          @parser.write \"\", true\n-          assert_nil @parser.document.start_elements\n-          assert_nil @parser.document.end_elements\n-        end\n+    it :test_early_finish do\n+      parser << \"<foo>\"\n+      assert_raises(Nokogiri::XML::SyntaxError) do\n+        parser.finish\n+      end\n+    end\n \n+    it :test_write_last_chunk do\n+      parser << \"<foo>\"\n+      parser.write(\"</foo>\", true)\n+      assert_equal [[\"foo\", []]], parser.document.start_elements\n+      assert_equal [[\"foo\"]], parser.document.end_elements\n+    end\n \n-        def test_finish_should_rethrow_last_error\n-          begin\n-            @parser << \"</foo>\"\n-          rescue => e\n-            expected = e\n-          end\n+    it :test_empty_doc do\n+      parser.options |= Nokogiri::XML::ParseOptions::RECOVER\n+      parser.write(\"\", true)\n+      assert_nil parser.document.start_elements\n+      assert_nil parser.document.end_elements\n+    end\n \n-          begin\n-            @parser.finish\n-          rescue => e\n-            actual = e\n-          end\n+    it :test_finish_should_rethrow_last_error do\n+      expected = assert_raise(Nokogiri::XML::SyntaxError) { parser << \"</foo>\" }\n+      actual = assert_raise(Nokogiri::XML::SyntaxError) { parser.finish }\n+      assert_equal actual.message, expected.message\n+    end\n \n-          assert_equal actual.message, expected.message\n+    it :test_should_throw_error_returned_by_document do\n+      doc = Doc.new\n+      class << doc\n+        def error(msg)\n+          raise \"parse error\"\n         end\n+      end\n+      parser = Nokogiri::XML::SAX::PushParser.new(doc)\n \n-        def test_should_throw_error_returned_by_document\n-          doc = Doc.new\n-          class << doc\n-            def error msg\n-              raise \"parse error\"\n-            end\n-          end\n-\n-          @parser = XML::SAX::PushParser.new(doc)\n-          begin\n-            @parser << \"</foo>\"\n-          rescue => e\n-            actual = e\n-          end\n-          fail 'PushParser should throw error when fed ill-formed data' if actual.nil?\n-\n-          assert_equal actual.message, \"parse error\"\n-        end\n+      exception = assert_raise(RuntimeError) { parser << \"</foo>\" }\n+      assert_equal exception.message, \"parse error\"\n+    end\n \n-        def test_writing_nil\n-          assert_equal @parser.write(nil), @parser\n-        end\n+    it :test_writing_nil do\n+      assert_equal parser.write(nil), parser\n+    end\n \n-        def test_end_document_called\n-          @parser.<<(<<-eoxml)\n-            <p id=\"asdfasdf\">\n-              <!-- This is a comment -->\n-              Paragraph 1\n-            </p>\n-          eoxml\n-          assert ! @parser.document.end_document_called\n-          @parser.finish\n-          assert @parser.document.end_document_called\n-        end\n+    it :test_end_document_called do\n+      parser.<<(<<~EOF)\n+        <p id=\"asdfasdf\">\n+          <!-- This is a comment -->\n+          Paragraph 1\n+        </p>\n+      EOF\n+      assert !parser.document.end_document_called\n+      parser.finish\n+      assert parser.document.end_document_called\n+    end\n \n-        def test_start_element\n-          @parser.<<(<<-eoxml)\n-            <p id=\"asdfasdf\">\n-          eoxml\n-\n-          assert_equal [[\"p\", [[\"id\", \"asdfasdf\"]]]],\n-            @parser.document.start_elements\n-\n-          @parser.<<(<<-eoxml)\n-              <!-- This is a comment -->\n-              Paragraph 1\n-            </p>\n-          eoxml\n-          assert_equal [' This is a comment '], @parser.document.comments\n-          @parser.finish\n-        end\n+    it :test_start_element do\n+      parser.<<(<<~EOF)\n+        <p id=\"asdfasdf\">\n+      EOF\n+\n+      assert_equal [[\"p\", [[\"id\", \"asdfasdf\"]]]],\n+        parser.document.start_elements\n+\n+      parser.<<(<<~EOF)\n+          <!-- This is a comment -->\n+          Paragraph 1\n+        </p>\n+      EOF\n+      assert_equal [\" This is a comment \"], parser.document.comments\n+      parser.finish\n+    end\n \n-        def test_start_element_with_namespaces\n-          @parser.<<(<<-eoxml)\n-            <p xmlns:foo=\"http://foo.example.com/\">\n-          eoxml\n-\n-          assert_equal [[\"p\", [[\"xmlns:foo\", \"http://foo.example.com/\"]]]],\n-            @parser.document.start_elements\n-\n-          @parser.<<(<<-eoxml)\n-              <!-- This is a comment -->\n-              Paragraph 1\n-            </p>\n-          eoxml\n-          assert_equal [' This is a comment '], @parser.document.comments\n-          @parser.finish\n-        end\n+    it :test_start_element_with_namespaces do\n+      parser.<<(<<~EOF)\n+        <p xmlns:foo=\"http://foo.example.com/\">\n+      EOF\n+\n+      assert_equal [[\"p\", [[\"xmlns:foo\", \"http://foo.example.com/\"]]]],\n+        parser.document.start_elements\n+\n+      parser.<<(<<~EOF)\n+          <!-- This is a comment -->\n+          Paragraph 1\n+        </p>\n+      EOF\n+      assert_equal [\" This is a comment \"], parser.document.comments\n+      parser.finish\n+    end\n \n-        def test_start_element_ns\n-          @parser.<<(<<-eoxml)\n-            <stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0' size='large'></stream:stream>\n-          eoxml\n+    it :test_start_element_ns do\n+      parser.<<(<<~EOF)\n+        <stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0' size='large'></stream:stream>\n+      EOF\n \n-          assert_equal 1, @parser.document.start_elements_namespace.length\n-          el = @parser.document.start_elements_namespace.first\n+      assert_equal 1, parser.document.start_elements_namespace.length\n+      el = parser.document.start_elements_namespace.first\n \n-          assert_equal 'stream', el.first\n-          assert_equal 2, el[1].length\n-          assert_equal [['version', '1.0'], ['size', 'large']],\n-            el[1].map { |x| [x.localname, x.value] }\n+      assert_equal \"stream\", el.first\n+      assert_equal 2, el[1].length\n+      assert_equal [[\"version\", \"1.0\"], [\"size\", \"large\"]],\n+        el[1].map { |x| [x.localname, x.value] }\n \n-          assert_equal 'stream', el[2]\n-          assert_equal 'http://etherx.jabber.org/streams', el[3]\n-          @parser.finish\n-        end\n+      assert_equal \"stream\", el[2]\n+      assert_equal \"http://etherx.jabber.org/streams\", el[3]\n+      parser.finish\n+    end\n \n-        def test_end_element_ns\n-          @parser.<<(<<-eoxml)\n-            <stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0'></stream:stream>\n-          eoxml\n+    it :test_end_element_ns do\n+      parser.<<(<<~EOF)\n+        <stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0'></stream:stream>\n+      EOF\n \n-          assert_equal [['stream', 'stream', 'http://etherx.jabber.org/streams']],\n-            @parser.document.end_elements_namespace\n-          @parser.finish\n-        end\n+      assert_equal [[\"stream\", \"stream\", \"http://etherx.jabber.org/streams\"]],\n+        parser.document.end_elements_namespace\n+      parser.finish\n+    end\n \n-        def test_chevron_partial_xml\n-          @parser.<<(<<-eoxml)\n-            <p id=\"asdfasdf\">\n-          eoxml\n-\n-          @parser.<<(<<-eoxml)\n-              <!-- This is a comment -->\n-              Paragraph 1\n-            </p>\n-          eoxml\n-          assert_equal [' This is a comment '], @parser.document.comments\n-          @parser.finish\n-        end\n+    it :test_chevron_partial_xml do\n+      parser.<<(<<~EOF)\n+        <p id=\"asdfasdf\">\n+      EOF\n+\n+      parser.<<(<<~EOF)\n+          <!-- This is a comment -->\n+          Paragraph 1\n+        </p>\n+      EOF\n+      assert_equal [\" This is a comment \"], parser.document.comments\n+      parser.finish\n+    end\n \n-        def test_chevron\n-          @parser.<<(<<-eoxml)\n-            <p id=\"asdfasdf\">\n-              <!-- This is a comment -->\n-              Paragraph 1\n-            </p>\n-          eoxml\n-          @parser.finish\n-          assert_equal [' This is a comment '], @parser.document.comments\n-        end\n+    it :test_chevron do\n+      parser.<<(<<~EOF)\n+        <p id=\"asdfasdf\">\n+          <!-- This is a comment -->\n+          Paragraph 1\n+        </p>\n+      EOF\n+      parser.finish\n+      assert_equal [\" This is a comment \"], parser.document.comments\n+    end\n \n-        def test_default_options\n-          assert_equal 0, @parser.options\n-        end\n+    it :test_default_options do\n+      assert_equal 0, parser.options\n+    end\n \n-        def test_recover\n-          @parser.options |= XML::ParseOptions::RECOVER\n-          @parser.<<(<<-eoxml)\n-            <p>\n-              Foo\n-              <bar>\n-              Bar\n-            </p>\n-          eoxml\n-          @parser.finish\n-          assert(@parser.document.errors.size >= 1)\n-          assert_equal [[\"p\", []], [\"bar\", []]], @parser.document.start_elements\n-          assert_equal \"FooBar\", @parser.document.data.map { |x|\n-            x.gsub(/\\s/, '')\n-          }.join\n-        end\n+    it :test_recover do\n+      parser.options |= Nokogiri::XML::ParseOptions::RECOVER\n+      parser.<<(<<~EOF)\n+        <p>\n+          Foo\n+          <bar>\n+          Bar\n+        </p>\n+      EOF\n+      parser.finish\n+      assert(parser.document.errors.size >= 1)\n+      assert_equal [[\"p\", []], [\"bar\", []]], parser.document.start_elements\n+      assert_equal \"FooBar\", parser.document.data.map { |x|\n+        x.gsub(/\\s/, \"\")\n+      }.join\n+    end\n \n-        def test_broken_encoding\n-          skip_unless_libxml2(\"ultra hard to fix for pure Java version\")\n-          @parser.options |= XML::ParseOptions::RECOVER\n-          # This is ISO_8859-1:\n-          @parser.<< \"<?xml version='1.0' encoding='UTF-8'?><r>Gau\\337</r>\"\n-          @parser.finish\n-          assert(@parser.document.errors.size >= 1)\n-          assert_equal \"Gau\\337\", @parser.document.data.join\n-          assert_equal [[\"r\"]], @parser.document.end_elements\n-        end\n+    it :test_broken_encoding do\n+      skip_unless_libxml2(\"ultra hard to fix for pure Java version\")\n+      parser.options |= Nokogiri::XML::ParseOptions::RECOVER\n+      # This is ISO_8859-1:\n+      parser.<< \"<?xml version='1.0' encoding='UTF-8'?><r>Gau\\337</r>\"\n+      parser.finish\n+      assert(parser.document.errors.size >= 1)\n+      assert_equal \"Gau\\337\", parser.document.data.join\n+      assert_equal [[\"r\"]], parser.document.end_elements\n+    end\n \n-        def test_replace_entities_attribute_behavior\n-          if Nokogiri.uses_libxml?\n-            # initially false\n-            assert_equal false, @parser.replace_entities\n-\n-            # can be set to true\n-            @parser.replace_entities = true\n-            assert_equal true, @parser.replace_entities\n-\n-            # can be set to false\n-            @parser.replace_entities = false\n-            assert_equal false, @parser.replace_entities\n-          else\n-            # initially true\n-            assert_equal true, @parser.replace_entities\n-\n-            # ignore attempts to set to false\n-            @parser.replace_entities = false # TODO: should we raise an exception here?\n-            assert_equal true, @parser.replace_entities\n-          end\n-        end\n+    it :test_replace_entities_attribute_behavior do\n+      if Nokogiri.uses_libxml?\n+        # initially false\n+        assert_equal false, parser.replace_entities\n+\n+        # can be set to true\n+        parser.replace_entities = true\n+        assert_equal true, parser.replace_entities\n+\n+        # can be set to false\n+        parser.replace_entities = false\n+        assert_equal false, parser.replace_entities\n+      else\n+        # initially true\n+        assert_equal true, parser.replace_entities\n+\n+        # ignore attempts to set to false\n+        parser.replace_entities = false # TODO: should we raise an exception here?\n+        assert_equal true, parser.replace_entities\n+      end\n+    end\n \n-        def test_untouched_entities\n-          skip_unless_libxml2(\"entities are always replaced in pure Java version\")\n-          @parser.<<(<<-eoxml)\n-            <p id=\"asdf&amp;asdf\">\n-              <!-- This is a comment -->\n-              Paragraph 1 &amp; 2\n-            </p>\n-          eoxml\n-          @parser.finish\n-          assert_equal [[\"p\", [[\"id\", \"asdf&#38;asdf\"]]]], @parser.document.start_elements\n-          assert_equal \"Paragraph 1 & 2\", @parser.document.data.join.strip\n-        end\n+    it :test_untouched_entities do\n+      skip_unless_libxml2(\"entities are always replaced in pure Java version\")\n+      parser.<<(<<~EOF)\n+        <p id=\"asdf&amp;asdf\">\n+          <!-- This is a comment -->\n+          Paragraph 1 &amp; 2\n+        </p>\n+      EOF\n+      parser.finish\n+      assert_equal [[\"p\", [[\"id\", \"asdf&#38;asdf\"]]]], parser.document.start_elements\n+      assert_equal \"Paragraph 1 & 2\", parser.document.data.join.strip\n+    end\n \n-        def test_replaced_entities\n-          @parser.replace_entities = true\n-          @parser.<<(<<-eoxml)\n-            <p id=\"asdf&amp;asdf\">\n-              <!-- This is a comment -->\n-              Paragraph 1 &amp; 2\n-            </p>\n-          eoxml\n-          @parser.finish\n-          assert_equal [[\"p\", [[\"id\", \"asdf&asdf\"]]]], @parser.document.start_elements\n-          assert_equal \"Paragraph 1 & 2\", @parser.document.data.join.strip\n-        end\n-      end\n+    it :test_replaced_entities do\n+      parser.replace_entities = true\n+      parser.<<(<<~EOF)\n+        <p id=\"asdf&amp;asdf\">\n+          <!-- This is a comment -->\n+          Paragraph 1 &amp; 2\n+        </p>\n+      EOF\n+      parser.finish\n+      assert_equal [[\"p\", [[\"id\", \"asdf&asdf\"]]]], parser.document.start_elements\n+      assert_equal \"Paragraph 1 & 2\", parser.document.data.join.strip\n     end\n   end\n end"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 3,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e3750182bc1a46572afd256ae53cc80802cf6759",
            "date": "2025-01-13T16:21:09Z",
            "author_login": "flavorjones"
          },
          {
            "sha": "148dda460759453c1e595c6b6ef6d95f15264743",
            "date": "2025-01-10T15:10:51Z",
            "author_login": "flavorjones"
          },
          {
            "sha": "adc292e5ca0da0db5bde29a241c5057b443593e8",
            "date": "2025-01-10T14:38:07Z",
            "author_login": "flavorjones"
          },
          {
            "sha": "c5cd95a8b1f59e1318906c9f4b8980c48306908b",
            "date": "2025-01-06T19:44:15Z",
            "author_login": "flavorjones"
          },
          {
            "sha": "af5b1b0590e2f365763d1801a4a5106198b47a53",
            "date": "2025-01-06T16:47:04Z",
            "author_login": "flavorjones"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-611",
    "description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri v1.12.4 and earlier, on JRuby only, the SAX parser resolves external entities by default. Users of Nokogiri on JRuby who parse untrusted documents using any of these classes are affected: Nokogiri::XML::SAX::Parse, Nokogiri::HTML4::SAX::Parser or its alias Nokogiri::HTML::SAX::Parser, Nokogiri::XML::SAX::PushParser, and Nokogiri::HTML4::SAX::PushParser or its alias Nokogiri::HTML::SAX::PushParser. JRuby users should upgrade to Nokogiri v1.12.5 or later to receive a patch for this issue. There are no workarounds available for v1.12.4 or earlier. CRuby users are not affected.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-09-27T20:15:07.397",
    "last_modified": "2024-11-21T06:25:27.733",
    "fix_date": "2021-09-26T21:44:03Z"
  },
  "references": [
    {
      "url": "https://github.com/sparklemotion/nokogiri/commit/5bf729ff3cc84709ee3c3248c981584088bf9f6d",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sparklemotion/nokogiri/security/advisories/GHSA-2rr5-8q37-2w7h",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sparklemotion/nokogiri/commit/5bf729ff3cc84709ee3c3248c981584088bf9f6d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sparklemotion/nokogiri/security/advisories/GHSA-2rr5-8q37-2w7h",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:07.790863",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "nokogiri",
    "owner": "sparklemotion",
    "created_at": "2008-07-14T15:34:32Z",
    "updated_at": "2025-01-13T16:21:33Z",
    "pushed_at": "2025-01-13T16:21:28Z",
    "size": 38122,
    "stars": 6162,
    "forks": 905,
    "open_issues": 88,
    "watchers": 6162,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "v1.4.x",
      "v1.5.x",
      "v1.6.4.x",
      "v1.6.6.x"
    ],
    "languages": {
      "C": 1480966,
      "Ruby": 1281868,
      "Java": 657572,
      "C++": 273316,
      "HTML": 97438,
      "Ragel": 97111,
      "Shell": 7585,
      "Dockerfile": 6888,
      "Yacc": 6793,
      "Makefile": 5853,
      "REXX": 1965,
      "XSLT": 1868,
      "CSS": 422,
      "sed": 354
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:05:48.604878"
  }
}