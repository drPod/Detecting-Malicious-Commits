{
  "cve_id": "CVE-2021-41103",
  "github_data": {
    "repository": "containerd/containerd",
    "fix_commit": "5b46e404f6b9f661a205e28d59c982d3634148f8",
    "related_commits": [
      "5b46e404f6b9f661a205e28d59c982d3634148f8",
      "5b46e404f6b9f661a205e28d59c982d3634148f8"
    ],
    "patch_url": "https://github.com/containerd/containerd/commit/5b46e404f6b9f661a205e28d59c982d3634148f8.patch",
    "fix_commit_details": {
      "sha": "5b46e404f6b9f661a205e28d59c982d3634148f8",
      "commit_date": "2021-10-04T15:24:47Z",
      "author": {
        "login": "dmcgowan",
        "type": "User",
        "stats": {
          "total_commits": 1775,
          "average_weekly_commits": 3.69022869022869,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 348
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-c2h3-6mxw-7mvq",
        "length": 110,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 544,
        "additions": 539,
        "deletions": 5
      },
      "files": [
        {
          "filename": "releases/v1.4.11.toml",
          "status": "added",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -0,0 +1,20 @@\n+# commit to be tagged for new release\n+commit = \"HEAD\"\n+\n+project_name = \"containerd\"\n+github_repo = \"containerd/containerd\"\n+match_deps = \"^github.com/(containerd/[a-zA-Z0-9-]+)$\"\n+\n+# previous release\n+previous = \"v1.4.10\"\n+\n+pre_release = false\n+\n+preface = \"\"\"\\\n+The eleventh patch release for containerd 1.4 is a security release to fix CVE-2021-41103.\n+\n+### Notable Updates\n+\n+* **Fix insufficiently restricted permissions on container root and plugin directories** [GHSA-c2h3-6mxw-7mvq](https://github.com/containerd/containerd/security/advisories/GHSA-c2h3-6mxw-7mvq)\n+\n+See the changelog for complete list of changes\"\"\""
        },
        {
          "filename": "runtime/v1/linux/bundle.go",
          "status": "modified",
          "additions": 55,
          "deletions": 1,
          "patch": "@@ -21,6 +21,7 @@ package linux\n import (\n \t\"context\"\n \t\"crypto/sha256\"\n+\t\"encoding/json\"\n \t\"fmt\"\n \t\"io/ioutil\"\n \t\"os\"\n@@ -30,6 +31,7 @@ import (\n \t\"github.com/containerd/containerd/runtime/linux/runctypes\"\n \t\"github.com/containerd/containerd/runtime/v1/shim\"\n \t\"github.com/containerd/containerd/runtime/v1/shim/client\"\n+\t\"github.com/opencontainers/runtime-spec/specs-go\"\n \t\"github.com/pkg/errors\"\n )\n \n@@ -48,14 +50,17 @@ func newBundle(id, path, workDir string, spec []byte) (b *bundle, err error) {\n \t\treturn nil, err\n \t}\n \tpath = filepath.Join(path, id)\n-\tif err := os.Mkdir(path, 0711); err != nil {\n+\tif err := os.Mkdir(path, 0700); err != nil {\n \t\treturn nil, err\n \t}\n \tdefer func() {\n \t\tif err != nil {\n \t\t\tos.RemoveAll(path)\n \t\t}\n \t}()\n+\tif err := prepareBundleDirectoryPermissions(path, spec); err != nil {\n+\t\treturn nil, err\n+\t}\n \tworkDir = filepath.Join(workDir, id)\n \tif err := os.MkdirAll(workDir, 0711); err != nil {\n \t\treturn nil, err\n@@ -77,6 +82,55 @@ func newBundle(id, path, workDir string, spec []byte) (b *bundle, err error) {\n \t}, err\n }\n \n+// prepareBundleDirectoryPermissions prepares the permissions of the bundle\n+// directory. When user namespaces are enabled, the permissions are modified\n+// to allow the remapped root GID to access the bundle.\n+func prepareBundleDirectoryPermissions(path string, spec []byte) error {\n+\tgid, err := remappedGID(spec)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif gid == 0 {\n+\t\treturn nil\n+\t}\n+\tif err := os.Chown(path, -1, int(gid)); err != nil {\n+\t\treturn err\n+\t}\n+\treturn os.Chmod(path, 0710)\n+}\n+\n+// ociSpecUserNS is a subset of specs.Spec used to reduce garbage during\n+// unmarshal.\n+type ociSpecUserNS struct {\n+\tLinux *linuxSpecUserNS\n+}\n+\n+// linuxSpecUserNS is a subset of specs.Linux used to reduce garbage during\n+// unmarshal.\n+type linuxSpecUserNS struct {\n+\tGIDMappings []specs.LinuxIDMapping\n+}\n+\n+// remappedGID reads the remapped GID 0 from the OCI spec, if it exists. If\n+// there is no remapping, remappedGID returns 0. If the spec cannot be parsed,\n+// remappedGID returns an error.\n+func remappedGID(spec []byte) (uint32, error) {\n+\tvar ociSpec ociSpecUserNS\n+\terr := json.Unmarshal(spec, &ociSpec)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\tif ociSpec.Linux == nil || len(ociSpec.Linux.GIDMappings) == 0 {\n+\t\treturn 0, nil\n+\t}\n+\tfor _, mapping := range ociSpec.Linux.GIDMappings {\n+\t\tif mapping.ContainerID == 0 {\n+\t\t\treturn mapping.HostID, nil\n+\t\t}\n+\t}\n+\treturn 0, nil\n+}\n+\n type bundle struct {\n \tid      string\n \tpath    string"
        },
        {
          "filename": "runtime/v1/linux/bundle_test.go",
          "status": "added",
          "additions": 166,
          "deletions": 0,
          "patch": "@@ -0,0 +1,166 @@\n+//go:build linux\n+// +build linux\n+\n+/*\n+   Copyright The containerd Authors.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package linux\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strconv\"\n+\t\"syscall\"\n+\t\"testing\"\n+\n+\t\"github.com/containerd/containerd/oci\"\n+\t\"github.com/containerd/continuity/testutil\"\n+\t\"github.com/opencontainers/runtime-spec/specs-go\"\n+)\n+\n+func TestNewBundle(t *testing.T) {\n+\ttestutil.RequiresRoot(t)\n+\ttests := []struct {\n+\t\tuserns bool\n+\t}{{\n+\t\tuserns: false,\n+\t}, {\n+\t\tuserns: true,\n+\t}}\n+\tconst usernsGID = 4200\n+\n+\tfor i, tc := range tests {\n+\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n+\t\t\tdir, err := ioutil.TempDir(\"\", \"test-new-bundle\")\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(\"failed to create test directory\", err)\n+\t\t\t}\n+\t\t\tdefer os.RemoveAll(dir)\n+\t\t\twork := filepath.Join(dir, \"work\")\n+\t\t\tstate := filepath.Join(dir, \"state\")\n+\t\t\tid := fmt.Sprintf(\"new-bundle-%d\", i)\n+\t\t\tspec := oci.Spec{}\n+\t\t\tif tc.userns {\n+\t\t\t\tspec.Linux = &specs.Linux{\n+\t\t\t\t\tGIDMappings: []specs.LinuxIDMapping{{ContainerID: 0, HostID: usernsGID}},\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tspecBytes, err := json.Marshal(&spec)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(\"failed to marshal spec\", err)\n+\t\t\t}\n+\n+\t\t\tb, err := newBundle(id, work, state, specBytes)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(\"newBundle should succeed\", err)\n+\t\t\t}\n+\t\t\tif b == nil {\n+\t\t\t\tt.Fatal(\"bundle should not be nil\")\n+\t\t\t}\n+\n+\t\t\tfi, err := os.Stat(b.path)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Error(\"should be able to stat bundle path\", err)\n+\t\t\t}\n+\t\t\tif tc.userns {\n+\t\t\t\tif fi.Mode() != os.ModeDir|0710 {\n+\t\t\t\t\tt.Error(\"bundle path should be a directory with perm 0710\")\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif fi.Mode() != os.ModeDir|0700 {\n+\t\t\t\t\tt.Error(\"bundle path should be a directory with perm 0700\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tstat, ok := fi.Sys().(*syscall.Stat_t)\n+\t\t\tif !ok {\n+\t\t\t\tt.Fatal(\"should assert to *syscall.Stat_t\")\n+\t\t\t}\n+\t\t\texpectedGID := uint32(0)\n+\t\t\tif tc.userns {\n+\t\t\t\texpectedGID = usernsGID\n+\t\t\t}\n+\t\t\tif stat.Gid != expectedGID {\n+\t\t\t\tt.Error(\"gid should match\", expectedGID, stat.Gid)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestRemappedGID(t *testing.T) {\n+\ttests := []struct {\n+\t\tspec oci.Spec\n+\t\tgid  uint32\n+\t}{{\n+\t\t// empty spec\n+\t\tspec: oci.Spec{},\n+\t\tgid:  0,\n+\t}, {\n+\t\t// empty Linux section\n+\t\tspec: oci.Spec{\n+\t\t\tLinux: &specs.Linux{},\n+\t\t},\n+\t\tgid: 0,\n+\t}, {\n+\t\t// empty ID mappings\n+\t\tspec: oci.Spec{\n+\t\t\tLinux: &specs.Linux{\n+\t\t\t\tGIDMappings: make([]specs.LinuxIDMapping, 0),\n+\t\t\t},\n+\t\t},\n+\t\tgid: 0,\n+\t}, {\n+\t\t// valid ID mapping\n+\t\tspec: oci.Spec{\n+\t\t\tLinux: &specs.Linux{\n+\t\t\t\tGIDMappings: []specs.LinuxIDMapping{{\n+\t\t\t\t\tContainerID: 0,\n+\t\t\t\t\tHostID:      1000,\n+\t\t\t\t}},\n+\t\t\t},\n+\t\t},\n+\t\tgid: 1000,\n+\t}, {\n+\t\t// missing ID mapping\n+\t\tspec: oci.Spec{\n+\t\t\tLinux: &specs.Linux{\n+\t\t\t\tGIDMappings: []specs.LinuxIDMapping{{\n+\t\t\t\t\tContainerID: 100,\n+\t\t\t\t\tHostID:      1000,\n+\t\t\t\t}},\n+\t\t\t},\n+\t\t},\n+\t\tgid: 0,\n+\t}}\n+\n+\tfor i, tc := range tests {\n+\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n+\t\t\ts, err := json.Marshal(tc.spec)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(\"failed to marshal spec\", err)\n+\t\t\t}\n+\t\t\tgid, err := remappedGID(s)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Error(\"should unmarshal successfully\", err)\n+\t\t\t}\n+\t\t\tif gid != tc.gid {\n+\t\t\t\tt.Error(\"expected GID to match\", tc.gid, gid)\n+\t\t\t}\n+\t\t})\n+\t}\n+}"
        },
        {
          "filename": "runtime/v2/bundle.go",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -72,7 +72,10 @@ func NewBundle(ctx context.Context, root, state, id string, spec []byte) (b *Bun\n \tif err := os.MkdirAll(filepath.Dir(b.Path), 0711); err != nil {\n \t\treturn nil, err\n \t}\n-\tif err := os.Mkdir(b.Path, 0711); err != nil {\n+\tif err := os.Mkdir(b.Path, 0700); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif err := prepareBundleDirectoryPermissions(b.Path, spec); err != nil {\n \t\treturn nil, err\n \t}\n \tpaths = append(paths, b.Path)"
        },
        {
          "filename": "runtime/v2/bundle_default.go",
          "status": "added",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -0,0 +1,24 @@\n+//go:build !linux\n+// +build !linux\n+\n+/*\n+   Copyright The containerd Authors.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package v2\n+\n+// prepareBundleDirectoryPermissions prepares the permissions of the bundle\n+// directory according to the needs of the current platform.\n+func prepareBundleDirectoryPermissions(path string, spec []byte) error { return nil }"
        },
        {
          "filename": "runtime/v2/bundle_linux.go",
          "status": "added",
          "additions": 74,
          "deletions": 0,
          "patch": "@@ -0,0 +1,74 @@\n+/*\n+   Copyright The containerd Authors.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package v2\n+\n+import (\n+\t\"encoding/json\"\n+\t\"os\"\n+\n+\t\"github.com/opencontainers/runtime-spec/specs-go\"\n+)\n+\n+// prepareBundleDirectoryPermissions prepares the permissions of the bundle\n+// directory according to the needs of the current platform.\n+// On Linux when user namespaces are enabled, the permissions are modified to\n+// allow the remapped root GID to access the bundle.\n+func prepareBundleDirectoryPermissions(path string, spec []byte) error {\n+\tgid, err := remappedGID(spec)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif gid == 0 {\n+\t\treturn nil\n+\t}\n+\tif err := os.Chown(path, -1, int(gid)); err != nil {\n+\t\treturn err\n+\t}\n+\treturn os.Chmod(path, 0710)\n+}\n+\n+// ociSpecUserNS is a subset of specs.Spec used to reduce garbage during\n+// unmarshal.\n+type ociSpecUserNS struct {\n+\tLinux *linuxSpecUserNS\n+}\n+\n+// linuxSpecUserNS is a subset of specs.Linux used to reduce garbage during\n+// unmarshal.\n+type linuxSpecUserNS struct {\n+\tGIDMappings []specs.LinuxIDMapping\n+}\n+\n+// remappedGID reads the remapped GID 0 from the OCI spec, if it exists. If\n+// there is no remapping, remappedGID returns 0. If the spec cannot be parsed,\n+// remappedGID returns an error.\n+func remappedGID(spec []byte) (uint32, error) {\n+\tvar ociSpec ociSpecUserNS\n+\terr := json.Unmarshal(spec, &ociSpec)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\tif ociSpec.Linux == nil || len(ociSpec.Linux.GIDMappings) == 0 {\n+\t\treturn 0, nil\n+\t}\n+\tfor _, mapping := range ociSpec.Linux.GIDMappings {\n+\t\tif mapping.ContainerID == 0 {\n+\t\t\treturn mapping.HostID, nil\n+\t\t}\n+\t}\n+\treturn 0, nil\n+}"
        },
        {
          "filename": "runtime/v2/bundle_linux_test.go",
          "status": "added",
          "additions": 166,
          "deletions": 0,
          "patch": "@@ -0,0 +1,166 @@\n+/*\n+   Copyright The containerd Authors.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package v2\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strconv\"\n+\t\"syscall\"\n+\t\"testing\"\n+\n+\t\"github.com/containerd/containerd/namespaces\"\n+\t\"github.com/containerd/containerd/oci\"\n+\t\"github.com/containerd/containerd/pkg/testutil\"\n+\t\"github.com/opencontainers/runtime-spec/specs-go\"\n+)\n+\n+func TestNewBundle(t *testing.T) {\n+\ttestutil.RequiresRoot(t)\n+\ttests := []struct {\n+\t\tuserns bool\n+\t}{{\n+\t\tuserns: false,\n+\t}, {\n+\t\tuserns: true,\n+\t}}\n+\tconst usernsGID = 4200\n+\n+\tfor i, tc := range tests {\n+\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n+\t\t\tdir, err := ioutil.TempDir(\"\", \"test-new-bundle\")\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(\"failed to create test directory\", err)\n+\t\t\t}\n+\t\t\tdefer os.RemoveAll(dir)\n+\t\t\twork := filepath.Join(dir, \"work\")\n+\t\t\tstate := filepath.Join(dir, \"state\")\n+\t\t\tid := fmt.Sprintf(\"new-bundle-%d\", i)\n+\t\t\tspec := oci.Spec{}\n+\t\t\tif tc.userns {\n+\t\t\t\tspec.Linux = &specs.Linux{\n+\t\t\t\t\tGIDMappings: []specs.LinuxIDMapping{{ContainerID: 0, HostID: usernsGID}},\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tspecBytes, err := json.Marshal(&spec)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(\"failed to marshal spec\", err)\n+\t\t\t}\n+\n+\t\t\tctx := namespaces.WithNamespace(context.TODO(), namespaces.Default)\n+\t\t\tb, err := NewBundle(ctx, work, state, id, specBytes)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(\"NewBundle should succeed\", err)\n+\t\t\t}\n+\t\t\tif b == nil {\n+\t\t\t\tt.Fatal(\"bundle should not be nil\")\n+\t\t\t}\n+\n+\t\t\tfi, err := os.Stat(b.Path)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Error(\"should be able to stat bundle path\", err)\n+\t\t\t}\n+\t\t\tif tc.userns {\n+\t\t\t\tif fi.Mode() != os.ModeDir|0710 {\n+\t\t\t\t\tt.Error(\"bundle path should be a directory with perm 0710\")\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif fi.Mode() != os.ModeDir|0700 {\n+\t\t\t\t\tt.Error(\"bundle path should be a directory with perm 0700\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tstat, ok := fi.Sys().(*syscall.Stat_t)\n+\t\t\tif !ok {\n+\t\t\t\tt.Fatal(\"should assert to *syscall.Stat_t\")\n+\t\t\t}\n+\t\t\texpectedGID := uint32(0)\n+\t\t\tif tc.userns {\n+\t\t\t\texpectedGID = usernsGID\n+\t\t\t}\n+\t\t\tif expectedGID != stat.Gid {\n+\t\t\t\tt.Error(\"gid should match\", expectedGID, stat.Gid)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestRemappedGID(t *testing.T) {\n+\ttests := []struct {\n+\t\tspec oci.Spec\n+\t\tgid  uint32\n+\t}{{\n+\t\t// empty spec\n+\t\tspec: oci.Spec{},\n+\t\tgid:  0,\n+\t}, {\n+\t\t// empty Linux section\n+\t\tspec: oci.Spec{\n+\t\t\tLinux: &specs.Linux{},\n+\t\t},\n+\t\tgid: 0,\n+\t}, {\n+\t\t// empty ID mappings\n+\t\tspec: oci.Spec{\n+\t\t\tLinux: &specs.Linux{\n+\t\t\t\tGIDMappings: make([]specs.LinuxIDMapping, 0),\n+\t\t\t},\n+\t\t},\n+\t\tgid: 0,\n+\t}, {\n+\t\t// valid ID mapping\n+\t\tspec: oci.Spec{\n+\t\t\tLinux: &specs.Linux{\n+\t\t\t\tGIDMappings: []specs.LinuxIDMapping{{\n+\t\t\t\t\tContainerID: 0,\n+\t\t\t\t\tHostID:      1000,\n+\t\t\t\t}},\n+\t\t\t},\n+\t\t},\n+\t\tgid: 1000,\n+\t}, {\n+\t\t// missing ID mapping\n+\t\tspec: oci.Spec{\n+\t\t\tLinux: &specs.Linux{\n+\t\t\t\tGIDMappings: []specs.LinuxIDMapping{{\n+\t\t\t\t\tContainerID: 100,\n+\t\t\t\t\tHostID:      1000,\n+\t\t\t\t}},\n+\t\t\t},\n+\t\t},\n+\t\tgid: 0,\n+\t}}\n+\n+\tfor i, tc := range tests {\n+\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n+\t\t\ts, err := json.Marshal(tc.spec)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(\"failed to marshal spec\", err)\n+\t\t\t}\n+\t\t\tgid, err := remappedGID(s)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Error(\"should unmarshal successfully\", err)\n+\t\t\t}\n+\t\t\tif tc.gid != gid {\n+\t\t\t\tt.Error(\"expected GID to match\", tc.gid, gid)\n+\t\t\t}\n+\t\t})\n+\t}\n+}"
        },
        {
          "filename": "runtime/v2/bundle_test.go",
          "status": "added",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -0,0 +1,23 @@\n+/*\n+   Copyright The containerd Authors.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package v2\n+\n+import (\n+\t// When testutil is imported for one platform (bundle_linux_test.go) it\n+\t// should be imported for all platforms.\n+\t_ \"github.com/containerd/containerd/pkg/testutil\"\n+)"
        },
        {
          "filename": "snapshots/btrfs/btrfs.go",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -63,11 +63,15 @@ type snapshotter struct {\n // root needs to be a mount point of btrfs.\n func NewSnapshotter(root string) (snapshots.Snapshotter, error) {\n \t// If directory does not exist, create it\n-\tif _, err := os.Stat(root); err != nil {\n+\tif st, err := os.Stat(root); err != nil {\n \t\tif !os.IsNotExist(err) {\n \t\t\treturn nil, err\n \t\t}\n-\t\tif err := os.Mkdir(root, 0755); err != nil {\n+\t\tif err := os.Mkdir(root, 0700); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t} else if st.Mode()&os.ModePerm != 0700 {\n+\t\tif err := os.Chmod(root, 0700); err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t}"
        },
        {
          "filename": "version/version.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -23,7 +23,7 @@ var (\n \tPackage = \"github.com/containerd/containerd\"\n \n \t// Version holds the complete version number. Filled in at linking time.\n-\tVersion = \"1.4.10+unknown\"\n+\tVersion = \"1.4.11+unknown\"\n \n \t// Revision is filled with the VCS (e.g. git) revision being used to build\n \t// the program at linking time."
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 5,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "432d32cd9dc739c04441202b6287063e67bdec3e",
            "date": "2025-01-14T14:08:26Z",
            "author_login": "fuweid"
          },
          {
            "sha": "d44d76186391365d6e251527bbbe5007e5c760b6",
            "date": "2025-01-14T07:56:05Z",
            "author_login": "samuelkarp"
          },
          {
            "sha": "04bac22dfc99d0d9991ba33e4b05b7d85bd86548",
            "date": "2025-01-14T07:27:22Z",
            "author_login": "AkihiroSuda"
          },
          {
            "sha": "b87d67fcc2795b662c6445f7960242e24e743cbd",
            "date": "2025-01-14T07:26:35Z",
            "author_login": "samuelkarp"
          },
          {
            "sha": "bdc847f1eb535a6728b6db3f2619d2a5ed0edbb9",
            "date": "2025-01-14T06:01:10Z",
            "author_login": "dmcgowan"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.8,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-22",
    "description": "containerd is an open source container runtime with an emphasis on simplicity, robustness and portability. A bug was found in containerd where container root directories and some plugins had insufficiently restricted permissions, allowing otherwise unprivileged Linux users to traverse directory contents and execute programs. When containers included executable programs with extended permission bits (such as setuid), unprivileged Linux users could discover and execute those programs. When the UID of an unprivileged Linux user on the host collided with the file owner or group inside a container, the unprivileged Linux user on the host could discover, read, and modify those files. This vulnerability has been fixed in containerd 1.4.11 and containerd 1.5.7. Users should update to these version when they are released and may restart containers or update directory permissions to mitigate the vulnerability. Users unable to update should limit access to the host to trusted users. Update directory permission on container bundles directories.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-10-04T17:15:08.517",
    "last_modified": "2024-11-21T06:25:28.423",
    "fix_date": "2021-10-04T15:24:47Z"
  },
  "references": [
    {
      "url": "https://cert-portal.siemens.com/productcert/pdf/ssa-222547.pdf",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/containerd/containerd/commit/5b46e404f6b9f661a205e28d59c982d3634148f8",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/containerd/containerd/security/advisories/GHSA-c2h3-6mxw-7mvq",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/B5Q6G6I4W5COQE25QMC7FJY3I3PAYFBB/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ZNFADTCHHYWVM6W4NJ6CB4FNFM2VMBIB/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202401-31",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://www.debian.org/security/2021/dsa-5002",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://cert-portal.siemens.com/productcert/pdf/ssa-222547.pdf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/containerd/containerd/commit/5b46e404f6b9f661a205e28d59c982d3634148f8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/containerd/containerd/security/advisories/GHSA-c2h3-6mxw-7mvq",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/B5Q6G6I4W5COQE25QMC7FJY3I3PAYFBB/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ZNFADTCHHYWVM6W4NJ6CB4FNFM2VMBIB/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202401-31",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://www.debian.org/security/2021/dsa-5002",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:07.805906",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "containerd",
    "owner": "containerd",
    "created_at": "2015-11-13T00:27:43Z",
    "updated_at": "2025-01-14T14:43:38Z",
    "pushed_at": "2025-01-14T14:43:31Z",
    "size": 158285,
    "stars": 17816,
    "forks": 3512,
    "open_issues": 357,
    "watchers": 17816,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release/1.0",
      "release/1.1",
      "release/1.2",
      "release/1.3",
      "release/1.4",
      "release/1.5",
      "release/1.6",
      "release/1.7",
      "release/2.0"
    ],
    "languages": {
      "Go": 5381141,
      "Shell": 94349,
      "Makefile": 26121,
      "PowerShell": 6191,
      "jq": 4089,
      "Dockerfile": 3995
    },
    "commit_activity": {
      "total_commits_last_year": 1314,
      "avg_commits_per_week": 25.26923076923077,
      "days_active_last_year": 277
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:50:55.249369"
  }
}