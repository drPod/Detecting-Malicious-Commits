{
  "cve_id": "CVE-2021-41130",
  "github_data": {
    "repository": "cloudendpoints/esp",
    "fix_commit": "e310c4f91d229a072507f80c73811489b4cdff27",
    "related_commits": [
      "e310c4f91d229a072507f80c73811489b4cdff27",
      "e310c4f91d229a072507f80c73811489b4cdff27"
    ],
    "patch_url": "https://github.com/cloudendpoints/esp/commit/e310c4f91d229a072507f80c73811489b4cdff27.patch",
    "fix_commit_details": {
      "sha": "e310c4f91d229a072507f80c73811489b4cdff27",
      "commit_date": "2021-08-31T05:05:31Z",
      "author": {
        "login": "shuoyang2016",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Remove X-Endpoint-API-UserInfo for all header occurrences. (#845)",
        "length": 65,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 99,
        "additions": 62,
        "deletions": 37
      },
      "files": [
        {
          "filename": "include/api_manager/request.h",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -74,7 +74,8 @@ class Request {\n \n   // Adds a header to backend. If the header exists, overwrite its value\n   virtual utils::Status AddHeaderToBackend(const std::string &key,\n-                                           const std::string &value) = 0;\n+                                           const std::string &value,\n+                                           bool changeAllOccurrence) = 0;\n };\n \n }  // namespace api_manager"
        },
        {
          "filename": "src/api_manager/check_auth.cc",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -393,7 +393,7 @@ void AuthChecker::PassUserInfoOnSuccess() {\n   char *base64_json_buf = auth::esp_base64_encode(\n       json_buf, strlen(json_buf), true, false, true /*padding*/);\n   context_->request()->AddHeaderToBackend(auth::kEndpointApiUserInfo,\n-                                          base64_json_buf);\n+                                          base64_json_buf, false);\n   auth::esp_grpc_free(json_buf);\n   auth::esp_grpc_free(base64_json_buf);\n "
        },
        {
          "filename": "src/api_manager/check_auth_test.cc",
          "status": "modified",
          "additions": 7,
          "deletions": 7,
          "patch": "@@ -458,7 +458,7 @@ void CheckAuthTest::TestValidToken(const std::string &auth_token,\n       }));\n   std::cout << \"need be replaced: \" << user_info << std::endl;\n   EXPECT_CALL(*raw_request_,\n-              AddHeaderToBackend(kEndpointApiUserInfo, user_info))\n+              AddHeaderToBackend(kEndpointApiUserInfo, user_info, false))\n       .WillOnce(Return(utils::Status::OK));\n \n   CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n@@ -490,8 +490,8 @@ TEST_F(CheckAuthTest, TestOKAuth) {\n       }));\n   EXPECT_CALL(*raw_request_, SetAuthToken(kToken)).Times(1);\n   EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_)).Times(0);\n-  EXPECT_CALL(*raw_request_,\n-              AddHeaderToBackend(kEndpointApiUserInfo, kUserInfo_kSub_kIss))\n+  EXPECT_CALL(*raw_request_, AddHeaderToBackend(kEndpointApiUserInfo,\n+                                                kUserInfo_kSub_kIss, false))\n       .WillOnce(Return(utils::Status::OK));\n \n   CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n@@ -513,8 +513,8 @@ TEST_F(CheckAuthTest, TestOKAuth) {\n       }));\n   EXPECT_CALL(*raw_request_, SetAuthToken(kToken2)).Times(1);\n   EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_)).Times(0);\n-  EXPECT_CALL(*raw_request_,\n-              AddHeaderToBackend(kEndpointApiUserInfo, kUserInfo_kSub2_kIss2))\n+  EXPECT_CALL(*raw_request_, AddHeaderToBackend(kEndpointApiUserInfo,\n+                                                kUserInfo_kSub2_kIss2, false))\n       .WillOnce(Return(utils::Status::OK));\n \n   CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n@@ -605,8 +605,8 @@ TEST_F(CheckAuthTest, TestNoOpenId) {\n         std::map<std::string, std::string> empty;\n         req->OnComplete(Status::OK, std::move(empty), std::move(body));\n       }));\n-  EXPECT_CALL(*raw_request_,\n-              AddHeaderToBackend(kEndpointApiUserInfo, kUserInfo_kSub_kIss2))\n+  EXPECT_CALL(*raw_request_, AddHeaderToBackend(kEndpointApiUserInfo,\n+                                                kUserInfo_kSub_kIss2, false))\n       .WillOnce(Return(utils::Status::OK));\n \n   CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });"
        },
        {
          "filename": "src/api_manager/check_service_control.cc",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -15,6 +15,7 @@\n ////////////////////////////////////////////////////////////////////////////////\n // includes should be ordered. This seems like a bug in clang-format?\n #include \"src/api_manager/check_service_control.h\"\n+\n #include \"google/protobuf/stubs/status.h\"\n #include \"src/api_manager/cloud_trace/cloud_trace.h\"\n \n@@ -85,8 +86,8 @@ void CheckServiceControl(std::shared_ptr<context::RequestContext> context,\n \n         // update consumer_project_id to service context\n         if (!info.consumer_project_id.empty()) {\n-          context->request()->AddHeaderToBackend(kConsumerProjecId,\n-                                                 info.consumer_project_id);\n+          context->request()->AddHeaderToBackend(\n+              kConsumerProjecId, info.consumer_project_id, false);\n         }\n \n         continuation(status);"
        },
        {
          "filename": "src/api_manager/context/client_ip_extraction_test.cc",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -117,8 +117,8 @@ class MockRequest : public Request {\n     return false;\n   }\n \n-  MOCK_METHOD2(AddHeaderToBackend,\n-               utils::Status(const std::string &, const std::string &));\n+  MOCK_METHOD3(AddHeaderToBackend,\n+               utils::Status(const std::string &, const std::string &, bool));\n   MOCK_METHOD1(SetAuthToken, void(const std::string &));\n   MOCK_METHOD0(GetFrontendProtocol,\n                ::google::api_manager::protocol::Protocol());"
        },
        {
          "filename": "src/api_manager/context/request_context.cc",
          "status": "modified",
          "additions": 10,
          "deletions": 8,
          "patch": "@@ -16,15 +16,17 @@\n //\n \n #include \"src/api_manager/context/request_context.h\"\n-#include \"google/api/backend.pb.h\"\n-#include \"src/api_manager/auth/lib/json_util.h\"\n-#include \"src/api_manager/utils/str_util.h\"\n \n #include <uuid/uuid.h>\n+\n #include <numeric>\n #include <sstream>\n #include <vector>\n \n+#include \"google/api/backend.pb.h\"\n+#include \"src/api_manager/auth/lib/json_util.h\"\n+#include \"src/api_manager/utils/str_util.h\"\n+\n using ::google::api_manager::auth::GetPrimitiveFieldValue;\n using ::google::api_manager::cloud_trace::HeaderType;\n using ::google::api_manager::utils::Status;\n@@ -208,7 +210,7 @@ void RequestContext::ExtractApiKey() {\n }\n \n void RequestContext::SetApiKeyHeader() {\n-  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_);\n+  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_, false);\n }\n \n void RequestContext::CompleteCheck(Status status) {\n@@ -434,7 +436,7 @@ void RequestContext::StartBackendSpanAndSetTraceContext() {\n       cloud_trace()->header_type() == HeaderType::CLOUD_TRACE_CONTEXT\n           ? kCloudTraceContextHeader\n           : kGRpcTraceContextHeader,\n-      trace_context_header);\n+      trace_context_header, false);\n   if (!status.ok()) {\n     service_context()->env()->LogError(\n         \"Failed to set trace context header to backend.\");\n@@ -535,14 +537,14 @@ void RequestContext::AddInstanceIdentityToken() {\n       std::string origin_auth_header;\n       if (request()->FindHeader(kAuthorizationHeader, &origin_auth_header)) {\n         Status status = request()->AddHeaderToBackend(\n-            kXForwardedAuthorizationHeader, origin_auth_header);\n+            kXForwardedAuthorizationHeader, origin_auth_header, false);\n         if (!status.ok()) {\n           service_context()->env()->LogError(\n               \"Failed to set X-Forwarded-Authorization header to backend.\");\n         }\n       }\n-      Status status = request()->AddHeaderToBackend(kAuthorizationHeader,\n-                                                    kBearerPrefix + token);\n+      Status status = request()->AddHeaderToBackend(\n+          kAuthorizationHeader, kBearerPrefix + token, false);\n       if (!status.ok()) {\n         service_context()->env()->LogError(\n             \"Failed to set authorization header to backend.\");"
        },
        {
          "filename": "src/api_manager/mock_request.h",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -25,8 +25,8 @@ class MockRequest : public Request {\n  public:\n   MOCK_METHOD2(FindQuery, bool(const std::string &, std::string *));\n   MOCK_METHOD2(FindHeader, bool(const std::string &, std::string *));\n-  MOCK_METHOD2(AddHeaderToBackend,\n-               utils::Status(const std::string &, const std::string &));\n+  MOCK_METHOD3(AddHeaderToBackend,\n+               utils::Status(const std::string &, const std::string &, bool));\n   MOCK_METHOD1(SetAuthToken, void(const std::string &));\n   MOCK_METHOD0(GetRequestHTTPMethod, std::string());\n   MOCK_METHOD0(GetQueryParameters, std::string());"
        },
        {
          "filename": "src/api_manager/request_handler.cc",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -43,7 +43,7 @@ RequestHandler::RequestHandler(\n   if (context_->request()->FindHeader(\n           google::api_manager::auth::kEndpointApiUserInfo, &buffer)) {\n     context_->request()->AddHeaderToBackend(\n-        google::api_manager::auth::kEndpointApiUserInfo, \"\");\n+        google::api_manager::auth::kEndpointApiUserInfo, \"\", true);\n   }\n }\n "
        },
        {
          "filename": "src/nginx/request.cc",
          "status": "modified",
          "additions": 21,
          "deletions": 11,
          "patch": "@@ -146,18 +146,21 @@ void NgxEspRequest::SetAuthToken(const std::string &auth_token) {\n }\n \n utils::Status NgxEspRequest::AddHeaderToBackend(const std::string &key,\n-                                                const std::string &value) {\n-  ngx_table_elt_t *h = nullptr;\n+                                                const std::string &value,\n+                                                bool changeAllOccurrence) {\n+  std::vector<ngx_table_elt_t *> headers;\n   for (auto &h_in : r_->headers_in) {\n     if (key.size() == h_in.key.len &&\n         strncasecmp(key.c_str(), reinterpret_cast<const char *>(h_in.key.data),\n                     h_in.key.len) == 0) {\n-      h = &h_in;\n-      break;\n+      headers.push_back(&h_in);\n+      if (!changeAllOccurrence) {\n+        break;\n+      }\n     }\n   }\n-  if (h == nullptr) {\n-    h = reinterpret_cast<ngx_table_elt_t *>(\n+  if (headers.empty()) {\n+    ngx_table_elt_t *h = reinterpret_cast<ngx_table_elt_t *>(\n         ngx_list_push(&r_->headers_in.headers));\n     if (h == nullptr) {\n       return utils::Status(Code::INTERNAL, \"Out of memory\");\n@@ -172,14 +175,21 @@ utils::Status NgxEspRequest::AddHeaderToBackend(const std::string &key,\n         h->lowcase_key,\n         reinterpret_cast<u_char *>(const_cast<char *>(key.c_str())),\n         key.size());\n+    headers.push_back(h);\n   }\n \n-  if (ngx_str_copy_from_std(r_->pool, key, &h->key) != NGX_OK ||\n-      ngx_str_copy_from_std(r_->pool, value, &h->value) != NGX_OK) {\n-    return utils::Status(Code::INTERNAL, \"Out of memory\");\n+  for (size_t i = 0; i < headers.size(); ++i) {\n+    ngx_table_elt_t *it = headers[i];\n+    if (ngx_str_copy_from_std(r_->pool, key, &it->key) != NGX_OK ||\n+        ngx_str_copy_from_std(r_->pool, value, &it->value) != NGX_OK) {\n+      return utils::Status(Code::INTERNAL, \"Out of memory\");\n+    }\n   }\n-  ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r_->connection->log, 0,\n-                 \"updates header to backend: \\\"%V: %V\\\"\", &h->key, &h->value);\n+\n+  ngx_log_debug3(\n+      NGX_LOG_DEBUG_HTTP, r_->connection->log, 0,\n+      \"updates header to backend, changeAllOccurrence: '%t', \\\"%V: %V\\\"\",\n+      changeAllOccurrence, &h->key, &h->value);\n   return utils::Status::OK;\n }\n "
        },
        {
          "filename": "src/nginx/request.h",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -57,7 +57,8 @@ class NgxEspRequest : public Request {\n \n   virtual void SetAuthToken(const std::string &auth_token);\n   virtual utils::Status AddHeaderToBackend(const std::string &key,\n-                                           const std::string &value);\n+                                           const std::string &value,\n+                                           bool changeAllOccurrence);\n   virtual bool FindQuery(const std::string &name, std::string *query);\n   virtual bool FindHeader(const std::string &name, std::string *header);\n "
        },
        {
          "filename": "src/nginx/t/ApiManager.pm",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -456,6 +456,7 @@ sub read_http_stream {\n       'path' => $path,\n       'uri' => $uri,\n       'headers' => \\%headers,\n+      'header_lines' => \\@header_lines,\n       'body' => $body\n     };\n "
        },
        {
          "filename": "src/nginx/t/auth_remove_user_info.t",
          "status": "modified",
          "additions": 10,
          "deletions": 1,
          "patch": "@@ -42,7 +42,7 @@ my $NginxPort = ApiManager::pick_port();\n my $BackendPort = ApiManager::pick_port();\n my $ServiceControlPort = ApiManager::pick_port();\n \n-my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(14);\n+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(15);\n \n # Save service name in the service configuration protocol buffer file.\n \n@@ -88,6 +88,7 @@ my $response = ApiManager::http($NginxPort,<<'EOF');\n GET /shelves?key=this-is-an-api-key HTTP/1.0\n Host: localhost\n x-endpoint-api-userinfo: Should be removed\n+x-endpoint-api-userinfo: Multiple userinfo should all be removed\n \n EOF\n \n@@ -114,6 +115,14 @@ is($r->{uri}, '/shelves?key=this-is-an-api-key', 'Backend uri was /shelves');\n is($r->{headers}->{host}, \"127.0.0.1:${BackendPort}\", 'Host header was set');\n is($r->{headers}->{'x-endpoint-api-userinfo'}, '',\n     'X-Endpoint-API-UserInfo should be removed from the request headers');\n+my $arr = $r->{header_lines};\n+my @userinfo_list = ();\n+\n+foreach (@$arr) {\n+  push(@userinfo_list, $_) if index($_, 'X-Endpoint-API-UserInfo') != -1;\n+}\n+is(join(\",\", @userinfo_list), 'X-Endpoint-API-UserInfo: ,X-Endpoint-API-UserInfo: ',\n+   \"Multiple userinfo should all be removed\");\n \n @requests = ApiManager::read_http_stream($t, 'servicecontrol.log');\n is(scalar @requests, 1, 'Service control received one request');"
        }
      ],
      "file_patterns": {
        "security_files": 3,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 5,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "1a01fe7e15152e4fd35dbb56f6b3ca829fce229b",
            "date": "2024-06-24T21:48:38Z",
            "author_login": "paulhong01"
          },
          {
            "sha": "fca75c59617318bf8e9589287a3e536f8792b354",
            "date": "2024-06-24T21:48:11Z",
            "author_login": "paulhong01"
          },
          {
            "sha": "4b377082d3f50ad1be94d1b27b41976064c12ed9",
            "date": "2024-06-11T21:36:00Z",
            "author_login": "paulhong01"
          },
          {
            "sha": "dc97f3a9d3db415ea01be2dccc026a73e62e15ed",
            "date": "2024-06-10T17:53:00Z",
            "author_login": "paulhong01"
          },
          {
            "sha": "73ae1115ae1a47f6d74269e0219497f44a278f6c",
            "date": "2024-05-20T20:25:59Z",
            "author_login": "Elliot-xq"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N",
    "cwe_id": "CWE-290",
    "description": "Extensible Service Proxy, a.k.a. ESP is a proxy which enables API management capabilities for JSON/REST or gRPC API services. ESPv1 can be configured to authenticate a JWT token. Its verified JWT claim is passed to the application by HTTP header \"X-Endpoint-API-UserInfo\", the application can use it to do authorization. But if there are two \"X-Endpoint-API-UserInfo\" headers from the client, ESPv1 only replaces the first one, the 2nd one will be passed to the application. An attacker can send two \"X-Endpoint-API-UserInfo\" headers, the second one with a fake JWT claim. Application may use the fake JWT claim to do the authorization. This impacts following ESPv1 usages: 1) Users have configured ESPv1 to do JWT authentication with Google ID Token as described in the referenced google endpoint document. 2) Users backend application is using the info in the \"X-Endpoint-API-UserInfo\" header to do the authorization. It has been fixed by v1.58.0. You need to patch it in the following ways: * If your docker image is using tag \":1\", needs to re-start the container to pick up the new version. The tag \":1\" will automatically point to the latest version. * If your docker image tag pings to a specific minor version, e.g. \":1.57\". You need to update it to \":1.58\" and re-start the container. There are no workaround for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-10-07T19:15:08.843",
    "last_modified": "2024-11-21T06:25:32.493",
    "fix_date": "2021-08-31T05:05:31Z"
  },
  "references": [
    {
      "url": "https://cloud.google.com/endpoints/docs/openapi/authenticating-users-google-id",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/cloudendpoints/esp/commit/e310c4f91d229a072507f80c73811489b4cdff27",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/cloudendpoints/esp/releases/tag/v1.58.0",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/cloudendpoints/esp/security/advisories/GHSA-43wx-8qmj-9r9q",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://cloud.google.com/endpoints/docs/openapi/authenticating-users-google-id",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/cloudendpoints/esp/commit/e310c4f91d229a072507f80c73811489b4cdff27",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/cloudendpoints/esp/releases/tag/v1.58.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/cloudendpoints/esp/security/advisories/GHSA-43wx-8qmj-9r9q",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:07.818044",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "esp",
    "owner": "cloudendpoints",
    "created_at": "2016-05-31T22:43:02Z",
    "updated_at": "2025-01-03T21:51:28Z",
    "pushed_at": "2024-06-24T21:51:18Z",
    "size": 4604,
    "stars": 281,
    "forks": 74,
    "open_issues": 25,
    "watchers": 281,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master",
      "v1.0.x",
      "v1.1.x",
      "v1.2.x",
      "v1.3.x",
      "v1.4.x",
      "v1.5.x",
      "v1.6.x",
      "v1.7.x",
      "v1.8.x",
      "v1.9.x",
      "v1.10.x",
      "v1.11.x",
      "v1.12.x",
      "v1.13.x",
      "v1.14.x",
      "v1.15.x",
      "v1.16.x",
      "v1.17.x",
      "v1.18.x",
      "v1.19.x",
      "v1.20.x"
    ],
    "languages": {
      "C++": 1510212,
      "Perl": 994308,
      "Shell": 298016,
      "Python": 173461,
      "Starlark": 126632,
      "Go": 103948,
      "JavaScript": 55560,
      "C": 33839,
      "Dockerfile": 13492,
      "Lua": 2491,
      "Gnuplot": 2179,
      "HTML": 812,
      "Makefile": 409
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-2-clause"
    },
    "collected_at": "2025-01-14T18:45:57.644591"
  }
}