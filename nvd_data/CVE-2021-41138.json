{
  "cve_id": "CVE-2021-41138",
  "github_data": {
    "repository": "paritytech/frontier",
    "fix_commit": "146bb48849e5393004be5c88beefe76fdf009aba",
    "related_commits": [
      "146bb48849e5393004be5c88beefe76fdf009aba",
      "146bb48849e5393004be5c88beefe76fdf009aba"
    ],
    "patch_url": "https://github.com/paritytech/frontier/commit/146bb48849e5393004be5c88beefe76fdf009aba.patch",
    "fix_commit_details": {
      "sha": "146bb48849e5393004be5c88beefe76fdf009aba",
      "commit_date": "2021-10-13T12:48:35Z",
      "author": {
        "login": "librelois",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix security issue: transaction validity controls must be executed in STF (#495)",
        "length": 253,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 368,
        "additions": 287,
        "deletions": 81
      },
      "files": [
        {
          "filename": "frame/ethereum/src/lib.rs",
          "status": "modified",
          "additions": 138,
          "deletions": 73,
          "patch": "@@ -118,78 +118,26 @@ where\n \t\t}\n \t}\n \n-\tpub fn validate_self_contained(&self, origin: &H160) -> Option<TransactionValidity> {\n+\tpub fn pre_dispatch_self_contained(\n+\t\t&self,\n+\t\torigin: &H160,\n+\t) -> Option<Result<(), TransactionValidityError>> {\n \t\tif let Call::transact(transaction) = self {\n-\t\t\tlet validate = || {\n-\t\t\t\t// We must ensure a transaction can pay the cost of its data bytes.\n-\t\t\t\t// If it can't it should not be included in a block.\n-\t\t\t\tlet mut gasometer = evm::gasometer::Gasometer::new(\n-\t\t\t\t\ttransaction.gas_limit.low_u64(),\n-\t\t\t\t\t<T as pallet_evm::Config>::config(),\n-\t\t\t\t);\n-\t\t\t\tlet transaction_cost = match transaction.action {\n-\t\t\t\t\tTransactionAction::Call(_) => {\n-\t\t\t\t\t\tevm::gasometer::call_transaction_cost(&transaction.input)\n-\t\t\t\t\t}\n-\t\t\t\t\tTransactionAction::Create => {\n-\t\t\t\t\t\tevm::gasometer::create_transaction_cost(&transaction.input)\n-\t\t\t\t\t}\n-\t\t\t\t};\n-\t\t\t\tif gasometer.record_transaction(transaction_cost).is_err() {\n-\t\t\t\t\treturn InvalidTransaction::Custom(\n-\t\t\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n-\t\t\t\t\t)\n-\t\t\t\t\t.into();\n-\t\t\t\t}\n-\n-\t\t\t\tif let Some(chain_id) = transaction.signature.chain_id() {\n-\t\t\t\t\tif chain_id != T::ChainId::get() {\n-\t\t\t\t\t\treturn InvalidTransaction::Custom(\n-\t\t\t\t\t\t\tTransactionValidationError::InvalidChainId as u8,\n-\t\t\t\t\t\t)\n-\t\t\t\t\t\t.into();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif transaction.gas_limit >= T::BlockGasLimit::get() {\n-\t\t\t\t\treturn InvalidTransaction::Custom(\n-\t\t\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n-\t\t\t\t\t)\n-\t\t\t\t\t.into();\n-\t\t\t\t}\n-\n-\t\t\t\tlet account_data = pallet_evm::Pallet::<T>::account_basic(&origin);\n-\n-\t\t\t\tif transaction.nonce < account_data.nonce {\n-\t\t\t\t\treturn InvalidTransaction::Stale.into();\n-\t\t\t\t}\n-\n-\t\t\t\tlet fee = transaction.gas_price.saturating_mul(transaction.gas_limit);\n-\t\t\t\tlet total_payment = transaction.value.saturating_add(fee);\n-\t\t\t\tif account_data.balance < total_payment {\n-\t\t\t\t\treturn InvalidTransaction::Payment.into();\n-\t\t\t\t}\n-\n-\t\t\t\tlet min_gas_price = T::FeeCalculator::min_gas_price();\n-\n-\t\t\t\tif transaction.gas_price < min_gas_price {\n-\t\t\t\t\treturn InvalidTransaction::Payment.into();\n-\t\t\t\t}\n-\n-\t\t\t\tlet mut builder = ValidTransactionBuilder::default()\n-\t\t\t\t\t.and_provides((origin, transaction.nonce))\n-\t\t\t\t\t.priority(transaction.gas_price.unique_saturated_into());\n-\n-\t\t\t\tif transaction.nonce > account_data.nonce {\n-\t\t\t\t\tif let Some(prev_nonce) = transaction.nonce.checked_sub(1.into()) {\n-\t\t\t\t\t\tbuilder = builder.and_requires((origin, prev_nonce))\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tbuilder.build()\n-\t\t\t};\n+\t\t\tSome(Pallet::<T>::validate_transaction_in_block(\n+\t\t\t\t*origin,\n+\t\t\t\t&transaction,\n+\t\t\t))\n+\t\t} else {\n+\t\t\tNone\n+\t\t}\n+\t}\n \n-\t\t\tSome(validate())\n+\tpub fn validate_self_contained(&self, origin: &H160) -> Option<TransactionValidity> {\n+\t\tif let Call::transact(transaction) = self {\n+\t\t\tSome(Pallet::<T>::validate_transaction_in_pool(\n+\t\t\t\t*origin,\n+\t\t\t\ttransaction,\n+\t\t\t))\n \t\t} else {\n \t\t\tNone\n \t\t}\n@@ -259,9 +207,12 @@ pub mod pallet {\n \t\t\t\t\t\t\"pre-block transaction signature invalid; the block cannot be built\",\n \t\t\t\t\t);\n \n-\t\t\t\t\tSelf::do_transact(source, transaction).expect(\n+\t\t\t\t\tSelf::validate_transaction_in_block(source, &transaction).expect(\n \t\t\t\t\t\t\"pre-block transaction verification failed; the block cannot be built\",\n \t\t\t\t\t);\n+\t\t\t\t\tSelf::apply_validated_transaction(source, transaction).expect(\n+\t\t\t\t\t\t\"pre-block transaction execution failed; the block cannot be built\",\n+\t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \n@@ -287,7 +238,7 @@ pub mod pallet {\n \t\t\t\tError::<T>::PreLogExists,\n \t\t\t);\n \n-\t\t\tSelf::do_transact(source, transaction)\n+\t\t\tSelf::apply_validated_transaction(source, transaction)\n \t\t}\n \t}\n \n@@ -418,7 +369,98 @@ impl<T: Config> Pallet<T> {\n \t\t}\n \t}\n \n-\tfn do_transact(source: H160, transaction: Transaction) -> DispatchResultWithPostInfo {\n+\t// Common controls to be performed in the same way by the pool and the\n+\t// State Transition Function (STF).\n+\t// This is the case for all controls except those concerning the nonce.\n+\tfn validate_transaction_common(\n+\t\torigin: H160,\n+\t\ttransaction: &Transaction,\n+\t) -> Result<U256, TransactionValidityError> {\n+\t\t// We must ensure a transaction can pay the cost of its data bytes.\n+\t\t// If it can't it should not be included in a block.\n+\t\tlet mut gasometer = evm::gasometer::Gasometer::new(\n+\t\t\ttransaction.gas_limit.low_u64(),\n+\t\t\t<T as pallet_evm::Config>::config(),\n+\t\t);\n+\t\tlet transaction_cost = match transaction.action {\n+\t\t\tTransactionAction::Call(_) => evm::gasometer::call_transaction_cost(&transaction.input),\n+\t\t\tTransactionAction::Create => {\n+\t\t\t\tevm::gasometer::create_transaction_cost(&transaction.input)\n+\t\t\t}\n+\t\t};\n+\t\tif gasometer.record_transaction(transaction_cost).is_err() {\n+\t\t\treturn Err(InvalidTransaction::Custom(\n+\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n+\t\t\t)\n+\t\t\t.into());\n+\t\t}\n+\n+\t\tif let Some(chain_id) = transaction.signature.chain_id() {\n+\t\t\tif chain_id != T::ChainId::get() {\n+\t\t\t\treturn Err(InvalidTransaction::Custom(\n+\t\t\t\t\tTransactionValidationError::InvalidChainId as u8,\n+\t\t\t\t)\n+\t\t\t\t.into());\n+\t\t\t}\n+\t\t}\n+\n+\t\tif transaction.gas_limit >= T::BlockGasLimit::get() {\n+\t\t\treturn Err(InvalidTransaction::Custom(\n+\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n+\t\t\t)\n+\t\t\t.into());\n+\t\t}\n+\n+\t\tlet account_data = pallet_evm::Pallet::<T>::account_basic(&origin);\n+\n+\t\tlet fee = transaction.gas_price.saturating_mul(transaction.gas_limit);\n+\t\tlet total_payment = transaction.value.saturating_add(fee);\n+\t\tif account_data.balance < total_payment {\n+\t\t\treturn Err(InvalidTransaction::Payment.into());\n+\t\t}\n+\n+\t\tlet min_gas_price = T::FeeCalculator::min_gas_price();\n+\n+\t\tif transaction.gas_price < min_gas_price {\n+\t\t\treturn Err(InvalidTransaction::Payment.into());\n+\t\t}\n+\n+\t\tOk(account_data.nonce)\n+\t}\n+\n+\t// Controls that must be performed by the pool.\n+\t// The controls common with the State Transition Function (STF) are in\n+\t// the function `validate_transaction_common`.\n+\tfn validate_transaction_in_pool(\n+\t\torigin: H160,\n+\t\ttransaction: &Transaction,\n+\t) -> TransactionValidity {\n+\t\tlet account_nonce = Self::validate_transaction_common(origin, transaction)?;\n+\n+\t\tif transaction.nonce < account_nonce {\n+\t\t\treturn Err(InvalidTransaction::Stale.into());\n+\t\t}\n+\n+\t\t// The tag provides and requires must be filled correctly according to the nonce.\n+\t\tlet mut builder = ValidTransactionBuilder::default()\n+\t\t\t.and_provides((origin, transaction.nonce))\n+\t\t\t.priority(transaction.gas_price.unique_saturated_into());\n+\n+\t\t// In the context of the pool, a transaction with\n+\t\t// too high a nonce is still considered valid\n+\t\tif transaction.nonce > account_nonce {\n+\t\t\tif let Some(prev_nonce) = transaction.nonce.checked_sub(1.into()) {\n+\t\t\t\tbuilder = builder.and_requires((origin, prev_nonce))\n+\t\t\t}\n+\t\t}\n+\n+\t\tbuilder.build()\n+\t}\n+\n+\tfn apply_validated_transaction(\n+\t\tsource: H160,\n+\t\ttransaction: Transaction,\n+\t) -> DispatchResultWithPostInfo {\n \t\tlet transaction_hash =\n \t\t\tH256::from_slice(Keccak256::digest(&rlp::encode(&transaction)).as_slice());\n \t\tlet transaction_index = Pending::<T>::get().len() as u32;\n@@ -565,6 +607,29 @@ impl<T: Config> Pallet<T> {\n \t\t\t}\n \t\t}\n \t}\n+\n+\t/// Validate an Ethereum transaction already in block\n+\t///\n+\t/// This function must be called during the pre-dispatch phase\n+\t/// (just before applying the extrinsic).\n+\tpub fn validate_transaction_in_block(\n+\t\torigin: H160,\n+\t\ttransaction: &ethereum::TransactionV0,\n+\t) -> Result<(), TransactionValidityError> {\n+\t\tlet account_nonce = Self::validate_transaction_common(origin, transaction)?;\n+\n+\t\t// In the context of the block, a transaction with a nonce that is\n+\t\t// too high should be considered invalid and make the whole block invalid.\n+\t\tif transaction.nonce > account_nonce {\n+\t\t\tErr(TransactionValidityError::Invalid(\n+\t\t\t\tInvalidTransaction::Future,\n+\t\t\t))\n+\t\t} else if transaction.nonce < account_nonce {\n+\t\t\tErr(TransactionValidityError::Invalid(InvalidTransaction::Stale))\n+\t\t} else {\n+\t\t\tOk(())\n+\t\t}\n+\t}\n }\n \n #[derive(Eq, PartialEq, Clone, sp_runtime::RuntimeDebug)]"
        },
        {
          "filename": "frame/ethereum/src/mock.rs",
          "status": "modified",
          "additions": 58,
          "deletions": 3,
          "patch": "@@ -19,6 +19,7 @@\n \n use super::*;\n use crate::IntermediateStateRoot;\n+use codec::{WrapperTypeDecode, WrapperTypeEncode};\n use ethereum::{TransactionAction, TransactionSignature};\n use frame_support::{parameter_types, traits::FindAuthor, ConsensusEngineId, PalletId};\n use pallet_evm::{AddressMapping, EnsureAddressTruncated, FeeCalculator};\n@@ -27,11 +28,13 @@ use sha3::Digest;\n use sp_core::{H160, H256, U256};\n use sp_runtime::{\n \ttesting::Header,\n-\ttraits::{BlakeTwo256, IdentityLookup},\n+\ttraits::{BlakeTwo256, IdentityLookup, SignedExtension},\n \tAccountId32,\n };\n \n-type UncheckedExtrinsic = frame_system::mocking::MockUncheckedExtrinsic<Test>;\n+pub type SignedExtra = (frame_system::CheckSpecVersion<Test>,);\n+\n+type UncheckedExtrinsic = frame_system::mocking::MockUncheckedExtrinsic<Test, (), SignedExtra>;\n type Block = frame_system::mocking::MockBlock<Test>;\n \n frame_support::construct_runtime! {\n@@ -166,6 +169,54 @@ impl crate::Config for Test {\n \ttype StateRoot = IntermediateStateRoot;\n }\n \n+impl fp_self_contained::SelfContainedCall for Call {\n+\ttype SignedInfo = H160;\n+\n+\tfn is_self_contained(&self) -> bool {\n+\t\tmatch self {\n+\t\t\tCall::Ethereum(call) => call.is_self_contained(),\n+\t\t\t_ => false,\n+\t\t}\n+\t}\n+\n+\tfn check_self_contained(&self) -> Option<Result<Self::SignedInfo, TransactionValidityError>> {\n+\t\tmatch self {\n+\t\t\tCall::Ethereum(call) => call.check_self_contained(),\n+\t\t\t_ => None,\n+\t\t}\n+\t}\n+\n+\tfn validate_self_contained(&self, info: &Self::SignedInfo) -> Option<TransactionValidity> {\n+\t\tmatch self {\n+\t\t\tCall::Ethereum(call) => call.validate_self_contained(info),\n+\t\t\t_ => None,\n+\t\t}\n+\t}\n+\n+\tfn pre_dispatch_self_contained(\n+\t\t&self,\n+\t\tinfo: &Self::SignedInfo,\n+\t) -> Option<Result<(), TransactionValidityError>> {\n+\t\tmatch self {\n+\t\t\tCall::Ethereum(call) => call.pre_dispatch_self_contained(info),\n+\t\t\t_ => None,\n+\t\t}\n+\t}\n+\n+\tfn apply_self_contained(\n+\t\tself,\n+\t\tinfo: Self::SignedInfo,\n+\t) -> Option<sp_runtime::DispatchResultWithInfo<sp_runtime::traits::PostDispatchInfoOf<Self>>> {\n+\t\tuse sp_runtime::traits::Dispatchable as _;\n+\t\tmatch self {\n+\t\t\tcall @ Call::Ethereum(crate::Call::transact(_)) => {\n+\t\t\t\tSome(call.dispatch(Origin::from(crate::RawOrigin::EthereumTransaction(info))))\n+\t\t\t}\n+\t\t\t_ => None,\n+\t\t}\n+\t}\n+}\n+\n pub struct AccountInfo {\n \tpub address: H160,\n \tpub account_id: AccountId32,\n@@ -255,6 +306,10 @@ impl UnsignedTransaction {\n \t}\n \n \tpub fn sign(&self, key: &H256) -> Transaction {\n+\t\tself.sign_with_chain_id(key, ChainId::get())\n+\t}\n+\n+\tpub fn sign_with_chain_id(&self, key: &H256, chain_id: u64) -> Transaction {\n \t\tlet hash = self.signing_hash();\n \t\tlet msg = libsecp256k1::Message::parse(hash.as_fixed_bytes());\n \t\tlet s = libsecp256k1::sign(\n@@ -264,7 +319,7 @@ impl UnsignedTransaction {\n \t\tlet sig = s.0.serialize();\n \n \t\tlet sig = TransactionSignature::new(\n-\t\t\ts.1.serialize() as u64 % 2 + ChainId::get() * 2 + 35,\n+\t\t\ts.1.serialize() as u64 % 2 + chain_id * 2 + 35,\n \t\t\tH256::from_slice(&sig[0..32]),\n \t\t\tH256::from_slice(&sig[32..64]),\n \t\t)"
        },
        {
          "filename": "frame/ethereum/src/tests.rs",
          "status": "modified",
          "additions": 61,
          "deletions": 5,
          "patch": "@@ -18,13 +18,18 @@\n //! Consensus extension module tests for BABE consensus.\n \n use crate::{\n-\tmock::*, CallOrCreateInfo, Error, RawOrigin, Transaction, TransactionAction,\n-\tValidTransactionBuilder, H160, H256, U256,\n+\tmock::*, CallOrCreateInfo, Error, RawOrigin, Transaction, TransactionAction, H160, H256, U256,\n };\n use ethereum::TransactionSignature;\n-use frame_support::{assert_err, assert_noop, assert_ok, unsigned::ValidateUnsigned};\n+use frame_support::{\n+\tassert_err, assert_noop, assert_ok,\n+\tunsigned::{TransactionValidityError, ValidateUnsigned},\n+};\n use rustc_hex::{FromHex, ToHex};\n-use sp_runtime::transaction_validity::{InvalidTransaction, TransactionSource};\n+use sp_runtime::traits::Applyable;\n+use sp_runtime::transaction_validity::{\n+\tInvalidTransaction, TransactionSource, ValidTransactionBuilder,\n+};\n use std::str::FromStr;\n \n // This ERC-20 contract mints the maximum amount of tokens to the contract creator.\n@@ -91,7 +96,7 @@ fn transaction_without_enough_gas_should_not_work() {\n }\n \n #[test]\n-fn transaction_with_invalid_nonce_should_not_work() {\n+fn transaction_with_to_low_nonce_should_not_work() {\n \tlet (pairs, mut ext) = new_test_ext(1);\n \tlet alice = &pairs[0];\n \n@@ -140,6 +145,57 @@ fn transaction_with_invalid_nonce_should_not_work() {\n \t});\n }\n \n+#[test]\n+fn transaction_with_to_hight_nonce_should_fail_in_block() {\n+\tlet (pairs, mut ext) = new_test_ext(1);\n+\tlet alice = &pairs[0];\n+\n+\text.execute_with(|| {\n+\t\tlet mut transaction = default_erc20_creation_unsigned_transaction();\n+\t\ttransaction.nonce = U256::one();\n+\n+\t\tlet signed = transaction.sign(&alice.private_key);\n+\t\tlet call = crate::Call::<Test>::transact(signed);\n+\t\tlet source = call.check_self_contained().unwrap().unwrap();\n+\t\tlet extrinsic = fp_self_contained::CheckedExtrinsic::<_, _, SignedExtra, _> {\n+\t\t\tsigned: fp_self_contained::CheckedSignature::SelfContained(source),\n+\t\t\tfunction: Call::Ethereum(call),\n+\t\t};\n+\t\tuse frame_support::weights::GetDispatchInfo as _;\n+\t\tlet dispatch_info = extrinsic.get_dispatch_info();\n+\t\tassert_err!(\n+\t\t\textrinsic.apply::<Test>(&dispatch_info, 0),\n+\t\t\tTransactionValidityError::Invalid(InvalidTransaction::Future)\n+\t\t);\n+\t});\n+}\n+\n+#[test]\n+fn transaction_with_invalid_chain_id_should_fail_in_block() {\n+\tlet (pairs, mut ext) = new_test_ext(1);\n+\tlet alice = &pairs[0];\n+\n+\text.execute_with(|| {\n+\t\tlet transaction =\n+\t\t\tdefault_erc20_creation_unsigned_transaction().sign_with_chain_id(&alice.private_key, 1);\n+\n+\t\tlet call = crate::Call::<Test>::transact(transaction);\n+\t\tlet source = call.check_self_contained().unwrap().unwrap();\n+\t\tlet extrinsic = fp_self_contained::CheckedExtrinsic::<_, _, SignedExtra, _> {\n+\t\t\tsigned: fp_self_contained::CheckedSignature::SelfContained(source),\n+\t\t\tfunction: Call::Ethereum(call),\n+\t\t};\n+\t\tuse frame_support::weights::GetDispatchInfo as _;\n+\t\tlet dispatch_info = extrinsic.get_dispatch_info();\n+\t\tassert_err!(\n+\t\t\textrinsic.apply::<Test>(&dispatch_info, 0),\n+\t\t\tTransactionValidityError::Invalid(InvalidTransaction::Custom(\n+\t\t\t\tcrate::TransactionValidationError::InvalidChainId as u8,\n+\t\t\t))\n+\t\t);\n+\t});\n+}\n+\n #[test]\n fn contract_constructor_should_get_executed() {\n \tlet (pairs, mut ext) = new_test_ext(1);"
        },
        {
          "filename": "primitives/self-contained/src/checked_extrinsic.rs",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -135,6 +135,12 @@ where\n \t\t\t\tOk(res)\n \t\t\t}\n \t\t\tCheckedSignature::SelfContained(signed_info) => {\n+\t\t\t\t// If pre-dispatch fail, the block must be considered invalid\n+\t\t\t\tself.function\n+\t\t\t\t\t.pre_dispatch_self_contained(&signed_info)\n+\t\t\t\t\t.ok_or(TransactionValidityError::Invalid(\n+\t\t\t\t\t\tInvalidTransaction::BadProof,\n+\t\t\t\t\t))??;\n \t\t\t\tOk(self.function.apply_self_contained(signed_info).ok_or(\n \t\t\t\t\tTransactionValidityError::Invalid(InvalidTransaction::BadProof),\n \t\t\t\t)?)"
        },
        {
          "filename": "primitives/self-contained/src/lib.rs",
          "status": "modified",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -44,6 +44,20 @@ pub trait SelfContainedCall: Dispatchable {\n \t/// Validate a self-contained function. Returns `None` if the\n \t/// function is not a self-contained.\n \tfn validate_self_contained(&self, info: &Self::SignedInfo) -> Option<TransactionValidity>;\n+\t/// Do any pre-flight stuff for a self-contained call.\n+\t///\n+\t/// Note this function by default delegates to `validate_self_contained`, so that\n+\t/// all checks performed for the transaction queue are also performed during\n+\t/// the dispatch phase (applying the extrinsic).\n+\t///\n+\t/// If you ever override this function, you need to make sure to always\n+\t/// perform the same validation as in `validate_self_contained`.\n+\t///\n+\t/// Returns `None` if the function is not a self-contained.\n+\tfn pre_dispatch_self_contained(\n+\t\t&self,\n+\t\tinfo: &Self::SignedInfo,\n+\t) -> Option<Result<(), TransactionValidityError>>;\n \t/// Apply a self-contained function. Returns `None` if the\n \t/// function is not a self-contained.\n \tfn apply_self_contained("
        },
        {
          "filename": "template/runtime/src/lib.rs",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -440,6 +440,16 @@ impl fp_self_contained::SelfContainedCall for Call {\n \t\t}\n \t}\n \n+\tfn pre_dispatch_self_contained(\n+\t\t&self,\n+\t\tinfo: &Self::SignedInfo,\n+\t) -> Option<Result<(), TransactionValidityError>> {\n+\t\tmatch self {\n+\t\t\tCall::Ethereum(call) => call.pre_dispatch_self_contained(info),\n+\t\t\t_ => None,\n+\t\t}\n+\t}\n+\n \tfn apply_self_contained(\n \t\tself,\n \t\tinfo: Self::SignedInfo,"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "802b196808ddb6ef5565b0e9c3baa8b904c637f3",
            "date": "2025-01-13T05:57:49Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "30b0fad98b3da35f202f91bf98c8b1a0f467d656",
            "date": "2025-01-13T05:56:55Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "817a938a0b4e5a464163c189bcd6abaec8b0a6d6",
            "date": "2025-01-13T05:56:31Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "6c84eaae3d86c78a5c6baecafe68451251e96707",
            "date": "2025-01-13T05:56:03Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "04e2f665e5227109d2100ab2f59ad4f31ff91058",
            "date": "2025-01-13T05:54:29Z",
            "author_login": "pLabarta"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
    "cwe_id": "CWE-20",
    "description": "Frontier is Substrate's Ethereum compatibility layer. In the newly introduced signed Frontier-specific extrinsic for `pallet-ethereum`, a large part of transaction validation logic was only called in transaction pool validation, but not in block execution. Malicious validators can take advantage of this to put invalid transactions into a block. The attack is limited in that the signature is always validated, and the majority of the validation is done again in the subsequent `pallet-evm` execution logic. However, do note that a chain ID replay attack was possible. In addition, spamming attacks are of main concerns, while they are limited by Substrate block size limits and other factors. The issue is patched in commit `146bb48849e5393004be5c88beefe76fdf009aba`.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-10-13T16:15:07.847",
    "last_modified": "2024-11-21T06:25:34.130",
    "fix_date": "2021-10-13T12:48:35Z"
  },
  "references": [
    {
      "url": "https://github.com/paritytech/frontier/commit/146bb48849e5393004be5c88beefe76fdf009aba",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/paritytech/frontier/pull/497",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/paritytech/frontier/security/advisories/GHSA-vj62-g63v-f8mf",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/paritytech/frontier/commit/146bb48849e5393004be5c88beefe76fdf009aba",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/paritytech/frontier/pull/497",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/paritytech/frontier/security/advisories/GHSA-vj62-g63v-f8mf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:31.826974",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "frontier",
    "owner": "paritytech",
    "created_at": "2018-11-08T13:10:57Z",
    "updated_at": "2025-01-13T05:57:53Z",
    "pushed_at": "2025-01-14T05:05:02Z",
    "size": 71567,
    "stars": 580,
    "forks": 511,
    "open_issues": 149,
    "watchers": 580,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Rust": 1552689,
      "TypeScript": 219803,
      "Solidity": 7119,
      "Handlebars": 5345,
      "JavaScript": 4300,
      "Makefile": 2075,
      "Shell": 1769,
      "Nix": 867
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:36:30.286455"
  }
}