{
  "cve_id": "CVE-2021-41193",
  "github_data": {
    "repository": "wireapp/wire-avs",
    "fix_commit": "40d373ede795443ae6f2f756e9fb1f4f4ae90bbe",
    "related_commits": [
      "40d373ede795443ae6f2f756e9fb1f4f4ae90bbe",
      "40d373ede795443ae6f2f756e9fb1f4f4ae90bbe"
    ],
    "patch_url": "https://github.com/wireapp/wire-avs/commit/40d373ede795443ae6f2f756e9fb1f4f4ae90bbe.patch",
    "fix_commit_details": {
      "sha": "40d373ede795443ae6f2f756e9fb1f4f4ae90bbe",
      "commit_date": "2021-09-07T11:07:15Z",
      "author": {
        "login": "c-g-owen",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Import latest release-7.1 files from old repo",
        "length": 45,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 3578,
        "additions": 3057,
        "deletions": 521
      },
      "files": [
        {
          "filename": ".gitattributes",
          "status": "added",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -0,0 +1,15 @@\n+#\n+# .gitattributes\n+#\n+# used to remove files from deployment using `git archive`\n+#\n+\n+.gitattributes  export-ignore\n+.gitignore      export-ignore\n+\n+BUILDCONTROL    export-ignore\n+\n+contrib         export-ignore\n+docs            export-ignore\n+mediaengine     export-ignore\n+tools           export-ignore"
        },
        {
          "filename": ".gitignore",
          "status": "added",
          "additions": 50,
          "deletions": 0,
          "patch": "@@ -0,0 +1,50 @@\n+*.[oa]\n+.*.swp\n+*.class\n+bin\n+gen\n+libs\n+obj\n+local.properties\n+*.log\n+\n+/netprobe\n+/verifyd\n+/vidloop\n+/zcall\n+/coin\n+/tmp\n+/scripts/tmp\n+\n+/build\n+.DS_STORE\n+xcuserdata\n+xcshareddata\n+zcontrib\n+ztest\n+BUILDCONTROL.local\n+artifacts\n+version.buildinfo\n+*.jnilib\n+config.mk\n+\n+test/audio_test/ios/build/\n+tools/zmm/build/\n+\n+*.aecdump\n+*.rtpdump\n+\n+test/data/near16_out.pcm\n+test/data/near32_out.pcm\n+test/data/out.pcm\n+test/data/out2.pcm\n+test/data/rtp.dat\n+\n+android/java/org/\n+\n+src/protobuf/proto/\n+\n+contrib/webrtc\n+\n+scan/\n+"
        },
        {
          "filename": "Makefile",
          "status": "modified",
          "additions": 4,
          "deletions": 8,
          "patch": "@@ -33,25 +33,21 @@ else\n VER_PATCH := $(BUILD_NUMBER)\n endif\n \n-VER_BRANCH := $(shell git rev-parse --abbrev-ref HEAD || echo \"Fetching branch failed\")\n+VER_BRANCH := $(shell git rev-parse --abbrev-ref HEAD || echo \"\")\n \n ifeq ($(VER_BRANCH),master)\n AVS_PROJECT := avsmaster\n AVS_RELEASE := 0\n-AVS_VERSION := 0.$(VER_PATCH)\n-else ifeq ($(VER_BRANCH),open_source)\n-AVS_PROJECT := avsopen\n-AVS_RELEASE := 1\n-AVS_VERSION := $(VER_MAJOR).$(VER_MINOR).$(VER_PATCH)\n+AVS_VERSION := 0.0.$(VER_PATCH)\n else\n AVS_PROJECT := avs\n AVS_RELEASE := 1\n AVS_VERSION := $(VER_MAJOR).$(VER_MINOR).$(VER_PATCH)\n endif\n \n-\n MK_COMPONENTS := toolchain contrib avs tools test android iosx dist\n \n+\n #--- Configuration ---\n \n -include config.mk\n@@ -91,7 +87,7 @@ endif\n \n #--- All My Targets ---\n \n-all: test\n+all: tools test\n \n ifeq ($(AVS_OS),android)\n wrapper: android"
        },
        {
          "filename": "docs/devicepair.md",
          "status": "added",
          "additions": 54,
          "deletions": 0,
          "patch": "@@ -0,0 +1,54 @@\n+Device Pairing\n+==============\n+\n+\n+\n+Flow Diagram\n+------------\n+\n+\n+```\n+      .------.               .-------.             .------.\n+      | old  |               |       |             |  new |\n+      |device|               |verifyd|             |device|\n+      '------'               '-------'             '------'\n+         |                       |                     |     [ User start a ]\n+         |                       |   POST /create      |     [ new pairing  ]\n+         |                       |<--------------------|\n+         |                       |   200 OK (id=42)    |\n+         |                       |-------------------->|\n+devpair  |                       |                     |     [ Show Pairing ID ]\n+publish()|                       |                     |\n+         |                       |                     |\n+         |  PUT /publish?id=42   |                     |\n+         |  (SDP Offer)          |                     |\n+         |---------------------->|                     |\n+         |  200 OK               |                     |  poll\n+         |<----------------------|                     +--.\n+         |                       |  GET /publish?id=42 | /|\\\n+         |                       |<--------------------|  |\n+         |                       |   200 OK (SDP Offer)|  |\n+         |                       |-------------------->|  |\n+         |                       |                     +--'\n+         |                       |                     | ~~~ devpair_create()\n+         |                       |                     | ~~~ devpair_accept()\n+         |                       |                     |\n+         |                       |  PUT /accept?id=42  |\n+         |                       |   (SDP Answer)      |\n+         |                       |<--------------------|\n+   poll  |                       |      200 OK         |\n+      .--+                       |-------------------->|\n+     /|\\ |  GET /accept?id=42    |                     |\n+      |  |---------------------->|                     |\n+      |  |  200 OK (SDP Answer)  |                     |\n+      |  |<----------------------|                     |\n+      '--+                       |                     |\n+devpair  |                       |                     |\n+ack()    |                       |                     |\n+         |                       |                     |\n+         |<================= DataChannel =============>|     [  Started]\n+\n+\n+TODO: transfer data (ledger)\n+\n+```"
        },
        {
          "filename": "docs/flowmgr.md",
          "status": "added",
          "additions": 145,
          "deletions": 0,
          "patch": "@@ -0,0 +1,145 @@\n+Flow Manager\n+============\n+\n+In Zeta, calling is split into two more or less independent parts: call\n+state handling and media handling.  Call state handling controls which\n+users and devices have joined a call in a conversation.  Media handling\n+makes sure that audio and video data is being exchanged between all\n+devices that have joined a call.\n+\n+The flow manager is a component of the AVS library that implements media\n+handling for calling.  It takes care of both the network and the AV side\n+of call media: it establishes media flows between devices, records audio\n+and video from the recording devices present in the system, encodes these\n+and sends them over the media flows, it receives encoded media from the\n+network, decodes it and plays it back on playback devices.\n+\n+This document describes both the interface and function of the flow\n+manager in great detail.\n+\n+\n+Basics\n+------\n+\n+Calling happens in the context of conversations.  Each conversation has an\n+associated call which devices can join.  Whether a device can join a call\n+and for how long is being controlled by the service.  This is determined by\n+the call state handling component of calling and is not being discussed\n+here.\n+\n+In order to be able to participate in a call, a device needs to be able to\n+exchange data with remote locations. Since there can be several devices\n+that can potentially join a call, the remote location is not predetermined\n+and it can change during a call. However, for each device there is at most\n+one such location at any given time. The relationship between exactly two\n+devices for exchanging media is called a media flow.\n+\n+Media flows are controlled by the service. Before starting a call, a device\n+asks the service for a set of flows, called 'posting for flows.' The\n+service determines any potential other devices in the call and creates a\n+media flow the asking devices and each of these. They receive their flows\n+without having asked for them through the `call.flow-add` event.\n+\n+When a device has received a flow, be it by asking or throug an event, it\n+starts preparing the flow. This entails an offer/answer exchange for media\n+capabilities followed by an ICE exchange to determine and open actual\n+network connections.\n+\n+A call starts once at least two devices have joined call. When this\n+happens, the service determines which media flow should be used to\n+exchange media over and informs the device by 'activating the flow'\n+through a `call.flow-active` event. Only when a flow is active is a device\n+allowed to send media over it. However, it does not have to. The device\n+can decide to keep the call muted or it can keep it on hold while being in\n+the call of another conversation.\n+\n+Sending and receiving of media ends when the flow is being deactivated by\n+the service, yet again by way of a `call.flow-active` event.\n+\n+Once the device determines that it doesn't want to be in a call anymore,\n+it can delete all its flows. If the other side of a flow decides to delete\n+it, the device will be informed by the service through a\n+`call.flow-delete` event.\n+\n+\n+The Flow Manager API\n+--------------------\n+\n+The flow manager is a single object that provides a number of functions to\n+be called by the user and calls a number of callbacks to be registered by\n+the user.\n+\n+There is only one flow manager per application. Functions that operate on\n+a per-conversation basis use the conversation ID as an argument.\n+\n+\n+Service Connection\n+------------------\n+\n+The flow manager needs to communicate to the service. It does so both\n+through HTTP requests and events.\n+\n+It emits HTTP requests through a callback registered at creation time.\n+This callback will contain all parts of the HTTP request as arguments.\n+Additionally, it contains an opaque pointer to a context. It is the user's\n+responsibility to create and dispatch an HTTP request. Once a response\n+arrives, the user must pass it to the flow manager through the\n+`flowmgr_resp()` function, passing the context pointer from the request.\n+\n+Additionally, all events must be passed to the flow manager through the\n+`flowmgr_event()` function.\n+\n+\n+Managing Calls\n+--------------\n+\n+When the API user anticipates that a call might start, it calls the\n+`flowmgr_acquire_flows()` function. This will cause the flow manager to\n+request flows from the service. The user can now proceed with call states.\n+Eventually, the service will activate one of the flows in response to the\n+device call state being set to active.\n+\n+Now there's two options: if setting up media on the activated flow fails,\n+an error is emitted allowing the user to alert its user and wind down the\n+call. If, however, it succeeds, something called audio categories comes\n+into play.\n+\n+It is also important that flows are released (flowmgr_release_flows()) after\n+a call participant has been set to \"idle\" and response has been received.\n+\n+Media Categories\n+----------------\n+\n+Media categories describe how recording and playback of media should be\n+handled for a conversation. Currently, there are four:\n+\n+*  _regular_: this is the normal mode where only notification sounds are\n+   emitted from the conversation and no recording takes place;\n+*  _muted_: the conversation has been muted and no playback or recording\n+   should happen (note that this is independent of any muting feature\n+   implemented by UI);\n+*  _call_: the conversation has actively joined a call, incoming media is\n+   being played back and recorded media is being streamed to the network;\n+*  _playback_: an embedded media element in the conversation is playing\n+   its media.\n+\n+The media category for each conversation is managed by the user of the\n+flow manager. In most cases, it will do so using the media manager.\n+\n+The flow manager does, however, request a certain media category necessary\n+for its operation. When a flow has been activated, it requests the _call_\n+category. When an active flow has been deactivated, it requests the\n+_regular_ category. It is up to the user to actually set the requested\n+category and perform any necessary action for a change.\n+\n+The flow manager requests a changed through `flowmgr_mcat_h`\n+callback. Any change to the media category of a conversation needs to be\n+communicated using the `flowmgr_mcat_changed()` function.\n+\n+So, when a flow is being activated by the service, the flow manager will\n+request the _call_ media category for that conversation. It will only\n+start playback and recording, however, once it has been notified that this\n+change has happened.\n+\n+Similarly, the user can decide at any time to revoke the _call_ media\n+category in which case the flow manager stops playback and recording."
        },
        {
          "filename": "docs/local_avs_on_ios.md",
          "status": "added",
          "additions": 52,
          "deletions": 0,
          "patch": "@@ -0,0 +1,52 @@\n+\n+# Building ZClient-iOS with local AVS\n+\n+## Requirements\n+\n+Xcode7\n+Cocoa pods: sudo gem install cocoapods\n+Carthage: brew install carthage\n+\n+## Set up xcode_link dir\n+\n+Make a link to avsball:\n+\n+```\n+mkdir xcode_link\n+cd xcode_link\n+ln -s ../avs/build/dist/ios/avsball ios\n+```\n+\n+## Getting Zclient dependencies\n+\n+Get pods and whatever\n+\n+```\n+cd zclient-ios\n+pod init\n+carthage bootstrap\n+```\n+\n+## Add getcomponents to Build Phases\n+\n+Open xcworkspace file in Xcode\n+Add following line to \"Check Pods manifest.lock\" in build phases\n+\n+```\n+${HOME}/Library/Python/2.7/bin/getcomponents --verbose --force --build-control ${SRCROOT}/BUILDCONTROL --platform ios\n+```\n+\n+## Fix Buildconfig to get local AVS\n+\n+Copy BUILDCONFIG to BUILDCONFIG.local, replace avs with local & add the paths section\n+\n+```\n+[libraries]\n+avs: local\n+\n+[paths]\n+avs: ../xcode_link\n+```\n+\n+## Profit\n+"
        },
        {
          "filename": "docs/release-process.txt",
          "status": "added",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -0,0 +1,25 @@\n+Release Process for AVS:\n+-----------------------\n+\n+\n+Different projects have different release policy:\n+\n+\n+  avs:          master     This is the main development branch\n+                release    This is the release branch, only for bugfixes\n+                           (commits in release branch are merged back to master)\n+\n+\n+  zcontrib:     master     Should always have production ready code in their master branch\n+                           New features are kept in a feature-branch\n+\n+\n+  mediaengine:  master     Should always have production ready code in their master branch\n+                           New features are kept in a feature-branch\n+\n+\n+\n+NOTE:  The release branch would only need updating if externally relevant stuff has been updated.\n+\n+\n+..."
        },
        {
          "filename": "mk/dist.mk",
          "status": "modified",
          "additions": 42,
          "deletions": 4,
          "patch": "@@ -53,7 +53,7 @@ ifeq ($(DIST_ARCH),)\n endif\n \n DIST_ARCH_android := $(filter armv7 arm64 i386 x86_64 osx,$(DIST_ARCH))\n-DIST_ARCH_ios := $(filter armv7 arm64 x86_64,$(DIST_ARCH))\n+DIST_ARCH_ios := $(filter arm64 x86_64,$(DIST_ARCH))\n \n DIST_FMWK_VERSION := A\n DIST_BUNDLE_LIB_NAME := AVS Library\n@@ -106,7 +106,8 @@ DIST_BUNDLE_LIB := \\\n DIST_AND_TARGETS := $(BUILD_DIST_AND)/avs.aar\n \n DIST_IOS_TARGETS := \\\n-\t$(BUILD_DIST_IOS)/$(BUILD_LIB_REL).framework.zip\n+\t$(BUILD_DIST_IOS)/$(BUILD_LIB_REL).framework.zip \\\n+\t$(BUILD_DIST_IOS)/$(BUILD_LIB_REL).xcframework.zip\n \n \n DIST_OSX_TARGETS := \\\n@@ -148,6 +149,7 @@ AVS_ARCH_NAME := $1\\n\\\n \tcp android/obj/local/$2/libavs.so $(BUILD_DIST_AND)/debug/$2/libavs.so\n endef\n \n+\n .PHONY: $(BUILD_DIST_AND)/avs.aar\n $(BUILD_DIST_AND)/avs.aar:\n \t@mkdir -p $(BUILD_DIST_AND)/aar\n@@ -287,13 +289,28 @@ $(BUILD_DIST_IOS)/$(BUILD_LIB_REL)/$(BUILD_LIB_REL):\n \t@for arch in $(DIST_ARCH_ios) ; do \\\n \t\t$(MAKE) contrib AVS_OS=ios AVS_ARCH=$$arch && \\\n \t\t$(MAKE) $(JOBS) avs AVS_OS=ios AVS_ARCH=$$arch && \\\n-\t\t$(MAKE) iosx AVS_OS=ios AVS_ARCH=$$arch ; \\\n+\t\t$(MAKE) iosx AVS_OS=ios AVS_ARCH=$$arch && \\\n+\t\techo \"creating dSYM for ios-$$arch\" && \\\n+\t\tdsymutil $(BUILD_BASE)/ios-$$arch/lib/avs.framework/avs \\\n+\t\t\t2>/dev/null && \\\n+\t\tmkdir -p $(BUILD_BASE)/ios-$$arch/lib/avs.framework/Headers && \\\n+\t\ttouch $(BUILD_BASE)/ios-$$arch/lib/avs.framework/Headers && \\\n+\t\tcp -a iosx/include/* \\\n+\t\t\t$(BUILD_BASE)/ios-$$arch/lib/avs.framework/Headers && \\\n+\t\tcp -a include/avs_wcall.h \\\n+\t\t\t$(BUILD_BASE)/ios-$$arch/lib/avs.framework/Headers && \\\n+\t\tmkdir -p $(BUILD_BASE)/ios-$$arch/lib/avs.framework/Modules && \\\n+\t\ttouch $(BUILD_BASE)/ios-$$arch/lib/avs.framework/Modules && \\\n+\t\tcp -a iosx/module.modulemap $(BUILD_BASE)/ios-$$arch/lib/avs.framework/Modules ; \\\n \tdone\n \t@mkdir -p $(dir $@)\n+\n \tlipo -create -output $@ \\\n \t\t$(foreach arch,$(DIST_ARCH_ios),\\\n \t\t-arch $(arch) $(BUILD_BASE)/ios-$(arch)/lib/avs.framework/avs)\n \n+\n+\n dist_test: $(BUILD_DIST_IOS)/$(BUILD_LIB_REL)/$(BUILD_LIB_REL)\n \n .PHONY: $(BUILD_DIST_OSX)/$(BUILD_LIB_REL)/$(BUILD_LIB_REL)\n@@ -317,9 +334,30 @@ $(BUILD_DIST_BASE)/%/$(BUILD_LIB_REL).framework.zip: \\\n \tdsymutil -o $(BUILD_DIST_BASE)/$*/Carthage/Build/iOS/avs.framework.dSYM \\\n \t\t$(BUILD_DIST_BASE)/$*/$(BUILD_LIB_REL)/$(BUILD_LIB_REL) \\\n \t\t2>/dev/null\n+\n \t@( cd $(BUILD_DIST_BASE)/$* && \\\n \t\tzip --symlinks -r $@ Carthage )\n \n+\n+$(BUILD_DIST_IOS)/$(BUILD_LIB_REL).xcframework.zip:\n+\t@for arch in $(DIST_ARCH_ios) ; do \\\n+\t     cp -a $(BUILD_DIST_IOS)/$(BUILD_LIB_REL)/Info.plist \\\n+\t\t\t$(BUILD_BASE)/ios-$$arch/lib/avs.framework/ ; \\\n+\tdone\n+\t/Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -create-xcframework \\\n+\t     $(foreach arch,$(DIST_ARCH_ios),\\\n+                -framework $(BUILD_BASE)/ios-$(arch)/lib/avs.framework/) \\\n+\t\t-output $(BUILD_DIST_IOS)/$(BUILD_LIB_REL)/avs.xcframework\n+\t@for arch in arm64 x86_64-simulator ; do \\\n+             mkdir -p $(BUILD_DIST_IOS)/$(BUILD_LIB_REL)/avs.xcframework/ios-$$arch/dSYMs && \\\n+\t     mv $(BUILD_DIST_IOS)/$(BUILD_LIB_REL)/avs.xcframework/ios-$$arch/avs.framework/avs.dSYM \\\n+\t\t$(BUILD_DIST_IOS)/$(BUILD_LIB_REL)/avs.xcframework/ios-$$arch/dSYMs ; \\\n+\tdone\n+\tcp -R $(BUILD_DIST_IOS)/$(BUILD_LIB_REL)/avs.xcframework \\\n+\t\t$(BUILD_DIST_BASE)/ios/avs.xcframework\n+\t@( cd $(BUILD_DIST_BASE)/ios && \\\n+\t\tzip --symlinks -r avs.xcframework.zip avs.xcframework )\n+\n #--- iOSX Tarballs ---\n \n $(BUILD_DIST_IOS)/$(BUILD_BALL_REL)/lib/libavsobjc.a:\n@@ -341,7 +379,7 @@ $(BUILD_DIST)/%/lib/libavsobjc.stripped.a: $(BUILD_DIST)/%/lib/libavsobjc.a\n #--- avscore Tarballs ---\n \n $(BUILD_DIST_BASE)/%/avscore.tar.bz2:\n-\t$(MAKE) contrib_librem AVS_OS=$* AVS_ARCH=x86_64 DIST=1\n+\t$(MAKE) tools contrib_librem AVS_OS=$* AVS_ARCH=x86_64 DIST=1\n \t@mkdir -p $(dir $@)/avscore\n \t@cp -a $(BUILD_BASE)/$*-x86_64/lib \\\n \t       $(BUILD_BASE)/$*-x86_64/share \\"
        },
        {
          "filename": "mk/target.mk",
          "status": "modified",
          "additions": 11,
          "deletions": 3,
          "patch": "@@ -180,6 +180,10 @@ ifeq ($(AVS_OS),)\n AVS_OS := $(HOST_OS)\n AVS_ARCH := $(HOST_ARCH)\n endif\n+ifeq ($(AVS_ARCH),arm64s)\n+AVS_ARCH := arm64\n+AVS_SIM := yes\n+endif\n ifeq ($(AVS_ARCH),)\n ifeq ($(AVS_OS),android)\n AVS_ARCH := armv7\n@@ -514,8 +518,13 @@ AVS_OS_FAMILY := darwin\n # SDK\n #\n ifeq ($(AVS_ARCH),x86_64)\n+AVS_SIM = yes\n+endif\n+\n+\n+ifdef AVS_SIM\n SDK := iphonesimulator\n-HOST_OPTIONS := --host=arm-apple-darwin\n+HOST_OPTIONS := --host=arm-apple-darwin \n else\n SDK := iphoneos\n endif\n@@ -544,8 +553,7 @@ CPPFLAGS += \\\n LFLAGS\t += \\\n \t -arch $(AVS_ARCH) \\\n \t -isysroot $(SDK_PATH) \\\n-\t -no-cpp-precomp \\\n-\t -Wl,-read_only_relocs,suppress\n+\t -no-cpp-precomp\n SH_LFLAGS += -dynamiclib\n LIBS\t += \\\n \t-lz \\"
        },
        {
          "filename": "mk/tools.mk",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -2,7 +2,8 @@\n # tools.mk\n #\n \n-TOOLS_ALL += zcall\n+TOOLS_ALL += zcall verifyd\n+#TOOLS_ALL += netprobe\n \n TOOLS_MKS := $(patsubst %,tools/%/tool.mk,$(TOOLS_ALL))\n TOOLS_OBJ_PATH := $(BUILD_OBJ)/tools"
        },
        {
          "filename": "src/audio_io/osx/audio_io_osx.cpp",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -636,6 +636,7 @@ namespace webrtc {\n             }\n             au_play_ = NULL;\n         }\n+\n         return 0;\n     }\n     \n@@ -1412,5 +1413,4 @@ namespace webrtc {\n             rec_delay_ += (rec_buffer_total_size_ - noSamp10ms) / (rec_fs_hz_ / 1000);\n         }\n     }\n-    \n }"
        },
        {
          "filename": "src/audio_level/audio_level.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -141,8 +141,8 @@ int audio_level_json(struct list *levell,\n \n \t\tja = jzon_alloc_object();\n \t\tif (ja) {\n-\t\t\tjzon_add_str(ja, \"userid\", userid);\n-\t\t\tjzon_add_str(ja, \"clientid\", clientid);\n+\t\t\tjzon_add_str(ja, \"userid\", \"%s\", userid);\n+\t\t\tjzon_add_str(ja, \"clientid\", \"%s\", clientid);\n \t\t\tjzon_add_int(ja, \"audio_level\",\n \t\t\t\t     (int32_t)a->aulevel_smooth);\n \t\t\tjzon_add_int(ja, \"audio_level_now\","
        },
        {
          "filename": "src/ecall/ecall.c",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -2060,7 +2060,8 @@ int ecall_start(struct ecall *ecall, enum icall_call_type call_type,\n {\n \tint err;\n \n-\tinfo(\"ecall(%p): start\\n\", ecall);\n+\tinfo(\"ecall(%p): start call_type=%d cbr=%d\\n\",\n+\t     ecall, call_type, audio_cbr);\n \n \tif (!ecall)\n \t\treturn EINVAL;\n@@ -2149,7 +2150,7 @@ int ecall_answer(struct ecall *ecall, enum icall_call_type call_type,\n #endif\n \t\n \n-\tinfo(\"ecall(%p): answer on pending econn %p call_type=%d\\n\", ecall, ecall->econn, call_type);\n+\tinfo(\"ecall(%p): answer on pending econn %p call_type=%d cbr=%d\\n\", ecall, ecall->econn, call_type, audio_cbr);\n \n \tif (!ecall->econn) {\n \t\twarning(\"ecall: answer: econn does not exist!\\n\");"
        },
        {
          "filename": "src/econn_fmt/msg.c",
          "status": "modified",
          "additions": 3,
          "deletions": 4,
          "patch": "@@ -308,7 +308,6 @@ static int econn_keys_decode(struct list *keyl, struct json_object *jobj)\n \treturn 0;\n }\n \n-\n int econn_message_encode(char **strp, const struct econn_message *msg)\n {\n \tstruct json_object *jobj = NULL;\n@@ -425,10 +424,10 @@ int econn_message_encode(char **strp, const struct econn_message *msg)\n \n \t\tjzon_add_bool(jobj, \"update\",\n \t\t\t      msg->u.confconn.update);\n-\t\tjzon_add_str(jobj, \"tool\",\n-\t\t\t      msg->u.confconn.tool);\n+\t\tjzon_add_str(jobj, \"tool\", \n+\t\t\t     \"%s\", msg->u.confconn.tool);\n \t\tjzon_add_str(jobj, \"toolver\",\n-\t\t\t      msg->u.confconn.toolver);\n+\t\t\t     \"%s\", msg->u.confconn.toolver);\n \t\tjzon_add_int(jobj, \"status\",\n \t\t\t      msg->u.confconn.status);\n \t\tjzon_add_bool(jobj, \"selective_audio\","
        },
        {
          "filename": "src/peerflow/cbr_detector_remote.cpp",
          "status": "modified",
          "additions": 15,
          "deletions": 7,
          "patch": "@@ -21,6 +21,9 @@\n \n #include \"cbr_detector_remote.h\"\n \n+#define MAX_MISSMATCH 10\n+#define MIN_MATCH 100\n+\n namespace wire {\n \n CbrDetectorRemote::CbrDetectorRemote()\n@@ -43,21 +46,26 @@ CbrDetectorRemote::Result CbrDetectorRemote::Decrypt(cricket::MediaType media_ty\n \n \tif (media_type == cricket::MEDIA_TYPE_AUDIO) {\n \t\tif (data_len == frame_size && frame_size >= 40) {\n+\t\t\tmissmatch_count = 0;\n \t\t\tframe_count++;\n-\t\t\tif (frame_count > 200 && !detected) {\n+\t\t\tif (frame_count > MIN_MATCH && !detected) {\n \t\t\t\tinfo(\"CBR detector: remote cbr detected\\n\");\n \t\t\t\tdetected = true;\n \t\t\t}\n \t\t}\n \t\telse {\n-\t\t\tframe_count = 0;\n-\t\t\tframe_size = data_len;\n-\t\t\tif (detected) {\n-\t\t\t\tinfo(\"CBR detector: remote cbr detected disabled\\n\");\n-\t\t\t\tdetected = false;\n+\t\t\tmissmatch_count++;\n+\t\t\tif (!detected\n+\t\t\t    || (detected && missmatch_count > MAX_MISSMATCH)) {\n+\t\t\t\tframe_count = 0;\n+\t\t\t\tframe_size = data_len;\n+\t\t\t\tmissmatch_count = 0;\n+\t\t\t\tif (detected) {\n+\t\t\t\t\tinfo(\"CBR detector: remote cbr detected disabled\\n\");\n+\t\t\t\t\tdetected = false;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n-\n \t}\n \n \tmemcpy(dst, src, data_len);"
        },
        {
          "filename": "src/peerflow/cbr_detector_remote.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -48,6 +48,7 @@ class CbrDetectorRemote : public rtc::RefCountedObject<webrtc::FrameDecryptorInt\n \tbool detected;\n \tuint32_t frame_count;\n \tuint32_t frame_size;\n+\tuint32_t missmatch_count;\n };\n \n }  // namespace wire"
        },
        {
          "filename": "src/wcall/wcall.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -2552,8 +2552,8 @@ int wcall_i_answer(struct wcall *wcall,\n \tcall_type = (call_type == WCALL_CALL_TYPE_FORCED_AUDIO) ?\n \t\t    WCALL_CALL_TYPE_NORMAL : call_type;\n \n-\tinfo(APITAG \"wcall(%p): answer calltype=%s\\n\",\n-\t     wcall, wcall_call_type_name(call_type));\n+\tinfo(APITAG \"wcall(%p): answer calltype=%s cbr=%d\\n\",\n+\t     wcall, wcall_call_type_name(call_type), audio_cbr);\n \n \tif (wcall->disable_audio)\n \t\twcall->disable_audio = false;"
        },
        {
          "filename": "test/test_acm.cpp",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -716,7 +716,6 @@ TEST(acm, wifi_channel_20ms_20pct_loss)\n     EXPECT_LT( stats.avg_expand_rate, 25.0 );\n }\n \n-#if 0\n TEST(acm, wifi_channel_20ms_20pct_loss_fec)\n {\n     float cpu_load;\n@@ -749,4 +748,3 @@ TEST(acm, wifi_channel_20ms_20pct_loss_fec)\n     EXPECT_LT( stats.max_expand_rate, 10.0 );\n     EXPECT_LT( stats.avg_expand_rate, 6.0 );\n }\n-#endif"
        },
        {
          "filename": "tools/aueffect/main.c",
          "status": "added",
          "additions": 46,
          "deletions": 0,
          "patch": "@@ -0,0 +1,46 @@\n+#include <ctype.h>\n+#include <getopt.h>\n+#include <stdlib.h>\n+#include <time.h>\n+#include <re.h>\n+#include <avs.h>\n+\n+static void progress_handler(int progress, void *arg)\n+{\n+\tprintf(\"Progress=%d\\n\", progress);\n+}\n+\n+\n+static void log_handler(uint32_t level, const char *msg, void *arg)\n+{\n+\tfprintf(stdout, msg, arg);\n+}\n+\n+\n+struct log log_def = {\n+\t.h = log_handler\n+}; \n+\n+int main(int argc, char *argv[])\n+{\n+\tchar *wavin;\n+\tchar *wavout;\n+\tint err;\n+\n+\tlog_set_min_level(LOG_LEVEL_DEBUG);\n+\t//log_register_handler(&log_def);\n+\t\n+\tif (argc != 3) {\n+\t\tfprintf(stderr, \"Usage: %s wavin wavout\\n\", argv[0]);\n+\t\treturn 22;\n+\t}\n+\n+\twavin = argv[1];\n+\twavout = argv[2];\n+\n+\terr = apply_effect_to_wav(wavin, wavout, AUDIO_EFFECT_NONE, false,\n+\t\t\t\t  progress_handler, NULL);\n+\tprintf(\"WAV completed with err=%d\\n\", err);\n+\n+\treturn 0;\n+}"
        },
        {
          "filename": "tools/aueffect/tool.mk",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+TOOL \t\t:= aueffect\n+aueffect_SRCS\t+= \\\n+\t\tmain.c\n+\n+aueffect_CPPFLAGS := $(AVS_CPPFLAGS) $(MENG_CPPFLAGS)\n+aueffect_CFLAGS := $(AVS_CFLAGS) $(AVS_CFLAGS)\n+aueffect_LIBS := $(AVS_LIBS) $(MENG_LIBS)\n+aueffect_DEPS := $(AVS_DEPS) $(MENG_DEPS)\n+aueffect_LIB_FILES := $(AVS_STATIC) $(MENG_STATIC)\n+\n+include mk/tool.mk"
        },
        {
          "filename": "tools/logparse/analyse_wireshark_dump.m",
          "status": "added",
          "additions": 312,
          "deletions": 0,
          "patch": "@@ -0,0 +1,312 @@\n+close all\n+clear all\n+\n+fid = fopen('ios_edge_through_android_hotspot4.txt','rt');\n+str = fread(fid, '*char')';\n+fclose(fid);\n+\n+% Wire settings\n+fs = 48000;\n+pt_target = 111;\n+% Whatsapp settings\n+%fs = 16000;\n+%pt_target = 120;\n+% facebook messenger settings\n+%fs = 16000;\n+%pt_target = 101;\n+% facetime\n+%fs = 24000;\n+%pt_target = [104,119,13];\n+\n+ix = strfind(str, 'No. ');\n+\n+time_buf = [];\n+pt_buf = [];\n+seq_buf = [];\n+ts_buf = [];\n+src_buf = [];\n+dst_buf = [];\n+src_port_buf = [];\n+dst_port_buf = [];\n+nBytes_buf = [];\n+msg_buf = [];\n+attr_type_buf = [];\n+attr_length_buf = [];\n+len_buf = [];\n+toc_buf = [];\n+\n+for i = 1 : length(ix)-1\n+    tmp_str = str(ix(i) : ix(i+1)-1);\n+\n+    % Get the time and srcs\n+    ix0 = strfind(tmp_str, 'Info');\n+    if length(ix0) > 0\n+        a = textscan(tmp_str(strfind(tmp_str, 'Info')+5:end),'%d%f%s%s%s%d');\n+        \n+        time = a{2};\n+        src = a{3};\n+        dst = a{4};\n+        protocol = a{5};\n+        len = a{6};\n+        \n+        ix0 = strfind(tmp_str,'Src Port:');\n+        ix00 = strfind(tmp_str(ix0:end),'(');\n+        ix01 = strfind(tmp_str(ix0:end),')');\n+        tmp_str0 = tmp_str(ix0:end);\n+        if length(tmp_str0) > 0\n+            src_port = str2num(tmp_str0(ix00(1)+1 : ix01(1)-1));\n+            dst_port = str2num(tmp_str0(ix00(2)+1 : ix01(2)-1));\n+        else\n+            src_port = -1;\n+            dst_port = -1;\n+        end\n+        ix1 = strfind(tmp_str, '0000  ');\n+        s = tmp_str(ix1(end)+5 : ix1(end)+5+30);\n+        toc = hex2dec(s(4:5));\n+        \n+        [a,b] = size(protocol);\n+        if a > 1 || b > 1\n+           protocol = 'N/A';\n+        end\n+        \n+        if strcmp(protocol,'UDP')\n+            msg_len = -1;\n+            msg_type = -1;\n+            attr_type = -1;\n+            attr_length = -1;\n+            ix0 = strfind(tmp_str,'[Length:');\n+            a = textscan(tmp_str(ix0+length('[Length:') : end), '%d');\n+            msg_len = a{1};        \n+            hdr_len = len - msg_len;\n+            if msg_len > 16 \n+                if hdr_len == 42\n+                    % Ipv4 + Ethernet\n+                    ix1 = strfind(tmp_str(ix0:end), '0020  ');\n+                    s = tmp_str(ix0+ix1+5+10*3 : ix0+ix1+5+10*3+30);\n+                    pt = hex2dec(s(4:5));\n+                    seq_nr = hex2dec([s(7:8),s(10:11)]);\n+                    ix2 = strfind(tmp_str(ix0:end), '0030  ');\n+                    s2 = tmp_str(ix0+ix2+5 : ix0+ix2+5+30);\n+                    timestamp = hex2dec([s(13:14),s(16:17),s2(1:2),s2(4:5)]);\n+                else\n+                    % Ipv4\n+                    ix1 = strfind(tmp_str(ix0:end), '0010  ');\n+                    s = tmp_str(ix0+ix1+5+12*3 : ix0+ix1+5+12*3+30);\n+                    pt = hex2dec(s(4:5));\n+                    seq_nr = hex2dec([s(7:8),s(10:11)]);\n+                    ix1 = strfind(tmp_str(ix0:end), '0020  ');\n+                    s = tmp_str(ix0+ix1+5 : ix0+ix1+5+30);\n+                    timestamp = hex2dec([s(1:2),s(4:5),s(7:8),s(10:11)]);            \n+                end\n+            else\n+                pt = -1;\n+                seq_nr = -1;\n+                timestamp = -1;\n+            end\n+            payload_len = double(msg_len);    \n+        elseif strcmp(protocol,'TFTP') || strcmp(protocol,'STUN')\n+            ix0 = strfind(tmp_str,'Message Length:');\n+            a = textscan(tmp_str(ix0+length('Message Length:') : end), '%d');\n+            msg_len = a{1};\n+            hdr_len = len - msg_len;\n+        \n+            if msg_len < 20\n+                msg_type = -1;\n+                attr_type = -1;\n+                attr_length = -1;\n+                pt = -1;\n+                seq_nr = -1;\n+                timestamp = -1;\n+                payload_len = 0;\n+            else\n+                if hdr_len == 62\n+                    % ipv4 + Ethernet\n+                    ix1 = strfind(tmp_str(ix0:end), '0020  ');\n+                    s = tmp_str(ix0+ix1+5+10*3 : ix0+ix1+5+10*3+30);\n+                    msg_type = hex2dec([s(1:2),s(4:5)]);            \n+            \n+                    ix1 = strfind(tmp_str(ix0:end), '0040  ');\n+                    s = tmp_str(ix0+ix1+5+10*3 : ix0+ix1+5+10*3+30);\n+                    attr_type = hex2dec([s(1:2),s(4:5)]);            \n+                    attr_length = hex2dec([s(7:8),s(10:11)]);\n+                    pt = hex2dec(s(16:17));\n+            \n+                    ix1 = strfind(tmp_str(ix0:end), '0050  ');\n+                    s = tmp_str(ix0+ix1+5 : ix0+ix1+5+30);            \n+                    seq_nr = hex2dec([s(1:2),s(4:5)]);\n+                    timestamp = hex2dec([s(7:8),s(10:11),s(13:14),s(16:17)]);\n+            \n+                    payload_len = double(len) - 80;            \n+                else\n+                    % ipv4\n+                    ix1 = strfind(tmp_str(ix0:end), '0010  ');\n+                    s = tmp_str(ix0+ix1+5+12*3 : ix0+ix1+5+12*3+30);\n+                    msg_type = hex2dec([s(1:2),s(4:5)]);\n+                        \n+                    ix1 = strfind(tmp_str(ix0:end), '0030  ');\n+                    s = tmp_str(ix0+ix1+5 : ix0+ix1+5+30);\n+                    attr_type = hex2dec([s(1:2),s(4:5)]);\n+                    attr_length = hex2dec([s(7:8),s(10:11)]);\n+        \n+                    ix1 = strfind(tmp_str(ix0:end), '0040  ');\n+                    s = tmp_str(ix0+ix1+5 : ix0+ix1+30);\n+                    pt = hex2dec(s(4:5));\n+            \n+                    seq_nr = hex2dec([s(7:8),s(10:11)]);\n+                    timestamp = hex2dec([s(13:14),s(16:17),s(19:20),s(22:23)]);\n+        \n+                    payload_len = double(len) - 64;            \n+                end\n+            end\n+            if strcmp(protocol,'TFTP')\n+                pt = -2;\n+            end\n+        else\n+            msg_len = -1;\n+            msg_type = -1;\n+            attr_type = -1;\n+            attr_length = -1;\n+            pt = -1;\n+            seq_nr = -1;\n+            timestamp = -1;\n+            payload_len = -1;\n+        end\n+                    \n+        if ~strcmp(protocol,'N/A') && ...\n+           ~strcmp(protocol,'IPv6') && ...\n+           ~strcmp(protocol,'ARP') && ...\n+           ~strcmp(protocol,'MDNS') && ...\n+           ~strcmp(protocol,'ICMPv6') && ...\n+           ~strcmp(protocol,'DHCPv6') && ...\n+           ~strcmp(protocol,'LLMNR')\n+        \n+            time_buf = [time_buf, time];\n+            pt_buf = [pt_buf, pt];\n+            seq_buf = [seq_buf, seq_nr];\n+            ts_buf = [ts_buf, timestamp];\n+            src_buf = [src_buf, ip2num(src{1})];\n+            dst_buf = [dst_buf, ip2num(dst{1})];\n+            src_port_buf = [src_port_buf, src_port];\n+            dst_port_buf = [dst_port_buf, dst_port];\n+            nBytes_buf =  [nBytes_buf, payload_len];\n+            msg_buf = [msg_buf, msg_type];\n+            attr_type_buf = [attr_type_buf, attr_type];\n+            attr_length_buf = [attr_length_buf, attr_length];\n+            len_buf = [len_buf, len];    \n+            toc_buf = [toc_buf, toc];\n+        end                \n+    end\n+end\n+\n+\n+flows = find_flows(src_buf, dst_buf, src_port_buf, dst_port_buf);\n+\n+figure\n+plot_rate(time_buf, len_buf, pt_buf, dst_buf, ip2num('192.168.43.13'), pt_target, 'dst');\n+figure\n+plot_rate(time_buf, len_buf, pt_buf, src_buf, ip2num('192.168.43.13'), pt_target, 'src');\n+\n+for i = 1 : length(flows)\n+    \n+    idx = find(src_buf == flows(i).src);\n+    idx = intersect(idx, find(dst_buf == flows(i).dst));\n+    idx = intersect(idx, find(src_port_buf == flows(i).src_port));\n+    idx = intersect(idx, find(dst_port_buf == flows(i).dst_port));\n+\n+    fprintf('Src %s %d Dst %s %d \\n', num2ip(flows(i).src), flows(i).src_port, num2ip(flows(i).dst), flows(i).dst_port);     \n+    fprintf('%d packets send from time %f to %f \\n', length(idx), time_buf(idx(1)), time_buf(idx(end)));\n+    t = time_buf(idx(end)) - time_buf(idx(1));\n+    fprintf('average bitrate = %f bps average packet rate = %f p/s \\n', sum(8*len_buf(idx))/t, length(idx)/t);\n+\n+    dst_buf_ = dst_buf(idx);\n+    data_ = nBytes_buf(idx);\n+    pt_ = pt_buf(idx);\n+    seq_ = seq_buf(idx);\n+    timestamp_ = ts_buf(idx);\n+    time_ = time_buf(idx);\n+    msg_ = msg_buf(idx);\n+\n+    idx = [];\n+    for j = 1 : length(pt_target)\n+        idx = [idx,find(pt_ == pt_target(j))];\n+    end\n+    idx = sort(idx);\n+\n+    if length(idx) > 2%10\n+        pt_ = pt_(idx);\n+        data_ = data_(idx);\n+        seq_ = seq_(idx);\n+        timestamp_ = timestamp_(idx);\n+        time_ = time_(idx);\n+        msg_ = msg_(idx);\n+\n+        if 0\n+            [seq_,idx] = sort(seq_);\n+            timestamp_ = timestamp_(idx);\n+            pt_ = pt_(idx);\n+            data_ = data_(idx);\n+            time_ = time_(idx);\n+        end\n+\n+        figure\n+\n+        subplot(5,2,1)\n+        plot(time_(2:end),seq_(2:end) - seq_(1:end-1))\n+        subplot(5,2,3)\n+        dts = (timestamp_(2:end) - timestamp_(1:end-1))/fs;\n+        dts = [dts(1),dts];\n+        plot(time_, dts)\n+        h = hist(dts, [0:0.01:0.5]);\n+        h = h/sum(h);\n+        subplot(5,2,4)\n+        bar([0:0.01:0.5],h)\n+        axis([0 0.2 0 1])\n+   \n+        pps = pps_smther(time_);\n+    \n+        subplot(5,2,2)\n+        plot(time_, pps)\n+        subplot(5,2,8)\n+        plot(time_, data_*8./dts)\n+        subplot(5,2,10)\n+        plot(time_,data_*8)\n+        grid on\n+\n+        subplot(5,2,7)\n+        h = hist(data_*8./dts, [0:2000:100000]);\n+        h = h/sum(h);\n+        bar([0:2000:100000],h)\n+        axis([0 100000 0 0.5])\n+        grid on\n+\n+        subplot(5,2,9)\n+        h = hist(data_*8, [0:100:5000]);\n+        h = h/sum(h);\n+        bar([0:100:5000],h)\n+        axis([0 5000 0 0.5])\n+        grid on\n+\n+        Delay = time_ - (timestamp_/fs);\n+        Delay = Delay - min(Delay);\n+        subplot(5,2,6)\n+        plot(time_, Delay)\n+        axis([min(time_) max(time_) 0 10])\n+        grid on\n+\n+        subplot(5,2,5)\n+        h = hist(Delay, [0:0.5:20]);\n+        h = h/sum(h);\n+        plot([0:0.5:20],cumsum(h))\n+        axis([1 20 0.9 1.0])\n+        grid on\n+\n+        t = sprintf('Src %s %d Dst %s %d \\n', num2ip(flows(i).src), flows(i).src_port, num2ip(flows(i).dst), flows(i).dst_port); \n+        set(gcf,'NextPlot','add');\n+        axes;\n+        h = title(t);\n+        set(gca,'Visible','off');\n+        set(h,'Visible','on');\n+        \n+    end\n+end\n+"
        },
        {
          "filename": "tools/logparse/extract_data.m",
          "status": "added",
          "additions": 421,
          "deletions": 0,
          "patch": "@@ -0,0 +1,421 @@\n+close all\n+clear\n+\n+files = dir('*.log');\n+%files = files(1:5000);\n+nFiles = length(files);\n+\n+% joining/ignoring\n+selfJoined = zeros(nFiles, 1);\n+otherJoined = zeros(nFiles, 1);\n+selfJoinedFirst = zeros(nFiles, 1);\n+isIgnoringCall = zeros(nFiles, 1);\n+\n+% stats\n+qual_reps = zeros(nFiles, 1);\n+dur = zeros(nFiles, 1);\n+ps = zeros(nFiles, 3);\n+rtt = zeros(nFiles, 3);\n+up_plr = zeros(nFiles, 3);\n+dn_plr = zeros(nFiles, 3);\n+up_jtr = zeros(nFiles, 3);\n+dn_jtr = zeros(nFiles, 3);\n+rate = zeros(nFiles, 3);\n+jBsize = zeros(nFiles, 3);\n+fec = zeros(nFiles, 3);\n+exp = zeros(nFiles, 3);\n+acc = zeros(nFiles, 3);\n+dcc = zeros(nFiles, 3);\n+\n+% metrics\n+start_time = cell(nFiles, 1);\n+success = zeros(nFiles, 1);\n+flows = zeros(nFiles, 1);\n+estab_time = zeros(nFiles, 1);\n+media_time = zeros(nFiles, 1);\n+setup_time = zeros(nFiles, 1);\n+loc_cand = cell(nFiles, 1);\n+rem_cand = cell(nFiles, 1);\n+session_ids = cell(nFiles, 1);\n+user_ids = cell(nFiles, 1);\n+\n+fid = fopen('sessions.txt','wt');\n+for i = 1 : length(files)\n+    % read log file\n+    fid_log = fopen(files(i).name, 'rt');\n+    str = fread(fid_log, '*char')';\n+    fclose(fid_log);\n+    \n+    start_time{i} = str(1:23);\n+\n+    ix0 = strfind(str, 'self isJoined: 1');\n+    selfJoined(i) = ~isempty(ix0);\n+    ix1 = strfind(str, 'other isJoined: 1');\n+    otherJoined(i) = ~isempty(ix1);\n+    selfJoinedFirst(i) = selfJoined(i) && otherJoined(i) && ix0(1) < ix1(1);\n+    \n+    isIgnoringCall(i) = ~isempty(strfind(str, 'isIgnoringCall: 1'));\n+    \n+    ix = strfind(str, 'Receive Quality Statistics');\n+    qual_reps(i) = length(ix);\n+    \n+    if qual_reps(i) == 1\n+        % log contains one quality report\n+        c = regexp(str(ix:ix+100), '(?<=]\\slast\\s)\\d+', 'match');\n+        dur(i) = str2double(c{1});\n+        \n+        if dur(i) > 0\n+            % stats\n+            ix_start = strfind(str(ix:min(ix+ 200, end)), 'packet size stats');\n+            ix_end   = strfind(str(ix:min(ix+1200, end)), '|');\n+            str2 = str(ix+ix_start(1)-1:ix+ix_end(end)-1);\n+            ps(i,:)     = extract_numbers(str2, 'packet size stats 20-40-60 ms');\n+            rtt(i,:)    = extract_numbers(str2, 'RTT (ms)');\n+            dn_jtr(i,:) = extract_numbers(str2, 'Jitter (samples)');\n+            up_plr(i,:) = extract_numbers(str2, 'Uplink Packet Loss');\n+            up_jtr(i,:) = extract_numbers(str2, 'Uplink Jitter');\n+            rate(i,:)   = extract_numbers(str2, 'Bitrate (kbps)');\n+            jBsize(i,:) = extract_numbers(str2, 'Buffer Size (ms)');\n+            dn_plr(i,:)    = extract_numbers(str2, 'Packet Loss Rate');\n+            fec(i,:)    = extract_numbers(str2, 'FEC Corrected Rate');\n+            exp(i,:)    = extract_numbers(str2, 'Expand Rate');\n+            acc(i,:)    = extract_numbers(str2, 'Accelerate Rate');\n+            dcc(i,:)    = extract_numbers(str2, 'Preemptive Rate');\n+        end\n+    end\n+    \n+    % metrics\n+    ix2 = strfind(str, 'metrics/complete');\n+    if ~isempty(ix2)\n+        ix_end = strfind(str(ix2:min(ix2+500, end)), '}');\n+        [success(i), rem_cand{i}, loc_cand{i}, session_ids{i}, user_ids{i}, flows(i), estab_time(i), media_time(i), setup_time(i)] = get_metrics(str(ix2(1):ix2(1)+ix_end(1)-1));\n+        if success(i)\n+            fprintf(fid, 'time: %s session_id: %s user_id: %s duration: %d remote candidate: %s local candidate: %s flows: %d \\n', ...\n+                start_time{i}, session_ids{i}, user_ids{i}, dur(i), rem_cand{i}, loc_cand{i}, flows(i));\n+        end\n+    else\n+        % use this if no metrics/complete found in log (doesn't seem to happen)\n+        success(i) = -1;\n+    end\n+    \n+    if mod(i, 5000) == 0\n+        fprintf('cnt = %d\\n', i);\n+    end\n+end\n+fclose all;\n+\n+fprintf('\\nLogs total: %d\\n', nFiles);\n+fprintf('--> Self Joined:   %d\\n', sum(selfJoined));\n+fprintf('--> Other Joined:  %d\\n', sum(otherJoined));\n+fprintf('--> Both Joined:   %d\\n', sum(selfJoined & otherJoined));\n+fprintf('----> Self Joined first: %d\\n', sum(selfJoinedFirst));\n+fprintf('--> Ignoring Call: %d\\n', sum(isIgnoringCall));\n+fprintf('\\nLogs with 0 quality reports: %d\\n', sum(qual_reps == 0));\n+fprintf('--> With metrics failed:  %d\\n', sum(qual_reps == 0 & success == 0));\n+fprintf('--> With metrics success: %d\\n', sum(qual_reps == 0 & success == 1));\n+fprintf('\\nLogs with 1 quality report: %d\\n', sum(qual_reps == 1));\n+fprintf('--> With metrics failed:  %d\\n', sum(qual_reps == 1 & success == 0));\n+fprintf('----> With duration == 0:   %d\\n', sum(qual_reps == 1 & success == 0 & dur == 0));\n+fprintf('----> With duration > 0:    %d\\n', sum(qual_reps == 1 & success == 0 & dur > 0));\n+fprintf('--> With metrics success: %d\\n', sum(qual_reps == 1 & success == 1));\n+fprintf('----> With duration == 0:   %d\\n', sum(qual_reps == 1 & success == 1 & dur == 0));\n+fprintf('----> With duration > 0:    %d\\n', sum(qual_reps == 1 & success == 1 & dur > 0));\n+%fprintf('------> With min(RTT) > max(RTT): %d\\n', sum(qual_reps == 1 & success == 1 & dur > 0 & rtt(:, 2) < rtt(:, 3)));\n+fprintf('----> With num_flows == 1:  %d\\n', sum(qual_reps == 1 & success == 1 & flows == 1));\n+fprintf('----> With num_flows > 1:   %d\\n', sum(qual_reps == 1 & success == 1 & flows > 1));\n+fprintf('\\nLogs with 2+ quality reports: %d\\n', sum(qual_reps > 1));\n+fprintf('--> With metrics failed:  %d\\n', sum(qual_reps > 1 & success == 0));\n+fprintf('--> With metrics success: %d\\n', sum(qual_reps > 1 & success == 1));\n+if min(success) < 0\n+    fprintf('Logs without any metrics (neither success or failed): %d\\n', sum(success == -1));\n+end\n+\n+\n+\n+% session and user maps\n+[sessions_map, sessions_sorted, sessions_count] = mapper(session_ids);\n+[users_map, users_sorted, users_count] = mapper(user_ids);\n+\n+% show details of users with most logs\n+fprintf('Total user IDs: %d\\n', length(users_count));\n+for ind = 1:20\n+    user = users_sorted{ind};\n+    fprintf('User ID %s has %d logs\\n', user, users_count(ind));\n+end\n+\n+fprintf('\\n');\n+\n+% show details of sessions with most logs\n+fprintf('Total session IDs: %d\\n', length(sessions_count));\n+for ind = 1:10\n+    ses = sessions_sorted{ind};\n+    log_ixs = sessions_map(ses);\n+    if ~strcmp(user_ids(log_ixs), 'ffffffff-ffff-ffff-ffff-ffffffffffff')\n+        fprintf('Session ID %s has %d logs:\\n', ses, sessions_count(ind));\n+        % sort by time\n+        t = zeros(size(log_ixs));\n+        for k = 1:length(log_ixs)\n+            str = start_time{log_ixs(k)};\n+            t(k) = posixtime(datetime(str(1:end-4), 'InputFormat', 'yyyy/MM/dd HH:mm:ss'));\n+            t(k) = t(k) + str2double(str(end-2:end)) / 1000;\n+        end\n+        [~, i] = sort(t);\n+        log_ixs = log_ixs(i);\n+        for k = log_ixs\n+            fprintf('  %s user ID: %s, flows: %d, duration: %d\\n', ...\n+                start_time{k}, user_ids{k}, flows(k), dur(k));\n+        end\n+    end\n+end\n+\n+\n+% indices of valid stats\n+ind = dur > 0 & rtt(:, 3) < rtt(:, 2) & flows == 1;\n+\n+ps_ = ps(ind, :);\n+rtt_ = rtt(ind, :);\n+rate_ = rate(ind, :);\n+jBsize_ = jBsize(ind, :);\n+up_jtr_ = up_jtr(ind, :);\n+dn_jtr_ = dn_jtr(ind, :);\n+up_plr_ = up_plr(ind, :);\n+dn_plr_ = dn_plr(ind, :);\n+fec_ = fec(ind, :);\n+exp_ = exp(ind, :);\n+acc_ = acc(ind, :);\n+dcc_ = dcc(ind, :);\n+rem_cand_ = rem_cand(ind);\n+loc_cand_ = loc_cand(ind);\n+\n+% RTT spread\n+bins = 0:250:10000;\n+H_rtt_spr = hist(rtt_(:,2) - rtt_(:,3),bins);\n+H_rtt_spr = H_rtt_spr / sum(H_rtt_spr);\n+\n+figure\n+bar(bins, H_rtt_spr)\n+axis([-bins(2)/2 bins(end)+bins(2)/2 0 max(H_rtt_spr)*1.1])\n+xlabel('RTT spread (ms)')\n+\n+% RTT avg / max\n+bins = 0:50:2000;\n+H_rtt_avg = hist(rtt_(:,1),bins);\n+H_rtt_avg = H_rtt_avg / sum(H_rtt_avg);\n+\n+figure\n+subplot(2,1,1)\n+bar(bins, H_rtt_avg)\n+axis([-bins(2)/2 bins(end)+bins(2)/2 0 max(H_rtt_avg)*1.1])\n+xlabel('avg RTT (ms)')\n+\n+bins = 0:250:10000;\n+H_rtt_max = hist(rtt_(:,2),bins);\n+H_rtt_max = H_rtt_max / sum(H_rtt_max);\n+\n+subplot(2,1,2)\n+bar(bins, H_rtt_max)\n+axis([-bins(2)/2 bins(end)+bins(2)/2 0 max(H_rtt_max)*1.1])\n+xlabel('Max RTT (ms)')\n+\n+% Jitter Buffer Size, avg / max\n+bins = 0:50:2000;\n+H_jbSize_avg = hist(jBsize_(:,1),bins);\n+H_jbSize_avg = H_jbSize_avg / sum(H_jbSize_avg);\n+\n+figure\n+subplot(2,1,1)\n+bar(bins, H_jbSize_avg)\n+axis([-bins(2)/2 bins(end)+bins(2)/2 0 max(H_jbSize_avg)*1.1])\n+xlabel('Avg JB size (ms)')\n+\n+bins = 0:250:10000;\n+H_jbSize_max = hist(jBsize_(:,1),bins);\n+H_jbSize_max = H_jbSize_max / sum(H_jbSize_max);\n+\n+subplot(2,1,2)\n+bar(bins, H_jbSize_max)\n+axis([-bins(2)/2 bins(end)+bins(2)/2 0 max(H_jbSize_max)*1.1])\n+xlabel('Max JB size (ms)')\n+\n+% Packet loss rate\n+bins = [0:1:20];\n+H_plr_avg = hist(dn_plr_(:,1),bins);\n+H_plr_avg = H_plr_avg / sum(H_plr_avg);\n+\n+figure\n+subplot(2,1,1)\n+bar(bins, H_plr_avg)\n+axis([-bins(2)/2 bins(end)+bins(2)/2 0 1])\n+xlabel('Avg Packet loss rate (%)')\n+\n+bins = [0:5:100];\n+H_plr_max = hist(dn_plr_(:,2),bins);\n+H_plr_max = H_plr_max / sum(H_plr_max);\n+\n+subplot(2,1,2)\n+bar(bins, H_plr_max)\n+axis([-bins(2)/2 bins(end)+bins(2)/2 0 1])\n+xlabel('Max Packet loss rate (%)')\n+\n+% Fec correction rate\n+bins = [0:1:20];\n+H_fec_avg = hist(fec_(:,1),bins);\n+H_fec_avg = H_fec_avg / sum(H_fec_avg);\n+\n+figure\n+subplot(2,1,1)\n+bar(bins, H_fec_avg)\n+axis([-bins(2)/2 bins(end)+bins(2)/2 0 1])\n+xlabel('Avg FEC correction rate (%)')\n+\n+bins = [0:5:100];\n+H_fec_max = hist(fec_(:,2),bins);\n+H_fec_max = H_fec_max / sum(H_fec_max);\n+\n+subplot(2,1,2)\n+bar(bins, H_fec_max)\n+axis([0 max(bins) 0 1.0])\n+xlabel('Max FEC correction rate (%)')\n+\n+% Expansion rate\n+bins = [0:1:20];\n+H_exp_avg = hist(exp_(:,1),bins);\n+H_exp_avg = H_exp_avg / sum(H_exp_avg);\n+\n+figure\n+subplot(2,1,1)\n+bar(bins, H_exp_avg)\n+axis([-bins(2)/2 bins(end)+bins(2)/2 0 1])\n+xlabel('Avg Expansion rate (%)')\n+\n+bins = [0:5:100];\n+H_exp_max = hist(exp_(:,2),bins);\n+H_exp_max = H_exp_max / sum(H_exp_max);\n+\n+subplot(2,1,2)\n+bar(bins, H_exp_max)\n+axis([-bins(2)/2 bins(end)+bins(2)/2 0 1])\n+xlabel('Max Expansion rate (%)')\n+\n+% Accelerate rate\n+bins = [0:1:20];\n+H_acc_avg = hist(acc_(:,1),bins);\n+H_acc_avg = H_acc_avg / sum(H_acc_avg);\n+\n+figure\n+subplot(2,1,1)\n+bar(bins, H_acc_avg)\n+axis([-bins(2)/2 bins(end)+bins(2)/2 0 1])\n+xlabel('Avg Accelerate rate (%)')\n+\n+bins = [0:5:100];\n+H_acc_max = hist(acc_(:,2),bins);\n+H_acc_max = H_acc_max / sum(H_acc_max);\n+\n+subplot(2,1,2)\n+bar(bins, H_acc_max)\n+axis([-bins(2)/2 bins(end)+bins(2)/2 0 1])\n+xlabel('Max Accelerate rate (%)')\n+\n+% Decelerate rate\n+bins = [0:1:20];\n+H_dcc_avg = hist(dcc_(:,1),bins);\n+H_dcc_avg = H_dcc_avg / sum(H_dcc_avg);\n+\n+figure\n+subplot(2,1,1)\n+bar(bins, H_dcc_avg)\n+axis([-bins(2)/2 bins(end)+bins(2)/2 0 1])\n+xlabel('Avg Decelerate rate (%)')\n+\n+subplot(2,1,2)\n+\n+bins = [0:5:100];\n+H_dcc_max = hist(dcc_(:,2),bins);\n+H_dcc_max = H_dcc_max / sum(H_dcc_max);\n+\n+bar(bins, H_dcc_max)\n+axis([-bins(2)/2 bins(end)+bins(2)/2 0 1])\n+xlabel('Max Decelerate rate, in 10 sec (%)')\n+\n+% Metrics\n+ix_prflx = strcmp(rem_cand_, 'prflx');\n+ix_srflx = strcmp(rem_cand_, 'srflx');\n+ix_host  = strcmp(rem_cand_, 'host');\n+ix_relay = strcmp(rem_cand_, 'relay');\n+\n+figure\n+H_met = [sum(ix_prflx), sum(ix_srflx), sum(ix_host), sum(ix_relay)] / length(rem_cand_) * 100;\n+bar(0:3, H_met)\n+axis([-0.5 3.5 0 100])\n+grid on\n+ax = gca;\n+ax.XTickLabel = {'prflx','srflx','host','relay'};\n+xlabel('Remote Candidate')\n+\n+% Calculate the total delay rtt + Jb for different connection types\n+TotAvgDelay = jBsize_(:,1);%rtt_(:,1);% + jBsize_(:,1);\n+bins = [0:50:5000];\n+Ha = hist(TotAvgDelay,bins);\n+Ha = Ha / sum(Ha);\n+Hp = hist(TotAvgDelay(ix_prflx),bins);\n+Hp = Hp / sum(Hp);\n+Hs = hist(TotAvgDelay(ix_srflx),bins);\n+Hs = Hs / sum(Hs);\n+Hh = hist(TotAvgDelay(ix_host),bins);\n+Hh = Hh / sum(Hh);\n+Hr = hist(TotAvgDelay(ix_relay),bins);\n+Hr = Hr / sum(Hr);\n+\n+figure\n+subplot(5,1,1)\n+bar(bins, Ha)\n+axis([0 2500 0 0.25])\n+legend('all')\n+subplot(5,1,2)\n+bar(bins, Hp)\n+axis([0 2500 0 0.25])\n+legend('prflx')\n+subplot(5,1,3)\n+bar(bins, Hs)\n+axis([0 2500 0 0.25])\n+legend('srflx')\n+subplot(5,1,4)\n+bar(bins, Hh)\n+axis([0 2500 0 0.25])\n+legend('host')\n+subplot(5,1,5)\n+bar(bins, Hr)\n+axis([0 2500 0 0.25])\n+legend('relay')\n+xlabel('Delay (ms)')\n+\n+figure\n+plot(bins,cumsum(Ha),'y')\n+hold\n+plot(bins,cumsum(Hp),'r')\n+plot(bins,cumsum(Hs),'g')\n+plot(bins,cumsum(Hh),'c')\n+plot(bins,cumsum(Hr))\n+axis([0 2500 0.0 1])\n+grid on\n+legend('all','prflx','srflx','host','relay')\n+xlabel('Delay (ms)')\n+\n+figure\n+plot(bins,cumsum(Ha),'y')\n+hold\n+plot(bins,cumsum(Hp),'r')\n+plot(bins,cumsum(Hs),'g')\n+plot(bins,cumsum(Hh),'c')\n+plot(bins,cumsum(Hr))\n+axis([0 5000 0.9 1.0])\n+grid on\n+legend('all','prflx','srflx','host','relay')\n+xlabel('Delay (ms)')\n+\n+save extracted_data selfJoined selfJoinedFirst otherJoined isIgnoringCall start_time ...\n+    session_ids user_ids success rem_cand loc_cand flows media_time estab_time setup_time ...\n+    dur ps rtt rate jBsize up_plr dn_plr up_jtr dn_jtr fec exp acc dcc ...\n+    sessions_map sessions_sorted sessions_count users_map users_sorted users_count;\n+"
        },
        {
          "filename": "tools/logparse/extract_numbers.m",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+function a = extract_numbers(str, key)\n+\n+key = strrep(key, ' ', '\\s');\n+key = strrep(key, '(', '\\(');\n+key = strrep(key, ')', '\\)');\n+pattern = ['(?<=' key '[\\s\\|:]+)[\\d\\.]+[\\s\\|]+[\\d\\.]+[\\s\\|]+[\\d\\.]+'];\n+substr = regexpi(str, pattern, 'match');\n+if isempty(substr)\n+    a = 0;\n+else\n+    a = sscanf(substr{1}, '%f | %f | %f')';\n+end"
        },
        {
          "filename": "tools/logparse/find_flows.m",
          "status": "added",
          "additions": 75,
          "deletions": 0,
          "patch": "@@ -0,0 +1,75 @@\n+function flows = find_flows(srcs, dsts, src_ports, dst_ports)\n+\n+flows = [];\n+%src = [];\n+%dst = [];\n+%src_port = [];\n+%dst_port = [];\n+\n+n = 1;\n+vec = srcs;\n+Usrcs = [];\n+while max(vec) > 0\n+    Usrcs(n) = max(vec);\n+    vec(find(vec == max(vec))) = 0;\n+    n = n + 1;\n+end\n+\n+n = 1;\n+vec = src_ports;\n+Usrc_ports = [];\n+while max(vec) > 0\n+    Usrc_ports(n) = max(vec);\n+    vec(find(vec == max(vec))) = 0;\n+    n = n + 1;\n+end\n+\n+n = 1;\n+vec = dsts;\n+Udsts = [];\n+while max(vec) > 0\n+    Udsts(n) = max(vec);\n+    vec(find(vec == max(vec))) = 0;\n+    n = n + 1;\n+end\n+\n+n = 1;\n+vec = dst_ports;\n+Udst_ports = [];\n+while max(vec) > 0\n+    Udst_ports(n) = max(vec);\n+    vec(find(vec == max(vec))) = 0;\n+    n = n + 1;\n+end\n+\n+num_flows = 0;\n+\n+for i = 1 : length(Usrcs)\n+   idx = find(srcs == Usrcs(i));\n+   dsts_ = dsts(idx);\n+   src_ports_ = src_ports(idx);\n+   dst_ports_ = dst_ports(idx);\n+   for j = 1 : length(Udsts)\n+        idx = find(dsts_ == Udsts(j));\n+        src_ports__ = src_ports_(idx);\n+        dst_ports__ = dst_ports_(idx);\n+        for k = 1 : length(Usrc_ports)\n+            idx = find(src_ports__ == Usrc_ports(k));\n+            dst_ports___ = dst_ports__(idx);\n+            for z = 1 : length(Udst_ports)\n+                idx = find(dst_ports___ == Udst_ports(z));\n+                if(length(idx) > 0)\n+                    num_flows = num_flows + 1;\n+                    flows(num_flows).src = Usrcs(i);\n+                    flows(num_flows).dst = Udsts(j);\n+                    flows(num_flows).src_port = Usrc_ports(k);\n+                    flows(num_flows).dst_port = Udst_ports(z);\n+                end\n+            end\n+        end\n+   end    \n+end\n+\n+%for i = 1 : num_flows\n+%   fprintf('Src %s %d Dst %s %d \\n', num2ip(flows(i).src), flows(i).src_port, num2ip(flows(i).dst), flows(i).dst_port); \n+%end"
        },
        {
          "filename": "tools/logparse/get_metrics.m",
          "status": "added",
          "additions": 59,
          "deletions": 0,
          "patch": "@@ -0,0 +1,59 @@\n+function [success, local_candidate, remote_candidate, session_id, user_id, ...\n+    num_flows, estab_time, media_time, setup_time] = get_metrics2(str)\n+\n+local_candidate = '';\n+remote_candidate = '';\n+session_id = 'ffffffff-ffff-ffff-ffff-ffffffffffff';\n+user_id = 'ffffffff-ffff-ffff-ffff-ffffffffffff';\n+num_flows = 0;\n+estab_time = 0;\n+setup_time = 0;\n+media_time = 0;\n+\n+str = strrep(str, '\"', '');    % remove all \"\n+success = ~isempty(strfind(str, 'success: true'));\n+if success\n+    c = regexp(str, '(?<=local_candidate:\\s)\\w+', 'match');\n+    local_candidate = c{1};\n+    \n+    c = regexp(str, '(?<=remote_candidate:\\s)\\w+', 'match');\n+    remote_candidate = c{1};\n+    \n+    ids = regexp(str, '(?<=session:\\s)[\\w-]+', 'match');\n+    if isempty(ids)\n+%        disp(['weird session: ' str]);\n+    else\n+        session_id = ids{1}(1:36);\n+        if length(ids{1}) >= 75 && ids{1}(38) == 'U'\n+            user_id = ids{1}(40:75);\n+        end\n+    end\n+    \n+    c = regexp(str, '(?<=num_flows:\\s)\\w+', 'match');\n+    if isempty(c)\n+%        disp(['weird num_flows: ' str]);\n+    else\n+        num_flows = str2double(c{1});\n+    end\n+    \n+    c = regexp(str, '(?<=estab_time:\\s)\\w+', 'match');\n+    if isempty(c)\n+        disp(['weird estab_time: ' str]);\n+    else\n+        estab_time = str2double(c{1});\n+    end\n+    \n+    c = regexp(str, '(?<=setup_time:\\s)\\w+', 'match');\n+    if isempty(c)\n+%        disp(['weird setup_time: ' str]);\n+    else\n+        setup_time = str2double(c{1});\n+    end\n+    \n+    c = regexp(str, '(?<=media_time:\\s)\\w+', 'match');\n+    if isempty(c)\n+        disp(['weird media_time: ' str]);\n+    else\n+        media_time = str2double(c{1});\n+    end\n+end"
        },
        {
          "filename": "tools/logparse/ip2num.m",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+function num = ip2num(ipadr)\n+\n+ix = strfind(ipadr, '.');\n+ix = [0,ix];\n+\n+if(length(ix) > 1)\n+    num = 0;    \n+    for i =  1 : length(ix)-1\n+        fak = 2^(8*(length(ix)-i));\n+        num = num + str2num(ipadr(ix(i)+1 : ix(i+1)-1))*fak;\n+    end\n+    fak = 1;\n+    num = num + str2num(ipadr(ix(i+1)+1 : end))*fak;\n+else\n+    num = -1;\n+end"
        },
        {
          "filename": "tools/logparse/mapper.m",
          "status": "added",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -0,0 +1,24 @@\n+function [map, ids_sorted, ids_count] = mapper(ids)\n+\n+% hash map from id -> indices\n+map = containers.Map;\n+for k = 1:length(ids)\n+    id = ids{k};\n+    if isKey(map, id)\n+        map(id) = [map(id), k];\n+    else\n+        map(id) = k;\n+    end\n+end\n+\n+remove(map, 'ffffffff-ffff-ffff-ffff-ffffffffffff');\n+\n+% sort by number of occurences\n+ids_sorted = keys(map);\n+ids_count = zeros(length(ids_sorted), 1);\n+for k = 1:length(ids_sorted)\n+    ids_count(k) = length(map(ids_sorted{k}));\n+end\n+[ids_count, ind] = sort(ids_count, 'descend');\n+ids_sorted = ids_sorted(ind);\n+"
        },
        {
          "filename": "tools/logparse/match_logs.m",
          "status": "added",
          "additions": 109,
          "deletions": 0,
          "patch": "@@ -0,0 +1,109 @@\n+close all\n+clear all\n+\n+load extracted_data;\n+\n+rtt_comb = zeros(100,3);\n+jBsize_comb = zeros(100,3);\n+TURN = zeros(100,1);\n+matches = 1;\n+\n+id_matched = zeros(1,length(session_ids(:,1)));\n+\n+\n+for i = 1 : length(session_ids(:,1))\n+    if id_matched(i) == 0\n+        sid = session_ids(i,:);\n+        for j = 1 : length(session_ids(:,1))\n+            if j ~= i && met(i,1) > -1 && met(j,1) > -1 && id_matched(j) == 0 \n+                err = sid - session_ids(j,:);\n+                e = err * err';\n+      \n+                if( e == 0)\n+                    sid\n+                    session_ids(j,:)\n+                    fprintf('found matching session_ids = %d with %d \\n', i, j);\n+                    id_matched(j) = 1;\n+                    id_matched(i) = 1;\n+                    %rtt(j,:)\n+                    %rtt(i,:)\n+                    %jBsize(j,:)\n+                    %jBsize(i,:)\n+                    rtt_comb(matches,1) = (rtt(j,1) + rtt(i,1))/2;\n+                    rtt_comb(matches,2) = max([rtt(j,2),rtt(i,2)]);\n+                    rtt_comb(matches,3) = min([rtt(j,3),rtt(i,3)]);                    \n+                    \n+                    jBsize_comb(matches,:) = jBsize(j,:) + jBsize(i,:);\n+                    \n+                    if( met(i,1) == 3)\n+                        if(met(j,1) == 3)\n+                            TURN(matches) = 2;\n+                        else\n+                            TURN(matches) = 1;\n+                        end\n+                    else\n+                        if(met(j,1) == 3)\n+                            TURN(matches) = 1;\n+                        else\n+                            TURN(matches) = 0;\n+                        end\n+                    end\n+                    \n+                    %met(j,:)\n+                    %met(i,:)\n+                    \n+                    matches = matches + 1;\n+                    %pause\n+                end     \n+            end\n+        end\n+    end\n+    if id_matched(i) == 0\n+       fprintf('could not find a match for %s \\n', session_ids(i,:)); \n+    end\n+end\n+\n+bins = [0 : 50 : 2500];\n+D = rtt_comb(:,1);% + jBsize_comb(:,1);\n+H = hist(D,bins);\n+H = H / sum(H);\n+figure; plot(bins,cumsum(H)*100)\n+grid on\n+xlabel('rtt Nw + Jb (ms)')\n+ylabel('cummulative frequency')\n+D = rtt_comb(:,1);\n+H = hist(D,bins);\n+figure; plot(bins,cumsum(H))\n+H = H / sum(H);\n+figure; plot(bins,cumsum(H))\n+figure; plot(bins,cumsum(H)*100)\n+grid on\n+xlabel('rtt Nw (ms)')\n+ylabel('cummulative frequency')\n+D = jBsize_comb(:,1);\n+H = hist(D,bins);\n+figure; plot(bins,cumsum(H))\n+H = H / sum(H);\n+figure; plot(bins,cumsum(H))\n+figure; plot(bins,cumsum(H)*100)\n+grid on\n+xlabel('rtt Nw (ms)')\n+ylabel('cummulative frequency')\n+\n+idx = find(TURN == 0);\n+H0 = hist(D(idx),bins);\n+H0 = H0 / sum(H0);\n+figure; \n+plot(bins,cumsum(H)*100,'k')\n+hold\n+plot(bins,cumsum(H0)*100)\n+grid on\n+idx = find(TURN == 1);\n+H1 = hist(D(idx),bins);\n+H1 = H1 / sum(H1);\n+plot(bins,cumsum(H1)*100,'r')\n+idx = find(TURN == 2);\n+H2 = hist(D(idx),bins);\n+H2 = H2 / sum(H2);\n+plot(bins,cumsum(H2)*100,'g')\n+"
        },
        {
          "filename": "tools/logparse/num2ip.m",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+function ip = num2ip(num)\n+\n+fak = 2^(8*3);\n+d = floor(num/fak);\n+rem = num - d*fak;\n+ip = num2str(d);\n+for i =  1 : 3\n+    fak = 2^(8*(3-i));\n+    d = floor(rem/fak);\n+    rem = rem - d*fak;\n+    ip = strcat(ip,'.',num2str(d));\n+end\n\\ No newline at end of file"
        },
        {
          "filename": "tools/logparse/plot_rate.m",
          "status": "added",
          "additions": 132,
          "deletions": 0,
          "patch": "@@ -0,0 +1,132 @@\n+function plot_rate(time, data_len, pt, ip, ip_target, pt_audio, direction)\n+\n+idx = find(ip == ip_target);\n+time_ = time(idx);\n+data_len_ = data_len(idx);\n+\n+rate = zeros(size(time_));\n+for i = 1 : length(time_)\n+    idx = find( (time_(i)-1) < time_);% < (time(i)+1));\n+    t = time_(idx);\n+    d = data_len_(idx);\n+    idx = find( (time_(i)+1) > t);\n+\n+    if( idx(end) < length(t))\n+        rate(i) = 8*sum(d(idx))/( (t(idx(end)+1)) - (t(idx(1))));\n+    elseif(i > 1)\n+        rate(i) = rate(i-1);\n+    else\n+        rate(i) = 0;\n+    end\n+end\n+\n+arg = strcat(direction,'=',num2ip(ip_target));\n+title(arg);\n+subplot(4,1,1)\n+plot(time_, rate/1000)\n+grid on\n+legend('Total')\n+ylabel('Rate (kbps)')\n+\n+idx = find(pt == -1);\n+time_ = time(idx);\n+data_len_ = data_len(idx);\n+ip_ = ip(idx);\n+\n+idx = find(ip_ == ip_target);\n+time_ = time_(idx);\n+data_len_ = data_len_(idx);\n+\n+rate = zeros(size(time_));\n+for i = 1 : length(time_)\n+    idx = find( (time_(i)-1) < time_);% < (time(i)+1));\n+    t = time_(idx);\n+    d = data_len_(idx);\n+    idx = find( (time_(i)+1) > t);\n+\n+    if( idx(end) < length(t))\n+        rate(i) = 8*sum(d(idx))/( (t(idx(end)+1)) - (t(idx(1))));\n+    elseif(i > 1)\n+        rate(i) = rate(i-1);\n+    else\n+        rate(i) = 0;\n+    end\n+end\n+\n+subplot(4,1,2)\n+plot(time_, rate/1000)\n+grid on\n+legend('TCP')\n+ylabel('Rate (kbps)')\n+\n+idx = find(pt ~= -1);\n+idx = intersect(idx, find(pt ~= pt_audio(1)));\n+for j = 2 : length(pt_audio)\n+    idx = intersect(idx, find(pt ~= pt_audio(j)));\n+end\n+time_ = time(idx);\n+data_len_ = data_len(idx);\n+ip_ = ip(idx);\n+\n+idx = find(ip_ == ip_target);\n+time_ = time_(idx);\n+data_len_ = data_len_(idx);\n+\n+rate = zeros(size(time_));\n+for i = 1 : length(time_)\n+    idx = find( (time_(i)-1) < time_);% < (time(i)+1));\n+    t = time_(idx);\n+    d = data_len_(idx);\n+    idx = find( (time_(i)+1) > t);\n+\n+    if( idx(end) < length(t))\n+        rate(i) = 8*sum(d(idx))/( (t(idx(end)+1)) - (t(idx(1))));\n+    elseif(i > 1)\n+        rate(i) = rate(i-1);\n+    else\n+        rate(i) = 0;\n+    end\n+end\n+\n+subplot(4,1,3)\n+plot(time_, rate/1000)\n+grid on\n+legend('UDP msc')\n+ylabel('Rate (kbps)')\n+\n+idx = [];\n+for j = 1 : length(pt_audio)\n+    idx = [idx,find(pt == pt_audio(j))];\n+end\n+idx = sort(idx);\n+\n+time_ = time(idx);\n+data_len_ = data_len(idx);\n+ip_ = ip(idx);\n+\n+idx = find(ip_ == ip_target);\n+time_ = time_(idx);\n+data_len_ = data_len_(idx);\n+\n+rate = zeros(size(time_));\n+for i = 1 : length(time_)\n+    idx = find( (time_(i)-1) < time_);% < (time(i)+1));\n+    t = time_(idx);\n+    d = data_len_(idx);\n+    idx = find( (time_(i)+1) > t);\n+\n+    if( idx(end) < length(t))\n+        rate(i) = 8*sum(d(idx))/( (t(idx(end)+1)) - (t(idx(1))));\n+    elseif(i > 1)\n+        rate(i) = rate(i-1);\n+    else\n+        rate(i) = 0;\n+    end\n+end\n+\n+subplot(4,1,4)\n+plot(time_, rate/1000)\n+grid on\n+legend('UDP Audio')\n+xlabel('Time (s)')\n+ylabel('Rate (kbps)')\n\\ No newline at end of file"
        },
        {
          "filename": "tools/logparse/pps_smther.m",
          "status": "added",
          "additions": 22,
          "deletions": 0,
          "patch": "@@ -0,0 +1,22 @@\n+function pps = pps_smther(time)\n+\n+pps = zeros(size(time));\n+for i = 1 : length(time)\n+idx = find( (time(i)-1) < time);% < (time(i)+1));\n+t = time(idx);\n+idx = find( (time(i)+1) > t);\n+\n+%time(i)\n+%t(idx)\n+\n+%if(time(i) > 26)\n+%    pause\n+%end\n+if( idx(end) < length(t))\n+pps(i) = length(idx)/( (t(idx(end)+1)) - (t(idx(1))));\n+elseif(i > 1)\n+pps(i) = pps(i-1);\n+else\n+pps(i) = 0;\n+end\n+end\n\\ No newline at end of file"
        },
        {
          "filename": "tools/logparse/print_logs.m",
          "status": "added",
          "additions": 47,
          "deletions": 0,
          "patch": "@@ -0,0 +1,47 @@\n+function print_logs(id1, id2)\n+\n+load extracted_data;\n+load extracted_maps\n+\n+i = get_logs(users_map, sessions_map, id1);\n+if nargin == 2\n+    ii = get_logs(users_map, sessions_map, id2);\n+    i = intersect(i, ii);\n+end\n+\n+% sort by time\n+t = zeros(size(i));\n+for k = 1:length(i)\n+    str = start_time{i(k)};\n+    t(k) = posixtime(datetime(str(1:end-4), 'InputFormat', 'yyyy/MM/dd HH:mm:ss'));\n+    t(k) = t(k) + str2double(str(end-2:end)) / 1000;\n+end\n+[~, ii] = sort(t);\n+i = i(ii);\n+\n+if 0\n+    fprintf('         Time             Session ID      User ID   Flows  Loc. Cand.  Rem. Cand.  Media Tm.  Dur.  RTT  PLoss JBSize\\n');\n+    for k = i\n+        fprintf('%s  %s..%s  %s..%s   %d   %8s    %8s   %8.1f    %4d  %4d   %4d\\n', ...\n+            start_time{k}, session_ids{k}(1:5), session_ids{k}(end-4:end), user_ids{k}(1:5), user_ids{k}(end-4:end), ...\n+            flows(k), rem_cand{k}, loc_cand{k}, media_time(k)/1e3, dur(k), rtt(k), jBsize(k));\n+    end\n+else\n+    fprintf('         Time                         Session ID                             User ID                Flows  Loc. Cand.  Rem. Cand.  Media Tm.  Dur.  RTT  PLoss JBSize\\n');\n+    for k = i\n+        fprintf('%s  %s  %s   %d   %8s    %8s   %8.1f    %4d  %4d   %4d\\n', ...\n+            start_time{k}, session_ids{k}, user_ids{k}, flows(k), rem_cand{k}, loc_cand{k}, media_time(k)/1e3, dur(k), rtt(k), jBsize(k));\n+    end\n+end\n+            \n+function log_ix = get_logs(users_map, sessions_map, id)\n+if isKey(users_map, id)\n+    disp(['User ID: ' id]);\n+    log_ix = users_map(id);\n+elseif isKey(sessions_map, id)\n+    disp(['Session ID: ' id]);\n+    log_ix = sessions_map(id);\n+else\n+    error([id, ' exists neither in the users_map nor sessions_map']);\n+    log_ix = [];\n+end"
        },
        {
          "filename": "tools/logparse/run_to_add_path.m",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+addpath(pwd);"
        },
        {
          "filename": "tools/netprobe/main.c",
          "status": "added",
          "additions": 477,
          "deletions": 0,
          "patch": "@@ -0,0 +1,477 @@\n+/*\n+* Wire\n+* Copyright (C) 2016 Wire Swiss GmbH\n+*\n+* This program is free software: you can redistribute it and/or modify\n+* it under the terms of the GNU General Public License as published by\n+* the Free Software Foundation, either version 3 of the License, or\n+* (at your option) any later version.\n+*\n+* This program is distributed in the hope that it will be useful,\n+* but WITHOUT ANY WARRANTY; without even the implied warranty of\n+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+* GNU General Public License for more details.\n+*\n+* You should have received a copy of the GNU General Public License\n+* along with this program. If not, see <http://www.gnu.org/licenses/>.\n+*/\n+/* libavs -- Network Prober\n+ */\n+\n+#include <ctype.h>\n+#include <getopt.h>\n+#include <stdlib.h>\n+#include <time.h>\n+#include <re.h>\n+#include <avs.h>\n+\n+\n+/* Defaults for arguments\n+ */\n+#define DEFAULT_REQUEST_URL \"https://prod-nginz-https.wire.com\"\n+#define DEFAULT_NOTIFICATION_URL \"https://prod-nginz-ssl.wire.com\"\n+#define DEV_REQUEST_URL \"https://staging-nginz-https.zinfra.io\"\n+#define DEV_NOTIFICATION_URL \"https://staging-nginz-ssl.zinfra.io\"\n+\n+\n+/* Globals\n+ */\n+\n+static struct engine *engine = NULL;\n+static struct config *g_config = NULL;\n+static struct probe_entry {\n+\tstruct netprobe *np;\n+\tstruct sa turn_srv;\n+\tbool secure;\n+\tint proto;\n+} netprobev[32];\n+static size_t netprobec;\n+static size_t netprobec_ok;\n+static const char *turn_uri;\n+\n+struct lookup_entry {\n+\tstruct zapi_ice_server turn;\n+\tchar *host;\n+\tint port;\n+\tint proto;\n+\tbool secure;\n+\tuint64_t ts;\n+\t\n+\tstruct le le;\n+};\n+\n+\n+static int start_netprobe(const struct sa *turn_srv,\n+\t\t\t  int proto, bool secure,\n+\t\t\t  const char *username, const char *password);\n+\n+static void dns_handler(int dns_err, const struct sa *srv, void *arg)\n+{\n+\tstruct lookup_entry *lent = arg;\n+\tstruct sa turn_srv;\n+\n+\tre_printf(\"DNS lookup for: %s err=%d\\n\", lent->host, dns_err);\n+\tif (dns_err)\n+\t\tgoto out;\n+\n+\tsa_cpy(&turn_srv, srv);\n+\tsa_set_port(&turn_srv, lent->port);\n+\n+\tre_printf(\"DNS lookup success: %s -> %J(proto=%s secure=%d)\\n\",\n+\t\t  lent->host, &turn_srv, net_proto2name(lent->proto),\n+\t\t  lent->secure);\n+\t\n+\tstart_netprobe(&turn_srv, lent->proto, lent->secure,\n+\t\t       lent->turn.username, lent->turn.credential);\n+ out:\n+\tmem_deref(lent);\n+}\n+\n+\n+static void lent_destructor(void *arg)\n+{\n+\tstruct lookup_entry *lent = arg;\n+\n+\tmem_deref(lent->host);\n+}\n+\n+\n+static int turn_dns_lookup(struct zapi_ice_server *turn,\n+\t\t\t   struct stun_uri *uri)\n+{\n+\tstruct lookup_entry *lent;\n+\tint err = 0;\n+\n+\tlent = mem_zalloc(sizeof(*lent), lent_destructor);\n+\tif (!lent)\n+\t\treturn ENOMEM;\n+\n+\tlent->turn = *turn;\n+\tlent->ts = tmr_jiffies();\n+\tlent->proto = uri->proto;\n+\tlent->secure = uri->secure;\n+\tlent->port = uri->port;\n+\terr = str_dup(&lent->host, uri->host);\n+\tif (err)\n+\t\tgoto out;\n+\n+\tre_printf(\"dns_lookup for: %s:%d\\n\", lent->host, lent->port);\n+\t\n+\terr = dns_lookup(lent->host, dns_handler, lent);\n+\tif (err) {\n+\t\twarning(\"dns_lookup: failed: %m\\n\", err);\n+\t\tgoto out;\n+\t}\n+ out:\n+\tif (err)\n+\t\tmem_deref(lent);\n+\n+\treturn err;\n+}\n+\n+\n+static void cfg_resp_handler(int err, const struct http_msg *msg,\n+\t\t\t     struct mbuf *mb, struct json_object *jobj,\n+\t\t\t     void *arg)\n+{\n+\tchar *json_str = NULL;\n+\tstruct zapi_ice_server *servers;\n+\tsize_t nservers = 0;\n+\tsize_t i;\n+\n+\tre_printf(\"config ready! err=%d\\n\");\n+\tif (err == ECONNABORTED)\n+\t\tgoto out;\n+\n+\tif (!err && jobj) {\n+\t\terr = jzon_encode(&json_str, jobj);\n+\t\tif (err)\n+\t\t\tgoto out;\n+\t}\n+\n+\tre_printf(\"CONFIG: %s\\n\", json_str);\n+\n+\tconfig_update(g_config, err, json_str, str_len(json_str));\n+\tmem_deref(json_str);\n+\t\n+\tservers = config_get_iceservers(g_config, &nservers);\n+\tre_printf(\"Probing: %d servers\\n\", nservers);\n+\n+\tfor (i = 0; i < nservers; ++i) {\n+\t\tstruct zapi_ice_server *turn = &servers[i];\n+\t\tstruct stun_uri uri;\n+\n+\t\terr = stun_uri_decode(&uri, turn->url);\n+\t\tif (err)\n+\t\t\terr = turn_dns_lookup(turn, &uri);\n+\t\telse {\n+\t\t\tstart_netprobe(&uri.addr, uri.proto, uri.secure,\n+\t\t\t\t       turn->username, turn->credential);\n+\t\t}\n+\t}\n+\n+\t\n+ out:\n+\tif (err)\n+\t\terror(\"config request failed: %m\\n\", err);\n+}\n+\n+static int config_req_handler(void *arg)\n+{\n+\tprintf(\"requesing config\\n\");\n+\treturn rest_request(NULL, engine_get_restcli(engine), 0,\n+\t\t\t    \"GET\", cfg_resp_handler, NULL,\n+\t\t\t    \"/calls/config/v2\", NULL);\n+\t\n+}\n+\n+\n+\n+\n+static void ready_handler(void *arg)\n+{\n+\tstruct stun_uri uri;\n+\tint err;\n+\n+\tdns_init(NULL);\n+\t\n+\t(void)uri;\n+\t(void)err;\n+\t\n+\tre_printf(\"engine ready.\\n\");\n+\n+\tconfig_alloc(&g_config, config_req_handler, NULL, NULL);\n+\tconfig_start(g_config);\n+\n+#if 0\n+\terr = stun_uri_decode(&uri, turn_uri);\n+\tif (err) {\n+\t\twarning(\"netprobe: ready_handler: failed to parse URI: %s\\n\",\n+\t\t\tturn_uri);\n+\t\treturn;\n+\t}\n+\n+\tstart_netprobe(&uri.addr, uri.proto, uri.secure, \"\", \"\");\n+#endif\n+}\n+\n+\n+static void error_handler(int err, void *arg)\n+{\n+\terror(\"Engine just broken: %m.\\n\", err);\n+}\n+\n+\n+static void engine_shutdown_handler(void *arg)\n+{\n+\t(void) arg;\n+\n+\tre_printf(\"The engine shutted down.\\n\");\n+\tre_cancel();\n+}\n+\n+\n+static void signal_handler(int sig)\n+{\n+\tstatic bool term = false;\n+\n+\tif (term) {\n+\t\twarning(\"Aborted.\\n\");\n+\t\texit(0);\n+\t}\n+\n+\tterm = true;\n+\n+\twarning(\"Terminating ...\\n\");\n+\n+\tengine_shutdown(engine);\n+}\n+\n+\n+static void netprobe_handler(int err, const struct netprobe_result *result,\n+\t\t\t     void *arg)\n+{\n+\tstruct probe_entry *np;\n+\tsize_t ix = (size_t)arg;\n+\n+\tif (err) {\n+\t\twarning(\"netprobe failed (%m)\\n\", err);\n+\t\tgoto out;\n+\t}\n+\n+\tnp = &netprobev[ix];\n+\n+\tre_printf(\"Network Probe results for %s TURN%s-server at %J\\n\",\n+\t\t  net_proto2name(np->proto),\n+\t\t  np->secure ? \"S\" : \"\", &np->turn_srv);\n+\tre_printf(\"    Average RTT:   %.1f milliseconds\\n\",\n+\t\t  result->rtt_avg / 1000.0);\n+\tre_printf(\"    transmitted:   %u packets\\n\", result->n_pkt_sent);\n+\tre_printf(\"    received:      %u packets\\n\", result->n_pkt_recv);\n+\tre_printf(\"\\n\");\n+\n+ out:\n+\tnetprobec_ok++;\n+\n+\tif (netprobec_ok >= netprobec) {\n+\t\tinfo(\"netprobing done. shutting down..\\n\");\n+\t\tengine_shutdown(engine);\n+\t}\n+}\n+\n+\n+static int start_netprobe(const struct sa *turn_srv,\n+\t\t\t  int proto, bool secure,\n+\t\t\t  const char *username, const char *password)\n+{\n+\tint err;\n+\n+\tre_printf(\"starting netprobe with TURN%s-server %J\"\n+\t\t  \" (proto=%s) ..\\n\",\n+\t\t  secure ? \"S\" : \"\", turn_srv,\n+\t\t  net_proto2name(proto));\n+\n+#define PACKET_COUNT 50\n+#define PACKET_INTERVAL 20\n+\n+\tif (netprobec >= ARRAY_SIZE(netprobev)) {\n+\t\twarning(\"reached maximum %zu netprobes\\n\", netprobec);\n+\t\treturn 0;\n+\t}\n+\n+\tnetprobev[netprobec].turn_srv = *turn_srv;\n+\tnetprobev[netprobec].secure = secure;\n+\tnetprobev[netprobec].proto = proto;\n+\t\n+\n+\terr = netprobe_alloc(&netprobev[netprobec].np,\n+\t\t\t     turn_srv, proto, secure,\n+\t\t\t     username, password,\n+\t\t\t     PACKET_COUNT, PACKET_INTERVAL,\n+\t\t\t     netprobe_handler, (void *)netprobec);\n+\tif (err) {\n+\t\twarning(\"could not create netprobe (%m)\\n\", err);\n+\t\tgoto out;\n+\t}\n+\n+\tnetprobec++;\n+\n+ out:\n+\treturn err;\n+}\n+\n+\n+static void usage(void)\n+{\n+\t(void)re_fprintf(stderr,\n+\t\t\t \"usage: netprobe [-dh] -e <email> -p <password>\"\n+\t\t\t \" [-r <url> -n <url>] [-t] [-t] [-d] [-d]\"\n+\t\t\t \" [-l <path>]\"\n+\t\t\t \"\\n\");\n+\t(void)re_fprintf(stderr, \"\\t-c <path>      config and cache \"\n+\t\t\t\t \t\t  \"directory\\n\");\n+\t(void)re_fprintf(stderr, \"\\t-d             Turn on debugging \"\n+\t\t\t                          \"(twice for more)\\n\");\n+\t(void)re_fprintf(stderr, \"\\t-e <email>     Email address\\n\");\n+\t(void)re_fprintf(stderr, \"\\t-p <password>  Password\\n\");\n+\t(void)re_fprintf(stderr, \"\\t-l <path>      Send debug log to file\\n\");\n+\t(void)re_fprintf(stderr, \"\\t-n <url>       Backend notification URL\"\n+\t\t\t\t \" (optional)\\n\");\n+\t(void)re_fprintf(stderr, \"\\t-r <url>       Backend request URL\"\n+\t\t\t\t \" (optional)\\n\");\n+\t(void)re_fprintf(stderr, \"\\t-D             Use dev environment\\n\");\n+\t(void)re_fprintf(stderr, \"\\t-u <TURN>      Force a TURN uri\\n\");\n+\n+\t(void)re_fprintf(stderr, \"\\t-h             Show options\\n\");\n+\t(void)re_fprintf(stderr, \"\\n\");\n+\t(void)re_fprintf(stderr, \"URLs default to regular backend.\\n\");\n+}\n+\n+\n+int main(int argc, char *argv[])\n+{\n+\tconst char *email = NULL;\n+\tconst char *password = NULL;\n+\tconst char *request_uri = DEFAULT_REQUEST_URL;\n+\tconst char *notification_uri = DEFAULT_NOTIFICATION_URL;\n+\tenum log_level level = LOG_LEVEL_WARN;\n+\tsize_t i;\n+\n+\tint err = 0;\n+\n+\tfor (;;) {\n+\t\tconst int c = getopt(argc, argv, \"de:l:n:p:r:tDu:\");\n+\t\tif (c < 0)\n+\t\t\tbreak;\n+\n+\t\tswitch (c) {\n+\n+\t\tcase 'd':\n+\t\t\tif (level == LOG_LEVEL_INFO)\n+\t\t\t\tlevel = LOG_LEVEL_DEBUG;\n+\t\t\telse\n+\t\t\t\tlevel = LOG_LEVEL_INFO;\n+\t\t\tbreak;\n+\n+\t\tcase 'D':\n+\t\t\trequest_uri = DEV_REQUEST_URL;\n+\t\t\tnotification_uri = DEV_NOTIFICATION_URL;\n+\t\t\tbreak;\n+\n+\t\tcase 'e':\n+\t\t\temail = optarg;\n+\t\t\tbreak;\n+\n+\t\tcase 'n':\n+\t\t\tnotification_uri = optarg;\n+\t\t\tbreak;\n+\n+\t\tcase 'p':\n+\t\t\tpassword = optarg;\n+\t\t\tbreak;\n+\n+\t\tcase 'r':\n+\t\t\trequest_uri = optarg;\n+\t\t\tbreak;\n+\n+\t\tcase 'u':\n+\t\t\tturn_uri = optarg;\n+\t\t\tbreak;\n+\n+\t\tcase '?':\n+\t\t\terr = EINVAL;\n+\t\t\t/* fall through */\n+\t\tcase 'h':\n+\t\t\tusage();\n+\t\t\treturn err;\n+\t\t}\n+\t}\n+\n+\tlog_set_min_level(level);\n+\n+\tif (email == NULL) {\n+\t\t(void)re_fprintf(stderr, \"Missing email.\\n\");\n+\t\terr = EINVAL;\n+\t\tgoto out;\n+\t}\n+\tif (password == NULL) {\n+\t\t(void)re_fprintf(stderr, \"Missing password.\\n\");\n+\t\terr = EINVAL;\n+\t\tgoto out;\n+\t}\n+\n+\terr = libre_init();\n+\tif (err) {\n+\t\t(void)re_fprintf(stderr, \"libre init failed: %m\\n\", err);\n+\t\tgoto out;\n+\t}\n+\n+\terr = avs_init(AVS_FLAG_EXPERIMENTAL);\n+\tif (err) {\n+\t\t(void)re_fprintf(stderr, \"avs init failed: %m\\n\", err);\n+\t\tgoto out;\n+\t}\n+\n+\tsys_coredump_set(true);\n+\n+\terr = engine_init(\"audummy\");\n+\tif (err) {\n+\t\t(void)re_fprintf(stderr, \"engine init failed: %m\\n\", err);\n+\t\tgoto out;\n+\t}\n+\n+\terr = engine_alloc(&engine, request_uri, notification_uri, email,\n+\t\t\t   password, NULL, false, false,\n+\t\t\t   \"netprobe/\" AVS_VERSION,\n+\t\t\t   ready_handler, error_handler,\n+\t\t\t   engine_shutdown_handler, 0);\n+\tif (err) {\n+\t\t(void)re_fprintf(stderr, \"Engine init failed: %m\\n\", err);\n+\t\tgoto out;\n+\t}\n+\n+\terr = re_main(signal_handler);\n+\n+ out:\n+\tfor (i=0; i<netprobec; i++)\n+\t\tmem_deref(netprobev[i].np);\n+\n+\tmem_deref(g_config);\n+\tmem_deref(engine);\n+\n+\tengine_close();\n+\tdns_close();\n+\n+\tlibre_close();\n+\n+\t/* check for memory leaks */\n+\tmem_debug();\n+\ttmr_debug();\n+\n+\tif (err) {\n+\t\treturn 1;\n+\t}\n+\telse {\n+\t\treturn 0;\n+\t}\n+}"
        },
        {
          "filename": "tools/netprobe/tool.mk",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+\n+TOOL \t\t:= netprobe\n+netprobe_SRCS\t+= \\\n+\t\tmain.c\n+\n+netprobe_CPPFLAGS := $(AVS_CPPFLAGS) $(MENG_CPPFLAGS)\n+netprobe_CFLAGS := $(AVS_CFLAGS) $(AVS_CFLAGS)\n+netprobe_LIBS := $(AVS_LIBS) $(MENG_LIBS)\n+netprobe_DEPS := $(AVS_DEPS) $(MENG_DEPS)\n+netprobe_LIB_FILES := $(AVS_STATIC) $(MENG_STATIC)\n+\n+include mk/tool.mk"
        },
        {
          "filename": "tools/packetdump/extract_audio_dump.py",
          "status": "added",
          "additions": 154,
          "deletions": 0,
          "patch": "@@ -0,0 +1,154 @@\n+from array import *\n+import matplotlib.pyplot as pyplot\n+import sys\n+import os\n+\n+def read_uint8(f):\n+    tmp = f.read(1)\n+    if tmp == \"\": return -1;\n+    out = int(tmp.encode('hex'),16)\n+    return out\n+\n+def read_uint16(f, order='big'):\n+    if order == 'big':\n+        seq = [0,1];\n+    else:\n+        seq = [1,0];\n+    tmp = f.read(2)\n+    if tmp == \"\": return -1;\n+    out = 0\n+    for j in seq: out = (out << 8) + int(tmp[j].encode('hex'),16)\n+    return out\n+\n+def read_uint32(f, order='big'):\n+    if order == 'big':\n+        seq = [0,1,2,3];\n+    else:\n+        seq = [3,2,1,0];\n+    tmp = f.read(4)\n+    out = 0\n+    for j in seq: out = (out << 8) + int(tmp[j].encode('hex'),16)\n+    return out\n+\n+file_name = sys.argv[1];\n+\n+pre, ext = os.path.splitext(file_name)\n+\n+pt_count = {};\n+d_min = {};\n+f = open(file_name,\"rb\")\n+try:\n+    byte = f.read(30)\n+    print byte\n+    length = read_uint16(f);\n+    D_min = 0xffffffff;\n+    packets = 0;\n+    #print length\n+    while length != -1:\n+        plen = read_uint16(f);\n+        time = read_uint32(f);\n+        if plen < 1:\n+            #print length;\n+            #print plen;\n+            tmp = f.read(length - 8);\n+            #print time\n+        else:\n+            tmp = read_uint8(f);\n+            pt = read_uint8(f);\n+            seq = read_uint16(f);\n+            timestamp = read_uint32(f);\n+            ssrc = read_uint32(f);\n+            tmp = f.read(plen - 12);\n+            packets = packets + 1;\n+            D = time - timestamp/48;\n+            if (pt in pt_count):\n+                pt_count[pt] = pt_count[pt] + 1;\n+                if(D < d_min[pt]): d_min[pt] = D\n+            else:\n+                pt_count[pt] = 1;\n+                d_min[pt] = D;\n+            #print time, seq\n+        length = read_uint16(f);\n+\n+    pt_opus = -1;\n+    max_cnt = -1;\n+    for p, c in pt_count.iteritems():\n+        if c > max_cnt:\n+            pt_opus = p;\n+            max_cnt = c;\n+#print pt_opus\n+    D_min = d_min[pt];\n+#print D_min;\n+finally:\n+    f.close()\n+\n+f = open(file_name,\"rb\")\n+try:\n+    packets = 0;\n+    timeBuf = array('f',[]);\n+    d1Buf = array('f',[]);\n+    dBuf = array('L',[]);\n+    timestampBuf = array('L',[]);\n+    seqBuf = array('L',[]);\n+    D_min_smth = time * 0.0001;\n+    alpha = 0.0001;\n+    prev_timestamp = -1;\n+    byte = f.read(30)\n+    length = read_uint16(f);\n+    while length != -1:\n+        plen = read_uint16(f);\n+        time = read_uint32(f);\n+            #if packets < 10:\n+            #print plen, time\n+        if plen < 1:\n+            tmp = f.read(length - 8);\n+        else:\n+            tmp = read_uint8(f);\n+            pt = read_uint8(f);\n+            seq = read_uint16(f);\n+            timestamp = read_uint32(f);\n+            ssrc = read_uint32(f);\n+            tmp = f.read(plen - 12);\n+            if pt == pt_opus:\n+                timeBuf.append(float(time)/1000.0);\n+                seqBuf.append(seq);\n+                timestampBuf.append(timestamp);\n+                d = time - timestamp/48;\n+                d1Buf.append(d);\n+                d = d - D_min;\n+                #if d == 0:\n+                #print time, seq, d\n+                if d < D_min_smth:\n+                    D_min_smth = d;\n+                else:\n+                    D_min_smth = D_min_smth*(1-alpha) + d*alpha;\n+                #d = d - int(D_min_smth)\n+                dBuf.append(d);\n+                packets = packets + 1;\n+        length = read_uint16(f);\n+finally:\n+    f.close()\n+\n+#print timeBuf[0:10]\n+#print seqBuf[0:10]\n+#print timestampBuf[0:10]\n+#print dBuf[0:10]\n+\n+maxD = max(dBuf);\n+pyplot.figure();\n+#pyplot.subplot(2,1,1);\n+#pyplot.plot(timeBuf,d1Buf);\n+#pyplot.xlim(min(timeBuf), max(timeBuf))\n+#pyplot.ylim(min(dBuf), maxD*1.2)\n+#pyplot.ylabel('Delay (ms) tot')\n+#pyplot.xlabel('Time (s)')\n+#pyplot.subplot(2,1,2);\n+pyplot.plot(timeBuf,dBuf);\n+pyplot.xlim(min(timeBuf), max(timeBuf))\n+pyplot.ylim(min(dBuf), maxD*1.2)\n+pyplot.ylabel('Delay (ms) tot')\n+pyplot.xlabel('Time (s)')\n+\n+pyplot.savefig(pre + '_Delay.png');\n+\n+#pyplot.show();"
        },
        {
          "filename": "tools/packetdump/extract_video_dump.py",
          "status": "added",
          "additions": 202,
          "deletions": 0,
          "patch": "@@ -0,0 +1,202 @@\n+from array import *\n+import matplotlib.pyplot as pyplot\n+import sys\n+import os\n+\n+def read_uint8(f):\n+    tmp = f.read(1)\n+    if tmp == \"\": return -1;\n+    out = int(tmp.encode('hex'),16)\n+    return out\n+\n+def read_uint16(f, order='big'):\n+    if order == 'big':\n+        seq = [0,1];\n+    else:\n+        seq = [1,0];\n+    tmp = f.read(2)\n+    if tmp == \"\": return -1;\n+    out = 0\n+    for j in seq: out = (out << 8) + int(tmp[j].encode('hex'),16)\n+    return out\n+\n+def read_uint32(f, order='big'):\n+    if order == 'big':\n+        seq = [0,1,2,3];\n+    else:\n+        seq = [3,2,1,0];\n+    tmp = f.read(4)\n+    out = 0\n+    for j in seq: out = (out << 8) + int(tmp[j].encode('hex'),16)\n+    return out\n+\n+file_name = sys.argv[1];\n+\n+pre, ext = os.path.splitext(file_name)\n+\n+f = open(file_name,\"rb\")\n+try:\n+    byte = f.read(30)\n+    print byte\n+    length = read_uint16(f);\n+    D_min = 0xffffffff;\n+    packets = 0;\n+    while length != -1:\n+        plen = read_uint16(f);\n+        time = read_uint32(f);\n+        Vp8Len = read_uint32(f);\n+        tmp = read_uint8(f);\n+        pt = read_uint8(f);\n+        seq = read_uint16(f);\n+        timestamp = read_uint32(f);\n+        ssrc = read_uint32(f);\n+        byte = f.read(18)\n+        packets = packets + 1;\n+        D = time - timestamp/90;\n+        if(D < D_min): D_min = D\n+        length = read_uint16(f);\n+finally:\n+    f.close()\n+\n+f = open(file_name,\"rb\")\n+try:\n+    byte = f.read(30)\n+    length = read_uint16(f);\n+    packets = 0;\n+    timeTot = array('f',[]);\n+    timeBase = array('f',[]);\n+    timeRtx = array('f',[]);\n+    dTot = array('L',[]);\n+    dBase = array('L',[]);\n+    dRtx = array('f',[]);\n+    Vp8Len = array('L',[]);\n+    timestampBuf = array('L',[]);\n+    seqBuf = array('L',[]);\n+    ptBuf = array('L',[]);\n+    D_min_smth = time * 0.0001;\n+    alpha = 0.0001;\n+    prev_timestamp = -1;\n+    rtxPt = -1000;\n+    while length != -1:\n+        plen = read_uint16(f);\n+        time = read_uint32(f);\n+        timeTot.append(float(time)/1000.0);\n+        Vp8Len.append(read_uint32(f,'little'));\n+        tmp = read_uint8(f);\n+        pt = read_uint8(f);\n+        ptBuf.append(pt);\n+        seq = read_uint16(f);\n+        seqBuf.append(seq);\n+        timestamp = read_uint32(f);\n+        timestampBuf.append(timestamp);\n+        ssrc = read_uint32(f);\n+        byte = f.read(18);\n+        d = time - timestamp/90;\n+        d = d - D_min;\n+        if d < D_min_smth:\n+            D_min_smth = d;\n+        else:\n+            D_min_smth = D_min_smth*(1-alpha) + d*alpha;\n+        d = d - int(D_min_smth)\n+        dTot.append(d);\n+        if (pt == 100 or pt == 228):\n+            dBase.append(d);\n+            timeBase.append(float(time)/1000.0);\n+        else:\n+            dRtx.append(d);\n+            timeRtx.append(float(time)/1000.0);\n+            rtxPt = pt & 0x7f;\n+        packets = packets + 1;\n+        length = read_uint16(f);\n+finally:\n+    f.close()\n+\n+maxD = max(dTot);\n+#if maxD > 1000:\n+    #maxD = 1000;\n+pyplot.figure();\n+pyplot.subplot(3,1,1);\n+pyplot.plot(timeTot,dTot);\n+pyplot.xlim(min(timeTot), max(timeTot))\n+pyplot.ylim(min(dTot), maxD*1.2)\n+pyplot.ylabel('Delay (ms) tot')\n+#pyplot.title('Total')\n+pyplot.subplot(3,1,2);\n+pyplot.plot(timeBase,dBase);\n+pyplot.xlim(min(timeTot), max(timeTot))\n+pyplot.ylim(min(dTot), max(dBase)*1.2)\n+pyplot.ylabel('Delay (ms) base')\n+#pyplot.title('Base')\n+pyplot.subplot(3,1,3);\n+pyplot.plot(timeRtx,dRtx,'.');\n+pyplot.xlim(min(timeTot), max(timeTot))\n+pyplot.ylim(min(dTot), maxD*1.2)\n+pyplot.ylabel('Delay (ms) rtx')\n+pyplot.xlabel('Time (s)')\n+#pyplot.title('Rtx')\n+\n+#pyplot.show();\n+\n+pyplot.savefig(pre + '_Delay.png');\n+\n+# Plot the bitrate\n+timeRate = array('f',[]);\n+Rate = array('f',[]);\n+Pps = array('f',[]);\n+Fps = array('f',[]);\n+loss = array('f',[]);\n+for i in range(0,packets-1):\n+    t1 = timeTot[i];\n+    t2 = t1;\n+    j = i;\n+    totBytes = Vp8Len[j];\n+    pkts = 1;\n+    frames = 0;\n+    seqArr = array('f',[]);\n+    while t2 < (t1 + 1):\n+        j = j + 1;\n+        if j > (packets-1):\n+            t2 = t1 + 3;\n+        else:\n+            totBytes = totBytes + Vp8Len[j];\n+            if ptBuf[j] == 228 or ptBuf[j] == (rtxPt + 128):\n+                frames = frames + 1;\n+            if ptBuf[j] == 100 or ptBuf[j] == 228:\n+                seqArr.append(seqBuf[j]);\n+            pkts = pkts + 1;\n+            t2 = timeTot[j];\n+    dt = t2 - t1;\n+    timeRate.append((t1 + t2)/2);\n+    Rate.append((totBytes*8)/dt);\n+    Pps.append(pkts/dt);\n+    Fps.append(frames/dt);\n+    if len(seqArr) > 1:\n+        dSeq = (max(seqArr)-min(seqArr));\n+        L = dSeq - len(seqArr);\n+        if dSeq > 0:\n+            L = L/(max(seqArr)-min(seqArr));\n+            loss.append(L*100)\n+    else:\n+        loss.append(100)\n+\n+pyplot.figure();\n+pyplot.subplot(4,1,1);\n+pyplot.plot(timeRate,Rate);\n+pyplot.xlim(min(timeTot), max(timeTot))\n+pyplot.ylabel('Rate (bps)')\n+pyplot.subplot(4,1,2);\n+pyplot.plot(timeRate,Pps);\n+pyplot.xlim(min(timeTot), max(timeTot))\n+pyplot.ylabel('Rate (pps)')\n+pyplot.subplot(4,1,3);\n+pyplot.plot(timeRate,Fps);\n+pyplot.xlim(min(timeTot), max(timeTot))\n+pyplot.ylabel('Rate (Fps)')\n+pyplot.subplot(4,1,4);\n+pyplot.plot(timeRate,loss);\n+pyplot.xlim(min(timeTot), max(timeTot))\n+pyplot.ylim(0, 100)\n+pyplot.ylabel('Loss Rate (%)')\n+pyplot.xlabel('Time (s)')\n+pyplot.savefig(pre + '_Rate.png');\n+"
        },
        {
          "filename": "tools/verifyd/main.c",
          "status": "added",
          "additions": 448,
          "deletions": 0,
          "patch": "@@ -0,0 +1,448 @@\n+/*\n+* Wire\n+* Copyright (C) 2016 Wire Swiss GmbH\n+*\n+* This program is free software: you can redistribute it and/or modify\n+* it under the terms of the GNU General Public License as published by\n+* the Free Software Foundation, either version 3 of the License, or\n+* (at your option) any later version.\n+*\n+* This program is distributed in the hope that it will be useful,\n+* but WITHOUT ANY WARRANTY; without even the implied warranty of\n+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+* GNU General Public License for more details.\n+*\n+* You should have received a copy of the GNU General Public License\n+* along with this program. If not, see <http://www.gnu.org/licenses/>.\n+*/\n+\n+#define _BSD_SOURCE 1\n+#define _DEFAULT_SOURCE 1\n+#include <getopt.h>\n+#include <stdio.h>\n+#include <re.h>\n+#include <avs.h>\n+\n+\n+struct ident_entry {\n+\tuint64_t id;\n+\tchar *ident;\n+\n+\tstruct {\n+\t\tchar *publish;\n+\t\tchar *accept;\n+\t} content;\n+};\n+\n+\n+static struct {\n+\tstruct http_sock *sock;\n+\tstruct tmr tmr;\n+\tstruct dict *idents;\n+} verifyd = {\n+\t.sock = NULL,\n+};\n+\n+\n+static void ie_destructor(void *arg)\n+{\n+\tstruct ident_entry *ie = arg;\n+\n+\tmem_deref(ie->content.publish);\n+\tmem_deref(ie->content.accept);\n+\tmem_deref(ie->ident);\n+}\n+\n+\n+static void handle_post_create(struct http_conn *conn,\n+\t\t\t       struct mbuf *mb, size_t clen)\n+{\n+\tstruct ident_entry *ie = NULL;\n+\tuint64_t ident;\n+\tchar key[256];\n+\tint err = 0;\n+\n+\tident = 1 + rand_u64() & 0xf;  // XXX for testing\n+\n+\tre_snprintf(key, sizeof(key), \"%llu\", ident);\n+\n+\tinfo(\"POST: new pairing id %llu\\n\", ident);\n+\n+\tie = mem_zalloc(sizeof(*ie), ie_destructor);\n+\n+\tie->id = ident;\n+\tstr_dup(&ie->ident, key);\n+\n+\terr = dict_add(verifyd.idents, key, ie);\n+\tif (err)\n+\t\tgoto out;\n+\n+\tmem_deref(ie); /* Owned by the dictionary */\n+\n+\thttp_creply(conn, 200, \"OK\",\n+\t\t    \"application/json\",\n+\t\t    \"{\\\"pairid\\\":\\\"%llu\\\"}\", ident);\n+\n+ out:\n+\tif (err) {\n+\t\twarning(\"internal error (%m)\\n\" ,err);\n+\t}\n+}\n+\n+\n+static void handle_put_publish(struct http_conn *conn,\n+\t\t\t       const struct http_msg *msg,\n+\t\t\t       struct mbuf *mb, size_t clen)\n+{\n+\tstruct ident_entry *ie = NULL;\n+\tstruct pl pl;\n+\tchar *key = NULL;\n+\tint err;\n+\n+\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n+\tif (err) {\n+\t\twarning(\"invalid input\\n\");\n+\t\tgoto out;\n+\t}\n+\n+\tpl_strdup(&key, &pl);\n+\n+\tie = dict_lookup(verifyd.idents, key);\n+\tif (!ie) {\n+\t\tinfo(\"publish: pairing-id %s not found\\n\", key);\n+\t\thttp_ereply(conn, 404, \"Not found\");\n+\t\tgoto out;\n+\t}\n+\n+\tdebug(\"publish: saving content(%zu): %b\\n\",\n+\t\t  clen, mbuf_buf(mb), mbuf_get_left(mb));\n+\n+\tmbuf_strdup(mb, &ie->content.publish, clen);\n+\n+\thttp_reply(conn, 200, \"OK\", NULL);\n+\n+\thttp_conn_close(conn);\n+\n+ out:\n+\tmem_deref(key);\n+}\n+\n+\n+static void handle_put_accept(struct http_conn *conn,\n+\t\t\t      const struct http_msg *msg,\n+\t\t\t      struct mbuf *mb, size_t clen)\n+{\n+\tstruct ident_entry *ie = NULL;\n+\tstruct pl pl;\n+\tchar *key = NULL;\n+\tint err;\n+\n+\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n+\tif (err) {\n+\t\twarning(\"invalid input\\n\");\n+\t\tgoto out;\n+\t}\n+\n+\tpl_strdup(&key, &pl);\n+\n+\tie = dict_lookup(verifyd.idents, key);\n+\tif (!ie) {\n+\t\tinfo(\"accept: pairing-id %s not found\\n\", key);\n+\t\thttp_ereply(conn, 404, \"Not found\");\n+\t\tgoto out;\n+\t}\n+\n+\tdebug(\"accept: saving content(%zu): %b\\n\",\n+\t\t  clen, mbuf_buf(mb), mbuf_get_left(mb));\n+\n+\tmbuf_strdup(mb, &ie->content.accept, clen);\n+\n+\thttp_reply(conn, 200, \"OK\", NULL);\n+\n+\thttp_conn_close(conn);\n+\n+ out:\n+\tmem_deref(key);\n+}\n+\n+\n+static void handle_get_publish(struct http_conn *conn,\n+\t\t\t       const struct http_msg *msg,\n+\t\t\t       struct mbuf *mb, size_t clen)\n+{\n+\tstruct ident_entry *ie = NULL;\n+\tstruct pl pl;\n+\tchar *key = NULL;\n+\tint err;\n+\n+\tinfo(\"handle get publish\\n\");\n+\n+\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n+\tif (err) {\n+\t\twarning(\"invalid input\\n\");\n+\t\tgoto out;\n+\t}\n+\n+\tpl_strdup(&key, &pl);\n+\n+\tie = dict_lookup(verifyd.idents, key);\n+\tif (!ie) {\n+\t\tinfo(\"publish: pairing-id %s not found\\n\", key);\n+\t\thttp_ereply(conn, 404, \"Not found\");\n+\t\tgoto out;\n+\t}\n+\n+\tdebug(\"handle get publish (content=%s)\\n\", ie->content.publish);\n+\n+\tif (ie->content.publish) {\n+\t\thttp_creply(conn, 200, \"OK\",\n+\t\t\t    \"application/json\", \"%s\", ie->content.publish);\n+\t}\n+\telse {\n+\t\thttp_ereply(conn, 404, \"Not Yet\");\n+\t}\n+\n+\thttp_conn_close(conn);\n+\n+ out:\n+\tmem_deref(key);\n+}\n+\n+\n+static void handle_get_accept(struct http_conn *conn,\n+\t\t\t      const struct http_msg *msg,\n+\t\t\t      struct mbuf *mb, size_t clen)\n+{\n+\tstruct ident_entry *ie = NULL;\n+\tstruct pl pl;\n+\tchar *key = NULL;\n+\tint err;\n+\n+\tinfo(\"handle get accept\\n\");\n+\n+\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n+\tif (err) {\n+\t\twarning(\"invalid input\\n\");\n+\t\tgoto out;\n+\t}\n+\n+\tpl_strdup(&key, &pl);\n+\n+\tie = dict_lookup(verifyd.idents, key);\n+\tif (!ie) {\n+\t\tinfo(\"accept: pairing-id %s not found\\n\", key);\n+\t\thttp_ereply(conn, 404, \"Not found\");\n+\t\tgoto out;\n+\t}\n+\n+\tdebug(\"handle get accept (content=%s)\\n\", ie->content.accept);\n+\n+\tif (ie->content.accept) {\n+\t\thttp_creply(conn, 200, \"OK\",\n+\t\t\t    \"application/json\", \"%s\", ie->content.accept);\n+\t}\n+\telse {\n+\t\thttp_ereply(conn, 404, \"Not Yet\");\n+\t}\n+\n+\thttp_conn_close(conn);\n+\n+ out:\n+\tmem_deref(key);\n+}\n+\n+\n+static void http_req_handler(struct http_conn *conn,\n+\t\t\t     const struct http_msg *msg, void *arg)\n+{\n+\tstruct mbuf *mb = mbuf_alloc(1024);\n+\tint err = 0;\n+\t(void)arg;\n+\n+\tinfo(\"restsrv: request %r %r%r from %J\\n\",\n+\t     &msg->met, &msg->path, &msg->prm,\n+\t     http_conn_peer(conn));\n+\n+\tif (0 == pl_strcasecmp(&msg->met, \"POST\") &&\n+\t    0 == pl_strcasecmp(&msg->path, \"/create\")) {\n+\n+\t\thandle_post_create(conn, msg->mb, (size_t)msg->clen);\n+\t}\n+\telse if (0 == pl_strcasecmp(&msg->met, \"PUT\") &&\n+\t\t 0 == pl_strcasecmp(&msg->path, \"/publish\")) {\n+\n+\t\thandle_put_publish(conn, msg, msg->mb, (size_t)msg->clen);\n+\t}\n+\telse if (0 == pl_strcasecmp(&msg->met, \"PUT\") &&\n+\t\t 0 == pl_strcasecmp(&msg->path, \"/accept\")) {\n+\n+\t\thandle_put_accept(conn, msg, msg->mb, (size_t)msg->clen);\n+\t}\n+\telse if (0 == pl_strcasecmp(&msg->met, \"GET\") &&\n+\t\t 0 == pl_strcasecmp(&msg->path, \"/publish\")) {\n+\n+\t\thandle_get_publish(conn, msg, msg->mb, (size_t)msg->clen);\n+\t}\n+\telse if (0 == pl_strcasecmp(&msg->met, \"GET\") &&\n+\t\t 0 == pl_strcasecmp(&msg->path, \"/accept\")) {\n+\n+\t\thandle_get_accept(conn, msg, msg->mb, (size_t)msg->clen);\n+\t}\n+\telse {\n+\t\twarning(\"no such resource\\n\");\n+\t\terr = ENOENT;\n+\t\tgoto out;\n+\t}\n+\n+ out:\n+\tif (err) {\n+\t\thttp_ereply(conn, 400, \"Bad Request\");\n+\t\twarning(\"restsrv: response 400 Bad Request (%m)\\n\", err);\n+\n+\t\thttp_conn_close(conn);\n+\t}\n+\n+\tmem_deref(mb);\n+}\n+\n+\n+static int srv_init(uint16_t lport)\n+{\n+\tstruct sa laddr;\n+\tstruct tcp_sock *tsock;\n+\tint err;\n+\n+\tinfo(\"srv_init: lport=%d\\n\", (int)lport);\n+\n+\terr = sa_set_str(&laddr, \"0.0.0.0\", lport);\n+\tif (err)\n+\t\treturn err;\n+\n+\terr = http_listen(&verifyd.sock, &laddr, http_req_handler, NULL);\n+\tif (err) {\n+\t\tre_fprintf(stderr, \"http_listen: failed: %m\\n\", err);\n+\t\treturn err;\n+\t}\n+\n+\ttsock = http_sock_tcp(verifyd.sock);\n+\tif (tsock) {\n+\t\ttcp_sock_local_get(tsock, &laddr);\n+\t}\n+\n+\tre_fprintf(stderr, \"verifyd: listening on %J\\n\", &laddr);\n+\n+\treturn 0;\n+}\n+\n+\n+static void srv_close(void)\n+{\n+\tverifyd.sock = mem_deref(verifyd.sock);\n+}\n+\n+\n+static void signal_handler(int sig)\n+{\n+\tstatic bool term = false;\n+\n+\tif (term) {\n+\t\twarning(\"Aborted.\\n\");\n+\t\texit(0);\n+\t}\n+\n+\tterm = true;\n+\n+\twarning(\"Terminating ...\\n\");\n+\n+\tre_cancel();\n+}\n+\n+\n+static void usage(const char *cmd)\n+{\n+\tre_fprintf(stderr, \"usage: %s -p <port>\\n\", cmd);\n+}\n+\n+\n+static void init_timeout(void *arg)\n+{\n+\tint local_port = *(int *)arg;\n+\n+\tinfo(\"init_timeout: srv_init\\n\");\n+\tsrv_init((uint16_t)local_port);\n+}\n+\n+\n+int main(int argc, char **argv)\n+{\n+\tint local_port = -1;\n+\tint err = 0;\n+\n+\tfor (;;) {\n+\t\tconst int c = getopt(argc, argv, \"p:\");\n+\n+\t\tif (c < 0)\n+\t\t\tbreak;\n+\n+\t\tswitch (c) {\n+\n+\t\tcase 'p':\n+\t\t\tlocal_port = atoi(optarg);\n+\t\t\tbreak;\n+\n+\t\tdefault:\n+\t\t\tbreak;\n+\n+\t\t}\n+\t}\n+\n+\tif (local_port == -1) {\n+\t\tusage(argv[0]);\n+\t\terr = EINVAL;\n+\t\tgoto out;\n+\t}\n+\n+\terr = libre_init();\n+\tif (err) {\n+\t\t(void)re_fprintf(stderr, \"libre init failed: %m\\n\", err);\n+\t\tgoto out;\n+\t}\n+\n+\terr = avs_init(0);\n+\tif (err) {\n+\t\t(void)re_fprintf(stderr, \"avs init failed: %m\\n\", err);\n+\t\tgoto out;\n+\t}\n+\n+\terr = dict_alloc(&verifyd.idents);\n+\tif (err) {\n+\t\tre_fprintf(stderr,\n+\t\t\t   \"%s: cannot alloc idetifier dictionary: %m\\n\",\n+\t\t\t   argv[0], err);\n+\t\tgoto out;\n+\t}\n+\n+\tlog_set_min_level(LOG_LEVEL_INFO);\n+\n+\ttmr_init(&verifyd.tmr);\n+\n+\ttmr_start(&verifyd.tmr, 1, init_timeout, &local_port);\n+\n+\tre_printf(\"re_main\\n\");\n+\tre_main(signal_handler);\n+\tre_printf(\"re_main DONE!\\n\");\n+\n+ out:\n+\ttmr_cancel(&verifyd.tmr);\n+\tmem_deref(verifyd.idents);\n+\n+\tsrv_close();\n+\n+\tlibre_close();\n+\n+\t/* check for memory leaks */\n+\tmem_debug();\n+\ttmr_debug();\n+\n+\treturn err;\n+}"
        },
        {
          "filename": "tools/verifyd/tool.mk",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+\n+TOOL \t\t:= verifyd\n+verifyd_SRCS\t+= \\\n+\t\tmain.c\n+\n+verifyd_CPPFLAGS := $(AVS_CPPFLAGS) $(MENG_CPPFLAGS)\n+verifyd_CFLAGS := $(AVS_CFLAGS) $(AVS_CFLAGS)\n+verifyd_LIBS := $(AVS_LIBS) $(MENG_LIBS)\n+verifyd_DEPS := $(AVS_DEPS) $(MENG_DEPS)\n+verifyd_LIB_FILES := $(AVS_STATIC) $(MENG_STATIC)\n+\n+include mk/tool.mk"
        },
        {
          "filename": "tools/zcall/conv.c",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -1255,7 +1255,6 @@ static void prekey_handler(const char *userid,\n \toutput(\"prekey_handler: %zu bytes, user:%s[%u] -> %s\\n\",\n \t       key_len, userid, id, clientid);\n \n-\n \terr = client_id_load(lclientid, sizeof(lclientid));\n \tif (err) {\n \t\tdebug(\"my clientid not set -- cannot store prekeys\\n\");\n@@ -1277,6 +1276,10 @@ static void prekey_handler(const char *userid,\n \t\t\t\terr);\n \t\t}\n \t}\n+\n+\tif (last) {\n+\t\toutput(\"prekey_handler: all prekeys fetched\\n\");\n+\t}\n }\n \n "
        },
        {
          "filename": "tools/zcall/how_to_batch_test.txt",
          "status": "added",
          "additions": 22,
          "deletions": 0,
          "patch": "@@ -0,0 +1,22 @@\n+How to run a batch test between zcall on android and zcall on OS X\n+\n+1) Compile zcall on osx\n+\tmake\n+2) compile avs library for android\n+\tmake dist_android DIST_ARCH=armv7\n+3) build zcall for android\n+\tmake AVS_OS=android tools\n+4) push zcall onto a android device\n+\tmake AVS_OS=android android_zcall \n+5) start zcall on OS X as normal \n+6) start zcall on android\n+\tadb shell\n+\tcd /data/local/tmp\n+\tzcall -e bla@blu -p fgtr -c /data/local/tmp -T\n+7) Set side A to auto answer\n+\t:set autoanswer 1\n+8) Start batch calling on side B\n+\t:batch_call 10 2\t- 10 calls that last 2 seconds each\n+\n+ \n+ \n\\ No newline at end of file"
        },
        {
          "filename": "webrtc/patch/webrtc_android.patch",
          "status": "removed",
          "additions": 0,
          "deletions": 279,
          "patch": "@@ -1,279 +0,0 @@\n-diff --git a/modules/utility/include/jvm_android.h b/modules/utility/include/jvm_android.h\n-index 3caab87761..44f4c2260c 100644\n---- a/modules/utility/include/jvm_android.h\n-+++ b/modules/utility/include/jvm_android.h\n-@@ -149,9 +149,10 @@ class JNIEnvironment {\n- //   JVM::Uninitialize();\n- class JVM {\n-  public:\n-+  static void Initialize(JavaVM* jvm);\n-   // Stores global handles to the Java VM interface.\n-   // Should be called once on a thread that is attached to the JVM.\n--  static void Initialize(JavaVM* jvm);\n-+  static void Initialize(JavaVM* jvm, JNIEnv *jni);\n-   // Like the method above but also passes the context to the ContextUtils\n-   // class. This method should be used by pure-C++ Android users that can't call\n-   // ContextUtils.initialize directly.\n-@@ -178,7 +179,7 @@ class JVM {\n-   JavaVM* jvm() const { return jvm_; }\n- \n-  protected:\n--  JVM(JavaVM* jvm);\n-+  JVM(JavaVM* jvm, JNIEnv *jni);\n-   ~JVM();\n- \n-  private:\n-diff --git a/modules/utility/source/jvm_android.cc b/modules/utility/source/jvm_android.cc\n-index 8e24daa0f2..b94c059d28 100644\n---- a/modules/utility/source/jvm_android.cc\n-+++ b/modules/utility/source/jvm_android.cc\n-@@ -21,6 +21,37 @@\n- namespace webrtc {\n- \n- JVM* g_jvm;\n-+JavaVM *g_vm;\n-+\n-+\n-+class Jni_Env {\n-+public:\n-+  Jni_Env() {\n-+    env = GetEnv(g_vm);\n-+    attached = false;\n-+    if (!env) {\n-+      RTC_LOG(INFO) << \"Jni_Env::Attaching thread to JVM\";\n-+\n-+      jint ret = g_vm->AttachCurrentThread(&env, nullptr);\n-+      if (ret == JNI_OK) {\n-+\tattached = true;\n-+      }\n-+      else {\n-+\tattached = false;\n-+\tenv = nullptr;\n-+      }\n-+    }\n-+  }\n-+\n-+  ~Jni_Env() {\n-+    if (attached) {\n-+      g_vm->DetachCurrentThread();\n-+    }\n-+  }\n-+\n-+  JNIEnv *env;\n-+  bool attached;\n-+};\n- \n- // TODO(henrika): add more clases here if needed.\n- struct {\n-@@ -49,11 +80,14 @@ void LoadClasses(JNIEnv* jni) {\n-     RTC_CHECK(globalRef) << c.name;\n-     c.clazz = globalRef;\n-   }\n-+\n-+  RTC_LOG(INFO) << \"LoadClasses: done\";\n- }\n- \n- void FreeClassReferences(JNIEnv* jni) {\n-   for (auto& c : loaded_classes) {\n--    jni->DeleteGlobalRef(c.clazz);\n-+    Jni_Env jenv;\n-+    jenv.env->DeleteGlobalRef(c.clazz);\n-     c.clazz = nullptr;\n-   }\n- }\n-@@ -105,8 +139,9 @@ GlobalRef::~GlobalRef() {\n- jboolean GlobalRef::CallBooleanMethod(jmethodID methodID, ...) {\n-   va_list args;\n-   va_start(args, methodID);\n--  jboolean res = jni_->CallBooleanMethodV(j_object_, methodID, args);\n--  CHECK_EXCEPTION(jni_) << \"Error during CallBooleanMethod\";\n-+  Jni_Env jenv;\n-+  jboolean res = jenv.env->CallBooleanMethodV(j_object_, methodID, args);\n-+  CHECK_EXCEPTION(jenv.env) << \"Error during CallBooleanMethod\";\n-   va_end(args);\n-   return res;\n- }\n-@@ -114,8 +149,9 @@ jboolean GlobalRef::CallBooleanMethod(jmethodID methodID, ...) {\n- jint GlobalRef::CallIntMethod(jmethodID methodID, ...) {\n-   va_list args;\n-   va_start(args, methodID);\n--  jint res = jni_->CallIntMethodV(j_object_, methodID, args);\n--  CHECK_EXCEPTION(jni_) << \"Error during CallIntMethod\";\n-+  Jni_Env jenv;\n-+  jint res = jenv.env->CallIntMethodV(j_object_, methodID, args);\n-+  CHECK_EXCEPTION(jenv.env) << \"Error during CallIntMethod\";\n-   va_end(args);\n-   return res;\n- }\n-@@ -123,7 +159,9 @@ jint GlobalRef::CallIntMethod(jmethodID methodID, ...) {\n- void GlobalRef::CallVoidMethod(jmethodID methodID, ...) {\n-   va_list args;\n-   va_start(args, methodID);\n--  jni_->CallVoidMethodV(j_object_, methodID, args);\n-+  Jni_Env jni;\n-+  if (jni.env)\n-+    jni.env->CallVoidMethodV(j_object_, methodID, args);\n-   CHECK_EXCEPTION(jni_) << \"Error during CallVoidMethod\";\n-   va_end(args);\n- }\n-@@ -136,8 +174,9 @@ NativeRegistration::NativeRegistration(JNIEnv* jni, jclass clazz)\n- \n- NativeRegistration::~NativeRegistration() {\n-   RTC_LOG(INFO) << \"NativeRegistration::dtor\";\n--  jni_->UnregisterNatives(j_class_);\n--  CHECK_EXCEPTION(jni_) << \"Error during UnregisterNatives\";\n-+  Jni_Env jenv;\n-+  jenv.env->UnregisterNatives(j_class_);\n-+  CHECK_EXCEPTION(jenv.env) << \"Error during UnregisterNatives\";\n- }\n- \n- std::unique_ptr<GlobalRef> NativeRegistration::NewObject(const char* name,\n-@@ -146,41 +185,47 @@ std::unique_ptr<GlobalRef> NativeRegistration::NewObject(const char* name,\n-   RTC_LOG(INFO) << \"NativeRegistration::NewObject\";\n-   va_list args;\n-   va_start(args, signature);\n--  jobject obj = jni_->NewObjectV(\n-+  Jni_Env jenv;\n-+  jobject obj = jenv.env->NewObjectV(\n-       j_class_, GetMethodID(jni_, j_class_, name, signature), args);\n--  CHECK_EXCEPTION(jni_) << \"Error during NewObjectV\";\n-+  CHECK_EXCEPTION(jenv.env) << \"Error during NewObjectV\";\n-   va_end(args);\n-   return std::unique_ptr<GlobalRef>(new GlobalRef(jni_, obj));\n- }\n- \n- // JavaClass implementation.\n- jmethodID JavaClass::GetMethodId(const char* name, const char* signature) {\n--  return GetMethodID(jni_, j_class_, name, signature);\n-+  Jni_Env jenv;\n-+  return GetMethodID(jenv.env, j_class_, name, signature);\n- }\n- \n- jmethodID JavaClass::GetStaticMethodId(const char* name,\n-                                        const char* signature) {\n--  return GetStaticMethodID(jni_, j_class_, name, signature);\n-+  Jni_Env jenv;\n-+  return GetStaticMethodID(jenv.env, j_class_, name, signature);\n- }\n- \n- jobject JavaClass::CallStaticObjectMethod(jmethodID methodID, ...) {\n-   va_list args;\n-   va_start(args, methodID);\n--  jobject res = jni_->CallStaticObjectMethodV(j_class_, methodID, args);\n--  CHECK_EXCEPTION(jni_) << \"Error during CallStaticObjectMethod\";\n-+  Jni_Env jenv;\n-+  jobject res = jenv.env->CallStaticObjectMethodV(j_class_, methodID, args);\n-+  CHECK_EXCEPTION(jenv.env) << \"Error during CallStaticObjectMethod\";\n-   return res;\n- }\n- \n- jint JavaClass::CallStaticIntMethod(jmethodID methodID, ...) {\n-   va_list args;\n-   va_start(args, methodID);\n--  jint res = jni_->CallStaticIntMethodV(j_class_, methodID, args);\n--  CHECK_EXCEPTION(jni_) << \"Error during CallStaticIntMethod\";\n-+  Jni_Env jenv;\n-+  jint res = jenv.env->CallStaticIntMethodV(j_class_, methodID, args);\n-+  CHECK_EXCEPTION(jenv.env) << \"Error during CallStaticIntMethod\";\n-   return res;\n- }\n- \n- // JNIEnvironment implementation.\n- JNIEnvironment::JNIEnvironment(JNIEnv* jni) : jni_(jni) {\n-+  (void)jni_;\n-   RTC_LOG(INFO) << \"JNIEnvironment::ctor\";\n- }\n- \n-@@ -196,36 +241,48 @@ std::unique_ptr<NativeRegistration> JNIEnvironment::RegisterNatives(\n-   RTC_LOG(INFO) << \"JNIEnvironment::RegisterNatives: \" << name;\n-   RTC_DCHECK(thread_checker_.IsCurrent());\n-   jclass clazz = LookUpClass(name);\n--  jni_->RegisterNatives(clazz, methods, num_methods);\n--  CHECK_EXCEPTION(jni_) << \"Error during RegisterNatives\";\n-+  Jni_Env jenv;\n-+  jenv.env->RegisterNatives(clazz, methods, num_methods);\n-+  CHECK_EXCEPTION(jenv.env) << \"Error during RegisterNatives\";\n-   return std::unique_ptr<NativeRegistration>(\n--      new NativeRegistration(jni_, clazz));\n-+      new NativeRegistration(jenv.env, clazz));\n- }\n- \n- std::string JNIEnvironment::JavaToStdString(const jstring& j_string) {\n-   RTC_DCHECK(thread_checker_.IsCurrent());\n--  const char* jchars = jni_->GetStringUTFChars(j_string, nullptr);\n--  CHECK_EXCEPTION(jni_);\n--  const int size = jni_->GetStringUTFLength(j_string);\n--  CHECK_EXCEPTION(jni_);\n-+  Jni_Env jenv;\n-+  const char* jchars = jenv.env->GetStringUTFChars(j_string, nullptr);\n-+  CHECK_EXCEPTION(jenv.env);\n-+  const int size = jenv.env->GetStringUTFLength(j_string);\n-+  CHECK_EXCEPTION(jenv.env);\n-   std::string ret(jchars, size);\n--  jni_->ReleaseStringUTFChars(j_string, jchars);\n--  CHECK_EXCEPTION(jni_);\n-+  jenv.env->ReleaseStringUTFChars(j_string, jchars);\n-+  CHECK_EXCEPTION(jenv.env);\n-   return ret;\n- }\n- \n- // static\n- void JVM::Initialize(JavaVM* jvm) {\n-+  Jni_Env jenv;\n-+\n-+  Initialize(jvm, jenv.env);\n-+}\n-+\n-+void JVM::Initialize(JavaVM* jvm, JNIEnv *jni) {\n-   RTC_LOG(INFO) << \"JVM::Initialize\";\n-   RTC_CHECK(!g_jvm);\n--  g_jvm = new JVM(jvm);\n-+  g_jvm = new JVM(jvm, jni);\n- }\n- \n- void JVM::Initialize(JavaVM* jvm, jobject context) {\n--  Initialize(jvm);\n-+  g_vm = jvm;\n-+  Jni_Env jenv;\n-+  JNIEnv* jni = jenv.env;\n-+\n-+  Initialize(jvm, jni);\n- \n-   // Pass in the context to the new ContextUtils class.\n--  JNIEnv* jni = g_jvm->jni();\n-+  //JNIEnv* jni = g_jvm->jni();\n-   jclass context_utils = FindClass(jni, \"org/webrtc/ContextUtils\");\n-   jmethodID initialize_method = jni->GetStaticMethodID(\n-       context_utils, \"initialize\", \"(Landroid/content/Context;)V\");\n-@@ -246,10 +303,11 @@ JVM* JVM::GetInstance() {\n-   return g_jvm;\n- }\n- \n--JVM::JVM(JavaVM* jvm) : jvm_(jvm) {\n-+JVM::JVM(JavaVM* jvm, JNIEnv *jni) : jvm_(jvm) {\n-   RTC_LOG(INFO) << \"JVM::JVM\";\n--  RTC_CHECK(jni()) << \"AttachCurrentThread() must be called on this thread.\";\n--  LoadClasses(jni());\n-+  RTC_CHECK(jni) << \"AttachCurrentThread() must be called on this thread.\";\n-+  g_jvm = this;\n-+  LoadClasses(jni);\n- }\n- \n- JVM::~JVM() {\n-@@ -266,6 +324,7 @@ std::unique_ptr<JNIEnvironment> JVM::environment() {\n-   // its JNIEnv, we should share the JavaVM, and use GetEnv to discover the\n-   // thread's JNIEnv. (Assuming it has one, if not, use AttachCurrentThread).\n-   // See // http://developer.android.com/training/articles/perf-jni.html.\n-+#if 0\n-   JNIEnv* jni = GetEnv(jvm_);\n-   if (!jni) {\n-     RTC_LOG(LS_ERROR)\n-@@ -273,6 +332,8 @@ std::unique_ptr<JNIEnvironment> JVM::environment() {\n-     return std::unique_ptr<JNIEnvironment>();\n-   }\n-   return std::unique_ptr<JNIEnvironment>(new JNIEnvironment(jni));\n-+#endif\n-+  return std::unique_ptr<JNIEnvironment>(new JNIEnvironment(nullptr));\n- }\n- \n- JavaClass JVM::GetClass(const char* name) {"
        },
        {
          "filename": "webrtc/scripts/build.sh",
          "status": "removed",
          "additions": 0,
          "deletions": 15,
          "patch": "@@ -1,15 +0,0 @@\n-#! /bin/bash\n-\n-DIR=$(dirname \"${BASH_SOURCE[0]}\")\n-\n-PLAT=$(uname)\n-if [ \"$PLAT\" == \"Darwin\" ]\n-then\n-\t$DIR/build_iosx.sh\n-elif [ \"$PLAT\" == \"Linux\" ]\n-then\n-\t$DIR/build_linux.sh\n-else\n-\techo \"Platform $PLAT not supported\"\n-fi\n-"
        },
        {
          "filename": "webrtc/scripts/build_iosx.sh",
          "status": "removed",
          "additions": 0,
          "deletions": 51,
          "patch": "@@ -1,51 +0,0 @@\n-#! /bin/bash\n-\n-SCRIPT_DIR=${BASH_SOURCE%/*}\n-. \"$SCRIPT_DIR/version.sh\"\n-\n-if [ -e depot_tools ]; then\n-\tpushd depot_tools > /dev/null\n-\tgit pull\n-\tpopd > /dev/null\n-else\n-\tgit clone https://chromium.googlesource.com/chromium/tools/depot_tools.git\n-fi\n-\n-export PATH=$PATH:$PWD/depot_tools\n-\n-if [ -e webrtc_checkout ]; then\n-\tpushd webrtc_checkout/ > /dev/null\n-else\n-\tmkdir webrtc_checkout\n-\tpushd webrtc_checkout/ > /dev/null\n-\tfetch --nohooks webrtc_ios\n-fi\n-\n-pushd src > /dev/null\n-if [ \"$WEBRTC_COMMIT\" == \"\" ]; then\n-\tgit checkout remotes/branch-heads/$WEBRTC_RELEASE\n-else\n-\tgit checkout $WEBRTC_COMMIT\n-fi\n-gclient sync\n-\n-for PATCH in ../../patch/*.patch; do \n-  patch -p1 < $PATCH\n-done\n-\n-export ARGS=\"is_debug=false rtc_include_tests=false rtc_build_examples=false rtc_build_tools=false use_custom_libcxx=false\"\n-gn gen out/osx-x86_64 -args=\"target_os=\\\"mac\\\" target_cpu=\\\"x64\\\" $ARGS\"\n-ninja -C out/osx-x86_64\n-\n-gn gen out/ios-x86_64 -args=\"target_os=\\\"ios\\\" target_cpu=\\\"x64\\\" $ARGS\"\n-ninja -C out/ios-x86_64\n-\n-gn gen out/ios-armv7 -args=\"target_os=\\\"ios\\\" target_cpu=\\\"arm\\\" $ARGS\"\n-ninja -C out/ios-armv7\n-\n-gn gen out/ios-arm64 -args=\"target_os=\\\"ios\\\" target_cpu=\\\"arm64\\\" $ARGS\"\n-ninja -C out/ios-arm64\n-\n-popd > /dev/null\n-popd > /dev/null\n-"
        },
        {
          "filename": "webrtc/scripts/build_linux.sh",
          "status": "removed",
          "additions": 0,
          "deletions": 59,
          "patch": "@@ -1,59 +0,0 @@\n-#! /bin/bash\n-\n-SCRIPT_DIR=${BASH_SOURCE%/*}\n-. \"$SCRIPT_DIR/version.sh\"\n-\n-if [ -e depot_tools ]; then\n-\tpushd depot_tools\n-\tgit pull\n-\tpopd\n-else\n-\tgit clone https://chromium.googlesource.com/chromium/tools/depot_tools.git\n-fi\n-\n-export PATH=$PATH:$PWD/depot_tools\n-\n-if [ -e webrtc_checkout ]; then\n-\tpushd webrtc_checkout/\n-else\n-\tmkdir webrtc_checkout\n-\tpushd webrtc_checkout/\n-\tfetch --nohooks webrtc_android\n-fi\n-\n-pushd src > /dev/null\n-\n-if [ \"$WEBRTC_COMMIT\" == \"\" ]; then\n-\tgit checkout remotes/branch-heads/$WEBRTC_RELEASE\n-else\n-\tgit checkout $WEBRTC_COMMIT\n-fi\n-yes | gclient sync\n-\n-sed s/sudo/echo\\ sudo/g build/install-build-deps-android.sh > build/install-build-deps-android-nosudo.sh\n-. build/install-build-deps-android-nosudo.sh --quick-check\n-. build/android/envsetup.sh \n-\n-for PATCH in ../../patch/*.patch; do \n-  patch -p1 < $PATCH\n-done\n-\n-export ARGS=\"is_debug=false rtc_include_tests=false rtc_build_examples=false rtc_build_tools=false use_custom_libcxx=false\"\n-gn gen out/linux-x86_64 -args=\"target_os=\\\"linux\\\" target_cpu=\\\"x64\\\" $ARGS\"\n-ninja -C out/linux-x86_64\n-\n-gn gen out/android-i386 -args=\"target_os=\\\"android\\\" target_cpu=\\\"x86\\\" $ARGS\"\n-ninja -C out/android-i386\n-\n-gn gen out/android-x86_64 -args=\"target_os=\\\"android\\\" target_cpu=\\\"x64\\\" $ARGS\"\n-ninja -C out/android-x86_64\n-\n-gn gen out/android-armv7 -args=\"target_os=\\\"android\\\" target_cpu=\\\"arm\\\" $ARGS\"\n-ninja -C out/android-armv7\n-\n-gn gen out/android-arm64 -args=\"target_os=\\\"android\\\" target_cpu=\\\"arm64\\\" $ARGS\"\n-ninja -C out/android-arm64\n-\n-popd > /dev/null\n-popd > /dev/null\n-"
        },
        {
          "filename": "webrtc/scripts/cpheader.sh",
          "status": "removed",
          "additions": 0,
          "deletions": 10,
          "patch": "@@ -1,10 +0,0 @@\n-#! /bin/bash\n-\n-srcfile=$1\n-dstfile=${srcfile/webrtc_checkout\\/src/$2\\/include}\n-\n-dstpath=`dirname $dstfile`\n-\n-mkdir -p $dstpath\n-cp $srcfile $dstfile\n-"
        },
        {
          "filename": "webrtc/scripts/package.sh",
          "status": "removed",
          "additions": 0,
          "deletions": 66,
          "patch": "@@ -1,66 +0,0 @@\n-#! /bin/bash\n-\n-SCRIPT_DIR=${BASH_SOURCE%/*}\n-. \"$SCRIPT_DIR/version.sh\"\n-\n-if [ \"$BUILD_NUMBER\" == \"\" ]; then\n-\texport BUILD_NUMBER=local;\n-fi\n-\n-AVS_OS=\"osx ios linux android\"\n-\n-WEBRTC_RB=\"$WEBRTC_RELEASE.$BUILD_NUMBER\"\n-DEST_DIR=\"../contrib/webrtc\"\n-\n-HOST_OS=$(uname)\n-\n-if [ \"$HOST_OS\" == \"Darwin\" ]; then\n-\techo \"Packaging header files\"\n-\trm -r $WEBRTC_RB 2> /dev/null\n-\tmkdir -p $WEBRTC_RB/include\n-\techo WEBRTC_RELEASE=$WEBRTC_RELEASE > $WEBRTC_RB/version.txt\n-\techo WEBRTC_COMMIT=$WEBRTC_COMMIT >> $WEBRTC_RB/version.txt\n-\tfind webrtc_checkout/src -type f -iname \"*.h\" -exec scripts/cpheader.sh {} $WEBRTC_RB \\;\n-\tzip -9r webrtc_${WEBRTC_RB}_headers.zip $WEBRTC_RB version.txt\n-\n-fi\n-\n-for OS in $AVS_OS; do\n-\techo \"Packaging $OS files\"\n-\trm -r $WEBRTC_RB 2> /dev/null\n-\n-\tfor p in webrtc_checkout/src/out/${OS}*; do\n-\t\tdst=$WEBRTC_RB/lib/${p/webrtc_checkout\\/src\\/out\\//}\n-\t\tif [ -e $p/obj/libwebrtc.a ]; then\n-\t\t\tmkdir -p $dst\n-\t\t\tcp $p/obj/libwebrtc.a $dst/\n-\t\tfi\n-\n-\t\tjar=$p/obj/modules/audio_device/audio_device_java__process_prebuilt-desugar.jar\n-\t\tif [ -e $jar ]; then\n-\t\t\tmkdir -p $WEBRTC_RB/java\n-\t\t\tcp $jar $WEBRTC_RB/java/audiodev.jar\n-\t\tfi\n-\n-\t\tjar=$p/obj/rtc_base/base_java__process_prebuilt-desugar.jar\n-\t\tif [ -e $jar ]; then\n-\t\t\tmkdir -p $WEBRTC_RB/java\n-\t\t\tcp $jar $WEBRTC_RB/java/base.jar\n-\t\tfi\n-\n-\t\tif [ \"$HOST_OS\" == \"Darwin\" ] && [ \"$OS\" == \"ios\" ]; then\n-\t\t\tmkdir -p $WEBRTC_RB/ios\n-\t\t\tcp webrtc_checkout/src/sdk/objc/components/audio/RTCAudioSession+Configuration.mm $WEBRTC_RB/ios\n-\t\t\tcp webrtc_checkout/src/sdk/objc/helpers/UIDevice+RTCDevice.mm $WEBRTC_RB/ios\n-\t\tfi\n-\tdone\n-\n-\n-\tif [ -e $WEBRTC_RB ]; then\n-\t\tzip -9r webrtc_${WEBRTC_RB}_${OS}.zip $WEBRTC_RB\n-\tfi\n-done\n-\n-echo \"Copying zips to $DEST_DIR\"\n-mkdir -p $DEST_DIR\n-cp *.zip $DEST_DIR"
        },
        {
          "filename": "webrtc/scripts/version.sh",
          "status": "removed",
          "additions": 0,
          "deletions": 4,
          "patch": "@@ -1,4 +0,0 @@\n-\n-export WEBRTC_RELEASE=m79\n-export WEBRTC_COMMIT=b484ec0082948ae086c2ba4142b4d2bf8bc4dd4b\n-"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 18,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b8e08cb2f3c34ae8562870ac31a59321a9fd1652",
            "date": "2025-01-13T09:52:28Z",
            "author_login": "z-dule"
          },
          {
            "sha": "d6015b146bbea4aece030ae8993214775c5edc24",
            "date": "2025-01-13T09:52:03Z",
            "author_login": "z-dule"
          },
          {
            "sha": "8319805cb6bf27dfc05df6b02952ad5d4edd765d",
            "date": "2025-01-13T09:51:28Z",
            "author_login": "z-dule"
          },
          {
            "sha": "d9c54b3ce370910473be61e3bee81a4736f5c961",
            "date": "2024-12-11T13:11:42Z",
            "author_login": "z-dule"
          },
          {
            "sha": "e02dedc9e748b90af65df047db7ff1fe4131e8ee",
            "date": "2024-12-11T12:17:56Z",
            "author_login": "z-dule"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-134",
    "description": "wire-avs is the audio visual signaling (AVS) component of Wire, an open-source messenger. A remote format string vulnerability in versions prior to 7.1.12 allows an attacker to cause a denial of service or possibly execute arbitrary code. The issue has been fixed in wire-avs 7.1.12. There are currently no known workarounds.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-03-01T19:15:08.403",
    "last_modified": "2024-11-21T06:25:44.177",
    "fix_date": "2021-09-07T11:07:15Z"
  },
  "references": [
    {
      "url": "https://github.com/wireapp/wire-avs/commit/40d373ede795443ae6f2f756e9fb1f4f4ae90bbe",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/wireapp/wire-avs/security/advisories/GHSA-2j6v-xpf3-xvrv",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/wireapp/wire-avs/commit/40d373ede795443ae6f2f756e9fb1f4f4ae90bbe",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/wireapp/wire-avs/security/advisories/GHSA-2j6v-xpf3-xvrv",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:59.764823",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "wire-avs",
    "owner": "wireapp",
    "created_at": "2016-03-10T09:19:37Z",
    "updated_at": "2025-01-13T09:52:45Z",
    "pushed_at": "2025-01-13T15:25:52Z",
    "size": 30358,
    "stars": 134,
    "forks": 55,
    "open_issues": 6,
    "watchers": 134,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-7.1",
      "release-7.2",
      "release-8.0",
      "release-8.1"
    ],
    "languages": {
      "C": 1570856,
      "C++": 984930,
      "Objective-C": 196360,
      "Java": 135850,
      "Makefile": 125597,
      "MATLAB": 78962,
      "Objective-C++": 71233,
      "TypeScript": 70374,
      "Python": 24282,
      "Shell": 16199,
      "JavaScript": 9544,
      "Dockerfile": 403
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-14T14:39:35.089051"
  }
}