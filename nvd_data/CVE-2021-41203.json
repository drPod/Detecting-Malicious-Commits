{
  "cve_id": "CVE-2021-41203",
  "github_data": {
    "repository": "tensorflow/tensorflow",
    "fix_commit": "368af875869a204b4ac552b9ddda59f6a46a56ec",
    "related_commits": [
      "368af875869a204b4ac552b9ddda59f6a46a56ec",
      "abcced051cb1bd8fb05046ac3b6023a7ebcc4578",
      "b619c6f865715ca3b15ef1842b5b95edbaa710ad",
      "e8dc63704c88007ee4713076605c90188d66f3d2",
      "368af875869a204b4ac552b9ddda59f6a46a56ec",
      "abcced051cb1bd8fb05046ac3b6023a7ebcc4578",
      "b619c6f865715ca3b15ef1842b5b95edbaa710ad",
      "e8dc63704c88007ee4713076605c90188d66f3d2"
    ],
    "patch_url": "https://github.com/tensorflow/tensorflow/commit/368af875869a204b4ac552b9ddda59f6a46a56ec.patch",
    "fix_commit_details": {
      "sha": "368af875869a204b4ac552b9ddda59f6a46a56ec",
      "commit_date": "2021-08-25T20:45:01Z",
      "author": {
        "login": "tensorflower-gardener",
        "type": "User",
        "stats": {
          "total_commits": 51283,
          "average_weekly_commits": 106.83958333333334,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 450
        }
      },
      "commit_message": {
        "title": "Avoid buffer overflow when loading tensors with insufficient data from checkpoints.",
        "length": 364,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 69,
        "additions": 69,
        "deletions": 0
      },
      "files": [
        {
          "filename": "tensorflow/core/util/saved_tensor_slice_util.h",
          "status": "modified",
          "additions": 26,
          "deletions": 0,
          "patch": "@@ -59,6 +59,9 @@ Status ParseShapeAndSlice(const string& shape_and_slice, TensorShape* shape,\n template <typename T>\n struct SaveTypeTraits;\n \n+template <typename T>\n+int TensorProtoDataSize(const TensorProto& t);\n+\n template <typename T>\n const typename SaveTypeTraits<T>::SavedType* TensorProtoData(\n     const TensorProto& t);\n@@ -95,6 +98,10 @@ void Fill(T* data, size_t n, TensorProto* t);\n #define TENSOR_PROTO_EXTRACT_TYPE(TYPE, FIELD, FTYPE)             \\\n   TENSOR_PROTO_EXTRACT_TYPE_HELPER(TYPE, FIELD, FTYPE, FTYPE)     \\\n   template <>                                                     \\\n+  inline int TensorProtoDataSize<TYPE>(const TensorProto& t) {    \\\n+    return t.FIELD##_val_size();                                  \\\n+  }                                                               \\\n+  template <>                                                     \\\n   inline void Fill(const TYPE* data, size_t n, TensorProto* t) {  \\\n     typename protobuf::RepeatedField<FTYPE> copy(data, data + n); \\\n     t->mutable_##FIELD##_val()->Swap(&copy);                      \\\n@@ -104,6 +111,10 @@ void Fill(T* data, size_t n, TensorProto* t);\n #define TENSOR_PROTO_EXTRACT_TYPE_COMPLEX(TYPE, FIELD, FTYPE)       \\\n   TENSOR_PROTO_EXTRACT_TYPE_HELPER(TYPE, FIELD, FTYPE, TYPE)        \\\n   template <>                                                       \\\n+  inline int TensorProtoDataSize<TYPE>(const TensorProto& t) {      \\\n+    return t.FIELD##_val_size() / 2;                                \\\n+  }                                                                 \\\n+  template <>                                                       \\\n   inline void Fill(const TYPE* data, size_t n, TensorProto* t) {    \\\n     const FTYPE* sub = reinterpret_cast<const FTYPE*>(data);        \\\n     typename protobuf::RepeatedField<FTYPE> copy(sub, sub + 2 * n); \\\n@@ -136,6 +147,11 @@ TENSOR_PROTO_EXTRACT_TYPE(quint16, int, int32);\n template <>\n struct SaveTypeTraits<qint32> : SaveTypeTraits<int32> {};\n \n+template <>\n+inline int TensorProtoDataSize<qint32>(const TensorProto& t) {\n+  return t.int_val_size();\n+}\n+\n template <>\n inline const int32* TensorProtoData<qint32>(const TensorProto& t) {\n   static_assert(SaveTypeTraits<qint32>::supported,\n@@ -158,6 +174,11 @@ struct SaveTypeTraits<Eigen::half> {\n   typedef protobuf::RepeatedField<int32> RepeatedField;\n };\n \n+template <>\n+inline int TensorProtoDataSize<Eigen::half>(const TensorProto& t) {\n+  return t.half_val_size();\n+}\n+\n template <>\n inline const int* TensorProtoData<Eigen::half>(const TensorProto& t) {\n   return t.half_val().data();\n@@ -187,6 +208,11 @@ struct SaveTypeTraits<tstring> {\n   typedef protobuf::RepeatedPtrField<string> RepeatedField;\n };\n \n+template <>\n+inline int TensorProtoDataSize<tstring>(const TensorProto& t) {\n+  return t.string_val_size();\n+}\n+\n template <>\n inline const string* const* TensorProtoData<tstring>(const TensorProto& t) {\n   static_assert(SaveTypeTraits<tstring>::supported,"
        },
        {
          "filename": "tensorflow/core/util/tensor_slice_reader.h",
          "status": "modified",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -181,6 +181,22 @@ bool TensorSliceReader::CopySliceData(const string& name,\n               << slice_s.DebugString() << \": computed key = \" << key;\n       return false;\n     }\n+    // Ensure the TensorSlice contains the expected amount of data.\n+    TensorShape shp_s;\n+    Status s = slice_s.SliceTensorShape(tss->shape(), &shp_s);\n+    if (!s.ok()) {\n+      VLOG(1) << \"Failed to slice tensor \" << name << \", slice \"\n+              << slice_s.DebugString() << \": \" << s;\n+      return false;\n+    }\n+    if (checkpoint::TensorProtoDataSize<T>(sts.data().data()) !=\n+        shp_s.num_elements()) {\n+      VLOG(1) << \"Tensor \" << name << \", slice \" << slice_s.DebugString()\n+              << \" had an unexpected amount of data: expected = \"\n+              << shp_s.num_elements() << \", got = \"\n+              << checkpoint::TensorProtoDataSize<T>(sts.data().data());\n+      return false;\n+    }\n     CopyDataFromTensorSliceToTensorSlice(\n         tss->shape(), slice_s, slice,\n         checkpoint::TensorProtoData<T>(sts.data().data()), data);"
        },
        {
          "filename": "tensorflow/core/util/tensor_slice_reader_test.cc",
          "status": "modified",
          "additions": 27,
          "deletions": 0,
          "patch": "@@ -459,6 +459,33 @@ TEST(TensorSliceReaderTest, InvalidTensorSlice) {\n   EXPECT_FALSE(reader.status().ok());\n }\n \n+TEST(TensorSliceReaderTest, MissingTensorData) {\n+  const string fname =\n+      io::JoinPath(testing::TmpDir(), \"missing_data_checkpoint\");\n+  TensorSliceWriter writer(fname, CreateTableTensorSliceBuilder);\n+  const int32 data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n+  TF_ASSERT_OK(writer.Add(\"test\", TensorShape({4, 5}),\n+                          TensorSlice::ParseOrDie(\"0,2:-\"), data));\n+  TF_ASSERT_OK(writer.Finish());\n+\n+  MutateSavedTensorSlices(fname, [&](SavedTensorSlices sts) {\n+    if (sts.has_data()) {\n+      // Replace the data with only 4 elements.\n+      Fill(data, 4, sts.mutable_data()->mutable_data());\n+    }\n+    return sts.SerializeAsString();\n+  });\n+\n+  TensorSliceReader reader(fname, OpenTableTensorSliceReader);\n+  TF_ASSERT_OK(reader.status());\n+\n+  // The tensor should be present, but loading it should fail due to the missing\n+  // data.\n+  EXPECT_TRUE(reader.HasTensor(\"test\", nullptr, nullptr));\n+  std::unique_ptr<Tensor> tensor;\n+  EXPECT_FALSE(reader.GetTensor(\"test\", &tensor).ok());\n+}\n+\n void CachedTensorSliceReaderTesterHelper(\n     const TensorSliceWriter::CreateBuilderFunction& create_function,\n     const TensorSliceReader::OpenTableFunction& open_function) {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "df078d626d561e6ae8f34d4702cbead44a3cbf82",
            "date": "2025-01-14T19:36:18Z",
            "author_login": "tensorflower-gardener"
          },
          {
            "sha": "2a6c919b732bc36a8aa444c03c455a5ba7376ad5",
            "date": "2025-01-14T19:00:47Z",
            "author_login": "sdasgup3"
          },
          {
            "sha": "ea89878e945fdb95ec85b5d396d45b70a42d268e",
            "date": "2025-01-14T19:00:19Z",
            "author_login": "eunjaekim-0"
          },
          {
            "sha": "2ed056484b967486920cc8be1740ab1bd13c9f64",
            "date": "2025-01-14T18:40:26Z",
            "author_login": "GleasonK"
          },
          {
            "sha": "f04ac71a7ba0972752968c52b299e9e53795c9bf",
            "date": "2025-01-14T18:36:27Z",
            "author_login": "tensorflower-gardener"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.8,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-345",
    "description": "TensorFlow is an open source platform for machine learning. In affected versions an attacker can trigger undefined behavior, integer overflows, segfaults and `CHECK`-fail crashes if they can change saved checkpoints from outside of TensorFlow. This is because the checkpoints loading infrastructure is missing validation for invalid file formats. The fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-11-05T21:15:08.613",
    "last_modified": "2024-11-21T06:25:45.840",
    "fix_date": "2021-08-25T20:45:01Z"
  },
  "references": [
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/368af875869a204b4ac552b9ddda59f6a46a56ec",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/abcced051cb1bd8fb05046ac3b6023a7ebcc4578",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/b619c6f865715ca3b15ef1842b5b95edbaa710ad",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/e8dc63704c88007ee4713076605c90188d66f3d2",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-7pxj-m4jf-r6h2",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/368af875869a204b4ac552b9ddda59f6a46a56ec",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/abcced051cb1bd8fb05046ac3b6023a7ebcc4578",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/b619c6f865715ca3b15ef1842b5b95edbaa710ad",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/e8dc63704c88007ee4713076605c90188d66f3d2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-7pxj-m4jf-r6h2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:31.875236",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "tensorflow",
    "owner": "tensorflow",
    "created_at": "2015-11-07T01:19:20Z",
    "updated_at": "2025-01-14T12:53:26Z",
    "pushed_at": "2025-01-14T12:53:14Z",
    "size": 1120707,
    "stars": 187254,
    "forks": 74432,
    "open_issues": 6569,
    "watchers": 187254,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 101199988,
      "Python": 45779571,
      "MLIR": 10763008,
      "HTML": 7662661,
      "Starlark": 7430486,
      "Go": 2171370,
      "C": 1288066,
      "Java": 1178817,
      "Jupyter Notebook": 805736,
      "Shell": 701425,
      "Objective-C++": 279654,
      "Objective-C": 169202,
      "CMake": 148610,
      "Smarty": 121630,
      "Swift": 81659,
      "Dockerfile": 37903,
      "C#": 13585,
      "Batchfile": 12126,
      "Ruby": 8898,
      "Perl": 7536,
      "Roff": 5034,
      "Cython": 3899,
      "Makefile": 2845,
      "CSS": 2761,
      "Vim Snippet": 58
    },
    "commit_activity": {
      "total_commits_last_year": 15729,
      "avg_commits_per_week": 302.4807692307692,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:54:01.412891"
  }
}