{
  "cve_id": "CVE-2021-41213",
  "github_data": {
    "repository": "tensorflow/tensorflow",
    "fix_commit": "afac8158d43691661ad083f6dd9e56f327c1dcb7",
    "related_commits": [
      "afac8158d43691661ad083f6dd9e56f327c1dcb7",
      "afac8158d43691661ad083f6dd9e56f327c1dcb7"
    ],
    "patch_url": "https://github.com/tensorflow/tensorflow/commit/afac8158d43691661ad083f6dd9e56f327c1dcb7.patch",
    "fix_commit_details": {
      "sha": "afac8158d43691661ad083f6dd9e56f327c1dcb7",
      "commit_date": "2021-10-06T17:38:26Z",
      "author": {
        "login": "JXRiver",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix the deadlock issue of recursive tf.function.",
        "length": 208,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 119,
        "additions": 116,
        "deletions": 3
      },
      "files": [
        {
          "filename": "tensorflow/python/eager/def_function.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -572,7 +572,7 @@ def __init__(self,\n       ValueError: if `input_signature` is not None and the `python_function`'s\n         argspec has keyword arguments.\n     \"\"\"\n-    self._lock = threading.Lock()\n+    self._lock = threading.RLock()\n     self._python_function = python_function\n     self._function_spec = function_lib.FunctionSpec.from_function_and_signature(\n         python_function,\n@@ -613,7 +613,7 @@ def __getstate__(self):\n   def __setstate__(self, state):\n     \"\"\"Restore from pickled state.\"\"\"\n     self.__dict__ = state\n-    self._lock = threading.Lock()\n+    self._lock = threading.RLock()\n     self._descriptor_cache = weakref.WeakKeyDictionary()\n     self._key_for_call_stats = self._get_key_for_call_stats()\n "
        },
        {
          "filename": "tensorflow/python/eager/def_function_test.py",
          "status": "modified",
          "additions": 113,
          "deletions": 0,
          "patch": "@@ -25,6 +25,7 @@\n from six.moves import range\n \n from tensorflow.python.autograph.core import converter\n+from tensorflow.python.eager import backprop\n from tensorflow.python.eager import def_function\n from tensorflow.python.eager import lift_to_graph\n from tensorflow.python.framework import constant_op\n@@ -36,6 +37,7 @@\n from tensorflow.python.framework import test_util\n from tensorflow.python.module import module\n from tensorflow.python.ops import array_ops\n+from tensorflow.python.ops import cond_v2\n from tensorflow.python.ops import control_flow_ops\n from tensorflow.python.ops import math_ops\n from tensorflow.python.ops import random_ops\n@@ -1261,6 +1263,117 @@ def testDouble(self, a):\n     self.assertAllEqual(obj2.testDouble.experimental_get_tracing_count(), 3)\n     self.assertAllEqual(obj1.testDouble.experimental_get_tracing_count(), 2)\n \n+  def test_recursive_tf_function(self):\n+\n+    @def_function.function\n+    def recursive_fn(n):\n+      if n > 0:\n+        return recursive_fn(n - 1)\n+      return 1\n+\n+    self.assertEqual(recursive_fn(5).numpy(), 1)\n+\n+  def test_recursive_tf_function_with_gradients(self):\n+\n+    @def_function.function\n+    def recursive_fn(n, x):\n+      if n > 0:\n+        return n * recursive_fn(n - 1, x)\n+      else:\n+        return x\n+\n+    x = variables.Variable(1.0)\n+    with backprop.GradientTape() as tape:\n+      g = recursive_fn(5, x)\n+\n+    dg_dx = tape.gradient(g, x)\n+    self.assertEqual(dg_dx.numpy(), 120)\n+\n+  def test_recursive_python_function(self):\n+\n+    def recursive_py_fn(n):\n+      if n > 0:\n+        return recursive_py_fn(n - 1)\n+      return 1\n+\n+    @def_function.function\n+    def recursive_fn(n):\n+      return recursive_py_fn(n)\n+\n+    self.assertEqual(recursive_fn(5).numpy(), 1)\n+\n+  def test_recursive_python_function_with_gradients(self):\n+\n+    def recursive_py_fn(n, x):\n+      if n > 0:\n+        return n * recursive_py_fn(n - 1, x)\n+      return x\n+\n+    @def_function.function\n+    def recursive_fn(n, x):\n+      return recursive_py_fn(n, x)\n+\n+    x = variables.Variable(1.0)\n+    with backprop.GradientTape() as tape:\n+      g = recursive_fn(5, x)\n+\n+    dg_dx = tape.gradient(g, x)\n+    self.assertEqual(dg_dx.numpy(), 120)\n+\n+  def test_recursive_tf_function_call_each_other(self):\n+\n+    @def_function.function\n+    def recursive_fn1(n):\n+      if n <= 1:\n+        return 1\n+      return recursive_fn2(n - 1)\n+\n+    @def_function.function\n+    def recursive_fn2(n):\n+      if n <= 1:\n+        return 2\n+      return recursive_fn1(n - 1)\n+\n+    self.assertEqual(recursive_fn1(5).numpy(), 1)\n+    self.assertEqual(recursive_fn1(6).numpy(), 2)\n+    self.assertEqual(recursive_fn2(5).numpy(), 2)\n+    self.assertEqual(recursive_fn2(6).numpy(), 1)\n+\n+  def test_recursive_tf_function_call_each_other_with_gradients(self):\n+\n+    @def_function.function\n+    def recursive_fn1(n, x):\n+      if n <= 1:\n+        return x\n+      return n * recursive_fn2(n - 1, x)\n+\n+    @def_function.function\n+    def recursive_fn2(n, x):\n+      if n <= 1:\n+        return 2 * x\n+      return n * recursive_fn1(n - 1, x)\n+\n+    x = variables.Variable(1.0)\n+    with backprop.GradientTape() as tape:\n+      g1 = recursive_fn1(5, x)\n+\n+    dg1_dx = tape.gradient(g1, x)\n+    self.assertEqual(dg1_dx.numpy(), 120)\n+\n+    with backprop.GradientTape() as tape:\n+      g2 = recursive_fn2(5, x)\n+\n+    dg2_dx = tape.gradient(g2, x)\n+    self.assertEqual(dg2_dx.numpy(), 240)\n+\n+  def test_recursive_tf_function_with_cond(self):\n+    @def_function.function(autograph=False)\n+    def recursive_fn(n):\n+      return cond_v2.cond_v2(n > 0, recursive_fn(n - 1), 1)\n+\n+    with self.assertRaises(RecursionError):\n+      recursive_fn(constant_op.constant(5))\n+\n \n if __name__ == '__main__':\n   ops.enable_eager_execution()"
        },
        {
          "filename": "tensorflow/python/eager/function.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -3037,7 +3037,7 @@ def __init__(self,\n     if self.input_signature is not None:\n       self._hashable_input_signature = hash(self.flat_input_signature)\n \n-    self._lock = threading.Lock()\n+    self._lock = threading.RLock()\n     # _descriptor_cache is a of instance of a class to an instance-specific\n     # `Function`, used to make sure defun-decorated methods create different\n     # functions for each instance."
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d93cc4f4f767f0d4a72f2fafcc59005be939c019",
            "date": "2025-01-14T20:36:32Z",
            "author_login": "sdasgup3"
          },
          {
            "sha": "d4e4516cc7d11a68a81a82227f3a432f7ab350a0",
            "date": "2025-01-14T19:59:15Z",
            "author_login": "ddunl"
          },
          {
            "sha": "65367823d999b6a36a685617100a7bb6ce03add4",
            "date": "2025-01-14T19:58:00Z",
            "author_login": "sdasgup3"
          },
          {
            "sha": "36cbae5466dbf356d91cf56127b2ab2ccd5a8b1f",
            "date": "2025-01-14T19:54:19Z",
            "author_login": "penpornk"
          },
          {
            "sha": "0a99598a8f76735ac32b5466385b0f5af08a06bb",
            "date": "2025-01-14T19:45:23Z",
            "author_login": "wangpengmit"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-667",
    "description": "TensorFlow is an open source platform for machine learning. In affected versions the code behind `tf.function` API can be made to deadlock when two `tf.function` decorated Python functions are mutually recursive. This occurs due to using a non-reentrant `Lock` Python object. Loading any model which contains mutually recursive functions is vulnerable. An attacker can cause denial of service by causing users to load such models and calling a recursive `tf.function`, although this is not a frequent scenario. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-11-05T23:15:08.217",
    "last_modified": "2024-11-21T06:25:47.550",
    "fix_date": "2021-10-06T17:38:26Z"
  },
  "references": [
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/afac8158d43691661ad083f6dd9e56f327c1dcb7",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-h67m-xg8f-fxcf",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/afac8158d43691661ad083f6dd9e56f327c1dcb7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-h67m-xg8f-fxcf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:31.878141",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "tensorflow",
    "owner": "tensorflow",
    "created_at": "2015-11-07T01:19:20Z",
    "updated_at": "2025-01-14T12:53:26Z",
    "pushed_at": "2025-01-14T12:53:14Z",
    "size": 1120707,
    "stars": 187254,
    "forks": 74432,
    "open_issues": 6569,
    "watchers": 187254,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 101199988,
      "Python": 45779571,
      "MLIR": 10763008,
      "HTML": 7662661,
      "Starlark": 7430486,
      "Go": 2171370,
      "C": 1288066,
      "Java": 1178817,
      "Jupyter Notebook": 805736,
      "Shell": 701425,
      "Objective-C++": 279654,
      "Objective-C": 169202,
      "CMake": 148610,
      "Smarty": 121630,
      "Swift": 81659,
      "Dockerfile": 37903,
      "C#": 13585,
      "Batchfile": 12126,
      "Ruby": 8898,
      "Perl": 7536,
      "Roff": 5034,
      "Cython": 3899,
      "Makefile": 2845,
      "CSS": 2761,
      "Vim Snippet": 58
    },
    "commit_activity": {
      "total_commits_last_year": 15729,
      "avg_commits_per_week": 302.4807692307692,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:54:01.412891"
  }
}