{
  "cve_id": "CVE-2021-41246",
  "github_data": {
    "repository": "auth0/express-openid-connect",
    "fix_commit": "5ab67ff2bd84f76674066b5e129b43ab5f2f430f",
    "related_commits": [
      "5ab67ff2bd84f76674066b5e129b43ab5f2f430f",
      "5ab67ff2bd84f76674066b5e129b43ab5f2f430f"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "5ab67ff2bd84f76674066b5e129b43ab5f2f430f",
      "commit_date": "2021-12-09T09:10:57Z",
      "author": {
        "login": "AudreyBudryte2",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-7rg2-qxmf-hhx9",
        "length": 59,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 258,
        "additions": 242,
        "deletions": 16
      },
      "files": [
        {
          "filename": "lib/appSession.js",
          "status": "modified",
          "additions": 38,
          "deletions": 12,
          "patch": "@@ -15,14 +15,17 @@ const debug = require('./debug')('appSession');\n const epoch = () => (Date.now() / 1000) | 0;\n const MAX_COOKIE_SIZE = 4096;\n \n+const REASSIGN = Symbol('reassign');\n+const REGENERATED_SESSION_ID = Symbol('regenerated_session_id');\n+\n function attachSessionObject(req, sessionName, value) {\n   Object.defineProperty(req, sessionName, {\n     enumerable: true,\n     get() {\n       return value;\n     },\n     set(arg) {\n-      if (arg === null || arg === undefined) {\n+      if (arg === null || arg === undefined || arg[REASSIGN]) {\n         value = arg;\n       } else {\n         throw new TypeError('session object cannot be reassigned');\n@@ -32,6 +35,17 @@ function attachSessionObject(req, sessionName, value) {\n   });\n }\n \n+function regenerateSessionStoreId(req, config) {\n+  if (config.session.store) {\n+    req[REGENERATED_SESSION_ID] = config.session.genid(req);\n+  }\n+}\n+\n+function replaceSession(req, session, config) {\n+  session[REASSIGN] = true;\n+  req[config.session.name] = session;\n+}\n+\n module.exports = (config) => {\n   let current;\n \n@@ -175,7 +189,7 @@ module.exports = (config) => {\n       };\n     }\n \n-    setCookie(id, req, res, iat) {\n+    setCookie(req, res, iat) {\n       setCookie(req, res, iat);\n     }\n   }\n@@ -197,12 +211,14 @@ module.exports = (config) => {\n       res,\n       { uat = epoch(), iat = uat, exp = calculateExp(iat, uat) }\n     ) {\n-      if (!req[sessionName] || !Object.keys(req[sessionName]).length) {\n-        if (req[COOKIES][sessionName]) {\n-          await this._destroy(id);\n-        }\n-      } else {\n-        await this._set(id, {\n+      const hasPrevSession = !!req[COOKIES][sessionName];\n+      const replacingPrevSession = !!req[REGENERATED_SESSION_ID];\n+      const hasCurrentSession = req[sessionName] && Object.keys(req[sessionName]).length;\n+      if (hasPrevSession && (replacingPrevSession || !hasCurrentSession)) {\n+        await this._destroy(id);\n+      }\n+      if (hasCurrentSession) {\n+        await this._set(req[REGENERATED_SESSION_ID] || id, {\n           header: { iat, uat, exp },\n           data: req[sessionName],\n         });\n@@ -233,7 +249,8 @@ module.exports = (config) => {\n     }\n   }\n \n-  const store = config.session.store\n+  const isCustomStore = !!config.session.store;\n+  const store = isCustomStore\n     ? new CustomStore(config.session.store)\n     : new CookieStore();\n \n@@ -330,11 +347,13 @@ module.exports = (config) => {\n       attachSessionObject(req, sessionName, {});\n     }\n \n-    const id = existingSessionValue || generateId(req);\n+    if (isCustomStore) {\n+      const id = existingSessionValue || generateId(req);\n \n-    onHeaders(res, () => store.setCookie(id, req, res, { iat }));\n+      onHeaders(res, () =>\n+        store.setCookie(req[REGENERATED_SESSION_ID] || id, req, res, { iat })\n+      );\n \n-    if (store.set) {\n       const { end: origEnd } = res;\n       res.end = async function resEnd(...args) {\n         try {\n@@ -349,8 +368,15 @@ module.exports = (config) => {\n           process.nextTick(() => next(e));\n         }\n       };\n+    } else {\n+      onHeaders(res, () =>\n+        store.setCookie(req, res, { iat })\n+      );\n     }\n \n     return next();\n   };\n };\n+\n+module.exports.regenerateSessionStoreId = regenerateSessionStoreId;\n+module.exports.replaceSession = replaceSession;"
        },
        {
          "filename": "middleware/auth.js",
          "status": "modified",
          "additions": 24,
          "deletions": 4,
          "patch": "@@ -10,6 +10,7 @@ const attemptSilentLogin = require('./attemptSilentLogin');\n const TransientCookieHandler = require('../lib/transientHandler');\n const { RequestContext, ResponseContext } = require('../lib/context');\n const appSession = require('../lib/appSession');\n+const { regenerateSessionStoreId, replaceSession } = appSession;\n const { decodeState } = require('../lib/hooks/getLoginState');\n \n const enforceLeadingSlash = (path) => {\n@@ -83,7 +84,7 @@ const auth = function (params) {\n         try {\n           const redirectUri = res.oidc.getRedirectUri();\n \n-          let session;\n+          let tokenSet;\n \n           try {\n             const callbackParams = client.callbackParams(req);\n@@ -110,7 +111,7 @@ const auth = function (params) {\n               extras = { exchangeBody: config.tokenEndpointParams };\n             }\n \n-            session = await client.callback(\n+            tokenSet = await client.callback(\n               redirectUri,\n               callbackParams,\n               checks,\n@@ -120,16 +121,35 @@ const auth = function (params) {\n             throw createError.BadRequest(err.message);\n           }\n \n+          let session = Object.assign({}, tokenSet); // Remove non-enumerable methods from the TokenSet\n+\n           if (config.afterCallback) {\n             session = await config.afterCallback(\n               req,\n               res,\n-              Object.assign({}, session), // Remove non-enumerable methods from the TokenSet\n+              session,\n               req.openidState\n             );\n           }\n \n-          Object.assign(req[config.session.name], session);\n+          if (req.oidc.isAuthenticated()) {\n+            if (req.oidc.user.sub === tokenSet.claims().sub) {\n+              // If it's the same user logging in again, just update the existing session.\n+              Object.assign(req[config.session.name], session);\n+            } else {\n+              // If it's a different user, replace the session to remove any custom user\n+              // properties on the session\n+              replaceSession(req, session, config);\n+              // And regenerate the session id so the previous user wont know the new user's session id\n+              regenerateSessionStoreId(req, config);\n+            }\n+          } else {\n+            // If a new user is replacing an anonymous session, update the existing session to keep\n+            // any anonymous session state (eg. checkout basket)\n+            Object.assign(req[config.session.name], session);\n+            // But update the session store id so a previous anonymous user wont know the new user's session id\n+            regenerateSessionStoreId(req, config);\n+          }\n           attemptSilentLogin.resumeSilentLogin(req, res);\n \n           next();"
        },
        {
          "filename": "test/appSession.customStore.tests.js",
          "status": "modified",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -57,6 +57,7 @@ describe('appSession custom store', () => {\n     const store = new RedisStore({ client: redisClient, prefix: '' });\n     redisClient.asyncSet = promisify(redisClient.set).bind(redisClient);\n     redisClient.asyncGet = promisify(redisClient.get).bind(redisClient);\n+    redisClient.asyncDbsize = promisify(redisClient.dbsize).bind(redisClient);\n \n     const conf = getConfig({\n       ...defaultConfig,\n@@ -72,6 +73,7 @@ describe('appSession custom store', () => {\n       await new Promise((resolve) => server.close(resolve));\n     }\n     if (redisClient) {\n+      await new Promise((resolve) => redisClient.flushall(resolve));\n       await new Promise((resolve) => redisClient.quit(resolve));\n     }\n   });\n@@ -116,6 +118,15 @@ describe('appSession custom store', () => {\n     });\n   });\n \n+  it('should not populate the store when there is no session', async () => {\n+    await setup();\n+    await request.get('/session', {\n+      baseUrl,\n+      json: true,\n+    });\n+    assert.equal(await redisClient.asyncDbsize(), 0);\n+  });\n+\n   it('should get a new session', async () => {\n     await setup();\n     const jar = await login({ sub: '__foo_user__' });\n@@ -126,6 +137,7 @@ describe('appSession custom store', () => {\n     });\n     assert.equal(res.statusCode, 200);\n     assert.deepEqual(res.body, { sub: '__foo_user__' });\n+    assert.equal(await redisClient.asyncDbsize(), 1);\n   });\n \n   it('should destroy an existing session', async () => {\n@@ -153,6 +165,7 @@ describe('appSession custom store', () => {\n     });\n     assert.isEmpty(loggedOutRes.body);\n     assert.isEmpty(jar.getCookies(baseUrl));\n+    assert.equal(await redisClient.asyncDbsize(), 0);\n   });\n \n   it('uses custom session id generator when provided', async () => {\n@@ -178,6 +191,7 @@ describe('appSession custom store', () => {\n       role: 'test',\n       userid: immId,\n     });\n+    assert.equal(await redisClient.asyncDbsize(), 1);\n   });\n \n   it('should handle storage errors', async () => {"
        },
        {
          "filename": "test/callback.tests.js",
          "status": "modified",
          "additions": 166,
          "deletions": 0,
          "patch": "@@ -14,6 +14,7 @@ const { makeIdToken } = require('./fixture/cert');\n const clientID = '__test_client_id__';\n const expectedDefaultState = encodeState({ returnTo: 'https://example.org' });\n const nock = require('nock');\n+const MemoryStore = require('memorystore')(auth);\n \n const baseUrl = 'http://localhost:3000';\n const defaultConfig = {\n@@ -77,6 +78,17 @@ const setup = async (params) => {\n       };\n     });\n \n+  let existingSessionCookie;\n+  if (params.existingSession) {\n+    await request.post('/session', {\n+      baseUrl,\n+      jar,\n+      json: params.existingSession,\n+    });\n+    const cookies = jar.getCookies(baseUrl);\n+    existingSessionCookie = cookies.find(({ key }) => key === 'appSession');\n+  }\n+\n   const response = await request.post('/callback', {\n     baseUrl,\n     jar,\n@@ -85,6 +97,9 @@ const setup = async (params) => {\n   const currentUser = await request\n     .get('/user', { baseUrl, jar, json: true })\n     .then((r) => r.body);\n+  const currentSession = await request\n+    .get('/session', { baseUrl, jar, json: true })\n+    .then((r) => r.body);\n   const tokens = await request\n     .get('/tokens', { baseUrl, jar, json: true })\n     .then((r) => r.body);\n@@ -96,9 +111,11 @@ const setup = async (params) => {\n     jar,\n     response,\n     currentUser,\n+    currentSession,\n     tokenReqHeader,\n     tokenReqBody,\n     tokens,\n+    existingSessionCookie,\n   };\n };\n \n@@ -887,4 +904,153 @@ describe('callback response_mode: form_post', () => {\n       assert.equal(statusCode, 999);\n     });\n   });\n+\n+  it('should replace the cookie session when a new user is logging in over an existing different user', async () => {\n+    const { currentSession, currentUser } = await setup({\n+      cookies: generateCookies({\n+        state: expectedDefaultState,\n+        nonce: '__test_nonce__',\n+      }),\n+      body: {\n+        state: expectedDefaultState,\n+        id_token: makeIdToken({ sub: 'bar' }),\n+      },\n+      existingSession: {\n+        shoppingCartId: 'bar',\n+        id_token: makeIdToken({ sub: 'foo' }),\n+      },\n+    });\n+\n+    assert.equal(currentUser.sub, 'bar');\n+    assert.isUndefined(currentSession.shoppingCartId);\n+  });\n+\n+  it('should preserve the cookie session when a new user is logging in over an anonymous session', async () => {\n+    const { currentSession, currentUser } = await setup({\n+      cookies: generateCookies({\n+        state: expectedDefaultState,\n+        nonce: '__test_nonce__',\n+      }),\n+      body: {\n+        state: expectedDefaultState,\n+        id_token: makeIdToken({ sub: 'foo' }),\n+      },\n+      existingSession: {\n+        shoppingCartId: 'bar',\n+      },\n+    });\n+\n+    assert.equal(currentUser.sub, 'foo');\n+    assert.equal(currentSession.shoppingCartId, 'bar');\n+  });\n+\n+  it('should preserve session but regenerate session id when a new user is logging in over an anonymous session', async () => {\n+    const store = new MemoryStore({\n+      checkPeriod: 24 * 60 * 1000,\n+    });\n+    const { currentSession, currentUser, existingSessionCookie, jar } = await setup({\n+      cookies: generateCookies({\n+        state: expectedDefaultState,\n+        nonce: '__test_nonce__',\n+      }),\n+      body: {\n+        state: expectedDefaultState,\n+        id_token: makeIdToken({ sub: 'foo' }),\n+      },\n+      existingSession: {\n+        shoppingCartId: 'bar',\n+      },\n+      authOpts: {\n+        session: {\n+          store,\n+        },\n+      },\n+    });\n+\n+    const cookies = jar.getCookies(baseUrl);\n+    const newSessionCookie = cookies.find(({ key }) => key === 'appSession');\n+    \n+    assert.equal(currentUser.sub, 'foo');\n+    assert.equal(currentSession.shoppingCartId, 'bar');\n+    assert.equal(\n+      store.store.length,\n+      1,\n+      'There should only be one session in the store'\n+    );\n+    assert.notEqual(existingSessionCookie.value, newSessionCookie.value);\n+  });\n+\n+  it('should preserve session when the same user is logging in over their existing session', async () => {\n+    const store = new MemoryStore({\n+      checkPeriod: 24 * 60 * 1000,\n+    });\n+    const { currentSession, currentUser, existingSessionCookie, jar } = await setup({\n+      cookies: generateCookies({\n+        state: expectedDefaultState,\n+        nonce: '__test_nonce__',\n+      }),\n+      body: {\n+        state: expectedDefaultState,\n+        id_token: makeIdToken({ sub: 'foo' }),\n+      },\n+      existingSession: {\n+        shoppingCartId: 'bar',\n+        id_token: makeIdToken({ sub: 'foo' }),\n+      },\n+      authOpts: {\n+        session: {\n+          store,\n+        },\n+      },\n+    });\n+\n+    const cookies = jar.getCookies(baseUrl);\n+    const newSessionCookie = cookies.find(({ key }) => key === 'appSession');\n+    \n+    assert.equal(currentUser.sub, 'foo');\n+    assert.equal(currentSession.shoppingCartId, 'bar');\n+    assert.equal(\n+      store.store.length,\n+      1,\n+      'There should only be one session in the store'\n+    );\n+    assert.equal(existingSessionCookie.value, newSessionCookie.value);\n+  });\n+\n+  it('should regenerate the session when a new user is logging in over an existing different user', async () => {\n+    const store = new MemoryStore({\n+      checkPeriod: 24 * 60 * 1000,\n+    });\n+    const { currentSession, currentUser, existingSessionCookie, jar } = await setup({\n+      cookies: generateCookies({\n+        state: expectedDefaultState,\n+        nonce: '__test_nonce__',\n+      }),\n+      body: {\n+        state: expectedDefaultState,\n+        id_token: makeIdToken({ sub: 'bar' }),\n+      },\n+      existingSession: {\n+        shoppingCartId: 'bar',\n+        id_token: makeIdToken({ sub: 'foo' }),\n+      },\n+      authOpts: {\n+        session: {\n+          store,\n+        },\n+      },\n+    });\n+\n+    const cookies = jar.getCookies(baseUrl);\n+    const newSessionCookie = cookies.find(({ key }) => key === 'appSession');\n+    \n+    assert.equal(currentUser.sub, 'bar');\n+    assert.isUndefined(currentSession.shoppingCartId);\n+    assert.equal(\n+      store.store.length,\n+      1,\n+      'There should only be one session in the store'\n+    );\n+    assert.notEqual(existingSessionCookie.value, newSessionCookie.value);\n+  });\n });"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 3,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7dbc3b48aff13b6eb93a32306d40b0de2e802a8d",
            "date": "2024-10-31T11:33:13Z",
            "author_login": "tusharpandey13"
          },
          {
            "sha": "5a58ffcd188db4799730604c062dc921786bb325",
            "date": "2024-10-09T06:57:56Z",
            "author_login": "arpit-jn"
          },
          {
            "sha": "47bf341668141f174b214f6fd0ef20f2f5d50ee6",
            "date": "2024-10-04T07:48:26Z",
            "author_login": "arpit-jn"
          },
          {
            "sha": "e9993181114d3b1e6f6e3311f48eae3458ca41c5",
            "date": "2024-08-05T10:14:05Z",
            "author_login": "arpit-jn"
          },
          {
            "sha": "6d3ae3de34c3b9423b8ecaab8039bd0b8f9d2bae",
            "date": "2024-07-25T14:25:10Z",
            "author_login": "stevenwong-okta"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:N",
    "cwe_id": "CWE-384",
    "description": "Express OpenID Connect is express JS middleware implementing sign on for Express web apps using OpenID Connect. Versions before and including `2.5.1` do not regenerate the session id and session cookie when user logs in. This behavior opens up the application to various session fixation vulnerabilities. Versions `2.5.2` contains a patch for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-12-09T16:15:08.383",
    "last_modified": "2024-11-21T06:25:52.357",
    "fix_date": "2021-12-09T09:10:57Z"
  },
  "references": [
    {
      "url": "https://github.com/auth0/express-openid-connect/commit/5ab67ff2bd84f76674066b5e129b43ab5f2f430f",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/auth0/express-openid-connect/releases/tag/v2.5.2",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/auth0/express-openid-connect/security/advisories/GHSA-7rg2-qxmf-hhx9",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/auth0/express-openid-connect/commit/5ab67ff2bd84f76674066b5e129b43ab5f2f430f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/auth0/express-openid-connect/releases/tag/v2.5.2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/auth0/express-openid-connect/security/advisories/GHSA-7rg2-qxmf-hhx9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:34.828376",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "express-openid-connect",
    "owner": "auth0",
    "created_at": "2018-11-08T22:02:14Z",
    "updated_at": "2025-01-15T12:57:57Z",
    "pushed_at": "2025-01-02T12:58:46Z",
    "size": 2754,
    "stars": 478,
    "forks": 143,
    "open_issues": 27,
    "watchers": 478,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "JavaScript": 257858,
      "TypeScript": 341
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T08:23:28.323130"
  }
}