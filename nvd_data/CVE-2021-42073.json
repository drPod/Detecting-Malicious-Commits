{
  "cve_id": "CVE-2021-42073",
  "github_data": {
    "repository": "debauchee/barrier",
    "fix_commit": "229abab99f39f11624e5651f819e7f1f8eddedcc",
    "related_commits": [
      "229abab99f39f11624e5651f819e7f1f8eddedcc",
      "b5adc93e2bd74cb094f91ff595c07f321a489f3e",
      "229abab99f39f11624e5651f819e7f1f8eddedcc",
      "b5adc93e2bd74cb094f91ff595c07f321a489f3e"
    ],
    "patch_url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc.patch",
    "fix_commit_details": {
      "sha": "229abab99f39f11624e5651f819e7f1f8eddedcc",
      "commit_date": "2021-11-01T02:50:15Z",
      "author": {
        "login": "p12tic",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Implement client identity verification",
        "length": 195,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 111,
        "additions": 96,
        "deletions": 15
      },
      "files": [
        {
          "filename": "doc/newsfragments/client-certificate-checking.bugfix",
          "status": "added",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -0,0 +1,7 @@\n+SECURITY ISSUE\n+\n+Barrier now supports client identity verification (fixes CVE-2021-42072, CVE-2021-42073).\n+\n+To support seamless upgrades from older versions of Barrier this is currently disabled by default.\n+The feature can be enabled in the settings dialog. If enabled, older clients of Barrier will be\n+rejected."
        },
        {
          "filename": "src/gui/src/MainWindow.cpp",
          "status": "modified",
          "additions": 43,
          "deletions": 11,
          "patch": "@@ -427,7 +427,7 @@ void MainWindow::checkConnected(const QString& line)\n \n void MainWindow::checkFingerprint(const QString& line)\n {\n-    QRegExp fingerprintRegex(\".*server fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");\n+    QRegExp fingerprintRegex(\".*peer fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");\n     if (!fingerprintRegex.exactMatch(line)) {\n         return;\n     }\n@@ -442,7 +442,11 @@ void MainWindow::checkFingerprint(const QString& line)\n         barrier::string::from_hex(fingerprintRegex.cap(2).toStdString())\n     };\n \n-    auto db_path = barrier::DataDirectories::trusted_servers_ssl_fingerprints_path();\n+    bool is_client = barrierType() == barrierClient;\n+\n+    auto db_path = is_client\n+            ? barrier::DataDirectories::trusted_servers_ssl_fingerprints_path()\n+            : barrier::DataDirectories::trusted_clients_ssl_fingerprints_path();\n \n     auto db_dir = db_path.parent_path();\n     if (!barrier::fs::exists(db_dir)) {\n@@ -461,17 +465,17 @@ void MainWindow::checkFingerprint(const QString& line)\n     static bool messageBoxAlreadyShown = false;\n \n     if (!messageBoxAlreadyShown) {\n-        stopBarrier();\n+        if (is_client) {\n+            stopBarrier();\n+        }\n \n-        messageBoxAlreadyShown = true;\n-        QMessageBox::StandardButton fingerprintReply =\n-            QMessageBox::information(\n-            this, tr(\"Security question\"),\n-            tr(\"Do you trust this fingerprint?\\n\\n\"\n+        QString message;\n+        if (is_client) {\n+            message = tr(\"Do you trust this fingerprint?\\n\\n\"\n                \"SHA256:\\n\"\n                \"%1\\n\"\n                \"%2\\n\\n\"\n-               \"SHA1 (obsolete, when using old Barrier server):\\n\"\n+               \"SHA1 (obsolete, when using old Barrier client):\\n\"\n                \"%3\\n\\n\"\n                \"This is a server fingerprint. You should compare this \"\n                \"fingerprint to the one on your server's screen. If the \"\n@@ -483,14 +487,38 @@ void MainWindow::checkFingerprint(const QString& line)\n             .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n             .arg(QString::fromStdString(\n                      barrier::create_fingerprint_randomart(fingerprint_sha256.data)))\n-            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data))),\n+            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data)));\n+        } else {\n+            message = tr(\"Do you trust this fingerprint?\\n\\n\"\n+               \"SHA256:\\n\"\n+               \"%1\\n\"\n+               \"%2\\n\\n\"\n+               \"This is a client fingerprint. You should compare this \"\n+               \"fingerprint to the one on your client's screen. If the \"\n+               \"two don't match exactly, then it's probably not the client \"\n+               \"you're expecting (it could be a malicious user).\\n\\n\"\n+               \"To automatically trust this fingerprint for future \"\n+               \"connections, click Yes. To reject this fingerprint and \"\n+               \"disconnect the client, click No.\")\n+            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n+            .arg(QString::fromStdString(\n+                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)));\n+        }\n+\n+        messageBoxAlreadyShown = true;\n+        QMessageBox::StandardButton fingerprintReply =\n+            QMessageBox::information(\n+            this, tr(\"Security question\"),\n+            message,\n             QMessageBox::Yes | QMessageBox::No);\n \n         if (fingerprintReply == QMessageBox::Yes) {\n             // restart core process after trusting fingerprint.\n             db.add_trusted(fingerprint_sha256);\n             db.write(db_path);\n-            startBarrier();\n+            if (is_client) {\n+                startBarrier();\n+            }\n         }\n \n         messageBoxAlreadyShown = false;\n@@ -734,6 +762,10 @@ bool MainWindow::serverArgs(QStringList& args, QString& app)\n         args << \"--log\" << appConfig().logFilenameCmd();\n     }\n \n+    if (!appConfig().getRequireClientCertificate()) {\n+        args << \"--disable-client-cert-checking\";\n+    }\n+\n     QString configFilename = this->configFilename();\n #if defined(Q_OS_WIN)\n     // wrap in quotes in case username contains spaces."
        },
        {
          "filename": "src/lib/barrier/ArgParser.cpp",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -65,7 +65,9 @@ ArgParser::parseServerArgs(ServerArgs& args, int argc, const char* const* argv)\n             // save screen change script path\n             args.m_screenChangeScript = argv[++i];\n         }\n-        else {\n+        else if (isArg(i, argc, argv, nullptr, \"--disable-client-cert-checking\")) {\n+            args.check_client_certificates = false;\n+        } else {\n             LOG((CLOG_PRINT \"%s: unrecognized option `%s'\" BYE, args.m_exename.c_str(), argv[i], args.m_exename.c_str()));\n             return false;\n         }"
        },
        {
          "filename": "src/lib/barrier/ServerApp.cpp",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -148,7 +148,10 @@ ServerApp::help()\n            << \"Options:\\n\"\n            << \"  -a, --address <address>  listen for clients on the given address.\\n\"\n            << \"  -c, --config <pathname>  use the named configuration file instead.\\n\"\n-           << HELP_COMMON_INFO_1 << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << \"\\n\"\n+           << HELP_COMMON_INFO_1\n+           << \"      --disable-client-cert-checking disable client SSL certificate \\n\"\n+              \"                                     checking (deprecated)\\n\"\n+           << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << \"\\n\"\n            << \"Default options are marked with a *\\n\"\n            << \"\\n\"\n            << \"The argument for --address is of the form: [<hostname>][:<port>].  The\\n\"\n@@ -658,6 +661,9 @@ ServerApp::openClientListener(const NetworkAddress& address)\n     auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n     if (args().m_enableCrypto) {\n         security_level = ConnectionSecurityLevel::ENCRYPTED;\n+        if (args().check_client_certificates) {\n+            security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;\n+        }\n     }\n \n     ClientListener* listen = new ClientListener("
        },
        {
          "filename": "src/lib/barrier/ServerArgs.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -30,4 +30,5 @@ class ServerArgs : public ArgsBase {\n     String                m_configFile;\n     Config*                m_config;\n     String                m_screenChangeScript;\n+    bool check_client_certificates = true;\n };"
        },
        {
          "filename": "src/lib/client/Client.cpp",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -129,7 +129,8 @@ Client::connect()\n \n     auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n     if (m_useSecureNetwork) {\n-        security_level = ConnectionSecurityLevel::ENCRYPTED;\n+        // client always authenticates server\n+        security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;\n     }\n \n     try {"
        },
        {
          "filename": "src/lib/net/ConnectionSecurityLevel.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -21,6 +21,7 @@\n enum class ConnectionSecurityLevel {\n     PLAINTEXT,\n     ENCRYPTED,\n+    ENCRYPTED_AUTHENTICATED\n };\n \n #endif // BARRIER_LIB_NET_CONNECTION_SECURITY_LEVEL_H"
        },
        {
          "filename": "src/lib/net/SecureSocket.cpp",
          "status": "modified",
          "additions": 32,
          "deletions": 1,
          "patch": "@@ -361,6 +361,11 @@ bool SecureSocket::load_certificates(const barrier::fs::path& path)\n     return true;\n }\n \n+static int cert_verify_ignore_callback(X509_STORE_CTX*, void*)\n+{\n+    return 1;\n+}\n+\n void\n SecureSocket::initContext(bool server)\n {\n@@ -396,6 +401,14 @@ SecureSocket::initContext(bool server)\n     if (m_ssl->m_context == NULL) {\n         showError(\"\");\n     }\n+\n+    if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n+        // We want to ask for peer certificate, but not verify it. If we don't ask for peer\n+        // certificate, e.g. client won't send it.\n+        SSL_CTX_set_verify(m_ssl->m_context, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n+                           nullptr);\n+        SSL_CTX_set_cert_verify_callback(m_ssl->m_context, cert_verify_ignore_callback, nullptr);\n+    }\n }\n \n void\n@@ -436,6 +449,24 @@ SecureSocket::secureAccept(int socket)\n \n     // If not fatal and no retry, state is good\n     if (retry == 0) {\n+        if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n+            if (verify_cert_fingerprint(\n+                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {\n+                LOG((CLOG_INFO \"accepted secure socket\"));\n+                if (!ensure_peer_certificate()) {\n+                    retry = 0;\n+                    disconnect();\n+                    return -1;// Cert fail, error\n+                }\n+            }\n+            else {\n+                LOG((CLOG_ERR \"failed to verify server certificate fingerprint\"));\n+                retry = 0;\n+                disconnect();\n+                return -1; // Fingerprint failed, error\n+            }\n+        }\n+\n         m_secureReady = true;\n         LOG((CLOG_INFO \"accepted secure socket\"));\n         if (CLOG->getFilter() >= kDEBUG1) {\n@@ -670,7 +701,7 @@ bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& fingerprint_\n     }\n \n     // note: the GUI parses the following two lines of logs, don't change unnecessarily\n-    LOG((CLOG_NOTE \"server fingerprint (SHA1): %s (SHA256): %s\",\n+    LOG((CLOG_NOTE \"peer fingerprint (SHA1): %s (SHA256): %s\",\n          barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(),\n          barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str()));\n "
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 5,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "653e4badeb88f61de901581667d4465d7b1e2d52",
            "date": "2022-02-04T16:47:29Z",
            "author_login": "walker0643"
          },
          {
            "sha": "7324f26e09f8df4a9c308c2ca7debbe6e668c46b",
            "date": "2022-02-03T16:39:00Z",
            "author_login": "walker0643"
          },
          {
            "sha": "00a57ea972e106a21af6ea5b849e21013685a0e5",
            "date": "2022-01-07T06:28:36Z",
            "author_login": "mipedja"
          },
          {
            "sha": "433126e7a15d8cb46ac3b96cd3cc965ca7e34905",
            "date": "2021-12-06T15:04:49Z",
            "author_login": "p12tic"
          },
          {
            "sha": "6ce4b7e97096c7166b0c515841867a8186cf1f29",
            "date": "2021-12-04T19:50:39Z",
            "author_login": "Unit193"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.2,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N",
    "cwe_id": "CWE-384",
    "description": "An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is \"Unnamed\" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-11-08T04:15:08.500",
    "last_modified": "2024-11-21T06:27:11.580",
    "fix_date": "2021-11-01T02:50:15Z"
  },
  "references": [
    {
      "url": "http://www.openwall.com/lists/oss-security/2021/11/02/4",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/debauchee/barrier/commit/b5adc93e2bd74cb094f91ff595c07f321a489f3e",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/debauchee/barrier/releases/tag/v2.4.0",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2021/11/02/4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/debauchee/barrier/commit/b5adc93e2bd74cb094f91ff595c07f321a489f3e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/debauchee/barrier/releases/tag/v2.4.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:31.880154",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "barrier",
    "owner": "debauchee",
    "created_at": "2018-01-25T21:40:32Z",
    "updated_at": "2025-01-14T10:14:55Z",
    "pushed_at": "2024-06-22T00:53:39Z",
    "size": 85633,
    "stars": 27943,
    "forks": 1529,
    "open_issues": 1039,
    "watchers": 27943,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 3535117,
      "C++": 2674516,
      "Objective-C++": 70570,
      "CMake": 49595,
      "Objective-C": 6472,
      "Batchfile": 4042,
      "Shell": 3327,
      "PowerShell": 1607,
      "QMake": 376
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T16:25:59.489027"
  }
}