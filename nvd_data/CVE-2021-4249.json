{
  "cve_id": "CVE-2021-4249",
  "github_data": {
    "repository": "snoyberg/xml",
    "fix_commit": "4be1021791dcdee8b164d239433a2043dc0939ea",
    "related_commits": [
      "4be1021791dcdee8b164d239433a2043dc0939ea",
      "4be1021791dcdee8b164d239433a2043dc0939ea"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "4be1021791dcdee8b164d239433a2043dc0939ea",
      "commit_date": "2021-02-26T18:56:37Z",
      "author": {
        "login": "jgm",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Resolve entities defined in DOCTYPE recursively",
        "length": 419,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 87,
        "additions": 80,
        "deletions": 7
      },
      "files": [
        {
          "filename": "xml-conduit/src/Text/XML/Stream/Parse.hs",
          "status": "modified",
          "additions": 45,
          "deletions": 7,
          "patch": "@@ -81,6 +81,7 @@ module Text.XML.Stream.Parse\n     , psDecodeEntities\n     , psDecodeIllegalCharacters\n     , psRetainNamespaces\n+    , psEntityExpansionSizeLimit\n       -- *** Entity decoding\n     , decodeXmlEntities\n     , decodeHtmlEntities\n@@ -196,7 +197,7 @@ tokenToEvent ps es n (TokenBeginElement name as isClosed _) =\n \n         addNS\n             | not (psRetainNamespaces ps) && (isPrefixed || isUnprefixed) = id\n-            | otherwise = (((tname, map resolve val):) .)\n+            | otherwise = (((tname, resolveEntities ps es val):) .)\n           where\n             tname\n                 | isPrefixed = TName Nothing (\"xmlns:\" `T.append` kname)\n@@ -212,9 +213,6 @@ tokenToEvent ps es n (TokenBeginElement name as isClosed _) =\n                                             else Just $ contentsToText val }\n             | otherwise = l\n \n-    resolve (ContentEntity e)\n-        | Just t <- lookup e es = ContentText t\n-    resolve c = c\n     n' = if isClosed then n else l' : n\n     fixAttName (name', val) = (tnameToName True l' name', val)\n     elementName = tnameToName False l' name\n@@ -227,13 +225,44 @@ tokenToEvent _ es n (TokenEndElement name) =\n         case n of\n             []   -> (NSLevel Nothing Map.empty, [])\n             x:xs -> (x, xs)\n-tokenToEvent _ es n (TokenContent (ContentEntity e))\n-    | Just t <- lookup e es = (es, n, [EventContent $ ContentText t])\n+tokenToEvent ps es n (TokenContent (ContentEntity e))\n+    = (es, n, map EventContent (resolveEntities ps es [ContentEntity e]))\n tokenToEvent _ es n (TokenContent c) = (es, n, [EventContent c])\n tokenToEvent _ es n (TokenComment c) = (es, n, [EventComment c])\n tokenToEvent _ es n (TokenDoctype t eid es') = (es ++ es', n, [EventBeginDoctype t eid, EventEndDoctype])\n tokenToEvent _ es n (TokenCDATA t) = (es, n, [EventCDATA t])\n \n+resolveEntities :: ParseSettings\n+                -> [(Text, Text)]  -- entity table\n+                -> [Content]\n+                -> [Content]\n+resolveEntities ps entities = foldr go []\n+ where\n+  go c@(ContentEntity e) cs\n+    = case expandEntity entities e of\n+        Just xs -> foldr go cs xs\n+        Nothing ->  c : cs\n+  go c cs = c:cs\n+  expandEntity es e\n+    | Just t <- lookup e es =\n+      case AT.parseOnly (manyTill\n+                          (parseContent ps False False :: Parser Content)\n+                          AT.endOfInput) t of\n+        Left _      -> Nothing\n+        Right xs    -> let es' = filter (\\(x,_) -> x /= e) es\n+                        in fst <$> foldr (goent es') (Just ([], 0)) xs\n+          -- we delete e from the entity map in resolving its contents,\n+          -- to avoid infinite loops in recursive expansion.\n+    | otherwise     = Nothing\n+  goent _ _ Nothing = Nothing\n+  goent es (ContentEntity e) (Just (cs, size))\n+    = expandEntity es e >>= foldr (goent es) (Just (cs, size))\n+  goent _ c@(ContentText t) (Just (cs, size)) =\n+    case size + T.length t of\n+      n | n > psEntityExpansionSizeLimit ps -> Nothing\n+        | otherwise -> Just (c:cs, size + T.length t)\n+\n+\n tnameToName :: Bool -> NSLevel -> TName -> Name\n tnameToName _ _ (TName (Just \"xml\") name) =\n     Name name (Just \"http://www.w3.org/XML/1998/namespace\") (Just \"xml\")\n@@ -407,13 +436,22 @@ data ParseSettings = ParseSettings\n     -- Default: @const Nothing@\n     --\n     -- Since 1.7.1\n+    , psEntityExpansionSizeLimit :: Int\n+    -- ^ Maximum number of characters allowed in expanding an\n+    -- internal entity.  This is intended to protect against the\n+    -- billion laughs attack.\n+    --\n+    -- Default: @8192@\n+    --\n+    -- Since 1.9.1\n     }\n \n instance Default ParseSettings where\n     def = ParseSettings\n         { psDecodeEntities = decodeXmlEntities\n         , psRetainNamespaces = False\n         , psDecodeIllegalCharacters = const Nothing\n+        , psEntityExpansionSizeLimit = 8192\n         }\n \n conduitToken :: MonadThrow m => ParseSettings -> ConduitT T.Text (PositionRange, Token) m ()\n@@ -555,7 +593,7 @@ parseContent :: ParseSettings\n              -> Bool -- break on double quote\n              -> Bool -- break on single quote\n              -> Parser Content\n-parseContent (ParseSettings decodeEntities _ decodeIllegalCharacters) breakDouble breakSingle = parseReference <|> parseTextContent where\n+parseContent (ParseSettings decodeEntities _ decodeIllegalCharacters _) breakDouble breakSingle = parseReference <|> parseTextContent where\n   parseReference = do\n     char' '&'\n     t <- parseEntityRef <|> parseHexCharRef <|> parseDecCharRef"
        },
        {
          "filename": "xml-conduit/test/unit.hs",
          "status": "modified",
          "additions": 35,
          "deletions": 0,
          "patch": "@@ -81,6 +81,10 @@ main = hspec $ do\n         it \"works for resolvable entities\" resolvedAllGood\n         it \"merges adjacent content nodes\" resolvedMergeContent\n         it \"understands inline entity declarations\" resolvedInline\n+        it \"can expand inline entities recursively\" resolvedInlineRecursive\n+        it \"doesn't explode with an inline entity loop\" resolvedInlineLoop\n+        it \"doesn't explode with the billion laughs attack\" billionLaughs\n+        it \"allows entity expansion size limit to be adjusted\" thousandLaughs\n         it \"doesn't break on [] in doctype comments\" doctypeComment\n         it \"skips element declarations in doctype\" doctypeElements\n         it \"skips processing instructions in doctype\" doctypePI\n@@ -736,6 +740,37 @@ resolvedInline = do\n     Res.Document _ root2 _ <- return $ Res.parseLBS_ Res.def \"<!DOCTYPE foo [<!ENTITY bar \\\"baz\\\">]><foo bar='&bar;'/>\"\n     root2 @?= Res.Element \"foo\" (Map.singleton \"bar\" \"baz\") []\n \n+resolvedInlineRecursive :: Assertion\n+resolvedInlineRecursive = do\n+    Res.Document _ root _ <- return $ Res.parseLBS_ Res.def\n+      \"<!DOCTYPE foo [<!ENTITY bim \\\"baz\\\"><!ENTITY bar \\\"&bim;&#73;&amp;\\\">]><foo>&bar;</foo>\"\n+    root @?= Res.Element \"foo\" Map.empty [Res.NodeContent \"bazI&\"]\n+\n+resolvedInlineLoop :: Assertion\n+resolvedInlineLoop = do\n+    res <- return $ Res.parseLBS Res.def\n+           \"<!DOCTYPE foo [<!ENTITY bim \\\"&bim;\\\">]><foo>&bim;</foo>\"\n+    Left (toException $ Res.UnresolvedEntityException (Set.fromList [\"bim\"]))\n+      `showEq` res\n+\n+billionLaughs :: Assertion\n+billionLaughs = do\n+    res <- return $ Res.parseLBS Res.def\n+      \"<?xml version=\\\"1.0\\\"?><!DOCTYPE lolz [<!ENTITY lol \\\"lol\\\"><!ELEMENT lolz (#PCDATA)><!ENTITY lol1 \\\"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\\\"><!ENTITY lol2 \\\"&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;\\\"><!ENTITY lol3 \\\"&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;\\\"><!ENTITY lol4 \\\"&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;\\\"><!ENTITY lol5 \\\"&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;\\\"><!ENTITY lol6 \\\"&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;\\\"><!ENTITY lol7 \\\"&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;\\\"><!ENTITY lol8 \\\"&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;\\\"><!ENTITY lol9 \\\"&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;\\\">]><lolz>&lol9;</lolz>\"\n+    Left (toException $ Res.UnresolvedEntityException (Set.fromList [\"lol9\"]))\n+      `showEq` res\n+\n+thousandLaughs :: Assertion\n+thousandLaughs = do\n+    res <- return $ Res.parseLBS Res.def{ P.psEntityExpansionSizeLimit = 2999 }\n+      \"<?xml version=\\\"1.0\\\"?><!DOCTYPE lolz [<!ENTITY lol \\\"lol\\\"><!ELEMENT lolz (#PCDATA)><!ENTITY lol1 \\\"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\\\"><!ENTITY lol2 \\\"&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;\\\"><!ENTITY lol3 \\\"&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;\\\">]><lolz>&lol3;</lolz>\"\n+    Left (toException $ Res.UnresolvedEntityException (Set.fromList [\"lol3\"]))\n+      `showEq` res\n+    -- Raise the entity expansion limit and it should work:\n+    Right (Res.Document {Res.documentRoot = Res.Element{ Res.elementNodes = [Res.NodeContent t] }}) <- return $ Res.parseLBS Res.def{ P.psEntityExpansionSizeLimit = 3001 } \"<?xml version=\\\"1.0\\\"?><!DOCTYPE lolz [<!ENTITY lol \\\"lol\\\"><!ELEMENT lolz (#PCDATA)><!ENTITY lol1 \\\"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\\\"><!ENTITY lol2 \\\"&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;\\\"><!ENTITY lol3 \\\"&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;\\\">]><lolz>&lol3;</lolz>\"\n+    t @?= T.replicate 1000 \"lol\"\n+\n+\n doctypeComment :: Assertion\n doctypeComment = do\n     Res.Document _ root _ <- return $ Res.parseLBS_"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "55b9cb761456750b219e83b3920ea5e49228e334",
            "date": "2025-01-25T17:30:03Z",
            "author_login": "k0ral"
          },
          {
            "sha": "a3db435e1810dfe0696d985011e8e72fea51d36f",
            "date": "2025-01-25T16:39:57Z",
            "author_login": "k0ral"
          },
          {
            "sha": "7a4262881c470aa06f588b1c58c9688e0b286e76",
            "date": "2025-01-25T16:21:23Z",
            "author_login": "k0ral"
          },
          {
            "sha": "cd987a2095085d8155de82809e847495bd1576c9",
            "date": "2025-01-25T16:21:01Z",
            "author_login": "k0ral"
          },
          {
            "sha": "3541e2d6247e6b9f43fa9bdc164b1bd2baf52383",
            "date": "2025-01-25T15:57:12Z",
            "author_login": "k0ral"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-404",
    "description": "A vulnerability was found in xml-conduit. It has been classified as problematic. Affected is an unknown function of the file xml-conduit/src/Text/XML/Stream/Parse.hs of the component DOCTYPE Entity Expansion Handler. The manipulation leads to infinite loop. It is possible to launch the attack remotely. Upgrading to version 1.9.1.0 is able to address this issue. The name of the patch is 4be1021791dcdee8b164d239433a2043dc0939ea. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-216204.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-12-18T15:15:10.063",
    "last_modified": "2024-11-21T06:37:14.023",
    "fix_date": "2021-02-26T18:56:37Z"
  },
  "references": [
    {
      "url": "https://github.com/snoyberg/xml/commit/4be1021791dcdee8b164d239433a2043dc0939ea",
      "source": "cna@vuldb.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/snoyberg/xml/pull/161",
      "source": "cna@vuldb.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://hackage.haskell.org/package/xml-conduit-1.9.1.0",
      "source": "cna@vuldb.com",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?id.216204",
      "source": "cna@vuldb.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/snoyberg/xml/commit/4be1021791dcdee8b164d239433a2043dc0939ea",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/snoyberg/xml/pull/161",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://hackage.haskell.org/package/xml-conduit-1.9.1.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?id.216204",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:23.180367",
    "processing_status": "enhanced"
  }
}