{
  "cve_id": "CVE-2021-43114",
  "github_data": {
    "repository": "NICMx/FORT-validator",
    "fix_commit": "274dc14aed1eb9b3350029d1063578a6b9c77b54",
    "related_commits": [
      "274dc14aed1eb9b3350029d1063578a6b9c77b54",
      "425e0f4037b4543fe8044ac96ca71d6d02d7d8c5",
      "673c679b6bf3f4187cd5242c31a795bf8a6c22b3",
      "eb68ebbaab50f3365aa51bbaa17cb862bf4607fa",
      "274dc14aed1eb9b3350029d1063578a6b9c77b54",
      "425e0f4037b4543fe8044ac96ca71d6d02d7d8c5",
      "673c679b6bf3f4187cd5242c31a795bf8a6c22b3",
      "eb68ebbaab50f3365aa51bbaa17cb862bf4607fa"
    ],
    "patch_url": "https://github.com/NICMx/FORT-validator/commit/274dc14aed1eb9b3350029d1063578a6b9c77b54.patch",
    "fix_commit_details": {
      "sha": "274dc14aed1eb9b3350029d1063578a6b9c77b54",
      "commit_date": "2021-09-08T17:40:26Z",
      "author": {
        "login": "ydahhrk",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Certificates: Fuse meta and level stacks",
        "length": 316,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 182,
        "additions": 99,
        "deletions": 83
      },
      "files": [
        {
          "filename": "src/cert_stack.c",
          "status": "modified",
          "additions": 96,
          "deletions": 83,
          "patch": "@@ -56,24 +56,19 @@ struct metadata_node {\n \tstruct serial_numbers serials;\n \tstruct subjects subjects;\n \n+\t/*\n+\t * Certificate repository \"level\". This aims to identify if the\n+\t * certificate is located at a distinct server than its father (common\n+\t * case when the RIRs delegate RPKI repositories).\n+\t */\n+\tunsigned int level;\n+\n \t/** Used by certstack. Points to the next stacked certificate. */\n \tSLIST_ENTRY(metadata_node) next;\n };\n \n SLIST_HEAD(metadata_stack, metadata_node);\n \n-/**\n- * Certificate repository \"level\". This aims to identify if the\n- * certificate is located at a distinct server than its father (common\n- * case when the RIRs delegate RPKI repositories).\n- */\n-struct repo_level_node {\n-\tunsigned int level;\n-\tSLIST_ENTRY(repo_level_node) next;\n-};\n-\n-SLIST_HEAD(repo_level_stack, repo_level_node);\n-\n /**\n  * This is the foundation through which we pull off our iterative traversal,\n  * as opposed to a stack-threatening recursive one.\n@@ -109,12 +104,6 @@ struct cert_stack {\n \t * seemingly not intended to be used outside of its library.)\n \t */\n \tstruct metadata_stack metas;\n-\n-\t/**\n-\t * Stacked data to store the repository \"levels\" (each level is a\n-\t * delegation of an RPKI server).\n-\t */\n-\tstruct repo_level_stack levels;\n };\n \n int\n@@ -134,7 +123,6 @@ certstack_create(struct cert_stack **result)\n \n \tSLIST_INIT(&stack->defers);\n \tSLIST_INIT(&stack->metas);\n-\tSLIST_INIT(&stack->levels);\n \n \t*result = stack;\n \treturn 0;\n@@ -185,7 +173,6 @@ certstack_destroy(struct cert_stack *stack)\n \tunsigned int stack_size;\n \tstruct metadata_node *meta;\n \tstruct defer_node *post;\n-\tstruct repo_level_node *level;\n \n \tstack_size = 0;\n \twhile (!SLIST_EMPTY(&stack->defers)) {\n@@ -208,15 +195,6 @@ certstack_destroy(struct cert_stack *stack)\n \t}\n \tpr_val_debug(\"Deleted %u metadatas.\", stack_size);\n \n-\tstack_size = 0;\n-\twhile (!SLIST_EMPTY(&stack->levels)) {\n-\t\tlevel = SLIST_FIRST(&stack->levels);\n-\t\tSLIST_REMOVE_HEAD(&stack->levels, next);\n-\t\tfree(level);\n-\t\tstack_size++;\n-\t}\n-\tpr_val_debug(\"Deleted %u stacked levels.\", stack_size);\n-\n \tfree(stack);\n }\n \n@@ -242,7 +220,6 @@ x509stack_pop(struct cert_stack *stack)\n {\n \tX509 *cert;\n \tstruct metadata_node *meta;\n-\tstruct repo_level_node *repo;\n \n \tcert = sk_X509_pop(stack->x509s);\n \tif (cert == NULL)\n@@ -254,12 +231,6 @@ x509stack_pop(struct cert_stack *stack)\n \t\tpr_crit(\"Attempted to pop empty metadata stack\");\n \tSLIST_REMOVE_HEAD(&stack->metas, next);\n \tmeta_destroy(meta);\n-\n-\trepo = SLIST_FIRST(&stack->levels);\n-\tif (repo == NULL)\n-\t\tpr_crit(\"Attempted to pop empty repo level stack\");\n-\tSLIST_REMOVE_HEAD(&stack->levels, next);\n-\tfree(repo);\n }\n \n /**\n@@ -297,89 +268,131 @@ deferstack_is_empty(struct cert_stack *stack)\n \treturn SLIST_EMPTY(&stack->defers);\n }\n \n+static int\n+init_resources(X509 *x509, enum rpki_policy policy, enum cert_type type,\n+    struct resources **_result)\n+{\n+\tstruct resources *result;\n+\tint error;\n+\n+\tresult = resources_create(false);\n+\tif (result == NULL)\n+\t\treturn pr_enomem();\n+\n+\tresources_set_policy(result, policy);\n+\terror = certificate_get_resources(x509, result, type);\n+\tif (error)\n+\t\tgoto fail;\n+\n+\t/*\n+\t * rfc8630#section-2.3\n+\t * \"The INR extension(s) of this TA MUST contain a non-empty set of\n+\t * number resources.\"\n+\t * The \"It MUST NOT use the \"inherit\" form of the INR extension(s)\"\n+\t * part is already handled in certificate_get_resources().\n+\t */\n+\tif (type == TA && resources_empty(result)) {\n+\t\terror = pr_val_err(\"Trust Anchor certificate does not define any number resources.\");\n+\t\tgoto fail;\n+\t}\n+\n+\t*_result = result;\n+\treturn 0;\n+\n+fail:\n+\tresources_destroy(result);\n+\treturn error;\n+}\n+\n+static int\n+init_level(struct cert_stack *stack, unsigned int *_result)\n+{\n+\tstruct metadata_node *head_meta;\n+\tunsigned int work_repo_level;\n+\tunsigned int result;\n+\n+\t/*\n+\t * Bruh, I don't understand the point of this block.\n+\t * Why can't it just be `result = working_repo_peek_level();`?\n+\t */\n+\n+\tresult = 0;\n+\twork_repo_level = working_repo_peek_level();\n+\thead_meta = SLIST_FIRST(&stack->metas);\n+\tif (head_meta != NULL && work_repo_level > head_meta->level)\n+\t\tresult = work_repo_level;\n+\n+\t*_result = result;\n+\treturn 0;\n+}\n+\n+static struct defer_node *\n+create_separator(void)\n+{\n+\tstruct defer_node *result;\n+\n+\tresult = malloc(sizeof(struct defer_node));\n+\tif (result == NULL)\n+\t\treturn NULL;\n+\n+\tresult->type = DNT_SEPARATOR;\n+\treturn result;\n+}\n+\n /** Steals ownership of @x509 on success. */\n int\n x509stack_push(struct cert_stack *stack, struct rpki_uri *uri, X509 *x509,\n     enum rpki_policy policy, enum cert_type type)\n {\n \tstruct metadata_node *meta;\n-\tstruct repo_level_node *repo, *head_repo;\n \tstruct defer_node *defer_separator;\n-\tunsigned int work_repo_level;\n \tint ok;\n \tint error;\n \n-\trepo = malloc(sizeof(struct repo_level_node));\n-\tif (repo == NULL)\n-\t\treturn pr_enomem();\n-\n-\trepo->level = 0;\n-\twork_repo_level = working_repo_peek_level();\n-\thead_repo = SLIST_FIRST(&stack->levels);\n-\tif (head_repo != NULL && work_repo_level > head_repo->level)\n-\t\trepo->level = work_repo_level;\n-\n-\tSLIST_INSERT_HEAD(&stack->levels, repo, next);\n-\n \tmeta = malloc(sizeof(struct metadata_node));\n-\tif (meta == NULL) {\n-\t\terror = pr_enomem();\n-\t\tgoto end3;\n-\t}\n+\tif (meta == NULL)\n+\t\treturn pr_enomem();\n \n \tmeta->uri = uri;\n \turi_refget(uri);\n \tserial_numbers_init(&meta->serials);\n \tsubjects_init(&meta->subjects);\n \n-\tmeta->resources = resources_create(false);\n-\tif (meta->resources == NULL) {\n-\t\terror = pr_enomem();\n-\t\tgoto end4;\n-\t}\n-\tresources_set_policy(meta->resources, policy);\n-\terror = certificate_get_resources(x509, meta->resources, type);\n+\terror = init_resources(x509, policy, type, &meta->resources);\n \tif (error)\n-\t\tgoto end5;\n+\t\tgoto cleanup_subjects;\n \n-\t/*\n-\t * rfc8630#section-2.3\n-\t * \"The INR extension(s) of this TA MUST contain a non-empty set of\n-\t * number resources.\"\n-\t * The \"It MUST NOT use the \"inherit\" form of the INR extension(s)\"\n-\t * part is already handled in certificate_get_resources().\n-\t */\n-\tif (type == TA && resources_empty(meta->resources)) {\n-\t\terror = pr_val_err(\"Trust Anchor certificate does not define any number resources.\");\n-\t\tgoto end5;\n-\t}\n+\terror = init_level(stack, &meta->level); /* Does not need a revert */\n+\tif (error)\n+\t\tgoto destroy_resources;\n \n-\tdefer_separator = malloc(sizeof(struct defer_node));\n+\tdefer_separator = create_separator();\n \tif (defer_separator == NULL) {\n \t\terror = pr_enomem();\n-\t\tgoto end5;\n+\t\tgoto destroy_resources;\n \t}\n-\tdefer_separator->type = DNT_SEPARATOR;\n \n \tok = sk_X509_push(stack->x509s, x509);\n \tif (ok <= 0) {\n \t\terror = val_crypto_err(\n \t\t    \"Could not add certificate to trusted stack: %d\", ok);\n-\t\tgoto end5;\n+\t\tgoto destroy_separator;\n \t}\n \n \tSLIST_INSERT_HEAD(&stack->defers, defer_separator, next);\n \tSLIST_INSERT_HEAD(&stack->metas, meta, next);\n \n \treturn 0;\n \n-end5:\tresources_destroy(meta->resources);\n-end4:\tsubjects_cleanup(&meta->subjects, subject_cleanup);\n+destroy_separator:\n+\tfree(defer_separator);\n+destroy_resources:\n+\tresources_destroy(meta->resources);\n+cleanup_subjects:\n+\tsubjects_cleanup(&meta->subjects, subject_cleanup);\n \tserial_numbers_cleanup(&meta->serials, serial_cleanup);\n \turi_refput(meta->uri);\n \tfree(meta);\n-end3:\tSLIST_REMOVE_HEAD(&stack->levels, next);\n-\tfree(repo);\n \treturn error;\n }\n \n@@ -428,8 +441,8 @@ x509stack_peek_resources(struct cert_stack *stack)\n unsigned int\n x509stack_peek_level(struct cert_stack *stack)\n {\n-\tstruct repo_level_node *repo = SLIST_FIRST(&stack->levels);\n-\treturn (repo != NULL) ? repo->level : 0;\n+\tstruct metadata_node *meta = SLIST_FIRST(&stack->metas);\n+\treturn (meta != NULL) ? meta->level : 0;\n }\n \n static int"
        },
        {
          "filename": "src/object/certificate.c",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -1152,6 +1152,9 @@ __certificate_get_resources(X509 *cert, struct resources *resources,\n \treturn 0;\n }\n \n+/**\n+ * Copies the resources from @cert to @resources.\n+ */\n int\n certificate_get_resources(X509 *cert, struct resources *resources,\n     enum cert_type type)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8bf1e0b19d393af3d6fbd7e74516b4514a1594b4",
            "date": "2025-01-02T22:42:17Z",
            "author_login": "ydahhrk"
          },
          {
            "sha": "280460a53a9fd6f3a07f10e92b09dfa60b8b337e",
            "date": "2024-12-20T22:12:21Z",
            "author_login": "ydahhrk"
          },
          {
            "sha": "38484cc3cb76ed69401fd2b0b7c4027401fd97b7",
            "date": "2024-12-18T22:57:58Z",
            "author_login": "ydahhrk"
          },
          {
            "sha": "17f095210553182b0e0a28ee6fd41b0d3c8fc1d3",
            "date": "2024-12-18T21:58:54Z",
            "author_login": "ydahhrk"
          },
          {
            "sha": "f99f662cec3e0fe083acf4a51916270b496018e1",
            "date": "2024-12-18T18:57:46Z",
            "author_login": "ydahhrk"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": null,
    "description": "FORT Validator versions prior to 1.5.2 will crash if an RPKI CA publishes an X.509 EE certificate. This will lead to RTR clients such as BGP routers to lose access to the RPKI VRP data set, effectively disabling Route Origin Validation.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-11-09T13:15:08.447",
    "last_modified": "2024-11-21T06:28:42.110",
    "fix_date": "2021-09-08T17:40:26Z"
  },
  "references": [
    {
      "url": "https://github.com/NICMx/FORT-validator/commit/274dc14aed1eb9b3350029d1063578a6b9c77b54",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/NICMx/FORT-validator/commit/425e0f4037b4543fe8044ac96ca71d6d02d7d8c5",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/NICMx/FORT-validator/commit/673c679b6bf3f4187cd5242c31a795bf8a6c22b3",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/NICMx/FORT-validator/commit/eb68ebbaab50f3365aa51bbaa17cb862bf4607fa",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/NICMx/FORT-validator/releases/tag/1.5.2",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2021/dsa-5033",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/NICMx/FORT-validator/commit/274dc14aed1eb9b3350029d1063578a6b9c77b54",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/NICMx/FORT-validator/commit/425e0f4037b4543fe8044ac96ca71d6d02d7d8c5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/NICMx/FORT-validator/commit/673c679b6bf3f4187cd5242c31a795bf8a6c22b3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/NICMx/FORT-validator/commit/eb68ebbaab50f3365aa51bbaa17cb862bf4607fa",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/NICMx/FORT-validator/releases/tag/1.5.2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2021/dsa-5033",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:31.882836",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "FORT-validator",
    "owner": "NICMx",
    "created_at": "2018-09-04T21:50:32Z",
    "updated_at": "2025-01-02T22:42:51Z",
    "pushed_at": "2025-01-02T22:42:47Z",
    "size": 4740,
    "stars": 51,
    "forks": 24,
    "open_issues": 47,
    "watchers": 51,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C": 1287678,
      "Makefile": 12563,
      "M4": 1781,
      "Dockerfile": 1297,
      "Shell": 1124
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:52:51.486812"
  }
}