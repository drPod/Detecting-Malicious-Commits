{
  "cve_id": "CVE-2021-43792",
  "github_data": {
    "repository": "discourse/discourse",
    "fix_commit": "cdaf7f4bb3ec268238e4c29a14bb73fad56574b4",
    "related_commits": [
      "cdaf7f4bb3ec268238e4c29a14bb73fad56574b4",
      "cdaf7f4bb3ec268238e4c29a14bb73fad56574b4"
    ],
    "patch_url": "https://github.com/discourse/discourse/commit/cdaf7f4bb3ec268238e4c29a14bb73fad56574b4.patch",
    "fix_commit_details": {
      "sha": "cdaf7f4bb3ec268238e4c29a14bb73fad56574b4",
      "commit_date": "2021-12-01T02:26:56Z",
      "author": {
        "login": "nattsw",
        "type": "User",
        "stats": {
          "total_commits": 136,
          "average_weekly_commits": 0.19624819624819625,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 76
        }
      },
      "commit_message": {
        "title": "SECURITY: Only show tags to users with permission (#15148)",
        "length": 58,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 192,
        "additions": 184,
        "deletions": 8
      },
      "files": [
        {
          "filename": "app/models/tag_user.rb",
          "status": "modified",
          "additions": 18,
          "deletions": 1,
          "patch": "@@ -4,6 +4,20 @@ class TagUser < ActiveRecord::Base\n   belongs_to :tag\n   belongs_to :user\n \n+  scope :notification_level_visible, -> (notification_levels = TagUser.notification_levels.values) {\n+    select(\"tag_users.*\")\n+      .distinct\n+      .joins(\"LEFT OUTER JOIN tag_group_memberships ON tag_users.tag_id = tag_group_memberships.tag_id\")\n+      .joins(\"LEFT OUTER JOIN tag_group_permissions ON tag_group_memberships.tag_group_id = tag_group_permissions.tag_group_id\")\n+      .joins(\"LEFT OUTER JOIN group_users on group_users.user_id = tag_users.user_id\")\n+      .where(\"(tag_group_permissions.group_id IS NULL\n+               OR tag_group_permissions.group_id = group_users.group_id\n+               OR group_users.group_id = :staff_group_id)\n+              AND tag_users.notification_level IN (:notification_levels)\",\n+             staff_group_id: Group::AUTO_GROUPS[:staff],\n+             notification_levels: notification_levels)\n+  }\n+\n   def self.notification_levels\n     NotificationLevels.all\n   end\n@@ -208,7 +222,10 @@ def self.notification_levels_for(user)\n         [name, self.notification_levels[:muted]]\n       end\n     else\n-      notification_levels = TagUser.where(user: user).joins(:tag).pluck(\"tags.name\", :notification_level)\n+      notification_levels = TagUser\n+        .notification_level_visible\n+        .where(user: user)\n+        .joins(:tag).pluck(\"tags.name\", :notification_level)\n     end\n \n     Hash[*notification_levels.flatten]"
        },
        {
          "filename": "app/services/post_alerter.rb",
          "status": "modified",
          "additions": 13,
          "deletions": 7,
          "patch": "@@ -125,9 +125,10 @@ def group_watchers(topic)\n   end\n \n   def tag_watchers(topic)\n-    topic.tag_users\n-      .where(notification_level: TagUser.notification_levels[:watching_first_post])\n-      .pluck(:user_id)\n+    topic\n+      .tag_users\n+      .notification_level_visible([TagUser.notification_levels[:watching_first_post]])\n+      .distinct(:user_id).pluck(:user_id)\n   end\n \n   def category_watchers(topic)\n@@ -698,17 +699,22 @@ def notify_post_users(post, notified, include_topic_watchers: true, include_cate\n           FROM tag_users\n      LEFT JOIN topic_users tu ON tu.user_id = tag_users.user_id\n                              AND tu.topic_id = :topic_id\n-         WHERE tag_users.notification_level = :watching\n-           AND tag_users.tag_id IN (:tag_ids)\n-           AND (tu.user_id IS NULL OR tu.notification_level = :watching)\n+     LEFT JOIN tag_group_memberships tgm ON tag_users.tag_id = tgm.tag_id\n+     LEFT JOIN tag_group_permissions tgp ON tgm.tag_group_id = tgp.tag_group_id\n+     LEFT JOIN group_users gu ON gu.user_id = tag_users.user_id\n+         WHERE (tgp.group_id IS NULL OR tgp.group_id = gu.group_id OR gu.group_id = :staff_group_id)\n+               AND (tag_users.notification_level = :watching\n+                    AND tag_users.tag_id IN (:tag_ids)\n+                    AND (tu.user_id IS NULL OR tu.notification_level = :watching))\n       SQL\n     end\n \n     notify = User.where(condition,\n       watching: TopicUser.notification_levels[:watching],\n       topic_id: post.topic_id,\n       category_id: post.topic.category_id,\n-      tag_ids: tag_ids\n+      tag_ids: tag_ids,\n+      staff_group_id: Group::AUTO_GROUPS[:staff]\n     )\n \n     if post.topic.private_message?"
        },
        {
          "filename": "spec/fabricators/tag_group_permission_fabricator.rb",
          "status": "added",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -0,0 +1,7 @@\n+# frozen_string_literal: true\n+\n+Fabricator(:tag_group_permission) do\n+  tag_group\n+  group\n+  permission_type TagGroupPermission.permission_types[:readonly]\n+end"
        },
        {
          "filename": "spec/models/tag_user_spec.rb",
          "status": "modified",
          "additions": 61,
          "deletions": 0,
          "patch": "@@ -22,6 +22,58 @@ def watching\n     TagUser.notification_levels[:watching]\n   end\n \n+  context \"notification_level_visible\" do\n+    let!(:tag1) { Fabricate(:tag) }\n+    let!(:tag2) { Fabricate(:tag) }\n+    let!(:tag3) { Fabricate(:tag) }\n+    let!(:tag4) { Fabricate(:tag) }\n+    fab!(:user1) { Fabricate(:user) }\n+    fab!(:user2) { Fabricate(:user) }\n+    let!(:tag_user1) { TagUser.create(user: user1, tag: tag1, notification_level: TagUser.notification_levels[:watching]) }\n+    let!(:tag_user2) { TagUser.create(user: user1, tag: tag2, notification_level: TagUser.notification_levels[:tracking]) }\n+    let!(:tag_user3) { TagUser.create(user: user2, tag: tag3, notification_level: TagUser.notification_levels[:watching_first_post]) }\n+    let!(:tag_user4) { TagUser.create(user: user2, tag: tag4, notification_level: TagUser.notification_levels[:muted]) }\n+\n+    it \"scopes to notification levels visible due to absence of tag group\" do\n+      expect(TagUser.notification_level_visible.length).to be(4)\n+    end\n+\n+    it \"scopes to notification levels visible by tag group permission\" do\n+      group1 = Fabricate(:group)\n+      tag_group1 = Fabricate(:tag_group, tags: [tag1])\n+      Fabricate(:tag_group_permission, tag_group: tag_group1, group: group1)\n+\n+      group2 = Fabricate(:group)\n+      tag_group2 = Fabricate(:tag_group, tags: [tag2])\n+      Fabricate(:tag_group_permission, tag_group: tag_group2, group: group2)\n+\n+      Fabricate(:group_user, group: group1, user: user1)\n+\n+      expect(TagUser.notification_level_visible.pluck(:id)).to match_array([\n+        tag_user1.id, tag_user3.id, tag_user4.id\n+      ])\n+    end\n+\n+    it \"scopes to notification levels visible because user is staff\" do\n+      group2 = Fabricate(:group)\n+      tag_group2 = Fabricate(:tag_group, tags: [tag2])\n+      Fabricate(:tag_group_permission, tag_group: tag_group2, group: group2)\n+\n+      staff_group = Group.find(Group::AUTO_GROUPS[:staff])\n+      Fabricate(:group_user, group: staff_group, user: user1)\n+\n+      expect(TagUser.notification_level_visible.length).to be(4)\n+    end\n+\n+    it \"scopes to notification levels visible by specified notification level\" do\n+      expect(TagUser.notification_level_visible([TagUser.notification_levels[:watching]]).length).to be(1)\n+      expect(TagUser.notification_level_visible(\n+        [TagUser.notification_levels[:watching],\n+         TagUser.notification_levels[:tracking]]\n+      ).length).to be(2)\n+    end\n+  end\n+\n   context \"change\" do\n     it \"watches or tracks on change\" do\n       user = Fabricate(:user)\n@@ -264,6 +316,7 @@ def watching\n         TagUser.create(user: user, tag: tag3, notification_level: TagUser.notification_levels[:watching_first_post])\n         TagUser.create(user: user, tag: tag4, notification_level: TagUser.notification_levels[:muted])\n       end\n+\n       it \"gets the tag_user notification levels for all tags the user is tracking and does not\n       include tags the user is not tracking at all\" do\n         tag5 = Fabricate(:tag)\n@@ -274,6 +327,14 @@ def watching\n         expect(levels[tag4.name]).to eq(TagUser.notification_levels[:muted])\n         expect(levels.key?(tag5.name)).to eq(false)\n       end\n+\n+      it \"does not show a tag is tracked if the user does not belong to the tag group with permissions\" do\n+        group = Fabricate(:group)\n+        tag_group = Fabricate(:tag_group, tags: [tag2])\n+        Fabricate(:tag_group_permission, tag_group: tag_group, group: group)\n+\n+        expect(TagUser.notification_levels_for(user).keys).to match_array([tag1.name, tag3.name, tag4.name])\n+      end\n     end\n   end\n end"
        },
        {
          "filename": "spec/services/post_alerter_spec.rb",
          "status": "modified",
          "additions": 85,
          "deletions": 0,
          "patch": "@@ -1158,6 +1158,33 @@ def set_topic_notification_level(user, topic, level_name)\n         notification_data = JSON.parse(notification.data)\n         expect(notification_data[\"display_username\"]).to eq(I18n.t(\"embed.replies\", count: 2))\n       end\n+\n+      it \"does not add notification if user does not belong to tag group with permissions\" do\n+        tag = Fabricate(:tag)\n+        topic = Fabricate(:topic, tags: [tag])\n+        post = Fabricate(:post, topic: topic)\n+        tag_group = Fabricate(:tag_group, tags: [tag])\n+        group = Fabricate(:group)\n+        Fabricate(:tag_group_permission, tag_group: tag_group, group: group)\n+\n+        TagUser.change(user.id, tag.id, TagUser.notification_levels[:watching])\n+\n+        expect { PostAlerter.post_created(post) }.not_to change { Notification.count }\n+      end\n+\n+      it \"adds notification if user belongs to tag group with permissions\" do\n+        tag = Fabricate(:tag)\n+        topic = Fabricate(:topic, tags: [tag])\n+        post = Fabricate(:post, topic: topic)\n+        tag_group = Fabricate(:tag_group, tags: [tag])\n+        group = Fabricate(:group)\n+        Fabricate(:group_user, group: group, user: user)\n+        Fabricate(:tag_group_permission, tag_group: tag_group, group: group)\n+\n+        TagUser.change(user.id, tag.id, TagUser.notification_levels[:watching])\n+\n+        expect { PostAlerter.post_created(post) }.to change { Notification.count }.by(1)\n+      end\n     end\n \n     context \"on change\" do\n@@ -1224,6 +1251,64 @@ def set_topic_notification_level(user, topic, level_name)\n         expect(Notification.where(user_id: admin.id).count).to eq(1)\n       end\n     end\n+\n+    context \"with tag groups\" do\n+      fab!(:tag)  { Fabricate(:tag) }\n+      fab!(:group) { Fabricate(:group) }\n+      fab!(:user) { Fabricate(:user) }\n+      fab!(:topic) { Fabricate(:topic, tags: [tag]) }\n+      fab!(:post) { Fabricate(:post, topic: topic) }\n+\n+      shared_examples \"tag user with notification level\" do |notification_level, notification_type|\n+        it \"notifies a user who is watching a tag that does not belong to a tag group\" do\n+          TagUser.change(user.id, tag.id, TagUser.notification_levels[notification_level])\n+          PostAlerter.post_created(post)\n+          expect(user.notifications.where(notification_type: Notification.types[notification_type]).count).to eq(1)\n+        end\n+\n+        it \"does not notify a user watching a tag with tag group permissions that he does not belong to\" do\n+          tag_group = Fabricate(:tag_group, tags: [tag])\n+          Fabricate(:tag_group_permission, tag_group: tag_group, group: group)\n+\n+          TagUser.change(user.id, tag.id, TagUser.notification_levels[notification_level])\n+\n+          PostAlerter.post_created(post)\n+\n+          expect(user.notifications.where(notification_type: Notification.types[notification_type]).count).to eq(0)\n+        end\n+\n+        it \"notifies a user watching a tag with tag group permissions that he belongs to\" do\n+          Fabricate(:group_user, group: group, user: user)\n+\n+          TagUser.change(user.id, tag.id, TagUser.notification_levels[notification_level])\n+\n+          PostAlerter.post_created(post)\n+\n+          expect(user.notifications.where(notification_type: Notification.types[notification_type]).count).to eq(1)\n+        end\n+\n+        it \"notifies a staff watching a tag with tag group permissions that he does not belong to\" do\n+          tag_group = Fabricate(:tag_group, tags: [tag])\n+          Fabricate(:tag_group_permission, tag_group: tag_group, group: group)\n+          staff_group = Group.find(Group::AUTO_GROUPS[:staff])\n+          Fabricate(:group_user, group: staff_group, user: user)\n+\n+          TagUser.change(user.id, tag.id, TagUser.notification_levels[notification_level])\n+\n+          PostAlerter.post_created(post)\n+\n+          expect(user.notifications.where(notification_type: Notification.types[notification_type]).count).to eq(1)\n+        end\n+      end\n+\n+      context \"with :watching notification level\" do\n+        include_examples \"tag user with notification level\", :watching, :posted\n+      end\n+\n+      context \"with :watching_first_post notification level\" do\n+        include_examples \"tag user with notification level\", :watching_first_post, :watching_first_post\n+      end\n+    end\n   end\n \n   describe '#extract_linked_users' do"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 5,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "496a739788d58a7f1c6bd59643d062ae37e982a0",
            "date": "2025-01-14T15:19:49Z",
            "author_login": "discourse-translator-bot"
          },
          {
            "sha": "a89086f7996f95024827df61fb0d86a516b269f6",
            "date": "2025-01-14T15:19:19Z",
            "author_login": "markvanlan"
          },
          {
            "sha": "473e37e7b3dcb254548a04695fb5e5f56a6de33b",
            "date": "2025-01-14T14:32:50Z",
            "author_login": "CvX"
          },
          {
            "sha": "eb64db828e116edbacdf10266f8102ed7028a2f2",
            "date": "2025-01-14T13:28:46Z",
            "author_login": "renato"
          },
          {
            "sha": "7330cfa76a6e6ab7bf90702fb1db5e1a37a2eca1",
            "date": "2025-01-14T13:28:16Z",
            "author_login": "awesomerobot"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-200",
    "description": "Discourse is an open source discussion platform. In affected versions a vulnerability affects users of tag groups who use the \"Tags are visible only to the following groups\" feature. A tag group may only allow a certain group (e.g. staff) to view certain tags. Users who were tracking or watching the tags via /preferences/tags, then have their staff status revoked will still see notifications related to the tag, but will not see the tag on each topic. This issue has been patched in stable version 2.7.11. Users are advised to upgrade as soon as possible.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-12-01T20:15:08.433",
    "last_modified": "2024-11-21T06:29:47.963",
    "fix_date": "2021-12-01T02:26:56Z"
  },
  "references": [
    {
      "url": "https://github.com/discourse/discourse/commit/cdaf7f4bb3ec268238e4c29a14bb73fad56574b4",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/discourse/discourse/security/advisories/GHSA-pq2x-vq37-8522",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://meta.discourse.org/t/non-forum-staff-getting-notifications-for-staff-only-tags/184895",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/discourse/discourse/commit/cdaf7f4bb3ec268238e4c29a14bb73fad56574b4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/discourse/discourse/security/advisories/GHSA-pq2x-vq37-8522",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://meta.discourse.org/t/non-forum-staff-getting-notifications-for-staff-only-tags/184895",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:34.813507",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "discourse",
    "owner": "discourse",
    "created_at": "2013-01-12T00:25:55Z",
    "updated_at": "2025-01-14T12:47:11Z",
    "pushed_at": "2025-01-14T12:47:07Z",
    "size": 692535,
    "stars": 42892,
    "forks": 8390,
    "open_issues": 67,
    "watchers": 42892,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Ruby": 20275963,
      "JavaScript": 9399743,
      "HTML": 1461704,
      "Handlebars": 1070089,
      "SCSS": 988476,
      "Mustache": 32177,
      "Shell": 12314,
      "CSS": 2558
    },
    "commit_activity": {
      "total_commits_last_year": 5032,
      "avg_commits_per_week": 96.76923076923077,
      "days_active_last_year": 300
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T13:00:05.486140"
  }
}