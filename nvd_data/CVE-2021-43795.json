{
  "cve_id": "CVE-2021-43795",
  "github_data": {
    "repository": "line/armeria",
    "fix_commit": "e2697a575e9df6692b423e02d731f293c1313284",
    "related_commits": [
      "e2697a575e9df6692b423e02d731f293c1313284",
      "e2697a575e9df6692b423e02d731f293c1313284"
    ],
    "patch_url": "https://github.com/line/armeria/commit/e2697a575e9df6692b423e02d731f293c1313284.patch",
    "fix_commit_details": {
      "sha": "e2697a575e9df6692b423e02d731f293c1313284",
      "commit_date": "2021-12-02T10:54:13Z",
      "author": {
        "login": "trustin",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-8fp4-rp6c-5gcv",
        "length": 921,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 723,
        "additions": 501,
        "deletions": 222
      },
      "files": [
        {
          "filename": "core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java",
          "status": "modified",
          "additions": 35,
          "deletions": 2,
          "patch": "@@ -304,11 +304,37 @@ public static String concatPaths(@Nullable String path1, @Nullable String path2)\n      */\n     public static String decodePath(String path) {\n         if (path.indexOf('%') < 0) {\n-            // No need to decoded; not percent-encoded\n+            // No need to decode because it's not percent-encoded\n             return path;\n         }\n \n+        // Decode percent-encoded characters, but don't decode %2F into /, so that a user can choose\n+        // to use it as a non-separator.\n+        //\n+        // For example, for the path pattern `/orgs/{org_name}/agents/{agent_name}`:\n+        // - orgs/mi6/agents/ethan-hunt\n+        //   - org_name: mi6\n+        //   - agent_name: ethan-hunt\n+        // - orgs/mi%2F6/agents/ethan-hunt\n+        //   - org_name: mi/6\n+        //   - agent_name: ethan-hunt\n+        return slowDecodePath(path, false);\n+    }\n+\n+    /**\n+     * Decodes a single percent-encoded path parameter.\n+     */\n+    public static String decodePathParam(String pathParam) {\n+        if (pathParam.indexOf('%') < 0) {\n+            // No need to decode because it's not percent-encoded\n+            return pathParam;\n+        }\n+\n         // Decode percent-encoded characters.\n+        return slowDecodePath(pathParam, true);\n+    }\n+\n+    private static String slowDecodePath(String path, boolean decodeSlash) {\n         // An invalid character is replaced with 0xFF, which will be replaced into '\ufffd' by UTF-8 decoder.\n         final int len = path.length();\n         try (TemporaryThreadLocals tempThreadLocals = TemporaryThreadLocals.acquire()) {\n@@ -335,7 +361,14 @@ public static String decodePath(String path) {\n                     // The first or second digit is not hexadecimal.\n                     buf[dstLen++] = (byte) 0xFF;\n                 } else {\n-                    buf[dstLen++] = (byte) ((digit1 << 4) | digit2);\n+                    final byte decoded = (byte) ((digit1 << 4) | digit2);\n+                    if (decodeSlash || decoded != 0x2F) {\n+                        buf[dstLen++] = decoded;\n+                    } else {\n+                        buf[dstLen++] = '%';\n+                        buf[dstLen++] = '2';\n+                        buf[dstLen++] = (byte) path.charAt(i); // f or F - preserve the case.\n+                    }\n                 }\n             }\n "
        },
        {
          "filename": "core/src/main/java/com/linecorp/armeria/internal/common/PathAndQuery.java",
          "status": "modified",
          "additions": 184,
          "deletions": 125,
          "patch": "@@ -44,13 +44,25 @@ public final class PathAndQuery {\n \n     private static final PathAndQuery ROOT_PATH_QUERY = new PathAndQuery(\"/\", null);\n \n+    /**\n+     * The lookup table for the characters allowed in a path.\n+     */\n     private static final BitSet ALLOWED_PATH_CHARS = new BitSet();\n+\n+    /**\n+     * The lookup table for the characters allowed in a query string.\n+     */\n     private static final BitSet ALLOWED_QUERY_CHARS = new BitSet();\n \n-    private static final int PERCENT_ENCODING_MARKER = 0xFF;\n+    /**\n+     * The lookup table for the reserved characters that require percent-encoding.\n+     */\n+    private static final BitSet RESERVED_CHARS = new BitSet();\n \n-    private static final byte[] RAW_CHAR_TO_MARKER = new byte[256];\n-    private static final String[] MARKER_TO_PERCENT_ENCODED_CHAR = new String[256];\n+    /**\n+     * The table that converts a byte into a percent-encoded chars, e.g. 'A' -> \"%41\".\n+     */\n+    private static final char[][] TO_PERCENT_ENCODED_CHARS = new char[256][];\n \n     static {\n         final String allowedPathChars =\n@@ -65,9 +77,13 @@ public final class PathAndQuery {\n             ALLOWED_QUERY_CHARS.set(allowedQueryChars.charAt(i));\n         }\n \n-        for (final ReservedChar reservedChar : ReservedChar.values()) {\n-            RAW_CHAR_TO_MARKER[reservedChar.rawChar] = reservedChar.marker;\n-            MARKER_TO_PERCENT_ENCODED_CHAR[reservedChar.marker] = reservedChar.percentEncodedChar;\n+        final String reservedChars = \":/?#[]@!$&'()*+,;=\";\n+        for (int i = 0; i < reservedChars.length(); i++) {\n+            RESERVED_CHARS.set(reservedChars.charAt(i));\n+        }\n+\n+        for (int i = 0; i < TO_PERCENT_ENCODED_CHARS.length; i++) {\n+            TO_PERCENT_ENCODED_CHARS[i] = String.format(\"%%%02X\", i).toCharArray();\n         }\n     }\n \n@@ -182,7 +198,7 @@ public String toString() {\n         if (query == null) {\n             return path;\n         }\n-        return path + \"?\" + query;\n+        return path + '?' + query;\n     }\n \n     @Nullable\n@@ -213,18 +229,17 @@ private static PathAndQuery splitPathAndQuery(@Nullable final String pathAndQuer\n             query = null;\n         }\n \n-        if (path.data[0] != '/') {\n+        if (path.data[0] != '/' || path.isEncoded(0)) {\n             // Do not accept a relative path.\n             return null;\n         }\n \n         // Reject the prohibited patterns.\n-        if (pathContainsDoubleDots(path)) {\n+        if (pathContainsDoubleDots(path) || queryContainsDoubleDots(query)) {\n             return null;\n         }\n \n-        return new PathAndQuery(encodeToPercents(path, true),\n-                                query != null ? encodeToPercents(query, false) : null);\n+        return new PathAndQuery(encodePathToPercents(path), encodeQueryToPercents(query));\n     }\n \n     @Nullable\n@@ -261,14 +276,8 @@ private static Bytes decodePercentsAndEncodeToUtf8(String value, int start, int\n                         // Do not decode '%2F' and '%2f' in the path to '/' for compatibility with\n                         // other implementations in the ecosystem, e.g. HTTP/JSON to gRPC transcoding.\n                         // https://github.com/googleapis/googleapis/blob/02710fa0ea5312d79d7fb986c9c9823fb41049a9/google/api/http.proto#L257-L258\n-\n-                        // Insert a special mark so we can distinguish a raw character ('/') and\n-                        // percent-encoded character ('%2F') in a path string.\n-                        // We will encode this mark back into a percent-encoded character later.\n-                        final byte marker = RAW_CHAR_TO_MARKER['/'];\n-                        buf.ensure(2);\n-                        buf.add((byte) PERCENT_ENCODING_MARKER);\n-                        buf.add(marker);\n+                        buf.ensure(1);\n+                        buf.addEncoded((byte) '/');\n                         wasSlash = false;\n                     } else {\n                         if (appendOneByte(buf, decoded, wasSlash, isPath)) {\n@@ -279,14 +288,9 @@ private static Bytes decodePercentsAndEncodeToUtf8(String value, int start, int\n                     }\n                 } else {\n                     // If query:\n-                    final byte marker = RAW_CHAR_TO_MARKER[decoded];\n-                    if (marker != 0) {\n-                        // Insert a special mark so we can distinguish a raw character and percent-encoded\n-                        // character in a query string, such as '&' and '%26'.\n-                        // We will encode this mark back into a percent-encoded character later.\n-                        buf.ensure(2);\n-                        buf.add((byte) PERCENT_ENCODING_MARKER);\n-                        buf.add(marker);\n+                    if (RESERVED_CHARS.get(decoded)) {\n+                        buf.ensure(1);\n+                        buf.addEncoded((byte) decoded);\n                         wasSlash = false;\n                     } else if (appendOneByte(buf, decoded, wasSlash, isPath)) {\n                         wasSlash = decoded == '/';\n@@ -301,7 +305,7 @@ private static Bytes decodePercentsAndEncodeToUtf8(String value, int start, int\n \n             if (cp == '+' && !isPath) {\n                 buf.ensure(1);\n-                buf.add((byte) ' ');\n+                buf.addEncoded((byte) ' ');\n                 wasSlash = false;\n                 continue;\n             }\n@@ -316,38 +320,38 @@ private static Bytes decodePercentsAndEncodeToUtf8(String value, int start, int\n \n             if (cp <= 0x7ff) {\n                 buf.ensure(2);\n-                buf.add((byte) ((cp >>> 6) | 0b110_00000));\n-                buf.add((byte) (cp & 0b111111 | 0b10_000000));\n+                buf.addEncoded((byte) ((cp >>> 6) | 0b110_00000));\n+                buf.addEncoded((byte) (cp & 0b111111 | 0b10_000000));\n             } else if (cp <= 0xffff) {\n                 buf.ensure(3);\n-                buf.add((byte) ((cp >>> 12) | 0b1110_0000));\n-                buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));\n-                buf.add((byte) ((cp & 0b111111) | 0b10_000000));\n+                buf.addEncoded((byte) ((cp >>> 12) | 0b1110_0000));\n+                buf.addEncoded((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));\n+                buf.addEncoded((byte) ((cp & 0b111111) | 0b10_000000));\n             } else if (cp <= 0x1fffff) {\n                 buf.ensure(4);\n-                buf.add((byte) ((cp >>> 18) | 0b11110_000));\n-                buf.add((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));\n-                buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));\n-                buf.add((byte) ((cp & 0b111111) | 0b10_000000));\n+                buf.addEncoded((byte) ((cp >>> 18) | 0b11110_000));\n+                buf.addEncoded((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));\n+                buf.addEncoded((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));\n+                buf.addEncoded((byte) ((cp & 0b111111) | 0b10_000000));\n             } else if (cp <= 0x3ffffff) {\n                 // A valid unicode character will never reach here, but for completeness.\n                 // http://unicode.org/mail-arch/unicode-ml/Archives-Old/UML018/0330.html\n                 buf.ensure(5);\n-                buf.add((byte) ((cp >>> 24) | 0b111110_00));\n-                buf.add((byte) (((cp >>> 18) & 0b111111) | 0b10_000000));\n-                buf.add((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));\n-                buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));\n-                buf.add((byte) ((cp & 0b111111) | 0b10_000000));\n+                buf.addEncoded((byte) ((cp >>> 24) | 0b111110_00));\n+                buf.addEncoded((byte) (((cp >>> 18) & 0b111111) | 0b10_000000));\n+                buf.addEncoded((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));\n+                buf.addEncoded((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));\n+                buf.addEncoded((byte) ((cp & 0b111111) | 0b10_000000));\n             } else {\n                 // A valid unicode character will never reach here, but for completeness.\n                 // http://unicode.org/mail-arch/unicode-ml/Archives-Old/UML018/0330.html\n                 buf.ensure(6);\n-                buf.add((byte) ((cp >>> 30) | 0b1111110_0));\n-                buf.add((byte) (((cp >>> 24) & 0b111111) | 0b10_000000));\n-                buf.add((byte) (((cp >>> 18) & 0b111111) | 0b10_000000));\n-                buf.add((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));\n-                buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));\n-                buf.add((byte) ((cp & 0b111111) | 0b10_000000));\n+                buf.addEncoded((byte) ((cp >>> 30) | 0b1111110_0));\n+                buf.addEncoded((byte) (((cp >>> 24) & 0b111111) | 0b10_000000));\n+                buf.addEncoded((byte) (((cp >>> 18) & 0b111111) | 0b10_000000));\n+                buf.addEncoded((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));\n+                buf.addEncoded((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));\n+                buf.addEncoded((byte) ((cp & 0b111111) | 0b10_000000));\n             }\n \n             wasSlash = false;\n@@ -380,8 +384,13 @@ private static boolean appendOneByte(Bytes buf, int cp, boolean wasSlash, boolea\n                 // Remove the consecutive slashes: '/path//with///consecutive////slashes'.\n             }\n         } else {\n+            final BitSet allowedChars = isPath ? ALLOWED_PATH_CHARS : ALLOWED_QUERY_CHARS;\n             buf.ensure(1);\n-            buf.add((byte) cp);\n+            if (allowedChars.get(cp)) {\n+                buf.add((byte) cp);\n+            } else {\n+                buf.addEncoded((byte) cp);\n+            }\n         }\n \n         return true;\n@@ -394,77 +403,144 @@ private static boolean pathContainsDoubleDots(Bytes path) {\n         byte b2 = '/';\n         for (int i = 1; i < length; i++) {\n             final byte b3 = path.data[i];\n-            if (b3 == '/' && b2 == '.' && b1 == '.' && b0 == '/') {\n+            // Flag if the last four bytes are `/../`.\n+            if (b1 == '.' && b2 == '.' && isSlash(b0) && isSlash(b3)) {\n                 return true;\n             }\n             b0 = b1;\n             b1 = b2;\n             b2 = b3;\n         }\n \n-        return b0 == '/' && b1 == '.' && b2 == '.';\n+        // Flag if the last three bytes are `/..`.\n+        return b1 == '.' && b2 == '.' && isSlash(b0);\n     }\n \n-    private static String encodeToPercents(Bytes value, boolean isPath) {\n-        final BitSet allowedChars = isPath ? ALLOWED_PATH_CHARS : ALLOWED_QUERY_CHARS;\n-        final int length = value.length;\n-        boolean needsEncoding = false;\n+    private static boolean queryContainsDoubleDots(@Nullable Bytes query) {\n+        if (query == null) {\n+            return false;\n+        }\n+\n+        final int length = query.length;\n+        boolean lookingForEquals = true;\n+        byte b0 = 0;\n+        byte b1 = 0;\n+        byte b2 = '/';\n         for (int i = 0; i < length; i++) {\n-            if (!allowedChars.get(value.data[i] & 0xFF)) {\n-                needsEncoding = true;\n-                break;\n+            byte b3 = query.data[i];\n+\n+            // Treat the delimiters as `/` so that we can use isSlash() for matching them.\n+            switch (b3) {\n+                case '=':\n+                    // Treat only the first `=` as `/`, e.g.\n+                    // - `foo=..` and `foo=../` should be flagged.\n+                    // - `foo=..=` shouldn't be flagged because `..=` is not a relative path.\n+                    if (lookingForEquals) {\n+                        lookingForEquals = false;\n+                        b3 = '/';\n+                    }\n+                    break;\n+                case '&':\n+                case ';':\n+                    b3 = '/';\n+                    lookingForEquals = true;\n+                    break;\n+            }\n+\n+            // Flag if the last four bytes are `/../` or `/..&`\n+            if (b1 == '.' && b2 == '.' && isSlash(b0) && isSlash(b3)) {\n+                return true;\n             }\n+\n+            b0 = b1;\n+            b1 = b2;\n+            b2 = b3;\n+        }\n+\n+        return b1 == '.' && b2 == '.' && isSlash(b0);\n+    }\n+\n+    private static boolean isSlash(byte b) {\n+        switch (b) {\n+            case '/':\n+            case '\\\\':\n+                return true;\n+            default:\n+                return false;\n         }\n+    }\n \n-        if (!needsEncoding) {\n+    private static String encodePathToPercents(Bytes value) {\n+        if (!value.hasEncodedBytes()) {\n             // Deprecated, but it fits perfect for our use case.\n             // noinspection deprecation\n-            return new String(value.data, 0, 0, length);\n+            return new String(value.data, 0, 0, value.length);\n         }\n \n-        final StringBuilder buf = new StringBuilder(length);\n+        // Slow path: some percent-encoded chars.\n+        return slowEncodePathToPercents(value);\n+    }\n+\n+    @Nullable\n+    private static String encodeQueryToPercents(@Nullable Bytes value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        if (!value.hasEncodedBytes()) {\n+            // Deprecated, but it fits perfect for our use case.\n+            // noinspection deprecation\n+            return new String(value.data, 0, 0, value.length);\n+        }\n+\n+        // Slow path: some percent-encoded chars.\n+        return slowEncodeQueryToPercents(value);\n+    }\n+\n+    private static String slowEncodePathToPercents(Bytes value) {\n+        final int length = value.length;\n+        final StringBuilder buf = new StringBuilder(length + value.numEncodedBytes() * 2);\n         for (int i = 0; i < length; i++) {\n             final int b = value.data[i] & 0xFF;\n \n-            if (b == PERCENT_ENCODING_MARKER && (i + 1) < length) {\n-                final int marker = value.data[i + 1] & 0xFF;\n-                final String percentEncodedChar = MARKER_TO_PERCENT_ENCODED_CHAR[marker];\n-                if (percentEncodedChar != null) {\n-                    buf.append(percentEncodedChar);\n-                    i++;\n-                    continue;\n-                }\n+            if (value.isEncoded(i)) {\n+                buf.append(TO_PERCENT_ENCODED_CHARS[b]);\n+                continue;\n             }\n \n-            if (allowedChars.get(b)) {\n-                buf.append((char) b);\n-            } else if (b == ' ') {\n-                if (isPath) {\n-                    buf.append(\"%20\");\n-                } else {\n-                    buf.append('+');\n-                }\n-            } else {\n-                buf.append('%');\n-                appendHexNibble(buf, b >>> 4);\n-                appendHexNibble(buf, b & 0xF);\n-            }\n+            buf.append((char) b);\n         }\n \n         return buf.toString();\n     }\n \n-    private static void appendHexNibble(StringBuilder buf, int nibble) {\n-        if (nibble < 10) {\n-            buf.append((char) ('0' + nibble));\n-        } else {\n-            buf.append((char) ('A' + nibble - 10));\n+    private static String slowEncodeQueryToPercents(Bytes value) {\n+        final int length = value.length;\n+        final StringBuilder buf = new StringBuilder(length + value.numEncodedBytes() * 2);\n+        for (int i = 0; i < length; i++) {\n+            final int b = value.data[i] & 0xFF;\n+\n+            if (value.isEncoded(i)) {\n+                if (b == ' ') {\n+                    buf.append('+');\n+                } else {\n+                    buf.append(TO_PERCENT_ENCODED_CHARS[b]);\n+                }\n+                continue;\n+            }\n+\n+            buf.append((char) b);\n         }\n+\n+        return buf.toString();\n     }\n \n     private static final class Bytes {\n         byte[] data;\n         int length;\n+        @Nullable\n+        private BitSet encoded;\n+        private int numEncodedBytes;\n \n         Bytes(int initialCapacity) {\n             data = new byte[initialCapacity];\n@@ -479,6 +555,27 @@ void add(byte b) {\n             data[length++] = b;\n         }\n \n+        void addEncoded(byte b) {\n+            if (encoded == null) {\n+                encoded = new BitSet();\n+            }\n+            encoded.set(length);\n+            data[length++] = b;\n+            numEncodedBytes++;\n+        }\n+\n+        boolean isEncoded(int index) {\n+            return encoded != null && encoded.get(index);\n+        }\n+\n+        boolean hasEncodedBytes() {\n+            return encoded != null;\n+        }\n+\n+        int numEncodedBytes() {\n+            return numEncodedBytes;\n+        }\n+\n         void ensure(int numBytes) {\n             int newCapacity = length + numBytes;\n             if (newCapacity <= data.length) {\n@@ -531,42 +628,4 @@ int nextCodePoint() {\n             return c1;\n         }\n     }\n-\n-    /**\n-     * Reserved characters which require percent-encoding. These values are only used for constructing\n-     * {@link #RAW_CHAR_TO_MARKER} and {@link #MARKER_TO_PERCENT_ENCODED_CHAR} mapping tables.\n-     *\n-     * @see <a href=\"https://datatracker.ietf.org/doc/html/rfc3986#section-2.2\">RFC 3986, section 2.2</a>\n-     */\n-    private enum ReservedChar {\n-        GEN_DELIM_01(':', \"%3A\", (byte) 0x01),\n-        GEN_DELIM_02('/', \"%2F\", (byte) 0x02),\n-        GEN_DELIM_03('?', \"%3F\", (byte) 0x03),\n-        GEN_DELIM_04('#', \"%23\", (byte) 0x04),\n-        GEN_DELIM_05('[', \"%5B\", (byte) 0x05),\n-        GEN_DELIM_06(']', \"%5D\", (byte) 0x06),\n-        GEN_DELIM_07('@', \"%40\", (byte) 0x07),\n-\n-        SUB_DELIM_01('!', \"%21\", (byte) 0x11),\n-        SUB_DELIM_02('$', \"%24\", (byte) 0x12),\n-        SUB_DELIM_03('&', \"%26\", (byte) 0x13),\n-        SUB_DELIM_04('\\'', \"%27\", (byte) 0x14),\n-        SUB_DELIM_05('(', \"%28\", (byte) 0x15),\n-        SUB_DELIM_06(')', \"%29\", (byte) 0x16),\n-        SUB_DELIM_07('*', \"%2A\", (byte) 0x17),\n-        SUB_DELIM_08('+', \"%2B\", (byte) 0x18),\n-        SUB_DELIM_09(',', \"%2C\", (byte) 0x19),\n-        SUB_DELIM_10(';', \"%3B\", (byte) 0x1A),\n-        SUB_DELIM_11('=', \"%3D\", (byte) 0x1B);\n-\n-        private final int rawChar;\n-        private final String percentEncodedChar;\n-        private final byte marker;\n-\n-        ReservedChar(int rawChar, String percentEncodedChar, byte marker) {\n-            this.rawChar = rawChar;\n-            this.percentEncodedChar = percentEncodedChar;\n-            this.marker = marker;\n-        }\n-    }\n }"
        },
        {
          "filename": "core/src/main/java/com/linecorp/armeria/server/RoutingResultBuilder.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -96,7 +96,7 @@ public RoutingResultBuilder decodedParam(String name, String value) {\n      */\n     public RoutingResultBuilder rawParam(String name, String value) {\n         pathParams().put(requireNonNull(name, \"name\"),\n-                         ArmeriaHttpUtil.decodePath(requireNonNull(value, \"value\")));\n+                         ArmeriaHttpUtil.decodePathParam(requireNonNull(value, \"value\")));\n         return this;\n     }\n "
        },
        {
          "filename": "core/src/test/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtilTest.java",
          "status": "modified",
          "additions": 29,
          "deletions": 11,
          "patch": "@@ -35,8 +35,11 @@\n import java.util.List;\n import java.util.Map;\n import java.util.function.BiConsumer;\n+import java.util.function.Function;\n \n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n \n import com.google.common.collect.ImmutableList;\n \n@@ -89,21 +92,36 @@ void testConcatPaths() throws Exception {\n         assertThat(concatPaths(\"/a/\", \"?foo=bar\")).isEqualTo(\"/a/?foo=bar\");\n     }\n \n-    @Test\n-    void testDecodePath() throws Exception {\n+    @ParameterizedTest\n+    @CsvSource({ \"true\", \"false\" })\n+    void testDecodePath(boolean isPathParam) throws Exception {\n+        final Function<String, String> decodeFunc;\n+        if (isPathParam) {\n+            decodeFunc = ArmeriaHttpUtil::decodePathParam;\n+        } else {\n+            decodeFunc = ArmeriaHttpUtil::decodePath;\n+        }\n+\n         // Fast path\n         final String pathThatDoesNotNeedDecode = \"/foo_bar_baz\";\n-        assertThat(decodePath(pathThatDoesNotNeedDecode)).isSameAs(pathThatDoesNotNeedDecode);\n+        assertThat(decodeFunc.apply(pathThatDoesNotNeedDecode)).isSameAs(pathThatDoesNotNeedDecode);\n \n         // Slow path\n-        assertThat(decodePath(\"/foo%20bar\\u007fbaz\")).isEqualTo(\"/foo bar\\u007fbaz\");\n-        assertThat(decodePath(\"/%C2%A2\")).isEqualTo(\"/\u00a2\"); // Valid UTF-8 sequence\n-        assertThat(decodePath(\"/%20\\u0080\")).isEqualTo(\"/ \ufffd\"); // Unallowed character\n-        assertThat(decodePath(\"/%\")).isEqualTo(\"/\ufffd\"); // No digit\n-        assertThat(decodePath(\"/%1\")).isEqualTo(\"/\ufffd\"); // Only a single digit\n-        assertThat(decodePath(\"/%G0\")).isEqualTo(\"/\ufffd\"); // First digit is not hex.\n-        assertThat(decodePath(\"/%0G\")).isEqualTo(\"/\ufffd\"); // Second digit is not hex.\n-        assertThat(decodePath(\"/%C3%28\")).isEqualTo(\"/\ufffd(\"); // Invalid UTF-8 sequence\n+        assertThat(decodeFunc.apply(\"/foo%20bar\\u007fbaz\")).isEqualTo(\"/foo bar\\u007fbaz\");\n+        assertThat(decodeFunc.apply(\"/%C2%A2\")).isEqualTo(\"/\u00a2\"); // Valid UTF-8 sequence\n+        assertThat(decodeFunc.apply(\"/%20\\u0080\")).isEqualTo(\"/ \ufffd\"); // Unallowed character\n+        assertThat(decodeFunc.apply(\"/%\")).isEqualTo(\"/\ufffd\"); // No digit\n+        assertThat(decodeFunc.apply(\"/%1\")).isEqualTo(\"/\ufffd\"); // Only a single digit\n+        assertThat(decodeFunc.apply(\"/%G0\")).isEqualTo(\"/\ufffd\"); // First digit is not hex.\n+        assertThat(decodeFunc.apply(\"/%0G\")).isEqualTo(\"/\ufffd\"); // Second digit is not hex.\n+        assertThat(decodeFunc.apply(\"/%C3%28\")).isEqualTo(\"/\ufffd(\"); // Invalid UTF-8 sequence\n+\n+        // %2F (/) must be decoded only for path parameters.\n+        if (isPathParam) {\n+            assertThat(decodeFunc.apply(\"/%2F\")).isEqualTo(\"//\");\n+        } else {\n+            assertThat(decodeFunc.apply(\"/%2F\")).isEqualTo(\"/%2F\");\n+        }\n     }\n \n     @Test"
        },
        {
          "filename": "core/src/test/java/com/linecorp/armeria/internal/common/PathAndQueryTest.java",
          "status": "modified",
          "additions": 240,
          "deletions": 81,
          "patch": "@@ -17,139 +17,265 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n+import java.util.Set;\n+\n import org.junit.jupiter.api.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import com.google.common.base.Ascii;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Maps;\n+\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.annotation.Nullable;\n \n class PathAndQueryTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PathAndQueryTest.class);\n+\n+    private static final Set<String> QUERY_SEPARATORS = ImmutableSet.of(\"&\", \";\");\n+\n+    private static final Set<String> BAD_DOUBLE_DOT_PATTERNS = ImmutableSet.of(\n+            \"..\", \"/..\", \"../\", \"/../\",\n+            \"../foo\", \"/../foo\",\n+            \"foo/..\", \"/foo/..\",\n+            \"foo/../\", \"/foo/../\",\n+            \"foo/../bar\", \"/foo/../bar\",\n+\n+            // Dots escaped\n+            \".%2e\", \"/.%2e\", \"%2E./\", \"/%2E./\", \".%2E/\", \"/.%2E/\",\n+            \"foo/.%2e\", \"/foo/.%2e\",\n+            \"foo/%2E./\", \"/foo/%2E./\",\n+            \"foo/%2E./bar\", \"/foo/%2E./bar\",\n+\n+            // Slashes escaped\n+            \"%2f..\", \"..%2F\", \"/..%2F\", \"%2F../\", \"%2f..%2f\",\n+            \"/foo%2f..\", \"/foo%2f../\", \"/foo/..%2f\",\"/foo%2F..%2F\",\n+\n+            // Dots and slashes escaped\n+            \".%2E%2F\"\n+    );\n+\n+    private static final Set<String> GOOD_DOUBLE_DOT_PATTERNS = ImmutableSet.of(\n+            \"..a\", \"a..\", \"a..b\",\n+            \"/..a\", \"/a..\", \"/a..b\",\n+            \"..a/\", \"a../\", \"a..b/\",\n+            \"/..a/\", \"/a../\", \"/a..b/\"\n+    );\n+\n     @Test\n     void empty() {\n-        final PathAndQuery res = PathAndQuery.parse(null);\n+        final PathAndQuery res = parse(null);\n         assertThat(res).isNotNull();\n         assertThat(res.path()).isEqualTo(\"/\");\n         assertThat(res.query()).isNull();\n \n-        final PathAndQuery res2 = PathAndQuery.parse(\"\");\n+        final PathAndQuery res2 = parse(\"\");\n         assertThat(res2).isNotNull();\n         assertThat(res2.path()).isEqualTo(\"/\");\n         assertThat(res2.query()).isNull();\n \n-        final PathAndQuery res3 = PathAndQuery.parse(\"?\");\n+        final PathAndQuery res3 = parse(\"?\");\n         assertThat(res3).isNotNull();\n         assertThat(res3.path()).isEqualTo(\"/\");\n         assertThat(res3.query()).isEqualTo(\"\");\n     }\n \n     @Test\n     void relative() {\n-        assertThat(PathAndQuery.parse(\"foo\")).isNull();\n+        assertThat(parse(\"foo\")).isNull();\n     }\n \n     @Test\n-    void doubleDots() {\n-        assertThat(PathAndQuery.parse(\"/..\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/../\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/../foo\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/foo/..\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/foo/../\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/foo/../bar\")).isNull();\n+    void doubleDotsInPath() {\n+        BAD_DOUBLE_DOT_PATTERNS.forEach(pattern -> assertProhibited(pattern));\n+        GOOD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n+            final String path = pattern.startsWith(\"/\") ? pattern : '/' + pattern;\n+            final PathAndQuery res = parse(path);\n+            assertThat(res).as(\"Ensure %s is allowed.\", path).isNotNull();\n+            assertThat(res.path()).as(\"Ensure %s is parsed as-is.\", path).isEqualTo(path);\n+        });\n+    }\n \n-        // Escaped\n-        assertThat(PathAndQuery.parse(\"/.%2e\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/%2E./\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/foo/.%2e\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/foo/%2E./\")).isNull();\n+    @Test\n+    void doubleDotsInFreeFormQuery() {\n+        BAD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n+            assertProhibited(\"/?\" + pattern);\n+        });\n+\n+        GOOD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n+            assertQueryStringAllowed(\"/?\" + pattern, pattern);\n+        });\n+    }\n \n-        // Not the double dots we are looking for.\n-        final PathAndQuery res = PathAndQuery.parse(\"/..a\");\n-        assertThat(res).isNotNull();\n-        assertThat(res.path()).isEqualTo(\"/..a\");\n-        final PathAndQuery res2 = PathAndQuery.parse(\"/a..\");\n-        assertThat(res2).isNotNull();\n-        assertThat(res2.path()).isEqualTo(\"/a..\");\n+    @Test\n+    void doubleDotsInNameValueQuery() {\n+        // Dots in a query param name.\n+        BAD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n+            assertProhibited(\"/?\" + pattern + \"=foo\");\n+        });\n+        GOOD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n+            assertQueryStringAllowed(\"/?\" + pattern + \"=foo\");\n+        });\n+\n+        // Dots in a query param value.\n+        BAD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n+            assertProhibited(\"/?foo=\" + pattern);\n+        });\n+        GOOD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n+            assertQueryStringAllowed(\"/?foo=\" + pattern);\n+        });\n+\n+        QUERY_SEPARATORS.forEach(qs -> {\n+            // Dots in the second query param name.\n+            BAD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n+                assertProhibited(\"/?a=b\" + qs + pattern + \"=c\");\n+            });\n+            GOOD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n+                assertQueryStringAllowed(\"/?a=b\" + qs + pattern + \"=c\");\n+            });\n+\n+            // Dots in the second query param value.\n+            BAD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n+                assertProhibited(\"/?a=b\" + qs + \"c=\" + pattern);\n+            });\n+            GOOD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n+                assertQueryStringAllowed(\"/?a=b\" + qs + \"c=\" + pattern);\n+            });\n+\n+            // Dots in the name of the query param in the middle.\n+            BAD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n+                assertProhibited(\"/?a=b\" + qs + pattern + \"=c\" + qs + \"d=e\");\n+            });\n+            GOOD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n+                assertQueryStringAllowed(\"/?a=b\" + qs + pattern + \"=c\" + qs + \"d=e\");\n+            });\n+\n+            // Dots in the value of the query param in the middle.\n+            BAD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n+                assertProhibited(\"/?a=b\" + qs + \"c=\" + pattern + qs + \"d=e\");\n+            });\n+            GOOD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n+                assertQueryStringAllowed(\"/?a=b\" + qs + \"c=\" + pattern + qs + \"d=e\");\n+            });\n+        });\n+    }\n+\n+    /**\n+     * {@link PathAndQuery} treats the first `=` in a query parameter as `/` internally to simplify\n+     * the detection the logic. This test makes sure the `=` appeared later is not treated as `/`.\n+     */\n+    @Test\n+    void dotsAndEqualsInNameValueQuery() {\n+        QUERY_SEPARATORS.forEach(qs -> {\n+            final PathAndQuery res = parse(\"/?a=..=\" + qs + \"b=..=\");\n+            assertThat(res).isNotNull();\n+            assertThat(res.query()).isEqualTo(\"a=..=\" + qs + \"b=..=\");\n+            assertThat(QueryParams.fromQueryString(res.query(), true)).containsExactly(\n+                    Maps.immutableEntry(\"a\", \"..=\"),\n+                    Maps.immutableEntry(\"b\", \"..=\")\n+            );\n+\n+            final PathAndQuery res2 = parse(\"/?a==..\" + qs + \"b==..\");\n+            assertThat(res2).isNotNull();\n+            assertThat(res2.query()).isEqualTo(\"a==..\" + qs + \"b==..\");\n+            assertThat(QueryParams.fromQueryString(res2.query(), true)).containsExactly(\n+                    Maps.immutableEntry(\"a\", \"=..\"),\n+                    Maps.immutableEntry(\"b\", \"=..\")\n+            );\n+\n+            final PathAndQuery res3 = parse(\"/?a==..=\" + qs + \"b==..=\");\n+            assertThat(res3).isNotNull();\n+            assertThat(res3.query()).isEqualTo(\"a==..=\" + qs + \"b==..=\");\n+            assertThat(QueryParams.fromQueryString(res3.query(), true)).containsExactly(\n+                    Maps.immutableEntry(\"a\", \"=..=\"),\n+                    Maps.immutableEntry(\"b\", \"=..=\")\n+            );\n+        });\n     }\n \n     @Test\n     void hexadecimal() {\n-        assertThat(PathAndQuery.parse(\"/%\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/%0\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/%0X\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/%X0\")).isNull();\n+        assertThat(parse(\"/%\")).isNull();\n+        assertThat(parse(\"/%0\")).isNull();\n+        assertThat(parse(\"/%0X\")).isNull();\n+        assertThat(parse(\"/%X0\")).isNull();\n     }\n \n     @Test\n     void controlChars() {\n-        assertThat(PathAndQuery.parse(\"/\\0\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/a\\nb\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/a\\u007fb\")).isNull();\n+        assertThat(parse(\"/\\0\")).isNull();\n+        assertThat(parse(\"/a\\nb\")).isNull();\n+        assertThat(parse(\"/a\\u007fb\")).isNull();\n \n         // Escaped\n-        assertThat(PathAndQuery.parse(\"/%00\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/a%09b\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/a%0ab\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/a%0db\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/a%7fb\")).isNull();\n+        assertThat(parse(\"/%00\")).isNull();\n+        assertThat(parse(\"/a%09b\")).isNull();\n+        assertThat(parse(\"/a%0ab\")).isNull();\n+        assertThat(parse(\"/a%0db\")).isNull();\n+        assertThat(parse(\"/a%7fb\")).isNull();\n \n         // With query string\n-        assertThat(PathAndQuery.parse(\"/\\0?c\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/a\\tb?c\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/a\\nb?c\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/a\\rb?c\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/a\\u007fb?c\")).isNull();\n+        assertThat(parse(\"/\\0?c\")).isNull();\n+        assertThat(parse(\"/a\\tb?c\")).isNull();\n+        assertThat(parse(\"/a\\nb?c\")).isNull();\n+        assertThat(parse(\"/a\\rb?c\")).isNull();\n+        assertThat(parse(\"/a\\u007fb?c\")).isNull();\n \n         // With query string with control chars\n-        assertThat(PathAndQuery.parse(\"/?\\0\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/?%00\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/?a\\u007fb\")).isNull();\n-        assertThat(PathAndQuery.parse(\"/?a%7Fb\")).isNull();\n+        assertThat(parse(\"/?\\0\")).isNull();\n+        assertThat(parse(\"/?%00\")).isNull();\n+        assertThat(parse(\"/?a\\u007fb\")).isNull();\n+        assertThat(parse(\"/?a%7Fb\")).isNull();\n         // However, 0x0A, 0x0D, 0x09 should be accepted in a query string.\n-        assertThat(PathAndQuery.parse(\"/?a\\tb\").query()).isEqualTo(\"a%09b\");\n-        assertThat(PathAndQuery.parse(\"/?a\\nb\").query()).isEqualTo(\"a%0Ab\");\n-        assertThat(PathAndQuery.parse(\"/?a\\rb\").query()).isEqualTo(\"a%0Db\");\n-        assertThat(PathAndQuery.parse(\"/?a%09b\").query()).isEqualTo(\"a%09b\");\n-        assertThat(PathAndQuery.parse(\"/?a%0Ab\").query()).isEqualTo(\"a%0Ab\");\n-        assertThat(PathAndQuery.parse(\"/?a%0Db\").query()).isEqualTo(\"a%0Db\");\n+        assertThat(parse(\"/?a\\tb\").query()).isEqualTo(\"a%09b\");\n+        assertThat(parse(\"/?a\\nb\").query()).isEqualTo(\"a%0Ab\");\n+        assertThat(parse(\"/?a\\rb\").query()).isEqualTo(\"a%0Db\");\n+        assertThat(parse(\"/?a%09b\").query()).isEqualTo(\"a%09b\");\n+        assertThat(parse(\"/?a%0Ab\").query()).isEqualTo(\"a%0Ab\");\n+        assertThat(parse(\"/?a%0Db\").query()).isEqualTo(\"a%0Db\");\n     }\n \n     @Test\n     void percent() {\n-        final PathAndQuery res = PathAndQuery.parse(\"/%25\");\n+        final PathAndQuery res = parse(\"/%25\");\n         assertThat(res).isNotNull();\n         assertThat(res.path()).isEqualTo(\"/%25\");\n         assertThat(res.query()).isNull();\n     }\n \n     @Test\n     void shouldNotDecodeSlash() {\n-        final PathAndQuery res = PathAndQuery.parse(\"%2F?%2F\");\n+        final PathAndQuery res = parse(\"%2F?%2F\");\n         // Do not accept a relative path.\n         assertThat(res).isNull();\n-        final PathAndQuery res1 = PathAndQuery.parse(\"/%2F?%2F\");\n+        final PathAndQuery res1 = parse(\"/%2F?%2F\");\n         assertThat(res1).isNotNull();\n         assertThat(res1.path()).isEqualTo(\"/%2F\");\n         assertThat(res1.query()).isEqualTo(\"%2F\");\n \n-        final PathAndQuery pathOnly = PathAndQuery.parse(\"/foo%2F\");\n+        final PathAndQuery pathOnly = parse(\"/foo%2F\");\n         assertThat(pathOnly).isNotNull();\n         assertThat(pathOnly.path()).isEqualTo(\"/foo%2F\");\n         assertThat(pathOnly.query()).isNull();\n \n-        final PathAndQuery queryOnly = PathAndQuery.parse(\"/?%2f=%2F\");\n+        final PathAndQuery queryOnly = parse(\"/?%2f=%2F\");\n         assertThat(queryOnly).isNotNull();\n         assertThat(queryOnly.path()).isEqualTo(\"/\");\n         assertThat(queryOnly.query()).isEqualTo(\"%2F=%2F\");\n     }\n \n     @Test\n     void consecutiveSlashes() {\n-        final PathAndQuery res = PathAndQuery.parse(\n+        final PathAndQuery res = parse(\n                 \"/path//with///consecutive////slashes?/query//with///consecutive////slashes\");\n         assertThat(res).isNotNull();\n         assertThat(res.path()).isEqualTo(\"/path/with/consecutive/slashes\");\n         assertThat(res.query()).isEqualTo(\"/query//with///consecutive////slashes\");\n \n         // Encoded slashes\n-        final PathAndQuery res2 = PathAndQuery.parse(\n+        final PathAndQuery res2 = parse(\n                 \"/path%2F/with/%2F/consecutive//%2F%2Fslashes?/query%2F/with/%2F/consecutive//%2F%2Fslashes\");\n         assertThat(res2).isNotNull();\n         assertThat(res2.path()).isEqualTo(\"/path%2F/with/%2F/consecutive/%2F%2Fslashes\");\n@@ -158,22 +284,22 @@ void consecutiveSlashes() {\n \n     @Test\n     void colon() {\n-        assertThat(PathAndQuery.parse(\"/:\")).isNotNull();\n-        assertThat(PathAndQuery.parse(\"/:/\")).isNotNull();\n-        assertThat(PathAndQuery.parse(\"/a/:\")).isNotNull();\n-        assertThat(PathAndQuery.parse(\"/a/:/\")).isNotNull();\n+        assertThat(parse(\"/:\")).isNotNull();\n+        assertThat(parse(\"/:/\")).isNotNull();\n+        assertThat(parse(\"/a/:\")).isNotNull();\n+        assertThat(parse(\"/a/:/\")).isNotNull();\n     }\n \n     @Test\n     void rawUnicode() {\n         // 2- and 3-byte UTF-8\n-        final PathAndQuery res1 = PathAndQuery.parse(\"/\\u00A2?\\u20AC\"); // \u00a2 and \u20ac\n+        final PathAndQuery res1 = parse(\"/\\u00A2?\\u20AC\"); // \u00a2 and \u20ac\n         assertThat(res1).isNotNull();\n         assertThat(res1.path()).isEqualTo(\"/%C2%A2\");\n         assertThat(res1.query()).isEqualTo(\"%E2%82%AC\");\n \n         // 4-byte UTF-8\n-        final PathAndQuery res2 = PathAndQuery.parse(\"/\\uD800\\uDF48\"); // \ud800\udf48\n+        final PathAndQuery res2 = parse(\"/\\uD800\\uDF48\"); // \ud800\udf48\n         assertThat(res2).isNotNull();\n         assertThat(res2.path()).isEqualTo(\"/%F0%90%8D%88\");\n         assertThat(res2.query()).isNull();\n@@ -185,122 +311,155 @@ void rawUnicode() {\n     void encodedUnicode() {\n         final String encodedPath = \"/%ec%95%88\";\n         final String encodedQuery = \"%eb%85%95\";\n-        final PathAndQuery res = PathAndQuery.parse(encodedPath + '?' + encodedQuery);\n+        final PathAndQuery res = parse(encodedPath + '?' + encodedQuery);\n         assertThat(res).isNotNull();\n         assertThat(res.path()).isEqualTo(Ascii.toUpperCase(encodedPath));\n         assertThat(res.query()).isEqualTo(Ascii.toUpperCase(encodedQuery));\n     }\n \n     @Test\n     void noEncoding() {\n-        final PathAndQuery res = PathAndQuery.parse(\"/a?b=c\");\n+        final PathAndQuery res = parse(\"/a?b=c\");\n         assertThat(res).isNotNull();\n         assertThat(res.path()).isEqualTo(\"/a\");\n         assertThat(res.query()).isEqualTo(\"b=c\");\n     }\n \n     @Test\n     void space() {\n-        final PathAndQuery res = PathAndQuery.parse(\"/ ? \");\n+        final PathAndQuery res = parse(\"/ ? \");\n         assertThat(res).isNotNull();\n         assertThat(res.path()).isEqualTo(\"/%20\");\n         assertThat(res.query()).isEqualTo(\"+\");\n \n-        final PathAndQuery res2 = PathAndQuery.parse(\"/%20?%20\");\n+        final PathAndQuery res2 = parse(\"/%20?%20\");\n         assertThat(res2).isNotNull();\n         assertThat(res2.path()).isEqualTo(\"/%20\");\n         assertThat(res2.query()).isEqualTo(\"+\");\n     }\n \n     @Test\n     void plus() {\n-        final PathAndQuery res = PathAndQuery.parse(\"/+?a+b=c+d\");\n+        final PathAndQuery res = parse(\"/+?a+b=c+d\");\n         assertThat(res).isNotNull();\n         assertThat(res.path()).isEqualTo(\"/+\");\n         assertThat(res.query()).isEqualTo(\"a+b=c+d\");\n \n-        final PathAndQuery res2 = PathAndQuery.parse(\"/%2b?a%2bb=c%2bd\");\n+        final PathAndQuery res2 = parse(\"/%2b?a%2bb=c%2bd\");\n         assertThat(res2).isNotNull();\n         assertThat(res2.path()).isEqualTo(\"/+\");\n         assertThat(res2.query()).isEqualTo(\"a%2Bb=c%2Bd\");\n     }\n \n     @Test\n     void ampersand() {\n-        final PathAndQuery res = PathAndQuery.parse(\"/&?a=1&a=2&b=3\");\n+        final PathAndQuery res = parse(\"/&?a=1&a=2&b=3\");\n         assertThat(res).isNotNull();\n         assertThat(res.path()).isEqualTo(\"/&\");\n         assertThat(res.query()).isEqualTo(\"a=1&a=2&b=3\");\n \n         // '%26' in a query string should never be decoded into '&'.\n-        final PathAndQuery res2 = PathAndQuery.parse(\"/%26?a=1%26a=2&b=3\");\n+        final PathAndQuery res2 = parse(\"/%26?a=1%26a=2&b=3\");\n         assertThat(res2).isNotNull();\n         assertThat(res2.path()).isEqualTo(\"/&\");\n         assertThat(res2.query()).isEqualTo(\"a=1%26a=2&b=3\");\n     }\n \n     @Test\n     void semicolon() {\n-        final PathAndQuery res = PathAndQuery.parse(\"/;?a=b;c=d\");\n+        final PathAndQuery res = parse(\"/;?a=b;c=d\");\n         assertThat(res).isNotNull();\n         assertThat(res.path()).isEqualTo(\"/;\");\n         assertThat(res.query()).isEqualTo(\"a=b;c=d\");\n \n         // '%3B' in a query string should never be decoded into ';'.\n-        final PathAndQuery res2 = PathAndQuery.parse(\"/%3b?a=b%3Bc=d\");\n+        final PathAndQuery res2 = parse(\"/%3b?a=b%3Bc=d\");\n         assertThat(res2).isNotNull();\n         assertThat(res2.path()).isEqualTo(\"/;\");\n         assertThat(res2.query()).isEqualTo(\"a=b%3Bc=d\");\n     }\n \n     @Test\n     void equal() {\n-        final PathAndQuery res = PathAndQuery.parse(\"/=?a=b=1\");\n+        final PathAndQuery res = parse(\"/=?a=b=1\");\n         assertThat(res).isNotNull();\n         assertThat(res.path()).isEqualTo(\"/=\");\n         assertThat(res.query()).isEqualTo(\"a=b=1\");\n \n         // '%3D' in a query string should never be decoded into '='.\n-        final PathAndQuery res2 = PathAndQuery.parse(\"/%3D?a%3db=1\");\n+        final PathAndQuery res2 = parse(\"/%3D?a%3db=1\");\n         assertThat(res2).isNotNull();\n         assertThat(res2.path()).isEqualTo(\"/=\");\n         assertThat(res2.query()).isEqualTo(\"a%3Db=1\");\n     }\n \n     @Test\n     void sharp() {\n-        final PathAndQuery res = PathAndQuery.parse(\"/#?a=b#1\");\n+        final PathAndQuery res = parse(\"/#?a=b#1\");\n         assertThat(res).isNotNull();\n         assertThat(res.path()).isEqualTo(\"/#\");\n         assertThat(res.query()).isEqualTo(\"a=b#1\");\n \n         // '%23' in a query string should never be decoded into '#'.\n-        final PathAndQuery res2 = PathAndQuery.parse(\"/%23?a=b%231\");\n+        final PathAndQuery res2 = parse(\"/%23?a=b%231\");\n         assertThat(res2).isNotNull();\n         assertThat(res2.path()).isEqualTo(\"/#\");\n         assertThat(res2.query()).isEqualTo(\"a=b%231\");\n     }\n \n     @Test\n     void allReservedCharacters() {\n-        final PathAndQuery res = PathAndQuery.parse(\"/#/:[]@!$&'()*+,;=?a=/#/:[]@!$&'()*+,;=\");\n+        final PathAndQuery res = parse(\"/#/:[]@!$&'()*+,;=?a=/#/:[]@!$&'()*+,;=\");\n         assertThat(res).isNotNull();\n         assertThat(res.path()).isEqualTo(\"/#/:[]@!$&'()*+,;=\");\n         assertThat(res.query()).isEqualTo(\"a=/#/:[]@!$&'()*+,;=\");\n \n         final PathAndQuery res2 =\n-                PathAndQuery.parse(\"/%23%2F%3A%5B%5D%40%21%24%26%27%28%29%2A%2B%2C%3B%3D%3F\" +\n-                                   \"?a=%23%2F%3A%5B%5D%40%21%24%26%27%28%29%2A%2B%2C%3B%3D%3F\");\n+                parse(\"/%23%2F%3A%5B%5D%40%21%24%26%27%28%29%2A%2B%2C%3B%3D%3F\" +\n+                      \"?a=%23%2F%3A%5B%5D%40%21%24%26%27%28%29%2A%2B%2C%3B%3D%3F\");\n         assertThat(res2).isNotNull();\n         assertThat(res2.path()).isEqualTo(\"/#%2F:[]@!$&'()*+,;=?\");\n         assertThat(res2.query()).isEqualTo(\"a=%23%2F%3A%5B%5D%40%21%24%26%27%28%29%2A%2B%2C%3B%3D%3F\");\n     }\n \n     @Test\n     void doubleQuote() {\n-        final PathAndQuery res = PathAndQuery.parse(\"/\\\"?\\\"\");\n+        final PathAndQuery res = parse(\"/\\\"?\\\"\");\n         assertThat(res).isNotNull();\n         assertThat(res.path()).isEqualTo(\"/%22\");\n         assertThat(res.query()).isEqualTo(\"%22\");\n     }\n+\n+    private static void assertProhibited(String rawPath) {\n+        assertThat(parse(rawPath))\n+                .as(\"Ensure parse(\\\"%s\\\") returns null.\", rawPath)\n+                .isNull();\n+    }\n+\n+    private static void assertQueryStringAllowed(String rawPath) {\n+        assertThat(rawPath).startsWith(\"/?\");\n+        final String expectedQuery = rawPath.substring(2);\n+        assertQueryStringAllowed(rawPath, expectedQuery);\n+    }\n+\n+    private static void assertQueryStringAllowed(String rawPath, String expectedQuery) {\n+        final PathAndQuery res = parse(rawPath);\n+        assertThat(res)\n+                .as(\"parse(\\\"%s\\\") must return non-null.\", rawPath)\n+                .isNotNull();\n+        assertThat(res.query())\n+                .as(\"parse(\\\"%s\\\").query() must return \\\"%s\\\".\", rawPath, expectedQuery)\n+                .isEqualTo(expectedQuery);\n+    }\n+\n+    @Nullable\n+    private static PathAndQuery parse(@Nullable String rawPath) {\n+        final PathAndQuery res = PathAndQuery.parse(rawPath);\n+        if (res != null) {\n+            logger.info(\"parse({}) => path: {}, query: {}\", rawPath, res.path(), res.query());\n+        } else {\n+            logger.info(\"parse({}) => null\", rawPath);\n+        }\n+        return res;\n+    }\n }"
        },
        {
          "filename": "core/src/test/java/com/linecorp/armeria/server/RoutingResultTest.java",
          "status": "modified",
          "additions": 12,
          "deletions": 2,
          "patch": "@@ -19,10 +19,11 @@\n import static org.assertj.core.api.Assertions.assertThat;\n \n import java.net.URISyntaxException;\n-import java.util.AbstractMap.SimpleEntry;\n \n import org.junit.jupiter.api.Test;\n \n+import com.google.common.collect.Maps;\n+\n import com.linecorp.armeria.common.MediaType;\n \n class RoutingResultTest {\n@@ -45,7 +46,16 @@ void routingResult() throws URISyntaxException {\n         assertThat(routingResult.isPresent()).isTrue();\n         assertThat(routingResult.path()).isEqualTo(\"/foo\");\n         assertThat(routingResult.query()).isEqualTo(\"bar=baz\");\n-        assertThat(routingResult.pathParams()).containsOnly(new SimpleEntry<>(\"qux\", \"quux\"));\n+        assertThat(routingResult.pathParams()).containsOnly(Maps.immutableEntry(\"qux\", \"quux\"));\n         assertThat(routingResult.negotiatedResponseMediaType()).isSameAs(MediaType.JSON_UTF_8);\n     }\n+\n+    @Test\n+    void percentEncodedPathParam() {\n+        final RoutingResultBuilder builder = RoutingResult.builder();\n+        final RoutingResult routingResult = builder.path(\"/foo\")\n+                                                   .rawParam(\"bar\", \"%62az%2Fqu%78\")\n+                                                   .build();\n+        assertThat(routingResult.pathParams()).containsOnly(Maps.immutableEntry(\"bar\", \"baz/qux\"));\n+    }\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 4,
        "max_directory_depth": 9
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "65629276366b5eb7c1094bb492759789094f437a",
            "date": "2025-01-14T02:52:48Z",
            "author_login": "ikhoon"
          },
          {
            "sha": "8ae035e0b7f42e314c35a2148e75df9558465735",
            "date": "2025-01-14T02:51:54Z",
            "author_login": "minwoox"
          },
          {
            "sha": "bbb0571ed0845a5872c4c63dc476bf6ce6b8396b",
            "date": "2025-01-14T02:48:03Z",
            "author_login": "ikhoon"
          },
          {
            "sha": "68ba43d431e67015d7460d601ef56c90dc684f4e",
            "date": "2025-01-14T02:37:02Z",
            "author_login": "ikhoon"
          },
          {
            "sha": "d7a4d293924f50cec7138f575193f76cb2352593",
            "date": "2025-01-11T10:06:05Z",
            "author_login": "github-actions[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-22",
    "description": "Armeria is an open source microservice framework. In affected versions an attacker can access an Armeria server's local file system beyond its restricted directory by sending an HTTP request whose path contains `%2F` (encoded `/`), such as `/files/..%2Fsecrets.txt`, bypassing Armeria's path validation logic. Armeria 1.13.4 or above contains the hardened path validation logic that handles `%2F` properly. This vulnerability can be worked around by inserting a decorator that performs an additional validation on the request path.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-12-02T18:15:08.267",
    "last_modified": "2024-11-21T06:29:48.350",
    "fix_date": "2021-12-02T10:54:13Z"
  },
  "references": [
    {
      "url": "https://github.com/line/armeria/commit/e2697a575e9df6692b423e02d731f293c1313284",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/line/armeria/pull/3855",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/line/armeria/security/advisories/GHSA-8fp4-rp6c-5gcv",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/line/armeria/commit/e2697a575e9df6692b423e02d731f293c1313284",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/line/armeria/pull/3855",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/line/armeria/security/advisories/GHSA-8fp4-rp6c-5gcv",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:34.816151",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "armeria",
    "owner": "line",
    "created_at": "2015-11-16T04:04:01Z",
    "updated_at": "2025-01-14T10:26:52Z",
    "pushed_at": "2025-01-14T06:11:16Z",
    "size": 243017,
    "stars": 4854,
    "forks": 925,
    "open_issues": 678,
    "watchers": 4854,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Java": 21571056,
      "MDX": 1120492,
      "TypeScript": 278598,
      "Thrift": 257694,
      "Scala": 238820,
      "Kotlin": 156259,
      "Less": 35351,
      "JavaScript": 26455,
      "Shell": 2062,
      "HTML": 1222,
      "CSS": 820
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:33:35.165360"
  }
}