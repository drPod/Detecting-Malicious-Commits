{
  "cve_id": "CVE-2021-43825",
  "github_data": {
    "repository": "envoyproxy/envoy",
    "fix_commit": "148de954ed3585d8b4298b424aa24916d0de6136",
    "related_commits": [
      "148de954ed3585d8b4298b424aa24916d0de6136",
      "148de954ed3585d8b4298b424aa24916d0de6136"
    ],
    "patch_url": "https://github.com/envoyproxy/envoy/commit/148de954ed3585d8b4298b424aa24916d0de6136.patch",
    "fix_commit_details": {
      "sha": "148de954ed3585d8b4298b424aa24916d0de6136",
      "commit_date": "2022-02-01T19:50:04Z",
      "author": {
        "login": "yanavlasov",
        "type": "User",
        "stats": {
          "total_commits": 353,
          "average_weekly_commits": 0.800453514739229,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 163
        }
      },
      "commit_message": {
        "title": "CVE-2021-43825",
        "length": 95,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 182,
        "additions": 166,
        "deletions": 16
      },
      "files": [
        {
          "filename": "source/common/http/conn_manager_impl.cc",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -205,8 +205,8 @@ void ConnectionManagerImpl::doEndStream(ActiveStream& stream) {\n   // here is when Envoy \"ends\" the stream by calling recreateStream at which point recreateStream\n   // explicitly nulls out response_encoder to avoid the downstream being notified of the\n   // Envoy-internal stream instance being ended.\n-  if (stream.response_encoder_ != nullptr &&\n-      (!stream.filter_manager_.remoteComplete() || !stream.state_.codec_saw_local_complete_)) {\n+  if (stream.response_encoder_ != nullptr && (!stream.filter_manager_.remoteDecodeComplete() ||\n+                                              !stream.state_.codec_saw_local_complete_)) {\n     // Indicate local is complete at this point so that if we reset during a continuation, we don't\n     // raise further data or trailers.\n     ENVOY_STREAM_LOG(debug, \"doEndStream() resetting stream\", stream);\n@@ -249,7 +249,7 @@ void ConnectionManagerImpl::doEndStream(ActiveStream& stream) {\n   // We also don't delay-close in the case of HTTP/1.1 where the request is\n   // fully read, as there's no race condition to avoid.\n   bool connection_close = stream.state_.saw_connection_close_;\n-  bool request_complete = stream.filter_manager_.remoteComplete();\n+  bool request_complete = stream.filter_manager_.remoteDecodeComplete();\n \n   checkForDeferredClose(connection_close && (request_complete || http_10_sans_cl));\n }\n@@ -1432,7 +1432,7 @@ void ConnectionManagerImpl::ActiveStream::encodeHeaders(ResponseHeaderMap& heade\n   // If we are destroying a stream before remote is complete and the connection does not support\n   // multiplexing, we should disconnect since we don't want to wait around for the request to\n   // finish.\n-  if (!filter_manager_.remoteComplete()) {\n+  if (!filter_manager_.remoteDecodeComplete()) {\n     if (connection_manager_.codec_->protocol() < Protocol::Http2) {\n       connection_manager_.drain_state_ = DrainState::Closing;\n     }"
        },
        {
          "filename": "source/common/http/filter_manager.cc",
          "status": "modified",
          "additions": 12,
          "deletions": 3,
          "patch": "@@ -303,6 +303,12 @@ bool ActiveStreamDecoderFilter::canContinue() {\n   return !parent_.state_.local_complete_;\n }\n \n+bool ActiveStreamEncoderFilter::canContinue() {\n+  // As with ActiveStreamDecoderFilter::canContinue() make sure we do not\n+  // continue if a local reply has been sent.\n+  return !parent_.state_.remote_encode_complete_;\n+}\n+\n Buffer::InstancePtr ActiveStreamDecoderFilter::createBuffer() {\n   auto buffer = dispatcher().getWatermarkFactory().createBuffer(\n       [this]() -> void { this->requestDataDrained(); },\n@@ -316,7 +322,7 @@ Buffer::InstancePtr& ActiveStreamDecoderFilter::bufferedData() {\n   return parent_.buffered_request_data_;\n }\n \n-bool ActiveStreamDecoderFilter::complete() { return parent_.state_.remote_complete_; }\n+bool ActiveStreamDecoderFilter::complete() { return parent_.state_.remote_decode_complete_; }\n \n void ActiveStreamDecoderFilter::doHeaders(bool end_stream) {\n   parent_.decodeHeaders(this, *parent_.filter_manager_callbacks_.requestHeaders(), end_stream);\n@@ -832,8 +838,8 @@ void FilterManager::decodeMetadata(ActiveStreamDecoderFilter* filter, MetadataMa\n }\n \n void FilterManager::maybeEndDecode(bool end_stream) {\n-  ASSERT(!state_.remote_complete_);\n-  state_.remote_complete_ = end_stream;\n+  ASSERT(!state_.remote_decode_complete_);\n+  state_.remote_decode_complete_ = end_stream;\n   if (end_stream) {\n     stream_info_.downstreamTiming().onLastDownstreamRxByteReceived(dispatcher().timeSource());\n     ENVOY_STREAM_LOG(debug, \"request end stream\", *this);\n@@ -1356,6 +1362,8 @@ void FilterManager::encodeTrailers(ActiveStreamEncoderFilter* filter,\n \n void FilterManager::maybeEndEncode(bool end_stream) {\n   if (end_stream) {\n+    ASSERT(!state_.remote_encode_complete_);\n+    state_.remote_encode_complete_ = true;\n     filter_manager_callbacks_.endStream();\n   }\n }\n@@ -1646,6 +1654,7 @@ Http1StreamEncoderOptionsOptRef ActiveStreamEncoderFilter::http1StreamEncoderOpt\n }\n \n void ActiveStreamEncoderFilter::responseDataTooLarge() {\n+  ENVOY_STREAM_LOG(debug, \"response data too large watermark exceeded\", parent_);\n   if (parent_.state_.encoder_filters_streaming_) {\n     onEncoderFilterAboveWriteBufferHighWatermark();\n   } else {"
        },
        {
          "filename": "source/common/http/filter_manager.h",
          "status": "modified",
          "additions": 9,
          "deletions": 9,
          "patch": "@@ -317,7 +317,7 @@ struct ActiveStreamEncoderFilter : public ActiveStreamFilterBase,\n       : ActiveStreamFilterBase(parent, dual_filter, std::move(match_state)), handle_(filter) {}\n \n   // ActiveStreamFilterBase\n-  bool canContinue() override { return true; }\n+  bool canContinue() override;\n   Buffer::InstancePtr createBuffer() override;\n   Buffer::InstancePtr& bufferedData() override;\n   bool complete() override;\n@@ -907,7 +907,7 @@ class FilterManager : public ScopeTrackedObject,\n   /**\n    * Whether remote processing has been marked as complete.\n    */\n-  bool remoteComplete() const { return state_.remote_complete_; }\n+  bool remoteDecodeComplete() const { return state_.remote_decode_complete_; }\n \n   /**\n    * Instructs the FilterManager to not create a filter chain. This makes it possible to issue\n@@ -1058,15 +1058,15 @@ class FilterManager : public ScopeTrackedObject,\n \n   struct State {\n     State()\n-        : remote_complete_(false), local_complete_(false), has_1xx_headers_(false),\n-          created_filter_chain_(false), is_head_request_(false), is_grpc_request_(false),\n-          non_100_response_headers_encoded_(false), under_on_local_reply_(false),\n-          decoder_filter_chain_aborted_(false), encoder_filter_chain_aborted_(false),\n-          saw_downstream_reset_(false) {}\n-\n+        : remote_encode_complete_(false), remote_decode_complete_(false), local_complete_(false),\n+          has_1xx_headers_(false), created_filter_chain_(false), is_head_request_(false),\n+          is_grpc_request_(false), non_100_response_headers_encoded_(false),\n+          under_on_local_reply_(false), decoder_filter_chain_aborted_(false),\n+          encoder_filter_chain_aborted_(false), saw_downstream_reset_(false) {}\n     uint32_t filter_call_state_{0};\n \n-    bool remote_complete_ : 1;\n+    bool remote_encode_complete_ : 1;\n+    bool remote_decode_complete_ : 1;\n     bool local_complete_ : 1; // This indicates that local is complete prior to filter processing.\n                               // A filter can still stop the stream from being complete as seen\n                               // by the codec."
        },
        {
          "filename": "test/integration/BUILD",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -517,6 +517,7 @@ envoy_cc_test_library(\n         \"//source/extensions/filters/http/buffer:config\",\n         \"//test/common/http/http2:http2_frame\",\n         \"//test/integration/filters:add_invalid_data_filter_lib\",\n+        \"//test/integration/filters:buffer_continue_filter_lib\",\n         \"//test/integration/filters:continue_after_local_reply_filter_lib\",\n         \"//test/integration/filters:continue_headers_only_inject_body\",\n         \"//test/integration/filters:encoder_decoder_buffer_filter_lib\","
        },
        {
          "filename": "test/integration/filters/BUILD",
          "status": "modified",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -545,6 +545,20 @@ envoy_cc_test_library(\n     ],\n )\n \n+envoy_cc_test_library(\n+    name = \"buffer_continue_filter_lib\",\n+    srcs = [\n+        \"buffer_continue_filter.cc\",\n+    ],\n+    deps = [\n+        \"//envoy/http:filter_interface\",\n+        \"//envoy/registry\",\n+        \"//envoy/server:filter_config_interface\",\n+        \"//source/extensions/filters/http/common:pass_through_filter_lib\",\n+        \"//test/extensions/filters/http/common:empty_http_filter_config_lib\",\n+    ],\n+)\n+\n envoy_cc_test_library(\n     name = \"test_socket_interface_lib\",\n     srcs = ["
        },
        {
          "filename": "test/integration/filters/buffer_continue_filter.cc",
          "status": "added",
          "additions": 74,
          "deletions": 0,
          "patch": "@@ -0,0 +1,74 @@\n+#include <string>\n+\n+#include \"envoy/http/filter.h\"\n+#include \"envoy/registry/registry.h\"\n+#include \"envoy/server/filter_config.h\"\n+\n+#include \"source/extensions/filters/http/common/pass_through_filter.h\"\n+\n+#include \"test/extensions/filters/http/common/empty_http_filter_config.h\"\n+\n+namespace Envoy {\n+\n+// A filter that buffers until the limit is reached and then continues.\n+class BufferContinueStreamFilter : public Http::PassThroughFilter {\n+public:\n+  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap&, bool end_stream) override {\n+    return end_stream ? Http::FilterHeadersStatus::Continue\n+                      : Http::FilterHeadersStatus::StopIteration;\n+  }\n+\n+  Http::FilterDataStatus decodeData(Buffer::Instance&, bool end_stream) override {\n+    return end_stream ? Http::FilterDataStatus::Continue\n+                      : Http::FilterDataStatus::StopIterationAndBuffer;\n+  }\n+\n+  Http::FilterHeadersStatus encodeHeaders(Http::ResponseHeaderMap& headers, bool) override {\n+    response_headers_ = &headers;\n+    return Http::FilterHeadersStatus::StopIteration;\n+  }\n+\n+  Http::FilterDataStatus encodeData(Buffer::Instance& data, bool end_stream) override {\n+    data_total_ += data.length();\n+\n+    const auto limit = encoder_callbacks_->encoderBufferLimit();\n+    const auto header_size = response_headers_->byteSize();\n+\n+    if (limit && header_size + data_total_ > limit) {\n+      // Give up since we've reached the buffer limit, Envoy should generate\n+      // a 500 since it couldn't finished encoding.\n+      return Http::FilterDataStatus::Continue;\n+    }\n+\n+    encoder_callbacks_->addEncodedData(data, false);\n+\n+    if (!end_stream) {\n+      return Http::FilterDataStatus::StopIterationAndBuffer;\n+    }\n+\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+private:\n+  Http::ResponseHeaderMap* response_headers_;\n+  uint64_t data_total_{0};\n+};\n+\n+class BufferContinueFilterConfig : public Extensions::HttpFilters::Common::EmptyHttpFilterConfig {\n+public:\n+  BufferContinueFilterConfig() : EmptyHttpFilterConfig(\"buffer-continue-filter\") {}\n+\n+  Http::FilterFactoryCb createFilter(const std::string&,\n+                                     Server::Configuration::FactoryContext&) override {\n+    return [](Http::FilterChainFactoryCallbacks& callbacks) -> void {\n+      callbacks.addStreamFilter(std::make_shared<::Envoy::BufferContinueStreamFilter>());\n+    };\n+  }\n+};\n+\n+// perform static registration\n+static Registry::RegisterFactory<BufferContinueFilterConfig,\n+                                 Server::Configuration::NamedHttpFilterConfigFactory>\n+    register_;\n+\n+} // namespace Envoy"
        },
        {
          "filename": "test/integration/protocol_integration_test.cc",
          "status": "modified",
          "additions": 52,
          "deletions": 0,
          "patch": "@@ -3450,6 +3450,58 @@ TEST_P(ProtocolIntegrationTest, FragmentStrippedFromPathWithOverride) {\n   EXPECT_EQ(\"200\", response->headers().getStatusValue());\n }\n \n+// Test buffering and then continuing after too many response bytes to buffer.\n+TEST_P(ProtocolIntegrationTest, BufferContinue) {\n+  // Bytes sent is configured for http/2 flow control windows.\n+  if (upstreamProtocol() != Http::CodecType::HTTP2) {\n+    return;\n+  }\n+  config_helper_.addConfigModifier(\n+      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n+              hcm) -> void {\n+        auto* route_config = hcm.mutable_route_config();\n+        auto* virtual_host = route_config->mutable_virtual_hosts(0);\n+        auto* header = virtual_host->mutable_response_headers_to_add()->Add()->mutable_header();\n+        header->set_key(\"foo\");\n+        header->set_value(\"bar\");\n+      });\n+\n+  useAccessLog();\n+  config_helper_.addFilter(\"{ name: buffer-continue-filter, typed_config: { \\\"@type\\\": \"\n+                           \"type.googleapis.com/google.protobuf.Empty } }\");\n+  config_helper_.setBufferLimits(1024, 1024);\n+  initialize();\n+\n+  // Send the request.\n+  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n+  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n+  auto downstream_request = &encoder_decoder.first;\n+  auto response = std::move(encoder_decoder.second);\n+  Buffer::OwnedImpl data(\"HTTP body content goes here\");\n+  codec_client_->sendData(*downstream_request, data, true);\n+  waitForNextUpstreamRequest();\n+\n+  // Send the response headers.\n+  upstream_request_->encodeHeaders(default_response_headers_, false);\n+\n+  // Now send an overly large response body. At some point, too much data will\n+  // be buffered, the stream will be reset, and the connection will disconnect.\n+  upstream_request_->encodeData(512, false);\n+  upstream_request_->encodeData(1024 * 100, false);\n+\n+  if (upstreamProtocol() == Http::CodecType::HTTP1) {\n+    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n+  } else {\n+    ASSERT_TRUE(upstream_request_->waitForReset());\n+    ASSERT_TRUE(fake_upstream_connection_->close());\n+    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n+  }\n+\n+  ASSERT_TRUE(response->waitForEndStream());\n+  EXPECT_TRUE(response->complete());\n+  EXPECT_EQ(\"500\", response->headers().getStatusValue());\n+}\n+\n TEST_P(DownstreamProtocolIntegrationTest, ContentLengthSmallerThanPayload) {\n   initialize();\n   codec_client_ = makeHttpConnection(lookupPort(\"http\"));"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "03cb8d59f80a2a75d9e1289c909e5979a79ace91",
            "date": "2025-01-13T06:31:54Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "3487b225f48717dd5a2babb5f921df4353633cee",
            "date": "2025-01-13T06:10:11Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "acdcfc6ac262ee4087a652532b93922550efb061",
            "date": "2025-01-10T07:01:57Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "02633ec5db8d6a3f24fa6752dff36b4fb5f0800e",
            "date": "2025-01-10T07:02:42Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "e62004f8710e90e255495ae44caab1a778f01b9e",
            "date": "2025-01-10T07:03:28Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:N/I:L/A:L",
    "cwe_id": "CWE-416",
    "description": "Envoy is an open source edge and service proxy, designed for cloud-native applications. Sending a locally generated response must stop further processing of request or response data. Envoy tracks the amount of buffered request and response data and aborts the request if the amount of buffered data is over the limit by sending 413 or 500 responses. However when the buffer overflows while response is processed by the filter chain the operation may not be aborted correctly and result in accessing a freed memory block. If this happens Envoy will crash resulting in a denial of service.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-02-22T23:15:10.890",
    "last_modified": "2024-11-21T06:29:52.517",
    "fix_date": "2022-02-01T19:50:04Z"
  },
  "references": [
    {
      "url": "https://github.com/envoyproxy/envoy/commit/148de954ed3585d8b4298b424aa24916d0de6136",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-h69p-g6xg-mhhh",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/commit/148de954ed3585d8b4298b424aa24916d0de6136",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-h69p-g6xg-mhhh",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:59.740278",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "envoy",
    "owner": "envoyproxy",
    "created_at": "2016-08-08T15:07:24Z",
    "updated_at": "2025-01-14T12:22:22Z",
    "pushed_at": "2025-01-14T05:36:17Z",
    "size": 240648,
    "stars": 25321,
    "forks": 4848,
    "open_issues": 1639,
    "watchers": 25321,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C++": 48293036,
      "Starlark": 3105942,
      "Java": 1320095,
      "Python": 605206,
      "Assembly": 327095,
      "Kotlin": 309606,
      "Swift": 250537,
      "Shell": 229801,
      "Go": 183281,
      "Rust": 107190,
      "JavaScript": 66339,
      "C": 61597,
      "Objective-C++": 55490,
      "Objective-C": 48840,
      "Jinja": 47798,
      "Smarty": 3528,
      "CSS": 2927,
      "HTML": 1522,
      "Emacs Lisp": 966,
      "Dockerfile": 960,
      "Thrift": 748,
      "PureBasic": 472,
      "Batchfile": 439,
      "Makefile": 303
    },
    "commit_activity": {
      "total_commits_last_year": 3286,
      "avg_commits_per_week": 63.19230769230769,
      "days_active_last_year": 303
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:55:59.245540"
  }
}