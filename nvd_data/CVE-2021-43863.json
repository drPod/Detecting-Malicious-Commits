{
  "cve_id": "CVE-2021-43863",
  "github_data": {
    "repository": "nextcloud/android",
    "fix_commit": "627caba60e69e223b0fc89c4cb18eaa76a95db95",
    "related_commits": [
      "627caba60e69e223b0fc89c4cb18eaa76a95db95",
      "627caba60e69e223b0fc89c4cb18eaa76a95db95"
    ],
    "patch_url": "https://github.com/nextcloud/android/commit/627caba60e69e223b0fc89c4cb18eaa76a95db95.patch",
    "fix_commit_details": {
      "sha": "627caba60e69e223b0fc89c4cb18eaa76a95db95",
      "commit_date": "2021-12-22T08:51:11Z",
      "author": {
        "login": "AlvaroBrey",
        "type": "User",
        "stats": {
          "total_commits": 1464,
          "average_weekly_commits": 2.0884450784593436,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 79
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-vjp2-f63v-w479",
        "length": 106,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 646,
        "additions": 593,
        "deletions": 53
      },
      "files": [
        {
          "filename": "src/androidTest/java/com/owncloud/android/providers/FileContentProviderVerificationIT.kt",
          "status": "added",
          "additions": 115,
          "deletions": 0,
          "patch": "@@ -0,0 +1,115 @@\n+/*\n+ *\n+ * Nextcloud Android client application\n+ *\n+ * @author Tobias Kaminsky\n+ * Copyright (C) 2021 Tobias Kaminsky\n+ * Copyright (C) 2021 Nextcloud GmbH\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program. If not, see <https://www.gnu.org/licenses/>.\n+ */\n+package com.owncloud.android.providers\n+\n+import java.lang.IllegalArgumentException\n+import com.owncloud.android.db.ProviderMeta\n+import android.content.ContentValues\n+import com.owncloud.android.utils.MimeTypeUtil\n+import org.junit.Test\n+\n+@Suppress(\"FunctionNaming\")\n+class FileContentProviderVerificationIT {\n+\n+    companion object {\n+        private const val INVALID_COLUMN = \"Invalid column\"\n+        private const val FILE_LENGTH = 120\n+    }\n+\n+    @Test(expected = IllegalArgumentException::class)\n+    fun verifyColumnName_Exception() {\n+        FileContentProvider.VerificationUtils.verifyColumnName(INVALID_COLUMN)\n+    }\n+\n+    @Test\n+    fun verifyColumnName_OK() {\n+        FileContentProvider.VerificationUtils.verifyColumnName(ProviderMeta.ProviderTableMeta.FILE_NAME)\n+    }\n+\n+    @Test\n+    fun verifyColumn_ContentValues_OK() {\n+        // with valid columns\n+        val contentValues = ContentValues()\n+        contentValues.put(ProviderMeta.ProviderTableMeta.FILE_CONTENT_LENGTH, FILE_LENGTH)\n+        contentValues.put(ProviderMeta.ProviderTableMeta.FILE_CONTENT_TYPE, MimeTypeUtil.MIMETYPE_TEXT_MARKDOWN)\n+        FileContentProvider.VerificationUtils.verifyColumns(contentValues)\n+\n+        // empty\n+        FileContentProvider.VerificationUtils.verifyColumns(ContentValues())\n+    }\n+\n+    @Test(expected = IllegalArgumentException::class)\n+    fun verifyColumn_ContentValues_invalidColumn() {\n+        // with invalid columns\n+        val contentValues = ContentValues()\n+        contentValues.put(INVALID_COLUMN, FILE_LENGTH)\n+        contentValues.put(ProviderMeta.ProviderTableMeta.FILE_CONTENT_TYPE, MimeTypeUtil.MIMETYPE_TEXT_MARKDOWN)\n+        FileContentProvider.VerificationUtils.verifyColumns(contentValues)\n+    }\n+\n+    @Test\n+    fun verifySortOrder_OK() {\n+        // null\n+        FileContentProvider.VerificationUtils.verifySortOrder(null)\n+\n+        // empty\n+        FileContentProvider.VerificationUtils.verifySortOrder(\"\")\n+\n+        // valid sort\n+        FileContentProvider.VerificationUtils.verifySortOrder(ProviderMeta.ProviderTableMeta.FILE_DEFAULT_SORT_ORDER)\n+    }\n+\n+    @Test(expected = IllegalArgumentException::class)\n+    fun verifySortOrder_InvalidColumn() {\n+        // with invalid column\n+        FileContentProvider.VerificationUtils.verifySortOrder(\"$INVALID_COLUMN desc\")\n+    }\n+\n+    @Test(expected = IllegalArgumentException::class)\n+    fun verifySortOrder_InvalidGrammar() {\n+        // with invalid grammar\n+        FileContentProvider.VerificationUtils.verifySortOrder(\"${ProviderMeta.ProviderTableMeta._ID} ;--foo\")\n+    }\n+\n+    @Test\n+    fun verifyWhere_OK() {\n+        FileContentProvider.VerificationUtils.verifyWhere(null)\n+        FileContentProvider.VerificationUtils.verifyWhere(\n+            \"${ProviderMeta.ProviderTableMeta._ID}=? AND ${ProviderMeta.ProviderTableMeta.FILE_ACCOUNT_OWNER}=?\"\n+        )\n+        FileContentProvider.VerificationUtils.verifyWhere(\n+            \"${ProviderMeta.ProviderTableMeta._ID} = 1\" +\n+                \" AND (1 = 1)\" +\n+                \" AND ${ProviderMeta.ProviderTableMeta.FILE_ACCOUNT_OWNER} LIKE ?\"\n+        )\n+    }\n+\n+    @Test(expected = IllegalArgumentException::class)\n+    fun verifyWhere_InvalidColumnName() {\n+        FileContentProvider.VerificationUtils.verifyWhere(\"$INVALID_COLUMN= ?\")\n+    }\n+\n+    @Test(expected = IllegalArgumentException::class)\n+    fun verifyWhere_InvalidGrammar() {\n+        FileContentProvider.VerificationUtils.verifyWhere(\"1=1 -- SELECT * FROM\")\n+    }\n+}"
        },
        {
          "filename": "src/main/java/com/owncloud/android/datamodel/ExternalLinksProvider.java",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -76,7 +76,9 @@ public long storeExternalLink(ExternalLink externalLink) {\n      * @return numbers of rows deleted\n      */\n     public int deleteAllExternalLinks() {\n-        return mContentResolver.delete(ProviderMeta.ProviderTableMeta.CONTENT_URI_EXTERNAL_LINKS, \" 1 = 1 \", null);\n+        return mContentResolver.delete(ProviderMeta.ProviderTableMeta.CONTENT_URI_EXTERNAL_LINKS,\n+                                       null,\n+                                       null);\n     }\n \n     /**"
        },
        {
          "filename": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -564,6 +564,10 @@ public boolean removeFile(OCFile ocFile, boolean removeDBData, boolean removeLoc\n                     // \"\"+file.getFileId());\n                     Uri file_uri = ContentUris.withAppendedId(ProviderTableMeta.CONTENT_URI_FILE, ocFile.getFileId());\n                     String where = ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \"=?\";\n+\n+                    // TODO switch to string array with fixed keys in it\n+                    // file_owner = ? and path =?\n+                    // String[] { \"file_owner\",  \"path\"}\n                     String[] whereArgs = new String[]{account.name, ocFile.getRemotePath()};\n                     int deleted = 0;\n                     if (getContentProviderClient() != null) {\n@@ -911,7 +915,7 @@ private List<OCFile> getFolderContent(long parentId, boolean onlyOnDevice) {\n                 ProviderTableMeta.FILE_PARENT + \"=?\",\n                 new String[]{String.valueOf(parentId)},\n                 null\n-            );\n+                                               );\n         }\n \n         if (cursor != null) {"
        },
        {
          "filename": "src/main/java/com/owncloud/android/datamodel/SyncedFolderProvider.java",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -112,12 +112,12 @@ public int countEnabledSyncedFolders() {\n      */\n     public List<SyncedFolder> getSyncedFolders() {\n         Cursor cursor = mContentResolver.query(\n-                ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n-                null,\n-                \"1=1\",\n-                null,\n-                null\n-        );\n+            ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n+            null,\n+            null,\n+            null,\n+            null\n+                                              );\n \n         if (cursor != null) {\n             List<SyncedFolder> list = new ArrayList<>(cursor.getCount());"
        },
        {
          "filename": "src/main/java/com/owncloud/android/db/ProviderMeta.java",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -122,16 +122,19 @@ static public class ProviderTableMeta implements BaseColumns {\n             _ID,\n             FILE_PARENT,\n             FILE_NAME,\n+            FILE_ENCRYPTED_NAME,\n             FILE_CREATION,\n             FILE_MODIFIED,\n             FILE_MODIFIED_AT_LAST_SYNC_FOR_DATA,\n             FILE_CONTENT_LENGTH,\n             FILE_CONTENT_TYPE,\n             FILE_STORAGE_PATH,\n             FILE_PATH,\n+            FILE_PATH_DECRYPTED,\n             FILE_ACCOUNT_OWNER,\n             FILE_LAST_SYNC_DATE,\n             FILE_LAST_SYNC_DATE_FOR_DATA,\n+            FILE_KEEP_IN_SYNC,\n             FILE_ETAG,\n             FILE_ETAG_ON_SERVER,\n             FILE_SHARED_VIA_LINK,\n@@ -146,6 +149,9 @@ static public class ProviderTableMeta implements BaseColumns {\n             FILE_MOUNT_TYPE,\n             FILE_HAS_PREVIEW,\n             FILE_UNREAD_COMMENTS_COUNT,\n+            FILE_OWNER_ID,\n+            FILE_OWNER_DISPLAY_NAME,\n+            FILE_NOTE,\n             FILE_SHAREES,\n             FILE_RICH_WORKSPACE));\n "
        },
        {
          "filename": "src/main/java/com/owncloud/android/providers/FileContentProvider.java",
          "status": "modified",
          "additions": 166,
          "deletions": 45,
          "patch": "@@ -64,7 +64,11 @@\n import javax.inject.Inject;\n \n import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n import dagger.android.AndroidInjection;\n+import third_parties.aosp.SQLiteTokenizer;\n+\n \n /**\n  * The ContentProvider for the ownCloud App.\n@@ -125,6 +129,14 @@ private int delete(SQLiteDatabase db, Uri uri, String where, String... whereArgs\n             return -1;\n         }\n \n+        // verify where for public paths\n+        switch (mUriMatcher.match(uri)) {\n+            case ROOT_DIRECTORY:\n+            case SINGLE_FILE:\n+            case DIRECTORY:\n+                VerificationUtils.verifyWhere(where);\n+        }\n+\n         int count;\n         switch (mUriMatcher.match(uri)) {\n             case SINGLE_FILE:\n@@ -169,7 +181,6 @@ private int delete(SQLiteDatabase db, Uri uri, String where, String... whereArgs\n \n     private int deleteDirectory(SQLiteDatabase db, Uri uri, String where, String... whereArgs) {\n         int count = 0;\n-\n         Cursor children = query(uri, null, null, null, null);\n         if (children != null) {\n             if (children.moveToFirst()) {\n@@ -194,9 +205,7 @@ private int deleteDirectory(SQLiteDatabase db, Uri uri, String where, String...\n         }\n \n         if (uri.getPathSegments().size() > MINIMUM_PATH_SEGMENTS_SIZE) {\n-            count += db.delete(ProviderTableMeta.FILE_TABLE_NAME,\n-                               ProviderTableMeta._ID + \"=\" + uri.getPathSegments().get(1)\n-                                   + (!TextUtils.isEmpty(where) ? \" AND (\" + where + \")\" : \"\"), whereArgs);\n+            count += deleteWithuri(db, uri, where, whereArgs);\n         }\n \n         return count;\n@@ -215,9 +224,7 @@ private int deleteSingleFile(SQLiteDatabase db, Uri uri, String where, String...\n             if (remoteId == null) {\n                 return 0;\n             } else {\n-                count = db.delete(ProviderTableMeta.FILE_TABLE_NAME,\n-                                  ProviderTableMeta._ID + \"=\" + uri.getPathSegments().get(1)\n-                                      + (!TextUtils.isEmpty(where) ? \" AND (\" + where + \")\" : \"\"), whereArgs);\n+                count = deleteWithuri(db, uri, where, whereArgs);\n             }\n         } catch (Exception e) {\n             Log_OC.d(TAG, \"DB-Error removing file!\", e);\n@@ -230,6 +237,13 @@ private int deleteSingleFile(SQLiteDatabase db, Uri uri, String where, String...\n         return count;\n     }\n \n+    private int deleteWithuri(SQLiteDatabase db, Uri uri, String where, String[] whereArgs) {\n+        final String[] argsWithUri = VerificationUtils.prependUriFirstSegmentToSelectionArgs(whereArgs, uri);\n+        return db.delete(ProviderTableMeta.FILE_TABLE_NAME,\n+                         ProviderTableMeta._ID + \"=?\"\n+                             + (!TextUtils.isEmpty(where) ? \" AND (\" + where + \")\" : \"\"), argsWithUri);\n+    }\n+\n     @Override\n     public String getType(@NonNull Uri uri) {\n         switch (mUriMatcher.match(uri)) {\n@@ -262,6 +276,16 @@ public Uri insert(@NonNull Uri uri, ContentValues values) {\n     }\n \n     private Uri insert(SQLiteDatabase db, Uri uri, ContentValues values) {\n+        // verify only for those requests that are not internal (files table)\n+        switch (mUriMatcher.match(uri)) {\n+            case ROOT_DIRECTORY:\n+            case SINGLE_FILE:\n+            case DIRECTORY:\n+                VerificationUtils.verifyColumns(values);\n+                break;\n+        }\n+\n+\n         switch (mUriMatcher.match(uri)) {\n             case ROOT_DIRECTORY:\n             case SINGLE_FILE:\n@@ -483,81 +507,66 @@ public Cursor query(@NonNull Uri uri, String[] projection, String selection, Str\n         return result;\n     }\n \n-    private Cursor query(SQLiteDatabase db, Uri uri, String[] projectionArray, String selection, String[] selectionArgs,\n+    private Cursor query(SQLiteDatabase db,\n+                         Uri uri,\n+                         String[] projectionArray,\n+                         String selection,\n+                         String[] selectionArgs,\n                          String sortOrder) {\n \n+        // verify only for those requests that are not internal\n+        final int uriMatch = mUriMatcher.match(uri);\n+\n         SQLiteQueryBuilder sqlQuery = new SQLiteQueryBuilder();\n \n-        sqlQuery.setTables(ProviderTableMeta.FILE_TABLE_NAME);\n \n-        switch (mUriMatcher.match(uri)) {\n+        switch (uriMatch) {\n             case ROOT_DIRECTORY:\n-                break;\n             case DIRECTORY:\n-                if (uri.getPathSegments().size() > SINGLE_PATH_SEGMENT) {\n-                    sqlQuery.appendWhere(ProviderTableMeta.FILE_PARENT + \"=\" + uri.getPathSegments().get(1));\n-                }\n-                break;\n             case SINGLE_FILE:\n-                if (uri.getPathSegments().size() > SINGLE_PATH_SEGMENT) {\n-                    sqlQuery.appendWhere(ProviderTableMeta._ID + \"=\" + uri.getPathSegments().get(1));\n-                }\n+                VerificationUtils.verifyWhere(selection); // prevent injection in public paths\n+                sqlQuery.setTables(ProviderTableMeta.FILE_TABLE_NAME);\n                 break;\n             case SHARES:\n                 sqlQuery.setTables(ProviderTableMeta.OCSHARES_TABLE_NAME);\n-                if (uri.getPathSegments().size() > SINGLE_PATH_SEGMENT) {\n-                    sqlQuery.appendWhere(ProviderTableMeta._ID + \"=\" + uri.getPathSegments().get(1));\n-                }\n                 break;\n             case CAPABILITIES:\n                 sqlQuery.setTables(ProviderTableMeta.CAPABILITIES_TABLE_NAME);\n-                if (uri.getPathSegments().size() > SINGLE_PATH_SEGMENT) {\n-                    sqlQuery.appendWhere(ProviderTableMeta._ID + \"=\" + uri.getPathSegments().get(1));\n-                }\n                 break;\n             case UPLOADS:\n                 sqlQuery.setTables(ProviderTableMeta.UPLOADS_TABLE_NAME);\n-                if (uri.getPathSegments().size() > SINGLE_PATH_SEGMENT) {\n-                    sqlQuery.appendWhere(ProviderTableMeta._ID + \"=\" + uri.getPathSegments().get(1));\n-                }\n                 break;\n             case SYNCED_FOLDERS:\n                 sqlQuery.setTables(ProviderTableMeta.SYNCED_FOLDERS_TABLE_NAME);\n-                if (uri.getPathSegments().size() > SINGLE_PATH_SEGMENT) {\n-                    sqlQuery.appendWhere(ProviderTableMeta._ID + \"=\" + uri.getPathSegments().get(1));\n-                }\n                 break;\n             case EXTERNAL_LINKS:\n                 sqlQuery.setTables(ProviderTableMeta.EXTERNAL_LINKS_TABLE_NAME);\n-                if (uri.getPathSegments().size() > SINGLE_PATH_SEGMENT) {\n-                    sqlQuery.appendWhere(ProviderTableMeta._ID + \"=\" + uri.getPathSegments().get(1));\n-                }\n                 break;\n             case ARBITRARY_DATA:\n                 sqlQuery.setTables(ProviderTableMeta.ARBITRARY_DATA_TABLE_NAME);\n-                if (uri.getPathSegments().size() > SINGLE_PATH_SEGMENT) {\n-                    sqlQuery.appendWhere(ProviderTableMeta._ID + \"=\" + uri.getPathSegments().get(1));\n-                }\n                 break;\n             case VIRTUAL:\n                 sqlQuery.setTables(ProviderTableMeta.VIRTUAL_TABLE_NAME);\n-                if (uri.getPathSegments().size() > SINGLE_PATH_SEGMENT) {\n-                    sqlQuery.appendWhere(ProviderTableMeta._ID + \"=\" + uri.getPathSegments().get(1));\n-                }\n                 break;\n             case FILESYSTEM:\n                 sqlQuery.setTables(ProviderTableMeta.FILESYSTEM_TABLE_NAME);\n-                if (uri.getPathSegments().size() > SINGLE_PATH_SEGMENT) {\n-                    sqlQuery.appendWhere(ProviderTableMeta._ID + \"=\" + uri.getPathSegments().get(1));\n-                }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Unknown uri id: \" + uri);\n         }\n \n+\n+        // add ID to arguments if Uri has more than one segment\n+        if (uriMatch != ROOT_DIRECTORY && uri.getPathSegments().size() > SINGLE_PATH_SEGMENT ) {\n+            String idColumn = uriMatch == DIRECTORY ? ProviderTableMeta.FILE_PARENT : ProviderTableMeta._ID;\n+            sqlQuery.appendWhere(idColumn + \"=?\");\n+            selectionArgs = VerificationUtils.prependUriFirstSegmentToSelectionArgs(selectionArgs, uri);\n+        }\n+\n+\n         String order;\n         if (TextUtils.isEmpty(sortOrder)) {\n-            switch (mUriMatcher.match(uri)) {\n+            switch (uriMatch) {\n                 case SHARES:\n                     order = ProviderTableMeta.OCSHARES_DEFAULT_SORT_ORDER;\n                     break;\n@@ -587,15 +596,18 @@ private Cursor query(SQLiteDatabase db, Uri uri, String[] projectionArray, Strin\n                     break;\n             }\n         } else {\n+            if (uriMatch == ROOT_DIRECTORY || uriMatch == SINGLE_FILE || uriMatch == DIRECTORY) {\n+                VerificationUtils.verifySortOrder(sortOrder);\n+            }\n             order = sortOrder;\n         }\n \n         // DB case_sensitive\n         db.execSQL(\"PRAGMA case_sensitive_like = true\");\n \n         // only file list is accessible via content provider, so only this has to be protected with projectionMap\n-        if ((mUriMatcher.match(uri) == ROOT_DIRECTORY || mUriMatcher.match(uri) == SINGLE_FILE ||\n-            mUriMatcher.match(uri) == DIRECTORY) && projectionArray != null) {\n+        if ((uriMatch == ROOT_DIRECTORY || uriMatch == SINGLE_FILE ||\n+            uriMatch == DIRECTORY) && projectionArray != null) {\n             HashMap<String, String> projectionMap = new HashMap<>();\n \n             for (String projection : ProviderTableMeta.FILE_ALL_COLUMNS) {\n@@ -637,6 +649,15 @@ public int update(@NonNull Uri uri, ContentValues values, String selection, Stri\n     }\n \n     private int update(SQLiteDatabase db, Uri uri, ContentValues values, String selection, String... selectionArgs) {\n+        // verify contentValues and selection for public paths to prevent injection\n+        switch (mUriMatcher.match(uri)) {\n+            case ROOT_DIRECTORY:\n+            case SINGLE_FILE:\n+            case DIRECTORY:\n+                VerificationUtils.verifyColumns(values);\n+                VerificationUtils.verifyWhere(selection);\n+        }\n+\n         switch (mUriMatcher.match(uri)) {\n             case DIRECTORY:\n                 return 0;\n@@ -1034,6 +1055,106 @@ private boolean isCallerNotAllowed(Uri uri) {\n         }\n     }\n \n+\n+    static class VerificationUtils {\n+\n+        private static boolean isValidColumnName(@NonNull String columnName) {\n+            return ProviderTableMeta.FILE_ALL_COLUMNS.contains(columnName);\n+        }\n+\n+        @VisibleForTesting\n+        public static void verifyColumns(@Nullable ContentValues contentValues) {\n+            if (contentValues == null || contentValues.keySet().size() == 0) {\n+                return;\n+            }\n+\n+            for (String name : contentValues.keySet()) {\n+                verifyColumnName(name);\n+            }\n+        }\n+\n+        @VisibleForTesting\n+        public static void verifyColumnName(@NonNull String columnName) {\n+            if (!isValidColumnName(columnName)) {\n+                throw new IllegalArgumentException(String.format(\"Column name \\\"%s\\\" is not allowed\", columnName));\n+            }\n+        }\n+\n+        public static String[] prependUriFirstSegmentToSelectionArgs(@Nullable final String[] originalArgs, final Uri uri) {\n+            String[] args;\n+            if (originalArgs == null) {\n+                args = new String[1];\n+            } else {\n+                args = new String[originalArgs.length + 1];\n+                System.arraycopy(originalArgs, 0, args, 1, originalArgs.length);\n+            }\n+            args[0] = uri.getPathSegments().get(1);\n+            return args;\n+        }\n+\n+        public static void verifySortOrder(@Nullable String sortOrder) {\n+            if (sortOrder == null) {\n+                return;\n+            }\n+            SQLiteTokenizer.tokenize(sortOrder, SQLiteTokenizer.OPTION_NONE, VerificationUtils::verifySortToken);\n+        }\n+\n+        private static void verifySortToken(String token){\n+            // accept empty tokens and valid column names\n+            if (TextUtils.isEmpty(token) || isValidColumnName(token)) {\n+                return;\n+            }\n+            // accept only a small subset of keywords\n+            if(SQLiteTokenizer.isKeyword(token)){\n+                switch (token.toUpperCase(Locale.ROOT)) {\n+                    case \"ASC\":\n+                    case \"DESC\":\n+                    case \"COLLATE\":\n+                    case \"NOCASE\":\n+                        return;\n+                }\n+            }\n+            // if none of the above, invalid token\n+            throw new IllegalArgumentException(\"Invalid token \" + token);\n+        }\n+\n+        public static void verifyWhere(@Nullable String where) {\n+            if (where == null) {\n+                return;\n+            }\n+            SQLiteTokenizer.tokenize(where, SQLiteTokenizer.OPTION_NONE, VerificationUtils::verifyWhereToken);\n+        }\n+\n+        private static void verifyWhereToken(String token) {\n+            // allow empty, valid column names, functions (min,max,count) and types\n+            if (TextUtils.isEmpty(token) || isValidColumnName(token)\n+                || SQLiteTokenizer.isFunction(token) || SQLiteTokenizer.isType(token)) {\n+                return;\n+            }\n+\n+            // Disallow dangerous keywords, allow others\n+            if (SQLiteTokenizer.isKeyword(token)) {\n+                switch (token.toUpperCase(Locale.ROOT)) {\n+                    case \"SELECT\":\n+                    case \"FROM\":\n+                    case \"WHERE\":\n+                    case \"GROUP\":\n+                    case \"HAVING\":\n+                    case \"WINDOW\":\n+                    case \"VALUES\":\n+                    case \"ORDER\":\n+                    case \"LIMIT\":\n+                        throw new IllegalArgumentException(\"Invalid token \" + token);\n+                    default:\n+                        return;\n+                }\n+            }\n+\n+            // if none of the above: invalid token\n+            throw new IllegalArgumentException(\"Invalid token \" + token);\n+        }\n+    }\n+\n     class DataBaseHelper extends SQLiteOpenHelper {\n         DataBaseHelper(Context context) {\n             super(context, ProviderMeta.DB_NAME, null, ProviderMeta.DB_VERSION);"
        },
        {
          "filename": "src/main/java/third_parties/aosp/SQLiteTokenizer.java",
          "status": "added",
          "additions": 292,
          "deletions": 0,
          "patch": "@@ -0,0 +1,292 @@\n+package third_parties.aosp;\n+\n+/*\n+ * Copyright (C) 2019 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.core.util.Consumer;\n+\n+/**\n+ * SQL Tokenizer specialized to extract tokens from SQL (snippets).\n+ *\n+ * Originally from AOSP: https://github.com/aosp-mirror/platform_frameworks_base/blob/0e66ea6f3221aa8ccbb78ce38fbcaa67d8ea94f9/core/java/android/database/sqlite/SQLiteQueryBuilder.java\n+ * Backported to be usable with AndroidX under api 24.\n+ */\n+public class SQLiteTokenizer {\n+    private static boolean isAlpha(char ch) {\n+        return ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z') || (ch == '_');\n+    }\n+\n+    private static boolean isNum(char ch) {\n+        return ('0' <= ch && ch <= '9');\n+    }\n+\n+    private static boolean isAlNum(char ch) {\n+        return isAlpha(ch) || isNum(ch);\n+    }\n+\n+    private static boolean isAnyOf(char ch, String set) {\n+        return set.indexOf(ch) >= 0;\n+    }\n+\n+    private static IllegalArgumentException genException(String message, String sql) {\n+        throw new IllegalArgumentException(message + \" in '\" + sql + \"'\");\n+    }\n+\n+    private static char peek(String s, int index) {\n+        return index < s.length() ? s.charAt(index) : '\\0';\n+    }\n+\n+    public static final int OPTION_NONE = 0;\n+\n+    /**\n+     * Require that SQL contains only tokens; any comments or values will result\n+     * in an exception.\n+     */\n+    public static final int OPTION_TOKEN_ONLY = 1 << 0;\n+\n+    /**\n+     * Tokenize the given SQL, returning the list of each encountered token.\n+     *\n+     * @throws IllegalArgumentException if invalid SQL is encountered.\n+     */\n+    public static List<String> tokenize(@Nullable String sql, int options) {\n+        final ArrayList<String> res = new ArrayList<>();\n+        tokenize(sql, options, res::add);\n+        return res;\n+    }\n+\n+    /**\n+     * Tokenize the given SQL, sending each encountered token to the given\n+     * {@link Consumer}.\n+     *\n+     * @throws IllegalArgumentException if invalid SQL is encountered.\n+     */\n+    public static void tokenize(@Nullable String sql, int options, Consumer<String> checker) {\n+        if (sql == null) {\n+            return;\n+        }\n+        int pos = 0;\n+        final int len = sql.length();\n+        while (pos < len) {\n+            final char ch = peek(sql, pos);\n+\n+            // Regular token.\n+            if (isAlpha(ch)) {\n+                final int start = pos;\n+                pos++;\n+                while (isAlNum(peek(sql, pos))) {\n+                    pos++;\n+                }\n+                final int end = pos;\n+\n+                final String token = sql.substring(start, end);\n+                checker.accept(token);\n+\n+                continue;\n+            }\n+\n+            // Handle quoted tokens\n+            if (isAnyOf(ch, \"'\\\"`\")) {\n+                final int quoteStart = pos;\n+                pos++;\n+\n+                for (;;) {\n+                    pos = sql.indexOf(ch, pos);\n+                    if (pos < 0) {\n+                        throw genException(\"Unterminated quote\", sql);\n+                    }\n+                    if (peek(sql, pos + 1) != ch) {\n+                        break;\n+                    }\n+                    // Quoted quote char -- e.g. \"abc\"\"def\" is a single string.\n+                    pos += 2;\n+                }\n+                final int quoteEnd = pos;\n+                pos++;\n+\n+                if (ch != '\\'') {\n+                    // Extract the token\n+                    final String tokenUnquoted = sql.substring(quoteStart + 1, quoteEnd);\n+\n+                    final String token;\n+\n+                    // Unquote if needed. i.e. \"aa\"\"bb\" -> aa\"bb\n+                    if (tokenUnquoted.indexOf(ch) >= 0) {\n+                        token = tokenUnquoted.replaceAll(\n+                            String.valueOf(ch) + ch, String.valueOf(ch));\n+                    } else {\n+                        token = tokenUnquoted;\n+                    }\n+                    checker.accept(token);\n+                } else {\n+                    if ((options &= OPTION_TOKEN_ONLY) != 0) {\n+                        throw genException(\"Non-token detected\", sql);\n+                    }\n+                }\n+                continue;\n+            }\n+            // Handle tokens enclosed in [...]\n+            if (ch == '[') {\n+                final int quoteStart = pos;\n+                pos++;\n+\n+                pos = sql.indexOf(']', pos);\n+                if (pos < 0) {\n+                    throw genException(\"Unterminated quote\", sql);\n+                }\n+                final int quoteEnd = pos;\n+                pos++;\n+\n+                final String token = sql.substring(quoteStart + 1, quoteEnd);\n+\n+                checker.accept(token);\n+                continue;\n+            }\n+            if ((options &= OPTION_TOKEN_ONLY) != 0) {\n+                throw genException(\"Non-token detected\", sql);\n+            }\n+\n+            // Detect comments.\n+            if (ch == '-' && peek(sql, pos + 1) == '-') {\n+                pos += 2;\n+                pos = sql.indexOf('\\n', pos);\n+                if (pos < 0) {\n+                    // We disallow strings ending in an inline comment.\n+                    throw genException(\"Unterminated comment\", sql);\n+                }\n+                pos++;\n+\n+                continue;\n+            }\n+            if (ch == '/' && peek(sql, pos + 1) == '*') {\n+                pos += 2;\n+                pos = sql.indexOf(\"*/\", pos);\n+                if (pos < 0) {\n+                    throw genException(\"Unterminated comment\", sql);\n+                }\n+                pos += 2;\n+\n+                continue;\n+            }\n+\n+            // Semicolon is never allowed.\n+            if (ch == ';') {\n+                throw genException(\"Semicolon is not allowed\", sql);\n+            }\n+\n+            // For this purpose, we can simply ignore other characters.\n+            // (Note it doesn't handle the X'' literal properly and reports this X as a token,\n+            // but that should be fine...)\n+            pos++;\n+        }\n+    }\n+\n+    /**\n+     * Test if given token is a\n+     * <a href=\"https://www.sqlite.org/lang_keywords.html\">SQLite reserved\n+     * keyword</a>.\n+     */\n+    public static boolean isKeyword(@NonNull String token) {\n+        switch (token.toUpperCase(Locale.US)) {\n+            case \"ABORT\": case \"ACTION\": case \"ADD\": case \"AFTER\":\n+            case \"ALL\": case \"ALTER\": case \"ANALYZE\": case \"AND\":\n+            case \"AS\": case \"ASC\": case \"ATTACH\": case \"AUTOINCREMENT\":\n+            case \"BEFORE\": case \"BEGIN\": case \"BETWEEN\": case \"BINARY\":\n+            case \"BY\": case \"CASCADE\": case \"CASE\": case \"CAST\":\n+            case \"CHECK\": case \"COLLATE\": case \"COLUMN\": case \"COMMIT\":\n+            case \"CONFLICT\": case \"CONSTRAINT\": case \"CREATE\": case \"CROSS\":\n+            case \"CURRENT\": case \"CURRENT_DATE\": case \"CURRENT_TIME\": case \"CURRENT_TIMESTAMP\":\n+            case \"DATABASE\": case \"DEFAULT\": case \"DEFERRABLE\": case \"DEFERRED\":\n+            case \"DELETE\": case \"DESC\": case \"DETACH\": case \"DISTINCT\":\n+            case \"DO\": case \"DROP\": case \"EACH\": case \"ELSE\":\n+            case \"END\": case \"ESCAPE\": case \"EXCEPT\": case \"EXCLUDE\":\n+            case \"EXCLUSIVE\": case \"EXISTS\": case \"EXPLAIN\": case \"FAIL\":\n+            case \"FILTER\": case \"FOLLOWING\": case \"FOR\": case \"FOREIGN\":\n+            case \"FROM\": case \"FULL\": case \"GLOB\": case \"GROUP\":\n+            case \"GROUPS\": case \"HAVING\": case \"IF\": case \"IGNORE\":\n+            case \"IMMEDIATE\": case \"IN\": case \"INDEX\": case \"INDEXED\":\n+            case \"INITIALLY\": case \"INNER\": case \"INSERT\": case \"INSTEAD\":\n+            case \"INTERSECT\": case \"INTO\": case \"IS\": case \"ISNULL\":\n+            case \"JOIN\": case \"KEY\": case \"LEFT\": case \"LIKE\":\n+            case \"LIMIT\": case \"MATCH\": case \"NATURAL\": case \"NO\":\n+            case \"NOCASE\": case \"NOT\": case \"NOTHING\": case \"NOTNULL\":\n+            case \"NULL\": case \"OF\": case \"OFFSET\": case \"ON\":\n+            case \"OR\": case \"ORDER\": case \"OTHERS\": case \"OUTER\":\n+            case \"OVER\": case \"PARTITION\": case \"PLAN\": case \"PRAGMA\":\n+            case \"PRECEDING\": case \"PRIMARY\": case \"QUERY\": case \"RAISE\":\n+            case \"RANGE\": case \"RECURSIVE\": case \"REFERENCES\": case \"REGEXP\":\n+            case \"REINDEX\": case \"RELEASE\": case \"RENAME\": case \"REPLACE\":\n+            case \"RESTRICT\": case \"RIGHT\": case \"ROLLBACK\": case \"ROW\":\n+            case \"ROWS\": case \"RTRIM\": case \"SAVEPOINT\": case \"SELECT\":\n+            case \"SET\": case \"TABLE\": case \"TEMP\": case \"TEMPORARY\":\n+            case \"THEN\": case \"TIES\": case \"TO\": case \"TRANSACTION\":\n+            case \"TRIGGER\": case \"UNBOUNDED\": case \"UNION\": case \"UNIQUE\":\n+            case \"UPDATE\": case \"USING\": case \"VACUUM\": case \"VALUES\":\n+            case \"VIEW\": case \"VIRTUAL\": case \"WHEN\": case \"WHERE\":\n+            case \"WINDOW\": case \"WITH\": case \"WITHOUT\":\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Test if given token is a\n+     * <a href=\"https://www.sqlite.org/lang_corefunc.html\">SQLite reserved\n+     * function</a>.\n+     */\n+    public static boolean isFunction(@NonNull String token) {\n+        switch (token.toLowerCase(Locale.US)) {\n+            case \"abs\": case \"avg\": case \"char\": case \"coalesce\":\n+            case \"count\": case \"glob\": case \"group_concat\": case \"hex\":\n+            case \"ifnull\": case \"instr\": case \"length\": case \"like\":\n+            case \"likelihood\": case \"likely\": case \"lower\": case \"ltrim\":\n+            case \"max\": case \"min\": case \"nullif\": case \"random\":\n+            case \"randomblob\": case \"replace\": case \"round\": case \"rtrim\":\n+            case \"substr\": case \"sum\": case \"total\": case \"trim\":\n+            case \"typeof\": case \"unicode\": case \"unlikely\": case \"upper\":\n+            case \"zeroblob\":\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Test if given token is a\n+     * <a href=\"https://www.sqlite.org/datatype3.html\">SQLite reserved type</a>.\n+     */\n+    public static boolean isType(@NonNull String token) {\n+        switch (token.toUpperCase(Locale.US)) {\n+            case \"INT\": case \"INTEGER\": case \"TINYINT\": case \"SMALLINT\":\n+            case \"MEDIUMINT\": case \"BIGINT\": case \"INT2\": case \"INT8\":\n+            case \"CHARACTER\": case \"VARCHAR\": case \"NCHAR\": case \"NVARCHAR\":\n+            case \"TEXT\": case \"CLOB\": case \"BLOB\": case \"REAL\":\n+            case \"DOUBLE\": case \"FLOAT\": case \"NUMERIC\": case \"DECIMAL\":\n+            case \"BOOLEAN\": case \"DATE\": case \"DATETIME\":\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 5,
        "max_directory_depth": 7
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "49c20af2bf5ac9f3f9d78576e0bbd4096cddb1a5",
            "date": "2025-01-14T13:49:12Z",
            "author_login": "tobiasKaminsky"
          },
          {
            "sha": "ba159a7528ac2110b7cdce2b2b1e1cf00f328f65",
            "date": "2025-01-14T13:32:32Z",
            "author_login": "alperozturk96"
          },
          {
            "sha": "14c3a9c60edf88aab70e311c271a2b81c622caa9",
            "date": "2025-01-14T13:16:47Z",
            "author_login": "alperozturk96"
          },
          {
            "sha": "cb137eb669394568507514f6752eaeadaacd1a82",
            "date": "2025-01-14T11:57:57Z",
            "author_login": "tobiasKaminsky"
          },
          {
            "sha": "5c8f4b17e05dbed634cbc26375d6b58258be5938",
            "date": "2025-01-14T11:49:35Z",
            "author_login": "alperozturk96"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-89",
    "description": "The Nextcloud Android app is the Android client for Nextcloud, a self-hosted productivity platform. The Nextcloud Android app uses content providers to manage its data. Prior to version 3.18.1, the providers `FileContentProvider` and `DiskLruImageCacheFileProvider` have security issues (an SQL injection, and an insufficient permission control, respectively) that allow malicious apps in the same device to access Nextcloud's data bypassing the permission control system. Users should upgrade to version 3.18.1 to receive a patch. There are no known workarounds aside from upgrading.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-01-25T16:15:08.740",
    "last_modified": "2024-11-21T06:29:58.153",
    "fix_date": "2021-12-22T08:51:11Z"
  },
  "references": [
    {
      "url": "https://github.com/nextcloud/android/commit/627caba60e69e223b0fc89c4cb18eaa76a95db95",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/nextcloud/android/security/advisories/GHSA-vjp2-f63v-w479",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://hackerone.com/reports/1358597",
      "source": "security-advisories@github.com",
      "tags": [
        "Permissions Required"
      ]
    },
    {
      "url": "https://github.com/nextcloud/android/commit/627caba60e69e223b0fc89c4cb18eaa76a95db95",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/nextcloud/android/security/advisories/GHSA-vjp2-f63v-w479",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://hackerone.com/reports/1358597",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Permissions Required"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:57.071525",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "android",
    "owner": "nextcloud",
    "created_at": "2016-06-06T21:23:36Z",
    "updated_at": "2025-01-14T13:49:16Z",
    "pushed_at": "2025-01-14T15:10:52Z",
    "size": 495752,
    "stars": 4377,
    "forks": 1788,
    "open_issues": 1138,
    "watchers": 4377,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Java": 3211554,
      "Kotlin": 2499386,
      "Shell": 42330,
      "Ruby": 22795,
      "Python": 18179,
      "Makefile": 6084,
      "Batchfile": 5444,
      "Dockerfile": 1149,
      "AIDL": 1013
    },
    "commit_activity": {
      "total_commits_last_year": 3334,
      "avg_commits_per_week": 64.11538461538461,
      "days_active_last_year": 340
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T17:35:41.646682"
  }
}