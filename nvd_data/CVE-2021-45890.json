{
  "cve_id": "CVE-2021-45890",
  "github_data": {
    "repository": "AuthGuard/AuthGuard",
    "fix_commit": "9783b1143da6576028de23e15a1f198b1f937b82",
    "related_commits": [
      "9783b1143da6576028de23e15a1f198b1f937b82",
      "9783b1143da6576028de23e15a1f198b1f937b82"
    ],
    "patch_url": "https://github.com/AuthGuard/AuthGuard/commit/9783b1143da6576028de23e15a1f198b1f937b82.patch",
    "fix_commit_details": {
      "sha": "9783b1143da6576028de23e15a1f198b1f937b82",
      "commit_date": "2021-10-05T20:53:55Z",
      "author": {
        "login": "kmehrunes",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Prevent authentication with inactive identifiers",
        "length": 48,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 66,
        "additions": 61,
        "deletions": 5
      },
      "files": [
        {
          "filename": "basic-auth/src/main/java/com/nexblocks/authguard/basic/BasicAuthProvider.java",
          "status": "modified",
          "additions": 33,
          "deletions": 4,
          "patch": "@@ -7,10 +7,7 @@\n import com.nexblocks.authguard.service.exceptions.ServiceAuthorizationException;\n import com.nexblocks.authguard.service.exceptions.ServiceException;\n import com.nexblocks.authguard.service.exceptions.codes.ErrorCode;\n-import com.nexblocks.authguard.service.model.AccountBO;\n-import com.nexblocks.authguard.service.model.AuthRequestBO;\n-import com.nexblocks.authguard.service.model.CredentialsBO;\n-import com.nexblocks.authguard.service.model.EntityType;\n+import com.nexblocks.authguard.service.model.*;\n import com.google.inject.Inject;\n import io.vavr.control.Either;\n import org.slf4j.Logger;\n@@ -86,7 +83,14 @@ private Either<Exception, AccountBO> handleBasicAuthenticationNoPassword(final S\n     private Either<Exception, AccountBO> verifyCredentialsAndGetAccount(final String username, final String password) {\n         final Optional<CredentialsBO> credentials = credentialsService.getByUsernameUnsafe(username);\n \n+        // TODO replace this with Either mapping\n         if (credentials.isPresent()) {\n+            final Optional<Exception> validationError = checkIdentifier(credentials.get(), username);\n+\n+            if (validationError.isPresent()) {\n+                return Either.left(validationError.get());\n+            }\n+\n             if (securePassword.verify(password, credentials.get().getHashedPassword())) {\n                 return getAccountById(credentials.get().getAccountId());\n             } else {\n@@ -103,13 +107,38 @@ private Either<Exception, AccountBO> verifyCredentialsAndGetAccount(final String\n         final Optional<CredentialsBO> credentials = credentialsService.getByUsernameUnsafe(username);\n \n         if (credentials.isPresent()) {\n+            final Optional<Exception> validationError = checkIdentifier(credentials.get(), username);\n+\n+            if (validationError.isPresent()) {\n+                return Either.left(validationError.get());\n+            }\n+\n             return getAccountById(credentials.get().getAccountId());\n         } else {\n             return Either.left(new ServiceAuthorizationException(ErrorCode.CREDENTIALS_DOES_NOT_EXIST,\n                     \"Identifier \" + username + \" does not exist\"));\n         }\n     }\n \n+    private Optional<Exception> checkIdentifier(final CredentialsBO credentials,\n+                                                final String identifier) {\n+        final Optional<UserIdentifierBO> matchedIdentifier = credentials.getIdentifiers()\n+                .stream()\n+                .filter(existing -> identifier.equals(existing.getIdentifier()))\n+                .findFirst();\n+\n+        if (matchedIdentifier.isEmpty()) {\n+            return Optional.of(new IllegalStateException(\"No identifier matched but credentials were returned\"));\n+        }\n+\n+        if (!matchedIdentifier.get().isActive()) {\n+            return Optional.of(new ServiceAuthorizationException(ErrorCode.INACTIVE_IDENTIFIER,\n+                    \"Identifier is not active\", EntityType.ACCOUNT, credentials.getAccountId()));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n     private Either<Exception, AccountBO> getAccountById(final String accountId) {\n         final Optional<AccountBO> account = accountsService.getById(accountId);\n "
        },
        {
          "filename": "basic-auth/src/test/java/com/nexblocks/authguard/basic/BasicAuthProviderTest.java",
          "status": "modified",
          "additions": 22,
          "deletions": 0,
          "patch": "@@ -64,6 +64,7 @@ void authenticate() {\n                 .withIdentifiers(UserIdentifierBO.builder()\n                         .identifier(username)\n                         .type(UserIdentifier.Type.USERNAME)\n+                        .active(true)\n                         .build());\n         final HashedPasswordBO hashedPasswordBO = HashedPasswordBO.builder()\n                 .password(credentials.getHashedPassword().getPassword())\n@@ -79,6 +80,27 @@ void authenticate() {\n         assertThat(result.get()).isEqualTo(account);\n     }\n \n+    @Test\n+    void authenticateInactiveIdentifier() {\n+        final String username = \"username\";\n+        final String password = \"password\";\n+        final String authorization = Base64.getEncoder().encodeToString((username + \":\" + password).getBytes());\n+\n+        final CredentialsBO credentials = RANDOM.nextObject(CredentialsBO.class)\n+                .withIdentifiers(UserIdentifierBO.builder()\n+                        .identifier(username)\n+                        .type(UserIdentifier.Type.USERNAME)\n+                        .active(false)\n+                        .build());\n+\n+        Mockito.when(credentialsService.getByUsernameUnsafe(username)).thenReturn(Optional.of(credentials));\n+\n+        final Either<Exception, AccountBO> result = basicAuth.authenticateAndGetAccount(authorization);\n+\n+        assertThat(result.isLeft()).isTrue();\n+        assertThat(result.getLeft()).isInstanceOf(ServiceAuthorizationException.class);\n+    }\n+\n     @Test\n     void authenticateNotFound() {\n         final String username = \"username\";"
        },
        {
          "filename": "service-api/src/main/java/com/nexblocks/authguard/service/exceptions/codes/ErrorCode.java",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -33,6 +33,7 @@ public enum ErrorCode {\n     TOKEN_EXPIRED_OR_DOES_NOT_EXIST(\"AT.025\"),\n     TOKEN_GENERATION_FAILED(\"AT.031\"),\n     ACCOUNT_IS_LOCKED(\"AT.032\"),\n+    INACTIVE_IDENTIFIER(\"AT.033\"),\n     GENERIC_AUTH_FAILURE(\"AT.039\"),\n \n     UNSUPPORTED_JWT_ALGORITHM(\"JT.021\"),"
        },
        {
          "filename": "service-api/src/main/java/com/nexblocks/authguard/service/model/UserIdentifier.java",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -8,7 +8,11 @@ public interface UserIdentifier {\n     Long getId(); // only useful for relational DBs\n     Type getType();\n     String getIdentifier();\n-    boolean isActive();\n+\n+    @Value.Default\n+    default boolean isActive() {\n+        return true;\n+    }\n \n     enum Type {\n         USERNAME,"
        }
      ],
      "file_patterns": {
        "security_files": 4,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 10
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "f323b9562b9c4b073c6252d2d73a39f6034a54f8",
            "date": "2024-11-20T21:38:20Z",
            "author_login": "kmehrunes"
          },
          {
            "sha": "fe99a5555382b8458a0a7719f963ec2fd6bcd5a0",
            "date": "2024-11-18T21:49:21Z",
            "author_login": "kmehrunes"
          },
          {
            "sha": "3a62d80dbe0af828c8565ffdd5bb7cc3f0da4da4",
            "date": "2024-11-02T14:21:33Z",
            "author_login": "kmehrunes"
          },
          {
            "sha": "cf29f6aa13dc6e50696bd8a55bc17abebfe08bee",
            "date": "2024-10-20T10:33:06Z",
            "author_login": "kmehrunes"
          },
          {
            "sha": "9475c60e9ff730f837004cc0ef9992537522df5c",
            "date": "2024-10-20T11:17:56Z",
            "author_login": "kmehrunes"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-287",
    "description": "basic/BasicAuthProvider.java in AuthGuard before 0.9.0 allows authentication via an inactive identifier.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2021-12-27T20:15:07.480",
    "last_modified": "2024-11-21T06:33:12.437",
    "fix_date": "2021-10-05T20:53:55Z"
  },
  "references": [
    {
      "url": "https://github.com/AuthGuard/AuthGuard/commit/9783b1143da6576028de23e15a1f198b1f937b82",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/AuthGuard/AuthGuard/compare/v0.8.0...v0.9.0",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/AuthGuard/AuthGuard/issues/166",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/AuthGuard/AuthGuard/pull/181",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/AuthGuard/AuthGuard/commit/9783b1143da6576028de23e15a1f198b1f937b82",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/AuthGuard/AuthGuard/compare/v0.8.0...v0.9.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/AuthGuard/AuthGuard/issues/166",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/AuthGuard/AuthGuard/pull/181",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:37.031477",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "AuthGuard",
    "owner": "AuthGuard",
    "created_at": "2019-07-13T21:27:18Z",
    "updated_at": "2024-11-20T21:38:25Z",
    "pushed_at": "2024-12-18T03:59:33Z",
    "size": 2455,
    "stars": 9,
    "forks": 0,
    "open_issues": 11,
    "watchers": 9,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Java": 1423250,
      "HTML": 9395
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T16:48:46.523773"
  }
}