{
  "cve_id": "CVE-2022-0122",
  "github_data": {
    "repository": "digitalbazaar/forge",
    "fix_commit": "db8016c805371e72b06d8e2edfe0ace0df934a5e",
    "related_commits": [
      "db8016c805371e72b06d8e2edfe0ace0df934a5e",
      "db8016c805371e72b06d8e2edfe0ace0df934a5e"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "db8016c805371e72b06d8e2edfe0ace0df934a5e",
      "commit_date": "2021-10-22T00:15:32Z",
      "author": {
        "login": "davidlehn",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Remove forge.util.parseUrl.",
        "length": 172,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 119,
        "additions": 45,
        "deletions": 74
      },
      "files": [
        {
          "filename": "CHANGELOG.md",
          "status": "modified",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -9,12 +9,22 @@ Forge ChangeLog\n   maintainers for internal project debug purposes and was never intended to be\n   used with untrusted user inputs. This API was not documented or advertised\n   and is being removed rather than fixed.\n+- **SECURITY**, **BREAKING**: Remove `forge.util.parseUrl()` (and\n+  `forge.http.parseUrl` alias) and use the [WHATWG URL\n+  Standard](https://url.spec.whatwg.org/). `URL` is supported by modern browers\n+  and modern Node.js. This change is needed to address URL parsing security\n+  issues. If `forge.util.parseUrl()` is used directly or through `forge.xhr` or\n+  `forge.http` APIs, and support is needed for environments without `URL`\n+  support, then a polyfill must be used.\n - **BREAKING**: Remove `forge.task` API. This API was never used, documented,\n   or advertised by the maintainers. If anyone was using this API and wishes to\n   continue development it in other project, please let the maintainers know.\n   Due to use in the test suite, a modified version is located in\n   `tests/support/`.\n \n+### Changed\n+- **BREAKING**: Increase supported Node.js version to 6.13.0 for URL support.\n+\n ### Added\n - OIDs for `surname`, `title`, and `givenName`.\n \n@@ -23,6 +33,12 @@ Forge ChangeLog\n   Depending on how applications used this id to name association it could cause\n   compatibility issues.\n \n+### Notes\n+- The URL related changes may expose bugs in some of the networking related\n+  code (unrelated to the much wider used cryptography code). The automated and\n+  manual test coverage for this code is weak at best. Issues or patches to\n+  update the code or tests would be appriciated.\n+\n ## 0.10.0 - 2020-09-01\n \n ### Changed"
        },
        {
          "filename": "README.md",
          "status": "modified",
          "additions": 0,
          "deletions": 4,
          "patch": "@@ -1968,10 +1968,6 @@ var nodeBuffer = Buffer.from(forgeBuffer.getBytes(), 'binary');\n // make sure you specify the encoding as 'binary'\n var nodeBuffer = Buffer.from('CAFE', 'hex');\n var forgeBuffer = forge.util.createBuffer(nodeBuffer.toString('binary'));\n-\n-// parse a URL\n-var parsed = forge.util.parseUrl('http://example.com/foo?bar=baz');\n-// parsed.scheme, parsed.host, parsed.port, parsed.path, parsed.fullHost\n ```\n \n <a name=\"log\" />"
        },
        {
          "filename": "lib/http.js",
          "status": "modified",
          "additions": 16,
          "deletions": 23,
          "patch": "@@ -33,8 +33,8 @@ var _getStorageId = function(client) {\n   // browsers (if this is undesirable)\n   // navigator.userAgent\n   return 'forge.http.' +\n-    client.url.scheme + '.' +\n-    client.url.host + '.' +\n+    client.url.protocol.slice(0, -1) + '.' +\n+    client.url.hostname + '.' +\n     client.url.port;\n };\n \n@@ -121,7 +121,7 @@ var _doRequest = function(client, socket) {\n     // connect\n     socket.options.request.connectTime = +new Date();\n     socket.connect({\n-      host: client.url.host,\n+      host: client.url.hostname,\n       port: client.url.port,\n       policyPort: client.policyPort,\n       policyUrl: client.policyUrl\n@@ -310,7 +310,7 @@ var _initSocket = function(client, socket, tlsOptions) {\n       // prime socket by connecting and caching TLS session, will do\n       // next request from there\n       socket.connect({\n-        host: client.url.host,\n+        host: client.url.hostname,\n         port: client.url.port,\n         policyPort: client.policyPort,\n         policyUrl: client.policyUrl\n@@ -405,7 +405,7 @@ var _readCookies = function(client, response) {\n  *\n  * @param options:\n  *   url: the url to connect to (scheme://host:port).\n- *     socketPool: the flash socket pool to use.\n+ *   socketPool: the flash socket pool to use.\n  *   policyPort: the flash policy port to use (if other than the\n  *     socket pool default), use 0 for flash default.\n  *   policyUrl: the flash policy file URL to use (if provided will\n@@ -441,8 +441,10 @@ http.createClient = function(options) {\n   // get scheme, host, and port from url\n   options.url = (options.url ||\n     window.location.protocol + '//' + window.location.host);\n-  var url = http.parseUrl(options.url);\n-  if(!url) {\n+  var url;\n+  try {\n+    url = new URL(options.url);\n+  } catch(e) {\n     var error = new Error('Invalid url.');\n     error.details = {url: options.url};\n     throw error;\n@@ -469,7 +471,7 @@ http.createClient = function(options) {\n     // idle sockets\n     idle: [],\n     // whether or not the connections are secure\n-    secure: (url.scheme === 'https'),\n+    secure: (url.protocol === 'https:'),\n     // cookie jar (key'd off of name and then path, there is only 1 domain\n     // and one setting for secure per client so name+path is unique)\n     cookies: {},\n@@ -497,7 +499,7 @@ http.createClient = function(options) {\n     if(depth === 0 && verified === true) {\n       // compare common name to url host\n       var cn = certs[depth].subject.getField('CN');\n-      if(cn === null || client.url.host !== cn.value) {\n+      if(cn === null || client.url.hostname !== cn.value) {\n         verified = {\n           message: 'Certificate common name does not match url host.'\n         };\n@@ -512,7 +514,7 @@ http.createClient = function(options) {\n     tlsOptions = {\n       caStore: caStore,\n       cipherSuites: options.cipherSuites || null,\n-      virtualHost: options.virtualHost || url.host,\n+      virtualHost: options.virtualHost || url.hostname,\n       verify: options.verify || _defaultCertificateVerify,\n       getCertificate: options.getCertificate || null,\n       getPrivateKey: options.getPrivateKey || null,\n@@ -552,7 +554,7 @@ http.createClient = function(options) {\n   client.send = function(options) {\n     // add host header if not set\n     if(options.request.getField('Host') === null) {\n-      options.request.setField('Host', client.url.fullHost);\n+      options.request.setField('Host', client.url.origin);\n     }\n \n     // set default dummy handlers\n@@ -1307,15 +1309,6 @@ http.createResponse = function() {\n   return response;\n };\n \n-/**\n- * Parses the scheme, host, and port from an http(s) url.\n- *\n- * @param str the url string.\n- *\n- * @return the parsed url object or null if the url is invalid.\n- */\n-http.parseUrl = forge.util.parseUrl;\n-\n /**\n  * Returns true if the given url is within the given cookie's domain.\n  *\n@@ -1336,11 +1329,11 @@ http.withinCookieDomain = function(url, cookie) {\n     // ensure domain starts with a '.'\n     // parse URL as necessary\n     if(typeof url === 'string') {\n-      url = http.parseUrl(url);\n+      url = new URL(url);\n     }\n \n-    // add '.' to front of URL host to match against domain\n-    var host = '.' + url.host;\n+    // add '.' to front of URL hostname to match against domain\n+    var host = '.' + url.hostname;\n \n     // if the host ends with domain then it falls within it\n     var idx = host.lastIndexOf(domain);"
        },
        {
          "filename": "lib/util.js",
          "status": "modified",
          "additions": 0,
          "deletions": 37,
          "patch": "@@ -2258,43 +2258,6 @@ util.clearItems = function(api, id, location) {\n   _callStorageFunction(_clearItems, arguments, location);\n };\n \n-/**\n- * Parses the scheme, host, and port from an http(s) url.\n- *\n- * @param str the url string.\n- *\n- * @return the parsed url object or null if the url is invalid.\n- */\n-util.parseUrl = function(str) {\n-  // FIXME: this regex looks a bit broken\n-  var regex = /^(https?):\\/\\/([^:&^\\/]*):?(\\d*)(.*)$/g;\n-  regex.lastIndex = 0;\n-  var m = regex.exec(str);\n-  var url = (m === null) ? null : {\n-    full: str,\n-    scheme: m[1],\n-    host: m[2],\n-    port: m[3],\n-    path: m[4]\n-  };\n-  if(url) {\n-    url.fullHost = url.host;\n-    if(url.port) {\n-      if(url.port !== 80 && url.scheme === 'http') {\n-        url.fullHost += ':' + url.port;\n-      } else if(url.port !== 443 && url.scheme === 'https') {\n-        url.fullHost += ':' + url.port;\n-      }\n-    } else if(url.scheme === 'http') {\n-      url.port = 80;\n-    } else if(url.scheme === 'https') {\n-      url.port = 443;\n-    }\n-    url.full = url.scheme + '://' + url.fullHost;\n-  }\n-  return url;\n-};\n-\n /* Storage for query variables */\n var _queryVariables = null;\n "
        },
        {
          "filename": "lib/xhr.js",
          "status": "modified",
          "additions": 8,
          "deletions": 6,
          "patch": "@@ -151,7 +151,7 @@ xhrApi.init = function(options) {\n     getPrivateKey: options.getPrivateKey,\n     getSignature: options.getSignature\n   });\n-  _clients[_client.url.full] = _client;\n+  _clients[_client.url.origin] = _client;\n \n   forge.log.debug(cat, 'ready');\n };\n@@ -380,18 +380,20 @@ xhrApi.create = function(options) {\n     // use default\n     _state.client = _client;\n   } else {\n-    var url = http.parseUrl(options.url);\n-    if(!url) {\n+    var url;\n+    try {\n+      url = new URL(options.url);\n+    } catch(e) {\n       var error = new Error('Invalid url.');\n       error.details = {\n         url: options.url\n       };\n     }\n \n     // find client\n-    if(url.full in _clients) {\n+    if(url.origin in _clients) {\n       // client found\n-      _state.client = _clients[url.full];\n+      _state.client = _clients[url.origin];\n     } else {\n       // create client\n       _state.client = http.createClient({\n@@ -409,7 +411,7 @@ xhrApi.create = function(options) {\n         getPrivateKey: options.getPrivateKey,\n         getSignature: options.getSignature\n       });\n-      _clients[url.full] = _state.client;\n+      _clients[url.origin] = _state.client;\n     }\n   }\n "
        },
        {
          "filename": "package.json",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -60,7 +60,7 @@\n     \"dist/*.min.js.map\"\n   ],\n   \"engines\": {\n-    \"node\": \">= 6.0.0\"\n+    \"node\": \">= 6.13.0\"\n   },\n   \"keywords\": [\n     \"aes\","
        },
        {
          "filename": "tests/websockets/server-webid.js",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -174,9 +174,10 @@ var fetchUrl = function(url, callback, redirects) {\n   console.log('Fetching URL: \\\"' + url + '\\\"');\n \n   // parse URL\n-  url = forge.util.parseUrl(url);\n-  var client = http.createClient(\n-    url.port, url.fullHost, url.scheme === 'https');\n+  url = new URL(url);\n+  var client = http.createClient({\n+    url: url\n+  });\n   var request = client.request('GET', url.path, {\n     Host: url.host,\n     Accept: 'application/rdf+xml'"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 1,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2bb97afb5058285ef09bcf1d04d6bd6b87cffd58",
            "date": "2022-03-30T00:12:23Z",
            "author_login": "davidlehn"
          },
          {
            "sha": "a0a4a4264bedb3296974b9675349c9c190144aeb",
            "date": "2022-03-30T00:11:45Z",
            "author_login": "davidlehn"
          },
          {
            "sha": "a33830f61c351e8e3a34309767e8dd0de148376b",
            "date": "2022-03-30T00:11:45Z",
            "author_login": "davidlehn"
          },
          {
            "sha": "740954d747ac56b76a6e1ae12a057c9548843436",
            "date": "2022-03-30T00:01:31Z",
            "author_login": "davidlehn"
          },
          {
            "sha": "56f4316b4cc6592e678f8c416209c45984b6547b",
            "date": "2022-03-28T13:41:04Z",
            "author_login": "dhensby"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",
    "cwe_id": "CWE-601",
    "description": "forge is vulnerable to URL Redirection to Untrusted Site",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-01-06T05:15:09.490",
    "last_modified": "2024-11-21T06:37:57.103",
    "fix_date": "2021-10-22T00:15:32Z"
  },
  "references": [
    {
      "url": "https://github.com/digitalbazaar/forge/commit/db8016c805371e72b06d8e2edfe0ace0df934a5e",
      "source": "security@huntr.dev",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/41852c50-3c6d-4703-8c55-4db27164a4ae",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/digitalbazaar/forge/commit/db8016c805371e72b06d8e2edfe0ace0df934a5e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/41852c50-3c6d-4703-8c55-4db27164a4ae",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:37.051359",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "forge",
    "owner": "digitalbazaar",
    "created_at": "2010-07-16T20:49:48Z",
    "updated_at": "2025-01-25T00:53:34Z",
    "pushed_at": "2024-08-14T16:12:50Z",
    "size": 5027,
    "stars": 5122,
    "forks": 796,
    "open_issues": 446,
    "watchers": 5122,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "0.6.x",
      "0.8.x",
      "main"
    ],
    "languages": {
      "JavaScript": 1642997,
      "HTML": 73308,
      "ActionScript": 25864,
      "C": 13441,
      "Python": 3547,
      "CSS": 1244
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T08:23:03.264871"
  }
}