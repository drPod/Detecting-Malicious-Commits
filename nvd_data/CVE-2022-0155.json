{
  "cve_id": "CVE-2022-0155",
  "github_data": {
    "repository": "follow-redirects/follow-redirects",
    "fix_commit": "8b347cbcef7c7b72a6e9be20f5710c17d6163c22",
    "related_commits": [
      "8b347cbcef7c7b72a6e9be20f5710c17d6163c22",
      "8b347cbcef7c7b72a6e9be20f5710c17d6163c22"
    ],
    "patch_url": "https://github.com/follow-redirects/follow-redirects/commit/8b347cbcef7c7b72a6e9be20f5710c17d6163c22.patch",
    "fix_commit_details": {
      "sha": "8b347cbcef7c7b72a6e9be20f5710c17d6163c22",
      "commit_date": "2022-01-10T16:52:42Z",
      "author": {
        "login": "RubenVerborgh",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Drop Cookie header across domains.",
        "length": 105,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 357,
        "additions": 175,
        "deletions": 182
      },
      "files": [
        {
          "filename": "index.js",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -392,9 +392,9 @@ RedirectableRequest.prototype._processResponse = function (response) {\n     var redirectUrlParts = url.parse(redirectUrl);\n     Object.assign(this._options, redirectUrlParts);\n \n-    // Drop the Authorization header if redirecting to another domain\n+    // Drop the confidential headers when redirecting to another domain\n     if (!(redirectUrlParts.host === currentHost || isSubdomainOf(redirectUrlParts.host, currentHost))) {\n-      removeMatchingHeaders(/^authorization$/i, this._options.headers);\n+      removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);\n     }\n \n     // Evaluate the beforeRedirect callback"
        },
        {
          "filename": "test/test.js",
          "status": "modified",
          "additions": 173,
          "deletions": 180,
          "patch": "@@ -1319,215 +1319,208 @@ describe(\"follow-redirects\", function () {\n     });\n   });\n \n-  describe(\"when the client passes an Authorization header\", function () {\n-    it(\"ignores it when null\", function () {\n-      app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n-      app.get(\"/b\", function (req, res) {\n-        res.end(JSON.stringify(req.headers));\n-      });\n-\n-      var opts = url.parse(\"http://127.0.0.1:3600/a\");\n-      opts.headers = {\n-        host: \"localhost\",\n-        authorization: null,\n-      };\n-\n-      return server.start(app)\n-        .then(asPromise(function (resolve, reject) {\n-          http.get(opts, resolve).on(\"error\", reject);\n-        }))\n-        .then(asPromise(function (resolve, reject, res) {\n-          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n-        }))\n-        .then(function (str) {\n-          var body = JSON.parse(str);\n-          assert.equal(body.host, \"localhost:3600\");\n-          assert.equal(body.authorization, undefined);\n+  [\n+    \"Authorization\",\n+    \"Cookie\",\n+  ].forEach(function (header) {\n+    describe(\"when the client passes an header named \" + header, function () {\n+      it(\"ignores it when null\", function () {\n+        app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n+        app.get(\"/b\", function (req, res) {\n+          res.end(JSON.stringify(req.headers));\n         });\n-    });\n \n-    it(\"keeps the header when redirected to the same host\", function () {\n-      app.get(\"/a\", redirectsTo(302, \"/b\"));\n-      app.get(\"/b\", function (req, res) {\n-        res.end(JSON.stringify(req.headers));\n-      });\n+        var opts = url.parse(\"http://127.0.0.1:3600/a\");\n+        opts.headers = { host: \"localhost\" };\n+        opts.headers[header] = null;\n \n-      var opts = url.parse(\"http://localhost:3600/a\");\n-      opts.headers = {\n-        authorization: \"bearer my-token-1234\",\n-      };\n+        return server.start(app)\n+          .then(asPromise(function (resolve, reject) {\n+            http.get(opts, resolve).on(\"error\", reject);\n+          }))\n+          .then(asPromise(function (resolve, reject, res) {\n+            res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n+          }))\n+          .then(function (str) {\n+            var body = JSON.parse(str);\n+            assert.equal(body.host, \"localhost:3600\");\n+            assert.equal(body[header.toLowerCase()], undefined);\n+          });\n+      });\n \n-      return server.start(app)\n-        .then(asPromise(function (resolve, reject) {\n-          http.get(opts, resolve).on(\"error\", reject);\n-        }))\n-        .then(asPromise(function (resolve, reject, res) {\n-          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n-        }))\n-        .then(function (str) {\n-          var body = JSON.parse(str);\n-          assert.equal(body.host, \"localhost:3600\");\n-          assert.equal(body.authorization, \"bearer my-token-1234\");\n+      it(\"keeps the header when redirected to the same host\", function () {\n+        app.get(\"/a\", redirectsTo(302, \"/b\"));\n+        app.get(\"/b\", function (req, res) {\n+          res.end(JSON.stringify(req.headers));\n         });\n-    });\n \n-    it(\"keeps the header when redirected to the same host via header\", function () {\n-      app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n-      app.get(\"/b\", function (req, res) {\n-        res.end(JSON.stringify(req.headers));\n-      });\n+        var opts = url.parse(\"http://localhost:3600/a\");\n+        opts.headers = {};\n+        opts.headers[header] = \"the header value\";\n \n-      var opts = url.parse(\"http://127.0.0.1:3600/a\");\n-      opts.headers = {\n-        host: \"localhost:3600\",\n-        authorization: \"bearer my-token-1234\",\n-      };\n+        return server.start(app)\n+          .then(asPromise(function (resolve, reject) {\n+            http.get(opts, resolve).on(\"error\", reject);\n+          }))\n+          .then(asPromise(function (resolve, reject, res) {\n+            res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n+          }))\n+          .then(function (str) {\n+            var body = JSON.parse(str);\n+            assert.equal(body.host, \"localhost:3600\");\n+            assert.equal(body[header.toLowerCase()], \"the header value\");\n+          });\n+      });\n \n-      return server.start(app)\n-        .then(asPromise(function (resolve, reject) {\n-          http.get(opts, resolve).on(\"error\", reject);\n-        }))\n-        .then(asPromise(function (resolve, reject, res) {\n-          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n-        }))\n-        .then(function (str) {\n-          var body = JSON.parse(str);\n-          assert.equal(body.host, \"localhost:3600\");\n-          assert.equal(body.authorization, \"bearer my-token-1234\");\n+      it(\"keeps the header when redirected to the same host via header\", function () {\n+        app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n+        app.get(\"/b\", function (req, res) {\n+          res.end(JSON.stringify(req.headers));\n         });\n-    });\n \n-    it(\"keeps the header when redirected to the same host via header\", function () {\n-      app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n-      app.get(\"/b\", function (req, res) {\n-        res.end(JSON.stringify(req.headers));\n-      });\n+        var opts = url.parse(\"http://127.0.0.1:3600/a\");\n+        opts.headers = { host: \"localhost:3600\" };\n+        opts.headers[header] = \"the header value\";\n \n-      var opts = url.parse(\"http://127.0.0.1:3600/a\");\n-      opts.headers = {\n-        host: \"localhost:3600\",\n-        authorization: \"bearer my-token-1234\",\n-      };\n+        return server.start(app)\n+          .then(asPromise(function (resolve, reject) {\n+            http.get(opts, resolve).on(\"error\", reject);\n+          }))\n+          .then(asPromise(function (resolve, reject, res) {\n+            res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n+          }))\n+          .then(function (str) {\n+            var body = JSON.parse(str);\n+            assert.equal(body.host, \"localhost:3600\");\n+            assert.equal(body[header.toLowerCase()], \"the header value\");\n+          });\n+      });\n \n-      return server.start(app)\n-        .then(asPromise(function (resolve, reject) {\n-          http.get(opts, resolve).on(\"error\", reject);\n-        }))\n-        .then(asPromise(function (resolve, reject, res) {\n-          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n-        }))\n-        .then(function (str) {\n-          var body = JSON.parse(str);\n-          assert.equal(body.host, \"localhost:3600\");\n-          assert.equal(body.authorization, \"bearer my-token-1234\");\n+      it(\"keeps the header when redirected to the same host via header\", function () {\n+        app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n+        app.get(\"/b\", function (req, res) {\n+          res.end(JSON.stringify(req.headers));\n         });\n-    });\n \n-    it(\"keeps the header when redirected to a subdomain\", function () {\n-      app.get(\"/a\", redirectsTo(302, \"http://sub.localhost:3600/b\"));\n-      app.get(\"/b\", function (req, res) {\n-        res.end(JSON.stringify(req.headers));\n-      });\n+        var opts = url.parse(\"http://127.0.0.1:3600/a\");\n+        opts.headers = { host: \"localhost:3600\" };\n+        opts.headers[header] = \"the header value\";\n \n-      var opts = url.parse(\"http://localhost:3600/a\");\n-      opts.headers = {\n-        authorization: \"bearer my-token-1234\",\n-      };\n-      // Intercept the hostname, as no DNS entry is defined for it\n-      opts.beforeRedirect = function (options) {\n-        assert.equal(options.hostname, \"sub.localhost\");\n-        options.hostname = \"localhost\";\n-      };\n+        return server.start(app)\n+          .then(asPromise(function (resolve, reject) {\n+            http.get(opts, resolve).on(\"error\", reject);\n+          }))\n+          .then(asPromise(function (resolve, reject, res) {\n+            res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n+          }))\n+          .then(function (str) {\n+            var body = JSON.parse(str);\n+            assert.equal(body.host, \"localhost:3600\");\n+            assert.equal(body[header.toLowerCase()], \"the header value\");\n+          });\n+      });\n \n-      return server.start(app)\n-        .then(asPromise(function (resolve, reject) {\n-          http.get(opts, resolve).on(\"error\", reject);\n-        }))\n-        .then(asPromise(function (resolve, reject, res) {\n-          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n-        }))\n-        .then(function (str) {\n-          var body = JSON.parse(str);\n-          assert.equal(body.host, \"localhost:3600\");\n-          assert.equal(body.authorization, \"bearer my-token-1234\");\n+      it(\"keeps the header when redirected to a subdomain\", function () {\n+        app.get(\"/a\", redirectsTo(302, \"http://sub.localhost:3600/b\"));\n+        app.get(\"/b\", function (req, res) {\n+          res.end(JSON.stringify(req.headers));\n         });\n-    });\n \n-    it(\"drops the header when redirected to a different host (same hostname and different port)\", function () {\n-      app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n-      app.get(\"/b\", function (req, res) {\n-        res.end(JSON.stringify(req.headers));\n-      });\n+        var opts = url.parse(\"http://localhost:3600/a\");\n+        opts.headers = {};\n+        opts.headers[header] = \"the header value\";\n \n-      var opts = url.parse(\"http://127.0.0.1:3600/a\");\n-      opts.headers = {\n-        host: \"localhost\",\n-        authorization: \"bearer my-token-1234\",\n-      };\n+        // Intercept the hostname, as no DNS entry is defined for it\n+        opts.beforeRedirect = function (options) {\n+          assert.equal(options.hostname, \"sub.localhost\");\n+          options.hostname = \"localhost\";\n+        };\n \n-      return server.start(app)\n-        .then(asPromise(function (resolve, reject) {\n-          http.get(opts, resolve).on(\"error\", reject);\n-        }))\n-        .then(asPromise(function (resolve, reject, res) {\n-          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n-        }))\n-        .then(function (str) {\n-          var body = JSON.parse(str);\n-          assert.equal(body.host, \"localhost:3600\");\n-          assert.equal(body.authorization, undefined);\n+        return server.start(app)\n+          .then(asPromise(function (resolve, reject) {\n+            http.get(opts, resolve).on(\"error\", reject);\n+          }))\n+          .then(asPromise(function (resolve, reject, res) {\n+            res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n+          }))\n+          .then(function (str) {\n+            var body = JSON.parse(str);\n+            assert.equal(body.host, \"localhost:3600\");\n+            assert.equal(body[header.toLowerCase()], \"the header value\");\n+          });\n+      });\n+\n+      it(\"drops the header when redirected to a different host (same hostname and different port)\", function () {\n+        app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n+        app.get(\"/b\", function (req, res) {\n+          res.end(JSON.stringify(req.headers));\n         });\n-    });\n \n-    it(\"drops the header when redirected to a different host\", function () {\n-      app.get(\"/a\", redirectsTo(302, \"http://127.0.0.1:3600/b\"));\n-      app.get(\"/b\", function (req, res) {\n-        res.end(JSON.stringify(req.headers));\n-      });\n+        var opts = url.parse(\"http://127.0.0.1:3600/a\");\n+        opts.headers = { host: \"localhost\" };\n+        opts.headers[header] = \"the header value\";\n \n-      var opts = url.parse(\"http://localhost:3600/a\");\n-      opts.headers = {\n-        authorization: \"bearer my-token-1234\",\n-      };\n+        return server.start(app)\n+          .then(asPromise(function (resolve, reject) {\n+            http.get(opts, resolve).on(\"error\", reject);\n+          }))\n+          .then(asPromise(function (resolve, reject, res) {\n+            res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n+          }))\n+          .then(function (str) {\n+            var body = JSON.parse(str);\n+            assert.equal(body.host, \"localhost:3600\");\n+            assert.equal(body[header.toLowerCase()], undefined);\n+          });\n+      });\n \n-      return server.start(app)\n-        .then(asPromise(function (resolve, reject) {\n-          http.get(opts, resolve).on(\"error\", reject);\n-        }))\n-        .then(asPromise(function (resolve, reject, res) {\n-          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n-        }))\n-        .then(function (str) {\n-          var body = JSON.parse(str);\n-          assert.equal(body.host, \"127.0.0.1:3600\");\n-          assert.equal(body.authorization, undefined);\n+      it(\"drops the header when redirected to a different host\", function () {\n+        app.get(\"/a\", redirectsTo(302, \"http://127.0.0.1:3600/b\"));\n+        app.get(\"/b\", function (req, res) {\n+          res.end(JSON.stringify(req.headers));\n         });\n-    });\n \n-    it(\"drops the header when redirected from a different host via header\", function () {\n-      app.get(\"/a\", redirectsTo(302, \"http://127.0.0.1:3600/b\"));\n-      app.get(\"/b\", function (req, res) {\n-        res.end(JSON.stringify(req.headers));\n-      });\n+        var opts = url.parse(\"http://localhost:3600/a\");\n+        opts.headers = {};\n+        opts.headers[header] = \"the header value\";\n \n-      var opts = url.parse(\"http://127.0.0.1:3600/a\");\n-      opts.headers = {\n-        host: \"localhost\",\n-        authorization: \"bearer my-token-1234\",\n-      };\n+        return server.start(app)\n+          .then(asPromise(function (resolve, reject) {\n+            http.get(opts, resolve).on(\"error\", reject);\n+          }))\n+          .then(asPromise(function (resolve, reject, res) {\n+            res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n+          }))\n+          .then(function (str) {\n+            var body = JSON.parse(str);\n+            assert.equal(body.host, \"127.0.0.1:3600\");\n+            assert.equal(body[header.toLowerCase()], undefined);\n+          });\n+      });\n \n-      return server.start(app)\n-        .then(asPromise(function (resolve, reject) {\n-          http.get(opts, resolve).on(\"error\", reject);\n-        }))\n-        .then(asPromise(function (resolve, reject, res) {\n-          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n-        }))\n-        .then(function (str) {\n-          var body = JSON.parse(str);\n-          assert.equal(body.host, \"127.0.0.1:3600\");\n-          assert.equal(body.authorization, undefined);\n+      it(\"drops the header when redirected from a different host via header\", function () {\n+        app.get(\"/a\", redirectsTo(302, \"http://127.0.0.1:3600/b\"));\n+        app.get(\"/b\", function (req, res) {\n+          res.end(JSON.stringify(req.headers));\n         });\n+\n+        var opts = url.parse(\"http://127.0.0.1:3600/a\");\n+        opts.headers = { host: \"localhost\" };\n+        opts.headers[header] = \"the header value\";\n+\n+        return server.start(app)\n+          .then(asPromise(function (resolve, reject) {\n+            http.get(opts, resolve).on(\"error\", reject);\n+          }))\n+          .then(asPromise(function (resolve, reject, res) {\n+            res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n+          }))\n+          .then(function (str) {\n+            var body = JSON.parse(str);\n+            assert.equal(body.host, \"127.0.0.1:3600\");\n+            assert.equal(body[header.toLowerCase()], undefined);\n+          });\n+      });\n     });\n   });\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "694d6b47a42bc8377e5ef1480394de451e16bd5b",
            "date": "2024-10-11T15:08:17Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "e4e55c77b2d849280d105943f49f42e0c735d05d",
            "date": "2024-09-06T08:56:25Z",
            "author_login": "RubenVerborgh"
          },
          {
            "sha": "31a1abf2d659ac1c8fcbe7e614a8c8914d80e1e3",
            "date": "2024-09-06T08:54:14Z",
            "author_login": "RubenVerborgh"
          },
          {
            "sha": "d2aaa97439e8a7e4a9cd02513ec7b12f23c17638",
            "date": "2024-09-03T21:45:36Z",
            "author_login": "RubenVerborgh"
          },
          {
            "sha": "62558f0cd106195f4c17ece3ad255eb93487d37f",
            "date": "2024-09-03T21:44:09Z",
            "author_login": "RubenVerborgh"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-359",
    "description": "follow-redirects is vulnerable to Exposure of Private Personal Information to an Unauthorized Actor",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-01-10T20:15:08.177",
    "last_modified": "2024-11-21T06:38:01.143",
    "fix_date": "2022-01-10T16:52:42Z"
  },
  "references": [
    {
      "url": "https://cert-portal.siemens.com/productcert/pdf/ssa-637483.pdf",
      "source": "security@huntr.dev",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/follow-redirects/follow-redirects/commit/8b347cbcef7c7b72a6e9be20f5710c17d6163c22",
      "source": "security@huntr.dev",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/fc524e4b-ebb6-427d-ab67-a64181020406",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://cert-portal.siemens.com/productcert/pdf/ssa-637483.pdf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/follow-redirects/follow-redirects/commit/8b347cbcef7c7b72a6e9be20f5710c17d6163c22",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/fc524e4b-ebb6-427d-ab67-a64181020406",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:37.065422",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "follow-redirects",
    "owner": "follow-redirects",
    "created_at": "2012-11-15T00:01:16Z",
    "updated_at": "2025-01-08T04:47:04Z",
    "pushed_at": "2024-10-12T15:45:49Z",
    "size": 801,
    "stars": 551,
    "forks": 170,
    "open_issues": 16,
    "watchers": 551,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "JavaScript": 107014
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T21:03:39.493148"
  }
}