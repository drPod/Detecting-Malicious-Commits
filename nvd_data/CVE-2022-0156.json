{
  "cve_id": "CVE-2022-0156",
  "github_data": {
    "repository": "vim/vim",
    "fix_commit": "9f1a39a5d1cd7989ada2d1cb32f97d84360e050f",
    "related_commits": [
      "9f1a39a5d1cd7989ada2d1cb32f97d84360e050f",
      "9f1a39a5d1cd7989ada2d1cb32f97d84360e050f"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "9f1a39a5d1cd7989ada2d1cb32f97d84360e050f",
      "commit_date": "2022-01-08T15:39:39Z",
      "author": {
        "login": "brammool",
        "type": "User",
        "stats": {
          "total_commits": 16567,
          "average_weekly_commits": 15.382544103992572,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 874
        }
      },
      "commit_message": {
        "title": "patch 8.2.4040: keeping track of allocated lines is too complicated",
        "length": 240,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 129,
        "additions": 82,
        "deletions": 47
      },
      "files": [
        {
          "filename": "src/alloc.c",
          "status": "modified",
          "additions": 15,
          "deletions": 2,
          "patch": "@@ -702,7 +702,7 @@ ga_init(garray_T *gap)\n }\n \n     void\n-ga_init2(garray_T *gap, int itemsize, int growsize)\n+ga_init2(garray_T *gap, size_t itemsize, int growsize)\n {\n     ga_init(gap);\n     gap->ga_itemsize = itemsize;\n@@ -789,7 +789,7 @@ ga_concat_strings(garray_T *gap, char *sep)\n  * When out of memory nothing changes and FAIL is returned.\n  */\n     int\n-ga_add_string(garray_T *gap, char_u *p)\n+ga_copy_string(garray_T *gap, char_u *p)\n {\n     char_u *cp = vim_strsave(p);\n \n@@ -805,6 +805,19 @@ ga_add_string(garray_T *gap, char_u *p)\n     return OK;\n }\n \n+/*\n+ * Add string \"p\" to \"gap\".\n+ * When out of memory \"p\" is freed and FAIL is returned.\n+ */\n+    int\n+ga_add_string(garray_T *gap, char_u *p)\n+{\n+    if (ga_grow(gap, 1) == FAIL)\n+\treturn FAIL;\n+    ((char_u **)(gap->ga_data))[gap->ga_len++] = p;\n+    return OK;\n+}\n+\n /*\n  * Concatenate a string to a growarray which contains bytes.\n  * When \"s\" is NULL does not do anything."
        },
        {
          "filename": "src/message.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -587,7 +587,7 @@ ignore_error_for_testing(char_u *error)\n     if (STRCMP(\"RESET\", error) == 0)\n \tga_clear_strings(&ignore_error_list);\n     else\n-\tga_add_string(&ignore_error_list, error);\n+\tga_copy_string(&ignore_error_list, error);\n }\n \n     static int"
        },
        {
          "filename": "src/proto/alloc.pro",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -17,10 +17,11 @@ void ga_clear(garray_T *gap);\n void ga_clear_strings(garray_T *gap);\n int ga_copy_strings(garray_T *from, garray_T *to);\n void ga_init(garray_T *gap);\n-void ga_init2(garray_T *gap, int itemsize, int growsize);\n+void ga_init2(garray_T *gap, size_t itemsize, int growsize);\n int ga_grow(garray_T *gap, int n);\n int ga_grow_inner(garray_T *gap, int n);\n char_u *ga_concat_strings(garray_T *gap, char *sep);\n+int ga_copy_string(garray_T *gap, char_u *p);\n int ga_add_string(garray_T *gap, char_u *p);\n void ga_concat(garray_T *gap, char_u *s);\n void ga_concat_len(garray_T *gap, char_u *s, size_t len);"
        },
        {
          "filename": "src/proto/userfunc.pro",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -38,7 +38,7 @@ char_u *untrans_function_name(char_u *name);\n char_u *get_scriptlocal_funcname(char_u *funcname);\n char_u *save_function_name(char_u **name, int *is_global, int skip, int flags, funcdict_T *fudi);\n void list_functions(regmatch_T *regmatch);\n-ufunc_T *define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free);\n+ufunc_T *define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free);\n void ex_function(exarg_T *eap);\n void ex_defcompile(exarg_T *eap);\n int eval_fname_script(char_u *p);"
        },
        {
          "filename": "src/testdir/test_vim9_func.vim",
          "status": "modified",
          "additions": 15,
          "deletions": 1,
          "patch": "@@ -1757,6 +1757,21 @@ def Test_nested_function_with_args_split()\n   CheckScriptFailure(lines, 'E1173: Text found after endfunction: BBBB')\n enddef\n \n+def Test_error_in_function_args()\n+  var lines =<< trim END\n+      def FirstFunction()\n+        def SecondFunction(J  =\n+        # Nois\n+        # one\n+         \n+         enddef|BBBB\n+      enddef\n+      # Compile all functions\n+      defcompile\n+  END\n+  CheckScriptFailure(lines, 'E488:')\n+enddef\n+\n def Test_return_type_wrong()\n   CheckScriptFailure([\n         'def Func(): number',\n@@ -2048,7 +2063,6 @@ func Test_free_dict_while_in_funcstack()\n endfunc\n \n def Run_Test_free_dict_while_in_funcstack()\n-\n   # this was freeing the TermRun() default argument dictionary while it was\n   # still referenced in a funcstack_T\n   var lines =<< trim END"
        },
        {
          "filename": "src/usercmd.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -1021,7 +1021,7 @@ may_get_cmd_block(exarg_T *eap, char_u *p, char_u **tofree, int *flags)\n \tchar_u\t    *line = NULL;\n \n \tga_init2(&ga, sizeof(char_u *), 10);\n-\tif (ga_add_string(&ga, p) == FAIL)\n+\tif (ga_copy_string(&ga, p) == FAIL)\n \t    return retp;\n \n \t// If the argument ends in \"}\" it must have been concatenated already\n@@ -1038,7 +1038,7 @@ may_get_cmd_block(exarg_T *eap, char_u *p, char_u **tofree, int *flags)\n \t\t    emsg(_(e_missing_rcurly));\n \t\t    break;\n \t\t}\n-\t\tif (ga_add_string(&ga, line) == FAIL)\n+\t\tif (ga_copy_string(&ga, line) == FAIL)\n \t\t    break;\n \t\tif (*skipwhite(line) == '}')\n \t\t    break;"
        },
        {
          "filename": "src/userfunc.c",
          "status": "modified",
          "additions": 32,
          "deletions": 30,
          "patch": "@@ -166,13 +166,13 @@ one_function_arg(\n \n /*\n  * Handle line continuation in function arguments or body.\n- * Get a next line, store it in \"eap\" if appropriate and use \"line_to_free\" to\n- * handle freeing the line later.\n+ * Get a next line, store it in \"eap\" if appropriate and put the line in\n+ * \"lines_to_free\" to free the line later.\n  */\n     static char_u *\n get_function_line(\n \texarg_T\t\t*eap,\n-\tchar_u\t\t**line_to_free,\n+\tgarray_T\t*lines_to_free,\n \tint\t\tindent,\n \tgetline_opt_T\tgetline_options)\n {\n@@ -184,10 +184,11 @@ get_function_line(\n \ttheline = eap->getline(':', eap->cookie, indent, getline_options);\n     if (theline != NULL)\n     {\n-\tif (*eap->cmdlinep == *line_to_free)\n+\tif (lines_to_free->ga_len > 0\n+\t\t&& *eap->cmdlinep == ((char_u **)lines_to_free->ga_data)\n+\t\t\t\t\t\t   [lines_to_free->ga_len - 1])\n \t    *eap->cmdlinep = theline;\n-\tvim_free(*line_to_free);\n-\t*line_to_free = theline;\n+\tga_add_string(lines_to_free, theline);\n     }\n \n     return theline;\n@@ -210,7 +211,7 @@ get_function_args(\n     garray_T\t*default_args,\n     int\t\tskip,\n     exarg_T\t*eap,\n-    char_u\t**line_to_free)\n+    garray_T\t*lines_to_free)\n {\n     int\t\tmustend = FALSE;\n     char_u\t*arg;\n@@ -241,7 +242,7 @@ get_function_args(\n \t\t\t && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))\n \t{\n \t    // End of the line, get the next one.\n-\t    char_u *theline = get_function_line(eap, line_to_free, 0,\n+\t    char_u *theline = get_function_line(eap, lines_to_free, 0,\n \t\t\t\t\t\t\t  GETLINE_CONCAT_CONT);\n \n \t    if (theline == NULL)\n@@ -677,7 +678,7 @@ get_function_body(\n \texarg_T\t    *eap,\n \tgarray_T    *newlines,\n \tchar_u\t    *line_arg_in,\n-\tchar_u\t    **line_to_free)\n+\tgarray_T    *lines_to_free)\n {\n     linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n     linenr_T\tsourcing_lnum_off;\n@@ -744,7 +745,7 @@ get_function_body(\n \t}\n \telse\n \t{\n-\t    theline = get_function_line(eap, line_to_free, indent,\n+\t    theline = get_function_line(eap, lines_to_free, indent,\n \t\t\t\t\t\t\t      getline_options);\n \t}\n \tif (KeyTyped)\n@@ -854,14 +855,20 @@ get_function_body(\n \t\t    {\n \t\t\t// Another command follows. If the line came from \"eap\"\n \t\t\t// we can simply point into it, otherwise we need to\n-\t\t\t// change \"eap->cmdlinep\".\n+\t\t\t// change \"eap->cmdlinep\" to point to the last fetched\n+\t\t\t// line.\n \t\t\teap->nextcmd = nextcmd;\n-\t\t\tif (*line_to_free != NULL\n-\t\t\t\t\t    && *eap->cmdlinep != *line_to_free)\n+\t\t\tif (lines_to_free->ga_len > 0\n+\t\t\t\t&& *eap->cmdlinep !=\n+\t\t\t\t\t    ((char_u **)lines_to_free->ga_data)\n+\t\t\t\t\t\t   [lines_to_free->ga_len - 1])\n \t\t\t{\n+\t\t\t    // *cmdlinep will be freed later, thus remove the\n+\t\t\t    // line from lines_to_free.\n \t\t\t    vim_free(*eap->cmdlinep);\n-\t\t\t    *eap->cmdlinep = *line_to_free;\n-\t\t\t    *line_to_free = NULL;\n+\t\t\t    *eap->cmdlinep = ((char_u **)lines_to_free->ga_data)\n+\t\t\t\t\t\t   [lines_to_free->ga_len - 1];\n+\t\t\t    --lines_to_free->ga_len;\n \t\t\t}\n \t\t    }\n \t\t    break;\n@@ -1118,7 +1125,6 @@ lambda_function_body(\n     garray_T\tnewlines;\n     char_u\t*cmdline = NULL;\n     int\t\tret = FAIL;\n-    char_u\t*line_to_free = NULL;\n     partial_T\t*pt;\n     char_u\t*name;\n     int\t\tlnum_save = -1;\n@@ -1144,12 +1150,9 @@ lambda_function_body(\n     }\n \n     ga_init2(&newlines, (int)sizeof(char_u *), 10);\n-    if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL)\n-    {\n-\tif (cmdline != line_to_free)\n-\t    vim_free(cmdline);\n+    if (get_function_body(&eap, &newlines, NULL,\n+\t\t\t\t\t     &evalarg->eval_tofree_ga) == FAIL)\n \tgoto erret;\n-    }\n \n     // When inside a lambda must add the function lines to evalarg.eval_ga.\n     evalarg->eval_break_count += newlines.ga_len;\n@@ -1208,8 +1211,6 @@ lambda_function_body(\n \t{\n \t    ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;\n \t    evalarg->eval_using_cmdline = TRUE;\n-\t    if (cmdline == line_to_free)\n-\t\tline_to_free = NULL;\n \t}\n     }\n     else\n@@ -1278,7 +1279,6 @@ lambda_function_body(\n erret:\n     if (lnum_save >= 0)\n \tSOURCING_LNUM = lnum_save;\n-    vim_free(line_to_free);\n     ga_clear_strings(&newlines);\n     if (newargs != NULL)\n \tga_clear_strings(newargs);\n@@ -3957,10 +3957,11 @@ list_functions(regmatch_T *regmatch)\n  * \":function\" also supporting nested \":def\".\n  * When \"name_arg\" is not NULL this is a nested function, using \"name_arg\" for\n  * the function name.\n+ * \"lines_to_free\" is a list of strings to be freed later.\n  * Returns a pointer to the function or NULL if no function defined.\n  */\n     ufunc_T *\n-define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)\n+define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free)\n {\n     int\t\tj;\n     int\t\tc;\n@@ -4229,7 +4230,7 @@ define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)\n     if (get_function_args(&p, ')', &newargs,\n \t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n \t\t\t NULL, &varargs, &default_args, eap->skip,\n-\t\t\t eap, line_to_free) == FAIL)\n+\t\t\t eap, lines_to_free) == FAIL)\n \tgoto errret_2;\n     whitep = p;\n \n@@ -4339,7 +4340,7 @@ define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)\n \n     // Do not define the function when getting the body fails and when\n     // skipping.\n-    if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL\n+    if (get_function_body(eap, &newlines, line_arg, lines_to_free) == FAIL\n \t    || eap->skip)\n \tgoto erret;\n \n@@ -4645,10 +4646,11 @@ define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)\n     void\n ex_function(exarg_T *eap)\n {\n-    char_u *line_to_free = NULL;\n+    garray_T lines_to_free;\n \n-    (void)define_function(eap, NULL, &line_to_free);\n-    vim_free(line_to_free);\n+    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n+    (void)define_function(eap, NULL, &lines_to_free);\n+    ga_clear_strings(&lines_to_free);\n }\n \n /*"
        },
        {
          "filename": "src/version.c",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -750,6 +750,8 @@ static char *(features[]) =\n \n static int included_patches[] =\n {   /* Add new patch number below this line */\n+/**/\n+    4040,\n /**/\n     4039,\n /**/"
        },
        {
          "filename": "src/vim9compile.c",
          "status": "modified",
          "additions": 10,
          "deletions": 7,
          "patch": "@@ -810,7 +810,7 @@ func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)\n  * Compile a nested :def command.\n  */\n     static char_u *\n-compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)\n+compile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)\n {\n     int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n     char_u\t*name_start = eap->arg;\n@@ -876,7 +876,7 @@ compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)\n \tgoto theend;\n     }\n \n-    ufunc = define_function(eap, lambda_name, line_to_free);\n+    ufunc = define_function(eap, lambda_name, lines_to_free);\n     if (ufunc == NULL)\n     {\n \tr = eap->skip ? OK : FAIL;\n@@ -2496,7 +2496,7 @@ compile_def_function(\n \tcctx_T\t\t*outer_cctx)\n {\n     char_u\t*line = NULL;\n-    char_u\t*line_to_free = NULL;\n+    garray_T\tlines_to_free;\n     char_u\t*p;\n     char\t*errormsg = NULL;\t// error message\n     cctx_T\tcctx;\n@@ -2514,6 +2514,9 @@ compile_def_function(\n #endif\n     int\t\tdebug_lnum = -1;\n \n+    // allocated lines are freed at the end\n+    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n+\n     // When using a function that was compiled before: Free old instructions.\n     // The index is reused.  Otherwise add a new entry in \"def_functions\".\n     if (ufunc->uf_dfunc_idx > 0)\n@@ -2681,8 +2684,8 @@ compile_def_function(\n \t    if (line != NULL)\n \t    {\n \t\tline = vim_strsave(line);\n-\t\tvim_free(line_to_free);\n-\t\tline_to_free = line;\n+\t\tif (ga_add_string(&lines_to_free, line) == FAIL)\n+\t\t    goto erret;\n \t    }\n \t}\n \n@@ -2926,7 +2929,7 @@ compile_def_function(\n \t    case CMD_def:\n \t    case CMD_function:\n \t\t    ea.arg = p;\n-\t\t    line = compile_nested_function(&ea, &cctx, &line_to_free);\n+\t\t    line = compile_nested_function(&ea, &cctx, &lines_to_free);\n \t\t    break;\n \n \t    case CMD_return:\n@@ -3236,7 +3239,7 @@ compile_def_function(\n     if (do_estack_push)\n \testack_pop();\n \n-    vim_free(line_to_free);\n+    ga_clear_strings(&lines_to_free);\n     free_imported(&cctx);\n     free_locals(&cctx);\n     ga_clear(&cctx.ctx_type_stack);"
        },
        {
          "filename": "src/viminfo.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -2730,7 +2730,7 @@ read_viminfo_barline(vir_T *virp, int got_encoding, int force, int writing)\n     {\n \t// Continuation line of an unrecognized item.\n \tif (writing)\n-\t    ga_add_string(&virp->vir_barlines, virp->vir_line);\n+\t    ga_copy_string(&virp->vir_barlines, virp->vir_line);\n     }\n     else\n     {\n@@ -2769,7 +2769,7 @@ read_viminfo_barline(vir_T *virp, int got_encoding, int force, int writing)\n \t    default:\n \t\t// copy unrecognized line (for future use)\n \t\tif (writing)\n-\t\t    ga_add_string(&virp->vir_barlines, virp->vir_line);\n+\t\t    ga_copy_string(&virp->vir_barlines, virp->vir_line);\n \t}\n \tfor (i = 0; i < values.ga_len; ++i)\n \t{"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "fb49e3cde79de4ce558c86d21a56eb9d60aeabd5",
            "date": "2025-01-25T15:18:51Z",
            "author_login": "chrisbra"
          },
          {
            "sha": "c729d6d154e097b439ff264b9736604824f4a5f4",
            "date": "2025-01-25T15:07:12Z",
            "author_login": "saccarosium"
          },
          {
            "sha": "d65aa1bbdb808ef8fecde6df240c48cc39a52a8e",
            "date": "2025-01-25T14:29:03Z",
            "author_login": "zeertzjq"
          },
          {
            "sha": "509a8d58f9a8ce00744114c1f21f0d951a559ecd",
            "date": "2025-01-25T14:26:09Z",
            "author_login": "pbnj"
          },
          {
            "sha": "99181205c5f8284a30f839107a12932924168f17",
            "date": "2025-01-25T13:54:28Z",
            "author_login": "chrisbra"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-416",
    "description": "vim is vulnerable to Use After Free",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-01-10T16:15:09.733",
    "last_modified": "2024-11-21T06:38:01.293",
    "fix_date": "2022-01-08T15:39:39Z"
  },
  "references": [
    {
      "url": "http://seclists.org/fulldisclosure/2022/Jul/13",
      "source": "security@huntr.dev",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://seclists.org/fulldisclosure/2022/Mar/29",
      "source": "security@huntr.dev",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2022/01/15/1",
      "source": "security@huntr.dev",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f",
      "source": "security@huntr.dev",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/47dded34-3767-4725-8c7c-9dcb68c70b36",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/3FH2J57GDA2WMBS6J56F6QQRA6BXQQFZ/",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HD5S2FC2HF22A7XQXK2XXIR46EARVWIM/",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202208-32",
      "source": "security@huntr.dev",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://support.apple.com/kb/HT213183",
      "source": "security@huntr.dev",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://support.apple.com/kb/HT213344",
      "source": "security@huntr.dev",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://seclists.org/fulldisclosure/2022/Jul/13",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://seclists.org/fulldisclosure/2022/Mar/29",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2022/01/15/1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/47dded34-3767-4725-8c7c-9dcb68c70b36",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/3FH2J57GDA2WMBS6J56F6QQRA6BXQQFZ/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HD5S2FC2HF22A7XQXK2XXIR46EARVWIM/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202208-32",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://support.apple.com/kb/HT213183",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://support.apple.com/kb/HT213344",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:37.063403",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "vim",
    "owner": "vim",
    "created_at": "2015-08-18T21:03:56Z",
    "updated_at": "2025-01-26T05:55:44Z",
    "pushed_at": "2025-01-25T15:21:53Z",
    "size": 155300,
    "stars": 37307,
    "forks": 5538,
    "open_issues": 1502,
    "watchers": 37307,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Vim Script": 19563490,
      "C": 14392521,
      "Roff": 576344,
      "Makefile": 496830,
      "C++": 246793,
      "NSIS": 179173,
      "M4": 159971,
      "Java": 85446,
      "Shell": 71333,
      "PostScript": 64070,
      "Module Management System": 56375,
      "Python": 51761,
      "XS": 51261,
      "Ruby": 40309,
      "JavaScript": 37774,
      "NewLisp": 37431,
      "Raku": 34258,
      "Emacs Lisp": 30304,
      "Perl": 29735,
      "SystemVerilog": 27883,
      "Smalltalk": 25762,
      "Awk": 19481,
      "Batchfile": 19124,
      "Objective-C": 13147,
      "DIGITAL Command Language": 10835,
      "HTML": 6885,
      "Prolog": 4336,
      "KRL": 4206,
      "MATLAB": 1970,
      "Thrift": 1670,
      "OpenEdge ABL": 1490,
      "sed": 826,
      "Tcl": 745,
      "Lua": 738,
      "BitBake": 388,
      "TeX": 225
    },
    "commit_activity": {
      "total_commits_last_year": 1869,
      "avg_commits_per_week": 35.94230769230769,
      "days_active_last_year": 322
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "vim"
    },
    "collected_at": "2025-01-26T07:35:34.408543"
  }
}