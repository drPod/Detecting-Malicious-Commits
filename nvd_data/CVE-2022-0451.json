{
  "cve_id": "CVE-2022-0451",
  "github_data": {
    "repository": "dart-lang/sdk",
    "fix_commit": "57db739be0ad4629079bfa94840064f615d35abc",
    "related_commits": [
      "57db739be0ad4629079bfa94840064f615d35abc",
      "57db739be0ad4629079bfa94840064f615d35abc"
    ],
    "patch_url": "https://github.com/dart-lang/sdk/commit/57db739be0ad4629079bfa94840064f615d35abc.patch",
    "fix_commit_details": {
      "sha": "57db739be0ad4629079bfa94840064f615d35abc",
      "commit_date": "2022-01-27T20:49:42Z",
      "author": {
        "login": "brianquinlan",
        "type": "User",
        "stats": {
          "total_commits": 140,
          "average_weekly_commits": 0.2017291066282421,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 72
        }
      },
      "commit_message": {
        "title": "Disable security-related headers on redirect.",
        "length": 339,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 234,
        "additions": 226,
        "deletions": 8
      },
      "files": [
        {
          "filename": "CHANGELOG.md",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -17,6 +17,13 @@\n - `IdbFactory.supportsDatabaseNames` has been deprecated. It will always return\n   `false`.\n \n+#### `dart:io`\n+\n+- **Breaking Change** [#45410](https://github.com/dart-lang/sdk/issues/45410):\n+  `HttpClient` no longer transmits some headers (i.e. `authorization`,\n+  `www-authenticate`, `cookie`, `cookie2`) when processing redirects to\n+  a different domain.\n+\n ### Tools\n \n #### Dart command line"
        },
        {
          "filename": "sdk/lib/_http/http.dart",
          "status": "modified",
          "additions": 33,
          "deletions": 2,
          "patch": "@@ -1715,8 +1715,39 @@ abstract class HttpClientRequest implements IOSink {\n   /// following the redirect.\n   ///\n   /// All headers added to the request will be added to the redirection\n-  /// request(s). However, any body send with the request will not be\n-  /// part of the redirection request(s).\n+  /// request(s) except when forwarding sensitive headers like\n+  /// \"Authorization\", \"WWW-Authenticate\", and \"Cookie\". Those headers\n+  /// will be skipped if following a redirect to a domain that is not a\n+  /// subdomain match or exact match of the initial domain.\n+  /// For example, a redirect from \"foo.com\" to either \"foo.com\" or\n+  /// \"sub.foo.com\" will forward the sensitive headers, but a redirect to\n+  /// \"bar.com\" will not.\n+  ///\n+  /// Any body send with the request will not be part of the redirection\n+  /// request(s).\n+  ///\n+  /// For precise control of redirect handling, set this property to `false`\n+  /// and make a separate HTTP request to process the redirect. For example:\n+  ///\n+  /// ```dart\n+  /// final client = HttpClient();\n+  /// var uri = Uri.parse(\"http://localhost/\");\n+  /// var request = await client.getUrl(uri);\n+  /// request.followRedirects = false;\n+  /// var response = await request.close();\n+  /// while (response.isRedirect) {\n+  ///   response.drain();\n+  ///   final location = response.headers.value(HttpHeaders.locationHeader);\n+  ///   if (location != null) {\n+  ///     uri = uri.resolve(location);\n+  ///     request = await client.getUrl(uri);\n+  ///     // Set the body or headers as desired.\n+  ///     request.followRedirects = false;\n+  ///     response = await request.close();\n+  ///   }\n+  /// }\n+  /// // Do something with the final response.\n+  /// ```\n   bool followRedirects = true;\n \n   /// Set this property to the maximum number of redirects to follow"
        },
        {
          "filename": "sdk/lib/_http/http_impl.dart",
          "status": "modified",
          "additions": 30,
          "deletions": 4,
          "patch": "@@ -667,7 +667,7 @@ class _HttpClientResponse extends _HttpInboundMessageListInt\n       }\n     }\n     return _httpClient\n-        ._openUrlFromRequest(method, url, _httpRequest)\n+        ._openUrlFromRequest(method, url, _httpRequest, isRedirect: true)\n         .then((request) {\n       request._responseRedirects\n         ..addAll(redirects)\n@@ -751,7 +751,8 @@ class _HttpClientResponse extends _HttpInboundMessageListInt\n       return drain().then((_) {\n         return _httpClient\n             ._openUrlFromRequest(\n-                _httpRequest.method, _httpRequest.uri, _httpRequest)\n+                _httpRequest.method, _httpRequest.uri, _httpRequest,\n+                isRedirect: false)\n             .then((request) => request.close());\n       });\n     }\n@@ -2715,8 +2716,31 @@ class _HttpClient implements HttpClient {\n     });\n   }\n \n+  static bool _isSubdomain(Uri subdomain, Uri domain) {\n+    return (subdomain.scheme == domain.scheme &&\n+        subdomain.port == domain.port &&\n+        (subdomain.host == domain.host ||\n+            subdomain.host.endsWith(\".\" + domain.host)));\n+  }\n+\n+  static bool _shouldCopyHeaderOnRedirect(\n+      String headerKey, Uri originalUrl, Uri redirectUri) {\n+    if (_isSubdomain(redirectUri, originalUrl)) {\n+      return true;\n+    }\n+\n+    const nonRedirectHeaders = [\n+      \"authorization\",\n+      \"www-authenticate\",\n+      \"cookie\",\n+      \"cookie2\"\n+    ];\n+    return !nonRedirectHeaders.contains(headerKey.toLowerCase());\n+  }\n+\n   Future<_HttpClientRequest> _openUrlFromRequest(\n-      String method, Uri uri, _HttpClientRequest previous) {\n+      String method, Uri uri, _HttpClientRequest previous,\n+      {required bool isRedirect}) {\n     // If the new URI is relative (to either '/' or some sub-path),\n     // construct a full URI from the previous one.\n     Uri resolved = previous.uri.resolveUri(uri);\n@@ -2728,7 +2752,9 @@ class _HttpClient implements HttpClient {\n         ..maxRedirects = previous.maxRedirects;\n       // Copy headers.\n       for (var header in previous.headers._headers.keys) {\n-        if (request.headers[header] == null) {\n+        if (request.headers[header] == null &&\n+            (!isRedirect ||\n+                _shouldCopyHeaderOnRedirect(header, resolved, previous.uri))) {\n           request.headers.set(header, previous.headers[header]!);\n         }\n       }"
        },
        {
          "filename": "tests/standalone/io/http_redirect_test.dart",
          "status": "modified",
          "additions": 78,
          "deletions": 1,
          "patch": "@@ -7,7 +7,7 @@ import \"package:expect/expect.dart\";\n import \"dart:async\";\n import \"dart:io\";\n \n-Future<HttpServer> setupServer() {\n+Future<HttpServer> setupServer({Uri? targetServer}) {\n   final completer = new Completer<HttpServer>();\n   HttpServer.bind(\"127.0.0.1\", 0).then((server) {\n     var handlers = new Map<String, Function>();\n@@ -128,16 +128,33 @@ Future<HttpServer> setupServer() {\n     // Setup redirect checking headers.\n     addRequestHandler(\"/src\", (HttpRequest request, HttpResponse response) {\n       Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n+      Expect.isNotNull(request.headers.value(\"Authorization\"),\n+          \"expected 'Authorization' header to be set\");\n       response.headers.set(\n           HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/target\");\n       response.statusCode = HttpStatus.movedPermanently;\n       response.close();\n     });\n     addRequestHandler(\"/target\", (HttpRequest request, HttpResponse response) {\n       Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n+      Expect.isNotNull(request.headers.value(\"Authorization\"),\n+          \"expected 'Authorization' header to be set\");\n       response.close();\n     });\n \n+    if (targetServer != null) {\n+      addRequestHandler(\"/src-crossdomain\",\n+          (HttpRequest request, HttpResponse response) {\n+        Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n+        Expect.isNotNull(request.headers.value(\"Authorization\"),\n+            \"expected 'Authorization' header to be set\");\n+        response.headers\n+            .set(HttpHeaders.locationHeader, targetServer.toString());\n+        response.statusCode = HttpStatus.movedPermanently;\n+        response.close();\n+      });\n+    }\n+\n     // Setup redirect for 301 where POST should not redirect.\n     addRequestHandler(\"/301src\", (HttpRequest request, HttpResponse response) {\n       Expect.equals(\"POST\", request.method);\n@@ -183,6 +200,36 @@ Future<HttpServer> setupServer() {\n   return completer.future;\n }\n \n+// A second HTTP server used to validate that redirect requests accross domains\n+// do *not* include security-related headers.\n+Future<HttpServer> setupTargetServer() {\n+  final completer = new Completer<HttpServer>();\n+  HttpServer.bind(\"127.0.0.1\", 0).then((server) {\n+    var handlers = new Map<String, Function>();\n+    addRequestHandler(\n+        String path, void handler(HttpRequest request, HttpResponse response)) {\n+      handlers[path] = handler;\n+    }\n+\n+    server.listen((HttpRequest request) {\n+      if (request.uri.path == \"/target\") {\n+        Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n+        Expect.isNull(request.headers.value(\"Authorization\"),\n+            \"expected 'Authorization' header to be removed on redirect\");\n+        request.response.close();\n+      } else {\n+        request.listen((_) {}, onDone: () {\n+          request.response.statusCode = 404;\n+          request.response.close();\n+        });\n+      }\n+    });\n+\n+    completer.complete(server);\n+  });\n+  return completer.future;\n+}\n+\n void checkRedirects(int redirectCount, HttpClientResponse response) {\n   if (redirectCount < 2) {\n     Expect.isTrue(response.redirects.isEmpty);\n@@ -250,6 +297,7 @@ void testManualRedirectWithHeaders() {\n         .then((HttpClientRequest request) {\n       request.followRedirects = false;\n       request.headers.add(\"X-Request-Header\", \"value\");\n+      request.headers.add(\"Authorization\", \"Basic ...\");\n       return request.close();\n     }).then(handleResponse);\n   });\n@@ -282,6 +330,7 @@ void testAutoRedirectWithHeaders() {\n         .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/src\"))\n         .then((HttpClientRequest request) {\n       request.headers.add(\"X-Request-Header\", \"value\");\n+      request.headers.add(\"Authorization\", \"Basic ...\");\n       return request.close();\n     }).then((HttpClientResponse response) {\n       response.listen((_) => Expect.fail(\"Response data not expected\"),\n@@ -294,6 +343,33 @@ void testAutoRedirectWithHeaders() {\n   });\n }\n \n+void testCrossDomainAutoRedirectWithHeaders() {\n+  setupTargetServer().then((targetServer) {\n+    setupServer(\n+            targetServer:\n+                Uri.parse(\"http://127.0.0.1:${targetServer.port}/target\"))\n+        .then((server) {\n+      HttpClient client = new HttpClient();\n+\n+      client\n+          .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/src-crossdomain\"))\n+          .then((HttpClientRequest request) {\n+        request.headers.add(\"X-Request-Header\", \"value\");\n+        request.headers.add(\"Authorization\", \"Basic ...\");\n+        return request.close();\n+      }).then((HttpClientResponse response) {\n+        response.listen((_) => Expect.fail(\"Response data not expected\"),\n+            onDone: () {\n+          Expect.equals(1, response.redirects.length);\n+          targetServer.close();\n+          server.close();\n+          client.close();\n+        });\n+      });\n+    });\n+  });\n+}\n+\n void testAutoRedirect301POST() {\n   setupServer().then((server) {\n     HttpClient client = new HttpClient();\n@@ -441,6 +517,7 @@ main() {\n   testManualRedirectWithHeaders();\n   testAutoRedirect();\n   testAutoRedirectWithHeaders();\n+  testCrossDomainAutoRedirectWithHeaders();\n   testAutoRedirect301POST();\n   testAutoRedirect303POST();\n   testAutoRedirectLimit();"
        },
        {
          "filename": "tests/standalone_2/io/http_redirect_test.dart",
          "status": "modified",
          "additions": 78,
          "deletions": 1,
          "patch": "@@ -9,7 +9,7 @@ import \"package:expect/expect.dart\";\n import \"dart:async\";\n import \"dart:io\";\n \n-Future<HttpServer> setupServer() {\n+Future<HttpServer> setupServer({Uri targetServer}) {\n   Completer completer = new Completer<HttpServer>();\n   HttpServer.bind(\"127.0.0.1\", 0).then((server) {\n     var handlers = new Map<String, Function>();\n@@ -130,16 +130,33 @@ Future<HttpServer> setupServer() {\n     // Setup redirect checking headers.\n     addRequestHandler(\"/src\", (HttpRequest request, HttpResponse response) {\n       Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n+      Expect.isNotNull(request.headers.value(\"Authorization\"),\n+          \"expected 'Authorization' header to be set\");\n       response.headers.set(\n           HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/target\");\n       response.statusCode = HttpStatus.movedPermanently;\n       response.close();\n     });\n     addRequestHandler(\"/target\", (HttpRequest request, HttpResponse response) {\n       Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n+      Expect.isNotNull(request.headers.value(\"Authorization\"),\n+          \"expected 'Authorization' header to be set\");\n       response.close();\n     });\n \n+    if (targetServer != null) {\n+      addRequestHandler(\"/src-crossdomain\",\n+          (HttpRequest request, HttpResponse response) {\n+        Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n+        Expect.isNotNull(request.headers.value(\"Authorization\"),\n+            \"expected 'Authorization' header to be set\");\n+        response.headers\n+            .set(HttpHeaders.locationHeader, targetServer.toString());\n+        response.statusCode = HttpStatus.movedPermanently;\n+        response.close();\n+      });\n+    }\n+\n     // Setup redirect for 301 where POST should not redirect.\n     addRequestHandler(\"/301src\", (HttpRequest request, HttpResponse response) {\n       Expect.equals(\"POST\", request.method);\n@@ -185,6 +202,36 @@ Future<HttpServer> setupServer() {\n   return completer.future;\n }\n \n+// A second HTTP server used to validate that redirect requests accross domains\n+// do *not* include security-related headers.\n+Future<HttpServer> setupTargetServer() {\n+  Completer completer = new Completer<HttpServer>();\n+  HttpServer.bind(\"127.0.0.1\", 0).then((server) {\n+    var handlers = new Map<String, Function>();\n+    addRequestHandler(\n+        String path, void handler(HttpRequest request, HttpResponse response)) {\n+      handlers[path] = handler;\n+    }\n+\n+    server.listen((HttpRequest request) {\n+      if (request.uri.path == \"/target\") {\n+        Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n+        Expect.isNull(request.headers.value(\"Authorization\"),\n+            \"expected 'Authorization' header to be removed on redirect\");\n+        request.response.close();\n+      } else {\n+        request.listen((_) {}, onDone: () {\n+          request.response.statusCode = 404;\n+          request.response.close();\n+        });\n+      }\n+    });\n+\n+    completer.complete(server);\n+  });\n+  return completer.future;\n+}\n+\n void checkRedirects(int redirectCount, HttpClientResponse response) {\n   if (redirectCount < 2) {\n     Expect.isTrue(response.redirects.isEmpty);\n@@ -252,6 +299,7 @@ void testManualRedirectWithHeaders() {\n         .then((HttpClientRequest request) {\n       request.followRedirects = false;\n       request.headers.add(\"X-Request-Header\", \"value\");\n+      request.headers.add(\"Authorization\", \"Basic ...\");\n       return request.close();\n     }).then(handleResponse);\n   });\n@@ -284,6 +332,7 @@ void testAutoRedirectWithHeaders() {\n         .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/src\"))\n         .then((HttpClientRequest request) {\n       request.headers.add(\"X-Request-Header\", \"value\");\n+      request.headers.add(\"Authorization\", \"Basic ...\");\n       return request.close();\n     }).then((HttpClientResponse response) {\n       response.listen((_) => Expect.fail(\"Response data not expected\"),\n@@ -296,6 +345,33 @@ void testAutoRedirectWithHeaders() {\n   });\n }\n \n+void testCrossDomainAutoRedirectWithHeaders() {\n+  setupTargetServer().then((targetServer) {\n+    setupServer(\n+            targetServer:\n+                Uri.parse(\"http://127.0.0.1:${targetServer.port}/target\"))\n+        .then((server) {\n+      HttpClient client = new HttpClient();\n+\n+      client\n+          .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/src-crossdomain\"))\n+          .then((HttpClientRequest request) {\n+        request.headers.add(\"X-Request-Header\", \"value\");\n+        request.headers.add(\"Authorization\", \"Basic ...\");\n+        return request.close();\n+      }).then((HttpClientResponse response) {\n+        response.listen((_) => Expect.fail(\"Response data not expected\"),\n+            onDone: () {\n+          Expect.equals(1, response.redirects.length);\n+          targetServer.close();\n+          server.close();\n+          client.close();\n+        });\n+      });\n+    });\n+  });\n+}\n+\n void testAutoRedirect301POST() {\n   setupServer().then((server) {\n     HttpClient client = new HttpClient();\n@@ -443,6 +519,7 @@ main() {\n   testManualRedirectWithHeaders();\n   testAutoRedirect();\n   testAutoRedirectWithHeaders();\n+  testCrossDomainAutoRedirectWithHeaders();\n   testAutoRedirect301POST();\n   testAutoRedirect303POST();\n   testAutoRedirectLimit();"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b5232ac632e26ffc4b4ca3d20afd51d337dbb39b",
            "date": "2025-01-14T19:06:10Z",
            "author_login": "Markzipan"
          },
          {
            "sha": "330cc916c6b5ecc76d52dc3daf1aea97184a363b",
            "date": "2025-01-14T18:31:26Z",
            "author_login": "stereotype441"
          },
          {
            "sha": "eafaa1173823e238eff5c9508a2e326da604ab7b",
            "date": "2025-01-14T18:27:18Z",
            "author_login": "scheglov"
          },
          {
            "sha": "6aeb1bffc1b3f1bd126d3904a2da7b1bdf42d004",
            "date": "2025-01-14T18:03:08Z",
            "author_login": "stereotype441"
          },
          {
            "sha": "52cc62938cb93ef747c57d66f19db06260145402",
            "date": "2025-01-14T17:54:23Z",
            "author_login": "rmacnak-google"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-305",
    "description": "Dart SDK contains the HTTPClient in dart:io library whcih includes authorization headers when handling cross origin redirects. These headers may be explicitly set and contain sensitive information. By default, HttpClient handles redirection logic. If a request is sent to example.com with authorization header and it redirects to an attackers site, they might not expect attacker site to receive authorization header. We recommend updating the Dart SDK to version 2.16.0 or beyond.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-02-18T14:15:07.817",
    "last_modified": "2024-11-21T06:38:39.097",
    "fix_date": "2022-01-27T20:49:42Z"
  },
  "references": [
    {
      "url": "https://dart-review.googlesource.com/c/sdk/+/229947",
      "source": "cve-coordination@google.com",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/dart-lang/sdk/commit/57db739be0ad4629079bfa94840064f615d35abc",
      "source": "cve-coordination@google.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://dart-review.googlesource.com/c/sdk/+/229947",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/dart-lang/sdk/commit/57db739be0ad4629079bfa94840064f615d35abc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:59.729023",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "sdk",
    "owner": "dart-lang",
    "created_at": "2015-05-16T14:14:58Z",
    "updated_at": "2025-01-14T14:41:25Z",
    "pushed_at": "2025-01-14T14:41:19Z",
    "size": 1476140,
    "stars": 10381,
    "forks": 1603,
    "open_issues": 8145,
    "watchers": 10381,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "beta",
      "dev",
      "main",
      "master",
      "stable"
    ],
    "languages": {
      "Dart": 145669978,
      "C++": 23871549,
      "C": 1579300,
      "Python": 1290938,
      "HTML": 702875,
      "Java": 589555,
      "JavaScript": 277923,
      "Shell": 107149,
      "GAP": 97087,
      "CSS": 76022,
      "ANTLR": 48460,
      "TeX": 37865,
      "SCSS": 22311,
      "Makefile": 10867,
      "Assembly": 8350,
      "Batchfile": 4772,
      "CMake": 1598,
      "Objective-C++": 854,
      "Dockerfile": 499
    },
    "commit_activity": {
      "total_commits_last_year": 5883,
      "avg_commits_per_week": 113.13461538461539,
      "days_active_last_year": 304
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T14:47:50.604306"
  }
}