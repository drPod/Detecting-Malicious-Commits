{
  "cve_id": "CVE-2022-0852",
  "github_data": {
    "repository": "oamg/convert2rhel",
    "fix_commit": "8d72fb030ed31116fdb256b327d299337b000af4",
    "related_commits": [
      "8d72fb030ed31116fdb256b327d299337b000af4",
      "8d72fb030ed31116fdb256b327d299337b000af4"
    ],
    "patch_url": "https://github.com/oamg/convert2rhel/commit/8d72fb030ed31116fdb256b327d299337b000af4.patch",
    "fix_commit_details": {
      "sha": "8d72fb030ed31116fdb256b327d299337b000af4",
      "commit_date": "2022-05-27T06:54:24Z",
      "author": {
        "login": "abadger",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Do not put the subscription-manager password onto the command line. (#492)",
        "length": 6492,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 1270,
        "additions": 983,
        "deletions": 287
      },
      "files": [
        {
          "filename": ".gitleaks.toml",
          "status": "added",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -0,0 +1,4 @@\n+[allowlist]\n+paths = [\n+    '''tests/integration/tier0/check-cve/test_cve_fixes.py''',\n+]"
        },
        {
          "filename": "convert2rhel/subscription.py",
          "status": "modified",
          "additions": 195,
          "deletions": 51,
          "patch": "@@ -109,21 +109,21 @@ def register_system():\n \n     # Loop the registration process until successful registration\n     attempt = 0\n-    while True and attempt < MAX_NUM_OF_ATTEMPTS_TO_SUBSCRIBE:\n-        registration_cmd = get_registration_cmd()\n-\n+    while attempt < MAX_NUM_OF_ATTEMPTS_TO_SUBSCRIBE:\n+        registration_cmd = RegistrationCommand.from_tool_opts(tool_opts)\n         attempt_msg = \"\"\n         if attempt > 0:\n             attempt_msg = \"Attempt %d of %d: \" % (attempt + 1, MAX_NUM_OF_ATTEMPTS_TO_SUBSCRIBE)\n         loggerinst.info(\"%sRegistering the system using subscription-manager ...\", attempt_msg)\n \n-        output, ret_code = call_registration_cmd(registration_cmd)\n+        output, ret_code = registration_cmd()\n         if ret_code == 0:\n             # Handling a signal interrupt that was previously handled by\n             # subscription-manager.\n             if \"user interrupted process\" in output.lower():\n                 raise KeyboardInterrupt\n             return\n+\n         loggerinst.info(\"System registration failed with return code = %s\" % str(ret_code))\n         if tool_opts.credentials_thru_cli:\n             loggerinst.warning(\n@@ -138,65 +138,209 @@ def register_system():\n     loggerinst.critical(\"Unable to register the system through subscription-manager.\")\n \n \n-def get_registration_cmd():\n-    \"\"\"Build a command for subscription-manager for registering the system.\"\"\"\n-    loggerinst.info(\"Building subscription-manager command ... \")\n-    registration_cmd = [\"subscription-manager\", \"register\", \"--force\"]\n-\n-    loggerinst.info(\"Checking for activation key ...\")\n-    if tool_opts.activation_key:\n-        # Activation key has been passed\n-        # -> username/password not required\n-        # -> organization required\n-        loggerinst.info(\"    ... activation key detected: %s\" % tool_opts.activation_key)\n-\n-        # TODO: Parse the output of 'subscription-manager orgs' and let the\n-        # user choose from the available organizations. If there's just one,\n-        # pick it automatically.\n-        # Organization is required when activation key is used\n+class RegistrationCommand(object):\n+    def __init__(self, activation_key=None, org=None, username=None, password=None, server_url=None):\n+        \"\"\"\n+        A callable that can register a system with subscription-manager.\n+\n+        :kwarg server_url: Optional URL to the subscription-manager backend.\n+            Useful when the customer has an on-prem subscription-manager instance.\n+        :kwarg activation_key: subscription-manager activation_key that can be\n+            used to register the system. Org must be specified if this was given.\n+        :kwarg org: The organization that the activation_key is associated with.\n+            It is required if activation_key is specified.\n+        :kwarg username: Username to authenticate with subscription-manager.\n+            Required if password is specified.\n+        :kwarg password: Password to authenticate with subscription-manager.\n+            It is required if username is specified.\n+\n+        .. note:: Either activation_key and org or username and password must\n+            be specified.\n+        \"\"\"\n+        self.cmd = \"subscription-manager\"\n+        self.server_url = server_url\n+\n+        if activation_key and not org:\n+            raise ValueError(\"org must be specified if activation_key is used\")\n+\n+        self.activation_key = activation_key\n+        self.org = org\n+\n+        self.password = password\n+        self.username = username\n+\n+        if (password and not username) or (username and not password):\n+            raise ValueError(\"username and password must be used together\")\n+\n+        elif not password:\n+            # No password set\n+            if not self.activation_key:\n+                raise ValueError(\"activation_key and org or username and password must be specified\")\n+\n+    @classmethod\n+    def from_tool_opts(cls, tool_opts):\n+        \"\"\"\n+        Alternate constructor that gets subscription-manager args from ToolOpts.\n+\n+        convert2rhel's command-line contains the information needed to register\n+        with subscription-manager. Get the information from the passed in\n+        ToolOpts structure to create the RegistrationCommand.\n+\n+        :arg tool_opts: The :class:`convert2rhel.toolopts.ToolOpts` structure to\n+            retrieve the subscription-manager information from.\n+        \"\"\"\n+        loggerinst.info(\"Gathering subscription-manager registration info ... \")\n+\n+        registration_attributes = {}\n         if tool_opts.org:\n-            loggerinst.info(\"    ... org detected\")\n-\n-        org = tool_opts.org\n-        while not org:\n-            org = utils.prompt_user(\"Organization: \")\n-\n-        registration_cmd.extend((\"--activationkey=%s\" % tool_opts.activation_key, \"--org=%s\" % org))\n-    else:\n-        loggerinst.info(\"    ... activation key not found, username and password required\")\n+            loggerinst.info(\"    ... organization detected\")\n+            registration_attributes[\"org\"] = tool_opts.org\n+\n+        if tool_opts.activation_key:\n+            # Activation key has been passed\n+            # -> username/password not required\n+            # -> organization required\n+            loggerinst.info(\"    ... activation key detected\")\n+            registration_attributes[\"activation_key\"] = tool_opts.activation_key\n+\n+            while \"org\" not in registration_attributes:\n+                loggerinst.info(\"    ... activation key requires organization\")\n+                # Organization is required when activation key is used\n+                # TODO: Parse the output of 'subscription-manager orgs' and let the\n+                # user choose from the available organizations. If there's just one,\n+                # pick it automatically.\n+                org = utils.prompt_user(\"Organization: \").strip()\n+                # In case the user entered the empty string\n+                if org:\n+                    registration_attributes[\"org\"] = org\n+        else:\n+            # No activation key -> username/password required\n+            if tool_opts.username and tool_opts.password:\n+                loggerinst.info(\"    ... activation key not found, using given username and password\")\n+            else:\n+                loggerinst.info(\"    ... activation key not found, username and password required\")\n+\n+            if tool_opts.username:\n+                loggerinst.info(\"    ... username detected\")\n+                username = tool_opts.username\n+            else:\n+                username = \"\"\n+                while not username:\n+                    username = utils.prompt_user(\"Username: \")\n+\n+            registration_attributes[\"username\"] = username\n+\n+            if tool_opts.password:\n+                loggerinst.info(\"    ... password detected\")\n+                password = tool_opts.password\n+            else:\n+                if tool_opts.username:\n+                    # Hint user for which username they need to enter pswd\n+                    loggerinst.info(\"Username: %s\", username)  # lgtm[py/clear-text-logging-sensitive-data]\n+                password = \"\"\n+                while not password:\n+                    password = utils.prompt_user(\"Password: \", password=True)\n+\n+            registration_attributes[\"password\"] = password\n+\n+        if tool_opts.serverurl:\n+            loggerinst.debug(\"    ... using custom RHSM URL\")\n+            registration_attributes[\"server_url\"] = tool_opts.serverurl\n+\n+        return cls(**registration_attributes)\n+\n+    @property\n+    def args(self):\n+        \"\"\"\n+        This property is a list of the command-line arguments that will be passed to\n+        subscription-manager to register the system. Set the individual attributes for\n+        :attr:`server_url`, :attr:`activation_key`, etc to affect the values here.\n+\n+        .. note:: :attr:`password` is not passed on the command line. Instead,\n+            it is sent to the running subscription-manager process via pexpect.\n+        \"\"\"\n+        args = [\"register\", \"--force\"]\n+\n+        if self.server_url:\n+            args.append(\"--serverurl=%s\" % self.server_url)\n+\n+        if self.activation_key:\n+            args.append(\"--activationkey=%s\" % self.activation_key)\n+\n+        if self.org:\n+            args.append(\"--org=%s\" % self.org)\n+\n+        if self.username:\n+            args.append(\"--username=%s\" % self.username)\n+\n+        return args\n+\n+    def __call__(self):\n+        \"\"\"\n+        Run the subscription-manager command.\n+\n+        Wrapper for running the subscription-manager command that keeps\n+        secrets secure.\n+        \"\"\"\n+        if self.password:\n+            loggerinst.debug(\n+                \"Calling command '%s %s'\" % (self.cmd, \" \".join(hide_secrets(self.args)))\n+            )  # lgtm[py/clear-text-logging-sensitive-data]\n+            output, ret_code = utils.run_cmd_in_pty(\n+                [self.cmd] + self.args, expect_script=((\"[Pp]assword: \", self.password + \"\\n\"),), print_cmd=False\n+            )\n+        else:\n+            # Warning: Currently activation_key can only be specified on the CLI. This is insecure\n+            # but there's nothing we can do about it for now. Once subscription-manager issue:\n+            # https://issues.redhat.com/browse/ENT-4724 is implemented, we can change both password\n+            # and activation_key to use a file-based approach to passing the secrets.\n+            output, ret_code = utils.run_subprocess([self.cmd] + self.args, print_cmd=False)\n \n-        if tool_opts.username:\n-            loggerinst.info(\"    ... username detected\")\n+        return output, ret_code\n \n-        username = tool_opts.username\n-        while not username:\n-            username = utils.prompt_user(\"Username: \")\n \n-        if tool_opts.password:\n-            loggerinst.info(\"    ... password detected\")\n+def hide_secrets(args):\n+    \"\"\"\n+    Replace secret values with asterisks.\n \n-        password = tool_opts.password\n-        while not password:\n-            password = utils.prompt_user(\"Password: \", password=True)\n+    This function takes a list of arguments which will be passed to\n+    subscription-manager on the command line and returns a new list\n+    that has any secret values obscured with asterisks.\n \n-        registration_cmd.extend((\"--username=%s\" % username, \"--password=%s\" % password))\n+    :arg args: An argument list for subscription-manager which may contain\n+        secret values.\n+    :returns: A new list of arguments with secret values hidden.\n+    \"\"\"\n+    obfuscation_string = \"*\" * 5\n+    secret_args = frozenset((\"--password\", \"--activationkey\", \"--token\"))\n \n-    if tool_opts.serverurl:\n-        loggerinst.debug(\"    ... using custom RHSM URL\")\n-        registration_cmd.append(\"--serverurl=%s\" % tool_opts.serverurl)\n+    sanitized_list = []\n+    hide_next = False\n+    for arg in args:\n+        if hide_next:\n+            # Second part of a two part secret argument (like --password *SECRET*)\n+            arg = obfuscation_string\n+            hide_next = False\n \n-    return registration_cmd\n+        elif arg in secret_args:\n+            # First part of a two part secret argument (like *--password* SECRET)\n+            hide_next = True\n \n+        else:\n+            # A secret argument in one part (like --password=SECRET)\n+            for problem_arg in secret_args:\n+                if arg.startswith(problem_arg + \"=\"):\n+                    arg = \"{0}={1}\".format(problem_arg, obfuscation_string)\n \n-def call_registration_cmd(registration_cmd):\n-    \"\"\"Wrapper for run_subprocess that avoids leaking password in the log.\"\"\"\n-    loggerinst.debug(\"Calling command '%s'\" % hide_password(\" \".join(registration_cmd)))\n-    return utils.run_subprocess(registration_cmd, print_cmd=False)\n+        sanitized_list.append(arg)\n \n+    if hide_next:\n+        loggerinst.debug(\n+            \"Passed arguments had unexpected secret argument,\"\n+            \" '{0}', without a secret\".format(sanitized_list[-1])  # lgtm[py/clear-text-logging-sensitive-data]\n+        )\n \n-def hide_password(cmd):\n-    \"\"\"Replace plaintext password with asterisks.\"\"\"\n-    return re.sub('--password=\".*?\"', '--password=\"*****\"', cmd)\n+    return sanitized_list\n \n \n def replace_subscription_manager():"
        },
        {
          "filename": "convert2rhel/unit_tests/README.md",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -49,7 +49,7 @@ def test_check_for_yum_updates(monkeypatch):\n     monkeypatch.setattr(package_handler, \"get_packages_to_update\", value=packages_to_update_mock)\n \n     assert package_handler.get_packages_to_update() is not None\n-    assert packages_to_update_mock.assert_called_once_with([\"package-1\", \"package-2\"])\n+    packages_to_update_mock.assert_called_once_with([\"package-1\", \"package-2\"])\n ```\n \n And this other example, of a test that don't need any mocks for external"
        },
        {
          "filename": "convert2rhel/unit_tests/conftest.py",
          "status": "modified",
          "additions": 8,
          "deletions": 1,
          "patch": "@@ -2,7 +2,7 @@\n \n import pytest\n \n-from convert2rhel import redhatrelease, utils\n+from convert2rhel import redhatrelease, toolopts, utils\n from convert2rhel.logger import setup_logger_handler\n from convert2rhel.systeminfo import system_info\n from convert2rhel.toolopts import tool_opts\n@@ -60,6 +60,13 @@ def setup_logger(tmpdir):\n     setup_logger_handler(log_name=\"convert2rhel\", log_dir=str(tmpdir))\n \n \n+@pytest.fixture\n+def global_tool_opts(monkeypatch):\n+    local_tool_opts = toolopts.ToolOpts()\n+    monkeypatch.setattr(toolopts, \"tool_opts\", local_tool_opts)\n+    return local_tool_opts\n+\n+\n @pytest.fixture()\n def pretend_os(request, pkg_root, monkeypatch):\n     \"\"\"Parametric fixture to pretend to be one of available OS for convertion."
        },
        {
          "filename": "convert2rhel/unit_tests/subscription_test.py",
          "status": "modified",
          "additions": 604,
          "deletions": 216,
          "patch": "@@ -22,10 +22,11 @@\n \n from collections import namedtuple\n \n+import pexpect\n import pytest\n \n from convert2rhel import unit_tests  # Imports unit_tests/__init__.py\n-from convert2rhel import pkghandler, subscription, utils\n+from convert2rhel import pkghandler, subscription, toolopts, utils\n from convert2rhel.systeminfo import system_info\n from convert2rhel.toolopts import tool_opts\n from convert2rhel.unit_tests import GetLoggerMocked, run_subprocess_side_effect\n@@ -45,77 +46,109 @@ def __call__(self, *args, **kwargs):\n         self.called += 1\n \n \n-class TestSubscription(unittest.TestCase):\n-    class GetOneSubMocked(unit_tests.MockFunction):\n-        def __call__(self, *args, **kwargs):\n-            Sub = namedtuple(\"Sub\", [\"pool_id\", \"sub_raw\"])\n+class RunSubprocessMocked(unit_tests.MockFunction):\n+    def __init__(self, tuples=None):\n+        # you can specify sequence of return (object, return code) as\n+        # a list of tuple that will be consumed continuosly on the each\n+        # call; when the list is consumed or it is empty, the default\n+        # tuple is returned\n+        self.tuples = tuples\n+        self.default_tuple = (\"output\", 0)\n+        self.called = 0\n+        self.cmd = []\n \n-            subscription1 = Sub(\"samplepool\", \"Subscription description\")\n-            return [subscription1]\n+    def __call__(self, cmd, *args, **kwargs):\n+        self.cmd = cmd\n+        self.called += 1\n \n-    class GetAvailSubsMocked(unit_tests.MockFunction):\n-        def __call__(self, *args, **kwargs):\n-            Sub = namedtuple(\"Sub\", [\"pool_id\", \"sub_raw\"])\n+        if self.tuples:\n+            return self.tuples.pop(0)\n+        return self.default_tuple\n \n-            subscription1 = Sub(\"samplepool\", \"Subscription description\")\n-            subscription2 = Sub(\"pool0\", \"sub desc\")\n-            return [subscription1, subscription2]\n \n-    class GetNoAvailSubsMocked(unit_tests.MockFunction):\n-        def __call__(self, *args, **kwargs):\n+class PromptUserLoopMocked(unit_tests.MockFunction):\n+    def __init__(self):\n+        self.called = {}\n+\n+    def __call__(self, *args, **kwargs):\n+        return_value = \"\"\n+\n+        # args[0] is the current question being asked\n+        if args[0] not in self.called:\n+            self.called[args[0]] = 0\n+\n+        if self.called[args[0]] >= 1:\n+            return_value = \"test\"\n+\n+        self.called[args[0]] += 1\n+        return return_value\n+\n+\n+class LetUserChooseItemMocked(unit_tests.MockFunction):\n+    def __init__(self):\n+        self.called = 0\n+\n+    def __call__(self, *args, **kwargs):\n+        self.called += 1\n+        return 0\n+\n+\n+class GetOneSubMocked(unit_tests.MockFunction):\n+    def __call__(self, *args, **kwargs):\n+        Sub = namedtuple(\"Sub\", [\"pool_id\", \"sub_raw\"])\n+\n+        subscription1 = Sub(\"samplepool\", \"Subscription description\")\n+        return [subscription1]\n+\n+\n+class GetAvailSubsMocked(unit_tests.MockFunction):\n+    def __call__(self, *args, **kwargs):\n+        Sub = namedtuple(\"Sub\", [\"pool_id\", \"sub_raw\"])\n+\n+        subscription1 = Sub(\"samplepool\", \"Subscription description\")\n+        subscription2 = Sub(\"pool0\", \"sub desc\")\n+        return [subscription1, subscription2]\n+\n+\n+class GetNoAvailSubsMocked(unit_tests.MockFunction):\n+    def __call__(self, *args, **kwargs):\n+        return []\n+\n+\n+class GetNoAvailSubsOnceMocked(unit_tests.MockFunction):\n+    def __init__(self):\n+        self.empty_last_call = False\n+\n+    def __call__(self, *args, **kwargs):\n+        if not self.empty_last_call:\n+            self.empty_last_call = True\n             return []\n \n-    class GetNoAvailSubsOnceMocked(unit_tests.MockFunction):\n-        def __init__(self):\n-            self.empty_last_call = False\n+        self.empty_last_call = False\n+        return [namedtuple(\"Sub\", [\"pool_id\", \"sub_raw\"])(\"samplepool\", \"Subscription description\")]\n \n-        def __call__(self, *args, **kwargs):\n-            if not self.empty_last_call:\n-                self.empty_last_call = True\n-                return []\n \n-            self.empty_last_call = False\n-            return [namedtuple(\"Sub\", [\"pool_id\", \"sub_raw\"])(\"samplepool\", \"Subscription description\")]\n+class RegistrationCmdCallMocked(unit_tests.MockFunction):\n+    def __init__(self):\n+        self.called = 0\n \n-    class LetUserChooseItemMocked(unit_tests.MockFunction):\n-        def __init__(self):\n-            self.called = 0\n+    def __call__(self):\n+        self.called += 1\n+        return (\"User interrupted process.\", 0)\n \n-        def __call__(self, *args, **kwargs):\n-            self.called += 1\n-            return 0\n-\n-    class GetRegistrationCmdMocked(unit_tests.MockFunction):\n-        def __call__(self):\n-            return \"subscription-manager register whatever-options\"\n-\n-    class CallRegistrationCmdMocked(unit_tests.MockFunction):\n-        def __init__(self, cmd):\n-            self.cmd = cmd\n-\n-        def __call__(self, cmd):\n-            self.cmd = cmd\n-            return (\"User interrupted process.\", 0)\n-\n-    class RunSubprocessMocked(unit_tests.MockFunction):\n-        def __init__(self, tuples=None):\n-            # you can specify sequence of return (object, return code) as\n-            # a list of tuple that will be consumed continuosly on the each\n-            # call; when the list is consumed or it is empty, the default\n-            # tuple is returned\n-            self.tuples = tuples\n-            self.default_tuple = (\"output\", 0)\n-            self.called = 0\n-            self.cmd = []\n \n-        def __call__(self, cmd, *args, **kwargs):\n-            self.cmd = cmd\n-            self.called += 1\n+class RegistrationCmdFromTooloptsMocked(unit_tests.MockFunction):\n+    def __init__(self):\n+        self.tool_opts = None\n+        self.called = 0\n+\n+    def __call__(self, tool_opts):\n+        self.called += 1\n+        self.tool_opts = tool_opts\n+        return RegistrationCmdCallMocked()\n \n-            if self.tuples:\n-                return self.tuples.pop(0)\n-            return self.default_tuple\n \n+class TestSubscription(unittest.TestCase):\n     class IsFileMocked(unit_tests.MockFunction):\n         def __init__(self, is_file):\n             self.is_file = is_file\n@@ -127,23 +160,6 @@ class PromptUserMocked(unit_tests.MockFunction):\n         def __call__(self, *args, **kwargs):\n             return True\n \n-    class PromptUserLoopMocked(unit_tests.MockFunction):\n-        def __init__(self):\n-            self.called = {}\n-\n-        def __call__(self, *args, **kwargs):\n-            return_value = \"\"\n-\n-            # args[0] is the current question being asked\n-            if args[0] not in self.called:\n-                self.called[args[0]] = 0\n-\n-            if self.called[args[0]] >= 1:\n-                return_value = \"test\"\n-\n-            self.called[args[0]] += 1\n-            return return_value\n-\n     class RemoveFileMocked(unit_tests.MockFunction):\n         def __init__(self, removed=True):\n             self.removed = removed\n@@ -175,138 +191,6 @@ def __call__(self, command, args):\n     def setUp(self):\n         tool_opts.__init__()\n \n-    def test_get_registration_cmd(self):\n-        tool_opts.username = \"user\"\n-        tool_opts.password = \"pass with space\"\n-        expected = [\"subscription-manager\", \"register\", \"--force\", \"--username=user\", \"--password=pass with space\"]\n-        self.assertEqual(subscription.get_registration_cmd(), expected)\n-\n-    @unit_tests.mock(subscription, \"get_avail_subs\", GetOneSubMocked())\n-    @unit_tests.mock(utils, \"let_user_choose_item\", LetUserChooseItemMocked())\n-    @unit_tests.mock(utils, \"run_subprocess\", RunSubprocessMocked())\n-    def test_attach_subscription_one_sub_available(self):\n-        self.assertEqual(subscription.attach_subscription(), True)\n-        self.assertEqual(utils.let_user_choose_item.called, 0)\n-\n-    def test_get_registration_cmd_activation_key(self):\n-        tool_opts.activation_key = \"activation_key\"\n-        tool_opts.org = \"org\"\n-        expected = [\"subscription-manager\", \"register\", \"--force\", \"--activationkey=activation_key\", \"--org=org\"]\n-        self.assertEqual(subscription.get_registration_cmd(), expected)\n-\n-    @unit_tests.mock(utils, \"prompt_user\", PromptUserLoopMocked())\n-    def test_get_registration_cmd_activation_key_empty_string(self):\n-        tool_opts.activation_key = \"activation_key\"\n-        expected = [\"subscription-manager\", \"register\", \"--force\", \"--activationkey=activation_key\", \"--org=test\"]\n-        self.assertEqual(subscription.get_registration_cmd(), expected)\n-        self.assertEqual(utils.prompt_user.called, {\"Organization: \": 2})\n-\n-    @unit_tests.mock(utils, \"prompt_user\", PromptUserLoopMocked())\n-    def test_get_registration_cmd_empty_string(self):\n-        expected = [\"subscription-manager\", \"register\", \"--force\", \"--username=test\", \"--password=test\"]\n-        self.assertEqual(subscription.get_registration_cmd(), expected)\n-        self.assertEqual(utils.prompt_user.called, {\"Username: \": 2, \"Password: \": 2})\n-\n-    @unit_tests.mock(subscription, \"get_avail_subs\", GetOneSubMocked())\n-    @unit_tests.mock(utils, \"let_user_choose_item\", LetUserChooseItemMocked())\n-    @unit_tests.mock(utils, \"run_subprocess\", RunSubprocessMocked())\n-    def test_attach_subscription_one_sub_available(self):\n-        self.assertEqual(subscription.attach_subscription(), True)\n-        self.assertEqual(utils.let_user_choose_item.called, 0)\n-\n-    @unit_tests.mock(subscription, \"get_avail_subs\", GetAvailSubsMocked())\n-    @unit_tests.mock(utils, \"let_user_choose_item\", LetUserChooseItemMocked())\n-    @unit_tests.mock(utils, \"run_subprocess\", RunSubprocessMocked())\n-    def test_attach_subscription_multiple_subs_available(self):\n-        self.assertEqual(subscription.attach_subscription(), True)\n-        self.assertEqual(utils.let_user_choose_item.called, 1)\n-\n-    @unit_tests.mock(subscription, \"get_avail_subs\", GetAvailSubsMocked())\n-    @unit_tests.mock(utils, \"let_user_choose_item\", LetUserChooseItemMocked())\n-    @unit_tests.mock(utils, \"run_subprocess\", RunSubprocessMocked())\n-    @unit_tests.mock(tool_opts, \"activation_key\", \"dummy_activate_key\")\n-    @unit_tests.mock(subscription, \"loggerinst\", GetLoggerMocked())\n-    def test_attach_subscription_available_with_activation_key(self):\n-        self.assertEqual(subscription.attach_subscription(), True)\n-        self.assertEqual(len(subscription.loggerinst.info_msgs), 1)\n-\n-    @unit_tests.mock(subscription, \"get_avail_subs\", GetNoAvailSubsMocked())\n-    def test_attach_subscription_none_available(self):\n-        self.assertEqual(subscription.attach_subscription(), False)\n-\n-    @unit_tests.mock(subscription, \"register_system\", DumbCallable())\n-    @unit_tests.mock(subscription, \"get_avail_subs\", GetAvailSubsMocked())\n-    @unit_tests.mock(utils, \"let_user_choose_item\", LetUserChooseItemMocked())\n-    @unit_tests.mock(utils, \"run_subprocess\", RunSubprocessMocked())\n-    def test_subscribe_system(self):\n-        tool_opts.username = \"user\"\n-        tool_opts.password = \"pass\"\n-        subscription.subscribe_system()\n-        self.assertEqual(subscription.register_system.called, 1)\n-\n-    @unit_tests.mock(subscription, \"register_system\", DumbCallable())\n-    @unit_tests.mock(subscription, \"get_avail_subs\", GetNoAvailSubsOnceMocked())\n-    @unit_tests.mock(utils, \"let_user_choose_item\", LetUserChooseItemMocked())\n-    @unit_tests.mock(utils, \"run_subprocess\", RunSubprocessMocked())\n-    def test_subscribe_system_fail_once(self):\n-        tool_opts.username = \"user\"\n-        tool_opts.password = \"pass\"\n-        subscription.subscribe_system()\n-        self.assertEqual(subscription.register_system.called, 2)\n-\n-    @unit_tests.mock(subscription, \"loggerinst\", GetLoggerMocked())\n-    @unit_tests.mock(subscription, \"MAX_NUM_OF_ATTEMPTS_TO_SUBSCRIBE\", 1)\n-    @unit_tests.mock(utils, \"run_subprocess\", RunSubprocessMocked([(\"nope\", 1)]))\n-    @unit_tests.mock(subscription, \"sleep\", mock.Mock())\n-    def test_register_system_fail_non_interactive(self):\n-        # Check the critical severity is logged when the credentials are given\n-        # on the cmdline but registration fails\n-        tool_opts.username = \"user\"\n-        tool_opts.password = \"pass\"\n-        tool_opts.credentials_thru_cli = True\n-        self.assertRaises(SystemExit, subscription.register_system)\n-        self.assertEqual(len(subscription.loggerinst.critical_msgs), 1)\n-\n-    @unit_tests.mock(utils, \"run_subprocess\", RunSubprocessMocked(tuples=[(\"nope\", 1), (\"nope\", 2), (\"Success\", 0)]))\n-    @unit_tests.mock(subscription.logging, \"getLogger\", GetLoggerMocked())\n-    @unit_tests.mock(subscription, \"get_registration_cmd\", GetRegistrationCmdMocked())\n-    @unit_tests.mock(subscription, \"sleep\", mock.Mock())\n-    def test_register_system_fail_interactive(self):\n-        # Check the function tries to register multiple times without\n-        # critical log.\n-        tool_opts.credentials_thru_cli = False\n-        subscription.register_system()\n-        self.assertEqual(utils.run_subprocess.called, 3)\n-        self.assertEqual(len(subscription.logging.getLogger.critical_msgs), 0)\n-\n-    @unit_tests.mock(subscription, \"get_registration_cmd\", GetRegistrationCmdMocked())\n-    @unit_tests.mock(subscription, \"call_registration_cmd\", CallRegistrationCmdMocked(\"cmd\"))\n-    def test_register_system_fail_with_keyboardinterrupt(self):\n-        self.assertRaises(KeyboardInterrupt, subscription.register_system)\n-\n-    def test_hiding_password(self):\n-        test_cmd = \"subscription-manager register --force \" '--username=jdoe --password=\"%s\" --org=0123'\n-        pswds_to_test = [\"my favourite password\", \"\\\\)(*&^%f %##@^%&*&^(\", \" \", \"\"]\n-        for pswd in pswds_to_test:\n-            sanitized_cmd = subscription.hide_password(test_cmd % pswd)\n-            self.assertEqual(\n-                sanitized_cmd, \"subscription-manager register --force \" '--username=jdoe --password=\"*****\" --org=0123'\n-            )\n-\n-    def test_rhsm_serverurl(self):\n-        tool_opts.username = \"user\"\n-        tool_opts.password = \"pass\"\n-        tool_opts.serverurl = \"url\"\n-        expected = [\n-            \"subscription-manager\",\n-            \"register\",\n-            \"--force\",\n-            \"--username=user\",\n-            \"--password=pass\",\n-            \"--serverurl=url\",\n-        ]\n-        self.assertEqual(subscription.get_registration_cmd(), expected)\n-\n     @unit_tests.mock(subscription.logging, \"getLogger\", GetLoggerMocked())\n     def test_get_pool_id(self):\n         # Check that we can distill the pool id from the subscription description\n@@ -487,6 +371,505 @@ def __call__(self, pkg, dest, reposdir=None):\n             return self.to_return\n \n \n+@pytest.fixture\n+def tool_opts(global_tool_opts, monkeypatch):\n+    monkeypatch.setattr(subscription, \"tool_opts\", global_tool_opts)\n+    return global_tool_opts\n+\n+\n+class TestSubscribeSystem(object):\n+    def test_subscribe_system(self, tool_opts, monkeypatch):\n+        monkeypatch.setattr(subscription, \"register_system\", DumbCallable())\n+        monkeypatch.setattr(subscription, \"get_avail_subs\", GetAvailSubsMocked())\n+        monkeypatch.setattr(utils, \"let_user_choose_item\", LetUserChooseItemMocked())\n+        monkeypatch.setattr(utils, \"run_subprocess\", RunSubprocessMocked())\n+\n+        tool_opts.username = \"user\"\n+        tool_opts.password = \"pass\"\n+\n+        subscription.subscribe_system()\n+\n+        assert subscription.register_system.called == 1\n+\n+    def test_subscribe_system_fail_once(self, tool_opts, monkeypatch):\n+        monkeypatch.setattr(subscription, \"register_system\", DumbCallable())\n+        monkeypatch.setattr(subscription, \"get_avail_subs\", GetNoAvailSubsOnceMocked())\n+        monkeypatch.setattr(utils, \"let_user_choose_item\", LetUserChooseItemMocked())\n+        monkeypatch.setattr(utils, \"run_subprocess\", RunSubprocessMocked())\n+\n+        tool_opts.username = \"user\"\n+        tool_opts.password = \"pass\"\n+\n+        subscription.subscribe_system()\n+\n+        assert subscription.register_system.called == 2\n+\n+\n+@pytest.mark.usefixtures(\"tool_opts\", scope=\"function\")\n+class TestAttachSubscription(object):\n+    def test_attach_subscription_one_sub_available(self, monkeypatch):\n+        monkeypatch.setattr(subscription, \"get_avail_subs\", GetOneSubMocked())\n+        monkeypatch.setattr(utils, \"let_user_choose_item\", LetUserChooseItemMocked())\n+        monkeypatch.setattr(utils, \"run_subprocess\", RunSubprocessMocked())\n+\n+        assert subscription.attach_subscription() is True\n+        assert utils.let_user_choose_item.called == 0\n+\n+    def test_attach_subscription_multiple_subs_available(self, monkeypatch):\n+        monkeypatch.setattr(subscription, \"get_avail_subs\", GetAvailSubsMocked())\n+        monkeypatch.setattr(utils, \"let_user_choose_item\", LetUserChooseItemMocked())\n+        monkeypatch.setattr(utils, \"run_subprocess\", RunSubprocessMocked())\n+\n+        assert subscription.attach_subscription() is True\n+        assert utils.let_user_choose_item.called == 1\n+\n+    def test_attach_subscription_available_with_activation_key(self, monkeypatch, caplog):\n+        monkeypatch.setattr(subscription, \"get_avail_subs\", GetAvailSubsMocked())\n+        monkeypatch.setattr(utils, \"let_user_choose_item\", LetUserChooseItemMocked())\n+        monkeypatch.setattr(utils, \"run_subprocess\", RunSubprocessMocked())\n+        monkeypatch.setattr(toolopts.tool_opts, \"activation_key\", \"dummy_activation_key\")\n+\n+        assert subscription.attach_subscription() is True\n+        assert len(caplog.records) == 1\n+        assert caplog.records[0].levelname == \"INFO\"\n+\n+    def test_attach_subscription_none_available(self, monkeypatch):\n+        monkeypatch.setattr(subscription, \"get_avail_subs\", GetNoAvailSubsMocked())\n+\n+        assert subscription.attach_subscription() is False\n+\n+\n+class TestRegisterSystem(object):\n+    def test_register_system_fail_non_interactive(self, tool_opts, monkeypatch, caplog):\n+        \"\"\"Check the critical severity is logged when the credentials are given on the cmdline but registration fails.\"\"\"\n+        monkeypatch.setattr(subscription, \"MAX_NUM_OF_ATTEMPTS_TO_SUBSCRIBE\", 1)\n+        monkeypatch.setattr(subscription, \"sleep\", mock.Mock())\n+\n+        fake_spawn = mock.Mock()\n+        fake_spawn.before.decode = mock.Mock(return_value=\"nope\")\n+        fake_spawn.exitstatus = 1\n+        monkeypatch.setattr(utils, \"PexpectSizedWindowSpawn\", fake_spawn)\n+\n+        tool_opts.username = \"user\"\n+        tool_opts.password = \"pass\"\n+        tool_opts.credentials_thru_cli = True\n+\n+        with pytest.raises(SystemExit):\n+            subscription.register_system()\n+\n+        assert caplog.records[-1].levelname == \"CRITICAL\"\n+\n+    def test_register_system_fail_interactive(self, tool_opts, monkeypatch, caplog):\n+        \"\"\"Check the function tries to register multiple times without critical log.\"\"\"\n+        tool_opts.credentials_thru_cli = False\n+        monkeypatch.setattr(subscription, \"sleep\", mock.Mock())\n+\n+        fake_from_tool_opts = mock.Mock(\n+            return_value=subscription.RegistrationCommand(username=\"invalid\", password=\"invalid\")\n+        )\n+        monkeypatch.setattr(subscription.RegistrationCommand, \"from_tool_opts\", fake_from_tool_opts)\n+\n+        # We may want to move this to the toplevel if we have other needs to\n+        # test pexpect driven code.  If we do so, though, we would want to\n+        # make it a bit more generic:\n+        # * Be able to set iterations before success\n+        # * Allow setting both exitstatus and signalstatus\n+        # * Allow setting stdout output\n+        # * Probably make the output and status settable per invocation rather\n+        #   than using a count\n+        class FakeProcess(mock.Mock):\n+            called_count = 0\n+\n+            @property\n+            def exitstatus(self):\n+                self.called_count += 1\n+                return self.called_count % 3\n+\n+        fake_process = FakeProcess()\n+        fake_process.before.decode = mock.Mock(side_effect=(\"nope\", \"nope\", \"Success\"))\n+        fake_spawn = mock.Mock(return_value=fake_process)\n+        monkeypatch.setattr(utils, \"PexpectSizedWindowSpawn\", fake_spawn)\n+\n+        subscription.register_system()\n+\n+        assert len(fake_spawn.call_args_list) == 3\n+        assert \"CRITICAL\" not in [rec.levelname for rec in caplog.records]\n+\n+    def test_register_system_fail_with_keyboardinterrupt(self, monkeypatch):\n+        monkeypatch.setattr(subscription.RegistrationCommand, \"from_tool_opts\", RegistrationCmdFromTooloptsMocked())\n+\n+        with pytest.raises(KeyboardInterrupt) as err:\n+            subscription.register_system()\n+\n+\n+class TestRegistrationCommand(object):\n+    @pytest.mark.parametrize(\n+        \"registration_kwargs\",\n+        (\n+            {\n+                \"server_url\": \"http://localhost/\",\n+                \"activation_key\": \"0xDEADBEEF\",\n+                \"org\": \"Local Organization\",\n+            },\n+            {\n+                \"server_url\": \"http://localhost/\",\n+                \"org\": \"Local Organization\",\n+                \"username\": \"me_myself_and_i\",\n+                \"password\": \"a password\",\n+            },\n+            {\n+                \"username\": \"me_myself_and_i\",\n+                \"password\": \"a password\",\n+            },\n+        ),\n+    )\n+    def test_instantiate_via_init(self, registration_kwargs):\n+        \"\"\"Test all valid combinations of args to RegistratoinCommand.__init__().\"\"\"\n+        reg_cmd = subscription.RegistrationCommand(**registration_kwargs)\n+        assert reg_cmd.cmd == \"subscription-manager\"\n+\n+        if \"server_url\" in registration_kwargs:\n+            assert reg_cmd.server_url == registration_kwargs[\"server_url\"]\n+\n+        if \"activation_key\" in registration_kwargs:\n+            assert reg_cmd.activation_key == registration_kwargs[\"activation_key\"]\n+\n+        if \"org\" in registration_kwargs:\n+            assert reg_cmd.org == registration_kwargs[\"org\"]\n+\n+        if \"password\" in registration_kwargs:\n+            assert reg_cmd.password == registration_kwargs[\"password\"]\n+            assert reg_cmd.username == registration_kwargs[\"username\"]\n+\n+        assert reg_cmd.activation_key or reg_cmd.username\n+\n+    @pytest.mark.parametrize(\n+        \"registration_kwargs, error_message\",\n+        (\n+            # No credentials specified\n+            (\n+                {\n+                    \"server_url\": \"http://localhost/\",\n+                    \"org\": \"Local Organization\",\n+                },\n+                \"activation_key and org or username and password must be specified\",\n+            ),\n+            # Activation key without an org\n+            (\n+                {\n+                    \"server_url\": \"http://localhost/\",\n+                    \"activation_key\": \"0xDEADBEEF\",\n+                },\n+                \"org must be specified if activation_key is used\",\n+            ),\n+            # Username without a password\n+            (\n+                {\n+                    \"server_url\": \"http://localhost/\",\n+                    \"username\": \"me_myself_and_i\",\n+                },\n+                \"username and password must be used together\",\n+            ),\n+            # Password without a username\n+            (\n+                {\n+                    \"server_url\": \"http://localhost/\",\n+                    \"password\": \"a password\",\n+                },\n+                \"username and password must be used together\",\n+            ),\n+        ),\n+    )\n+    def test_instantiate_failures(self, registration_kwargs, error_message):\n+        \"\"\"Test various failures instantiating RegistrationCommand.\"\"\"\n+        with pytest.raises(ValueError, match=error_message):\n+            cmd = subscription.RegistrationCommand(**registration_kwargs)\n+\n+    @pytest.mark.parametrize(\n+        \"registration_kwargs\",\n+        (\n+            {\n+                \"server_url\": \"http://localhost/\",\n+                \"activation_key\": \"0xDEADBEEF\",\n+                \"org\": \"Local Organization\",\n+            },\n+            {\n+                \"server_url\": \"http://localhost/\",\n+                \"org\": \"Local Organization\",\n+                \"username\": \"me_myself_and_i\",\n+                \"password\": \"a password\",\n+            },\n+            {\n+                \"username\": \"me_myself_and_i\",\n+                \"password\": \"a password\",\n+            },\n+        ),\n+    )\n+    def test_from_tool_opts_all_data_on_cli(self, registration_kwargs, tool_opts):\n+        \"\"\"Test that the RegistrationCommand is created from toolopts successfully.\"\"\"\n+        if \"server_url\" in registration_kwargs:\n+            tool_opts.serverurl = registration_kwargs[\"server_url\"]\n+\n+        if \"org\" in registration_kwargs:\n+            tool_opts.org = registration_kwargs[\"org\"]\n+\n+        if \"activation_key\" in registration_kwargs:\n+            tool_opts.activation_key = registration_kwargs[\"activation_key\"]\n+\n+        if \"username\" in registration_kwargs:\n+            tool_opts.username = registration_kwargs[\"username\"]\n+\n+        if \"password\" in registration_kwargs:\n+            tool_opts.password = registration_kwargs[\"password\"]\n+\n+        reg_cmd = subscription.RegistrationCommand.from_tool_opts(tool_opts)\n+\n+        assert reg_cmd.cmd == \"subscription-manager\"\n+\n+        if \"server_url\" in registration_kwargs:\n+            assert reg_cmd.server_url == registration_kwargs[\"server_url\"]\n+\n+        if \"org\" in registration_kwargs:\n+            assert reg_cmd.org == registration_kwargs[\"org\"]\n+\n+        if \"activation_key\" in registration_kwargs:\n+            assert reg_cmd.activation_key == registration_kwargs[\"activation_key\"]\n+\n+        if \"username\" in registration_kwargs:\n+            assert reg_cmd.username == registration_kwargs[\"username\"]\n+\n+        if \"password\" in registration_kwargs:\n+            assert reg_cmd.password == registration_kwargs[\"password\"]\n+\n+    @pytest.mark.parametrize(\n+        \"registration_kwargs, prompt_input\",\n+        (\n+            # activation_key and not org\n+            (\n+                {\"activation_key\": \"0xDEADBEEF\"},\n+                {\"Organization: \": \"Local Organization\"},\n+            ),\n+            # no activation_key no password\n+            (\n+                {\"username\": \"me_myself_and_i\"},\n+                {\"Password: \": \"a password\"},\n+            ),\n+            # no activation_key no username\n+            (\n+                {\"password\": \"a password\"},\n+                {\"Username: \": \"me_myself_and_i\"},\n+            ),\n+            # no credentials at all\n+            (\n+                {},\n+                {\"Username: \": \"me_myself_and_i\", \"Password: \": \"a password\"},\n+            ),\n+        ),\n+    )\n+    def test_from_tool_opts_interactive_data(self, registration_kwargs, prompt_input, tool_opts, monkeypatch):\n+        \"\"\"Test that things work when we interactively ask for more data.\"\"\"\n+\n+        def prompt_user(prompt, password=False):\n+            if prompt in prompt_input:\n+                return prompt_input[prompt]\n+            raise Exception(\"Should not have been called with that prompt for the input\")\n+\n+        fake_prompt_user = mock.Mock(side_effect=prompt_user)\n+\n+        monkeypatch.setattr(utils, \"prompt_user\", fake_prompt_user)\n+\n+        for option_name, option_value in registration_kwargs.items():\n+            setattr(tool_opts, option_name, option_value)\n+\n+        registration_cmd = subscription.RegistrationCommand.from_tool_opts(tool_opts)\n+\n+        if \"Organization: \" in prompt_input:\n+            assert registration_cmd.org == prompt_input[\"Organization: \"]\n+\n+        if \"Password: \" in prompt_input:\n+            assert registration_cmd.password == prompt_input[\"Password: \"]\n+\n+        if \"Username: \" in prompt_input:\n+            assert registration_cmd.username == prompt_input[\"Username: \"]\n+\n+        # assert that we prompted the user the number of times that we expected\n+        assert fake_prompt_user.call_count == len(prompt_input)\n+\n+    def test_from_tool_opts_activation_key_empty_string(self, tool_opts, monkeypatch):\n+        monkeypatch.setattr(utils, \"prompt_user\", PromptUserLoopMocked())\n+        tool_opts.activation_key = \"activation_key\"\n+\n+        registration_cmd = subscription.RegistrationCommand.from_tool_opts(tool_opts)\n+\n+        assert registration_cmd.activation_key == \"activation_key\"\n+        assert registration_cmd.org == \"test\"\n+        assert utils.prompt_user.called == {\"Organization: \": 2}\n+\n+    def test_from_tool_opts_username_empty_string(self, tool_opts, monkeypatch):\n+        monkeypatch.setattr(utils, \"prompt_user\", PromptUserLoopMocked())\n+\n+        registration_cmd = subscription.RegistrationCommand.from_tool_opts(tool_opts)\n+\n+        assert registration_cmd.username == \"test\"\n+        assert registration_cmd.password == \"test\"\n+        assert utils.prompt_user.called == {\"Username: \": 2, \"Password: \": 2}\n+\n+    @pytest.mark.parametrize(\n+        \"registration_kwargs\",\n+        (\n+            {\n+                \"server_url\": \"http://localhost/\",\n+                \"activation_key\": \"0xDEADBEEF\",\n+                \"org\": \"Local Organization\",\n+            },\n+            {\n+                \"server_url\": \"http://localhost/\",\n+                \"org\": \"Local Organization\",\n+                \"username\": \"me_myself_and_i\",\n+                \"password\": \"a password\",\n+            },\n+            {\n+                \"username\": \"me_myself_and_i\",\n+                \"password\": \"a password\",\n+            },\n+        ),\n+    )\n+    def test_args(self, registration_kwargs):\n+        \"\"\"Test that the argument list is generated correctly.\"\"\"\n+        reg_cmd = subscription.RegistrationCommand(**registration_kwargs)\n+\n+        args_list = reg_cmd.args\n+\n+        # Assert that these are always added\n+        assert args_list[0] == \"register\"\n+        assert \"--force\" in args_list\n+\n+        # Assert that password was not added to the args_list\n+        assert len([arg for arg in args_list if \"password\" in arg]) == 0\n+\n+        # Assert the other args were added\n+        if \"server_url\" in registration_kwargs:\n+            assert \"--serverurl={server_url}\".format(**registration_kwargs) in args_list\n+\n+        if \"activation_key\" in registration_kwargs:\n+            assert \"--activationkey={activation_key}\".format(**registration_kwargs) in args_list\n+\n+        if \"org\" in registration_kwargs:\n+            assert \"--org={org}\".format(**registration_kwargs) in args_list\n+\n+        if \"username\" in registration_kwargs:\n+            assert \"--username={username}\".format(**registration_kwargs) in args_list\n+\n+        expected_length = len(registration_kwargs) + 2\n+        if \"password\" in registration_kwargs:\n+            expected_length -= 1\n+\n+        assert len(args_list) == expected_length\n+\n+    def test_calling_registration_command_activation_key(self, monkeypatch):\n+        monkeypatch.setattr(utils, \"run_subprocess\", mock.Mock(return_value=(\"\", 0)))\n+        monkeypatch.setattr(utils, \"run_cmd_in_pty\", mock.Mock(return_value=(\"\", 0)))\n+\n+        reg_cmd = subscription.RegistrationCommand(activation_key=\"0xDEADBEEF\", org=\"Local Organization\")\n+        assert reg_cmd() == (\"\", 0)\n+\n+        utils.run_subprocess.assert_called_once_with(\n+            [\"subscription-manager\", \"register\", \"--force\", \"--activationkey=0xDEADBEEF\", \"--org=Local Organization\"],\n+            print_cmd=False,\n+        )\n+        assert utils.run_cmd_in_pty.call_count == 0\n+\n+    def test_calling_registration_command_password(self, monkeypatch):\n+        monkeypatch.setattr(utils, \"run_subprocess\", mock.Mock(return_value=(\"\", 0)))\n+        monkeypatch.setattr(utils, \"run_cmd_in_pty\", mock.Mock(return_value=(\"\", 0)))\n+\n+        reg_cmd = subscription.RegistrationCommand(username=\"me_myself_and_i\", password=\"a password\")\n+        reg_cmd()\n+\n+        utils.run_cmd_in_pty.assert_called_once_with(\n+            [\"subscription-manager\", \"register\", \"--force\", \"--username=me_myself_and_i\"],\n+            expect_script=((\"[Pp]assword: \", \"a password\\n\"),),\n+            print_cmd=False,\n+        )\n+        assert utils.run_cmd_in_pty.call_count == 1\n+\n+        assert utils.run_subprocess.call_count == 0\n+\n+\n+@pytest.mark.parametrize(\n+    (\"secret\",),\n+    (\n+        (\"my favourite password\",),\n+        (\"\\\\)(*&^%f %##@^%&*&^(\",),\n+        (\" \",),\n+        (\"\",),\n+    ),\n+)\n+def test_hide_secrets(secret):\n+    test_cmd = [\n+        \"register\",\n+        \"--force\",\n+        \"--username=jdoe\",\n+        \"--password\",\n+        secret,\n+        \"--org=0123\",\n+        \"--activationkey=%s\" % secret,\n+    ]\n+    sanitized_cmd = subscription.hide_secrets(test_cmd)\n+    assert sanitized_cmd == [\n+        \"register\",\n+        \"--force\",\n+        \"--username=jdoe\",\n+        \"--password\",\n+        \"*****\",\n+        \"--org=0123\",\n+        \"--activationkey=*****\",\n+    ]\n+\n+\n+def test_hide_secrets_no_secrets():\n+    \"\"\"Test that a list with no secrets to hide is not modified.\"\"\"\n+    test_cmd = [\n+        \"register\",\n+        \"--force\",\n+        \"--username=jdoe\",\n+        \"--org=0123\",\n+    ]\n+    sanitized_cmd = subscription.hide_secrets(test_cmd)\n+    assert sanitized_cmd == [\n+        \"register\",\n+        \"--force\",\n+        \"--username=jdoe\",\n+        \"--org=0123\",\n+    ]\n+\n+\n+def test_hide_secret_unexpected_input(caplog):\n+    test_cmd = [\n+        \"register\",\n+        \"--force\",\n+        \"--password=SECRETS\",\n+        \"--username=jdoe\",\n+        \"--org=0123\",\n+        \"--activationkey\",\n+        # This is missing the activationkey as the second argument\n+    ]\n+\n+    sanitized_cmd = subscription.hide_secrets(test_cmd)\n+\n+    assert sanitized_cmd == [\n+        \"register\",\n+        \"--force\",\n+        \"--password=*****\",\n+        \"--username=jdoe\",\n+        \"--org=0123\",\n+        \"--activationkey\",\n+    ]\n+    assert len(caplog.records) == 1\n+    assert caplog.records[-1].levelname == \"FILE\"\n+    assert \"Passed arguments had unexpected secret argument,\" \" '--activationkey', without a secret\" in caplog.text\n+\n+\n class DownloadRHSMPkgsMocked(unit_tests.MockFunction):\n     def __init__(self):\n         self.called = 0\n@@ -554,7 +937,7 @@ def test_download_rhsm_pkgs(version, pkgs_to_download, monkeypatch):\n     assert frozenset(subscription._download_rhsm_pkgs.pkgs_to_download) == pkgs_to_download\n \n \n-class TestUnregisteringSystem:\n+class TestUnregisteringSystem(object):\n     @pytest.mark.parametrize(\n         (\"output\", \"ret_code\", \"expected\"),\n         ((\"\", 0, \"System unregistered successfully.\"), (\"Failed to unregister.\", 1, \"System unregistration failed\")),\n@@ -583,25 +966,30 @@ def test_unregister_system(self, output, ret_code, expected, monkeypatch, caplog\n         assert expected in caplog.records[-1].message\n \n     def test_unregister_system_submgr_not_found(self, monkeypatch, caplog):\n-        rpm_command = \"rpm --quiet -q subscription-manager\"\n+        rpm_command = [\"rpm\", \"--quiet\", \"-q\", \"subscription-manager\"]\n+\n         run_subprocess_mock = mock.Mock(\n             side_effect=unit_tests.run_subprocess_side_effect(\n-                ((rpm_command,), (\"\", 1)),\n+                (rpm_command, (\"\", 1)),\n             )\n         )\n         monkeypatch.setattr(utils, \"run_subprocess\", value=run_subprocess_mock)\n         subscription.unregister_system()\n         assert \"The subscription-manager package is not installed.\" in caplog.records[-1].message\n \n-    def test_unregister_system_keep_rhsm(self, monkeypatch, caplog):\n-        monkeypatch.setattr(tool_opts, \"keep_rhsm\", value=True)\n+    def test_unregister_system_keep_rhsm(self, monkeypatch, caplog, tool_opts):\n+        tool_opts.keep_rhsm = True\n+\n         subscription.unregister_system()\n+\n         assert \"Skipping due to the use of --keep-rhsm.\" in caplog.records[-1].message\n \n-    @mock.patch(\"convert2rhel.toolopts.tool_opts.keep_rhsm\", True)\n-    def test_unregister_system_skipped(self, monkeypatch, caplog):\n+    def test_unregister_system_skipped(self, monkeypatch, caplog, tool_opts):\n+        tool_opts.keep_rhsm = True\n         monkeypatch.setattr(pkghandler, \"get_installed_pkg_objects\", mock.Mock())\n+\n         subscription.unregister_system()\n+\n         assert \"Skipping due to the use of --keep-rhsm.\" in caplog.text\n         pkghandler.get_installed_pkg_objects.assert_not_called()\n \n@@ -632,7 +1020,7 @@ def test_download_rhsm_pkgs_skipped(monkeypatch, caplog):\n )\n def test_verify_rhsm_installed(submgr_installed, keep_rhsm, critical_string, monkeypatch, caplog):\n     if keep_rhsm:\n-        monkeypatch.setattr(tool_opts, \"keep_rhsm\", keep_rhsm)\n+        monkeypatch.setattr(toolopts.tool_opts, \"keep_rhsm\", keep_rhsm)\n \n     if submgr_installed:\n         monkeypatch.setattr("
        },
        {
          "filename": "convert2rhel/unit_tests/systeminfo_test.py",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -161,6 +161,8 @@ def test_modified_rpm_files_diff_with_differences_after_conversion(self):\n     @unit_tests.mock(logger, \"LOG_DIR\", unit_tests.TMP_DIR)\n     @unit_tests.mock(utils, \"run_subprocess\", RunSubprocessMocked((\"rpmva\\n\", 0)))\n     def test_generate_rpm_va(self):\n+        # TODO: move class from unittest to pytest and use global tool_opts fixture\n+        tool_opts.no_rpm_va = False\n         # Check that rpm -Va is executed (default) and stored into the specific file.\n         system_info.generate_rpm_va()\n "
        },
        {
          "filename": "convert2rhel/unit_tests/utils_test.py",
          "status": "modified",
          "additions": 62,
          "deletions": 0,
          "patch": "@@ -15,6 +15,7 @@\n # You should have received a copy of the GNU General Public License\n # along with this program.  If not, see <https://www.gnu.org/licenses/>.\n import getpass\n+import logging\n import os\n import sys\n import unittest\n@@ -262,6 +263,67 @@ def test_is_rpm_based_os(self):\n         assert is_rpm_based_os() in (True, False)\n \n \n+@pytest.mark.parametrize(\n+    \"command, expected_output, expected_code\",\n+    (\n+        ([\"echo\", \"foobar\"], \"foobar\", 0),\n+        ([\"sh\", \"-c\", \"exit 56\"], \"\", 56),\n+    ),\n+)\n+def test_run_cmd_in_pty_simple(command, expected_output, expected_code, monkeypatch):\n+    output, code = utils.run_cmd_in_pty(command)\n+    assert output.strip() == expected_output\n+    assert code == expected_code\n+\n+\n+def test_run_cmd_in_pty_expect_script():\n+    if sys.version_info < (3,):\n+        prompt_cmd = \"raw_input\"\n+    else:\n+        prompt_cmd = \"input\"\n+    output, code = utils.run_cmd_in_pty(\n+        [sys.executable, \"-c\", 'print(%s(\"Ask for password: \"))' % prompt_cmd],\n+        expect_script=((\"password: *\", \"Foo bar\\n\"),),\n+    )\n+\n+    assert output.strip().splitlines()[-1] == \"Foo bar\"\n+    assert code == 0\n+\n+\n+@pytest.mark.parametrize(\n+    \"print_cmd, print_output\",\n+    (\n+        (True, True),\n+        (True, False),\n+        (False, True),\n+        (False, False),\n+    ),\n+)\n+def test_run_cmd_in_pty_quiet_options(print_cmd, print_output, global_tool_opts, caplog):\n+    global_tool_opts.debug = True\n+    caplog.set_level(logging.DEBUG)\n+\n+    output, code = utils.run_cmd_in_pty([\"echo\", \"foo bar\"], print_cmd=print_cmd, print_output=print_output)\n+\n+    expected_count = 1  # There will always be one debug log stating the pty columns\n+    if print_cmd:\n+        assert caplog.records[0].levelname == \"DEBUG\"\n+        assert caplog.records[0].message.strip() == \"Calling command 'echo foo bar'\"\n+        expected_count += 1\n+\n+    if print_output:\n+        assert caplog.records[-1].levelname == \"INFO\"\n+        assert caplog.records[-1].message.strip() == \"foo bar\"\n+        expected_count += 1\n+\n+    assert len(caplog.records) == expected_count\n+\n+\n+def test_run_cmd_in_pty_check_for_deprecated_string():\n+    with pytest.raises(TypeError, match=\"cmd should be a list, not a str\"):\n+        utils.run_cmd_in_pty(\"echo foobar\")\n+\n+\n def test_get_package_name_from_rpm(monkeypatch):\n     monkeypatch.setattr(utils, \"rpm\", get_rpm_mocked())\n     monkeypatch.setattr(utils, \"get_rpm_header\", lambda _: get_rpm_header_mocked())"
        },
        {
          "filename": "convert2rhel/utils.py",
          "status": "modified",
          "additions": 53,
          "deletions": 15,
          "patch": "@@ -153,15 +153,22 @@ def run_subprocess(cmd, print_cmd=True, print_output=True):\n     return output, return_code\n \n \n-def run_cmd_in_pty(cmd, print_cmd=True, print_output=True, columns=120):\n+def run_cmd_in_pty(cmd, expect_script=(), print_cmd=True, print_output=True, columns=120):\n     \"\"\"Similar to run_subprocess(), but the command is executed in a pseudo-terminal.\n \n     The pseudo-terminal can be useful when a command prints out a different output with or without an active terminal\n     session. E.g. yumdownloader does not print the name of the downloaded rpm if not executed from a terminal.\n     Switching off printing the command can be useful in case it contains a password in plain text.\n \n-    :param cmd: The command to execute, including the options, e.g. \"ls -al\"\n-    :type cmd: string\n+    :param cmd: The command to execute, including the options as a list, e.g. [\"ls\", \"-al\"]\n+    :type cmd: list\n+    :param expect_script: An iterable of pairs of expected strings and response strings. By giving\n+    these pairs, interactive programs can be scripted.  Example:\n+        run_cmd_in_pty(['sudo', 'whoami'], [('password: ', 'sudo_password\\n')])\n+        Note1: The caller is responsible for adding newlines to the response strings where\n+        needed. Note2: This function will await pexpect.EOF after all of the pairs in expect_script\n+        have been exhausted.\n+    :type expect_script: iterable of 2-tuples or strings:\n     :param print_cmd: Log the command (to both logfile and stdout)\n     :type print_cmd: bool\n     :param print_output: Log the combined stdout and stderr of the executed command (to both logfile and stdout)\n@@ -180,28 +187,59 @@ def run_cmd_in_pty(cmd, print_cmd=True, print_output=True, columns=120):\n     if print_cmd:\n         loggerinst.debug(\"Calling command '%s'\" % \" \".join(cmd))\n \n-    class PexpectSizedWindowSpawn(pexpect.spawn):\n-        # https://github.com/pexpect/pexpect/issues/134\n-        def setwinsize(self, rows, cols):\n-            super(PexpectSizedWindowSpawn, self).setwinsize(0, columns)\n-\n-    process = PexpectSizedWindowSpawn(cmd[0], cmd[1:], env={\"LC_ALL\": \"C\"}, timeout=None)\n-\n-    # The setting of window size is super unreliable\n-    process.setwinsize(0, columns)\n+    process = PexpectSizedWindowSpawn(cmd[0], cmd[1:], env={\"LC_ALL\": \"C\", \"LANG\": \"C\"}, timeout=None)\n+    # Needed on RHEL-8+ (see comments near PexpectSizedWindowSpawn definition)\n+    process.setwinsize(1, columns)\n     loggerinst.debug(\"Pseudo-PTY columns set to: %s\" % (process.getwinsize(),))\n \n+    for expect, send in expect_script:\n+        process.expect(expect)\n+        process.send(send)\n+\n     process.expect(pexpect.EOF)\n+    try:\n+        process.wait()\n+    except pexpect.ExceptionPexpect:\n+        # RHEL 7's pexpect throws an exception if the process has already exited\n+        # We're just waiting to be sure that the process has finished so we can\n+        # ignore the exception.\n+        pass\n+\n+    # Per the pexpect API, this is necessary in order to get the return code\n+    process.close()\n+    return_code = process.exitstatus\n+\n     output = process.before.decode()\n     if print_output:\n         loggerinst.info(output.rstrip(\"\\n\"))\n \n-    process.close()  # Per the pexpect API, this is necessary in order to get the return code\n-    return_code = process.exitstatus\n-\n     return output, return_code\n \n \n+# For pexpect released prior to 2015 (RHEL7's pexpect-2.3),\n+# spawn.__init__() hardcodes a call to setwinsize(24, 80) to set the\n+# initial terminal size. There is no official way to set the terminal size\n+# to a custom value before the process starts. This can cause an issue with\n+# truncated lines for processes which read the terminal size when they\n+# start and never refresh that value (like yumdownloader)\n+#\n+# overriding setwinsize to set the columns to the size we want in this\n+# subclass is a kludge for the issue. On pexpect-2.3, it fixes the issue\n+# because of the setwinsize call in __init__() at the cost of never being\n+# able to change the column size later.  On later pexpect (RHEL-8 has\n+# pexpect-4.3), this doesn't fix the issue of the terminal size being small\n+# when the subprocess starts but dnf download checks the terminal's size\n+# just before it prints the statusline we care about. So setting the\n+# terminal size via setwinsize() after the process is created works (note:\n+# there is a race condition there but it's unlikely to ever trigger as it\n+# would require downloading a package to happen quicker than the time\n+# between calling spawn.__init__() and spawn.setwinsize())\n+class PexpectSizedWindowSpawn(pexpect.spawn):\n+    # https://github.com/pexpect/pexpect/issues/134\n+    def setwinsize(self, rows, cols):\n+        super(PexpectSizedWindowSpawn, self).setwinsize(rows, 120)\n+\n+\n def let_user_choose_item(num_of_options, item_to_choose):\n     \"\"\"Ask user to enter a number corresponding to the item they choose.\"\"\"\n     while True:  # Loop until user enters a valid number"
        },
        {
          "filename": "plans/tier0.fmf",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -5,6 +5,10 @@ discover+:\n   discover+:\n     test: basic-sanity-checks\n \n+/check_cve:\n+  discover+:\n+    test: check-cve-2022-1662\n+\n /check_user_response:\n   discover+:\n     test: check-user-response"
        },
        {
          "filename": "tests/ansible_collections/roles/install-testing-deps/tasks/main.yml",
          "status": "modified",
          "additions": 14,
          "deletions": 2,
          "patch": "@@ -1,7 +1,11 @@\n ---\n - name: Ensure python3\n   yum:\n-    name: python3\n+    # gcc and python3-devel are needed for psutil\n+    name:\n+      - \"python3\"\n+      - \"gcc\"\n+      - \"python3-devel\"\n     state: present\n \n - name: Install pip if not present\n@@ -11,6 +15,14 @@\n \n - name: Install pytest framework dependencies\n   pip:\n-    name: [\"pytest\", \"pytest-cov\", \"envparse\", \"click\", \"pexpect\", \"dataclasses\", \"jsonschema\"]\n+    name:\n+      - \"pytest\"\n+      - \"pytest-cov\"\n+      - \"envparse\"\n+      - \"click\"\n+      - \"pexpect\"\n+      - \"dataclasses\"\n+      - \"jsonschema\"\n+      - \"psutil\"\n     # Use pip3 in case pip was installed via rpm package on this system\n     executable: pip3"
        },
        {
          "filename": "tests/integration/tier0/check-cve-2022-1662/main.fmf",
          "status": "added",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -0,0 +1,6 @@\n+summary: check cve-2022-1662 is fixed\n+\n+tier: 0\n+\n+test: |\n+  pytest -svv"
        },
        {
          "filename": "tests/integration/tier0/check-cve-2022-1662/test_cve_fixes.py",
          "status": "added",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -0,0 +1,29 @@\n+from multiprocessing import Pool\n+\n+import psutil\n+\n+\n+def watchdog():\n+    while True:\n+        for process in psutil.process_iter():\n+            # For some reason the psutil catches subscription-manager in process.name()\n+            # as 'subscription-ma', thus using 'subscription' to catch it\n+            if \"subscription\" in process.name():\n+                return process.cmdline()\n+\n+\n+def test_passing_password_to_submrg(convert2rhel):\n+    username = \"testname\"\n+    password = \"EXAMPLE&hTYGHKPvU7Ewd\"\n+    with convert2rhel(f\"-y --no-rpm-va -u {username} -p {password}\") as c2r:\n+        # Just to be sure, try to run through all three tries\n+        # of the registration process in case the race condition applies\n+        for subscription_try in range(2):\n+            c2r.expect(\"Registering the system using subscription-manager ...\")\n+            # Run watchdog function using multiprocessing pool\n+            # as soon as Convert2RHEL tries to call subscription-manager\n+            with Pool(processes=1) as pool:\n+                watcher = pool.apply_async(watchdog, ())\n+                # Check for the password not being passed to the subscription-manager\n+                print(watcher.get())\n+                assert not [cmdline for cmdline in watcher.get() if password in cmdline]"
        },
        {
          "filename": "tests/integration/tier0/check-user-response/test_user_response.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -41,7 +41,7 @@ def test_check_user_response_organization(convert2rhel):\n             env.str(\"RHSM_KEY\"),\n         )\n     ) as c2r:\n-        c2r.expect_exact(\" ... activation key detected: \")\n+        c2r.expect_exact(\"activation key detected\")\n         c2r.expect_exact(\"Organization: \")\n         c2r.sendline()\n         assert c2r.expect_exact([\"Organization\", \"Registering the system\"]) == 0"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 9,
        "unique_directories": 7,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "f21f6cfbfabf832754f06fc4b1faea8d74a3ef91",
            "date": "2024-12-11T15:44:23Z",
            "author_login": "danmyway"
          },
          {
            "sha": "940e048d23d7385677fdf84f21e0ab630fda7405",
            "date": "2024-12-06T17:21:50Z",
            "author_login": "danmyway"
          },
          {
            "sha": "98267049f8fca9ca17664764005b17afd67af849",
            "date": "2024-12-06T12:58:44Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "9959824856549eb1adec06e70e1c90886ffb67f8",
            "date": "2024-12-06T12:58:28Z",
            "author_login": "bocekm"
          },
          {
            "sha": "dbcd745b886d616887a09eb173e9a5d03e77925a",
            "date": "2024-12-03T17:46:01Z",
            "author_login": "bocekm"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-359",
    "description": "There is a flaw in convert2rhel. convert2rhel passes the Red Hat account password to subscription-manager via the command line, which could allow unauthorized users locally on the machine to view the password via the process command line via e.g. htop or ps. The specific impact varies upon the privileges of the Red Hat account in question, but it could affect the integrity, availability, and/or data confidentiality of other systems that are administered by that account. This occurs regardless of how the password is supplied to convert2rhel.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-08-29T15:15:10.027",
    "last_modified": "2024-11-21T06:39:31.770",
    "fix_date": "2022-05-27T06:54:24Z"
  },
  "references": [
    {
      "url": "https://access.redhat.com/security/cve/CVE-2022-0852",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2060129",
      "source": "secalert@redhat.com",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/oamg/convert2rhel/commit/8d72fb030ed31116fdb256b327d299337b000af4",
      "source": "secalert@redhat.com",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/oamg/convert2rhel/pull/492",
      "source": "secalert@redhat.com",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://issues.redhat.com/browse/RHELC-432",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://access.redhat.com/security/cve/CVE-2022-0852",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2060129",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/oamg/convert2rhel/commit/8d72fb030ed31116fdb256b327d299337b000af4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/oamg/convert2rhel/pull/492",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://issues.redhat.com/browse/RHELC-432",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:39.053802",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "convert2rhel",
    "owner": "oamg",
    "created_at": "2019-12-13T21:58:18Z",
    "updated_at": "2025-01-14T14:50:38Z",
    "pushed_at": "2025-01-13T16:56:37Z",
    "size": 4289,
    "stars": 108,
    "forks": 86,
    "open_issues": 22,
    "watchers": 108,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release/v1.3",
      "release/v2.0"
    ],
    "languages": {
      "Python": 1808914,
      "Dockerfile": 5105,
      "Makefile": 4778,
      "Shell": 2683,
      "C": 478
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-14T21:43:33.007511"
  }
}