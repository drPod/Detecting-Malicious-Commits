{
  "cve_id": "CVE-2022-0991",
  "github_data": {
    "repository": "admidio/admidio",
    "fix_commit": "e84e472ebe517e2ff5795c46dc10b5f49dc4d46a",
    "related_commits": [
      "e84e472ebe517e2ff5795c46dc10b5f49dc4d46a",
      "e84e472ebe517e2ff5795c46dc10b5f49dc4d46a"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "e84e472ebe517e2ff5795c46dc10b5f49dc4d46a",
      "commit_date": "2022-03-13T08:26:54Z",
      "author": {
        "login": "Fasse",
        "type": "User",
        "stats": {
          "total_commits": 6698,
          "average_weekly_commits": 6.638255698711595,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 829
        }
      },
      "commit_message": {
        "title": " Sessions should be invalidated if password was changed #1238",
        "length": 61,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 129,
        "additions": 85,
        "deletions": 44
      },
      "files": [
        {
          "filename": "adm_program/system/classes/Session.php",
          "status": "modified",
          "additions": 28,
          "deletions": 17,
          "patch": "@@ -74,7 +74,7 @@ public function __construct(Database $database, $cookiePrefix = '')\n             $this->readDataByColumns(array('ses_session_id' => $sessionId));\n \n             if ($this->newRecord) {\n-                // if PHP session id was commited then store them in that field\n+                // if PHP session id was committed then store them in that field\n                 $this->setValue('ses_session_id', $sessionId);\n                 $this->setValue('ses_timestamp', DATETIME_NOW);\n             }\n@@ -117,9 +117,11 @@ protected function clearUserData()\n      * Returns a CSRF token from the session. If no CSRF token exists a new one will be\n      * generated and stored within the session. The next call of the method will than\n      * return the existing token. The CSRF token has 30 characters. A new token could\n-     * be forced by the paramter **$newToken**\n+     * be forced by the parameter **$newToken**\n      * @param bool $newToken If set to true, always a new token will be generated.\n      * @return string Returns the CSRF token\n+     * @throws AdmException\n+     * @throws AdmException\n      */\n     public function getCsrfToken(bool $newToken = false): string\n     {\n@@ -132,7 +134,7 @@ public function getCsrfToken(bool $newToken = false): string\n \n     /**\n      * Returns a reference of an object that is stored in the session.\n-     * This is necessary because the old database connection is not longer valid.\n+     * This is necessary because the old database connection is not valid anymore.\n      * @param string $objectName Internal unique name of the object. The name was set with the method **addObject**\n      * @return object|false Returns the reference to the object or false if the object was not found.\n      */\n@@ -174,8 +176,8 @@ public function hasObject(string $objectName): bool\n     }\n \n     /**\n-     * Initialize the array with all objects except the gNavigation object. If the session got an refresh\n-     * the existing navigation should still be stored in the refreshed sesssion.\n+     * Initialize the array with all objects except the gNavigation object. If the session got a refresh\n+     * the existing navigation should still be stored in the refreshed session.\n      */\n     public function initializeObjects()\n     {\n@@ -201,7 +203,7 @@ public function isValidLogin(int $userId): bool\n                 // session has a user assigned -> check if login is still valid\n                 $timeGap = time() - strtotime($this->getValue('ses_timestamp', 'Y-m-d H:i:s'));\n \n-                // Check how long the user was inactive. If time range is to long -> logout\n+                // Check how long the user was inactive. If time range is too long -> logout\n                 // if user has auto login than session is also valid\n                 if ($this->mAutoLogin instanceof AutoLogin || $timeGap < $gSettingsManager->getInt('logout_minutes') * 60) {\n                     return true;\n@@ -261,8 +263,8 @@ public function refreshAutoLogin()\n                 $this->setValue('ses_usr_id', (int) $this->mAutoLogin->getValue('atl_usr_id'));\n \n                 // save cookie for autologin\n-                $currDateTime = new \\DateTime();\n-                $oneYearDateInterval = new \\DateInterval('P1Y');\n+                $currDateTime = new DateTime();\n+                $oneYearDateInterval = new DateInterval('P1Y');\n                 $oneYearAfterDateTime = $currDateTime->add($oneYearDateInterval);\n                 $timestampExpired = $oneYearAfterDateTime->getTimestamp();\n \n@@ -297,8 +299,13 @@ public function refreshAutoLogin()\n      */\n     public function refresh()\n     {\n-        // read session data from database to update the renew flag\n-        $this->readDataById((int) $this->getValue('ses_id'));\n+        // read session data from database to update the reload flag\n+        if(!$this->readDataById((int) $this->getValue('ses_id'))) {\n+            // if session was not found than destroy session object\n+            unset($_SESSION['gCurrentSession']);\n+            $this->initializeObjects();\n+            $this->clear();\n+        }\n \n         // check if current connection has same ip address as of session initialization\n         // if config parameter $gCheckIpAddress = 0 then don't check ip address\n@@ -370,9 +377,11 @@ public function reload(int $userId)\n      */\n     public function save($updateFingerPrint = true): bool\n     {\n+        global $gCurrentOrgId;\n+\n         if ($this->newRecord) {\n             // Insert\n-            $this->setValue('ses_org_id', $GLOBALS['gCurrentOrgId']);\n+            $this->setValue('ses_org_id', $gCurrentOrgId);\n             $this->setValue('ses_begin', DATETIME_NOW);\n             // remove the last part of the IP because of privacy (GDPR)\n             $ip = preg_replace(array('/\\.\\d+$/', '/[\\da-f]*:[\\da-f]*$/'), array('.XXX', 'XXXX:XXXX'), $_SERVER['REMOTE_ADDR']);\n@@ -403,8 +412,8 @@ public function setAutoLogin()\n         $this->mAutoLogin->save();\n \n         // save cookie for autologin\n-        $currDateTime = new \\DateTime();\n-        $oneYearDateInterval = new \\DateInterval('P1Y');\n+        $currDateTime = new DateTime();\n+        $oneYearDateInterval = new DateInterval('P1Y');\n         $oneYearAfterDateTime = $currDateTime->add($oneYearDateInterval);\n         $timestampExpired = $oneYearAfterDateTime->getTimestamp();\n \n@@ -478,7 +487,7 @@ public static function setCookie(\n      * @param bool|null $secure       If \"true\" cookie is only set if connection is HTTPS. Default is an auto detection.\n      * @param bool $httpOnly     If \"true\" cookie is accessible only via HTTP.\n      *                             Set to \"false\" to allow access for JavaScript. (Possible XSS security leak)\n-     * @throws \\RuntimeException\n+     * @throws RuntimeException\n      */\n     public static function start(string $cookiePrefix, int $limit = 0, string $path = '', string $domain = '', bool $secure = null, bool $httpOnly = true)\n     {\n@@ -488,7 +497,7 @@ public static function start(string $cookiePrefix, int $limit = 0, string $path\n             $message = 'HTTP-Headers already sent!';\n             $gLogger->alert($message);\n \n-            throw new \\RuntimeException($message);\n+            throw new RuntimeException($message);\n         }\n \n         $sessionName = $cookiePrefix . '_SESSION_ID';\n@@ -543,11 +552,13 @@ public static function start(string $cookiePrefix, int $limit = 0, string $path\n     /**\n      * Deletes all sessions in table admSessions that are inactive since **$maxInactiveTime** minutes..\n      * @param int $maxInactiveMinutes Time in Minutes after that a session will be deleted.\n+     * @throws Exception\n+     * @throws Exception\n      */\n     public function tableCleanup(int $maxInactiveMinutes = 30)\n     {\n-        $now = new \\DateTime();\n-        $minutesBack = new \\DateInterval('PT' . $maxInactiveMinutes . 'M');\n+        $now = new DateTime();\n+        $minutesBack = new DateInterval('PT' . $maxInactiveMinutes . 'M');\n         $timestamp = $now->sub($minutesBack)->format('Y-m-d H:i:s');\n \n         $sql = 'DELETE FROM '.TBL_SESSIONS.'"
        },
        {
          "filename": "adm_program/system/classes/User.php",
          "status": "modified",
          "additions": 57,
          "deletions": 27,
          "patch": "@@ -109,7 +109,7 @@ public function allowedEditProfileField(self $user, $fieldNameIntern)\n      * @param string $fieldNameIntern Expects the **usf_name_intern** of the field that should be checked.\n      * @return bool Return true if the current user is allowed to view this profile field of **$user**.\n      */\n-    public function allowedViewProfileField(self $user, $fieldNameIntern)\n+    public function allowedViewProfileField(self $user, string $fieldNameIntern)\n     {\n         return $user->mProfileFieldsData->isVisible($fieldNameIntern, $this->hasRightEditProfile($user));\n     }\n@@ -125,7 +125,7 @@ public function assignDefaultRoles()\n         $this->db->startTransaction();\n \n         // every user will get the default roles for registration, if the current user has the right to assign roles\n-        // than the roles assignment dialog will be shown\n+        // than the role assignment dialog will be shown\n         $sql = 'SELECT rol_id\n                   FROM '.TBL_ROLES.'\n             INNER JOIN '.TBL_CATEGORIES.'\n@@ -149,7 +149,7 @@ public function assignDefaultRoles()\n \n     /**\n      * @param string $mode      'set' or 'edit'\n-     * @param int $id           Id of the role for which the membership should be set,\n+     * @param int $id           ID of the role for which the membership should be set,\n      *                          or id of the current membership that should be edited.\n      * @param string $startDate New start date of the membership. Default will be **DATE_NOW**.\n      * @param string $endDate   New end date of the membership. Default will be **31.12.9999**\n@@ -169,7 +169,7 @@ private function changeRoleMembership($mode, $id, $startDate, $endDate, $leader)\n         $maxEndDate   = $endDate;\n \n         if ($mode === 'set') {\n-            // subtract 1 day from start date so that we find memberships that ends yesterday\n+            // subtract 1 day from start date so that we find memberships that end yesterday\n             // these memberships can be continued with new date\n             $oneDayOffset = new \\DateInterval('P1D');\n \n@@ -192,7 +192,7 @@ private function changeRoleMembership($mode, $id, $startDate, $endDate, $leader)\n                        AND mem_usr_id = ? -- $usrId\n                        AND mem_begin <= ? -- $endDate\n                        AND mem_end   >= ? -- $startDate\n-                  ORDER BY mem_begin ASC';\n+                  ORDER BY mem_begin';\n             $queryParams = array(\n                 $id,\n                 $usrId,\n@@ -209,7 +209,7 @@ private function changeRoleMembership($mode, $id, $startDate, $endDate, $leader)\n                        AND mem_usr_id = ? -- $usrId\n                        AND mem_begin <= ? -- $endDate\n                        AND mem_end   >= ? -- $startDate\n-                  ORDER BY mem_begin ASC';\n+                  ORDER BY mem_begin';\n             $queryParams = array(\n                 $id,\n                 $member->getValue('mem_rol_id'),\n@@ -234,14 +234,14 @@ private function changeRoleMembership($mode, $id, $startDate, $endDate, $leader)\n             }\n \n             if ($mode === 'set') {\n-                // save new end date if an later date exists\n-                // but only if end date is greater than the begin date otherwise the membership should be deleted\n+                // save new end date if a later date exists\n+                // but only if end date is greater than the beginn date otherwise the membership should be deleted\n                 if (strcmp($member->getValue('mem_end', 'Y-m-d'), $maxEndDate) > 0\n                 &&  strcmp($member->getValue('mem_begin', 'Y-m-d'), $maxEndDate) < 0) {\n                     $maxEndDate = $member->getValue('mem_end', 'Y-m-d');\n                 }\n             } else {\n-                // save new end date if an later date exists\n+                // save new end date if a later date exists\n                 if (strcmp($member->getValue('mem_end', 'Y-m-d'), $maxEndDate) > 0) {\n                     $maxEndDate = $member->getValue('mem_end', 'Y-m-d');\n                 }\n@@ -257,7 +257,7 @@ private function changeRoleMembership($mode, $id, $startDate, $endDate, $leader)\n                     $minStartDate = $member->getValue('mem_begin', 'Y-m-d');\n                 }\n \n-                // save new end date if an later date exists\n+                // save new end date if a later date exists\n                 if (strcmp($member->getValue('mem_end', 'Y-m-d'), $maxEndDate) > 0) {\n                     $maxEndDate = $member->getValue('mem_end', 'Y-m-d');\n                 }\n@@ -296,7 +296,7 @@ private function changeRoleMembership($mode, $id, $startDate, $endDate, $leader)\n     }\n \n     /**\n-     * Method reads all relationships of the user and will store them in an array. Also the\n+     * Method reads all relationships of the user and will store them in an array. The\n      * relationship property if the user can edit the profile of the other user will be stored\n      * for later checks within this class.\n      * @return bool Return true if relationships could be checked.\n@@ -336,8 +336,8 @@ private function checkRelationshipsRights()\n     /**\n      * The method reads all roles where this user has a valid membership and checks the rights of\n      * those roles. It stores all rights that the user get at last through one role in an array.\n-     * In addition the method checks which roles lists the user could see in an separate array.\n-     * Also an array with all roles where the user has the right to write an email will be stored.\n+     * The method checks which role lists the user could see in a separate array.\n+     * An array with all roles where the user has the right to write an email will be stored.\n      * The method considered the role leader rights of each role if this is set and the current\n      * user is a leader in a role.\n      * @param string $right The database column name of the right that should be checked. If this param\n@@ -409,8 +409,7 @@ public function checkRolesRight($right = null)\n                     // add role to membership array\n                     $this->rolesMembership[] = $rolId;\n \n-                    // Rechte der Rollen in das Array uebertragen,\n-                    // falls diese noch nicht durch andere Rollen gesetzt wurden\n+                    // Transfer the rights of the roles into the array, if these have not yet been set by other roles\n                     foreach ($tmpRolesRights as $key => &$value) {\n                         if (!$value && $row[$key] == '1') {\n                             $value = true;\n@@ -429,38 +428,38 @@ public function checkRolesRight($right = null)\n                     }\n                 }\n \n-                // Listenansichtseinstellung merken\n-                // Leiter duerfen die Rolle sehen\n+                // Remember list view setting\n+                // leaders are allowed to see the role\n                 if ($row['mem_usr_id'] > 0 && ($row['rol_this_list_view'] > 0 || $memLeader)) {\n-                    // Mitgliedschaft bei der Rolle und diese nicht gesperrt, dann anschauen\n+                    // Membership to the role and this is not locked, then look at it\n                     $this->listViewRights[$rolId] = true;\n                 } elseif ((int) $row['rol_this_list_view'] === 2) {\n-                    // andere Rollen anschauen, wenn jeder sie sehen darf\n+                    // look at other roles when everyone is allowed to see them\n                     $this->listViewRights[$rolId] = true;\n                 } else {\n                     $this->listViewRights[$rolId] = false;\n                 }\n \n-                // Mailrechte setzen\n-                // Leiter duerfen der Rolle Mails schreiben\n+                // Set mail permissions\n+                // Leaders are allowed to write mails to the role\n                 if ($row['mem_usr_id'] > 0 && ($row['rol_mail_this_role'] > 0 || $memLeader)) {\n-                    // Mitgliedschaft bei der Rolle und diese nicht gesperrt, dann anschauen\n+                    // Membership to the role and this is not locked, then look at it\n                     $this->listMailRights[$rolId] = true;\n                 } elseif ($row['rol_mail_this_role'] >= 2) {\n-                    // andere Rollen anschauen, wenn jeder sie sehen darf\n+                    // look at other roles when everyone is allowed to see them\n                     $this->listMailRights[$rolId] = true;\n                 } else {\n                     $this->listMailRights[$rolId] = false;\n                 }\n             }\n             $this->rolesRights = $tmpRolesRights;\n \n-            // ist das Recht 'alle Listen einsehen' gesetzt, dann dies auch im Array bei allen Rollen setzen\n+            // if the right 'view all lists' is set, then set this also in the array for all roles\n             if ($this->rolesRights['rol_all_lists_view']) {\n                 $this->listViewRights = array_fill_keys(array_keys($this->listViewRights), true);\n             }\n \n-            // ist das Recht 'allen Rollen EMails schreiben' gesetzt, dann dies auch im Array bei allen Rollen setzen\n+            // if the right 'write emails to all roles' is set, then set this also in the array for all roles\n             if ($this->rolesRights['rol_mail_to_all']) {\n                 $this->listMailRights = array_fill_keys(array_keys($this->listMailRights), true);\n             }\n@@ -1422,6 +1421,32 @@ private function handleIncorrectPasswordLogin()\n         return 'SYS_LOGIN_USERNAME_PASSWORD_INCORRECT';\n     }\n \n+    /**\n+     * Deletes all other sessions of the current user except the current session. Also all auto logins of the user\n+     * will be removed. This method is useful if the user changed his password or if unusual activities within\n+     * the user account are noticed.\n+     * @return bool Returns true if all things could be done. Otherwise false is returned.\n+     */\n+    public function invalidateAllOtherLogins()\n+    {\n+        global $gCurrentUserId, $gCurrentSession;\n+\n+        // remove all sessions of the current user except the current session\n+        $sql = 'DELETE FROM ' . TBL_SESSIONS . '\n+                 WHERE ses_usr_id = ? -- $gCurrentUserId\n+                   AND ses_id    <> ? -- $gCurrentSession->getValue(\\'ses_id\\') ';\n+        $queryParams = array($gCurrentUserId, $gCurrentSession->getValue('ses_id'));\n+        $this->db->queryPrepared($sql, $queryParams);\n+\n+        // remove all auto logins of the current user\n+        $sql = 'DELETE FROM ' . TBL_AUTO_LOGIN . '\n+                 WHERE atl_usr_id = ? -- $gCurrentUserId ';\n+        $queryParams = array($gCurrentUserId);\n+        $this->db->queryPrepared($sql, $queryParams);\n+\n+        return true;\n+    }\n+\n     /**\n      * Checks if the user is assigned to the role **Administrator**\n      * @return bool Returns **true** if the user is a member of the role **Administrator**\n@@ -1765,7 +1790,12 @@ public function setPassword($newPassword, $doHashing = true)\n                 $this\n             );\n         }\n-        return parent::setValue('usr_password', $newPasswordHash, false);\n+        if(parent::setValue('usr_password', $newPasswordHash, false)) {\n+            // for security reasons remove all sessions and auto login of the user\n+            return $this->invalidateAllOtherLogins();\n+        }\n+\n+        return false;\n     }\n \n     /**\n@@ -2029,7 +2059,7 @@ public function editWeblinksRight()\n \n     /**\n      * Return the (internal) representation of this user's profile fields\n-     * @return array All profile fields of the user\n+     * @return object<ProfileFields> All profile fields of the user\n      */\n     public function getProfileFieldsData()\n     {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "00eed34b64f4edfc34441c80fde054751de0e546",
            "date": "2025-01-23T19:53:46Z",
            "author_login": "Fasse"
          },
          {
            "sha": "8af815bf5111ad7c35737b3830b10e565a778928",
            "date": "2025-01-21T15:57:22Z",
            "author_login": "kainhofer"
          },
          {
            "sha": "a720ec9e6204387e926c648640d694430178d105",
            "date": "2025-01-23T05:41:31Z",
            "author_login": "Fasse"
          },
          {
            "sha": "59ff38abc905a8c88cd88e161a71b4fe2ed8a756",
            "date": "2025-01-23T05:35:20Z",
            "author_login": "Fasse"
          },
          {
            "sha": "31390c4fdf8d5d00d6ab4f798b8f014acff285d2",
            "date": "2025-01-22T21:02:26Z",
            "author_login": "kainhofer"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:N",
    "cwe_id": "CWE-613",
    "description": "Insufficient Session Expiration in GitHub repository admidio/admidio prior to 4.1.9.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-03-19T08:15:06.937",
    "last_modified": "2024-11-21T06:39:48.740",
    "fix_date": "2022-03-13T08:26:54Z"
  },
  "references": [
    {
      "url": "https://github.com/admidio/admidio/commit/e84e472ebe517e2ff5795c46dc10b5f49dc4d46a",
      "source": "security@huntr.dev",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/1c406a4e-15d0-4920-8495-731c48473ba4",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/admidio/admidio/commit/e84e472ebe517e2ff5795c46dc10b5f49dc4d46a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/1c406a4e-15d0-4920-8495-731c48473ba4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:02.043194",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "admidio",
    "owner": "admidio",
    "created_at": "2015-01-05T11:03:46Z",
    "updated_at": "2025-01-14T08:00:57Z",
    "pushed_at": "2025-01-14T06:12:48Z",
    "size": 122123,
    "stars": 349,
    "forks": 134,
    "open_issues": 157,
    "watchers": 349,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "PHP": 3162563,
      "JavaScript": 806324,
      "Smarty": 240740,
      "CSS": 89897,
      "HTML": 37144,
      "Shell": 12111,
      "Dockerfile": 3439
    },
    "commit_activity": {
      "total_commits_last_year": 581,
      "avg_commits_per_week": 11.173076923076923,
      "days_active_last_year": 183
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T14:42:13.964136"
  }
}