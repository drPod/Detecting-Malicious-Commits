{
  "cve_id": "CVE-2022-1285",
  "github_data": {
    "repository": "gogs/gogs",
    "fix_commit": "7885f454a4946c4bbec1b4f8c603b5eea7429c7f",
    "related_commits": [
      "7885f454a4946c4bbec1b4f8c603b5eea7429c7f",
      "7885f454a4946c4bbec1b4f8c603b5eea7429c7f"
    ],
    "patch_url": "https://github.com/gogs/gogs/commit/7885f454a4946c4bbec1b4f8c603b5eea7429c7f.patch",
    "fix_commit_details": {
      "sha": "7885f454a4946c4bbec1b4f8c603b5eea7429c7f",
      "commit_date": "2022-05-31T07:17:17Z",
      "author": {
        "login": "unknwon",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "webhook: revalidate local hostname before each delivery (#6988)",
        "length": 63,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 73,
        "additions": 41,
        "deletions": 32
      },
      "files": [
        {
          "filename": "CHANGELOG.md",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -22,6 +22,7 @@ All notable changes to Gogs are documented in this file.\n \n ### Fixed\n \n+- _Security:_ SSRF in webhook. [#6901](https://github.com/gogs/gogs/issues/6901)\n - _Security:_ XSS in cookies. [#6953](https://github.com/gogs/gogs/issues/6953)\n - _Security:_ OS Command Injection in file uploading. [#6968](https://github.com/gogs/gogs/issues/6968)\n - _Security:_ Remote Command Execution in file editing. [#6555](https://github.com/gogs/gogs/issues/6555)"
        },
        {
          "filename": "conf/locale/locale_en-US.ini",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -443,6 +443,7 @@ migrate.clone_address_desc = This can be a HTTP/HTTPS/GIT URL.\n migrate.clone_address_desc_import_local = You're also allowed to migrate a repository by local server path.\n migrate.permission_denied = You are not allowed to import local repositories.\n migrate.invalid_local_path = Invalid local path, it does not exist or not a directory.\n+migrate.clone_address_resolved_to_blocked_local_address = Clone address resolved to a local network address that is implicitly blocked.\n migrate.failed = Migration failed: %v\n \n mirror_from = mirror of\n@@ -809,7 +810,7 @@ settings.webhook.headers = Headers\n settings.webhook.payload = Payload\n settings.webhook.body = Body\n settings.webhook.err_cannot_parse_payload_url = Cannot parse payload URL: %v\n-settings.webhook.err_cannot_use_local_addresses = Non admins are not allowed to use local addresses.\n+settings.webhook.url_resolved_to_blocked_local_address = Payload URL resolved to a local network address that is implicitly blocked.\n settings.githooks_desc = Git Hooks are powered by Git itself, you can edit files of supported hooks in the list below to perform custom operations.\n settings.githook_edit_desc = If the hook is inactive, sample content will be presented. Leaving content to an empty value will disable this hook.\n settings.githook_name = Hook Name"
        },
        {
          "filename": "internal/db/error.go",
          "status": "modified",
          "additions": 6,
          "deletions": 5,
          "patch": "@@ -194,9 +194,10 @@ func (err ErrLastOrgOwner) Error() string {\n //         \\/     \\/|__|              \\/                       \\/\n \n type ErrInvalidCloneAddr struct {\n-\tIsURLError         bool\n-\tIsInvalidPath      bool\n-\tIsPermissionDenied bool\n+\tIsURLError            bool\n+\tIsInvalidPath         bool\n+\tIsPermissionDenied    bool\n+\tIsBlockedLocalAddress bool\n }\n \n func IsErrInvalidCloneAddr(err error) bool {\n@@ -205,8 +206,8 @@ func IsErrInvalidCloneAddr(err error) bool {\n }\n \n func (err ErrInvalidCloneAddr) Error() string {\n-\treturn fmt.Sprintf(\"invalid clone address [is_url_error: %v, is_invalid_path: %v, is_permission_denied: %v]\",\n-\t\terr.IsURLError, err.IsInvalidPath, err.IsPermissionDenied)\n+\treturn fmt.Sprintf(\"invalid clone address [is_url_error: %v, is_invalid_path: %v, is_permission_denied: %v, is_blocked_local_address: %v]\",\n+\t\terr.IsURLError, err.IsInvalidPath, err.IsPermissionDenied, err.IsBlockedLocalAddress)\n }\n \n type ErrUpdateTaskNotExist struct {"
        },
        {
          "filename": "internal/db/webhook.go",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -24,6 +24,7 @@ import (\n \t\"gogs.io/gogs/internal/conf\"\n \t\"gogs.io/gogs/internal/errutil\"\n \t\"gogs.io/gogs/internal/httplib\"\n+\t\"gogs.io/gogs/internal/netutil\"\n \t\"gogs.io/gogs/internal/sync\"\n )\n \n@@ -688,6 +689,11 @@ func TestWebhook(repo *Repository, event HookEventType, p api.Payloader, webhook\n }\n \n func (t *HookTask) deliver() {\n+\tif netutil.IsBlockedLocalHostname(t.URL, conf.Security.LocalNetworkAllowlist) {\n+\t\tt.ResponseContent = \"Payload URL resolved to a local network address that is implicitly blocked.\"\n+\t\treturn\n+\t}\n+\n \tt.IsDelivered = true\n \n \ttimeout := time.Duration(conf.Webhook.DeliverTimeout) * time.Second"
        },
        {
          "filename": "internal/form/repo.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -72,8 +72,8 @@ func (f MigrateRepo) ParseRemoteAddr(user *db.User) (string, error) {\n \t\t\treturn \"\", db.ErrInvalidCloneAddr{IsURLError: true}\n \t\t}\n \n-\t\tif netutil.IsLocalHostname(u.Hostname(), conf.Security.LocalNetworkAllowlist) {\n-\t\t\treturn \"\", db.ErrInvalidCloneAddr{IsURLError: true}\n+\t\tif netutil.IsBlockedLocalHostname(u.Hostname(), conf.Security.LocalNetworkAllowlist) {\n+\t\t\treturn \"\", db.ErrInvalidCloneAddr{IsBlockedLocalAddress: true}\n \t\t}\n \n \t\tif len(f.AuthUsername)+len(f.AuthPassword) > 0 {"
        },
        {
          "filename": "internal/netutil/netutil.go",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -47,9 +47,10 @@ func init() {\n \t}\n }\n \n-// IsLocalHostname returns true if given hostname is resolved to local network\n-// address, except exempted from the allowlist.\n-func IsLocalHostname(hostname string, allowlist []string) bool {\n+// IsBlockedLocalHostname returns true if given hostname is resolved to a local\n+// network address that is implicitly blocked (i.e. not exempted from the\n+// allowlist).\n+func IsBlockedLocalHostname(hostname string, allowlist []string) bool {\n \tfor _, allow := range allowlist {\n \t\tif hostname == allow {\n \t\t\treturn false"
        },
        {
          "filename": "internal/netutil/netutil_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -34,7 +34,7 @@ func TestIsLocalHostname(t *testing.T) {\n \t}\n \tfor _, test := range tests {\n \t\tt.Run(\"\", func(t *testing.T) {\n-\t\t\tassert.Equal(t, test.want, IsLocalHostname(test.hostname, test.allowlist))\n+\t\t\tassert.Equal(t, test.want, IsBlockedLocalHostname(test.hostname, test.allowlist))\n \t\t})\n \t}\n }"
        },
        {
          "filename": "internal/route/api/v1/repo/repo.go",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -248,6 +248,8 @@ func Migrate(c *context.APIContext, f form.MigrateRepo) {\n \t\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, errors.New(\"You are not allowed to import local repositories.\"))\n \t\t\tcase addrErr.IsInvalidPath:\n \t\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, errors.New(\"Invalid local path, it does not exist or not a directory.\"))\n+\t\t\tcase addrErr.IsBlockedLocalAddress:\n+\t\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, errors.New(\"Clone address resolved to a local network address that is implicitly blocked.\"))\n \t\t\tdefault:\n \t\t\t\tc.Error(err, \"unexpected error\")\n \t\t\t}"
        },
        {
          "filename": "internal/route/repo/repo.go",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -180,11 +180,13 @@ func MigratePost(c *context.Context, f form.MigrateRepo) {\n \t\t\taddrErr := err.(db.ErrInvalidCloneAddr)\n \t\t\tswitch {\n \t\t\tcase addrErr.IsURLError:\n-\t\t\t\tc.RenderWithErr(c.Tr(\"form.url_error\"), MIGRATE, &f)\n+\t\t\t\tc.RenderWithErr(c.Tr(\"repo.migrate.clone_address\")+c.Tr(\"form.url_error\"), MIGRATE, &f)\n \t\t\tcase addrErr.IsPermissionDenied:\n \t\t\t\tc.RenderWithErr(c.Tr(\"repo.migrate.permission_denied\"), MIGRATE, &f)\n \t\t\tcase addrErr.IsInvalidPath:\n \t\t\t\tc.RenderWithErr(c.Tr(\"repo.migrate.invalid_local_path\"), MIGRATE, &f)\n+\t\t\tcase addrErr.IsBlockedLocalAddress:\n+\t\t\t\tc.RenderWithErr(c.Tr(\"repo.migrate.clone_address_resolved_to_blocked_local_address\"), MIGRATE, &f)\n \t\t\tdefault:\n \t\t\t\tc.Error(err, \"unexpected error\")\n \t\t\t}"
        },
        {
          "filename": "internal/route/repo/webhook.go",
          "status": "modified",
          "additions": 11,
          "deletions": 14,
          "patch": "@@ -119,20 +119,17 @@ func WebhooksNew(c *context.Context, orCtx *orgRepoContext) {\n \tc.Success(orCtx.TmplNew)\n }\n \n-func validateWebhook(actor *db.User, l macaron.Locale, w *db.Webhook) (field, msg string, ok bool) {\n-\tif !actor.IsAdmin {\n-\t\t// \ud83d\udea8 SECURITY: Local addresses must not be allowed by non-admins to prevent SSRF,\n-\t\t// see https://github.com/gogs/gogs/issues/5366 for details.\n-\t\tpayloadURL, err := url.Parse(w.URL)\n-\t\tif err != nil {\n-\t\t\treturn \"PayloadURL\", l.Tr(\"repo.settings.webhook.err_cannot_parse_payload_url\", err), false\n-\t\t}\n-\n-\t\tif netutil.IsLocalHostname(payloadURL.Hostname(), conf.Security.LocalNetworkAllowlist) {\n-\t\t\treturn \"PayloadURL\", l.Tr(\"repo.settings.webhook.err_cannot_use_local_addresses\"), false\n-\t\t}\n+func validateWebhook(l macaron.Locale, w *db.Webhook) (field, msg string, ok bool) {\n+\t// \ud83d\udea8 SECURITY: Local addresses must not be allowed by non-admins to prevent SSRF,\n+\t// see https://github.com/gogs/gogs/issues/5366 for details.\n+\tpayloadURL, err := url.Parse(w.URL)\n+\tif err != nil {\n+\t\treturn \"PayloadURL\", l.Tr(\"repo.settings.webhook.err_cannot_parse_payload_url\", err), false\n \t}\n \n+\tif netutil.IsBlockedLocalHostname(payloadURL.Hostname(), conf.Security.LocalNetworkAllowlist) {\n+\t\treturn \"PayloadURL\", l.Tr(\"repo.settings.webhook.url_resolved_to_blocked_local_address\"), false\n+\t}\n \treturn \"\", \"\", true\n }\n \n@@ -144,7 +141,7 @@ func validateAndCreateWebhook(c *context.Context, orCtx *orgRepoContext, w *db.W\n \t\treturn\n \t}\n \n-\tfield, msg, ok := validateWebhook(c.User, c.Locale, w)\n+\tfield, msg, ok := validateWebhook(c.Locale, w)\n \tif !ok {\n \t\tc.FormErr(field)\n \t\tc.RenderWithErr(msg, orCtx.TmplNew, nil)\n@@ -348,7 +345,7 @@ func validateAndUpdateWebhook(c *context.Context, orCtx *orgRepoContext, w *db.W\n \t\treturn\n \t}\n \n-\tfield, msg, ok := validateWebhook(c.User, c.Locale, w)\n+\tfield, msg, ok := validateWebhook(c.Locale, w)\n \tif !ok {\n \t\tc.FormErr(field)\n \t\tc.RenderWithErr(msg, orCtx.TmplNew, nil)"
        },
        {
          "filename": "internal/route/repo/webhook_test.go",
          "status": "modified",
          "additions": 3,
          "deletions": 5,
          "patch": "@@ -31,23 +31,21 @@ func Test_validateWebhook(t *testing.T) {\n \t}{\n \t\t{\n \t\t\tname:    \"admin bypass local address check\",\n-\t\t\tactor:   &db.User{IsAdmin: true},\n-\t\t\twebhook: &db.Webhook{URL: \"http://localhost:3306\"},\n+\t\t\twebhook: &db.Webhook{URL: \"https://www.google.com\"},\n \t\t\texpOK:   true,\n \t\t},\n \n \t\t{\n \t\t\tname:     \"local address not allowed\",\n-\t\t\tactor:    &db.User{},\n \t\t\twebhook:  &db.Webhook{URL: \"http://localhost:3306\"},\n \t\t\texpField: \"PayloadURL\",\n-\t\t\texpMsg:   \"repo.settings.webhook.err_cannot_use_local_addresses\",\n+\t\t\texpMsg:   \"repo.settings.webhook.url_resolved_to_blocked_local_address\",\n \t\t\texpOK:    false,\n \t\t},\n \t}\n \tfor _, test := range tests {\n \t\tt.Run(test.name, func(t *testing.T) {\n-\t\t\tfield, msg, ok := validateWebhook(test.actor, l, test.webhook)\n+\t\t\tfield, msg, ok := validateWebhook(l, test.webhook)\n \t\t\tassert.Equal(t, test.expOK, ok)\n \t\t\tassert.Equal(t, test.expMsg, msg)\n \t\t\tassert.Equal(t, test.expField, field)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 7,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "96d5d622b8d55c426861df74de8b88dc9870d36f",
            "date": "2025-01-02T00:46:13Z",
            "author_login": "unknwon"
          },
          {
            "sha": "b59e943aa65316a74a6c0a51941ffd7263744f5c",
            "date": "2025-01-02T00:41:24Z",
            "author_login": "MarcUs7i"
          },
          {
            "sha": "371a6092ded5250757fd9d62adc0eb220faea360",
            "date": "2025-01-01T16:18:34Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "e6896eb3935e49242424b58ea082b3cfc4502caa",
            "date": "2025-01-01T16:11:51Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "6c04a1ce7c754e295b0cd2f6963a79fe1bfb6688",
            "date": "2025-01-01T15:37:55Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-918",
    "description": "Server-Side Request Forgery (SSRF) in GitHub repository gogs/gogs prior to 0.12.8.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-06-01T06:15:07.193",
    "last_modified": "2024-11-21T06:40:24.783",
    "fix_date": "2022-05-31T07:17:17Z"
  },
  "references": [
    {
      "url": "https://github.com/gogs/gogs/commit/7885f454a4946c4bbec1b4f8c603b5eea7429c7f",
      "source": "security@huntr.dev",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/da1fbd6e-7a02-458e-9c2e-6d226c47046d",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/gogs/gogs/commit/7885f454a4946c4bbec1b4f8c603b5eea7429c7f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/da1fbd6e-7a02-458e-9c2e-6d226c47046d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:07.196161",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "gogs",
    "owner": "gogs",
    "created_at": "2014-02-12T01:57:08Z",
    "updated_at": "2025-01-14T08:26:37Z",
    "pushed_at": "2025-01-02T00:46:14Z",
    "size": 207255,
    "stars": 45328,
    "forks": 4884,
    "open_issues": 940,
    "watchers": 45328,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Go": 1511466,
      "Less": 60542,
      "JavaScript": 47845,
      "Shell": 26321,
      "Batchfile": 932,
      "Dockerfile": 890,
      "Procfile": 33
    },
    "commit_activity": {
      "total_commits_last_year": 105,
      "avg_commits_per_week": 2.019230769230769,
      "days_active_last_year": 55
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T12:56:32.136099"
  }
}