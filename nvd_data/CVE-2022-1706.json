{
  "cve_id": "CVE-2022-1706",
  "github_data": {
    "repository": "coreos/ignition",
    "fix_commit": "4b70b44b430ecf8377a276e89b5acd3a6957d4ea",
    "related_commits": [
      "4b70b44b430ecf8377a276e89b5acd3a6957d4ea",
      "4b70b44b430ecf8377a276e89b5acd3a6957d4ea"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "4b70b44b430ecf8377a276e89b5acd3a6957d4ea",
      "commit_date": "2022-05-03T15:46:41Z",
      "author": {
        "login": "bgilbert",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #1350 from bgilbert/userdata",
        "length": 112,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 3632,
        "additions": 3342,
        "deletions": 290
      },
      "files": [
        {
          "filename": "Makefile",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -23,8 +23,11 @@ install: all\n \t  install -m 0644 -D -t $(DESTDIR)/usr/lib/dracut/modules.d/$${bn} $$x/*; \\\n \tdone\n \tchmod a+x $(DESTDIR)/usr/lib/dracut/modules.d/*/*.sh $(DESTDIR)/usr/lib/dracut/modules.d/*/*-generator\n+\tinstall -m 0644 -D -t $(DESTDIR)/usr/lib/systemd/system systemd/ignition-delete-config.service\n \tinstall -m 0755 -D -t $(DESTDIR)/usr/lib/dracut/modules.d/30ignition bin/$(GOARCH)/ignition\n \tinstall -m 0755 -D -t $(DESTDIR)/usr/bin bin/$(GOARCH)/ignition-validate\n+\tinstall -m 0755 -d $(DESTDIR)/usr/libexec\n+\tln -sf ../lib/dracut/modules.d/30ignition/ignition $(DESTDIR)/usr/libexec/ignition-rmcfg\n \n .PHONY: vendor\n vendor:"
        },
        {
          "filename": "go.mod",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -6,18 +6,17 @@ require (\n \tcloud.google.com/go v0.58.0\n \tcloud.google.com/go/storage v1.9.0\n \tgithub.com/aws/aws-sdk-go v1.30.28\n+\tgithub.com/beevik/etree v1.1.1-0.20200718192613-4a2f8b9d084c\n \tgithub.com/coreos/go-semver v0.3.0\n \tgithub.com/coreos/go-systemd/v22 v22.0.0\n \tgithub.com/coreos/vcontext v0.0.0-20211021162308-f1dbbca7bef4\n \tgithub.com/google/renameio v0.1.0\n \tgithub.com/google/uuid v1.1.1\n \tgithub.com/pin/tftp v2.1.0+incompatible\n-\tgithub.com/smartystreets/goconvey v0.0.0-20190222223459-a17d461953aa // indirect\n \tgithub.com/spf13/pflag v1.0.6-0.20210604193023-d5e0c0615ace\n \tgithub.com/stretchr/testify v1.7.0\n \tgithub.com/vincent-petithory/dataurl v1.0.0\n \tgithub.com/vmware/vmw-guestinfo v0.0.0-20220317130741-510905f0efa3\n-\tgithub.com/vmware/vmw-ovflib v0.0.0-20170608004843-1f217b9dc714\n \tgo.opencensus.io v0.22.5 // indirect\n \tgolang.org/x/net v0.0.0-20200602114024-627f9648deb9\n \tgolang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d"
        },
        {
          "filename": "go.sum",
          "status": "modified",
          "additions": 2,
          "deletions": 10,
          "patch": "@@ -40,6 +40,8 @@ github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03\n github.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=\n github.com/aws/aws-sdk-go v1.30.28 h1:SaPM7dlmp7h3Lj1nJ4jdzOkTdom08+g20k7AU5heZYg=\n github.com/aws/aws-sdk-go v1.30.28/go.mod h1:5zCpMtNQVjRREroY7sYe8lOMRSxkhG6MZveU8YkpAk0=\n+github.com/beevik/etree v1.1.1-0.20200718192613-4a2f8b9d084c h1:uYq6BD31fkfeNKQmfLj7ODcEfkb5JLsKrXVSqgnfGg8=\n+github.com/beevik/etree v1.1.1-0.20200718192613-4a2f8b9d084c/go.mod h1:0yGO2rna3S9DkITDWHY1bMtcY4IJ4w+4S+EooZUR0bE=\n github.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\n github.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\n github.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\n@@ -115,8 +117,6 @@ github.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+\n github.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=\n github.com/googleapis/gax-go/v2 v2.0.5 h1:sjZBwGj9Jlw33ImPtvFviGYvseOtDM7hkSKB7+Tv3SM=\n github.com/googleapis/gax-go/v2 v2.0.5/go.mod h1:DWXyrwAJ9X0FpwwEdw+IPEYBICEFu5mhpdKc/us6bOk=\n-github.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1 h1:EGx4pi6eqNxGaHF6qqu48+N2wcFQ5qg5FXgOdqsJ5d8=\n-github.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=\n github.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\n github.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\n github.com/ianlancetaylor/demangle v0.0.0-20181102032728-5e5cf60278f6/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=\n@@ -125,8 +125,6 @@ github.com/jmespath/go-jmespath v0.3.0/go.mod h1:9QtRXoHjLGCJ5IBSaohpXITPlowMeeY\n github.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=\n github.com/jstemmer/go-junit-report v0.9.1 h1:6QPYqodiu3GuPL+7mfx+NwDdp2eTkp9IfEUpgAwUN0o=\n github.com/jstemmer/go-junit-report v0.9.1/go.mod h1:Brl9GWCQeLvo8nXZwPNNblvFj/XSXhF0NWZEnDohbsk=\n-github.com/jtolds/gls v4.2.1+incompatible h1:fSuqC+Gmlu6l/ZYAoZzx2pyucC8Xza35fpRVWLVmUEE=\n-github.com/jtolds/gls v4.2.1+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=\n github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\n github.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=\n github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\n@@ -140,10 +138,6 @@ github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZb\n github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\n github.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\n github.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=\n-github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d h1:zE9ykElWQ6/NYmHa3jpm/yHnI4xSofP+UP6SpjHcSeM=\n-github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=\n-github.com/smartystreets/goconvey v0.0.0-20190222223459-a17d461953aa h1:E+gaaifzi2xF65PbDmuKI3PhLWY6G5opMLniFq8vmXA=\n-github.com/smartystreets/goconvey v0.0.0-20190222223459-a17d461953aa/go.mod h1:2RVY1rIf+2J2o/IM9+vPq9RzmHDSseB7FoXiSNIUsoU=\n github.com/spf13/pflag v1.0.6-0.20210604193023-d5e0c0615ace h1:9PNP1jnUjRhfmGMlkXHjYPishpcw4jpSt/V/xYY3FMA=\n github.com/spf13/pflag v1.0.6-0.20210604193023-d5e0c0615ace/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\n github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\n@@ -155,8 +149,6 @@ github.com/vincent-petithory/dataurl v1.0.0 h1:cXw+kPto8NLuJtlMsI152irrVw9fRDX8A\n github.com/vincent-petithory/dataurl v1.0.0/go.mod h1:FHafX5vmDzyP+1CQATJn7WFKc9CvnvxyvZy6I1MrG/U=\n github.com/vmware/vmw-guestinfo v0.0.0-20220317130741-510905f0efa3 h1:v6jG/tdl4O07LNVp74Nt7/OyL+1JsIW1M2f/nSvQheY=\n github.com/vmware/vmw-guestinfo v0.0.0-20220317130741-510905f0efa3/go.mod h1:CSBTxrhePCm0cmXNKDGeu+6bOQzpaEklfCqEpn89JWk=\n-github.com/vmware/vmw-ovflib v0.0.0-20170608004843-1f217b9dc714 h1:wJqF3m4Tj8I4beSi6vGxIyNtsq6wwGqhK3UnA99ltL4=\n-github.com/vmware/vmw-ovflib v0.0.0-20170608004843-1f217b9dc714/go.mod h1:jiPk45kn7klhByRvUq5i2vo1RtHKBHj+iWGFpxbXuuI=\n github.com/yuin/goldmark v1.1.25/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\n github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\n go.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU="
        },
        {
          "filename": "internal/main.go",
          "status": "modified",
          "additions": 57,
          "deletions": 3,
          "patch": "@@ -41,10 +41,13 @@ import (\n )\n \n func main() {\n-\tif filepath.Base(os.Args[0]) == \"ignition-apply\" {\n+\tswitch filepath.Base(os.Args[0]) {\n+\tcase \"ignition-apply\":\n \t\tignitionApplyMain()\n-\t} else {\n-\t\t// otherwise, assume regular Ignition\n+\tcase \"ignition-rmcfg\":\n+\t\tignitionRmCfgMain()\n+\tdefault:\n+\t\t// assume regular Ignition\n \t\tignitionMain()\n \t}\n }\n@@ -187,3 +190,54 @@ func ignitionApplyMain() {\n \t\tos.Exit(1)\n \t}\n }\n+\n+func ignitionRmCfgMain() {\n+\tflags := struct {\n+\t\tlogToStdout bool\n+\t\tplatform    string\n+\t\tversion     bool\n+\t}{}\n+\tpflag.StringVar(&flags.platform, \"platform\", \"\", fmt.Sprintf(\"current platform. %v\", platform.Names()))\n+\tpflag.BoolVar(&flags.logToStdout, \"log-to-stdout\", false, \"log to stdout instead of the system log\")\n+\tpflag.BoolVar(&flags.version, \"version\", false, \"print the version and exit\")\n+\tpflag.Usage = func() {\n+\t\tfmt.Fprintf(pflag.CommandLine.Output(), \"Usage: %s [options]\\n\", os.Args[0])\n+\t\tfmt.Fprintf(pflag.CommandLine.Output(), \"Options:\\n\")\n+\t\tpflag.PrintDefaults()\n+\t}\n+\tpflag.Parse()\n+\n+\tif flags.version {\n+\t\tfmt.Printf(\"%s\\n\", version.String)\n+\t\treturn\n+\t}\n+\n+\tif pflag.NArg() != 0 {\n+\t\tpflag.Usage()\n+\t\tos.Exit(2)\n+\t}\n+\n+\tif flags.platform == \"\" {\n+\t\tfmt.Fprint(os.Stderr, \"'--platform' must be provided\\n\")\n+\t\tos.Exit(2)\n+\t}\n+\n+\tlogger := log.New(flags.logToStdout)\n+\tdefer logger.Close()\n+\n+\tlogger.Info(version.String)\n+\n+\tplatformConfig := platform.MustGet(flags.platform)\n+\tfetcher, err := platformConfig.NewFetcherFunc()(&logger)\n+\tif err != nil {\n+\t\tlogger.Crit(\"failed to generate fetcher: %s\", err)\n+\t\tos.Exit(3)\n+\t}\n+\n+\tif err := platformConfig.DelConfig(&fetcher); err != nil {\n+\t\tlogger.Crit(\"couldn't delete config: %s\", err)\n+\t\tos.Exit(1)\n+\t}\n+\n+\tlogger.Info(\"Successfully deleted config\")\n+}"
        },
        {
          "filename": "internal/platform/platform.go",
          "status": "modified",
          "additions": 20,
          "deletions": 4,
          "patch": "@@ -15,6 +15,7 @@\n package platform\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \n \t\"github.com/coreos/ignition/v2/internal/log\"\n@@ -44,13 +45,18 @@ import (\n \t\"github.com/coreos/ignition/v2/internal/resource\"\n )\n \n+var (\n+\tErrCannotDelete = errors.New(\"cannot delete config on this platform\")\n+)\n+\n // Config represents a set of options that map to a particular platform.\n type Config struct {\n \tname       string\n \tfetch      providers.FuncFetchConfig\n \tinit       providers.FuncInit\n \tnewFetcher providers.FuncNewFetcher\n \tstatus     providers.FuncPostStatus\n+\tdelConfig  providers.FuncDelConfig\n }\n \n func (c Config) Name() string {\n@@ -93,6 +99,14 @@ func (c Config) Status(stageName string, f resource.Fetcher, statusErr error) er\n \treturn nil\n }\n \n+func (c Config) DelConfig(f *resource.Fetcher) error {\n+\tif c.delConfig != nil {\n+\t\treturn c.delConfig(f)\n+\t} else {\n+\t\treturn ErrCannotDelete\n+\t}\n+}\n+\n var configs = registry.Create(\"platform configs\")\n \n func init() {\n@@ -172,12 +186,14 @@ func init() {\n \t\tfetch: qemu.FetchConfig,\n \t})\n \tconfigs.Register(Config{\n-\t\tname:  \"virtualbox\",\n-\t\tfetch: virtualbox.FetchConfig,\n+\t\tname:      \"virtualbox\",\n+\t\tfetch:     virtualbox.FetchConfig,\n+\t\tdelConfig: virtualbox.DelConfig,\n \t})\n \tconfigs.Register(Config{\n-\t\tname:  \"vmware\",\n-\t\tfetch: vmware.FetchConfig,\n+\t\tname:      \"vmware\",\n+\t\tfetch:     vmware.FetchConfig,\n+\t\tdelConfig: vmware.DelConfig,\n \t})\n \tconfigs.Register(Config{\n \t\tname:  \"vultr\","
        },
        {
          "filename": "internal/providers/providers.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -32,3 +32,4 @@ type FuncFetchConfig func(f *resource.Fetcher) (types.Config, report.Report, err\n type FuncInit func(f *resource.Fetcher) error\n type FuncNewFetcher func(logger *log.Logger) (resource.Fetcher, error)\n type FuncPostStatus func(stageName string, f resource.Fetcher, e error) error\n+type FuncDelConfig func(f *resource.Fetcher) error"
        },
        {
          "filename": "internal/providers/virtualbox/virtualbox.c",
          "status": "modified",
          "additions": 86,
          "deletions": 4,
          "patch": "@@ -24,6 +24,10 @@\n #include <errno.h>\n #include \"virtualbox.h\"\n \n+// From virtualbox/include/VBox/HostServices/GuestPropertySvc.h\n+#define GUEST_PROP_FN_GET_PROP 1\n+#define GUEST_PROP_FN_DEL_PROP 4\n+\n static void _cleanup_close(int *fd) {\n \tif (*fd != -1) {\n \t\tclose(*fd);\n@@ -86,13 +90,16 @@ static int connect(int fd, uint32_t *client_id) {\n }\n \n static int get_prop(int fd, uint32_t client_id, const char *name, void **value, size_t *size) {\n+\t// xref VbglR3GuestPropRead() in\n+\t// virtualbox/src/VBox/Additions/common/VBoxGuest/lib/VBoxGuestR3LibGuestProp.cpp\n+\n \t// init header\n \tsize_t msg_size = sizeof(struct vbg_ioctl_hgcm_call) + 4 * sizeof(struct vmmdev_hgcm_function_parameter64);\n \tstruct vbg_ioctl_hgcm_call _cleanup_free_ *msg = calloc(1, msg_size);\n \t// init_header re-adds the size of msg->hdr\n \tinit_header(&msg->hdr, msg_size - sizeof(msg->hdr), msg_size - sizeof(msg->hdr));\n \tmsg->client_id = client_id;\n-\tmsg->function = 1;     // GUEST_PROP_FN_GET_PROP\n+\tmsg->function = GUEST_PROP_FN_GET_PROP;\n \tmsg->timeout_ms = -1;  // inf\n \tmsg->interruptible = 1;\n \tmsg->parm_count = 4;\n@@ -147,6 +154,38 @@ static int get_prop(int fd, uint32_t client_id, const char *name, void **value,\n \t}\n }\n \n+static int del_prop(int fd, uint32_t client_id, const char *name) {\n+\t// xref VbglR3GuestPropDelete() in\n+\t// virtualbox/src/VBox/Additions/common/VBoxGuest/lib/VBoxGuestR3LibGuestProp.cpp\n+\n+\t// init header\n+\tsize_t msg_size = sizeof(struct vbg_ioctl_hgcm_call) + sizeof(struct vmmdev_hgcm_function_parameter64);\n+\tstruct vbg_ioctl_hgcm_call _cleanup_free_ *msg = calloc(1, msg_size);\n+\t// init_header re-adds the size of msg->hdr\n+\tinit_header(&msg->hdr, msg_size - sizeof(msg->hdr), msg_size - sizeof(msg->hdr));\n+\tmsg->client_id = client_id;\n+\tmsg->function = GUEST_PROP_FN_DEL_PROP;\n+\tmsg->timeout_ms = -1;  // inf\n+\tmsg->interruptible = 1;\n+\tmsg->parm_count = 1;\n+\n+\t// init arguments\n+\tstruct vmmdev_hgcm_function_parameter64 *params = (void *) (msg + 1);\n+\t// property name (in)\n+\tparams[0].type = VMMDEV_HGCM_PARM_TYPE_LINADDR_IN;\n+\tparams[0].u.pointer.size = strlen(name) + 1;\n+\tparams[0].u.pointer.u.linear_addr = (uintptr_t) name;\n+\n+\t// delete value\n+\tif (ioctl(fd, VBG_IOCTL_HGCM_CALL_64(msg_size), msg)) {\n+\t\treturn VERR_GENERAL_FAILURE;\n+\t}\n+\tif (msg->hdr.rc != VINF_SUCCESS) {\n+\t\treturn msg->hdr.rc;\n+\t}\n+\treturn VINF_SUCCESS;\n+}\n+\n static int disconnect(int fd, uint32_t client_id) {\n \tstruct vbg_ioctl_hgcm_disconnect msg = {\n \t\t.u = {\n@@ -162,7 +201,7 @@ static int disconnect(int fd, uint32_t client_id) {\n \treturn msg.hdr.rc;\n }\n \n-int virtualbox_get_guest_property(char *name, void **value, size_t *size) {\n+static int start_connection(uint32_t *client_id) {\n \t// clear any previous garbage in errno for error returns\n \terrno = 0;\n \n@@ -179,12 +218,26 @@ int virtualbox_get_guest_property(char *name, void **value, size_t *size) {\n \t}\n \n \t// connect to property service\n-\tuint32_t client_id;\n-\tret = connect(fd, &client_id);\n+\tret = connect(fd, client_id);\n \tif (ret != VINF_SUCCESS) {\n \t\treturn ret;\n \t}\n \n+\t// return fd\n+\tret = fd;\n+\tfd = -1;\n+\treturn ret;\n+}\n+\n+int virtualbox_get_guest_property(char *name, void **value, size_t *size) {\n+\t// connect\n+\tuint32_t client_id;\n+\tint ret = start_connection(&client_id);\n+\tif (ret < 0) {\n+\t\treturn ret;\n+\t}\n+\tint _cleanup_close_ fd = ret;\n+\n \t// get property\n \tret = get_prop(fd, client_id, name, value, size);\n \tif (ret != VINF_SUCCESS) {\n@@ -206,3 +259,32 @@ int virtualbox_get_guest_property(char *name, void **value, size_t *size) {\n \terrno = 0;\n \treturn 0;\n }\n+\n+int virtualbox_delete_guest_property(char *name) {\n+\t// connect\n+\tuint32_t client_id;\n+\tint ret = start_connection(&client_id);\n+\tif (ret < 0) {\n+\t\treturn ret;\n+\t}\n+\tint _cleanup_close_ fd = ret;\n+\n+\t// delete property\n+\tret = del_prop(fd, client_id, name);\n+\tif (ret != VINF_SUCCESS) {\n+\t\tdisconnect(fd, client_id);\n+\t\treturn ret;\n+\t}\n+\n+\t// disconnect\n+\tret = disconnect(fd, client_id);\n+\tif (ret != VINF_SUCCESS) {\n+\t\t// we could ignore the failure, but better to make sure bugs\n+\t\t// are noticed\n+\t\treturn ret;\n+\t}\n+\n+\t// for clarity, ensure the Go error return is nil\n+\terrno = 0;\n+\treturn 0;\n+}"
        },
        {
          "filename": "internal/providers/virtualbox/virtualbox.go",
          "status": "modified",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -69,6 +69,19 @@ func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {\n \treturn util.ParseConfig(f.Logger, config)\n }\n \n+func DelConfig(f *resource.Fetcher) error {\n+\tf.Logger.Info(\"deleting Ignition config from VirtualBox guest property\")\n+\terr := deleteProperty(configEncodingProperty)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\terr = deleteProperty(configProperty)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n func fetchProperty(name string) ([]byte, error) {\n \tcName := C.CString(name)\n \tdefer C.free(unsafe.Pointer(cName))\n@@ -96,3 +109,21 @@ func fetchProperty(name string) ([]byte, error) {\n \t}\n \treturn s[0:len], nil\n }\n+\n+func deleteProperty(name string) error {\n+\tcName := C.CString(name)\n+\tdefer C.free(unsafe.Pointer(cName))\n+\n+\tret, errno := C.virtualbox_delete_guest_property(cName)\n+\tif ret != C.VINF_SUCCESS {\n+\t\tif ret == C.VERR_GENERAL_FAILURE && errno != nil {\n+\t\t\treturn fmt.Errorf(\"deleting VirtualBox guest property %q: %w\", name, errno)\n+\t\t}\n+\t\tif ret == C.VERR_PERMISSION_DENIED {\n+\t\t\treturn fmt.Errorf(\"deleting VirtualBox guest property %q: permission denied; is the property read-only?\", name)\n+\t\t}\n+\t\t// see <linux/vbox_err.h>\n+\t\treturn fmt.Errorf(\"deleting VirtualBox guest property %q: error %d\", name, ret)\n+\t}\n+\treturn nil\n+}"
        },
        {
          "filename": "internal/providers/virtualbox/virtualbox.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -16,5 +16,6 @@\n #define IGNITION_VIRTUALBOX_H\n \n int virtualbox_get_guest_property(char *name, void **value, size_t *size);\n+int virtualbox_delete_guest_property(char *name);\n \n #endif"
        },
        {
          "filename": "internal/providers/vmware/ovf.go",
          "status": "added",
          "additions": 123,
          "deletions": 0,
          "patch": "@@ -0,0 +1,123 @@\n+// Copyright 2014-2015 VMware, Inc. All Rights Reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Originally from https://github.com/vmware-archive/vmw-ovflib\n+\n+package vmware\n+\n+import (\n+\t\"encoding/xml\"\n+\t\"fmt\"\n+\n+\t\"github.com/beevik/etree\"\n+)\n+\n+const (\n+\tXMLNS = \"http://schemas.dmtf.org/ovf/environment/1\"\n+)\n+\n+type environment struct {\n+\tPlatform   platform   `xml:\"PlatformSection\"`\n+\tProperties []property `xml:\"PropertySection>Property\"`\n+}\n+\n+type platform struct {\n+\tKind    string `xml:\"Kind\"`\n+\tVersion string `xml:\"Version\"`\n+\tVendor  string `xml:\"Vendor\"`\n+\tLocale  string `xml:\"Locale\"`\n+}\n+\n+type property struct {\n+\tKey   string `xml:\"key,attr\"`\n+\tValue string `xml:\"value,attr\"`\n+}\n+\n+type OvfEnvironment struct {\n+\tPlatform   platform\n+\tProperties map[string]string\n+}\n+\n+func ReadOvfEnvironment(doc []byte) (OvfEnvironment, error) {\n+\tvar env environment\n+\tif err := xml.Unmarshal(doc, &env); err != nil {\n+\t\treturn OvfEnvironment{}, err\n+\t}\n+\n+\tdict := make(map[string]string)\n+\tfor _, p := range env.Properties {\n+\t\tdict[p.Key] = p.Value\n+\t}\n+\treturn OvfEnvironment{Properties: dict, Platform: env.Platform}, nil\n+}\n+\n+// Return the new OVF document, and true if anything was deleted.\n+func DeleteOvfProperties(from []byte, props []string) ([]byte, bool, error) {\n+\t// parse document\n+\tdoc := etree.NewDocument()\n+\tif err := doc.ReadFromBytes(from); err != nil {\n+\t\treturn nil, false, fmt.Errorf(\"parsing OVF environment: %w\", err)\n+\t}\n+\n+\t// build set of properties to drop\n+\tdrops := make(map[string]struct{})\n+\tfor _, prop := range props {\n+\t\tdrops[prop] = struct{}{}\n+\t}\n+\n+\t// etree's XPath implementation isn't rigorous about keeping\n+\t// separate namespaces separate.  Be extra-careful to check\n+\t// namespace URIs everywhere.\n+\tremoved := false\n+\tfor _, parent := range doc.FindElements(\"/Environment[namespace-uri()='\" + XMLNS + \"']/PropertySection[namespace-uri()='\" + XMLNS + \"']\") {\n+\t\t// walk each property\n+\t\tvar remove []*etree.Element\n+\t\tfor _, el := range parent.ChildElements() {\n+\t\t\tif el.NamespaceURI() != XMLNS {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t// walk attrs by hand so we can check namespaces\n+\t\t\tfor _, attr := range el.Attr {\n+\t\t\t\tif attr.NamespaceURI() != XMLNS {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\t// queue property for removal if it's on the\n+\t\t\t\t// list\n+\t\t\t\tif attr.Key == \"key\" {\n+\t\t\t\t\tif _, drop := drops[attr.Value]; drop {\n+\t\t\t\t\t\tremove = append(remove, el)\n+\t\t\t\t\t\tremoved = true\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t// remove queued properties\n+\t\tfor _, el := range remove {\n+\t\t\tparent.RemoveChild(el)\n+\t\t}\n+\t}\n+\n+\t// Out of caution, if we didn't find anything to remove, return\n+\t// the input bytes rather than reserializing.\n+\tif !removed {\n+\t\treturn from, removed, nil\n+\t}\n+\n+\tto, err := doc.WriteToBytes()\n+\tif err != nil {\n+\t\treturn nil, false, fmt.Errorf(\"serializing OVF environment: %w\", err)\n+\t}\n+\treturn to, removed, nil\n+}"
        },
        {
          "filename": "internal/providers/vmware/ovf_test.go",
          "status": "added",
          "additions": 177,
          "deletions": 0,
          "patch": "@@ -0,0 +1,177 @@\n+// Copyright 2014-2015 VMware, Inc. All Rights Reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Originally from https://github.com/vmware-archive/vmw-ovflib\n+\n+package vmware\n+\n+import (\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+var data_vsphere = []byte(`<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Environment\n+     xmlns=\"http://schemas.dmtf.org/ovf/environment/1\"\n+     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+     xmlns:oe=\"http://schemas.dmtf.org/ovf/environment/1\"\n+     xmlns:ve=\"http://www.vmware.com/schema/ovfenv\"\n+     oe:id=\"\"\n+     ve:vCenterId=\"vm-12345\">\n+   <PlatformSection>\n+      <Kind>VMware ESXi</Kind>\n+      <Version>5.5.0</Version>\n+      <Vendor>VMware, Inc.</Vendor>\n+      <Locale>en</Locale>\n+   </PlatformSection>\n+   <PropertySection>\n+         <Property oe:key=\"foo\" oe:value=\"42\"/>\n+         <Property oe:key=\"bar\" oe:value=\"0\"/>\n+   </PropertySection>\n+   <ve:EthernetAdapterSection>\n+      <ve:Adapter ve:mac=\"00:00:00:00:00:00\" ve:network=\"foo\" ve:unitNumber=\"7\"/>\n+   </ve:EthernetAdapterSection>\n+</Environment>`)\n+\n+var data_vapprun = []byte(`<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Environment xmlns=\"http://schemas.dmtf.org/ovf/environment/1\"\n+     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+     xmlns:oe=\"http://schemas.dmtf.org/ovf/environment/1\"\n+     oe:id=\"CoreOS-vmw\">\n+   <PlatformSection>\n+      <Kind>vapprun</Kind>\n+      <Version>1.0</Version>\n+      <Vendor>VMware, Inc.</Vendor>\n+      <Locale>en_US</Locale>\n+   </PlatformSection>\n+   <PropertySection>\n+      <Property oe:key=\"foo\" oe:value=\"42\"/>\n+      <Property oe:key=\"bar\" oe:value=\"0\"/>\n+      <Property oe:key=\"guestinfo.user_data.url\" oe:value=\"https://gist.githubusercontent.com/sigma/5a64aac1693da9ca70d2/raw/plop.yaml\"/>\n+      <Property oe:key=\"guestinfo.user_data.doc\" oe:value=\"\"/>\n+      <Property oe:key=\"guestinfo.meta_data.url\" oe:value=\"\"/>\n+      <Property oe:key=\"guestinfo.meta_data.doc\" oe:value=\"\"/>\n+   </PropertySection>\n+</Environment>`)\n+\n+var data_delete_prop_simple = []byte(`<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Environment xmlns=\"http://schemas.dmtf.org/ovf/environment/1\" xmlns:a=\"http://schemas.dmtf.org/ovf/environment/1\">\n+   <Invalid>\n+     <InvalidKey>garbage!</InvalidKey>\n+   </Invalid>\n+   <PropertySection>\n+      <!-- XML attributes don't default to the default namespace -->\n+      <Property a:key=\"guestinfo.ignition.config.data\" value=\"remove\"/>\n+      <Property a:key=\"guestinfo.ignition.config.data.encoding\" value=\"remove\"/>\n+   </PropertySection>\n+</Environment>`)\n+\n+var data_delete_prop_complex = []byte(`<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Environment xmlns=\"http://schemas.dmtf.org/ovf/environment/1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:oe=\"http://schemas.dmtf.org/ovf/environment/1\" xmlns:ex=\"http://example.com/xmlns\" oe:id=\"ignition-vmw\">\n+   <PlatformSection>\n+      <Kind>vapprun</Kind>\n+      <Version>1.0</Version>\n+      <Vendor>VMware, Inc.</Vendor>\n+      <Locale>en_US</Locale>\n+   </PlatformSection>\n+   <Invalid>\n+     <InvalidKey>garbage!</InvalidKey>\n+   </Invalid>\n+   <PropertySection>\n+      <Property ex:key=\"guestinfo.ignition.config.data.encoding\" oe:value=\"keep\"/>\n+      <ex:Property oe:key=\"guestinfo.ignition.config.data.encoding\" oe:value=\"keep\"/>\n+      <Property oe:key=\"guestinfo.ignition.config.data\" oe:value=\"remove\"/>\n+      <Property oe:key=\"guestinfo.ignition.config.data.encoding\" oe:value=\"remove\"/>\n+      <Property oe:key=\"bar\" oe:value=\"0\"/>\n+   </PropertySection>\n+   <ex:PropertySection>\n+      <Property oe:key=\"guestinfo.ignition.config.data\" oe:value=\"keep\"/>\n+      <Property oe:key=\"guestinfo.ignition.config.data.encoding\" oe:value=\"keep\"/>\n+   </ex:PropertySection>\n+</Environment>`)\n+\n+func TestOvfEnvProperties(t *testing.T) {\n+\tvar testOne = func(env_str []byte) {\n+\t\tenv, err := ReadOvfEnvironment(env_str)\n+\t\tassert.Nil(t, err)\n+\t\tprops := env.Properties\n+\n+\t\tvar val string\n+\t\tvar ok bool\n+\t\tval, ok = props[\"foo\"]\n+\t\tassert.True(t, ok)\n+\t\tassert.Equal(t, val, \"42\")\n+\n+\t\tval, ok = props[\"bar\"]\n+\t\tassert.True(t, ok)\n+\t\tassert.Equal(t, val, \"0\")\n+\t}\n+\n+\ttestOne(data_vapprun)\n+\ttestOne(data_vsphere)\n+}\n+\n+func TestOvfEnvPlatform(t *testing.T) {\n+\tenv, err := ReadOvfEnvironment(data_vsphere)\n+\tassert.Nil(t, err)\n+\tplatform := env.Platform\n+\n+\tassert.Equal(t, platform.Kind, \"VMware ESXi\")\n+\tassert.Equal(t, platform.Version, \"5.5.0\")\n+\tassert.Equal(t, platform.Vendor, \"VMware, Inc.\")\n+\tassert.Equal(t, platform.Locale, \"en\")\n+}\n+\n+func TestVappRunUserDataUrl(t *testing.T) {\n+\tenv, err := ReadOvfEnvironment(data_vapprun)\n+\tassert.Nil(t, err)\n+\tprops := env.Properties\n+\n+\tvar val string\n+\tvar ok bool\n+\n+\tval, ok = props[\"guestinfo.user_data.url\"]\n+\tassert.True(t, ok)\n+\tassert.Equal(t, val, \"https://gist.githubusercontent.com/sigma/5a64aac1693da9ca70d2/raw/plop.yaml\")\n+}\n+\n+func TestInvalidData(t *testing.T) {\n+\t_, err := ReadOvfEnvironment(append(data_vsphere, []byte(\"garbage\")...))\n+\tassert.Nil(t, err)\n+}\n+\n+func TestDeleteProps(t *testing.T) {\n+\tfor _, sample := range [][]byte{data_delete_prop_simple, data_delete_prop_complex, data_vapprun} {\n+\t\tvar expectedLines []string\n+\t\texpectedDelete := false\n+\t\tfor _, line := range strings.Split(string(sample), \"\\n\") {\n+\t\t\tif strings.Contains(line, \"remove\") {\n+\t\t\t\t// drop XML element, leave indentation\n+\t\t\t\tstartSkip := strings.IndexAny(line, \"<>\")\n+\t\t\t\tendSkip := strings.LastIndexAny(line, \"<>\")\n+\t\t\t\tline = line[:startSkip] + line[endSkip+1:]\n+\t\t\t\texpectedDelete = true\n+\t\t\t}\n+\t\t\texpectedLines = append(expectedLines, line)\n+\t\t}\n+\t\texpected := strings.Join(expectedLines, \"\\n\")\n+\n+\t\tresult, deleted, err := DeleteOvfProperties(sample, []string{\"guestinfo.ignition.config.data\", \"guestinfo.ignition.config.data.encoding\"})\n+\t\tassert.Nil(t, err)\n+\t\tassert.Equal(t, expected, string(result))\n+\t\tassert.Equal(t, expectedDelete, deleted)\n+\t}\n+}"
        },
        {
          "filename": "internal/providers/vmware/vmware_amd64.go",
          "status": "modified",
          "additions": 72,
          "deletions": 7,
          "patch": "@@ -18,6 +18,8 @@\n package vmware\n \n import (\n+\t\"fmt\"\n+\n \t\"github.com/coreos/ignition/v2/config/v3_4_experimental/types\"\n \t\"github.com/coreos/ignition/v2/internal/providers\"\n \t\"github.com/coreos/ignition/v2/internal/providers/util\"\n@@ -26,7 +28,19 @@ import (\n \t\"github.com/coreos/vcontext/report\"\n \t\"github.com/vmware/vmw-guestinfo/rpcvmx\"\n \t\"github.com/vmware/vmw-guestinfo/vmcheck\"\n-\t\"github.com/vmware/vmw-ovflib\"\n+)\n+\n+const (\n+\tGUESTINFO_OVF               = \"ovfenv\"\n+\tGUESTINFO_USERDATA          = \"ignition.config.data\"\n+\tGUESTINFO_USERDATA_ENCODING = \"ignition.config.data.encoding\"\n+\n+\tGUESTINFO_DELETED_USERDATA          = \"e30K\"\n+\tGUESTINFO_DELETED_USERDATA_ENCODING = \"base64\"\n+\n+\tOVF_PREFIX            = \"guestinfo.\"\n+\tOVF_USERDATA          = OVF_PREFIX + GUESTINFO_USERDATA\n+\tOVF_USERDATA_ENCODING = OVF_PREFIX + GUESTINFO_USERDATA_ENCODING\n )\n \n func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {\n@@ -57,27 +71,27 @@ func fetchRawConfig(f *resource.Fetcher) (config, error) {\n \tvar ovfData string\n \tvar ovfEncoding string\n \n-\tovfEnv, err := info.String(\"ovfenv\", \"\")\n+\tovfEnv, err := info.String(GUESTINFO_OVF, \"\")\n \tif err != nil {\n \t\tf.Logger.Warning(\"failed to fetch ovfenv: %v. Continuing...\", err)\n \t} else if ovfEnv != \"\" {\n \t\tf.Logger.Debug(\"using OVF environment from guestinfo\")\n-\t\tenv, err := ovf.ReadEnvironment([]byte(ovfEnv))\n+\t\tenv, err := ReadOvfEnvironment([]byte(ovfEnv))\n \t\tif err != nil {\n \t\t\tf.Logger.Warning(\"failed to parse OVF environment: %v. Continuing...\", err)\n \t\t}\n \n-\t\tovfData = env.Properties[\"guestinfo.ignition.config.data\"]\n-\t\tovfEncoding = env.Properties[\"guestinfo.ignition.config.data.encoding\"]\n+\t\tovfData = env.Properties[OVF_USERDATA]\n+\t\tovfEncoding = env.Properties[OVF_USERDATA_ENCODING]\n \t}\n \n-\tdata, err := info.String(\"ignition.config.data\", ovfData)\n+\tdata, err := info.String(GUESTINFO_USERDATA, ovfData)\n \tif err != nil {\n \t\tf.Logger.Debug(\"failed to fetch config: %v\", err)\n \t\treturn config{}, err\n \t}\n \n-\tencoding, err := info.String(\"ignition.config.data.encoding\", ovfEncoding)\n+\tencoding, err := info.String(GUESTINFO_USERDATA_ENCODING, ovfEncoding)\n \tif err != nil {\n \t\tf.Logger.Debug(\"failed to fetch config encoding: %v\", err)\n \t\treturn config{}, err\n@@ -88,3 +102,54 @@ func fetchRawConfig(f *resource.Fetcher) (config, error) {\n \t\tencoding: encoding,\n \t}, nil\n }\n+\n+func DelConfig(f *resource.Fetcher) error {\n+\tinfo := rpcvmx.NewConfig()\n+\n+\t// delete userdata if set and not already a deletion marker\n+\torig, err := info.String(GUESTINFO_USERDATA, GUESTINFO_DELETED_USERDATA)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"getting config property: %w\", err)\n+\t}\n+\tif orig != GUESTINFO_DELETED_USERDATA {\n+\t\t// we can't delete properties or set them to the empty\n+\t\t// string, so set encoding to \"base64\" and data to encoded \"{}\"\n+\t\tf.Logger.Info(\"deleting config from guestinfo properties\")\n+\t\tif err := info.SetString(GUESTINFO_USERDATA, GUESTINFO_DELETED_USERDATA); err != nil {\n+\t\t\treturn fmt.Errorf(\"replacing config: %w\", err)\n+\t\t}\n+\n+\t\t// overwrite encoding if unset or not already base64\n+\t\torigEncoding, err := info.String(GUESTINFO_USERDATA_ENCODING, \"\")\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"getting config encoding property: %w\", err)\n+\t\t}\n+\t\tif origEncoding != GUESTINFO_DELETED_USERDATA_ENCODING {\n+\t\t\tif err := info.SetString(GUESTINFO_USERDATA_ENCODING, GUESTINFO_DELETED_USERDATA_ENCODING); err != nil {\n+\t\t\t\treturn fmt.Errorf(\"replacing config encoding: %w\", err)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tovfEnv, err := info.String(GUESTINFO_OVF, \"\")\n+\tif err != nil {\n+\t\t// unlike FetchConfig, don't ignore errors, since that could\n+\t\t// have security implications\n+\t\treturn fmt.Errorf(\"reading OVF environment: %w\", err)\n+\t}\n+\tif ovfEnv != \"\" {\n+\t\tprunedData, didPrune, err := DeleteOvfProperties([]byte(ovfEnv), []string{OVF_USERDATA, OVF_USERDATA_ENCODING})\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"deleting OVF properties: %w\", err)\n+\t\t}\n+\t\t// don't rewrite the property if there's nothing to change\n+\t\tif didPrune {\n+\t\t\tf.Logger.Info(\"deleting config from OVF environment\")\n+\t\t\tif err := info.SetString(GUESTINFO_OVF, string(prunedData)); err != nil {\n+\t\t\t\treturn fmt.Errorf(\"replacing OVF environment: %w\", err)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}"
        },
        {
          "filename": "internal/providers/vmware/vmware_unsupported.go",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -32,3 +32,7 @@ import (\n func FetchConfig(_ *resource.Fetcher) (types.Config, report.Report, error) {\n \treturn types.Config{}, report.Report{}, errors.New(\"vmware provider is not supported on this architecture\")\n }\n+\n+func DelConfig(_ *resource.Fetcher) error {\n+\treturn errors.New(\"vmware provider is not supported on this architecture\")\n+}"
        },
        {
          "filename": "systemd/ignition-delete-config.service",
          "status": "added",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -0,0 +1,25 @@\n+[Unit]\n+Description=Ignition (delete config)\n+Documentation=https://coreos.github.io/ignition/\n+\n+ConditionFirstBoot=true\n+ConditionPathExists=/run/ignition.env\n+ConditionKernelCommandLine=|ignition.platform.id=virtualbox\n+ConditionKernelCommandLine=|ignition.platform.id=vmware\n+\n+DefaultDependencies=no\n+# Run before any user services to prevent potential config leaks\n+Before=sysinit.target\n+\n+OnFailure=emergency.target\n+OnFailureJobMode=isolate\n+\n+[Service]\n+Type=oneshot\n+EnvironmentFile=/run/ignition.env\n+ExecStart=/usr/libexec/ignition-rmcfg --platform=${PLATFORM_ID}\n+RemainAfterExit=yes\n+\n+[Install]\n+# Not RequiredBy, since we want to allow the unit to be masked\n+WantedBy=sysinit.target"
        },
        {
          "filename": "vendor/github.com/beevik/etree/.travis.yml",
          "status": "added",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -0,0 +1,18 @@\n+language: go\n+sudo: false\n+\n+env:\n+  - GO111MODULE=on\n+\n+go:\n+  - 1.11.x\n+  - 1.14.x\n+  - tip\n+\n+matrix:\n+  allow_failures:\n+    - go: tip\n+\n+script:\n+  - go vet ./...\n+  - go test -v ./..."
        },
        {
          "filename": "vendor/github.com/beevik/etree/CONTRIBUTORS",
          "status": "added",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -0,0 +1,10 @@\n+Brett Vickers (beevik)\n+Felix Geisend\u00f6rfer (felixge)\n+Kamil Kisiel (kisielk)\n+Graham King (grahamking)\n+Matt Smith (ma314smith)\n+Michal Jemala (michaljemala)\n+Nicolas Piganeau (npiganeau)\n+Chris Brown (ccbrown)\n+Earncef Sequeira (earncef)\n+Gabriel de Labachelerie (wuzuf)"
        },
        {
          "filename": "vendor/github.com/beevik/etree/LICENSE",
          "status": "added",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -0,0 +1,24 @@\n+Copyright 2015-2019 Brett Vickers. All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions\n+are met:\n+\n+   1. Redistributions of source code must retain the above copyright\n+      notice, this list of conditions and the following disclaimer.\n+\n+   2. Redistributions in binary form must reproduce the above copyright\n+      notice, this list of conditions and the following disclaimer in the\n+      documentation and/or other materials provided with the distribution.\n+\n+THIS SOFTWARE IS PROVIDED BY COPYRIGHT HOLDER ``AS IS'' AND ANY\n+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER OR\n+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n+OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
        },
        {
          "filename": "vendor/github.com/beevik/etree/README.md",
          "status": "added",
          "additions": 205,
          "deletions": 0,
          "patch": "@@ -0,0 +1,205 @@\n+[![Build Status](https://travis-ci.org/beevik/etree.svg?branch=master)](https://travis-ci.org/beevik/etree)\n+[![GoDoc](https://godoc.org/github.com/beevik/etree?status.svg)](https://godoc.org/github.com/beevik/etree)\n+\n+etree\n+=====\n+\n+The etree package is a lightweight, pure go package that expresses XML in\n+the form of an element tree.  Its design was inspired by the Python\n+[ElementTree](http://docs.python.org/2/library/xml.etree.elementtree.html)\n+module.\n+\n+Some of the package's capabilities and features:\n+\n+* Represents XML documents as trees of elements for easy traversal.\n+* Imports, serializes, modifies or creates XML documents from scratch.\n+* Writes and reads XML to/from files, byte slices, strings and io interfaces.\n+* Performs simple or complex searches with lightweight XPath-like query APIs.\n+* Auto-indents XML using spaces or tabs for better readability.\n+* Implemented in pure go; depends only on standard go libraries.\n+* Built on top of the go [encoding/xml](http://golang.org/pkg/encoding/xml)\n+  package.\n+\n+### Creating an XML document\n+\n+The following example creates an XML document from scratch using the etree\n+package and outputs its indented contents to stdout.\n+```go\n+doc := etree.NewDocument()\n+doc.CreateProcInst(\"xml\", `version=\"1.0\" encoding=\"UTF-8\"`)\n+doc.CreateProcInst(\"xml-stylesheet\", `type=\"text/xsl\" href=\"style.xsl\"`)\n+\n+people := doc.CreateElement(\"People\")\n+people.CreateComment(\"These are all known people\")\n+\n+jon := people.CreateElement(\"Person\")\n+jon.CreateAttr(\"name\", \"Jon\")\n+\n+sally := people.CreateElement(\"Person\")\n+sally.CreateAttr(\"name\", \"Sally\")\n+\n+doc.Indent(2)\n+doc.WriteTo(os.Stdout)\n+```\n+\n+Output:\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<?xml-stylesheet type=\"text/xsl\" href=\"style.xsl\"?>\n+<People>\n+  <!--These are all known people-->\n+  <Person name=\"Jon\"/>\n+  <Person name=\"Sally\"/>\n+</People>\n+```\n+\n+### Reading an XML file\n+\n+Suppose you have a file on disk called `bookstore.xml` containing the\n+following data:\n+\n+```xml\n+<bookstore xmlns:p=\"urn:schemas-books-com:prices\">\n+\n+  <book category=\"COOKING\">\n+    <title lang=\"en\">Everyday Italian</title>\n+    <author>Giada De Laurentiis</author>\n+    <year>2005</year>\n+    <p:price>30.00</p:price>\n+  </book>\n+\n+  <book category=\"CHILDREN\">\n+    <title lang=\"en\">Harry Potter</title>\n+    <author>J K. Rowling</author>\n+    <year>2005</year>\n+    <p:price>29.99</p:price>\n+  </book>\n+\n+  <book category=\"WEB\">\n+    <title lang=\"en\">XQuery Kick Start</title>\n+    <author>James McGovern</author>\n+    <author>Per Bothner</author>\n+    <author>Kurt Cagle</author>\n+    <author>James Linn</author>\n+    <author>Vaidyanathan Nagarajan</author>\n+    <year>2003</year>\n+    <p:price>49.99</p:price>\n+  </book>\n+\n+  <book category=\"WEB\">\n+    <title lang=\"en\">Learning XML</title>\n+    <author>Erik T. Ray</author>\n+    <year>2003</year>\n+    <p:price>39.95</p:price>\n+  </book>\n+\n+</bookstore>\n+```\n+\n+This code reads the file's contents into an etree document.\n+```go\n+doc := etree.NewDocument()\n+if err := doc.ReadFromFile(\"bookstore.xml\"); err != nil {\n+    panic(err)\n+}\n+```\n+\n+You can also read XML from a string, a byte slice, or an `io.Reader`.\n+\n+### Processing elements and attributes\n+\n+This example illustrates several ways to access elements and attributes using\n+etree selection queries.\n+```go\n+root := doc.SelectElement(\"bookstore\")\n+fmt.Println(\"ROOT element:\", root.Tag)\n+\n+for _, book := range root.SelectElements(\"book\") {\n+    fmt.Println(\"CHILD element:\", book.Tag)\n+    if title := book.SelectElement(\"title\"); title != nil {\n+        lang := title.SelectAttrValue(\"lang\", \"unknown\")\n+        fmt.Printf(\"  TITLE: %s (%s)\\n\", title.Text(), lang)\n+    }\n+    for _, attr := range book.Attr {\n+        fmt.Printf(\"  ATTR: %s=%s\\n\", attr.Key, attr.Value)\n+    }\n+}\n+```\n+Output:\n+```\n+ROOT element: bookstore\n+CHILD element: book\n+  TITLE: Everyday Italian (en)\n+  ATTR: category=COOKING\n+CHILD element: book\n+  TITLE: Harry Potter (en)\n+  ATTR: category=CHILDREN\n+CHILD element: book\n+  TITLE: XQuery Kick Start (en)\n+  ATTR: category=WEB\n+CHILD element: book\n+  TITLE: Learning XML (en)\n+  ATTR: category=WEB\n+```\n+\n+### Path queries\n+\n+This example uses etree's path functions to select all book titles that fall\n+into the category of 'WEB'.  The double-slash prefix in the path causes the\n+search for book elements to occur recursively; book elements may appear at any\n+level of the XML hierarchy.\n+```go\n+for _, t := range doc.FindElements(\"//book[@category='WEB']/title\") {\n+    fmt.Println(\"Title:\", t.Text())\n+}\n+```\n+\n+Output:\n+```\n+Title: XQuery Kick Start\n+Title: Learning XML\n+```\n+\n+This example finds the first book element under the root bookstore element and\n+outputs the tag and text of each of its child elements.\n+```go\n+for _, e := range doc.FindElements(\"./bookstore/book[1]/*\") {\n+    fmt.Printf(\"%s: %s\\n\", e.Tag, e.Text())\n+}\n+```\n+\n+Output:\n+```\n+title: Everyday Italian\n+author: Giada De Laurentiis\n+year: 2005\n+price: 30.00\n+```\n+\n+This example finds all books with a price of 49.99 and outputs their titles.\n+```go\n+path := etree.MustCompilePath(\"./bookstore/book[p:price='49.99']/title\")\n+for _, e := range doc.FindElementsPath(path) {\n+    fmt.Println(e.Text())\n+}\n+```\n+\n+Output:\n+```\n+XQuery Kick Start\n+```\n+\n+Note that this example uses the FindElementsPath function, which takes as an\n+argument a pre-compiled path object. Use precompiled paths when you plan to\n+search with the same path more than once.\n+\n+### Other features\n+\n+These are just a few examples of the things the etree package can do. See the\n+[documentation](http://godoc.org/github.com/beevik/etree) for a complete\n+description of its capabilities.\n+\n+### Contributing\n+\n+This project accepts contributions. Just fork the repo and submit a pull\n+request!"
        },
        {
          "filename": "vendor/github.com/beevik/etree/RELEASE_NOTES.md",
          "status": "added",
          "additions": 109,
          "deletions": 0,
          "patch": "@@ -0,0 +1,109 @@\n+Release v1.1.0\n+==============\n+\n+**New Features**\n+\n+* New attribute helpers.\n+  * Added the `Element.SortAttrs` method, which lexicographically sorts an\n+    element's attributes by key.\n+* New `ReadSettings` properties.\n+  * Added `Entity` for the support of custom entity maps.\n+* New `WriteSettings` properties.\n+  * Added `UseCRLF` to allow the output of CR-LF newlines instead of the\n+    default LF newlines. This is useful on Windows systems.\n+* Additional support for text and CDATA sections.\n+  * The `Element.Text` method now returns the concatenation of all consecutive\n+    character data tokens immediately following an element's opening tag.\n+  * Added `Element.SetCData` to replace the character data immediately\n+    following an element's opening tag with a CDATA section.\n+  * Added `Element.CreateCData` to create and add a CDATA section child\n+    `CharData` token to an element.\n+  * Added `Element.CreateText` to create and add a child text `CharData` token\n+    to an element.\n+  * Added `NewCData` to create a parentless CDATA section `CharData` token.\n+  * Added `NewText` to create a parentless text `CharData`\n+    token.\n+  * Added `CharData.IsCData` to detect if the token contains a CDATA section.\n+  * Added `CharData.IsWhitespace` to detect if the token contains whitespace\n+    inserted by one of the document Indent functions.\n+  * Modified `Element.SetText` so that it replaces a run of consecutive\n+    character data tokens following the element's opening tag (instead of just\n+    the first one).\n+* New \"tail text\" support.\n+  * Added the `Element.Tail` method, which returns the text immediately\n+    following an element's closing tag.\n+  * Added the `Element.SetTail` method, which modifies the text immediately\n+    following an element's closing tag.\n+* New element child insertion and removal methods.\n+  * Added the `Element.InsertChildAt` method, which inserts a new child token\n+    before the specified child token index.\n+  * Added the `Element.RemoveChildAt` method, which removes the child token at\n+    the specified child token index.\n+* New element and attribute queries.\n+  * Added the `Element.Index` method, which returns the element's index within\n+    its parent element's child token list.\n+  * Added the `Element.NamespaceURI` method to return the namespace URI\n+    associated with an element.\n+  * Added the `Attr.NamespaceURI` method to return the namespace URI\n+    associated with an element.\n+  * Added the `Attr.Element` method to return the element that an attribute\n+    belongs to.\n+* New Path filter functions.\n+  * Added `[local-name()='val']` to keep elements whose unprefixed tag matches\n+    the desired value.\n+  * Added `[name()='val']` to keep elements whose full tag matches the desired\n+    value.\n+  * Added `[namespace-prefix()='val']` to keep elements whose namespace prefix\n+    matches the desired value.\n+  * Added `[namespace-uri()='val']` to keep elements whose namespace URI\n+    matches the desired value.\n+\n+**Bug Fixes**\n+\n+* A default XML `CharSetReader` is now used to prevent failed parsing of XML\n+  documents using certain encodings.\n+  ([Issue](https://github.com/beevik/etree/issues/53)).\n+* All characters are now properly escaped according to XML parsing rules.\n+  ([Issue](https://github.com/beevik/etree/issues/55)).\n+* The `Document.Indent` and `Document.IndentTabs` functions no longer insert\n+  empty string `CharData` tokens.\n+\n+**Deprecated**\n+\n+* `Element`\n+    * The `InsertChild` method is deprecated. Use `InsertChildAt` instead.\n+    * The `CreateCharData` method is deprecated. Use `CreateText` instead.\n+* `CharData`\n+    * The `NewCharData` method is deprecated. Use `NewText` instead.\n+\n+\n+Release v1.0.1\n+==============\n+\n+**Changes**\n+\n+* Added support for absolute etree Path queries. An absolute path begins with\n+  `/` or `//` and begins its search from the element's document root.\n+* Added [`GetPath`](https://godoc.org/github.com/beevik/etree#Element.GetPath)\n+  and [`GetRelativePath`](https://godoc.org/github.com/beevik/etree#Element.GetRelativePath)\n+  functions to the [`Element`](https://godoc.org/github.com/beevik/etree#Element)\n+  type.\n+\n+**Breaking changes**\n+\n+* A path starting with `//` is now interpreted as an absolute path.\n+  Previously, it was interpreted as a relative path starting from the element\n+  whose\n+  [`FindElement`](https://godoc.org/github.com/beevik/etree#Element.FindElement)\n+  method was called.  To remain compatible with this release, all paths\n+  prefixed with `//` should be prefixed with `.//` when called from any\n+  element other than the document's root.\n+* [**edit 2/1/2019**]: Minor releases should not contain breaking changes.\n+  Even though this breaking change was very minor, it was a mistake to include\n+  it in this minor release. In the future, all breaking changes will be\n+  limited to major releases (e.g., version 2.0.0).\n+\n+Release v1.0.0\n+==============\n+\n+Initial release."
        },
        {
          "filename": "vendor/github.com/beevik/etree/etree.go",
          "status": "added",
          "additions": 1511,
          "deletions": 0,
          "patch": "@@ -0,0 +1,1511 @@\n+// Copyright 2015-2019 Brett Vickers.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package etree provides XML services through an Element Tree\n+// abstraction.\n+package etree\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"encoding/xml\"\n+\t\"errors\"\n+\t\"io\"\n+\t\"os\"\n+\t\"sort\"\n+\t\"strings\"\n+)\n+\n+const (\n+\t// NoIndent is used with the Document Indent function to disable all\n+\t// indenting.\n+\tNoIndent = -1\n+)\n+\n+// ErrXML is returned when XML parsing fails due to incorrect formatting.\n+var ErrXML = errors.New(\"etree: invalid XML format\")\n+\n+// ReadSettings determine the default behavior of the Document's ReadFrom*\n+// methods.\n+type ReadSettings struct {\n+\t// CharsetReader to be passed to standard xml.Decoder. Default: nil.\n+\tCharsetReader func(charset string, input io.Reader) (io.Reader, error)\n+\n+\t// Permissive allows input containing common mistakes such as missing tags\n+\t// or attribute values. Default: false.\n+\tPermissive bool\n+\n+\t// Entity to be passed to standard xml.Decoder. Default: nil.\n+\tEntity map[string]string\n+}\n+\n+// newReadSettings creates a default ReadSettings record.\n+func newReadSettings() ReadSettings {\n+\treturn ReadSettings{\n+\t\tCharsetReader: func(label string, input io.Reader) (io.Reader, error) {\n+\t\t\treturn input, nil\n+\t\t},\n+\t\tPermissive: false,\n+\t}\n+}\n+\n+// dup creates a duplicate of the ReadSettings object.\n+func (s *ReadSettings) dup() ReadSettings {\n+\tvar entityCopy map[string]string\n+\tif s.Entity != nil {\n+\t\tentityCopy = make(map[string]string)\n+\t\tfor k, v := range s.Entity {\n+\t\t\tentityCopy[k] = v\n+\t\t}\n+\t}\n+\treturn ReadSettings{\n+\t\tCharsetReader: s.CharsetReader,\n+\t\tPermissive:    s.Permissive,\n+\t\tEntity:        entityCopy,\n+\t}\n+}\n+\n+// WriteSettings determine the behavior of the Document's WriteTo* and\n+// Indent* methods.\n+type WriteSettings struct {\n+\t// CanonicalEndTags forces the production of XML end tags, even for\n+\t// elements that have no child elements. Default: false.\n+\tCanonicalEndTags bool\n+\n+\t// CanonicalText forces the production of XML character references for\n+\t// text data characters &, <, and >. If false, XML character references\n+\t// are also produced for \" and '. Default: false.\n+\tCanonicalText bool\n+\n+\t// CanonicalAttrVal forces the production of XML character references for\n+\t// attribute value characters &, < and \". If false, XML character\n+\t// references are also produced for > and '. Default: false.\n+\tCanonicalAttrVal bool\n+\n+\t// UseCRLF causes the document's indentation methods to use a carriage\n+\t// return followed by a linefeed (\"\\r\\n\") when outputting a newline. If\n+\t// false, only a linefeed is used (\"\\n\"). Default: false.\n+\tUseCRLF bool\n+}\n+\n+// newWriteSettings creates a default WriteSettings record.\n+func newWriteSettings() WriteSettings {\n+\treturn WriteSettings{\n+\t\tCanonicalEndTags: false,\n+\t\tCanonicalText:    false,\n+\t\tCanonicalAttrVal: false,\n+\t\tUseCRLF:          false,\n+\t}\n+}\n+\n+// dup creates a dulicate of the WriteSettings object.\n+func (s *WriteSettings) dup() WriteSettings {\n+\treturn *s\n+}\n+\n+// A Token is an interface type used to represent XML elements, character\n+// data, CDATA sections, XML comments, XML directives, and XML processing\n+// instructions.\n+type Token interface {\n+\tParent() *Element\n+\tIndex() int\n+\tdup(parent *Element) Token\n+\tsetParent(parent *Element)\n+\tsetIndex(index int)\n+\twriteTo(w *bufio.Writer, s *WriteSettings)\n+}\n+\n+// A Document is a container holding a complete XML tree.\n+//\n+// A document has a single embedded element, which contains zero or more child\n+// tokens, one of which is usually the root element. The embedded element may\n+// include other children such as processing instruction tokens or character\n+// data tokens. The document's embedded element is never directly serialized;\n+// only its children are.\n+//\n+// A document also contains read and write settings, which influence the way\n+// the document is deserialized, serialized, and indented.\n+type Document struct {\n+\tElement\n+\tReadSettings  ReadSettings\n+\tWriteSettings WriteSettings\n+}\n+\n+// An Element represents an XML element, its attributes, and its child tokens.\n+type Element struct {\n+\tSpace, Tag string   // namespace prefix and tag\n+\tAttr       []Attr   // key-value attribute pairs\n+\tChild      []Token  // child tokens (elements, comments, etc.)\n+\tparent     *Element // parent element\n+\tindex      int      // token index in parent's children\n+}\n+\n+// An Attr represents a key-value attribute within an XML element.\n+type Attr struct {\n+\tSpace, Key string   // The attribute's namespace prefix and key\n+\tValue      string   // The attribute value string\n+\telement    *Element // element containing the attribute\n+}\n+\n+// charDataFlags are used with CharData tokens to store additional settings.\n+type charDataFlags uint8\n+\n+const (\n+\t// The CharData contains only whitespace.\n+\twhitespaceFlag charDataFlags = 1 << iota\n+\n+\t// The CharData contains a CDATA section.\n+\tcdataFlag\n+)\n+\n+// CharData may be used to represent simple text data or a CDATA section\n+// within an XML document. The Data property should never be modified\n+// directly; use the SetData method instead.\n+type CharData struct {\n+\tData   string // the simple text or CDATA section content\n+\tparent *Element\n+\tindex  int\n+\tflags  charDataFlags\n+}\n+\n+// A Comment represents an XML comment.\n+type Comment struct {\n+\tData   string // the comment's text\n+\tparent *Element\n+\tindex  int\n+}\n+\n+// A Directive represents an XML directive.\n+type Directive struct {\n+\tData   string // the directive string\n+\tparent *Element\n+\tindex  int\n+}\n+\n+// A ProcInst represents an XML processing instruction.\n+type ProcInst struct {\n+\tTarget string // the processing instruction target\n+\tInst   string // the processing instruction value\n+\tparent *Element\n+\tindex  int\n+}\n+\n+// NewDocument creates an XML document without a root element.\n+func NewDocument() *Document {\n+\treturn &Document{\n+\t\tElement:       Element{Child: make([]Token, 0)},\n+\t\tReadSettings:  newReadSettings(),\n+\t\tWriteSettings: newWriteSettings(),\n+\t}\n+}\n+\n+// NewDocumentWithRoot creates an XML document and sets the element 'e' as its\n+// root element. If the element 'e' is already part of another document, it is\n+// first removed from its existing document.\n+func NewDocumentWithRoot(e *Element) *Document {\n+\td := NewDocument()\n+\td.SetRoot(e)\n+\treturn d\n+}\n+\n+// Copy returns a recursive, deep copy of the document.\n+func (d *Document) Copy() *Document {\n+\treturn &Document{\n+\t\tElement:       *(d.Element.dup(nil).(*Element)),\n+\t\tReadSettings:  d.ReadSettings.dup(),\n+\t\tWriteSettings: d.WriteSettings.dup(),\n+\t}\n+}\n+\n+// Root returns the root element of the document. It returns nil if there is\n+// no root element.\n+func (d *Document) Root() *Element {\n+\tfor _, t := range d.Child {\n+\t\tif c, ok := t.(*Element); ok {\n+\t\t\treturn c\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// SetRoot replaces the document's root element with the element 'e'. If the\n+// document already has a root element when this function is called, then the\n+// existing root element is unbound from the document. If the element 'e' is\n+// part of another document, then it is unbound from the other document.\n+func (d *Document) SetRoot(e *Element) {\n+\tif e.parent != nil {\n+\t\te.parent.RemoveChild(e)\n+\t}\n+\n+\t// If there is already a root element, replace it.\n+\tp := &d.Element\n+\tfor i, t := range p.Child {\n+\t\tif _, ok := t.(*Element); ok {\n+\t\t\tt.setParent(nil)\n+\t\t\tt.setIndex(-1)\n+\t\t\tp.Child[i] = e\n+\t\t\te.setParent(p)\n+\t\t\te.setIndex(i)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\t// No existing root element, so add it.\n+\tp.addChild(e)\n+}\n+\n+// ReadFrom reads XML from the reader 'r' into this document. The function\n+// returns the number of bytes read and any error encountered.\n+func (d *Document) ReadFrom(r io.Reader) (n int64, err error) {\n+\treturn d.Element.readFrom(r, d.ReadSettings)\n+}\n+\n+// ReadFromFile reads XML from a local file at path 'filepath' into this\n+// document.\n+func (d *Document) ReadFromFile(filepath string) error {\n+\tf, err := os.Open(filepath)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer f.Close()\n+\t_, err = d.ReadFrom(f)\n+\treturn err\n+}\n+\n+// ReadFromBytes reads XML from the byte slice 'b' into the this document.\n+func (d *Document) ReadFromBytes(b []byte) error {\n+\t_, err := d.ReadFrom(bytes.NewReader(b))\n+\treturn err\n+}\n+\n+// ReadFromString reads XML from the string 's' into this document.\n+func (d *Document) ReadFromString(s string) error {\n+\t_, err := d.ReadFrom(strings.NewReader(s))\n+\treturn err\n+}\n+\n+// WriteTo serializes the document out to the writer 'w'. The function returns\n+// the number of bytes written and any error encountered.\n+func (d *Document) WriteTo(w io.Writer) (n int64, err error) {\n+\tcw := newCountWriter(w)\n+\tb := bufio.NewWriter(cw)\n+\tfor _, c := range d.Child {\n+\t\tc.writeTo(b, &d.WriteSettings)\n+\t}\n+\terr, n = b.Flush(), cw.bytes\n+\treturn\n+}\n+\n+// WriteToFile serializes the document out to the file at path 'filepath'.\n+func (d *Document) WriteToFile(filepath string) error {\n+\tf, err := os.Create(filepath)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer f.Close()\n+\t_, err = d.WriteTo(f)\n+\treturn err\n+}\n+\n+// WriteToBytes serializes this document into a slice of bytes.\n+func (d *Document) WriteToBytes() (b []byte, err error) {\n+\tvar buf bytes.Buffer\n+\tif _, err = d.WriteTo(&buf); err != nil {\n+\t\treturn\n+\t}\n+\treturn buf.Bytes(), nil\n+}\n+\n+// WriteToString serializes this document into a string.\n+func (d *Document) WriteToString() (s string, err error) {\n+\tvar b []byte\n+\tif b, err = d.WriteToBytes(); err != nil {\n+\t\treturn\n+\t}\n+\treturn string(b), nil\n+}\n+\n+type indentFunc func(depth int) string\n+\n+// Indent modifies the document's element tree by inserting character data\n+// tokens containing newlines and indentation. The amount of indentation per\n+// depth level is given by the 'spaces' parameter. Pass etree.NoIndent for\n+// 'spaces' if you want no indentation at all.\n+func (d *Document) Indent(spaces int) {\n+\tvar indent indentFunc\n+\tswitch {\n+\tcase spaces < 0:\n+\t\tindent = func(depth int) string { return \"\" }\n+\tcase d.WriteSettings.UseCRLF:\n+\t\tindent = func(depth int) string { return indentCRLF(depth*spaces, indentSpaces) }\n+\tdefault:\n+\t\tindent = func(depth int) string { return indentLF(depth*spaces, indentSpaces) }\n+\t}\n+\td.Element.indent(0, indent)\n+}\n+\n+// IndentTabs modifies the document's element tree by inserting CharData\n+// tokens containing newlines and tabs for indentation.  One tab is used per\n+// indentation level.\n+func (d *Document) IndentTabs() {\n+\tvar indent indentFunc\n+\tswitch d.WriteSettings.UseCRLF {\n+\tcase true:\n+\t\tindent = func(depth int) string { return indentCRLF(depth, indentTabs) }\n+\tdefault:\n+\t\tindent = func(depth int) string { return indentLF(depth, indentTabs) }\n+\t}\n+\td.Element.indent(0, indent)\n+}\n+\n+// NewElement creates an unparented element with the specified tag (i.e.,\n+// name). The tag may include a namespace prefix followed by a colon.\n+func NewElement(tag string) *Element {\n+\tspace, stag := spaceDecompose(tag)\n+\treturn newElement(space, stag, nil)\n+}\n+\n+// newElement is a helper function that creates an element and binds it to\n+// a parent element if possible.\n+func newElement(space, tag string, parent *Element) *Element {\n+\te := &Element{\n+\t\tSpace:  space,\n+\t\tTag:    tag,\n+\t\tAttr:   make([]Attr, 0),\n+\t\tChild:  make([]Token, 0),\n+\t\tparent: parent,\n+\t\tindex:  -1,\n+\t}\n+\tif parent != nil {\n+\t\tparent.addChild(e)\n+\t}\n+\treturn e\n+}\n+\n+// Copy creates a recursive, deep copy of the element and all its attributes\n+// and children. The returned element has no parent but can be parented to a\n+// another element using AddChild, or added to a document with SetRoot or\n+// NewDocumentWithRoot.\n+func (e *Element) Copy() *Element {\n+\treturn e.dup(nil).(*Element)\n+}\n+\n+// FullTag returns the element e's complete tag, including namespace prefix if\n+// present.\n+func (e *Element) FullTag() string {\n+\tif e.Space == \"\" {\n+\t\treturn e.Tag\n+\t}\n+\treturn e.Space + \":\" + e.Tag\n+}\n+\n+// NamespaceURI returns the XML namespace URI associated with the element. If\n+// the element is part of the XML default namespace, NamespaceURI returns the\n+// empty string.\n+func (e *Element) NamespaceURI() string {\n+\tif e.Space == \"\" {\n+\t\treturn e.findDefaultNamespaceURI()\n+\t}\n+\treturn e.findLocalNamespaceURI(e.Space)\n+}\n+\n+// findLocalNamespaceURI finds the namespace URI corresponding to the\n+// requested prefix.\n+func (e *Element) findLocalNamespaceURI(prefix string) string {\n+\tfor _, a := range e.Attr {\n+\t\tif a.Space == \"xmlns\" && a.Key == prefix {\n+\t\t\treturn a.Value\n+\t\t}\n+\t}\n+\n+\tif e.parent == nil {\n+\t\treturn \"\"\n+\t}\n+\n+\treturn e.parent.findLocalNamespaceURI(prefix)\n+}\n+\n+// findDefaultNamespaceURI finds the default namespace URI of the element.\n+func (e *Element) findDefaultNamespaceURI() string {\n+\tfor _, a := range e.Attr {\n+\t\tif a.Space == \"\" && a.Key == \"xmlns\" {\n+\t\t\treturn a.Value\n+\t\t}\n+\t}\n+\n+\tif e.parent == nil {\n+\t\treturn \"\"\n+\t}\n+\n+\treturn e.parent.findDefaultNamespaceURI()\n+}\n+\n+// namespacePrefix returns the namespace prefix associated with the element.\n+func (e *Element) namespacePrefix() string {\n+\treturn e.Space\n+}\n+\n+// name returns the tag associated with the element.\n+func (e *Element) name() string {\n+\treturn e.Tag\n+}\n+\n+// Text returns all character data immediately following the element's opening\n+// tag.\n+func (e *Element) Text() string {\n+\tif len(e.Child) == 0 {\n+\t\treturn \"\"\n+\t}\n+\n+\ttext := \"\"\n+\tfor _, ch := range e.Child {\n+\t\tif cd, ok := ch.(*CharData); ok {\n+\t\t\tif text == \"\" {\n+\t\t\t\ttext = cd.Data\n+\t\t\t} else {\n+\t\t\t\ttext += cd.Data\n+\t\t\t}\n+\t\t} else {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn text\n+}\n+\n+// SetText replaces all character data immediately following an element's\n+// opening tag with the requested string.\n+func (e *Element) SetText(text string) {\n+\te.replaceText(0, text, 0)\n+}\n+\n+// SetCData replaces all character data immediately following an element's\n+// opening tag with a CDATA section.\n+func (e *Element) SetCData(text string) {\n+\te.replaceText(0, text, cdataFlag)\n+}\n+\n+// Tail returns all character data immediately following the element's end\n+// tag.\n+func (e *Element) Tail() string {\n+\tif e.Parent() == nil {\n+\t\treturn \"\"\n+\t}\n+\n+\tp := e.Parent()\n+\ti := e.Index()\n+\n+\ttext := \"\"\n+\tfor _, ch := range p.Child[i+1:] {\n+\t\tif cd, ok := ch.(*CharData); ok {\n+\t\t\tif text == \"\" {\n+\t\t\t\ttext = cd.Data\n+\t\t\t} else {\n+\t\t\t\ttext += cd.Data\n+\t\t\t}\n+\t\t} else {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn text\n+}\n+\n+// SetTail replaces all character data immediately following the element's end\n+// tag with the requested string.\n+func (e *Element) SetTail(text string) {\n+\tif e.Parent() == nil {\n+\t\treturn\n+\t}\n+\n+\tp := e.Parent()\n+\tp.replaceText(e.Index()+1, text, 0)\n+}\n+\n+// replaceText is a helper function that replaces a series of chardata tokens\n+// starting at index i with the requested text.\n+func (e *Element) replaceText(i int, text string, flags charDataFlags) {\n+\tend := e.findTermCharDataIndex(i)\n+\n+\tswitch {\n+\tcase end == i:\n+\t\tif text != \"\" {\n+\t\t\t// insert a new chardata token at index i\n+\t\t\tcd := newCharData(text, flags, nil)\n+\t\t\te.InsertChildAt(i, cd)\n+\t\t}\n+\n+\tcase end == i+1:\n+\t\tif text == \"\" {\n+\t\t\t// remove the chardata token at index i\n+\t\t\te.RemoveChildAt(i)\n+\t\t} else {\n+\t\t\t// replace the first and only character token at index i\n+\t\t\tcd := e.Child[i].(*CharData)\n+\t\t\tcd.Data, cd.flags = text, flags\n+\t\t}\n+\n+\tdefault:\n+\t\tif text == \"\" {\n+\t\t\t// remove all chardata tokens starting from index i\n+\t\t\tcopy(e.Child[i:], e.Child[end:])\n+\t\t\tremoved := end - i\n+\t\t\te.Child = e.Child[:len(e.Child)-removed]\n+\t\t\tfor j := i; j < len(e.Child); j++ {\n+\t\t\t\te.Child[j].setIndex(j)\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// replace the first chardata token at index i and remove all\n+\t\t\t// subsequent chardata tokens\n+\t\t\tcd := e.Child[i].(*CharData)\n+\t\t\tcd.Data, cd.flags = text, flags\n+\t\t\tcopy(e.Child[i+1:], e.Child[end:])\n+\t\t\tremoved := end - (i + 1)\n+\t\t\te.Child = e.Child[:len(e.Child)-removed]\n+\t\t\tfor j := i + 1; j < len(e.Child); j++ {\n+\t\t\t\te.Child[j].setIndex(j)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// findTermCharDataIndex finds the index of the first child token that isn't\n+// a CharData token. It starts from the requested start index.\n+func (e *Element) findTermCharDataIndex(start int) int {\n+\tfor i := start; i < len(e.Child); i++ {\n+\t\tif _, ok := e.Child[i].(*CharData); !ok {\n+\t\t\treturn i\n+\t\t}\n+\t}\n+\treturn len(e.Child)\n+}\n+\n+// CreateElement creates a new element with the specified tag (i.e., name) and\n+// adds it as the last child token of this element. The tag may include a\n+// prefix followed by a colon.\n+func (e *Element) CreateElement(tag string) *Element {\n+\tspace, stag := spaceDecompose(tag)\n+\treturn newElement(space, stag, e)\n+}\n+\n+// AddChild adds the token 't' as the last child of the element. If token 't'\n+// was already the child of another element, it is first removed from its\n+// parent element.\n+func (e *Element) AddChild(t Token) {\n+\tif t.Parent() != nil {\n+\t\tt.Parent().RemoveChild(t)\n+\t}\n+\te.addChild(t)\n+}\n+\n+// InsertChild inserts the token 't' into this element's list of children just\n+// before the element's existing child token 'ex'. If the existing element\n+// 'ex' does not appear in this element's list of child tokens, then 't' is\n+// added to the end of this element's list of child tokens. If token 't' is\n+// already the child of another element, it is first removed from the other\n+// element's list of child tokens.\n+//\n+// Deprecated: InsertChild is deprecated. Use InsertChildAt instead.\n+func (e *Element) InsertChild(ex Token, t Token) {\n+\tif ex == nil || ex.Parent() != e {\n+\t\te.AddChild(t)\n+\t\treturn\n+\t}\n+\n+\tif t.Parent() != nil {\n+\t\tt.Parent().RemoveChild(t)\n+\t}\n+\n+\tt.setParent(e)\n+\n+\ti := ex.Index()\n+\te.Child = append(e.Child, nil)\n+\tcopy(e.Child[i+1:], e.Child[i:])\n+\te.Child[i] = t\n+\n+\tfor j := i; j < len(e.Child); j++ {\n+\t\te.Child[j].setIndex(j)\n+\t}\n+}\n+\n+// InsertChildAt inserts the token 't' into this element's list of child\n+// tokens just before the requested 'index'. If the index is greater than or\n+// equal to the length of the list of child tokens, then the token 't' is\n+// added to the end of the list of child tokens.\n+func (e *Element) InsertChildAt(index int, t Token) {\n+\tif index >= len(e.Child) {\n+\t\te.AddChild(t)\n+\t\treturn\n+\t}\n+\n+\tif t.Parent() != nil {\n+\t\tif t.Parent() == e && t.Index() > index {\n+\t\t\tindex--\n+\t\t}\n+\t\tt.Parent().RemoveChild(t)\n+\t}\n+\n+\tt.setParent(e)\n+\n+\te.Child = append(e.Child, nil)\n+\tcopy(e.Child[index+1:], e.Child[index:])\n+\te.Child[index] = t\n+\n+\tfor j := index; j < len(e.Child); j++ {\n+\t\te.Child[j].setIndex(j)\n+\t}\n+}\n+\n+// RemoveChild attempts to remove the token 't' from this element's list of\n+// child tokens. If the token 't' was a child of this element, then it is\n+// removed and returned. Otherwise, nil is returned.\n+func (e *Element) RemoveChild(t Token) Token {\n+\tif t.Parent() != e {\n+\t\treturn nil\n+\t}\n+\treturn e.RemoveChildAt(t.Index())\n+}\n+\n+// RemoveChildAt removes the child token appearing in slot 'index' of this\n+// element's list of child tokens. The removed child token is then returned.\n+// If the index is out of bounds, no child is removed and nil is returned.\n+func (e *Element) RemoveChildAt(index int) Token {\n+\tif index >= len(e.Child) {\n+\t\treturn nil\n+\t}\n+\n+\tt := e.Child[index]\n+\tfor j := index + 1; j < len(e.Child); j++ {\n+\t\te.Child[j].setIndex(j - 1)\n+\t}\n+\te.Child = append(e.Child[:index], e.Child[index+1:]...)\n+\tt.setIndex(-1)\n+\tt.setParent(nil)\n+\treturn t\n+}\n+\n+// ReadFrom reads XML from the reader 'ri' and stores the result as a new\n+// child of this element.\n+func (e *Element) readFrom(ri io.Reader, settings ReadSettings) (n int64, err error) {\n+\tr := newCountReader(ri)\n+\tdec := xml.NewDecoder(r)\n+\tdec.CharsetReader = settings.CharsetReader\n+\tdec.Strict = !settings.Permissive\n+\tdec.Entity = settings.Entity\n+\tvar stack stack\n+\tstack.push(e)\n+\tfor {\n+\t\tt, err := dec.RawToken()\n+\t\tswitch {\n+\t\tcase err == io.EOF:\n+\t\t\tif len(stack.data) != 1 {\n+\t\t\t\treturn r.bytes, ErrXML\n+\t\t\t}\n+\t\t\treturn r.bytes, nil\n+\t\tcase err != nil:\n+\t\t\treturn r.bytes, err\n+\t\tcase stack.empty():\n+\t\t\treturn r.bytes, ErrXML\n+\t\t}\n+\n+\t\ttop := stack.peek().(*Element)\n+\n+\t\tswitch t := t.(type) {\n+\t\tcase xml.StartElement:\n+\t\t\te := newElement(t.Name.Space, t.Name.Local, top)\n+\t\t\tfor _, a := range t.Attr {\n+\t\t\t\te.createAttr(a.Name.Space, a.Name.Local, a.Value, e)\n+\t\t\t}\n+\t\t\tstack.push(e)\n+\t\tcase xml.EndElement:\n+\t\t\tif top.Tag != t.Name.Local || top.Space != t.Name.Space {\n+\t\t\t\treturn r.bytes, ErrXML\n+\t\t\t}\n+\t\t\tstack.pop()\n+\t\tcase xml.CharData:\n+\t\t\tdata := string(t)\n+\t\t\tvar flags charDataFlags\n+\t\t\tif isWhitespace(data) {\n+\t\t\t\tflags = whitespaceFlag\n+\t\t\t}\n+\t\t\tnewCharData(data, flags, top)\n+\t\tcase xml.Comment:\n+\t\t\tnewComment(string(t), top)\n+\t\tcase xml.Directive:\n+\t\t\tnewDirective(string(t), top)\n+\t\tcase xml.ProcInst:\n+\t\t\tnewProcInst(t.Target, string(t.Inst), top)\n+\t\t}\n+\t}\n+}\n+\n+// SelectAttr finds an element attribute matching the requested 'key' and, if\n+// found, returns a pointer to the matching attribute. The function returns\n+// nil if no matching attribute is found. The key may include a namespace\n+// prefix followed by a colon.\n+func (e *Element) SelectAttr(key string) *Attr {\n+\tspace, skey := spaceDecompose(key)\n+\tfor i, a := range e.Attr {\n+\t\tif spaceMatch(space, a.Space) && skey == a.Key {\n+\t\t\treturn &e.Attr[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// SelectAttrValue finds an element attribute matching the requested 'key' and\n+// returns its value if found. If no matching attribute is found, the function\n+// returns the 'dflt' value instead. The key may include a namespace prefix\n+// followed by a colon.\n+func (e *Element) SelectAttrValue(key, dflt string) string {\n+\tspace, skey := spaceDecompose(key)\n+\tfor _, a := range e.Attr {\n+\t\tif spaceMatch(space, a.Space) && skey == a.Key {\n+\t\t\treturn a.Value\n+\t\t}\n+\t}\n+\treturn dflt\n+}\n+\n+// ChildElements returns all elements that are children of this element.\n+func (e *Element) ChildElements() []*Element {\n+\tvar elements []*Element\n+\tfor _, t := range e.Child {\n+\t\tif c, ok := t.(*Element); ok {\n+\t\t\telements = append(elements, c)\n+\t\t}\n+\t}\n+\treturn elements\n+}\n+\n+// SelectElement returns the first child element with the given 'tag' (i.e.,\n+// name). The function returns nil if no child element matching the tag is\n+// found. The tag may include a namespace prefix followed by a colon.\n+func (e *Element) SelectElement(tag string) *Element {\n+\tspace, stag := spaceDecompose(tag)\n+\tfor _, t := range e.Child {\n+\t\tif c, ok := t.(*Element); ok && spaceMatch(space, c.Space) && stag == c.Tag {\n+\t\t\treturn c\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// SelectElements returns a slice of all child elements with the given 'tag'\n+// (i.e., name). The tag may include a namespace prefix followed by a colon.\n+func (e *Element) SelectElements(tag string) []*Element {\n+\tspace, stag := spaceDecompose(tag)\n+\tvar elements []*Element\n+\tfor _, t := range e.Child {\n+\t\tif c, ok := t.(*Element); ok && spaceMatch(space, c.Space) && stag == c.Tag {\n+\t\t\telements = append(elements, c)\n+\t\t}\n+\t}\n+\treturn elements\n+}\n+\n+// FindElement returns the first element matched by the XPath-like 'path'\n+// string. The function returns nil if no child element is found using the\n+// path. It panics if an invalid path string is supplied.\n+func (e *Element) FindElement(path string) *Element {\n+\treturn e.FindElementPath(MustCompilePath(path))\n+}\n+\n+// FindElementPath returns the first element matched by the 'path' object. The\n+// function returns nil if no element is found using the path.\n+func (e *Element) FindElementPath(path Path) *Element {\n+\tp := newPather()\n+\telements := p.traverse(e, path)\n+\tif len(elements) > 0 {\n+\t\treturn elements[0]\n+\t}\n+\treturn nil\n+}\n+\n+// FindElements returns a slice of elements matched by the XPath-like 'path'\n+// string. The function returns nil if no child element is found using the\n+// path. It panics if an invalid path string is supplied.\n+func (e *Element) FindElements(path string) []*Element {\n+\treturn e.FindElementsPath(MustCompilePath(path))\n+}\n+\n+// FindElementsPath returns a slice of elements matched by the 'path' object.\n+func (e *Element) FindElementsPath(path Path) []*Element {\n+\tp := newPather()\n+\treturn p.traverse(e, path)\n+}\n+\n+// GetPath returns the absolute path of the element. The absolute path is the\n+// full path from the document's root.\n+func (e *Element) GetPath() string {\n+\tpath := []string{}\n+\tfor seg := e; seg != nil; seg = seg.Parent() {\n+\t\tif seg.Tag != \"\" {\n+\t\t\tpath = append(path, seg.Tag)\n+\t\t}\n+\t}\n+\n+\t// Reverse the path.\n+\tfor i, j := 0, len(path)-1; i < j; i, j = i+1, j-1 {\n+\t\tpath[i], path[j] = path[j], path[i]\n+\t}\n+\n+\treturn \"/\" + strings.Join(path, \"/\")\n+}\n+\n+// GetRelativePath returns the path of this element relative to the 'source'\n+// element. If the two elements are not part of the same element tree, then\n+// the function returns the empty string.\n+func (e *Element) GetRelativePath(source *Element) string {\n+\tvar path []*Element\n+\n+\tif source == nil {\n+\t\treturn \"\"\n+\t}\n+\n+\t// Build a reverse path from the element toward the root. Stop if the\n+\t// source element is encountered.\n+\tvar seg *Element\n+\tfor seg = e; seg != nil && seg != source; seg = seg.Parent() {\n+\t\tpath = append(path, seg)\n+\t}\n+\n+\t// If we found the source element, reverse the path and compose the\n+\t// string.\n+\tif seg == source {\n+\t\tif len(path) == 0 {\n+\t\t\treturn \".\"\n+\t\t}\n+\t\tparts := []string{}\n+\t\tfor i := len(path) - 1; i >= 0; i-- {\n+\t\t\tparts = append(parts, path[i].Tag)\n+\t\t}\n+\t\treturn \"./\" + strings.Join(parts, \"/\")\n+\t}\n+\n+\t// The source wasn't encountered, so climb from the source element toward\n+\t// the root of the tree until an element in the reversed path is\n+\t// encountered.\n+\n+\tfindPathIndex := func(e *Element, path []*Element) int {\n+\t\tfor i, ee := range path {\n+\t\t\tif e == ee {\n+\t\t\t\treturn i\n+\t\t\t}\n+\t\t}\n+\t\treturn -1\n+\t}\n+\n+\tclimb := 0\n+\tfor seg = source; seg != nil; seg = seg.Parent() {\n+\t\ti := findPathIndex(seg, path)\n+\t\tif i >= 0 {\n+\t\t\tpath = path[:i] // truncate at found segment\n+\t\t\tbreak\n+\t\t}\n+\t\tclimb++\n+\t}\n+\n+\t// No element in the reversed path was encountered, so the two elements\n+\t// must not be part of the same tree.\n+\tif seg == nil {\n+\t\treturn \"\"\n+\t}\n+\n+\t// Reverse the (possibly truncated) path and prepend \"..\" segments to\n+\t// climb.\n+\tparts := []string{}\n+\tfor i := 0; i < climb; i++ {\n+\t\tparts = append(parts, \"..\")\n+\t}\n+\tfor i := len(path) - 1; i >= 0; i-- {\n+\t\tparts = append(parts, path[i].Tag)\n+\t}\n+\treturn strings.Join(parts, \"/\")\n+}\n+\n+// indent recursively inserts proper indentation between an XML element's\n+// child tokens.\n+func (e *Element) indent(depth int, indent indentFunc) {\n+\te.stripIndent()\n+\tn := len(e.Child)\n+\tif n == 0 {\n+\t\treturn\n+\t}\n+\n+\toldChild := e.Child\n+\te.Child = make([]Token, 0, n*2+1)\n+\tisCharData, firstNonCharData := false, true\n+\tfor _, c := range oldChild {\n+\t\t// Insert NL+indent before child if it's not character data.\n+\t\t// Exceptions: when it's the first non-character-data child, or when\n+\t\t// the child is at root depth.\n+\t\t_, isCharData = c.(*CharData)\n+\t\tif !isCharData {\n+\t\t\tif !firstNonCharData || depth > 0 {\n+\t\t\t\ts := indent(depth)\n+\t\t\t\tif s != \"\" {\n+\t\t\t\t\tnewCharData(s, whitespaceFlag, e)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfirstNonCharData = false\n+\t\t}\n+\n+\t\te.addChild(c)\n+\n+\t\t// Recursively process child elements.\n+\t\tif ce, ok := c.(*Element); ok {\n+\t\t\tce.indent(depth+1, indent)\n+\t\t}\n+\t}\n+\n+\t// Insert NL+indent before the last child.\n+\tif !isCharData {\n+\t\tif !firstNonCharData || depth > 0 {\n+\t\t\ts := indent(depth - 1)\n+\t\t\tif s != \"\" {\n+\t\t\t\tnewCharData(s, whitespaceFlag, e)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// stripIndent removes any previously inserted indentation.\n+func (e *Element) stripIndent() {\n+\t// Count the number of non-indent child tokens\n+\tn := len(e.Child)\n+\tfor _, c := range e.Child {\n+\t\tif cd, ok := c.(*CharData); ok && cd.IsWhitespace() {\n+\t\t\tn--\n+\t\t}\n+\t}\n+\tif n == len(e.Child) {\n+\t\treturn\n+\t}\n+\n+\t// Strip out indent CharData\n+\tnewChild := make([]Token, n)\n+\tj := 0\n+\tfor _, c := range e.Child {\n+\t\tif cd, ok := c.(*CharData); ok && cd.IsWhitespace() {\n+\t\t\tcontinue\n+\t\t}\n+\t\tnewChild[j] = c\n+\t\tnewChild[j].setIndex(j)\n+\t\tj++\n+\t}\n+\te.Child = newChild\n+}\n+\n+// dup duplicates the element.\n+func (e *Element) dup(parent *Element) Token {\n+\tne := &Element{\n+\t\tSpace:  e.Space,\n+\t\tTag:    e.Tag,\n+\t\tAttr:   make([]Attr, len(e.Attr)),\n+\t\tChild:  make([]Token, len(e.Child)),\n+\t\tparent: parent,\n+\t\tindex:  e.index,\n+\t}\n+\tfor i, t := range e.Child {\n+\t\tne.Child[i] = t.dup(ne)\n+\t}\n+\tcopy(ne.Attr, e.Attr)\n+\treturn ne\n+}\n+\n+// Parent returns this element's parent element. It returns nil if this\n+// element has no parent.\n+func (e *Element) Parent() *Element {\n+\treturn e.parent\n+}\n+\n+// Index returns the index of this element within its parent element's\n+// list of child tokens. If this element has no parent, then the function\n+// returns -1.\n+func (e *Element) Index() int {\n+\treturn e.index\n+}\n+\n+// setParent replaces this element token's parent.\n+func (e *Element) setParent(parent *Element) {\n+\te.parent = parent\n+}\n+\n+// setIndex sets this element token's index within its parent's Child slice.\n+func (e *Element) setIndex(index int) {\n+\te.index = index\n+}\n+\n+// writeTo serializes the element to the writer w.\n+func (e *Element) writeTo(w *bufio.Writer, s *WriteSettings) {\n+\tw.WriteByte('<')\n+\tw.WriteString(e.FullTag())\n+\tfor _, a := range e.Attr {\n+\t\tw.WriteByte(' ')\n+\t\ta.writeTo(w, s)\n+\t}\n+\tif len(e.Child) > 0 {\n+\t\tw.WriteByte('>')\n+\t\tfor _, c := range e.Child {\n+\t\t\tc.writeTo(w, s)\n+\t\t}\n+\t\tw.Write([]byte{'<', '/'})\n+\t\tw.WriteString(e.FullTag())\n+\t\tw.WriteByte('>')\n+\t} else {\n+\t\tif s.CanonicalEndTags {\n+\t\t\tw.Write([]byte{'>', '<', '/'})\n+\t\t\tw.WriteString(e.FullTag())\n+\t\t\tw.WriteByte('>')\n+\t\t} else {\n+\t\t\tw.Write([]byte{'/', '>'})\n+\t\t}\n+\t}\n+}\n+\n+// addChild adds a child token to the element e.\n+func (e *Element) addChild(t Token) {\n+\tt.setParent(e)\n+\tt.setIndex(len(e.Child))\n+\te.Child = append(e.Child, t)\n+}\n+\n+// CreateAttr creates an attribute with the specified 'key' and 'value' and\n+// adds it to this element. If an attribute with same key already exists on\n+// this element, then its value is replaced. The key may include a namespace\n+// prefix followed by a colon.\n+func (e *Element) CreateAttr(key, value string) *Attr {\n+\tspace, skey := spaceDecompose(key)\n+\treturn e.createAttr(space, skey, value, e)\n+}\n+\n+// createAttr is a helper function that creates attributes.\n+func (e *Element) createAttr(space, key, value string, parent *Element) *Attr {\n+\tfor i, a := range e.Attr {\n+\t\tif space == a.Space && key == a.Key {\n+\t\t\te.Attr[i].Value = value\n+\t\t\treturn &e.Attr[i]\n+\t\t}\n+\t}\n+\ta := Attr{\n+\t\tSpace:   space,\n+\t\tKey:     key,\n+\t\tValue:   value,\n+\t\telement: parent,\n+\t}\n+\te.Attr = append(e.Attr, a)\n+\treturn &e.Attr[len(e.Attr)-1]\n+}\n+\n+// RemoveAttr removes the first attribute of this element whose key matches\n+// 'key'. It returns a copy of the removed attribute if a match is found. If\n+// no match is found, it returns nil. The key may include a namespace prefix\n+// followed by a colon.\n+func (e *Element) RemoveAttr(key string) *Attr {\n+\tspace, skey := spaceDecompose(key)\n+\tfor i, a := range e.Attr {\n+\t\tif space == a.Space && skey == a.Key {\n+\t\t\te.Attr = append(e.Attr[0:i], e.Attr[i+1:]...)\n+\t\t\treturn &Attr{\n+\t\t\t\tSpace:   a.Space,\n+\t\t\t\tKey:     a.Key,\n+\t\t\t\tValue:   a.Value,\n+\t\t\t\telement: nil,\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// SortAttrs sorts this element's attributes lexicographically by key.\n+func (e *Element) SortAttrs() {\n+\tsort.Sort(byAttr(e.Attr))\n+}\n+\n+type byAttr []Attr\n+\n+func (a byAttr) Len() int {\n+\treturn len(a)\n+}\n+\n+func (a byAttr) Swap(i, j int) {\n+\ta[i], a[j] = a[j], a[i]\n+}\n+\n+func (a byAttr) Less(i, j int) bool {\n+\tsp := strings.Compare(a[i].Space, a[j].Space)\n+\tif sp == 0 {\n+\t\treturn strings.Compare(a[i].Key, a[j].Key) < 0\n+\t}\n+\treturn sp < 0\n+}\n+\n+// FullKey returns this attribute's complete key, including namespace prefix\n+// if present.\n+func (a *Attr) FullKey() string {\n+\tif a.Space == \"\" {\n+\t\treturn a.Key\n+\t}\n+\treturn a.Space + \":\" + a.Key\n+}\n+\n+// Element returns a pointer to the element containing this attribute.\n+func (a *Attr) Element() *Element {\n+\treturn a.element\n+}\n+\n+// NamespaceURI returns the XML namespace URI associated with this attribute.\n+// The function returns the empty string if the attribute is unprefixed or\n+// if the attribute is part of the XML default namespace.\n+func (a *Attr) NamespaceURI() string {\n+\tif a.Space == \"\" {\n+\t\treturn \"\"\n+\t}\n+\treturn a.element.findLocalNamespaceURI(a.Space)\n+}\n+\n+// writeTo serializes the attribute to the writer.\n+func (a *Attr) writeTo(w *bufio.Writer, s *WriteSettings) {\n+\tw.WriteString(a.FullKey())\n+\tw.WriteString(`=\"`)\n+\tvar m escapeMode\n+\tif s.CanonicalAttrVal {\n+\t\tm = escapeCanonicalAttr\n+\t} else {\n+\t\tm = escapeNormal\n+\t}\n+\tescapeString(w, a.Value, m)\n+\tw.WriteByte('\"')\n+}\n+\n+// NewText creates an unparented CharData token containing simple text data.\n+func NewText(text string) *CharData {\n+\treturn newCharData(text, 0, nil)\n+}\n+\n+// NewCData creates an unparented XML character CDATA section with 'data' as\n+// its content.\n+func NewCData(data string) *CharData {\n+\treturn newCharData(data, cdataFlag, nil)\n+}\n+\n+// NewCharData creates an unparented CharData token containing simple text\n+// data.\n+//\n+// Deprecated: NewCharData is deprecated. Instead, use NewText, which does the\n+// same thing.\n+func NewCharData(data string) *CharData {\n+\treturn newCharData(data, 0, nil)\n+}\n+\n+// newCharData creates a character data token and binds it to a parent\n+// element. If parent is nil, the CharData token remains unbound.\n+func newCharData(data string, flags charDataFlags, parent *Element) *CharData {\n+\tc := &CharData{\n+\t\tData:   data,\n+\t\tparent: nil,\n+\t\tindex:  -1,\n+\t\tflags:  flags,\n+\t}\n+\tif parent != nil {\n+\t\tparent.addChild(c)\n+\t}\n+\treturn c\n+}\n+\n+// CreateText creates a CharData token simple text data and adds it to the\n+// end of this element's list of child tokens.\n+func (e *Element) CreateText(text string) *CharData {\n+\treturn newCharData(text, 0, e)\n+}\n+\n+// CreateCData creates a CharData token containing a CDATA section with 'data'\n+// as its content and adds it to the end of this element's list of child\n+// tokens.\n+func (e *Element) CreateCData(data string) *CharData {\n+\treturn newCharData(data, cdataFlag, e)\n+}\n+\n+// CreateCharData creates a CharData token simple text data and adds it to the\n+// end of this element's list of child tokens.\n+//\n+// Deprecated: CreateCharData is deprecated. Instead, use CreateText, which\n+// does the same thing.\n+func (e *Element) CreateCharData(data string) *CharData {\n+\treturn newCharData(data, 0, e)\n+}\n+\n+// SetData modifies the content of the CharData token. In the case of a\n+// CharData token containing simple text, the simple text is modified. In the\n+// case of a CharData token containing a CDATA section, the CDATA section's\n+// content is modified.\n+func (c *CharData) SetData(text string) {\n+\tc.Data = text\n+\tif isWhitespace(text) {\n+\t\tc.flags |= whitespaceFlag\n+\t} else {\n+\t\tc.flags &= ^whitespaceFlag\n+\t}\n+}\n+\n+// IsCData returns true if this CharData token is contains a CDATA section. It\n+// returns false if the CharData token contains simple text.\n+func (c *CharData) IsCData() bool {\n+\treturn (c.flags & cdataFlag) != 0\n+}\n+\n+// IsWhitespace returns true if this CharData token contains only whitespace.\n+func (c *CharData) IsWhitespace() bool {\n+\treturn (c.flags & whitespaceFlag) != 0\n+}\n+\n+// Parent returns this CharData token's parent element, or nil if it has no\n+// parent.\n+func (c *CharData) Parent() *Element {\n+\treturn c.parent\n+}\n+\n+// Index returns the index of this CharData token within its parent element's\n+// list of child tokens. If this CharData token has no parent, then the\n+// function returns -1.\n+func (c *CharData) Index() int {\n+\treturn c.index\n+}\n+\n+// dup duplicates the character data.\n+func (c *CharData) dup(parent *Element) Token {\n+\treturn &CharData{\n+\t\tData:   c.Data,\n+\t\tflags:  c.flags,\n+\t\tparent: parent,\n+\t\tindex:  c.index,\n+\t}\n+}\n+\n+// setParent replaces the character data token's parent.\n+func (c *CharData) setParent(parent *Element) {\n+\tc.parent = parent\n+}\n+\n+// setIndex sets the CharData token's index within its parent element's Child\n+// slice.\n+func (c *CharData) setIndex(index int) {\n+\tc.index = index\n+}\n+\n+// writeTo serializes character data to the writer.\n+func (c *CharData) writeTo(w *bufio.Writer, s *WriteSettings) {\n+\tif c.IsCData() {\n+\t\tw.WriteString(`<![CDATA[`)\n+\t\tw.WriteString(c.Data)\n+\t\tw.WriteString(`]]>`)\n+\t} else {\n+\t\tvar m escapeMode\n+\t\tif s.CanonicalText {\n+\t\t\tm = escapeCanonicalText\n+\t\t} else {\n+\t\t\tm = escapeNormal\n+\t\t}\n+\t\tescapeString(w, c.Data, m)\n+\t}\n+}\n+\n+// NewComment creates an unparented comment token.\n+func NewComment(comment string) *Comment {\n+\treturn newComment(comment, nil)\n+}\n+\n+// NewComment creates a comment token and sets its parent element to 'parent'.\n+func newComment(comment string, parent *Element) *Comment {\n+\tc := &Comment{\n+\t\tData:   comment,\n+\t\tparent: nil,\n+\t\tindex:  -1,\n+\t}\n+\tif parent != nil {\n+\t\tparent.addChild(c)\n+\t}\n+\treturn c\n+}\n+\n+// CreateComment creates a comment token using the specified 'comment' string\n+// and adds it as the last child token of this element.\n+func (e *Element) CreateComment(comment string) *Comment {\n+\treturn newComment(comment, e)\n+}\n+\n+// dup duplicates the comment.\n+func (c *Comment) dup(parent *Element) Token {\n+\treturn &Comment{\n+\t\tData:   c.Data,\n+\t\tparent: parent,\n+\t\tindex:  c.index,\n+\t}\n+}\n+\n+// Parent returns comment token's parent element, or nil if it has no parent.\n+func (c *Comment) Parent() *Element {\n+\treturn c.parent\n+}\n+\n+// Index returns the index of this Comment token within its parent element's\n+// list of child tokens. If this Comment token has no parent, then the\n+// function returns -1.\n+func (c *Comment) Index() int {\n+\treturn c.index\n+}\n+\n+// setParent replaces the comment token's parent.\n+func (c *Comment) setParent(parent *Element) {\n+\tc.parent = parent\n+}\n+\n+// setIndex sets the Comment token's index within its parent element's Child\n+// slice.\n+func (c *Comment) setIndex(index int) {\n+\tc.index = index\n+}\n+\n+// writeTo serialies the comment to the writer.\n+func (c *Comment) writeTo(w *bufio.Writer, s *WriteSettings) {\n+\tw.WriteString(\"<!--\")\n+\tw.WriteString(c.Data)\n+\tw.WriteString(\"-->\")\n+}\n+\n+// NewDirective creates an unparented XML directive token.\n+func NewDirective(data string) *Directive {\n+\treturn newDirective(data, nil)\n+}\n+\n+// newDirective creates an XML directive and binds it to a parent element. If\n+// parent is nil, the Directive remains unbound.\n+func newDirective(data string, parent *Element) *Directive {\n+\td := &Directive{\n+\t\tData:   data,\n+\t\tparent: nil,\n+\t\tindex:  -1,\n+\t}\n+\tif parent != nil {\n+\t\tparent.addChild(d)\n+\t}\n+\treturn d\n+}\n+\n+// CreateDirective creates an XML directive token with the specified 'data'\n+// value and adds it as the last child token of this element.\n+func (e *Element) CreateDirective(data string) *Directive {\n+\treturn newDirective(data, e)\n+}\n+\n+// dup duplicates the directive.\n+func (d *Directive) dup(parent *Element) Token {\n+\treturn &Directive{\n+\t\tData:   d.Data,\n+\t\tparent: parent,\n+\t\tindex:  d.index,\n+\t}\n+}\n+\n+// Parent returns directive token's parent element, or nil if it has no\n+// parent.\n+func (d *Directive) Parent() *Element {\n+\treturn d.parent\n+}\n+\n+// Index returns the index of this Directive token within its parent element's\n+// list of child tokens. If this Directive token has no parent, then the\n+// function returns -1.\n+func (d *Directive) Index() int {\n+\treturn d.index\n+}\n+\n+// setParent replaces the directive token's parent.\n+func (d *Directive) setParent(parent *Element) {\n+\td.parent = parent\n+}\n+\n+// setIndex sets the Directive token's index within its parent element's Child\n+// slice.\n+func (d *Directive) setIndex(index int) {\n+\td.index = index\n+}\n+\n+// writeTo serializes the XML directive to the writer.\n+func (d *Directive) writeTo(w *bufio.Writer, s *WriteSettings) {\n+\tw.WriteString(\"<!\")\n+\tw.WriteString(d.Data)\n+\tw.WriteString(\">\")\n+}\n+\n+// NewProcInst creates an unparented XML processing instruction.\n+func NewProcInst(target, inst string) *ProcInst {\n+\treturn newProcInst(target, inst, nil)\n+}\n+\n+// newProcInst creates an XML processing instruction and binds it to a parent\n+// element. If parent is nil, the ProcInst remains unbound.\n+func newProcInst(target, inst string, parent *Element) *ProcInst {\n+\tp := &ProcInst{\n+\t\tTarget: target,\n+\t\tInst:   inst,\n+\t\tparent: nil,\n+\t\tindex:  -1,\n+\t}\n+\tif parent != nil {\n+\t\tparent.addChild(p)\n+\t}\n+\treturn p\n+}\n+\n+// CreateProcInst creates an XML processing instruction token with the\n+// sepcified 'target' and instruction 'inst'. It is then added as the last\n+// child token of this element.\n+func (e *Element) CreateProcInst(target, inst string) *ProcInst {\n+\treturn newProcInst(target, inst, e)\n+}\n+\n+// dup duplicates the procinst.\n+func (p *ProcInst) dup(parent *Element) Token {\n+\treturn &ProcInst{\n+\t\tTarget: p.Target,\n+\t\tInst:   p.Inst,\n+\t\tparent: parent,\n+\t\tindex:  p.index,\n+\t}\n+}\n+\n+// Parent returns processing instruction token's parent element, or nil if it\n+// has no parent.\n+func (p *ProcInst) Parent() *Element {\n+\treturn p.parent\n+}\n+\n+// Index returns the index of this ProcInst token within its parent element's\n+// list of child tokens. If this ProcInst token has no parent, then the\n+// function returns -1.\n+func (p *ProcInst) Index() int {\n+\treturn p.index\n+}\n+\n+// setParent replaces the processing instruction token's parent.\n+func (p *ProcInst) setParent(parent *Element) {\n+\tp.parent = parent\n+}\n+\n+// setIndex sets the processing instruction token's index within its parent\n+// element's Child slice.\n+func (p *ProcInst) setIndex(index int) {\n+\tp.index = index\n+}\n+\n+// writeTo serializes the processing instruction to the writer.\n+func (p *ProcInst) writeTo(w *bufio.Writer, s *WriteSettings) {\n+\tw.WriteString(\"<?\")\n+\tw.WriteString(p.Target)\n+\tif p.Inst != \"\" {\n+\t\tw.WriteByte(' ')\n+\t\tw.WriteString(p.Inst)\n+\t}\n+\tw.WriteString(\"?>\")\n+}"
        },
        {
          "filename": "vendor/github.com/beevik/etree/go.mod",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+module github.com/beevik/etree\n+\n+go 1.12"
        },
        {
          "filename": "vendor/github.com/beevik/etree/helpers.go",
          "status": "added",
          "additions": 276,
          "deletions": 0,
          "patch": "@@ -0,0 +1,276 @@\n+// Copyright 2015-2019 Brett Vickers.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package etree\n+\n+import (\n+\t\"bufio\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"unicode/utf8\"\n+)\n+\n+// A simple stack\n+type stack struct {\n+\tdata []interface{}\n+}\n+\n+func (s *stack) empty() bool {\n+\treturn len(s.data) == 0\n+}\n+\n+func (s *stack) push(value interface{}) {\n+\ts.data = append(s.data, value)\n+}\n+\n+func (s *stack) pop() interface{} {\n+\tvalue := s.data[len(s.data)-1]\n+\ts.data[len(s.data)-1] = nil\n+\ts.data = s.data[:len(s.data)-1]\n+\treturn value\n+}\n+\n+func (s *stack) peek() interface{} {\n+\treturn s.data[len(s.data)-1]\n+}\n+\n+// A fifo is a simple first-in-first-out queue.\n+type fifo struct {\n+\tdata       []interface{}\n+\thead, tail int\n+}\n+\n+func (f *fifo) add(value interface{}) {\n+\tif f.len()+1 >= len(f.data) {\n+\t\tf.grow()\n+\t}\n+\tf.data[f.tail] = value\n+\tif f.tail++; f.tail == len(f.data) {\n+\t\tf.tail = 0\n+\t}\n+}\n+\n+func (f *fifo) remove() interface{} {\n+\tvalue := f.data[f.head]\n+\tf.data[f.head] = nil\n+\tif f.head++; f.head == len(f.data) {\n+\t\tf.head = 0\n+\t}\n+\treturn value\n+}\n+\n+func (f *fifo) len() int {\n+\tif f.tail >= f.head {\n+\t\treturn f.tail - f.head\n+\t}\n+\treturn len(f.data) - f.head + f.tail\n+}\n+\n+func (f *fifo) grow() {\n+\tc := len(f.data) * 2\n+\tif c == 0 {\n+\t\tc = 4\n+\t}\n+\tbuf, count := make([]interface{}, c), f.len()\n+\tif f.tail >= f.head {\n+\t\tcopy(buf[0:count], f.data[f.head:f.tail])\n+\t} else {\n+\t\thindex := len(f.data) - f.head\n+\t\tcopy(buf[0:hindex], f.data[f.head:])\n+\t\tcopy(buf[hindex:count], f.data[:f.tail])\n+\t}\n+\tf.data, f.head, f.tail = buf, 0, count\n+}\n+\n+// countReader implements a proxy reader that counts the number of\n+// bytes read from its encapsulated reader.\n+type countReader struct {\n+\tr     io.Reader\n+\tbytes int64\n+}\n+\n+func newCountReader(r io.Reader) *countReader {\n+\treturn &countReader{r: r}\n+}\n+\n+func (cr *countReader) Read(p []byte) (n int, err error) {\n+\tb, err := cr.r.Read(p)\n+\tcr.bytes += int64(b)\n+\treturn b, err\n+}\n+\n+// countWriter implements a proxy writer that counts the number of\n+// bytes written by its encapsulated writer.\n+type countWriter struct {\n+\tw     io.Writer\n+\tbytes int64\n+}\n+\n+func newCountWriter(w io.Writer) *countWriter {\n+\treturn &countWriter{w: w}\n+}\n+\n+func (cw *countWriter) Write(p []byte) (n int, err error) {\n+\tb, err := cw.w.Write(p)\n+\tcw.bytes += int64(b)\n+\treturn b, err\n+}\n+\n+// isWhitespace returns true if the byte slice contains only\n+// whitespace characters.\n+func isWhitespace(s string) bool {\n+\tfor i := 0; i < len(s); i++ {\n+\t\tif c := s[i]; c != ' ' && c != '\\t' && c != '\\n' && c != '\\r' {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+// spaceMatch returns true if namespace a is the empty string\n+// or if namespace a equals namespace b.\n+func spaceMatch(a, b string) bool {\n+\tswitch {\n+\tcase a == \"\":\n+\t\treturn true\n+\tdefault:\n+\t\treturn a == b\n+\t}\n+}\n+\n+// spaceDecompose breaks a namespace:tag identifier at the ':'\n+// and returns the two parts.\n+func spaceDecompose(str string) (space, key string) {\n+\tcolon := strings.IndexByte(str, ':')\n+\tif colon == -1 {\n+\t\treturn \"\", str\n+\t}\n+\treturn str[:colon], str[colon+1:]\n+}\n+\n+// Strings used by indentCRLF and indentLF\n+const (\n+\tindentSpaces = \"\\r\\n                                                                \"\n+\tindentTabs   = \"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"\n+)\n+\n+// indentCRLF returns a CRLF newline followed by n copies of the first\n+// non-CRLF character in the source string.\n+func indentCRLF(n int, source string) string {\n+\tswitch {\n+\tcase n < 0:\n+\t\treturn source[:2]\n+\tcase n < len(source)-1:\n+\t\treturn source[:n+2]\n+\tdefault:\n+\t\treturn source + strings.Repeat(source[2:3], n-len(source)+2)\n+\t}\n+}\n+\n+// indentLF returns a LF newline followed by n copies of the first non-LF\n+// character in the source string.\n+func indentLF(n int, source string) string {\n+\tswitch {\n+\tcase n < 0:\n+\t\treturn source[1:2]\n+\tcase n < len(source)-1:\n+\t\treturn source[1 : n+2]\n+\tdefault:\n+\t\treturn source[1:] + strings.Repeat(source[2:3], n-len(source)+2)\n+\t}\n+}\n+\n+// nextIndex returns the index of the next occurrence of sep in s,\n+// starting from offset.  It returns -1 if the sep string is not found.\n+func nextIndex(s, sep string, offset int) int {\n+\tswitch i := strings.Index(s[offset:], sep); i {\n+\tcase -1:\n+\t\treturn -1\n+\tdefault:\n+\t\treturn offset + i\n+\t}\n+}\n+\n+// isInteger returns true if the string s contains an integer.\n+func isInteger(s string) bool {\n+\tfor i := 0; i < len(s); i++ {\n+\t\tif (s[i] < '0' || s[i] > '9') && !(i == 0 && s[i] == '-') {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+type escapeMode byte\n+\n+const (\n+\tescapeNormal escapeMode = iota\n+\tescapeCanonicalText\n+\tescapeCanonicalAttr\n+)\n+\n+// escapeString writes an escaped version of a string to the writer.\n+func escapeString(w *bufio.Writer, s string, m escapeMode) {\n+\tvar esc []byte\n+\tlast := 0\n+\tfor i := 0; i < len(s); {\n+\t\tr, width := utf8.DecodeRuneInString(s[i:])\n+\t\ti += width\n+\t\tswitch r {\n+\t\tcase '&':\n+\t\t\tesc = []byte(\"&amp;\")\n+\t\tcase '<':\n+\t\t\tesc = []byte(\"&lt;\")\n+\t\tcase '>':\n+\t\t\tif m == escapeCanonicalAttr {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tesc = []byte(\"&gt;\")\n+\t\tcase '\\'':\n+\t\t\tif m != escapeNormal {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tesc = []byte(\"&apos;\")\n+\t\tcase '\"':\n+\t\t\tif m == escapeCanonicalText {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tesc = []byte(\"&quot;\")\n+\t\tcase '\\t':\n+\t\t\tif m != escapeCanonicalAttr {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tesc = []byte(\"&#x9;\")\n+\t\tcase '\\n':\n+\t\t\tif m != escapeCanonicalAttr {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tesc = []byte(\"&#xA;\")\n+\t\tcase '\\r':\n+\t\t\tif m == escapeNormal {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tesc = []byte(\"&#xD;\")\n+\t\tdefault:\n+\t\t\tif !isInCharacterRange(r) || (r == 0xFFFD && width == 1) {\n+\t\t\t\tesc = []byte(\"\\uFFFD\")\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tw.WriteString(s[last : i-width])\n+\t\tw.Write(esc)\n+\t\tlast = i\n+\t}\n+\tw.WriteString(s[last:])\n+}\n+\n+func isInCharacterRange(r rune) bool {\n+\treturn r == 0x09 ||\n+\t\tr == 0x0A ||\n+\t\tr == 0x0D ||\n+\t\tr >= 0x20 && r <= 0xD7FF ||\n+\t\tr >= 0xE000 && r <= 0xFFFD ||\n+\t\tr >= 0x10000 && r <= 0x10FFFF\n+}"
        },
        {
          "filename": "vendor/github.com/beevik/etree/path.go",
          "status": "added",
          "additions": 580,
          "deletions": 0,
          "patch": "@@ -0,0 +1,580 @@\n+// Copyright 2015-2019 Brett Vickers.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package etree\n+\n+import (\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+/*\n+A Path is a string that represents a search path through an etree starting\n+from the document root or an arbitrary element. Paths are used with the\n+Element object's Find* methods to locate and return desired elements.\n+\n+A Path consists of a series of slash-separated \"selectors\", each of which may\n+be modified by one or more bracket-enclosed \"filters\". Selectors are used to\n+traverse the etree from element to element, while filters are used to narrow\n+the list of candidate elements at each node.\n+\n+Although etree Path strings are structurally and behaviorally similar to XPath\n+strings (https://www.w3.org/TR/1999/REC-xpath-19991116/), they have a more\n+limited set of selectors and filtering options.\n+\n+The following selectors are supported by etree paths:\n+\n+    .               Select the current element.\n+    ..              Select the parent of the current element.\n+    *               Select all child elements of the current element.\n+    /               Select the root element when used at the start of a path.\n+    //              Select all descendants of the current element.\n+    tag             Select all child elements with a name matching the tag.\n+\n+The following basic filters are supported:\n+\n+    [@attrib]       Keep elements with an attribute named attrib.\n+    [@attrib='val'] Keep elements with an attribute named attrib and value matching val.\n+    [tag]           Keep elements with a child element named tag.\n+    [tag='val']     Keep elements with a child element named tag and text matching val.\n+    [n]             Keep the n-th element, where n is a numeric index starting from 1.\n+\n+The following function-based filters are supported:\n+\n+    [text()]                    Keep elements with non-empty text.\n+    [text()='val']              Keep elements whose text matches val.\n+    [local-name()='val']        Keep elements whose un-prefixed tag matches val.\n+    [name()='val']              Keep elements whose full tag exactly matches val.\n+    [namespace-prefix()]        Keep elements with non-empty namespace prefixes.\n+    [namespace-prefix()='val']  Keep elements whose namespace prefix matches val.\n+    [namespace-uri()]           Keep elements with non-empty namespace URIs.\n+    [namespace-uri()='val']     Keep elements whose namespace URI matches val.\n+\n+Below are some examples of etree path strings.\n+\n+Select the bookstore child element of the root element:\n+    /bookstore\n+\n+Beginning from the root element, select the title elements of all descendant\n+book elements having a 'category' attribute of 'WEB':\n+    //book[@category='WEB']/title\n+\n+Beginning from the current element, select the first descendant book element\n+with a title child element containing the text 'Great Expectations':\n+    .//book[title='Great Expectations'][1]\n+\n+Beginning from the current element, select all child elements of book elements\n+with an attribute 'language' set to 'english':\n+    ./book/*[@language='english']\n+\n+Beginning from the current element, select all child elements of book elements\n+containing the text 'special':\n+    ./book/*[text()='special']\n+\n+Beginning from the current element, select all descendant book elements whose\n+title child element has a 'language' attribute of 'french':\n+    .//book/title[@language='french']/..\n+\n+Beginning from the current element, select all descendant book elements\n+belonging to the http://www.w3.org/TR/html4/ namespace:\n+    .//book[namespace-uri()='http://www.w3.org/TR/html4/']\n+\n+*/\n+type Path struct {\n+\tsegments []segment\n+}\n+\n+// ErrPath is returned by path functions when an invalid etree path is provided.\n+type ErrPath string\n+\n+// Error returns the string describing a path error.\n+func (err ErrPath) Error() string {\n+\treturn \"etree: \" + string(err)\n+}\n+\n+// CompilePath creates an optimized version of an XPath-like string that\n+// can be used to query elements in an element tree.\n+func CompilePath(path string) (Path, error) {\n+\tvar comp compiler\n+\tsegments := comp.parsePath(path)\n+\tif comp.err != ErrPath(\"\") {\n+\t\treturn Path{nil}, comp.err\n+\t}\n+\treturn Path{segments}, nil\n+}\n+\n+// MustCompilePath creates an optimized version of an XPath-like string that\n+// can be used to query elements in an element tree.  Panics if an error\n+// occurs.  Use this function to create Paths when you know the path is\n+// valid (i.e., if it's hard-coded).\n+func MustCompilePath(path string) Path {\n+\tp, err := CompilePath(path)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\treturn p\n+}\n+\n+// A segment is a portion of a path between \"/\" characters.\n+// It contains one selector and zero or more [filters].\n+type segment struct {\n+\tsel     selector\n+\tfilters []filter\n+}\n+\n+func (seg *segment) apply(e *Element, p *pather) {\n+\tseg.sel.apply(e, p)\n+\tfor _, f := range seg.filters {\n+\t\tf.apply(p)\n+\t}\n+}\n+\n+// A selector selects XML elements for consideration by the\n+// path traversal.\n+type selector interface {\n+\tapply(e *Element, p *pather)\n+}\n+\n+// A filter pares down a list of candidate XML elements based\n+// on a path filter in [brackets].\n+type filter interface {\n+\tapply(p *pather)\n+}\n+\n+// A pather is helper object that traverses an element tree using\n+// a Path object.  It collects and deduplicates all elements matching\n+// the path query.\n+type pather struct {\n+\tqueue      fifo\n+\tresults    []*Element\n+\tinResults  map[*Element]bool\n+\tcandidates []*Element\n+\tscratch    []*Element // used by filters\n+}\n+\n+// A node represents an element and the remaining path segments that\n+// should be applied against it by the pather.\n+type node struct {\n+\te        *Element\n+\tsegments []segment\n+}\n+\n+func newPather() *pather {\n+\treturn &pather{\n+\t\tresults:    make([]*Element, 0),\n+\t\tinResults:  make(map[*Element]bool),\n+\t\tcandidates: make([]*Element, 0),\n+\t\tscratch:    make([]*Element, 0),\n+\t}\n+}\n+\n+// traverse follows the path from the element e, collecting\n+// and then returning all elements that match the path's selectors\n+// and filters.\n+func (p *pather) traverse(e *Element, path Path) []*Element {\n+\tfor p.queue.add(node{e, path.segments}); p.queue.len() > 0; {\n+\t\tp.eval(p.queue.remove().(node))\n+\t}\n+\treturn p.results\n+}\n+\n+// eval evalutes the current path node by applying the remaining\n+// path's selector rules against the node's element.\n+func (p *pather) eval(n node) {\n+\tp.candidates = p.candidates[0:0]\n+\tseg, remain := n.segments[0], n.segments[1:]\n+\tseg.apply(n.e, p)\n+\n+\tif len(remain) == 0 {\n+\t\tfor _, c := range p.candidates {\n+\t\t\tif in := p.inResults[c]; !in {\n+\t\t\t\tp.inResults[c] = true\n+\t\t\t\tp.results = append(p.results, c)\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\tfor _, c := range p.candidates {\n+\t\t\tp.queue.add(node{c, remain})\n+\t\t}\n+\t}\n+}\n+\n+// A compiler generates a compiled path from a path string.\n+type compiler struct {\n+\terr ErrPath\n+}\n+\n+// parsePath parses an XPath-like string describing a path\n+// through an element tree and returns a slice of segment\n+// descriptors.\n+func (c *compiler) parsePath(path string) []segment {\n+\t// If path ends with //, fix it\n+\tif strings.HasSuffix(path, \"//\") {\n+\t\tpath += \"*\"\n+\t}\n+\n+\tvar segments []segment\n+\n+\t// Check for an absolute path\n+\tif strings.HasPrefix(path, \"/\") {\n+\t\tsegments = append(segments, segment{new(selectRoot), []filter{}})\n+\t\tpath = path[1:]\n+\t}\n+\n+\t// Split path into segments\n+\tfor _, s := range splitPath(path) {\n+\t\tsegments = append(segments, c.parseSegment(s))\n+\t\tif c.err != ErrPath(\"\") {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn segments\n+}\n+\n+func splitPath(path string) []string {\n+\tvar pieces []string\n+\tstart := 0\n+\tinquote := false\n+\tfor i := 0; i+1 <= len(path); i++ {\n+\t\tif path[i] == '\\'' {\n+\t\t\tinquote = !inquote\n+\t\t} else if path[i] == '/' && !inquote {\n+\t\t\tpieces = append(pieces, path[start:i])\n+\t\t\tstart = i + 1\n+\t\t}\n+\t}\n+\treturn append(pieces, path[start:])\n+}\n+\n+// parseSegment parses a path segment between / characters.\n+func (c *compiler) parseSegment(path string) segment {\n+\tpieces := strings.Split(path, \"[\")\n+\tseg := segment{\n+\t\tsel:     c.parseSelector(pieces[0]),\n+\t\tfilters: []filter{},\n+\t}\n+\tfor i := 1; i < len(pieces); i++ {\n+\t\tfpath := pieces[i]\n+\t\tif fpath[len(fpath)-1] != ']' {\n+\t\t\tc.err = ErrPath(\"path has invalid filter [brackets].\")\n+\t\t\tbreak\n+\t\t}\n+\t\tseg.filters = append(seg.filters, c.parseFilter(fpath[:len(fpath)-1]))\n+\t}\n+\treturn seg\n+}\n+\n+// parseSelector parses a selector at the start of a path segment.\n+func (c *compiler) parseSelector(path string) selector {\n+\tswitch path {\n+\tcase \".\":\n+\t\treturn new(selectSelf)\n+\tcase \"..\":\n+\t\treturn new(selectParent)\n+\tcase \"*\":\n+\t\treturn new(selectChildren)\n+\tcase \"\":\n+\t\treturn new(selectDescendants)\n+\tdefault:\n+\t\treturn newSelectChildrenByTag(path)\n+\t}\n+}\n+\n+var fnTable = map[string]func(e *Element) string{\n+\t\"local-name\":       (*Element).name,\n+\t\"name\":             (*Element).FullTag,\n+\t\"namespace-prefix\": (*Element).namespacePrefix,\n+\t\"namespace-uri\":    (*Element).NamespaceURI,\n+\t\"text\":             (*Element).Text,\n+}\n+\n+// parseFilter parses a path filter contained within [brackets].\n+func (c *compiler) parseFilter(path string) filter {\n+\tif len(path) == 0 {\n+\t\tc.err = ErrPath(\"path contains an empty filter expression.\")\n+\t\treturn nil\n+\t}\n+\n+\t// Filter contains [@attr='val'], [fn()='val'], or [tag='val']?\n+\teqindex := strings.Index(path, \"='\")\n+\tif eqindex >= 0 {\n+\t\trindex := nextIndex(path, \"'\", eqindex+2)\n+\t\tif rindex != len(path)-1 {\n+\t\t\tc.err = ErrPath(\"path has mismatched filter quotes.\")\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tkey := path[:eqindex]\n+\t\tvalue := path[eqindex+2 : rindex]\n+\n+\t\tswitch {\n+\t\tcase key[0] == '@':\n+\t\t\treturn newFilterAttrVal(key[1:], value)\n+\t\tcase strings.HasSuffix(key, \"()\"):\n+\t\t\tname := key[:len(key)-2]\n+\t\t\tif fn, ok := fnTable[name]; ok {\n+\t\t\t\treturn newFilterFuncVal(fn, value)\n+\t\t\t}\n+\t\t\tc.err = ErrPath(\"path has unknown function \" + name)\n+\t\t\treturn nil\n+\t\tdefault:\n+\t\t\treturn newFilterChildText(key, value)\n+\t\t}\n+\t}\n+\n+\t// Filter contains [@attr], [N], [tag] or [fn()]\n+\tswitch {\n+\tcase path[0] == '@':\n+\t\treturn newFilterAttr(path[1:])\n+\tcase strings.HasSuffix(path, \"()\"):\n+\t\tname := path[:len(path)-2]\n+\t\tif fn, ok := fnTable[name]; ok {\n+\t\t\treturn newFilterFunc(fn)\n+\t\t}\n+\t\tc.err = ErrPath(\"path has unknown function \" + name)\n+\t\treturn nil\n+\tcase isInteger(path):\n+\t\tpos, _ := strconv.Atoi(path)\n+\t\tswitch {\n+\t\tcase pos > 0:\n+\t\t\treturn newFilterPos(pos - 1)\n+\t\tdefault:\n+\t\t\treturn newFilterPos(pos)\n+\t\t}\n+\tdefault:\n+\t\treturn newFilterChild(path)\n+\t}\n+}\n+\n+// selectSelf selects the current element into the candidate list.\n+type selectSelf struct{}\n+\n+func (s *selectSelf) apply(e *Element, p *pather) {\n+\tp.candidates = append(p.candidates, e)\n+}\n+\n+// selectRoot selects the element's root node.\n+type selectRoot struct{}\n+\n+func (s *selectRoot) apply(e *Element, p *pather) {\n+\troot := e\n+\tfor root.parent != nil {\n+\t\troot = root.parent\n+\t}\n+\tp.candidates = append(p.candidates, root)\n+}\n+\n+// selectParent selects the element's parent into the candidate list.\n+type selectParent struct{}\n+\n+func (s *selectParent) apply(e *Element, p *pather) {\n+\tif e.parent != nil {\n+\t\tp.candidates = append(p.candidates, e.parent)\n+\t}\n+}\n+\n+// selectChildren selects the element's child elements into the\n+// candidate list.\n+type selectChildren struct{}\n+\n+func (s *selectChildren) apply(e *Element, p *pather) {\n+\tfor _, c := range e.Child {\n+\t\tif c, ok := c.(*Element); ok {\n+\t\t\tp.candidates = append(p.candidates, c)\n+\t\t}\n+\t}\n+}\n+\n+// selectDescendants selects all descendant child elements\n+// of the element into the candidate list.\n+type selectDescendants struct{}\n+\n+func (s *selectDescendants) apply(e *Element, p *pather) {\n+\tvar queue fifo\n+\tfor queue.add(e); queue.len() > 0; {\n+\t\te := queue.remove().(*Element)\n+\t\tp.candidates = append(p.candidates, e)\n+\t\tfor _, c := range e.Child {\n+\t\t\tif c, ok := c.(*Element); ok {\n+\t\t\t\tqueue.add(c)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// selectChildrenByTag selects into the candidate list all child\n+// elements of the element having the specified tag.\n+type selectChildrenByTag struct {\n+\tspace, tag string\n+}\n+\n+func newSelectChildrenByTag(path string) *selectChildrenByTag {\n+\ts, l := spaceDecompose(path)\n+\treturn &selectChildrenByTag{s, l}\n+}\n+\n+func (s *selectChildrenByTag) apply(e *Element, p *pather) {\n+\tfor _, c := range e.Child {\n+\t\tif c, ok := c.(*Element); ok && spaceMatch(s.space, c.Space) && s.tag == c.Tag {\n+\t\t\tp.candidates = append(p.candidates, c)\n+\t\t}\n+\t}\n+}\n+\n+// filterPos filters the candidate list, keeping only the\n+// candidate at the specified index.\n+type filterPos struct {\n+\tindex int\n+}\n+\n+func newFilterPos(pos int) *filterPos {\n+\treturn &filterPos{pos}\n+}\n+\n+func (f *filterPos) apply(p *pather) {\n+\tif f.index >= 0 {\n+\t\tif f.index < len(p.candidates) {\n+\t\t\tp.scratch = append(p.scratch, p.candidates[f.index])\n+\t\t}\n+\t} else {\n+\t\tif -f.index <= len(p.candidates) {\n+\t\t\tp.scratch = append(p.scratch, p.candidates[len(p.candidates)+f.index])\n+\t\t}\n+\t}\n+\tp.candidates, p.scratch = p.scratch, p.candidates[0:0]\n+}\n+\n+// filterAttr filters the candidate list for elements having\n+// the specified attribute.\n+type filterAttr struct {\n+\tspace, key string\n+}\n+\n+func newFilterAttr(str string) *filterAttr {\n+\ts, l := spaceDecompose(str)\n+\treturn &filterAttr{s, l}\n+}\n+\n+func (f *filterAttr) apply(p *pather) {\n+\tfor _, c := range p.candidates {\n+\t\tfor _, a := range c.Attr {\n+\t\t\tif spaceMatch(f.space, a.Space) && f.key == a.Key {\n+\t\t\t\tp.scratch = append(p.scratch, c)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\tp.candidates, p.scratch = p.scratch, p.candidates[0:0]\n+}\n+\n+// filterAttrVal filters the candidate list for elements having\n+// the specified attribute with the specified value.\n+type filterAttrVal struct {\n+\tspace, key, val string\n+}\n+\n+func newFilterAttrVal(str, value string) *filterAttrVal {\n+\ts, l := spaceDecompose(str)\n+\treturn &filterAttrVal{s, l, value}\n+}\n+\n+func (f *filterAttrVal) apply(p *pather) {\n+\tfor _, c := range p.candidates {\n+\t\tfor _, a := range c.Attr {\n+\t\t\tif spaceMatch(f.space, a.Space) && f.key == a.Key && f.val == a.Value {\n+\t\t\t\tp.scratch = append(p.scratch, c)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\tp.candidates, p.scratch = p.scratch, p.candidates[0:0]\n+}\n+\n+// filterFunc filters the candidate list for elements satisfying a custom\n+// boolean function.\n+type filterFunc struct {\n+\tfn func(e *Element) string\n+}\n+\n+func newFilterFunc(fn func(e *Element) string) *filterFunc {\n+\treturn &filterFunc{fn}\n+}\n+\n+func (f *filterFunc) apply(p *pather) {\n+\tfor _, c := range p.candidates {\n+\t\tif f.fn(c) != \"\" {\n+\t\t\tp.scratch = append(p.scratch, c)\n+\t\t}\n+\t}\n+\tp.candidates, p.scratch = p.scratch, p.candidates[0:0]\n+}\n+\n+// filterFuncVal filters the candidate list for elements containing a value\n+// matching the result of a custom function.\n+type filterFuncVal struct {\n+\tfn  func(e *Element) string\n+\tval string\n+}\n+\n+func newFilterFuncVal(fn func(e *Element) string, value string) *filterFuncVal {\n+\treturn &filterFuncVal{fn, value}\n+}\n+\n+func (f *filterFuncVal) apply(p *pather) {\n+\tfor _, c := range p.candidates {\n+\t\tif f.fn(c) == f.val {\n+\t\t\tp.scratch = append(p.scratch, c)\n+\t\t}\n+\t}\n+\tp.candidates, p.scratch = p.scratch, p.candidates[0:0]\n+}\n+\n+// filterChild filters the candidate list for elements having\n+// a child element with the specified tag.\n+type filterChild struct {\n+\tspace, tag string\n+}\n+\n+func newFilterChild(str string) *filterChild {\n+\ts, l := spaceDecompose(str)\n+\treturn &filterChild{s, l}\n+}\n+\n+func (f *filterChild) apply(p *pather) {\n+\tfor _, c := range p.candidates {\n+\t\tfor _, cc := range c.Child {\n+\t\t\tif cc, ok := cc.(*Element); ok &&\n+\t\t\t\tspaceMatch(f.space, cc.Space) &&\n+\t\t\t\tf.tag == cc.Tag {\n+\t\t\t\tp.scratch = append(p.scratch, c)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tp.candidates, p.scratch = p.scratch, p.candidates[0:0]\n+}\n+\n+// filterChildText filters the candidate list for elements having\n+// a child element with the specified tag and text.\n+type filterChildText struct {\n+\tspace, tag, text string\n+}\n+\n+func newFilterChildText(str, text string) *filterChildText {\n+\ts, l := spaceDecompose(str)\n+\treturn &filterChildText{s, l, text}\n+}\n+\n+func (f *filterChildText) apply(p *pather) {\n+\tfor _, c := range p.candidates {\n+\t\tfor _, cc := range c.Child {\n+\t\t\tif cc, ok := cc.(*Element); ok &&\n+\t\t\t\tspaceMatch(f.space, cc.Space) &&\n+\t\t\t\tf.tag == cc.Tag &&\n+\t\t\t\tf.text == cc.Text() {\n+\t\t\t\tp.scratch = append(p.scratch, c)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tp.candidates, p.scratch = p.scratch, p.candidates[0:0]\n+}"
        },
        {
          "filename": "vendor/github.com/vmware/vmw-ovflib/LICENSE",
          "status": "removed",
          "additions": 0,
          "deletions": 202,
          "patch": "@@ -1,202 +0,0 @@\n-Apache License\n-                           Version 2.0, January 2004\n-                        http://www.apache.org/licenses/\n-\n-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n-\n-   1. Definitions.\n-\n-      \"License\" shall mean the terms and conditions for use, reproduction,\n-      and distribution as defined by Sections 1 through 9 of this document.\n-\n-      \"Licensor\" shall mean the copyright owner or entity authorized by\n-      the copyright owner that is granting the License.\n-\n-      \"Legal Entity\" shall mean the union of the acting entity and all\n-      other entities that control, are controlled by, or are under common\n-      control with that entity. For the purposes of this definition,\n-      \"control\" means (i) the power, direct or indirect, to cause the\n-      direction or management of such entity, whether by contract or\n-      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n-      outstanding shares, or (iii) beneficial ownership of such entity.\n-\n-      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n-      exercising permissions granted by this License.\n-\n-      \"Source\" form shall mean the preferred form for making modifications,\n-      including but not limited to software source code, documentation\n-      source, and configuration files.\n-\n-      \"Object\" form shall mean any form resulting from mechanical\n-      transformation or translation of a Source form, including but\n-      not limited to compiled object code, generated documentation,\n-      and conversions to other media types.\n-\n-      \"Work\" shall mean the work of authorship, whether in Source or\n-      Object form, made available under the License, as indicated by a\n-      copyright notice that is included in or attached to the work\n-      (an example is provided in the Appendix below).\n-\n-      \"Derivative Works\" shall mean any work, whether in Source or Object\n-      form, that is based on (or derived from) the Work and for which the\n-      editorial revisions, annotations, elaborations, or other modifications\n-      represent, as a whole, an original work of authorship. For the purposes\n-      of this License, Derivative Works shall not include works that remain\n-      separable from, or merely link (or bind by name) to the interfaces of,\n-      the Work and Derivative Works thereof.\n-\n-      \"Contribution\" shall mean any work of authorship, including\n-      the original version of the Work and any modifications or additions\n-      to that Work or Derivative Works thereof, that is intentionally\n-      submitted to Licensor for inclusion in the Work by the copyright owner\n-      or by an individual or Legal Entity authorized to submit on behalf of\n-      the copyright owner. For the purposes of this definition, \"submitted\"\n-      means any form of electronic, verbal, or written communication sent\n-      to the Licensor or its representatives, including but not limited to\n-      communication on electronic mailing lists, source code control systems,\n-      and issue tracking systems that are managed by, or on behalf of, the\n-      Licensor for the purpose of discussing and improving the Work, but\n-      excluding communication that is conspicuously marked or otherwise\n-      designated in writing by the copyright owner as \"Not a Contribution.\"\n-\n-      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n-      on behalf of whom a Contribution has been received by Licensor and\n-      subsequently incorporated within the Work.\n-\n-   2. Grant of Copyright License. Subject to the terms and conditions of\n-      this License, each Contributor hereby grants to You a perpetual,\n-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n-      copyright license to reproduce, prepare Derivative Works of,\n-      publicly display, publicly perform, sublicense, and distribute the\n-      Work and such Derivative Works in Source or Object form.\n-\n-   3. Grant of Patent License. Subject to the terms and conditions of\n-      this License, each Contributor hereby grants to You a perpetual,\n-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n-      (except as stated in this section) patent license to make, have made,\n-      use, offer to sell, sell, import, and otherwise transfer the Work,\n-      where such license applies only to those patent claims licensable\n-      by such Contributor that are necessarily infringed by their\n-      Contribution(s) alone or by combination of their Contribution(s)\n-      with the Work to which such Contribution(s) was submitted. If You\n-      institute patent litigation against any entity (including a\n-      cross-claim or counterclaim in a lawsuit) alleging that the Work\n-      or a Contribution incorporated within the Work constitutes direct\n-      or contributory patent infringement, then any patent licenses\n-      granted to You under this License for that Work shall terminate\n-      as of the date such litigation is filed.\n-\n-   4. Redistribution. You may reproduce and distribute copies of the\n-      Work or Derivative Works thereof in any medium, with or without\n-      modifications, and in Source or Object form, provided that You\n-      meet the following conditions:\n-\n-      (a) You must give any other recipients of the Work or\n-          Derivative Works a copy of this License; and\n-\n-      (b) You must cause any modified files to carry prominent notices\n-          stating that You changed the files; and\n-\n-      (c) You must retain, in the Source form of any Derivative Works\n-          that You distribute, all copyright, patent, trademark, and\n-          attribution notices from the Source form of the Work,\n-          excluding those notices that do not pertain to any part of\n-          the Derivative Works; and\n-\n-      (d) If the Work includes a \"NOTICE\" text file as part of its\n-          distribution, then any Derivative Works that You distribute must\n-          include a readable copy of the attribution notices contained\n-          within such NOTICE file, excluding those notices that do not\n-          pertain to any part of the Derivative Works, in at least one\n-          of the following places: within a NOTICE text file distributed\n-          as part of the Derivative Works; within the Source form or\n-          documentation, if provided along with the Derivative Works; or,\n-          within a display generated by the Derivative Works, if and\n-          wherever such third-party notices normally appear. The contents\n-          of the NOTICE file are for informational purposes only and\n-          do not modify the License. You may add Your own attribution\n-          notices within Derivative Works that You distribute, alongside\n-          or as an addendum to the NOTICE text from the Work, provided\n-          that such additional attribution notices cannot be construed\n-          as modifying the License.\n-\n-      You may add Your own copyright statement to Your modifications and\n-      may provide additional or different license terms and conditions\n-      for use, reproduction, or distribution of Your modifications, or\n-      for any such Derivative Works as a whole, provided Your use,\n-      reproduction, and distribution of the Work otherwise complies with\n-      the conditions stated in this License.\n-\n-   5. Submission of Contributions. Unless You explicitly state otherwise,\n-      any Contribution intentionally submitted for inclusion in the Work\n-      by You to the Licensor shall be under the terms and conditions of\n-      this License, without any additional terms or conditions.\n-      Notwithstanding the above, nothing herein shall supersede or modify\n-      the terms of any separate license agreement you may have executed\n-      with Licensor regarding such Contributions.\n-\n-   6. Trademarks. This License does not grant permission to use the trade\n-      names, trademarks, service marks, or product names of the Licensor,\n-      except as required for reasonable and customary use in describing the\n-      origin of the Work and reproducing the content of the NOTICE file.\n-\n-   7. Disclaimer of Warranty. Unless required by applicable law or\n-      agreed to in writing, Licensor provides the Work (and each\n-      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n-      implied, including, without limitation, any warranties or conditions\n-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n-      PARTICULAR PURPOSE. You are solely responsible for determining the\n-      appropriateness of using or redistributing the Work and assume any\n-      risks associated with Your exercise of permissions under this License.\n-\n-   8. Limitation of Liability. In no event and under no legal theory,\n-      whether in tort (including negligence), contract, or otherwise,\n-      unless required by applicable law (such as deliberate and grossly\n-      negligent acts) or agreed to in writing, shall any Contributor be\n-      liable to You for damages, including any direct, indirect, special,\n-      incidental, or consequential damages of any character arising as a\n-      result of this License or out of the use or inability to use the\n-      Work (including but not limited to damages for loss of goodwill,\n-      work stoppage, computer failure or malfunction, or any and all\n-      other commercial damages or losses), even if such Contributor\n-      has been advised of the possibility of such damages.\n-\n-   9. Accepting Warranty or Additional Liability. While redistributing\n-      the Work or Derivative Works thereof, You may choose to offer,\n-      and charge a fee for, acceptance of support, warranty, indemnity,\n-      or other liability obligations and/or rights consistent with this\n-      License. However, in accepting such obligations, You may act only\n-      on Your own behalf and on Your sole responsibility, not on behalf\n-      of any other Contributor, and only if You agree to indemnify,\n-      defend, and hold each Contributor harmless for any liability\n-      incurred by, or claims asserted against, such Contributor by reason\n-      of your accepting any such warranty or additional liability.\n-\n-   END OF TERMS AND CONDITIONS\n-\n-   APPENDIX: How to apply the Apache License to your work.\n-\n-      To apply the Apache License to your work, attach the following\n-      boilerplate notice, with the fields enclosed by brackets \"{}\"\n-      replaced with your own identifying information. (Don't include\n-      the brackets!)  The text should be enclosed in the appropriate\n-      comment syntax for the file format. We also recommend that a\n-      file or class name and description of purpose be included on the\n-      same \"printed page\" as the copyright notice for easier\n-      identification within third-party archives.\n-\n-   Copyright {yyyy} {name of copyright owner}\n-\n-   Licensed under the Apache License, Version 2.0 (the \"License\");\n-   you may not use this file except in compliance with the License.\n-   You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-"
        },
        {
          "filename": "vendor/github.com/vmware/vmw-ovflib/README",
          "status": "removed",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -1 +0,0 @@\n-minimal support for parsing OVF environment"
        },
        {
          "filename": "vendor/github.com/vmware/vmw-ovflib/ovf.go",
          "status": "removed",
          "additions": 0,
          "deletions": 54,
          "patch": "@@ -1,54 +0,0 @@\n-// Copyright 2014-2015 VMware, Inc. All Rights Reserved.\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//     http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package ovf\n-\n-import (\n-\t\"encoding/xml\"\n-)\n-\n-type environment struct {\n-\tPlatform   platform   `xml:\"PlatformSection\"`\n-\tProperties []property `xml:\"PropertySection>Property\"`\n-}\n-\n-type platform struct {\n-\tKind    string `xml:\"Kind\"`\n-\tVersion string `xml:\"Version\"`\n-\tVendor  string `xml:\"Vendor\"`\n-\tLocale  string `xml:\"Locale\"`\n-}\n-\n-type property struct {\n-\tKey   string `xml:\"key,attr\"`\n-\tValue string `xml:\"value,attr\"`\n-}\n-\n-type OvfEnvironment struct {\n-\tPlatform   platform\n-\tProperties map[string]string\n-}\n-\n-func ReadEnvironment(doc []byte) (OvfEnvironment, error) {\n-\tvar env environment\n-\tif err := xml.Unmarshal(doc, &env); err != nil {\n-\t\treturn OvfEnvironment{}, err\n-\t}\n-\n-\tdict := make(map[string]string)\n-\tfor _, p := range env.Properties {\n-\t\tdict[p.Key] = p.Value\n-\t}\n-\treturn OvfEnvironment{Properties: dict, Platform: env.Platform}, nil\n-}"
        },
        {
          "filename": "vendor/modules.txt",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -58,6 +58,9 @@ github.com/aws/aws-sdk-go/service/s3/s3iface\n github.com/aws/aws-sdk-go/service/s3/s3manager\n github.com/aws/aws-sdk-go/service/sts\n github.com/aws/aws-sdk-go/service/sts/stsiface\n+# github.com/beevik/etree v1.1.1-0.20200718192613-4a2f8b9d084c\n+## explicit\n+github.com/beevik/etree\n # github.com/coreos/go-json v0.0.0-20211020211907-c63f628265de\n github.com/coreos/go-json\n # github.com/coreos/go-semver v0.3.0\n@@ -128,9 +131,6 @@ github.com/vmware/vmw-guestinfo/message\n github.com/vmware/vmw-guestinfo/rpcout\n github.com/vmware/vmw-guestinfo/rpcvmx\n github.com/vmware/vmw-guestinfo/vmcheck\n-# github.com/vmware/vmw-ovflib v0.0.0-20170608004843-1f217b9dc714\n-## explicit\n-github.com/vmware/vmw-ovflib\n # go.opencensus.io v0.22.5\n ## explicit\n go.opencensus.io"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 10,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "26ab8e36ed117c07bfed65c08f3847438d6023ab",
            "date": "2025-01-22T13:31:14Z",
            "author_login": "prestist"
          },
          {
            "sha": "7252ddb128a436651e5cb805c69834393b83bfa0",
            "date": "2025-01-20T22:13:20Z",
            "author_login": "prestist"
          },
          {
            "sha": "55d0c2adeda0bd248e2735ff77fab492b7c5c04f",
            "date": "2025-01-20T12:29:16Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "beaeeb449973322adf92f6b5aa26bdf379e7efab",
            "date": "2025-01-19T13:09:41Z",
            "author_login": "ferdnyc"
          },
          {
            "sha": "116f0b82f7dc19461b5f0b09550c81f3489525ec",
            "date": "2025-01-19T12:59:23Z",
            "author_login": "ferdnyc"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-863",
    "description": "A vulnerability was found in Ignition where ignition configs are accessible from unprivileged containers in VMs running on VMware products. This issue is only relevant in user environments where the Ignition config contains secrets. The highest threat from this vulnerability is to data confidentiality. Possible workaround is to not put secrets in the Ignition config.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-05-17T18:15:08.200",
    "last_modified": "2024-11-21T06:41:17.473",
    "fix_date": "2022-05-03T15:46:41Z"
  },
  "references": [
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2082274",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/coreos/ignition/commit/4b70b44b430ecf8377a276e89b5acd3a6957d4ea",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/coreos/ignition/issues/1300",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/coreos/ignition/issues/1315",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/coreos/ignition/pull/1350",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LY7LKGMQMXV6DGD263YQHNSLOJJ5VLV5/",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NP765L7TJI7CD4XVOHUWZVRYRH3FYBOR/",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/T5QQXRGQKTN4YX2ZF3GQNEBDEOKJGCN3/",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2082274",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/coreos/ignition/commit/4b70b44b430ecf8377a276e89b5acd3a6957d4ea",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/coreos/ignition/issues/1300",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/coreos/ignition/issues/1315",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/coreos/ignition/pull/1350",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LY7LKGMQMXV6DGD263YQHNSLOJJ5VLV5/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NP765L7TJI7CD4XVOHUWZVRYRH3FYBOR/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/T5QQXRGQKTN4YX2ZF3GQNEBDEOKJGCN3/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:07.126050",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "ignition",
    "owner": "coreos",
    "created_at": "2015-03-28T03:52:33Z",
    "updated_at": "2025-01-22T13:31:21Z",
    "pushed_at": "2025-01-22T13:31:15Z",
    "size": 23484,
    "stars": 853,
    "forks": 248,
    "open_issues": 116,
    "watchers": 853,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "spec2x"
    ],
    "languages": {
      "Go": 1640148,
      "C": 30850,
      "Shell": 18029,
      "Makefile": 2382,
      "Dockerfile": 391
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T08:22:18.233296"
  }
}