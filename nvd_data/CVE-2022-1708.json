{
  "cve_id": "CVE-2022-1708",
  "github_data": {
    "repository": "cri-o/cri-o",
    "fix_commit": "f032cf649ecc7e0c46718bd9e7814bfb317cb544",
    "related_commits": [
      "f032cf649ecc7e0c46718bd9e7814bfb317cb544",
      "f032cf649ecc7e0c46718bd9e7814bfb317cb544"
    ],
    "patch_url": "https://github.com/cri-o/cri-o/commit/f032cf649ecc7e0c46718bd9e7814bfb317cb544.patch",
    "fix_commit_details": {
      "sha": "f032cf649ecc7e0c46718bd9e7814bfb317cb544",
      "commit_date": "2022-06-06T17:54:06Z",
      "author": {
        "login": "haircommander",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-fcm2-6c3h-pg6j",
        "length": 117,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 289,
        "additions": 282,
        "deletions": 7
      },
      "files": [
        {
          "filename": "internal/config/conmonmgr/conmonmgr.go",
          "status": "modified",
          "additions": 29,
          "deletions": 3,
          "patch": "@@ -1,6 +1,7 @@\n package conmonmgr\n \n import (\n+\t\"bytes\"\n \t\"path\"\n \t\"strings\"\n \n@@ -10,11 +11,15 @@ import (\n \t\"github.com/sirupsen/logrus\"\n )\n \n-var versionSupportsSync = semver.MustParse(\"2.0.19\")\n+var (\n+\tversionSupportsSync             = semver.MustParse(\"2.0.19\")\n+\tversionSupportsLogGlobalSizeMax = semver.MustParse(\"2.1.2\")\n+)\n \n type ConmonManager struct {\n-\tconmonVersion *semver.Version\n-\tsupportsSync  bool\n+\tconmonVersion            *semver.Version\n+\tsupportsSync             bool\n+\tsupportsLogGlobalSizeMax bool\n }\n \n // this function is heavily based on github.com/containers/common#probeConmon\n@@ -37,6 +42,7 @@ func New(conmonPath string) (*ConmonManager, error) {\n \t}\n \n \tc.initializeSupportsSync()\n+\tc.initializeSupportsLogGlobalSizeMax(conmonPath)\n \treturn c, nil\n }\n \n@@ -49,6 +55,26 @@ func (c *ConmonManager) parseConmonVersion(versionString string) error {\n \treturn nil\n }\n \n+func (c *ConmonManager) initializeSupportsLogGlobalSizeMax(conmonPath string) {\n+\tc.supportsLogGlobalSizeMax = c.conmonVersion.GTE(versionSupportsLogGlobalSizeMax)\n+\tif !c.supportsLogGlobalSizeMax {\n+\t\t// Read help output as a fallback in case the feature was backported to conmon,\n+\t\t// but the version wasn't bumped.\n+\t\thelpOutput, err := cmdrunner.CombinedOutput(conmonPath, \"--help\")\n+\t\tc.supportsLogGlobalSizeMax = err == nil && bytes.Contains(helpOutput, []byte(\"--log-global-size-max\"))\n+\t}\n+\tverb := \"does not\"\n+\tif c.supportsLogGlobalSizeMax {\n+\t\tverb = \"does\"\n+\t}\n+\n+\tlogrus.Infof(\"Conmon %s support the --log-global-size-max option\", verb)\n+}\n+\n+func (c *ConmonManager) SupportsLogGlobalSizeMax() bool {\n+\treturn c.supportsLogGlobalSizeMax\n+}\n+\n func (c *ConmonManager) initializeSupportsSync() {\n \tc.supportsSync = c.conmonVersion.GTE(versionSupportsSync)\n \tverb := \"does not\""
        },
        {
          "filename": "internal/config/conmonmgr/conmonmgr_test.go",
          "status": "modified",
          "additions": 105,
          "deletions": 1,
          "patch": "@@ -70,7 +70,7 @@ var _ = t.Describe(\"ConmonManager\", func() {\n \t\tIt(\"should succeed when output expected\", func() {\n \t\t\t// Given\n \t\t\tgomock.InOrder(\n-\t\t\t\trunner.EXPECT().CombinedOutput(gomock.Any(), gomock.Any()).Return([]byte(\"conmon version 2.0.0\"), nil),\n+\t\t\t\trunner.EXPECT().CombinedOutput(gomock.Any(), gomock.Any()).Return([]byte(\"conmon version 2.2.2\"), nil),\n \t\t\t)\n \n \t\t\t// When\n@@ -170,4 +170,108 @@ var _ = t.Describe(\"ConmonManager\", func() {\n \t\t\tExpect(mgr.SupportsSync()).To(Equal(true))\n \t\t})\n \t})\n+\tt.Describe(\"initializeSupportsLogGlobalSizeMax\", func() {\n+\t\tvar mgr *ConmonManager\n+\t\tBeforeEach(func() {\n+\t\t\trunner = runnerMock.NewMockCommandRunner(mockCtrl)\n+\t\t\tcmdrunner.SetMocked(runner)\n+\t\t\tmgr = new(ConmonManager)\n+\t\t})\n+\t\tIt(\"should be false when major version less\", func() {\n+\t\t\t// Given\n+\t\t\tgomock.InOrder(\n+\t\t\t\trunner.EXPECT().CombinedOutput(gomock.Any(), gomock.Any()).Return([]byte{}, errors.New(\"cmd failed\")),\n+\t\t\t)\n+\t\t\terr := mgr.parseConmonVersion(\"1.1.2\")\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\t// When\n+\t\t\tmgr.initializeSupportsLogGlobalSizeMax(\"\")\n+\n+\t\t\t// Then\n+\t\t\tExpect(mgr.SupportsLogGlobalSizeMax()).To(Equal(false))\n+\t\t})\n+\t\tIt(\"should be true when major version greater\", func() {\n+\t\t\t// Given\n+\t\t\terr := mgr.parseConmonVersion(\"3.1.1\")\n+\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t// When\n+\t\t\tmgr.initializeSupportsLogGlobalSizeMax(\"\")\n+\n+\t\t\t// Then\n+\t\t\tExpect(mgr.SupportsLogGlobalSizeMax()).To(Equal(true))\n+\t\t})\n+\t\tIt(\"should be false when minor version less\", func() {\n+\t\t\t// Given\n+\t\t\tgomock.InOrder(\n+\t\t\t\trunner.EXPECT().CombinedOutput(gomock.Any(), gomock.Any()).Return([]byte{}, errors.New(\"cmd failed\")),\n+\t\t\t)\n+\t\t\terr := mgr.parseConmonVersion(\"2.0.2\")\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\t// When\n+\t\t\tmgr.initializeSupportsLogGlobalSizeMax(\"\")\n+\n+\t\t\t// Then\n+\t\t\tExpect(mgr.SupportsLogGlobalSizeMax()).To(Equal(false))\n+\t\t})\n+\t\tIt(\"should be true when minor version greater\", func() {\n+\t\t\t// Given\n+\t\t\terr := mgr.parseConmonVersion(\"2.2.2\")\n+\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t// When\n+\t\t\tmgr.initializeSupportsLogGlobalSizeMax(\"\")\n+\n+\t\t\t// Then\n+\t\t\tExpect(mgr.SupportsLogGlobalSizeMax()).To(Equal(true))\n+\t\t})\n+\t\tIt(\"should be false when patch version less\", func() {\n+\t\t\t// Given\n+\t\t\tgomock.InOrder(\n+\t\t\t\trunner.EXPECT().CombinedOutput(gomock.Any(), gomock.Any()).Return([]byte{}, errors.New(\"cmd failed\")),\n+\t\t\t)\n+\t\t\terr := mgr.parseConmonVersion(\"2.1.1\")\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\t// When\n+\t\t\tmgr.initializeSupportsLogGlobalSizeMax(\"\")\n+\n+\t\t\t// Then\n+\t\t\tExpect(mgr.SupportsLogGlobalSizeMax()).To(Equal(false))\n+\t\t})\n+\t\tIt(\"should be true when patch version greater\", func() {\n+\t\t\t// Given\n+\t\t\terr := mgr.parseConmonVersion(\"2.1.3\")\n+\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t// When\n+\t\t\tmgr.initializeSupportsLogGlobalSizeMax(\"\")\n+\n+\t\t\t// Then\n+\t\t\tExpect(mgr.SupportsLogGlobalSizeMax()).To(Equal(true))\n+\t\t})\n+\t\tIt(\"should be true when version equal\", func() {\n+\t\t\t// Given\n+\t\t\terr := mgr.parseConmonVersion(\"2.1.2\")\n+\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t// When\n+\t\t\tmgr.initializeSupportsLogGlobalSizeMax(\"\")\n+\t\t\t// Then\n+\t\t\tExpect(mgr.SupportsLogGlobalSizeMax()).To(Equal(true))\n+\t\t})\n+\t\tIt(\"should be true if feature backported\", func() {\n+\t\t\t// Given\n+\t\t\tgomock.InOrder(\n+\t\t\t\trunner.EXPECT().CombinedOutput(gomock.Any(), gomock.Any()).Return([]byte(\"--log-global-size-max\"), nil),\n+\t\t\t)\n+\t\t\terr := mgr.parseConmonVersion(\"0.0.0\")\n+\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t// When\n+\t\t\tmgr.initializeSupportsLogGlobalSizeMax(\"\")\n+\n+\t\t\t// Then\n+\t\t\tExpect(mgr.SupportsLogGlobalSizeMax()).To(Equal(true))\n+\t\t})\n+\t})\n })"
        },
        {
          "filename": "internal/oci/oci.go",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -35,6 +35,11 @@ const (\n \t// killContainerTimeout is the timeout that we wait for the container to\n \t// be SIGKILLed.\n \tkillContainerTimeout = 2 * time.Minute\n+\n+\t// maxExecSyncSize is the maximum size of exec sync output CRI-O will process.\n+\t// It is set to the amount of logs allowed in the dockershim implementation:\n+\t// https://github.com/kubernetes/kubernetes/pull/82514\n+\tmaxExecSyncSize = 16 * 1024 * 1024\n )\n \n // Runtime is the generic structure holding both global and specific"
        },
        {
          "filename": "internal/oci/runtime_oci.go",
          "status": "modified",
          "additions": 18,
          "deletions": 1,
          "patch": "@@ -486,6 +486,9 @@ func (r *runtimeOCI) ExecSyncContainer(ctx context.Context, c *Container, comman\n \tif r.config.ConmonSupportsSync() {\n \t\targs = append(args, \"--sync\")\n \t}\n+\tif r.config.ConmonSupportsLogGlobalSizeMax() {\n+\t\targs = append(args, \"--log-global-size-max\", strconv.Itoa(maxExecSyncSize))\n+\t}\n \tif c.terminal {\n \t\targs = append(args, \"-t\")\n \t}\n@@ -661,7 +664,7 @@ func (r *runtimeOCI) ExecSyncContainer(ctx context.Context, c *Container, comman\n \t// ExecSyncResponse we have to read the logfile.\n \t// XXX: Currently runC dups the same console over both stdout and stderr,\n \t//      so we can't differentiate between the two.\n-\tlogBytes, err := ioutil.ReadFile(logPath)\n+\tlogBytes, err := TruncateAndReadFile(ctx, logPath, maxExecSyncSize)\n \tif err != nil {\n \t\treturn nil, &ExecSyncError{\n \t\t\tStdout:   stdoutBuf,\n@@ -680,6 +683,20 @@ func (r *runtimeOCI) ExecSyncContainer(ctx context.Context, c *Container, comman\n \t}, nil\n }\n \n+func TruncateAndReadFile(ctx context.Context, path string, size int64) ([]byte, error) {\n+\tinfo, err := os.Stat(path)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif info.Size() > size {\n+\t\tlog.Errorf(ctx, \"Exec sync output in file %s has size %d which is longer than expected size of %d\", path, info.Size(), size)\n+\t\tif err := os.Truncate(path, size); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\treturn os.ReadFile(path)\n+}\n+\n // UpdateContainer updates container resources\n func (r *runtimeOCI) UpdateContainer(ctx context.Context, c *Container, res *rspec.LinuxResources) error {\n \tif c.Spoofed() {"
        },
        {
          "filename": "internal/oci/runtime_oci_test.go",
          "status": "modified",
          "additions": 39,
          "deletions": 0,
          "patch": "@@ -3,6 +3,7 @@ package oci_test\n import (\n \t\"context\"\n \t\"math/rand\"\n+\t\"os\"\n \t\"os/exec\"\n \t\"time\"\n \n@@ -142,6 +143,44 @@ var _ = t.Describe(\"Oci\", func() {\n \t\t\t})\n \t\t}\n \t})\n+\tContext(\"TruncateAndReadFile\", func() {\n+\t\ttests := []struct {\n+\t\t\ttitle    string\n+\t\t\tcontents []byte\n+\t\t\texpected []byte\n+\t\t\tfail     bool\n+\t\t\tsize     int64\n+\t\t}{\n+\t\t\t{\n+\t\t\t\ttitle:    \"should read file if size is smaller than limit\",\n+\t\t\t\tcontents: []byte(\"abcd\"),\n+\t\t\t\texpected: []byte(\"abcd\"),\n+\t\t\t\tsize:     5,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\ttitle:    \"should read only size if size is same as limit\",\n+\t\t\t\tcontents: []byte(\"abcd\"),\n+\t\t\t\texpected: []byte(\"abcd\"),\n+\t\t\t\tsize:     4,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\ttitle:    \"should read only size if size is larger than limit\",\n+\t\t\t\tcontents: []byte(\"abcd\"),\n+\t\t\t\texpected: []byte(\"abc\"),\n+\t\t\t\tsize:     3,\n+\t\t\t},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tIt(test.title, func() {\n+\t\t\t\tfileName := t.MustTempFile(\"to-read\")\n+\t\t\t\tExpect(os.WriteFile(fileName, test.contents, 0o644)).To(BeNil())\n+\t\t\t\tfound, err := oci.TruncateAndReadFile(context.Background(), fileName, test.size)\n+\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\tExpect(found).To(Equal(test.expected))\n+\t\t\t})\n+\t\t}\n+\t})\n })\n \n func waitContainerStopAndFailAfterTimeout(ctx context.Context,"
        },
        {
          "filename": "internal/oci/runtime_vm.go",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -39,6 +39,7 @@ import (\n \t\"k8s.io/client-go/tools/remotecommand\"\n \ttypes \"k8s.io/cri-api/pkg/apis/runtime/v1\"\n \tkubecontainer \"k8s.io/kubernetes/pkg/kubelet/container\"\n+\tkioutil \"k8s.io/kubernetes/pkg/kubelet/util/ioutils\"\n \tutilexec \"k8s.io/utils/exec\"\n )\n \n@@ -307,8 +308,8 @@ func (r *runtimeVM) ExecSyncContainer(ctx context.Context, c *Container, command\n \tdefer log.Debugf(ctx, \"RuntimeVM.ExecSyncContainer() end\")\n \n \tvar stdoutBuf, stderrBuf bytes.Buffer\n-\tstdout := cioutil.NewNopWriteCloser(&stdoutBuf)\n-\tstderr := cioutil.NewNopWriteCloser(&stderrBuf)\n+\tstdout := kioutil.WriteCloserWrapper(kioutil.LimitWriter(&stdoutBuf, maxExecSyncSize))\n+\tstderr := kioutil.WriteCloserWrapper(kioutil.LimitWriter(&stderrBuf, maxExecSyncSize))\n \n \texitCode, err := r.execContainerCommon(ctx, c, command, timeout, nil, stdout, stderr, c.terminal, nil)\n \tif err != nil {"
        },
        {
          "filename": "pkg/config/config.go",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -1183,6 +1183,10 @@ func (c *RuntimeConfig) ConmonSupportsSync() bool {\n \treturn c.conmonManager.SupportsSync()\n }\n \n+func (c *RuntimeConfig) ConmonSupportsLogGlobalSizeMax() bool {\n+\treturn c.conmonManager.SupportsLogGlobalSizeMax()\n+}\n+\n func (c *RuntimeConfig) ValidatePinnsPath(executable string) error {\n \tvar err error\n \tc.PinnsPath, err = validateExecutablePath(executable, c.PinnsPath)"
        },
        {
          "filename": "test/ctr.bats",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -514,6 +514,14 @@ function check_oci_annotation() {\n \tcrictl exec --sync \"$ctr_id\" /bin/sh -c \"[[ -t 1 ]]\"\n }\n \n+@test \"ctr execsync should cap output\" {\n+\tstart_crio\n+\n+\tctr_id=$(crictl run \"$TESTDATA\"/container_sleep.json \"$TESTDATA\"/sandbox_config.json)\n+\n+\t[[ $(crictl exec --sync \"$ctr_id\" /bin/sh -c \"for i in $(seq 1 50000000); do echo -n 'a'; done\" | wc -c) -le 16777216 ]]\n+}\n+\n @test \"ctr device add\" {\n \t# In an user namespace we can only bind mount devices from the host, not mknod\n \t# https://github.com/opencontainers/runc/blob/master/libcontainer/rootfs_linux.go#L480-L481"
        },
        {
          "filename": "vendor/k8s.io/kubernetes/pkg/kubelet/util/ioutils/ioutils.go",
          "status": "added",
          "additions": 70,
          "deletions": 0,
          "patch": "@@ -0,0 +1,70 @@\n+/*\n+Copyright 2016 The Kubernetes Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package ioutils\n+\n+import \"io\"\n+\n+// writeCloserWrapper represents a WriteCloser whose closer operation is noop.\n+type writeCloserWrapper struct {\n+\tWriter io.Writer\n+}\n+\n+func (w *writeCloserWrapper) Write(buf []byte) (int, error) {\n+\treturn w.Writer.Write(buf)\n+}\n+\n+func (w *writeCloserWrapper) Close() error {\n+\treturn nil\n+}\n+\n+// WriteCloserWrapper returns a writeCloserWrapper.\n+func WriteCloserWrapper(w io.Writer) io.WriteCloser {\n+\treturn &writeCloserWrapper{w}\n+}\n+\n+// LimitWriter is a copy of the standard library ioutils.LimitReader,\n+// applied to the writer interface.\n+// LimitWriter returns a Writer that writes to w\n+// but stops with EOF after n bytes.\n+// The underlying implementation is a *LimitedWriter.\n+func LimitWriter(w io.Writer, n int64) io.Writer { return &LimitedWriter{w, n} }\n+\n+// A LimitedWriter writes to W but limits the amount of\n+// data returned to just N bytes. Each call to Write\n+// updates N to reflect the new amount remaining.\n+// Write returns EOF when N <= 0 or when the underlying W returns EOF.\n+type LimitedWriter struct {\n+\tW io.Writer // underlying writer\n+\tN int64     // max bytes remaining\n+}\n+\n+func (l *LimitedWriter) Write(p []byte) (n int, err error) {\n+\tif l.N <= 0 {\n+\t\treturn 0, io.ErrShortWrite\n+\t}\n+\ttruncated := false\n+\tif int64(len(p)) > l.N {\n+\t\tp = p[0:l.N]\n+\t\ttruncated = true\n+\t}\n+\tn, err = l.W.Write(p)\n+\tl.N -= int64(n)\n+\tif err == nil && truncated {\n+\t\terr = io.ErrShortWrite\n+\t}\n+\treturn\n+}"
        },
        {
          "filename": "vendor/modules.txt",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -1741,6 +1741,7 @@ k8s.io/kubernetes/pkg/kubelet/cri/streaming\n k8s.io/kubernetes/pkg/kubelet/cri/streaming/portforward\n k8s.io/kubernetes/pkg/kubelet/cri/streaming/remotecommand\n k8s.io/kubernetes/pkg/kubelet/types\n+k8s.io/kubernetes/pkg/kubelet/util/ioutils\n k8s.io/kubernetes/pkg/proxy\n k8s.io/kubernetes/pkg/proxy/config\n k8s.io/kubernetes/pkg/proxy/healthcheck"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 3,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 6,
        "max_directory_depth": 7
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c956013c220998c7736e4bc6a98fccd797e47abd",
            "date": "2025-01-10T00:51:31Z",
            "author_login": "openshift-merge-bot[bot]"
          },
          {
            "sha": "9165374efe1323244b7a18dc3620f8ef36088fa7",
            "date": "2025-01-08T18:26:33Z",
            "author_login": "openshift-merge-bot[bot]"
          },
          {
            "sha": "ddaed68a375aa041c6eb58cf4de5a41bd0c9ba1e",
            "date": "2024-12-21T10:43:47Z",
            "author_login": "bitoku"
          },
          {
            "sha": "a4fd64fe43ca8fc4a928f0277bbfc8d8abec1e0b",
            "date": "2025-01-07T23:28:50Z",
            "author_login": "openshift-merge-bot[bot]"
          },
          {
            "sha": "f5e6d6f7ff827d9b958a749a6975d5838142953d",
            "date": "2025-01-07T06:47:58Z",
            "author_login": "kwilczynski"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "A vulnerability was found in CRI-O that causes memory or disk space exhaustion on the node for anyone with access to the Kube API. The ExecSync request runs commands in a container and logs the output of the command. This output is then read by CRI-O after command execution, and it is read in a manner where the entire file corresponding to the output of the command is read in. Thus, if the output of the command is large it is possible to exhaust the memory or the disk space of the node when CRI-O reads the output of the command. The highest threat from this vulnerability is system availability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-06-07T18:15:11.640",
    "last_modified": "2024-11-21T06:41:17.743",
    "fix_date": "2022-06-06T17:54:06Z"
  },
  "references": [
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2085361",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/cri-o/cri-o/commit/f032cf649ecc7e0c46718bd9e7814bfb317cb544",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/cri-o/cri-o/security/advisories/GHSA-fcm2-6c3h-pg6j",
      "source": "secalert@redhat.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2085361",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/cri-o/cri-o/commit/f032cf649ecc7e0c46718bd9e7814bfb317cb544",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/cri-o/cri-o/security/advisories/GHSA-fcm2-6c3h-pg6j",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:09.414357",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "cri-o",
    "owner": "cri-o",
    "created_at": "2016-09-09T19:56:31Z",
    "updated_at": "2025-01-14T12:21:34Z",
    "pushed_at": "2025-01-13T20:41:06Z",
    "size": 172454,
    "stars": 5292,
    "forks": 1069,
    "open_issues": 116,
    "watchers": 5292,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-1.0",
      "release-1.6",
      "release-1.7",
      "release-1.8",
      "release-1.9",
      "release-1.10",
      "release-1.11",
      "release-1.12",
      "release-1.13",
      "release-1.14",
      "release-1.15",
      "release-1.16",
      "release-1.17",
      "release-1.18",
      "release-1.19",
      "release-1.20",
      "release-1.21",
      "release-1.22"
    ],
    "languages": {
      "Go": 2088167,
      "Shell": 463814,
      "Makefile": 20554,
      "C": 18919,
      "Nix": 2863,
      "Dockerfile": 120
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:23:12.607889"
  }
}