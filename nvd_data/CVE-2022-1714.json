{
  "cve_id": "CVE-2022-1714",
  "github_data": {
    "repository": "radareorg/radare2",
    "fix_commit": "3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e",
    "related_commits": [
      "3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e",
      "3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e"
    ],
    "patch_url": "https://github.com/radareorg/radare2/commit/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e.patch",
    "fix_commit_details": {
      "sha": "3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e",
      "commit_date": "2022-05-13T13:58:15Z",
      "author": {
        "login": "radare",
        "type": "User",
        "stats": {
          "total_commits": 16352,
          "average_weekly_commits": 19.630252100840337,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 785
        }
      },
      "commit_message": {
        "title": "Fix 4 byte oobread in msp430 disassembler ##crash",
        "length": 193,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 27,
        "additions": 13,
        "deletions": 14
      },
      "files": [
        {
          "filename": "libr/anal/p/anal_msp430.c",
          "status": "modified",
          "additions": 6,
          "deletions": 7,
          "patch": "@@ -10,17 +10,13 @@\n #include \"../arch/msp430/msp430_disas.h\"\n \n static int msp430_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n-\tint ret;\n-\tstruct msp430_cmd cmd;\n-\n-\tmemset (&cmd, 0, sizeof (cmd));\n-\t//op->id = ???;\n+\tstruct msp430_cmd cmd = {0};\n \top->size = -1;\n \top->nopcode = 1;\n \top->type = R_ANAL_OP_TYPE_UNK;\n \top->family = R_ANAL_OP_FAMILY_CPU;\n \n-\tret = op->size = msp430_decode_command (buf, len, &cmd);\n+\tint ret = op->size = msp430_decode_command (buf, len, &cmd);\n \tif (mask & R_ANAL_OP_MASK_DISASM) {\n \t\tif (ret < 1) {\n \t\t\top->mnemonic = strdup (\"invalid\");\n@@ -59,7 +55,9 @@ static int msp430_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int le\n \t\tcase MSP430_CALL:\n \t\t\top->type = R_ANAL_OP_TYPE_CALL;\n \t\t\top->fail = addr + op->size;\n-\t\t\top->jump = r_read_at_le16 (buf, 2);\n+\t\t\tif (len > 4) {\n+\t\t\t\top->jump = r_read_at_le16 (buf, 2);\n+\t\t\t}\n \t\t\tbreak;\n \t\tcase MSP430_RETI:\n \t\t\top->type = R_ANAL_OP_TYPE_RET;\n@@ -111,6 +109,7 @@ static bool set_reg_profile(RAnal *anal) {\n \tconst char *p = \\\n \t\t\"=PC\tpc\\n\"\n \t\t\"=SP\tsp\\n\"\n+\t\t\"=SN\tr0\\n\"\n \t\t// this is the \"new\" ABI, the old was reverse order\n \t\t\"=A0\tr12\\n\"\n \t\t\"=A1\tr13\\n\""
        },
        {
          "filename": "libr/bin/format/elf/elf.c",
          "status": "modified",
          "additions": 7,
          "deletions": 7,
          "patch": "@@ -124,7 +124,7 @@ static bool init_ehdr(ELFOBJ *bin) {\n \tut8 ehdr[sizeof (Elf_(Ehdr))] = {0};\n \tint i, len;\n \tif (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {\n-\t\tR_LOG_ERROR (\"read (magic)\");\n+\t\tR_LOG_DEBUG (\"read (magic)\");\n \t\treturn false;\n \t}\n \tsdb_set (bin->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n@@ -188,7 +188,7 @@ static bool init_ehdr(ELFOBJ *bin) {\n \tmemset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));\n \tlen = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));\n \tif (len < 32) { // tinyelf != sizeof (Elf_(Ehdr))) {\n-\t\tR_LOG_ERROR (\"read (ehdr)\");\n+\t\tR_LOG_DEBUG (\"read (ehdr)\");\n \t\treturn false;\n \t}\n \t// XXX no need to check twice\n@@ -257,7 +257,7 @@ static bool read_phdr(ELFOBJ *bin, bool linux_kernel_hack) {\n \t\tconst size_t rsize = bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr));\n \t\tint len = r_buf_read_at (bin->b, rsize, phdr, sizeof (Elf_(Phdr)));\n \t\tif (len < 1) {\n-\t\t\tR_LOG_ERROR (\"read (phdr)\");\n+\t\t\tR_LOG_DEBUG (\"read (phdr)\");\n \t\t\tR_FREE (bin->phdr);\n \t\t\treturn false;\n \t\t}\n@@ -397,7 +397,7 @@ static int init_shdr(ELFOBJ *bin) {\n \t\tj = 0;\n \t\tlen = r_buf_read_at (bin->b, bin->ehdr.e_shoff + i * sizeof (Elf_(Shdr)), shdr, sizeof (Elf_(Shdr)));\n \t\tif (len < 1) {\n-\t\t\tR_LOG_ERROR (\"read (shdr) at 0x%\" PFMT64x, (ut64) bin->ehdr.e_shoff);\n+\t\t\tR_LOG_DEBUG (\"read (shdr) at 0x%\" PFMT64x, (ut64) bin->ehdr.e_shoff);\n \t\t\tR_FREE (bin->shdr);\n \t\t\treturn false;\n \t\t}\n@@ -475,7 +475,7 @@ static int init_strtab(ELFOBJ *bin) {\n \tint res = r_buf_read_at (bin->b, bin->shstrtab_section->sh_offset, (ut8*)bin->shstrtab,\n \t\tbin->shstrtab_section->sh_size);\n \tif (res < 1) {\n-\t\tR_LOG_ERROR (\"read (shstrtab) at 0x%\" PFMT64x, (ut64) bin->shstrtab_section->sh_offset);\n+\t\tR_LOG_DEBUG (\"read (shstrtab) at 0x%\" PFMT64x, (ut64) bin->shstrtab_section->sh_offset);\n \t\tR_FREE (bin->shstrtab);\n \t\treturn false;\n \t}\n@@ -970,7 +970,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \t}\n \tElf_(Verdef) *defs = calloc (shdr->sh_size, 1);\n \tif (!defs) {\n-\t\tR_LOG_ERROR (\"Cannot allocate memory (Check Elf_(Verdef))\");\n+\t\tR_LOG_DEBUG (\"Cannot allocate memory (Check Elf_(Verdef))\");\n \t\treturn false;\n \t}\n \tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n@@ -1798,7 +1798,7 @@ ut64 Elf_(r_bin_elf_get_init_offset)(ELFOBJ *bin) {\n \t\treturn UT64_MAX;\n \t}\n \tif (r_buf_read_at (bin->b, entry + 16, buf, sizeof (buf)) < 1) {\n-\t\tR_LOG_ERROR (\"read (init_offset)\");\n+\t\tR_LOG_DEBUG (\"read (init_offset)\");\n \t\treturn 0;\n \t}\n \tif (buf[0] == 0x68) { // push // x86 only"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "0f85675c7a5d542a89318b62d4a4bc997e595e03",
            "date": "2025-01-14T11:01:39Z",
            "author_login": "radare"
          },
          {
            "sha": "92d45a6034fe60123adc23bf49b398809fe36d25",
            "date": "2025-01-14T11:11:00Z",
            "author_login": "radare"
          },
          {
            "sha": "07be136859c56f96a692c8d5d1a3531345f16a0c",
            "date": "2025-01-14T10:46:07Z",
            "author_login": "radare"
          },
          {
            "sha": "05ebe2e92fc1905702201106228b285c80bd958b",
            "date": "2025-01-14T10:28:47Z",
            "author_login": "radare"
          },
          {
            "sha": "e672c13d0f3620daf80a718e47d759f933bd8961",
            "date": "2025-01-14T10:18:30Z",
            "author_login": "trufae"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.1,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
    "cwe_id": "CWE-125",
    "description": "Out-of-bounds Read in GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-05-13T15:15:08.733",
    "last_modified": "2024-11-21T06:41:18.470",
    "fix_date": "2022-05-13T13:58:15Z"
  },
  "references": [
    {
      "url": "https://github.com/radareorg/radare2/commit/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e",
      "source": "security@huntr.dev",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/1c22055b-b015-47a8-a57b-4982978751d0",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/radareorg/radare2/commit/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/1c22055b-b015-47a8-a57b-4982978751d0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:07.114509",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "radare2",
    "owner": "radareorg",
    "created_at": "2012-07-03T07:42:26Z",
    "updated_at": "2025-01-14T11:39:09Z",
    "pushed_at": "2025-01-14T11:39:05Z",
    "size": 182812,
    "stars": 20990,
    "forks": 3027,
    "open_issues": 874,
    "watchers": 20990,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 29143253,
      "Makefile": 262919,
      "Shell": 145034,
      "Meson": 123192,
      "C++": 82794,
      "HTML": 55704,
      "Rebol": 54153,
      "Python": 38146,
      "Roff": 36722,
      "JavaScript": 23584,
      "CSS": 19465,
      "Batchfile": 8970,
      "Perl": 6449,
      "sed": 4448,
      "R": 1960,
      "Rez": 1386,
      "Assembly": 939,
      "Vala": 839,
      "Wren": 460,
      "Gnuplot": 429,
      "C#": 164,
      "Dart": 125,
      "Rascal": 45
    },
    "commit_activity": {
      "total_commits_last_year": 1594,
      "avg_commits_per_week": 30.653846153846153,
      "days_active_last_year": 294
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:04:16.054007"
  }
}