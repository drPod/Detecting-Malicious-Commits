{
  "cve_id": "CVE-2022-21646",
  "github_data": {
    "repository": "authzed/spicedb",
    "fix_commit": "15bba2e2d2a4bda336a37a7fe8ef8a35028cd970",
    "related_commits": [
      "15bba2e2d2a4bda336a37a7fe8ef8a35028cd970",
      "15bba2e2d2a4bda336a37a7fe8ef8a35028cd970"
    ],
    "patch_url": "https://github.com/authzed/spicedb/commit/15bba2e2d2a4bda336a37a7fe8ef8a35028cd970.patch",
    "fix_commit_details": {
      "sha": "15bba2e2d2a4bda336a37a7fe8ef8a35028cd970",
      "commit_date": "2022-01-11T19:39:23Z",
      "author": {
        "login": "josephschorr",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-7p8f-8hjm-wm92",
        "length": 89,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 2418,
        "additions": 1761,
        "deletions": 657
      },
      "files": [
        {
          "filename": "internal/graph/check.go",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -45,7 +45,9 @@ type ValidatedCheckRequest struct {\n func (cc *ConcurrentChecker) Check(ctx context.Context, req ValidatedCheckRequest, relation *v0.Relation) (*v1.DispatchCheckResponse, error) {\n \tvar directFunc ReduceableCheckFunc\n \n-\tif onrEqual(req.Subject, req.ObjectAndRelation) {\n+\tif req.Subject.ObjectId == tuple.PublicWildcard {\n+\t\tdirectFunc = checkError(NewErrInvalidArgument(errors.New(\"cannot perform check on wildcard\")))\n+\t} else if onrEqual(req.Subject, req.ObjectAndRelation) {\n \t\t// If we have found the goal's ONR, then we know that the ONR is a member.\n \t\tdirectFunc = alwaysMember()\n \t} else if relation.UsersetRewrite == nil {"
        },
        {
          "filename": "internal/graph/errors.go",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -122,3 +122,15 @@ func NewRelationMissingTypeInfoErr(nsName string, relationName string) error {\n \t\trelationName:  relationName,\n \t}\n }\n+\n+// ErrInvalidArgument occurs when a request sent has an invalid argument.\n+type ErrInvalidArgument struct {\n+\terror\n+}\n+\n+// NewErrInvalidArgument constructs a request sent has an invalid argument.\n+func NewErrInvalidArgument(baseErr error) error {\n+\treturn ErrInvalidArgument{\n+\t\terror: baseErr,\n+\t}\n+}"
        },
        {
          "filename": "internal/graph/lookup.go",
          "status": "modified",
          "additions": 46,
          "deletions": 3,
          "patch": "@@ -2,6 +2,7 @@ package graph\n \n import (\n \t\"context\"\n+\t\"errors\"\n \t\"fmt\"\n \n \tv0 \"github.com/authzed/authzed-go/proto/authzed/api/v0\"\n@@ -46,6 +47,10 @@ const (\n // Lookup performs a lookup request with the provided request and context.\n func (cl *ConcurrentLookup) Lookup(ctx context.Context, req ValidatedLookupRequest) (*v1.DispatchLookupResponse, error) {\n \tfuncToResolve := cl.lookupInternal(ctx, req)\n+\tif req.Subject.ObjectId == tuple.PublicWildcard {\n+\t\tfuncToResolve = returnResult(lookupResultError(req, NewErrInvalidArgument(errors.New(\"cannot perform lookup on wildcard\")), emptyMetadata))\n+\t}\n+\n \tresolved := lookupOne(ctx, req, funcToResolve)\n \n \t// Remove the resolved relation reference from the excluded direct list to mark that it was completely resolved.\n@@ -115,9 +120,7 @@ func (cl *ConcurrentLookup) lookupInternal(ctx context.Context, req ValidatedLoo\n \t\tvar requests []ReduceableLookupFunc\n \t\tfor _, obj := range toCheck.AsSlice() {\n \t\t\t// If we've already found the target ONR, no further resolution is necessary.\n-\t\t\tif obj.Namespace == req.Subject.Namespace &&\n-\t\t\t\tobj.Relation == req.Subject.Relation &&\n-\t\t\t\tobj.ObjectId == req.Subject.ObjectId {\n+\t\t\tif onrEqualOrWildcard(obj, req.Subject) {\n \t\t\t\tcontinue\n \t\t\t}\n \n@@ -206,6 +209,46 @@ func (cl *ConcurrentLookup) lookupDirect(ctx context.Context, req ValidatedLooku\n \t\t})\n \t}\n \n+\t// Dispatch a check for the subject wildcard, if allowed.\n+\tisWildcardAllowed, err := typeSystem.IsAllowedPublicNamespace(req.ObjectRelation.Relation, req.Subject.Namespace)\n+\tif isWildcardAllowed == namespace.PublicSubjectAllowed {\n+\t\trequests = append(requests, func(ctx context.Context, resultChan chan<- LookupResult) {\n+\t\t\tobjects := tuple.NewONRSet()\n+\t\t\tit, err := cl.ds.ReverseQueryTuples(\n+\t\t\t\tctx,\n+\t\t\t\ttuple.UsersetToSubjectFilter(&v0.ObjectAndRelation{\n+\t\t\t\t\tNamespace: req.Subject.Namespace,\n+\t\t\t\t\tObjectId:  tuple.PublicWildcard,\n+\t\t\t\t\tRelation:  req.Subject.Relation,\n+\t\t\t\t}),\n+\t\t\t\treq.Revision,\n+\t\t\t\toptions.WithResRelation(&options.ResourceRelation{\n+\t\t\t\t\tNamespace: req.ObjectRelation.Namespace,\n+\t\t\t\t\tRelation:  req.ObjectRelation.Relation,\n+\t\t\t\t}),\n+\t\t\t)\n+\t\t\tif err != nil {\n+\t\t\t\tresultChan <- lookupResultError(req, err, emptyMetadata)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tdefer it.Close()\n+\n+\t\t\tfor tpl := it.Next(); tpl != nil; tpl = it.Next() {\n+\t\t\t\tobjects.Add(tpl.ObjectAndRelation)\n+\t\t\t\tif objects.Length() >= req.Limit {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif it.Err() != nil {\n+\t\t\t\tresultChan <- lookupResultError(req, it.Err(), emptyMetadata)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tresultChan <- lookupResult(req, objects.AsSlice(), emptyMetadata)\n+\t\t})\n+\t}\n+\n \t// Dispatch to any allowed subject relation types that don't match the target ONR, collect\n \t// the found object IDs, and then search for those.\n \tallowedDirect, err := typeSystem.AllowedSubjectRelations(req.ObjectRelation.Relation)"
        },
        {
          "filename": "internal/membership/foundsubject.go",
          "status": "added",
          "additions": 142,
          "deletions": 0,
          "patch": "@@ -0,0 +1,142 @@\n+package membership\n+\n+import (\n+\t\"fmt\"\n+\t\"sort\"\n+\t\"strings\"\n+\n+\tv0 \"github.com/authzed/authzed-go/proto/authzed/api/v0\"\n+\n+\t\"github.com/authzed/spicedb/pkg/tuple\"\n+)\n+\n+// NewFoundSubject creates a new FoundSubject for a subject and a set of its resources.\n+func NewFoundSubject(subject *v0.ObjectAndRelation, resources ...*v0.ObjectAndRelation) FoundSubject {\n+\treturn FoundSubject{subject, tuple.NewONRSet(), tuple.NewONRSet(resources...)}\n+}\n+\n+// FoundSubject contains a single found subject and all the relationships in which that subject\n+// is a member which were found via the ONRs expansion.\n+type FoundSubject struct {\n+\t// subject is the subject found.\n+\tsubject *v0.ObjectAndRelation\n+\n+\t// excludedSubjects are any subjects excluded. Only should be set if subject is a wildcard.\n+\texcludedSubjects *tuple.ONRSet\n+\n+\t// relations are the relations under which the subject lives that informed the locating\n+\t// of this subject for the root ONR.\n+\trelationships *tuple.ONRSet\n+}\n+\n+// Subject returns the Subject of the FoundSubject.\n+func (fs FoundSubject) Subject() *v0.ObjectAndRelation {\n+\treturn fs.subject\n+}\n+\n+// WildcardType returns the object type for the wildcard subject, if this is a wildcard subject.\n+func (fs FoundSubject) WildcardType() (string, bool) {\n+\tif fs.subject.ObjectId == tuple.PublicWildcard {\n+\t\treturn fs.subject.Namespace, true\n+\t}\n+\n+\treturn \"\", false\n+}\n+\n+// ExcludedSubjectsFromWildcard returns those subjects excluded from the wildcard subject.\n+// If not a wildcard subject, returns false.\n+func (fs FoundSubject) ExcludedSubjectsFromWildcard() ([]*v0.ObjectAndRelation, bool) {\n+\tif fs.subject.ObjectId == tuple.PublicWildcard {\n+\t\treturn fs.excludedSubjects.AsSlice(), true\n+\t}\n+\n+\treturn []*v0.ObjectAndRelation{}, false\n+}\n+\n+// Relationships returns all the relationships in which the subject was found as per the expand.\n+func (fs FoundSubject) Relationships() []*v0.ObjectAndRelation {\n+\treturn fs.relationships.AsSlice()\n+}\n+\n+// ToValidationString returns the FoundSubject in a format that is consumable by the validationfile\n+// package.\n+func (fs FoundSubject) ToValidationString() string {\n+\tonrString := tuple.StringONR(fs.Subject())\n+\texcluded, isWildcard := fs.ExcludedSubjectsFromWildcard()\n+\tif isWildcard && len(excluded) > 0 {\n+\t\texcludedONRStrings := make([]string, 0, len(excluded))\n+\t\tfor _, excludedONR := range excluded {\n+\t\t\texcludedONRStrings = append(excludedONRStrings, tuple.StringONR(excludedONR))\n+\t\t}\n+\n+\t\tsort.Strings(excludedONRStrings)\n+\t\treturn fmt.Sprintf(\"%s - {%s}\", onrString, strings.Join(excludedONRStrings, \", \"))\n+\t}\n+\n+\treturn onrString\n+}\n+\n+// union performs merging of two FoundSubject's with the same subject.\n+func (fs FoundSubject) union(other FoundSubject) FoundSubject {\n+\tif toKey(fs.subject) != toKey(other.subject) {\n+\t\tpanic(\"Got wrong found subject to union\")\n+\t}\n+\n+\trelationships := fs.relationships.Union(other.relationships)\n+\tvar excludedSubjects *tuple.ONRSet\n+\n+\t// If a wildcard, then union together excluded subjects.\n+\t_, isWildcard := fs.WildcardType()\n+\tif isWildcard {\n+\t\texcludedSubjects = fs.excludedSubjects.Union(other.excludedSubjects)\n+\t}\n+\n+\treturn FoundSubject{\n+\t\tsubject:          fs.subject,\n+\t\texcludedSubjects: excludedSubjects,\n+\t\trelationships:    relationships,\n+\t}\n+}\n+\n+// intersect performs intersection between two FoundSubject's with the same subject.\n+func (fs FoundSubject) intersect(other FoundSubject) FoundSubject {\n+\tif toKey(fs.subject) != toKey(other.subject) {\n+\t\tpanic(\"Got wrong found subject to intersect\")\n+\t}\n+\n+\trelationships := fs.relationships.Union(other.relationships)\n+\tvar excludedSubjects *tuple.ONRSet\n+\n+\t// If a wildcard, then union together excluded subjects.\n+\t_, isWildcard := fs.WildcardType()\n+\tif isWildcard {\n+\t\texcludedSubjects = fs.excludedSubjects.Union(other.excludedSubjects)\n+\t}\n+\n+\treturn FoundSubject{\n+\t\tsubject:          fs.subject,\n+\t\texcludedSubjects: excludedSubjects,\n+\t\trelationships:    relationships,\n+\t}\n+}\n+\n+// FoundSubjects contains the subjects found for a specific ONR.\n+type FoundSubjects struct {\n+\t// subjects is a map from the Subject ONR (as a string) to the FoundSubject information.\n+\tsubjects map[string]FoundSubject\n+}\n+\n+// ListFound returns a slice of all the FoundSubject's.\n+func (fs FoundSubjects) ListFound() []FoundSubject {\n+\tfound := []FoundSubject{}\n+\tfor _, sub := range fs.subjects {\n+\t\tfound = append(found, sub)\n+\t}\n+\treturn found\n+}\n+\n+// LookupSubject returns the FoundSubject for a matching subject, if any.\n+func (fs FoundSubjects) LookupSubject(subject *v0.ObjectAndRelation) (FoundSubject, bool) {\n+\tfound, ok := fs.subjects[toKey(subject)]\n+\treturn found, ok\n+}"
        },
        {
          "filename": "internal/membership/foundsubject_test.go",
          "status": "added",
          "additions": 62,
          "deletions": 0,
          "patch": "@@ -0,0 +1,62 @@\n+package membership\n+\n+import (\n+\t\"fmt\"\n+\t\"testing\"\n+\n+\t\"github.com/authzed/spicedb/pkg/validationfile\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestToValidationString(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tname     string\n+\t\tfs       FoundSubject\n+\t\texpected string\n+\t}{\n+\t\t{\n+\t\t\t\"basic\",\n+\t\t\tfs(\"user\", \"user1\", \"...\"),\n+\t\t\t\"user:user1\",\n+\t\t},\n+\t\t{\n+\t\t\t\"with exclusion\",\n+\t\t\tfs(\"user\", \"*\", \"...\", ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t\"user:* - {user:user1}\",\n+\t\t},\n+\t\t{\n+\t\t\t\"with some exclusion\",\n+\t\t\tfs(\"user\", \"*\", \"...\",\n+\t\t\t\tONR(\"user\", \"user1\", \"...\"),\n+\t\t\t\tONR(\"user\", \"user2\", \"...\"),\n+\t\t\t\tONR(\"user\", \"user3\", \"...\"),\n+\t\t\t\tONR(\"user\", \"user4\", \"...\"),\n+\t\t\t\tONR(\"user\", \"user5\", \"...\"),\n+\t\t\t),\n+\t\t\t\"user:* - {user:user1, user:user2, user:user3, user:user4, user:user5}\",\n+\t\t},\n+\t\t{\n+\t\t\t\"with many exclusion\",\n+\t\t\tfs(\"user\", \"*\", \"...\",\n+\t\t\t\tONR(\"user\", \"user1\", \"...\"),\n+\t\t\t\tONR(\"user\", \"user2\", \"...\"),\n+\t\t\t\tONR(\"user\", \"user3\", \"...\"),\n+\t\t\t\tONR(\"user\", \"user4\", \"...\"),\n+\t\t\t\tONR(\"user\", \"user5\", \"...\"),\n+\t\t\t\tONR(\"user\", \"user6\", \"...\"),\n+\t\t\t),\n+\t\t\t\"user:* - {user:user1, user:user2, user:user3, user:user4, user:user5, user:user6}\",\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\trequire := require.New(t)\n+\t\t\trequire.Equal(tc.expected, tc.fs.ToValidationString())\n+\n+\t\t\tsub, err := validationfile.ValidationString(fmt.Sprintf(\"[%s]\", tc.expected)).Subject()\n+\t\t\trequire.Nil(err)\n+\t\t\trequire.NotNil(sub)\n+\t\t})\n+\t}\n+}"
        },
        {
          "filename": "internal/membership/membership.go",
          "status": "added",
          "additions": 140,
          "deletions": 0,
          "patch": "@@ -0,0 +1,140 @@\n+package membership\n+\n+import (\n+\t\"fmt\"\n+\n+\tv0 \"github.com/authzed/authzed-go/proto/authzed/api/v0\"\n+\n+\t\"github.com/authzed/spicedb/pkg/tuple\"\n+)\n+\n+// Set represents the set of membership for one or more ONRs, based on expansion\n+// trees.\n+type Set struct {\n+\t// objectsAndRelations is a map from an ONR (as a string) to the subjects found for that ONR.\n+\tobjectsAndRelations map[string]FoundSubjects\n+}\n+\n+// SubjectsByONR returns a map from ONR (as a string) to the FoundSubjects for that ONR.\n+func (ms *Set) SubjectsByONR() map[string]FoundSubjects {\n+\treturn ms.objectsAndRelations\n+}\n+\n+// NewMembershipSet constructs a new membership set.\n+//\n+// NOTE: This is designed solely for the developer API and should *not* be used in any performance\n+// sensitive code.\n+func NewMembershipSet() *Set {\n+\treturn &Set{\n+\t\tobjectsAndRelations: map[string]FoundSubjects{},\n+\t}\n+}\n+\n+// AddExpansion adds the expansion of an ONR to the membership set. Returns false if the ONR was already added.\n+//\n+// NOTE: The expansion tree *should* be the fully recursive expansion.\n+func (ms *Set) AddExpansion(onr *v0.ObjectAndRelation, expansion *v0.RelationTupleTreeNode) (FoundSubjects, bool, error) {\n+\tonrString := tuple.StringONR(onr)\n+\texisting, ok := ms.objectsAndRelations[onrString]\n+\tif ok {\n+\t\treturn existing, false, nil\n+\t}\n+\n+\ttss, err := populateFoundSubjects(onr, expansion)\n+\tif err != nil {\n+\t\treturn FoundSubjects{}, false, err\n+\t}\n+\n+\tfs := tss.ToFoundSubjects()\n+\tms.objectsAndRelations[onrString] = fs\n+\treturn fs, true, nil\n+}\n+\n+// AccessibleExpansionSubjects returns a TrackingSubjectSet representing the set of accessible subjects in the expansion.\n+func AccessibleExpansionSubjects(treeNode *v0.RelationTupleTreeNode) (TrackingSubjectSet, error) {\n+\treturn populateFoundSubjects(treeNode.Expanded, treeNode)\n+}\n+\n+func populateFoundSubjects(rootONR *v0.ObjectAndRelation, treeNode *v0.RelationTupleTreeNode) (TrackingSubjectSet, error) {\n+\tresource := rootONR\n+\tif treeNode.Expanded != nil {\n+\t\tresource = treeNode.Expanded\n+\t}\n+\n+\tswitch typed := treeNode.NodeType.(type) {\n+\tcase *v0.RelationTupleTreeNode_IntermediateNode:\n+\t\tswitch typed.IntermediateNode.Operation {\n+\t\tcase v0.SetOperationUserset_UNION:\n+\t\t\ttoReturn := NewTrackingSubjectSet()\n+\t\t\tfor _, child := range typed.IntermediateNode.ChildNodes {\n+\t\t\t\ttss, err := populateFoundSubjects(resource, child)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, err\n+\t\t\t\t}\n+\n+\t\t\t\ttoReturn.AddFrom(tss)\n+\t\t\t}\n+\t\t\treturn toReturn, nil\n+\n+\t\tcase v0.SetOperationUserset_INTERSECTION:\n+\t\t\tif len(typed.IntermediateNode.ChildNodes) == 0 {\n+\t\t\t\treturn nil, fmt.Errorf(\"Found intersection with no children\")\n+\t\t\t}\n+\n+\t\t\tfirstChildSet, err := populateFoundSubjects(rootONR, typed.IntermediateNode.ChildNodes[0])\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\ttoReturn := NewTrackingSubjectSet()\n+\t\t\ttoReturn.AddFrom(firstChildSet)\n+\n+\t\t\tfor _, child := range typed.IntermediateNode.ChildNodes[1:] {\n+\t\t\t\tchildSet, err := populateFoundSubjects(rootONR, child)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, err\n+\t\t\t\t}\n+\t\t\t\ttoReturn = toReturn.Intersect(childSet)\n+\t\t\t}\n+\t\t\treturn toReturn, nil\n+\n+\t\tcase v0.SetOperationUserset_EXCLUSION:\n+\t\t\tif len(typed.IntermediateNode.ChildNodes) == 0 {\n+\t\t\t\treturn nil, fmt.Errorf(\"Found exclusion with no children\")\n+\t\t\t}\n+\n+\t\t\tfirstChildSet, err := populateFoundSubjects(rootONR, typed.IntermediateNode.ChildNodes[0])\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\ttoReturn := NewTrackingSubjectSet()\n+\t\t\ttoReturn.AddFrom(firstChildSet)\n+\n+\t\t\tfor _, child := range typed.IntermediateNode.ChildNodes[1:] {\n+\t\t\t\tchildSet, err := populateFoundSubjects(rootONR, child)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, err\n+\t\t\t\t}\n+\t\t\t\ttoReturn = toReturn.Exclude(childSet)\n+\t\t\t}\n+\n+\t\t\treturn toReturn, nil\n+\n+\t\tdefault:\n+\t\t\tpanic(\"unknown expand operation\")\n+\t\t}\n+\n+\tcase *v0.RelationTupleTreeNode_LeafNode:\n+\t\ttoReturn := NewTrackingSubjectSet()\n+\t\tfor _, user := range typed.LeafNode.Users {\n+\t\t\tfs := NewFoundSubject(user.GetUserset())\n+\t\t\ttoReturn.Add(fs)\n+\t\t\tfs.relationships.Add(resource)\n+\t\t}\n+\t\treturn toReturn, nil\n+\n+\tdefault:\n+\t\tpanic(\"unknown TreeNode type\")\n+\t}\n+}"
        },
        {
          "filename": "internal/membership/membership_test.go",
          "status": "added",
          "additions": 383,
          "deletions": 0,
          "patch": "@@ -0,0 +1,383 @@\n+package membership\n+\n+import (\n+\t\"sort\"\n+\t\"testing\"\n+\n+\tv0 \"github.com/authzed/authzed-go/proto/authzed/api/v0\"\n+\t\"github.com/stretchr/testify/require\"\n+\n+\t\"github.com/authzed/spicedb/pkg/graph\"\n+\t\"github.com/authzed/spicedb/pkg/testutil\"\n+\t\"github.com/authzed/spicedb/pkg/tuple\"\n+)\n+\n+var (\n+\tONR      = tuple.ObjectAndRelation\n+\tEllipsis = \"...\"\n+)\n+\n+var (\n+\t_this *v0.ObjectAndRelation\n+\n+\tcompanyOwner = graph.Leaf(ONR(\"folder\", \"company\", \"owner\"),\n+\t\ttuple.User(ONR(\"user\", \"owner\", Ellipsis)),\n+\t)\n+\tcompanyEditor = graph.Union(ONR(\"folder\", \"company\", \"editor\"),\n+\t\tgraph.Leaf(_this, tuple.User(ONR(\"user\", \"writer\", Ellipsis))),\n+\t\tcompanyOwner,\n+\t)\n+\n+\tauditorsOwner = graph.Leaf(ONR(\"folder\", \"auditors\", \"owner\"))\n+\n+\tauditorsEditor = graph.Union(ONR(\"folder\", \"auditors\", \"editor\"),\n+\t\tgraph.Leaf(_this),\n+\t\tauditorsOwner,\n+\t)\n+\n+\tauditorsViewerRecursive = graph.Union(ONR(\"folder\", \"auditors\", \"viewer\"),\n+\t\tgraph.Leaf(_this,\n+\t\t\ttuple.User(ONR(\"user\", \"auditor\", \"...\")),\n+\t\t),\n+\t\tauditorsEditor,\n+\t\tgraph.Union(ONR(\"folder\", \"auditors\", \"viewer\")),\n+\t)\n+\n+\tcompanyViewerRecursive = graph.Union(ONR(\"folder\", \"company\", \"viewer\"),\n+\t\tgraph.Union(ONR(\"folder\", \"company\", \"viewer\"),\n+\t\t\tauditorsViewerRecursive,\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n+\t\t\t\ttuple.User(ONR(\"folder\", \"auditors\", \"viewer\")),\n+\t\t\t),\n+\t\t),\n+\t\tcompanyEditor,\n+\t\tgraph.Union(ONR(\"folder\", \"company\", \"viewer\")),\n+\t)\n+)\n+\n+func TestMembershipSetBasic(t *testing.T) {\n+\trequire := require.New(t)\n+\tms := NewMembershipSet()\n+\n+\t// Add some expansion trees.\n+\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"owner\"), companyOwner)\n+\trequire.True(ok)\n+\trequire.NoError(err)\n+\tverifySubjects(t, require, fso, \"user:owner\")\n+\n+\tfse, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"editor\"), companyEditor)\n+\trequire.True(ok)\n+\trequire.NoError(err)\n+\tverifySubjects(t, require, fse, \"user:owner\", \"user:writer\")\n+\n+\tfsv, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), companyViewerRecursive)\n+\trequire.True(ok)\n+\trequire.NoError(err)\n+\tverifySubjects(t, require, fsv, \"folder:auditors#viewer\", \"user:auditor\", \"user:legal\", \"user:owner\", \"user:writer\")\n+}\n+\n+func TestMembershipSetIntersectionBasic(t *testing.T) {\n+\trequire := require.New(t)\n+\tms := NewMembershipSet()\n+\n+\tintersection := graph.Intersection(ONR(\"folder\", \"company\", \"viewer\"),\n+\t\tgraph.Leaf(_this,\n+\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n+\t\t),\n+\t\tgraph.Leaf(_this,\n+\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n+\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n+\t\t),\n+\t)\n+\n+\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), intersection)\n+\trequire.True(ok)\n+\trequire.NoError(err)\n+\tverifySubjects(t, require, fso, \"user:legal\")\n+}\n+\n+func TestMembershipSetExclusion(t *testing.T) {\n+\trequire := require.New(t)\n+\tms := NewMembershipSet()\n+\n+\texclusion := graph.Exclusion(ONR(\"folder\", \"company\", \"viewer\"),\n+\t\tgraph.Leaf(_this,\n+\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n+\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n+\t\t),\n+\t\tgraph.Leaf(_this,\n+\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n+\t\t),\n+\t)\n+\n+\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), exclusion)\n+\trequire.True(ok)\n+\trequire.NoError(err)\n+\tverifySubjects(t, require, fso, \"user:owner\")\n+}\n+\n+func TestMembershipSetExclusionMultiple(t *testing.T) {\n+\trequire := require.New(t)\n+\tms := NewMembershipSet()\n+\n+\texclusion := graph.Exclusion(ONR(\"folder\", \"company\", \"viewer\"),\n+\t\tgraph.Leaf(_this,\n+\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n+\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n+\t\t\ttuple.User(ONR(\"user\", \"third\", \"...\")),\n+\t\t),\n+\t\tgraph.Leaf(_this,\n+\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n+\t\t),\n+\t\tgraph.Leaf(_this,\n+\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n+\t\t),\n+\t)\n+\n+\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), exclusion)\n+\trequire.True(ok)\n+\trequire.NoError(err)\n+\tverifySubjects(t, require, fso, \"user:third\")\n+}\n+\n+func TestMembershipSetExclusionMultipleWithWildcard(t *testing.T) {\n+\trequire := require.New(t)\n+\tms := NewMembershipSet()\n+\n+\texclusion := graph.Exclusion(ONR(\"folder\", \"company\", \"viewer\"),\n+\t\tgraph.Leaf(_this,\n+\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n+\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n+\t\t),\n+\t\tgraph.Leaf(_this,\n+\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n+\t\t),\n+\t\tgraph.Leaf(_this,\n+\t\t\ttuple.User(ONR(\"user\", \"*\", \"...\")),\n+\t\t),\n+\t)\n+\n+\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), exclusion)\n+\trequire.True(ok)\n+\trequire.NoError(err)\n+\tverifySubjects(t, require, fso)\n+}\n+\n+func TestMembershipSetExclusionMultipleMiddle(t *testing.T) {\n+\trequire := require.New(t)\n+\tms := NewMembershipSet()\n+\n+\texclusion := graph.Exclusion(ONR(\"folder\", \"company\", \"viewer\"),\n+\t\tgraph.Leaf(_this,\n+\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n+\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n+\t\t\ttuple.User(ONR(\"user\", \"third\", \"...\")),\n+\t\t),\n+\t\tgraph.Leaf(_this,\n+\t\t\ttuple.User(ONR(\"user\", \"another\", \"...\")),\n+\t\t),\n+\t\tgraph.Leaf(_this,\n+\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n+\t\t),\n+\t)\n+\n+\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), exclusion)\n+\trequire.True(ok)\n+\trequire.NoError(err)\n+\tverifySubjects(t, require, fso, \"user:third\", \"user:legal\")\n+}\n+\n+func TestMembershipSetIntersectionWithOneWildcard(t *testing.T) {\n+\trequire := require.New(t)\n+\tms := NewMembershipSet()\n+\n+\tintersection :=\n+\t\tgraph.Intersection(ONR(\"folder\", \"company\", \"viewer\"),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n+\t\t\t\ttuple.User(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n+\t\t\t),\n+\t\t)\n+\n+\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), intersection)\n+\trequire.True(ok)\n+\trequire.NoError(err)\n+\tverifySubjects(t, require, fso, \"user:legal\")\n+}\n+\n+func TestMembershipSetIntersectionWithAllWildcardLeft(t *testing.T) {\n+\trequire := require.New(t)\n+\tms := NewMembershipSet()\n+\n+\tintersection :=\n+\t\tgraph.Intersection(ONR(\"folder\", \"company\", \"viewer\"),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n+\t\t\t\ttuple.User(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t),\n+\t\t)\n+\n+\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), intersection)\n+\trequire.True(ok)\n+\trequire.NoError(err)\n+\tverifySubjects(t, require, fso, \"user:*\", \"user:owner\")\n+}\n+\n+func TestMembershipSetIntersectionWithAllWildcardRight(t *testing.T) {\n+\trequire := require.New(t)\n+\tms := NewMembershipSet()\n+\n+\tintersection :=\n+\t\tgraph.Intersection(ONR(\"folder\", \"company\", \"viewer\"),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n+\t\t\t\ttuple.User(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t),\n+\t\t)\n+\n+\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), intersection)\n+\trequire.True(ok)\n+\trequire.NoError(err)\n+\tverifySubjects(t, require, fso, \"user:*\", \"user:owner\")\n+}\n+\n+func TestMembershipSetExclusionWithLeftWildcard(t *testing.T) {\n+\trequire := require.New(t)\n+\tms := NewMembershipSet()\n+\n+\texclusion :=\n+\t\tgraph.Exclusion(ONR(\"folder\", \"company\", \"viewer\"),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n+\t\t\t\ttuple.User(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n+\t\t\t),\n+\t\t)\n+\n+\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), exclusion)\n+\trequire.True(ok)\n+\trequire.NoError(err)\n+\tverifySubjects(t, require, fso, \"user:*\", \"user:owner\")\n+}\n+\n+func TestMembershipSetExclusionWithRightWildcard(t *testing.T) {\n+\trequire := require.New(t)\n+\tms := NewMembershipSet()\n+\n+\texclusion :=\n+\t\tgraph.Exclusion(ONR(\"folder\", \"company\", \"viewer\"),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n+\t\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n+\t\t\t),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t),\n+\t\t)\n+\n+\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), exclusion)\n+\trequire.True(ok)\n+\trequire.NoError(err)\n+\tverifySubjects(t, require, fso)\n+}\n+\n+func TestMembershipSetIntersectionWithThreeWildcards(t *testing.T) {\n+\trequire := require.New(t)\n+\tms := NewMembershipSet()\n+\n+\tintersection :=\n+\t\tgraph.Intersection(ONR(\"folder\", \"company\", \"viewer\"),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n+\t\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n+\t\t\t),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t),\n+\t\t)\n+\n+\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), intersection)\n+\trequire.True(ok)\n+\trequire.NoError(err)\n+\tverifySubjects(t, require, fso, \"user:owner\", \"user:legal\")\n+}\n+\n+func TestMembershipSetIntersectionWithOneBranchMissingWildcards(t *testing.T) {\n+\trequire := require.New(t)\n+\tms := NewMembershipSet()\n+\n+\tintersection :=\n+\t\tgraph.Intersection(ONR(\"folder\", \"company\", \"viewer\"),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n+\t\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n+\t\t\t\ttuple.User(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n+\t\t\t),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t),\n+\t\t)\n+\n+\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), intersection)\n+\trequire.True(ok)\n+\trequire.NoError(err)\n+\tverifySubjects(t, require, fso, \"user:owner\")\n+}\n+\n+func TestMembershipSetIntersectionWithTwoBranchesMissingWildcards(t *testing.T) {\n+\trequire := require.New(t)\n+\tms := NewMembershipSet()\n+\n+\tintersection :=\n+\t\tgraph.Intersection(ONR(\"folder\", \"company\", \"viewer\"),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n+\t\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n+\t\t\t),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"another\", \"...\")),\n+\t\t\t),\n+\t\t\tgraph.Leaf(_this,\n+\t\t\t\ttuple.User(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t),\n+\t\t)\n+\n+\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), intersection)\n+\trequire.True(ok)\n+\trequire.NoError(err)\n+\tverifySubjects(t, require, fso)\n+}\n+\n+func verifySubjects(t *testing.T, require *require.Assertions, fs FoundSubjects, expected ...string) {\n+\tfoundSubjects := []*v0.ObjectAndRelation{}\n+\tfor _, found := range fs.ListFound() {\n+\t\tfoundSubjects = append(foundSubjects, found.Subject())\n+\n+\t\t_, ok := fs.LookupSubject(found.Subject())\n+\t\trequire.True(ok, \"Could not find expected subject %s\", found.Subject())\n+\t}\n+\n+\tfound := tuple.StringsONRs(foundSubjects)\n+\tsort.Strings(expected)\n+\tsort.Strings(found)\n+\n+\ttestutil.RequireEqualEmptyNil(t, expected, found)\n+}"
        },
        {
          "filename": "internal/membership/trackingsubjectset.go",
          "status": "added",
          "additions": 185,
          "deletions": 0,
          "patch": "@@ -0,0 +1,185 @@\n+package membership\n+\n+import (\n+\t\"fmt\"\n+\n+\tv0 \"github.com/authzed/authzed-go/proto/authzed/api/v0\"\n+\n+\t\"github.com/authzed/spicedb/pkg/tuple\"\n+)\n+\n+func isWildcard(subject *v0.ObjectAndRelation) bool {\n+\treturn subject.ObjectId == tuple.PublicWildcard\n+}\n+\n+// TrackingSubjectSet defines a set that tracks accessible subjects and their associated\n+// relationships.\n+//\n+// NOTE: This is designed solely for the developer API and testing and should *not* be used in any\n+// performance sensitive code.\n+//\n+// NOTE: Unlike a traditional set, unions between wildcards and a concrete subject will result\n+// in *both* being present in the set, to maintain the proper relationship tracking and reporting\n+// of concrete subjects.\n+//\n+// TODO(jschorr): Once we have stable generics support, break into a standard SubjectSet and\n+// a tracking variant built on top of it.\n+type TrackingSubjectSet map[string]FoundSubject\n+\n+// NewTrackingSubjectSet creates a new TrackingSubjectSet, with optional initial subjects.\n+func NewTrackingSubjectSet(subjects ...FoundSubject) TrackingSubjectSet {\n+\tvar toReturn TrackingSubjectSet = make(map[string]FoundSubject)\n+\ttoReturn.Add(subjects...)\n+\treturn toReturn\n+}\n+\n+// AddFrom adds the subjects found in the other set to this set.\n+func (tss TrackingSubjectSet) AddFrom(otherSet TrackingSubjectSet) {\n+\tfor _, value := range otherSet {\n+\t\ttss.Add(value)\n+\t}\n+}\n+\n+// RemoveFrom removes any subjects found in the other set from this set.\n+func (tss TrackingSubjectSet) RemoveFrom(otherSet TrackingSubjectSet) {\n+\tfor _, otherSAR := range otherSet {\n+\t\ttss.Remove(otherSAR.subject)\n+\t}\n+}\n+\n+// Add adds the given subjects to this set.\n+func (tss TrackingSubjectSet) Add(subjectsAndResources ...FoundSubject) {\n+\ttss.AddWithResources(subjectsAndResources, nil)\n+}\n+\n+// AddWithResources adds the given subjects to this set, with the additional resources appended\n+// for each subject to be included in their relationships.\n+func (tss TrackingSubjectSet) AddWithResources(subjectsAndResources []FoundSubject, additionalResources *tuple.ONRSet) {\n+\tfor _, sar := range subjectsAndResources {\n+\t\tfound, ok := tss[toKey(sar.subject)]\n+\t\tif ok {\n+\t\t\ttss[toKey(sar.subject)] = found.union(sar)\n+\t\t} else {\n+\t\t\ttss[toKey(sar.subject)] = sar\n+\t\t}\n+\t}\n+}\n+\n+// Get returns the found subject in the set, if any.\n+func (tss TrackingSubjectSet) Get(subject *v0.ObjectAndRelation) (FoundSubject, bool) {\n+\tfound, ok := tss[toKey(subject)]\n+\treturn found, ok\n+}\n+\n+// Contains returns true if the set contains the given subject.\n+func (tss TrackingSubjectSet) Contains(subject *v0.ObjectAndRelation) bool {\n+\t_, ok := tss[toKey(subject)]\n+\treturn ok\n+}\n+\n+// removeExact removes the given subject(s) from the set. If the subject is a wildcard, only\n+// the exact matching wildcard will be removed.\n+func (tss TrackingSubjectSet) removeExact(subjects ...*v0.ObjectAndRelation) {\n+\tfor _, subject := range subjects {\n+\t\tdelete(tss, toKey(subject))\n+\t}\n+}\n+\n+// Remove removes the given subject(s) from the set. If the subject is a wildcard, all matching\n+// subjects are removed. If the subject matches a wildcard in the existing set, then it is added\n+// to that wildcard as an exclusion.\n+func (tss TrackingSubjectSet) Remove(subjects ...*v0.ObjectAndRelation) {\n+\tfor _, subject := range subjects {\n+\t\tdelete(tss, toKey(subject))\n+\n+\t\t// Delete any entries matching the wildcard, if applicable.\n+\t\tif isWildcard(subject) {\n+\t\t\t// Remove any subjects matching the type.\n+\t\t\tfor key := range tss {\n+\t\t\t\tcurrent := fromKey(key)\n+\t\t\t\tif current.Namespace == subject.Namespace {\n+\t\t\t\t\tdelete(tss, key)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// Check for any wildcards matching and, if found, add to the exclusion.\n+\t\t\tfor _, existing := range tss {\n+\t\t\t\twildcardType, ok := existing.WildcardType()\n+\t\t\t\tif ok && wildcardType == subject.Namespace {\n+\t\t\t\t\texisting.excludedSubjects.Add(subject)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// WithType returns any subjects in the set with the given object type.\n+func (tss TrackingSubjectSet) WithType(objectType string) []FoundSubject {\n+\ttoReturn := make([]FoundSubject, 0, len(tss))\n+\tfor _, current := range tss {\n+\t\tif current.subject.Namespace == objectType {\n+\t\t\ttoReturn = append(toReturn, current)\n+\t\t}\n+\t}\n+\treturn toReturn\n+}\n+\n+// Exclude returns a new set that contains the items in this set minus those in the other set.\n+func (tss TrackingSubjectSet) Exclude(otherSet TrackingSubjectSet) TrackingSubjectSet {\n+\tnewSet := NewTrackingSubjectSet()\n+\tnewSet.AddFrom(tss)\n+\tnewSet.RemoveFrom(otherSet)\n+\treturn newSet\n+}\n+\n+// Intersect returns a new set that contains the items in this set *and* the other set. Note that\n+// if wildcard is found in *both* sets, it will be returned *along* with any concrete subjects found\n+// on the other side of the intersection.\n+func (tss TrackingSubjectSet) Intersect(otherSet TrackingSubjectSet) TrackingSubjectSet {\n+\tnewSet := NewTrackingSubjectSet()\n+\tfor _, current := range tss {\n+\t\t// Add directly if shared by both.\n+\t\tother, ok := otherSet.Get(current.subject)\n+\t\tif ok {\n+\t\t\tnewSet.Add(current.intersect(other))\n+\t\t}\n+\n+\t\t// If the current is a wildcard, and add any matching.\n+\t\tif isWildcard(current.subject) {\n+\t\t\tnewSet.AddWithResources(otherSet.WithType(current.subject.Namespace), current.relationships)\n+\t\t}\n+\t}\n+\n+\tfor _, current := range otherSet {\n+\t\t// If the current is a wildcard, add any matching.\n+\t\tif isWildcard(current.subject) {\n+\t\t\tnewSet.AddWithResources(tss.WithType(current.subject.Namespace), current.relationships)\n+\t\t}\n+\t}\n+\n+\treturn newSet\n+}\n+\n+// ToSlice returns a slice of all subjects found in the set.\n+func (tss TrackingSubjectSet) ToSlice() []FoundSubject {\n+\ttoReturn := make([]FoundSubject, 0, len(tss))\n+\tfor _, current := range tss {\n+\t\ttoReturn = append(toReturn, current)\n+\t}\n+\treturn toReturn\n+}\n+\n+// ToFoundSubjects returns the set as a FoundSubjects struct.\n+func (tss TrackingSubjectSet) ToFoundSubjects() FoundSubjects {\n+\treturn FoundSubjects{tss}\n+}\n+\n+func toKey(subject *v0.ObjectAndRelation) string {\n+\treturn fmt.Sprintf(\"%s %s %s\", subject.Namespace, subject.ObjectId, subject.Relation)\n+}\n+\n+func fromKey(key string) *v0.ObjectAndRelation {\n+\tsubject := &v0.ObjectAndRelation{}\n+\tfmt.Sscanf(key, \"%s %s %s\", &subject.Namespace, &subject.ObjectId, &subject.Relation)\n+\treturn subject\n+}"
        },
        {
          "filename": "internal/membership/trackingsubjectset_test.go",
          "status": "added",
          "additions": 342,
          "deletions": 0,
          "patch": "@@ -0,0 +1,342 @@\n+package membership\n+\n+import (\n+\t\"testing\"\n+\n+\tv0 \"github.com/authzed/authzed-go/proto/authzed/api/v0\"\n+\t\"github.com/stretchr/testify/require\"\n+\n+\t\"github.com/authzed/spicedb/pkg/tuple\"\n+)\n+\n+func set(subjects ...*v0.ObjectAndRelation) TrackingSubjectSet {\n+\tnewSet := NewTrackingSubjectSet()\n+\tfor _, subject := range subjects {\n+\t\tnewSet.Add(NewFoundSubject(subject))\n+\t}\n+\treturn newSet\n+}\n+\n+func union(firstSet TrackingSubjectSet, sets ...TrackingSubjectSet) TrackingSubjectSet {\n+\tcurrent := firstSet\n+\tfor _, set := range sets {\n+\t\tcurrent.AddFrom(set)\n+\t}\n+\treturn current\n+}\n+\n+func intersect(firstSet TrackingSubjectSet, sets ...TrackingSubjectSet) TrackingSubjectSet {\n+\tcurrent := firstSet\n+\tfor _, set := range sets {\n+\t\tcurrent = current.Intersect(set)\n+\t}\n+\treturn current\n+}\n+\n+func exclude(firstSet TrackingSubjectSet, sets ...TrackingSubjectSet) TrackingSubjectSet {\n+\tcurrent := firstSet\n+\tfor _, set := range sets {\n+\t\tcurrent = current.Exclude(set)\n+\t}\n+\treturn current\n+}\n+\n+func fs(subjectType string, subjectID string, subjectRel string, excludedSubjects ...*v0.ObjectAndRelation) FoundSubject {\n+\treturn FoundSubject{\n+\t\tsubject:          ONR(subjectType, subjectID, subjectRel),\n+\t\texcludedSubjects: tuple.NewONRSet(excludedSubjects...),\n+\t\trelationships:    tuple.NewONRSet(),\n+\t}\n+}\n+\n+func TestTrackingSubjectSet(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tname     string\n+\t\tset      TrackingSubjectSet\n+\t\texpected []FoundSubject\n+\t}{\n+\t\t{\n+\t\t\t\"simple set\",\n+\t\t\tset(ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t[]FoundSubject{fs(\"user\", \"user1\", \"...\")},\n+\t\t},\n+\t\t{\n+\t\t\t\"simple union\",\n+\t\t\tunion(\n+\t\t\t\tset(ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t\tset(ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t\tset(ONR(\"user\", \"user3\", \"...\")),\n+\t\t\t),\n+\t\t\t[]FoundSubject{\n+\t\t\t\tfs(\"user\", \"user1\", \"...\"),\n+\t\t\t\tfs(\"user\", \"user2\", \"...\"),\n+\t\t\t\tfs(\"user\", \"user3\", \"...\"),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"simple intersection\",\n+\t\t\tintersect(\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t\t\t(ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t\t),\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t\t\t(ONR(\"user\", \"user3\", \"...\")),\n+\t\t\t\t),\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t\t\t(ONR(\"user\", \"user4\", \"...\")),\n+\t\t\t\t),\n+\t\t\t),\n+\t\t\t[]FoundSubject{fs(\"user\", \"user2\", \"...\")},\n+\t\t},\n+\t\t{\n+\t\t\t\"empty intersection\",\n+\t\t\tintersect(\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t\t\t(ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t\t),\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"user3\", \"...\")),\n+\t\t\t\t\t(ONR(\"user\", \"user4\", \"...\")),\n+\t\t\t\t),\n+\t\t\t),\n+\t\t\t[]FoundSubject{},\n+\t\t},\n+\t\t{\n+\t\t\t\"simple exclusion\",\n+\t\t\texclude(\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t\t\t(ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t\t),\n+\t\t\t\tset(ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t\tset(ONR(\"user\", \"user3\", \"...\")),\n+\t\t\t),\n+\t\t\t[]FoundSubject{fs(\"user\", \"user1\", \"...\")},\n+\t\t},\n+\t\t{\n+\t\t\t\"empty exclusion\",\n+\t\t\texclude(\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t\t\t(ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t\t),\n+\t\t\t\tset(ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t\tset(ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t),\n+\t\t\t[]FoundSubject{},\n+\t\t},\n+\t\t{\n+\t\t\t\"wildcard left side union\",\n+\t\t\tunion(\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t\t),\n+\t\t\t\tset(ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t),\n+\t\t\t[]FoundSubject{\n+\t\t\t\tfs(\"user\", \"*\", \"...\"),\n+\t\t\t\tfs(\"user\", \"user1\", \"...\"),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"wildcard right side union\",\n+\t\t\tunion(\n+\t\t\t\tset(ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t\t),\n+\t\t\t),\n+\t\t\t[]FoundSubject{\n+\t\t\t\tfs(\"user\", \"*\", \"...\"),\n+\t\t\t\tfs(\"user\", \"user1\", \"...\"),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"wildcard left side exclusion\",\n+\t\t\texclude(\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t\t\t(ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t\t),\n+\t\t\t\tset(ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t),\n+\t\t\t[]FoundSubject{\n+\t\t\t\tfs(\"user\", \"*\", \"...\", ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t\tfs(\"user\", \"user2\", \"...\"),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"wildcard right side exclusion\",\n+\t\t\texclude(\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t\t),\n+\t\t\t\tset(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t),\n+\t\t\t[]FoundSubject{},\n+\t\t},\n+\t\t{\n+\t\t\t\"wildcard right side concrete exclusion\",\n+\t\t\texclude(\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t\t),\n+\t\t\t\tset(ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t),\n+\t\t\t[]FoundSubject{\n+\t\t\t\tfs(\"user\", \"*\", \"...\", ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"wildcard both sides exclusion\",\n+\t\t\texclude(\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t\t\t(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t\t),\n+\t\t\t\tset(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t),\n+\t\t\t[]FoundSubject{},\n+\t\t},\n+\t\t{\n+\t\t\t\"wildcard left side intersection\",\n+\t\t\tintersect(\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t\t\t(ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t\t),\n+\t\t\t\tset(ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t),\n+\t\t\t[]FoundSubject{\n+\t\t\t\tfs(\"user\", \"user1\", \"...\"),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"wildcard right side intersection\",\n+\t\t\tintersect(\n+\t\t\t\tset(ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t\t\t(ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t\t),\n+\t\t\t),\n+\t\t\t[]FoundSubject{\n+\t\t\t\tfs(\"user\", \"user1\", \"...\"),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"wildcard both sides intersection\",\n+\t\t\tintersect(\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t\t\t(ONR(\"user\", \"user1\", \"...\"))),\n+\t\t\t\tset(\n+\t\t\t\t\t(ONR(\"user\", \"*\", \"...\")),\n+\t\t\t\t\t(ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t\t),\n+\t\t\t),\n+\t\t\t[]FoundSubject{\n+\t\t\t\tfs(\"user\", \"*\", \"...\"),\n+\t\t\t\tfs(\"user\", \"user1\", \"...\"),\n+\t\t\t\tfs(\"user\", \"user2\", \"...\"),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"wildcard with exclusions union\",\n+\t\t\tunion(\n+\t\t\t\tNewTrackingSubjectSet(fs(\"user\", \"*\", \"...\", ONR(\"user\", \"user1\", \"...\"))),\n+\t\t\t\tNewTrackingSubjectSet(fs(\"user\", \"*\", \"...\", ONR(\"user\", \"user2\", \"...\"))),\n+\t\t\t),\n+\t\t\t[]FoundSubject{\n+\t\t\t\tfs(\"user\", \"*\", \"...\", ONR(\"user\", \"user1\", \"...\"), ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"wildcard with exclusions intersection\",\n+\t\t\tintersect(\n+\t\t\t\tNewTrackingSubjectSet(fs(\"user\", \"*\", \"...\", ONR(\"user\", \"user1\", \"...\"))),\n+\t\t\t\tNewTrackingSubjectSet(fs(\"user\", \"*\", \"...\", ONR(\"user\", \"user2\", \"...\"))),\n+\t\t\t),\n+\t\t\t[]FoundSubject{\n+\t\t\t\tfs(\"user\", \"*\", \"...\", ONR(\"user\", \"user1\", \"...\"), ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"wildcard with exclusions exclusion\",\n+\t\t\texclude(\n+\t\t\t\tNewTrackingSubjectSet(\n+\t\t\t\t\tfs(\"user\", \"*\", \"...\", ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t\t),\n+\t\t\t\tNewTrackingSubjectSet(fs(\"user\", \"*\", \"...\", ONR(\"user\", \"user2\", \"...\"))),\n+\t\t\t),\n+\t\t\t[]FoundSubject{},\n+\t\t},\n+\t\t{\n+\t\t\t\"wildcard with exclusions excluded user added\",\n+\t\t\texclude(\n+\t\t\t\tNewTrackingSubjectSet(\n+\t\t\t\t\tfs(\"user\", \"*\", \"...\", ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t\t),\n+\t\t\t\tNewTrackingSubjectSet(fs(\"user\", \"user2\", \"...\")),\n+\t\t\t),\n+\t\t\t[]FoundSubject{\n+\t\t\t\tfs(\"user\", \"*\", \"...\", ONR(\"user\", \"user1\", \"...\"), ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"wildcard multiple exclusions\",\n+\t\t\texclude(\n+\t\t\t\tNewTrackingSubjectSet(\n+\t\t\t\t\tfs(\"user\", \"*\", \"...\", ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t\t),\n+\t\t\t\tNewTrackingSubjectSet(fs(\"user\", \"user2\", \"...\")),\n+\t\t\t\tNewTrackingSubjectSet(fs(\"user\", \"user3\", \"...\")),\n+\t\t\t),\n+\t\t\t[]FoundSubject{\n+\t\t\t\tfs(\"user\", \"*\", \"...\", ONR(\"user\", \"user1\", \"...\"), ONR(\"user\", \"user2\", \"...\"), ONR(\"user\", \"user3\", \"...\")),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"intersection of exclusions\",\n+\t\t\tintersect(\n+\t\t\t\tNewTrackingSubjectSet(\n+\t\t\t\t\tfs(\"user\", \"*\", \"...\", ONR(\"user\", \"user1\", \"...\")),\n+\t\t\t\t),\n+\t\t\t\tNewTrackingSubjectSet(\n+\t\t\t\t\tfs(\"user\", \"*\", \"...\", ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t\t),\n+\t\t\t),\n+\t\t\t[]FoundSubject{\n+\t\t\t\tfs(\"user\", \"*\", \"...\", ONR(\"user\", \"user1\", \"...\"), ONR(\"user\", \"user2\", \"...\")),\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\trequire := require.New(t)\n+\n+\t\t\tfor _, fs := range tc.expected {\n+\t\t\t\t_, isWildcard := fs.WildcardType()\n+\t\t\t\tif isWildcard {\n+\t\t\t\t\tfound, ok := tc.set.Get(fs.subject)\n+\t\t\t\t\trequire.True(ok, \"missing expected subject %s\", fs.subject)\n+\n+\t\t\t\t\texpectedExcluded := fs.excludedSubjects.AsSlice()\n+\t\t\t\t\tfoundExcluded := found.excludedSubjects.AsSlice()\n+\t\t\t\t\trequire.Len(fs.excludedSubjects.Subtract(found.excludedSubjects).AsSlice(), 0, \"mismatch on excluded subjects on %s: expected: %s, found: %s\", fs.subject, expectedExcluded, foundExcluded)\n+\t\t\t\t\trequire.Len(found.excludedSubjects.Subtract(fs.excludedSubjects).AsSlice(), 0, \"mismatch on excluded subjects on %s: expected: %s, found: %s\", fs.subject, expectedExcluded, foundExcluded)\n+\t\t\t\t} else {\n+\t\t\t\t\trequire.True(tc.set.Contains(fs.subject), \"missing expected subject %s\", fs.subject)\n+\t\t\t\t}\n+\t\t\t\ttc.set.removeExact(fs.subject)\n+\t\t\t}\n+\n+\t\t\trequire.Len(tc.set, 0)\n+\t\t})\n+\t}\n+}"
        },
        {
          "filename": "internal/services/consistency_test.go",
          "status": "modified",
          "additions": 118,
          "deletions": 51,
          "patch": "@@ -23,12 +23,12 @@ import (\n \t\"github.com/authzed/spicedb/internal/dispatch\"\n \t\"github.com/authzed/spicedb/internal/dispatch/caching\"\n \t\"github.com/authzed/spicedb/internal/dispatch/graph\"\n+\t\"github.com/authzed/spicedb/internal/membership\"\n \t\"github.com/authzed/spicedb/internal/namespace\"\n \tv1 \"github.com/authzed/spicedb/internal/proto/dispatch/v1\"\n \tv0svc \"github.com/authzed/spicedb/internal/services/v0\"\n \tv1svc \"github.com/authzed/spicedb/internal/services/v1\"\n \t\"github.com/authzed/spicedb/internal/testfixtures\"\n-\tgraphpkg \"github.com/authzed/spicedb/pkg/graph\"\n \t\"github.com/authzed/spicedb/pkg/testutil\"\n \t\"github.com/authzed/spicedb/pkg/tuple\"\n \t\"github.com/authzed/spicedb/pkg/validationfile\"\n@@ -133,18 +133,36 @@ func runAssertions(t *testing.T,\n \t\t\trel := tuple.Parse(assertTrueRel)\n \t\t\trequire.NotNil(t, rel)\n \n+\t\t\t// Ensure the assertion passes Check.\n \t\t\tresult, err := tester.Check(context.Background(), rel.ObjectAndRelation, rel.User.GetUserset(), revision)\n \t\t\trequire.NoError(t, err)\n \t\t\trequire.True(t, result, \"Assertion `%s` returned false; true expected\", tuple.String(rel))\n+\n+\t\t\t// Ensure the assertion passes Lookup.\n+\t\t\tresolvedObjectIds, err := tester.Lookup(context.Background(), &v0.RelationReference{\n+\t\t\t\tNamespace: rel.ObjectAndRelation.Namespace,\n+\t\t\t\tRelation:  rel.ObjectAndRelation.Relation,\n+\t\t\t}, rel.User.GetUserset(), revision)\n+\t\t\trequire.NoError(t, err)\n+\t\t\trequire.Contains(t, resolvedObjectIds, rel.ObjectAndRelation.ObjectId, \"Missing object %s in lookup for assertion %s\", rel.ObjectAndRelation, rel)\n \t\t}\n \n \t\tfor _, assertFalseRel := range parsedFile.Assertions.AssertFalse {\n \t\t\trel := tuple.Parse(assertFalseRel)\n \t\t\trequire.NotNil(t, rel)\n \n+\t\t\t// Ensure the assertion does not pass Check.\n \t\t\tresult, err := tester.Check(context.Background(), rel.ObjectAndRelation, rel.User.GetUserset(), revision)\n \t\t\trequire.NoError(t, err)\n \t\t\trequire.False(t, result, \"Assertion `%s` returned true; false expected\", tuple.String(rel))\n+\n+\t\t\t// Ensure the assertion does not pass Lookup.\n+\t\t\tresolvedObjectIds, err := tester.Lookup(context.Background(), &v0.RelationReference{\n+\t\t\t\tNamespace: rel.ObjectAndRelation.Namespace,\n+\t\t\t\tRelation:  rel.ObjectAndRelation.Relation,\n+\t\t\t}, rel.User.GetUserset(), revision)\n+\t\t\trequire.NoError(t, err)\n+\t\t\trequire.NotContains(t, resolvedObjectIds, rel.ObjectAndRelation.ObjectId, \"Found unexpected object %s in lookup for false assertion %s\", rel.ObjectAndRelation, rel)\n \t\t}\n \t}\n }\n@@ -241,12 +259,18 @@ func runConsistencyTests(t *testing.T,\n \t// Collect the set of objects and subjects.\n \tobjectsPerNamespace := setmultimap.New()\n \tsubjects := tuple.NewONRSet()\n+\tsubjectsNoWildcard := tuple.NewONRSet()\n \tfor _, tpl := range fullyResolved.Tuples {\n \t\tobjectsPerNamespace.Put(tpl.ObjectAndRelation.Namespace, tpl.ObjectAndRelation.ObjectId)\n \n \t\tswitch m := tpl.User.UserOneof.(type) {\n \t\tcase *v0.User_Userset:\n+\t\t\t// NOTE: we skip adding wildcards as subjects or object IDs.\n \t\t\tsubjects.Add(m.Userset)\n+\t\t\tif m.Userset.ObjectId != tuple.PublicWildcard {\n+\t\t\t\tobjectsPerNamespace.Put(m.Userset.Namespace, m.Userset.ObjectId)\n+\t\t\t\tsubjectsNoWildcard.Add(m.Userset)\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -263,11 +287,18 @@ func runConsistencyTests(t *testing.T,\n \n \t\t\t\tfor _, objectID := range allObjectIds {\n \t\t\t\t\tobjectIDStr := objectID.(string)\n+\n \t\t\t\t\tonr := &v0.ObjectAndRelation{\n \t\t\t\t\t\tNamespace: nsDef.Name,\n \t\t\t\t\t\tRelation:  relation.Name,\n \t\t\t\t\t\tObjectId:  objectIDStr,\n \t\t\t\t\t}\n+\n+\t\t\t\t\tif subject.ObjectId == tuple.PublicWildcard {\n+\t\t\t\t\t\taccessibilitySet.Set(onr, subject, isWildcard)\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\n \t\t\t\t\thasPermission, err := tester.Check(context.Background(), onr, subject, revision)\n \t\t\t\t\trequire.NoError(t, err)\n \n@@ -293,6 +324,7 @@ func runConsistencyTests(t *testing.T,\n \t\taccessibilitySet:    accessibilitySet,\n \t\tdispatch:            dispatch,\n \t\tsubjects:            subjects,\n+\t\tsubjectsNoWildcard:  subjectsNoWildcard,\n \t\ttester:              tester,\n \t\trevision:            revision,\n \t}\n@@ -325,20 +357,17 @@ func accessibleViaWildcardOnly(t *testing.T, dispatch dispatch.Dispatcher, onr *\n \t})\n \trequire.NoError(t, err)\n \n-\tsubjectsFound := graphpkg.Simplify(resp.TreeNode)\n-\tsubjectsFoundSet := tuple.NewONRSet()\n-\tfor _, subjectUser := range subjectsFound {\n-\t\tsubjectsFoundSet.Add(subjectUser.GetUserset())\n-\t}\n-\n-\treturn !subjectsFoundSet.Has(subject)\n+\tsubjectsFound, err := membership.AccessibleExpansionSubjects(resp.TreeNode)\n+\trequire.NoError(t, err)\n+\treturn !subjectsFound.Contains(subject)\n }\n \n type validationContext struct {\n \tfullyResolved *validationfile.FullyParsedValidationFile\n \n \tobjectsPerNamespace *setmultimap.MultiMap\n \tsubjects            *tuple.ONRSet\n+\tsubjectsNoWildcard  *tuple.ONRSet\n \taccessibilitySet    *accessibilitySet\n \n \tdispatch dispatch.Dispatcher\n@@ -391,12 +420,13 @@ func validateValidation(t *testing.T, dev v0.DeveloperServiceServer, reqContext\n \t\trequire.Nil(t, err)\n \n \t\tfor _, validationStr := range validationStrings {\n-\t\t\tsubjectONR, err := validationStr.Subject()\n+\t\t\tfoundSubject, err := validationStr.Subject()\n \t\t\trequire.Nil(t, err)\n \t\t\trequire.True(t,\n-\t\t\t\tvctx.accessibilitySet.GetIsMember(onr, subjectONR) == isMember,\n+\t\t\t\t(vctx.accessibilitySet.GetIsMember(onr, foundSubject.Subject) == isMember ||\n+\t\t\t\t\tvctx.accessibilitySet.GetIsMember(onr, foundSubject.Subject) == isWildcard),\n \t\t\t\t\"Generated expected relations returned inaccessible member %s for %s\",\n-\t\t\t\ttuple.StringONR(subjectONR),\n+\t\t\t\ttuple.StringONR(foundSubject.Subject),\n \t\t\t\ttuple.StringONR(onr))\n \t\t}\n \t}\n@@ -408,7 +438,7 @@ func validateValidation(t *testing.T, dev v0.DeveloperServiceServer, reqContext\n \tfor _, result := range vctx.accessibilitySet.results {\n \t\tif result.isMember == isMember || result.isMember == isMemberViaWildcard {\n \t\t\ttrueAssertions = append(trueAssertions, fmt.Sprintf(\"%s@%s\", tuple.StringONR(result.object), tuple.StringONR(result.subject)))\n-\t\t} else {\n+\t\t} else if result.isMember == isNotMember {\n \t\t\tfalseAssertions = append(falseAssertions, fmt.Sprintf(\"%s@%s\", tuple.StringONR(result.object), tuple.StringONR(result.subject)))\n \t\t}\n \t}\n@@ -434,7 +464,7 @@ func validateValidation(t *testing.T, dev v0.DeveloperServiceServer, reqContext\n func validateEditChecks(t *testing.T, dev v0.DeveloperServiceServer, reqContext *v0.RequestContext, vctx *validationContext) {\n \tfor _, nsDef := range vctx.fullyResolved.NamespaceDefinitions {\n \t\tfor _, relation := range nsDef.Relation {\n-\t\t\tfor _, subject := range vctx.subjects.AsSlice() {\n+\t\t\tfor _, subject := range vctx.subjectsNoWildcard.AsSlice() {\n \t\t\t\tobjectRelation := &v0.RelationReference{\n \t\t\t\t\tNamespace: nsDef.Name,\n \t\t\t\t\tRelation:  relation.Name,\n@@ -490,7 +520,7 @@ func validateEditChecks(t *testing.T, dev v0.DeveloperServiceServer, reqContext\n func validateLookup(t *testing.T, vctx *validationContext) {\n \tfor _, nsDef := range vctx.fullyResolved.NamespaceDefinitions {\n \t\tfor _, relation := range nsDef.Relation {\n-\t\t\tfor _, subject := range vctx.subjects.AsSlice() {\n+\t\t\tfor _, subject := range vctx.subjectsNoWildcard.AsSlice() {\n \t\t\t\tobjectRelation := &v0.RelationReference{\n \t\t\t\t\tNamespace: nsDef.Name,\n \t\t\t\t\tRelation:  relation.Name,\n@@ -619,38 +649,76 @@ func validateExpansionSubjects(t *testing.T, vctx *validationContext) {\n \t\t\t\t\t})\n \t\t\t\t\tvrequire.NoError(err)\n \n-\t\t\t\t\tsubjectsFound := graphpkg.Simplify(resp.TreeNode)\n-\t\t\t\t\tsubjectsFoundSet := tuple.NewONRSet()\n-\n-\t\t\t\t\tfor _, subjectUser := range subjectsFound {\n-\t\t\t\t\t\tsubjectsFoundSet.Add(subjectUser.GetUserset())\n-\t\t\t\t\t}\n+\t\t\t\t\tsubjectsFoundSet, err := membership.AccessibleExpansionSubjects(resp.TreeNode)\n+\t\t\t\t\tvrequire.NoError(err)\n \n \t\t\t\t\t// Ensure all terminal subjects were found in the expansion.\n-\t\t\t\t\tvrequire.EqualValues(0, accessibleTerminalSubjects.Subtract(subjectsFoundSet).Length())\n+\t\t\t\t\tvrequire.EqualValues(0, len(accessibleTerminalSubjects.Exclude(subjectsFoundSet).ToSlice()), \"Expected %s, Found: %s\", accessibleTerminalSubjects.ToSlice(), subjectsFoundSet.ToSlice())\n \n \t\t\t\t\t// Ensure every subject found matches Check.\n-\t\t\t\t\tfor _, subjectUser := range subjectsFound {\n-\t\t\t\t\t\tsubject := subjectUser.GetUserset()\n+\t\t\t\t\tfor _, foundSubject := range subjectsFoundSet.ToSlice() {\n+\t\t\t\t\t\texcludedSubjects, isWildcard := foundSubject.ExcludedSubjectsFromWildcard()\n \n-\t\t\t\t\t\tisMember, err := vctx.tester.Check(context.Background(),\n-\t\t\t\t\t\t\t&v0.ObjectAndRelation{\n-\t\t\t\t\t\t\t\tNamespace: nsDef.Name,\n-\t\t\t\t\t\t\t\tRelation:  relation.Name,\n-\t\t\t\t\t\t\t\tObjectId:  objectIDStr,\n-\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\tsubject,\n-\t\t\t\t\t\t\tvctx.revision,\n-\t\t\t\t\t\t)\n-\t\t\t\t\t\tvrequire.NoError(err)\n-\t\t\t\t\t\tvrequire.True(\n-\t\t\t\t\t\t\tisMember,\n-\t\t\t\t\t\t\t\"Found Check under Expand failure for relation %s:%s#%s and subject %s\",\n-\t\t\t\t\t\t\tnsDef.Name,\n-\t\t\t\t\t\t\tobjectIDStr,\n-\t\t\t\t\t\t\trelation.Name,\n-\t\t\t\t\t\t\ttuple.StringONR(subject),\n-\t\t\t\t\t\t)\n+\t\t\t\t\t\t// If the subject is a wildcard, then check every matching subject.\n+\t\t\t\t\t\tif isWildcard {\n+\t\t\t\t\t\t\texcludedSubjectsSet := tuple.NewONRSet(excludedSubjects...)\n+\n+\t\t\t\t\t\t\tallSubjectObjectIds, ok := vctx.objectsPerNamespace.Get(foundSubject.Subject().Namespace)\n+\t\t\t\t\t\t\tif !ok {\n+\t\t\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tfor _, subjectID := range allSubjectObjectIds {\n+\t\t\t\t\t\t\t\tsubjectIDStr := subjectID.(string)\n+\t\t\t\t\t\t\t\tlocalSubject := &v0.ObjectAndRelation{\n+\t\t\t\t\t\t\t\t\tNamespace: foundSubject.Subject().Namespace,\n+\t\t\t\t\t\t\t\t\tRelation:  foundSubject.Subject().Relation,\n+\t\t\t\t\t\t\t\t\tObjectId:  subjectIDStr,\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tisMember, err := vctx.tester.Check(context.Background(),\n+\t\t\t\t\t\t\t\t\t&v0.ObjectAndRelation{\n+\t\t\t\t\t\t\t\t\t\tNamespace: nsDef.Name,\n+\t\t\t\t\t\t\t\t\t\tRelation:  relation.Name,\n+\t\t\t\t\t\t\t\t\t\tObjectId:  objectIDStr,\n+\t\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\t\tlocalSubject,\n+\t\t\t\t\t\t\t\t\tvctx.revision,\n+\t\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t\t\tvrequire.NoError(err)\n+\t\t\t\t\t\t\t\tvrequire.Equal(\n+\t\t\t\t\t\t\t\t\t!excludedSubjectsSet.Has(localSubject),\n+\t\t\t\t\t\t\t\t\tisMember,\n+\t\t\t\t\t\t\t\t\t\"Found Check under Expand failure for relation %s:%s#%s and subject %s (checked because of wildcard %s). Expected: %v, Found: %v\",\n+\t\t\t\t\t\t\t\t\tnsDef.Name,\n+\t\t\t\t\t\t\t\t\tobjectIDStr,\n+\t\t\t\t\t\t\t\t\trelation.Name,\n+\t\t\t\t\t\t\t\t\ttuple.StringONR(localSubject),\n+\t\t\t\t\t\t\t\t\ttuple.StringONR(foundSubject.Subject()),\n+\t\t\t\t\t\t\t\t\t!excludedSubjectsSet.Has(localSubject),\n+\t\t\t\t\t\t\t\t\tisMember,\n+\t\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t// Otherwise, check directly.\n+\t\t\t\t\t\t\tisMember, err := vctx.tester.Check(context.Background(),\n+\t\t\t\t\t\t\t\t&v0.ObjectAndRelation{\n+\t\t\t\t\t\t\t\t\tNamespace: nsDef.Name,\n+\t\t\t\t\t\t\t\t\tRelation:  relation.Name,\n+\t\t\t\t\t\t\t\t\tObjectId:  objectIDStr,\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\tfoundSubject.Subject(),\n+\t\t\t\t\t\t\t\tvctx.revision,\n+\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t\tvrequire.NoError(err)\n+\t\t\t\t\t\t\tvrequire.True(\n+\t\t\t\t\t\t\t\tisMember,\n+\t\t\t\t\t\t\t\t\"Found Check under Expand failure for relation %s:%s#%s and subject %s\",\n+\t\t\t\t\t\t\t\tnsDef.Name,\n+\t\t\t\t\t\t\t\tobjectIDStr,\n+\t\t\t\t\t\t\t\trelation.Name,\n+\t\t\t\t\t\t\t\ttuple.StringONR(foundSubject.Subject()),\n+\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t})\n \t\t\t}\n@@ -673,6 +741,7 @@ const (\n \tisNotMember         isMemberStatus = 0\n \tisMember            isMemberStatus = 1\n \tisMemberViaWildcard isMemberStatus = 2\n+\tisWildcard          isMemberStatus = 3\n )\n \n type checkResult struct {\n@@ -707,16 +776,15 @@ func (rs *accessibilitySet) GetIsMember(object *v0.ObjectAndRelation, subject *v\n \t\t}\n \t}\n \n-\tpanic(\"Missing matching result\")\n+\tpanic(fmt.Sprintf(\"Missing matching result for %s %s\", object, subject))\n }\n \n-// AccessibleObjectIDs returns the set of object IDs accessible for the given subject from the given relation on the namespace,\n-// *not* including those accessible solely via wildcard.\n+// AccessibleObjectIDs returns the set of object IDs accessible for the given subject from the given relation on the namespace.\n func (rs *accessibilitySet) AccessibleObjectIDs(namespaceName string, relationName string, subject *v0.ObjectAndRelation) []string {\n \tvar accessibleObjectIDs []string\n \tsubjectStr := tuple.StringONR(subject)\n \tfor _, result := range rs.results {\n-\t\tif result.isMember != isMember {\n+\t\tif result.isMember == isNotMember {\n \t\t\tcontinue\n \t\t}\n \n@@ -727,17 +795,16 @@ func (rs *accessibilitySet) AccessibleObjectIDs(namespaceName string, relationNa\n \treturn accessibleObjectIDs\n }\n \n-// AccessibleTerminalSubjects returns the set of terminal subjects with accessible for the given object on the given relation on the namespace,\n-// *not* including those accessible solely via wildcard.\n-func (rs *accessibilitySet) AccessibleTerminalSubjects(namespaceName string, relationName string, objectIDStr string) *tuple.ONRSet {\n-\taccessibleSubjects := tuple.NewONRSet()\n+// AccessibleTerminalSubjects returns the set of terminal subjects with accessible for the given object on the given relation on the namespace\n+func (rs *accessibilitySet) AccessibleTerminalSubjects(namespaceName string, relationName string, objectIDStr string) membership.TrackingSubjectSet {\n+\taccessibleSubjects := membership.NewTrackingSubjectSet()\n \tfor _, result := range rs.results {\n-\t\tif result.isMember != isMember {\n+\t\tif result.isMember == isNotMember || result.isMember == isWildcard {\n \t\t\tcontinue\n \t\t}\n \n \t\tif result.object.Namespace == namespaceName && result.object.Relation == relationName && result.object.ObjectId == objectIDStr && result.subject.Relation == \"...\" {\n-\t\t\taccessibleSubjects.Add(result.subject)\n+\t\t\taccessibleSubjects.Add(membership.NewFoundSubject(result.subject, result.object))\n \t\t}\n \t}\n \treturn accessibleSubjects"
        },
        {
          "filename": "internal/services/testconfigs/bannedintersectwildcard.yaml",
          "status": "added",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -0,0 +1,25 @@\n+---\n+schema: >-\n+  definition test/user {}\n+\n+  definition test/resource {\n+    relation viewer: test/user | test/user:*\n+    relation banned1: test/user | test/user:*\n+    relation banned2: test/user | test/user:*\n+\n+    permission banned = banned1 & banned2\n+    permission view = viewer - banned\n+  }\n+relationships: |\n+  test/resource:first#viewer@test/user:*\n+  test/resource:first#banned1@test/user:somegal\n+  test/resource:first#banned2@test/user:somegal\n+  test/resource:first#banned1@test/user:anotheruser\n+assertions:\n+  assertTrue:\n+    - \"test/resource:first#view@test/user:anotheruser\"\n+    - \"test/resource:first#view@test/user:editordude\"\n+    - \"test/resource:first#view@test/user:aseconduser\"\n+    - \"test/resource:first#view@test/user:athirduser\"\n+  assertFalse:\n+    - \"test/resource:first#view@test/user:somegal\""
        },
        {
          "filename": "internal/services/testconfigs/simplewildcard.yaml",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+---\n+schema: >-\n+  definition test/user {}\n+\n+  definition test/resource {\n+    relation viewer: test/user | test/user:*\n+  }\n+relationships: |\n+  test/resource:first#viewer@test/user:*\n+  test/resource:first#viewer@test/user:concreteguy\n+assertions:\n+  assertTrue:\n+    - test/resource:first#viewer@test/user:concreteguy\n+    - test/resource:first#viewer@test/user:anotheruser\n+    - test/resource:first#viewer@test/user:aseconduser\n+    - test/resource:first#viewer@test/user:athirduser"
        },
        {
          "filename": "internal/services/testconfigs/wildcardnested.yaml",
          "status": "added",
          "additions": 35,
          "deletions": 0,
          "patch": "@@ -0,0 +1,35 @@\n+---\n+schema: >-\n+  definition test/user {}\n+\n+  definition test/resource {\n+    relation viewer: test/user | test/user:*\n+    relation banned: test/user\n+    relation mustbehere: test/user\n+\n+    permission view = viewer - banned\n+    permission specialview = view & mustbehere\n+  }\n+relationships: |\n+  test/resource:first#viewer@test/user:*\n+  test/resource:first#banned@test/user:bannedguy\n+  test/resource:first#mustbehere@test/user:somegal\n+assertions:\n+  assertTrue:\n+    - test/resource:first#viewer@test/user:somegal\n+    - test/resource:first#viewer@test/user:anotherperson\n+    - test/resource:first#viewer@test/user:thirduser\n+    - test/resource:first#viewer@test/user:bannedguy\n+\n+    - test/resource:first#view@test/user:somegal\n+    - test/resource:first#view@test/user:anotherperson\n+    - test/resource:first#view@test/user:thirduser\n+\n+    - test/resource:first#mustbehere@test/user:somegal\n+    - test/resource:first#specialview@test/user:somegal\n+  assertFalse:\n+    - test/resource:first#view@test/user:bannedguy\n+\n+    - test/resource:first#specialview@test/user:bannedguy\n+    - test/resource:first#specialview@test/user:anotherperson\n+    - test/resource:first#specialview@test/user:thirduser"
        },
        {
          "filename": "internal/services/testconfigs/wildcardwithintersection.yaml",
          "status": "added",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -0,0 +1,25 @@\n+---\n+schema: >-\n+  definition test/user {}\n+\n+  definition test/resource {\n+    relation viewer: test/user | test/user:*\n+    relation reader: test/user | test/user:*\n+\n+    permission view = viewer & reader\n+  }\n+relationships: |\n+  test/resource:first#reader@test/user:*\n+  test/resource:first#viewer@test/user:somegal\n+\n+  test/resource:second#reader@test/user:*\n+  test/resource:second#viewer@test/user:*\n+assertions:\n+  assertTrue:\n+    - test/resource:first#view@test/user:somegal\n+    - test/resource:second#view@test/user:editordude\n+    - test/resource:second#view@test/user:seconduser\n+  assertFalse:\n+    - \"test/resource:first#view@test/user:editordude\"\n+    - \"test/resource:first#view@test/user:anotheruser\"\n+    - \"test/resource:first#view@test/user:aseconduser\""
        },
        {
          "filename": "internal/services/testconfigs/wildcardwithrightsideexclusion.yaml",
          "status": "added",
          "additions": 27,
          "deletions": 0,
          "patch": "@@ -0,0 +1,27 @@\n+---\n+schema: >-\n+  definition test/user {}\n+\n+  definition test/resource {\n+    relation viewer: test/user \n+    relation banned: test/user | test/user:*\n+\n+    permission view = viewer - banned\n+  }\n+relationships: |\n+  test/resource:first#banned@test/user:*\n+  test/resource:first#viewer@test/user:somegal\n+\n+  test/resource:second#banned@test/user:otherperson\n+  test/resource:second#viewer@test/user:somegal\n+assertions:\n+  assertTrue:\n+    - test/resource:first#viewer@test/user:somegal\n+    - test/resource:second#viewer@test/user:somegal\n+  assertFalse:\n+    - \"test/resource:first#view@test/user:editordude\"\n+    - \"test/resource:first#view@test/user:anotheruser\"\n+    - \"test/resource:first#view@test/user:aseconduser\"\n+    - \"test/resource:first#view@test/user:athirduser\"\n+    - \"test/resource:first#view@test/user:somegal\"\n+    - \"test/resource:second#view@test/user:otherperson\""
        },
        {
          "filename": "internal/services/v0/acl.go",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -433,6 +433,9 @@ func rewriteACLError(ctx context.Context, err error) error {\n \tcase errors.As(err, &graph.ErrRequestCanceled{}):\n \t\treturn status.Errorf(codes.Canceled, \"request canceled: %s\", err)\n \n+\tcase errors.As(err, &graph.ErrInvalidArgument{}):\n+\t\treturn status.Errorf(codes.InvalidArgument, \"%s\", err)\n+\n \tcase errors.As(err, &datastore.ErrInvalidRevision{}):\n \t\treturn status.Errorf(codes.OutOfRange, \"invalid zookie: %s\", err)\n "
        },
        {
          "filename": "internal/services/v0/acl_test.go",
          "status": "modified",
          "additions": 17,
          "deletions": 2,
          "patch": "@@ -25,9 +25,9 @@ import (\n \t\"github.com/authzed/spicedb/internal/datastore\"\n \t\"github.com/authzed/spicedb/internal/datastore/memdb\"\n \t\"github.com/authzed/spicedb/internal/dispatch/graph\"\n+\t\"github.com/authzed/spicedb/internal/membership\"\n \t\"github.com/authzed/spicedb/internal/namespace\"\n \ttf \"github.com/authzed/spicedb/internal/testfixtures\"\n-\tg \"github.com/authzed/spicedb/pkg/graph\"\n \tns \"github.com/authzed/spicedb/pkg/namespace\"\n \t\"github.com/authzed/spicedb/pkg/tuple\"\n \t\"github.com/authzed/spicedb/pkg/zookie\"\n@@ -522,6 +522,13 @@ func TestCheck(t *testing.T) {\n \t\t\t\t{ONR(\"user\", \"aasdasd\", \"...\"), false},\n \t\t\t},\n \t\t},\n+\t\t{\n+\t\t\tONR(\"document\", \"somedoc\", \"owner\"),\n+\t\t\tcodes.InvalidArgument,\n+\t\t\t[]checkTest{\n+\t\t\t\t{ONR(\"user\", \"*\", \"...\"), false},\n+\t\t\t},\n+\t\t},\n \t}\n \n \tfor _, delta := range testTimedeltas {\n@@ -643,7 +650,9 @@ func TestExpand(t *testing.T) {\n \t\t\t\t\t\trequire.NotNil(expanded.Revision)\n \t\t\t\t\t\trequire.NotEmpty(expanded.Revision.Token)\n \n-\t\t\t\t\t\trequire.Equal(tc.expandRelatedCount, len(g.Simplify(expanded.TreeNode)))\n+\t\t\t\t\t\tfound, err := membership.AccessibleExpansionSubjects(expanded.TreeNode)\n+\t\t\t\t\t\trequire.NoError(err)\n+\t\t\t\t\t\trequire.Equal(tc.expandRelatedCount, len(found))\n \n \t\t\t\t\t\tdispatchCount, err := responsemeta.GetIntResponseTrailerMetadata(trailer, responsemeta.DispatchedOperationsCount)\n \t\t\t\t\t\trequire.NoError(err)\n@@ -773,6 +782,12 @@ func TestLookup(t *testing.T) {\n \t\t\t[]string{},\n \t\t\tcodes.FailedPrecondition,\n \t\t},\n+\t\t{\n+\t\t\tRR(\"document\", \"viewer_and_editor_derived\"),\n+\t\t\tONR(\"user\", \"*\", \"...\"),\n+\t\t\t[]string{},\n+\t\t\tcodes.InvalidArgument,\n+\t\t},\n \t}\n \n \tfor _, delta := range testTimedeltas {"
        },
        {
          "filename": "internal/services/v0/developer.go",
          "status": "modified",
          "additions": 37,
          "deletions": 4,
          "patch": "@@ -16,9 +16,9 @@ import (\n \t\"google.golang.org/grpc\"\n \t\"google.golang.org/protobuf/encoding/prototext\"\n \n+\t\"github.com/authzed/spicedb/internal/membership\"\n \tv1 \"github.com/authzed/spicedb/internal/proto/dispatch/v1\"\n \t\"github.com/authzed/spicedb/internal/sharederrors\"\n-\t\"github.com/authzed/spicedb/pkg/membership\"\n \t\"github.com/authzed/spicedb/pkg/schemadsl/generator\"\n \t\"github.com/authzed/spicedb/pkg/tuple\"\n \t\"github.com/authzed/spicedb/pkg/validationfile\"\n@@ -331,7 +331,7 @@ func generateValidation(membershipSet *membership.Set) (string, error) {\n \t\tfor _, fs := range foundSubjects.ListFound() {\n \t\t\tstrs = append(strs,\n \t\t\t\tfmt.Sprintf(\"[%s] is %s\",\n-\t\t\t\t\ttuple.StringONR(fs.Subject()),\n+\t\t\t\t\tfs.ToValidationString(),\n \t\t\t\t\tstrings.Join(wrapRelationships(tuple.StringsONRs(fs.Relationships())), \"/\"),\n \t\t\t\t))\n \t\t}\n@@ -425,7 +425,7 @@ func validateSubjects(onr *v0.ObjectAndRelation, fs membership.FoundSubjects, va\n \t// Verify that every referenced subject is found in the membership.\n \tencounteredSubjects := map[string]struct{}{}\n \tfor _, validationString := range validationStrings {\n-\t\tsubjectONR, err := validationString.Subject()\n+\t\texpectedSubject, err := validationString.Subject()\n \t\tif err != nil {\n \t\t\tfailures = append(failures, &v0.DeveloperError{\n \t\t\t\tMessage: fmt.Sprintf(\"For object and permission/relation `%s`, %s\", tuple.StringONR(onr), err.Error()),\n@@ -436,10 +436,11 @@ func validateSubjects(onr *v0.ObjectAndRelation, fs membership.FoundSubjects, va\n \t\t\tcontinue\n \t\t}\n \n-\t\tif subjectONR == nil {\n+\t\tif expectedSubject == nil {\n \t\t\tcontinue\n \t\t}\n \n+\t\tsubjectONR := expectedSubject.Subject\n \t\tencounteredSubjects[tuple.StringONR(subjectONR)] = struct{}{}\n \n \t\texpectedRelationships, err := validationString.ONRS()\n@@ -482,6 +483,38 @@ func validateSubjects(onr *v0.ObjectAndRelation, fs membership.FoundSubjects, va\n \t\t\t\tContext: string(validationString),\n \t\t\t})\n \t\t}\n+\n+\t\t// Verify exclusions are the same, if any.\n+\t\tfoundExcludedSubjects, isWildcard := subject.ExcludedSubjectsFromWildcard()\n+\t\texpectedExcludedSubjects := expectedSubject.Exceptions\n+\t\tif isWildcard {\n+\t\t\texpectedExcludedONRStrings := tuple.StringsONRs(expectedExcludedSubjects)\n+\t\t\tfoundExcludedONRStrings := tuple.StringsONRs(foundExcludedSubjects)\n+\t\t\tif !cmp.Equal(expectedExcludedONRStrings, foundExcludedONRStrings) {\n+\t\t\t\tfailures = append(failures, &v0.DeveloperError{\n+\t\t\t\t\tMessage: fmt.Sprintf(\"For object and permission/relation `%s`, found different excluded subjects for subject `%s`: Specified: `%s`, Computed: `%s`\",\n+\t\t\t\t\t\ttuple.StringONR(onr),\n+\t\t\t\t\t\ttuple.StringONR(subjectONR),\n+\t\t\t\t\t\tstrings.Join(wrapRelationships(expectedExcludedONRStrings), \", \"),\n+\t\t\t\t\t\tstrings.Join(wrapRelationships(foundExcludedONRStrings), \", \"),\n+\t\t\t\t\t),\n+\t\t\t\t\tSource:  v0.DeveloperError_VALIDATION_YAML,\n+\t\t\t\t\tKind:    v0.DeveloperError_MISSING_EXPECTED_RELATIONSHIP,\n+\t\t\t\t\tContext: string(validationString),\n+\t\t\t\t})\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif len(expectedExcludedSubjects) > 0 {\n+\t\t\t\tfailures = append(failures, &v0.DeveloperError{\n+\t\t\t\t\tMessage: fmt.Sprintf(\"For object and permission/relation `%s`, found unexpected excluded subjects\",\n+\t\t\t\t\t\ttuple.StringONR(onr),\n+\t\t\t\t\t),\n+\t\t\t\t\tSource:  v0.DeveloperError_VALIDATION_YAML,\n+\t\t\t\t\tKind:    v0.DeveloperError_EXTRA_RELATIONSHIP_FOUND,\n+\t\t\t\t\tContext: string(validationString),\n+\t\t\t\t})\n+\t\t\t}\n+\t\t}\n \t}\n \n \t// Verify that every subject found was referenced."
        },
        {
          "filename": "internal/services/v0/developer_test.go",
          "status": "modified",
          "additions": 53,
          "deletions": 0,
          "patch": "@@ -634,6 +634,59 @@ assertFalse:\n \t\t\t`document:somedoc#view:\n - '[user:*] is <document:somedoc#viewer>'\n - '[user:jimmy] is <document:somedoc#writer>'\n+`,\n+\t\t},\n+\t\t{\n+\t\t\t\"wildcard exclusion\",\n+\t\t\t`\n+\t\t   \t\t\tdefinition user {}\n+\t\t   \t\t\tdefinition document {\n+\t\t   \t\t\t\trelation banned: user\n+\t\t   \t\t\t\trelation viewer: user | user:*\n+\t\t   \t\t\t\tpermission view = viewer - banned\n+\t\t   \t\t\t}\n+\t\t   \t\t\t`,\n+\t\t\t[]*v0.RelationTuple{\n+\t\t\t\ttuple.MustParse(\"document:somedoc#banned@user:jimmy\"),\n+\t\t\t\ttuple.MustParse(\"document:somedoc#viewer@user:*\"),\n+\t\t\t},\n+\t\t\t`\"document:somedoc#view\":\n+- \"[user:* - {user:jimmy}] is <document:somedoc#viewer>\"`,\n+\t\t\t`assertTrue:\n+- document:somedoc#view@user:somegal\n+assertFalse:\n+- document:somedoc#view@user:jimmy`,\n+\t\t\tnil,\n+\t\t\t`document:somedoc#view:\n+- '[user:* - {user:jimmy}] is <document:somedoc#viewer>'\n+`,\n+\t\t},\n+\t\t{\n+\t\t\t\"wildcard exclusion under intersection\",\n+\t\t\t`\n+\t\t   \t\t\tdefinition user {}\n+\t\t   \t\t\tdefinition document {\n+\t\t   \t\t\t\trelation banned: user\n+\t\t   \t\t\t\trelation viewer: user | user:*\n+\t\t   \t\t\t\trelation other: user\n+\t\t   \t\t\t\tpermission view = (viewer - banned) & (viewer - other)\n+\t\t   \t\t\t}\n+\t\t   \t\t\t`,\n+\t\t\t[]*v0.RelationTuple{\n+\t\t\t\ttuple.MustParse(\"document:somedoc#other@user:sarah\"),\n+\t\t\t\ttuple.MustParse(\"document:somedoc#banned@user:jimmy\"),\n+\t\t\t\ttuple.MustParse(\"document:somedoc#viewer@user:*\"),\n+\t\t\t},\n+\t\t\t`\"document:somedoc#view\":\n+- \"[user:* - {user:jimmy}] is <document:somedoc#viewer>\"`,\n+\t\t\t`assertTrue:\n+- document:somedoc#view@user:somegal\n+assertFalse:\n+- document:somedoc#view@user:jimmy\n+- document:somedoc#view@user:sarah`,\n+\t\t\tnil,\n+\t\t\t`document:somedoc#view:\n+- '[user:* - {user:jimmy, user:sarah}] is <document:somedoc#viewer>'\n `,\n \t\t},\n \t}"
        },
        {
          "filename": "internal/services/v1/permissions_test.go",
          "status": "modified",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -228,6 +228,13 @@ func TestCheckPermissions(t *testing.T) {\n \t\t\tv1.CheckPermissionResponse_PERMISSIONSHIP_UNSPECIFIED,\n \t\t\tcodes.InvalidArgument,\n \t\t},\n+\t\t{\n+\t\t\tobj(\"document\", \"something\"),\n+\t\t\t\"viewer\",\n+\t\t\tsub(\"user\", \"*\", \"\"),\n+\t\t\tv1.CheckPermissionResponse_PERMISSIONSHIP_UNSPECIFIED,\n+\t\t\tcodes.InvalidArgument,\n+\t\t},\n \t}\n \n \tfor _, delta := range testTimedeltas {\n@@ -390,6 +397,12 @@ func TestLookupResources(t *testing.T) {\n \t\t\t[]string{},\n \t\t\tcodes.FailedPrecondition,\n \t\t},\n+\t\t{\n+\t\t\t\"document\", \"viewer_and_editor_derived\",\n+\t\t\tsub(\"user\", \"*\", \"\"),\n+\t\t\t[]string{},\n+\t\t\tcodes.InvalidArgument,\n+\t\t},\n \t}\n \n \tfor _, delta := range testTimedeltas {"
        },
        {
          "filename": "internal/services/v1/relationships.go",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -207,7 +207,7 @@ func (ps *permissionServer) WriteRelationships(ctx context.Context, req *v1.Writ\n \t\t\tif isAllowed != namespace.PublicSubjectAllowed {\n \t\t\t\treturn nil, status.Errorf(\n \t\t\t\t\tcodes.InvalidArgument,\n-\t\t\t\t\t\"wildcardsubjects of type %s are not allowed on %v\",\n+\t\t\t\t\t\"wildcard subjects of type %s are not allowed on %v\",\n \t\t\t\t\tupdate.Relationship.Subject.Object.ObjectType,\n \t\t\t\t\ttuple.StringObjectRef(update.Relationship.Resource),\n \t\t\t\t)\n@@ -275,6 +275,9 @@ func rewritePermissionsError(ctx context.Context, err error) error {\n \tcase errors.As(err, &datastore.ErrPreconditionFailed{}):\n \t\treturn status.Errorf(codes.FailedPrecondition, \"failed precondition: %s\", err)\n \n+\tcase errors.As(err, &graph.ErrInvalidArgument{}):\n+\t\treturn status.Errorf(codes.InvalidArgument, \"%s\", err)\n+\n \tcase errors.As(err, &graph.ErrRequestCanceled{}):\n \t\treturn status.Errorf(codes.Canceled, \"request canceled: %s\", err)\n "
        },
        {
          "filename": "pkg/graph/tree.go",
          "status": "modified",
          "additions": 4,
          "deletions": 111,
          "patch": "@@ -1,81 +1,10 @@\n package graph\n \n import (\n-\t\"fmt\"\n-\n \tv0 \"github.com/authzed/authzed-go/proto/authzed/api/v0\"\n )\n \n-func Simplify(node *v0.RelationTupleTreeNode) []*v0.User {\n-\tswitch typed := node.NodeType.(type) {\n-\tcase *v0.RelationTupleTreeNode_IntermediateNode:\n-\t\tswitch typed.IntermediateNode.Operation {\n-\t\tcase v0.SetOperationUserset_UNION:\n-\t\t\treturn SimplifyUnion(typed.IntermediateNode.ChildNodes)\n-\t\tcase v0.SetOperationUserset_INTERSECTION:\n-\t\t\treturn SimplifyIntersection(typed.IntermediateNode.ChildNodes)\n-\t\tcase v0.SetOperationUserset_EXCLUSION:\n-\t\t\treturn SimplifyExclusion(typed.IntermediateNode.ChildNodes)\n-\t\t}\n-\tcase *v0.RelationTupleTreeNode_LeafNode:\n-\t\tvar toReturn UserSet = make(map[string]struct{})\n-\t\tfor _, usr := range typed.LeafNode.Users {\n-\t\t\ttoReturn.Add(usr)\n-\t\t}\n-\t\treturn toReturn.ToSlice()\n-\t}\n-\treturn nil\n-}\n-\n-func SimplifyUnion(children []*v0.RelationTupleTreeNode) []*v0.User {\n-\tvar toReturn UserSet = make(map[string]struct{})\n-\tfor _, child := range children {\n-\t\ttoReturn.Add(Simplify(child)...)\n-\t}\n-\treturn toReturn.ToSlice()\n-}\n-\n-func SimplifyIntersection(children []*v0.RelationTupleTreeNode) []*v0.User {\n-\tfirstChildChildren := Simplify(children[0])\n-\n-\tif len(children) == 1 {\n-\t\treturn firstChildChildren\n-\t}\n-\n-\tvar inOthers UserSet = make(map[string]struct{})\n-\tinOthers.Add(SimplifyIntersection(children[1:])...)\n-\n-\tmaxChildren := len(firstChildChildren)\n-\tif len(inOthers) < maxChildren {\n-\t\tmaxChildren = len(inOthers)\n-\t}\n-\n-\ttoReturn := make([]*v0.User, 0, maxChildren)\n-\tfor _, child := range firstChildChildren {\n-\t\tif inOthers.Contains(child) {\n-\t\t\ttoReturn = append(toReturn, child)\n-\t\t}\n-\t}\n-\n-\treturn toReturn\n-}\n-\n-func SimplifyExclusion(children []*v0.RelationTupleTreeNode) []*v0.User {\n-\tfirstChildChildren := Simplify(children[0])\n-\n-\tif len(children) == 1 || len(firstChildChildren) == 0 {\n-\t\treturn firstChildChildren\n-\t}\n-\n-\tvar toReturn UserSet = make(map[string]struct{})\n-\ttoReturn.Add(firstChildChildren...)\n-\tfor _, child := range children[1:] {\n-\t\ttoReturn.Remove(Simplify(child)...)\n-\t}\n-\n-\treturn toReturn.ToSlice()\n-}\n-\n+// Leaf constructs a RelationTupleTreeNode leaf.\n func Leaf(start *v0.ObjectAndRelation, children ...*v0.User) *v0.RelationTupleTreeNode {\n \treturn &v0.RelationTupleTreeNode{\n \t\tNodeType: &v0.RelationTupleTreeNode_LeafNode{\n@@ -103,53 +32,17 @@ func setResult(\n \t}\n }\n \n+// Union constructs a RelationTupleTreeNode union operation.\n func Union(start *v0.ObjectAndRelation, children ...*v0.RelationTupleTreeNode) *v0.RelationTupleTreeNode {\n \treturn setResult(v0.SetOperationUserset_UNION, start, children)\n }\n \n+// Intersection constructs a RelationTupleTreeNode intersection operation.\n func Intersection(start *v0.ObjectAndRelation, children ...*v0.RelationTupleTreeNode) *v0.RelationTupleTreeNode {\n \treturn setResult(v0.SetOperationUserset_INTERSECTION, start, children)\n }\n \n+// Exclusion constructs a RelationTupleTreeNode exclusion operation.\n func Exclusion(start *v0.ObjectAndRelation, children ...*v0.RelationTupleTreeNode) *v0.RelationTupleTreeNode {\n \treturn setResult(v0.SetOperationUserset_EXCLUSION, start, children)\n }\n-\n-type UserSet map[string]struct{}\n-\n-func (us UserSet) Add(users ...*v0.User) {\n-\tfor _, usr := range users {\n-\t\tus[toKey(usr)] = struct{}{}\n-\t}\n-}\n-\n-func (us UserSet) Contains(usr *v0.User) bool {\n-\t_, ok := us[toKey(usr)]\n-\treturn ok\n-}\n-\n-func (us UserSet) Remove(users ...*v0.User) {\n-\tfor _, usr := range users {\n-\t\tdelete(us, toKey(usr))\n-\t}\n-}\n-\n-func (us UserSet) ToSlice() []*v0.User {\n-\ttoReturn := make([]*v0.User, 0, len(us))\n-\tfor key := range us {\n-\t\ttoReturn = append(toReturn, fromKey(key))\n-\t}\n-\treturn toReturn\n-}\n-\n-func toKey(usr *v0.User) string {\n-\treturn fmt.Sprintf(\"%s %s %s\", usr.GetUserset().Namespace, usr.GetUserset().ObjectId, usr.GetUserset().Relation)\n-}\n-\n-func fromKey(key string) *v0.User {\n-\tuserset := &v0.ObjectAndRelation{}\n-\tfmt.Sscanf(key, \"%s %s %s\", &userset.Namespace, &userset.ObjectId, &userset.Relation)\n-\treturn &v0.User{\n-\t\tUserOneof: &v0.User_Userset{Userset: userset},\n-\t}\n-}"
        },
        {
          "filename": "pkg/graph/tree_test.go",
          "status": "removed",
          "additions": 0,
          "deletions": 112,
          "patch": "@@ -1,112 +0,0 @@\n-package graph\n-\n-import (\n-\t\"testing\"\n-\n-\tv0 \"github.com/authzed/authzed-go/proto/authzed/api/v0\"\n-\t\"github.com/stretchr/testify/require\"\n-\n-\t\"github.com/authzed/spicedb/pkg/tuple\"\n-)\n-\n-var ONR = tuple.ObjectAndRelation\n-\n-func TestSimplify(t *testing.T) {\n-\ttestCases := []struct {\n-\t\tname     string\n-\t\ttree     *v0.RelationTupleTreeNode\n-\t\texpected []*v0.ObjectAndRelation\n-\t}{\n-\t\t{\n-\t\t\t\"simple leaf\",\n-\t\t\tLeaf(nil, tuple.User(ONR(\"user\", \"user1\", \"...\"))),\n-\t\t\t[]*v0.ObjectAndRelation{ONR(\"user\", \"user1\", \"...\")},\n-\t\t},\n-\t\t{\n-\t\t\t\"simple union\",\n-\t\t\tUnion(nil,\n-\t\t\t\tLeaf(nil, tuple.User(ONR(\"user\", \"user1\", \"...\"))),\n-\t\t\t\tLeaf(nil, tuple.User(ONR(\"user\", \"user2\", \"...\"))),\n-\t\t\t\tLeaf(nil, tuple.User(ONR(\"user\", \"user3\", \"...\"))),\n-\t\t\t),\n-\t\t\t[]*v0.ObjectAndRelation{\n-\t\t\t\tONR(\"user\", \"user1\", \"...\"),\n-\t\t\t\tONR(\"user\", \"user2\", \"...\"),\n-\t\t\t\tONR(\"user\", \"user3\", \"...\"),\n-\t\t\t},\n-\t\t},\n-\t\t{\n-\t\t\t\"simple intersection\",\n-\t\t\tIntersection(nil,\n-\t\t\t\tLeaf(nil,\n-\t\t\t\t\ttuple.User(ONR(\"user\", \"user1\", \"...\")),\n-\t\t\t\t\ttuple.User(ONR(\"user\", \"user2\", \"...\")),\n-\t\t\t\t),\n-\t\t\t\tLeaf(nil,\n-\t\t\t\t\ttuple.User(ONR(\"user\", \"user2\", \"...\")),\n-\t\t\t\t\ttuple.User(ONR(\"user\", \"user3\", \"...\")),\n-\t\t\t\t),\n-\t\t\t\tLeaf(nil,\n-\t\t\t\t\ttuple.User(ONR(\"user\", \"user2\", \"...\")),\n-\t\t\t\t\ttuple.User(ONR(\"user\", \"user4\", \"...\")),\n-\t\t\t\t),\n-\t\t\t),\n-\t\t\t[]*v0.ObjectAndRelation{ONR(\"user\", \"user2\", \"...\")},\n-\t\t},\n-\t\t{\n-\t\t\t\"empty intersection\",\n-\t\t\tIntersection(nil,\n-\t\t\t\tLeaf(nil,\n-\t\t\t\t\ttuple.User(ONR(\"user\", \"user1\", \"...\")),\n-\t\t\t\t\ttuple.User(ONR(\"user\", \"user2\", \"...\")),\n-\t\t\t\t),\n-\t\t\t\tLeaf(nil,\n-\t\t\t\t\ttuple.User(ONR(\"user\", \"user3\", \"...\")),\n-\t\t\t\t\ttuple.User(ONR(\"user\", \"user4\", \"...\")),\n-\t\t\t\t),\n-\t\t\t),\n-\t\t\t[]*v0.ObjectAndRelation{},\n-\t\t},\n-\t\t{\n-\t\t\t\"simple exclusion\",\n-\t\t\tExclusion(nil,\n-\t\t\t\tLeaf(nil,\n-\t\t\t\t\ttuple.User(ONR(\"user\", \"user1\", \"...\")),\n-\t\t\t\t\ttuple.User(ONR(\"user\", \"user2\", \"...\")),\n-\t\t\t\t),\n-\t\t\t\tLeaf(nil, tuple.User(ONR(\"user\", \"user2\", \"...\"))),\n-\t\t\t\tLeaf(nil, tuple.User(ONR(\"user\", \"user3\", \"...\"))),\n-\t\t\t),\n-\t\t\t[]*v0.ObjectAndRelation{ONR(\"user\", \"user1\", \"...\")},\n-\t\t},\n-\t\t{\n-\t\t\t\"empty exclusion\",\n-\t\t\tExclusion(nil,\n-\t\t\t\tLeaf(nil,\n-\t\t\t\t\ttuple.User(ONR(\"user\", \"user1\", \"...\")),\n-\t\t\t\t\ttuple.User(ONR(\"user\", \"user2\", \"...\")),\n-\t\t\t\t),\n-\t\t\t\tLeaf(nil, tuple.User(ONR(\"user\", \"user1\", \"...\"))),\n-\t\t\t\tLeaf(nil, tuple.User(ONR(\"user\", \"user2\", \"...\"))),\n-\t\t\t),\n-\t\t\t[]*v0.ObjectAndRelation{},\n-\t\t},\n-\t}\n-\n-\tfor _, tc := range testCases {\n-\t\tt.Run(tc.name, func(t *testing.T) {\n-\t\t\trequire := require.New(t)\n-\n-\t\t\tvar simplified UserSet = make(map[string]struct{})\n-\t\t\tsimplified.Add(Simplify(tc.tree)...)\n-\n-\t\t\tfor _, onr := range tc.expected {\n-\t\t\t\tusr := tuple.User(onr)\n-\t\t\t\trequire.True(simplified.Contains(usr))\n-\t\t\t\tsimplified.Remove(usr)\n-\t\t\t}\n-\n-\t\t\trequire.Len(simplified, 0)\n-\t\t})\n-\t}\n-}"
        },
        {
          "filename": "pkg/membership/membership.go",
          "status": "removed",
          "additions": 0,
          "deletions": 238,
          "patch": "@@ -1,238 +0,0 @@\n-package membership\n-\n-import (\n-\t\"fmt\"\n-\n-\tv0 \"github.com/authzed/authzed-go/proto/authzed/api/v0\"\n-\n-\t\"github.com/authzed/spicedb/pkg/tuple\"\n-)\n-\n-// Set represents the set of membership for one or more ONRs, based on expansion\n-// trees.\n-type Set struct {\n-\t// objectsAndRelations is a map from an ONR (as a string) to the subjects found for that ONR.\n-\tobjectsAndRelations map[string]FoundSubjects\n-}\n-\n-// SubjectsByONR returns a map from ONR (as a string) to the FoundSubjects for that ONR.\n-func (ms *Set) SubjectsByONR() map[string]FoundSubjects {\n-\treturn ms.objectsAndRelations\n-}\n-\n-// FoundSubjects contains the subjects found for a specific ONR.\n-type FoundSubjects struct {\n-\t// subjects is a map from the Subject ONR (as a string) to the FoundSubject information.\n-\tsubjects map[string]FoundSubject\n-}\n-\n-// ListFound returns a slice of all the FoundSubject's.\n-func (fs FoundSubjects) ListFound() []FoundSubject {\n-\tfound := []FoundSubject{}\n-\tfor _, sub := range fs.subjects {\n-\t\tfound = append(found, sub)\n-\t}\n-\treturn found\n-}\n-\n-// LookupSubject returns the FoundSubject for a matching subject, if any.\n-func (fs FoundSubjects) LookupSubject(subject *v0.ObjectAndRelation) (FoundSubject, bool) {\n-\tonrString := tuple.StringONR(subject)\n-\tfound, ok := fs.subjects[onrString]\n-\treturn found, ok\n-}\n-\n-// FoundSubject contains a single found subject and all the relationships in which that subject\n-// is a member which were found via the ONRs expansion.\n-type FoundSubject struct {\n-\t// subject is the subject found.\n-\tsubject *v0.ObjectAndRelation\n-\n-\t// relations are the relations under which the subject lives that informed the locating\n-\t// of this subject for the root ONR.\n-\trelationships *tuple.ONRSet\n-}\n-\n-// Subject returns the Subject of the FoundSubject.\n-func (fs FoundSubject) Subject() *v0.ObjectAndRelation {\n-\treturn fs.subject\n-}\n-\n-// Relationships returns all the relationships in which the subject was found as per the expand.\n-func (fs FoundSubject) Relationships() []*v0.ObjectAndRelation {\n-\treturn fs.relationships.AsSlice()\n-}\n-\n-// NewMembershipSet constructs a new membership set.\n-//\n-// NOTE: This is designed solely for the developer API and should *not* be used in any performance\n-// sensitive code.\n-func NewMembershipSet() *Set {\n-\treturn &Set{\n-\t\tobjectsAndRelations: map[string]FoundSubjects{},\n-\t}\n-}\n-\n-// AddExpansion adds the expansion of an ONR to the membership set. Returns false if the ONR was already added.\n-//\n-// NOTE: The expansion tree *should* be the fully recursive expansion.\n-func (ms *Set) AddExpansion(onr *v0.ObjectAndRelation, expansion *v0.RelationTupleTreeNode) (FoundSubjects, bool, error) {\n-\tonrString := tuple.StringONR(onr)\n-\texisting, ok := ms.objectsAndRelations[onrString]\n-\tif ok {\n-\t\treturn existing, false, nil\n-\t}\n-\n-\tfoundSubjectsMap := map[string]FoundSubject{}\n-\terr := populateFoundSubjects(foundSubjectsMap, onr, expansion)\n-\tif err != nil {\n-\t\treturn FoundSubjects{}, false, err\n-\t}\n-\n-\tfs := FoundSubjects{\n-\t\tsubjects: foundSubjectsMap,\n-\t}\n-\tms.objectsAndRelations[onrString] = fs\n-\treturn fs, true, nil\n-}\n-\n-func populateFoundSubjects(foundSubjectsMap map[string]FoundSubject, rootONR *v0.ObjectAndRelation, treeNode *v0.RelationTupleTreeNode) error {\n-\trelationship := rootONR\n-\tif treeNode.Expanded != nil {\n-\t\trelationship = treeNode.Expanded\n-\t}\n-\n-\tswitch typed := treeNode.NodeType.(type) {\n-\tcase *v0.RelationTupleTreeNode_IntermediateNode:\n-\t\tswitch typed.IntermediateNode.Operation {\n-\t\tcase v0.SetOperationUserset_UNION:\n-\t\t\tfor _, child := range typed.IntermediateNode.ChildNodes {\n-\t\t\t\terr := populateFoundSubjects(foundSubjectsMap, rootONR, child)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\tcase v0.SetOperationUserset_INTERSECTION:\n-\t\t\tif len(typed.IntermediateNode.ChildNodes) == 0 {\n-\t\t\t\treturn fmt.Errorf(\"found intersection with no children\")\n-\t\t\t}\n-\n-\t\t\tfsm := map[string]FoundSubject{}\n-\t\t\terr := populateFoundSubjects(fsm, rootONR, typed.IntermediateNode.ChildNodes[0])\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\n-\t\t\tsubjectset := newSubjectSet()\n-\t\t\tsubjectset.union(fsm)\n-\n-\t\t\tfor _, child := range typed.IntermediateNode.ChildNodes[1:] {\n-\t\t\t\tfsm := map[string]FoundSubject{}\n-\t\t\t\tif err := populateFoundSubjects(fsm, rootONR, child); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tsubjectset.intersect(fsm)\n-\t\t\t}\n-\n-\t\t\tsubjectset.populate(foundSubjectsMap)\n-\n-\t\tcase v0.SetOperationUserset_EXCLUSION:\n-\t\t\tif len(typed.IntermediateNode.ChildNodes) == 0 {\n-\t\t\t\treturn fmt.Errorf(\"found exclusion with no children\")\n-\t\t\t}\n-\n-\t\t\tfsm := map[string]FoundSubject{}\n-\t\t\terr := populateFoundSubjects(fsm, rootONR, typed.IntermediateNode.ChildNodes[0])\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\n-\t\t\tsubjectset := newSubjectSet()\n-\t\t\tsubjectset.union(fsm)\n-\n-\t\t\tfor _, child := range typed.IntermediateNode.ChildNodes[1:] {\n-\t\t\t\tfsm := map[string]FoundSubject{}\n-\t\t\t\tif err := populateFoundSubjects(fsm, rootONR, child); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tsubjectset.exclude(fsm)\n-\t\t\t}\n-\n-\t\t\tsubjectset.populate(foundSubjectsMap)\n-\n-\t\tdefault:\n-\t\t\tpanic(\"unknown expand operation\")\n-\t\t}\n-\n-\tcase *v0.RelationTupleTreeNode_LeafNode:\n-\t\tfor _, user := range typed.LeafNode.Users {\n-\t\t\tsubjectONRString := tuple.StringONR(user.GetUserset())\n-\t\t\t_, ok := foundSubjectsMap[subjectONRString]\n-\t\t\tif !ok {\n-\t\t\t\tfoundSubjectsMap[subjectONRString] = FoundSubject{\n-\t\t\t\t\tsubject:       user.GetUserset(),\n-\t\t\t\t\trelationships: tuple.NewONRSet(),\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tfoundSubjectsMap[subjectONRString].relationships.Add(relationship)\n-\t\t}\n-\tdefault:\n-\t\tpanic(\"unknown TreeNode type\")\n-\t}\n-\n-\treturn nil\n-}\n-\n-type subjectSet struct {\n-\tsubjectsMap map[string]FoundSubject\n-}\n-\n-func newSubjectSet() *subjectSet {\n-\treturn &subjectSet{\n-\t\tsubjectsMap: map[string]FoundSubject{},\n-\t}\n-}\n-\n-func (ss *subjectSet) populate(outgoingSubjectsMap map[string]FoundSubject) {\n-\tfor key, fs := range ss.subjectsMap {\n-\t\texisting, ok := outgoingSubjectsMap[key]\n-\t\tif ok {\n-\t\t\texisting.relationships.UpdateFrom(fs.relationships)\n-\t\t} else {\n-\t\t\toutgoingSubjectsMap[key] = fs\n-\t\t}\n-\t}\n-}\n-\n-func (ss *subjectSet) union(subjectsMap map[string]FoundSubject) {\n-\tfor key, fs := range subjectsMap {\n-\t\texisting, ok := ss.subjectsMap[key]\n-\t\tif ok {\n-\t\t\texisting.relationships.UpdateFrom(fs.relationships)\n-\t\t} else {\n-\t\t\tss.subjectsMap[key] = fs\n-\t\t}\n-\t}\n-}\n-\n-func (ss *subjectSet) intersect(subjectsMap map[string]FoundSubject) {\n-\tfor key, fs := range ss.subjectsMap {\n-\t\tother, ok := subjectsMap[key]\n-\t\tif ok {\n-\t\t\tfs.relationships.UpdateFrom(other.relationships)\n-\t\t} else {\n-\t\t\tdelete(ss.subjectsMap, key)\n-\t\t}\n-\t}\n-}\n-\n-func (ss *subjectSet) exclude(subjectsMap map[string]FoundSubject) {\n-\tfor key := range ss.subjectsMap {\n-\t\t_, ok := subjectsMap[key]\n-\t\tif ok {\n-\t\t\tdelete(ss.subjectsMap, key)\n-\t\t}\n-\t}\n-}"
        },
        {
          "filename": "pkg/membership/membership_test.go",
          "status": "removed",
          "additions": 0,
          "deletions": 128,
          "patch": "@@ -1,128 +0,0 @@\n-package membership\n-\n-import (\n-\t\"testing\"\n-\n-\tv0 \"github.com/authzed/authzed-go/proto/authzed/api/v0\"\n-\t\"github.com/stretchr/testify/require\"\n-\n-\t\"github.com/authzed/spicedb/pkg/graph\"\n-\t\"github.com/authzed/spicedb/pkg/tuple\"\n-)\n-\n-var (\n-\tONR      = tuple.ObjectAndRelation\n-\tEllipsis = \"...\"\n-)\n-\n-var (\n-\t_this *v0.ObjectAndRelation\n-\n-\tcompanyOwner = graph.Leaf(ONR(\"folder\", \"company\", \"owner\"),\n-\t\ttuple.User(ONR(\"user\", \"owner\", Ellipsis)),\n-\t)\n-\tcompanyEditor = graph.Union(ONR(\"folder\", \"company\", \"editor\"),\n-\t\tgraph.Leaf(_this, tuple.User(ONR(\"user\", \"writer\", Ellipsis))),\n-\t\tcompanyOwner,\n-\t)\n-\n-\tauditorsOwner = graph.Leaf(ONR(\"folder\", \"auditors\", \"owner\"))\n-\n-\tauditorsEditor = graph.Union(ONR(\"folder\", \"auditors\", \"editor\"),\n-\t\tgraph.Leaf(_this),\n-\t\tauditorsOwner,\n-\t)\n-\n-\tauditorsViewerRecursive = graph.Union(ONR(\"folder\", \"auditors\", \"viewer\"),\n-\t\tgraph.Leaf(_this,\n-\t\t\ttuple.User(ONR(\"user\", \"auditor\", \"...\")),\n-\t\t),\n-\t\tauditorsEditor,\n-\t\tgraph.Union(ONR(\"folder\", \"auditors\", \"viewer\")),\n-\t)\n-\n-\tcompanyViewerRecursive = graph.Union(ONR(\"folder\", \"company\", \"viewer\"),\n-\t\tgraph.Union(ONR(\"folder\", \"company\", \"viewer\"),\n-\t\t\tauditorsViewerRecursive,\n-\t\t\tgraph.Leaf(_this,\n-\t\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n-\t\t\t\ttuple.User(ONR(\"folder\", \"auditors\", \"viewer\")),\n-\t\t\t),\n-\t\t),\n-\t\tcompanyEditor,\n-\t\tgraph.Union(ONR(\"folder\", \"company\", \"viewer\")),\n-\t)\n-)\n-\n-func TestMembershipSet(t *testing.T) {\n-\trequire := require.New(t)\n-\tms := NewMembershipSet()\n-\n-\t// Add some expansion trees.\n-\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"owner\"), companyOwner)\n-\trequire.True(ok)\n-\trequire.NoError(err)\n-\tverifySubjects(require, fso, \"user:owner\")\n-\n-\tfse, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"editor\"), companyEditor)\n-\trequire.True(ok)\n-\trequire.NoError(err)\n-\tverifySubjects(require, fse, \"user:owner\", \"user:writer\")\n-\n-\tfsv, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), companyViewerRecursive)\n-\trequire.True(ok)\n-\trequire.NoError(err)\n-\tverifySubjects(require, fsv, \"folder:auditors#viewer\", \"user:auditor\", \"user:legal\", \"user:owner\", \"user:writer\")\n-}\n-\n-func TestMembershipSetIntersection(t *testing.T) {\n-\trequire := require.New(t)\n-\tms := NewMembershipSet()\n-\n-\tintersection := graph.Intersection(ONR(\"folder\", \"company\", \"viewer\"),\n-\t\tgraph.Leaf(_this,\n-\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n-\t\t),\n-\t\tgraph.Leaf(_this,\n-\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n-\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n-\t\t),\n-\t)\n-\n-\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), intersection)\n-\trequire.True(ok)\n-\trequire.NoError(err)\n-\tverifySubjects(require, fso, \"user:legal\")\n-}\n-\n-func TestMembershipSetExclusion(t *testing.T) {\n-\trequire := require.New(t)\n-\tms := NewMembershipSet()\n-\n-\tintersection := graph.Exclusion(ONR(\"folder\", \"company\", \"viewer\"),\n-\t\tgraph.Leaf(_this,\n-\t\t\ttuple.User(ONR(\"user\", \"owner\", \"...\")),\n-\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n-\t\t),\n-\t\tgraph.Leaf(_this,\n-\t\t\ttuple.User(ONR(\"user\", \"legal\", \"...\")),\n-\t\t),\n-\t)\n-\n-\tfso, ok, err := ms.AddExpansion(ONR(\"folder\", \"company\", \"viewer\"), intersection)\n-\trequire.True(ok)\n-\trequire.NoError(err)\n-\tverifySubjects(require, fso, \"user:owner\")\n-}\n-\n-func verifySubjects(require *require.Assertions, fs FoundSubjects, expected ...string) {\n-\tfoundSubjects := []*v0.ObjectAndRelation{}\n-\tfor _, found := range fs.ListFound() {\n-\t\tfoundSubjects = append(foundSubjects, found.Subject())\n-\n-\t\t_, ok := fs.LookupSubject(found.Subject())\n-\t\trequire.True(ok)\n-\t}\n-\n-\trequire.Equal(expected, tuple.StringsONRs(foundSubjects))\n-}"
        },
        {
          "filename": "pkg/tuple/onrset.go",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -91,6 +91,18 @@ func (ons *ONRSet) With(onr *v0.ObjectAndRelation) *ONRSet {\n \treturn updated\n }\n \n+// Union returns a copy of this ONR set with the other set's elements added in.\n+func (ons *ONRSet) Union(otherSet *ONRSet) *ONRSet {\n+\tupdated := NewONRSet()\n+\tfor _, current := range ons.onrs {\n+\t\tupdated.Add(current)\n+\t}\n+\tfor _, current := range otherSet.onrs {\n+\t\tupdated.Add(current)\n+\t}\n+\treturn updated\n+}\n+\n // AsSlice returns the ONRs found in the set as a slice.\n func (ons *ONRSet) AsSlice() []*v0.ObjectAndRelation {\n \tslice := make([]*v0.ObjectAndRelation, 0, len(ons.onrs))"
        },
        {
          "filename": "pkg/validationfile/fileformat.go",
          "status": "modified",
          "additions": 41,
          "deletions": 4,
          "patch": "@@ -149,10 +149,20 @@ func (ors ObjectRelationString) ONR() (*v0.ObjectAndRelation, *ErrorWithSource)\n }\n \n var (\n-\tvsSubjectRegex           = regexp.MustCompile(`(.*?)\\[(?P<user_str>.*)\\](.*?)`)\n-\tvsObjectAndRelationRegex = regexp.MustCompile(`(.*?)<(?P<onr_str>[^\\>]+)>(.*?)`)\n+\tvsSubjectRegex               = regexp.MustCompile(`(.*?)\\[(?P<user_str>.*)\\](.*?)`)\n+\tvsObjectAndRelationRegex     = regexp.MustCompile(`(.*?)<(?P<onr_str>[^\\>]+)>(.*?)`)\n+\tvsSubjectWithExceptionsRegex = regexp.MustCompile(`^(.+)\\s*-\\s*\\{([^\\}]+)\\}$`)\n )\n \n+// SubjectWithExceptions returns the subject found in a validation string, along with any exceptions.\n+type SubjectWithExceptions struct {\n+\t// Subject is the subject found.\n+\tSubject *v0.ObjectAndRelation\n+\n+\t// Exceptions are those subjects removed from the subject, if it is a wildcard.\n+\tExceptions []*v0.ObjectAndRelation\n+}\n+\n // ValidationString holds a validation string containing a Subject and one or\n // more Relations to the parent Object.\n // Example: `[tenant/user:someuser#...] is <tenant/document:example#viewer>`\n@@ -170,17 +180,44 @@ func (vs ValidationString) SubjectString() (string, bool) {\n \n // Subject returns the subject contained in the ValidationString, if any. If\n // none, returns nil.\n-func (vs ValidationString) Subject() (*v0.ObjectAndRelation, *ErrorWithSource) {\n+func (vs ValidationString) Subject() (*SubjectWithExceptions, *ErrorWithSource) {\n \tsubjectStr, ok := vs.SubjectString()\n \tif !ok {\n \t\treturn nil, nil\n \t}\n \n+\tsubjectStr = strings.TrimSpace(subjectStr)\n+\tif strings.HasSuffix(subjectStr, \"}\") {\n+\t\tresult := vsSubjectWithExceptionsRegex.FindStringSubmatch(subjectStr)\n+\t\tif len(result) != 3 {\n+\t\t\treturn nil, &ErrorWithSource{fmt.Errorf(\"invalid subject: %s\", subjectStr), subjectStr, 0, 0}\n+\t\t}\n+\n+\t\tsubjectONR := tuple.ParseSubjectONR(strings.TrimSpace(result[1]))\n+\t\tif subjectONR == nil {\n+\t\t\treturn nil, &ErrorWithSource{fmt.Errorf(\"invalid subject: %s\", result[1]), result[1], 0, 0}\n+\t\t}\n+\n+\t\texceptionsString := strings.TrimSpace(result[2])\n+\t\texceptionsStringsSlice := strings.Split(exceptionsString, \",\")\n+\t\texceptions := make([]*v0.ObjectAndRelation, 0, len(exceptionsStringsSlice))\n+\t\tfor _, exceptionString := range exceptionsStringsSlice {\n+\t\t\texceptionONR := tuple.ParseSubjectONR(strings.TrimSpace(exceptionString))\n+\t\t\tif exceptionONR == nil {\n+\t\t\t\treturn nil, &ErrorWithSource{fmt.Errorf(\"invalid subject: %s\", exceptionString), exceptionString, 0, 0}\n+\t\t\t}\n+\n+\t\t\texceptions = append(exceptions, exceptionONR)\n+\t\t}\n+\n+\t\treturn &SubjectWithExceptions{subjectONR, exceptions}, nil\n+\t}\n+\n \tfound := tuple.ParseSubjectONR(subjectStr)\n \tif found == nil {\n \t\treturn nil, &ErrorWithSource{fmt.Errorf(\"invalid subject: %s\", subjectStr), subjectStr, 0, 0}\n \t}\n-\treturn found, nil\n+\treturn &SubjectWithExceptions{found, nil}, nil\n }\n \n // ONRStrings returns the ONRs contained in the ValidationString, if any."
        },
        {
          "filename": "pkg/validationfile/fileformat_test.go",
          "status": "modified",
          "additions": 16,
          "deletions": 2,
          "patch": "@@ -65,18 +65,32 @@ func TestValidationString(t *testing.T) {\n \t\t\t\"\",\n \t\t\t[]string{\"tenant/document:example#viewer\", \"tenant/document:example#builder\"},\n \t\t},\n+\t\t{\n+\t\t\t\"subject with exclusions\",\n+\t\t\t\"[tenant/user:someuser#... - {test/user:1,test/user:2}] is <tenant/document:example#viewer>/<tenant/document:example#builder>\",\n+\t\t\t\"tenant/user:someuser\",\n+\t\t\t[]string{\"tenant/document:example#viewer\", \"tenant/document:example#builder\"},\n+\t\t},\n+\t\t{\n+\t\t\t\"subject with bad exclusions\",\n+\t\t\t\"[tenant/user:someuser#... - {te1,test/user:2}] is <tenant/document:example#viewer>/<tenant/document:example#builder>\",\n+\t\t\t\"\",\n+\t\t\t[]string{\"tenant/document:example#viewer\", \"tenant/document:example#builder\"},\n+\t\t},\n \t}\n \n \tfor _, tc := range tests {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trequire := require.New(t)\n \t\t\tvs := ValidationString(tc.input)\n \n-\t\t\tsubject, _ := vs.Subject()\n+\t\t\tsubject, err := vs.Subject()\n+\n \t\t\tif tc.expectedSubject == \"\" {\n \t\t\t\trequire.Nil(subject)\n \t\t\t} else {\n-\t\t\t\trequire.Equal(tc.expectedSubject, tuple.StringONR(subject))\n+\t\t\t\trequire.Nil(err)\n+\t\t\t\trequire.Equal(tc.expectedSubject, tuple.StringONR(subject.Subject))\n \t\t\t}\n \n \t\t\tfoundONRStrings := []string{}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 5,
        "dependency_files": 0,
        "test_files": 15,
        "unique_directories": 10,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "db2cf0146d7b2a1bf7c8b838acf91cde019b9445",
            "date": "2025-01-14T18:25:51Z",
            "author_login": "josephschorr"
          },
          {
            "sha": "75390a9b4c3492bbd14c1df2e50209e285be5831",
            "date": "2025-01-08T23:45:38Z",
            "author_login": "josephschorr"
          },
          {
            "sha": "3bbf45766ed519c53ff802619a032e58e2af57a7",
            "date": "2025-01-13T22:44:38Z",
            "author_login": "josephschorr"
          },
          {
            "sha": "3e257e6c4207721f8ae421ec1424f96c0c60279b",
            "date": "2025-01-11T22:06:12Z",
            "author_login": "josephschorr"
          },
          {
            "sha": "fabeff191dec15fae327c896a9f40e095fde5e49",
            "date": "2025-01-10T22:22:57Z",
            "author_login": "josephschorr"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-20",
    "description": "SpiceDB is a database system for managing security-critical application permissions. Any user making use of a wildcard relationship under the right hand branch of an `exclusion` or within an `intersection` operation will see `Lookup`/`LookupResources` return a resource as \"accessible\" if it is *not* accessible by virtue of the inclusion of the wildcard in the intersection or the right side of the exclusion. In `v1.3.0`, the wildcard is ignored entirely in lookup's dispatch, resulting in the `banned` wildcard being ignored in the exclusion. Version 1.4.0 contains a patch for this issue. As a workaround, don't make use of wildcards on the right side of intersections or within exclusions.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-01-11T22:15:07.727",
    "last_modified": "2024-11-21T06:45:08.780",
    "fix_date": "2022-01-11T19:39:23Z"
  },
  "references": [
    {
      "url": "https://github.com/authzed/spicedb/commit/15bba2e2d2a4bda336a37a7fe8ef8a35028cd970",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/authzed/spicedb/issues/358",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/authzed/spicedb/releases/tag/v1.4.0",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/authzed/spicedb/security/advisories/GHSA-7p8f-8hjm-wm92",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/authzed/spicedb/commit/15bba2e2d2a4bda336a37a7fe8ef8a35028cd970",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/authzed/spicedb/issues/358",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/authzed/spicedb/releases/tag/v1.4.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/authzed/spicedb/security/advisories/GHSA-7p8f-8hjm-wm92",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:37.069423",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "spicedb",
    "owner": "authzed",
    "created_at": "2021-08-16T15:32:09Z",
    "updated_at": "2025-01-14T00:07:27Z",
    "pushed_at": "2025-01-13T22:53:04Z",
    "size": 19045,
    "stars": 5286,
    "forks": 286,
    "open_issues": 107,
    "watchers": 5286,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Go": 4522371,
      "JavaScript": 16612,
      "HTML": 3663,
      "Dockerfile": 1564
    },
    "commit_activity": {
      "total_commits_last_year": 625,
      "avg_commits_per_week": 12.01923076923077,
      "days_active_last_year": 208
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:56:47.808291"
  }
}