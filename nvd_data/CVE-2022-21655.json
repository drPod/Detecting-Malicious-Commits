{
  "cve_id": "CVE-2022-21655",
  "github_data": {
    "repository": "envoyproxy/envoy",
    "fix_commit": "177d608155ba8b11598b9bbf8240e90d8c350682",
    "related_commits": [
      "177d608155ba8b11598b9bbf8240e90d8c350682",
      "177d608155ba8b11598b9bbf8240e90d8c350682"
    ],
    "patch_url": "https://github.com/envoyproxy/envoy/commit/177d608155ba8b11598b9bbf8240e90d8c350682.patch",
    "fix_commit_details": {
      "sha": "177d608155ba8b11598b9bbf8240e90d8c350682",
      "commit_date": "2022-02-01T19:59:31Z",
      "author": {
        "login": "yanavlasov",
        "type": "User",
        "stats": {
          "total_commits": 353,
          "average_weekly_commits": 0.800453514739229,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 163
        }
      },
      "commit_message": {
        "title": "CVE-2022-21655",
        "length": 92,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 79,
        "additions": 75,
        "deletions": 4
      },
      "files": [
        {
          "filename": "docs/root/version_history/current.rst",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -25,6 +25,7 @@ Bug Fixes\n *Changes expected to improve the state of the world and are unlikely to have negative effects*\n \n * access_log: fix memory leak when reopening an access log fails. Access logs will now try to be reopened on each subsequent flush attempt after a failure.\n+* data plane: fix crash when internal redirect selects a route configured with direct response or redirect actions.\n * data plane: fixing error handling where writing to a socket failed while under the stack of processing. This should genreally affect HTTP/3. This behavioral change can be reverted by setting ``envoy.reloadable_features.allow_upstream_inline_write`` to false.\n * eds: fix the eds cluster update by allowing update on the locality of the cluster endpoints. This behavioral change can be temporarily reverted by setting runtime guard ``envoy.reloadable_features.support_locality_update_on_eds_cluster_endpoints`` to false.\n * jwt_authn: fixed the crash when a CONNECT request is sent to JWT filter configured with regex match on the Host header."
        },
        {
          "filename": "source/common/router/router.cc",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1692,7 +1692,8 @@ bool Filter::convertRequestHeadersForInternalRedirect(Http::RequestHeaderMap& do\n     return false;\n   }\n \n-  const auto& route_name = route->routeEntry()->routeName();\n+  const auto& route_name = route->directResponseEntry() ? route->directResponseEntry()->routeName()\n+                                                        : route->routeEntry()->routeName();\n   for (const auto& predicate : policy.predicates()) {\n     if (!predicate->acceptTargetRoute(*filter_state, route_name, !scheme_is_http,\n                                       !target_is_http)) {"
        },
        {
          "filename": "test/common/router/router_test.cc",
          "status": "modified",
          "additions": 30,
          "deletions": 3,
          "patch": "@@ -56,6 +56,7 @@ using testing::AtLeast;\n using testing::Eq;\n using testing::InSequence;\n using testing::Invoke;\n+using testing::InvokeWithoutArgs;\n using testing::MockFunction;\n using testing::NiceMock;\n using testing::Property;\n@@ -319,7 +320,7 @@ TEST_F(RouterTest, MissingRequiredHeaders) {\n       sendLocalReply(Http::Code::ServiceUnavailable,\n                      testing::Eq(\"missing required header: :method\"), _, _,\n                      \"filter_removed_required_request_headers{missing_required_header:_:method}\"))\n-      .WillOnce(testing::InvokeWithoutArgs([] {}));\n+      .WillOnce(InvokeWithoutArgs([] {}));\n   router_.decodeHeaders(headers, true);\n   router_.onDestroy();\n }\n@@ -3411,8 +3412,7 @@ TEST_F(RouterTest, RetryUpstreamResetResponseStarted) {\n   // Normally, sendLocalReply will actually send the reply, but in this case the\n   // HCM will detect the headers have already been sent and not route through\n   // the encoder again.\n-  EXPECT_CALL(callbacks_, sendLocalReply(_, _, _, _, _)).WillOnce(testing::InvokeWithoutArgs([] {\n-  }));\n+  EXPECT_CALL(callbacks_, sendLocalReply(_, _, _, _, _)).WillOnce(InvokeWithoutArgs([] {}));\n   encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n   // For normal HTTP, once we have a 200 we consider this a success, even if a\n   // later reset occurs.\n@@ -4207,6 +4207,33 @@ TEST_F(RouterTest, HttpInternalRedirectSucceeded) {\n                    ->value());\n }\n \n+TEST_F(RouterTest, HttpInternalRedirectMatchedToDirectResponseSucceeded) {\n+  NiceMock<MockDirectResponseEntry> direct_response;\n+  std::string route_name(\"route-test-name\");\n+  EXPECT_CALL(direct_response, routeName()).WillOnce(ReturnRef(route_name));\n+\n+  enableRedirects();\n+  sendRequest();\n+  EXPECT_CALL(callbacks_, clearRouteCache()).WillOnce(InvokeWithoutArgs([&]() -> void {\n+    // Direct message route should be matched after internal redirect\n+    EXPECT_CALL(*callbacks_.route_, routeEntry()).WillRepeatedly(Return(nullptr));\n+    EXPECT_CALL(*callbacks_.route_, directResponseEntry()).WillRepeatedly(Return(&direct_response));\n+  }));\n+  EXPECT_CALL(callbacks_, recreateStream(_)).WillOnce(Return(true));\n+\n+  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n+  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n+                    .counter(\"upstream_internal_redirect_succeeded_total\")\n+                    .value());\n+\n+  // In production, the HCM recreateStream would have called this.\n+  router_.onDestroy();\n+  EXPECT_EQ(1, callbacks_.streamInfo()\n+                   .filterState()\n+                   ->getDataMutable<StreamInfo::UInt32Accessor>(\"num_internal_redirects\")\n+                   ->value());\n+}\n+\n TEST_F(RouterTest, InternalRedirectStripsFragment) {\n   enableRedirects();\n   default_request_headers_.setForwardedProto(\"http\");"
        },
        {
          "filename": "test/integration/redirect_integration_test.cc",
          "status": "modified",
          "additions": 42,
          "deletions": 0,
          "patch": "@@ -39,6 +39,15 @@ class RedirectIntegrationTest : public HttpProtocolIntegrationTest {\n         ->set_value(3);\n     config_helper_.addVirtualHost(handle_max_3_hop);\n \n+    auto handle_by_direct_response = config_helper_.createVirtualHost(\"handle.direct.response\");\n+    handle_by_direct_response.mutable_routes(0)->set_name(\"direct_response\");\n+    handle_by_direct_response.mutable_routes(0)->mutable_direct_response()->set_status(204);\n+    handle_by_direct_response.mutable_routes(0)\n+        ->mutable_direct_response()\n+        ->mutable_body()\n+        ->set_inline_string(EMPTY_STRING);\n+    config_helper_.addVirtualHost(handle_by_direct_response);\n+\n     HttpProtocolIntegrationTest::initialize();\n   }\n \n@@ -665,6 +674,39 @@ TEST_P(RedirectIntegrationTest, InvalidRedirect) {\n             response->headers().get(test_header_key_)[0]->value().getStringView());\n }\n \n+TEST_P(RedirectIntegrationTest, InternalRedirectHandledByDirectResponse) {\n+  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n+  // Validate that header sanitization is only called once.\n+  config_helper_.addConfigModifier(\n+      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n+             hcm) { hcm.set_via(\"via_value\"); });\n+  initialize();\n+\n+  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n+\n+  default_request_headers_.setHost(\"handle.internal.redirect\");\n+  IntegrationStreamDecoderPtr response =\n+      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n+\n+  waitForNextUpstreamRequest();\n+\n+  redirect_response_.setLocation(\"http://handle.direct.response/\");\n+  upstream_request_->encodeHeaders(redirect_response_, true);\n+\n+  ASSERT_TRUE(response->waitForEndStream());\n+  ASSERT_TRUE(response->complete());\n+  EXPECT_EQ(\"204\", response->headers().getStatusValue());\n+  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n+                   ->value());\n+  // 302 was never returned downstream\n+  EXPECT_EQ(0, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n+  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_2xx\")->value());\n+  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n+              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n+  // No test header\n+  EXPECT_THAT(waitForAccessLog(access_log_name_, 1), HasSubstr(\"204 direct_response -\\n\"));\n+}\n+\n INSTANTIATE_TEST_SUITE_P(Protocols, RedirectIntegrationTest,\n                          testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams()),\n                          HttpProtocolIntegrationTest::protocolTestParamsToString);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c93cf7af47f7e24c83b563d3b956074333bc4bf7",
            "date": "2025-01-14T17:23:07Z",
            "author_login": "phlax"
          },
          {
            "sha": "078dae3549912e632c3776a5e9a4679226093276",
            "date": "2025-01-14T14:27:08Z",
            "author_login": "agrawroh"
          },
          {
            "sha": "7b20933ee263eb9aeaceee6bc309b80b997cbbb2",
            "date": "2025-01-14T14:13:49Z",
            "author_login": "phlax"
          },
          {
            "sha": "03cb8d59f80a2a75d9e1289c909e5979a79ace91",
            "date": "2025-01-13T06:31:54Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "3487b225f48717dd5a2babb5f921df4353633cee",
            "date": "2025-01-13T06:10:11Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-670",
    "description": "Envoy is an open source edge and service proxy, designed for cloud-native applications. The envoy common router will segfault if an internal redirect selects a route configured with direct response or redirect actions. This will result in a denial of service. As a workaround turn off internal redirects if direct response entries are configured on the same listener.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-02-22T23:15:11.163",
    "last_modified": "2024-11-21T06:45:09.970",
    "fix_date": "2022-02-01T19:59:31Z"
  },
  "references": [
    {
      "url": "https://github.com/envoyproxy/envoy/commit/177d608155ba8b11598b9bbf8240e90d8c350682",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-7r5p-7fmh-jxpg",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/commit/177d608155ba8b11598b9bbf8240e90d8c350682",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-7r5p-7fmh-jxpg",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:59.740686",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "envoy",
    "owner": "envoyproxy",
    "created_at": "2016-08-08T15:07:24Z",
    "updated_at": "2025-01-14T12:22:22Z",
    "pushed_at": "2025-01-14T05:36:17Z",
    "size": 240648,
    "stars": 25321,
    "forks": 4848,
    "open_issues": 1639,
    "watchers": 25321,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C++": 48293036,
      "Starlark": 3105942,
      "Java": 1320095,
      "Python": 605206,
      "Assembly": 327095,
      "Kotlin": 309606,
      "Swift": 250537,
      "Shell": 229801,
      "Go": 183281,
      "Rust": 107190,
      "JavaScript": 66339,
      "C": 61597,
      "Objective-C++": 55490,
      "Objective-C": 48840,
      "Jinja": 47798,
      "Smarty": 3528,
      "CSS": 2927,
      "HTML": 1522,
      "Emacs Lisp": 966,
      "Dockerfile": 960,
      "Thrift": 748,
      "PureBasic": 472,
      "Batchfile": 439,
      "Makefile": 303
    },
    "commit_activity": {
      "total_commits_last_year": 3286,
      "avg_commits_per_week": 63.19230769230769,
      "days_active_last_year": 303
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:55:59.245540"
  }
}