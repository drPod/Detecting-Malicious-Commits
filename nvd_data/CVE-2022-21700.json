{
  "cve_id": "CVE-2022-21700",
  "github_data": {
    "repository": "micronaut-projects/micronaut-core",
    "fix_commit": "b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3",
    "related_commits": [
      "b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3",
      "b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3",
      "commit_date": "2019-11-18T07:23:08Z",
      "author": {
        "login": "fabienrenaud",
        "type": "User",
        "stats": {
          "total_commits": 7,
          "average_weekly_commits": 0.017326732673267328,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 2
        }
      },
      "commit_message": {
        "title": "Use ConversionContext constants where possible instead of class (#2356)",
        "length": 395,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 204,
        "additions": 145,
        "deletions": 59
      },
      "files": [
        {
          "filename": "core/src/main/java/io/micronaut/core/convert/ConversionContext.java",
          "status": "modified",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -41,6 +41,31 @@ public interface ConversionContext extends AnnotationMetadataProvider, TypeVaria\n     ConversionContext DEFAULT = new ConversionContext() {\n     };\n \n+    /**\n+     * Constant for Boolean argument.\n+     */\n+    ArgumentConversionContext<Boolean> BOOLEAN = ConversionContext.of(Argument.BOOLEAN);\n+\n+    /**\n+     * Constant for Integer argument.\n+     */\n+    ArgumentConversionContext<Integer> INT = ConversionContext.of(Argument.INT);\n+\n+    /**\n+     * Constant for Long argument.\n+     */\n+    ArgumentConversionContext<Long> LONG = ConversionContext.of(Argument.LONG);\n+\n+    /**\n+     * Constant for String argument.\n+     */\n+    ArgumentConversionContext<String> STRING = ConversionContext.of(Argument.STRING);\n+\n+    /**\n+     * Constant for List<String> argument.\n+     */\n+    ArgumentConversionContext<List<String>> LIST_OF_STRING = ConversionContext.of(Argument.LIST_OF_STRING);\n+\n     /**\n      * In the case where the type to be converted contains generic type arguments this map will return\n      * the concrete types of those arguments. For example for the {@link Map} type two keys will be present"
        },
        {
          "filename": "core/src/main/java/io/micronaut/core/convert/DefaultArgumentConversionContext.java",
          "status": "modified",
          "additions": 20,
          "deletions": 7,
          "patch": "@@ -19,13 +19,7 @@\n import io.micronaut.core.type.Argument;\n \n import java.nio.charset.Charset;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Optional;\n+import java.util.*;\n \n /**\n  * Default implementation of the {@link ConversionContext} interface.\n@@ -114,6 +108,25 @@ public Argument<T> getArgument() {\n         return argument;\n     }\n \n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        DefaultArgumentConversionContext<?> that = (DefaultArgumentConversionContext<?>) o;\n+        return Objects.equals(getArgument(), that.getArgument()) &&\n+            Objects.equals(finalLocale, that.finalLocale) &&\n+            Objects.equals(finalCharset, that.finalCharset);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(argument, finalLocale, finalCharset);\n+    }\n+\n     @Override\n     public String toString() {\n         return argument.toString();"
        },
        {
          "filename": "core/src/main/java/io/micronaut/core/convert/value/ConvertibleMultiValues.java",
          "status": "modified",
          "additions": 17,
          "deletions": 0,
          "patch": "@@ -15,6 +15,7 @@\n  */\n package io.micronaut.core.convert.value;\n \n+import io.micronaut.core.convert.ArgumentConversionContext;\n import io.micronaut.core.convert.ConversionContext;\n import io.micronaut.core.convert.ConversionService;\n import io.micronaut.core.reflect.GenericTypeUtils;\n@@ -170,6 +171,22 @@ default <T> Optional<T> getFirst(CharSequence name, Argument<T> requiredType) {\n         return Optional.empty();\n     }\n \n+    /**\n+     * Find a header and convert it to the given type.\n+     *\n+     * @param name              The name of the header\n+     * @param conversionContext The conversion context\n+     * @param <T>               The generic type\n+     * @return If the header is presented and can be converted an optional of the value otherwise {@link Optional#empty()}\n+     */\n+    default <T> Optional<T> getFirst(CharSequence name, ArgumentConversionContext<T> conversionContext) {\n+        V v = get(name);\n+        if (v != null) {\n+            return ConversionService.SHARED.convert(v, conversionContext);\n+        }\n+        return Optional.empty();\n+    }\n+\n     /**\n      * Find a header and convert it to the given type.\n      *"
        },
        {
          "filename": "core/src/main/java/io/micronaut/core/convert/value/ConvertibleValues.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -70,7 +70,7 @@ default Class<V> getValueType() {\n      * @return True if it is\n      */\n     default boolean contains(String name) {\n-        return get(name, Object.class).isPresent();\n+        return get(name, Argument.OBJECT_ARGUMENT).isPresent();\n     }\n \n     /**"
        },
        {
          "filename": "core/src/main/java/io/micronaut/core/type/Argument.java",
          "status": "modified",
          "additions": 19,
          "deletions": 9,
          "patch": "@@ -40,59 +40,64 @@\n  */\n public interface Argument<T> extends TypeVariableResolver, AnnotatedElement, Type {\n \n+    /**\n+     * Constant for string argument.\n+     */\n+    Argument<String> STRING = Argument.of(String.class);\n+\n     /**\n      * Constant for int argument. Used by generated code, do not remove.\n      */\n     @SuppressWarnings(\"unused\")\n-    Argument INT = Argument.of(int.class);\n+    Argument<Integer> INT = Argument.of(int.class);\n \n     /**\n      * Constant for long argument. Used by generated code, do not remove.\n      */\n     @SuppressWarnings(\"unused\")\n-    Argument LONG = Argument.of(long.class);\n+    Argument<Long> LONG = Argument.of(long.class);\n \n     /**\n      * Constant for float argument. Used by generated code, do not remove.\n      */\n     @SuppressWarnings(\"unused\")\n-    Argument FLOAT = Argument.of(float.class);\n+    Argument<Float> FLOAT = Argument.of(float.class);\n \n     /**\n      * Constant for double argument. Used by generated code, do not remove.\n      */\n     @SuppressWarnings(\"unused\")\n-    Argument DOUBLE = Argument.of(double.class);\n+    Argument<Double> DOUBLE = Argument.of(double.class);\n \n     /**\n      * Constant for void argument. Used by generated code, do not remove.\n      */\n     @SuppressWarnings(\"unused\")\n-    Argument VOID = Argument.of(void.class);\n+    Argument<Void> VOID = Argument.of(void.class);\n \n     /**\n      * Constant for byte argument. Used by generated code, do not remove.\n      */\n     @SuppressWarnings(\"unused\")\n-    Argument BYTE = Argument.of(byte.class);\n+    Argument<Byte> BYTE = Argument.of(byte.class);\n \n     /**\n      * Constant for boolean argument. Used by generated code, do not remove.\n      */\n     @SuppressWarnings(\"unused\")\n-    Argument BOOLEAN = Argument.of(boolean.class);\n+    Argument<Boolean> BOOLEAN = Argument.of(boolean.class);\n \n     /**\n      * Constant char argument. Used by generated code, do not remove.\n      */\n     @SuppressWarnings(\"unused\")\n-    Argument CHAR = Argument.of(char.class);\n+    Argument<Character> CHAR = Argument.of(char.class);\n \n     /**\n      * Constant short argument. Used by generated code, do not remove.\n      */\n     @SuppressWarnings(\"unused\")\n-    Argument SHORT = Argument.of(short.class);\n+    Argument<Short> SHORT = Argument.of(short.class);\n \n     /**\n      * Constant representing zero arguments. Used by generated code, do not remove.\n@@ -107,6 +112,11 @@ public interface Argument<T> extends TypeVariableResolver, AnnotatedElement, Typ\n     @SuppressWarnings(\"unused\")\n     Argument<Object> OBJECT_ARGUMENT = of(Object.class);\n \n+    /**\n+     * Constant for List<String> argument.\n+     */\n+    Argument<List<String>> LIST_OF_STRING = Argument.listOf(String.class);\n+\n     /**\n      * @return The name of the argument\n      */"
        },
        {
          "filename": "core/src/main/java/io/micronaut/core/type/DefaultArgument.java",
          "status": "modified",
          "additions": 2,
          "deletions": 6,
          "patch": "@@ -47,11 +47,7 @@ public class DefaultArgument<T> implements Argument<T> {\n      * @param genericTypes       The generic types\n      */\n     public DefaultArgument(Class<T> type, String name, AnnotationMetadata annotationMetadata, Argument... genericTypes) {\n-        this.type = type;\n-        this.name = name;\n-        this.annotationMetadata = annotationMetadata != null ? annotationMetadata : AnnotationMetadata.EMPTY_METADATA;\n-        this.typeParameters = initializeTypeParameters(genericTypes);\n-        this.typeParameterArray = genericTypes;\n+        this(type, name, annotationMetadata, initializeTypeParameters(genericTypes), genericTypes);\n     }\n \n     /**\n@@ -184,7 +180,7 @@ public int hashCode() {\n         return Objects.hash(type, name, typeParameters);\n     }\n \n-    private Map<String, Argument<?>> initializeTypeParameters(Argument[] genericTypes) {\n+    private static Map<String, Argument<?>> initializeTypeParameters(Argument[] genericTypes) {\n         Map<String, Argument<?>> typeParameters;\n         if (genericTypes != null && genericTypes.length > 0) {\n             typeParameters = new LinkedHashMap<>(genericTypes.length);"
        },
        {
          "filename": "http-client/src/main/java/io/micronaut/http/client/exceptions/HttpClientErrorDecoder.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -71,7 +71,7 @@ default Argument<?> getErrorType(MediaType mediaType) {\n         } else if (mediaType.equals(MediaType.APPLICATION_VND_ERROR_TYPE)) {\n             return Argument.of(VndError.class);\n         } else {\n-            return Argument.of(String.class);\n+            return Argument.STRING;\n         }\n     }\n }"
        },
        {
          "filename": "http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -141,6 +141,7 @@ class RoutingInBoundHandler extends SimpleChannelInboundHandler<io.micronaut.htt\n     private static final Logger LOG = LoggerFactory.getLogger(RoutingInBoundHandler.class);\n     private static final Pattern IGNORABLE_ERROR_MESSAGE = Pattern.compile(\n             \"^.*(?:connection.*(?:reset|closed|abort|broken)|broken.*pipe).*$\", Pattern.CASE_INSENSITIVE);\n+    private static final Argument ARGUMENT_PART_DATA = Argument.of(PartData.class);\n \n     private final Router router;\n     private final ExecutorSelector executorSelector;\n@@ -769,7 +770,7 @@ protected void doOnNext(Object message) {\n                                 Argument typeVariable;\n \n                                 if (StreamingFileUpload.class.isAssignableFrom(argument.getType())) {\n-                                    typeVariable = Argument.of(PartData.class);\n+                                    typeVariable = ARGUMENT_PART_DATA;\n                                 } else {\n                                     typeVariable = argument.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n                                 }\n@@ -784,7 +785,7 @@ protected void doOnNext(Object message) {\n                                 if (Publishers.isConvertibleToPublisher(typeVariableType)) {\n                                     boolean streamingFileUpload = StreamingFileUpload.class.isAssignableFrom(typeVariableType);\n                                     if (streamingFileUpload) {\n-                                        typeVariable = Argument.of(PartData.class);\n+                                        typeVariable = ARGUMENT_PART_DATA;\n                                     } else {\n                                         typeVariable = typeVariable.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n                                     }"
        },
        {
          "filename": "http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/CompletableFutureBodyBinder.java",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -49,6 +49,8 @@\n public class CompletableFutureBodyBinder extends DefaultBodyAnnotationBinder<CompletableFuture>\n     implements NonBlockingBodyArgumentBinder<CompletableFuture> {\n \n+    private static final Argument<CompletableFuture> TYPE = Argument.of(CompletableFuture.class);\n+\n     private final BeanLocator beanLocator;\n     private final HttpServerConfiguration httpServerConfiguration;\n \n@@ -65,7 +67,7 @@ public CompletableFutureBodyBinder(BeanLocator beanLocator, HttpServerConfigurat\n \n     @Override\n     public Argument<CompletableFuture> argumentType() {\n-        return Argument.of(CompletableFuture.class);\n+        return TYPE;\n     }\n \n     @Override"
        },
        {
          "filename": "http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/PublisherBodyBinder.java",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -54,6 +54,7 @@\n public class PublisherBodyBinder extends DefaultBodyAnnotationBinder<Publisher> implements NonBlockingBodyArgumentBinder<Publisher> {\n \n     private static final Logger LOG = LoggerFactory.getLogger(NettyHttpServer.class);\n+    private static final Argument<Publisher> TYPE = Argument.of(Publisher.class);\n \n     private final BeanLocator beanLocator;\n     private final HttpServerConfiguration httpServerConfiguration;\n@@ -71,7 +72,7 @@ public PublisherBodyBinder(ConversionService conversionService, BeanLocator bean\n \n     @Override\n     public Argument<Publisher> argumentType() {\n-        return Argument.of(Publisher.class);\n+        return TYPE;\n     }\n \n     @Override"
        },
        {
          "filename": "http-server-netty/src/test/groovy/io/micronaut/http/server/netty/cors/CorsFilterSpec.groovy",
          "status": "modified",
          "additions": 10,
          "deletions": 9,
          "patch": "@@ -15,6 +15,7 @@\n  */\n package io.micronaut.http.server.netty.cors\n \n+import io.micronaut.core.convert.ConversionContext\n import io.micronaut.core.type.Argument\n import io.micronaut.http.HttpHeaders\n import io.micronaut.http.HttpMethod\n@@ -146,7 +147,7 @@ class CorsFilterSpec extends Specification {\n         2 * headers.getOrigin() >> Optional.of('http://www.foo.com')\n         1 * request.getMethod() >> HttpMethod.GET\n         !result.isPresent()\n-        0 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.of(List,String))\n+        0 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.of(Argument.of(List,String)))\n     }\n \n     void \"test preflight handleRequest with disallowed header\"() {\n@@ -170,8 +171,8 @@ class CorsFilterSpec extends Specification {\n \n         then: \"the request is rejected because bar is not allowed\"\n         2 * headers.getOrigin() >> Optional.of('http://www.foo.com')\n-        1 * headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.class) >> Optional.of(HttpMethod.GET)\n-        1 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.of(List,String)) >> ['foo', 'bar']\n+        1 * headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, ConversionContext.of(HttpMethod.class)) >> Optional.of(HttpMethod.GET)\n+        1 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.of(Argument.of(List,String))) >> ['foo', 'bar']\n         result.get().status == HttpStatus.FORBIDDEN\n     }\n \n@@ -196,8 +197,8 @@ class CorsFilterSpec extends Specification {\n \n         then: \"the request is successful\"\n         4 * headers.getOrigin() >> Optional.of('http://www.foo.com')\n-        2 * headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.class) >> Optional.of(HttpMethod.GET)\n-        2 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.of(List,String)) >> Optional.of(['foo'])\n+        2 * headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, ConversionContext.of(HttpMethod.class)) >> Optional.of(HttpMethod.GET)\n+        2 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.of(Argument.of(List,String))) >> Optional.of(['foo'])\n         result.get().status == HttpStatus.OK\n     }\n \n@@ -274,8 +275,8 @@ class CorsFilterSpec extends Specification {\n         HttpResponse response = corsHandler.handleRequest(request).get()\n \n         then: \"the response is not modified\"\n-        2 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.of(List,String)) >> Optional.of(['X-Header', 'Y-Header'])\n-        1 * headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.class) >> Optional.of(HttpMethod.GET)\n+        2 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.of(Argument.of(List,String))) >> Optional.of(['X-Header', 'Y-Header'])\n+        1 * headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, ConversionContext.of(HttpMethod.class)) >> Optional.of(HttpMethod.GET)\n         response.getHeaders().get(ACCESS_CONTROL_ALLOW_METHODS) == 'GET'\n         response.getHeaders().get(ACCESS_CONTROL_ALLOW_ORIGIN) == 'http://www.foo.com' // The origin is echo'd\n         response.getHeaders().get(VARY) == 'Origin' // The vary header is set\n@@ -305,8 +306,8 @@ class CorsFilterSpec extends Specification {\n         HttpResponse response = corsHandler.handleRequest(request).get()\n \n         then: \"the response is not modified\"\n-        2 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.of(List,String)) >> Optional.of(['X-Header', 'Y-Header'])\n-        1 * headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.class) >> Optional.of(HttpMethod.GET)\n+        2 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.of(Argument.of(List,String))) >> Optional.of(['X-Header', 'Y-Header'])\n+        1 * headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, ConversionContext.of(HttpMethod.class)) >> Optional.of(HttpMethod.GET)\n         response.getHeaders().get(ACCESS_CONTROL_ALLOW_METHODS) == 'GET'\n         response.getHeaders().get(ACCESS_CONTROL_ALLOW_ORIGIN) == 'http://www.foo.com' // The origin is echo'd\n         response.getHeaders().get(VARY) == 'Origin' // The vary header is set"
        },
        {
          "filename": "http-server/src/main/java/io/micronaut/http/server/cors/CorsFilter.java",
          "status": "modified",
          "additions": 8,
          "deletions": 5,
          "patch": "@@ -27,8 +27,9 @@\n import static io.micronaut.http.HttpHeaders.VARY;\n \n import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ArgumentConversionContext;\n+import io.micronaut.core.convert.ConversionContext;\n import io.micronaut.core.order.Ordered;\n-import io.micronaut.core.type.Argument;\n import io.micronaut.core.util.StringUtils;\n import io.micronaut.http.HttpHeaders;\n import io.micronaut.http.HttpMethod;\n@@ -59,6 +60,8 @@\n @Filter(\"/**\")\n public class CorsFilter implements HttpServerFilter {\n \n+    private static final ArgumentConversionContext<HttpMethod> CONVERSION_CONTEXT_HTTP_METHOD = ConversionContext.of(HttpMethod.class);\n+\n     protected final HttpServerConfiguration.CorsConfiguration corsConfiguration;\n \n     /**\n@@ -108,9 +111,9 @@ protected void handleResponse(HttpRequest<?> request, MutableHttpResponse<?> res\n                 CorsOriginConfiguration config = optionalConfig.get();\n \n                 if (CorsUtil.isPreflightRequest(request)) {\n-                    Optional<HttpMethod> result = headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.class);\n+                    Optional<HttpMethod> result = headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, CONVERSION_CONTEXT_HTTP_METHOD);\n                     setAllowMethods(result.get(), response);\n-                    Optional<List> allowedHeaders = headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.of(List.class, String.class));\n+                    Optional<List<String>> allowedHeaders = headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.LIST_OF_STRING);\n                     allowedHeaders.ifPresent(val ->\n                         setAllowHeaders(val, response)\n                     );\n@@ -150,14 +153,14 @@ protected Optional<MutableHttpResponse<?>> handleRequest(HttpRequest request) {\n                 List<HttpMethod> allowedMethods = config.getAllowedMethods();\n \n                 if (!isAnyMethod(allowedMethods)) {\n-                    HttpMethod methodToMatch = preflight ? headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.class).orElse(requestMethod) : requestMethod;\n+                    HttpMethod methodToMatch = preflight ? headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, CONVERSION_CONTEXT_HTTP_METHOD).orElse(requestMethod) : requestMethod;\n                     if (allowedMethods.stream().noneMatch(method -> method.equals(methodToMatch))) {\n                         return Optional.of(HttpResponse.status(HttpStatus.FORBIDDEN));\n                     }\n                 }\n \n                 if (preflight) {\n-                    Optional<List<String>> accessControlHeaders = headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.listOf(String.class));\n+                    Optional<List<String>> accessControlHeaders = headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.LIST_OF_STRING);\n \n                     List<String> allowedHeaders = config.getAllowedHeaders();\n "
        },
        {
          "filename": "http-server/src/main/java/io/micronaut/http/server/cors/CorsOriginConverter.java",
          "status": "modified",
          "additions": 10,
          "deletions": 6,
          "patch": "@@ -15,6 +15,7 @@\n  */\n package io.micronaut.http.server.cors;\n \n+import io.micronaut.core.convert.ArgumentConversionContext;\n import io.micronaut.core.convert.ConversionContext;\n import io.micronaut.core.convert.TypeConverter;\n import io.micronaut.core.convert.value.ConvertibleValues;\n@@ -23,6 +24,7 @@\n import io.micronaut.http.HttpMethod;\n \n import javax.inject.Singleton;\n+import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n \n@@ -43,6 +45,8 @@ public class CorsOriginConverter implements TypeConverter<Object, CorsOriginConf\n     private static final String ALLOW_CREDENTIALS = \"allowCredentials\";\n     private static final String MAX_AGE = \"maxAge\";\n \n+    private static final ArgumentConversionContext<List<HttpMethod>> CONVERSION_CONTEXT_LIST_OF_HTTP_METHOD = ConversionContext.of(Argument.listOf(HttpMethod.class));\n+\n     @Override\n     public Optional<CorsOriginConfiguration> convert(Object object, Class<CorsOriginConfiguration> targetType, ConversionContext context) {\n         CorsOriginConfiguration configuration = new CorsOriginConfiguration();\n@@ -51,27 +55,27 @@ public Optional<CorsOriginConfiguration> convert(Object object, Class<CorsOrigin\n             ConvertibleValues<Object> convertibleValues = new ConvertibleValuesMap<>(mapConfig);\n \n             convertibleValues\n-                .get(ALLOWED_ORIGINS, Argument.listOf(String.class))\n+                .get(ALLOWED_ORIGINS, ConversionContext.LIST_OF_STRING)\n                 .ifPresent(configuration::setAllowedOrigins);\n \n             convertibleValues\n-                .get(ALLOWED_METHODS, Argument.listOf(HttpMethod.class))\n+                .get(ALLOWED_METHODS, CONVERSION_CONTEXT_LIST_OF_HTTP_METHOD)\n                 .ifPresent(configuration::setAllowedMethods);\n \n             convertibleValues\n-                .get(ALLOWED_HEADERS, Argument.listOf(String.class))\n+                .get(ALLOWED_HEADERS, ConversionContext.LIST_OF_STRING)\n                 .ifPresent(configuration::setAllowedHeaders);\n \n             convertibleValues\n-                .get(EXPOSED_HEADERS, Argument.listOf(String.class))\n+                .get(EXPOSED_HEADERS, ConversionContext.LIST_OF_STRING)\n                 .ifPresent(configuration::setExposedHeaders);\n \n             convertibleValues\n-                .get(ALLOW_CREDENTIALS, Boolean.class)\n+                .get(ALLOW_CREDENTIALS, ConversionContext.BOOLEAN)\n                 .ifPresent(configuration::setAllowCredentials);\n \n             convertibleValues\n-                .get(MAX_AGE, Long.class)\n+                .get(MAX_AGE, ConversionContext.LONG)\n                 .ifPresent(configuration::setMaxAge);\n         }\n         return Optional.of(configuration);"
        },
        {
          "filename": "http/src/main/java/io/micronaut/http/HttpHeaders.java",
          "status": "modified",
          "additions": 7,
          "deletions": 6,
          "patch": "@@ -15,6 +15,7 @@\n  */\n package io.micronaut.http;\n \n+import io.micronaut.core.convert.ConversionContext;\n import io.micronaut.core.convert.ConversionService;\n import io.micronaut.core.type.Headers;\n \n@@ -470,7 +471,7 @@ default Integer getInt(CharSequence name) {\n      * @return An {@link Optional} of {@link Integer}\n      */\n     default Optional<Integer> findInt(CharSequence name) {\n-        return get(name, Integer.class);\n+        return get(name, ConversionContext.INT);\n     }\n \n     /**\n@@ -480,7 +481,7 @@ default Optional<Integer> findInt(CharSequence name) {\n      * @return The first value or null if it is present\n      */\n     default Optional<String> findFirst(CharSequence name) {\n-        return getFirst(name, String.class);\n+        return getFirst(name, ConversionContext.STRING);\n     }\n \n     /**\n@@ -489,7 +490,7 @@ default Optional<String> findFirst(CharSequence name) {\n      * @return The content type\n      */\n     default Optional<MediaType> contentType() {\n-        return getFirst(HttpHeaders.CONTENT_TYPE, MediaType.class);\n+        return getFirst(HttpHeaders.CONTENT_TYPE, MediaType.CONVERSION_CONTEXT);\n     }\n \n     /**\n@@ -498,7 +499,7 @@ default Optional<MediaType> contentType() {\n      * @return The content type\n      */\n     default OptionalLong contentLength() {\n-        Optional<Long> optional = getFirst(HttpHeaders.CONTENT_LENGTH, Long.class);\n+        Optional<Long> optional = getFirst(HttpHeaders.CONTENT_LENGTH, ConversionContext.LONG);\n         return optional.map(OptionalLong::of).orElseGet(OptionalLong::empty);\n     }\n \n@@ -511,7 +512,7 @@ default List<MediaType> accept() {\n         return getAll(HttpHeaders.ACCEPT)\n             .stream()\n             .flatMap(x -> Arrays.stream(x.split(\",\")))\n-            .flatMap(s -> ConversionService.SHARED.convert(s, MediaType.class).map(Stream::of).orElse(Stream.empty()))\n+            .flatMap(s -> ConversionService.SHARED.convert(s, MediaType.CONVERSION_CONTEXT).map(Stream::of).orElse(Stream.empty()))\n             .distinct()\n             .collect(Collectors.toList());\n     }\n@@ -520,7 +521,7 @@ default List<MediaType> accept() {\n      * @return Whether the {@link HttpHeaders#CONNECTION} header is set to Keep-Alive\n      */\n     default boolean isKeepAlive() {\n-        return getFirst(CONNECTION, String.class).map(val -> val.equalsIgnoreCase(\"keep-alive\")).orElse(false);\n+        return getFirst(CONNECTION, ConversionContext.STRING).map(val -> val.equalsIgnoreCase(\"keep-alive\")).orElse(false);\n     }\n \n     /**"
        },
        {
          "filename": "http/src/main/java/io/micronaut/http/MediaType.java",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -15,9 +15,13 @@\n  */\n package io.micronaut.http;\n \n+import io.micronaut.core.annotation.Internal;\n import io.micronaut.core.annotation.TypeHint;\n+import io.micronaut.core.convert.ArgumentConversionContext;\n+import io.micronaut.core.convert.ConversionContext;\n import io.micronaut.core.convert.ConversionService;\n import io.micronaut.core.naming.NameUtils;\n+import io.micronaut.core.type.Argument;\n import io.micronaut.core.util.StringUtils;\n import io.micronaut.core.value.OptionalValues;\n import io.micronaut.http.annotation.Produces;\n@@ -318,6 +322,12 @@ public class MediaType implements CharSequence {\n      */\n     public static final String V_PARAMETER = \"v\";\n \n+    @Internal\n+    static final Argument<MediaType> ARGUMENT = Argument.of(MediaType.class);\n+\n+    @Internal\n+    static final ArgumentConversionContext<MediaType> CONVERSION_CONTEXT = ConversionContext.of(ARGUMENT);\n+\n     private static final BigDecimal QUALITY_RATING_NUMBER = new BigDecimal(\"1.0\");\n     private static final String QUALITY_RATING = \"1.0\";\n     private static final String SEMICOLON = \";\";"
        },
        {
          "filename": "runtime/src/main/java/io/micronaut/cache/interceptor/CacheInterceptor.java",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -259,7 +259,7 @@ protected Object interceptCompletableFuture(MethodInvocationContext<Object, Obje\n             Object[] params = resolveParams(context, cacheable.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n             Object key = keyGenerator.generateKey(context, params);\n             CompletableFuture<Object> thisFuture = new CompletableFuture<>();\n-            Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.of(Object.class));\n+            Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n             asyncCache.get(key, firstTypeVariable).whenComplete((BiConsumer<Optional<?>, Throwable>) (o, throwable) -> {\n                 if (throwable == null && o.isPresent()) {\n                     // cache hit, return result\n@@ -503,7 +503,7 @@ private Publisher<Object> buildCacheablePublisher(\n         CacheKeyGenerator keyGenerator = resolveKeyGenerator(cacheOperation.defaultKeyGenerator, cacheable);\n         Object[] params = resolveParams(context, cacheable.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n         Object key = keyGenerator.generateKey(context, params);\n-        Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.of(Object.class));\n+        Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n \n         Maybe<Object> maybe = Maybe.create(emitter -> {\n             asyncCache.get(key, firstTypeVariable).whenComplete((opt, throwable) -> {"
        },
        {
          "filename": "runtime/src/main/java/io/micronaut/scheduling/io/watch/FileWatchCondition.java",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -20,7 +20,7 @@\n import io.micronaut.context.condition.Condition;\n import io.micronaut.context.condition.ConditionContext;\n import io.micronaut.core.annotation.Introspected;\n-import io.micronaut.core.type.Argument;\n+import io.micronaut.core.convert.ConversionContext;\n import io.micronaut.core.util.CollectionUtils;\n \n import java.io.File;\n@@ -40,7 +40,7 @@ public boolean matches(ConditionContext context) {\n         if (beanContext instanceof ApplicationContext) {\n             List<String> paths = ((ApplicationContext) beanContext)\n                     .getEnvironment()\n-                    .getProperty(FileWatchConfiguration.PATHS, Argument.listOf(String.class))\n+                    .getProperty(FileWatchConfiguration.PATHS, ConversionContext.LIST_OF_STRING)\n                     .orElse(null);\n \n             if (CollectionUtils.isNotEmpty(paths)) {"
        },
        {
          "filename": "session/src/main/java/io/micronaut/session/binder/SessionArgumentBinder.java",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -42,6 +42,8 @@\n @Requires(classes = HttpServerConfiguration.class)\n public class SessionArgumentBinder implements TypedRequestArgumentBinder<Session> {\n \n+    private static final Argument<Session> TYPE = Argument.of(Session.class);\n+\n     private final SessionStore<Session> sessionStore;\n \n     /**\n@@ -55,7 +57,7 @@ public SessionArgumentBinder(SessionStore<Session> sessionStore) {\n \n     @Override\n     public Argument<Session> argumentType() {\n-        return Argument.of(Session.class);\n+        return TYPE;\n     }\n \n     @Override"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 12,
        "max_directory_depth": 10
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "6e8753361c5c55c6402c33cca6e40aae89ab31f8",
            "date": "2025-01-26T05:16:20Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "f2809e8e2233de1dec304f072df72022e2c63061",
            "date": "2025-01-26T02:17:39Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "5f3af8f45cabb2a416453a934e79c6d4c21f274c",
            "date": "2025-01-24T17:49:06Z",
            "author_login": "graemerocher"
          },
          {
            "sha": "466bfe1f7af8db623c7bbfc6185bd0568481fe84",
            "date": "2025-01-24T12:01:32Z",
            "author_login": "yawkat"
          },
          {
            "sha": "7fe5f259115728e441470331af7be6ea814e6eab",
            "date": "2025-01-24T10:11:24Z",
            "author_login": "yawkat"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-400",
    "description": "Micronaut is a JVM-based, full stack Java framework designed for building JVM web applications with support for Java, Kotlin and the Groovy language. In affected versions sending an invalid Content Type header leads to memory leak in DefaultArgumentConversionContext as this type is erroneously used in static state. ### Impact Sending an invalid Content Type header leads to memory leak in `DefaultArgumentConversionContext` as this type is erroneously used in static state. ### Patches The problem is patched in Micronaut 3.2.7 and above. ### Workarounds The default content type binder can be replaced in an existing Micronaut application to mitigate the issue: ```java package example; import java.util.List; import io.micronaut.context.annotation.Replaces; import io.micronaut.core.convert.ConversionService; import io.micronaut.http.MediaType; import io.micronaut.http.bind.DefaultRequestBinderRegistry; import io.micronaut.http.bind.binders.RequestArgumentBinder; import jakarta.inject.Singleton; @Singleton @Replaces(DefaultRequestBinderRegistry.class) class FixedRequestBinderRegistry extends DefaultRequestBinderRegistry { public FixedRequestBinderRegistry(ConversionService conversionService, List<RequestArgumentBinder> binders) { super(conversionService, binders); } @Override protected void registerDefaultConverters(ConversionService<?> conversionService) { super.registerDefaultConverters(conversionService); conversionService.addConverter(CharSequence.class, MediaType.class, charSequence -> { try { return MediaType.of(charSequence); } catch (IllegalArgumentException e) { return null; } }); } } ``` ### References Commit that introduced the vulnerability https://github.com/micronaut-projects/micronaut-core/commit/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3 ### For more information If you have any questions or comments about this advisory: * Open an issue in [Micronaut Core](https://github.com/micronaut-projects/micronaut-core/issues) * Email us at [info@micronaut.io](mailto:info@micronaut.io)",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-01-18T23:15:08.840",
    "last_modified": "2024-11-21T06:45:15.750",
    "fix_date": "2019-11-18T07:23:08Z"
  },
  "references": [
    {
      "url": "https://github.com/micronaut-projects/micronaut-core/commit/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/micronaut-projects/micronaut-core/security/advisories/GHSA-2457-2263-mm9f",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/micronaut-projects/micronaut-core/commit/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/micronaut-projects/micronaut-core/security/advisories/GHSA-2457-2263-mm9f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:57.040558",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "micronaut-core",
    "owner": "micronaut-projects",
    "created_at": "2018-03-07T12:05:08Z",
    "updated_at": "2025-01-26T05:16:25Z",
    "pushed_at": "2025-01-26T05:16:22Z",
    "size": 106313,
    "stars": 6141,
    "forks": 1081,
    "open_issues": 777,
    "watchers": 6141,
    "has_security_policy": false,
    "default_branch": "4.8.x",
    "protected_branches": [
      "1.0.x",
      "1.1.x",
      "1.2.x",
      "1.3.x",
      "2.0.x",
      "2.1.x",
      "2.2.x",
      "2.3.x",
      "2.4.x",
      "2.5.x",
      "3.0.x",
      "3.1.x",
      "3.2.x",
      "3.3.x",
      "3.4.x",
      "3.5.x",
      "3.6.x",
      "3.7.x",
      "3.8.x",
      "3.9.x",
      "3.10.x",
      "4.0.x",
      "4.1.x",
      "4.2.x",
      "4.3.x",
      "4.4.x",
      "4.5.x",
      "4.6.x",
      "4.7.x",
      "4.8.x"
    ],
    "languages": {
      "Java": 13241975,
      "Groovy": 7097202,
      "Kotlin": 1689030,
      "HTML": 143,
      "Shell": 14
    },
    "commit_activity": {
      "total_commits_last_year": 816,
      "avg_commits_per_week": 15.692307692307692,
      "days_active_last_year": 214
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T08:14:08.829542"
  }
}