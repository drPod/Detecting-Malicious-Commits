{
  "cve_id": "CVE-2022-21706",
  "github_data": {
    "repository": "zulip/zulip",
    "fix_commit": "88917019f03860609114082cdc0f31a561503f9e",
    "related_commits": [
      "88917019f03860609114082cdc0f31a561503f9e",
      "88917019f03860609114082cdc0f31a561503f9e"
    ],
    "patch_url": "https://github.com/zulip/zulip/commit/88917019f03860609114082cdc0f31a561503f9e.patch",
    "fix_commit_details": {
      "sha": "88917019f03860609114082cdc0f31a561503f9e",
      "commit_date": "2022-01-23T12:22:12Z",
      "author": {
        "login": "mateuszmandera",
        "type": "User",
        "stats": {
          "total_commits": 1273,
          "average_weekly_commits": 1.9675425038639875,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 268
        }
      },
      "commit_message": {
        "title": "CVE-2022-21706: Prevent use of multiuse invites to join other orgs.",
        "length": 523,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 100,
        "additions": 91,
        "deletions": 9
      },
      "files": [
        {
          "filename": "zerver/tests/test_auth_backends.py",
          "status": "modified",
          "additions": 43,
          "deletions": 0,
          "patch": "@@ -91,6 +91,7 @@\n     PreregistrationUser,\n     Realm,\n     RealmDomain,\n+    Stream,\n     UserProfile,\n     clear_supported_auth_backends_cache,\n     email_to_username,\n@@ -1582,6 +1583,48 @@ def test_social_auth_registration_using_multiuse_invite(self) -> None:\n             result, realm, subdomain, email, name, name, self.BACKEND_CLASS.full_name_validated\n         )\n \n+    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n+    def test_social_auth_registration_using_multiuse_invite_realm_validation(self) -> None:\n+        \"\"\"If the user doesn't exist yet, social auth can be used to register an account\"\"\"\n+        email = \"newuser@zulip.com\"\n+        name = \"Full Name\"\n+        subdomain = \"zulip\"\n+        realm = get_realm(\"zulip\")\n+        realm.invite_required = True\n+        realm.save()\n+\n+        streams: List[Stream] = []\n+\n+        # Generate an invitation for a different realm than the one we'll attempt to join:\n+        lear_realm = get_realm(\"lear\")\n+        multiuse_obj = MultiuseInvite.objects.create(\n+            realm=lear_realm, referred_by=UserProfile.objects.filter(realm=lear_realm).first()\n+        )\n+        multiuse_obj.streams.set(streams)\n+        validity_in_days = 2\n+        create_confirmation_link(\n+            multiuse_obj, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n+        )\n+        multiuse_confirmation = Confirmation.objects.all().last()\n+        assert multiuse_confirmation is not None\n+        multiuse_object_key = multiuse_confirmation.confirmation_key\n+        account_data_dict = self.get_account_data_dict(email=email, name=name)\n+\n+        # Now we try to use the invitation for the lear realm to join the zulip realm,\n+        # which should fail.\n+        result = self.social_auth_test(\n+            account_data_dict,\n+            subdomain=subdomain,\n+            is_signup=True,\n+            expect_choose_email_screen=True,\n+            multiuse_object_key=multiuse_object_key,\n+        )\n+\n+        result = self.client_get(result.url)\n+        self.assert_in_response(\n+            \"Whoops. We couldn't find your confirmation link in the system.\", result\n+        )\n+\n     def test_social_auth_registration_without_is_signup(self) -> None:\n         \"\"\"If `is_signup` is not set then a new account isn't created\"\"\"\n         email = \"newuser@zulip.com\""
        },
        {
          "filename": "zerver/tests/test_signup.py",
          "status": "modified",
          "additions": 30,
          "deletions": 1,
          "patch": "@@ -11,7 +11,7 @@\n from django.contrib.auth.views import PasswordResetConfirmView\n from django.contrib.contenttypes.models import ContentType\n from django.core.exceptions import ValidationError\n-from django.http import HttpResponse\n+from django.http import HttpRequest, HttpResponse\n from django.test import Client, override_settings\n from django.urls import reverse\n from django.utils.timezone import now as timezone_now\n@@ -107,6 +107,7 @@\n from zerver.views.auth import redirect_and_log_into_subdomain, start_two_factor_auth\n from zerver.views.development.registration import confirmation_key\n from zerver.views.invite import get_invitee_emails_set\n+from zerver.views.registration import accounts_home\n from zproject.backends import ExternalAuthDataDict, ExternalAuthResult\n \n \n@@ -2903,6 +2904,34 @@ def test_multiuse_link_with_specified_streams(self) -> None:\n         self.check_user_able_to_register(email2, invite_link)\n         self.check_user_subscribed_only_to_streams(name2, streams)\n \n+    def test_multiuse_link_different_realms(self) -> None:\n+        \"\"\"\n+        Verify that an invitation generated for one realm can't be used\n+        to join another.\n+        \"\"\"\n+        lear_realm = get_realm(\"lear\")\n+        self.realm = lear_realm\n+        invite_link = self.generate_multiuse_invite_link(streams=[])\n+        key = invite_link.split(\"/\")[-2]\n+\n+        result = self.client_get(f\"/join/{key}/\", subdomain=\"zulip\")\n+        self.assertEqual(result.status_code, 404)\n+        self.assert_in_response(\n+            \"Whoops. We couldn't find your confirmation link in the system.\", result\n+        )\n+\n+        # Now we want to test the accounts_home function, which can't be used\n+        # for the multiuse invite case via an HTTP request, but is still supposed\n+        # to do its own verification that the realms match as a hardening measure\n+        # against a caller that fails to do that.\n+        request = HttpRequest()\n+        confirmation = Confirmation.objects.get(confirmation_key=key)\n+        multiuse_object = confirmation.content_object\n+        with patch(\n+            \"zerver.views.registration.get_subdomain\", return_value=\"zulip\"\n+        ), self.assertRaises(AssertionError):\n+            accounts_home(request, multiuse_object=multiuse_object)\n+\n     def test_create_multiuse_link_api_call(self) -> None:\n         self.login(\"iago\")\n "
        },
        {
          "filename": "zerver/views/auth.py",
          "status": "modified",
          "additions": 10,
          "deletions": 6,
          "patch": "@@ -181,8 +181,14 @@ def maybe_send_to_registration(\n             request.session, \"registration_desktop_flow_otp\", desktop_flow_otp, expiry_seconds=3600\n         )\n \n+    try:\n+        # TODO: This should use get_realm_from_request, but a bunch of tests\n+        # rely on mocking get_subdomain here, so they'll need to be tweaked first.\n+        realm: Optional[Realm] = get_realm(get_subdomain(request))\n+    except Realm.DoesNotExist:\n+        realm = None\n+\n     multiuse_obj: Optional[MultiuseInvite] = None\n-    realm: Optional[Realm] = None\n     from_multiuse_invite = False\n     if multiuse_object_key:\n         from_multiuse_invite = True\n@@ -192,13 +198,11 @@ def maybe_send_to_registration(\n             return render_confirmation_key_error(request, exception)\n \n         assert multiuse_obj is not None\n-        realm = multiuse_obj.realm\n+        if realm != multiuse_obj.realm:\n+            return render(request, \"confirmation/link_does_not_exist.html\", status=404)\n+\n         invited_as = multiuse_obj.invited_as\n     else:\n-        try:\n-            realm = get_realm(get_subdomain(request))\n-        except Realm.DoesNotExist:\n-            pass\n         invited_as = PreregistrationUser.INVITE_AS[\"MEMBER\"]\n \n     form = HomepageForm({\"email\": email}, realm=realm, from_multiuse_invite=from_multiuse_invite)"
        },
        {
          "filename": "zerver/views/registration.py",
          "status": "modified",
          "additions": 8,
          "deletions": 2,
          "patch": "@@ -676,7 +676,11 @@ def accounts_home(\n     invited_as = None\n \n     if multiuse_object:\n-        realm = multiuse_object.realm\n+        # multiuse_object's realm should have been validated by the caller,\n+        # so this code shouldn't be reachable with a multiuse_object which\n+        # has its realm mismatching the realm of the request.\n+        assert realm == multiuse_object.realm\n+\n         streams_to_subscribe = multiuse_object.streams.all()\n         from_multiuse_invite = True\n         invited_as = multiuse_object.invited_as\n@@ -726,12 +730,14 @@ def accounts_home(\n \n \n def accounts_home_from_multiuse_invite(request: HttpRequest, confirmation_key: str) -> HttpResponse:\n+    realm = get_realm_from_request(request)\n     multiuse_object = None\n     try:\n         multiuse_object = get_object_from_key(confirmation_key, [Confirmation.MULTIUSE_INVITE])\n+        if realm != multiuse_object.realm:\n+            return render(request, \"confirmation/link_does_not_exist.html\", status=404)\n         # Required for OAuth 2\n     except ConfirmationKeyException as exception:\n-        realm = get_realm_from_request(request)\n         if realm is None or realm.invite_required:\n             return render_confirmation_key_error(request, exception)\n     return accounts_home("
        }
      ],
      "file_patterns": {
        "security_files": 2,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "99ea0255da6d835e98f12adb7100af0f6d9ccb85",
            "date": "2025-01-09T06:57:21Z",
            "author_login": "mateuszmandera"
          },
          {
            "sha": "4196859cd65d373537a0a6092ffe8dc2a6b09ada",
            "date": "2025-01-09T05:56:09Z",
            "author_login": "mateuszmandera"
          },
          {
            "sha": "67887324ed74f9196aff2c26c40f5937ff811819",
            "date": "2024-11-19T21:51:08Z",
            "author_login": "mateuszmandera"
          },
          {
            "sha": "8b09190bcd129ea5e46509343049e595b92f06d9",
            "date": "2025-01-13T13:33:06Z",
            "author_login": "amanagr"
          },
          {
            "sha": "a05cbfa0c9e41e2fa2930b28653076279ae7bda0",
            "date": "2025-01-13T13:24:09Z",
            "author_login": "amanagr"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.2,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:N",
    "cwe_id": "CWE-284",
    "description": "Zulip is an open-source team collaboration tool with topic-based threading. Zulip Server version 2.0.0 and above are vulnerable to insufficient access control with multi-use invitations. A Zulip Server deployment which hosts multiple organizations is vulnerable to an attack where an invitation created in one organization (potentially as a role with elevated permissions) can be used to join any other organization. This bypasses any restrictions on required domains on users' email addresses, may be used to gain access to organizations which are only accessible by invitation, and may be used to gain access with elevated privileges. This issue has been patched in release 4.10. There are no known workarounds for this issue. ### Patches _Has the problem been patched? What versions should users upgrade to?_ ### Workarounds _Is there a way for users to fix or remediate the vulnerability without upgrading?_ ### References _Are there any links users can visit to find out more?_ ### For more information If you have any questions or comments about this advisory, you can discuss them on the [developer community Zulip server](https://zulip.com/developer-community/), or email the [Zulip security team](mailto:security@zulip.com).",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-02-26T00:15:08.260",
    "last_modified": "2024-11-21T06:45:16.603",
    "fix_date": "2022-01-23T12:22:12Z"
  },
  "references": [
    {
      "url": "https://blog.zulip.com/2022/02/25/zulip-cloud-invitation-vulnerability/",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://blog.zulip.com/2022/02/25/zulip-server-4-10-security-release/#cve-2022-21706",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/zulip/zulip/commit/88917019f03860609114082cdc0f31a561503f9e",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/zulip/zulip/security/advisories/GHSA-6xmj-2wcm-p2jc",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://blog.zulip.com/2022/02/25/zulip-cloud-invitation-vulnerability/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://blog.zulip.com/2022/02/25/zulip-server-4-10-security-release/#cve-2022-21706",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/zulip/zulip/commit/88917019f03860609114082cdc0f31a561503f9e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/zulip/zulip/security/advisories/GHSA-6xmj-2wcm-p2jc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:59.755760",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "zulip",
    "owner": "zulip",
    "created_at": "2015-09-25T16:37:25Z",
    "updated_at": "2025-01-14T13:31:30Z",
    "pushed_at": "2025-01-14T02:34:21Z",
    "size": 495185,
    "stars": 21946,
    "forks": 8107,
    "open_issues": 2487,
    "watchers": 21946,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "1.4.x",
      "1.5.x",
      "1.8.x",
      "1.9.x",
      "2.0.x",
      "2.1.x",
      "3.x",
      "3.1-with-bmemcached",
      "4.x",
      "4.0-rc1-branch",
      "5.x",
      "5.x-user-sharding",
      "5.0-rc1-branch",
      "5.0-rc2-branch",
      "6.x",
      "6.0-beta1-branch",
      "6.0-rc1-branch",
      "7.x",
      "7.0-beta1-branch",
      "7.0-beta2-branch",
      "8.x",
      "9.x",
      "buddy-list-prep",
      "chat.zulip.org",
      "dockertest",
      "main",
      "s3-compatible-uploads",
      "zulip-cloud-current"
    ],
    "languages": {
      "Python": 14193798,
      "TypeScript": 4055572,
      "JavaScript": 2278673,
      "HTML": 957053,
      "CSS": 942085,
      "Handlebars": 597145,
      "Shell": 161466,
      "Puppet": 137563,
      "Perl": 10353,
      "Dockerfile": 4219,
      "Ruby": 3794,
      "Emacs Lisp": 157
    },
    "commit_activity": {
      "total_commits_last_year": 6397,
      "avg_commits_per_week": 123.01923076923077,
      "days_active_last_year": 356
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:44:17.890508"
  }
}