{
  "cve_id": "CVE-2022-21708",
  "github_data": {
    "repository": "graph-gophers/graphql-go",
    "fix_commit": "eae31ca73eb3473c544710955d1dbebc22605bfe",
    "related_commits": [
      "eae31ca73eb3473c544710955d1dbebc22605bfe",
      "eae31ca73eb3473c544710955d1dbebc22605bfe"
    ],
    "patch_url": "https://github.com/graph-gophers/graphql-go/commit/eae31ca73eb3473c544710955d1dbebc22605bfe.patch",
    "fix_commit_details": {
      "sha": "eae31ca73eb3473c544710955d1dbebc22605bfe",
      "commit_date": "2022-01-18T21:14:45Z",
      "author": {
        "login": "tonyghita",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "validation: fix bug in maxDepth fragment spread logic (#492)",
        "length": 60,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 120,
        "additions": 113,
        "deletions": 7
      },
      "files": [
        {
          "filename": "graphql_test.go",
          "status": "modified",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -4297,3 +4297,32 @@ func TestInterfaceImplementingInterface(t *testing.T) {\n \t\t\t`,\n \t}})\n }\n+\n+func TestCircularFragmentMaxDepth(t *testing.T) {\n+\twithMaxDepth := graphql.MustParseSchema(starwars.Schema, &starwars.Resolver{}, graphql.MaxDepth(2))\n+\tgqltesting.RunTests(t, []*gqltesting.Test{\n+\t\t{\n+\t\t\tSchema: withMaxDepth,\n+\t\t\tQuery: `\n+\t              query {\n+\t                  ...X\n+\t              }\n+\n+\t              fragment X on Query {\n+\t                  ...Y\n+\t              }\n+\t              fragment Y on Query {\n+\t                  ...X\n+\t              }\n+\t          `,\n+\t\t\tExpectedErrors: []*gqlerrors.QueryError{{\n+\t\t\t\tMessage: `Cannot spread fragment \"X\" within itself via Y.`,\n+\t\t\t\tRule:    \"NoFragmentCycles\",\n+\t\t\t\tLocations: []gqlerrors.Location{\n+\t\t\t\t\t{Line: 7, Column: 20},\n+\t\t\t\t\t{Line: 10, Column: 20},\n+\t\t\t\t},\n+\t\t\t}},\n+\t\t},\n+\t})\n+}"
        },
        {
          "filename": "internal/validation/validate_max_depth_test.go",
          "status": "modified",
          "additions": 65,
          "deletions": 2,
          "patch": "@@ -34,6 +34,7 @@ const (\n \t\tid: ID!\n \t\tname: String!\n \t\tfriends: [Character]\n+\t\tenemies: [Character]\n \t\tappearsIn: [Episode]!\n \t}\n \n@@ -43,12 +44,15 @@ const (\n \t\tJEDI\n \t}\n \n-\ttype Starship {}\n+\ttype Starship {\n+\t\tid: ID!\n+\t}\n \n \ttype Human implements Character {\n \t\tid: ID!\n \t\tname: String!\n \t\tfriends: [Character]\n+\t\tenemies: [Character]\n \t\tappearsIn: [Episode]!\n \t\tstarships: [Starship]\n \t\ttotalCredits: Int\n@@ -58,6 +62,7 @@ const (\n \t\tid: ID!\n \t\tname: String!\n \t\tfriends: [Character]\n+\t\tenemies: [Character]\n \t\tappearsIn: [Episode]!\n \t\tprimaryFunction: String\n \t}`\n@@ -304,6 +309,64 @@ func TestMaxDepthFragmentSpreads(t *testing.T) {\n \t\t\tdepth:   6,\n \t\t\tfailure: true,\n \t\t},\n+\t\t{\n+\t\t\tname: \"spreadAtDifferentDepths\",\n+\t\t\tquery: `\n+\t\t\tfragment character on Character {\n+\t\t\t\tname # depth + 0\n+\t\t\t\tfriends { # depth + 0\n+\t\t\t\t\tname # depth + 1\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tquery laterDepthValidated {\n+\t\t\t\t...character # depth 1 (+1)\n+\t\t\t\tenemies { # depth 1\n+\t\t\t\t\tfriends { # depth 2\n+\t\t\t\t\t\t...character # depth 2 (+1), should error!\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t`,\n+\t\t\tdepth:   2,\n+\t\t\tfailure: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"spreadAtSameDepth\",\n+\t\t\tquery: `\n+\t\t\tfragment character on Character {\n+\t\t\t\tname # depth + 0\n+\t\t\t\tfriends { # depth + 0\n+\t\t\t\t\tname # depth + 1\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tquery {\n+\t\t\t\tcharacters { # depth 1\n+\t\t\t\t\tfriends { # depth 2\n+\t\t\t\t\t\t...character # depth 3 (+1)\n+\t\t\t\t\t}\n+\t\t\t\t\tenemies { # depth 2\n+\t\t\t\t\t\t...character # depth 3 (+1)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t`,\n+\t\t\tdepth: 4,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"fragmentCycle\",\n+\t\t\tquery: `\n+\t\t\tfragment X on Query { ...Y }\n+\t\t\tfragment Y on Query { ...Z }\n+\t\t\tfragment Z on Query { ...X }\n+\n+\t\t\tquery {\n+\t\t\t\t...X\n+\t\t\t}\n+\t\t\t`,\n+\t\t\tdepth:   10,\n+\t\t\tfailure: true,\n+\t\t},\n \t} {\n \t\ttc.Run(t, s)\n \t}\n@@ -431,7 +494,7 @@ func TestMaxDepthValidation(t *testing.T) {\n \n \t\t\topc := &opContext{context: context, ops: doc.Operations}\n \n-\t\t\tactual := validateMaxDepth(opc, op.Selections, 1)\n+\t\t\tactual := validateMaxDepth(opc, op.Selections, nil, 1)\n \t\t\tif actual != tc.expected {\n \t\t\t\tt.Errorf(\"expected %t, actual %t\", tc.expected, actual)\n \t\t\t}"
        },
        {
          "filename": "internal/validation/validation.go",
          "status": "modified",
          "additions": 19,
          "deletions": 5,
          "patch": "@@ -76,7 +76,7 @@ func Validate(s *types.Schema, doc *types.ExecutableDefinition, variables map[st\n \n \t\t// Check if max depth is exceeded, if it's set. If max depth is exceeded,\n \t\t// don't continue to validate the document and exit early.\n-\t\tif validateMaxDepth(opc, op.Selections, 1) {\n+\t\tif validateMaxDepth(opc, op.Selections, nil, 1) {\n \t\t\treturn c.errs\n \t\t}\n \n@@ -235,13 +235,19 @@ func validateValue(c *opContext, v *types.InputValueDefinition, val interface{},\n \n // validates the query doesn't go deeper than maxDepth (if set). Returns whether\n // or not query validated max depth to avoid excessive recursion.\n-func validateMaxDepth(c *opContext, sels []types.Selection, depth int) bool {\n+//\n+// The visited map is necessary to ensure that max depth validation does not get stuck in cyclical\n+// fragment spreads.\n+func validateMaxDepth(c *opContext, sels []types.Selection, visited map[*types.FragmentDefinition]struct{}, depth int) bool {\n \t// maxDepth checking is turned off when maxDepth is 0\n \tif c.maxDepth == 0 {\n \t\treturn false\n \t}\n \n \texceededMaxDepth := false\n+\tif visited == nil {\n+\t\tvisited = map[*types.FragmentDefinition]struct{}{}\n+\t}\n \n \tfor _, sel := range sels {\n \t\tswitch sel := sel.(type) {\n@@ -251,11 +257,12 @@ func validateMaxDepth(c *opContext, sels []types.Selection, depth int) bool {\n \t\t\t\tc.addErr(sel.Alias.Loc, \"MaxDepthExceeded\", \"Field %q has depth %d that exceeds max depth %d\", sel.Name.Name, depth, c.maxDepth)\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\texceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, sel.SelectionSet, depth+1)\n+\t\t\texceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, sel.SelectionSet, visited, depth+1)\n+\n \t\tcase *types.InlineFragment:\n \t\t\t// Depth is not checked because inline fragments resolve to other fields which are checked.\n \t\t\t// Depth is not incremented because inline fragments have the same depth as neighboring fields\n-\t\t\texceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, sel.Selections, depth)\n+\t\t\texceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, sel.Selections, visited, depth)\n \t\tcase *types.FragmentSpread:\n \t\t\t// Depth is not checked because fragments resolve to other fields which are checked.\n \t\t\tfrag := c.doc.Fragments.Get(sel.Name.Name)\n@@ -264,8 +271,15 @@ func validateMaxDepth(c *opContext, sels []types.Selection, depth int) bool {\n \t\t\t\tc.addErr(sel.Loc, \"MaxDepthEvaluationError\", \"Unknown fragment %q. Unable to evaluate depth.\", sel.Name.Name)\n \t\t\t\tcontinue\n \t\t\t}\n+\n+\t\t\tif _, ok := visited[frag]; ok {\n+\t\t\t\t// we've already seen this fragment, don't check depth again.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tvisited[frag] = struct{}{}\n+\n \t\t\t// Depth is not incremented because fragments have the same depth as surrounding fields\n-\t\t\texceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, frag.Selections, depth)\n+\t\t\texceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, frag.Selections, visited, depth)\n \t\t}\n \t}\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8fb462468c986c352c3da5e490f573582cc049ee",
            "date": "2024-12-06T00:23:56Z",
            "author_login": "pavelnikolov"
          },
          {
            "sha": "c7ab88dfb69606e541d6b847ab220dcd03fceeb0",
            "date": "2024-12-05T23:06:41Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "50fd0f483f68371ceccdadb5524ce9e8c70fd1ac",
            "date": "2024-10-19T10:30:43Z",
            "author_login": "pavelnikolov"
          },
          {
            "sha": "c5a18114747f4b79a3a7eb61a641d7db99965c34",
            "date": "2024-10-19T10:29:11Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "658f3274b01d69e588827a2af2f0d5af8c1d3810",
            "date": "2024-09-21T07:29:03Z",
            "author_login": "pavelnikolov"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "graphql-go is a GraphQL server with a focus on ease of use. In versions prior to 1.3.0 there exists a DoS vulnerability that is possible due to a bug in the library that would allow an attacker with specifically designed queries to cause stack overflow panics. Any user with access to the GraphQL handler can send these queries and cause stack overflows. This in turn could potentially compromise the ability of the server to serve data to its users. The issue has been patched in version `v1.3.0`. The only known workaround for this issue is to disable the `graphql.MaxDepth` option from your schema which is not recommended.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-01-21T23:15:08.457",
    "last_modified": "2024-11-21T06:45:16.903",
    "fix_date": "2022-01-18T21:14:45Z"
  },
  "references": [
    {
      "url": "https://github.com/graph-gophers/graphql-go/commit/eae31ca73eb3473c544710955d1dbebc22605bfe",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/graph-gophers/graphql-go/security/advisories/GHSA-mh3m-8c74-74xh",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/graph-gophers/graphql-go/commit/eae31ca73eb3473c544710955d1dbebc22605bfe",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/graph-gophers/graphql-go/security/advisories/GHSA-mh3m-8c74-74xh",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:57.058879",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "graphql-go",
    "owner": "graph-gophers",
    "created_at": "2016-10-18T13:57:24Z",
    "updated_at": "2025-01-14T07:42:54Z",
    "pushed_at": "2024-12-06T00:24:01Z",
    "size": 1705,
    "stars": 4669,
    "forks": 490,
    "open_issues": 45,
    "watchers": 4669,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Go": 481201,
      "Shell": 10738,
      "HTML": 2431,
      "JavaScript": 546
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-2-clause"
    },
    "collected_at": "2025-01-14T14:04:53.491590"
  }
}