{
  "cve_id": "CVE-2022-21725",
  "github_data": {
    "repository": "tensorflow/tensorflow",
    "fix_commit": "3218043d6d3a019756607643cf65574fbfef5d7a",
    "related_commits": [
      "3218043d6d3a019756607643cf65574fbfef5d7a",
      "3218043d6d3a019756607643cf65574fbfef5d7a"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "3218043d6d3a019756607643cf65574fbfef5d7a",
      "commit_date": "2021-11-23T22:27:24Z",
      "author": {
        "login": "ishark",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Internal change",
        "length": 98,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 100,
        "additions": 83,
        "deletions": 17
      },
      "files": [
        {
          "filename": "tensorflow/core/grappler/costs/BUILD",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -355,6 +355,7 @@ tf_cc_test(\n         \"//tensorflow/core:protos_all_cc\",\n         \"//tensorflow/core:test\",\n         \"//tensorflow/core:test_main\",\n+        \"//tensorflow/core/platform:status_matchers\",\n     ],\n )\n "
        },
        {
          "filename": "tensorflow/core/grappler/costs/op_level_cost_estimator.cc",
          "status": "modified",
          "additions": 24,
          "deletions": 13,
          "patch": "@@ -2153,7 +2153,7 @@ OpInfo::TensorProperties OpLevelCostEstimator::DescribeTensor(\n }\n \n /* static */\n-OpLevelCostEstimator::ConvolutionDimensions\n+StatusOr<OpLevelCostEstimator::ConvolutionDimensions>\n OpLevelCostEstimator::OpDimensionsFromInputs(\n     const TensorShapeProto& original_image_shape, const OpInfo& op_info,\n     bool* found_unknown_shapes) {\n@@ -2190,6 +2190,11 @@ OpLevelCostEstimator::OpDimensionsFromInputs(\n   std::vector<int64_t> strides = GetStrides(op_info);\n   int64_t sx = strides[x_index];\n   int64_t sy = strides[y_index];\n+  if (sx == 0 || sy == 0) {\n+    return errors::InvalidArgument(\n+        \"Stride must be > 0 for Height and Width, but got (\", sy, \", \", sx,\n+        \")\");\n+  }\n   const auto padding = GetPadding(op_info);\n \n   int64_t ox = GetOutputSize(ix, kx, sx, padding);\n@@ -2206,8 +2211,9 @@ Status OpLevelCostEstimator::PredictMaxPool(const OpContext& op_context,\n   bool found_unknown_shapes = false;\n   const auto& op_info = op_context.op_info;\n   // x: op_info.inputs(0)\n-  ConvolutionDimensions dims = OpDimensionsFromInputs(\n-      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n+  TF_ASSIGN_OR_RETURN(ConvolutionDimensions dims,\n+                      OpDimensionsFromInputs(op_info.inputs(0).shape(), op_info,\n+                                             &found_unknown_shapes));\n   // kx * ky - 1 comparisons per output (kx * xy > 1)\n   // or 1 copy per output (kx * k1 = 1).\n   int per_output_ops = dims.kx * dims.ky == 1 ? 1 : dims.kx * dims.ky - 1;\n@@ -2248,8 +2254,9 @@ Status OpLevelCostEstimator::PredictMaxPoolGrad(const OpContext& op_context,\n                                    op_info.ShortDebugString());\n   }\n \n-  ConvolutionDimensions dims = OpDimensionsFromInputs(\n-      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n+  TF_ASSIGN_OR_RETURN(ConvolutionDimensions dims,\n+                      OpDimensionsFromInputs(op_info.inputs(0).shape(), op_info,\n+                                             &found_unknown_shapes));\n \n   int64_t ops = 0;\n   if (dims.kx == 1 && dims.ky == 1) {\n@@ -2324,8 +2331,9 @@ Status OpLevelCostEstimator::PredictAvgPool(const OpContext& op_context,\n   bool found_unknown_shapes = false;\n   const auto& op_info = op_context.op_info;\n   // x: op_info.inputs(0)\n-  ConvolutionDimensions dims = OpDimensionsFromInputs(\n-      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n+  TF_ASSIGN_OR_RETURN(ConvolutionDimensions dims,\n+                      OpDimensionsFromInputs(op_info.inputs(0).shape(), op_info,\n+                                             &found_unknown_shapes));\n \n   // kx * ky - 1 additions and 1 multiplication per output.\n   int64_t ops = dims.batch * dims.ox * dims.oy * dims.oz * dims.kx * dims.ky;\n@@ -2382,8 +2390,9 @@ Status OpLevelCostEstimator::PredictAvgPoolGrad(const OpContext& op_context,\n     found_unknown_shapes = true;\n   }\n \n-  ConvolutionDimensions dims =\n-      OpDimensionsFromInputs(x_shape, op_info, &found_unknown_shapes);\n+  TF_ASSIGN_OR_RETURN(\n+      ConvolutionDimensions dims,\n+      OpDimensionsFromInputs(x_shape, op_info, &found_unknown_shapes));\n \n   int64_t ops = 0;\n   if (dims.kx <= dims.sx && dims.ky <= dims.sy) {\n@@ -2409,8 +2418,9 @@ Status OpLevelCostEstimator::PredictFusedBatchNorm(\n   // offset: op_info.inputs(2)\n   // mean: op_info.inputs(3)  --> only for inference\n   // variance: op_info.inputs(4) --> only for inference\n-  ConvolutionDimensions dims = OpDimensionsFromInputs(\n-      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n+  TF_ASSIGN_OR_RETURN(ConvolutionDimensions dims,\n+                      OpDimensionsFromInputs(op_info.inputs(0).shape(), op_info,\n+                                             &found_unknown_shapes));\n   const bool is_training = IsTraining(op_info);\n \n   int64_t ops = 0;\n@@ -2459,8 +2469,9 @@ Status OpLevelCostEstimator::PredictFusedBatchNormGrad(\n   // scale: op_info.inputs(2)\n   // mean: op_info.inputs(3)\n   // variance or inverse of variance: op_info.inputs(4)\n-  ConvolutionDimensions dims = OpDimensionsFromInputs(\n-      op_info.inputs(1).shape(), op_info, &found_unknown_shapes);\n+  TF_ASSIGN_OR_RETURN(ConvolutionDimensions dims,\n+                      OpDimensionsFromInputs(op_info.inputs(1).shape(), op_info,\n+                                             &found_unknown_shapes));\n \n   int64_t ops = 0;\n   const auto rsqrt_cost = Eigen::internal::functor_traits<"
        },
        {
          "filename": "tensorflow/core/grappler/costs/op_level_cost_estimator.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -290,7 +290,7 @@ class OpLevelCostEstimator {\n       bool* found_unknown_shapes);\n \n   // For Pooling, FusedBatchNorm, and their grad ops.\n-  static ConvolutionDimensions OpDimensionsFromInputs(\n+  static StatusOr<ConvolutionDimensions> OpDimensionsFromInputs(\n       const TensorShapeProto& original_image_shape, const OpInfo& op_info,\n       bool* found_unknown_shapes);\n "
        },
        {
          "filename": "tensorflow/core/grappler/costs/op_level_cost_estimator_test.cc",
          "status": "modified",
          "additions": 57,
          "deletions": 3,
          "patch": "@@ -24,6 +24,7 @@ limitations under the License.\n #include \"tensorflow/core/framework/tensor_shape.h\"\n #include \"tensorflow/core/framework/tensor_shape.pb.h\"\n #include \"tensorflow/core/framework/types.h\"\n+#include \"tensorflow/core/platform/status_matchers.h\"\n #include \"tensorflow/core/platform/test.h\"\n #include \"tensorflow/core/protobuf/device_properties.pb.h\"\n \n@@ -558,9 +559,10 @@ class OpLevelCostEstimatorTest : public ::testing::Test {\n     }\n \n     bool found_unknown_shapes;\n-    auto dims = OpLevelCostEstimator::OpDimensionsFromInputs(\n-        op_context.op_info.inputs(0).shape(), op_context.op_info,\n-        &found_unknown_shapes);\n+    TF_ASSERT_OK_AND_ASSIGN(\n+        auto dims, OpLevelCostEstimator::OpDimensionsFromInputs(\n+                       op_context.op_info.inputs(0).shape(), op_context.op_info,\n+                       &found_unknown_shapes));\n     Padding padding_enum;\n     if (padding == \"VALID\") {\n       padding_enum = Padding::VALID;\n@@ -581,6 +583,38 @@ class OpLevelCostEstimatorTest : public ::testing::Test {\n     EXPECT_EQ(padding_enum, dims.padding);\n   }\n \n+  StatusOr<OpLevelCostEstimator::ConvolutionDimensions>\n+  CallOpDimensionsFromInputs(const int n, const int h, const int w, const int c,\n+                             const int kx, const int ky, const int sx,\n+                             const int sy, const string& data_format,\n+                             const string& padding) {\n+    OpContext op_context;\n+\n+    const std::vector<int> x = {n, h, w, c};\n+    const std::vector<int> ksize = {1, kx, ky, 1};\n+    std::vector<int> strides;\n+    if (data_format == \"NHWC\") {\n+      strides = {1, sy, sx, 1};\n+    } else {\n+      strides = {1, 1, sy, sx};\n+    }\n+\n+    auto& op_info = op_context.op_info;\n+    SetCpuDevice(&op_info);\n+    op_info.set_op(\"MaxPool\");\n+\n+    DescribeTensor4D(x[0], x[1], x[2], x[3], op_info.add_inputs());\n+    auto* attr = op_info.mutable_attr();\n+    SetAttrValue(data_format, &(*attr)[\"data_format\"]);\n+    SetAttrValue(padding, &(*attr)[\"padding\"]);\n+    SetAttrValue(strides, &(*attr)[\"strides\"]);\n+    SetAttrValue(ksize, &(*attr)[\"ksize\"]);\n+    bool found_unknown_shapes;\n+    return OpLevelCostEstimator::OpDimensionsFromInputs(\n+        op_context.op_info.inputs(0).shape(), op_context.op_info,\n+        &found_unknown_shapes);\n+  }\n+\n   OpLevelCostEstimator estimator_;\n };\n \n@@ -1383,6 +1417,26 @@ TEST_F(OpLevelCostEstimatorTest, OpDimensionsFromInputs) {\n   }\n }\n \n+TEST_F(OpLevelCostEstimatorTest, OpDimensionsFromInputsError) {\n+  std::vector<string> paddings = {\"VALID\", \"SAME\"};\n+  std::vector<string> formats = {\"NHWC\", \"NCHW\"};\n+  for (const auto& p : paddings) {\n+    for (const auto& f : formats) {\n+      // n, h, w, c, kx, ky, sx, sy, data_format, padding.\n+      ASSERT_THAT(\n+          CallOpDimensionsFromInputs(10, 14, 14, 3840, 3, 3, 0, 2, f, p),\n+          testing::StatusIs(\n+              error::INVALID_ARGUMENT,\n+              \"Stride must be > 0 for Height and Width, but got (2, 0)\"));\n+      ASSERT_THAT(\n+          CallOpDimensionsFromInputs(10, 14, 14, 3840, 3, 3, 2, 0, f, p),\n+          testing::StatusIs(\n+              error::INVALID_ARGUMENT,\n+              \"Stride must be > 0 for Height and Width, but got (0, 2)\"));\n+    }\n+  }\n+}\n+\n TEST_F(OpLevelCostEstimatorTest, PredictMaxPool) {\n   auto predict_max_pool = [this](const int n, const int in, const int c,\n                                  const int k, const int s,"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "5c27f5f4dc39afdefbd93c2ef266a8c7ab534a98",
            "date": "2025-01-25T18:55:10Z",
            "author_login": "tensorflower-gardener"
          },
          {
            "sha": "05df81c283627135b7651c9c7a8fa0035bff2206",
            "date": "2025-01-25T17:06:34Z",
            "author_login": "tensorflower-gardener"
          },
          {
            "sha": "4075a7dd74ea543557d1824e16721598e1a6af8d",
            "date": "2025-01-25T17:06:30Z",
            "author_login": "tensorflower-gardener"
          },
          {
            "sha": "4d08d96d6a0aea39c5bd90d9728dbcf59008993c",
            "date": "2025-01-25T17:04:34Z",
            "author_login": "tensorflower-gardener"
          },
          {
            "sha": "1b58ec4dcd6e5752598dc57d4788119f8ea12e23",
            "date": "2025-01-25T11:39:06Z",
            "author_login": "tensorflower-gardener"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-369",
    "description": "Tensorflow is an Open Source Machine Learning Framework. The estimator for the cost of some convolution operations can be made to execute a division by 0. The function fails to check that the stride argument is strictly positive. Hence, the fix is to add a check for the stride argument to ensure it is valid. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-02-03T13:15:07.870",
    "last_modified": "2024-11-21T06:45:18.887",
    "fix_date": "2021-11-23T22:27:24Z"
  },
  "references": [
    {
      "url": "https://github.com/tensorflow/tensorflow/blob/ffa202a17ab7a4a10182b746d230ea66f021fe16/tensorflow/core/grappler/costs/op_level_cost_estimator.cc#L189-L198",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/3218043d6d3a019756607643cf65574fbfef5d7a",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-v3f7-j968-4h5f",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/blob/ffa202a17ab7a4a10182b746d230ea66f021fe16/tensorflow/core/grappler/costs/op_level_cost_estimator.cc#L189-L198",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/3218043d6d3a019756607643cf65574fbfef5d7a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-v3f7-j968-4h5f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:57.106727",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "tensorflow",
    "owner": "tensorflow",
    "created_at": "2015-11-07T01:19:20Z",
    "updated_at": "2025-01-26T06:52:14Z",
    "pushed_at": "2025-01-26T07:27:00Z",
    "size": 1126495,
    "stars": 187418,
    "forks": 74442,
    "open_issues": 6822,
    "watchers": 187418,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 101327392,
      "Python": 45791326,
      "MLIR": 10764225,
      "HTML": 7662661,
      "Starlark": 7439181,
      "Go": 2171369,
      "C": 1294440,
      "Java": 1178817,
      "Jupyter Notebook": 805736,
      "Shell": 702245,
      "Objective-C++": 279654,
      "Objective-C": 169202,
      "CMake": 148610,
      "Smarty": 121630,
      "Swift": 81659,
      "Dockerfile": 38067,
      "C#": 13585,
      "Batchfile": 12126,
      "Ruby": 8898,
      "Perl": 7536,
      "Roff": 5034,
      "Cython": 3899,
      "Makefile": 2845,
      "CSS": 2761,
      "Vim Snippet": 58
    },
    "commit_activity": {
      "total_commits_last_year": 15545,
      "avg_commits_per_week": 298.9423076923077,
      "days_active_last_year": 354
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:37:26.588757"
  }
}