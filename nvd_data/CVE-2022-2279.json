{
  "cve_id": "CVE-2022-2279",
  "github_data": {
    "repository": "bfabiszewski/libmobi",
    "fix_commit": "c0699c8693c47f14a2e57dec7292e862ac7adf9c",
    "related_commits": [
      "c0699c8693c47f14a2e57dec7292e862ac7adf9c",
      "c0699c8693c47f14a2e57dec7292e862ac7adf9c"
    ],
    "patch_url": "https://github.com/bfabiszewski/libmobi/commit/c0699c8693c47f14a2e57dec7292e862ac7adf9c.patch",
    "fix_commit_details": {
      "sha": "c0699c8693c47f14a2e57dec7292e862ac7adf9c",
      "commit_date": "2022-04-27T10:35:39Z",
      "author": {
        "login": "bfabiszewski",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix undefined behavior when passing null to strdup",
        "length": 50,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 35,
        "additions": 21,
        "deletions": 14
      },
      "files": [
        {
          "filename": "ChangeLog",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -1,3 +1,4 @@\n+2022-04-27: Fix undefined behavior when passing null to strdup\n 2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input\n 2022-04-26: Fix text formatting\n 2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input"
        },
        {
          "filename": "src/opf.c",
          "status": "modified",
          "additions": 18,
          "deletions": 12,
          "patch": "@@ -1152,24 +1152,30 @@ MOBI_RET mobi_build_opf_metadata(OPF *opf,  const MOBIData *m, const MOBIRawml *\n     if (mobi_is_dictionary(m)) {\n         if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n             if (m->mh && m->mh->dict_input_lang) {\n-                opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n-                if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n-                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n-                    return MOBI_MALLOC_FAILED;\n-                }\n                 uint32_t dict_lang_in = *m->mh->dict_input_lang;\n-                opf->metadata->x_meta->dictionary_in_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n+                const char *lang = mobi_get_locale_string(dict_lang_in);\n+                if (lang) {\n+                    opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n+                    if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n+                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n+                        return MOBI_MALLOC_FAILED;\n+                    }\n+                    opf->metadata->x_meta->dictionary_in_lang[0] = strdup(lang);\n+                }\n             }\n         }\n         if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n             if (m->mh && m->mh->dict_output_lang) {\n-                opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n-                if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n-                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n-                    return MOBI_MALLOC_FAILED;\n+                uint32_t dict_lang_out = *m->mh->dict_output_lang;\n+                const char *lang = mobi_get_locale_string(dict_lang_out);\n+                if (lang) {\n+                    opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n+                    if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n+                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n+                        return MOBI_MALLOC_FAILED;\n+                    }\n+                    opf->metadata->x_meta->dictionary_out_lang[0] = strdup(lang);\n                 }\n-                uint32_t dict_lang_in = *m->mh->dict_output_lang;\n-                opf->metadata->x_meta->dictionary_out_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n             }\n         }\n         if (rawml->orth->orth_index_name) {"
        },
        {
          "filename": "src/util.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -641,7 +641,7 @@ static const char *mobi_locale[MOBI_LANG_MAX][MOBI_REGION_MAX] = {\n  See mobi_locale array.\n  \n  @param[in] locale_number Mobipocket locale number (as stored in MOBI header)\n- @return Pointer to locale string in mobi_locale array\n+ @return Pointer to locale string in mobi_locale array or NULL on error\n  */\n const char * mobi_get_locale_string(const uint32_t locale_number) {\n     uint8_t lang_code = locale_number & 0xffU;"
        },
        {
          "filename": "tools/common.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -330,7 +330,7 @@ void print_summary(const MOBIData *m) {\n             *m->mh->dict_input_lang && *m->mh->dict_output_lang) {\n             const char *locale_in = mobi_get_locale_string(*m->mh->dict_input_lang);\n             const char *locale_out = mobi_get_locale_string(*m->mh->dict_output_lang);\n-            printf(\": %s => %s\", locale_in, locale_out);\n+            printf(\": %s => %s\", locale_in ? locale_in : \"unknown\", locale_out ? locale_out : \"unknown\");\n         }\n         printf(\"\\n\");\n     }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "906274205c11944b628da1c553b255acb1af7c55",
            "date": "2024-10-29T17:49:48Z",
            "author_login": "bfabiszewski"
          },
          {
            "sha": "3c7ae6436b54cc3d18955e40f1e8de7d59497ede",
            "date": "2024-10-29T17:23:57Z",
            "author_login": "bfabiszewski"
          },
          {
            "sha": "ea137c29818b3ff6ab6968a83dfed89716acecfb",
            "date": "2024-07-04T16:27:48Z",
            "author_login": "bfabiszewski"
          },
          {
            "sha": "2e15b158fdd81ebd0f8dd2febfd1aaa80f73c238",
            "date": "2024-06-17T19:14:36Z",
            "author_login": "bfabiszewski"
          },
          {
            "sha": "85dcfe803fc2a21020ddcf15c3eb66b93d388add",
            "date": "2024-06-17T06:10:16Z",
            "author_login": "bfabiszewski"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-476",
    "description": "NULL Pointer Dereference in GitHub repository bfabiszewski/libmobi prior to 0.11.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-07-01T09:15:09.067",
    "last_modified": "2024-11-21T07:00:40.670",
    "fix_date": "2022-04-27T10:35:39Z"
  },
  "references": [
    {
      "url": "https://github.com/bfabiszewski/libmobi/commit/c0699c8693c47f14a2e57dec7292e862ac7adf9c",
      "source": "security@huntr.dev",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/68c249e2-779d-4871-b7e3-851f03aca2de",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/bfabiszewski/libmobi/commit/c0699c8693c47f14a2e57dec7292e862ac7adf9c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/68c249e2-779d-4871-b7e3-851f03aca2de",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:09.504159",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "libmobi",
    "owner": "bfabiszewski",
    "created_at": "2014-05-14T10:23:18Z",
    "updated_at": "2025-01-04T18:03:00Z",
    "pushed_at": "2024-10-29T17:50:02Z",
    "size": 48334,
    "stars": 429,
    "forks": 69,
    "open_issues": 2,
    "watchers": 429,
    "has_security_policy": false,
    "default_branch": "public",
    "protected_branches": [],
    "languages": {
      "C": 977087,
      "M4": 13279,
      "Roff": 8058,
      "CMake": 7485,
      "Shell": 5517,
      "Makefile": 4701
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-3.0"
    },
    "collected_at": "2025-01-14T16:13:48.046970"
  }
}