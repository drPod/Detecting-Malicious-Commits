{
  "cve_id": "CVE-2022-23071",
  "github_data": {
    "repository": "TandoorRecipes/recipes",
    "fix_commit": "d48fe26a3529cc1ee903ffb2758dfd8f7efaba8c",
    "related_commits": [
      "d48fe26a3529cc1ee903ffb2758dfd8f7efaba8c",
      "d48fe26a3529cc1ee903ffb2758dfd8f7efaba8c"
    ],
    "patch_url": "https://github.com/TandoorRecipes/recipes/commit/d48fe26a3529cc1ee903ffb2758dfd8f7efaba8c.patch",
    "fix_commit_details": {
      "sha": "d48fe26a3529cc1ee903ffb2758dfd8f7efaba8c",
      "commit_date": "2022-05-17T16:04:43Z",
      "author": {
        "login": "vabene1111",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "added url validation to all server requests",
        "length": 43,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 90,
        "additions": 59,
        "deletions": 31
      },
      "files": [
        {
          "filename": "cookbook/integration/cookbookapp.py",
          "status": "modified",
          "additions": 5,
          "deletions": 2,
          "patch": "@@ -6,6 +6,7 @@\n from io import BytesIO\n \n import requests\n+import validators\n import yaml\n \n from cookbook.helper.ingredient_parser import IngredientParser\n@@ -59,8 +60,10 @@ def get_recipe_from_file(self, file):\n \n         if len(images) > 0:\n             try:\n-                response = requests.get(images[0])\n-                self.import_recipe_image(recipe, BytesIO(response.content))\n+                url = images[0]\n+                if validators.url(url, public=True):\n+                    response = requests.get(url)\n+                    self.import_recipe_image(recipe, BytesIO(response.content))\n             except Exception as e:\n                 print('failed to import image ', str(e))\n "
        },
        {
          "filename": "cookbook/integration/cookmate.py",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -5,6 +5,7 @@\n from gettext import gettext as _\n \n import requests\n+import validators\n from lxml import etree\n \n from cookbook.helper.ingredient_parser import IngredientParser\n@@ -64,7 +65,9 @@ def get_recipe_from_file(self, file):\n \n         if recipe_xml.find('imageurl') is not None:\n             try:\n-                response = requests.get(recipe_xml.find('imageurl').text.strip())\n+                url = recipe_xml.find('imageurl').text.strip()\n+                if validators.url(url, public=True):\n+                    response = requests.get(url)\n                 self.import_recipe_image(recipe, BytesIO(response.content))\n             except Exception as e:\n                 print('failed to import image ', str(e))"
        },
        {
          "filename": "cookbook/integration/recettetek.py",
          "status": "modified",
          "additions": 8,
          "deletions": 5,
          "patch": "@@ -5,6 +5,7 @@\n from zipfile import ZipFile\n \n import requests\n+import validators\n \n from django.utils.translation import gettext as _\n from cookbook.helper.image_processing import get_filetype\n@@ -123,11 +124,13 @@ def get_recipe_from_file(self, file):\n                         self.import_recipe_image(recipe, BytesIO(import_zip.read(image_file_name)), filetype=get_filetype(image_file_name))\n             else:\n                 if file['originalPicture'] != '':\n-                    response = requests.get(file['originalPicture'])\n-                    if imghdr.what(BytesIO(response.content)) is not None:\n-                        self.import_recipe_image(recipe, BytesIO(response.content), filetype=get_filetype(file['originalPicture']))\n-                    else:\n-                        raise Exception(\"Original image failed to download.\")\n+                    url = file['originalPicture']\n+                    if validators.url(url, public=True):\n+                        response = requests.get(url)\n+                        if imghdr.what(BytesIO(response.content)) is not None:\n+                            self.import_recipe_image(recipe, BytesIO(response.content), filetype=get_filetype(file['originalPicture']))\n+                        else:\n+                            raise Exception(\"Original image failed to download.\")\n         except Exception as e:\n             print(recipe.name, ': failed to import image ', str(e))\n "
        },
        {
          "filename": "cookbook/integration/recipesage.py",
          "status": "modified",
          "additions": 5,
          "deletions": 2,
          "patch": "@@ -2,6 +2,7 @@\n from io import BytesIO\n \n import requests\n+import validators\n \n from cookbook.helper.ingredient_parser import IngredientParser\n from cookbook.integration.integration import Integration\n@@ -51,8 +52,10 @@ def get_recipe_from_file(self, file):\n \n         if len(file['image']) > 0:\n             try:\n-                response = requests.get(file['image'][0])\n-                self.import_recipe_image(recipe, BytesIO(response.content))\n+                url = file['image'][0]\n+                if validators.url(url, public=True):\n+                    response = requests.get(url)\n+                    self.import_recipe_image(recipe, BytesIO(response.content))\n             except Exception as e:\n                 print('failed to import image ', str(e))\n "
        },
        {
          "filename": "cookbook/provider/dropbox.py",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -4,6 +4,8 @@\n from datetime import datetime\n \n import requests\n+import validators\n+\n from cookbook.models import Recipe, RecipeImport, SyncLog\n from cookbook.provider.provider import Provider\n \n@@ -104,9 +106,11 @@ def get_file(recipe):\n             recipe.link = Dropbox.get_share_link(recipe)\n             recipe.save()\n \n-        response = requests.get(recipe.link.replace('www.dropbox.', 'dl.dropboxusercontent.'))\n+        url = recipe.link.replace('www.dropbox.', 'dl.dropboxusercontent.')\n+        if validators.url(url, public=True):\n+            response = requests.get(url)\n \n-        return io.BytesIO(response.content)\n+            return io.BytesIO(response.content)\n \n     @staticmethod\n     def rename_file(recipe, new_name):"
        },
        {
          "filename": "cookbook/provider/nextcloud.py",
          "status": "modified",
          "additions": 13,
          "deletions": 11,
          "patch": "@@ -4,6 +4,7 @@\n from datetime import datetime\n \n import requests\n+import validators\n import webdav3.client as wc\n from cookbook.models import Recipe, RecipeImport, SyncLog\n from cookbook.provider.provider import Provider\n@@ -92,20 +93,21 @@ def get_share_link(recipe):\n             \"Content-Type\": \"application/json\"\n         }\n \n-        r = requests.get(\n-            url,\n-            headers=headers,\n-            auth=HTTPBasicAuth(\n-                recipe.storage.username, recipe.storage.password\n+        if validators.url(url, public=True):\n+            r = requests.get(\n+                url,\n+                headers=headers,\n+                auth=HTTPBasicAuth(\n+                    recipe.storage.username, recipe.storage.password\n+                )\n             )\n-        )\n \n-        response_json = r.json()\n-        for element in response_json['ocs']['data']:\n-            if element['share_type'] == '3':\n-                return element['url']\n+            response_json = r.json()\n+            for element in response_json['ocs']['data']:\n+                if element['share_type'] == '3':\n+                    return element['url']\n \n-        return Nextcloud.create_share_link(recipe)\n+            return Nextcloud.create_share_link(recipe)\n \n     @staticmethod\n     def get_file(recipe):"
        },
        {
          "filename": "cookbook/views/api.py",
          "status": "modified",
          "additions": 17,
          "deletions": 8,
          "patch": "@@ -6,6 +6,7 @@\n from collections import OrderedDict\n \n import requests\n+import validators\n from PIL import UnidentifiedImageError\n from annoying.decorators import ajax_request\n from annoying.functions import get_object_or_None\n@@ -14,7 +15,7 @@\n from django.contrib.postgres.search import TrigramSimilarity\n from django.core.exceptions import FieldError, ValidationError\n from django.core.files import File\n-from django.db.models import (Case, Count, Exists, F, IntegerField, OuterRef, ProtectedError, Q,\n+from django.db.models import (Case, Count, Exists, OuterRef, ProtectedError, Q,\n                               Subquery, Value, When)\n from django.db.models.fields.related import ForeignObjectRel\n from django.db.models.functions import Coalesce, Lower\n@@ -24,7 +25,6 @@\n from django.utils.translation import gettext as _\n from django_scopes import scopes_disabled\n from icalendar import Calendar, Event\n-from recipe_scrapers import NoSchemaFoundInWildMode, WebsiteNotImplementedError, scrape_me\n from requests.exceptions import MissingSchema\n from rest_framework import decorators, status, viewsets\n from rest_framework.exceptions import APIException, PermissionDenied\n@@ -34,6 +34,7 @@\n from rest_framework.response import Response\n from rest_framework.viewsets import ViewSetMixin\n from treebeard.exceptions import InvalidMoveToDescendant, InvalidPosition, PathOverflow\n+from validators import ValidationFailure\n \n from cookbook.helper.HelperFunctions import str2bool\n from cookbook.helper.image_processing import handle_image\n@@ -43,7 +44,6 @@\n                                                group_required)\n from cookbook.helper.recipe_html_import import get_recipe_from_source\n from cookbook.helper.recipe_search import RecipeFacet, RecipeSearch, old_search\n-from cookbook.helper.recipe_url_import import get_from_scraper\n from cookbook.helper.shopping_helper import RecipeShoppingEditor, shopping_helper\n from cookbook.models import (Automation, BookmarkletImport, CookLog, CustomFilter, ExportLog, Food,\n                              FoodInheritField, ImportLog, Ingredient, Keyword, MealPlan, MealType,\n@@ -774,16 +774,18 @@ def image(self, request, pk):\n         if serializer.is_valid():\n             serializer.save()\n             image = None\n-            filetype = \".jpeg\" # fall-back to .jpeg, even if wrong, at least users will know it's an image and most image viewers can open it correctly anyways\n+            filetype = \".jpeg\"  # fall-back to .jpeg, even if wrong, at least users will know it's an image and most image viewers can open it correctly anyways\n \n             if 'image' in serializer.validated_data:\n                 image = obj.image\n                 filetype = mimetypes.guess_extension(serializer.validated_data['image'].content_type) or filetype\n             elif 'image_url' in serializer.validated_data:\n                 try:\n-                    response = requests.get(serializer.validated_data['image_url'])\n-                    image = File(io.BytesIO(response.content))\n-                    filetype = mimetypes.guess_extension(response.headers['content-type']) or filetype\n+                    url = serializer.validated_data['image_url']\n+                    if validators.url(url, public=True):\n+                        response = requests.get(url)\n+                        image = File(io.BytesIO(response.content))\n+                        filetype = mimetypes.guess_extension(response.headers['content-type']) or filetype\n                 except UnidentifiedImageError as e:\n                     print(e)\n                     pass\n@@ -1188,7 +1190,13 @@ def recipe_from_source(request):\n     # in manual mode request complete page to return it later\n     if url:\n         try:\n-            data = requests.get(url, headers=external_request_headers).content\n+            if validators.url(url, public=True):\n+                data = requests.get(url, headers=external_request_headers).content\n+            else:\n+                return JsonResponse({\n+                    'error': True,\n+                    'msg': _('Invalid Url')\n+                }, status=400)\n         except requests.exceptions.ConnectionError:\n             return JsonResponse({\n                 'error': True,\n@@ -1199,6 +1207,7 @@ def recipe_from_source(request):\n                 'error': True,\n                 'msg': _('Bad URL Schema.')\n             }, status=400)\n+\n     recipe_json, recipe_tree, recipe_html, recipe_images = get_recipe_from_source(data, url, request)\n     if len(recipe_tree) == 0 and len(recipe_json) == 0:\n         return JsonResponse({"
        },
        {
          "filename": "requirements.txt",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -43,3 +43,4 @@ python-ldap==3.4.0\n django-auth-ldap==4.0.0\n pytest-factoryboy==2.1.0\n pyppeteer==1.0.2\n+validators==0.19.0\n\\ No newline at end of file"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 1,
        "test_files": 0,
        "unique_directories": 4,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "f25de4b4ce3ac284a538ed132b4024a90c17b14f",
            "date": "2025-01-05T10:38:35Z",
            "author_login": "vabene1111"
          },
          {
            "sha": "6444680e067c11e5579656e57119a4e03a324322",
            "date": "2025-01-01T07:16:19Z",
            "author_login": "vabene1111"
          },
          {
            "sha": "c604369e867be22c811246dc35ff1451e830dfc9",
            "date": "2025-01-01T00:33:49Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "fd4236672e232a0f105828e22214bc1afedb2058",
            "date": "2024-12-29T12:46:17Z",
            "author_login": "vabene1111"
          },
          {
            "sha": "00148a29931c266db192b88580c3f70d35f9e8b1",
            "date": "2024-12-29T12:44:43Z",
            "author_login": "vabene1111"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-918",
    "description": "In Recipes, versions 0.9.1 through 1.2.5 are vulnerable to Server Side Request Forgery (SSRF), in the \u201cImport Recipe\u201d functionality. When an attacker enters the localhost URL, a low privileged attacker can access/read the internal file system to access sensitive information.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-06-19T11:15:07.810",
    "last_modified": "2024-11-21T06:47:55.497",
    "fix_date": "2022-05-17T16:04:43Z"
  },
  "references": [
    {
      "url": "https://github.com/TandoorRecipes/recipes/commit/d48fe26a3529cc1ee903ffb2758dfd8f7efaba8c",
      "source": "vulnerabilitylab@mend.io",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.mend.io/vulnerability-database/CVE-2022-23071",
      "source": "vulnerabilitylab@mend.io",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/TandoorRecipes/recipes/commit/d48fe26a3529cc1ee903ffb2758dfd8f7efaba8c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.mend.io/vulnerability-database/CVE-2022-23071",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:09.461139",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "recipes",
    "owner": "TandoorRecipes",
    "created_at": "2019-11-13T20:34:02Z",
    "updated_at": "2025-01-14T08:32:24Z",
    "pushed_at": "2025-01-13T16:56:58Z",
    "size": 63549,
    "stars": 5822,
    "forks": 606,
    "open_issues": 319,
    "watchers": 5822,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "develop",
      "master"
    ],
    "languages": {
      "HTML": 5670582,
      "Python": 1226241,
      "JavaScript": 858487,
      "TypeScript": 836415,
      "Vue": 759673,
      "CSS": 113784,
      "Shell": 3302,
      "Dockerfile": 2745,
      "C": 73
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:42:51.807571"
  }
}