{
  "cve_id": "CVE-2022-2321",
  "github_data": {
    "repository": "heroiclabs/nakama",
    "fix_commit": "e2e02fce80ff33ce45f8a6ebc0b7a99ee0b03824",
    "related_commits": [
      "e2e02fce80ff33ce45f8a6ebc0b7a99ee0b03824",
      "e2e02fce80ff33ce45f8a6ebc0b7a99ee0b03824"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "e2e02fce80ff33ce45f8a6ebc0b7a99ee0b03824",
      "commit_date": "2022-07-05T18:22:19Z",
      "author": {
        "login": "ftkg",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Better limit for unsuccessful login attempts on the devconsole. (#878)",
        "length": 70,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 227,
        "additions": 220,
        "deletions": 7
      },
      "files": [
        {
          "filename": "main.go",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -141,6 +141,7 @@ func main() {\n \tsessionRegistry := server.NewLocalSessionRegistry(metrics)\n \tsessionCache := server.NewLocalSessionCache(config.GetSession().TokenExpirySec)\n \tconsoleSessionCache := server.NewLocalSessionCache(config.GetConsole().TokenExpirySec)\n+\tloginAttemptCache := server.NewLocalLoginAttemptCache()\n \tstatusRegistry := server.NewStatusRegistry(logger, config, sessionRegistry, jsonpbMarshaler)\n \ttracker := server.StartLocalTracker(logger, config, sessionRegistry, statusRegistry, metrics, jsonpbMarshaler)\n \trouter := server.NewLocalMessageRouter(sessionRegistry, tracker, jsonpbMarshaler)\n@@ -166,7 +167,7 @@ func main() {\n \tstatusHandler := server.NewLocalStatusHandler(logger, sessionRegistry, matchRegistry, tracker, metrics, config.GetName())\n \n \tapiServer := server.StartApiServer(logger, startupLogger, db, jsonpbMarshaler, jsonpbUnmarshaler, config, socialClient, leaderboardCache, leaderboardRankCache, sessionRegistry, sessionCache, statusRegistry, matchRegistry, matchmaker, tracker, router, streamManager, metrics, pipeline, runtime)\n-\tconsoleServer := server.StartConsoleServer(logger, startupLogger, db, config, tracker, router, streamManager, sessionCache, consoleSessionCache, statusRegistry, statusHandler, runtimeInfo, matchRegistry, configWarnings, semver, leaderboardCache, leaderboardRankCache, apiServer, cookie)\n+\tconsoleServer := server.StartConsoleServer(logger, startupLogger, db, config, tracker, router, streamManager, sessionCache, consoleSessionCache, loginAttemptCache, statusRegistry, statusHandler, runtimeInfo, matchRegistry, configWarnings, semver, leaderboardCache, leaderboardRankCache, apiServer, cookie)\n \n \tgaenabled := len(os.Getenv(\"NAKAMA_TELEMETRY\")) < 1\n \tconst gacode = \"UA-89792135-1\"\n@@ -232,6 +233,7 @@ func main() {\n \tsessionCache.Stop()\n \tsessionRegistry.Stop()\n \tmetrics.Stop(logger)\n+\tloginAttemptCache.Stop()\n \n \tif gaenabled {\n \t\t_ = ga.SendSessionStop(telemetryClient, gacode, cookie)"
        },
        {
          "filename": "server/console.go",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -138,6 +138,7 @@ type ConsoleServer struct {\n \tStreamManager        StreamManager\n \tsessionCache         SessionCache\n \tconsoleSessionCache  SessionCache\n+\tloginAttemptCache    LoginAttemptCache\n \tstatusRegistry       *StatusRegistry\n \tmatchRegistry        MatchRegistry\n \tstatusHandler        StatusHandler\n@@ -155,7 +156,7 @@ type ConsoleServer struct {\n \thttpClient           *http.Client\n }\n \n-func StartConsoleServer(logger *zap.Logger, startupLogger *zap.Logger, db *sql.DB, config Config, tracker Tracker, router MessageRouter, streamManager StreamManager, sessionCache SessionCache, consoleSessionCache SessionCache, statusRegistry *StatusRegistry, statusHandler StatusHandler, runtimeInfo *RuntimeInfo, matchRegistry MatchRegistry, configWarnings map[string]string, serverVersion string, leaderboardCache LeaderboardCache, leaderboardRankCache LeaderboardRankCache, api *ApiServer, cookie string) *ConsoleServer {\n+func StartConsoleServer(logger *zap.Logger, startupLogger *zap.Logger, db *sql.DB, config Config, tracker Tracker, router MessageRouter, streamManager StreamManager, sessionCache SessionCache, consoleSessionCache SessionCache, loginAttemptCache LoginAttemptCache, statusRegistry *StatusRegistry, statusHandler StatusHandler, runtimeInfo *RuntimeInfo, matchRegistry MatchRegistry, configWarnings map[string]string, serverVersion string, leaderboardCache LeaderboardCache, leaderboardRankCache LeaderboardRankCache, api *ApiServer, cookie string) *ConsoleServer {\n \tvar gatewayContextTimeoutMs string\n \tif config.GetConsole().IdleTimeoutMs > 500 {\n \t\t// Ensure the GRPC Gateway timeout is just under the idle timeout (if possible) to ensure it has priority.\n@@ -182,6 +183,7 @@ func StartConsoleServer(logger *zap.Logger, startupLogger *zap.Logger, db *sql.D\n \t\tStreamManager:        streamManager,\n \t\tsessionCache:         sessionCache,\n \t\tconsoleSessionCache:  consoleSessionCache,\n+\t\tloginAttemptCache:    loginAttemptCache,\n \t\tstatusRegistry:       statusRegistry,\n \t\tmatchRegistry:        matchRegistry,\n \t\tstatusHandler:        statusHandler,"
        },
        {
          "filename": "server/console_authenticate.go",
          "status": "modified",
          "additions": 40,
          "deletions": 5,
          "patch": "@@ -20,17 +20,17 @@ import (\n \t\"database/sql\"\n \t\"errors\"\n \t\"fmt\"\n-\t\"github.com/gofrs/uuid\"\n-\t\"google.golang.org/protobuf/types/known/emptypb\"\n \t\"time\"\n \n+\t\"github.com/gofrs/uuid\"\n \tjwt \"github.com/golang-jwt/jwt/v4\"\n \t\"github.com/heroiclabs/nakama/v3/console\"\n \t\"github.com/jackc/pgtype\"\n \t\"go.uber.org/zap\"\n \t\"golang.org/x/crypto/bcrypt\"\n \t\"google.golang.org/grpc/codes\"\n \t\"google.golang.org/grpc/status\"\n+\t\"google.golang.org/protobuf/types/known/emptypb\"\n )\n \n type ConsoleTokenClaims struct {\n@@ -71,6 +71,11 @@ func parseConsoleToken(hmacSecretByte []byte, tokenString string) (id, username,\n }\n \n func (s *ConsoleServer) Authenticate(ctx context.Context, in *console.AuthenticateRequest) (*console.ConsoleSession, error) {\n+\tip, _ := extractClientAddressFromContext(s.logger, ctx)\n+\tif !s.loginAttemptCache.Allow(in.Username, ip) {\n+\t\treturn nil, status.Error(codes.ResourceExhausted, \"Try again later.\")\n+\t}\n+\n \trole := console.UserRole_USER_ROLE_UNKNOWN\n \tvar uname string\n \tvar email string\n@@ -81,10 +86,20 @@ func (s *ConsoleServer) Authenticate(ctx context.Context, in *console.Authentica\n \t\t\trole = console.UserRole_USER_ROLE_ADMIN\n \t\t\tuname = in.Username\n \t\t\tid = uuid.Nil\n+\t\t} else {\n+\t\t\tif lockout, until := s.loginAttemptCache.Add(s.config.GetConsole().Username, ip); lockout != LockoutTypeNone {\n+\t\t\t\tswitch lockout {\n+\t\t\t\tcase LockoutTypeAccount:\n+\t\t\t\t\ts.logger.Info(fmt.Sprintf(\"Console admin account locked until %v.\", until))\n+\t\t\t\tcase LockoutTypeIp:\n+\t\t\t\t\ts.logger.Info(fmt.Sprintf(\"Console admin IP locked until %v.\", until))\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn nil, status.Error(codes.Unauthenticated, \"Invalid credentials.\")\n \t\t}\n \tdefault:\n \t\tvar err error\n-\t\tid, uname, email, role, err = s.lookupConsoleUser(ctx, in.Username, in.Password)\n+\t\tid, uname, email, role, err = s.lookupConsoleUser(ctx, in.Username, in.Password, ip)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -94,7 +109,10 @@ func (s *ConsoleServer) Authenticate(ctx context.Context, in *console.Authentica\n \t\treturn nil, status.Error(codes.Unauthenticated, \"Invalid credentials.\")\n \t}\n \n+\ts.loginAttemptCache.Reset(uname)\n+\n \texp := time.Now().UTC().Add(time.Duration(s.config.GetConsole().TokenExpirySec) * time.Second).Unix()\n+\n \ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, &ConsoleTokenClaims{\n \t\tExpiresAt: exp,\n \t\tID:        id.String(),\n@@ -132,19 +150,28 @@ func (s *ConsoleServer) AuthenticateLogout(ctx context.Context, in *console.Auth\n \treturn &emptypb.Empty{}, nil\n }\n \n-func (s *ConsoleServer) lookupConsoleUser(ctx context.Context, unameOrEmail, password string) (id uuid.UUID, uname string, email string, role console.UserRole, err error) {\n+func (s *ConsoleServer) lookupConsoleUser(ctx context.Context, unameOrEmail, password, ip string) (id uuid.UUID, uname string, email string, role console.UserRole, err error) {\n \trole = console.UserRole_USER_ROLE_UNKNOWN\n \tquery := \"SELECT id, username, email, role, password, disable_time FROM console_user WHERE username = $1 OR email = $1\"\n \tvar dbPassword []byte\n \tvar dbDisableTime pgtype.Timestamptz\n \terr = s.db.QueryRowContext(ctx, query, unameOrEmail).Scan(&id, &uname, &email, &role, &dbPassword, &dbDisableTime)\n \tif err != nil {\n \t\tif err == sql.ErrNoRows {\n-\t\t\terr = nil\n+\t\t\tif lockout, until := s.loginAttemptCache.Add(\"\", ip); lockout == LockoutTypeIp {\n+\t\t\t\ts.logger.Info(fmt.Sprintf(\"Console user IP locked until %v.\", until))\n+\t\t\t}\n+\t\t\terr = status.Error(codes.Unauthenticated, \"Invalid credentials.\")\n \t\t}\n \t\treturn\n \t}\n \n+\t// Check lockout again as the login attempt may have been through email.\n+\tif !s.loginAttemptCache.Allow(uname, ip) {\n+\t\terr = status.Error(codes.ResourceExhausted, \"Try again later.\")\n+\t\treturn\n+\t}\n+\n \t// Check if it's disabled.\n \tif dbDisableTime.Status == pgtype.Present && dbDisableTime.Time.Unix() != 0 {\n \t\ts.logger.Info(\"Console user account is disabled.\", zap.String(\"username\", unameOrEmail))\n@@ -155,6 +182,14 @@ func (s *ConsoleServer) lookupConsoleUser(ctx context.Context, unameOrEmail, pas\n \t// Check password\n \terr = bcrypt.CompareHashAndPassword(dbPassword, []byte(password))\n \tif err != nil {\n+\t\tif lockout, until := s.loginAttemptCache.Add(uname, ip); lockout != LockoutTypeNone {\n+\t\t\tswitch lockout {\n+\t\t\tcase LockoutTypeAccount:\n+\t\t\t\ts.logger.Info(fmt.Sprintf(\"Console user account locked until %v.\", until))\n+\t\t\tcase LockoutTypeIp:\n+\t\t\t\ts.logger.Info(fmt.Sprintf(\"Console user IP locked until %v.\", until))\n+\t\t\t}\n+\t\t}\n \t\terr = status.Error(codes.Unauthenticated, \"Invalid credentials.\")\n \t\treturn\n \t}"
        },
        {
          "filename": "server/login_attempt_cache.go",
          "status": "added",
          "additions": 174,
          "deletions": 0,
          "patch": "@@ -0,0 +1,174 @@\n+// Copyright 2022 The Nakama Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+\t\"time\"\n+)\n+\n+type LockoutType uint8\n+\n+const (\n+\tLockoutTypeNone LockoutType = iota\n+\tLockoutTypeAccount\n+\tLockoutTypeIp\n+)\n+\n+const (\n+\tmaxAttemptsAccount   = 5\n+\tlockoutPeriodAccount = time.Minute * 1\n+\n+\tmaxAttemptsIp   = 10\n+\tlockoutPeriodIp = time.Minute * 10\n+)\n+\n+type LoginAttemptCache interface {\n+\tStop()\n+\t// Allow checks whether account or IP is locked out or should be allowed to attempt to authenticate.\n+\tAllow(account, ip string) bool\n+\t// Add a failed attempt and return current lockout status.\n+\tAdd(account, ip string) (LockoutType, time.Time)\n+\t// Reset account attempts on successful login.\n+\tReset(account string)\n+}\n+\n+type lockoutStatus struct {\n+\tlockedUntil time.Time\n+\tattempts    []time.Time\n+}\n+\n+func (ls *lockoutStatus) trim(now time.Time, retentionPeriod time.Duration) bool {\n+\tif ls.lockedUntil.Before(now) {\n+\t\tls.lockedUntil = time.Time{}\n+\t}\n+\tfor i := len(ls.attempts) - 1; i >= 0; i-- {\n+\t\tif now.Sub(ls.attempts[i]) >= retentionPeriod {\n+\t\t\tls.attempts = ls.attempts[i+1:]\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\treturn ls.lockedUntil.IsZero() && len(ls.attempts) == 0\n+}\n+\n+type LocalLoginAttemptCache struct {\n+\tsync.RWMutex\n+\tctx         context.Context\n+\tctxCancelFn context.CancelFunc\n+\n+\taccountCache map[string]*lockoutStatus\n+\tipCache      map[string]*lockoutStatus\n+}\n+\n+func NewLocalLoginAttemptCache() LoginAttemptCache {\n+\tctx, ctxCancelFn := context.WithCancel(context.Background())\n+\n+\tc := &LocalLoginAttemptCache{\n+\t\taccountCache: make(map[string]*lockoutStatus),\n+\t\tipCache:      make(map[string]*lockoutStatus),\n+\n+\t\tctx:         ctx,\n+\t\tctxCancelFn: ctxCancelFn,\n+\t}\n+\n+\tgo func() {\n+\t\tticker := time.NewTicker(10 * time.Minute)\n+\t\tfor {\n+\t\t\tselect {\n+\t\t\tcase <-c.ctx.Done():\n+\t\t\t\tticker.Stop()\n+\t\t\t\treturn\n+\t\t\tcase t := <-ticker.C:\n+\t\t\t\tnow := t.UTC()\n+\t\t\t\tc.Lock()\n+\t\t\t\tfor account, status := range c.accountCache {\n+\t\t\t\t\tif status.trim(now, lockoutPeriodAccount) {\n+\t\t\t\t\t\tdelete(c.accountCache, account)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tfor ip, status := range c.ipCache {\n+\t\t\t\t\tif status.trim(now, lockoutPeriodIp) {\n+\t\t\t\t\t\tdelete(c.ipCache, ip)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tc.Unlock()\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\treturn c\n+}\n+\n+func (c *LocalLoginAttemptCache) Stop() {\n+\tc.ctxCancelFn()\n+}\n+\n+func (c *LocalLoginAttemptCache) Allow(account, ip string) bool {\n+\tnow := time.Now().UTC()\n+\tc.RLock()\n+\tdefer c.RUnlock()\n+\tif status, found := c.accountCache[account]; found && !status.lockedUntil.IsZero() && status.lockedUntil.After(now) {\n+\t\treturn false\n+\t}\n+\tif status, found := c.ipCache[ip]; found && !status.lockedUntil.IsZero() && status.lockedUntil.After(now) {\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func (c *LocalLoginAttemptCache) Reset(account string) {\n+\tc.Lock()\n+\tdelete(c.accountCache, account)\n+\tc.Unlock()\n+}\n+\n+func (c *LocalLoginAttemptCache) Add(account, ip string) (LockoutType, time.Time) {\n+\tnow := time.Now().UTC()\n+\tvar lockoutType LockoutType\n+\tvar lockedUntil time.Time\n+\tc.Lock()\n+\tdefer c.Unlock()\n+\tif account != \"\" {\n+\t\tstatus, found := c.accountCache[account]\n+\t\tif !found {\n+\t\t\tstatus = &lockoutStatus{}\n+\t\t\tc.accountCache[account] = status\n+\t\t}\n+\t\tstatus.attempts = append(status.attempts, now)\n+\t\t_ = status.trim(now, lockoutPeriodAccount)\n+\t\tif len(status.attempts) >= maxAttemptsAccount {\n+\t\t\tstatus.lockedUntil = now.Add(lockoutPeriodAccount)\n+\t\t\tlockedUntil = status.lockedUntil\n+\t\t\tlockoutType = LockoutTypeAccount\n+\t\t}\n+\t}\n+\tif ip != \"\" {\n+\t\tstatus, found := c.ipCache[ip]\n+\t\tif !found {\n+\t\t\tstatus = &lockoutStatus{}\n+\t\t\tc.ipCache[ip] = status\n+\t\t}\n+\t\tstatus.attempts = append(status.attempts, now)\n+\t\t_ = status.trim(now, lockoutPeriodIp)\n+\t\tif len(status.attempts) >= maxAttemptsIp {\n+\t\t\tstatus.lockedUntil = now.Add(lockoutPeriodIp)\n+\t\t\tlockedUntil = status.lockedUntil\n+\t\t\tlockoutType = LockoutTypeIp\n+\t\t}\n+\t}\n+\treturn lockoutType, lockedUntil\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "1645d207813bf259b97c6b814416bb67fd81661b",
            "date": "2025-01-25T21:12:31Z",
            "author_login": "zyro"
          },
          {
            "sha": "320f5eb35a863b7a98dea04f3809b9e3eb7d5a2d",
            "date": "2025-01-24T17:11:19Z",
            "author_login": "ftkg"
          },
          {
            "sha": "ba3c0bc5ad7778ceeae3dc4837decba62c264a48",
            "date": "2025-01-24T16:59:41Z",
            "author_login": "sesposito"
          },
          {
            "sha": "77dd45625a15e3bd88fda601cd32dab57ee766d4",
            "date": "2025-01-24T12:24:34Z",
            "author_login": "sesposito"
          },
          {
            "sha": "f15adc2465c1a71f316b0e321a739c2fd8eb40d3",
            "date": "2025-01-24T12:06:36Z",
            "author_login": "sesposito"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-307",
    "description": "Improper Restriction of Excessive Authentication Attempts in GitHub repository heroiclabs/nakama prior to 3.13.0. This results in login brute-force attacks.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-07-05T19:15:07.817",
    "last_modified": "2024-11-21T07:00:45.980",
    "fix_date": "2022-07-05T18:22:19Z"
  },
  "references": [
    {
      "url": "https://github.com/heroiclabs/nakama/commit/e2e02fce80ff33ce45f8a6ebc0b7a99ee0b03824",
      "source": "security@huntr.dev",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/3055b3f5-6b80-4d47-8e00-3500dfb458bc",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/heroiclabs/nakama/commit/e2e02fce80ff33ce45f8a6ebc0b7a99ee0b03824",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/3055b3f5-6b80-4d47-8e00-3500dfb458bc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:11.457190",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "nakama",
    "owner": "heroiclabs",
    "created_at": "2017-01-13T17:15:12Z",
    "updated_at": "2025-01-26T07:57:08Z",
    "pushed_at": "2025-01-25T21:16:48Z",
    "size": 99312,
    "stars": 9261,
    "forks": 1116,
    "open_issues": 97,
    "watchers": 9261,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Go": 4235544,
      "TypeScript": 241538,
      "Lua": 217247,
      "HTML": 126027,
      "Shell": 25907,
      "SCSS": 19484,
      "Yacc": 14251,
      "Dockerfile": 3621,
      "Python": 2707,
      "JavaScript": 1014,
      "Makefile": 372
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T08:32:53.806370"
  }
}