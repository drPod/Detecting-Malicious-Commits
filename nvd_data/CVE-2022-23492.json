{
  "cve_id": "CVE-2022-23492",
  "github_data": {
    "repository": "libp2p/go-libp2p",
    "fix_commit": "15d7dfbf54264ead8e6f49ca658d79c90635e2de",
    "related_commits": [
      "15d7dfbf54264ead8e6f49ca658d79c90635e2de",
      "15d7dfbf54264ead8e6f49ca658d79c90635e2de"
    ],
    "patch_url": "https://github.com/libp2p/go-libp2p/commit/15d7dfbf54264ead8e6f49ca658d79c90635e2de.patch",
    "fix_commit_details": {
      "sha": "15d7dfbf54264ead8e6f49ca658d79c90635e2de",
      "commit_date": "2022-01-18T09:25:41Z",
      "author": {
        "login": "marten-seemann",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #1275 from libp2p/rcmgr",
        "length": 68,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 851,
        "additions": 681,
        "deletions": 170
      },
      "files": [
        {
          "filename": "config/config.go",
          "status": "modified",
          "additions": 13,
          "deletions": 5,
          "patch": "@@ -87,10 +87,12 @@ type Config struct {\n \tAddrsFactory    bhost.AddrsFactory\n \tConnectionGater connmgr.ConnectionGater\n \n-\tConnManager connmgr.ConnManager\n-\tNATManager  NATManagerC\n-\tPeerstore   peerstore.Peerstore\n-\tReporter    metrics.Reporter\n+\tConnManager     connmgr.ConnManager\n+\tResourceManager network.ResourceManager\n+\n+\tNATManager NATManagerC\n+\tPeerstore  peerstore.Peerstore\n+\tReporter   metrics.Reporter\n \n \tMultiaddrResolver *madns.Resolver\n \n@@ -148,6 +150,9 @@ func (cfg *Config) makeSwarm() (*swarm.Swarm, error) {\n \tif cfg.DialTimeout != 0 {\n \t\topts = append(opts, swarm.WithDialTimeout(cfg.DialTimeout))\n \t}\n+\tif cfg.ResourceManager != nil {\n+\t\topts = append(opts, swarm.WithResourceManager(cfg.ResourceManager))\n+\t}\n \t// TODO: Make the swarm implementation configurable.\n \treturn swarm.NewSwarm(pid, cfg.Peerstore, opts...)\n }\n@@ -179,11 +184,14 @@ func (cfg *Config) addTransports(h host.Host) error {\n \tif cfg.ConnectionGater != nil {\n \t\topts = append(opts, tptu.WithConnectionGater(cfg.ConnectionGater))\n \t}\n+\tif cfg.ResourceManager != nil {\n+\t\topts = append(opts, tptu.WithResourceManager(cfg.ResourceManager))\n+\t}\n \tupgrader, err := tptu.New(secure, muxer, opts...)\n \tif err != nil {\n \t\treturn err\n \t}\n-\ttpts, err := makeTransports(h, upgrader, cfg.ConnectionGater, cfg.PSK, cfg.Transports)\n+\ttpts, err := makeTransports(h, upgrader, cfg.ConnectionGater, cfg.PSK, cfg.ResourceManager, cfg.Transports)\n \tif err != nil {\n \t\treturn err\n \t}"
        },
        {
          "filename": "config/constructor_types.go",
          "status": "modified",
          "additions": 20,
          "deletions": 11,
          "patch": "@@ -7,7 +7,6 @@ import (\n \t\"github.com/libp2p/go-libp2p-core/connmgr\"\n \t\"github.com/libp2p/go-libp2p-core/crypto\"\n \t\"github.com/libp2p/go-libp2p-core/host\"\n-\t\"github.com/libp2p/go-libp2p-core/mux\"\n \t\"github.com/libp2p/go-libp2p-core/network\"\n \t\"github.com/libp2p/go-libp2p-core/peer\"\n \t\"github.com/libp2p/go-libp2p-core/peerstore\"\n@@ -21,41 +20,51 @@ var (\n \thostType      = reflect.TypeOf((*host.Host)(nil)).Elem()\n \tnetworkType   = reflect.TypeOf((*network.Network)(nil)).Elem()\n \ttransportType = reflect.TypeOf((*transport.Transport)(nil)).Elem()\n-\tmuxType       = reflect.TypeOf((*mux.Multiplexer)(nil)).Elem()\n+\tmuxType       = reflect.TypeOf((*network.Multiplexer)(nil)).Elem()\n \tsecurityType  = reflect.TypeOf((*sec.SecureTransport)(nil)).Elem()\n \tprivKeyType   = reflect.TypeOf((*crypto.PrivKey)(nil)).Elem()\n \tpubKeyType    = reflect.TypeOf((*crypto.PubKey)(nil)).Elem()\n \tpstoreType    = reflect.TypeOf((*peerstore.Peerstore)(nil)).Elem()\n \tconnGaterType = reflect.TypeOf((*connmgr.ConnectionGater)(nil)).Elem()\n \tupgraderType  = reflect.TypeOf((*transport.Upgrader)(nil)).Elem()\n+\trcmgrType     = reflect.TypeOf((*network.ResourceManager)(nil)).Elem()\n \n \t// concrete types\n \tpeerIDType = reflect.TypeOf((peer.ID)(\"\"))\n \tpskType    = reflect.TypeOf((pnet.PSK)(nil))\n )\n \n var argTypes = map[reflect.Type]constructor{\n-\tupgraderType: func(_ host.Host, u transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater) interface{} { return u },\n-\thostType:     func(h host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater) interface{} { return h },\n-\tnetworkType: func(h host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater) interface{} {\n+\tupgraderType: func(_ host.Host, u transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater, _ network.ResourceManager) interface{} {\n+\t\treturn u\n+\t},\n+\thostType: func(h host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater, _ network.ResourceManager) interface{} {\n+\t\treturn h\n+\t},\n+\tnetworkType: func(h host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater, _ network.ResourceManager) interface{} {\n \t\treturn h.Network()\n \t},\n-\tpskType: func(_ host.Host, _ transport.Upgrader, psk pnet.PSK, _ connmgr.ConnectionGater) interface{} {\n+\tpskType: func(_ host.Host, _ transport.Upgrader, psk pnet.PSK, _ connmgr.ConnectionGater, _ network.ResourceManager) interface{} {\n \t\treturn psk\n \t},\n-\tconnGaterType: func(_ host.Host, _ transport.Upgrader, _ pnet.PSK, cg connmgr.ConnectionGater) interface{} { return cg },\n-\tpeerIDType: func(h host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater) interface{} {\n+\tconnGaterType: func(_ host.Host, _ transport.Upgrader, _ pnet.PSK, cg connmgr.ConnectionGater, _ network.ResourceManager) interface{} {\n+\t\treturn cg\n+\t},\n+\tpeerIDType: func(h host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater, _ network.ResourceManager) interface{} {\n \t\treturn h.ID()\n \t},\n-\tprivKeyType: func(h host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater) interface{} {\n+\tprivKeyType: func(h host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater, _ network.ResourceManager) interface{} {\n \t\treturn h.Peerstore().PrivKey(h.ID())\n \t},\n-\tpubKeyType: func(h host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater) interface{} {\n+\tpubKeyType: func(h host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater, _ network.ResourceManager) interface{} {\n \t\treturn h.Peerstore().PubKey(h.ID())\n \t},\n-\tpstoreType: func(h host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater) interface{} {\n+\tpstoreType: func(h host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater, _ network.ResourceManager) interface{} {\n \t\treturn h.Peerstore()\n \t},\n+\trcmgrType: func(_ host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater, rcmgr network.ResourceManager) interface{} {\n+\t\treturn rcmgr\n+\t},\n }\n \n func newArgTypeSet(types ...reflect.Type) map[reflect.Type]constructor {"
        },
        {
          "filename": "config/muxer.go",
          "status": "modified",
          "additions": 11,
          "deletions": 10,
          "patch": "@@ -3,14 +3,15 @@ package config\n import (\n \t\"fmt\"\n \n-\t\"github.com/libp2p/go-libp2p-core/host\"\n-\t\"github.com/libp2p/go-libp2p-core/mux\"\n-\n \tmsmux \"github.com/libp2p/go-stream-muxer-multistream\"\n+\n+\t\"github.com/libp2p/go-libp2p-core/network\"\n+\n+\t\"github.com/libp2p/go-libp2p-core/host\"\n )\n \n // MuxC is a stream multiplex transport constructor.\n-type MuxC func(h host.Host) (mux.Multiplexer, error)\n+type MuxC func(h host.Host) (network.Multiplexer, error)\n \n // MsMuxC is a tuple containing a multiplex transport constructor and a protocol\n // ID.\n@@ -25,8 +26,8 @@ var muxArgTypes = newArgTypeSet(hostType, networkType, peerIDType, pstoreType)\n // using reflection.\n func MuxerConstructor(m interface{}) (MuxC, error) {\n \t// Already constructed?\n-\tif t, ok := m.(mux.Multiplexer); ok {\n-\t\treturn func(_ host.Host) (mux.Multiplexer, error) {\n+\tif t, ok := m.(network.Multiplexer); ok {\n+\t\treturn func(_ host.Host) (network.Multiplexer, error) {\n \t\t\treturn t, nil\n \t\t}, nil\n \t}\n@@ -35,16 +36,16 @@ func MuxerConstructor(m interface{}) (MuxC, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn func(h host.Host) (mux.Multiplexer, error) {\n-\t\tt, err := ctor(h, nil, nil, nil)\n+\treturn func(h host.Host) (network.Multiplexer, error) {\n+\t\tt, err := ctor(h, nil, nil, nil, nil)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\treturn t.(mux.Multiplexer), nil\n+\t\treturn t.(network.Multiplexer), nil\n \t}, nil\n }\n \n-func makeMuxer(h host.Host, tpts []MsMuxC) (mux.Multiplexer, error) {\n+func makeMuxer(h host.Host, tpts []MsMuxC) (network.Multiplexer, error) {\n \tmuxMuxer := msmux.NewBlankTransport()\n \ttransportSet := make(map[string]struct{}, len(tpts))\n \tfor _, tptC := range tpts {"
        },
        {
          "filename": "config/muxer_test.go",
          "status": "modified",
          "additions": 7,
          "deletions": 6,
          "patch": "@@ -3,18 +3,19 @@ package config\n import (\n \t\"testing\"\n \n+\t\"github.com/libp2p/go-libp2p-core/network\"\n+\n \t\"github.com/libp2p/go-libp2p-core/host\"\n \t\"github.com/libp2p/go-libp2p-core/peer\"\n \tswarmt \"github.com/libp2p/go-libp2p-swarm/testing\"\n \tbhost \"github.com/libp2p/go-libp2p/p2p/host/basic\"\n \n-\t\"github.com/libp2p/go-libp2p-core/mux\"\n \tyamux \"github.com/libp2p/go-libp2p-yamux\"\n )\n \n func TestMuxerSimple(t *testing.T) {\n \t// single\n-\t_, err := MuxerConstructor(func(_ peer.ID) mux.Multiplexer { return nil })\n+\t_, err := MuxerConstructor(func(_ peer.ID) network.Multiplexer { return nil })\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -27,14 +28,14 @@ func TestMuxerByValue(t *testing.T) {\n \t}\n }\n func TestMuxerDuplicate(t *testing.T) {\n-\t_, err := MuxerConstructor(func(_ peer.ID, _ peer.ID) mux.Multiplexer { return nil })\n+\t_, err := MuxerConstructor(func(_ peer.ID, _ peer.ID) network.Multiplexer { return nil })\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n }\n \n func TestMuxerError(t *testing.T) {\n-\t_, err := MuxerConstructor(func() (mux.Multiplexer, error) { return nil, nil })\n+\t_, err := MuxerConstructor(func() (network.Multiplexer, error) { return nil, nil })\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -45,8 +46,8 @@ func TestMuxerBadTypes(t *testing.T) {\n \t\tfunc() error { return nil },\n \t\tfunc() string { return \"\" },\n \t\tfunc() {},\n-\t\tfunc(string) mux.Multiplexer { return nil },\n-\t\tfunc(string) (mux.Multiplexer, error) { return nil, nil },\n+\t\tfunc(string) network.Multiplexer { return nil },\n+\t\tfunc(string) (network.Multiplexer, error) { return nil, nil },\n \t\tnil,\n \t\t\"testing\",\n \t} {"
        },
        {
          "filename": "config/reflection_magic.go",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -6,6 +6,8 @@ import (\n \t\"reflect\"\n \t\"runtime\"\n \n+\t\"github.com/libp2p/go-libp2p-core/network\"\n+\n \t\"github.com/libp2p/go-libp2p-core/pnet\"\n \n \t\"github.com/libp2p/go-libp2p-core/connmgr\"\n@@ -80,7 +82,7 @@ func callConstructor(c reflect.Value, args []reflect.Value) (interface{}, error)\n \treturn val, err\n }\n \n-type constructor func(h host.Host, u transport.Upgrader, psk pnet.PSK, cg connmgr.ConnectionGater) interface{}\n+type constructor func(host.Host, transport.Upgrader, pnet.PSK, connmgr.ConnectionGater, network.ResourceManager) interface{}\n \n func makeArgumentConstructors(fnType reflect.Type, argTypes map[reflect.Type]constructor) ([]constructor, error) {\n \tparams := fnType.NumIn()\n@@ -131,7 +133,7 @@ func makeConstructor(\n \ttptType reflect.Type,\n \targTypes map[reflect.Type]constructor,\n \topts ...interface{},\n-) (func(host.Host, transport.Upgrader, pnet.PSK, connmgr.ConnectionGater) (interface{}, error), error) {\n+) (func(host.Host, transport.Upgrader, pnet.PSK, connmgr.ConnectionGater, network.ResourceManager) (interface{}, error), error) {\n \tv := reflect.ValueOf(tpt)\n \t// avoid panicing on nil/zero value.\n \tif v == (reflect.Value{}) {\n@@ -155,10 +157,10 @@ func makeConstructor(\n \t\treturn nil, err\n \t}\n \n-\treturn func(h host.Host, u transport.Upgrader, psk pnet.PSK, cg connmgr.ConnectionGater) (interface{}, error) {\n+\treturn func(h host.Host, u transport.Upgrader, psk pnet.PSK, cg connmgr.ConnectionGater, rcmgr network.ResourceManager) (interface{}, error) {\n \t\targuments := make([]reflect.Value, 0, len(argConstructors)+len(opts))\n \t\tfor i, makeArg := range argConstructors {\n-\t\t\tif arg := makeArg(h, u, psk, cg); arg != nil {\n+\t\t\tif arg := makeArg(h, u, psk, cg, rcmgr); arg != nil {\n \t\t\t\targuments = append(arguments, reflect.ValueOf(arg))\n \t\t\t} else {\n \t\t\t\t// ValueOf an un-typed nil yields a zero reflect"
        },
        {
          "filename": "config/security.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -42,7 +42,7 @@ func SecurityConstructor(security interface{}) (SecC, error) {\n \t\treturn nil, err\n \t}\n \treturn func(h host.Host) (sec.SecureTransport, error) {\n-\t\tt, err := ctor(h, nil, nil, nil)\n+\t\tt, err := ctor(h, nil, nil, nil, nil)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}"
        },
        {
          "filename": "config/transport.go",
          "status": "modified",
          "additions": 7,
          "deletions": 6,
          "patch": "@@ -3,14 +3,15 @@ package config\n import (\n \t\"github.com/libp2p/go-libp2p-core/connmgr\"\n \t\"github.com/libp2p/go-libp2p-core/host\"\n+\t\"github.com/libp2p/go-libp2p-core/network\"\n \t\"github.com/libp2p/go-libp2p-core/pnet\"\n \t\"github.com/libp2p/go-libp2p-core/transport\"\n )\n \n // TptC is the type for libp2p transport constructors. You probably won't ever\n // implement this function interface directly. Instead, pass your transport\n // constructor to TransportConstructor.\n-type TptC func(host.Host, transport.Upgrader, pnet.PSK, connmgr.ConnectionGater) (transport.Transport, error)\n+type TptC func(host.Host, transport.Upgrader, pnet.PSK, connmgr.ConnectionGater, network.ResourceManager) (transport.Transport, error)\n \n var transportArgTypes = argTypes\n \n@@ -38,27 +39,27 @@ var transportArgTypes = argTypes\n func TransportConstructor(tpt interface{}, opts ...interface{}) (TptC, error) {\n \t// Already constructed?\n \tif t, ok := tpt.(transport.Transport); ok {\n-\t\treturn func(_ host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater) (transport.Transport, error) {\n+\t\treturn func(_ host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater, _ network.ResourceManager) (transport.Transport, error) {\n \t\t\treturn t, nil\n \t\t}, nil\n \t}\n \tctor, err := makeConstructor(tpt, transportType, transportArgTypes, opts...)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn func(h host.Host, u transport.Upgrader, psk pnet.PSK, cg connmgr.ConnectionGater) (transport.Transport, error) {\n-\t\tt, err := ctor(h, u, psk, cg)\n+\treturn func(h host.Host, u transport.Upgrader, psk pnet.PSK, cg connmgr.ConnectionGater, rcmgr network.ResourceManager) (transport.Transport, error) {\n+\t\tt, err := ctor(h, u, psk, cg, rcmgr)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t\treturn t.(transport.Transport), nil\n \t}, nil\n }\n \n-func makeTransports(h host.Host, u transport.Upgrader, cg connmgr.ConnectionGater, psk pnet.PSK, tpts []TptC) ([]transport.Transport, error) {\n+func makeTransports(h host.Host, u transport.Upgrader, cg connmgr.ConnectionGater, psk pnet.PSK, rcmgr network.ResourceManager, tpts []TptC) ([]transport.Transport, error) {\n \ttransports := make([]transport.Transport, len(tpts))\n \tfor i, tC := range tpts {\n-\t\tt, err := tC(h, u, psk, cg)\n+\t\tt, err := tC(h, u, psk, cg, rcmgr)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}"
        },
        {
          "filename": "config/transport_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -33,10 +33,10 @@ func TestConstructorWithOpts(t *testing.T) {\n \tvar options []int\n \tc, err := TransportConstructor(func(_ transport.Upgrader, opts ...int) (transport.Transport, error) {\n \t\toptions = opts\n-\t\treturn tcp.NewTCPTransport(nil)\n+\t\treturn tcp.NewTCPTransport(nil, nil)\n \t}, 42, 1337)\n \trequire.NoError(t, err)\n-\t_, err = c(nil, nil, nil, nil)\n+\t_, err = c(nil, nil, nil, nil, nil)\n \trequire.NoError(t, err)\n \trequire.Equal(t, []int{42, 1337}, options)\n }"
        },
        {
          "filename": "defaults.go",
          "status": "modified",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -10,6 +10,7 @@ import (\n \tnoise \"github.com/libp2p/go-libp2p-noise\"\n \t\"github.com/libp2p/go-libp2p-peerstore/pstoremem\"\n \tquic \"github.com/libp2p/go-libp2p-quic-transport\"\n+\trcmgr \"github.com/libp2p/go-libp2p-resource-manager\"\n \ttls \"github.com/libp2p/go-libp2p-tls\"\n \tyamux \"github.com/libp2p/go-libp2p-yamux\"\n \t\"github.com/libp2p/go-tcp-transport\"\n@@ -85,6 +86,19 @@ var DefaultEnableRelay = func(cfg *Config) error {\n \treturn cfg.Apply(EnableRelay())\n }\n \n+var DefaultResourceManager = func(cfg *Config) error {\n+\t// Default memory limit: 1/8th of total memory, minimum 128MB, maximum 1GB\n+\tlimiter := rcmgr.NewDefaultLimiter()\n+\tSetDefaultServiceLimits(limiter)\n+\n+\tmgr, err := rcmgr.NewResourceManager(limiter)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn cfg.Apply(ResourceManager(mgr))\n+}\n+\n // Complete list of default options and when to fallback on them.\n //\n // Please *DON'T* specify default options any other way. Putting this all here\n@@ -121,6 +135,10 @@ var defaults = []struct {\n \t\tfallback: func(cfg *Config) bool { return !cfg.RelayCustom },\n \t\topt:      DefaultEnableRelay,\n \t},\n+\t{\n+\t\tfallback: func(cfg *Config) bool { return cfg.ResourceManager == nil },\n+\t\topt:      DefaultResourceManager,\n+\t},\n }\n \n // Defaults configures libp2p to use the default options. Can be combined with"
        },
        {
          "filename": "go.mod",
          "status": "modified",
          "additions": 13,
          "deletions": 12,
          "patch": "@@ -22,23 +22,24 @@ require (\n \tgithub.com/libp2p/go-eventbus v0.2.1\n \tgithub.com/libp2p/go-libp2p-asn-util v0.1.0\n \tgithub.com/libp2p/go-libp2p-blankhost v0.3.0\n-\tgithub.com/libp2p/go-libp2p-circuit v0.4.1-0.20220104091935-28fb8d25f785\n-\tgithub.com/libp2p/go-libp2p-core v0.13.1-0.20220104083644-a3dd401efe36\n-\tgithub.com/libp2p/go-libp2p-mplex v0.4.1\n+\tgithub.com/libp2p/go-libp2p-circuit v0.6.0\n+\tgithub.com/libp2p/go-libp2p-core v0.14.0\n+\tgithub.com/libp2p/go-libp2p-mplex v0.5.0\n \tgithub.com/libp2p/go-libp2p-nat v0.1.0\n \tgithub.com/libp2p/go-libp2p-noise v0.3.0\n \tgithub.com/libp2p/go-libp2p-peerstore v0.6.0\n-\tgithub.com/libp2p/go-libp2p-quic-transport v0.15.2\n-\tgithub.com/libp2p/go-libp2p-swarm v0.9.1-0.20220104091227-f776b7e504b1\n-\tgithub.com/libp2p/go-libp2p-testing v0.6.1-0.20211214061856-c642a397cccd\n+\tgithub.com/libp2p/go-libp2p-quic-transport v0.16.0\n+\tgithub.com/libp2p/go-libp2p-resource-manager v0.1.0\n+\tgithub.com/libp2p/go-libp2p-swarm v0.10.0\n+\tgithub.com/libp2p/go-libp2p-testing v0.7.0\n \tgithub.com/libp2p/go-libp2p-tls v0.3.1\n-\tgithub.com/libp2p/go-libp2p-transport-upgrader v0.6.1-0.20220104084635-5fc0a74b41f0\n-\tgithub.com/libp2p/go-libp2p-yamux v0.7.0\n+\tgithub.com/libp2p/go-libp2p-transport-upgrader v0.7.0\n+\tgithub.com/libp2p/go-libp2p-yamux v0.8.0\n \tgithub.com/libp2p/go-msgio v0.1.0\n-\tgithub.com/libp2p/go-netroute v0.1.6\n-\tgithub.com/libp2p/go-stream-muxer-multistream v0.3.0\n-\tgithub.com/libp2p/go-tcp-transport v0.4.1-0.20220104085503-4ad75e6f32a5\n-\tgithub.com/libp2p/go-ws-transport v0.5.1-0.20220104085536-0bac7beec89d\n+\tgithub.com/libp2p/go-netroute v0.2.0\n+\tgithub.com/libp2p/go-stream-muxer-multistream v0.4.0\n+\tgithub.com/libp2p/go-tcp-transport v0.5.0\n+\tgithub.com/libp2p/go-ws-transport v0.6.0\n \tgithub.com/libp2p/zeroconf/v2 v2.1.1\n \tgithub.com/multiformats/go-multiaddr v0.5.0\n \tgithub.com/multiformats/go-multiaddr-dns v0.3.1"
        },
        {
          "filename": "go.sum",
          "status": "modified",
          "additions": 38,
          "deletions": 33,
          "patch": "@@ -334,7 +334,6 @@ github.com/ipfs/go-log/v2 v2.0.5/go.mod h1:eZs4Xt4ZUJQFM3DlanGhy7TkwwawCZcSByscw\n github.com/ipfs/go-log/v2 v2.1.1/go.mod h1:2v2nsGfZsvvAJz13SyFzf9ObaqwHiHxsPLEHntrv9KM=\n github.com/ipfs/go-log/v2 v2.1.3/go.mod h1:/8d0SH3Su5Ooc31QlL1WysJhvyOTDCjcCZ9Axpmri6g=\n github.com/ipfs/go-log/v2 v2.3.0/go.mod h1:QqGoj30OTpnKaG/LKTGTxoP2mmQtjVMEnK72gynbe/g=\n-github.com/ipfs/go-log/v2 v2.4.0/go.mod h1:nPZnh7Cj7lwS3LpRU5Mwr2ol1c2gXIEXuF6aywqrtmo=\n github.com/ipfs/go-log/v2 v2.5.0 h1:+MhAooFd9XZNvR0i9FriKW6HB0ql7HNXUuflWtc0dd4=\n github.com/ipfs/go-log/v2 v2.5.0/go.mod h1:prSpmC1Gpllc9UYWxDiZDreBYw7zp4Iqp1kOLU9U5UI=\n github.com/jackpal/go-nat-pmp v1.0.2 h1:KzKSgb7qkJvOUTqYl9/Hg/me3pWgBmERKrTGD7BdWus=\n@@ -368,8 +367,9 @@ github.com/kisielk/errcheck v1.2.0/go.mod h1:/BMXB+zMLi60iA8Vv6Ksmxu/1UDYcXs4uQL\n github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=\n github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\n github.com/kkdai/bstream v0.0.0-20161212061736-f391b8402d23/go.mod h1:J+Gs4SYgM6CZQHDETBtE9HaSEkGmuNXF86RwHhHUvq4=\n-github.com/klauspost/compress v1.11.7 h1:0hzRabrMN4tSTvMfnL3SCv1ZGeAP23ynzodBgaHeMeg=\n github.com/klauspost/compress v1.11.7/go.mod h1:aoV0uJVorq1K+umq18yTdKaF57EivdYsUV+/s2qKfXs=\n+github.com/klauspost/compress v1.13.6 h1:P76CopJELS0TiO2mebmnzgWaajssP/EszplttgQxcgc=\n+github.com/klauspost/compress v1.13.6/go.mod h1:/3/Vjq9QcHkK5uEr5lBEmyoZ1iFhe47etQ6QUkpK6sk=\n github.com/klauspost/cpuid/v2 v2.0.4/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=\n github.com/klauspost/cpuid/v2 v2.0.9 h1:lgaqFMSdTdQYdZ04uHyN2d/eKdOMyi2YLSvlQIBFYa4=\n github.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=\n@@ -405,8 +405,8 @@ github.com/libp2p/go-libp2p-asn-util v0.1.0/go.mod h1:wu+AnM9Ii2KgO5jMmS1rz9dvzT\n github.com/libp2p/go-libp2p-blankhost v0.2.0/go.mod h1:eduNKXGTioTuQAUcZ5epXi9vMl+t4d8ugUBRQ4SqaNQ=\n github.com/libp2p/go-libp2p-blankhost v0.3.0 h1:kTnLArltMabZlzY63pgGDA4kkUcLkBFSM98zBssn/IY=\n github.com/libp2p/go-libp2p-blankhost v0.3.0/go.mod h1:urPC+7U01nCGgJ3ZsV8jdwTp6Ji9ID0dMTvq+aJ+nZU=\n-github.com/libp2p/go-libp2p-circuit v0.4.1-0.20220104091935-28fb8d25f785 h1:zMKE9nQDjrfHoTFUMVAvY5GDYS7EYkr3oWNJjm729j0=\n-github.com/libp2p/go-libp2p-circuit v0.4.1-0.20220104091935-28fb8d25f785/go.mod h1:RsRUIXmHoYoSgM/Xi2dQY+YcWaBiK0oLpGkPwhsHNDk=\n+github.com/libp2p/go-libp2p-circuit v0.6.0 h1:rw/HlhmUB3OktS/Ygz6+2XABOmHKzZpPUuMNUMosj8w=\n+github.com/libp2p/go-libp2p-circuit v0.6.0/go.mod h1:kB8hY+zCpMeScyvFrKrGicRdid6vNXbunKE4rXATZ0M=\n github.com/libp2p/go-libp2p-core v0.2.0/go.mod h1:X0eyB0Gy93v0DZtSYbEM7RnMChm9Uv3j7yRXjO77xSI=\n github.com/libp2p/go-libp2p-core v0.3.0/go.mod h1:ACp3DmS3/N64c2jDzcV429ukDpicbL6+TrrxANBjPGw=\n github.com/libp2p/go-libp2p-core v0.5.0/go.mod h1:49XGI+kc38oGVwqSBhDEwytaAxgZasHhFfQKibzTls0=\n@@ -418,10 +418,11 @@ github.com/libp2p/go-libp2p-core v0.8.6/go.mod h1:dgHr0l0hIKfWpGpqAMbpo19pen9wJf\n github.com/libp2p/go-libp2p-core v0.10.0/go.mod h1:ECdxehoYosLYHgDDFa2N4yE8Y7aQRAMf0sX9mf2sbGg=\n github.com/libp2p/go-libp2p-core v0.11.0/go.mod h1:ECdxehoYosLYHgDDFa2N4yE8Y7aQRAMf0sX9mf2sbGg=\n github.com/libp2p/go-libp2p-core v0.12.0/go.mod h1:ECdxehoYosLYHgDDFa2N4yE8Y7aQRAMf0sX9mf2sbGg=\n-github.com/libp2p/go-libp2p-core v0.13.1-0.20220104083644-a3dd401efe36 h1:b/pMmgc5EV+dqSc+MjkX5xPa1nV6EKiOb0L0XT03Lic=\n-github.com/libp2p/go-libp2p-core v0.13.1-0.20220104083644-a3dd401efe36/go.mod h1:KlkHsZ0nKerWsXLZJm3LfFQwusI5k3iN4BgtYTE4IYE=\n-github.com/libp2p/go-libp2p-mplex v0.4.1 h1:/pyhkP1nLwjG3OM+VuaNJkQT/Pqq73WzB3aDN3Fx1sc=\n+github.com/libp2p/go-libp2p-core v0.14.0 h1:0kYSgiK/D7Eo28GTuRXo5YHsWwAisVpFCqCVPUd/vJs=\n+github.com/libp2p/go-libp2p-core v0.14.0/go.mod h1:tLasfcVdTXnixsLB0QYaT1syJOhsbrhG7q6pGrHtBg8=\n github.com/libp2p/go-libp2p-mplex v0.4.1/go.mod h1:cmy+3GfqfM1PceHTLL7zQzAAYaryDu6iPSC+CIb094g=\n+github.com/libp2p/go-libp2p-mplex v0.5.0 h1:vt3k4E4HSND9XH4Z8rUpacPJFSAgLOv6HDvG8W9Ks9E=\n+github.com/libp2p/go-libp2p-mplex v0.5.0/go.mod h1:eLImPJLkj3iG5t5lq68w3Vm5NAQ5BcKwrrb2VmOYb3M=\n github.com/libp2p/go-libp2p-nat v0.1.0 h1:vigUi2MEN+fwghe5ijpScxtbbDz+L/6y8XwlzYOJgSY=\n github.com/libp2p/go-libp2p-nat v0.1.0/go.mod h1:DQzAG+QbDYjN1/C3B6vXucLtz3u9rEonLVPtZVzQqks=\n github.com/libp2p/go-libp2p-noise v0.3.0 h1:NCVH7evhVt9njbTQshzT7N1S3Q6fjj9M11FCgfH5+cA=\n@@ -432,30 +433,32 @@ github.com/libp2p/go-libp2p-peerstore v0.6.0/go.mod h1:DGEmKdXrcYpK9Jha3sS7MhqYd\n github.com/libp2p/go-libp2p-pnet v0.2.0 h1:J6htxttBipJujEjz1y0a5+eYoiPcFHhSYHH6na5f0/k=\n github.com/libp2p/go-libp2p-pnet v0.2.0/go.mod h1:Qqvq6JH/oMZGwqs3N1Fqhv8NVhrdYcO0BW4wssv21LA=\n github.com/libp2p/go-libp2p-quic-transport v0.13.0/go.mod h1:39/ZWJ1TW/jx1iFkKzzUg00W6tDJh73FC0xYudjr7Hc=\n-github.com/libp2p/go-libp2p-quic-transport v0.15.2 h1:wHBEceRy+1/8Ec8dAIyr+/P7L2YefIGprPVy5LrMM+k=\n-github.com/libp2p/go-libp2p-quic-transport v0.15.2/go.mod h1:wv4uGwjcqe8Mhjj7N/Ic0aKjA+/10UnMlSzLO0yRpYQ=\n+github.com/libp2p/go-libp2p-quic-transport v0.16.0 h1:aVg9/jr+R2esov5sH7wkXrmYmqJiUjtLMLYX3L9KYdY=\n+github.com/libp2p/go-libp2p-quic-transport v0.16.0/go.mod h1:1BXjVMzr+w7EkPfiHkKnwsWjPjtfaNT0q8RS3tGDvEQ=\n+github.com/libp2p/go-libp2p-resource-manager v0.1.0 h1:tYpbhLPVC4egLavupAi9jGKKLeMemyGq5tnfBc8taBs=\n+github.com/libp2p/go-libp2p-resource-manager v0.1.0/go.mod h1:wJPNjeE4XQlxeidwqVY5G6DLOKqFK33u2n8blpl0I6Y=\n github.com/libp2p/go-libp2p-swarm v0.8.0/go.mod h1:sOMp6dPuqco0r0GHTzfVheVBh6UEL0L1lXUZ5ot2Fvc=\n-github.com/libp2p/go-libp2p-swarm v0.9.1-0.20220104091227-f776b7e504b1 h1:LsJE5h8hrv/WtmrxNi4WV+ctN0/ut7XxTl8hQu8VV2c=\n-github.com/libp2p/go-libp2p-swarm v0.9.1-0.20220104091227-f776b7e504b1/go.mod h1:BTllovQKjG9wYSVE9vP14kg7tSTW8ECcOlVXod2dgRs=\n+github.com/libp2p/go-libp2p-swarm v0.10.0 h1:1yr7UCwxCN92cw9g9Q+fnJSlk7lOB1RetoEewxhGVL0=\n+github.com/libp2p/go-libp2p-swarm v0.10.0/go.mod h1:71ceMcV6Rg/0rIQ97rsZWMzto1l9LnNquef+efcRbmA=\n github.com/libp2p/go-libp2p-testing v0.1.1/go.mod h1:xaZWMJrPUM5GlDBxCeGUi7kI4eqnjVyavGroI2nxEM0=\n github.com/libp2p/go-libp2p-testing v0.1.2-0.20200422005655-8775583591d8/go.mod h1:Qy8sAncLKpwXtS2dSnDOP8ktexIAHKu+J+pnZOFZLTc=\n github.com/libp2p/go-libp2p-testing v0.4.0/go.mod h1:Q+PFXYoiYFN5CAEG2w3gLPEzotlKsNSbKQ/lImlOWF0=\n github.com/libp2p/go-libp2p-testing v0.5.0/go.mod h1:QBk8fqIL1XNcno/l3/hhaIEn4aLRijpYOR+zVjjlh+A=\n-github.com/libp2p/go-libp2p-testing v0.6.0/go.mod h1:QBk8fqIL1XNcno/l3/hhaIEn4aLRijpYOR+zVjjlh+A=\n-github.com/libp2p/go-libp2p-testing v0.6.1-0.20211214061856-c642a397cccd h1:kGqONcelOVC+DxSuhhLYZ6itE64pKi6/Omxmu0kyp8I=\n-github.com/libp2p/go-libp2p-testing v0.6.1-0.20211214061856-c642a397cccd/go.mod h1:fi7jML2yROjVlnDhVwd45iGA6KP2Auaet/oCmyI/9u8=\n+github.com/libp2p/go-libp2p-testing v0.7.0 h1:9bfyhNINizxuLrKsenzGaZalXRXIaAEmx1BP/PzF1gM=\n+github.com/libp2p/go-libp2p-testing v0.7.0/go.mod h1:OLbdn9DbgdMwv00v+tlp1l3oe2Cl+FAjoWIA2pa0X6E=\n github.com/libp2p/go-libp2p-tls v0.3.0/go.mod h1:fwF5X6PWGxm6IDRwF3V8AVCCj/hOd5oFlg+wo2FxJDY=\n github.com/libp2p/go-libp2p-tls v0.3.1 h1:lsE2zYte+rZCEOHF72J1Fg3XK3dGQyKvI6i5ehJfEp0=\n github.com/libp2p/go-libp2p-tls v0.3.1/go.mod h1:fwF5X6PWGxm6IDRwF3V8AVCCj/hOd5oFlg+wo2FxJDY=\n github.com/libp2p/go-libp2p-transport-upgrader v0.5.0/go.mod h1:Rc+XODlB3yce7dvFV4q/RmyJGsFcCZRkeZMu/Zdg0mo=\n-github.com/libp2p/go-libp2p-transport-upgrader v0.6.1-0.20220104084635-5fc0a74b41f0 h1:eD/QJCpcImYOUl6MdBuxMByVaEe5VMm463zJG6oUg9o=\n-github.com/libp2p/go-libp2p-transport-upgrader v0.6.1-0.20220104084635-5fc0a74b41f0/go.mod h1:ByIyNe8asQhgcyIHetb4f+UgV+hDrA8pQ3L/TgNs+RI=\n+github.com/libp2p/go-libp2p-transport-upgrader v0.7.0 h1:ADnLrL7fC4Vy7HPjk9oGof7nDeTqGXuof85Ar6kin9Q=\n+github.com/libp2p/go-libp2p-transport-upgrader v0.7.0/go.mod h1:GIR2aTRp1J5yjVlkUoFqMkdobfob6RnAwYg/RZPhrzg=\n github.com/libp2p/go-libp2p-yamux v0.5.0/go.mod h1:AyR8k5EzyM2QN9Bbdg6X1SkVVuqLwTGf0L4DFq9g6po=\n-github.com/libp2p/go-libp2p-yamux v0.7.0 h1:bVXHbTj/XH4uBBsPrg26BlDABk5WYRlssY73P0SjhPc=\n-github.com/libp2p/go-libp2p-yamux v0.7.0/go.mod h1:fMyA0CsPfHkIuBU0wjRGrCjTBFiXTXxG0k5M4ETv+08=\n+github.com/libp2p/go-libp2p-yamux v0.8.0 h1:APQYlttIj+Rr5sfa6siojwsi0ZwcIh/exHIUl9hZr6o=\n+github.com/libp2p/go-libp2p-yamux v0.8.0/go.mod h1:yTkPgN2ib8FHyU1ZcVD7aelzyAqXXwEPbyx+aSKm9h8=\n github.com/libp2p/go-maddr-filter v0.1.0/go.mod h1:VzZhTXkMucEGGEOSKddrwGiOv0tUhgnKqNEmIAz/bPU=\n-github.com/libp2p/go-mplex v0.3.0 h1:U1T+vmCYJaEoDJPV1aq31N56hS+lJgb397GsylNSgrU=\n github.com/libp2p/go-mplex v0.3.0/go.mod h1:0Oy/A9PQlwBytDRp4wSkFnzHYDKcpLot35JQ6msjvYQ=\n+github.com/libp2p/go-mplex v0.4.0 h1:Ukkez9/4EOX5rTw4sHefNJp10dksftAA05ZgyjplUbM=\n+github.com/libp2p/go-mplex v0.4.0/go.mod h1:y26Lx+wNVtMYMaPu300Cbot5LkEZ4tJaNYeHeT9dh6E=\n github.com/libp2p/go-msgio v0.0.4/go.mod h1:63lBBgOTDKQL6EWazRMCwXsEeEeK9O2Cd+0+6OOuipQ=\n github.com/libp2p/go-msgio v0.0.6/go.mod h1:4ecVB6d9f4BDSL5fqvPiC4A3KivjWn+Venn/1ALLMWA=\n github.com/libp2p/go-msgio v0.1.0 h1:8Q7g/528ivAlfXTFWvWhVjTE8XG8sDTkRUKPYh9+5Q8=\n@@ -465,8 +468,8 @@ github.com/libp2p/go-nat v0.1.0/go.mod h1:X7teVkwRHNInVNWQiO/tAiAVRwSr5zoRz4YSTC\n github.com/libp2p/go-netroute v0.1.2/go.mod h1:jZLDV+1PE8y5XxBySEBgbuVAXbhtuHSdmLPL2n9MKbk=\n github.com/libp2p/go-netroute v0.1.3/go.mod h1:jZLDV+1PE8y5XxBySEBgbuVAXbhtuHSdmLPL2n9MKbk=\n github.com/libp2p/go-netroute v0.1.5/go.mod h1:V1SR3AaECRkEQCoFFzYwVYWvYIEtlxx89+O3qcpCl4A=\n-github.com/libp2p/go-netroute v0.1.6 h1:ruPJStbYyXVYGQ81uzEDzuvbYRLKRrLvTYd33yomC38=\n-github.com/libp2p/go-netroute v0.1.6/go.mod h1:AqhkMh0VuWmfgtxKPp3Oc1LdU5QSWS7wl0QLhSZqXxQ=\n+github.com/libp2p/go-netroute v0.2.0 h1:0FpsbsvuSnAhXFnCY0VLFbJOzaK0VnP0r1QT/o4nWRE=\n+github.com/libp2p/go-netroute v0.2.0/go.mod h1:Vio7LTzZ+6hoT4CMZi5/6CpY3Snzh2vgZhWgxMNwlQI=\n github.com/libp2p/go-openssl v0.0.4/go.mod h1:unDrJpgy3oFr+rqXsarWifmJuNnJR4chtO1HmaZjggc=\n github.com/libp2p/go-openssl v0.0.5/go.mod h1:unDrJpgy3oFr+rqXsarWifmJuNnJR4chtO1HmaZjggc=\n github.com/libp2p/go-openssl v0.0.7 h1:eCAzdLejcNVBzP/iZM9vqHnQm+XyCEbSSIheIPRGNsw=\n@@ -477,26 +480,25 @@ github.com/libp2p/go-reuseport-transport v0.1.0 h1:C3PHeHjmnz8m6f0uydObj02tMEoi7\n github.com/libp2p/go-reuseport-transport v0.1.0/go.mod h1:vev0C0uMkzriDY59yFHD9v+ujJvYmDQVLowvAjEOmfw=\n github.com/libp2p/go-sockaddr v0.0.2/go.mod h1:syPvOmNs24S3dFVGJA1/mrqdeijPxLV2Le3BRLKd68k=\n github.com/libp2p/go-sockaddr v0.1.0/go.mod h1:syPvOmNs24S3dFVGJA1/mrqdeijPxLV2Le3BRLKd68k=\n-github.com/libp2p/go-sockaddr v0.1.1 h1:yD80l2ZOdGksnOyHrhxDdTDFrf7Oy+v3FMVArIRgZxQ=\n-github.com/libp2p/go-sockaddr v0.1.1/go.mod h1:syPvOmNs24S3dFVGJA1/mrqdeijPxLV2Le3BRLKd68k=\n-github.com/libp2p/go-stream-muxer-multistream v0.3.0 h1:TqnSHPJEIqDEO7h1wZZ0p3DXdvDSiLHQidKKUGZtiOY=\n github.com/libp2p/go-stream-muxer-multistream v0.3.0/go.mod h1:yDh8abSIzmZtqtOt64gFJUXEryejzNb0lisTt+fAMJA=\n+github.com/libp2p/go-stream-muxer-multistream v0.4.0 h1:HsM/9OdtqnIzjVXcxTXjmqKrj3gJ8kacaOJwJS1ipaY=\n+github.com/libp2p/go-stream-muxer-multistream v0.4.0/go.mod h1:nb+dGViZleRP4XcyHuZSVrJCBl55nRBOMmiSL/dyziw=\n github.com/libp2p/go-tcp-transport v0.4.0/go.mod h1:0y52Rwrn4076xdJYu/51/qJIdxz+EWDAOG2S45sV3VI=\n-github.com/libp2p/go-tcp-transport v0.4.1-0.20220104085503-4ad75e6f32a5 h1:/x3GSszKipn1nlKY0C5at59fBLYyJeObd5gm32DrobM=\n-github.com/libp2p/go-tcp-transport v0.4.1-0.20220104085503-4ad75e6f32a5/go.mod h1:YPwlF5gW5BnFikKoQBuJeQkPXAn+z2wTzDpJKamkgjY=\n-github.com/libp2p/go-ws-transport v0.5.1-0.20220104085536-0bac7beec89d h1:2C9MSQsQ4teo3JRtBlN2CbS6xXC/Qk40kgMFO0rdjEM=\n-github.com/libp2p/go-ws-transport v0.5.1-0.20220104085536-0bac7beec89d/go.mod h1:aXV24UYVRjIiMXhs+/qygvfYklQmhUzmhVi5cSiQu5Y=\n+github.com/libp2p/go-tcp-transport v0.5.0 h1:3ZPW8HAuyRAuFzyabE0hSrCXKKSWzROnZZX7DtcIatY=\n+github.com/libp2p/go-tcp-transport v0.5.0/go.mod h1:UPPL0DIjQqiWRwVAb+CEQlaAG0rp/mCqJfIhFcLHc4Y=\n+github.com/libp2p/go-ws-transport v0.6.0 h1:326XBL6Q+5CQ2KtjXz32+eGu02W/Kz2+Fm4SpXdr0q4=\n+github.com/libp2p/go-ws-transport v0.6.0/go.mod h1:dXqtI9e2JV9FtF1NOtWVZSKXh5zXvnuwPXfj8GPBbYU=\n github.com/libp2p/go-yamux v1.4.1 h1:P1Fe9vF4th5JOxxgQvfbOHkrGqIZniTLf+ddhZp8YTI=\n github.com/libp2p/go-yamux v1.4.1/go.mod h1:fr7aVgmdNGJK+N1g+b6DW6VxzbRCjCOejR/hkmpooHE=\n-github.com/libp2p/go-yamux/v2 v2.3.0 h1:luRV68GS1vqqr6EFUjtu1kr51d+IbW0gSowu8emYWAI=\n-github.com/libp2p/go-yamux/v2 v2.3.0/go.mod h1:iTU+lOIn/2h0AgKcL49clNTwfEw+WSfDYrXe05EyKIs=\n+github.com/libp2p/go-yamux/v3 v3.0.1 h1:lIdxHGVZ+y/EHgCrqGNt4Q+Mk9qu26MbOWH/yRw+Ihk=\n+github.com/libp2p/go-yamux/v3 v3.0.1/go.mod h1:s2LsDhHbh+RfCsQoICSYt58U2f8ijtPANFD8BmE74Bo=\n github.com/libp2p/zeroconf/v2 v2.1.1 h1:XAuSczA96MYkVwH+LqqqCUZb2yH3krobMJ1YE+0hG2s=\n github.com/libp2p/zeroconf/v2 v2.1.1/go.mod h1:fuJqLnUwZTshS3U/bMRJ3+ow/v9oid1n0DmyYyNO1Xs=\n github.com/lightstep/lightstep-tracer-common/golang/gogo v0.0.0-20190605223551-bc2310a04743/go.mod h1:qklhhLq1aX+mtWk9cPHPzaBjWImj5ULL6C7HFJtXQMM=\n github.com/lightstep/lightstep-tracer-go v0.18.1/go.mod h1:jlF1pusYV4pidLvZ+XD0UBX0ZE6WURAspgAczcDHrL4=\n github.com/lucas-clemente/quic-go v0.23.0/go.mod h1:paZuzjXCE5mj6sikVLMvqXk8lJV2AsqtJ6bDhjEfxx0=\n-github.com/lucas-clemente/quic-go v0.24.0 h1:ToR7SIIEdrgOhgVTHvPgdVRJfgVy+N0wQAagH7L4d5g=\n-github.com/lucas-clemente/quic-go v0.24.0/go.mod h1:paZuzjXCE5mj6sikVLMvqXk8lJV2AsqtJ6bDhjEfxx0=\n+github.com/lucas-clemente/quic-go v0.25.0 h1:K+X9Gvd7JXsOHtU0N2icZ2Nw3rx82uBej3mP4CLgibc=\n+github.com/lucas-clemente/quic-go v0.25.0/go.mod h1:YtzP8bxRVCBlO77yRanE264+fY/T2U9ZlW1AaHOsMOg=\n github.com/lunixbochs/vtclean v1.0.0/go.mod h1:pHhQNgMf3btfWnGBVipUOjRYhoOsdGqdm/+2c2E2WMI=\n github.com/lyft/protoc-gen-validate v0.0.13/go.mod h1:XbGvPuh87YZc5TdIa2/I4pLk0QoUACkjt2znoq26NVQ=\n github.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=\n@@ -508,6 +510,8 @@ github.com/marten-seemann/qtls-go1-16 v0.1.4 h1:xbHbOGGhrenVtII6Co8akhLEdrawwB2i\n github.com/marten-seemann/qtls-go1-16 v0.1.4/go.mod h1:gNpI2Ol+lRS3WwSOtIUUtRwZEQMXjYK+dQSBFbethAk=\n github.com/marten-seemann/qtls-go1-17 v0.1.0 h1:P9ggrs5xtwiqXv/FHNwntmuLMNq3KaSIG93AtAZ48xk=\n github.com/marten-seemann/qtls-go1-17 v0.1.0/go.mod h1:fz4HIxByo+LlWcreM4CZOYNuz3taBQ8rN2X6FqvaWo8=\n+github.com/marten-seemann/qtls-go1-18 v0.1.0-beta.1 h1:EnzzN9fPUkUck/1CuY1FlzBaIYMoiBsdwTNmNGkwUUM=\n+github.com/marten-seemann/qtls-go1-18 v0.1.0-beta.1/go.mod h1:PUhIQk19LoFt2174H4+an8TYvWOGjb/hHwphBeaDHwI=\n github.com/marten-seemann/tcp v0.0.0-20210406111302-dfbc87cc63fd h1:br0buuQ854V8u83wA0rVZ8ttrq5CpaPZdvrK0LP2lOk=\n github.com/marten-seemann/tcp v0.0.0-20210406111302-dfbc87cc63fd/go.mod h1:QuCEs1Nt24+FYQEqAAncTDPJIuGs+LxK1MCiFL25pMU=\n github.com/mattn/go-colorable v0.0.9/go.mod h1:9vuHe8Xs5qXnSaW/c/ABM9alt+Vo+STaOChaDxuIBZU=\n@@ -639,7 +643,6 @@ github.com/opentracing-contrib/go-observer v0.0.0-20170622124052-a52f23424492/go\n github.com/opentracing/basictracer-go v1.0.0/go.mod h1:QfBfYuafItcjQuMwinw9GhYKwFXS9KnPs5lxoYwgW74=\n github.com/opentracing/opentracing-go v1.0.2/go.mod h1:UkNAQd3GIcIGf0SeVgPpRdFStlNbqXla1AfSYxPUl2o=\n github.com/opentracing/opentracing-go v1.1.0/go.mod h1:UkNAQd3GIcIGf0SeVgPpRdFStlNbqXla1AfSYxPUl2o=\n-github.com/opentracing/opentracing-go v1.2.0 h1:uEJPy/1a5RIPAJ0Ov+OIO8OxWu77jEv+1B0VhjKrZUs=\n github.com/opentracing/opentracing-go v1.2.0/go.mod h1:GxEUsuufX4nBwe+T+Wl9TAgYrxe9dPLANfrWvHYVTgc=\n github.com/openzipkin-contrib/zipkin-go-opentracing v0.4.5/go.mod h1:/wsWhb9smxSfWAKL3wpBW7V8scJMt8N8gnaMCS9E/cA=\n github.com/openzipkin/zipkin-go v0.1.1/go.mod h1:NtoC/o8u3JlF1lSlyPNswIbeQH9bJTmOf0Erfk+hxe8=\n@@ -648,6 +651,8 @@ github.com/openzipkin/zipkin-go v0.2.1/go.mod h1:NaW6tEwdmWMaCDZzg8sh+IBNOxHMPnh\n github.com/openzipkin/zipkin-go v0.2.2/go.mod h1:NaW6tEwdmWMaCDZzg8sh+IBNOxHMPnhQw8ySjnjRyN4=\n github.com/pact-foundation/pact-go v1.0.4/go.mod h1:uExwJY4kCzNPcHRj+hCR/HBbOOIwwtUjcrb0b5/5kLM=\n github.com/pascaldekloe/goe v0.0.0-20180627143212-57f6aae5913c/go.mod h1:lzWF7FIEvWOWxwDKqyGYQf6ZUaNfKdP144TG7ZOy1lc=\n+github.com/pbnjay/memory v0.0.0-20210728143218-7b4eea64cf58 h1:onHthvaw9LFnH4t2DcNVpwGmV9E1BkGknEliJkfwQj0=\n+github.com/pbnjay/memory v0.0.0-20210728143218-7b4eea64cf58/go.mod h1:DXv8WO4yhMYhSNPKjeNKa5WY9YCIEBRbNzFFPJbWO6Y=\n github.com/pborman/uuid v1.2.0/go.mod h1:X/NO0urCmaxf9VXbdlT7C2Yzkj2IKimNn4k+gtPdI/k=\n github.com/pelletier/go-toml v1.2.0/go.mod h1:5z9KED0ma1S8pY6P1sdut58dfprrGBbd/94hg7ilaic=\n github.com/performancecopilot/speed v3.0.0+incompatible/go.mod h1:/CLtqpZ5gBg1M9iaPbIdPPGyKcA8hKdoy6hAWba7Yac="
        },
        {
          "filename": "libp2p_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -45,7 +45,7 @@ func TestTransportConstructor(t *testing.T) {\n \t\t_ connmgr.ConnectionGater,\n \t\tupgrader transport.Upgrader,\n \t) transport.Transport {\n-\t\ttpt, err := tcp.NewTCPTransport(upgrader)\n+\t\ttpt, err := tcp.NewTCPTransport(upgrader, nil)\n \t\trequire.NoError(t, err)\n \t\treturn tpt\n \t}"
        },
        {
          "filename": "limits.go",
          "status": "added",
          "additions": 157,
          "deletions": 0,
          "patch": "@@ -0,0 +1,157 @@\n+package libp2p\n+\n+import (\n+\t\"github.com/libp2p/go-libp2p-core/protocol\"\n+\n+\t\"github.com/libp2p/go-libp2p/p2p/host/autonat\"\n+\trelayv1 \"github.com/libp2p/go-libp2p/p2p/protocol/circuitv1/relay\"\n+\tcircuit \"github.com/libp2p/go-libp2p/p2p/protocol/circuitv2/proto\"\n+\trelayv2 \"github.com/libp2p/go-libp2p/p2p/protocol/circuitv2/relay\"\n+\t\"github.com/libp2p/go-libp2p/p2p/protocol/holepunch\"\n+\t\"github.com/libp2p/go-libp2p/p2p/protocol/identify\"\n+\t\"github.com/libp2p/go-libp2p/p2p/protocol/ping\"\n+\n+\trcmgr \"github.com/libp2p/go-libp2p-resource-manager\"\n+)\n+\n+// SetDefaultServiceLimits sets the default limits for bundled libp2p services\n+//\n+// More specifically this sets the following limits:\n+// - identify:\n+//   128 streams in, 128 streams out, 256 streams total, 4MB min, 64MB max svc memory\n+//   16/16/32 streams per peer\n+// - ping:\n+//   128 streams in, 128 sreams out, 256 streasms total, 4MB min, 64MB max svc memory\n+//   2/3/4 streams per peer\n+// - autonat\n+//   128 streams in, 128 streams out, 128 streams total, 4MB min, 64MB max svc memory\n+//   2/2/2 streams per peer\n+// - holepunch\n+//   128 streams in, 128 streams out, 128 streams total, 4MB min, 64MB max svc memory\n+//   2/2/2 streams per peer\n+// - relay v1 and v2 (separate services)\n+//   1024 streams in, 1024 streams out, 1024 streams total, 4MB min, 64MB max svc memory\n+//   64/64/64 streams per peer\n+func SetDefaultServiceLimits(limiter *rcmgr.BasicLimiter) {\n+\tif limiter.ServiceLimits == nil {\n+\t\tlimiter.ServiceLimits = make(map[string]rcmgr.Limit)\n+\t}\n+\tif limiter.ServicePeerLimits == nil {\n+\t\tlimiter.ServicePeerLimits = make(map[string]rcmgr.Limit)\n+\t}\n+\tif limiter.ProtocolLimits == nil {\n+\t\tlimiter.ProtocolLimits = make(map[protocol.ID]rcmgr.Limit)\n+\t}\n+\tif limiter.ProtocolPeerLimits == nil {\n+\t\tlimiter.ProtocolPeerLimits = make(map[protocol.ID]rcmgr.Limit)\n+\t}\n+\n+\t// identify\n+\tsetServiceLimits(limiter, identify.ServiceName,\n+\t\tlimiter.DefaultServiceLimits.\n+\t\t\tWithMemoryLimit(1, 4<<20, 64<<20). // max 64MB service memory\n+\t\t\tWithStreamLimit(128, 128, 256),    // max 256 streams -- symmetric\n+\t\tpeerLimit(16, 16, 32))\n+\n+\tsetProtocolLimits(limiter, identify.ID,\n+\t\tlimiter.DefaultProtocolLimits.WithMemoryLimit(1, 4<<20, 32<<20),\n+\t\tpeerLimit(16, 16, 32))\n+\tsetProtocolLimits(limiter, identify.IDPush,\n+\t\tlimiter.DefaultProtocolLimits.WithMemoryLimit(1, 4<<20, 32<<20),\n+\t\tpeerLimit(16, 16, 32))\n+\tsetProtocolLimits(limiter, identify.IDDelta,\n+\t\tlimiter.DefaultProtocolLimits.WithMemoryLimit(1, 4<<20, 32<<20),\n+\t\tpeerLimit(16, 16, 32))\n+\n+\t// ping\n+\tsetServiceLimits(limiter, ping.ServiceName,\n+\t\tlimiter.DefaultServiceLimits.\n+\t\t\tWithMemoryLimit(1, 4<<20, 64<<20). // max 64MB service memory\n+\t\t\tWithStreamLimit(128, 128, 128),    // max 128 streams - asymmetric\n+\t\tpeerLimit(2, 3, 4))\n+\tsetProtocolLimits(limiter, ping.ID,\n+\t\tlimiter.DefaultProtocolLimits.WithMemoryLimit(1, 4<<20, 64<<20),\n+\t\tpeerLimit(2, 3, 4))\n+\n+\t// autonat\n+\tsetServiceLimits(limiter, autonat.ServiceName,\n+\t\tlimiter.DefaultServiceLimits.\n+\t\t\tWithMemoryLimit(1, 4<<20, 64<<20). // max 64MB service memory\n+\t\t\tWithStreamLimit(128, 128, 128),    // max 128 streams - asymmetric\n+\t\tpeerLimit(2, 2, 2))\n+\tsetProtocolLimits(limiter, autonat.AutoNATProto,\n+\t\tlimiter.DefaultProtocolLimits.WithMemoryLimit(1, 4<<20, 64<<20),\n+\t\tpeerLimit(2, 2, 2))\n+\n+\t// holepunch\n+\tsetServiceLimits(limiter, holepunch.ServiceName,\n+\t\tlimiter.DefaultServiceLimits.\n+\t\t\tWithMemoryLimit(1, 4<<20, 64<<20). // max 64MB service memory\n+\t\t\tWithStreamLimit(128, 128, 256),    // max 256 streams - symmetric\n+\t\tpeerLimit(2, 2, 2))\n+\tsetProtocolLimits(limiter, holepunch.Protocol,\n+\t\tlimiter.DefaultProtocolLimits.WithMemoryLimit(1, 4<<20, 64<<20),\n+\t\tpeerLimit(2, 2, 2))\n+\n+\t// relay/v1\n+\tsetServiceLimits(limiter, relayv1.ServiceName,\n+\t\tlimiter.DefaultServiceLimits.\n+\t\t\tWithMemoryLimit(1, 4<<20, 64<<20). // max 64MB service memory\n+\t\t\tWithStreamLimit(1024, 1024, 1024), // max 1024 streams - asymmetric\n+\t\tpeerLimit(64, 64, 64))\n+\n+\t// relay/v2\n+\tsetServiceLimits(limiter, relayv2.ServiceName,\n+\t\tlimiter.DefaultServiceLimits.\n+\t\t\tWithMemoryLimit(1, 4<<20, 64<<20). // max 64MB service memory\n+\t\t\tWithStreamLimit(1024, 1024, 1024), // max 1024 streams - asymmetric\n+\t\tpeerLimit(64, 64, 64))\n+\n+\t// circuit protocols, both client and service\n+\tsetProtocolLimits(limiter, circuit.ProtoIDv1,\n+\t\tlimiter.DefaultProtocolLimits.\n+\t\t\tWithMemoryLimit(1, 4<<20, 64<<20).\n+\t\t\tWithStreamLimit(1280, 1280, 1280),\n+\t\tpeerLimit(128, 128, 128))\n+\tsetProtocolLimits(limiter, circuit.ProtoIDv2Hop,\n+\t\tlimiter.DefaultProtocolLimits.\n+\t\t\tWithMemoryLimit(1, 4<<20, 64<<20).\n+\t\t\tWithStreamLimit(1280, 1280, 1280),\n+\t\tpeerLimit(128, 128, 128))\n+\tsetProtocolLimits(limiter, circuit.ProtoIDv2Stop,\n+\t\tlimiter.DefaultProtocolLimits.\n+\t\t\tWithMemoryLimit(1, 4<<20, 64<<20).\n+\t\t\tWithStreamLimit(1280, 1280, 1280),\n+\t\tpeerLimit(128, 128, 128))\n+\n+}\n+\n+func setServiceLimits(limiter *rcmgr.BasicLimiter, svc string, limit rcmgr.Limit, peerLimit rcmgr.Limit) {\n+\tif _, ok := limiter.ServiceLimits[svc]; !ok {\n+\t\tlimiter.ServiceLimits[svc] = limit\n+\t}\n+\tif _, ok := limiter.ServicePeerLimits[svc]; !ok {\n+\t\tlimiter.ServicePeerLimits[svc] = peerLimit\n+\t}\n+}\n+\n+func setProtocolLimits(limiter *rcmgr.BasicLimiter, proto protocol.ID, limit rcmgr.Limit, peerLimit rcmgr.Limit) {\n+\tif _, ok := limiter.ProtocolLimits[proto]; !ok {\n+\t\tlimiter.ProtocolLimits[proto] = limit\n+\t}\n+\tif _, ok := limiter.ProtocolPeerLimits[proto]; !ok {\n+\t\tlimiter.ProtocolPeerLimits[proto] = peerLimit\n+\t}\n+}\n+\n+func peerLimit(numStreamsIn, numStreamsOut, numStreamsTotal int) rcmgr.Limit {\n+\treturn &rcmgr.StaticLimit{\n+\t\t// memory: 256kb for window buffers plus some change for message buffers per stream\n+\t\tMemory: int64(numStreamsTotal * (256<<10 + 16384)),\n+\t\tBaseLimit: rcmgr.BaseLimit{\n+\t\t\tStreamsInbound:  numStreamsIn,\n+\t\t\tStreamsOutbound: numStreamsOut,\n+\t\t\tStreams:         numStreamsTotal,\n+\t\t},\n+\t}\n+}"
        },
        {
          "filename": "options.go",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -346,6 +346,17 @@ func ConnectionGater(cg connmgr.ConnectionGater) Option {\n \t}\n }\n \n+// ResourceManager configures libp2p to use the given ResourceManager.\n+func ResourceManager(rcmgr network.ResourceManager) Option {\n+\treturn func(cfg *Config) error {\n+\t\tif cfg.ResourceManager != nil {\n+\t\t\treturn errors.New(\"cannot configure multiple resource managers\")\n+\t\t}\n+\t\tcfg.ResourceManager = rcmgr\n+\t\treturn nil\n+\t}\n+}\n+\n // NATPortMap configures libp2p to use the default NATManager. The default\n // NATManager will attempt to open a port in your network's firewall using UPnP.\n func NATPortMap() Option {"
        },
        {
          "filename": "p2p/host/autonat/client.go",
          "status": "modified",
          "additions": 15,
          "deletions": 1,
          "patch": "@@ -36,12 +36,26 @@ func (c *client) DialBack(ctx context.Context, p peer.ID) (ma.Multiaddr, error)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\n+\tif err := s.Scope().SetService(ServiceName); err != nil {\n+\t\tlog.Debugf(\"error attaching stream to autonat service: %s\", err)\n+\t\ts.Reset()\n+\t\treturn nil, err\n+\t}\n+\n+\tif err := s.Scope().ReserveMemory(maxMsgSize, network.ReservationPriorityAlways); err != nil {\n+\t\tlog.Debugf(\"error reserving memory for autonat stream: %s\", err)\n+\t\ts.Reset()\n+\t\treturn nil, err\n+\t}\n+\tdefer s.Scope().ReleaseMemory(maxMsgSize)\n+\n \ts.SetDeadline(time.Now().Add(streamTimeout))\n \t// Might as well just reset the stream. Once we get to this point, we\n \t// don't care about being nice.\n \tdefer s.Close()\n \n-\tr := protoio.NewDelimitedReader(s, network.MessageSizeMax)\n+\tr := protoio.NewDelimitedReader(s, maxMsgSize)\n \tw := protoio.NewDelimitedWriter(s)\n \n \treq := newDialMessage(peer.AddrInfo{ID: c.h.ID(), Addrs: c.addrFunc()})"
        },
        {
          "filename": "p2p/host/autonat/svc.go",
          "status": "modified",
          "additions": 20,
          "deletions": 1,
          "patch": "@@ -19,6 +19,12 @@ import (\n \n var streamTimeout = 60 * time.Second\n \n+const (\n+\tServiceName = \"libp2p.autonat\"\n+\n+\tmaxMsgSize = 4096\n+)\n+\n // AutoNATService provides NAT autodetection services to other peers\n type autoNATService struct {\n \tinstanceLock      sync.Mutex\n@@ -45,13 +51,26 @@ func newAutoNATService(c *config) (*autoNATService, error) {\n }\n \n func (as *autoNATService) handleStream(s network.Stream) {\n+\tif err := s.Scope().SetService(ServiceName); err != nil {\n+\t\tlog.Debugf(\"error attaching stream to autonat service: %s\", err)\n+\t\ts.Reset()\n+\t\treturn\n+\t}\n+\n+\tif err := s.Scope().ReserveMemory(maxMsgSize, network.ReservationPriorityAlways); err != nil {\n+\t\tlog.Debugf(\"error reserving memory for autonat stream: %s\", err)\n+\t\ts.Reset()\n+\t\treturn\n+\t}\n+\tdefer s.Scope().ReleaseMemory(maxMsgSize)\n+\n \ts.SetDeadline(time.Now().Add(streamTimeout))\n \tdefer s.Close()\n \n \tpid := s.Conn().RemotePeer()\n \tlog.Debugf(\"New stream from %s\", pid.Pretty())\n \n-\tr := protoio.NewDelimitedReader(s, network.MessageSizeMax)\n+\tr := protoio.NewDelimitedReader(s, maxMsgSize)\n \tw := protoio.NewDelimitedWriter(s)\n \n \tvar req pb.Message"
        },
        {
          "filename": "p2p/host/basic/basic_host.go",
          "status": "modified",
          "additions": 7,
          "deletions": 2,
          "patch": "@@ -405,7 +405,12 @@ func (h *BasicHost) newStreamHandler(s network.Stream) {\n \t\t}\n \t}\n \n-\ts.SetProtocol(protocol.ID(protoID))\n+\tif err := s.SetProtocol(protocol.ID(protoID)); err != nil {\n+\t\tlog.Debugf(\"error setting stream protocol: %s\", err)\n+\t\ts.Reset()\n+\t\treturn\n+\t}\n+\n \tlog.Debugf(\"protocol negotiation took %s\", took)\n \n \tgo handle(protoID, s)\n@@ -1009,7 +1014,7 @@ func (h *BasicHost) SetAutoNat(a autonat.AutoNAT) {\n \t}\n }\n \n-// Return the host's AutoNAT service, if AutoNAT is enabled.\n+// GetAutoNat returns the host's AutoNAT service, if AutoNAT is enabled.\n func (h *BasicHost) GetAutoNat() autonat.AutoNAT {\n \th.addrMu.Lock()\n \tdefer h.addrMu.Unlock()"
        },
        {
          "filename": "p2p/net/connmgr/connmgr_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -795,6 +795,7 @@ func (m mockConn) Stat() network.ConnStats                               { retur\n func (m mockConn) ID() string                                            { panic(\"implement me\") }\n func (m mockConn) NewStream(ctx context.Context) (network.Stream, error) { panic(\"implement me\") }\n func (m mockConn) GetStreams() []network.Stream                          { panic(\"implement me\") }\n+func (m mockConn) Scope() network.ConnScope                              { panic(\"implement me\") }\n \n func TestPeerInfoSorting(t *testing.T) {\n \tt.Run(\"starts with temporary connections\", func(t *testing.T) {"
        },
        {
          "filename": "p2p/net/mock/mock_conn.go",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -195,3 +195,7 @@ func (c *conn) RemotePublicKey() ic.PubKey {\n func (c *conn) Stat() network.ConnStats {\n \treturn c.stat\n }\n+\n+func (c *conn) Scope() network.ConnScope {\n+\treturn network.NullScope\n+}"
        },
        {
          "filename": "p2p/net/mock/mock_peernet.go",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -368,3 +368,7 @@ func (pn *peernet) notifyAll(notification func(f network.Notifiee)) {\n \tpn.notifmu.Unlock()\n \twg.Wait()\n }\n+\n+func (pn *peernet) ResourceManager() network.ResourceManager {\n+\treturn network.NullResourceManager\n+}"
        },
        {
          "filename": "p2p/net/mock/mock_stream.go",
          "status": "modified",
          "additions": 11,
          "deletions": 7,
          "patch": "@@ -10,7 +10,6 @@ import (\n \t\"sync/atomic\"\n \t\"time\"\n \n-\t\"github.com/libp2p/go-libp2p-core/mux\"\n \t\"github.com/libp2p/go-libp2p-core/network\"\n \t\"github.com/libp2p/go-libp2p-core/protocol\"\n )\n@@ -105,8 +104,9 @@ func (s *stream) Stat() network.Stats {\n \treturn s.stat\n }\n \n-func (s *stream) SetProtocol(proto protocol.ID) {\n+func (s *stream) SetProtocol(proto protocol.ID) error {\n \ts.protocol.Store(proto)\n+\treturn nil\n }\n \n func (s *stream) CloseWrite() error {\n@@ -132,8 +132,8 @@ func (s *stream) Close() error {\n \n func (s *stream) Reset() error {\n \t// Cancel any pending reads/writes with an error.\n-\ts.write.CloseWithError(mux.ErrReset)\n-\ts.read.CloseWithError(mux.ErrReset)\n+\ts.write.CloseWithError(network.ErrReset)\n+\ts.read.CloseWithError(network.ErrReset)\n \n \tselect {\n \tcase s.reset <- struct{}{}:\n@@ -236,7 +236,7 @@ func (s *stream) transport() {\n \t\t\t\tcase s.reset <- struct{}{}:\n \t\t\t\tdefault:\n \t\t\t\t}\n-\t\t\t\treturn mux.ErrReset\n+\t\t\t\treturn network.ErrReset\n \t\t\t}\n \t\t\tif err := drainBuf(); err != nil {\n \t\t\t\treturn err\n@@ -256,14 +256,14 @@ func (s *stream) transport() {\n \t\t// Reset takes precedent.\n \t\tselect {\n \t\tcase <-s.reset:\n-\t\t\ts.writeErr = mux.ErrReset\n+\t\t\ts.writeErr = network.ErrReset\n \t\t\treturn\n \t\tdefault:\n \t\t}\n \n \t\tselect {\n \t\tcase <-s.reset:\n-\t\t\ts.writeErr = mux.ErrReset\n+\t\t\ts.writeErr = network.ErrReset\n \t\t\treturn\n \t\tcase <-s.close:\n \t\t\tif err := drainBuf(); err != nil {\n@@ -289,6 +289,10 @@ func (s *stream) transport() {\n \t}\n }\n \n+func (s *stream) Scope() network.StreamScope {\n+\treturn network.NullScope\n+}\n+\n func (s *stream) cancelWrite(err error) {\n \ts.write.CloseWithError(err)\n \ts.writeErr = err"
        },
        {
          "filename": "p2p/protocol/circuitv1/relay/relay.go",
          "status": "modified",
          "additions": 84,
          "deletions": 25,
          "patch": "@@ -25,6 +25,8 @@ var log = logging.Logger(\"relay\")\n const (\n \tProtoID = \"/libp2p/circuit/relay/0.1.0\"\n \n+\tServiceName = \"libp2p.relay/v1\"\n+\n \tStreamTimeout    = time.Minute\n \tConnectTimeout   = 30 * time.Second\n \tHandshakeTimeout = time.Minute\n@@ -40,9 +42,10 @@ type Relay struct {\n \tctx    context.Context\n \tcancel context.CancelFunc\n \n-\thost host.Host\n-\trc   Resources\n-\tacl  ACLFilter\n+\thost  host.Host\n+\trc    Resources\n+\tacl   ACLFilter\n+\tscope network.ResourceScopeSpan\n \n \tmx     sync.Mutex\n \tconns  map[peer.ID]int\n@@ -64,6 +67,17 @@ func NewRelay(h host.Host, opts ...Option) (*Relay, error) {\n \t\t}\n \t}\n \n+\t// get a scope for memory reservations at service level\n+\terr := h.Network().ResourceManager().ViewService(ServiceName,\n+\t\tfunc(s network.ServiceScope) error {\n+\t\t\tvar err error\n+\t\t\tr.scope, err = s.BeginSpan()\n+\t\t\treturn err\n+\t\t})\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n \th.SetStreamHandler(ProtoID, r.handleStream)\n \n \treturn r, nil\n@@ -72,19 +86,33 @@ func NewRelay(h host.Host, opts ...Option) (*Relay, error) {\n func (r *Relay) Close() error {\n \tif atomic.CompareAndSwapInt32(&r.closed, 0, 1) {\n \t\tr.host.RemoveStreamHandler(ProtoID)\n+\t\tr.scope.Done()\n \t\tr.cancel()\n \t}\n \treturn nil\n }\n \n func (r *Relay) handleStream(s network.Stream) {\n-\ts.SetReadDeadline(time.Now().Add(StreamTimeout))\n-\n \tlog.Debugf(\"new relay stream from: %s\", s.Conn().RemotePeer())\n \n+\tif err := s.Scope().SetService(ServiceName); err != nil {\n+\t\tlog.Debugf(\"error attaching stream to relay service: %s\", err)\n+\t\ts.Reset()\n+\t\treturn\n+\t}\n+\n+\tif err := s.Scope().ReserveMemory(maxMessageSize, network.ReservationPriorityAlways); err != nil {\n+\t\tlog.Debugf(\"error reserving memory for stream: %s\", err)\n+\t\ts.Reset()\n+\t\treturn\n+\t}\n+\tdefer s.Scope().ReleaseMemory(maxMessageSize)\n+\n \trd := util.NewDelimitedReader(s, maxMessageSize)\n \tdefer rd.Close()\n \n+\ts.SetReadDeadline(time.Now().Add(StreamTimeout))\n+\n \tvar msg pb.CircuitRelay\n \n \terr := rd.ReadMsg(&msg)\n@@ -108,55 +136,74 @@ func (r *Relay) handleStream(s network.Stream) {\n }\n \n func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {\n+\tspan, err := r.scope.BeginSpan()\n+\tif err != nil {\n+\t\tlog.Debugf(\"failed to begin relay transaction: %s\", err)\n+\t\tr.handleError(s, pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)\n+\t\treturn\n+\t}\n+\n+\tfail := func(code pb.CircuitRelay_Status) {\n+\t\tspan.Done()\n+\t\tr.handleError(s, code)\n+\t}\n+\n+\t// reserve buffers for the relay\n+\tif err := span.ReserveMemory(2*r.rc.BufferSize, network.ReservationPriorityHigh); err != nil {\n+\t\tlog.Debugf(\"error reserving memory for relay: %s\", err)\n+\t\tfail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)\n+\t\treturn\n+\t}\n+\n \tsrc, err := peerToPeerInfo(msg.GetSrcPeer())\n \tif err != nil {\n-\t\tr.handleError(s, pb.CircuitRelay_HOP_SRC_MULTIADDR_INVALID)\n+\t\tfail(pb.CircuitRelay_HOP_SRC_MULTIADDR_INVALID)\n \t\treturn\n \t}\n \n \tif src.ID != s.Conn().RemotePeer() {\n-\t\tr.handleError(s, pb.CircuitRelay_HOP_SRC_MULTIADDR_INVALID)\n+\t\tfail(pb.CircuitRelay_HOP_SRC_MULTIADDR_INVALID)\n \t\treturn\n \t}\n \n \tdest, err := peerToPeerInfo(msg.GetDstPeer())\n \tif err != nil {\n-\t\tr.handleError(s, pb.CircuitRelay_HOP_DST_MULTIADDR_INVALID)\n+\t\tfail(pb.CircuitRelay_HOP_DST_MULTIADDR_INVALID)\n \t\treturn\n \t}\n \n \tif dest.ID == r.host.ID() {\n-\t\tr.handleError(s, pb.CircuitRelay_HOP_CANT_RELAY_TO_SELF)\n+\t\tfail(pb.CircuitRelay_HOP_CANT_RELAY_TO_SELF)\n \t\treturn\n \t}\n \n \tif r.acl != nil && !r.acl.AllowHop(src.ID, dest.ID) {\n \t\tlog.Debugf(\"refusing hop from %s to %s; ACL refused\", src.ID, dest.ID)\n-\t\tr.handleError(s, pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)\n+\t\tfail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)\n \t\treturn\n \t}\n \n \tr.mx.Lock()\n \tif r.active >= r.rc.MaxCircuits {\n \t\tr.mx.Unlock()\n \t\tlog.Debugf(\"refusing connection from %s to %s; too many active circuits\", src.ID, dest.ID)\n-\t\tr.handleError(s, pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)\n+\t\tfail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)\n \t\treturn\n \t}\n \n \tsrcConns := r.conns[src.ID]\n \tif srcConns >= r.rc.MaxCircuitsPerPeer {\n \t\tr.mx.Unlock()\n \t\tlog.Debugf(\"refusing connection from %s to %s; too many connections from %s\", src.ID, dest.ID, src)\n-\t\tr.handleError(s, pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)\n+\t\tfail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)\n \t\treturn\n \t}\n \n \tdestConns := r.conns[dest.ID]\n \tif destConns >= r.rc.MaxCircuitsPerPeer {\n \t\tr.mx.Unlock()\n \t\tlog.Debugf(\"refusing connection from %s to %s; too many connecitons to %s\", src.ID, dest.ID, dest.ID)\n-\t\tr.handleError(s, pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)\n+\t\tfail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)\n \t\treturn\n \t}\n \n@@ -166,6 +213,7 @@ func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {\n \tr.mx.Unlock()\n \n \tcleanup := func() {\n+\t\tspan.Done()\n \t\tr.mx.Lock()\n \t\tr.active--\n \t\tr.rmConn(src.ID)\n@@ -190,7 +238,26 @@ func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {\n \t\treturn\n \t}\n \n+\tfail = func(code pb.CircuitRelay_Status) {\n+\t\tbs.Reset()\n+\t\tcleanup()\n+\t\tr.handleError(s, code)\n+\t}\n+\n+\tif err := bs.Scope().SetService(ServiceName); err != nil {\n+\t\tlog.Debugf(\"error attaching stream to relay service: %s\", err)\n+\t\tfail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)\n+\t\treturn\n+\t}\n+\n \t// stop handshake\n+\tif err := bs.Scope().ReserveMemory(maxMessageSize, network.ReservationPriorityAlways); err != nil {\n+\t\tlog.Debugf(\"failed to reserve memory for stream: %s\", err)\n+\t\tfail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)\n+\t\treturn\n+\t}\n+\tdefer bs.Scope().ReleaseMemory(maxMessageSize)\n+\n \trd := util.NewDelimitedReader(bs, maxMessageSize)\n \twr := util.NewDelimitedWriter(bs)\n \tdefer rd.Close()\n@@ -203,9 +270,7 @@ func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {\n \terr = wr.WriteMsg(msg)\n \tif err != nil {\n \t\tlog.Debugf(\"error writing stop handshake: %s\", err.Error())\n-\t\tbs.Reset()\n-\t\tr.handleError(s, pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)\n-\t\tcleanup()\n+\t\tfail(pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)\n \t\treturn\n \t}\n \n@@ -214,25 +279,19 @@ func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {\n \terr = rd.ReadMsg(msg)\n \tif err != nil {\n \t\tlog.Debugf(\"error reading stop response: %s\", err.Error())\n-\t\tbs.Reset()\n-\t\tr.handleError(s, pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)\n-\t\tcleanup()\n+\t\tfail(pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)\n \t\treturn\n \t}\n \n \tif msg.GetType() != pb.CircuitRelay_STATUS {\n \t\tlog.Debugf(\"unexpected relay stop response: not a status message (%d)\", msg.GetType())\n-\t\tbs.Reset()\n-\t\tr.handleError(s, pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)\n-\t\tcleanup()\n+\t\tfail(pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)\n \t\treturn\n \t}\n \n \tif msg.GetCode() != pb.CircuitRelay_SUCCESS {\n \t\tlog.Debugf(\"relay stop failure: %d\", msg.GetCode())\n-\t\tbs.Reset()\n-\t\tr.handleError(s, msg.GetCode())\n-\t\tcleanup()\n+\t\tfail(msg.GetCode())\n \t\treturn\n \t}\n "
        },
        {
          "filename": "p2p/protocol/circuitv2/client/dial.go",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -144,6 +144,12 @@ func (c *Client) dialPeer(ctx context.Context, relay, dest peer.AddrInfo) (*Conn\n }\n \n func (c *Client) connectV2(s network.Stream, dest peer.AddrInfo) (*Conn, error) {\n+\tif err := s.Scope().ReserveMemory(maxMessageSize, network.ReservationPriorityAlways); err != nil {\n+\t\ts.Reset()\n+\t\treturn nil, err\n+\t}\n+\tdefer s.Scope().ReleaseMemory(maxMessageSize)\n+\n \trd := util.NewDelimitedReader(s, maxMessageSize)\n \twr := util.NewDelimitedWriter(s)\n \tdefer rd.Close()\n@@ -196,6 +202,12 @@ func (c *Client) connectV2(s network.Stream, dest peer.AddrInfo) (*Conn, error)\n }\n \n func (c *Client) connectV1(s network.Stream, dest peer.AddrInfo) (*Conn, error) {\n+\tif err := s.Scope().ReserveMemory(maxMessageSize, network.ReservationPriorityAlways); err != nil {\n+\t\ts.Reset()\n+\t\treturn nil, err\n+\t}\n+\tdefer s.Scope().ReleaseMemory(maxMessageSize)\n+\n \trd := util.NewDelimitedReader(s, maxMessageSize)\n \twr := util.NewDelimitedWriter(s)\n \tdefer rd.Close()"
        },
        {
          "filename": "p2p/protocol/circuitv2/client/transport.go",
          "status": "modified",
          "additions": 10,
          "deletions": 3,
          "patch": "@@ -50,14 +50,21 @@ var _ transport.Transport = (*Client)(nil)\n var _ io.Closer = (*Client)(nil)\n \n func (c *Client) Dial(ctx context.Context, a ma.Multiaddr, p peer.ID) (transport.CapableConn, error) {\n+\tconnScope, err := c.host.Network().ResourceManager().OpenConnection(network.DirOutbound, false)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif err := connScope.SetPeer(p); err != nil {\n+\t\tconnScope.Done()\n+\t\treturn nil, err\n+\t}\n \tconn, err := c.dial(ctx, a, p)\n \tif err != nil {\n+\t\tconnScope.Done()\n \t\treturn nil, err\n \t}\n-\n \tconn.tagHop()\n-\n-\treturn c.upgrader.Upgrade(ctx, c, conn, network.DirOutbound, p)\n+\treturn c.upgrader.Upgrade(ctx, c, conn, network.DirOutbound, p, connScope)\n }\n \n func (c *Client) CanDial(addr ma.Multiaddr) bool {"
        },
        {
          "filename": "p2p/protocol/circuitv2/relay/relay.go",
          "status": "modified",
          "additions": 79,
          "deletions": 20,
          "patch": "@@ -24,6 +24,8 @@ import (\n )\n \n const (\n+\tServiceName = \"libp2p.relay/v2\"\n+\n \tReservationTagWeight = 10\n \n \tStreamTimeout    = time.Minute\n@@ -48,6 +50,7 @@ type Relay struct {\n \trc          Resources\n \tacl         ACLFilter\n \tconstraints *constraints\n+\tscope       network.ResourceScopeSpan\n \n \tmx    sync.Mutex\n \trsvp  map[peer.ID]time.Time\n@@ -77,6 +80,17 @@ func New(h host.Host, opts ...Option) (*Relay, error) {\n \t\t}\n \t}\n \n+\t// get a scope for memory reservations at service level\n+\terr := h.Network().ResourceManager().ViewService(ServiceName,\n+\t\tfunc(s network.ServiceScope) error {\n+\t\t\tvar err error\n+\t\t\tr.scope, err = s.BeginSpan()\n+\t\t\treturn err\n+\t\t})\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n \tr.constraints = newConstraints(&r.rc)\n \tr.selfAddr = ma.StringCast(fmt.Sprintf(\"/p2p/%s\", h.ID()))\n \n@@ -93,6 +107,7 @@ func New(h host.Host, opts ...Option) (*Relay, error) {\n func (r *Relay) Close() error {\n \tif atomic.CompareAndSwapUint32(&r.closed, 0, 1) {\n \t\tr.host.RemoveStreamHandler(proto.ProtoIDv2Hop)\n+\t\tr.scope.Done()\n \t\tr.cancel()\n \t\tr.mx.Lock()\n \t\tfor p := range r.rsvp {\n@@ -104,13 +119,26 @@ func (r *Relay) Close() error {\n }\n \n func (r *Relay) handleStream(s network.Stream) {\n-\ts.SetReadDeadline(time.Now().Add(StreamTimeout))\n-\n \tlog.Infof(\"new relay stream from: %s\", s.Conn().RemotePeer())\n \n+\tif err := s.Scope().SetService(ServiceName); err != nil {\n+\t\tlog.Debugf(\"error attaching stream to relay service: %s\", err)\n+\t\ts.Reset()\n+\t\treturn\n+\t}\n+\n+\tif err := s.Scope().ReserveMemory(maxMessageSize, network.ReservationPriorityAlways); err != nil {\n+\t\tlog.Debugf(\"error reserving memory for stream: %s\", err)\n+\t\ts.Reset()\n+\t\treturn\n+\t}\n+\tdefer s.Scope().ReleaseMemory(maxMessageSize)\n+\n \trd := util.NewDelimitedReader(s, maxMessageSize)\n \tdefer rd.Close()\n \n+\ts.SetReadDeadline(time.Now().Add(StreamTimeout))\n+\n \tvar msg pbv2.HopMessage\n \n \terr := rd.ReadMsg(&msg)\n@@ -184,21 +212,40 @@ func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {\n \tsrc := s.Conn().RemotePeer()\n \ta := s.Conn().RemoteMultiaddr()\n \n+\tspan, err := r.scope.BeginSpan()\n+\tif err != nil {\n+\t\tlog.Debugf(\"failed to begin relay transaction: %s\", err)\n+\t\tr.handleError(s, pbv2.Status_RESOURCE_LIMIT_EXCEEDED)\n+\t\treturn\n+\t}\n+\n+\tfail := func(status pbv2.Status) {\n+\t\tspan.Done()\n+\t\tr.handleError(s, status)\n+\t}\n+\n+\t// reserve buffers for the relay\n+\tif err := span.ReserveMemory(2*r.rc.BufferSize, network.ReservationPriorityHigh); err != nil {\n+\t\tlog.Debugf(\"error reserving memory for relay: %s\", err)\n+\t\tfail(pbv2.Status_RESOURCE_LIMIT_EXCEEDED)\n+\t\treturn\n+\t}\n+\n \tif isRelayAddr(a) {\n \t\tlog.Debugf(\"refusing connection from %s; connection attempt over relay connection\")\n-\t\tr.handleError(s, pbv2.Status_PERMISSION_DENIED)\n+\t\tfail(pbv2.Status_PERMISSION_DENIED)\n \t\treturn\n \t}\n \n \tdest, err := util.PeerToPeerInfoV2(msg.GetPeer())\n \tif err != nil {\n-\t\tr.handleError(s, pbv2.Status_MALFORMED_MESSAGE)\n+\t\tfail(pbv2.Status_MALFORMED_MESSAGE)\n \t\treturn\n \t}\n \n \tif r.acl != nil && !r.acl.AllowConnect(src, s.Conn().RemoteMultiaddr(), dest.ID) {\n \t\tlog.Debugf(\"refusing connection from %s to %s; permission denied\", src, dest.ID)\n-\t\tr.handleError(s, pbv2.Status_PERMISSION_DENIED)\n+\t\tfail(pbv2.Status_PERMISSION_DENIED)\n \t\treturn\n \t}\n \n@@ -207,23 +254,23 @@ func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {\n \tif !rsvp {\n \t\tr.mx.Unlock()\n \t\tlog.Debugf(\"refusing connection from %s to %s; no reservation\", src, dest.ID)\n-\t\tr.handleError(s, pbv2.Status_NO_RESERVATION)\n+\t\tfail(pbv2.Status_NO_RESERVATION)\n \t\treturn\n \t}\n \n \tsrcConns := r.conns[src]\n \tif srcConns >= r.rc.MaxCircuits {\n \t\tr.mx.Unlock()\n \t\tlog.Debugf(\"refusing connection from %s to %s; too many connections from %s\", src, dest.ID, src)\n-\t\tr.handleError(s, pbv2.Status_RESOURCE_LIMIT_EXCEEDED)\n+\t\tfail(pbv2.Status_RESOURCE_LIMIT_EXCEEDED)\n \t\treturn\n \t}\n \n \tdestConns := r.conns[dest.ID]\n \tif destConns >= r.rc.MaxCircuits {\n \t\tr.mx.Unlock()\n \t\tlog.Debugf(\"refusing connection from %s to %s; too many connecitons to %s\", src, dest.ID, dest.ID)\n-\t\tr.handleError(s, pbv2.Status_RESOURCE_LIMIT_EXCEEDED)\n+\t\tfail(pbv2.Status_RESOURCE_LIMIT_EXCEEDED)\n \t\treturn\n \t}\n \n@@ -232,6 +279,7 @@ func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {\n \tr.mx.Unlock()\n \n \tcleanup := func() {\n+\t\tspan.Done()\n \t\tr.mx.Lock()\n \t\tr.rmConn(src)\n \t\tr.rmConn(dest.ID)\n@@ -251,7 +299,26 @@ func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {\n \t\treturn\n \t}\n \n+\tfail = func(status pbv2.Status) {\n+\t\tbs.Reset()\n+\t\tcleanup()\n+\t\tr.handleError(s, status)\n+\t}\n+\n+\tif err := bs.Scope().SetService(ServiceName); err != nil {\n+\t\tlog.Debugf(\"error attaching stream to relay service: %s\", err)\n+\t\tfail(pbv2.Status_RESOURCE_LIMIT_EXCEEDED)\n+\t\treturn\n+\t}\n+\n \t// handshake\n+\tif err := bs.Scope().ReserveMemory(maxMessageSize, network.ReservationPriorityAlways); err != nil {\n+\t\tlog.Debugf(\"erro reserving memory for stream: %s\", err)\n+\t\tfail(pbv2.Status_RESOURCE_LIMIT_EXCEEDED)\n+\t\treturn\n+\t}\n+\tdefer bs.Scope().ReleaseMemory(maxMessageSize)\n+\n \trd := util.NewDelimitedReader(bs, maxMessageSize)\n \twr := util.NewDelimitedWriter(bs)\n \tdefer rd.Close()\n@@ -266,9 +333,7 @@ func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {\n \terr = wr.WriteMsg(&stopmsg)\n \tif err != nil {\n \t\tlog.Debugf(\"error writing stop handshake\")\n-\t\tbs.Reset()\n-\t\tcleanup()\n-\t\tr.handleError(s, pbv2.Status_CONNECTION_FAILED)\n+\t\tfail(pbv2.Status_CONNECTION_FAILED)\n \t\treturn\n \t}\n \n@@ -277,25 +342,19 @@ func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {\n \terr = rd.ReadMsg(&stopmsg)\n \tif err != nil {\n \t\tlog.Debugf(\"error reading stop response: %s\", err.Error())\n-\t\tbs.Reset()\n-\t\tcleanup()\n-\t\tr.handleError(s, pbv2.Status_CONNECTION_FAILED)\n+\t\tfail(pbv2.Status_CONNECTION_FAILED)\n \t\treturn\n \t}\n \n \tif t := stopmsg.GetType(); t != pbv2.StopMessage_STATUS {\n \t\tlog.Debugf(\"unexpected stop response; not a status message (%d)\", t)\n-\t\tbs.Reset()\n-\t\tcleanup()\n-\t\tr.handleError(s, pbv2.Status_CONNECTION_FAILED)\n+\t\tfail(pbv2.Status_CONNECTION_FAILED)\n \t\treturn\n \t}\n \n \tif status := stopmsg.GetStatus(); status != pbv2.Status_OK {\n \t\tlog.Debugf(\"relay stop failure: %d\", status)\n-\t\tbs.Reset()\n-\t\tcleanup()\n-\t\tr.handleError(s, pbv2.Status_CONNECTION_FAILED)\n+\t\tfail(pbv2.Status_CONNECTION_FAILED)\n \t\treturn\n \t}\n "
        },
        {
          "filename": "p2p/protocol/circuitv2/relay/relay_test.go",
          "status": "modified",
          "additions": 4,
          "deletions": 5,
          "patch": "@@ -18,7 +18,6 @@ import (\n \n \t\"github.com/libp2p/go-libp2p-core/crypto\"\n \t\"github.com/libp2p/go-libp2p-core/host\"\n-\t\"github.com/libp2p/go-libp2p-core/mux\"\n \t\"github.com/libp2p/go-libp2p-core/network\"\n \t\"github.com/libp2p/go-libp2p-core/peer\"\n \n@@ -60,7 +59,7 @@ func getNetHosts(t *testing.T, ctx context.Context, n int) (hosts []host.Host, u\n \t\tupgrader := swarmt.GenUpgrader(t, netw)\n \t\tupgraders = append(upgraders, upgrader)\n \n-\t\ttpt, err := tcp.NewTCPTransport(upgrader)\n+\t\ttpt, err := tcp.NewTCPTransport(upgrader, nil)\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n@@ -246,12 +245,12 @@ func TestRelayLimitTime(t *testing.T) {\n \tif n > 0 {\n \t\tt.Fatalf(\"expected to write 0 bytes, wrote %d\", n)\n \t}\n-\tif err != mux.ErrReset {\n+\tif err != network.ErrReset {\n \t\tt.Fatalf(\"expected reset, but got %s\", err)\n \t}\n \n \terr = <-rch\n-\tif err != mux.ErrReset {\n+\tif err != network.ErrReset {\n \t\tt.Fatalf(\"expected reset, but got %s\", err)\n \t}\n }\n@@ -279,7 +278,7 @@ func TestRelayLimitData(t *testing.T) {\n \t\t}\n \n \t\tn, err := s.Read(buf)\n-\t\tif err != mux.ErrReset {\n+\t\tif err != network.ErrReset {\n \t\t\tt.Fatalf(\"expected reset but got %s\", err)\n \t\t}\n \t\trch <- n"
        },
        {
          "filename": "p2p/protocol/holepunch/coordination.go",
          "status": "modified",
          "additions": 34,
          "deletions": 3,
          "patch": "@@ -28,6 +28,8 @@ var StreamTimeout = 1 * time.Minute\n \n // TODO Should we have options for these ?\n const (\n+\tServiceName = \"libp2p.holepunch\"\n+\n \tmaxMsgSize  = 4 * 1024 // 4K\n \tdialTimeout = 5 * time.Second\n \tmaxRetries  = 3\n@@ -146,15 +148,30 @@ func (hs *Service) Close() error {\n func (hs *Service) initiateHolePunch(rp peer.ID) ([]ma.Multiaddr, time.Duration, error) {\n \thpCtx := network.WithUseTransient(hs.ctx, \"hole-punch\")\n \tsCtx := network.WithNoDial(hpCtx, \"hole-punch\")\n+\n \tstr, err := hs.host.NewStream(sCtx, rp, Protocol)\n \tif err != nil {\n \t\treturn nil, 0, fmt.Errorf(\"failed to open hole-punching stream: %w\", err)\n \t}\n \tdefer str.Close()\n-\tstr.SetDeadline(time.Now().Add(StreamTimeout))\n+\n+\tif err := str.Scope().SetService(ServiceName); err != nil {\n+\t\tlog.Debugf(\"error attaching stream to holepunch service: %s\", err)\n+\t\tstr.Reset()\n+\t\treturn nil, 0, err\n+\t}\n+\n+\tif err := str.Scope().ReserveMemory(maxMsgSize, network.ReservationPriorityAlways); err != nil {\n+\t\tlog.Debugf(\"error reserving memory for stream: %s, err\")\n+\t\tstr.Reset()\n+\t\treturn nil, 0, err\n+\t}\n+\tdefer str.Scope().ReleaseMemory(maxMsgSize)\n \n \tw := protoio.NewDelimitedWriter(str)\n+\trd := protoio.NewDelimitedReader(str, maxMsgSize)\n \n+\tstr.SetDeadline(time.Now().Add(StreamTimeout))\n \t// send a CONNECT and start RTT measurement.\n \tmsg := &pb.HolePunch{\n \t\tType:     pb.HolePunch_CONNECT.Enum(),\n@@ -168,7 +185,6 @@ func (hs *Service) initiateHolePunch(rp peer.ID) ([]ma.Multiaddr, time.Duration,\n \t}\n \n \t// wait for a CONNECT message from the remote peer\n-\trd := protoio.NewDelimitedReader(str, maxMsgSize)\n \tmsg.Reset()\n \tif err := rd.ReadMsg(msg); err != nil {\n \t\tstr.Reset()\n@@ -318,12 +334,20 @@ func (hs *Service) incomingHolePunch(s network.Stream) (rtt time.Duration, addrs\n \t\treturn 0, nil, errors.New(\"rejecting hole punch request, as we don't have any public addresses\")\n \t}\n \n-\ts.SetDeadline(time.Now().Add(StreamTimeout))\n+\tif err := s.Scope().ReserveMemory(maxMsgSize, network.ReservationPriorityAlways); err != nil {\n+\t\tlog.Debugf(\"error reserving memory for stream: %s, err\")\n+\t\treturn 0, nil, err\n+\t}\n+\tdefer s.Scope().ReleaseMemory(maxMsgSize)\n+\n \twr := protoio.NewDelimitedWriter(s)\n \trd := protoio.NewDelimitedReader(s, maxMsgSize)\n \n \t// Read Connect message\n \tmsg := new(pb.HolePunch)\n+\n+\ts.SetDeadline(time.Now().Add(StreamTimeout))\n+\n \tif err := rd.ReadMsg(msg); err != nil {\n \t\treturn 0, nil, fmt.Errorf(\"failed to read message from initator: %w\", err)\n \t}\n@@ -366,6 +390,13 @@ func (hs *Service) handleNewStream(s network.Stream) {\n \t\ts.Reset()\n \t\treturn\n \t}\n+\n+\tif err := s.Scope().SetService(ServiceName); err != nil {\n+\t\tlog.Debugf(\"error attaching stream to holepunch service: %s\", err)\n+\t\ts.Reset()\n+\t\treturn\n+\t}\n+\n \trp := s.Conn().RemotePeer()\n \trtt, addrs, err := hs.incomingHolePunch(s)\n \tif err != nil {"
        },
        {
          "filename": "p2p/protocol/identify/id.go",
          "status": "modified",
          "additions": 26,
          "deletions": 1,
          "patch": "@@ -41,6 +41,8 @@ const ID = \"/ipfs/id/1.0.0\"\n // 0.4.17 which asserted an exact version match.\n const LibP2PVersion = \"ipfs/0.1.0\"\n \n+const ServiceName = \"libp2p.identify\"\n+\n // StreamReadTimeout is the read timeout on all incoming Identify family streams.\n var StreamReadTimeout = 60 * time.Second\n \n@@ -357,7 +359,11 @@ func (ids *idService) identifyConn(c network.Conn) error {\n \t\tids.removeConn(c)\n \t\treturn err\n \t}\n-\ts.SetProtocol(ID)\n+\n+\tif err := s.SetProtocol(ID); err != nil {\n+\t\tlog.Warnf(\"error setting identify protocol for stream: %s\", err)\n+\t\ts.Reset()\n+\t}\n \n \t// ok give the response to our handler.\n \tif err := msmux.SelectProtoOrFail(ID, s); err != nil {\n@@ -370,6 +376,12 @@ func (ids *idService) identifyConn(c network.Conn) error {\n }\n \n func (ids *idService) sendIdentifyResp(s network.Stream) {\n+\tif err := s.Scope().SetService(ServiceName); err != nil {\n+\t\tlog.Warnf(\"error attaching stream to identify service: %s\", err)\n+\t\ts.Reset()\n+\t\treturn\n+\t}\n+\n \tdefer s.Close()\n \n \tc := s.Conn()\n@@ -402,6 +414,19 @@ func (ids *idService) sendIdentifyResp(s network.Stream) {\n }\n \n func (ids *idService) handleIdentifyResponse(s network.Stream) error {\n+\tif err := s.Scope().SetService(ServiceName); err != nil {\n+\t\tlog.Warnf(\"error attaching stream to identify service: %s\", err)\n+\t\ts.Reset()\n+\t\treturn err\n+\t}\n+\n+\tif err := s.Scope().ReserveMemory(signedIDSize, network.ReservationPriorityAlways); err != nil {\n+\t\tlog.Warnf(\"error reserving memory for identify stream: %s\", err)\n+\t\ts.Reset()\n+\t\treturn err\n+\t}\n+\tdefer s.Scope().ReleaseMemory(signedIDSize)\n+\n \t_ = s.SetReadDeadline(time.Now().Add(StreamReadTimeout))\n \n \tc := s.Conn()"
        },
        {
          "filename": "p2p/protocol/identify/id_delta.go",
          "status": "modified",
          "additions": 16,
          "deletions": 1,
          "patch": "@@ -15,13 +15,28 @@ import (\n \n const IDDelta = \"/p2p/id/delta/1.0.0\"\n \n+const deltaMsgSize = 2048\n+\n // deltaHandler handles incoming delta updates from peers.\n func (ids *idService) deltaHandler(s network.Stream) {\n+\tif err := s.Scope().SetService(ServiceName); err != nil {\n+\t\tlog.Warnf(\"error attaching stream to identify service: %s\", err)\n+\t\ts.Reset()\n+\t\treturn\n+\t}\n+\n+\tif err := s.Scope().ReserveMemory(deltaMsgSize, network.ReservationPriorityAlways); err != nil {\n+\t\tlog.Warnf(\"error reserving memory for identify stream: %s\", err)\n+\t\ts.Reset()\n+\t\treturn\n+\t}\n+\tdefer s.Scope().ReleaseMemory(deltaMsgSize)\n+\n \t_ = s.SetReadDeadline(time.Now().Add(StreamReadTimeout))\n \n \tc := s.Conn()\n \n-\tr := protoio.NewDelimitedReader(s, 2048)\n+\tr := protoio.NewDelimitedReader(s, deltaMsgSize)\n \tmes := pb.Identify{}\n \tif err := r.ReadMsg(&mes); err != nil {\n \t\tlog.Warn(\"error reading identify message: \", err)"
        },
        {
          "filename": "p2p/protocol/ping/ping.go",
          "status": "modified",
          "additions": 49,
          "deletions": 10,
          "patch": "@@ -9,18 +9,22 @@ import (\n \n \tu \"github.com/ipfs/go-ipfs-util\"\n \tlogging \"github.com/ipfs/go-log/v2\"\n+\tpool \"github.com/libp2p/go-buffer-pool\"\n \t\"github.com/libp2p/go-libp2p-core/host\"\n \t\"github.com/libp2p/go-libp2p-core/network\"\n \t\"github.com/libp2p/go-libp2p-core/peer\"\n )\n \n var log = logging.Logger(\"ping\")\n \n-const PingSize = 32\n+const (\n+\tPingSize    = 32\n+\tpingTimeout = time.Second * 60\n \n-const ID = \"/ipfs/ping/1.0.0\"\n+\tID = \"/ipfs/ping/1.0.0\"\n \n-const pingTimeout = time.Second * 60\n+\tServiceName = \"libp2p.ping\"\n+)\n \n type PingService struct {\n \tHost host.Host\n@@ -33,7 +37,21 @@ func NewPingService(h host.Host) *PingService {\n }\n \n func (p *PingService) PingHandler(s network.Stream) {\n-\tbuf := make([]byte, PingSize)\n+\tif err := s.Scope().SetService(ServiceName); err != nil {\n+\t\tlog.Debugf(\"error attaching stream to ping service: %s\", err)\n+\t\ts.Reset()\n+\t\treturn\n+\t}\n+\n+\tif err := s.Scope().ReserveMemory(PingSize, network.ReservationPriorityAlways); err != nil {\n+\t\tlog.Debugf(\"error reserving memory for ping stream: %s\", err)\n+\t\ts.Reset()\n+\t\treturn\n+\t}\n+\tdefer s.Scope().ReleaseMemory(PingSize)\n+\n+\tbuf := pool.Get(PingSize)\n+\tdefer pool.Put(buf)\n \n \terrCh := make(chan error, 1)\n \tdefer close(errCh)\n@@ -81,15 +99,25 @@ func (ps *PingService) Ping(ctx context.Context, p peer.ID) <-chan Result {\n \treturn Ping(ctx, ps.Host, p)\n }\n \n+func pingError(err error) chan Result {\n+\tch := make(chan Result, 1)\n+\tch <- Result{Error: err}\n+\tclose(ch)\n+\treturn ch\n+}\n+\n // Ping pings the remote peer until the context is canceled, returning a stream\n // of RTTs or errors.\n func Ping(ctx context.Context, h host.Host, p peer.ID) <-chan Result {\n \ts, err := h.NewStream(network.WithUseTransient(ctx, \"ping\"), p, ID)\n \tif err != nil {\n-\t\tch := make(chan Result, 1)\n-\t\tch <- Result{Error: err}\n-\t\tclose(ch)\n-\t\treturn ch\n+\t\treturn pingError(err)\n+\t}\n+\n+\tif err := s.Scope().SetService(ServiceName); err != nil {\n+\t\tlog.Debugf(\"error attaching stream to ping service: %s\", err)\n+\t\ts.Reset()\n+\t\treturn pingError(err)\n \t}\n \n \tctx, cancel := context.WithCancel(ctx)\n@@ -130,7 +158,16 @@ func Ping(ctx context.Context, h host.Host, p peer.ID) <-chan Result {\n }\n \n func ping(s network.Stream) (time.Duration, error) {\n-\tbuf := make([]byte, PingSize)\n+\tif err := s.Scope().ReserveMemory(2*PingSize, network.ReservationPriorityAlways); err != nil {\n+\t\tlog.Debugf(\"error reserving memory for ping stream: %s\", err)\n+\t\ts.Reset()\n+\t\treturn 0, err\n+\t}\n+\tdefer s.Scope().ReleaseMemory(2 * PingSize)\n+\n+\tbuf := pool.Get(PingSize)\n+\tdefer pool.Put(buf)\n+\n \tu.NewTimeSeededRand().Read(buf)\n \n \tbefore := time.Now()\n@@ -139,7 +176,9 @@ func ping(s network.Stream) (time.Duration, error) {\n \t\treturn 0, err\n \t}\n \n-\trbuf := make([]byte, PingSize)\n+\trbuf := pool.Get(PingSize)\n+\tdefer pool.Put(rbuf)\n+\n \t_, err = io.ReadFull(s, rbuf)\n \tif err != nil {\n \t\treturn 0, err"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 8,
        "dependency_files": 0,
        "test_files": 5,
        "unique_directories": 12,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "4651a0d2247ab8964384919083ae42b995fed42a",
            "date": "2025-01-10T18:25:48Z",
            "author_login": "marten-seemann"
          },
          {
            "sha": "a2993c18f7e9a005e23feff49d7f3296188be631",
            "date": "2025-01-10T18:25:24Z",
            "author_login": "sukunrt"
          },
          {
            "sha": "ca611f1c4e1e026d15f37f420ecb00c212112d37",
            "date": "2025-01-10T18:14:35Z",
            "author_login": "sukunrt"
          },
          {
            "sha": "3143db22c6e6b39bedd021ed04e0cdd74b382572",
            "date": "2025-01-10T15:36:52Z",
            "author_login": "MarcoPolo"
          },
          {
            "sha": "2209ae05976df6a1cc2631c961f57549d109008c",
            "date": "2024-12-26T15:37:37Z",
            "author_login": "sukunrt"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "go-libp2p is the offical libp2p implementation in the Go programming language. Version `0.18.0` and older of go-libp2p are vulnerable to targeted resource exhaustion attacks. These attacks target libp2p\u2019s connection, stream, peer, and memory management. An attacker can cause the allocation of large amounts of memory, ultimately leading to the process getting killed by the host\u2019s operating system. While a connection manager tasked with keeping the number of connections within manageable limits has been part of go-libp2p, this component was designed to handle the regular churn of peers, not a targeted resource exhaustion attack. Users are advised to upgrade their version of go-libp2p to version `0.18.1` or newer. Users unable to upgrade may consult the denial of service (dos) mitigation page for more information on how to incorporate mitigation strategies, monitor your application, and respond to attacks. ",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-12-08T01:15:09.697",
    "last_modified": "2024-11-21T06:48:40.450",
    "fix_date": "2022-01-18T09:25:41Z"
  },
  "references": [
    {
      "url": "https://docs.libp2p.io/reference/dos-mitigation/",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/libp2p/go-libp2p/commit/15d7dfbf54264ead8e6f49ca658d79c90635e2de",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libp2p/go-libp2p/security/advisories/GHSA-j7qp-mfxf-8xjw",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://docs.libp2p.io/reference/dos-mitigation/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/libp2p/go-libp2p/commit/15d7dfbf54264ead8e6f49ca658d79c90635e2de",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libp2p/go-libp2p/security/advisories/GHSA-j7qp-mfxf-8xjw",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:21.210437",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "go-libp2p",
    "owner": "libp2p",
    "created_at": "2015-09-30T23:24:32Z",
    "updated_at": "2025-01-13T20:11:32Z",
    "pushed_at": "2025-01-14T08:40:03Z",
    "size": 58847,
    "stars": 6172,
    "forks": 1096,
    "open_issues": 266,
    "watchers": 6172,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Go": 2678094,
      "Shell": 13226,
      "Standard ML": 70
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T19:02:28.131398"
  }
}