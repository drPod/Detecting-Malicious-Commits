{
  "cve_id": "CVE-2022-23525",
  "github_data": {
    "repository": "helm/helm",
    "fix_commit": "638ebffbc2e445156f3978f02fd83d9af1e56f5b",
    "related_commits": [
      "638ebffbc2e445156f3978f02fd83d9af1e56f5b",
      "638ebffbc2e445156f3978f02fd83d9af1e56f5b"
    ],
    "patch_url": "https://github.com/helm/helm/commit/638ebffbc2e445156f3978f02fd83d9af1e56f5b.patch",
    "fix_commit_details": {
      "sha": "638ebffbc2e445156f3978f02fd83d9af1e56f5b",
      "commit_date": "2022-12-14T13:55:41Z",
      "author": {
        "login": "hickeyma",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-53c4-hhmh-vw5q",
        "length": 65,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 75,
        "additions": 75,
        "deletions": 0
      },
      "files": [
        {
          "filename": "pkg/repo/index.go",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -118,6 +118,10 @@ func LoadIndexFile(path string) (*IndexFile, error) {\n // MustAdd adds a file to the index\n // This can leave the index in an unsorted state\n func (i IndexFile) MustAdd(md *chart.Metadata, filename, baseURL, digest string) error {\n+\tif i.Entries == nil {\n+\t\treturn errors.New(\"entries not initialized\")\n+\t}\n+\n \tif md.APIVersion == \"\" {\n \t\tmd.APIVersion = chart.APIVersionV1\n \t}\n@@ -339,6 +343,10 @@ func loadIndex(data []byte, source string) (*IndexFile, error) {\n \n \tfor name, cvs := range i.Entries {\n \t\tfor idx := len(cvs) - 1; idx >= 0; idx-- {\n+\t\t\tif cvs[idx] == nil {\n+\t\t\t\tlog.Printf(\"skipping loading invalid entry for chart %q from %s: empty entry\", name, source)\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tif cvs[idx].APIVersion == \"\" {\n \t\t\t\tcvs[idx].APIVersion = chart.APIVersionV1\n \t\t\t}"
        },
        {
          "filename": "pkg/repo/index_test.go",
          "status": "modified",
          "additions": 33,
          "deletions": 0,
          "patch": "@@ -59,6 +59,15 @@ entries:\n       version: 1.0.0\n       home: https://github.com/something\n       digest: \"sha256:1234567890abcdef\"\n+`\n+\tindexWithEmptyEntry = `\n+apiVersion: v1\n+entries:\n+  grafana:\n+  - apiVersion: v2\n+    name: grafana\n+  foo:\n+  -\n `\n )\n \n@@ -152,6 +161,12 @@ func TestLoadIndex_Duplicates(t *testing.T) {\n \t}\n }\n \n+func TestLoadIndex_EmptyEntry(t *testing.T) {\n+\tif _, err := loadIndex([]byte(indexWithEmptyEntry), \"indexWithEmptyEntry\"); err != nil {\n+\t\tt.Errorf(\"unexpected error: %s\", err)\n+\t}\n+}\n+\n func TestLoadIndex_Empty(t *testing.T) {\n \tif _, err := loadIndex([]byte(\"\"), \"indexWithEmpty\"); err == nil {\n \t\tt.Errorf(\"Expected an error when index.yaml is empty.\")\n@@ -526,3 +541,21 @@ func TestIndexWrite(t *testing.T) {\n \t\tt.Fatal(\"Index files doesn't contain expected content\")\n \t}\n }\n+\n+func TestAddFileIndexEntriesNil(t *testing.T) {\n+\ti := NewIndexFile()\n+\ti.APIVersion = chart.APIVersionV1\n+\ti.Entries = nil\n+\tfor _, x := range []struct {\n+\t\tmd       *chart.Metadata\n+\t\tfilename string\n+\t\tbaseURL  string\n+\t\tdigest   string\n+\t}{\n+\t\t{&chart.Metadata{APIVersion: \"v2\", Name: \" \", Version: \"8033-5.apinie+s.r\"}, \"setter-0.1.9+beta.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\"},\n+\t} {\n+\t\tif err := i.MustAdd(x.md, x.filename, x.baseURL, x.digest); err == nil {\n+\t\t\tt.Errorf(\"expected err to be non-nil when entries not initialized\")\n+\t\t}\n+\t}\n+}"
        },
        {
          "filename": "pkg/repo/repo.go",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -100,6 +100,9 @@ func (r *File) Remove(name string) bool {\n \tcp := []*Entry{}\n \tfound := false\n \tfor _, rf := range r.Repositories {\n+\t\tif rf == nil {\n+\t\t\tcontinue\n+\t\t}\n \t\tif rf.Name == name {\n \t\t\tfound = true\n \t\t\tcontinue"
        },
        {
          "filename": "pkg/repo/repo_test.go",
          "status": "modified",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -225,3 +225,34 @@ func TestRepoNotExists(t *testing.T) {\n \t\tt.Errorf(\"expected prompt `couldn't load repositories file`\")\n \t}\n }\n+\n+func TestRemoveRepositoryInvalidEntries(t *testing.T) {\n+\tsampleRepository := NewFile()\n+\tsampleRepository.Add(\n+\t\t&Entry{\n+\t\t\tName: \"stable\",\n+\t\t\tURL:  \"https://example.com/stable/charts\",\n+\t\t},\n+\t\t&Entry{\n+\t\t\tName: \"incubator\",\n+\t\t\tURL:  \"https://example.com/incubator\",\n+\t\t},\n+\t\t&Entry{},\n+\t\tnil,\n+\t\t&Entry{\n+\t\t\tName: \"test\",\n+\t\t\tURL:  \"https://example.com/test\",\n+\t\t},\n+\t)\n+\n+\tremoveRepository := \"stable\"\n+\tfound := sampleRepository.Remove(removeRepository)\n+\tif !found {\n+\t\tt.Errorf(\"expected repository %s not found\", removeRepository)\n+\t}\n+\n+\tfound = sampleRepository.Has(removeRepository)\n+\tif found {\n+\t\tt.Errorf(\"repository %s not deleted\", removeRepository)\n+\t}\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "fb54996b001697513cdb1ffa5915c0ba90149fff",
            "date": "2025-01-14T02:16:44Z",
            "author_login": "sabre1041"
          },
          {
            "sha": "7dac0157a78e5ba6ad607cf1b1fc598b98ef5dfd",
            "date": "2025-01-13T18:01:22Z",
            "author_login": "robertsirc"
          },
          {
            "sha": "6d42a2973d108a28bff46e38f2afe6a9e98918af",
            "date": "2025-01-11T18:41:47Z",
            "author_login": "shahbazaamir"
          },
          {
            "sha": "bd897c96fbaf7546d6a5c57be009f16f9d38d6de",
            "date": "2025-01-09T00:46:19Z",
            "author_login": "gjenkins8"
          },
          {
            "sha": "ad9768402951f48f61e1ecbea0c1894456d63a2a",
            "date": "2025-01-07T17:09:02Z",
            "author_login": "mattfarina"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-476",
    "description": "Helm is a tool for managing Charts, pre-configured Kubernetes resources. Versions prior to 3.10.3 are subject to NULL Pointer Dereference in the _repo_package. The _repo_ package contains a handler that processes the index file of a repository. For example, the Helm client adds references to chart repositories where charts are managed. The _repo_ package parses the index file of the repository and loads it into structures Go can work with. Some index files can cause array data structures to be created causing a memory violation. Applications that use the _repo_ package in the Helm SDK to parse an index file can suffer a Denial of Service when that input causes a panic that cannot be recovered from. The Helm Client will panic with an index file that causes a memory violation panic. Helm is not a long running service so the panic will not affect future uses of the Helm client. This issue has been patched in 3.10.3. SDK users can validate index files that are correctly formatted before passing them to the _repo_ functions.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-12-15T19:15:17.027",
    "last_modified": "2024-11-21T06:48:44.937",
    "fix_date": "2022-12-14T13:55:41Z"
  },
  "references": [
    {
      "url": "https://github.com/helm/helm/commit/638ebffbc2e445156f3978f02fd83d9af1e56f5b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/helm/helm/security/advisories/GHSA-53c4-hhmh-vw5q",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/helm/helm/commit/638ebffbc2e445156f3978f02fd83d9af1e56f5b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/helm/helm/security/advisories/GHSA-53c4-hhmh-vw5q",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:23.165671",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "helm",
    "owner": "helm",
    "created_at": "2015-10-06T01:07:32Z",
    "updated_at": "2025-01-14T12:24:26Z",
    "pushed_at": "2025-01-14T02:16:52Z",
    "size": 22466,
    "stars": 27310,
    "forks": 7159,
    "open_issues": 777,
    "watchers": 27310,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "feat-v3/event-emitter-lua",
      "kube-update-test",
      "main",
      "release-2.0",
      "release-2.1",
      "release-2.2",
      "release-2.3",
      "release-2.4",
      "release-2.5",
      "release-2.6",
      "release-2.7",
      "release-2.8",
      "release-2.9"
    ],
    "languages": {
      "Go": 1934648,
      "Shell": 31103,
      "Makefile": 8742
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:57:31.645568"
  }
}