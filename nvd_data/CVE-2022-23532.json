{
  "cve_id": "CVE-2022-23532",
  "github_data": {
    "repository": "neo4j-contrib/neo4j-apoc-procedures",
    "fix_commit": "01e63ed2d187cd2a8aa1d78bf831ef0fdd69b522",
    "related_commits": [
      "01e63ed2d187cd2a8aa1d78bf831ef0fdd69b522",
      "01e63ed2d187cd2a8aa1d78bf831ef0fdd69b522"
    ],
    "patch_url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/01e63ed2d187cd2a8aa1d78bf831ef0fdd69b522.patch",
    "fix_commit_details": {
      "sha": "01e63ed2d187cd2a8aa1d78bf831ef0fdd69b522",
      "commit_date": "2022-12-16T11:44:40Z",
      "author": {
        "login": "gem-neo4j",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "4.4 export security fix (#3370)",
        "length": 115,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 359,
        "additions": 312,
        "deletions": 47
      },
      "files": [
        {
          "filename": "core/src/main/java/apoc/export/csv/ExportCSV.java",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -116,8 +116,8 @@ private Stream<ProgressInfo> exportCsv(@Name(\"file\") String fileName, String sou\n \n     private void dump(Object data, ExportConfig c, ProgressReporter reporter, ExportFileManager printWriter, CsvFormat exporter) {\n         if (data instanceof SubGraph)\n-            exporter.dump((SubGraph)data,printWriter,reporter,c);\n+            exporter.dump((SubGraph) data, printWriter, reporter, c);\n         if (data instanceof Result)\n-            exporter.dump((Result)data,printWriter,reporter,c);\n+            exporter.dump((Result) data, printWriter, reporter, c);\n     }\n }"
        },
        {
          "filename": "core/src/main/java/apoc/util/FileUtils.java",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -227,7 +227,7 @@ private static Path getPath(String url) {\n         Path urlPath;\n         URL toURL = null;\n         try {\n-            final URI uri = URI.create(url.trim());\n+            final URI uri = URI.create(url.trim()).normalize();\n             toURL = uri.toURL();\n             urlPath = Paths.get(uri);\n         } catch (Exception e) {\n@@ -242,10 +242,10 @@ private static Path getPath(String url) {\n \n     private static boolean pathStartsWithOther(Path resolvedPath, Path basePath) throws IOException {\n         try {\n-            return resolvedPath.toRealPath().startsWith(basePath.toRealPath());\n+            return resolvedPath.toFile().getCanonicalFile().toPath().startsWith(basePath.toRealPath());\n         } catch (Exception e) {\n-            if (e instanceof NoSuchFileException) { // If we're about to creating a file this exception has been thrown\n-                return resolvedPath.normalize().startsWith(basePath);\n+            if (e instanceof NoSuchFileException) { // If we're about to create a file this exception has been thrown\n+                return resolvedPath.toFile().getCanonicalFile().toPath().startsWith(basePath);\n             }\n             return false;\n         }"
        },
        {
          "filename": "core/src/test/java/apoc/export/ExportCoreSecurityTest.java",
          "status": "modified",
          "additions": 303,
          "deletions": 39,
          "patch": "@@ -8,16 +8,17 @@\n import apoc.export.json.ExportJson;\n import apoc.util.FileUtils;\n import apoc.util.TestUtil;\n+import junit.framework.TestCase;\n import org.apache.commons.lang3.exception.ExceptionUtils;\n-import org.junit.After;\n-import org.junit.Before;\n+import org.junit.Assert;\n import org.junit.BeforeClass;\n import org.junit.ClassRule;\n import org.junit.Test;\n import org.junit.experimental.runners.Enclosed;\n import org.junit.runner.RunWith;\n import org.junit.runners.Parameterized;\n import org.neo4j.configuration.GraphDatabaseSettings;\n+import org.neo4j.graphdb.QueryExecutionException;\n import org.neo4j.graphdb.Result;\n import org.neo4j.test.rule.DbmsRule;\n import org.neo4j.test.rule.ImpermanentDbmsRule;\n@@ -38,10 +39,17 @@\n public class ExportCoreSecurityTest {\n \n     private static final File directory = new File(\"target/import\");\n+    private static final File directoryWithSamePrefix = new File(\"target/imported\");\n+    private static final File subDirectory = new File(\"target/import/tests\");\n     private static final List<String> APOC_EXPORT_PROCEDURE_NAME = Arrays.asList(\"csv\", \"json\", \"graphml\", \"cypher\");\n \n     static {\n+        //noinspection ResultOfMethodCallIgnored\n         directory.mkdirs();\n+        //noinspection ResultOfMethodCallIgnored\n+        subDirectory.mkdirs();\n+        //noinspection ResultOfMethodCallIgnored\n+        directoryWithSamePrefix.mkdirs();\n     }\n \n     @ClassRule\n@@ -52,16 +60,11 @@ public class ExportCoreSecurityTest {\n     @BeforeClass\n     public static void setUp() throws Exception {\n         TestUtil.registerProcedure(db, ExportCSV.class, ExportJson.class, ExportGraphML.class, ExportCypher.class);\n+        setFileExport(false);\n     }\n \n-    @Before\n-    public void before() {\n-        ApocConfig.apocConfig().setProperty(ApocSettings.apoc_export_file_enabled, false);\n-    }\n-\n-    @After\n-    public void after() {\n-        ApocConfig.apocConfig().setProperty(ApocSettings.apoc_export_file_enabled, false);\n+    private static void setFileExport(boolean allowed) {\n+        ApocConfig.apocConfig().setProperty(ApocConfig.APOC_EXPORT_FILE_ENABLED, allowed);\n     }\n \n     private static Collection<String[]> data(Map<String, List<String>> apocProcedureArguments) {\n@@ -114,16 +117,12 @@ public static Collection<String[]> data() {\n \n         @Test\n         public void testIllegalFSAccessExport() {\n-            final String message = apocProcedure + \" should throw an exception\";\n-            try {\n-                db.executeTransactionally(\"CALL \" + apocProcedure, Map.of(),\n-                        Result::resultAsString);\n-                fail(message);\n-            } catch (Exception e) {\n-                assertError(e, ApocConfig.EXPORT_TO_FILE_ERROR, RuntimeException.class, apocProcedure);\n-            }\n-        }\n+            QueryExecutionException e = Assert.assertThrows(QueryExecutionException.class,\n+                    () -> TestUtil.testCall(db, \"CALL \" + apocProcedure, (r) -> {})\n+            );\n \n+            assertError(e, ApocConfig.EXPORT_TO_FILE_ERROR, RuntimeException.class, apocProcedure);\n+        }\n     }\n \n     @RunWith(Parameterized.class)\n@@ -162,45 +161,310 @@ public static Collection<String[]> data() {\n         public void testIllegalExternalFSAccessExport() {\n             final String message = apocProcedure + \" should throw an exception\";\n             try {\n-                ApocConfig.apocConfig().setProperty(ApocSettings.apoc_export_file_enabled, true);\n+                setFileExport(true);\n                 db.executeTransactionally(\"CALL \" + apocProcedure, Map.of(),\n                         Result::resultAsString);\n                 fail(message);\n             } catch (Exception e) {\n                 assertError(e, FileUtils.ACCESS_OUTSIDE_DIR_ERROR, IOException.class, apocProcedure);\n             } finally {\n-                ApocConfig.apocConfig().setProperty(ApocSettings.apoc_export_file_enabled, false);\n+                setFileExport(false);\n             }\n         }\n     }\n \n+    @RunWith(Parameterized.class)\n+    public static class TestPathTraversalAccess {\n+        private final String apocProcedure;\n+\n+        public TestPathTraversalAccess(String exportMethod, String exportMethodType, String exportMethodArguments) {\n+            this.apocProcedure = \"apoc.export.\" + exportMethod + \".\" + exportMethodType + \"(\" + exportMethodArguments + \")\";\n+        }\n+\n+        private static final String case1 = \"'file:///%2e%2e%2f%2f%2e%2e%2f%2f%2e%2e%2f%2f%2e%2e%2f%2fapoc/test.txt'\";\n+        private static final String case2 = \"'file:///%2e%2e%2f%2ftest.txt'\";\n+        private static final String case3 = \"'../test.txt'\";\n+        private static final String case4 = \"'tests/../../test.txt'\";\n+        private static final String case5 = \"'tests/..//..//test.txt'\";\n+\n+        private static final List<String> cases = Arrays.asList(case1, case2, case3, case4, case5);\n+\n+        private static final Map<String, List<String>> METHOD_ARGUMENTS = Map.of(\n+                \"query\",  cases.stream().map(\n+                        filePath -> \"\\\"RETURN 1\\\", \" + filePath + \", {}\"\n+                ).collect(Collectors.toList()),\n+                \"all\", cases.stream().map(\n+                        filePath -> filePath + \", {}\"\n+                ).collect(Collectors.toList()),\n+                \"data\", cases.stream().map(\n+                        filePath -> \"[], [], \" + filePath + \", {}\"\n+                ).collect(Collectors.toList()),\n+                \"graph\", cases.stream().map(\n+                        filePath -> \"{nodes: [], relationships: []}, \" + filePath + \", {}\"\n+                ).collect(Collectors.toList())\n+        );\n+\n+        @Parameterized.Parameters\n+        public static Collection<String[]> data() {\n+            return ExportCoreSecurityTest.data(METHOD_ARGUMENTS);\n+        }\n+\n+        @Test\n+        public void testPathTraversal() {\n+            setFileExport(true);\n+\n+            QueryExecutionException e = Assert.assertThrows(QueryExecutionException.class,\n+                    () -> TestUtil.testCall(db, \"CALL \" + apocProcedure, (r) -> {})\n+            );\n+\n+            assertError(e, FileUtils.ACCESS_OUTSIDE_DIR_ERROR, IOException.class, apocProcedure);\n+            setFileExport(false);\n+        }\n+    }\n+\n+    /**\n+     * All of these will resolve to a local path after normalization which will point to\n+     * a non-existing directory in our import folder: /apoc. Causing them to error that is\n+     * not found. They all attempt to exit the import folder back to the apoc folder:\n+     * Directory Layout: .../apoc/core/target/import\n+     */\n+    @RunWith(Parameterized.class)\n+    public static class TestPathTraversalIsNormalised {\n+        private final String apocProcedure;\n+\n+        public TestPathTraversalIsNormalised(String exportMethod, String exportMethodType, String exportMethodArguments) {\n+            this.apocProcedure = \"apoc.export.\" + exportMethod + \".\" + exportMethodType + \"(\" + exportMethodArguments + \")\";\n+        }\n+\n+        private static final String case1 = \"'file://%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f/apoc/test.txt'\";\n+        private static final String case2 = \"'file://../../../../apoc/test.txt'\";\n+        private static final String case3 = \"'file:///..//..//..//..//apoc//core//..//test.txt'\";\n+        private static final String case4 = \"'file:///..//..//..//..//apoc/test.txt'\";\n+        private static final String case5 = \"'file://\" + directory.getAbsolutePath() + \"//..//..//..//..//apoc/test.txt'\";\n+        private static final String case6 = \"'file:///%252e%252e%252f%252e%252e%252f%252e%252e%252f%252e%252e%252f/apoc/test.txt'\";\n+\n+        private static final List<String> cases = Arrays.asList(case1, case2, case3, case4, case5, case6);\n+\n+        private static final Map<String, List<String>> METHOD_ARGUMENTS = Map.of(\n+                \"query\", cases.stream().map(\n+                        filePath -> \"\\\"RETURN 1\\\", \" + filePath + \", {}\"\n+                ).collect(Collectors.toList()),\n+                \"all\", cases.stream().map(\n+                        filePath -> filePath + \", {}\"\n+                ).collect(Collectors.toList()),\n+                \"data\", cases.stream().map(\n+                        filePath -> \"[], [], \" + filePath + \", {}\"\n+                ).collect(Collectors.toList()),\n+                \"graph\", cases.stream().map(\n+                        filePath -> \"{nodes: [], relationships: []}, \" + filePath + \", {}\"\n+                ).collect(Collectors.toList())\n+        );\n+\n+        @Parameterized.Parameters\n+        public static Collection<String[]> data() {\n+            return ExportCoreSecurityTest.data(METHOD_ARGUMENTS);\n+        }\n+\n+        @Test\n+        public void testPathTraversal() {\n+            setFileExport(true);\n+\n+            QueryExecutionException e = Assert.assertThrows(QueryExecutionException.class,\n+                    () -> TestUtil.testCall(db, \"CALL \" + apocProcedure, (r) -> {})\n+            );\n+\n+            TestCase.assertTrue(e.getMessage().contains(\"apoc/test.txt (No such file or directory)\"));\n+            setFileExport(false);\n+        }\n+    }\n+\n+    /**\n+     * These tests normalize the path to be within the import directory and make the file there.\n+     * Some attempt to exit the directory.\n+     * They result in a file name test.txt being created (and deleted after).\n+     */\n+    @RunWith(Parameterized.class)\n+    public static class TestPathTraversalIsNormalisedWithinDirectory {\n+        private final String apocProcedure;\n+\n+        public TestPathTraversalIsNormalisedWithinDirectory(String exportMethod, String exportMethodType, String exportMethodArguments) {\n+            this.apocProcedure = \"apoc.export.\" + exportMethod + \".\" + exportMethodType + \"(\" + exportMethodArguments + \")\";\n+        }\n+\n+        private static final String case1 = \"'file:///..//..//..//..//apoc//..//..//..//..//test.txt'\";\n+        private static final String case2 = \"'file:///..//..//..//..//apoc//..//test.txt'\";\n+        private static final String case3 = \"'file:///../import/../import//..//test.txt'\";\n+        private static final String case4 = \"'file://test.txt'\";\n+        private static final String case5 = \"'file://tests/../test.txt'\";\n+        private static final String case6 = \"'file:///tests//..//test.txt'\";\n+        private static final String case7 = \"'test.txt'\";\n+        private static final String case8 = \"'file:///..//..//..//..//test.txt'\";\n+\n+        private static final List<String> cases = Arrays.asList(case1, case2, case3, case4, case5, case6, case7, case8);\n+\n+        private static final Map<String, List<String>> METHOD_ARGUMENTS = Map.of(\n+                \"query\", cases.stream().map(\n+                        filePath -> \"\\\"RETURN 1\\\", \" + filePath + \", {}\"\n+                ).collect(Collectors.toList()),\n+                \"all\", cases.stream().map(\n+                        filePath -> filePath + \", {}\"\n+                ).collect(Collectors.toList()),\n+                \"data\", cases.stream().map(\n+                        filePath -> \"[], [], \" + filePath + \", {}\"\n+                ).collect(Collectors.toList()),\n+                \"graph\", cases.stream().map(\n+                        filePath -> \"{nodes: [], relationships: []}, \" + filePath + \", {}\"\n+                ).collect(Collectors.toList())\n+        );\n+\n+        @Parameterized.Parameters\n+        public static Collection<String[]> data() {\n+            return ExportCoreSecurityTest.data(METHOD_ARGUMENTS);\n+        }\n+\n+        @Test\n+        public void testPathTraversal() {\n+            setFileExport(true);\n+\n+            TestUtil.testCall(db, \"CALL \" + apocProcedure,\n+                    (r) -> assertTrue(((String) r.get(\"file\")).contains(\"test.txt\"))\n+            );\n+\n+            File f = new File(directory.getAbsolutePath() + \"/test.txt\");\n+            TestCase.assertTrue(f.exists());\n+            TestCase.assertTrue(f.delete());\n+        }\n+    }\n+\n+    /*\n+     * These test cases attempt to access a directory with the same prefix as the import directory. This is design to\n+     * test \"directoryName.startsWith\" logic which is a common path traversal bug.\n+     *\n+     * All these tests should fail because they access a directory which isn't the configured directory\n+     */\n+    @RunWith(Parameterized.class)\n+    public static class TestPathTraversalIsWithSimilarDirectoryName {\n+        private final String apocProcedure;\n+\n+        public TestPathTraversalIsWithSimilarDirectoryName(String exportMethod, String exportMethodType, String exportMethodArguments) {\n+            this.apocProcedure = \"apoc.export.\" + exportMethod + \".\" + exportMethodType + \"(\" + exportMethodArguments + \")\";\n+        }\n+\n+        private static final String case1 = \"'../imported/test.txt'\";\n+        private static final String case2 = \"'tests/../../imported/test.txt'\";\n+\n+        private static final List<String> cases = Arrays.asList(case1, case2);\n+\n+        private static final Map<String, List<String>> METHOD_ARGUMENTS = Map.of(\n+                \"query\", cases.stream().map(\n+                        filePath -> \"\\\"RETURN 1\\\", \" + filePath + \", {}\"\n+                ).collect(Collectors.toList()),\n+                \"all\", cases.stream().map(\n+                        filePath -> filePath + \", {}\"\n+                ).collect(Collectors.toList()),\n+                \"data\", cases.stream().map(\n+                        filePath -> \"[], [], \" + filePath + \", {}\"\n+                ).collect(Collectors.toList()),\n+                \"graph\", cases.stream().map(\n+                        filePath -> \"{nodes: [], relationships: []}, \" + filePath + \", {}\"\n+                ).collect(Collectors.toList())\n+        );\n+\n+        @Parameterized.Parameters\n+        public static Collection<String[]> data() {\n+            return ExportCoreSecurityTest.data(METHOD_ARGUMENTS);\n+        }\n+\n+        @Test\n+        public void testPathTraversal() {\n+            setFileExport(true);\n+\n+            QueryExecutionException e = Assert.assertThrows(QueryExecutionException.class,\n+                    () -> TestUtil.testCall(db, \"CALL \" + apocProcedure, (r) -> {})\n+            );\n+\n+            assertError(e, FileUtils.ACCESS_OUTSIDE_DIR_ERROR, IOException.class, apocProcedure);\n+\n+            setFileExport(false);\n+        }\n+    }\n+\n+\n+    /**\n+     * These tests normalize the path to be within the import directory and step into a subdirectory\n+     * to make the file there.\n+     * Some attempt to exit the directory.\n+     * They result in a file name test.txt in the directory /tests being created (and deleted after).\n+     */\n+    @RunWith(Parameterized.class)\n+    public static class TestPathTraversAllowedWithinDirectory {\n+        private final String apocProcedure;\n+\n+        public TestPathTraversAllowedWithinDirectory(String exportMethod, String exportMethodType, String exportMethodArguments) {\n+            this.apocProcedure = \"apoc.export.\" + exportMethod + \".\" + exportMethodType + \"(\" + exportMethodArguments + \")\";\n+        }\n+\n+        private static final String case1 = \"'file:///../import/../import//..//tests/test.txt'\";\n+        private static final String case2 = \"'file:///..//..//..//..//apoc//..//tests/test.txt'\";\n+        private static final String case3 = \"'file:///../import/../import//..//tests/../tests/test.txt'\";\n+        private static final String case4 = \"'file:///tests/test.txt'\";\n+        private static final String case5 = \"'tests/test.txt'\";\n+\n+        private static final List<String> cases = Arrays.asList(case1, case2, case3, case4, case5);\n+\n+        private static final Map<String, List<String>> METHOD_ARGUMENTS = Map.of(\n+                \"query\", cases.stream().map(\n+                        filePath -> \"\\\"RETURN 1\\\", \" + filePath + \", {}\"\n+                ).collect(Collectors.toList()),\n+                \"all\", cases.stream().map(\n+                        filePath -> filePath + \", {}\"\n+                ).collect(Collectors.toList()),\n+                \"data\", cases.stream().map(\n+                        filePath -> \"[], [], \" + filePath + \", {}\"\n+                ).collect(Collectors.toList()),\n+                \"graph\", cases.stream().map(\n+                        filePath -> \"{nodes: [], relationships: []}, \" + filePath + \", {}\"\n+                ).collect(Collectors.toList())\n+        );\n+\n+        @Parameterized.Parameters\n+        public static Collection<String[]> data() {\n+            return ExportCoreSecurityTest.data(METHOD_ARGUMENTS);\n+        }\n+\n+        @Test\n+        public void testPathTraversal() {\n+            setFileExport(true);\n+\n+            TestUtil.testCall(db, \"CALL \" + apocProcedure,\n+                    (r) -> assertTrue(((String) r.get(\"file\")).contains(\"tests/test.txt\"))\n+            );\n+\n+            File f = new File(subDirectory.getAbsolutePath() + \"/test.txt\");\n+            TestCase.assertTrue(f.exists());\n+            TestCase.assertTrue(f.delete());\n+        }\n+    }\n+\n     public static class TestCypherSchema {\n         private final String apocProcedure = \"apoc.export.cypher.schema(%s)\";\n-        private final String message = apocProcedure + \" should throw an exception\";\n \n         @Test\n         public void testIllegalFSAccessExportCypherSchema() {\n-            try {\n-                db.executeTransactionally(String.format(\"CALL \" + apocProcedure, \"'./hello', {}\"), Map.of(),\n-                        Result::resultAsString);\n-                fail(message);\n-            } catch (Exception e) {\n-                assertError(e, ApocConfig.EXPORT_TO_FILE_ERROR, RuntimeException.class, apocProcedure);\n-            }\n+            QueryExecutionException e = Assert.assertThrows(QueryExecutionException.class,\n+                    () -> TestUtil.testCall(db, String.format(\"CALL \" + apocProcedure, \"'./hello', {}\"), (r) -> {})\n+            );\n+            assertError(e, ApocConfig.EXPORT_TO_FILE_ERROR, RuntimeException.class, apocProcedure);\n         }\n \n         @Test\n         public void testIllegalExternalFSAccessExportCypherSchema() {\n-            try {\n-                ApocConfig.apocConfig().setProperty(ApocSettings.apoc_export_file_enabled, true);\n-                db.executeTransactionally(String.format(\"CALL \" + apocProcedure, \"'../hello', {}\"), Map.of(),\n-                        Result::resultAsString);\n-                fail(message);\n-            } catch (Exception e) {\n-                assertError(e, FileUtils.ACCESS_OUTSIDE_DIR_ERROR, IOException.class, apocProcedure);\n-            } finally {\n-                ApocConfig.apocConfig().setProperty(ApocSettings.apoc_export_file_enabled, false);\n-            }\n+            setFileExport(true);\n+            QueryExecutionException e = Assert.assertThrows(QueryExecutionException.class,\n+                    () -> TestUtil.testCall(db, String.format(\"CALL \" + apocProcedure, \"'../hello', {}\"), (r) -> {})\n+            );\n+            assertError(e, FileUtils.ACCESS_OUTSIDE_DIR_ERROR, IOException.class, apocProcedure);\n+            setFileExport(false);\n         }\n     }\n "
        },
        {
          "filename": "core/src/test/java/apoc/export/csv/ExportCsvTest.java",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -114,8 +114,9 @@ public class ExportCsvTest {\n             \",,,,,,,,0,1,KNOWS%n\" +\n             \",,,,,,,,3,4,NEXT_DELIVERY%n\");\n \n-    private static File directory = new File(\"target/import\");\n-    static { //noinspection ResultOfMethodCallIgnored\n+    private static final File directory = new File(\"target/import\");\n+    static {\n+        //noinspection ResultOfMethodCallIgnored\n         directory.mkdirs();\n     }\n "
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 7
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "6228faee514c9233ddefd5f93d8b49e79a3c6316",
            "date": "2024-12-20T11:34:48Z",
            "author_login": "vga91"
          },
          {
            "sha": "8d0c17aadc91ae9704054cb784ce0084eb6e9af5",
            "date": "2024-12-19T08:47:27Z",
            "author_login": "vga91"
          },
          {
            "sha": "cd0a12e14ba1e60c4e18c71fd12d6ba79cec4c26",
            "date": "2024-12-19T08:16:01Z",
            "author_login": "gem-neo4j"
          },
          {
            "sha": "d8a44e1e612da6272398129b0bdf123122d42763",
            "date": "2024-12-18T13:07:44Z",
            "author_login": "vga91"
          },
          {
            "sha": "f4e65dde351d9aa5053f50e216968f49552e9132",
            "date": "2024-12-18T10:14:56Z",
            "author_login": "vga91"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:N/I:H/A:L",
    "cwe_id": "CWE-22",
    "description": "APOC (Awesome Procedures on Cypher) is an add-on library for Neo4j that provides hundreds of procedures and functions. A path traversal vulnerability found in the apoc.export.* procedures of apoc plugins in Neo4j Graph database. The issue allows a malicious actor to potentially break out of the expected directory. The vulnerability is such that files could only be created but not overwritten. For the vulnerability to be exploited, an attacker would need access to execute an arbitrary query, either by having access to an authenticated Neo4j client, or a Cypher injection vulnerability in an application. The minimum versions containing patch for this vulnerability are 4.4.0.12 and 4.3.0.12 and 5.3.1. As a workaround, you can control the\u00a0allowlist of the procedures\u00a0that can be used in your system, and/or turn off local file access by setting apoc.export.file.enabled=false.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-01-14T01:15:11.490",
    "last_modified": "2024-11-21T06:48:45.610",
    "fix_date": "2022-12-16T11:44:40Z"
  },
  "references": [
    {
      "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/01e63ed2d187cd2a8aa1d78bf831ef0fdd69b522",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/security/advisories/GHSA-5v8v-gwmw-qw97",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/01e63ed2d187cd2a8aa1d78bf831ef0fdd69b522",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/security/advisories/GHSA-5v8v-gwmw-qw97",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:43.553017",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "neo4j-apoc-procedures",
    "owner": "neo4j-contrib",
    "created_at": "2016-02-25T08:33:37Z",
    "updated_at": "2025-01-14T01:24:49Z",
    "pushed_at": "2025-01-10T14:12:18Z",
    "size": 57609,
    "stars": 1740,
    "forks": 494,
    "open_issues": 122,
    "watchers": 1740,
    "has_security_policy": false,
    "default_branch": "4.4",
    "protected_branches": [],
    "languages": {
      "Java": 5993757,
      "Kotlin": 289604,
      "Cypher": 125027,
      "Roff": 44458,
      "HTML": 42496,
      "ANTLR": 1509,
      "JavaScript": 517
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:37:26.764500"
  }
}