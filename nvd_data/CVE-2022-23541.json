{
  "cve_id": "CVE-2022-23541",
  "github_data": {
    "repository": "auth0/node-jsonwebtoken",
    "fix_commit": "e1fa9dcc12054a8681db4e6373da1b30cf7016e3",
    "related_commits": [
      "e1fa9dcc12054a8681db4e6373da1b30cf7016e3",
      "e1fa9dcc12054a8681db4e6373da1b30cf7016e3"
    ],
    "patch_url": "https://github.com/auth0/node-jsonwebtoken/commit/e1fa9dcc12054a8681db4e6373da1b30cf7016e3.patch",
    "fix_commit_details": {
      "sha": "e1fa9dcc12054a8681db4e6373da1b30cf7016e3",
      "commit_date": "2022-12-21T12:36:01Z",
      "author": {
        "login": "edgarchirivella-okta",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-8cf7-32gw-wr33",
        "length": 3288,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 647,
        "additions": 557,
        "deletions": 90
      },
      "files": [
        {
          "filename": "CHANGELOG.md",
          "status": "modified",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -4,6 +4,24 @@\n All notable changes to this project will be documented in this file starting from version **v4.0.0**.\n This project adheres to [Semantic Versioning](http://semver.org/).\n \n+## 9.0.0 - 2022-12-21\n+\n+  **Breaking changes: See [Migration from v8 to v9](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v8-to-v9)**\n+\n+### Breaking changes\n+\n+- Removed support for Node versions 11 and below.\n+- The verify() function no longer accepts unsigned tokens by default. ([834503079514b72264fd13023a3b8d648afd6a16]https://github.com/auth0/node-jsonwebtoken/commit/834503079514b72264fd13023a3b8d648afd6a16)\n+- RSA key size must be 2048 bits or greater. ([ecdf6cc6073ea13a7e71df5fad043550f08d0fa6]https://github.com/auth0/node-jsonwebtoken/commit/ecdf6cc6073ea13a7e71df5fad043550f08d0fa6)\n+- Key types must be valid for the signing / verification algorithm\n+\n+### Security fixes\n+\n+- security: fixes `Arbitrary File Write via verify function` - CVE-2022-23529\n+- security: fixes `Insecure default algorithm in jwt.verify() could lead to signature validation bypass` - CVE-2022-23540\n+- security: fixes `Insecure implementation of key retrieval function could lead to Forgeable Public/Private Tokens from RSA to HMAC` - CVE-2022-23541\n+- security: fixes `Unrestricted key type could lead to legacy keys usage` - CVE-2022-23539\n+\n ## 8.5.1 - 2019-03-18\n \n ### Bug fix"
        },
        {
          "filename": "README.md",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -17,6 +17,7 @@ $ npm install jsonwebtoken\n \n # Migration notes\n \n+* [From v8 to v9](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v8-to-v9)\n * [From v7 to v8](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v7-to-v8)\n \n # Usage\n@@ -52,6 +53,7 @@ When signing with RSA algorithms the minimum modulus length is 2048 except when\n * `keyid`\n * `mutatePayload`: if true, the sign function will modify the payload object directly. This is useful if you need a raw reference to the payload after claims have been applied to it but before it has been encoded into a token.\n * `allowInsecureKeySizes`: if true allows private keys with a modulus below 2048 to be used for RSA\n+* `allowInvalidAsymmetricKeyTypes`: if true, allows asymmetric keys which do not match the specified algorithm. This option is intended only for backwards compatability and should be avoided.\n \n \n \n@@ -158,7 +160,7 @@ As mentioned in [this comment](https://github.com/auth0/node-jsonwebtoken/issues\n   > Eg: `1000`, `\"2 days\"`, `\"10h\"`, `\"7d\"`. A numeric value is interpreted as a seconds count. If you use a string be sure you provide the time units (days, hours, etc), otherwise milliseconds unit is used by default (`\"120\"` is equal to `\"120ms\"`).\n * `clockTimestamp`: the time in seconds that should be used as the current time for all necessary comparisons.\n * `nonce`: if you want to check `nonce` claim, provide a string value here. It is used on Open ID for the ID Tokens. ([Open ID implementation notes](https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes))\n-\n+* `allowInvalidAsymmetricKeyTypes`: if true, allows asymmetric keys which do not match the specified algorithm. This option is intended only for backwards compatability and should be avoided.\n \n ```js\n // verify a token symmetric - synchronous"
        },
        {
          "filename": "lib/asymmetricKeyDetailsSupported.js",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+const semver = require('semver');\n+\n+module.exports = semver.satisfies(process.version, '>=15.7.0');"
        },
        {
          "filename": "lib/rsaPssKeyDetailsSupported.js",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+const semver = require('semver');\n+\n+module.exports = semver.satisfies(process.version, '>=16.9.0');"
        },
        {
          "filename": "lib/validateAsymmetricKey.js",
          "status": "added",
          "additions": 66,
          "deletions": 0,
          "patch": "@@ -0,0 +1,66 @@\n+const ASYMMETRIC_KEY_DETAILS_SUPPORTED = require('./asymmetricKeyDetailsSupported');\n+const RSA_PSS_KEY_DETAILS_SUPPORTED = require('./rsaPssKeyDetailsSupported');\n+\n+const allowedAlgorithmsForKeys = {\n+  'ec': ['ES256', 'ES384', 'ES512'],\n+  'rsa': ['RS256', 'PS256', 'RS384', 'PS384', 'RS512', 'PS512'],\n+  'rsa-pss': ['PS256', 'PS384', 'PS512']\n+};\n+\n+const allowedCurves = {\n+  ES256: 'prime256v1',\n+  ES384: 'secp384r1',\n+  ES512: 'secp521r1',\n+};\n+\n+module.exports = function(algorithm, key) {\n+  if (!algorithm || !key) return;\n+\n+  const keyType = key.asymmetricKeyType;\n+  if (!keyType) return;\n+\n+  const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];\n+\n+  if (!allowedAlgorithms) {\n+    throw new Error(`Unknown key type \"${keyType}\".`);\n+  }\n+\n+  if (!allowedAlgorithms.includes(algorithm)) {\n+    throw new Error(`\"alg\" parameter for \"${keyType}\" key type must be one of: ${allowedAlgorithms.join(', ')}.`)\n+  }\n+\n+  /*\n+   * Ignore the next block from test coverage because it gets executed\n+   * conditionally depending on the Node version. Not ignoring it would\n+   * prevent us from reaching the target % of coverage for versions of\n+   * Node under 15.7.0.\n+   */\n+  /* istanbul ignore next */\n+  if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {\n+    switch (keyType) {\n+    case 'ec':\n+      const keyCurve = key.asymmetricKeyDetails.namedCurve;\n+      const allowedCurve = allowedCurves[algorithm];\n+\n+      if (keyCurve !== allowedCurve) {\n+        throw new Error(`\"alg\" parameter \"${algorithm}\" requires curve \"${allowedCurve}\".`);\n+      }\n+      break;\n+\n+    case 'rsa-pss':\n+      if (RSA_PSS_KEY_DETAILS_SUPPORTED) {\n+        const length = parseInt(algorithm.slice(-3), 10);\n+        const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;\n+\n+        if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {\n+          throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of \"alg\" ${algorithm}.`);\n+        }\n+\n+        if (saltLength !== undefined && saltLength > length >> 3) {\n+          throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of \"alg\" ${algorithm}.`)\n+        }\n+      }\n+      break;\n+    }\n+  }\n+}"
        },
        {
          "filename": "package.json",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,6 +1,6 @@\n {\n   \"name\": \"jsonwebtoken\",\n-  \"version\": \"8.5.1\",\n+  \"version\": \"9.0.0\",\n   \"description\": \"JSON Web Token implementation (symmetric and asymmetric)\",\n   \"main\": \"index.js\",\n   \"nyc\": {"
        },
        {
          "filename": "sign.js",
          "status": "modified",
          "additions": 11,
          "deletions": 1,
          "patch": "@@ -1,5 +1,6 @@\n const timespan = require('./lib/timespan');\n const PS_SUPPORTED = require('./lib/psSupported');\n+const validateAsymmetricKey = require('./lib/validateAsymmetricKey');\n const jws = require('jws');\n const {includes, isBoolean, isInteger, isNumber, isPlainObject, isString, once} = require('lodash')\n const { KeyObject, createSecretKey, createPrivateKey } = require('crypto')\n@@ -22,7 +23,8 @@ const sign_options_schema = {\n   noTimestamp: { isValid: isBoolean, message: '\"noTimestamp\" must be a boolean' },\n   keyid: { isValid: isString, message: '\"keyid\" must be a string' },\n   mutatePayload: { isValid: isBoolean, message: '\"mutatePayload\" must be a boolean' },\n-  allowInsecureKeySizes: { isValid: isBoolean, message: '\"allowInsecureKeySizes\" must be a boolean'}\n+  allowInsecureKeySizes: { isValid: isBoolean, message: '\"allowInsecureKeySizes\" must be a boolean'},\n+  allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '\"allowInvalidAsymmetricKeyTypes\" must be a boolean'}\n };\n \n const registered_claims_schema = {\n@@ -166,6 +168,14 @@ module.exports = function (payload, secretOrPrivateKey, options, callback) {\n     return failure(error);\n   }\n \n+  if (!options.allowInvalidAsymmetricKeyTypes) {\n+    try {\n+      validateAsymmetricKey(header.alg, secretOrPrivateKey);\n+    } catch (error) {\n+      return failure(error);\n+    }\n+  }\n+\n   const timestamp = payload.iat || Math.floor(Date.now() / 1000);\n \n   if (options.noTimestamp) {"
        },
        {
          "filename": "test/dsa-private.pem",
          "status": "added",
          "additions": 36,
          "deletions": 0,
          "patch": "@@ -0,0 +1,36 @@\n+-----BEGIN DSA PRIVATE KEY-----\n+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\n+-----END DSA PRIVATE KEY-----"
        },
        {
          "filename": "test/dsa-public.pem",
          "status": "added",
          "additions": 36,
          "deletions": 0,
          "patch": "@@ -0,0 +1,36 @@\n+-----BEGIN PUBLIC KEY-----\n+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\n+y0elWU3mxe6Rn6R7WHM8or7sX3tWDq6OntJlKg==\n+-----END PUBLIC KEY-----"
        },
        {
          "filename": "test/jwt.asymmetric_signing.tests.js",
          "status": "modified",
          "additions": 60,
          "deletions": 29,
          "patch": "@@ -1,17 +1,17 @@\n-var jwt = require('../index');\n-var PS_SUPPORTED = require('../lib/psSupported');\n-var fs = require('fs');\n-var path = require('path');\n+const jwt = require('../index');\n+const PS_SUPPORTED = require('../lib/psSupported');\n+const fs = require('fs');\n+const path = require('path');\n \n-var expect = require('chai').expect;\n-var assert = require('chai').assert;\n-var ms = require('ms');\n+const expect = require('chai').expect;\n+const assert = require('chai').assert;\n+const ms = require('ms');\n \n function loadKey(filename) {\n   return fs.readFileSync(path.join(__dirname, filename));\n }\n \n-var algorithms = {\n+const algorithms = {\n   RS256: {\n     pub_key: loadKey('pub.pem'),\n     priv_key: loadKey('priv.pem'),\n@@ -35,18 +35,17 @@ if (PS_SUPPORTED) {\n }\n \n \n-describe('Asymmetric Algorithms', function(){\n-\n+describe('Asymmetric Algorithms', function() {\n   Object.keys(algorithms).forEach(function (algorithm) {\n     describe(algorithm, function () {\n-      var pub = algorithms[algorithm].pub_key;\n-      var priv = algorithms[algorithm].priv_key;\n+      const pub = algorithms[algorithm].pub_key;\n+      const priv = algorithms[algorithm].priv_key;\n \n       // \"invalid\" means it is not the public key for the loaded \"priv\" key\n-      var invalid_pub = algorithms[algorithm].invalid_pub_key;\n+      const invalid_pub = algorithms[algorithm].invalid_pub_key;\n \n       describe('when signing a token', function () {\n-        var token = jwt.sign({ foo: 'bar' }, priv, { algorithm: algorithm });\n+        const token = jwt.sign({ foo: 'bar' }, priv, { algorithm: algorithm });\n \n         it('should be syntactically valid', function () {\n           expect(token).to.be.a('string');\n@@ -73,23 +72,22 @@ describe('Asymmetric Algorithms', function(){\n \n         context('synchronous', function () {\n           it('should validate with public key', function () {\n-            var decoded = jwt.verify(token, pub);\n+            const decoded = jwt.verify(token, pub);\n             assert.ok(decoded.foo);\n             assert.equal('bar', decoded.foo);\n           });\n \n           it('should throw with invalid public key', function () {\n-            var jwtVerify = jwt.verify.bind(null, token, invalid_pub)\n+            const jwtVerify = jwt.verify.bind(null, token, invalid_pub)\n             assert.throw(jwtVerify, 'invalid signature');\n           });\n         });\n \n       });\n \n       describe('when signing a token with expiration', function () {\n-        var token = jwt.sign({ foo: 'bar' }, priv, { algorithm: algorithm, expiresIn: '10m' });\n-\n         it('should be valid expiration', function (done) {\n+          const token = jwt.sign({ foo: 'bar' }, priv, { algorithm: algorithm, expiresIn: '10m' });\n           jwt.verify(token, pub, function (err, decoded) {\n             assert.isNotNull(decoded);\n             assert.isNull(err);\n@@ -99,8 +97,7 @@ describe('Asymmetric Algorithms', function(){\n \n         it('should be invalid', function (done) {\n           // expired token\n-          token = jwt.sign({ foo: 'bar' }, priv, { algorithm: algorithm, expiresIn: -1 * ms('10m') });\n-\n+          const token = jwt.sign({ foo: 'bar' }, priv, { algorithm: algorithm, expiresIn: -1 * ms('10m') });\n           jwt.verify(token, pub, function (err, decoded) {\n             assert.isUndefined(decoded);\n             assert.isNotNull(err);\n@@ -113,7 +110,7 @@ describe('Asymmetric Algorithms', function(){\n \n         it('should NOT be invalid', function (done) {\n           // expired token\n-          token = jwt.sign({ foo: 'bar' }, priv, { algorithm: algorithm, expiresIn: -1 * ms('10m') });\n+          const token = jwt.sign({ foo: 'bar' }, priv, { algorithm: algorithm, expiresIn: -1 * ms('10m') });\n \n           jwt.verify(token, pub, { ignoreExpiration: true }, function (err, decoded) {\n             assert.ok(decoded.foo);\n@@ -135,7 +132,7 @@ describe('Asymmetric Algorithms', function(){\n       });\n \n       describe('when decoding a jwt token with additional parts', function () {\n-        var token = jwt.sign({ foo: 'bar' }, priv, { algorithm: algorithm });\n+        const token = jwt.sign({ foo: 'bar' }, priv, { algorithm: algorithm });\n \n         it('should throw', function (done) {\n           jwt.verify(token + '.foo', pub, function (err, decoded) {\n@@ -148,24 +145,24 @@ describe('Asymmetric Algorithms', function(){\n \n       describe('when decoding a invalid jwt token', function () {\n         it('should return null', function (done) {\n-          var payload = jwt.decode('whatever.token');\n+          const payload = jwt.decode('whatever.token');\n           assert.isNull(payload);\n           done();\n         });\n       });\n \n       describe('when decoding a valid jwt token', function () {\n         it('should return the payload', function (done) {\n-          var obj = { foo: 'bar' };\n-          var token = jwt.sign(obj, priv, { algorithm: algorithm });\n-          var payload = jwt.decode(token);\n+          const obj = { foo: 'bar' };\n+          const token = jwt.sign(obj, priv, { algorithm: algorithm });\n+          const payload = jwt.decode(token);\n           assert.equal(payload.foo, obj.foo);\n           done();\n         });\n         it('should return the header and payload and signature if complete option is set', function (done) {\n-          var obj = { foo: 'bar' };\n-          var token = jwt.sign(obj, priv, { algorithm: algorithm });\n-          var decoded = jwt.decode(token, { complete: true });\n+          const obj = { foo: 'bar' };\n+          const token = jwt.sign(obj, priv, { algorithm: algorithm });\n+          const decoded = jwt.decode(token, { complete: true });\n           assert.equal(decoded.payload.foo, obj.foo);\n           assert.deepEqual(decoded.header, { typ: 'JWT', alg: algorithm });\n           assert.ok(typeof decoded.signature == 'string');\n@@ -174,4 +171,38 @@ describe('Asymmetric Algorithms', function(){\n       });\n     });\n   });\n+\n+  describe('when signing a token with an unsupported private key type', function () {\n+    it('should throw an error', function() {\n+      const obj = { foo: 'bar' };\n+      const key = loadKey('dsa-private.pem');\n+      const algorithm = 'RS256';\n+\n+      expect(function() {\n+        jwt.sign(obj, key, { algorithm });\n+      }).to.throw('Unknown key type \"dsa\".');\n+    });\n+  });\n+\n+  describe('when signing a token with an incorrect private key type', function () {\n+    it('should throw a validation error if key validation is enabled', function() {\n+      const obj = { foo: 'bar' };\n+      const key = loadKey('rsa-private.pem');\n+      const algorithm = 'ES256';\n+\n+      expect(function() {\n+        jwt.sign(obj, key, { algorithm });\n+      }).to.throw(/\"alg\" parameter for \"rsa\" key type must be one of:/);\n+    });\n+\n+    it('should throw an unknown error if key validation is disabled', function() {\n+      const obj = { foo: 'bar' };\n+      const key = loadKey('rsa-private.pem');\n+      const algorithm = 'ES256';\n+\n+      expect(function() {\n+        jwt.sign(obj, key, { algorithm, allowInvalidAsymmetricKeyTypes: true });\n+      }).to.not.throw(/\"alg\" parameter for \"rsa\" key type must be one of:/);\n+    });\n+  });\n });"
        },
        {
          "filename": "test/prime256v1-private.pem",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+-----BEGIN EC PRIVATE KEY-----\n+MHcCAQEEIMP1Xt/ic2jAHJva2Pll866d1jYL+dk3VdLytEU1+LFmoAoGCCqGSM49\n+AwEHoUQDQgAEvIywoA1H1a2XpPPTqsRxSk6YnNRVsu4E+wTvb7uV6Yttvko9zWar\n+jmtM3LHDXk/nHn+Pva0KD+lby8gb2daHGg==\n+-----END EC PRIVATE KEY-----"
        },
        {
          "filename": "test/rsa-pss-invalid-salt-length-private.pem",
          "status": "added",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -0,0 +1,29 @@\n+-----BEGIN PRIVATE KEY-----\n+MIIE8gIBADBCBgkqhkiG9w0BAQowNaAPMA0GCWCGSAFlAwQCAQUAoRwwGgYJKoZI\n+hvcNAQEIMA0GCWCGSAFlAwQCAQUAogQCAgQABIIEpzCCBKMCAQACggEBAJy3FuDR\n+1qKXsC8o+0xDJbuJCnysT71EFDGQY2/b3cZmxW3rzDYLyE65t2Go1jeK5Kxs+kwS\n+1VxfefD8DifeDZN66wjRse4iWLcxmQB5FfishXOdozciimgXNvXJNS8X//feSofl\n+vDQaTUI0NJnw1qQ2CB0pgGInwajsRKpWnDOhfk3NA/cmGlmfhTtDSTxq0ReytUie\n+TjY7gy+S9YYm4bAgBcMeoup0GEPzYccK4+1yCmWzQZGFcrY1cuB9bL+vT7ajQFhe\n+WVKlp6z35GyBF2zI7gJSkHpUHaWV5+Z9aTr6+YP6U7xuCRvXQ/l6BEOUjt4Es2YG\n+3frgxeVbOs1gAakCAwEAAQKCAQAMvFxhnOwCfq1Ux9HUWsigOvzdMOuyB+xUMtXB\n+625Uh1mYG0eXRNHcg/9BMoVmMiVvVdPphsZMIX45dWJ5HvSffafIKbJ6FdR73s3+\n+WdjNQsf9o1v2SRpSZ0CSLO3ji+HDdQ89iBAJc/G/ZZq4v/fRlIqIRC0ozO5SGhFi\n+fnNnRqH78d2KeJMX/g9jBZM8rJQCi+pb0keHmFmLJ5gZa4HokE8rWQJQY46PVYUH\n+W2BwEJToMl3MPC7D95soWVuFt3KHnIWhuma/tnCmd2AUvcMrdWq0CwStH3vuX4LB\n+vJug0toWkobt1tzZgzzCASb2EpzJj8UNxP1CzTQWsvl8OephAoGBAMVnmZeLHoh2\n+kxn/+rXetZ4Msjgu19MHNQAtlMvqzwZLan0K/BhnHprJLy4SDOuQYIs+PYJuXdT7\n+Yv2mp9kwTPz8glP9LAto4MDeDfCu0cyXmZb2VQcT/lqVyrwfx3Psqxm/Yxg62YKr\n+aQE8WqgZGUdOvU9dYU+7EmPlYpdGpPVlAoGBAMs7ks+12oE6kci3WApdnt0kk5+f\n+8fbQ0lp2vR3tEw8DURa5FnHWA4o46XvcMcuXwZBrpxANPNAxJJjMBs1hSkc8h4hd\n+4vjtRNYJpj+uBdDIRmdqTzbpWv+hv8Xpiol5EVgnMVs2UZWDjoxQ+mYa1R8tAUfj\n+ojzV2KBMWGCoHgj1AoGALki6JGQEBq72kpQILnhHUQVdC/s/s0TvUlldl+o4HBu2\n+nhbjQL182YHuQ/kLenfhiwRO27QQ4A0JCrv2gt/mTTLPQ+4KU6qFd/MYhaQXoMay\n+xkh/aydu7cJNRIqW80E8ZM8Q5u91bEPQXO/PubYYzTVTAba9SDpud2mjEiEIMFkC\n+gYEAxINEQEgtkkuZ76UpIkzIcjkN7YlxJCFjZUnvL+KvTRL986TgyQ4RujOxwKx4\n+Ec8ZwZX2opTKOt1p771IzorGkf87ZmayM9TpfLUz5dtVkD43pYOsOQKHlStIDgz2\n+gltoo/6xwOrTFGlzCsa6eMR1U4Hm/SZlF8IHh2iLBFtLP4kCgYBqTi1XeWeVQVSA\n+y9Wolv9kMoRh/Xh6F2D8bTTybGshDVO+P4YLM4lLxh5UDZAd/VOkdf3ZIcUGv022\n+lxrYbLbIEGckMCpkdHeZH/1/iuJUeiCrXeyNlQsXBrmJKr/0lENniJHGpiSEyvY5\n+D8Oafyjd7ZjUmyBFvS4heQEC6Pjo3Q==\n+-----END PRIVATE KEY-----"
        },
        {
          "filename": "test/rsa-pss-private.pem",
          "status": "added",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -0,0 +1,29 @@\n+-----BEGIN PRIVATE KEY-----\n+MIIE8QIBADBBBgkqhkiG9w0BAQowNKAPMA0GCWCGSAFlAwQCAQUAoRwwGgYJKoZI\n+hvcNAQEIMA0GCWCGSAFlAwQCAQUAogMCASAEggSnMIIEowIBAAKCAQEA00tEqqyF\n+VnyvcVA2ewVoSicCMdQXmWyYM82sBWX0wcnn0WUuZp1zjux4xTvQ71Lhx95OJCQZ\n+7r7b2192Im5ca37wNRbI6DhyXNdNVFXLFYlNAvgP+V0gIwlr6NgopdJqHCjYVv/g\n+GOoesRZaDdtV1A3O9CXdJ34x2HZh7nhwYK5hqZDhUW4rd+5GzIIzwCJfwgTQpkIc\n+18UeMMEoKJ6A0ixdpf43HqJ5fAB5nsbYFhyHpfiX1UO2EFJtSdbKEIbRmqcbNjG1\n+tu1tjt6u8LI2coetLh/IYMbMfkyQz+eAUHLQCUb2R8BqLOL3hRqEsVTBo93UJlOs\n+VWC1fKaq+HOEWQIDAQABAoIBAAet23PagPQTjwAZcAlzjlvs5AMHQsj5gznqwSmR\n+ut3/e7SGrrOIXbv1iIQejZQ3w8CS/0MH/ttIRiRIaWTh9EDsjvKsU9FAxUNDiJTG\n+k3LCbTFCQ7kGiJWiu4XDCWMmwmLTRzLjlMjtr/+JS5eSVPcNKMGDI3D9K0xDLSxQ\n+u0DVigYgWOCWlejHCEU4yi6vBO0HlumWjVPelWb9GmihBDwCLUJtG0JA6H6rw+KS\n+i6SNXcMGVKfjEghChRp+HaMvLvMgU44Ptnj8jhlfBctXInBY1is1FfDSWxXdVbUM\n+1HdKXfV4A50GXSvJLiWP9ZZsaZ7NiBJK8IiJBXD72EFOzwECgYEA3RjnTJn9emzG\n+84eIHZQujWWt4Tk/wjeLJYOYtAZpF7R3/fYLVypX9Bsw1IbwZodq/jChTjMaUkYt\n+//FgUjF/t0uakEg1i+THPZvktNB8Q1E9NwHerB8HF/AD/jMALD+ejdLQ11Z4VScw\n+zyNmSvD9I84/sgpms5YVKSH9sqww2RkCgYEA9KYws3sTfRLc1hlsS25V6+Zg3ZCk\n+iGcp+zrxGC1gb2/PpRvEDBucZO21KbSRuQDavWIOZYl4fGu7s8wo2oF8RxOsHQsM\n+LJyjklruvtjnvuoft/bGAv2zLQkNaj+f7IgK6965gIxcLYL66UPCZZkTfL5CoJis\n+V0v2hBh1ES5bLUECgYEAuONeaLxNL9dO989akAGefDePFExfePYhshk91S2XLG+J\n++CGMkjOioUsrpk3BMrwDSNU5zr8FP8/YH7OlrJYgCxN6CTWZMYb65hY7RskhYNnK\n+qvkxUBYSRH49mJDlkBsTZ93nLmvs7Kh9NHqRzBGCXjLXKPdxsrPKtj7qfENqBeEC\n+gYAC9dPXCCE3PTgw2wPlccNWZGY9qBdlkyH96TurmDj3gDnZ/JkFsHvW+M1dYNL2\n+kx0Sd5JHBj/P+Zm+1jSUWEbBsWo+u7h8/bQ4/CKxanx7YefaWQESXjGB1P81jumH\n+einvqrVB6fDfmBsjIW/DvPNwafjyaoaDU+b6uDUKbS4rQQKBgCe0pvDl5lO8FM81\n+NP7GoCIu1gKBS+us1sgYE65ZFmVXJ6b5DckvobXSjM60G2N5w2xaXEXJsnwMApf1\n+SClQUsgNWcSXRwL+w0pIdyFKS25BSfwUNQ9n7QLJcYgmflbARTfB3He/10vbFzTp\n+G6ZAiKUp9bKFPzviII40AEPL2hPX\n+-----END PRIVATE KEY-----"
        },
        {
          "filename": "test/schema.tests.js",
          "status": "modified",
          "additions": 15,
          "deletions": 15,
          "patch": "@@ -6,31 +6,31 @@ var PS_SUPPORTED = require('../lib/psSupported');\n describe('schema', function() {\n \n   describe('sign options', function() {\n-\n     var cert_rsa_priv = fs.readFileSync(__dirname + '/rsa-private.pem');\n     var cert_ecdsa_priv = fs.readFileSync(__dirname + '/ecdsa-private.pem');\n+    var cert_secp384r1_priv = fs.readFileSync(__dirname + '/secp384r1-private.pem');\n+    var cert_secp521r1_priv = fs.readFileSync(__dirname + '/secp521r1-private.pem');\n \n-    function sign(options, secret) {\n-      var isEcdsa = options.algorithm && options.algorithm.indexOf('ES') === 0;\n-      jwt.sign({foo: 123}, secret || (isEcdsa ? cert_ecdsa_priv : cert_rsa_priv), options);\n+    function sign(options, secretOrPrivateKey) {\n+      jwt.sign({foo: 123}, secretOrPrivateKey, options);\n     }\n \n     it('should validate algorithm', function () {\n       expect(function () {\n-        sign({ algorithm: 'foo' });\n+        sign({ algorithm: 'foo' }, cert_rsa_priv);\n       }).to.throw(/\"algorithm\" must be a valid string enum value/);\n-      sign({ algorithm: 'none' });\n-      sign({algorithm: 'RS256'});\n-      sign({algorithm: 'RS384'});\n-      sign({algorithm: 'RS512'});\n+      sign({ algorithm: 'none' }, null);\n+      sign({algorithm: 'RS256'}, cert_rsa_priv);\n+      sign({algorithm: 'RS384'}, cert_rsa_priv);\n+      sign({algorithm: 'RS512'}, cert_rsa_priv);\n       if (PS_SUPPORTED) {\n-        sign({algorithm: 'PS256'});\n-        sign({algorithm: 'PS384'});\n-        sign({algorithm: 'PS512'});\n+        sign({algorithm: 'PS256'}, cert_rsa_priv);\n+        sign({algorithm: 'PS384'}, cert_rsa_priv);\n+        sign({algorithm: 'PS512'}, cert_rsa_priv);\n       }\n-      sign({algorithm: 'ES256'});\n-      sign({algorithm: 'ES384'});\n-      sign({algorithm: 'ES512'});\n+      sign({algorithm: 'ES256'}, cert_ecdsa_priv);\n+      sign({algorithm: 'ES384'}, cert_secp384r1_priv);\n+      sign({algorithm: 'ES512'}, cert_secp521r1_priv);\n       sign({algorithm: 'HS256'}, 'superSecret');\n       sign({algorithm: 'HS384'}, 'superSecret');\n       sign({algorithm: 'HS512'}, 'superSecret');"
        },
        {
          "filename": "test/secp384r1-private.pem",
          "status": "added",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -0,0 +1,6 @@\n+-----BEGIN EC PRIVATE KEY-----\n+MIGkAgEBBDCez58vZHVp+ArI7/fe835GAtRzE0AtrxGgQAY1U/uk2SQOaSw1ph61\n+3Unr0ygS172gBwYFK4EEACKhZANiAARtwlnIqYqZxfiWR+/EM35nKHuLpOjUHiX1\n+kEpSS03C9XlrBLNwLQfgjpYx9Qvqh26XAzTe74DYjcc748R+zZD2YAd3lV+OcdRE\n+U+DWm4j5E6dlOXzvmw/3qxUcg3rRgR4=\n+-----END EC PRIVATE KEY-----"
        },
        {
          "filename": "test/secp521r1-private.pem",
          "status": "added",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -0,0 +1,7 @@\n+-----BEGIN EC PRIVATE KEY-----\n+MIHcAgEBBEIBlWXKBKKCgTgf7+NS09TMv7/NO3RtMBn9xTe+46oNNNK405lrZ9mz\n+WYtlsYvkdsc2Cx3v5V8JegaCOM+XtAZ0MNKgBwYFK4EEACOhgYkDgYYABAFNzaM7\n+Zb9ug0p5KaZb5mjHrIshoVJSHaOXGtcjLVUakYVk0v9VsE+FKqyuLYcORUuAZdxl\n+ITAlC5e5JZ0o8NEKbAE+8oOrePrItR3IFBtWO15p7qiRa2dBB8oQklFrmQaJYn4K\n+fDV0hYpfu6ahpRNu2akR7aMXL/vXrptCH/n64q9KjA==\n+-----END EC PRIVATE KEY-----"
        },
        {
          "filename": "test/validateAsymmetricKey.tests.js",
          "status": "added",
          "additions": 142,
          "deletions": 0,
          "patch": "@@ -0,0 +1,142 @@\n+const validateAsymmetricKey = require('../lib/validateAsymmetricKey');\n+const PS_SUPPORTED = require('../lib/psSupported');\n+const ASYMMETRIC_KEY_DETAILS_SUPPORTED = require('../lib/asymmetricKeyDetailsSupported');\n+const RSA_PSS_KEY_DETAILS_SUPPORTED = require('../lib/rsaPssKeyDetailsSupported');\n+const fs = require('fs');\n+const path = require('path');\n+const { createPrivateKey } = require('crypto');\n+const expect = require('chai').expect;\n+\n+function loadKey(filename) {\n+  return createPrivateKey(\n+    fs.readFileSync(path.join(__dirname, filename))\n+  );\n+}\n+\n+const algorithmParams = {\n+  RS256: {\n+    invalidPrivateKey: loadKey('secp384r1-private.pem')\n+  },\n+  ES256: {\n+    invalidPrivateKey: loadKey('priv.pem')\n+  }\n+};\n+\n+if (PS_SUPPORTED) {\n+  algorithmParams.PS256 = {\n+    invalidPrivateKey: loadKey('secp384r1-private.pem')\n+  };\n+}\n+\n+describe('Asymmetric key validation', function() {\n+  Object.keys(algorithmParams).forEach(function(algorithm) {\n+    describe(algorithm, function() {\n+      const keys = algorithmParams[algorithm];\n+\n+      describe('when validating a key with an invalid private key type', function () {\n+        it('should throw an error', function () {\n+          const expectedErrorMessage = /\"alg\" parameter for \"[\\w\\d-]+\" key type must be one of:/;\n+\n+          expect(function() {\n+            validateAsymmetricKey(algorithm, keys.invalidPrivateKey);\n+          }).to.throw(expectedErrorMessage);\n+        });\n+      });\n+    });\n+  });\n+\n+  describe('when the function has missing parameters', function() {\n+    it('should pass the validation if no key has been provided', function() {\n+      const algorithm = 'ES256';\n+      validateAsymmetricKey(algorithm);\n+    });\n+\n+    it('should pass the validation if no algorithm has been provided', function() {\n+      const key = loadKey('dsa-private.pem');\n+      validateAsymmetricKey(null, key);\n+    });\n+  });\n+\n+  describe('when validating a key with an unsupported type', function () {\n+    it('should throw an error', function() {\n+      const algorithm = 'RS256';\n+      const key = loadKey('dsa-private.pem');\n+      const expectedErrorMessage = 'Unknown key type \"dsa\".';\n+\n+      expect(function() {\n+        validateAsymmetricKey(algorithm, key);\n+      }).to.throw(expectedErrorMessage);\n+    });\n+  });\n+\n+  describe('Elliptic curve algorithms', function () {\n+    const curvesAlgorithms = [\n+      { algorithm: 'ES256', curve: 'prime256v1' },\n+      { algorithm: 'ES384', curve: 'secp384r1' },\n+      { algorithm: 'ES512', curve: 'secp521r1' },\n+    ];\n+\n+    const curvesKeys = [\n+      { curve: 'prime256v1', key: loadKey('prime256v1-private.pem') },\n+      { curve: 'secp384r1', key: loadKey('secp384r1-private.pem') },\n+      { curve: 'secp521r1', key: loadKey('secp521r1-private.pem') }\n+    ];\n+\n+    describe('when validating keys generated using Elliptic Curves', function () {\n+      curvesAlgorithms.forEach(function(curveAlgorithm) {\n+        curvesKeys\n+          .forEach((curveKeys) => {\n+            if (curveKeys.curve !== curveAlgorithm.curve) {\n+              if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {\n+                it(`should throw an error when validating an ${curveAlgorithm.algorithm} token for key with curve ${curveKeys.curve}`, function() {\n+                  expect(() => {\n+                    validateAsymmetricKey(curveAlgorithm.algorithm, curveKeys.key);\n+                  }).to.throw(`\"alg\" parameter \"${curveAlgorithm.algorithm}\" requires curve \"${curveAlgorithm.curve}\".`);\n+                });\n+              } else {\n+                it(`should pass the validation for incorrect keys if the Node version does not support checking the key's curve name`, function() {\n+                  expect(() => {\n+                    validateAsymmetricKey(curveAlgorithm.algorithm, curveKeys.key);\n+                  }).not.to.throw();\n+                });\n+              }\n+            } else {\n+              it(`should accept an ${curveAlgorithm.algorithm} token for key with curve ${curveKeys.curve}`, function() {\n+                expect(() => {\n+                  validateAsymmetricKey(curveAlgorithm.algorithm, curveKeys.key);\n+                }).not.to.throw();\n+              });\n+            }\n+          });\n+      });\n+    });\n+  });\n+\n+  if (RSA_PSS_KEY_DETAILS_SUPPORTED) {\n+    describe('RSA-PSS algorithms', function () {\n+      const key = loadKey('rsa-pss-private.pem');\n+\n+      it(`it should throw an error when validating a key with wrong RSA-RSS parameters`, function () {\n+        const algorithm = 'PS512';\n+        expect(function() {\n+          validateAsymmetricKey(algorithm, key);\n+        }).to.throw('Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of \"alg\" PS512')\n+      });\n+\n+      it(`it should throw an error when validating a key with invalid salt length`, function () {\n+        const algorithm = 'PS256';\n+        const shortSaltKey = loadKey('rsa-pss-invalid-salt-length-private.pem');\n+        expect(function() {\n+          validateAsymmetricKey(algorithm, shortSaltKey);\n+        }).to.throw('Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of \"alg\" PS256.')\n+      });\n+\n+      it(`it should pass the validation when the key matches all the requirements for the algorithm`, function () {\n+        expect(function() {\n+          const algorithm = 'PS256';\n+          validateAsymmetricKey(algorithm, key);\n+        }).not.to.throw()\n+      });\n+    });\n+  }\n+});"
        },
        {
          "filename": "test/verify.tests.js",
          "status": "modified",
          "additions": 74,
          "deletions": 43,
          "patch": "@@ -1,22 +1,22 @@\n-var jwt = require('../index');\n-var jws = require('jws');\n-var fs = require('fs');\n-var path = require('path');\n-var sinon = require('sinon');\n-var JsonWebTokenError = require('../lib/JsonWebTokenError');\n+const jwt = require('../index');\n+const jws = require('jws');\n+const fs = require('fs');\n+const path = require('path');\n+const sinon = require('sinon');\n+const JsonWebTokenError = require('../lib/JsonWebTokenError');\n \n-var assert = require('chai').assert;\n-var expect = require('chai').expect;\n+const assert = require('chai').assert;\n+const expect = require('chai').expect;\n \n describe('verify', function() {\n-  var pub = fs.readFileSync(path.join(__dirname, 'pub.pem'));\n-  var priv = fs.readFileSync(path.join(__dirname, 'priv.pem'));\n+  const pub = fs.readFileSync(path.join(__dirname, 'pub.pem'));\n+  const priv = fs.readFileSync(path.join(__dirname, 'priv.pem'));\n \n   it('should first assume JSON claim set', function (done) {\n-    var header = { alg: 'RS256' };\n-    var payload = { iat: Math.floor(Date.now() / 1000 ) };\n+    const header = { alg: 'RS256' };\n+    const payload = { iat: Math.floor(Date.now() / 1000 ) };\n \n-    var signed = jws.sign({\n+    const signed = jws.sign({\n       header: header,\n       payload: payload,\n       secret: priv,\n@@ -31,10 +31,10 @@ describe('verify', function() {\n   });\n \n   it('should not be able to verify unsigned token', function () {\n-    var header = { alg: 'none' };\n-    var payload = { iat: Math.floor(Date.now() / 1000 ) };\n+    const header = { alg: 'none' };\n+    const payload = { iat: Math.floor(Date.now() / 1000 ) };\n \n-    var signed = jws.sign({\n+    const signed = jws.sign({\n       header: header,\n       payload: payload,\n       secret: 'secret',\n@@ -47,10 +47,10 @@ describe('verify', function() {\n   });\n \n   it('should not be able to verify unsigned token', function () {\n-    var header = { alg: 'none' };\n-    var payload = { iat: Math.floor(Date.now() / 1000 ) };\n+    const header = { alg: 'none' };\n+    const payload = { iat: Math.floor(Date.now() / 1000 ) };\n \n-    var signed = jws.sign({\n+    const signed = jws.sign({\n       header: header,\n       payload: payload,\n       secret: 'secret',\n@@ -63,10 +63,10 @@ describe('verify', function() {\n   });\n \n   it('should be able to verify unsigned token when none is specified', function (done) {\n-    var header = { alg: 'none' };\n-    var payload = { iat: Math.floor(Date.now() / 1000 ) };\n+    const header = { alg: 'none' };\n+    const payload = { iat: Math.floor(Date.now() / 1000 ) };\n \n-    var signed = jws.sign({\n+    const signed = jws.sign({\n       header: header,\n       payload: payload,\n       secret: 'secret',\n@@ -99,11 +99,11 @@ describe('verify', function() {\n   });\n \n   describe('secret or token as callback', function () {\n-    var token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE0MzcwMTg1ODIsImV4cCI6MTQzNzAxODU5Mn0.3aR3vocmgRpG05rsI9MpR6z2T_BGtMQaPq2YR6QaroU';\n-    var key = 'key';\n+    const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE0MzcwMTg1ODIsImV4cCI6MTQzNzAxODU5Mn0.3aR3vocmgRpG05rsI9MpR6z2T_BGtMQaPq2YR6QaroU';\n+    const key = 'key';\n \n-    var payload = { foo: 'bar', iat: 1437018582, exp: 1437018592 };\n-    var options = {algorithms: ['HS256'], ignoreExpiration: true};\n+    const payload = { foo: 'bar', iat: 1437018582, exp: 1437018592 };\n+    const options = {algorithms: ['HS256'], ignoreExpiration: true};\n \n     it('without callback', function (done) {\n       jwt.verify(token, key, options, function (err, p) {\n@@ -114,7 +114,7 @@ describe('verify', function() {\n     });\n \n     it('simple callback', function (done) {\n-      var keyFunc = function(header, callback) {\n+      const keyFunc = function(header, callback) {\n         assert.deepEqual(header, { alg: 'HS256', typ: 'JWT' });\n \n         callback(undefined, key);\n@@ -128,7 +128,7 @@ describe('verify', function() {\n     });\n \n     it('should error if called synchronously', function (done) {\n-      var keyFunc = function(header, callback) {\n+      const keyFunc = function(header, callback) {\n         callback(undefined, key);\n       };\n \n@@ -140,7 +140,7 @@ describe('verify', function() {\n     });\n \n     it('simple error', function (done) {\n-      var keyFunc = function(header, callback) {\n+      const keyFunc = function(header, callback) {\n         callback(new Error('key not found'));\n       };\n \n@@ -153,7 +153,7 @@ describe('verify', function() {\n     });\n \n     it('delayed callback', function (done) {\n-      var keyFunc = function(header, callback) {\n+      const keyFunc = function(header, callback) {\n         setTimeout(function() {\n           callback(undefined, key);\n         }, 25);\n@@ -167,7 +167,7 @@ describe('verify', function() {\n     });\n \n     it('delayed error', function (done) {\n-      var keyFunc = function(header, callback) {\n+      const keyFunc = function(header, callback) {\n         setTimeout(function() {\n           callback(new Error('key not found'));\n         }, 25);\n@@ -184,17 +184,17 @@ describe('verify', function() {\n \n   describe('expiration', function () {\n     // { foo: 'bar', iat: 1437018582, exp: 1437018592 }\n-    var token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE0MzcwMTg1ODIsImV4cCI6MTQzNzAxODU5Mn0.3aR3vocmgRpG05rsI9MpR6z2T_BGtMQaPq2YR6QaroU';\n-    var key = 'key';\n+    const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE0MzcwMTg1ODIsImV4cCI6MTQzNzAxODU5Mn0.3aR3vocmgRpG05rsI9MpR6z2T_BGtMQaPq2YR6QaroU';\n+    const key = 'key';\n \n-    var clock;\n+    let clock;\n     afterEach(function () {\n       try { clock.restore(); } catch (e) {}\n     });\n \n     it('should error on expired token', function (done) {\n       clock = sinon.useFakeTimers(1437018650000); // iat + 58s, exp + 48s\n-      var options = {algorithms: ['HS256']};\n+      const options = {algorithms: ['HS256']};\n \n       jwt.verify(token, key, options, function (err, p) {\n         assert.equal(err.name, 'TokenExpiredError');\n@@ -208,7 +208,7 @@ describe('verify', function() {\n \n     it('should not error on expired token within clockTolerance interval', function (done) {\n       clock = sinon.useFakeTimers(1437018594000); // iat + 12s, exp + 2s\n-      var options = {algorithms: ['HS256'], clockTolerance: 5 }\n+      const options = {algorithms: ['HS256'], clockTolerance: 5 }\n \n       jwt.verify(token, key, options, function (err, p) {\n         assert.isNull(err);\n@@ -218,16 +218,16 @@ describe('verify', function() {\n     });\n \n     describe('option: clockTimestamp', function () {\n-      var clockTimestamp = 1000000000;\n+      const clockTimestamp = 1000000000;\n       it('should verify unexpired token relative to user-provided clockTimestamp', function (done) {\n-        var token = jwt.sign({foo: 'bar', iat: clockTimestamp, exp: clockTimestamp + 1}, key);\n+        const token = jwt.sign({foo: 'bar', iat: clockTimestamp, exp: clockTimestamp + 1}, key);\n         jwt.verify(token, key, {clockTimestamp: clockTimestamp}, function (err) {\n           assert.isNull(err);\n           done();\n         });\n       });\n       it('should error on expired token relative to user-provided clockTimestamp', function (done) {\n-        var token = jwt.sign({foo: 'bar', iat: clockTimestamp, exp: clockTimestamp + 1}, key);\n+        const token = jwt.sign({foo: 'bar', iat: clockTimestamp, exp: clockTimestamp + 1}, key);\n         jwt.verify(token, key, {clockTimestamp: clockTimestamp + 1}, function (err, p) {\n           assert.equal(err.name, 'TokenExpiredError');\n           assert.equal(err.message, 'jwt expired');\n@@ -238,7 +238,7 @@ describe('verify', function() {\n         });\n       });\n       it('should verify clockTimestamp is a number', function (done) {\n-        var token = jwt.sign({foo: 'bar', iat: clockTimestamp, exp: clockTimestamp + 1}, key);\n+        const token = jwt.sign({foo: 'bar', iat: clockTimestamp, exp: clockTimestamp + 1}, key);\n         jwt.verify(token, key, {clockTimestamp: 'notANumber'}, function (err, p) {\n           assert.equal(err.name, 'JsonWebTokenError');\n           assert.equal(err.message,'clockTimestamp must be a number');\n@@ -250,10 +250,10 @@ describe('verify', function() {\n \n     describe('option: maxAge and clockTimestamp', function () {\n       // { foo: 'bar', iat: 1437018582, exp: 1437018800 } exp = iat + 218s\n-      var token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE0MzcwMTg1ODIsImV4cCI6MTQzNzAxODgwMH0.AVOsNC7TiT-XVSpCpkwB1240izzCIJ33Lp07gjnXVpA';\n+      const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE0MzcwMTg1ODIsImV4cCI6MTQzNzAxODgwMH0.AVOsNC7TiT-XVSpCpkwB1240izzCIJ33Lp07gjnXVpA';\n       it('cannot be more permissive than expiration', function (done) {\n-        var clockTimestamp = 1437018900;  // iat + 318s (exp: iat + 218s)\n-        var options = {algorithms: ['HS256'], clockTimestamp: clockTimestamp, maxAge: '1000y'};\n+        const clockTimestamp = 1437018900;  // iat + 318s (exp: iat + 218s)\n+        const options = {algorithms: ['HS256'], clockTimestamp: clockTimestamp, maxAge: '1000y'};\n \n         jwt.verify(token, key, options, function (err, p) {\n           // maxAge not exceded, but still expired\n@@ -267,4 +267,35 @@ describe('verify', function() {\n       });\n     });\n   });\n+\n+  describe('when verifying a token with an unsupported public key type', function () {\n+    it('should throw an error', function() {\n+      const token = 'eyJhbGciOiJSUzI1NiJ9.eyJpYXQiOjE2Njk5OTAwMDN9.YdjFWJtPg_9nccMnTfQyesWQ0UX-GsWrfCGit_HqjeIkNjoV6dkAJ8AtbnVEhA4oxwqSXx6ilMOfHEjmMlPtyyyVKkWKQHcIWYnqPbNSEv8a7Men8KhJTIWb4sf5YbhgSCpNvU_VIZjLO1Z0PzzgmEikp0vYbxZFAbCAlZCvUlcIc-kdjIRCnDJe0BBrYRxNLEJtYsf7D1yFIFIqw8-VP87yZdExA4eHsTaE84SgnL24ZK5h5UooDx-IRNd_rrMyio8kNy63grVxCWOtkXZ26iZk6v-HMsnBqxvUwR6-8wfaWrcpADkyUO1q3SNsoTdwtflbvfwgjo3uve0IvIzHMw';\n+      const key = fs.readFileSync(path.join(__dirname, 'dsa-public.pem'));\n+\n+      expect(function() {\n+        jwt.verify(token, key);\n+      }).to.throw('Unknown key type \"dsa\".');\n+    });\n+  });\n+\n+  describe('when verifying a token with an incorrect public key type', function () {\n+    it('should throw a validation error if key validation is enabled', function() {\n+      const token = 'eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJwYXkiOiJsb2FkIiwiaWF0IjoxNjcwMjMwNDE2fQ.7TYP8SB_9Tw1fNIfuG60b4tvoLPpDAVBQpV1oepnuKwjUz8GOw4fRLzclo0Q2YAXisJ3zIYMEFsHpYrflfoZJQ';\n+      const key = fs.readFileSync(path.join(__dirname, 'rsa-public.pem'));\n+\n+      expect(function() {\n+        jwt.verify(token, key, { algorithms: ['ES256'] });\n+      }).to.throw('\"alg\" parameter for \"rsa\" key type must be one of: RS256, PS256, RS384, PS384, RS512, PS512.');\n+    });\n+\n+    it('should throw an unknown error if key validation is disabled', function() {\n+      const token = 'eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJwYXkiOiJsb2FkIiwiaWF0IjoxNjcwMjMwNDE2fQ.7TYP8SB_9Tw1fNIfuG60b4tvoLPpDAVBQpV1oepnuKwjUz8GOw4fRLzclo0Q2YAXisJ3zIYMEFsHpYrflfoZJQ';\n+      const key = fs.readFileSync(path.join(__dirname, 'rsa-public.pem'));\n+\n+      expect(function() {\n+        jwt.verify(token, key, { algorithms: ['ES256'], allowInvalidAsymmetricKeyTypes: true });\n+      }).to.not.throw('\"alg\" parameter for \"rsa\" key type must be one of: RS256, PS256, RS384, PS384, RS512, PS512.');\n+    });\n+  });\n });"
        },
        {
          "filename": "verify.js",
          "status": "modified",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -3,6 +3,7 @@ const NotBeforeError = require('./lib/NotBeforeError');\n const TokenExpiredError = require('./lib/TokenExpiredError');\n const decode = require('./decode');\n const timespan = require('./lib/timespan');\n+const validateAsymmetricKey = require('./lib/validateAsymmetricKey');\n const PS_SUPPORTED = require('./lib/psSupported');\n const jws = require('jws');\n const {KeyObject, createSecretKey, createPublicKey} = require(\"crypto\");\n@@ -49,6 +50,10 @@ module.exports = function (jwtString, secretOrPublicKey, options, callback) {\n     return done(new JsonWebTokenError('nonce must be a non-empty string'));\n   }\n \n+  if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== 'boolean') {\n+    return done(new JsonWebTokenError('allowInvalidAsymmetricKeyTypes must be a boolean'));\n+  }\n+\n   const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);\n \n   if (!jwtString){\n@@ -146,6 +151,14 @@ module.exports = function (jwtString, secretOrPublicKey, options, callback) {\n       return done(new JsonWebTokenError((`secretOrPublicKey must be an asymmetric key when using ${header.alg}`)))\n     }\n \n+    if (!options.allowInvalidAsymmetricKeyTypes) {\n+      try {\n+        validateAsymmetricKey(header.alg, secretOrPublicKey);\n+      } catch (e) {\n+        return done(e);\n+      }\n+    }\n+\n     let valid;\n \n     try {"
        }
      ],
      "file_patterns": {
        "security_files": 4,
        "config_files": 1,
        "dependency_files": 1,
        "test_files": 11,
        "unique_directories": 3,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "bc28861f1fa981ed9c009e29c044a19760a0b128",
            "date": "2023-08-30T12:25:33Z",
            "author_login": "jakelacey2012"
          },
          {
            "sha": "96b89060cfc19272a7d853f53cb28c42580a6a67",
            "date": "2023-08-30T12:06:25Z",
            "author_login": "jakelacey2012"
          },
          {
            "sha": "ed35062239c0195d4341025d4699cc39608b435e",
            "date": "2023-08-30T12:02:58Z",
            "author_login": "jakelacey2012"
          },
          {
            "sha": "84539b29e17fd40ed25c53fc28db8ae41a34aff8",
            "date": "2023-07-05T17:05:28Z",
            "author_login": "jakelacey2012"
          },
          {
            "sha": "a99fd4b473e257c2f50ff69c716db1c520bf9a78",
            "date": "2023-04-03T08:27:06Z",
            "author_login": "jakelacey2012"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.0,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:L",
    "cwe_id": "CWE-287",
    "description": "jsonwebtoken is an implementation of JSON Web Tokens. Versions `<= 8.5.1` of `jsonwebtoken` library can be misconfigured so that passing a poorly implemented key retrieval function referring to the `secretOrPublicKey` argument from the readme link will result in incorrect verification of tokens. There is a possibility of using a different algorithm and key combination in verification, other than the one that was used to sign the tokens. Specifically, tokens signed with an asymmetric public key could be verified with a symmetric HS256 algorithm. This can lead to successful validation of  forged tokens. If your application is supporting usage of both symmetric key and asymmetric key in jwt.verify() implementation with the same key retrieval function. This issue has been patched, please update to version 9.0.0.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-12-22T18:15:09.390",
    "last_modified": "2024-11-21T06:48:46.580",
    "fix_date": "2022-12-21T12:36:01Z"
  },
  "references": [
    {
      "url": "https://github.com/auth0/node-jsonwebtoken/commit/e1fa9dcc12054a8681db4e6373da1b30cf7016e3",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/auth0/node-jsonwebtoken/releases/tag/v9.0.0",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/auth0/node-jsonwebtoken/security/advisories/GHSA-hjrf-2m68-5959",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20240621-0007/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/auth0/node-jsonwebtoken/commit/e1fa9dcc12054a8681db4e6373da1b30cf7016e3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/auth0/node-jsonwebtoken/releases/tag/v9.0.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/auth0/node-jsonwebtoken/security/advisories/GHSA-hjrf-2m68-5959",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20240621-0007/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:23.198684",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "node-jsonwebtoken",
    "owner": "auth0",
    "created_at": "2013-07-01T01:28:43Z",
    "updated_at": "2025-01-14T07:11:43Z",
    "pushed_at": "2024-07-28T19:53:23Z",
    "size": 456,
    "stars": 17804,
    "forks": 1234,
    "open_issues": 168,
    "watchers": 17804,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "JavaScript": 154442
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T19:15:56.130788"
  }
}