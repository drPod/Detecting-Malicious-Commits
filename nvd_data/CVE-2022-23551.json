{
  "cve_id": "CVE-2022-23551",
  "github_data": {
    "repository": "Azure/aad-pod-identity",
    "fix_commit": "7e01970391bde6c360d077066ca17d059204cb5d",
    "related_commits": [
      "7e01970391bde6c360d077066ca17d059204cb5d",
      "7e01970391bde6c360d077066ca17d059204cb5d"
    ],
    "patch_url": "https://github.com/Azure/aad-pod-identity/commit/7e01970391bde6c360d077066ca17d059204cb5d.patch",
    "fix_commit_details": {
      "sha": "7e01970391bde6c360d077066ca17d059204cb5d",
      "commit_date": "2022-10-03T17:29:05Z",
      "author": {
        "login": "aramase",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix: add handler for invalid token requests (#1325)",
        "length": 111,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 59,
        "additions": 59,
        "deletions": 0
      },
      "files": [
        {
          "filename": "pkg/nmi/server/server.go",
          "status": "modified",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -40,6 +40,17 @@ const (\n \theaderRetryAfter   = \"Retry-After\"\n )\n \n+var (\n+\t// invalidTokenPathMatcher matches the token path that is not supported by IMDS\n+\t// this handler is configured right after the token path handler to block requests with\n+\t// invalid token path instead of sending it to IMDS.\n+\t// we don't have to handle case sensitivity for \"/identity/\" as that's rejected by IMDS\n+\tinvalidTokenPathMatcher = mux.MatcherFunc(func(req *http.Request, rm *mux.RouteMatch) bool {\n+\t\tr := regexp.MustCompile(\"/(?i:metadata)/identity(.*?)oauth2(.*?)token\") // #nosec\n+\t\treturn r.MatchString(req.URL.Path)\n+\t})\n+)\n+\n // Server encapsulates all of the parameters necessary for starting up\n // the server. These can be set via command line.\n type Server struct {\n@@ -98,7 +109,15 @@ func (s *Server) Run() error {\n \tgo s.updateIPTableRules()\n \n \trtr := mux.NewRouter()\n+\t// Flow for the request is as follows:\n+\t// 1. If the request is for token, then it will be handled by tokenHandler post validation.\n+\t// 2. If the request is for token but the path is invalid, then it will be handled by invalidTokenPathHandler.\n+\t// 3. If the request is for host token, then it will be handled by hostTokenHandler.\n+\t// 4. If the request is for instance metadata\n+\t//    4.1 If blockInstanceMetadata is set to true, then it will be handled by blockInstanceMetadataHandler (deny access to instance metadata).\n+\t// 5. If the request is for any other path, it will be proxied to IMDS and the response will be returned to the caller.\n \trtr.PathPrefix(tokenPathPrefix).Handler(appHandler(s.msiHandler))\n+\trtr.MatcherFunc(invalidTokenPathMatcher).HandlerFunc(invalidTokenPathHandler)\n \trtr.PathPrefix(hostTokenPathPrefix).Handler(appHandler(s.hostHandler))\n \tif s.BlockInstanceMetadata {\n \t\trtr.PathPrefix(instancePathPrefix).HandlerFunc(forbiddenHandler)\n@@ -581,6 +600,11 @@ func forbiddenHandler(w http.ResponseWriter, r *http.Request) {\n \thttp.Error(w, \"Request blocked by AAD Pod Identity NMI\", http.StatusForbidden)\n }\n \n+// invalidTokenPathHandler responds to invalid token requests with HTTP 400 Bad Request\n+func invalidTokenPathHandler(w http.ResponseWriter, r *http.Request) {\n+\thttp.Error(w, \"Invalid request\", http.StatusBadRequest)\n+}\n+\n func copyHeader(dst, src http.Header) {\n \tfor k, vv := range src {\n \t\tfor _, v := range vv {"
        },
        {
          "filename": "pkg/nmi/server/server_test.go",
          "status": "modified",
          "additions": 35,
          "deletions": 0,
          "patch": "@@ -217,6 +217,36 @@ func TestRouterPathPrefix(t *testing.T) {\n \t\t\texpectedStatusCode: http.StatusOK,\n \t\t\texpectedBody:       \"default_handler\",\n \t\t},\n+\t\t{\n+\t\t\tname:               \"invalid token request with \\\\oauth2\",\n+\t\t\turl:                `/metadata/identity\\oauth2/token/`,\n+\t\t\texpectedStatusCode: http.StatusOK,\n+\t\t\texpectedBody:       \"invalid_request_handler\",\n+\t\t},\n+\t\t{\n+\t\t\tname:               \"invalid token request with \\\\token\",\n+\t\t\turl:                `/metadata/identity/oauth2\\token/`,\n+\t\t\texpectedStatusCode: http.StatusOK,\n+\t\t\texpectedBody:       \"invalid_request_handler\",\n+\t\t},\n+\t\t{\n+\t\t\tname:               \"invalid token request with \\\\oauth2\\\\token\",\n+\t\t\turl:                `/metadata/identity\\oauth2\\token/`,\n+\t\t\texpectedStatusCode: http.StatusOK,\n+\t\t\texpectedBody:       \"invalid_request_handler\",\n+\t\t},\n+\t\t{\n+\t\t\tname:               \"invalid token request with mix of / and \\\\\",\n+\t\t\turl:                `/metadata/identity/\\oauth2\\token/`,\n+\t\t\texpectedStatusCode: http.StatusOK,\n+\t\t\texpectedBody:       \"invalid_request_handler\",\n+\t\t},\n+\t\t{\n+\t\t\tname:               \"invalid token request with multiple \\\\\",\n+\t\t\turl:                `/metadata/identity\\\\\\oauth2\\\\token/`,\n+\t\t\texpectedStatusCode: http.StatusOK,\n+\t\t\texpectedBody:       \"invalid_request_handler\",\n+\t\t},\n \t}\n \n \tfor _, test := range tests {\n@@ -225,6 +255,7 @@ func TestRouterPathPrefix(t *testing.T) {\n \t\t\tdefer teardown()\n \n \t\t\trtr.PathPrefix(tokenPathPrefix).HandlerFunc(testTokenHandler)\n+\t\t\trtr.MatcherFunc(invalidTokenPathMatcher).HandlerFunc(testInvalidRequestHandler)\n \t\t\trtr.PathPrefix(hostTokenPathPrefix).HandlerFunc(testHostTokenHandler)\n \t\t\trtr.PathPrefix(instancePathPrefix).HandlerFunc(testInstanceHandler)\n \t\t\trtr.PathPrefix(\"/\").HandlerFunc(testDefaultHandler)\n@@ -263,3 +294,7 @@ func testInstanceHandler(w http.ResponseWriter, r *http.Request) {\n func testDefaultHandler(w http.ResponseWriter, r *http.Request) {\n \tfmt.Fprintf(w, \"default_handler\\n\")\n }\n+\n+func testInvalidRequestHandler(w http.ResponseWriter, r *http.Request) {\n+\tfmt.Fprintf(w, \"invalid_request_handler\\n\")\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e4e7eab22ca44d110a05de46491948d365a63905",
            "date": "2023-10-02T20:34:21Z",
            "author_login": "aramase"
          },
          {
            "sha": "1cfffd4b992a14a1c1a98523f0234114e9610df5",
            "date": "2023-08-25T04:58:50Z",
            "author_login": "aramase"
          },
          {
            "sha": "d17ea6a41aed5284fda895d6d48f50cc5f9f175f",
            "date": "2023-06-16T15:54:24Z",
            "author_login": "aramase"
          },
          {
            "sha": "69befdf8b00a9d9a87279b222046647a720f9c12",
            "date": "2023-06-15T18:30:00Z",
            "author_login": "sozercan"
          },
          {
            "sha": "f8090f0305f198b19f0d4cb547a5695856afdcbc",
            "date": "2023-06-15T18:26:20Z",
            "author_login": "sozercan"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:H/UI:R/S:U/C:L/I:H/A:L",
    "cwe_id": "CWE-863",
    "description": "aad-pod-identity assigns Azure Active Directory identities to Kubernetes applications and has now been deprecated as of 24 October 2022. The NMI component in AAD Pod Identity intercepts and validates token requests based on regex. In this case, a token request made with backslash in the request (example: `/metadata/identity\\oauth2\\token/`) would bypass the NMI validation and be sent to IMDS allowing a pod in the cluster to access identities that it shouldn't have access to. This issue has been fixed and has been included in AAD Pod Identity release version 1.8.13. If using the AKS pod-managed identities add-on, no action is required. The clusters should now be running the version 1.8.13 release.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-12-21T20:15:09.490",
    "last_modified": "2024-11-21T06:48:47.733",
    "fix_date": "2022-10-03T17:29:05Z"
  },
  "references": [
    {
      "url": "https://github.com/Azure/aad-pod-identity/commit/7e01970391bde6c360d077066ca17d059204cb5d",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Azure/aad-pod-identity/releases/tag/v1.8.13",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Azure/aad-pod-identity/security/advisories/GHSA-p82q-rxpm-hjpc",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Azure/aad-pod-identity/commit/7e01970391bde6c360d077066ca17d059204cb5d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Azure/aad-pod-identity/releases/tag/v1.8.13",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Azure/aad-pod-identity/security/advisories/GHSA-p82q-rxpm-hjpc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:23.195524",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "aad-pod-identity",
    "owner": "Azure",
    "created_at": "2018-04-06T18:12:16Z",
    "updated_at": "2024-12-11T12:06:44Z",
    "pushed_at": "2023-10-02T20:34:21Z",
    "size": 20142,
    "stars": 566,
    "forks": 255,
    "open_issues": 0,
    "watchers": 566,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Go": 581689,
      "Shell": 11858,
      "Makefile": 9866,
      "Mustache": 4036,
      "HTML": 1568,
      "Dockerfile": 1226,
      "SCSS": 101
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T20:13:55.329674"
  }
}