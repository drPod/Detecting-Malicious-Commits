{
  "cve_id": "CVE-2022-23605",
  "github_data": {
    "repository": "wireapp/wire-webapp",
    "fix_commit": "42c9a1edddbdd5d4d8f9a196a98f6fc19bb21741",
    "related_commits": [
      "42c9a1edddbdd5d4d8f9a196a98f6fc19bb21741",
      "42c9a1edddbdd5d4d8f9a196a98f6fc19bb21741"
    ],
    "patch_url": "https://github.com/wireapp/wire-webapp/commit/42c9a1edddbdd5d4d8f9a196a98f6fc19bb21741.patch",
    "fix_commit_details": {
      "sha": "42c9a1edddbdd5d4d8f9a196a98f6fc19bb21741",
      "commit_date": "2022-01-27T18:18:37Z",
      "author": {
        "login": "comawill",
        "type": "User",
        "stats": {
          "total_commits": 29,
          "average_weekly_commits": 0.06531531531531531,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 18
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-2w3m-ppfg-hg62",
        "length": 90,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 74,
        "additions": 67,
        "deletions": 7
      },
      "files": [
        {
          "filename": "src/script/conversation/ConversationRepository.ts",
          "status": "modified",
          "additions": 24,
          "deletions": 3,
          "patch": "@@ -327,6 +327,8 @@ export class ConversationRepository {\n         this.deleteConversationFromRepository(conversationEntity);\n       }\n     });\n+\n+    this.cleanupEphemeralMessages();\n   }\n \n   //##############################################################################\n@@ -2747,17 +2749,29 @@ export class ConversationRepository {\n   }\n \n   /**\n-   * Convert multiple JSON events into entities and add them to a given conversation.\n+   * Convert multiple JSON events into entities and validate them\n    *\n    * @param events Event data\n    * @param conversationEntity Conversation entity the events will be added to\n-   * @param prepend Should existing messages be prepended\n    * @returns Resolves with an array of mapped messages\n    */\n-  private async addEventsToConversation(events: EventRecord[], conversationEntity: Conversation, prepend = true) {\n+  private async validateMessages(events: EventRecord[], conversationEntity: Conversation) {\n     const mappedEvents = await this.event_mapper.mapJsonEvents(events, conversationEntity);\n     const updatedEvents = (await this.updateMessagesUserEntities(mappedEvents)) as ContentMessage[];\n     const validatedMessages = (await this.ephemeralHandler.validateMessages(updatedEvents)) as ContentMessage[];\n+    return validatedMessages;\n+  }\n+\n+  /**\n+   * Convert multiple JSON events into entities, validate and add them to a given conversation.\n+   *\n+   * @param events Event data\n+   * @param conversationEntity Conversation entity the events will be added to\n+   * @param prepend Should existing messages be prepended\n+   * @returns Resolves with an array of mapped messages\n+   */\n+  private async addEventsToConversation(events: EventRecord[], conversationEntity: Conversation, prepend = true) {\n+    const validatedMessages = await this.validateMessages(events, conversationEntity);\n     if (prepend && conversationEntity.messages().length) {\n       conversationEntity.prependMessages(validatedMessages);\n     } else {\n@@ -2887,4 +2901,11 @@ export class ConversationRepository {\n \n     return false;\n   }\n+\n+  public async cleanupEphemeralMessages(): Promise<void> {\n+    this.conversationState.conversations().forEach(async conversationEntity => {\n+      const messages = (await this.eventService.loadEphemeralEvents(conversationEntity.id)) as EventRecord[];\n+      this.validateMessages(messages, conversationEntity);\n+    });\n+  }\n }"
        },
        {
          "filename": "src/script/conversation/ConversationService.ts",
          "status": "modified",
          "additions": 5,
          "deletions": 4,
          "patch": "@@ -476,12 +476,13 @@ export class ConversationService {\n    * @param query will be checked in against all text messages\n    * @returns Resolves with the matching events\n    */\n-  searchInConversation(conversation_id: string, query: string): Promise<any> {\n+  async searchInConversation(conversation_id: string, query: string): Promise<any> {\n     const category_min = MessageCategory.TEXT;\n     const category_max = MessageCategory.TEXT | MessageCategory.LINK | MessageCategory.LINK_PREVIEW;\n \n-    return this.eventService.loadEventsWithCategory(conversation_id, category_min, category_max).then(events => {\n-      return events.filter(({data: event_data}: any) => fullTextSearch(event_data.content, query));\n-    });\n+    const events = await this.eventService.loadEventsWithCategory(conversation_id, category_min, category_max);\n+    return events\n+      .filter(record => record.ephemeral_expires !== true)\n+      .filter(({data: event_data}: any) => fullTextSearch(event_data.content, query));\n   }\n }"
        },
        {
          "filename": "src/script/event/EventService.ts",
          "status": "modified",
          "additions": 38,
          "deletions": 0,
          "patch": "@@ -87,6 +87,34 @@ export class EventService {\n     }\n   }\n \n+  async loadEphemeralEvents(conversationId: string): Promise<EventRecord[]> {\n+    if (!conversationId) {\n+      this.logger.error(`Cannot get ephemeral events in conversation '${conversationId}' without ID`);\n+      throw new ConversationError(BASE_ERROR_TYPE.MISSING_PARAMETER, BaseError.MESSAGE.MISSING_PARAMETER);\n+    }\n+\n+    try {\n+      if (this.storageService.db) {\n+        const events = await this.storageService.db\n+          .table(StorageSchemata.OBJECT_STORE.EVENTS)\n+          .where('conversation')\n+          .equals(conversationId)\n+          .and(record => !!record.ephemeral_expires)\n+          .toArray();\n+        return events;\n+      }\n+\n+      const records = (await this.storageService.getAll(StorageSchemata.OBJECT_STORE.EVENTS)) as EventRecord[];\n+      return records\n+        .filter(record => record.conversation === conversationId && !!record.ephemeral_expires)\n+        .sort(compareEventsById);\n+    } catch (error) {\n+      const logMessage = `Failed to get ephemeral events for conversation '${conversationId}': ${error.message}`;\n+      this.logger.error(logMessage, error);\n+      throw error;\n+    }\n+  }\n+\n   /**\n    * Load event from database.\n    *\n@@ -134,11 +162,20 @@ export class EventService {\n     categoryMin: MessageCategory,\n     categoryMax = MessageCategory.LIKED,\n   ): Promise<DBEvents> {\n+    const filterExpired = (record: EventRecord) => {\n+      if (typeof record.ephemeral_expires !== 'undefined') {\n+        return +record.ephemeral_expires - Date.now() > 0;\n+      }\n+\n+      return true;\n+    };\n+\n     if (this.storageService.db) {\n       const events = await this.storageService.db\n         .table(StorageSchemata.OBJECT_STORE.EVENTS)\n         .where('[conversation+category]')\n         .between([conversationId, categoryMin], [conversationId, categoryMax], true, true)\n+        .and(filterExpired)\n         .sortBy('time');\n       return events;\n     }\n@@ -149,6 +186,7 @@ export class EventService {\n         record =>\n           record.conversation === conversationId && record.category >= categoryMin && record.category <= categoryMax,\n       )\n+      .filter(filterExpired)\n       .sort(compareEventsByTime);\n   }\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "54c1432194d842adf054ae1ffedd9acb087e0ae0",
            "date": "2025-01-14T09:32:56Z",
            "author_login": "olafsulich"
          },
          {
            "sha": "de37c669b558186ffdb1d1adb1ed29ffe339b43b",
            "date": "2025-01-14T09:22:36Z",
            "author_login": "przemvs"
          },
          {
            "sha": "549fed0e77350bd1b2f50d62f1ff766d314beb29",
            "date": "2025-01-14T08:16:18Z",
            "author_login": "przemvs"
          },
          {
            "sha": "105b1e241ebf033812a641586cad3c923eb4c5cd",
            "date": "2025-01-13T16:22:50Z",
            "author_login": "waseemansar"
          },
          {
            "sha": "641bdf1881f9f563fd870b1600cee4535df4cc89",
            "date": "2025-01-13T14:04:30Z",
            "author_login": "thisisamir98"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.4,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-212",
    "description": "Wire webapp is a web client for the wire messaging protocol. In versions prior to 2022-01-27-production.0 expired ephemeral messages were not reliably removed from local chat history of Wire Webapp. In versions before 2022-01-27-production.0 ephemeral messages and assets might still be accessible through the local search functionality. Any attempt to view one of these message in the chat view will then trigger the deletion. This issue only affects locally stored messages. On premise instances of wire-webapp need to be updated to 2022-01-27-production.0, so that their users are no longer affected. There are no known workarounds for this issue.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-02-04T23:15:15.567",
    "last_modified": "2024-11-21T06:48:54.933",
    "fix_date": "2022-01-27T18:18:37Z"
  },
  "references": [
    {
      "url": "https://github.com/wireapp/wire-webapp/commit/42c9a1edddbdd5d4d8f9a196a98f6fc19bb21741",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/wireapp/wire-webapp/security/advisories/GHSA-2w3m-ppfg-hg62",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/wireapp/wire-webapp/commit/42c9a1edddbdd5d4d8f9a196a98f6fc19bb21741",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/wireapp/wire-webapp/security/advisories/GHSA-2w3m-ppfg-hg62",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:57.143592",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "wire-webapp",
    "owner": "wireapp",
    "created_at": "2016-07-21T15:34:05Z",
    "updated_at": "2025-01-14T09:33:00Z",
    "pushed_at": "2025-01-14T13:27:24Z",
    "size": 183984,
    "stars": 1149,
    "forks": 292,
    "open_issues": 68,
    "watchers": 1149,
    "has_security_policy": false,
    "default_branch": "dev",
    "protected_branches": [],
    "languages": {
      "JavaScript": 7174442,
      "TypeScript": 5670689,
      "Less": 308396,
      "Shell": 16243,
      "HTML": 13071,
      "EJS": 10888,
      "CSS": 4737,
      "GLSL": 1710,
      "Mustache": 815,
      "Dockerfile": 320,
      "Procfile": 23
    },
    "commit_activity": {
      "total_commits_last_year": 1930,
      "avg_commits_per_week": 37.11538461538461,
      "days_active_last_year": 284
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-14T14:55:00.209124"
  }
}