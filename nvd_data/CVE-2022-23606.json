{
  "cve_id": "CVE-2022-23606",
  "github_data": {
    "repository": "envoyproxy/envoy",
    "fix_commit": "4b6dd3b53cd5c6d4d4df378a2fc62c1707522b31",
    "related_commits": [
      "4b6dd3b53cd5c6d4d4df378a2fc62c1707522b31",
      "4b6dd3b53cd5c6d4d4df378a2fc62c1707522b31"
    ],
    "patch_url": "https://github.com/envoyproxy/envoy/commit/4b6dd3b53cd5c6d4d4df378a2fc62c1707522b31.patch",
    "fix_commit_details": {
      "sha": "4b6dd3b53cd5c6d4d4df378a2fc62c1707522b31",
      "commit_date": "2022-02-01T19:33:02Z",
      "author": {
        "login": "yanavlasov",
        "type": "User",
        "stats": {
          "total_commits": 353,
          "average_weekly_commits": 0.800453514739229,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 163
        }
      },
      "commit_message": {
        "title": "CVE-2022-23606",
        "length": 233,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 243,
        "additions": 230,
        "deletions": 13
      },
      "files": [
        {
          "filename": "docs/root/version_history/current.rst",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -28,6 +28,7 @@ Bug Fixes\n * data plane: fixing error handling where writing to a socket failed while under the stack of processing. This should genreally affect HTTP/3. This behavioral change can be reverted by setting ``envoy.reloadable_features.allow_upstream_inline_write`` to false.\n * eds: fix the eds cluster update by allowing update on the locality of the cluster endpoints. This behavioral change can be temporarily reverted by setting runtime guard ``envoy.reloadable_features.support_locality_update_on_eds_cluster_endpoints`` to false.\n * tls: fix a bug while matching a certificate SAN with an exact value in ``match_typed_subject_alt_names`` of a listener where wildcard ``*`` character is not the only character of the dns label. Example, ``baz*.example.net`` and ``*baz.example.net`` and ``b*z.example.net`` will match ``baz1.example.net`` and ``foobaz.example.net`` and ``buzz.example.net``, respectively.\n+* upstream: fix stack overflow when a cluster with large number of idle connections is removed.\n * xray: fix the AWS X-Ray tracer extension to not sample the trace if ``sampled=`` keyword is not present in the header ``x-amzn-trace-id``.\n \n Removed Config or Runtime"
        },
        {
          "filename": "source/common/conn_pool/BUILD",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -14,6 +14,7 @@ envoy_cc_library(\n     hdrs = [\"conn_pool_base.h\"],\n     deps = [\n         \"//envoy/stats:timespan_interface\",\n+        \"//source/common/common:debug_recursion_checker_lib\",\n         \"//source/common/common:linked_object\",\n         \"//source/common/stats:timespan_lib\",\n         \"//source/common/upstream:upstream_lib\","
        },
        {
          "filename": "source/common/conn_pool/conn_pool_base.cc",
          "status": "modified",
          "additions": 21,
          "deletions": 6,
          "patch": "@@ -1,6 +1,7 @@\n #include \"source/common/conn_pool/conn_pool_base.h\"\n \n #include \"source/common/common/assert.h\"\n+#include \"source/common/common/debug_recursion_checker.h\"\n #include \"source/common/network/transport_socket_options_impl.h\"\n #include \"source/common/runtime/runtime_features.h\"\n #include \"source/common/stats/timespan_impl.h\"\n@@ -349,6 +350,8 @@ void ConnPoolImplBase::transitionActiveClientState(ActiveClient& client,\n void ConnPoolImplBase::addIdleCallbackImpl(Instance::IdleCb cb) { idle_callbacks_.push_back(cb); }\n \n void ConnPoolImplBase::closeIdleConnectionsForDrainingPool() {\n+  Common::AutoDebugRecursionChecker assert_not_in(recursion_checker_);\n+\n   // Create a separate list of elements to close to avoid mutate-while-iterating problems.\n   std::list<ActiveClient*> to_close;\n \n@@ -403,11 +406,7 @@ bool ConnPoolImplBase::isIdleImpl() const {\n          connecting_clients_.empty();\n }\n \n-void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n-  if (is_draining_for_deletion_) {\n-    closeIdleConnectionsForDrainingPool();\n-  }\n-\n+void ConnPoolImplBase::checkForIdleAndNotify() {\n   if (isIdleImpl()) {\n     ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n               is_draining_for_deletion_);\n@@ -417,6 +416,14 @@ void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n   }\n }\n \n+void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n+  if (is_draining_for_deletion_) {\n+    closeIdleConnectionsForDrainingPool();\n+  }\n+\n+  checkForIdleAndNotify();\n+}\n+\n void ConnPoolImplBase::onConnectionEvent(ActiveClient& client, absl::string_view failure_reason,\n                                          Network::ConnectionEvent event) {\n   if (client.state() == ActiveClient::State::CONNECTING) {\n@@ -487,7 +494,15 @@ void ConnPoolImplBase::onConnectionEvent(ActiveClient& client, absl::string_view\n \n     dispatcher_.deferredDelete(client.removeFromList(owningList(client.state())));\n \n-    checkForIdleAndCloseIdleConnsIfDraining();\n+    // Check if the pool transitioned to idle state after removing closed client\n+    // from one of the client tracking lists.\n+    // There is no need to check if other connections are idle in a draining pool\n+    // because the pool will close all idle connection when it is starting to\n+    // drain.\n+    // Trying to close other connections here can lead to deep recursion when\n+    // a large number idle connections are closed at the start of pool drain.\n+    // See CdsIntegrationTest.CdsClusterDownWithLotsOfIdleConnections for an example.\n+    checkForIdleAndNotify();\n \n     client.setState(ActiveClient::State::CLOSED);\n "
        },
        {
          "filename": "source/common/conn_pool/conn_pool_base.h",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -6,6 +6,7 @@\n #include \"envoy/stats/timespan.h\"\n #include \"envoy/upstream/cluster_manager.h\"\n \n+#include \"source/common/common/debug_recursion_checker.h\"\n #include \"source/common/common/dump_state_utils.h\"\n #include \"source/common/common/linked_object.h\"\n \n@@ -222,6 +223,9 @@ class ConnPoolImplBase : protected Logger::Loggable<Logger::Id::pool> {\n   void onConnectionEvent(ActiveClient& client, absl::string_view failure_reason,\n                          Network::ConnectionEvent event);\n \n+  // Check if the pool has gone idle and invoke idle notification callbacks.\n+  void checkForIdleAndNotify();\n+\n   // See if the pool has gone idle. If we're draining, this will also close idle connections.\n   void checkForIdleAndCloseIdleConnsIfDraining();\n \n@@ -371,6 +375,7 @@ class ConnPoolImplBase : protected Logger::Loggable<Logger::Id::pool> {\n   bool deferred_deleting_{false};\n \n   Event::SchedulableCallbackPtr upstream_ready_cb_;\n+  Common::DebugRecursionChecker recursion_checker_;\n };\n \n } // namespace ConnectionPool"
        },
        {
          "filename": "test/config/utility.cc",
          "status": "modified",
          "additions": 28,
          "deletions": 0,
          "patch": "@@ -442,6 +442,34 @@ envoy::config::cluster::v3::Cluster ConfigHelper::buildStaticCluster(const std::\n                   name, name, address, port, lb_policy));\n }\n \n+envoy::config::cluster::v3::Cluster ConfigHelper::buildH1ClusterWithHighCircuitBreakersLimits(\n+    const std::string& name, int port, const std::string& address, const std::string& lb_policy) {\n+  return TestUtility::parseYaml<envoy::config::cluster::v3::Cluster>(\n+      fmt::format(R\"EOF(\n+      name: {}\n+      connect_timeout: 50s\n+      type: STATIC\n+      circuit_breakers:\n+        thresholds:\n+        - priority: DEFAULT\n+          max_connections: 10000\n+          max_pending_requests: 10000\n+          max_requests: 10000\n+          max_retries: 10000\n+      load_assignment:\n+        cluster_name: {}\n+        endpoints:\n+        - lb_endpoints:\n+          - endpoint:\n+              address:\n+                socket_address:\n+                  address: {}\n+                  port_value: {}\n+      lb_policy: {}\n+    )EOF\",\n+                  name, name, address, port, lb_policy));\n+}\n+\n envoy::config::cluster::v3::Cluster ConfigHelper::buildCluster(const std::string& name,\n                                                                const std::string& lb_policy) {\n   API_NO_BOOST(envoy::config::cluster::v3::Cluster) cluster;"
        },
        {
          "filename": "test/config/utility.h",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -153,6 +153,11 @@ class ConfigHelper {\n   buildStaticCluster(const std::string& name, int port, const std::string& address,\n                      const std::string& lb_policy = \"ROUND_ROBIN\");\n \n+  static envoy::config::cluster::v3::Cluster\n+  buildH1ClusterWithHighCircuitBreakersLimits(const std::string& name, int port,\n+                                              const std::string& address,\n+                                              const std::string& lb_policy = \"ROUND_ROBIN\");\n+\n   // ADS configurations\n   static envoy::config::cluster::v3::Cluster\n   buildCluster(const std::string& name, const std::string& lb_policy = \"ROUND_ROBIN\");"
        },
        {
          "filename": "test/integration/BUILD",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -110,10 +110,12 @@ envoy_proto_library(\n \n envoy_cc_test(\n     name = \"cds_integration_test\",\n+    size = \"large\",\n     srcs = [\"cds_integration_test.cc\"],\n     data = [\n         \"//test/config/integration/certs\",\n     ],\n+    shard_count = 4,\n     deps = [\n         \":http_integration_lib\",\n         \"//source/common/config:protobuf_link_hacks\","
        },
        {
          "filename": "test/integration/cds_integration_test.cc",
          "status": "modified",
          "additions": 167,
          "deletions": 7,
          "patch": "@@ -37,7 +37,8 @@ class CdsIntegrationTest : public Grpc::DeltaSotwIntegrationParamTest, public Ht\n                                 sotwOrDelta() == Grpc::SotwOrDelta::Sotw ||\n                                         sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw\n                                     ? \"GRPC\"\n-                                    : \"DELTA_GRPC\")) {\n+                                    : \"DELTA_GRPC\")),\n+        cluster_creator_(&ConfigHelper::buildStaticCluster) {\n     if (sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw ||\n         sotwOrDelta() == Grpc::SotwOrDelta::UnifiedDelta) {\n       config_helper_.addRuntimeOverride(\"envoy.reloadable_features.unified_mux\", \"true\");\n@@ -79,14 +80,14 @@ class CdsIntegrationTest : public Grpc::DeltaSotwIntegrationParamTest, public Ht\n     // Create the regular (i.e. not an xDS server) upstreams. We create them manually here after\n     // initialize() because finalize() expects all fake_upstreams_ to correspond to a static\n     // cluster in the bootstrap config - which we don't want since we're testing dynamic CDS!\n-    addFakeUpstream(Http::CodecType::HTTP2);\n-    addFakeUpstream(Http::CodecType::HTTP2);\n-    cluster1_ = ConfigHelper::buildStaticCluster(\n+    addFakeUpstream(upstream_codec_type_);\n+    addFakeUpstream(upstream_codec_type_);\n+    cluster1_ = cluster_creator_(\n         ClusterName1, fake_upstreams_[UpstreamIndex1]->localAddress()->ip()->port(),\n-        Network::Test::getLoopbackAddressString(ipVersion()));\n-    cluster2_ = ConfigHelper::buildStaticCluster(\n+        Network::Test::getLoopbackAddressString(ipVersion()), \"ROUND_ROBIN\");\n+    cluster2_ = cluster_creator_(\n         ClusterName2, fake_upstreams_[UpstreamIndex2]->localAddress()->ip()->port(),\n-        Network::Test::getLoopbackAddressString(ipVersion()));\n+        Network::Test::getLoopbackAddressString(ipVersion()), \"ROUND_ROBIN\");\n \n     // Let Envoy establish its connection to the CDS server.\n     acceptXdsConnection();\n@@ -133,6 +134,10 @@ class CdsIntegrationTest : public Grpc::DeltaSotwIntegrationParamTest, public Ht\n   envoy::config::cluster::v3::Cluster cluster2_;\n   // True if we decided not to run the test after all.\n   bool test_skipped_{true};\n+  Http::CodecType upstream_codec_type_{Http::CodecType::HTTP2};\n+  std::function<envoy::config::cluster::v3::Cluster(const std::string&, int, const std::string&,\n+                                                    const std::string&)>\n+      cluster_creator_;\n };\n \n INSTANTIATE_TEST_SUITE_P(IpVersionsClientTypeDelta, CdsIntegrationTest,\n@@ -343,5 +348,160 @@ TEST_P(CdsIntegrationTest, VersionsRememberedAfterReconnect) {\n   ASSERT_TRUE(codec_client_->waitForDisconnect());\n }\n \n+// This test verifies that Envoy can delete a cluster with a lot of idle connections.\n+// The original problem was recursive closure of idle connections that can run out\n+// of stack when there are a lot of idle connections.\n+TEST_P(CdsIntegrationTest, CdsClusterDownWithLotsOfIdleConnections) {\n+  constexpr int num_requests = 2000;\n+  // Make upstream H/1 so it creates connection for each request\n+  upstream_codec_type_ = Http::CodecType::HTTP1;\n+  // Relax default circuit breaker limits and timeouts so Envoy can accumulate a lot of idle\n+  // connections\n+  cluster_creator_ = &ConfigHelper::buildH1ClusterWithHighCircuitBreakersLimits;\n+  config_helper_.addConfigModifier(\n+      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n+              hcm) -> void {\n+        hcm.mutable_route_config()\n+            ->mutable_virtual_hosts(0)\n+            ->mutable_routes(0)\n+            ->mutable_route()\n+            ->mutable_timeout()\n+            ->set_seconds(600);\n+        hcm.mutable_route_config()\n+            ->mutable_virtual_hosts(0)\n+            ->mutable_routes(0)\n+            ->mutable_route()\n+            ->mutable_idle_timeout()\n+            ->set_seconds(600);\n+      });\n+  initialize();\n+  std::vector<IntegrationStreamDecoderPtr> responses;\n+  std::vector<FakeHttpConnectionPtr> upstream_connections;\n+  std::vector<FakeStreamPtr> upstream_requests;\n+  codec_client_ = makeHttpConnection(makeClientConnection((lookupPort(\"http\"))));\n+  // The first loop establishes a lot of open connections with active requests to upstream\n+  for (int i = 0; i < num_requests; ++i) {\n+    Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"GET\"},\n+                                                   {\":path\", \"/cluster1\"},\n+                                                   {\":scheme\", \"http\"},\n+                                                   {\":authority\", \"host\"},\n+                                                   {\"x-lyft-user-id\", absl::StrCat(i)}};\n+\n+    auto response = codec_client_->makeHeaderOnlyRequest(request_headers);\n+    responses.push_back(std::move(response));\n+\n+    FakeHttpConnectionPtr fake_upstream_connection;\n+    waitForNextUpstreamConnection({UpstreamIndex1}, TestUtility::DefaultTimeout,\n+                                  fake_upstream_connection);\n+    // Wait for the next stream on the upstream connection.\n+    FakeStreamPtr upstream_request;\n+    AssertionResult result =\n+        fake_upstream_connection->waitForNewStream(*dispatcher_, upstream_request);\n+    RELEASE_ASSERT(result, result.message());\n+    // Wait for the stream to be completely received.\n+    result = upstream_request->waitForEndStream(*dispatcher_);\n+    RELEASE_ASSERT(result, result.message());\n+    upstream_connections.push_back(std::move(fake_upstream_connection));\n+    upstream_requests.push_back(std::move(upstream_request));\n+  }\n+\n+  // This loop completes all requests making the all upstream connections idle\n+  for (int i = 0; i < num_requests; ++i) {\n+    // Send response headers, and end_stream if there is no response body.\n+    upstream_requests[i]->encodeHeaders(default_response_headers_, true);\n+    // Wait for the response to be read by the codec client.\n+    RELEASE_ASSERT(responses[i]->waitForEndStream(), \"unexpected timeout\");\n+    ASSERT_TRUE(responses[i]->complete());\n+    EXPECT_EQ(\"200\", responses[i]->headers().getStatusValue());\n+  }\n+\n+  test_server_->waitForCounterGe(\"cluster_manager.cluster_added\", 1);\n+\n+  // Tell Envoy that cluster_1 is gone. Envoy will try to close all idle connections\n+  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"55\", {}, {}, {}));\n+  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster, {}, {},\n+                                                             {ClusterName1}, \"42\");\n+  // We can continue the test once we're sure that Envoy's ClusterManager has made use of\n+  // the DiscoveryResponse that says cluster_1 is gone.\n+  test_server_->waitForCounterGe(\"cluster_manager.cluster_removed\", 1);\n+\n+  // If we made it this far then everything is ok.\n+  for (int i = 0; i < num_requests; ++i) {\n+    AssertionResult result = upstream_connections[i]->close();\n+    RELEASE_ASSERT(result, result.message());\n+    result = upstream_connections[i]->waitForDisconnect();\n+    RELEASE_ASSERT(result, result.message());\n+  }\n+  upstream_connections.clear();\n+  cleanupUpstreamAndDownstream();\n+  ASSERT_TRUE(codec_client_->waitForDisconnect());\n+}\n+\n+// This test verifies that Envoy can delete a cluster with a lot of connections in the connecting\n+// state and associated pending requests. The recursion guard in the\n+// ConnPoolImplBase::closeIdleConnectionsForDrainingPool() would fire if it was called recursively.\n+//\n+// Test is currently disabled as there is presently no reliable way of making upstream connections\n+// hang in connecting state.\n+TEST_P(CdsIntegrationTest, DISABLED_CdsClusterDownWithLotsOfConnectingConnections) {\n+  // Use low number of pending connections to prevent bumping into the default\n+  // limit of 128, since the upstream will be prevented below from\n+  // accepting connections.\n+  constexpr int num_requests = 64;\n+  // Make upstream H/1 so it creates connection for each request\n+  upstream_codec_type_ = Http::CodecType::HTTP1;\n+  cluster_creator_ = &ConfigHelper::buildH1ClusterWithHighCircuitBreakersLimits;\n+  config_helper_.addConfigModifier(\n+      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n+              hcm) -> void {\n+        hcm.mutable_route_config()\n+            ->mutable_virtual_hosts(0)\n+            ->mutable_routes(0)\n+            ->mutable_route()\n+            ->mutable_timeout()\n+            ->set_seconds(600);\n+        hcm.mutable_route_config()\n+            ->mutable_virtual_hosts(0)\n+            ->mutable_routes(0)\n+            ->mutable_route()\n+            ->mutable_idle_timeout()\n+            ->set_seconds(600);\n+      });\n+  initialize();\n+  test_server_->waitForCounterGe(\"cluster_manager.cluster_added\", 1);\n+  std::vector<IntegrationStreamDecoderPtr> responses;\n+  codec_client_ = makeHttpConnection(makeClientConnection((lookupPort(\"http\"))));\n+  // Stop upstream at UpstreamIndex1 dispatcher, to prevent it from accepting TCP connections.\n+  // This will cause Envoy's connections to that upstream hang in the connecting state.\n+  fake_upstreams_[UpstreamIndex1]->dispatcher()->exit();\n+  for (int i = 0; i < num_requests; ++i) {\n+    Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"GET\"},\n+                                                   {\":path\", \"/cluster1\"},\n+                                                   {\":scheme\", \"http\"},\n+                                                   {\":authority\", \"host\"},\n+                                                   {\"x-lyft-user-id\", absl::StrCat(i)}};\n+\n+    auto response = codec_client_->makeHeaderOnlyRequest(request_headers);\n+    responses.push_back(std::move(response));\n+  }\n+\n+  // Wait for Envoy to try to establish all expected connections\n+  test_server_->waitForCounterEq(\"cluster.cluster_1.upstream_cx_total\", num_requests);\n+\n+  // Tell Envoy that cluster_1 is gone. Envoy will try to close all pending connections\n+  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"55\", {}, {}, {}));\n+  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster, {}, {},\n+                                                             {ClusterName1}, \"42\");\n+  // We can continue the test once we're sure that Envoy's ClusterManager has made use of\n+  // the DiscoveryResponse that says cluster_1 is gone.\n+  test_server_->waitForCounterGe(\"cluster_manager.cluster_removed\", 1);\n+\n+  cleanupUpstreamAndDownstream();\n+  ASSERT_TRUE(codec_client_->waitForDisconnect());\n+  // If we got here it means that the recursion guard in the\n+  // ConnPoolImplBase::closeIdleConnectionsForDrainingPool() did not fire, which is what this test\n+  // validates.\n+}\n+\n } // namespace\n } // namespace Envoy"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "a5cf609225dfd223ec734cdc2d9a2cb33e58cacc",
            "date": "2025-01-14T20:58:08Z",
            "author_login": "phlax"
          },
          {
            "sha": "b0f43d67aa25c1b03c97186a200cc187f4c22db3",
            "date": "2025-01-14T17:27:17Z",
            "author_login": "publish-envoy[bot]"
          },
          {
            "sha": "c93cf7af47f7e24c83b563d3b956074333bc4bf7",
            "date": "2025-01-14T17:23:07Z",
            "author_login": "phlax"
          },
          {
            "sha": "078dae3549912e632c3776a5e9a4679226093276",
            "date": "2025-01-14T14:27:08Z",
            "author_login": "agrawroh"
          },
          {
            "sha": "7b20933ee263eb9aeaceee6bc309b80b997cbbb2",
            "date": "2025-01-14T14:13:49Z",
            "author_login": "phlax"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-674",
    "description": "Envoy is an open source edge and service proxy, designed for cloud-native applications. When a cluster is deleted via Cluster Discovery Service (CDS) all idle connections established to endpoints in that cluster are disconnected. A recursion was introduced in the procedure of disconnecting idle connections that can lead to stack exhaustion and abnormal process termination when a cluster has a large number of idle connections. This infinite recursion causes Envoy to crash. Users are advised to upgrade.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-02-22T23:15:11.337",
    "last_modified": "2024-11-21T06:48:55.100",
    "fix_date": "2022-02-01T19:33:02Z"
  },
  "references": [
    {
      "url": "https://github.com/envoyproxy/envoy/commit/4b6dd3b53cd5c6d4d4df378a2fc62c1707522b31",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-9vp2-4cp7-vvxf",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/commit/4b6dd3b53cd5c6d4d4df378a2fc62c1707522b31",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-9vp2-4cp7-vvxf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:59.741145",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "envoy",
    "owner": "envoyproxy",
    "created_at": "2016-08-08T15:07:24Z",
    "updated_at": "2025-01-14T12:22:22Z",
    "pushed_at": "2025-01-14T05:36:17Z",
    "size": 240648,
    "stars": 25321,
    "forks": 4848,
    "open_issues": 1639,
    "watchers": 25321,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C++": 48293036,
      "Starlark": 3105942,
      "Java": 1320095,
      "Python": 605206,
      "Assembly": 327095,
      "Kotlin": 309606,
      "Swift": 250537,
      "Shell": 229801,
      "Go": 183281,
      "Rust": 107190,
      "JavaScript": 66339,
      "C": 61597,
      "Objective-C++": 55490,
      "Objective-C": 48840,
      "Jinja": 47798,
      "Smarty": 3528,
      "CSS": 2927,
      "HTML": 1522,
      "Emacs Lisp": 966,
      "Dockerfile": 960,
      "Thrift": 748,
      "PureBasic": 472,
      "Batchfile": 439,
      "Makefile": 303
    },
    "commit_activity": {
      "total_commits_last_year": 3286,
      "avg_commits_per_week": 63.19230769230769,
      "days_active_last_year": 303
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:55:59.245540"
  }
}