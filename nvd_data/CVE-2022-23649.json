{
  "cve_id": "CVE-2022-23649",
  "github_data": {
    "repository": "sigstore/cosign",
    "fix_commit": "96d410a6580e4e81d24d112a0855c70ca3fb5b49",
    "related_commits": [
      "96d410a6580e4e81d24d112a0855c70ca3fb5b49",
      "96d410a6580e4e81d24d112a0855c70ca3fb5b49"
    ],
    "patch_url": "https://github.com/sigstore/cosign/commit/96d410a6580e4e81d24d112a0855c70ca3fb5b49.patch",
    "fix_commit_details": {
      "sha": "96d410a6580e4e81d24d112a0855c70ca3fb5b49",
      "commit_date": "2022-02-18T19:40:01Z",
      "author": {
        "login": "nsmith5",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-ccxc-vr6p-4858",
        "length": 605,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 232,
        "additions": 226,
        "deletions": 6
      },
      "files": [
        {
          "filename": "cmd/cosign/cli/verify/verify.go",
          "status": "modified",
          "additions": 13,
          "deletions": 4,
          "patch": "@@ -146,13 +146,20 @@ func (c *VerifyCommand) Exec(ctx context.Context, images []string) (err error) {\n \t}\n \tco.SigVerifier = pubKey\n \n+\t// NB: There are only 2 kinds of verification right now:\n+\t// 1. You gave us the public key explicitly to verify against so co.SigVerifier is non-nil or,\n+\t// 2. We're going to find an x509 certificate on the signature and verify against Fulcio root trust\n+\t// TODO(nsmith5): Refactor this verification logic to pass back _how_ verification\n+\t// was performed so we don't need to use this fragile logic here.\n+\tfulcioVerified := (co.SigVerifier == nil)\n+\n \tfor _, img := range images {\n \t\tif c.LocalImage {\n \t\t\tverified, bundleVerified, err := cosign.VerifyLocalImageSignatures(ctx, img, co)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n-\t\t\tPrintVerificationHeader(img, co, bundleVerified)\n+\t\t\tPrintVerificationHeader(img, co, bundleVerified, fulcioVerified)\n \t\t\tPrintVerification(img, verified, c.Output)\n \t\t} else {\n \t\t\tref, err := name.ParseReference(img)\n@@ -169,15 +176,15 @@ func (c *VerifyCommand) Exec(ctx context.Context, images []string) (err error) {\n \t\t\t\treturn err\n \t\t\t}\n \n-\t\t\tPrintVerificationHeader(ref.Name(), co, bundleVerified)\n+\t\t\tPrintVerificationHeader(ref.Name(), co, bundleVerified, fulcioVerified)\n \t\t\tPrintVerification(ref.Name(), verified, c.Output)\n \t\t}\n \t}\n \n \treturn nil\n }\n \n-func PrintVerificationHeader(imgRef string, co *cosign.CheckOpts, bundleVerified bool) {\n+func PrintVerificationHeader(imgRef string, co *cosign.CheckOpts, bundleVerified, fulcioVerified bool) {\n \tfmt.Fprintf(os.Stderr, \"\\nVerification for %s --\\n\", imgRef)\n \tfmt.Fprintln(os.Stderr, \"The following checks were performed on each of these signatures:\")\n \tif co.ClaimVerifier != nil {\n@@ -195,7 +202,9 @@ func PrintVerificationHeader(imgRef string, co *cosign.CheckOpts, bundleVerified\n \tif co.SigVerifier != nil {\n \t\tfmt.Fprintln(os.Stderr, \"  - The signatures were verified against the specified public key\")\n \t}\n-\tfmt.Fprintln(os.Stderr, \"  - Any certificates were verified against the Fulcio roots.\")\n+\tif fulcioVerified {\n+\t\tfmt.Fprintln(os.Stderr, \"  - Any certificates were verified against the Fulcio roots.\")\n+\t}\n }\n \n // PrintVerification logs details about the verification to stdout"
        },
        {
          "filename": "cmd/cosign/cli/verify/verify_attestation.go",
          "status": "modified",
          "additions": 8,
          "deletions": 1,
          "patch": "@@ -127,6 +127,13 @@ func (c *VerifyAttestationCommand) Exec(ctx context.Context, images []string) (e\n \t\t}\n \t}\n \n+\t// NB: There are only 2 kinds of verification right now:\n+\t// 1. You gave us the public key explicitly to verify against so co.SigVerifier is non-nil or,\n+\t// 2. We're going to find an x509 certificate on the signature and verify against Fulcio root trust\n+\t// TODO(nsmith5): Refactor this verification logic to pass back _how_ verification\n+\t// was performed so we don't need to use this fragile logic here.\n+\tfulcioVerified := (co.SigVerifier == nil)\n+\n \tfor _, imageRef := range images {\n \t\tvar verified []oci.Signature\n \t\tvar bundleVerified bool\n@@ -267,7 +274,7 @@ func (c *VerifyAttestationCommand) Exec(ctx context.Context, images []string) (e\n \t\t}\n \n \t\t// TODO: add CUE validation report to `PrintVerificationHeader`.\n-\t\tPrintVerificationHeader(imageRef, co, bundleVerified)\n+\t\tPrintVerificationHeader(imageRef, co, bundleVerified, fulcioVerified)\n \t\t// The attestations are always JSON, so use the raw \"text\" mode for outputting them instead of conversion\n \t\tPrintVerification(imageRef, verified, \"text\")\n \t}"
        },
        {
          "filename": "pkg/cosign/verify.go",
          "status": "modified",
          "additions": 67,
          "deletions": 0,
          "patch": "@@ -586,6 +586,10 @@ func VerifyBundle(ctx context.Context, sig oci.Signature) (bool, error) {\n \t\treturn false, nil\n \t}\n \n+\tif err := compareSigs(bundle.Payload.Body.(string), sig); err != nil {\n+\t\treturn false, err\n+\t}\n+\n \tpublicKeys, err := GetRekorPubs(ctx)\n \tif err != nil {\n \t\treturn false, errors.Wrap(err, \"retrieving rekor public key\")\n@@ -637,6 +641,31 @@ func VerifyBundle(ctx context.Context, sig oci.Signature) (bool, error) {\n \treturn true, nil\n }\n \n+// compare bundle signature to the signature we are verifying\n+func compareSigs(bundleBody string, sig oci.Signature) error {\n+\t// TODO(nsmith5): modify function signature to make it more clear _why_\n+\t// we've returned nil (there are several reasons possible here).\n+\tactualSig, err := sig.Base64Signature()\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"base64 signature\")\n+\t}\n+\tif actualSig == \"\" {\n+\t\t// NB: empty sig means this is an attestation\n+\t\treturn nil\n+\t}\n+\tbundleSignature, err := bundleSig(bundleBody)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"failed to extract signature from bundle\")\n+\t}\n+\tif bundleSignature == \"\" {\n+\t\treturn nil\n+\t}\n+\tif bundleSignature != actualSig {\n+\t\treturn fmt.Errorf(\"signature in bundle does not match signature being verified\")\n+\t}\n+\treturn nil\n+}\n+\n func bundleHash(bundleBody, signature string) (string, string, error) {\n \tvar toto models.Intoto\n \tvar rekord models.Rekord\n@@ -698,6 +727,44 @@ func bundleHash(bundleBody, signature string) (string, string, error) {\n \treturn *hrekordObj.Data.Hash.Algorithm, *hrekordObj.Data.Hash.Value, nil\n }\n \n+// bundleSig extracts the signature from the rekor bundle body\n+func bundleSig(bundleBody string) (string, error) {\n+\tvar rekord models.Rekord\n+\tvar hrekord models.Hashedrekord\n+\tvar rekordObj models.RekordV001Schema\n+\tvar hrekordObj models.HashedrekordV001Schema\n+\n+\tbodyDecoded, err := base64.StdEncoding.DecodeString(bundleBody)\n+\tif err != nil {\n+\t\treturn \"\", errors.Wrap(err, \"decoding bundleBody\")\n+\t}\n+\n+\t// Try Rekord\n+\tif err := json.Unmarshal(bodyDecoded, &rekord); err == nil {\n+\t\tspecMarshal, err := json.Marshal(rekord.Spec)\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tif err := json.Unmarshal(specMarshal, &rekordObj); err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\treturn rekordObj.Signature.Content.String(), nil\n+\t}\n+\n+\t// Try hashedRekordObj\n+\tif err := json.Unmarshal(bodyDecoded, &hrekord); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tspecMarshal, err := json.Marshal(hrekord.Spec)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif err := json.Unmarshal(specMarshal, &hrekordObj); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn hrekordObj.Signature.Content.String(), nil\n+}\n+\n func VerifySET(bundlePayload cbundle.RekorPayload, signature []byte, pub *ecdsa.PublicKey) error {\n \tcontents, err := json.Marshal(bundlePayload)\n \tif err != nil {"
        },
        {
          "filename": "pkg/cosign/verify_test.go",
          "status": "modified",
          "additions": 38,
          "deletions": 0,
          "patch": "@@ -26,6 +26,7 @@ import (\n \t\"github.com/in-toto/in-toto-golang/in_toto\"\n \t\"github.com/pkg/errors\"\n \t\"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n+\t\"github.com/sigstore/cosign/pkg/oci/static\"\n \t\"github.com/sigstore/cosign/pkg/types\"\n \t\"github.com/sigstore/cosign/test\"\n \t\"github.com/sigstore/sigstore/pkg/signature\"\n@@ -196,3 +197,40 @@ func TestValidateAndUnpackCertInvalidEmail(t *testing.T) {\n \t_, err := ValidateAndUnpackCert(leafCert, co)\n \trequire.Contains(t, err.Error(), \"expected email not found in certificate\")\n }\n+\n+func TestCompareSigs(t *testing.T) {\n+\t//TODO(nsmith5): Add test cases for invalid signature, missing signature etc\n+\ttests := []struct {\n+\t\tdescription string\n+\t\tb64sig      string\n+\t\tbundleBody  string\n+\t\tshouldErr   bool\n+\t}{\n+\t\t{\n+\t\t\tdescription: \"sigs match\",\n+\t\t\tb64sig:      \"MEQCIDO3XHbLovPWK+bk8ItCig2cwlr/8MXbLvz3UFzxMGIMAiA1lqdM9IqqUvCUqzOjufTq3sKU3qSn7R5tPqPz0ddNwQ==\",\n+\t\t\tbundleBody:  `eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoiaGFzaGVkcmVrb3JkIiwic3BlYyI6eyJkYXRhIjp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiIzODE1MmQxZGQzMjZhZjQwNWY4OTlkYmNjMmNlMzUwYjVmMTZkNDVkZjdmMjNjNDg4ZjQ4NTBhZmExY2Q4NmQxIn19LCJzaWduYXR1cmUiOnsiY29udGVudCI6Ik1FUUNJRE8zWEhiTG92UFdLK2JrOEl0Q2lnMmN3bHIvOE1YYkx2ejNVRnp4TUdJTUFpQTFscWRNOUlxcVV2Q1Vxek9qdWZUcTNzS1UzcVNuN1I1dFBxUHowZGROd1E9PSIsInB1YmxpY0tleSI6eyJjb250ZW50IjoiTFMwdExTMUNSVWRKVGlCUVZVSk1TVU1nUzBWWkxTMHRMUzBLVFVacmQwVjNXVWhMYjFwSmVtb3dRMEZSV1VsTGIxcEplbW93UkVGUlkwUlJaMEZGVUN0RVIyb3ZXWFV4VG5vd01XVjVSV2hVZDNRMlQya3hXV3BGWXdwSloxRldjRlZTTjB0bUwwSm1hVk16Y1ZReFVHd3dkbGh3ZUZwNVMyWkpSMHMyZWxoQ04ybE5aV3RFVTA1M1dHWldPSEpKYUdaMmRrOW5QVDBLTFMwdExTMUZUa1FnVUZWQ1RFbERJRXRGV1MwdExTMHRDZz09In19fX0=`,\n+\t\t},\n+\t\t{\n+\t\t\tdescription: \"sigs don't match\",\n+\t\t\tb64sig:      \"bm9wZQo=\",\n+\t\t\tbundleBody:  `eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoiaGFzaGVkcmVrb3JkIiwic3BlYyI6eyJkYXRhIjp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiIzODE1MmQxZGQzMjZhZjQwNWY4OTlkYmNjMmNlMzUwYjVmMTZkNDVkZjdmMjNjNDg4ZjQ4NTBhZmExY2Q4NmQxIn19LCJzaWduYXR1cmUiOnsiY29udGVudCI6Ik1FUUNJRE8zWEhiTG92UFdLK2JrOEl0Q2lnMmN3bHIvOE1YYkx2ejNVRnp4TUdJTUFpQTFscWRNOUlxcVV2Q1Vxek9qdWZUcTNzS1UzcVNuN1I1dFBxUHowZGROd1E9PSIsInB1YmxpY0tleSI6eyJjb250ZW50IjoiTFMwdExTMUNSVWRKVGlCUVZVSk1TVU1nUzBWWkxTMHRMUzBLVFVacmQwVjNXVWhMYjFwSmVtb3dRMEZSV1VsTGIxcEplbW93UkVGUlkwUlJaMEZGVUN0RVIyb3ZXWFV4VG5vd01XVjVSV2hVZDNRMlQya3hXV3BGWXdwSloxRldjRlZTTjB0bUwwSm1hVk16Y1ZReFVHd3dkbGh3ZUZwNVMyWkpSMHMyZWxoQ04ybE5aV3RFVTA1M1dHWldPSEpKYUdaMmRrOW5QVDBLTFMwdExTMUZUa1FnVUZWQ1RFbERJRXRGV1MwdExTMHRDZz09In19fX0=`,\n+\t\t\tshouldErr:   true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.description, func(t *testing.T) {\n+\t\t\tsig, err := static.NewSignature([]byte(\"payload\"), test.b64sig)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"failed to create static signature: %v\", err)\n+\t\t\t}\n+\t\t\terr = compareSigs(test.bundleBody, sig)\n+\t\t\tif err == nil && test.shouldErr {\n+\t\t\t\tt.Fatal(\"test should have errored\")\n+\t\t\t}\n+\t\t\tif err != nil && !test.shouldErr {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t})\n+\t}\n+}"
        },
        {
          "filename": "pkg/sget/sget.go",
          "status": "modified",
          "additions": 8,
          "deletions": 1,
          "patch": "@@ -83,13 +83,20 @@ func (sg *SecureGet) Do(ctx context.Context) error {\n \t}\n \n \tif co.SigVerifier != nil || options.EnableExperimental() {\n+\t\t// NB: There are only 2 kinds of verification right now:\n+\t\t// 1. You gave us the public key explicitly to verify against so co.SigVerifier is non-nil or,\n+\t\t// 2. We're going to find an x509 certificate on the signature and verify against Fulcio root trust\n+\t\t// TODO(nsmith5): Refactor this verification logic to pass back _how_ verification\n+\t\t// was performed so we don't need to use this fragile logic here.\n+\t\tfulcioVerified := (co.SigVerifier == nil)\n+\n \t\tco.RootCerts = fulcio.GetRoots()\n \n \t\tsp, bundleVerified, err := cosign.VerifyImageSignatures(ctx, ref, co)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tverify.PrintVerificationHeader(sg.ImageRef, co, bundleVerified)\n+\t\tverify.PrintVerificationHeader(sg.ImageRef, co, bundleVerified, fulcioVerified)\n \t\tverify.PrintVerification(sg.ImageRef, sp, \"text\")\n \t}\n "
        },
        {
          "filename": "test/e2e_test.go",
          "status": "modified",
          "additions": 92,
          "deletions": 0,
          "patch": "@@ -55,6 +55,7 @@ import (\n \t\"github.com/sigstore/cosign/pkg/cosign\"\n \t\"github.com/sigstore/cosign/pkg/cosign/kubernetes\"\n \tcremote \"github.com/sigstore/cosign/pkg/cosign/remote\"\n+\t\"github.com/sigstore/cosign/pkg/oci/mutate\"\n \tociremote \"github.com/sigstore/cosign/pkg/oci/remote\"\n \t\"github.com/sigstore/cosign/pkg/sget\"\n \tsigs \"github.com/sigstore/cosign/pkg/signature\"\n@@ -1156,3 +1157,94 @@ func registryClientOpts(ctx context.Context) []remote.Option {\n \t\tremote.WithContext(ctx),\n \t}\n }\n+\n+// If a signature has a bundle, but *not for that signature*, cosign verification should fail\n+// This test is pretty long, so here are the basic points:\n+//    1. Sign image1 with a keypair, store entry in rekor\n+//    2. Sign image2 with keypair, DO NOT store entry in rekor\n+//    3. Take the bundle from image1 and store it on the signature in image2\n+//    4. Verification of image2 should now fail, since the bundle is for a different signature\n+func TestInvalidBundle(t *testing.T) {\n+\tregName, stop := reg(t)\n+\tdefer stop()\n+\ttd := t.TempDir()\n+\n+\timg1 := path.Join(regName, \"cosign-e2e\")\n+\n+\timgRef, _, cleanup := mkimage(t, img1)\n+\tdefer cleanup()\n+\n+\t_, privKeyPath, pubKeyPath := keypair(t, td)\n+\n+\tctx := context.Background()\n+\n+\t// Sign image1 and store the entry in rekor\n+\t// (we're just using it for its bundle)\n+\tdefer setenv(t, options.ExperimentalEnv, \"1\")()\n+\tremoteOpts := ociremote.WithRemoteOptions(registryClientOpts(ctx)...)\n+\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc, RekorURL: rekorURL}\n+\tregOpts := options.RegistryOptions{}\n+\n+\tmust(sign.SignCmd(ro, ko, regOpts, nil, []string{img1}, \"\", true, \"\", \"\", \"\", true, false, \"\"), t)\n+\t// verify image1\n+\tmust(verify(pubKeyPath, img1, true, nil, \"\"), t)\n+\t// extract the bundle from image1\n+\tsi, err := ociremote.SignedImage(imgRef, remoteOpts)\n+\tmust(err, t)\n+\timgSigs, err := si.Signatures()\n+\tmust(err, t)\n+\tsigs, err := imgSigs.Get()\n+\tmust(err, t)\n+\tif l := len(sigs); l != 1 {\n+\t\tt.Error(\"expected one signature\")\n+\t}\n+\tbund, err := sigs[0].Bundle()\n+\tmust(err, t)\n+\tif bund == nil {\n+\t\tt.Fail()\n+\t}\n+\n+\t// Now, we move on to image2\n+\t// Sign image2 and DO NOT store the entry in rekor\n+\tdefer setenv(t, options.ExperimentalEnv, \"0\")()\n+\timg2 := path.Join(regName, \"unrelated\")\n+\timgRef2, _, cleanup := mkimage(t, img2)\n+\tdefer cleanup()\n+\tmust(sign.SignCmd(ro, ko, regOpts, nil, []string{img2}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n+\tmust(verify(pubKeyPath, img2, true, nil, \"\"), t)\n+\n+\tsi2, err := ociremote.SignedEntity(imgRef2, remoteOpts)\n+\tmust(err, t)\n+\tsigs2, err := si2.Signatures()\n+\tmust(err, t)\n+\tgottenSigs2, err := sigs2.Get()\n+\tmust(err, t)\n+\tif len(gottenSigs2) != 1 {\n+\t\tt.Fatal(\"there should be one signature\")\n+\t}\n+\tsigsTag, err := ociremote.SignatureTag(imgRef2)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// At this point, we would mutate the signature to add the bundle annotation\n+\t// since we don't have a function for it at the moment, mock this by deleting the signature\n+\t// and pushing a new signature with the additional bundle annotation\n+\tif err := remote.Delete(sigsTag); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tmustErr(verify(pubKeyPath, img2, true, nil, \"\"), t)\n+\n+\tnewSig, err := mutate.Signature(gottenSigs2[0], mutate.WithBundle(bund))\n+\tmust(err, t)\n+\tsi2, err = ociremote.SignedEntity(imgRef2, remoteOpts)\n+\tmust(err, t)\n+\tnewImage, err := mutate.AttachSignatureToEntity(si2, newSig)\n+\tmust(err, t)\n+\tif err := ociremote.WriteSignatures(sigsTag.Repository, newImage); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// veriyfing image2 now should fail\n+\tmustErr(verify(pubKeyPath, img2, true, nil, \"\"), t)\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 4,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "accc80a840524890790c5c368fee26e22ec60bda",
            "date": "2025-01-13T20:41:02Z",
            "author_login": "codysoyland"
          },
          {
            "sha": "e5aa062fa9e4c8b893cf14e77f07127031395ca9",
            "date": "2025-01-13T17:30:27Z",
            "author_login": "haydentherapper"
          },
          {
            "sha": "d01988ed7edc1d9c67d3383e7a02b988ba7d14fd",
            "date": "2025-01-13T03:54:54Z",
            "author_login": "nianyush"
          },
          {
            "sha": "87c08b00fca8a96a2ef756cee3953372a5783a45",
            "date": "2025-01-10T08:26:43Z",
            "author_login": "cpanato"
          },
          {
            "sha": "342f8d89f88f1de022d35d720b54322cfe7352fb",
            "date": "2025-01-09T16:07:26Z",
            "author_login": "cmurphy"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.3,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N",
    "cwe_id": "CWE-295",
    "description": "Cosign provides container signing, verification, and storage in an OCI registry for the sigstore project. Prior to version 1.5.2, Cosign can be manipulated to claim that an entry for a signature exists in the Rekor transparency log even if it doesn't. This requires the attacker to have pull and push permissions for the signature in OCI. This can happen with both standard signing with a keypair and \"keyless signing\" with Fulcio. If an attacker has access to the signature in OCI, they can manipulate cosign into believing the entry was stored in Rekor even though it wasn't. The vulnerability has been patched in v1.5.2 of Cosign. The `signature` in the `signedEntryTimestamp` provided by Rekor is now compared to the `signature` that is being verified. If these don't match, then an error is returned. If a valid bundle is copied to a different signature, verification should fail. Cosign output now only informs the user that certificates were verified if a certificate was in fact verified. There is currently no known workaround.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-02-18T22:15:12.793",
    "last_modified": "2024-11-21T06:49:01.113",
    "fix_date": "2022-02-18T19:40:01Z"
  },
  "references": [
    {
      "url": "https://github.com/sigstore/cosign/commit/96d410a6580e4e81d24d112a0855c70ca3fb5b49",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sigstore/cosign/security/advisories/GHSA-ccxc-vr6p-4858",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sigstore/cosign/commit/96d410a6580e4e81d24d112a0855c70ca3fb5b49",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sigstore/cosign/security/advisories/GHSA-ccxc-vr6p-4858",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:59.731880",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "cosign",
    "owner": "sigstore",
    "created_at": "2021-02-04T12:49:39Z",
    "updated_at": "2025-01-14T13:11:06Z",
    "pushed_at": "2025-01-13T20:41:02Z",
    "size": 22969,
    "stars": 4642,
    "forks": 553,
    "open_issues": 250,
    "watchers": 4642,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-1.13"
    ],
    "languages": {
      "Go": 1543441,
      "Shell": 15352,
      "Makefile": 8067,
      "PowerShell": 1530
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:36:50.204114"
  }
}