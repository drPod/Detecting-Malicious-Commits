{
  "cve_id": "CVE-2022-23949",
  "github_data": {
    "repository": "keylime/keylime",
    "fix_commit": "387e320dc22c89f4f47c68cb37eb9eec2137f34b",
    "related_commits": [
      "387e320dc22c89f4f47c68cb37eb9eec2137f34b",
      "65c2b737129b5837f4a03660aeb1191ced275a57",
      "e429e95329fc60608713ddfb82f4a92ee3b3d2d9",
      "387e320dc22c89f4f47c68cb37eb9eec2137f34b",
      "65c2b737129b5837f4a03660aeb1191ced275a57",
      "e429e95329fc60608713ddfb82f4a92ee3b3d2d9"
    ],
    "patch_url": "https://github.com/keylime/keylime/commit/387e320dc22c89f4f47c68cb37eb9eec2137f34b.patch",
    "fix_commit_details": {
      "sha": "387e320dc22c89f4f47c68cb37eb9eec2137f34b",
      "commit_date": "2022-01-17T15:39:35Z",
      "author": {
        "login": "aplanas",
        "type": "User",
        "stats": {
          "total_commits": 37,
          "average_weekly_commits": 0.08584686774941995,
          "total_additions": 1222,
          "total_deletions": 673,
          "weeks_active": 18
        }
      },
      "commit_message": {
        "title": "Validate user ID in all public interfaces",
        "length": 225,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 96,
        "additions": 93,
        "deletions": 3
      },
      "files": [
        {
          "filename": "keylime/cloud_verifier_tornado.py",
          "status": "modified",
          "additions": 30,
          "deletions": 1,
          "patch": "@@ -18,7 +18,7 @@\n from keylime import json\n from keylime import registrar_client\n from keylime.agentstates import AgentAttestStates\n-from keylime.common import states\n+from keylime.common import states, validators\n from keylime.db.verifier_db import VerfierMain\n from keylime.db.verifier_db import VerifierAllowlist\n from keylime.db.keylime_db import DBEngineManager, SessionManager\n@@ -264,6 +264,13 @@ def get(self):\n         agent_id = rest_params[\"agents\"]\n \n         if (agent_id is not None) and (agent_id != ''):\n+            # If the agent ID is not valid (wrong set of characters),\n+            # just do nothing.\n+            if not validators.valid_agent_id(agent_id):\n+                web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n+                logger.error(\"GET received an invalid agent ID: %s\", agent_id)\n+                return\n+\n             try:\n                 agent = session.query(VerfierMain).filter_by(\n                     agent_id=agent_id).one_or_none()\n@@ -330,6 +337,13 @@ def delete(self):\n             logger.warning('DELETE returning 400 response. uri not supported: %s', self.request.path)\n             return\n \n+        # If the agent ID is not valid (wrong set of characters), just\n+        # do nothing.\n+        if not validators.valid_agent_id(agent_id):\n+            web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n+            logger.error(\"DELETE received an invalid agent ID: %s\", agent_id)\n+            return\n+\n         try:\n             agent = session.query(VerfierMain).filter_by(\n                 agent_id=agent_id).first()\n@@ -396,6 +410,13 @@ def post(self):\n             agent_id = rest_params[\"agents\"]\n \n             if agent_id is not None:\n+                # If the agent ID is not valid (wrong set of\n+                # characters), just do nothing.\n+                if not validators.valid_agent_id(agent_id):\n+                    web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n+                    logger.error(\"POST received an invalid agent ID: %s\", agent_id)\n+                    return\n+\n                 content_length = len(self.request.body)\n                 if content_length == 0:\n                     web_util.echo_json_response(\n@@ -534,6 +555,14 @@ def put(self):\n             if agent_id is None:\n                 web_util.echo_json_response(self, 400, \"uri not supported\")\n                 logger.warning(\"PUT returning 400 response. uri not supported\")\n+\n+            # If the agent ID is not valid (wrong set of characters),\n+            # just do nothing.\n+            if not validators.valid_agent_id(agent_id):\n+                web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n+                logger.error(\"PUT received an invalid agent ID: %s\", agent_id)\n+                return\n+\n             try:\n                 verifier_id = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n                 agent = session.query(VerfierMain).filter_by("
        },
        {
          "filename": "keylime/keylime_agent.py",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -676,6 +676,11 @@ def main():\n         agent_uuid = os.getenv(\"KEYLIME_AGENT_UUID\", None)\n         if agent_uuid is None:\n             raise RuntimeError(\"Env variable KEYLIME_AGENT_UUID is empty, but agent_uuid is set to 'environment'\")\n+    elif not validators.valid_uuid(agent_uuid):\n+        raise RuntimeError(\"The UUID is not valid\")\n+\n+    if not validators.valid_agent_id(agent_uuid):\n+        raise RuntimeError(\"The agent ID set via agent uuid parameter use invalid characters\")\n \n     if config.STUB_VTPM and config.TPM_CANNED_VALUES is not None:\n         # Use canned values for stubbing"
        },
        {
          "filename": "keylime/registrar_common.py",
          "status": "modified",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -17,6 +17,7 @@\n from cryptography.hazmat.backends import default_backend\n from cryptography.x509 import load_der_x509_certificate\n \n+from keylime.common import validators\n from keylime.db.registrar_db import RegistrarMain\n from keylime.db.keylime_db import DBEngineManager, SessionManager\n from keylime import config\n@@ -74,6 +75,13 @@ def do_GET(self):\n         agent_id = rest_params[\"agents\"]\n \n         if agent_id is not None:\n+            # If the agent ID is not valid (wrong set of characters),\n+            # just do nothing.\n+            if not validators.valid_agent_id(agent_id):\n+                web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n+                logger.error(\"GET received an invalid agent ID: %s\", agent_id)\n+                return\n+\n             try:\n                 agent = session.query(RegistrarMain).filter_by(\n                     agent_id=agent_id).first()\n@@ -150,6 +158,13 @@ def do_DELETE(self):\n         agent_id = rest_params[\"agents\"]\n \n         if agent_id is not None:\n+            # If the agent ID is not valid (wrong set of characters),\n+            # just do nothing.\n+            if not validators.valid_agent_id(agent_id):\n+                web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n+                logger.error(\"DELETE received an invalid agent ID: %s\", agent_id)\n+                return\n+\n             if session.query(RegistrarMain).filter_by(agent_id=agent_id).delete():\n                 # send response\n                 try:\n@@ -233,6 +248,13 @@ def do_POST(self):\n             logger.warning('POST agent returning 400 response. agent id not found in uri %s', self.path)\n             return\n \n+        # If the agent ID is not valid (wrong set of characters), just\n+        # do nothing.\n+        if not validators.valid_agent_id(agent_id):\n+            web_util.echo_json_response(self, 400, \"agent id not valid\")\n+            logger.error(\"POST received an invalid agent ID: %s\", agent_id)\n+            return\n+\n         try:\n             content_length = int(self.headers.get('Content-Length', 0))\n             if content_length == 0:\n@@ -410,6 +432,13 @@ def do_PUT(self):\n             logger.warning('PUT agent returning 400 response. agent id not found in uri %s', self.path)\n             return\n \n+        # If the agent ID is not valid (wrong set of characters), just\n+        # do nothing.\n+        if not validators.valid_agent_id(agent_id):\n+            web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n+            logger.error(\"PUT received an invalid agent ID: %s\", agent_id)\n+            return\n+\n         try:\n             content_length = int(self.headers.get('Content-Length', 0))\n             if content_length == 0:"
        },
        {
          "filename": "keylime/tenant.py",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -34,7 +34,7 @@\n from keylime import crypto\n from keylime.cmd import user_data_encrypt\n from keylime import ca_util\n-from keylime.common import algorithms\n+from keylime.common import algorithms, validators\n from keylime import ima_file_signatures\n from keylime import measured_boot\n from keylime import gpg\n@@ -1313,6 +1313,8 @@ def main(argv=sys.argv):\n         if mytenant.agent_uuid.startswith('-----BEGIN PUBLIC KEY-----'):\n             mytenant.agent_uuid = hashlib.sha256(\n                 mytenant.agent_uuid).hexdigest()\n+        if not validators.valid_agent_id(mytenant.agent_uuid):\n+            raise UserError(\"The agent ID set via agent uuid parameter use invalid characters\")\n     else:\n         logger.warning(\"Using default UUID d432fbb3-d2f1-4a97-9ef7-75bd81c00000\")\n         mytenant.agent_uuid = \"d432fbb3-d2f1-4a97-9ef7-75bd81c00000\""
        },
        {
          "filename": "keylime/tenant_webapp.py",
          "status": "modified",
          "additions": 26,
          "deletions": 1,
          "patch": "@@ -16,7 +16,7 @@\n import tornado.web\n \n from keylime.requests_client import RequestsClient\n-from keylime.common import states\n+from keylime.common import validators, states\n from keylime import config\n from keylime import json\n from keylime import keylime_logging\n@@ -395,6 +395,13 @@ async def get(self):\n \n         agent_id = rest_params[\"agents\"]\n         if agent_id is not None:\n+            # If the agent ID is not valid (wrong set of characters),\n+            # just do nothing.\n+            if not validators.valid_agent_id(agent_id):\n+                web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n+                logger.error(\"GET received an invalid agent ID: %s\", agent_id)\n+                return\n+\n             # Handle request for specific agent data separately\n             agents = await self.get_agent_state(agent_id)\n             agents[\"id\"] = agent_id\n@@ -455,6 +462,12 @@ def delete(self):\n             return\n \n         agent_id = rest_params[\"agents\"]\n+        # If the agent ID is not valid (wrong set of characters), just\n+        # do nothing.\n+        if not validators.valid_agent_id(agent_id):\n+            web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n+            logger.error(\"DELETE received an invalid agent ID: %s\", agent_id)\n+            return\n \n         # let Tenant do dirty work of deleting agent\n         mytenant = tenant.Tenant()\n@@ -482,6 +495,12 @@ def post(self):\n             return\n \n         agent_id = rest_params[\"agents\"]\n+        # If the agent ID is not valid (wrong set of characters), just\n+        # do nothing.\n+        if not validators.valid_agent_id(agent_id):\n+            web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n+            logger.error(\"POST received an invalid agent ID: %s\", agent_id)\n+            return\n \n         # Parse payload files (base64 data-uri)\n         if self.get_argument(\"ptype\", Agent_Init_Types.FILE, True) == Agent_Init_Types.FILE:\n@@ -593,6 +612,12 @@ def put(self):\n             return\n \n         agent_id = rest_params[\"agents\"]\n+        # If the agent ID is not valid (wrong set of characters), just\n+        # do nothing.\n+        if not validators.valid_agent_id(agent_id):\n+            web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n+            logger.error(\"PUT received an invalid agent ID: %s\", agent_id)\n+            return\n \n         # let Tenant do dirty work of reactivating agent\n         mytenant = tenant.Tenant()"
        }
      ],
      "file_patterns": {
        "security_files": 5,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7acb977f46355cd56495316733f622c7937a9e03",
            "date": "2025-01-06T15:32:59Z",
            "author_login": "sergio-correia"
          },
          {
            "sha": "f832ad542b169902949f350fb03f3e4354201b3b",
            "date": "2024-12-18T19:45:24Z",
            "author_login": "sergio-correia"
          },
          {
            "sha": "29ddc5d047a889da10e58df6b6b11c13f3463b1e",
            "date": "2025-01-02T09:27:25Z",
            "author_login": "ansasaki"
          },
          {
            "sha": "5756729b8a5ff6b15ac4af4a1a90a5a551b46291",
            "date": "2024-12-20T16:54:24Z",
            "author_login": "ansasaki"
          },
          {
            "sha": "c366e821b0f6cda3a7459a40d9a5199b5b245eaf",
            "date": "2024-12-23T10:27:03Z",
            "author_login": "ansasaki"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-290",
    "description": "In Keylime before 6.3.0, unsanitized UUIDs can be passed by a rogue agent and can lead to log spoofing on the verifier and registrar.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-09-21T19:15:10.027",
    "last_modified": "2024-11-21T06:49:30.877",
    "fix_date": "2022-01-17T15:39:35Z"
  },
  "references": [
    {
      "url": "https://github.com/keylime/keylime/commit/387e320dc22c89f4f47c68cb37eb9eec2137f34b",
      "source": "patrick@puiterwijk.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/keylime/keylime/commit/65c2b737129b5837f4a03660aeb1191ced275a57",
      "source": "patrick@puiterwijk.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/keylime/keylime/commit/e429e95329fc60608713ddfb82f4a92ee3b3d2d9",
      "source": "patrick@puiterwijk.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/keylime/keylime/security/advisories/GHSA-87gh-qc28-j9mm",
      "source": "patrick@puiterwijk.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://seclists.org/oss-sec/2022/q1/101",
      "source": "patrick@puiterwijk.org",
      "tags": [
        "Exploit",
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/keylime/keylime/commit/387e320dc22c89f4f47c68cb37eb9eec2137f34b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/keylime/keylime/commit/65c2b737129b5837f4a03660aeb1191ced275a57",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/keylime/keylime/commit/e429e95329fc60608713ddfb82f4a92ee3b3d2d9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/keylime/keylime/security/advisories/GHSA-87gh-qc28-j9mm",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://seclists.org/oss-sec/2022/q1/101",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Mailing List",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:41.268816",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "keylime",
    "owner": "keylime",
    "created_at": "2016-10-19T13:25:46Z",
    "updated_at": "2025-01-12T12:34:11Z",
    "pushed_at": "2025-01-09T12:26:20Z",
    "size": 15805,
    "stars": 438,
    "forks": 153,
    "open_issues": 34,
    "watchers": 438,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Python": 1433962,
      "Jinja": 185366,
      "Shell": 68786,
      "Dockerfile": 1771,
      "Standard ML": 1202,
      "Mako": 919,
      "Makefile": 138
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:30:01.325109"
  }
}