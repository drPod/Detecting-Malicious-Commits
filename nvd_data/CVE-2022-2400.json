{
  "cve_id": "CVE-2022-2400",
  "github_data": {
    "repository": "dompdf/dompdf",
    "fix_commit": "99aeec1efec9213e87098d42eb09439e7ee0bb6a",
    "related_commits": [
      "99aeec1efec9213e87098d42eb09439e7ee0bb6a",
      "99aeec1efec9213e87098d42eb09439e7ee0bb6a"
    ],
    "patch_url": "https://github.com/dompdf/dompdf/commit/99aeec1efec9213e87098d42eb09439e7ee0bb6a.patch",
    "fix_commit_details": {
      "sha": "99aeec1efec9213e87098d42eb09439e7ee0bb6a",
      "commit_date": "2022-04-18T19:17:23Z",
      "author": {
        "login": "bsweeney",
        "type": "User",
        "stats": {
          "total_commits": 565,
          "average_weekly_commits": 0.5417066155321189,
          "total_additions": 110908,
          "total_deletions": 255740,
          "weeks_active": 220
        }
      },
      "commit_message": {
        "title": "Update resource URI validation and handling",
        "length": 424,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 627,
        "additions": 359,
        "deletions": 268
      },
      "files": [
        {
          "filename": "src/Css/Stylesheet.php",
          "status": "modified",
          "additions": 23,
          "deletions": 46,
          "patch": "@@ -325,46 +325,26 @@ function load_css_file($file, $origin = self::ORIG_AUTHOR)\n             $parsed = Helpers::parse_data_uri($file);\n             $css = $parsed[\"data\"];\n         } else {\n-            $parsed_url = Helpers::explode_url($file);\n-\n-            [$this->_protocol, $this->_base_host, $this->_base_path, $filename] = $parsed_url;\n+            $options = $this->_dompdf->getOptions();\n \n-            $file = Helpers::build_url($this->_protocol, $this->_base_host, $this->_base_path, $filename);\n+            $parsed_url = Helpers::explode_url($file);\n+            $protocol = $parsed_url[\"protocol\"];\n \n-            $options = $this->_dompdf->getOptions();\n-            // Download the remote file\n-            if (!$options->isRemoteEnabled() && ($this->_protocol !== \"\" && $this->_protocol !== \"file://\")) {\n-                Helpers::record_warnings(E_USER_WARNING, \"Remote CSS resource '$file' referenced, but remote file download is disabled.\", __FILE__, __LINE__);\n-                return;\n-            }\n-            if ($this->_protocol === \"\" || $this->_protocol === \"file://\") {\n-                $realfile = realpath($file);\n-\n-                $rootDir = realpath($options->getRootDir());\n-                if (strpos($realfile, $rootDir) !== 0) {\n-                    $chroot = $options->getChroot();\n-                    $chrootValid = false;\n-                    foreach ($chroot as $chrootPath) {\n-                        $chrootPath = realpath($chrootPath);\n-                        if ($chrootPath !== false && strpos($realfile, $chrootPath) === 0) {\n-                            $chrootValid = true;\n-                            break;\n-                        }\n-                    }\n-                    if ($chrootValid !== true) {\n-                        Helpers::record_warnings(E_USER_WARNING, \"Permission denied on $file. The file could not be found under the paths specified by Options::chroot.\", __FILE__, __LINE__);\n+            if ($file !== $this->getDefaultStylesheet()) {\n+                $allowed_protocols = $options->getAllowedProtocols();\n+                if (!array_key_exists($protocol, $allowed_protocols)) {\n+                    Helpers::record_warnings(E_USER_WARNING, \"Permission denied on $file. The communication protocol is not supported.\", __FILE__, __LINE__);\n+                    return;\n+                }\n+                foreach ($allowed_protocols[$protocol][\"rules\"] as $rule) {\n+                    [$result, $message] = $rule($file);\n+                    if (!$result) {\n+                        Helpers::record_warnings(E_USER_WARNING, \"Error loading $file: $message\", __FILE__, __LINE__);\n                         return;\n                     }\n                 }\n-\n-                if (!$realfile) {\n-                    Helpers::record_warnings(E_USER_WARNING, \"File '$realfile' not found.\", __FILE__, __LINE__);\n-                    return;\n-                }\n-\n-                $file = $realfile;\n             }\n-            \n+\n             [$css, $http_response_header] = Helpers::getFileContent($file, $this->_dompdf->getHttpContext());\n \n             $good_mime_type = true;\n@@ -379,11 +359,12 @@ function load_css_file($file, $origin = self::ORIG_AUTHOR)\n                     }\n                 }\n             }\n-\n             if (!$good_mime_type || $css === null) {\n                 Helpers::record_warnings(E_USER_WARNING, \"Unable to load css file $file\", __FILE__, __LINE__);\n                 return;\n             }\n+\n+            [$this->_protocol, $this->_base_host, $this->_base_path] = $parsed_url;\n         }\n \n         $this->_parse_css($css);\n@@ -1421,20 +1402,16 @@ public function resolve_url($val): string\n             $val = preg_replace(\"/url\\(\\s*['\\\"]?([^'\\\")]+)['\\\"]?\\s*\\)/\", \"\\\\1\", trim($val));\n \n             // Resolve the url now in the context of the current stylesheet\n-            $parsed_url = Helpers::explode_url($val);\n             $path = Helpers::build_url($this->_protocol,\n                 $this->_base_host,\n                 $this->_base_path,\n                 $val);\n-            if (($parsed_url[\"protocol\"] === \"\" || $parsed_url[\"protocol\"] === \"file://\") && ($this->_protocol === \"\" || $this->_protocol === \"file://\")) {\n-                $path = realpath($path);\n-                // If realpath returns FALSE then specifically state that there is no background image\n-                if ($path === false) {\n-                    $path = \"none\";\n-                }\n+            if ($path === null) {\n+                $path = \"none\";\n             }\n         }\n         if ($DEBUGCSS) {\n+            $parsed_url = Helpers::explode_url($path);\n             print \"<pre>[_image\\n\";\n             print_r($parsed_url);\n             print $this->_protocol . \"\\n\" . $this->_base_path . \"\\n\" . $path . \"\\n\";\n@@ -1483,9 +1460,9 @@ private function _parse_import($url)\n             // Above does not work for subfolders and absolute urls.\n             // Todo: As above, do we need to replace php or file to an empty protocol for local files?\n \n-            $url = $this->resolve_url($url);\n-\n-            $this->load_css_file($url);\n+            if (($url = $this->resolve_url($url)) !== \"none\") {\n+                $this->load_css_file($url);\n+            }\n \n             // Restore the current base url\n             $this->_protocol = $protocol;\n@@ -1675,7 +1652,7 @@ public function getDefaultStylesheet()\n     {\n         $options = $this->_dompdf->getOptions();\n         $rootDir = realpath($options->getRootDir());\n-        return $rootDir . self::DEFAULT_STYLESHEET;\n+        return Helpers::build_url(\"file://\", \"\", $rootDir, $rootDir . self::DEFAULT_STYLESHEET);\n     }\n \n     /**"
        },
        {
          "filename": "src/Dompdf.php",
          "status": "modified",
          "additions": 18,
          "deletions": 41,
          "patch": "@@ -196,16 +196,6 @@ class Dompdf\n      */\n     private $quirksmode = false;\n \n-    /**\n-    * Protocol whitelist\n-    *\n-    * Protocols and PHP wrappers allowed in URLs. Full support is not\n-    * guaranteed for the protocols/wrappers contained in this array.\n-    *\n-    * @var array\n-    */\n-    private $allowedProtocols = [\"\", \"file://\", \"http://\", \"https://\"];\n-\n     /**\n     * Local file extension whitelist\n     *\n@@ -271,8 +261,11 @@ public function __construct($options = null)\n         }\n \n         $versionFile = realpath(__DIR__ . '/../VERSION');\n-        if (file_exists($versionFile) && ($version = trim(file_get_contents($versionFile))) !== false && $version !== '$Format:<%h>$') {\n-            $this->version = sprintf('dompdf %s', $version);\n+        if (($version = file_get_contents($versionFile)) !== false) {\n+            $version = trim($version);\n+            if ($version !== '$Format:<%h>$') {\n+                $this->version = sprintf('dompdf %s', $version);\n+            }\n         }\n \n         $this->setPhpConfig();\n@@ -352,43 +345,25 @@ public function loadHtmlFile($file, $encoding = null)\n             [$this->protocol, $this->baseHost, $this->basePath] = Helpers::explode_url($file);\n         }\n         $protocol = strtolower($this->protocol);\n-        \n         $uri = Helpers::build_url($this->protocol, $this->baseHost, $this->basePath, $file);\n \n-        if (!in_array($protocol, $this->allowedProtocols, true)) {\n+        $allowed_protocols = $this->options->getAllowedProtocols();\n+        if (!array_key_exists($protocol, $allowed_protocols)) {\n             throw new Exception(\"Permission denied on $file. The communication protocol is not supported.\");\n         }\n \n-        if (!$this->options->isRemoteEnabled() && ($protocol !== \"\" && $protocol !== \"file://\")) {\n-            throw new Exception(\"Remote file requested, but remote file download is disabled.\");\n-        }\n-\n-        if ($protocol === \"\" || $protocol === \"file://\") {\n-            $realfile = realpath($uri);\n-\n-            $chroot = $this->options->getChroot();\n-            $chrootValid = false;\n-            foreach ($chroot as $chrootPath) {\n-                $chrootPath = realpath($chrootPath);\n-                if ($chrootPath !== false && strpos($realfile, $chrootPath) === 0) {\n-                    $chrootValid = true;\n-                    break;\n-                }\n-            }\n-            if ($chrootValid !== true) {\n-                throw new Exception(\"Permission denied on $file. The file could not be found under the paths specified by Options::chroot.\");\n-            }\n-\n-            $ext = strtolower(pathinfo($realfile, PATHINFO_EXTENSION));\n+        if ($protocol === \"file://\") {\n+            $ext = strtolower(pathinfo($uri, PATHINFO_EXTENSION));\n             if (!in_array($ext, $this->allowedLocalFileExtensions)) {\n-                throw new Exception(\"Permission denied on $file. This file extension is forbidden\");\n+                throw new Exception(\"Permission denied on $file: The file extension is forbidden.\");\n             }\n+        }\n \n-            if (!$realfile) {\n-                throw new Exception(\"File '$file' not found.\");\n+        foreach ($allowed_protocols[$protocol][\"rules\"] as $rule) {\n+            [$result, $message] = $rule($uri);\n+            if (!$result) {\n+                throw new Exception(\"Error loading $file: $message\");\n             }\n-\n-            $uri = $realfile;\n         }\n \n         [$contents, $http_response_header] = Helpers::getFileContent($uri, $this->options->getHttpContext());\n@@ -604,7 +579,9 @@ private function processHtml()\n                         $url = $tag->getAttribute(\"href\");\n                         $url = Helpers::build_url($this->protocol, $this->baseHost, $this->basePath, $url);\n \n-                        $this->css->load_css_file($url, Stylesheet::ORIG_AUTHOR);\n+                        if ($url !== null) {\n+                            $this->css->load_css_file($url, Stylesheet::ORIG_AUTHOR);\n+                        }\n                     }\n                     break;\n "
        },
        {
          "filename": "src/FontMetrics.php",
          "status": "modified",
          "additions": 8,
          "deletions": 27,
          "patch": "@@ -214,37 +214,18 @@ public function registerFont($style, $remoteFile, $context = null)\n \n         // Download the remote file\n         [$protocol] = Helpers::explode_url($remoteFile);\n-        if (!$this->options->isRemoteEnabled() && ($protocol !== \"\" && $protocol !== \"file://\")) {\n-            Helpers::record_warnings(E_USER_WARNING, \"Remote font resource $remoteFile referenced, but remote file download is disabled.\", __FILE__, __LINE__);\n-            return false;\n+        $allowed_protocols = $this->options->getAllowedProtocols();\n+        if (!array_key_exists($protocol, $allowed_protocols)) {\n+            Helpers::record_warnings(E_USER_WARNING, \"Permission denied on $remoteFile. The communication protocol is not supported.\", __FILE__, __LINE__);\n         }\n-        if ($protocol === \"\" || $protocol === \"file://\") {\n-            $realfile = realpath($remoteFile);\n-\n-            $rootDir = realpath($this->options->getRootDir());\n-            if (strpos($realfile, $rootDir) !== 0) {\n-                $chroot = $this->options->getChroot();\n-                $chrootValid = false;\n-                foreach ($chroot as $chrootPath) {\n-                    $chrootPath = realpath($chrootPath);\n-                    if ($chrootPath !== false && strpos($realfile, $chrootPath) === 0) {\n-                        $chrootValid = true;\n-                        break;\n-                    }\n-                }\n-                if ($chrootValid !== true) {\n-                    Helpers::record_warnings(E_USER_WARNING, \"Permission denied on $remoteFile. The file could not be found under the paths specified by Options::chroot.\", __FILE__, __LINE__);\n-                    return false;\n-                }\n-            }\n \n-            if (!$realfile) {\n-                Helpers::record_warnings(E_USER_WARNING, \"File '$realfile' not found.\", __FILE__, __LINE__);\n-                return false;\n+        foreach ($allowed_protocols[$protocol][\"rules\"] as $rule) {\n+            [$result, $message] = $rule($remoteFile);\n+            if ($result !== true) {\n+                Helpers::record_warnings(E_USER_WARNING, \"Error loading $remoteFile: $message\", __FILE__, __LINE__);\n             }\n-\n-            $remoteFile = $realfile;\n         }\n+\n         list($remoteFileContent, $http_response_header) = @Helpers::getFileContent($remoteFile, $context);\n         if ($remoteFileContent === null) {\n             return false;"
        },
        {
          "filename": "src/FrameDecorator/Image.php",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -57,7 +57,7 @@ function __construct(Frame $frame, Dompdf $dompdf)\n             $dompdf->getProtocol(),\n             $dompdf->getBaseHost(),\n             $dompdf->getBasePath(),\n-            $dompdf\n+            $dompdf->getOptions()\n         );\n \n         if (Cache::is_broken($this->_image_url) &&"
        },
        {
          "filename": "src/Helpers.php",
          "status": "modified",
          "additions": 56,
          "deletions": 39,
          "patch": "@@ -57,28 +57,45 @@ public static function pre_r($mixed, $return = false)\n     public static function build_url($protocol, $host, $base_path, $url)\n     {\n         $protocol = mb_strtolower($protocol);\n+        if (empty($protocol)) {\n+            $protocol = \"file://\";\n+        }\n         if ($url === \"\") {\n-            //return $protocol . $host . rtrim($base_path, \"/\\\\\") . \"/\";\n-            return $protocol . $host . $base_path;\n+            return null;\n         }\n \n+        $url_lc = mb_strtolower($url);\n+\n         // Is the url already fully qualified, a Data URI, or a reference to a named anchor?\n         // File-protocol URLs may require additional processing (e.g. for URLs with a relative path)\n-        if ((mb_strpos($url, \"://\") !== false && substr($url, 0, 7) !== \"file://\") || mb_substr($url, 0, 1) === \"#\" || mb_strpos($url, \"data:\") === 0 || mb_strpos($url, \"mailto:\") === 0 || mb_strpos($url, \"tel:\") === 0) {\n+        if (\n+            (\n+                mb_strpos($url_lc, \"://\") !== false\n+                && !in_array(substr($url_lc, 0, 7), [\"file://\", \"phar://\"], true)\n+            )\n+            || mb_substr($url_lc, 0, 1) === \"#\"\n+            || mb_strpos($url_lc, \"data:\") === 0\n+            || mb_strpos($url_lc, \"mailto:\") === 0\n+            || mb_strpos($url_lc, \"tel:\") === 0\n+        ) {\n             return $url;\n         }\n \n-        if (strpos($url, \"file://\") === 0) {\n+        $res = \"\";\n+        if (strpos($url_lc, \"file://\") === 0) {\n             $url = substr($url, 7);\n-            $protocol = \"\";\n+            $protocol = \"file://\";\n+        } elseif (strpos($url_lc, \"phar://\") === 0) {\n+            $res = substr($url, strpos($url_lc, \".phar\")+5);\n+            $url = substr($url, 7, strpos($url_lc, \".phar\")-2);\n+            $protocol = \"phar://\";\n         }\n \n         $ret = \"\";\n-        if ($protocol !== \"file://\") {\n-            $ret = $protocol;\n-        }\n \n-        if (!in_array(mb_strtolower($protocol), [\"http://\", \"https://\", \"ftp://\", \"ftps://\"], true)) {\n+        $is_local_path = in_array($protocol, [\"file://\", \"phar://\"], true);\n+\n+        if ($is_local_path) {\n             //On Windows local file, an abs path can begin also with a '\\' or a drive letter and colon\n             //drive: followed by a relative path would be a drive specific default folder.\n             //not known in php app code, treat as abs path\n@@ -89,9 +106,18 @@ public static function build_url($protocol, $host, $base_path, $url)\n             }\n             $ret .= $url;\n             $ret = preg_replace('/\\?(.*)$/', \"\", $ret);\n+\n+            $filepath = realpath($ret);\n+            if ($filepath === false) {\n+                return null;\n+            }\n+\n+            $ret = \"$protocol$filepath$res\";\n+\n             return $ret;\n         }\n \n+        $ret = $protocol;\n         // Protocol relative urls (e.g. \"//example.org/style.css\")\n         if (strpos($url, '//') === 0) {\n             $ret .= substr($url, 2);\n@@ -431,14 +457,14 @@ public static function explode_url($url)\n         $host = \"\";\n         $path = \"\";\n         $file = \"\";\n+        $res = \"\";\n \n         $arr = parse_url($url);\n         if ( isset($arr[\"scheme\"]) ) {\n             $arr[\"scheme\"] = mb_strtolower($arr[\"scheme\"]);\n         }\n \n-        // Exclude windows drive letters...\n-        if (isset($arr[\"scheme\"]) && $arr[\"scheme\"] !== \"file\" && strlen($arr[\"scheme\"]) > 1) {\n+        if (isset($arr[\"scheme\"]) && $arr[\"scheme\"] !== \"file\" && $arr[\"scheme\"] !== \"phar\" && strlen($arr[\"scheme\"]) > 1) {\n             $protocol = $arr[\"scheme\"] . \"://\";\n \n             if (isset($arr[\"user\"])) {\n@@ -480,42 +506,32 @@ public static function explode_url($url)\n \n         } else {\n \n-            $i = mb_stripos($url, \"file://\");\n-            if ($i !== false) {\n-                $url = mb_substr($url, $i + 7);\n-            }\n-\n-            $protocol = \"\"; // \"file://\"; ? why doesn't this work... It's because of\n-            // network filenames like //COMPU/SHARENAME\n-\n+            $protocol = \"\";\n             $host = \"\"; // localhost, really\n-            $file = basename($url);\n-\n-            $path = dirname($url);\n-\n-            // Check that the path exists\n-            if ($path !== false) {\n-                $path .= '/';\n \n+            $i = mb_stripos($url, \"://\");\n+            if ($i !== false) {\n+                $protocol = mb_strtolower(mb_substr($url, 0, $i + 3));\n+                $url = mb_substr($url, $i + 3);\n             } else {\n-                // generate a url to access the file if no real path found.\n-                $protocol = isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] === 'on' ? 'https://' : 'http://';\n-\n-                $host = isset($_SERVER[\"HTTP_HOST\"]) ? $_SERVER[\"HTTP_HOST\"] : php_uname(\"n\");\n+                $protocol = \"file://\";\n+            }\n \n-                if (substr($arr[\"path\"], 0, 1) === '/') {\n-                    $path = dirname($arr[\"path\"]);\n-                } else {\n-                    $path = '/' . rtrim(dirname($_SERVER[\"SCRIPT_NAME\"]), '/') . '/' . $arr[\"path\"];\n-                }\n+            if ($protocol === \"phar://\") {\n+                $res = substr($url, stripos($url, \".phar\")+5);\n+                $url = substr($url, 7, stripos($url, \".phar\")-2);\n             }\n+\n+            $file = basename($url);\n+            $path = dirname($url) . \"/\";\n         }\n \n         $ret = [$protocol, $host, $path, $file,\n             \"protocol\" => $protocol,\n             \"host\" => $host,\n             \"path\" => $path,\n-            \"file\" => $file];\n+            \"file\" => $file,\n+            \"resource\" => $res];\n         return $ret;\n     }\n \n@@ -878,12 +894,13 @@ public static function getFileContent($uri, $context = null, $offset = 0, $maxle\n         $content = null;\n         $headers = null;\n         [$protocol] = Helpers::explode_url($uri);\n-        $is_local_path = ($protocol === \"\" || $protocol === \"file://\");\n+        $is_local_path = in_array(strtolower($protocol), [\"\", \"file://\", \"phar://\"], true);\n+        $can_use_curl = in_array(strtolower($protocol), [\"http://\", \"https://\"], true);\n \n         set_error_handler([self::class, 'record_warnings']);\n \n         try {\n-            if ($is_local_path || ini_get('allow_url_fopen')) {\n+            if ($is_local_path || ini_get('allow_url_fopen') || !$can_use_curl) {\n                 if ($is_local_path === false) {\n                     $uri = Helpers::encodeURI($uri);\n                 }\n@@ -899,7 +916,7 @@ public static function getFileContent($uri, $context = null, $offset = 0, $maxle\n                     $headers = $http_response_header;\n                 }\n \n-            } elseif (function_exists('curl_exec')) {\n+            } elseif ($can_use_curl && function_exists('curl_exec')) {\n                 $curl = curl_init($uri);\n \n                 curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);"
        },
        {
          "filename": "src/Image/Cache.php",
          "status": "modified",
          "additions": 62,
          "deletions": 106,
          "patch": "@@ -9,7 +9,7 @@\n  */\n namespace Dompdf\\Image;\n \n-use Dompdf\\Dompdf;\n+use Dompdf\\Options;\n use Dompdf\\Helpers;\n use Dompdf\\Exception\\ImageException;\n \n@@ -43,144 +43,98 @@ class Cache\n \n     public static $error_message = \"Image not found or type unknown\";\n     \n-    /**\n-     * Current dompdf instance\n-     *\n-     * @var Dompdf\n-     */\n-    protected static $_dompdf;\n-\n     /**\n      * Resolve and fetch an image for use.\n      *\n      * @param string $url       The url of the image\n      * @param string $protocol  Default protocol if none specified in $url\n      * @param string $host      Default host if none specified in $url\n      * @param string $base_path Default path if none specified in $url\n-     * @param Dompdf $dompdf    The Dompdf instance\n+     * @param Options $options  An instance of Dompdf\\Options\n      *\n-     * @throws ImageException\n-     * @return array             An array with two elements: The local path to the image and the image extension\n+     * @return array            An array with three elements: The local path to the image, the image\n+     *                          extension, and an error message if the image could not be cached\n      */\n-    static function resolve_url($url, $protocol, $host, $base_path, Dompdf $dompdf)\n+    static function resolve_url($url, $protocol, $host, $base_path, Options $options)\n     {\n-        self::$_dompdf = $dompdf;\n-        \n-        $protocol = mb_strtolower($protocol);\n-        $parsed_url = Helpers::explode_url($url);\n+        $tempfile = null;\n+        $resolved_url = null;\n+        $type = null;\n         $message = null;\n-\n-        $remote = ($protocol && $protocol !== \"file://\") || ($parsed_url['protocol'] !== \"\");\n-\n-        $data_uri = strpos($parsed_url['protocol'], \"data:\") === 0;\n-        $full_url = null;\n-        $enable_remote = $dompdf->getOptions()->getIsRemoteEnabled();\n-        $tempfile = false;\n-\n+        \n         try {\n+            $full_url = Helpers::build_url($protocol, $host, $base_path, $url);\n \n-            // Remote not allowed and is not DataURI\n-            if (!$enable_remote && $remote && !$data_uri) {\n-                throw new ImageException(\"Remote file access is disabled.\", E_WARNING);\n+            if ($full_url === null) {\n+                throw new ImageException(\"Unable to parse image URL $url.\", E_WARNING);\n             }\n-            \n-            // remote allowed or DataURI\n-            if (($enable_remote && $remote) || $data_uri) {\n-                // Download remote files to a temporary directory\n-                $full_url = Helpers::build_url($protocol, $host, $base_path, $url);\n \n-                // From cache\n-                if (isset(self::$_cache[$full_url])) {\n-                    $resolved_url = self::$_cache[$full_url];\n-                } // From remote\n-                else {\n-                    $tmp_dir = $dompdf->getOptions()->getTempDir();\n-                    if (($resolved_url = @tempnam($tmp_dir, \"ca_dompdf_img_\")) === false) {\n-                        throw new ImageException(\"Unable to create temporary image in \" . $tmp_dir, E_WARNING);\n+            $parsed_url = Helpers::explode_url($full_url);\n+            $protocol = strtolower($parsed_url[\"protocol\"]);\n+            $is_data_uri = strpos($protocol, \"data:\") === 0;\n+            \n+            if (!$is_data_uri) {\n+                $allowed_protocols = $options->getAllowedProtocols();\n+                if (!array_key_exists($protocol, $allowed_protocols)) {\n+                    throw new ImageException(\"Permission denied on $url. The communication protocol is not supported.\", E_WARNING);\n+                }\n+                foreach ($allowed_protocols[$protocol][\"rules\"] as $rule) {\n+                    [$result, $message] = $rule($full_url);\n+                    if (!$result) {\n+                        throw new ImageException(\"Error loading $url: $message\", E_WARNING);\n                     }\n-                    $tempfile = $resolved_url;\n-                    $image = null;\n+                }\n+            }\n \n-                    if ($data_uri) {\n-                        if ($parsed_data_uri = Helpers::parse_data_uri($url)) {\n-                            $image = $parsed_data_uri['data'];\n-                        }\n-                    } else {\n-                        list($image, $http_response_header) = Helpers::getFileContent($full_url, $dompdf->getHttpContext());\n-                    }\n+            if ($protocol === \"file://\") {\n+                $resolved_url = $full_url;\n+            } elseif (isset(self::$_cache[$full_url])) {\n+                $resolved_url = self::$_cache[$full_url];\n+            } else {\n+                $tmp_dir = $options->getTempDir();\n+                if (($resolved_url = @tempnam($tmp_dir, \"ca_dompdf_img_\")) === false) {\n+                    throw new ImageException(\"Unable to create temporary image in \" . $tmp_dir, E_WARNING);\n+                }\n+                $tempfile = $resolved_url;\n \n-                    // Image not found or invalid\n-                    if ($image === null) {\n-                        $msg = ($data_uri ? \"Data-URI could not be parsed\" : \"Image not found\");\n-                        throw new ImageException($msg, E_WARNING);\n-                    } // Image found, put in cache and process\n-                    else {\n-                        //e.g. fetch.php?media=url.jpg&cache=1\n-                        //- Image file name might be one of the dynamic parts of the url, don't strip off!\n-                        //- a remote url does not need to have a file extension at all\n-                        //- local cached file does not have a matching file extension\n-                        //Therefore get image type from the content\n-                        if (@file_put_contents($resolved_url, $image) === false) {\n-                            throw new ImageException(\"Unable to create temporary image in \" . $tmp_dir, E_WARNING);\n-                        }\n+                $image = null;\n+                if ($is_data_uri) {\n+                    if (($parsed_data_uri = Helpers::parse_data_uri($url)) !== false) {\n+                        $image = $parsed_data_uri[\"data\"];\n                     }\n+                } else {\n+                    list($image, $http_response_header) = Helpers::getFileContent($full_url, $options->getHttpContext());\n                 }\n-            } // Not remote, local image\n-            else {\n-                $resolved_url = Helpers::build_url($protocol, $host, $base_path, $url);\n \n-                if ($protocol === \"\" || $protocol === \"file://\") {\n-                    $realfile = realpath($resolved_url);\n-        \n-                    $rootDir = realpath($dompdf->getOptions()->getRootDir());\n-                    if (strpos($realfile, $rootDir) !== 0) {\n-                        $chroot = $dompdf->getOptions()->getChroot();\n-                        $chrootValid = false;\n-                        foreach ($chroot as $chrootPath) {\n-                            $chrootPath = realpath($chrootPath);\n-                            if ($chrootPath !== false && strpos($realfile, $chrootPath) === 0) {\n-                                $chrootValid = true;\n-                                break;\n-                            }\n-                        }\n-                        if ($chrootValid !== true) {\n-                            throw new ImageException(\"Permission denied on $resolved_url. The file could not be found under the paths specified by Options::chroot.\", E_WARNING);\n-                        }\n-                    }\n-        \n-                    if (!$realfile) {\n-                        throw new ImageException(\"File '$realfile' not found.\", E_WARNING);\n-                    }\n-        \n-                    $resolved_url = $realfile;\n+                // Image not found or invalid\n+                if ($image === null) {\n+                    $msg = ($is_data_uri ? \"Data-URI could not be parsed\" : \"Image not found\");\n+                    throw new ImageException($msg, E_WARNING);\n+                }\n+\n+                if (@file_put_contents($resolved_url, $image) === false) {\n+                    throw new ImageException(\"Unable to create temporary image in \" . $tmp_dir, E_WARNING);\n                 }\n+\n+                self::$_cache[$full_url] = $resolved_url;\n             }\n \n             // Check if the local file is readable\n             if (!is_readable($resolved_url) || !filesize($resolved_url)) {\n                 throw new ImageException(\"Image not readable or empty\", E_WARNING);\n-            } // Check is the file is an image\n-            else {\n-                list($width, $height, $type) = Helpers::dompdf_getimagesize($resolved_url, $dompdf->getHttpContext());\n+            }\n \n-                // Known image type\n-                if ($width && $height && in_array($type, [\"gif\", \"png\", \"jpeg\", \"bmp\", \"svg\",\"webp\"], true)) {\n-                    //Don't put replacement image into cache - otherwise it will be deleted on cache cleanup.\n-                    //Only execute on successful caching of remote image.\n-                    if ($enable_remote && $remote || $data_uri) {\n-                        self::$_cache[$full_url] = $resolved_url;\n-                    }\n-                } // Unknown image type\n-                else {\n-                    throw new ImageException(\"Image type unknown\", E_WARNING);\n-                }\n+            list($width, $height, $type) = Helpers::dompdf_getimagesize($resolved_url, $options->getHttpContext());\n+\n+            if (($width && $height && in_array($type, [\"gif\", \"png\", \"jpeg\", \"bmp\", \"svg\",\"webp\"], true)) === false) {\n+                throw new ImageException(\"Image type unknown\", E_WARNING);\n             }\n         } catch (ImageException $e) {\n             if ($tempfile) {\n                 unlink($tempfile);\n             }\n             $resolved_url = self::$broken_image;\n-            $type = \"png\";\n+            $type = \"svg\";\n             $message = self::$error_message;\n             Helpers::record_warnings($e->getCode(), $e->getMessage() . \" \\n $url\", $e->getFile(), $e->getLine());\n             self::$_cache[$full_url] = $resolved_url;\n@@ -229,7 +183,9 @@ static function clear(bool $debugPng = false)\n             if ($debugPng) {\n                 print \"[clear unlink $file]\";\n             }\n-            unlink($file);\n+            if (file_exists($file)) {\n+                unlink($file);\n+            }\n         }\n \n         foreach (self::$tempImages as $versions) {"
        },
        {
          "filename": "src/Options.php",
          "status": "modified",
          "additions": 139,
          "deletions": 3,
          "patch": "@@ -62,6 +62,20 @@ class Options\n      */\n     private $chroot;\n \n+    /**\n+    * Protocol whitelist\n+    *\n+    * Protocols and PHP wrappers allowed in URIs. Full support is not\n+    * guaranteed for the protocols/wrappers specified by this array.\n+    *\n+    * @var array\n+    */\n+    private $allowedProtocols = [\n+        \"file://\" => [\"rules\" => []],\n+        \"http://\" => [\"rules\" => []],\n+        \"https://\" => [\"rules\" => []]\n+    ];\n+\n     /**\n      * @var string\n      */\n@@ -299,9 +313,12 @@ public function __construct(array $attributes = null)\n         $this->setFontCache($this->getFontDir());\n \n         $ver = \"\";\n-        $versionFile = realpath(__DIR__ . \"/../VERSION\");\n-        if (file_exists($versionFile) && ($version = trim(file_get_contents($versionFile))) !== false && $version !== '$Format:<%h>$') {\n-            $ver = \"/$version\";\n+        $versionFile = realpath(__DIR__ . '/../VERSION');\n+        if (($version = file_get_contents($versionFile)) !== false) {\n+            $version = trim($version);\n+            if ($version !== '$Format:<%h>$') {\n+                $ver = \"/$version\";\n+            }\n         }\n         $this->setHttpContext([\n             \"http\" => [\n@@ -310,6 +327,8 @@ public function __construct(array $attributes = null)\n             ]\n         ]);\n \n+        $this->setAllowedProtocols([\"file://\", \"http://\", \"https://\"]);\n+\n         if (null !== $attributes) {\n             $this->set($attributes);\n         }\n@@ -334,6 +353,8 @@ public function set($attributes, $value = null)\n                 $this->setFontCache($value);\n             } elseif ($key === 'chroot') {\n                 $this->setChroot($value);\n+            } elseif ($key === 'allowedProtocols') {\n+                $this->setAllowedProtocols($value);\n             } elseif ($key === 'logOutputFile' || $key === 'log_output_file') {\n                 $this->setLogOutputFile($value);\n             } elseif ($key === 'defaultMediaType' || $key === 'default_media_type') {\n@@ -399,6 +420,8 @@ public function get($key)\n             return $this->getFontCache();\n         } elseif ($key === 'chroot') {\n             return $this->getChroot();\n+        } elseif ($key === 'allowedProtocols') {\n+            return $this->getAllowedProtocols();\n         } elseif ($key === 'logOutputFile' || $key === 'log_output_file') {\n             return $this->getLogOutputFile();\n         } elseif ($key === 'defaultMediaType' || $key === 'default_media_type') {\n@@ -499,6 +522,67 @@ public function setChroot($chroot, $delimiter = ',')\n         return $this;\n     }\n \n+    /**\n+     * @return array\n+     */\n+    public function getAllowedProtocols()\n+    {\n+        return $this->allowedProtocols;\n+    }\n+\n+    /**\n+     * @param array $allowedProtocols The protocols to allow as an array ([\"protocol://\" => [\"rules\" => [callable]]], ...) or a string list of the protocols\n+     * @return $this\n+     */\n+    public function setAllowedProtocols(array $allowedProtocols)\n+    {\n+        $protocols = [];\n+        foreach ($allowedProtocols as $protocol => $config) {\n+            if (is_string($protocol)) {\n+                $protocols[$protocol] = [];\n+                if (is_array($config)) {\n+                    $protocols[$protocol] = $config;\n+                }\n+            } elseif (is_string($config)) {\n+                $protocols[$config] = [];\n+            }\n+        }\n+        $this->allowedProtocols = [];\n+        foreach ($protocols as $protocol => $config) {\n+            $this->addAllowedProtocol($protocol, ...($config[\"rules\"] ?? []));\n+        }\n+        return $this;\n+    }\n+\n+    /**\n+     * Adds a new protocol to the allowed protocols collection\n+     *\n+     * @param string $protocol The scheme to add (e.g. \"http://\")\n+     * @param callable $rule A callable that validates the protocol\n+     * @return $this\n+     */\n+    public function addAllowedProtocol(string $protocol, callable ...$rules)\n+    {\n+        $protocol = strtolower($protocol);\n+        if (empty($rules)) {\n+            $rules = [];\n+            switch ($protocol) {\n+                case \"file://\":\n+                    $rules[] = [$this, \"validateLocalUri\"];\n+                    break;\n+                case \"http://\":\n+                case \"https://\":\n+                    $rules[] = [$this, \"validateRemoteUri\"];\n+                    break;\n+                case \"phar://\":\n+                    $rules[] = [$this, \"validatePharUri\"];\n+                    break;\n+            }\n+        }\n+        $this->allowedProtocols[$protocol] = [\"rules\" => $rules];\n+        return $this;\n+    }\n+\n     /**\n      * @return array\n      */\n@@ -1011,4 +1095,56 @@ public function getHttpContext()\n     {\n         return $this->httpContext;\n     }\n+\n+    public function validateLocalUri(string $uri)\n+    {\n+        if ($uri === null || strlen($uri) === 0) {\n+            return [false, \"The URI must not be empty.\"];\n+        }\n+\n+        $realfile = realpath(str_replace(\"file://\", \"\", $uri));\n+\n+        $dirs = $this->chroot;\n+        $dirs[] = $this->rootDir;\n+        $chrootValid = false;\n+        foreach ($dirs as $chrootPath) {\n+            $chrootPath = realpath($chrootPath);\n+            if ($chrootPath !== false && strpos($realfile, $chrootPath) === 0) {\n+                $chrootValid = true;\n+                break;\n+            }\n+        }\n+        if ($chrootValid !== true) {\n+            return [false, \"Permission denied. The file could not be found under the paths specified by Options::chroot.\"];\n+        }\n+\n+        if (!$realfile) {\n+            return [false, \"File not found.\"];\n+        }\n+\n+        return [true, null];\n+    }\n+\n+    public function validatePharUri(string $uri)\n+    {\n+        if ($uri === null || strlen($uri) === 0) {\n+            return [false, \"The URI must not be empty.\"];\n+        }\n+\n+        $file = substr(substr($uri, 0, strpos($uri, \".phar\") + 5), 7);\n+        return $this->validateLocalUri($file);\n+    }\n+\n+    public function validateRemoteUri(string $uri)\n+    {\n+        if ($uri === null || strlen($uri) === 0) {\n+            return [false, \"The URI must not be empty.\"];\n+        }\n+\n+        if (!$this->isRemoteEnabled) {\n+            return [false, \"Remote file requested, but remote file download is disabled.\"];\n+        }\n+\n+        return [true, null];\n+    }\n }"
        },
        {
          "filename": "src/Renderer/AbstractRenderer.php",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -97,7 +97,7 @@ protected function _background_image($url, $x, $y, $width, $height, $style)\n             $sheet->get_protocol(),\n             $sheet->get_host(),\n             $sheet->get_base_path(),\n-            $this->_dompdf\n+            $this->_dompdf->getOptions()\n         );\n \n         // Bail if the image is no good"
        },
        {
          "filename": "tests/Css/StyleTest.php",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -53,17 +53,17 @@ public function cssImageNoBaseHrefProvider(): array\n     {\n         $basePath = realpath(__DIR__ . \"/..\");\n         return [\n-            \"local absolute\" => [\"url($basePath/_files/jamaica.jpg)\", $basePath . DIRECTORY_SEPARATOR . \"_files\" . DIRECTORY_SEPARATOR . \"jamaica.jpg\"],\n-            \"local relative\" => [\"url(../_files/jamaica.jpg)\", $basePath . DIRECTORY_SEPARATOR . \"_files\" . DIRECTORY_SEPARATOR . \"jamaica.jpg\"]\n+            \"local absolute\" => [\"url($basePath/_files/jamaica.jpg)\", \"file://\" . $basePath . DIRECTORY_SEPARATOR . \"_files\" . DIRECTORY_SEPARATOR . \"jamaica.jpg\"],\n+            \"local relative\" => [\"url(../_files/jamaica.jpg)\", \"file://\" . $basePath . DIRECTORY_SEPARATOR . \"_files\" . DIRECTORY_SEPARATOR . \"jamaica.jpg\"]\n         ];\n     }\n \n     public function cssImageWithBaseHrefProvider(): array\n     {\n         $basePath = realpath(__DIR__ . \"/..\");\n         return [\n-            \"local absolute\" => [\"url($basePath/_files/jamaica.jpg)\", $basePath . DIRECTORY_SEPARATOR . \"_files\" . DIRECTORY_SEPARATOR . \"jamaica.jpg\"],\n-            \"local relative\" => [\"url(../_files/jamaica.jpg)\", $basePath . DIRECTORY_SEPARATOR . \"_files\" . DIRECTORY_SEPARATOR . \"jamaica.jpg\"]\n+            \"local absolute\" => [\"url($basePath/_files/jamaica.jpg)\", \"file://\" . $basePath . DIRECTORY_SEPARATOR . \"_files\" . DIRECTORY_SEPARATOR . \"jamaica.jpg\"],\n+            \"local relative\" => [\"url(../_files/jamaica.jpg)\", \"file://\" . $basePath . DIRECTORY_SEPARATOR . \"_files\" . DIRECTORY_SEPARATOR . \"jamaica.jpg\"]\n         ];\n     }\n "
        },
        {
          "filename": "tests/HelpersTest.php",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -101,4 +101,11 @@ public function testLengthEqual(float $a, float $b, bool $expected): void\n         $this->assertSame($expected, Helpers::lengthEqual(-$a, -$b));\n         $this->assertSame($expected, Helpers::lengthEqual(-$b, -$a));\n     }\n+\n+    \n+    public function testCustomProtocolParsing(): void\n+    {\n+        $uri = \"mock://path/to/resource\";\n+        $this->assertSame($uri, Helpers::build_url(\"\", \"\", \"\", $uri));\n+    }\n }"
        },
        {
          "filename": "tests/OptionsTest.php",
          "status": "modified",
          "additions": 40,
          "deletions": 0,
          "patch": "@@ -95,4 +95,44 @@ public function testSetters()\n         $option->setChroot(['test11']);\n         $this->assertEquals(['test11'], $option->getChroot());\n     }\n+\n+    public function testAllowedProtocols()\n+    {\n+        $options = new Options([\"isRemoteEnabled\" => false]);\n+        $options->setAllowedProtocols([\"http://\"]);\n+        $allowedProtocols = $options->getAllowedProtocols();\n+        $this->assertIsArray($allowedProtocols);\n+        $this->assertEquals(1, count($allowedProtocols));\n+        $this->assertArrayHasKey(\"http://\", $allowedProtocols);\n+        $this->assertIsArray($allowedProtocols[\"http://\"]);\n+        $this->assertArrayHasKey(\"rules\", $allowedProtocols[\"http://\"]);\n+        $this->assertIsArray($allowedProtocols[\"http://\"][\"rules\"]);\n+        $this->assertEquals(1, count($allowedProtocols[\"http://\"][\"rules\"]));\n+        $this->assertEquals([$options, \"validateRemoteUri\"], $allowedProtocols[\"http://\"][\"rules\"][0]);\n+\n+        [$validation_result] = $allowedProtocols[\"http://\"][\"rules\"][0](\"http://example.com/\");\n+        $this->assertFalse($validation_result);\n+\n+        \n+        $mock_protocol = [\n+            \"mock://\" => [\n+                \"rules\" => [\n+                    function ($uri) { return [true, null]; }\n+                ]\n+            ]\n+        ];\n+        $options->setAllowedProtocols($mock_protocol);\n+        $allowedProtocols = $options->getAllowedProtocols();\n+        $this->assertIsArray($allowedProtocols);\n+        $this->assertEquals(1, count($allowedProtocols));\n+        $this->assertArrayHasKey(\"mock://\", $allowedProtocols);\n+        $this->assertIsArray($allowedProtocols[\"mock://\"]);\n+        $this->assertArrayHasKey(\"rules\", $allowedProtocols[\"mock://\"]);\n+        $this->assertIsArray($allowedProtocols[\"mock://\"][\"rules\"]);\n+        $this->assertEquals(1, count($allowedProtocols[\"mock://\"][\"rules\"]));\n+        $this->assertEquals($mock_protocol[\"mock://\"][\"rules\"][0], $allowedProtocols[\"mock://\"][\"rules\"][0]);\n+\n+        [$validation_result] = $allowedProtocols[\"mock://\"][\"rules\"][0](\"mock://example.com/\");\n+        $this->assertTrue($validation_result);\n+    }\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 7,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c8aef1fd36697fa7c11bd70f2dcd519138352fa7",
            "date": "2025-01-12T20:45:17Z",
            "author_login": "bsweeney"
          },
          {
            "sha": "dbaec915f060a2ec8403353004bec9edc2925e4e",
            "date": "2025-01-02T01:45:18Z",
            "author_login": "bsweeney"
          },
          {
            "sha": "4962521eff3649d27b161cced23260ff6e573c9b",
            "date": "2025-01-02T01:08:23Z",
            "author_login": "bsweeney"
          },
          {
            "sha": "3954d53b10e102fb58cfce266cb9255ac96a93eb",
            "date": "2025-01-02T01:07:11Z",
            "author_login": "bsweeney"
          },
          {
            "sha": "ad11f84d74e6994d3544fd3a5daf3737f87d851a",
            "date": "2025-01-02T00:59:07Z",
            "author_login": "bsweeney"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-73",
    "description": "External Control of File Name or Path in GitHub repository dompdf/dompdf prior to 2.0.0.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-07-18T15:15:08.153",
    "last_modified": "2024-11-21T07:00:54.880",
    "fix_date": "2022-04-18T19:17:23Z"
  },
  "references": [
    {
      "url": "https://github.com/dompdf/dompdf/commit/99aeec1efec9213e87098d42eb09439e7ee0bb6a",
      "source": "security@huntr.dev",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/a6da5e5e-86be-499a-a3c3-2950f749202a",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2023/07/msg00017.html",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://github.com/dompdf/dompdf/commit/99aeec1efec9213e87098d42eb09439e7ee0bb6a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/a6da5e5e-86be-499a-a3c3-2950f749202a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2023/07/msg00017.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:11.498913",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "dompdf",
    "owner": "dompdf",
    "created_at": "2012-11-12T20:47:16Z",
    "updated_at": "2025-01-14T14:37:08Z",
    "pushed_at": "2025-01-14T12:20:44Z",
    "size": 19290,
    "stars": 10652,
    "forks": 1805,
    "open_issues": 561,
    "watchers": 10652,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "develop"
    ],
    "languages": {
      "PHP": 1351094,
      "HTML": 53927,
      "CSS": 7482
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-2.1"
    },
    "collected_at": "2025-01-14T17:18:22.526016"
  }
}