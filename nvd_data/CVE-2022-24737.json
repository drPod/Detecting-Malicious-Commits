{
  "cve_id": "CVE-2022-24737",
  "github_data": {
    "repository": "httpie/httpie",
    "fix_commit": "65ab7d5caaaf2f95e61f9dd65441801c2ddee38b",
    "related_commits": [
      "65ab7d5caaaf2f95e61f9dd65441801c2ddee38b",
      "65ab7d5caaaf2f95e61f9dd65441801c2ddee38b"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "65ab7d5caaaf2f95e61f9dd65441801c2ddee38b",
      "commit_date": "2022-02-01T09:14:24Z",
      "author": {
        "login": "isidentical",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Implement new style cookies",
        "length": 27,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 1523,
        "additions": 1406,
        "deletions": 117
      },
      "files": [
        {
          "filename": "docs/README.md",
          "status": "modified",
          "additions": 140,
          "deletions": 0,
          "patch": "@@ -2157,6 +2157,85 @@ $ http --session-read-only=./ro-session.json pie.dev/headers Custom-Header:orig-\n $ http --session-read-only=./ro-session.json pie.dev/headers Custom-Header:new-value\n ```\n \n+### Host-based Cookie Policy\n+\n+Cookies in stored HTTPie sessions have a `domain` field which is binding them to the\n+specified hostname. For example, in the following session:\n+\n+```json\n+{\n+    \"cookies\": [\n+        {\n+            \"domain\": \"pie.dev\",\n+            \"name\": \"secret_cookie\",\n+            \"value\": \"value_1\"\n+        },\n+        {\n+            \"domain\": \"httpbin.org\",\n+            \"name\": \"secret_cookie\",\n+            \"value\": \"value_2\"\n+        }\n+    ]\n+}\n+```\n+\n+we will send `Cookie:secret_cookie=value_1` only when you are making a request against `pie.dev` (it\n+also includes the domains, like `api.pie.dev`), and `Cookie:secret_cookie=value_2` when you use `httpbin.org`.\n+\n+```bash\n+$ http --session=./session.json pie.dev/cookies\n+```\n+\n+```json\n+{\n+    \"cookies\": {\n+        \"secret_cookie\": \"value_1\"\n+    }\n+}\n+```\n+\n+```bash\n+$ http --session=./session.json httpbin.org/cookies\n+```\n+\n+```json\n+{\n+    \"cookies\": {\n+        \"secret_cookie\": \"value_2\"\n+    }\n+}\n+```\n+\n+If you want to make a cookie domain unbound, you can simply set the `domain`\n+field to `null` by editing the session file directly:\n+\n+```json\n+{\n+    \"cookies\": [\n+        {\n+            \"domain\": null,\n+            \"expires\": null,\n+            \"name\": \"generic_cookie\",\n+            \"path\": \"/\",\n+            \"secure\": false,\n+            \"value\": \"generic_value\"\n+        }\n+    ]\n+}\n+```\n+\n+```bash\n+$ http --session=./session.json pie.dev/cookies\n+```\n+\n+```json\n+{\n+    \"cookies\": {\n+        \"generic_cookie\": \"generic_value\"\n+    }\n+}\n+```\n+\n ### Cookie Storage Behavior\n \n **TL;DR:** Cookie storage priority: Server response > Command line request > Session file\n@@ -2208,6 +2287,50 @@ Expired cookies are never stored.\n If a cookie in a session file expires, it will be removed before sending a new request.\n If the server expires an existing cookie, it will also be removed from the session file.\n \n+### Upgrading Sessions\n+\n+In rare circumstances, HTTPie makes changes in it's session layout. For allowing a smoother transition of existing files\n+from the old layout to the new layout we offer 2 interfaces:\n+\n+- `httpie cli sessions upgrade`\n+- `httpie cli sessions upgrade-all`\n+\n+\n+With `httpie cli sessions upgrade`, you can upgrade a single session with it's name (or it's path, if it is an\n+[anonymous session](#anonymous-sessions)) and the hostname it belongs to. For example:\n+\n+([named session](#named-sessions))\n+\n+```bash\n+$ httpie cli sessions upgrade pie.dev api_auth\n+Refactored 'api_auth' (for 'pie.dev') to the version 3.1.0.\n+```\n+\n+([anonymous session](#anonymous-sessions))\n+\n+```bash\n+$ httpie cli sessions upgrade pie.dev ./session.json\n+Refactored 'session' (for 'pie.dev') to the version 3.1.0.\n+```\n+\n+If you want to upgrade every existing [named session](#named-sessions), you can use `httpie cli sessions upgrade-all` (be aware\n+that this won't upgrade [anonymous sessions](#anonymous-sessions)):\n+\n+```bash\n+$ httpie cli sessions upgrade-all\n+Refactored 'api_auth' (for 'pie.dev') to the version 3.1.0.\n+Refactored 'login_cookies' (for 'httpie.io') to the version 3.1.0.\n+```\n+\n+#### Additional Customizations\n+\n+| Flag             | Description                                                                                                                                                                                                                  |\n+|------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| `--bind-cookies` | Bind all the unbound cookies to the hostname that session belongs. By default, if the cookie is unbound (the `domain` attribute does not exist / set to an empty string) then it will still continue to be a generic cookie. |\n+\n+These flags can be used to customize the defaults during an `upgrade` operation. They can\n+be used in both `sessions upgrade` and `sessions upgrade-all`.\n+\n ## Config\n \n HTTPie uses a simple `config.json` file.\n@@ -2299,6 +2422,23 @@ And since there\u2019s neither data nor `EOF`, it will get stuck. So unless you\u2019r\n \n Also, it might be good to set a connection `--timeout` limit to prevent your program from hanging if the server never responds.\n \n+### Security\n+\n+#### Exposure of Cookies To The 3rd Party Hosts On Redirects\n+\n+*Vulnerability Type*: [CWE-200](https://cwe.mitre.org/data/definitions/200.html)\n+*Severity Level*: LOW\n+*Affected Versions*: `<3.1.0`\n+\n+The handling of [cookies](#cookies) was not compatible with the [RFC 6265](https://datatracker.ietf.org/doc/html/rfc6265)\n+on the point of handling the `Domain` attribute when they were saved into [session](#sessions) files. All cookies were shared\n+across all hosts during the runtime, including redirects to the 3rd party hosts.\n+\n+This vulnerability has been fixed in [3.1.0](https://github.com/httpie/httpie/releases/tag/3.1.0) and the\n+[`httpie cli sessions upgrade`](#upgrading-sessions)/[`httpie cli sessions upgrade-all`]((#upgrading-sessions) commands\n+have been put in place in order to allow a smooth transition to the new session layout from the existing [session](#sessions)\n+files.\n+\n ## Plugin manager\n \n HTTPie offers extensibility through a [plugin API](https://github.com/httpie/httpie/blob/master/httpie/plugins/base.py),"
        },
        {
          "filename": "httpie/client.py",
          "status": "modified",
          "additions": 2,
          "deletions": 4,
          "patch": "@@ -44,6 +44,7 @@ def collect_messages(\n     httpie_session_headers = None\n     if args.session or args.session_read_only:\n         httpie_session = get_httpie_session(\n+            env=env,\n             config_dir=env.config.directory,\n             session_name=args.session or args.session_read_only,\n             host=args.headers.get('Host'),\n@@ -130,10 +131,7 @@ def collect_messages(\n     if httpie_session:\n         if httpie_session.is_new() or not args.session_read_only:\n             httpie_session.cookies = requests_session.cookies\n-            httpie_session.remove_cookies(\n-                # TODO: take path & domain into account?\n-                cookie['name'] for cookie in expired_cookies\n-            )\n+            httpie_session.remove_cookies(expired_cookies)\n             httpie_session.save()\n \n "
        },
        {
          "filename": "httpie/config.py",
          "status": "modified",
          "additions": 40,
          "deletions": 20,
          "patch": "@@ -1,7 +1,7 @@\n import json\n import os\n from pathlib import Path\n-from typing import Union\n+from typing import Any, Dict, Union\n \n from . import __version__\n from .compat import is_windows\n@@ -62,6 +62,21 @@ class ConfigFileError(Exception):\n     pass\n \n \n+def read_raw_config(config_type: str, path: Path) -> Dict[str, Any]:\n+    try:\n+        with path.open(encoding=UTF8) as f:\n+            try:\n+                return json.load(f)\n+            except ValueError as e:\n+                raise ConfigFileError(\n+                    f'invalid {config_type} file: {e} [{path}]'\n+                )\n+    except FileNotFoundError:\n+        pass\n+    except OSError as e:\n+        raise ConfigFileError(f'cannot read {config_type} file: {e}')\n+\n+\n class BaseConfigDict(dict):\n     name = None\n     helpurl = None\n@@ -77,26 +92,25 @@ def ensure_directory(self):\n     def is_new(self) -> bool:\n         return not self.path.exists()\n \n+    def pre_process_data(self, data: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"Hook for processing the incoming config data.\"\"\"\n+        return data\n+\n+    def post_process_data(self, data: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"Hook for processing the outgoing config data.\"\"\"\n+        return data\n+\n     def load(self):\n         config_type = type(self).__name__.lower()\n-        try:\n-            with self.path.open(encoding=UTF8) as f:\n-                try:\n-                    data = json.load(f)\n-                except ValueError as e:\n-                    raise ConfigFileError(\n-                        f'invalid {config_type} file: {e} [{self.path}]'\n-                    )\n-                self.update(data)\n-        except FileNotFoundError:\n-            pass\n-        except OSError as e:\n-            raise ConfigFileError(f'cannot read {config_type} file: {e}')\n-\n-    def save(self):\n-        self['__meta__'] = {\n-            'httpie': __version__\n-        }\n+        data = read_raw_config(config_type, self.path)\n+        if data is not None:\n+            data = self.pre_process_data(data)\n+            self.update(data)\n+\n+    def save(self, *, bump_version: bool = False):\n+        self.setdefault('__meta__', {})\n+        if bump_version or 'httpie' not in self['__meta__']:\n+            self['__meta__']['httpie'] = __version__\n         if self.helpurl:\n             self['__meta__']['help'] = self.helpurl\n \n@@ -106,13 +120,19 @@ def save(self):\n         self.ensure_directory()\n \n         json_string = json.dumps(\n-            obj=self,\n+            obj=self.post_process_data(self),\n             indent=4,\n             sort_keys=True,\n             ensure_ascii=True,\n         )\n         self.path.write_text(json_string + '\\n', encoding=UTF8)\n \n+    @property\n+    def version(self):\n+        return self.get(\n+            '__meta__', {}\n+        ).get('httpie', __version__)\n+\n \n class Config(BaseConfigDict):\n     FILENAME = 'config.json'"
        },
        {
          "filename": "httpie/manager/cli.py",
          "status": "modified",
          "additions": 42,
          "deletions": 1,
          "patch": "@@ -2,6 +2,15 @@\n from httpie.cli.argparser import HTTPieManagerArgumentParser\n from httpie import __version__\n \n+CLI_SESSION_UPGRADE_FLAGS = [\n+    {\n+        'variadic': ['--bind-cookies'],\n+        'action': 'store_true',\n+        'default': False,\n+        'help': 'Bind domainless cookies to the host that session belongs.'\n+    }\n+]\n+\n COMMANDS = {\n     'plugins': {\n         'help': 'Manage HTTPie plugins.',\n@@ -34,6 +43,34 @@\n             'List all installed HTTPie plugins.'\n         ],\n     },\n+    'cli': {\n+        'help': 'Manage HTTPie for Terminal',\n+        'sessions': {\n+            'help': 'Manage HTTPie sessions',\n+            'upgrade': [\n+                'Upgrade the given HTTPie session with the latest '\n+                'layout. A list of changes between different session versions '\n+                'can be found in the official documentation.',\n+                {\n+                    'dest': 'hostname',\n+                    'metavar': 'HOSTNAME',\n+                    'help': 'The host this session belongs.'\n+                },\n+                {\n+                    'dest': 'session',\n+                    'metavar': 'SESSION_NAME_OR_PATH',\n+                    'help': 'The name or the path for the session that will be upgraded.'\n+                },\n+                *CLI_SESSION_UPGRADE_FLAGS\n+            ],\n+            'upgrade-all': [\n+                'Upgrade all named sessions with the latest layout. A list of '\n+                'changes between different session versions can be found in the official '\n+                'documentation.',\n+                *CLI_SESSION_UPGRADE_FLAGS\n+            ],\n+        }\n+    }\n }\n \n \n@@ -54,6 +91,8 @@ def generate_subparsers(root, parent_parser, definitions):\n     )\n     for command, properties in definitions.items():\n         is_subparser = isinstance(properties, dict)\n+        properties = properties.copy()\n+\n         descr = properties.pop('help', None) if is_subparser else properties.pop(0)\n         command_parser = actions.add_parser(command, description=descr)\n         command_parser.root = root\n@@ -62,7 +101,9 @@ def generate_subparsers(root, parent_parser, definitions):\n             continue\n \n         for argument in properties:\n-            command_parser.add_argument(**argument)\n+            argument = argument.copy()\n+            variadic = argument.pop('variadic', [])\n+            command_parser.add_argument(*variadic, **argument)\n \n \n parser = HTTPieManagerArgumentParser("
        },
        {
          "filename": "httpie/manager/core.py",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -1,9 +1,11 @@\n import argparse\n+from typing import Optional\n \n from httpie.context import Environment\n from httpie.manager.plugins import PluginInstaller\n from httpie.status import ExitStatus\n from httpie.manager.cli import missing_subcommand, parser\n+from httpie.manager.tasks import CLI_TASKS\n \n MSG_COMMAND_CONFUSION = '''\\\n This command is only for managing HTTPie plugins.\n@@ -22,12 +24,21 @@\n '''.rstrip(\"\\n\").format(args='POST pie.dev/post hello=world')\n \n \n+def dispatch_cli_task(env: Environment, action: Optional[str], args: argparse.Namespace) -> ExitStatus:\n+    if action is None:\n+        parser.error(missing_subcommand('cli'))\n+\n+    return CLI_TASKS[action](env, args)\n+\n+\n def program(args: argparse.Namespace, env: Environment) -> ExitStatus:\n     if args.action is None:\n         parser.error(MSG_NAKED_INVOCATION)\n \n     if args.action == 'plugins':\n         plugins = PluginInstaller(env, debug=args.debug)\n         return plugins.run(args.plugins_action, args)\n+    elif args.action == 'cli':\n+        return dispatch_cli_task(env, args.cli_action, args)\n \n     return ExitStatus.SUCCESS"
        },
        {
          "filename": "httpie/manager/tasks.py",
          "status": "added",
          "additions": 134,
          "deletions": 0,
          "patch": "@@ -0,0 +1,134 @@\n+import argparse\n+from typing import TypeVar, Callable, Tuple\n+\n+from httpie.sessions import SESSIONS_DIR_NAME, Session, get_httpie_session\n+from httpie.status import ExitStatus\n+from httpie.context import Environment\n+from httpie.manager.cli import missing_subcommand, parser\n+\n+T = TypeVar('T')\n+\n+CLI_TASKS = {}\n+\n+\n+def task(name: str) -> Callable[[T], T]:\n+    def wrapper(func: T) -> T:\n+        CLI_TASKS[name] = func\n+        return func\n+    return wrapper\n+\n+\n+@task('sessions')\n+def cli_sessions(env: Environment, args: argparse.Namespace) -> ExitStatus:\n+    action = args.cli_sessions_action\n+    if action is None:\n+        parser.error(missing_subcommand('cli', 'sessions'))\n+\n+    if action == 'upgrade':\n+        return cli_upgrade_session(env, args)\n+    elif action == 'upgrade-all':\n+        return cli_upgrade_all_sessions(env, args)\n+    else:\n+        raise ValueError(f'Unexpected action: {action}')\n+\n+\n+def is_version_greater(version_1: str, version_2: str) -> bool:\n+    # In an ideal scenerio, we would depend on `packaging` in order\n+    # to offer PEP 440 compatible parsing. But since it might not be\n+    # commonly available for outside packages, and since we are only\n+    # going to parse HTTPie's own version it should be fine to compare\n+    # this in a SemVer subset fashion.\n+\n+    def split_version(version: str) -> Tuple[int, ...]:\n+        parts = []\n+        for part in version.split('.')[:3]:\n+            try:\n+                parts.append(int(part))\n+            except ValueError:\n+                break\n+        return tuple(parts)\n+\n+    return split_version(version_1) > split_version(version_2)\n+\n+\n+def fix_cookie_layout(session: Session, hostname: str, args: argparse.Namespace) -> None:\n+    if not isinstance(session['cookies'], dict):\n+        return None\n+\n+    session['cookies'] = [\n+        {\n+            'name': key,\n+            **value\n+        }\n+        for key, value in session['cookies'].items()\n+    ]\n+    for cookie in session.cookies:\n+        if cookie.domain == '':\n+            if args.bind_cookies:\n+                cookie.domain = hostname\n+            else:\n+                cookie._rest['is_explicit_none'] = True\n+\n+\n+FIXERS_TO_VERSIONS = {\n+    '3.1.0': fix_cookie_layout\n+}\n+\n+\n+def upgrade_session(env: Environment, args: argparse.Namespace, hostname: str, session_name: str):\n+    session = get_httpie_session(\n+        env=env,\n+        config_dir=env.config.directory,\n+        session_name=session_name,\n+        host=hostname,\n+        url=hostname,\n+        refactor_mode=True\n+    )\n+\n+    session_name = session.path.stem\n+    if session.is_new():\n+        env.log_error(f'{session_name!r} (for {hostname!r}) does not exist.')\n+        return ExitStatus.ERROR\n+\n+    fixers = [\n+        fixer\n+        for version, fixer in FIXERS_TO_VERSIONS.items()\n+        if is_version_greater(version, session.version)\n+    ]\n+\n+    if len(fixers) == 0:\n+        env.stdout.write(f'{session_name!r} (for {hostname!r}) is already up-to-date.\\n')\n+        return ExitStatus.SUCCESS\n+\n+    for fixer in fixers:\n+        fixer(session, hostname, args)\n+\n+    session.save(bump_version=True)\n+    env.stdout.write(f'Refactored {session_name!r} (for {hostname!r}) to the version {session.version}.\\n')\n+    return ExitStatus.SUCCESS\n+\n+\n+def cli_upgrade_session(env: Environment, args: argparse.Namespace) -> ExitStatus:\n+    return upgrade_session(\n+        env,\n+        args=args,\n+        hostname=args.hostname,\n+        session_name=args.session\n+    )\n+\n+\n+def cli_upgrade_all_sessions(env: Environment, args: argparse.Namespace) -> ExitStatus:\n+    session_dir_path = env.config_dir / SESSIONS_DIR_NAME\n+\n+    status = ExitStatus.SUCCESS\n+    for host_path in session_dir_path.iterdir():\n+        hostname = host_path.name\n+        for session_path in host_path.glob(\"*.json\"):\n+            session_name = session_path.stem\n+            status |= upgrade_session(\n+                env,\n+                args=args,\n+                hostname=hostname,\n+                session_name=session_name\n+            )\n+    return status"
        },
        {
          "filename": "httpie/sessions.py",
          "status": "modified",
          "additions": 170,
          "deletions": 36,
          "patch": "@@ -6,15 +6,17 @@\n import re\n \n from http.cookies import SimpleCookie\n+from http.cookiejar import Cookie\n from pathlib import Path\n-from typing import Iterable, Optional, Union\n-from urllib.parse import urlsplit\n+from typing import Any, Dict, Optional, Union\n \n from requests.auth import AuthBase\n-from requests.cookies import RequestsCookieJar, create_cookie\n+from requests.cookies import RequestsCookieJar, remove_cookie_by_name\n \n+from .context import Environment\n from .cli.dicts import HTTPHeadersDict\n from .config import BaseConfigDict, DEFAULT_CONFIG_DIR\n+from .utils import url_as_host\n from .plugins.registry import plugin_manager\n \n \n@@ -26,27 +28,88 @@\n # <https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Requests>\n SESSION_IGNORED_HEADER_PREFIXES = ['Content-', 'If-']\n \n+# Cookie related options\n+KEPT_COOKIE_OPTIONS = ['name', 'expires', 'path', 'value', 'domain', 'secure']\n+DEFAULT_COOKIE_PATH = '/'\n+\n+INSECURE_COOKIE_JAR_WARNING = '''\\\n+Outdated layout detected for the current session. Please consider updating it,\n+in order to not get affected by potential security problems.\n+\n+For fixing the current session:\n+\n+    With binding all cookies to the current host (secure):\n+        $ httpie cli sessions upgrade --bind-cookies {hostname} {session_id}\n+\n+    Without binding cookies (leaving them as is) (insecure):\n+        $ httpie cli sessions upgrade {hostname} {session_id}\n+'''\n+\n+INSECURE_COOKIE_JAR_WARNING_FOR_NAMED_SESSIONS = '''\\\n+\n+For fixing all named sessions:\n+\n+    With binding all cookies to the current host (secure):\n+        $ httpie cli sessions upgrade-all --bind-cookies\n+\n+    Without binding cookies (leaving them as is) (insecure):\n+        $ httpie cli sessions upgrade-all\n+\n+See https://pie.co/docs/security for more information.\n+'''\n+\n+\n+def is_anonymous_session(session_name: str) -> bool:\n+    return os.path.sep in session_name\n+\n+\n+def materialize_cookie(cookie: Cookie) -> Dict[str, Any]:\n+    materialized_cookie = {\n+        option: getattr(cookie, option)\n+        for option in KEPT_COOKIE_OPTIONS\n+    }\n+\n+    if (\n+        cookie._rest.get('is_explicit_none')\n+        and materialized_cookie['domain'] == ''\n+    ):\n+        materialized_cookie['domain'] = None\n+\n+    return materialized_cookie\n+\n \n def get_httpie_session(\n+    env: Environment,\n     config_dir: Path,\n     session_name: str,\n     host: Optional[str],\n     url: str,\n+    *,\n+    refactor_mode: bool = False\n ) -> 'Session':\n-    if os.path.sep in session_name:\n+    bound_hostname = host or url_as_host(url)\n+    if not bound_hostname:\n+        # HACK/FIXME: httpie-unixsocket's URLs have no hostname.\n+        bound_hostname = 'localhost'\n+\n+    # host:port => host_port\n+    hostname = bound_hostname.replace(':', '_')\n+    if is_anonymous_session(session_name):\n         path = os.path.expanduser(session_name)\n+        session_id = path\n     else:\n-        hostname = host or urlsplit(url).netloc.split('@')[-1]\n-        if not hostname:\n-            # HACK/FIXME: httpie-unixsocket's URLs have no hostname.\n-            hostname = 'localhost'\n-\n-        # host:port => host_port\n-        hostname = hostname.replace(':', '_')\n         path = (\n             config_dir / SESSIONS_DIR_NAME / hostname / f'{session_name}.json'\n         )\n-    session = Session(path)\n+        session_id = session_name\n+\n+    session = Session(\n+        path,\n+        env=env,\n+        session_id=session_id,\n+        bound_host=bound_hostname.split(':')[0],\n+        refactor_mode=refactor_mode\n+    )\n     session.load()\n     return session\n \n@@ -55,15 +118,86 @@ class Session(BaseConfigDict):\n     helpurl = 'https://httpie.io/docs#sessions'\n     about = 'HTTPie session file'\n \n-    def __init__(self, path: Union[str, Path]):\n+    def __init__(\n+        self,\n+        path: Union[str, Path],\n+        env: Environment,\n+        bound_host: str,\n+        session_id: str,\n+        refactor_mode: bool = False,\n+    ):\n         super().__init__(path=Path(path))\n         self['headers'] = {}\n-        self['cookies'] = {}\n+        self['cookies'] = []\n         self['auth'] = {\n             'type': None,\n             'username': None,\n             'password': None\n         }\n+        self.env = env\n+        self.cookie_jar = RequestsCookieJar()\n+        self.session_id = session_id\n+        self.bound_host = bound_host\n+        self.refactor_mode = refactor_mode\n+\n+    def pre_process_data(self, data: Dict[str, Any]) -> Dict[str, Any]:\n+        cookies = data.get('cookies')\n+        if isinstance(cookies, dict):\n+            normalized_cookies = [\n+                {\n+                    'name': key,\n+                    **value\n+                }\n+                for key, value in cookies.items()\n+            ]\n+        elif isinstance(cookies, list):\n+            normalized_cookies = cookies\n+        else:\n+            normalized_cookies = []\n+\n+        should_issue_warning = False\n+        for cookie in normalized_cookies:\n+            domain = cookie.get('domain', '')\n+            if domain == '' and isinstance(cookies, dict):\n+                should_issue_warning = True\n+            elif domain is None:\n+                # domain = None means explicitly lack of cookie, though\n+                # requests requires domain to be string so we'll cast it\n+                # manually.\n+                cookie['domain'] = ''\n+                cookie['rest'] = {'is_explicit_none': True}\n+\n+            self.cookie_jar.set(**cookie)\n+\n+        if should_issue_warning and not self.refactor_mode:\n+            warning = INSECURE_COOKIE_JAR_WARNING.format(hostname=self.bound_host, session_id=self.session_id)\n+            if not is_anonymous_session(self.session_id):\n+                warning += INSECURE_COOKIE_JAR_WARNING_FOR_NAMED_SESSIONS\n+\n+            self.env.log_error(\n+                warning,\n+                level='warning'\n+            )\n+\n+        return data\n+\n+    def post_process_data(self, data: Dict[str, Any]) -> Dict[str, Any]:\n+        cookies = data.get('cookies')\n+        # Save in the old-style fashion\n+\n+        normalized_cookies = [\n+            materialize_cookie(cookie)\n+            for cookie in self.cookie_jar\n+        ]\n+        if isinstance(cookies, dict):\n+            data['cookies'] = {\n+                cookie.pop('name'): cookie\n+                for cookie in normalized_cookies\n+            }\n+        else:\n+            data['cookies'] = normalized_cookies\n+\n+        return data\n \n     def update_headers(self, request_headers: HTTPHeadersDict):\n         \"\"\"\n@@ -73,10 +207,10 @@ def update_headers(self, request_headers: HTTPHeadersDict):\n         \"\"\"\n         headers = self.headers\n         for name, value in request_headers.copy().items():\n-\n             if value is None:\n                 continue  # Ignore explicitly unset headers\n \n+            original_value = value\n             if type(value) is not str:\n                 value = value.decode()\n \n@@ -85,8 +219,15 @@ def update_headers(self, request_headers: HTTPHeadersDict):\n \n             if name.lower() == 'cookie':\n                 for cookie_name, morsel in SimpleCookie(value).items():\n-                    self['cookies'][cookie_name] = {'value': morsel.value}\n-                del request_headers[name]\n+                    if not morsel['path']:\n+                        morsel['path'] = DEFAULT_COOKIE_PATH\n+                    self.cookie_jar.set(cookie_name, morsel)\n+\n+                all_cookie_headers = request_headers.getall(name)\n+                if len(all_cookie_headers) > 1:\n+                    all_cookie_headers.remove(original_value)\n+                else:\n+                    request_headers.popall(name)\n                 continue\n \n             for prefix in SESSION_IGNORED_HEADER_PREFIXES:\n@@ -103,23 +244,21 @@ def headers(self) -> HTTPHeadersDict:\n \n     @property\n     def cookies(self) -> RequestsCookieJar:\n-        jar = RequestsCookieJar()\n-        for name, cookie_dict in self['cookies'].items():\n-            jar.set_cookie(create_cookie(\n-                name, cookie_dict.pop('value'), **cookie_dict))\n-        jar.clear_expired_cookies()\n-        return jar\n+        self.cookie_jar.clear_expired_cookies()\n+        return self.cookie_jar\n \n     @cookies.setter\n     def cookies(self, jar: RequestsCookieJar):\n-        # <https://docs.python.org/3/library/cookielib.html#cookie-objects>\n-        stored_attrs = ['value', 'path', 'secure', 'expires']\n-        self['cookies'] = {}\n-        for cookie in jar:\n-            self['cookies'][cookie.name] = {\n-                attname: getattr(cookie, attname)\n-                for attname in stored_attrs\n-            }\n+        self.cookie_jar = jar\n+\n+    def remove_cookies(self, cookies: Dict[str, str]):\n+        for cookie in cookies:\n+            remove_cookie_by_name(\n+                self.cookie_jar,\n+                cookie['name'],\n+                domain=cookie.get('domain', None),\n+                path=cookie.get('path', None)\n+            )\n \n     @property\n     def auth(self) -> Optional[AuthBase]:\n@@ -154,8 +293,3 @@ def auth(self) -> Optional[AuthBase]:\n     def auth(self, auth: dict):\n         assert {'type', 'raw_auth'} == auth.keys()\n         self['auth'] = auth\n-\n-    def remove_cookies(self, names: Iterable[str]):\n-        for name in names:\n-            if name in self['cookies']:\n-                del self['cookies'][name]"
        },
        {
          "filename": "httpie/utils.py",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -9,6 +9,7 @@\n from http.cookiejar import parse_ns_headers\n from pathlib import Path\n from pprint import pformat\n+from urllib.parse import urlsplit\n from typing import Any, List, Optional, Tuple, Callable, Iterable, TypeVar\n \n import requests.auth\n@@ -237,3 +238,7 @@ def unwrap_context(exc: Exception) -> Optional[Exception]:\n         return unwrap_context(context)\n     else:\n         return exc\n+\n+\n+def url_as_host(url: str) -> str:\n+    return urlsplit(url).netloc.split('@')[-1]"
        },
        {
          "filename": "setup.py",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -11,6 +11,7 @@\n tests_require = [\n     'pytest',\n     'pytest-httpbin>=0.0.6',\n+    'pytest-lazy-fixture>=0.0.6',\n     'responses',\n ]\n dev_require = ["
        },
        {
          "filename": "tests/conftest.py",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -4,7 +4,11 @@\n import pytest\n from pytest_httpbin import certs\n \n-from .utils import HTTPBIN_WITH_CHUNKED_SUPPORT_DOMAIN, HTTPBIN_WITH_CHUNKED_SUPPORT\n+from .utils import ( # noqa\n+    HTTPBIN_WITH_CHUNKED_SUPPORT_DOMAIN,\n+    HTTPBIN_WITH_CHUNKED_SUPPORT,\n+    mock_env\n+)\n from .utils.plugins_cli import ( # noqa\n     broken_plugin,\n     dummy_plugin,"
        },
        {
          "filename": "tests/fixtures/__init__.py",
          "status": "modified",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -1,6 +1,9 @@\n \"\"\"Test data\"\"\"\n+import json\n from pathlib import Path\n+from typing import Optional, Dict, Any\n \n+import httpie\n from httpie.encoding import UTF8\n from httpie.output.formatters.xml import pretty_xml, parse_xml\n \n@@ -19,10 +22,20 @@ def patharg(path):\n JSON_FILE_PATH = FIXTURES_ROOT / 'test.json'\n JSON_WITH_DUPE_KEYS_FILE_PATH = FIXTURES_ROOT / 'test_with_dupe_keys.json'\n BIN_FILE_PATH = FIXTURES_ROOT / 'test.bin'\n+\n XML_FILES_PATH = FIXTURES_ROOT / 'xmldata'\n XML_FILES_VALID = list((XML_FILES_PATH / 'valid').glob('*_raw.xml'))\n XML_FILES_INVALID = list((XML_FILES_PATH / 'invalid').glob('*.xml'))\n \n+SESSION_FILES_PATH = FIXTURES_ROOT / 'session_data'\n+SESSION_FILES_OLD = sorted((SESSION_FILES_PATH / 'old').glob('*.json'))\n+SESSION_FILES_NEW = sorted((SESSION_FILES_PATH / 'new').glob('*.json'))\n+\n+SESSION_VARIABLES = {\n+    '__version__': httpie.__version__,\n+    '__host__': 'null',\n+}\n+\n FILE_PATH_ARG = patharg(FILE_PATH)\n BIN_FILE_PATH_ARG = patharg(BIN_FILE_PATH)\n JSON_FILE_PATH_ARG = patharg(JSON_FILE_PATH)\n@@ -40,3 +53,14 @@ def patharg(path):\n UNICODE = FILE_CONTENT\n XML_DATA_RAW = '<?xml version=\"1.0\" encoding=\"utf-8\"?><root><e>text</e></root>'\n XML_DATA_FORMATTED = pretty_xml(parse_xml(XML_DATA_RAW))\n+\n+\n+def read_session_file(session_file: Path, *, extra_variables: Optional[Dict[str, str]] = None) -> Any:\n+    with open(session_file) as stream:\n+        data = stream.read()\n+\n+    session_vars = {**SESSION_VARIABLES, **(extra_variables or {})}\n+    for variable, value in session_vars.items():\n+        data = data.replace(variable, value)\n+\n+    return json.loads(data)"
        },
        {
          "filename": "tests/fixtures/session_data/new/cookies_dict.json",
          "status": "added",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -0,0 +1,31 @@\n+{\n+    \"__meta__\": {\n+        \"about\": \"HTTPie session file\",\n+        \"help\": \"https://httpie.io/docs#sessions\",\n+        \"httpie\": \"__version__\"\n+    },\n+    \"auth\": {\n+        \"password\": null,\n+        \"type\": null,\n+        \"username\": null\n+    },\n+    \"cookies\": [\n+        {\n+            \"domain\": __host__,\n+            \"expires\": null,\n+            \"name\": \"baz\",\n+            \"path\": \"/\",\n+            \"secure\": false,\n+            \"value\": \"quux\"\n+        },\n+        {\n+            \"domain\": __host__,\n+            \"expires\": null,\n+            \"name\": \"foo\",\n+            \"path\": \"/\",\n+            \"secure\": false,\n+            \"value\": \"bar\"\n+        }\n+    ],\n+    \"headers\": {}\n+}"
        },
        {
          "filename": "tests/fixtures/session_data/new/cookies_dict_dev_version.json",
          "status": "added",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -0,0 +1,31 @@\n+{\n+    \"__meta__\": {\n+        \"about\": \"HTTPie session file\",\n+        \"help\": \"https://httpie.io/docs#sessions\",\n+        \"httpie\": \"__version__\"\n+    },\n+    \"auth\": {\n+        \"password\": null,\n+        \"type\": null,\n+        \"username\": null\n+    },\n+    \"cookies\": [\n+        {\n+            \"domain\": __host__,\n+            \"expires\": null,\n+            \"name\": \"baz\",\n+            \"path\": \"/\",\n+            \"secure\": false,\n+            \"value\": \"quux\"\n+        },\n+        {\n+            \"domain\": __host__,\n+            \"expires\": null,\n+            \"name\": \"foo\",\n+            \"path\": \"/\",\n+            \"secure\": false,\n+            \"value\": \"bar\"\n+        }\n+    ],\n+    \"headers\": {}\n+}"
        },
        {
          "filename": "tests/fixtures/session_data/new/cookies_dict_with_extras.json",
          "status": "added",
          "additions": 33,
          "deletions": 0,
          "patch": "@@ -0,0 +1,33 @@\n+{\n+    \"__meta__\": {\n+        \"about\": \"HTTPie session file\",\n+        \"help\": \"https://httpie.io/docs#sessions\",\n+        \"httpie\": \"__version__\"\n+    },\n+    \"auth\": {\n+        \"raw_auth\": \"foo:bar\",\n+        \"type\": \"basic\"\n+    },\n+    \"cookies\": [\n+        {\n+            \"domain\": __host__,\n+            \"expires\": null,\n+            \"name\": \"baz\",\n+            \"path\": \"/\",\n+            \"secure\": false,\n+            \"value\": \"quux\"\n+        },\n+        {\n+            \"domain\": __host__,\n+            \"expires\": null,\n+            \"name\": \"foo\",\n+            \"path\": \"/\",\n+            \"secure\": false,\n+            \"value\": \"bar\"\n+        }\n+    ],\n+    \"headers\": {\n+        \"X-Data\": \"value\",\n+        \"X-Foo\": \"bar\"\n+    }\n+}"
        },
        {
          "filename": "tests/fixtures/session_data/new/empty_cookies_dict.json",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+{\n+    \"__meta__\": {\n+        \"about\": \"HTTPie session file\",\n+        \"help\": \"https://httpie.io/docs#sessions\",\n+        \"httpie\": \"__version__\"\n+    },\n+    \"auth\": {\n+        \"password\": null,\n+        \"type\": null,\n+        \"username\": null\n+    },\n+    \"cookies\": [],\n+    \"headers\": {}\n+}"
        },
        {
          "filename": "tests/fixtures/session_data/new/empty_cookies_list.json",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+{\n+    \"__meta__\": {\n+        \"about\": \"HTTPie session file\",\n+        \"help\": \"https://httpie.io/docs#sessions\",\n+        \"httpie\": \"__version__\"\n+    },\n+    \"auth\": {\n+        \"password\": null,\n+        \"type\": null,\n+        \"username\": null\n+    },\n+    \"cookies\": [],\n+    \"headers\": {}\n+}"
        },
        {
          "filename": "tests/fixtures/session_data/old/cookies_dict.json",
          "status": "added",
          "additions": 27,
          "deletions": 0,
          "patch": "@@ -0,0 +1,27 @@\n+{\n+    \"__meta__\": {\n+        \"about\": \"HTTPie session file\",\n+        \"help\": \"https://httpie.io/docs#sessions\",\n+        \"httpie\": \"3.0.2\"\n+    },\n+    \"auth\": {\n+        \"password\": null,\n+        \"type\": null,\n+        \"username\": null\n+    },\n+    \"cookies\": {\n+        \"baz\": {\n+            \"expires\": null,\n+            \"path\": \"/\",\n+            \"secure\": false,\n+            \"value\": \"quux\"\n+        },\n+        \"foo\": {\n+            \"expires\": null,\n+            \"path\": \"/\",\n+            \"secure\": false,\n+            \"value\": \"bar\"\n+        }\n+    },\n+    \"headers\": {}\n+}"
        },
        {
          "filename": "tests/fixtures/session_data/old/cookies_dict_dev_version.json",
          "status": "added",
          "additions": 27,
          "deletions": 0,
          "patch": "@@ -0,0 +1,27 @@\n+{\n+    \"__meta__\": {\n+        \"about\": \"HTTPie session file\",\n+        \"help\": \"https://httpie.io/docs#sessions\",\n+        \"httpie\": \"2.7.0.dev0\"\n+    },\n+    \"auth\": {\n+        \"password\": null,\n+        \"type\": null,\n+        \"username\": null\n+    },\n+    \"cookies\": {\n+        \"baz\": {\n+            \"expires\": null,\n+            \"path\": \"/\",\n+            \"secure\": false,\n+            \"value\": \"quux\"\n+        },\n+        \"foo\": {\n+            \"expires\": null,\n+            \"path\": \"/\",\n+            \"secure\": false,\n+            \"value\": \"bar\"\n+        }\n+    },\n+    \"headers\": {}\n+}"
        },
        {
          "filename": "tests/fixtures/session_data/old/cookies_dict_with_extras.json",
          "status": "added",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -0,0 +1,29 @@\n+{\n+    \"__meta__\": {\n+        \"about\": \"HTTPie session file\",\n+        \"help\": \"https://httpie.io/docs#sessions\",\n+        \"httpie\": \"3.0.2\"\n+    },\n+    \"auth\": {\n+        \"raw_auth\": \"foo:bar\",\n+        \"type\": \"basic\"\n+    },\n+    \"cookies\": {\n+        \"baz\": {\n+            \"expires\": null,\n+            \"path\": \"/\",\n+            \"secure\": false,\n+            \"value\": \"quux\"\n+        },\n+        \"foo\": {\n+            \"expires\": null,\n+            \"path\": \"/\",\n+            \"secure\": false,\n+            \"value\": \"bar\"\n+        }\n+    },\n+    \"headers\": {\n+        \"X-Data\": \"value\",\n+        \"X-Foo\": \"bar\"\n+    }\n+}"
        },
        {
          "filename": "tests/fixtures/session_data/old/empty_cookies_dict.json",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+{\n+    \"__meta__\": {\n+        \"about\": \"HTTPie session file\",\n+        \"help\": \"https://httpie.io/docs#sessions\",\n+        \"httpie\": \"3.0.2\"\n+    },\n+    \"auth\": {\n+        \"password\": null,\n+        \"type\": null,\n+        \"username\": null\n+    },\n+    \"cookies\": {},\n+    \"headers\": {}\n+}"
        },
        {
          "filename": "tests/fixtures/session_data/old/empty_cookies_list.json",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+{\n+    \"__meta__\": {\n+        \"about\": \"HTTPie session file\",\n+        \"help\": \"https://httpie.io/docs#sessions\",\n+        \"httpie\": \"3.0.2\"\n+    },\n+    \"auth\": {\n+        \"password\": null,\n+        \"type\": null,\n+        \"username\": null\n+    },\n+    \"cookies\": [],\n+    \"headers\": {}\n+}"
        },
        {
          "filename": "tests/test_cookie_on_redirects.py",
          "status": "added",
          "additions": 262,
          "deletions": 0,
          "patch": "@@ -0,0 +1,262 @@\n+import pytest\n+from .utils import http\n+\n+\n+@pytest.fixture\n+def remote_httpbin(httpbin_with_chunked_support):\n+    return httpbin_with_chunked_support\n+\n+\n+def _stringify(fixture):\n+    return fixture + ''\n+\n+\n+@pytest.mark.parametrize('instance', [\n+    pytest.lazy_fixture('httpbin'),\n+    pytest.lazy_fixture('remote_httpbin'),\n+])\n+def test_explicit_user_set_cookie(httpbin, instance):\n+    # User set cookies ARE NOT persisted within redirects\n+    # when there is no session, even on the same domain.\n+\n+    r = http(\n+        '--follow',\n+        httpbin + '/redirect-to',\n+        f'url=={_stringify(instance)}/cookies',\n+        'Cookie:a=b'\n+    )\n+    assert r.json == {'cookies': {}}\n+\n+\n+@pytest.mark.parametrize('instance', [\n+    pytest.lazy_fixture('httpbin'),\n+    pytest.lazy_fixture('remote_httpbin'),\n+])\n+def test_explicit_user_set_cookie_in_session(tmp_path, httpbin, instance):\n+    # User set cookies ARE persisted within redirects\n+    # when there is A session, even on the same domain.\n+\n+    r = http(\n+        '--follow',\n+        '--session',\n+        str(tmp_path / 'session.json'),\n+        httpbin + '/redirect-to',\n+        f'url=={_stringify(instance)}/cookies',\n+        'Cookie:a=b'\n+    )\n+    assert r.json == {'cookies': {'a': 'b'}}\n+\n+\n+@pytest.mark.parametrize('instance', [\n+    pytest.lazy_fixture('httpbin'),\n+    pytest.lazy_fixture('remote_httpbin'),\n+])\n+def test_saved_user_set_cookie_in_session(tmp_path, httpbin, instance):\n+    # User set cookies ARE persisted within redirects\n+    # when there is A session, even on the same domain.\n+\n+    http(\n+        '--follow',\n+        '--session',\n+        str(tmp_path / 'session.json'),\n+        httpbin + '/get',\n+        'Cookie:a=b'\n+    )\n+    r = http(\n+        '--follow',\n+        '--session',\n+        str(tmp_path / 'session.json'),\n+        httpbin + '/redirect-to',\n+        f'url=={_stringify(instance)}/cookies',\n+    )\n+    assert r.json == {'cookies': {'a': 'b'}}\n+\n+\n+@pytest.mark.parametrize('instance', [\n+    pytest.lazy_fixture('httpbin'),\n+    pytest.lazy_fixture('remote_httpbin'),\n+])\n+@pytest.mark.parametrize('session', [True, False])\n+def test_explicit_user_set_headers(httpbin, tmp_path, instance, session):\n+    # User set headers ARE persisted within redirects\n+    # even on different domains domain with or without\n+    # an active session.\n+    session_args = []\n+    if session:\n+        session_args.extend([\n+            '--session',\n+            str(tmp_path / 'session.json')\n+        ])\n+\n+    r = http(\n+        '--follow',\n+        *session_args,\n+        httpbin + '/redirect-to',\n+        f'url=={_stringify(instance)}/get',\n+        'X-Custom-Header:value'\n+    )\n+    assert 'X-Custom-Header' in r.json['headers']\n+\n+\n+@pytest.mark.parametrize('session', [True, False])\n+def test_server_set_cookie_on_redirect_same_domain(tmp_path, httpbin, session):\n+    # Server set cookies ARE persisted on the same domain\n+    # when they are forwarded.\n+\n+    session_args = []\n+    if session:\n+        session_args.extend([\n+            '--session',\n+            str(tmp_path / 'session.json')\n+        ])\n+\n+    r = http(\n+        '--follow',\n+        *session_args,\n+        httpbin + '/cookies/set/a/b',\n+    )\n+    assert r.json['cookies'] == {'a': 'b'}\n+\n+\n+@pytest.mark.parametrize('session', [True, False])\n+def test_server_set_cookie_on_redirect_different_domain(tmp_path, http_server, httpbin, session):\n+    # Server set cookies ARE persisted on different domains\n+    # when they are forwarded.\n+\n+    session_args = []\n+    if session:\n+        session_args.extend([\n+            '--session',\n+            str(tmp_path / 'session.json')\n+        ])\n+\n+    r = http(\n+        '--follow',\n+        *session_args,\n+        http_server + '/cookies/set-and-redirect',\n+        f\"X-Redirect-To:{httpbin + '/cookies'}\",\n+        'X-Cookies:a=b'\n+    )\n+    assert r.json['cookies'] == {'a': 'b'}\n+\n+\n+def test_saved_session_cookies_on_same_domain(tmp_path, httpbin):\n+    # Saved session cookies ARE persisted when making a new\n+    # request to the same domain.\n+    http(\n+        '--session',\n+        str(tmp_path / 'session.json'),\n+        httpbin + '/cookies/set/a/b'\n+    )\n+    r = http(\n+        '--session',\n+        str(tmp_path / 'session.json'),\n+        httpbin + '/cookies'\n+    )\n+    assert r.json == {'cookies': {'a': 'b'}}\n+\n+\n+def test_saved_session_cookies_on_different_domain(tmp_path, httpbin, remote_httpbin):\n+    # Saved session cookies ARE persisted when making a new\n+    # request to a different domain.\n+    http(\n+        '--session',\n+        str(tmp_path / 'session.json'),\n+        httpbin + '/cookies/set/a/b'\n+    )\n+    r = http(\n+        '--session',\n+        str(tmp_path / 'session.json'),\n+        remote_httpbin + '/cookies'\n+    )\n+    assert r.json == {'cookies': {}}\n+\n+\n+@pytest.mark.parametrize('initial_domain, first_request_domain, second_request_domain, expect_cookies', [\n+    (\n+        # Cookies are set by    Domain A\n+        # Initial domain is     Domain A\n+        # Redirected domain is  Domain A\n+        pytest.lazy_fixture('httpbin'),\n+        pytest.lazy_fixture('httpbin'),\n+        pytest.lazy_fixture('httpbin'),\n+        True,\n+    ),\n+    (\n+        # Cookies are set by    Domain A\n+        # Initial domain is     Domain B\n+        # Redirected domain is  Domain B\n+        pytest.lazy_fixture('httpbin'),\n+        pytest.lazy_fixture('remote_httpbin'),\n+        pytest.lazy_fixture('remote_httpbin'),\n+        False,\n+    ),\n+    (\n+        # Cookies are set by    Domain A\n+        # Initial domain is     Domain A\n+        # Redirected domain is  Domain B\n+        pytest.lazy_fixture('httpbin'),\n+        pytest.lazy_fixture('httpbin'),\n+        pytest.lazy_fixture('remote_httpbin'),\n+        False,\n+    ),\n+    (\n+        # Cookies are set by    Domain A\n+        # Initial domain is     Domain B\n+        # Redirected domain is  Domain A\n+        pytest.lazy_fixture('httpbin'),\n+        pytest.lazy_fixture('remote_httpbin'),\n+        pytest.lazy_fixture('httpbin'),\n+        True,\n+    ),\n+])\n+def test_saved_session_cookies_on_redirect(tmp_path, initial_domain, first_request_domain, second_request_domain, expect_cookies):\n+    http(\n+        '--session',\n+        str(tmp_path / 'session.json'),\n+        initial_domain + '/cookies/set/a/b'\n+    )\n+    r = http(\n+        '--session',\n+        str(tmp_path / 'session.json'),\n+        '--follow',\n+        first_request_domain + '/redirect-to',\n+        f'url=={_stringify(second_request_domain)}/cookies'\n+    )\n+    if expect_cookies:\n+        expected_data = {'cookies': {'a': 'b'}}\n+    else:\n+        expected_data = {'cookies': {}}\n+    assert r.json == expected_data\n+\n+\n+def test_saved_session_cookie_pool(tmp_path, httpbin, remote_httpbin):\n+    http(\n+        '--session',\n+        str(tmp_path / 'session.json'),\n+        httpbin + '/cookies/set/a/b'\n+    )\n+    http(\n+        '--session',\n+        str(tmp_path / 'session.json'),\n+        remote_httpbin + '/cookies/set/a/c'\n+    )\n+    http(\n+        '--session',\n+        str(tmp_path / 'session.json'),\n+        remote_httpbin + '/cookies/set/b/d'\n+    )\n+\n+    response = http(\n+        '--session',\n+        str(tmp_path / 'session.json'),\n+        httpbin + '/cookies'\n+    )\n+    assert response.json['cookies'] == {'a': 'b'}\n+\n+    response = http(\n+        '--session',\n+        str(tmp_path / 'session.json'),\n+        remote_httpbin + '/cookies'\n+    )\n+    assert response.json['cookies'] == {'a': 'c', 'b': 'd'}"
        },
        {
          "filename": "tests/test_httpie_cli.py",
          "status": "added",
          "additions": 125,
          "deletions": 0,
          "patch": "@@ -0,0 +1,125 @@\n+import pytest\n+import shutil\n+import json\n+from httpie.sessions import SESSIONS_DIR_NAME\n+from httpie.status import ExitStatus\n+from tests.utils import DUMMY_HOST, httpie\n+from tests.fixtures import SESSION_FILES_PATH, SESSION_FILES_NEW, SESSION_FILES_OLD, read_session_file\n+\n+\n+OLD_SESSION_FILES_PATH = SESSION_FILES_PATH / 'old'\n+\n+\n+@pytest.mark.requires_installation\n+def test_plugins_cli_error_message_without_args():\n+    # No arguments\n+    result = httpie(no_debug=True)\n+    assert result.exit_status == ExitStatus.ERROR\n+    assert 'usage: ' in result.stderr\n+    assert 'specify one of these' in result.stderr\n+    assert 'please use the http/https commands:' in result.stderr\n+\n+\n+@pytest.mark.parametrize(\n+    'example',\n+    [\n+        'pie.dev/get',\n+        'DELETE localhost:8000/delete',\n+        'POST pie.dev/post header:value a=b header_2:value x:=1',\n+    ],\n+)\n+@pytest.mark.requires_installation\n+def test_plugins_cli_error_messages_with_example(example):\n+    result = httpie(*example.split(), no_debug=True)\n+    assert result.exit_status == ExitStatus.ERROR\n+    assert 'usage: ' in result.stderr\n+    assert f'http {example}' in result.stderr\n+    assert f'https {example}' in result.stderr\n+\n+\n+@pytest.mark.parametrize(\n+    'example',\n+    [\n+        'cli',\n+        'plugins',\n+        'cli foo',\n+        'plugins unknown',\n+        'plugins unknown.com A:B c=d',\n+        'unknown.com UNPARSABLE????SYNTAX',\n+    ],\n+)\n+@pytest.mark.requires_installation\n+def test_plugins_cli_error_messages_invalid_example(example):\n+    result = httpie(*example.split(), no_debug=True)\n+    assert result.exit_status == ExitStatus.ERROR\n+    assert 'usage: ' in result.stderr\n+    assert f'http {example}' not in result.stderr\n+    assert f'https {example}' not in result.stderr\n+\n+\n+HTTPIE_CLI_SESSIONS_UPGRADE_OPTIONS = [\n+    (\n+        # Default settings\n+        [],\n+        {'__host__': json.dumps(None)},\n+    ),\n+    (\n+        # When --bind-cookies is applied, the __host__ becomes DUMMY_URL.\n+        ['--bind-cookies'],\n+        {'__host__': json.dumps(DUMMY_HOST)},\n+    ),\n+]\n+\n+\n+@pytest.mark.parametrize(\n+    'old_session_file, new_session_file', zip(SESSION_FILES_OLD, SESSION_FILES_NEW)\n+)\n+@pytest.mark.parametrize(\n+    'extra_args, extra_variables',\n+    HTTPIE_CLI_SESSIONS_UPGRADE_OPTIONS,\n+)\n+def test_httpie_sessions_upgrade(tmp_path, old_session_file, new_session_file, extra_args, extra_variables):\n+    session_path = tmp_path / 'session.json'\n+    shutil.copyfile(old_session_file, session_path)\n+\n+    result = httpie(\n+        'cli', 'sessions', 'upgrade', *extra_args, DUMMY_HOST, str(session_path)\n+    )\n+    assert result.exit_status == ExitStatus.SUCCESS\n+    assert read_session_file(session_path) == read_session_file(\n+        new_session_file, extra_variables=extra_variables\n+    )\n+\n+\n+def test_httpie_sessions_upgrade_on_non_existent_file(tmp_path):\n+    session_path = tmp_path / 'session.json'\n+    result = httpie('cli', 'sessions', 'upgrade', DUMMY_HOST, str(session_path))\n+    assert result.exit_status == ExitStatus.ERROR\n+    assert 'does not exist' in result.stderr\n+\n+\n+@pytest.mark.parametrize(\n+    'extra_args, extra_variables',\n+    HTTPIE_CLI_SESSIONS_UPGRADE_OPTIONS,\n+)\n+def test_httpie_sessions_upgrade_all(tmp_path, mock_env, extra_args, extra_variables):\n+    mock_env._create_temp_config_dir = False\n+    mock_env.config_dir = tmp_path / \"config\"\n+\n+    session_dir = mock_env.config_dir / SESSIONS_DIR_NAME / DUMMY_HOST\n+    session_dir.mkdir(parents=True)\n+    for original_session_file in SESSION_FILES_OLD:\n+        shutil.copy(original_session_file, session_dir)\n+\n+    result = httpie(\n+        'cli', 'sessions', 'upgrade-all', *extra_args, env=mock_env\n+    )\n+    assert result.exit_status == ExitStatus.SUCCESS\n+\n+    for refactored_session_file, expected_session_file in zip(\n+        sorted(session_dir.glob(\"*.json\")),\n+        SESSION_FILES_NEW\n+    ):\n+        assert read_session_file(refactored_session_file) == read_session_file(\n+            expected_session_file, extra_variables=extra_variables\n+        )"
        },
        {
          "filename": "tests/test_plugins_cli.py",
          "status": "modified",
          "additions": 0,
          "deletions": 43,
          "patch": "@@ -1,7 +1,6 @@\n import pytest\n \n from httpie.status import ExitStatus\n-from tests.utils import httpie\n from tests.utils.plugins_cli import parse_listing\n \n \n@@ -149,45 +148,3 @@ def test_broken_plugins(httpie_plugins, httpie_plugins_success, dummy_plugin, br\n     # No warning now, since it is uninstalled.\n     data = parse_listing(httpie_plugins_success('list'))\n     assert len(data) == 1\n-\n-\n-@pytest.mark.requires_installation\n-def test_plugins_cli_error_message_without_args():\n-    # No arguments\n-    result = httpie(no_debug=True)\n-    assert result.exit_status == ExitStatus.ERROR\n-    assert 'usage: ' in result.stderr\n-    assert 'specify one of these' in result.stderr\n-    assert 'please use the http/https commands:' in result.stderr\n-\n-\n-@pytest.mark.parametrize(\n-    'example', [\n-        'pie.dev/get',\n-        'DELETE localhost:8000/delete',\n-        'POST pie.dev/post header:value a=b header_2:value x:=1'\n-    ]\n-)\n-@pytest.mark.requires_installation\n-def test_plugins_cli_error_messages_with_example(example):\n-    result = httpie(*example.split(), no_debug=True)\n-    assert result.exit_status == ExitStatus.ERROR\n-    assert 'usage: ' in result.stderr\n-    assert f'http {example}' in result.stderr\n-    assert f'https {example}' in result.stderr\n-\n-\n-@pytest.mark.parametrize(\n-    'example', [\n-        'plugins unknown',\n-        'plugins unknown.com A:B c=d',\n-        'unknown.com UNPARSABLE????SYNTAX',\n-    ]\n-)\n-@pytest.mark.requires_installation\n-def test_plugins_cli_error_messages_invalid_example(example):\n-    result = httpie(*example.split(), no_debug=True)\n-    assert result.exit_status == ExitStatus.ERROR\n-    assert 'usage: ' in result.stderr\n-    assert f'http {example}' not in result.stderr\n-    assert f'https {example}' not in result.stderr"
        },
        {
          "filename": "tests/test_sessions.py",
          "status": "modified",
          "additions": 176,
          "deletions": 10,
          "patch": "@@ -1,20 +1,24 @@\n import json\n import os\n import shutil\n+from contextlib import contextmanager\n from datetime import datetime\n from unittest import mock\n+from pathlib import Path\n+from typing import Iterator\n \n import pytest\n \n from .fixtures import FILE_PATH_ARG, UNICODE\n+from httpie.context import Environment\n from httpie.encoding import UTF8\n from httpie.plugins import AuthPlugin\n from httpie.plugins.builtin import HTTPBasicAuth\n from httpie.plugins.registry import plugin_manager\n from httpie.sessions import Session\n from httpie.utils import get_expired_cookies\n from .test_auth_plugins import basic_auth\n-from .utils import HTTP_OK, MockEnvironment, http, mk_config_dir\n+from .utils import DUMMY_HOST, HTTP_OK, MockEnvironment, http, mk_config_dir\n from base64 import b64encode\n \n \n@@ -203,9 +207,9 @@ def test_session_with_cookie_followed_by_another_header(self, httpbin):\n         \"\"\"\n         self.start_session(httpbin)\n         session_data = {\n-            \"headers\": {\n-                \"cookie\": \"...\",\n-                \"zzz\": \"...\"\n+            'headers': {\n+                'cookie': '...',\n+                'zzz': '...'\n             }\n         }\n         session_path = self.config_dir / 'session-data.json'\n@@ -307,7 +311,7 @@ class Plugin(AuthPlugin):\n             auth_type = 'test-prompted'\n \n             def get_auth(self, username=None, password=None):\n-                basic_auth_header = \"Basic \" + b64encode(self.raw_auth.encode()).strip().decode('latin1')\n+                basic_auth_header = 'Basic ' + b64encode(self.raw_auth.encode()).strip().decode('latin1')\n                 return basic_auth(basic_auth_header)\n \n         plugin_manager.register(Plugin)\n@@ -359,7 +363,7 @@ def get_auth(self, username=None, password=None):\n              )\n         updated_session = json.loads(self.session_path.read_text(encoding=UTF8))\n         assert updated_session['auth']['type'] == 'test-saved'\n-        assert updated_session['auth']['raw_auth'] == \"user:password\"\n+        assert updated_session['auth']['raw_auth'] == 'user:password'\n         plugin_manager.unregister(Plugin)\n \n \n@@ -368,12 +372,12 @@ class TestExpiredCookies(CookieTestBase):\n     @pytest.mark.parametrize(\n         'initial_cookie, expired_cookie',\n         [\n-            ({'id': {'value': 123}}, 'id'),\n-            ({'id': {'value': 123}}, 'token')\n+            ({'id': {'value': 123}}, {'name': 'id'}),\n+            ({'id': {'value': 123}}, {'name': 'token'})\n         ]\n     )\n-    def test_removes_expired_cookies_from_session_obj(self, initial_cookie, expired_cookie, httpbin):\n-        session = Session(self.config_dir)\n+    def test_removes_expired_cookies_from_session_obj(self, initial_cookie, expired_cookie, httpbin, mock_env):\n+        session = Session(self.config_dir, env=mock_env, session_id=None, bound_host=None)\n         session['cookies'] = initial_cookie\n         session.remove_cookies([expired_cookie])\n         assert expired_cookie not in session.cookies\n@@ -524,3 +528,165 @@ def test_cookie_storage_priority(self, cli_cookie, set_cookie, expected, httpbin\n         updated_session = json.loads(self.session_path.read_text(encoding=UTF8))\n \n         assert updated_session['cookies']['cookie1']['value'] == expected\n+\n+\n+@pytest.fixture\n+def basic_session(httpbin, tmp_path):\n+    session_path = tmp_path / 'session.json'\n+    http(\n+        '--session', str(session_path),\n+        httpbin + '/get'\n+    )\n+    return session_path\n+\n+\n+@contextmanager\n+def open_session(path: Path, env: Environment, read_only: bool = False) -> Iterator[Session]:\n+    session = Session(path, env, session_id='test', bound_host=DUMMY_HOST)\n+    session.load()\n+    yield session\n+    if not read_only:\n+        session.save()\n+\n+\n+@contextmanager\n+def open_raw_session(path: Path, read_only: bool = False) -> None:\n+    with open(path) as stream:\n+        raw_session = json.load(stream)\n+\n+    yield raw_session\n+\n+    if not read_only:\n+        with open(path, 'w') as stream:\n+            json.dump(raw_session, stream)\n+\n+\n+def read_stderr(env: Environment) -> bytes:\n+    env.stderr.seek(0)\n+    stderr_data = env.stderr.read()\n+    if isinstance(stderr_data, str):\n+        return stderr_data.encode()\n+    else:\n+        return stderr_data\n+\n+\n+def test_old_session_version_saved_as_is(basic_session, mock_env):\n+    with open_session(basic_session, mock_env) as session:\n+        session['__meta__'] = {'httpie': '0.0.1'}\n+\n+    with open_session(basic_session, mock_env, read_only=True) as session:\n+        assert session['__meta__']['httpie'] == '0.0.1'\n+\n+\n+def test_old_session_cookie_layout_warning(basic_session, mock_env):\n+    with open_session(basic_session, mock_env) as session:\n+        # Use the old layout & set a cookie\n+        session['cookies'] = {}\n+        session.cookies.set('foo', 'bar')\n+\n+    assert read_stderr(mock_env) == b''\n+\n+    with open_session(basic_session, mock_env, read_only=True) as session:\n+        assert b'Outdated layout detected' in read_stderr(mock_env)\n+\n+\n+@pytest.mark.parametrize('cookies, expect_warning', [\n+    # Old-style cookie format\n+    (\n+        # Without 'domain' set\n+        {'foo': {'value': 'bar'}},\n+        True\n+    ),\n+    (\n+        # With 'domain' set to empty string\n+        {'foo': {'value': 'bar', 'domain': ''}},\n+        True\n+    ),\n+    (\n+        # With 'domain' set to null\n+        {'foo': {'value': 'bar', 'domain': None}},\n+        False,\n+    ),\n+    (\n+        # With 'domain' set to a URL\n+        {'foo': {'value': 'bar', 'domain': DUMMY_HOST}},\n+        False,\n+    ),\n+    # New style cookie format\n+    (\n+        # Without 'domain' set\n+        [{'name': 'foo', 'value': 'bar'}],\n+        False\n+    ),\n+    (\n+        # With 'domain' set to empty string\n+        [{'name': 'foo', 'value': 'bar', 'domain': ''}],\n+        False\n+    ),\n+    (\n+        # With 'domain' set to null\n+        [{'name': 'foo', 'value': 'bar', 'domain': None}],\n+        False,\n+    ),\n+    (\n+        # With 'domain' set to a URL\n+        [{'name': 'foo', 'value': 'bar', 'domain': DUMMY_HOST}],\n+        False,\n+    ),\n+])\n+def test_cookie_security_warnings_on_raw_cookies(basic_session, mock_env, cookies, expect_warning):\n+    with open_raw_session(basic_session) as raw_session:\n+        raw_session['cookies'] = cookies\n+\n+    with open_session(basic_session, mock_env, read_only=True):\n+        warning = b'Outdated layout detected'\n+        stderr = read_stderr(mock_env)\n+\n+        if expect_warning:\n+            assert warning in stderr\n+        else:\n+            assert warning not in stderr\n+\n+\n+def test_old_session_cookie_layout_loading(basic_session, httpbin, mock_env):\n+    with open_session(basic_session, mock_env) as session:\n+        # Use the old layout & set a cookie\n+        session['cookies'] = {}\n+        session.cookies.set('foo', 'bar')\n+\n+    response = http(\n+        '--session', str(basic_session),\n+        httpbin + '/cookies'\n+    )\n+    assert response.json['cookies'] == {'foo': 'bar'}\n+\n+\n+@pytest.mark.parametrize('layout_type', [\n+    dict, list\n+])\n+def test_session_cookie_layout_preservance(basic_session, mock_env, layout_type):\n+    with open_session(basic_session, mock_env) as session:\n+        session['cookies'] = layout_type()\n+        session.cookies.set('foo', 'bar')\n+        session.save()\n+\n+    with open_session(basic_session, mock_env, read_only=True) as session:\n+        assert isinstance(session['cookies'], layout_type)\n+\n+\n+@pytest.mark.parametrize('layout_type', [\n+    dict, list\n+])\n+def test_session_cookie_layout_preservance_on_new_cookies(basic_session, httpbin, mock_env, layout_type):\n+    with open_session(basic_session, mock_env) as session:\n+        session['cookies'] = layout_type()\n+        session.cookies.set('foo', 'bar')\n+        session.save()\n+\n+    http(\n+        '--session', str(basic_session),\n+        httpbin + '/cookies/set/baz/quux'\n+    )\n+\n+    with open_session(basic_session, mock_env, read_only=True) as session:\n+        assert isinstance(session['cookies'], layout_type)"
        },
        {
          "filename": "tests/utils/__init__.py",
          "status": "modified",
          "additions": 22,
          "deletions": 2,
          "patch": "@@ -6,6 +6,8 @@\n import json\n import tempfile\n import warnings\n+import pytest\n+from contextlib import suppress\n from io import BytesIO\n from pathlib import Path\n from typing import Any, Optional, Union, List, Iterable\n@@ -16,6 +18,7 @@\n from httpie.status import ExitStatus\n from httpie.config import Config\n from httpie.context import Environment\n+from httpie.utils import url_as_host\n \n \n # pytest-httpbin currently does not support chunked requests:\n@@ -39,6 +42,7 @@\n )\n \n DUMMY_URL = 'http://this-should.never-resolve'  # Note: URL never fetched\n+DUMMY_HOST = url_as_host(DUMMY_URL)\n \n \n def strip_colors(colorized_msg: str) -> str:\n@@ -187,6 +191,13 @@ class ExitStatusError(Exception):\n     pass\n \n \n+@pytest.fixture\n+def mock_env() -> MockEnvironment:\n+    env = MockEnvironment(stdout_mode='')\n+    yield env\n+    env.cleanup()\n+\n+\n def normalize_args(args: Iterable[Any]) -> List[str]:\n     return [str(arg) for arg in args]\n \n@@ -201,7 +212,7 @@ def httpie(\n     status.\n     \"\"\"\n \n-    env = kwargs.setdefault('env', MockEnvironment())\n+    env = kwargs.setdefault('env', MockEnvironment(stdout_mode=''))\n     cli_args = ['httpie']\n     if not kwargs.pop('no_debug', False):\n         cli_args.append('--debug')\n@@ -214,7 +225,16 @@ def httpie(\n     env.stdout.seek(0)\n     env.stderr.seek(0)\n     try:\n-        response = StrCLIResponse(env.stdout.read())\n+        output = env.stdout.read()\n+        if isinstance(output, bytes):\n+            with suppress(UnicodeDecodeError):\n+                output = output.decode()\n+\n+        if isinstance(output, bytes):\n+            response = BytesCLIResponse(output)\n+        else:\n+            response = StrCLIResponse(output)\n+\n         response.stderr = env.stderr.read()\n         response.exit_status = exit_status\n         response.args = cli_args"
        },
        {
          "filename": "tests/utils/http_server.py",
          "status": "modified",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -85,6 +85,19 @@ def status_custom_msg(handler):\n     handler.end_headers()\n \n \n+@TestHandler.handler('GET', '/cookies/set-and-redirect')\n+def set_cookie_and_redirect(handler):\n+    handler.send_response(302)\n+\n+    redirect_to = handler.headers.get('X-Redirect-To', '/headers')\n+    handler.send_header('Location', redirect_to)\n+\n+    raw_cookies = handler.headers.get('X-Cookies', 'a=b')\n+    for cookie in raw_cookies.split(', '):\n+        handler.send_header('Set-Cookie', cookie)\n+    handler.end_headers()\n+\n+\n @pytest.fixture(scope=\"function\")\n def http_server():\n     \"\"\"A custom HTTP server implementation for our tests, that is"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 11,
        "dependency_files": 0,
        "test_files": 18,
        "unique_directories": 9,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "5b604c37c6c67e18e7c3e9aee6c88a8c22b98345",
            "date": "2024-12-17T17:30:35Z",
            "author_login": "sersorrel"
          },
          {
            "sha": "2843b874c60bda30e7393f0500353b6fe8451542",
            "date": "2024-11-01T17:35:35Z",
            "author_login": "github-actions[bot]"
          },
          {
            "sha": "2105caa49bae87c5809c274e407619a0de2639d1",
            "date": "2024-11-01T17:29:56Z",
            "author_login": "jkbrzt"
          },
          {
            "sha": "8560d1196d78fa839a4d69503680d95bed4552d4",
            "date": "2024-11-01T17:01:03Z",
            "author_login": "jkbrzt"
          },
          {
            "sha": "2ef4a57d8c2a3defd189e0cc6e365fa8a9aaff2c",
            "date": "2024-11-01T16:47:27Z",
            "author_login": "jkbrzt"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-200",
    "description": "HTTPie is a command-line HTTP client. HTTPie has the practical concept of sessions, which help users to persistently store some of the state that belongs to the outgoing requests and incoming responses on the disk for further usage. Before 3.1.0, HTTPie didn\u2018t distinguish between cookies and hosts they belonged. This behavior resulted in the exposure of some cookies when there are redirects originating from the actual host to a third party website. Users are advised to upgrade. There are no known workarounds.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-03-07T23:15:07.817",
    "last_modified": "2024-11-21T06:50:59.150",
    "fix_date": "2022-02-01T09:14:24Z"
  },
  "references": [
    {
      "url": "https://github.com/httpie/httpie/commit/65ab7d5caaaf2f95e61f9dd65441801c2ddee38b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/httpie/httpie/releases/tag/3.1.0",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/httpie/httpie/security/advisories/GHSA-9w4w-cpc8-h2fq",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4QZD2AZOL7XLNZVAV6GDNXYU6MFRU5RS/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/R5VYSYKEKVZEVEBIWAADGDXG4Y3EWCQ3/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TXFCHGTW3V32GD6GXXJZE5QAOSDT3RTY/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/httpie/httpie/commit/65ab7d5caaaf2f95e61f9dd65441801c2ddee38b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/httpie/httpie/releases/tag/3.1.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/httpie/httpie/security/advisories/GHSA-9w4w-cpc8-h2fq",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4QZD2AZOL7XLNZVAV6GDNXYU6MFRU5RS/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/R5VYSYKEKVZEVEBIWAADGDXG4Y3EWCQ3/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TXFCHGTW3V32GD6GXXJZE5QAOSDT3RTY/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:59.784352",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "cli",
    "owner": "httpie",
    "created_at": "2012-02-25T12:39:13Z",
    "updated_at": "2025-01-26T06:33:54Z",
    "pushed_at": "2024-12-17T17:30:35Z",
    "size": 6925,
    "stars": 34517,
    "forks": 3691,
    "open_issues": 179,
    "watchers": 34517,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Python": 573376,
      "Roff": 31657,
      "Shell": 7684,
      "Makefile": 6656,
      "Dockerfile": 1148
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-26T08:17:19.167956"
  }
}