{
  "cve_id": "CVE-2022-24738",
  "github_data": {
    "repository": "tharsis/evmos",
    "fix_commit": "28870258d4ee9f1b8aeef5eba891681f89348f71",
    "related_commits": [
      "28870258d4ee9f1b8aeef5eba891681f89348f71",
      "28870258d4ee9f1b8aeef5eba891681f89348f71"
    ],
    "patch_url": "https://github.com/tharsis/evmos/commit/28870258d4ee9f1b8aeef5eba891681f89348f71.patch",
    "fix_commit_details": {
      "sha": "28870258d4ee9f1b8aeef5eba891681f89348f71",
      "commit_date": "2022-03-06T17:37:08Z",
      "author": {
        "login": "fedekunze",
        "type": "User",
        "stats": {
          "total_commits": 546,
          "average_weekly_commits": 3.1560693641618496,
          "total_additions": 609192,
          "total_deletions": 391003,
          "weeks_active": 116
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-5jgq-x857-p8xw",
        "length": 284,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 250,
        "additions": 233,
        "deletions": 17
      },
      "files": [
        {
          "filename": "CHANGELOG.md",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -37,6 +37,10 @@ Ref: https://keepachangelog.com/en/1.0.0/\n \n ## [v2.0.0] - 2022-03-06\n \n+### State Machine Breaking\n+\n+- (claims) Restrict claiming to a list of authorized IBC channels.\n+\n ### Improvements\n \n - (deps) [\\#360](https://github.com/tharsis/evmos/pull/360) Bump Ethermint to [`v0.11.0`](https://github.com/tharsis/ethermint/releases/tag/v0.11.0)"
        },
        {
          "filename": "client/docs/statik/statik.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": null
        },
        {
          "filename": "client/docs/swagger-ui/swagger.yaml",
          "status": "modified",
          "additions": 42,
          "deletions": 0,
          "patch": "@@ -250,6 +250,20 @@ paths:\n                   claims_denom:\n                     type: string\n                     title: denom of claimable coin\n+                  authorized_channels:\n+                    type: array\n+                    items:\n+                      type: string\n+                    description: >-\n+                      list of authorized channel identifiers that can perform\n+                      address attestations\n+\n+                      via IBC.\n+                  evm_channels:\n+                    type: array\n+                    items:\n+                      type: string\n+                    title: list of channel identifiers from EVM compatible chains\n             description: >-\n               QueryParamsResponse is the response type for the Query/Params RPC\n               method.\n@@ -26870,6 +26884,20 @@ definitions:\n       claims_denom:\n         type: string\n         title: denom of claimable coin\n+      authorized_channels:\n+        type: array\n+        items:\n+          type: string\n+        description: >-\n+          list of authorized channel identifiers that can perform address\n+          attestations\n+\n+          via IBC.\n+      evm_channels:\n+        type: array\n+        items:\n+          type: string\n+        title: list of channel identifiers from EVM compatible chains\n     description: Params defines the claims module's parameters.\n   evmos.claims.v1.QueryClaimsRecordResponse:\n     type: object\n@@ -26983,6 +27011,20 @@ definitions:\n           claims_denom:\n             type: string\n             title: denom of claimable coin\n+          authorized_channels:\n+            type: array\n+            items:\n+              type: string\n+            description: >-\n+              list of authorized channel identifiers that can perform address\n+              attestations\n+\n+              via IBC.\n+          evm_channels:\n+            type: array\n+            items:\n+              type: string\n+            title: list of channel identifiers from EVM compatible chains\n     description: QueryParamsResponse is the response type for the Query/Params RPC method.\n   evmos.claims.v1.QueryTotalUnclaimedResponse:\n     type: object"
        },
        {
          "filename": "proto/evmos/claims/v1/genesis.proto",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -12,7 +12,6 @@ option go_package = \"github.com/tharsis/evmos/v2/x/claims/types\";\n message GenesisState {\n   // params defines all the parameters of the module.\n   Params params = 1 [ (gogoproto.nullable) = false ];\n-\n   // list of claim records with the corresponding airdrop recipient\n   repeated ClaimsRecordAddress claims_records = 2\n       [ (gogoproto.nullable) = false ];"
        },
        {
          "filename": "types/errors.go",
          "status": "added",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -0,0 +1,18 @@\n+package types\n+\n+import (\n+\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n+)\n+\n+// RootCodespace is the codespace for all errors defined in this package\n+const RootCodespace = \"evmos\"\n+\n+// root error codes for Evmos\n+const (\n+\tcodeKeyTypeNotSupported = iota + 2\n+)\n+\n+// errors\n+var (\n+\tErrKeyTypeNotSupported = sdkerrors.Register(RootCodespace, codeKeyTypeNotSupported, \"key type 'secp256k1' not supported\")\n+)"
        },
        {
          "filename": "x/claims/keeper/ibc_callbacks.go",
          "status": "modified",
          "additions": 34,
          "deletions": 1,
          "patch": "@@ -9,6 +9,7 @@ import (\n \tchanneltypes \"github.com/cosmos/ibc-go/v3/modules/core/04-channel/types\"\n \t\"github.com/cosmos/ibc-go/v3/modules/core/exported\"\n \n+\tevmos \"github.com/tharsis/evmos/v2/types\"\n \t\"github.com/tharsis/evmos/v2/x/claims/types\"\n )\n \n@@ -21,7 +22,7 @@ func (k Keeper) OnRecvPacket(\n ) exported.Acknowledgement {\n \tparams := k.GetParams(ctx)\n \n-\t// short circuit in case claim is not active (no-op)\n+\t// short (no-op) circuit by returning original ACK in case the claim is not active\n \tif !params.IsClaimsActive(ctx.BlockTime()) {\n \t\treturn ack\n \t}\n@@ -60,6 +61,38 @@ func (k Keeper) OnRecvPacket(\n \t}\n \n \tsenderClaimsRecord, senderRecordFound := k.GetClaimsRecord(ctx, sender)\n+\n+\t// NOTE: we know that the connected chains from the authorized IBC channels\n+\t// don't support ethereum keys (i.e `ethsecp256k1`). Thus, so we return an error,\n+\t// unless the destination channel from a connection to a chain that is EVM-compatible\n+\t// or supports ethereum keys (eg: Cronos, Injective).\n+\tif sender.Equals(recipient) && !params.IsEVMChannel(packet.DestinationChannel) {\n+\t\tswitch {\n+\t\t// case 1: secp256k1 key from sender/recipient has no claimed actions -> error ACK to prevent funds from getting stuck\n+\t\tcase senderRecordFound && !senderClaimsRecord.HasClaimedAny():\n+\t\t\treturn channeltypes.NewErrorAcknowledgement(\n+\t\t\t\tsdkerrors.Wrapf(\n+\t\t\t\t\tevmos.ErrKeyTypeNotSupported, \"receiver address %s is not a valid ethereum address\", data.Receiver,\n+\t\t\t\t).Error(),\n+\t\t\t)\n+\t\tdefault:\n+\t\t\t// case 2: sender/recipient has funds stuck -> error acknowledgement to prevent more transferred tokens from\n+\t\t\t// getting stuck while we implement IBC withdrawals\n+\t\t\treturn channeltypes.NewErrorAcknowledgement(\n+\t\t\t\tsdkerrors.Wrapf(\n+\t\t\t\t\tevmos.ErrKeyTypeNotSupported,\n+\t\t\t\t\t\"reverted transfer to unsupported address %s to prevent more funds from getting stuck\",\n+\t\t\t\t\tdata.Receiver,\n+\t\t\t\t).Error(),\n+\t\t\t)\n+\t\t}\n+\t}\n+\n+\t// return original ACK in case the destination channel is not authorized\n+\tif !params.IsAuthorizedChannel(packet.DestinationChannel) {\n+\t\treturn ack\n+\t}\n+\n \trecipientClaimsRecord, recipientRecordFound := k.GetClaimsRecord(ctx, recipient)\n \n \t// handle the 4 cases for the recipient and sender claim records"
        },
        {
          "filename": "x/claims/keeper/ibc_callbacks_test.go",
          "status": "modified",
          "additions": 59,
          "deletions": 8,
          "patch": "@@ -6,14 +6,15 @@ import (\n \n \t\"github.com/stretchr/testify/suite\"\n \n+\t\"github.com/cosmos/cosmos-sdk/crypto/keys/secp256k1\"\n \tsdk \"github.com/cosmos/cosmos-sdk/types\"\n \tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n \ttransfertypes \"github.com/cosmos/ibc-go/v3/modules/apps/transfer/types\"\n \tclienttypes \"github.com/cosmos/ibc-go/v3/modules/core/02-client/types\"\n \tchanneltypes \"github.com/cosmos/ibc-go/v3/modules/core/04-channel/types\"\n \tibcgotesting \"github.com/cosmos/ibc-go/v3/testing\"\n-\n \tibcmock \"github.com/cosmos/ibc-go/v3/testing/mock\"\n+\n \t\"github.com/tharsis/evmos/v2/app\"\n \t\"github.com/tharsis/evmos/v2/ibctesting\"\n \t\"github.com/tharsis/evmos/v2/x/claims/types\"\n@@ -295,12 +296,16 @@ func (suite *IBCTestingSuite) TestOnAckClaim() {\n }\n \n func (suite *KeeperTestSuite) TestReceive() {\n+\tpk := secp256k1.GenPrivKey()\n+\tsecpAddr := sdk.AccAddress(pk.PubKey().Address())\n+\tsecpAddrEvmos := secpAddr.String()\n+\tsecpAddrCosmos := sdk.MustBech32ifyAddressBytes(sdk.Bech32MainPrefix, secpAddr)\n \tsender := \"evmos1sv9m0g7ycejwr3s369km58h5qe7xj77hvcxrms\"\n \treceiver := \"evmos1hf0468jjpe6m6vx38s97z2qqe8ldu0njdyf625\"\n \n \tdisabledTimeoutTimestamp := uint64(0)\n \ttimeoutHeight = clienttypes.NewHeight(0, 100)\n-\tmockpacket := channeltypes.NewPacket(ibcgotesting.MockPacketData, 1, \"port\", \"channel\", \"port2\", \"channel2\", timeoutHeight, disabledTimeoutTimestamp)\n+\tmockpacket := channeltypes.NewPacket(ibcgotesting.MockPacketData, 1, transfertypes.PortID, \"channel-0\", transfertypes.PortID, \"channel-0\", timeoutHeight, disabledTimeoutTimestamp)\n \tack := ibcmock.MockAcknowledgement\n \n \ttestCases := []struct {\n@@ -318,6 +323,17 @@ func (suite *KeeperTestSuite) TestReceive() {\n \t\t\t\tsuite.Require().Equal(ack, resAck)\n \t\t\t},\n \t\t},\n+\t\t{\n+\t\t\t\"params, channel not authorized\",\n+\t\t\tfunc() {\n+\t\t\t\ttransfer := transfertypes.NewFungibleTokenPacketData(\"aevmos\", \"100\", sender, receiver)\n+\t\t\t\tbz := transfertypes.ModuleCdc.MustMarshalJSON(&transfer)\n+\t\t\t\tpacket := channeltypes.NewPacket(bz, 1, transfertypes.PortID, \"channel-0\", transfertypes.PortID, \"channel-100\", timeoutHeight, 0)\n+\n+\t\t\t\tresAck := suite.app.ClaimsKeeper.OnRecvPacket(suite.ctx, packet, ack)\n+\t\t\t\tsuite.Require().Equal(ack, resAck)\n+\t\t\t},\n+\t\t},\n \t\t{\n \t\t\t\"non ics20 packet\",\n \t\t\tfunc() {\n@@ -332,18 +348,18 @@ func (suite *KeeperTestSuite) TestReceive() {\n \t\t\tfunc() {\n \t\t\t\ttransfer := transfertypes.NewFungibleTokenPacketData(\"aevmos\", \"100\", \"evmos\", receiver)\n \t\t\t\tbz := transfertypes.ModuleCdc.MustMarshalJSON(&transfer)\n-\t\t\t\tpacket := channeltypes.NewPacket(bz, 1, \"port\", \"channel\", \"port2\", \"channel2\", timeoutHeight, 0)\n+\t\t\t\tpacket := channeltypes.NewPacket(bz, 1, transfertypes.PortID, \"channel-0\", transfertypes.PortID, \"channel-0\", timeoutHeight, 0)\n \n \t\t\t\tresAck := suite.app.ClaimsKeeper.OnRecvPacket(suite.ctx, packet, ack)\n \t\t\t\tsuite.Require().False(resAck.Success())\n \t\t\t},\n \t\t},\n \t\t{\n-\t\t\t\"invalid sender\",\n+\t\t\t\"invalid sender 2\",\n \t\t\tfunc() {\n \t\t\t\ttransfer := transfertypes.NewFungibleTokenPacketData(\"aevmos\", \"100\", \"badba1sv9m0g7ycejwr3s369km58h5qe7xj77hvcxrms\", receiver)\n \t\t\t\tbz := transfertypes.ModuleCdc.MustMarshalJSON(&transfer)\n-\t\t\t\tpacket := channeltypes.NewPacket(bz, 1, \"port\", \"channel\", \"port2\", \"channel2\", timeoutHeight, 0)\n+\t\t\t\tpacket := channeltypes.NewPacket(bz, 1, transfertypes.PortID, \"channel-0\", transfertypes.PortID, \"channel-0\", timeoutHeight, 0)\n \n \t\t\t\tresAck := suite.app.ClaimsKeeper.OnRecvPacket(suite.ctx, packet, ack)\n \t\t\t\tsuite.Require().False(resAck.Success())\n@@ -354,7 +370,31 @@ func (suite *KeeperTestSuite) TestReceive() {\n \t\t\tfunc() {\n \t\t\t\ttransfer := transfertypes.NewFungibleTokenPacketData(\"aevmos\", \"100\", receiver, \"badbadhf0468jjpe6m6vx38s97z2qqe8ldu0njdyf625\")\n \t\t\t\tbz := transfertypes.ModuleCdc.MustMarshalJSON(&transfer)\n-\t\t\t\tpacket := channeltypes.NewPacket(bz, 1, \"port\", \"channel\", \"port2\", \"channel2\", timeoutHeight, 0)\n+\t\t\t\tpacket := channeltypes.NewPacket(bz, 1, transfertypes.PortID, \"channel-0\", transfertypes.PortID, \"channel-0\", timeoutHeight, 0)\n+\n+\t\t\t\tresAck := suite.app.ClaimsKeeper.OnRecvPacket(suite.ctx, packet, ack)\n+\t\t\t\tsuite.Require().False(resAck.Success())\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"fail - sender and receiver address is the same (no claim record)\",\n+\t\t\tfunc() {\n+\t\t\t\ttransfer := transfertypes.NewFungibleTokenPacketData(\"aevmos\", \"100\", secpAddrCosmos, secpAddrEvmos)\n+\t\t\t\tbz := transfertypes.ModuleCdc.MustMarshalJSON(&transfer)\n+\t\t\t\tpacket := channeltypes.NewPacket(bz, 1, transfertypes.PortID, \"channel-0\", transfertypes.PortID, \"channel-0\", timeoutHeight, 0)\n+\n+\t\t\t\tresAck := suite.app.ClaimsKeeper.OnRecvPacket(suite.ctx, packet, ack)\n+\t\t\t\tsuite.Require().False(resAck.Success())\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"fail - sender and receiver address is the same (with claim record)\",\n+\t\t\tfunc() {\n+\t\t\t\ttransfer := transfertypes.NewFungibleTokenPacketData(\"aevmos\", \"100\", secpAddrCosmos, secpAddrEvmos)\n+\t\t\t\tbz := transfertypes.ModuleCdc.MustMarshalJSON(&transfer)\n+\t\t\t\tpacket := channeltypes.NewPacket(bz, 1, transfertypes.PortID, \"channel-0\", transfertypes.PortID, \"channel-0\", timeoutHeight, 0)\n+\n+\t\t\t\tsuite.app.ClaimsKeeper.SetClaimsRecord(suite.ctx, secpAddr, types.NewClaimsRecord(sdk.NewInt(100)))\n \n \t\t\t\tresAck := suite.app.ClaimsKeeper.OnRecvPacket(suite.ctx, packet, ack)\n \t\t\t\tsuite.Require().False(resAck.Success())\n@@ -365,7 +405,18 @@ func (suite *KeeperTestSuite) TestReceive() {\n \t\t\tfunc() {\n \t\t\t\ttransfer := transfertypes.NewFungibleTokenPacketData(\"aevmos\", \"100\", sender, receiver)\n \t\t\t\tbz := transfertypes.ModuleCdc.MustMarshalJSON(&transfer)\n-\t\t\t\tpacket := channeltypes.NewPacket(bz, 1, \"port\", \"channel\", \"port2\", \"channel2\", timeoutHeight, 0)\n+\t\t\t\tpacket := channeltypes.NewPacket(bz, 1, transfertypes.PortID, \"channel-0\", transfertypes.PortID, types.DefaultAuthorizedChannels[0], timeoutHeight, 0)\n+\n+\t\t\t\tresAck := suite.app.ClaimsKeeper.OnRecvPacket(suite.ctx, packet, ack)\n+\t\t\t\tsuite.Require().True(resAck.Success())\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"correct, same sender with EVM channel\",\n+\t\t\tfunc() {\n+\t\t\t\ttransfer := transfertypes.NewFungibleTokenPacketData(\"aevmos\", \"100\", secpAddrCosmos, secpAddrEvmos)\n+\t\t\t\tbz := transfertypes.ModuleCdc.MustMarshalJSON(&transfer)\n+\t\t\t\tpacket := channeltypes.NewPacket(bz, 1, transfertypes.PortID, \"channel-0\", transfertypes.PortID, types.DefaultEVMChannels[0], timeoutHeight, 0)\n \n \t\t\t\tresAck := suite.app.ClaimsKeeper.OnRecvPacket(suite.ctx, packet, ack)\n \t\t\t\tsuite.Require().True(resAck.Success())\n@@ -384,7 +435,7 @@ func (suite *KeeperTestSuite) TestReceive() {\n func (suite *KeeperTestSuite) TestAck() {\n \tdisabledTimeoutTimestamp := uint64(0)\n \ttimeoutHeight = clienttypes.NewHeight(0, 100)\n-\tmockpacket := channeltypes.NewPacket(ibcgotesting.MockPacketData, 1, \"port\", \"channel\", \"port2\", \"channel2\", timeoutHeight, disabledTimeoutTimestamp)\n+\tmockpacket := channeltypes.NewPacket(ibcgotesting.MockPacketData, 1, transfertypes.PortID, \"channel-0\", transfertypes.PortID, \"channel-0\", timeoutHeight, disabledTimeoutTimestamp)\n \tack := ibcmock.MockAcknowledgement\n \n \ttestCases := []struct {"
        },
        {
          "filename": "x/claims/module.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -167,4 +167,4 @@ func (am AppModule) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.Val\n }\n \n // ConsensusVersion implements AppModule/ConsensusVersion.\n-func (AppModule) ConsensusVersion() uint64 { return 1 }\n+func (AppModule) ConsensusVersion() uint64 { return 2 }"
        },
        {
          "filename": "x/claims/types/claim_record.go",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -57,6 +57,17 @@ func (cr ClaimsRecord) HasClaimedAction(action Action) bool {\n \t}\n }\n \n+// HasClaimedAny returns true if the user has claimed at least one reward from the\n+// available actions\n+func (cr ClaimsRecord) HasClaimedAny() bool {\n+\tfor _, completed := range cr.ActionsCompleted {\n+\t\tif completed {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n // HasClaimedAll returns true if the user has claimed all the rewards from the\n // available actions\n func (cr ClaimsRecord) HasClaimedAll() bool {"
        },
        {
          "filename": "x/claims/types/claim_record_test.go",
          "status": "modified",
          "additions": 39,
          "deletions": 0,
          "patch": "@@ -137,6 +137,45 @@ func TestClaimsRecordHasClaimedAll(t *testing.T) {\n \t}\n }\n \n+func TestClaimsRecordHasAny(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tname         string\n+\t\tclaimsRecord ClaimsRecord\n+\t\texpBool      bool\n+\t}{\n+\t\t{\n+\t\t\t\"false - empty\",\n+\t\t\tClaimsRecord{},\n+\t\t\tfalse,\n+\t\t},\n+\t\t{\n+\t\t\t\"false - not claimed\",\n+\t\t\tClaimsRecord{\n+\t\t\t\tActionsCompleted: []bool{false, false, false, false},\n+\t\t\t},\n+\t\t\tfalse,\n+\t\t},\n+\t\t{\n+\t\t\t\"true - single action claimed\",\n+\t\t\tClaimsRecord{\n+\t\t\t\tActionsCompleted: []bool{true, false, false, false},\n+\t\t\t},\n+\t\t\ttrue,\n+\t\t},\n+\t\t{\n+\t\t\t\"true - all claimed\",\n+\t\t\tClaimsRecord{\n+\t\t\t\tActionsCompleted: []bool{true, true, true, true},\n+\t\t\t},\n+\t\t\ttrue,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\trequire.True(t, tc.expBool == tc.claimsRecord.HasClaimedAny(), tc.name)\n+\t}\n+}\n+\n func TestClaimsRecordAddressValidate(t *testing.T) {\n \taddr := sdk.AccAddress(tests.GenerateAddress().Bytes())\n "
        },
        {
          "filename": "x/erc20/module.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -42,7 +42,7 @@ func (AppModuleBasic) RegisterLegacyAminoCodec(cdc *codec.LegacyAmino) {}\n \n // ConsensusVersion returns the consensus state-breaking version for the module.\n func (AppModuleBasic) ConsensusVersion() uint64 {\n-\treturn 1\n+\treturn 2\n }\n \n // RegisterInterfaces registers interfaces and implementations of the erc20 module."
        },
        {
          "filename": "x/inflation/genesis.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -11,7 +11,7 @@ func InitGenesis(\n \tctx sdk.Context,\n \tk keeper.Keeper,\n \tak types.AccountKeeper,\n-\tsk types.StakingKeeper,\n+\t_ types.StakingKeeper,\n \tdata types.GenesisState,\n ) {\n \t// Ensure inflation module account is set on genesis\n@@ -33,7 +33,7 @@ func InitGenesis(\n \tk.SetEpochsPerPeriod(ctx, epochsPerPeriod)\n \n \t// Get bondedRatio\n-\tbondedRatio := sk.BondedRatio(ctx)\n+\tbondedRatio := k.BondedRatio(ctx)\n \n \t// Calculate epoch mint provision\n \tepochMintProvision := types.CalculateEpochMintProvision("
        },
        {
          "filename": "x/inflation/keeper/hooks.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -46,7 +46,7 @@ func (k Keeper) AfterEpochEnd(ctx sdk.Context, epochIdentifier string, epochNumb\n \t\tperiod++\n \t\tk.SetPeriod(ctx, period)\n \t\tperiod = k.GetPeriod(ctx)\n-\t\tbondedRatio := k.stakingKeeper.BondedRatio(ctx)\n+\t\tbondedRatio := k.BondedRatio(ctx)\n \t\tnewProvision = types.CalculateEpochMintProvision(\n \t\t\tparams,\n \t\t\tperiod,"
        },
        {
          "filename": "x/inflation/keeper/hooks_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -55,7 +55,7 @@ func (suite *KeeperTestSuite) TestPeriodChangesAfterEpochEnd() {\n \n \tcurrentEpochPeriod := suite.app.InflationKeeper.GetEpochsPerPeriod(suite.ctx)\n \t// bondingRatio is zero in tests\n-\tbondedRatio := suite.app.StakingKeeper.BondedRatio(suite.ctx)\n+\tbondedRatio := suite.app.InflationKeeper.BondedRatio(suite.ctx)\n \n \ttestCases := []struct {\n \t\tname    string"
        },
        {
          "filename": "x/inflation/keeper/inflation.go",
          "status": "modified",
          "additions": 17,
          "deletions": 0,
          "patch": "@@ -3,10 +3,15 @@ package keeper\n import (\n \tsdk \"github.com/cosmos/cosmos-sdk/types\"\n \n+\tethermint \"github.com/tharsis/ethermint/types\"\n+\n \tincentivestypes \"github.com/tharsis/evmos/v2/x/incentives/types\"\n \t\"github.com/tharsis/evmos/v2/x/inflation/types\"\n )\n \n+// 200M token at year 4 allocated to the team\n+var teamAlloc = sdk.NewInt(200_000_000).Mul(ethermint.PowerReduction)\n+\n // MintAndAllocateInflation performs inflation minting and allocation\n func (k Keeper) MintAndAllocateInflation(ctx sdk.Context, coin sdk.Coin) error {\n \t// Mint coins for distribution\n@@ -88,3 +93,15 @@ func (k Keeper) GetProportions(\n \t\tcoin.Amount.ToDec().Mul(distribution).TruncateInt(),\n \t)\n }\n+\n+// BondedRatio the fraction of the staking tokens which are currently bonded\n+// It doesn't consider team allocation for inflation\n+func (k Keeper) BondedRatio(ctx sdk.Context) sdk.Dec {\n+\tstakeSupply := k.stakingKeeper.StakingTokenSupply(ctx)\n+\tif !stakeSupply.IsPositive() || stakeSupply.LTE(teamAlloc) {\n+\t\treturn sdk.ZeroDec()\n+\t}\n+\n+\tstakeSupply = stakeSupply.Sub(teamAlloc)\n+\treturn k.stakingKeeper.TotalBondedTokens(ctx).ToDec().QuoInt(stakeSupply)\n+}"
        },
        {
          "filename": "x/inflation/types/interfaces.go",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -34,4 +34,6 @@ type DistrKeeper interface {\n type StakingKeeper interface {\n \t// BondedRatio the fraction of the staking tokens which are currently bonded\n \tBondedRatio(ctx sdk.Context) sdk.Dec\n+\tStakingTokenSupply(ctx sdk.Context) sdk.Int\n+\tTotalBondedTokens(ctx sdk.Context) sdk.Int\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 12,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "cb46d96dae36a26b3cd11570421c2edc2e804bd4",
            "date": "2025-01-13T13:35:37Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "116a676f8e9c4f4847a05fe7a3fbe627956f44fe",
            "date": "2025-01-13T08:22:05Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "392b2279dafa5182b3a5299f165a2e035d031e0a",
            "date": "2025-01-10T10:48:35Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "9274fcaddad99ca39807a4e85d5e4c10585dc78a",
            "date": "2025-01-09T13:58:02Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "1a507391b54073793be7bc4e6b14ce8d529054ae",
            "date": "2025-01-07T09:00:46Z",
            "author_login": "xujk-byte"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-287",
    "description": "Evmos is the Ethereum Virtual Machine (EVM) Hub on the Cosmos Network. In versions of evmos prior to 2.0.1 attackers are able to drain unclaimed funds from user addresses. To do this an attacker must create a new chain which does not enforce signature verification and connects it to the target evmos instance. The attacker can use this joined chain to transfer unclaimed funds. Users are advised to upgrade. There are no known workarounds for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-03-07T22:15:08.227",
    "last_modified": "2024-11-21T06:50:59.283",
    "fix_date": "2022-03-06T17:37:08Z"
  },
  "references": [
    {
      "url": "https://github.com/tharsis/evmos/commit/28870258d4ee9f1b8aeef5eba891681f89348f71",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tharsis/evmos/releases/tag/v2.0.1",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tharsis/evmos/security/advisories/GHSA-5jgq-x857-p8xw",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tharsis/evmos/commit/28870258d4ee9f1b8aeef5eba891681f89348f71",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tharsis/evmos/releases/tag/v2.0.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tharsis/evmos/security/advisories/GHSA-5jgq-x857-p8xw",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:59.784201",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "evmos",
    "owner": "tharsis",
    "created_at": "2021-09-28T09:13:46Z",
    "updated_at": "2025-01-13T13:35:42Z",
    "pushed_at": "2025-01-14T13:36:57Z",
    "size": 197487,
    "stars": 1680,
    "forks": 878,
    "open_issues": 23,
    "watchers": 1680,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Go": 4931570,
      "Python": 413227,
      "Solidity": 118737,
      "Jsonnet": 56049,
      "JavaScript": 47253,
      "Shell": 44165,
      "Nix": 23467,
      "Makefile": 21112,
      "Batchfile": 2623,
      "Dockerfile": 1717
    },
    "commit_activity": {
      "total_commits_last_year": 455,
      "avg_commits_per_week": 8.75,
      "days_active_last_year": 185
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T20:43:57.805075"
  }
}