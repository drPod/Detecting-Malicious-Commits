{
  "cve_id": "CVE-2022-24761",
  "github_data": {
    "repository": "Pylons/waitress",
    "fix_commit": "9e0b8c801e4d505c2ffc91b891af4ba48af715e0",
    "related_commits": [
      "9e0b8c801e4d505c2ffc91b891af4ba48af715e0",
      "9e0b8c801e4d505c2ffc91b891af4ba48af715e0"
    ],
    "patch_url": "https://github.com/Pylons/waitress/commit/9e0b8c801e4d505c2ffc91b891af4ba48af715e0.patch",
    "fix_commit_details": {
      "sha": "9e0b8c801e4d505c2ffc91b891af4ba48af715e0",
      "commit_date": "2022-03-16T21:26:15Z",
      "author": {
        "login": "digitalresistor",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-4f7p-27jc-3c36",
        "length": 103,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 246,
        "additions": 202,
        "deletions": 44
      },
      "files": [
        {
          "filename": "CHANGES.txt",
          "status": "modified",
          "additions": 26,
          "deletions": 0,
          "patch": "@@ -1,3 +1,29 @@\n+2.1.1\n+-----\n+\n+Security Bugfix\n+~~~~~~~~~~~~~~~\n+\n+- Waitress now validates that chunked encoding extensions are valid, and don't\n+  contain invalid characters that are not allowed. They are still skipped/not\n+  processed, but if they contain invalid data we no longer continue in and\n+  return a 400 Bad Request. This stops potential HTTP desync/HTTP request\n+  smuggling. Thanks to Zhang Zeyu for reporting this issue. See\n+  https://github.com/Pylons/waitress/security/advisories/GHSA-4f7p-27jc-3c36\n+\n+- Waitress now validates that the chunk length is only valid hex digits when\n+  parsing chunked encoding, and values such as ``0x01`` and ``+01`` are no\n+  longer supported. This stops potential HTTP desync/HTTP request smuggling.\n+  Thanks to Zhang Zeyu for reporting this issue. See\n+  https://github.com/Pylons/waitress/security/advisories/GHSA-4f7p-27jc-3c36\n+\n+- Waitress now validates that the Content-Length sent by a remote contains only\n+  digits in accordance with RFC7230 and will return a 400 Bad Request when the\n+  Content-Length header contains invalid data, such as ``+10`` which would\n+  previously get parsed as ``10`` and accepted. This stops potential HTTP\n+  desync/HTTP request smuggling Thanks to Zhang Zeyu for reporting this issue. See\n+  https://github.com/Pylons/waitress/security/advisories/GHSA-4f7p-27jc-3c36\n+\n 2.1.0\n -----\n "
        },
        {
          "filename": "setup.cfg",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,6 +1,6 @@\n [metadata]\n name = waitress\n-version = 2.1.0\n+version = 2.1.1\n description = Waitress WSGI server\n long_description = file: README.rst, CHANGES.txt\n long_description_content_type = text/x-rst"
        },
        {
          "filename": "src/waitress/parser.py",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -23,6 +23,7 @@\n \n from waitress.buffers import OverflowableBuffer\n from waitress.receiver import ChunkedReceiver, FixedStreamReceiver\n+from waitress.rfc7230 import HEADER_FIELD_RE, ONLY_DIGIT_RE\n from waitress.utilities import (\n     BadRequest,\n     RequestEntityTooLarge,\n@@ -31,8 +32,6 @@\n     find_double_newline,\n )\n \n-from .rfc7230 import HEADER_FIELD\n-\n \n def unquote_bytes_to_wsgi(bytestring):\n     return unquote_to_bytes(bytestring).decode(\"latin-1\")\n@@ -221,7 +220,7 @@ def parse_header(self, header_plus):\n         headers = self.headers\n \n         for line in lines:\n-            header = HEADER_FIELD.match(line)\n+            header = HEADER_FIELD_RE.match(line)\n \n             if not header:\n                 raise ParsingError(\"Invalid header\")\n@@ -317,11 +316,12 @@ def parse_header(self, header_plus):\n                 self.connection_close = True\n \n         if not self.chunked:\n-            try:\n-                cl = int(headers.get(\"CONTENT_LENGTH\", 0))\n-            except ValueError:\n+            cl = headers.get(\"CONTENT_LENGTH\", \"0\")\n+\n+            if not ONLY_DIGIT_RE.match(cl.encode(\"latin-1\")):\n                 raise ParsingError(\"Content-Length is invalid\")\n \n+            cl = int(cl)\n             self.content_length = cl\n \n             if cl > 0:"
        },
        {
          "filename": "src/waitress/receiver.py",
          "status": "modified",
          "additions": 21,
          "deletions": 7,
          "patch": "@@ -14,6 +14,7 @@\n \"\"\"Data Chunk Receiver\n \"\"\"\n \n+from waitress.rfc7230 import CHUNK_EXT_RE, ONLY_HEXDIG_RE\n from waitress.utilities import BadRequest, find_double_newline\n \n \n@@ -110,6 +111,7 @@ def received(self, s):\n                     s = b\"\"\n                 else:\n                     self.chunk_end = b\"\"\n+\n                     if pos == 0:\n                         # Chop off the terminating CR LF from the chunk\n                         s = s[2:]\n@@ -133,20 +135,32 @@ def received(self, s):\n                     line = s[:pos]\n                     s = s[pos + 2 :]\n                     self.control_line = b\"\"\n-                    line = line.strip()\n \n                     if line:\n                         # Begin a new chunk.\n                         semi = line.find(b\";\")\n \n                         if semi >= 0:\n-                            # discard extension info.\n+                            extinfo = line[semi:]\n+                            valid_ext_info = CHUNK_EXT_RE.match(extinfo)\n+\n+                            if not valid_ext_info:\n+                                self.error = BadRequest(\"Invalid chunk extension\")\n+                                self.all_chunks_received = True\n+\n+                                break\n+\n                             line = line[:semi]\n-                        try:\n-                            sz = int(line.strip(), 16)  # hexadecimal\n-                        except ValueError:  # garbage in input\n-                            self.error = BadRequest(\"garbage in chunked encoding input\")\n-                            sz = 0\n+\n+                        if not ONLY_HEXDIG_RE.match(line):\n+                            self.error = BadRequest(\"Invalid chunk size\")\n+                            self.all_chunks_received = True\n+\n+                            break\n+\n+                        # Can not fail due to matching against the regular\n+                        # expression above\n+                        sz = int(line, 16)  # hexadecimal\n \n                         if sz > 0:\n                             # Start a new chunk."
        },
        {
          "filename": "src/waitress/rfc7230.py",
          "status": "modified",
          "additions": 26,
          "deletions": 1,
          "patch": "@@ -5,6 +5,9 @@\n \n import re\n \n+HEXDIG = \"[0-9a-fA-F]\"\n+DIGIT = \"[0-9]\"\n+\n WS = \"[ \\t]\"\n OWS = WS + \"{0,}?\"\n RWS = WS + \"{1,}?\"\n@@ -25,6 +28,12 @@\n #                  ; visible (printing) characters\n VCHAR = r\"\\x21-\\x7e\"\n \n+# The '\\\\' between \\x5b and \\x5d is needed to escape \\x5d (']')\n+QDTEXT = \"[\\t \\x21\\x23-\\x5b\\\\\\x5d-\\x7e\" + OBS_TEXT + \"]\"\n+\n+QUOTED_PAIR = r\"\\\\\" + \"([\\t \" + VCHAR + OBS_TEXT + \"])\"\n+QUOTED_STRING = '\"(?:(?:' + QDTEXT + \")|(?:\" + QUOTED_PAIR + '))*\"'\n+\n # header-field   = field-name \":\" OWS field-value OWS\n # field-name     = token\n # field-value    = *( field-content / obs-fold )\n@@ -43,8 +52,24 @@\n # Which allows the field value here to just see if there is even a value in the first place\n FIELD_VALUE = \"(?:\" + FIELD_CONTENT + \")?\"\n \n-HEADER_FIELD = re.compile(\n+# chunk-ext      = *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] )\n+# chunk-ext-name = token\n+# chunk-ext-val  = token / quoted-string\n+\n+CHUNK_EXT_NAME = TOKEN\n+CHUNK_EXT_VAL = \"(?:\" + TOKEN + \")|(?:\" + QUOTED_STRING + \")\"\n+CHUNK_EXT = (\n+    \"(?:;(?P<extension>\" + CHUNK_EXT_NAME + \")(?:=(?P<value>\" + CHUNK_EXT_VAL + \"))?)*\"\n+)\n+\n+# Pre-compiled regular expressions for use elsewhere\n+ONLY_HEXDIG_RE = re.compile((\"^\" + HEXDIG + \"+$\").encode(\"latin-1\"))\n+ONLY_DIGIT_RE = re.compile((\"^\" + DIGIT + \"+$\").encode(\"latin-1\"))\n+HEADER_FIELD_RE = re.compile(\n     (\n         \"^(?P<name>\" + TOKEN + \"):\" + OWS + \"(?P<value>\" + FIELD_VALUE + \")\" + OWS + \"$\"\n     ).encode(\"latin-1\")\n )\n+QUOTED_PAIR_RE = re.compile(QUOTED_PAIR)\n+QUOTED_STRING_RE = re.compile(QUOTED_STRING)\n+CHUNK_EXT_RE = re.compile((\"^\" + CHUNK_EXT + \"$\").encode(\"latin-1\"))"
        },
        {
          "filename": "src/waitress/utilities.py",
          "status": "modified",
          "additions": 3,
          "deletions": 25,
          "patch": "@@ -22,7 +22,7 @@\n import stat\n import time\n \n-from .rfc7230 import OBS_TEXT, VCHAR\n+from .rfc7230 import QUOTED_PAIR_RE, QUOTED_STRING_RE\n \n logger = logging.getLogger(\"waitress\")\n queue_logger = logging.getLogger(\"waitress.queue\")\n@@ -216,40 +216,18 @@ def parse_http_date(d):\n     return retval\n \n \n-# RFC 5234 Appendix B.1 \"Core Rules\":\n-# VCHAR         =  %x21-7E\n-#                  ; visible (printing) characters\n-vchar_re = VCHAR\n-\n-# RFC 7230 Section 3.2.6 \"Field Value Components\":\n-# quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n-# qdtext        = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text\n-# obs-text      = %x80-FF\n-# quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n-obs_text_re = OBS_TEXT\n-\n-# The '\\\\' between \\x5b and \\x5d is needed to escape \\x5d (']')\n-qdtext_re = \"[\\t \\x21\\x23-\\x5b\\\\\\x5d-\\x7e\" + obs_text_re + \"]\"\n-\n-quoted_pair_re = r\"\\\\\" + \"([\\t \" + vchar_re + obs_text_re + \"])\"\n-quoted_string_re = '\"(?:(?:' + qdtext_re + \")|(?:\" + quoted_pair_re + '))*\"'\n-\n-quoted_string = re.compile(quoted_string_re)\n-quoted_pair = re.compile(quoted_pair_re)\n-\n-\n def undquote(value):\n     if value.startswith('\"') and value.endswith('\"'):\n         # So it claims to be DQUOTE'ed, let's validate that\n-        matches = quoted_string.match(value)\n+        matches = QUOTED_STRING_RE.match(value)\n \n         if matches and matches.end() == len(value):\n             # Remove the DQUOTE's from the value\n             value = value[1:-1]\n \n             # Remove all backslashes that are followed by a valid vchar or\n             # obs-text\n-            value = quoted_pair.sub(r\"\\1\", value)\n+            value = QUOTED_PAIR_RE.sub(r\"\\1\", value)\n \n             return value\n     elif not value.startswith('\"') and not value.endswith('\"'):"
        },
        {
          "filename": "tests/test_functional.py",
          "status": "modified",
          "additions": 47,
          "deletions": 3,
          "patch": "@@ -322,7 +322,7 @@ def test_chunking_request_without_content(self):\n             self.assertFalse(\"transfer-encoding\" in headers)\n \n     def test_chunking_request_with_content(self):\n-        control_line = b\"20;\\r\\n\"  # 20 hex = 32 dec\n+        control_line = b\"20\\r\\n\"  # 20 hex = 32 dec\n         s = b\"This string has 32 characters.\\r\\n\"\n         expected = s * 12\n         header = b\"GET / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n@@ -341,7 +341,7 @@ def test_chunking_request_with_content(self):\n             self.assertFalse(\"transfer-encoding\" in headers)\n \n     def test_broken_chunked_encoding(self):\n-        control_line = b\"20;\\r\\n\"  # 20 hex = 32 dec\n+        control_line = b\"20\\r\\n\"  # 20 hex = 32 dec\n         s = b\"This string has 32 characters.\\r\\n\"\n         to_send = b\"GET / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n         to_send += control_line + s + b\"\\r\\n\"\n@@ -364,8 +364,52 @@ def test_broken_chunked_encoding(self):\n             self.send_check_error(to_send)\n             self.assertRaises(ConnectionClosed, read_http, fp)\n \n+    def test_broken_chunked_encoding_invalid_hex(self):\n+        control_line = b\"0x20\\r\\n\"  # 20 hex = 32 dec\n+        s = b\"This string has 32 characters.\\r\\n\"\n+        to_send = b\"GET / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n+        to_send += control_line + s + b\"\\r\\n\"\n+        self.connect()\n+        self.sock.send(to_send)\n+        with self.sock.makefile(\"rb\", 0) as fp:\n+            line, headers, response_body = read_http(fp)\n+            self.assertline(line, \"400\", \"Bad Request\", \"HTTP/1.1\")\n+            cl = int(headers[\"content-length\"])\n+            self.assertEqual(cl, len(response_body))\n+            self.assertIn(b\"Invalid chunk size\", response_body)\n+            self.assertEqual(\n+                sorted(headers.keys()),\n+                [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"],\n+            )\n+            self.assertEqual(headers[\"content-type\"], \"text/plain\")\n+            # connection has been closed\n+            self.send_check_error(to_send)\n+            self.assertRaises(ConnectionClosed, read_http, fp)\n+\n+    def test_broken_chunked_encoding_invalid_extension(self):\n+        control_line = b\"20;invalid=\\r\\n\"  # 20 hex = 32 dec\n+        s = b\"This string has 32 characters.\\r\\n\"\n+        to_send = b\"GET / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n+        to_send += control_line + s + b\"\\r\\n\"\n+        self.connect()\n+        self.sock.send(to_send)\n+        with self.sock.makefile(\"rb\", 0) as fp:\n+            line, headers, response_body = read_http(fp)\n+            self.assertline(line, \"400\", \"Bad Request\", \"HTTP/1.1\")\n+            cl = int(headers[\"content-length\"])\n+            self.assertEqual(cl, len(response_body))\n+            self.assertIn(b\"Invalid chunk extension\", response_body)\n+            self.assertEqual(\n+                sorted(headers.keys()),\n+                [\"connection\", \"content-length\", \"content-type\", \"date\", \"server\"],\n+            )\n+            self.assertEqual(headers[\"content-type\"], \"text/plain\")\n+            # connection has been closed\n+            self.send_check_error(to_send)\n+            self.assertRaises(ConnectionClosed, read_http, fp)\n+\n     def test_broken_chunked_encoding_missing_chunk_end(self):\n-        control_line = b\"20;\\r\\n\"  # 20 hex = 32 dec\n+        control_line = b\"20\\r\\n\"  # 20 hex = 32 dec\n         s = b\"This string has 32 characters.\\r\\n\"\n         to_send = b\"GET / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n         to_send += control_line + s"
        },
        {
          "filename": "tests/test_parser.py",
          "status": "modified",
          "additions": 21,
          "deletions": 1,
          "patch": "@@ -155,7 +155,7 @@ def test_received_chunked_completed_sets_content_length(self):\n             b\"Transfer-Encoding: chunked\\r\\n\"\n             b\"X-Foo: 1\\r\\n\"\n             b\"\\r\\n\"\n-            b\"1d;\\r\\n\"\n+            b\"1d\\r\\n\"\n             b\"This string has 29 characters\\r\\n\"\n             b\"0\\r\\n\\r\\n\"\n         )\n@@ -193,6 +193,26 @@ def test_parse_header_bad_content_length(self):\n         else:  # pragma: nocover\n             self.assertTrue(False)\n \n+    def test_parse_header_bad_content_length_plus(self):\n+        data = b\"GET /foobar HTTP/8.4\\r\\ncontent-length: +10\\r\\n\"\n+\n+        try:\n+            self.parser.parse_header(data)\n+        except ParsingError as e:\n+            self.assertIn(\"Content-Length is invalid\", e.args[0])\n+        else:  # pragma: nocover\n+            self.assertTrue(False)\n+\n+    def test_parse_header_bad_content_length_minus(self):\n+        data = b\"GET /foobar HTTP/8.4\\r\\ncontent-length: -10\\r\\n\"\n+\n+        try:\n+            self.parser.parse_header(data)\n+        except ParsingError as e:\n+            self.assertIn(\"Content-Length is invalid\", e.args[0])\n+        else:  # pragma: nocover\n+            self.assertTrue(False)\n+\n     def test_parse_header_multiple_content_length(self):\n         data = b\"GET /foobar HTTP/8.4\\r\\ncontent-length: 10\\r\\ncontent-length: 20\\r\\n\"\n "
        },
        {
          "filename": "tests/test_receiver.py",
          "status": "modified",
          "additions": 51,
          "deletions": 0,
          "patch": "@@ -1,5 +1,7 @@\n import unittest\n \n+import pytest\n+\n \n class TestFixedStreamReceiver(unittest.TestCase):\n     def _makeOne(self, cl, buf):\n@@ -226,6 +228,55 @@ def test_received_multiple_chunks_split(self):\n         self.assertEqual(inst.error, None)\n \n \n+class TestChunkedReceiverParametrized:\n+    def _makeOne(self, buf):\n+        from waitress.receiver import ChunkedReceiver\n+\n+        return ChunkedReceiver(buf)\n+\n+    @pytest.mark.parametrize(\n+        \"invalid_extension\", [b\"\\n\", b\"invalid=\", b\"\\r\", b\"invalid = true\"]\n+    )\n+    def test_received_invalid_extensions(self, invalid_extension):\n+        from waitress.utilities import BadRequest\n+\n+        buf = DummyBuffer()\n+        inst = self._makeOne(buf)\n+        data = b\"4;\" + invalid_extension + b\"\\r\\ntest\\r\\n\"\n+        result = inst.received(data)\n+        assert result == len(data)\n+        assert inst.error.__class__ == BadRequest\n+        assert inst.error.body == \"Invalid chunk extension\"\n+\n+    @pytest.mark.parametrize(\n+        \"valid_extension\", [b\"test\", b\"valid=true\", b\"valid=true;other=true\"]\n+    )\n+    def test_received_valid_extensions(self, valid_extension):\n+        # While waitress may ignore extensions in Chunked Encoding, we do want\n+        # to make sure that we don't fail when we do encounter one that is\n+        # valid\n+        buf = DummyBuffer()\n+        inst = self._makeOne(buf)\n+        data = b\"4;\" + valid_extension + b\"\\r\\ntest\\r\\n\"\n+        result = inst.received(data)\n+        assert result == len(data)\n+        assert inst.error == None\n+\n+    @pytest.mark.parametrize(\n+        \"invalid_size\", [b\"0x04\", b\"+0x04\", b\"x04\", b\"+04\", b\" 04\", b\" 0x04\"]\n+    )\n+    def test_received_invalid_size(self, invalid_size):\n+        from waitress.utilities import BadRequest\n+\n+        buf = DummyBuffer()\n+        inst = self._makeOne(buf)\n+        data = invalid_size + b\"\\r\\ntest\\r\\n\"\n+        result = inst.received(data)\n+        assert result == len(data)\n+        assert inst.error.__class__ == BadRequest\n+        assert inst.error.body == \"Invalid chunk size\"\n+\n+\n class DummyBuffer:\n     def __init__(self, data=None):\n         if data is None:"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "fc592e804a1aed87654c1ad21337dad86582c71f",
            "date": "2024-11-25T01:07:27Z",
            "author_login": "mmerickel"
          },
          {
            "sha": "7a19337321c43b81076da20bc9c4e2e077a7e01c",
            "date": "2024-11-24T19:55:09Z",
            "author_login": "kgaughan"
          },
          {
            "sha": "2a1524a9b5786459786a4b86e5b2f09d1041e53d",
            "date": "2024-11-23T19:40:01Z",
            "author_login": "kgaughan"
          },
          {
            "sha": "b11ae729cc51ca2998a1ad9b4992b34f34ac95e7",
            "date": "2024-11-16T19:46:41Z",
            "author_login": "digitalresistor"
          },
          {
            "sha": "38ffad094b785168aba197f6b6d8df5de713cc2b",
            "date": "2024-11-16T19:39:00Z",
            "author_login": "digitalresistor"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-444",
    "description": "Waitress is a Web Server Gateway Interface server for Python 2 and 3. When using Waitress versions 2.1.0 and prior behind a proxy that does not properly validate the incoming HTTP request matches the RFC7230 standard, Waitress and the frontend proxy may disagree on where one request starts and where it ends. This would allow requests to be smuggled via the front-end proxy to waitress and later behavior. There are two classes of vulnerability that may lead to request smuggling that are addressed by this advisory: The use of Python's `int()` to parse strings into integers, leading to `+10` to be parsed as `10`, or `0x01` to be parsed as `1`, where as the standard specifies that the string should contain only digits or hex digits; and Waitress does not support chunk extensions, however it was discarding them without validating that they did not contain illegal characters. This vulnerability has been patched in Waitress 2.1.1. A workaround is available. When deploying a proxy in front of waitress, turning on any and all functionality to make sure that the request matches the RFC7230 standard. Certain proxy servers may not have this functionality though and users are encouraged to upgrade to the latest version of waitress instead.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-03-17T13:15:07.647",
    "last_modified": "2024-11-21T06:51:02.277",
    "fix_date": "2022-03-16T21:26:15Z"
  },
  "references": [
    {
      "url": "https://github.com/Pylons/waitress/commit/9e0b8c801e4d505c2ffc91b891af4ba48af715e0",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Pylons/waitress/releases/tag/v2.1.1",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Pylons/waitress/security/advisories/GHSA-4f7p-27jc-3c36",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00011.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2022/dsa-5138",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Pylons/waitress/commit/9e0b8c801e4d505c2ffc91b891af4ba48af715e0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Pylons/waitress/releases/tag/v2.1.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/Pylons/waitress/security/advisories/GHSA-4f7p-27jc-3c36",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00011.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2022/dsa-5138",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:02.034001",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "waitress",
    "owner": "Pylons",
    "created_at": "2011-12-17T06:58:21Z",
    "updated_at": "2025-01-11T21:17:13Z",
    "pushed_at": "2024-11-25T01:07:27Z",
    "size": 1868,
    "stars": 1467,
    "forks": 178,
    "open_issues": 16,
    "watchers": 1467,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Python": 495340
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:00:04.687602"
  }
}