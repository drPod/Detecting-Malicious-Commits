{
  "cve_id": "CVE-2022-24766",
  "github_data": {
    "repository": "mitmproxy/mitmproxy",
    "fix_commit": "b06fb6d157087d526bd02e7aadbe37c56865c71b",
    "related_commits": [
      "b06fb6d157087d526bd02e7aadbe37c56865c71b",
      "b06fb6d157087d526bd02e7aadbe37c56865c71b"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "b06fb6d157087d526bd02e7aadbe37c56865c71b",
      "commit_date": "2022-03-16T08:56:50Z",
      "author": {
        "login": "mhils",
        "type": "User",
        "stats": {
          "total_commits": 4057,
          "average_weekly_commits": 5.194622279129321,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 457
        }
      },
      "commit_message": {
        "title": "security: reject whitespace in HTTP/1 header names",
        "length": 313,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 107,
        "additions": 95,
        "deletions": 12
      },
      "files": [
        {
          "filename": "mitmproxy/addons/proxyserver.py",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -98,6 +98,13 @@ def load(self, loader):\n             in custom scripts are lowercased before they are sent.\n             \"\"\",\n         )\n+        loader.add_option(\n+            \"validate_inbound_headers\", bool, True,\n+            \"\"\"\n+            Make sure that incoming HTTP requests are not malformed.\n+            Disabling this option makes mitmproxy vulnerable to HTTP smuggling attacks.\n+            \"\"\",\n+        )\n \n     async def running(self):\n         self.master = ctx.master"
        },
        {
          "filename": "mitmproxy/net/http/http1/__init__.py",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -3,6 +3,7 @@\n     read_response_head,\n     connection_close,\n     expected_http_body_size,\n+    validate_headers,\n )\n from .assemble import (\n     assemble_request, assemble_request_head,\n@@ -16,6 +17,7 @@\n     \"read_response_head\",\n     \"connection_close\",\n     \"expected_http_body_size\",\n+    \"validate_headers\",\n     \"assemble_request\", \"assemble_request_head\",\n     \"assemble_response\", \"assemble_response_head\",\n     \"assemble_body\","
        },
        {
          "filename": "mitmproxy/net/http/http1/read.py",
          "status": "modified",
          "additions": 34,
          "deletions": 4,
          "patch": "@@ -38,6 +38,38 @@ def connection_close(http_version, headers):\n     )\n \n \n+# https://datatracker.ietf.org/doc/html/rfc7230#section-3.2: Header fields are tokens.\n+# \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" /  \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n+_valid_header_name = re.compile(rb\"^[!#$%&'*+\\-.^_`|~0-9a-zA-Z]+$\")\n+\n+\n+def validate_headers(\n+    headers: Headers\n+) -> None:\n+    \"\"\"\n+    Validate headers to avoid request smuggling attacks. Raises a ValueError if they are malformed.\n+    \"\"\"\n+\n+    te_found = False\n+    cl_found = False\n+\n+    for (name, value) in headers.fields:\n+        if not _valid_header_name.match(name):\n+            raise ValueError(f\"Received an invalid header name: {name!r}. Invalid header names may introduce \"\n+                             f\"request smuggling vulnerabilities. Disable the validate_inbound_headers option \"\n+                             f\"to skip this security check.\")\n+\n+        name_lower = name.lower()\n+        te_found = te_found or name_lower == b\"transfer-encoding\"\n+        cl_found = cl_found or name_lower == b\"content-length\"\n+\n+    if te_found and cl_found:\n+        raise ValueError(\"Received both a Transfer-Encoding and a Content-Length header, \"\n+                         \"refusing as recommended in RFC 7230 Section 3.3.3. \"\n+                         \"See https://github.com/mitmproxy/mitmproxy/issues/4799 for details. \"\n+                         \"Disable the validate_inbound_headers option to skip this security check.\")\n+\n+\n def expected_http_body_size(\n         request: Request,\n         response: Optional[Response] = None\n@@ -101,10 +133,8 @@ def expected_http_body_size(\n     #        a message downstream.\n     #\n     if \"transfer-encoding\" in headers:\n-        if \"content-length\" in headers:\n-            raise ValueError(\"Received both a Transfer-Encoding and a Content-Length header, \"\n-                             \"refusing as recommended in RFC 7230 Section 3.3.3. \"\n-                             \"See https://github.com/mitmproxy/mitmproxy/issues/4799 for details.\")\n+        # we should make sure that there isn't also a content-length header.\n+        # this is already handled in validate_headers.\n \n         te: str = headers[\"transfer-encoding\"]\n         if not te.isascii():"
        },
        {
          "filename": "mitmproxy/proxy/layers/http/_http1.py",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -234,6 +234,8 @@ def read_headers(self, event: events.ConnectionEvent) -> layer.CommandGenerator[\n                 request_head = [bytes(x) for x in request_head]  # TODO: Make url.parse compatible with bytearrays\n                 try:\n                     self.request = http1.read_request_head(request_head)\n+                    if self.context.options.validate_inbound_headers:\n+                        http1.validate_headers(self.request.headers)\n                     expected_body_size = http1.expected_http_body_size(self.request)\n                 except ValueError as e:\n                     yield commands.SendData(self.conn, make_error_response(400, str(e)))\n@@ -330,6 +332,8 @@ def read_headers(self, event: events.ConnectionEvent) -> layer.CommandGenerator[\n                 response_head = [bytes(x) for x in response_head]  # TODO: Make url.parse compatible with bytearrays\n                 try:\n                     self.response = http1.read_response_head(response_head)\n+                    if self.context.options.validate_inbound_headers:\n+                        http1.validate_headers(self.response.headers)\n                     expected_size = http1.expected_http_body_size(self.request, self.response)\n                 except ValueError as e:\n                     yield commands.CloseConnection(self.conn)"
        },
        {
          "filename": "mitmproxy/proxy/layers/http/_http2.py",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -40,7 +40,7 @@ class Http2Connection(HttpConnection):\n     h2_conf_defaults = dict(\n         header_encoding=False,\n         validate_outbound_headers=False,\n-        validate_inbound_headers=True,\n+        # validate_inbound_headers is controlled by the validate_inbound_headers option.\n         normalize_inbound_headers=False,  # changing this to True is required to pass h2spec\n         normalize_outbound_headers=False,\n     )\n@@ -58,6 +58,7 @@ def __init__(self, context: Context, conn: Connection):\n         if self.debug:\n             self.h2_conf.logger = H2ConnectionLogger(f\"{human.format_address(self.context.client.peername)}: \"\n                                                      f\"{self.__class__.__name__}\")\n+        self.h2_conf.validate_inbound_headers = self.context.options.validate_inbound_headers\n         self.h2_conn = BufferedH2Connection(self.h2_conf)\n         self.streams = {}\n "
        },
        {
          "filename": "test/mitmproxy/net/http/http1/test_read.py",
          "status": "modified",
          "additions": 14,
          "deletions": 6,
          "patch": "@@ -4,7 +4,7 @@\n from mitmproxy.net.http.http1.read import (\n     read_request_head,\n     read_response_head, connection_close, expected_http_body_size,\n-    _read_request_line, _read_response_line, _read_headers, get_header_tokens\n+    _read_request_line, _read_response_line, _read_headers, get_header_tokens, validate_headers\n )\n from mitmproxy.test.tutils import treq, tresp\n \n@@ -59,6 +59,19 @@ def test_read_response_head():\n     assert r.content is None\n \n \n+def test_validate_headers():\n+    # both content-length and chunked (possible request smuggling)\n+    with pytest.raises(ValueError, match=\"Received both a Transfer-Encoding and a Content-Length header\"):\n+        validate_headers(\n+            Headers(transfer_encoding=\"chunked\", content_length=\"42\"),\n+        )\n+\n+    with pytest.raises(ValueError, match=\"Received an invalid header name\"):\n+        validate_headers(\n+            Headers([(b\"content-length \", b\"42\")]),\n+        )\n+\n+\n def test_expected_http_body_size():\n     # Expect: 100-continue\n     assert expected_http_body_size(\n@@ -91,11 +104,6 @@ def test_expected_http_body_size():\n     assert expected_http_body_size(\n         treq(headers=Headers(transfer_encoding=\"gzip,\\tchunked\")),\n     ) is None\n-    # both content-length and chunked (possible request smuggling)\n-    with pytest.raises(ValueError, match=\"Received both a Transfer-Encoding and a Content-Length header\"):\n-        expected_http_body_size(\n-            treq(headers=Headers(transfer_encoding=\"chunked\", content_length=\"42\")),\n-        )\n     with pytest.raises(ValueError, match=\"Invalid transfer encoding\"):\n         expected_http_body_size(\n             treq(headers=Headers(transfer_encoding=\"chun\\u212Aed\")),  # \"chun\u212aed\".lower() == \"chunked\""
        },
        {
          "filename": "test/mitmproxy/proxy/layers/http/test_http.py",
          "status": "modified",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -1261,6 +1261,37 @@ def test_request_smuggling(tctx):\n     assert b\"Received both a Transfer-Encoding and a Content-Length header\" in err()\n \n \n+def test_request_smuggling_whitespace(tctx):\n+    \"\"\"Test that we reject header names with whitespace\"\"\"\n+    err = Placeholder(bytes)\n+    assert (\n+        Playbook(http.HttpLayer(tctx, HTTPMode.regular), hooks=False)\n+        >> DataReceived(tctx.client, b\"GET http://example.com/ HTTP/1.1\\r\\n\"\n+                                     b\"Host: example.com\\r\\n\"\n+                                     b\"Content-Length : 42\\r\\n\\r\\n\")\n+        << SendData(tctx.client, err)\n+        << CloseConnection(tctx.client)\n+    )\n+    assert b\"Received an invalid header name\" in err()\n+\n+\n+def test_request_smuggling_validation_disabled(tctx):\n+    \"\"\"Test that we don't reject request smuggling when validation is disabled.\"\"\"\n+    tctx.options.validate_inbound_headers = False\n+    assert (\n+        Playbook(http.HttpLayer(tctx, HTTPMode.regular), hooks=False)\n+        >> DataReceived(tctx.client, b\"GET http://example.com/ HTTP/1.1\\r\\n\"\n+                                     b\"Host: example.com\\r\\n\"\n+                                     b\"Content-Length: 4\\r\\n\"\n+                                     b\"Transfer-Encoding: chunked\\r\\n\\r\\n\"\n+                                     b\"4\\r\\n\"\n+                                     b\"abcd\\r\\n\"\n+                                     b\"0\\r\\n\"\n+                                     b\"\\r\\n\")\n+        << OpenConnection(Placeholder(Server))\n+    )\n+\n+\n def test_request_smuggling_te_te(tctx):\n     \"\"\"Test that we reject transfer-encoding headers that are weird in some way\"\"\"\n     err = Placeholder(bytes)"
        },
        {
          "filename": "test/mitmproxy/proxy/layers/http/test_http2.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -352,11 +352,11 @@ def enable_response_streaming(flow: HTTPFlow):\n         assert \"peer closed connection\" in flow().error.msg\n \n \n-@pytest.mark.xfail(reason=\"inbound validation turned on to protect against request smuggling\")\n @pytest.mark.parametrize(\"normalize\", [True, False])\n def test_no_normalization(tctx, normalize):\n     \"\"\"Test that we don't normalize headers when we just pass them through.\"\"\"\n     tctx.options.normalize_outbound_headers = normalize\n+    tctx.options.validate_inbound_headers = False\n \n     server = Placeholder(Server)\n     flow = Placeholder(HTTPFlow)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 5,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b761cb46c4dc5192cd4d2a10013be3647e70d322",
            "date": "2025-01-19T15:10:55Z",
            "author_login": "mhils"
          },
          {
            "sha": "e78ab0ffd96a90dc8b6d2913c5a2bc759fc6133c",
            "date": "2025-01-17T17:09:45Z",
            "author_login": "mhils"
          },
          {
            "sha": "99e79f7619470b690edd8805456344210a72cd68",
            "date": "2025-01-16T21:15:31Z",
            "author_login": "mhils"
          },
          {
            "sha": "2f4a5062b959512225033bf93824d5e6a66ab980",
            "date": "2025-01-16T20:37:30Z",
            "author_login": "mhils"
          },
          {
            "sha": "0e3b0992eea1994888444839e1dab8bee5b6ab6d",
            "date": "2025-01-16T14:58:00Z",
            "author_login": "meitinger"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-444",
    "description": "mitmproxy is an interactive, SSL/TLS-capable intercepting proxy. In mitmproxy 7.0.4 and below, a malicious client or server is able to perform HTTP request smuggling attacks through mitmproxy. This means that a malicious client/server could smuggle a request/response through mitmproxy as part of another request/response's HTTP message body. While mitmproxy would only see one request, the target server would see multiple requests. A smuggled request is still captured as part of another request's body, but it does not appear in the request list and does not go through the usual mitmproxy event hooks, where users may have implemented custom access control checks or input sanitization. Unless mitmproxy is used to protect an HTTP/1 service, no action is required. The vulnerability has been fixed in mitmproxy 8.0.0 and above. There are currently no known workarounds.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-03-21T19:15:11.613",
    "last_modified": "2024-11-21T06:51:03.097",
    "fix_date": "2022-03-16T08:56:50Z"
  },
  "references": [
    {
      "url": "https://github.com/mitmproxy/mitmproxy/commit/b06fb6d157087d526bd02e7aadbe37c56865c71b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/mitmproxy/mitmproxy/security/advisories/GHSA-gcx2-gvj7-pxv3",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://mitmproxy.org/posts/releases/mitmproxy8/",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/mitmproxy/mitmproxy/commit/b06fb6d157087d526bd02e7aadbe37c56865c71b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/mitmproxy/mitmproxy/security/advisories/GHSA-gcx2-gvj7-pxv3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://mitmproxy.org/posts/releases/mitmproxy8/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:02.047323",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "mitmproxy",
    "owner": "mitmproxy",
    "created_at": "2010-02-16T04:10:13Z",
    "updated_at": "2025-01-14T20:41:07Z",
    "pushed_at": "2025-01-13T12:04:08Z",
    "size": 63629,
    "stars": 37554,
    "forks": 4080,
    "open_issues": 362,
    "watchers": 37554,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Python": 2745355,
      "TypeScript": 448942,
      "JavaScript": 121441,
      "Less": 29532,
      "HTML": 11270,
      "Kaitai Struct": 3685,
      "CSS": 3618,
      "Shell": 3299,
      "Dockerfile": 702,
      "PowerShell": 258
    },
    "commit_activity": {
      "total_commits_last_year": 476,
      "avg_commits_per_week": 9.153846153846153,
      "days_active_last_year": 129
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T20:49:26.847820"
  }
}