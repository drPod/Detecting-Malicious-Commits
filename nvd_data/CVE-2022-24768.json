{
  "cve_id": "CVE-2022-24768",
  "github_data": {
    "repository": "argoproj/argo-cd",
    "fix_commit": "af03b291d4b7e9d3ce9a6580ae9c8141af0e05cf",
    "related_commits": [
      "af03b291d4b7e9d3ce9a6580ae9c8141af0e05cf",
      "af03b291d4b7e9d3ce9a6580ae9c8141af0e05cf"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "af03b291d4b7e9d3ce9a6580ae9c8141af0e05cf",
      "commit_date": "2022-03-22T17:57:30Z",
      "author": {
        "login": "alexmt",
        "type": "User",
        "stats": {
          "total_commits": 476,
          "average_weekly_commits": 1.3112947658402203,
          "total_additions": 243832,
          "total_deletions": 121311,
          "weeks_active": 148
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-2f5v-8r3f-8pww",
        "length": 285,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 273,
        "additions": 197,
        "deletions": 76
      },
      "files": [
        {
          "filename": "controller/appcontroller.go",
          "status": "modified",
          "additions": 18,
          "deletions": 4,
          "patch": "@@ -28,6 +28,7 @@ import (\n \t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n \t\"k8s.io/apimachinery/pkg/labels\"\n \tapiruntime \"k8s.io/apimachinery/pkg/runtime\"\n+\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n \t\"k8s.io/apimachinery/pkg/types\"\n \t\"k8s.io/apimachinery/pkg/util/runtime\"\n \t\"k8s.io/apimachinery/pkg/util/wait\"\n@@ -421,8 +422,12 @@ func (ctrl *ApplicationController) getResourceTree(a *appv1.Application, managed\n \t\t\t\t},\n \t\t\t})\n \t\t} else {\n-\t\t\terr := ctrl.stateCache.IterateHierarchy(a.Spec.Destination.Server, kube.GetResourceKey(live), func(child appv1.ResourceNode, appName string) {\n+\t\t\terr := ctrl.stateCache.IterateHierarchy(a.Spec.Destination.Server, kube.GetResourceKey(live), func(child appv1.ResourceNode, appName string) bool {\n+\t\t\t\tif !proj.IsResourcePermitted(schema.GroupKind{Group: child.ResourceRef.Group, Kind: child.ResourceRef.Kind}, child.Namespace, a.Spec.Destination) {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n \t\t\t\tnodes = append(nodes, child)\n+\t\t\t\treturn true\n \t\t\t})\n \t\t\tif err != nil {\n \t\t\t\treturn nil, err\n@@ -432,16 +437,18 @@ func (ctrl *ApplicationController) getResourceTree(a *appv1.Application, managed\n \torphanedNodes := make([]appv1.ResourceNode, 0)\n \tfor k := range orphanedNodesMap {\n \t\tif k.Namespace != \"\" && proj.IsGroupKindPermitted(k.GroupKind(), true) && !isKnownOrphanedResourceExclusion(k, proj) {\n-\t\t\terr := ctrl.stateCache.IterateHierarchy(a.Spec.Destination.Server, k, func(child appv1.ResourceNode, appName string) {\n+\t\t\terr := ctrl.stateCache.IterateHierarchy(a.Spec.Destination.Server, k, func(child appv1.ResourceNode, appName string) bool {\n \t\t\t\tbelongToAnotherApp := false\n \t\t\t\tif appName != \"\" {\n \t\t\t\t\tif _, exists, err := ctrl.appInformer.GetIndexer().GetByKey(ctrl.namespace + \"/\" + appName); exists && err == nil {\n \t\t\t\t\t\tbelongToAnotherApp = true\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tif !belongToAnotherApp {\n-\t\t\t\t\torphanedNodes = append(orphanedNodes, child)\n+\t\t\t\tif belongToAnotherApp || !proj.IsResourcePermitted(schema.GroupKind{Group: child.ResourceRef.Group, Kind: child.ResourceRef.Kind}, child.Namespace, a.Spec.Destination) {\n+\t\t\t\t\treturn false\n \t\t\t\t}\n+\t\t\t\torphanedNodes = append(orphanedNodes, child)\n+\t\t\t\treturn true\n \t\t\t})\n \t\t\tif err != nil {\n \t\t\t\treturn nil, err\n@@ -1291,6 +1298,13 @@ func (ctrl *ApplicationController) processAppRefreshQueueItem() (processNext boo\n \t\tapp.Status.Sync.Status = appv1.SyncStatusCodeUnknown\n \t\tapp.Status.Health.Status = health.HealthStatusUnknown\n \t\tctrl.persistAppStatus(origApp, &app.Status)\n+\n+\t\tif err := ctrl.cache.SetAppResourcesTree(app.Name, &appv1.ApplicationTree{}); err != nil {\n+\t\t\tlog.Warnf(\"failed to set app resource tree: %v\", err)\n+\t\t}\n+\t\tif err := ctrl.cache.SetAppManagedResources(app.Name, nil); err != nil {\n+\t\t\tlog.Warnf(\"failed to set app managed resources tree: %v\", err)\n+\t\t}\n \t\treturn\n \t}\n "
        },
        {
          "filename": "controller/appcontroller_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -136,12 +136,12 @@ func newFakeController(data *fakeData) *ApplicationController {\n \tmockStateCache.On(\"GetClusterCache\", mock.Anything).Return(&clusterCacheMock, nil)\n \tmockStateCache.On(\"IterateHierarchy\", mock.Anything, mock.Anything, mock.Anything).Run(func(args mock.Arguments) {\n \t\tkey := args[1].(kube.ResourceKey)\n-\t\taction := args[2].(func(child argoappv1.ResourceNode, appName string))\n+\t\taction := args[2].(func(child argoappv1.ResourceNode, appName string) bool)\n \t\tappName := \"\"\n \t\tif res, ok := data.namespacedResources[key]; ok {\n \t\t\tappName = res.AppName\n \t\t}\n-\t\taction(argoappv1.ResourceNode{ResourceRef: argoappv1.ResourceRef{Kind: key.Kind, Group: key.Group, Namespace: key.Namespace, Name: key.Name}}, appName)\n+\t\t_ = action(argoappv1.ResourceNode{ResourceRef: argoappv1.ResourceRef{Kind: key.Kind, Group: key.Group, Namespace: key.Namespace, Name: key.Name}}, appName)\n \t}).Return(nil)\n \treturn ctrl\n }"
        },
        {
          "filename": "controller/cache/cache.go",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -108,7 +108,7 @@ type LiveStateCache interface {\n \t// Returns synced cluster cache\n \tGetClusterCache(server string) (clustercache.ClusterCache, error)\n \t// Executes give callback against resource specified by the key and all its children\n-\tIterateHierarchy(server string, key kube.ResourceKey, action func(child appv1.ResourceNode, appName string)) error\n+\tIterateHierarchy(server string, key kube.ResourceKey, action func(child appv1.ResourceNode, appName string) bool) error\n \t// Returns state of live nodes which correspond for target nodes of specified application.\n \tGetManagedLiveObjs(a *appv1.Application, targetObjs []*unstructured.Unstructured) (map[kube.ResourceKey]*unstructured.Unstructured, error)\n \t// IterateResources iterates all resource stored in cache\n@@ -481,13 +481,13 @@ func (c *liveStateCache) IsNamespaced(server string, gk schema.GroupKind) (bool,\n \treturn clusterInfo.IsNamespaced(gk)\n }\n \n-func (c *liveStateCache) IterateHierarchy(server string, key kube.ResourceKey, action func(child appv1.ResourceNode, appName string)) error {\n+func (c *liveStateCache) IterateHierarchy(server string, key kube.ResourceKey, action func(child appv1.ResourceNode, appName string) bool) error {\n \tclusterInfo, err := c.getSyncedCluster(server)\n \tif err != nil {\n \t\treturn err\n \t}\n-\tclusterInfo.IterateHierarchy(key, func(resource *clustercache.Resource, namespaceResources map[kube.ResourceKey]*clustercache.Resource) {\n-\t\taction(asResourceNode(resource), getApp(resource, namespaceResources))\n+\tclusterInfo.IterateHierarchy(key, func(resource *clustercache.Resource, namespaceResources map[kube.ResourceKey]*clustercache.Resource) bool {\n+\t\treturn action(asResourceNode(resource), getApp(resource, namespaceResources))\n \t})\n \treturn nil\n }"
        },
        {
          "filename": "controller/cache/mocks/LiveStateCache.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -176,11 +176,11 @@ func (_m *LiveStateCache) IsNamespaced(server string, gk schema.GroupKind) (bool\n }\n \n // IterateHierarchy provides a mock function with given fields: server, key, action\n-func (_m *LiveStateCache) IterateHierarchy(server string, key kube.ResourceKey, action func(v1alpha1.ResourceNode, string)) error {\n+func (_m *LiveStateCache) IterateHierarchy(server string, key kube.ResourceKey, action func(v1alpha1.ResourceNode, string) bool) error {\n \tret := _m.Called(server, key, action)\n \n \tvar r0 error\n-\tif rf, ok := ret.Get(0).(func(string, kube.ResourceKey, func(v1alpha1.ResourceNode, string)) error); ok {\n+\tif rf, ok := ret.Get(0).(func(string, kube.ResourceKey, func(v1alpha1.ResourceNode, string) bool) error); ok {\n \t\tr0 = rf(server, key, action)\n \t} else {\n \t\tr0 = ret.Error(0)"
        },
        {
          "filename": "go.mod",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -8,7 +8,7 @@ require (\n \tgithub.com/TomOnTime/utfutil v0.0.0-20180511104225-09c41003ee1d\n \tgithub.com/alicebob/miniredis v2.5.0+incompatible\n \tgithub.com/alicebob/miniredis/v2 v2.14.2\n-\tgithub.com/argoproj/gitops-engine v0.6.0\n+\tgithub.com/argoproj/gitops-engine v0.6.1-0.20220316000647-723667dff7d5\n \tgithub.com/argoproj/notifications-engine v0.3.1-0.20220127183449-91deed20b998\n \tgithub.com/argoproj/pkg v0.11.1-0.20211203175135-36c59d8fafe0\n \tgithub.com/bombsimon/logrusr/v2 v2.0.1"
        },
        {
          "filename": "go.sum",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -130,8 +130,8 @@ github.com/antonmedv/expr v1.8.9/go.mod h1:5qsM3oLGDND7sDmQGDXHkYfkjYMUX14qsgqmH\n github.com/apache/thrift v0.12.0/go.mod h1:cp2SuWMxlEZw2r+iP2GNCdIi4C1qmUzdZFSVb+bacwQ=\n github.com/apache/thrift v0.13.0/go.mod h1:cp2SuWMxlEZw2r+iP2GNCdIi4C1qmUzdZFSVb+bacwQ=\n github.com/appscode/go v0.0.0-20190808133642-1d4ef1f1c1e0/go.mod h1:iy07dV61Z7QQdCKJCIvUoDL21u6AIceRhZzyleh2ymc=\n-github.com/argoproj/gitops-engine v0.6.0 h1:Tnh6kUUVuBV0m3gueYIymAeErWl9XNN9O9JcOoNM0vU=\n-github.com/argoproj/gitops-engine v0.6.0/go.mod h1:pRgVpLW7pZqf7n3COJ7UcDepk4cI61LAcJd64Q3Jq/c=\n+github.com/argoproj/gitops-engine v0.6.1-0.20220316000647-723667dff7d5 h1:QZvSvXHKx/hKTvbw3EK+u9JDVlo6UvC4+IVqNIGbcUo=\n+github.com/argoproj/gitops-engine v0.6.1-0.20220316000647-723667dff7d5/go.mod h1:pRgVpLW7pZqf7n3COJ7UcDepk4cI61LAcJd64Q3Jq/c=\n github.com/argoproj/notifications-engine v0.3.1-0.20220127183449-91deed20b998 h1:V9RDg+IZeebnm3XjkfkbN07VM21Fu1Cy/RJNoHO++VM=\n github.com/argoproj/notifications-engine v0.3.1-0.20220127183449-91deed20b998/go.mod h1:5mKv7zEgI3NO0L+fsuRSwBSY9EIXSuyIsDND8O8TTIw=\n github.com/argoproj/pkg v0.11.1-0.20211203175135-36c59d8fafe0 h1:Cfp7rO/HpVxnwlRqJe0jHiBbZ77ZgXhB6HWlYD02Xdc="
        },
        {
          "filename": "pkg/apis/application/v1alpha1/app_project_types.go",
          "status": "modified",
          "additions": 7,
          "deletions": 3,
          "patch": "@@ -313,11 +313,15 @@ func (proj AppProject) IsGroupKindPermitted(gk schema.GroupKind, namespaced bool\n \n // IsLiveResourcePermitted returns whether a live resource found in the cluster is permitted by an AppProject\n func (proj AppProject) IsLiveResourcePermitted(un *unstructured.Unstructured, server string, name string) bool {\n-\tif !proj.IsGroupKindPermitted(un.GroupVersionKind().GroupKind(), un.GetNamespace() != \"\") {\n+\treturn proj.IsResourcePermitted(un.GroupVersionKind().GroupKind(), un.GetNamespace(), ApplicationDestination{Server: server, Name: name})\n+}\n+\n+func (proj AppProject) IsResourcePermitted(groupKind schema.GroupKind, namespace string, dest ApplicationDestination) bool {\n+\tif !proj.IsGroupKindPermitted(groupKind, namespace != \"\") {\n \t\treturn false\n \t}\n-\tif un.GetNamespace() != \"\" {\n-\t\treturn proj.IsDestinationPermitted(ApplicationDestination{Server: server, Namespace: un.GetNamespace(), Name: name})\n+\tif namespace != \"\" {\n+\t\treturn proj.IsDestinationPermitted(ApplicationDestination{Server: dest.Server, Name: dest.Name, Namespace: namespace})\n \t}\n \treturn true\n }"
        },
        {
          "filename": "server/application/application.go",
          "status": "modified",
          "additions": 23,
          "deletions": 8,
          "patch": "@@ -488,6 +488,21 @@ func (s *Server) ListResourceEvents(ctx context.Context, q *application.Applicat\n \t\t\t\"involvedObject.namespace\": a.Namespace,\n \t\t}).String()\n \t} else {\n+\t\ttree, err := s.getAppResources(ctx, a)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tfound := false\n+\t\tfor _, n := range append(tree.Nodes, tree.OrphanedNodes...) {\n+\t\t\tif n.ResourceRef.UID == q.ResourceUID && n.ResourceRef.Name == q.ResourceName && n.ResourceRef.Namespace == q.ResourceNamespace {\n+\t\t\t\tfound = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif !found {\n+\t\t\treturn nil, status.Errorf(codes.InvalidArgument, \"%s not found as part of application %s\", q.ResourceName, *q.Name)\n+\t\t}\n+\n \t\tnamespace = q.ResourceNamespace\n \t\tvar config *rest.Config\n \t\tconfig, err = s.getApplicationClusterConfig(ctx, a)\n@@ -937,7 +952,7 @@ func (s *Server) getAppResources(ctx context.Context, a *appv1.Application) (*ap\n \treturn &tree, err\n }\n \n-func (s *Server) getAppResource(ctx context.Context, action string, q *application.ApplicationResourceRequest) (*appv1.ResourceNode, *rest.Config, *appv1.Application, error) {\n+func (s *Server) getAppLiveResource(ctx context.Context, action string, q *application.ApplicationResourceRequest) (*appv1.ResourceNode, *rest.Config, *appv1.Application, error) {\n \ta, err := s.appLister.Get(*q.Name)\n \tif err != nil {\n \t\treturn nil, nil, nil, err\n@@ -952,7 +967,7 @@ func (s *Server) getAppResource(ctx context.Context, action string, q *applicati\n \t}\n \n \tfound := tree.FindNode(q.Group, q.Kind, q.Namespace, q.ResourceName)\n-\tif found == nil {\n+\tif found == nil || found.ResourceRef.UID == \"\" {\n \t\treturn nil, nil, nil, status.Errorf(codes.InvalidArgument, \"%s %s %s not found as part of application %s\", q.Kind, q.Group, q.ResourceName, *q.Name)\n \t}\n \tconfig, err := s.getApplicationClusterConfig(ctx, a)\n@@ -963,7 +978,7 @@ func (s *Server) getAppResource(ctx context.Context, action string, q *applicati\n }\n \n func (s *Server) GetResource(ctx context.Context, q *application.ApplicationResourceRequest) (*application.ApplicationResourceResponse, error) {\n-\tres, config, _, err := s.getAppResource(ctx, rbacpolicy.ActionGet, q)\n+\tres, config, _, err := s.getAppLiveResource(ctx, rbacpolicy.ActionGet, q)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1008,7 +1023,7 @@ func (s *Server) PatchResource(ctx context.Context, q *application.ApplicationRe\n \t\tVersion:      q.Version,\n \t\tGroup:        q.Group,\n \t}\n-\tres, config, a, err := s.getAppResource(ctx, rbacpolicy.ActionUpdate, resourceRequest)\n+\tres, config, a, err := s.getAppLiveResource(ctx, rbacpolicy.ActionUpdate, resourceRequest)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1048,7 +1063,7 @@ func (s *Server) DeleteResource(ctx context.Context, q *application.ApplicationR\n \t\tVersion:      q.Version,\n \t\tGroup:        q.Group,\n \t}\n-\tres, config, a, err := s.getAppResource(ctx, rbacpolicy.ActionDelete, resourceRequest)\n+\tres, config, a, err := s.getAppLiveResource(ctx, rbacpolicy.ActionDelete, resourceRequest)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1335,7 +1350,7 @@ func getSelectedPods(treeNodes []appv1.ResourceNode, q *application.ApplicationP\n \tvar pods []appv1.ResourceNode\n \tisTheOneMap := make(map[string]bool)\n \tfor _, treeNode := range treeNodes {\n-\t\tif treeNode.Kind == kube.PodKind && treeNode.Group == \"\" {\n+\t\tif treeNode.Kind == kube.PodKind && treeNode.Group == \"\" && treeNode.UID != \"\" {\n \t\t\tif isTheSelectedOne(&treeNode, q, treeNodes, isTheOneMap) {\n \t\t\t\tpods = append(pods, treeNode)\n \t\t\t}\n@@ -1625,7 +1640,7 @@ func (s *Server) logResourceEvent(res *appv1.ResourceNode, ctx context.Context,\n }\n \n func (s *Server) ListResourceActions(ctx context.Context, q *application.ApplicationResourceRequest) (*application.ResourceActionsListResponse, error) {\n-\tres, config, _, err := s.getAppResource(ctx, rbacpolicy.ActionGet, q)\n+\tres, config, _, err := s.getAppLiveResource(ctx, rbacpolicy.ActionGet, q)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1676,7 +1691,7 @@ func (s *Server) RunResourceAction(ctx context.Context, q *application.ResourceA\n \t\tGroup:        q.Group,\n \t}\n \tactionRequest := fmt.Sprintf(\"%s/%s/%s/%s\", rbacpolicy.ActionAction, q.Group, q.Kind, q.Action)\n-\tres, config, a, err := s.getAppResource(ctx, actionRequest, resourceRequest)\n+\tres, config, a, err := s.getAppLiveResource(ctx, actionRequest, resourceRequest)\n \tif err != nil {\n \t\treturn nil, err\n \t}"
        },
        {
          "filename": "test/e2e/app_management_test.go",
          "status": "modified",
          "additions": 111,
          "deletions": 50,
          "patch": "@@ -1046,64 +1046,125 @@ func TestSyncAsync(t *testing.T) {\n \t\tExpect(SyncStatusIs(SyncStatusCodeSynced))\n }\n \n-func TestPermissions(t *testing.T) {\n-\tEnsureCleanState(t)\n-\tappName := Name()\n-\t_, err := RunCli(\"proj\", \"create\", \"test\")\n-\tassert.NoError(t, err)\n+// assertResourceActions verifies if view/modify resource actions are successful/failing for given application\n+func assertResourceActions(t *testing.T, appName string, successful bool) {\n+\tassertError := func(err error, message string) {\n+\t\tif successful {\n+\t\t\tassert.NoError(t, err)\n+\t\t} else {\n+\t\t\tif assert.Error(t, err) {\n+\t\t\t\tassert.Contains(t, err.Error(), message)\n+\t\t\t}\n+\t\t}\n+\t}\n \n-\t// make sure app cannot be created without permissions in project\n-\t_, err = RunCli(\"app\", \"create\", appName, \"--repo\", RepoURL(RepoURLTypeFile),\n-\t\t\"--path\", guestbookPath, \"--project\", \"test\", \"--dest-server\", KubernetesInternalAPIServerAddr, \"--dest-namespace\", DeploymentNamespace())\n-\tassert.Error(t, err)\n-\tsourceError := fmt.Sprintf(\"application repo %s is not permitted in project 'test'\", RepoURL(RepoURLTypeFile))\n-\tdestinationError := fmt.Sprintf(\"application destination {%s %s} is not permitted in project 'test'\", KubernetesInternalAPIServerAddr, DeploymentNamespace())\n+\tcloser, cdClient := ArgoCDClientset.NewApplicationClientOrDie()\n+\tdefer io.Close(closer)\n \n-\tassert.Contains(t, err.Error(), sourceError)\n-\tassert.Contains(t, err.Error(), destinationError)\n+\tdeploymentResource, err := KubeClientset.AppsV1().Deployments(DeploymentNamespace()).Get(context.Background(), \"guestbook-ui\", metav1.GetOptions{})\n+\trequire.NoError(t, err)\n \n-\tproj, err := AppClientset.ArgoprojV1alpha1().AppProjects(ArgoCDNamespace).Get(context.Background(), \"test\", metav1.GetOptions{})\n-\tassert.NoError(t, err)\n+\tlogs, err := cdClient.PodLogs(context.Background(), &applicationpkg.ApplicationPodLogsQuery{\n+\t\tGroup: pointer.String(\"apps\"), Kind: pointer.String(\"Deployment\"), Name: &appName, Namespace: DeploymentNamespace(),\n+\t})\n+\trequire.NoError(t, err)\n+\t_, err = logs.Recv()\n+\tassertError(err, \"EOF\")\n \n-\tproj.Spec.Destinations = []ApplicationDestination{{Server: \"*\", Namespace: \"*\"}}\n-\tproj.Spec.SourceRepos = []string{\"*\"}\n-\tproj, err = AppClientset.ArgoprojV1alpha1().AppProjects(ArgoCDNamespace).Update(context.Background(), proj, metav1.UpdateOptions{})\n-\tassert.NoError(t, err)\n+\texpectedError := fmt.Sprintf(\"Deployment apps guestbook-ui not found as part of application %s\", appName)\n \n-\t// make sure controller report permissions issues in conditions\n-\t_, err = RunCli(\"app\", \"create\", appName, \"--repo\", RepoURL(RepoURLTypeFile),\n-\t\t\"--path\", guestbookPath, \"--project\", \"test\", \"--dest-server\", KubernetesInternalAPIServerAddr, \"--dest-namespace\", DeploymentNamespace())\n-\tassert.NoError(t, err)\n-\tdefer func() {\n-\t\terr = AppClientset.ArgoprojV1alpha1().Applications(ArgoCDNamespace).Delete(context.Background(), appName, metav1.DeleteOptions{})\n-\t\tassert.NoError(t, err)\n-\t}()\n+\t_, err = cdClient.ListResourceEvents(context.Background(), &applicationpkg.ApplicationResourceEventsQuery{\n+\t\tName: &appName, ResourceName: \"guestbook-ui\", ResourceNamespace: DeploymentNamespace(), ResourceUID: string(deploymentResource.UID)})\n+\tassertError(err, fmt.Sprintf(\"%s not found as part of application %s\", \"guestbook-ui\", appName))\n \n-\tproj.Spec.Destinations = []ApplicationDestination{}\n-\tproj.Spec.SourceRepos = []string{}\n-\t_, err = AppClientset.ArgoprojV1alpha1().AppProjects(ArgoCDNamespace).Update(context.Background(), proj, metav1.UpdateOptions{})\n-\tassert.NoError(t, err)\n-\ttime.Sleep(1 * time.Second)\n-\tcloser, client, err := ArgoCDClientset.NewApplicationClient()\n-\tassert.NoError(t, err)\n-\tdefer io.Close(closer)\n+\t_, err = cdClient.GetResource(context.Background(), &applicationpkg.ApplicationResourceRequest{\n+\t\tName: &appName, ResourceName: \"guestbook-ui\", Namespace: DeploymentNamespace(), Version: \"v1\", Group: \"apps\", Kind: \"Deployment\"})\n+\tassertError(err, expectedError)\n \n-\trefresh := string(RefreshTypeNormal)\n-\tapp, err := client.Get(context.Background(), &applicationpkg.ApplicationQuery{Name: &appName, Refresh: &refresh})\n-\tassert.NoError(t, err)\n+\t_, err = cdClient.DeleteResource(context.Background(), &applicationpkg.ApplicationResourceDeleteRequest{\n+\t\tName: &appName, ResourceName: \"guestbook-ui\", Namespace: DeploymentNamespace(), Version: \"v1\", Group: \"apps\", Kind: \"Deployment\",\n+\t})\n+\tassertError(err, expectedError)\n \n-\tdestinationErrorExist := false\n-\tsourceErrorExist := false\n-\tfor i := range app.Status.Conditions {\n-\t\tif strings.Contains(app.Status.Conditions[i].Message, destinationError) {\n-\t\t\tdestinationErrorExist = true\n-\t\t}\n-\t\tif strings.Contains(app.Status.Conditions[i].Message, sourceError) {\n-\t\t\tsourceErrorExist = true\n-\t\t}\n-\t}\n-\tassert.True(t, destinationErrorExist)\n-\tassert.True(t, sourceErrorExist)\n+\t_, err = cdClient.RunResourceAction(context.Background(), &applicationpkg.ResourceActionRunRequest{\n+\t\tName: &appName, ResourceName: \"guestbook-ui\", Namespace: DeploymentNamespace(), Version: \"v1\", Group: \"apps\", Kind: \"Deployment\", Action: \"restart\",\n+\t})\n+\tassertError(err, expectedError)\n+}\n+\n+func TestPermissions(t *testing.T) {\n+\tappCtx := Given(t)\n+\tprojName := \"argo-project\"\n+\tprojActions := projectFixture.\n+\t\tGiven(t).\n+\t\tName(projName).\n+\t\tWhen().\n+\t\tCreate()\n+\n+\tsourceError := fmt.Sprintf(\"application repo %s is not permitted in project 'argo-project'\", RepoURL(RepoURLTypeFile))\n+\tdestinationError := fmt.Sprintf(\"application destination {%s %s} is not permitted in project 'argo-project'\", KubernetesInternalAPIServerAddr, DeploymentNamespace())\n+\n+\tappCtx.\n+\t\tPath(\"guestbook-logs\").\n+\t\tProject(projName).\n+\t\tWhen().\n+\t\tIgnoreErrors().\n+\t\t// ensure app is not created if project permissions are missing\n+\t\tCreateApp().\n+\t\tThen().\n+\t\tExpect(Error(\"\", sourceError)).\n+\t\tExpect(Error(\"\", destinationError)).\n+\t\tWhen().\n+\t\tDoNotIgnoreErrors().\n+\t\t// add missing permissions, create and sync app\n+\t\tAnd(func() {\n+\t\t\tprojActions.AddDestination(\"*\", \"*\")\n+\t\t\tprojActions.AddSource(\"*\")\n+\t\t}).\n+\t\tCreateApp().\n+\t\tSync().\n+\t\tThen().\n+\t\t// make sure application resource actiions are successful\n+\t\tAnd(func(app *Application) {\n+\t\t\tassertResourceActions(t, app.Name, true)\n+\t\t}).\n+\t\tWhen().\n+\t\t// remove projet permissions and \"refresh\" app\n+\t\tAnd(func() {\n+\t\t\tprojActions.UpdateProject(func(proj *AppProject) {\n+\t\t\t\tproj.Spec.Destinations = nil\n+\t\t\t\tproj.Spec.SourceRepos = nil\n+\t\t\t})\n+\t\t}).\n+\t\tRefresh(RefreshTypeNormal).\n+\t\tThen().\n+\t\t// ensure app resource tree is empty when source/destination permissions are missing\n+\t\tExpect(Condition(ApplicationConditionInvalidSpecError, destinationError)).\n+\t\tExpect(Condition(ApplicationConditionInvalidSpecError, sourceError)).\n+\t\tAnd(func(app *Application) {\n+\t\t\tcloser, cdClient := ArgoCDClientset.NewApplicationClientOrDie()\n+\t\t\tdefer io.Close(closer)\n+\t\t\ttree, err := cdClient.ResourceTree(context.Background(), &applicationpkg.ResourcesQuery{ApplicationName: &app.Name})\n+\t\t\trequire.NoError(t, err)\n+\t\t\tassert.Len(t, tree.Nodes, 0)\n+\t\t\tassert.Len(t, tree.OrphanedNodes, 0)\n+\t\t}).\n+\t\tWhen().\n+\t\t// add missing permissions but deny management of Deployment kind\n+\t\tAnd(func() {\n+\t\t\tprojActions.\n+\t\t\t\tAddDestination(\"*\", \"*\").\n+\t\t\t\tAddSource(\"*\").\n+\t\t\t\tUpdateProject(func(proj *AppProject) {\n+\t\t\t\t\tproj.Spec.NamespaceResourceBlacklist = []metav1.GroupKind{{Group: \"*\", Kind: \"Deployment\"}}\n+\t\t\t\t})\n+\t\t}).\n+\t\tRefresh(RefreshTypeNormal).\n+\t\tThen().\n+\t\t// make sure application resource actiions are failing\n+\t\tAnd(func(app *Application) {\n+\t\t\tassertResourceActions(t, \"test-permissions\", false)\n+\t\t})\n }\n \n func TestPermissionWithScopedRepo(t *testing.T) {"
        },
        {
          "filename": "test/e2e/fixture/project/actions.go",
          "status": "modified",
          "additions": 27,
          "deletions": 0,
          "patch": "@@ -1,7 +1,12 @@\n package project\n \n import (\n+\t\"context\"\n+\n+\t\"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n \t\"github.com/argoproj/argo-cd/v2/test/e2e/fixture\"\n+\t\"github.com/stretchr/testify/require\"\n+\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n )\n \n // this implements the \"when\" part of given/when/then\n@@ -34,6 +39,25 @@ func (a *Actions) Create(args ...string) *Actions {\n \treturn a\n }\n \n+func (a *Actions) AddDestination(cluster string, namespace string) *Actions {\n+\ta.runCli(\"proj\", \"add-destination\", a.context.name, cluster, namespace)\n+\treturn a\n+}\n+\n+func (a *Actions) AddSource(repo string) *Actions {\n+\ta.runCli(\"proj\", \"add-source\", a.context.name, repo)\n+\treturn a\n+}\n+\n+func (a *Actions) UpdateProject(updater func(project *v1alpha1.AppProject)) *Actions {\n+\tproj, err := fixture.AppClientset.ArgoprojV1alpha1().AppProjects(fixture.ArgoCDNamespace).Get(context.TODO(), a.context.name, v1.GetOptions{})\n+\trequire.NoError(a.context.t, err)\n+\tupdater(proj)\n+\t_, err = fixture.AppClientset.ArgoprojV1alpha1().AppProjects(fixture.ArgoCDNamespace).Update(context.TODO(), proj, v1.UpdateOptions{})\n+\trequire.NoError(a.context.t, err)\n+\treturn a\n+}\n+\n func (a *Actions) Name(name string) *Actions {\n \ta.context.name = name\n \treturn a\n@@ -72,4 +96,7 @@ func (a *Actions) Then() *Consequences {\n func (a *Actions) runCli(args ...string) {\n \ta.context.t.Helper()\n \ta.lastOutput, a.lastError = fixture.RunCli(args...)\n+\tif !a.ignoreErrors {\n+\t\trequire.Empty(a.context.t, a.lastError)\n+\t}\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 8,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "544aea18c32b34eac523791e7e2ef186abbd6daf",
            "date": "2025-01-24T21:58:00Z",
            "author_login": "rpelczar"
          },
          {
            "sha": "75def4f2df3e27892292b8020bfb9100a2784105",
            "date": "2025-01-24T13:28:45Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "c7e02eefdd6ea3e9ab84f4014724175dca0edac5",
            "date": "2025-01-24T13:16:35Z",
            "author_login": "reggie-k"
          },
          {
            "sha": "bd9923fd75439821639abe2697e3d99ed723c29b",
            "date": "2025-01-24T13:15:02Z",
            "author_login": "crenshaw-dev"
          },
          {
            "sha": "bcf2143dfee5c979d6ee97bbefcd8b82ff2c18dc",
            "date": "2025-01-23T11:12:44Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-200",
    "description": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. All unpatched versions of Argo CD starting with 1.0.0 are vulnerable to an improper access control bug, allowing a malicious user to potentially escalate their privileges to admin-level. Versions starting with 0.8.0 and 0.5.0 contain limited versions of this issue. To perform exploits, an authorized Argo CD user must have push access to an Application's source git or Helm repository or `sync` and `override` access to an Application. Once a user has that access, different exploitation levels are possible depending on their other RBAC privileges. A patch for this vulnerability has been released in Argo CD versions 2.3.2, 2.2.8, and 2.1.14. Some mitigation measures are available but do not serve as a substitute for upgrading. To avoid privilege escalation, limit who has push access to Application source repositories or `sync` + `override` access to Applications; and limit which repositories are available in projects where users have `update` access to Applications. To avoid unauthorized resource inspection/tampering, limit who has `delete`, `get`, or `action` access to Applications.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-03-23T22:15:13.143",
    "last_modified": "2024-11-21T06:51:03.453",
    "fix_date": "2022-03-22T17:57:30Z"
  },
  "references": [
    {
      "url": "https://github.com/argoproj/argo-cd/commit/af03b291d4b7e9d3ce9a6580ae9c8141af0e05cf",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/releases/tag/v2.1.14",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/releases/tag/v2.2.8",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/releases/tag/v2.3.2",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/security/advisories/GHSA-2f5v-8r3f-8pww",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/af03b291d4b7e9d3ce9a6580ae9c8141af0e05cf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/releases/tag/v2.1.14",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/releases/tag/v2.2.8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/releases/tag/v2.3.2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/security/advisories/GHSA-2f5v-8r3f-8pww",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:02.056812",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "argo-cd",
    "owner": "argoproj",
    "created_at": "2018-02-09T11:12:01Z",
    "updated_at": "2025-01-26T07:30:32Z",
    "pushed_at": "2025-01-26T00:30:55Z",
    "size": 126760,
    "stars": 18517,
    "forks": 5658,
    "open_issues": 3618,
    "watchers": 18517,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Go": 6748861,
      "TypeScript": 1301647,
      "Lua": 203056,
      "SCSS": 92996,
      "Shell": 58415,
      "Makefile": 24896,
      "Dockerfile": 15239,
      "Procfile": 10040,
      "JavaScript": 5975,
      "CSS": 2209,
      "Mustache": 1066,
      "HTML": 895
    },
    "commit_activity": {
      "total_commits_last_year": 1669,
      "avg_commits_per_week": 32.09615384615385,
      "days_active_last_year": 305
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:38:30.002178"
  }
}