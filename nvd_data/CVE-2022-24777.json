{
  "cve_id": "CVE-2022-24777",
  "github_data": {
    "repository": "grpc/grpc-swift",
    "fix_commit": "858f977f2a51fca2292f384cf7a108dc2e73a3bd",
    "related_commits": [
      "858f977f2a51fca2292f384cf7a108dc2e73a3bd",
      "858f977f2a51fca2292f384cf7a108dc2e73a3bd"
    ],
    "patch_url": "https://github.com/grpc/grpc-swift/commit/858f977f2a51fca2292f384cf7a108dc2e73a3bd.patch",
    "fix_commit_details": {
      "sha": "858f977f2a51fca2292f384cf7a108dc2e73a3bd",
      "commit_date": "2022-03-23T11:22:01Z",
      "author": {
        "login": "glbrntt",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-r6ww-5963-7r95",
        "length": 80,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 156,
        "additions": 139,
        "deletions": 17
      },
      "files": [
        {
          "filename": "FuzzTesting/FailCases/clusterfuzz-testcase-minimized-ServerFuzzer-release-4739158818553856",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "Sources/GRPC/GRPCIdleHandler.swift",
          "status": "modified",
          "additions": 16,
          "deletions": 1,
          "patch": "@@ -153,7 +153,19 @@ internal final class GRPCIdleHandler: ChannelInboundHandler {\n         streamID: .rootStream,\n         payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)\n       )\n-      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)\n+\n+      self.context?.write(self.wrapOutboundOut(goAwayFrame), promise: nil)\n+\n+      // We emit a ping after some GOAWAY frames.\n+      if operations.shouldPingAfterGoAway {\n+        let pingFrame = HTTP2Frame(\n+          streamID: .rootStream,\n+          payload: .ping(self.pingHandler.pingDataGoAway, ack: false)\n+        )\n+        self.context?.write(self.wrapOutboundOut(pingFrame), promise: nil)\n+      }\n+\n+      self.context?.flush()\n     }\n \n     // Close the channel, if necessary.\n@@ -181,6 +193,9 @@ internal final class GRPCIdleHandler: ChannelInboundHandler {\n     case let .reply(framePayload):\n       let frame = HTTP2Frame(streamID: .rootStream, payload: framePayload)\n       self.context?.writeAndFlush(self.wrapOutboundOut(frame), promise: nil)\n+\n+    case .ratchetDownLastSeenStreamID:\n+      self.perform(operations: self.stateMachine.ratchetDownGoAwayStreamID())\n     }\n   }\n "
        },
        {
          "filename": "Sources/GRPC/GRPCIdleHandlerStateMachine.swift",
          "status": "modified",
          "additions": 39,
          "deletions": 7,
          "patch": "@@ -189,10 +189,17 @@ struct GRPCIdleHandlerStateMachine {\n     /// Whether the channel should be closed.\n     private(set) var shouldCloseChannel: Bool\n \n+    /// Whether a ping should be sent after a GOAWAY frame.\n+    private(set) var shouldPingAfterGoAway: Bool\n+\n     fileprivate static let none = Operations()\n \n-    fileprivate mutating func sendGoAwayFrame(lastPeerInitiatedStreamID streamID: HTTP2StreamID) {\n+    fileprivate mutating func sendGoAwayFrame(\n+      lastPeerInitiatedStreamID streamID: HTTP2StreamID,\n+      followWithPing: Bool = false\n+    ) {\n       self.sendGoAwayWithLastPeerInitiatedStreamID = streamID\n+      self.shouldPingAfterGoAway = followWithPing\n     }\n \n     fileprivate mutating func cancelIdleTask(_ task: Scheduled<Void>) {\n@@ -220,6 +227,7 @@ struct GRPCIdleHandlerStateMachine {\n       self.idleTask = nil\n       self.sendGoAwayWithLastPeerInitiatedStreamID = nil\n       self.shouldCloseChannel = false\n+      self.shouldPingAfterGoAway = false\n     }\n   }\n \n@@ -267,12 +275,7 @@ struct GRPCIdleHandlerStateMachine {\n       operations.cancelIdleTask(state.idleTask)\n \n     case var .quiescing(state):\n-      precondition(state.initiatedByUs)\n-      precondition(state.role == .client)\n-      // If we're a client and we initiated shutdown then it's possible for streams to be created in\n-      // the quiescing state as there's a delay between stream channels (i.e. `HTTP2StreamChannel`)\n-      // being created and us being notified about their creation (via a user event fired by\n-      // the `HTTP2Handler`).\n+      state.lastPeerInitiatedStreamID = streamID\n       state.openStreams += 1\n       self.state = .quiescing(state)\n \n@@ -466,6 +469,18 @@ struct GRPCIdleHandlerStateMachine {\n \n       if state.hasOpenStreams {\n         operations.notifyConnectionManager(about: .quiescing)\n+        switch state.role {\n+        case .client:\n+          // The server sent us a GOAWAY we'll just stop opening new streams and will send a GOAWAY\n+          // frame before we close later.\n+          ()\n+        case .server:\n+          // Client sent us a GOAWAY frame; we'll let the streams drain and then close. We'll tell\n+          // the client that we're going away and send them a ping. When we receive the pong we will\n+          // send another GOAWAY frame with a lower stream ID. In this case, the pong acts as an ack\n+          // for the GOAWAY.\n+          operations.sendGoAwayFrame(lastPeerInitiatedStreamID: .maxID, followWithPing: true)\n+        }\n         self.state = .quiescing(.init(fromOperating: state, initiatedByUs: false))\n       } else {\n         // No open streams, we can close as well.\n@@ -494,6 +509,23 @@ struct GRPCIdleHandlerStateMachine {\n     return operations\n   }\n \n+  mutating func ratchetDownGoAwayStreamID() -> Operations {\n+    var operations: Operations = .none\n+\n+    switch self.state {\n+    case let .quiescing(state):\n+      let streamID = state.lastPeerInitiatedStreamID\n+      operations.sendGoAwayFrame(lastPeerInitiatedStreamID: streamID)\n+    case .operating, .waitingToIdle:\n+      // We can only ratchet down the stream ID if we're already quiescing.\n+      preconditionFailure()\n+    case .closing, .closed:\n+      ()\n+    }\n+\n+    return operations\n+  }\n+\n   mutating func receiveSettings(_ settings: HTTP2Settings) -> Operations {\n     // Log the change in settings.\n     self.logger.debug("
        },
        {
          "filename": "Sources/GRPC/GRPCKeepaliveHandlers.swift",
          "status": "modified",
          "additions": 21,
          "deletions": 9,
          "patch": "@@ -17,8 +17,11 @@ import NIOCore\n import NIOHTTP2\n \n struct PingHandler {\n-  /// Code for ping\n-  private let pingCode: UInt64\n+  /// Opaque ping data used for keep-alive pings.\n+  private let pingData: HTTP2PingData\n+\n+  /// Opaque ping data used for a ping sent after a GOAWAY frame.\n+  internal let pingDataGoAway: HTTP2PingData\n \n   /// The amount of time to wait before sending a keepalive ping.\n   private let interval: TimeAmount\n@@ -90,6 +93,7 @@ struct PingHandler {\n     case schedulePing(delay: TimeAmount, timeout: TimeAmount)\n     case cancelScheduledTimeout\n     case reply(HTTP2Frame.FramePayload)\n+    case ratchetDownLastSeenStreamID\n   }\n \n   init(\n@@ -102,7 +106,8 @@ struct PingHandler {\n     minimumReceivedPingIntervalWithoutData: TimeAmount? = nil,\n     maximumPingStrikes: UInt? = nil\n   ) {\n-    self.pingCode = pingCode\n+    self.pingData = HTTP2PingData(withInteger: pingCode)\n+    self.pingDataGoAway = HTTP2PingData(withInteger: ~pingCode)\n     self.interval = interval\n     self.timeout = timeout\n     self.permitWithoutCalls = permitWithoutCalls\n@@ -137,8 +142,12 @@ struct PingHandler {\n   }\n \n   private func handlePong(_ pingData: HTTP2PingData) -> Action {\n-    if pingData.integer == self.pingCode {\n+    if pingData == self.pingData {\n       return .cancelScheduledTimeout\n+    } else if pingData == self.pingDataGoAway {\n+      // We received a pong for a ping we sent to trail a GOAWAY frame: this means we can now\n+      // send another GOAWAY frame with a (possibly) lower stream ID.\n+      return .ratchetDownLastSeenStreamID\n     } else {\n       return .none\n     }\n@@ -161,32 +170,35 @@ struct PingHandler {\n         // This is a valid ping, reset our strike count and reply with a pong.\n         self.pingStrikes = 0\n         self.lastReceivedPingDate = self.now()\n-        return .reply(self.generatePingFrame(code: pingData.integer, ack: true))\n+        return .reply(self.generatePingFrame(data: pingData, ack: true))\n       }\n     } else {\n       // We don't support ping strikes. We'll just reply with a pong.\n       //\n       // Note: we don't need to update `pingStrikes` or `lastReceivedPingDate` as we don't\n       // support ping strikes.\n-      return .reply(self.generatePingFrame(code: pingData.integer, ack: true))\n+      return .reply(self.generatePingFrame(data: pingData, ack: true))\n     }\n   }\n \n   mutating func pingFired() -> Action {\n     if self.shouldBlockPing {\n       return .none\n     } else {\n-      return .reply(self.generatePingFrame(code: self.pingCode, ack: false))\n+      return .reply(self.generatePingFrame(data: self.pingData, ack: false))\n     }\n   }\n \n-  private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {\n+  private mutating func generatePingFrame(\n+    data: HTTP2PingData,\n+    ack: Bool\n+  ) -> HTTP2Frame.FramePayload {\n     if self.activeStreams == 0 {\n       self.sentPingsWithoutData += 1\n     }\n \n     self.lastSentPingDate = self.now()\n-    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)\n+    return HTTP2Frame.FramePayload.ping(data, ack: ack)\n   }\n \n   /// Returns true if, on receipt of a ping, the ping should be regarded as a ping strike."
        },
        {
          "filename": "Tests/GRPCTests/GRPCIdleHandlerStateMachineTests.swift",
          "status": "modified",
          "additions": 50,
          "deletions": 0,
          "patch": "@@ -24,6 +24,10 @@ class GRPCIdleHandlerStateMachineTests: GRPCTestCase {\n     return GRPCIdleHandlerStateMachine(role: .client, logger: self.clientLogger)\n   }\n \n+  private func makeServerStateMachine() -> GRPCIdleHandlerStateMachine {\n+    return GRPCIdleHandlerStateMachine(role: .server, logger: self.serverLogger)\n+  }\n+\n   private func makeNoOpScheduled() -> Scheduled<Void> {\n     let loop = EmbeddedEventLoop()\n     return loop.scheduleTask(deadline: .distantFuture) { return () }\n@@ -469,6 +473,43 @@ class GRPCIdleHandlerStateMachineTests: GRPCTestCase {\n     // The peer initiated shutdown by sending GOAWAY, we'll idle.\n     op6.assertConnectionManager(.idle)\n   }\n+\n+  func testClientSendsGoAwayAndOpensStream() {\n+    var stateMachine = self.makeServerStateMachine()\n+\n+    let op1 = stateMachine.receiveSettings([])\n+    op1.assertConnectionManager(.ready)\n+    op1.assertScheduleIdleTimeout()\n+\n+    // Schedule the idle timeout.\n+    let op2 = stateMachine.scheduledIdleTimeoutTask(self.makeNoOpScheduled())\n+    op2.assertDoNothing()\n+\n+    // Create a stream to cancel the task.\n+    let op3 = stateMachine.streamCreated(withID: 1)\n+    op3.assertCancelIdleTimeout()\n+\n+    // Receive a GOAWAY frame from the client.\n+    let op4 = stateMachine.receiveGoAway()\n+    op4.assertGoAway(streamID: .maxID)\n+    op4.assertShouldPingAfterGoAway()\n+\n+    // Create another stream. This is fine, the client hasn't ack'd the ping yet.\n+    let op5 = stateMachine.streamCreated(withID: 7)\n+    op5.assertDoNothing()\n+\n+    // Receiving the ping is handled by a different state machine which will tell us to ratchet\n+    // down the go away stream ID.\n+    let op6 = stateMachine.ratchetDownGoAwayStreamID()\n+    op6.assertGoAway(streamID: 7)\n+    op6.assertShouldNotPingAfterGoAway()\n+\n+    let op7 = stateMachine.streamClosed(withID: 7)\n+    op7.assertDoNothing()\n+\n+    let op8 = stateMachine.streamClosed(withID: 1)\n+    op8.assertShouldClose()\n+  }\n }\n \n extension GRPCIdleHandlerStateMachine.Operations {\n@@ -477,6 +518,7 @@ extension GRPCIdleHandlerStateMachine.Operations {\n     XCTAssertNil(self.idleTask)\n     XCTAssertNil(self.sendGoAwayWithLastPeerInitiatedStreamID)\n     XCTAssertFalse(self.shouldCloseChannel)\n+    XCTAssertFalse(self.shouldPingAfterGoAway)\n   }\n \n   func assertGoAway(streamID: HTTP2StreamID) {\n@@ -524,4 +566,12 @@ extension GRPCIdleHandlerStateMachine.Operations {\n   func assertShouldNotClose() {\n     XCTAssertFalse(self.shouldCloseChannel)\n   }\n+\n+  func assertShouldPingAfterGoAway() {\n+    XCTAssert(self.shouldPingAfterGoAway)\n+  }\n+\n+  func assertShouldNotPingAfterGoAway() {\n+    XCTAssertFalse(self.shouldPingAfterGoAway)\n+  }\n }"
        },
        {
          "filename": "Tests/GRPCTests/GRPCPingHandlerTests.swift",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -347,6 +347,12 @@ class GRPCPingHandlerTests: GRPCTestCase {\n     )\n   }\n \n+  func testPongWithGoAwayPingData() {\n+    self.setupPingHandler()\n+    let response = self.pingHandler.read(pingData: self.pingHandler.pingDataGoAway, ack: true)\n+    XCTAssertEqual(response, .ratchetDownLastSeenStreamID)\n+  }\n+\n   private func setupPingHandler(\n     pingCode: UInt64 = 1,\n     interval: TimeAmount = .seconds(15),\n@@ -379,6 +385,8 @@ extension PingHandler.Action: Equatable {\n       return lhsDelay == rhsDelay && lhsTimeout == rhsTimeout\n     case (.cancelScheduledTimeout, .cancelScheduledTimeout):\n       return true\n+    case (.ratchetDownLastSeenStreamID, .ratchetDownLastSeenStreamID):\n+      return true\n     case let (.reply(lhsPayload), .reply(rhsPayload)):\n       switch (lhsPayload, rhsPayload) {\n       case (let .ping(lhsData, ack: lhsAck), let .ping(rhsData, ack: rhsAck)):"
        },
        {
          "filename": "Tests/GRPCTests/ServerFuzzingRegressionTests.swift",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -83,4 +83,9 @@ final class ServerFuzzingRegressionTests: GRPCTestCase {\n     let name = \"clusterfuzz-testcase-minimized-ServerFuzzer-release-5285159577452544\"\n     XCTAssertNoThrow(try self.runTest(withInputNamed: name))\n   }\n+\n+  func testFuzzCase_release_4739158818553856() {\n+    let name = \"clusterfuzz-testcase-minimized-ServerFuzzer-release-4739158818553856\"\n+    XCTAssertNoThrow(try self.runTest(withInputNamed: name))\n+  }\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "76073a2c1a2dcae35df4f0ab83ffd07b23e4cec9",
            "date": "2025-01-13T14:02:47Z",
            "author_login": "glbrntt"
          },
          {
            "sha": "560c6c7bf5bb2217db4c2d39b888661dc242252c",
            "date": "2025-01-07T13:03:45Z",
            "author_login": "rnro"
          },
          {
            "sha": "5e92f645c59923f535e9660fb917822dc8d9f48f",
            "date": "2025-01-06T16:06:40Z",
            "author_login": "rnro"
          },
          {
            "sha": "0696e0adf7e081ba7a757a4c87242a1aab524078",
            "date": "2024-12-20T15:23:23Z",
            "author_login": "glbrntt"
          },
          {
            "sha": "5be11cd9386bfd9b29ed72549fe7530157a37bf2",
            "date": "2024-12-20T15:16:18Z",
            "author_login": "glbrntt"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-617",
    "description": "grpc-swift is the Swift language implementation of gRPC, a remote procedure call (RPC) framework. Prior to version 1.7.2, a grpc-swift server is vulnerable to a denial of service attack via a reachable assertion. This is due to incorrect logic when handling GOAWAY frames. The attack is low-effort: it takes very little resources to construct and send the required sequence of frames. The impact on availability is high as the server will crash, dropping all in flight connections and requests. This issue is fixed in version 1.7.2. There are currently no known workarounds.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-03-25T17:15:08.653",
    "last_modified": "2024-11-21T06:51:04.610",
    "fix_date": "2022-03-23T11:22:01Z"
  },
  "references": [
    {
      "url": "https://github.com/grpc/grpc-swift/commit/858f977f2a51fca2292f384cf7a108dc2e73a3bd",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/grpc/grpc-swift/security/advisories/GHSA-r6ww-5963-7r95",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/grpc/grpc-swift/commit/858f977f2a51fca2292f384cf7a108dc2e73a3bd",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/grpc/grpc-swift/security/advisories/GHSA-r6ww-5963-7r95",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:02.063975",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "grpc-swift",
    "owner": "grpc",
    "created_at": "2016-09-21T17:35:31Z",
    "updated_at": "2025-01-13T14:02:52Z",
    "pushed_at": "2025-01-13T14:02:47Z",
    "size": 18431,
    "stars": 2073,
    "forks": 419,
    "open_issues": 103,
    "watchers": 2073,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "cgrpc",
      "main",
      "release/1.x"
    ],
    "languages": {
      "Swift": 1340902,
      "Shell": 16441
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:06:04.208414"
  }
}