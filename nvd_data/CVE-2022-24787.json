{
  "cve_id": "CVE-2022-24787",
  "github_data": {
    "repository": "vyperlang/vyper",
    "fix_commit": "2c73f8352635c0a433423a5b94740de1a118e508",
    "related_commits": [
      "2c73f8352635c0a433423a5b94740de1a118e508",
      "2c73f8352635c0a433423a5b94740de1a118e508"
    ],
    "patch_url": "https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508.patch",
    "fix_commit_details": {
      "sha": "2c73f8352635c0a433423a5b94740de1a118e508",
      "commit_date": "2022-04-02T15:30:04Z",
      "author": {
        "login": "charles-cooper",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-7vrm-3jc8-5wwm",
        "length": 278,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 263,
        "additions": 159,
        "deletions": 104
      },
      "files": [
        {
          "filename": "tests/parser/functions/test_slice.py",
          "status": "modified",
          "additions": 30,
          "deletions": 0,
          "patch": "@@ -210,6 +210,36 @@ def ret10_slice() -> Bytes[10]:\n     assert c.ret10_slice() == b\"A\"\n \n \n+def test_slice_equality(get_contract):\n+    # test for equality with dirty bytes\n+    code = \"\"\"\n+@external\n+def assert_eq() -> bool:\n+    dirty_bytes: String[4] = \"abcd\"\n+    dirty_bytes = slice(dirty_bytes, 0, 3)\n+    clean_bytes: String[4] = \"abc\"\n+    return dirty_bytes == clean_bytes\n+    \"\"\"\n+\n+    c = get_contract(code)\n+    assert c.assert_eq()\n+\n+\n+def test_slice_inequality(get_contract):\n+    # test for equality with dirty bytes\n+    code = \"\"\"\n+@external\n+def assert_ne() -> bool:\n+    dirty_bytes: String[4] = \"abcd\"\n+    dirty_bytes = slice(dirty_bytes, 0, 3)\n+    clean_bytes: String[4] = \"abcd\"\n+    return dirty_bytes != clean_bytes\n+    \"\"\"\n+\n+    c = get_contract(code)\n+    assert c.assert_ne()\n+\n+\n def test_slice_convert(get_contract):\n     # test slice of converting between bytes32 and Bytes\n     code = \"\"\""
        },
        {
          "filename": "tests/parser/types/test_string.py",
          "status": "modified",
          "additions": 101,
          "deletions": 58,
          "patch": "@@ -168,120 +168,165 @@ def test(a: uint256, b: String[50] = \"foo\") -> Bytes[100]:\n     assert c.test(12345, \"bar\")[-3:] == b\"bar\"\n \n \n-def test_string_equality(get_contract_with_gas_estimation):\n-    code = \"\"\"\n-_compA: String[100]\n-_compB: String[100]\n+string_equality_tests = [\n+    (\n+        100,\n+        \"The quick brown fox jumps over the lazy dog\",\n+        \"The quick brown fox jumps over the lazy hog\",\n+    ),\n+    # check <= 32 codepath\n+    (32, \"abc\", \"abc\\0\"),\n+    (32, \"abc\", \"abc\\1\"),  # use a_init dirty bytes\n+    (32, \"abc\\2\", \"abc\"),  # use b_init dirty bytes\n+    (32, \"\", \"\\0\"),\n+    (32, \"\", \"\\1\"),\n+    (33, \"\", \"\\1\"),\n+    (33, \"\", \"\\0\"),\n+]\n+\n+\n+@pytest.mark.parametrize(\"len_,a,b\", string_equality_tests)\n+def test_string_equality(get_contract_with_gas_estimation, len_, a, b):\n+    # fixtures to initialize strings with dirty bytes\n+    a_init = \"\\\\1\" * len_\n+    b_init = \"\\\\2\" * len_\n+    string1 = a.encode(\"unicode_escape\").decode(\"utf-8\")\n+    string2 = b.encode(\"unicode_escape\").decode(\"utf-8\")\n+    code = f\"\"\"\n+a: String[{len_}]\n+b: String[{len_}]\n \n @external\n def equal_true() -> bool:\n-    compA: String[100] = \"The quick brown fox jumps over the lazy dog\"\n-    compB: String[100] = \"The quick brown fox jumps over the lazy dog\"\n-    return compA == compB\n+    a: String[{len_}] = \"{a_init}\"\n+    b: String[{len_}] = \"{b_init}\"\n+    a = \"{string1}\"\n+    b = \"{string1}\"\n+    return a == b\n \n @external\n def equal_false() -> bool:\n-    compA: String[100] = \"The quick brown fox jumps over the lazy dog\"\n-    compB: String[100] = \"The quick brown fox jumps over the lazy hog\"\n-    return compA == compB\n+    a: String[{len_}] = \"{a_init}\"\n+    b: String[{len_}] = \"{b_init}\"\n+    a = \"{string1}\"\n+    b = \"{string2}\"\n+    return a == b\n \n @external\n def not_equal_true() -> bool:\n-    compA: String[100] = \"The quick brown fox jumps over the lazy dog\"\n-    compB: String[100] = \"The quick brown fox jumps over the lazy hog\"\n-    return compA != compB\n+    a: String[{len_}] = \"{a_init}\"\n+    b: String[{len_}] = \"{b_init}\"\n+    a = \"{string1}\"\n+    b = \"{string2}\"\n+    return a != b\n \n @external\n def not_equal_false() -> bool:\n-    compA: String[100] = \"The quick brown fox jumps over the lazy dog\"\n-    compB: String[100] = \"The quick brown fox jumps over the lazy dog\"\n-    return compA != compB\n+    a: String[{len_}] = \"{a_init}\"\n+    b: String[{len_}] = \"{b_init}\"\n+    a = \"{string1}\"\n+    b = \"{string1}\"\n+    return a != b\n \n @external\n def literal_equal_true() -> bool:\n-    return \"The quick brown fox jumps over the lazy dog\" == \\\n-    \"The quick brown fox jumps over the lazy dog\"\n+    return \"{string1}\" == \"{string1}\"\n \n @external\n def literal_equal_false() -> bool:\n-    return \"The quick brown fox jumps over the lazy dog\" == \\\n-    \"The quick brown fox jumps over the lazy hog\"\n+    return \"{string1}\" == \"{string2}\"\n \n @external\n def literal_not_equal_true() -> bool:\n-    return \"The quick brown fox jumps over the lazy dog\" != \\\n-    \"The quick brown fox jumps over the lazy hog\"\n+    return \"{string1}\" != \"{string2}\"\n \n @external\n def literal_not_equal_false() -> bool:\n-    return \"The quick brown fox jumps over the lazy dog\" != \\\n-    \"The quick brown fox jumps over the lazy dog\"\n+    return \"{string1}\" != \"{string1}\"\n \n @external\n def storage_equal_true() -> bool:\n-    self._compA = \"The quick brown fox jumps over the lazy dog\"\n-    self._compB = \"The quick brown fox jumps over the lazy dog\"\n-    return self._compA == self._compB\n+    self.a = \"{a_init}\"\n+    self.b = \"{b_init}\"\n+    self.a = \"{string1}\"\n+    self.b = \"{string1}\"\n+    return self.a == self.b\n \n @external\n def storage_equal_false() -> bool:\n-    self._compA = \"The quick brown fox jumps over the lazy dog\"\n-    self._compB = \"The quick brown fox jumps over the lazy hog\"\n-    return self._compA == self._compB\n+    self.a = \"{a_init}\"\n+    self.b = \"{b_init}\"\n+    self.a = \"{string1}\"\n+    self.b = \"{string2}\"\n+    return self.a == self.b\n \n @external\n def storage_not_equal_true() -> bool:\n-    self._compA = \"The quick brown fox jumps over the lazy dog\"\n-    self._compB = \"The quick brown fox jumps over the lazy hog\"\n-    return self._compA != self._compB\n+    self.a = \"{a_init}\"\n+    self.b = \"{b_init}\"\n+    self.a = \"{string1}\"\n+    self.b = \"{string2}\"\n+    return self.a != self.b\n \n @external\n def storage_not_equal_false() -> bool:\n-    self._compA = \"The quick brown fox jumps over the lazy dog\"\n-    self._compB = \"The quick brown fox jumps over the lazy dog\"\n-    return self._compA != self._compB\n+    self.a = \"{a_init}\"\n+    self.b = \"{b_init}\"\n+    self.a = \"{string1}\"\n+    self.b = \"{string1}\"\n+    return self.a != self.b\n \n @external\n-def string_compare_equal(str1: String[100], str2: String[100]) -> bool:\n+def string_compare_equal(str1: String[{len_}], str2: String[{len_}]) -> bool:\n     return str1 == str2\n \n @external\n-def string_compare_not_equal(str1: String[100], str2: String[100]) -> bool:\n+def string_compare_not_equal(str1: String[{len_}], str2: String[{len_}]) -> bool:\n     return str1 != str2\n \n @external\n-def compare_passed_storage_equal(str: String[100]) -> bool:\n-    self._compA = \"The quick brown fox jumps over the lazy dog\"\n-    return self._compA == str\n+def compare_passed_storage_equal(str_: String[{len_}]) -> bool:\n+    self.a = \"{a_init}\"\n+    self.a = \"{string1}\"\n+    return self.a == str_\n \n @external\n-def compare_passed_storage_not_equal(str: String[100]) -> bool:\n-    self._compA = \"The quick brown fox jumps over the lazy dog\"\n-    return self._compA != str\n+def compare_passed_storage_not_equal(str_: String[{len_}]) -> bool:\n+    self.a = \"{a_init}\"\n+    self.a = \"{string1}\"\n+    return self.a != str_\n \n @external\n def compare_var_storage_equal_true() -> bool:\n-    self._compA = \"The quick brown fox jumps over the lazy dog\"\n-    compB: String[100] = \"The quick brown fox jumps over the lazy dog\"\n-    return self._compA == compB\n+    self.a = \"{a_init}\"\n+    b: String[{len_}] = \"{b_init}\"\n+    self.a = \"{string1}\"\n+    b = \"{string1}\"\n+    return self.a == b\n \n @external\n def compare_var_storage_equal_false() -> bool:\n-    self._compA = \"The quick brown fox jumps over the lazy dog\"\n-    compB: String[100] = \"The quick brown fox jumps over the lazy hog\"\n-    return self._compA == compB\n+    self.a = \"{a_init}\"\n+    b: String[{len_}] = \"{b_init}\"\n+    self.a = \"{string1}\"\n+    b = \"{string2}\"\n+    return self.a == b\n \n @external\n def compare_var_storage_not_equal_true() -> bool:\n-    self._compA = \"The quick brown fox jumps over the lazy dog\"\n-    compB: String[100] = \"The quick brown fox jumps over the lazy hog\"\n-    return self._compA != compB\n+    self.a = \"{a_init}\"\n+    b: String[{len_}] = \"{b_init}\"\n+    self.a = \"{string1}\"\n+    b = \"{string2}\"\n+    return self.a != b\n \n @external\n def compare_var_storage_not_equal_false() -> bool:\n-    self._compA = \"The quick brown fox jumps over the lazy dog\"\n-    compB: String[100] = \"The quick brown fox jumps over the lazy dog\"\n-    return self._compA != compB\n+    self.a = \"{a_init}\"\n+    b: String[{len_}] = \"{b_init}\"\n+    self.a = \"{string1}\"\n+    b = \"{string1}\"\n+    return self.a != b\n     \"\"\"\n \n     c = get_contract_with_gas_estimation(code)\n@@ -298,8 +343,6 @@ def compare_var_storage_not_equal_false() -> bool:\n     assert c.storage_not_equal_true() is True\n     assert c.storage_not_equal_false() is False\n \n-    a = \"The quick brown fox jumps over the lazy dog\"\n-    b = \"The quick brown fox jumps over the lazy hog\"\n     assert c.string_compare_equal(a, a) is True\n     assert c.string_compare_equal(a, b) is False\n     assert c.string_compare_not_equal(b, a) is True"
        },
        {
          "filename": "vyper/codegen/core.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -186,7 +186,7 @@ def copy_bytes(dst, src, length, length_bound):\n \n     with src.cache_when_complex(\"src\") as (b1, src), length.cache_when_complex(\n         \"copy_bytes_count\"\n-    ) as (b2, length,), dst.cache_when_complex(\"dst\") as (b3, dst):\n+    ) as (b2, length), dst.cache_when_complex(\"dst\") as (b3, dst):\n \n         # fast code for common case where num bytes is small\n         # TODO expand this for more cases where num words is less than ~8"
        },
        {
          "filename": "vyper/codegen/expr.py",
          "status": "modified",
          "additions": 7,
          "deletions": 24,
          "patch": "@@ -5,8 +5,6 @@\n from vyper.address_space import DATA, IMMUTABLES, MEMORY, STORAGE\n from vyper.codegen import external_call, self_call\n from vyper.codegen.core import (\n-    LOAD,\n-    bytes_data_ptr,\n     clamp_basetype,\n     ensure_in_memory,\n     get_dyn_array_count,\n@@ -801,30 +799,15 @@ def parse_Compare(self):\n             left = Expr(self.expr.left, self.context).ir_node\n             right = Expr(self.expr.right, self.context).ir_node\n \n-            length_mismatch = left.typ.maxlen != right.typ.maxlen\n-            left_over_32 = left.typ.maxlen > 32\n-            right_over_32 = right.typ.maxlen > 32\n-\n-            if length_mismatch or left_over_32 or right_over_32:\n-                left_keccak = keccak256_helper(self.expr, left, self.context)\n-                right_keccak = keccak256_helper(self.expr, right, self.context)\n-\n-                if op == \"eq\" or op == \"ne\":\n-                    return IRnode.from_list([op, left_keccak, right_keccak], typ=\"bool\")\n-\n-                else:\n-                    return\n+            left_keccak = keccak256_helper(self.expr, left, self.context)\n+            right_keccak = keccak256_helper(self.expr, right, self.context)\n \n+            if op not in (\"eq\", \"ne\"):\n+                return  # raises\n             else:\n-\n-                def load_bytearray(side):\n-                    return LOAD(bytes_data_ptr(side))\n-\n-                return IRnode.from_list(\n-                    # CMC 2022-03-24 TODO investigate this.\n-                    [op, load_bytearray(left), load_bytearray(right)],\n-                    typ=\"bool\",\n-                )\n+                # use hash even for Bytes[N<=32], because there could be dirty\n+                # bytes past the bytes data.\n+                return IRnode.from_list([op, left_keccak, right_keccak], typ=\"bool\")\n \n         # Compare other types.\n         elif is_numeric_type(left.typ) and is_numeric_type(right.typ):"
        },
        {
          "filename": "vyper/codegen/keccak256_helper.py",
          "status": "modified",
          "additions": 20,
          "deletions": 21,
          "patch": "@@ -1,6 +1,6 @@\n from math import ceil\n \n-from vyper.codegen.core import ensure_in_memory\n+from vyper.codegen.core import bytes_data_ptr, ensure_in_memory, get_bytearray_length\n from vyper.codegen.ir_node import IRnode\n from vyper.codegen.types import BaseType, ByteArrayLike, is_base_type\n from vyper.exceptions import CompilerPanic\n@@ -21,37 +21,36 @@ def _gas_bound(num_words):\n     return SHA3_BASE + num_words * SHA3_PER_WORD\n \n \n-def keccak256_helper(expr, ir_arg, context):\n-    sub = ir_arg  # TODO get rid of useless variable\n-    _check_byteslike(sub.typ, expr)\n+def keccak256_helper(expr, to_hash, context):\n+    _check_byteslike(to_hash.typ, expr)\n \n     # Can hash literals\n     # TODO this is dead code.\n-    if isinstance(sub, bytes):\n-        return IRnode.from_list(bytes_to_int(keccak256(sub)), typ=BaseType(\"bytes32\"))\n+    if isinstance(to_hash, bytes):\n+        return IRnode.from_list(bytes_to_int(keccak256(to_hash)), typ=BaseType(\"bytes32\"))\n \n     # Can hash bytes32 objects\n-    if is_base_type(sub.typ, \"bytes32\"):\n+    if is_base_type(to_hash.typ, \"bytes32\"):\n         return IRnode.from_list(\n             [\n                 \"seq\",\n-                [\"mstore\", MemoryPositions.FREE_VAR_SPACE, sub],\n+                [\"mstore\", MemoryPositions.FREE_VAR_SPACE, to_hash],\n                 [\"sha3\", MemoryPositions.FREE_VAR_SPACE, 32],\n             ],\n             typ=BaseType(\"bytes32\"),\n             add_gas_estimate=_gas_bound(1),\n         )\n \n-    sub = ensure_in_memory(sub, context)\n-\n-    return IRnode.from_list(\n-        [\n-            \"with\",\n-            \"_buf\",\n-            sub,\n-            [\"sha3\", [\"add\", \"_buf\", 32], [\"mload\", \"_buf\"]],\n-        ],\n-        typ=BaseType(\"bytes32\"),\n-        annotation=\"keccak256\",\n-        add_gas_estimate=_gas_bound(ceil(sub.typ.maxlen / 32)),\n-    )\n+    to_hash = ensure_in_memory(to_hash, context)\n+\n+    with to_hash.cache_when_complex(\"buf\") as (b1, to_hash):\n+        data = bytes_data_ptr(to_hash)\n+        len_ = get_bytearray_length(to_hash)\n+        return b1.resolve(\n+            IRnode.from_list(\n+                [\"sha3\", data, len_],\n+                typ=\"bytes32\",\n+                annotation=\"keccak256\",\n+                add_gas_estimate=_gas_bound(ceil(to_hash.typ.maxlen / 32)),\n+            )\n+        )"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c208b954564e8fffdd4c86cc3c497e0c3df1aeec",
            "date": "2025-01-14T17:09:31Z",
            "author_login": "charles-cooper"
          },
          {
            "sha": "db8dcc713168b16977b5b07267653c9024f6acea",
            "date": "2025-01-12T17:01:49Z",
            "author_login": "charles-cooper"
          },
          {
            "sha": "10e91d5a2ba6eaab2f7194fd86cefb7a0ff19964",
            "date": "2025-01-12T16:34:14Z",
            "author_login": "tserg"
          },
          {
            "sha": "43259f8953672ef7a19167c6c048d020d82e05da",
            "date": "2025-01-12T16:32:46Z",
            "author_login": "charles-cooper"
          },
          {
            "sha": "9b5523e6131335c81714e7e8af63cc49404f5ce7",
            "date": "2025-01-12T16:19:30Z",
            "author_login": "charles-cooper"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-697",
    "description": "Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-04-04T18:15:07.877",
    "last_modified": "2024-11-21T06:51:05.760",
    "fix_date": "2022-04-02T15:30:04Z"
  },
  "references": [
    {
      "url": "https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vyperlang/vyper/security/advisories/GHSA-7vrm-3jc8-5wwm",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vyperlang/vyper/security/advisories/GHSA-7vrm-3jc8-5wwm",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:02.096933",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "vyper",
    "owner": "vyperlang",
    "created_at": "2016-11-11T08:56:41Z",
    "updated_at": "2025-01-13T17:32:27Z",
    "pushed_at": "2025-01-12T17:01:50Z",
    "size": 11939,
    "stars": 4948,
    "forks": 817,
    "open_issues": 489,
    "watchers": 4948,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Python": 2662211,
      "Makefile": 2222,
      "Batchfile": 1614,
      "Dockerfile": 1145,
      "Shell": 472
    },
    "commit_activity": {
      "total_commits_last_year": 317,
      "avg_commits_per_week": 6.096153846153846,
      "days_active_last_year": 154
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:48:09.728520"
  }
}