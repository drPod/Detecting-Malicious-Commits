{
  "cve_id": "CVE-2022-24788",
  "github_data": {
    "repository": "vyperlang/vyper",
    "fix_commit": "049dbdc647b2ce838fae7c188e6bb09cf16e470b",
    "related_commits": [
      "049dbdc647b2ce838fae7c188e6bb09cf16e470b",
      "049dbdc647b2ce838fae7c188e6bb09cf16e470b"
    ],
    "patch_url": "https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b.patch",
    "fix_commit_details": {
      "sha": "049dbdc647b2ce838fae7c188e6bb09cf16e470b",
      "commit_date": "2022-04-13T13:39:37Z",
      "author": {
        "login": "charles-cooper",
        "type": "User",
        "stats": {
          "total_commits": 1087,
          "average_weekly_commits": 2.539719626168224,
          "total_additions": 171904,
          "total_deletions": 132151,
          "weeks_active": 180
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-j2x6-9323-fp7h",
        "length": 2308,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 294,
        "additions": 214,
        "deletions": 80
      },
      "files": [
        {
          "filename": "tests/parser/functions/test_interfaces.py",
          "status": "modified",
          "additions": 165,
          "deletions": 1,
          "patch": "@@ -6,7 +6,7 @@\n from vyper.builtin_interfaces import ERC20, ERC721\n from vyper.cli.utils import extract_file_interface_imports\n from vyper.compiler import compile_code, compile_codes\n-from vyper.exceptions import InterfaceViolation, StructureException\n+from vyper.exceptions import ArgumentException, InterfaceViolation, StructureException\n \n \n def test_basic_extract_interface():\n@@ -308,6 +308,170 @@ def test():\n     assert erc20.balanceOf(sender) == 1000\n \n \n+# test data returned from external interface gets clamped\n+@pytest.mark.parametrize(\"typ\", (\"int128\", \"uint8\"))\n+def test_external_interface_int_clampers(get_contract, assert_tx_failed, typ):\n+    external_contract = f\"\"\"\n+@external\n+def ok() -> {typ}:\n+    return 1\n+\n+@external\n+def should_fail() -> int256:\n+    return -2**255 # OOB for all int/uint types with less than 256 bits\n+    \"\"\"\n+\n+    code = f\"\"\"\n+interface BadContract:\n+    def ok() -> {typ}: view\n+    def should_fail() -> {typ}: view\n+\n+foo: BadContract\n+\n+@external\n+def __init__(addr: BadContract):\n+    self.foo = addr\n+\n+\n+@external\n+def test_ok() -> {typ}:\n+    return self.foo.ok()\n+\n+@external\n+def test_fail() -> {typ}:\n+    return self.foo.should_fail()\n+\n+@external\n+def test_fail2() -> {typ}:\n+    x: {typ} = self.foo.should_fail()\n+    return x\n+\n+@external\n+def test_fail3() -> int256:\n+    return convert(self.foo.should_fail(), int256)\n+    \"\"\"\n+\n+    bad_c = get_contract(external_contract)\n+    c = get_contract(\n+        code,\n+        bad_c.address,\n+        interface_codes={\"BadCode\": {\"type\": \"vyper\", \"code\": external_contract}},\n+    )\n+    assert bad_c.ok() == 1\n+    assert bad_c.should_fail() == -(2 ** 255)\n+\n+    assert c.test_ok() == 1\n+    assert_tx_failed(lambda: c.test_fail())\n+    assert_tx_failed(lambda: c.test_fail2())\n+    assert_tx_failed(lambda: c.test_fail3())\n+\n+\n+# test data returned from external interface gets clamped\n+def test_external_interface_bytes_clampers(get_contract, assert_tx_failed):\n+    external_contract = \"\"\"\n+@external\n+def ok() -> Bytes[2]:\n+    return b\"12\"\n+\n+@external\n+def should_fail() -> Bytes[3]:\n+    return b\"123\"\n+    \"\"\"\n+\n+    code = \"\"\"\n+interface BadContract:\n+    def ok() -> Bytes[2]: view\n+    def should_fail() -> Bytes[2]: view\n+\n+foo: BadContract\n+\n+@external\n+def __init__(addr: BadContract):\n+    self.foo = addr\n+\n+\n+@external\n+def test_ok() -> Bytes[2]:\n+    return self.foo.ok()\n+\n+@external\n+def test_fail() -> Bytes[3]:\n+    return self.foo.should_fail()\n+    \"\"\"\n+\n+    bad_c = get_contract(external_contract)\n+    c = get_contract(code, bad_c.address)\n+    assert bad_c.ok() == b\"12\"\n+    assert bad_c.should_fail() == b\"123\"\n+\n+    assert c.test_ok() == b\"12\"\n+    assert_tx_failed(lambda: c.test_fail())\n+\n+\n+# test data returned from external interface gets clamped\n+def test_json_abi_bytes_clampers(get_contract, assert_tx_failed, assert_compile_failed):\n+    external_contract = \"\"\"\n+@external\n+def returns_Bytes3() -> Bytes[3]:\n+    return b\"123\"\n+    \"\"\"\n+\n+    should_not_compile = \"\"\"\n+import BadJSONInterface as BadJSONInterface\n+@external\n+def foo(x: BadJSONInterface) -> Bytes[2]:\n+    return slice(x.returns_Bytes3(), 0, 2)\n+    \"\"\"\n+\n+    code = \"\"\"\n+import BadJSONInterface as BadJSONInterface\n+\n+foo: BadJSONInterface\n+\n+@external\n+def __init__(addr: BadJSONInterface):\n+    self.foo = addr\n+\n+\n+@external\n+def test_fail1() -> Bytes[2]:\n+    # should compile, but raise runtime exception\n+    return self.foo.returns_Bytes3()\n+\n+@external\n+def test_fail2() -> Bytes[2]:\n+    # should compile, but raise runtime exception\n+    x: Bytes[2] = self.foo.returns_Bytes3()\n+    return x\n+\n+@external\n+def test_fail3() -> Bytes[3]:\n+    # should revert - returns_Bytes3 is inferred to have return type Bytes[2]\n+    # (because test_fail3 comes after test_fail1)\n+    return self.foo.returns_Bytes3()\n+\n+    \"\"\"\n+\n+    bad_c = get_contract(external_contract)\n+    bad_c_interface = {\n+        \"BadJSONInterface\": {\n+            \"type\": \"json\",\n+            \"code\": compile_code(external_contract, [\"abi\"])[\"abi\"],\n+        }\n+    }\n+\n+    assert_compile_failed(\n+        lambda: get_contract(should_not_compile, interface_codes=bad_c_interface), ArgumentException\n+    )\n+\n+    c = get_contract(code, bad_c.address, interface_codes=bad_c_interface)\n+    assert bad_c.returns_Bytes3() == b\"123\"\n+\n+    assert_tx_failed(lambda: c.test_fail1())\n+    assert_tx_failed(lambda: c.test_fail2())\n+    assert_tx_failed(lambda: c.test_fail3())\n+\n+\n def test_units_interface(w3, get_contract):\n     code = \"\"\"\n import balanceof as BalanceOf"
        },
        {
          "filename": "vyper/codegen/core.py",
          "status": "modified",
          "additions": 10,
          "deletions": 13,
          "patch": "@@ -123,10 +123,7 @@ def _dynarray_make_setter(dst, src):\n \n         # for ABI-encoded dynamic data, we must loop to unpack, since\n         # the layout does not match our memory layout\n-        should_loop = (\n-            src.encoding in (Encoding.ABI, Encoding.JSON_ABI)\n-            and src.typ.subtype.abi_type.is_dynamic()\n-        )\n+        should_loop = src.encoding == Encoding.ABI and src.typ.subtype.abi_type.is_dynamic()\n \n         # if the subtype is dynamic, there might be a lot of\n         # unused space inside of each element. for instance\n@@ -379,7 +376,7 @@ def _get_element_ptr_tuplelike(parent, key):\n \n     ofst = 0  # offset from parent start\n \n-    if parent.encoding in (Encoding.ABI, Encoding.JSON_ABI):\n+    if parent.encoding == Encoding.ABI:\n         if parent.location == STORAGE:\n             raise CompilerPanic(\"storage variables should not be abi encoded\")  # pragma: notest\n \n@@ -449,7 +446,7 @@ def _get_element_ptr_array(parent, key, array_bounds_check):\n         # NOTE: there are optimization rules for this when ix or bound is literal\n         ix = IRnode.from_list([clamp_op, ix, bound], typ=ix.typ)\n \n-    if parent.encoding in (Encoding.ABI, Encoding.JSON_ABI):\n+    if parent.encoding == Encoding.ABI:\n         if parent.location == STORAGE:\n             raise CompilerPanic(\"storage variables should not be abi encoded\")  # pragma: notest\n \n@@ -703,20 +700,20 @@ def _freshname(name):\n # returns True if t is ABI encoded and is a type that needs any kind of\n # validation\n def needs_clamp(t, encoding):\n-    if encoding not in (Encoding.ABI, Encoding.JSON_ABI):\n+    if encoding == Encoding.VYPER:\n         return False\n+    if encoding != Encoding.ABI:\n+        raise CompilerPanic(\"unreachable\")  # pragma: notest\n     if isinstance(t, (ByteArrayLike, DArrayType)):\n-        if encoding == Encoding.JSON_ABI:\n-            # don't have bytestring size bound from json, don't clamp\n-            return False\n-        return True\n-    if isinstance(t, BaseType) and t.typ not in (\"int256\", \"uint256\", \"bytes32\"):\n         return True\n+    if isinstance(t, BaseType):\n+        return t.typ not in (\"int256\", \"uint256\", \"bytes32\")\n     if isinstance(t, SArrayType):\n         return needs_clamp(t.subtype, encoding)\n     if isinstance(t, TupleLike):\n         return any(needs_clamp(m, encoding) for m in t.tuple_members())\n-    return False\n+\n+    raise CompilerPanic(\"unreachable\")  # pragma: notest\n \n \n # Create an x=y statement, where the types may be compound"
        },
        {
          "filename": "vyper/codegen/external_call.py",
          "status": "modified",
          "additions": 33,
          "deletions": 37,
          "patch": "@@ -6,10 +6,12 @@\n     check_assign,\n     check_external_call,\n     dummy_node_for_type,\n-    get_element_ptr,\n+    make_setter,\n+    needs_clamp,\n )\n from vyper.codegen.ir_node import Encoding, IRnode\n from vyper.codegen.types import InterfaceType, TupleType, get_type_for_exact_size\n+from vyper.codegen.types.convert import new_type_to_old_type\n from vyper.exceptions import StateAccessViolation, TypeCheckFailure\n \n \n@@ -59,22 +61,19 @@ def _pack_arguments(contract_sig, args, context):\n     return buf, mstore_method_id + [encode_args], args_ofst, args_len\n \n \n-def _returndata_encoding(contract_sig):\n-    if contract_sig.is_from_json:\n-        return Encoding.JSON_ABI\n-    return Encoding.ABI\n+def _unpack_returndata(buf, contract_sig, skip_contract_check, context, expr):\n+    # expr.func._metadata[\"type\"].return_type is more accurate\n+    # than contract_sig.return_type in the case of JSON interfaces.\n+    ast_return_t = expr.func._metadata[\"type\"].return_type\n \n-\n-def _unpack_returndata(buf, contract_sig, skip_contract_check, context):\n-    return_t = contract_sig.return_type\n-    if return_t is None:\n+    if ast_return_t is None:\n         return [\"pass\"], 0, 0\n \n+    # sanity check\n+    return_t = new_type_to_old_type(ast_return_t)\n+    check_assign(dummy_node_for_type(return_t), dummy_node_for_type(contract_sig.return_type))\n+\n     return_t = calculate_type_for_external_return(return_t)\n-    # if the abi signature has a different type than\n-    # the vyper type, we need to wrap and unwrap the type\n-    # so that the ABI decoding works correctly\n-    should_unwrap_abi_tuple = return_t != contract_sig.return_type\n \n     abi_return_t = return_t.abi_type\n \n@@ -88,25 +87,30 @@ def _unpack_returndata(buf, contract_sig, skip_contract_check, context):\n     # revert when returndatasize is not in bounds\n     ret = []\n     # runtime: min_return_size <= returndatasize\n-    # TODO move the -1 optimization to IR optimizer\n     if not skip_contract_check:\n-        ret += [[\"assert\", [\"gt\", \"returndatasize\", min_return_size - 1]]]\n+        ret += [[\"assert\", [\"ge\", \"returndatasize\", min_return_size]]]\n \n-    # add as the last IRnode a pointer to the return data structure\n+    encoding = Encoding.ABI\n \n-    # the return type has been wrapped by the calling contract;\n-    # unwrap it so downstream code isn't confused.\n-    # basically this expands to buf+32 if the return type has been wrapped\n-    # in a tuple AND its ABI type is dynamic.\n-    # in most cases, this simply will evaluate to ret.\n-    # in the special case where the return type has been wrapped\n-    # in a tuple AND its ABI type is dynamic, it expands to buf+32.\n-    buf = IRnode(buf, typ=return_t, encoding=_returndata_encoding(contract_sig), location=MEMORY)\n+    buf = IRnode.from_list(\n+        buf,\n+        typ=return_t,\n+        location=MEMORY,\n+        encoding=encoding,\n+        annotation=f\"{expr.node_source_code} returndata buffer\",\n+    )\n \n-    if should_unwrap_abi_tuple:\n-        buf = get_element_ptr(buf, 0, array_bounds_check=False)\n+    assert isinstance(return_t, TupleType)\n+    # unpack strictly\n+    if needs_clamp(return_t, encoding):\n+        buf2 = IRnode.from_list(\n+            context.new_internal_variable(return_t), typ=return_t, location=MEMORY\n+        )\n \n-    ret += [buf]\n+        ret.append(make_setter(buf2, buf))\n+        ret.append(buf2)\n+    else:\n+        ret.append(buf)\n \n     return ret, ret_ofst, ret_len\n \n@@ -145,7 +149,7 @@ def _external_call_helper(\n     buf, arg_packer, args_ofst, args_len = _pack_arguments(contract_sig, args_ir, context)\n \n     ret_unpacker, ret_ofst, ret_len = _unpack_returndata(\n-        buf, contract_sig, skip_contract_check, context\n+        buf, contract_sig, skip_contract_check, context, expr\n     )\n \n     sub += arg_packer\n@@ -169,15 +173,7 @@ def _external_call_helper(\n     if contract_sig.return_type is not None:\n         sub += ret_unpacker\n \n-    ret = IRnode.from_list(\n-        sub,\n-        typ=contract_sig.return_type,\n-        location=MEMORY,\n-        # set the encoding to ABI here, downstream code will decode and add clampers.\n-        encoding=_returndata_encoding(contract_sig),\n-    )\n-\n-    return ret\n+    return IRnode.from_list(sub, typ=contract_sig.return_type, location=MEMORY)\n \n \n def _get_special_kwargs(stmt_expr, context):"
        },
        {
          "filename": "vyper/codegen/function_definitions/external_function.py",
          "status": "modified",
          "additions": 5,
          "deletions": 26,
          "patch": "@@ -3,36 +3,14 @@\n import vyper.utils as util\n from vyper.address_space import CALLDATA, DATA, MEMORY\n from vyper.ast.signatures.function_signature import FunctionSignature, VariableRecord\n+from vyper.codegen.abi_encoder import abi_encoding_matches_vyper\n from vyper.codegen.context import Context\n-from vyper.codegen.core import get_element_ptr, getpos, make_setter\n+from vyper.codegen.core import get_element_ptr, getpos, make_setter, needs_clamp\n from vyper.codegen.expr import Expr\n from vyper.codegen.function_definitions.utils import get_nonreentrant_lock\n from vyper.codegen.ir_node import Encoding, IRnode\n from vyper.codegen.stmt import parse_body\n-from vyper.codegen.types.types import (\n-    BaseType,\n-    ByteArrayLike,\n-    DArrayType,\n-    SArrayType,\n-    TupleLike,\n-    TupleType,\n-)\n-from vyper.exceptions import CompilerPanic\n-\n-\n-def _should_decode(typ):\n-    # either a basetype which needs to be clamped\n-    # or a complex type which contains something that\n-    # needs to be clamped.\n-    if isinstance(typ, BaseType):\n-        return typ.typ not in (\"int256\", \"uint256\", \"bytes32\")\n-    if isinstance(typ, (ByteArrayLike, DArrayType)):\n-        return True\n-    if isinstance(typ, SArrayType):\n-        return _should_decode(typ.subtype)\n-    if isinstance(typ, TupleLike):\n-        return any(_should_decode(t) for t in typ.tuple_members())\n-    raise CompilerPanic(f\"_should_decode({typ})\")  # pragma: notest\n+from vyper.codegen.types.types import TupleType\n \n \n # register function args with the local calling context.\n@@ -53,7 +31,7 @@ def _register_function_args(context: Context, sig: FunctionSignature) -> List[IR\n \n         arg_ir = get_element_ptr(base_args_ofst, i)\n \n-        if _should_decode(arg.typ):\n+        if needs_clamp(arg.typ, Encoding.ABI):\n             # allocate a memory slot for it and copy\n             p = context.new_variable(arg.name, arg.typ, is_mutable=False)\n             dst = IRnode(p, typ=arg.typ, location=MEMORY)\n@@ -62,6 +40,7 @@ def _register_function_args(context: Context, sig: FunctionSignature) -> List[IR\n             copy_arg.source_pos = getpos(arg.ast_source)\n             ret.append(copy_arg)\n         else:\n+            assert abi_encoding_matches_vyper(arg.typ)\n             # leave it in place\n             context.vars[arg.name] = VariableRecord(\n                 name=arg.name,"
        },
        {
          "filename": "vyper/codegen/ir_node.py",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -47,8 +47,6 @@ class Encoding(Enum):\n     VYPER = auto()\n     # abi encoded, default for args/return values from external funcs\n     ABI = auto()\n-    # abi encoded, same as ABI but no clamps for bytestrings\n-    JSON_ABI = auto()\n     # future: packed\n \n "
        },
        {
          "filename": "vyper/codegen/types/convert.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -32,7 +32,7 @@ def new_type_to_old_type(typ: new.BasePrimitive) -> old.NodeType:\n     if isinstance(typ, new.DynamicArrayDefinition):\n         return old.DArrayType(new_type_to_old_type(typ.value_type), typ.length)\n     if isinstance(typ, new.TupleDefinition):\n-        return old.TupleType(typ.value_type)\n+        return old.TupleType([new_type_to_old_type(t) for t in typ.value_type])\n     if isinstance(typ, new.StructDefinition):\n         return old.StructType(\n             {n: new_type_to_old_type(t) for (n, t) in typ.members.items()}, typ._id"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c208b954564e8fffdd4c86cc3c497e0c3df1aeec",
            "date": "2025-01-14T17:09:31Z",
            "author_login": "charles-cooper"
          },
          {
            "sha": "db8dcc713168b16977b5b07267653c9024f6acea",
            "date": "2025-01-12T17:01:49Z",
            "author_login": "charles-cooper"
          },
          {
            "sha": "10e91d5a2ba6eaab2f7194fd86cefb7a0ff19964",
            "date": "2025-01-12T16:34:14Z",
            "author_login": "tserg"
          },
          {
            "sha": "43259f8953672ef7a19167c6c048d020d82e05da",
            "date": "2025-01-12T16:32:46Z",
            "author_login": "charles-cooper"
          },
          {
            "sha": "9b5523e6131335c81714e7e8af63cc49404f5ce7",
            "date": "2025-01-12T16:19:30Z",
            "author_login": "charles-cooper"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:H/A:N",
    "cwe_id": "CWE-120",
    "description": "Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-04-13T19:15:09.243",
    "last_modified": "2024-11-21T06:51:05.893",
    "fix_date": "2022-04-13T13:39:37Z"
  },
  "references": [
    {
      "url": "https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vyperlang/vyper/security/advisories/GHSA-4mrx-6fxm-8jpg",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vyperlang/vyper/security/advisories/GHSA-4mrx-6fxm-8jpg",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:04.379995",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "vyper",
    "owner": "vyperlang",
    "created_at": "2016-11-11T08:56:41Z",
    "updated_at": "2025-01-13T17:32:27Z",
    "pushed_at": "2025-01-12T17:01:50Z",
    "size": 11939,
    "stars": 4948,
    "forks": 817,
    "open_issues": 489,
    "watchers": 4948,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Python": 2662211,
      "Makefile": 2222,
      "Batchfile": 1614,
      "Dockerfile": 1145,
      "Shell": 472
    },
    "commit_activity": {
      "total_commits_last_year": 317,
      "avg_commits_per_week": 6.096153846153846,
      "days_active_last_year": 154
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:48:09.728520"
  }
}