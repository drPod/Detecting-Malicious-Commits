{
  "cve_id": "CVE-2022-24790",
  "github_data": {
    "repository": "puma/puma",
    "fix_commit": "5bb7d202e24dec00a898dca4aa11db391d7787a5",
    "related_commits": [
      "5bb7d202e24dec00a898dca4aa11db391d7787a5",
      "5bb7d202e24dec00a898dca4aa11db391d7787a5"
    ],
    "patch_url": "https://github.com/puma/puma/commit/5bb7d202e24dec00a898dca4aa11db391d7787a5.patch",
    "fix_commit_details": {
      "sha": "5bb7d202e24dec00a898dca4aa11db391d7787a5",
      "commit_date": "2022-03-30T14:06:46Z",
      "author": {
        "login": "nateberkopec",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-h99w-9q5r-gjq9",
        "length": 250,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 304,
        "additions": 289,
        "deletions": 15
      },
      "files": [
        {
          "filename": "lib/puma/client.rb",
          "status": "modified",
          "additions": 54,
          "deletions": 11,
          "patch": "@@ -23,6 +23,8 @@ module Puma\n \n   class ConnectionError < RuntimeError; end\n \n+  class HttpParserError501 < IOError; end\n+\n   # An instance of this class represents a unique request from a client.\n   # For example, this could be a web request from a browser or from CURL.\n   #\n@@ -35,7 +37,21 @@ class ConnectionError < RuntimeError; end\n   # Instances of this class are responsible for knowing if\n   # the header and body are fully buffered via the `try_to_finish` method.\n   # They can be used to \"time out\" a response via the `timeout_at` reader.\n+  #\n   class Client\n+\n+    # this tests all values but the last, which must be chunked\n+    ALLOWED_TRANSFER_ENCODING = %w[compress deflate gzip].freeze\n+\n+    # chunked body validation\n+    CHUNK_SIZE_INVALID = /[^\\h]/.freeze\n+    CHUNK_VALID_ENDING = \"\\r\\n\".freeze\n+\n+    # Content-Length header value validation\n+    CONTENT_LENGTH_VALUE_INVALID = /[^\\d]/.freeze\n+\n+    TE_ERR_MSG = 'Invalid Transfer-Encoding'\n+\n     # The object used for a request with no body. All requests with\n     # no body share this one object since it has no state.\n     EmptyBody = NullIO.new\n@@ -302,24 +318,40 @@ def setup_body\n       body = @parser.body\n \n       te = @env[TRANSFER_ENCODING2]\n-\n       if te\n-        if te.include?(\",\")\n-          te.split(\",\").each do |part|\n-            if CHUNKED.casecmp(part.strip) == 0\n-              return setup_chunked_body(body)\n-            end\n+        te_lwr = te.downcase\n+        if te.include? ','\n+          te_ary = te_lwr.split ','\n+          te_count = te_ary.count CHUNKED\n+          te_valid = te_ary[0..-2].all? { |e| ALLOWED_TRANSFER_ENCODING.include? e }\n+          if te_ary.last == CHUNKED && te_count == 1 && te_valid\n+            @env.delete TRANSFER_ENCODING2\n+            return setup_chunked_body body\n+          elsif te_count >= 1\n+            raise HttpParserError   , \"#{TE_ERR_MSG}, multiple chunked: '#{te}'\"\n+          elsif !te_valid\n+            raise HttpParserError501, \"#{TE_ERR_MSG}, unknown value: '#{te}'\"\n           end\n-        elsif CHUNKED.casecmp(te) == 0\n-          return setup_chunked_body(body)\n+        elsif te_lwr == CHUNKED\n+          @env.delete TRANSFER_ENCODING2\n+          return setup_chunked_body body\n+        elsif ALLOWED_TRANSFER_ENCODING.include? te_lwr\n+          raise HttpParserError     , \"#{TE_ERR_MSG}, single value must be chunked: '#{te}'\"\n+        else\n+          raise HttpParserError501  , \"#{TE_ERR_MSG}, unknown value: '#{te}'\"\n         end\n       end\n \n       @chunked_body = false\n \n       cl = @env[CONTENT_LENGTH]\n \n-      unless cl\n+      if cl\n+        # cannot contain characters that are not \\d\n+        if cl =~ CONTENT_LENGTH_VALUE_INVALID\n+          raise HttpParserError, \"Invalid Content-Length: #{cl.inspect}\"\n+        end\n+      else\n         @buffer = body.empty? ? nil : body\n         @body = EmptyBody\n         set_ready\n@@ -478,7 +510,13 @@ def decode_chunk(chunk)\n       while !io.eof?\n         line = io.gets\n         if line.end_with?(\"\\r\\n\")\n-          len = line.strip.to_i(16)\n+          # Puma doesn't process chunk extensions, but should parse if they're\n+          # present, which is the reason for the semicolon regex\n+          chunk_hex = line.strip[/\\A[^;]+/]\n+          if chunk_hex =~ CHUNK_SIZE_INVALID\n+            raise HttpParserError, \"Invalid chunk size: '#{chunk_hex}'\"\n+          end\n+          len = chunk_hex.to_i(16)\n           if len == 0\n             @in_last_chunk = true\n             @body.rewind\n@@ -509,7 +547,12 @@ def decode_chunk(chunk)\n \n           case\n           when got == len\n-            write_chunk(part[0..-3]) # to skip the ending \\r\\n\n+            # proper chunked segment must end with \"\\r\\n\"\n+            if part.end_with? CHUNK_VALID_ENDING\n+              write_chunk(part[0..-3]) # to skip the ending \\r\\n\n+            else\n+              raise HttpParserError, \"Chunk size mismatch\"\n+            end\n           when got <= len - 2\n             write_chunk(part)\n             @partial_part_left = len - part.size"
        },
        {
          "filename": "lib/puma/const.rb",
          "status": "modified",
          "additions": 5,
          "deletions": 3,
          "patch": "@@ -76,7 +76,7 @@ class UnsupportedOption < RuntimeError\n     508 => 'Loop Detected',\n     510 => 'Not Extended',\n     511 => 'Network Authentication Required'\n-  }\n+  }.freeze\n \n   # For some HTTP status codes the client only expects headers.\n   #\n@@ -85,7 +85,7 @@ class UnsupportedOption < RuntimeError\n     204 => true,\n     205 => true,\n     304 => true\n-  }\n+  }.freeze\n \n   # Frequently used constants when constructing requests or responses.  Many times\n   # the constant just refers to a string with the same contents.  Using these constants\n@@ -145,9 +145,11 @@ module Const\n       408 => \"HTTP/1.1 408 Request Timeout\\r\\nConnection: close\\r\\nServer: Puma #{PUMA_VERSION}\\r\\n\\r\\n\".freeze,\n       # Indicate that there was an internal error, obviously.\n       500 => \"HTTP/1.1 500 Internal Server Error\\r\\n\\r\\n\".freeze,\n+      # Incorrect or invalid header value\n+      501 => \"HTTP/1.1 501 Not Implemented\\r\\n\\r\\n\".freeze,\n       # A common header for indicating the server is too busy.  Not used yet.\n       503 => \"HTTP/1.1 503 Service Unavailable\\r\\n\\r\\nBUSY\".freeze\n-    }\n+    }.freeze\n \n     # The basic max request size we'll try to read.\n     CHUNK_SIZE = 16 * 1024"
        },
        {
          "filename": "lib/puma/server.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -515,6 +515,9 @@ def client_error(e, client)\n       when HttpParserError\n         client.write_error(400)\n         @events.parse_error e, client\n+      when HttpParserError501\n+        client.write_error(501)\n+        @events.parse_error e, client\n       else\n         client.write_error(500)\n         @events.unknown_error e, nil, \"Read\""
        },
        {
          "filename": "test/helper.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -174,6 +174,9 @@ def skip_unless(eng, bt: caller)\n Minitest::Test.include TestSkips\n \n class Minitest::Test\n+\n+  REPO_NAME = ENV['GITHUB_REPOSITORY'] ? ENV['GITHUB_REPOSITORY'][/[^\\/]+\\z/] : 'puma'\n+\n   def self.run(reporter, options = {}) # :nodoc:\n     prove_it!\n     super"
        },
        {
          "filename": "test/test_puma_server.rb",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -602,17 +602,20 @@ def test_Expect_100\n   def test_chunked_request\n     body = nil\n     content_length = nil\n+    transfer_encoding = nil\n     server_run { |env|\n       body = env['rack.input'].read\n       content_length = env['CONTENT_LENGTH']\n+      transfer_encoding = env['HTTP_TRANSFER_ENCODING']\n       [200, {}, [\"\"]]\n     }\n \n-    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n+    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: gzip,chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n \n     assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n     assert_equal \"hello\", body\n     assert_equal \"5\", content_length\n+    assert_nil transfer_encoding\n   end\n \n   def test_large_chunked_request"
        },
        {
          "filename": "test/test_request_invalid.rb",
          "status": "added",
          "additions": 220,
          "deletions": 0,
          "patch": "@@ -0,0 +1,220 @@\n+require_relative \"helper\"\n+require \"puma/events\"\n+\n+# These tests check for invalid request headers and metadata.\n+# Content-Length, Transfer-Encoding, and chunked body size\n+# values are checked for validity\n+#\n+# See https://datatracker.ietf.org/doc/html/rfc7230\n+#\n+# https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2 Content-Length\n+# https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.1 Transfer-Encoding\n+# https://datatracker.ietf.org/doc/html/rfc7230#section-4.1   chunked body size\n+#\n+class TestRequestInvalid < Minitest::Test\n+  # running parallel seems to take longer...\n+  # parallelize_me! unless JRUBY_HEAD\n+\n+  GET_PREFIX = \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\"\n+  CHUNKED = \"1\\r\\nH\\r\\n4\\r\\nello\\r\\n5\\r\\nWorld\\r\\n0\\r\\n\\r\\n\"\n+\n+  def setup\n+    @host = '127.0.0.1'\n+\n+    @ios = []\n+\n+    # this app should never be called, used for debugging\n+    app = ->(env) {\n+      body = ''.dup\n+      env.each do |k,v|\n+        body << \"#{k} = #{v}\\n\"\n+        if k == 'rack.input'\n+          body << \"#{v.read}\\n\"\n+        end\n+      end\n+      [200, {}, [body]]\n+    }\n+\n+    @log_writer = Puma::LogWriter.strings\n+    events = Puma::Events.new\n+    @server = Puma::Server.new app, @log_writer, events\n+    @port = (@server.add_tcp_listener @host, 0).addr[1]\n+    @server.run\n+    sleep 0.15 if Puma.jruby?\n+  end\n+\n+  def teardown\n+    @server.stop(true)\n+    @ios.each { |io| io.close if io && !io.closed? }\n+  end\n+\n+  def send_http_and_read(req)\n+    send_http(req).read\n+  end\n+\n+  def send_http(req)\n+    new_connection << req\n+  end\n+\n+  def new_connection\n+    TCPSocket.new(@host, @port).tap {|sock| @ios << sock}\n+  end\n+\n+  def assert_status(str, status = 400)\n+    assert str.start_with?(\"HTTP/1.1 #{status}\"), \"'#{str[/[^\\r]+/]}' should be #{status}\"\n+  end\n+\n+  # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 below are invalid Content-Length\n+\n+  def test_content_length_multiple\n+    te = [\n+      'Content-Length: 5',\n+      'Content-Length: 5'\n+    ].join \"\\r\\n\"\n+\n+    data = send_http_and_read \"#{GET_PREFIX}#{te}\\r\\n\\r\\nHello\\r\\n\\r\\n\"\n+\n+    assert_status data\n+  end\n+\n+  def test_content_length_bad_characters_1\n+    te = 'Content-Length: 5.01'\n+\n+    data = send_http_and_read \"#{GET_PREFIX}#{te}\\r\\n\\r\\nHello\\r\\n\\r\\n\"\n+\n+    assert_status data\n+  end\n+\n+  def test_content_length_bad_characters_2\n+    te = 'Content-Length: +5'\n+\n+    data = send_http_and_read \"#{GET_PREFIX}#{te}\\r\\n\\r\\nHello\\r\\n\\r\\n\"\n+\n+    assert_status data\n+  end\n+\n+  def test_content_length_bad_characters_3\n+    te = 'Content-Length: 5 test'\n+\n+    data = send_http_and_read \"#{GET_PREFIX}#{te}\\r\\n\\r\\nHello\\r\\n\\r\\n\"\n+\n+    assert_status data\n+  end\n+\n+  # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 below are invalid Transfer-Encoding\n+\n+  def test_transfer_encoding_chunked_not_last\n+    te = [\n+      'Transfer-Encoding: chunked',\n+      'Transfer-Encoding: gzip'\n+    ].join \"\\r\\n\"\n+\n+    data = send_http_and_read \"#{GET_PREFIX}#{te}\\r\\n\\r\\n#{CHUNKED}\"\n+\n+    assert_status data\n+  end\n+\n+  def test_transfer_encoding_chunked_multiple\n+    te = [\n+      'Transfer-Encoding: chunked',\n+      'Transfer-Encoding: gzip',\n+      'Transfer-Encoding: chunked'\n+    ].join \"\\r\\n\"\n+\n+    data = send_http_and_read \"#{GET_PREFIX}#{te}\\r\\n\\r\\n#{CHUNKED}\"\n+\n+    assert_status data\n+  end\n+\n+  def test_transfer_encoding_invalid_single\n+    te = 'Transfer-Encoding: xchunked'\n+\n+    data = send_http_and_read \"#{GET_PREFIX}#{te}\\r\\n\\r\\n#{CHUNKED}\"\n+\n+    assert_status data, 501\n+  end\n+\n+  def test_transfer_encoding_invalid_multiple\n+    te = [\n+      'Transfer-Encoding: x_gzip',\n+      'Transfer-Encoding: gzip',\n+      'Transfer-Encoding: chunked'\n+    ].join \"\\r\\n\"\n+\n+    data = send_http_and_read \"#{GET_PREFIX}#{te}\\r\\n\\r\\n#{CHUNKED}\"\n+\n+    assert_status data, 501\n+  end\n+\n+  def test_transfer_encoding_single_not_chunked\n+    te = 'Transfer-Encoding: gzip'\n+\n+    data = send_http_and_read \"#{GET_PREFIX}#{te}\\r\\n\\r\\n#{CHUNKED}\"\n+\n+    assert_status data\n+  end\n+\n+  # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 below are invalid chunked size\n+\n+  def test_chunked_size_bad_characters_1\n+    te = 'Transfer-Encoding: chunked'\n+    chunked ='5.01'\n+\n+    data = send_http_and_read \"#{GET_PREFIX}#{te}\\r\\n\\r\\n1\\r\\nh\\r\\n#{chunked}\\r\\nHello\\r\\n0\\r\\n\\r\\n\"\n+\n+    assert_status data\n+  end\n+\n+  def test_chunked_size_bad_characters_2\n+    te = 'Transfer-Encoding: chunked'\n+    chunked ='+5'\n+\n+    data = send_http_and_read \"#{GET_PREFIX}#{te}\\r\\n\\r\\n1\\r\\nh\\r\\n#{chunked}\\r\\nHello\\r\\n0\\r\\n\\r\\n\"\n+\n+    assert_status data\n+  end\n+\n+  def test_chunked_size_bad_characters_3\n+    te = 'Transfer-Encoding: chunked'\n+    chunked ='5 bad'\n+\n+    data = send_http_and_read \"#{GET_PREFIX}#{te}\\r\\n\\r\\n1\\r\\nh\\r\\n#{chunked}\\r\\nHello\\r\\n0\\r\\n\\r\\n\"\n+\n+    assert_status data\n+  end\n+\n+  def test_chunked_size_bad_characters_4\n+    te = 'Transfer-Encoding: chunked'\n+    chunked ='0xA'\n+\n+    data = send_http_and_read \"#{GET_PREFIX}#{te}\\r\\n\\r\\n1\\r\\nh\\r\\n#{chunked}\\r\\nHelloHello\\r\\n0\\r\\n\\r\\n\"\n+\n+    assert_status data\n+  end\n+\n+  # size is less than bytesize\n+  def test_chunked_size_mismatch_1\n+    te = 'Transfer-Encoding: chunked'\n+    chunked =\n+      \"5\\r\\nHello\\r\\n\" \\\n+      \"4\\r\\nWorld\\r\\n\" \\\n+      \"0\"\n+\n+    data = send_http_and_read \"#{GET_PREFIX}#{te}\\r\\n\\r\\n#{chunked}\\r\\n\\r\\n\"\n+\n+    assert_status data\n+  end\n+\n+  # size is greater than bytesize\n+  def test_chunked_size_mismatch_2\n+    te = 'Transfer-Encoding: chunked'\n+    chunked =\n+      \"5\\r\\nHello\\r\\n\" \\\n+      \"6\\r\\nWorld\\r\\n\" \\\n+      \"0\"\n+\n+    data = send_http_and_read \"#{GET_PREFIX}#{te}\\r\\n\\r\\n#{chunked}\\r\\n\\r\\n\"\n+\n+    assert_status data\n+  end\n+end"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "edd2a1728e39d055545fd12ffdfa42d5d4ccbc58",
            "date": "2025-01-11T03:28:01Z",
            "author_login": "MSP-Greg"
          },
          {
            "sha": "69aa270f5e61efea37d73280137deea855f14ac6",
            "date": "2025-01-11T03:18:53Z",
            "author_login": "MSP-Greg"
          },
          {
            "sha": "a478d4d095595f5cca982c45cf65ece0fb1118e9",
            "date": "2025-01-10T10:37:58Z",
            "author_login": "joshuay03"
          },
          {
            "sha": "437c9ce93ac63eba38a5c553b7b5a52699bab971",
            "date": "2025-01-07T01:26:28Z",
            "author_login": "nateberkopec"
          },
          {
            "sha": "584d4e4070528479571ed001f94f90d07f074acc",
            "date": "2025-01-04T17:33:40Z",
            "author_login": "MSP-Greg"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-444",
    "description": "Puma is a simple, fast, multi-threaded, parallel HTTP 1.1 server for Ruby/Rack applications. When using Puma behind a proxy that does not properly validate that the incoming HTTP request matches the RFC7230 standard, Puma and the frontend proxy may disagree on where a request starts and ends. This would allow requests to be smuggled via the front-end proxy to Puma. The vulnerability has been fixed in 5.6.4 and 4.3.12. Users are advised to upgrade as soon as possible. Workaround: when deploying a proxy in front of Puma, turning on any and all functionality to make sure that the request matches the RFC7230 standard.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-03-30T22:15:08.500",
    "last_modified": "2024-11-21T06:51:06.130",
    "fix_date": "2022-03-30T14:06:46Z"
  },
  "references": [
    {
      "url": "https://github.com/puma/puma/commit/5bb7d202e24dec00a898dca4aa11db391d7787a5",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/puma/puma/security/advisories/GHSA-h99w-9q5r-gjq9",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2022/08/msg00015.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/F6YWGIIKL7KKTS3ZOAYMYPC7D6WQ5OA5/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/L7NESIBFCNSR3XH7LXDPKVMSUBNUB43G/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TUBFJ44NCKJ34LECZRAP4N5VL6USJSIB/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202208-28",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2022/dsa-5146",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/puma/puma/commit/5bb7d202e24dec00a898dca4aa11db391d7787a5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/puma/puma/security/advisories/GHSA-h99w-9q5r-gjq9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2022/08/msg00015.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/F6YWGIIKL7KKTS3ZOAYMYPC7D6WQ5OA5/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/L7NESIBFCNSR3XH7LXDPKVMSUBNUB43G/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TUBFJ44NCKJ34LECZRAP4N5VL6USJSIB/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202208-28",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.debian.org/security/2022/dsa-5146",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:02.082836",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "puma",
    "owner": "puma",
    "created_at": "2011-09-23T02:26:08Z",
    "updated_at": "2025-01-14T14:47:16Z",
    "pushed_at": "2025-01-11T03:28:01Z",
    "size": 11904,
    "stars": 7716,
    "forks": 1449,
    "open_issues": 93,
    "watchers": 7716,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Ruby": 735873,
      "C": 59303,
      "Java": 43606,
      "Ragel": 9223,
      "Shell": 9208,
      "PowerShell": 3326,
      "Dockerfile": 1455,
      "Lua": 127,
      "Batchfile": 35
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T16:25:36.527726"
  }
}