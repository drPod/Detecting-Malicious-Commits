{
  "cve_id": "CVE-2022-24791",
  "github_data": {
    "repository": "bytecodealliance/wasmtime",
    "fix_commit": "666c2554ea0e1728c35aa41178cf235920db888a",
    "related_commits": [
      "666c2554ea0e1728c35aa41178cf235920db888a",
      "666c2554ea0e1728c35aa41178cf235920db888a"
    ],
    "patch_url": "https://github.com/bytecodealliance/wasmtime/commit/666c2554ea0e1728c35aa41178cf235920db888a.patch",
    "fix_commit_details": {
      "sha": "666c2554ea0e1728c35aa41178cf235920db888a",
      "commit_date": "2022-03-31T21:26:01Z",
      "author": {
        "login": "cfallin",
        "type": "User",
        "stats": {
          "total_commits": 794,
          "average_weekly_commits": 1.7298474945533768,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 156
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-gwc9-348x-qwv2",
        "length": 1260,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 61,
        "additions": 46,
        "deletions": 15
      },
      "files": [
        {
          "filename": "cranelift/codegen/src/machinst/vcode.rs",
          "status": "modified",
          "additions": 19,
          "deletions": 12,
          "patch": "@@ -17,6 +17,7 @@\n //! See the main module comment in `mod.rs` for more details on the VCode-based\n //! backend pipeline.\n \n+use crate::fx::FxHashMap;\n use crate::ir::{self, types, Constant, ConstantData, SourceLoc};\n use crate::machinst::*;\n use crate::settings;\n@@ -478,6 +479,19 @@ impl<I: VCodeInst> VCode<I> {\n         let mut inst_end_offsets = vec![0; self.insts.len()];\n         let mut label_inst_indices = vec![0; self.num_blocks()];\n \n+        // Map from instruction index to index in\n+        // `safepoint_slots`. We need this because we emit\n+        // instructions out-of-order, while the safepoint_insns /\n+        // safepoint_slots data structures are sorted in instruction\n+        // order.\n+        let mut safepoint_indices: FxHashMap<u32, usize> = FxHashMap::default();\n+        for (safepoint_idx, iix) in self.safepoint_insns.iter().enumerate() {\n+            // Disregard safepoints that ended up having no live refs.\n+            if self.safepoint_slots[safepoint_idx].len() > 0 {\n+                safepoint_indices.insert(*iix, safepoint_idx);\n+            }\n+        }\n+\n         // Construct the final order we emit code in: cold blocks at the end.\n         let mut final_order: SmallVec<[BlockIndex; 16]> = smallvec![];\n         let mut cold_blocks: SmallVec<[BlockIndex; 16]> = smallvec![];\n@@ -493,7 +507,6 @@ impl<I: VCodeInst> VCode<I> {\n         final_order.extend(cold_blocks.clone());\n \n         // Emit blocks.\n-        let mut safepoint_idx = 0;\n         let mut cur_srcloc = None;\n         let mut last_offset = None;\n         let mut start_of_cold_code = None;\n@@ -541,17 +554,11 @@ impl<I: VCodeInst> VCode<I> {\n                 }\n                 state.pre_sourceloc(cur_srcloc.unwrap_or(SourceLoc::default()));\n \n-                if safepoint_idx < self.safepoint_insns.len()\n-                    && self.safepoint_insns[safepoint_idx] == iix\n-                {\n-                    if self.safepoint_slots[safepoint_idx].len() > 0 {\n-                        let stack_map = self.abi.spillslots_to_stack_map(\n-                            &self.safepoint_slots[safepoint_idx][..],\n-                            &state,\n-                        );\n-                        state.pre_safepoint(stack_map);\n-                    }\n-                    safepoint_idx += 1;\n+                if let Some(safepoint_idx) = safepoint_indices.get(&iix) {\n+                    let stack_map = self\n+                        .abi\n+                        .spillslots_to_stack_map(&self.safepoint_slots[*safepoint_idx][..], &state);\n+                    state.pre_safepoint(stack_map);\n                 }\n \n                 self.insts[iix as usize].emit(&mut buffer, &self.emit_info, &mut state);"
        },
        {
          "filename": "tests/all/funcref.rs",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -6,6 +6,7 @@ use wasmtime::*;\n #[test]\n fn pass_funcref_in_and_out_of_wasm() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (func (export \"func\") (param funcref) (result funcref)\n@@ -60,7 +61,8 @@ fn pass_funcref_in_and_out_of_wasm() -> anyhow::Result<()> {\n \n     // Passing in a `funcref` from another store fails.\n     {\n-        let (mut other_store, other_module) = ref_types_module(r#\"(module (func (export \"f\")))\"#)?;\n+        let (mut other_store, other_module) =\n+            ref_types_module(false, r#\"(module (func (export \"f\")))\"#)?;\n         let other_store_instance = Instance::new(&mut other_store, &other_module, &[])?;\n         let f = other_store_instance\n             .get_func(&mut other_store, \"f\")\n@@ -77,6 +79,7 @@ fn pass_funcref_in_and_out_of_wasm() -> anyhow::Result<()> {\n #[test]\n fn receive_null_funcref_from_wasm() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (func (export \"get-null\") (result funcref)"
        },
        {
          "filename": "tests/all/gc.rs",
          "status": "modified",
          "additions": 15,
          "deletions": 1,
          "patch": "@@ -14,7 +14,17 @@ impl Drop for SetFlagOnDrop {\n \n #[test]\n fn smoke_test_gc() -> anyhow::Result<()> {\n+    smoke_test_gc_impl(false)\n+}\n+\n+#[test]\n+fn smoke_test_gc_epochs() -> anyhow::Result<()> {\n+    smoke_test_gc_impl(true)\n+}\n+\n+fn smoke_test_gc_impl(use_epochs: bool) -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        use_epochs,\n         r#\"\n             (module\n                 (import \"\" \"\" (func $do_gc))\n@@ -69,6 +79,7 @@ fn smoke_test_gc() -> anyhow::Result<()> {\n #[test]\n fn wasm_dropping_refs() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (func (export \"drop_ref\") (param externref)\n@@ -145,7 +156,7 @@ fn many_live_refs() -> anyhow::Result<()> {\n         \",\n     );\n \n-    let (mut store, module) = ref_types_module(&wat)?;\n+    let (mut store, module) = ref_types_module(false, &wat)?;\n \n     let live_refs = Arc::new(AtomicUsize::new(0));\n \n@@ -191,6 +202,7 @@ fn many_live_refs() -> anyhow::Result<()> {\n #[test]\n fn drop_externref_via_table_set() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (table $t 1 externref)\n@@ -400,6 +412,7 @@ fn gee_i_sure_hope_refcounting_is_atomic() -> anyhow::Result<()> {\n #[test]\n fn global_init_no_leak() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (import \"\" \"\" (global externref))\n@@ -424,6 +437,7 @@ fn global_init_no_leak() -> anyhow::Result<()> {\n #[test]\n fn no_gc_middle_of_args() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (import \"\" \"return_some\" (func $return (result externref externref externref)))"
        },
        {
          "filename": "tests/all/main.rs",
          "status": "modified",
          "additions": 8,
          "deletions": 1,
          "patch": "@@ -33,6 +33,7 @@ mod wast;\n \n /// A helper to compile a module in a new store with reference types enabled.\n pub(crate) fn ref_types_module(\n+    use_epochs: bool,\n     source: &str,\n ) -> anyhow::Result<(wasmtime::Store<()>, wasmtime::Module)> {\n     use wasmtime::*;\n@@ -41,9 +42,15 @@ pub(crate) fn ref_types_module(\n \n     let mut config = Config::new();\n     config.wasm_reference_types(true);\n+    if use_epochs {\n+        config.epoch_interruption(true);\n+    }\n \n     let engine = Engine::new(&config)?;\n-    let store = Store::new(&engine, ());\n+    let mut store = Store::new(&engine, ());\n+    if use_epochs {\n+        store.set_epoch_deadline(1);\n+    }\n \n     let module = Module::new(&engine, source)?;\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 2,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "75f7b2bed7b2c4360a1a01fdfdb2cfaac9b0b6ae",
            "date": "2025-01-14T15:49:21Z",
            "author_login": "nilsmartel"
          },
          {
            "sha": "e4fd50d1e27f3ba3d4757b85547d55f585d446f9",
            "date": "2025-01-14T01:28:53Z",
            "author_login": "alexcrichton"
          },
          {
            "sha": "8659e11c4ad12512defd6213de0a9d73f8ae6732",
            "date": "2025-01-14T00:47:04Z",
            "author_login": "fitzgen"
          },
          {
            "sha": "84f381fa1bc5c00438108d16fb14657a2c76a182",
            "date": "2025-01-13T22:31:43Z",
            "author_login": "saulecabrera"
          },
          {
            "sha": "a6a08570216d5c42b1c1fc9699fe5b9ae214f27e",
            "date": "2025-01-13T21:05:07Z",
            "author_login": "alexcrichton"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-416",
    "description": "Wasmtime is a standalone JIT-style runtime for WebAssembly, using Cranelift. There is a use after free vulnerability in Wasmtime when both running Wasm that uses externrefs and enabling epoch interruption in Wasmtime. If you are not explicitly enabling epoch interruption (it is disabled by default) then you are not affected. If you are explicitly disabling the Wasm reference types proposal (it is enabled by default) then you are also not affected. The use after free is caused by Cranelift failing to emit stack maps when there are safepoints inside cold blocks. Cold blocks occur when epoch interruption is enabled. Cold blocks are emitted at the end of compiled functions, and change the order blocks are emitted versus defined. This reordering accidentally caused Cranelift to skip emitting some stack maps because it expected to emit the stack maps in block definition order, rather than block emission order. When Wasmtime would eventually collect garbage, it would fail to find live references on the stack because of the missing stack maps, think that they were unreferenced garbage, and therefore reclaim them. Then after the collection ended, the Wasm code could use the reclaimed-too-early references, which is a use after free. Patches have been released in versions 0.34.2 and 0.35.2, which fix the vulnerability. All Wasmtime users are recommended to upgrade to these patched versions. If upgrading is not an option for you at this time, you can avoid the vulnerability by either: disabling the Wasm reference types proposal, config.wasm_reference_types(false); or by disabling epoch interruption if you were previously enabling it. config.epoch_interruption(false).",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-03-31T23:15:08.063",
    "last_modified": "2024-11-21T06:51:06.277",
    "fix_date": "2022-03-31T21:26:01Z"
  },
  "references": [
    {
      "url": "https://github.com/bytecodealliance/wasmtime/commit/666c2554ea0e1728c35aa41178cf235920db888a",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gwc9-348x-qwv2",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/bytecodealliance/wasmtime/commit/666c2554ea0e1728c35aa41178cf235920db888a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gwc9-348x-qwv2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:02.086822",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "wasmtime",
    "owner": "bytecodealliance",
    "created_at": "2017-08-29T14:01:55Z",
    "updated_at": "2025-01-14T09:40:55Z",
    "pushed_at": "2025-01-14T01:52:50Z",
    "size": 111616,
    "stars": 15702,
    "forks": 1345,
    "open_issues": 787,
    "watchers": 15702,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-0.32.0",
      "release-0.33.0",
      "release-0.34.0",
      "release-0.35.0",
      "release-0.36.0",
      "release-0.37.0",
      "release-0.38.0",
      "release-0.39.0",
      "release-0.40.0",
      "release-1.0.0",
      "release-2.0.0",
      "release-3.0.0",
      "release-4.0.0",
      "release-5.0.0",
      "release-6.0.0",
      "release-7.0.0",
      "release-8.0.0",
      "release-9.0.0"
    ],
    "languages": {
      "Rust": 19224087,
      "WebAssembly": 6773216,
      "Common Lisp": 1793054,
      "C": 257019,
      "JavaScript": 24116,
      "Shell": 23820,
      "C++": 21050,
      "CMake": 7205,
      "OCaml": 6903,
      "Assembly": 4165,
      "Dockerfile": 2564,
      "Makefile": 1432,
      "CSS": 303
    },
    "commit_activity": {
      "total_commits_last_year": 1586,
      "avg_commits_per_week": 30.5,
      "days_active_last_year": 278
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:32:42.127815"
  }
}