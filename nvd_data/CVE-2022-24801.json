{
  "cve_id": "CVE-2022-24801",
  "github_data": {
    "repository": "twisted/twisted",
    "fix_commit": "592217e951363d60e9cd99c5bbfd23d4615043ac",
    "related_commits": [
      "592217e951363d60e9cd99c5bbfd23d4615043ac",
      "592217e951363d60e9cd99c5bbfd23d4615043ac"
    ],
    "patch_url": "https://github.com/twisted/twisted/commit/592217e951363d60e9cd99c5bbfd23d4615043ac.patch",
    "fix_commit_details": {
      "sha": "592217e951363d60e9cd99c5bbfd23d4615043ac",
      "commit_date": "2022-04-04T09:30:28Z",
      "author": {
        "login": "adiroiban",
        "type": "User",
        "stats": {
          "total_commits": 1603,
          "average_weekly_commits": 1.3053745928338762,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 174
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-c2jg-hw38-jrqq",
        "length": 138,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 291,
        "additions": 278,
        "deletions": 13
      },
      "files": [
        {
          "filename": "src/twisted/web/http.py",
          "status": "modified",
          "additions": 86,
          "deletions": 9,
          "patch": "@@ -108,7 +108,7 @@\n import time\n import warnings\n from io import BytesIO\n-from typing import AnyStr, Callable, Optional\n+from typing import AnyStr, Callable, Optional, Tuple\n from urllib.parse import (\n     ParseResultBytes,\n     unquote_to_bytes as unquote,\n@@ -410,10 +410,39 @@ def toChunk(data):\n     return (networkString(f\"{len(data):x}\"), b\"\\r\\n\", data, b\"\\r\\n\")\n \n \n-def fromChunk(data):\n+def _ishexdigits(b: bytes) -> bool:\n+    \"\"\"\n+    Is the string case-insensitively hexidecimal?\n+\n+    It must be composed of one or more characters in the ranges a-f, A-F\n+    and 0-9.\n+    \"\"\"\n+    for c in b:\n+        if c not in b\"0123456789abcdefABCDEF\":\n+            return False\n+    return b != b\"\"\n+\n+\n+def _hexint(b: bytes) -> int:\n+    \"\"\"\n+    Decode a hexadecimal integer.\n+\n+    Unlike L{int(b, 16)}, this raises L{ValueError} when the integer has\n+    a prefix like C{b'0x'}, C{b'+'}, or C{b'-'}, which is desirable when\n+    parsing network protocols.\n+    \"\"\"\n+    if not _ishexdigits(b):\n+        raise ValueError(b)\n+    return int(b, 16)\n+\n+\n+def fromChunk(data: bytes) -> Tuple[bytes, bytes]:\n     \"\"\"\n     Convert chunk to string.\n \n+    Note that this function is not specification compliant: it doesn't handle\n+    chunk extensions.\n+\n     @type data: C{bytes}\n \n     @return: tuple of (result, remaining) - both C{bytes}.\n@@ -422,7 +451,7 @@ def fromChunk(data):\n         byte string.\n     \"\"\"\n     prefix, rest = data.split(b\"\\r\\n\", 1)\n-    length = int(prefix, 16)\n+    length = _hexint(prefix)\n     if length < 0:\n         raise ValueError(\"Chunk length must be >= 0, not %d\" % (length,))\n     if rest[length : length + 2] != b\"\\r\\n\":\n@@ -1790,6 +1819,47 @@ def noMoreData(self):\n maxChunkSizeLineLength = 1024\n \n \n+_chunkExtChars = (\n+    b\"\\t !\\\"#$%&'()*+,-./0123456789:;<=>?@\"\n+    b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`\"\n+    b\"abcdefghijklmnopqrstuvwxyz{|}~\"\n+    b\"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"\n+    b\"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\n+    b\"\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\"\n+    b\"\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\"\n+    b\"\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\"\n+    b\"\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\"\n+    b\"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n+    b\"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\"\n+)\n+\"\"\"\n+Characters that are valid in a chunk extension.\n+\n+See RFC 7230 section 4.1.1::\n+\n+     chunk-ext      = *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] )\n+\n+     chunk-ext-name = token\n+     chunk-ext-val  = token / quoted-string\n+\n+And section 3.2.6::\n+\n+     token          = 1*tchar\n+\n+     tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n+                    / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n+                    / DIGIT / ALPHA\n+                    ; any VCHAR, except delimiters\n+\n+     quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n+     qdtext         = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text\n+     obs-text       = %x80-FF\n+\n+We don't check if chunk extensions are well-formed beyond validating that they\n+don't contain characters outside this range.\n+\"\"\"\n+\n+\n class _ChunkedTransferDecoder:\n     \"\"\"\n     Protocol for decoding I{chunked} Transfer-Encoding, as defined by RFC 7230,\n@@ -1883,14 +1953,19 @@ def _dataReceived_CHUNK_LENGTH(self) -> bool:\n         endOfLengthIndex = self._buffer.find(b\";\", 0, eolIndex)\n         if endOfLengthIndex == -1:\n             endOfLengthIndex = eolIndex\n+        rawLength = self._buffer[0:endOfLengthIndex]\n         try:\n-            length = int(self._buffer[0:endOfLengthIndex], 16)\n+            length = _hexint(rawLength)\n         except ValueError:\n             raise _MalformedChunkedDataError(\"Chunk-size must be an integer.\")\n \n-        if length < 0:\n-            raise _MalformedChunkedDataError(\"Chunk-size must not be negative.\")\n-        elif length == 0:\n+        ext = self._buffer[endOfLengthIndex + 1 : eolIndex]\n+        if ext and ext.translate(None, _chunkExtChars) != b\"\":\n+            raise _MalformedChunkedDataError(\n+                f\"Invalid characters in chunk extensions: {ext!r}.\"\n+            )\n+\n+        if length == 0:\n             self.state = \"TRAILER\"\n         else:\n             self.state = \"BODY\"\n@@ -2246,7 +2321,7 @@ def lineReceived(self, line):\n                 self.setRawMode()\n         elif line[0] in b\" \\t\":\n             # Continuation of a multi line header.\n-            self.__header = self.__header + b\"\\n\" + line\n+            self.__header += b\" \" + line.lstrip(b\" \\t\")\n         # Regular header line.\n         # Processing of header line is delayed to allow accumulating multi\n         # line headers.\n@@ -2274,6 +2349,8 @@ def fail():\n \n         # Can this header determine the length?\n         if header == b\"content-length\":\n+            if not data.isdigit():\n+                return fail()\n             try:\n                 length = int(data)\n             except ValueError:\n@@ -2327,7 +2404,7 @@ def headerReceived(self, line):\n             return False\n \n         header = header.lower()\n-        data = data.strip()\n+        data = data.strip(b\" \\t\")\n \n         if not self._maybeChooseTransferDecoder(header, data):\n             return False"
        },
        {
          "filename": "src/twisted/web/newsfragments/10323.bugfix",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+twisted.web.http had several several defects in HTTP request parsing that could permit HTTP request smuggling. It now disallows signed Content-Length headers, forbids illegal characters in chunked extensions, forbids 0x prefix to chunk lengths, and only strips spaces and horizontal tab characters from header values. These changes address CVE-2022-24801 and GHSA-c2jg-hw38-jrqq."
        },
        {
          "filename": "src/twisted/web/test/test_http.py",
          "status": "modified",
          "additions": 191,
          "deletions": 4,
          "patch": "@@ -1279,6 +1279,28 @@ def test_extensions(self):\n         p.dataReceived(b\"3; x-foo=bar\\r\\nabc\\r\\n\")\n         self.assertEqual(L, [b\"abc\"])\n \n+    def test_extensionsMalformed(self):\n+        \"\"\"\n+        L{_ChunkedTransferDecoder.dataReceived} raises\n+        L{_MalformedChunkedDataError} when the chunk extension fields contain\n+        invalid characters.\n+\n+        This is a potential request smuggling vector: see GHSA-c2jg-hw38-jrqq.\n+        \"\"\"\n+        invalidControl = (\n+            b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\n\\x0b\\x0c\\r\\x0e\\x0f\"\n+            b\"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\"\n+        )\n+        invalidDelimiter = b\"\\\\\"\n+        invalidDel = b\"\\x7f\"\n+        for b in invalidControl + invalidDelimiter + invalidDel:\n+            data = b\"3; \" + bytes((b,)) + b\"\\r\\nabc\\r\\n\"\n+            p = http._ChunkedTransferDecoder(\n+                lambda b: None,  # pragma: nocov\n+                lambda b: None,  # pragma: nocov\n+            )\n+            self.assertRaises(http._MalformedChunkedDataError, p.dataReceived, data)\n+\n     def test_oversizedChunkSizeLine(self):\n         \"\"\"\n         L{_ChunkedTransferDecoder.dataReceived} raises\n@@ -1334,6 +1356,22 @@ def test_malformedChunkSizeNegative(self):\n             http._MalformedChunkedDataError, p.dataReceived, b\"-3\\r\\nabc\\r\\n\"\n         )\n \n+    def test_malformedChunkSizeHex(self):\n+        \"\"\"\n+        L{_ChunkedTransferDecoder.dataReceived} raises\n+        L{_MalformedChunkedDataError} when the chunk size is prefixed with\n+        \"0x\", as if it were a Python integer literal.\n+\n+        This is a potential request smuggling vector: see GHSA-c2jg-hw38-jrqq.\n+        \"\"\"\n+        p = http._ChunkedTransferDecoder(\n+            lambda b: None,  # pragma: nocov\n+            lambda b: None,  # pragma: nocov\n+        )\n+        self.assertRaises(\n+            http._MalformedChunkedDataError, p.dataReceived, b\"0x3\\r\\nabc\\r\\n\"\n+        )\n+\n     def test_malformedChunkEnd(self):\n         r\"\"\"\n         L{_ChunkedTransferDecoder.dataReceived} raises\n@@ -1446,6 +1484,8 @@ def testChunks(self):\n             chunked = b\"\".join(http.toChunk(s))\n             self.assertEqual((s, b\"\"), http.fromChunk(chunked))\n         self.assertRaises(ValueError, http.fromChunk, b\"-5\\r\\nmalformed!\\r\\n\")\n+        self.assertRaises(ValueError, http.fromChunk, b\"0xa\\r\\nmalformed!\\r\\n\")\n+        self.assertRaises(ValueError, http.fromChunk, b\"0XA\\r\\nmalformed!\\r\\n\")\n \n     def testConcatenatedChunks(self):\n         chunked = b\"\".join([b\"\".join(http.toChunk(t)) for t in self.strings])\n@@ -1703,7 +1743,12 @@ def test_headersMultiline(self):\n         Line folded headers are handled by L{HTTPChannel} by replacing each\n         fold with a single space by the time they are made available to the\n         L{Request}. Any leading whitespace in the folded lines of the header\n-        value is preserved.\n+        value is replaced with a single space, per:\n+\n+            A server that receives an obs-fold in a request message ... MUST\n+            ... replace each received obs-fold with one or more SP octets prior\n+            to interpreting the field value or forwarding the message\n+            downstream.\n \n         See RFC 7230 section 3.2.4.\n         \"\"\"\n@@ -1740,15 +1785,65 @@ def process(self):\n         )\n         self.assertEqual(\n             request.requestHeaders.getRawHeaders(b\"space\"),\n-            [b\"space  space\"],\n+            [b\"space space\"],\n         )\n         self.assertEqual(\n             request.requestHeaders.getRawHeaders(b\"spaces\"),\n-            [b\"spaces   spaces    spaces\"],\n+            [b\"spaces spaces spaces\"],\n         )\n         self.assertEqual(\n             request.requestHeaders.getRawHeaders(b\"tab\"),\n-            [b\"t \\ta \\tb\"],\n+            [b\"t a b\"],\n+        )\n+\n+    def test_headerStripWhitespace(self):\n+        \"\"\"\n+        Leading and trailing space and tab characters are stripped from\n+        headers. Other forms of whitespace are preserved.\n+\n+        See RFC 7230 section 3.2.3 and 3.2.4.\n+        \"\"\"\n+        processed = []\n+\n+        class MyRequest(http.Request):\n+            def process(self):\n+                processed.append(self)\n+                self.finish()\n+\n+        requestLines = [\n+            b\"GET / HTTP/1.0\",\n+            b\"spaces:   spaces were stripped   \",\n+            b\"tabs: \\t\\ttabs were stripped\\t\\t\",\n+            b\"spaces-and-tabs: \\t \\t spaces and tabs were stripped\\t \\t\",\n+            b\"line-tab:   \\v vertical tab was preserved\\v\\t\",\n+            b\"form-feed: \\f form feed was preserved \\f  \",\n+            b\"\",\n+            b\"\",\n+        ]\n+\n+        self.runRequest(b\"\\n\".join(requestLines), MyRequest, 0)\n+        [request] = processed\n+        # All leading and trailing whitespace is stripped from the\n+        # header-value.\n+        self.assertEqual(\n+            request.requestHeaders.getRawHeaders(b\"spaces\"),\n+            [b\"spaces were stripped\"],\n+        )\n+        self.assertEqual(\n+            request.requestHeaders.getRawHeaders(b\"tabs\"),\n+            [b\"tabs were stripped\"],\n+        )\n+        self.assertEqual(\n+            request.requestHeaders.getRawHeaders(b\"spaces-and-tabs\"),\n+            [b\"spaces and tabs were stripped\"],\n+        )\n+        self.assertEqual(\n+            request.requestHeaders.getRawHeaders(b\"line-tab\"),\n+            [b\"\\v vertical tab was preserved\\v\"],\n+        )\n+        self.assertEqual(\n+            request.requestHeaders.getRawHeaders(b\"form-feed\"),\n+            [b\"\\f form feed was preserved \\f\"],\n         )\n \n     def test_tooManyHeaders(self):\n@@ -2315,6 +2410,58 @@ def test_duplicateContentLengths(self):\n             ]\n         )\n \n+    def test_contentLengthMalformed(self):\n+        \"\"\"\n+        A request with a non-integer C{Content-Length} header fails with a 400\n+        response without calling L{Request.process}.\n+        \"\"\"\n+        self.assertRequestRejected(\n+            [\n+                b\"GET /a HTTP/1.1\",\n+                b\"Content-Length: MORE THAN NINE THOUSAND!\",\n+                b\"Host: host.invalid\",\n+                b\"\",\n+                b\"\",\n+                b\"x\" * 9001,\n+            ]\n+        )\n+\n+    def test_contentLengthTooPositive(self):\n+        \"\"\"\n+        A request with a C{Content-Length} header that begins with a L{+} fails\n+        with a 400 response without calling L{Request.process}.\n+\n+        This is a potential request smuggling vector: see GHSA-c2jg-hw38-jrqq.\n+        \"\"\"\n+        self.assertRequestRejected(\n+            [\n+                b\"GET /a HTTP/1.1\",\n+                b\"Content-Length: +100\",\n+                b\"Host: host.invalid\",\n+                b\"\",\n+                b\"\",\n+                b\"x\" * 100,\n+            ]\n+        )\n+\n+    def test_contentLengthNegative(self):\n+        \"\"\"\n+        A request with a C{Content-Length} header that is negative fails with\n+        a 400 response without calling L{Request.process}.\n+\n+        This is a potential request smuggling vector: see GHSA-c2jg-hw38-jrqq.\n+        \"\"\"\n+        self.assertRequestRejected(\n+            [\n+                b\"GET /a HTTP/1.1\",\n+                b\"Content-Length: -100\",\n+                b\"Host: host.invalid\",\n+                b\"\",\n+                b\"\",\n+                b\"x\" * 200,\n+            ]\n+        )\n+\n     def test_duplicateContentLengthsWithPipelinedRequests(self):\n         \"\"\"\n         Two pipelined requests, the first of which includes multiple\n@@ -4239,3 +4386,43 @@ def test_sendHeaderSanitizesLinearWhitespace(self):\n                 transport.value().splitlines(),\n                 [b\": \".join([sanitizedBytes, sanitizedBytes])],\n             )\n+\n+\n+class HexHelperTests(unittest.SynchronousTestCase):\n+    \"\"\"\n+    Test the L{http._hexint} and L{http._ishexdigits} helper functions.\n+    \"\"\"\n+\n+    badStrings = (b\"\", b\"0x1234\", b\"feds\", b\"-123\" b\"+123\")\n+\n+    def test_isHex(self):\n+        \"\"\"\n+        L{_ishexdigits()} returns L{True} for nonempy bytestrings containing\n+        hexadecimal digits.\n+        \"\"\"\n+        for s in (b\"10\", b\"abcdef\", b\"AB1234\", b\"fed\", b\"123467890\"):\n+            self.assertIs(True, http._ishexdigits(s))\n+\n+    def test_decodes(self):\n+        \"\"\"\n+        L{_hexint()} returns the integer equivalent of the input.\n+        \"\"\"\n+        self.assertEqual(10, http._hexint(b\"a\"))\n+        self.assertEqual(0x10, http._hexint(b\"10\"))\n+        self.assertEqual(0xABCD123, http._hexint(b\"abCD123\"))\n+\n+    def test_isNotHex(self):\n+        \"\"\"\n+        L{_ishexdigits()} returns L{False} for bytestrings that don't contain\n+        hexadecimal digits, including the empty string.\n+        \"\"\"\n+        for s in self.badStrings:\n+            self.assertIs(False, http._ishexdigits(s))\n+\n+    def test_decodeNotHex(self):\n+        \"\"\"\n+        L{_hexint()} raises L{ValueError} for bytestrings that can't\n+        be decoded.\n+        \"\"\"\n+        for s in self.badStrings:\n+            self.assertRaises(ValueError, http._hexint, s)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "68cfcb2ef8e0c7ba8f103390b2d81e2ccc4ee7f8",
            "date": "2025-01-10T16:54:09Z",
            "author_login": "itamarst"
          },
          {
            "sha": "3564bce98d8585d820b4220ce0b2c50eb697cd2d",
            "date": "2025-01-10T16:34:01Z",
            "author_login": "pythonspeed"
          },
          {
            "sha": "92683005f665c902218fdc021d264511fae5bbdf",
            "date": "2025-01-10T16:33:46Z",
            "author_login": "pythonspeed"
          },
          {
            "sha": "f021674af66bf960c89292bb05b5c3177f1d43e8",
            "date": "2025-01-10T16:25:37Z",
            "author_login": "pythonspeed"
          },
          {
            "sha": "5cec06e7e551a7612d0664f983675b7eb56bd0c4",
            "date": "2025-01-10T16:21:17Z",
            "author_login": "pythonspeed"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-444",
    "description": "Twisted is an event-based framework for internet applications, supporting Python 3.6+. Prior to version 22.4.0rc1, the Twisted Web HTTP 1.1 server, located in the `twisted.web.http` module, parsed several HTTP request constructs more leniently than permitted by RFC 7230. This non-conformant parsing can lead to desync if requests pass through multiple HTTP parsers, potentially resulting in HTTP request smuggling. Users who may be affected use Twisted Web's HTTP 1.1 server and/or proxy and also pass requests through a different HTTP server and/or proxy. The Twisted Web client is not affected. The HTTP 2.0 server uses a different parser, so it is not affected. The issue has been addressed in Twisted 22.4.0rc1. Two workarounds are available: Ensure any vulnerabilities in upstream proxies have been addressed, such as by upgrading them; or filter malformed requests by other means, such as configuration of an upstream proxy.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-04-04T18:15:07.933",
    "last_modified": "2024-11-25T18:12:24.673",
    "fix_date": "2022-04-04T09:30:28Z"
  },
  "references": [
    {
      "url": "https://github.com/twisted/twisted/commit/592217e951363d60e9cd99c5bbfd23d4615043ac",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/twisted/twisted/releases/tag/twisted-22.4.0rc1",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/twisted/twisted/security/advisories/GHSA-c2jg-hw38-jrqq",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00003.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7U6KYDTOLPICAVSR34G2WRYLFBD2YW5K/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GLKHA6WREIVAMBQD7KKWYHPHGGNKMAG6/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpujul2022.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/twisted/twisted/commit/592217e951363d60e9cd99c5bbfd23d4615043ac",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/twisted/twisted/releases/tag/twisted-22.4.0rc1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/twisted/twisted/security/advisories/GHSA-c2jg-hw38-jrqq",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00003.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7U6KYDTOLPICAVSR34G2WRYLFBD2YW5K/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GLKHA6WREIVAMBQD7KKWYHPHGGNKMAG6/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://www.oracle.com/security-alerts/cpujul2022.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:02.097097",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "twisted",
    "owner": "twisted",
    "created_at": "2011-07-01T20:40:42Z",
    "updated_at": "2025-01-14T01:49:44Z",
    "pushed_at": "2025-01-10T16:54:12Z",
    "size": 76428,
    "stars": 5674,
    "forks": 1182,
    "open_issues": 2764,
    "watchers": 5674,
    "has_security_policy": false,
    "default_branch": "trunk",
    "protected_branches": [],
    "languages": {
      "Python": 12636835,
      "GAP": 18052,
      "Batchfile": 3472,
      "Shell": 3244,
      "JavaScript": 752,
      "HTML": 270,
      "Gherkin": 140
    },
    "commit_activity": {
      "total_commits_last_year": 995,
      "avg_commits_per_week": 19.134615384615383,
      "days_active_last_year": 157
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:21:57.408414"
  }
}