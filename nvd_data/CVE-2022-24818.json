{
  "cve_id": "CVE-2022-24818",
  "github_data": {
    "repository": "geotools/geotools",
    "fix_commit": "4f70fa3234391dd0cda883a20ab0ec75688cba49",
    "related_commits": [
      "4f70fa3234391dd0cda883a20ab0ec75688cba49",
      "4f70fa3234391dd0cda883a20ab0ec75688cba49"
    ],
    "patch_url": "https://github.com/geotools/geotools/commit/4f70fa3234391dd0cda883a20ab0ec75688cba49.patch",
    "fix_commit_details": {
      "sha": "4f70fa3234391dd0cda883a20ab0ec75688cba49",
      "commit_date": "2022-04-06T12:14:20Z",
      "author": {
        "login": "aaime",
        "type": "User",
        "stats": {
          "total_commits": 3007,
          "average_weekly_commits": 4.562974203338391,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 546
        }
      },
      "commit_message": {
        "title": "[GEOT-7115] Streamline JNDI lookups",
        "length": 35,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 292,
        "additions": 185,
        "deletions": 107
      },
      "files": [
        {
          "filename": "docs/user/library/metadata/geotools.rst",
          "status": "modified",
          "additions": 10,
          "deletions": 4,
          "patch": "@@ -55,13 +55,19 @@ In rare cases, such as OSGi plug-in system, adding additional jars to the ``CLAS\n JNDI\n ^^^^\n \n-If you are working in a Java Enterprise Edition environment, and would like to configure GeoTools to look up services in a specific context use the following::\n+To configure GeoTools to look up services in a specific context use the following:\n+\n+.. code-block:: java\n   \n-  GeoTools.init( applicationContext ); // JNDI configuration\n+   GeoTools.init( context ); // JNDI configuration\n \n-GeoTools uses names of the format ``jdbc:EPSG`` internally these are adapted for use with your ``applicationContext`` using the ``GeoTools.fixName`` method::\n+For JNDI lookup GeooTools uses:\n \n-  String name = GeoTools.fixName(\"jdbc.EPSG\");\n+.. code-block:: java\n+\n+   DataSource dataSource = (DataSource) GeoTools.jndiLookup(name);\n+   \n+The ``jndiLookup(String)`` is to safe lookups by default. The default use of ``GeoTools.DEFAULT_JNDI_VALIDATOR`` ensures only no-schema and java schema lookups are allowed. To relax this policy you may supply your own approach using ``GeoTools.setJNDINameValidator(Predicate<String>)``.\n \n XML\n ^^^"
        },
        {
          "filename": "docs/user/welcome/upgrade.rst",
          "status": "modified",
          "additions": 22,
          "deletions": 0,
          "patch": "@@ -70,6 +70,28 @@ Fixing this required changes to multiple classes:\n GeoTools 25.x\n -------------\n \n+GeoTools\n+^^^^^^^^\n+\n+In GeoTools 25.7 ``GeoTools.getInitialContext().look(name)`` and related methods have been deprecated, with ``GeoTools.jndiLookup(name)``. We have also taken an opportunity to remove ``GeoTools.fixName( context, name )`` \n+\n+The use of ``GeoTools.jndiLookup(name)`` is subject to validation with the default ``GeoTools.DEFAULT_JNDI_VALIDATOR`` validator used limit name lookup.\n+\n+BEFORE\n+\n+.. code-block:: java\n+\n+   context = GeoTools.getInitialContext();\n+   String fixedName = GeoTools.fixName( context, name );\n+   return (DataSource) context.lookup(fixedName);\n+\n+AFTER\n+\n+.. code-block:: java\n+\n+   return (DataSource) GeoTools.jndiLookup(name);\n+\n+\n More variable arguments support in core classes\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n "
        },
        {
          "filename": "modules/library/jdbc/src/main/java/org/geotools/data/jdbc/datasource/JNDIDataSourceFactory.java",
          "status": "modified",
          "additions": 2,
          "deletions": 7,
          "patch": "@@ -64,7 +64,7 @@ public boolean canProcess(Map<String, ?> params) {\n     public DataSource createNewDataSource(Map<String, ?> params) throws IOException {\n         String refName = (String) JNDI_REFNAME.lookUp(params);\n         try {\n-            return (DataSource) GeoTools.getInitialContext().lookup(refName);\n+            return (DataSource) GeoTools.jndiLookup(refName);\n         } catch (Exception e) {\n             throw new DataSourceException(\"Could not find the specified data source in JNDI\", e);\n         }\n@@ -83,11 +83,6 @@ public Param[] getParametersInfo() {\n     /** Make sure a JNDI context is available */\n     @Override\n     public boolean isAvailable() {\n-        try {\n-            GeoTools.getInitialContext();\n-            return true;\n-        } catch (Exception e) {\n-            return false;\n-        }\n+        return GeoTools.isJNDIAvailable();\n     }\n }"
        },
        {
          "filename": "modules/library/jdbc/src/main/java/org/geotools/jdbc/JDBCJNDIDataStoreFactory.java",
          "status": "modified",
          "additions": 3,
          "deletions": 16,
          "patch": "@@ -21,7 +21,6 @@\n import java.util.Map;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n-import javax.naming.Context;\n import javax.naming.NamingException;\n import javax.sql.DataSource;\n import org.geotools.data.DataStore;\n@@ -90,23 +89,16 @@ protected DataSource createDataSource(Map<String, ?> params, SQLDialect dialect)\n         String jndiName = (String) JNDI_REFNAME.lookUp(params);\n         if (jndiName == null) throw new IOException(\"Missing \" + JNDI_REFNAME.description);\n \n-        Context ctx = null;\n         DataSource ds = null;\n \n         try {\n-            ctx = GeoTools.getInitialContext();\n-        } catch (NamingException e) {\n-            throw new RuntimeException(e);\n-        }\n-\n-        try {\n-            ds = (DataSource) ctx.lookup(jndiName);\n+            ds = (DataSource) GeoTools.jndiLookup(jndiName);\n         } catch (NamingException e1) {\n             // check if the user did not specify \"java:comp/env\"\n             // and this code is running in a J2EE environment\n             try {\n                 if (jndiName.startsWith(J2EERootContext) == false) {\n-                    ds = (DataSource) ctx.lookup(J2EERootContext + jndiName);\n+                    ds = (DataSource) GeoTools.jndiLookup(J2EERootContext + jndiName);\n                     // success --> issue a waring\n                     Logger.getLogger(this.getClass().getName())\n                             .log(\n@@ -135,12 +127,7 @@ protected DataSource createDataSource(Map<String, ?> params, SQLDialect dialect)\n      */\n     @Override\n     public boolean isAvailable() {\n-        try {\n-            GeoTools.getInitialContext();\n-            return true;\n-        } catch (NamingException e) {\n-            return false;\n-        }\n+        return GeoTools.isJNDIAvailable();\n     }\n \n     /** Override to omit all those parameters which define the creation of the connection. */"
        },
        {
          "filename": "modules/library/metadata/pom.xml",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -134,6 +134,11 @@\n       <version>${project.version}</version>\n       <scope>compile</scope>\n     </dependency>\n+    <dependency>\n+      <groupId>org.mockito</groupId>\n+      <artifactId>mockito-core</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n   </dependencies>\n \n   <build>"
        },
        {
          "filename": "modules/library/metadata/src/main/java/org/geotools/util/factory/GeoTools.java",
          "status": "modified",
          "additions": 92,
          "deletions": 19,
          "patch": "@@ -25,6 +25,8 @@\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Modifier;\n import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n import java.net.URL;\n import java.security.AccessController;\n import java.security.PrivilegedAction;\n@@ -38,6 +40,7 @@\n import java.util.Properties;\n import java.util.Set;\n import java.util.StringTokenizer;\n+import java.util.function.Predicate;\n import java.util.jar.Manifest;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n@@ -87,6 +90,7 @@\n  * @author Martin Desruisseaux\n  */\n public final class GeoTools {\n+\n     /** Properties about this geotools build */\n     private static final Properties PROPS;\n \n@@ -301,6 +305,29 @@ private static Properties loadProperites(String resource) {\n         BINDINGS = Collections.unmodifiableMap(bindings);\n     }\n \n+    /**\n+     * Default JNDI name validator, allows lookups only on names without a scheme, or using the\n+     * <code>java</code> scheme.\n+     */\n+    public static final Predicate<String> DEFAULT_JNDI_VALIDATOR =\n+            name -> {\n+                Logger LOGGER = Logging.getLogger(GeoTools.class);\n+                try {\n+                    URI uri = new URI(name);\n+                    boolean result = uri.getScheme() == null || uri.getScheme().equals(\"java\");\n+                    if (!result)\n+                        LOGGER.warning(\n+                                \"JNDI lookup allowed only on java scheme, or no scheme. Found instead: \"\n+                                        + name);\n+                    return result;\n+                } catch (URISyntaxException e) {\n+                    LOGGER.log(Level.WARNING, \"Invalid JNDI name provided\", e);\n+                    return false;\n+                }\n+            };\n+\n+    private static Predicate<String> jndiValidator = DEFAULT_JNDI_VALIDATOR;\n+\n     /**\n      * Binds the specified {@linkplain System#getProperty(String) system property} to the specified\n      * key. Only one key can be bound to a given system property. However the same key can be binded\n@@ -735,13 +762,13 @@ public static void init() {\n     /**\n      * Provides GeoTools with the JNDI context for resource lookup.\n      *\n-     * @param applicationContext The initial context to use.\n-     * @see #getInitialContext\n+     * @param initialContext The initial context to use for JNDI lookup\n+     * @see #jndiLookup(String)\n      * @since 2.4\n      */\n-    public static void init(final InitialContext applicationContext) {\n+    public static void init(final InitialContext initialContext) {\n         synchronized (GeoTools.class) {\n-            context = applicationContext;\n+            context = initialContext;\n         }\n         fireConfigurationChanged();\n     }\n@@ -934,30 +961,24 @@ static <T, D extends T> T instantiate(String className, Class<T> type, D default\n         }\n         return defaultValue;\n     }\n+\n     /**\n      * Returns the default initial context.\n      *\n-     * @param hints An optional set of hints, or {@code null} if none.\n      * @return The initial context (never {@code null}).\n      * @throws NamingException if the initial context can't be created.\n-     * @see #init(InitialContext)\n-     * @since 2.4\n-     * @deprecated hints isn't really used. Use the function without hints\n+     * @deprecated Please use {@link #jndiLookup(String)} instead, or provide an {@link\n+     *     InitialContext} to the {@link #init(InitialContext)} method and use it directly.\n      */\n     @Deprecated\n-    public static synchronized InitialContext getInitialContext(final Hints hints)\n-            throws NamingException {\n-\n-        return getInitialContext();\n+    public static synchronized InitialContext getInitialContext() throws NamingException {\n+        Logging.getLogger(GeoTools.class)\n+                .severe(\n+                        \"Please don't use GeoTools.getInitialContext(), perform lookups using GeoTools.jndiLookup(s) instead.\");\n+        return getJNDIContext();\n     }\n \n-    /**\n-     * Returns the default initial context.\n-     *\n-     * @return The initial context (never {@code null}).\n-     * @throws NamingException if the initial context can't be created.\n-     */\n-    public static synchronized InitialContext getInitialContext() throws NamingException {\n+    private static synchronized InitialContext getJNDIContext() throws NamingException {\n         if (context == null) {\n             try {\n                 context = new InitialContext();\n@@ -968,6 +989,45 @@ public static synchronized InitialContext getInitialContext() throws NamingExcep\n         return context;\n     }\n \n+    /**\n+     * Checks if JNDI is available, either because it was initialized, or because it was possible to\n+     * create one.\n+     */\n+    public static boolean isJNDIAvailable() {\n+        try {\n+            // see if we have a context, or can create one\n+            return getJNDIContext() != null;\n+        } catch (NamingException e) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Sets up a function that will be called to validate the JNDI lookups. If not set, the\n+     * DEFAULT_JNDI_VALIDATOR is used. The function may want to log the reason why a given name was\n+     * denied lookup.\n+     *\n+     * @param validator A function returning true if the lookups are meant to be performed, false\n+     *     otherwise.\n+     */\n+    public static void setJNDINameValidator(Predicate<String> validator) {\n+        jndiValidator = validator;\n+    }\n+\n+    /**\n+     * Looks up an object from the JNDI {@link InitialContext}. By default, it only allows lookups\n+     * with no scheme, or inside the <code>java</code> scheme. One can set up a custom name\n+     * validation routine using\n+     *\n+     * @param name\n+     * @return\n+     * @throws NamingException\n+     */\n+    public static Object jndiLookup(String name) throws NamingException {\n+        if (!jndiValidator.test(name)) return null;\n+        return getJNDIContext().lookup(name);\n+    }\n+\n     private static NamingException handleException(Exception e) {\n         final Logger LOGGER = Logging.getLogger(GeoTools.class);\n         final String propFileName = \"jndi.properties\";\n@@ -1064,7 +1124,11 @@ public static synchronized void clearInitialContext() throws NamingException {\n      * @return Name fixed up with {@link Context#composeName(String,String)}, or {@code null} if the\n      *     given name was null.\n      * @since 2.4\n+     * @deprecated With no replacement, GeoTools now uses JNDI lookups as instructed in {@link\n+     *     #jndiLookup(String)}, but does not put any object in the contex, the downstream\n+     *     application should do it if necessary instead.\n      */\n+    @Deprecated\n     public static String fixName(final String name) {\n         return fixName(null, name, null);\n     }\n@@ -1079,7 +1143,11 @@ public static String fixName(final String name) {\n      * @return Name fixed up with {@link Context#composeName(String,String)}, or {@code null} if the\n      *     given name was null.\n      * @since 2.4\n+     * @deprecated With no replacement, GeoTools now uses JNDI lookups as instructed in {@link *\n+     *     #jndiLookup(String)}, but does not put any object in the contex, the downstream *\n+     *     application should do it if necessary instead.\n      */\n+    @Deprecated\n     public static String fixName(final Context context, final String name) {\n         return (context != null) ? fixName(context, name, null) : name;\n     }\n@@ -1088,7 +1156,12 @@ public static String fixName(final Context context, final String name) {\n      * Implementation of {@code fixName} method. If the context is {@code null}, then the\n      * {@linkplain #getInitialContext GeoTools initial context} will be fetch only when first\n      * needed.\n+     *\n+     * @deprecated With no replacement, GeoTools now uses JNDI lookups as instructed in {@link *\n+     *     #jndiLookup(String)}, but does not put any object in the contex, the downstream *\n+     *     application should do it if necessary instead.\n      */\n+    @Deprecated\n     private static String fixName(Context context, final String name, final Hints hints) {\n         String fixed = null;\n         if (name != null) {"
        },
        {
          "filename": "modules/library/metadata/src/test/java/org/geotools/util/factory/FactoryRegistryTest.java",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -68,6 +68,7 @@ public void ensureHintsLoaded() {\n      * @param creator {@code true} if the registry should be an instance of {@link\n      *     org.geotools.util.factory.FactoryCreator}.\n      */\n+    @SuppressWarnings(\"PMD.UnusedPrivateMethod\") // PMD getting confused here?\n     private FactoryRegistry getRegistry(\n             final boolean creator,\n             final Factory factory1,"
        },
        {
          "filename": "modules/library/metadata/src/test/java/org/geotools/util/factory/GeoToolsTest.java",
          "status": "modified",
          "additions": 44,
          "deletions": 0,
          "patch": "@@ -29,11 +29,15 @@\n import java.util.Map;\n import java.util.jar.Manifest;\n import javax.media.jai.JAI;\n+import javax.naming.InitialContext;\n+import javax.naming.NamingException;\n import org.apache.commons.logging.LogFactory;\n import org.geotools.util.NullEntityResolver;\n import org.geotools.util.PreventLocalEntityResolver;\n import org.geotools.util.Version;\n+import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.Mockito;\n import org.opengis.filter.Filter;\n import org.xml.sax.EntityResolver;\n \n@@ -46,6 +50,13 @@\n  * @author Martin Desruisseaux\n  */\n public final class GeoToolsTest {\n+\n+    @Before\n+    public void clearJNDI() throws NamingException {\n+        GeoTools.clearInitialContext();\n+        GeoTools.setJNDINameValidator(GeoTools.DEFAULT_JNDI_VALIDATOR);\n+    }\n+\n     /** Makes sures that J2SE 1.4 assertions are enabled. */\n     @Test\n     public void testAssertionEnabled() {\n@@ -194,6 +205,7 @@ public void testSystemHints() {\n      * We avoid the tests that would require a real initial context.\n      */\n     @Test\n+    @SuppressWarnings(\"deprecation\")\n     public void testFixName() {\n         assertNull(GeoTools.fixName(null));\n         assertEquals(\"simpleName\", GeoTools.fixName(\"simpleName\"));\n@@ -262,4 +274,36 @@ public void testEntityResolver() {\n             Hints.scanSystemProperties();\n         }\n     }\n+\n+    @Test\n+    public void testLookupValidation() throws Exception {\n+        // setup mock initial context (need a JNDI provider otherwise, like simple-jndi)\n+        InitialContext ctx = Mockito.mock(InitialContext.class);\n+        Object test1 = new Object();\n+        String name1 = \"java://test1\";\n+        Mockito.when(ctx.lookup(name1)).thenReturn(test1);\n+        Object test2 = new Object();\n+        String name2 = \"ftp://test2\";\n+        Mockito.when(ctx.lookup(name2)).thenReturn(test2);\n+        Object test3 = new Object();\n+        String name3 = \"http://test3\";\n+        Mockito.when(ctx.lookup(name3)).thenReturn(test3);\n+        Object test4 = new Object();\n+        String name4 = \"java://test4{}\"; // invalid URI\n+        Mockito.when(ctx.lookup(name4)).thenReturn(test4);\n+\n+        // using default validator\n+        GeoTools.init(ctx);\n+        assertSame(test1, GeoTools.jndiLookup(name1));\n+        assertNull(GeoTools.jndiLookup(name2));\n+        assertNull(GeoTools.jndiLookup(name3));\n+        assertNull(GeoTools.jndiLookup(name4));\n+\n+        // setup an \"accept all\" filter\n+        GeoTools.setJNDINameValidator(name -> true);\n+        assertSame(test1, GeoTools.jndiLookup(name1));\n+        assertSame(test2, GeoTools.jndiLookup(name2));\n+        assertSame(test3, GeoTools.jndiLookup(name3));\n+        assertSame(test4, GeoTools.jndiLookup(name4));\n+    }\n }"
        },
        {
          "filename": "modules/library/referencing/src/main/java/org/geotools/referencing/factory/AbstractEpsgMediator.java",
          "status": "modified",
          "additions": 1,
          "deletions": 5,
          "patch": "@@ -20,7 +20,6 @@\n import java.sql.SQLException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n-import javax.naming.InitialContext;\n import javax.sql.DataSource;\n import org.geotools.metadata.iso.citation.Citations;\n import org.geotools.util.SimpleInternationalString;\n@@ -73,11 +72,8 @@ static DataSource lookupDataSource(Hints hints) throws FactoryException {\n             return (DataSource) hint;\n         } else if (hint instanceof String) {\n             String name = (String) hint;\n-            InitialContext context;\n             try {\n-                context = GeoTools.getInitialContext();\n-                // name = GeoTools.fixName( context, name );\n-                return (DataSource) context.lookup(name);\n+                return (DataSource) GeoTools.jndiLookup(name);\n             } catch (Exception e) {\n                 throw new FactoryException(\"EPSG_DATA_SOURCE '\" + name + \"' not found:\" + e, e);\n             }"
        },
        {
          "filename": "modules/library/referencing/src/main/java/org/geotools/referencing/factory/epsg/AbstractEpsgFactory.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -303,7 +303,7 @@ public AbstractEpsgFactory(final Hints userHints) throws FactoryException {\n             if (hint instanceof String) {\n                 String name = (String) hint;\n                 try {\n-                    dataSource = (DataSource) GeoTools.getInitialContext().lookup(name);\n+                    dataSource = (DataSource) GeoTools.jndiLookup(name);\n                 } catch (NamingException e) {\n                     throw new FactoryException(\"A EPSG_DATA_SOURCE hint is required:\" + e);\n                 }"
        },
        {
          "filename": "modules/library/referencing/src/main/java/org/geotools/referencing/factory/epsg/ThreadedEpsgFactory.java",
          "status": "modified",
          "additions": 3,
          "deletions": 54,
          "patch": "@@ -22,9 +22,7 @@\n import java.util.jar.Attributes.Name;\n import java.util.logging.Level;\n import java.util.logging.LogRecord;\n-import javax.naming.InitialContext;\n import javax.naming.NamingException;\n-import javax.naming.NoInitialContextException;\n import javax.sql.DataSource;\n import org.geotools.metadata.i18n.ErrorKeys;\n import org.geotools.metadata.i18n.Errors;\n@@ -91,28 +89,12 @@ public class ThreadedEpsgFactory extends DeferredAuthorityFactory\n      */\n     public static final String DATASOURCE_NAME = \"java:comp/env/jdbc/EPSG\";\n \n-    /**\n-     * {@code true} if automatic registration of {@link #datasourceName} is allowed. Set to {@code\n-     * false} for now because the registration has not been correctly tested in JEE environment.\n-     *\n-     * @todo Consider removing completly the code related to JNDI binding. In such case, this field\n-     *     and the {@link #registerInto} field would be removed.\n-     */\n-    private static final boolean ALLOW_REGISTRATION = false;\n-\n     /** The default priority level for this factory. */\n     protected static final int PRIORITY = MAXIMUM_PRIORITY - 10;\n \n     /** The factories to be given to the backing store. */\n     private final ReferencingFactoryContainer factories;\n \n-    /**\n-     * The context where to register {@link #datasource}, or {@code null} if it should not be\n-     * registered. This is used only as a way to pass \"hiden\" return value between {@link\n-     * #createDataSource()} and {@link #createBackingStore()}.\n-     */\n-    private transient InitialContext registerInto;\n-\n     /**\n      * The data source name. If it was not specified by the {@link Hints#EPSG_DATA_SOURCE\n      * EPSG_DATA_SOURCE} hint, then this is the {@value #DATASOURCE_NAME} value.\n@@ -301,15 +283,10 @@ public synchronized void setDataSource(final DataSource datasource) throws SQLEx\n      * @throws SQLException if an error occured while creating the data source.\n      */\n     protected DataSource createDataSource() throws SQLException {\n-        InitialContext context = null;\n         DataSource source = null;\n         try {\n-            context = GeoTools.getInitialContext();\n-            source = (DataSource) context.lookup(datasourceName);\n-        } catch (IllegalArgumentException | NoInitialContextException exception) {\n-            // Fall back on 'return null' below.\n-        } catch (NamingException exception) {\n-            registerInto = context;\n+            source = (DataSource) GeoTools.jndiLookup(datasourceName);\n+        } catch (IllegalArgumentException | NamingException exception) {\n             // Fall back on 'return null' below.\n         }\n         return source;\n@@ -380,14 +357,7 @@ private AbstractAuthorityFactory createBackingStore0() throws FactoryException,\n          * Try to gets the DataSource from JNDI. In case of success, it will be tried\n          * for a connection before any DataSource declared in META-INF/services/.\n          */\n-        DataSource source;\n-        final InitialContext context;\n-        try {\n-            source = createDataSource();\n-            context = registerInto;\n-        } finally {\n-            registerInto = null;\n-        }\n+        DataSource source = createDataSource();\n         if (source == null) {\n             throw new FactoryNotFoundException(Errors.format(ErrorKeys.NO_DATA_SOURCE));\n         }\n@@ -398,27 +368,6 @@ private AbstractAuthorityFactory createBackingStore0() throws FactoryException,\n         } finally {\n             datasource = null;\n         }\n-        /*\n-         * We now have a working connection. If a naming directory is running but didn't contains\n-         * the \"jdbc/EPSG\" entry, add it now. In such case, a message is prepared and logged.\n-         */\n-        LogRecord record;\n-        if (ALLOW_REGISTRATION && context != null) {\n-            try {\n-                context.bind(datasourceName, source);\n-                record =\n-                        Loggings.format(\n-                                Level.FINE,\n-                                LoggingKeys.CREATED_DATASOURCE_ENTRY_$1,\n-                                datasourceName);\n-            } catch (NamingException exception) {\n-                record =\n-                        Loggings.format(\n-                                Level.WARNING, LoggingKeys.CANT_BIND_DATASOURCE_$1, datasourceName);\n-                record.setThrown(exception);\n-            }\n-            log(record);\n-        }\n         this.datasource = source; // Stores the data source only after success.\n         return factory;\n     }"
        },
        {
          "filename": "modules/unsupported/postgis-raster/src/main/java/org/geotools/gce/pgraster/PGRasterConfig.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -117,7 +117,7 @@ static Document parse(File cfgfile) {\n         String jndi = first(db, \"jndi\").map(this::nodeValue).orElse(null);\n         if (jndi != null) {\n             try {\n-                dataSource = (DataSource) GeoTools.getInitialContext().lookup(jndi);\n+                dataSource = (DataSource) GeoTools.jndiLookup(jndi);\n             } catch (NamingException e) {\n                 throw new IllegalArgumentException(\"Error performing JNDI lookup for: \" + jndi, e);\n             }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 10,
        "max_directory_depth": 11
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8960ffbe83404ceb20dc3033d2cbf3ca394040a4",
            "date": "2025-01-14T08:31:34Z",
            "author_login": "mprins"
          },
          {
            "sha": "bb5be37204ef75a7f396653f87d87b0d327b1d0a",
            "date": "2025-01-13T22:06:04Z",
            "author_login": "roarbra"
          },
          {
            "sha": "7ef12ec97e199696034e71d06978d21f2e435c08",
            "date": "2025-01-13T09:11:54Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "024f733c6ec9d95391b3d0f9c83a3a6530923a00",
            "date": "2025-01-13T08:56:40Z",
            "author_login": "mprins"
          },
          {
            "sha": "d682bc5ed4c5ab2d7f50a232df279bdb4b8b4249",
            "date": "2025-01-07T10:17:23Z",
            "author_login": "mprins"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.2,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-20",
    "description": "GeoTools is an open source Java library that provides tools for geospatial data. The GeoTools library has a number of data sources that can perform unchecked JNDI lookups, which in turn can be used to perform class deserialization and result in arbitrary code execution. Similar to the Log4J case, the vulnerability can be triggered if the JNDI names are user-provided, but requires admin-level login to be triggered. The lookups are now restricted in GeoTools 26.4, GeoTools 25.6, and GeoTools 24.6. Users unable to upgrade should ensure that any downstream application should not allow usage of remotely provided JNDI strings.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-04-13T21:15:07.753",
    "last_modified": "2024-11-21T06:51:09.987",
    "fix_date": "2022-04-06T12:14:20Z"
  },
  "references": [
    {
      "url": "https://github.com/geotools/geotools/commit/4f70fa3234391dd0cda883a20ab0ec75688cba49",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/geotools/geotools/security/advisories/GHSA-jvh2-668r-g75x",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/geotools/geotools/commit/4f70fa3234391dd0cda883a20ab0ec75688cba49",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/geotools/geotools/security/advisories/GHSA-jvh2-668r-g75x",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:04.380287",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "geotools",
    "owner": "geotools",
    "created_at": "2011-11-10T23:22:12Z",
    "updated_at": "2025-01-14T08:31:40Z",
    "pushed_at": "2025-01-14T10:56:05Z",
    "size": 419761,
    "stars": 1751,
    "forks": 1157,
    "open_issues": 3,
    "watchers": 1751,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "10.x",
      "11.x",
      "12.x",
      "13.x",
      "14.x",
      "15.x",
      "16.x",
      "17.x",
      "18.x",
      "19.x",
      "20.x",
      "21.x",
      "22.x",
      "23.x",
      "24.x",
      "25.x",
      "26.x",
      "27.x",
      "28.x",
      "29.x",
      "30.x"
    ],
    "languages": {
      "Java": 94586016,
      "PLpgSQL": 3664254,
      "Scheme": 919603,
      "HTML": 178498,
      "CSS": 37887,
      "Shell": 19012,
      "Python": 15428,
      "Scala": 957,
      "nesC": 83
    },
    "commit_activity": {
      "total_commits_last_year": 222,
      "avg_commits_per_week": 4.269230769230769,
      "days_active_last_year": 137
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-2.1"
    },
    "collected_at": "2025-01-14T13:20:27.489856"
  }
}