{
  "cve_id": "CVE-2022-24829",
  "github_data": {
    "repository": "garden-io/garden",
    "fix_commit": "56051a5b50409227bc420910da88ed156a6e432b",
    "related_commits": [
      "56051a5b50409227bc420910da88ed156a6e432b",
      "56051a5b50409227bc420910da88ed156a6e432b"
    ],
    "patch_url": "https://github.com/garden-io/garden/commit/56051a5b50409227bc420910da88ed156a6e432b.patch",
    "fix_commit_details": {
      "sha": "56051a5b50409227bc420910da88ed156a6e432b",
      "commit_date": "2022-04-07T17:08:34Z",
      "author": {
        "login": "eysi09",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix(core): require auth key for server endpoints",
        "length": 48,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 222,
        "additions": 179,
        "deletions": 43
      },
      "files": [
        {
          "filename": "core/src/cli/cli.ts",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -435,7 +435,11 @@ ${renderCommands(commands)}\n               namespace: garden.namespace,\n             })\n \n-            command.server.showUrl(dashboardProcess?.serverHost || undefined)\n+            let url: string | undefined\n+            if (dashboardProcess) {\n+              url = `${dashboardProcess.serverHost}?key=${dashboardProcess.serverAuthKey}`\n+            }\n+            command.server.showUrl(url)\n           }\n         }\n "
        },
        {
          "filename": "core/src/constants.ts",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -71,6 +71,7 @@ export const gardenEnv = {\n   GARDEN_LOGGER_TYPE: env.get(\"GARDEN_LOGGER_TYPE\").required(false).asString(),\n   GARDEN_PROXY_DEFAULT_ADDRESS: env.get(\"GARDEN_PROXY_DEFAULT_ADDRESS\").required(false).asString(),\n   GARDEN_SERVER_PORT: env.get(\"GARDEN_SERVER_PORT\").required(false).asPortNumber(),\n+  GARDEN_SERVER_HOSTNAME: env.get(\"GARDEN_SERVER_HOSTNAME\").required(false).asUrlString(),\n   GARDEN_SKIP_TESTS: env.get(\"GARDEN_SKIP_TESTS\").required(false).default(\"\").asString(),\n   GARDEN_HARD_CONCURRENCY_LIMIT: env.get(\"GARDEN_HARD_CONCURRENCY_LIMIT\").required(false).default(50).asInt(),\n   GARDEN_TASK_CONCURRENCY_LIMIT: env.get(\"GARDEN_TASK_CONCURRENCY_LIMIT\").required(false).default(6).asInt(),"
        },
        {
          "filename": "core/src/events.ts",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -98,7 +98,7 @@ export interface Events extends LoggerEvents {\n \n   // Process events\n   serversUpdated: {\n-    servers: { host: string; command: string }[]\n+    servers: { host: string; command: string; serverAuthKey: string }[]\n   }\n   receivedToken: AuthTokenResponse\n "
        },
        {
          "filename": "core/src/server/dashboard-event-stream.ts",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -62,7 +62,11 @@ export class DashboardEventStream extends BufferedEventStream {\n       this.log.debug(`Updated list of running dashboard servers: ${servers.map((p) => p.serverHost).join(\", \")}`)\n \n       this.garden.events.emit(\"serversUpdated\", {\n-        servers: servers.map((p) => ({ command: p.command!, host: p.serverHost! })),\n+        servers: servers.map((p) => ({\n+          command: p.command!,\n+          host: p.serverHost!,\n+          serverAuthKey: p.serverAuthKey || \"\",\n+        })),\n       })\n     }\n "
        },
        {
          "filename": "core/src/server/server.ts",
          "status": "modified",
          "additions": 31,
          "deletions": 18,
          "patch": "@@ -79,15 +79,15 @@ export class GardenServer {\n     this.debugLog = this.log.placeholder({ level: LogLevel.debug, childEntriesInheritLevel: true })\n     this.garden = undefined\n     this.port = port\n-    this.authKey = randomString(64)\n+    this.authKey = randomString(24)\n     this.incomingEvents = new EventBus()\n     this.activePersistentRequests = {}\n \n     this.serversUpdatedListener = ({ servers }) => {\n       // Update status log line with new `garden dashboard` server, if any\n-      for (const { host, command } of servers) {\n+      for (const { host, command, serverAuthKey } of servers) {\n         if (command === \"dashboard\") {\n-          this.showUrl(host)\n+          this.showUrl(`${host}?key=${serverAuthKey}`)\n           return\n         }\n       }\n@@ -104,13 +104,15 @@ export class GardenServer {\n \n     this.app = await this.createApp()\n \n+    const hostname = gardenEnv.GARDEN_SERVER_HOSTNAME || \"localhost\"\n+\n     if (this.port) {\n-      this.server = this.app.listen(this.port)\n+      this.server = this.app.listen(this.port, hostname)\n     } else {\n       do {\n         try {\n           this.port = await getPort({ port: defaultWatchServerPort })\n-          this.server = this.app.listen(this.port)\n+          this.server = this.app.listen(this.port, hostname)\n         } catch {}\n       } while (!this.server)\n     }\n@@ -119,10 +121,14 @@ export class GardenServer {\n     this.statusLog = this.log.placeholder()\n   }\n \n-  getUrl() {\n+  getBaseUrl() {\n     return `http://localhost:${this.port}`\n   }\n \n+  getUrl() {\n+    return `${this.getBaseUrl()}?key=${this.authKey}`\n+  }\n+\n   showUrl(url?: string) {\n     this.statusLog.setState({\n       emoji: \"sunflower\",\n@@ -156,6 +162,16 @@ export class GardenServer {\n     const app = websockify(new Koa())\n     const http = new Router()\n \n+    http.use((ctx, next) => {\n+      const authToken = ctx.header[authTokenHeader] || ctx.query.key\n+\n+      if (authToken !== this.authKey) {\n+        ctx.throw(401, `Unauthorized request`)\n+        return\n+      }\n+      return next()\n+    })\n+\n     /**\n      * HTTP API endpoint (POST /api)\n      *\n@@ -164,7 +180,6 @@ export class GardenServer {\n      * means we can keep a consistent format across mechanisms.\n      */\n     http.post(\"/api\", async (ctx) => {\n-      // TODO: require auth key here from 0.13.0 onwards\n       if (!this.garden) {\n         return this.notReady(ctx)\n       }\n@@ -239,15 +254,7 @@ export class GardenServer {\n      * The API matches that of the Garden Cloud /events endpoint.\n      */\n     http.post(\"/events\", async (ctx) => {\n-      const authHeader = ctx.header[authTokenHeader]\n-\n-      if (authHeader !== this.authKey) {\n-        ctx.status = 401\n-        return\n-      }\n-\n       // TODO: validate the input\n-\n       const batch = ctx.request.body as ApiEventBatch\n       this.debugLog.debug(`Received ${batch.events.length} events from session ${batch.sessionId}`)\n \n@@ -258,6 +265,7 @@ export class GardenServer {\n     })\n \n     app.use(bodyParser())\n+\n     app.use(http.routes())\n     app.use(http.allowedMethods())\n \n@@ -277,7 +285,7 @@ export class GardenServer {\n     return app\n   }\n \n-  private notReady(ctx: Router.IRouterContext) {\n+  private notReady(ctx: Router.IRouterContext | Koa.ParameterizedContext) {\n     ctx.status = 503\n     ctx.response.body = notReadyMessage\n   }\n@@ -297,8 +305,6 @@ export class GardenServer {\n \n       const connId = uuidv4()\n \n-      // TODO: require auth key on connections here, from 0.13.0 onwards\n-\n       // The typing for koa-websocket isn't working currently\n       const websocket: Koa.Context[\"ws\"] = ctx[\"websocket\"]\n \n@@ -318,6 +324,13 @@ export class GardenServer {\n         return send(\"error\", { message, requestId })\n       }\n \n+      // TODO: Only allow auth key authentication\n+      if (ctx.query.sessionId !== `${this.garden.sessionId}` && ctx.query.key !== `${this.authKey}`) {\n+        error(`401 Unauthorized`)\n+        websocket.terminate()\n+        return\n+      }\n+\n       // Set up heartbeat to detect dead connections\n       let isAlive = true\n "
        },
        {
          "filename": "core/test/unit/src/cli/cli.ts",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -420,7 +420,7 @@ describe(\"cli\", () => {\n         command: \"dashboard\",\n         sessionId: serverGarden.sessionId,\n         persistent: true,\n-        serverHost: server.getUrl(),\n+        serverHost: server.getBaseUrl(),\n         serverAuthKey: server.authKey,\n         projectRoot: serverGarden.projectRoot,\n         projectName: serverGarden.projectName,\n@@ -527,7 +527,7 @@ describe(\"cli\", () => {\n         command: \"dashboard\",\n         sessionId: serverGarden.sessionId,\n         persistent: true,\n-        serverHost: server.getUrl(),\n+        serverHost: server.getBaseUrl(),\n         serverAuthKey: server.authKey,\n         projectRoot: serverGarden.projectRoot,\n         projectName: serverGarden.projectName,"
        },
        {
          "filename": "core/test/unit/src/server/dashboard-event-stream.ts",
          "status": "modified",
          "additions": 5,
          "deletions": 3,
          "patch": "@@ -70,8 +70,8 @@ describe(\"DashboardEventStream\", () => {\n       streamEvents: true,\n       streamLogEntries: true,\n       targets: [\n-        { host: serverA.getUrl(), clientAuthToken: serverA.authKey, enterprise: false },\n-        { host: serverB.getUrl(), clientAuthToken: serverB.authKey, enterprise: false },\n+        { host: serverA.getBaseUrl(), clientAuthToken: serverA.authKey, enterprise: false },\n+        { host: serverB.getBaseUrl(), clientAuthToken: serverB.authKey, enterprise: false },\n       ],\n     })\n \n@@ -193,7 +193,9 @@ describe(\"DashboardEventStream\", () => {\n       await record.setCommand(values)\n       await streamer.updateTargets()\n \n-      garden.events.expectEvent(\"serversUpdated\", { servers: [{ host: values.serverHost, command: \"dashboard\" }] })\n+      garden.events.expectEvent(\"serversUpdated\", {\n+        servers: [{ host: values.serverHost, command: \"dashboard\", serverAuthKey: \"foo\" }],\n+      })\n     })\n \n     it(\"ignores servers matching ignoreHost\", async () => {"
        },
        {
          "filename": "core/test/unit/src/server/server.ts",
          "status": "modified",
          "additions": 89,
          "deletions": 10,
          "patch": "@@ -58,47 +58,83 @@ describe(\"GardenServer\", () => {\n   it(\"should update dashboard URL with new one if another is started\", async () => {\n     gardenServer.showUrl(\"http://foo\")\n     garden.events.emit(\"serversUpdated\", {\n-      servers: [{ host: \"http://localhost:9800\", command: \"dashboard\" }],\n+      servers: [{ host: \"http://localhost:9800\", command: \"dashboard\", serverAuthKey: \"foo\" }],\n     })\n     const line = gardenServer[\"statusLog\"]\n     await sleep(1) // This is enough to let go of the control loop\n     const status = stripAnsi(line.getLatestMessage().msg || \"\")\n-    expect(status).to.equal(`Garden dashboard running at http://localhost:9800`)\n+    expect(status).to.equal(`Garden dashboard running at http://localhost:9800?key=foo`)\n   })\n \n   describe(\"GET /\", () => {\n     it(\"should return the dashboard index page\", async () => {\n-      await request(server).get(\"/\").expect(200)\n+      await request(server)\n+        .get(\"/\")\n+        .set({ [authTokenHeader]: gardenServer.authKey })\n+        .expect(200)\n     })\n   })\n \n   describe(\"POST /api\", () => {\n+    it(\"returns 401 if missing auth header\", async () => {\n+      await request(server).post(\"/api\").send({}).expect(401)\n+    })\n+\n+    it(\"returns 401 if auth header doesn't match auth key\", async () => {\n+      await request(server)\n+        .post(\"/api\")\n+        .set({ [authTokenHeader]: \"foo\" })\n+        .send({})\n+        .expect(401)\n+    })\n+\n     it(\"should 400 on non-JSON body\", async () => {\n-      await request(server).post(\"/api\").send(\"foo\").expect(400)\n+      await request(server)\n+        .post(\"/api\")\n+        .set({ [authTokenHeader]: gardenServer.authKey })\n+        .send(\"foo\")\n+        .expect(400)\n     })\n \n     it(\"should 400 on invalid payload\", async () => {\n-      await request(server).post(\"/api\").send({ foo: \"bar\" }).expect(400)\n+      await request(server)\n+        .post(\"/api\")\n+        .set({ [authTokenHeader]: gardenServer.authKey })\n+        .send({ foo: \"bar\" })\n+        .expect(400)\n     })\n \n     it(\"should 404 on invalid command\", async () => {\n-      await request(server).post(\"/api\").send({ command: \"foo\" }).expect(404)\n+      await request(server)\n+        .post(\"/api\")\n+        .set({ [authTokenHeader]: gardenServer.authKey })\n+        .send({ command: \"foo\" })\n+        .expect(404)\n     })\n \n     it(\"should 503 when Garden instance is not set\", async () => {\n       gardenServer[\"garden\"] = undefined\n-      await request(server).post(\"/api\").send({ command: \"get.config\" }).expect(503)\n+      await request(server)\n+        .post(\"/api\")\n+        .set({ [authTokenHeader]: gardenServer.authKey })\n+        .send({ command: \"get.config\" })\n+        .expect(503)\n     })\n \n     it(\"should execute a command and return its results\", async () => {\n-      const res = await request(server).post(\"/api\").send({ command: \"get.config\" }).expect(200)\n+      const res = await request(server)\n+        .post(\"/api\")\n+        .set({ [authTokenHeader]: gardenServer.authKey })\n+        .send({ command: \"get.config\" })\n+        .expect(200)\n       const config = await garden.dumpConfig({ log: garden.log })\n       expect(res.body.result).to.eql(deepOmitUndefined(config))\n     })\n \n     it(\"should correctly map arguments and options to commands\", async () => {\n       const res = await request(server)\n         .post(\"/api\")\n+        .set({ [authTokenHeader]: gardenServer.authKey })\n         .send({\n           command: \"build\",\n           parameters: {\n@@ -119,8 +155,23 @@ describe(\"GardenServer\", () => {\n   })\n \n   describe(\"/dashboardPages\", () => {\n+    it(\"returns 401 if missing auth header\", async () => {\n+      await request(server).get(\"/dashboardPages/test-plugin/test\").expect(401)\n+    })\n+\n+    it(\"returns 401 if auth header doesn't match auth key\", async () => {\n+      await request(server)\n+        .get(\"/dashboardPages/test-plugin/test\")\n+        .set({ [authTokenHeader]: \"foo\" })\n+        .send({})\n+        .expect(401)\n+    })\n+\n     it(\"should resolve the URL for the given dashboard page and redirect\", async () => {\n-      const res = await request(server).get(\"/dashboardPages/test-plugin/test\").expect(302)\n+      const res = await request(server)\n+        .get(\"/dashboardPages/test-plugin/test\")\n+        .set({ [authTokenHeader]: gardenServer.authKey })\n+        .expect(302)\n \n       expect(res.header.location).to.equal(\"http://localhost:12345/test\")\n     })\n@@ -162,7 +213,7 @@ describe(\"GardenServer\", () => {\n     let ws: WebSocket\n \n     beforeEach((done) => {\n-      ws = new WebSocket(`ws://localhost:${port}/ws`)\n+      ws = new WebSocket(`ws://localhost:${port}/ws?sessionId=${garden.sessionId}`)\n       ws.on(\"open\", () => {\n         done()\n       })\n@@ -177,6 +228,34 @@ describe(\"GardenServer\", () => {\n       ws.on(\"message\", (msg) => cb(JSON.parse(msg.toString())))\n     }\n \n+    it(\"terminates the connection if auth query params are missing\", (done) => {\n+      const badWs = new WebSocket(`ws://localhost:${port}/ws`)\n+      badWs.on(\"close\", () => {\n+        done()\n+      })\n+    })\n+\n+    it(\"terminates the connection if key doesn't match and sessionId is missing\", (done) => {\n+      const badWs = new WebSocket(`ws://localhost:${port}/ws?key=foo`)\n+      badWs.on(\"close\", () => {\n+        done()\n+      })\n+    })\n+\n+    it(\"terminates the connection if sessionId doesn't match and key is missing\", (done) => {\n+      const badWs = new WebSocket(`ws://localhost:${port}/ws?sessionId=foo`)\n+      badWs.on(\"close\", () => {\n+        done()\n+      })\n+    })\n+\n+    it(\"terminates the connection if both sessionId and key are bad\", (done) => {\n+      const badWs = new WebSocket(`ws://localhost:${port}/ws?sessionId=foo&key=bar`)\n+      badWs.on(\"close\", () => {\n+        done()\n+      })\n+    })\n+\n     it(\"should emit events from the Garden event bus\", (done) => {\n       onMessage((req) => {\n         expect(req).to.eql({ type: \"event\", name: \"_test\", payload: \"foo\" })"
        },
        {
          "filename": "dashboard/src/api/actions.ts",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -36,7 +36,7 @@ import {\n   FetchTaskResultParams,\n   FetchTestResultParams,\n } from \"./api\"\n-import { getTestKey } from \"../util/helpers\"\n+import { getAuthKey, getTestKey } from \"../util/helpers\"\n import { ProviderMap } from \"@garden-io/core/build/src/config/provider\"\n import { DashboardPage } from \"@garden-io/core/build/src/types/plugin/provider/getDashboardPage\"\n \n@@ -113,7 +113,7 @@ function processConfigInitResult(entities: Entities, config: ConfigDump) {\n         path: `/provider/${provider.name}/${page.name}`,\n         description: page.description + ` (from provider ${provider.name})`,\n         // Use static URL if provided, otherwise we'll request a redirect from this API endpoint\n-        url: page.url || `/dashboardPages/${provider.name}/${page.name}`,\n+        url: page.url || `/dashboardPages/${provider.name}/${page.name}?key=${getAuthKey()}`,\n       }))\n     })\n "
        },
        {
          "filename": "dashboard/src/api/api.ts",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -15,6 +15,7 @@ import { ServiceLogEntry } from \"@garden-io/core/build/src/types/plugin/service/\n import { CommandResult } from \"@garden-io/core/build/src/commands/base\"\n import { ConfigDump } from \"@garden-io/core/build/src/garden\"\n import { StatusCommandResult } from \"@garden-io/core/build/src/commands/get/get-status\"\n+import { getAuthKey } from \"../util/helpers\"\n \n export interface ApiRequest {\n   command: string\n@@ -64,7 +65,8 @@ export async function fetchTestResult({ name, moduleName }: FetchTestResultParam\n async function apiCommand<T>(command: string, parameters: {} = {}): Promise<T> {\n   const url = \"/api\"\n   const method = \"POST\"\n-  const headers = { \"Content-Type\": \"application/json\" }\n+  const headers = { \"Content-Type\": \"application/json\", \"x-access-auth-token\": getAuthKey() }\n+\n   const data: ApiRequest = { command, parameters }\n \n   const res = await axios.request<CommandResult<T>>({ url, method, headers, data })"
        },
        {
          "filename": "dashboard/src/components/menu.tsx",
          "status": "modified",
          "additions": 25,
          "deletions": 3,
          "patch": "@@ -9,13 +9,14 @@\n import { css } from \"emotion\"\n import styled from \"@emotion/styled\"\n import React from \"react\"\n-import { NavLink as ReactRouterNavLink } from \"react-router-dom\"\n+import { NavLink as ReactRouterNavLink, NavLinkProps as ReactRouterNavLinkProps } from \"react-router-dom\"\n \n import logo from \"../assets/logo.png\"\n \n import { colors } from \"../styles/variables\"\n import { useUiState } from \"../hooks\"\n import { Page } from \"../contexts/api\"\n+import { getAuthKey } from \"../util/helpers\"\n \n interface Props {\n   pages: Page[]\n@@ -46,7 +47,28 @@ const Nav = styled.nav`\n   width: 100%;\n `\n \n-const NavLink = (props: any) => <ReactRouterNavLink {...props} activeStyle={{ color: colors.gardenGreenDark }} />\n+type NavLinkProps = Omit<ReactRouterNavLinkProps, \"to\"> & {\n+  to: {\n+    pathname: string\n+    search?: string\n+    hash?: string\n+    state?: any\n+  }\n+}\n+\n+/**\n+ * Helper class for ensuring that the auth key param is set on routes.\n+ */\n+const NavLink = (props: NavLinkProps) => {\n+  const urlParams = new URLSearchParams(props.to.search)\n+  urlParams.set(\"key\", getAuthKey() || \"\")\n+  const to = {\n+    ...props.to,\n+    search: urlParams.toString(),\n+  }\n+\n+  return <ReactRouterNavLink {...props} to={to} activeStyle={{ color: colors.gardenGreenDark }} />\n+}\n \n const A = styled.a(linkStyle)\n const Link = styled(NavLink)(linkStyle)\n@@ -77,7 +99,7 @@ const Menu: React.FC<Props> = ({ pages }) => {\n     <>\n       <MenuContainer visible={isMenuOpen}>\n         <Nav>\n-          <NavLink to=\"/\">\n+          <NavLink to={{ pathname: \"/\" }}>\n             <Logo src={logo} alt=\"Home\" />\n           </NavLink>\n           {pages.map((page) => ("
        },
        {
          "filename": "dashboard/src/hooks.ts",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -11,6 +11,7 @@ import { useState, useEffect, useCallback, useRef, useContext } from \"react\"\n import getApiUrl from \"./api/get-api-url\"\n import { ApiContext } from \"./contexts/api\"\n import { UiContext } from \"./contexts/ui\"\n+import { getAuthKey } from \"./util/helpers\"\n \n const wsRetryInterval = 2000\n \n@@ -36,7 +37,7 @@ export const useWebsocket = (\n \n   const initWs = () => {\n     const url = getApiUrl()\n-    const ws = new WebSocket(`ws://${url}/ws`)\n+    const ws = new WebSocket(`ws://${url}/ws?key=${getAuthKey()}`)\n     ws.onopen = (_event) => {\n       if (wsStateRef.current === \"closed\") {\n         handleWsOpened()"
        },
        {
          "filename": "dashboard/src/util/helpers.ts",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -96,3 +96,11 @@ export function getTextWidth(text: string, font: string) {\n   const metrics = context.measureText(text)\n   return metrics.width\n }\n+\n+/**\n+ * Returns the auth key from the current page's URL params.\n+ */\n+export function getAuthKey() {\n+  const urlParams = new URLSearchParams(window.location.search)\n+  return urlParams.get(\"key\")\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 9,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "fd0e7246cf3aaf8189ae28379fbefc4a3689e36f",
            "date": "2025-01-14T14:52:12Z",
            "author_login": "vvagaytsev"
          },
          {
            "sha": "bc08d0695298b2aa6508f769d69cd1765cb45003",
            "date": "2025-01-14T14:00:25Z",
            "author_login": "stefreak"
          },
          {
            "sha": "fa20266059f20a9d1d542f642e8df789b56731fd",
            "date": "2025-01-14T13:50:50Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "add0043406a03d017e8ba8524c202863adb80cf4",
            "date": "2025-01-14T13:50:40Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "f4ba09231ec983a8f2918e33ccb407a0bf712cc4",
            "date": "2025-01-14T13:50:12Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-306",
    "description": "Garden is an automation platform for Kubernetes development and testing. In versions prior to 0.12.39 multiple endpoints did not require authentication. In some operating modes this allows for an attacker to gain access to the application erroneously. The configuration is leaked through the /api endpoint on the local server that is responsible for serving the Garden dashboard. At the moment, this server is accessible to 0.0.0.0 which makes it accessible to anyone on the same network (or anyone on the internet if they are on a public, static IP). This may lead to the ability to compromise credentials, secrets or environment variables. Users are advised to upgrade to version 0.12.39 as soon as possible. Users unable to upgrade should use a firewall blocking access to port 9777 from all untrusted network machines.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-04-11T20:15:20.277",
    "last_modified": "2024-11-21T06:51:11.450",
    "fix_date": "2022-04-07T17:08:34Z"
  },
  "references": [
    {
      "url": "https://github.com/garden-io/garden/commit/56051a5b50409227bc420910da88ed156a6e432b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/garden-io/garden/security/advisories/GHSA-f5f3-qrqw-2vqf",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/garden-io/garden/commit/56051a5b50409227bc420910da88ed156a6e432b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/garden-io/garden/security/advisories/GHSA-f5f3-qrqw-2vqf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:04.370530",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "garden",
    "owner": "garden-io",
    "created_at": "2017-12-03T02:10:59Z",
    "updated_at": "2025-01-14T15:13:55Z",
    "pushed_at": "2025-01-14T15:42:25Z",
    "size": 128819,
    "stars": 3409,
    "forks": 273,
    "open_issues": 220,
    "watchers": 3409,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "0.12",
      "0.13"
    ],
    "languages": {
      "TypeScript": 5913720,
      "JavaScript": 58098,
      "PEG.js": 36055,
      "Shell": 29837,
      "Dockerfile": 27378,
      "Rust": 22761,
      "Mustache": 11507,
      "Java": 9467,
      "HCL": 7104,
      "Vue": 6840,
      "Python": 6175,
      "PowerShell": 5764,
      "HTML": 4589,
      "CSS": 3598,
      "Ruby": 2042,
      "Go": 1366,
      "Nix": 760,
      "Jinja": 485,
      "Open Policy Agent": 328
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mpl-2.0"
    },
    "collected_at": "2025-01-14T19:15:19.085275"
  }
}