{
  "cve_id": "CVE-2022-24841",
  "github_data": {
    "repository": "fleetdm/fleet",
    "fix_commit": "da171d3b8d149c30b8307723cbe6b6e8847cb30c",
    "related_commits": [
      "da171d3b8d149c30b8307723cbe6b6e8847cb30c",
      "da171d3b8d149c30b8307723cbe6b6e8847cb30c"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "da171d3b8d149c30b8307723cbe6b6e8847cb30c",
      "commit_date": "2022-04-18T17:27:30Z",
      "author": {
        "login": "lucasmrod",
        "type": "User",
        "stats": {
          "total_commits": 613,
          "average_weekly_commits": 1.3775280898876405,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 154
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-pr2g-j78h-84cr",
        "length": 2564,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 1691,
        "additions": 1339,
        "deletions": 352
      },
      "files": [
        {
          "filename": "changes/activities-rbac",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+* Restrict non-global user from access to activities\n\\ No newline at end of file"
        },
        {
          "filename": "changes/issue-GHSA-pr2g-j78h-84cr",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+* Fix access control issues with \"user\" endpoints.\n+* Fix access control issues with \"pack\" endpoints.\n+* Fix access control issues with \"software\" endpoints."
        },
        {
          "filename": "cypress/integration/free/maintainer.spec.ts",
          "status": "modified",
          "additions": 8,
          "deletions": 28,
          "patch": "@@ -189,31 +189,7 @@ describe(\n     describe(\"Manage software page\", () => {\n       beforeEach(() => cy.visit(\"/software/manage\"));\n       it(\"should restrict global maintainer from 'Manage automations' button\", () => {\n-        it(\"hides manages software automations when all teams selected\", () => {\n-          cy.getAttached(\".manage-software-page__header-wrap\").within(() => {\n-            cy.getAttached(\".Select\").within(() => {\n-              cy.findByText(/all teams/i).should(\"exist\");\n-            });\n-            cy.getAttached(\".manage-software-page__header-wrap\").within(() => {\n-              cy.findByRole(\"button\", {\n-                name: /manage automations/i,\n-              }).should(\"not.exist\");\n-            });\n-          });\n-        });\n-        it(\"hides manage automations button when all teams not selected\", () => {\n-          cy.getAttached(\".manage-software-page__header-wrap\").within(() => {\n-            cy.getAttached(\".Select\").within(() => {\n-              cy.getAttached(\".Select-control\").click();\n-              cy.getAttached(\".Select-menu-outer\").within(() => {\n-                cy.findByText(/apples/i).should(\"exist\");\n-              });\n-              cy.findByRole(\"button\", {\n-                name: /manage automations/i,\n-              }).should(\"not.exist\");\n-            });\n-          });\n-        });\n+        cy.findByText(/manage automations/).should(\"not.exist\");\n       });\n     });\n     describe(\"Query pages\", () => {\n@@ -274,9 +250,13 @@ describe(\n         cy.loginWithCySession(\"mary@organization.com\", \"user123#\");\n         cy.visit(\"/policies/manage\");\n       });\n-      it(\"allows maintainer to manage automations\", () => {\n-        cy.findByRole(\"button\", { name: /manage automations/i }).click();\n-        cy.findByRole(\"button\", { name: /cancel/i }).click();\n+      it(\"hides manage automations from maintainer\", () => {\n+        cy.getAttached(\".button-wrap\").within(() => {\n+          cy.findByRole(\"button\", { name: /add a policy/i }).should(\"exist\");\n+          cy.findByRole(\"button\", { name: /manage automations/i }).should(\n+            \"not.exist\"\n+          );\n+        });\n       });\n       it(\"allows maintainer to add a policy\", () => {\n         cy.findByRole(\"button\", { name: /add a policy/i }).click();"
        },
        {
          "filename": "cypress/integration/free/observer.spec.ts",
          "status": "modified",
          "additions": 2,
          "deletions": 4,
          "patch": "@@ -209,12 +209,10 @@ describe(\"Free tier - Observer user\", () => {\n       cy.visit(\"/policies/manage\");\n     });\n     it(\"hides manage automations button\", () => {\n-      cy.findByRole(\"button\", { name: /manage automations/i }).should(\n-        \"not.exist\"\n-      );\n+      cy.findByText(/manage automations/i).should(\"not.exist\");\n     });\n     it(\"hides add a policy button\", () => {\n-      cy.findByRole(\"button\", { name: /add a policy/i }).should(\"not.exist\");\n+      cy.findByText(/add a policy/).should(\"not.exist\");\n     });\n     it(\"hides run, edit, or delete a policy\", () => {\n       cy.getAttached(\"tbody\").within(() => {"
        },
        {
          "filename": "cypress/integration/premium/admin.spec.ts",
          "status": "modified",
          "additions": 21,
          "deletions": 0,
          "patch": "@@ -564,6 +564,27 @@ describe(\"Premium tier - Global Admin user\", () => {\n       });\n       cy.findByText(/successfully updated policy automations/i).should(\"exist\");\n     });\n+    it(\"allows global admin to automate a team policy\", () => {\n+      cy.visit(\"/policies/manage\");\n+      cy.getAttached(\".Select-control\").within(() => {\n+        cy.findByText(/all teams/i).click();\n+      });\n+      cy.getAttached(\".Select-menu\")\n+        .contains(/apples/i)\n+        .click();\n+      cy.getAttached(\".button-wrap\")\n+        .findByRole(\"button\", { name: /manage automations/i })\n+        .click();\n+      cy.getAttached(\".manage-automations-modal\").within(() => {\n+        cy.getAttached(\".fleet-slider\").click();\n+        cy.getAttached(\".fleet-checkbox__input\").check({ force: true });\n+        cy.getAttached(\"#webhook-url\")\n+          .clear()\n+          .type(\"https://example.com/global_admin\");\n+        cy.findByText(/save/i).click();\n+      });\n+      cy.findByText(/successfully updated policy automations/i).should(\"exist\");\n+    });\n     it(\"allows global admin to delete a team policy\", () => {\n       cy.visit(\"/policies/manage\");\n       cy.getAttached(\".Select-control\").within(() => {"
        },
        {
          "filename": "cypress/integration/premium/maintainer.spec.ts",
          "status": "modified",
          "additions": 4,
          "deletions": 31,
          "patch": "@@ -201,32 +201,8 @@ describe(\"Premium tier - Maintainer user\", () => {\n     });\n     describe(\"Manage software page\", () => {\n       beforeEach(() => cy.visit(\"/software/manage\"));\n-      it(\"should restrict global maintainer from 'Manage automations' button\", () => {\n-        it(\"hides manages software automations when all teams selected\", () => {\n-          cy.getAttached(\".manage-software-page__header-wrap\").within(() => {\n-            cy.getAttached(\".Select\").within(() => {\n-              cy.findByText(/all teams/i).should(\"exist\");\n-            });\n-            cy.getAttached(\".manage-software-page__header-wrap\").within(() => {\n-              cy.findByRole(\"button\", {\n-                name: /manage automations/i,\n-              }).should(\"not.exist\");\n-            });\n-          });\n-        });\n-        it(\"hides manage automations button when all teams not selected\", () => {\n-          cy.getAttached(\".manage-software-page__header-wrap\").within(() => {\n-            cy.getAttached(\".Select\").within(() => {\n-              cy.getAttached(\".Select-control\").click();\n-              cy.getAttached(\".Select-menu-outer\").within(() => {\n-                cy.findByText(/apples/i).should(\"exist\");\n-              });\n-              cy.findByRole(\"button\", {\n-                name: /manage automations/i,\n-              }).should(\"not.exist\");\n-            });\n-          });\n-        });\n+      it(\"hides 'Manage automations' button from global maintainer\", () => {\n+        cy.findByText(/manage automations/i).should(\"not.exist\");\n       });\n     });\n     describe(\"Query pages\", () => {\n@@ -250,11 +226,8 @@ describe(\"Premium tier - Maintainer user\", () => {\n     });\n     describe(\"Manage policies page\", () => {\n       beforeEach(() => cy.visit(\"/policies/manage\"));\n-      it(\"allows global maintainer to click 'Manage automations' button\", () => {\n-        cy.getAttached(\".button-wrap\")\n-          .findByRole(\"button\", { name: /manage automations/i })\n-          .click();\n-        cy.findByRole(\"button\", { name: /cancel/i }).click();\n+      it(\"hides manage automations button\", () => {\n+        cy.findByText(/manage hosts/i).should(\"not.exist\");\n       });\n       it(\"allows global maintainer to add a new policy\", () => {\n         cy.getAttached(\".button-wrap\")"
        },
        {
          "filename": "cypress/integration/premium/team_admin.spec.ts",
          "status": "modified",
          "additions": 2,
          "deletions": 11,
          "patch": "@@ -192,10 +192,7 @@ describe(\"Premium tier - Team Admin user\", () => {\n   });\n   describe(\"Manage software page\", () => {\n     beforeEach(() => cy.visit(\"/software/manage\"));\n-    it(\"hides manage automations button since all teams not selected\", () => {\n-      cy.getAttached(\".manage-software-page__header-wrap\").within(() => {\n-        cy.findByText(/apples/i).should(\"exist\");\n-      });\n+    it(\"hides manage automations button\", () => {\n       cy.findByText(/manage automations/i).should(\"not.exist\");\n     });\n   });\n@@ -283,12 +280,6 @@ describe(\"Premium tier - Team Admin user\", () => {\n   });\n   describe(\"Manage policies page\", () => {\n     beforeEach(() => cy.visit(\"/policies/manage\"));\n-    it(\"hides manage automations button when all teams not selected\", () => {\n-      cy.getAttached(\".manage-policies-page__header-wrap\").within(() => {\n-        cy.findByText(/apples/i).should(\"exist\");\n-      });\n-      cy.findByText(/manage automations/i).should(\"not.exist\");\n-    });\n     it(\"allows team admin to add a new policy\", () => {\n       cy.getAttached(\".button-wrap\")\n         .findByRole(\"button\", { name: /add a policy/i })\n@@ -358,7 +349,7 @@ describe(\"Premium tier - Team Admin user\", () => {\n       cy.findByText(/apples/i).should(\"exist\");\n     });\n     it(\"displays the team admin controls\", () => {\n-      cy.findByRole(\"button\", { name: /add member/i }).click();\n+      cy.findByRole(\"button\", { name: /create user/i }).click();\n       cy.findByRole(\"button\", { name: /cancel/i }).click();\n       cy.findByRole(\"button\", { name: /add hosts/i }).click();\n       cy.findByRole(\"button\", { name: /done/i }).click();"
        },
        {
          "filename": "cypress/integration/premium/team_maintainer_observer.spec.ts",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -276,8 +276,8 @@ describe(\"Premium tier - Team observer/maintainer user\", () => {\n         cy.findByText(/apples/i).click();\n         cy.findByText(/oranges/i).click();\n \n-        // On maintaining team, should see the \"Manage automations\" button\n-        cy.findByText(/manage automations/i).should(\"exist\");\n+        // On maintaining team, should not see the \"Manage automations\" button\n+        cy.findByText(/manage automations/i).should(\"not.exist\");\n         // On maintaining team, should see \"add a policy\" and \"save\" a policy\n         cy.findByText(/add a policy/i).click();\n "
        },
        {
          "filename": "frontend/pages/Homepage/cards/Software/Software.tsx",
          "status": "modified",
          "additions": 10,
          "deletions": 2,
          "patch": "@@ -1,7 +1,8 @@\n-import React, { useState } from \"react\";\n+import React, { useContext, useState } from \"react\";\n import { useQuery } from \"react-query\";\n import { Tab, Tabs, TabList, TabPanel } from \"react-tabs\";\n \n+import { AppContext } from \"context/app\";\n import paths from \"router/paths\";\n import configAPI from \"services/entities/config\";\n import softwareAPI, { ISoftwareResponse } from \"services/entities/software\";\n@@ -39,6 +40,10 @@ const Software = ({\n   const [pageIndex, setPageIndex] = useState<number>(0);\n   const [isSoftwareEnabled, setIsSoftwareEnabled] = useState<boolean>();\n \n+  const { availableTeams, currentTeam, isOnGlobalTeam } = useContext(\n+    AppContext\n+  );\n+\n   const { data: config } = useQuery([\"config\"], configAPI.loadAll, {\n     onSuccess: (data) => {\n       setIsSoftwareEnabled(data?.host_settings?.enable_software_inventory);\n@@ -71,8 +76,11 @@ const Software = ({\n         teamId: currentTeamId,\n       }),\n     {\n+      enabled:\n+        isOnGlobalTeam ||\n+        !!availableTeams?.find((t) => t.id === currentTeam?.id),\n       keepPreviousData: true,\n-      staleTime: 30000, // TODO: Discuss a reasonable staleTime given that counts are only updated infrequently?\n+      staleTime: 30000, // stale time can be adjusted if fresher data is desired based on software inventory interval\n       onSuccess: (data) => {\n         setShowSoftwareUI(true);\n         if (isSoftwareEnabled && data.software?.length !== 0) {"
        },
        {
          "filename": "frontend/pages/admin/TeamManagementPage/TeamDetailsWrapper/MembersPage/MembersPage.tsx",
          "status": "modified",
          "additions": 47,
          "deletions": 28,
          "patch": "@@ -51,9 +51,13 @@ const MembersPage = ({\n   const teamId = parseInt(team_id, 10);\n \n   const { renderFlash } = useContext(NotificationContext);\n-  const { config, isGlobalAdmin, currentUser, isPremiumTier } = useContext(\n-    AppContext\n-  );\n+  const {\n+    config,\n+    currentUser,\n+    isGlobalAdmin,\n+    isPremiumTier,\n+    isTeamAdmin,\n+  } = useContext(AppContext);\n \n   const smtpConfigured = config?.smtp_settings.configured || false;\n   const canUseSso = config?.sso_settings.enable_sso || false;\n@@ -137,14 +141,7 @@ const MembersPage = ({\n   const toggleCreateMemberModal = useCallback(() => {\n     setShowCreateUserModal(!showCreateUserModal);\n     setShowAddMemberModal(false);\n-    currentUser ? setUserEditing(currentUser) : setUserEditing(undefined);\n-  }, [\n-    showCreateUserModal,\n-    currentUser,\n-    setShowCreateUserModal,\n-    setUserEditing,\n-    setShowAddMemberModal,\n-  ]);\n+  }, [showCreateUserModal, setShowCreateUserModal, setShowAddMemberModal]);\n \n   // FUNCTIONS\n \n@@ -153,7 +150,10 @@ const MembersPage = ({\n     teamsAPI\n       .removeMembers(teamId, removedUsers)\n       .then(() => {\n-        renderFlash(\"success\", `Successfully removed ${userEditing?.name}`);\n+        renderFlash(\n+          \"success\",\n+          `Successfully removed ${userEditing?.name || \"member\"}`\n+        );\n         // If user removes self from team, redirect to home\n         if (currentUser && currentUser.id === removedUsers.users[0].id) {\n           window.location.href = \"/\";\n@@ -178,12 +178,15 @@ const MembersPage = ({\n     (newMembers: INewMembersBody) => {\n       teamsAPI\n         .addMembers(teamId, newMembers)\n-        .then(() =>\n+        .then(() => {\n+          const count = newMembers.users.length;\n           renderFlash(\n             \"success\",\n-            `${newMembers.users.length} members successfully added to ${currentTeam?.name}.`\n-          )\n-        )\n+            `${count} ${\n+              count === 1 ? \"member\" : \"members\"\n+            } successfully added to ${currentTeam?.name}.`\n+          );\n+        })\n         .catch(() =>\n           renderFlash(\"error\", \"Could not add members. Please try again.\")\n         )\n@@ -288,7 +291,10 @@ const MembersPage = ({\n         usersAPI\n           .update(userEditing.id, updatedAttrs)\n           .then(() => {\n-            renderFlash(\"success\", `Successfully edited ${userName}.`);\n+            renderFlash(\n+              \"success\",\n+              `Successfully edited ${userName || \"member\"}.`\n+            );\n \n             if (\n               currentUser &&\n@@ -317,7 +323,7 @@ const MembersPage = ({\n             } else {\n               renderFlash(\n                 \"error\",\n-                `Could not edit ${userName}. Please try again.`\n+                `Could not edit ${userName || \"member\"}. Please try again.`\n               );\n             }\n           });\n@@ -349,13 +355,24 @@ const MembersPage = ({\n                   Expecting to see new team members listed here? Try again in a\n                   few seconds as the system catches up.\n                 </p>\n-                <Button\n-                  variant=\"brand\"\n-                  className={`${noMembersClass}__create-button`}\n-                  onClick={toggleAddUserModal}\n-                >\n-                  Add member\n-                </Button>\n+                {isGlobalAdmin && (\n+                  <Button\n+                    variant=\"brand\"\n+                    className={`${noMembersClass}__create-button`}\n+                    onClick={toggleAddUserModal}\n+                  >\n+                    Add member\n+                  </Button>\n+                )}\n+                {isTeamAdmin && (\n+                  <Button\n+                    variant=\"brand\"\n+                    className={`${noMembersClass}__create-button`}\n+                    onClick={toggleCreateMemberModal}\n+                  >\n+                    Create user\n+                  </Button>\n+                )}\n               </>\n             ) : (\n               <>\n@@ -396,8 +413,10 @@ const MembersPage = ({\n           isLoading={isLoadingMembers}\n           defaultSortHeader={\"name\"}\n           defaultSortDirection={\"asc\"}\n-          onActionButtonClick={toggleAddUserModal}\n-          actionButtonText={\"Add member\"}\n+          onActionButtonClick={\n+            isGlobalAdmin ? toggleAddUserModal : toggleCreateMemberModal\n+          }\n+          actionButtonText={isGlobalAdmin ? \"Add member\" : \"Create user\"}\n           actionButtonVariant={\"brand\"}\n           hideActionButton={memberIds.length === 0 && searchString === \"\"}\n           onQueryChange={({ searchQuery }) => setSearchString(searchQuery)}\n@@ -424,7 +443,7 @@ const MembersPage = ({\n           onSubmit={onEditMemberSubmit}\n           defaultName={userEditing?.name}\n           defaultEmail={userEditing?.email}\n-          defaultGlobalRole={userEditing?.global_role}\n+          defaultGlobalRole={userEditing?.global_role || null}\n           defaultTeamRole={userEditing?.role}\n           defaultTeams={userEditing?.teams}\n           availableTeams={teams || []}"
        },
        {
          "filename": "frontend/pages/admin/UserManagementPage/components/UserForm/UserForm.tsx",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -121,7 +121,7 @@ const UserForm = ({\n   });\n \n   const [isGlobalUser, setIsGlobalUser] = useState<boolean>(\n-    defaultGlobalRole !== null\n+    !!defaultGlobalRole\n   );\n \n   useEffect(() => {"
        },
        {
          "filename": "frontend/pages/policies/ManagePoliciesPage/ManagePoliciesPage.tsx",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -138,6 +138,7 @@ const ManagePolicyPage = ({\n \n   const canAddOrRemovePolicy =\n     isGlobalAdmin || isGlobalMaintainer || isTeamMaintainer || isTeamAdmin;\n+  const canManageAutomations = isGlobalAdmin || isTeamAdmin;\n \n   const { isLoading: isLoadingWebhooks, refetch: refetchWebhooks } = useQuery<\n     IConfig | ILoadTeamResponse,\n@@ -364,7 +365,7 @@ const ManagePolicyPage = ({\n             </div>\n           </div>\n           <div className={`${baseClass} button-wrap`}>\n-            {canAddOrRemovePolicy &&\n+            {canManageAutomations &&\n               !isLoadingWebhooks &&\n               !isLoadingGlobalPolicies && (\n                 <Button"
        },
        {
          "filename": "frontend/pages/software/ManageSoftwarePage/ManageSoftwarePage.tsx",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -68,9 +68,9 @@ const ManageSoftwarePage = ({\n   const {\n     availableTeams,\n     currentTeam,\n-    setConfig,\n     isGlobalAdmin,\n     isGlobalMaintainer,\n+    isOnGlobalTeam,\n   } = useContext(AppContext);\n   const { renderFlash } = useContext(NotificationContext);\n \n@@ -162,6 +162,9 @@ const ManageSoftwarePage = ({\n       return softwareAPI.load(params);\n     },\n     {\n+      enabled:\n+        isOnGlobalTeam ||\n+        !!availableTeams?.find((t) => t.id === currentTeam?.id),\n       keepPreviousData: true,\n       staleTime: 30000, // stale time can be adjusted if fresher data is desired based on software inventory interval\n     }\n@@ -190,6 +193,9 @@ const ManageSoftwarePage = ({\n       });\n     },\n     {\n+      enabled:\n+        isOnGlobalTeam ||\n+        !!availableTeams?.find((t) => t.id === currentTeam?.id),\n       keepPreviousData: true,\n       staleTime: 30000, // stale time can be adjusted if fresher data is desired based on software inventory interval\n       refetchOnWindowFocus: false,"
        },
        {
          "filename": "server/authz/authz.go",
          "status": "modified",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -138,6 +138,12 @@ type AuthzTyper interface {\n \tAuthzType() string\n }\n \n+// ExtraAuthzer is the interface to implement extra fields for the policy.\n+type ExtraAuthzer interface {\n+\t// ExtraAuthz returns the extra key/value pairs for the type.\n+\tExtraAuthz() (map[string]interface{}, error)\n+}\n+\n // jsonToInterface turns any type that can be JSON (un)marshaled into an\n // map[string]interface{} for evaluation by the OPA engine. Nil is returned as nil.\n func jsonToInterface(in interface{}) (interface{}, error) {\n@@ -169,6 +175,19 @@ func jsonToInterface(in interface{}) (interface{}, error) {\n \tif typer, ok := in.(AuthzTyper); ok {\n \t\tout[\"type\"] = typer.AuthzType()\n \t}\n+\t// Add any extra key/values defined by the type.\n+\tif extra, ok := in.(ExtraAuthzer); ok {\n+\t\textraKVs, err := extra.ExtraAuthz()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"extra authz: %w\", err)\n+\t\t}\n+\t\tfor k, v := range extraKVs {\n+\t\t\tif _, ok := out[k]; ok {\n+\t\t\t\treturn nil, fmt.Errorf(\"existing authz value: %s\", k)\n+\t\t\t}\n+\t\t\tout[k] = v\n+\t\t}\n+\t}\n \n \treturn out, nil\n }"
        },
        {
          "filename": "server/authz/policy.rego",
          "status": "modified",
          "additions": 49,
          "deletions": 26,
          "patch": "@@ -13,8 +13,12 @@ import input.subject\n read := \"read\"\n list := \"list\"\n write := \"write\"\n+\n+# User specific actions\n write_role := \"write_role\"\n change_password := \"change_password\"\n+\n+# Query specific actions\n run := \"run\"\n run_new := \"run_new\"\n \n@@ -95,35 +99,31 @@ allow {\n \n ##\n # Users\n+#\n+# NOTE: More rules apply to users but they are implemented in Go code.\n+# Our end goal is to move all the authorization logic here.\n ##\n \n-# Any user can write self (besides role) and change their own password.\n+# Any user can read and write self and change their own password.\n allow {\n   object.type == \"user\"\n   object.id == subject.id\n   object.id != 0\n-  action == [write, change_password][_]\n+  action == [read, write, change_password][_]\n }\n \n-# Any user can read other users.\n-allow {\n-  object.type == \"user\"\n-  not is_null(subject)\n-  action == read\n-}\n-\n-# Admins can write all users + roles + change passwords.\n+# Global admins can perform all operations on all users.\n allow {\n   object.type == \"user\"\n   subject.global_role == admin\n-  action == [write, write_role, change_password][_]\n+  action == [read, write, write_role, change_password][_]\n }\n \n-## Team admins can create or edit new users, but not change their password.\n+# Team admins can perform all operations on the team users (except changing their password).\n allow {\n   object.type == \"user\"\n   team_role(subject, object.teams[_].id) == admin\n-  action == [write, write_role][_]\n+  action == [read, write, write_role][_]\n }\n \n ##\n@@ -141,9 +141,9 @@ allow {\n # Activities\n ##\n \n-# All users can read activities\n+# Only global users can read activities\n allow {\n-  not is_null(subject)\n+  not is_null(subject.global_role)\n   object.type == \"activity\"\n   action == read\n }\n@@ -402,26 +402,41 @@ allow {\n # Packs\n ##\n \n-# Global admins and maintainers can read/write all packs\n+# Global admins and maintainers can read/write all packs.\n allow {\n   object.type == \"pack\"\n-  subject.global_role == [admin,maintainer][_]\n+  subject.global_role == [admin, maintainer][_]\n   action == [read, write][_]\n }\n \n-# Team admins and maintainers can read global packs\n+# All users can read the global pack.\n allow {\n-  is_null(object.team_ids)\n   object.type == \"pack\"\n-  team_role(subject, subject.teams[_].id) == [admin,maintainer][_]\n+  not is_null(subject)\n+  object.is_global_pack == true\n   action == read\n }\n \n-# Team admins and maintainers can read/write their team packs\n+# Team admins, maintainers and observers can read their team's pack.\n+#\n+# NOTE: Action \"read\" on a team's pack includes listing its scheduled queries.\n allow {\n   object.type == \"pack\"\n-  team_role(subject, object.team_ids[_]) == [admin,maintainer][_]\n-  action == [read, write][_]\n+  not is_null(object.pack_team_id)\n+  team_role(subject, object.pack_team_id) == [admin, maintainer, observer][_]\n+  action == read\n+}\n+\n+# Team admins and maintainers can add/remove scheduled queries from/to their team's pack.\n+#\n+# NOTE: The team's pack is not editable per-se, it's a special pack to group\n+# all the team's scheduled queries. So the \"write\" operation only covers\n+# adding/removing scheduled queries from the pack.\n+allow {\n+  object.type == \"pack\"\n+  not is_null(object.pack_team_id)\n+  team_role(subject, object.pack_team_id) == [admin, maintainer][_]\n+  action == write\n }\n \n ##\n@@ -481,9 +496,17 @@ allow {\n # Software\n ##\n \n-# All users can read software\n+# Global users can read all software.\n allow {\n-  not is_null(subject)\n-  object.type == \"software\"\n+  object.type == \"software_inventory\"\n+  subject.global_role == [admin, maintainer, observer][_]\n   action == read\n }\n+\n+# Team users can read all software in their teams.\n+allow {\n+  not is_null(object.team_id)\n+  object.type == \"software_inventory\"\n+  team_role(subject, object.team_id) == [admin, maintainer, observer][_]\n+  action == read\n+}\n\\ No newline at end of file"
        },
        {
          "filename": "server/authz/policy_test.go",
          "status": "modified",
          "additions": 30,
          "deletions": 18,
          "patch": "@@ -115,7 +115,7 @@ func TestAuthorizeUser(t *testing.T) {\n \t\t{user: nil, object: user, action: changePwd, allow: false},\n \t\t{user: nil, object: newUser, action: write, allow: false},\n \n-\t\t// Admin can read/write all and create new\n+\t\t// Global admin can read/write all and create new.\n \t\t{user: test.UserAdmin, object: user, action: read, allow: true},\n \t\t{user: test.UserAdmin, object: user, action: write, allow: true},\n \t\t{user: test.UserAdmin, object: user, action: writeRole, allow: true},\n@@ -126,48 +126,60 @@ func TestAuthorizeUser(t *testing.T) {\n \t\t{user: test.UserAdmin, object: test.UserAdmin, action: writeRole, allow: true},\n \t\t{user: test.UserAdmin, object: test.UserAdmin, action: changePwd, allow: true},\n \n-\t\t// Regular users can read all users and write self (besides roles), but not create\n-\t\t{user: test.UserMaintainer, object: user, action: read, allow: true},\n+\t\t// Global maintainers cannot read/write users.\n+\t\t{user: test.UserMaintainer, object: user, action: read, allow: false},\n \t\t{user: test.UserMaintainer, object: user, action: write, allow: false},\n \t\t{user: test.UserMaintainer, object: user, action: writeRole, allow: false},\n \t\t{user: test.UserMaintainer, object: user, action: changePwd, allow: false},\n+\t\t// Global maintainers cannot create users.\n \t\t{user: test.UserMaintainer, object: newUser, action: write, allow: false},\n+\t\t// Global maintainers can read/write itself (besides roles).\n \t\t{user: test.UserMaintainer, object: test.UserMaintainer, action: read, allow: true},\n \t\t{user: test.UserMaintainer, object: test.UserMaintainer, action: write, allow: true},\n \t\t{user: test.UserMaintainer, object: test.UserMaintainer, action: writeRole, allow: false},\n \t\t{user: test.UserMaintainer, object: test.UserMaintainer, action: changePwd, allow: true},\n \n-\t\t{user: test.UserNoRoles, object: user, action: read, allow: true},\n+\t\t// Users without roles cannot read/write users.\n+\t\t{user: test.UserNoRoles, object: user, action: read, allow: false},\n \t\t{user: test.UserNoRoles, object: user, action: write, allow: false},\n \t\t{user: test.UserNoRoles, object: user, action: writeRole, allow: false},\n \t\t{user: test.UserNoRoles, object: user, action: changePwd, allow: false},\n+\t\t// User without roles cannot add new users.\n \t\t{user: test.UserNoRoles, object: newUser, action: write, allow: false},\n+\t\t// User without roles can read/write itself (besides roles).\n \t\t{user: test.UserNoRoles, object: test.UserNoRoles, action: read, allow: true},\n \t\t{user: test.UserNoRoles, object: test.UserNoRoles, action: write, allow: true},\n \t\t{user: test.UserNoRoles, object: test.UserNoRoles, action: writeRole, allow: false},\n \t\t{user: test.UserNoRoles, object: test.UserNoRoles, action: changePwd, allow: true},\n \n-\t\t{user: test.UserObserver, object: user, action: read, allow: true},\n+\t\t// Global observers cannot read/write users.\n+\t\t{user: test.UserObserver, object: user, action: read, allow: false},\n \t\t{user: test.UserObserver, object: user, action: write, allow: false},\n \t\t{user: test.UserObserver, object: user, action: writeRole, allow: false},\n \t\t{user: test.UserObserver, object: user, action: changePwd, allow: false},\n+\t\t// Global observers cannot create users.\n \t\t{user: test.UserObserver, object: newUser, action: write, allow: false},\n+\t\t// Global observers can read/write itself (besides roles).\n \t\t{user: test.UserObserver, object: test.UserObserver, action: read, allow: true},\n \t\t{user: test.UserObserver, object: test.UserObserver, action: write, allow: true},\n \t\t{user: test.UserObserver, object: test.UserObserver, action: writeRole, allow: false},\n \t\t{user: test.UserObserver, object: test.UserObserver, action: changePwd, allow: true},\n \n-\t\t// Team Admin can create/write/write role of any team user, but not change password\n-\t\t{user: teamAdmin, object: user, action: read, allow: true},\n+\t\t// Team admins cannot read/write global users.\n+\t\t{user: teamAdmin, object: user, action: read, allow: false},\n \t\t{user: teamAdmin, object: user, action: write, allow: false},\n \t\t{user: teamAdmin, object: user, action: writeRole, allow: false},\n \t\t{user: teamAdmin, object: user, action: changePwd, allow: false},\n+\t\t// Team admins cannot create new global users.\n \t\t{user: teamAdmin, object: newUser, action: write, allow: false},\n+\t\t// Team admins can read/write team users (except change their password).\n \t\t{user: teamAdmin, object: teamObserver, action: read, allow: true},\n \t\t{user: teamAdmin, object: teamObserver, action: write, allow: true},\n \t\t{user: teamAdmin, object: teamObserver, action: writeRole, allow: true},\n \t\t{user: teamAdmin, object: teamObserver, action: changePwd, allow: false},\n+\t\t// Team admins can add new users to the team.\n \t\t{user: teamAdmin, object: newTeamUser, action: write, allow: true},\n+\t\t// Team admins can read/write itself.\n \t\t{user: teamAdmin, object: teamAdmin, action: read, allow: true},\n \t\t{user: teamAdmin, object: teamAdmin, action: write, allow: true},\n \t\t{user: teamAdmin, object: teamAdmin, action: writeRole, allow: true},\n@@ -622,25 +634,25 @@ func TestAuthorizeTeamPacks(t *testing.T) {\n \t\t{\n \t\t\tuser: test.UserTeamMaintainerTeam1,\n \t\t\tobject: &fleet.Pack{\n-\t\t\t\tTeamIDs: []uint{1},\n+\t\t\t\tType: ptr.String(\"team-1\"),\n \t\t\t},\n \t\t\taction: read,\n \t\t\tallow:  true,\n \t\t},\n-\t\t// Team observer cannot read packs of the team.\n+\t\t// Team observer can read packs of the team.\n \t\t{\n \t\t\tuser: test.UserTeamObserverTeam1TeamAdminTeam2,\n \t\t\tobject: &fleet.Pack{\n-\t\t\t\tTeamIDs: []uint{1},\n+\t\t\t\tType: ptr.String(\"team-1\"),\n \t\t\t},\n \t\t\taction: read,\n-\t\t\tallow:  false,\n+\t\t\tallow:  true,\n \t\t},\n \t\t// Team observer cannot write packs of the team.\n \t\t{\n \t\t\tuser: test.UserTeamObserverTeam1TeamAdminTeam2,\n \t\t\tobject: &fleet.Pack{\n-\t\t\t\tTeamIDs: []uint{1},\n+\t\t\t\tType: ptr.String(\"team-1\"),\n \t\t\t},\n \t\t\taction: write,\n \t\t\tallow:  false,\n@@ -649,7 +661,7 @@ func TestAuthorizeTeamPacks(t *testing.T) {\n \t\t{\n \t\t\tuser: test.UserTeamAdminTeam1,\n \t\t\tobject: &fleet.Pack{\n-\t\t\t\tTeamIDs: []uint{2},\n+\t\t\t\tType: ptr.String(\"team-2\"),\n \t\t\t},\n \t\t\taction: read,\n \t\t\tallow:  false,\n@@ -658,24 +670,24 @@ func TestAuthorizeTeamPacks(t *testing.T) {\n \t\t{\n \t\t\tuser: test.UserTeamAdminTeam1,\n \t\t\tobject: &fleet.Pack{\n-\t\t\t\tTeamIDs: []uint{2},\n+\t\t\t\tType: ptr.String(\"team-2\"),\n \t\t\t},\n \t\t\taction: read,\n \t\t\tallow:  false,\n \t\t},\n-\t\t// Team maintainers can read global packs.\n+\t\t// Team maintainers cannot read global packs.\n \t\t{\n \t\t\tuser:   test.UserTeamMaintainerTeam1,\n \t\t\tobject: &fleet.Pack{},\n \t\t\taction: read,\n-\t\t\tallow:  true,\n+\t\t\tallow:  false,\n \t\t},\n-\t\t// Team admins can read global packs.\n+\t\t// Team admins cannot read global packs.\n \t\t{\n \t\t\tuser:   test.UserTeamAdminTeam1,\n \t\t\tobject: &fleet.Pack{},\n \t\t\taction: read,\n-\t\t\tallow:  true,\n+\t\t\tallow:  false,\n \t\t},\n \t\t// Team admins cannot write global packs.\n \t\t{"
        },
        {
          "filename": "server/fleet/authz.go",
          "status": "modified",
          "additions": 17,
          "deletions": 3,
          "patch": "@@ -7,12 +7,26 @@ const (\n \tActionList = \"list\"\n \t// ActionWrite refers to writing (CRUD operations) an entity.\n \tActionWrite = \"write\"\n+\n+\t//\n+\t// User specific actions\n+\t//\n+\n \t// ActionWriteRole is a write to a user's global roles and teams.\n+\t//\n+\t// While the Write action allows setting the role on creation of a user, the\n+\t// ActionWriteRole action is required to modify an existing user's password.\n \tActionWriteRole = \"write_role\"\n-\t// ActionChangePassword is the permission to change a user's password. While\n-\t// the Write action allows setting the password on creation of a user, the\n-\t// ChangePassword action is required to modify an existing user's password.\n+\t// ActionChangePassword is the permission to change a user's password.\n+\t//\n+\t// While the Write action allows setting the password on creation of a user, the\n+\t// ActionChangePassword action is required to modify an existing user's password.\n \tActionChangePassword = \"change_password\"\n+\n+\t//\n+\t// Query specific actions\n+\t//\n+\n \t// ActionRun is the action for running a live query.\n \tActionRun = \"run\"\n \t// ActionRunNew is the action for running a new live query."
        },
        {
          "filename": "server/fleet/packs.go",
          "status": "modified",
          "additions": 61,
          "deletions": 12,
          "patch": "@@ -2,6 +2,10 @@ package fleet\n \n import (\n \t\"errors\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\t\"github.com/fleetdm/fleet/v4/server/ptr\"\n )\n \n type PackListOptions struct {\n@@ -12,20 +16,65 @@ type PackListOptions struct {\n }\n \n // Pack is the structure which represents an osquery query pack.\n+//\n+// NOTE: A \"team pack\" is a special type of pack with Pack.Type=\"team-$TEAM_ID\".\n+// Such team packs hold the scheduled queries for a team. This is different from a\n+// pack that has a team as target (Pack.Teams and Pack.TeamIDs fields).\n type Pack struct {\n \tUpdateCreateTimestamps\n-\tID          uint     `json:\"id\"`\n-\tName        string   `json:\"name\"`\n-\tDescription string   `json:\"description,omitempty\"`\n-\tPlatform    string   `json:\"platform,omitempty\"`\n-\tDisabled    bool     `json:\"disabled\"`\n-\tType        *string  `json:\"type\" db:\"pack_type\"`\n-\tLabels      []Target `json:\"labels\"`\n-\tLabelIDs    []uint   `json:\"label_ids\"`\n-\tHosts       []Target `json:\"hosts\"`\n-\tHostIDs     []uint   `json:\"host_ids\"`\n-\tTeams       []Target `json:\"teams\"`\n-\tTeamIDs     []uint   `json:\"team_ids\"`\n+\tID          uint   `json:\"id\"`\n+\tName        string `json:\"name\"`\n+\tDescription string `json:\"description,omitempty\"`\n+\tPlatform    string `json:\"platform,omitempty\"`\n+\tDisabled    bool   `json:\"disabled\"`\n+\t// Type indicates the type of the pack:\n+\t//\t- \"global\" is the type of the global pack.\n+\t//\t- \"team-$ID\" is the type for team packs.\n+\t//\t- nil is the type for a user created pack.\n+\tType     *string  `json:\"type\" db:\"pack_type\"`\n+\tLabels   []Target `json:\"labels\"`\n+\tLabelIDs []uint   `json:\"label_ids\"`\n+\tHosts    []Target `json:\"hosts\"`\n+\tHostIDs  []uint   `json:\"host_ids\"`\n+\tTeams    []Target `json:\"teams\"`\n+\t// TeamIDs holds the ID of the teams this pack should target.\n+\tTeamIDs []uint `json:\"team_ids\"`\n+}\n+\n+// isTeamPack returns true if the pack is a pack specifically made for a team.\n+func (p *Pack) isTeamPack() bool {\n+\treturn p.Type != nil && strings.HasPrefix(*p.Type, \"team-\")\n+}\n+\n+// isGlobalPack returns true if the pack is the global pack.\n+func (p *Pack) isGlobalPack() bool {\n+\treturn p.Type != nil && *p.Type == \"global\"\n+}\n+\n+// TeamPack returns the team ID for a team's pack.\n+// Returns (nil, nil) if the pack is not a team pack.\n+func (p *Pack) teamPack() (*uint, error) {\n+\tif !p.isTeamPack() {\n+\t\treturn nil, nil\n+\t}\n+\tt := strings.TrimPrefix(*p.Type, \"team-\")\n+\tteamID, err := strconv.ParseUint(t, 10, 64)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn ptr.Uint(uint(teamID)), nil\n+}\n+\n+// ExtraAuthz implements authz.ExtraAuthzer.\n+func (p *Pack) ExtraAuthz() (map[string]interface{}, error) {\n+\tpackTeamID, err := p.teamPack()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn map[string]interface{}{\n+\t\t\"pack_team_id\":   packTeamID,\n+\t\t\"is_global_pack\": p.isGlobalPack(),\n+\t}, nil\n }\n \n // Verify verifies the pack's fields are valid."
        },
        {
          "filename": "server/fleet/software.go",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -43,6 +43,17 @@ func (Software) AuthzType() string {\n \treturn \"software\"\n }\n \n+// AuthzSoftwareInventory is used for access controls on software inventory.\n+type AuthzSoftwareInventory struct {\n+\t// TeamID is the ID of the team. A value of nil means global scope.\n+\tTeamID *uint `json:\"team_id\"`\n+}\n+\n+// AuthzType implements authz.AuthzTyper.\n+func (s *AuthzSoftwareInventory) AuthzType() string {\n+\treturn \"software_inventory\"\n+}\n+\n type VulnerabilitiesSlice []SoftwareCVE\n \n // HostSoftware is the set of software installed on a specific host"
        },
        {
          "filename": "server/service/activities_test.go",
          "status": "modified",
          "additions": 20,
          "deletions": 8,
          "patch": "@@ -15,22 +15,34 @@ func TestListActivities(t *testing.T) {\n \tds := new(mock.Store)\n \tsvc := newTestService(t, ds, nil, nil)\n \n+\tglobalUsers := []*fleet.User{test.UserAdmin, test.UserMaintainer, test.UserObserver}\n+\tteamUsers := []*fleet.User{test.UserTeamAdminTeam1, test.UserTeamMaintainerTeam1, test.UserTeamObserverTeam1}\n+\n \tds.ListActivitiesFunc = func(ctx context.Context, opts fleet.ListOptions) ([]*fleet.Activity, error) {\n \t\treturn []*fleet.Activity{\n \t\t\t{ID: 1},\n \t\t\t{ID: 2},\n \t\t}, nil\n \t}\n \n-\t// admin user\n-\tactivities, err := svc.ListActivities(test.UserContext(test.UserAdmin), fleet.ListOptions{})\n-\trequire.NoError(t, err)\n-\trequire.Len(t, activities, 2)\n+\t// any global user can read activities\n+\tfor _, u := range globalUsers {\n+\t\tactivities, err := svc.ListActivities(test.UserContext(u), fleet.ListOptions{})\n+\t\trequire.NoError(t, err)\n+\t\trequire.Len(t, activities, 2)\n+\t}\n+\n+\t// team users cannot read activities\n+\tfor _, u := range teamUsers {\n+\t\t_, err := svc.ListActivities(test.UserContext(u), fleet.ListOptions{})\n+\t\trequire.Error(t, err)\n+\t\trequire.Contains(t, err.Error(), authz.ForbiddenErrorMessage)\n+\t}\n \n-\t// anyone can read activities\n-\tactivities, err = svc.ListActivities(test.UserContext(test.UserNoRoles), fleet.ListOptions{})\n-\trequire.NoError(t, err)\n-\trequire.Len(t, activities, 2)\n+\t// user with no roles cannot read activities\n+\t_, err := svc.ListActivities(test.UserContext(test.UserNoRoles), fleet.ListOptions{})\n+\trequire.Error(t, err)\n+\trequire.Contains(t, err.Error(), authz.ForbiddenErrorMessage)\n \n \t// no user in context\n \t_, err = svc.ListActivities(context.Background(), fleet.ListOptions{})"
        },
        {
          "filename": "server/service/endpoint_utils_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 7,
          "patch": "@@ -11,7 +11,6 @@ import (\n \t\"testing\"\n \t\"time\"\n \n-\tauthz_ctx \"github.com/fleetdm/fleet/v4/server/contexts/authz\"\n \t\"github.com/fleetdm/fleet/v4/server/fleet\"\n \t\"github.com/fleetdm/fleet/v4/server/mock\"\n \t\"github.com/fleetdm/fleet/v4/server/ptr\"\n@@ -294,15 +293,11 @@ func TestEndpointer(t *testing.T) {\n \n \te := newUserAuthenticatedEndpointer(svc, fleetAPIOptions, r, \"v1\", \"2021-11\")\n \tnopHandler := func(ctx context.Context, request interface{}, svc fleet.Service) (interface{}, error) {\n-\t\tif authctx, ok := authz_ctx.FromContext(ctx); ok {\n-\t\t\tauthctx.SetChecked()\n-\t\t}\n+\t\tsetAuthCheckedOnPreAuthErr(ctx)\n \t\treturn \"nop\", nil\n \t}\n \toverrideHandler := func(ctx context.Context, request interface{}, svc fleet.Service) (interface{}, error) {\n-\t\tif authctx, ok := authz_ctx.FromContext(ctx); ok {\n-\t\t\tauthctx.SetChecked()\n-\t\t}\n+\t\tsetAuthCheckedOnPreAuthErr(ctx)\n \t\treturn \"override\", nil\n \t}\n "
        },
        {
          "filename": "server/service/global_schedule.go",
          "status": "modified",
          "additions": 25,
          "deletions": 4,
          "patch": "@@ -2,6 +2,7 @@ package service\n \n import (\n \t\"context\"\n+\t\"fmt\"\n \n \t\"github.com/fleetdm/fleet/v4/server/fleet\"\n \t\"github.com/fleetdm/fleet/v4/server/ptr\"\n@@ -36,7 +37,9 @@ func getGlobalScheduleEndpoint(ctx context.Context, request interface{}, svc fle\n }\n \n func (svc *Service) GetGlobalScheduledQueries(ctx context.Context, opts fleet.ListOptions) ([]*fleet.ScheduledQuery, error) {\n-\tif err := svc.authz.Authorize(ctx, &fleet.Pack{}, fleet.ActionRead); err != nil {\n+\tif err := svc.authz.Authorize(ctx, &fleet.Pack{\n+\t\tType: ptr.String(\"global\"),\n+\t}, fleet.ActionRead); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -88,7 +91,9 @@ func globalScheduleQueryEndpoint(ctx context.Context, request interface{}, svc f\n }\n \n func (svc *Service) GlobalScheduleQuery(ctx context.Context, sq *fleet.ScheduledQuery) (*fleet.ScheduledQuery, error) {\n-\tif err := svc.authz.Authorize(ctx, &fleet.Pack{}, fleet.ActionRead); err != nil {\n+\tif err := svc.authz.Authorize(ctx, &fleet.Pack{\n+\t\tType: ptr.String(\"global\"),\n+\t}, fleet.ActionRead); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -131,7 +136,9 @@ func modifyGlobalScheduleEndpoint(ctx context.Context, request interface{}, svc\n }\n \n func (svc *Service) ModifyGlobalScheduledQueries(ctx context.Context, id uint, query fleet.ScheduledQueryPayload) (*fleet.ScheduledQuery, error) {\n-\tif err := svc.authz.Authorize(ctx, &fleet.Pack{}, fleet.ActionWrite); err != nil {\n+\tif err := svc.authz.Authorize(ctx, &fleet.Pack{\n+\t\tType: ptr.String(\"global\"),\n+\t}, fleet.ActionWrite); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -170,9 +177,23 @@ func deleteGlobalScheduleEndpoint(ctx context.Context, request interface{}, svc\n }\n \n func (svc *Service) DeleteGlobalScheduledQueries(ctx context.Context, id uint) error {\n-\tif err := svc.authz.Authorize(ctx, &fleet.Pack{}, fleet.ActionWrite); err != nil {\n+\tif err := svc.authz.Authorize(ctx, &fleet.Pack{\n+\t\tType: ptr.String(\"global\"),\n+\t}, fleet.ActionWrite); err != nil {\n \t\treturn err\n \t}\n \n+\tglobalPack, err := svc.ds.EnsureGlobalPack(ctx)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tscheduledQuery, err := svc.ds.ScheduledQuery(ctx, id)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif scheduledQuery.PackID != globalPack.ID {\n+\t\treturn fmt.Errorf(\"scheduled query %d is not global\", id)\n+\t}\n+\n \treturn svc.DeleteScheduledQuery(ctx, id)\n }"
        },
        {
          "filename": "server/service/global_schedule_test.go",
          "status": "modified",
          "additions": 24,
          "deletions": 24,
          "patch": "@@ -40,40 +40,40 @@ func TestGlobalScheduleAuth(t *testing.T) {\n \t\tshouldFailRead  bool\n \t}{\n \t\t{\n-\t\t\t\"global admin\",\n-\t\t\t&fleet.User{GlobalRole: ptr.String(fleet.RoleAdmin)},\n-\t\t\tfalse,\n-\t\t\tfalse,\n+\t\t\tname:            \"global admin\",\n+\t\t\tuser:            &fleet.User{GlobalRole: ptr.String(fleet.RoleAdmin)},\n+\t\t\tshouldFailWrite: false,\n+\t\t\tshouldFailRead:  false,\n \t\t},\n \t\t{\n-\t\t\t\"global maintainer\",\n-\t\t\t&fleet.User{GlobalRole: ptr.String(fleet.RoleMaintainer)},\n-\t\t\tfalse,\n-\t\t\tfalse,\n+\t\t\tname:            \"global maintainer\",\n+\t\t\tuser:            &fleet.User{GlobalRole: ptr.String(fleet.RoleMaintainer)},\n+\t\t\tshouldFailWrite: false,\n+\t\t\tshouldFailRead:  false,\n \t\t},\n \t\t{\n-\t\t\t\"global observer\",\n-\t\t\t&fleet.User{GlobalRole: ptr.String(fleet.RoleObserver)},\n-\t\t\ttrue,\n-\t\t\ttrue,\n+\t\t\tname:            \"global observer\",\n+\t\t\tuser:            &fleet.User{GlobalRole: ptr.String(fleet.RoleObserver)},\n+\t\t\tshouldFailWrite: true,\n+\t\t\tshouldFailRead:  false,\n \t\t},\n \t\t{\n-\t\t\t\"team admin\",\n-\t\t\t&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleAdmin}}},\n-\t\t\ttrue,\n-\t\t\tfalse,\n+\t\t\tname:            \"team admin\",\n+\t\t\tuser:            &fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleAdmin}}},\n+\t\t\tshouldFailWrite: true,\n+\t\t\tshouldFailRead:  false,\n \t\t},\n \t\t{\n-\t\t\t\"team maintainer\",\n-\t\t\t&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleMaintainer}}},\n-\t\t\ttrue,\n-\t\t\tfalse,\n+\t\t\tname:            \"team maintainer\",\n+\t\t\tuser:            &fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleMaintainer}}},\n+\t\t\tshouldFailWrite: true,\n+\t\t\tshouldFailRead:  false,\n \t\t},\n \t\t{\n-\t\t\t\"team observer\",\n-\t\t\t&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleObserver}}},\n-\t\t\ttrue,\n-\t\t\ttrue,\n+\t\t\tname:            \"team observer\",\n+\t\t\tuser:            &fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleObserver}}},\n+\t\t\tshouldFailWrite: true,\n+\t\t\tshouldFailRead:  false,\n \t\t},\n \t}\n \tfor _, tt := range testCases {"
        },
        {
          "filename": "server/service/hosts.go",
          "status": "modified",
          "additions": 4,
          "deletions": 6,
          "patch": "@@ -7,7 +7,6 @@ import (\n \t\"time\"\n \n \t\"github.com/fleetdm/fleet/v4/server/contexts/authz\"\n-\tauthz_ctx \"github.com/fleetdm/fleet/v4/server/contexts/authz\"\n \t\"github.com/fleetdm/fleet/v4/server/contexts/ctxerr\"\n \t\"github.com/fleetdm/fleet/v4/server/contexts/logging\"\n \t\"github.com/fleetdm/fleet/v4/server/contexts/viewer\"\n@@ -275,7 +274,7 @@ func getHostEndpoint(ctx context.Context, request interface{}, svc fleet.Service\n }\n \n func (svc *Service) GetHost(ctx context.Context, id uint) (*fleet.HostDetail, error) {\n-\talreadyAuthd := svc.authz.IsAuthenticatedWith(ctx, authz_ctx.AuthnDeviceToken)\n+\talreadyAuthd := svc.authz.IsAuthenticatedWith(ctx, authz.AuthnDeviceToken)\n \tif !alreadyAuthd {\n \t\t// First ensure the user has access to list hosts, then check the specific\n \t\t// host once team_id is loaded.\n@@ -560,7 +559,7 @@ func refetchHostEndpoint(ctx context.Context, request interface{}, svc fleet.Ser\n }\n \n func (svc *Service) RefetchHost(ctx context.Context, id uint) error {\n-\tif !svc.authz.IsAuthenticatedWith(ctx, authz_ctx.AuthnDeviceToken) {\n+\tif !svc.authz.IsAuthenticatedWith(ctx, authz.AuthnDeviceToken) {\n \t\tif err := svc.authz.Authorize(ctx, &fleet.Host{}, fleet.ActionList); err != nil {\n \t\t\treturn err\n \t\t}\n@@ -676,7 +675,7 @@ func listHostDeviceMappingEndpoint(ctx context.Context, request interface{}, svc\n }\n \n func (svc *Service) ListHostDeviceMapping(ctx context.Context, id uint) ([]*fleet.HostDeviceMapping, error) {\n-\tif !svc.authz.IsAuthenticatedWith(ctx, authz_ctx.AuthnDeviceToken) {\n+\tif !svc.authz.IsAuthenticatedWith(ctx, authz.AuthnDeviceToken) {\n \t\tif err := svc.authz.Authorize(ctx, &fleet.Host{}, fleet.ActionList); err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -720,7 +719,7 @@ func getMacadminsDataEndpoint(ctx context.Context, request interface{}, svc flee\n }\n \n func (svc *Service) MacadminsData(ctx context.Context, id uint) (*fleet.MacadminsData, error) {\n-\tif !svc.authz.IsAuthenticatedWith(ctx, authz_ctx.AuthnDeviceToken) {\n+\tif !svc.authz.IsAuthenticatedWith(ctx, authz.AuthnDeviceToken) {\n \t\tif err := svc.authz.Authorize(ctx, &fleet.Host{}, fleet.ActionList); err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -932,5 +931,4 @@ func (svc *Service) OSVersions(ctx context.Context, teamID *uint, platform *stri\n \t}\n \n \treturn osVersions, nil\n-\n }"
        },
        {
          "filename": "server/service/scheduled_queries_test.go",
          "status": "modified",
          "additions": 27,
          "deletions": 24,
          "patch": "@@ -43,40 +43,43 @@ func TestScheduledQueriesAuth(t *testing.T) {\n \t\tshouldFailRead  bool\n \t}{\n \t\t{\n-\t\t\t\"global admin\",\n-\t\t\t&fleet.User{GlobalRole: ptr.String(fleet.RoleAdmin)},\n-\t\t\tfalse,\n-\t\t\tfalse,\n+\t\t\tname:            \"global admin\",\n+\t\t\tuser:            &fleet.User{GlobalRole: ptr.String(fleet.RoleAdmin)},\n+\t\t\tshouldFailWrite: false,\n+\t\t\tshouldFailRead:  false,\n \t\t},\n \t\t{\n-\t\t\t\"global maintainer\",\n-\t\t\t&fleet.User{GlobalRole: ptr.String(fleet.RoleMaintainer)},\n-\t\t\tfalse,\n-\t\t\tfalse,\n+\t\t\tname:            \"global maintainer\",\n+\t\t\tuser:            &fleet.User{GlobalRole: ptr.String(fleet.RoleMaintainer)},\n+\t\t\tshouldFailWrite: false,\n+\t\t\tshouldFailRead:  false,\n \t\t},\n \t\t{\n-\t\t\t\"global observer\",\n-\t\t\t&fleet.User{GlobalRole: ptr.String(fleet.RoleObserver)},\n-\t\t\ttrue,\n-\t\t\ttrue,\n+\t\t\tname:            \"global observer\",\n+\t\t\tuser:            &fleet.User{GlobalRole: ptr.String(fleet.RoleObserver)},\n+\t\t\tshouldFailWrite: true,\n+\t\t\tshouldFailRead:  true,\n \t\t},\n+\t\t// Team users cannot read or write scheduled queries using the below service APIs.\n+\t\t// Team users must use the \"Team\" endpoints (GetTeamScheduledQueries, TeamScheduleQuery,\n+\t\t// ModifyTeamScheduledQueries and DeleteTeamScheduledQueries).\n \t\t{\n-\t\t\t\"team admin\",\n-\t\t\t&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleAdmin}}},\n-\t\t\ttrue,\n-\t\t\tfalse,\n+\t\t\tname:            \"team admin\",\n+\t\t\tuser:            &fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleAdmin}}},\n+\t\t\tshouldFailWrite: true,\n+\t\t\tshouldFailRead:  true,\n \t\t},\n \t\t{\n-\t\t\t\"team maintainer\",\n-\t\t\t&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleMaintainer}}},\n-\t\t\ttrue,\n-\t\t\tfalse,\n+\t\t\tname:            \"team maintainer\",\n+\t\t\tuser:            &fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleMaintainer}}},\n+\t\t\tshouldFailWrite: true,\n+\t\t\tshouldFailRead:  true,\n \t\t},\n \t\t{\n-\t\t\t\"team observer\",\n-\t\t\t&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleObserver}}},\n-\t\t\ttrue,\n-\t\t\ttrue,\n+\t\t\tname:            \"team observer\",\n+\t\t\tuser:            &fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleObserver}}},\n+\t\t\tshouldFailWrite: true,\n+\t\t\tshouldFailRead:  true,\n \t\t},\n \t}\n \tfor _, tt := range testCases {"
        },
        {
          "filename": "server/service/software.go",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -44,7 +44,9 @@ func listSoftwareEndpoint(ctx context.Context, request interface{}, svc fleet.Se\n }\n \n func (svc Service) ListSoftware(ctx context.Context, opt fleet.SoftwareListOptions) ([]fleet.Software, error) {\n-\tif err := svc.authz.Authorize(ctx, &fleet.Software{}, fleet.ActionRead); err != nil {\n+\tif err := svc.authz.Authorize(ctx, &fleet.AuthzSoftwareInventory{\n+\t\tTeamID: opt.TeamID,\n+\t}, fleet.ActionRead); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -82,7 +84,9 @@ func countSoftwareEndpoint(ctx context.Context, request interface{}, svc fleet.S\n }\n \n func (svc Service) CountSoftware(ctx context.Context, opt fleet.SoftwareListOptions) (int, error) {\n-\tif err := svc.authz.Authorize(ctx, &fleet.Software{}, fleet.ActionRead); err != nil {\n+\tif err := svc.authz.Authorize(ctx, &fleet.AuthzSoftwareInventory{\n+\t\tTeamID: opt.TeamID,\n+\t}, fleet.ActionRead); err != nil {\n \t\treturn 0, err\n \t}\n "
        },
        {
          "filename": "server/service/software_test.go",
          "status": "modified",
          "additions": 148,
          "deletions": 1,
          "patch": "@@ -23,7 +23,11 @@ func TestService_ListSoftware(t *testing.T) {\n \t\treturn []fleet.Software{}, nil\n \t}\n \n-\tuser := &fleet.User{ID: 3, Email: \"foo@bar.com\", GlobalRole: ptr.String(fleet.RoleObserver)}\n+\tuser := &fleet.User{\n+\t\tID:         3,\n+\t\tEmail:      \"foo@bar.com\",\n+\t\tGlobalRole: ptr.String(fleet.RoleAdmin),\n+\t}\n \n \tsvc := newTestService(t, ds, nil, nil)\n \tctx := context.Background()\n@@ -48,3 +52,146 @@ func TestService_ListSoftware(t *testing.T) {\n \tassert.Equal(t, fleet.ListOptions{PerPage: 11, Page: 2, OrderKey: \"id\", OrderDirection: fleet.OrderAscending}, calledWithOpt.ListOptions)\n \tassert.True(t, calledWithOpt.WithHostCounts)\n }\n+\n+func TestServiceSoftwareInventoryAuth(t *testing.T) {\n+\tds := new(mock.Store)\n+\n+\tds.ListSoftwareFunc = func(ctx context.Context, opt fleet.SoftwareListOptions) ([]fleet.Software, error) {\n+\t\treturn []fleet.Software{}, nil\n+\t}\n+\tds.CountSoftwareFunc = func(ctx context.Context, opt fleet.SoftwareListOptions) (int, error) {\n+\t\treturn 0, nil\n+\t}\n+\tsvc := newTestService(t, ds, nil, nil)\n+\n+\tfor _, tc := range []struct {\n+\t\tname                 string\n+\t\tuser                 *fleet.User\n+\t\tshouldFailGlobalRead bool\n+\t\tshouldFailTeamRead   bool\n+\t}{\n+\t\t{\n+\t\t\tname: \"global-admin\",\n+\t\t\tuser: &fleet.User{\n+\t\t\t\tID:         1,\n+\t\t\t\tGlobalRole: ptr.String(fleet.RoleAdmin),\n+\t\t\t},\n+\t\t\tshouldFailGlobalRead: false,\n+\t\t\tshouldFailTeamRead:   false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"global-maintainer\",\n+\t\t\tuser: &fleet.User{\n+\t\t\t\tID:         1,\n+\t\t\t\tGlobalRole: ptr.String(fleet.RoleMaintainer),\n+\t\t\t},\n+\t\t\tshouldFailGlobalRead: false,\n+\t\t\tshouldFailTeamRead:   false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"global-observer\",\n+\t\t\tuser: &fleet.User{\n+\t\t\t\tID:         1,\n+\t\t\t\tGlobalRole: ptr.String(fleet.RoleObserver),\n+\t\t\t},\n+\t\t\tshouldFailGlobalRead: false,\n+\t\t\tshouldFailTeamRead:   false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"team-admin-belongs-to-team\",\n+\t\t\tuser: &fleet.User{\n+\t\t\t\tID: 1,\n+\t\t\t\tTeams: []fleet.UserTeam{{\n+\t\t\t\t\tTeam: fleet.Team{ID: 1},\n+\t\t\t\t\tRole: fleet.RoleAdmin,\n+\t\t\t\t}},\n+\t\t\t},\n+\t\t\tshouldFailGlobalRead: true,\n+\t\t\tshouldFailTeamRead:   false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"team-maintainer-belongs-to-team\",\n+\t\t\tuser: &fleet.User{\n+\t\t\t\tID: 1,\n+\t\t\t\tTeams: []fleet.UserTeam{{\n+\t\t\t\t\tTeam: fleet.Team{ID: 1},\n+\t\t\t\t\tRole: fleet.RoleMaintainer,\n+\t\t\t\t}},\n+\t\t\t},\n+\t\t\tshouldFailGlobalRead: true,\n+\t\t\tshouldFailTeamRead:   false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"team-observer-belongs-to-team\",\n+\t\t\tuser: &fleet.User{\n+\t\t\t\tID: 1,\n+\t\t\t\tTeams: []fleet.UserTeam{{\n+\t\t\t\t\tTeam: fleet.Team{ID: 1},\n+\t\t\t\t\tRole: fleet.RoleObserver,\n+\t\t\t\t}},\n+\t\t\t},\n+\t\t\tshouldFailGlobalRead: true,\n+\t\t\tshouldFailTeamRead:   false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"team-admin-does-not-belong-to-team\",\n+\t\t\tuser: &fleet.User{\n+\t\t\t\tID: 1,\n+\t\t\t\tTeams: []fleet.UserTeam{{\n+\t\t\t\t\tTeam: fleet.Team{ID: 2},\n+\t\t\t\t\tRole: fleet.RoleAdmin,\n+\t\t\t\t}},\n+\t\t\t},\n+\t\t\tshouldFailGlobalRead: true,\n+\t\t\tshouldFailTeamRead:   true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"team-maintainer-does-not-belong-to-team\",\n+\t\t\tuser: &fleet.User{\n+\t\t\t\tID: 1,\n+\t\t\t\tTeams: []fleet.UserTeam{{\n+\t\t\t\t\tTeam: fleet.Team{ID: 2},\n+\t\t\t\t\tRole: fleet.RoleMaintainer,\n+\t\t\t\t}},\n+\t\t\t},\n+\t\t\tshouldFailGlobalRead: true,\n+\t\t\tshouldFailTeamRead:   true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"team-observer-does-not-belong-to-team\",\n+\t\t\tuser: &fleet.User{\n+\t\t\t\tID: 1,\n+\t\t\t\tTeams: []fleet.UserTeam{{\n+\t\t\t\t\tTeam: fleet.Team{ID: 2},\n+\t\t\t\t\tRole: fleet.RoleObserver,\n+\t\t\t\t}},\n+\t\t\t},\n+\t\t\tshouldFailGlobalRead: true,\n+\t\t\tshouldFailTeamRead:   true,\n+\t\t},\n+\t} {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tctx := viewer.NewContext(context.Background(), viewer.Viewer{User: tc.user})\n+\n+\t\t\t// List all software.\n+\t\t\t_, err := svc.ListSoftware(ctx, fleet.SoftwareListOptions{})\n+\t\t\tcheckAuthErr(t, tc.shouldFailGlobalRead, err)\n+\n+\t\t\t// Count all software.\n+\t\t\t_, err = svc.CountSoftware(ctx, fleet.SoftwareListOptions{})\n+\t\t\tcheckAuthErr(t, tc.shouldFailGlobalRead, err)\n+\n+\t\t\t// List software for a team.\n+\t\t\t_, err = svc.ListSoftware(ctx, fleet.SoftwareListOptions{\n+\t\t\t\tTeamID: ptr.Uint(1),\n+\t\t\t})\n+\t\t\tcheckAuthErr(t, tc.shouldFailTeamRead, err)\n+\n+\t\t\t// Count software for a team.\n+\t\t\t_, err = svc.CountSoftware(ctx, fleet.SoftwareListOptions{\n+\t\t\t\tTeamID: ptr.Uint(1),\n+\t\t\t})\n+\t\t\tcheckAuthErr(t, tc.shouldFailTeamRead, err)\n+\t\t})\n+\t}\n+}"
        },
        {
          "filename": "server/service/team_schedule.go",
          "status": "modified",
          "additions": 13,
          "deletions": 5,
          "patch": "@@ -2,6 +2,7 @@ package service\n \n import (\n \t\"context\"\n+\t\"fmt\"\n \n \t\"github.com/fleetdm/fleet/v4/server/fleet\"\n \t\"github.com/fleetdm/fleet/v4/server/ptr\"\n@@ -36,7 +37,9 @@ func getTeamScheduleEndpoint(ctx context.Context, request interface{}, svc fleet\n }\n \n func (svc Service) GetTeamScheduledQueries(ctx context.Context, teamID uint, opts fleet.ListOptions) ([]*fleet.ScheduledQuery, error) {\n-\tif err := svc.authz.Authorize(ctx, &fleet.Pack{TeamIDs: []uint{teamID}}, fleet.ActionRead); err != nil {\n+\tif err := svc.authz.Authorize(ctx, &fleet.Pack{\n+\t\tType: ptr.String(fmt.Sprintf(\"team-%d\", teamID)),\n+\t}, fleet.ActionRead); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -92,14 +95,15 @@ func teamScheduleQueryEndpoint(ctx context.Context, request interface{}, svc fle\n \tif err != nil {\n \t\treturn teamScheduleQueryResponse{Err: err}, nil\n \t}\n-\t_ = resp\n \treturn teamScheduleQueryResponse{\n \t\tScheduled: resp,\n \t}, nil\n }\n \n func (svc Service) TeamScheduleQuery(ctx context.Context, teamID uint, q *fleet.ScheduledQuery) (*fleet.ScheduledQuery, error) {\n-\tif err := svc.authz.Authorize(ctx, &fleet.Pack{TeamIDs: []uint{teamID}}, fleet.ActionWrite); err != nil {\n+\tif err := svc.authz.Authorize(ctx, &fleet.Pack{\n+\t\tType: ptr.String(fmt.Sprintf(\"team-%d\", teamID)),\n+\t}, fleet.ActionWrite); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -140,7 +144,9 @@ func modifyTeamScheduleEndpoint(ctx context.Context, request interface{}, svc fl\n }\n \n func (svc Service) ModifyTeamScheduledQueries(ctx context.Context, teamID uint, scheduledQueryID uint, query fleet.ScheduledQueryPayload) (*fleet.ScheduledQuery, error) {\n-\tif err := svc.authz.Authorize(ctx, &fleet.Pack{TeamIDs: []uint{teamID}}, fleet.ActionWrite); err != nil {\n+\tif err := svc.authz.Authorize(ctx, &fleet.Pack{\n+\t\tType: ptr.String(fmt.Sprintf(\"team-%d\", teamID)),\n+\t}, fleet.ActionWrite); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -180,7 +186,9 @@ func deleteTeamScheduleEndpoint(ctx context.Context, request interface{}, svc fl\n }\n \n func (svc Service) DeleteTeamScheduledQueries(ctx context.Context, teamID uint, scheduledQueryID uint) error {\n-\tif err := svc.authz.Authorize(ctx, &fleet.Pack{TeamIDs: []uint{teamID}}, fleet.ActionWrite); err != nil {\n+\tif err := svc.authz.Authorize(ctx, &fleet.Pack{\n+\t\tType: ptr.String(fmt.Sprintf(\"team-%d\", teamID)),\n+\t}, fleet.ActionWrite); err != nil {\n \t\treturn err\n \t}\n \treturn svc.ds.DeleteScheduledQuery(ctx, scheduledQueryID)"
        },
        {
          "filename": "server/service/team_schedule_test.go",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -2,6 +2,7 @@ package service\n \n import (\n \t\"context\"\n+\t\"fmt\"\n \t\"testing\"\n \n \t\"github.com/fleetdm/fleet/v4/server/contexts/viewer\"\n@@ -15,7 +16,10 @@ func TestTeamScheduleAuth(t *testing.T) {\n \tsvc := newTestService(t, ds, nil, nil)\n \n \tds.EnsureTeamPackFunc = func(ctx context.Context, teamID uint) (*fleet.Pack, error) {\n-\t\treturn &fleet.Pack{ID: 999}, nil\n+\t\treturn &fleet.Pack{\n+\t\t\tID:   999,\n+\t\t\tType: ptr.String(fmt.Sprintf(\"team-%d\", teamID)),\n+\t\t}, nil\n \t}\n \tds.ListScheduledQueriesInPackWithStatsFunc = func(ctx context.Context, id uint, opts fleet.ListOptions) ([]*fleet.ScheduledQuery, error) {\n \t\treturn nil, nil\n@@ -76,7 +80,7 @@ func TestTeamScheduleAuth(t *testing.T) {\n \t\t\t\"team observer, belongs to team\",\n \t\t\t&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleObserver}}},\n \t\t\ttrue,\n-\t\t\ttrue,\n+\t\t\tfalse,\n \t\t},\n \t\t{\n \t\t\t\"team maintainer, DOES NOT belong to team\","
        },
        {
          "filename": "server/service/users.go",
          "status": "modified",
          "additions": 64,
          "deletions": 21,
          "patch": "@@ -11,6 +11,7 @@ import (\n \n \t\"github.com/fleetdm/fleet/v4/server\"\n \t\"github.com/fleetdm/fleet/v4/server/authz\"\n+\tauthz_ctx \"github.com/fleetdm/fleet/v4/server/contexts/authz\"\n \t\"github.com/fleetdm/fleet/v4/server/contexts/ctxerr\"\n \t\"github.com/fleetdm/fleet/v4/server/contexts/viewer\"\n \t\"github.com/fleetdm/fleet/v4/server/fleet\"\n@@ -140,7 +141,11 @@ func listUsersEndpoint(ctx context.Context, request interface{}, svc fleet.Servi\n }\n \n func (svc *Service) ListUsers(ctx context.Context, opt fleet.UserListOptions) ([]*fleet.User, error) {\n-\tif err := svc.authz.Authorize(ctx, &fleet.User{}, fleet.ActionRead); err != nil {\n+\tuser := &fleet.User{}\n+\tif opt.TeamID != 0 {\n+\t\tuser.Teams = []fleet.UserTeam{{Team: fleet.Team{ID: opt.TeamID}}}\n+\t}\n+\tif err := svc.authz.Authorize(ctx, user, fleet.ActionRead); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -216,12 +221,27 @@ func getUserEndpoint(ctx context.Context, request interface{}, svc fleet.Service\n \treturn getUserResponse{User: user, AvailableTeams: availableTeams}, nil\n }\n \n+// setAuthCheckedOnPreAuthErr can be used to set the authentication as checked\n+// in case of errors that happened before an auth check can be performed.\n+// Otherwise the endpoints return a \"authentication skipped\" error instead of\n+// the actual returned error.\n+func setAuthCheckedOnPreAuthErr(ctx context.Context) {\n+\tif az, ok := authz_ctx.FromContext(ctx); ok {\n+\t\taz.SetChecked()\n+\t}\n+}\n+\n func (svc *Service) User(ctx context.Context, id uint) (*fleet.User, error) {\n-\tif err := svc.authz.Authorize(ctx, &fleet.User{ID: id}, fleet.ActionRead); err != nil {\n-\t\treturn nil, err\n+\tuser, err := svc.ds.UserByID(ctx, id)\n+\tif err != nil {\n+\t\tsetAuthCheckedOnPreAuthErr(ctx)\n+\t\treturn nil, ctxerr.Wrap(ctx, err)\n \t}\n \n-\treturn svc.ds.UserByID(ctx, id)\n+\tif err := svc.authz.Authorize(ctx, user, fleet.ActionRead); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn user, nil\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -251,12 +271,9 @@ func modifyUserEndpoint(ctx context.Context, request interface{}, svc fleet.Serv\n }\n \n func (svc *Service) ModifyUser(ctx context.Context, userID uint, p fleet.UserPayload) (*fleet.User, error) {\n-\tif err := svc.authz.Authorize(ctx, &fleet.User{}, fleet.ActionRead); err != nil {\n-\t\treturn nil, err\n-\t}\n-\n \tuser, err := svc.User(ctx, userID)\n \tif err != nil {\n+\t\tsetAuthCheckedOnPreAuthErr(ctx)\n \t\treturn nil, err\n \t}\n \n@@ -326,7 +343,10 @@ func (svc *Service) ModifyUser(ctx context.Context, userID uint, p fleet.UserPay\n \n \tif p.GlobalRole != nil && *p.GlobalRole != \"\" {\n \t\tif currentUser.GlobalRole == nil {\n-\t\t\treturn nil, ctxerr.New(ctx, \"Cannot edit global role as a team member\")\n+\t\t\treturn nil, authz.ForbiddenWithInternal(\n+\t\t\t\t\"cannot edit global role as a team member\",\n+\t\t\t\tcurrentUser, user, fleet.ActionWriteRole,\n+\t\t\t)\n \t\t}\n \n \t\tif p.Teams != nil && len(*p.Teams) > 0 {\n@@ -336,7 +356,10 @@ func (svc *Service) ModifyUser(ctx context.Context, userID uint, p fleet.UserPay\n \t\tuser.Teams = []fleet.UserTeam{}\n \t} else if p.Teams != nil {\n \t\tif !isAdminOfTheModifiedTeams(currentUser, user.Teams, *p.Teams) {\n-\t\t\treturn nil, ctxerr.New(ctx, \"Cannot modify teams in that way\")\n+\t\t\treturn nil, authz.ForbiddenWithInternal(\n+\t\t\t\t\"cannot modify teams in that way\",\n+\t\t\t\tcurrentUser, user, fleet.ActionWriteRole,\n+\t\t\t)\n \t\t}\n \t\tuser.Teams = *p.Teams\n \t\tuser.GlobalRole = nil\n@@ -379,10 +402,14 @@ func deleteUserEndpoint(ctx context.Context, request interface{}, svc fleet.Serv\n }\n \n func (svc *Service) DeleteUser(ctx context.Context, id uint) error {\n-\tif err := svc.authz.Authorize(ctx, &fleet.User{ID: id}, fleet.ActionWrite); err != nil {\n+\tuser, err := svc.ds.UserByID(ctx, id)\n+\tif err != nil {\n+\t\tsetAuthCheckedOnPreAuthErr(ctx)\n+\t\treturn ctxerr.Wrap(ctx, err)\n+\t}\n+\tif err := svc.authz.Authorize(ctx, user, fleet.ActionWrite); err != nil {\n \t\treturn err\n \t}\n-\n \treturn svc.ds.DeleteUser(ctx, id)\n }\n \n@@ -616,35 +643,51 @@ func (svc *Service) ChangeUserEmail(ctx context.Context, token string) (string,\n \treturn svc.ds.ConfirmPendingEmailChange(ctx, vc.UserID(), token)\n }\n \n+// isAdminOfTheModifiedTeams checks whether the current user is allowed to modify the user\n+// roles in the teams.\n+//\n+// TODO: End-goal is to move all this logic to policy.rego.\n func isAdminOfTheModifiedTeams(currentUser *fleet.User, originalUserTeams, newUserTeams []fleet.UserTeam) bool {\n-\t// If the user is of the right global role, then they can modify the teams\n-\tif currentUser.GlobalRole != nil && (*currentUser.GlobalRole == fleet.RoleAdmin || *currentUser.GlobalRole == fleet.RoleMaintainer) {\n+\t// Global admins can modify all user teams roles.\n+\tif currentUser.GlobalRole != nil && *currentUser.GlobalRole == fleet.RoleAdmin {\n \t\treturn true\n \t}\n \n-\t// otherwise, gather the resulting teams\n-\tresultingTeams := make(map[uint]string)\n+\t// Otherwise, make a map of the original and resulting teams.\n+\tnewTeams := make(map[uint]string)\n \tfor _, team := range newUserTeams {\n-\t\tresultingTeams[team.ID] = team.Role\n+\t\tnewTeams[team.ID] = team.Role\n+\t}\n+\toriginalTeams := make(map[uint]struct{})\n+\tfor _, team := range originalUserTeams {\n+\t\toriginalTeams[team.ID] = struct{}{}\n \t}\n \n-\t// and see which ones were removed or changed from the original\n+\t// See which ones were removed or changed from the original.\n \tteamsAffected := make(map[uint]struct{})\n \tfor _, team := range originalUserTeams {\n-\t\tif resultingTeams[team.ID] != team.Role {\n+\t\tif newTeams[team.ID] != team.Role {\n+\t\t\tteamsAffected[team.ID] = struct{}{}\n+\t\t}\n+\t}\n+\n+\t// See which ones of the new are not in the original.\n+\tfor _, team := range newUserTeams {\n+\t\tif _, ok := originalTeams[team.ID]; !ok {\n \t\t\tteamsAffected[team.ID] = struct{}{}\n \t\t}\n \t}\n \n-\t// then gather the teams the current user is admin for\n+\t// Then gather the teams the current user is admin for.\n \tcurrentUserTeamAdmin := make(map[uint]struct{})\n \tfor _, team := range currentUser.Teams {\n \t\tif team.Role == fleet.RoleAdmin {\n \t\t\tcurrentUserTeamAdmin[team.ID] = struct{}{}\n \t\t}\n \t}\n \n-\t// and let's check that the teams that were either removed or changed are also teams this user is an admin of\n+\t// And finally, let's check that the teams that were either removed\n+\t// or changed are also teams this user is an admin of.\n \tfor teamID := range teamsAffected {\n \t\tif _, ok := currentUserTeamAdmin[teamID]; !ok {\n \t\t\treturn false"
        },
        {
          "filename": "server/service/users_test.go",
          "status": "modified",
          "additions": 703,
          "deletions": 80,
          "patch": "@@ -7,6 +7,7 @@ import (\n \t\"testing\"\n \t\"time\"\n \n+\t\"github.com/fleetdm/fleet/v4/server/authz\"\n \t\"github.com/fleetdm/fleet/v4/server/contexts/ctxerr\"\n \t\"github.com/fleetdm/fleet/v4/server/contexts/viewer\"\n \t\"github.com/fleetdm/fleet/v4/server/datastore/mysql\"\n@@ -41,18 +42,27 @@ func TestUserAuth(t *testing.T) {\n \tds.InviteByEmailFunc = func(ctx context.Context, email string) (*fleet.Invite, error) {\n \t\treturn nil, errors.New(\"AA\")\n \t}\n+\n+\tuserTeamMaintainerID := uint(999)\n+\tuserGlobalMaintainerID := uint(888)\n+\tvar self *fleet.User // to be set by tests\n \tds.UserByIDFunc = func(ctx context.Context, id uint) (*fleet.User, error) {\n-\t\tif id == 999 {\n+\t\tswitch id {\n+\t\tcase userTeamMaintainerID:\n \t\t\treturn &fleet.User{\n-\t\t\t\tID:    999,\n+\t\t\t\tID:    userTeamMaintainerID,\n \t\t\t\tTeams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleMaintainer}},\n \t\t\t}, nil\n+\t\tcase userGlobalMaintainerID:\n+\t\t\treturn &fleet.User{\n+\t\t\t\tID:         userGlobalMaintainerID,\n+\t\t\t\tGlobalRole: ptr.String(fleet.RoleMaintainer),\n+\t\t\t}, nil\n+\t\tdefault:\n+\t\t\treturn self, nil\n \t\t}\n-\t\treturn &fleet.User{\n-\t\t\tID:         888,\n-\t\t\tGlobalRole: ptr.String(fleet.RoleMaintainer),\n-\t\t}, nil\n \t}\n+\n \tds.SaveUserFunc = func(ctx context.Context, user *fleet.User) error {\n \t\treturn nil\n \t}\n@@ -70,92 +80,277 @@ func TestUserAuth(t *testing.T) {\n \t}\n \n \ttestCases := []struct {\n-\t\tname                  string\n-\t\tuser                  *fleet.User\n+\t\tname string\n+\t\tuser *fleet.User\n+\n \t\tshouldFailGlobalWrite bool\n \t\tshouldFailTeamWrite   bool\n-\t\tshouldFailRead        bool\n-\t\tshouldFailDeleteReset bool\n+\n+\t\tshouldFailWriteRoleGlobalToGlobal    bool\n+\t\tshouldFailWriteRoleGlobalToTeam      bool\n+\t\tshouldFailWriteRoleTeamToAnotherTeam bool\n+\t\tshouldFailWriteRoleTeamToGlobal      bool\n+\n+\t\tshouldFailWriteRoleOwnDomain bool\n+\n+\t\tshouldFailGlobalRead bool\n+\t\tshouldFailTeamRead   bool\n+\n+\t\tshouldFailGlobalDelete bool\n+\t\tshouldFailTeamDelete   bool\n+\n+\t\tshouldFailGlobalPasswordReset bool\n+\t\tshouldFailTeamPasswordReset   bool\n+\n+\t\tshouldFailGlobalChangePassword bool\n+\t\tshouldFailTeamChangePassword   bool\n+\n+\t\tshouldFailListAll  bool\n+\t\tshouldFailListTeam bool\n \t}{\n \t\t{\n-\t\t\t\"global admin\",\n-\t\t\t&fleet.User{GlobalRole: ptr.String(fleet.RoleAdmin)},\n-\t\t\tfalse,\n-\t\t\tfalse,\n-\t\t\tfalse,\n-\t\t\tfalse,\n+\t\t\tname:                                 \"global admin\",\n+\t\t\tuser:                                 &fleet.User{ID: 1000, GlobalRole: ptr.String(fleet.RoleAdmin)},\n+\t\t\tshouldFailGlobalWrite:                false,\n+\t\t\tshouldFailTeamWrite:                  false,\n+\t\t\tshouldFailWriteRoleGlobalToGlobal:    false,\n+\t\t\tshouldFailWriteRoleGlobalToTeam:      false,\n+\t\t\tshouldFailWriteRoleTeamToAnotherTeam: false,\n+\t\t\tshouldFailWriteRoleTeamToGlobal:      false,\n+\t\t\tshouldFailWriteRoleOwnDomain:         false,\n+\t\t\tshouldFailGlobalRead:                 false,\n+\t\t\tshouldFailTeamRead:                   false,\n+\t\t\tshouldFailGlobalDelete:               false,\n+\t\t\tshouldFailTeamDelete:                 false,\n+\t\t\tshouldFailGlobalPasswordReset:        false,\n+\t\t\tshouldFailTeamPasswordReset:          false,\n+\t\t\tshouldFailGlobalChangePassword:       false,\n+\t\t\tshouldFailTeamChangePassword:         false,\n+\t\t\tshouldFailListAll:                    false,\n+\t\t\tshouldFailListTeam:                   false,\n \t\t},\n \t\t{\n-\t\t\t\"global maintainer\",\n-\t\t\t&fleet.User{GlobalRole: ptr.String(fleet.RoleMaintainer)},\n-\t\t\ttrue,\n-\t\t\ttrue,\n-\t\t\tfalse,\n-\t\t\ttrue,\n+\t\t\tname:                                 \"global maintainer\",\n+\t\t\tuser:                                 &fleet.User{ID: 1000, GlobalRole: ptr.String(fleet.RoleMaintainer)},\n+\t\t\tshouldFailGlobalWrite:                true,\n+\t\t\tshouldFailTeamWrite:                  true,\n+\t\t\tshouldFailWriteRoleGlobalToGlobal:    true,\n+\t\t\tshouldFailWriteRoleGlobalToTeam:      true,\n+\t\t\tshouldFailWriteRoleTeamToAnotherTeam: true,\n+\t\t\tshouldFailWriteRoleTeamToGlobal:      true,\n+\t\t\tshouldFailWriteRoleOwnDomain:         true,\n+\t\t\tshouldFailGlobalRead:                 true,\n+\t\t\tshouldFailTeamRead:                   true,\n+\t\t\tshouldFailGlobalDelete:               true,\n+\t\t\tshouldFailTeamDelete:                 true,\n+\t\t\tshouldFailGlobalPasswordReset:        true,\n+\t\t\tshouldFailTeamPasswordReset:          true,\n+\t\t\tshouldFailGlobalChangePassword:       true,\n+\t\t\tshouldFailTeamChangePassword:         true,\n+\t\t\tshouldFailListAll:                    true,\n+\t\t\tshouldFailListTeam:                   true,\n \t\t},\n \t\t{\n-\t\t\t\"global observer\",\n-\t\t\t&fleet.User{GlobalRole: ptr.String(fleet.RoleObserver)},\n-\t\t\ttrue,\n-\t\t\ttrue,\n-\t\t\tfalse,\n-\t\t\ttrue,\n+\t\t\tname:                                 \"global observer\",\n+\t\t\tuser:                                 &fleet.User{ID: 1000, GlobalRole: ptr.String(fleet.RoleObserver)},\n+\t\t\tshouldFailGlobalWrite:                true,\n+\t\t\tshouldFailTeamWrite:                  true,\n+\t\t\tshouldFailWriteRoleGlobalToGlobal:    true,\n+\t\t\tshouldFailWriteRoleGlobalToTeam:      true,\n+\t\t\tshouldFailWriteRoleTeamToAnotherTeam: true,\n+\t\t\tshouldFailWriteRoleTeamToGlobal:      true,\n+\t\t\tshouldFailWriteRoleOwnDomain:         true,\n+\t\t\tshouldFailGlobalRead:                 true,\n+\t\t\tshouldFailTeamRead:                   true,\n+\t\t\tshouldFailGlobalDelete:               true,\n+\t\t\tshouldFailTeamDelete:                 true,\n+\t\t\tshouldFailGlobalPasswordReset:        true,\n+\t\t\tshouldFailTeamPasswordReset:          true,\n+\t\t\tshouldFailGlobalChangePassword:       true,\n+\t\t\tshouldFailTeamChangePassword:         true,\n+\t\t\tshouldFailListAll:                    true,\n+\t\t\tshouldFailListTeam:                   true,\n \t\t},\n \t\t{\n-\t\t\t\"team admin, belongs to team\",\n-\t\t\t&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleAdmin}}},\n-\t\t\ttrue,\n-\t\t\tfalse,\n-\t\t\tfalse,\n-\t\t\ttrue,\n+\t\t\tname:                                 \"team admin, belongs to team\",\n+\t\t\tuser:                                 &fleet.User{ID: 1000, Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleAdmin}}},\n+\t\t\tshouldFailGlobalWrite:                true,\n+\t\t\tshouldFailTeamWrite:                  false,\n+\t\t\tshouldFailWriteRoleGlobalToGlobal:    true,\n+\t\t\tshouldFailWriteRoleGlobalToTeam:      true,\n+\t\t\tshouldFailWriteRoleTeamToAnotherTeam: true,\n+\t\t\tshouldFailWriteRoleTeamToGlobal:      true,\n+\t\t\tshouldFailWriteRoleOwnDomain:         false,\n+\t\t\tshouldFailGlobalRead:                 true,\n+\t\t\tshouldFailTeamRead:                   false,\n+\t\t\tshouldFailGlobalDelete:               true,\n+\t\t\tshouldFailTeamDelete:                 false,\n+\t\t\tshouldFailGlobalPasswordReset:        true,\n+\t\t\tshouldFailTeamPasswordReset:          true,\n+\t\t\tshouldFailGlobalChangePassword:       true,\n+\t\t\tshouldFailTeamChangePassword:         true,\n+\t\t\tshouldFailListAll:                    true,\n+\t\t\tshouldFailListTeam:                   false,\n \t\t},\n \t\t{\n-\t\t\t\"team maintainer, belongs to team\",\n-\t\t\t&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleMaintainer}}},\n-\t\t\ttrue,\n-\t\t\ttrue,\n-\t\t\tfalse,\n-\t\t\ttrue,\n+\t\t\tname:                                 \"team maintainer, belongs to team\",\n+\t\t\tuser:                                 &fleet.User{ID: 1000, Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleMaintainer}}},\n+\t\t\tshouldFailGlobalWrite:                true,\n+\t\t\tshouldFailTeamWrite:                  true,\n+\t\t\tshouldFailWriteRoleGlobalToGlobal:    true,\n+\t\t\tshouldFailWriteRoleGlobalToTeam:      true,\n+\t\t\tshouldFailWriteRoleTeamToAnotherTeam: true,\n+\t\t\tshouldFailWriteRoleTeamToGlobal:      true,\n+\t\t\tshouldFailWriteRoleOwnDomain:         true,\n+\t\t\tshouldFailGlobalRead:                 true,\n+\t\t\tshouldFailTeamRead:                   true,\n+\t\t\tshouldFailGlobalDelete:               true,\n+\t\t\tshouldFailTeamDelete:                 true,\n+\t\t\tshouldFailGlobalPasswordReset:        true,\n+\t\t\tshouldFailTeamPasswordReset:          true,\n+\t\t\tshouldFailGlobalChangePassword:       true,\n+\t\t\tshouldFailTeamChangePassword:         true,\n+\t\t\tshouldFailListAll:                    true,\n+\t\t\tshouldFailListTeam:                   true,\n \t\t},\n \t\t{\n-\t\t\t\"team observer, belongs to team\",\n-\t\t\t&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleObserver}}},\n-\t\t\ttrue,\n-\t\t\ttrue,\n-\t\t\tfalse,\n-\t\t\ttrue,\n+\t\t\tname:                                 \"team observer, belongs to team\",\n+\t\t\tuser:                                 &fleet.User{ID: 1000, Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleObserver}}},\n+\t\t\tshouldFailGlobalWrite:                true,\n+\t\t\tshouldFailTeamWrite:                  true,\n+\t\t\tshouldFailWriteRoleGlobalToGlobal:    true,\n+\t\t\tshouldFailWriteRoleGlobalToTeam:      true,\n+\t\t\tshouldFailWriteRoleTeamToAnotherTeam: true,\n+\t\t\tshouldFailWriteRoleTeamToGlobal:      true,\n+\t\t\tshouldFailWriteRoleOwnDomain:         true,\n+\t\t\tshouldFailGlobalRead:                 true,\n+\t\t\tshouldFailTeamRead:                   true,\n+\t\t\tshouldFailGlobalDelete:               true,\n+\t\t\tshouldFailTeamDelete:                 true,\n+\t\t\tshouldFailGlobalPasswordReset:        true,\n+\t\t\tshouldFailTeamPasswordReset:          true,\n+\t\t\tshouldFailGlobalChangePassword:       true,\n+\t\t\tshouldFailTeamChangePassword:         true,\n+\t\t\tshouldFailListAll:                    true,\n+\t\t\tshouldFailListTeam:                   true,\n \t\t},\n \t\t{\n-\t\t\t\"team maintainer, DOES NOT belong to team\",\n-\t\t\t&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 2}, Role: fleet.RoleMaintainer}}},\n-\t\t\ttrue,\n-\t\t\ttrue,\n-\t\t\tfalse,\n-\t\t\ttrue,\n+\t\t\tname:                                 \"team maintainer, DOES NOT belong to team\",\n+\t\t\tuser:                                 &fleet.User{ID: 1000, Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 2}, Role: fleet.RoleMaintainer}}},\n+\t\t\tshouldFailGlobalWrite:                true,\n+\t\t\tshouldFailTeamWrite:                  true,\n+\t\t\tshouldFailWriteRoleGlobalToGlobal:    true,\n+\t\t\tshouldFailWriteRoleGlobalToTeam:      true,\n+\t\t\tshouldFailWriteRoleTeamToAnotherTeam: true,\n+\t\t\tshouldFailWriteRoleTeamToGlobal:      true,\n+\t\t\tshouldFailWriteRoleOwnDomain:         true,\n+\t\t\tshouldFailGlobalRead:                 true,\n+\t\t\tshouldFailTeamRead:                   true,\n+\t\t\tshouldFailGlobalDelete:               true,\n+\t\t\tshouldFailTeamDelete:                 true,\n+\t\t\tshouldFailGlobalPasswordReset:        true,\n+\t\t\tshouldFailTeamPasswordReset:          true,\n+\t\t\tshouldFailGlobalChangePassword:       true,\n+\t\t\tshouldFailTeamChangePassword:         true,\n+\t\t\tshouldFailListAll:                    true,\n+\t\t\tshouldFailListTeam:                   true,\n \t\t},\n \t\t{\n-\t\t\t\"team admin, DOES NOT belong to team\",\n-\t\t\t&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 2}, Role: fleet.RoleAdmin}}},\n-\t\t\ttrue,\n-\t\t\ttrue,\n-\t\t\tfalse,\n-\t\t\ttrue,\n+\t\t\tname:                                 \"team admin, DOES NOT belong to team\",\n+\t\t\tuser:                                 &fleet.User{ID: 1000, Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 2}, Role: fleet.RoleAdmin}}},\n+\t\t\tshouldFailGlobalWrite:                true,\n+\t\t\tshouldFailTeamWrite:                  true,\n+\t\t\tshouldFailWriteRoleGlobalToGlobal:    true,\n+\t\t\tshouldFailWriteRoleGlobalToTeam:      true,\n+\t\t\tshouldFailWriteRoleTeamToAnotherTeam: true,\n+\t\t\tshouldFailWriteRoleTeamToGlobal:      true,\n+\t\t\tshouldFailWriteRoleOwnDomain:         false, // this is testing changing its own role in the team it belongs to.\n+\t\t\tshouldFailGlobalRead:                 true,\n+\t\t\tshouldFailTeamRead:                   true,\n+\t\t\tshouldFailGlobalDelete:               true,\n+\t\t\tshouldFailTeamDelete:                 true,\n+\t\t\tshouldFailGlobalPasswordReset:        true,\n+\t\t\tshouldFailTeamPasswordReset:          true,\n+\t\t\tshouldFailGlobalChangePassword:       true,\n+\t\t\tshouldFailTeamChangePassword:         true,\n+\t\t\tshouldFailListAll:                    true,\n+\t\t\tshouldFailListTeam:                   true,\n \t\t},\n \t\t{\n-\t\t\t\"team observer, DOES NOT belong to team\",\n-\t\t\t&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 2}, Role: fleet.RoleObserver}}},\n-\t\t\ttrue,\n-\t\t\ttrue,\n-\t\t\tfalse,\n-\t\t\ttrue,\n+\t\t\tname:                                 \"team observer, DOES NOT belong to team\",\n+\t\t\tuser:                                 &fleet.User{ID: 1000, Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 2}, Role: fleet.RoleObserver}}},\n+\t\t\tshouldFailGlobalWrite:                true,\n+\t\t\tshouldFailTeamWrite:                  true,\n+\t\t\tshouldFailWriteRoleGlobalToGlobal:    true,\n+\t\t\tshouldFailWriteRoleGlobalToTeam:      true,\n+\t\t\tshouldFailWriteRoleTeamToAnotherTeam: true,\n+\t\t\tshouldFailWriteRoleTeamToGlobal:      true,\n+\t\t\tshouldFailWriteRoleOwnDomain:         true,\n+\t\t\tshouldFailGlobalRead:                 true,\n+\t\t\tshouldFailTeamRead:                   true,\n+\t\t\tshouldFailGlobalDelete:               true,\n+\t\t\tshouldFailTeamDelete:                 true,\n+\t\t\tshouldFailGlobalPasswordReset:        true,\n+\t\t\tshouldFailTeamPasswordReset:          true,\n+\t\t\tshouldFailGlobalChangePassword:       true,\n+\t\t\tshouldFailTeamChangePassword:         true,\n+\t\t\tshouldFailListAll:                    true,\n+\t\t\tshouldFailListTeam:                   true,\n \t\t},\n \t}\n \tfor _, tt := range testCases {\n \t\tt.Run(tt.name, func(t *testing.T) {\n \t\t\tctx := viewer.NewContext(context.Background(), viewer.Viewer{User: tt.user})\n \n+\t\t\ttt.user.SetPassword(\"p4ssw0rd.\", 10, 10)\n+\n+\t\t\t// To test a user reading/modifying itself.\n+\t\t\tu := *tt.user\n+\t\t\tself = &u\n+\n+\t\t\t// A user can always read itself (read rego action).\n+\t\t\t_, err := svc.User(ctx, tt.user.ID)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\t// A user can always write itself (write rego action).\n+\t\t\t_, err = svc.ModifyUser(ctx, tt.user.ID, fleet.UserPayload{Name: ptr.String(\"Foo\")})\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\t// A user can always change its own password (change_password rego action).\n+\t\t\t_, err = svc.ModifyUser(ctx, tt.user.ID, fleet.UserPayload{Password: ptr.String(\"p4ssw0rd.\"), NewPassword: ptr.String(\"p4ssw0rd.3\")})\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tchangeRole := func(role string) string {\n+\t\t\t\tswitch role {\n+\t\t\t\tcase fleet.RoleMaintainer:\n+\t\t\t\t\treturn fleet.RoleAdmin // promote\n+\t\t\t\tcase fleet.RoleAdmin:\n+\t\t\t\t\treturn fleet.RoleMaintainer // demote\n+\t\t\t\tcase fleet.RoleObserver:\n+\t\t\t\t\treturn fleet.RoleAdmin // promote\n+\t\t\t\tdefault:\n+\t\t\t\t\tt.Fatalf(\"unknown role: %s\", role)\n+\t\t\t\t\treturn \"\"\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Test a user modifying its own role within its domain (write_role rego action).\n+\t\t\tif tt.user.GlobalRole != nil {\n+\t\t\t\t_, err = svc.ModifyUser(ctx, tt.user.ID, fleet.UserPayload{GlobalRole: ptr.String(changeRole(*tt.user.GlobalRole))})\n+\t\t\t\tcheckAuthErr(t, tt.shouldFailWriteRoleOwnDomain, err)\n+\t\t\t} else { // Team user\n+\t\t\t\townTeamDifferentRole := []fleet.UserTeam{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tTeam: fleet.Team{ID: tt.user.Teams[0].ID},\n+\t\t\t\t\t\tRole: changeRole(tt.user.Teams[0].Role),\n+\t\t\t\t\t},\n+\t\t\t\t}\n+\t\t\t\t_, err = svc.ModifyUser(ctx, tt.user.ID, fleet.UserPayload{Teams: &ownTeamDifferentRole})\n+\t\t\t\tcheckAuthErr(t, tt.shouldFailWriteRoleOwnDomain, err)\n+\t\t\t}\n+\n \t\t\tteams := []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleMaintainer}}\n-\t\t\t_, err := svc.CreateUser(ctx, fleet.UserPayload{\n+\t\t\t_, err = svc.CreateUser(ctx, fleet.UserPayload{\n \t\t\t\tName:     ptr.String(\"Some Name\"),\n \t\t\t\tEmail:    ptr.String(\"some@email.com\"),\n \t\t\t\tPassword: ptr.String(\"passw0rd.\"),\n@@ -171,29 +366,54 @@ func TestUserAuth(t *testing.T) {\n \t\t\t})\n \t\t\tcheckAuthErr(t, tt.shouldFailGlobalWrite, err)\n \n-\t\t\t_, err = svc.ModifyUser(ctx, 999, fleet.UserPayload{Teams: &teams})\n+\t\t\t_, err = svc.ModifyUser(ctx, userGlobalMaintainerID, fleet.UserPayload{Name: ptr.String(\"Foo\")})\n+\t\t\tcheckAuthErr(t, tt.shouldFailGlobalWrite, err)\n+\n+\t\t\t_, err = svc.ModifyUser(ctx, userTeamMaintainerID, fleet.UserPayload{Name: ptr.String(\"Bar\")})\n \t\t\tcheckAuthErr(t, tt.shouldFailTeamWrite, err)\n \n-\t\t\t_, err = svc.ModifyUser(ctx, 888, fleet.UserPayload{Teams: &teams})\n-\t\t\tcheckAuthErr(t, tt.shouldFailGlobalWrite, err)\n+\t\t\t_, err = svc.ModifyUser(ctx, userGlobalMaintainerID, fleet.UserPayload{GlobalRole: ptr.String(fleet.RoleMaintainer)})\n+\t\t\tcheckAuthErr(t, tt.shouldFailWriteRoleGlobalToGlobal, err)\n \n-\t\t\t_, err = svc.ModifyUser(ctx, 888, fleet.UserPayload{GlobalRole: ptr.String(fleet.RoleMaintainer)})\n-\t\t\tcheckAuthErr(t, tt.shouldFailGlobalWrite, err)\n+\t\t\t_, err = svc.ModifyUser(ctx, userGlobalMaintainerID, fleet.UserPayload{Teams: &teams})\n+\t\t\tcheckAuthErr(t, tt.shouldFailWriteRoleGlobalToTeam, err)\n \n-\t\t\terr = svc.DeleteUser(ctx, 999)\n-\t\t\tcheckAuthErr(t, tt.shouldFailDeleteReset, err)\n+\t\t\tanotherTeams := []fleet.UserTeam{{Team: fleet.Team{ID: 2}, Role: fleet.RoleMaintainer}}\n+\t\t\t_, err = svc.ModifyUser(ctx, userTeamMaintainerID, fleet.UserPayload{Teams: &anotherTeams})\n+\t\t\tcheckAuthErr(t, tt.shouldFailWriteRoleTeamToAnotherTeam, err)\n \n-\t\t\t_, err = svc.RequirePasswordReset(ctx, 999, false)\n-\t\t\tcheckAuthErr(t, tt.shouldFailDeleteReset, err)\n+\t\t\t_, err = svc.ModifyUser(ctx, userTeamMaintainerID, fleet.UserPayload{GlobalRole: ptr.String(fleet.RoleMaintainer)})\n+\t\t\tcheckAuthErr(t, tt.shouldFailWriteRoleTeamToGlobal, err)\n \n-\t\t\t_, err = svc.ListUsers(ctx, fleet.UserListOptions{})\n-\t\t\tcheckAuthErr(t, tt.shouldFailRead, err)\n+\t\t\t_, err = svc.User(ctx, userGlobalMaintainerID)\n+\t\t\tcheckAuthErr(t, tt.shouldFailGlobalRead, err)\n+\n+\t\t\t_, err = svc.User(ctx, userTeamMaintainerID)\n+\t\t\tcheckAuthErr(t, tt.shouldFailTeamRead, err)\n+\n+\t\t\terr = svc.DeleteUser(ctx, userGlobalMaintainerID)\n+\t\t\tcheckAuthErr(t, tt.shouldFailGlobalDelete, err)\n+\n+\t\t\terr = svc.DeleteUser(ctx, userTeamMaintainerID)\n+\t\t\tcheckAuthErr(t, tt.shouldFailTeamDelete, err)\n+\n+\t\t\t_, err = svc.RequirePasswordReset(ctx, userGlobalMaintainerID, false)\n+\t\t\tcheckAuthErr(t, tt.shouldFailGlobalPasswordReset, err)\n \n-\t\t\t_, err = svc.User(ctx, 999)\n-\t\t\tcheckAuthErr(t, tt.shouldFailRead, err)\n+\t\t\t_, err = svc.RequirePasswordReset(ctx, userTeamMaintainerID, false)\n+\t\t\tcheckAuthErr(t, tt.shouldFailTeamPasswordReset, err)\n \n-\t\t\t_, err = svc.User(ctx, 888)\n-\t\t\tcheckAuthErr(t, tt.shouldFailRead, err)\n+\t\t\t_, err = svc.ModifyUser(ctx, userGlobalMaintainerID, fleet.UserPayload{NewPassword: ptr.String(\"passw0rd.2\")})\n+\t\t\tcheckAuthErr(t, tt.shouldFailGlobalChangePassword, err)\n+\n+\t\t\t_, err = svc.ModifyUser(ctx, userTeamMaintainerID, fleet.UserPayload{NewPassword: ptr.String(\"passw0rd.2\")})\n+\t\t\tcheckAuthErr(t, tt.shouldFailTeamChangePassword, err)\n+\n+\t\t\t_, err = svc.ListUsers(ctx, fleet.UserListOptions{})\n+\t\t\tcheckAuthErr(t, tt.shouldFailListAll, err)\n+\n+\t\t\t_, err = svc.ListUsers(ctx, fleet.UserListOptions{TeamID: 1})\n+\t\t\tcheckAuthErr(t, tt.shouldFailListTeam, err)\n \t\t})\n \t}\n }\n@@ -677,3 +897,406 @@ func TestAuthenticatedUser(t *testing.T) {\n \tassert.Nil(t, err)\n \tassert.Equal(t, user, admin1)\n }\n+\n+func TestIsAdminOfTheModifiedTeams(t *testing.T) {\n+\ttype teamWithRole struct {\n+\t\tteamID uint\n+\t\trole   string\n+\t}\n+\ttype roles struct {\n+\t\tglobal *string\n+\t\tteams  []teamWithRole\n+\t}\n+\tfor _, tc := range []struct {\n+\t\tname string\n+\t\t// actionUserRoles are the roles of the user executing the role change action.\n+\t\tactionUserRoles roles\n+\t\t// targetUserOriginalTeams are the original teams the target user belongs to.\n+\t\ttargetUserOriginalTeams []teamWithRole\n+\t\t// targetUserNewTeams are the new teams the target user will be added to.\n+\t\ttargetUserNewTeams []teamWithRole\n+\n+\t\texpected bool\n+\t}{\n+\t\t{\n+\t\t\tname: \"global-admin-allmighty\",\n+\t\t\tactionUserRoles: roles{\n+\t\t\t\tglobal: ptr.String(fleet.RoleAdmin),\n+\t\t\t},\n+\t\t\ttargetUserOriginalTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserNewTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 2,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"global-maintainer-cannot-modify-team-users\",\n+\t\t\tactionUserRoles: roles{\n+\t\t\t\tglobal: ptr.String(fleet.RoleMaintainer),\n+\t\t\t},\n+\t\t\ttargetUserOriginalTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserNewTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleMaintainer,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"team-admin-of-original-and-new\",\n+\t\t\tactionUserRoles: roles{\n+\t\t\t\tteams: []teamWithRole{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tteamID: 1,\n+\t\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tteamID: 2,\n+\t\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserOriginalTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserNewTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 2,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"team-admin-of-one-original-and-leave-other-team-unmodified\",\n+\t\t\tactionUserRoles: roles{\n+\t\t\t\tteams: []teamWithRole{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tteamID: 1,\n+\t\t\t\t\t\trole:   fleet.RoleMaintainer,\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tteamID: 2,\n+\t\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserOriginalTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleMaintainer,\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 2,\n+\t\t\t\t\trole:   fleet.RoleMaintainer,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserNewTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleMaintainer,\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 2,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"team-admin-of-original-only\",\n+\t\t\tactionUserRoles: roles{\n+\t\t\t\tteams: []teamWithRole{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tteamID: 1,\n+\t\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tteamID: 2,\n+\t\t\t\t\t\trole:   fleet.RoleMaintainer,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserOriginalTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserNewTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 2,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"team-admin-of-new-only\",\n+\t\t\tactionUserRoles: roles{\n+\t\t\t\tteams: []teamWithRole{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tteamID: 1,\n+\t\t\t\t\t\trole:   fleet.RoleObserver,\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tteamID: 2,\n+\t\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserOriginalTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserNewTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 2,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"team-admin-but-new-another-team-observer\",\n+\t\t\tactionUserRoles: roles{\n+\t\t\t\tteams: []teamWithRole{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tteamID: 1,\n+\t\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserOriginalTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserNewTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 2,\n+\t\t\t\t\trole:   fleet.RoleObserver,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"team-admin-but-new-another-team-admin\",\n+\t\t\tactionUserRoles: roles{\n+\t\t\t\tteams: []teamWithRole{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tteamID: 1,\n+\t\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserOriginalTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserNewTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 2,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"team-admin-but-original-another-team\",\n+\t\t\tactionUserRoles: roles{\n+\t\t\t\tteams: []teamWithRole{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tteamID: 1,\n+\t\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserOriginalTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 2,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserNewTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"team-admin-but-change-role-another-team\",\n+\t\t\tactionUserRoles: roles{\n+\t\t\t\tteams: []teamWithRole{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tteamID: 1,\n+\t\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserOriginalTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 2,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserNewTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 2,\n+\t\t\t\t\trole:   fleet.RoleMaintainer,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"team-admin-of-one-original-only\",\n+\t\t\tactionUserRoles: roles{\n+\t\t\t\tteams: []teamWithRole{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tteamID: 1,\n+\t\t\t\t\t\trole:   fleet.RoleMaintainer,\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tteamID: 2,\n+\t\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserOriginalTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleMaintainer,\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 2,\n+\t\t\t\t\trole:   fleet.RoleMaintainer,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttargetUserNewTeams: []teamWithRole{\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 1,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tteamID: 2,\n+\t\t\t\t\trole:   fleet.RoleAdmin,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: false,\n+\t\t},\n+\t} {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tuserTeamsFn := func(twr []teamWithRole) []fleet.UserTeam {\n+\t\t\t\tvar userTeams []fleet.UserTeam\n+\t\t\t\tfor _, ot := range twr {\n+\t\t\t\t\tuserTeams = append(userTeams, fleet.UserTeam{\n+\t\t\t\t\t\tTeam: fleet.Team{ID: ot.teamID},\n+\t\t\t\t\t\tRole: ot.role,\n+\t\t\t\t\t})\n+\t\t\t\t}\n+\t\t\t\treturn userTeams\n+\t\t\t}\n+\n+\t\t\tactionUserTeams := userTeamsFn(tc.actionUserRoles.teams)\n+\t\t\toriginalUserTeams := userTeamsFn(tc.targetUserOriginalTeams)\n+\t\t\tnewUserTeams := userTeamsFn(tc.targetUserNewTeams)\n+\n+\t\t\tresult := isAdminOfTheModifiedTeams(\n+\t\t\t\t&fleet.User{\n+\t\t\t\t\tGlobalRole: tc.actionUserRoles.global,\n+\t\t\t\t\tTeams:      actionUserTeams,\n+\t\t\t\t},\n+\t\t\t\toriginalUserTeams,\n+\t\t\t\tnewUserTeams,\n+\t\t\t)\n+\t\t\trequire.Equal(t, tc.expected, result)\n+\t\t})\n+\t}\n+}\n+\n+// TestAdminAddRoleOtherTeam is an explicit test to check that\n+// that an admin cannot add itself to another team.\n+func TestTeamAdminAddRoleOtherTeam(t *testing.T) {\n+\tds := new(mock.Store)\n+\tsvc := newTestService(t, ds, nil, nil)\n+\n+\t// adminTeam2 is a team admin of team with ID=2.\n+\tadminTeam2 := &fleet.User{\n+\t\tID: 1,\n+\t\tTeams: []fleet.UserTeam{\n+\t\t\t{\n+\t\t\t\tTeam: fleet.Team{ID: 2},\n+\t\t\t\tRole: fleet.RoleAdmin,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tds.UserByIDFunc = func(ctx context.Context, id uint) (*fleet.User, error) {\n+\t\tif id != 1 {\n+\t\t\treturn nil, &notFoundError{}\n+\t\t}\n+\t\treturn adminTeam2, nil\n+\t}\n+\tds.SaveUserFunc = func(ctx context.Context, user *fleet.User) error {\n+\t\treturn nil\n+\t}\n+\n+\tctx := viewer.NewContext(context.Background(), viewer.Viewer{User: adminTeam2})\n+\tadminTeam2.SetPassword(\"p4ssw0rd.\", 10, 10)\n+\n+\t// adminTeam2 tries to add itself to team with ID=3 as admin.\n+\t_, err := svc.ModifyUser(ctx, adminTeam2.ID, fleet.UserPayload{\n+\t\tTeams: &[]fleet.UserTeam{\n+\t\t\t{\n+\t\t\t\tTeam: fleet.Team{ID: 2},\n+\t\t\t\tRole: fleet.RoleAdmin,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tTeam: fleet.Team{ID: 3},\n+\t\t\t\tRole: fleet.RoleAdmin,\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.Equal(t, (&authz.Forbidden{}).Error(), err.Error())\n+\trequire.False(t, ds.SaveUserFuncInvoked)\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 4,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 8,
        "unique_directories": 11,
        "max_directory_depth": 6
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "ac03358703c41bde8101e411bfe67fabc14ac205",
            "date": "2025-01-25T00:52:58Z",
            "author_login": "rachaelshaw"
          },
          {
            "sha": "3089c960490612b95b62df389556d8db7c7ffad9",
            "date": "2025-01-25T00:14:15Z",
            "author_login": "eashaw"
          },
          {
            "sha": "d074ba2b48d771671b1d95f16f9499a75a4a62ee",
            "date": "2025-01-24T22:32:03Z",
            "author_login": "jordan-wright"
          },
          {
            "sha": "2589092849fa79968d5299a0eb617f2c2917015c",
            "date": "2025-01-24T22:28:43Z",
            "author_login": "eashaw"
          },
          {
            "sha": "c21ad843453a24f5c14b8e67d350d709c69016ed",
            "date": "2025-01-24T21:04:56Z",
            "author_login": "Sampfluger88"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-284",
    "description": "fleetdm/fleet is an open source device management, built on osquery. All versions of fleet making use of the teams feature are affected by this authorization bypass issue. Fleet instances without teams, or with teams but without restricted team accounts are not affected. In affected versions a team admin can erroneously add themselves as admin, maintainer or observer on other teams. Users are advised to upgrade to version 4.13. There are no known workarounds for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-04-18T22:15:08.933",
    "last_modified": "2024-11-21T06:51:12.970",
    "fix_date": "2022-04-18T17:27:30Z"
  },
  "references": [
    {
      "url": "https://github.com/fleetdm/fleet/commit/da171d3b8d149c30b8307723cbe6b6e8847cb30c",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/fleetdm/fleet/security/advisories/GHSA-pr2g-j78h-84cr",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/fleetdm/fleet/commit/da171d3b8d149c30b8307723cbe6b6e8847cb30c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/fleetdm/fleet/security/advisories/GHSA-pr2g-j78h-84cr",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:04.393409",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "fleet",
    "owner": "fleetdm",
    "created_at": "2020-11-03T22:17:18Z",
    "updated_at": "2025-01-26T07:02:30Z",
    "pushed_at": "2025-01-26T00:22:12Z",
    "size": 738940,
    "stars": 3434,
    "forks": 465,
    "open_issues": 2199,
    "watchers": 3434,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Go": 17008265,
      "JavaScript": 5463823,
      "TypeScript": 4078457,
      "Augeas": 703542,
      "HCL": 412124,
      "EJS": 346613,
      "SCSS": 341789,
      "Shell": 197477,
      "Less": 75399,
      "HTML": 54731,
      "PowerShell": 48967,
      "Ruby": 42872,
      "Makefile": 34427,
      "Open Policy Agent": 28606,
      "Perl": 24185,
      "Python": 20720,
      "Dockerfile": 10660,
      "Roff": 5414,
      "PHP": 3891,
      "Smarty": 3636,
      "CSS": 3494,
      "Puppet": 2310,
      "Jinja": 94
    },
    "commit_activity": {
      "total_commits_last_year": 5409,
      "avg_commits_per_week": 104.01923076923077,
      "days_active_last_year": 297
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T08:03:49.100456"
  }
}