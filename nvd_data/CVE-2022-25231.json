{
  "cve_id": "CVE-2022-25231",
  "github_data": {
    "repository": "node-opcua/node-opcua",
    "fix_commit": "7b5044b3f5866fbedc3efabd05e407352c07bd2f",
    "related_commits": [
      "7b5044b3f5866fbedc3efabd05e407352c07bd2f",
      "7b5044b3f5866fbedc3efabd05e407352c07bd2f"
    ],
    "patch_url": "https://github.com/node-opcua/node-opcua/commit/7b5044b3f5866fbedc3efabd05e407352c07bd2f.patch",
    "fix_commit_details": {
      "sha": "7b5044b3f5866fbedc3efabd05e407352c07bd2f",
      "commit_date": "2022-08-12T22:06:23Z",
      "author": {
        "login": "erossignon",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "server: use ServiceFault on request error",
        "length": 41,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 1913,
        "additions": 978,
        "deletions": 935
      },
      "files": [
        {
          "filename": "packages/node-opcua-client/source/private/client_session_impl.ts",
          "status": "modified",
          "additions": 10,
          "deletions": 2,
          "patch": "@@ -10,7 +10,7 @@ import {\n     ExtraDataTypeManager,\n     getExtensionObjectConstructor,\n     getExtraDataTypeManager,\n-    promoteOpaqueStructure,\n+    promoteOpaqueStructure\n } from \"node-opcua-client-dynamic-extension-object\";\n import { Certificate, Nonce } from \"node-opcua-crypto\";\n import { attributeNameById, BrowseDirection, LocalizedTextLike } from \"node-opcua-data-model\";\n@@ -82,7 +82,13 @@ import {\n import { WriteRequest, WriteResponse, WriteValue } from \"node-opcua-service-write\";\n import { StatusCode, StatusCodes, Callback, CallbackT } from \"node-opcua-status-code\";\n import { ErrorCallback } from \"node-opcua-status-code\";\n-import { BrowseNextRequest, BrowseNextResponse, HistoryReadValueIdOptions, WriteValueOptions } from \"node-opcua-types\";\n+import {\n+    BrowseNextRequest,\n+    BrowseNextResponse,\n+    HistoryReadValueIdOptions,\n+    ServiceFault,\n+    WriteValueOptions\n+} from \"node-opcua-types\";\n import { buffer_ellipsis, getFunctionParameterNames, isNullOrUndefined, lowerFirstLetter } from \"node-opcua-utils\";\n import { DataType, Variant, VariantLike } from \"node-opcua-variant\";\n \n@@ -1540,6 +1546,7 @@ export class ClientSessionImpl extends EventEmitter implements ClientSession {\n             if (err && err.message.match(/BadSessionIdInvalid/) && request.constructor.name !== \"ActivateSessionRequest\") {\n                 debugLog(\"Transaction on Invalid Session \", request.constructor.name);\n                 request.requestHeader.requestHandle = requestHandleNotSetValue;\n+                warningLog(\"client is now attempting to recreate a session\");\n                 this.recreate_session_and_reperform_transaction(request, callback);\n                 return;\n             }\n@@ -1595,6 +1602,7 @@ export class ClientSessionImpl extends EventEmitter implements ClientSession {\n                 }\n                 return callback(err);\n             }\n+\n             /* istanbul ignore next */\n             if (!response) {\n                 return callback(new Error(\"internal Error\"));"
        },
        {
          "filename": "packages/node-opcua-client/source/private/client_subscription_impl.ts",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -471,8 +471,12 @@ export class ClientSubscriptionImpl extends EventEmitter implements ClientSubscr\n         });\n         session.setTriggering(setTriggeringRequest, (err: Error | null, response?: SetTriggeringResponse) => {\n             if (err) {\n-                // use soft error, no exceptions\n-                return callback(null, response);\n+                if (response) {\n+                    // use soft error, no exceptions\n+                    return callback(null, response);\n+                } else {\n+                    return callback(err);\n+                }\n             }\n             // istanbul ignore next\n             if (!response) {"
        },
        {
          "filename": "packages/node-opcua-end2end-test/test/discovery/u_test_discovery_server.ts",
          "status": "modified",
          "additions": 22,
          "deletions": 14,
          "patch": "@@ -18,7 +18,8 @@ import {\n     StatusCodes,\n     RegisterServerMethod,\n     makeApplicationUrn,\n-    OPCUADiscoveryServer\n+    OPCUADiscoveryServer,\n+    ServiceFault\n } from \"node-opcua\";\n import { readCertificate, exploreCertificate } from \"node-opcua-crypto\";\n import { checkDebugFlag, make_debugLog } from \"node-opcua-debug\";\n@@ -132,13 +133,15 @@ export function t(test: any) {\n                 }\n             });\n \n-            function check_response(err: Error | null, response: any): void {\n-                should.not.exist(err);\n+            function check_error_response(err: Error | null, response: any): void {\n+                should.exist(err);\n+                should.not.exist(response);\n+                (err as any).response.should.be.instanceOf(ServiceFault);\n                 //xx console.log(response.toString());\n-                response.responseHeader.serviceResult.should.eql(StatusCodes.BadDiscoveryUrlMissing);\n+                (err as any).response.responseHeader.serviceResult.should.eql(StatusCodes.BadDiscoveryUrlMissing);\n             }\n \n-            await send_registered_server_request(discoveryServerEndpointUrl, request, check_response);\n+            await send_registered_server_request(discoveryServerEndpointUrl, request, check_error_response);\n         });\n \n         it(\"DISCO1-2 should fail to register server to the discover server if server type is Client (BadInvalidArgument)\", async () => {\n@@ -161,13 +164,15 @@ export function t(test: any) {\n                 }\n             });\n \n-            function check_response(err: Error | null, response: any) {\n-                should.not.exist(err);\n+            function check_error_response(err: Error | null, response: any) {\n+                should.exist(err);\n+                should.not.exist(response);\n                 //xx debugLog(response.toString());\n-                response.responseHeader.serviceResult.should.eql(StatusCodes.BadInvalidArgument);\n+                (err as any).response.should.be.instanceOf(ServiceFault);\n+                (err as any).response.responseHeader.serviceResult.should.eql(StatusCodes.BadInvalidArgument);\n             }\n \n-            await send_registered_server_request(discoveryServerEndpointUrl, request, check_response);\n+            await send_registered_server_request(discoveryServerEndpointUrl, request, check_error_response);\n         });\n \n         it(\"DISCO1-3 should fail to register server to the discover server if server name array is empty (BadServerNameMissing)\", async () => {\n@@ -190,12 +195,14 @@ export function t(test: any) {\n                 }\n             });\n \n-            function check_response(err: Error | null, response: any) {\n-                should.not.exist(err);\n-                response.responseHeader.serviceResult.should.eql(StatusCodes.BadServerNameMissing);\n+            function check_error_response(err: Error | null, response: any) {\n+                should.exist(err);\n+                should.not.exist(response);\n+                (err as any).response.should.be.instanceOf(ServiceFault);\n+                (err as any).response.responseHeader.serviceResult.should.eql(StatusCodes.BadServerNameMissing);\n             }\n \n-            await send_registered_server_request(discoveryServerEndpointUrl, request, check_response);\n+            await send_registered_server_request(discoveryServerEndpointUrl, request, check_error_response);\n         });\n     });\n \n@@ -207,7 +214,8 @@ export function t(test: any) {\n         let server: OPCUAServer;\n \n         before(() => {\n-            OPCUAServer.registry.count().should.eql(0);1162\n+            OPCUAServer.registry.count().should.eql(0);\n+            1162;\n         });\n \n         after(() => {"
        },
        {
          "filename": "packages/node-opcua-end2end-test/test/end_to_end/u_test_e2e_BrowseRequest.js",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -164,10 +164,10 @@ module.exports = function(test) {\n                     const browseNextRequest = new BrowseNextRequest({\n                         continuationPoints: null\n                     });\n-                    g_session.performMessageTransaction(browseNextRequest, function(err, response) {\n+                    g_session.performMessageTransaction(browseNextRequest, function(err, _response) {\n                         err.message.should.match(/BadNothingToDo/);\n                         // console.log(response.toString());\n-                        response.responseHeader.serviceResult.should.equal(StatusCodes.BadNothingToDo);\n+                        err.response.responseHeader.serviceResult.should.equal(StatusCodes.BadNothingToDo);\n                         callback();\n                     });\n                 }"
        },
        {
          "filename": "packages/node-opcua-end2end-test/test/end_to_end/u_test_e2e_SubscriptionUseCase.js",
          "status": "modified",
          "additions": 21,
          "deletions": 14,
          "patch": "@@ -39,10 +39,10 @@ const {\n     Variant,\n     Subscription,\n     SubscriptionState,\n-    installSessionLogging\n+    installSessionLogging,\n+    ServiceFault\n } = require(\"node-opcua\");\n \n-\n const { make_debugLog, checkDebugFlag } = require(\"node-opcua-debug\");\n \n const {\n@@ -726,7 +726,8 @@ module.exports = function (test) {\n                                 },\n                                 function (callback) {\n                                     function publish_callback(err, response) {\n-                                        should.exist(response);\n+                                        should.not.exist(response);\n+                                        err.response.should.be.instanceOf(ServiceFault);\n                                         should(err.message).match(/BadNoSubscription/);\n                                     }\n \n@@ -825,7 +826,8 @@ module.exports = function (test) {\n                                         subscriptionIds: []\n                                     },\n                                     function (err, response) {\n-                                        should.exist(response);\n+                                        should.not.exist(response);\n+                                        should.exist(err);\n                                         err.message.should.match(/BadNothingToDo/);\n                                         callback();\n                                     }\n@@ -1518,7 +1520,8 @@ module.exports = function (test) {\n                     });\n                     session.createMonitoredItems(createMonitoredItemsRequest, function (err, createMonitoredItemsResponse) {\n                         should(err.message).match(/BadNothingToDo/);\n-                        createMonitoredItemsResponse.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n+                        should.not.exist(createMonitoredItemsResponse);\n+                        err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n                         callback();\n                     });\n                 },\n@@ -1581,7 +1584,8 @@ module.exports = function (test) {\n                     });\n                     session.modifyMonitoredItems(modifyMonitoredItemsRequest, function (err, modifyMonitoredItemsResponse) {\n                         should(err.message).match(/BadNothingToDo/);\n-                        modifyMonitoredItemsResponse.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n+                        err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n+                        should.not.exist(modifyMonitoredItemsResponse);\n                         callback();\n                     });\n                 },\n@@ -1600,7 +1604,8 @@ module.exports = function (test) {\n                     });\n                     session.deleteMonitoredItems(deleteMonitoredItemsRequest, function (err, deleteMonitoredItemsResponse) {\n                         should(err.message).match(/BadNothingToDo/);\n-                        deleteMonitoredItemsResponse.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n+                        err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n+                        should.not.exist(deleteMonitoredItemsResponse);\n                         callback();\n                     });\n                 },\n@@ -1793,6 +1798,7 @@ module.exports = function (test) {\n                             requestedPublishingInterval: -1\n                         },\n                         function (err, createSubscriptionResponse) {\n+                            should.not.exist(err);\n                             createSubscriptionResponse.revisedPublishingInterval.should.be.greaterThan(10);\n \n                             inner_done(err);\n@@ -1903,7 +1909,6 @@ module.exports = function (test) {\n \n             installSessionLogging(server);\n \n-\n             endpointUrl = test.endpointUrl;\n             temperatureVariableId = server.temperatureVariableId;\n \n@@ -2139,13 +2144,13 @@ module.exports = function (test) {\n                             })\n                         ],\n                         (err) => {\n-                            tracelog(\"inner\", err ? err.message: \"\");\n+                            tracelog(\"inner\", err ? err.message : \"\");\n                             inner_done(err);\n                         }\n                     );\n                 },\n                 (err) => {\n-                    tracelog(\"done\", err ? err.message: \"\");\n+                    tracelog(\"done\", err ? err.message : \"\");\n                     done(err);\n                 }\n             );\n@@ -4064,8 +4069,9 @@ module.exports = function (test) {\n                     });\n                     g_session.republish(request, function (err, response) {\n                         should.exist(err);\n-                        response.should.be.instanceof(RepublishResponse);\n-                        response.responseHeader.serviceResult.should.eql(StatusCodes.BadMessageNotAvailable);\n+                        should.not.exist(response);\n+                        err.response.should.be.instanceof(ServiceFault);\n+                        err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadMessageNotAvailable);\n                         done();\n                     });\n                 }, done);\n@@ -4081,8 +4087,9 @@ module.exports = function (test) {\n                     });\n                     g_session.republish(request, function (err, response) {\n                         should.exist(err);\n-                        response.should.be.instanceof(RepublishResponse);\n-                        response.responseHeader.serviceResult.should.eql(StatusCodes.BadSubscriptionIdInvalid);\n+                        should.not.exist(response);\n+                        err.response.should.be.instanceof(ServiceFault);\n+                        err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadSubscriptionIdInvalid);\n                         done();\n                     });\n                 }, done);"
        },
        {
          "filename": "packages/node-opcua-end2end-test/test/end_to_end/u_test_e2e_Subscription_Transfer.js",
          "status": "modified",
          "additions": 11,
          "deletions": 4,
          "patch": "@@ -456,10 +456,17 @@ module.exports = function (test) {\n                         const response1 = spy_publish_session2.getCall(1).args[1];\n                         const response2 = spy_publish_session2.getCall(2).args[1];\n                         const response3 = spy_publish_session2.getCall(3).args[1];\n-\n-                        response1.responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n-                        response2.responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n-                        response3.responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n+                        should.not.exist(response1);\n+                        should.not.exist(response2);\n+                        should.not.exist(response3);\n+\n+                        const err1 = spy_publish_session2.getCall(1).args[0];\n+                        const err2 = spy_publish_session2.getCall(2).args[0];\n+                        const err3 = spy_publish_session2.getCall(3).args[0];\n+                        \n+                        err1.response.responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n+                        err2.response.responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n+                        err3.response.responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n                         //xx console.log(response1.toString())\n                         //xx console.log(response2.toString())\n                         //xx console.log(response3.toString())"
        },
        {
          "filename": "packages/node-opcua-end2end-test/test/end_to_end/u_test_e2e_browse_read.js",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -29,6 +29,8 @@ const fail_fast_connectivity_strategy = {\n const describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\n module.exports = function (test) {\n     describe(\"Browse-Read-Write Services\", function () {\n+\n+        /** @type {ClientSession} */\n         let g_session = null;\n \n         // use fail fast connectionStrategy\n@@ -170,7 +172,7 @@ module.exports = function (test) {\n \n             g_session.read(nodesToRead, function (err, dataValues) {\n                 if (err) {\n-                    const response = dataValues;\n+                    const response = err.response;\n                     //dataValues.length.should.be(1);\n                     response.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n                     done();"
        },
        {
          "filename": "packages/node-opcua-end2end-test/test/end_to_end/u_test_e2e_registerNodes.js",
          "status": "modified",
          "additions": 129,
          "deletions": 126,
          "patch": "@@ -2,20 +2,11 @@\n const should = require(\"should\");\n const async = require(\"async\");\n \n+const { OPCUAClient, StatusCodes, UnregisterNodesRequest, RegisterNodesRequest, DataType, AttributeIds, ServiceFault } = require(\"node-opcua\");\n const { perform_operation_on_client_session } = require(\"../../test_helpers/perform_operation_on_client_session\");\n \n-const opcua = require(\"node-opcua\");\n-const StatusCodes = opcua.StatusCodes;\n-const OPCUAClient = opcua.OPCUAClient;\n-const UnregisterNodesRequest = opcua.UnregisterNodesRequest;\n-const RegisterNodesRequest = opcua.RegisterNodesRequest;\n-const AttributeIds = opcua.AttributeIds;\n-const DataType = opcua.DataType;\n-\n module.exports = function (test) {\n-\n     describe(\"end-to-end testing registerNodes\", function () {\n-\n         let client, endpointUrl;\n \n         beforeEach(function (done) {\n@@ -30,135 +21,147 @@ module.exports = function (test) {\n         });\n \n         it(\"should register nodes - BadNothingToDo\", function (done) {\n-\n-            perform_operation_on_client_session(client, endpointUrl, function (session, inner_done) {\n-\n-                const request = new RegisterNodesRequest({\n-                    nodesToRegister: []\n-                });\n-                session.performMessageTransaction(request, function (err/*, response*/) {\n-                    err.message.should.match(/BadNothingToDo/);\n-                    inner_done();\n-                });\n-\n-            }, done);\n+            perform_operation_on_client_session(\n+                client,\n+                endpointUrl,\n+                function (session, inner_done) {\n+                    const request = new RegisterNodesRequest({\n+                        nodesToRegister: []\n+                    });\n+                    session.performMessageTransaction(request, function (err /*, response*/) {\n+                        err.message.should.match(/BadNothingToDo/);\n+                        inner_done();\n+                    });\n+                },\n+                done\n+            );\n         });\n \n         it(\"should register nodes - Good\", function (done) {\n-\n-            perform_operation_on_client_session(client, endpointUrl, function (session, inner_done) {\n-\n-                const request = new RegisterNodesRequest({\n-                    nodesToRegister: [\n-                        \"ns=0;i=1\"\n-                    ]\n-                });\n-                session.performMessageTransaction(request, function (err, response) {\n-                    should.not.exist(err);\n-                    response.registeredNodeIds.length.should.eql(1);\n-                    inner_done();\n-                });\n-\n-            }, done);\n+            perform_operation_on_client_session(\n+                client,\n+                endpointUrl,\n+                function (session, inner_done) {\n+                    const request = new RegisterNodesRequest({\n+                        nodesToRegister: [\"ns=0;i=1\"]\n+                    });\n+                    session.performMessageTransaction(request, function (err, response) {\n+                        should.not.exist(err);\n+                        response.registeredNodeIds.length.should.eql(1);\n+                        inner_done();\n+                    });\n+                },\n+                done\n+            );\n         });\n \n         it(\"should unregister nodes - BadNothingToDo\", function (done) {\n-            perform_operation_on_client_session(client, endpointUrl, function (session, inner_done) {\n-\n-                const request = new UnregisterNodesRequest({\n-                    nodesToUnregister: []\n-                });\n-                session.performMessageTransaction(request, function (err, response) {\n-                    should.exist(response);\n-                    err.message.should.match(/BadNothingToDo/);\n-                    inner_done();\n-                });\n-\n-            }, done);\n+            perform_operation_on_client_session(\n+                client,\n+                endpointUrl,\n+                function (session, inner_done) {\n+                    const request = new UnregisterNodesRequest({\n+                        nodesToUnregister: []\n+                    });\n+                    session.performMessageTransaction(request, function (err, response) {\n+                        should.not.exist(response);\n+                        should.exist(err);\n+                        err.response.should.be.instanceOf(ServiceFault);\n+                        err.message.should.match(/BadNothingToDo/);\n+                        err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n+                        inner_done();\n+                    });\n+                },\n+                done\n+            );\n         });\n \n         it(\"should unregister nodes - Good\", function (done) {\n-            perform_operation_on_client_session(client, endpointUrl, function (session, inner_done) {\n-\n-                const request = new UnregisterNodesRequest({\n-                    nodesToUnregister: [\n-                        \"ns=0;i=1\"\n-                    ]\n-                });\n-                session.performMessageTransaction(request, function (err, response) {\n-                    should.exist(response);\n-                    should.not.exist(err);\n-                    inner_done();\n-                });\n-\n-            }, done);\n+            perform_operation_on_client_session(\n+                client,\n+                endpointUrl,\n+                function (session, inner_done) {\n+                    const request = new UnregisterNodesRequest({\n+                        nodesToUnregister: [\"ns=0;i=1\"]\n+                    });\n+                    session.performMessageTransaction(request, function (err, response) {\n+                        should.exist(response);\n+                        should.not.exist(err);\n+                        inner_done();\n+                    });\n+                },\n+                done\n+            );\n         });\n \n-\n         it(\"should register nodes and provide a alias that can be used on all operations\", function (done) {\n-            perform_operation_on_client_session(client, endpointUrl, function (session, inner_done) {\n-\n-                const nodesToRegister = [\"ns=2;s=Static_Scalar_Double\"];\n-                let registeredNodeIds = [];\n-                let dataValue1, dataValue2;\n-                async.series([\n-                    function register_some_node(callback) {\n-\n-                        session.registerNodes(nodesToRegister, function (err, _registeredNodeIds) {\n-                            if (err) {\n-                                return callback(err);\n+            perform_operation_on_client_session(\n+                client,\n+                endpointUrl,\n+                function (session, inner_done) {\n+                    const nodesToRegister = [\"ns=2;s=Static_Scalar_Double\"];\n+                    let registeredNodeIds = [];\n+                    let dataValue1, dataValue2;\n+                    async.series(\n+                        [\n+                            function register_some_node(callback) {\n+                                session.registerNodes(nodesToRegister, function (err, _registeredNodeIds) {\n+                                    if (err) {\n+                                        return callback(err);\n+                                    }\n+                                    registeredNodeIds = _registeredNodeIds;\n+                                    callback();\n+                                });\n+                            },\n+                            function (callback) {\n+                                const nodeToWrite = {\n+                                    nodeId: registeredNodeIds[0],\n+                                    attributeId: AttributeIds.Value,\n+                                    value: { value: { dataType: DataType.Double, value: 1000 } }\n+                                };\n+                                session.write(nodeToWrite, function (err, statusCode) {\n+                                    statusCode.should.eql(StatusCodes.Good);\n+                                    callback(err);\n+                                });\n+                            },\n+                            function (callback) {\n+                                const nodeToRead = { nodeId: nodesToRegister[0], attributeId: 13 };\n+                                session.read(nodeToRead, function (err, dataValue) {\n+                                    if (err) {\n+                                        return callback(err);\n+                                    }\n+                                    dataValue.statusCode.should.eql(StatusCodes.Good);\n+                                    dataValue1 = dataValue;\n+                                    callback();\n+                                });\n+                            },\n+                            function (callback) {\n+                                const nodeToRead = { nodeId: registeredNodeIds[0], attributeId: 13 };\n+                                session.read(nodeToRead, function (err, dataValue) {\n+                                    if (err) {\n+                                        return callback(err);\n+                                    }\n+                                    dataValue.statusCode.should.eql(StatusCodes.Good);\n+                                    dataValue2 = dataValue;\n+                                    callback();\n+                                });\n+                            },\n+                            function (callback) {\n+                                registeredNodeIds[0].toString().should.not.eql(nodesToRegister[0].toString());\n+                                dataValue1.statusCode.toString().should.eql(dataValue2.statusCode.toString());\n+\n+                                //xx console.log(dataValue1.toString());\n+                                //xx console.log(dataValue2.toString());\n+\n+                                dataValue1.value.toString().should.eql(dataValue2.value.toString());\n+                                callback();\n                             }\n-                            registeredNodeIds = _registeredNodeIds;\n-                            callback();\n-                        });\n-                    },\n-                    function (callback) {\n-\n-                        const nodeToWrite = {\n-                            nodeId: registeredNodeIds[0],\n-                            attributeId: AttributeIds.Value,\n-                            value: {value: {dataType: DataType.Double, value: 1000}}\n-                        };\n-                        session.write(nodeToWrite, function (err, statusCode) {\n-                            statusCode.should.eql(StatusCodes.Good);\n-                            callback(err);\n-                        });\n-                    },\n-                    function (callback) {\n-                        const nodeToRead = {nodeId: nodesToRegister[0], attributeId: 13};\n-                        session.read(nodeToRead, function (err, dataValue) {\n-                            if (err) {\n-                                return callback(err);\n-                            }\n-                            dataValue.statusCode.should.eql(StatusCodes.Good);\n-                            dataValue1 = dataValue;\n-                            callback();\n-                        });\n-                    },\n-                    function (callback) {\n-                        const nodeToRead = {nodeId: registeredNodeIds[0], attributeId: 13};\n-                        session.read(nodeToRead, function (err, dataValue) {\n-                            if (err) {\n-                                return callback(err);\n-                            }\n-                            dataValue.statusCode.should.eql(StatusCodes.Good);\n-                            dataValue2 = dataValue;\n-                            callback();\n-                        });\n-                    },\n-                    function (callback) {\n-                        registeredNodeIds[0].toString().should.not.eql(nodesToRegister[0].toString());\n-                        dataValue1.statusCode.toString().should.eql(dataValue2.statusCode.toString());\n-\n-                        //xx console.log(dataValue1.toString());\n-                        //xx console.log(dataValue2.toString());\n-\n-                        dataValue1.value.toString().should.eql(dataValue2.value.toString());\n-                        callback();\n-                    }\n-                ], inner_done);\n-\n-            }, done);\n+                        ],\n+                        inner_done\n+                    );\n+                },\n+                done\n+            );\n         });\n     });\n };"
        },
        {
          "filename": "packages/node-opcua-end2end-test/test/end_to_end/u_test_e2e_set_triggering.ts",
          "status": "modified",
          "additions": 7,
          "deletions": 7,
          "patch": "@@ -1,3 +1,4 @@\n+/* eslint-disable max-statements */\n // tslint:disable: no-shadowed-variable\n // tslint:disable: no-console\n import {\n@@ -29,6 +30,7 @@ import {\n     OPCUAClient,\n     Range,\n     ServerSidePublishEngine,\n+    ServiceFault,\n     SetTriggeringRequestOptions,\n     StatusCode,\n     StatusCodes,\n@@ -241,16 +243,14 @@ export function t(test: any) {\n \n             try {\n                 const result = await subscription.setTriggering(t, [], []);\n-\n-                //  console.log(result.toString());\n-\n-                result.removeResults?.length.should.eql(0);\n-                result.addResults?.length.should.eql(0);\n-                result.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n+                console.log(result.toString());\n             } catch (err) {\n                 _err = err as Error;\n             }\n-            should.not.exist(_err, \"not expecting any exception\");\n+            should.exist(_err, \"expecting a ServiceFault exception\");\n+            const response = (_err as any).response as ServiceFault;\n+            response.should.be.instanceOf(ServiceFault);\n+            response.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n \n             /*\n              */"
        },
        {
          "filename": "packages/node-opcua-end2end-test/test/end_to_end/u_test_e2e_test_accessing_service_before_session_is_activated.js",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -29,6 +29,7 @@ module.exports = function(test) {\n \n             let session1;\n             let last_response;\n+            let last_response_err;\n             let activate_error;\n             async.series([\n \n@@ -58,6 +59,7 @@ module.exports = function(test) {\n                         console.log(err ? err.toString() : \"null\");\n                         console.log(response ? response.toString() : \"null\");\n                         last_response = response;\n+                        last_response_err = err;\n                         callback();\n                     });\n                 },\n@@ -81,7 +83,7 @@ module.exports = function(test) {\n                 if (err) {\n                     return done(err);\n                 }\n-                last_response.responseHeader.serviceResult.should.eql(StatusCodes.BadSessionNotActivated);\n+                last_response_err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadSessionNotActivated);\n                 should.exist(activate_error, \n                     \"Activate Session should return an error if there has been an attempt to use it before being activated\");\n                 activate_error.message.should.match(/BadSessionIdInvalid|BadSessionClosed/);"
        },
        {
          "filename": "packages/node-opcua-end2end-test/test/end_to_end/u_test_e2e_transfer_session.js",
          "status": "modified",
          "additions": 679,
          "deletions": 691,
          "patch": "@@ -1,724 +1,712 @@\n \"use strict\";\n+const path = require(\"path\");\n+const fs = require(\"fs\");\n const should = require(\"should\");\n const async = require(\"async\");\n const _ = require(\"underscore\");\n-const path = require(\"path\");\n-const fs = require(\"fs\");\n \n-const { \n-  OPCUAClient, \n-  StatusCodes, \n-  PublishRequest,\n-  CreateSubscriptionRequest,\n-  CloseSessionRequest,\n-  ReadRequest,\n-  TimestampsToReturn, \n-  MessageSecurityMode,\n-  SecurityPolicy,\n-  UserNameIdentityToken\n-} = require(\"node-opcua\");\n const {\n-  readCertificate,\n-  readCertificateRevocationList\n-} = require(\"node-opcua-crypto\");\n+    OPCUAClient,\n+    StatusCodes,\n+    PublishRequest,\n+    CreateSubscriptionRequest,\n+    CloseSessionRequest,\n+    ReadRequest,\n+    TimestampsToReturn,\n+    MessageSecurityMode,\n+    SecurityPolicy,\n+    UserNameIdentityToken,\n+    ServiceFault,\n+    ReadResponse\n+} = require(\"node-opcua\");\n+const { readCertificate, readCertificateRevocationList } = require(\"node-opcua-crypto\");\n \n const certificateFolder = path.join(__dirname, \"../../../node-opcua-samples/certificates\");\n fs.existsSync(certificateFolder).should.eql(true, \"expecting certificate store at \" + certificateFolder);\n \n function sendPublishRequest(session, callback) {\n-  const publishRequest = new PublishRequest({});\n-  session.performMessageTransaction(publishRequest, function(err, response) {\n-    callback(err, response);\n-  });\n+    const publishRequest = new PublishRequest({});\n+    session.performMessageTransaction(publishRequest, function (err, response) {\n+        callback(err, response);\n+    });\n }\n \n function createSubscription(session, callback) {\n-  const publishingInterval = 1000;\n-  const createSubscriptionRequest = new CreateSubscriptionRequest({\n-    requestedPublishingInterval: publishingInterval,\n-    requestedLifetimeCount: 60,\n-    requestedMaxKeepAliveCount: 10,\n-    maxNotificationsPerPublish: 10,\n-    publishingEnabled: true,\n-    priority: 6\n-  });\n-\n-  session.performMessageTransaction(createSubscriptionRequest, function(err/*, response*/) {\n-    callback(err);\n-  });\n-}\n-\n-const describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\n-\n-module.exports = function(test) {\n-\n-  describe(\"testing session  transfer to different channel\", function() {\n-\n-    it(\"RQC1 - It should be possible to close a session that has not be activated yet\", function(done) {\n-      let client1;\n-      let session1;\n-      async.series([\n-\n-        function(callback) {\n-          client1 = OPCUAClient.create({});\n-          client1.connect(test.endpointUrl, callback);\n-        },\n-\n-        // create a session using client1, without activating it\n-        function(callback) {\n-          test.server.engine.currentSessionCount.should.eql(0);\n-          client1._createSession(function(err, session) {\n-            if (err) {\n-              return callback(err);\n-            }\n-            session1 = session;\n-            callback();\n-          });\n-        },\n-\n-        function(callback) {\n-\n-          // Question: ? Should a unactivated session be accounted for\n-          //             in the currentSessionCount ?\n-          test.server.engine.currentSessionCount.should.eql(1);\n-\n-          // however client shall not record session yet\n-          client1._sessions.length.should.eql(0);\n-\n-          // in fact, let make sure that close Session is not harmfull\n-          client1.closeSession(session1, /* deleteSubscriptions =*/true, function(err) {\n-            client1._sessions.length.should.eql(0);\n-            if (err) {\n-              // if treated as a Failure , close session expected to return BadSessionNotActivated\n-              err.message.match(/BadSessionNotActivated/);\n-            }\n-            callback();\n-          });\n-\n-        },\n-        function(callback) {\n-          test.server.engine.currentSessionCount.should.eql(0);\n-          callback();\n-        },\n-        function(callback) {\n-          client1.disconnect(callback);\n-        }\n-      ], done);\n-\n+    const publishingInterval = 1000;\n+    const createSubscriptionRequest = new CreateSubscriptionRequest({\n+        requestedPublishingInterval: publishingInterval,\n+        requestedLifetimeCount: 60,\n+        requestedMaxKeepAliveCount: 10,\n+        maxNotificationsPerPublish: 10,\n+        publishingEnabled: true,\n+        priority: 6\n     });\n \n-    it(\"RQB1 - calling CreateSession and CloseSession &  CloseSession again should return BadSessionIdInvalid\", function(done) {\n-      let client1;\n-      let session1;\n-      async.series([\n-\n-        function(callback) {\n-          client1 = OPCUAClient.create();\n-          client1.connect(test.endpointUrl, callback);\n-        },\n-        // create a session using client1\n-        function(callback) {\n-          client1._createSession(function(err, session) {\n-            if (err) {\n-              return callback(err);\n-            }\n-            session1 = session;\n-            callback();\n-          });\n-        },\n-\n-        function(callback) {\n-          session1.close(function() {\n-            callback();\n-          });\n-        },\n-        function(callback) {\n-          session1.close(function(err) {\n-            // now session close do not return error if session in invalid\n-            // err.message.should.match(/SessionIdInvalid/);\n-            should.not.exist(err);\n-            callback();\n-          });\n-        },\n-        //\n-        function(callback) {\n-          test.server.engine.currentSessionCount.should.eql(0);\n-          client1.disconnect(callback);\n-        }\n-\n-      ], done);\n-\n-    });\n-\n-    it(\"RQB2 - calling CloseSession without calling CreateSession first\", function(done) {\n-      let client1;\n-\n-      async.series([\n-\n-        function(callback) {\n-          client1 = OPCUAClient.create({});\n-          client1.connect(test.endpointUrl, callback);\n-        },\n-        function(callback) {\n-          const request = new CloseSessionRequest({\n-            deleteSubscriptions: true\n-          });\n-          client1.performMessageTransaction(request, function(err, response) {\n-            should.not.exist(err);\n-            //err.message.should.match(/BadSessionIdInvalid/);\n-            response.responseHeader.serviceResult.should.eql(StatusCodes.BadSessionIdInvalid);\n-            callback();\n-          });\n-        },\n-        function(callback) {\n-          client1.disconnect(callback);\n-        },\n-        function(callback) {\n-          test.server.engine.currentSessionCount.should.eql(0);\n-          callback();\n-        }\n-      ], done);\n-\n+    session.performMessageTransaction(createSubscriptionRequest, function (err /*, response*/) {\n+        callback(err);\n     });\n+}\n \n-    it(\"RQB3 - calling CreateSession,  CloseSession  and CloseSession again\", function(done) {\n-      let client1;\n-      let session1;\n-      async.series([\n-\n-        function(callback) {\n-          client1 = OPCUAClient.create();\n-          client1.connect(test.endpointUrl, callback);\n-        },\n-        // create a session using client1\n-        function(callback) {\n-          client1.createSession(function(err, session) {\n-            if (err) {\n-              return callback(err);\n-            }\n-            session1 = session;\n-            callback();\n-          });\n-        },\n-\n-        // first call to close session should be OK\n-        function(callback) {\n-          client1.closeSession(session1, /* deleteSubscriptions =*/true, function(err) {\n-            callback(err);\n-          });\n-        },\n-\n-        // second call to close session should raise an error\n-        function(callback) {\n-          const request = new CloseSessionRequest({\n-            deleteSubscriptions: true\n-          });\n-          client1.performMessageTransaction(request, function(err, response) {\n-            should.not.exist(err);\n-            //err.message.should.match(/BadSessionIdInvalid/);\n-            response.responseHeader.serviceResult.should.eql(StatusCodes.BadSessionIdInvalid);\n-            callback();\n-          });\n-        },\n-\n-        function(callback) {\n-          client1.disconnect(callback);\n-        },\n-        function(callback) {\n-          test.server.engine.currentSessionCount.should.eql(0);\n-          callback();\n-        }\n+const describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\n \n-      ], function final(err) {\n-        client1.disconnect(function() {\n-          done(err);\n+module.exports = function (test) {\n+    describe(\"testing session  transfer to different channel\", function () {\n+        it(\"RQC1 - It should be possible to close a session that has not be activated yet\", function (done) {\n+            let client1;\n+            let session1;\n+            async.series(\n+                [\n+                    function (callback) {\n+                        client1 = OPCUAClient.create({});\n+                        client1.connect(test.endpointUrl, callback);\n+                    },\n+\n+                    // create a session using client1, without activating it\n+                    function (callback) {\n+                        test.server.engine.currentSessionCount.should.eql(0);\n+                        client1._createSession(function (err, session) {\n+                            if (err) {\n+                                return callback(err);\n+                            }\n+                            session1 = session;\n+                            callback();\n+                        });\n+                    },\n+\n+                    function (callback) {\n+                        // Question: ? Should a unactivated session be accounted for\n+                        //             in the currentSessionCount ?\n+                        test.server.engine.currentSessionCount.should.eql(1);\n+\n+                        // however client shall not record session yet\n+                        client1._sessions.length.should.eql(0);\n+\n+                        // in fact, let make sure that close Session is not harmfull\n+                        client1.closeSession(session1, /* deleteSubscriptions =*/ true, function (err) {\n+                            client1._sessions.length.should.eql(0);\n+                            if (err) {\n+                                // if treated as a Failure , close session expected to return BadSessionNotActivated\n+                                err.message.match(/BadSessionNotActivated/);\n+                            }\n+                            callback();\n+                        });\n+                    },\n+                    function (callback) {\n+                        test.server.engine.currentSessionCount.should.eql(0);\n+                        callback();\n+                    },\n+                    function (callback) {\n+                        client1.disconnect(callback);\n+                    }\n+                ],\n+                done\n+            );\n         });\n-      });\n \n-    });\n-\n-    it(\"RQ0 - call ActiveSession on a session that has been transferred to a different channel\", function(done) {\n-\n-      // this test verifies that the following requirement can be met\n-      // OpcUA 1.02 part 3 $5.5 Secure Channel Set page 20\n-      // Once a  Client  has established a  Session  it may wish to access the  Session  from a different\n-      // SecureChannel. The Client can do this by validating the new  SecureChannel  with the\n-      // ActivateSession  Service  described in 5.6.3.\n-      let client1, client2;\n-      let session1;\n-      async.series([\n-\n-        // create a first channel (client1)\n-        function(callback) {\n-          client1 = OPCUAClient.create();\n-          client1.connect(test.endpointUrl, callback);\n-        },\n-        // create a session using client1\n-        function(callback) {\n-          client1._createSession(function(err, session) {\n-            if (err) {\n-              return callback(err);\n-            }\n-            session1 = session;\n-            callback();\n-          });\n-        },\n-        // activate the session as expected on same channel used to create it\n-        function(callback) {\n-          client1._activateSession(session1, function(err) {\n-            callback(err);\n-          });\n-        },\n-        // let verify that it is now possible to send a request on client1's session\n-        function(callback) {\n-          // coerce nodeIds\n-          const request = new ReadRequest({\n-            nodesToRead: [{ nodeId: \"i=2255\", attributeId: 13 }],\n-            maxAge: 0,\n-            timestampsToReturn: TimestampsToReturn.Both\n-          });\n-          request.requestHeader.authenticationToken = session1.authenticationToken;\n-          client1.performMessageTransaction(request, function(err, response) {\n-            should.not.exist(err);\n-            response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n-            callback();\n-          });\n-        },\n-\n-        // create a second channel (client2)\n-        function(callback) {\n-          client2 = OPCUAClient.create();\n-          client2.connect(test.endpointUrl, callback);\n-        },\n-\n-        // reactivate session on second channel\n-        function(callback) {\n-          client2.reactivateSession(session1, function(err) {\n-            callback(err);\n-          });\n-        },\n-\n-        // now that session has been assigned to client 1,\n-        // server shall refuse any requests on channel1\n-        function(callback) {\n-          // coerce nodeIds\n-          const request = new ReadRequest({\n-            nodesToRead: [{ nodeId: \"i=2255\", attributeId: 13 }],\n-            maxAge: 0,\n-            timestampsToReturn: TimestampsToReturn.Both\n-          });\n-          request.requestHeader.authenticationToken = session1.authenticationToken;\n-          client1.performMessageTransaction(request, function(err, response) {\n-            if (!err) {\n-              response.responseHeader.serviceResult.should.eql(StatusCodes.BadSecureChannelIdInvalid);\n-            }\n-            callback(err);\n-          });\n-        },\n-        // but server shall access request on new channel\n-        function(callback) {\n-          // coerce nodeIds\n-          const request = new ReadRequest({\n-            nodesToRead: [{ nodeId: \"i=2255\", attributeId: 13 }],\n-            maxAge: 0,\n-            timestampsToReturn: TimestampsToReturn.Both\n-          });\n-          request.requestHeader.authenticationToken = session1.authenticationToken;\n-          client2.performMessageTransaction(request, function(err, response) {\n-            if (!err) {\n-              response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n-            }\n-            callback(err);\n-          });\n-        },\n-\n-\n-        // terminate\n-        function(callback) {\n-          client2.disconnect(callback);\n-        },\n-        function(callback) {\n-          client1.disconnect(callback);\n-        },\n-        function(callback) {\n-          test.server.engine.currentSessionCount.should.eql(0);\n-          callback();\n-        }\n-\n-      ], done);\n-    });\n-\n-    // OpcUA 1.02 part 3 $5.6.3.1 ActiveSession Set page 29\n-    // When the ActivateSession  Service  is called f or the first time then the Server shall reject the request\n-    // if the  SecureChannel  is not same as the one associated with the CreateSession  request.\n-    it(\"RQ1 - should reject if the channel used to activate the session for the first time is not the same as the channel used to create the session\", function(done) {\n-\n-      let client1, client2;\n-      let session1;\n-\n-      let initialChannelCount = 0;\n-      async.series([\n-\n-        // create a first channel (client1)\n-        function(callback) {\n-          initialChannelCount = test.server.getChannels().length;\n-          test.server.getChannels().length.should.equal(initialChannelCount);\n-          client1 = OPCUAClient.create();\n-          client1.connect(test.endpointUrl, callback);\n-        },\n-\n-        // create a session using client1\n-        //   ( without activating it)\n-        function(callback) {\n-          client1._createSession(function(err, session) {\n-            if (err) {\n-              return callback(err);\n-            }\n-            session1 = session;\n-            test.server.getChannels().length.should.equal(initialChannelCount + 1);\n-            callback();\n-          });\n-        },\n-        // create a second channel (client2)\n-        function(callback) {\n-          client2 = OPCUAClient.create();\n-          client2.connect(test.endpointUrl, callback);\n-        },\n-\n-        // activate the session created with client1 using client2 !!\n-        // this should be detected by server and server shall return an error\n-        function(callback) {\n-          test.server.getChannels().length.should.equal(initialChannelCount + 2);\n-          //xx console.log(\" ID1 =\", client1._secureChannel.channelId);\n-          //xx console.log(\" ID2 =\", client2._secureChannel.channelId);\n-\n-          client2.reactivateSession(session1, function(err) {\n-\n-            if (!err) {\n-              callback(new Error(\"_activateSession shall return an error \"));\n-            }\n-            err.message.should.match(/BadSessionNotActivated/);\n-            callback();\n-          });\n-        },\n-\n-        // terminate\n-        function(callback) {\n-          client2.disconnect(callback);\n-        },\n-        // activate the session as expected on same channel used to create it\n-        // so we can close it properly\n-        function(callback) {\n-          client1._activateSession(session1, function(err) {\n-            should.not.exist(err);\n-            session1.close(callback);\n-          });\n-        },\n-        function(callback) {\n-          client1.disconnect(callback);\n-        },\n-        function(callback) {\n-          test.server.engine.currentSessionCount.should.eql(0);\n-          callback();\n-        }\n-\n-      ], done);\n-    });\n+        it(\"RQB1 - calling CreateSession and CloseSession &  CloseSession again should return BadSessionIdInvalid\", function (done) {\n+            let client1;\n+            let session1;\n+            async.series(\n+                [\n+                    function (callback) {\n+                        client1 = OPCUAClient.create();\n+                        client1.connect(test.endpointUrl, callback);\n+                    },\n+                    // create a session using client1\n+                    function (callback) {\n+                        client1._createSession(function (err, session) {\n+                            if (err) {\n+                                return callback(err);\n+                            }\n+                            session1 = session;\n+                            callback();\n+                        });\n+                    },\n+\n+                    function (callback) {\n+                        session1.close(function () {\n+                            callback();\n+                        });\n+                    },\n+                    function (callback) {\n+                        session1.close(function (err) {\n+                            // now session close do not return error if session in invalid\n+                            // err.message.should.match(/SessionIdInvalid/);\n+                            should.not.exist(err);\n+                            callback();\n+                        });\n+                    },\n+                    //\n+                    function (callback) {\n+                        test.server.engine.currentSessionCount.should.eql(0);\n+                        client1.disconnect(callback);\n+                    }\n+                ],\n+                done\n+            );\n+        });\n \n+        it(\"RQB2 - calling CloseSession without calling CreateSession first\", function (done) {\n+            let client1;\n+\n+            async.series(\n+                [\n+                    function (callback) {\n+                        client1 = OPCUAClient.create({});\n+                        client1.connect(test.endpointUrl, callback);\n+                    },\n+                    function (callback) {\n+                        const request = new CloseSessionRequest({\n+                            deleteSubscriptions: true\n+                        });\n+                        client1.performMessageTransaction(request, function (err, response) {\n+                            should.exist(err);\n+                            should.not.exist(response);\n+                            err.response.should.be.instanceOf(ServiceFault);\n+                            err.message.should.match(/BadSessionIdInvalid/);\n+                            err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadSessionIdInvalid);\n+                            callback();\n+                        });\n+                    },\n+                    function (callback) {\n+                        client1.disconnect(callback);\n+                    },\n+                    function (callback) {\n+                        test.server.engine.currentSessionCount.should.eql(0);\n+                        callback();\n+                    }\n+                ],\n+                done\n+            );\n+        });\n \n-    function m(file) {\n-      const p = path.join(certificateFolder, file);\n-      if (!fs.existsSync(p)) {\n-        console.error(\" cannot find \", p);\n-      }\n-      return p;\n-    }\n-\n-    // OpcUA 1.02 part 3 $5.6.3.1 ActiveSession Set page 29\n-    // Subsequent calls to  ActivateSession  may be associated with different  SecureChannels.  If this is the\n-    // case then  the  Server  shall verify that the  Certificate  the  Client  used to create the new\n-    // SecureChannel  is the same as the  Certificate  used to create the original  SecureChannel.\n-    it(\"RQ2 -server should raise an error if a existing session is reactivated from a channel that have different certificate than the original channel\", function(done) {\n-\n-      const serverCertificate = test.server.getCertificateChain();\n-\n-      let client1, client2;\n-      let session1;\n-      async.series([\n-\n-        // create a first channel (client1) with\n-        function(callback) {\n-          //xx console.log(\" creating initial channel with some certificate\");\n-          const certificateFile1 = m(\"client_cert_2048.pem\");\n-          const privateKeyFile1 = m(\"client_key_2048.pem\");\n-          console.log(certificateFile1);\n-\n-          client1 = OPCUAClient.create({\n-            certificateFile: certificateFile1,\n-            privateKeyFile: privateKeyFile1,\n-            securityMode: MessageSecurityMode.Sign,\n-            securityPolicy: SecurityPolicy.Basic128Rsa15,\n-            serverCertificate: serverCertificate\n-          });\n-\n-   \n-          const certificate = readCertificate(certificateFile1);\n-\n-          async function doIt() {\n-            await test.server.serverCertificateManager.trustCertificate(certificate);\n-            const issuerCertificateFile = m(\"CA/public/cacert.pem\");\n-            const issuerCertificateRevocationListFile = m(\"CA/crl/revocation_list.der\");\n-            const issuerCertificate = readCertificate(issuerCertificateFile);\n-            const issuerCrl = await readCertificateRevocationList(issuerCertificateRevocationListFile);\n-            await test.server.serverCertificateManager.addIssuer(issuerCertificate);\n-            await test.server.serverCertificateManager.addRevocationList(issuerCrl);\n-            callback();\n-          }\n-          doIt();\n-        },\n-        function(callback) {\n-          client1.connect(test.endpointUrl, callback);\n-        },\n-        // create a session using client1\n-        function(callback) {\n-          //xx console.log(\" create session\");\n-          client1._createSession(function(err, session) {\n-            if (err) {\n-              return callback(err);\n-            }\n-            session1 = session;\n-            callback();\n-          });\n-        },\n-        // activate the session as expected on same channel used to create it\n-        function(callback) {\n-          //xx console.log(\" activate session\");\n-          client1._activateSession(session1, function(err) {\n-            callback(err);\n-          });\n-        },\n-\n-        // create a second channel (client2)\n-        // with a different certificate ....\n-        function(callback) {\n-\n-          // creating second channel with different credential\n-          console.log(\" creating second channel with different certificate\");\n-          const certificateFile2 = m(\"client_cert_3072.pem\");\n-          const privateKeyFile2 = m(\"client_key_3072.pem\");\n-          client2 = OPCUAClient.create({\n-            certificateFile: certificateFile2,\n-            privateKeyFile: privateKeyFile2,\n-            securityMode: MessageSecurityMode.Sign,\n-            securityPolicy: SecurityPolicy.Basic256,\n-            serverCertificate: serverCertificate\n-          });\n-          const certificate = readCertificate(certificateFile2);\n-          test.server.serverCertificateManager.trustCertificate(certificate, callback);\n-\n-        },\n-        function(callback) {\n-          client2.connect(test.endpointUrl, callback);\n-        },\n-        function(callback) {\n-          // reactivate session on second channel\n-          // Reactivate should fail because certificate is not the same as the original one\n-          client2.reactivateSession(session1, function(err) {\n-            if (err) {\n-              err.message.should.match(/BadNoValidCertificates/);\n-              callback();\n-            } else {\n-              callback(new Error(\"expecting reactivateSession to fail\"));\n-            }\n-          });\n-        },\n-        // terminate\n-        function(callback) {\n-          client2.disconnect(callback);\n-        },\n-        function(callback) {\n-          session1.close(callback);\n-        },\n-        function(callback) {\n-          client1.disconnect(callback);\n-        },\n-\n-        function(callback) {\n-          test.server.engine.currentSessionCount.should.eql(0);\n-          callback();\n-        }\n+        it(\"RQB3 - calling CreateSession,  CloseSession  and CloseSession again\", function (done) {\n+            let client1;\n+            let session1;\n+            async.series(\n+                [\n+                    function (callback) {\n+                        client1 = OPCUAClient.create();\n+                        client1.connect(test.endpointUrl, callback);\n+                    },\n+                    // create a session using client1\n+                    function (callback) {\n+                        client1.createSession(function (err, session) {\n+                            if (err) {\n+                                return callback(err);\n+                            }\n+                            session1 = session;\n+                            callback();\n+                        });\n+                    },\n+\n+                    // first call to close session should be OK\n+                    function (callback) {\n+                        client1.closeSession(session1, /* deleteSubscriptions =*/ true, function (err) {\n+                            callback(err);\n+                        });\n+                    },\n+\n+                    // second call to close session should raise an error\n+                    function (callback) {\n+                        const request = new CloseSessionRequest({\n+                            deleteSubscriptions: true\n+                        });\n+                        client1.performMessageTransaction(request, function (err, response) {\n+                            should.exist(err);\n+                            should.not.exist(response);\n+                            err.message.should.match(/BadSessionIdInvalid/);\n+                            err.response.should.be.instanceOf(ServiceFault);\n+                            err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadSessionIdInvalid);\n+                            callback();\n+                        });\n+                    },\n+\n+                    function (callback) {\n+                        client1.disconnect(callback);\n+                    },\n+                    function (callback) {\n+                        test.server.engine.currentSessionCount.should.eql(0);\n+                        callback();\n+                    }\n+                ],\n+                function final(err) {\n+                    client1.disconnect(function () {\n+                        done(err);\n+                    });\n+                }\n+            );\n+        });\n \n-      ], done);\n+        it(\"RQ0 - call ActiveSession on a session that has been transferred to a different channel\", function (done) {\n+            // this test verifies that the following requirement can be met\n+            // OpcUA 1.02 part 3 $5.5 Secure Channel Set page 20\n+            // Once a  Client  has established a  Session  it may wish to access the  Session  from a different\n+            // SecureChannel. The Client can do this by validating the new  SecureChannel  with the\n+            // ActivateSession  Service  described in 5.6.3.\n+            let client1, client2;\n+            let session1;\n+            async.series(\n+                [\n+                    // create a first channel (client1)\n+                    function (callback) {\n+                        client1 = OPCUAClient.create();\n+                        client1.connect(test.endpointUrl, callback);\n+                    },\n+                    // create a session using client1\n+                    function (callback) {\n+                        client1._createSession(function (err, session) {\n+                            if (err) {\n+                                return callback(err);\n+                            }\n+                            session1 = session;\n+                            callback();\n+                        });\n+                    },\n+                    // activate the session as expected on same channel used to create it\n+                    function (callback) {\n+                        client1._activateSession(session1, function (err) {\n+                            callback(err);\n+                        });\n+                    },\n+                    // let verify that it is now possible to send a request on client1's session\n+                    function (callback) {\n+                        // coerce nodeIds\n+                        const request = new ReadRequest({\n+                            nodesToRead: [{ nodeId: \"i=2255\", attributeId: 13 }],\n+                            maxAge: 0,\n+                            timestampsToReturn: TimestampsToReturn.Both\n+                        });\n+                        request.requestHeader.authenticationToken = session1.authenticationToken;\n+                        client1.performMessageTransaction(request, function (err, response) {\n+                            should.not.exist(err);\n+                            response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n+                            callback();\n+                        });\n+                    },\n+\n+                    // create a second channel (client2)\n+                    function (callback) {\n+                        client2 = OPCUAClient.create();\n+                        client2.connect(test.endpointUrl, callback);\n+                    },\n+\n+                    // reactivate session on second channel\n+                    function (callback) {\n+                        client2.reactivateSession(session1, function (err) {\n+                            callback(err);\n+                        });\n+                    },\n+\n+                    // now that session has been assigned to client 1,\n+                    // server shall refuse any requests on channel1\n+                    function (callback) {\n+                        // coerce nodeIds\n+                        const request = new ReadRequest({\n+                            nodesToRead: [{ nodeId: \"i=2255\", attributeId: 13 }],\n+                            maxAge: 0,\n+                            timestampsToReturn: TimestampsToReturn.Both\n+                        });\n+                        request.requestHeader.authenticationToken = session1.authenticationToken;\n+                        client1.performMessageTransaction(request, function (err, response) {\n+                            should.not.exist(err);\n+                            should.exist(response);\n+                            response.should.be.instanceOf(ReadResponse);\n+                            response.responseHeader.serviceResult.should.eql(StatusCodes.BadSecureChannelIdInvalid);\n+                            callback();\n+                        });\n+                    },\n+                    // but server shall access request on new channel\n+                    function (callback) {\n+                        // coerce nodeIds\n+                        const request = new ReadRequest({\n+                            nodesToRead: [{ nodeId: \"i=2255\", attributeId: 13 }],\n+                            maxAge: 0,\n+                            timestampsToReturn: TimestampsToReturn.Both\n+                        });\n+                        request.requestHeader.authenticationToken = session1.authenticationToken;\n+                        client2.performMessageTransaction(request, function (err, response) {\n+                            if (!err) {\n+                                response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n+                            }\n+                            callback(err);\n+                        });\n+                    },\n+\n+                    // terminate\n+                    function (callback) {\n+                        client2.disconnect(callback);\n+                    },\n+                    function (callback) {\n+                        client1.disconnect(callback);\n+                    },\n+                    function (callback) {\n+                        test.server.engine.currentSessionCount.should.eql(0);\n+                        callback();\n+                    }\n+                ],\n+                done\n+            );\n+        });\n \n-    });\n+        // OpcUA 1.02 part 3 $5.6.3.1 ActiveSession Set page 29\n+        // When the ActivateSession  Service  is called f or the first time then the Server shall reject the request\n+        // if the  SecureChannel  is not same as the one associated with the CreateSession  request.\n+        it(\"RQ1 - should reject if the channel used to activate the session for the first time is not the same as the channel used to create the session\", function (done) {\n+            let client1, client2;\n+            let session1;\n+\n+            let initialChannelCount = 0;\n+            async.series(\n+                [\n+                    // create a first channel (client1)\n+                    function (callback) {\n+                        initialChannelCount = test.server.getChannels().length;\n+                        test.server.getChannels().length.should.equal(initialChannelCount);\n+                        client1 = OPCUAClient.create();\n+                        client1.connect(test.endpointUrl, callback);\n+                    },\n+\n+                    // create a session using client1\n+                    //   ( without activating it)\n+                    function (callback) {\n+                        client1._createSession(function (err, session) {\n+                            if (err) {\n+                                return callback(err);\n+                            }\n+                            session1 = session;\n+                            test.server.getChannels().length.should.equal(initialChannelCount + 1);\n+                            callback();\n+                        });\n+                    },\n+                    // create a second channel (client2)\n+                    function (callback) {\n+                        client2 = OPCUAClient.create();\n+                        client2.connect(test.endpointUrl, callback);\n+                    },\n+\n+                    // activate the session created with client1 using client2 !!\n+                    // this should be detected by server and server shall return an error\n+                    function (callback) {\n+                        test.server.getChannels().length.should.equal(initialChannelCount + 2);\n+                        //xx console.log(\" ID1 =\", client1._secureChannel.channelId);\n+                        //xx console.log(\" ID2 =\", client2._secureChannel.channelId);\n+\n+                        client2.reactivateSession(session1, function (err) {\n+                            if (!err) {\n+                                callback(new Error(\"_activateSession shall return an error \"));\n+                            }\n+                            err.message.should.match(/BadSessionNotActivated/);\n+                            callback();\n+                        });\n+                    },\n+\n+                    // terminate\n+                    function (callback) {\n+                        client2.disconnect(callback);\n+                    },\n+                    // activate the session as expected on same channel used to create it\n+                    // so we can close it properly\n+                    function (callback) {\n+                        client1._activateSession(session1, function (err) {\n+                            should.not.exist(err);\n+                            session1.close(callback);\n+                        });\n+                    },\n+                    function (callback) {\n+                        client1.disconnect(callback);\n+                    },\n+                    function (callback) {\n+                        test.server.engine.currentSessionCount.should.eql(0);\n+                        callback();\n+                    }\n+                ],\n+                done\n+            );\n+        });\n \n-    // In addition,the Server shall verify that the  Client  supplied a  UserIdentityToken  that is   identical to the token\n-    // currently associated with the  Session.\n-    it(\"RQ3 - server should raise an error if a session is reactivated with different user identity tokens\", function(done) {\n-      let client1, client2;\n-      let session1;\n-\n-      const user1 = {\n-        userName: \"user1\", password: \"password1\"\n-      };\n-      const user2 = new UserNameIdentityToken({\n-        userName: \"user1\", password: \"password1\"\n-      });\n-      //xx console.log(\" user1 \", user1.toString());\n-      async.series([\n-\n-        // given a established session with a subscription and some publish request\n-\n-        function(callback) {\n-          client1 = OPCUAClient.create();\n-          client1.connect(test.endpointUrl, callback);\n-        },\n-        // create a session using client1\n-        function(callback) {\n-\n-          client1.createSession(user1, function(err, session) {\n-            if (err) {\n-              return callback(err);\n+        function m(file) {\n+            const p = path.join(certificateFolder, file);\n+            if (!fs.existsSync(p)) {\n+                console.error(\" cannot find \", p);\n             }\n-            session1 = session;\n-            callback();\n-          });\n-        },\n-        // when the session is transferred to a different channel\n-        // create a second channel (client2)\n-        function(callback) {\n-          client2 = OPCUAClient.create();\n-          client2.connect(test.endpointUrl, callback);\n-        },\n-        function(callback) {\n-          // reactivate session on second channel\n-          // alter session1.userIdentityInfo\n-          session1.userIdentityInfo = user2;\n-          session1.userIdentityInfo.userName.should.eql(\"user1\");\n-\n-          client2.reactivateSession(session1, function(err) {\n-            err.message.should.match(/BadIdentityChangeNotSupported/);\n-            _.contains(client1._sessions, session1).should.eql(true);// should have failed\n-            callback();\n-          });\n-        },\n-        // terminate\n-        function(callback) {\n-          client2.disconnect(callback);\n-        },\n-        function(callback) {\n-          client1.disconnect(callback);\n-        },\n-        function(callback) {\n-          test.server.engine.currentSessionCount.should.eql(0);\n-          callback();\n+            return p;\n         }\n \n-      ], done);\n-\n-    });\n-    // Once the Server accepts the new  SecureChannel  it shall reject requests sent via the old  SecureChannel.\n-    xit(\"RQ4 - server should reject request send via old channel when session has been transferred to new channel\", function(done) {\n-      async.series([], done);\n-    });\n-\n-    // unprocessed pending Requests such as PublishRequest shall be be denied by the server\n-    // Once the Server accepts the new  SecureChannel  it shall reject requests sent via the old  SecureChannel\n-    it(\"RQ5 - server should reject pending requests send to old channel when session has been transferred to new channel\", function(done) {\n-\n-      const sinon = require(\"sinon\");\n-\n-      const collectPublishResponse = sinon.spy();\n-\n-      let client1, client2;\n-      let session1;\n-      async.series([\n-\n-        // given a established session with a subscription and some publish request\n-\n-        function(callback) {\n-          client1 = OPCUAClient.create();\n-          client1.connect(test.endpointUrl, callback);\n-        },\n-        // create a session using client1\n-        function(callback) {\n-          client1._createSession(function(err, session) {\n-            if (err) {\n-              return callback(err);\n-            }\n-            session1 = session;\n-            callback();\n-          });\n-        },\n-        // activate the session as expected on same channel used to create it\n-        function(callback) {\n-          client1._activateSession(session1, function(err) {\n-            callback(err);\n-          });\n-        },\n-\n-        // creaet a subscription,\n-        function(callback) {\n-          createSubscription(session1, callback);\n-        },\n-\n-\n-        // when the session is transferred to a different channel\n-        // create a second channel (client2)\n-        function(callback) {\n-          client2 = OPCUAClient.create();\n-          client2.connect(test.endpointUrl, callback);\n-          collectPublishResponse.callCount.should.eql(0);\n-        },\n-\n-        // provision 3 publish requests and wait for the first keep alive\n-        function(callback) {\n-\n-          sendPublishRequest(session1, function(err) {\n-            should.not.exist(err);\n-            collectPublishResponse.callCount.should.eql(0);\n-            callback();\n-          });\n-          sendPublishRequest(session1, collectPublishResponse);\n-          sendPublishRequest(session1, collectPublishResponse);\n-        },\n-\n-\n-        function(callback) {\n-          // reactivate session on second channel\n-          client2.reactivateSession(session1, function(err) {\n-            callback(err);\n-          });\n-        },\n-        function(callback) {\n-          setTimeout(callback, 100);\n-        },\n-\n-        function(callback) {\n-\n-          collectPublishResponse.callCount.should.eql(2);\n-          collectPublishResponse.getCall(0).args[0].message.should.match(/BadSecureChannelClosed/);\n-          collectPublishResponse.getCall(1).args[0].message.should.match(/BadSecureChannelClosed/);\n-          callback();\n-        },\n-\n-\n-        // terminate\n-        function(callback) {\n-          client2.disconnect(callback);\n-        },\n-        function(callback) {\n-          client1.disconnect(callback);\n-        },\n-        function(callback) {\n-          test.server.engine.currentSessionCount.should.eql(0);\n-          callback();\n-        }\n+        // OpcUA 1.02 part 3 $5.6.3.1 ActiveSession Set page 29\n+        // Subsequent calls to  ActivateSession  may be associated with different  SecureChannels.  If this is the\n+        // case then  the  Server  shall verify that the  Certificate  the  Client  used to create the new\n+        // SecureChannel  is the same as the  Certificate  used to create the original  SecureChannel.\n+        it(\"RQ2 -server should raise an error if a existing session is reactivated from a channel that have different certificate than the original channel\", function (done) {\n+            const serverCertificate = test.server.getCertificateChain();\n+\n+            let client1, client2;\n+            let session1;\n+            async.series(\n+                [\n+                    // create a first channel (client1) with\n+                    function (callback) {\n+                        //xx console.log(\" creating initial channel with some certificate\");\n+                        const certificateFile1 = m(\"client_cert_2048.pem\");\n+                        const privateKeyFile1 = m(\"client_key_2048.pem\");\n+                        console.log(certificateFile1);\n+\n+                        client1 = OPCUAClient.create({\n+                            certificateFile: certificateFile1,\n+                            privateKeyFile: privateKeyFile1,\n+                            securityMode: MessageSecurityMode.Sign,\n+                            securityPolicy: SecurityPolicy.Basic128Rsa15,\n+                            serverCertificate: serverCertificate\n+                        });\n+\n+                        const certificate = readCertificate(certificateFile1);\n+\n+                        async function doIt() {\n+                            await test.server.serverCertificateManager.trustCertificate(certificate);\n+                            const issuerCertificateFile = m(\"CA/public/cacert.pem\");\n+                            const issuerCertificateRevocationListFile = m(\"CA/crl/revocation_list.der\");\n+                            const issuerCertificate = readCertificate(issuerCertificateFile);\n+                            const issuerCrl = await readCertificateRevocationList(issuerCertificateRevocationListFile);\n+                            await test.server.serverCertificateManager.addIssuer(issuerCertificate);\n+                            await test.server.serverCertificateManager.addRevocationList(issuerCrl);\n+                            callback();\n+                        }\n+                        doIt();\n+                    },\n+                    function (callback) {\n+                        client1.connect(test.endpointUrl, callback);\n+                    },\n+                    // create a session using client1\n+                    function (callback) {\n+                        //xx console.log(\" create session\");\n+                        client1._createSession(function (err, session) {\n+                            if (err) {\n+                                return callback(err);\n+                            }\n+                            session1 = session;\n+                            callback();\n+                        });\n+                    },\n+                    // activate the session as expected on same channel used to create it\n+                    function (callback) {\n+                        //xx console.log(\" activate session\");\n+                        client1._activateSession(session1, function (err) {\n+                            callback(err);\n+                        });\n+                    },\n+\n+                    // create a second channel (client2)\n+                    // with a different certificate ....\n+                    function (callback) {\n+                        // creating second channel with different credential\n+                        console.log(\" creating second channel with different certificate\");\n+                        const certificateFile2 = m(\"client_cert_3072.pem\");\n+                        const privateKeyFile2 = m(\"client_key_3072.pem\");\n+                        client2 = OPCUAClient.create({\n+                            certificateFile: certificateFile2,\n+                            privateKeyFile: privateKeyFile2,\n+                            securityMode: MessageSecurityMode.Sign,\n+                            securityPolicy: SecurityPolicy.Basic256,\n+                            serverCertificate: serverCertificate\n+                        });\n+                        const certificate = readCertificate(certificateFile2);\n+                        test.server.serverCertificateManager.trustCertificate(certificate, callback);\n+                    },\n+                    function (callback) {\n+                        client2.connect(test.endpointUrl, callback);\n+                    },\n+                    function (callback) {\n+                        // reactivate session on second channel\n+                        // Reactivate should fail because certificate is not the same as the original one\n+                        client2.reactivateSession(session1, function (err) {\n+                            if (err) {\n+                                err.message.should.match(/BadNoValidCertificates/);\n+                                callback();\n+                            } else {\n+                                callback(new Error(\"expecting reactivateSession to fail\"));\n+                            }\n+                        });\n+                    },\n+                    // terminate\n+                    function (callback) {\n+                        client2.disconnect(callback);\n+                    },\n+                    function (callback) {\n+                        session1.close(callback);\n+                    },\n+                    function (callback) {\n+                        client1.disconnect(callback);\n+                    },\n+\n+                    function (callback) {\n+                        test.server.engine.currentSessionCount.should.eql(0);\n+                        callback();\n+                    }\n+                ],\n+                done\n+            );\n+        });\n \n-      ], done);\n+        // In addition,the Server shall verify that the  Client  supplied a  UserIdentityToken  that is   identical to the token\n+        // currently associated with the  Session.\n+        it(\"RQ3 - server should raise an error if a session is reactivated with different user identity tokens\", function (done) {\n+            let client1, client2;\n+            let session1;\n+\n+            const user1 = {\n+                userName: \"user1\",\n+                password: \"password1\"\n+            };\n+            const user2 = new UserNameIdentityToken({\n+                userName: \"user1\",\n+                password: \"password1\"\n+            });\n+            //xx console.log(\" user1 \", user1.toString());\n+            async.series(\n+                [\n+                    // given a established session with a subscription and some publish request\n+\n+                    function (callback) {\n+                        client1 = OPCUAClient.create();\n+                        client1.connect(test.endpointUrl, callback);\n+                    },\n+                    // create a session using client1\n+                    function (callback) {\n+                        client1.createSession(user1, function (err, session) {\n+                            if (err) {\n+                                return callback(err);\n+                            }\n+                            session1 = session;\n+                            callback();\n+                        });\n+                    },\n+                    // when the session is transferred to a different channel\n+                    // create a second channel (client2)\n+                    function (callback) {\n+                        client2 = OPCUAClient.create();\n+                        client2.connect(test.endpointUrl, callback);\n+                    },\n+                    function (callback) {\n+                        // reactivate session on second channel\n+                        // alter session1.userIdentityInfo\n+                        session1.userIdentityInfo = user2;\n+                        session1.userIdentityInfo.userName.should.eql(\"user1\");\n+\n+                        client2.reactivateSession(session1, function (err) {\n+                            err.message.should.match(/BadIdentityChangeNotSupported/);\n+                            _.contains(client1._sessions, session1).should.eql(true); // should have failed\n+                            callback();\n+                        });\n+                    },\n+                    // terminate\n+                    function (callback) {\n+                        client2.disconnect(callback);\n+                    },\n+                    function (callback) {\n+                        client1.disconnect(callback);\n+                    },\n+                    function (callback) {\n+                        test.server.engine.currentSessionCount.should.eql(0);\n+                        callback();\n+                    }\n+                ],\n+                done\n+            );\n+        });\n+        // Once the Server accepts the new  SecureChannel  it shall reject requests sent via the old  SecureChannel.\n+        xit(\"RQ4 - server should reject request send via old channel when session has been transferred to new channel\", function (done) {\n+            async.series([], done);\n+        });\n \n+        // unprocessed pending Requests such as PublishRequest shall be be denied by the server\n+        // Once the Server accepts the new  SecureChannel  it shall reject requests sent via the old  SecureChannel\n+        it(\"RQ5 - server should reject pending requests send to old channel when session has been transferred to new channel\", function (done) {\n+            const sinon = require(\"sinon\");\n+\n+            const collectPublishResponse = sinon.spy();\n+\n+            let client1, client2;\n+            let session1;\n+            async.series(\n+                [\n+                    // given a established session with a subscription and some publish request\n+\n+                    function (callback) {\n+                        client1 = OPCUAClient.create();\n+                        client1.connect(test.endpointUrl, callback);\n+                    },\n+                    // create a session using client1\n+                    function (callback) {\n+                        client1._createSession(function (err, session) {\n+                            if (err) {\n+                                return callback(err);\n+                            }\n+                            session1 = session;\n+                            callback();\n+                        });\n+                    },\n+                    // activate the session as expected on same channel used to create it\n+                    function (callback) {\n+                        client1._activateSession(session1, function (err) {\n+                            callback(err);\n+                        });\n+                    },\n+\n+                    // creaet a subscription,\n+                    function (callback) {\n+                        createSubscription(session1, callback);\n+                    },\n+\n+                    // when the session is transferred to a different channel\n+                    // create a second channel (client2)\n+                    function (callback) {\n+                        client2 = OPCUAClient.create();\n+                        client2.connect(test.endpointUrl, callback);\n+                        collectPublishResponse.callCount.should.eql(0);\n+                    },\n+\n+                    // provision 3 publish requests and wait for the first keep alive\n+                    function (callback) {\n+                        sendPublishRequest(session1, function (err) {\n+                            should.not.exist(err);\n+                            collectPublishResponse.callCount.should.eql(0);\n+                            callback();\n+                        });\n+                        sendPublishRequest(session1, collectPublishResponse);\n+                        sendPublishRequest(session1, collectPublishResponse);\n+                    },\n+\n+                    function (callback) {\n+                        // reactivate session on second channel\n+                        client2.reactivateSession(session1, function (err) {\n+                            callback(err);\n+                        });\n+                    },\n+                    function (callback) {\n+                        setTimeout(callback, 100);\n+                    },\n+\n+                    function (callback) {\n+                        collectPublishResponse.callCount.should.eql(2);\n+                        collectPublishResponse.getCall(0).args[0].message.should.match(/BadSecureChannelClosed/);\n+                        collectPublishResponse.getCall(1).args[0].message.should.match(/BadSecureChannelClosed/);\n+                        callback();\n+                    },\n+\n+                    // terminate\n+                    function (callback) {\n+                        client2.disconnect(callback);\n+                    },\n+                    function (callback) {\n+                        client1.disconnect(callback);\n+                    },\n+                    function (callback) {\n+                        test.server.engine.currentSessionCount.should.eql(0);\n+                        callback();\n+                    }\n+                ],\n+                done\n+            );\n+        });\n     });\n-\n-  });\n-\n };"
        },
        {
          "filename": "packages/node-opcua-secure-channel/source/client/client_secure_channel_layer.ts",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -119,7 +119,8 @@ function process_request_callback(requestData: RequestData, err?: Error | null,\n         err = new Error(\" serviceResult = \" + response.responseHeader.serviceResult.toString());\r\n         //  \"  returned by server \\n response:\" + response.toString() + \"\\n  request: \" + request.toString());\r\n         (err as any).response = response;\r\n-        ((err as any).request = request), (response = undefined);\r\n+        (err as any).request = request;\r\n+        response = undefined;\r\n     }\r\n \r\n     const theCallbackFunction = requestData.callback;\r\n@@ -1721,7 +1722,7 @@ export class ClientSecureChannelLayer extends EventEmitter {\n         // istanbul ignore next\r\n         if (!this.derivedKeys || !this.derivedKeys.derivedClientKeys) {\r\n             errorLog(\"derivedKeys not set but security mode = \", MessageSecurityMode[this.securityMode]);\r\n-            return null; // \r\n+            return null; //\r\n             // throw new Error(\"internal error expecting valid derivedKeys while security mode is \" + MessageSecurityMode[this.securityMode]);\r\n         }\r\n \r"
        },
        {
          "filename": "packages/node-opcua-server-discovery/source/opcua_discovery_server.ts",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -15,7 +15,7 @@ import { UAString } from \"node-opcua-basic-types\";\n import { makeApplicationUrn } from \"node-opcua-common\";\n import { checkDebugFlag, make_debugLog } from \"node-opcua-debug\";\n import { extractFullyQualifiedDomainName, resolveFullyQualifiedDomainName } from \"node-opcua-hostname\";\n-import { Message, Response, ServerSecureChannelLayer } from \"node-opcua-secure-channel\";\n+import { Message, Response, ServerSecureChannelLayer, ServiceFault } from \"node-opcua-secure-channel\";\n import { OPCUABaseServer, OPCUABaseServerOptions, OPCUAServerEndPoint } from \"node-opcua-server\";\n \n import {\n@@ -390,7 +390,7 @@ export class OPCUADiscoveryServer extends OPCUABaseServer {\n \n         function sendError(statusCode: StatusCode): Response {\n             debugLog(chalk.red(\"_on_RegisterServer(2)Request error\"), statusCode.toString());\n-            const response1 = new RegisterServerXResponse({\n+            const response1 = new ServiceFault({\n                 responseHeader: { serviceResult: statusCode }\n             });\n             return response1;"
        },
        {
          "filename": "packages/node-opcua-server/source/opcua_server.ts",
          "status": "modified",
          "additions": 22,
          "deletions": 23,
          "patch": "@@ -145,7 +145,8 @@ import {\n     BuildInfoOptions,\n     MonitoredItemCreateResult,\n     IssuedIdentityToken,\n-    BrowseResultOptions\n+    BrowseResultOptions,\n+    ServiceFault\n } from \"node-opcua-types\";\n import { DataType } from \"node-opcua-variant\";\n import { VariantArrayType } from \"node-opcua-variant\";\n@@ -184,7 +185,7 @@ const warningLog = make_warningLog(__filename);\n const default_maxConnectionsPerEndpoint = 10;\n \n function g_sendError(channel: ServerSecureChannelLayer, message: Message, ResponseClass: any, statusCode: StatusCode): void {\n-    const response = new ResponseClass({\n+    const response = new ServiceFault({\n         responseHeader: { serviceResult: statusCode }\n     });\n     return channel.send_response(\"MSG\", response, message);\n@@ -2233,7 +2234,7 @@ export class OPCUAServer extends OPCUABaseServer {\n \n         function sendResponse(response1: Response) {\n             try {\n-                assert(response1 instanceof ResponseClass);\n+                assert(response1 instanceof ResponseClass || response1 instanceof ServiceFault);\n                 if (message.session) {\n                     const counterName = ResponseClass.name.replace(\"Response\", \"\");\n                     message.session.incrementRequestTotalCounter(counterName);\n@@ -3071,7 +3072,7 @@ export class OPCUAServer extends OPCUABaseServer {\n             (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                 assert(session);\n                 assert(session.publishEngine); // server.publishEngine doesn't exists, OPCUAServer has probably shut down already\n-                session.publishEngine._on_PublishRequest(request, (request1: PublishRequest, response: PublishResponse) => {\n+                session.publishEngine._on_PublishRequest(request, (_request1, response) => {\n                     sendResponse(response);\n                 });\n             }\n@@ -3180,16 +3181,20 @@ export class OPCUAServer extends OPCUABaseServer {\n                     linksToAdd,\n                     linksToRemove\n                 );\n-                const response = new SetTriggeringResponse({\n-                    responseHeader: { serviceResult: statusCode },\n-\n-                    addResults,\n-                    removeResults,\n-                    addDiagnosticInfos: null,\n-                    removeDiagnosticInfos: null\n-                });\n+                if (statusCode !== StatusCodes.Good) {\n+                    const response = new ServiceFault({ responseHeader: { serviceResult: statusCode } });\n+                    sendResponse(response);\n+                } else {\n+                    const response = new SetTriggeringResponse({\n+                        responseHeader: { serviceResult: statusCode },\n \n-                sendResponse(response);\n+                        addResults,\n+                        removeResults,\n+                        addDiagnosticInfos: null,\n+                        removeDiagnosticInfos: null\n+                    });\n+                    sendResponse(response);\n+                }\n             }\n         );\n     }\n@@ -3390,11 +3395,8 @@ export class OPCUAServer extends OPCUABaseServer {\n             message,\n             channel,\n             (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n-                let response;\n-\n                 if (!request.nodesToRegister || request.nodesToRegister.length === 0) {\n-                    response = new RegisterNodesResponse({ responseHeader: { serviceResult: StatusCodes.BadNothingToDo } });\n-                    return sendResponse(response);\n+                    return sendError(StatusCodes.BadNothingToDo);\n                 }\n                 if (this.engine.serverCapabilities.operationLimits.maxNodesPerRegisterNodes > 0) {\n                     if (request.nodesToRegister.length > this.engine.serverCapabilities.operationLimits.maxNodesPerRegisterNodes) {\n@@ -3410,7 +3412,7 @@ export class OPCUAServer extends OPCUABaseServer {\n                 // NodeId from the request.\n                 const registeredNodeIds = request.nodesToRegister.map((nodeId) => session.registerNode(nodeId));\n \n-                response = new RegisterNodesResponse({\n+                const response = new RegisterNodesResponse({\n                     registeredNodeIds\n                 });\n                 sendResponse(response);\n@@ -3427,13 +3429,10 @@ export class OPCUAServer extends OPCUABaseServer {\n             message,\n             channel,\n             (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n-                let response;\n-\n                 request.nodesToUnregister = request.nodesToUnregister || [];\n \n                 if (!request.nodesToUnregister || request.nodesToUnregister.length === 0) {\n-                    response = new UnregisterNodesResponse({ responseHeader: { serviceResult: StatusCodes.BadNothingToDo } });\n-                    return sendResponse(response);\n+                    return sendError(StatusCodes.BadNothingToDo);\n                 }\n \n                 if (this.engine.serverCapabilities.operationLimits.maxNodesPerRegisterNodes > 0) {\n@@ -3446,7 +3445,7 @@ export class OPCUAServer extends OPCUABaseServer {\n \n                 request.nodesToUnregister.map((nodeId: NodeId) => session.unRegisterNode(nodeId));\n \n-                response = new UnregisterNodesResponse({});\n+                const response = new UnregisterNodesResponse({});\n                 sendResponse(response);\n             }\n         );"
        },
        {
          "filename": "packages/node-opcua-server/source/server_publish_engine.ts",
          "status": "modified",
          "additions": 24,
          "deletions": 19,
          "patch": "@@ -11,7 +11,7 @@ import { checkDebugFlag, make_debugLog } from \"node-opcua-debug\";\n import { ObjectRegistry } from \"node-opcua-object-registry\";\n import { StatusCode, StatusCodes } from \"node-opcua-status-code\";\n \n-import { PublishRequest, PublishResponse, SubscriptionAcknowledgement } from \"node-opcua-types\";\n+import { PublishRequest, PublishResponse, ServiceFault, SubscriptionAcknowledgement } from \"node-opcua-types\";\n import { Subscription } from \"./server_subscription\";\n import { SubscriptionState } from \"./server_subscription\";\n import { IServerSidePublishEngine, INotifMsg, IClosedOrTransferredSubscription } from \"./i_server_side_publish_engine\";\n@@ -36,7 +36,7 @@ interface PublishData {\n     request: PublishRequest;\n     serverTimeWhenReceived: number;\n     results: StatusCode[];\n-    callback: (request: PublishRequest, response: PublishResponse) => void;\n+    callback: (request: PublishRequest, response: PublishResponse | ServiceFault) => void;\n }\n \n function _assertValidPublishData(publishData: PublishData) {\n@@ -137,7 +137,7 @@ export class ServerSidePublishEngine extends EventEmitter implements IServerSide\n \n         const tmp = srcPublishEngine.detach_subscription(subscription);\n         destPublishEngine.add_subscription(tmp);\n-        \n+\n         subscription.resetLifeTimeCounter();\n         if (sendInitialValues) {\n             /*  A Boolean parameter with the following values:\n@@ -327,11 +327,12 @@ export class ServerSidePublishEngine extends EventEmitter implements IServerSide\n     public on_close_subscription(subscription: IClosedOrTransferredSubscription): void {\n         doDebug && debugLog(\"ServerSidePublishEngine#on_close_subscription\", subscription.id);\n         if (subscription.hasPendingNotifications) {\n-            doDebug && debugLog(\n-                \"ServerSidePublishEngine#on_close_subscription storing subscription\",\n-                subscription.id,\n-                \" to _closed_subscriptions because it has pending notification\"\n-            );\n+            doDebug &&\n+                debugLog(\n+                    \"ServerSidePublishEngine#on_close_subscription storing subscription\",\n+                    subscription.id,\n+                    \" to _closed_subscriptions because it has pending notification\"\n+                );\n             this._closed_subscriptions.push(subscription);\n         } else {\n             doDebug && debugLog(\"ServerSidePublishEngine#on_close_subscription disposing subscription\", subscription.id);\n@@ -402,7 +403,7 @@ export class ServerSidePublishEngine extends EventEmitter implements IServerSide\n      */\n     public _on_PublishRequest(\n         request: PublishRequest,\n-        callback?: (request1: PublishRequest, response: PublishResponse) => void\n+        callback?: (request1: PublishRequest, response: PublishResponse| ServiceFault) => void\n     ): void {\n         callback = callback || dummy_function;\n         assert(typeof callback === \"function\");\n@@ -483,9 +484,10 @@ export class ServerSidePublishEngine extends EventEmitter implements IServerSide\n                                 s.timeToKeepAlive +\n                                 \" m?=\" +\n                                 s.hasUncollectedMonitoredItemNotifications +\n-                                \" \" + \n+                                \" \" +\n                                 SubscriptionState[s.state] +\n-                                \" \" + s.messageSent + \n+                                \" \" +\n+                                s.messageSent +\n                                 \"]\"\n                         )\n                         .join(\" \\n\")\n@@ -508,7 +510,8 @@ export class ServerSidePublishEngine extends EventEmitter implements IServerSide\n             }\n             const starving_subscription = this._find_starving_subscription();\n             if (starving_subscription) {\n-                doDebug && debugLog(chalk.bgWhite.red(\"feeding most late subscription subscriptionId  = \"), starving_subscription.id);\n+                doDebug &&\n+                    debugLog(chalk.bgWhite.red(\"feeding most late subscription subscriptionId  = \"), starving_subscription.id);\n                 starving_subscription.process_subscription();\n             }\n         });\n@@ -537,10 +540,10 @@ export class ServerSidePublishEngine extends EventEmitter implements IServerSide\n \n     private _send_error_for_request(publishData: PublishData, statusCode: StatusCode): void {\n         _assertValidPublishData(publishData);\n-        const publishResponse = new PublishResponse({\n+        const response = new ServiceFault({\n             responseHeader: { serviceResult: statusCode }\n         });\n-        this._send_response_for_request(publishData, publishResponse);\n+        this._send_response_for_request(publishData, response);\n     }\n \n     private _cancelPendingPublishRequest(statusCode: StatusCode): void {\n@@ -629,7 +632,7 @@ export class ServerSidePublishEngine extends EventEmitter implements IServerSide\n         assert(this.pendingPublishRequestCount > 0);\n         assert(response.subscriptionId !== 0xffffff);\n         const publishData = this._publish_request_queue.shift()!;\n-        this._send_response_for_request(publishData, response);\n+        this._send_valid_response_for_request(publishData, response);\n     }\n \n     public _on_tick(): void {\n@@ -654,15 +657,17 @@ export class ServerSidePublishEngine extends EventEmitter implements IServerSide\n             this._send_error_for_request(publishData, StatusCodes.BadTimeout);\n         }\n     }\n-\n-    public _send_response_for_request(publishData: PublishData, response: PublishResponse): void {\n+    public _send_response_for_request(publishData: PublishData, response: PublishResponse | ServiceFault): void {\n+        response.responseHeader.requestHandle = publishData.request.requestHeader.requestHandle;\n+        publishData.callback(publishData.request, response);\n+    }\n+    public _send_valid_response_for_request(publishData: PublishData, response: PublishResponse): void {\n         if (doDebug) {\n             debugLog(\"_send_response_for_request \", response.toString());\n         }\n         _assertValidPublishData(publishData);\n         // xx assert(response.responseHeader.requestHandle !== 0,\"expecting a valid requestHandle\");\n         response.results = publishData.results;\n-        response.responseHeader.requestHandle = publishData.request.requestHeader.requestHandle;\n-        publishData.callback(publishData.request, response);\n+        this._send_response_for_request(publishData, response);\n     }\n }"
        },
        {
          "filename": "packages/node-opcua-server/test/test_server_engine_subscription.js",
          "status": "modified",
          "additions": 13,
          "deletions": 9,
          "patch": "@@ -6,6 +6,7 @@ const { MonitoringMode, PublishRequest } = require(\"node-opcua-service-subscript\n const { StatusCodes, StatusCode } = require(\"node-opcua-status-code\");\n const { TimestampsToReturn } = require(\"node-opcua-service-read\");\n const { MonitoredItemCreateRequest } = require(\"node-opcua-service-subscription\");\n+const { ServiceFault } = require(\"node-opcua-types\");\n \n const { get_mini_nodeset_filename } = require(\"node-opcua-address-space/testHelpers\");\n \n@@ -402,19 +403,22 @@ describe(\"ServerEngine Subscriptions service\", function () {\n             publishSpy.callCount.should.eql(4);\n \n             publishSpy.getCall(1).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n-            publishSpy.getCall(1).args[1].subscriptionId.should.eql(0xffffffff);\n-            publishSpy.getCall(1).args[1].notificationMessage.sequenceNumber.should.eql(0);\n-            publishSpy.getCall(1).args[1].notificationMessage.notificationData.length.should.eql(0);\n+            publishSpy.getCall(1).args[1].should.be.instanceOf(ServiceFault);\n+            // publishSpy.getCall(1).args[1].subscriptionId.should.eql(0xffffffff);\n+            // publishSpy.getCall(1).args[1].notificationMessage.sequenceNumber.should.eql(0);\n+            // publishSpy.getCall(1).args[1].notificationMessage.notificationData.length.should.eql(0);\n \n             publishSpy.getCall(2).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n-            publishSpy.getCall(2).args[1].subscriptionId.should.eql(0xffffffff);\n-            publishSpy.getCall(2).args[1].notificationMessage.sequenceNumber.should.eql(0);\n-            publishSpy.getCall(2).args[1].notificationMessage.notificationData.length.should.eql(0);\n+            publishSpy.getCall(2).args[1].should.be.instanceOf(ServiceFault);\n+            // publishSpy.getCall(2).args[1].subscriptionId.should.eql(0xffffffff);\n+            // publishSpy.getCall(2).args[1].notificationMessage.sequenceNumber.should.eql(0);\n+            // publishSpy.getCall(2).args[1].notificationMessage.notificationData.length.should.eql(0);\n \n             publishSpy.getCall(3).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n-            publishSpy.getCall(3).args[1].subscriptionId.should.eql(0xffffffff);\n-            publishSpy.getCall(3).args[1].notificationMessage.sequenceNumber.should.eql(0);\n-            publishSpy.getCall(3).args[1].notificationMessage.notificationData.length.should.eql(0);\n+            publishSpy.getCall(3).args[1].should.be.instanceOf(ServiceFault);\n+            // publishSpy.getCall(3).args[1].subscriptionId.should.eql(0xffffffff);\n+            // publishSpy.getCall(3).args[1].notificationMessage.sequenceNumber.should.eql(0);\n+            // publishSpy.getCall(3).args[1].notificationMessage.notificationData.length.should.eql(0);\n \n             await engine.closeSession(session.authenticationToken, true, \"CloseSession\");\n         });"
        },
        {
          "filename": "packages/node-opcua-server/test/test_server_publish_engine.ts",
          "status": "modified",
          "additions": 6,
          "deletions": 8,
          "patch": "@@ -185,7 +185,7 @@ describe(\"Testing the server publish engine\", function (this: any) {\n         serverSidePublishEngine.dispose();\n     });\n \n-    it(\"ZDZ-5 a server should return BadNoSubscription as a response for a publish Request if there is no subscription available for this session. \", () => {\n+    it(\"ZDZ-5 a server should return ServiceFault(BadNoSubscription) as a response for a publish Request if there is no subscription available for this session. \", () => {\n         // create a server - server has no subscription\n         const publish_server = new ServerSidePublishEngine();\n \n@@ -199,7 +199,7 @@ describe(\"Testing the server publish engine\", function (this: any) {\n         flushPending();\n \n         send_response_for_request_spy.callCount.should.equal(1);\n-        send_response_for_request_spy.getCall(0).args[1].schema.name.should.equal(\"PublishResponse\");\n+        send_response_for_request_spy.getCall(0).args[1].schema.name.should.equal(\"ServiceFault\");\n         send_response_for_request_spy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n \n         publish_server.shutdown();\n@@ -309,25 +309,23 @@ describe(\"Testing the server publish engine\", function (this: any) {\n         // xx console.log(send_response_for_request_spy.getCall(0).args[1].responseHeader.toString());\n         // xx console.log(send_response_for_request_spy.getCall(1).args[1].responseHeader.toString());\n \n-        send_response_for_request_spy.getCall(1).args[1].schema.name.should.equal(\"PublishResponse\");\n+        send_response_for_request_spy.getCall(1).args[1].schema.name.should.equal(\"ServiceFault\");\n         send_response_for_request_spy\n             .getCall(1)\n             .args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadTooManyPublishRequests);\n         send_response_for_request_spy.getCall(1).args[1].responseHeader.requestHandle.should.eql(2);\n-        send_response_for_request_spy.getCall(1).args[1].results!.should.eql([]);\n-\n+       \n         publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 8 } }));\n         flushPending();\n \n         send_response_for_request_spy.callCount.should.be.equal(3);\n         // xx console.log(send_response_for_request_spy.getCall(2).args[1].responseHeader.toString());\n-        send_response_for_request_spy.getCall(2).args[1].schema.name.should.equal(\"PublishResponse\");\n+        send_response_for_request_spy.getCall(2).args[1].schema.name.should.equal(\"ServiceFault\");\n         send_response_for_request_spy\n             .getCall(2)\n             .args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadTooManyPublishRequests);\n         send_response_for_request_spy.getCall(2).args[1].responseHeader.requestHandle.should.eql(3);\n-        send_response_for_request_spy.getCall(2).args[1].results!.should.eql([]);\n-\n+    \n         subscription.terminate();\n         subscription.dispose();\n         publish_server.shutdown();"
        },
        {
          "filename": "packages/parallel_test.js",
          "status": "modified",
          "additions": 15,
          "deletions": 8,
          "patch": "@@ -302,6 +302,10 @@ if (isMainThread) {\n                 if (key.name === \"l\") {\n                     dumpRunningTests();\n                 }\n+                if (key.name === \"i\") {\n+                    dumpRunningTests();\n+                    dumpRunningTestsLogs();\n+                }\n             });\n         }\n \n@@ -315,14 +319,7 @@ if (isMainThread) {\n         const infoTimer = setInterval(() => {\n             console.log(\"----------------------------------------------- RUNNING TESTS \");\n             dumpRunningTests();\n-            const runningTests = [...runningPages].map((i) => testFiles[i]);\n-            for (let file of runningTests) {\n-                const outputs = outputFor[file];\n-                if (outputs && outputs.length) {\n-                    console.log(chalk.green(\"log for\", file));\n-                    console.log(outputs.join(\"\\n\"));\n-                }\n-            }\n+            dumpRunningTestsLogs();\n         }, testWatchDogTimeout);\n \n         fileMax = testFiles.length;\n@@ -342,3 +339,13 @@ if (isMainThread) {\n     const { workerThread } = require(\"./parallel_test_worker\");\n     workerThread();\n }\n+function dumpRunningTestsLogs() {\n+    const runningTests = [...runningPages].map((i) => testFiles[i]);\n+    for (let file of runningTests) {\n+        const outputs = outputFor[file];\n+        if (outputs && outputs.length) {\n+            console.log(chalk.green(\"log for\", file));\n+            console.log(outputs.join(\"\\n\"));\n+        }\n+    }\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 12,
        "unique_directories": 8,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "0042f95d7be6318ed22bc3dcfdbd4ea3084bd08a",
            "date": "2025-01-05T15:05:12Z",
            "author_login": "erossignon"
          },
          {
            "sha": "8354bc4a6cac073bacba405aa70797f16c56771a",
            "date": "2025-01-03T14:32:17Z",
            "author_login": "erossignon"
          },
          {
            "sha": "069823c62842ca68428b8f96d5df7e41d437ddb9",
            "date": "2025-01-03T13:56:05Z",
            "author_login": "erossignon"
          },
          {
            "sha": "2d128442b2dc19d4962259992a85c6ad998125ce",
            "date": "2025-01-03T13:54:51Z",
            "author_login": "erossignon"
          },
          {
            "sha": "f966ee4ce83c1012795fbf030d261df091c3c189",
            "date": "2025-01-03T13:53:29Z",
            "author_login": "erossignon"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-770",
    "description": "The package node-opcua before 2.74.0 are vulnerable to Denial of Service (DoS) by sending a specifically crafted OPC UA message with a special OPC UA NodeID, when the requested memory allocation exceeds the v8\u2019s memory limit.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-08-23T05:15:07.873",
    "last_modified": "2024-11-21T06:51:50.897",
    "fix_date": "2022-08-12T22:06:23Z"
  },
  "references": [
    {
      "url": "https://github.com/node-opcua/node-opcua/commit/7b5044b3f5866fbedc3efabd05e407352c07bd2f",
      "source": "report@snyk.io",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/node-opcua/node-opcua/pull/1182",
      "source": "report@snyk.io",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.snyk.io/vuln/SNYK-JS-NODEOPCUA-2988724",
      "source": "report@snyk.io",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/node-opcua/node-opcua/commit/7b5044b3f5866fbedc3efabd05e407352c07bd2f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/node-opcua/node-opcua/pull/1182",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.snyk.io/vuln/SNYK-JS-NODEOPCUA-2988724",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:14.277361",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "node-opcua",
    "owner": "node-opcua",
    "created_at": "2014-01-22T21:48:45Z",
    "updated_at": "2025-01-11T16:49:30Z",
    "pushed_at": "2025-01-05T16:27:24Z",
    "size": 44208,
    "stars": 1505,
    "forks": 485,
    "open_issues": 39,
    "watchers": 1505,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "TypeScript": 10516428,
      "JavaScript": 1930816,
      "XSLT": 5379,
      "Shell": 4981,
      "Batchfile": 2277,
      "Makefile": 1377,
      "Dockerfile": 462
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:31:52.054193"
  }
}