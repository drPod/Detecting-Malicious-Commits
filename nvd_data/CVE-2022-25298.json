{
  "cve_id": "CVE-2022-25298",
  "github_data": {
    "repository": "sprinfall/webcc",
    "fix_commit": "55a45fd5039061d5cc62e9f1b9d1f7e97a15143f",
    "related_commits": [
      "55a45fd5039061d5cc62e9f1b9d1f7e97a15143f",
      "55a45fd5039061d5cc62e9f1b9d1f7e97a15143f"
    ],
    "patch_url": "https://github.com/sprinfall/webcc/commit/55a45fd5039061d5cc62e9f1b9d1f7e97a15143f.patch",
    "fix_commit_details": {
      "sha": "55a45fd5039061d5cc62e9f1b9d1f7e97a15143f",
      "commit_date": "2022-02-15T14:58:33Z",
      "author": {
        "login": "sprinfall",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix static file serving security issue; fix url path encoding issue",
        "length": 67,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 365,
        "additions": 227,
        "deletions": 138
      },
      "files": [
        {
          "filename": "examples/CMakeLists.txt",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -37,7 +37,7 @@ if(WEBCC_ENABLE_SSL)\n endif()\n \n if(WIN32)\n-    add_executable(url_unicode url_unicode.cc encoding.cc encoding.h)\n+    add_executable(url_unicode url_unicode.cc)\n     target_link_libraries(url_unicode ${EXAMPLE_LIBS})\n     set_target_properties(url_unicode PROPERTIES FOLDER \"Examples\")\n endif()"
        },
        {
          "filename": "examples/encoding.cc",
          "status": "removed",
          "additions": 0,
          "deletions": 60,
          "patch": "@@ -1,60 +0,0 @@\n-#include \"encoding.h\"\n-\n-#include <Windows.h>\n-\n-namespace {\n-\n-// Wrapper for Windows API MultiByteToWideChar.\n-std::wstring MB2WC(const std::string& input, unsigned int code_page) {\n-  if (input.empty()) {\n-    return L\"\";\n-  }\n-\n-  int length = ::MultiByteToWideChar(code_page, 0, &input[0],\n-                                     static_cast<int>(input.size()),\n-                                     NULL, 0);\n-\n-  std::wstring output(length, '\\0');\n-\n-  ::MultiByteToWideChar(code_page, 0, &input[0], static_cast<int>(input.size()),\n-                        &output[0], static_cast<int>(output.size()));\n-\n-  return output;\n-}\n-\n-// Wrapper for Windows API WideCharToMultiByte.\n-std::string WC2MB(const std::wstring& input, unsigned int code_page) {\n-  if (input.empty()) {\n-    return \"\";\n-  }\n-\n-  // There do have other code pages which require the flags to be 0, e.g.,\n-  // 50220, 50211, and so on. But they are not included in our charset\n-  // dictionary. So, only consider 65001 (UTF-8) and 54936 (GB18030).\n-  DWORD flags = 0;\n-  if (code_page != 65001 && code_page != 54936) {\n-    flags = WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK | WC_DEFAULTCHAR;\n-  }\n-\n-  int length = ::WideCharToMultiByte(code_page, flags, &input[0],\n-                                     static_cast<int>(input.size()), NULL, 0,\n-                                     NULL, NULL);\n-\n-  std::string output(length, '\\0');\n-\n-  ::WideCharToMultiByte(code_page, flags, &input[0],\n-                        static_cast<int>(input.size()), &output[0],\n-                        static_cast<int>(output.size()), NULL, NULL);\n-\n-  return output;\n-}\n-\n-}  // namespace\n-\n-std::string Utf16ToUtf8(const std::wstring& utf16_string) {\n-  return WC2MB(utf16_string, CP_UTF8);\n-}\n-\n-std::wstring Utf8ToUtf16(const std::string& utf8_string) {\n-  return MB2WC(utf8_string, CP_UTF8);\n-}"
        },
        {
          "filename": "examples/encoding.h",
          "status": "removed",
          "additions": 0,
          "deletions": 12,
          "patch": "@@ -1,12 +0,0 @@\n-#ifndef ENCODING_H_\n-#define ENCODING_H_\n-\n-#include <string>\n-\n-// Convert UTF16 to UTF8.\n-std::string Utf16ToUtf8(const std::wstring& utf16_string);\n-\n-// Convert UTF8 to UTF16.\n-std::wstring Utf8ToUtf16(const std::string& utf8_string);\n-\n-#endif  // ENCODING_H_"
        },
        {
          "filename": "examples/url_unicode.cc",
          "status": "modified",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "webcc/body.cc",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -202,7 +202,7 @@ Payload FileBody::NextPayload(bool /*free_previous*/) {\n }\n \n void FileBody::Dump(std::ostream& os, const std::string& prefix) const {\n-  os << prefix << \"<file: \" << path_.string() << \">\" << std::endl;\n+  os << prefix << \"<file: \" << path_.u8string() << \">\" << std::endl;\n }\n \n bool FileBody::Move(const fs::path& new_path) {"
        },
        {
          "filename": "webcc/fs.h",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -27,6 +27,8 @@ using std::filesystem::path;\n using std::filesystem::filesystem_error;\n \n // functions\n+using std::filesystem::absolute;\n+using std::filesystem::canonical;\n using std::filesystem::rename;\n using std::filesystem::remove;\n using std::filesystem::exists;\n@@ -47,6 +49,8 @@ using boost::filesystem::path;\n using boost::filesystem::filesystem_error;\n \n // functions\n+using boost::filesystem::absolute;\n+using boost::filesystem::canonical;\n using boost::filesystem::rename;\n using boost::filesystem::remove;\n using boost::filesystem::exists;"
        },
        {
          "filename": "webcc/request_parser.cc",
          "status": "modified",
          "additions": 4,
          "deletions": 5,
          "patch": "@@ -24,14 +24,13 @@ void RequestParser::Init(Request* request, ViewMatcher view_matcher) {\n }\n \n bool RequestParser::OnHeadersEnd() {\n-  bool matched = view_matcher_(request_->method(), request_->url().path(),\n-                               &stream_);\n-\n+  // Decode the URL path before match.\n+  std::string url_path = Url::DecodeUnsafe(request_->url().path());\n+  bool matched = view_matcher_(request_->method(), url_path, &stream_);\n   if (!matched) {\n     LOG_WARN(\"No view matches the request: %s %s\", request_->method().c_str(),\n-             request_->url().path().c_str());\n+             url_path.c_str());\n   }\n-\n   return matched;\n }\n "
        },
        {
          "filename": "webcc/request_parser.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -8,6 +8,7 @@\n \n namespace webcc {\n \n+// Parameters: http_method, url_path, [out]stream\n using ViewMatcher =\n     std::function<bool(const std::string&, const std::string&, bool*)>;\n "
        },
        {
          "filename": "webcc/router.cc",
          "status": "modified",
          "additions": 3,
          "deletions": 4,
          "patch": "@@ -67,7 +67,7 @@ ViewPtr Router::FindView(const std::string& method, const std::string& url,\n   return ViewPtr();\n }\n \n-bool Router::MatchView(const std::string& method, const std::string& url,\n+bool Router::MatchView(const std::string& method, const std::string& url_path,\n                        bool* stream) {\n   assert(stream != nullptr);\n   *stream = false;\n@@ -80,13 +80,12 @@ bool Router::MatchView(const std::string& method, const std::string& url,\n \n     if (route.url.empty()) {\n       std::smatch match;\n-\n-      if (std::regex_match(url, match, route.url_regex)) {\n+      if (std::regex_match(url_path, match, route.url_regex)) {\n         *stream = route.view->Stream(method);\n         return true;\n       }\n     } else {\n-      if (boost::iequals(route.url, url)) {\n+      if (boost::iequals(route.url, url_path)) {\n         *stream = route.view->Stream(method);\n         return true;\n       }"
        },
        {
          "filename": "webcc/router.h",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -28,10 +28,10 @@ class Router {\n   ViewPtr FindView(const std::string& method, const std::string& url,\n                    UrlArgs* args);\n \n-  // Match the view by HTTP method and URL (path).\n+  // Match the view by HTTP method and URL path.\n   // Return if a view is matched or not.\n   // If the view asks for data streaming, |stream| will be set to true.\n-  bool MatchView(const std::string& method, const std::string& url,\n+  bool MatchView(const std::string& method, const std::string& url_path,\n                  bool* stream);\n \n private:"
        },
        {
          "filename": "webcc/server.cc",
          "status": "modified",
          "additions": 32,
          "deletions": 4,
          "patch": "@@ -4,6 +4,8 @@\n #include <fstream>\n #include <utility>\n \n+#include \"boost/algorithm/string/trim.hpp\"\n+\n #include \"webcc/body.h\"\n #include \"webcc/logger.h\"\n #include \"webcc/request.h\"\n@@ -32,6 +34,7 @@ Server::Server(boost::asio::ip::tcp protocol, std::uint16_t port,\n       doc_root_(doc_root),\n       acceptor_(io_context_),\n       signals_(io_context_) {\n+  CheckDocRoot();\n   AddSignals();\n }\n \n@@ -105,6 +108,27 @@ bool Server::IsRunning() const {\n   return running_ && !io_context_.stopped();\n }\n \n+void Server::CheckDocRoot() {\n+  try {\n+    if (!fs::exists(doc_root_) || !fs::is_directory(doc_root_)) {\n+      LOG_ERRO(\"Doc root is not an existing directory!\");\n+      return;\n+    }\n+\n+    if (doc_root_.is_relative()) {\n+      doc_root_ = fs::absolute(doc_root_);\n+    }\n+\n+    doc_root_ = fs::canonical(doc_root_);\n+\n+  } catch (fs::filesystem_error& e) {\n+    LOG_ERRO(\"Doc root error: %s\", e.what());\n+    doc_root_.clear();\n+  }\n+\n+  LOG_INFO(\"Doc root: %s\", doc_root_.u8string().c_str());\n+}\n+\n void Server::AddSignals() {\n   signals_.add(SIGINT);  // Ctrl+C\n   signals_.add(SIGTERM);\n@@ -314,14 +338,16 @@ void Server::Handle(ConnectionPtr connection) {\n }\n \n bool Server::MatchViewOrStatic(const std::string& method,\n-                               const std::string& url, bool* stream) {\n-  if (Router::MatchView(method, url, stream)) {\n+                               const std::string& url_path, bool* stream) {\n+  if (Router::MatchView(method, url_path, stream)) {\n     return true;\n   }\n \n   // Try to match a static file.\n   if (method == methods::kGet && !doc_root_.empty()) {\n-    fs::path path = doc_root_ / url;\n+    fs::path sub_path = utility::TranslatePath(url_path);\n+    //LOG_INFO(\"Translated URL path: %s\", sub_path.u8string().c_str());\n+    fs::path path = doc_root_ / sub_path;\n \n     fs::error_code ec;\n     if (!fs::is_directory(path, ec) && fs::exists(path, ec)) {\n@@ -340,7 +366,9 @@ ResponsePtr Server::ServeStatic(RequestPtr request) {\n     return {};\n   }\n \n-  fs::path path = doc_root_ / request->url().path();\n+  std::string url_path = Url::DecodeUnsafe(request->url().path());\n+  fs::path sub_path = utility::TranslatePath(url_path);\n+  fs::path path = doc_root_ / sub_path;\n \n   try {\n     // NOTE: FileBody might throw Error::kFileError."
        },
        {
          "filename": "webcc/server.h",
          "status": "modified",
          "additions": 9,
          "deletions": 2,
          "patch": "@@ -61,6 +61,10 @@ class Server : public Router {\n   bool IsRunning() const;\n \n private:\n+  // Check if doc root is valid.\n+  // Absolute it if necessary.\n+  void CheckDocRoot();\n+\n   // Register signals which indicate when the server should exit.\n   void AddSignals();\n \n@@ -90,10 +94,13 @@ class Server : public Router {\n   // request comes, this connection will be put back to the queue again.\n   virtual void Handle(ConnectionPtr connection);\n \n-  // Match the view by HTTP method and URL (path).\n+  // Match the view by HTTP method and URL path.\n   // Return if a view or static file is matched or not.\n+  // The |url_path| has already been decoded.\n+  // The |url_path| is UTF8 encoded by itself, and this is taken into account\n+  // when match the static files.\n   // If the view asks for data streaming, |stream| will be set to true.\n-  bool MatchViewOrStatic(const std::string& method, const std::string& url,\n+  bool MatchViewOrStatic(const std::string& method, const std::string& url_path,\n                          bool* stream);\n \n   // Serve static files from the doc root."
        },
        {
          "filename": "webcc/string.cc",
          "status": "modified",
          "additions": 61,
          "deletions": 0,
          "patch": "@@ -1,11 +1,72 @@\n #include \"webcc/string.h\"\n \n+#if (defined(_WIN32) || defined(_WIN64))\n+#include <Windows.h>\n+#endif\n+\n #include <random>\n \n #include \"boost/algorithm/string/trim.hpp\"\n \n namespace webcc {\n \n+#if (defined(_WIN32) || defined(_WIN64))\n+\n+// Wrapper for Windows API MultiByteToWideChar.\n+static std::wstring MB2WC(const std::string& input, unsigned int code_page) {\n+  if (input.empty()) {\n+    return L\"\";\n+  }\n+\n+  int length = ::MultiByteToWideChar(code_page, 0, &input[0],\n+                                     static_cast<int>(input.size()),\n+                                     NULL, 0);\n+\n+  std::wstring output(length, '\\0');\n+\n+  ::MultiByteToWideChar(code_page, 0, &input[0], static_cast<int>(input.size()),\n+                        &output[0], static_cast<int>(output.size()));\n+\n+  return output;\n+}\n+\n+// Wrapper for Windows API WideCharToMultiByte.\n+static std::string WC2MB(const std::wstring& input, unsigned int code_page) {\n+  if (input.empty()) {\n+    return \"\";\n+  }\n+\n+  // There do have other code pages which require the flags to be 0, e.g.,\n+  // 50220, 50211, and so on. But they are not included in our charset\n+  // dictionary. So, only consider 65001 (UTF-8) and 54936 (GB18030).\n+  DWORD flags = 0;\n+  if (code_page != 65001 && code_page != 54936) {\n+    flags = WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK | WC_DEFAULTCHAR;\n+  }\n+\n+  int length = ::WideCharToMultiByte(code_page, flags, &input[0],\n+                                     static_cast<int>(input.size()), NULL, 0,\n+                                     NULL, NULL);\n+\n+  std::string output(length, '\\0');\n+\n+  ::WideCharToMultiByte(code_page, flags, &input[0],\n+                        static_cast<int>(input.size()), &output[0],\n+                        static_cast<int>(output.size()), NULL, NULL);\n+\n+  return output;\n+}\n+\n+std::string Utf16To8(const std::wstring& utf16_string) {\n+  return WC2MB(utf16_string, CP_UTF8);\n+}\n+\n+std::wstring Utf8To16(const std::string& utf8_string) {\n+  return MB2WC(utf8_string, CP_UTF8);\n+}\n+\n+#endif  // defined(_WIN32) || defined(_WIN64)\n+\n // Ref: https://stackoverflow.com/a/24586587\n std::string RandomString(std::size_t length) {\n   static const char chrs[] ="
        },
        {
          "filename": "webcc/string.h",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -8,6 +8,11 @@\n \n namespace webcc {\n \n+#if (defined(_WIN32) || defined(_WIN64))\n+std::string Utf16To8(const std::wstring& utf16_string);\n+std::wstring Utf8To16(const std::string& utf8_string);\n+#endif\n+\n // Get a randomly generated string with the given length.\n std::string RandomString(std::size_t length);\n "
        },
        {
          "filename": "webcc/url.cc",
          "status": "modified",
          "additions": 46,
          "deletions": 47,
          "patch": "@@ -29,52 +29,6 @@ bool HexToDecimal(char hex, int* decimal) {\n   return true;\n }\n \n-bool Decode(string_view encoded, std::string* raw) {\n-  for (auto iter = encoded.begin(); iter != encoded.end(); ++iter) {\n-    if (*iter == '%') {\n-      if (++iter == encoded.end()) {\n-        // Invalid URI string, two hexadecimal digits must follow '%'.\n-        return false;\n-      }\n-\n-      int h_decimal = 0;\n-      if (!HexToDecimal(*iter, &h_decimal)) {\n-        return false;\n-      }\n-\n-      if (++iter == encoded.end()) {\n-        // Invalid URI string, two hexadecimal digits must follow '%'.\n-        return false;\n-      }\n-\n-      int l_decimal = 0;\n-      if (!HexToDecimal(*iter, &l_decimal)) {\n-        return false;\n-      }\n-\n-      raw->push_back(static_cast<char>((h_decimal << 4) + l_decimal));\n-\n-    } else if (*iter > 127 || *iter < 0) {\n-      // Invalid encoded URI string, must be entirely ASCII.\n-      return false;\n-    } else {\n-      raw->push_back(*iter);\n-    }\n-  }\n-\n-  return true;\n-}\n-\n-// Unsafe decode.\n-// Return the original string on failure.\n-std::string DecodeUnsafe(string_view encoded) {\n-  std::string raw;\n-  if (Decode(encoded, &raw)) {\n-    return raw;\n-  }\n-  return ToString(encoded);\n-}\n-\n // Encode all characters which should be encoded.\n std::string EncodeImpl(string_view raw,  // UTF8\n                        std::function<bool(int)> should_encode) {\n@@ -195,6 +149,50 @@ std::string Url::EncodeFull(string_view utf8_str) {\n   });\n }\n \n+bool Url::Decode(string_view encoded, std::string* raw) {\n+  for (auto iter = encoded.begin(); iter != encoded.end(); ++iter) {\n+    if (*iter == '%') {\n+      if (++iter == encoded.end()) {\n+        // Invalid URI string, two hexadecimal digits must follow '%'.\n+        return false;\n+      }\n+\n+      int h_decimal = 0;\n+      if (!HexToDecimal(*iter, &h_decimal)) {\n+        return false;\n+      }\n+\n+      if (++iter == encoded.end()) {\n+        // Invalid URI string, two hexadecimal digits must follow '%'.\n+        return false;\n+      }\n+\n+      int l_decimal = 0;\n+      if (!HexToDecimal(*iter, &l_decimal)) {\n+        return false;\n+      }\n+\n+      raw->push_back(static_cast<char>((h_decimal << 4) + l_decimal));\n+\n+    } else if (*iter > 127 || *iter < 0) {\n+      // Invalid encoded URI string, must be entirely ASCII.\n+      return false;\n+    } else {\n+      raw->push_back(*iter);\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+std::string Url::DecodeUnsafe(string_view encoded) {\n+  std::string raw;\n+  if (Decode(encoded, &raw)) {\n+    return raw;\n+  }\n+  return ToString(encoded);\n+}\n+\n // -----------------------------------------------------------------------------\n \n Url::Url(string_view str, bool encode) {\n@@ -318,7 +316,8 @@ UrlQuery::UrlQuery(const std::string& encoded_str) {\n       string_view key;\n       string_view value;\n       if (SplitKV(kv, '=', false, &key, &value)) {\n-        parameters_.push_back({ DecodeUnsafe(key), DecodeUnsafe(value) });\n+        parameters_.push_back(\n+            { Url::DecodeUnsafe(key), Url::DecodeUnsafe(value) });\n       }\n     }\n   }"
        },
        {
          "filename": "webcc/url.h",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -22,6 +22,12 @@ class Url {\n   static std::string EncodeQuery(string_view utf8_str);\n   static std::string EncodeFull(string_view utf8_str);\n \n+  static bool Decode(string_view encoded, std::string* raw);\n+\n+  // Unsafe decode.\n+  // Return the original string on failure.\n+  static std::string DecodeUnsafe(string_view encoded);\n+\n public:\n   Url() = default;\n "
        },
        {
          "filename": "webcc/utility.cc",
          "status": "modified",
          "additions": 39,
          "deletions": 0,
          "patch": "@@ -7,6 +7,8 @@\n #include <iostream>\n #include <sstream>\n \n+#include \"boost/algorithm/string.hpp\"\n+\n #include \"webcc/string.h\"\n #include \"webcc/version.h\"\n \n@@ -91,5 +93,42 @@ std::string EndpointToString(const tcp::endpoint& endpoint) {\n   return ss.str();\n }\n \n+fs::path TranslatePath(const std::string& utf8_url_path) {\n+#if (defined(_WIN32) || defined(_WIN64))\n+  std::wstring url_path = Utf8To16(utf8_url_path);\n+  std::vector<std::wstring> words;\n+  boost::split(words, url_path, boost::is_any_of(L\"/\"),\n+               boost::token_compress_on);\n+#else\n+  std::vector<std::string> words;\n+  boost::split(words, utf8_url_path, boost::is_any_of(\"/\"),\n+               boost::token_compress_on);\n+#endif  // defined(_WIN32) || defined(_WIN64)\n+\n+  fs::path path;\n+  for (auto& word : words) {\n+    // Ignore . and ..\n+#if (defined(_WIN32) || defined(_WIN64))\n+    if (word == L\".\" || word == L\"..\") {\n+#else\n+    if (word == \".\" || word == \"..\") {\n+#endif\n+      continue;\n+    }\n+\n+    fs::path p{ word };\n+\n+    // Ignore C:\\\\, C:, path\\\\sub, ...\n+    // parent_path() is similar to Python os.path.dirname().\n+    if (!p.parent_path().empty()) {\n+      continue;\n+    }\n+\n+    path /= p;\n+  }\n+\n+  return path;\n+}\n+\n }  // namespace utility\n }  // namespace webcc"
        },
        {
          "filename": "webcc/utility.h",
          "status": "modified",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -39,6 +39,19 @@ void PrintEndpoint(std::ostream& ostream,\n // TCP endpoint to string.\n std::string EndpointToString(const boost::asio::ip::tcp::endpoint& endpoint);\n \n+// Translate a /-separated URL path to the local (relative) path.\n+// Examples:\n+//   (Non-Windows)\n+//   \"/path/to/file\" -> \"path/to/file\"\n+//   \"/path/./to/../file\" -> \"path/to/file\" (. and .. are ignored)\n+//   \"/path//to//file\" -> \"path/to/file\"\n+//   (Windows)\n+//   \"/path/to/file\" -> \"path\\to\\file\"\n+//   \"/path\\\\sub/to/file\" -> \"to\\file\" (path\\\\sub is ignored)\n+//   \"/C:\\\\test/path\" -> \"path\" (C:\\\\test is ignored)\n+// Reference: Python http/server.py translate_path()\n+fs::path TranslatePath(const std::string& utf8_url_path);\n+\n }  // namespace utility\n }  // namespace webcc\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8c7d2e9a1b081aaa65f03d825fbf6c00b551f652",
            "date": "2023-12-11T14:04:38Z",
            "author_login": "sprinfall"
          },
          {
            "sha": "dee032102d66f9b104252d5afc89031422f5b37f",
            "date": "2023-12-08T14:32:26Z",
            "author_login": "sprinfall"
          },
          {
            "sha": "82075a264469379a52d48b6459f38a7427452353",
            "date": "2023-12-08T13:45:23Z",
            "author_login": "sprinfall"
          },
          {
            "sha": "166eafa629fb3a14dc9acad423fe393a826e451f",
            "date": "2023-12-05T14:56:52Z",
            "author_login": "sprinfall"
          },
          {
            "sha": "0ed300509d33f03b2428a769852d06465006233b",
            "date": "2023-12-04T15:43:13Z",
            "author_login": "sprinfall"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-22",
    "description": "This affects the package sprinfall/webcc before 0.3.0. It is possible to traverse directories to fetch arbitrary files from the server.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-02-18T13:15:08.320",
    "last_modified": "2024-11-21T06:51:57.073",
    "fix_date": "2022-02-15T14:58:33Z"
  },
  "references": [
    {
      "url": "https://github.com/sprinfall/webcc/commit/55a45fd5039061d5cc62e9f1b9d1f7e97a15143f",
      "source": "report@snyk.io",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://snyk.io/vuln/SNYK-UNMANAGED-SPRINFALLWEBCC-2404182",
      "source": "report@snyk.io",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sprinfall/webcc/commit/55a45fd5039061d5cc62e9f1b9d1f7e97a15143f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://snyk.io/vuln/SNYK-UNMANAGED-SPRINFALLWEBCC-2404182",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:59.728762",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "webcc",
    "owner": "sprinfall",
    "created_at": "2017-05-26T08:43:48Z",
    "updated_at": "2025-01-02T11:43:17Z",
    "pushed_at": "2024-06-04T13:22:52Z",
    "size": 7861,
    "stars": 275,
    "forks": 62,
    "open_issues": 11,
    "watchers": 275,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 239774,
      "CMake": 8432,
      "C": 110,
      "HTML": 13
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-3.0"
    },
    "collected_at": "2025-01-14T14:16:35.648575"
  }
}