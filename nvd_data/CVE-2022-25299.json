{
  "cve_id": "CVE-2022-25299",
  "github_data": {
    "repository": "cesanta/mongoose",
    "fix_commit": "c65c8fdaaa257e0487ab0aaae9e8f6b439335945",
    "related_commits": [
      "c65c8fdaaa257e0487ab0aaae9e8f6b439335945",
      "c65c8fdaaa257e0487ab0aaae9e8f6b439335945"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "c65c8fdaaa257e0487ab0aaae9e8f6b439335945",
      "commit_date": "2022-01-17T12:08:23Z",
      "author": {
        "login": "cpq",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Protect against the directory traversal in mg_upload()",
        "length": 54,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 130,
        "additions": 72,
        "deletions": 58
      },
      "files": [
        {
          "filename": "Makefile",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -59,7 +59,7 @@ fuzz: fuzzer\n \t$(RUN) ./fuzzer\n \n # make CC=/usr/local/opt/llvm\\@8/bin/clang ASAN_OPTIONS=detect_leaks=1\n-test: CFLAGS += -DMG_ENABLE_IPV6=$(IPV6) -fsanitize=address#,undefined\n+test: CFLAGS += -DMG_ENABLE_IPV6=$(IPV6) -fsanitize=address,undefined\n test: mongoose.h  Makefile $(SRCS)\n \t$(CC) $(SRCS) $(CFLAGS) -coverage $(LDFLAGS) -g -o unit_test\n \tASAN_OPTIONS=$(ASAN_OPTIONS) $(RUN) ./unit_test"
        },
        {
          "filename": "mongoose.c",
          "status": "modified",
          "additions": 28,
          "deletions": 28,
          "patch": "@@ -1142,34 +1142,6 @@ char *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {\n   return buf;\n }\n \n-#if MG_ENABLE_FILE\n-int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n-                   const char *dir) {\n-  char offset[40] = \"\", name[200] = \"\", path[256];\n-  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n-  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n-  if (name[0] == '\\0') {\n-    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n-    return -1;\n-  } else {\n-    FILE *fp;\n-    size_t oft = strtoul(offset, NULL, 0);\n-    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n-    LOG(LL_DEBUG,\n-        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n-    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n-      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n-      return -2;\n-    } else {\n-      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n-      fclose(fp);\n-      mg_http_reply(c, 200, \"\", \"\");\n-      return (int) hm->body.len;\n-    }\n-  }\n-}\n-#endif\n-\n static void static_cb(struct mg_connection *c, int ev, void *ev_data,\n                       void *fn_data) {\n   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {\n@@ -1680,6 +1652,34 @@ void mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm) {\n   c->recv.len -= ch.len;\n }\n \n+#if MG_ENABLE_FILE\n+int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n+                   const char *dir) {\n+  char offset[40] = \"\", name[200] = \"\", path[256];\n+  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n+  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n+  if (name[0] == '\\0') {\n+    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n+    return -1;\n+  } else {\n+    FILE *fp;\n+    long oft = strtol(offset, NULL, 0);\n+    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n+    remove_double_dots(path);\n+    LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));\n+    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n+      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);\n+      return -2;\n+    } else {\n+      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n+      fclose(fp);\n+      mg_http_reply(c, 200, \"\", \"\");\n+      return (int) hm->body.len;\n+    }\n+  }\n+}\n+#endif\n+\n static void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n   if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {\n     struct mg_http_message hm;"
        },
        {
          "filename": "src/http.c",
          "status": "modified",
          "additions": 28,
          "deletions": 28,
          "patch": "@@ -378,34 +378,6 @@ char *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {\n   return buf;\n }\n \n-#if MG_ENABLE_FILE\n-int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n-                   const char *dir) {\n-  char offset[40] = \"\", name[200] = \"\", path[256];\n-  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n-  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n-  if (name[0] == '\\0') {\n-    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n-    return -1;\n-  } else {\n-    FILE *fp;\n-    size_t oft = strtoul(offset, NULL, 0);\n-    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n-    LOG(LL_DEBUG,\n-        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n-    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n-      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n-      return -2;\n-    } else {\n-      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n-      fclose(fp);\n-      mg_http_reply(c, 200, \"\", \"\");\n-      return (int) hm->body.len;\n-    }\n-  }\n-}\n-#endif\n-\n static void static_cb(struct mg_connection *c, int ev, void *ev_data,\n                       void *fn_data) {\n   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {\n@@ -916,6 +888,34 @@ void mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm) {\n   c->recv.len -= ch.len;\n }\n \n+#if MG_ENABLE_FILE\n+int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n+                   const char *dir) {\n+  char offset[40] = \"\", name[200] = \"\", path[256];\n+  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n+  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n+  if (name[0] == '\\0') {\n+    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n+    return -1;\n+  } else {\n+    FILE *fp;\n+    long oft = strtol(offset, NULL, 0);\n+    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n+    remove_double_dots(path);\n+    LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));\n+    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n+      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);\n+      return -2;\n+    } else {\n+      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n+      fclose(fp);\n+      mg_http_reply(c, 200, \"\", \"\");\n+      return (int) hm->body.len;\n+    }\n+  }\n+}\n+#endif\n+\n static void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n   if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {\n     struct mg_http_message hm;"
        },
        {
          "filename": "test/unit_test.c",
          "status": "modified",
          "additions": 15,
          "deletions": 1,
          "patch": "@@ -679,7 +679,6 @@ static void test_http_server(void) {\n     char *p;\n     remove(\"uploaded.txt\");\n     ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) == NULL);\n-\n     ASSERT(fetch(&mgr, buf, url,\n                  \"POST /upload HTTP/1.0\\n\"\n                  \"Content-Length: 1\\n\\nx\") == 400);\n@@ -698,6 +697,21 @@ static void test_http_server(void) {\n     remove(\"uploaded.txt\");\n   }\n \n+  {\n+    // Test upload directory traversal\n+    char *p;\n+    remove(\"uploaded.txt\");\n+    ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) == NULL);\n+    ASSERT(fetch(&mgr, buf, url,\n+                 \"POST /upload?name=../uploaded.txt HTTP/1.0\\r\\n\"\n+                 \"Content-Length: 5\\r\\n\"\n+                 \"\\r\\nhello\") == 200);\n+    ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) != NULL);\n+    ASSERT(strcmp(p, \"hello\") == 0);\n+    free(p);\n+    remove(\"uploaded.txt\");\n+  }\n+\n   // HEAD request\n   ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n   ASSERT(fetch(&mgr, buf, url, \"HEAD /a.txt HTTP/1.0\\n\\n\") == 200);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8de9699390b95a0295cbc57f134d33b74613f4d4",
            "date": "2025-01-24T15:05:17Z",
            "author_login": "scaprile"
          },
          {
            "sha": "bf592a22ae6c62d22a22b113ab056555d1a433c3",
            "date": "2025-01-23T22:15:40Z",
            "author_login": "scaprile"
          },
          {
            "sha": "8d4a619a15a77708ed0210f0cce6382692a28926",
            "date": "2025-01-23T17:33:28Z",
            "author_login": "scaprile"
          },
          {
            "sha": "1a3588624d9894c0ca215d58ceec637e58c6fa7e",
            "date": "2025-01-21T19:50:14Z",
            "author_login": "scaprile"
          },
          {
            "sha": "74b3fd2efc9f289f9b21fead82afe381c6e1cdcc",
            "date": "2025-01-17T23:07:35Z",
            "author_login": "scaprile"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-552",
    "description": "This affects the package cesanta/mongoose before 7.6. The unsafe handling of file names during upload using mg_http_upload() method may enable attackers to write files to arbitrary locations outside the designated target folder.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-02-18T13:15:08.383",
    "last_modified": "2024-11-21T06:51:57.187",
    "fix_date": "2022-01-17T12:08:23Z"
  },
  "references": [
    {
      "url": "https://github.com/cesanta/mongoose/commit/c65c8fdaaa257e0487ab0aaae9e8f6b439335945",
      "source": "report@snyk.io",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://snyk.io/vuln/SNYK-UNMANAGED-CESANTAMONGOOSE-2404180",
      "source": "report@snyk.io",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/cesanta/mongoose/commit/c65c8fdaaa257e0487ab0aaae9e8f6b439335945",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://snyk.io/vuln/SNYK-UNMANAGED-CESANTAMONGOOSE-2404180",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:02:59.728893",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "mongoose",
    "owner": "cesanta",
    "created_at": "2012-08-14T15:09:51Z",
    "updated_at": "2025-01-14T10:34:26Z",
    "pushed_at": "2025-01-13T08:36:30Z",
    "size": 33259,
    "stars": 11308,
    "forks": 2751,
    "open_issues": 8,
    "watchers": 11308,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "C": 2303375,
      "C++": 113221,
      "Makefile": 72214,
      "JavaScript": 63544,
      "HTML": 24255,
      "CSS": 7324,
      "Shell": 6552,
      "Batchfile": 333
    },
    "commit_activity": {
      "total_commits_last_year": 322,
      "avg_commits_per_week": 6.1923076923076925,
      "days_active_last_year": 178
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:08:52.126107"
  }
}