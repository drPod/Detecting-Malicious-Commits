{
  "cve_id": "CVE-2022-25891",
  "github_data": {
    "repository": "containrrr/shoutrrr",
    "fix_commit": "6a27056f9d7522a8b493216195cb7634bf4b5c42",
    "related_commits": [
      "6a27056f9d7522a8b493216195cb7634bf4b5c42",
      "6a27056f9d7522a8b493216195cb7634bf4b5c42"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "6a27056f9d7522a8b493216195cb7634bf4b5c42",
      "commit_date": "2022-05-21T12:48:37Z",
      "author": {
        "login": "piksel",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix(discord): message size fixes (#242)",
        "length": 287,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 258,
        "additions": 160,
        "deletions": 98
      },
      "files": [
        {
          "filename": "pkg/services/discord/discord.go",
          "status": "modified",
          "additions": 14,
          "deletions": 12,
          "patch": "@@ -4,12 +4,13 @@ import (\n \t\"bytes\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"net/http\"\n+\t\"net/url\"\n+\n \t\"github.com/containrrr/shoutrrr/pkg/format\"\n \t\"github.com/containrrr/shoutrrr/pkg/services/standard\"\n \t\"github.com/containrrr/shoutrrr/pkg/types\"\n \t\"github.com/containrrr/shoutrrr/pkg/util\"\n-\t\"net/http\"\n-\t\"net/url\"\n )\n \n // Service providing Discord as a notification service\n@@ -32,15 +33,20 @@ const (\n )\n \n // Send a notification message to discord\n-func (service *Service) Send(message string, params *types.Params) error {\n-\n+func (service *Service) Send(message string, params *types.Params) (err error) {\n \tif service.config.JSON {\n \t\tpostURL := CreateAPIURLFromConfig(service.config)\n-\t\treturn doSend([]byte(message), postURL)\n+\t\terr = doSend([]byte(message), postURL)\n+\t} else {\n+\t\titems, omitted := CreateItemsFromPlain(message, service.config.SplitLines)\n+\t\terr = service.sendItems(items, params, omitted)\n \t}\n \n-\titems, omitted := CreateItemsFromPlain(message, service.config.SplitLines)\n-\treturn service.sendItems(items, params, omitted)\n+\tif err != nil {\n+\t\terr = fmt.Errorf(\"failed to send discord notification: %v\", err)\n+\t}\n+\n+\treturn\n }\n \n // SendItems sends items with additional meta data and richer appearance\n@@ -121,9 +127,5 @@ func doSend(payload []byte, postURL string) error {\n \t\terr = fmt.Errorf(\"response status code %s\", res.Status)\n \t}\n \n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"failed to send discord notification: %v\", err)\n-\t}\n-\n-\treturn nil\n+\treturn err\n }"
        },
        {
          "filename": "pkg/services/discord/discord_json.go",
          "status": "modified",
          "additions": 17,
          "deletions": 8,
          "patch": "@@ -2,16 +2,17 @@ package discord\n \n import (\n \t\"fmt\"\n+\t\"time\"\n+\n \t\"github.com/containrrr/shoutrrr/pkg/types\"\n \t\"github.com/containrrr/shoutrrr/pkg/util\"\n-\t\"time\"\n )\n \n // WebhookPayload is the webhook endpoint payload\n type WebhookPayload struct {\n-\tEmbeds   []embedItem `json:\"embeds\"`\n-\tUsername string      `json:\"username,omitempty\"`\n-\tAvatarURL string     `json:\"avatar_url,omitempty\"`\n+\tEmbeds    []embedItem `json:\"embeds\"`\n+\tUsername  string      `json:\"username,omitempty\"`\n+\tAvatarURL string      `json:\"avatar_url,omitempty\"`\n }\n \n // JSON is the actual notification payload\n@@ -32,6 +33,10 @@ type embedFooter struct {\n // CreatePayloadFromItems creates a JSON payload to be sent to the discord webhook API\n func CreatePayloadFromItems(items []types.MessageItem, title string, colors [types.MessageLevelCount]uint, omitted int) (WebhookPayload, error) {\n \n+\tif len(items) < 1 {\n+\t\treturn WebhookPayload{}, fmt.Errorf(\"message is empty\")\n+\t}\n+\n \tmetaCount := 1\n \tif omitted < 1 && len(title) < 1 {\n \t\tmetaCount = 0\n@@ -65,10 +70,14 @@ func CreatePayloadFromItems(items []types.MessageItem, title string, colors [typ\n \t\tembeds = append(embeds, ei)\n \t}\n \n-\tembeds[0].Title = title\n-\tif omitted > 0 {\n-\t\tembeds[0].Footer = &embedFooter{\n-\t\t\tText: fmt.Sprintf(\"... (%v character(s) where omitted)\", omitted),\n+\t// This should not happen, but it's better to leave the index check before dereferencing the array\n+\tif len(embeds) > 0 {\n+\t\tembeds[0].Title = title\n+\n+\t\tif omitted > 0 {\n+\t\t\tembeds[0].Footer = &embedFooter{\n+\t\t\t\tText: fmt.Sprintf(\"... (%v character(s) were omitted)\", omitted),\n+\t\t\t}\n \t\t}\n \t}\n "
        },
        {
          "filename": "pkg/services/discord/discord_test.go",
          "status": "modified",
          "additions": 49,
          "deletions": 20,
          "patch": "@@ -1,6 +1,7 @@\n package discord_test\n \n import (\n+\t\"fmt\"\n \t\"log\"\n \t\"time\"\n \n@@ -115,12 +116,24 @@ var _ = Describe(\"the discord service\", func() {\n \t\t})\n \t})\n \tDescribe(\"creating a json payload\", func() {\n-\t\t//When(\"given a blank message\", func() {\n-\t\t//\tIt(\"should return an error\", func() {\n-\t\t//\t\t_, err := CreatePayloadFromItems(\"\", false)\n-\t\t//\t\tExpect(err).To(HaveOccurred())\n-\t\t//\t})\n-\t\t//})\n+\t\tWhen(\"given a blank message\", func() {\n+\t\t\tWhen(\"split lines is enabled\", func() {\n+\t\t\t\tIt(\"should return an error\", func() {\n+\t\t\t\t\titems, omitted := CreateItemsFromPlain(\"\", true)\n+\t\t\t\t\tExpect(items).To(BeEmpty())\n+\t\t\t\t\t_, err := CreatePayloadFromItems(items, \"title\", dummyColors, omitted)\n+\t\t\t\t\tExpect(err).To(HaveOccurred())\n+\t\t\t\t})\n+\t\t\t})\n+\t\t\tWhen(\"split lines is disabled\", func() {\n+\t\t\t\tIt(\"should return an error\", func() {\n+\t\t\t\t\titems, omitted := CreateItemsFromPlain(\"\", false)\n+\t\t\t\t\tExpect(items).To(BeEmpty())\n+\t\t\t\t\t_, err := CreatePayloadFromItems(items, \"title\", dummyColors, omitted)\n+\t\t\t\t\tExpect(err).To(HaveOccurred())\n+\t\t\t\t})\n+\t\t\t})\n+\t\t})\n \t\tWhen(\"given a message that exceeds the max length\", func() {\n \t\t\tIt(\"should return a payload with chunked messages\", func() {\n \n@@ -204,29 +217,45 @@ var _ = Describe(\"the discord service\", func() {\n \t})\n \n \tDescribe(\"sending the payload\", func() {\n-\t\tvar err error\n+\t\tvar dummyConfig = Config{\n+\t\t\tWebhookID: \"1\",\n+\t\t\tToken:     \"dummyToken\",\n+\t\t}\n+\t\tvar service Service\n \t\tBeforeEach(func() {\n \t\t\thttpmock.Activate()\n+\t\t\tservice = Service{}\n+\t\t\tif err := service.Initialize(dummyConfig.GetURL(), logger); err != nil {\n+\t\t\t\tpanic(fmt.Errorf(\"service initialization failed: %v\", err))\n+\t\t\t}\n \t\t})\n \t\tAfterEach(func() {\n \t\t\thttpmock.DeactivateAndReset()\n \t\t})\n \t\tIt(\"should not report an error if the server accepts the payload\", func() {\n-\t\t\tconfig := Config{\n-\t\t\t\tWebhookID: \"1\",\n-\t\t\t\tToken:     \"dummyToken\",\n-\t\t\t}\n-\t\t\tserviceURL := config.GetURL()\n-\t\t\tservice := Service{}\n-\t\t\terr = service.Initialize(serviceURL, logger)\n-\t\t\tExpect(err).NotTo(HaveOccurred())\n+\t\t\tsetupResponder(&dummyConfig, 204, \"\")\n \n-\t\t\tsetupResponder(&config, 204, \"\")\n-\n-\t\t\terr = service.Send(\"Message\", nil)\n-\t\t\tExpect(err).NotTo(HaveOccurred())\n+\t\t\tExpect(service.Send(\"Message\", nil)).To(Succeed())\n+\t\t})\n+\t\tIt(\"should report an error if the server response is not OK\", func() {\n+\t\t\tsetupResponder(&dummyConfig, 400, \"\")\n+\t\t\tExpect(service.Initialize(dummyConfig.GetURL(), logger)).To(Succeed())\n+\t\t\tExpect(service.Send(\"Message\", nil)).NotTo(Succeed())\n+\t\t})\n+\t\tIt(\"should report an error if the message is empty\", func() {\n+\t\t\tsetupResponder(&dummyConfig, 204, \"\")\n+\t\t\tExpect(service.Initialize(dummyConfig.GetURL(), logger)).To(Succeed())\n+\t\t\tExpect(service.Send(\"\", nil)).NotTo(Succeed())\n+\t\t})\n+\t\tWhen(\"using a custom json payload\", func() {\n+\t\t\tIt(\"should report an error if the server response is not OK\", func() {\n+\t\t\t\tconfig := dummyConfig\n+\t\t\t\tconfig.JSON = true\n+\t\t\t\tsetupResponder(&config, 400, \"\")\n+\t\t\t\tExpect(service.Initialize(config.GetURL(), logger)).To(Succeed())\n+\t\t\t\tExpect(service.Send(\"Message\", nil)).NotTo(Succeed())\n+\t\t\t})\n \t\t})\n-\n \t})\n })\n "
        },
        {
          "filename": "pkg/util/partition_message.go",
          "status": "modified",
          "additions": 10,
          "deletions": 4,
          "patch": "@@ -18,11 +18,17 @@ func PartitionMessage(input string, limits t.MessageLimit, distance int) (items\n \tmaxTotal := Min(len(runes), limits.TotalChunkSize)\n \tmaxCount := limits.ChunkCount - 1\n \n+\tif len(input) == 0 {\n+\t\t// If the message is empty, return an empty array\n+\t\tomitted = 0\n+\t\treturn\n+\t}\n+\n \tfor i := 0; i < maxCount; i++ {\n-\t\t// If no suitable split point is found, use the chunkSize\n-\t\tchunkEnd := chunkOffset + limits.ChunkSize\n-\t\t// ... and start next chunk directly after this one\n-\t\tnextChunkStart := chunkEnd\n+\t\t// If no suitable split point is found, start next chunk at chunkSize from chunk start\n+\t\tnextChunkStart := chunkOffset + limits.ChunkSize\n+\t\t// ... and set the chunk end to the rune before the next chunk\n+\t\tchunkEnd := nextChunkStart - 1\n \t\tif chunkEnd > maxTotal {\n \t\t\t// The chunk is smaller than the limit, no need to search\n \t\t\tchunkEnd = maxTotal"
        },
        {
          "filename": "pkg/util/partition_message_test.go",
          "status": "modified",
          "additions": 70,
          "deletions": 54,
          "patch": "@@ -1,85 +1,101 @@\n package util\n \n import (\n+\t\"strings\"\n+\n \t\"github.com/containrrr/shoutrrr/pkg/types\"\n \t. \"github.com/onsi/ginkgo\"\n \t. \"github.com/onsi/gomega\"\n-\t\"strings\"\n )\n \n var _ = Describe(\"Partition Message\", func() {\n-\tDescribe(\"creating a json payload\", func() {\n-\t\tlimits := types.MessageLimit{\n-\t\t\tChunkSize:      2000,\n-\t\t\tTotalChunkSize: 6000,\n-\t\t\tChunkCount:     10,\n-\t\t}\n-\t\tWhen(\"given a message that exceeds the max length\", func() {\n-\t\t\tWhen(\"not splitting by lines\", func() {\n-\t\t\t\tIt(\"should return a payload with chunked messages\", func() {\n+\tlimits := types.MessageLimit{\n+\t\tChunkSize:      2000,\n+\t\tTotalChunkSize: 6000,\n+\t\tChunkCount:     10,\n+\t}\n+\tWhen(\"given a message that exceeds the max length\", func() {\n+\t\tWhen(\"not splitting by lines\", func() {\n+\t\t\tIt(\"should return a payload with chunked messages\", func() {\n \n-\t\t\t\t\titems, _ := testPartitionMessage(42, limits, 100)\n+\t\t\t\titems, _ := testPartitionMessage(42, limits, 100)\n \n-\t\t\t\t\tExpect(len(items[0].Text)).To(Equal(1994))\n-\t\t\t\t\tExpect(len(items[1].Text)).To(Equal(1999))\n-\t\t\t\t\tExpect(len(items[2].Text)).To(Equal(205))\n-\t\t\t\t})\n-\t\t\t\tIt(\"omit characters above total max\", func() {\n-\t\t\t\t\titems, _ := testPartitionMessage(62, limits, 100)\n+\t\t\t\tExpect(len(items[0].Text)).To(Equal(1994))\n+\t\t\t\tExpect(len(items[1].Text)).To(Equal(1999))\n+\t\t\t\tExpect(len(items[2].Text)).To(Equal(205))\n+\t\t\t})\n+\t\t\tIt(\"omit characters above total max\", func() {\n+\t\t\t\titems, _ := testPartitionMessage(62, limits, 100)\n \n-\t\t\t\t\tExpect(len(items[0].Text)).To(Equal(1994))\n-\t\t\t\t\tExpect(len(items[1].Text)).To(Equal(1999))\n-\t\t\t\t\tExpect(len(items[2].Text)).To(Equal(1999))\n-\t\t\t\t\tExpect(len(items[3].Text)).To(Equal(5))\n+\t\t\t\tExpect(len(items[0].Text)).To(Equal(1994))\n+\t\t\t\tExpect(len(items[1].Text)).To(Equal(1999))\n+\t\t\t\tExpect(len(items[2].Text)).To(Equal(1999))\n+\t\t\t\tExpect(len(items[3].Text)).To(Equal(5))\n+\t\t\t})\n+\t\t\tIt(\"should handle messages with a size modulus of chunksize\", func() {\n+\t\t\t\titems, _ := testPartitionMessage(20, limits, 100)\n+\t\t\t\tExpect(len(items[0].Text)).To(Equal(1994))\n+\t\t\t\tExpect(len(items[1].Text)).To(Equal(5))\n+\n+\t\t\t\titems, _ = testPartitionMessage(40, limits, 100)\n+\t\t\t\tExpect(len(items[0].Text)).To(Equal(1994))\n+\t\t\t\tExpect(len(items[1].Text)).To(Equal(1999))\n+\t\t\t\tExpect(len(items[2].Text)).To(Equal(5))\n+\t\t\t})\n+\t\t\tWhen(\"the message is empty\", func() {\n+\t\t\t\tIt(\"should return no items\", func() {\n+\t\t\t\t\titems, _ := testPartitionMessage(0, limits, 100)\n+\t\t\t\t\tExpect(items).To(BeEmpty())\n \t\t\t\t})\n \t\t\t})\n-\t\t\tWhen(\"splitting by lines\", func() {\n-\t\t\t\tIt(\"should return a payload with chunked messages\", func() {\n-\t\t\t\t\titems, omitted := testMessageItemsFromLines(18, limits, 2)\n \n-\t\t\t\t\tExpect(len(items[0].Text)).To(Equal(200))\n-\t\t\t\t\tExpect(len(items[8].Text)).To(Equal(200))\n+\t\t})\n+\t\tWhen(\"splitting by lines\", func() {\n+\t\t\tIt(\"should return a payload with chunked messages\", func() {\n+\t\t\t\titems, omitted := testMessageItemsFromLines(18, limits, 2)\n \n-\t\t\t\t\tExpect(omitted).To(Equal(0))\n-\t\t\t\t})\n-\t\t\t\tIt(\"omit characters above total max\", func() {\n-\t\t\t\t\titems, omitted := testMessageItemsFromLines(19, limits, 2)\n+\t\t\t\tExpect(len(items[0].Text)).To(Equal(200))\n+\t\t\t\tExpect(len(items[8].Text)).To(Equal(200))\n \n-\t\t\t\t\tExpect(len(items[0].Text)).To(Equal(200))\n-\t\t\t\t\tExpect(len(items[8].Text)).To(Equal(200))\n+\t\t\t\tExpect(omitted).To(Equal(0))\n+\t\t\t})\n+\t\t\tIt(\"omit characters above total max\", func() {\n+\t\t\t\titems, omitted := testMessageItemsFromLines(19, limits, 2)\n \n-\t\t\t\t\tExpect(omitted).To(Equal(100))\n-\t\t\t\t})\n-\t\t\t\tIt(\"should trim characters above chunk size\", func() {\n-\t\t\t\t\thundreds := 42\n-\t\t\t\t\trepeat := 21\n-\t\t\t\t\titems, omitted := testMessageItemsFromLines(hundreds, limits, repeat)\n+\t\t\t\tExpect(len(items[0].Text)).To(Equal(200))\n+\t\t\t\tExpect(len(items[8].Text)).To(Equal(200))\n \n-\t\t\t\t\tExpect(len(items[0].Text)).To(Equal(limits.ChunkSize))\n-\t\t\t\t\tExpect(len(items[1].Text)).To(Equal(limits.ChunkSize))\n+\t\t\t\tExpect(omitted).To(Equal(100))\n+\t\t\t})\n+\t\t\tIt(\"should trim characters above chunk size\", func() {\n+\t\t\t\thundreds := 42\n+\t\t\t\trepeat := 21\n+\t\t\t\titems, omitted := testMessageItemsFromLines(hundreds, limits, repeat)\n \n-\t\t\t\t\t// Trimmed characters do not count towards the total omitted count\n-\t\t\t\t\tExpect(omitted).To(Equal(0))\n-\t\t\t\t})\n+\t\t\t\tExpect(len(items[0].Text)).To(Equal(limits.ChunkSize))\n+\t\t\t\tExpect(len(items[1].Text)).To(Equal(limits.ChunkSize))\n \n-\t\t\t\tIt(\"omit characters above total chunk size\", func() {\n-\t\t\t\t\thundreds := 100\n-\t\t\t\t\trepeat := 20\n-\t\t\t\t\titems, omitted := testMessageItemsFromLines(hundreds, limits, repeat)\n+\t\t\t\t// Trimmed characters do not count towards the total omitted count\n+\t\t\t\tExpect(omitted).To(Equal(0))\n+\t\t\t})\n \n-\t\t\t\t\tExpect(len(items[0].Text)).To(Equal(limits.ChunkSize))\n-\t\t\t\t\tExpect(len(items[1].Text)).To(Equal(limits.ChunkSize))\n-\t\t\t\t\tExpect(len(items[2].Text)).To(Equal(limits.ChunkSize))\n+\t\t\tIt(\"omit characters above total chunk size\", func() {\n+\t\t\t\thundreds := 100\n+\t\t\t\trepeat := 20\n+\t\t\t\titems, omitted := testMessageItemsFromLines(hundreds, limits, repeat)\n \n-\t\t\t\t\tmaxRunes := hundreds * 100\n-\t\t\t\t\texpectedOmitted := maxRunes - limits.TotalChunkSize\n+\t\t\t\tExpect(len(items[0].Text)).To(Equal(limits.ChunkSize))\n+\t\t\t\tExpect(len(items[1].Text)).To(Equal(limits.ChunkSize))\n+\t\t\t\tExpect(len(items[2].Text)).To(Equal(limits.ChunkSize))\n \n-\t\t\t\t\tExpect(omitted).To(Equal(expectedOmitted))\n-\t\t\t\t})\n+\t\t\t\tmaxRunes := hundreds * 100\n+\t\t\t\texpectedOmitted := maxRunes - limits.TotalChunkSize\n \n+\t\t\t\tExpect(omitted).To(Equal(expectedOmitted))\n \t\t\t})\n \n \t\t})\n+\n \t})\n })\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "3c77fd561ef108f9a683dfe68f108d56d67c7f24",
            "date": "2024-01-03T11:46:45Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "be4df5e3a2f9d4005bac41211929b5e6428fd87f",
            "date": "2024-01-03T11:25:54Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "70699483975eae2edb8a127fe0f177ce5a196501",
            "date": "2024-01-03T11:25:38Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "e389a6f75b3b81afa476495cdcedcc7e775be8e4",
            "date": "2024-01-01T15:08:28Z",
            "author_login": "atgreen"
          },
          {
            "sha": "88c33ee066315dfaa2790fee640193bdd043461c",
            "date": "2023-12-08T09:49:10Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": null,
    "description": "The package github.com/containrrr/shoutrrr/pkg/util before 0.6.0 are vulnerable to Denial of Service (DoS) via the util.PartitionMessage function. Exploiting this vulnerability is possible by sending exactly 2000, 4000, or 6000 characters messages.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-07-15T20:15:08.540",
    "last_modified": "2024-11-21T06:53:10.343",
    "fix_date": "2022-05-21T12:48:37Z"
  },
  "references": [
    {
      "url": "https://github.com/containrrr/shoutrrr/commit/6a27056f9d7522a8b493216195cb7634bf4b5c42",
      "source": "report@snyk.io",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/containrrr/shoutrrr/issues/240",
      "source": "report@snyk.io",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/containrrr/shoutrrr/pull/242",
      "source": "report@snyk.io",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/containrrr/shoutrrr/releases/tag/v0.6.0",
      "source": "report@snyk.io",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://snyk.io/vuln/SNYK-GOLANG-GITHUBCOMCONTAINRRRSHOUTRRRPKGUTIL-2849059",
      "source": "report@snyk.io",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/containrrr/shoutrrr/commit/6a27056f9d7522a8b493216195cb7634bf4b5c42",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/containrrr/shoutrrr/issues/240",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/containrrr/shoutrrr/pull/242",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/containrrr/shoutrrr/releases/tag/v0.6.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://snyk.io/vuln/SNYK-GOLANG-GITHUBCOMCONTAINRRRSHOUTRRRPKGUTIL-2849059",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:11.495009",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "shoutrrr",
    "owner": "containrrr",
    "created_at": "2019-04-11T06:49:34Z",
    "updated_at": "2025-01-25T01:09:21Z",
    "pushed_at": "2024-07-26T14:54:15Z",
    "size": 13520,
    "stars": 1099,
    "forks": 62,
    "open_issues": 72,
    "watchers": 1099,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "gh-pages"
    ],
    "languages": {
      "Go": 468654,
      "Shell": 1267,
      "Dockerfile": 236
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T08:18:15.093215"
  }
}