{
  "cve_id": "CVE-2022-2756",
  "github_data": {
    "repository": "kareadita/kavita",
    "fix_commit": "9c31f7e7c81b919923cb2e3857439ec0d16243e4",
    "related_commits": [
      "9c31f7e7c81b919923cb2e3857439ec0d16243e4",
      "9c31f7e7c81b919923cb2e3857439ec0d16243e4"
    ],
    "patch_url": "https://github.com/kareadita/kavita/commit/9c31f7e7c81b919923cb2e3857439ec0d16243e4.patch",
    "fix_commit_details": {
      "sha": "9c31f7e7c81b919923cb2e3857439ec0d16243e4",
      "commit_date": "2022-08-08T20:22:38Z",
      "author": {
        "login": "majora2007",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "v0.5.4.1 - Security Hotfix (#1414)",
        "length": 1280,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 221,
        "additions": 171,
        "deletions": 50
      },
      "files": [
        {
          "filename": "API/Controllers/AccountController.cs",
          "status": "modified",
          "additions": 19,
          "deletions": 7,
          "patch": "@@ -70,13 +70,21 @@ public AccountController(UserManager<AppUser> userManager,\n         /// </summary>\n         /// <param name=\"resetPasswordDto\"></param>\n         /// <returns></returns>\n+        [AllowAnonymous]\n         [HttpPost(\"reset-password\")]\n         public async Task<ActionResult> UpdatePassword(ResetPasswordDto resetPasswordDto)\n         {\n+            // TODO: Log this request to Audit Table\n             _logger.LogInformation(\"{UserName} is changing {ResetUser}'s password\", User.GetUsername(), resetPasswordDto.UserName);\n-            var user = await _userManager.Users.SingleAsync(x => x.UserName == resetPasswordDto.UserName);\n \n-            if (resetPasswordDto.UserName != User.GetUsername() && !(User.IsInRole(PolicyConstants.AdminRole) || User.IsInRole(PolicyConstants.ChangePasswordRole)))\n+            var user = await _userManager.Users.SingleOrDefaultAsync(x => x.UserName == resetPasswordDto.UserName);\n+            if (user == null) return Ok(); // Don't report BadRequest as that would allow brute forcing to find accounts on system\n+\n+\n+            if (resetPasswordDto.UserName == User.GetUsername() && !(User.IsInRole(PolicyConstants.ChangePasswordRole) || User.IsInRole(PolicyConstants.AdminRole)))\n+                return Unauthorized(\"You are not permitted to this operation.\");\n+\n+            if (resetPasswordDto.UserName != User.GetUsername() && !User.IsInRole(PolicyConstants.AdminRole))\n                 return Unauthorized(\"You are not permitted to this operation.\");\n \n             var errors = await _accountService.ChangeUserPassword(user, resetPasswordDto.Password);\n@@ -94,6 +102,7 @@ public async Task<ActionResult> UpdatePassword(ResetPasswordDto resetPasswordDto\n         /// </summary>\n         /// <param name=\"registerDto\"></param>\n         /// <returns></returns>\n+        [AllowAnonymous]\n         [HttpPost(\"register\")]\n         public async Task<ActionResult<UserDto>> RegisterFirstUser(RegisterDto registerDto)\n         {\n@@ -155,6 +164,7 @@ public async Task<ActionResult<UserDto>> RegisterFirstUser(RegisterDto registerD\n         /// </summary>\n         /// <param name=\"loginDto\"></param>\n         /// <returns></returns>\n+        [AllowAnonymous]\n         [HttpPost(\"login\")]\n         public async Task<ActionResult<UserDto>> Login(LoginDto loginDto)\n         {\n@@ -173,14 +183,14 @@ public async Task<ActionResult<UserDto>> Login(LoginDto loginDto)\n                     \"You are missing an email on your account. Please wait while we migrate your account.\");\n             }\n \n-            if (!validPassword)\n+            var result = await _signInManager\n+                .CheckPasswordSignInAsync(user, loginDto.Password, true);\n+\n+            if (result.IsLockedOut)\n             {\n-                return Unauthorized(\"Your credentials are not correct\");\n+                return Unauthorized(\"You've been locked out from too many authorization attempts. Please wait 10 minutes.\");\n             }\n \n-            var result = await _signInManager\n-                .CheckPasswordSignInAsync(user, loginDto.Password, false);\n-\n             if (!result.Succeeded)\n             {\n                 return Unauthorized(result.IsNotAllowed ? \"You must confirm your email first\" : \"Your credentials are not correct.\");\n@@ -212,6 +222,7 @@ public async Task<ActionResult<UserDto>> Login(LoginDto loginDto)\n         /// </summary>\n         /// <param name=\"tokenRequestDto\"></param>\n         /// <returns></returns>\n+        [AllowAnonymous]\n         [HttpPost(\"refresh-token\")]\n         public async Task<ActionResult<TokenRequestDto>> RefreshToken([FromBody] TokenRequestDto tokenRequestDto)\n         {\n@@ -462,6 +473,7 @@ await _emailService.SendConfirmationEmail(new ConfirmationEmailDto()\n             return BadRequest(\"There was an error setting up your account. Please check the logs\");\n         }\n \n+        [AllowAnonymous]\n         [HttpPost(\"confirm-email\")]\n         public async Task<ActionResult<UserDto>> ConfirmEmail(ConfirmEmailDto dto)\n         {"
        },
        {
          "filename": "API/Controllers/AdminController.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -1,5 +1,6 @@\n \ufeffusing System.Threading.Tasks;\n using API.Entities;\n+using Microsoft.AspNetCore.Authorization;\n using Microsoft.AspNetCore.Identity;\n using Microsoft.AspNetCore.Mvc;\n \n@@ -18,6 +19,7 @@ public AdminController(UserManager<AppUser> userManager)\n         /// Checks if an admin exists on the system. This is essentially a check to validate if the system has been setup.\n         /// </summary>\n         /// <returns></returns>\n+        [AllowAnonymous]\n         [HttpGet(\"exists\")]\n         public async Task<ActionResult<bool>> AdminExists()\n         {"
        },
        {
          "filename": "API/Controllers/BaseApiController.cs",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -1,10 +1,12 @@\n-\ufeffusing Microsoft.AspNetCore.Mvc;\n+\ufeffusing Microsoft.AspNetCore.Authorization;\n+using Microsoft.AspNetCore.Mvc;\n \n namespace API.Controllers\n {\n     [ApiController]\n     [Route(\"api/[controller]\")]\n+    [Authorize]\n     public class BaseApiController : ControllerBase\n     {\n     }\n-}\n\\ No newline at end of file\n+}"
        },
        {
          "filename": "API/Controllers/FallbackController.cs",
          "status": "modified",
          "additions": 17,
          "deletions": 15,
          "patch": "@@ -1,24 +1,26 @@\n \ufeffusing System.IO;\n using API.Services;\n+using Microsoft.AspNetCore.Authorization;\n using Microsoft.AspNetCore.Mvc;\n \n-namespace API.Controllers\n+namespace API.Controllers;\n+\n+[AllowAnonymous]\n+public class FallbackController : Controller\n {\n-    public class FallbackController : Controller\n-    {\n-        // ReSharper disable once S4487\n-        // ReSharper disable once NotAccessedField.Local\n-        private readonly ITaskScheduler _taskScheduler;\n+    // ReSharper disable once S4487\n+    // ReSharper disable once NotAccessedField.Local\n+    private readonly ITaskScheduler _taskScheduler;\n \n-        public FallbackController(ITaskScheduler taskScheduler)\n-        {\n-            // This is used to load TaskScheduler on startup without having to navigate to a Controller that uses.\n-            _taskScheduler = taskScheduler;\n-        }\n+    public FallbackController(ITaskScheduler taskScheduler)\n+    {\n+        // This is used to load TaskScheduler on startup without having to navigate to a Controller that uses.\n+        _taskScheduler = taskScheduler;\n+    }\n \n-        public ActionResult Index()\n-        {\n-            return PhysicalFile(Path.Combine(Directory.GetCurrentDirectory(), \"wwwroot\", \"index.html\"), \"text/HTML\");\n-        }\n+    public ActionResult Index()\n+    {\n+        return PhysicalFile(Path.Combine(Directory.GetCurrentDirectory(), \"wwwroot\", \"index.html\"), \"text/HTML\");\n     }\n }\n+"
        },
        {
          "filename": "API/Controllers/ImageController.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -137,6 +137,8 @@ public async Task<ActionResult> GetBookmarkImage(int chapterId, int pageNum, str\n         [HttpGet(\"cover-upload\")]\n         public ActionResult GetCoverUploadImage(string filename)\n         {\n+            if (filename.Contains(\"..\")) return BadRequest(\"Invalid Filename\");\n+\n             var path = Path.Join(_directoryService.TempDirectory, filename);\n             if (string.IsNullOrEmpty(path) || !_directoryService.FileSystem.File.Exists(path)) return BadRequest($\"File does not exist\");\n             var format = _directoryService.FileSystem.Path.GetExtension(path).Replace(\".\", \"\");"
        },
        {
          "filename": "API/Controllers/OPDSController.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -17,10 +17,12 @@\n using API.Helpers;\n using API.Services;\n using Kavita.Common;\n+using Microsoft.AspNetCore.Authorization;\n using Microsoft.AspNetCore.Mvc;\n \n namespace API.Controllers;\n \n+[AllowAnonymous]\n public class OpdsController : BaseApiController\n {\n     private readonly IUnitOfWork _unitOfWork;"
        },
        {
          "filename": "API/Controllers/ReaderController.cs",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -57,6 +57,11 @@ public async Task<ActionResult> GetPdf(int chapterId)\n             var chapter = await _cacheService.Ensure(chapterId);\n             if (chapter == null) return BadRequest(\"There was an issue finding pdf file for reading\");\n \n+            // Validate the user has access to the PDF\n+            var series = await _unitOfWork.SeriesRepository.GetSeriesForChapter(chapter.Id,\n+                await _unitOfWork.UserRepository.GetUserIdByUsernameAsync(User.GetUsername()));\n+            if (series == null) return BadRequest(\"Invalid Access\");\n+\n             try\n             {\n                 var path = _cacheService.GetCachedFile(chapter);"
        },
        {
          "filename": "API/Controllers/ReadingListController.cs",
          "status": "modified",
          "additions": 72,
          "deletions": 19,
          "patch": "@@ -3,15 +3,18 @@\n using System.Threading.Tasks;\n using API.Comparators;\n using API.Data;\n+using API.Data.Repositories;\n using API.DTOs.ReadingLists;\n using API.Entities;\n using API.Extensions;\n using API.Helpers;\n using API.SignalR;\n+using Microsoft.AspNetCore.Authorization;\n using Microsoft.AspNetCore.Mvc;\n \n namespace API.Controllers\n {\n+    [Authorize]\n     public class ReadingListController : BaseApiController\n     {\n         private readonly IUnitOfWork _unitOfWork;\n@@ -73,8 +76,18 @@ public async Task<ActionResult<IEnumerable<ReadingListItemDto>>> GetListForUser(\n             var userId = await _unitOfWork.UserRepository.GetUserIdByUsernameAsync(User.GetUsername());\n             var items = await _unitOfWork.ReadingListRepository.GetReadingListItemDtosByIdAsync(readingListId, userId);\n             return Ok(items);\n+        }\n+\n+        private async Task<AppUser?> UserHasReadingListAccess(int readingListId)\n+        {\n+            var user = await _unitOfWork.UserRepository.GetUserByUsernameAsync(User.GetUsername(),\n+                AppUserIncludes.ReadingLists);\n+            if (user.ReadingLists.SingleOrDefault(rl => rl.Id == readingListId) == null && !await _unitOfWork.UserRepository.IsUserAdminAsync(user))\n+            {\n+                return null;\n+            }\n \n-            //return Ok(await _unitOfWork.ReadingListRepository.AddReadingProgressModifiers(userId, items.ToList()));\n+            return user;\n         }\n \n         /// <summary>\n@@ -86,6 +99,11 @@ public async Task<ActionResult<IEnumerable<ReadingListItemDto>>> GetListForUser(\n         public async Task<ActionResult> UpdateListItemPosition(UpdateReadingListPosition dto)\n         {\n             // Make sure UI buffers events\n+            var user = await UserHasReadingListAccess(dto.ReadingListId);\n+            if (user == null)\n+            {\n+                return BadRequest(\"You do not have permissions on this reading list or the list doesn't exist\");\n+            }\n             var items = (await _unitOfWork.ReadingListRepository.GetReadingListItemsByIdAsync(dto.ReadingListId)).ToList();\n             var item = items.Find(r => r.Id == dto.ReadingListItemId);\n             items.Remove(item);\n@@ -112,10 +130,15 @@ public async Task<ActionResult> UpdateListItemPosition(UpdateReadingListPosition\n         [HttpPost(\"delete-item\")]\n         public async Task<ActionResult> DeleteListItem(UpdateReadingListPosition dto)\n         {\n+            var user = await UserHasReadingListAccess(dto.ReadingListId);\n+            if (user == null)\n+            {\n+                return BadRequest(\"You do not have permissions on this reading list or the list doesn't exist\");\n+            }\n+\n             var readingList = await _unitOfWork.ReadingListRepository.GetReadingListByIdAsync(dto.ReadingListId);\n             readingList.Items = readingList.Items.Where(r => r.Id != dto.ReadingListItemId).ToList();\n \n-\n             var index = 0;\n             foreach (var readingListItem in readingList.Items)\n             {\n@@ -141,9 +164,14 @@ public async Task<ActionResult> DeleteListItem(UpdateReadingListPosition dto)\n         [HttpPost(\"remove-read\")]\n         public async Task<ActionResult> DeleteReadFromList([FromQuery] int readingListId)\n         {\n-            var userId = await _unitOfWork.UserRepository.GetUserIdByUsernameAsync(User.GetUsername());\n-            var items = await _unitOfWork.ReadingListRepository.GetReadingListItemDtosByIdAsync(readingListId, userId);\n-            items = await _unitOfWork.ReadingListRepository.AddReadingProgressModifiers(userId, items.ToList());\n+            var user = await UserHasReadingListAccess(readingListId);\n+            if (user == null)\n+            {\n+                return BadRequest(\"You do not have permissions on this reading list or the list doesn't exist\");\n+            }\n+\n+            var items = await _unitOfWork.ReadingListRepository.GetReadingListItemDtosByIdAsync(readingListId, user.Id);\n+            items = await _unitOfWork.ReadingListRepository.AddReadingProgressModifiers(user.Id, items.ToList());\n \n             // Collect all Ids to remove\n             var itemIdsToRemove = items.Where(item => item.PagesRead == item.PagesTotal).Select(item => item.Id);\n@@ -176,15 +204,13 @@ public async Task<ActionResult> DeleteReadFromList([FromQuery] int readingListId\n         [HttpDelete]\n         public async Task<ActionResult> DeleteList([FromQuery] int readingListId)\n         {\n-            var user = await _unitOfWork.UserRepository.GetUserWithReadingListsByUsernameAsync(User.GetUsername());\n-            var isAdmin = await _unitOfWork.UserRepository.IsUserAdminAsync(user);\n-            var readingList = user.ReadingLists.SingleOrDefault(r => r.Id == readingListId);\n-            if (readingList == null && !isAdmin)\n+            var user = await UserHasReadingListAccess(readingListId);\n+            if (user == null)\n             {\n-                return BadRequest(\"User is not associated with this reading list\");\n+                return BadRequest(\"You do not have permissions on this reading list or the list doesn't exist\");\n             }\n \n-            readingList = await _unitOfWork.ReadingListRepository.GetReadingListByIdAsync(readingListId);\n+            var readingList = await _unitOfWork.ReadingListRepository.GetReadingListByIdAsync(readingListId);\n \n             user.ReadingLists.Remove(readingList);\n \n@@ -213,13 +239,14 @@ public async Task<ActionResult<ReadingListDto>> CreateList(CreateReadingListDto\n                 return BadRequest(\"A list of this name already exists\");\n             }\n \n-            user.ReadingLists.Add(DbFactory.ReadingList(dto.Title, string.Empty, false));\n+            var readingList = DbFactory.ReadingList(dto.Title, string.Empty, false);\n+            user.ReadingLists.Add(readingList);\n \n             if (!_unitOfWork.HasChanges()) return BadRequest(\"There was a problem creating list\");\n \n             await _unitOfWork.CommitAsync();\n \n-            return Ok(await _unitOfWork.ReadingListRepository.GetReadingListDtoByTitleAsync(dto.Title));\n+            return Ok(await _unitOfWork.ReadingListRepository.GetReadingListDtoByTitleAsync(user.Id, dto.Title));\n         }\n \n         /// <summary>\n@@ -233,7 +260,11 @@ public async Task<ActionResult> UpdateList(UpdateReadingListDto dto)\n             var readingList = await _unitOfWork.ReadingListRepository.GetReadingListByIdAsync(dto.ReadingListId);\n             if (readingList == null) return BadRequest(\"List does not exist\");\n \n-\n+            var user = await UserHasReadingListAccess(readingList.Id);\n+            if (user == null)\n+            {\n+                return BadRequest(\"You do not have permissions on this reading list or the list doesn't exist\");\n+            }\n \n             if (!string.IsNullOrEmpty(dto.Title))\n             {\n@@ -277,7 +308,12 @@ await _eventHub.SendMessageAsync(MessageFactory.CoverUpdate,\n         [HttpPost(\"update-by-series\")]\n         public async Task<ActionResult> UpdateListBySeries(UpdateReadingListBySeriesDto dto)\n         {\n-            var user = await _unitOfWork.UserRepository.GetUserWithReadingListsByUsernameAsync(User.GetUsername());\n+            var user = await UserHasReadingListAccess(dto.ReadingListId);\n+            if (user == null)\n+            {\n+                return BadRequest(\"You do not have permissions on this reading list or the list doesn't exist\");\n+            }\n+\n             var readingList = user.ReadingLists.SingleOrDefault(l => l.Id == dto.ReadingListId);\n             if (readingList == null) return BadRequest(\"Reading List does not exist\");\n             var chapterIdsForSeries =\n@@ -314,7 +350,11 @@ public async Task<ActionResult> UpdateListBySeries(UpdateReadingListBySeriesDto\n         [HttpPost(\"update-by-multiple\")]\n         public async Task<ActionResult> UpdateListByMultiple(UpdateReadingListByMultipleDto dto)\n         {\n-            var user = await _unitOfWork.UserRepository.GetUserWithReadingListsByUsernameAsync(User.GetUsername());\n+            var user = await UserHasReadingListAccess(dto.ReadingListId);\n+            if (user == null)\n+            {\n+                return BadRequest(\"You do not have permissions on this reading list or the list doesn't exist\");\n+            }\n             var readingList = user.ReadingLists.SingleOrDefault(l => l.Id == dto.ReadingListId);\n             if (readingList == null) return BadRequest(\"Reading List does not exist\");\n \n@@ -354,7 +394,11 @@ public async Task<ActionResult> UpdateListByMultiple(UpdateReadingListByMultiple\n         [HttpPost(\"update-by-multiple-series\")]\n         public async Task<ActionResult> UpdateListByMultipleSeries(UpdateReadingListByMultipleSeriesDto dto)\n         {\n-            var user = await _unitOfWork.UserRepository.GetUserWithReadingListsByUsernameAsync(User.GetUsername());\n+            var user = await UserHasReadingListAccess(dto.ReadingListId);\n+            if (user == null)\n+            {\n+                return BadRequest(\"You do not have permissions on this reading list or the list doesn't exist\");\n+            }\n             var readingList = user.ReadingLists.SingleOrDefault(l => l.Id == dto.ReadingListId);\n             if (readingList == null) return BadRequest(\"Reading List does not exist\");\n \n@@ -388,9 +432,14 @@ public async Task<ActionResult> UpdateListByMultipleSeries(UpdateReadingListByMu\n         [HttpPost(\"update-by-volume\")]\n         public async Task<ActionResult> UpdateListByVolume(UpdateReadingListByVolumeDto dto)\n         {\n-            var user = await _unitOfWork.UserRepository.GetUserWithReadingListsByUsernameAsync(User.GetUsername());\n+            var user = await UserHasReadingListAccess(dto.ReadingListId);\n+            if (user == null)\n+            {\n+                return BadRequest(\"You do not have permissions on this reading list or the list doesn't exist\");\n+            }\n             var readingList = user.ReadingLists.SingleOrDefault(l => l.Id == dto.ReadingListId);\n             if (readingList == null) return BadRequest(\"Reading List does not exist\");\n+\n             var chapterIdsForVolume =\n                 (await _unitOfWork.ChapterRepository.GetChaptersAsync(dto.VolumeId)).Select(c => c.Id).ToList();\n \n@@ -419,7 +468,11 @@ public async Task<ActionResult> UpdateListByVolume(UpdateReadingListByVolumeDto\n         [HttpPost(\"update-by-chapter\")]\n         public async Task<ActionResult> UpdateListByChapter(UpdateReadingListByChapterDto dto)\n         {\n-            var user = await _unitOfWork.UserRepository.GetUserWithReadingListsByUsernameAsync(User.GetUsername());\n+            var user = await UserHasReadingListAccess(dto.ReadingListId);\n+            if (user == null)\n+            {\n+                return BadRequest(\"You do not have permissions on this reading list or the list doesn't exist\");\n+            }\n             var readingList = user.ReadingLists.SingleOrDefault(l => l.Id == dto.ReadingListId);\n             if (readingList == null) return BadRequest(\"Reading List does not exist\");\n "
        },
        {
          "filename": "API/Controllers/ThemeController.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -24,6 +24,7 @@ public ThemeController(IUnitOfWork unitOfWork, IThemeService themeService, ITask\n         _taskScheduler = taskScheduler;\n     }\n \n+    [AllowAnonymous]\n     [HttpGet]\n     public async Task<ActionResult<IEnumerable<SiteThemeDto>>> GetThemes()\n     {"
        },
        {
          "filename": "API/Controllers/UploadController.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -59,6 +59,8 @@ public async Task<ActionResult<string>> GetImageFromFile(UploadUrlDto dto)\n                 if (string.IsNullOrEmpty(path) || !_directoryService.FileSystem.File.Exists(path))\n                     return BadRequest($\"Could not download file\");\n \n+                if (!await _imageService.IsImage(path)) return BadRequest(\"Url does not return a valid image\");\n+\n                 return $\"coverupload_{dateString}.{format}\";\n             }\n             catch (FlurlHttpException ex)"
        },
        {
          "filename": "API/Data/Repositories/ReadingListRepository.cs",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -17,7 +17,7 @@ public interface IReadingListRepository\n     Task<IEnumerable<ReadingListItemDto>> GetReadingListItemDtosByIdAsync(int readingListId, int userId);\n     Task<ReadingListDto> GetReadingListDtoByIdAsync(int readingListId, int userId);\n     Task<IEnumerable<ReadingListItemDto>> AddReadingProgressModifiers(int userId, IList<ReadingListItemDto> items);\n-    Task<ReadingListDto> GetReadingListDtoByTitleAsync(string title);\n+    Task<ReadingListDto> GetReadingListDtoByTitleAsync(int userId, string title);\n     Task<IEnumerable<ReadingListItem>> GetReadingListItemsByIdAsync(int readingListId);\n \n     Task<IEnumerable<ReadingListDto>> GetReadingListDtosForSeriesAndUserAsync(int userId, int seriesId,\n@@ -211,10 +211,10 @@ public async Task<IEnumerable<ReadingListItemDto>> AddReadingProgressModifiers(i\n         return items;\n     }\n \n-    public async Task<ReadingListDto> GetReadingListDtoByTitleAsync(string title)\n+    public async Task<ReadingListDto> GetReadingListDtoByTitleAsync(int userId, string title)\n     {\n         return await _context.ReadingList\n-            .Where(r => r.Title.Equals(title))\n+            .Where(r => r.Title.Equals(title) && r.AppUserId == userId)\n             .ProjectTo<ReadingListDto>(_mapper.ConfigurationProvider)\n             .SingleOrDefaultAsync();\n     }"
        },
        {
          "filename": "API/Extensions/IdentityServiceExtensions.cs",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -1,4 +1,5 @@\n-\ufeffusing System.Text;\n+\ufeffusing System;\n+using System.Text;\n using System.Threading.Tasks;\n using API.Constants;\n using API.Data;\n@@ -32,6 +33,11 @@ public static IServiceCollection AddIdentityServices(this IServiceCollection ser\n                     opt.Password.RequiredLength = 6;\n \n                     opt.SignIn.RequireConfirmedEmail = true;\n+\n+                    opt.Lockout.AllowedForNewUsers = true;\n+                    opt.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(10);\n+                    opt.Lockout.MaxFailedAccessAttempts = 5;\n+\n                 })\n                 .AddTokenProvider<DataProtectorTokenProvider<AppUser>>(TokenOptions.DefaultProvider)\n                 .AddRoles<AppRole>()"
        },
        {
          "filename": "API/Services/ImageService.cs",
          "status": "modified",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -27,6 +27,8 @@ public interface IImageService\n     /// <param name=\"filePath\">Full path to the image to convert</param>\n     /// <returns>File of written webp image</returns>\n     Task<string> ConvertToWebP(string filePath, string outputPath);\n+\n+    Task<bool> IsImage(string filePath);\n }\n \n public class ImageService : IImageService\n@@ -115,6 +117,23 @@ public async Task<string> ConvertToWebP(string filePath, string outputPath)\n         return outputFile;\n     }\n \n+    public async Task<bool> IsImage(string filePath)\n+    {\n+        try\n+        {\n+            var info = await SixLabors.ImageSharp.Image.IdentifyAsync(filePath);\n+            if (info == null) return false;\n+\n+            return true;\n+        }\n+        catch (Exception ex)\n+        {\n+            /* Swallow Exception */\n+        }\n+\n+        return false;\n+    }\n+\n \n     /// <inheritdoc />\n     public string CreateThumbnailFromBase64(string encodedImage, string fileName)"
        },
        {
          "filename": "Kavita.Common/Kavita.Common.csproj",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -4,7 +4,7 @@\n         <TargetFramework>net6.0</TargetFramework>\n         <Company>kavitareader.com</Company>\n         <Product>Kavita</Product>\n-        <AssemblyVersion>0.5.4.0</AssemblyVersion>\n+        <AssemblyVersion>0.5.4.1</AssemblyVersion>\n         <NeutralLanguage>en</NeutralLanguage>\n     </PropertyGroup>\n "
        },
        {
          "filename": "README.md",
          "status": "modified",
          "additions": 5,
          "deletions": 2,
          "patch": "@@ -21,12 +21,12 @@ your reading collection with your friends and family!\n - [x] Serve up Manga/Webtoons/Comics (cbr, cbz, zip/rar, 7zip, raw images) and Books (epub, pdf)\n - [x] First class responsive readers that work great on any device (phone, tablet, desktop)\n - [x] Dark mode and customizable theming support\n-- [ ] Provide hooks into metadata providers to fetch metadata for Comics, Manga, and Books\n+- [ ] Provide a plugin system to allow external metadata integration and scrobbling for read status, ratings, and reviews\n - [x] Metadata should allow for collections, want to read integration from 3rd party services, genres.\n - [x] Ability to manage users, access, and ratings\n-- [ ] Ability to sync ratings and reviews to external services\n - [x] Fully Accessible with active accessibility audits\n - [x] Dedicated webtoon reading mode\n+- [ ] Full localization support\n - [ ] And so much [more...](https://github.com/Kareadita/Kavita/projects)\n \n ## Support\n@@ -93,6 +93,9 @@ Thank you to [<img src=\"/Logo/jetbrains.svg\" alt=\"\" width=\"32\"> JetBrains](http:\n ## Palace-Designs\n We would like to extend a big thank you to [<img src=\"/Logo/hosting-sponsor.png\" alt=\"\" width=\"128\">](https://www.palace-designs.com/) who hosts our infrastructure pro-bono.\n \n+## Huntr\n+We would like to extend a big thank you to [Huntr](https://huntr.dev/repos/kareadita/kavita) who has worked with Kavita in reporting security vulnerabilities. If you are interested in \n+being paid to help secure Kavita, please give them a try.\n \n ### License\n "
        },
        {
          "filename": "SECURITY.md",
          "status": "added",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -0,0 +1,10 @@\n+# Security Policy\n+\n+## Supported Versions\n+\n+Security is maintained on latest stable version only. \n+\n+## Reporting a Vulnerability\n+\n+\n+Please reach out to majora2007 via our Discord or you can (and should) report your vulnerability via [Huntr](https://huntr.dev/repos/kareadita/kavita)."
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 6,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d880c1690c9b250a444a5db4464574ef224d803c",
            "date": "2025-01-03T21:17:00Z",
            "author_login": "OrioleNix"
          },
          {
            "sha": "8c87523c625557bb71ed3217006b7bde439088ee",
            "date": "2025-01-03T20:45:30Z",
            "author_login": "majora2007"
          },
          {
            "sha": "b93bfa49b0dbecf0d556106bbe928ea64f91ab3b",
            "date": "2025-01-03T20:44:46Z",
            "author_login": "DieselTech"
          },
          {
            "sha": "6ae9cbf4aa9be398d096547e1e024198c1df6bec",
            "date": "2024-12-11T00:49:50Z",
            "author_login": "majora2007"
          },
          {
            "sha": "a8144a1d3ed578e9e2f6162e7400391920e1728f",
            "date": "2024-12-11T00:49:08Z",
            "author_login": "majora2007"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-918",
    "description": "Server-Side Request Forgery (SSRF) in GitHub repository kareadita/kavita prior to 0.5.4.1.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-08-10T16:15:08.423",
    "last_modified": "2024-11-21T07:01:38.670",
    "fix_date": "2022-08-08T20:22:38Z"
  },
  "references": [
    {
      "url": "https://github.com/kareadita/kavita/commit/9c31f7e7c81b919923cb2e3857439ec0d16243e4",
      "source": "security@huntr.dev",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/95e7c181-9d80-4428-aebf-687ac55a9216",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/kareadita/kavita/commit/9c31f7e7c81b919923cb2e3857439ec0d16243e4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/95e7c181-9d80-4428-aebf-687ac55a9216",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:14.208686",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "Kavita",
    "owner": "kareadita",
    "created_at": "2020-12-12T22:23:54Z",
    "updated_at": "2025-01-14T03:43:25Z",
    "pushed_at": "2025-01-14T12:57:46Z",
    "size": 186456,
    "stars": 6931,
    "forks": 366,
    "open_issues": 176,
    "watchers": 6931,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "C#": 3400726,
      "TypeScript": 1501314,
      "HTML": 700558,
      "SCSS": 156696,
      "Shell": 8899,
      "JavaScript": 5479,
      "COBOL": 3544,
      "Dockerfile": 1045,
      "Python": 870
    },
    "commit_activity": {
      "total_commits_last_year": 284,
      "avg_commits_per_week": 5.461538461538462,
      "days_active_last_year": 96
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-14T13:05:25.251217"
  }
}