{
  "cve_id": "CVE-2022-2888",
  "github_data": {
    "repository": "octoprint/octoprint",
    "fix_commit": "40e6217ac1a85cc5ed592873ae49db01d3005da4",
    "related_commits": [
      "40e6217ac1a85cc5ed592873ae49db01d3005da4",
      "40e6217ac1a85cc5ed592873ae49db01d3005da4"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "40e6217ac1a85cc5ed592873ae49db01d3005da4",
      "commit_date": "2022-09-01T10:45:57Z",
      "author": {
        "login": "foosel",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "\ud83d\udd12 Make session handling more secure",
        "length": 1703,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 203,
        "additions": 175,
        "deletions": 28
      },
      "files": [
        {
          "filename": "src/octoprint/access/users.py",
          "status": "modified",
          "additions": 27,
          "deletions": 10,
          "patch": "@@ -127,11 +127,9 @@ def _cleanup_sessions(self):\n         for session, user in list(self._session_users_by_session.items()):\n             if not isinstance(user, SessionUser):\n                 continue\n-            if user.created + (24 * 60 * 60) < time.monotonic():\n+            if user.touched + (15 * 60) < time.monotonic():\n                 self._logger.info(\n-                    \"Cleaning up user session {} for user {}\".format(\n-                        session, user.get_id()\n-                    )\n+                    f\"Cleaning up user session {session} for user {user.get_id()}\"\n                 )\n                 self.logout_user(user, stale=True)\n \n@@ -176,6 +174,9 @@ def check_password(self, username, password):\n                 # old hash doesn't match either, wrong password\n                 return False\n \n+    def signature_key_for_user(self, username, salt=None):\n+        return self.create_password_hash(username, salt=salt)\n+\n     def add_user(self, username, password, active, permissions, groups, overwrite=False):\n         pass\n \n@@ -227,29 +228,38 @@ def remove_user(self, username):\n             del self._sessionids_by_userid[username]\n \n     def validate_user_session(self, userid, session):\n+        self._cleanup_sessions()\n+\n         if session in self._session_users_by_session:\n             user = self._session_users_by_session[session]\n             return userid == user.get_id()\n \n         return False\n \n-    def find_user(self, userid=None, session=None):\n+    def find_user(self, userid=None, session=None, fresh=False):\n+        self._cleanup_sessions()\n+\n         if session is not None and session in self._session_users_by_session:\n             user = self._session_users_by_session[session]\n             if userid is None or userid == user.get_id():\n+                user.touch()\n                 return user\n \n         return None\n \n     def find_sessions_for(self, matcher):\n+        self._cleanup_sessions()\n+\n         result = []\n         for user in self.get_all_users():\n             if matcher(user):\n                 try:\n                     session_ids = self._sessionids_by_userid[user.get_id()]\n                     for session_id in session_ids:\n                         try:\n-                            result.append(self._session_users_by_session[session_id])\n+                            session_user = self._session_users_by_session[session_id]\n+                            session_user.touch()\n+                            result.append(session_user)\n                         except KeyError:\n                             # unknown session after all\n                             continue\n@@ -780,6 +790,14 @@ def change_user_password(self, username, password):\n             self._dirty = True\n             self._save()\n \n+            self._trigger_on_user_modified(user)\n+\n+    def signature_key_for_user(self, username, salt=None):\n+        if username not in self._users:\n+            raise UnknownUser(username)\n+        user = self._users[username]\n+        return UserManager.create_password_hash(username + user._passwordHash, salt=salt)\n+\n     def change_user_setting(self, username, key, value):\n         if username not in self._users:\n             raise UnknownUser(username)\n@@ -845,10 +863,10 @@ def remove_user(self, username):\n         self._dirty = True\n         self._save()\n \n-    def find_user(self, userid=None, apikey=None, session=None):\n+    def find_user(self, userid=None, apikey=None, session=None, fresh=False):\n         user = UserManager.find_user(self, userid=userid, session=session)\n \n-        if user is not None:\n+        if user is not None or (session and fresh):\n             return user\n \n         if userid is not None:\n@@ -1383,8 +1401,7 @@ def __init__(self, user):\n         wrapt.ObjectProxy.__init__(self, user)\n \n         self._self_session = \"\".join(\"%02X\" % z for z in bytes(uuid.uuid4().bytes))\n-        self._self_created = time.monotonic()\n-        self._self_touched = time.monotonic()\n+        self._self_created = self._self_touched = time.monotonic()\n \n     @property\n     def session(self):"
        },
        {
          "filename": "src/octoprint/server/__init__.py",
          "status": "modified",
          "additions": 18,
          "deletions": 3,
          "patch": "@@ -130,7 +130,7 @@\n     loginFromApiKeyRequestHandler,\n     requireLoginRequestHandler,\n )\n-from octoprint.server.util.flask import PreemptiveCache\n+from octoprint.server.util.flask import PreemptiveCache, validate_session_signature\n from octoprint.settings import settings\n \n VERSION = __version__\n@@ -187,12 +187,25 @@ def load_user(id):\n     else:\n         sessionid = None\n \n+    if session and \"usersession.signature\" in session:\n+        sessionsig = session[\"usersession.signature\"]\n+    else:\n+        sessionsig = \"\"\n+\n     if sessionid:\n-        user = userManager.find_user(userid=id, session=sessionid)\n+        # session[\"_fresh\"] is False if the session comes from a remember me cookie,\n+        # True if it came from a use of the login dialog\n+        user = userManager.find_user(\n+            userid=id, session=sessionid, fresh=session.get(\"_fresh\", False)\n+        )\n     else:\n         user = userManager.find_user(userid=id)\n \n-    if user and user.is_active:\n+    if (\n+        user\n+        and user.is_active\n+        and (not sessionid or validate_session_signature(sessionsig, id, sessionid))\n+    ):\n         return user\n \n     return None\n@@ -1366,7 +1379,9 @@ def _setup_app(self, app):\n \n         app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n         app.config[\"JSONIFY_PRETTYPRINT_REGULAR\"] = False\n+        app.config[\"REMEMBER_COOKIE_DURATION\"] = 90 * 24 * 60 * 60  # 90 days\n         app.config[\"REMEMBER_COOKIE_HTTPONLY\"] = True\n+        # REMEMBER_COOKIE_SECURE will be taken care of by our custom cookie handling\n \n         # we must not set this before TEMPLATES_AUTO_RELOAD is set to True or that won't take\n         app.debug = self._debug"
        },
        {
          "filename": "src/octoprint/server/api/__init__.py",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -38,6 +38,7 @@\n     limit,\n     no_firstrun_access,\n     passive_login,\n+    session_signature,\n )\n from octoprint.settings import settings as s\n from octoprint.settings import valid_boolean_trues\n@@ -312,6 +313,9 @@ def login():\n \n                 user = octoprint.server.userManager.login_user(user)\n                 session[\"usersession.id\"] = user.session\n+                session[\"usersession.signature\"] = session_signature(\n+                    username, user.session\n+                )\n                 g.user = user\n \n                 login_user(user, remember=remember)"
        },
        {
          "filename": "src/octoprint/server/util/flask.py",
          "status": "modified",
          "additions": 91,
          "deletions": 7,
          "patch": "@@ -5,11 +5,13 @@\n __copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n \n import functools\n+import hashlib\n+import hmac\n import logging\n import os\n import threading\n import time\n-from datetime import datetime\n+from datetime import datetime, timedelta\n from typing import Union\n \n import flask\n@@ -23,6 +25,9 @@\n import webassets.updater\n import webassets.utils\n from cachelib import BaseCache\n+from flask import current_app\n+from flask_login import COOKIE_NAME as REMEMBER_COOKIE_NAME\n+from flask_login.utils import decode_cookie, encode_cookie\n from werkzeug.local import LocalProxy\n from werkzeug.utils import cached_property\n \n@@ -422,6 +427,49 @@ def host_to_server_and_port(host, scheme):\n # ~~ request and response versions\n \n \n+def encode_remember_me_cookie(value):\n+    from octoprint.server import userManager\n+\n+    name = value.split(\"|\")[0]\n+    try:\n+        remember_key = userManager.signature_key_for_user(\n+            name, salt=current_app.config[\"SECRET_KEY\"]\n+        )\n+        timestamp = datetime.utcnow().timestamp()\n+        return encode_cookie(f\"{name}|{timestamp}\", key=remember_key)\n+    except Exception:\n+        pass\n+\n+    return \"\"\n+\n+\n+def decode_remember_me_cookie(value):\n+    from octoprint.server import userManager\n+\n+    parts = value.split(\"|\")\n+    if len(parts) == 3:\n+        name, created, _ = parts\n+\n+        try:\n+            # valid signature?\n+            signature_key = userManager.signature_key_for_user(\n+                name, salt=current_app.config[\"SECRET_KEY\"]\n+            )\n+            cookie = decode_cookie(value, key=signature_key)\n+            if cookie:\n+                # still valid?\n+                if (\n+                    datetime.fromtimestamp(float(created))\n+                    + timedelta(seconds=current_app.config[\"REMEMBER_COOKIE_DURATION\"])\n+                    > datetime.utcnow()\n+                ):\n+                    return encode_cookie(name)\n+        except Exception:\n+            pass\n+\n+    raise ValueError(\"Invalid remember me cookie\")\n+\n+\n class OctoPrintFlaskRequest(flask.Request):\n     environment_wrapper = staticmethod(lambda x: x)\n \n@@ -437,10 +485,23 @@ def cookies(self):\n         result = {}\n         desuffixed = {}\n         for key, value in cookies.items():\n-            if key.endswith(self.cookie_suffix):\n-                desuffixed[key[: -len(self.cookie_suffix)]] = value\n-            else:\n-                result[key] = value\n+\n+            def process_value(k, v):\n+                if k == current_app.config.get(\n+                    \"REMEMBER_COOKIE_NAME\", REMEMBER_COOKIE_NAME\n+                ):\n+                    return decode_remember_me_cookie(v)\n+                return v\n+\n+            try:\n+                if key.endswith(self.cookie_suffix):\n+                    key = key[: -len(self.cookie_suffix)]\n+                    desuffixed[key] = process_value(key, value)\n+                else:\n+                    result[key] = process_value(key, value)\n+            except ValueError:\n+                # ignore broken cookies\n+                pass\n \n         result.update(desuffixed)\n         return result\n@@ -471,7 +532,7 @@ def cookie_suffix(self):\n \n \n class OctoPrintFlaskResponse(flask.Response):\n-    def set_cookie(self, key, *args, **kwargs):\n+    def set_cookie(self, key, value=\"\", *args, **kwargs):\n         # restrict cookie path to script root\n         kwargs[\"path\"] = flask.request.script_root + kwargs.get(\"path\", \"/\")\n \n@@ -490,9 +551,13 @@ def set_cookie(self, key, *args, **kwargs):\n         # set secure if necessary\n         kwargs[\"secure\"] = settings().getBoolean([\"server\", \"cookies\", \"secure\"])\n \n+        # tie account properties to remember me cookie (e.g. current password hash)\n+        if key == current_app.config.get(\"REMEMBER_COOKIE_NAME\", REMEMBER_COOKIE_NAME):\n+            value = encode_remember_me_cookie(value)\n+\n         # add request specific cookie suffix to name\n         flask.Response.set_cookie(\n-            self, key + flask.request.cookie_suffix, *args, **kwargs\n+            self, key + flask.request.cookie_suffix, value=value, *args, **kwargs\n         )\n \n     def delete_cookie(self, key, path=\"/\", domain=None):\n@@ -608,6 +673,9 @@ def login(u):\n         )\n         if hasattr(u, \"session\"):\n             flask.session[\"usersession.id\"] = u.session\n+            flask.session[\"usersession.signature\"] = session_signature(\n+                u.get_id(), u.session\n+            )\n         flask.g.user = u\n \n         eventManager().fire(Events.USER_LOGGED_IN, payload={\"username\": u.get_id()})\n@@ -1832,3 +1900,19 @@ def default(self, obj):\n             return JsonEncoding.encode(obj)\n         except TypeError:\n             return flask.json.JSONEncoder.default(self, obj)\n+\n+\n+##~~ Session signing\n+\n+\n+def session_signature(user, session):\n+    from octoprint.server import userManager\n+\n+    key = userManager.signature_key_for_user(user, salt=current_app.config[\"SECRET_KEY\"])\n+    return hmac.new(\n+        key.encode(\"utf-8\"), session.encode(\"utf-8\"), hashlib.sha512\n+    ).hexdigest()\n+\n+\n+def validate_session_signature(sig, user, session):\n+    return hmac.compare_digest(sig, session_signature(user, session))"
        },
        {
          "filename": "src/octoprint/server/util/sockjs.py",
          "status": "modified",
          "additions": 15,
          "deletions": 1,
          "patch": "@@ -21,9 +21,10 @@\n import octoprint.vendor.sockjs.tornado.util\n from octoprint.access.groups import GroupChangeListener\n from octoprint.access.permissions import Permissions\n-from octoprint.access.users import LoginStatusListener\n+from octoprint.access.users import LoginStatusListener, SessionUser\n from octoprint.events import Events\n from octoprint.settings import settings\n+from octoprint.util import RepeatedTimer\n from octoprint.util.json import dumps as json_dumps\n from octoprint.util.version import get_python_version_string\n \n@@ -173,13 +174,24 @@ def __init__(\n         self._subscriptions_active = False\n         self._subscriptions = {\"state\": False, \"plugins\": [], \"events\": []}\n \n+        self._keep_alive = RepeatedTimer(\n+            60, self._keep_alive_callback, condition=lambda: self._authed\n+        )\n+\n     @staticmethod\n     def _get_remote_address(info):\n         forwarded_for = info.headers.get(\"X-Forwarded-For\")\n         if forwarded_for is not None:\n             return forwarded_for.split(\",\")[0]\n         return info.ip\n \n+    def _keep_alive_callback(self):\n+        if not self._authed:\n+            return\n+        if not isinstance(self._user, SessionUser):\n+            return\n+        self._user.touch()\n+\n     def __str__(self):\n         if self._remoteAddress:\n             return f\"{self!r} connected to {self._remoteAddress}\"\n@@ -716,6 +728,8 @@ def _on_login(self, user):\n         )\n         self._authed = True\n \n+        self._keep_alive.start()\n+\n         for name, hook in self._authed_hooks.items():\n             try:\n                 hook(self, self._user)"
        },
        {
          "filename": "src/octoprint/static/js/app/viewmodels/usersettings.js",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -88,7 +88,7 @@ $(function () {\n \n             self.userSettingsDialog.trigger(\"beforeSave\");\n \n-            function process() {\n+            function saveSettings() {\n                 var settings = {\n                     interface: {\n                         language: self.interface_language()\n@@ -110,15 +110,15 @@ $(function () {\n                         self.access_currentPassword()\n                     )\n                     .done(function () {\n-                        process();\n+                        saveSettings();\n                     })\n                     .fail(function (xhr) {\n                         if (xhr.status === 403) {\n                             self.access_currentPasswordMismatch(true);\n                         }\n                     });\n             } else {\n-                process();\n+                saveSettings();\n             }\n         };\n "
        },
        {
          "filename": "src/octoprint/templates/dialogs/usersettings/access.jinja2",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -24,6 +24,9 @@\n                 <span class=\"help-inline\" data-bind=\"visible: passwordMismatch()\">{{ _('Passwords do not match') }}</span>\n             </div>\n         </div>\n+        <p>{% trans %}\n+            Please note that you will be <strong>logged out immediately</strong> after changing your password and asked to login again.\n+        {% endtrans %}</p>\n     </fieldset>\n     <fieldset>\n         <legend>{{ _('API Key') }}</legend>"
        },
        {
          "filename": "tests/server/util/test_flask.py",
          "status": "modified",
          "additions": 14,
          "deletions": 4,
          "patch": "@@ -10,6 +10,7 @@\n import unittest\n from unittest import mock\n \n+import flask\n from ddt import data, ddt, unpack\n \n from octoprint.server.util.flask import (\n@@ -424,6 +425,9 @@ class OctoPrintFlaskRequestTest(unittest.TestCase):\n     def setUp(self):\n         self.orig_environment_wrapper = OctoPrintFlaskRequest.environment_wrapper\n \n+        self.app = flask.Flask(\"testapp\")\n+        self.app.config[\"SECRET_KEY\"] = \"secret\"\n+\n     def tearDown(self):\n         OctoPrintFlaskRequest.environment_wrapper = staticmethod(\n             self.orig_environment_wrapper\n@@ -470,7 +474,8 @@ def test_cookies(self):\n \n         request = OctoPrintFlaskRequest(environ)\n \n-        cookies = request.cookies\n+        with self.app.app_context():\n+            cookies = request.cookies\n         self.assertDictEqual(\n             {\n                 \"postfixed\": \"postfixed_value\",\n@@ -495,6 +500,9 @@ def setUp(self):\n         self.settings = mock.MagicMock()\n         self.settings_getter.return_value = self.settings\n \n+        self.app = flask.Flask(\"testapp\")\n+        self.app.config[\"SECRET_KEY\"] = \"secret\"\n+\n     def tearDown(self):\n         self.settings_patcher.stop()\n \n@@ -545,13 +553,14 @@ def test_cookie_set_and_delete(\n \n                 # test set_cookie\n                 with mock.patch(\"flask.Response.set_cookie\") as set_cookie_mock:\n-                    response.set_cookie(\"some_key\", \"some_value\", **kwargs)\n+                    with self.app.app_context():\n+                        response.set_cookie(\"some_key\", \"some_value\", **kwargs)\n \n                     # set_cookie should have key and path values adjusted\n                     set_cookie_mock.assert_called_once_with(\n                         response,\n                         \"some_key\" + expected_suffix,\n-                        \"some_value\",\n+                        value=\"some_value\",\n                         path=expected_path_set,\n                         secure=secure,\n                         samesite=expected_samesite,\n@@ -560,7 +569,8 @@ def test_cookie_set_and_delete(\n                 # test delete_cookie\n                 with mock.patch(\"flask.Response.set_cookie\") as set_cookie_mock:\n                     with mock.patch(\"flask.Response.delete_cookie\") as delete_cookie_mock:\n-                        response.delete_cookie(\"some_key\", **kwargs)\n+                        with self.app.app_context():\n+                            response.delete_cookie(\"some_key\", **kwargs)\n \n                         # delete_cookie internally calls set_cookie - so our delete_cookie call still uses the non modified\n                         # key and path values, set_cookie will translate those (as tested above)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 7,
        "max_directory_depth": 6
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d79a0d20f3f1c7f2edb56dedda3b70267a937e65",
            "date": "2025-01-07T16:26:18Z",
            "author_login": "foosel"
          },
          {
            "sha": "b47f001b81a042069bf8c5f51a28a2642aa02497",
            "date": "2025-01-07T16:17:19Z",
            "author_login": "foosel"
          },
          {
            "sha": "51eae276d8c15208dd9cbe4a9da4b8a688f80a14",
            "date": "2025-01-07T15:55:37Z",
            "author_login": "foosel"
          },
          {
            "sha": "2a2a9921e6b79da220d3e66fde43cacd62a5a4ad",
            "date": "2024-11-06T08:34:42Z",
            "author_login": "foosel"
          },
          {
            "sha": "9701568a6f3dcf356e5e800a49da6ffac128cae5",
            "date": "2024-11-04T09:42:39Z",
            "author_login": "foosel"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.4,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N",
    "cwe_id": "CWE-613",
    "description": "If an attacker comes into the possession of a victim's OctoPrint session cookie through whatever means, the attacker can use this cookie to authenticate as long as the victim's account exists.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-09-21T12:15:09.923",
    "last_modified": "2024-11-21T07:01:52.543",
    "fix_date": "2022-09-01T10:45:57Z"
  },
  "references": [
    {
      "url": "https://github.com/octoprint/octoprint/commit/40e6217ac1a85cc5ed592873ae49db01d3005da4",
      "source": "security@huntr.dev",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/d27d232b-2578-4b32-b3b4-74aabdadf629",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/octoprint/octoprint/commit/40e6217ac1a85cc5ed592873ae49db01d3005da4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/d27d232b-2578-4b32-b3b4-74aabdadf629",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:41.266343",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "OctoPrint",
    "owner": "octoprint",
    "created_at": "2012-12-31T12:20:57Z",
    "updated_at": "2025-01-24T15:32:16Z",
    "pushed_at": "2025-01-22T00:15:47Z",
    "size": 56452,
    "stars": 8422,
    "forks": 1674,
    "open_issues": 270,
    "watchers": 8422,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "devel",
      "maintenance",
      "master",
      "rc/devel",
      "rc/maintenance"
    ],
    "languages": {
      "Python": 3030267,
      "JavaScript": 1731194,
      "G-code": 1651044,
      "Jinja": 479315,
      "HTML": 51198,
      "Less": 49667,
      "CSS": 7021
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "agpl-3.0"
    },
    "collected_at": "2025-01-26T07:48:53.933676"
  }
}