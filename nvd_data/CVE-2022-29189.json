{
  "cve_id": "CVE-2022-29189",
  "github_data": {
    "repository": "pion/dtls",
    "fix_commit": "a6397ff7282bc56dc37a68ea9211702edb4de1de",
    "related_commits": [
      "a6397ff7282bc56dc37a68ea9211702edb4de1de",
      "a6397ff7282bc56dc37a68ea9211702edb4de1de"
    ],
    "patch_url": "https://github.com/pion/dtls/commit/a6397ff7282bc56dc37a68ea9211702edb4de1de.patch",
    "fix_commit_details": {
      "sha": "a6397ff7282bc56dc37a68ea9211702edb4de1de",
      "commit_date": "2022-05-10T19:36:31Z",
      "author": {
        "login": "Sean-Der",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Add limit to fragmentBuffer",
        "length": 201,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 37,
        "additions": 36,
        "deletions": 1
      },
      "files": [
        {
          "filename": "errors.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -62,6 +62,7 @@ var (\n \terrSequenceNumberOverflow            = &InternalError{Err: errors.New(\"sequence number overflow\")}                        //nolint:goerr113\n \terrInvalidFSMTransition              = &InternalError{Err: errors.New(\"invalid state machine transition\")}                //nolint:goerr113\n \terrFailedToAccessPoolReadBuffer      = &InternalError{Err: errors.New(\"failed to access pool read buffer\")}               //nolint:goerr113\n+\terrFragmentBufferOverflow            = &InternalError{Err: errors.New(\"fragment buffer overflow\")}                        //nolint:goerr113\n )\n \n // FatalError indicates that the DTLS connection is no longer available."
        },
        {
          "filename": "fragment_buffer.go",
          "status": "modified",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -6,6 +6,9 @@ import (\n \t\"github.com/pion/dtls/v2/pkg/protocol/recordlayer\"\n )\n \n+// 2 megabytes\n+const fragmentBufferMaxSize = 2000000\n+\n type fragment struct {\n \trecordLayerHeader recordlayer.Header\n \thandshakeHeader   handshake.Header\n@@ -23,10 +26,25 @@ func newFragmentBuffer() *fragmentBuffer {\n \treturn &fragmentBuffer{cache: map[uint16][]*fragment{}}\n }\n \n+// current total size of buffer\n+func (f *fragmentBuffer) size() int {\n+\tsize := 0\n+\tfor i := range f.cache {\n+\t\tfor j := range f.cache[i] {\n+\t\t\tsize += len(f.cache[i][j].data)\n+\t\t}\n+\t}\n+\treturn size\n+}\n+\n // Attempts to push a DTLS packet to the fragmentBuffer\n // when it returns true it means the fragmentBuffer has inserted and the buffer shouldn't be handled\n // when an error returns it is fatal, and the DTLS connection should be stopped\n func (f *fragmentBuffer) push(buf []byte) (bool, error) {\n+\tif f.size()+len(buf) >= fragmentBufferMaxSize {\n+\t\treturn false, errFragmentBufferOverflow\n+\t}\n+\n \tfrag := new(fragment)\n \tif err := frag.recordLayerHeader.Unmarshal(buf); err != nil {\n \t\treturn false, err"
        },
        {
          "filename": "fragment_buffer_test.go",
          "status": "modified",
          "additions": 17,
          "deletions": 1,
          "patch": "@@ -1,6 +1,7 @@\n package dtls\n \n import (\n+\t\"errors\"\n \t\"reflect\"\n \t\"testing\"\n )\n@@ -57,7 +58,7 @@ func TestFragmentBuffer(t *testing.T) {\n \t\t\tEpoch: 0,\n \t\t},\n \t\t{\n-\t\t\tName: \"Multiple Handshakes in Signle Fragment\",\n+\t\t\tName: \"Multiple Handshakes in Single Fragment\",\n \t\t\tIn: [][]byte{\n \t\t\t\t{\n \t\t\t\t\t0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x30, /* record header */\n@@ -113,3 +114,18 @@ func TestFragmentBuffer(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestFragmentBuffer_Overflow(t *testing.T) {\n+\tfragmentBuffer := newFragmentBuffer()\n+\n+\t// Push a buffer that doesn't exceed size limits\n+\tif _, err := fragmentBuffer.push([]byte{0x16, 0xfe, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00}); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// Allocate a buffer that exceeds cache size\n+\tlargeBuffer := make([]byte, fragmentBufferMaxSize)\n+\tif _, err := fragmentBuffer.push(largeBuffer); !errors.Is(err, errFragmentBufferOverflow) {\n+\t\tt.Fatalf(\"Pushing a large buffer returned (%s) expected(%s)\", err, errFragmentBufferOverflow)\n+\t}\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "1e4ae60e28516c475e999b389bcbe96a168c4470",
            "date": "2024-12-19T01:22:36Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "ceb84588accbb1b0ca0a51e807cc0062278c6d38",
            "date": "2024-12-12T03:18:39Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "4e34db5ca6566b816295c74f5e547fc260a69749",
            "date": "2024-12-01T04:41:51Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "02434c73b48f63397b58dc1f7615b62575f0e93e",
            "date": "2024-12-01T00:37:09Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "b3e02c4ba7e207c6dfce4e490f30fe09c8c926be",
            "date": "2024-11-04T20:14:27Z",
            "author_login": "renovate[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-120",
    "description": "Pion DTLS is a Go implementation of Datagram Transport Layer Security. Prior to version 2.1.4, a buffer that was used for inbound network traffic had no upper limit. Pion DTLS would buffer all network traffic from the remote user until the handshake completes or timed out. An attacker could exploit this to cause excessive memory usage. Version 2.1.4 contains a patch for this issue. There are currently no known workarounds available.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-05-21T00:15:11.387",
    "last_modified": "2024-11-21T06:58:40.400",
    "fix_date": "2022-05-10T19:36:31Z"
  },
  "references": [
    {
      "url": "https://github.com/pion/dtls/commit/a6397ff7282bc56dc37a68ea9211702edb4de1de",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/pion/dtls/releases/tag/v2.1.4",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/pion/dtls/security/advisories/GHSA-cx94-mrg9-rq4j",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/pion/dtls/commit/a6397ff7282bc56dc37a68ea9211702edb4de1de",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/pion/dtls/releases/tag/v2.1.4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/pion/dtls/security/advisories/GHSA-cx94-mrg9-rq4j",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:07.145247",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "dtls",
    "owner": "pion",
    "created_at": "2018-10-19T05:38:21Z",
    "updated_at": "2025-01-13T08:03:16Z",
    "pushed_at": "2024-12-19T05:02:20Z",
    "size": 1403,
    "stars": 612,
    "forks": 160,
    "open_issues": 9,
    "watchers": 612,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Go": 708925,
      "Dockerfile": 270
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:50:58.128138"
  }
}