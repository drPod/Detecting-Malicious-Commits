{
  "cve_id": "CVE-2022-29217",
  "github_data": {
    "repository": "jpadilla/pyjwt",
    "fix_commit": "9c528670c455b8d948aff95ed50e22940d1ad3fc",
    "related_commits": [
      "9c528670c455b8d948aff95ed50e22940d1ad3fc",
      "9c528670c455b8d948aff95ed50e22940d1ad3fc"
    ],
    "patch_url": "https://github.com/jpadilla/pyjwt/commit/9c528670c455b8d948aff95ed50e22940d1ad3fc.patch",
    "fix_commit_details": {
      "sha": "9c528670c455b8d948aff95ed50e22940d1ad3fc",
      "commit_date": "2022-05-12T18:31:00Z",
      "author": {
        "login": "jpadilla",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-ffqj-6fqr-9h24",
        "length": 109,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 214,
        "additions": 191,
        "deletions": 23
      },
      "files": [
        {
          "filename": ".gitignore",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -60,3 +60,4 @@ target/\n \n .pytest_cache\n .mypy_cache\n+pip-wheel-metadata/"
        },
        {
          "filename": "jwt/__init__.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -25,7 +25,7 @@\n )\n from .jwks_client import PyJWKClient\n \n-__version__ = \"2.3.0\"\n+__version__ = \"2.4.0\"\n \n __title__ = \"PyJWT\"\n __description__ = \"JSON Web Token implementation in Python\""
        },
        {
          "filename": "jwt/algorithms.py",
          "status": "modified",
          "additions": 18,
          "deletions": 21,
          "patch": "@@ -9,6 +9,8 @@\n     der_to_raw_signature,\n     force_bytes,\n     from_base64url_uint,\n+    is_pem_format,\n+    is_ssh_key,\n     raw_to_der_signature,\n     to_base64url_uint,\n )\n@@ -183,14 +185,7 @@ def __init__(self, hash_alg):\n     def prepare_key(self, key):\n         key = force_bytes(key)\n \n-        invalid_strings = [\n-            b\"-----BEGIN PUBLIC KEY-----\",\n-            b\"-----BEGIN CERTIFICATE-----\",\n-            b\"-----BEGIN RSA PUBLIC KEY-----\",\n-            b\"ssh-rsa\",\n-        ]\n-\n-        if any(string_value in key for string_value in invalid_strings):\n+        if is_pem_format(key) or is_ssh_key(key):\n             raise InvalidKeyError(\n                 \"The specified key is an asymmetric key or x509 certificate and\"\n                 \" should not be used as an HMAC secret.\"\n@@ -551,26 +546,28 @@ def __init__(self, **kwargs):\n             pass\n \n         def prepare_key(self, key):\n-\n-            if isinstance(\n-                key,\n-                (Ed25519PrivateKey, Ed25519PublicKey, Ed448PrivateKey, Ed448PublicKey),\n-            ):\n-                return key\n-\n             if isinstance(key, (bytes, str)):\n                 if isinstance(key, str):\n                     key = key.encode(\"utf-8\")\n                 str_key = key.decode(\"utf-8\")\n \n                 if \"-----BEGIN PUBLIC\" in str_key:\n-                    return load_pem_public_key(key)\n-                if \"-----BEGIN PRIVATE\" in str_key:\n-                    return load_pem_private_key(key, password=None)\n-                if str_key[0:4] == \"ssh-\":\n-                    return load_ssh_public_key(key)\n+                    key = load_pem_public_key(key)\n+                elif \"-----BEGIN PRIVATE\" in str_key:\n+                    key = load_pem_private_key(key, password=None)\n+                elif str_key[0:4] == \"ssh-\":\n+                    key = load_ssh_public_key(key)\n \n-            raise TypeError(\"Expecting a PEM-formatted or OpenSSH key.\")\n+            # Explicit check the key to prevent confusing errors from cryptography\n+            if not isinstance(\n+                key,\n+                (Ed25519PrivateKey, Ed25519PublicKey, Ed448PrivateKey, Ed448PublicKey),\n+            ):\n+                raise InvalidKeyError(\n+                    \"Expecting a EllipticCurvePrivateKey/EllipticCurvePublicKey. Wrong key provided for EdDSA algorithms\"\n+                )\n+\n+            return key\n \n         def sign(self, msg, key):\n             \"\"\""
        },
        {
          "filename": "jwt/utils.py",
          "status": "modified",
          "additions": 61,
          "deletions": 0,
          "patch": "@@ -1,5 +1,6 @@\n import base64\n import binascii\n+import re\n from typing import Any, Union\n \n try:\n@@ -97,3 +98,63 @@ def raw_to_der_signature(raw_sig: bytes, curve: EllipticCurve) -> bytes:\n     s = bytes_to_number(raw_sig[num_bytes:])\n \n     return encode_dss_signature(r, s)\n+\n+\n+# Based on https://github.com/hynek/pem/blob/7ad94db26b0bc21d10953f5dbad3acfdfacf57aa/src/pem/_core.py#L224-L252\n+_PEMS = {\n+    b\"CERTIFICATE\",\n+    b\"TRUSTED CERTIFICATE\",\n+    b\"PRIVATE KEY\",\n+    b\"PUBLIC KEY\",\n+    b\"ENCRYPTED PRIVATE KEY\",\n+    b\"OPENSSH PRIVATE KEY\",\n+    b\"DSA PRIVATE KEY\",\n+    b\"RSA PRIVATE KEY\",\n+    b\"RSA PUBLIC KEY\",\n+    b\"EC PRIVATE KEY\",\n+    b\"DH PARAMETERS\",\n+    b\"NEW CERTIFICATE REQUEST\",\n+    b\"CERTIFICATE REQUEST\",\n+    b\"SSH2 PUBLIC KEY\",\n+    b\"SSH2 ENCRYPTED PRIVATE KEY\",\n+    b\"X509 CRL\",\n+}\n+\n+_PEM_RE = re.compile(\n+    b\"----[- ]BEGIN (\"\n+    + b\"|\".join(_PEMS)\n+    + b\"\"\")[- ]----\\r?\n+.+?\\r?\n+----[- ]END \\\\1[- ]----\\r?\\n?\"\"\",\n+    re.DOTALL,\n+)\n+\n+\n+def is_pem_format(key: bytes) -> bool:\n+    return bool(_PEM_RE.search(key))\n+\n+\n+# Based on https://github.com/pyca/cryptography/blob/bcb70852d577b3f490f015378c75cba74986297b/src/cryptography/hazmat/primitives/serialization/ssh.py#L40-L46\n+_CERT_SUFFIX = b\"-cert-v01@openssh.com\"\n+_SSH_PUBKEY_RC = re.compile(br\"\\A(\\S+)[ \\t]+(\\S+)\")\n+_SSH_KEY_FORMATS = [\n+    b\"ssh-ed25519\",\n+    b\"ssh-rsa\",\n+    b\"ssh-dss\",\n+    b\"ecdsa-sha2-nistp256\",\n+    b\"ecdsa-sha2-nistp384\",\n+    b\"ecdsa-sha2-nistp521\",\n+]\n+\n+\n+def is_ssh_key(key: bytes) -> bool:\n+    if any(string_value in key for string_value in _SSH_KEY_FORMATS):\n+        return True\n+\n+    ssh_pubkey_match = _SSH_PUBKEY_RC.match(key)\n+    if ssh_pubkey_match:\n+        key_type = ssh_pubkey_match.group(1)\n+        if _CERT_SUFFIX == key_type[-len(_CERT_SUFFIX) :]:\n+            return True\n+\n+    return False"
        },
        {
          "filename": "tests/test_advisory.py",
          "status": "added",
          "additions": 109,
          "deletions": 0,
          "patch": "@@ -0,0 +1,109 @@\n+import jwt\n+import pytest\n+from jwt.exceptions import InvalidKeyError\n+\n+priv_key_bytes = b'''-----BEGIN PRIVATE KEY-----\n+MC4CAQAwBQYDK2VwBCIEIIbBhdo2ah7X32i50GOzrCr4acZTe6BezUdRIixjTAdL\n+-----END PRIVATE KEY-----'''\n+\n+pub_key_bytes = b'ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIPL1I9oiq+B8crkmuV4YViiUnhdLjCp3hvy1bNGuGfNL'\n+\n+ssh_priv_key_bytes = b\"\"\"-----BEGIN EC PRIVATE KEY-----\n+MHcCAQEEIOWc7RbaNswMtNtc+n6WZDlUblMr2FBPo79fcGXsJlGQoAoGCCqGSM49\n+AwEHoUQDQgAElcy2RSSSgn2RA/xCGko79N+7FwoLZr3Z0ij/ENjow2XpUDwwKEKk\n+Ak3TDXC9U8nipMlGcY7sDpXp2XyhHEM+Rw==\n+-----END EC PRIVATE KEY-----\"\"\"\n+\n+ssh_key_bytes = b\"\"\"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBJXMtkUkkoJ9kQP8QhpKO/TfuxcKC2a92dIo/xDY6MNl6VA8MChCpAJN0w1wvVPJ4qTJRnGO7A6V6dl8oRxDPkc=\"\"\"\n+\n+\n+class TestAdvisory:\n+    def test_ghsa_ffqj_6fqr_9h24(self):\n+        # Generate ed25519 private key\n+        # private_key = ed25519.Ed25519PrivateKey.generate()\n+\n+        # Get private key bytes as they would be stored in a file\n+        # priv_key_bytes = private_key.private_bytes(\n+        #     encoding=serialization.Encoding.PEM,\n+        #     format=serialization.PrivateFormat.PKCS8,\n+        #     encryption_algorithm=serialization.NoEncryption(),\n+        # )\n+\n+        # Get public key bytes as they would be stored in a file\n+        # pub_key_bytes = private_key.public_key().public_bytes(\n+        #     encoding=serialization.Encoding.OpenSSH,\n+        #     format=serialization.PublicFormat.OpenSSH,\n+        # )\n+\n+        # Making a good jwt token that should work by signing it\n+        # with the private key\n+        # encoded_good = jwt.encode({\"test\": 1234}, priv_key_bytes, algorithm=\"EdDSA\")\n+        encoded_good = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJFZERTQSJ9.eyJ0ZXN0IjoxMjM0fQ.M5y1EEavZkHSlj9i8yi9nXKKyPBSAUhDRTOYZi3zZY11tZItDaR3qwAye8pc74_lZY3Ogt9KPNFbVOSGnUBHDg'\n+\n+        # Using HMAC with the public key to trick the receiver to think that the\n+        # public key is a HMAC secret\n+        encoded_bad = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0ZXN0IjoxMjM0fQ.6ulDpqSlbHmQ8bZXhZRLFko9SwcHrghCwh8d-exJEE4'\n+\n+        # Both of the jwt tokens are validated as valid\n+        jwt.decode(\n+            encoded_good,\n+            pub_key_bytes,\n+            algorithms=jwt.algorithms.get_default_algorithms(),\n+        )\n+\n+        with pytest.raises(InvalidKeyError):\n+            jwt.decode(\n+                encoded_bad,\n+                pub_key_bytes,\n+                algorithms=jwt.algorithms.get_default_algorithms(),\n+            )\n+\n+        # Of course the receiver should specify ed25519 algorithm to be used if\n+        # they specify ed25519 public key. However, if other algorithms are used,\n+        # the POC does not work\n+        # HMAC specifies illegal strings for the HMAC secret in jwt/algorithms.py\n+        #\n+        #        invalid_str ings = [\n+        #            b\"-----BEGIN PUBLIC KEY-----\",\n+        #            b\"-----BEGIN CERTIFICATE-----\",\n+        #            b\"-----BEGIN RSA PUBLIC KEY-----\",\n+        #            b\"ssh-rsa\",\n+        #        ]\n+        #\n+        # However, OKPAlgorithm (ed25519) accepts the following in  jwt/algorithms.py:\n+        #\n+        #                if \"-----BEGIN PUBLIC\" in str_key:\n+        #                    return load_pem_public_key(key)\n+        #                if \"-----BEGIN PRIVATE\" in str_key:\n+        #                    return load_pem_private_key(key, password=None)\n+        #                if str_key[0:4] == \"ssh-\":\n+        #                    return load_ssh_public_key(key)\n+        #\n+        # These should most likely made to match each other to prevent this behavior\n+\n+        # POC for the ecdsa-sha2-nistp256 format.\n+        # openssl ecparam -genkey -name prime256v1 -noout -out ec256-key-priv.pem\n+        # openssl ec -in ec256-key-priv.pem -pubout > ec256-key-pub.pem\n+        # ssh-keygen -y -f ec256-key-priv.pem > ec256-key-ssh.pub\n+\n+        # Making a good jwt token that should work by signing it with the private key\n+        # encoded_good = jwt.encode({\"test\": 1234}, ssh_priv_key_bytes, algorithm=\"ES256\")\n+        encoded_good = \"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0ZXN0IjoxMjM0fQ.NX42mS8cNqYoL3FOW9ZcKw8Nfq2mb6GqJVADeMA1-kyHAclilYo_edhdM_5eav9tBRQTlL0XMeu_WFE_mz3OXg\"\n+\n+        # Using HMAC with the ssh public key to trick the receiver to think that the public key is a HMAC secret\n+        # encoded_bad = jwt.encode({\"test\": 1234}, ssh_key_bytes, algorithm=\"HS256\")\n+        encoded_bad = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0ZXN0IjoxMjM0fQ.5eYfbrbeGYmWfypQ6rMWXNZ8bdHcqKng5GPr9MJZITU\"\n+\n+        # Both of the jwt tokens are validated as valid\n+        jwt.decode(\n+            encoded_good,\n+            ssh_key_bytes,\n+            algorithms=jwt.algorithms.get_default_algorithms()\n+        )\n+\n+        with pytest.raises(InvalidKeyError):\n+            jwt.decode(\n+                encoded_bad,\n+                ssh_key_bytes,\n+                algorithms=jwt.algorithms.get_default_algorithms()\n+            )"
        },
        {
          "filename": "tests/test_algorithms.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -679,7 +679,7 @@ class TestOKPAlgorithms:\n     def test_okp_ed25519_should_reject_non_string_key(self):\n         algo = OKPAlgorithm()\n \n-        with pytest.raises(TypeError):\n+        with pytest.raises(InvalidKeyError):\n             algo.prepare_key(None)\n \n         with open(key_path(\"testkey_ed25519\")) as keyfile:"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 3,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b16a49f015dc6627fd794260ff03b5ff60a9e6de",
            "date": "2025-01-14T09:09:33Z",
            "author_login": "pre-commit-ci[bot]"
          },
          {
            "sha": "565b6d95d65d8d210de5fad50e177cbd814a56de",
            "date": "2024-12-14T08:46:13Z",
            "author_login": "shuhaib-aot"
          },
          {
            "sha": "3ebbb22f30f2b1b41727b269a08b427e9a85d6bb",
            "date": "2024-11-28T03:30:29Z",
            "author_login": "jpadilla"
          },
          {
            "sha": "37748dc1e328f120aa04ec98b2a71a0af6301a24",
            "date": "2024-11-28T03:29:52Z",
            "author_login": "jpadilla"
          },
          {
            "sha": "33022c25525c1020869c71ce2a4109e44ae4ced1",
            "date": "2024-11-28T03:19:49Z",
            "author_login": "jpadilla"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-327",
    "description": "PyJWT is a Python implementation of RFC 7519. PyJWT supports multiple different JWT signing algorithms. With JWT, an attacker submitting the JWT token can choose the used signing algorithm. The PyJWT library requires that the application chooses what algorithms are supported. The application can specify `jwt.algorithms.get_default_algorithms()` to get support for all algorithms, or specify a single algorithm. The issue is not that big as `algorithms=jwt.algorithms.get_default_algorithms()` has to be used. Users should upgrade to v2.4.0 to receive a patch for this issue. As a workaround, always be explicit with the algorithms that are accepted and expected when decoding.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-05-24T15:15:07.767",
    "last_modified": "2024-11-21T06:58:44.463",
    "fix_date": "2022-05-12T18:31:00Z"
  },
  "references": [
    {
      "url": "https://github.com/jpadilla/pyjwt/commit/9c528670c455b8d948aff95ed50e22940d1ad3fc",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/jpadilla/pyjwt/releases/tag/2.4.0",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/jpadilla/pyjwt/security/advisories/GHSA-ffqj-6fqr-9h24",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/5PK7IQCBVNLYJEFTPHBBPFP72H4WUFNX/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6HIYEYZRQEP6QTHT3EHH3RGFYJIHIMAO/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/jpadilla/pyjwt/commit/9c528670c455b8d948aff95ed50e22940d1ad3fc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/jpadilla/pyjwt/releases/tag/2.4.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/jpadilla/pyjwt/security/advisories/GHSA-ffqj-6fqr-9h24",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/5PK7IQCBVNLYJEFTPHBBPFP72H4WUFNX/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6HIYEYZRQEP6QTHT3EHH3RGFYJIHIMAO/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://www.vicarius.io/vsociety/posts/risky-algorithms-algorithm-confusion-in-pyjwt-cve-2022-29217",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:07.155862",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "pyjwt",
    "owner": "jpadilla",
    "created_at": "2011-02-24T20:25:09Z",
    "updated_at": "2025-01-14T09:09:38Z",
    "pushed_at": "2025-01-14T09:09:35Z",
    "size": 1227,
    "stars": 5229,
    "forks": 694,
    "open_issues": 20,
    "watchers": 5229,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Python": 219335
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T18:04:35.252115"
  }
}