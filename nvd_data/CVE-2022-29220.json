{
  "cve_id": "CVE-2022-29220",
  "github_data": {
    "repository": "fastify/github-action-merge-dependabot",
    "fix_commit": "309f39539c5d918d8a47075587aa8720a9c127f7",
    "related_commits": [
      "309f39539c5d918d8a47075587aa8720a9c127f7",
      "309f39539c5d918d8a47075587aa8720a9c127f7"
    ],
    "patch_url": "https://github.com/fastify/github-action-merge-dependabot/commit/309f39539c5d918d8a47075587aa8720a9c127f7.patch",
    "fix_commit_details": {
      "sha": "309f39539c5d918d8a47075587aa8720a9c127f7",
      "commit_date": "2022-05-26T10:13:06Z",
      "author": {
        "login": "ianlnf",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-v5vr-h3xq-8v6w",
        "length": 1077,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 799,
        "additions": 797,
        "deletions": 2
      },
      "files": [
        {
          "filename": "dist/105.index.js",
          "status": "added",
          "additions": 315,
          "deletions": 0,
          "patch": "@@ -0,0 +1,315 @@\n+\"use strict\";\n+exports.id = 105;\n+exports.ids = [105];\n+exports.modules = {\n+\n+/***/ 8770:\n+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n+\n+\n+const fs = __webpack_require__(7147);\n+const os = __webpack_require__(2037);\n+\n+const tempDirectorySymbol = Symbol.for('__RESOLVED_TEMP_DIRECTORY__');\n+\n+if (!global[tempDirectorySymbol]) {\n+\tObject.defineProperty(global, tempDirectorySymbol, {\n+\t\tvalue: fs.realpathSync(os.tmpdir())\n+\t});\n+}\n+\n+module.exports = global[tempDirectorySymbol];\n+\n+\n+/***/ }),\n+\n+/***/ 4105:\n+/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n+\n+// ESM COMPAT FLAG\n+__webpack_require__.r(__webpack_exports__);\n+\n+// EXPORTS\n+__webpack_require__.d(__webpack_exports__, {\n+  \"rootTemporaryDirectory\": () => (/* reexport */ temp_dir),\n+  \"temporaryDirectory\": () => (/* binding */ temporaryDirectory),\n+  \"temporaryDirectoryTask\": () => (/* binding */ temporaryDirectoryTask),\n+  \"temporaryFile\": () => (/* binding */ temporaryFile),\n+  \"temporaryFileTask\": () => (/* binding */ temporaryFileTask),\n+  \"temporaryWrite\": () => (/* binding */ temporaryWrite),\n+  \"temporaryWriteSync\": () => (/* binding */ temporaryWriteSync),\n+  \"temporaryWriteTask\": () => (/* binding */ temporaryWriteTask)\n+});\n+\n+// EXTERNAL MODULE: external \"node:fs\"\n+var external_node_fs_ = __webpack_require__(7561);\n+// EXTERNAL MODULE: external \"node:fs/promises\"\n+var promises_ = __webpack_require__(3977);\n+// EXTERNAL MODULE: external \"node:path\"\n+var external_node_path_ = __webpack_require__(9411);\n+// EXTERNAL MODULE: external \"node:stream\"\n+var external_node_stream_ = __webpack_require__(4492);\n+// EXTERNAL MODULE: external \"node:util\"\n+var external_node_util_ = __webpack_require__(7261);\n+// EXTERNAL MODULE: external \"util\"\n+var external_util_ = __webpack_require__(3837);\n+// EXTERNAL MODULE: external \"crypto\"\n+var external_crypto_ = __webpack_require__(6113);\n+;// CONCATENATED MODULE: ./node_modules/crypto-random-string/index.js\n+\n+\n+\n+const randomBytesAsync = (0,external_util_.promisify)(external_crypto_.randomBytes);\n+\n+const urlSafeCharacters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~'.split('');\n+const numericCharacters = '0123456789'.split('');\n+const distinguishableCharacters = 'CDEHKMPRTUWXY012458'.split('');\n+const asciiPrintableCharacters = '!\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'.split('');\n+const alphanumericCharacters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('');\n+\n+const generateForCustomCharacters = (length, characters) => {\n+\t// Generating entropy is faster than complex math operations, so we use the simplest way\n+\tconst characterCount = characters.length;\n+\tconst maxValidSelector = (Math.floor(0x10000 / characterCount) * characterCount) - 1; // Using values above this will ruin distribution when using modular division\n+\tconst entropyLength = 2 * Math.ceil(1.1 * length); // Generating a bit more than required so chances we need more than one pass will be really low\n+\tlet string = '';\n+\tlet stringLength = 0;\n+\n+\twhile (stringLength < length) { // In case we had many bad values, which may happen for character sets of size above 0x8000 but close to it\n+\t\tconst entropy = external_crypto_.randomBytes(entropyLength);\n+\t\tlet entropyPosition = 0;\n+\n+\t\twhile (entropyPosition < entropyLength && stringLength < length) {\n+\t\t\tconst entropyValue = entropy.readUInt16LE(entropyPosition);\n+\t\t\tentropyPosition += 2;\n+\t\t\tif (entropyValue > maxValidSelector) { // Skip values which will ruin distribution when using modular division\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tstring += characters[entropyValue % characterCount];\n+\t\t\tstringLength++;\n+\t\t}\n+\t}\n+\n+\treturn string;\n+};\n+\n+const generateForCustomCharactersAsync = async (length, characters) => {\n+\t// Generating entropy is faster than complex math operations, so we use the simplest way\n+\tconst characterCount = characters.length;\n+\tconst maxValidSelector = (Math.floor(0x10000 / characterCount) * characterCount) - 1; // Using values above this will ruin distribution when using modular division\n+\tconst entropyLength = 2 * Math.ceil(1.1 * length); // Generating a bit more than required so chances we need more than one pass will be really low\n+\tlet string = '';\n+\tlet stringLength = 0;\n+\n+\twhile (stringLength < length) { // In case we had many bad values, which may happen for character sets of size above 0x8000 but close to it\n+\t\tconst entropy = await randomBytesAsync(entropyLength); // eslint-disable-line no-await-in-loop\n+\t\tlet entropyPosition = 0;\n+\n+\t\twhile (entropyPosition < entropyLength && stringLength < length) {\n+\t\t\tconst entropyValue = entropy.readUInt16LE(entropyPosition);\n+\t\t\tentropyPosition += 2;\n+\t\t\tif (entropyValue > maxValidSelector) { // Skip values which will ruin distribution when using modular division\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tstring += characters[entropyValue % characterCount];\n+\t\t\tstringLength++;\n+\t\t}\n+\t}\n+\n+\treturn string;\n+};\n+\n+const generateRandomBytes = (byteLength, type, length) => external_crypto_.randomBytes(byteLength).toString(type).slice(0, length);\n+\n+const generateRandomBytesAsync = async (byteLength, type, length) => {\n+\tconst buffer = await randomBytesAsync(byteLength);\n+\treturn buffer.toString(type).slice(0, length);\n+};\n+\n+const allowedTypes = new Set([\n+\tundefined,\n+\t'hex',\n+\t'base64',\n+\t'url-safe',\n+\t'numeric',\n+\t'distinguishable',\n+\t'ascii-printable',\n+\t'alphanumeric'\n+]);\n+\n+const createGenerator = (generateForCustomCharacters, generateRandomBytes) => ({length, type, characters}) => {\n+\tif (!(length >= 0 && Number.isFinite(length))) {\n+\t\tthrow new TypeError('Expected a `length` to be a non-negative finite number');\n+\t}\n+\n+\tif (type !== undefined && characters !== undefined) {\n+\t\tthrow new TypeError('Expected either `type` or `characters`');\n+\t}\n+\n+\tif (characters !== undefined && typeof characters !== 'string') {\n+\t\tthrow new TypeError('Expected `characters` to be string');\n+\t}\n+\n+\tif (!allowedTypes.has(type)) {\n+\t\tthrow new TypeError(`Unknown type: ${type}`);\n+\t}\n+\n+\tif (type === undefined && characters === undefined) {\n+\t\ttype = 'hex';\n+\t}\n+\n+\tif (type === 'hex' || (type === undefined && characters === undefined)) {\n+\t\treturn generateRandomBytes(Math.ceil(length * 0.5), 'hex', length); // Need 0.5 byte entropy per character\n+\t}\n+\n+\tif (type === 'base64') {\n+\t\treturn generateRandomBytes(Math.ceil(length * 0.75), 'base64', length); // Need 0.75 byte of entropy per character\n+\t}\n+\n+\tif (type === 'url-safe') {\n+\t\treturn generateForCustomCharacters(length, urlSafeCharacters);\n+\t}\n+\n+\tif (type === 'numeric') {\n+\t\treturn generateForCustomCharacters(length, numericCharacters);\n+\t}\n+\n+\tif (type === 'distinguishable') {\n+\t\treturn generateForCustomCharacters(length, distinguishableCharacters);\n+\t}\n+\n+\tif (type === 'ascii-printable') {\n+\t\treturn generateForCustomCharacters(length, asciiPrintableCharacters);\n+\t}\n+\n+\tif (type === 'alphanumeric') {\n+\t\treturn generateForCustomCharacters(length, alphanumericCharacters);\n+\t}\n+\n+\tif (characters.length === 0) {\n+\t\tthrow new TypeError('Expected `characters` string length to be greater than or equal to 1');\n+\t}\n+\n+\tif (characters.length > 0x10000) {\n+\t\tthrow new TypeError('Expected `characters` string length to be less or equal to 65536');\n+\t}\n+\n+\treturn generateForCustomCharacters(length, characters.split(''));\n+};\n+\n+const cryptoRandomString = createGenerator(generateForCustomCharacters, generateRandomBytes);\n+\n+cryptoRandomString.async = createGenerator(generateForCustomCharactersAsync, generateRandomBytesAsync);\n+\n+/* harmony default export */ const crypto_random_string = (cryptoRandomString);\n+\n+;// CONCATENATED MODULE: ./node_modules/unique-string/index.js\n+\n+\n+function uniqueString() {\n+\treturn crypto_random_string({length: 32});\n+}\n+\n+// EXTERNAL MODULE: ./node_modules/temp-dir/index.js\n+var temp_dir = __webpack_require__(8770);\n+;// CONCATENATED MODULE: ./node_modules/tempy/node_modules/is-stream/index.js\n+function isStream(stream) {\n+\treturn stream !== null\n+\t\t&& typeof stream === 'object'\n+\t\t&& typeof stream.pipe === 'function';\n+}\n+\n+function isWritableStream(stream) {\n+\treturn isStream(stream)\n+\t\t&& stream.writable !== false\n+\t\t&& typeof stream._write === 'function'\n+\t\t&& typeof stream._writableState === 'object';\n+}\n+\n+function isReadableStream(stream) {\n+\treturn isStream(stream)\n+\t\t&& stream.readable !== false\n+\t\t&& typeof stream._read === 'function'\n+\t\t&& typeof stream._readableState === 'object';\n+}\n+\n+function isDuplexStream(stream) {\n+\treturn isWritableStream(stream)\n+\t\t&& isReadableStream(stream);\n+}\n+\n+function isTransformStream(stream) {\n+\treturn isDuplexStream(stream)\n+\t\t&& typeof stream._transform === 'function';\n+}\n+\n+;// CONCATENATED MODULE: ./node_modules/tempy/index.js\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+const pipeline = (0,external_node_util_.promisify)(external_node_stream_.pipeline); // TODO: Use `node:stream/promises` when targeting Node.js 16.\n+\n+const getPath = (prefix = '') => external_node_path_.join(temp_dir, prefix + uniqueString());\n+\n+const writeStream = async (filePath, data) => pipeline(data, external_node_fs_.createWriteStream(filePath));\n+\n+async function runTask(temporaryPath, callback) {\n+\ttry {\n+\t\treturn await callback(temporaryPath);\n+\t} finally {\n+\t\tawait promises_.rm(temporaryPath, {recursive: true, force: true});\n+\t}\n+}\n+\n+function temporaryFile({name, extension} = {}) {\n+\tif (name) {\n+\t\tif (extension !== undefined && extension !== null) {\n+\t\t\tthrow new Error('The `name` and `extension` options are mutually exclusive');\n+\t\t}\n+\n+\t\treturn external_node_path_.join(temporaryDirectory(), name);\n+\t}\n+\n+\treturn getPath() + (extension === undefined || extension === null ? '' : '.' + extension.replace(/^\\./, ''));\n+}\n+\n+const temporaryFileTask = async (callback, options) => runTask(temporaryFile(options), callback);\n+\n+function temporaryDirectory({prefix = ''} = {}) {\n+\tconst directory = getPath(prefix);\n+\texternal_node_fs_.mkdirSync(directory);\n+\treturn directory;\n+}\n+\n+const temporaryDirectoryTask = async (callback, options) => runTask(temporaryDirectory(options), callback);\n+\n+async function temporaryWrite(fileContent, options) {\n+\tconst filename = temporaryFile(options);\n+\tconst write = isStream(fileContent) ? writeStream : promises_.writeFile;\n+\tawait write(filename, fileContent);\n+\treturn filename;\n+}\n+\n+const temporaryWriteTask = async (fileContent, callback, options) => runTask(await temporaryWrite(fileContent, options), callback);\n+\n+function temporaryWriteSync(fileContent, options) {\n+\tconst filename = temporaryFile(options);\n+\texternal_node_fs_.writeFileSync(filename, fileContent);\n+\treturn filename;\n+}\n+\n+\n+\n+\n+/***/ })\n+\n+};\n+;\n\\ No newline at end of file"
        },
        {
          "filename": "dist/index.js",
          "status": "modified",
          "additions": 94,
          "deletions": 1,
          "patch": "@@ -9701,6 +9701,8 @@ const {\n   getModuleVersionChanges,\n   checkModuleVersionChanges,\n } = __nccwpck_require__(9488)\n+const { verifyCommits } = __nccwpck_require__(3094)\n+const { dependabotAuthor } = __nccwpck_require__(500)\n \n const {\n   GITHUB_TOKEN,\n@@ -9728,11 +9730,25 @@ module.exports = async function run() {\n \n     const pr = pull_request || (await client.getPullRequest(PR_NUMBER))\n \n-    const isDependabotPR = pr.user.login === 'dependabot[bot]'\n+    const isDependabotPR = pr.user.login === dependabotAuthor\n     if (!isDependabotPR) {\n       return logWarning('Not a dependabot PR, skipping.')\n     }\n \n+    const commits = await client.getPullRequestCommits(pr.number)\n+\n+    if (!commits.every(commit => commit.author.login === dependabotAuthor)) {\n+      return logWarning('PR contains non dependabot commits, skipping.')\n+    }\n+\n+    try {\n+      await verifyCommits(commits)\n+    } catch {\n+      return logWarning(\n+        'PR contains invalid dependabot commit signatures, skipping.'\n+      )\n+    }\n+\n     const prDiff = await client.getPullRequestDiff(pr.number)\n \n     // Get changed modules from diff if available or from PR title as fallback\n@@ -9814,6 +9830,23 @@ function parsePrTitle(pullRequest) {\n }\n \n \n+/***/ }),\n+\n+/***/ 500:\n+/***/ ((module) => {\n+\n+\"use strict\";\n+\n+const dependabotAuthor = 'dependabot[bot]'\n+\n+const dependabotCommitter = 'GitHub'\n+\n+module.exports = {\n+  dependabotAuthor,\n+  dependabotCommitter,\n+}\n+\n+\n /***/ }),\n \n /***/ 5013:\n@@ -9913,6 +9946,16 @@ function githubClient(githubToken) {\n       })\n       return pullRequest\n     },\n+\n+    async getPullRequestCommits(pullRequestNumber) {\n+      const { data } = await octokit.rest.pulls.listCommits({\n+        owner,\n+        repo: repoName,\n+        pull_number: pullRequestNumber,\n+      })\n+\n+      return data\n+    },\n   }\n }\n \n@@ -10125,6 +10168,56 @@ exports.isValidSemver = function (version) {\n }\n \n \n+/***/ }),\n+\n+/***/ 3094:\n+/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {\n+\n+\"use strict\";\n+\n+\n+const {\n+  dependabotAuthor,\n+  dependabotCommitter,\n+} = __nccwpck_require__(500)\n+\n+function verifyCommits(commits) {\n+  commits.forEach(function (commit) {\n+    const {\n+      commit: {\n+        verification: { verified },\n+        committer,\n+        author,\n+      },\n+      sha,\n+    } = commit\n+    verifyCommitSignatureCommitterAndAuthor(sha, author, committer, verified)\n+  })\n+}\n+\n+function verifyCommitSignatureCommitterAndAuthor(\n+  sha,\n+  author,\n+  committer,\n+  verified\n+) {\n+  if (\n+    !verified ||\n+    committer.name !== dependabotCommitter ||\n+    author.name !== dependabotAuthor\n+  ) {\n+    throw new Error(\n+      `Signature for commit ${sha} could not be verified - Not a dependabot commit`\n+    )\n+  }\n+}\n+\n+module.exports = {\n+  verifyCommits,\n+  verifyCommitSignatureCommitterAndAuthor,\n+}\n+\n+\n /***/ }),\n \n /***/ 2877:"
        },
        {
          "filename": "src/action.js",
          "status": "modified",
          "additions": 17,
          "deletions": 1,
          "patch": "@@ -20,6 +20,8 @@ const {\n   getModuleVersionChanges,\n   checkModuleVersionChanges,\n } = require('./moduleVersionChanges')\n+const { verifyCommits } = require('./verifyCommitSignatures')\n+const { dependabotAuthor } = require('./getDependabotDetails')\n \n const {\n   GITHUB_TOKEN,\n@@ -47,11 +49,25 @@ module.exports = async function run() {\n \n     const pr = pull_request || (await client.getPullRequest(PR_NUMBER))\n \n-    const isDependabotPR = pr.user.login === 'dependabot[bot]'\n+    const isDependabotPR = pr.user.login === dependabotAuthor\n     if (!isDependabotPR) {\n       return logWarning('Not a dependabot PR, skipping.')\n     }\n \n+    const commits = await client.getPullRequestCommits(pr.number)\n+\n+    if (!commits.every(commit => commit.author.login === dependabotAuthor)) {\n+      return logWarning('PR contains non dependabot commits, skipping.')\n+    }\n+\n+    try {\n+      await verifyCommits(commits)\n+    } catch {\n+      return logWarning(\n+        'PR contains invalid dependabot commit signatures, skipping.'\n+      )\n+    }\n+\n     const prDiff = await client.getPullRequestDiff(pr.number)\n \n     // Get changed modules from diff if available or from PR title as fallback"
        },
        {
          "filename": "src/getDependabotDetails.js",
          "status": "added",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -0,0 +1,9 @@\n+'use strict'\n+const dependabotAuthor = 'dependabot[bot]'\n+\n+const dependabotCommitter = 'GitHub'\n+\n+module.exports = {\n+  dependabotAuthor,\n+  dependabotCommitter,\n+}"
        },
        {
          "filename": "src/github-client.js",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -54,6 +54,16 @@ function githubClient(githubToken) {\n       })\n       return pullRequest\n     },\n+\n+    async getPullRequestCommits(pullRequestNumber) {\n+      const { data } = await octokit.rest.pulls.listCommits({\n+        owner,\n+        repo: repoName,\n+        pull_number: pullRequestNumber,\n+      })\n+\n+      return data\n+    },\n   }\n }\n "
        },
        {
          "filename": "src/verifyCommitSignatures.js",
          "status": "added",
          "additions": 42,
          "deletions": 0,
          "patch": "@@ -0,0 +1,42 @@\n+'use strict'\n+\n+const {\n+  dependabotAuthor,\n+  dependabotCommitter,\n+} = require('./getDependabotDetails')\n+\n+function verifyCommits(commits) {\n+  commits.forEach(function (commit) {\n+    const {\n+      commit: {\n+        verification: { verified },\n+        committer,\n+        author,\n+      },\n+      sha,\n+    } = commit\n+    verifyCommitSignatureCommitterAndAuthor(sha, author, committer, verified)\n+  })\n+}\n+\n+function verifyCommitSignatureCommitterAndAuthor(\n+  sha,\n+  author,\n+  committer,\n+  verified\n+) {\n+  if (\n+    !verified ||\n+    committer.name !== dependabotCommitter ||\n+    author.name !== dependabotAuthor\n+  ) {\n+    throw new Error(\n+      `Signature for commit ${sha} could not be verified - Not a dependabot commit`\n+    )\n+  }\n+}\n+\n+module.exports = {\n+  verifyCommits,\n+  verifyCommitSignatureCommitterAndAuthor,\n+}"
        },
        {
          "filename": "test/action.test.js",
          "status": "modified",
          "additions": 80,
          "deletions": 0,
          "patch": "@@ -13,6 +13,7 @@ const { diffs } = require('./moduleChanges')\n const actionLog = require('../src/log')\n const actionUtil = require('../src/util')\n const actionGithubClient = require('../src/github-client')\n+const verifyCommits = require('../src/verifyCommitSignatures')\n \n const GITHUB_TOKEN = 'the-token'\n const BOT_NAME = 'dependabot[bot]'\n@@ -34,15 +35,22 @@ function buildStubbedAction({ payload, inputs }) {\n \n   const prStub = sinon.stub()\n   const prDiffStub = sinon.stub()\n+  const prCommitsStub = sinon.stub()\n   const approveStub = sinon.stub()\n   const mergeStub = sinon.stub()\n+\n   const clientStub = sinon.stub(actionGithubClient, 'githubClient').returns({\n     getPullRequest: prStub.resolves(),\n     approvePullRequest: approveStub.resolves(),\n     mergePullRequest: mergeStub.resolves(),\n     getPullRequestDiff: prDiffStub.resolves(),\n+    getPullRequestCommits: prCommitsStub.resolves([]),\n   })\n \n+  const verifyCommitsStub = sinon\n+    .stub(verifyCommits, 'verifyCommits')\n+    .returns(Promise.resolve())\n+\n   const action = proxyquire('../src/action', {\n     '@actions/core': coreStub,\n     'actions-toolkit': toolkitStub,\n@@ -63,6 +71,8 @@ function buildStubbedAction({ payload, inputs }) {\n       approveStub,\n       mergeStub,\n       prDiffStub,\n+      prCommitsStub,\n+      verifyCommitsStub,\n     },\n   }\n }\n@@ -124,6 +134,76 @@ tap.test('should skip non-dependabot PR', async () => {\n   sinon.assert.notCalled(stubs.mergeStub)\n })\n \n+tap.test('should skip PR with non dependabot commit', async () => {\n+  const PR_NUMBER = Math.random()\n+  const { action, stubs } = buildStubbedAction({\n+    payload: {\n+      pull_request: {\n+        user: {\n+          login: BOT_NAME,\n+        },\n+        number: PR_NUMBER,\n+      },\n+    },\n+    inputs: { PR_NUMBER },\n+  })\n+\n+  stubs.prCommitsStub.resolves([\n+    {\n+      author: {\n+        login: 'not dependabot',\n+      },\n+    },\n+  ])\n+\n+  await action()\n+\n+  sinon.assert.calledOnce(stubs.prCommitsStub)\n+  sinon.assert.calledWithExactly(\n+    stubs.logStub.logWarning,\n+    'PR contains non dependabot commits, skipping.'\n+  )\n+  sinon.assert.notCalled(stubs.approveStub)\n+  sinon.assert.notCalled(stubs.mergeStub)\n+})\n+\n+tap.test(\n+  'should skip PR if dependabot commit signatures cannot be verified',\n+  async () => {\n+    const PR_NUMBER = Math.random()\n+    const { action, stubs } = buildStubbedAction({\n+      payload: {\n+        pull_request: {\n+          user: {\n+            login: BOT_NAME,\n+          },\n+          number: PR_NUMBER,\n+        },\n+      },\n+      inputs: { PR_NUMBER },\n+    })\n+\n+    stubs.prCommitsStub.resolves([\n+      {\n+        author: {\n+          login: 'dependabot[bot]',\n+        },\n+      },\n+    ])\n+\n+    stubs.verifyCommitsStub.rejects()\n+\n+    await action()\n+\n+    sinon.assert.calledWithExactly(\n+      stubs.logStub.logWarning,\n+      'PR contains invalid dependabot commit signatures, skipping.'\n+    )\n+    sinon.assert.notCalled(stubs.approveStub)\n+    sinon.assert.notCalled(stubs.mergeStub)\n+  }\n+)\n+\n tap.test('should process dependabot PR and skip PR not in target', async () => {\n   const PR_NUMBER = Math.random()\n   const { action, stubs } = buildStubbedAction({"
        },
        {
          "filename": "test/github-client.test.js",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -18,6 +18,7 @@ const octokitStubs = {\n   get: sinon.stub().returns(Promise.resolve({ data })),\n   createReview: sinon.stub().returns(Promise.resolve({ data })),\n   merge: sinon.stub().returns(Promise.resolve({ data })),\n+  listCommits: sinon.stub().returns(Promise.resolve({ data })),\n }\n \n const { githubClient } = tap.mock('../src/github-client', {\n@@ -95,4 +96,15 @@ tap.test('githubClient', async t => {\n       },\n     })\n   })\n+\n+  t.test('getPullRequestCommits', async () => {\n+    const result = await githubClient(TOKEN).getPullRequestCommits(PR_NUMBER)\n+    tap.equal(result, data)\n+\n+    sinon.assert.calledWith(octokitStubs.listCommits, {\n+      owner: githubContext.repository.owner.login,\n+      repo: githubContext.repository.name,\n+      pull_number: PR_NUMBER,\n+    })\n+  })\n })"
        },
        {
          "filename": "test/verifyCommitSignatures.test.js",
          "status": "added",
          "additions": 218,
          "deletions": 0,
          "patch": "@@ -0,0 +1,218 @@\n+'use strict'\n+\n+const tap = require('tap')\n+\n+const {\n+  dependabotAuthor,\n+  dependabotCommitter,\n+} = require('../src/getDependabotDetails')\n+const {\n+  verifyCommits,\n+  verifyCommitSignatureCommitterAndAuthor,\n+} = require('../src/verifyCommitSignatures')\n+\n+const ValidAuthorValidCommitterVerifiedCommitMock = {\n+  commit: {\n+    author: { name: dependabotAuthor },\n+    committer: { name: dependabotCommitter },\n+    verification: { verified: true },\n+  },\n+  sha: 'sha',\n+}\n+const ValidAuthorValidCommitterUnverifiedCommitMock = {\n+  commit: {\n+    author: { name: dependabotAuthor },\n+    committer: { name: dependabotCommitter },\n+    verification: { verified: false },\n+  },\n+  sha: 'sha',\n+}\n+const InvalidAuthorValidCommitterVerifiedCommitMock = {\n+  commit: {\n+    author: { name: 'testUser' },\n+    committer: { name: dependabotCommitter },\n+    verification: { verified: true },\n+  },\n+  sha: 'sha',\n+}\n+const ValidAuthorInvalidCommitterVerifiedCommitMock = {\n+  commit: {\n+    author: { name: dependabotAuthor },\n+    committer: { name: 'testUser' },\n+    verification: { verified: true },\n+  },\n+  sha: 'sha',\n+}\n+const InvalidAuthorInvalidCommitterUnverifiedCommitMock = {\n+  commit: {\n+    author: { name: 'testUser' },\n+    committer: { name: 'testUser' },\n+    verification: { verified: false },\n+  },\n+  sha: 'sha',\n+}\n+\n+const prCommitsValid = [\n+  ValidAuthorValidCommitterVerifiedCommitMock,\n+  ValidAuthorValidCommitterVerifiedCommitMock,\n+]\n+const prCommitsInvalid = [\n+  InvalidAuthorValidCommitterVerifiedCommitMock,\n+  InvalidAuthorValidCommitterVerifiedCommitMock,\n+]\n+const prCommitsValidAndInvalid = [\n+  ValidAuthorValidCommitterVerifiedCommitMock,\n+  InvalidAuthorValidCommitterVerifiedCommitMock,\n+]\n+\n+tap.test('verifyCommitSignatureCommitterAndAuthor', async t => {\n+  t.test('shoud throw error when', async t => {\n+    t.test('the verified flag is set to false', async t => {\n+      const {\n+        commit: {\n+          author,\n+          committer,\n+          verification: { verified },\n+        },\n+        sha,\n+      } = ValidAuthorValidCommitterUnverifiedCommitMock\n+      t.throws(\n+        () =>\n+          verifyCommitSignatureCommitterAndAuthor(\n+            sha,\n+            author,\n+            committer,\n+            verified\n+          ),\n+        new Error(\n+          `Signature for commit ${sha} could not be verified - Not a dependabot commit`\n+        )\n+      )\n+    })\n+\n+    t.test('the committer name is not GitHub', async t => {\n+      const {\n+        commit: {\n+          author,\n+          committer,\n+          verification: { verified },\n+        },\n+        sha,\n+      } = ValidAuthorInvalidCommitterVerifiedCommitMock\n+      t.throws(\n+        () =>\n+          verifyCommitSignatureCommitterAndAuthor(\n+            sha,\n+            author,\n+            committer,\n+            verified\n+          ),\n+        new Error(\n+          `Signature for commit ${sha} could not be verified - Not a dependabot commit`\n+        )\n+      )\n+    })\n+\n+    t.test('the authot name is not dependabot[bot]', async t => {\n+      const {\n+        commit: {\n+          author,\n+          committer,\n+          verification: { verified },\n+        },\n+        sha,\n+      } = InvalidAuthorValidCommitterVerifiedCommitMock\n+      t.throws(\n+        () =>\n+          verifyCommitSignatureCommitterAndAuthor(\n+            sha,\n+            author,\n+            committer,\n+            verified\n+          ),\n+        new Error(\n+          `Signature for commit ${sha} could not be verified - Not a dependabot commit`\n+        )\n+      )\n+    })\n+\n+    t.test(\n+      'the committer name is not Github, the author is not dependabot[bot] and is not verified',\n+      async t => {\n+        const {\n+          commit: {\n+            author,\n+            committer,\n+            verification: { verified },\n+          },\n+          sha,\n+        } = InvalidAuthorInvalidCommitterUnverifiedCommitMock\n+        t.throws(\n+          () =>\n+            verifyCommitSignatureCommitterAndAuthor(\n+              sha,\n+              author,\n+              committer,\n+              verified\n+            ),\n+          new Error(\n+            `Signature for commit ${sha} could not be verified - Not a dependabot commit`\n+          )\n+        )\n+      }\n+    )\n+  })\n+\n+  t.test('should not throw an error when', async t => {\n+    t.test(\n+      'the committer name is Github, the author is dependabot[bot] and is verified',\n+      async t => {\n+        const {\n+          commit: {\n+            author,\n+            committer,\n+            verification: { verified },\n+          },\n+          sha,\n+        } = ValidAuthorValidCommitterVerifiedCommitMock\n+        t.doesNotThrow(\n+          () =>\n+            verifyCommitSignatureCommitterAndAuthor(\n+              sha,\n+              author,\n+              committer,\n+              verified\n+            ),\n+          {}\n+        )\n+      }\n+    )\n+  })\n+})\n+\n+tap.test('VerifyCommits', async t => {\n+  t.test('Should throw error when', async t => {\n+    t.test('At least one commit does not match the requirements', async t => {\n+      t.throws(\n+        () => verifyCommits(prCommitsValidAndInvalid),\n+        new Error(\n+          `Signature for commit sha could not be verified - Not a dependabot commit`\n+        )\n+      )\n+    })\n+\n+    t.test('At least one commit does not match the requirements', async t => {\n+      t.throws(\n+        () => verifyCommits(prCommitsInvalid),\n+        new Error(\n+          `Signature for commit sha could not be verified - Not a dependabot commit`\n+        )\n+      )\n+    })\n+  })\n+  t.test('Should not throw error when', async t => {\n+    t.test('All commits match the requirements', async t => {\n+      t.doesNotThrow(() => verifyCommits(prCommitsValid), {})\n+    })\n+  })\n+})"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 3,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "727dd6a6be812e51d49967309bd20eb81dd7e7f6",
            "date": "2025-01-13T08:55:36Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "57a658422bbd6c279d8601087cf0ca1893383e35",
            "date": "2025-01-06T14:10:08Z",
            "author_login": "Uzlopak"
          },
          {
            "sha": "ee2d70462cce19b65474dab38bce152765301743",
            "date": "2025-01-06T13:54:48Z",
            "author_login": "Uzlopak"
          },
          {
            "sha": "c8cb7e788ea6d0744b9097010535c048d339e854",
            "date": "2024-12-23T09:20:08Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "78aab26ee41dbb100e15e598c74a5684a55552b4",
            "date": "2024-12-09T08:16:31Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-283",
    "description": "github-action-merge-dependabot is an action that automatically approves and merges dependabot pull requests (PRs). Prior to version 3.2.0, github-action-merge-dependabot does not check if a commit created by dependabot is verified with the proper GPG key. There is just a check if the actor is set to `dependabot[bot]` to determine if the PR is a legit PR. Theoretically, an owner of a seemingly valid and legit action in the pipeline can check if the PR is created by dependabot and if their own action has enough permissions to modify the PR in the pipeline. If so, they can modify the PR by adding a second seemingly valid and legit commit to the PR, as they can set arbitrarily the username and email in for commits in git. Because the bot only checks if the actor is valid, it would pass the malicious changes through and merge the PR automatically, without getting noticed by project maintainers. It would probably not be possible to determine where the malicious commit came from, as it would only say `dependabot[bot]` and the corresponding email-address. Version 3.2.0 contains a patch for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-05-31T16:15:08.037",
    "last_modified": "2024-11-21T06:58:44.837",
    "fix_date": "2022-05-26T10:13:06Z"
  },
  "references": [
    {
      "url": "https://github.com/fastify/github-action-merge-dependabot/commit/309f39539c5d918d8a47075587aa8720a9c127f7",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/fastify/github-action-merge-dependabot/security/advisories/GHSA-v5vr-h3xq-8v6w",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://hackerone.com/bugs?report_id=1564530",
      "source": "security-advisories@github.com",
      "tags": [
        "Permissions Required",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/fastify/github-action-merge-dependabot/commit/309f39539c5d918d8a47075587aa8720a9c127f7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/fastify/github-action-merge-dependabot/security/advisories/GHSA-v5vr-h3xq-8v6w",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://hackerone.com/bugs?report_id=1564530",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Permissions Required",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:07.193643",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "github-action-merge-dependabot",
    "owner": "fastify",
    "created_at": "2020-11-11T14:23:33Z",
    "updated_at": "2025-01-13T08:55:41Z",
    "pushed_at": "2025-01-13T08:55:38Z",
    "size": 3089,
    "stars": 161,
    "forks": 35,
    "open_issues": 12,
    "watchers": 161,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "JavaScript": 53039,
      "Shell": 83
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T22:58:58.288468"
  }
}