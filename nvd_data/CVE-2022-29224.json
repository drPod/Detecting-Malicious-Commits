{
  "cve_id": "CVE-2022-29224",
  "github_data": {
    "repository": "envoyproxy/envoy",
    "fix_commit": "9b1c3962172a972bc0359398af6daa3790bb59db",
    "related_commits": [
      "9b1c3962172a972bc0359398af6daa3790bb59db",
      "9b1c3962172a972bc0359398af6daa3790bb59db"
    ],
    "patch_url": "https://github.com/envoyproxy/envoy/commit/9b1c3962172a972bc0359398af6daa3790bb59db.patch",
    "fix_commit_details": {
      "sha": "9b1c3962172a972bc0359398af6daa3790bb59db",
      "commit_date": "2022-06-08T23:09:34Z",
      "author": {
        "login": "pradeepcrao",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "healthcheck: fix grpc inline removal crashes (#749)",
        "length": 142,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 90,
        "additions": 83,
        "deletions": 7
      },
      "files": [
        {
          "filename": "source/common/upstream/health_checker_impl.cc",
          "status": "modified",
          "additions": 19,
          "deletions": 7,
          "patch": "@@ -815,10 +815,17 @@ void GrpcHealthCheckerImpl::GrpcActiveHealthCheckSession::onGoAway(\n   // Even if we have active health check probe, fail it on GOAWAY and schedule new one.\n   if (request_encoder_) {\n     handleFailure(envoy::data::core::v3::NETWORK);\n-    expect_reset_ = true;\n-    request_encoder_->getStream().resetStream(Http::StreamResetReason::LocalReset);\n+    // request_encoder_ can already be destroyed if the host was removed during the failure callback\n+    // above.\n+    if (request_encoder_ != nullptr) {\n+      expect_reset_ = true;\n+      request_encoder_->getStream().resetStream(Http::StreamResetReason::LocalReset);\n+    }\n+  }\n+  // client_ can already be destroyed if the host was removed during the failure callback above.\n+  if (client_ != nullptr) {\n+    client_->close();\n   }\n-  client_->close();\n }\n \n bool GrpcHealthCheckerImpl::GrpcActiveHealthCheckSession::isHealthCheckSucceeded(\n@@ -852,12 +859,17 @@ void GrpcHealthCheckerImpl::GrpcActiveHealthCheckSession::onRpcComplete(\n   if (end_stream) {\n     resetState();\n   } else {\n-    // resetState() will be called by onResetStream().\n-    expect_reset_ = true;\n-    request_encoder_->getStream().resetStream(Http::StreamResetReason::LocalReset);\n+    // request_encoder_ can already be destroyed if the host was removed during the failure callback\n+    // above.\n+    if (request_encoder_ != nullptr) {\n+      // resetState() will be called by onResetStream().\n+      expect_reset_ = true;\n+      request_encoder_->getStream().resetStream(Http::StreamResetReason::LocalReset);\n+    }\n   }\n \n-  if (!parent_.reuse_connection_ || goaway) {\n+  // client_ can already be destroyed if the host was removed during the failure callback above.\n+  if (client_ != nullptr && (!parent_.reuse_connection_ || goaway)) {\n     client_->close();\n   }\n }"
        },
        {
          "filename": "test/common/upstream/health_checker_impl_test.cc",
          "status": "modified",
          "additions": 64,
          "deletions": 0,
          "patch": "@@ -4737,6 +4737,70 @@ TEST_F(GrpcHealthCheckerImplTest, SuccessStartFailedFailFirst) {\n   expectHostHealthy(true);\n }\n \n+// Verify functionality when a host is removed inline with a failure via RPC that was proceeded\n+// by a GOAWAY.\n+TEST_F(GrpcHealthCheckerImplTest, GrpcHealthFailViaRpcRemoveHostInCallback) {\n+  setupHC();\n+  cluster_->prioritySet().getMockHostSet(0)->hosts_ = {\n+      makeTestHost(cluster_->info_, \"tcp://127.0.0.1:80\", simTime())};\n+\n+  expectSessionCreate();\n+  expectHealthcheckStart(0);\n+  EXPECT_CALL(event_logger_, logUnhealthy(_, _, _, true));\n+  health_checker_->start();\n+\n+  EXPECT_CALL(*this, onHostStatus(_, HealthTransition::Changed))\n+      .WillOnce(Invoke([&](HostSharedPtr host, HealthTransition) {\n+        cluster_->prioritySet().getMockHostSet(0)->hosts_ = {};\n+        cluster_->prioritySet().runUpdateCallbacks(0, {}, {host});\n+      }));\n+  EXPECT_CALL(event_logger_, logEjectUnhealthy(_, _, _));\n+  test_sessions_[0]->codec_client_->raiseGoAway(Http::GoAwayErrorCode::NoError);\n+  respondServiceStatus(0, grpc::health::v1::HealthCheckResponse::NOT_SERVING);\n+}\n+\n+// Verify functionality when a host is removed inline with a failure via an error GOAWAY.\n+TEST_F(GrpcHealthCheckerImplTest, GrpcHealthFailViaGoawayRemoveHostInCallback) {\n+  setupHCWithUnhealthyThreshold(/*threshold=*/1);\n+  cluster_->prioritySet().getMockHostSet(0)->hosts_ = {\n+      makeTestHost(cluster_->info_, \"tcp://127.0.0.1:80\", simTime())};\n+\n+  expectSessionCreate();\n+  expectHealthcheckStart(0);\n+  EXPECT_CALL(event_logger_, logUnhealthy(_, _, _, true));\n+  health_checker_->start();\n+\n+  EXPECT_CALL(*this, onHostStatus(_, HealthTransition::Changed))\n+      .WillOnce(Invoke([&](HostSharedPtr host, HealthTransition) {\n+        cluster_->prioritySet().getMockHostSet(0)->hosts_ = {};\n+        cluster_->prioritySet().runUpdateCallbacks(0, {}, {host});\n+      }));\n+  EXPECT_CALL(event_logger_, logEjectUnhealthy(_, _, _));\n+  test_sessions_[0]->codec_client_->raiseGoAway(Http::GoAwayErrorCode::Other);\n+}\n+\n+// Verify functionality when a host is removed inline with by a bad RPC response.\n+TEST_F(GrpcHealthCheckerImplTest, GrpcHealthFailViaBadResponseRemoveHostInCallback) {\n+  setupHCWithUnhealthyThreshold(/*threshold=*/1);\n+  cluster_->prioritySet().getMockHostSet(0)->hosts_ = {\n+      makeTestHost(cluster_->info_, \"tcp://127.0.0.1:80\", simTime())};\n+\n+  expectSessionCreate();\n+  expectHealthcheckStart(0);\n+  EXPECT_CALL(event_logger_, logUnhealthy(_, _, _, true));\n+  health_checker_->start();\n+\n+  EXPECT_CALL(*this, onHostStatus(_, HealthTransition::Changed))\n+      .WillOnce(Invoke([&](HostSharedPtr host, HealthTransition) {\n+        cluster_->prioritySet().getMockHostSet(0)->hosts_ = {};\n+        cluster_->prioritySet().runUpdateCallbacks(0, {}, {host});\n+      }));\n+  EXPECT_CALL(event_logger_, logEjectUnhealthy(_, _, _));\n+  std::unique_ptr<Http::TestResponseHeaderMapImpl> response_headers(\n+      new Http::TestResponseHeaderMapImpl{{\":status\", \"500\"}});\n+  test_sessions_[0]->stream_response_callbacks_->decodeHeaders(std::move(response_headers), false);\n+}\n+\n // Test host recovery after explicit check failure requires several successful checks.\n TEST_F(GrpcHealthCheckerImplTest, GrpcHealthFail) {\n   setupHC();"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7974086e9b5530770497339e086ae666ee185ea7",
            "date": "2025-01-14T22:14:52Z",
            "author_login": "krinkinmu"
          },
          {
            "sha": "a5cf609225dfd223ec734cdc2d9a2cb33e58cacc",
            "date": "2025-01-14T20:58:08Z",
            "author_login": "phlax"
          },
          {
            "sha": "b0f43d67aa25c1b03c97186a200cc187f4c22db3",
            "date": "2025-01-14T17:27:17Z",
            "author_login": "publish-envoy[bot]"
          },
          {
            "sha": "c93cf7af47f7e24c83b563d3b956074333bc4bf7",
            "date": "2025-01-14T17:23:07Z",
            "author_login": "phlax"
          },
          {
            "sha": "078dae3549912e632c3776a5e9a4679226093276",
            "date": "2025-01-14T14:27:08Z",
            "author_login": "agrawroh"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-476",
    "description": "Envoy is a cloud-native high-performance proxy. Versions of envoy prior to 1.22.1 are subject to a segmentation fault in the GrpcHealthCheckerImpl. Envoy can perform various types of upstream health checking. One of them uses gRPC. Envoy also has a feature which can \u201chold\u201d (prevent removal) upstream hosts obtained via service discovery until configured active health checking fails. If an attacker controls an upstream host and also controls service discovery of that host (via DNS, the EDS API, etc.), an attacker can crash Envoy by forcing removal of the host from service discovery, and then failing the gRPC health check request. This will crash Envoy via a null pointer dereference. Users are advised to upgrade to resolve this vulnerability. Users unable to upgrade may disable gRPC health checking and/or replace it with a different health checking type as a mitigation.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-06-09T19:15:10.450",
    "last_modified": "2024-11-21T06:58:45.357",
    "fix_date": "2022-06-08T23:09:34Z"
  },
  "references": [
    {
      "url": "https://github.com/envoyproxy/envoy/commit/9b1c3962172a972bc0359398af6daa3790bb59db",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-m4j9-86g3-8f49",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/commit/9b1c3962172a972bc0359398af6daa3790bb59db",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-m4j9-86g3-8f49",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:09.425778",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "envoy",
    "owner": "envoyproxy",
    "created_at": "2016-08-08T15:07:24Z",
    "updated_at": "2025-01-14T12:22:22Z",
    "pushed_at": "2025-01-14T05:36:17Z",
    "size": 240648,
    "stars": 25321,
    "forks": 4848,
    "open_issues": 1639,
    "watchers": 25321,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C++": 48293036,
      "Starlark": 3105942,
      "Java": 1320095,
      "Python": 605206,
      "Assembly": 327095,
      "Kotlin": 309606,
      "Swift": 250537,
      "Shell": 229801,
      "Go": 183281,
      "Rust": 107190,
      "JavaScript": 66339,
      "C": 61597,
      "Objective-C++": 55490,
      "Objective-C": 48840,
      "Jinja": 47798,
      "Smarty": 3528,
      "CSS": 2927,
      "HTML": 1522,
      "Emacs Lisp": 966,
      "Dockerfile": 960,
      "Thrift": 748,
      "PureBasic": 472,
      "Batchfile": 439,
      "Makefile": 303
    },
    "commit_activity": {
      "total_commits_last_year": 3286,
      "avg_commits_per_week": 63.19230769230769,
      "days_active_last_year": 303
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:55:59.245540"
  }
}