{
  "cve_id": "CVE-2022-29227",
  "github_data": {
    "repository": "envoyproxy/envoy",
    "fix_commit": "fe7c69c248f4fe5a9080c7ccb35275b5218bb5ab",
    "related_commits": [
      "fe7c69c248f4fe5a9080c7ccb35275b5218bb5ab",
      "fe7c69c248f4fe5a9080c7ccb35275b5218bb5ab"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "fe7c69c248f4fe5a9080c7ccb35275b5218bb5ab",
      "commit_date": "2022-06-08T23:10:39Z",
      "author": {
        "login": "pradeepcrao",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "internal redirect: fix a lifetime bug (#785)",
        "length": 185,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 127,
        "additions": 112,
        "deletions": 15
      },
      "files": [
        {
          "filename": "source/common/http/conn_manager_impl.cc",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -1729,6 +1729,12 @@ void ConnectionManagerImpl::ActiveStream::recreateStream(\n             filter_state->parent(), StreamInfo::FilterState::LifeSpan::FilterChain);\n   }\n \n+  // Make sure that relevant information makes it from the original stream info\n+  // to the new one. Generally this should consist of all downstream related\n+  // data, and not include upstream related data.\n+  (*connection_manager_.streams_.begin())\n+      ->filter_manager_.streamInfo()\n+      .setFromForRecreateStream(filter_manager_.streamInfo());\n   new_stream.decodeHeaders(std::move(request_headers_), !proxy_body);\n   if (proxy_body) {\n     // This functionality is currently only used for internal redirects, which the router only"
        },
        {
          "filename": "source/common/http/filter_manager.cc",
          "status": "modified",
          "additions": 3,
          "deletions": 4,
          "patch": "@@ -327,7 +327,7 @@ Buffer::InstancePtr& ActiveStreamDecoderFilter::bufferedData() {\n   return parent_.buffered_request_data_;\n }\n \n-bool ActiveStreamDecoderFilter::complete() { return parent_.state_.remote_decode_complete_; }\n+bool ActiveStreamDecoderFilter::complete() { return parent_.remoteDecodeComplete(); }\n \n void ActiveStreamDecoderFilter::doHeaders(bool end_stream) {\n   parent_.decodeHeaders(this, *parent_.filter_manager_callbacks_.requestHeaders(), end_stream);\n@@ -843,9 +843,8 @@ void FilterManager::decodeMetadata(ActiveStreamDecoderFilter* filter, MetadataMa\n }\n \n void FilterManager::maybeEndDecode(bool end_stream) {\n-  ASSERT(!state_.remote_decode_complete_);\n-  state_.remote_decode_complete_ = end_stream;\n-  if (end_stream) {\n+  // If recreateStream is called, the HCM rewinds state and may send more encodeData calls.\n+  if (end_stream && !remoteDecodeComplete()) {\n     stream_info_.downstreamTiming().onLastDownstreamRxByteReceived(dispatcher().timeSource());\n     ENVOY_STREAM_LOG(debug, \"request end stream\", *this);\n   }"
        },
        {
          "filename": "source/common/http/filter_manager.h",
          "status": "modified",
          "additions": 9,
          "deletions": 7,
          "patch": "@@ -907,7 +907,10 @@ class FilterManager : public ScopeTrackedObject,\n   /**\n    * Whether remote processing has been marked as complete.\n    */\n-  bool remoteDecodeComplete() const { return state_.remote_decode_complete_; }\n+  bool remoteDecodeComplete() const {\n+    return stream_info_.downstreamTiming() &&\n+           stream_info_.downstreamTiming()->lastDownstreamRxByteReceived().has_value();\n+  }\n \n   /**\n    * Instructs the FilterManager to not create a filter chain. This makes it possible to issue\n@@ -1058,15 +1061,14 @@ class FilterManager : public ScopeTrackedObject,\n \n   struct State {\n     State()\n-        : remote_encode_complete_(false), remote_decode_complete_(false), local_complete_(false),\n-          has_1xx_headers_(false), created_filter_chain_(false), is_head_request_(false),\n-          is_grpc_request_(false), non_100_response_headers_encoded_(false),\n-          under_on_local_reply_(false), decoder_filter_chain_aborted_(false),\n-          encoder_filter_chain_aborted_(false), saw_downstream_reset_(false) {}\n+        : remote_encode_complete_(false), local_complete_(false), has_1xx_headers_(false),\n+          created_filter_chain_(false), is_head_request_(false), is_grpc_request_(false),\n+          non_100_response_headers_encoded_(false), under_on_local_reply_(false),\n+          decoder_filter_chain_aborted_(false), encoder_filter_chain_aborted_(false),\n+          saw_downstream_reset_(false) {}\n     uint32_t filter_call_state_{0};\n \n     bool remote_encode_complete_ : 1;\n-    bool remote_decode_complete_ : 1;\n     bool local_complete_ : 1; // This indicates that local is complete prior to filter processing.\n                               // A filter can still stop the stream from being complete as seen\n                               // by the codec."
        },
        {
          "filename": "source/common/http/http1/codec_impl.cc",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -1203,8 +1203,10 @@ ParserStatus ServerConnectionImpl::onMessageCompleteBase() {\n }\n \n void ServerConnectionImpl::onResetStream(StreamResetReason reason) {\n-  active_request_->response_encoder_.runResetCallbacks(reason);\n-  connection_.dispatcher().deferredDelete(std::move(active_request_));\n+  if (active_request_) {\n+    active_request_->response_encoder_.runResetCallbacks(reason);\n+    connection_.dispatcher().deferredDelete(std::move(active_request_));\n+  }\n }\n \n Status ServerConnectionImpl::sendProtocolError(absl::string_view details) {"
        },
        {
          "filename": "source/common/stream_info/stream_info_impl.h",
          "status": "modified",
          "additions": 16,
          "deletions": 2,
          "patch": "@@ -308,9 +308,23 @@ struct StreamInfoImpl : public StreamInfo {\n     ASSERT(downstream_bytes_meter_.get() == downstream_bytes_meter.get());\n   }\n \n+  // This function is used to persist relevant information from the original\n+  // stream into to the new one, when recreating the stream. Generally this\n+  // includes information about the downstream stream, but not the upstream\n+  // stream.\n+  void setFromForRecreateStream(StreamInfo& info) {\n+    downstream_timing_ = info.downstreamTiming();\n+    protocol_ = info.protocol();\n+    bytes_received_ = info.bytesReceived();\n+    downstream_bytes_meter_ = info.getDownstreamBytesMeter();\n+    // These two are set in the constructor, but to T(recreate), and should be T(create)\n+    start_time_ = info.startTime();\n+    start_time_monotonic_ = info.startTimeMonotonic();\n+  }\n+\n   TimeSource& time_source_;\n-  const SystemTime start_time_;\n-  const MonotonicTime start_time_monotonic_;\n+  SystemTime start_time_;\n+  MonotonicTime start_time_monotonic_;\n   absl::optional<MonotonicTime> final_time_;\n \n   absl::optional<Http::Protocol> protocol_;"
        },
        {
          "filename": "test/common/stream_info/stream_info_impl_test.cc",
          "status": "modified",
          "additions": 28,
          "deletions": 0,
          "patch": "@@ -219,6 +219,34 @@ TEST_F(StreamInfoImplTest, MiscSettersAndGetters) {\n   }\n }\n \n+TEST_F(StreamInfoImplTest, SetFrom) {\n+  StreamInfoImpl s1(Http::Protocol::Http2, test_time_.timeSystem(), nullptr);\n+\n+  s1.addBytesReceived(1);\n+  s1.downstreamTiming().onLastDownstreamRxByteReceived(test_time_.timeSystem());\n+\n+#ifdef __clang__\n+#if defined(__linux__)\n+#if defined(__has_feature) && !(__has_feature(thread_sanitizer))\n+  ASSERT_TRUE(sizeof(s1) == 760 || sizeof(s1) == 776 || sizeof(s1) == 800)\n+      << \"If adding fields to StreamInfoImpl, please check to see if you \"\n+         \"need to add them to setFromForRecreateStream! Current size \"\n+      << sizeof(s1);\n+#endif\n+#endif\n+#endif\n+\n+  StreamInfoImpl s2(Http::Protocol::Http11, test_time_.timeSystem(), nullptr);\n+  s2.setFromForRecreateStream(s1);\n+  EXPECT_EQ(s1.startTime(), s2.startTime());\n+  EXPECT_EQ(s1.startTimeMonotonic(), s2.startTimeMonotonic());\n+  EXPECT_EQ(s1.downstreamTiming().lastDownstreamRxByteReceived(),\n+            s2.downstreamTiming().lastDownstreamRxByteReceived());\n+  EXPECT_EQ(s1.protocol(), s2.protocol());\n+  EXPECT_EQ(s1.bytesReceived(), s2.bytesReceived());\n+  EXPECT_EQ(s1.getDownstreamBytesMeter(), s2.getDownstreamBytesMeter());\n+}\n+\n TEST_F(StreamInfoImplTest, DynamicMetadataTest) {\n   StreamInfoImpl stream_info(Http::Protocol::Http2, test_time_.timeSystem(), nullptr);\n "
        },
        {
          "filename": "test/integration/cds_integration_test.cc",
          "status": "modified",
          "additions": 46,
          "deletions": 0,
          "patch": "@@ -303,6 +303,52 @@ TEST_P(CdsIntegrationTest, TwoClusters) {\n   cleanupUpstreamAndDownstream();\n }\n \n+// Test internal redirect to a cluster removed during the backend think time.\n+TEST_P(CdsIntegrationTest, TwoClustersAndRedirects) {\n+  setDownstreamProtocol(Http::CodecType::HTTP1);\n+  config_helper_.addConfigModifier(\n+      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n+             hcm) {\n+        auto* route = hcm.mutable_route_config()->mutable_virtual_hosts(0)->mutable_routes(1);\n+        route->mutable_route()\n+            ->mutable_internal_redirect_policy()\n+            ->mutable_redirect_response_codes()\n+            ->Add(302);\n+      });\n+\n+  // Tell Envoy that cluster_2 is here.\n+  initialize();\n+  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(\n+      Config::TypeUrl::get().Cluster, {cluster1_, cluster2_}, {cluster2_}, {}, \"42\");\n+  // The '3' includes the fake CDS server.\n+  test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 3);\n+  // Tell Envoy that cluster_1 is gone.\n+  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster,\n+                                                             {cluster2_}, {}, {ClusterName1}, \"43\");\n+  test_server_->waitForCounterGe(\"cluster_manager.cluster_removed\", 1);\n+\n+  codec_client_ = makeHttpConnection(makeClientConnection((lookupPort(\"http\"))));\n+  default_request_headers_.setPath(\"/cluster2\");\n+  default_request_headers_.setContentLength(\"4\");\n+  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n+  Buffer::OwnedImpl data(\"body\");\n+  encoder_decoder.first.encodeData(data, true);\n+  auto& response = encoder_decoder.second;\n+\n+  ASSERT_TRUE(fake_upstreams_[UpstreamIndex2]->waitForHttpConnection(*dispatcher_,\n+                                                                     fake_upstream_connection_));\n+  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n+  ASSERT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));\n+\n+  Http::TestResponseHeaderMapImpl redirect_response{\n+      {\":status\", \"302\"}, {\"content-length\", \"0\"}, {\"location\", \"http://host/cluster1\"}};\n+\n+  // Send a response to the original request redirecting to the deleted cluster.\n+  upstream_request_->encodeHeaders(redirect_response, true);\n+  ASSERT_TRUE(response->waitForEndStream());\n+  EXPECT_EQ(\"503\", response->headers().getStatusValue());\n+}\n+\n // Tests that when Envoy's delta xDS stream dis/reconnects, Envoy can inform the server of the\n // resources it already has: the reconnected stream need not start with a state-of-the-world update.\n TEST_P(CdsIntegrationTest, VersionsRememberedAfterReconnect) {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 5,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "ad2a1c700b1cc6c8b1581bc3e2990d696501f105",
            "date": "2025-01-24T15:25:19Z",
            "author_login": "asedeno"
          },
          {
            "sha": "969348a552e76101e5dadde6b8f65694a5198fdf",
            "date": "2025-01-24T11:36:03Z",
            "author_login": "zirain"
          },
          {
            "sha": "2a9c998e1732f07f597acfa10c23342730c8fdc4",
            "date": "2025-01-24T11:11:22Z",
            "author_login": "krinkinmu"
          },
          {
            "sha": "ae6cb3254cbf98999993d0120d289a207a57f825",
            "date": "2025-01-24T10:58:35Z",
            "author_login": "mathetake"
          },
          {
            "sha": "6f5bdbf15f61efc9876f468754857ce0a28d65a3",
            "date": "2025-01-23T20:43:22Z",
            "author_login": "fredyw"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-416",
    "description": "Envoy is a cloud-native high-performance edge/middle/service proxy. In versions prior to 1.22.1 if Envoy attempts to send an internal redirect of an HTTP request consisting of more than HTTP headers, there\u2019s a lifetime bug which can be triggered. If while replaying the request Envoy sends a local reply when the redirect headers are processed, the downstream state indicates that the downstream stream is not complete. On sending the local reply, Envoy will attempt to reset the upstream stream, but as it is actually complete, and deleted, this result in a use-after-free. Users are advised to upgrade. Users unable to upgrade are advised to disable internal redirects if crashes are observed.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-06-09T20:15:08.140",
    "last_modified": "2024-11-21T06:58:45.730",
    "fix_date": "2022-06-08T23:10:39Z"
  },
  "references": [
    {
      "url": "https://github.com/envoyproxy/envoy/commit/fe7c69c248f4fe5a9080c7ccb35275b5218bb5ab",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-rm2p-qvf6-pvr6",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/commit/fe7c69c248f4fe5a9080c7ccb35275b5218bb5ab",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-rm2p-qvf6-pvr6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:09.426318",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "envoy",
    "owner": "envoyproxy",
    "created_at": "2016-08-08T15:07:24Z",
    "updated_at": "2025-01-26T06:15:25Z",
    "pushed_at": "2025-01-24T15:25:20Z",
    "size": 241791,
    "stars": 25373,
    "forks": 4864,
    "open_issues": 1660,
    "watchers": 25373,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C++": 48447088,
      "Starlark": 3112278,
      "Java": 1321815,
      "Python": 604443,
      "Assembly": 327095,
      "Kotlin": 309606,
      "Swift": 250537,
      "Shell": 231950,
      "Go": 183281,
      "Rust": 107631,
      "JavaScript": 66339,
      "C": 61597,
      "Objective-C++": 55490,
      "Objective-C": 48840,
      "Jinja": 47798,
      "Smarty": 3528,
      "CSS": 2927,
      "HTML": 1522,
      "Emacs Lisp": 966,
      "Dockerfile": 960,
      "Thrift": 748,
      "PureBasic": 472,
      "Batchfile": 439,
      "Makefile": 303
    },
    "commit_activity": {
      "total_commits_last_year": 3237,
      "avg_commits_per_week": 62.25,
      "days_active_last_year": 300
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:41:58.674890"
  }
}