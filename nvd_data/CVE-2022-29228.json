{
  "cve_id": "CVE-2022-29228",
  "github_data": {
    "repository": "envoyproxy/envoy",
    "fix_commit": "7ffda4e809dec74449ebc330cebb9d2f4ab61360",
    "related_commits": [
      "7ffda4e809dec74449ebc330cebb9d2f4ab61360",
      "7ffda4e809dec74449ebc330cebb9d2f4ab61360"
    ],
    "patch_url": "https://github.com/envoyproxy/envoy/commit/7ffda4e809dec74449ebc330cebb9d2f4ab61360.patch",
    "fix_commit_details": {
      "sha": "7ffda4e809dec74449ebc330cebb9d2f4ab61360",
      "commit_date": "2022-06-08T23:10:04Z",
      "author": {
        "login": "pradeepcrao",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "oauth2: do not blindly accept requests with a token in the Authorization headera (781)",
        "length": 933,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 149,
        "additions": 61,
        "deletions": 88
      },
      "files": [
        {
          "filename": "source/extensions/filters/http/oauth2/filter.cc",
          "status": "modified",
          "additions": 7,
          "deletions": 51,
          "patch": "@@ -203,31 +203,6 @@ const std::string& OAuth2Filter::bearerPrefix() const {\n   CONSTRUCT_ON_FIRST_USE(std::string, \"bearer \");\n }\n \n-std::string OAuth2Filter::extractAccessToken(const Http::RequestHeaderMap& headers) const {\n-  ASSERT(headers.Path() != nullptr);\n-\n-  // Start by looking for a bearer token in the Authorization header.\n-  const Http::HeaderEntry* authorization = headers.getInline(authorization_handle.handle());\n-  if (authorization != nullptr) {\n-    const auto value = StringUtil::trim(authorization->value().getStringView());\n-    const auto& bearer_prefix = bearerPrefix();\n-    if (absl::StartsWithIgnoreCase(value, bearer_prefix)) {\n-      const size_t start = bearer_prefix.length();\n-      return std::string(StringUtil::ltrim(value.substr(start)));\n-    }\n-  }\n-\n-  // Check for the named query string parameter.\n-  const auto path = headers.Path()->value().getStringView();\n-  const auto params = Http::Utility::parseQueryString(path);\n-  const auto param = params.find(\"token\");\n-  if (param != params.end()) {\n-    return param->second;\n-  }\n-\n-  return EMPTY_STRING;\n-}\n-\n /**\n  * primary cases:\n  * 1) user is signing out\n@@ -236,6 +211,10 @@ std::string OAuth2Filter::extractAccessToken(const Http::RequestHeaderMap& heade\n  * 4) user is unauthorized\n  */\n Http::FilterHeadersStatus OAuth2Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool) {\n+  // Sanitize the Authorization header, since we have no way to validate its content. Also,\n+  // if token forwarding is enabled, this header will be set based on what is on the HMAC cookie\n+  // before forwarding the request upstream.\n+  headers.removeInline(authorization_handle.handle());\n \n   // The following 2 headers are guaranteed for regular requests. The asserts are helpful when\n   // writing test code to not forget these important variables in mock requests\n@@ -290,17 +269,7 @@ Http::FilterHeadersStatus OAuth2Filter::decodeHeaders(Http::RequestHeaderMap& he\n     request_headers_ = &headers;\n   }\n \n-  // If a bearer token is supplied as a header or param, we ingest it here and kick off the\n-  // user resolution immediately. Note this comes after HMAC validation, so technically this\n-  // header is sanitized in a way, as the validation check forces the correct Bearer Cookie value.\n-  access_token_ = extractAccessToken(headers);\n-  if (!access_token_.empty()) {\n-    found_bearer_token_ = true;\n-    finishFlow();\n-    return Http::FilterHeadersStatus::Continue;\n-  }\n-\n-  // If no access token and this isn't the callback URI, redirect to acquire credentials.\n+  // If this isn't the callback URI, redirect to acquire credentials.\n   //\n   // The following conditional could be replaced with a regex pattern-match,\n   // if we're concerned about strict matching against the callback path.\n@@ -439,18 +408,6 @@ void OAuth2Filter::onGetAccessTokenSuccess(const std::string& access_code,\n }\n \n void OAuth2Filter::finishFlow() {\n-\n-  // We have fully completed the entire OAuth flow, whether through Authorization header or from\n-  // user redirection to the auth server.\n-  if (found_bearer_token_) {\n-    if (config_->forwardBearerToken()) {\n-      setBearerToken(*request_headers_, access_token_);\n-    }\n-    config_->stats().oauth_success_.inc();\n-    decoder_callbacks_->continueDecoding();\n-    return;\n-  }\n-\n   std::string token_payload;\n   if (config_->forwardBearerToken()) {\n     token_payload = absl::StrCat(host_, new_expires_, access_token_, id_token_, refresh_token_);\n@@ -472,8 +429,8 @@ void OAuth2Filter::finishFlow() {\n   const std::string cookie_tail_http_only =\n       fmt::format(CookieTailHttpOnlyFormatString, new_expires_);\n \n-  // At this point we have all of the pieces needed to authorize a user that did not originally\n-  // have a bearer access token. Now, we construct a redirect request to return the user to their\n+  // At this point we have all of the pieces needed to authorize a user.\n+  // Now, we construct a redirect request to return the user to their\n   // previous state and additionally set the OAuth cookies in browser.\n   // The redirection should result in successfully passing this filter.\n   Http::ResponseHeaderMapPtr response_headers{Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n@@ -509,7 +466,6 @@ void OAuth2Filter::finishFlow() {\n \n   decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_LOGGED_IN);\n   config_->stats().oauth_success_.inc();\n-  decoder_callbacks_->continueDecoding();\n }\n \n void OAuth2Filter::sendUnauthorizedResponse() {"
        },
        {
          "filename": "source/extensions/filters/http/oauth2/filter.h",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -243,7 +243,6 @@ class OAuth2Filter : public Http::PassThroughDecoderFilter, public FilterCallbac\n   std::string new_expires_;\n   absl::string_view host_;\n   std::string state_;\n-  bool found_bearer_token_{false};\n   Http::RequestHeaderMap* request_headers_{nullptr};\n \n   std::unique_ptr<OAuth2Client> oauth_client_;\n@@ -257,7 +256,6 @@ class OAuth2Filter : public Http::PassThroughDecoderFilter, public FilterCallbac\n   Http::FilterHeadersStatus signOutUser(const Http::RequestHeaderMap& headers);\n \n   const std::string& bearerPrefix() const;\n-  std::string extractAccessToken(const Http::RequestHeaderMap& headers) const;\n };\n \n } // namespace Oauth2"
        },
        {
          "filename": "source/extensions/filters/http/oauth2/oauth_client.cc",
          "status": "modified",
          "additions": 0,
          "deletions": 3,
          "patch": "@@ -21,9 +21,6 @@ namespace HttpFilters {\n namespace Oauth2 {\n \n namespace {\n-Http::RegisterCustomInlineHeader<Http::CustomInlineHeaderRegistry::Type::RequestHeaders>\n-    authorization_handle(Http::CustomHeaders::get().Authorization);\n-\n constexpr const char* GetAccessTokenBodyFormatString =\n     \"grant_type=authorization_code&code={0}&client_id={1}&client_secret={2}&redirect_uri={3}\";\n "
        },
        {
          "filename": "test/extensions/filters/http/oauth2/filter_test.cc",
          "status": "modified",
          "additions": 54,
          "deletions": 32,
          "patch": "@@ -95,7 +95,7 @@ class OAuth2Test : public testing::Test {\n   }\n \n   // Set up proto fields with standard config.\n-  FilterConfigSharedPtr getConfig() {\n+  FilterConfigSharedPtr getConfig(bool forward_bearer_token = true) {\n     envoy::extensions::filters::http::oauth2::v3::OAuth2Config p;\n     auto* endpoint = p.mutable_token_endpoint();\n     endpoint->set_cluster(\"auth.example.com\");\n@@ -105,7 +105,7 @@ class OAuth2Test : public testing::Test {\n     p.mutable_redirect_path_matcher()->mutable_path()->set_exact(TEST_CALLBACK);\n     p.set_authorization_endpoint(\"https://auth.example.com/oauth/authorize/\");\n     p.mutable_signout_path()->mutable_path()->set_exact(\"/_signout\");\n-    p.set_forward_bearer_token(true);\n+    p.set_forward_bearer_token(forward_bearer_token);\n     p.add_auth_scopes(\"user\");\n     p.add_auth_scopes(\"openid\");\n     p.add_auth_scopes(\"email\");\n@@ -422,6 +422,50 @@ TEST_F(OAuth2Test, OAuthOkPass) {\n   EXPECT_EQ(scope_.counterFromString(\"test.oauth_success\").value(), 1);\n }\n \n+/**\n+ * Scenario: The OAuth filter receives a request to an arbitrary path with valid OAuth cookies\n+ * (cookie values and validation are mocked out), but with an invalid token in the Authorization\n+ * header and forwarding bearer token is disabled.\n+ *\n+ * Expected behavior: the filter should sanitize the Authorization header and let the request\n+ * proceed.\n+ */\n+TEST_F(OAuth2Test, OAuthOkPassButInvalidToken) {\n+  init(getConfig(false /* forward_bearer_token */));\n+\n+  Http::TestRequestHeaderMapImpl mock_request_headers{\n+      {Http::Headers::get().Path.get(), \"/anypath\"},\n+      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n+      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n+      {Http::Headers::get().Scheme.get(), \"https\"},\n+      {Http::CustomHeaders::get().Authorization.get(), \"Bearer injected_malice!\"},\n+  };\n+\n+  Http::TestRequestHeaderMapImpl expected_headers{\n+      {Http::Headers::get().Path.get(), \"/anypath\"},\n+      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n+      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n+      {Http::Headers::get().Scheme.get(), \"https\"},\n+  };\n+\n+  // cookie-validation mocking\n+  EXPECT_CALL(*validator_, setParams(_, _));\n+  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(true));\n+\n+  // Sanitized return reference mocking\n+  std::string legit_token{\"legit_token\"};\n+  EXPECT_CALL(*validator_, token()).WillRepeatedly(ReturnRef(legit_token));\n+\n+  EXPECT_EQ(Http::FilterHeadersStatus::Continue,\n+            filter_->decodeHeaders(mock_request_headers, false));\n+\n+  // Ensure that existing OAuth forwarded headers got sanitized.\n+  EXPECT_EQ(mock_request_headers, expected_headers);\n+\n+  EXPECT_EQ(scope_.counterFromString(\"test.oauth_failure\").value(), 0);\n+  EXPECT_EQ(scope_.counterFromString(\"test.oauth_success\").value(), 1);\n+}\n+\n /**\n  * Scenario: The OAuth filter receives a request without valid OAuth cookies to a non-callback URL\n  * (indicating that the user needs to re-validate cookies or get 401'd).\n@@ -790,63 +834,41 @@ TEST_F(OAuth2Test, OAuthTestFullFlowPostWithParameters) {\n \n   EXPECT_CALL(decoder_callbacks_,\n               encodeHeaders_(HeaderMapEqualRef(&second_response_headers), true));\n-  EXPECT_CALL(decoder_callbacks_, continueDecoding());\n \n   filter_->finishFlow();\n }\n \n TEST_F(OAuth2Test, OAuthBearerTokenFlowFromHeader) {\n-  Http::TestRequestHeaderMapImpl request_headers_before{\n-      {Http::Headers::get().Path.get(), \"/test?role=bearer\"},\n-      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n-      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n-      {Http::Headers::get().Scheme.get(), \"https\"},\n-      {Http::CustomHeaders::get().Authorization.get(), \"Bearer xyz-header-token\"},\n-  };\n-  // Expected decoded headers after the callback & validation of the bearer token is complete.\n-  Http::TestRequestHeaderMapImpl request_headers_after{\n+  Http::TestRequestHeaderMapImpl request_headers{\n       {Http::Headers::get().Path.get(), \"/test?role=bearer\"},\n       {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n       {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n       {Http::Headers::get().Scheme.get(), \"https\"},\n       {Http::CustomHeaders::get().Authorization.get(), \"Bearer xyz-header-token\"},\n   };\n \n-  // Fail the validation to trigger the OAuth flow.\n+  // Fail the validation.\n   EXPECT_CALL(*validator_, setParams(_, _));\n   EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n \n-  EXPECT_EQ(Http::FilterHeadersStatus::Continue,\n-            filter_->decodeHeaders(request_headers_before, false));\n-\n-  // Finally, expect that the header map had OAuth information appended to it.\n-  EXPECT_EQ(request_headers_before, request_headers_after);\n+  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n+            filter_->decodeHeaders(request_headers, false));\n }\n \n TEST_F(OAuth2Test, OAuthBearerTokenFlowFromQueryParameters) {\n-  Http::TestRequestHeaderMapImpl request_headers_before{\n-      {Http::Headers::get().Path.get(), \"/test?role=bearer&token=xyz-queryparam-token\"},\n-      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n-      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n-      {Http::Headers::get().Scheme.get(), \"https\"},\n-  };\n-  Http::TestRequestHeaderMapImpl request_headers_after{\n+  Http::TestRequestHeaderMapImpl request_headers{\n       {Http::Headers::get().Path.get(), \"/test?role=bearer&token=xyz-queryparam-token\"},\n       {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n       {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n       {Http::Headers::get().Scheme.get(), \"https\"},\n-      {Http::CustomHeaders::get().Authorization.get(), \"Bearer xyz-queryparam-token\"},\n   };\n \n-  // Fail the validation to trigger the OAuth flow.\n+  // Fail the validation.\n   EXPECT_CALL(*validator_, setParams(_, _));\n   EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n \n-  EXPECT_EQ(Http::FilterHeadersStatus::Continue,\n-            filter_->decodeHeaders(request_headers_before, false));\n-\n-  // Expected decoded headers after the callback & validation of the bearer token is complete.\n-  EXPECT_EQ(request_headers_before, request_headers_after);\n+  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n+            filter_->decodeHeaders(request_headers, false));\n }\n \n } // namespace Oauth2"
        }
      ],
      "file_patterns": {
        "security_files": 4,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c93cf7af47f7e24c83b563d3b956074333bc4bf7",
            "date": "2025-01-14T17:23:07Z",
            "author_login": "phlax"
          },
          {
            "sha": "078dae3549912e632c3776a5e9a4679226093276",
            "date": "2025-01-14T14:27:08Z",
            "author_login": "agrawroh"
          },
          {
            "sha": "7b20933ee263eb9aeaceee6bc309b80b997cbbb2",
            "date": "2025-01-14T14:13:49Z",
            "author_login": "phlax"
          },
          {
            "sha": "03cb8d59f80a2a75d9e1289c909e5979a79ace91",
            "date": "2025-01-13T06:31:54Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "3487b225f48717dd5a2babb5f921df4353633cee",
            "date": "2025-01-13T06:10:11Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-617",
    "description": "Envoy is a cloud-native high-performance proxy. In versions prior to 1.22.1 the OAuth filter would try to invoke the remaining filters in the chain after emitting a local response, which triggers an ASSERT() in newer versions and corrupts memory on earlier versions. continueDecoding() shouldn\u2019t ever be called from filters after a local reply has been sent. Users are advised to upgrade. There are no known workarounds for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-06-09T20:15:08.197",
    "last_modified": "2024-11-21T06:58:45.850",
    "fix_date": "2022-06-08T23:10:04Z"
  },
  "references": [
    {
      "url": "https://github.com/envoyproxy/envoy/commit/7ffda4e809dec74449ebc330cebb9d2f4ab61360",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-rww6-8h7g-8jf6",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/commit/7ffda4e809dec74449ebc330cebb9d2f4ab61360",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-rww6-8h7g-8jf6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:09.426459",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "envoy",
    "owner": "envoyproxy",
    "created_at": "2016-08-08T15:07:24Z",
    "updated_at": "2025-01-14T12:22:22Z",
    "pushed_at": "2025-01-14T05:36:17Z",
    "size": 240648,
    "stars": 25321,
    "forks": 4848,
    "open_issues": 1639,
    "watchers": 25321,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C++": 48293036,
      "Starlark": 3105942,
      "Java": 1320095,
      "Python": 605206,
      "Assembly": 327095,
      "Kotlin": 309606,
      "Swift": 250537,
      "Shell": 229801,
      "Go": 183281,
      "Rust": 107190,
      "JavaScript": 66339,
      "C": 61597,
      "Objective-C++": 55490,
      "Objective-C": 48840,
      "Jinja": 47798,
      "Smarty": 3528,
      "CSS": 2927,
      "HTML": 1522,
      "Emacs Lisp": 966,
      "Dockerfile": 960,
      "Thrift": 748,
      "PureBasic": 472,
      "Batchfile": 439,
      "Makefile": 303
    },
    "commit_activity": {
      "total_commits_last_year": 3286,
      "avg_commits_per_week": 63.19230769230769,
      "days_active_last_year": 303
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:55:59.245540"
  }
}