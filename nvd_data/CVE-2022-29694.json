{
  "cve_id": "CVE-2022-29694",
  "github_data": {
    "repository": "unicorn-engine/unicorn",
    "fix_commit": "3d3deac5e6d38602b689c4fef5dac004f07a2e63",
    "related_commits": [
      "3d3deac5e6d38602b689c4fef5dac004f07a2e63",
      "3d3deac5e6d38602b689c4fef5dac004f07a2e63"
    ],
    "patch_url": "https://github.com/unicorn-engine/unicorn/commit/3d3deac5e6d38602b689c4fef5dac004f07a2e63.patch",
    "fix_commit_details": {
      "sha": "3d3deac5e6d38602b689c4fef5dac004f07a2e63",
      "commit_date": "2022-04-16T17:17:41Z",
      "author": {
        "login": "wtdcode",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix crash when mapping a big memory and calling uc_close",
        "length": 56,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 361,
        "additions": 353,
        "deletions": 8
      },
      "files": [
        {
          "filename": "qemu/exec.c",
          "status": "modified",
          "additions": 15,
          "deletions": 6,
          "patch": "@@ -42,7 +42,7 @@\n #include \"exec/ram_addr.h\"\n \n #include \"qemu/range.h\"\n-\n+#include \"qemu/rcu_queue.h\"\n #include \"uc_priv.h\"\n \n typedef struct PhysPageEntry PhysPageEntry;\n@@ -966,7 +966,7 @@ static ram_addr_t find_ram_offset(struct uc_struct *uc, ram_addr_t size)\n \n     assert(size != 0); /* it would hand out same offset multiple times */\n \n-    if (QLIST_EMPTY(&uc->ram_list.blocks)) {\n+    if (QLIST_EMPTY_RCU(&uc->ram_list.blocks)) {\n         return 0;\n     }\n \n@@ -1043,6 +1043,8 @@ static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n         new_block->host = phys_mem_alloc(uc, new_block->max_length,\n                 &new_block->mr->align);\n         if (!new_block->host) {\n+            // mmap fails.\n+            uc->invalid_error = UC_ERR_NOMEM;\n             // error_setg_errno(errp, errno,\n             //         \"cannot set up guest memory '%s'\",\n             //         memory_region_name(new_block->mr));\n@@ -1062,11 +1064,11 @@ static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n         }\n     }\n     if (block) {\n-        QLIST_INSERT_BEFORE(block, new_block, next);\n+        QLIST_INSERT_BEFORE_RCU(block, new_block, next);\n     } else if (last_block) {\n-        QLIST_INSERT_AFTER(last_block, new_block, next);\n+        QLIST_INSERT_AFTER_RCU(last_block, new_block, next);\n     } else { /* list is empty */\n-        QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next);\n+        QLIST_INSERT_HEAD_RCU(&uc->ram_list.blocks, new_block, next);\n     }\n     uc->ram_list.mru_block = NULL;\n \n@@ -1099,8 +1101,15 @@ RAMBlock *qemu_ram_alloc_from_ptr(struct uc_struct *uc, ram_addr_t size, void *h\n     if (host) {\n         new_block->flags |= RAM_PREALLOC;\n     }\n+\n+    uc->invalid_addr = UC_ERR_OK;\n     ram_block_add(mr->uc, new_block);\n \n+    if (uc->invalid_error != UC_ERR_OK) {\n+        g_free(new_block);\n+        return NULL;\n+    }\n+\n     return new_block;\n }\n \n@@ -1130,7 +1139,7 @@ void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n     //    ram_block_notify_remove(block->host, block->max_length);\n     //}\n \n-    QLIST_REMOVE(block, next);\n+    QLIST_REMOVE_RCU(block, next);\n     uc->ram_list.mru_block = NULL;\n     /* Write list before version */\n     //smp_wmb();"
        },
        {
          "filename": "qemu/include/qemu/atomic.h",
          "status": "modified",
          "additions": 53,
          "deletions": 0,
          "patch": "@@ -115,6 +115,19 @@\n     atomic_set__nocheck(ptr, i);                      \\\n } while(0)\n \n+#define atomic_rcu_read(ptr)                          \\\n+    ({                                                \\\n+    QEMU_BUILD_BUG_ON(sizeof(*ptr) > ATOMIC_REG_SIZE); \\\n+    typeof_strip_qual(*ptr) _val;                     \\\n+    atomic_rcu_read__nocheck(ptr, &_val);             \\\n+    _val;                                             \\\n+    })\n+\n+#define atomic_rcu_set(ptr, i) do {                   \\\n+    QEMU_BUILD_BUG_ON(sizeof(*ptr) > ATOMIC_REG_SIZE); \\\n+    __atomic_store_n(ptr, i, __ATOMIC_RELEASE);       \\\n+} while(0)\n+\n /* All the remaining operations are fully sequentially consistent */\n \n #define atomic_xchg__nocheck(ptr, i)    ({                  \\\n@@ -192,6 +205,46 @@\n #define atomic_read(ptr)       atomic_read__nocheck(ptr)\n #define atomic_set(ptr, i)     atomic_set__nocheck(ptr,i)\n \n+/**\n+ * atomic_rcu_read - reads a RCU-protected pointer to a local variable\n+ * into a RCU read-side critical section. The pointer can later be safely\n+ * dereferenced within the critical section.\n+ *\n+ * This ensures that the pointer copy is invariant thorough the whole critical\n+ * section.\n+ *\n+ * Inserts memory barriers on architectures that require them (currently only\n+ * Alpha) and documents which pointers are protected by RCU.\n+ *\n+ * atomic_rcu_read also includes a compiler barrier to ensure that\n+ * value-speculative optimizations (e.g. VSS: Value Speculation\n+ * Scheduling) does not perform the data read before the pointer read\n+ * by speculating the value of the pointer.\n+ *\n+ * Should match atomic_rcu_set(), atomic_xchg(), atomic_cmpxchg().\n+ */\n+#define atomic_rcu_read(ptr)    ({                \\\n+    typeof(*ptr) _val = atomic_read(ptr);         \\\n+    smp_read_barrier_depends();                   \\\n+    _val;                                         \\\n+})\n+\n+/**\n+ * atomic_rcu_set - assigns (publicizes) a pointer to a new data structure\n+ * meant to be read by RCU read-side critical sections.\n+ *\n+ * Documents which pointers will be dereferenced by RCU read-side critical\n+ * sections and adds the required memory barriers on architectures requiring\n+ * them. It also makes sure the compiler does not reorder code initializing the\n+ * data structure before its publication.\n+ *\n+ * Should match atomic_rcu_read().\n+ */\n+#define atomic_rcu_set(ptr, i)  do {              \\\n+    smp_wmb();                                    \\\n+    atomic_set(ptr, i);                           \\\n+} while (0)\n+\n #define atomic_xchg__nocheck  atomic_xchg\n \n /* Provide shorter names for GCC atomic builtins.  */"
        },
        {
          "filename": "qemu/include/qemu/rcu_queue.h",
          "status": "added",
          "additions": 268,
          "deletions": 0,
          "patch": "@@ -0,0 +1,268 @@\n+#ifndef QEMU_RCU_QUEUE_H\n+#define QEMU_RCU_QUEUE_H\n+\n+/*\n+ * rcu_queue.h\n+ *\n+ * RCU-friendly versions of the queue.h primitives.\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2.1 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n+ *\n+ * Copyright (c) 2013 Mike D. Day, IBM Corporation.\n+ *\n+ * IBM's contributions to this file may be relicensed under LGPLv2 or later.\n+ */\n+\n+#include \"qemu/queue.h\"\n+#include \"qemu/atomic.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\n+/*\n+ * List access methods.\n+ */\n+#define QLIST_EMPTY_RCU(head) (atomic_read(&(head)->lh_first) == NULL)\n+#define QLIST_FIRST_RCU(head) (atomic_rcu_read(&(head)->lh_first))\n+#define QLIST_NEXT_RCU(elm, field) (atomic_rcu_read(&(elm)->field.le_next))\n+\n+/*\n+ * List functions.\n+ */\n+\n+\n+/*\n+ *  The difference between atomic_read/set and atomic_rcu_read/set\n+ *  is in the including of a read/write memory barrier to the volatile\n+ *  access. atomic_rcu_* macros include the memory barrier, the\n+ *  plain atomic macros do not. Therefore, it should be correct to\n+ *  issue a series of reads or writes to the same element using only\n+ *  the atomic_* macro, until the last read or write, which should be\n+ *  atomic_rcu_* to introduce a read or write memory barrier as\n+ *  appropriate.\n+ */\n+\n+/* Upon publication of the listelm->next value, list readers\n+ * will see the new node when following next pointers from\n+ * antecedent nodes, but may not see the new node when following\n+ * prev pointers from subsequent nodes until after the RCU grace\n+ * period expires.\n+ * see linux/include/rculist.h __list_add_rcu(new, prev, next)\n+ */\n+#define QLIST_INSERT_AFTER_RCU(listelm, elm, field) do {    \\\n+    (elm)->field.le_next = (listelm)->field.le_next;        \\\n+    (elm)->field.le_prev = &(listelm)->field.le_next;       \\\n+    atomic_rcu_set(&(listelm)->field.le_next, (elm));       \\\n+    if ((elm)->field.le_next != NULL) {                     \\\n+       (elm)->field.le_next->field.le_prev =                \\\n+        &(elm)->field.le_next;                              \\\n+    }                                                       \\\n+} while (/*CONSTCOND*/0)\n+\n+/* Upon publication of the listelm->prev->next value, list\n+ * readers will see the new element when following prev pointers\n+ * from subsequent elements, but may not see the new element\n+ * when following next pointers from antecedent elements\n+ * until after the RCU grace period expires.\n+ */\n+#define QLIST_INSERT_BEFORE_RCU(listelm, elm, field) do {   \\\n+    (elm)->field.le_prev = (listelm)->field.le_prev;        \\\n+    (elm)->field.le_next = (listelm);                       \\\n+    atomic_rcu_set((listelm)->field.le_prev, (elm));        \\\n+    (listelm)->field.le_prev = &(elm)->field.le_next;       \\\n+} while (/*CONSTCOND*/0)\n+\n+/* Upon publication of the head->first value, list readers\n+ * will see the new element when following the head, but may\n+ * not see the new element when following prev pointers from\n+ * subsequent elements until after the RCU grace period has\n+ * expired.\n+ */\n+#define QLIST_INSERT_HEAD_RCU(head, elm, field) do {    \\\n+    (elm)->field.le_prev = &(head)->lh_first;           \\\n+    (elm)->field.le_next = (head)->lh_first;            \\\n+    atomic_rcu_set((&(head)->lh_first), (elm));         \\\n+    if ((elm)->field.le_next != NULL) {                 \\\n+       (elm)->field.le_next->field.le_prev =            \\\n+        &(elm)->field.le_next;                          \\\n+    }                                                   \\\n+} while (/*CONSTCOND*/0)\n+\n+\n+/* prior to publication of the elm->prev->next value, some list\n+ * readers may still see the removed element when following\n+ * the antecedent's next pointer.\n+ */\n+#define QLIST_REMOVE_RCU(elm, field) do {           \\\n+    if ((elm)->field.le_next != NULL) {             \\\n+       (elm)->field.le_next->field.le_prev =        \\\n+        (elm)->field.le_prev;                       \\\n+    }                                               \\\n+    atomic_set((elm)->field.le_prev, (elm)->field.le_next); \\\n+} while (/*CONSTCOND*/0)\n+\n+/* List traversal must occur within an RCU critical section.  */\n+#define QLIST_FOREACH_RCU(var, head, field)                 \\\n+        for ((var) = atomic_rcu_read(&(head)->lh_first);    \\\n+                (var);                                      \\\n+                (var) = atomic_rcu_read(&(var)->field.le_next))\n+\n+/* List traversal must occur within an RCU critical section.  */\n+#define QLIST_FOREACH_SAFE_RCU(var, head, field, next_var)           \\\n+    for ((var) = (atomic_rcu_read(&(head)->lh_first));               \\\n+      (var) &&                                                       \\\n+          ((next_var) = atomic_rcu_read(&(var)->field.le_next), 1);  \\\n+           (var) = (next_var))\n+\n+/*\n+ * RCU simple queue\n+ */\n+\n+/* Simple queue access methods */\n+#define QSIMPLEQ_EMPTY_RCU(head)      (atomic_read(&(head)->sqh_first) == NULL)\n+#define QSIMPLEQ_FIRST_RCU(head)       atomic_rcu_read(&(head)->sqh_first)\n+#define QSIMPLEQ_NEXT_RCU(elm, field)  atomic_rcu_read(&(elm)->field.sqe_next)\n+\n+/* Simple queue functions */\n+#define QSIMPLEQ_INSERT_HEAD_RCU(head, elm, field) do {         \\\n+    (elm)->field.sqe_next = (head)->sqh_first;                  \\\n+    if ((elm)->field.sqe_next == NULL) {                        \\\n+        (head)->sqh_last = &(elm)->field.sqe_next;              \\\n+    }                                                           \\\n+    atomic_rcu_set(&(head)->sqh_first, (elm));                  \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QSIMPLEQ_INSERT_TAIL_RCU(head, elm, field) do {    \\\n+    (elm)->field.sqe_next = NULL;                          \\\n+    atomic_rcu_set((head)->sqh_last, (elm));               \\\n+    (head)->sqh_last = &(elm)->field.sqe_next;             \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QSIMPLEQ_INSERT_AFTER_RCU(head, listelm, elm, field) do {       \\\n+    (elm)->field.sqe_next = (listelm)->field.sqe_next;                  \\\n+    if ((elm)->field.sqe_next == NULL) {                                \\\n+        (head)->sqh_last = &(elm)->field.sqe_next;                      \\\n+    }                                                                   \\\n+    atomic_rcu_set(&(listelm)->field.sqe_next, (elm));                  \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QSIMPLEQ_REMOVE_HEAD_RCU(head, field) do {                     \\\n+    atomic_set(&(head)->sqh_first, (head)->sqh_first->field.sqe_next); \\\n+    if ((head)->sqh_first == NULL) {                                   \\\n+        (head)->sqh_last = &(head)->sqh_first;                         \\\n+    }                                                                  \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QSIMPLEQ_REMOVE_RCU(head, elm, type, field) do {            \\\n+    if ((head)->sqh_first == (elm)) {                               \\\n+        QSIMPLEQ_REMOVE_HEAD_RCU((head), field);                    \\\n+    } else {                                                        \\\n+        struct type *curr = (head)->sqh_first;                      \\\n+        while (curr->field.sqe_next != (elm)) {                     \\\n+            curr = curr->field.sqe_next;                            \\\n+        }                                                           \\\n+        atomic_set(&curr->field.sqe_next,                           \\\n+                   curr->field.sqe_next->field.sqe_next);           \\\n+        if (curr->field.sqe_next == NULL) {                         \\\n+            (head)->sqh_last = &(curr)->field.sqe_next;             \\\n+        }                                                           \\\n+    }                                                               \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QSIMPLEQ_FOREACH_RCU(var, head, field)                          \\\n+    for ((var) = atomic_rcu_read(&(head)->sqh_first);                   \\\n+         (var);                                                         \\\n+         (var) = atomic_rcu_read(&(var)->field.sqe_next))\n+\n+#define QSIMPLEQ_FOREACH_SAFE_RCU(var, head, field, next)                \\\n+    for ((var) = atomic_rcu_read(&(head)->sqh_first);                    \\\n+         (var) && ((next) = atomic_rcu_read(&(var)->field.sqe_next), 1); \\\n+         (var) = (next))\n+\n+/*\n+ * RCU tail queue\n+ */\n+\n+/* Tail queue access methods */\n+#define QTAILQ_EMPTY_RCU(head)      (atomic_read(&(head)->tqh_first) == NULL)\n+#define QTAILQ_FIRST_RCU(head)       atomic_rcu_read(&(head)->tqh_first)\n+#define QTAILQ_NEXT_RCU(elm, field)  atomic_rcu_read(&(elm)->field.tqe_next)\n+\n+/* Tail queue functions */\n+#define QTAILQ_INSERT_HEAD_RCU(head, elm, field) do {                   \\\n+    (elm)->field.tqe_next = (head)->tqh_first;                          \\\n+    if ((elm)->field.tqe_next != NULL) {                                \\\n+        (head)->tqh_first->field.tqe_circ.tql_prev =                    \\\n+            &(elm)->field.tqe_circ;                                     \\\n+    } else {                                                            \\\n+        (head)->tqh_circ.tql_prev = &(elm)->field.tqe_circ;             \\\n+    }                                                                   \\\n+    atomic_rcu_set(&(head)->tqh_first, (elm));                          \\\n+    (elm)->field.tqe_circ.tql_prev = &(head)->tqh_circ;                 \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QTAILQ_INSERT_TAIL_RCU(head, elm, field) do {                   \\\n+    (elm)->field.tqe_next = NULL;                                       \\\n+    (elm)->field.tqe_circ.tql_prev = (head)->tqh_circ.tql_prev;         \\\n+    atomic_rcu_set(&(head)->tqh_circ.tql_prev->tql_next, (elm));        \\\n+    (head)->tqh_circ.tql_prev = &(elm)->field.tqe_circ;                 \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QTAILQ_INSERT_AFTER_RCU(head, listelm, elm, field) do {         \\\n+    (elm)->field.tqe_next = (listelm)->field.tqe_next;                  \\\n+    if ((elm)->field.tqe_next != NULL) {                                \\\n+        (elm)->field.tqe_next->field.tqe_circ.tql_prev =                \\\n+            &(elm)->field.tqe_circ;                                     \\\n+    } else {                                                            \\\n+        (head)->tqh_circ.tql_prev = &(elm)->field.tqe_circ;             \\\n+    }                                                                   \\\n+    atomic_rcu_set(&(listelm)->field.tqe_next, (elm));                  \\\n+    (elm)->field.tqe_circ.tql_prev = &(listelm)->field.tqe_circ;        \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QTAILQ_INSERT_BEFORE_RCU(listelm, elm, field) do {                \\\n+    (elm)->field.tqe_circ.tql_prev = (listelm)->field.tqe_circ.tql_prev;  \\\n+    (elm)->field.tqe_next = (listelm);                                    \\\n+    atomic_rcu_set(&(listelm)->field.tqe_circ.tql_prev->tql_next, (elm)); \\\n+    (listelm)->field.tqe_circ.tql_prev = &(elm)->field.tqe_circ;          \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QTAILQ_REMOVE_RCU(head, elm, field) do {                        \\\n+    if (((elm)->field.tqe_next) != NULL) {                              \\\n+        (elm)->field.tqe_next->field.tqe_circ.tql_prev =                \\\n+            (elm)->field.tqe_circ.tql_prev;                             \\\n+    } else {                                                            \\\n+        (head)->tqh_circ.tql_prev = (elm)->field.tqe_circ.tql_prev;     \\\n+    }                                                                   \\\n+    atomic_set(&(elm)->field.tqe_circ.tql_prev->tql_next, (elm)->field.tqe_next); \\\n+    (elm)->field.tqe_circ.tql_prev = NULL;                              \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QTAILQ_FOREACH_RCU(var, head, field)                            \\\n+    for ((var) = atomic_rcu_read(&(head)->tqh_first);                   \\\n+         (var);                                                         \\\n+         (var) = atomic_rcu_read(&(var)->field.tqe_next))\n+\n+#define QTAILQ_FOREACH_SAFE_RCU(var, head, field, next)                  \\\n+    for ((var) = atomic_rcu_read(&(head)->tqh_first);                    \\\n+         (var) && ((next) = atomic_rcu_read(&(var)->field.tqe_next), 1); \\\n+         (var) = (next))\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif /* QEMU_RCU_QUEUE_H */"
        },
        {
          "filename": "qemu/softmmu/memory.c",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -43,8 +43,9 @@ MemoryRegion *memory_map(struct uc_struct *uc, hwaddr begin, size_t size, uint32\n     MemoryRegion *ram = g_new(MemoryRegion, 1);\n \n     memory_region_init_ram(uc, ram, size, perms);\n-    if (ram->addr == -1) {\n+    if (ram->addr == -1 || !ram->ram_block) {\n         // out of memory\n+        g_free(ram);\n         return NULL;\n     }\n \n@@ -63,8 +64,9 @@ MemoryRegion *memory_map_ptr(struct uc_struct *uc, hwaddr begin, size_t size, ui\n \n     memory_region_init_ram_ptr(uc, ram, size, ptr);\n     ram->perms = perms;\n-    if (ram->addr == -1) {\n+    if (ram->addr == -1 || !ram->ram_block) {\n         // out of memory\n+        g_free(ram);\n         return NULL;\n     }\n "
        },
        {
          "filename": "tests/unit/test_mem.c",
          "status": "modified",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -175,6 +175,18 @@ static void test_map_wrap(void)\n     OK(uc_close(uc));\n }\n \n+static void test_map_big_memory(void)\n+{\n+    uc_engine *uc;\n+\n+    OK(uc_open(UC_ARCH_X86, UC_MODE_64, &uc));\n+\n+    uc_assert_err(UC_ERR_NOMEM,\n+                  uc_mem_map(uc, 0x0, 0xfffffffffffff000, UC_PROT_ALL));\n+\n+    OK(uc_close(uc));\n+}\n+\n TEST_LIST = {{\"test_map_correct\", test_map_correct},\n              {\"test_map_wrapping\", test_map_wrapping},\n              {\"test_mem_protect\", test_mem_protect},\n@@ -183,4 +195,5 @@ TEST_LIST = {{\"test_map_correct\", test_map_correct},\n              {\"test_mem_protect_map_ptr\", test_mem_protect_map_ptr},\n              {\"test_map_at_the_end\", test_map_at_the_end},\n              {\"test_map_wrap\", test_map_wrap},\n+             {\"test_map_big_memory\", test_map_big_memory},\n              {NULL, NULL}};"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d568885d64c89db5b9a722f0c1bef05aa92f84ca",
            "date": "2024-09-26T11:15:03Z",
            "author_login": "wtdcode"
          },
          {
            "sha": "050f2fbcaf4196b1fe2d39078a6d3fd27f403d56",
            "date": "2024-09-26T11:13:57Z",
            "author_login": "wtdcode"
          },
          {
            "sha": "9e0addd682df9a508d4ca3869e603ea0ea140961",
            "date": "2024-09-26T11:11:53Z",
            "author_login": "wtdcode"
          },
          {
            "sha": "2ccdc0823775d836a87dc91f76ff9f55e6c8253e",
            "date": "2024-09-26T10:47:20Z",
            "author_login": "wtdcode"
          },
          {
            "sha": "867770c7efb7a7b8d57453b0a182ce184b14770b",
            "date": "2024-09-26T10:44:51Z",
            "author_login": "wtdcode"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-476",
    "description": "Unicorn Engine v2.0.0-rc7 and below was discovered to contain a NULL pointer dereference via qemu_ram_free.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-06-02T14:15:50.553",
    "last_modified": "2024-11-21T06:59:34.720",
    "fix_date": "2022-04-16T17:17:41Z"
  },
  "references": [
    {
      "url": "https://github.com/unicorn-engine/unicorn/commit/3d3deac5e6d38602b689c4fef5dac004f07a2e63",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/unicorn-engine/unicorn/issues/1588",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/unicorn-engine/unicorn/pull/1593/commits/31389e59457f304be3809f9679f91a42daa7ebaa",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/unicorn-engine/unicorn/pull/1593/commits/6a879a082d4d67a5d13f1233ae0334cde0a7f844",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://violentbinary.github.io/posts/2-simple-analysis-of-software-virtualization-of-memory-in-unicorn-engine/",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Technical Description",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/unicorn-engine/unicorn/commit/3d3deac5e6d38602b689c4fef5dac004f07a2e63",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/unicorn-engine/unicorn/issues/1588",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/unicorn-engine/unicorn/pull/1593/commits/31389e59457f304be3809f9679f91a42daa7ebaa",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/unicorn-engine/unicorn/pull/1593/commits/6a879a082d4d67a5d13f1233ae0334cde0a7f844",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://violentbinary.github.io/posts/2-simple-analysis-of-software-virtualization-of-memory-in-unicorn-engine/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Technical Description",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:07.203652",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "unicorn",
    "owner": "unicorn-engine",
    "created_at": "2015-08-20T16:35:45Z",
    "updated_at": "2025-01-14T15:08:14Z",
    "pushed_at": "2025-01-14T00:47:55Z",
    "size": 16548,
    "stars": 7790,
    "forks": 1361,
    "open_issues": 121,
    "watchers": 7790,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 16868670,
      "Java": 513517,
      "Python": 389911,
      "Pascal": 154018,
      "F#": 145529,
      "Shell": 141870,
      "Rust": 140122,
      "Visual Basic 6.0": 127689,
      "Ruby": 124279,
      "Zig": 110533,
      "Haskell": 105350,
      "Go": 103478,
      "C++": 80861,
      "CMake": 54607,
      "Objective-C": 48840,
      "Makefile": 23244,
      "C#": 18588,
      "Assembly": 2160,
      "Batchfile": 38
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T15:48:09.565870"
  }
}