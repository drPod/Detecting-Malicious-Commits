{
  "cve_id": "CVE-2022-29859",
  "github_data": {
    "repository": "ambiot/amb1_sdk",
    "fix_commit": "4b73f58f32914d0081d79a79e53a3215c8c1ea56",
    "related_commits": [
      "4b73f58f32914d0081d79a79e53a3215c8c1ea56",
      "4b73f58f32914d0081d79a79e53a3215c8c1ea56"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "4b73f58f32914d0081d79a79e53a3215c8c1ea56",
      "commit_date": "2022-03-11T06:41:08Z",
      "author": {
        "login": "galexfang",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "[dhcps] update dhcps",
        "length": 20,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 526,
        "additions": 475,
        "deletions": 51
      },
      "files": [
        {
          "filename": "component/common/network/dhcp/dhcps.c",
          "status": "modified",
          "additions": 456,
          "deletions": 51,
          "patch": "@@ -1,7 +1,8 @@\n \n #include \"dhcps.h\"\n #include \"tcpip.h\"\n-\n+#include \"wifi_constants.h\"\n+extern rtw_mode_t wifi_mode;\n //static struct dhcp_server_state dhcp_server_state_machine;\n static uint8_t dhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;\n /* recorded the client MAC addr(default sudo mac) */\n@@ -11,6 +12,7 @@ static uint8_t dhcp_recorded_xid[4] = {0xff, 0xff, 0xff, 0xff};\n \n /* UDP Protocol Control Block(PCB) */\n static struct udp_pcb *dhcps_pcb;\n+static struct udp_pcb *dns_server_pcb;\n \n static struct ip_addr dhcps_send_broadcast_address;\n static struct ip_addr dhcps_local_address;\n@@ -20,6 +22,7 @@ static struct ip_addr dhcps_local_mask;\n static struct ip_addr dhcps_local_gateway;\n static struct ip_addr dhcps_network_id;\n static struct ip_addr dhcps_subnet_broadcast; \n+static struct eth_addr dhcps_allocated_client_ethaddr;\n static struct ip_addr dhcps_allocated_client_address;\n static int dhcps_addr_pool_set = 0;\n static struct ip_addr dhcps_addr_pool_start;\n@@ -73,7 +76,7 @@ static void mark_ip_in_table(uint8_t d)\n \t\tprintf(\"\\r\\n ip_table.ip_range[3] = 0x%x\\r\\n\",ip_table.ip_range[3]);\n #endif\t\n \t} else if(128 < d && d <= 160) {\n-\t\tip_table.ip_range[4] = MARK_RANGE5_IP_BIT(ip_table, d);\t\n+\t\tip_table.ip_range[4] = MARK_RANGE5_IP_BIT(ip_table, (d - 128));\t\n #if (debug_dhcps)\t\t\n \t\tprintf(\"\\r\\n ip_table.ip_range[4] = 0x%x\\r\\n\",ip_table.ip_range[4]);\n #endif\t\n@@ -101,15 +104,24 @@ static void mark_ip_in_table(uint8_t d)\n #ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n static void save_client_addr(struct ip_addr *client_ip, uint8_t *hwaddr)\n {\n+#if LWIP_VERSION_MAJOR >= 2\n+\tuint8_t d = (uint8_t)ip4_addr4(ip_2_ip4(client_ip));\n+#else\n \tuint8_t d = (uint8_t)ip4_addr4(client_ip);\n-\t\n+#endif\n \txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n \tmemcpy(ip_table.client_mac[d], hwaddr, 6); \n #if (debug_dhcps)\t\n-\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\\n\", __func__,\n+#if LWIP_VERSION_MAJOR >= 2\n+\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\n\", __func__,\n+\t\tip4_addr1(ip_2_ip4(client_ip)), ip4_addr2(ip_2_ip4(client_ip)), ip4_addr3(ip_2_ip4(client_ip)), ip4_addr4(ip_2_ip4(client_ip)),\n+\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n+#else\n+\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\n\", __func__,\n \t\tip4_addr1(client_ip), ip4_addr2(client_ip), ip4_addr3(client_ip), ip4_addr4(client_ip),\n \t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n-#endif\t\n+#endif\n+#endif\n \txSemaphoreGive(dhcps_ip_table_semaphore);\n }\n \n@@ -142,6 +154,82 @@ static uint8_t check_client_request_ip(struct ip_addr *client_req_ip, uint8_t *h\n Exit:\n \treturn ip_addr4;\n }\n+\n+static uint8_t check_client_direct_request_ip(struct ip_addr *client_req_ip, uint8_t *hwaddr)\n+{\n+\tint ip_addr4 = 0, i;\n+\n+#if (debug_dhcps)\t\n+#if LWIP_VERSION_MAJOR >= 2\n+\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\n\", __func__,\n+\t\t\tip4_addr1(ip_2_ip4(client_req_ip)), ip4_addr2(ip_2_ip4(client_req_ip)), ip4_addr3(ip_2_ip4(client_req_ip)), ip4_addr4(ip_2_ip4(client_req_ip)),\n+\t\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n+#else\n+\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\n\", __func__,\n+\t\t\tip4_addr1(client_req_ip), ip4_addr2(client_req_ip), ip4_addr3(client_req_ip), ip4_addr4(client_req_ip),\n+\t\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n+#endif\t\n+#endif\n+\n+#if LWIP_VERSION_MAJOR >= 2\n+\tif( (ip4_addr1(ip_2_ip4(&dhcps_network_id)) != ip4_addr1(ip_2_ip4(client_req_ip))) ||\n+\t\t(ip4_addr2(ip_2_ip4(&dhcps_network_id)) != ip4_addr2(ip_2_ip4(client_req_ip))) ||\n+\t\t(ip4_addr3(ip_2_ip4(&dhcps_network_id)) != ip4_addr3(ip_2_ip4(client_req_ip))))\n+#else\n+\tif( (ip4_addr1(&dhcps_network_id) != ip4_addr1(client_req_ip)) ||\n+\t\t(ip4_addr2(&dhcps_network_id) != ip4_addr2(client_req_ip)) ||\n+\t\t(ip4_addr3(&dhcps_network_id) != ip4_addr3(client_req_ip)))\n+#endif\n+\n+\t{\n+\t\tip_addr4 = 0;\n+\t\tgoto Exit;\n+\t}\n+\n+\t// check if the requested ip is available\n+#if LWIP_VERSION_MAJOR >= 2\n+\tip_addr4 = ip4_addr4(ip_2_ip4(client_req_ip));\n+#else\n+\tip_addr4 = ip4_addr4(client_req_ip);\n+#endif\n+\n+\tif (ip_addr4 < DHCP_POOL_START || ip_addr4 > DHCP_POOL_END) {\n+\t\tip_addr4 = 0;\n+\t\tgoto Exit;\n+\t}\n+\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n+\tprintf(\"ip_table[%d] = %x,%x,%x,%x,%x,%x\\n\",ip_addr4,ip_table.client_mac[ip_addr4][0],\n+\t\t\t\t\t\t\t\t\t\t  \t\t\t     ip_table.client_mac[ip_addr4][1],\n+\t\t\t\t\t\t\t\t\t\t  \t\t\t\t ip_table.client_mac[ip_addr4][2],\n+\t\t\t\t\t\t\t\t\t\t  \t\t\t\t ip_table.client_mac[ip_addr4][3],\n+\t\t\t\t\t\t\t\t\t\t  \t\t\t\t ip_table.client_mac[ip_addr4][4],\n+\t\t\t\t\t\t\t\t\t\t  \t\t\t\t ip_table.client_mac[ip_addr4][5]);\n+\tif(\t(\tip_table.client_mac[ip_addr4][0] == 0 &&\n+\t\t\tip_table.client_mac[ip_addr4][1] == 0 &&\n+\t\t\tip_table.client_mac[ip_addr4][2] == 0 &&\n+\t\t\tip_table.client_mac[ip_addr4][3] == 0 &&\n+\t\t\tip_table.client_mac[ip_addr4][4] == 0 &&\n+\t\t\tip_table.client_mac[ip_addr4][5] == 0) ||\n+\t\t(\tip_table.client_mac[ip_addr4][0] == hwaddr[0] &&\n+\t\t\tip_table.client_mac[ip_addr4][1] == hwaddr[1] &&\n+\t\t\tip_table.client_mac[ip_addr4][2] == hwaddr[2] &&\n+\t\t\tip_table.client_mac[ip_addr4][3] == hwaddr[3] &&\n+\t\t\tip_table.client_mac[ip_addr4][4] == hwaddr[4] &&\n+\t\t\tip_table.client_mac[ip_addr4][5] == hwaddr[5]))\n+\t{\n+\t\t// the ip is available or already allocated to this client\n+\t}\n+\telse\n+\t{\n+\t\tip_addr4 = 0; // the ip is used\n+\t}\n+\t\n+\txSemaphoreGive(dhcps_ip_table_semaphore);\n+\n+Exit:\n+\treturn ip_addr4;\n+}\n+\n static void dump_client_table()\n {\n #if 0\n@@ -174,8 +262,14 @@ static uint8_t search_next_ip(void)\n \tuint8_t start, end;\n \tuint8_t max_count;\n \tif(dhcps_addr_pool_set){\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\tstart = (uint8_t)ip4_addr4(ip_2_ip4(&dhcps_addr_pool_start));\n+\t\tend = (uint8_t)ip4_addr4(ip_2_ip4(&dhcps_addr_pool_end));\n+#else\n \t\tstart = (uint8_t)ip4_addr4(&dhcps_addr_pool_start);\n \t\tend = (uint8_t)ip4_addr4(&dhcps_addr_pool_end);\n+#endif\n+\n \t}else{\n \t\tstart = 0;\n \t\tend = 255;\n@@ -244,55 +338,101 @@ static uint8_t *fill_one_option_content(uint8_t *option_base_addr,\n /**\n   * @brief  fill in the needed content of the dhcp offer message. \n   * @param  optptr  the addr which the tail of dhcp magic field. \n-  * @retval the addr represent to add the end of option.\n+  * @retval\t0, add ok\n+  *\t\t\t-1, add fail\n   */\n-static void add_offer_options(uint8_t *option_start_address)\n+static int8_t add_offer_options(uint8_t *option_start_address)\n {\n-\tuint8_t *temp_option_addr;\n+\t// Total minimum len = 6+6+6+6+6+6+4+3+1 = 44\n+\tuint8_t *temp_option_addr = option_start_address;\n+\tint max_addable_option_len = dhcp_message_total_options_lenth - 4 - 3;\t// -magic-type\n+\n+\tif(option_start_address == NULL)\n+\t\tgoto ERROR;\n+\n \t/* add DHCP options 1. \n \tThe subnet mask option specifies the client's subnet mask */\n-\ttemp_option_addr = fill_one_option_content(option_start_address,\n-\t\t\tDHCP_OPTION_CODE_SUBNET_MASK, DHCP_OPTION_LENGTH_FOUR,\n-\t\t\t\t\t(void *)&dhcps_local_mask);\n+\tif(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {\n+\t\ttemp_option_addr = fill_one_option_content(option_start_address, DHCP_OPTION_CODE_SUBNET_MASK,\n+\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR,(void *)&dhcps_local_mask);\n+\t}else{\n+\t\tgoto ERROR;\n+\t}\n \t\n         /* add DHCP options 3 (i.e router(gateway)). The time server option \n         specifies a list of RFC 868 [6] time servers available to the client. */\n-\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n-\t\t\tDHCP_OPTION_CODE_ROUTER, DHCP_OPTION_LENGTH_FOUR,\n-\t\t\t\t\t(void *)&dhcps_local_address);\n+        if(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {\n+\t\ttemp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_ROUTER,\n+\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR, (void *)&dhcps_local_address);\n+\t}else{\n+\t\tgoto ERROR;\n+\t}\n \n \t/* add DHCP options 6 (i.e DNS). \n         The option specifies a list of DNS servers available to the client. */\n-\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n-\t\t\tDHCP_OPTION_CODE_DNS_SERVER, DHCP_OPTION_LENGTH_FOUR,\n-\t\t\t\t\t(void *)&dhcps_local_address);\t\n+\t if(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {\n+\t \ttemp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_DNS_SERVER,\n+\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR, (void *)&dhcps_local_address);\t\n+\t}else{\n+\t\tgoto ERROR;\n+\t}\n+\t\n \t/* add DHCP options 51.\n \tThis option is used to request a lease time for the IP address. */\n-\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n-\t\t\tDHCP_OPTION_CODE_LEASE_TIME, DHCP_OPTION_LENGTH_FOUR,\n-\t\t\t\t\t(void *)&dhcp_option_lease_time);\n+\t if(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {\n+\t\ttemp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_LEASE_TIME,\n+\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR, (void *)&dhcp_option_lease_time);\n+\t}else{\n+\t\tgoto ERROR;\n+\t}\n+\t\n \t/* add DHCP options 54. \n \tThe identifier is the IP address of the selected server. */\n-\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n-\t\t\tDHCP_OPTION_CODE_SERVER_ID, DHCP_OPTION_LENGTH_FOUR,\n-\t\t\t\t(void *)&dhcps_local_address);\n+\t if(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {\n+\t\ttemp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_SERVER_ID,\n+\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR, (void *)&dhcps_local_address);\n+\t}else{\n+\t\tgoto ERROR;\n+\t}\n+\t\n \t/* add DHCP options 28. \n \tThis option specifies the broadcast address in use on client's subnet.*/\n-\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n-\t\tDHCP_OPTION_CODE_BROADCAST_ADDRESS, DHCP_OPTION_LENGTH_FOUR,\n-\t\t\t\t(void *)&dhcps_subnet_broadcast);\n+\tif(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {\n+\t\ttemp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_BROADCAST_ADDRESS,\n+\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR, (void *)&dhcps_subnet_broadcast);\n+\t}else{\n+\t\tgoto ERROR;\n+\t}\n+\t\n \t/* add DHCP options 26. \n \tThis option specifies the Maximum transmission unit to use */\n-\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n-\t\tDHCP_OPTION_CODE_INTERFACE_MTU, DHCP_OPTION_LENGTH_TWO,\n-\t\t\t\t\t(void *) &dhcp_option_interface_mtu);//dhcp_option_interface_mtu_576);\n+\tif(temp_option_addr + 4 -option_start_address <= max_addable_option_len) {\n+\t\ttemp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_INTERFACE_MTU,\n+\t\t\t\t\t\tDHCP_OPTION_LENGTH_TWO, (void *) &dhcp_option_interface_mtu);//dhcp_option_interface_mtu_576);\n+\t}else{\n+\t\tgoto ERROR;\n+\t}\n+\t\n \t/* add DHCP options 31.\n \tThis option specifies whether or not the client should solicit routers */\n-\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n-\t\tDHCP_OPTION_CODE_PERFORM_ROUTER_DISCOVERY, DHCP_OPTION_LENGTH_ONE,\n-\t\t\t\t\t\t\t\tNULL);\n+\tif(temp_option_addr + 3 -option_start_address <= max_addable_option_len) {\n+\t\ttemp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_PERFORM_ROUTER_DISCOVERY,\n+\t\t\t\t\t\tDHCP_OPTION_LENGTH_ONE,\tNULL);\n+\t}else{\n+\t\tgoto ERROR;\n+\t}\n+\n+\t// END\n+\tif(temp_option_addr + 1 -option_start_address <= max_addable_option_len) {\n \t*temp_option_addr++ = DHCP_OPTION_CODE_END;\n+\t}else{\n+\t\tgoto ERROR;\n+\t}\n+\treturn 0;\n \n+ERROR:\n+\tprintf(\"\\r\\n[%s] error: add options fail !!\", __func__);\n+\treturn -1;\n }\n \n \n@@ -311,7 +451,6 @@ static void dhcps_initialize_message(struct dhcp_msg *dhcp_message_repository)\n         memcpy((char *)dhcp_recorded_xid, (char *) dhcp_message_repository->xid,\n \t\t\t\t\tsizeof(dhcp_message_repository->xid));\n         dhcp_message_repository->secs = 0;\n-        dhcp_message_repository->flags = htons(BOOTP_BROADCAST);         \n \n \tmemcpy((char *)dhcp_message_repository->yiaddr,\n \t\t\t(char *)&dhcps_allocated_client_address,\n@@ -341,9 +480,27 @@ static void dhcps_initialize_message(struct dhcp_msg *dhcp_message_repository)\n static void dhcps_send_offer(struct pbuf *packet_buffer)\n {\n \tuint8_t temp_ip = 0;\n-\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\t\n-#if (!IS_USE_FIXED_IP) \t\n+\tstruct pbuf *newly_malloc_packet_buffer = NULL;\n+\n+\t// newly malloc a longer pbuf for dhcp offer rather than using the short pbuf from dhcp discover\n+\tnewly_malloc_packet_buffer = pbuf_alloc(PBUF_TRANSPORT, DHCP_MSG_LEN + DHCP_OPTION_TOTAL_LENGTH_MAX, PBUF_RAM);\n+\tif(newly_malloc_packet_buffer == NULL)\n+\t{\n+\t\tprintf(\"\\r\\n[%s] error:  pbuf alloc fail !\", __func__);\n+\t\treturn;\n+\t}\n+\tif(pbuf_copy(newly_malloc_packet_buffer, packet_buffer) != ERR_OK)\n+\t{\n+\t\tprintf(\"\\r\\n[%s] error:  pbuf copy fail !\", __func__);\n+\t\tpbuf_free(newly_malloc_packet_buffer);\t\n+\t\treturn;\n+\t}\t\n+\tdhcp_message_total_options_lenth = DHCP_OPTION_TOTAL_LENGTH_MAX;\n+\tdhcp_message_repository = (struct dhcp_msg *)newly_malloc_packet_buffer->payload;\t\n+#if (!IS_USE_FIXED_IP) \n+#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n \ttemp_ip = check_client_request_ip(&client_request_ip, client_addr);\n+#endif\n \t/* create new client ip */\n \tif(temp_ip == 0)\n \t\ttemp_ip = search_next_ip();\n@@ -358,15 +515,55 @@ static void dhcps_send_offer(struct pbuf *packet_buffer)\n #endif\t\n \t\tprintf(\"\\r\\n No useable ip!!!!\\r\\n\");\n \t}\n-\tprintf(\"\\n\\r[%d]DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),temp_ip);\n+#if LWIP_VERSION_MAJOR >= 2\n+\tprintf(\"\\n\\r[%d]DHCP assign ip = %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\n\", \\\n+\t\t\txTaskGetTickCount(), ip4_addr1(ip_2_ip4(&dhcps_network_id)), \\\n+\t\t\tip4_addr2(ip_2_ip4(&dhcps_network_id)), \\\n+\t\t\tip4_addr3(ip_2_ip4(&dhcps_network_id)), temp_ip, \\\n+\t\t\tclient_addr[0], client_addr[1], client_addr[2], \\\n+\t\t\tclient_addr[3], client_addr[4], client_addr[5]);\n+\tIP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), (ip4_addr1(ip_2_ip4(&dhcps_network_id))),\n+\t\t\tip4_addr2(ip_2_ip4(&dhcps_network_id)), ip4_addr3(ip_2_ip4(&dhcps_network_id)), temp_ip);\n+#else\n+\tprintf(\"\\n\\r[%d]DHCP assign ip = %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\n\", \\\n+\t\t\txTaskGetTickCount(), ip4_addr1(&dhcps_network_id), \\\n+\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), temp_ip, \\\n+\t\t\tclient_addr[0], client_addr[1], client_addr[2], \\\n+\t\t\tclient_addr[3], client_addr[4], client_addr[5]);\n \tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n \t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), temp_ip);\n+#endif\n+\n #endif   \n \tdhcps_initialize_message(dhcp_message_repository);\n-\tadd_offer_options(add_msg_type(&dhcp_message_repository->options[4],\n-\t\t\tDHCP_MESSAGE_TYPE_OFFER));\n-\tudp_sendto_if(dhcps_pcb, packet_buffer,\n-\t\t\t&dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n+\tif(add_offer_options(add_msg_type(&dhcp_message_repository->options[4], DHCP_MESSAGE_TYPE_OFFER)) == 0){\n+\t\tif(dhcp_message_repository->flags == 0x0){\n+\t\t\t// unicast\n+\t\t\tfor(int i=0;i<6;i++)\n+\t\t\t\tdhcps_allocated_client_ethaddr.addr[i] = dhcp_message_repository->chaddr[i];\n+#if ETHARP_SUPPORT_STATIC_ENTRIES\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\t\t\tetharp_add_static_entry(ip_2_ip4(&dhcps_allocated_client_address), &dhcps_allocated_client_ethaddr);\n+#else\n+\t\t\t\tetharp_add_static_entry(&dhcps_allocated_client_address, &dhcps_allocated_client_ethaddr);\n+#endif\n+#endif\n+\t\t\t\tudp_sendto_if(dhcps_pcb, newly_malloc_packet_buffer, &dhcps_allocated_client_address, DHCP_CLIENT_PORT, dhcps_netif);\n+#if ETHARP_SUPPORT_STATIC_ENTRIES\t\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\t\t\tetharp_remove_static_entry(ip_2_ip4(&dhcps_allocated_client_address));\n+#else\n+\t\t\t\tetharp_remove_static_entry(&dhcps_allocated_client_address);\n+#endif\n+#endif\n+\n+\t\t}\n+\t\telse\n+\t\t\t// broadcast\n+\t\t\tudp_sendto_if(dhcps_pcb, newly_malloc_packet_buffer, &dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n+\t}\n+\n+\tpbuf_free(newly_malloc_packet_buffer);\t\n }\n \n /**\n@@ -390,12 +587,50 @@ static void dhcps_send_nak(struct pbuf *packet_buffer)\n   */\n static void dhcps_send_ack(struct pbuf *packet_buffer)\n {\n-\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\n+\tstruct pbuf *newly_malloc_packet_buffer = NULL;\n+\n+\t// newly malloc a longer pbuf for dhcp ack rather than using the short pbuf from dhcp request\n+\tnewly_malloc_packet_buffer = pbuf_alloc(PBUF_TRANSPORT, DHCP_MSG_LEN + DHCP_OPTION_TOTAL_LENGTH_MAX, PBUF_RAM);\n+\tif(newly_malloc_packet_buffer == NULL)\n+\t{\n+\t\tprintf(\"\\r\\n[%s] error:  pbuf alloc fail !\", __func__);\n+\t\treturn;\n+\t}\n+\tif(pbuf_copy(newly_malloc_packet_buffer, packet_buffer) != ERR_OK)\n+\t{\n+\t\tprintf(\"\\r\\n[%s] error:  pbuf copy fail !\", __func__);\n+\t\tpbuf_free(newly_malloc_packet_buffer);\t\n+\t\treturn;\n+\t}\t\n+\tdhcp_message_total_options_lenth = DHCP_OPTION_TOTAL_LENGTH_MAX;\n+\tdhcp_message_repository = (struct dhcp_msg *)newly_malloc_packet_buffer->payload;\n \tdhcps_initialize_message(dhcp_message_repository);\n-\tadd_offer_options(add_msg_type(&dhcp_message_repository->options[4],\n-\t\t\t      \t\t\tDHCP_MESSAGE_TYPE_ACK));\n-\tudp_sendto_if(dhcps_pcb, packet_buffer,\n-\t\t   &dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n+\tif(add_offer_options(add_msg_type(&dhcp_message_repository->options[4], DHCP_MESSAGE_TYPE_ACK)) == 0){\n+\t\tif(dhcp_message_repository->flags == 0x0){\n+\t\t\t// unicast\n+\t\t\tfor(int i=0;i<6;i++)\n+\t\t\t\tdhcps_allocated_client_ethaddr.addr[i] = dhcp_message_repository->chaddr[i];\n+#if ETHARP_SUPPORT_STATIC_ENTRIES\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\t\tetharp_add_static_entry(ip_2_ip4(&dhcps_allocated_client_address), &dhcps_allocated_client_ethaddr);\n+#else\n+\t\t\tetharp_add_static_entry(&dhcps_allocated_client_address, &dhcps_allocated_client_ethaddr);\n+#endif\n+#endif\n+\t\t\tudp_sendto_if(dhcps_pcb, newly_malloc_packet_buffer, &dhcps_allocated_client_address, DHCP_CLIENT_PORT, dhcps_netif);\n+#if ETHARP_SUPPORT_STATIC_ENTRIES\t\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\t\tetharp_remove_static_entry(ip_2_ip4(&dhcps_allocated_client_address));\n+#else\n+\t\t\tetharp_remove_static_entry(&dhcps_allocated_client_address);\n+#endif\n+#endif\n+\t\t}\n+\t\telse\n+\t\t\t// broadcast\n+\t\t\tudp_sendto_if(dhcps_pcb, newly_malloc_packet_buffer, &dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n+\t}\n+\tpbuf_free(newly_malloc_packet_buffer);\n }\n \n /**\n@@ -427,6 +662,18 @@ uint8_t dhcps_handle_state_machine_change(uint8_t option_message_type)\n #if (!IS_USE_FIXED_IP) \t\n #if (debug_dhcps)\n \t\tprintf(\"\\r\\ndhcp_server_state_machine=%d\", dhcp_server_state_machine);\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\tprintf(\"\\r\\ndhcps_allocated_client_address=%d.%d.%d.%d\", \n+\t\t\t\tip4_addr1(ip_2_ip4(&dhcps_allocated_client_address)),\n+\t\t\t\tip4_addr2(ip_2_ip4(&dhcps_allocated_client_address)),\n+\t\t\t\tip4_addr3(ip_2_ip4(&dhcps_allocated_client_address)),\n+\t\t\t\tip4_addr4(ip_2_ip4(&dhcps_allocated_client_address)));\n+\t\tprintf(\"\\r\\nclient_request_ip=%d.%d.%d.%d\\n\", \n+\t\t\t\tip4_addr1(ip_2_ip4(&client_request_ip)),\n+\t\t\t\tip4_addr2(ip_2_ip4(&client_request_ip)),\n+\t\t\t\tip4_addr3(ip_2_ip4(&client_request_ip)),\n+\t\t\t\tip4_addr4(ip_2_ip4(&client_request_ip)));\n+#else\n \t\tprintf(\"\\r\\ndhcps_allocated_client_address=%d.%d.%d.%d\", \n \t\t\t\tip4_addr1(&dhcps_allocated_client_address),\n \t\t\t\tip4_addr2(&dhcps_allocated_client_address),\n@@ -437,26 +684,71 @@ uint8_t dhcps_handle_state_machine_change(uint8_t option_message_type)\n \t\t\t\tip4_addr2(&client_request_ip),\n \t\t\t\tip4_addr3(&client_request_ip),\n \t\t\t\tip4_addr4(&client_request_ip));\n+#endif\n+\n #endif\t\t\n+\n+\t\t// for renew\n+\t\tif((*(uint32_t *) dhcp_message_repository->ciaddr != 0) && (*(uint32_t *)&client_request_ip == 0)) {\n+\t\t\tmemcpy(&client_request_ip, dhcp_message_repository->ciaddr, sizeof(client_request_ip));\n+\t\t}\n+\n \t\tif (dhcp_server_state_machine == DHCP_SERVER_STATE_OFFER) {\n-\t\t\tif (ip4_addr4(&dhcps_allocated_client_address) != 0) { \n-\t\t\t\tif (memcmp((void *)&dhcps_allocated_client_address, (void *)&client_request_ip, 4) == 0) {  \t\n+\t\t\tuint8_t ip_addr4 = check_client_direct_request_ip(&client_request_ip, client_addr);\n+\n+\t\t\tif(ip_addr4 > 0){\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(ip_2_ip4(&dhcps_network_id)),ip4_addr2(ip_2_ip4(&dhcps_network_id)),ip4_addr3(ip_2_ip4(&dhcps_network_id)),ip_addr4);\n+\t\t\t\tIP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), (ip4_addr1(ip_2_ip4(&dhcps_network_id))),\n+\t\t\t\t\t\tip4_addr2(ip_2_ip4(&dhcps_network_id)), ip4_addr3(ip_2_ip4(&dhcps_network_id)), ip_addr4);\n+#else\n+\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),ip_addr4);\n+\t\t\t\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n+\t\t\t\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), ip_addr4);\n+#endif\n+\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\t\tif (ip4_addr4(ip_2_ip4(&dhcps_allocated_client_address)) != 0) \n+#else\n+\t\t\tif (ip4_addr4(&dhcps_allocated_client_address) != 0) \n+#endif \n+\t\t\t{ \n+\t\t\t\tif (memcmp((void *)&dhcps_allocated_client_address, (void *)&client_request_ip, 4) == 0) {  \n+#if LWIP_VERSION_MAJOR >= 2\n+\t\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(ip_2_ip4(&dhcps_network_id)),ip4_addr2(ip_2_ip4(&dhcps_network_id)),ip4_addr3(ip_2_ip4(&dhcps_network_id)),ip4_addr4(ip_2_ip4(&dhcps_allocated_client_address)));\n+#else\n+\t\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),ip4_addr4(&dhcps_allocated_client_address));\n+#endif\n \t\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n \t\t\t  \t} else {\n \t\t\t\t  \tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n \t\t\t  \t}\n \t\t\t} else {\n \t\t\t  \tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n \t\t\t}  \n+#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n \t\t} else if(dhcp_server_state_machine == DHCP_SERVER_STATE_IDLE){\n-\t\t\tuint8_t ip_addr4 = check_client_request_ip(&client_request_ip, client_addr);\n-\t\t\tif(ip_addr4 > 0){\n+\t\t\tuint8_t ip_addr4 = check_client_direct_request_ip(&client_request_ip, client_addr);\n+\n+\t\t\tif(ip_addr4 > 0){\t\t\t\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(ip_2_ip4(&dhcps_network_id)),ip4_addr2(ip_2_ip4(&dhcps_network_id)),ip4_addr3(ip_2_ip4(&dhcps_network_id)),ip_addr4);\n+\t\t\t\tIP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), (ip4_addr1(ip_2_ip4(&dhcps_network_id))),\n+\t\t\t\t\t\tip4_addr2(ip_2_ip4(&dhcps_network_id)), ip4_addr3(ip_2_ip4(&dhcps_network_id)), ip_addr4);\n+#else\n+\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),ip_addr4);\n \t\t\t\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n \t\t\t\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), ip_addr4);\n+#endif\n+\n \t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n \t\t\t}else{\n \t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n \t\t\t}\n+#endif\n \t\t} else {\n \t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n \t\t}\n@@ -556,6 +848,15 @@ struct pbuf *udp_packet_buffer, struct ip_addr *sender_addr, uint16_t sender_por\n \t\treturn;  \n \t}\n \tif (sender_port == DHCP_CLIENT_PORT) {\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\tif(netif_get_idx(ip_current_input_netif()) == 0 && wifi_mode == RTW_MODE_STA_AP)\n+#else\n+\t\tif(netif_get_idx(ip_current_netif()) == 0 && wifi_mode == RTW_MODE_STA_AP)\n+#endif\n+\t\t{\n+\t\t\tpbuf_free(udp_packet_buffer);\n+\t\t\treturn;\n+\t\t}\n \t\ttotal_length_of_packet_buffer = udp_packet_buffer->tot_len;\n \t\tif (udp_packet_buffer->next != NULL) {\n \t\t\tmerged_packet_buffer = pbuf_coalesce(udp_packet_buffer,\n@@ -565,6 +866,7 @@ struct pbuf *udp_packet_buffer, struct ip_addr *sender_addr, uint16_t sender_por\n \t\t\t\tpbuf_free(udp_packet_buffer);\t\n \t\t\t\treturn;\n \t\t\t}\n+\t\t\tudp_packet_buffer = merged_packet_buffer;\n \t\t}\n \t\tswitch (dhcps_check_msg_and_handle_options(udp_packet_buffer)) {\n \t\tcase  DHCP_SERVER_STATE_OFFER:\n@@ -579,7 +881,11 @@ struct pbuf *udp_packet_buffer, struct ip_addr *sender_addr, uint16_t sender_por\n \t\t\t#endif\n \t\t\tdhcps_send_ack(udp_packet_buffer);\n #if (!IS_USE_FIXED_IP)\n-\t\t\tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_allocated_client_address)); \t\t\t\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\t\tmark_ip_in_table((uint8_t)ip4_addr4(ip_2_ip4(&dhcps_allocated_client_address))); \n+#else\n+\t\t\tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_allocated_client_address)); \t\n+#endif\t\t\t\n \t#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n \t\t\tsave_client_addr(&dhcps_allocated_client_address, client_addr);\n \t\t\tmemset(&client_request_ip, 0, sizeof(client_request_ip));\n@@ -635,6 +941,65 @@ void dhcps_set_addr_pool(int addr_pool_set, struct ip_addr * addr_pool_start, st\n \t\tdhcps_addr_pool_set = 0;\n \t}\n }\n+\n+\n+static void dnss_receive_udp_packet_handler(void *arg, struct udp_pcb *udp_pcb,\n+struct pbuf *udp_packet_buffer, struct ip_addr *sender_addr, uint16_t sender_port)\n+{\n+\tint ret=0;\n+\tstruct dns_hdr *dns_rsp;\n+\n+/*\n+\tprintf(\"\\n%s: Receive DNS query,ip = %d.%d.%d.%d, port = %d(%x)\\n\",__func__,\\\n+\t\t\tsender_addr->addr & 0xff,\\\n+\t\t\tsender_addr->addr>>8 & 0xff,\\\n+\t\t\tsender_addr->addr>>16 & 0xff,\\\n+\t\t\tsender_addr->addr>>24 & 0xff,\\\n+\t\t\tsender_port,sender_port);\n+*/\n+\n+\tdns_rsp = (struct dns_hdr*) udp_packet_buffer->payload;\n+\n+\tdns_rsp->flags1 |= 0x80; // 0x80 : Response;\n+\tdns_rsp->flags2 = 0x05;  //0x05 : Reply code (Query Refused)\n+\n+\tret = udp_sendto(udp_pcb, udp_packet_buffer, sender_addr, sender_port);\n+\n+\t/* free the UDP connection, so we can accept new clients */\n+\tudp_disconnect(udp_pcb);\n+\n+\t/* Free the packet buffer */\n+\tpbuf_free(udp_packet_buffer);\n+}\n+\n+\n+void dns_server_init(struct netif * pnetif)\n+{\n+\tuint8_t *ip;\n+\n+\tif (dns_server_pcb != NULL) {\n+\t\tudp_remove(dns_server_pcb);\n+\t\tdns_server_pcb = NULL;\n+\t}\n+\n+\tdns_server_pcb = udp_new();\n+\tif (dns_server_pcb == NULL) {\n+\t\tprintf(\"\\n\\r Error!!!upd_new error \\n\\r\");\n+\t\treturn;\n+\t}\n+\n+\tudp_bind(dns_server_pcb, IP_ADDR_ANY, DNS_SERVER_PORT);\n+\tudp_recv(dns_server_pcb, dnss_receive_udp_packet_handler, NULL);\n+}\n+\n+void dns_server_deinit(void)\n+{\n+\tif (dns_server_pcb != NULL) {\n+\t\tudp_remove(dns_server_pcb);\n+\t\tdns_server_pcb = NULL;\n+\t}\n+}\n+\n /** \n   * @brief  Initialize dhcp server.\n   * @param  None.\n@@ -666,7 +1031,12 @@ void dhcps_init(struct netif * pnetif)\n \t\tprintf(\"\\n\\r Error!!!upd_new error \\n\\r\");\n \t\treturn;\n \t}\n+#if LWIP_VERSION_MAJOR >= 2\n+\tIP4_ADDR(ip_2_ip4(&dhcps_send_broadcast_address), 255, 255, 255, 255);\n+#else\n \tIP4_ADDR(&dhcps_send_broadcast_address, 255, 255, 255, 255);\n+#endif\n+\n \t/* get net info from net interface */\n \n \tmemcpy(&dhcps_local_address, &pnetif->ip_addr,\n@@ -678,6 +1048,15 @@ void dhcps_init(struct netif * pnetif)\n \t\t\t\t\t\tsizeof(struct ip_addr));\n \n \t/* calculate the usable network ip range */\n+#if LWIP_VERSION_MAJOR >= 2\n+\tip4_addr_set_u32(ip_2_ip4(&dhcps_network_id), (ip_addr_get_ip4_u32(netif_ip_addr4(pnetif))&(ip_addr_get_ip4_u32(netif_ip_netmask4(pnetif)))));\n+\tip4_addr_set_u32(ip_2_ip4(&dhcps_subnet_broadcast), (ip4_addr_get_u32(ip_2_ip4(&dhcps_network_id)) | ~(ip_addr_get_ip4_u32(netif_ip_netmask4(pnetif)))));\n+#if 1\n+\tip4_addr_set_u32(ip_2_ip4(&dhcps_owned_first_ip), htonl(ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcps_network_id))) + 1));\n+\tip4_addr_set_u32(ip_2_ip4(&dhcps_owned_last_ip), htonl(ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcps_subnet_broadcast))) - 1));\t\n+\tdhcps_num_of_available_ips = (ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcps_owned_last_ip))) - ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcps_owned_first_ip)))) + 1;\n+#endif\n+#else\n \tdhcps_network_id.addr = ((pnetif->ip_addr.addr) &\n \t\t\t\t\t(pnetif->netmask.addr));\n \t\n@@ -689,6 +1068,8 @@ void dhcps_init(struct netif * pnetif)\n \tdhcps_num_of_available_ips = ((ntohl(dhcps_owned_last_ip.addr) \n \t\t\t\t- ntohl(dhcps_owned_first_ip.addr)) + 1); \n #endif\n+#endif\n+\n \n #if CONFIG_EXAMPLE_UART_ATCMD || CONFIG_EXAMPLE_SPI_ATCMD \n #if IP_SOF_BROADCAST\n@@ -697,9 +1078,16 @@ void dhcps_init(struct netif * pnetif)\n #endif\n \n #if IS_USE_FIXED_IP\n+#if LWIP_VERSION_MAJOR >= 2\n+\tIP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), ip4_addr1(ip_2_ip4(&dhcps_local_address))\n+\t\t, ip4_addr2(ip_2_ip4(&dhcps_local_address)), ip4_addr3(ip_2_ip4(&dhcps_local_address)),\n+\t\t\t\t\t(ip4_addr4(ip_2_ip4(&dhcps_local_address))) + 1 );\n+#else\n \tIP4_ADDR(&dhcps_allocated_client_address, ip4_addr1(&dhcps_local_address)\n \t\t, ip4_addr2(&dhcps_local_address), ip4_addr3(&dhcps_local_address),\n \t\t\t\t\t(ip4_addr4(&dhcps_local_address)) + 1 );\n+#endif\n+\n #else\n \tif (dhcps_ip_table_semaphore != NULL) {\t\n \t\tvSemaphoreDelete(dhcps_ip_table_semaphore);\n@@ -709,15 +1097,26 @@ void dhcps_init(struct netif * pnetif)\n \n \t//dhcps_ip_table = (struct ip_table *)(pvPortMalloc(sizeof(struct ip_table)));\n \tmemset(&ip_table, 0, sizeof(struct table));\n+#if LWIP_VERSION_MAJOR >= 2\n+\tmark_ip_in_table((uint8_t)ip4_addr4(ip_2_ip4(&dhcps_local_address)));\n+\tmark_ip_in_table((uint8_t)ip4_addr4(ip_2_ip4(&dhcps_local_gateway)));\n+#else\n \tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_address));\n \tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_gateway));\n+#endif\n+\n #if 0\n \tfor (i = 1; i < ip4_addr4(&dhcps_local_address); i++) {\n \t\tmark_ip_in_table(i);\n \t}\n #endif\t\n #endif\n+#if LWIP_VERSION_MAJOR >= 2\n+\tif(ip4_addr_get_u32(ip_2_ip4(&dhcps_addr_pool_start)) == 0 && ip4_addr_get_u32(ip_2_ip4(&dhcps_addr_pool_end)) == 0)\n+#else\n \tif(dhcps_addr_pool_start.addr== 0 && dhcps_addr_pool_end.addr == 0)\n+#endif\n+\n \t{\t\t\n \t\tmemcpy(&dhcps_pool_start,&dhcps_local_address,sizeof(struct ip_addr));\n \t\tip = (uint8_t *)&dhcps_pool_start;\n@@ -729,6 +1128,10 @@ void dhcps_init(struct netif * pnetif)\n \t}\n \tudp_bind(dhcps_pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);\n \tudp_recv(dhcps_pcb, dhcps_receive_udp_packet_handler, NULL);\n+\n+\t//DNS server init\n+\tdns_server_init(pnetif);\n+\n }\n \n void dhcps_deinit(void)\n@@ -740,5 +1143,7 @@ void dhcps_deinit(void)\n \tif (dhcps_ip_table_semaphore != NULL) {\t\n \t\tvSemaphoreDelete(dhcps_ip_table_semaphore);\n \t\tdhcps_ip_table_semaphore = NULL;\n-\t}\t\t\n+\t}\t\t   \n+    //DNS server deinit\n+\tdns_server_deinit();\n }"
        },
        {
          "filename": "component/common/network/dhcp/dhcps.h",
          "status": "modified",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -7,6 +7,7 @@\n #include \"lwip/udp.h\"\n #include \"lwip/stats.h\"\n #include \"lwip/sys.h\"\n+#include \"netif/etharp.h\"\n \n #include <platform/platform_stdlib.h>\n \n@@ -36,6 +37,7 @@\n #define DHCP_MESSAGE_HTYPE \t\t\t\t(1)\n #define DHCP_MESSAGE_HLEN  \t\t\t\t(6)\n \n+#define DNS_SERVER_PORT \t\t\t\t(53)\n #define DHCP_SERVER_PORT  \t\t\t\t(67)\n #define DHCP_CLIENT_PORT  \t\t\t\t(68)\n \n@@ -51,6 +53,10 @@\n #define DHCP_OPTION_LENGTH_TWO\t\t\t\t(2)\n #define DHCP_OPTION_LENGTH_THREE\t\t\t(3)\n #define DHCP_OPTION_LENGTH_FOUR\t\t\t\t(4)\n+#ifndef DHCP_MSG_LEN\n+#define DHCP_MSG_LEN\t\t\t\t\t\t\t236\n+#endif\n+#define DHCP_OPTION_TOTAL_LENGTH_MAX\t312\t//(51)= 4(magic)+3(type)+44(option code: 1,3,6,51,54,28,26,32,end)\n \n #define DHCP_OPTION_CODE_SUBNET_MASK   \t\t\t(1)\n #define DHCP_OPTION_CODE_ROUTER        \t\t\t(3)\n@@ -115,6 +121,19 @@ struct address_pool{\n \tuint32_t end;\n };\n \n+PACK_STRUCT_BEGIN\n+/** DNS message header */\n+struct dns_hdr {\n+  PACK_STRUCT_FIELD(u16_t id);\n+  PACK_STRUCT_FIELD(u8_t flags1);\n+  PACK_STRUCT_FIELD(u8_t flags2);\n+  PACK_STRUCT_FIELD(u16_t numquestions);\n+  PACK_STRUCT_FIELD(u16_t numanswers);\n+  PACK_STRUCT_FIELD(u16_t numauthrr);\n+  PACK_STRUCT_FIELD(u16_t numextrarr);\n+} PACK_STRUCT_STRUCT;\n+PACK_STRUCT_END\n+\n /* 01~32 */\n #define MARK_RANGE1_IP_BIT(table, ip)\t((table.ip_range[0]) | (1 << ((ip) - 1)))\t \n /* 33~64 */"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "63d54848534113c50e4e78d0ba45359be9ef7e0f",
            "date": "2022-11-23T07:20:05Z",
            "author_login": "M-ichae-l"
          },
          {
            "sha": "808458eec488c90ec6c237e380f8b52cff9e9550",
            "date": "2022-11-23T07:17:06Z",
            "author_login": "M-ichae-l"
          },
          {
            "sha": "a4db4b99fe00b4d9616b0b000f4ce4db3abe6ddd",
            "date": "2022-07-22T07:36:48Z",
            "author_login": "EvanPan1014"
          },
          {
            "sha": "0705aecd1a660defae669e6cb2325c02cbd7b2fd",
            "date": "2022-07-20T12:59:29Z",
            "author_login": "EvanPan1014"
          },
          {
            "sha": "4a9de2e4f21239a2d4a6f6bf75ce4e6e916102ec",
            "date": "2022-07-20T12:43:58Z",
            "author_login": "EvanPan1014"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": null,
    "description": "component/common/network/dhcp/dhcps.c in ambiot amb1_sdk (aka SDK for Ameba1) before 2022-03-11 mishandles data structures for DHCP packet data.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-04-27T23:15:08.023",
    "last_modified": "2024-11-21T06:59:50.463",
    "fix_date": "2022-03-11T06:41:08Z"
  },
  "references": [
    {
      "url": "https://github.com/ambiot/amb1_sdk/commit/4b73f58f32914d0081d79a79e53a3215c8c1ea56",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.amebaiot.com/zh/security_bulletin/cve-2022-29859/",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/ambiot/amb1_sdk/commit/4b73f58f32914d0081d79a79e53a3215c8c1ea56",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.amebaiot.com/zh/security_bulletin/cve-2022-29859/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:04.422862",
    "processing_status": "enhanced"
  }
}