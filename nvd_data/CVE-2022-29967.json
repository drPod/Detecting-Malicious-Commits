{
  "cve_id": "CVE-2022-29967",
  "github_data": {
    "repository": "babelouest/glewlwyd",
    "fix_commit": "e3f7245c33897bf9b3a75acfcdb8b7b93974bf11",
    "related_commits": [
      "e3f7245c33897bf9b3a75acfcdb8b7b93974bf11",
      "e3f7245c33897bf9b3a75acfcdb8b7b93974bf11"
    ],
    "patch_url": "https://github.com/babelouest/glewlwyd/commit/e3f7245c33897bf9b3a75acfcdb8b7b93974bf11.patch",
    "fix_commit_details": {
      "sha": "e3f7245c33897bf9b3a75acfcdb8b7b93974bf11",
      "commit_date": "2022-04-29T11:26:44Z",
      "author": {
        "login": "babelouest",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix file access check for directory traversal, and fix call for callback_static_file_uncompressed if header not set",
        "length": 115,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 256,
        "additions": 136,
        "deletions": 120
      },
      "files": [
        {
          "filename": "src/static_compressed_inmemory_website_callback.c",
          "status": "modified",
          "additions": 135,
          "deletions": 119,
          "patch": "@@ -4,7 +4,7 @@\n  *\n  * Copyright 2020-2022 Nicolas Mora <mail@babelouest.org>\n  *\n- * Version 20220425\n+ * Version 20220428\n  *\n  * The MIT License (MIT)\n  *\n@@ -89,6 +89,8 @@\n  */\n #include <pthread.h>\n #include <zlib.h>\n+#include <limits.h>\n+#include <stdlib.h>\n #include <string.h>\n #include <ulfius.h>\n \n@@ -158,7 +160,7 @@ static void callback_static_file_uncompressed_stream_free(void * cls) {\n static int callback_static_file_uncompressed (const struct _u_request * request, struct _u_response * response, void * user_data) {\n   size_t length;\n   FILE * f;\n-  char * file_requested, * file_path, * url_dup_save;\n+  char * file_requested, * file_path, * url_dup_save, * real_path = NULL;\n   const char * content_type;\n   int ret = U_CALLBACK_CONTINUE;\n \n@@ -185,34 +187,40 @@ static int callback_static_file_uncompressed (const struct _u_request * request,\n     }\n \n     file_path = msprintf(\"%s/%s\", ((struct _u_compressed_inmemory_website_config *)user_data)->files_path, file_requested);\n+    real_path = realpath(file_path, NULL);\n+    if (0 == o_strncmp(((struct _u_compressed_inmemory_website_config *)user_data)->files_path, real_path, o_strlen(((struct _u_compressed_inmemory_website_config *)user_data)->files_path))) {\n+      f = fopen (file_path, \"rb\");\n+      if (f) {\n+        fseek (f, 0, SEEK_END);\n+        length = ftell (f);\n+        fseek (f, 0, SEEK_SET);\n+\n+        content_type = u_map_get_case(&((struct _u_compressed_inmemory_website_config *)user_data)->mime_types, get_filename_ext(file_requested));\n+        if (content_type == NULL) {\n+          content_type = u_map_get(&((struct _u_compressed_inmemory_website_config *)user_data)->mime_types, \"*\");\n+          y_log_message(Y_LOG_LEVEL_WARNING, \"Static File Server - Unknown mime type for extension %s\", get_filename_ext(file_requested));\n+        }\n+        u_map_put(response->map_header, \"Content-Type\", content_type);\n+        u_map_copy_into(response->map_header, &((struct _u_compressed_inmemory_website_config *)user_data)->map_header);\n \n-    f = fopen (file_path, \"rb\");\n-    if (f) {\n-      fseek (f, 0, SEEK_END);\n-      length = ftell (f);\n-      fseek (f, 0, SEEK_SET);\n-\n-      content_type = u_map_get_case(&((struct _u_compressed_inmemory_website_config *)user_data)->mime_types, get_filename_ext(file_requested));\n-      if (content_type == NULL) {\n-        content_type = u_map_get(&((struct _u_compressed_inmemory_website_config *)user_data)->mime_types, \"*\");\n-        y_log_message(Y_LOG_LEVEL_WARNING, \"Static File Server - Unknown mime type for extension %s\", get_filename_ext(file_requested));\n-      }\n-      u_map_put(response->map_header, \"Content-Type\", content_type);\n-      u_map_copy_into(response->map_header, &((struct _u_compressed_inmemory_website_config *)user_data)->map_header);\n-\n-      if (ulfius_set_stream_response(response, 200, callback_static_file_uncompressed_stream, callback_static_file_uncompressed_stream_free, length, CHUNK, f) != U_OK) {\n-        y_log_message(Y_LOG_LEVEL_ERROR, \"Static File Server - Error ulfius_set_stream_response\");\n-      }\n-    } else {\n-      if (((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404 == NULL) {\n-        ret = U_CALLBACK_IGNORE;\n+        if (ulfius_set_stream_response(response, 200, callback_static_file_uncompressed_stream, callback_static_file_uncompressed_stream_free, length, CHUNK, f) != U_OK) {\n+          y_log_message(Y_LOG_LEVEL_ERROR, \"Static File Server - Error ulfius_set_stream_response\");\n+        }\n       } else {\n-        ulfius_add_header_to_response(response, \"Location\", ((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404);\n-        response->status = 302;\n+        if (((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404 == NULL) {\n+          ret = U_CALLBACK_IGNORE;\n+        } else {\n+          ulfius_add_header_to_response(response, \"Location\", ((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404);\n+          response->status = 302;\n+        }\n       }\n+      o_free(url_dup_save);\n+    } else {\n+      response->status = 403;\n     }\n     o_free(file_path);\n-    o_free(url_dup_save);\n+    free(real_path); // realpath uses malloc\n+\n   } else {\n     y_log_message(Y_LOG_LEVEL_ERROR, \"Static File Server - Error, user_data is NULL or inconsistent\");\n     ret = U_CALLBACK_ERROR;\n@@ -290,7 +298,7 @@ int callback_static_compressed_inmemory_website (const struct _u_request * reque\n   unsigned char * file_content, * file_content_orig = NULL;\n   size_t length, read_length, offset, data_zip_len = 0;\n   FILE * f;\n-  char * file_requested, * file_path, * url_dup_save, * data_zip = NULL;\n+  char * file_requested, * file_path, * url_dup_save, * data_zip = NULL, * real_path = NULL;\n   const char * content_type;\n \n   /*\n@@ -328,12 +336,11 @@ int callback_static_compressed_inmemory_website (const struct _u_request * reque\n           compress_mode = U_COMPRESS_DEFL;\n         }\n \n-\n         if (compress_mode != U_COMPRESS_NONE) {\n           if (compress_mode == U_COMPRESS_GZIP && config->allow_cache_compressed && u_map_has_key(&config->gzip_files, file_requested)) {\n             ulfius_set_binary_body_response(response, 200, u_map_get(&config->gzip_files, file_requested), u_map_get_length(&config->gzip_files, file_requested));\n             u_map_put(response->map_header, U_CONTENT_HEADER, U_ACCEPT_GZIP);\n-            \n+\n             content_type = u_map_get_case(&config->mime_types, get_filename_ext(file_requested));\n             if (content_type == NULL) {\n               content_type = u_map_get(&config->mime_types, \"*\");\n@@ -343,7 +350,7 @@ int callback_static_compressed_inmemory_website (const struct _u_request * reque\n           } else if (compress_mode == U_COMPRESS_DEFL && config->allow_cache_compressed && u_map_has_key(&config->deflate_files, file_requested)) {\n             ulfius_set_binary_body_response(response, 200, u_map_get(&config->deflate_files, file_requested), u_map_get_length(&config->deflate_files, file_requested));\n             u_map_put(response->map_header, U_CONTENT_HEADER, U_ACCEPT_DEFLATE);\n-            \n+\n             content_type = u_map_get_case(&config->mime_types, get_filename_ext(file_requested));\n             if (content_type == NULL) {\n               content_type = u_map_get(&config->mime_types, \"*\");\n@@ -352,120 +359,129 @@ int callback_static_compressed_inmemory_website (const struct _u_request * reque\n             u_map_copy_into(response->map_header, &config->map_header);\n           } else {\n             file_path = msprintf(\"%s/%s\", ((struct _u_compressed_inmemory_website_config *)user_data)->files_path, file_requested);\n+            real_path = realpath(file_path, NULL);\n+            if (0 == o_strncmp(((struct _u_compressed_inmemory_website_config *)user_data)->files_path, real_path, o_strlen(((struct _u_compressed_inmemory_website_config *)user_data)->files_path))) {\n+              if (!pthread_mutex_lock(&config->lock)) {\n+                f = fopen (file_path, \"rb\");\n+                if (f) {\n+                  content_type = u_map_get_case(&config->mime_types, get_filename_ext(file_requested));\n+                  if (content_type == NULL) {\n+                    content_type = u_map_get(&config->mime_types, \"*\");\n+                    y_log_message(Y_LOG_LEVEL_WARNING, \"Static File Server - Unknown mime type for extension %s\", get_filename_ext(file_requested));\n+                  }\n+                  if (!string_array_has_value((const char **)config->mime_types_compressed, content_type)) {\n+                    compress_mode = U_COMPRESS_NONE;\n+                  }\n \n-            if (!pthread_mutex_lock(&config->lock)) {\n-              f = fopen (file_path, \"rb\");\n-              if (f) {\n-                content_type = u_map_get_case(&config->mime_types, get_filename_ext(file_requested));\n-                if (content_type == NULL) {\n-                  content_type = u_map_get(&config->mime_types, \"*\");\n-                  y_log_message(Y_LOG_LEVEL_WARNING, \"Static File Server - Unknown mime type for extension %s\", get_filename_ext(file_requested));\n-                }\n-                if (!string_array_has_value((const char **)config->mime_types_compressed, content_type)) {\n-                  compress_mode = U_COMPRESS_NONE;\n-                }\n-\n-                u_map_put(response->map_header, \"Content-Type\", content_type);\n-                u_map_copy_into(response->map_header, &config->map_header);\n-                \n-                fseek (f, 0, SEEK_END);\n-                offset = length = ftell (f);\n-                fseek (f, 0, SEEK_SET);\n-\n-                if (length) {\n-                  if ((file_content_orig = file_content = o_malloc(length)) != NULL && (data_zip = o_malloc((2*length)+20)) != NULL) {\n-                    defstream.zalloc = u_zalloc;\n-                    defstream.zfree = u_zfree;\n-                    defstream.opaque = Z_NULL;\n-                    defstream.avail_in = (uInt)length;\n-                    defstream.next_in = (Bytef *)file_content;\n-                    while ((read_length = fread(file_content, sizeof(char), offset, f))) {\n-                      file_content += read_length;\n-                      offset -= read_length;\n-                    }\n-\n-                    if (compress_mode == U_COMPRESS_GZIP) {\n-                      if (deflateInit2(&defstream,\n-                                       Z_DEFAULT_COMPRESSION,\n-                                       Z_DEFLATED,\n-                                       U_GZIP_WINDOW_BITS | U_GZIP_ENCODING,\n-                                       8,\n-                                       Z_DEFAULT_STRATEGY) != Z_OK) {\n-                        y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error deflateInit (gzip)\");\n-                        ret = U_CALLBACK_ERROR;\n-                      }\n-                    } else {\n-                      if (deflateInit(&defstream, Z_BEST_COMPRESSION) != Z_OK) {\n-                        y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error deflateInit (deflate)\");\n-                        ret = U_CALLBACK_ERROR;\n+                  u_map_put(response->map_header, \"Content-Type\", content_type);\n+                  u_map_copy_into(response->map_header, &config->map_header);\n+\n+                  fseek (f, 0, SEEK_END);\n+                  offset = length = ftell (f);\n+                  fseek (f, 0, SEEK_SET);\n+\n+                  if (length) {\n+                    if ((file_content_orig = file_content = o_malloc(length)) != NULL && (data_zip = o_malloc((2*length)+20)) != NULL) {\n+                      defstream.zalloc = u_zalloc;\n+                      defstream.zfree = u_zfree;\n+                      defstream.opaque = Z_NULL;\n+                      defstream.avail_in = (uInt)length;\n+                      defstream.next_in = (Bytef *)file_content;\n+                      while ((read_length = fread(file_content, sizeof(char), offset, f))) {\n+                        file_content += read_length;\n+                        offset -= read_length;\n                       }\n-                    }\n-                    if (ret == U_CALLBACK_CONTINUE) {\n-                      do {\n-                        if ((data_zip = o_realloc(data_zip, data_zip_len+_U_W_BLOCK_SIZE)) != NULL) {\n-                          defstream.avail_out = _U_W_BLOCK_SIZE;\n-                          defstream.next_out = ((Bytef *)data_zip)+data_zip_len;\n-                          switch ((res = deflate(&defstream, Z_FINISH))) {\n-                            case Z_OK:\n-                            case Z_STREAM_END:\n-                            case Z_BUF_ERROR:\n-                              break;\n-                            default:\n-                              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error deflate %d\", res);\n-                              ret = U_CALLBACK_ERROR;\n-                              break;\n-                          }\n-                          data_zip_len += _U_W_BLOCK_SIZE - defstream.avail_out;\n-                        } else {\n-                          y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error allocating resources for data_zip\");\n+\n+                      if (compress_mode == U_COMPRESS_GZIP) {\n+                        if (deflateInit2(&defstream,\n+                                         Z_DEFAULT_COMPRESSION,\n+                                         Z_DEFLATED,\n+                                         U_GZIP_WINDOW_BITS | U_GZIP_ENCODING,\n+                                         8,\n+                                         Z_DEFAULT_STRATEGY) != Z_OK) {\n+                          y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error deflateInit (gzip)\");\n                           ret = U_CALLBACK_ERROR;\n                         }\n-                      } while (U_CALLBACK_CONTINUE == ret && defstream.avail_out == 0);\n-\n+                      } else {\n+                        if (deflateInit(&defstream, Z_BEST_COMPRESSION) != Z_OK) {\n+                          y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error deflateInit (deflate)\");\n+                          ret = U_CALLBACK_ERROR;\n+                        }\n+                      }\n                       if (ret == U_CALLBACK_CONTINUE) {\n-                        if (compress_mode == U_COMPRESS_GZIP) {\n-                          if (config->allow_cache_compressed) {\n-                            u_map_put_binary(&config->gzip_files, file_requested, data_zip, 0, defstream.total_out);\n+                        do {\n+                          if ((data_zip = o_realloc(data_zip, data_zip_len+_U_W_BLOCK_SIZE)) != NULL) {\n+                            defstream.avail_out = _U_W_BLOCK_SIZE;\n+                            defstream.next_out = ((Bytef *)data_zip)+data_zip_len;\n+                            switch ((res = deflate(&defstream, Z_FINISH))) {\n+                              case Z_OK:\n+                              case Z_STREAM_END:\n+                              case Z_BUF_ERROR:\n+                                break;\n+                              default:\n+                                y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error deflate %d\", res);\n+                                ret = U_CALLBACK_ERROR;\n+                                break;\n+                            }\n+                            data_zip_len += _U_W_BLOCK_SIZE - defstream.avail_out;\n+                          } else {\n+                            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error allocating resources for data_zip\");\n+                            ret = U_CALLBACK_ERROR;\n                           }\n-                          ulfius_set_binary_body_response(response, 200, u_map_get(&config->gzip_files, file_requested), u_map_get_length(&config->gzip_files, file_requested));\n-                        } else {\n-                          if (config->allow_cache_compressed) {\n-                            u_map_put_binary(&config->deflate_files, file_requested, data_zip, 0, defstream.total_out);\n+                        } while (U_CALLBACK_CONTINUE == ret && defstream.avail_out == 0);\n+\n+                        if (ret == U_CALLBACK_CONTINUE) {\n+                          if (compress_mode == U_COMPRESS_GZIP) {\n+                            if (config->allow_cache_compressed) {\n+                              u_map_put_binary(&config->gzip_files, file_requested, data_zip, 0, defstream.total_out);\n+                            }\n+                            ulfius_set_binary_body_response(response, 200, u_map_get(&config->gzip_files, file_requested), u_map_get_length(&config->gzip_files, file_requested));\n+                          } else {\n+                            if (config->allow_cache_compressed) {\n+                              u_map_put_binary(&config->deflate_files, file_requested, data_zip, 0, defstream.total_out);\n+                            }\n+                            ulfius_set_binary_body_response(response, 200, u_map_get(&config->deflate_files, file_requested), u_map_get_length(&config->deflate_files, file_requested));\n                           }\n-                          ulfius_set_binary_body_response(response, 200, u_map_get(&config->deflate_files, file_requested), u_map_get_length(&config->deflate_files, file_requested));\n+                          u_map_put(response->map_header, U_CONTENT_HEADER, compress_mode==U_COMPRESS_GZIP?U_ACCEPT_GZIP:U_ACCEPT_DEFLATE);\n                         }\n-                        u_map_put(response->map_header, U_CONTENT_HEADER, compress_mode==U_COMPRESS_GZIP?U_ACCEPT_GZIP:U_ACCEPT_DEFLATE);\n                       }\n+                      deflateEnd(&defstream);\n+                      o_free(data_zip);\n+                    } else {\n+                      y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error allocating resource for file_content or data_zip\");\n+                      ret = U_CALLBACK_ERROR;\n                     }\n-                    deflateEnd(&defstream);\n-                    o_free(data_zip);\n+                    o_free(file_content_orig);\n+                  }\n+                  fclose(f);\n+                } else {\n+                  if (((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404 == NULL) {\n+                    ret = U_CALLBACK_IGNORE;\n                   } else {\n-                    y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error allocating resource for file_content or data_zip\");\n-                    ret = U_CALLBACK_ERROR;\n+                    ulfius_add_header_to_response(response, \"Location\", ((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404);\n+                    response->status = 302;\n                   }\n-                  o_free(file_content_orig);\n                 }\n-                fclose(f);\n+                pthread_mutex_unlock(&config->lock);\n               } else {\n-                if (((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404 == NULL) {\n-                  ret = U_CALLBACK_IGNORE;\n-                } else {\n-                  ulfius_add_header_to_response(response, \"Location\", ((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404);\n-                  response->status = 302;\n-                }\n+                y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error pthread_lock_mutex\");\n+                ret = U_CALLBACK_ERROR;\n               }\n-              pthread_mutex_unlock(&config->lock);\n             } else {\n-              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error pthread_lock_mutex\");\n-              ret = U_CALLBACK_ERROR;\n+              response->status = 403;\n             }\n             o_free(file_path);\n+            free(real_path); // realpath uses malloc\n           }\n         } else {\n           ret = callback_static_file_uncompressed(request, response, user_data);\n         }\n         free_string_array(accept_list);\n+      } else {\n+        ret = callback_static_file_uncompressed(request, response, user_data);\n       }\n+    } else {\n+      ret = callback_static_file_uncompressed(request, response, user_data);\n     }\n     o_free(url_dup_save);\n   }"
        },
        {
          "filename": "src/static_compressed_inmemory_website_callback.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -4,7 +4,7 @@\n  *\n  * Copyright 2020-2022 Nicolas Mora <mail@babelouest.org>\n  *\n- * Version 20220425\n+ * Version 20220428\n  * \n  * The MIT License (MIT)\n  * "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "0219fa08044c1594d8b014903165e53754291605",
            "date": "2024-10-20T17:15:13Z",
            "author_login": "babelouest"
          },
          {
            "sha": "a1ba826cab672bd3b409de687c83cf6cf4b816c8",
            "date": "2024-10-20T17:14:00Z",
            "author_login": "babelouest"
          },
          {
            "sha": "110930c922fc4aea3b8157b41fa775201e259417",
            "date": "2024-05-06T11:26:40Z",
            "author_login": "babelouest"
          },
          {
            "sha": "7f68cbcfdb10c3c0cbe2727d7fed927e53fb6843",
            "date": "2024-05-02T11:25:51Z",
            "author_login": "babelouest"
          },
          {
            "sha": "fcc9e97fc2d6f8c99dd305c8459f358acacc4c4f",
            "date": "2024-05-01T13:20:44Z",
            "author_login": "babelouest"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-22",
    "description": "static_compressed_inmemory_website_callback.c in Glewlwyd through 2.6.2 allows directory traversal.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-04-29T23:15:09.937",
    "last_modified": "2024-11-21T07:00:04.940",
    "fix_date": "2022-04-29T11:26:44Z"
  },
  "references": [
    {
      "url": "https://github.com/babelouest/glewlwyd/commit/e3f7245c33897bf9b3a75acfcdb8b7b93974bf11",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/babelouest/glewlwyd/commit/e3f7245c33897bf9b3a75acfcdb8b7b93974bf11",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:04.428288",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "glewlwyd",
    "owner": "babelouest",
    "created_at": "2016-11-30T04:26:49Z",
    "updated_at": "2024-12-31T15:15:29Z",
    "pushed_at": "2024-10-20T17:15:18Z",
    "size": 29732,
    "stars": 428,
    "forks": 80,
    "open_issues": 6,
    "watchers": 428,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 8431516,
      "JavaScript": 1254100,
      "CSS": 112372,
      "HTML": 76882,
      "CMake": 68128,
      "Makefile": 31438,
      "Shell": 18468,
      "Dockerfile": 3556
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:26:49.165020"
  }
}