{
  "cve_id": "CVE-2022-30330",
  "github_data": {
    "repository": "keepkey/keepkey-firmware",
    "fix_commit": "447c1f038a31378ab9589965c098467d9ea6cccc",
    "related_commits": [
      "447c1f038a31378ab9589965c098467d9ea6cccc",
      "447c1f038a31378ab9589965c098467d9ea6cccc"
    ],
    "patch_url": "https://github.com/keepkey/keepkey-firmware/commit/447c1f038a31378ab9589965c098467d9ea6cccc.patch",
    "fix_commit_details": {
      "sha": "447c1f038a31378ab9589965c098467d9ea6cccc",
      "commit_date": "2022-04-12T19:44:55Z",
      "author": {
        "login": "mrnerdhair",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix: more robust address range checks in svhandler_flash_*",
        "length": 58,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 99,
        "additions": 64,
        "deletions": 35
      },
      "files": [
        {
          "filename": "lib/board/supervise.c",
          "status": "modified",
          "additions": 64,
          "deletions": 35,
          "patch": "@@ -30,6 +30,63 @@\n \n #ifndef EMULATOR\n \n+bool do_memory_ranges_overlap(size_t range1Start, size_t range1End, size_t range2Start, size_t range2End) {\n+  if (range1Start <= range2Start) {\n+    return range2Start < range1End;\n+  } else {\n+    return range1Start < range2End;\n+  }\n+}\n+\n+bool allow_svhandler_flash_sector(const FlashSector* sector) {\n+  return sector->use == FLASH_STORAGE1 ||\n+         sector->use == FLASH_STORAGE2 ||\n+         sector->use == FLASH_STORAGE3 ||\n+         sector->use == FLASH_UNUSED0 ||\n+         sector->use == FLASH_APP;\n+}\n+\n+bool allow_svhandler_flash_sector_num(int sector) {\n+  for (const FlashSector *s = flash_sector_map; s->use != FLASH_INVALID; s++) {\n+    if (s->sector == sector) return allow_svhandler_flash_sector(s);\n+  }\n+  return false;\n+}\n+\n+bool allow_svhandler_flash_range(size_t start, size_t end) {\n+  // Protect from overflow.\n+  if (start > end) return false;\n+\n+  // Disallow non-flash writes.\n+  if (start < FLASH_ORIGIN || end > FLASH_END) return false;\n+\n+  // Disallow writes to any sectors which aren't allowed.\n+  bool startAllowed = false;\n+  bool endAllowed = false;\n+  for (const FlashSector* s = flash_sector_map; s->use != FLASH_INVALID; s++) {\n+    if (allow_svhandler_flash_sector(s)) {\n+      if (!startAllowed &&\n+          start + 1 > start &&\n+          do_memory_ranges_overlap(start, start + 1, s->start, s->start + s->len)) {\n+        startAllowed = true;\n+      }\n+      if (!endAllowed &&\n+          end - 1 < end &&\n+          do_memory_ranges_overlap(end - 1, end, s->start, s->start + s->len)) {\n+        endAllowed = true;\n+      }\n+    } else {\n+      if (do_memory_ranges_overlap(start, end, s->start, s->start + s->len)) return false;\n+    }\n+  }\n+\n+  // Ensure writes start and end in allowed sectors. As long as flash_sector_map consists of\n+  // contiguous sectors, this will ensure no writes can target flash outside the map.\n+  if (!startAllowed || !endAllowed) return false;\n+\n+  return true;\n+}\n+\n /// Return context from user isr processing\n void svc_busr_return(void) {\n   __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_BUSR_RET) : \"memory\");\n@@ -76,13 +133,10 @@ bool svc_flash_pgm_word(uint32_t beginAddr, uint32_t data) {\n }\n \n void svhandler_flash_erase_sector(void) {\n-  uint32_t sector = _param_1;\n+  uint8_t sector = _param_1;\n \n-  // Do not allow firmware to erase bootstrap or bootloader sectors.\n-  if ((sector == FLASH_BOOTSTRAP_SECTOR) ||\n-      (sector >= FLASH_BOOT_SECTOR_FIRST && sector <= FLASH_BOOT_SECTOR_LAST)) {\n-    return;\n-  }\n+  // Verify requested sector is allowed.\n+  if (!allow_svhandler_flash_sector_num(sector)) return;\n \n   // Unlock flash.\n   flash_clear_status_flags();\n@@ -111,25 +165,8 @@ void svhandler_flash_pgm_blk(void) {\n   uint32_t data = _param_2;\n   uint32_t length = _param_3;\n \n-  // Protect from overflow.\n-  if (beginAddr + length < beginAddr) return;\n-\n-  // Do not allow firmware to erase bootstrap or bootloader sectors.\n-  if (((beginAddr >= BSTRP_FLASH_SECT_START) &&\n-       (beginAddr <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1))) ||\n-      (((beginAddr + length) >= BSTRP_FLASH_SECT_START) &&\n-       ((beginAddr + length) <=\n-        (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1)))) {\n-    return;\n-  }\n-\n-  if (((beginAddr >= BLDR_FLASH_SECT_START) &&\n-       (beginAddr <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1))) ||\n-      (((beginAddr + length) >= BLDR_FLASH_SECT_START) &&\n-       ((beginAddr + length) <=\n-        (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1)))) {\n-    return;\n-  }\n+  // Verify requested address range is allowed.\n+  if (!allow_svhandler_flash_range(beginAddr, beginAddr + length)) return;\n \n   // Unlock flash.\n   flash_clear_status_flags();\n@@ -157,16 +194,8 @@ void svhandler_flash_pgm_word(void) {\n   uint32_t dst = _param_1;\n   uint32_t src = _param_2;\n \n-  // Do not allow firmware to erase bootstrap or bootloader sectors.\n-  if ((dst >= BSTRP_FLASH_SECT_START) &&\n-      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {\n-    return;\n-  }\n-\n-  if ((dst >= BLDR_FLASH_SECT_START) &&\n-      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {\n-    return;\n-  }\n+  // Verify requested address range is allowed.\n+  if (!allow_svhandler_flash_range(dst, dst + sizeof(uint32_t))) return;\n \n   // Unlock flash.\n   flash_clear_status_flags();"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "742a7d62e31465696509d8a8f32ebae9c4c703fa",
            "date": "2024-03-06T02:12:26Z",
            "author_login": "pastaghost"
          },
          {
            "sha": "a8d9caae87119e739dfd6ad709144305884aac85",
            "date": "2024-03-06T02:06:47Z",
            "author_login": "pastaghost"
          },
          {
            "sha": "33b3ae5f5371c3e17616e3070ef048c048f59080",
            "date": "2024-03-05T21:25:07Z",
            "author_login": "pastaghost"
          },
          {
            "sha": "1297662a2313fa6b363440458f0964be970fe9e3",
            "date": "2024-03-04T22:52:35Z",
            "author_login": "pastaghost"
          },
          {
            "sha": "50164a2eece63b84f1d5d4ff80df1184d3bb17c2",
            "date": "2024-03-04T22:52:28Z",
            "author_login": "pastaghost"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.6,
    "cvss_vector": "CVSS:3.1/AV:P/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-20",
    "description": "In the KeepKey firmware before 7.3.2,Flaws in the supervisor interface can be exploited to bypass important security restrictions on firmware operations. Using these flaws, malicious firmware code can elevate privileges, permanently make the device inoperable or overwrite the trusted bootloader code to compromise the hardware wallet across reboots or storage wipes.",
    "attack_vector": "PHYSICAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-05-07T04:15:09.253",
    "last_modified": "2024-11-21T07:02:36.110",
    "fix_date": "2022-04-12T19:44:55Z"
  },
  "references": [
    {
      "url": "https://blog.inhq.net/posts/keepkey-CVE-2022-30330/",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/keepkey/keepkey-firmware/commit/447c1f038a31378ab9589965c098467d9ea6cccc",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/keepkey/keepkey-firmware/releases/tag/v7.3.2",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://blog.inhq.net/posts/keepkey-CVE-2022-30330/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/keepkey/keepkey-firmware/commit/447c1f038a31378ab9589965c098467d9ea6cccc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/keepkey/keepkey-firmware/releases/tag/v7.3.2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:07.091083",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "keepkey-firmware",
    "owner": "keepkey",
    "created_at": "2015-07-21T16:37:45Z",
    "updated_at": "2025-01-07T15:34:05Z",
    "pushed_at": "2024-03-06T02:19:56Z",
    "size": 40493,
    "stars": 157,
    "forks": 103,
    "open_issues": 14,
    "watchers": 157,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "beta"
    ],
    "languages": {
      "C": 1873217,
      "C++": 92884,
      "CMake": 37609,
      "Assembly": 28081,
      "Shell": 8597,
      "Dockerfile": 2436,
      "Python": 1057,
      "Pawn": 656,
      "GDB": 179
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-3.0"
    },
    "collected_at": "2025-01-14T13:13:29.883414"
  }
}