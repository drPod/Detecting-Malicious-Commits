{
  "cve_id": "CVE-2022-31020",
  "github_data": {
    "repository": "hyperledger/indy-node",
    "fix_commit": "fe507474f77084faef4539101e2bbb4d508a97f5",
    "related_commits": [
      "fe507474f77084faef4539101e2bbb4d508a97f5",
      "fe507474f77084faef4539101e2bbb4d508a97f5"
    ],
    "patch_url": "https://github.com/hyperledger/indy-node/commit/fe507474f77084faef4539101e2bbb4d508a97f5.patch",
    "fix_commit_details": {
      "sha": "fe507474f77084faef4539101e2bbb4d508a97f5",
      "commit_date": "2022-09-02T19:38:19Z",
      "author": {
        "login": "WadeBarnes",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-r6v9-p59m-gj2p",
        "length": 89,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 445,
        "additions": 405,
        "deletions": 40
      },
      "files": [
        {
          "filename": "indy_common/test/test_util.py",
          "status": "modified",
          "additions": 32,
          "deletions": 1,
          "patch": "@@ -1,6 +1,8 @@\n+import pytest\n+\n from operator import itemgetter\n from indy_common.util import getIndex\n-\n+from indy_common.util import compose_cmd\n \n def test_getIndex():\n     items = [('a', {'key1': 1}), ('b', {'key2': 2})]\n@@ -12,3 +14,32 @@ def containsKey(key):\n     assert 0 == getIndex(containsKey('key1'), items)\n     assert 1 == getIndex(containsKey('key2'), items)\n     assert -1 == getIndex(containsKey('key3'), items)\n+\n+@pytest.mark.parametrize(\n+    'pkg_name,package',\n+    [\n+        pytest.param('some_package', 'some_package', id='some_package'),\n+        pytest.param('package_1', 'package_1;echo \"hi\"&&echo \"hello\"\\necho \"hello world!\"', id='strips mixed cmd concat'),\n+        pytest.param('package_3', 'package_3;echo \"hey\"', id='strips semi-colon cmd concat'),\n+        pytest.param('package_4', 'package_4&&echo \"hey\"', id='strips and cmd concat'),\n+        pytest.param('package_5', 'package_5\\necho \"hey\"', id='strips Cr cmd concat'),\n+    ]\n+)\n+def test_compose_cmd(pkg_name, package):\n+    expected_cmd = f'dpkg -s {pkg_name}'\n+\n+    cmd = compose_cmd(['dpkg', '-s', package])\n+    assert expected_cmd == cmd\n+\n+def test_compose_cmd_allows_whitespace():\n+    pkg_name = 'package_7 some_other_package'\n+    expected_cmd = f'dpkg -s {pkg_name}'\n+    cmd = compose_cmd(['dpkg', '-s', pkg_name])\n+    assert expected_cmd == cmd\n+\n+def test_compose_cmd_allows_pipe():\n+    expected_cmd = 'dpkg --get-selections | grep -v deinstall | cut -f1'\n+    cmd = compose_cmd(\n+        ['dpkg', '--get-selections', '|', 'grep', '-v', 'deinstall', '|', 'cut', '-f1']\n+    )\n+    assert expected_cmd == cmd\n\\ No newline at end of file"
        },
        {
          "filename": "indy_common/util.py",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -1,6 +1,7 @@\n import datetime\n import os\n import random\n+import re\n from typing import Tuple, Union, TypeVar, List, Callable\n \n import libnacl.secret\n@@ -143,6 +144,7 @@ def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int:\n def compose_cmd(cmd):\n     if os.name != 'nt':\n         cmd = ' '.join(cmd)\n+        cmd = re.split(\";|&&\", cmd.splitlines()[0], 1)[0].rstrip()\n     return cmd\n \n "
        },
        {
          "filename": "indy_node/server/request_handlers/config_req_handlers/pool_upgrade_handler.py",
          "status": "modified",
          "additions": 18,
          "deletions": 16,
          "patch": "@@ -1,3 +1,5 @@\n+import re\n+\n from typing import Optional\n \n from indy_common.authorize.auth_actions import AuthActionAdd, AuthActionEdit\n@@ -52,22 +54,6 @@ def additional_dynamic_validation(self, request: Request, req_pp_time: Optional[\n         self._validate_request_type(request)\n         identifier, req_id, operation = get_request_data(request)\n         status = '*'\n-\n-        pkg_to_upgrade = operation.get(PACKAGE, getConfig().UPGRADE_ENTRY)\n-        targetVersion = operation[VERSION]\n-        reinstall = operation.get(REINSTALL, False)\n-\n-        if not pkg_to_upgrade:\n-            raise InvalidClientRequest(identifier, req_id, \"Upgrade package name is empty\")\n-\n-        try:\n-            res = self.upgrader.check_upgrade_possible(pkg_to_upgrade, targetVersion, reinstall)\n-        except Exception as exc:\n-            res = str(exc)\n-\n-        if res:\n-            raise InvalidClientRequest(identifier, req_id, res)\n-\n         action = operation.get(ACTION)\n         # TODO: Some validation needed for making sure name and version\n         # present\n@@ -99,6 +85,22 @@ def additional_dynamic_validation(self, request: Request, req_pp_time: Optional[\n         self.write_req_validator.validate(request,\n                                           [auth_action])\n \n+        pkg_to_upgrade = operation.get(PACKAGE, getConfig().UPGRADE_ENTRY)\n+        if not pkg_to_upgrade:\n+            raise InvalidClientRequest(identifier, req_id, \"Upgrade package name is empty\")\n+\n+        # Only allow processing of a single package\n+        pkg_to_upgrade = re.split(\"\\s+|;|&&|\\|\", pkg_to_upgrade.splitlines()[0], 1)[0].rstrip()\n+        targetVersion = operation[VERSION]\n+        reinstall = operation.get(REINSTALL, False)\n+        try:\n+            res = self.upgrader.check_upgrade_possible(pkg_to_upgrade, targetVersion, reinstall)\n+        except Exception as exc:\n+            res = str(exc)\n+\n+        if res:\n+            raise InvalidClientRequest(identifier, req_id, res)\n+\n     def apply_forced_request(self, req: Request):\n         super().apply_forced_request(req)\n         txn = self._req_to_txn(req)"
        },
        {
          "filename": "indy_node/test/node_control_utils/test_node_control_util.py",
          "status": "modified",
          "additions": 253,
          "deletions": 21,
          "patch": "@@ -1,5 +1,7 @@\n+from ast import arg\n import pytest\n import shutil\n+import re\n \n from common.version import DigitDotVersion\n \n@@ -13,8 +15,8 @@\n # - conditionally skip all tests for non-debian systems\n # - teste _parse_version_deps_from_pkg_mgr_output deeply\n \n-generated_commands = []\n \n+generated_commands = []\n \n @pytest.fixture\n def catch_generated_commands(monkeypatch):\n@@ -29,12 +31,107 @@ def _f(command, *args, **kwargs):\n     monkeypatch.setattr(NodeControlUtil, 'run_shell_command', _f)\n \n \n-def test_generated_cmd_get_curr_info(catch_generated_commands):\n-    pkg_name = 'some_package'\n+some_package_info = 'Package: some_package\\nVersion: 1.2.3\\nDepends: aaa (= 1.2.4), bbb (>= 1.2.5), ccc, aaa'\n+some_other_package_info = 'Package: some_other_package\\nVersion: 4.5.6\\nDepends: ddd (= 3.4.5), eee (>= 5.1.2), fff, ddd'\n+app_package_info = 'Package: {}\\nVersion: 1.2.3\\nDepends: aaa (= 1.2.4), bbb (>= 1.2.5), ccc, aaa'.format(APP_NAME)\n+any_package_info = 'Package: any_package\\nVersion: 1.2.3\\nDepends: aaa (= 1.2.4), bbb (>= 1.2.5), ccc, aaa'\n+\n+@pytest.fixture\n+def patch_run_shell_command(monkeypatch):\n+    generated_commands[:] = []\n+\n+    pkg_list = 'openssl\\nsed\\ntar\\nsome_package\\nsome_other_package\\n{}\\nany_package'.format(APP_NAME)\n+    pkg_info = '{}\\n\\n{}\\n\\n{}\\n\\n{}'.format(some_package_info, some_other_package_info, app_package_info, any_package_info)\n+\n+    def mock_run_shell_command(command, *args, **kwargs):\n+        # Keep track of the generated commands\n+        generated_commands.append(command)\n+        if command == 'dpkg --get-selections | grep -v deinstall | cut -f1':\n+            return pkg_list\n+        else:\n+            package_name = command.split()[-1]\n+            packages = re.split(\"\\n\\n\", pkg_info)\n+            for package in packages:\n+                if package_name in package:\n+                    return package\n+\n+            return ''\n+\n+    monkeypatch.setattr(NodeControlUtil, 'run_shell_command', mock_run_shell_command)\n+\n+\n+@pytest.mark.parametrize(\n+    'pkg_name',\n+    [\n+        pytest.param('not_installed_package', id='not_installed_package'),\n+        # Ensure partial matches don't work.\n+        pytest.param('some', id='partial_name_match-some'),\n+        pytest.param('package', id='partial_name_match-package'),\n+    ]\n+)\n+def test_generated_cmd_get_curr_info_pkg_not_installed(patch_run_shell_command, pkg_name):\n+    pkg_name = 'not_installed_package'\n     # TODO not an API for now\n     NodeControlUtil._get_curr_info(pkg_name)\n     assert len(generated_commands) == 1\n-    assert generated_commands[0] == \"dpkg -s {}\".format(pkg_name)\n+    assert generated_commands[0] == 'dpkg --get-selections | grep -v deinstall | cut -f1'\n+\n+\n+def test_generated_cmd_get_curr_info_pkg_installed(patch_run_shell_command):\n+    pkg_name = 'some_package'\n+    # TODO not an API for now\n+    NodeControlUtil._get_curr_info(pkg_name)\n+    assert len(generated_commands) == 2\n+    assert generated_commands[0] == 'dpkg --get-selections | grep -v deinstall | cut -f1'\n+    assert generated_commands[1] == \"dpkg -s {}\".format(pkg_name)\n+\n+\n+def test_generated_cmd_get_curr_info_accepts_single_pkg_only(patch_run_shell_command):\n+    expected_pkg_name = 'some_other_package'\n+    # The extra spaces between the package names is on purpose.\n+    pkg_name = 'some_other_package   some_package'\n+    # TODO not an API for now\n+    NodeControlUtil._get_curr_info(pkg_name)\n+    assert len(generated_commands) == 2\n+    assert generated_commands[0] == 'dpkg --get-selections | grep -v deinstall | cut -f1'\n+    assert generated_commands[1] == \"dpkg -s {}\".format(expected_pkg_name)\n+\n+\n+@pytest.mark.parametrize(\n+    'pkg_name,package',\n+    [\n+        pytest.param('some_package', 'some_package|echo \"hey\";echo \"hi\"&&echo \"hello\"|echo \"hello world\"\\necho \"hello world!\"', id='strips mixed cmd concat'),\n+        pytest.param('some_package', 'some_package|echo \"hey\"', id='strips pipe cmd concat'),\n+        pytest.param('some_package', 'some_package;echo \"hey\"', id='strips semi-colon cmd concat'),\n+        pytest.param('some_package', 'some_package&&echo \"hey\"', id='strips AND cmd concat'),\n+        pytest.param('some_package', 'some_package\\necho \"hey\"', id='strips Cr cmd concat'),\n+        pytest.param('some_package', 'some_package echo \"hey\"', id='strips whitespace'),\n+    ]\n+)\n+def test_generated_cmd_get_curr_info_with_command_concat(patch_run_shell_command, pkg_name, package):\n+    # TODO not an API for now\n+    NodeControlUtil._get_curr_info(package)\n+    assert len(generated_commands) == 2\n+    assert generated_commands[0] == 'dpkg --get-selections | grep -v deinstall | cut -f1'\n+    assert generated_commands[1] == \"dpkg -s {}\".format(pkg_name)\n+\n+\n+@pytest.mark.parametrize(\n+    'pkg_name,expected_output',\n+    [\n+        pytest.param('some_package', some_package_info, id='some_package'),\n+        pytest.param('some_other_package', some_other_package_info, id='some_other_package'),\n+        pytest.param(APP_NAME, app_package_info, id=APP_NAME),\n+        pytest.param('any_package', any_package_info, id='any_package'),\n+        pytest.param('not_installed_package', '', id='not_installed_package'),\n+        # Ensure partial matches don't work.\n+        pytest.param('some', '', id='partial_name_match-some'),\n+        pytest.param('package', '', id='partial_name_match-package'),\n+    ]\n+)\n+def test_get_curr_info_output(patch_run_shell_command, pkg_name, expected_output):\n+    pkg_info = NodeControlUtil._get_curr_info(pkg_name)\n+    assert pkg_info == expected_output\n \n \n def test_generated_cmd_get_latest_pkg_version(catch_generated_commands):\n@@ -65,12 +162,119 @@ def test_generated_cmd_get_info_from_package_manager(catch_generated_commands):\n     assert len(generated_commands) == 1\n     assert generated_commands[0] == \"apt-cache show {}\".format(\" \".join(packages))\n \n-\n+# apt update is successful\n def test_generated_cmd_update_package_cache(catch_generated_commands):\n     NodeControlUtil.update_package_cache()\n     assert len(generated_commands) == 1\n     assert generated_commands[0] == \"apt update\"\n \n+# apt update fails\n+# apt update dependencies don't need to be upgraded, i.e. only key update is performed.\n+def test_generated_cmd_update_package_cache_2(monkeypatch):\n+    run_shell_script_counter = 0\n+    commands = []\n+\n+    def _run_shell_script(command, *args, **kwargs):\n+        nonlocal run_shell_script_counter\n+        run_shell_script_counter += 1\n+        commands.append(command)\n+\n+        if run_shell_script_counter == 1:\n+            raise Exception(\"Command 'apt update' returned non-zero exit status\")\n+\n+        return ''\n+\n+    def _f(command, *args, **kwargs):\n+        commands.append(command)\n+        return ''\n+\n+    monkeypatch.setattr(NodeControlUtil, 'run_shell_script', _run_shell_script)\n+    monkeypatch.setattr(NodeControlUtil, 'run_shell_script_extended', _f)\n+    monkeypatch.setattr(NodeControlUtil, 'run_shell_command', _f)\n+\n+    NodeControlUtil.update_package_cache()\n+    assert len(commands) == 4\n+    assert commands[0] == \"apt update\"\n+    assert commands[1] == \"apt-key adv --keyserver keyserver.ubuntu.com --recv-keys CE7709D068DB5E88\"\n+    assert commands[2] == \"apt list --upgradable\"\n+    assert commands[3] == \"apt update\"\n+\n+\n+# apt update fails\n+# apt update dependencies need to be upgraded\n+def test_generated_cmd_update_package_cache_3(monkeypatch):\n+    run_shell_script_counter = 0\n+    commands = []\n+\n+    def _run_shell_script(command, *args, **kwargs):\n+        nonlocal run_shell_script_counter\n+        run_shell_script_counter += 1\n+        commands.append(command)\n+\n+        if run_shell_script_counter == 1:\n+            raise Exception(\"Command 'apt update' returned non-zero exit status\")\n+\n+        return ''\n+\n+    def _run_shell_command(command, *args, **kwargs):\n+        commands.append(command)\n+        return \"\"\"libgnutls-openssl27/xenial-updates 3.4.10-4ubuntu1.9 amd64 [upgradable from: 3.4.10-4ubuntu1.7]\n+libgnutls30/xenial-updates 3.4.10-4ubuntu1.9 amd64 [upgradable from: 3.4.10-4ubuntu1.7]\n+liblxc1/xenial-updates 2.0.11-0ubuntu1~16.04.3 amd64 [upgradable from: 2.0.8-0ubuntu1~16.04.2]\"\"\"\n+\n+    def _f(command, *args, **kwargs):\n+        commands.append(command)\n+        return ''\n+\n+    monkeypatch.setattr(NodeControlUtil, 'run_shell_script', _run_shell_script)\n+    monkeypatch.setattr(NodeControlUtil, 'run_shell_script_extended', _f)\n+    monkeypatch.setattr(NodeControlUtil, 'run_shell_command', _run_shell_command)\n+\n+    NodeControlUtil.update_package_cache()\n+    assert len(commands) == 5\n+    assert commands[0] == \"apt update\"\n+    assert commands[1] == \"apt-key adv --keyserver keyserver.ubuntu.com --recv-keys CE7709D068DB5E88\"\n+    assert commands[2] == \"apt list --upgradable\"\n+    assert commands[3] == \"apt --only-upgrade install -y libgnutls30\"\n+    assert commands[4] == \"apt update\"\n+\n+\n+def test_generated_cmd_update_repo_keys(catch_generated_commands):\n+    NodeControlUtil.update_repo_keys()\n+    assert len(generated_commands) == 1\n+    assert generated_commands[0] == \"apt-key adv --keyserver keyserver.ubuntu.com --recv-keys CE7709D068DB5E88\"\n+\n+\n+# apt update dependencies don't need to be upgraded\n+def test_generated_cmd_update_apt_update_dependencies_1(catch_generated_commands):\n+    NodeControlUtil.update_apt_update_dependencies()\n+    assert len(generated_commands) == 1\n+    assert generated_commands[0] == \"apt list --upgradable\"\n+\n+\n+# apt update dependencies need to be upgraded\n+def test_generated_cmd_update_apt_update_dependencies_2(monkeypatch):\n+    commands = []\n+\n+    def _run_shell_command(command, *args, **kwargs):\n+        commands.append(command)\n+        return \"\"\"libgnutls-openssl27/xenial-updates 3.4.10-4ubuntu1.9 amd64 [upgradable from: 3.4.10-4ubuntu1.7]\n+libgnutls30/xenial-updates 3.4.10-4ubuntu1.9 amd64 [upgradable from: 3.4.10-4ubuntu1.7]\n+liblxc1/xenial-updates 2.0.11-0ubuntu1~16.04.3 amd64 [upgradable from: 2.0.8-0ubuntu1~16.04.2]\"\"\"\n+\n+    def _f(command, *args, **kwargs):\n+        commands.append(command)\n+        return ''\n+\n+    monkeypatch.setattr(NodeControlUtil, 'run_shell_script', _f)\n+    monkeypatch.setattr(NodeControlUtil, 'run_shell_script_extended', _f)\n+    monkeypatch.setattr(NodeControlUtil, 'run_shell_command', _run_shell_command)\n+\n+    NodeControlUtil.update_apt_update_dependencies()\n+    assert len(commands) == 2\n+    assert commands[0] == \"apt list --upgradable\"\n+    assert commands[1] == \"apt --only-upgrade install -y libgnutls30\"\n+\n \n def test_generated_cmd_get_sys_holds(monkeypatch, catch_generated_commands):\n     monkeypatch.setattr(shutil, 'which', lambda *_: 'path')\n@@ -154,24 +358,52 @@ def test_get_latest_pkg_version_for_unknown_package():\n         'some-unknown-package-name', update_cache=False) is None\n \n \n-def test_curr_pkg_info_no_data(monkeypatch):\n-    monkeypatch.setattr(NodeControlUtil, 'run_shell_command', lambda *_: '')\n-    assert (None, []) == NodeControlUtil.curr_pkg_info('any_package')\n+def test_curr_pkg_info_no_data(patch_run_shell_command):\n+    assert (None, []) == NodeControlUtil.curr_pkg_info('some-unknown-package-name')\n \n \n-def test_curr_pkg_info(monkeypatch):\n-    output = 'Version: 1.2.3\\nDepends: aaa (= 1.2.4), bbb (>= 1.2.5), ccc, aaa'\n-    expected_deps = ['aaa=1.2.4', 'bbb=1.2.5', 'ccc']\n-    monkeypatch.setattr(NodeControlUtil, 'run_shell_command', lambda *_: output)\n+@pytest.mark.parametrize(\n+    'pkg_name,version,expected_deps',\n+    [\n+        pytest.param('some_package', '1.2.3', ['aaa=1.2.4', 'bbb=1.2.5', 'ccc'], id='some_package'),\n+        pytest.param('some_other_package', '4.5.6', ['ddd=3.4.5', 'eee=5.1.2', 'fff'], id='some_other_package'),\n+        pytest.param(APP_NAME, '1.2.3', ['aaa=1.2.4', 'bbb=1.2.5', 'ccc'], id=APP_NAME),\n+        pytest.param('any_package', '1.2.3', ['aaa=1.2.4', 'bbb=1.2.5', 'ccc'], id='any_package'),\n+    ]\n+)\n+def test_curr_pkg_info(patch_run_shell_command, pkg_name, version, expected_deps):\n+    upstream_cls = src_version_cls(pkg_name)\n+    expected_version = DebianVersion(\n+        version, upstream_cls=upstream_cls)\n+\n+    pkg_info = NodeControlUtil.curr_pkg_info(pkg_name)\n+\n+    assert expected_version == pkg_info[0]\n+    assert isinstance(expected_version, type(pkg_info[0]))\n+    assert isinstance(expected_version.upstream, type(pkg_info[0].upstream))\n+    assert expected_deps == pkg_info[1]\n \n-    for pkg_name in [APP_NAME, 'any_package']:\n-        upstream_cls = src_version_cls(pkg_name)\n-        expected_version = DebianVersion(\n-            '1.2.3', upstream_cls=upstream_cls)\n \n-        pkg_info = NodeControlUtil.curr_pkg_info(pkg_name)\n+@pytest.mark.parametrize(\n+    'pkg_name',\n+    [\n+        pytest.param('{} | echo \"hey\"; echo \"hi\" && echo \"hello\"|echo \"hello world\"'.format(APP_NAME), id='multiple'),\n+        pytest.param('{}|echo \"hey\"'.format(APP_NAME), id='pipe'),\n+        pytest.param('{};echo \"hey\"'.format(APP_NAME), id='semi-colon'),\n+        pytest.param('{}&&echo \"hey\"'.format(APP_NAME), id='and'),\n+        pytest.param('{}\\necho \"hey\"'.format(APP_NAME), id='Cr'),\n+        pytest.param('{} echo \"hey\"'.format(APP_NAME), id='whitespace'),\n+    ]\n+)\n+def test_curr_pkg_info_with_command_concat(patch_run_shell_command, pkg_name):\n+    expected_deps = ['aaa=1.2.4', 'bbb=1.2.5', 'ccc']\n+    upstream_cls = src_version_cls(pkg_name)\n+    expected_version = DebianVersion(\n+        '1.2.3', upstream_cls=upstream_cls)\n+\n+    pkg_info = NodeControlUtil.curr_pkg_info(pkg_name)\n \n-        assert expected_version == pkg_info[0]\n-        assert isinstance(expected_version, type(pkg_info[0]))\n-        assert isinstance(expected_version.upstream, type(pkg_info[0].upstream))\n-        assert expected_deps == pkg_info[1]\n+    assert expected_version == pkg_info[0]\n+    assert isinstance(expected_version, type(pkg_info[0]))\n+    assert isinstance(expected_version.upstream, type(pkg_info[0].upstream))\n+    assert expected_deps == pkg_info[1]\n\\ No newline at end of file"
        },
        {
          "filename": "indy_node/test/request_handlers/test_pool_upgrade_handler.py",
          "status": "modified",
          "additions": 42,
          "deletions": 2,
          "patch": "@@ -71,6 +71,11 @@ def test_pool_upgrade_static_validation_passes(pool_upgrade_handler,\n def test_pool_upgrade_dynamic_validation_fails_pckg(pool_upgrade_handler,\n                                                     pool_upgrade_request,\n                                                     tconf):\n+    pool_upgrade_handler.upgrader.get_upgrade_txn = \\\n+        lambda predicate, reverse: \\\n+            {TXN_PAYLOAD: {TXN_PAYLOAD_DATA: {}}}\n+    pool_upgrade_handler.write_req_validator.validate = lambda a, b: 0\n+\n     pool_upgrade_request.operation[PACKAGE] = ''\n     with pytest.raises(InvalidClientRequest) as e:\n         pool_upgrade_handler.dynamic_validation(pool_upgrade_request, 0)\n@@ -82,23 +87,53 @@ def test_pool_upgrade_dynamic_validation_fails_not_installed(\n         pool_upgrade_handler,\n         pool_upgrade_request,\n         tconf):\n+    pool_upgrade_handler.upgrader.get_upgrade_txn = \\\n+        lambda predicate, reverse: \\\n+            {TXN_PAYLOAD: {TXN_PAYLOAD_DATA: {}}}\n+    pool_upgrade_handler.write_req_validator.validate = lambda a, b: 0\n+\n+    monkeypatch.setattr(NodeControlUtil, 'curr_pkg_info',\n+                        lambda *x: (None, None))\n+    with pytest.raises(InvalidClientRequest) as e:\n+        pool_upgrade_handler.dynamic_validation(pool_upgrade_request, 0)\n+    e.match('{} is not installed and cannot be upgraded'.format(pool_upgrade_request.operation[PACKAGE]))\n+\n+\n+def test_pool_upgrade_dynamic_validation_fails_not_installed_mpr(\n+        monkeypatch,\n+        pool_upgrade_handler,\n+        pool_upgrade_request,\n+        tconf):\n+    pool_upgrade_handler.upgrader.get_upgrade_txn = \\\n+        lambda predicate, reverse: \\\n+            {TXN_PAYLOAD: {TXN_PAYLOAD_DATA: {}}}\n+    pool_upgrade_handler.write_req_validator.validate = lambda a, b: 0\n+\n     monkeypatch.setattr(NodeControlUtil, 'curr_pkg_info',\n                         lambda *x: (None, None))\n+\n+    # When multiple packages are requested, only the first should be processed.\n+    pool_upgrade_request.operation[PACKAGE] = 'some_package some_other_package'\n     with pytest.raises(InvalidClientRequest) as e:\n         pool_upgrade_handler.dynamic_validation(pool_upgrade_request, 0)\n-    e.match('is not installed and cannot be upgraded')\n+    e.match('some_package is not installed and cannot be upgraded')\n \n \n def test_pool_upgrade_dynamic_validation_fails_belong(\n         monkeypatch,\n         pool_upgrade_handler,\n         pool_upgrade_request,\n         tconf):\n+    pool_upgrade_handler.upgrader.get_upgrade_txn = \\\n+        lambda predicate, reverse: \\\n+            {TXN_PAYLOAD: {TXN_PAYLOAD_DATA: {}}}\n+    pool_upgrade_handler.write_req_validator.validate = lambda a, b: 0\n+\n     monkeypatch.setattr(NodeControlUtil, 'curr_pkg_info',\n                         lambda *x: ('1.1.1', ['some_pkg']))\n     with pytest.raises(InvalidClientRequest) as e:\n         pool_upgrade_handler.dynamic_validation(pool_upgrade_request, 0)\n-    e.match('doesn\\'t belong to pool')\n+    e.match('{} doesn\\'t belong to pool'.format(pool_upgrade_request.operation[PACKAGE]))\n \n \n def test_pool_upgrade_dynamic_validation_fails_upgradable(\n@@ -107,6 +142,11 @@ def test_pool_upgrade_dynamic_validation_fails_upgradable(\n         pool_upgrade_request,\n         pkg_version,\n         tconf):\n+    pool_upgrade_handler.upgrader.get_upgrade_txn = \\\n+        lambda predicate, reverse: \\\n+            {TXN_PAYLOAD: {TXN_PAYLOAD_DATA: {}}}\n+    pool_upgrade_handler.write_req_validator.validate = lambda a, b: 0\n+\n     monkeypatch.setattr(\n         NodeControlUtil, 'curr_pkg_info',\n         lambda *x: (pkg_version, [APP_NAME])"
        },
        {
          "filename": "indy_node/utils/node_control_utils.py",
          "status": "modified",
          "additions": 58,
          "deletions": 0,
          "patch": "@@ -199,9 +199,27 @@ def run_shell_script_extended(\n \n     @classmethod\n     def _get_curr_info(cls, package):\n+        # Only allow processing of a single package\n+        package = re.split(\"\\s+|;|&&|\\|\", package.splitlines()[0], 1)[0].rstrip()\n+\n+        # Ensure the package exists before fetching the details directly from dpkg\n+        if not cls._package_exists(package):\n+            return ''\n+\n         cmd = compose_cmd(['dpkg', '-s', package])\n         return cls.run_shell_command(cmd)\n \n+    @classmethod\n+    def _package_exists(cls, package):\n+        cmd = compose_cmd(\n+            ['dpkg', '--get-selections', '|', 'grep', '-v', 'deinstall', '|', 'cut', '-f1']\n+        )\n+        installed_packages = cls.run_shell_command(cmd)\n+\n+        # Ensure full match of package names.\n+        is_installed = True if package in installed_packages.split('\\n') else False\n+        return is_installed\n+\n     @classmethod\n     def _parse_deps(cls, deps: str):\n         ret = []\n@@ -341,8 +359,48 @@ def _get_info_from_package_manager(cls, *package):\n     @classmethod\n     def update_package_cache(cls):\n         cmd = compose_cmd(['apt', 'update'])\n+        try:\n+            cls.run_shell_script(cmd)\n+        except Exception as e:\n+            # Currently two issues can stop this from working.\n+            # 1) The Sovrin Repo key needs to be updated\n+            #    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys CE7709D068DB5E88\n+            # 2) The following certificate validation error occurs:\n+            #       Err:6 https://repo.sovrin.org/deb xenial Release\n+            #         server certificate verification failed. CAfile: /etc/ssl/certs/ca-certificates.crt CRLfile: none\n+            #       Reading package lists... Done\n+            #       E: The repository 'https://repo.sovrin.org/deb xenial Release' does not have a Release file.\n+            #       N: Updating from such a repository can't be done securely, and is therefore disabled by default.\n+            #       N: See apt-secure(8) manpage for repository creation and user configuration details.\n+            #    This can be fixed by updating libgnutls30:\n+            #    apt --only-upgrade install -y libgnutls30\n+            logger.warning(\"Call to apt update failed in update_package_cache; {}\".format(e))\n+            cls.update_repo_keys()\n+            cls.update_apt_update_dependencies()\n+\n+            # Try again ...\n+            logger.info(\"Trying apt update again ...\")\n+            cls.run_shell_script(cmd)\n+\n+    @classmethod\n+    def update_repo_keys(cls):\n+        logger.info(\"Updating signing keys for the artifact repository ...\")\n+        cmd = compose_cmd(['apt-key', 'adv', '--keyserver', 'keyserver.ubuntu.com', '--recv-keys', 'CE7709D068DB5E88'])\n         cls.run_shell_script(cmd)\n \n+    @classmethod\n+    def update_apt_update_dependencies(cls):\n+        cmd = compose_cmd(['apt', 'list', '--upgradable'])\n+        logger.info(\"Getting list of upgradable packages ...\")\n+        upgradable_packages = cls.run_shell_command(cmd).split(\"\\n\")\n+        libgnutls30 = next((x for x in upgradable_packages if x.find('libgnutls30') != -1), None)\n+        if libgnutls30 is not None:\n+            logger.info(\"Upgrading libgnutls30 ...\")\n+            cmd = compose_cmd(['apt', '--only-upgrade', 'install', '-y', 'libgnutls30'])\n+            cls.run_shell_script(cmd)\n+        else:\n+            logger.info(\"libgnutls30 is already up to date.\")\n+\n     @classmethod\n     def get_deps_tree(cls, *package, depth=0):\n         ret = list(set(package))"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 6,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c52a5282adf0b18e7f5285c96f4e9aaf93e3a747",
            "date": "2024-11-26T21:38:13Z",
            "author_login": "WadeBarnes"
          },
          {
            "sha": "80bda24bfc04d1bfb4b0c1f5e14317ef4f65a4fb",
            "date": "2024-11-25T15:44:33Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "8b660b7282b1370e020d6ffc515f433929d80635",
            "date": "2024-11-12T14:45:40Z",
            "author_login": "WadeBarnes"
          },
          {
            "sha": "b41151b284e57c8963ebb19bfdac9be6dcfb3050",
            "date": "2024-11-11T21:55:52Z",
            "author_login": "leopardracer"
          },
          {
            "sha": "d7037d7bdf1558310d625868e40c9cd0cf654a43",
            "date": "2024-11-11T21:54:24Z",
            "author_login": "leopardracer"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-20",
    "description": "Indy Node is the server portion of a distributed ledger purpose-built for decentralized identity. In versions 1.12.4 and prior, the `pool-upgrade` request handler in Indy-Node allows an improperly authenticated attacker to remotely execute code on nodes within the network. The `pool-upgrade` request handler in Indy-Node 1.12.5 has been updated to properly authenticate pool-upgrade transactions before any processing is performed by the request handler. The transactions are further sanitized to prevent remote code execution. As a workaround, endorsers should not create DIDs for untrusted users. A vulnerable ledger should configure `auth_rules` to prevent new DIDs from being written to the ledger until the network can be upgraded.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-09-06T17:15:08.220",
    "last_modified": "2024-11-21T07:03:43.660",
    "fix_date": "2022-09-02T19:38:19Z"
  },
  "references": [
    {
      "url": "https://github.com/hyperledger/indy-node/commit/fe507474f77084faef4539101e2bbb4d508a97f5",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/hyperledger/indy-node/releases/tag/v1.12.5",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/hyperledger/indy-node/security/advisories/GHSA-r6v9-p59m-gj2p",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/hyperledger/indy-node/commit/fe507474f77084faef4539101e2bbb4d508a97f5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/hyperledger/indy-node/releases/tag/v1.12.5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/hyperledger/indy-node/security/advisories/GHSA-r6v9-p59m-gj2p",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:39.078327",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "indy-node",
    "owner": "hyperledger",
    "created_at": "2016-12-21T05:45:04Z",
    "updated_at": "2025-01-09T23:58:35Z",
    "pushed_at": "2025-01-13T21:55:52Z",
    "size": 23587,
    "stars": 688,
    "forks": 657,
    "open_issues": 45,
    "watchers": 688,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "authz",
      "feature-rich-schemas",
      "gha_optimizing",
      "hotfix-1.7.1",
      "hotfix-1.8.1",
      "indy-besu",
      "main",
      "node-crash-test",
      "release-1.7.0",
      "release-1.7.1",
      "release-1.8.0",
      "release-1.9.0",
      "release-1.9.1",
      "release-1.9.2",
      "release-1.10.0",
      "release-1.11.0",
      "release-1.12.0",
      "release-1.12.1",
      "release-1.12.2",
      "release-1.12.3",
      "release-1.12.4",
      "release-1.12.5",
      "release-1.12.6",
      "release-notes",
      "release-notes-1.9.0",
      "stable"
    ],
    "languages": {
      "Python": 2488328,
      "Shell": 138533,
      "Dockerfile": 10924,
      "Batchfile": 3329,
      "Makefile": 1650,
      "Jinja": 1587
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:30:26.688674"
  }
}