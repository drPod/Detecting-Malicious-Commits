{
  "cve_id": "CVE-2022-31054",
  "github_data": {
    "repository": "argoproj/argo-events",
    "fix_commit": "eaabcb6d65022fc34a0cc9ea7f00681abd326b35",
    "related_commits": [
      "eaabcb6d65022fc34a0cc9ea7f00681abd326b35",
      "eaabcb6d65022fc34a0cc9ea7f00681abd326b35"
    ],
    "patch_url": "https://github.com/argoproj/argo-events/commit/eaabcb6d65022fc34a0cc9ea7f00681abd326b35.patch",
    "fix_commit_details": {
      "sha": "eaabcb6d65022fc34a0cc9ea7f00681abd326b35",
      "commit_date": "2022-05-13T15:29:20Z",
      "author": {
        "login": "whynowy",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "chore: discontinue using ioutil (#1966)",
        "length": 86,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 375,
        "additions": 190,
        "deletions": 185
      },
      "files": [
        {
          "filename": "common/util.go",
          "status": "modified",
          "additions": 3,
          "deletions": 4,
          "patch": "@@ -23,7 +23,6 @@ import (\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"hash/fnv\"\n-\t\"io/ioutil\"\n \t\"net/http\"\n \t\"os\"\n \t\"reflect\"\n@@ -151,7 +150,7 @@ func GetSecretFromVolume(selector *v1.SecretKeySelector) (string, error) {\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n-\tdata, err := ioutil.ReadFile(filePath)\n+\tdata, err := os.ReadFile(filePath)\n \tif err != nil {\n \t\treturn \"\", errors.Wrapf(err, \"failed to get secret value of name: %s, key: %s\", selector.Name, selector.Key)\n \t}\n@@ -175,7 +174,7 @@ func GetConfigMapFromVolume(selector *v1.ConfigMapKeySelector) (string, error) {\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n-\tdata, err := ioutil.ReadFile(filePath)\n+\tdata, err := os.ReadFile(filePath)\n \tif err != nil {\n \t\treturn \"\", errors.Wrapf(err, \"failed to get configMap value of name: %s, key: %s\", selector.Name, selector.Key)\n \t}\n@@ -259,7 +258,7 @@ func GetTLSConfig(config *apicommon.TLSConfig) (*tls.Config, error) {\n \n \tc := &tls.Config{}\n \tif len(caCertPath) > 0 {\n-\t\tcaCert, err := ioutil.ReadFile(caCertPath)\n+\t\tcaCert, err := os.ReadFile(caCertPath)\n \t\tif err != nil {\n \t\t\treturn nil, errors.Wrapf(err, \"failed to read ca cert file %s\", caCertPath)\n \t\t}"
        },
        {
          "filename": "controllers/sensor/validate_test.go",
          "status": "modified",
          "additions": 9,
          "deletions": 6,
          "patch": "@@ -18,7 +18,7 @@ package sensor\n \n import (\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"strings\"\n \t\"testing\"\n \n@@ -31,14 +31,17 @@ import (\n \n func TestValidateSensor(t *testing.T) {\n \tdir := \"../../examples/sensors\"\n-\tfiles, dirErr := ioutil.ReadDir(dir)\n-\trequire.NoError(t, dirErr)\n+\tdirEntries, err := os.ReadDir(dir)\n+\trequire.NoError(t, err)\n \n-\tfor _, file := range files {\n+\tfor _, entry := range dirEntries {\n+\t\tif entry.IsDir() {\n+\t\t\tcontinue\n+\t\t}\n \t\tt.Run(\n-\t\t\tfmt.Sprintf(\"test example load: %s/%s\", dir, file.Name()),\n+\t\t\tfmt.Sprintf(\"test example load: %s/%s\", dir, entry.Name()),\n \t\t\tfunc(t *testing.T) {\n-\t\t\t\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", dir, file.Name()))\n+\t\t\t\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", dir, entry.Name()))\n \t\t\t\tassert.NoError(t, err)\n \n \t\t\t\tvar sensor *v1alpha1.Sensor"
        },
        {
          "filename": "docs/sensors/triggers/http-trigger.md",
          "status": "modified",
          "additions": 42,
          "deletions": 44,
          "patch": "@@ -13,6 +13,7 @@ Argo Events offers HTTP trigger which can easily invoke serverless functions lik\n <br/>\n \n ## Specification\n+\n The HTTP trigger specification is available [here](https://github.com/argoproj/argo-events/blob/master/api/sensor.md#httptrigger).\n \n ## REST API Calls\n@@ -21,21 +22,20 @@ Consider a scenario where your REST API server needs to consume events from even\n the integration yourself in the server code, although server logic has nothing to do any of the event-sources. This is where Argo Events HTTP trigger\n can help. The HTTP trigger takes the task of consuming events from event-sources away from API server and seamlessly integrates these events via REST API calls.\n \n-\n We will set up a basic go http server and connect it with the Minio events.\n \n-1. The HTTP server simply prints the request body as follows.\n+1.  The HTTP server simply prints the request body as follows.\n \n         package main\n \n         import (\n         \t\"fmt\"\n-        \t\"io/ioutil\"\n+        \t\"io\"\n         \t\"net/http\"\n         )\n \n         func hello(w http.ResponseWriter, req *http.Request) {\n-        \tbody, err := ioutil.ReadAll(req.Body)\n+        \tbody, err := io.ReadAll(req.Body)\n         \tif err != nil {\n         \t\tfmt.Printf(\"%+v\\n\", err)\n         \t\treturn\n@@ -50,35 +50,34 @@ We will set up a basic go http server and connect it with the Minio events.\n         \thttp.ListenAndServe(\":8090\", nil)\n         }\n \n-2. Deploy the HTTP server.\n+2.  Deploy the HTTP server.\n \n         kubectl -n argo-events apply -f https://raw.githubusercontent.com/argoproj/argo-events/stable/examples/tutorials/09-http-trigger/http-server.yaml\n \n-3. Create a service to expose the http server.\n+3.  Create a service to expose the http server.\n \n         kubectl -n argo-events apply -f https://raw.githubusercontent.com/argoproj/argo-events/stable/examples/tutorials/09-http-trigger/http-server-svc.yaml\n \n-4. Either use Ingress, OpenShift Route or port-forwarding to expose the http server.\n+4.  Either use Ingress, OpenShift Route or port-forwarding to expose the http server.\n \n         kubectl -n argo-events port-forward <http-server-pod-name> 8090:8090\n \n-5. Our goals is to seamlessly integrate Minio S3 bucket notifications with REST API server created in previous step. So,\n-   lets set up the Minio event-source available [here](https://argoproj.github.io/argo-events/setup/minio/).\n-   Don't create the sensor as we will be deploying it in next step.\n+5.  Our goals is to seamlessly integrate Minio S3 bucket notifications with REST API server created in previous step. So,\n+    lets set up the Minio event-source available [here](https://argoproj.github.io/argo-events/setup/minio/).\n+    Don't create the sensor as we will be deploying it in next step.\n \n-6. Create a sensor as follows.\n+6.  Create a sensor as follows.\n \n         kubectl apply -n argo-events -f https://raw.githubusercontent.com/argoproj/argo-events/stable/examples/sensors/http-trigger.yaml\n \n-7. Now, drop a file onto `input` bucket in Minio server.\n-\n+7.  Now, drop a file onto `input` bucket in Minio server.\n \n-8. The sensor has triggered a http request to the http server. Take a look at the logs.\n+8.  The sensor has triggered a http request to the http server. Take a look at the logs.\n \n         server is listening on 8090\n         {\"type\":\"minio\",\"bucket\":\"input\"}\n \n-9. Great!!!\n+9.  Great!!!\n \n ### Request Payload\n \n@@ -122,6 +121,7 @@ you want to define a generic trigger template in the sensor and populate values\n You can learn more about trigger parameterization [here](https://argoproj.github.io/argo-events/tutorials/02-parameterization/).\n \n ### Policy\n+\n Trigger policy helps you determine the status of the HTTP request and decide whether to stop or continue sensor.\n \n To determine whether the HTTP request was successful or not, the HTTP trigger provides a `Status` policy.\n@@ -155,32 +155,30 @@ The above HTTP trigger will be treated successful only if the HTTP request retur\n OpenFaaS offers a simple way to spin up serverless functions. Lets see how we can leverage Argo Events HTTP trigger\n to invoke OpenFaaS function.\n \n-1. If you don't have OpenFaaS installed, follow the [instructions](https://docs.openfaas.com/deployment/kubernetes/).\n-\n-2. Let's create a basic function. You can follow the [steps](https://blog.alexellis.io/serverless-golang-with-openfaas/).\n-   to set up the function.\n+1.  If you don't have OpenFaaS installed, follow the [instructions](https://docs.openfaas.com/deployment/kubernetes/).\n \n+2.  Let's create a basic function. You can follow the [steps](https://blog.alexellis.io/serverless-golang-with-openfaas/).\n+    to set up the function.\n \n-        package function\n+         package function\n \n-        import (\n-        \t\"fmt\"\n-        )\n-\n-        // Handle a serverless request\n-        func Handle(req []byte) string {\n-        \treturn fmt.Sprintf(\"Hello, Go. You said: %s\", string(req))\n-        }\n+         import (\n+         \t\"fmt\"\n+         )\n \n+         // Handle a serverless request\n+         func Handle(req []byte) string {\n+         \treturn fmt.Sprintf(\"Hello, Go. You said: %s\", string(req))\n+         }\n \n-3. Make sure the function pod is up and running.\n+3.  Make sure the function pod is up and running.\n \n-4. We are going to invoke OpenFaaS function on a message on Redis Subscriber.\n+4.  We are going to invoke OpenFaaS function on a message on Redis Subscriber.\n \n-5. Let's set up the Redis Database, Redis PubSub event-source as specified [here](https://argoproj.github.io/argo-events/setup/redis/).\n-   Do not create the Redis sensor, we are going to create it in next step.\n+5.  Let's set up the Redis Database, Redis PubSub event-source as specified [here](https://argoproj.github.io/argo-events/setup/redis/).\n+    Do not create the Redis sensor, we are going to create it in next step.\n \n-6. Let's create the sensor with OpenFaaS trigger.\n+6.  Let's create the sensor with OpenFaaS trigger.\n \n         apiVersion: argoproj.io/v1alpha1\n         kind: Sensor\n@@ -202,32 +200,32 @@ to invoke OpenFaaS function.\n                       dest: bucket\n                   method: POST\n \n-7. Publish a message on `FOO` channel using `redis-cli`.\n+7.  Publish a message on `FOO` channel using `redis-cli`.\n \n         PUBLISH FOO hello\n \n-8. As soon as you publish the message, the sensor will invoke the OpenFaaS function `gohash`.\n+8.  As soon as you publish the message, the sensor will invoke the OpenFaaS function `gohash`.\n \n ## Kubeless\n \n Similar to REST API calls, you can easily invoke Kubeless functions using HTTP trigger.\n \n-1. If you don't have Kubeless installed, follow the [installation](https://kubeless.io/docs/quick-start/).\n+1.  If you don't have Kubeless installed, follow the [installation](https://kubeless.io/docs/quick-start/).\n \n-2. Lets create a basic function.\n+2.  Lets create a basic function.\n \n         def hello(event, context):\n           print event\n           return event['data']\n \n-3. Make sure the function pod and service is created.\n+3.  Make sure the function pod and service is created.\n \n-4. Now, we are going to invoke the Kubeless function when a message is placed on a NATS queue.\n+4.  Now, we are going to invoke the Kubeless function when a message is placed on a NATS queue.\n \n-5. Let's set up the NATS event-source. Follow [instructions](https://argoproj.github.io/argo-events/setup/nats/#setup) for details.\n-   Do not create the NATS sensor, we are going to create it in next step.\n+5.  Let's set up the NATS event-source. Follow [instructions](https://argoproj.github.io/argo-events/setup/nats/#setup) for details.\n+    Do not create the NATS sensor, we are going to create it in next step.\n \n-6. Let's create NATS sensor with HTTP trigger.\n+6.  Let's create NATS sensor with HTTP trigger.\n \n         apiVersion: argoproj.io/v1alpha1\n         kind: Sensor\n@@ -254,11 +252,11 @@ Similar to REST API calls, you can easily invoke Kubeless functions using HTTP t\n                       dest: last_name\n                   method: POST\n \n-7. Once event-source and sensor pod are up and running, dispatch a message on `foo` subject using nats client.\n+7.  Once event-source and sensor pod are up and running, dispatch a message on `foo` subject using nats client.\n \n         go run main.go -s localhost foo '{\"first_name\": \"foo\", \"last_name\": \"bar\"}'\n \n-8. It will invoke Kubeless function `hello`.\n+8.  It will invoke Kubeless function `hello`.\n \n         {'event-time': None, 'extensions': {'request': <LocalRequest: POST http://hello.kubeless.svc.cluster.local:8080/> }, 'event-type': None, 'event-namespace': None, 'data': '{\"first_name\":\"foo\",\"last_name\":\"bar\"}', 'event-id': None}\n "
        },
        {
          "filename": "eventsources/common/naivewatcher/watcher_test.go",
          "status": "modified",
          "additions": 6,
          "deletions": 7,
          "patch": "@@ -2,7 +2,6 @@ package naivewatcher\n \n import (\n \t\"fmt\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"syscall\"\n@@ -41,7 +40,7 @@ func TestWatcherAutoCheck(t *testing.T) {\n \t}\n \tdefer watcher.Close()\n \n-\ttmpdir, err := ioutil.TempDir(\"\", \"naive-watcher-\")\n+\ttmpdir, err := os.MkdirTemp(\"\", \"naive-watcher-\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -85,7 +84,7 @@ func TestWatcherAutoCheck(t *testing.T) {\n \t}, events)\n \n \t// Write a file\n-\terr = ioutil.WriteFile(filepath.Join(tmpdir, \"bar\"), []byte(\"wow\"), 0666)\n+\terr = os.WriteFile(filepath.Join(tmpdir, \"bar\"), []byte(\"wow\"), 0666)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -111,7 +110,7 @@ func TestWatcherAutoCheck(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\terr = ioutil.WriteFile(filepath.Join(tmpdir, \"foo\"), []byte(\"wowwow\"), 0666)\n+\terr = os.WriteFile(filepath.Join(tmpdir, \"foo\"), []byte(\"wowwow\"), 0666)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -158,7 +157,7 @@ func TestWatcherManualCheck(t *testing.T) {\n \t}\n \tdefer watcher.Close()\n \n-\ttmpdir, err := ioutil.TempDir(\"\", \"naive-watcher-\")\n+\ttmpdir, err := os.MkdirTemp(\"\", \"naive-watcher-\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -193,7 +192,7 @@ func TestWatcherManualCheck(t *testing.T) {\n \t}, events)\n \n \t// Write a file\n-\terr = ioutil.WriteFile(filepath.Join(tmpdir, \"bar\"), []byte(\"wow\"), 0666)\n+\terr = os.WriteFile(filepath.Join(tmpdir, \"bar\"), []byte(\"wow\"), 0666)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -217,7 +216,7 @@ func TestWatcherManualCheck(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\terr = ioutil.WriteFile(filepath.Join(tmpdir, \"foo\"), []byte(\"wowwow\"), 0666)\n+\terr = os.WriteFile(filepath.Join(tmpdir, \"foo\"), []byte(\"wowwow\"), 0666)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}"
        },
        {
          "filename": "eventsources/sources/amqp/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package amqp\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/eventsources/sources\"\n@@ -35,7 +35,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"either url or urlSecret must be specified\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"amqp.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"amqp.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/awssns/start.go",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -23,7 +23,7 @@ import (\n \t\"encoding/base64\"\n \t\"encoding/json\"\n \t\"encoding/pem\"\n-\t\"io/ioutil\"\n+\t\"io\"\n \t\"net/http\"\n \t\"net/url\"\n \t\"reflect\"\n@@ -115,7 +115,8 @@ func (router *Router) HandleRoute(writer http.ResponseWriter, request *http.Requ\n \t\troute.Metrics.EventProcessingDuration(route.EventSourceName, route.EventName, float64(time.Since(start)/time.Millisecond))\n \t}(time.Now())\n \n-\tbody, err := ioutil.ReadAll(request.Body)\n+\trequest.Body = http.MaxBytesReader(writer, request.Body, 65536)\n+\tbody, err := io.ReadAll(request.Body)\n \tif err != nil {\n \t\tlogger.Errorw(\"failed to parse the request body\", zap.Error(err))\n \t\tcommon.SendErrorResponse(writer, err.Error())\n@@ -318,7 +319,7 @@ func (m *httpNotification) verify() error {\n \t}\n \tdefer res.Body.Close()\n \n-\tbody, err := ioutil.ReadAll(res.Body)\n+\tbody, err := io.ReadAll(io.LimitReader(res.Body, 65536))\n \tif err != nil {\n \t\treturn errors.Wrap(err, \"failed to read signing cert body\")\n \t}"
        },
        {
          "filename": "eventsources/sources/awssns/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package awssns\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/ghodss/yaml\"\n@@ -36,7 +36,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"must specify topic arn\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"aws-sns.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"aws-sns.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/awssqs/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package awssqs\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/ghodss/yaml\"\n@@ -40,7 +40,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"must specify queue name\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"aws-sqs.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"aws-sqs.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/azureeventshub/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package azureeventshub\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/ghodss/yaml\"\n@@ -36,7 +36,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"FQDN is not specified\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"azure-events-hub.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"azure-events-hub.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/bitbucket/start.go",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -20,7 +20,7 @@ import (\n \t\"crypto/rand\"\n \t\"encoding/json\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"io\"\n \t\"math/big\"\n \t\"net/http\"\n \t\"time\"\n@@ -76,7 +76,8 @@ func (router *Router) HandleRoute(writer http.ResponseWriter, request *http.Requ\n \t\treturn\n \t}\n \n-\tbody, err := ioutil.ReadAll(request.Body)\n+\trequest.Body = http.MaxBytesReader(writer, request.Body, 65536)\n+\tbody, err := io.ReadAll(request.Body)\n \tif err != nil {\n \t\tlogger.Desugar().Error(\"failed to parse request body\", zap.Error(err))\n \t\tcommon.SendErrorResponse(writer, err.Error())"
        },
        {
          "filename": "eventsources/sources/bitbucket/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -18,7 +18,7 @@ package bitbucket\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/ghodss/yaml\"\n@@ -35,7 +35,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"project key can't be empty\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"bitbucket.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"bitbucket.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/bitbucketserver/start.go",
          "status": "modified",
          "additions": 5,
          "deletions": 4,
          "patch": "@@ -22,7 +22,7 @@ import (\n \t\"crypto/sha256\"\n \t\"encoding/hex\"\n \t\"encoding/json\"\n-\t\"io/ioutil\"\n+\t\"io\"\n \t\"math/big\"\n \t\"net/http\"\n \t\"time\"\n@@ -84,7 +84,7 @@ func (router *Router) HandleRoute(writer http.ResponseWriter, request *http.Requ\n \t\troute.Metrics.EventProcessingDuration(route.EventSourceName, route.EventName, float64(time.Since(start)/time.Millisecond))\n \t}(time.Now())\n \n-\tbody, err := router.parseAndValidateBitbucketServerRequest(request)\n+\tbody, err := router.parseAndValidateBitbucketServerRequest(writer, request)\n \tif err != nil {\n \t\tlogger.Errorw(\"failed to parse/validate request\", zap.Error(err))\n \t\tcommon.SendErrorResponse(writer, err.Error())\n@@ -391,8 +391,9 @@ func (router *Router) createRequestBodyFromWebhook(hook bitbucketv1.Webhook) ([]\n \treturn requestBody, nil\n }\n \n-func (router *Router) parseAndValidateBitbucketServerRequest(request *http.Request) ([]byte, error) {\n-\tbody, err := ioutil.ReadAll(request.Body)\n+func (router *Router) parseAndValidateBitbucketServerRequest(writer http.ResponseWriter, request *http.Request) ([]byte, error) {\n+\trequest.Body = http.MaxBytesReader(writer, request.Body, 65536)\n+\tbody, err := io.ReadAll(request.Body)\n \tif err != nil {\n \t\treturn nil, errors.Wrap(err, \"failed to parse request body\")\n \t}"
        },
        {
          "filename": "eventsources/sources/bitbucketserver/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -18,7 +18,7 @@ package bitbucketserver\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/ghodss/yaml\"\n@@ -35,7 +35,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"at least one repository is required\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"bitbucketserver.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"bitbucketserver.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/calendar/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package calendar\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/eventsources/sources\"\n@@ -39,7 +39,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"must have either schedule or interval\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"calendar.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"calendar.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/emitter/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package emitter\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/eventsources/sources\"\n@@ -35,7 +35,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"broker url must be specified\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"emitter.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"emitter.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/file/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package file\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/ghodss/yaml\"\n@@ -36,7 +36,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"type must be specified\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"file.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"file.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/gcppubsub/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package gcppubsub\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/eventsources/sources\"\n@@ -35,7 +35,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"must specify topic or subscriptionID\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"gcp-pubsub.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"gcp-pubsub.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/generic/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -3,7 +3,7 @@ package generic\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/eventsources/sources\"\n@@ -19,7 +19,7 @@ func TestEventListener_ValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"server url can't be empty\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"generic.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"generic.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/github/start_test.go",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -19,7 +19,7 @@ package github\n import (\n \t\"bytes\"\n \t\"encoding/json\"\n-\t\"io/ioutil\"\n+\t\"io\"\n \t\"net/http\"\n \t\"testing\"\n \n@@ -74,15 +74,15 @@ func TestRouteActiveHandler(t *testing.T) {\n \t\t\tconvey.So(err, convey.ShouldBeNil)\n \n \t\t\trouter.HandleRoute(writer, &http.Request{\n-\t\t\t\tBody: ioutil.NopCloser(bytes.NewReader(body)),\n+\t\t\t\tBody: io.NopCloser(bytes.NewReader(body)),\n \t\t\t})\n \t\t\tconvey.So(writer.HeaderStatus, convey.ShouldEqual, http.StatusBadRequest)\n \n \t\t\tconvey.Convey(\"Active route should return success\", func() {\n \t\t\t\troute.Active = true\n \n \t\t\t\trouter.HandleRoute(writer, &http.Request{\n-\t\t\t\t\tBody: ioutil.NopCloser(bytes.NewReader(body)),\n+\t\t\t\t\tBody: io.NopCloser(bytes.NewReader(body)),\n \t\t\t\t})\n \n \t\t\t\tconvey.So(writer.HeaderStatus, convey.ShouldEqual, http.StatusBadRequest)\n@@ -121,15 +121,15 @@ func TestRouteActiveHandlerDeprecated(t *testing.T) {\n \t\t\tconvey.So(err, convey.ShouldBeNil)\n \n \t\t\trouter.HandleRoute(writer, &http.Request{\n-\t\t\t\tBody: ioutil.NopCloser(bytes.NewReader(body)),\n+\t\t\t\tBody: io.NopCloser(bytes.NewReader(body)),\n \t\t\t})\n \t\t\tconvey.So(writer.HeaderStatus, convey.ShouldEqual, http.StatusBadRequest)\n \n \t\t\tconvey.Convey(\"Active route should return success\", func() {\n \t\t\t\troute.Active = true\n \n \t\t\t\trouter.HandleRoute(writer, &http.Request{\n-\t\t\t\t\tBody: ioutil.NopCloser(bytes.NewReader(body)),\n+\t\t\t\t\tBody: io.NopCloser(bytes.NewReader(body)),\n \t\t\t\t})\n \n \t\t\t\tconvey.So(writer.HeaderStatus, convey.ShouldEqual, http.StatusBadRequest)"
        },
        {
          "filename": "eventsources/sources/github/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package github\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/eventsources/sources\"\n@@ -34,7 +34,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"either repositories or organizations is required\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"github.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"github.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/gitlab/start.go",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -20,7 +20,7 @@ import (\n \t\"context\"\n \t\"crypto/rand\"\n \t\"encoding/json\"\n-\t\"io/ioutil\"\n+\t\"io\"\n \t\"math/big\"\n \t\"net/http\"\n \t\"reflect\"\n@@ -86,8 +86,8 @@ func (router *Router) HandleRoute(writer http.ResponseWriter, request *http.Requ\n \t\t\treturn\n \t\t}\n \t}\n-\n-\tbody, err := ioutil.ReadAll(request.Body)\n+\trequest.Body = http.MaxBytesReader(writer, request.Body, 65536)\n+\tbody, err := io.ReadAll(request.Body)\n \tif err != nil {\n \t\tlogger.Errorw(\"failed to parse request body\", zap.Error(err))\n \t\tcommon.SendErrorResponse(writer, err.Error())"
        },
        {
          "filename": "eventsources/sources/gitlab/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package gitlab\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/ghodss/yaml\"\n@@ -36,7 +36,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"projects can't be empty\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"gitlab.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"gitlab.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/hdfs/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -3,7 +3,7 @@ package hdfs\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/eventsources/sources\"\n@@ -19,7 +19,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"type is required\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"hdfs.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"hdfs.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/kafka/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package kafka\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/ghodss/yaml\"\n@@ -36,7 +36,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"url must be specified\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"kafka.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"kafka.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/minio/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package minio\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/eventsources/sources\"\n@@ -35,7 +35,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"access key can't be empty\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"minio.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"minio.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/mqtt/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package mqtt\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/eventsources/sources\"\n@@ -35,7 +35,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"url must be specified\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"mqtt.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"mqtt.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/nats/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package nats\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/eventsources/sources\"\n@@ -35,7 +35,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"url must be specified\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"nats.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"nats.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/nsq/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package nsq\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/ghodss/yaml\"\n@@ -36,7 +36,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"host address must be specified\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"nsq.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"nsq.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/pulsar/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -18,7 +18,7 @@ package pulsar\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/eventsources/sources\"\n@@ -34,7 +34,7 @@ func TestEventListener_ValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"topics can't be empty list\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"pulsar.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"pulsar.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/redis/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package redis\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/eventsources/sources\"\n@@ -35,7 +35,7 @@ func TestValidateRedisEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"host address must be specified\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"redis.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"redis.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/redisStream/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package redisstream\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/eventsources/sources\"\n@@ -35,7 +35,7 @@ func TestValidateRedisEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"host address must be specified\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"redis-streams.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"redis-streams.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/resource/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package resource\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/ghodss/yaml\"\n@@ -36,7 +36,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"version must be specified\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"resource.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"resource.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/slack/start.go",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -20,7 +20,7 @@ import (\n \t\"bytes\"\n \t\"context\"\n \t\"encoding/json\"\n-\t\"io/ioutil\"\n+\t\"io\"\n \t\"net/http\"\n \t\"time\"\n \n@@ -271,9 +271,9 @@ func (rc *Router) handleSlashCommand(request *http.Request) ([]byte, error) {\n \n func getRequestBody(request *http.Request) ([]byte, error) {\n \t// Read request payload\n-\tbody, err := ioutil.ReadAll(request.Body)\n+\tbody, err := io.ReadAll(io.LimitReader(request.Body, 65536))\n \t// Reset request.Body ReadCloser to prevent side-effect if re-read\n-\trequest.Body = ioutil.NopCloser(bytes.NewBuffer(body))\n+\trequest.Body = io.NopCloser(bytes.NewBuffer(body))\n \tif err != nil {\n \t\treturn nil, errors.Wrap(err, \"failed to parse request body\")\n \t}"
        },
        {
          "filename": "eventsources/sources/slack/start_test.go",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -22,7 +22,7 @@ import (\n \t\"crypto/sha256\"\n \t\"encoding/hex\"\n \t\"encoding/json\"\n-\t\"io/ioutil\"\n+\t\"io\"\n \t\"net/http\"\n \t\"strconv\"\n \t\"strings\"\n@@ -64,7 +64,7 @@ func TestRouteActiveHandler(t *testing.T) {\n \t\t\tconvey.So(err, convey.ShouldBeNil)\n \t\t\tconvey.So(payload, convey.ShouldNotBeNil)\n \t\t\trouter.HandleRoute(writer, &http.Request{\n-\t\t\t\tBody: ioutil.NopCloser(bytes.NewReader(payload)),\n+\t\t\t\tBody: io.NopCloser(bytes.NewReader(payload)),\n \t\t\t})\n \t\t\tconvey.So(writer.HeaderStatus, convey.ShouldEqual, http.StatusInternalServerError)\n \t\t})\n@@ -102,7 +102,7 @@ func TestSlackSignature(t *testing.T) {\n \t\t\t}()\n \n \t\t\trouter.HandleRoute(writer, &http.Request{\n-\t\t\t\tBody:   ioutil.NopCloser(bytes.NewReader(payload)),\n+\t\t\t\tBody:   io.NopCloser(bytes.NewReader(payload)),\n \t\t\t\tHeader: h,\n \t\t\t\tMethod: \"POST\",\n \t\t\t})\n@@ -137,7 +137,7 @@ func TestInteractionHandler(t *testing.T) {\n \t\t\trouter.HandleRoute(writer, &http.Request{\n \t\t\t\tMethod: http.MethodPost,\n \t\t\t\tHeader: headers,\n-\t\t\t\tBody:   ioutil.NopCloser(strings.NewReader(buf.String())),\n+\t\t\t\tBody:   io.NopCloser(strings.NewReader(buf.String())),\n \t\t\t})\n \t\t\tresult := <-out\n \t\t\tconvey.So(writer.HeaderStatus, convey.ShouldEqual, http.StatusOK)\n@@ -173,7 +173,7 @@ func TestSlackCommandHandler(t *testing.T) {\n \t\t\trouter.HandleRoute(writer, &http.Request{\n \t\t\t\tMethod: http.MethodPost,\n \t\t\t\tHeader: headers,\n-\t\t\t\tBody:   ioutil.NopCloser(strings.NewReader(buf.String())),\n+\t\t\t\tBody:   io.NopCloser(strings.NewReader(buf.String())),\n \t\t\t})\n \t\t\tresult := <-out\n \t\t\tconvey.So(writer.HeaderStatus, convey.ShouldEqual, http.StatusOK)\n@@ -223,7 +223,7 @@ func TestEventHandler(t *testing.T) {\n \t\t\t}()\n \n \t\t\trouter.HandleRoute(writer, &http.Request{\n-\t\t\t\tBody: ioutil.NopCloser(bytes.NewBuffer(payload)),\n+\t\t\t\tBody: io.NopCloser(bytes.NewBuffer(payload)),\n \t\t\t})\n \t\t\tconvey.So(writer.HeaderStatus, convey.ShouldEqual, http.StatusInternalServerError)\n \t\t})"
        },
        {
          "filename": "eventsources/sources/slack/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package slack\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/eventsources/sources\"\n@@ -35,7 +35,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"token not provided\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"slack.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"slack.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/storagegrid/start.go",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -20,7 +20,7 @@ import (\n \t\"context\"\n \t\"encoding/json\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"io\"\n \t\"net/http\"\n \t\"net/url\"\n \t\"strings\"\n@@ -141,7 +141,8 @@ func (router *Router) HandleRoute(writer http.ResponseWriter, request *http.Requ\n \t}\n \n \tlogger.Info(\"parsing the request body...\")\n-\tbody, err := ioutil.ReadAll(request.Body)\n+\trequest.Body = http.MaxBytesReader(writer, request.Body, 65536)\n+\tbody, err := io.ReadAll(request.Body)\n \tif err != nil {\n \t\tlogger.Errorw(\"failed to parse request body\", zap.Error(err))\n \t\tcommon.SendErrorResponse(writer, \"\")"
        },
        {
          "filename": "eventsources/sources/storagegrid/start_test.go",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -19,7 +19,7 @@ package storagegrid\n import (\n \t\"bytes\"\n \t\"encoding/json\"\n-\t\"io/ioutil\"\n+\t\"io\"\n \t\"net/http\"\n \t\"testing\"\n \n@@ -102,7 +102,7 @@ func TestRouteActiveHandler(t *testing.T) {\n \t\t\tpbytes, err := yaml.Marshal(storageGridEventSource)\n \t\t\tconvey.So(err, convey.ShouldBeNil)\n \t\t\trouter.HandleRoute(writer, &http.Request{\n-\t\t\t\tBody: ioutil.NopCloser(bytes.NewReader(pbytes)),\n+\t\t\t\tBody: io.NopCloser(bytes.NewReader(pbytes)),\n \t\t\t})\n \t\t\tconvey.So(writer.HeaderStatus, convey.ShouldEqual, http.StatusBadRequest)\n \t\t})\n@@ -117,7 +117,7 @@ func TestRouteActiveHandler(t *testing.T) {\n \t\t\t}()\n \n \t\t\trouter.HandleRoute(writer, &http.Request{\n-\t\t\t\tBody: ioutil.NopCloser(bytes.NewReader([]byte(notification))),\n+\t\t\t\tBody: io.NopCloser(bytes.NewReader([]byte(notification))),\n \t\t\t})\n \t\t\tconvey.So(writer.HeaderStatus, convey.ShouldEqual, http.StatusOK)\n \t\t})"
        },
        {
          "filename": "eventsources/sources/storagegrid/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package storagegrid\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/eventsources/sources\"\n@@ -35,7 +35,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"topic arn must be provided\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"storage-grid.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"storage-grid.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/stripe/start.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package stripe\n import (\n \t\"context\"\n \t\"encoding/json\"\n-\t\"io/ioutil\"\n+\t\"io\"\n \t\"net/http\"\n \t\"time\"\n \n@@ -97,7 +97,7 @@ func (rc *Router) HandleRoute(writer http.ResponseWriter, request *http.Request)\n \n \tconst MaxBodyBytes = int64(65536)\n \trequest.Body = http.MaxBytesReader(writer, request.Body, MaxBodyBytes)\n-\tpayload, err := ioutil.ReadAll(request.Body)\n+\tpayload, err := io.ReadAll(request.Body)\n \tif err != nil {\n \t\tlogger.Errorw(\"error reading request body\", zap.Error(err))\n \t\twriter.WriteHeader(http.StatusServiceUnavailable)"
        },
        {
          "filename": "eventsources/sources/stripe/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package stripe\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/ghodss/yaml\"\n@@ -40,7 +40,7 @@ func TestValidateEventSource(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Equal(t, \"api key K8s secret selector not provided\", err.Error())\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"stripe.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"stripe.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "eventsources/sources/webhook/start.go",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package webhook\n import (\n \t\"context\"\n \t\"encoding/json\"\n-\t\"io/ioutil\"\n+\t\"io\"\n \t\"net/http\"\n \t\"time\"\n \n@@ -105,7 +105,8 @@ func (router *Router) HandleRoute(writer http.ResponseWriter, request *http.Requ\n \t\troute.Metrics.EventProcessingDuration(route.EventSourceName, route.EventName, float64(time.Since(start)/time.Millisecond))\n \t}(time.Now())\n \n-\tbody, err := ioutil.ReadAll(request.Body)\n+\trequest.Body = http.MaxBytesReader(writer, request.Body, 65536)\n+\tbody, err := io.ReadAll(request.Body)\n \tif err != nil {\n \t\tlogger.Errorw(\"failed to parse request body\", zap.Error(err))\n \t\tcommon.SendErrorResponse(writer, err.Error())"
        },
        {
          "filename": "eventsources/sources/webhook/validate_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package webhook\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/eventsources/sources\"\n@@ -36,7 +36,7 @@ func TestValidateEventSource(t *testing.T) {\n \terr := listener.ValidateEventSource(context.Background())\n \tassert.Error(t, err)\n \n-\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"webhook.yaml\"))\n+\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", sources.EventSourceDir, \"webhook.yaml\"))\n \tassert.Nil(t, err)\n \n \tvar eventSource *v1alpha1.EventSource"
        },
        {
          "filename": "hack/crds.go",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -1,15 +1,15 @@\n package main\n \n import (\n-\t\"io/ioutil\"\n+\t\"os\"\n \n \t\"sigs.k8s.io/yaml\"\n )\n \n type obj = map[string]interface{}\n \n func cleanCRD(filename string) {\n-\tdata, err := ioutil.ReadFile(filename)\n+\tdata, err := os.ReadFile(filename)\n \tif err != nil {\n \t\tpanic(err)\n \t}\n@@ -43,7 +43,7 @@ func cleanCRD(filename string) {\n \tif err != nil {\n \t\tpanic(err)\n \t}\n-\terr = ioutil.WriteFile(filename, data, 0666)\n+\terr = os.WriteFile(filename, data, 0666)\n \tif err != nil {\n \t\tpanic(err)\n \t}"
        },
        {
          "filename": "hack/gen-openapi-spec/main.go",
          "status": "modified",
          "additions": 2,
          "deletions": 3,
          "patch": "@@ -2,7 +2,6 @@ package main\n \n import (\n \t\"encoding/json\"\n-\t\"io/ioutil\"\n \t\"log\"\n \t\"os\"\n \t\"strings\"\n@@ -86,7 +85,7 @@ func main() {\n \tif err != nil {\n \t\tlog.Fatal(err.Error())\n \t}\n-\terr = ioutil.WriteFile(output, jsonBytes, 0644)\n+\terr = os.WriteFile(output, jsonBytes, 0644)\n \tif err != nil {\n \t\tpanic(err)\n \t}\n@@ -158,7 +157,7 @@ func swaggify(name string) string {\n }\n \n func getKubernetesSwagger(kubeSwaggerPath string) spec.Definitions {\n-\tdata, err := ioutil.ReadFile(kubeSwaggerPath)\n+\tdata, err := os.ReadFile(kubeSwaggerPath)\n \tif err != nil {\n \t\tpanic(err)\n \t}"
        },
        {
          "filename": "sensors/artifacts/file.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -18,7 +18,7 @@ package artifacts\n \n import (\n \t\"errors\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \n \t\"github.com/argoproj/argo-events/common/logging\"\n \t\"github.com/argoproj/argo-events/pkg/apis/sensor/v1alpha1\"\n@@ -39,7 +39,7 @@ func NewFileReader(fileArtifact *v1alpha1.FileArtifact) (ArtifactReader, error)\n }\n \n func (reader *FileReader) Read() ([]byte, error) {\n-\tcontent, err := ioutil.ReadFile(reader.fileArtifact.Path)\n+\tcontent, err := os.ReadFile(reader.fileArtifact.Path)\n \tif err != nil {\n \t\treturn nil, err\n \t}"
        },
        {
          "filename": "sensors/artifacts/file_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -17,7 +17,6 @@ limitations under the License.\n package artifacts\n \n import (\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"testing\"\n \n@@ -28,7 +27,7 @@ import (\n \n func TestFileReader(t *testing.T) {\n \tcontent := []byte(\"temp content\")\n-\ttmpfile, err := ioutil.TempFile(\"\", \"argo-events-temp\")\n+\ttmpfile, err := os.CreateTemp(\"\", \"argo-events-temp\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}"
        },
        {
          "filename": "sensors/artifacts/git.go",
          "status": "modified",
          "additions": 3,
          "deletions": 4,
          "patch": "@@ -18,7 +18,6 @@ package artifacts\n \n import (\n \t\"fmt\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"path\"\n \t\"strings\"\n@@ -78,7 +77,7 @@ func (g *GitArtifactReader) getRemote() string {\n }\n \n func getSSHKeyAuth(sshKeyFile string) (transport.AuthMethod, error) {\n-\tsshKey, err := ioutil.ReadFile(sshKeyFile)\n+\tsshKey, err := os.ReadFile(sshKeyFile)\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"failed to read ssh key file. err: %+v\", err)\n \t}\n@@ -198,7 +197,7 @@ func (g *GitArtifactReader) readFromRepository(r *git.Repository, dir string) ([\n \tif isSymbolLink {\n \t\treturn nil, fmt.Errorf(\"%q is a symbol link which is not allowed\", g.artifact.FilePath)\n \t}\n-\treturn ioutil.ReadFile(filePath)\n+\treturn os.ReadFile(filePath)\n }\n \n func (g *GitArtifactReader) getBranchOrTag() *git.CheckoutOptions {\n@@ -222,7 +221,7 @@ func (g *GitArtifactReader) getBranchOrTag() *git.CheckoutOptions {\n func (g *GitArtifactReader) Read() ([]byte, error) {\n \tcloneDir := g.artifact.CloneDirectory\n \tif cloneDir == \"\" {\n-\t\ttempDir, err := ioutil.TempDir(\"\", \"git-tmp\")\n+\t\ttempDir, err := os.MkdirTemp(\"\", \"git-tmp\")\n \t\tif err != nil {\n \t\t\treturn nil, errors.Wrap(err, \"failed to create a temp file to clone the repository\")\n \t\t}"
        },
        {
          "filename": "sensors/artifacts/s3.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -19,7 +19,7 @@ package artifacts\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"io\"\n \n \t\"github.com/minio/minio-go/v7\"\n \t\"github.com/minio/minio-go/v7/pkg/credentials\"\n@@ -61,7 +61,7 @@ func (reader *S3Reader) Read() ([]byte, error) {\n \t\t}\n \t}()\n \n-\tb, err := ioutil.ReadAll(obj)\n+\tb, err := io.ReadAll(io.LimitReader(obj, 65536))\n \tif err != nil {\n \t\treturn nil, err\n \t}"
        },
        {
          "filename": "sensors/artifacts/store_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -18,7 +18,7 @@ package artifacts\n \n import (\n \t\"context\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/argoproj/argo-events/pkg/apis/sensor/v1alpha1\"\n@@ -74,7 +74,7 @@ func TestGetArtifactReader(t *testing.T) {\n }\n \n func TestDecodeSensor(t *testing.T) {\n-\tb, err := ioutil.ReadFile(\"../../examples/sensors/multi-trigger-sensor.yaml\")\n+\tb, err := os.ReadFile(\"../../examples/sensors/multi-trigger-sensor.yaml\")\n \tassert.Nil(t, err)\n \t_, err = decodeAndUnstructure(b)\n \tassert.Nil(t, err)"
        },
        {
          "filename": "sensors/artifacts/url.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -2,7 +2,7 @@ package artifacts\n \n import (\n \t\"crypto/tls\"\n-\t\"io/ioutil\"\n+\t\"io\"\n \t\"net/http\"\n \n \t\"github.com/pkg/errors\"\n@@ -45,7 +45,7 @@ func (reader *URLReader) Read() ([]byte, error) {\n \t\treturn nil, errors.Errorf(\"status code %v\", resp.StatusCode)\n \t}\n \n-\tcontent, err := ioutil.ReadAll(resp.Body)\n+\tcontent, err := io.ReadAll(io.LimitReader(resp.Body, 65536))\n \tif err != nil {\n \t\tlog.Warnf(\"failed to read url body for %s: %s\", reader.urlArtifact.Path, err)\n \t\treturn nil, err"
        },
        {
          "filename": "sensors/triggers/argo-workflow/argo-workflow.go",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -18,7 +18,6 @@ package argo_workflow\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"os/exec\"\n \t\"strconv\"\n@@ -136,7 +135,7 @@ func (t *ArgoWorkflowTrigger) Execute(ctx context.Context, events map[string]*v1\n \n \tswitch op {\n \tcase v1alpha1.Submit:\n-\t\tfile, err := ioutil.TempFile(\"\", fmt.Sprintf(\"%s%s\", name, obj.GetGenerateName()))\n+\t\tfile, err := os.CreateTemp(\"\", fmt.Sprintf(\"%s%s\", name, obj.GetGenerateName()))\n \t\tif err != nil {\n \t\t\treturn nil, errors.Wrapf(err, \"failed to create a temp file for the workflow %s\", obj.GetName())\n \t\t}"
        },
        {
          "filename": "test/e2e/fixtures/given.go",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -1,7 +1,7 @@\n package fixtures\n \n import (\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"strings\"\n \t\"testing\"\n \n@@ -91,7 +91,7 @@ func (g *Given) readResource(text string, v metav1.Object) {\n \tif strings.HasPrefix(text, \"@\") {\n \t\tfile = strings.TrimPrefix(text, \"@\")\n \t} else {\n-\t\tf, err := ioutil.TempFile(\"\", \"argo-events-e2e\")\n+\t\tf, err := os.CreateTemp(\"\", \"argo-events-e2e\")\n \t\tif err != nil {\n \t\t\tg.t.Fatal(err)\n \t\t}\n@@ -106,7 +106,7 @@ func (g *Given) readResource(text string, v metav1.Object) {\n \t\tfile = f.Name()\n \t}\n \n-\tf, err := ioutil.ReadFile(file)\n+\tf, err := os.ReadFile(file)\n \tif err != nil {\n \t\tg.t.Fatal(err)\n \t}"
        },
        {
          "filename": "test/stress/main.go",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -5,7 +5,6 @@ import (\n \t\"context\"\n \t\"encoding/json\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"regexp\"\n@@ -674,7 +673,7 @@ func readResource(text string, v metav1.Object) error {\n \tif strings.HasPrefix(text, \"@\") {\n \t\tfile := strings.TrimPrefix(text, \"@\")\n \t\t_, fileName, _, _ := runtime.Caller(0)\n-\t\tdata, err = ioutil.ReadFile(filepath.Dir(fileName) + \"/\" + file)\n+\t\tdata, err = os.ReadFile(filepath.Dir(fileName) + \"/\" + file)\n \t\tif err != nil {\n \t\t\treturn fmt.Errorf(\"failed to read a file: %w\", err)\n \t\t}"
        },
        {
          "filename": "webhook/validator/eventsource_test.go",
          "status": "modified",
          "additions": 7,
          "deletions": 4,
          "patch": "@@ -2,7 +2,7 @@ package validator\n \n import (\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/ghodss/yaml\"\n@@ -13,10 +13,13 @@ import (\n \n func TestValidateEventSource(t *testing.T) {\n \tdir := \"../../examples/event-sources\"\n-\tfiles, err := ioutil.ReadDir(dir)\n+\tdirEntries, err := os.ReadDir(dir)\n \tassert.Nil(t, err)\n-\tfor _, file := range files {\n-\t\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", dir, file.Name()))\n+\tfor _, entry := range dirEntries {\n+\t\tif entry.IsDir() {\n+\t\t\tcontinue\n+\t\t}\n+\t\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", dir, entry.Name()))\n \t\tassert.Nil(t, err)\n \t\tvar es *v1alpha1.EventSource\n \t\terr = yaml.Unmarshal(content, &es)"
        },
        {
          "filename": "webhook/validator/sensor_test.go",
          "status": "modified",
          "additions": 7,
          "deletions": 4,
          "patch": "@@ -3,7 +3,7 @@ package validator\n import (\n \t\"context\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"os\"\n \t\"testing\"\n \n \t\"github.com/ghodss/yaml\"\n@@ -52,7 +52,7 @@ var (\n \n func TestValidateSensor(t *testing.T) {\n \tdir := \"../../examples/sensors\"\n-\tfiles, err := ioutil.ReadDir(dir)\n+\tdirEntries, err := os.ReadDir(dir)\n \tassert.Nil(t, err)\n \n \ttestBus := fakeBus.DeepCopy()\n@@ -61,8 +61,11 @@ func TestValidateSensor(t *testing.T) {\n \t_, err = fakeEventBusClient.ArgoprojV1alpha1().EventBus(testNamespace).Create(context.TODO(), testBus, metav1.CreateOptions{})\n \tassert.Nil(t, err)\n \n-\tfor _, file := range files {\n-\t\tcontent, err := ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", dir, file.Name()))\n+\tfor _, entry := range dirEntries {\n+\t\tif entry.IsDir() {\n+\t\t\tcontinue\n+\t\t}\n+\t\tcontent, err := os.ReadFile(fmt.Sprintf(\"%s/%s\", dir, entry.Name()))\n \t\tassert.Nil(t, err)\n \t\tvar sensor *v1alpha1.Sensor\n \t\terr = yaml.Unmarshal(content, &sensor)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 38,
        "unique_directories": 38,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "30541a1dc6f773e4116a79a7f97ad4b29dd9fcb1",
            "date": "2025-01-11T12:53:45Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "505c9259f67636252a24a0721e2af1f06f32123e",
            "date": "2025-01-11T12:36:51Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "02cc9bb02d0abf21465baa7287fc08f53e0f6665",
            "date": "2025-01-11T12:33:17Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "e3a92c53bf32aabfa27d2df917e8c6df0a09a811",
            "date": "2025-01-11T12:33:05Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "199e05467950d6204382ed58ccf315161873e800",
            "date": "2025-01-11T12:32:58Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "Argo Events is an event-driven workflow automation framework for Kubernetes. Prior to version 1.7.1, several `HandleRoute` endpoints make use of the deprecated `ioutil.ReadAll()`. `ioutil.ReadAll()` reads all the data into memory. As such, an attacker who sends a large request to the Argo Events server will be able to crash it and cause denial of service. A patch for this vulnerability has been released in Argo Events version 1.7.1.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-06-13T20:15:07.897",
    "last_modified": "2024-11-21T07:03:47.880",
    "fix_date": "2022-05-13T15:29:20Z"
  },
  "references": [
    {
      "url": "https://github.com/argoproj/argo-events/commit/eaabcb6d65022fc34a0cc9ea7f00681abd326b35",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-events/issues/1946",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-events/pull/1966",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-events/security/advisories/GHSA-5q86-62xr-3r57",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-events/commit/eaabcb6d65022fc34a0cc9ea7f00681abd326b35",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-events/issues/1946",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-events/pull/1966",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-events/security/advisories/GHSA-5q86-62xr-3r57",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:09.435054",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "argo-events",
    "owner": "argoproj",
    "created_at": "2018-05-17T15:06:49Z",
    "updated_at": "2025-01-13T20:11:56Z",
    "pushed_at": "2025-01-11T12:55:18Z",
    "size": 159355,
    "stars": 2409,
    "forks": 749,
    "open_issues": 147,
    "watchers": 2409,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Go": 1641980,
      "Shell": 15374,
      "Makefile": 9200,
      "Smarty": 3292,
      "Dockerfile": 1240
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T16:20:24.927235"
  }
}