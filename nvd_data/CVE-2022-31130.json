{
  "cve_id": "CVE-2022-31130",
  "github_data": {
    "repository": "grafana/grafana",
    "fix_commit": "4dd56e4dabce10007bf4ba1059bf54178c35b177",
    "related_commits": [
      "4dd56e4dabce10007bf4ba1059bf54178c35b177",
      "9da278c044ba605eb5a1886c48df9a2cb0d3885f",
      "4dd56e4dabce10007bf4ba1059bf54178c35b177",
      "9da278c044ba605eb5a1886c48df9a2cb0d3885f"
    ],
    "patch_url": "https://github.com/grafana/grafana/commit/4dd56e4dabce10007bf4ba1059bf54178c35b177.patch",
    "fix_commit_details": {
      "sha": "4dd56e4dabce10007bf4ba1059bf54178c35b177",
      "commit_date": "2022-09-09T16:41:22Z",
      "author": {
        "login": "marefr",
        "type": "User",
        "stats": {
          "total_commits": 1875,
          "average_weekly_commits": 3.2271944922547333,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 258
        }
      },
      "commit_message": {
        "title": "Security: Make proxy endpoints not leak sensitive HTTP headers",
        "length": 154,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 104,
        "additions": 102,
        "deletions": 2
      },
      "files": [
        {
          "filename": "pkg/api/plugins.go",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -24,6 +24,7 @@ import (\n \t\"github.com/grafana/grafana/pkg/plugins\"\n \t\"github.com/grafana/grafana/pkg/plugins/backendplugin\"\n \t\"github.com/grafana/grafana/pkg/plugins/manager/installer\"\n+\t\"github.com/grafana/grafana/pkg/services/contexthandler\"\n \t\"github.com/grafana/grafana/pkg/services/pluginsettings\"\n \t\"github.com/grafana/grafana/pkg/setting\"\n \t\"github.com/grafana/grafana/pkg/util/errutil\"\n@@ -546,6 +547,14 @@ func (hs *HTTPServer) makePluginResourceRequest(w http.ResponseWriter, req *http\n \t\t\ths.log.Warn(\"failed to to unpack JSONData in datasource instance settings\", \"err\", err)\n \t\t}\n \t}\n+\n+\tlist := contexthandler.AuthHTTPHeaderListFromContext(req.Context())\n+\tif list != nil {\n+\t\tfor _, name := range list.Items {\n+\t\t\treq.Header.Del(name)\n+\t\t}\n+\t}\n+\n \tproxyutil.ClearCookieHeader(req, keepCookieModel.KeepCookies)\n \tproxyutil.PrepareProxyRequest(req)\n "
        },
        {
          "filename": "pkg/api/plugins_test.go",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -20,6 +20,7 @@ import (\n \t\"github.com/grafana/grafana/pkg/infra/log\"\n \t\"github.com/grafana/grafana/pkg/models\"\n \t\"github.com/grafana/grafana/pkg/plugins\"\n+\t\"github.com/grafana/grafana/pkg/services/contexthandler\"\n \t\"github.com/grafana/grafana/pkg/setting\"\n \t\"github.com/grafana/grafana/pkg/web/webtest\"\n )\n@@ -275,6 +276,12 @@ func TestMakePluginResourceRequest(t *testing.T) {\n \t\tpluginClient: pluginClient,\n \t}\n \treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n+\n+\tconst customHeader = \"X-CUSTOM\"\n+\treq.Header.Set(customHeader, \"val\")\n+\tctx := contexthandler.WithAuthHTTPHeader(req.Context(), customHeader)\n+\treq = req.WithContext(ctx)\n+\n \tresp := httptest.NewRecorder()\n \tpCtx := backend.PluginContext{}\n \terr := hs.makePluginResourceRequest(resp, req, pCtx)\n@@ -287,6 +294,7 @@ func TestMakePluginResourceRequest(t *testing.T) {\n \t}\n \n \trequire.Equal(t, \"sandbox\", resp.Header().Get(\"Content-Security-Policy\"))\n+\trequire.Empty(t, req.Header.Get(customHeader))\n }\n \n func callGetPluginAsset(sc *scenarioContext) {"
        },
        {
          "filename": "pkg/middleware/middleware_basic_auth_test.go",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -36,6 +36,9 @@ func TestMiddlewareBasicAuth(t *testing.T) {\n \t\tassert.True(t, sc.context.IsSignedIn)\n \t\tassert.Equal(t, orgID, sc.context.OrgId)\n \t\tassert.Equal(t, models.ROLE_EDITOR, sc.context.OrgRole)\n+\t\tlist := contexthandler.AuthHTTPHeaderListFromContext(sc.context.Req.Context())\n+\t\trequire.NotNil(t, list)\n+\t\trequire.EqualValues(t, []string{\"Authorization\"}, list.Items)\n \t}, configure)\n \n \tmiddlewareScenario(t, \"Handle auth\", func(t *testing.T, sc *scenarioContext) {\n@@ -69,6 +72,9 @@ func TestMiddlewareBasicAuth(t *testing.T) {\n \n \t\tassert.True(t, sc.context.IsSignedIn)\n \t\tassert.Equal(t, id, sc.context.UserId)\n+\t\tlist := contexthandler.AuthHTTPHeaderListFromContext(sc.context.Req.Context())\n+\t\trequire.NotNil(t, list)\n+\t\trequire.EqualValues(t, []string{\"Authorization\"}, list.Items)\n \t}, configure)\n \n \tmiddlewareScenario(t, \"Should return error if user is not found\", func(t *testing.T, sc *scenarioContext) {"
        },
        {
          "filename": "pkg/middleware/middleware_jwt_auth_test.go",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -6,6 +6,7 @@ import (\n \t\"testing\"\n \n \t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n \n \t\"github.com/grafana/grafana/pkg/models\"\n \t\"github.com/grafana/grafana/pkg/services/contexthandler\"\n@@ -54,6 +55,9 @@ func TestMiddlewareJWTAuth(t *testing.T) {\n \t\tassert.Equal(t, orgID, sc.context.OrgId)\n \t\tassert.Equal(t, id, sc.context.UserId)\n \t\tassert.Equal(t, myUsername, sc.context.Login)\n+\t\tlist := contexthandler.AuthHTTPHeaderListFromContext(sc.context.Req.Context())\n+\t\trequire.NotNil(t, list)\n+\t\trequire.EqualValues(t, []string{sc.cfg.JWTAuthHeaderName}, list.Items)\n \t}, configure, configureUsernameClaim)\n \n \tmiddlewareScenario(t, \"Valid token with valid email claim\", func(t *testing.T, sc *scenarioContext) {"
        },
        {
          "filename": "pkg/middleware/middleware_test.go",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -395,6 +395,11 @@ func TestMiddlewareContext(t *testing.T) {\n \t\t\tassert.True(t, sc.context.IsSignedIn)\n \t\t\tassert.Equal(t, userID, sc.context.UserId)\n \t\t\tassert.Equal(t, orgID, sc.context.OrgId)\n+\t\t\tlist := contexthandler.AuthHTTPHeaderListFromContext(sc.context.Req.Context())\n+\t\t\trequire.NotNil(t, list)\n+\t\t\trequire.Contains(t, list.Items, sc.cfg.AuthProxyHeaderName)\n+\t\t\trequire.Contains(t, list.Items, \"X-WEBAUTH-GROUPS\")\n+\t\t\trequire.Contains(t, list.Items, \"X-WEBAUTH-ROLE\")\n \t\t}, func(cfg *setting.Cfg) {\n \t\t\tconfigure(cfg)\n \t\t\tcfg.LDAPEnabled = false"
        },
        {
          "filename": "pkg/services/contexthandler/auth_jwt.go",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -93,6 +93,9 @@ func (h *ContextHandler) initContextWithJWT(ctx *models.ReqContext, orgId int64)\n \t\treturn true\n \t}\n \n+\tnewCtx := WithAuthHTTPHeader(ctx.Req.Context(), h.Cfg.JWTAuthHeaderName)\n+\t*ctx.Req = *ctx.Req.WithContext(newCtx)\n+\n \tctx.SignedInUser = query.Result\n \tctx.IsSignedIn = true\n "
        },
        {
          "filename": "pkg/services/contexthandler/contexthandler.go",
          "status": "modified",
          "additions": 52,
          "deletions": 2,
          "patch": "@@ -211,6 +211,9 @@ func (h *ContextHandler) initContextWithAPIKey(reqContext *models.ReqContext) bo\n \t\treturn true\n \t}\n \n+\tctx := WithAuthHTTPHeader(reqContext.Req.Context(), \"Authorization\")\n+\t*reqContext.Req = *reqContext.Req.WithContext(ctx)\n+\n \t// fetch key\n \tkeyQuery := models.GetApiKeyByNameQuery{KeyName: decoded.Name, OrgId: decoded.OrgId}\n \tif err := h.SQLStore.GetApiKeyByName(reqContext.Req.Context(), &keyQuery); err != nil {\n@@ -287,7 +290,7 @@ func (h *ContextHandler) initContextWithBasicAuth(reqContext *models.ReqContext,\n \t\treturn false\n \t}\n \n-\tctx, span := h.tracer.Start(reqContext.Req.Context(), \"initContextWithBasicAuth\")\n+\t_, span := h.tracer.Start(reqContext.Req.Context(), \"initContextWithBasicAuth\")\n \tdefer span.End()\n \n \tusername, password, err := util.DecodeBasicAuthHeader(header)\n@@ -296,12 +299,15 @@ func (h *ContextHandler) initContextWithBasicAuth(reqContext *models.ReqContext,\n \t\treturn true\n \t}\n \n+\tctx := WithAuthHTTPHeader(reqContext.Req.Context(), \"Authorization\")\n+\t*reqContext.Req = *reqContext.Req.WithContext(ctx)\n+\n \tauthQuery := models.LoginUserQuery{\n \t\tUsername: username,\n \t\tPassword: password,\n \t\tCfg:      h.Cfg,\n \t}\n-\tif err := h.authenticator.AuthenticateUser(reqContext.Req.Context(), &authQuery); err != nil {\n+\tif err := h.authenticator.AuthenticateUser(ctx, &authQuery); err != nil {\n \t\treqContext.Logger.Debug(\n \t\t\t\"Failed to authorize the user\",\n \t\t\t\"username\", username,\n@@ -523,6 +529,15 @@ func (h *ContextHandler) initContextWithAuthProxy(reqContext *models.ReqContext,\n \n \tlogger.Debug(\"Successfully got user info\", \"userID\", user.UserId, \"username\", user.Login)\n \n+\tctx := WithAuthHTTPHeader(reqContext.Req.Context(), h.Cfg.AuthProxyHeaderName)\n+\tfor _, header := range h.Cfg.AuthProxyHeaders {\n+\t\tif header != \"\" {\n+\t\t\tctx = WithAuthHTTPHeader(ctx, header)\n+\t\t}\n+\t}\n+\n+\t*reqContext.Req = *reqContext.Req.WithContext(ctx)\n+\n \t// Add user info to context\n \treqContext.SignedInUser = user\n \treqContext.IsSignedIn = true\n@@ -542,3 +557,38 @@ func (h *ContextHandler) initContextWithAuthProxy(reqContext *models.ReqContext,\n \n \treturn true\n }\n+\n+type authHTTPHeaderListContextKey struct{}\n+\n+var authHTTPHeaderListKey = authHTTPHeaderListContextKey{}\n+\n+// AuthHTTPHeaderList used to record HTTP headers that being when verifying authentication\n+// of an incoming HTTP request.\n+type AuthHTTPHeaderList struct {\n+\tItems []string\n+}\n+\n+// WithAuthHTTPHeader returns a copy of parent in which the named HTTP header will be included\n+// and later retrievable by AuthHTTPHeaderListFromContext.\n+func WithAuthHTTPHeader(parent context.Context, name string) context.Context {\n+\tlist := AuthHTTPHeaderListFromContext(parent)\n+\n+\tif list == nil {\n+\t\tlist = &AuthHTTPHeaderList{\n+\t\t\tItems: []string{},\n+\t\t}\n+\t}\n+\n+\tlist.Items = append(list.Items, name)\n+\n+\treturn context.WithValue(parent, authHTTPHeaderListKey, list)\n+}\n+\n+// AuthHTTPHeaderListFromContext returns the AuthHTTPHeaderList in a context.Context, if any,\n+// and will include any HTTP headers used when verifying authentication of an incoming HTTP request.\n+func AuthHTTPHeaderListFromContext(c context.Context) *AuthHTTPHeaderList {\n+\tif list, ok := c.Value(authHTTPHeaderListKey).(*AuthHTTPHeaderList); ok {\n+\t\treturn list\n+\t}\n+\treturn nil\n+}"
        },
        {
          "filename": "pkg/util/proxyutil/reverse_proxy.go",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -10,6 +10,7 @@ import (\n \t\"time\"\n \n \tglog \"github.com/grafana/grafana/pkg/infra/log\"\n+\t\"github.com/grafana/grafana/pkg/services/contexthandler\"\n )\n \n // StatusClientClosedRequest A non-standard status code introduced by nginx\n@@ -66,6 +67,13 @@ func NewReverseProxy(logger glog.Logger, director func(*http.Request), opts ...R\n // wrapDirector wraps a director and adds additional functionality.\n func wrapDirector(d func(*http.Request)) func(req *http.Request) {\n \treturn func(req *http.Request) {\n+\t\tlist := contexthandler.AuthHTTPHeaderListFromContext(req.Context())\n+\t\tif list != nil {\n+\t\t\tfor _, name := range list.Items {\n+\t\t\t\treq.Header.Del(name)\n+\t\t\t}\n+\t\t}\n+\n \t\td(req)\n \t\tPrepareProxyRequest(req)\n "
        },
        {
          "filename": "pkg/util/proxyutil/reverse_proxy_test.go",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -9,6 +9,7 @@ import (\n \t\"time\"\n \n \t\"github.com/grafana/grafana/pkg/infra/log\"\n+\t\"github.com/grafana/grafana/pkg/services/contexthandler\"\n \t\"github.com/stretchr/testify/require\"\n )\n \n@@ -30,6 +31,11 @@ func TestReverseProxy(t *testing.T) {\n \t\treq.Header.Set(\"Referer\", \"https://test.com/api\")\n \t\treq.RemoteAddr = \"10.0.0.1\"\n \n+\t\tconst customHeader = \"X-CUSTOM\"\n+\t\treq.Header.Set(customHeader, \"val\")\n+\t\tctx := contexthandler.WithAuthHTTPHeader(req.Context(), customHeader)\n+\t\treq = req.WithContext(ctx)\n+\n \t\trp := NewReverseProxy(log.New(\"test\"), func(req *http.Request) {\n \t\t\treq.Header.Set(\"X-KEY\", \"value\")\n \t\t})\n@@ -49,6 +55,7 @@ func TestReverseProxy(t *testing.T) {\n \t\trequire.Empty(t, resp.Cookies())\n \t\trequire.Equal(t, \"sandbox\", resp.Header.Get(\"Content-Security-Policy\"))\n \t\trequire.NoError(t, resp.Body.Close())\n+\t\trequire.Empty(t, actualReq.Header.Get(customHeader))\n \t})\n \n \tt.Run(\"When proxying a request using WithModifyResponse should call it before default ModifyResponse func\", func(t *testing.T) {"
        }
      ],
      "file_patterns": {
        "security_files": 3,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 5,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7151ea6abc4336f72b837adec679891483ab963b",
            "date": "2025-01-14T14:58:38Z",
            "author_login": "spinillos"
          },
          {
            "sha": "b96a752db33b49add26f4e0588a989a9b04e8855",
            "date": "2025-01-14T14:36:58Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "125a11ca99e8f011ee6be1ceadda9397ddaeec86",
            "date": "2025-01-14T14:33:29Z",
            "author_login": "harisrozajac"
          },
          {
            "sha": "3884c0e89631bafede8a2d7aeb58ed1069058c4f",
            "date": "2025-01-14T14:08:01Z",
            "author_login": "jdbaldry"
          },
          {
            "sha": "037570b9c8fc36f2e58949b99166bb887237f639",
            "date": "2025-01-14T14:01:10Z",
            "author_login": "alexanderzobnin"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-200",
    "description": "Grafana is an open source observability and data visualization platform. Versions of Grafana for endpoints prior to 9.1.8 and 8.5.14 could leak authentication tokens to some destination plugins under some conditions. The vulnerability impacts data source and plugin proxy endpoints with authentication tokens. The destination plugin could receive a user's Grafana authentication token. Versions 9.1.8 and 8.5.14 contain a patch for this issue. As a workaround, do not use API keys, JWT authentication, or any HTTP Header based authentication.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-10-13T23:15:09.637",
    "last_modified": "2024-11-21T07:03:57.583",
    "fix_date": "2022-09-09T16:41:22Z"
  },
  "references": [
    {
      "url": "https://github.com/grafana/grafana/commit/4dd56e4dabce10007bf4ba1059bf54178c35b177",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/grafana/grafana/commit/9da278c044ba605eb5a1886c48df9a2cb0d3885f",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/grafana/grafana/releases/tag/v9.1.8",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/grafana/grafana/security/advisories/GHSA-jv32-5578-pxjc",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/grafana/grafana/commit/4dd56e4dabce10007bf4ba1059bf54178c35b177",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/grafana/grafana/commit/9da278c044ba605eb5a1886c48df9a2cb0d3885f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/grafana/grafana/releases/tag/v9.1.8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/grafana/grafana/security/advisories/GHSA-jv32-5578-pxjc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:41.336741",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "grafana",
    "owner": "grafana",
    "created_at": "2013-12-11T15:59:56Z",
    "updated_at": "2025-01-14T13:04:53Z",
    "pushed_at": "2025-01-14T13:12:26Z",
    "size": 1292625,
    "stars": 65883,
    "forks": 12291,
    "open_issues": 4193,
    "watchers": 65883,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "TypeScript": 29758164,
      "Go": 20683989,
      "Rich Text Format": 352348,
      "HTML": 334782,
      "CUE": 186863,
      "JavaScript": 170294,
      "Shell": 148477,
      "MDX": 147186,
      "Starlark": 132379,
      "SCSS": 112108,
      "Jsonnet": 39563,
      "Makefile": 24993,
      "Python": 23487,
      "Dockerfile": 21670,
      "Jinja": 11630,
      "HCL": 4097,
      "CSS": 3116,
      "Mustache": 2239,
      "Smarty": 2116,
      "PowerShell": 367,
      "Assembly": 168
    },
    "commit_activity": {
      "total_commits_last_year": 9810,
      "avg_commits_per_week": 188.65384615384616,
      "days_active_last_year": 302
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "agpl-3.0"
    },
    "collected_at": "2025-01-14T13:16:15.724443"
  }
}