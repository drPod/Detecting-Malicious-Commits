{
  "cve_id": "CVE-2022-31153",
  "github_data": {
    "repository": "OpenZeppelin/cairo-contracts",
    "fix_commit": "2cd60279c3332285d47edf9ee3888b71257acdc9",
    "related_commits": [
      "2cd60279c3332285d47edf9ee3888b71257acdc9",
      "2cd60279c3332285d47edf9ee3888b71257acdc9"
    ],
    "patch_url": "https://github.com/OpenZeppelin/cairo-contracts/commit/2cd60279c3332285d47edf9ee3888b71257acdc9.patch",
    "fix_commit_details": {
      "sha": "2cd60279c3332285d47edf9ee3888b71257acdc9",
      "commit_date": "2022-06-29T21:08:33Z",
      "author": {
        "login": "JulissaDantes",
        "type": "User",
        "stats": {
          "total_commits": 8,
          "average_weekly_commits": 0.0446927374301676,
          "total_additions": 1589,
          "total_deletions": 405,
          "weeks_active": 6
        }
      },
      "commit_message": {
        "title": "Eth account support (#361)",
        "length": 3282,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 736,
        "additions": 640,
        "deletions": 96
      },
      "files": [
        {
          "filename": "docs/Account.md",
          "status": "modified",
          "additions": 89,
          "deletions": 8,
          "patch": "@@ -13,6 +13,7 @@ A more detailed writeup on the topic can be found on [Perama's blogpost](https:/\n * [Keys, signatures and signers](#keys-signatures-and-signers)\n   * [Signer](#signer)\n   * [MockSigner utility](#mocksigner-utility)\n+  * [MockEthSigner utility](#mockethsigner-utility)\n * [Account entrypoint](#account-entrypoint)\n * [Call and AccountCallArray format](#call-and-accountcallarray-format)\n   * [Call](#call)\n@@ -24,6 +25,12 @@ A more detailed writeup on the topic can be found on [Perama's blogpost](https:/\n   * [`set_public_key`](#set_public_key)\n   * [`is_valid_signature`](#is_valid_signature)\n   * [`__execute__`](#__execute__)\n+  * [`is_valid_eth_signature`](#is_valid_eth_signature)\n+  * [`eth_execute`](#eth_execute)\n+  * [`_unsafe_execute`](#_unsafe_execute)\n+* [Presets](#presets)\n+  * [Account](#account)\n+  * [Eth Account](#eth-account)\n * [Account differentiation with ERC165](#account-differentiation-with-erc165)\n * [Extending the Account contract](#extending-the-account-contract)\n * [L1 escape hatch mechanism](#l1-escape-hatch-mechanism)\n@@ -159,6 +166,13 @@ If utilizing multicall, send multiple transactions with the `send_transactions`\n     )\n ```\n \n+### MockEthSigner utility\n+\n+The `MockEthSigner` class in [utils.py](../tests/utils.py) is used to perform transactions on a given Account with a secp256k1 curve key pair, crafting the transaction and managing nonces. It differs from the `MockSigner` implementation by:\n+\n+* not using the public key but its derived address instead (the last 20 bytes of the keccak256 hash of the public key and adding `0x` to the beginning)\n+* signing the message with a secp256k1 curve address\n+\n ## Account entrypoint\n \n `__execute__` acts as a single entrypoint for all user interaction with any contract, including managing the account contract itself. That's why if you want to change the public key controlling the Account, you would send a transaction targeting the very Account contract:\n@@ -361,11 +375,10 @@ is_valid: felt\n \n This is the only external entrypoint to interact with the Account contract. It:\n \n-1. Takes the input and builds a `Call` for each iterated message. See [Multicall transactions](#multicall-transactions) for more information\n-2. Validates the transaction signature matches the message (including the nonce)\n-3. Increments the nonce\n-4. Calls the target contract with the intended function selector and calldata parameters\n-5. Forwards the contract call response data as return value\n+1. Validates the transaction signature matches the message (including the nonce)\n+2. Increments the nonce\n+3. Calls the target contract with the intended function selector and calldata parameters\n+4. Forwards the contract call response data as return value\n \n Parameters:\n \n@@ -386,6 +399,69 @@ response_len: felt\n response: felt*\n ```\n \n+### `is_valid_eth_signature`\n+\n+Returns `TRUE` if a given signature in the secp256k1 curve is valid, otherwise it reverts. In the future it will return `FALSE` if a given signature is invalid (for more info please check [this issue](https://github.com/OpenZeppelin/cairo-contracts/issues/327)).\n+\n+Parameters:\n+\n+```cairo\n+signature_len: felt\n+signature: felt*\n+```\n+\n+Returns:\n+\n+```cairo\n+is_valid: felt\n+```\n+\n+> returns `TRUE` if a given signature is valid. Otherwise, reverts. In the future it will return `FALSE` if a given signature is invalid (for more info please check [this issue](https://github.com/OpenZeppelin/cairo-contracts/issues/327)).\n+\n+### `eth_execute`\n+\n+This follows the same idea as the vanilla version of `execute` with the sole difference that signature verification is on the secp256k1 curve.\n+\n+Parameters:\n+\n+```cairo\n+call_array_len: felt\n+call_array: AccountCallArray*\n+calldata_len: felt\n+calldata: felt*\n+nonce: felt\n+```\n+\n+> Note that the current signature scheme expects a 7-element array like `[sig_v, uint256_sig_r_low, uint256_sig_r_high, uint256_sig_s_low, uint256_sig_s_high, uint256_hash_low, uint256_hash_high]` given that the parameters of the verification are bigger than a felt.\n+\n+Returns:\n+\n+```cairo\n+response_len: felt\n+response: felt*\n+```\n+\n+### `_unsafe_execute`\n+\n+It's an internal method that performs the following tasks:\n+\n+1. Increments the nonce.\n+2. Takes the input and builds a `Call` for each iterated message. See [Multicall transactions](#multicall-transactions) for more information.\n+3. Calls the target contract with the intended function selector and calldata parameters\n+4. Forwards the contract call response data as return value\n+\n+## Presets\n+\n+The following contract presets are ready to deploy and can be used as-is for quick prototyping and testing. Each preset differs on the signature type being used by the Account.\n+\n+### Account\n+\n+The [`Account`](../src/openzeppelin/account/Account.cairo) preset uses StarkNet keys to validate transactions.\n+\n+### Eth Account\n+\n+The [`EthAccount`](../src/openzeppelin/account/EthAccount.cairo) preset supports Ethereum addresses, validating transactions with secp256k1 keys.\n+\n ## Account differentiation with ERC165\n \n Certain contracts like ERC721 require a means to differentiate between account contracts and non-account contracts. For a contract to declare itself as an account, it should implement [ERC165](https://eips.ethereum.org/EIPS/eip-165) as proposed in [#100](https://github.com/OpenZeppelin/cairo-contracts/discussions/100). To be in compliance with ERC165 specifications, the idea is to calculate the XOR of `IAccount`'s EVM selectors (not StarkNet selectors). The resulting magic value of `IAccount` is 0x50b70dcb.\n@@ -394,13 +470,18 @@ Our ERC165 integration on StarkNet is inspired by OpenZeppelin's Solidity implem\n \n ## Extending the Account contract\n \n-Account contracts can be extended by following the [extensibility pattern](../docs/Extensibility.md#the-pattern). The basic idea behind integrating the pattern is to import the requisite methods from the Account library and incorporate the extended logic thereafter.\n+Account contracts can be extended by following the [extensibility pattern](../docs/Extensibility.md#the-pattern).\n+\n+To implement custom account contracts, a pair of `validate` and `execute` functions should be exposed. This is why the Account library comes with different flavors of such pairs, like the vanilla `is_valid_signature` and `execute`, or the Ethereum flavored `is_valid_eth_signature` and `eth_execute` pair.\n+\n+Account contract developers are encouraged to implement the [standard Account interface](https://github.com/OpenZeppelin/cairo-contracts/discussions/41) and incorporate the custom logic thereafter.\n+\n+To implement alternative `execute` functions, make sure to check their corresponding `validate` function before calling the `_unsafe_execute` building block, as each of the current presets is doing. Do not expose `_unsafe_execute` directly.\n \n-Currently, there's only a single library/preset Account scheme, but we're looking for feedback and new presets to emerge. Some new validation schemes to look out for in the future:\n+Some other validation schemes to look out for in the future:\n \n * multisig\n * guardian logic like in [Argent's account](https://github.com/argentlabs/argent-contracts-starknet/blob/de5654555309fa76160ba3d7393d32d2b12e7349/contracts/ArgentAccount.cairo)\n-* [Ethereum signatures](https://github.com/OpenZeppelin/cairo-contracts/issues/161)\n \n ## L1 escape hatch mechanism\n "
        },
        {
          "filename": "src/openzeppelin/account/Account.cairo",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -3,7 +3,7 @@\n \n %lang starknet\n \n-from starkware.cairo.common.cairo_builtins import HashBuiltin, SignatureBuiltin\n+from starkware.cairo.common.cairo_builtins import HashBuiltin, SignatureBuiltin, BitwiseBuiltin\n \n from openzeppelin.account.library import Account, AccountCallArray\n \n@@ -95,7 +95,8 @@ func __execute__{\n         syscall_ptr : felt*,\n         pedersen_ptr : HashBuiltin*,\n         range_check_ptr,\n-        ecdsa_ptr: SignatureBuiltin*\n+        ecdsa_ptr: SignatureBuiltin*,\n+        bitwise_ptr: BitwiseBuiltin*\n     }(\n         call_array_len: felt,\n         call_array: AccountCallArray*,"
        },
        {
          "filename": "src/openzeppelin/account/EthAccount.cairo",
          "status": "added",
          "additions": 113,
          "deletions": 0,
          "patch": "@@ -0,0 +1,113 @@\n+# SPDX-License-Identifier: MIT\n+# OpenZeppelin Contracts for Cairo v0.1.0 (account/EthAccount.cairo)\n+\n+%lang starknet\n+from starkware.cairo.common.cairo_builtins import HashBuiltin, SignatureBuiltin, BitwiseBuiltin\n+from openzeppelin.account.library import Account, AccountCallArray\n+\n+from openzeppelin.introspection.ERC165 import ERC165\n+\n+#\n+# Constructor\n+#\n+\n+@constructor\n+func constructor{\n+        syscall_ptr : felt*,\n+        pedersen_ptr : HashBuiltin*,\n+        range_check_ptr\n+    }(eth_address: felt):\n+    Account.initializer(eth_address)\n+    return ()\n+end\n+\n+#\n+# Getters\n+#\n+\n+@view\n+func get_eth_address{\n+        syscall_ptr : felt*,\n+        pedersen_ptr : HashBuiltin*,\n+        range_check_ptr\n+    }() -> (res: felt):\n+    let (res) = Account.get_public_key()\n+    return (res=res)\n+end\n+\n+@view\n+func get_nonce{\n+        syscall_ptr : felt*, \n+        pedersen_ptr : HashBuiltin*,\n+        range_check_ptr\n+    }() -> (res: felt):\n+    let (res) = Account.get_nonce()\n+    return (res=res)\n+end\n+\n+@view\n+func supportsInterface{\n+        syscall_ptr: felt*,\n+        pedersen_ptr: HashBuiltin*,\n+        range_check_ptr\n+    } (interfaceId: felt) -> (success: felt):\n+    let (success) = ERC165.supports_interface(interfaceId)\n+    return (success)\n+end\n+\n+#\n+# Setters\n+#\n+\n+@external\n+func set_eth_address{\n+        syscall_ptr : felt*,\n+        pedersen_ptr : HashBuiltin*,\n+        range_check_ptr\n+    }(new_eth_address: felt):\n+    Account.set_public_key(new_eth_address)\n+    return ()\n+end\n+\n+#\n+# Business logic\n+#\n+\n+@view\n+func is_valid_signature{\n+        syscall_ptr : felt*,\n+        pedersen_ptr : HashBuiltin*,\n+        range_check_ptr,\n+        ecdsa_ptr: SignatureBuiltin*,\n+        bitwise_ptr: BitwiseBuiltin*\n+    }(\n+        hash: felt,\n+        signature_len: felt,\n+        signature: felt*\n+    ) -> (is_valid: felt):\n+    let (is_valid) = Account.is_valid_eth_signature(hash, signature_len, signature)\n+    return (is_valid=is_valid)\n+end\n+\n+@external\n+func __execute__{\n+        syscall_ptr : felt*,\n+        pedersen_ptr : HashBuiltin*,\n+        range_check_ptr,\n+        bitwise_ptr: BitwiseBuiltin*\n+    }(\n+        call_array_len: felt,\n+        call_array: AccountCallArray*,\n+        calldata_len: felt,\n+        calldata: felt*,\n+        nonce: felt\n+    ) -> (response_len: felt, response: felt*):    \n+    let (response_len, response) = Account.eth_execute(\n+        call_array_len,\n+        call_array,\n+        calldata_len,\n+        calldata,\n+        nonce\n+    )\n+    return (response_len=response_len, response=response)\n+end"
        },
        {
          "filename": "src/openzeppelin/account/library.cairo",
          "status": "modified",
          "additions": 103,
          "deletions": 16,
          "patch": "@@ -3,12 +3,14 @@\n from starkware.cairo.common.registers import get_fp_and_pc\n from starkware.starknet.common.syscalls import get_contract_address\n from starkware.cairo.common.signature import verify_ecdsa_signature\n-from starkware.cairo.common.cairo_builtins import HashBuiltin, SignatureBuiltin\n+from starkware.cairo.common.cairo_builtins import HashBuiltin, SignatureBuiltin, BitwiseBuiltin\n from starkware.cairo.common.alloc import alloc\n+from starkware.cairo.common.uint256 import Uint256\n from starkware.cairo.common.memcpy import memcpy\n+from starkware.cairo.common.math import split_felt\n from starkware.cairo.common.bool import TRUE\n from starkware.starknet.common.syscalls import call_contract, get_caller_address, get_tx_info\n-\n+from starkware.cairo.common.cairo_secp.signature import verify_eth_signature_uint256\n from openzeppelin.introspection.ERC165 import ERC165\n \n from openzeppelin.utils.constants import IACCOUNT_ID\n@@ -141,12 +143,49 @@ namespace Account:\n         return (is_valid=TRUE)\n     end\n \n+ func is_valid_eth_signature{\n+            syscall_ptr : felt*,\n+            pedersen_ptr : HashBuiltin*,\n+            bitwise_ptr: BitwiseBuiltin*,\n+            range_check_ptr\n+        }(\n+            hash: felt,\n+            signature_len: felt,\n+            signature: felt*\n+        ) -> (is_valid: felt):\n+        alloc_locals\n+        let (_public_key) = get_public_key()\n+        let (__fp__, _) = get_fp_and_pc()\n+\n+        # This interface expects a signature pointer and length to make\n+        # no assumption about signature validation schemes.\n+        # But this implementation does, and it expects a the sig_v, sig_r, \n+        # sig_s, and hash elements.\n+        let sig_v : felt = signature[0]\n+        let sig_r : Uint256 = Uint256(low=signature[1], high=signature[2])\n+        let sig_s : Uint256 = Uint256(low=signature[3], high=signature[4])\n+        let (high, low) = split_felt(hash)\n+        let msg_hash : Uint256 = Uint256(low=low, high=high)\n+        \n+        let (local keccak_ptr : felt*) = alloc()\n+\n+        with keccak_ptr:\n+            verify_eth_signature_uint256(\n+                msg_hash=msg_hash,\n+                r=sig_r,\n+                s=sig_s,\n+                v=sig_v,\n+                eth_address=_public_key)                        \n+        end\n+\n+        return (is_valid=TRUE)\n+    end\n \n     func execute{\n             syscall_ptr : felt*,\n             pedersen_ptr : HashBuiltin*,\n             range_check_ptr,\n-            ecdsa_ptr: SignatureBuiltin*\n+            bitwise_ptr: BitwiseBuiltin*\n         }(\n             call_array_len: felt,\n             call_array: AccountCallArray*,\n@@ -156,34 +195,81 @@ namespace Account:\n         ) -> (response_len: felt, response: felt*):\n         alloc_locals\n \n+        let (__fp__, _) = get_fp_and_pc()\n+        let (tx_info) = get_tx_info()\n+        let (local ecdsa_ptr : SignatureBuiltin*) = alloc()\n+        with ecdsa_ptr:\n+            # validate transaction\n+            with_attr error_message(\"Account: invalid signature\"):\n+                let (is_valid) = is_valid_signature(tx_info.transaction_hash, tx_info.signature_len, tx_info.signature)\n+                assert is_valid = TRUE\n+            end\n+        end        \n+\n+        return _unsafe_execute(call_array_len, call_array, calldata_len, calldata, nonce)\n+    end\n+\n+    func eth_execute{\n+            syscall_ptr : felt*,\n+            pedersen_ptr : HashBuiltin*,\n+            range_check_ptr,\n+            bitwise_ptr: BitwiseBuiltin*\n+        }(\n+            call_array_len: felt,\n+            call_array: AccountCallArray*,\n+            calldata_len: felt,\n+            calldata: felt*,\n+            nonce: felt\n+        ) -> (response_len: felt, response: felt*):\n+        alloc_locals\n+\n+        let (__fp__, _) = get_fp_and_pc()\n+        let (tx_info) = get_tx_info()\n+\n+        # validate transaction        \n+        with_attr error_message(\"Account: invalid secp256k1 signature\"):\n+            let (is_valid) = is_valid_eth_signature(tx_info.transaction_hash, tx_info.signature_len, tx_info.signature)\n+            assert is_valid = TRUE\n+        end\n+                \n+        return _unsafe_execute(call_array_len, call_array, calldata_len, calldata, nonce)\n+    end\n+\n+    func _unsafe_execute{\n+            syscall_ptr : felt*,\n+            pedersen_ptr : HashBuiltin*,\n+            range_check_ptr,\n+            bitwise_ptr: BitwiseBuiltin*\n+        }(\n+            call_array_len: felt,\n+            call_array: AccountCallArray*,\n+            calldata_len: felt,\n+            calldata: felt*, \n+            nonce: felt\n+        ) -> (response_len: felt, response: felt*):\n+        alloc_locals\n+        \n         let (caller) = get_caller_address()\n         with_attr error_message(\"Account: no reentrant call\"):\n             assert caller = 0\n         end\n \n-        let (__fp__, _) = get_fp_and_pc()\n-        let (tx_info) = get_tx_info()\n-        let (_current_nonce) = Account_current_nonce.read()\n-\n         # validate nonce\n+\n+        let (_current_nonce) = Account_current_nonce.read()\n+        \n         with_attr error_message(\"Account: nonce is invalid\"):\n             assert _current_nonce = nonce\n         end\n \n+        # bump nonce\n+        Account_current_nonce.write(_current_nonce + 1)\n+\n         # TMP: Convert `AccountCallArray` to 'Call'.\n         let (calls : Call*) = alloc()\n         _from_call_array_to_call(call_array_len, call_array, calldata, calls)\n         let calls_len = call_array_len\n \n-        # validate transaction\n-        let (is_valid) = is_valid_signature(tx_info.transaction_hash, tx_info.signature_len, tx_info.signature)\n-        with_attr error_message(\"Account: invalid signature\"):\n-            assert is_valid = TRUE\n-        end\n-\n-        # bump nonce\n-        Account_current_nonce.write(_current_nonce + 1)\n-\n         # execute call\n         let (response : felt*) = alloc()\n         let (response_len) = _execute_list(calls_len, calls, response)\n@@ -240,4 +326,5 @@ namespace Account:\n         _from_call_array_to_call(call_array_len - 1, call_array + AccountCallArray.SIZE, calldata, calls + Call.SIZE)\n         return ()\n     end\n+    \n end"
        },
        {
          "filename": "tests/access/test_Ownable.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,7 +1,7 @@\n import pytest\n+from signers import MockSigner\n from starkware.starknet.testing.starknet import Starknet\n from utils import (\n-    MockSigner,\n     ZERO_ADDRESS,\n     assert_event_emitted,\n     get_contract_class,"
        },
        {
          "filename": "tests/account/test_Account.py",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,6 +1,7 @@\n import pytest\n from starkware.starknet.testing.starknet import Starknet\n-from utils import MockSigner, assert_revert, get_contract_class, cached_contract, TRUE\n+from signers import MockSigner\n+from utils import assert_revert, get_contract_class, cached_contract, TRUE\n \n \n signer = MockSigner(123456789987654321)"
        },
        {
          "filename": "tests/account/test_AddressRegistry.py",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,6 +1,7 @@\n import pytest\n from starkware.starknet.testing.starknet import Starknet\n-from utils import MockSigner, get_contract_class, cached_contract\n+from signers import MockSigner\n+from utils import get_contract_class, cached_contract\n \n \n signer = MockSigner(123456789987654321)"
        },
        {
          "filename": "tests/account/test_EthAccount.py",
          "status": "added",
          "additions": 203,
          "deletions": 0,
          "patch": "@@ -0,0 +1,203 @@\n+import pytest\n+from starkware.starknet.testing.starknet import Starknet\n+from starkware.starkware_utils.error_handling import StarkException\n+from starkware.starknet.definitions.error_codes import StarknetErrorCode\n+from utils import assert_revert, get_contract_class, cached_contract, TRUE, FALSE\n+from signers import MockEthSigner\n+\n+private_key = b'\\x01' * 32\n+signer = MockEthSigner(b'\\x01' * 32)\n+other = MockEthSigner(b'\\x02' * 32)\n+\n+IACCOUNT_ID = 0xf10dbd44\n+\n+\n+@pytest.fixture(scope='module')\n+def contract_defs():\n+    account_cls = get_contract_class('openzeppelin/account/EthAccount.cairo')\n+    init_cls = get_contract_class(\"tests/mocks/Initializable.cairo\")\n+    attacker_cls = get_contract_class(\"tests/mocks/account_reentrancy.cairo\")\n+\n+    return account_cls, init_cls, attacker_cls\n+\n+\n+@pytest.fixture(scope='module')\n+async def account_init(contract_defs):\n+    account_cls, init_cls, attacker_cls = contract_defs\n+    starknet = await Starknet.empty()\n+\n+    account1 = await starknet.deploy(\n+        contract_class=account_cls,\n+        constructor_calldata=[signer.eth_address]\n+    )\n+    account2 = await starknet.deploy(\n+        contract_class=account_cls,\n+        constructor_calldata=[signer.eth_address]\n+    )\n+    initializable1 = await starknet.deploy(\n+        contract_class=init_cls,\n+        constructor_calldata=[],\n+    )\n+    initializable2 = await starknet.deploy(\n+        contract_class=init_cls,\n+        constructor_calldata=[],\n+    )\n+    attacker = await starknet.deploy(\n+        contract_class=attacker_cls,\n+        constructor_calldata=[],\n+    )\n+\n+    return starknet.state, account1, account2, initializable1, initializable2, attacker\n+\n+\n+@pytest.fixture\n+def account_factory(contract_defs, account_init):\n+    account_cls, init_cls, attacker_cls = contract_defs\n+    state, account1, account2, initializable1, initializable2, attacker = account_init\n+    _state = state.copy()\n+    account1 = cached_contract(_state, account_cls, account1)\n+    account2 = cached_contract(_state, account_cls, account2)\n+    initializable1 = cached_contract(_state, init_cls, initializable1)\n+    initializable2 = cached_contract(_state, init_cls, initializable2)\n+    attacker = cached_contract(_state, attacker_cls, attacker)\n+\n+    return account1, account2, initializable1, initializable2, attacker\n+\n+\n+@pytest.mark.asyncio\n+async def test_constructor(account_factory):\n+    account, *_ = account_factory\n+\n+    execution_info = await account.get_eth_address().call()\n+    assert execution_info.result == (signer.eth_address,)\n+\n+    execution_info = await account.supportsInterface(IACCOUNT_ID).call()\n+    assert execution_info.result == (TRUE,)\n+\n+\n+@pytest.mark.asyncio\n+async def test_execute(account_factory):\n+    account, _, initializable, *_ = account_factory\n+\n+    execution_info = await initializable.initialized().call()\n+    assert execution_info.result == (FALSE,)\n+\n+    _, hash, signature = await signer.send_transactions(account, [(initializable.contract_address, 'initialize', [])])\n+\n+    validity_info, *_ = await signer.send_transactions(account, [(account.contract_address, 'is_valid_signature', [hash, len(signature), *signature])])\n+    assert validity_info.result.response[0] == TRUE\n+\n+    execution_info = await initializable.initialized().call()\n+    assert execution_info.result == (TRUE,)\n+\n+    # should revert if signature is not correct\n+    await assert_revert(\n+        signer.send_transactions(account, [(account.contract_address, 'is_valid_signature', [hash-1, len(signature), *signature])]),\n+        reverted_with=\"Invalid signature\"\n+    )\n+\n+\n+@pytest.mark.asyncio\n+async def test_multicall(account_factory):\n+    account, _, initializable_1, initializable_2, _ = account_factory\n+\n+    execution_info = await initializable_1.initialized().call()\n+    assert execution_info.result == (FALSE,)\n+    execution_info = await initializable_2.initialized().call()\n+    assert execution_info.result == (FALSE,)\n+\n+    await signer.send_transactions(\n+        account,\n+        [\n+            (initializable_1.contract_address, 'initialize', []),\n+            (initializable_2.contract_address, 'initialize', [])\n+        ]\n+    )\n+\n+    execution_info = await initializable_1.initialized().call()\n+    assert execution_info.result == (TRUE,)\n+    execution_info = await initializable_2.initialized().call()\n+    assert execution_info.result == (TRUE,)\n+\n+\n+@pytest.mark.asyncio\n+async def test_return_value(account_factory):\n+    account, _, initializable, *_ = account_factory\n+\n+    # initialize, set `initialized = 1`\n+    await signer.send_transactions(account, [(initializable.contract_address, 'initialize', [])])\n+\n+    read_info, *_ = await signer.send_transactions(account, [(initializable.contract_address, 'initialized', [])])\n+    call_info = await initializable.initialized().call()\n+    (call_result, ) = call_info.result\n+    assert read_info.result.response == [call_result]  # 1\n+\n+\n+@ pytest.mark.asyncio\n+async def test_nonce(account_factory):\n+    account, _, initializable, *_ = account_factory\n+    \n+    # bump nonce \n+    _, hash, signature = await signer.send_transactions(account, [(initializable.contract_address, 'initialized', [])])\n+\n+    execution_info = await account.get_nonce().call()\n+    current_nonce = execution_info.result.res\n+\n+    # lower nonce\n+    await assert_revert(\n+        signer.send_transactions(account, [(initializable.contract_address, 'initialize', [])], current_nonce - 1),\n+        reverted_with=\"Account: nonce is invalid\"\n+    )\n+\n+    # higher nonce\n+    await assert_revert(\n+        signer.send_transactions(account, [(initializable.contract_address, 'initialize', [])], current_nonce + 1),\n+        reverted_with=\"Account: nonce is invalid\"\n+    )\n+\n+    # right nonce\n+    await signer.send_transactions(account, [(initializable.contract_address, 'initialize', [])], current_nonce)\n+\n+    execution_info = await initializable.initialized().call()\n+    assert execution_info.result == (TRUE,)\n+\n+\n+@pytest.mark.asyncio\n+async def test_eth_address_setter(account_factory):\n+    account, *_ = account_factory\n+\n+    execution_info = await account.get_eth_address().call()\n+    assert execution_info.result == (signer.eth_address,)\n+\n+    # set new pubkey\n+    await signer.send_transactions(account, [(account.contract_address, 'set_eth_address', [other.eth_address])])\n+\n+    execution_info = await account.get_eth_address().call()\n+    assert execution_info.result == (other.eth_address,)\n+\n+\n+@pytest.mark.asyncio\n+async def test_eth_address_setter_different_account(account_factory):\n+    account, bad_account, *_ = account_factory\n+\n+    # set new pubkey\n+    await assert_revert(\n+        signer.send_transactions(\n+            bad_account,\n+            [(account.contract_address, 'set_eth_address', [other.eth_address])]\n+        ),\n+        reverted_with=\"Account: caller is not this account\"\n+    )\n+\n+\n+@pytest.mark.asyncio\n+async def test_account_takeover_with_reentrant_call(account_factory):\n+    account, _, _, _, attacker = account_factory\n+\n+    await assert_revert(\n+        signer.send_transaction(account, attacker.contract_address, 'account_takeover', []),\n+        reverted_with=\"Account: no reentrant call\"\n+    )\n+    \n+    execution_info = await account.get_eth_address().call()\n+    assert execution_info.result == (signer.eth_address,)"
        },
        {
          "filename": "tests/security/test_pausable.py",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -1,10 +1,12 @@\n import pytest\n from starkware.starknet.testing.starknet import Starknet\n+from signers import MockSigner\n from utils import (\n     TRUE, FALSE, assert_revert, assert_event_emitted, \n-    get_contract_class, cached_contract, MockSigner\n+    get_contract_class, cached_contract\n )\n \n+\n signer = MockSigner(12345678987654321)\n \n @pytest.fixture"
        },
        {
          "filename": "tests/signers.py",
          "status": "added",
          "additions": 95,
          "deletions": 0,
          "patch": "@@ -0,0 +1,95 @@\n+from nile.signer import Signer, from_call_to_call_array, get_transaction_hash\n+from utils import to_uint\n+import eth_keys\n+\n+class MockSigner():\n+    \"\"\"\n+    Utility for sending signed transactions to an Account on Starknet.\n+\n+    Parameters\n+    ----------\n+\n+    private_key : int\n+\n+    Examples\n+    ---------\n+    Constructing a MockSigner object\n+\n+    >>> signer = MockSigner(1234)\n+\n+    Sending a transaction\n+\n+    >>> await signer.send_transaction(\n+            account, contract_address, 'contract_method', [arg_1]\n+        )\n+\n+    Sending multiple transactions\n+\n+    >>> await signer.send_transaction(\n+            account, [\n+                (contract_address, 'contract_method', [arg_1]),\n+                (contract_address, 'another_method', [arg_1, arg_2])\n+            ]\n+        )\n+                           \n+    \"\"\"\n+    def __init__(self, private_key):\n+        self.signer = Signer(private_key)\n+        self.public_key = self.signer.public_key\n+        \n+    async def send_transaction(self, account, to, selector_name, calldata, nonce=None, max_fee=0):\n+        return await self.send_transactions(account, [(to, selector_name, calldata)], nonce, max_fee)\n+\n+    async def send_transactions(self, account, calls, nonce=None, max_fee=0):\n+        if nonce is None:\n+            execution_info = await account.get_nonce().call()\n+            nonce, = execution_info.result\n+\n+        build_calls = []\n+        for call in calls:\n+            build_call = list(call)\n+            build_call[0] = hex(build_call[0])\n+            build_calls.append(build_call)\n+\n+        (call_array, calldata, sig_r, sig_s) = self.signer.sign_transaction(hex(account.contract_address), build_calls, nonce, max_fee)\n+        return await account.__execute__(call_array, calldata, nonce).invoke(signature=[sig_r, sig_s])\n+\n+class MockEthSigner():\n+    \"\"\"\n+    Utility for sending signed transactions to an Account on Starknet, like MockSigner, but using a secp256k1 signature.\n+    Parameters\n+    ----------\n+    private_key : int\n+                  \n+    \"\"\"\n+    def __init__(self, private_key):\n+        self.signer = eth_keys.keys.PrivateKey(private_key)        \n+        self.eth_address = int(self.signer.public_key.to_checksum_address(),0)\n+\n+    async def send_transaction(self, account, to, selector_name, calldata, nonce=None, max_fee=0):\n+        return await self.send_transactions(account, [(to, selector_name, calldata)], nonce, max_fee)\n+\n+    async def send_transactions(self, account, calls, nonce=None, max_fee=0):\n+        if nonce is None:\n+            execution_info = await account.get_nonce().call()\n+            nonce, = execution_info.result\n+\n+        build_calls = []\n+        for call in calls:\n+            build_call = list(call)\n+            build_call[0] = hex(build_call[0])\n+            build_calls.append(build_call)\n+\n+        (call_array, calldata) = from_call_to_call_array(build_calls)\n+        message_hash = get_transaction_hash(\n+            account.contract_address, call_array, calldata, nonce, max_fee\n+        )\n+        \n+        signature = self.signer.sign_msg_hash((message_hash).to_bytes(32, byteorder=\"big\"))        \n+        sig_r = to_uint(signature.r)\n+        sig_s = to_uint(signature.s)\n+\n+        # the hash and signature are returned for other tests to use\n+        return await account.__execute__(call_array, calldata, nonce).invoke(\n+            signature=[signature.v, *sig_r, *sig_s]\n+        ), message_hash, [signature.v, *sig_r, *sig_s]"
        },
        {
          "filename": "tests/token/erc20/test_ERC20.py",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -1,11 +1,13 @@\n import pytest\n from starkware.starknet.testing.starknet import Starknet\n+from signers import MockSigner\n from utils import (\n-    MockSigner, to_uint, add_uint, sub_uint, str_to_felt, MAX_UINT256, \n+    to_uint, add_uint, sub_uint, str_to_felt, MAX_UINT256, \n     ZERO_ADDRESS, INVALID_UINT256, TRUE, get_contract_class, cached_contract, \n     assert_revert, assert_event_emitted, contract_path\n )\n \n+\n signer = MockSigner(123456789987654321)\n \n # testing vars"
        },
        {
          "filename": "tests/token/erc20/test_ERC20_Burnable_mock.py",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -1,10 +1,12 @@\n import pytest\n from starkware.starknet.testing.starknet import Starknet\n+from signers import MockSigner\n from utils import (\n-    MockSigner, to_uint, add_uint, sub_uint, str_to_felt, ZERO_ADDRESS, INVALID_UINT256,\n-    get_contract_class, cached_contract, assert_revert, assert_event_emitted, \n+    to_uint, add_uint, sub_uint, str_to_felt, ZERO_ADDRESS, INVALID_UINT256,\n+    get_contract_class, cached_contract, assert_revert, assert_event_emitted\n )\n \n+\n signer = MockSigner(123456789987654321)\n \n # testing vars"
        },
        {
          "filename": "tests/token/erc20/test_ERC20_Mintable.py",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -1,11 +1,13 @@\n import pytest\n from starkware.starknet.testing.starknet import Starknet\n+from signers import MockSigner\n from utils import (\n-    MockSigner, to_uint, add_uint, sub_uint, str_to_felt, \n+    to_uint, add_uint, sub_uint, str_to_felt, \n     MAX_UINT256, ZERO_ADDRESS, INVALID_UINT256, get_contract_class, \n     cached_contract, assert_revert, assert_event_emitted\n )\n \n+\n signer = MockSigner(123456789987654321)\n \n # testing vars"
        },
        {
          "filename": "tests/token/erc20/test_ERC20_Pausable.py",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -1,10 +1,12 @@\n import pytest\n from starkware.starknet.testing.starknet import Starknet\n+from signers import MockSigner\n from utils import (\n-    MockSigner, TRUE, FALSE, to_uint, str_to_felt, assert_revert, \n+    TRUE, FALSE, to_uint, str_to_felt, assert_revert, \n     get_contract_class, cached_contract\n )\n \n+\n signer = MockSigner(123456789987654321)\n \n # testing vars"
        },
        {
          "filename": "tests/token/erc20/test_ERC20_Upgradeable.py",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -1,11 +1,13 @@\n import pytest\n from starkware.starknet.testing.starknet import Starknet\n+from signers import MockSigner\n from utils import (\n-    MockSigner, to_uint, sub_uint, str_to_felt, assert_revert,\n+    to_uint, sub_uint, str_to_felt, assert_revert,\n     get_contract_class, cached_contract\n )\n \n \n+\n signer = MockSigner(123456789987654321)\n \n USER = 999"
        },
        {
          "filename": "tests/token/erc721/test_ERC721_Mintable_Burnable.py",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,7 +1,8 @@\n import pytest\n from starkware.starknet.testing.starknet import Starknet\n+from signers import MockSigner\n from utils import (\n-    MockSigner, str_to_felt, ZERO_ADDRESS, TRUE, FALSE, assert_revert, INVALID_UINT256,\n+    str_to_felt, ZERO_ADDRESS, TRUE, FALSE, assert_revert, INVALID_UINT256,\n     assert_event_emitted, get_contract_class, cached_contract, to_uint, sub_uint, add_uint\n )\n "
        },
        {
          "filename": "tests/token/erc721/test_ERC721_Mintable_Pausable.py",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,7 +1,8 @@\n import pytest\n from starkware.starknet.testing.starknet import Starknet\n+from signers import MockSigner\n from utils import (\n-    MockSigner, str_to_felt, TRUE, FALSE, get_contract_class, cached_contract, \n+    str_to_felt, TRUE, FALSE, get_contract_class, cached_contract, \n     assert_revert, to_uint\n )\n "
        },
        {
          "filename": "tests/token/erc721/test_ERC721_SafeMintable_mock.py",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,7 +1,8 @@\n import pytest\n from starkware.starknet.testing.starknet import Starknet\n+from signers import MockSigner\n from utils import (\n-    MockSigner, str_to_felt, ZERO_ADDRESS, INVALID_UINT256, assert_revert,\n+    str_to_felt, ZERO_ADDRESS, INVALID_UINT256, assert_revert,\n     assert_event_emitted, get_contract_class, cached_contract, to_uint\n )\n "
        },
        {
          "filename": "tests/token/erc721_enumerable/test_ERC721_Enumerable_Mintable_Burnable.py",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,7 +1,8 @@\n import pytest\n from starkware.starknet.testing.starknet import Starknet\n+from signers import MockSigner\n from utils import (\n-    MockSigner, str_to_felt, MAX_UINT256, get_contract_class, cached_contract,\n+    str_to_felt, MAX_UINT256, get_contract_class, cached_contract,\n     TRUE, assert_revert, to_uint, sub_uint, add_uint\n )\n "
        },
        {
          "filename": "tests/upgrades/test_Proxy.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,7 +1,7 @@\n import pytest\n from starkware.starknet.testing.starknet import Starknet\n+from signers import MockSigner\n from utils import (\n-    MockSigner,\n     assert_revert,\n     get_contract_class,\n     cached_contract,"
        },
        {
          "filename": "tests/upgrades/test_upgrades.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,7 +1,7 @@\n import pytest\n from starkware.starknet.testing.starknet import Starknet\n+from signers import MockSigner\n from utils import (\n-    MockSigner,\n     assert_revert,\n     assert_revert_entry_point,\n     assert_event_emitted,"
        },
        {
          "filename": "tests/utils.py",
          "status": "modified",
          "additions": 0,
          "deletions": 54,
          "patch": "@@ -7,7 +7,6 @@\n from starkware.starkware_utils.error_handling import StarkException\n from starkware.starknet.testing.starknet import StarknetContract\n from starkware.starknet.business_logic.execution.objects import Event\n-from nile.signer import Signer\n \n \n MAX_UINT256 = (2**128 - 1, 2**128 - 1)\n@@ -130,56 +129,3 @@ def cached_contract(state, _class, deployed):\n         deploy_execution_info=deployed.deploy_execution_info\n     )\n     return contract\n-\n-\n-class MockSigner():\n-    \"\"\"\n-    Utility for sending signed transactions to an Account on Starknet.\n-\n-    Parameters\n-    ----------\n-\n-    private_key : int\n-\n-    Examples\n-    ---------\n-    Constructing a MockSigner object\n-\n-    >>> signer = MockSigner(1234)\n-\n-    Sending a transaction\n-\n-    >>> await signer.send_transaction(\n-            account, contract_address, 'contract_method', [arg_1]\n-        )\n-\n-    Sending multiple transactions\n-\n-    >>> await signer.send_transaction(\n-            account, [\n-                (contract_address, 'contract_method', [arg_1]),\n-                (contract_address, 'another_method', [arg_1, arg_2])\n-            ]\n-        )\n-                           \n-    \"\"\"\n-    def __init__(self, private_key):\n-        self.signer = Signer(private_key)\n-        self.public_key = self.signer.public_key\n-        \n-    async def send_transaction(self, account, to, selector_name, calldata, nonce=None, max_fee=0):\n-        return await self.send_transactions(account, [(to, selector_name, calldata)], nonce, max_fee)\n-\n-    async def send_transactions(self, account, calls, nonce=None, max_fee=0):\n-        if nonce is None:\n-            execution_info = await account.get_nonce().call()\n-            nonce, = execution_info.result\n-\n-        build_calls = []\n-        for call in calls:\n-            build_call = list(call)\n-            build_call[0] = hex(build_call[0])\n-            build_calls.append(build_call)\n-\n-        (call_array, calldata, sig_r, sig_s) = self.signer.sign_transaction(hex(account.contract_address), build_calls, nonce, max_fee)\n-        return await account.__execute__(call_array, calldata, nonce).invoke(signature=[sig_r, sig_s])"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 18,
        "unique_directories": 10,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "906df739160c6886e40fb0bc77b7fa25079d0a06",
            "date": "2025-01-13T15:38:35Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "dcb8bacff388d9f0b497a50d0b653fc4b66416a9",
            "date": "2025-01-10T13:27:22Z",
            "author_login": "Dahka2321"
          },
          {
            "sha": "ca212cef40ecdd5af0b220ce0b0facb3037472e1",
            "date": "2025-01-09T18:17:47Z",
            "author_login": "immrsd"
          },
          {
            "sha": "39950b704feb356389c979c11d987d957409d0dc",
            "date": "2025-01-06T19:43:20Z",
            "author_login": "andrew-fleming"
          },
          {
            "sha": "742d3afaa88aca4c86925582067b09e51b482730",
            "date": "2025-01-03T20:39:44Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-664",
    "description": "OpenZeppelin Contracts for Cairo is a library for contract development written in Cairo for StarkNet, a decentralized ZK Rollup. Version 0.2.0 is vulnerable to an error that renders account contracts unusable on live networks. This issue affects all accounts (vanilla and ethereum flavors) in the v0.2.0 release of OpenZeppelin Contracts for Cairo, which are not whitelisted on StarkNet mainnet. Only goerli deployments of v0.2.0 accounts are affected. This faulty behavior is not observed in StarkNet's testing framework. This bug has been patched in v0.2.1.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-07-15T18:15:08.760",
    "last_modified": "2024-11-21T07:04:00.707",
    "fix_date": "2022-06-29T21:08:33Z"
  },
  "references": [
    {
      "url": "https://github.com/OpenZeppelin/cairo-contracts/blob/release-0.2.0/src/openzeppelin/account/library.cairo#L203",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/cairo-contracts/commit/2cd60279c3332285d47edf9ee3888b71257acdc9",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/cairo-contracts/issues/386",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/cairo-contracts/pull/387",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/cairo-contracts/releases/tag/v0.2.1",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/cairo-contracts/security/advisories/GHSA-8mjr-jr5h-q2xr",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/cairo-contracts/blob/release-0.2.0/src/openzeppelin/account/library.cairo#L203",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/cairo-contracts/commit/2cd60279c3332285d47edf9ee3888b71257acdc9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/cairo-contracts/issues/386",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/cairo-contracts/pull/387",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/cairo-contracts/releases/tag/v0.2.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/cairo-contracts/security/advisories/GHSA-8mjr-jr5h-q2xr",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:11.494203",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "cairo-contracts",
    "owner": "OpenZeppelin",
    "created_at": "2021-08-18T23:00:24Z",
    "updated_at": "2025-01-13T16:58:31Z",
    "pushed_at": "2025-01-13T15:38:40Z",
    "size": 3614,
    "stars": 841,
    "forks": 358,
    "open_issues": 73,
    "watchers": 841,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Rust": 1358456,
      "Python": 2223
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T15:26:49.806548"
  }
}