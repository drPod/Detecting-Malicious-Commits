{
  "cve_id": "CVE-2022-31173",
  "github_data": {
    "repository": "graphql-rust/juniper",
    "fix_commit": "2b609ee057be950e3454b69fadc431d120e407bb",
    "related_commits": [
      "2b609ee057be950e3454b69fadc431d120e407bb",
      "8d28cdba6eb10f53490ba41d1b5cb40506c2de22",
      "2b609ee057be950e3454b69fadc431d120e407bb",
      "8d28cdba6eb10f53490ba41d1b5cb40506c2de22"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "2b609ee057be950e3454b69fadc431d120e407bb",
      "commit_date": "2022-07-28T11:33:16Z",
      "author": {
        "login": "ilslv",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-4rx6-g5vg-5f3j",
        "length": 252,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 393,
        "additions": 292,
        "deletions": 101
      },
      "files": [
        {
          "filename": "juniper/src/validation/rules/no_fragment_cycles.rs",
          "status": "modified",
          "additions": 43,
          "deletions": 25,
          "patch": "@@ -7,19 +7,6 @@ use crate::{\n     value::ScalarValue,\n };\n \n-pub struct NoFragmentCycles<'a> {\n-    current_fragment: Option<&'a str>,\n-    spreads: HashMap<&'a str, Vec<Spanning<&'a str>>>,\n-    fragment_order: Vec<&'a str>,\n-}\n-\n-struct CycleDetector<'a> {\n-    visited: HashSet<&'a str>,\n-    spreads: &'a HashMap<&'a str, Vec<Spanning<&'a str>>>,\n-    path_indices: HashMap<&'a str, usize>,\n-    errors: Vec<RuleError>,\n-}\n-\n pub fn factory<'a>() -> NoFragmentCycles<'a> {\n     NoFragmentCycles {\n         current_fragment: None,\n@@ -28,6 +15,12 @@ pub fn factory<'a>() -> NoFragmentCycles<'a> {\n     }\n }\n \n+pub struct NoFragmentCycles<'a> {\n+    current_fragment: Option<&'a str>,\n+    spreads: HashMap<&'a str, Vec<Spanning<&'a str>>>,\n+    fragment_order: Vec<&'a str>,\n+}\n+\n impl<'a, S> Visitor<'a, S> for NoFragmentCycles<'a>\n where\n     S: ScalarValue,\n@@ -38,14 +31,12 @@ where\n         let mut detector = CycleDetector {\n             visited: HashSet::new(),\n             spreads: &self.spreads,\n-            path_indices: HashMap::new(),\n             errors: Vec::new(),\n         };\n \n         for frag in &self.fragment_order {\n             if !detector.visited.contains(frag) {\n-                let mut path = Vec::new();\n-                detector.detect_from(frag, &mut path);\n+                detector.detect_from(frag);\n             }\n         }\n \n@@ -91,19 +82,46 @@ where\n     }\n }\n \n+type CycleDetectorState<'a> = (&'a str, Vec<&'a Spanning<&'a str>>, HashMap<&'a str, usize>);\n+\n+struct CycleDetector<'a> {\n+    visited: HashSet<&'a str>,\n+    spreads: &'a HashMap<&'a str, Vec<Spanning<&'a str>>>,\n+    errors: Vec<RuleError>,\n+}\n+\n impl<'a> CycleDetector<'a> {\n-    fn detect_from(&mut self, from: &'a str, path: &mut Vec<&'a Spanning<&'a str>>) {\n+    fn detect_from(&mut self, from: &'a str) {\n+        let mut to_visit = Vec::new();\n+        to_visit.push((from, Vec::new(), HashMap::new()));\n+\n+        while let Some((from, path, path_indices)) = to_visit.pop() {\n+            to_visit.extend(self.detect_from_inner(from, path, path_indices));\n+        }\n+    }\n+\n+    /// This function should be called only inside [`Self::detect_from()`], as\n+    /// it's a recursive function using heap instead of a stack. So, instead of\n+    /// the recursive call, we return a [`Vec`] that is visited inside\n+    /// [`Self::detect_from()`].\n+    fn detect_from_inner(\n+        &mut self,\n+        from: &'a str,\n+        path: Vec<&'a Spanning<&'a str>>,\n+        mut path_indices: HashMap<&'a str, usize>,\n+    ) -> Vec<CycleDetectorState<'a>> {\n         self.visited.insert(from);\n \n         if !self.spreads.contains_key(from) {\n-            return;\n+            return Vec::new();\n         }\n \n-        self.path_indices.insert(from, path.len());\n+        path_indices.insert(from, path.len());\n \n+        let mut to_visit = Vec::new();\n         for node in &self.spreads[from] {\n-            let name = &node.item;\n-            let index = self.path_indices.get(name).cloned();\n+            let name = node.item;\n+            let index = path_indices.get(name).cloned();\n \n             if let Some(index) = index {\n                 let err_pos = if index < path.len() {\n@@ -114,14 +132,14 @@ impl<'a> CycleDetector<'a> {\n \n                 self.errors\n                     .push(RuleError::new(&error_message(name), &[err_pos.start]));\n-            } else if !self.visited.contains(name) {\n+            } else {\n+                let mut path = path.clone();\n                 path.push(node);\n-                self.detect_from(name, path);\n-                path.pop();\n+                to_visit.push((name, path, path_indices.clone()));\n             }\n         }\n \n-        self.path_indices.remove(from);\n+        to_visit\n     }\n }\n "
        },
        {
          "filename": "juniper/src/validation/rules/no_undefined_variables.rs",
          "status": "modified",
          "additions": 35,
          "deletions": 13,
          "patch": "@@ -12,13 +12,6 @@ pub enum Scope<'a> {\n     Fragment(&'a str),\n }\n \n-pub struct NoUndefinedVariables<'a> {\n-    defined_variables: HashMap<Option<&'a str>, (SourcePosition, HashSet<&'a str>)>,\n-    used_variables: HashMap<Scope<'a>, Vec<Spanning<&'a str>>>,\n-    current_scope: Option<Scope<'a>>,\n-    spreads: HashMap<Scope<'a>, Vec<&'a str>>,\n-}\n-\n pub fn factory<'a>() -> NoUndefinedVariables<'a> {\n     NoUndefinedVariables {\n         defined_variables: HashMap::new(),\n@@ -28,6 +21,13 @@ pub fn factory<'a>() -> NoUndefinedVariables<'a> {\n     }\n }\n \n+pub struct NoUndefinedVariables<'a> {\n+    defined_variables: HashMap<Option<&'a str>, (SourcePosition, HashSet<&'a str>)>,\n+    used_variables: HashMap<Scope<'a>, Vec<Spanning<&'a str>>>,\n+    current_scope: Option<Scope<'a>>,\n+    spreads: HashMap<Scope<'a>, Vec<&'a str>>,\n+}\n+\n impl<'a> NoUndefinedVariables<'a> {\n     fn find_undef_vars(\n         &'a self,\n@@ -36,8 +36,34 @@ impl<'a> NoUndefinedVariables<'a> {\n         unused: &mut Vec<&'a Spanning<&'a str>>,\n         visited: &mut HashSet<Scope<'a>>,\n     ) {\n+        let mut to_visit = Vec::new();\n+        if let Some(spreads) = self.find_undef_vars_inner(scope, defined, unused, visited) {\n+            to_visit.push(spreads);\n+        }\n+        while let Some(spreads) = to_visit.pop() {\n+            for spread in spreads {\n+                if let Some(spreads) =\n+                    self.find_undef_vars_inner(&Scope::Fragment(spread), defined, unused, visited)\n+                {\n+                    to_visit.push(spreads);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// This function should be called only inside [`Self::find_undef_vars()`],\n+    /// as it's a recursive function using heap instead of a stack. So, instead\n+    /// of the recursive call, we return a [`Vec`] that is visited inside\n+    /// [`Self::find_undef_vars()`].\n+    fn find_undef_vars_inner(\n+        &'a self,\n+        scope: &Scope<'a>,\n+        defined: &HashSet<&'a str>,\n+        unused: &mut Vec<&'a Spanning<&'a str>>,\n+        visited: &mut HashSet<Scope<'a>>,\n+    ) -> Option<&'a Vec<&'a str>> {\n         if visited.contains(scope) {\n-            return;\n+            return None;\n         }\n \n         visited.insert(scope.clone());\n@@ -50,11 +76,7 @@ impl<'a> NoUndefinedVariables<'a> {\n             }\n         }\n \n-        if let Some(spreads) = self.spreads.get(scope) {\n-            for spread in spreads {\n-                self.find_undef_vars(&Scope::Fragment(spread), defined, unused, visited);\n-            }\n-        }\n+        self.spreads.get(scope)\n     }\n }\n "
        },
        {
          "filename": "juniper/src/validation/rules/no_unused_fragments.rs",
          "status": "modified",
          "additions": 30,
          "deletions": 15,
          "patch": "@@ -13,12 +13,6 @@ pub enum Scope<'a> {\n     Fragment(&'a str),\n }\n \n-pub struct NoUnusedFragments<'a> {\n-    spreads: HashMap<Scope<'a>, Vec<&'a str>>,\n-    defined_fragments: HashSet<Spanning<&'a str>>,\n-    current_scope: Option<Scope<'a>>,\n-}\n-\n pub fn factory<'a>() -> NoUnusedFragments<'a> {\n     NoUnusedFragments {\n         spreads: HashMap::new(),\n@@ -27,22 +21,43 @@ pub fn factory<'a>() -> NoUnusedFragments<'a> {\n     }\n }\n \n+pub struct NoUnusedFragments<'a> {\n+    spreads: HashMap<Scope<'a>, Vec<&'a str>>,\n+    defined_fragments: HashSet<Spanning<&'a str>>,\n+    current_scope: Option<Scope<'a>>,\n+}\n+\n impl<'a> NoUnusedFragments<'a> {\n-    fn find_reachable_fragments(&self, from: &Scope<'a>, result: &mut HashSet<&'a str>) {\n+    fn find_reachable_fragments(&'a self, from: &Scope<'a>, result: &mut HashSet<&'a str>) {\n+        let mut to_visit = Vec::new();\n         if let Scope::Fragment(name) = *from {\n-            if result.contains(name) {\n-                return;\n-            } else {\n-                result.insert(name);\n-            }\n+            to_visit.push(name);\n         }\n \n-        if let Some(spreads) = self.spreads.get(from) {\n-            for spread in spreads {\n-                self.find_reachable_fragments(&Scope::Fragment(spread), result)\n+        while let Some(from) = to_visit.pop() {\n+            if let Some(next) = self.find_reachable_fragments_inner(from, result) {\n+                to_visit.extend(next);\n             }\n         }\n     }\n+\n+    /// This function should be called only inside\n+    /// [`Self::find_reachable_fragments()`], as it's a recursive function using\n+    /// heap instead of a stack. So, instead of the recursive call, we return a\n+    /// [`Vec`] that is visited inside [`Self::find_reachable_fragments()`].\n+    fn find_reachable_fragments_inner(\n+        &'a self,\n+        from: &'a str,\n+        result: &mut HashSet<&'a str>,\n+    ) -> Option<&'a Vec<&'a str>> {\n+        if result.contains(from) {\n+            return None;\n+        } else {\n+            result.insert(from);\n+        }\n+\n+        self.spreads.get(&Scope::Fragment(from))\n+    }\n }\n \n impl<'a, S> Visitor<'a, S> for NoUnusedFragments<'a>"
        },
        {
          "filename": "juniper/src/validation/rules/no_unused_variables.rs",
          "status": "modified",
          "additions": 36,
          "deletions": 14,
          "patch": "@@ -12,13 +12,6 @@ pub enum Scope<'a> {\n     Fragment(&'a str),\n }\n \n-pub struct NoUnusedVariables<'a> {\n-    defined_variables: HashMap<Option<&'a str>, HashSet<&'a Spanning<&'a str>>>,\n-    used_variables: HashMap<Scope<'a>, Vec<&'a str>>,\n-    current_scope: Option<Scope<'a>>,\n-    spreads: HashMap<Scope<'a>, Vec<&'a str>>,\n-}\n-\n pub fn factory<'a>() -> NoUnusedVariables<'a> {\n     NoUnusedVariables {\n         defined_variables: HashMap::new(),\n@@ -28,16 +21,49 @@ pub fn factory<'a>() -> NoUnusedVariables<'a> {\n     }\n }\n \n+pub struct NoUnusedVariables<'a> {\n+    defined_variables: HashMap<Option<&'a str>, HashSet<&'a Spanning<&'a str>>>,\n+    used_variables: HashMap<Scope<'a>, Vec<&'a str>>,\n+    current_scope: Option<Scope<'a>>,\n+    spreads: HashMap<Scope<'a>, Vec<&'a str>>,\n+}\n+\n impl<'a> NoUnusedVariables<'a> {\n     fn find_used_vars(\n-        &self,\n+        &'a self,\n         from: &Scope<'a>,\n         defined: &HashSet<&'a str>,\n         used: &mut HashSet<&'a str>,\n         visited: &mut HashSet<Scope<'a>>,\n     ) {\n+        let mut to_visit = Vec::new();\n+        if let Some(spreads) = self.find_used_vars_inner(from, defined, used, visited) {\n+            to_visit.push(spreads);\n+        }\n+        while let Some(spreads) = to_visit.pop() {\n+            for spread in spreads {\n+                if let Some(spreads) =\n+                    self.find_used_vars_inner(&Scope::Fragment(spread), defined, used, visited)\n+                {\n+                    to_visit.push(spreads);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// This function should be called only inside [`Self::find_used_vars()`],\n+    /// as it's a recursive function using heap instead of a stack. So, instead\n+    /// of the recursive call, we return a [`Vec`] that is visited inside\n+    /// [`Self::find_used_vars()`].\n+    fn find_used_vars_inner(\n+        &'a self,\n+        from: &Scope<'a>,\n+        defined: &HashSet<&'a str>,\n+        used: &mut HashSet<&'a str>,\n+        visited: &mut HashSet<Scope<'a>>,\n+    ) -> Option<&'a Vec<&'a str>> {\n         if visited.contains(from) {\n-            return;\n+            return None;\n         }\n \n         visited.insert(from.clone());\n@@ -50,11 +76,7 @@ impl<'a> NoUnusedVariables<'a> {\n             }\n         }\n \n-        if let Some(spreads) = self.spreads.get(from) {\n-            for spread in spreads {\n-                self.find_used_vars(&Scope::Fragment(spread), defined, used, visited);\n-            }\n-        }\n+        self.spreads.get(from)\n     }\n }\n "
        },
        {
          "filename": "juniper/src/validation/rules/overlapping_fields_can_be_merged.rs",
          "status": "modified",
          "additions": 49,
          "deletions": 18,
          "patch": "@@ -274,30 +274,61 @@ impl<'a, S: Debug> OverlappingFieldsCanBeMerged<'a, S> {\n     ) where\n         S: ScalarValue,\n     {\n-        let fragment = match self.named_fragments.get(fragment_name) {\n-            Some(f) => f,\n-            None => return,\n-        };\n+        let mut to_check = Vec::new();\n+        if let Some(fragments) = self.collect_conflicts_between_fields_and_fragment_inner(\n+            conflicts,\n+            field_map,\n+            fragment_name,\n+            mutually_exclusive,\n+            ctx,\n+        ) {\n+            to_check.push((fragment_name, fragments))\n+        }\n+\n+        while let Some((fragment_name, fragment_names2)) = to_check.pop() {\n+            for fragment_name2 in fragment_names2 {\n+                // Early return on fragment recursion, as it makes no sense.\n+                // Fragment recursions are prevented by `no_fragment_cycles` validator.\n+                if fragment_name == fragment_name2 {\n+                    return;\n+                }\n+                if let Some(fragments) = self.collect_conflicts_between_fields_and_fragment_inner(\n+                    conflicts,\n+                    field_map,\n+                    fragment_name2,\n+                    mutually_exclusive,\n+                    ctx,\n+                ) {\n+                    to_check.push((fragment_name2, fragments));\n+                };\n+            }\n+        }\n+    }\n+\n+    /// This function should be called only inside\n+    /// [`Self::collect_conflicts_between_fields_and_fragment()`], as it's a\n+    /// recursive function using heap instead of a stack. So, instead of the\n+    /// recursive call, we return a [`Vec`] that is visited inside\n+    /// [`Self::collect_conflicts_between_fields_and_fragment()`].\n+    fn collect_conflicts_between_fields_and_fragment_inner(\n+        &self,\n+        conflicts: &mut Vec<Conflict>,\n+        field_map: &AstAndDefCollection<'a, S>,\n+        fragment_name: &str,\n+        mutually_exclusive: bool,\n+        ctx: &ValidatorContext<'a, S>,\n+    ) -> Option<Vec<&'a str>>\n+    where\n+        S: ScalarValue,\n+    {\n+        let fragment = self.named_fragments.get(fragment_name)?;\n \n         let (field_map2, fragment_names2) =\n             self.get_referenced_fields_and_fragment_names(fragment, ctx);\n \n         self.collect_conflicts_between(conflicts, mutually_exclusive, field_map, &field_map2, ctx);\n \n-        for fragment_name2 in fragment_names2 {\n-            // Early return on fragment recursion, as it makes no sense.\n-            // Fragment recursions are prevented by `no_fragment_cycles` validator.\n-            if fragment_name == fragment_name2 {\n-                return;\n-            }\n-            self.collect_conflicts_between_fields_and_fragment(\n-                conflicts,\n-                field_map,\n-                fragment_name2,\n-                mutually_exclusive,\n-                ctx,\n-            );\n-        }\n+        Some(fragment_names2)\n     }\n \n     fn collect_conflicts_between("
        },
        {
          "filename": "juniper/src/validation/rules/variables_in_allowed_position.rs",
          "status": "modified",
          "additions": 42,
          "deletions": 16,
          "patch": "@@ -17,14 +17,6 @@ pub enum Scope<'a> {\n     Fragment(&'a str),\n }\n \n-pub struct VariableInAllowedPosition<'a, S: fmt::Debug + 'a> {\n-    spreads: HashMap<Scope<'a>, HashSet<&'a str>>,\n-    variable_usages: HashMap<Scope<'a>, Vec<(Spanning<&'a String>, Type<'a>)>>,\n-    #[allow(clippy::type_complexity)]\n-    variable_defs: HashMap<Scope<'a>, Vec<&'a (Spanning<&'a str>, VariableDefinition<'a, S>)>>,\n-    current_scope: Option<Scope<'a>>,\n-}\n-\n pub fn factory<'a, S: fmt::Debug>() -> VariableInAllowedPosition<'a, S> {\n     VariableInAllowedPosition {\n         spreads: HashMap::new(),\n@@ -34,16 +26,54 @@ pub fn factory<'a, S: fmt::Debug>() -> VariableInAllowedPosition<'a, S> {\n     }\n }\n \n+pub struct VariableInAllowedPosition<'a, S: fmt::Debug + 'a> {\n+    spreads: HashMap<Scope<'a>, HashSet<&'a str>>,\n+    variable_usages: HashMap<Scope<'a>, Vec<(Spanning<&'a String>, Type<'a>)>>,\n+    #[allow(clippy::type_complexity)]\n+    variable_defs: HashMap<Scope<'a>, Vec<&'a (Spanning<&'a str>, VariableDefinition<'a, S>)>>,\n+    current_scope: Option<Scope<'a>>,\n+}\n+\n impl<'a, S: fmt::Debug> VariableInAllowedPosition<'a, S> {\n-    fn collect_incorrect_usages(\n-        &self,\n+    fn collect_incorrect_usages<'me>(\n+        &'me self,\n         from: &Scope<'a>,\n         var_defs: &[&'a (Spanning<&'a str>, VariableDefinition<S>)],\n         ctx: &mut ValidatorContext<'a, S>,\n         visited: &mut HashSet<Scope<'a>>,\n     ) {\n+        let mut to_visit = Vec::new();\n+        if let Some(spreads) = self.collect_incorrect_usages_inner(from, var_defs, ctx, visited) {\n+            to_visit.push(spreads);\n+        }\n+\n+        while let Some(spreads) = to_visit.pop() {\n+            for spread in spreads {\n+                if let Some(spreads) = self.collect_incorrect_usages_inner(\n+                    &Scope::Fragment(spread),\n+                    var_defs,\n+                    ctx,\n+                    visited,\n+                ) {\n+                    to_visit.push(spreads);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// This function should be called only inside\n+    /// [`Self::collect_incorrect_usages()`], as it's a recursive function using\n+    /// heap instead of a stack. So, instead of the recursive call, we return a\n+    /// [`Vec`] that is visited inside [`Self::collect_incorrect_usages()`].\n+    fn collect_incorrect_usages_inner<'me>(\n+        &'me self,\n+        from: &Scope<'a>,\n+        var_defs: &[&'a (Spanning<&'a str>, VariableDefinition<S>)],\n+        ctx: &mut ValidatorContext<'a, S>,\n+        visited: &mut HashSet<Scope<'a>>,\n+    ) -> Option<&'me HashSet<&'a str>> {\n         if visited.contains(from) {\n-            return;\n+            return None;\n         }\n \n         visited.insert(from.clone());\n@@ -74,11 +104,7 @@ impl<'a, S: fmt::Debug> VariableInAllowedPosition<'a, S> {\n             }\n         }\n \n-        if let Some(spreads) = self.spreads.get(from) {\n-            for spread in spreads {\n-                self.collect_incorrect_usages(&Scope::Fragment(spread), var_defs, ctx, visited);\n-            }\n-        }\n+        self.spreads.get(from)\n     }\n }\n "
        },
        {
          "filename": "tests/integration/Cargo.toml",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -10,6 +10,7 @@ chrono = \"0.4\"\n derive_more = \"0.99\"\n fnv = \"1.0\"\n futures = \"0.3\"\n+itertools = \"0.10\"\n juniper = { path = \"../../juniper\" }\n juniper_subscriptions = { path = \"../../juniper_subscriptions\" }\n serde = { version = \"1.0\", features = [\"derive\"] }"
        },
        {
          "filename": "tests/integration/tests/cve_2022_31173.rs",
          "status": "added",
          "additions": 56,
          "deletions": 0,
          "patch": "@@ -0,0 +1,56 @@\n+//! Checks that long looping chain of fragments doesn't cause a stack overflow.\n+//!\n+//! ```graphql\n+//! # Fragment loop example\n+//! query {\n+//!     ...a\n+//! }\n+//!\n+//! fragment a on Query {\n+//!     ...b\n+//! }\n+//!\n+//! fragment b on Query {\n+//!     ...a\n+//! }\n+//! ```\n+\n+use std::iter;\n+\n+use itertools::Itertools as _;\n+use juniper::{graphql_object, graphql_vars, EmptyMutation, EmptySubscription};\n+\n+struct Query;\n+\n+#[graphql_object]\n+impl Query {\n+    fn dummy() -> bool {\n+        false\n+    }\n+}\n+\n+type Schema = juniper::RootNode<'static, Query, EmptyMutation, EmptySubscription>;\n+\n+#[tokio::test]\n+async fn test() {\n+    const PERM: &str = \"abcefghijk\";\n+    const CIRCLE_SIZE: usize = 7500;\n+\n+    let query = iter::once(format!(\"query {{ ...{PERM} }} \"))\n+        .chain(\n+            PERM.chars()\n+                .permutations(PERM.len())\n+                .map(|vec| vec.into_iter().collect::<String>())\n+                .take(CIRCLE_SIZE)\n+                .collect::<Vec<_>>()\n+                .into_iter()\n+                .circular_tuple_windows::<(_, _)>()\n+                .map(|(cur, next)| format!(\"fragment {cur} on Query {{ ...{next} }} \")),\n+        )\n+        .collect::<String>();\n+\n+    let schema = Schema::new(Query, EmptyMutation::new(), EmptySubscription::new());\n+    let _ = juniper::execute(&query, None, &schema, &graphql_vars! {}, &())\n+        .await\n+        .unwrap_err();\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 1,
        "test_files": 2,
        "unique_directories": 3,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "f049481f1623838afdd3203a0c01bf017c0f1c41",
            "date": "2025-01-13T17:49:04Z",
            "author_login": "tyranron"
          },
          {
            "sha": "f7b85fd9c256efc75aedded86c7ff64381b40064",
            "date": "2025-01-13T17:46:55Z",
            "author_login": "tyranron"
          },
          {
            "sha": "03e0beeda89cbc7a738611fec603f732717b8ee8",
            "date": "2025-01-13T17:27:35Z",
            "author_login": "tyranron"
          },
          {
            "sha": "3d609abfb7743572c33d3a3806e3e93ab705f23f",
            "date": "2024-09-23T21:03:52Z",
            "author_login": "SandroHc"
          },
          {
            "sha": "d193cdc55cd7d86db827b54255e163944139f12c",
            "date": "2025-01-13T17:27:35Z",
            "author_login": "tyranron"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "Juniper is a GraphQL server library for Rust. Affected versions of Juniper are vulnerable to uncontrolled recursion resulting in a program crash. This issue has been addressed in version 0.15.10. Users are advised to upgrade. Users unable to upgrade should limit the recursion depth manually.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-08-01T19:15:08.330",
    "last_modified": "2024-11-21T07:04:03.200",
    "fix_date": "2022-07-28T11:33:16Z"
  },
  "references": [
    {
      "url": "https://github.com/graphql-rust/juniper/blob/juniper-v0.15.10/juniper/CHANGELOG.md#01510-2022-07-28",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/graphql-rust/juniper/commit/2b609ee057be950e3454b69fadc431d120e407bb",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/graphql-rust/juniper/commit/8d28cdba6eb10f53490ba41d1b5cb40506c2de22",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/graphql-rust/juniper/security/advisories/GHSA-4rx6-g5vg-5f3j",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/graphql-rust/juniper/blob/juniper-v0.15.10/juniper/CHANGELOG.md#01510-2022-07-28",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/graphql-rust/juniper/commit/2b609ee057be950e3454b69fadc431d120e407bb",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/graphql-rust/juniper/commit/8d28cdba6eb10f53490ba41d1b5cb40506c2de22",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/graphql-rust/juniper/security/advisories/GHSA-4rx6-g5vg-5f3j",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:14.186253",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "juniper",
    "owner": "graphql-rust",
    "created_at": "2016-09-11T16:43:19Z",
    "updated_at": "2025-01-23T17:00:34Z",
    "pushed_at": "2025-01-13T17:53:31Z",
    "size": 14026,
    "stars": 5749,
    "forks": 429,
    "open_issues": 105,
    "watchers": 5749,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Rust": 2769412,
      "HTML": 21494,
      "Makefile": 6150,
      "JavaScript": 502,
      "CSS": 47
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T08:16:06.577979"
  }
}