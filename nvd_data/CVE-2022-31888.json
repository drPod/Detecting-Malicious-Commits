{
  "cve_id": "CVE-2022-31888",
  "github_data": {
    "repository": "osTicket/osTicket",
    "fix_commit": "85a76f403a3a116176d0798f39a4c430181d8364",
    "related_commits": [
      "85a76f403a3a116176d0798f39a4c430181d8364",
      "85a76f403a3a116176d0798f39a4c430181d8364"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "85a76f403a3a116176d0798f39a4c430181d8364",
      "commit_date": "2022-04-24T20:49:20Z",
      "author": {
        "login": "protich",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Security: Session Fixation",
        "length": 183,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 284,
        "additions": 157,
        "deletions": 127
      },
      "files": [
        {
          "filename": "include/class.auth.php",
          "status": "modified",
          "additions": 9,
          "deletions": 6,
          "patch": "@@ -538,6 +538,8 @@ function login($staff, $bk) {\n             || !($authkey=$bk->getAuthKey($staff)))\n             return false;\n \n+        // Regenerate session id and refresh (avoid session fixation)\n+        $staff->regenerateSession();\n         //Log debug info.\n         $ost->logDebug(_S('Agent Login'),\n             sprintf(_S(\"%s logged in [%s], via %s\"), $staff->getUserName(),\n@@ -563,9 +565,10 @@ function login($staff, $bk) {\n         $authsession['id'] = $staff->getId();\n         $authsession['key'] =  $authkey;\n         $authsession['2fa'] =  $auth2fa;\n-\n+        // Set session token\n+        $staff->setSessionToken();\n+        // Set Auth Key\n         $staff->setAuthKey($authkey);\n-        $staff->refreshSession(true); //set the hash.\n         Signal::send('auth.login.succeeded', $staff);\n \n         if ($bk->supportsInteractiveAuthentication())\n@@ -755,15 +758,15 @@ function login($user, $bk) {\n                 throw new AccessDenied(__('Account is administratively locked'));\n         }\n \n+        // Regenerate session id and refresh (avoid session fixation)\n+        $user->regenerateSession();\n         // Tag the user and associated ticket in the SESSION\n         $this->setAuthKey($user, $bk, $authkey);\n-\n+        // Set Session Token\n+        $user->setSessionToken();\n         //The backend used decides the format of the auth key.\n         // XXX: encrypt to hide the bk??\n         $user->setAuthKey($authkey);\n-\n-        $user->refreshSession(true); //set the hash.\n-\n         //Log login info...\n         $msg=sprintf(_S('%1$s (%2$s) logged in [%3$s]'\n                 /* Tokens are <username>, <id>, and <ip> */),"
        },
        {
          "filename": "include/class.usersession.php",
          "status": "modified",
          "additions": 145,
          "deletions": 118,
          "patch": "@@ -17,137 +17,163 @@ class.usersession.php\n include_once(INCLUDE_DIR.'class.client.php');\n include_once(INCLUDE_DIR.'class.staff.php');\n \n-\n class UserSession {\n    var $session_id = '';\n-   var $userID='';\n+   var $userID = 0;\n    var $browser = '';\n    var $ip = '';\n-   var $validated=FALSE;\n-\n-   function __construct($userid){\n+   var $validated = false;\n \n-      $this->browser=(!empty($_SERVER['HTTP_USER_AGENT'])) ? $_SERVER['HTTP_USER_AGENT'] : $_ENV['HTTP_USER_AGENT'];\n-      $this->ip=(!empty($_SERVER['REMOTE_ADDR'])) ? $_SERVER['REMOTE_ADDR'] : getenv('REMOTE_ADDR');\n-      $this->session_id=session_id();\n-      $this->userID=$userid;\n+   function __construct($userid) {\n+      $this->browser = (!empty($_SERVER['HTTP_USER_AGENT'])) ? $_SERVER['HTTP_USER_AGENT'] : $_ENV['HTTP_USER_AGENT'];\n+      $this->ip = (!empty($_SERVER['REMOTE_ADDR'])) ? $_SERVER['REMOTE_ADDR'] : getenv('REMOTE_ADDR');\n+      $this->session_id = session_id();\n+      $this->userID = $userid;\n    }\n \n-   function isStaff(){\n-       return FALSE;\n+   function isStaff() {\n+       return false;\n    }\n \n    function isClient() {\n-       return FALSE;\n+       return false;\n    }\n \n-\n-   function getSessionId(){\n+   function getSessionId() {\n        return $this->session_id;\n    }\n \n-   function getIP(){\n+   function getIP() {\n         return  $this->ip;\n    }\n \n-   function getBrowser(){\n+   function getBrowser() {\n        return $this->browser;\n    }\n-   function refreshSession(){\n-       //nothing to do...clients need to worry about it.\n-   }\n \n    function sessionToken(){\n-\n       $time  = time();\n       $hash  = md5($time.SESSION_SECRET.$this->userID);\n       $token = \"$hash:$time:\".MD5($this->ip);\n-\n-      return($token);\n+      return $token;\n    }\n \n    function getLastUpdate($htoken) {\n        if (!$htoken)\n            return 0;\n \n-       @list($hash,$expire,$ip)=explode(\":\",$htoken);\n+       @list($hash, $expire, $ip) = explode(\":\", $htoken);\n        return $expire;\n    }\n \n    function isvalidSession($htoken,$maxidletime=0,$checkip=false){\n-        global $cfg;\n+        global $cfgi;\n \n-        $token = rawurldecode($htoken);\n+        // Compare session ids\n+        if (strcmp($this->getSessionId(), session_id()))\n+            return false;\n \n-        #check if we got what we expected....\n-        if($token && !strstr($token,\":\"))\n-            return FALSE;\n+        // Is the session invalidated?\n+        if (isset($_SESSION['KAPUT']) &&  $_SESSION['KAPUT'] < time())\n+            return (session_destroy() && false);\n \n-        #get the goodies\n-        list($hash,$expire,$ip)=explode(\":\",$token);\n+        $token = rawurldecode($htoken);\n+        // Check if we got what we expected....\n+        if ($token && !strstr($token,\":\"))\n+            return false;\n \n-        #Make sure the session hash is valid\n-        if((md5($expire . SESSION_SECRET . $this->userID)!=$hash)){\n-            return FALSE;\n-        }\n-        #is it expired??\n+        // Get the goodies\n+        list($hash, $expire, $ip) = explode(\":\",$token);\n \n+        // Make sure the session hash is valid\n+        if ((md5($expire . SESSION_SECRET . $this->userID) != $hash))\n+            return false;\n+\n+        // is it expired??\n+        if ($maxidletime && ((time()-$expire)>$maxidletime))\n+            return false;\n \n-        if($maxidletime && ((time()-$expire)>$maxidletime)){\n-            return FALSE;\n-        }\n         #Make sure IP is still same ( proxy access??????)\n-        if($checkip && strcmp($ip, MD5($this->ip)))\n-            return FALSE;\n+        if ($checkip && strcmp($ip, MD5($this->ip)))\n+            return false;\n+\n+        $this->validated = true;\n \n-        $this->validated=TRUE;\n+        return true;\n+   }\n+\n+   function regenerateSession($destroy=false) {\n+       // Delayed kaput time for current session\n+       $_SESSION['KAPUT'] = time() + 60;\n+       // Save the session id as old\n+       $old = session_id();\n+       // Regenerate the session without destroying data\n+       session_regenerate_id(false);\n+       // Get new session id and close\n+       $new = session_id();\n+       session_write_close();\n+       // Start new session\n+       session_id($new);\n+       session_start();\n+       $this->session_id  = $new;\n+       // Make sure new session is not set to KAPUT\n+       unset($_SESSION['KAPUT']);\n+       // Destroy ?\n+       if ($destroy) {\n+           // Destrory old session\n+           $this->destroySession($old);\n+           // Restore new session\n+           session_id($new);\n+           session_start();\n+       }\n+       return true;\n+   }\n \n-        return TRUE;\n+   function destroySession($id) {\n+       // Close current session\n+       session_write_close();\n+       // Start target session\n+       session_id($id);\n+       session_start();\n+       // Destroy session\n+       session_destroy();\n+       session_write_close();\n+       return true;\n    }\n \n    function isValid() {\n-        return FALSE;\n+        return  ($this->validated);\n    }\n \n }\n \n-class ClientSession extends EndUser {\n \n+trait UserSessionTrait {\n+    // Session Object\n     var $session;\n+    // Session Token\n     var $token;\n-\n-    function __construct($user) {\n-        parent::__construct($user);\n-        $this->token = &$_SESSION[':token']['client'];\n-        // XXX: Change the key to user-id\n-        $this->session= new UserSession($user->getId());\n-    }\n-\n-    function getSessionUser() {\n-        return $this->user;\n-    }\n-\n-    function isValid(){\n-        global $_SESSION,$cfg;\n-\n-        if(!$this->getId() || $this->session->getSessionId()!=session_id())\n-            return false;\n-\n-        return $this->session->isvalidSession($this->token,$cfg->getClientTimeout(),false)?true:false;\n-    }\n-\n-    function refreshSession($force=false){\n-        global $cfg;\n-\n+    // Maximum idle time before session is considered invalid\n+    var $maxidletime = 0;\n+    // Indicates if session is bound to the IP address\n+    var $checkip = false;\n+    // User class\n+    var $class = '';\n+\n+    function refreshSession($force=false) {\n         $time = $this->session->getLastUpdate($this->token);\n         // Deadband session token updates to once / 30-seconds\n         if (!$force && time() - $time < 30)\n             return;\n \n         $this->token = $this->getSessionToken();\n-        //TODO: separate expire time from hash??\n+        osTicketSession::renewCookie($time, $this->maxidletime);\n+    }\n \n-        osTicketSession::renewCookie($time, $cfg->getClientSessionTimeout());\n+    function regenerateSession($destroy=false) {\n+        $this->session->regenerateSession($destroy);\n+        // Set cookie for the new session id.\n+        $this->refreshSession(true);\n     }\n \n     function getSession() {\n@@ -158,75 +184,76 @@ function getSessionToken() {\n         return $this->session->sessionToken();\n     }\n \n-    function getIP(){\n+    function setSessionToken($token=null) {\n+        // Assign memory to token variable\n+        $this->token = &$_SESSION[':token'][$this->class];\n+        // Set token\n+        $this->token = $token ?: $this->getSessionToken();\n+    }\n+\n+    function getIP() {\n         return $this->session->getIP();\n     }\n+\n+    function isValidSession() {\n+        return ($this->getId()\n+                && $this->session->isvalidSession($this->token,\n+                    $this->maxidletime, $this->checkip));\n+    }\n+\n+    abstract function isValid();\n }\n \n+class ClientSession extends EndUser {\n+    use UserSessionTrait;\n \n-class StaffSession extends Staff {\n+    function __construct($user) {\n+        global $cfg;\n+        parent::__construct($user);\n+        $this->class ='client';\n+        // XXX: Change the key to user-id\n+        $this->session = new UserSession($user->getId());\n+        $this->setSessionToken();\n+        $this->maxidletime = $cfg->getClientTimeout();\n+    }\n \n-    var $session;\n-    var $token;\n+    function getSessionUser() {\n+        return $this->user;\n+    }\n+\n+    function isValid() {\n+        return $this->isValidSession();\n+    }\n+}\n+\n+class StaffSession extends Staff {\n+    use UserSessionTrait;\n \n     static function lookup($var) {\n-        if ($staff = parent::lookup($var)) {\n-            $staff->token = &$_SESSION[':token']['staff'];\n-            $staff->session= new UserSession($staff->getId());\n+        global $cfg;\n+        if (($staff = parent::lookup($var))) {\n+            $staff->class = 'staff';\n+            $staff->session = new UserSession($staff->getId());\n+            $staff->setSessionToken();\n+            $staff->maxidletime = $cfg->getStaffTimeout();\n+            $staff->checkip = $cfg->enableStaffIPBinding();\n         }\n         return $staff;\n     }\n \n     function clear2FA() {\n+        unset($_SESSION['_auth']['staff']['2fa']);\n         $_SESSION['_auth']['staff']['2fa'] = null;\n         return true;\n     }\n \n     // If 2fa is set then it means it's pending\n     function is2FAPending() {\n-        if (!isset($_SESSION['_auth']['staff']['2fa']))\n-            return false;\n-\n-        return true;\n-    }\n-\n-    function isValid(){\n-        global $cfg;\n-\n-        if(!$this->getId() || $this->session->getSessionId()!=session_id())\n-            return false;\n-\n-        if ($this->is2FAPending())\n-            return false;\n-\n-        return $this->session->isvalidSession($this->token,$cfg->getStaffTimeout(),$cfg->enableStaffIPBinding())?true:false;\n-    }\n-\n-    function refreshSession($force=false){\n-        global $cfg;\n-\n-        $time = $this->session->getLastUpdate($this->token);\n-        // Deadband session token updates to once / 30-seconds\n-        if (!$force && time() - $time < 30)\n-            return;\n-\n-        $this->token=$this->getSessionToken();\n-\n-        osTicketSession::renewCookie($time, $cfg->getStaffSessionTimeout());\n-    }\n-\n-    function getSession() {\n-        return $this->session;\n-    }\n-\n-    function getSessionToken() {\n-        return $this->session->sessionToken();\n+        return isset($_SESSION['_auth']['staff']['2fa']);\n     }\n \n-    function getIP(){\n-        return $this->session->getIP();\n+    function isValid() {\n+        return (!$this->is2FAPending() && $this->isValidSession());\n     }\n-\n }\n-\n ?>"
        },
        {
          "filename": "open.php",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -47,9 +47,9 @@\n         // Drop session-backed form data\n         unset($_SESSION[':form-data']);\n         //Logged in...simply view the newly created ticket.\n-        if($thisclient && $thisclient->isValid()) {\n-            session_regenerate_id();\n-            session_write_close();\n+        if ($thisclient && $thisclient->isValid()) {\n+            // Regenerate session id\n+            $thisclient->regenerateSession();\n             @header('Location: tickets.php?id='.$ticket->getId());\n         } else\n             $ost->getCSRF()->rotate();"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "4689926b2d3d25754f0ddcf8d4e181a2817f6d56",
            "date": "2023-10-25T15:45:33Z",
            "author_login": "JediKev"
          },
          {
            "sha": "03755768d9f239d70a1af7ddc7eb35c49bf6239d",
            "date": "2023-10-25T15:34:06Z",
            "author_login": "JediKev"
          },
          {
            "sha": "0f08e5b0b7474522d76416e7b57709c3ff619fef",
            "date": "2023-10-25T15:26:17Z",
            "author_login": "JediKev"
          },
          {
            "sha": "7c2003629dd7c11db33cd7d7f790704d87cfd412",
            "date": "2023-10-25T15:19:29Z",
            "author_login": "JediKev"
          },
          {
            "sha": "f878766863fc6e5bc8b8c53ae48afef31496b53a",
            "date": "2023-10-25T15:06:35Z",
            "author_login": "JediKev"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-384",
    "description": "Session Fixation vulnerability in in function login in class.auth.php in osTicket through 1.16.2.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-04-05T22:15:07.180",
    "last_modified": "2024-11-21T07:05:26.577",
    "fix_date": "2022-04-24T20:49:20Z"
  },
  "references": [
    {
      "url": "https://checkmarx.com/blog/securing-open-source-solutions-a-study-of-osticket-vulnerabilities/",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit"
      ]
    },
    {
      "url": "https://github.com/osTicket/osTicket/commit/85a76f403a3a116176d0798f39a4c430181d8364",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/osTicket/osTicket/releases/tag/v1.16.3",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://checkmarx.com/blog/securing-open-source-solutions-a-study-of-osticket-vulnerabilities/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit"
      ]
    },
    {
      "url": "https://github.com/osTicket/osTicket/commit/85a76f403a3a116176d0798f39a4c430181d8364",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/osTicket/osTicket/releases/tag/v1.16.3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:09.056611",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "osTicket",
    "owner": "osTicket",
    "created_at": "2013-08-12T19:10:14Z",
    "updated_at": "2025-01-25T07:44:35Z",
    "pushed_at": "2024-11-14T16:43:24Z",
    "size": 76341,
    "stars": 3311,
    "forks": 1677,
    "open_issues": 1163,
    "watchers": 3311,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "develop"
    ],
    "languages": {
      "PHP": 6160811,
      "JavaScript": 360520,
      "CSS": 239335,
      "Less": 15079,
      "Shell": 4233,
      "Perl": 2087,
      "HTML": 882,
      "Standard ML": 33
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-26T07:46:21.978137"
  }
}