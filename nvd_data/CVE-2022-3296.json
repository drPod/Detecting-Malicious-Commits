{
  "cve_id": "CVE-2022-3296",
  "github_data": {
    "repository": "vim/vim",
    "fix_commit": "96b9bf8f74af8abf1e30054f996708db7dc285be",
    "related_commits": [
      "96b9bf8f74af8abf1e30054f996708db7dc285be",
      "96b9bf8f74af8abf1e30054f996708db7dc285be"
    ],
    "patch_url": "https://github.com/vim/vim/commit/96b9bf8f74af8abf1e30054f996708db7dc285be.patch",
    "fix_commit_details": {
      "sha": "96b9bf8f74af8abf1e30054f996708db7dc285be",
      "commit_date": "2022-09-24T16:24:12Z",
      "author": {
        "login": "brammool",
        "type": "User",
        "stats": {
          "total_commits": 16567,
          "average_weekly_commits": 15.411162790697674,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 874
        }
      },
      "commit_message": {
        "title": "patch 9.0.0577: buffer underflow with unexpected :finally",
        "length": 153,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 547,
        "additions": 284,
        "deletions": 263
      },
      "files": [
        {
          "filename": "src/ex_eval.c",
          "status": "modified",
          "additions": 260,
          "deletions": 263,
          "patch": "@@ -1935,128 +1935,127 @@ ex_finally(exarg_T *eap)\n     if (cmdmod_error(FALSE))\n \treturn;\n \n-    if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)\n+    for (idx = cstack->cs_idx; idx >= 0; --idx)\n+\tif (cstack->cs_flags[idx] & CSF_TRY)\n+\t    break;\n+    if (cstack->cs_trylevel <= 0 || idx < 0)\n+    {\n \teap->errmsg = _(e_finally_without_try);\n-    else\n+\treturn;\n+    }\n+\n+    if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n     {\n-\tif (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n-\t{\n-\t    eap->errmsg = get_end_emsg(cstack);\n-\t    for (idx = cstack->cs_idx - 1; idx > 0; --idx)\n-\t\tif (cstack->cs_flags[idx] & CSF_TRY)\n-\t\t    break;\n-\t    // Make this error pending, so that the commands in the following\n-\t    // finally clause can be executed.  This overrules also a pending\n-\t    // \":continue\", \":break\", \":return\", or \":finish\".\n-\t    pending = CSTP_ERROR;\n-\t}\n-\telse\n-\t    idx = cstack->cs_idx;\n+\teap->errmsg = get_end_emsg(cstack);\n+\t// Make this error pending, so that the commands in the following\n+\t// finally clause can be executed.  This overrules also a pending\n+\t// \":continue\", \":break\", \":return\", or \":finish\".\n+\tpending = CSTP_ERROR;\n+    }\n \n-\tif (cstack->cs_flags[idx] & CSF_FINALLY)\n+    if (cstack->cs_flags[idx] & CSF_FINALLY)\n+    {\n+\t// Give up for a multiple \":finally\" and ignore it.\n+\teap->errmsg = _(e_multiple_finally);\n+\treturn;\n+    }\n+    rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,\n+\t\t\t\t\t\t   &cstack->cs_looplevel);\n+\n+    /*\n+     * Don't do something when the corresponding try block never got active\n+     * (because of an inactive surrounding conditional or after an error or\n+     * interrupt or throw) or for a \":finally\" without \":try\" or a multiple\n+     * \":finally\".  After every other error (did_emsg or the conditional\n+     * errors detected above) or after an interrupt (got_int) or an\n+     * exception (did_throw), the finally clause must be executed.\n+     */\n+    skip = !(cstack->cs_flags[cstack->cs_idx] & CSF_TRUE);\n+\n+    if (!skip)\n+    {\n+\t// When debugging or a breakpoint was encountered, display the\n+\t// debug prompt (if not already done).  The user then knows that the\n+\t// finally clause is executed.\n+\tif (dbg_check_skipped(eap))\n \t{\n-\t    // Give up for a multiple \":finally\" and ignore it.\n-\t    eap->errmsg = _(e_multiple_finally);\n-\t    return;\n+\t    // Handle a \">quit\" debug command as if an interrupt had\n+\t    // occurred before the \":finally\".  That is, discard the\n+\t    // original exception and replace it by an interrupt\n+\t    // exception.\n+\t    (void)do_intthrow(cstack);\n \t}\n-\trewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,\n-\t\t\t\t\t\t       &cstack->cs_looplevel);\n \n \t/*\n-\t * Don't do something when the corresponding try block never got active\n-\t * (because of an inactive surrounding conditional or after an error or\n-\t * interrupt or throw) or for a \":finally\" without \":try\" or a multiple\n-\t * \":finally\".  After every other error (did_emsg or the conditional\n-\t * errors detected above) or after an interrupt (got_int) or an\n-\t * exception (did_throw), the finally clause must be executed.\n+\t * If there is a preceding catch clause and it caught the exception,\n+\t * finish the exception now.  This happens also after errors except\n+\t * when this is a multiple \":finally\" or one not within a \":try\".\n+\t * After an error or interrupt, this also discards a pending\n+\t * \":continue\", \":break\", \":finish\", or \":return\" from the preceding\n+\t * try block or catch clause.\n \t */\n-\tskip = !(cstack->cs_flags[cstack->cs_idx] & CSF_TRUE);\n+\tcleanup_conditionals(cstack, CSF_TRY, FALSE);\n \n-\tif (!skip)\n+\tif (cstack->cs_idx >= 0\n+\t\t\t   && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n \t{\n-\t    // When debugging or a breakpoint was encountered, display the\n-\t    // debug prompt (if not already done).  The user then knows that the\n-\t    // finally clause is executed.\n-\t    if (dbg_check_skipped(eap))\n-\t    {\n-\t\t// Handle a \">quit\" debug command as if an interrupt had\n-\t\t// occurred before the \":finally\".  That is, discard the\n-\t\t// original exception and replace it by an interrupt\n-\t\t// exception.\n-\t\t(void)do_intthrow(cstack);\n-\t    }\n-\n-\t    /*\n-\t     * If there is a preceding catch clause and it caught the exception,\n-\t     * finish the exception now.  This happens also after errors except\n-\t     * when this is a multiple \":finally\" or one not within a \":try\".\n-\t     * After an error or interrupt, this also discards a pending\n-\t     * \":continue\", \":break\", \":finish\", or \":return\" from the preceding\n-\t     * try block or catch clause.\n-\t     */\n-\t    cleanup_conditionals(cstack, CSF_TRY, FALSE);\n+\t    // Variables declared in the previous block can no longer be\n+\t    // used.\n+\t    leave_block(cstack);\n+\t    enter_block(cstack);\n+\t}\n \n-\t    if (cstack->cs_idx >= 0\n-\t\t\t       && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n+\t/*\n+\t * Make did_emsg, got_int, did_throw pending.  If set, they overrule\n+\t * a pending \":continue\", \":break\", \":return\", or \":finish\".  Then\n+\t * we have particularly to discard a pending return value (as done\n+\t * by the call to cleanup_conditionals() above when did_emsg or\n+\t * got_int is set).  The pending values are restored by the\n+\t * \":endtry\", except if there is a new error, interrupt, exception,\n+\t * \":continue\", \":break\", \":return\", or \":finish\" in the following\n+\t * finally clause.  A missing \":endwhile\", \":endfor\" or \":endif\"\n+\t * detected here is treated as if did_emsg and did_throw had\n+\t * already been set, respectively in case that the error is not\n+\t * converted to an exception, did_throw had already been unset.\n+\t * We must not set did_emsg here since that would suppress the\n+\t * error message.\n+\t */\n+\tif (pending == CSTP_ERROR || did_emsg || got_int || did_throw)\n+\t{\n+\t    if (cstack->cs_pending[cstack->cs_idx] == CSTP_RETURN)\n \t    {\n-\t\t// Variables declared in the previous block can no longer be\n-\t\t// used.\n-\t\tleave_block(cstack);\n-\t\tenter_block(cstack);\n+\t\treport_discard_pending(CSTP_RETURN,\n+\t\t\t\t       cstack->cs_rettv[cstack->cs_idx]);\n+\t\tdiscard_pending_return(cstack->cs_rettv[cstack->cs_idx]);\n \t    }\n-\n-\t    /*\n-\t     * Make did_emsg, got_int, did_throw pending.  If set, they overrule\n-\t     * a pending \":continue\", \":break\", \":return\", or \":finish\".  Then\n-\t     * we have particularly to discard a pending return value (as done\n-\t     * by the call to cleanup_conditionals() above when did_emsg or\n-\t     * got_int is set).  The pending values are restored by the\n-\t     * \":endtry\", except if there is a new error, interrupt, exception,\n-\t     * \":continue\", \":break\", \":return\", or \":finish\" in the following\n-\t     * finally clause.  A missing \":endwhile\", \":endfor\" or \":endif\"\n-\t     * detected here is treated as if did_emsg and did_throw had\n-\t     * already been set, respectively in case that the error is not\n-\t     * converted to an exception, did_throw had already been unset.\n-\t     * We must not set did_emsg here since that would suppress the\n-\t     * error message.\n-\t     */\n-\t    if (pending == CSTP_ERROR || did_emsg || got_int || did_throw)\n-\t    {\n-\t\tif (cstack->cs_pending[cstack->cs_idx] == CSTP_RETURN)\n-\t\t{\n-\t\t    report_discard_pending(CSTP_RETURN,\n-\t\t\t\t\t   cstack->cs_rettv[cstack->cs_idx]);\n-\t\t    discard_pending_return(cstack->cs_rettv[cstack->cs_idx]);\n-\t\t}\n-\t\tif (pending == CSTP_ERROR && !did_emsg)\n-\t\t    pending |= (THROW_ON_ERROR) ? CSTP_THROW : 0;\n-\t\telse\n-\t\t    pending |= did_throw ? CSTP_THROW : 0;\n-\t\tpending |= did_emsg  ? CSTP_ERROR     : 0;\n-\t\tpending |= got_int   ? CSTP_INTERRUPT : 0;\n-\t\tcstack->cs_pending[cstack->cs_idx] = pending;\n-\n-\t\t// It's mandatory that the current exception is stored in the\n-\t\t// cstack so that it can be rethrown at the \":endtry\" or be\n-\t\t// discarded if the finally clause is left by a \":continue\",\n-\t\t// \":break\", \":return\", \":finish\", error, interrupt, or another\n-\t\t// exception.  When emsg() is called for a missing \":endif\" or\n-\t\t// a missing \":endwhile\"/\":endfor\" detected here, the\n-\t\t// exception will be discarded.\n-\t\tif (did_throw && cstack->cs_exception[cstack->cs_idx]\n-\t\t\t\t\t\t\t != current_exception)\n-\t\t    internal_error(\"ex_finally()\");\n-\t    }\n-\n-\t    /*\n-\t     * Set CSL_HAD_FINA, so do_cmdline() will reset did_emsg,\n-\t     * got_int, and did_throw and make the finally clause active.\n-\t     * This will happen after emsg() has been called for a missing\n-\t     * \":endif\" or a missing \":endwhile\"/\":endfor\" detected here, so\n-\t     * that the following finally clause will be executed even then.\n-\t     */\n-\t    cstack->cs_lflags |= CSL_HAD_FINA;\n+\t    if (pending == CSTP_ERROR && !did_emsg)\n+\t\tpending |= (THROW_ON_ERROR) ? CSTP_THROW : 0;\n+\t    else\n+\t\tpending |= did_throw ? CSTP_THROW : 0;\n+\t    pending |= did_emsg  ? CSTP_ERROR     : 0;\n+\t    pending |= got_int   ? CSTP_INTERRUPT : 0;\n+\t    cstack->cs_pending[cstack->cs_idx] = pending;\n+\n+\t    // It's mandatory that the current exception is stored in the\n+\t    // cstack so that it can be rethrown at the \":endtry\" or be\n+\t    // discarded if the finally clause is left by a \":continue\",\n+\t    // \":break\", \":return\", \":finish\", error, interrupt, or another\n+\t    // exception.  When emsg() is called for a missing \":endif\" or\n+\t    // a missing \":endwhile\"/\":endfor\" detected here, the\n+\t    // exception will be discarded.\n+\t    if (did_throw && cstack->cs_exception[cstack->cs_idx]\n+\t\t\t\t\t\t     != current_exception)\n+\t\tinternal_error(\"ex_finally()\");\n \t}\n+\n+\t/*\n+\t * Set CSL_HAD_FINA, so do_cmdline() will reset did_emsg,\n+\t * got_int, and did_throw and make the finally clause active.\n+\t * This will happen after emsg() has been called for a missing\n+\t * \":endif\" or a missing \":endwhile\"/\":endfor\" detected here, so\n+\t * that the following finally clause will be executed even then.\n+\t */\n+\tcstack->cs_lflags |= CSL_HAD_FINA;\n     }\n }\n \n@@ -2076,185 +2075,183 @@ ex_endtry(exarg_T *eap)\n     if (cmdmod_error(FALSE))\n \treturn;\n \n-    if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)\n-\teap->errmsg = _(e_endtry_without_try);\n-    else\n+    for (idx = cstack->cs_idx; idx >= 0; --idx)\n+\tif (cstack->cs_flags[idx] & CSF_TRY)\n+\t    break;\n+    if (cstack->cs_trylevel <= 0 || idx < 0)\n     {\n-\t/*\n-\t * Don't do something after an error, interrupt or throw in the try\n-\t * block, catch clause, or finally clause preceding this \":endtry\" or\n-\t * when an error or interrupt occurred after a \":continue\", \":break\",\n-\t * \":return\", or \":finish\" in a try block or catch clause preceding this\n-\t * \":endtry\" or when the try block never got active (because of an\n-\t * inactive surrounding conditional or after an error or interrupt or\n-\t * throw) or when there is a surrounding conditional and it has been\n-\t * made inactive by a \":continue\", \":break\", \":return\", or \":finish\" in\n-\t * the finally clause.  The latter case need not be tested since then\n-\t * anything pending has already been discarded. */\n-\tskip = did_emsg || got_int || did_throw\n+\teap->errmsg = _(e_endtry_without_try);\n+\treturn;\n+    }\n+\n+    /*\n+     * Don't do something after an error, interrupt or throw in the try\n+     * block, catch clause, or finally clause preceding this \":endtry\" or\n+     * when an error or interrupt occurred after a \":continue\", \":break\",\n+     * \":return\", or \":finish\" in a try block or catch clause preceding this\n+     * \":endtry\" or when the try block never got active (because of an\n+     * inactive surrounding conditional or after an error or interrupt or\n+     * throw) or when there is a surrounding conditional and it has been\n+     * made inactive by a \":continue\", \":break\", \":return\", or \":finish\" in\n+     * the finally clause.  The latter case need not be tested since then\n+     * anything pending has already been discarded. */\n+    skip = did_emsg || got_int || did_throw\n \t\t\t     || !(cstack->cs_flags[cstack->cs_idx] & CSF_TRUE);\n \n-\tif (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n-\t{\n-\t    eap->errmsg = get_end_emsg(cstack);\n+    if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n+    {\n+\teap->errmsg = get_end_emsg(cstack);\n \n-\t    // Find the matching \":try\" and report what's missing.\n-\t    idx = cstack->cs_idx;\n-\t    do\n-\t\t--idx;\n-\t    while (idx > 0 && !(cstack->cs_flags[idx] & CSF_TRY));\n-\t    rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,\n-\t\t\t\t\t\t       &cstack->cs_looplevel);\n-\t    skip = TRUE;\n+\t// Find the matching \":try\" and report what's missing.\n+\trewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,\n+\t\t\t\t\t\t\t&cstack->cs_looplevel);\n+\tskip = TRUE;\n \n-\t    /*\n-\t     * If an exception is being thrown, discard it to prevent it from\n-\t     * being rethrown at the end of this function.  It would be\n-\t     * discarded by the error message, anyway.  Resets did_throw.\n-\t     * This does not affect the script termination due to the error\n-\t     * since \"trylevel\" is decremented after emsg() has been called.\n-\t     */\n-\t    if (did_throw)\n-\t\tdiscard_current_exception();\n+\t/*\n+\t * If an exception is being thrown, discard it to prevent it from\n+\t * being rethrown at the end of this function.  It would be\n+\t * discarded by the error message, anyway.  Resets did_throw.\n+\t * This does not affect the script termination due to the error\n+\t * since \"trylevel\" is decremented after emsg() has been called.\n+\t */\n+\tif (did_throw)\n+\t    discard_current_exception();\n \n-\t    // report eap->errmsg, also when there already was an error\n-\t    did_emsg = FALSE;\n-\t}\n-\telse\n-\t{\n-\t    idx = cstack->cs_idx;\n+\t// report eap->errmsg, also when there already was an error\n+\tdid_emsg = FALSE;\n+    }\n+    else\n+    {\n+\tidx = cstack->cs_idx;\n \n-\t    // Check the flags only when not in a skipped block.\n-\t    if (!skip && in_vim9script()\n+\t// Check the flags only when not in a skipped block.\n+\tif (!skip && in_vim9script()\n \t\t     && (cstack->cs_flags[idx] & (CSF_CATCH|CSF_FINALLY)) == 0)\n-\t    {\n-\t\t// try/endtry without any catch or finally: give an error and\n-\t\t// continue.\n-\t\teap->errmsg = _(e_missing_catch_or_finally);\n-\t    }\n-\n-\t    /*\n-\t     * If we stopped with the exception currently being thrown at this\n-\t     * try conditional since we didn't know that it doesn't have\n-\t     * a finally clause, we need to rethrow it after closing the try\n-\t     * conditional.\n-\t     */\n-\t    if (did_throw && (cstack->cs_flags[idx] & CSF_TRUE)\n-\t\t    && !(cstack->cs_flags[idx] & CSF_FINALLY))\n-\t\trethrow = TRUE;\n-\t}\n-\n-\t// If there was no finally clause, show the user when debugging or\n-\t// a breakpoint was encountered that the end of the try conditional has\n-\t// been reached: display the debug prompt (if not already done).  Do\n-\t// this on normal control flow or when an exception was thrown, but not\n-\t// on an interrupt or error not converted to an exception or when\n-\t// a \":break\", \":continue\", \":return\", or \":finish\" is pending.  These\n-\t// actions are carried out immediately.\n-\tif ((rethrow || (!skip\n-\t\t\t&& !(cstack->cs_flags[idx] & CSF_FINALLY)\n-\t\t\t&& !cstack->cs_pending[idx]))\n-\t\t&& dbg_check_skipped(eap))\n \t{\n-\t    // Handle a \">quit\" debug command as if an interrupt had occurred\n-\t    // before the \":endtry\".  That is, throw an interrupt exception and\n-\t    // set \"skip\" and \"rethrow\".\n-\t    if (got_int)\n-\t    {\n-\t\tskip = TRUE;\n-\t\t(void)do_intthrow(cstack);\n-\t\t// The do_intthrow() call may have reset did_throw or\n-\t\t// cstack->cs_pending[idx].\n-\t\trethrow = FALSE;\n-\t\tif (did_throw && !(cstack->cs_flags[idx] & CSF_FINALLY))\n-\t\t    rethrow = TRUE;\n-\t    }\n+\t    // try/endtry without any catch or finally: give an error and\n+\t    // continue.\n+\t    eap->errmsg = _(e_missing_catch_or_finally);\n \t}\n \n \t/*\n-\t * If a \":return\" is pending, we need to resume it after closing the\n-\t * try conditional; remember the return value.  If there was a finally\n-\t * clause making an exception pending, we need to rethrow it.  Make it\n-\t * the exception currently being thrown.\n+\t * If we stopped with the exception currently being thrown at this\n+\t * try conditional since we didn't know that it doesn't have\n+\t * a finally clause, we need to rethrow it after closing the try\n+\t * conditional.\n \t */\n-\tif (!skip)\n+\tif (did_throw && (cstack->cs_flags[idx] & CSF_TRUE)\n+\t\t&& !(cstack->cs_flags[idx] & CSF_FINALLY))\n+\t    rethrow = TRUE;\n+    }\n+\n+    // If there was no finally clause, show the user when debugging or\n+    // a breakpoint was encountered that the end of the try conditional has\n+    // been reached: display the debug prompt (if not already done).  Do\n+    // this on normal control flow or when an exception was thrown, but not\n+    // on an interrupt or error not converted to an exception or when\n+    // a \":break\", \":continue\", \":return\", or \":finish\" is pending.  These\n+    // actions are carried out immediately.\n+    if ((rethrow || (!skip && !(cstack->cs_flags[idx] & CSF_FINALLY)\n+\t\t    && !cstack->cs_pending[idx]))\n+\t    && dbg_check_skipped(eap))\n+    {\n+\t// Handle a \">quit\" debug command as if an interrupt had occurred\n+\t// before the \":endtry\".  That is, throw an interrupt exception and\n+\t// set \"skip\" and \"rethrow\".\n+\tif (got_int)\n \t{\n-\t    pending = cstack->cs_pending[idx];\n-\t    cstack->cs_pending[idx] = CSTP_NONE;\n-\t    if (pending == CSTP_RETURN)\n-\t\trettv = cstack->cs_rettv[idx];\n-\t    else if (pending & CSTP_THROW)\n-\t\tcurrent_exception = cstack->cs_exception[idx];\n+\t    skip = TRUE;\n+\t    (void)do_intthrow(cstack);\n+\t    // The do_intthrow() call may have reset did_throw or\n+\t    // cstack->cs_pending[idx].\n+\t    rethrow = FALSE;\n+\t    if (did_throw && !(cstack->cs_flags[idx] & CSF_FINALLY))\n+\t\trethrow = TRUE;\n \t}\n+    }\n \n-\t/*\n-\t * Discard anything pending on an error, interrupt, or throw in the\n-\t * finally clause.  If there was no \":finally\", discard a pending\n-\t * \":continue\", \":break\", \":return\", or \":finish\" if an error or\n-\t * interrupt occurred afterwards, but before the \":endtry\" was reached.\n-\t * If an exception was caught by the last of the catch clauses and there\n-\t * was no finally clause, finish the exception now.  This happens also\n-\t * after errors except when this \":endtry\" is not within a \":try\".\n-\t * Restore \"emsg_silent\" if it has been reset by this try conditional.\n-\t */\n-\t(void)cleanup_conditionals(cstack, CSF_TRY | CSF_SILENT, TRUE);\n+    /*\n+     * If a \":return\" is pending, we need to resume it after closing the\n+     * try conditional; remember the return value.  If there was a finally\n+     * clause making an exception pending, we need to rethrow it.  Make it\n+     * the exception currently being thrown.\n+     */\n+    if (!skip)\n+    {\n+\tpending = cstack->cs_pending[idx];\n+\tcstack->cs_pending[idx] = CSTP_NONE;\n+\tif (pending == CSTP_RETURN)\n+\t    rettv = cstack->cs_rettv[idx];\n+\telse if (pending & CSTP_THROW)\n+\t    current_exception = cstack->cs_exception[idx];\n+    }\n \n-\tif (cstack->cs_idx >= 0\n-\t\t\t       && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n-\t    leave_block(cstack);\n-\t--cstack->cs_trylevel;\n+    /*\n+     * Discard anything pending on an error, interrupt, or throw in the\n+     * finally clause.  If there was no \":finally\", discard a pending\n+     * \":continue\", \":break\", \":return\", or \":finish\" if an error or\n+     * interrupt occurred afterwards, but before the \":endtry\" was reached.\n+     * If an exception was caught by the last of the catch clauses and there\n+     * was no finally clause, finish the exception now.  This happens also\n+     * after errors except when this \":endtry\" is not within a \":try\".\n+     * Restore \"emsg_silent\" if it has been reset by this try conditional.\n+     */\n+    (void)cleanup_conditionals(cstack, CSF_TRY | CSF_SILENT, TRUE);\n \n-\tif (!skip)\n-\t{\n-\t    report_resume_pending(pending,\n+    if (cstack->cs_idx >= 0 && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n+\tleave_block(cstack);\n+    --cstack->cs_trylevel;\n+\n+    if (!skip)\n+    {\n+\treport_resume_pending(pending,\n \t\t    (pending == CSTP_RETURN) ? rettv :\n \t\t    (pending & CSTP_THROW) ? (void *)current_exception : NULL);\n-\t    switch (pending)\n-\t    {\n-\t\tcase CSTP_NONE:\n-\t\t    break;\n+\tswitch (pending)\n+\t{\n+\t    case CSTP_NONE:\n+\t\tbreak;\n \n-\t\t// Reactivate a pending \":continue\", \":break\", \":return\",\n-\t\t// \":finish\" from the try block or a catch clause of this try\n-\t\t// conditional.  This is skipped, if there was an error in an\n-\t\t// (unskipped) conditional command or an interrupt afterwards\n-\t\t// or if the finally clause is present and executed a new error,\n-\t\t// interrupt, throw, \":continue\", \":break\", \":return\", or\n-\t\t// \":finish\".\n-\t\tcase CSTP_CONTINUE:\n-\t\t    ex_continue(eap);\n-\t\t    break;\n-\t\tcase CSTP_BREAK:\n-\t\t    ex_break(eap);\n-\t\t    break;\n-\t\tcase CSTP_RETURN:\n-\t\t    do_return(eap, FALSE, FALSE, rettv);\n-\t\t    break;\n-\t\tcase CSTP_FINISH:\n-\t\t    do_finish(eap, FALSE);\n-\t\t    break;\n+\t    // Reactivate a pending \":continue\", \":break\", \":return\",\n+\t    // \":finish\" from the try block or a catch clause of this try\n+\t    // conditional.  This is skipped, if there was an error in an\n+\t    // (unskipped) conditional command or an interrupt afterwards\n+\t    // or if the finally clause is present and executed a new error,\n+\t    // interrupt, throw, \":continue\", \":break\", \":return\", or\n+\t    // \":finish\".\n+\t    case CSTP_CONTINUE:\n+\t\tex_continue(eap);\n+\t\tbreak;\n+\t    case CSTP_BREAK:\n+\t\tex_break(eap);\n+\t\tbreak;\n+\t    case CSTP_RETURN:\n+\t\tdo_return(eap, FALSE, FALSE, rettv);\n+\t\tbreak;\n+\t    case CSTP_FINISH:\n+\t\tdo_finish(eap, FALSE);\n+\t\tbreak;\n \n-\t\t// When the finally clause was entered due to an error,\n-\t\t// interrupt or throw (as opposed to a \":continue\", \":break\",\n-\t\t// \":return\", or \":finish\"), restore the pending values of\n-\t\t// did_emsg, got_int, and did_throw.  This is skipped, if there\n-\t\t// was a new error, interrupt, throw, \":continue\", \":break\",\n-\t\t// \":return\", or \":finish\".  in the finally clause.\n-\t\tdefault:\n-\t\t    if (pending & CSTP_ERROR)\n-\t\t\tdid_emsg = TRUE;\n-\t\t    if (pending & CSTP_INTERRUPT)\n-\t\t\tgot_int = TRUE;\n-\t\t    if (pending & CSTP_THROW)\n-\t\t\trethrow = TRUE;\n-\t\t    break;\n-\t    }\n+\t    // When the finally clause was entered due to an error,\n+\t    // interrupt or throw (as opposed to a \":continue\", \":break\",\n+\t    // \":return\", or \":finish\"), restore the pending values of\n+\t    // did_emsg, got_int, and did_throw.  This is skipped, if there\n+\t    // was a new error, interrupt, throw, \":continue\", \":break\",\n+\t    // \":return\", or \":finish\".  in the finally clause.\n+\t    default:\n+\t\tif (pending & CSTP_ERROR)\n+\t\t    did_emsg = TRUE;\n+\t\tif (pending & CSTP_INTERRUPT)\n+\t\t    got_int = TRUE;\n+\t\tif (pending & CSTP_THROW)\n+\t\t    rethrow = TRUE;\n+\t\tbreak;\n \t}\n-\n-\tif (rethrow)\n-\t    // Rethrow the current exception (within this cstack).\n-\t    do_throw(cstack);\n     }\n+\n+    if (rethrow)\n+\t// Rethrow the current exception (within this cstack).\n+\tdo_throw(cstack);\n }\n \n /*"
        },
        {
          "filename": "src/testdir/test_trycatch.vim",
          "status": "modified",
          "additions": 22,
          "deletions": 0,
          "patch": "@@ -3,6 +3,7 @@\n \n source check.vim\n source shared.vim\n+import './vim9.vim' as v9\n \n \"-------------------------------------------------------------------------------\n \" Test environment\t\t\t\t\t\t\t    {{{1\n@@ -2008,6 +2009,27 @@ func Test_try_catch_errors()\n   call assert_fails('try | for i in range(5) | endif | endtry', 'E580:')\n   call assert_fails('try | while v:true | endtry', 'E170:')\n   call assert_fails('try | if v:true | endtry', 'E171:')\n+\n+  \" this was using a negative index in cstack[]\n+  let lines =<< trim END\n+      try\n+      for\n+      if\n+      endwhile\n+      if\n+      finally\n+  END\n+  call v9.CheckScriptFailure(lines, 'E690:')\n+\n+  let lines =<< trim END\n+      try\n+      for\n+      if\n+      endwhile\n+      if\n+      endtry\n+  END\n+  call v9.CheckScriptFailure(lines, 'E690:')\n endfunc\n \n \" Test for verbose messages with :try :catch, and :finally                 {{{1"
        },
        {
          "filename": "src/version.c",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -699,6 +699,8 @@ static char *(features[]) =\n \n static int included_patches[] =\n {   /* Add new patch number below this line */\n+/**/\n+    577,\n /**/\n     576,\n /**/"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "1aefe1de0b20fe4966863e07efa14b6aa87323ee",
            "date": "2025-01-14T16:29:42Z",
            "author_login": "yegappan"
          },
          {
            "sha": "1ac53b84ada3a992f320566737e66fa00d48611f",
            "date": "2025-01-14T16:25:02Z",
            "author_login": "chrisbra"
          },
          {
            "sha": "57f0119358ed7f060d5020309b9043463121435f",
            "date": "2025-01-14T16:21:42Z",
            "author_login": "h-east"
          },
          {
            "sha": "045564d0a73218594691953c0c8bf2035e1e176e",
            "date": "2025-01-14T16:15:59Z",
            "author_login": "habamax"
          },
          {
            "sha": "6289f9159102e0855bedc566636b5e7ca6ced72c",
            "date": "2025-01-14T16:13:36Z",
            "author_login": "yegappan"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.8,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-121",
    "description": "Stack-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0577.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-09-25T17:15:09.457",
    "last_modified": "2024-11-21T07:19:14.457",
    "fix_date": "2022-09-24T16:24:12Z"
  },
  "references": [
    {
      "url": "https://github.com/vim/vim/commit/96b9bf8f74af8abf1e30054f996708db7dc285be",
      "source": "security@huntr.dev",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/958866b8-526a-4979-9471-39392e0c9077",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4QI7AETXBHPC7SGA77Q7O5IEGULWYET7/",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LSSEWQLK55MCNT4Z2IIJEJYEI5HLCODI/",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202305-16",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://github.com/vim/vim/commit/96b9bf8f74af8abf1e30054f996708db7dc285be",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/958866b8-526a-4979-9471-39392e0c9077",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4QI7AETXBHPC7SGA77Q7O5IEGULWYET7/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LSSEWQLK55MCNT4Z2IIJEJYEI5HLCODI/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202305-16",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:41.286039",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "vim",
    "owner": "vim",
    "created_at": "2015-08-18T21:03:56Z",
    "updated_at": "2025-01-14T08:58:33Z",
    "pushed_at": "2025-01-13T07:25:13Z",
    "size": 153925,
    "stars": 37215,
    "forks": 5529,
    "open_issues": 1516,
    "watchers": 37215,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Vim Script": 20025864,
      "C": 14374546,
      "Roff": 576344,
      "Makefile": 490522,
      "C++": 246793,
      "NSIS": 180936,
      "M4": 159971,
      "Java": 85446,
      "Shell": 71333,
      "PostScript": 64070,
      "Module Management System": 56375,
      "Python": 51761,
      "XS": 51261,
      "Ruby": 40309,
      "JavaScript": 37774,
      "NewLisp": 37431,
      "Raku": 34258,
      "Emacs Lisp": 30304,
      "Perl": 29735,
      "SystemVerilog": 27883,
      "Smalltalk": 25762,
      "Awk": 19481,
      "Batchfile": 18475,
      "Objective-C": 13147,
      "DIGITAL Command Language": 10835,
      "HTML": 6885,
      "Prolog": 4336,
      "KRL": 4206,
      "MATLAB": 1970,
      "Thrift": 1670,
      "OpenEdge ABL": 1490,
      "sed": 826,
      "Tcl": 745,
      "Lua": 738,
      "BitBake": 388
    },
    "commit_activity": {
      "total_commits_last_year": 1872,
      "avg_commits_per_week": 36.0,
      "days_active_last_year": 324
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "vim"
    },
    "collected_at": "2025-01-14T12:54:52.772009"
  }
}