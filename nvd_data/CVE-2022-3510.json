{
  "cve_id": "CVE-2022-3510",
  "github_data": {
    "repository": "protocolbuffers/protobuf",
    "fix_commit": "db7c17803320525722f45c1d26fc08bc41d1bf48",
    "related_commits": [
      "db7c17803320525722f45c1d26fc08bc41d1bf48",
      "db7c17803320525722f45c1d26fc08bc41d1bf48"
    ],
    "patch_url": "https://github.com/protocolbuffers/protobuf/commit/db7c17803320525722f45c1d26fc08bc41d1bf48.patch",
    "fix_commit_details": {
      "sha": "db7c17803320525722f45c1d26fc08bc41d1bf48",
      "commit_date": "2022-09-29T15:28:01Z",
      "author": {
        "login": "mkruskal-google",
        "type": "User",
        "stats": {
          "total_commits": 1010,
          "average_weekly_commits": 1.1771561771561772,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 131
        }
      },
      "commit_message": {
        "title": "Sync from Piper @mkruskal/footmitten",
        "length": 57,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 136,
        "additions": 110,
        "deletions": 26
      },
      "files": [
        {
          "filename": "CHANGES.txt",
          "status": "modified",
          "additions": 8,
          "deletions": 1,
          "patch": "@@ -40,8 +40,15 @@\n   * Optimized Java proto serialization gencode for protos having many extension ranges with few fields in between.\n   * More thoroughly annotate public generated code in Java lite protocol buffers.\n   * Fixed Bug in proto3 java lite repeated enum fields. Failed to call copyOnWrite before modifying previously built message. Causes modification to already \"built\" messages that should be immutable.\n-  * Refactoring java full runtime to reuse sub-message builders and prepare to migrate parsing logic from parse constructor to builder.\n   * Fix Java reflection serialization of empty packed fields.\n+  * Refactoring java full runtime to reuse sub-message builders and prepare to\n+    migrate parsing logic from parse constructor to builder.\n+  * Move proto wireformat parsing functionality from the private \"parsing\n+    constructor\" to the Builder class.\n+  * Change the Lite runtime to prefer merging from the wireformat into mutable\n+    messages rather than building up a new immutable object before merging. This\n+    way results in fewer allocations and copy operations.\n+  * Make message-type extensions merge from wire-format instead of building up instances and merging afterwards. This has much better performance.\n \n   Python\n   * Changes ordering of printed fields in .pyi files from lexicographic to the same ordering found in the proto descriptor."
        },
        {
          "filename": "java/core/src/main/java/com/google/protobuf/MessageReflection.java",
          "status": "modified",
          "additions": 54,
          "deletions": 11,
          "patch": "@@ -378,6 +378,7 @@ MergeTarget newEmptyTargetForField(\n   static class BuilderAdapter implements MergeTarget {\n \n     private final Message.Builder builder;\n+    private boolean hasNestedBuilders = true;\n \n     @Override\n     public Descriptors.Descriptor getDescriptorForType() {\n@@ -393,13 +394,30 @@ public Object getField(Descriptors.FieldDescriptor field) {\n       return builder.getField(field);\n     }\n \n+    private Message.Builder getFieldBuilder(Descriptors.FieldDescriptor field) {\n+      if (hasNestedBuilders) {\n+        try {\n+          return builder.getFieldBuilder(field);\n+        } catch (UnsupportedOperationException e) {\n+          hasNestedBuilders = false;\n+        }\n+      }\n+      return null;\n+    }\n+\n     @Override\n     public boolean hasField(Descriptors.FieldDescriptor field) {\n       return builder.hasField(field);\n     }\n \n     @Override\n     public MergeTarget setField(Descriptors.FieldDescriptor field, Object value) {\n+      if (!field.isRepeated() && value instanceof MessageLite.Builder) {\n+        if (value != getFieldBuilder(field)) {\n+          builder.setField(field, ((MessageLite.Builder) value).buildPartial());\n+        }\n+        return this;\n+      }\n       builder.setField(field, value);\n       return this;\n     }\n@@ -413,12 +431,18 @@ public MergeTarget clearField(Descriptors.FieldDescriptor field) {\n     @Override\n     public MergeTarget setRepeatedField(\n         Descriptors.FieldDescriptor field, int index, Object value) {\n+      if (value instanceof MessageLite.Builder) {\n+        value = ((MessageLite.Builder) value).buildPartial();\n+      }\n       builder.setRepeatedField(field, index, value);\n       return this;\n     }\n \n     @Override\n     public MergeTarget addRepeatedField(Descriptors.FieldDescriptor field, Object value) {\n+      if (value instanceof MessageLite.Builder) {\n+        value = ((MessageLite.Builder) value).buildPartial();\n+      }\n       builder.addRepeatedField(field, value);\n       return this;\n     }\n@@ -536,11 +560,19 @@ public void mergeGroup(\n         Message defaultInstance)\n         throws IOException {\n       if (!field.isRepeated()) {\n+        Message.Builder subBuilder;\n         if (hasField(field)) {\n-          input.readGroup(field.getNumber(), builder.getFieldBuilder(field), extensionRegistry);\n-          return;\n+          subBuilder = getFieldBuilder(field);\n+          if (subBuilder != null) {\n+            input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n+            return;\n+          } else {\n+            subBuilder = newMessageFieldInstance(field, defaultInstance);\n+            subBuilder.mergeFrom((Message) getField(field));\n+          }\n+        } else {\n+          subBuilder = newMessageFieldInstance(field, defaultInstance);\n         }\n-        Message.Builder subBuilder = newMessageFieldInstance(field, defaultInstance);\n         input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n         Object unused = setField(field, subBuilder.buildPartial());\n       } else {\n@@ -558,11 +590,19 @@ public void mergeMessage(\n         Message defaultInstance)\n         throws IOException {\n       if (!field.isRepeated()) {\n+        Message.Builder subBuilder;\n         if (hasField(field)) {\n-          input.readMessage(builder.getFieldBuilder(field), extensionRegistry);\n-          return;\n+          subBuilder = getFieldBuilder(field);\n+          if (subBuilder != null) {\n+            input.readMessage(subBuilder, extensionRegistry);\n+            return;\n+          } else {\n+            subBuilder = newMessageFieldInstance(field, defaultInstance);\n+            subBuilder.mergeFrom((Message) getField(field));\n+          }\n+        } else {\n+          subBuilder = newMessageFieldInstance(field, defaultInstance);\n         }\n-        Message.Builder subBuilder = newMessageFieldInstance(field, defaultInstance);\n         input.readMessage(subBuilder, extensionRegistry);\n         Object unused = setField(field, subBuilder.buildPartial());\n       } else {\n@@ -586,11 +626,14 @@ private Message.Builder newMessageFieldInstance(\n     public MergeTarget newMergeTargetForField(\n         Descriptors.FieldDescriptor field, Message defaultInstance) {\n       Message.Builder subBuilder;\n-      if (defaultInstance != null) {\n-        subBuilder = defaultInstance.newBuilderForType();\n-      } else {\n-        subBuilder = builder.newBuilderForField(field);\n+      if (!field.isRepeated() && hasField(field)) {\n+        subBuilder = getFieldBuilder(field);\n+        if (subBuilder != null) {\n+          return new BuilderAdapter(subBuilder);\n+        }\n       }\n+\n+      subBuilder = newMessageFieldInstance(field, defaultInstance);\n       if (!field.isRepeated()) {\n         Message originalMessage = (Message) getField(field);\n         if (originalMessage != null) {\n@@ -626,7 +669,7 @@ public WireFormat.Utf8Validation getUtf8Validation(Descriptors.FieldDescriptor d\n \n     @Override\n     public Object finish() {\n-      return builder.buildPartial();\n+      return builder;\n     }\n   }\n "
        },
        {
          "filename": "ruby/compatibility_tests/v3.0.0/tests/basic.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -667,8 +667,8 @@ def test_map_msg_enum_valuetypes\n       assert m[\"z\"] == :C\n       m[\"z\"] = 2\n       assert m[\"z\"] == :B\n-      m[\"z\"] = 4\n-      assert m[\"z\"] == 4\n+      m[\"z\"] = 5\n+      assert m[\"z\"] == 5\n       assert_raise RangeError do\n         m[\"z\"] = :Z\n       end"
        },
        {
          "filename": "ruby/ext/google/protobuf_c/message.c",
          "status": "modified",
          "additions": 7,
          "deletions": 2,
          "patch": "@@ -1263,15 +1263,20 @@ VALUE build_module_from_enumdesc(VALUE _enumdesc) {\n   int n = upb_EnumDef_ValueCount(e);\n   for (int i = 0; i < n; i++) {\n     const upb_EnumValueDef* ev = upb_EnumDef_Value(e, i);\n-    const char* name = upb_EnumValueDef_Name(ev);\n+    char* name = strdup(upb_EnumValueDef_Name(ev));\n     int32_t value = upb_EnumValueDef_Number(ev);\n     if (name[0] < 'A' || name[0] > 'Z') {\n-      rb_warn(\n+      if (name[0] >= 'a' && name[0] <= 'z') {\n+        name[0] -= 32; // auto capitalize\n+      } else {\n+        rb_warn(\n           \"Enum value '%s' does not start with an uppercase letter \"\n           \"as is required for Ruby constants.\",\n           name);\n+      }\n     }\n     rb_define_const(mod, name, INT2NUM(value));\n+    free(name);\n   }\n \n   rb_define_singleton_method(mod, \"lookup\", enum_lookup, 1);"
        },
        {
          "filename": "ruby/src/main/java/com/google/protobuf/jruby/RubyEnumDescriptor.java",
          "status": "modified",
          "additions": 20,
          "deletions": 3,
          "patch": "@@ -162,9 +162,10 @@ private RubyModule buildModuleFromDescriptor(ThreadContext context) {\n     boolean defaultValueRequiredButNotFound =\n         descriptor.getFile().getSyntax() == FileDescriptor.Syntax.PROTO3;\n     for (EnumValueDescriptor value : descriptor.getValues()) {\n-      String name = value.getName();\n-      // Make sure its a valid constant name before trying to create it\n-      if (Character.isUpperCase(name.codePointAt(0))) {\n+      String name = fixEnumConstantName(value.getName());\n+      // Make sure it's a valid constant name before trying to create it\n+      int ch = name.codePointAt(0);\n+      if (Character.isUpperCase(ch)) {\n         enumModule.defineConstant(name, runtime.newFixnum(value.getNumber()));\n       } else {\n         runtime\n@@ -189,6 +190,22 @@ private RubyModule buildModuleFromDescriptor(ThreadContext context) {\n     return enumModule;\n   }\n \n+  private static String fixEnumConstantName(String name) {\n+    if (name != null && name.length() > 0) {\n+      int ch = name.codePointAt(0);\n+      if (ch >= 'a' && ch <= 'z') {\n+        // Protobuf enums can start with lowercase letters, while Ruby's constant should\n+        // always start with uppercase letters. We tolerate this case by capitalizing\n+        // the first character if possible.\n+        return new StringBuilder()\n+                .appendCodePoint(Character.toUpperCase(ch))\n+                .append(name.substring(1))\n+                .toString();\n+      }\n+    }\n+    return name;\n+  }\n+\n   private EnumDescriptor descriptor;\n   private EnumDescriptorProto.Builder builder;\n   private IRubyObject name;"
        },
        {
          "filename": "ruby/tests/basic_test.proto",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -73,6 +73,7 @@ enum TestEnum {\n   A = 1;\n   B = 2;\n   C = 3;\n+  v0 = 4;\n }\n \n message TestEmbeddedMessageParent {"
        },
        {
          "filename": "ruby/tests/basic_test_proto2.proto",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -69,6 +69,7 @@ enum TestEnum {\n   A = 1;\n   B = 2;\n   C = 3;\n+  v0 = 4;\n }\n \n enum TestNonZeroEnum {"
        },
        {
          "filename": "ruby/tests/common_tests.rb",
          "status": "modified",
          "additions": 12,
          "deletions": 7,
          "patch": "@@ -331,14 +331,16 @@ def test_rptfield_enum\n     l.push :A\n     l.push :B\n     l.push :C\n-    assert l.count == 3\n+    l.push :v0\n+    assert l.count == 4\n     assert_raise RangeError do\n       l.push :D\n     end\n     assert l[0] == :A\n+    assert l[3] == :v0\n \n-    l.push 4\n-    assert l[3] == 4\n+    l.push 5\n+    assert l[4] == 5\n   end\n \n   def test_rptfield_initialize\n@@ -542,8 +544,8 @@ def test_map_msg_enum_valuetypes\n     assert m[\"z\"] == :C\n     m[\"z\"] = 2\n     assert m[\"z\"] == :B\n-    m[\"z\"] = 4\n-    assert m[\"z\"] == 4\n+    m[\"z\"] = 5\n+    assert m[\"z\"] == 5\n     assert_raise RangeError do\n       m[\"z\"] = :Z\n     end\n@@ -712,14 +714,17 @@ def test_enum_lookup\n     assert proto_module::TestEnum::A == 1\n     assert proto_module::TestEnum::B == 2\n     assert proto_module::TestEnum::C == 3\n+    assert proto_module::TestEnum::V0 == 4\n \n     assert proto_module::TestEnum::lookup(1) == :A\n     assert proto_module::TestEnum::lookup(2) == :B\n     assert proto_module::TestEnum::lookup(3) == :C\n+    assert proto_module::TestEnum::lookup(4) == :v0\n \n     assert proto_module::TestEnum::resolve(:A) == 1\n     assert proto_module::TestEnum::resolve(:B) == 2\n     assert proto_module::TestEnum::resolve(:C) == 3\n+    assert proto_module::TestEnum::resolve(:v0) == 4\n   end\n \n   def test_enum_const_get_helpers\n@@ -788,7 +793,7 @@ def test_enum_getter_only_enums\n     assert_raise(NoMethodError) { m.a }\n     assert_raise(NoMethodError) { m.a_const_const }\n   end\n-  \n+\n   def test_repeated_push\n     m = proto_module::TestMessage.new\n \n@@ -1762,7 +1767,7 @@ def test_freeze\n     assert_raise(FrozenErrorType) { m.repeated_msg = proto_module::TestMessage2.new }\n     assert_raise(FrozenErrorType) { m.repeated_enum = :A }\n   end\n-  \n+\n   def test_eq\n     m1 = proto_module::TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n     m2 = proto_module::TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])"
        },
        {
          "filename": "ruby/tests/generated_code.proto",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -67,6 +67,8 @@ enum TestEnum {\n   A = 1;\n   B = 2;\n   C = 3;\n+\n+  v0 = 4;\n }\n \n message testLowercaseNested {"
        },
        {
          "filename": "ruby/tests/generated_code_proto2.proto",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -68,6 +68,8 @@ enum TestEnum {\n   A = 1;\n   B = 2;\n   C = 3;\n+\n+  v0 = 4;\n }\n \n message TestUnknown {"
        },
        {
          "filename": "ruby/tests/repeated_field_test.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -697,6 +697,7 @@ def fill_test_msg(test_msg)\n       value :A, 1\n       value :B, 2\n       value :C, 3\n+      value :v0, 4\n     end\n   end\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 7,
        "unique_directories": 6,
        "max_directory_depth": 8
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c3a325e39c9b2a836e0923d66229433722696018",
            "date": "2025-01-14T21:02:57Z",
            "author_login": "goldvitaly"
          },
          {
            "sha": "d43eec81d0e38547f58c4621e93d3cdacbe07d35",
            "date": "2025-01-14T19:27:06Z",
            "author_login": "protobuf-github-bot"
          },
          {
            "sha": "2b35daebad8f4415eead2b3dc5ba44c6ecce386f",
            "date": "2025-01-14T19:20:40Z",
            "author_login": "protobuf-team-bot"
          },
          {
            "sha": "fad454c7846e0ffe33e656254fccf59cb39a2ee3",
            "date": "2025-01-14T19:01:44Z",
            "author_login": "protobuf-github-bot"
          },
          {
            "sha": "32838e8c2ce88f1c040f5b68c9ac4941fa97fa09",
            "date": "2025-01-14T18:28:32Z",
            "author_login": "protobuf-github-bot"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": null,
    "description": "A parsing issue similar to CVE-2022-3171, but with Message-Type Extensions in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3 can lead to a denial of service attack. Inputs containing multiple instances of non-repeated embedded messages with repeated or unknown fields causes objects to be converted back-n-forth between mutable and immutable forms, resulting in potentially long garbage collection pauses. We recommend updating to the versions mentioned above.\n\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-12-12T13:15:14.670",
    "last_modified": "2024-11-21T07:19:40.690",
    "fix_date": "2022-09-29T15:28:01Z"
  },
  "references": [
    {
      "url": "https://github.com/protocolbuffers/protobuf/commit/db7c17803320525722f45c1d26fc08bc41d1bf48",
      "source": "cve-coordination@google.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/protocolbuffers/protobuf/commit/db7c17803320525722f45c1d26fc08bc41d1bf48",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:21.222885",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "protobuf",
    "owner": "protocolbuffers",
    "created_at": "2014-08-26T15:52:15Z",
    "updated_at": "2025-01-14T15:11:04Z",
    "pushed_at": "2025-01-14T15:57:44Z",
    "size": 175767,
    "stars": 66310,
    "forks": 15572,
    "open_issues": 291,
    "watchers": 66310,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "3.0.x",
      "3.1.x",
      "3.2.x",
      "3.3.x",
      "3.5.x",
      "3.6.x",
      "3.7.x",
      "3.8.x",
      "3.9.x",
      "3.10.x",
      "3.11.x",
      "3.12.x",
      "3.13.x",
      "3.14.x",
      "3.15.x",
      "3.16.x",
      "3.17.x",
      "3.18.x",
      "3.19.x",
      "3.20.x",
      "4.0.x",
      "21.x",
      "22.x",
      "23.x"
    ],
    "languages": {
      "C++": 13080791,
      "C#": 7401673,
      "C": 4855735,
      "Java": 4527958,
      "Objective-C": 2772586,
      "Python": 1372639,
      "Starlark": 867066,
      "PHP": 516603,
      "Rust": 401045,
      "Ruby": 352464,
      "CMake": 149169,
      "Kotlin": 140283,
      "Shell": 61035,
      "NASL": 28944,
      "Lua": 27008,
      "Swift": 25869,
      "Emacs Lisp": 7886,
      "Vim Script": 3805,
      "Dart": 3076,
      "Batchfile": 2682,
      "Pawn": 1779,
      "Objective-C++": 1505,
      "PowerShell": 794,
      "Awk": 684,
      "Makefile": 580,
      "M4": 438,
      "RenderScript": 1
    },
    "commit_activity": {
      "total_commits_last_year": 3047,
      "avg_commits_per_week": 58.59615384615385,
      "days_active_last_year": 283
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T16:02:42.847810"
  }
}