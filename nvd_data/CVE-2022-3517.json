{
  "cve_id": "CVE-2022-3517",
  "github_data": {
    "repository": "isaacs/minimatch",
    "fix_commit": "a8763f4388e51956be62dc6025cec1126beeb5e6",
    "related_commits": [
      "a8763f4388e51956be62dc6025cec1126beeb5e6",
      "a8763f4388e51956be62dc6025cec1126beeb5e6"
    ],
    "patch_url": "https://github.com/isaacs/minimatch/commit/a8763f4388e51956be62dc6025cec1126beeb5e6.patch",
    "fix_commit_details": {
      "sha": "a8763f4388e51956be62dc6025cec1126beeb5e6",
      "commit_date": "2022-02-06T20:26:10Z",
      "author": {
        "login": "isaacs",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Improve redos protection, add many tests",
        "length": 90,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 8222,
        "additions": 8163,
        "deletions": 59
      },
      "files": [
        {
          "filename": "minimatch.js",
          "status": "modified",
          "additions": 74,
          "deletions": 45,
          "patch": "@@ -1,15 +1,15 @@\n module.exports = minimatch\n minimatch.Minimatch = Minimatch\n \n-var path = { sep: '/' }\n-try {\n-  path = require('path')\n-} catch (er) {}\n+const path = (() => { try { return require('path') } catch (e) {}})() || {\n+  sep: '/'\n+}\n+minimatch.sep = path.sep\n \n-var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\n-var expand = require('brace-expansion')\n+const GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\n+const expand = require('brace-expansion')\n \n-var plTypes = {\n+const plTypes = {\n   '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n   '?': { open: '(?:', close: ')?' },\n   '+': { open: '(?:', close: ')+' },\n@@ -19,22 +19,22 @@ var plTypes = {\n \n // any single thing other than /\n // don't need to escape / when using new RegExp()\n-var qmark = '[^/]'\n+const qmark = '[^/]'\n \n // * => any number of characters\n-var star = qmark + '*?'\n+const star = qmark + '*?'\n \n // ** when dots are allowed.  Anything goes, except .. and .\n // not (^ or / followed by one or two dots followed by $ or /),\n // followed by anything, any number of times.\n-var twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n+const twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n \n // not a ^ or / followed by a dot,\n // followed by anything, any number of times.\n-var twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n+const twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n \n // characters that need to be escaped in RegExp.\n-var reSpecials = charSet('().*{}+?[]^$\\\\!')\n+const reSpecials = charSet('().*{}+?[]^$\\\\!')\n \n // \"abc\" -> { a:true, b:true, c:true }\n function charSet (s) {\n@@ -45,7 +45,7 @@ function charSet (s) {\n }\n \n // normalizes slashes.\n-var slashSplit = /\\/+/\n+const slashSplit = /\\/+/\n \n minimatch.filter = filter\n function filter (pattern, options) {\n@@ -58,41 +58,63 @@ function filter (pattern, options) {\n function ext (a, b) {\n   a = a || {}\n   b = b || {}\n-  var t = {}\n-  Object.keys(b).forEach(function (k) {\n-    t[k] = b[k]\n-  })\n+  const t = {}\n   Object.keys(a).forEach(function (k) {\n     t[k] = a[k]\n   })\n+  Object.keys(b).forEach(function (k) {\n+    t[k] = b[k]\n+  })\n   return t\n }\n \n minimatch.defaults = function (def) {\n-  if (!def || !Object.keys(def).length) return minimatch\n+  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n+    return minimatch\n+  }\n \n-  var orig = minimatch\n+  const orig = minimatch\n \n-  var m = function minimatch (p, pattern, options) {\n-    return orig.minimatch(p, pattern, ext(def, options))\n+  const m = function minimatch (p, pattern, options) {\n+    return orig(p, pattern, ext(def, options))\n   }\n \n   m.Minimatch = function Minimatch (pattern, options) {\n     return new orig.Minimatch(pattern, ext(def, options))\n   }\n+  m.Minimatch.defaults = options => {\n+    return orig.defaults(ext(def, options)).Minimatch\n+  }\n+\n+  m.filter = function filter (pattern, options) {\n+    return orig.filter(pattern, ext(def, options))\n+  }\n+\n+  m.defaults = function defaults (options) {\n+    return orig.defaults(ext(def, options))\n+  }\n+\n+  m.makeRe = function makeRe (pattern, options) {\n+    return orig.makeRe(pattern, ext(def, options))\n+  }\n+\n+  m.braceExpand = function braceExpand (pattern, options) {\n+    return orig.braceExpand(pattern, ext(def, options))\n+  }\n+\n+  m.match = function (list, pattern, options) {\n+    return orig.match(list, pattern, ext(def, options))\n+  }\n \n   return m\n }\n \n Minimatch.defaults = function (def) {\n-  if (!def || !Object.keys(def).length) return Minimatch\n   return minimatch.defaults(def).Minimatch\n }\n \n function minimatch (p, pattern, options) {\n-  if (typeof pattern !== 'string') {\n-    throw new TypeError('glob pattern string required')\n-  }\n+  assertValidPattern(pattern)\n \n   if (!options) options = {}\n \n@@ -112,9 +134,7 @@ function Minimatch (pattern, options) {\n     return new Minimatch(pattern, options)\n   }\n \n-  if (typeof pattern !== 'string') {\n-    throw new TypeError('glob pattern string required')\n-  }\n+  assertValidPattern(pattern)\n \n   if (!options) options = {}\n   pattern = pattern.trim()\n@@ -242,19 +262,27 @@ function braceExpand (pattern, options) {\n   pattern = typeof pattern === 'undefined'\n     ? this.pattern : pattern\n \n-  if (typeof pattern === 'undefined') {\n-    throw new TypeError('undefined pattern')\n-  }\n+  assertValidPattern(pattern)\n \n-  if (options.nobrace ||\n-    !pattern.match(/\\{.*\\}/)) {\n+  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n     // shortcut. no need to expand.\n     return [pattern]\n   }\n \n   return expand(pattern)\n }\n \n+const MAX_PATTERN_LENGTH = 1024 * 64\n+const assertValidPattern = pattern => {\n+  if (typeof pattern !== 'string') {\n+    throw new TypeError('invalid pattern')\n+  }\n+\n+  if (pattern.length > MAX_PATTERN_LENGTH) {\n+    throw new TypeError('pattern is too long')\n+  }\n+}\n+\n // parse a component of the expanded set.\n // At this point, no pattern may contain \"/\" in it\n // so we're going to return a 2d array, where each entry is the full\n@@ -267,11 +295,9 @@ function braceExpand (pattern, options) {\n // of * is equivalent to a single *.  Globstar behavior is enabled by\n // default, and can be disabled by setting options.noglobstar.\n Minimatch.prototype.parse = parse\n-var SUBPARSE = {}\n+const SUBPARSE = {}\n function parse (pattern, isSub) {\n-  if (pattern.length > 1024 * 64) {\n-    throw new TypeError('pattern is too long')\n-  }\n+  assertValidPattern(pattern)\n \n   var options = this.options\n \n@@ -280,7 +306,7 @@ function parse (pattern, isSub) {\n   if (pattern === '') return ''\n \n   var re = ''\n-  var hasMagic = !!options.nocase\n+  var hasMagic = false\n   var escaping = false\n   // ? => one single character\n   var patternListStack = []\n@@ -332,10 +358,11 @@ function parse (pattern, isSub) {\n     }\n \n     switch (c) {\n-      case '/':\n+      case '/': /* istanbul ignore next */ {\n         // completely not allowed, even escaped.\n         // Should already be path-split by now.\n         return false\n+      }\n \n       case '\\\\':\n         clearStateChar()\n@@ -620,7 +647,7 @@ function parse (pattern, isSub) {\n   var flags = options.nocase ? 'i' : ''\n   try {\n     var regExp = new RegExp('^' + re + '$', flags)\n-  } catch (er) {\n+  } catch (er) /* istanbul ignore next - should be impossible */ {\n     // If it was an invalid regular expression, then it can't match\n     // anything.  This trick looks for a character after the end of\n     // the string, which is of course impossible, except in multi-line\n@@ -678,15 +705,15 @@ function makeRe () {\n \n   try {\n     this.regexp = new RegExp(re, flags)\n-  } catch (ex) {\n+  } catch (ex) /* istanbul ignore next - should be impossible */ {\n     this.regexp = false\n   }\n   return this.regexp\n }\n \n minimatch.match = function (list, pattern, options) {\n   options = options || {}\n-  var mm = new Minimatch(pattern, options)\n+  const mm = new Minimatch(pattern, options)\n   list = list.filter(function (f) {\n     return mm.match(f)\n   })\n@@ -779,6 +806,7 @@ Minimatch.prototype.matchOne = function (file, pattern, partial) {\n \n     // should be impossible.\n     // some invalid regexp stuff in the set.\n+    /* istanbul ignore if */\n     if (p === false) return false\n \n     if (p === GLOBSTAR) {\n@@ -852,6 +880,7 @@ Minimatch.prototype.matchOne = function (file, pattern, partial) {\n       // no match was found.\n       // However, in partial mode, we can't say this is necessarily over.\n       // If there's more *pattern* left, then\n+      /* istanbul ignore if */\n       if (partial) {\n         // ran out of file\n         this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n@@ -900,16 +929,16 @@ Minimatch.prototype.matchOne = function (file, pattern, partial) {\n     // this is ok if we're doing the match as part of\n     // a glob fs traversal.\n     return partial\n-  } else if (pi === pl) {\n+  } else /* istanbul ignore else */ if (pi === pl) {\n     // ran out of pattern, still have file left.\n     // this is only acceptable if we're on the very last\n     // empty segment of a file with a trailing slash.\n     // a/* should match a/b/\n-    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n-    return emptyFileEnd\n+    return (fi === fl - 1) && (file[fi] === '')\n   }\n \n   // should be unreachable.\n+  /* istanbul ignore next */\n   throw new Error('wtf?')\n }\n "
        },
        {
          "filename": "package-lock.json",
          "status": "modified",
          "additions": 7984,
          "deletions": 1,
          "patch": null
        },
        {
          "filename": "package.json",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -9,7 +9,7 @@\n   },\n   \"main\": \"minimatch.js\",\n   \"scripts\": {\n-    \"test\": \"tap test/*.js --cov\",\n+    \"test\": \"tap\",\n     \"preversion\": \"npm test\",\n     \"postversion\": \"npm publish\",\n     \"postpublish\": \"git push origin --all; git push origin --tags\"\n@@ -21,7 +21,7 @@\n     \"brace-expansion\": \"^1.1.7\"\n   },\n   \"devDependencies\": {\n-    \"tap\": \"^10.3.2\"\n+    \"tap\": \"^15.1.6\"\n   },\n   \"license\": \"ISC\",\n   \"files\": ["
        },
        {
          "filename": "test/basic.js",
          "status": "modified",
          "additions": 54,
          "deletions": 5,
          "patch": "@@ -27,10 +27,16 @@ tap.test('basic tests', function (t) {\n     // options.debug = true\n     var m = new mm.Minimatch(pattern, options)\n     var r = m.makeRe()\n+    var r2 = mm.makeRe(pattern, options)\n+    t.equal(String(r), String(r2), 'same results from both makeRe fns')\n     var expectRe = regexps[re++]\n-    expectRe = '/' + expectRe.slice(1, -1).replace(new RegExp('([^\\\\\\\\])/', 'g'), '$1\\\\\\/') + '/'\n-    tapOpts.re = String(r) || JSON.stringify(r)\n-    tapOpts.re = '/' + tapOpts.re.slice(1, -1).replace(new RegExp('([^\\\\\\\\])/', 'g'), '$1\\\\\\/') + '/'\n+    if (expectRe !== false) {\n+      expectRe = '/' + expectRe.slice(1, -1).replace(new RegExp('([^\\\\\\\\])/', 'g'), '$1\\\\\\/') + '/'\n+      tapOpts.re = String(r) || JSON.stringify(r)\n+      tapOpts.re = '/' + tapOpts.re.slice(1, -1).replace(new RegExp('([^\\\\\\\\])/', 'g'), '$1\\\\\\/') + '/'\n+    } else {\n+      tapOpts.re = r\n+    }\n     tapOpts.files = JSON.stringify(f)\n     tapOpts.pattern = pattern\n     tapOpts.set = m.set\n@@ -39,7 +45,7 @@ tap.test('basic tests', function (t) {\n     var actual = mm.match(f, pattern, options)\n     actual.sort(alpha)\n \n-    t.equivalent(\n+    t.same(\n       actual, expect,\n       JSON.stringify(pattern) + ' ' + JSON.stringify(expect),\n       tapOpts\n@@ -56,10 +62,53 @@ tap.test('global leak test', function (t) {\n   var globalAfter = Object.keys(global).filter(function (k) {\n     return (k !== '__coverage__' && k !== '__core-js_shared__')\n   })\n-  t.equivalent(globalAfter, globalBefore, 'no new globals, please')\n+  t.same(globalAfter, globalBefore, 'no new globals, please')\n   t.end()\n })\n \n+tap.test('invalid patterns', t => {\n+  const toolong = 'x'.repeat(64 * 1024) + 'y'\n+  const expectTooLong = { message: 'pattern is too long' }\n+  t.throws(() => mm.braceExpand(toolong), expectTooLong)\n+  t.throws(() => new mm.Minimatch(toolong), expectTooLong)\n+  t.throws(() => mm('xy', toolong), expectTooLong)\n+  t.throws(() => mm.match(['xy'], toolong), expectTooLong)\n+\n+  const invalid = { message: 'invalid pattern' }\n+  const invalids = [\n+    null,\n+    1234,\n+    NaN,\n+    Infinity,\n+    undefined,\n+    {a: 1},\n+    true,\n+    false,\n+  ]\n+  for (const i of invalids) {\n+    t.throws(() => mm.braceExpand(i), invalid)\n+    t.throws(() => new mm.Minimatch(i), invalid)\n+    t.throws(() => mm('xy', i), invalid)\n+    t.throws(() => mm.match(['xy'], i), invalid)\n+  }\n+\n+  t.end()\n+})\n+\n+tap.test('ctor is generator', t => {\n+  const m = mm.Minimatch('asdf')\n+  t.type(m, mm.Minimatch)\n+  t.equal(m.pattern, 'asdf')\n+  t.end()\n+})\n+\n+tap.test('nocomment matches nothing', t => {\n+  t.equal(mm('#comment', '#comment', { nocomment: false }), false)\n+  t.equal(mm('#comment', '#comment', { nocomment: true }), true)\n+  t.end()\n+})\n+\n+\n function alpha (a, b) {\n   return a > b ? 1 : -1\n }"
        },
        {
          "filename": "test/brace-expand.js",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -66,7 +66,7 @@ tap.test('brace expansion', function (t) {\n   patterns.forEach(function (tc) {\n     var p = tc[0],\n       expect = tc[1]\n-    t.equivalent(minimatch.braceExpand(p), expect, p)\n+    t.same(minimatch.braceExpand(p), expect, p)\n   })\n   t.end()\n })"
        },
        {
          "filename": "test/defaults.js",
          "status": "modified",
          "additions": 33,
          "deletions": 2,
          "patch": "@@ -36,7 +36,7 @@ tap.test('basic tests', function (t) {\n     var actual = mm.match(f, pattern, options)\n     actual.sort(alpha)\n \n-    t.equivalent(\n+    t.same(\n       actual,\n       expect,\n       JSON.stringify(pattern) + ' ' + JSON.stringify(expect),\n@@ -52,7 +52,38 @@ tap.test('global leak test', function (t) {\n   var globalAfter = Object.keys(global).filter(function (k) {\n     return (k !== '__coverage__')\n   })\n-  t.equivalent(globalAfter, globalBefore, 'no new globals, please')\n+  t.same(globalAfter, globalBefore, 'no new globals, please')\n+  t.end()\n+})\n+\n+tap.test('empty defaults obj returns original ctor', t => {\n+  for (const empty of [{}, undefined, null, false, 1234, 'xyz']) {\n+    const defmm = mm.defaults({})\n+    t.equal(defmm, mm)\n+    const Class = mm.Minimatch.defaults({})\n+    t.equal(Class, mm.Minimatch)\n+  }\n+  t.end()\n+})\n+\n+tap.test('call defaults mm function', t => {\n+  const defmm = mm.defaults({ nocomment: true })\n+  t.equal(mm('# nocomment', '# nocomment'), false)\n+  t.equal(defmm('# nocomment', '# nocomment'), true)\n+  t.equal(defmm('# nocomment', '# nocomment', { nocomment: false }), false)\n+  const undef = defmm.defaults({ nocomment: false })\n+  t.equal(undef('# nocomment', '# nocomment'), false)\n+  const unm = new undef.Minimatch('asdf')\n+  t.same(unm.options, { nocomment: false })\n+  const UndefClass = defmm.Minimatch.defaults({ nocomment: false })\n+  const unmm = new UndefClass('asfd')\n+  t.same(unmm.options, { nocomment: false })\n+\n+  const f = defmm.filter('#nc')\n+  t.same(['x','#nc', 'y'].filter(f), ['#nc'])\n+  t.same(defmm.match(['x','#nc', 'y'], '#nc'), ['#nc'])\n+  t.same(defmm.braceExpand('# {a,b}'), ['# a', '# b'])\n+  t.same(defmm.makeRe('# {a,b}'), /^(?:\\#\\ a|\\#\\ b)$/)\n   t.end()\n })\n "
        },
        {
          "filename": "test/no-path-module.js",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+const t = require('tap')\n+const mm = t.mock('../', { path: null })\n+t.equal(mm.sep, '/')"
        },
        {
          "filename": "test/patterns.js",
          "status": "modified",
          "additions": 7,
          "deletions": 3,
          "patch": "@@ -259,7 +259,10 @@ module.exports = [\n   'https://github.com/isaacs/minimatch/issues/59',\n   ['[z-a]', []],\n   ['a/[2015-03-10T00:23:08.647Z]/z', []],\n-  ['[a-0][a-\\u0100]', []]\n+  ['[a-0][a-\\u0100]', []],\n+\n+  'comments match nothing',\n+  ['# ignore this', []],\n ]\n \n module.exports.regexps = [\n@@ -327,7 +330,7 @@ module.exports.regexps = [\n   '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?)$/',\n   '/^(?:\\\\[\\\\])$/',\n   '/^(?:\\\\[abc)$/',\n-  '/^(?:(?=.)XYZ)$/i',\n+  '/^(?:XYZ)$/i',\n   '/^(?:(?=.)ab[^/]*?)$/i',\n   '/^(?:(?!\\\\.)(?=.)[ia][^/][ck])$/i',\n   '/^(?:\\\\/(?!\\\\.)(?=.)[^/]*?|(?!\\\\.)(?=.)[^/]*?)$/',\n@@ -358,7 +361,8 @@ module.exports.regexps = [\n   '/^(?:(?:(?!(?:\\\\/|^)\\\\.).)*?\\\\/\\\\.x\\\\/(?:(?!(?:\\\\/|^)\\\\.).)*?)$/',\n   '/^(?:\\\\[z\\\\-a\\\\])$/',\n   '/^(?:a\\\\/\\\\[2015\\\\-03\\\\-10T00:23:08\\\\.647Z\\\\]\\\\/z)$/',\n-  '/^(?:(?=.)\\\\[a-0\\\\][a-\u0100])$/'\n+  '/^(?:(?=.)\\\\[a-0\\\\][a-\u0100])$/',\n+  false,\n ]\n \n Object.defineProperty(module.exports, 'files', {"
        },
        {
          "filename": "test/win-path-sep.js",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+const t = require('tap')\n+const mm = t.mock('../', { path: { sep: '\\\\' }})\n+\n+t.equal(mm('x\\\\y\\\\z', 'x/y/*/z'), false)\n+t.equal(mm('x\\\\y\\\\w\\\\z', 'x/y/*/z'), true)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 2,
        "dependency_files": 1,
        "test_files": 6,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "0569cd3373408f9d701d3aab187b3f43a24a0db7",
            "date": "2024-07-08T23:02:08Z",
            "author_login": "isaacs"
          },
          {
            "sha": "17d31c75ee4a6c4e516b6610647274285dc493c7",
            "date": "2024-07-08T23:02:00Z",
            "author_login": "isaacs"
          },
          {
            "sha": "346685ced5203464bb10fd3d4dfa6964f6102ede",
            "date": "2024-07-08T21:51:21Z",
            "author_login": "isaacs"
          },
          {
            "sha": "632e0da294b644ce2b537df4d64d4316fd84e0f1",
            "date": "2024-07-08T21:51:12Z",
            "author_login": "isaacs"
          },
          {
            "sha": "0de7f45232cad5e3e49e4eb7cd9b6e124ed04b84",
            "date": "2024-06-25T22:40:45Z",
            "author_login": "isaacs"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "A vulnerability was found in the minimatch package. This flaw allows a Regular Expression Denial of Service (ReDoS) when calling the braceExpand function with specific arguments, resulting in a Denial of Service.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-10-17T20:15:09.937",
    "last_modified": "2024-11-21T07:19:41.573",
    "fix_date": "2022-02-06T20:26:10Z"
  },
  "references": [
    {
      "url": "https://github.com/grafana/grafana-image-renderer/issues/329",
      "source": "secalert@redhat.com",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/isaacs/minimatch/commit/a8763f4388e51956be62dc6025cec1126beeb5e6",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2023/01/msg00011.html",
      "source": "secalert@redhat.com",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/MTEUUTNIEBHGKUKKLNUZSV7IEP6IP3Q3/",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UM6XJ73Q3NAM5KSGCOKJ2ZIA6GUWUJLK/",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://github.com/grafana/grafana-image-renderer/issues/329",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/isaacs/minimatch/commit/a8763f4388e51956be62dc6025cec1126beeb5e6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2023/01/msg00011.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/MTEUUTNIEBHGKUKKLNUZSV7IEP6IP3Q3/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UM6XJ73Q3NAM5KSGCOKJ2ZIA6GUWUJLK/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:41.349562",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "minimatch",
    "owner": "isaacs",
    "created_at": "2011-07-16T02:45:46Z",
    "updated_at": "2025-01-14T01:00:45Z",
    "pushed_at": "2024-07-08T23:02:12Z",
    "size": 931,
    "stars": 3324,
    "forks": 247,
    "open_issues": 8,
    "watchers": 3324,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "JavaScript": 407483,
      "TypeScript": 71458
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "isc"
    },
    "collected_at": "2025-01-14T18:06:42.765065"
  }
}