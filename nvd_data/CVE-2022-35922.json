{
  "cve_id": "CVE-2022-35922",
  "github_data": {
    "repository": "websockets-rs/rust-websocket",
    "fix_commit": "cbf6e9983e839d2ecad86de8cd1b3f20ed43390b",
    "related_commits": [
      "cbf6e9983e839d2ecad86de8cd1b3f20ed43390b",
      "cbf6e9983e839d2ecad86de8cd1b3f20ed43390b"
    ],
    "patch_url": "https://github.com/websockets-rs/rust-websocket/commit/cbf6e9983e839d2ecad86de8cd1b3f20ed43390b.patch",
    "fix_commit_details": {
      "sha": "cbf6e9983e839d2ecad86de8cd1b3f20ed43390b",
      "commit_date": "2022-07-23T23:50:07Z",
      "author": {
        "login": "vi",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Implement dataframe and message size limits",
        "length": 43,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 64,
        "additions": 62,
        "deletions": 2
      },
      "files": [
        {
          "filename": "src/receiver.rs",
          "status": "modified",
          "additions": 43,
          "deletions": 2,
          "patch": "@@ -14,6 +14,10 @@ use crate::ws;\n use crate::ws::receiver::Receiver as ReceiverTrait;\n use crate::ws::receiver::{DataFrameIterator, MessageIterator};\n \n+const DEFAULT_MAX_DATAFRAME_SIZE : usize = 1024*1024*100;\n+const DEFAULT_MAX_MESSAGE_SIZE : usize = 1024*1024*200;\n+const MAX_DATAFRAMES_IN_ONE_MESSAGE: usize = 1024*1024;\n+\n /// This reader bundles an existing stream with a parsing algorithm.\n /// It is used by the client in its `.split()` function as the reading component.\n pub struct Reader<R>\n@@ -74,14 +78,33 @@ where\n pub struct Receiver {\n \tbuffer: Vec<DataFrame>,\n \tmask: bool,\n+\t// u32s instead uf usizes to economize used memory by this struct\n+\tmax_dataframe_size: u32,\n+\tmax_message_size: u32,\n }\n \n impl Receiver {\n \t/// Create a new Receiver using the specified Reader.\n+\t/// \n+\t/// Uses built-in limits for dataframe and message sizes. \n \tpub fn new(mask: bool) -> Receiver {\n+\t\tReceiver::new_with_limits(mask, DEFAULT_MAX_DATAFRAME_SIZE, DEFAULT_MAX_MESSAGE_SIZE)\n+\t}\n+\n+\t/// Create a new Receiver using the specified Reader, with configurable limits\n+\t/// \n+\t/// Sizes should not be larger than `u32::MAX`.\n+\t/// \n+\t/// Note that `max_message_size` denotes message size where no new dataframes would be read,\n+\t/// so actual maximum message size is larger.\n+\tpub fn new_with_limits(mask: bool, max_dataframe_size: usize, max_message_size: usize) -> Receiver {\n+\t\tlet max_dataframe_size: u32 = max_dataframe_size.min(u32::MAX as usize) as u32;\n+\t\tlet max_message_size: u32 = max_message_size.min(u32::MAX as usize) as u32;\n \t\tReceiver {\n \t\t\tbuffer: Vec::new(),\n \t\t\tmask,\n+\t\t\tmax_dataframe_size,\n+\t\t\tmax_message_size,\n \t\t}\n \t}\n }\n@@ -96,14 +119,15 @@ impl ws::Receiver for Receiver {\n \twhere\n \t\tR: Read,\n \t{\n-\t\tDataFrame::read_dataframe(reader, self.mask)\n+\t\tDataFrame::read_dataframe_with_limit(reader, self.mask, self.max_dataframe_size as usize)\n \t}\n \n \t/// Returns the data frames that constitute one message.\n \tfn recv_message_dataframes<R>(&mut self, reader: &mut R) -> WebSocketResult<Vec<DataFrame>>\n \twhere\n \t\tR: Read,\n \t{\n+\t\tlet mut current_message_length : usize = self.buffer.iter().map(|x|x.data.len()).sum();\n \t\tlet mut finished = if self.buffer.is_empty() {\n \t\t\tlet first = self.recv_dataframe(reader)?;\n \n@@ -114,6 +138,7 @@ impl ws::Receiver for Receiver {\n \t\t\t}\n \n \t\t\tlet finished = first.finished;\n+\t\t\tcurrent_message_length += first.data.len();\n \t\t\tself.buffer.push(first);\n \t\t\tfinished\n \t\t} else {\n@@ -126,7 +151,10 @@ impl ws::Receiver for Receiver {\n \n \t\t\tmatch next.opcode as u8 {\n \t\t\t\t// Continuation opcode\n-\t\t\t\t0 => self.buffer.push(next),\n+\t\t\t\t0 => {\n+\t\t\t\t\tcurrent_message_length += next.data.len();\n+\t\t\t\t\tself.buffer.push(next)\n+\t\t\t\t}\n \t\t\t\t// Control frame\n \t\t\t\t8..=15 => {\n \t\t\t\t\treturn Ok(vec![next]);\n@@ -138,6 +166,19 @@ impl ws::Receiver for Receiver {\n \t\t\t\t\t));\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tif !finished {\n+\t\t\t\tif self.buffer.len() >= MAX_DATAFRAMES_IN_ONE_MESSAGE {\n+\t\t\t\t\treturn Err(WebSocketError::ProtocolError(\n+\t\t\t\t\t\t\"Exceeded count of data frames in one WebSocket message\",\n+\t\t\t\t\t));\n+\t\t\t\t}\n+\t\t\t\tif current_message_length >= self.max_message_size as usize {\n+\t\t\t\t\treturn Err(WebSocketError::ProtocolError(\n+\t\t\t\t\t\t\"Exceeded maximum WebSocket message size\",\n+\t\t\t\t\t));\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \n \t\tOk(::std::mem::replace(&mut self.buffer, Vec::new()))"
        },
        {
          "filename": "websocket-base/src/dataframe.rs",
          "status": "modified",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -96,6 +96,25 @@ impl DataFrame {\n \n \t\tDataFrame::read_dataframe_body(header, data, should_be_masked)\n \t}\n+\n+\t/// Reads a DataFrame from a Reader, or error out if header declares exceeding limit you specify\n+\tpub fn read_dataframe_with_limit<R>(reader: &mut R, should_be_masked: bool, limit: usize) -> WebSocketResult<Self>\n+\twhere\n+\t\tR: Read,\n+\t{\n+\t\tlet header = dfh::read_header(reader)?;\n+\n+\t\tif header.len > limit as u64 {\n+\t\t\treturn Err(io::Error::new(io::ErrorKind::InvalidData, \"exceeded DataFrame length limit\").into());\n+\t\t}\n+\t\tlet mut data: Vec<u8> = Vec::with_capacity(header.len as usize);\n+\t\tlet read = reader.take(header.len).read_to_end(&mut data)?;\n+\t\tif (read as u64) < header.len {\n+\t\t\treturn Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"incomplete payload\").into());\n+\t\t}\n+\n+\t\tDataFrame::read_dataframe_body(header, data, should_be_masked)\n+\t}\n }\n \n impl DataFrameable for DataFrame {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2bbeca93954298aac87adbdff958ff9cfa9a4af2",
            "date": "2023-09-17T12:49:06Z",
            "author_login": "vi"
          },
          {
            "sha": "2245bee923cd27db539b9c2e2a2bc65ea42baf7e",
            "date": "2023-07-27T18:52:55Z",
            "author_login": "vi"
          },
          {
            "sha": "a232c749f066ba6a5ab5f6995d802e42f04d8adf",
            "date": "2023-07-27T15:39:36Z",
            "author_login": "dearlordylord"
          },
          {
            "sha": "74c82be3de282e1c4c35c51daac1a84b583ce8ea",
            "date": "2022-07-24T15:05:30Z",
            "author_login": "vi"
          },
          {
            "sha": "3bde0f409b346d204070d26ddc2ca273ac5c73a2",
            "date": "2022-07-24T13:21:04Z",
            "author_login": "vi"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "Rust-WebSocket is a WebSocket (RFC6455) library written in Rust. In versions prior to 0.26.5 untrusted websocket connections can cause an out-of-memory (OOM) process abort in a client or a server. The root cause of the issue is during dataframe parsing. Affected versions would allocate a buffer based on the declared dataframe size, which may come from an untrusted source. When `Vec::with_capacity` fails to allocate, the default Rust allocator will abort the current process, killing all threads. This affects only sync (non-Tokio) implementation. Async version also does not limit memory, but does not use `with_capacity`, so DoS can happen only when bytes for oversized dataframe or message actually got delivered by the attacker. The crashes are fixed in version 0.26.5 by imposing default dataframe size limits. Affected users are advised to update to this version. Users unable to upgrade are advised to filter websocket traffic externally or to only accept trusted traffic.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-08-01T22:15:10.460",
    "last_modified": "2024-11-21T07:11:58.143",
    "fix_date": "2022-07-23T23:50:07Z"
  },
  "references": [
    {
      "url": "https://github.com/websockets-rs/rust-websocket/commit/cbf6e9983e839d2ecad86de8cd1b3f20ed43390b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/websockets-rs/rust-websocket/security/advisories/GHSA-qrjv-rf5q-qpxc",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4V2EOOU5OLEHVMKAH6BALQXKDKIZRXCI/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HYPNCM4H4OFBIZI6XMJ2DUTS54FT2TWP/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/websockets-rs/rust-websocket/commit/cbf6e9983e839d2ecad86de8cd1b3f20ed43390b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/websockets-rs/rust-websocket/security/advisories/GHSA-qrjv-rf5q-qpxc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4V2EOOU5OLEHVMKAH6BALQXKDKIZRXCI/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HYPNCM4H4OFBIZI6XMJ2DUTS54FT2TWP/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:14.190687",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "rust-websocket",
    "owner": "websockets-rs",
    "created_at": "2014-11-27T06:49:59Z",
    "updated_at": "2025-01-08T14:10:55Z",
    "pushed_at": "2023-09-17T12:52:17Z",
    "size": 22471,
    "stars": 1561,
    "forks": 225,
    "open_issues": 45,
    "watchers": 1561,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Rust": 208704,
      "Shell": 3360
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T15:54:24.135814"
  }
}