{
  "cve_id": "CVE-2022-35949",
  "github_data": {
    "repository": "nodejs/undici",
    "fix_commit": "124f7ebf705366b2e1844dff721928d270f87895",
    "related_commits": [
      "124f7ebf705366b2e1844dff721928d270f87895",
      "124f7ebf705366b2e1844dff721928d270f87895"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "124f7ebf705366b2e1844dff721928d270f87895",
      "commit_date": "2022-08-09T09:29:11Z",
      "author": {
        "login": "RafaelGSS",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-8qr4-xgw6-wmr3",
        "length": 43,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 175,
        "additions": 171,
        "deletions": 4
      },
      "files": [
        {
          "filename": "index.js",
          "status": "modified",
          "additions": 6,
          "deletions": 1,
          "patch": "@@ -53,7 +53,12 @@ function makeDispatcher (fn) {\n         throw new InvalidArgumentError('invalid opts.path')\n       }\n \n-      url = new URL(opts.path, util.parseOrigin(url))\n+      let path = opts.path\n+      if (!opts.path.startsWith('/')) {\n+        path = `/${path}`\n+      }\n+\n+      url = new URL(util.parseOrigin(url).origin + path)\n     } else {\n       if (!opts) {\n         opts = typeof url === 'object' ? url : {}"
        },
        {
          "filename": "lib/core/util.js",
          "status": "modified",
          "additions": 14,
          "deletions": 3,
          "patch": "@@ -108,14 +108,25 @@ function parseURL (url) {\n     const port = url.port != null\n       ? url.port\n       : (url.protocol === 'https:' ? 443 : 80)\n-    const origin = url.origin != null\n+    let origin = url.origin != null\n       ? url.origin\n       : `${url.protocol}//${url.hostname}:${port}`\n-    const path = url.path != null\n+    let path = url.path != null\n       ? url.path\n       : `${url.pathname || ''}${url.search || ''}`\n \n-    url = new URL(path, origin)\n+    if (origin.endsWith('/')) {\n+      origin = origin.substring(0, origin.length - 1)\n+    }\n+\n+    if (path && !path.startsWith('/')) {\n+      path = `/${path}`\n+    }\n+    // new URL(path, origin) is unsafe when `path` contains an absolute URL\n+    // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:\n+    // If first parameter is a relative URL, second param is required, and will be used as the base URL.\n+    // If first parameter is an absolute URL, a given second param will be ignored.\n+    url = new URL(origin + path)\n   }\n \n   return url"
        },
        {
          "filename": "test/request.js",
          "status": "added",
          "additions": 151,
          "deletions": 0,
          "patch": "@@ -0,0 +1,151 @@\n+'use strict'\n+\n+const { createServer } = require('http')\n+const { test } = require('tap')\n+const { request } = require('..')\n+\n+test('no-slash/one-slash pathname should be included in req.path', async (t) => {\n+  const pathServer = createServer((req, res) => {\n+    t.fail('it shouldn\\'t be called')\n+    res.statusCode = 200\n+    res.end('hello')\n+  })\n+\n+  const requestedServer = createServer((req, res) => {\n+    t.equal(`/localhost:${pathServer.address().port}`, req.url)\n+    t.equal('GET', req.method)\n+    t.equal(`localhost:${requestedServer.address().port}`, req.headers.host)\n+    res.statusCode = 200\n+    res.end('hello')\n+  })\n+\n+  t.teardown(requestedServer.close.bind(requestedServer))\n+  t.teardown(pathServer.close.bind(pathServer))\n+\n+  await Promise.all([\n+    requestedServer.listen(0),\n+    pathServer.listen(0)\n+  ])\n+\n+  const noSlashPathname = await request({\n+    method: 'GET',\n+    origin: `http://localhost:${requestedServer.address().port}`,\n+    pathname: `localhost:${pathServer.address().port}`\n+  })\n+  t.equal(noSlashPathname.statusCode, 200)\n+  const noSlashPath = await request({\n+    method: 'GET',\n+    origin: `http://localhost:${requestedServer.address().port}`,\n+    path: `localhost:${pathServer.address().port}`\n+  })\n+  t.equal(noSlashPath.statusCode, 200)\n+  const noSlashPath2Arg = await request(\n+    `http://localhost:${requestedServer.address().port}`,\n+    { path: `localhost:${pathServer.address().port}` }\n+  )\n+  t.equal(noSlashPath2Arg.statusCode, 200)\n+  const oneSlashPathname = await request({\n+    method: 'GET',\n+    origin: `http://localhost:${requestedServer.address().port}`,\n+    pathname: `/localhost:${pathServer.address().port}`\n+  })\n+  t.equal(oneSlashPathname.statusCode, 200)\n+  const oneSlashPath = await request({\n+    method: 'GET',\n+    origin: `http://localhost:${requestedServer.address().port}`,\n+    path: `/localhost:${pathServer.address().port}`\n+  })\n+  t.equal(oneSlashPath.statusCode, 200)\n+  const oneSlashPath2Arg = await request(\n+    `http://localhost:${requestedServer.address().port}`,\n+    { path: `/localhost:${pathServer.address().port}` }\n+  )\n+  t.equal(oneSlashPath2Arg.statusCode, 200)\n+  t.end()\n+})\n+\n+test('protocol-relative URL as pathname should be included in req.path', async (t) => {\n+  const pathServer = createServer((req, res) => {\n+    t.fail('it shouldn\\'t be called')\n+    res.statusCode = 200\n+    res.end('hello')\n+  })\n+\n+  const requestedServer = createServer((req, res) => {\n+    t.equal(`//localhost:${pathServer.address().port}`, req.url)\n+    t.equal('GET', req.method)\n+    t.equal(`localhost:${requestedServer.address().port}`, req.headers.host)\n+    res.statusCode = 200\n+    res.end('hello')\n+  })\n+\n+  t.teardown(requestedServer.close.bind(requestedServer))\n+  t.teardown(pathServer.close.bind(pathServer))\n+\n+  await Promise.all([\n+    requestedServer.listen(0),\n+    pathServer.listen(0)\n+  ])\n+\n+  const noSlashPathname = await request({\n+    method: 'GET',\n+    origin: `http://localhost:${requestedServer.address().port}`,\n+    pathname: `//localhost:${pathServer.address().port}`\n+  })\n+  t.equal(noSlashPathname.statusCode, 200)\n+  const noSlashPath = await request({\n+    method: 'GET',\n+    origin: `http://localhost:${requestedServer.address().port}`,\n+    path: `//localhost:${pathServer.address().port}`\n+  })\n+  t.equal(noSlashPath.statusCode, 200)\n+  const noSlashPath2Arg = await request(\n+    `http://localhost:${requestedServer.address().port}`,\n+    { path: `//localhost:${pathServer.address().port}` }\n+  )\n+  t.equal(noSlashPath2Arg.statusCode, 200)\n+  t.end()\n+})\n+\n+test('Absolute URL as pathname should be included in req.path', async (t) => {\n+  const pathServer = createServer((req, res) => {\n+    t.fail('it shouldn\\'t be called')\n+    res.statusCode = 200\n+    res.end('hello')\n+  })\n+\n+  const requestedServer = createServer((req, res) => {\n+    t.equal(`/http://localhost:${pathServer.address().port}`, req.url)\n+    t.equal('GET', req.method)\n+    t.equal(`localhost:${requestedServer.address().port}`, req.headers.host)\n+    res.statusCode = 200\n+    res.end('hello')\n+  })\n+\n+  t.teardown(requestedServer.close.bind(requestedServer))\n+  t.teardown(pathServer.close.bind(pathServer))\n+\n+  await Promise.all([\n+    requestedServer.listen(0),\n+    pathServer.listen(0)\n+  ])\n+\n+  const noSlashPathname = await request({\n+    method: 'GET',\n+    origin: `http://localhost:${requestedServer.address().port}`,\n+    pathname: `http://localhost:${pathServer.address().port}`\n+  })\n+  t.equal(noSlashPathname.statusCode, 200)\n+  const noSlashPath = await request({\n+    method: 'GET',\n+    origin: `http://localhost:${requestedServer.address().port}`,\n+    path: `http://localhost:${pathServer.address().port}`\n+  })\n+  t.equal(noSlashPath.statusCode, 200)\n+  const noSlashPath2Arg = await request(\n+    `http://localhost:${requestedServer.address().port}`,\n+    { path: `http://localhost:${pathServer.address().port}` }\n+  )\n+  t.equal(noSlashPath2Arg.statusCode, 200)\n+  t.end()\n+})"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "5e234ac4e0314b0f067d25a9cba5d6c5c29c2370",
            "date": "2025-01-24T15:50:36Z",
            "author_login": "zuozp8"
          },
          {
            "sha": "af0eee28c00dd0e0cf001e3db5d2e000106c74b8",
            "date": "2025-01-23T08:59:57Z",
            "author_login": "github-actions[bot]"
          },
          {
            "sha": "f0ffe1ff116a660c43119e6cc3e93217745fbf92",
            "date": "2025-01-23T08:59:35Z",
            "author_login": "github-actions[bot]"
          },
          {
            "sha": "4d75e12a5e32af0c0311b0f4227954b5fa44a184",
            "date": "2025-01-23T08:47:49Z",
            "author_login": "mcollina"
          },
          {
            "sha": "35f5d45eb1d0f9836a842e4d0afbbb9ca2157b16",
            "date": "2025-01-22T21:30:26Z",
            "author_login": "Uzlopak"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-918",
    "description": "undici is an HTTP/1.1 client, written from scratch for Node.js.`undici` is vulnerable to SSRF (Server-side Request Forgery) when an application takes in **user input** into the `path/pathname` option of `undici.request`. If a user specifies a URL such as `http://127.0.0.1` or `//127.0.0.1` ```js const undici = require(\"undici\") undici.request({origin: \"http://example.com\", pathname: \"//127.0.0.1\"}) ``` Instead of processing the request as `http://example.org//127.0.0.1` (or `http://example.org/http://127.0.0.1` when `http://127.0.0.1 is used`), it actually processes the request as `http://127.0.0.1/` and sends it to `http://127.0.0.1`. If a developer passes in user input into `path` parameter of `undici.request`, it can result in an _SSRF_ as they will assume that the hostname cannot change, when in actual fact it can change because the specified path parameter is combined with the base URL. This issue was fixed in `undici@5.8.1`. The best workaround is to validate user input before passing it to the `undici.request` call.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-08-12T23:15:07.970",
    "last_modified": "2024-11-21T07:12:01.970",
    "fix_date": "2022-08-09T09:29:11Z"
  },
  "references": [
    {
      "url": "https://github.com/nodejs/undici/commit/124f7ebf705366b2e1844dff721928d270f87895",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/nodejs/undici/releases/tag/v5.8.2",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/nodejs/undici/security/advisories/GHSA-8qr4-xgw6-wmr3",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/nodejs/undici/commit/124f7ebf705366b2e1844dff721928d270f87895",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/nodejs/undici/releases/tag/v5.8.2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/nodejs/undici/security/advisories/GHSA-8qr4-xgw6-wmr3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Mitigation",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:14.216939",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "undici",
    "owner": "nodejs",
    "created_at": "2018-05-11T22:07:48Z",
    "updated_at": "2025-01-26T05:49:32Z",
    "pushed_at": "2025-01-25T00:16:54Z",
    "size": 11836,
    "stars": 6530,
    "forks": 578,
    "open_issues": 240,
    "watchers": 6530,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "JavaScript": 2464768,
      "TypeScript": 82943,
      "Shell": 170
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T07:55:29.117412"
  }
}