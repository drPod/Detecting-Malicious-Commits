{
  "cve_id": "CVE-2022-35964",
  "github_data": {
    "repository": "tensorflow/tensorflow",
    "fix_commit": "2a458fc4866505be27c62f81474ecb2b870498fa",
    "related_commits": [
      "2a458fc4866505be27c62f81474ecb2b870498fa",
      "2a458fc4866505be27c62f81474ecb2b870498fa"
    ],
    "patch_url": "https://github.com/tensorflow/tensorflow/commit/2a458fc4866505be27c62f81474ecb2b870498fa.patch",
    "fix_commit_details": {
      "sha": "2a458fc4866505be27c62f81474ecb2b870498fa",
      "commit_date": "2022-07-24T05:06:18Z",
      "author": {
        "login": "cantonios",
        "type": "User",
        "stats": {
          "total_commits": 299,
          "average_weekly_commits": 0.6229166666666667,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 96
        }
      },
      "commit_message": {
        "title": "Add size input validation to BlockLSTMGradV2.",
        "length": 214,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 77,
        "additions": 76,
        "deletions": 1
      },
      "files": [
        {
          "filename": "tensorflow/core/kernels/rnn/lstm_ops.cc",
          "status": "modified",
          "additions": 24,
          "deletions": 1,
          "patch": "@@ -1138,19 +1138,30 @@ class BlockLSTMGradOp : public OpKernel {\n \n     const Tensor* x;\n     OP_REQUIRES_OK(ctx, ctx->input(\"x\", &x));\n-    OP_REQUIRES(ctx, x->dims() == 3, errors::InvalidArgument(\"x must be 3D\"));\n+    OP_REQUIRES(\n+        ctx, x->dims() == 3,\n+        errors::InvalidArgument(\"x must be rank 3 but is rank \", x->dims()));\n     const int64_t timelen = x->dim_size(0);\n     const int64_t batch_size = x->dim_size(1);\n     const int64_t input_size = x->dim_size(2);\n \n     const Tensor* cs_prev_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->input(\"cs_prev\", &cs_prev_tensor));\n+    OP_REQUIRES(ctx, cs_prev_tensor->dims() == 2,\n+                errors::InvalidArgument(\"cs_prev must be rank 2 but is rank \",\n+                                        cs_prev_tensor->dims()));\n \n     const Tensor* h_prev_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->input(\"h_prev\", &h_prev_tensor));\n+    OP_REQUIRES(ctx, h_prev_tensor->dims() == 2,\n+                errors::InvalidArgument(\"h_prev must be rank 2 but is rank \",\n+                                        h_prev_tensor->dims()));\n \n     const Tensor* w_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->input(\"w\", &w_tensor));\n+    OP_REQUIRES(ctx, w_tensor->dims() == 2,\n+                errors::InvalidArgument(\"w must be rank 2 but is rank \",\n+                                        w_tensor->dims()));\n     const int64_t cell_size = w_tensor->dim_size(1) / 4;\n     OP_REQUIRES(ctx, input_size + cell_size == w_tensor->dim_size(0),\n                 errors::InvalidArgument(\n@@ -1159,15 +1170,27 @@ class BlockLSTMGradOp : public OpKernel {\n \n     const Tensor* wci_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->input(\"wci\", &wci_tensor));\n+    OP_REQUIRES(ctx, wci_tensor->dims() == 1,\n+                errors::InvalidArgument(\"wci must be rank 1 but is rank \",\n+                                        wci_tensor->dims()));\n \n     const Tensor* wcf_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->input(\"wcf\", &wcf_tensor));\n+    OP_REQUIRES(ctx, wcf_tensor->dims() == 1,\n+                errors::InvalidArgument(\"wcf must be rank 1 but is rank \",\n+                                        wcf_tensor->dims()));\n \n     const Tensor* wco_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->input(\"wco\", &wco_tensor));\n+    OP_REQUIRES(ctx, wco_tensor->dims() == 1,\n+                errors::InvalidArgument(\"wco must be rank 1 but is rank \",\n+                                        wco_tensor->dims()));\n \n     const Tensor* b_tensor = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->input(\"b\", &b_tensor));\n+    OP_REQUIRES(ctx, b_tensor->dims() == 1,\n+                errors::InvalidArgument(\"b must be rank 1 but is rank \",\n+                                        b_tensor->dims()));\n     OP_REQUIRES(\n         ctx, cell_size == b_tensor->dim_size(0) / 4,\n         errors::InvalidArgument(\"w and b cell_size don't match: \", cell_size,"
        },
        {
          "filename": "tensorflow/python/kernel_tests/nn_ops/rnn_cell_test.py",
          "status": "modified",
          "additions": 52,
          "deletions": 0,
          "patch": "@@ -1354,6 +1354,58 @@ def testLSTMBlockCellErrorHandling(self):\n               cell_clip=cell_clip,\n               use_peephole=use_peephole))\n \n+  @test_util.run_in_graph_and_eager_modes\n+  def testLSTMBlockCellGradErrorHandling(self):\n+    use_peephole = False\n+    seq_len_max = constant_op.constant(1, shape=[], dtype=dtypes.int64)\n+    x = constant_op.constant(0.504355371, shape=[1, 1, 1], dtype=dtypes.float32)\n+    cs_prev = constant_op.constant(\n+        0.504355371, shape=[1, 1, 1], dtype=dtypes.float32)\n+    h_prev = constant_op.constant(\n+        0.504355371, shape=[1, 1], dtype=dtypes.float32)\n+    w = constant_op.constant(0.504355371, shape=[1, 1], dtype=dtypes.float32)\n+    wci = constant_op.constant(0.504355371, shape=[1], dtype=dtypes.float32)\n+    wcf = constant_op.constant(0.504355371, shape=[1], dtype=dtypes.float32)\n+    wco = constant_op.constant(0.504355371, shape=[1], dtype=dtypes.float32)\n+    b = constant_op.constant(0.504355371, shape=[1], dtype=dtypes.float32)\n+    i = constant_op.constant(0.504355371, shape=[1, 1, 1], dtype=dtypes.float32)\n+    cs = constant_op.constant(\n+        0.504355371, shape=[1, 1, 1], dtype=dtypes.float32)\n+    f = constant_op.constant(0.504355371, shape=[1, 1, 1], dtype=dtypes.float32)\n+    o = constant_op.constant(0.504355371, shape=[1, 1, 1], dtype=dtypes.float32)\n+    ci = constant_op.constant(\n+        0.504355371, shape=[1, 1, 1], dtype=dtypes.float32)\n+    co = constant_op.constant(\n+        0.504355371, shape=[1, 1, 1], dtype=dtypes.float32)\n+    h = constant_op.constant(0.504355371, shape=[1, 1, 1], dtype=dtypes.float32)\n+    cs_grad = constant_op.constant(\n+        0.504355371, shape=[1, 1, 1], dtype=dtypes.float32)\n+    h_grad = constant_op.constant(\n+        0.504355371, shape=[1, 1, 1], dtype=dtypes.float32)\n+    with self.assertRaisesRegex((ValueError, errors_impl.InvalidArgumentError),\n+                                \"must be rank\"):\n+      self.evaluate(\n+          gen_rnn_ops.block_lstm_grad_v2(\n+              seq_len_max=seq_len_max,\n+              x=x,\n+              cs_prev=cs_prev,\n+              h_prev=h_prev,\n+              w=w,\n+              wci=wci,\n+              wcf=wcf,\n+              wco=wco,\n+              b=b,\n+              i=i,\n+              cs=cs,\n+              f=f,\n+              o=o,\n+              ci=ci,\n+              co=co,\n+              h=h,\n+              cs_grad=cs_grad,\n+              h_grad=h_grad,\n+              use_peephole=use_peephole))\n+\n \n class BidirectionalRNNTest(test.TestCase):\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "fd41705e0ad7a123a9d01b8be2a3b34b3266493e",
            "date": "2025-01-14T13:33:52Z",
            "author_login": "loislo"
          },
          {
            "sha": "af5275c5731565cbf2a2c01ee418a8cf62388431",
            "date": "2025-01-14T12:48:20Z",
            "author_login": "akuegel"
          },
          {
            "sha": "ee156c15e5d1cd7d2bd85885e7fd2bf7e143c2c3",
            "date": "2025-01-14T12:46:22Z",
            "author_login": "pifon2a"
          },
          {
            "sha": "bd43a8255ce9e203b740bcdc09e8f79d3a26f887",
            "date": "2025-01-14T12:33:02Z",
            "author_login": "metaflow"
          },
          {
            "sha": "8003fb40987f176d35364da2af8fcdfab339349e",
            "date": "2025-01-14T11:27:47Z",
            "author_login": "vwbaker"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-20",
    "description": "TensorFlow is an open source platform for machine learning. The implementation of `BlockLSTMGradV2` does not fully validate its inputs. This results in a a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 2a458fc4866505be27c62f81474ecb2b870498fa. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-09-16T21:15:08.890",
    "last_modified": "2024-11-21T07:12:03.920",
    "fix_date": "2022-07-24T05:06:18Z"
  },
  "references": [
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/2a458fc4866505be27c62f81474ecb2b870498fa",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-f7r5-q7cx-h668",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/2a458fc4866505be27c62f81474ecb2b870498fa",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-f7r5-q7cx-h668",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:39.128317",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "tensorflow",
    "owner": "tensorflow",
    "created_at": "2015-11-07T01:19:20Z",
    "updated_at": "2025-01-14T12:53:26Z",
    "pushed_at": "2025-01-14T12:53:14Z",
    "size": 1120707,
    "stars": 187254,
    "forks": 74432,
    "open_issues": 6569,
    "watchers": 187254,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 101199988,
      "Python": 45779571,
      "MLIR": 10763008,
      "HTML": 7662661,
      "Starlark": 7430486,
      "Go": 2171370,
      "C": 1288066,
      "Java": 1178817,
      "Jupyter Notebook": 805736,
      "Shell": 701425,
      "Objective-C++": 279654,
      "Objective-C": 169202,
      "CMake": 148610,
      "Smarty": 121630,
      "Swift": 81659,
      "Dockerfile": 37903,
      "C#": 13585,
      "Batchfile": 12126,
      "Ruby": 8898,
      "Perl": 7536,
      "Roff": 5034,
      "Cython": 3899,
      "Makefile": 2845,
      "CSS": 2761,
      "Vim Snippet": 58
    },
    "commit_activity": {
      "total_commits_last_year": 15729,
      "avg_commits_per_week": 302.4807692307692,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:54:01.412891"
  }
}