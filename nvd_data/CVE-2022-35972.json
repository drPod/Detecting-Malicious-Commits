{
  "cve_id": "CVE-2022-35972",
  "github_data": {
    "repository": "tensorflow/tensorflow",
    "fix_commit": "785d67a78a1d533759fcd2f5e8d6ef778de849e0",
    "related_commits": [
      "785d67a78a1d533759fcd2f5e8d6ef778de849e0",
      "785d67a78a1d533759fcd2f5e8d6ef778de849e0"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "785d67a78a1d533759fcd2f5e8d6ef778de849e0",
      "commit_date": "2022-07-19T05:40:58Z",
      "author": {
        "login": "cantonios",
        "type": "User",
        "stats": {
          "total_commits": 299,
          "average_weekly_commits": 0.6203319502074689,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 96
        }
      },
      "commit_message": {
        "title": "Fix quantize ops input validation issues.",
        "length": 130,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 370,
        "additions": 337,
        "deletions": 33
      },
      "files": [
        {
          "filename": "tensorflow/core/kernels/fake_quant_ops.cc",
          "status": "modified",
          "additions": 16,
          "deletions": 1,
          "patch": "@@ -24,6 +24,7 @@ limitations under the License.\n // Above is the related header but clang tidy doesn't recognize it.\n #include \"tensorflow/core/framework/numeric_op.h\"\n #include \"tensorflow/core/framework/tensor.h\"\n+#include \"tensorflow/core/framework/tensor_shape.h\"\n #include \"tensorflow/core/lib/core/errors.h\"\n #include \"tensorflow/core/lib/monitoring/gauge.h\"\n #include \"tensorflow/core/platform/protobuf.h\"\n@@ -205,6 +206,13 @@ class FakeQuantWithMinMaxVarsOp : public OpKernel {\n     const Tensor& min = context->input(1);\n     const Tensor& max = context->input(2);\n \n+    OP_REQUIRES(\n+        context, TensorShapeUtils::IsScalar(min.shape()),\n+        InvalidArgument(\"`min` must be rank 0 but is rank \", min.dims()));\n+    OP_REQUIRES(\n+        context, TensorShapeUtils::IsScalar(max.shape()),\n+        InvalidArgument(\"`max` must be rank 0 but is rank \", max.dims()));\n+\n     Tensor* output;\n     OP_REQUIRES_OK(context,\n                    context->allocate_output(0, input.shape(), &output));\n@@ -342,10 +350,17 @@ class FakeQuantWithMinMaxVarsPerChannelOp : public OpKernel {\n     const Tensor& input = context->input(0);\n     const int depth = input.dim_size(input.dims() - 1);  // last dimension size.\n     const Tensor& min = context->input(1);\n+    const Tensor& max = context->input(2);\n+\n+    OP_REQUIRES(\n+        context, TensorShapeUtils::IsVector(min.shape()),\n+        InvalidArgument(\"`min` must be rank 1 but is rank \", min.dims()));\n     OP_REQUIRES(context, min.dim_size(0) == depth,\n                 InvalidArgument(\"min has incorrect size, expected \", depth,\n                                 \" was \", min.dim_size(0)));\n-    const Tensor& max = context->input(2);\n+    OP_REQUIRES(\n+        context, TensorShapeUtils::IsVector(max.shape()),\n+        InvalidArgument(\"`max` must be rank 1 but is rank \", max.dims()));\n     OP_REQUIRES(context, max.dim_size(0) == depth,\n                 InvalidArgument(\"max has incorrect size, expected \", depth,\n                                 \" was \", max.dim_size(0)));"
        },
        {
          "filename": "tensorflow/core/kernels/quantized_bias_add_op.cc",
          "status": "modified",
          "additions": 25,
          "deletions": 4,
          "patch": "@@ -20,6 +20,7 @@ limitations under the License.\n #include \"tensorflow/core/framework/numeric_op.h\"\n #include \"tensorflow/core/framework/op_kernel.h\"\n #include \"tensorflow/core/framework/tensor.h\"\n+#include \"tensorflow/core/framework/tensor_shape.h\"\n #include \"tensorflow/core/kernels/meta_support.h\"\n #include \"tensorflow/core/kernels/ops_util.h\"\n #include \"tensorflow/core/kernels/quantization_utils.h\"\n@@ -38,10 +39,30 @@ class QuantizedBiasAddOp : public OpKernel {\n   void Compute(OpKernelContext* context) override {\n     const Tensor& input = context->input(0);\n     const Tensor& bias = context->input(1);\n-    const float input_min = context->input(2).flat<float>()(0);\n-    const float input_max = context->input(3).flat<float>()(0);\n-    const float bias_min = context->input(4).flat<float>()(0);\n-    const float bias_max = context->input(5).flat<float>()(0);\n+\n+    const Tensor& min_input = context->input(2);\n+    const Tensor& max_input = context->input(3);\n+    const Tensor& min_bias = context->input(4);\n+    const Tensor& max_bias = context->input(5);\n+    OP_REQUIRES(\n+        context, TensorShapeUtils::IsScalar(min_input.shape()),\n+        errors::InvalidArgument(\"`min_input` must be rank 0 but is rank \",\n+                                min_input.dims()));\n+    OP_REQUIRES(\n+        context, TensorShapeUtils::IsScalar(max_input.shape()),\n+        errors::InvalidArgument(\"`max_input` must be rank 0 but is rank \",\n+                                max_input.dims()));\n+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_bias.shape()),\n+                errors::InvalidArgument(\n+                    \"`min_bias` must be rank 0 but is rank \", min_bias.dims()));\n+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_bias.shape()),\n+                errors::InvalidArgument(\n+                    \"`max_bias` must be rank 0 but is rank \", max_bias.dims()));\n+\n+    const float input_min = min_input.flat<float>()(0);\n+    const float input_max = max_input.flat<float>()(0);\n+    const float bias_min = min_bias.flat<float>()(0);\n+    const float bias_max = max_bias.flat<float>()(0);\n \n     OP_REQUIRES(context, TensorShapeUtils::IsMatrixOrHigher(input.shape()),\n                 errors::InvalidArgument(\"Input tensor must be at least 2D: \","
        },
        {
          "filename": "tensorflow/core/kernels/quantized_bias_add_op_test.cc",
          "status": "modified",
          "additions": 8,
          "deletions": 8,
          "patch": "@@ -74,10 +74,10 @@ TEST_F(QuantizedBiasAddTest, Small) {\n                             input_quantized.flat<quint8>());\n   AddInputFromArray<quint8>(bias_quantized.shape(),\n                             bias_quantized.flat<quint8>());\n-  AddInputFromArray<float>(TensorShape({1}), {input_min});\n-  AddInputFromArray<float>(TensorShape({1}), {input_max});\n-  AddInputFromArray<float>(TensorShape({1}), {bias_min});\n-  AddInputFromArray<float>(TensorShape({1}), {bias_max});\n+  AddInputFromArray<float>(TensorShape({}), {input_min});\n+  AddInputFromArray<float>(TensorShape({}), {input_max});\n+  AddInputFromArray<float>(TensorShape({}), {bias_min});\n+  AddInputFromArray<float>(TensorShape({}), {bias_max});\n   TF_ASSERT_OK(RunOpKernel());\n   const Tensor& output_quantized = *GetOutput(0);\n   const float output_min = GetOutput(1)->flat<float>()(0);\n@@ -156,10 +156,10 @@ TEST_F(QuantizedBiasAddTest, RealData) {\n                             input_quantized.flat<quint8>());\n   AddInputFromArray<quint8>(bias_quantized.shape(),\n                             bias_quantized.flat<quint8>());\n-  AddInputFromArray<float>(TensorShape({1}), {input_min});\n-  AddInputFromArray<float>(TensorShape({1}), {input_max});\n-  AddInputFromArray<float>(TensorShape({1}), {bias_min});\n-  AddInputFromArray<float>(TensorShape({1}), {bias_max});\n+  AddInputFromArray<float>(TensorShape({}), {input_min});\n+  AddInputFromArray<float>(TensorShape({}), {input_max});\n+  AddInputFromArray<float>(TensorShape({}), {bias_min});\n+  AddInputFromArray<float>(TensorShape({}), {bias_max});\n   TF_ASSERT_OK(RunOpKernel());\n   const Tensor& output_quantized = *GetOutput(0);\n   const float output_min = GetOutput(1)->flat<float>()(0);"
        },
        {
          "filename": "tensorflow/core/kernels/quantized_instance_norm.cc",
          "status": "modified",
          "additions": 11,
          "deletions": 3,
          "patch": "@@ -25,7 +25,7 @@ limitations under the License.\n #include \"tensorflow/core/framework/op_kernel.h\"\n #include \"tensorflow/core/framework/register_types.h\"\n #include \"tensorflow/core/framework/tensor.h\"\n-\n+#include \"tensorflow/core/framework/tensor_shape.h\"\n #include \"tensorflow/core/kernels/quantization_utils.h\"\n \n #ifdef USE_NEON\n@@ -274,8 +274,16 @@ class QuantizedInstanceNorm : public OpKernel {\n   void Compute(OpKernelContext* context) override {\n     const Tensor& input = context->input(0);\n \n-    float input_min = context->input(1).flat<float>()(0);\n-    float input_max = context->input(2).flat<float>()(0);\n+    const Tensor& x_min = context->input(1);\n+    const Tensor& x_max = context->input(2);\n+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(x_min.shape()),\n+                errors::InvalidArgument(\"`x_min` must be rank 0 but is rank \",\n+                                        x_min.dims()));\n+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(x_max.shape()),\n+                errors::InvalidArgument(\"`x_max` must be rank 0 but is rank \",\n+                                        x_max.dims()));\n+    float input_min = x_min.scalar<float>()();\n+    float input_max = x_max.scalar<float>()();\n     float input_scale = (input_max - input_min) / 255.0f;\n \n     OP_REQUIRES(context, input_min < input_max,"
        },
        {
          "filename": "tensorflow/core/kernels/requantize.cc",
          "status": "modified",
          "additions": 31,
          "deletions": 5,
          "patch": "@@ -18,9 +18,11 @@ limitations under the License.\n #define EIGEN_USE_THREADS\n \n #include <math.h>\n-#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n+\n #include \"tensorflow/core/framework/op.h\"\n #include \"tensorflow/core/framework/op_kernel.h\"\n+#include \"tensorflow/core/framework/tensor.h\"\n+#include \"tensorflow/core/framework/tensor_shape.h\"\n #include \"tensorflow/core/framework/type_traits.h\"\n #include \"tensorflow/core/framework/types.h\"\n #include \"tensorflow/core/kernels/meta_support.h\"\n@@ -38,10 +40,34 @@ class RequantizeOp : public OpKernel {\n \n   void Compute(OpKernelContext* ctx) override {\n     const Tensor& input = ctx->input(0);\n-    const float input_min_float = ctx->input(1).flat<float>()(0);\n-    const float input_max_float = ctx->input(2).flat<float>()(0);\n-    const float requested_output_min_float = ctx->input(3).flat<float>()(0);\n-    const float requested_output_max_float = ctx->input(4).flat<float>()(0);\n+\n+    const Tensor& input_min = ctx->input(1);\n+    const Tensor& input_max = ctx->input(2);\n+    const Tensor& requested_output_min = ctx->input(3);\n+    const Tensor& requested_output_max = ctx->input(4);\n+    OP_REQUIRES(\n+        ctx, TensorShapeUtils::IsScalar(input_min.shape()),\n+        errors::InvalidArgument(\"`input_min` must be rank 0 but is rank \",\n+                                input_min.dims()));\n+    OP_REQUIRES(\n+        ctx, TensorShapeUtils::IsScalar(input_max.shape()),\n+        errors::InvalidArgument(\"`input_max` must be rank 0 but is rank \",\n+                                input_max.dims()));\n+    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(requested_output_min.shape()),\n+                errors::InvalidArgument(\n+                    \"`requested_output_min` must be rank 0 but is rank \",\n+                    requested_output_min.dims()));\n+    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(requested_output_max.shape()),\n+                errors::InvalidArgument(\n+                    \"`requested_output_max` must be rank 0 but is rank \",\n+                    requested_output_max.dims()));\n+\n+    const float input_min_float = input_min.flat<float>()(0);\n+    const float input_max_float = input_max.flat<float>()(0);\n+    const float requested_output_min_float =\n+        requested_output_min.flat<float>()(0);\n+    const float requested_output_max_float =\n+        requested_output_max.flat<float>()(0);\n \n     Tensor* output = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));"
        },
        {
          "filename": "tensorflow/core/kernels/requantize_op_test.cc",
          "status": "modified",
          "additions": 12,
          "deletions": 12,
          "patch": "@@ -53,10 +53,10 @@ TEST_F(RequantizeTest, HandCraftedRequantize) {\n   // Requantize to -1 to 1.\n   AddInputFromArray<qint32>(TensorShape({value_count}),\n                             {-(1 << 23), 0, (1 << 23)});\n-  AddInputFromArray<float>(TensorShape({1}), {-256.0f});\n-  AddInputFromArray<float>(TensorShape({1}), {256.0f});\n-  AddInputFromArray<float>(TensorShape({1}), {-1.0f});\n-  AddInputFromArray<float>(TensorShape({1}), {1.0f});\n+  AddInputFromArray<float>(TensorShape({}), {-256.0f});\n+  AddInputFromArray<float>(TensorShape({}), {256.0f});\n+  AddInputFromArray<float>(TensorShape({}), {-1.0f});\n+  AddInputFromArray<float>(TensorShape({}), {1.0f});\n   TF_ASSERT_OK(RunOpKernel());\n   Tensor expected(allocator(), DT_QUINT8, TensorShape({value_count}));\n   test::FillValues<quint8>(&expected, {0, 128, 255});\n@@ -71,10 +71,10 @@ TEST_F(RequantizeTest, InvalidOutputMin) {\n \n   AddInputFromArray<qint32>(TensorShape({value_count}),\n                             {-(1 << 23), 0, (1 << 23)});\n-  AddInputFromArray<float>(TensorShape({1}), {-256.0f});\n-  AddInputFromArray<float>(TensorShape({1}), {256.0f});\n-  AddInputFromArray<float>(TensorShape({1}), {0.01f});\n-  AddInputFromArray<float>(TensorShape({1}), {1.0f});\n+  AddInputFromArray<float>(TensorShape({}), {-256.0f});\n+  AddInputFromArray<float>(TensorShape({}), {256.0f});\n+  AddInputFromArray<float>(TensorShape({}), {0.01f});\n+  AddInputFromArray<float>(TensorShape({}), {1.0f});\n   EXPECT_EQ(\"requested_output_min must be <= 0, but got 0.01\",\n             RunOpKernel().error_message());\n }\n@@ -85,10 +85,10 @@ TEST_F(RequantizeTest, InvalidOutputMax) {\n \n   AddInputFromArray<qint32>(TensorShape({value_count}),\n                             {-(1 << 23), 0, (1 << 23)});\n-  AddInputFromArray<float>(TensorShape({1}), {-256.0f});\n-  AddInputFromArray<float>(TensorShape({1}), {256.0f});\n-  AddInputFromArray<float>(TensorShape({1}), {-10.0f});\n-  AddInputFromArray<float>(TensorShape({1}), {-11.0f});\n+  AddInputFromArray<float>(TensorShape({}), {-256.0f});\n+  AddInputFromArray<float>(TensorShape({}), {256.0f});\n+  AddInputFromArray<float>(TensorShape({}), {-10.0f});\n+  AddInputFromArray<float>(TensorShape({}), {-11.0f});\n   EXPECT_EQ(\n       \"requested_output_max must be >= requested_output_min, but got -11 and \"\n       \"-10\","
        },
        {
          "filename": "tensorflow/python/kernel_tests/quantization_ops/BUILD",
          "status": "added",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -0,0 +1,24 @@\n+# Tests of TensorFlow quantization ops written using the Python API.\n+\n+# buildifier: disable=same-origin-load\n+load(\"//tensorflow:tensorflow.bzl\", \"tf_py_test\")\n+\n+package(\n+    default_visibility = [\"//tensorflow:internal\"],\n+    licenses = [\"notice\"],\n+)\n+\n+tf_py_test(\n+    name = \"quantization_ops_test\",\n+    size = \"small\",\n+    srcs = [\"quantization_ops_test.py\"],\n+    deps = [\n+        \"//tensorflow/python:array_ops\",\n+        \"//tensorflow/python:client\",\n+        \"//tensorflow/python:client_testlib\",\n+        \"//tensorflow/python:framework\",\n+        \"//tensorflow/python:framework_for_generated_wrappers\",\n+        \"//tensorflow/python:math_ops\",\n+        \"//third_party/py/numpy\",\n+    ],\n+)"
        },
        {
          "filename": "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py",
          "status": "added",
          "additions": 210,
          "deletions": 0,
          "patch": "@@ -0,0 +1,210 @@\n+# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+# ==============================================================================\n+\"\"\"Tests for tf.quantize ops.\"\"\"\n+import numpy as np\n+\n+from tensorflow.python.framework import constant_op\n+from tensorflow.python.framework import dtypes\n+from tensorflow.python.framework import errors\n+from tensorflow.python.framework import test_util\n+from tensorflow.python.ops import array_ops\n+from tensorflow.python.ops import math_ops\n+from tensorflow.python.ops import nn_ops\n+from tensorflow.python.platform import googletest\n+\n+\n+class FakeQuantWithMinMaxVarsOpTest(test_util.TensorFlowTestCase):\n+\n+  @test_util.run_in_graph_and_eager_modes\n+  def test_invalid_inputs(self):\n+    inputs = constant_op.constant(\n+        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"must be rank 0\"):\n+      self.evaluate(\n+          array_ops.fake_quant_with_min_max_vars(\n+              inputs=inputs, min=0.0, max=[[1.0], [2.0], [4.0]]))\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"must be rank 0\"):\n+      self.evaluate(\n+          array_ops.fake_quant_with_min_max_vars(\n+              inputs=inputs, min=[[1.0], [2.0], [4.0]], max=1.0))\n+\n+\n+class FakeQuantWithMinMaxVarsPerChannelOpTest(test_util.TensorFlowTestCase):\n+\n+  @test_util.run_in_graph_and_eager_modes\n+  def test_invalid_inputs(self):\n+    inputs = constant_op.constant(\n+        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"must be rank 1\"):\n+      self.evaluate(\n+          array_ops.fake_quant_with_min_max_vars_per_channel(\n+              inputs=inputs, min=[[0.0]], max=[1.0]))\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"Dimensions must be equal|incorrect size\"):\n+      self.evaluate(\n+          array_ops.fake_quant_with_min_max_vars_per_channel(\n+              inputs=inputs, min=[0.0, 0.1], max=[1.0]))\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"must be rank 1\"):\n+      self.evaluate(\n+          array_ops.fake_quant_with_min_max_vars_per_channel(\n+              inputs=inputs, min=[1.0], max=[[1.0]]))\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"Dimensions must be equal|incorrect size\"):\n+      self.evaluate(\n+          array_ops.fake_quant_with_min_max_vars_per_channel(\n+              inputs=inputs, min=[0.0], max=[1.0, 1.1]))\n+\n+\n+class QuantizedBiasedAddTest(test_util.TensorFlowTestCase):\n+\n+  @test_util.run_in_graph_and_eager_modes\n+  def test_invalid_inputs(self):\n+    inputs = constant_op.constant(\n+        np.int8(0), shape=[3, 3, 3, 3], dtype=dtypes.qint8)\n+    bias = constant_op.constant(np.int8(0), shape=[3], dtype=dtypes.qint8)\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"must be rank 0\"):\n+      self.evaluate(\n+          nn_ops.quantized_bias_add(\n+              input=inputs,\n+              bias=bias,\n+              min_input=[],\n+              max_input=1.0,\n+              min_bias=0.0,\n+              max_bias=1.0,\n+              out_type=dtypes.qint32))\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"must be rank 0\"):\n+      self.evaluate(\n+          nn_ops.quantized_bias_add(\n+              input=inputs,\n+              bias=bias,\n+              min_input=0.0,\n+              max_input=[],\n+              min_bias=0.0,\n+              max_bias=1.0,\n+              out_type=dtypes.qint32))\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"must be rank 0\"):\n+      self.evaluate(\n+          nn_ops.quantized_bias_add(\n+              input=inputs,\n+              bias=bias,\n+              min_input=0.0,\n+              max_input=1.0,\n+              min_bias=[],\n+              max_bias=1.0,\n+              out_type=dtypes.qint32))\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"must be rank 0\"):\n+      self.evaluate(\n+          nn_ops.quantized_bias_add(\n+              input=inputs,\n+              bias=bias,\n+              min_input=0.0,\n+              max_input=1.0,\n+              min_bias=0.0,\n+              max_bias=[],\n+              out_type=dtypes.qint32))\n+\n+\n+class QuantizedInstanceNormOpTest(test_util.TensorFlowTestCase):\n+\n+  @test_util.run_in_graph_and_eager_modes\n+  def test_invalid_inputs(self):\n+    inputs = constant_op.constant(\n+        np.uint8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"must be rank 0\"):\n+      self.evaluate(\n+          array_ops.quantized_instance_norm(\n+              x=inputs, x_min=0.0, x_max=[[1.0], [2.0], [4.0]]))\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"must be rank 0\"):\n+      self.evaluate(\n+          array_ops.quantized_instance_norm(\n+              x=inputs, x_min=[[1.0], [2.0], [4.0]], x_max=1.0))\n+\n+\n+class RequantizeOpTest(test_util.TensorFlowTestCase):\n+\n+  @test_util.run_in_graph_and_eager_modes\n+  def test_invalid_inputs(self):\n+    inputs = constant_op.constant(\n+        np.int32(0), shape=[3, 3, 3, 3], dtype=dtypes.qint32)\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"must be rank 0\"):\n+      self.evaluate(\n+          math_ops.requantize(\n+              input=inputs,\n+              input_min=[],\n+              input_max=1.0,\n+              requested_output_min=0.0,\n+              requested_output_max=1.0,\n+              out_type=dtypes.qint8))\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"must be rank 0\"):\n+      self.evaluate(\n+          math_ops.requantize(\n+              input=inputs,\n+              input_min=0.0,\n+              input_max=[],\n+              requested_output_min=0.0,\n+              requested_output_max=1.0,\n+              out_type=dtypes.qint8))\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"must be rank 0\"):\n+      self.evaluate(\n+          math_ops.requantize(\n+              input=inputs,\n+              input_min=0.0,\n+              input_max=1.0,\n+              requested_output_min=[],\n+              requested_output_max=1.0,\n+              out_type=dtypes.qint8))\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"must be rank 0\"):\n+      self.evaluate(\n+          math_ops.requantize(\n+              input=inputs,\n+              input_min=0.0,\n+              input_max=1.0,\n+              requested_output_min=0.0,\n+              requested_output_max=[],\n+              out_type=dtypes.qint8))\n+\n+\n+if __name__ == \"__main__\":\n+  googletest.main()"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 2,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "5c27f5f4dc39afdefbd93c2ef266a8c7ab534a98",
            "date": "2025-01-25T18:55:10Z",
            "author_login": "tensorflower-gardener"
          },
          {
            "sha": "05df81c283627135b7651c9c7a8fa0035bff2206",
            "date": "2025-01-25T17:06:34Z",
            "author_login": "tensorflower-gardener"
          },
          {
            "sha": "4075a7dd74ea543557d1824e16721598e1a6af8d",
            "date": "2025-01-25T17:06:30Z",
            "author_login": "tensorflower-gardener"
          },
          {
            "sha": "4d08d96d6a0aea39c5bd90d9728dbcf59008993c",
            "date": "2025-01-25T17:04:34Z",
            "author_login": "tensorflower-gardener"
          },
          {
            "sha": "1b58ec4dcd6e5752598dc57d4788119f8ea12e23",
            "date": "2025-01-25T11:39:06Z",
            "author_login": "tensorflower-gardener"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-20",
    "description": "TensorFlow is an open source platform for machine learning. If `QuantizedBiasAdd` is given `min_input`, `max_input`, `min_bias`, `max_bias` tensors of a nonzero rank, it results in a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 785d67a78a1d533759fcd2f5e8d6ef778de849e0. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-09-16T21:15:09.427",
    "last_modified": "2024-11-21T07:12:05.080",
    "fix_date": "2022-07-19T05:40:58Z"
  },
  "references": [
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/785d67a78a1d533759fcd2f5e8d6ef778de849e0",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-4pc4-m9mj-v2r9",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/785d67a78a1d533759fcd2f5e8d6ef778de849e0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-4pc4-m9mj-v2r9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:39.129491",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "tensorflow",
    "owner": "tensorflow",
    "created_at": "2015-11-07T01:19:20Z",
    "updated_at": "2025-01-26T06:52:14Z",
    "pushed_at": "2025-01-26T07:27:00Z",
    "size": 1126495,
    "stars": 187418,
    "forks": 74442,
    "open_issues": 6822,
    "watchers": 187418,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 101327392,
      "Python": 45791326,
      "MLIR": 10764225,
      "HTML": 7662661,
      "Starlark": 7439181,
      "Go": 2171369,
      "C": 1294440,
      "Java": 1178817,
      "Jupyter Notebook": 805736,
      "Shell": 702245,
      "Objective-C++": 279654,
      "Objective-C": 169202,
      "CMake": 148610,
      "Smarty": 121630,
      "Swift": 81659,
      "Dockerfile": 38067,
      "C#": 13585,
      "Batchfile": 12126,
      "Ruby": 8898,
      "Perl": 7536,
      "Roff": 5034,
      "Cython": 3899,
      "Makefile": 2845,
      "CSS": 2761,
      "Vim Snippet": 58
    },
    "commit_activity": {
      "total_commits_last_year": 15545,
      "avg_commits_per_week": 298.9423076923077,
      "days_active_last_year": 354
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:37:26.588757"
  }
}