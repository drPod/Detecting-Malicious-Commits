{
  "cve_id": "CVE-2022-35990",
  "github_data": {
    "repository": "tensorflow/tensorflow",
    "fix_commit": "f3cf67ac5705f4f04721d15e485e192bb319feed",
    "related_commits": [
      "f3cf67ac5705f4f04721d15e485e192bb319feed",
      "f3cf67ac5705f4f04721d15e485e192bb319feed"
    ],
    "patch_url": "https://github.com/tensorflow/tensorflow/commit/f3cf67ac5705f4f04721d15e485e192bb319feed.patch",
    "fix_commit_details": {
      "sha": "f3cf67ac5705f4f04721d15e485e192bb319feed",
      "commit_date": "2022-07-22T05:43:01Z",
      "author": {
        "login": "tensorflower-gardener",
        "type": "User",
        "stats": {
          "total_commits": 51283,
          "average_weekly_commits": 106.83958333333334,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 450
        }
      },
      "commit_message": {
        "title": "Add IsScalar / IsVector (rank) checks to input min/max tensors for FakeQuantWithMinMaxVarsPerChannelGradientOp and FakeQuantWithMinMaxVarsGradientOp.",
        "length": 179,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 84,
        "additions": 80,
        "deletions": 4
      },
      "files": [
        {
          "filename": "tensorflow/core/kernels/fake_quant_ops.cc",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -261,6 +261,12 @@ class FakeQuantWithMinMaxVarsGradientOp : public OpKernel {\n                 InvalidArgument(\"gradient and input must be the same size\"));\n     const Tensor& min = context->input(2);\n     const Tensor& max = context->input(3);\n+    OP_REQUIRES(\n+        context, TensorShapeUtils::IsScalar(min.shape()),\n+        InvalidArgument(\"`min` must be rank 0 but is rank \", min.dims()));\n+    OP_REQUIRES(\n+        context, TensorShapeUtils::IsScalar(max.shape()),\n+        InvalidArgument(\"`max` must be rank 0 but is rank \", max.dims()));\n \n     Tensor* grad_wrt_input;\n     OP_REQUIRES_OK(context,\n@@ -414,10 +420,16 @@ class FakeQuantWithMinMaxVarsPerChannelGradientOp : public OpKernel {\n                 InvalidArgument(\"gradient and input must be the same size\"));\n     const int depth = input.dim_size(input.dims() - 1);  // last dimension size.\n     const Tensor& min = context->input(2);\n+    OP_REQUIRES(\n+        context, TensorShapeUtils::IsVector(min.shape()),\n+        InvalidArgument(\"`min` must be rank 1 but is rank \", min.dims()));\n     OP_REQUIRES(context, min.dim_size(0) == depth,\n                 InvalidArgument(\"min has incorrect size, expected \", depth,\n                                 \" was \", min.dim_size(0)));\n     const Tensor& max = context->input(3);\n+    OP_REQUIRES(\n+        context, TensorShapeUtils::IsVector(max.shape()),\n+        InvalidArgument(\"`max` must be rank 1 but is rank \", max.dims()));\n     OP_REQUIRES(context, max.dim_size(0) == depth,\n                 InvalidArgument(\"max has incorrect size, expected \", depth,\n                                 \" was \", max.dim_size(0)));"
        },
        {
          "filename": "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py",
          "status": "modified",
          "additions": 68,
          "deletions": 4,
          "patch": "@@ -77,6 +77,71 @@ def test_invalid_inputs(self):\n               inputs=inputs, min=[0.0], max=[1.0, 1.1]))\n \n \n+class FakeQuantWithMinMaxVarsGradientOpTest(test_util.TensorFlowTestCase):\n+\n+  @test_util.run_in_graph_and_eager_modes\n+  def test_invalid_inputs(self):\n+    gradients = constant_op.constant(\n+        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n+    inputs = constant_op.constant(\n+        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"must be equal rank|must be rank 0\"):\n+      self.evaluate(\n+          array_ops.fake_quant_with_min_max_vars_gradient(\n+              gradients=gradients,\n+              inputs=inputs,\n+              min=0.0,\n+              max=[[1.0], [2.0], [4.0]]))\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"must be rank 0\"):\n+      self.evaluate(\n+          array_ops.fake_quant_with_min_max_vars_gradient(\n+              gradients=gradients,\n+              inputs=inputs,\n+              min=[[1.0], [2.0], [4.0]],\n+              max=[[1.0], [2.0], [4.0]]))\n+\n+\n+class FakeQuantWithMinMaxVarsPerChannelGradientOpTest(\n+    test_util.TensorFlowTestCase):\n+\n+  @test_util.run_in_graph_and_eager_modes\n+  def test_invalid_inputs(self):\n+    gradients = constant_op.constant(\n+        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n+    inputs = constant_op.constant(\n+        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"Shapes must be equal rank|must be rank 1\"):\n+      self.evaluate(\n+          array_ops.fake_quant_with_min_max_vars_per_channel_gradient(\n+              gradients=gradients, inputs=inputs, min=[[0.0]], max=[1.0]))\n+\n+    with self.assertRaisesRegex(\n+        (ValueError, errors.InvalidArgumentError),\n+        \"Dimension 0 in both shapes must be equal|incorrect size\"):\n+      self.evaluate(\n+          array_ops.fake_quant_with_min_max_vars_per_channel_gradient(\n+              gradients=gradients, inputs=inputs, min=[0.0, 0.1], max=[1.0]))\n+\n+    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n+                                \"Shapes must be equal rank|must be rank 1\"):\n+      self.evaluate(\n+          array_ops.fake_quant_with_min_max_vars_per_channel_gradient(\n+              gradients=gradients, inputs=inputs, min=[1.0], max=[[1.0]]))\n+\n+    with self.assertRaisesRegex(\n+        (ValueError, errors.InvalidArgumentError),\n+        \"Dimension 0 in both shapes must be equal|incorrect size\"):\n+      self.evaluate(\n+          array_ops.fake_quant_with_min_max_vars_per_channel_gradient(\n+              gradients=gradients, inputs=inputs, min=[0.0], max=[1.0, 1.1]))\n+\n+\n class QuantizedBiasedAddTest(test_util.TensorFlowTestCase):\n \n   @test_util.run_in_graph_and_eager_modes\n@@ -337,10 +402,9 @@ def test_invalid_inputs(self):\n     with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                 \"must be rank 0\"):\n       self.evaluate(\n-          math_ops.quantize_down_and_shrink_range(input=inputs,\n-                                                  input_min=[],\n-                                                  input_max=4.0,\n-                                                  out_type=dtypes.quint8))\n+          math_ops.quantize_down_and_shrink_range(\n+              input=inputs, input_min=[], input_max=4.0,\n+              out_type=dtypes.quint8))\n \n \n if __name__ == \"__main__\":"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d93cc4f4f767f0d4a72f2fafcc59005be939c019",
            "date": "2025-01-14T20:36:32Z",
            "author_login": "sdasgup3"
          },
          {
            "sha": "d4e4516cc7d11a68a81a82227f3a432f7ab350a0",
            "date": "2025-01-14T19:59:15Z",
            "author_login": "ddunl"
          },
          {
            "sha": "65367823d999b6a36a685617100a7bb6ce03add4",
            "date": "2025-01-14T19:58:00Z",
            "author_login": "sdasgup3"
          },
          {
            "sha": "36cbae5466dbf356d91cf56127b2ab2ccd5a8b1f",
            "date": "2025-01-14T19:54:19Z",
            "author_login": "penpornk"
          },
          {
            "sha": "0a99598a8f76735ac32b5466385b0f5af08a06bb",
            "date": "2025-01-14T19:45:23Z",
            "author_login": "wangpengmit"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-617",
    "description": "TensorFlow is an open source platform for machine learning. When `tf.quantization.fake_quant_with_min_max_vars_per_channel_gradient` receives input `min` or `max` of rank other than 1, it gives a `CHECK` fail that can trigger a denial of service attack. We have patched the issue in GitHub commit f3cf67ac5705f4f04721d15e485e192bb319feed. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range.There are no known workarounds for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-09-16T22:15:11.727",
    "last_modified": "2024-11-21T07:12:07.730",
    "fix_date": "2022-07-22T05:43:01Z"
  },
  "references": [
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/f3cf67ac5705f4f04721d15e485e192bb319feed",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-h7ff-cfc9-wmmh",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/f3cf67ac5705f4f04721d15e485e192bb319feed",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-h7ff-cfc9-wmmh",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:39.131387",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "tensorflow",
    "owner": "tensorflow",
    "created_at": "2015-11-07T01:19:20Z",
    "updated_at": "2025-01-14T12:53:26Z",
    "pushed_at": "2025-01-14T12:53:14Z",
    "size": 1120707,
    "stars": 187254,
    "forks": 74432,
    "open_issues": 6569,
    "watchers": 187254,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 101199988,
      "Python": 45779571,
      "MLIR": 10763008,
      "HTML": 7662661,
      "Starlark": 7430486,
      "Go": 2171370,
      "C": 1288066,
      "Java": 1178817,
      "Jupyter Notebook": 805736,
      "Shell": 701425,
      "Objective-C++": 279654,
      "Objective-C": 169202,
      "CMake": 148610,
      "Smarty": 121630,
      "Swift": 81659,
      "Dockerfile": 37903,
      "C#": 13585,
      "Batchfile": 12126,
      "Ruby": 8898,
      "Perl": 7536,
      "Roff": 5034,
      "Cython": 3899,
      "Makefile": 2845,
      "CSS": 2761,
      "Vim Snippet": 58
    },
    "commit_activity": {
      "total_commits_last_year": 15729,
      "avg_commits_per_week": 302.4807692307692,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:54:01.412891"
  }
}