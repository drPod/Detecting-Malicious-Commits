{
  "cve_id": "CVE-2022-36026",
  "github_data": {
    "repository": "tensorflow/tensorflow",
    "fix_commit": "f3f9cb38ecfe5a8a703f2c4a8fead434ef291713",
    "related_commits": [
      "f3f9cb38ecfe5a8a703f2c4a8fead434ef291713",
      "f3f9cb38ecfe5a8a703f2c4a8fead434ef291713"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "f3f9cb38ecfe5a8a703f2c4a8fead434ef291713",
      "commit_date": "2022-07-28T05:22:30Z",
      "author": {
        "login": "dansuh17",
        "type": "User",
        "stats": {
          "total_commits": 340,
          "average_weekly_commits": 0.7053941908713693,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 86
        }
      },
      "commit_message": {
        "title": "Validate the rank and number of elements of the `num_bits` tensor for QuantizeAndDequantizeV3.",
        "length": 352,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 267,
        "additions": 162,
        "deletions": 105
      },
      "files": [
        {
          "filename": "tensorflow/core/kernels/quantize_and_dequantize_op.cc",
          "status": "modified",
          "additions": 106,
          "deletions": 105,
          "patch": "@@ -21,19 +21,23 @@ limitations under the License.\n #define EIGEN_USE_GPU\n #endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n \n-#include \"tensorflow/core/kernels/quantize_and_dequantize_op.h\"\n-\n #include \"tensorflow/core/framework/op.h\"\n #include \"tensorflow/core/framework/op_kernel.h\"\n #include \"tensorflow/core/framework/register_types.h\"\n+#include \"tensorflow/core/framework/tensor_shape.h\"\n #include \"tensorflow/core/framework/type_traits.h\"\n #include \"tensorflow/core/framework/types.h\"\n+#include \"tensorflow/core/kernels/quantize_and_dequantize_op.h\"\n #include \"tensorflow/core/lib/core/errors.h\"\n \n namespace tensorflow {\n+namespace {\n \n-typedef Eigen::ThreadPoolDevice CPUDevice;\n-typedef Eigen::GpuDevice GPUDevice;\n+using CpuDevice = ::Eigen::ThreadPoolDevice;\n+using GpuDevice = ::Eigen::GpuDevice;\n+using ::tensorflow::errors::InvalidArgument;\n+\n+}  // namespace\n \n // Simulate quantization precision loss in a float tensor by:\n // 1. Quantize the tensor to fixed point numbers, which should match the target\n@@ -49,19 +53,19 @@ class QuantizeAndDequantizeV2Op : public OpKernel {\n     OP_REQUIRES_OK(ctx, ctx->GetAttr(\"axis\", &axis_));\n     OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n     OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n-                errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,\n-                                        \" with signed_input_ \", signed_input_));\n+                InvalidArgument(\"num_bits is out of range: \", num_bits_,\n+                                \" with signed_input_ \", signed_input_));\n     OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n \n     string round_mode_string;\n     OP_REQUIRES_OK(ctx, ctx->GetAttr(\"round_mode\", &round_mode_string));\n     OP_REQUIRES(\n         ctx,\n         (round_mode_string == \"HALF_UP\" || round_mode_string == \"HALF_TO_EVEN\"),\n-        errors::InvalidArgument(\"Round mode string must be \"\n-                                \"'HALF_UP' or \"\n-                                \"'HALF_TO_EVEN', is '\" +\n-                                round_mode_string + \"'\"));\n+        InvalidArgument(\"Round mode string must be \"\n+                        \"'HALF_UP' or \"\n+                        \"'HALF_TO_EVEN', is '\" +\n+                        round_mode_string + \"'\"));\n     if (round_mode_string == \"HALF_UP\") {\n       round_mode_ = ROUND_HALF_UP;\n     } else if (round_mode_string == \"HALF_TO_EVEN\") {\n@@ -72,12 +76,10 @@ class QuantizeAndDequantizeV2Op : public OpKernel {\n \n   void Compute(OpKernelContext* ctx) override {\n     const Tensor& input = ctx->input(0);\n-    OP_REQUIRES(\n-        ctx, axis_ >= -1,\n-        errors::InvalidArgument(\"Axis must be at least -1. Found \", axis_));\n-    OP_REQUIRES(\n-        ctx, (axis_ == -1 || axis_ < input.shape().dims()),\n-        errors::InvalidArgument(\"Shape must be at least rank \", axis_ + 1,\n+    OP_REQUIRES(ctx, axis_ >= -1,\n+                InvalidArgument(\"Axis must be at least -1. Found \", axis_));\n+    OP_REQUIRES(ctx, (axis_ == -1 || axis_ < input.shape().dims()),\n+                InvalidArgument(\"Shape must be at least rank \", axis_ + 1,\n                                 \" but is rank \", input.shape().dims()));\n     const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);\n     Tensor input_min_tensor;\n@@ -91,21 +93,21 @@ class QuantizeAndDequantizeV2Op : public OpKernel {\n         auto min_val = input_min_tensor.scalar<T>()();\n         auto max_val = input_max_tensor.scalar<T>()();\n         OP_REQUIRES(ctx, min_val <= max_val,\n-                    errors::InvalidArgument(\"Invalid range: input_min \",\n-                                            min_val, \" > input_max \", max_val));\n+                    InvalidArgument(\"Invalid range: input_min \", min_val,\n+                                    \" > input_max \", max_val));\n       } else {\n-        OP_REQUIRES(ctx, input_min_tensor.dim_size(0) == depth,\n-                    errors::InvalidArgument(\n-                        \"input_min_tensor has incorrect size, was \",\n-                        input_min_tensor.dim_size(0), \" expected \", depth,\n-                        \" to match dim \", axis_, \" of the input \",\n-                        input_min_tensor.shape()));\n-        OP_REQUIRES(ctx, input_max_tensor.dim_size(0) == depth,\n-                    errors::InvalidArgument(\n-                        \"input_max_tensor has incorrect size, was \",\n-                        input_max_tensor.dim_size(0), \" expected \", depth,\n-                        \" to match dim \", axis_, \" of the input \",\n-                        input_max_tensor.shape()));\n+        OP_REQUIRES(\n+            ctx, input_min_tensor.dim_size(0) == depth,\n+            InvalidArgument(\"input_min_tensor has incorrect size, was \",\n+                            input_min_tensor.dim_size(0), \" expected \", depth,\n+                            \" to match dim \", axis_, \" of the input \",\n+                            input_min_tensor.shape()));\n+        OP_REQUIRES(\n+            ctx, input_max_tensor.dim_size(0) == depth,\n+            InvalidArgument(\"input_max_tensor has incorrect size, was \",\n+                            input_max_tensor.dim_size(0), \" expected \", depth,\n+                            \" to match dim \", axis_, \" of the input \",\n+                            input_max_tensor.shape()));\n       }\n     } else {\n       auto range_shape = (axis_ == -1) ? TensorShape({}) : TensorShape({depth});\n@@ -158,38 +160,34 @@ class QuantizeAndDequantizeV4GradientOp : public OpKernel {\n     Tensor* input_backprop = nullptr;\n     OP_REQUIRES_OK(ctx,\n                    ctx->allocate_output(0, input.shape(), &input_backprop));\n-    OP_REQUIRES(\n-        ctx, axis_ >= -1,\n-        errors::InvalidArgument(\"Axis must be at least -1. Found \", axis_));\n+    OP_REQUIRES(ctx, axis_ >= -1,\n+                InvalidArgument(\"Axis must be at least -1. Found \", axis_));\n     OP_REQUIRES(ctx, (axis_ == -1 || axis_ < input.shape().dims()),\n-                errors::InvalidArgument(\n+                InvalidArgument(\n                     \"Axis should be -1 or 0 or a positive value less than \",\n                     input.shape().dims(), \"but given axis value was \", axis_));\n \n-    OP_REQUIRES(\n-        ctx, input.IsSameSize(gradient),\n-        errors::InvalidArgument(\"gradient and input must be the same size\"));\n+    OP_REQUIRES(ctx, input.IsSameSize(gradient),\n+                InvalidArgument(\"gradient and input must be the same size\"));\n     const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);\n     const Tensor& input_min_tensor = ctx->input(2);\n     OP_REQUIRES(ctx,\n                 input_min_tensor.dims() == 0 || input_min_tensor.dims() == 1,\n-                errors::InvalidArgument(\n+                InvalidArgument(\n                     \"Input min tensor must have dimension 0 or 1. Received \",\n                     input_min_tensor.dims(), \".\"));\n     const Tensor& input_max_tensor = ctx->input(3);\n     OP_REQUIRES(ctx,\n                 input_max_tensor.dims() == 0 || input_max_tensor.dims() == 1,\n-                errors::InvalidArgument(\n+                InvalidArgument(\n                     \"Input max tensor must have dimension 0 or 1. Received \",\n                     input_max_tensor.dims(), \".\"));\n     if (axis_ != -1) {\n-      OP_REQUIRES(\n-          ctx, input_min_tensor.dim_size(0) == depth,\n-          errors::InvalidArgument(\"min has incorrect size, expected \", depth,\n+      OP_REQUIRES(ctx, input_min_tensor.dim_size(0) == depth,\n+                  InvalidArgument(\"min has incorrect size, expected \", depth,\n                                   \" was \", input_min_tensor.dim_size(0)));\n-      OP_REQUIRES(\n-          ctx, input_max_tensor.dim_size(0) == depth,\n-          errors::InvalidArgument(\"max has incorrect size, expected \", depth,\n+      OP_REQUIRES(ctx, input_max_tensor.dim_size(0) == depth,\n+                  InvalidArgument(\"max has incorrect size, expected \", depth,\n                                   \" was \", input_max_tensor.dim_size(0)));\n     }\n \n@@ -203,12 +201,12 @@ class QuantizeAndDequantizeV4GradientOp : public OpKernel {\n                    ctx->allocate_output(2, min_max_shape, &input_max_backprop));\n \n     if (axis_ == -1) {\n-      OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_min_tensor.shape()),\n-                  errors::InvalidArgument(\n-                      \"input_min must be a scalar if axis is unspecified\"));\n-      OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_max_tensor.shape()),\n-                  errors::InvalidArgument(\n-                      \"input_max must be a scalar if axis is unspecified\"));\n+      OP_REQUIRES(\n+          ctx, TensorShapeUtils::IsScalar(input_min_tensor.shape()),\n+          InvalidArgument(\"input_min must be a scalar if axis is unspecified\"));\n+      OP_REQUIRES(\n+          ctx, TensorShapeUtils::IsScalar(input_max_tensor.shape()),\n+          InvalidArgument(\"input_max must be a scalar if axis is unspecified\"));\n       functor::QuantizeAndDequantizeOneScaleGradientFunctor<Device, T> f;\n       f(ctx->eigen_device<Device>(), gradient.template flat<T>(),\n         input.template flat<T>(), input_min_tensor.scalar<T>(),\n@@ -252,46 +250,50 @@ class QuantizeAndDequantizeV3Op : public OpKernel {\n   void Compute(OpKernelContext* ctx) override {\n     const Tensor& input = ctx->input(0);\n     OP_REQUIRES(ctx, axis_ < input.dims(),\n-                errors::InvalidArgument(\n+                InvalidArgument(\n                     \"Axis requested is larger than input dimensions. Axis: \",\n                     axis_, \" Input Dimensions: \", input.dims()));\n     const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);\n     Tensor* output = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n \n-    Tensor num_bits_tensor;\n-    num_bits_tensor = ctx->input(3);\n-    int num_bits_val = num_bits_tensor.scalar<int32>()();\n+    // Get num_bits and validate.\n+    const Tensor num_bits_tensor = ctx->input(3);\n+    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(num_bits_tensor.shape()),\n+                InvalidArgument(\"Invalid shape. The `num_bits` tensor should \"\n+                                \"be a scalar. Got dimensions: \",\n+                                num_bits_tensor.dims()));\n \n-    OP_REQUIRES(\n-        ctx, num_bits_val > 0 && num_bits_val < (signed_input_ ? 62 : 63),\n-        errors::InvalidArgument(\"num_bits is out of range: \", num_bits_val,\n-                                \" with signed_input_ \", signed_input_));\n+    const int num_bits_val = num_bits_tensor.scalar<int32>()();\n+    OP_REQUIRES(ctx,\n+                num_bits_val > 0 && num_bits_val < (signed_input_ ? 62 : 63),\n+                InvalidArgument(\"num_bits is out of range: \", num_bits_val,\n+                                \" with `signed_input_` \", signed_input_));\n \n     Tensor input_min_tensor;\n     Tensor input_max_tensor;\n     if (range_given_) {\n       input_min_tensor = ctx->input(1);\n       input_max_tensor = ctx->input(2);\n       if (axis_ == -1) {\n-        auto min_val = input_min_tensor.scalar<T>()();\n-        auto max_val = input_max_tensor.scalar<T>()();\n+        const auto min_val = input_min_tensor.scalar<T>()();\n+        const auto max_val = input_max_tensor.scalar<T>()();\n         OP_REQUIRES(ctx, min_val <= max_val,\n-                    errors::InvalidArgument(\"Invalid range: input_min \",\n-                                            min_val, \" > input_max \", max_val));\n+                    InvalidArgument(\"Invalid range: input_min \", min_val,\n+                                    \" > input_max \", max_val));\n       } else {\n-        OP_REQUIRES(ctx, input_min_tensor.dim_size(0) == depth,\n-                    errors::InvalidArgument(\n-                        \"input_min_tensor has incorrect size, was \",\n-                        input_min_tensor.dim_size(0), \" expected \", depth,\n-                        \" to match dim \", axis_, \" of the input \",\n-                        input_min_tensor.shape()));\n-        OP_REQUIRES(ctx, input_max_tensor.dim_size(0) == depth,\n-                    errors::InvalidArgument(\n-                        \"input_max_tensor has incorrect size, was \",\n-                        input_max_tensor.dim_size(0), \" expected \", depth,\n-                        \" to match dim \", axis_, \" of the input \",\n-                        input_max_tensor.shape()));\n+        OP_REQUIRES(\n+            ctx, input_min_tensor.dim_size(0) == depth,\n+            InvalidArgument(\"input_min_tensor has incorrect size, was \",\n+                            input_min_tensor.dim_size(0), \" expected \", depth,\n+                            \" to match dim \", axis_, \" of the input \",\n+                            input_min_tensor.shape()));\n+        OP_REQUIRES(\n+            ctx, input_max_tensor.dim_size(0) == depth,\n+            InvalidArgument(\"input_max_tensor has incorrect size, was \",\n+                            input_max_tensor.dim_size(0), \" expected \", depth,\n+                            \" to match dim \", axis_, \" of the input \",\n+                            input_max_tensor.shape()));\n       }\n     } else {\n       auto range_shape = (axis_ == -1) ? TensorShape({}) : TensorShape({depth});\n@@ -331,15 +333,14 @@ class QuantizeAndDequantizeOp : public OpKernel {\n     OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n     OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n     OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n-                errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,\n-                                        \" with signed_input_ \", signed_input_));\n+                InvalidArgument(\"num_bits is out of range: \", num_bits_,\n+                                \" with signed_input_ \", signed_input_));\n     OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n     OP_REQUIRES_OK(ctx, ctx->GetAttr(\"input_min\", &input_min_));\n     OP_REQUIRES_OK(ctx, ctx->GetAttr(\"input_max\", &input_max_));\n     if (range_given_) {\n-      OP_REQUIRES(\n-          ctx, input_min_ <= input_max_,\n-          errors::InvalidArgument(\"Invalid range: input_min \", input_min_,\n+      OP_REQUIRES(ctx, input_min_ <= input_max_,\n+                  InvalidArgument(\"Invalid range: input_min \", input_min_,\n                                   \" > input_max \", input_max_));\n     }\n   }\n@@ -371,93 +372,93 @@ class QuantizeAndDequantizeOp : public OpKernel {\n   float input_max_;\n };\n \n-// Specializations for CPUDevice.\n+// Specializations for CpuDevice.\n \n namespace functor {\n template <typename T>\n-struct QuantizeAndDequantizeOneScaleFunctor<CPUDevice, T> {\n-  void operator()(const CPUDevice& d, typename TTypes<T>::ConstVec input,\n+struct QuantizeAndDequantizeOneScaleFunctor<CpuDevice, T> {\n+  void operator()(const CpuDevice& d, typename TTypes<T>::ConstVec input,\n                   const bool signed_input, const int num_bits,\n                   const bool range_given, Tensor* input_min_tensor,\n                   Tensor* input_max_tensor, QuantizerRoundMode round_mode,\n                   bool narrow_range, typename TTypes<T>::Vec out) {\n-    QuantizeAndDequantizeOneScaleImpl<CPUDevice, T>::Compute(\n+    QuantizeAndDequantizeOneScaleImpl<CpuDevice, T>::Compute(\n         d, input, signed_input, num_bits, range_given, input_min_tensor,\n         input_max_tensor, round_mode, narrow_range, out);\n   }\n };\n \n template <typename T>\n-struct QuantizeAndDequantizePerChannelFunctor<CPUDevice, T> {\n-  void operator()(const CPUDevice& d, typename TTypes<T, 3>::ConstTensor input,\n+struct QuantizeAndDequantizePerChannelFunctor<CpuDevice, T> {\n+  void operator()(const CpuDevice& d, typename TTypes<T, 3>::ConstTensor input,\n                   bool signed_input, int num_bits, bool range_given,\n                   Tensor* input_min_tensor, Tensor* input_max_tensor,\n                   QuantizerRoundMode round_mode, bool narrow_range,\n                   typename TTypes<T, 3>::Tensor out) {\n-    QuantizeAndDequantizePerChannelImpl<CPUDevice, T>::Compute(\n+    QuantizeAndDequantizePerChannelImpl<CpuDevice, T>::Compute(\n         d, input, signed_input, num_bits, range_given, input_min_tensor,\n         input_max_tensor, round_mode, narrow_range, out);\n   }\n };\n \n template <typename T>\n-struct QuantizeAndDequantizeOneScaleGradientFunctor<CPUDevice, T> {\n-  void operator()(const CPUDevice& d, typename TTypes<T>::ConstFlat gradient,\n+struct QuantizeAndDequantizeOneScaleGradientFunctor<CpuDevice, T> {\n+  void operator()(const CpuDevice& d, typename TTypes<T>::ConstFlat gradient,\n                   typename TTypes<T>::ConstFlat input,\n                   typename TTypes<T>::ConstScalar input_min_tensor,\n                   typename TTypes<T>::ConstScalar input_max_tensor,\n                   typename TTypes<T>::Flat input_backprop,\n                   typename TTypes<T>::Scalar input_min_backprop,\n                   typename TTypes<T>::Scalar input_max_backprop) {\n-    QuantizeAndDequantizeOneScaleGradientImpl<CPUDevice, T>::Compute(\n+    QuantizeAndDequantizeOneScaleGradientImpl<CpuDevice, T>::Compute(\n         d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n         input_min_backprop, input_max_backprop);\n   }\n };\n \n template <typename T>\n-struct QuantizeAndDequantizePerChannelGradientFunctor<CPUDevice, T> {\n-  void operator()(const CPUDevice& d,\n+struct QuantizeAndDequantizePerChannelGradientFunctor<CpuDevice, T> {\n+  void operator()(const CpuDevice& d,\n                   typename TTypes<T, 3>::ConstTensor gradient,\n                   typename TTypes<T, 3>::ConstTensor input,\n                   const Tensor* input_min_tensor,\n                   const Tensor* input_max_tensor,\n                   typename TTypes<T, 3>::Tensor input_backprop,\n                   typename TTypes<T>::Flat input_min_backprop,\n                   typename TTypes<T>::Flat input_max_backprop) {\n-    QuantizeAndDequantizePerChannelGradientImpl<CPUDevice, T>::Compute(\n+    QuantizeAndDequantizePerChannelGradientImpl<CpuDevice, T>::Compute(\n         d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n         input_min_backprop, input_max_backprop);\n   }\n };\n \n-template struct functor::QuantizeAndDequantizeOneScaleGradientFunctor<CPUDevice,\n+template struct functor::QuantizeAndDequantizeOneScaleGradientFunctor<CpuDevice,\n                                                                       float>;\n template struct functor::QuantizeAndDequantizePerChannelGradientFunctor<\n-    CPUDevice, double>;\n+    CpuDevice, double>;\n \n }  // namespace functor\n \n #define REGISTER_CPU_KERNEL(T)                                                 \\\n   REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV2\")                      \\\n                               .Device(DEVICE_CPU)                              \\\n                               .TypeConstraint<T>(\"T\"),                         \\\n-                          QuantizeAndDequantizeV2Op<CPUDevice, T>);            \\\n+                          QuantizeAndDequantizeV2Op<CpuDevice, T>);            \\\n   REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV3\")                      \\\n                               .Device(DEVICE_CPU)                              \\\n                               .TypeConstraint<T>(\"T\"),                         \\\n-                          QuantizeAndDequantizeV3Op<CPUDevice, T>);            \\\n+                          QuantizeAndDequantizeV3Op<CpuDevice, T>);            \\\n   REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV4\")                      \\\n                               .Device(DEVICE_CPU)                              \\\n                               .TypeConstraint<T>(\"T\"),                         \\\n-                          QuantizeAndDequantizeV2Op<CPUDevice, T>);            \\\n+                          QuantizeAndDequantizeV2Op<CpuDevice, T>);            \\\n   REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV4Grad\")                  \\\n                               .Device(DEVICE_CPU)                              \\\n                               .TypeConstraint<T>(\"T\"),                         \\\n-                          QuantizeAndDequantizeV4GradientOp<CPUDevice, T>);    \\\n+                          QuantizeAndDequantizeV4GradientOp<CpuDevice, T>);    \\\n   REGISTER_KERNEL_BUILDER(                                                     \\\n       Name(\"QuantizeAndDequantize\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n-      QuantizeAndDequantizeOp<CPUDevice, T>);\n+      QuantizeAndDequantizeOp<CpuDevice, T>);\n TF_CALL_float(REGISTER_CPU_KERNEL);\n TF_CALL_double(REGISTER_CPU_KERNEL);\n #undef REGISTER_CPU_KERNEL\n@@ -470,29 +471,29 @@ TF_CALL_double(REGISTER_CPU_KERNEL);\n                               .HostMemory(\"input_min\")                         \\\n                               .HostMemory(\"input_max\")                         \\\n                               .TypeConstraint<T>(\"T\"),                         \\\n-                          QuantizeAndDequantizeV2Op<GPUDevice, T>);            \\\n+                          QuantizeAndDequantizeV2Op<GpuDevice, T>);            \\\n   REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV3\")                      \\\n                               .Device(DEVICE_GPU)                              \\\n                               .HostMemory(\"input_min\")                         \\\n                               .HostMemory(\"input_max\")                         \\\n                               .HostMemory(\"num_bits\")                          \\\n                               .TypeConstraint<T>(\"T\"),                         \\\n-                          QuantizeAndDequantizeV3Op<GPUDevice, T>);            \\\n+                          QuantizeAndDequantizeV3Op<GpuDevice, T>);            \\\n   REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV4\")                      \\\n                               .Device(DEVICE_GPU)                              \\\n                               .HostMemory(\"input_min\")                         \\\n                               .HostMemory(\"input_max\")                         \\\n                               .TypeConstraint<T>(\"T\"),                         \\\n-                          QuantizeAndDequantizeV2Op<GPUDevice, T>);            \\\n+                          QuantizeAndDequantizeV2Op<GpuDevice, T>);            \\\n   REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV4Grad\")                  \\\n                               .Device(DEVICE_GPU)                              \\\n                               .HostMemory(\"input_min\")                         \\\n                               .HostMemory(\"input_max\")                         \\\n                               .TypeConstraint<T>(\"T\"),                         \\\n-                          QuantizeAndDequantizeV4GradientOp<GPUDevice, T>);    \\\n+                          QuantizeAndDequantizeV4GradientOp<GpuDevice, T>);    \\\n   REGISTER_KERNEL_BUILDER(                                                     \\\n       Name(\"QuantizeAndDequantize\").Device(DEVICE_GPU).TypeConstraint<T>(\"T\"), \\\n-      QuantizeAndDequantizeOp<GPUDevice, T>);\n+      QuantizeAndDequantizeOp<GpuDevice, T>);\n TF_CALL_float(REGISTER_GPU_KERNEL);\n TF_CALL_double(REGISTER_GPU_KERNEL);\n #undef REGISTER_GPU_KERNEL"
        },
        {
          "filename": "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py",
          "status": "modified",
          "additions": 56,
          "deletions": 0,
          "patch": "@@ -15,9 +15,11 @@\n \"\"\"Tests for tf.quantize ops.\"\"\"\n import numpy as np\n \n+from tensorflow.python.eager import context\n from tensorflow.python.framework import constant_op\n from tensorflow.python.framework import dtypes\n from tensorflow.python.framework import errors\n+from tensorflow.python.framework import ops\n from tensorflow.python.framework import test_util\n from tensorflow.python.ops import array_ops\n from tensorflow.python.ops import math_ops\n@@ -407,5 +409,59 @@ def test_invalid_inputs(self):\n               out_type=dtypes.quint8))\n \n \n+class QuantizeAndDequantizeV3OpTest(test_util.TensorFlowTestCase):\n+\n+  @test_util.run_in_graph_and_eager_modes\n+  def test_valid(self):\n+    with ops.Graph().as_default(), context.eager_mode():\n+      input_value = constant_op.constant([-0.8, -0.5, 0, 0.3, 0.8, -2.0],\n+                                         shape=(6,),\n+                                         dtype=dtypes.float32),\n+      input_min = constant_op.constant(-127, shape=(), dtype=dtypes.float32)\n+      input_max = constant_op.constant(127, shape=(), dtype=dtypes.float32)\n+      num_bits = constant_op.constant(8, shape=(), dtype=dtypes.int32)\n+\n+      quantized = array_ops.quantize_and_dequantize_v3(\n+          input_value,\n+          input_min,\n+          input_max,\n+          num_bits,\n+          signed_input=True,\n+          range_given=False)\n+      self.assertSequenceAlmostEqual(\n+          input_value[0].numpy(), quantized.numpy()[0], delta=0.05)\n+\n+  @test_util.run_in_graph_and_eager_modes\n+  def test_invalid_inputs(self):\n+    input_value = constant_op.constant([-0.8, -0.5, 0, 0.3, 0.8, -2.0],\n+                                       shape=(6,),\n+                                       dtype=dtypes.float32),\n+    input_min = constant_op.constant(-127, shape=(), dtype=dtypes.float32)\n+    input_max = constant_op.constant(127, shape=(), dtype=dtypes.float32)\n+    # Tensor with invalid shape and invalid number of elements.\n+    num_bits = constant_op.constant([], shape=(0,), dtype=dtypes.int32)\n+\n+    # Test that running the op raises error. It raises different errors\n+    # depending on whether the shape inference is run first or the op's\n+    # Compute() is run first.\n+    try:\n+      array_ops.quantize_and_dequantize_v3(\n+          input_value, input_min, input_max, num_bits, signed_input=True)\n+    except Exception as ex:  # pylint: disable=broad-except\n+      if isinstance(ex, errors.InvalidArgumentError):\n+        self.assertRegex(str(ex), \"The `num_bits` tensor should be a scalar.\")\n+      elif isinstance(ex, ValueError):\n+        self.assertRegex(str(ex), \"Shape must be rank 0\")\n+      else:\n+        self.fail(\n+            \"Raised exception other than expected: %s. \"\n+            \"Expected exceptions are errors.InvalidArgumentError or ValueError\",\n+            ex.__name__)\n+    else:\n+      self.fail(\n+          \"Did not raise an exception where it is expected to raise either \"\n+          \"a ValueError or errors.InvalidArgumentError.\")\n+\n+\n if __name__ == \"__main__\":\n   googletest.main()"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "5c27f5f4dc39afdefbd93c2ef266a8c7ab534a98",
            "date": "2025-01-25T18:55:10Z",
            "author_login": "tensorflower-gardener"
          },
          {
            "sha": "05df81c283627135b7651c9c7a8fa0035bff2206",
            "date": "2025-01-25T17:06:34Z",
            "author_login": "tensorflower-gardener"
          },
          {
            "sha": "4075a7dd74ea543557d1824e16721598e1a6af8d",
            "date": "2025-01-25T17:06:30Z",
            "author_login": "tensorflower-gardener"
          },
          {
            "sha": "4d08d96d6a0aea39c5bd90d9728dbcf59008993c",
            "date": "2025-01-25T17:04:34Z",
            "author_login": "tensorflower-gardener"
          },
          {
            "sha": "1b58ec4dcd6e5752598dc57d4788119f8ea12e23",
            "date": "2025-01-25T11:39:06Z",
            "author_login": "tensorflower-gardener"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-617",
    "description": "TensorFlow is an open source platform for machine learning. If `QuantizeAndDequantizeV3` is given a nonscalar `num_bits` input tensor, it results in a `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit f3f9cb38ecfe5a8a703f2c4a8fead434ef291713. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-09-16T22:15:11.953",
    "last_modified": "2024-11-21T07:12:12.807",
    "fix_date": "2022-07-28T05:22:30Z"
  },
  "references": [
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/f3f9cb38ecfe5a8a703f2c4a8fead434ef291713",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-9cr2-8pwr-fhfq",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/commit/f3f9cb38ecfe5a8a703f2c4a8fead434ef291713",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-9cr2-8pwr-fhfq",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:39.131890",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "tensorflow",
    "owner": "tensorflow",
    "created_at": "2015-11-07T01:19:20Z",
    "updated_at": "2025-01-26T06:52:14Z",
    "pushed_at": "2025-01-26T07:27:00Z",
    "size": 1126495,
    "stars": 187418,
    "forks": 74442,
    "open_issues": 6822,
    "watchers": 187418,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C++": 101327392,
      "Python": 45791326,
      "MLIR": 10764225,
      "HTML": 7662661,
      "Starlark": 7439181,
      "Go": 2171369,
      "C": 1294440,
      "Java": 1178817,
      "Jupyter Notebook": 805736,
      "Shell": 702245,
      "Objective-C++": 279654,
      "Objective-C": 169202,
      "CMake": 148610,
      "Smarty": 121630,
      "Swift": 81659,
      "Dockerfile": 38067,
      "C#": 13585,
      "Batchfile": 12126,
      "Ruby": 8898,
      "Perl": 7536,
      "Roff": 5034,
      "Cython": 3899,
      "Makefile": 2845,
      "CSS": 2761,
      "Vim Snippet": 58
    },
    "commit_activity": {
      "total_commits_last_year": 15545,
      "avg_commits_per_week": 298.9423076923077,
      "days_active_last_year": 354
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:37:26.588757"
  }
}