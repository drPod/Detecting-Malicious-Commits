{
  "cve_id": "CVE-2022-36056",
  "github_data": {
    "repository": "sigstore/cosign",
    "fix_commit": "80b79ed8b4d28ccbce3d279fd273606b5cddcc25",
    "related_commits": [
      "80b79ed8b4d28ccbce3d279fd273606b5cddcc25",
      "80b79ed8b4d28ccbce3d279fd273606b5cddcc25"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "80b79ed8b4d28ccbce3d279fd273606b5cddcc25",
      "commit_date": "2022-09-14T08:37:41Z",
      "author": {
        "login": "asraa",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-8gw7-4j42-w388",
        "length": 1286,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 1688,
        "additions": 1452,
        "deletions": 236
      },
      "files": [
        {
          "filename": "cmd/cosign/cli/verify/verify_blob.go",
          "status": "modified",
          "additions": 361,
          "deletions": 169,
          "patch": "@@ -19,7 +19,7 @@ import (\n \t\"bytes\"\n \t\"context\"\n \t\"crypto\"\n-\t_ \"crypto/sha256\" // for `crypto.SHA256`\n+\t\"crypto/sha256\"\n \t\"crypto/x509\"\n \t\"encoding/base64\"\n \t\"encoding/hex\"\n@@ -28,6 +28,7 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n+\t\"strings\"\n \t\"time\"\n \n \t\"github.com/go-openapi/runtime\"\n@@ -37,6 +38,7 @@ import (\n \t\"github.com/sigstore/cosign/cmd/cosign/cli/rekor\"\n \t\"github.com/sigstore/cosign/pkg/blob\"\n \t\"github.com/sigstore/cosign/pkg/cosign\"\n+\t\"github.com/sigstore/cosign/pkg/cosign/bundle\"\n \t\"github.com/sigstore/cosign/pkg/cosign/pivkey\"\n \t\"github.com/sigstore/cosign/pkg/cosign/pkcs11key\"\n \tsigs \"github.com/sigstore/cosign/pkg/signature\"\n@@ -45,11 +47,15 @@ import (\n \tctypes \"github.com/sigstore/cosign/pkg/types\"\n \t\"github.com/sigstore/rekor/pkg/generated/client\"\n \t\"github.com/sigstore/rekor/pkg/generated/models\"\n+\t\"github.com/sigstore/rekor/pkg/pki\"\n \t\"github.com/sigstore/rekor/pkg/types\"\n-\thashedrekord \"github.com/sigstore/rekor/pkg/types/hashedrekord/v0.0.1\"\n-\trekord \"github.com/sigstore/rekor/pkg/types/rekord/v0.0.1\"\n+\t\"github.com/sigstore/rekor/pkg/types/hashedrekord\"\n+\thashedrekord_v001 \"github.com/sigstore/rekor/pkg/types/hashedrekord/v0.0.1\"\n+\t\"github.com/sigstore/rekor/pkg/types/intoto\"\n+\tintoto_v001 \"github.com/sigstore/rekor/pkg/types/intoto/v0.0.1\"\n+\t\"github.com/sigstore/rekor/pkg/types/rekord\"\n+\trekord_v001 \"github.com/sigstore/rekor/pkg/types/rekord/v0.0.1\"\n \t\"github.com/sigstore/sigstore/pkg/cryptoutils\"\n-\t\"github.com/sigstore/sigstore/pkg/signature\"\n \t\"github.com/sigstore/sigstore/pkg/signature/dsse\"\n \tsignatureoptions \"github.com/sigstore/sigstore/pkg/signature/options\"\n )\n@@ -65,14 +71,13 @@ func VerifyBlobCmd(ctx context.Context, ko options.KeyOpts, certRef, certEmail,\n \tcertGithubWorkflowName,\n \tcertGithubWorkflowRepository,\n \tcertGithubWorkflowRef string, enforceSCT bool) error {\n-\tvar verifier signature.Verifier\n \tvar cert *x509.Certificate\n \n \tif !options.OneOf(ko.KeyRef, ko.Sk, certRef) && !options.EnableExperimental() && ko.BundlePath == \"\" {\n \t\treturn &options.PubKeyParseError{}\n \t}\n \n-\tsig, b64sig, err := signatures(sigRef, ko.BundlePath)\n+\tsig, err := signatures(sigRef, ko.BundlePath)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -82,14 +87,44 @@ func VerifyBlobCmd(ctx context.Context, ko options.KeyOpts, certRef, certEmail,\n \t\treturn err\n \t}\n \n+\tco := &cosign.CheckOpts{\n+\t\tCertEmail:                    certEmail,\n+\t\tCertOidcIssuer:               certOidcIssuer,\n+\t\tCertGithubWorkflowTrigger:    certGithubWorkflowTrigger,\n+\t\tCertGithubWorkflowSha:        certGithubWorkflowSha,\n+\t\tCertGithubWorkflowName:       certGithubWorkflowName,\n+\t\tCertGithubWorkflowRepository: certGithubWorkflowRepository,\n+\t\tCertGithubWorkflowRef:        certGithubWorkflowRef,\n+\t\tEnforceSCT:                   enforceSCT,\n+\t}\n+\tif options.EnableExperimental() {\n+\t\tif ko.RekorURL != \"\" {\n+\t\t\trekorClient, err := rekor.NewClient(ko.RekorURL)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"creating Rekor client: %w\", err)\n+\t\t\t}\n+\t\t\tco.RekorClient = rekorClient\n+\t\t}\n+\t}\n+\tif certRef == \"\" || options.EnableExperimental() {\n+\t\tco.RootCerts, err = fulcio.GetRoots()\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"getting Fulcio roots: %w\", err)\n+\t\t}\n+\t\tco.IntermediateCerts, err = fulcio.GetIntermediates()\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"getting Fulcio intermediates: %w\", err)\n+\t\t}\n+\t}\n+\n \t// Keys are optional!\n \tswitch {\n \tcase ko.KeyRef != \"\":\n-\t\tverifier, err = sigs.PublicKeyFromKeyRef(ctx, ko.KeyRef)\n+\t\tco.SigVerifier, err = sigs.PublicKeyFromKeyRef(ctx, ko.KeyRef)\n \t\tif err != nil {\n \t\t\treturn fmt.Errorf(\"loading public key: %w\", err)\n \t\t}\n-\t\tpkcs11Key, ok := verifier.(*pkcs11key.Key)\n+\t\tpkcs11Key, ok := co.SigVerifier.(*pkcs11key.Key)\n \t\tif ok {\n \t\t\tdefer pkcs11Key.Close()\n \t\t}\n@@ -99,7 +134,7 @@ func VerifyBlobCmd(ctx context.Context, ko options.KeyOpts, certRef, certEmail,\n \t\t\treturn fmt.Errorf(\"opening piv token: %w\", err)\n \t\t}\n \t\tdefer sk.Close()\n-\t\tverifier, err = sk.Verifier()\n+\t\tco.SigVerifier, err = sk.Verifier()\n \t\tif err != nil {\n \t\t\treturn fmt.Errorf(\"loading public key from token: %w\", err)\n \t\t}\n@@ -108,27 +143,8 @@ func VerifyBlobCmd(ctx context.Context, ko options.KeyOpts, certRef, certEmail,\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tco := &cosign.CheckOpts{\n-\t\t\tCertEmail:                    certEmail,\n-\t\t\tCertOidcIssuer:               certOidcIssuer,\n-\t\t\tCertGithubWorkflowTrigger:    certGithubWorkflowTrigger,\n-\t\t\tCertGithubWorkflowSha:        certGithubWorkflowSha,\n-\t\t\tCertGithubWorkflowName:       certGithubWorkflowName,\n-\t\t\tCertGithubWorkflowRepository: certGithubWorkflowRepository,\n-\t\t\tCertGithubWorkflowRef:        certGithubWorkflowRef,\n-\t\t\tEnforceSCT:                   enforceSCT,\n-\t\t}\n \t\tif certChain == \"\" {\n-\t\t\t// If no certChain is passed, the Fulcio root certificate will be used\n-\t\t\tco.RootCerts, err = fulcio.GetRoots()\n-\t\t\tif err != nil {\n-\t\t\t\treturn fmt.Errorf(\"getting Fulcio roots: %w\", err)\n-\t\t\t}\n-\t\t\tco.IntermediateCerts, err = fulcio.GetIntermediates()\n-\t\t\tif err != nil {\n-\t\t\t\treturn fmt.Errorf(\"getting Fulcio intermediates: %w\", err)\n-\t\t\t}\n-\t\t\tverifier, err = cosign.ValidateAndUnpackCert(cert, co)\n+\t\t\tco.SigVerifier, err = cosign.ValidateAndUnpackCert(cert, co)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n@@ -138,7 +154,7 @@ func VerifyBlobCmd(ctx context.Context, ko options.KeyOpts, certRef, certEmail,\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n-\t\t\tverifier, err = cosign.ValidateAndUnpackCertWithChain(cert, chain, co)\n+\t\t\tco.SigVerifier, err = cosign.ValidateAndUnpackCertWithChain(cert, chain, co)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n@@ -151,120 +167,223 @@ func VerifyBlobCmd(ctx context.Context, ko options.KeyOpts, certRef, certEmail,\n \t\tif b.Cert == \"\" {\n \t\t\treturn fmt.Errorf(\"bundle does not contain cert for verification, please provide public key\")\n \t\t}\n-\t\t// cert can either be a cert or public key\n+\t\t// b.Cert can either be a certificate or public key\n \t\tcertBytes := []byte(b.Cert)\n \t\tif isb64(certBytes) {\n \t\t\tcertBytes, _ = base64.StdEncoding.DecodeString(b.Cert)\n \t\t}\n \t\tcert, err = loadCertFromPEM(certBytes)\n \t\tif err != nil {\n \t\t\t// check if cert is actually a public key\n-\t\t\tverifier, err = sigs.LoadPublicKeyRaw(certBytes, crypto.SHA256)\n+\t\t\tco.SigVerifier, err = sigs.LoadPublicKeyRaw(certBytes, crypto.SHA256)\n \t\t} else {\n-\t\t\tverifier, err = signature.LoadVerifier(cert.PublicKey, crypto.SHA256)\n+\t\t\tco.SigVerifier, err = cosign.ValidateAndUnpackCert(cert, co)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n \t\t}\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n+\t// No certificate is provided: search by artifact sha in the TLOG.\n \tcase options.EnableExperimental():\n-\t\trClient, err := rekor.NewClient(ko.RekorURL)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\n-\t\tuuids, err := cosign.FindTLogEntriesByPayload(ctx, rClient, blobBytes)\n+\t\tuuids, err := cosign.FindTLogEntriesByPayload(ctx, co.RekorClient, blobBytes)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \n \t\tif len(uuids) == 0 {\n \t\t\treturn errors.New(\"could not find a tlog entry for provided blob\")\n \t\t}\n-\t\treturn verifySigByUUID(ctx, ko, rClient, certEmail, certOidcIssuer, sig, b64sig, uuids, blobBytes, enforceSCT)\n-\t}\n \n-\t// Use the DSSE verifier if the payload is a DSSE with the In-Toto format.\n-\tif isIntotoDSSE(blobBytes) {\n-\t\tverifier = dsse.WrapVerifier(verifier)\n-\t}\n+\t\t// Iterate through and try to find a matching Rekor entry.\n+\t\t// This does not support intoto properly! c/f extractCerts and\n+\t\t// the verifier.\n+\t\tfor _, u := range uuids {\n+\t\t\ttlogEntry, err := cosign.GetTlogEntry(ctx, co.RekorClient, u)\n+\t\t\tif err != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// Note that this will error out if the TLOG entry was signed with a\n+\t\t\t// raw public key. Again, using search on artifact sha is unreliable.\n+\t\t\tcerts, err := extractCerts(tlogEntry)\n+\t\t\tif err != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tcert := certs[0]\n+\t\t\tco.SigVerifier, err = cosign.ValidateAndUnpackCert(cert, co)\n+\t\t\tif err != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif err := verifyBlob(ctx, co, blobBytes, sig, cert,\n+\t\t\t\tko.BundlePath, tlogEntry); err == nil {\n+\t\t\t\t// We found a succesful Rekor entry!\n+\t\t\t\tfmt.Fprintln(os.Stderr, \"Verified OK\")\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t}\n+\n+\t\t// No successful Rekor entry found.\n+\t\tfmt.Fprintln(os.Stderr, `WARNING: No valid entries were found in rekor to verify this blob.\n+\n+Transparency log support for blobs is experimental, and occasionally an entry isn't found even if one exists.\n+\n+We recommend requesting the certificate/signature from the original signer of this blob and manually verifying with cosign verify-blob --cert [cert] --signature [signature].`)\n+\t\treturn fmt.Errorf(\"could not find a valid tlog entry for provided blob, found %d invalid entries\", len(uuids))\n \n-\t// verify the signature\n-\tif err := verifier.VerifySignature(bytes.NewReader([]byte(sig)), bytes.NewReader(blobBytes)); err != nil {\n-\t\treturn err\n \t}\n \n-\t// verify the rekor entry\n-\tif err := verifyRekorEntry(ctx, ko, nil, verifier, cert, b64sig, blobBytes); err != nil {\n+\t// Performs all blob verification.\n+\tif err := verifyBlob(ctx, co, blobBytes, sig, cert, ko.BundlePath, nil); err != nil {\n \t\treturn err\n \t}\n \n \tfmt.Fprintln(os.Stderr, \"Verified OK\")\n \treturn nil\n }\n \n-func verifySigByUUID(ctx context.Context, ko options.KeyOpts, rClient *client.Rekor, certEmail, certOidcIssuer, sig, b64sig string,\n-\tuuids []string, blobBytes []byte, enforceSCT bool) error {\n-\tvar validSigExists bool\n-\tfor _, u := range uuids {\n-\t\ttlogEntry, err := cosign.GetTlogEntry(ctx, rClient, u)\n+/* Verify Blob main entry point. This will perform the following:\n+   1. Verifies the signature on the blob using the provided verifier.\n+   2. Checks for transparency log entry presence:\n+        a. Verifies the Rekor entry in the bundle, if provided. OR\n+        b. If we don't have a Rekor entry retrieved via cert, do an online lookup (assuming\n+           we are in experimental mode).\n+        c. Uses the provided Rekor entry (may have been retrieved through Rekor SearchIndex) OR\n+   3. If a certificate is provided, check it's expiration.\n+*/\n+// TODO: Make a version of this public. This could be VerifyBlobCmd, but we need to\n+// clean up the args into CheckOpts or use KeyOpts here to resolve different KeyOpts.\n+func verifyBlob(ctx context.Context, co *cosign.CheckOpts,\n+\tblobBytes []byte, sig string, cert *x509.Certificate,\n+\tbundlePath string, e *models.LogEntryAnon) error {\n+\tif cert != nil {\n+\t\t// This would have already be done in the main entrypoint, but do this for robustness.\n+\t\tvar err error\n+\t\tco.SigVerifier, err = cosign.ValidateAndUnpackCert(cert, co)\n \t\tif err != nil {\n-\t\t\tcontinue\n+\t\t\treturn fmt.Errorf(\"validating cert: %w\", err)\n \t\t}\n+\t}\n \n-\t\tcerts, err := extractCerts(tlogEntry)\n-\t\tif err != nil {\n-\t\t\tcontinue\n-\t\t}\n+\t// Use the DSSE verifier if the payload is a DSSE with the In-Toto format.\n+\t// TODO: This verifier only supports verification of a single signer/signature on\n+\t// the envelope. Either have the verifier validate that only one signature exists,\n+\t// or use a multi-signature verifier.\n+\tif isIntotoDSSE(blobBytes) {\n+\t\tco.SigVerifier = dsse.WrapVerifier(co.SigVerifier)\n+\t}\n \n-\t\tco := &cosign.CheckOpts{\n-\t\t\tCertEmail:      certEmail,\n-\t\t\tCertOidcIssuer: certOidcIssuer,\n-\t\t\tEnforceSCT:     enforceSCT,\n-\t\t}\n+\t// 1. Verify the signature.\n+\tif err := co.SigVerifier.VerifySignature(strings.NewReader(sig), bytes.NewReader(blobBytes)); err != nil {\n+\t\treturn err\n+\t}\n \n-\t\tco.RootCerts, err = fulcio.GetRoots()\n-\t\tif err != nil {\n-\t\t\treturn fmt.Errorf(\"getting Fulcio roots: %w\", err)\n+\t// This is the signature creation time. Without a transparency log entry timestamp,\n+\t// we can only use the current time as a bound.\n+\tvar validityTime time.Time\n+\t// 2. Checks for transparency log entry presence:\n+\tswitch {\n+\t// a. We have a local bundle.\n+\tcase bundlePath != \"\":\n+\t\tvar svBytes []byte\n+\t\tvar err error\n+\t\tif cert != nil {\n+\t\t\tsvBytes, err = cryptoutils.MarshalCertificateToPEM(cert)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"marshalling cert: %w\", err)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tsvBytes, err = sigs.PublicKeyPem(co.SigVerifier, signatureoptions.WithContext(ctx))\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"marshalling pubkey: %w\", err)\n+\t\t\t}\n \t\t}\n-\t\tco.IntermediateCerts, err = fulcio.GetIntermediates()\n+\t\tbundle, err := verifyRekorBundle(ctx, bundlePath, co.RekorClient, blobBytes, sig, svBytes)\n \t\tif err != nil {\n-\t\t\treturn fmt.Errorf(\"getting Fulcio intermediates: %w\", err)\n+\t\t\t// Return when the provided bundle fails verification. (Do not fallback).\n+\t\t\treturn err\n+\t\t}\n+\t\tvalidityTime = time.Unix(bundle.IntegratedTime, 0)\n+\t\tfmt.Fprintf(os.Stderr, \"tlog entry verified offline\\n\")\n+\t// b. We can make an online lookup to the transparency log since we don't have an entry.\n+\tcase co.RekorClient != nil && e == nil:\n+\t\tvar tlogFindErr error\n+\t\tif cert == nil {\n+\t\t\tpub, err := co.SigVerifier.PublicKey(co.PKOpts...)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\te, tlogFindErr = tlogFindPublicKey(ctx, co.RekorClient, blobBytes, sig, pub)\n+\t\t} else {\n+\t\t\te, tlogFindErr = tlogFindCertificate(ctx, co.RekorClient, blobBytes, sig, cert)\n+\t\t}\n+\t\tif tlogFindErr != nil {\n+\t\t\t// TODO: Think about whether we should break here.\n+\t\t\t// This is COSIGN_EXPERIMENTAL mode, but in the case where someone\n+\t\t\t// provided a public key or still-valid cert,\n+\t\t\t/// they don't need TLOG lookup for the timestamp.\n+\t\t\tfmt.Fprintf(os.Stderr, \"could not find entry in tlog: %s\", tlogFindErr)\n+\t\t\treturn tlogFindErr\n+\t\t}\n+\t\t// Fallthrough here to verify the TLOG entry and compute the integrated time.\n+\t\tfallthrough\n+\t// We are provided a log entry, possibly from above, or search.\n+\tcase e != nil:\n+\t\tif err := cosign.VerifyTLogEntry(ctx, co.RekorClient, e); err != nil {\n+\t\t\treturn err\n \t\t}\n \n-\t\tcert := certs[0]\n-\t\tverifier, err := cosign.ValidateAndUnpackCert(cert, co)\n+\t\tuuid, err := cosign.ComputeLeafHash(e)\n \t\tif err != nil {\n-\t\t\tcontinue\n-\t\t}\n-\t\t// Use the DSSE verifier if the payload is a DSSE with the In-Toto format.\n-\t\tif isIntotoDSSE(blobBytes) {\n-\t\t\tverifier = dsse.WrapVerifier(verifier)\n-\t\t}\n-\t\t// verify the signature\n-\t\tif err := verifier.VerifySignature(bytes.NewReader([]byte(sig)), bytes.NewReader(blobBytes)); err != nil {\n-\t\t\tcontinue\n+\t\t\treturn err\n \t\t}\n \n-\t\t// verify the rekor entry\n-\t\tif err := verifyRekorEntry(ctx, ko, tlogEntry, verifier, cert, b64sig, blobBytes); err != nil {\n-\t\t\tcontinue\n-\t\t}\n-\t\tvalidSigExists = true\n+\t\tvalidityTime = time.Unix(*e.IntegratedTime, 0)\n+\t\tfmt.Fprintf(os.Stderr, \"tlog entry verified with uuid: %s index: %d\\n\", hex.EncodeToString(uuid), *e.LogIndex)\n+\t// If we do not have access to a bundle, a Rekor entry, or the access to lookup,\n+\t// then we can only use the current time as the signature creation time to verify\n+\t// the signature was created when the certificate was valid.\n+\tdefault:\n+\t\tvalidityTime = time.Now()\n \t}\n-\tif !validSigExists {\n-\t\tfmt.Fprintln(os.Stderr, `WARNING: No valid entries were found in rekor to verify this blob.\n \n-Transparency log support for blobs is experimental, and occasionally an entry isn't found even if one exists.\n+\t// 3. If a certificate is provided, check it's expiration.\n+\tif cert == nil {\n+\t\treturn nil\n+\t}\n \n-We recommend requesting the certificate/signature from the original signer of this blob and manually verifying with cosign verify-blob --cert [cert] --signature [signature].`)\n-\t\treturn fmt.Errorf(\"could not find a valid tlog entry for provided blob, found %d invalid entries\", len(uuids))\n+\treturn cosign.CheckExpiry(cert, validityTime)\n+}\n+\n+func tlogFindPublicKey(ctx context.Context, rekorClient *client.Rekor,\n+\tblobBytes []byte, sig string, pub crypto.PublicKey) (*models.LogEntryAnon, error) {\n+\tpemBytes, err := cryptoutils.MarshalPublicKeyToPEM(pub)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n-\tfmt.Fprintln(os.Stderr, \"Verified OK\")\n-\treturn nil\n+\treturn tlogFindEntry(ctx, rekorClient, blobBytes, sig, pemBytes)\n+}\n+\n+func tlogFindCertificate(ctx context.Context, rekorClient *client.Rekor,\n+\tblobBytes []byte, sig string, cert *x509.Certificate) (*models.LogEntryAnon, error) {\n+\tpemBytes, err := cryptoutils.MarshalCertificateToPEM(cert)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn tlogFindEntry(ctx, rekorClient, blobBytes, sig, pemBytes)\n }\n \n-// signatures returns the raw signature and the base64 encoded signature\n-func signatures(sigRef string, bundlePath string) (string, string, error) {\n+func tlogFindEntry(ctx context.Context, client *client.Rekor,\n+\tblobBytes []byte, sig string, pem []byte) (*models.LogEntryAnon, error) {\n+\tb64sig := base64.StdEncoding.EncodeToString([]byte(sig))\n+\treturn cosign.FindTlogEntry(ctx, client, b64sig, blobBytes, pem)\n+}\n+\n+// signatures returns the raw signature\n+func signatures(sigRef string, bundlePath string) (string, error) {\n \tvar targetSig []byte\n \tvar err error\n \tswitch {\n@@ -273,18 +392,18 @@ func signatures(sigRef string, bundlePath string) (string, string, error) {\n \t\tif err != nil {\n \t\t\tif !os.IsNotExist(err) {\n \t\t\t\t// ignore if file does not exist, it can be a base64 encoded string as well\n-\t\t\t\treturn \"\", \"\", err\n+\t\t\t\treturn \"\", err\n \t\t\t}\n \t\t\ttargetSig = []byte(sigRef)\n \t\t}\n \tcase bundlePath != \"\":\n \t\tb, err := cosign.FetchLocalSignedPayloadFromPath(bundlePath)\n \t\tif err != nil {\n-\t\t\treturn \"\", \"\", err\n+\t\t\treturn \"\", err\n \t\t}\n \t\ttargetSig = []byte(b.Base64Signature)\n \tdefault:\n-\t\treturn \"\", \"\", fmt.Errorf(\"missing flag '--signature'\")\n+\t\treturn \"\", fmt.Errorf(\"missing flag '--signature'\")\n \t}\n \n \tvar sig, b64sig string\n@@ -296,7 +415,7 @@ func signatures(sigRef string, bundlePath string) (string, string, error) {\n \t\tsig = string(targetSig)\n \t\tb64sig = base64.StdEncoding.EncodeToString(targetSig)\n \t}\n-\treturn sig, b64sig, nil\n+\treturn sig, nil\n }\n \n func payloadBytes(blobRef string) ([]byte, error) {\n@@ -313,119 +432,176 @@ func payloadBytes(blobRef string) ([]byte, error) {\n \treturn blobBytes, nil\n }\n \n-func verifyRekorEntry(ctx context.Context, ko options.KeyOpts, e *models.LogEntryAnon, pubKey signature.Verifier, cert *x509.Certificate, b64sig string, blobBytes []byte) error {\n-\t// TODO: This can be moved below offline bundle verification when SIGSTORE_TRUST_REKOR_API_PUBLIC_KEY\n-\t// is removed.\n-\trekorClient, err := rekor.NewClient(ko.RekorURL)\n+// TODO: RekorClient can be removed when SIGSTORE_TRUST_REKOR_API_PUBLIC_KEY\n+// is removed.\n+func verifyRekorBundle(ctx context.Context, bundlePath string, rekorClient *client.Rekor,\n+\tblobBytes []byte, sig string, pubKeyBytes []byte) (*bundle.RekorPayload, error) {\n+\tb, err := cosign.FetchLocalSignedPayloadFromPath(bundlePath)\n \tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\t// If we have a bundle with a rekor entry, let's first try to verify offline\n-\tif ko.BundlePath != \"\" {\n-\t\tif err := verifyRekorBundle(ctx, ko.BundlePath, cert, rekorClient); err == nil {\n-\t\t\tfmt.Fprintf(os.Stderr, \"tlog entry verified offline\\n\")\n-\t\t\treturn nil\n-\t\t}\n+\t\treturn nil, err\n \t}\n-\tif !options.EnableExperimental() {\n-\t\treturn nil\n+\tif b.Bundle == nil {\n+\t\treturn nil, fmt.Errorf(\"rekor entry could not be extracted from local bundle\")\n \t}\n \n-\t// Only fetch from rekor tlog if we don't already have the entry.\n-\tif e == nil {\n-\t\tvar pubBytes []byte\n-\t\tif pubKey != nil {\n-\t\t\tpubBytes, err = sigs.PublicKeyPem(pubKey, signatureoptions.WithContext(ctx))\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t}\n-\t\tif cert != nil {\n-\t\t\tpubBytes, err = cryptoutils.MarshalCertificateToPEM(cert)\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t}\n-\t\te, err = cosign.FindTlogEntry(ctx, rekorClient, b64sig, blobBytes, pubBytes)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n+\tif err := verifyBundleMatchesData(ctx, b.Bundle, blobBytes, pubKeyBytes, []byte(sig)); err != nil {\n+\t\treturn nil, err\n \t}\n \n-\tif err := cosign.VerifyTLogEntry(ctx, rekorClient, e); err != nil {\n-\t\treturn nil\n+\tpublicKeys, err := cosign.GetRekorPubs(ctx, rekorClient)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"retrieving rekor public key: %w\", err)\n \t}\n \n-\tuuid, err := cosign.ComputeLeafHash(e)\n+\tpubKey, ok := publicKeys[b.Bundle.Payload.LogID]\n+\tif !ok {\n+\t\treturn nil, errors.New(\"rekor log public key not found for payload\")\n+\t}\n+\terr = cosign.VerifySET(b.Bundle.Payload, b.Bundle.SignedEntryTimestamp, pubKey.PubKey)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn nil, err\n \t}\n-\n-\tfmt.Fprintf(os.Stderr, \"tlog entry verified with uuid: %s index: %d\\n\", hex.EncodeToString(uuid), *e.LogIndex)\n-\tif cert == nil {\n-\t\treturn nil\n+\tif pubKey.Status != tuf.Active {\n+\t\tfmt.Fprintf(os.Stderr, \"**Info** Successfully verified Rekor entry using an expired verification key\\n\")\n \t}\n-\t// if we have a cert, we should check expiry\n-\treturn cosign.CheckExpiry(cert, time.Unix(*e.IntegratedTime, 0))\n+\n+\treturn &b.Bundle.Payload, nil\n }\n \n-func verifyRekorBundle(ctx context.Context, bundlePath string, cert *x509.Certificate, rekorClient *client.Rekor) error {\n-\tb, err := cosign.FetchLocalSignedPayloadFromPath(bundlePath)\n+func verifyBundleMatchesData(ctx context.Context, bundle *bundle.RekorBundle, blobBytes, certBytes, sigBytes []byte) error {\n+\teimpl, kind, apiVersion, err := unmarshalEntryImpl(bundle.Payload.Body.(string))\n \tif err != nil {\n \t\treturn err\n \t}\n-\tif b.Bundle == nil {\n-\t\treturn fmt.Errorf(\"rekor entry is not available\")\n-\t}\n-\tpublicKeys, err := cosign.GetRekorPubs(ctx, rekorClient)\n+\n+\ttargetImpl, err := reconstructCanonicalizedEntry(ctx, kind, apiVersion, blobBytes, certBytes, sigBytes)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"retrieving rekor public key: %w\", err)\n+\t\treturn fmt.Errorf(\"recontructing rekorEntry for bundle comparison: %w\", err)\n \t}\n \n-\tpubKey, ok := publicKeys[b.Bundle.Payload.LogID]\n-\tif !ok {\n-\t\treturn errors.New(\"rekor log public key not found for payload\")\n+\tswitch e := eimpl.(type) {\n+\tcase *rekord_v001.V001Entry:\n+\t\tt := targetImpl.(*rekord_v001.V001Entry)\n+\t\tdata, err := e.RekordObj.Data.Content.MarshalText()\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"invalid rekord data: %w\", err)\n+\t\t}\n+\t\ttData, err := t.RekordObj.Data.Content.MarshalText()\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"invalid rekord data: %w\", err)\n+\t\t}\n+\t\tif !bytes.Equal(data, tData) {\n+\t\t\treturn fmt.Errorf(\"rekord data does not match blob\")\n+\t\t}\n+\t\tif err := compareBase64Strings(e.RekordObj.Signature.Content.String(),\n+\t\t\tt.RekordObj.Signature.Content.String()); err != nil {\n+\t\t\treturn fmt.Errorf(\"rekord signature does not match bundle %s\", err)\n+\t\t}\n+\t\tif err := compareBase64Strings(e.RekordObj.Signature.PublicKey.Content.String(),\n+\t\t\tt.RekordObj.Signature.PublicKey.Content.String()); err != nil {\n+\t\t\treturn fmt.Errorf(\"rekord public key does not match bundle\")\n+\t\t}\n+\tcase *hashedrekord_v001.V001Entry:\n+\t\tt := targetImpl.(*hashedrekord_v001.V001Entry)\n+\t\tif *e.HashedRekordObj.Data.Hash.Value != *t.HashedRekordObj.Data.Hash.Value {\n+\t\t\treturn fmt.Errorf(\"hashedRekord data does not match blob\")\n+\t\t}\n+\t\tif err := compareBase64Strings(e.HashedRekordObj.Signature.Content.String(),\n+\t\t\tt.HashedRekordObj.Signature.Content.String()); err != nil {\n+\t\t\treturn fmt.Errorf(\"hashedRekord signature does not match bundle %s\", err)\n+\t\t}\n+\t\tif err := compareBase64Strings(e.HashedRekordObj.Signature.PublicKey.Content.String(),\n+\t\t\tt.HashedRekordObj.Signature.PublicKey.Content.String()); err != nil {\n+\t\t\treturn fmt.Errorf(\"hashedRekord public key does not match bundle\")\n+\t\t}\n+\tcase *intoto_v001.V001Entry:\n+\t\tt := targetImpl.(*intoto_v001.V001Entry)\n+\t\tif *e.IntotoObj.Content.Hash.Value != *t.IntotoObj.Content.Hash.Value {\n+\t\t\treturn fmt.Errorf(\"intoto content hash does not match attestation\")\n+\t\t}\n+\t\tif *e.IntotoObj.Content.PayloadHash.Value != *t.IntotoObj.Content.PayloadHash.Value {\n+\t\t\treturn fmt.Errorf(\"intoto payload hash does not match attestation\")\n+\t\t}\n+\t\tif err := compareBase64Strings(e.IntotoObj.PublicKey.String(),\n+\t\t\tt.IntotoObj.PublicKey.String()); err != nil {\n+\t\t\treturn fmt.Errorf(\"intoto public key does not match bundle\")\n+\t\t}\n+\tdefault:\n+\t\treturn errors.New(\"unexpected tlog entry type\")\n \t}\n-\terr = cosign.VerifySET(b.Bundle.Payload, b.Bundle.SignedEntryTimestamp, pubKey.PubKey)\n+\treturn nil\n+}\n+\n+func reconstructCanonicalizedEntry(ctx context.Context, kind, apiVersion string, blobBytes, certBytes, sigBytes []byte) (types.EntryImpl, error) {\n+\tprops := types.ArtifactProperties{\n+\t\tPublicKeyBytes: certBytes,\n+\t\tPKIFormat:      string(pki.X509),\n+\t}\n+\tswitch kind {\n+\tcase rekord.KIND:\n+\t\tprops.ArtifactBytes = blobBytes\n+\t\tprops.SignatureBytes = sigBytes\n+\tcase hashedrekord.KIND:\n+\t\tblobHash := sha256.Sum256(blobBytes)\n+\t\tprops.ArtifactHash = strings.ToLower(hex.EncodeToString(blobHash[:]))\n+\t\tprops.SignatureBytes = sigBytes\n+\tcase intoto.KIND:\n+\t\tprops.ArtifactBytes = blobBytes\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"unexpected entry kind: %s\", kind)\n+\t}\n+\tproposedEntry, err := types.NewProposedEntry(ctx, kind, apiVersion, props)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn nil, err\n \t}\n-\tif pubKey.Status != tuf.Active {\n-\t\tfmt.Fprintf(os.Stderr, \"**Info** Successfully verified Rekor entry using an expired verification key\\n\")\n+\tentry, err := types.NewEntry(proposedEntry)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n-\n-\tif cert == nil {\n-\t\treturn nil\n+\tcan, err := entry.Canonicalize(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tproposedEntryCan, err := models.UnmarshalProposedEntry(bytes.NewReader(can), runtime.JSONConsumer())\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n-\tit := time.Unix(b.Bundle.Payload.IntegratedTime, 0)\n-\treturn cosign.CheckExpiry(cert, it)\n+\treturn types.NewEntry(proposedEntryCan)\n }\n \n-func extractCerts(e *models.LogEntryAnon) ([]*x509.Certificate, error) {\n-\tb, err := base64.StdEncoding.DecodeString(e.Body.(string))\n+// unmarshalEntryImpl decodes the base64-encoded entry to a specific entry type (types.EntryImpl).\n+func unmarshalEntryImpl(e string) (types.EntryImpl, string, string, error) {\n+\tb, err := base64.StdEncoding.DecodeString(e)\n \tif err != nil {\n-\t\treturn nil, err\n+\t\treturn nil, \"\", \"\", err\n \t}\n \n \tpe, err := models.UnmarshalProposedEntry(bytes.NewReader(b), runtime.JSONConsumer())\n \tif err != nil {\n-\t\treturn nil, err\n+\t\treturn nil, \"\", \"\", err\n+\t}\n+\n+\tentry, err := types.NewEntry(pe)\n+\tif err != nil {\n+\t\treturn nil, \"\", \"\", err\n \t}\n+\treturn entry, pe.Kind(), entry.APIVersion(), nil\n+}\n \n-\teimpl, err := types.NewEntry(pe)\n+func extractCerts(e *models.LogEntryAnon) ([]*x509.Certificate, error) {\n+\teimpl, _, _, err := unmarshalEntryImpl(e.Body.(string))\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n \tvar publicKeyB64 []byte\n \tswitch e := eimpl.(type) {\n-\tcase *rekord.V001Entry:\n+\tcase *rekord_v001.V001Entry:\n \t\tpublicKeyB64, err = e.RekordObj.Signature.PublicKey.Content.MarshalText()\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\tcase *hashedrekord.V001Entry:\n+\tcase *hashedrekord_v001.V001Entry:\n \t\tpublicKeyB64, err = e.HashedRekordObj.Signature.PublicKey.Content.MarshalText()\n \t\tif err != nil {\n \t\t\treturn nil, err\n@@ -463,3 +639,19 @@ func isIntotoDSSE(blobBytes []byte) bool {\n \n \treturn true\n }\n+\n+// TODO: Use this function to compare bundle signatures in OCI.\n+func compareBase64Strings(got string, expected string) error {\n+\tdecodeFirst, err := base64.StdEncoding.DecodeString(got)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"decoding base64 string %s\", got)\n+\t}\n+\tdecodeSecond, err := base64.StdEncoding.DecodeString(expected)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"decoding base64 string %s\", expected)\n+\t}\n+\tif !bytes.Equal(decodeFirst, decodeSecond) {\n+\t\treturn fmt.Errorf(\"comparing base64 strings, expected %s, got %s\", expected, got)\n+\t}\n+\treturn nil\n+}"
        },
        {
          "filename": "cmd/cosign/cli/verify/verify_blob_test.go",
          "status": "modified",
          "additions": 985,
          "deletions": 12,
          "patch": "@@ -15,14 +15,46 @@\n package verify\n \n import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"crypto\"\n+\t\"crypto/ecdsa\"\n+\t\"crypto/elliptic\"\n+\t\"crypto/rand\"\n+\t\"crypto/sha256\"\n+\t\"crypto/x509\"\n \t\"encoding/base64\"\n+\t\"encoding/hex\"\n \t\"encoding/json\"\n+\t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"strings\"\n \t\"testing\"\n+\t\"time\"\n \n-\t\"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n+\t\"github.com/cyberphone/json-canonicalization/go/src/webpki.org/jsoncanonicalizer\"\n+\t\"github.com/go-openapi/swag\"\n+\tssldsse \"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n+\t\"github.com/sigstore/cosign/cmd/cosign/cli/options\"\n+\t\"github.com/sigstore/cosign/internal/pkg/cosign/rekor/mock\"\n \t\"github.com/sigstore/cosign/pkg/cosign\"\n+\t\"github.com/sigstore/cosign/pkg/cosign/bundle\"\n+\tsigs \"github.com/sigstore/cosign/pkg/signature\"\n+\tctypes \"github.com/sigstore/cosign/pkg/types\"\n+\t\"github.com/sigstore/cosign/test\"\n+\t\"github.com/sigstore/rekor/pkg/generated/client\"\n+\t\"github.com/sigstore/rekor/pkg/generated/models\"\n+\t\"github.com/sigstore/rekor/pkg/pki\"\n+\t\"github.com/sigstore/rekor/pkg/types\"\n+\t\"github.com/sigstore/rekor/pkg/types/hashedrekord\"\n+\thashedrekord_v001 \"github.com/sigstore/rekor/pkg/types/hashedrekord/v0.0.1\"\n+\t\"github.com/sigstore/rekor/pkg/types/intoto\"\n+\t\"github.com/sigstore/rekor/pkg/types/rekord\"\n+\t\"github.com/sigstore/sigstore/pkg/cryptoutils\"\n+\t\"github.com/sigstore/sigstore/pkg/signature\"\n+\t\"github.com/sigstore/sigstore/pkg/signature/dsse\"\n+\tsignatureoptions \"github.com/sigstore/sigstore/pkg/signature/options\"\n )\n \n func TestSignaturesRef(t *testing.T) {\n@@ -48,7 +80,7 @@ func TestSignaturesRef(t *testing.T) {\n \n \tfor _, test := range tests {\n \t\tt.Run(test.description, func(t *testing.T) {\n-\t\t\tgotSig, gotb64Sig, err := signatures(test.sigRef, \"\")\n+\t\t\tgotSig, err := signatures(test.sigRef, \"\")\n \t\t\tif test.shouldErr && err != nil {\n \t\t\t\treturn\n \t\t\t}\n@@ -58,9 +90,6 @@ func TestSignaturesRef(t *testing.T) {\n \t\t\tif gotSig != sig {\n \t\t\t\tt.Fatalf(\"unexpected signature, expected: %s got: %s\", sig, gotSig)\n \t\t\t}\n-\t\t\tif gotb64Sig != b64sig {\n-\t\t\t\tt.Fatalf(\"unexpected encoded signature, expected: %s got: %s\", b64sig, gotb64Sig)\n-\t\t\t}\n \t\t})\n \t}\n }\n@@ -84,28 +113,25 @@ func TestSignaturesBundle(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n \n-\tgotSig, gotb64Sig, err := signatures(\"\", fp)\n+\tgotSig, err := signatures(\"\", fp)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n \tif gotSig != sig {\n \t\tt.Fatalf(\"unexpected signature, expected: %s got: %s\", sig, gotSig)\n \t}\n-\tif gotb64Sig != b64sig {\n-\t\tt.Fatalf(\"unexpected encoded signature, expected: %s got: %s\", b64sig, gotb64Sig)\n-\t}\n }\n \n func TestIsIntotoDSSEWithEnvelopes(t *testing.T) {\n \ttts := []struct {\n-\t\tenvelope     dsse.Envelope\n+\t\tenvelope     ssldsse.Envelope\n \t\tisIntotoDSSE bool\n \t}{\n \t\t{\n-\t\t\tenvelope: dsse.Envelope{\n+\t\t\tenvelope: ssldsse.Envelope{\n \t\t\t\tPayloadType: \"application/vnd.in-toto+json\",\n \t\t\t\tPayload:     base64.StdEncoding.EncodeToString([]byte(\"This is a test\")),\n-\t\t\t\tSignatures:  []dsse.Signature{},\n+\t\t\t\tSignatures:  []ssldsse.Signature{},\n \t\t\t},\n \t\t\tisIntotoDSSE: true,\n \t\t},\n@@ -141,3 +167,950 @@ func TestIsIntotoDSSEWithBytes(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// Does not test identity options, only blob verification with different\n+// options.\n+func TestVerifyBlob(t *testing.T) {\n+\tctx := context.Background()\n+\ttd := t.TempDir()\n+\n+\tleafPriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tsigner, err := signature.LoadECDSASignerVerifier(leafPriv, crypto.SHA256)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tpubKeyBytes, err := sigs.PublicKeyPem(signer, signatureoptions.WithContext(ctx))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// Generate expired and unexpired certificates\n+\tidentity := \"hello@foo.com\"\n+\tissuer := \"issuer\"\n+\trootCert, rootPriv, _ := test.GenerateRootCa()\n+\trootPool := x509.NewCertPool()\n+\trootPool.AddCert(rootCert)\n+\tunexpiredLeafCert, _ := test.GenerateLeafCertWithExpiration(identity, issuer,\n+\t\ttime.Now(), leafPriv, rootCert, rootPriv)\n+\tunexpiredCertPem, _ := cryptoutils.MarshalCertificateToPEM(unexpiredLeafCert)\n+\n+\texpiredLeafCert, _ := test.GenerateLeafCertWithExpiration(identity, issuer,\n+\t\ttime.Now().Add(-time.Hour), leafPriv, rootCert, rootPriv)\n+\texpiredLeafPem, _ := cryptoutils.MarshalCertificateToPEM(expiredLeafCert)\n+\n+\t// Make rekor signer\n+\trekorPriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\trekorSigner, err := signature.LoadECDSASignerVerifier(rekorPriv, crypto.SHA256)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tpemRekor, err := cryptoutils.MarshalPublicKeyToPEM(rekorSigner.Public())\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\ttmpRekorPubFile, err := os.CreateTemp(td, \"cosign_rekor_pub_*.key\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to create temp rekor pub file: %v\", err)\n+\t}\n+\tdefer tmpRekorPubFile.Close()\n+\tif _, err := tmpRekorPubFile.Write(pemRekor); err != nil {\n+\t\tt.Fatalf(\"failed to write rekor pub file: %v\", err)\n+\t}\n+\tt.Setenv(\"SIGSTORE_REKOR_PUBLIC_KEY\", tmpRekorPubFile.Name())\n+\n+\tvar makeSignature = func(blob []byte) string {\n+\t\tsig, err := signer.SignMessage(bytes.NewReader([]byte(blob)))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\treturn string(sig)\n+\t}\n+\tblobBytes := []byte(\"foo\")\n+\tblobSignature := makeSignature(blobBytes)\n+\n+\totherBytes := []byte(\"bar\")\n+\totherSignature := makeSignature(otherBytes)\n+\n+\ttts := []struct {\n+\t\tname        string\n+\t\tblob        []byte\n+\t\tsignature   string\n+\t\tsigVerifier signature.Verifier\n+\t\tcert        *x509.Certificate\n+\t\tbundlePath  string\n+\t\t// If online lookups to Rekor are enabled\n+\t\texperimental bool\n+\t\t// The rekor entry response when Rekor is enabled\n+\t\trekorEntry *models.LogEntry\n+\t\tshouldErr  bool\n+\t}{\n+\t\t{\n+\t\t\tname:         \"valid signature with public key\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: false,\n+\t\t\tshouldErr:    false,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with public key - experimental no rekor fail\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: true,\n+\t\t\trekorEntry:   nil,\n+\t\t\tshouldErr:    true,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with public key - experimental rekor entry success\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: true,\n+\t\t\trekorEntry: makeRekorEntry(t, *rekorSigner, blobBytes, []byte(blobSignature),\n+\t\t\t\tpubKeyBytes, true),\n+\t\t\tshouldErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with public key - good bundle provided\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: false,\n+\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(blobSignature),\n+\t\t\t\tpubKeyBytes, true),\n+\t\t\tshouldErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with public key - bad bundle SET\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: false,\n+\t\t\tbundlePath: makeLocalBundle(t, *signer, blobBytes, []byte(blobSignature),\n+\t\t\t\tunexpiredCertPem, true),\n+\t\t\tshouldErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with public key - bad bundle cert mismatch\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: false,\n+\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(blobSignature),\n+\t\t\t\tunexpiredCertPem, true),\n+\t\t\tshouldErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with public key - bad bundle signature mismatch\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: false,\n+\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(makeSignature(blobBytes)),\n+\t\t\t\tpubKeyBytes, true),\n+\t\t\tshouldErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with public key - bad bundle msg & signature mismatch\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: false,\n+\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, otherBytes, []byte(otherSignature),\n+\t\t\t\tpubKeyBytes, true),\n+\t\t\tshouldErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"invalid signature with public key\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    otherSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: false,\n+\t\t\tshouldErr:    true,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"invalid signature with public key - experimental\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    otherSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: true,\n+\t\t\tshouldErr:    true,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with unexpired certificate\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\tcert:         unexpiredLeafCert,\n+\t\t\texperimental: false,\n+\t\t\tshouldErr:    false,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with unexpired certificate - bad bundle cert mismatch\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: false,\n+\t\t\tcert:         unexpiredLeafCert,\n+\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(blobSignature),\n+\t\t\t\tpubKeyBytes, true),\n+\t\t\tshouldErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with unexpired certificate - bad bundle signature mismatch\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: false,\n+\t\t\tcert:         unexpiredLeafCert,\n+\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(makeSignature(blobBytes)),\n+\t\t\t\tunexpiredCertPem, true),\n+\t\t\tshouldErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with unexpired certificate - bad bundle msg & signature mismatch\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: false,\n+\t\t\tcert:         unexpiredLeafCert,\n+\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, otherBytes, []byte(otherSignature),\n+\t\t\t\tunexpiredCertPem, true),\n+\t\t\tshouldErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"invalid signature with unexpired certificate\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    otherSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\tcert:         unexpiredLeafCert,\n+\t\t\texperimental: false,\n+\t\t\tshouldErr:    true,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with unexpired certificate - experimental\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tcert:         unexpiredLeafCert,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: true,\n+\t\t\trekorEntry: makeRekorEntry(t, *rekorSigner, blobBytes, []byte(blobSignature),\n+\t\t\t\tunexpiredCertPem, true),\n+\t\t\tshouldErr: false,\n+\t\t},\n+\n+\t\t{\n+\t\t\tname:         \"valid signature with unexpired certificate - experimental & rekor entry found\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tcert:         unexpiredLeafCert,\n+\t\t\texperimental: true,\n+\t\t\trekorEntry: makeRekorEntry(t, *rekorSigner, blobBytes, []byte(blobSignature),\n+\t\t\t\tunexpiredCertPem, true),\n+\t\t\tshouldErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with expired certificate\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tcert:         expiredLeafCert,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: false,\n+\t\t\tshouldErr:    true,\n+\t\t},\n+\n+\t\t{\n+\t\t\tname:         \"valid signature with expired certificate - experimental good rekor lookup\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\tcert:         expiredLeafCert,\n+\t\t\texperimental: true,\n+\t\t\trekorEntry: makeRekorEntry(t, *rekorSigner, blobBytes, []byte(blobSignature),\n+\t\t\t\texpiredLeafPem, true),\n+\t\t\tshouldErr: false,\n+\t\t},\n+\n+\t\t{\n+\t\t\tname:         \"valid signature with expired certificate - experimental bad rekor integrated time\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tcert:         expiredLeafCert,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: true,\n+\t\t\trekorEntry: makeRekorEntry(t, *rekorSigner, blobBytes, []byte(blobSignature),\n+\t\t\t\texpiredLeafPem, false),\n+\t\t\tshouldErr: true,\n+\t\t},\n+\n+\t\t{\n+\t\t\tname:         \"valid signature with unexpired certificate - good bundle, nonexperimental\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tcert:         unexpiredLeafCert,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: false,\n+\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(blobSignature),\n+\t\t\t\tunexpiredCertPem, true),\n+\t\t\tshouldErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with expired certificate - good bundle, nonexperimental\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tcert:         expiredLeafCert,\n+\t\t\tsigVerifier:  signer,\n+\t\t\texperimental: false,\n+\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(blobSignature),\n+\t\t\t\texpiredLeafPem, true),\n+\t\t\tshouldErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with expired certificate - bundle with bad expiration\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\tcert:         expiredLeafCert,\n+\t\t\texperimental: false,\n+\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(blobSignature),\n+\t\t\t\texpiredLeafPem, false),\n+\t\t\tshouldErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with expired certificate - bundle with bad SET\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\tcert:         expiredLeafCert,\n+\t\t\texperimental: false,\n+\t\t\tbundlePath: makeLocalBundle(t, *signer, blobBytes, []byte(blobSignature),\n+\t\t\t\texpiredLeafPem, true),\n+\t\t\tshouldErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with expired certificate - experimental good bundle\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\tcert:         expiredLeafCert,\n+\t\t\texperimental: true,\n+\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(blobSignature),\n+\t\t\t\texpiredLeafPem, true),\n+\t\t\tshouldErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"valid signature with expired certificate - experimental bad rekor entry\",\n+\t\t\tblob:         blobBytes,\n+\t\t\tsignature:    blobSignature,\n+\t\t\tsigVerifier:  signer,\n+\t\t\tcert:         expiredLeafCert,\n+\t\t\texperimental: true,\n+\t\t\t// This is the wrong signer for the SET!\n+\t\t\trekorEntry: makeRekorEntry(t, *signer, blobBytes, []byte(blobSignature),\n+\t\t\t\texpiredLeafPem, true),\n+\t\t\tshouldErr: true,\n+\t\t},\n+\t}\n+\tfor _, tt := range tts {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\ttt := tt\n+\t\t\tvar mClient client.Rekor\n+\t\t\tmClient.Entries = &mock.EntriesClient{Entries: tt.rekorEntry}\n+\t\t\tco := &cosign.CheckOpts{\n+\t\t\t\tSigVerifier: tt.sigVerifier,\n+\t\t\t\tRootCerts:   rootPool,\n+\t\t\t}\n+\t\t\t// if expermental is enabled, add RekorClient to co.\n+\t\t\tif tt.experimental {\n+\t\t\t\tco.RekorClient = &mClient\n+\t\t\t}\n+\n+\t\t\terr := verifyBlob(ctx, co, tt.blob, tt.signature, tt.cert, tt.bundlePath, nil)\n+\t\t\tif (err != nil) != tt.shouldErr {\n+\t\t\t\tt.Fatalf(\"verifyBlob()= %s, expected shouldErr=%t \", err, tt.shouldErr)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func makeRekorEntry(t *testing.T, rekorSigner signature.ECDSASignerVerifier,\n+\tpyld, sig, svBytes []byte, expiryValid bool) *models.LogEntry {\n+\tctx := context.Background()\n+\t// Calculate log ID, the digest of the Rekor public key\n+\tlogID, err := getLogID(rekorSigner.Public())\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\thashedrekord := &hashedrekord_v001.V001Entry{}\n+\th := sha256.Sum256(pyld)\n+\tpe, err := hashedrekord.CreateFromArtifactProperties(ctx, types.ArtifactProperties{\n+\t\tArtifactHash:   hex.EncodeToString(h[:]),\n+\t\tSignatureBytes: sig,\n+\t\tPublicKeyBytes: svBytes,\n+\t\tPKIFormat:      \"x509\",\n+\t})\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tentry, err := types.NewEntry(pe)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tleaf, err := entry.Canonicalize(ctx)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tintegratedTime := time.Now()\n+\tcerts, _ := cryptoutils.UnmarshalCertificatesFromPEM(svBytes)\n+\tif certs != nil && len(certs) > 0 {\n+\t\tif expiryValid {\n+\t\t\tintegratedTime = certs[0].NotAfter.Add(-time.Second)\n+\t\t} else {\n+\t\t\tintegratedTime = certs[0].NotAfter.Add(time.Second)\n+\t\t}\n+\t}\n+\te := models.LogEntryAnon{\n+\t\tBody:           base64.StdEncoding.EncodeToString(leaf),\n+\t\tIntegratedTime: swag.Int64(integratedTime.Unix()),\n+\t\tLogIndex:       swag.Int64(0),\n+\t\tLogID:          swag.String(logID),\n+\t}\n+\t// Marshal payload, sign, and set SET in Bundle\n+\tjsonPayload, err := json.Marshal(e)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tcanonicalized, err := jsoncanonicalizer.Transform(jsonPayload)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tbundleSig, err := rekorSigner.SignMessage(bytes.NewReader(canonicalized))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tuuid, _ := cosign.ComputeLeafHash(&e)\n+\n+\te.Verification = &models.LogEntryAnonVerification{\n+\t\tSignedEntryTimestamp: bundleSig,\n+\t\tInclusionProof: &models.InclusionProof{\n+\t\t\tLogIndex: swag.Int64(0),\n+\t\t\tTreeSize: swag.Int64(1),\n+\t\t\tRootHash: swag.String(hex.EncodeToString(uuid)),\n+\t\t\tHashes:   []string{},\n+\t\t},\n+\t}\n+\treturn &models.LogEntry{hex.EncodeToString(uuid): e}\n+}\n+\n+func makeLocalBundle(t *testing.T, rekorSigner signature.ECDSASignerVerifier,\n+\tpyld []byte, sig []byte, svBytes []byte, expiryValid bool) string {\n+\ttd := t.TempDir()\n+\n+\t// Create bundle.\n+\tentry := makeRekorEntry(t, rekorSigner, pyld, sig, svBytes, expiryValid)\n+\tvar e models.LogEntryAnon\n+\tfor _, v := range *entry {\n+\t\te = v\n+\t}\n+\tb := cosign.LocalSignedPayload{\n+\t\tBase64Signature: base64.StdEncoding.EncodeToString(sig),\n+\t\tCert:            string(svBytes),\n+\t\tBundle: &bundle.RekorBundle{\n+\t\t\tPayload: bundle.RekorPayload{\n+\t\t\t\tBody:           e.Body,\n+\t\t\t\tIntegratedTime: *e.IntegratedTime,\n+\t\t\t\tLogIndex:       *e.LogIndex,\n+\t\t\t\tLogID:          *e.LogID,\n+\t\t\t},\n+\t\t\tSignedEntryTimestamp: e.Verification.SignedEntryTimestamp,\n+\t\t},\n+\t}\n+\n+\t// Write bundle to disk\n+\tjsonBundle, err := json.Marshal(b)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tbundlePath := filepath.Join(td, \"bundle.sig\")\n+\tif err := os.WriteFile(bundlePath, jsonBundle, 0644); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\treturn bundlePath\n+}\n+\n+func TestVerifyBlobCmdWithBundle(t *testing.T) {\n+\tkeyless := newKeylessStack(t)\n+\n+\tt.Run(\"Normal verification\", func(t *testing.T) {\n+\t\tidentity := \"hello@foo.com\"\n+\t\tissuer := \"issuer\"\n+\t\tleafCert, _, leafPemCert, signer := keyless.genLeafCert(t, identity, issuer)\n+\n+\t\t// Create blob\n+\t\tblob := \"someblob\"\n+\n+\t\t// Sign blob with private key\n+\t\tsig, err := signer.SignMessage(bytes.NewReader([]byte(blob)))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\t// Create bundle\n+\t\tentry := genRekorEntry(t, hashedrekord.KIND, hashedrekord.New().DefaultVersion(), []byte(blob), leafPemCert, sig)\n+\t\tb := createBundle(t, sig, leafPemCert, keyless.rekorLogID, leafCert.NotBefore.Unix()+1, entry)\n+\t\tb.Bundle.SignedEntryTimestamp = keyless.rekorSignPayload(t, b.Bundle.Payload)\n+\t\tbundlePath := writeBundleFile(t, keyless.td, b, \"bundle.json\")\n+\t\tblobPath := writeBlobFile(t, keyless.td, blob, \"blob.txt\")\n+\n+\t\t// Verify command\n+\t\terr = VerifyBlobCmd(context.Background(),\n+\t\t\toptions.KeyOpts{BundlePath: bundlePath},\n+\t\t\t\"\",       /*certRef*/ // Cert is fetched from bundle\n+\t\t\tidentity, /*certEmail*/\n+\t\t\tissuer,   /*certOidcIssuer*/\n+\t\t\t\"\",       /*certChain*/ // Chain is fetched from TUF/SIGSTORE_ROOT_FILE\n+\t\t\t\"\",       /*sigRef*/    // Sig is fetched from bundle\n+\t\t\tblobPath, /*blobRef*/\n+\t\t\t// GitHub identity flags start\n+\t\t\t\"\", \"\", \"\", \"\", \"\",\n+\t\t\t// GitHub identity flags end\n+\t\t\tfalse /*enforceSCT*/)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t})\n+\tt.Run(\"Mismatched cert/sig\", func(t *testing.T) {\n+\t\t// This test ensures that the signature and cert at the top level in the LocalSignedPayload must be identical to the ones in the RekorBundle.\n+\t\tidentity := \"hello@foo.com\"\n+\t\tissuer := \"issuer\"\n+\t\tleafCert, _, leafPemCert, signer := keyless.genLeafCert(t, identity, issuer)\n+\t\t_, _, leafPemCert2, signer2 := keyless.genLeafCert(t, identity, issuer)\n+\n+\t\t// Create blob\n+\t\tblob := \"someblob\"\n+\n+\t\tsig, err := signer.SignMessage(bytes.NewReader([]byte(blob)))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\tsig2, err := signer2.SignMessage(bytes.NewReader([]byte(blob)))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\t// Create bundle\n+\t\tentry := genRekorEntry(t, hashedrekord.KIND, hashedrekord.New().DefaultVersion(), []byte(blob), leafPemCert2, sig2)\n+\t\tb := createBundle(t, sig, leafPemCert, keyless.rekorLogID, leafCert.NotBefore.Unix()+1, entry)\n+\t\tb.Bundle.SignedEntryTimestamp = keyless.rekorSignPayload(t, b.Bundle.Payload)\n+\t\tbundlePath := writeBundleFile(t, keyless.td, b, \"bundle.json\")\n+\t\tblobPath := writeBlobFile(t, keyless.td, blob, \"blob.txt\")\n+\n+\t\t// Verify command\n+\t\terr = VerifyBlobCmd(context.Background(),\n+\t\t\toptions.KeyOpts{BundlePath: bundlePath},\n+\t\t\t\"\",       /*certRef*/ // Cert is fetched from bundle\n+\t\t\t\"\",       /*certEmail*/\n+\t\t\t\"\",       /*certOidcIssuer*/\n+\t\t\t\"\",       /*certChain*/ // Chain is fetched from TUF/SIGSTORE_ROOT_FILE\n+\t\t\t\"\",       /*sigRef*/    // Sig is fetched from bundle\n+\t\t\tblobPath, /*blobRef*/\n+\t\t\t// GitHub identity flags start\n+\t\t\t\"\", \"\", \"\", \"\", \"\",\n+\t\t\t// GitHub identity flags end\n+\t\t\tfalse /*enforceSCT*/)\n+\t\tif err == nil {\n+\t\t\tt.Fatal(\"expecting err due to mismatched signatures, got nil\")\n+\t\t}\n+\t})\n+\tt.Run(\"Expired cert\", func(t *testing.T) {\n+\t\tidentity := \"hello@foo.com\"\n+\t\tissuer := \"issuer\"\n+\t\tleafCert, _, leafPemCert, signer := keyless.genLeafCert(t, identity, issuer)\n+\n+\t\t// Create blob\n+\t\tblob := \"someblob\"\n+\n+\t\t// Sign blob with private key\n+\t\tsig, err := signer.SignMessage(bytes.NewReader([]byte(blob)))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\t// Create bundle\n+\t\tentry := genRekorEntry(t, hashedrekord.KIND, hashedrekord.New().DefaultVersion(), []byte(blob), leafPemCert, sig)\n+\t\tb := createBundle(t, sig, leafPemCert, keyless.rekorLogID, leafCert.NotBefore.Unix()-1, entry)\n+\t\tb.Bundle.SignedEntryTimestamp = keyless.rekorSignPayload(t, b.Bundle.Payload)\n+\t\tbundlePath := writeBundleFile(t, keyless.td, b, \"bundle.json\")\n+\t\tblobPath := writeBlobFile(t, keyless.td, blob, \"blob.txt\")\n+\n+\t\t// Verify command\n+\t\terr = VerifyBlobCmd(context.Background(),\n+\t\t\toptions.KeyOpts{BundlePath: bundlePath},\n+\t\t\t\"\",       /*certRef*/ // Cert is fetched from bundle\n+\t\t\t\"\",       /*certEmail*/\n+\t\t\t\"\",       /*certOidcIssuer*/\n+\t\t\t\"\",       /*certChain*/ // Chain is fetched from TUF/SIGSTORE_ROOT_FILE\n+\t\t\t\"\",       /*sigRef*/    // Sig is fetched from bundle\n+\t\t\tblobPath, /*blobRef*/\n+\t\t\t// GitHub identity flags start\n+\t\t\t\"\", \"\", \"\", \"\", \"\",\n+\t\t\t// GitHub identity flags end\n+\t\t\tfalse /*enforceSCT*/)\n+\t\tif err == nil {\n+\t\t\tt.Fatal(\"expected error due to expired cert, received nil\")\n+\t\t}\n+\t})\n+\tt.Run(\"Attestation\", func(t *testing.T) {\n+\t\tidentity := \"hello@foo.com\"\n+\t\tissuer := \"issuer\"\n+\t\tleafCert, _, leafPemCert, signer := keyless.genLeafCert(t, identity, issuer)\n+\n+\t\tstmt := `{\"_type\":\"https://in-toto.io/Statement/v0.1\",\"predicateType\":\"customFoo\",\"subject\":[{\"name\":\"subject\",\"digest\":{\"sha256\":\"deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef\"}}],\"predicate\":{}}`\n+\t\twrapped := dsse.WrapSigner(signer, ctypes.IntotoPayloadType)\n+\t\tsignedPayload, err := wrapped.SignMessage(bytes.NewReader([]byte(stmt)), signatureoptions.WithContext(context.Background()))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\t// intoto sig = json-serialized dsse envelope\n+\t\tsig := signedPayload\n+\n+\t\t// Create bundle\n+\t\tentry := genRekorEntry(t, intoto.KIND, intoto.New().DefaultVersion(), signedPayload, leafPemCert, sig)\n+\t\tb := createBundle(t, sig, leafPemCert, keyless.rekorLogID, leafCert.NotBefore.Unix()+1, entry)\n+\t\tb.Bundle.SignedEntryTimestamp = keyless.rekorSignPayload(t, b.Bundle.Payload)\n+\t\tbundlePath := writeBundleFile(t, keyless.td, b, \"bundle.json\")\n+\t\tblobPath := writeBlobFile(t, keyless.td, string(signedPayload), \"attestation.txt\")\n+\n+\t\t// Verify command\n+\t\terr = VerifyBlobCmd(context.Background(),\n+\t\t\toptions.KeyOpts{BundlePath: bundlePath},\n+\t\t\t\"\",       /*certRef*/ // Cert is fetched from bundle\n+\t\t\t\"\",       /*certEmail*/\n+\t\t\t\"\",       /*certOidcIssuer*/\n+\t\t\t\"\",       /*certChain*/ // Chain is fetched from TUF/SIGSTORE_ROOT_FILE\n+\t\t\t\"\",       /*sigRef*/    // Sig is fetched from bundle\n+\t\t\tblobPath, /*blobRef*/\n+\t\t\t// GitHub identity flags start\n+\t\t\t\"\", \"\", \"\", \"\", \"\",\n+\t\t\t// GitHub identity flags end\n+\t\t\tfalse /*enforceSCT*/)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t})\n+\tt.Run(\"Invalid blob signature\", func(t *testing.T) {\n+\t\tidentity := \"hello@foo.com\"\n+\t\tissuer := \"issuer\"\n+\t\tleafCert, _, leafPemCert, signer := keyless.genLeafCert(t, identity, issuer)\n+\n+\t\t// Create blob\n+\t\tblob := \"someblob\"\n+\n+\t\t// Sign blob with private key\n+\t\tsig, err := signer.SignMessage(bytes.NewReader([]byte(blob)))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\t// Create bundle\n+\t\tentry := genRekorEntry(t, hashedrekord.KIND, hashedrekord.New().DefaultVersion(), []byte(blob), leafPemCert, sig)\n+\t\tb := createBundle(t, sig, leafPemCert, keyless.rekorLogID, leafCert.NotBefore.Unix()+1, entry)\n+\t\tb.Bundle.SignedEntryTimestamp = []byte{'i', 'n', 'v', 'a', 'l', 'i', 'd'}\n+\t\tbundlePath := writeBundleFile(t, keyless.td, b, \"bundle.json\")\n+\t\tblobPath := writeBlobFile(t, keyless.td, blob, \"blob.txt\")\n+\n+\t\t// Verify command\n+\t\terr = VerifyBlobCmd(context.Background(),\n+\t\t\toptions.KeyOpts{BundlePath: bundlePath},\n+\t\t\t\"\",       /*certRef*/ // Cert is fetched from bundle\n+\t\t\t\"\",       /*certEmail*/\n+\t\t\t\"\",       /*certOidcIssuer*/\n+\t\t\t\"\",       /*certChain*/ // Chain is fetched from TUF/SIGSTORE_ROOT_FILE\n+\t\t\t\"\",       /*sigRef*/    // Sig is fetched from bundle\n+\t\t\tblobPath, /*blobRef*/\n+\t\t\t// GitHub identity flags start\n+\t\t\t\"\", \"\", \"\", \"\", \"\",\n+\t\t\t// GitHub identity flags end\n+\t\t\tfalse /*enforceSCT*/)\n+\t\tif err == nil || !strings.Contains(err.Error(), \"unable to verify SET\") {\n+\t\t\tt.Fatalf(\"expected error verifying SET, got %v\", err)\n+\t\t}\n+\t})\n+\tt.Run(\"Mismatched certificate email\", func(t *testing.T) {\n+\t\tidentity := \"hello@foo.com\"\n+\t\tissuer := \"issuer\"\n+\t\tleafCert, _, leafPemCert, signer := keyless.genLeafCert(t, identity, issuer)\n+\n+\t\t// Create blob\n+\t\tblob := \"someblob\"\n+\n+\t\t// Sign blob with private key\n+\t\tsig, err := signer.SignMessage(bytes.NewReader([]byte(blob)))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\t// Create bundle\n+\t\tentry := genRekorEntry(t, hashedrekord.KIND, hashedrekord.New().DefaultVersion(), []byte(blob), leafPemCert, sig)\n+\t\tb := createBundle(t, sig, leafPemCert, keyless.rekorLogID, leafCert.NotBefore.Unix()+1, entry)\n+\t\tb.Bundle.SignedEntryTimestamp = keyless.rekorSignPayload(t, b.Bundle.Payload)\n+\t\tbundlePath := writeBundleFile(t, keyless.td, b, \"bundle.json\")\n+\t\tblobPath := writeBlobFile(t, keyless.td, blob, \"blob.txt\")\n+\n+\t\t// Verify command\n+\t\terr = VerifyBlobCmd(context.Background(),\n+\t\t\toptions.KeyOpts{BundlePath: bundlePath},\n+\t\t\t\"\",                    /*certRef*/ // Cert is fetched from bundle\n+\t\t\t\"invalid@example.com\", /*certEmail*/\n+\t\t\tissuer,                /*certOidcIssuer*/\n+\t\t\t\"\",                    /*certChain*/ // Chain is fetched from TUF/SIGSTORE_ROOT_FILE\n+\t\t\t\"\",                    /*sigRef*/    // Sig is fetched from bundle\n+\t\t\tblobPath,              /*blobRef*/\n+\t\t\t// GitHub identity flags start\n+\t\t\t\"\", \"\", \"\", \"\", \"\",\n+\t\t\t// GitHub identity flags end\n+\t\t\tfalse /*enforceSCT*/)\n+\t\tif err == nil || !strings.Contains(err.Error(), \"expected email not found in certificate\") {\n+\t\t\tt.Fatalf(\"expected error with mismatched identity, got %v\", err)\n+\t\t}\n+\t})\n+\tt.Run(\"Mismatched certificate issuer\", func(t *testing.T) {\n+\t\tidentity := \"hello@foo.com\"\n+\t\tissuer := \"issuer\"\n+\t\tleafCert, _, leafPemCert, signer := keyless.genLeafCert(t, identity, issuer)\n+\n+\t\t// Create blob\n+\t\tblob := \"someblob\"\n+\n+\t\t// Sign blob with private key\n+\t\tsig, err := signer.SignMessage(bytes.NewReader([]byte(blob)))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\t// Create bundle\n+\t\tentry := genRekorEntry(t, hashedrekord.KIND, hashedrekord.New().DefaultVersion(), []byte(blob), leafPemCert, sig)\n+\t\tb := createBundle(t, sig, leafPemCert, keyless.rekorLogID, leafCert.NotBefore.Unix()+1, entry)\n+\t\tb.Bundle.SignedEntryTimestamp = keyless.rekorSignPayload(t, b.Bundle.Payload)\n+\t\tbundlePath := writeBundleFile(t, keyless.td, b, \"bundle.json\")\n+\t\tblobPath := writeBlobFile(t, keyless.td, blob, \"blob.txt\")\n+\n+\t\t// Verify command\n+\t\terr = VerifyBlobCmd(context.Background(),\n+\t\t\toptions.KeyOpts{BundlePath: bundlePath},\n+\t\t\t\"\",        /*certRef*/ // Cert is fetched from bundle\n+\t\t\tidentity,  /*certEmail*/\n+\t\t\t\"invalid\", /*certOidcIssuer*/\n+\t\t\t\"\",        /*certChain*/ // Chain is fetched from TUF/SIGSTORE_ROOT_FILE\n+\t\t\t\"\",        /*sigRef*/    // Sig is fetched from bundle\n+\t\t\tblobPath,  /*blobRef*/\n+\t\t\t// GitHub identity flags start\n+\t\t\t\"\", \"\", \"\", \"\", \"\",\n+\t\t\t// GitHub identity flags end\n+\t\t\tfalse /*enforceSCT*/)\n+\t\tif err == nil || !strings.Contains(err.Error(), \"expected oidc issuer not found in certificate\") {\n+\t\t\tt.Fatalf(\"expected error with mismatched issuer, got %v\", err)\n+\t\t}\n+\t})\n+}\n+\n+type keylessStack struct {\n+\trootCert    *x509.Certificate\n+\trootPriv    *ecdsa.PrivateKey\n+\trootPemCert []byte\n+\tsubCert     *x509.Certificate\n+\tsubPriv     *ecdsa.PrivateKey\n+\tsubPemCert  []byte\n+\trekorSigner *signature.ECDSASignerVerifier\n+\trekorLogID  string\n+\ttd          string // temporary directory\n+}\n+\n+func newKeylessStack(t *testing.T) *keylessStack {\n+\tstack := &keylessStack{td: t.TempDir()}\n+\tstack.rootCert, stack.rootPriv, _ = test.GenerateRootCa()\n+\tstack.rootPemCert, _ = cryptoutils.MarshalCertificateToPEM(stack.rootCert)\n+\tstack.subCert, stack.subPriv, _ = test.GenerateSubordinateCa(stack.rootCert, stack.rootPriv)\n+\tstack.subPemCert, _ = cryptoutils.MarshalCertificateToPEM(stack.subCert)\n+\n+\tstack.genChainFile(t)\n+\tstack.genRekor(t)\n+\treturn stack\n+}\n+\n+func (s *keylessStack) genLeafCert(t *testing.T, subject string, issuer string) (*x509.Certificate, *ecdsa.PrivateKey, []byte, *signature.ECDSASignerVerifier) {\n+\tcert, priv, _ := test.GenerateLeafCert(subject, issuer, s.subCert, s.subPriv)\n+\tpemCert, _ := cryptoutils.MarshalCertificateToPEM(cert)\n+\tsigner, err := signature.LoadECDSASignerVerifier(priv, crypto.SHA256)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\treturn cert, priv, pemCert, signer\n+}\n+\n+func (s *keylessStack) genChainFile(t *testing.T) {\n+\tvar chain []byte\n+\tchain = append(chain, s.subPemCert...)\n+\tchain = append(chain, s.rootPemCert...)\n+\ttmpChainFile, err := os.CreateTemp(s.td, \"cosign_fulcio_chain_*.cert\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to create temp chain file: %v\", err)\n+\t}\n+\tdefer tmpChainFile.Close()\n+\tif _, err := tmpChainFile.Write(chain); err != nil {\n+\t\tt.Fatalf(\"failed to write chain file: %v\", err)\n+\t}\n+\t// Override for Fulcio root so it doesn't use TUF\n+\tt.Setenv(\"SIGSTORE_ROOT_FILE\", tmpChainFile.Name())\n+}\n+\n+func (s *keylessStack) genRekor(t *testing.T) {\n+\t// Create Rekor private key and write to disk\n+\trekorPriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\ts.rekorSigner, err = signature.LoadECDSASignerVerifier(rekorPriv, crypto.SHA256)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\trekorPub := s.rekorSigner.Public()\n+\tpemRekor, err := cryptoutils.MarshalPublicKeyToPEM(rekorPub)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\ttmpRekorPubFile, err := os.CreateTemp(s.td, \"cosign_rekor_pub_*.key\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to create temp rekor pub file: %v\", err)\n+\t}\n+\tdefer tmpRekorPubFile.Close()\n+\tif _, err := tmpRekorPubFile.Write(pemRekor); err != nil {\n+\t\tt.Fatalf(\"failed to write rekor pub file: %v\", err)\n+\t}\n+\n+\t// Calculate log ID, the digest of the Rekor public key\n+\ts.rekorLogID, err = getLogID(rekorPub)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t// Override for Rekor public key so it doesn't use TUF\n+\tt.Setenv(\"SIGSTORE_REKOR_PUBLIC_KEY\", tmpRekorPubFile.Name())\n+}\n+func (s *keylessStack) rekorSignPayload(t *testing.T, payload bundle.RekorPayload) []byte {\n+\t// Marshal payload, sign, and return SET\n+\tjsonPayload, err := json.Marshal(payload)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tcanonicalized, err := jsoncanonicalizer.Transform(jsonPayload)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tbundleSig, err := s.rekorSigner.SignMessage(bytes.NewReader(canonicalized))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\treturn bundleSig\n+}\n+\n+// getLogID calculates the digest of a PKIX-encoded public key\n+func getLogID(pub crypto.PublicKey) (string, error) {\n+\tpubBytes, err := x509.MarshalPKIXPublicKey(pub)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tdigest := sha256.Sum256(pubBytes)\n+\treturn hex.EncodeToString(digest[:]), nil\n+}\n+\n+func genRekorEntry(t *testing.T, kind, version string, artifact []byte, cert []byte, sig []byte) string {\n+\t// Generate the Rekor Entry\n+\tentryImpl, err := createEntry(context.Background(), kind, version, artifact, cert, sig)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tentryBytes, err := entryImpl.Canonicalize(context.Background())\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\treturn base64.StdEncoding.EncodeToString(entryBytes)\n+}\n+\n+func createBundle(t *testing.T, sig []byte, certPem []byte, logID string, integratedTime int64, rekorEntry string) *cosign.LocalSignedPayload {\n+\t// Create bundle with:\n+\t// * Blob signature\n+\t// * Signing certificate\n+\t// * Bundle with a payload and signature over the payload\n+\tb := &cosign.LocalSignedPayload{\n+\t\tBase64Signature: base64.StdEncoding.EncodeToString(sig),\n+\t\tCert:            string(certPem),\n+\t\tBundle: &bundle.RekorBundle{\n+\t\t\tSignedEntryTimestamp: []byte{},\n+\t\t\tPayload: bundle.RekorPayload{\n+\t\t\t\tLogID:          logID,\n+\t\t\t\tIntegratedTime: integratedTime,\n+\t\t\t\tLogIndex:       1,\n+\t\t\t\tBody:           rekorEntry,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\treturn b\n+}\n+\n+func createEntry(ctx context.Context, kind, apiVersion string, blobBytes, certBytes, sigBytes []byte) (types.EntryImpl, error) {\n+\tprops := types.ArtifactProperties{\n+\t\tPublicKeyBytes: certBytes,\n+\t\tPKIFormat:      string(pki.X509),\n+\t}\n+\tswitch kind {\n+\tcase rekord.KIND:\n+\t\tprops.ArtifactBytes = blobBytes\n+\t\tprops.SignatureBytes = sigBytes\n+\tcase hashedrekord.KIND:\n+\t\tblobHash := sha256.Sum256(blobBytes)\n+\t\tprops.ArtifactHash = strings.ToLower(hex.EncodeToString(blobHash[:]))\n+\t\tprops.SignatureBytes = sigBytes\n+\tcase intoto.KIND:\n+\t\tprops.ArtifactBytes = blobBytes\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"unexpected entry kind: %s\", kind)\n+\t}\n+\tproposedEntry, err := types.NewProposedEntry(ctx, kind, apiVersion, props)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn types.NewEntry(proposedEntry)\n+}\n+\n+func writeBundleFile(t *testing.T, td string, b *cosign.LocalSignedPayload, name string) string {\n+\t// Write bundle to disk\n+\tjsonBundle, err := json.Marshal(b)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tbundlePath := filepath.Join(td, name)\n+\tif err := os.WriteFile(bundlePath, jsonBundle, 0644); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\treturn bundlePath\n+}\n+\n+func writeBlobFile(t *testing.T, td string, blob string, name string) string {\n+\t// Write blob to disk\n+\tblobPath := filepath.Join(td, name)\n+\tif err := os.WriteFile(blobPath, []byte(blob), 0644); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\treturn blobPath\n+}"
        },
        {
          "filename": "internal/pkg/cosign/rekor/mock/mock_rekor_client.go",
          "status": "modified",
          "additions": 28,
          "deletions": 51,
          "patch": "@@ -15,81 +15,58 @@\n package mock\n \n import (\n-\t\"encoding/base64\"\n-\t\"encoding/hex\"\n+\t\"errors\"\n \n \t\"github.com/go-openapi/runtime\"\n-\t\"github.com/transparency-dev/merkle/rfc6962\"\n \n \t\"github.com/sigstore/rekor/pkg/generated/client/entries\"\n \t\"github.com/sigstore/rekor/pkg/generated/models\"\n )\n \n-var (\n-\tlea = models.LogEntryAnon{\n-\t\tAttestation:    &models.LogEntryAnonAttestation{},\n-\t\tBody:           base64.StdEncoding.EncodeToString([]byte(\"asdf\")),\n-\t\tIntegratedTime: new(int64),\n-\t\tLogID:          new(string),\n-\t\tLogIndex:       new(int64),\n-\t\tVerification: &models.LogEntryAnonVerification{\n-\t\t\tInclusionProof: &models.InclusionProof{\n-\t\t\t\tRootHash: new(string),\n-\t\t\t\tTreeSize: new(int64),\n-\t\t\t\tLogIndex: new(int64),\n-\t\t\t},\n-\t\t},\n-\t}\n-\tdata = models.LogEntry{\n-\t\tuuid(lea): lea,\n-\t}\n-)\n-\n-// uuid generates the UUID for the given LogEntry.\n-// This is effectively a reimplementation of\n-// pkg/cosign/tlog.go -> verifyUUID / ComputeLeafHash, but separated\n-// to avoid a circular dependency.\n-// TODO?: Perhaps we should refactor the tlog libraries into a separate\n-// package?\n-func uuid(e models.LogEntryAnon) string {\n-\tentryBytes, err := base64.StdEncoding.DecodeString(e.Body.(string))\n-\tif err != nil {\n-\t\tpanic(err)\n-\t}\n-\treturn hex.EncodeToString(rfc6962.DefaultHasher.HashLeaf(entryBytes))\n-}\n-\n // EntriesClient is a client that implements entries.ClientService for Rekor\n // To use:\n // var mClient client.Rekor\n-// mClient.entries = &EntriesClient{}\n+// mClient.Entries = &logEntry\n type EntriesClient struct {\n-\tEntries models.LogEntry\n+\tEntries *models.LogEntry\n }\n \n func (m *EntriesClient) CreateLogEntry(params *entries.CreateLogEntryParams, opts ...entries.ClientOption) (*entries.CreateLogEntryCreated, error) {\n-\treturn &entries.CreateLogEntryCreated{\n-\t\tETag:     \"\",\n-\t\tLocation: \"\",\n-\t\tPayload:  data,\n-\t}, nil\n+\tif m.Entries != nil {\n+\t\treturn &entries.CreateLogEntryCreated{\n+\t\t\tETag:     \"\",\n+\t\t\tLocation: \"\",\n+\t\t\tPayload:  *m.Entries,\n+\t\t}, nil\n+\t}\n+\treturn nil, errors.New(\"entry not provided\")\n }\n \n func (m *EntriesClient) GetLogEntryByIndex(params *entries.GetLogEntryByIndexParams, opts ...entries.ClientOption) (*entries.GetLogEntryByIndexOK, error) {\n-\treturn &entries.GetLogEntryByIndexOK{\n-\t\tPayload: data,\n-\t}, nil\n+\tif m.Entries != nil {\n+\t\treturn &entries.GetLogEntryByIndexOK{\n+\t\t\tPayload: *m.Entries,\n+\t\t}, nil\n+\t}\n+\treturn nil, errors.New(\"entry not provided\")\n }\n \n func (m *EntriesClient) GetLogEntryByUUID(params *entries.GetLogEntryByUUIDParams, opts ...entries.ClientOption) (*entries.GetLogEntryByUUIDOK, error) {\n-\treturn &entries.GetLogEntryByUUIDOK{\n-\t\tPayload: data,\n-\t}, nil\n+\tif m.Entries != nil {\n+\t\treturn &entries.GetLogEntryByUUIDOK{\n+\t\t\tPayload: *m.Entries,\n+\t\t}, nil\n+\t}\n+\treturn nil, errors.New(\"entry not provided\")\n }\n \n func (m *EntriesClient) SearchLogQuery(params *entries.SearchLogQueryParams, opts ...entries.ClientOption) (*entries.SearchLogQueryOK, error) {\n+\tresp := []models.LogEntry{}\n+\tif m.Entries != nil {\n+\t\tresp = append(resp, *m.Entries)\n+\t}\n \treturn &entries.SearchLogQueryOK{\n-\t\tPayload: []models.LogEntry{data},\n+\t\tPayload: resp,\n \t}, nil\n }\n "
        },
        {
          "filename": "internal/pkg/cosign/rekor/signer_test.go",
          "status": "modified",
          "additions": 8,
          "deletions": 1,
          "patch": "@@ -22,10 +22,12 @@ import (\n \t\"strings\"\n \t\"testing\"\n \n+\t\"github.com/go-openapi/swag\"\n \t\"github.com/sigstore/cosign/internal/pkg/cosign/payload\"\n \t\"github.com/sigstore/cosign/internal/pkg/cosign/rekor/mock\"\n \t\"github.com/sigstore/cosign/pkg/cosign\"\n \t\"github.com/sigstore/rekor/pkg/generated/client\"\n+\t\"github.com/sigstore/rekor/pkg/generated/models\"\n \t\"github.com/sigstore/sigstore/pkg/signature\"\n )\n \n@@ -48,7 +50,12 @@ func TestSigner(t *testing.T) {\n \n \t// Mock out Rekor client\n \tvar mClient client.Rekor\n-\tmClient.Entries = &mock.EntriesClient{}\n+\n+\tmClient.Entries = &mock.EntriesClient{\n+\t\tEntries: &models.LogEntry{\"123\": models.LogEntryAnon{\n+\t\t\tLogIndex: swag.Int64(123),\n+\t\t}},\n+\t}\n \n \ttestSigner := NewSigner(payloadSigner, &mClient)\n "
        },
        {
          "filename": "pkg/cosign/verify.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -992,7 +992,7 @@ func VerifySET(bundlePayload cbundle.RekorPayload, signature []byte, pub *ecdsa.\n \t// verify the SET against the public key\n \thash := sha256.Sum256(canonicalized)\n \tif !ecdsa.VerifyASN1(pub, hash[:], signature) {\n-\t\treturn &VerificationError{\"unable to verify\"}\n+\t\treturn &VerificationError{\"unable to verify SET\"}\n \t}\n \treturn nil\n }"
        },
        {
          "filename": "pkg/cosign/verify_test.go",
          "status": "modified",
          "additions": 40,
          "deletions": 1,
          "patch": "@@ -23,6 +23,7 @@ import (\n \t\"crypto/sha256\"\n \t\"crypto/x509\"\n \t\"encoding/base64\"\n+\t\"encoding/hex\"\n \t\"encoding/json\"\n \t\"encoding/pem\"\n \t\"errors\"\n@@ -46,11 +47,13 @@ import (\n \t\"github.com/sigstore/cosign/pkg/types\"\n \t\"github.com/sigstore/cosign/test\"\n \t\"github.com/sigstore/rekor/pkg/generated/client\"\n+\t\"github.com/sigstore/rekor/pkg/generated/models\"\n \trtypes \"github.com/sigstore/rekor/pkg/types\"\n \t\"github.com/sigstore/sigstore/pkg/cryptoutils\"\n \t\"github.com/sigstore/sigstore/pkg/signature\"\n \t\"github.com/sigstore/sigstore/pkg/signature/options\"\n \t\"github.com/stretchr/testify/require\"\n+\t\"github.com/transparency-dev/merkle/rfc6962\"\n )\n \n type mockVerifier struct {\n@@ -343,6 +346,40 @@ func TestVerifyImageSignatureWithExistingSub(t *testing.T) {\n \t}\n }\n \n+var (\n+\tlea = models.LogEntryAnon{\n+\t\tAttestation:    &models.LogEntryAnonAttestation{},\n+\t\tBody:           base64.StdEncoding.EncodeToString([]byte(\"asdf\")),\n+\t\tIntegratedTime: new(int64),\n+\t\tLogID:          new(string),\n+\t\tLogIndex:       new(int64),\n+\t\tVerification: &models.LogEntryAnonVerification{\n+\t\t\tInclusionProof: &models.InclusionProof{\n+\t\t\t\tRootHash: new(string),\n+\t\t\t\tTreeSize: new(int64),\n+\t\t\t\tLogIndex: new(int64),\n+\t\t\t},\n+\t\t},\n+\t}\n+\tdata = models.LogEntry{\n+\t\tuuid(lea): lea,\n+\t}\n+)\n+\n+// uuid generates the UUID for the given LogEntry.\n+// This is effectively a reimplementation of\n+// pkg/cosign/tlog.go -> verifyUUID / ComputeLeafHash, but separated\n+// to avoid a circular dependency.\n+// TODO?: Perhaps we should refactor the tlog libraries into a separate\n+// package?\n+func uuid(e models.LogEntryAnon) string {\n+\tentryBytes, err := base64.StdEncoding.DecodeString(e.Body.(string))\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\treturn hex.EncodeToString(rfc6962.DefaultHasher.HashLeaf(entryBytes))\n+}\n+\n // This test ensures that image signature validation fails properly if we are\n // using a SigVerifier with Rekor.\n // See https://github.com/sigstore/cosign/issues/1816 for more details.\n@@ -361,7 +398,9 @@ func TestVerifyImageSignatureWithSigVerifierAndRekor(t *testing.T) {\n \t// tlog entry for the signature during validation (even though it does not\n \t// match the underlying data / key)\n \tmClient := new(client.Rekor)\n-\tmClient.Entries = &mock.EntriesClient{}\n+\tmClient.Entries = &mock.EntriesClient{\n+\t\tEntries: &data,\n+\t}\n \n \tif _, err := VerifyImageSignature(context.TODO(), ociSig, v1.Hash{}, &CheckOpts{\n \t\tSigVerifier: sv,"
        },
        {
          "filename": "test/cert_utils.go",
          "status": "modified",
          "additions": 29,
          "deletions": 1,
          "patch": "@@ -69,7 +69,7 @@ func GenerateRootCa() (*x509.Certificate, *ecdsa.PrivateKey, error) {\n \t\t\tCommonName:   \"sigstore\",\n \t\t\tOrganization: []string{\"sigstore.dev\"},\n \t\t},\n-\t\tNotBefore:             time.Now().Add(-5 * time.Minute),\n+\t\tNotBefore:             time.Now().Add(-5 * time.Hour),\n \t\tNotAfter:              time.Now().Add(5 * time.Hour),\n \t\tKeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageCRLSign,\n \t\tBasicConstraintsValid: true,\n@@ -117,6 +117,34 @@ func GenerateSubordinateCa(rootTemplate *x509.Certificate, rootPriv crypto.Signe\n \treturn cert, priv, nil\n }\n \n+func GenerateLeafCertWithExpiration(subject string, oidcIssuer string, expiration time.Time,\n+\tpriv *ecdsa.PrivateKey,\n+\tparentTemplate *x509.Certificate, parentPriv crypto.Signer) (*x509.Certificate, error) {\n+\tcertTemplate := &x509.Certificate{\n+\t\tSerialNumber:   big.NewInt(1),\n+\t\tEmailAddresses: []string{subject},\n+\t\tNotBefore:      expiration,\n+\t\tNotAfter:       expiration.Add(10 * time.Minute),\n+\t\tKeyUsage:       x509.KeyUsageDigitalSignature,\n+\t\tExtKeyUsage:    []x509.ExtKeyUsage{x509.ExtKeyUsageCodeSigning},\n+\t\tIsCA:           false,\n+\t\tExtraExtensions: []pkix.Extension{{\n+\t\t\t// OID for OIDC Issuer extension\n+\t\t\tId:       asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 1},\n+\t\t\tCritical: false,\n+\t\t\tValue:    []byte(oidcIssuer),\n+\t\t},\n+\t\t},\n+\t}\n+\n+\tcert, err := createCertificate(certTemplate, parentTemplate, &priv.PublicKey, parentPriv)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn cert, nil\n+}\n+\n func GenerateLeafCert(subject string, oidcIssuer string, parentTemplate *x509.Certificate, parentPriv crypto.Signer) (*x509.Certificate, *ecdsa.PrivateKey, error) {\n \tcertTemplate := &x509.Certificate{\n \t\tSerialNumber:   big.NewInt(1),"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 5,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "accc80a840524890790c5c368fee26e22ec60bda",
            "date": "2025-01-13T20:41:02Z",
            "author_login": "codysoyland"
          },
          {
            "sha": "e5aa062fa9e4c8b893cf14e77f07127031395ca9",
            "date": "2025-01-13T17:30:27Z",
            "author_login": "haydentherapper"
          },
          {
            "sha": "d01988ed7edc1d9c67d3383e7a02b988ba7d14fd",
            "date": "2025-01-13T03:54:54Z",
            "author_login": "nianyush"
          },
          {
            "sha": "87c08b00fca8a96a2ef756cee3953372a5783a45",
            "date": "2025-01-10T08:26:43Z",
            "author_login": "cpanato"
          },
          {
            "sha": "342f8d89f88f1de022d35d720b54322cfe7352fb",
            "date": "2025-01-09T16:07:26Z",
            "author_login": "cmurphy"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-347",
    "description": "Cosign is a project under the sigstore organization which aims to make signatures invisible infrastructure. In versions prior to 1.12.0 a number of vulnerabilities have been found in cosign verify-blob, where Cosign would successfully verify an artifact when verification should have failed. First a cosign bundle can be crafted to successfully verify a blob even if the embedded rekorBundle does not reference the given signature. Second, when providing identity flags, the email and issuer of a certificate is not checked when verifying a Rekor bundle, and the GitHub Actions identity is never checked. Third, providing an invalid Rekor bundle without the experimental flag results in a successful verification. And fourth an invalid transparency log entry will result in immediate success for verification. Details and examples of these issues can be seen in the GHSA-8gw7-4j42-w388 advisory linked. Users are advised to upgrade to 1.12.0. There are no known workarounds for these issues.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-09-14T20:15:09.860",
    "last_modified": "2024-11-21T07:12:16.937",
    "fix_date": "2022-09-14T08:37:41Z"
  },
  "references": [
    {
      "url": "https://github.com/sigstore/cosign/commit/80b79ed8b4d28ccbce3d279fd273606b5cddcc25",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sigstore/cosign/security/advisories/GHSA-8gw7-4j42-w388",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Mitigation",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sigstore/cosign/commit/80b79ed8b4d28ccbce3d279fd273606b5cddcc25",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sigstore/cosign/security/advisories/GHSA-8gw7-4j42-w388",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Mitigation",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:39.114993",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "cosign",
    "owner": "sigstore",
    "created_at": "2021-02-04T12:49:39Z",
    "updated_at": "2025-01-26T00:45:59Z",
    "pushed_at": "2025-01-20T16:21:17Z",
    "size": 22982,
    "stars": 4679,
    "forks": 557,
    "open_issues": 253,
    "watchers": 4679,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-1.13"
    ],
    "languages": {
      "Go": 1543441,
      "Shell": 15352,
      "Makefile": 8067,
      "PowerShell": 1530
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:58:53.388122"
  }
}