{
  "cve_id": "CVE-2022-36066",
  "github_data": {
    "repository": "discourse/discourse",
    "fix_commit": "b27d5626d208a22c516a0adfda7554b67b493835",
    "related_commits": [
      "b27d5626d208a22c516a0adfda7554b67b493835",
      "b27d5626d208a22c516a0adfda7554b67b493835"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "b27d5626d208a22c516a0adfda7554b67b493835",
      "commit_date": "2022-09-29T18:00:38Z",
      "author": {
        "login": "CvX",
        "type": "User",
        "stats": {
          "total_commits": 1646,
          "average_weekly_commits": 2.368345323741007,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 242
        }
      },
      "commit_message": {
        "title": "SECURITY: Prevent arbitrary file write when decompressing files (#18421)",
        "length": 327,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 232,
        "additions": 175,
        "deletions": 57
      },
      "files": [
        {
          "filename": "lib/compression/engine.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -22,6 +22,6 @@ def initialize(strategy)\n       @strategy = strategy\n     end\n \n-    delegate :extension, :decompress, :compress, :strip_directory, to: :@strategy\n+    delegate :extension, :decompress, :compress, to: :@strategy\n   end\n end"
        },
        {
          "filename": "lib/compression/gzip.rb",
          "status": "modified",
          "additions": 8,
          "deletions": 2,
          "patch": "@@ -30,8 +30,14 @@ def get_compressed_file_stream(compressed_file_path)\n       yield(gzip)\n     end\n \n-    def build_entry_path(_compressed_file, dest_path, compressed_file_path, entry, _allow_non_root_folder)\n-      compressed_file_path.gsub(extension, '')\n+    def build_entry_path(dest_path, _, compressed_file_path)\n+      basename = File.basename(compressed_file_path)\n+      basename.gsub!(/#{Regexp.escape(extension)}$/, '')\n+      File.join(dest_path, basename)\n+    end\n+\n+    def decompression_results_path(dest_path, compressed_file_path)\n+      build_entry_path(dest_path, nil, compressed_file_path)\n     end\n \n     def extract_file(entry, entry_path, available_size)"
        },
        {
          "filename": "lib/compression/pipeline.rb",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -20,11 +20,11 @@ def compress(path, target_name)\n       end\n     end\n \n-    def decompress(dest_path, compressed_file_path, max_size, allow_non_root_folder: false)\n+    def decompress(dest_path, compressed_file_path, max_size)\n       @strategies.reverse.reduce(compressed_file_path) do |to_decompress, strategy|\n-        last_extension = strategy.extension\n-        strategy.decompress(dest_path, to_decompress, max_size, allow_non_root_folder: allow_non_root_folder)\n-        to_decompress.gsub(last_extension, '')\n+        next_compressed_file = strategy.decompress(dest_path, to_decompress, max_size)\n+        FileUtils.rm_rf(to_decompress)\n+        next_compressed_file\n       end\n     end\n   end"
        },
        {
          "filename": "lib/compression/strategy.rb",
          "status": "modified",
          "additions": 12,
          "deletions": 15,
          "patch": "@@ -9,38 +9,31 @@ def can_handle?(file_name)\n       file_name.include?(extension)\n     end\n \n-    def decompress(dest_path, compressed_file_path, max_size, allow_non_root_folder: false)\n+    def decompress(dest_path, compressed_file_path, max_size)\n       sanitized_compressed_file_path = sanitize_path(compressed_file_path)\n+      sanitized_dest_path = sanitize_path(dest_path)\n \n       get_compressed_file_stream(sanitized_compressed_file_path) do |compressed_file|\n         available_size = calculate_available_size(max_size)\n \n         entries_of(compressed_file).each do |entry|\n-          entry_path = build_entry_path(\n-            compressed_file, sanitize_path(dest_path),\n-            sanitized_compressed_file_path, entry,\n-            allow_non_root_folder\n-          )\n+          entry_path = build_entry_path(sanitized_dest_path, entry, sanitized_compressed_file_path)\n+          if !is_safe_path_for_extraction?(entry_path, sanitized_dest_path)\n+            next\n+          end\n \n+          FileUtils.mkdir_p(File.dirname(entry_path))\n           if is_file?(entry)\n             remaining_size = extract_file(entry, entry_path, available_size)\n             available_size = remaining_size\n           else\n             extract_folder(entry, entry_path)\n           end\n         end\n+        decompression_results_path(sanitized_dest_path, sanitized_compressed_file_path)\n       end\n     end\n \n-    def strip_directory(from, to, relative: false)\n-      sanitized_from = sanitize_path(from) rescue nil\n-      sanitized_to = sanitize_path(to) rescue nil\n-      return unless sanitized_from && sanitized_to\n-\n-      glob_path = relative ? \"#{sanitized_from}/*/*\" : \"#{sanitized_from}/**\"\n-      FileUtils.mv(Dir.glob(glob_path), sanitized_to) if File.directory?(sanitized_from)\n-    end\n-\n     private\n \n     def sanitize_path(filename)\n@@ -92,5 +85,9 @@ def extract_file(entry, entry_path, available_size)\n \n       remaining_size\n     end\n+\n+    def is_safe_path_for_extraction?(path, dest_directory)\n+      File.expand_path(path).start_with?(dest_directory)\n+    end\n   end\n end"
        },
        {
          "filename": "lib/compression/tar.rb",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -26,10 +26,12 @@ def get_compressed_file_stream(compressed_file_path)\n       yield(tar_extract)\n     end\n \n-    def build_entry_path(_compressed_file, dest_path, compressed_file_path, entry, _allow_non_root_folder)\n-      File.join(dest_path, entry.full_name).tap do |entry_path|\n-        FileUtils.mkdir_p(File.dirname(entry_path))\n-      end\n+    def build_entry_path(dest_path, entry, _)\n+      File.join(dest_path, entry.full_name)\n+    end\n+\n+    def decompression_results_path(dest_path, _)\n+      dest_path\n     end\n   end\n end"
        },
        {
          "filename": "lib/compression/zip.rb",
          "status": "modified",
          "additions": 4,
          "deletions": 9,
          "patch": "@@ -35,17 +35,12 @@ def get_compressed_file_stream(compressed_file_path)\n       yield(zip_file)\n     end\n \n-    def build_entry_path(compressed_file, dest_path, compressed_file_path, entry, allow_non_root_folder)\n-      folder_name = compressed_file_path.split('/').last.gsub('.zip', '')\n-      root = root_folder_present?(compressed_file, allow_non_root_folder) ? '' : \"#{folder_name}/\"\n-\n-      File.join(dest_path, \"#{root}#{entry.name}\").tap do |entry_path|\n-        FileUtils.mkdir_p(File.dirname(entry_path))\n-      end\n+    def build_entry_path(dest_path, entry, _)\n+      File.join(dest_path, entry.name)\n     end\n \n-    def root_folder_present?(filenames, allow_non_root_folder)\n-      filenames.map { |p| p.name.split('/').first }.uniq.size == 1 || allow_non_root_folder\n+    def decompression_results_path(dest_path, _)\n+      dest_path\n     end\n \n     def extract_file(entry, entry_path, available_size)"
        },
        {
          "filename": "lib/theme_store/zip_importer.rb",
          "status": "modified",
          "additions": 8,
          "deletions": 1,
          "patch": "@@ -20,7 +20,7 @@ def import!\n     available_size = SiteSetting.decompressed_theme_max_file_size_mb\n     Compression::Engine.engine_for(@original_filename).tap do |engine|\n       engine.decompress(@temp_folder, @filename, available_size)\n-      engine.strip_directory(@temp_folder, @temp_folder, relative: true)\n+      strip_root_directory\n     end\n   rescue RuntimeError\n     raise RemoteTheme::ImportError, I18n.t(\"themes.import_error.unpack_failed\")\n@@ -36,6 +36,13 @@ def version\n     \"\"\n   end\n \n+  def strip_root_directory\n+    root_files = Dir.glob(\"#{@temp_folder}/*\")\n+    if root_files.size == 1 && File.directory?(root_files[0])\n+      FileUtils.mv(Dir.glob(\"#{@temp_folder}/*/*\"), @temp_folder)\n+    end\n+  end\n+\n   def real_path(relative)\n     fullpath = \"#{@temp_folder}/#{relative}\"\n     return nil unless File.exist?(fullpath)"
        },
        {
          "filename": "spec/lib/compression/engine_spec.rb",
          "status": "modified",
          "additions": 131,
          "deletions": 20,
          "patch": "@@ -2,20 +2,22 @@\n \n RSpec.describe Compression::Engine do\n   let(:available_size) { SiteSetting.decompressed_theme_max_file_size_mb }\n+  let(:folder_name) { 'test' }\n+  let(:temp_folder) do\n+    path = \"#{Pathname.new(Dir.tmpdir).realpath}/#{SecureRandom.hex}\"\n+    FileUtils.mkdir(path)\n+    path\n+  end\n \n   before do\n-    @temp_folder = \"#{Pathname.new(Dir.tmpdir).realpath}/#{SecureRandom.hex}\"\n-    @folder_name = 'test'\n-\n-    FileUtils.mkdir(@temp_folder)\n-    Dir.chdir(@temp_folder) do\n-      FileUtils.mkdir_p(\"#{@folder_name}/a\")\n-      File.write(\"#{@folder_name}/hello.txt\", 'hello world')\n-      File.write(\"#{@folder_name}/a/inner\", 'hello world inner')\n+    Dir.chdir(temp_folder) do\n+      FileUtils.mkdir_p(\"#{folder_name}/a\")\n+      File.write(\"#{folder_name}/hello.txt\", 'hello world')\n+      File.write(\"#{folder_name}/a/inner\", 'hello world inner')\n     end\n   end\n \n-  after { FileUtils.rm_rf @temp_folder }\n+  after { FileUtils.rm_rf(temp_folder) }\n \n   it 'raises an exception when the file is not supported' do\n     unknown_extension = 'a_file.crazyext'\n@@ -24,36 +26,145 @@\n \n   describe 'compressing and decompressing files' do\n     before do\n-      Dir.chdir(@temp_folder) do\n-        @compressed_path = Compression::Engine.engine_for(\"#{@folder_name}#{extension}\").compress(@temp_folder, @folder_name)\n-        FileUtils.rm_rf(\"#{@folder_name}/\")\n+      Dir.chdir(temp_folder) do\n+        @compressed_path = Compression::Engine.engine_for(\"#{folder_name}#{extension}\").compress(temp_folder, folder_name)\n+        FileUtils.rm_rf(\"#{folder_name}/\")\n       end\n     end\n \n     context 'when working with zip files' do\n       let(:extension) { '.zip' }\n \n-      it 'decompress the folder and inspect files correctly' do\n+      it 'decompresses the folder and inspects files correctly' do\n         engine = described_class.engine_for(@compressed_path)\n \n-        engine.decompress(@temp_folder, \"#{@temp_folder}/#{@folder_name}.zip\", available_size)\n+        extract_location = \"#{temp_folder}/extract_location\"\n+        FileUtils.mkdir(extract_location)\n+        engine.decompress(extract_location, \"#{temp_folder}/#{folder_name}.zip\", available_size)\n \n-        expect(read_file(\"test/hello.txt\")).to eq(\"hello world\")\n-        expect(read_file(\"test/a/inner\")).to eq(\"hello world inner\")\n+        expect(read_file(\"extract_location/hello.txt\")).to eq(\"hello world\")\n+        expect(read_file(\"extract_location/a/inner\")).to eq(\"hello world inner\")\n+      end\n+\n+      it \"doesn't allow files to be extracted outside the target directory\" do\n+        FileUtils.rm_rf(temp_folder)\n+        FileUtils.mkdir(temp_folder)\n+\n+        zip_file = \"#{temp_folder}/theme.zip\"\n+        Zip::File.open(zip_file, create: true) do |zipfile|\n+          zipfile.get_output_stream(\"child-file\") do |f|\n+            f.puts(\"child file\")\n+          end\n+          zipfile.get_output_stream(\"../escape-decompression-folder.txt\") do |f|\n+            f.puts(\"file that attempts to escape the decompression destination directory\")\n+          end\n+          zipfile.mkdir(\"child-dir\")\n+          zipfile.get_output_stream(\"child-dir/grandchild-file\") do |f|\n+            f.puts(\"grandchild file\")\n+          end\n+        end\n+\n+        extract_location = \"#{temp_folder}/extract_location\"\n+        FileUtils.mkdir(extract_location)\n+        engine = described_class.engine_for(zip_file)\n+        engine.decompress(extract_location, zip_file, available_size)\n+        Dir.chdir(temp_folder) do\n+          expect(Dir.glob(\"**/*\")).to contain_exactly(\n+            \"extract_location\",\n+            \"extract_location/child-file\",\n+            \"extract_location/child-dir\",\n+            \"extract_location/child-dir/grandchild-file\",\n+            \"theme.zip\"\n+          )\n+        end\n+      end\n+\n+      it \"decompresses into symlinked directory\" do\n+        real_location = \"#{temp_folder}/extract_location\"\n+        extract_location = \"#{temp_folder}/is/symlinked\"\n+\n+        FileUtils.mkdir(real_location)\n+        FileUtils.mkdir_p(extract_location)\n+        extract_location = \"#{extract_location}/extract_location\"\n+        FileUtils.symlink(real_location, extract_location)\n+\n+        engine = described_class.engine_for(@compressed_path)\n+        engine.decompress(extract_location, \"#{temp_folder}/#{folder_name}.zip\", available_size)\n+\n+        expect(File.realpath(extract_location)).to eq(real_location)\n+        expect(read_file(\"is/symlinked/extract_location/hello.txt\")).to eq(\"hello world\")\n+        expect(read_file(\"is/symlinked/extract_location/a/inner\")).to eq(\"hello world inner\")\n       end\n     end\n \n     context 'when working with .tar.gz files' do\n       let(:extension) { '.tar.gz' }\n \n-      it 'decompress the folder and inspect files correctly' do\n+      it 'decompresses the folder and inspects files correctly' do\n         engine = described_class.engine_for(@compressed_path)\n \n-        engine.decompress(@temp_folder, \"#{@temp_folder}/#{@folder_name}.tar.gz\", available_size)\n+        engine.decompress(temp_folder, \"#{temp_folder}/#{folder_name}.tar.gz\", available_size)\n \n         expect(read_file(\"test/hello.txt\")).to eq(\"hello world\")\n         expect(read_file(\"test/a/inner\")).to eq(\"hello world inner\")\n       end\n+\n+      it \"doesn't allow files to be extracted outside the target directory\" do\n+        FileUtils.rm_rf(temp_folder)\n+        FileUtils.mkdir(temp_folder)\n+\n+        tar_file = \"#{temp_folder}/theme.tar\"\n+        File.open(tar_file, \"wb\") do |file|\n+          Gem::Package::TarWriter.new(file) do |tar|\n+            tar.add_file(\"child-file\", 644) do |tf|\n+              tf.write(\"child file\")\n+            end\n+            tar.add_file(\"../escape-extraction-folder\", 644) do |tf|\n+              tf.write(\"file that attempts to escape the decompression destination directory\")\n+            end\n+            tar.mkdir(\"child-dir\", 755)\n+            tar.add_file(\"child-dir/grandchild-file\", 644) do |tf|\n+              tf.write(\"grandchild file\")\n+            end\n+          end\n+        end\n+        tar_gz_file = \"#{temp_folder}/theme.tar.gz\"\n+        Zlib::GzipWriter.open(tar_gz_file) do |gz|\n+          gz.orig_name = tar_file\n+          gz.write(File.binread(tar_file))\n+        end\n+        FileUtils.rm(tar_file)\n+\n+        extract_location = \"#{temp_folder}/extract_location\"\n+        FileUtils.mkdir(extract_location)\n+        engine = described_class.engine_for(tar_gz_file)\n+        engine.decompress(extract_location, tar_gz_file, available_size)\n+        Dir.chdir(temp_folder) do\n+          expect(Dir.glob(\"**/*\")).to contain_exactly(\n+            \"extract_location\",\n+            \"extract_location/child-file\",\n+            \"extract_location/child-dir\",\n+            \"extract_location/child-dir/grandchild-file\",\n+          )\n+        end\n+      end\n+\n+      it \"decompresses into symlinked directory\" do\n+        real_location = \"#{temp_folder}/extract_location\"\n+        extract_location = \"#{temp_folder}/is/symlinked\"\n+\n+        FileUtils.mkdir(real_location)\n+        FileUtils.mkdir_p(extract_location)\n+        extract_location = \"#{extract_location}/extract_location\"\n+        FileUtils.symlink(real_location, extract_location)\n+\n+        engine = described_class.engine_for(@compressed_path)\n+        engine.decompress(extract_location, \"#{temp_folder}/#{folder_name}.tar.gz\", available_size)\n+\n+        expect(File.realpath(extract_location)).to eq(real_location)\n+        expect(read_file(\"is/symlinked/extract_location/test/hello.txt\")).to eq(\"hello world\")\n+        expect(read_file(\"is/symlinked/extract_location/test/a/inner\")).to eq(\"hello world inner\")\n+      end\n     end\n \n     context 'when working with .tar files' do\n@@ -62,7 +173,7 @@\n       it 'decompress the folder and inspect files correctly' do\n         engine = described_class.engine_for(@compressed_path)\n \n-        engine.decompress(@temp_folder, \"#{@temp_folder}/#{@folder_name}.tar\", available_size)\n+        engine.decompress(temp_folder, \"#{temp_folder}/#{folder_name}.tar\", available_size)\n \n         expect(read_file(\"test/hello.txt\")).to eq(\"hello world\")\n         expect(read_file(\"test/a/inner\")).to eq(\"hello world inner\")\n@@ -71,6 +182,6 @@\n   end\n \n   def read_file(relative_path)\n-    File.read(\"#{@temp_folder}/#{relative_path}\")\n+    File.read(\"#{temp_folder}/#{relative_path}\")\n   end\n end"
        },
        {
          "filename": "spec/lib/theme_store/zip_exporter_spec.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -65,7 +65,7 @@\n     file = 'discourse-header-icons.zip'\n     Dir.chdir(dir) do\n       available_size = SiteSetting.decompressed_theme_max_file_size_mb\n-      Compression::Zip.new.decompress(dir, file, available_size, allow_non_root_folder: true)\n+      Compression::Zip.new.decompress(dir, file, available_size)\n       `rm #{file}`\n \n       folders = Dir.glob(\"**/*\").reject { |f| File.file?(f) }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d2efdf5282a868d80e916caaeb51d40d1ea256a2",
            "date": "2025-01-24T21:33:06Z",
            "author_login": "awesomerobot"
          },
          {
            "sha": "4c1c4ba8d42db4d1c732af69c39740d2aee91410",
            "date": "2025-01-24T19:50:52Z",
            "author_login": "featheredtoast"
          },
          {
            "sha": "59a67758489683457e7dca5fd712710034c08631",
            "date": "2025-01-24T19:42:22Z",
            "author_login": "xfalcox"
          },
          {
            "sha": "9cc99ef6db77d82b4af95911ee503e227cceae62",
            "date": "2025-01-24T18:36:35Z",
            "author_login": "SamSaffron"
          },
          {
            "sha": "5a94ceda542e5a0d0d8b90219bb835a51780b502",
            "date": "2025-01-24T18:05:47Z",
            "author_login": "xfalcox"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-434",
    "description": "Discourse is an open source discussion platform. In versions prior to 2.8.9 on the `stable` branch and prior to 2.9.0.beta10 on the `beta` and `tests-passed` branches, admins can upload a maliciously crafted Zip or Gzip Tar archive to write files at arbitrary locations and trigger remote code execution. The problem is patched in version 2.8.9 on the `stable` branch and version 2.9.0.beta10 on the `beta` and `tests-passed` branches. There are no known workarounds.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-09-29T20:15:09.747",
    "last_modified": "2024-11-21T07:12:18.350",
    "fix_date": "2022-09-29T18:00:38Z"
  },
  "references": [
    {
      "url": "https://github.com/discourse/discourse/commit/b27d5626d208a22c516a0adfda7554b67b493835",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/discourse/discourse/pull/18421",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/discourse/discourse/security/advisories/GHSA-grvh-qcpg-hfmv",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/discourse/discourse/commit/b27d5626d208a22c516a0adfda7554b67b493835",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/discourse/discourse/pull/18421",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/discourse/discourse/security/advisories/GHSA-grvh-qcpg-hfmv",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:41.302680",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "discourse",
    "owner": "discourse",
    "created_at": "2013-01-12T00:25:55Z",
    "updated_at": "2025-01-26T07:21:20Z",
    "pushed_at": "2025-01-25T09:40:42Z",
    "size": 701178,
    "stars": 42998,
    "forks": 8411,
    "open_issues": 82,
    "watchers": 42998,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Ruby": 20337451,
      "JavaScript": 9453662,
      "HTML": 1461712,
      "Handlebars": 1061673,
      "SCSS": 987048,
      "Mustache": 32177,
      "Shell": 12314,
      "CSS": 2558
    },
    "commit_activity": {
      "total_commits_last_year": 5042,
      "avg_commits_per_week": 96.96153846153847,
      "days_active_last_year": 299
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-26T07:34:08.623080"
  }
}