{
  "cve_id": "CVE-2022-36085",
  "github_data": {
    "repository": "open-policy-agent/opa",
    "fix_commit": "25a597bc3f4985162e7f65f9c36599f4f8f55823",
    "related_commits": [
      "25a597bc3f4985162e7f65f9c36599f4f8f55823",
      "3e8c754ed007b22393cf65e48751ad9f6457fee8",
      "25a597bc3f4985162e7f65f9c36599f4f8f55823",
      "3e8c754ed007b22393cf65e48751ad9f6457fee8"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "25a597bc3f4985162e7f65f9c36599f4f8f55823",
      "commit_date": "2022-09-07T18:00:18Z",
      "author": {
        "login": "srenatus",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "ast/compile: respect unsafeBuiltinMap for 'with' replacements (#5107)",
        "length": 327,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 195,
        "additions": 164,
        "deletions": 31
      },
      "files": [
        {
          "filename": "ast/compile.go",
          "status": "modified",
          "additions": 33,
          "deletions": 25,
          "patch": "@@ -2196,7 +2196,7 @@ func (c *Compiler) rewriteWithModifiers() {\n \t\t\tif !ok {\n \t\t\t\treturn x, nil\n \t\t\t}\n-\t\t\tbody, err := rewriteWithModifiersInBody(c, f, body)\n+\t\t\tbody, err := rewriteWithModifiersInBody(c, c.unsafeBuiltinsMap, f, body)\n \t\t\tif err != nil {\n \t\t\t\tc.err(err)\n \t\t\t}\n@@ -2475,19 +2475,20 @@ func (qc *queryCompiler) checkTypes(_ *QueryContext, body Body) (Body, error) {\n }\n \n func (qc *queryCompiler) checkUnsafeBuiltins(_ *QueryContext, body Body) (Body, error) {\n-\tvar unsafe map[string]struct{}\n-\tif qc.unsafeBuiltins != nil {\n-\t\tunsafe = qc.unsafeBuiltins\n-\t} else {\n-\t\tunsafe = qc.compiler.unsafeBuiltinsMap\n-\t}\n-\terrs := checkUnsafeBuiltins(unsafe, body)\n+\terrs := checkUnsafeBuiltins(qc.unsafeBuiltinsMap(), body)\n \tif len(errs) > 0 {\n \t\treturn nil, errs\n \t}\n \treturn body, nil\n }\n \n+func (qc *queryCompiler) unsafeBuiltinsMap() map[string]struct{} {\n+\tif qc.unsafeBuiltins != nil {\n+\t\treturn qc.unsafeBuiltins\n+\t}\n+\treturn qc.compiler.unsafeBuiltinsMap\n+}\n+\n func (qc *queryCompiler) checkDeprecatedBuiltins(_ *QueryContext, body Body) (Body, error) {\n \terrs := checkDeprecatedBuiltins(qc.compiler.deprecatedBuiltinsMap, body, qc.compiler.strict)\n \tif len(errs) > 0 {\n@@ -2498,7 +2499,7 @@ func (qc *queryCompiler) checkDeprecatedBuiltins(_ *QueryContext, body Body) (Bo\n \n func (qc *queryCompiler) rewriteWithModifiers(_ *QueryContext, body Body) (Body, error) {\n \tf := newEqualityFactory(newLocalVarGenerator(\"q\", body))\n-\tbody, err := rewriteWithModifiersInBody(qc.compiler, f, body)\n+\tbody, err := rewriteWithModifiersInBody(qc.compiler, qc.unsafeBuiltinsMap(), f, body)\n \tif err != nil {\n \t\treturn nil, Errors{err}\n \t}\n@@ -4785,10 +4786,10 @@ func rewriteDeclaredVar(g *localVarGenerator, stack *localDeclaredVars, v Var, o\n // rewriteWithModifiersInBody will rewrite the body so that with modifiers do\n // not contain terms that require evaluation as values. If this function\n // encounters an invalid with modifier target then it will raise an error.\n-func rewriteWithModifiersInBody(c *Compiler, f *equalityFactory, body Body) (Body, *Error) {\n+func rewriteWithModifiersInBody(c *Compiler, unsafeBuiltinsMap map[string]struct{}, f *equalityFactory, body Body) (Body, *Error) {\n \tvar result Body\n \tfor i := range body {\n-\t\texprs, err := rewriteWithModifier(c, f, body[i])\n+\t\texprs, err := rewriteWithModifier(c, unsafeBuiltinsMap, f, body[i])\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -4803,11 +4804,11 @@ func rewriteWithModifiersInBody(c *Compiler, f *equalityFactory, body Body) (Bod\n \treturn result, nil\n }\n \n-func rewriteWithModifier(c *Compiler, f *equalityFactory, expr *Expr) ([]*Expr, *Error) {\n+func rewriteWithModifier(c *Compiler, unsafeBuiltinsMap map[string]struct{}, f *equalityFactory, expr *Expr) ([]*Expr, *Error) {\n \n \tvar result []*Expr\n \tfor i := range expr.With {\n-\t\teval, err := validateWith(c, expr, i)\n+\t\teval, err := validateWith(c, unsafeBuiltinsMap, expr, i)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -4822,7 +4823,7 @@ func rewriteWithModifier(c *Compiler, f *equalityFactory, expr *Expr) ([]*Expr,\n \treturn append(result, expr), nil\n }\n \n-func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {\n+func validateWith(c *Compiler, unsafeBuiltinsMap map[string]struct{}, expr *Expr, i int) (bool, *Error) {\n \ttarget, value := expr.With[i].Target, expr.With[i].Value\n \n \t// Ensure that values that are built-ins are rewritten to Ref (not Var)\n@@ -4831,6 +4832,10 @@ func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {\n \t\t\tvalue.Value = Ref([]*Term{NewTerm(v)})\n \t\t}\n \t}\n+\tisBuiltinRefOrVar, err := isBuiltinRefOrVar(c.builtins, unsafeBuiltinsMap, target)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n \n \tswitch {\n \tcase isDataRef(target):\n@@ -4854,15 +4859,15 @@ func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {\n \t\t\tif child := node.Child(ref[len(ref)-1].Value); child != nil {\n \t\t\t\tfor _, v := range child.Values {\n \t\t\t\t\tif len(v.(*Rule).Head.Args) > 0 {\n-\t\t\t\t\t\tif validateWithFunctionValue(c.builtins, c.RuleTree, value) {\n-\t\t\t\t\t\t\treturn false, nil\n+\t\t\t\t\t\tif ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {\n+\t\t\t\t\t\t\treturn false, err // may be nil\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \tcase isInputRef(target): // ok, valid\n-\tcase isBuiltinRefOrVar(c.builtins, target):\n+\tcase isBuiltinRefOrVar:\n \n \t\t// NOTE(sr): first we ensure that parsed Var builtins (`count`, `concat`, etc)\n \t\t// are rewritten to their proper Ref convention\n@@ -4876,8 +4881,8 @@ func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {\n \t\t\treturn false, err\n \t\t}\n \n-\t\tif validateWithFunctionValue(c.builtins, c.RuleTree, value) {\n-\t\t\treturn false, nil\n+\t\tif ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {\n+\t\t\treturn false, err // may be nil\n \t\t}\n \tdefault:\n \t\treturn false, NewError(TypeErr, target.Location, \"with keyword target must reference existing %v, %v, or a function\", InputRootDocument, DefaultRootDocument)\n@@ -4906,13 +4911,13 @@ func validateWithBuiltinTarget(bi *Builtin, target Ref, loc *location.Location)\n \treturn nil\n }\n \n-func validateWithFunctionValue(bs map[string]*Builtin, ruleTree *TreeNode, value *Term) bool {\n+func validateWithFunctionValue(bs map[string]*Builtin, unsafeMap map[string]struct{}, ruleTree *TreeNode, value *Term) (bool, *Error) {\n \tif v, ok := value.Value.(Ref); ok {\n \t\tif ruleTree.Find(v) != nil { // ref exists in rule tree\n-\t\t\treturn true\n+\t\t\treturn true, nil\n \t\t}\n \t}\n-\treturn isBuiltinRefOrVar(bs, value)\n+\treturn isBuiltinRefOrVar(bs, unsafeMap, value)\n }\n \n func isInputRef(term *Term) bool {\n@@ -4933,13 +4938,16 @@ func isDataRef(term *Term) bool {\n \treturn false\n }\n \n-func isBuiltinRefOrVar(bs map[string]*Builtin, term *Term) bool {\n+func isBuiltinRefOrVar(bs map[string]*Builtin, unsafeBuiltinsMap map[string]struct{}, term *Term) (bool, *Error) {\n \tswitch v := term.Value.(type) {\n \tcase Ref, Var:\n+\t\tif _, ok := unsafeBuiltinsMap[v.String()]; ok {\n+\t\t\treturn false, NewError(CompileErr, term.Location, \"with keyword replacing built-in function: target must not be unsafe: %q\", v)\n+\t\t}\n \t\t_, ok := bs[v.String()]\n-\t\treturn ok\n+\t\treturn ok, nil\n \t}\n-\treturn false\n+\treturn false, nil\n }\n \n func isVirtual(node *TreeNode, ref Ref) bool {"
        },
        {
          "filename": "ast/compile_test.go",
          "status": "modified",
          "additions": 80,
          "deletions": 6,
          "patch": "@@ -4049,6 +4049,7 @@ func TestCompilerRewriteWithValue(t *testing.T) {\n \ttests := []struct {\n \t\tnote         string\n \t\tinput        string\n+\t\topts         func(*Compiler) *Compiler\n \t\texpected     string\n \t\texpectedRule *Rule\n \t\twantErr      error\n@@ -4154,6 +4155,26 @@ func TestCompilerRewriteWithValue(t *testing.T) {\n \t\t\t\treturn r\n \t\t\t}(),\n \t\t},\n+\t\t{\n+\t\t\tnote: \"built-in function: replaced by another built-in that's marked unsafe\",\n+\t\t\tinput: `\n+\t\t\t\tq := is_object({\"url\": \"https://httpbin.org\", \"method\": \"GET\"})\n+\t\t\t\tp { q with is_object as http.send }\n+\t\t\t`,\n+\t\t\topts:    func(c *Compiler) *Compiler { return c.WithUnsafeBuiltins(map[string]struct{}{\"http.send\": {}}) },\n+\t\t\twantErr: fmt.Errorf(\"rego_compile_error: with keyword replacing built-in function: target must not be unsafe: \\\"http.send\\\"\"),\n+\t\t},\n+\t\t{\n+\t\t\tnote: \"non-built-in function: replaced by another built-in that's marked unsafe\",\n+\t\t\tinput: `\n+\t\t\tr(_) = {}\n+\t\t\tq := r({\"url\": \"https://httpbin.org\", \"method\": \"GET\"})\n+\t\t\tp {\n+\t\t\t\tq with r as http.send\n+\t\t\t}`,\n+\t\t\topts:    func(c *Compiler) *Compiler { return c.WithUnsafeBuiltins(map[string]struct{}{\"http.send\": {}}) },\n+\t\t\twantErr: fmt.Errorf(\"rego_compile_error: with keyword replacing built-in function: target must not be unsafe: \\\"http.send\\\"\"),\n+\t\t},\n \t\t{\n \t\t\tnote: \"built-in function: valid, arity 1, non-compound name\",\n \t\t\tinput: `\n@@ -4171,6 +4192,9 @@ func TestCompilerRewriteWithValue(t *testing.T) {\n \tfor _, tc := range tests {\n \t\tt.Run(tc.note, func(t *testing.T) {\n \t\t\tc := NewCompiler()\n+\t\t\tif tc.opts != nil {\n+\t\t\t\tc = tc.opts(c)\n+\t\t\t}\n \t\t\tmodule := fixture + tc.input\n \t\t\tc.Modules[\"test\"] = MustParseModule(module)\n \t\t\tcompileStages(c, c.rewriteWithModifiers)\n@@ -6676,13 +6700,63 @@ func TestQueryCompilerWithStageAfterWithMetrics(t *testing.T) {\n }\n \n func TestQueryCompilerWithUnsafeBuiltins(t *testing.T) {\n-\tc := NewCompiler().WithUnsafeBuiltins(map[string]struct{}{\n-\t\t\"count\": {},\n-\t})\n+\ttests := []struct {\n+\t\tnote     string\n+\t\tquery    string\n+\t\tcompiler *Compiler\n+\t\topts     func(QueryCompiler) QueryCompiler\n+\t\terr      string\n+\t}{\n+\t\t{\n+\t\t\tnote:     \"builtin unsafe via compiler\",\n+\t\t\tquery:    \"count([])\",\n+\t\t\tcompiler: NewCompiler().WithUnsafeBuiltins(map[string]struct{}{\"count\": {}}),\n+\t\t\terr:      \"unsafe built-in function calls in expression: count\",\n+\t\t},\n+\t\t{\n+\t\t\tnote:     \"builtin unsafe via query compiler\",\n+\t\t\tquery:    \"count([])\",\n+\t\t\tcompiler: NewCompiler(),\n+\t\t\topts: func(qc QueryCompiler) QueryCompiler {\n+\t\t\t\treturn qc.WithUnsafeBuiltins(map[string]struct{}{\"count\": {}})\n+\t\t\t},\n+\t\t\terr: \"unsafe built-in function calls in expression: count\",\n+\t\t},\n+\t\t{\n+\t\t\tnote:     \"builtin unsafe via compiler, 'with' mocking\",\n+\t\t\tquery:    \"is_array([]) with is_array as count\",\n+\t\t\tcompiler: NewCompiler().WithUnsafeBuiltins(map[string]struct{}{\"count\": {}}),\n+\t\t\terr:      `with keyword replacing built-in function: target must not be unsafe: \"count\"`,\n+\t\t},\n+\t\t{\n+\t\t\tnote:     \"builtin unsafe via query compiler,  'with' mocking\",\n+\t\t\tquery:    \"is_array([]) with is_array as count\",\n+\t\t\tcompiler: NewCompiler(),\n+\t\t\topts: func(qc QueryCompiler) QueryCompiler {\n+\t\t\t\treturn qc.WithUnsafeBuiltins(map[string]struct{}{\"count\": {}})\n+\t\t\t},\n+\t\t\terr: `with keyword replacing built-in function: target must not be unsafe: \"count\"`,\n+\t\t},\n+\t}\n \n-\t_, err := c.QueryCompiler().WithUnsafeBuiltins(map[string]struct{}{}).Compile(MustParseBody(\"count([])\"))\n-\tif err != nil {\n-\t\tt.Fatal(err)\n+\tfor _, tc := range tests {\n+\t\tt.Run(tc.note, func(t *testing.T) {\n+\t\t\tqc := tc.compiler.QueryCompiler()\n+\t\t\tif tc.opts != nil {\n+\t\t\t\tqc = tc.opts(qc)\n+\t\t\t}\n+\t\t\t_, err := qc.Compile(MustParseBody(tc.query))\n+\t\t\tvar errs Errors\n+\t\t\tif !errors.As(err, &errs) {\n+\t\t\t\tt.Fatalf(\"expected error type %T, got %v %[2]T\", errs, err)\n+\t\t\t}\n+\t\t\tif exp, act := 1, len(errs); exp != act {\n+\t\t\t\tt.Fatalf(\"expected %d error(s), got %d\", exp, act)\n+\t\t\t}\n+\t\t\tif exp, act := tc.err, errs[0].Message; exp != act {\n+\t\t\t\tt.Errorf(\"expected message %q, got %q\", exp, act)\n+\t\t\t}\n+\t\t})\n \t}\n }\n "
        },
        {
          "filename": "rego/rego_test.go",
          "status": "modified",
          "additions": 51,
          "deletions": 0,
          "patch": "@@ -1437,6 +1437,7 @@ func TestUnsafeBuiltins(t *testing.T) {\n \tctx := context.Background()\n \n \tunsafeCountExpr := \"unsafe built-in function calls in expression: count\"\n+\tunsafeCountExprWith := `with keyword replacing built-in function: target must not be unsafe: \"count\"`\n \n \tt.Run(\"unsafe query\", func(t *testing.T) {\n \t\tr := New(\n@@ -1448,6 +1449,16 @@ func TestUnsafeBuiltins(t *testing.T) {\n \t\t}\n \t})\n \n+\tt.Run(\"unsafe query, 'with' replacement\", func(t *testing.T) {\n+\t\tr := New(\n+\t\t\tQuery(`is_array([1, 2, 3]) with is_array as count`),\n+\t\t\tUnsafeBuiltins(map[string]struct{}{\"count\": {}}),\n+\t\t)\n+\t\tif _, err := r.Eval(ctx); err == nil || !strings.Contains(err.Error(), unsafeCountExprWith) {\n+\t\t\tt.Fatalf(\"Expected unsafe built-in error but got %v\", err)\n+\t\t}\n+\t})\n+\n \tt.Run(\"unsafe module\", func(t *testing.T) {\n \t\tr := New(\n \t\t\tQuery(`data.pkg.deny`),\n@@ -1463,6 +1474,36 @@ func TestUnsafeBuiltins(t *testing.T) {\n \t\t}\n \t})\n \n+\tt.Run(\"unsafe module, 'with' replacement in query\", func(t *testing.T) {\n+\t\tr := New(\n+\t\t\tQuery(`data.pkg.deny with is_array as count`),\n+\t\t\tModule(\"pkg.rego\", `package pkg\n+\t\t\tdeny {\n+\t\t\t\tis_array(input.requests) > 10\n+\t\t\t}\n+\t\t\t`),\n+\t\t\tUnsafeBuiltins(map[string]struct{}{\"count\": {}}),\n+\t\t)\n+\t\tif _, err := r.Eval(ctx); err == nil || !strings.Contains(err.Error(), unsafeCountExprWith) {\n+\t\t\tt.Fatalf(\"Expected unsafe built-in error but got %v\", err)\n+\t\t}\n+\t})\n+\n+\tt.Run(\"unsafe module, 'with' replacement in module\", func(t *testing.T) {\n+\t\tr := New(\n+\t\t\tQuery(`data.pkg.deny`),\n+\t\t\tModule(\"pkg.rego\", `package pkg\n+\t\t\tdeny {\n+\t\t\t\tis_array(input.requests) > 10 with is_array as count\n+\t\t\t}\n+\t\t\t`),\n+\t\t\tUnsafeBuiltins(map[string]struct{}{\"count\": {}}),\n+\t\t)\n+\t\tif _, err := r.Eval(ctx); err == nil || !strings.Contains(err.Error(), unsafeCountExprWith) {\n+\t\t\tt.Fatalf(\"Expected unsafe built-in error but got %v\", err)\n+\t\t}\n+\t})\n+\n \tt.Run(\"inherit in query\", func(t *testing.T) {\n \t\tr := New(\n \t\t\tCompiler(ast.NewCompiler().WithUnsafeBuiltins(map[string]struct{}{\"count\": {}})),\n@@ -1473,6 +1514,16 @@ func TestUnsafeBuiltins(t *testing.T) {\n \t\t}\n \t})\n \n+\tt.Run(\"inherit in query, 'with' replacement\", func(t *testing.T) {\n+\t\tr := New(\n+\t\t\tCompiler(ast.NewCompiler().WithUnsafeBuiltins(map[string]struct{}{\"count\": {}})),\n+\t\t\tQuery(\"is_array([]) with is_array as count\"),\n+\t\t)\n+\t\tif _, err := r.Eval(ctx); err == nil || !strings.Contains(err.Error(), unsafeCountExprWith) {\n+\t\t\tt.Fatalf(\"Expected unsafe built-in error but got %v\", err)\n+\t\t}\n+\t})\n+\n \tt.Run(\"override/disable in query\", func(t *testing.T) {\n \t\tr := New(\n \t\t\tCompiler(ast.NewCompiler().WithUnsafeBuiltins(map[string]struct{}{\"count\": {}})),"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "6e83f2ac535b501d8d26859f71d32e31ec931ca6",
            "date": "2025-01-24T22:03:26Z",
            "author_login": "johanfylling"
          },
          {
            "sha": "211e95da7e04035f6cf27d6c221659d6fa0d0b86",
            "date": "2025-01-24T11:12:12Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "e682a677922b23306501f53d2f418753968f2263",
            "date": "2025-01-24T19:00:06Z",
            "author_login": "anderseknert"
          },
          {
            "sha": "d20dd18f71df02874c82f6bd1c4557be17e1590e",
            "date": "2025-01-24T15:27:14Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "b032e3bfc00044691bd1c749596d2429e06e2324",
            "date": "2025-01-24T12:47:16Z",
            "author_login": "johanfylling"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-20",
    "description": "Open Policy Agent (OPA) is an open source, general-purpose policy engine. The Rego compiler provides a (deprecated) `WithUnsafeBuiltins` function, which allows users to provide a set of built-in functions that should be deemed unsafe \u2014 and as such rejected \u2014 by the compiler if encountered in the policy compilation stage. A bypass of this protection has been found, where the use of the `with` keyword to mock such a built-in function (a feature introduced in OPA v0.40.0), isn\u2019t taken into account by `WithUnsafeBuiltins`. Multiple conditions need to be met in order to create an adverse effect. Version 0.43.1 contains a patch for this issue. As a workaround, avoid using the `WithUnsafeBuiltins` function and use the `capabilities` feature instead.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-09-08T14:15:08.340",
    "last_modified": "2024-11-21T07:12:21.110",
    "fix_date": "2022-09-07T18:00:18Z"
  },
  "references": [
    {
      "url": "https://github.com/open-policy-agent/opa/commit/25a597bc3f4985162e7f65f9c36599f4f8f55823",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/open-policy-agent/opa/commit/3e8c754ed007b22393cf65e48751ad9f6457fee8",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/open-policy-agent/opa/pull/4540",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/open-policy-agent/opa/pull/4616",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/open-policy-agent/opa/releases/tag/v0.43.1",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/open-policy-agent/opa/security/advisories/GHSA-f524-rf33-2jjr",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/open-policy-agent/opa/commit/25a597bc3f4985162e7f65f9c36599f4f8f55823",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/open-policy-agent/opa/commit/3e8c754ed007b22393cf65e48751ad9f6457fee8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/open-policy-agent/opa/pull/4540",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/open-policy-agent/opa/pull/4616",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/open-policy-agent/opa/releases/tag/v0.43.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/open-policy-agent/opa/security/advisories/GHSA-f524-rf33-2jjr",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:39.092121",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "opa",
    "owner": "open-policy-agent",
    "created_at": "2015-12-28T22:08:25Z",
    "updated_at": "2025-01-14T14:30:21Z",
    "pushed_at": "2025-01-13T20:58:04Z",
    "size": 1086711,
    "stars": 9857,
    "forks": 1368,
    "open_issues": 386,
    "watchers": 9857,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "main-1.0",
      "master",
      "release-0.12",
      "release-0.13",
      "release-0.14",
      "release-0.16",
      "release-0.17",
      "release-0.19",
      "release-0.20",
      "release-0.21",
      "release-0.23",
      "release-0.30",
      "release-0.32",
      "release-0.33",
      "release-0.34",
      "release-0.36",
      "release-0.37",
      "release-0.38",
      "release-0.42",
      "release-0.43",
      "release-0.46",
      "release-0.47",
      "release-0.49",
      "release-0.50",
      "release-0.53",
      "release-0.57",
      "release-0.64",
      "release-0.67"
    ],
    "languages": {
      "Go": 8113294,
      "C": 934778,
      "C++": 709198,
      "Open Policy Agent": 42095,
      "Makefile": 22395,
      "Shell": 18937,
      "JavaScript": 14203,
      "Python": 5616,
      "Dockerfile": 2601
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T16:06:07.409105"
  }
}