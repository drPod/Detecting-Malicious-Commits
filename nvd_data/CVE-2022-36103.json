{
  "cve_id": "CVE-2022-36103",
  "github_data": {
    "repository": "siderolabs/talos",
    "fix_commit": "9eaf33f3f274e746ca1b442c0a1a0dae0cec088f",
    "related_commits": [
      "9eaf33f3f274e746ca1b442c0a1a0dae0cec088f",
      "9eaf33f3f274e746ca1b442c0a1a0dae0cec088f"
    ],
    "patch_url": "https://github.com/siderolabs/talos/commit/9eaf33f3f274e746ca1b442c0a1a0dae0cec088f.patch",
    "fix_commit_details": {
      "sha": "9eaf33f3f274e746ca1b442c0a1a0dae0cec088f",
      "commit_date": "2022-09-08T11:58:10Z",
      "author": {
        "login": "smira",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix: never sign client certificate requests in trustd",
        "length": 632,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 158,
        "additions": 149,
        "deletions": 9
      },
      "files": [
        {
          "filename": "internal/app/trustd/internal/reg/reg.go",
          "status": "modified",
          "additions": 56,
          "deletions": 3,
          "patch": "@@ -6,12 +6,19 @@ package reg\n \n import (\n \t\"context\"\n+\tstdx509 \"crypto/x509\"\n+\t\"crypto/x509/pkix\"\n+\t\"encoding/pem\"\n+\t\"log\"\n \n \t\"github.com/cosi-project/runtime/pkg/resource\"\n \t\"github.com/cosi-project/runtime/pkg/safe\"\n \t\"github.com/cosi-project/runtime/pkg/state\"\n \t\"github.com/siderolabs/crypto/x509\"\n \t\"google.golang.org/grpc\"\n+\t\"google.golang.org/grpc/codes\"\n+\t\"google.golang.org/grpc/peer\"\n+\t\"google.golang.org/grpc/status\"\n \n \tsecurityapi \"github.com/talos-systems/talos/pkg/machinery/api/security\"\n \t\"github.com/talos-systems/talos/pkg/machinery/resources/secrets\"\n@@ -33,17 +40,63 @@ func (r *Registrator) Register(s *grpc.Server) {\n }\n \n // Certificate implements the securityapi.SecurityServer interface.\n+//\n+// This API is called by Talos worker nodes to request a server certificate for apid running on the node.\n+// Control plane nodes generate certificates (client and server) directly from machine config PKI.\n func (r *Registrator) Certificate(ctx context.Context, in *securityapi.CertificateRequest) (resp *securityapi.CertificateResponse, err error) {\n+\tremotePeer, ok := peer.FromContext(ctx)\n+\tif !ok {\n+\t\treturn nil, status.Error(codes.PermissionDenied, \"peer not found\")\n+\t}\n+\n \tosRoot, err := safe.StateGet[*secrets.OSRoot](ctx, r.Resources, resource.NewMetadata(secrets.NamespaceName, secrets.OSRootType, secrets.OSRootID, resource.VersionUndefined))\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\t// TODO: Verify that the request is coming from the IP addresss declared in\n+\t// decode and validate CSR\n+\tcsrPemBlock, _ := pem.Decode(in.Csr)\n+\tif csrPemBlock == nil {\n+\t\treturn nil, status.Errorf(codes.InvalidArgument, \"failed to decode CSR\")\n+\t}\n+\n+\trequest, err := stdx509.ParseCertificateRequest(csrPemBlock.Bytes)\n+\tif err != nil {\n+\t\treturn nil, status.Errorf(codes.InvalidArgument, \"failed to parse CSR: %s\", err)\n+\t}\n+\n+\tlog.Printf(\"received CSR signing request from %s: subject %s dns names %s addresses %s\", remotePeer.Addr, request.Subject, request.DNSNames, request.IPAddresses)\n+\n+\t// allow only server auth certificates\n+\tx509Opts := []x509.Option{\n+\t\tx509.KeyUsage(stdx509.KeyUsageDigitalSignature),\n+\t\tx509.ExtKeyUsage([]stdx509.ExtKeyUsage{stdx509.ExtKeyUsageServerAuth}),\n+\t}\n+\n+\t// don't allow any certificates which can be used for client authentication\n+\t//\n+\t// we don't return an error here, as otherwise workers running old versions of Talos\n+\t// will fail to provision client certificate and will never launch apid\n+\t//\n+\t// instead, the returned certificate will be rejected when being used\n+\tif len(request.Subject.Organization) > 0 {\n+\t\tlog.Printf(\"removing client auth organization from CSR: %s\", request.Subject.Organization)\n+\n+\t\tx509Opts = append(x509Opts, x509.OverrideSubject(func(subject *pkix.Name) {\n+\t\t\tsubject.Organization = nil\n+\t\t}))\n+\t}\n+\n+\t// TODO: Verify that the request is coming from the IP address declared in\n \t// the CSR.\n-\tsigned, err := x509.NewCertificateFromCSRBytes(osRoot.TypedSpec().CA.Crt, osRoot.TypedSpec().CA.Key, in.Csr)\n+\tsigned, err := x509.NewCertificateFromCSRBytes(\n+\t\tosRoot.TypedSpec().CA.Crt,\n+\t\tosRoot.TypedSpec().CA.Key,\n+\t\tin.Csr,\n+\t\tx509Opts...,\n+\t)\n \tif err != nil {\n-\t\treturn\n+\t\treturn nil, status.Errorf(codes.Internal, \"failed to sign CSR: %s\", err)\n \t}\n \n \tresp = &securityapi.CertificateResponse{"
        },
        {
          "filename": "internal/app/trustd/internal/reg/reg_test.go",
          "status": "modified",
          "additions": 93,
          "deletions": 6,
          "patch": "@@ -4,11 +4,98 @@\n \n package reg_test\n \n-import \"testing\"\n+import (\n+\t\"context\"\n+\tstdx509 \"crypto/x509\"\n+\t\"net\"\n+\t\"net/netip\"\n+\t\"testing\"\n+\t\"time\"\n \n-func TestEmpty(t *testing.T) {\n-\t// added for accurate coverage estimation\n-\t//\n-\t// please remove it once any unit-test is added\n-\t// for this package\n+\t\"github.com/cosi-project/runtime/pkg/state\"\n+\t\"github.com/cosi-project/runtime/pkg/state/impl/inmem\"\n+\t\"github.com/cosi-project/runtime/pkg/state/impl/namespaced\"\n+\t\"github.com/siderolabs/crypto/x509\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\t\"google.golang.org/grpc/peer\"\n+\n+\t\"github.com/talos-systems/talos/internal/app/trustd/internal/reg\"\n+\t\"github.com/talos-systems/talos/pkg/machinery/api/security\"\n+\t\"github.com/talos-systems/talos/pkg/machinery/config/types/v1alpha1/generate\"\n+\t\"github.com/talos-systems/talos/pkg/machinery/resources/secrets\"\n+\t\"github.com/talos-systems/talos/pkg/machinery/role\"\n+)\n+\n+func TestCertificate(t *testing.T) {\n+\tctx, cancel := context.WithCancel(context.Background())\n+\tdefer cancel()\n+\n+\tresources := state.WrapCore(namespaced.NewState(inmem.Build))\n+\n+\tca, err := generate.NewTalosCA(time.Now())\n+\trequire.NoError(t, err)\n+\n+\tosRoot := secrets.NewOSRoot(secrets.OSRootID)\n+\tosRoot.TypedSpec().CA = &x509.PEMEncodedCertificateAndKey{\n+\t\tCrt: ca.CrtPEM,\n+\t\tKey: ca.KeyPEM,\n+\t}\n+\trequire.NoError(t, resources.Create(ctx, osRoot))\n+\n+\tctx = peer.NewContext(ctx, &peer.Peer{\n+\t\tAddr: &net.TCPAddr{\n+\t\t\tIP:   netip.MustParseAddr(\"127.0.0.1\").AsSlice(),\n+\t\t\tPort: 30000,\n+\t\t},\n+\t})\n+\n+\tr := &reg.Registrator{\n+\t\tResources: resources,\n+\t}\n+\n+\tfor _, tt := range []struct {\n+\t\tname       string\n+\t\tcsrSetters []x509.Option\n+\t}{\n+\t\t{\n+\t\t\tname: \"server certificate\",\n+\t\t\tcsrSetters: []x509.Option{\n+\t\t\t\tx509.IPAddresses([]net.IP{netip.MustParseAddr(\"10.5.0.4\").AsSlice()}),\n+\t\t\t\tx509.DNSNames([]string{\"talos-default-worker-1\"}),\n+\t\t\t\tx509.CommonName(\"talos-default-worker-1\"),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"attempt at client certificate\",\n+\t\t\tcsrSetters: []x509.Option{\n+\t\t\t\tx509.CommonName(\"talos-default-worker-1\"),\n+\t\t\t\tx509.Organization(string(role.Impersonator)),\n+\t\t\t},\n+\t\t},\n+\t} {\n+\t\ttt := tt\n+\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tserverCSR, serverCert, err := x509.NewEd25519CSRAndIdentity(tt.csrSetters...)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tresp, err := r.Certificate(ctx, &security.CertificateRequest{\n+\t\t\t\tCsr: serverCSR.X509CertificateRequestPEM,\n+\t\t\t})\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tassert.Equal(t, resp.Ca, ca.CrtPEM)\n+\n+\t\t\tserverCert.Crt = resp.Crt\n+\n+\t\t\tcert, err := serverCert.GetCert()\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tassert.Equal(t, stdx509.KeyUsageDigitalSignature, cert.KeyUsage)\n+\t\t\tassert.Equal(t, []stdx509.ExtKeyUsage{stdx509.ExtKeyUsageServerAuth}, cert.ExtKeyUsage)\n+\t\t\tassert.Equal(t, \"talos-default-worker-1\", cert.Subject.CommonName)\n+\t\t\tassert.Equal(t, []string(nil), cert.Subject.Organization)\n+\t\t})\n+\t}\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "9b957df64680a97a16575db67d4af27cfc0ef7d2",
            "date": "2025-01-13T16:57:56Z",
            "author_login": "frezbo"
          },
          {
            "sha": "e41a995253428dde437eecec52cabfb4c80f90ea",
            "date": "2025-01-14T04:52:33Z",
            "author_login": "frezbo"
          },
          {
            "sha": "db4ca5668ac0d85a98a5ea022f6546526d20aff1",
            "date": "2025-01-14T10:24:50Z",
            "author_login": "smira"
          },
          {
            "sha": "faa1490033df0a843010fa7154096d84f415afce",
            "date": "2025-01-13T14:43:10Z",
            "author_login": "smira"
          },
          {
            "sha": "8de19758dafce802c0f93a63ae3083b5ad17162d",
            "date": "2025-01-13T14:55:27Z",
            "author_login": "smira"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.2,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-732",
    "description": "Talos Linux is a Linux distribution built for Kubernetes deployments. Talos worker nodes use a join token to get accepted into the Talos cluster. Due to improper validation of the request while signing a worker node CSR (certificate signing request) Talos control plane node might issue Talos API certificate which allows full access to Talos API on a control plane node. Accessing Talos API with full level access on a control plane node might reveal sensitive information which allows full level access to the cluster (Kubernetes and Talos PKI, etc.). Talos API join token is stored in the machine configuration on the worker node. When configured correctly, Kubernetes workloads don't have access to the machine configuration, but due to a misconfiguration workload might access the machine configuration and reveal the join token. This problem has been fixed in Talos 1.2.2. Enabling the Pod Security Standards mitigates the vulnerability by denying hostPath mounts and host networking by default in the baseline policy. Clusters that don't run untrusted workloads are not affected. Clusters with correct Pod Security configurations which don't allow hostPath mounts, and secure access to cloud metadata server (or machine configuration is not supplied via cloud metadata server) are not affected.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-09-13T17:15:08.320",
    "last_modified": "2024-11-21T07:12:23.730",
    "fix_date": "2022-09-08T11:58:10Z"
  },
  "references": [
    {
      "url": "https://github.com/siderolabs/talos/commit/9eaf33f3f274e746ca1b442c0a1a0dae0cec088f",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/siderolabs/talos/releases/tag/v1.2.2",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/siderolabs/talos/security/advisories/GHSA-7hgc-php5-77qq",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/siderolabs/talos/commit/9eaf33f3f274e746ca1b442c0a1a0dae0cec088f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/siderolabs/talos/releases/tag/v1.2.2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/siderolabs/talos/security/advisories/GHSA-7hgc-php5-77qq",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:39.107996",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "talos",
    "owner": "siderolabs",
    "created_at": "2017-11-03T23:19:12Z",
    "updated_at": "2025-01-14T12:58:57Z",
    "pushed_at": "2025-01-14T13:01:58Z",
    "size": 86747,
    "stars": 7242,
    "forks": 591,
    "open_issues": 307,
    "watchers": 7242,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-0.1",
      "release-0.2",
      "release-0.3",
      "release-0.4",
      "release-0.5",
      "release-0.6",
      "release-0.7",
      "release-0.8",
      "release-0.9",
      "release-0.10",
      "release-0.11",
      "release-0.12",
      "release-0.13",
      "release-0.14",
      "release-1.0",
      "release-1.1",
      "release-1.2",
      "release-1.3",
      "release-1.4",
      "release-1.5",
      "release-1.6",
      "release-1.7",
      "release-1.8",
      "release-1.9"
    ],
    "languages": {
      "Go": 7008613,
      "Jinja": 139221,
      "JavaScript": 86226,
      "HTML": 82327,
      "Shell": 78017,
      "Dockerfile": 52233,
      "SCSS": 42309,
      "Makefile": 30151,
      "CSS": 5762,
      "jq": 1723
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mpl-2.0"
    },
    "collected_at": "2025-01-14T15:22:57.566098"
  }
}