{
  "cve_id": "CVE-2022-39206",
  "github_data": {
    "repository": "theonedev/onedev",
    "fix_commit": "0052047a5b5095ac6a6b4a73a522d0272fec3a22",
    "related_commits": [
      "0052047a5b5095ac6a6b4a73a522d0272fec3a22",
      "0052047a5b5095ac6a6b4a73a522d0272fec3a22"
    ],
    "patch_url": "https://github.com/theonedev/onedev/commit/0052047a5b5095ac6a6b4a73a522d0272fec3a22.patch",
    "fix_commit_details": {
      "sha": "0052047a5b5095ac6a6b4a73a522d0272fec3a22",
      "commit_date": "2022-05-30T14:21:43Z",
      "author": {
        "login": "robinshine",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix the docker sock mount security vulnerability",
        "length": 48,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 120,
        "additions": 103,
        "deletions": 17
      },
      "files": [
        {
          "filename": "pom.xml",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -589,7 +589,7 @@\n \t</repositories>\n \t<properties>\n \t\t<commons.version>2.1.2</commons.version>\n-\t\t<agent.version>1.3.7</agent.version>\n+\t\t<agent.version>1.3.8</agent.version>\n \t\t<slf4j.version>1.7.30</slf4j.version>\n \t\t<logback.version>1.2.9</logback.version>\n \t\t<antlr.version>4.7.2</antlr.version>"
        },
        {
          "filename": "server-core/src/main/java/io/onedev/server/migration/DataMigrator.java",
          "status": "modified",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -4078,4 +4078,27 @@ private void migrate85(File dataDir, Stack<Integer> versions) {\n \tprivate void migrate86(File dataDir, Stack<Integer> versions) {\r\n \t}\r\n \t\r\n+\tprivate void migrate87(File dataDir, Stack<Integer> versions) {\r\n+\t\tfor (File file: dataDir.listFiles()) {\r\n+\t\t\tif (file.getName().startsWith(\"Settings.xml\")) {\r\n+\t\t\t\tVersionedXmlDoc dom = VersionedXmlDoc.fromFile(file);\r\n+\t\t\t\tfor (Element element: dom.getRootElement().elements()) {\r\n+\t\t\t\t\tString key = element.elementTextTrim(\"key\");\r\n+\t\t\t\t\tif (key.equals(\"JOB_EXECUTORS\")) {\r\n+\t\t\t\t\t\tElement valueElement = element.element(\"value\");\r\n+\t\t\t\t\t\tif (valueElement != null) {\r\n+\t\t\t\t\t\t\tfor (Element executorElement: valueElement.elements()) {\r\n+\t\t\t\t\t\t\t\tif (executorElement.getName().contains(\"DockerExecutor\")) \r\n+\t\t\t\t\t\t\t\t\texecutorElement.addElement(\"mountDockerSock\").setText(\"false\");\r\n+\t\t\t\t\t\t\t\telse if (executorElement.getName().contains(\"KubernetesExecutor\")) \r\n+\t\t\t\t\t\t\t\t\texecutorElement.addElement(\"mountContainerSock\").setText(\"false\");\r\n+\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t}\t\t\t\t\t\t\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t\tdom.writeToFile(file, false);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\t\r\n }\r"
        },
        {
          "filename": "server-plugin/server-plugin-executor-kubernetes/src/main/java/io/onedev/server/plugin/executor/kubernetes/KubernetesExecutor.java",
          "status": "modified",
          "additions": 33,
          "deletions": 10,
          "patch": "@@ -117,6 +117,8 @@ public class KubernetesExecutor extends JobExecutor implements Testable<TestData\n \t\n \tprivate String kubeCtlPath;\n \t\n+\tprivate boolean mountContainerSock;\n+\t\n \t@Editable(order=20, description=\"Optionally specify node selector of the job pods\")\n \tpublic List<NodeSelectorEntry> getNodeSelector() {\n \t\treturn nodeSelector;\n@@ -146,6 +148,21 @@ public List<RegistryLogin> getRegistryLogins() {\n \tpublic void setRegistryLogins(List<RegistryLogin> registryLogins) {\n \t\tthis.registryLogins = registryLogins;\n \t}\n+\t\n+\t@Editable(order=300, description=\"Whether or not to mount docker/containerd sock into job \"\n+\t\t\t+ \"container to support container operations in job commands, for instance to build \"\n+\t\t\t+ \"container image.<br>\"\n+\t\t\t+ \"<b class='text-danger'>WARNING</b>: Malicious jobs can take control of k8s node \"\n+\t\t\t+ \"running the job by operating the mounted container sock. You should configure job \"\n+\t\t\t+ \"requirement option below to make sure the executor can only be used by trusted \"\n+\t\t\t+ \"jobs if this option is enabled\")\n+\tpublic boolean isMountContainerSock() {\n+\t\treturn mountContainerSock;\n+\t}\n+\n+\tpublic void setMountContainerSock(boolean mountContainerSock) {\n+\t\tthis.mountContainerSock = mountContainerSock;\n+\t}\n \n \t@Editable(order=25000, group=\"More Settings\", description=\"Optionally specify where to run service pods \"\n \t\t\t+ \"specified in job. The first matching locator will be used. If no any locators are found, \"\n@@ -769,8 +786,11 @@ public void consume(String line) {\n \t\t\t\t\tcommonVolumeMounts.add(authInfoMount2);\n \t\t\t\tif (trustCertsConfigMapName != null)\n \t\t\t\t\tcommonVolumeMounts.add(trustCertsMount);\n-\t\t\t\tcommonVolumeMounts.add(dockerSockMount);\n-\t\t\t\tcommonVolumeMounts.add(containerdSockMount);\n+\t\t\t\t\n+\t\t\t\tif (isMountContainerSock()) {\n+\t\t\t\t\tcommonVolumeMounts.add(dockerSockMount);\n+\t\t\t\t\tcommonVolumeMounts.add(containerdSockMount);\n+\t\t\t\t}\n \n \t\t\t\tCompositeFacade entryFacade;\n \t\t\t\tif (jobContext != null) {\n@@ -975,14 +995,17 @@ public Void visit(LeafFacade facade, List<Integer> position) {\n \t\t\t\t\t\t\t\"configMap\", CollectionUtils.newLinkedHashMap(\n \t\t\t\t\t\t\t\t\t\"name\", trustCertsConfigMapName)));\n \t\t\t\t}\n-\t\t\t\tvolumes.add(CollectionUtils.newLinkedHashMap(\n-\t\t\t\t\t\t\"name\", \"docker-sock\", \n-\t\t\t\t\t\t\"hostPath\", CollectionUtils.newLinkedHashMap(\n-\t\t\t\t\t\t\t\t\"path\", dockerSock)));\n-\t\t\t\tvolumes.add(CollectionUtils.newLinkedHashMap(\n-\t\t\t\t\t\t\"name\", \"containerd-sock\", \n-\t\t\t\t\t\t\"hostPath\", CollectionUtils.newLinkedHashMap(\n-\t\t\t\t\t\t\t\t\"path\", containerdSock)));\n+\t\t\t\t\n+\t\t\t\tif (isMountContainerSock()) {\n+\t\t\t\t\tvolumes.add(CollectionUtils.newLinkedHashMap(\n+\t\t\t\t\t\t\t\"name\", \"docker-sock\", \n+\t\t\t\t\t\t\t\"hostPath\", CollectionUtils.newLinkedHashMap(\n+\t\t\t\t\t\t\t\t\t\"path\", dockerSock)));\n+\t\t\t\t\tvolumes.add(CollectionUtils.newLinkedHashMap(\n+\t\t\t\t\t\t\t\"name\", \"containerd-sock\", \n+\t\t\t\t\t\t\t\"hostPath\", CollectionUtils.newLinkedHashMap(\n+\t\t\t\t\t\t\t\t\t\"path\", containerdSock)));\n+\t\t\t\t}\n \t\t\t\tpodSpec.put(\"volumes\", volumes);\n \n \t\t\t\tString podName = \"job\";"
        },
        {
          "filename": "server-plugin/server-plugin-executor-remotedocker/src/main/java/io/onedev/server/plugin/executor/remotedocker/RemoteDockerExecutor.java",
          "status": "modified",
          "additions": 18,
          "deletions": 2,
          "patch": "@@ -36,6 +36,8 @@ public class RemoteDockerExecutor extends ServerDockerExecutor {\n \t\n \tprivate String agentQuery;\n \t\n+\tprivate boolean mountDockerSock;\n+\t\n \t@Editable(order=390, name=\"Agent Selector\", placeholder=\"Any agent\", \n \t\t\tdescription=\"Specify agents applicable for this executor\")\n \t@io.onedev.server.web.editable.annotation.AgentQuery(forExecutor=true)\n@@ -47,6 +49,20 @@ public void setAgentQuery(String agentQuery) {\n \t\tthis.agentQuery = agentQuery;\n \t}\n \n+\t@Editable(order=400, description=\"Whether or not to mount docker sock into job container to \"\n+\t\t\t+ \"support docker operations in job commands, for instance to build docker image.<br>\"\n+\t\t\t+ \"<b class='text-danger'>WARNING</b>: Malicious jobs can take control of the agent \"\n+\t\t\t+ \"running the job by operating the mounted docker sock. You should configure job \"\n+\t\t\t+ \"requirement option below to make sure the executor can only be used by trusted \"\n+\t\t\t+ \"jobs if this option is enabled\")\n+\tpublic boolean isMountDockerSock() {\n+\t\treturn mountDockerSock;\n+\t}\n+\n+\tpublic void setMountDockerSock(boolean mountDockerSock) {\n+\t\tthis.mountDockerSock = mountDockerSock;\n+\t}\n+\t\n \t@Override\n \tpublic void execute(String jobToken, JobContext jobContext) {\n \t\tAgentQuery parsedQeury = AgentQuery.parse(agentQuery, true);\n@@ -73,8 +89,8 @@ public void runOn(Long agentId, Session agentSession, AgentData agentData) {\n \t\t\t\tList<String> trustCertContent = getTrustCertContent();\n \t\t\t\tDockerJobData jobData = new DockerJobData(jobToken, getName(), jobContext.getProjectPath(), \n \t\t\t\t\t\tjobContext.getProjectId(), jobContext.getCommitId().name(), jobContext.getBuildNumber(), \n-\t\t\t\t\t\tjobContext.getActions(), jobContext.getRetried(), services, registryLogins, \n-\t\t\t\t\t\ttrustCertContent, getRunOptions());\n+\t\t\t\t\t\tjobContext.getActions(), jobContext.getRetried(), services, registryLogins,\n+\t\t\t\t\t\tmountDockerSock, trustCertContent, getRunOptions());\n \t\t\t\t\n \t\t\t\ttry {\n \t\t\t\t\tWebsocketUtils.call(agentSession, jobData, 0);"
        },
        {
          "filename": "server-plugin/server-plugin-executor-serverdocker/src/main/java/io/onedev/server/plugin/executor/serverdocker/ServerDockerExecutor.java",
          "status": "modified",
          "additions": 22,
          "deletions": 4,
          "patch": "@@ -93,6 +93,8 @@ public class ServerDockerExecutor extends JobExecutor implements Testable<TestDa\n \t\n \tprivate String dockerExecutable;\n \t\n+\tprivate boolean mountDockerSock;\n+\t\n \tprivate static transient volatile String hostInstallPath;\n \n \t@Editable(order=400, description=\"Specify login information for docker registries if necessary\")\n@@ -104,6 +106,20 @@ public void setRegistryLogins(List<RegistryLogin> registryLogins) {\n \t\tthis.registryLogins = registryLogins;\n \t}\n \n+\t@Editable(order=500, description=\"Whether or not to mount docker sock into job container to \"\n+\t\t\t+ \"support docker operations in job commands, for instance to build docker image.<br>\"\n+\t\t\t+ \"<b class='text-danger'>WARNING</b>: Malicious jobs can take control of whole OneDev \"\n+\t\t\t+ \"by operating the mounted docker sock. You should configure job requirement \"\n+\t\t\t+ \"option below to make sure the executor can only be used by trusted jobs if this \"\n+\t\t\t+ \"option is enabled\")\n+\tpublic boolean isMountDockerSock() {\n+\t\treturn mountDockerSock;\n+\t}\n+\n+\tpublic void setMountDockerSock(boolean mountDockerSock) {\n+\t\tthis.mountDockerSock = mountDockerSock;\n+\t}\n+\n \t@Editable(order=50050, group=\"More Settings\", description=\"Optionally specify options to run container. For instance, you may use <tt>-m 2g</tt> \"\n \t\t\t+ \"to limit memory of created container to be 2 giga bytes\")\n \tpublic String getRunOptions() {\n@@ -247,10 +263,12 @@ else if (workingDir != null)\n \t\t\t\t\t\t\t\t\t\t\tdocker.addArgs(\"-v\", getHostPath(hostCachePath) + \":\" + containerCachePath);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\t\n-\t\t\t\t\t\t\t\t\t\tif (SystemUtils.IS_OS_WINDOWS) \n-\t\t\t\t\t\t\t\t\t\t\tdocker.addArgs(\"-v\", \"//./pipe/docker_engine://./pipe/docker_engine\");\n-\t\t\t\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t\t\t\tdocker.addArgs(\"-v\", \"/var/run/docker.sock:/var/run/docker.sock\");\n+\t\t\t\t\t\t\t\t\t\tif (isMountDockerSock()) {\n+\t\t\t\t\t\t\t\t\t\t\tif (SystemUtils.IS_OS_WINDOWS) \n+\t\t\t\t\t\t\t\t\t\t\t\tdocker.addArgs(\"-v\", \"//./pipe/docker_engine://./pipe/docker_engine\");\n+\t\t\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\t\t\tdocker.addArgs(\"-v\", \"/var/run/docker.sock:/var/run/docker.sock\");\n+\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\t\n \t\t\t\t\t\t\t\t\t\tif (hostAuthInfoHome.get() != null) {\n \t\t\t\t\t\t\t\t\t\t\tString hostPath = getHostPath(hostAuthInfoHome.get().getAbsolutePath());"
        },
        {
          "filename": "server-product/system/incompatibilities/incompatibilities.md",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -1,3 +1,9 @@\n+# 7.3.0\n+1. [CI/CD] Docker sock is mounted by default for server docker executor, remote docker executor and Kubernetes \n+executor for security reasons. If your CI job performs docker operation, the build may fail. You may enable \n+the mount docker sock option in related executors, but make sure to configure job requirement of the executor \n+to only allow trusted jobs to use the executors\n+\n # 7.0.0\n \n 1. [RESTful api] Email addresses of a user should now be retrieved via [UserResource.getEmailAddresses](/help/api/io.onedev.server.rest.UserResource/getEmailAddresses), and should be operated via [EmailAddressResource](/help/api/io.onedev.server.rest.EmailAddressResource)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 6,
        "max_directory_depth": 11
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "10e2c31d03935064a014dfb1464fa7bc146be9e0",
            "date": "2025-01-11T23:54:45Z",
            "author_login": "robinshine"
          },
          {
            "sha": "715386eb735489c08616f9e1c3dc56f58a5457c3",
            "date": "2025-01-11T01:12:03Z",
            "author_login": "robinshine"
          },
          {
            "sha": "be37d8fc32b9c3c4d7b11d3af8051be8911ee390",
            "date": "2025-01-09T14:35:55Z",
            "author_login": "robinshine"
          },
          {
            "sha": "f61d99124dd571668a8836354672903717ced5ca",
            "date": "2025-01-06T03:25:54Z",
            "author_login": "sususweet"
          },
          {
            "sha": "4c37f0dd4e0336e64f22fa04929d67188ee70bd4",
            "date": "2025-01-06T02:48:57Z",
            "author_login": "sususweet"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-610",
    "description": "Onedev is an open source, self-hosted Git Server with CI/CD and Kanban. When using Docker-based job executors, the Docker socket (e.g. /var/run/docker.sock on Linux) is mounted into each Docker step. Users that can define and trigger CI/CD jobs on a project could use this to control the Docker daemon on the host machine. This is a known dangerous pattern, as it can be used to break out of Docker containers and, in most cases, gain root privileges on the host system. This issue allows regular (non-admin) users to potentially take over the build infrastructure of a OneDev instance. Attackers need to have an account (or be able to register one) and need permission to create a project. Since code.onedev.io has the right preconditions for this to be exploited by remote attackers, it could have been used to hijack builds of OneDev itself, e.g. by injecting malware into the docker images that are built and pushed to Docker Hub. The impact is increased by this as described before. Users are advised to upgrade to 7.3.0 or higher. There are no known workarounds for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-09-13T19:15:13.160",
    "last_modified": "2024-11-21T07:17:47.097",
    "fix_date": "2022-05-30T14:21:43Z"
  },
  "references": [
    {
      "url": "https://blog.sonarsource.com/onedev-remote-code-execution/",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/theonedev/onedev/commit/0052047a5b5095ac6a6b4a73a522d0272fec3a22",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/theonedev/onedev/security/advisories/GHSA-gjq9-4xx9-cr3q",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://blog.sonarsource.com/onedev-remote-code-execution/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/theonedev/onedev/commit/0052047a5b5095ac6a6b4a73a522d0272fec3a22",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/theonedev/onedev/security/advisories/GHSA-gjq9-4xx9-cr3q",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:39.109705",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "onedev",
    "owner": "theonedev",
    "created_at": "2018-11-06T02:57:01Z",
    "updated_at": "2025-01-14T10:30:38Z",
    "pushed_at": "2025-01-11T23:54:59Z",
    "size": 226316,
    "stars": 13579,
    "forks": 872,
    "open_issues": 0,
    "watchers": 13579,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Java": 11067283,
      "JavaScript": 730260,
      "HTML": 381307,
      "CSS": 180682,
      "Shell": 116784,
      "ANTLR": 46591,
      "Smarty": 17174,
      "Python": 5761,
      "Mustache": 3983,
      "Dockerfile": 125
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:48:17.966345"
  }
}