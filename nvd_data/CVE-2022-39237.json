{
  "cve_id": "CVE-2022-39237",
  "github_data": {
    "repository": "sylabs/sif",
    "fix_commit": "07fb86029a12e3210f6131e065570124605daeaa",
    "related_commits": [
      "07fb86029a12e3210f6131e065570124605daeaa",
      "07fb86029a12e3210f6131e065570124605daeaa"
    ],
    "patch_url": "https://github.com/sylabs/sif/commit/07fb86029a12e3210f6131e065570124605daeaa.patch",
    "fix_commit_details": {
      "sha": "07fb86029a12e3210f6131e065570124605daeaa",
      "commit_date": "2022-10-06T11:52:14Z",
      "author": {
        "login": "tri-adam",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-m5m3-46gj-wch8",
        "length": 96,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 222,
        "additions": 149,
        "deletions": 73
      },
      "files": [
        {
          "filename": "pkg/integrity/clearsign.go",
          "status": "modified",
          "additions": 32,
          "deletions": 2,
          "patch": "@@ -1,4 +1,4 @@\n-// Copyright (c) 2020, Sylabs Inc. All rights reserved.\n+// Copyright (c) 2020-2022, Sylabs Inc. All rights reserved.\n // This software is licensed under a 3-clause BSD license. Please consult the LICENSE.md file\n // distributed with the sources of this project regarding your rights to use or distribute this\n // software.\n@@ -7,6 +7,7 @@ package integrity\n \n import (\n \t\"bytes\"\n+\t\"crypto\"\n \t\"encoding/json\"\n \t\"errors\"\n \t\"io\"\n@@ -18,9 +19,32 @@ import (\n \n var errClearsignedMsgNotFound = errors.New(\"clearsigned message not found\")\n \n+// Hash functions specified for OpenPGP in RFC4880, excluding those that are not currently\n+// recommended by NIST.\n+var supportedPGPAlgorithms = []crypto.Hash{\n+\tcrypto.SHA224,\n+\tcrypto.SHA256,\n+\tcrypto.SHA384,\n+\tcrypto.SHA512,\n+}\n+\n+// hashAlgorithmSupported returns whether h is a supported PGP hash function.\n+func hashAlgorithmSupported(h crypto.Hash) bool {\n+\tfor _, alg := range supportedPGPAlgorithms {\n+\t\tif alg == h {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n // signAndEncodeJSON encodes v, clear-signs it with privateKey, and writes it to w. If config is\n // nil, sensible defaults are used.\n func signAndEncodeJSON(w io.Writer, v interface{}, privateKey *packet.PrivateKey, config *packet.Config) error {\n+\tif !hashAlgorithmSupported(config.Hash()) {\n+\t\treturn errHashUnsupported\n+\t}\n+\n \t// Get clearsign encoder.\n \tplaintext, err := clearsign.Encode(w, privateKey, config)\n \tif err != nil {\n@@ -59,7 +83,13 @@ func verifyAndDecode(data []byte, kr openpgp.KeyRing) (*openpgp.Entity, []byte,\n \t}\n \n \t// Check signature.\n-\te, err := openpgp.CheckDetachedSignature(kr, bytes.NewReader(b.Bytes), b.ArmoredSignature.Body, nil)\n+\te, err := openpgp.CheckDetachedSignatureAndHash(\n+\t\tkr,\n+\t\tbytes.NewReader(b.Bytes),\n+\t\tb.ArmoredSignature.Body,\n+\t\tsupportedPGPAlgorithms,\n+\t\tnil,\n+\t)\n \treturn e, b.Plaintext, rest, err\n }\n "
        },
        {
          "filename": "pkg/integrity/clearsign_test.go",
          "status": "modified",
          "additions": 13,
          "deletions": 4,
          "patch": "@@ -1,4 +1,4 @@\n-// Copyright (c) 2020-2021, Sylabs Inc. All rights reserved.\n+// Copyright (c) 2020-2022, Sylabs Inc. All rights reserved.\n // This software is licensed under a 3-clause BSD license. Please consult the LICENSE.md file\n // distributed with the sources of this project regarding your rights to use or distribute this\n // software.\n@@ -9,13 +9,15 @@ import (\n \t\"bufio\"\n \t\"bytes\"\n \t\"crypto\"\n+\t\"encoding/json\"\n \t\"errors\"\n \t\"io\"\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n \n \t\"github.com/ProtonMail/go-crypto/openpgp\"\n+\t\"github.com/ProtonMail/go-crypto/openpgp/clearsign\"\n \tpgperrors \"github.com/ProtonMail/go-crypto/openpgp/errors\"\n \t\"github.com/ProtonMail/go-crypto/openpgp/packet\"\n \t\"github.com/sebdah/goldie/v2\"\n@@ -41,7 +43,7 @@ func TestSignAndEncodeJSON(t *testing.T) {\n \t}{\n \t\t{name: \"EncryptedKey\", key: &encryptedKey, wantErr: true},\n \t\t{name: \"DefaultHash\", key: e.PrivateKey},\n-\t\t{name: \"SHA1\", key: e.PrivateKey, hash: crypto.SHA1},\n+\t\t{name: \"SHA1\", key: e.PrivateKey, hash: crypto.SHA1, wantErr: true},\n \t\t{name: \"SHA224\", key: e.PrivateKey, hash: crypto.SHA224},\n \t\t{name: \"SHA256\", key: e.PrivateKey, hash: crypto.SHA256},\n \t\t{name: \"SHA384\", key: e.PrivateKey, hash: crypto.SHA384},\n@@ -121,7 +123,7 @@ func TestVerifyAndDecodeJSON(t *testing.T) {\n \t\t{name: \"CorruptedSignature\", el: openpgp.EntityList{e}, corrupter: corruptSignature},\n \t\t{name: \"VerifyOnly\", el: openpgp.EntityList{e}, wantEntity: e},\n \t\t{name: \"DefaultHash\", el: openpgp.EntityList{e}, output: &testType{}, wantEntity: e},\n-\t\t{name: \"SHA1\", hash: crypto.SHA1, el: openpgp.EntityList{e}, output: &testType{}, wantEntity: e},\n+\t\t{name: \"SHA1\", hash: crypto.SHA1, el: openpgp.EntityList{e}, wantErr: pgperrors.StructuralError(\"hash algorithm mismatch with cleartext message headers\")}, //nolint:lll\n \t\t{name: \"SHA224\", hash: crypto.SHA224, el: openpgp.EntityList{e}, output: &testType{}, wantEntity: e},\n \t\t{name: \"SHA256\", hash: crypto.SHA256, el: openpgp.EntityList{e}, output: &testType{}, wantEntity: e},\n \t\t{name: \"SHA384\", hash: crypto.SHA384, el: openpgp.EntityList{e}, output: &testType{}, wantEntity: e},\n@@ -136,10 +138,17 @@ func TestVerifyAndDecodeJSON(t *testing.T) {\n \t\t\tconfig := packet.Config{\n \t\t\t\tDefaultHash: tt.hash,\n \t\t\t}\n-\t\t\terr := signAndEncodeJSON(&b, testValue, e.PrivateKey, &config)\n+\n+\t\t\t// Manually sign and encode rather than calling signAndEncodeJSON, since we want to\n+\t\t\t// test unsupported hash algorithms.\n+\t\t\tplaintext, err := clearsign.Encode(&b, e.PrivateKey, &config)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n+\t\t\tif err := json.NewEncoder(plaintext).Encode(testValue); err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tplaintext.Close()\n \n \t\t\t// Introduce corruption, if applicable.\n \t\t\tif tt.corrupter != nil {"
        },
        {
          "filename": "pkg/integrity/digest.go",
          "status": "modified",
          "additions": 11,
          "deletions": 9,
          "patch": "@@ -22,12 +22,14 @@ var (\n \terrDigestMalformed = errors.New(\"digest malformed\")\n )\n \n-var supportedAlgorithms = map[crypto.Hash]string{\n-\tcrypto.SHA1:   \"sha1\",\n-\tcrypto.SHA224: \"sha224\",\n-\tcrypto.SHA256: \"sha256\",\n-\tcrypto.SHA384: \"sha384\",\n-\tcrypto.SHA512: \"sha512\",\n+// Hash functions supported for digests.\n+var supportedDigestAlgorithms = map[crypto.Hash]string{\n+\tcrypto.SHA224:     \"sha224\",\n+\tcrypto.SHA256:     \"sha256\",\n+\tcrypto.SHA384:     \"sha384\",\n+\tcrypto.SHA512:     \"sha512\",\n+\tcrypto.SHA512_224: \"sha512_224\",\n+\tcrypto.SHA512_256: \"sha512_256\",\n }\n \n // hashValue calculates a digest by applying hash function h to the contents read from r. If h is\n@@ -52,7 +54,7 @@ type digest struct {\n // newDigest returns a new digest. If h is not supported, errHashUnsupported is returned. If digest\n // is malformed, errDigestMalformed is returned.\n func newDigest(h crypto.Hash, value []byte) (digest, error) {\n-\tif _, ok := supportedAlgorithms[h]; !ok {\n+\tif _, ok := supportedDigestAlgorithms[h]; !ok {\n \t\treturn digest{}, errHashUnsupported\n \t}\n \n@@ -104,7 +106,7 @@ func (d digest) matches(r io.Reader) (bool, error) {\n \n // MarshalJSON marshals d into string of format \"alg:value\".\n func (d digest) MarshalJSON() ([]byte, error) {\n-\tn, ok := supportedAlgorithms[d.hash]\n+\tn, ok := supportedDigestAlgorithms[d.hash]\n \tif !ok {\n \t\treturn nil, errHashUnsupported\n \t}\n@@ -130,7 +132,7 @@ func (d *digest) UnmarshalJSON(data []byte) error {\n \t\treturn fmt.Errorf(\"%w: %v\", errDigestMalformed, err)\n \t}\n \n-\tfor h, n := range supportedAlgorithms {\n+\tfor h, n := range supportedDigestAlgorithms {\n \t\tif n == name {\n \t\t\tdigest, err := newDigest(h, v)\n \t\t\tif err != nil {"
        },
        {
          "filename": "pkg/integrity/digest_test.go",
          "status": "modified",
          "additions": 47,
          "deletions": 17,
          "patch": "@@ -114,14 +114,14 @@ func TestDigest_MarshalJSON(t *testing.T) {\n \t\twantErr error\n \t}{\n \t\t{\n-\t\t\tname:    \"UnsupportedHash\",\n+\t\t\tname:    \"HashUnsupportedMD5\",\n \t\t\thash:    crypto.MD5,\n \t\t\twantErr: errHashUnsupported,\n \t\t},\n \t\t{\n-\t\t\tname:  \"SHA1\",\n-\t\t\thash:  crypto.SHA1,\n-\t\t\tvalue: \"597f6a540010f94c15d71806a99a2c8710e747bd\",\n+\t\t\tname:    \"HashUnsupportedSHA1\",\n+\t\t\thash:    crypto.SHA1,\n+\t\t\twantErr: errHashUnsupported,\n \t\t},\n \t\t{\n \t\t\tname:  \"SHA224\",\n@@ -143,6 +143,16 @@ func TestDigest_MarshalJSON(t *testing.T) {\n \t\t\thash:  crypto.SHA512,\n \t\t\tvalue: \"db3974a97f2407b7cae1ae637c0030687a11913274d578492558e39c16c017de84eacdc8c62fe34ee4e12b4b1428817f09b6a2760c3f8a664ceae94d2434a593\", //nolint:lll\n \t\t},\n+\t\t{\n+\t\t\tname:  \"SHA512_224\",\n+\t\t\thash:  crypto.SHA512_224,\n+\t\t\tvalue: \"06001bf08dfb17d2b54925116823be230e98b5c6c278303bc4909a8c\",\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"SHA512_256\",\n+\t\t\thash:  crypto.SHA512_256,\n+\t\t\tvalue: \"3d37fe58435e0d87323dee4a2c1b339ef954de63716ee79f5747f94d974f913f\",\n+\t\t},\n \t}\n \n \tfor _, tt := range tests {\n@@ -193,60 +203,80 @@ func TestDigest_UnmarshalJSON(t *testing.T) {\n \t\t\twantErr: errDigestMalformed,\n \t\t},\n \t\t{\n-\t\t\tname:    \"UnsupportedHash\",\n+\t\t\tname:    \"HashUnsupportedMD5\",\n \t\t\tr:       strings.NewReader(`\"md5:b0804ec967f48520697662a204f5fe72\"`),\n \t\t\twantErr: errHashUnsupported,\n \t\t},\n+\t\t{\n+\t\t\tname:    \"HashUnsupportedSHA1\",\n+\t\t\tr:       strings.NewReader(`\"sha1:597f6a540010f94c15d71806a99a2c8710e747bd\"`),\n+\t\t\twantErr: errHashUnsupported,\n+\t\t},\n \t\t{\n \t\t\tname:    \"DigestMalformedNotHex\",\n-\t\t\tr:       strings.NewReader(`\"sha1:oops\"`),\n+\t\t\tr:       strings.NewReader(`\"sha256:oops\"`),\n \t\t\twantErr: errDigestMalformed,\n \t\t},\n \t\t{\n \t\t\tname:    \"DigestMalformedIncorrectLen\",\n-\t\t\tr:       strings.NewReader(`\"sha1:597f\"`),\n+\t\t\tr:       strings.NewReader(`\"sha256:597f\"`),\n \t\t\twantErr: errDigestMalformed,\n \t\t},\n-\t\t{\n-\t\t\tname:      \"SHA1\",\n-\t\t\tr:         strings.NewReader(`\"sha1:597f6a540010f94c15d71806a99a2c8710e747bd\"`),\n-\t\t\twantHash:  crypto.SHA1,\n-\t\t\twantValue: \"597f6a540010f94c15d71806a99a2c8710e747bd\",\n-\t\t},\n \t\t{\n \t\t\tname:      \"SHA224\",\n \t\t\tr:         strings.NewReader(`\"sha224:95041dd60ab08c0bf5636d50be85fe9790300f39eb84602858a9b430\"`),\n-\t\t\twantHash:  crypto.SHA1,\n+\t\t\twantHash:  crypto.SHA224,\n \t\t\twantValue: \"95041dd60ab08c0bf5636d50be85fe9790300f39eb84602858a9b430\",\n \t\t},\n \t\t{\n \t\t\tname:      \"SHA256\",\n \t\t\tr:         strings.NewReader(`\"sha256:a948904f2f0f479b8f8197694b30184b0d2ed1c1cd2a1ec0fb85d299a192a447\"`),\n-\t\t\twantHash:  crypto.SHA1,\n+\t\t\twantHash:  crypto.SHA256,\n \t\t\twantValue: \"a948904f2f0f479b8f8197694b30184b0d2ed1c1cd2a1ec0fb85d299a192a447\",\n \t\t},\n \t\t{\n \t\t\tname:      \"SHA384\",\n \t\t\tr:         strings.NewReader(`\"sha384:6b3b69ff0a404f28d75e98a066d3fc64fffd9940870cc68bece28545b9a75086b343d7a1366838083e4b8f3ca6fd3c80\"`), //nolint:lll\n-\t\t\twantHash:  crypto.SHA1,\n+\t\t\twantHash:  crypto.SHA384,\n \t\t\twantValue: \"6b3b69ff0a404f28d75e98a066d3fc64fffd9940870cc68bece28545b9a75086b343d7a1366838083e4b8f3ca6fd3c80\",\n \t\t},\n \t\t{\n \t\t\tname:      \"SHA512\",\n \t\t\tr:         strings.NewReader(`\"sha512:db3974a97f2407b7cae1ae637c0030687a11913274d578492558e39c16c017de84eacdc8c62fe34ee4e12b4b1428817f09b6a2760c3f8a664ceae94d2434a593\"`), //nolint:lll\n-\t\t\twantHash:  crypto.SHA1,\n+\t\t\twantHash:  crypto.SHA512,\n \t\t\twantValue: \"db3974a97f2407b7cae1ae637c0030687a11913274d578492558e39c16c017de84eacdc8c62fe34ee4e12b4b1428817f09b6a2760c3f8a664ceae94d2434a593\", //nolint:lll\n \t\t},\n+\t\t{\n+\t\t\tname:      \"SHA512_224\",\n+\t\t\tr:         strings.NewReader(`\"sha512_224:06001bf08dfb17d2b54925116823be230e98b5c6c278303bc4909a8c\"`),\n+\t\t\twantHash:  crypto.SHA512_224,\n+\t\t\twantValue: \"06001bf08dfb17d2b54925116823be230e98b5c6c278303bc4909a8c\",\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"SHA512_256\",\n+\t\t\tr:         strings.NewReader(`\"sha512_256:3d37fe58435e0d87323dee4a2c1b339ef954de63716ee79f5747f94d974f913f\"`),\n+\t\t\twantHash:  crypto.SHA512_256,\n+\t\t\twantValue: \"3d37fe58435e0d87323dee4a2c1b339ef954de63716ee79f5747f94d974f913f\",\n+\t\t},\n \t}\n \n \tfor _, tt := range tests {\n \t\ttt := tt\n \t\tt.Run(tt.name, func(t *testing.T) {\n \t\t\tvar d digest\n+\n \t\t\terr := json.NewDecoder(tt.r).Decode(&d)\n \t\t\tif got, want := err, tt.wantErr; !errors.Is(got, want) {\n \t\t\t\tt.Fatalf(\"got error %v, want %v\", got, want)\n \t\t\t}\n+\n+\t\t\tif got, want := d.hash, tt.wantHash; got != want {\n+\t\t\t\tt.Errorf(\"got hash %v, want %v\", got, want)\n+\t\t\t}\n+\n+\t\t\tif got, want := hex.EncodeToString(d.value), tt.wantValue; got != want {\n+\t\t\t\tt.Errorf(\"got value %v, want %v\", got, want)\n+\t\t\t}\n \t\t})\n \t}\n }"
        },
        {
          "filename": "pkg/integrity/metadata_test.go",
          "status": "modified",
          "additions": 15,
          "deletions": 11,
          "patch": "@@ -1,4 +1,4 @@\n-// Copyright (c) 2020-2021, Sylabs Inc. All rights reserved.\n+// Copyright (c) 2020-2022, Sylabs Inc. All rights reserved.\n // This software is licensed under a 3-clause BSD license. Please consult the LICENSE.md file\n // distributed with the sources of this project regarding your rights to use or distribute this\n // software.\n@@ -35,12 +35,14 @@ func TestGetHeaderMetadata(t *testing.T) {\n \t\twantErr error\n \t}{\n \t\t{name: \"HashUnavailable\", header: bytes.NewReader(b), hash: crypto.MD4, wantErr: errHashUnavailable},\n-\t\t{name: \"HashUnsupported\", header: bytes.NewReader(b), hash: crypto.MD5, wantErr: errHashUnsupported},\n-\t\t{name: \"SHA1\", header: bytes.NewReader(b), hash: crypto.SHA1},\n+\t\t{name: \"HashUnsupportedMD5\", header: bytes.NewReader(b), hash: crypto.MD5, wantErr: errHashUnsupported},\n+\t\t{name: \"HashUnsupportedSHA1\", header: bytes.NewReader(b), hash: crypto.SHA1, wantErr: errHashUnsupported},\n \t\t{name: \"SHA224\", header: bytes.NewReader(b), hash: crypto.SHA224},\n \t\t{name: \"SHA256\", header: bytes.NewReader(b), hash: crypto.SHA256},\n \t\t{name: \"SHA384\", header: bytes.NewReader(b), hash: crypto.SHA384},\n \t\t{name: \"SHA512\", header: bytes.NewReader(b), hash: crypto.SHA512},\n+\t\t{name: \"SHA512_224\", header: bytes.NewReader(b), hash: crypto.SHA512_224},\n+\t\t{name: \"SHA512_256\", header: bytes.NewReader(b), hash: crypto.SHA512_256},\n \t}\n \n \tfor _, tt := range tests {\n@@ -88,13 +90,15 @@ func TestGetObjectMetadata(t *testing.T) {\n \t\twantErr    error\n \t}{\n \t\t{name: \"HashUnavailable\", descr: bytes.NewReader(rid0), hash: crypto.MD4, wantErr: errHashUnavailable},\n-\t\t{name: \"HashUnsupported\", descr: bytes.NewReader(rid0), hash: crypto.MD5, wantErr: errHashUnsupported},\n-\t\t{name: \"RelativeID\", relativeID: 1, descr: bytes.NewReader(rid1), data: strings.NewReader(\"blah\"), hash: crypto.SHA1},\n-\t\t{name: \"SHA1\", descr: bytes.NewReader(rid0), data: strings.NewReader(\"blah\"), hash: crypto.SHA1},\n+\t\t{name: \"HashUnsupportedMD5\", descr: bytes.NewReader(rid0), hash: crypto.MD5, wantErr: errHashUnsupported},\n+\t\t{name: \"HashUnsupportedSHA1\", descr: bytes.NewReader(rid0), hash: crypto.SHA1, wantErr: errHashUnsupported},\n+\t\t{name: \"RelativeID\", relativeID: 1, descr: bytes.NewReader(rid1), data: strings.NewReader(\"blah\"), hash: crypto.SHA256}, //nolint:lll\n \t\t{name: \"SHA224\", descr: bytes.NewReader(rid0), data: strings.NewReader(\"blah\"), hash: crypto.SHA224},\n \t\t{name: \"SHA256\", descr: bytes.NewReader(rid0), data: strings.NewReader(\"blah\"), hash: crypto.SHA256},\n \t\t{name: \"SHA384\", descr: bytes.NewReader(rid0), data: strings.NewReader(\"blah\"), hash: crypto.SHA384},\n \t\t{name: \"SHA512\", descr: bytes.NewReader(rid0), data: strings.NewReader(\"blah\"), hash: crypto.SHA512},\n+\t\t{name: \"SHA512_224\", descr: bytes.NewReader(rid0), data: strings.NewReader(\"blah\"), hash: crypto.SHA512_224},\n+\t\t{name: \"SHA512_256\", descr: bytes.NewReader(rid0), data: strings.NewReader(\"blah\"), hash: crypto.SHA512_256},\n \t}\n \n \tfor _, tt := range tests {\n@@ -139,11 +143,11 @@ func TestGetImageMetadata(t *testing.T) {\n \t\twantErr error\n \t}{\n \t\t{name: \"HashUnavailable\", hash: crypto.MD4, wantErr: errHashUnavailable},\n-\t\t{name: \"HashUnsupported\", hash: crypto.MD5, wantErr: errHashUnsupported},\n-\t\t{name: \"MinimumIDInvalid\", minID: 2, ods: []sif.Descriptor{od1}, hash: crypto.SHA1, wantErr: errMinimumIDInvalid},\n-\t\t{name: \"Object1\", minID: 1, ods: []sif.Descriptor{od1}, hash: crypto.SHA1},\n-\t\t{name: \"Object2\", minID: 1, ods: []sif.Descriptor{od2}, hash: crypto.SHA1},\n-\t\t{name: \"SHA1\", minID: 1, ods: []sif.Descriptor{od1, od2}, hash: crypto.SHA1},\n+\t\t{name: \"HashUnsupportedMD5\", hash: crypto.MD5, wantErr: errHashUnsupported},\n+\t\t{name: \"HashUnsupportedSHA1\", hash: crypto.SHA1, wantErr: errHashUnsupported},\n+\t\t{name: \"MinimumIDInvalid\", minID: 2, ods: []sif.Descriptor{od1}, hash: crypto.SHA256, wantErr: errMinimumIDInvalid},\n+\t\t{name: \"Object1\", minID: 1, ods: []sif.Descriptor{od1}, hash: crypto.SHA256},\n+\t\t{name: \"Object2\", minID: 1, ods: []sif.Descriptor{od2}, hash: crypto.SHA256},\n \t\t{name: \"SHA224\", minID: 1, ods: []sif.Descriptor{od1, od2}, hash: crypto.SHA224},\n \t\t{name: \"SHA256\", minID: 1, ods: []sif.Descriptor{od1, od2}, hash: crypto.SHA256},\n \t\t{name: \"SHA384\", minID: 1, ods: []sif.Descriptor{od1, od2}, hash: crypto.SHA384},"
        },
        {
          "filename": "pkg/integrity/sign_test.go",
          "status": "modified",
          "additions": 22,
          "deletions": 8,
          "patch": "@@ -1,4 +1,4 @@\n-// Copyright (c) 2020-2021, Sylabs Inc. All rights reserved.\n+// Copyright (c) 2020-2022, Sylabs Inc. All rights reserved.\n // This software is licensed under a 3-clause BSD license. Please consult the LICENSE.md file\n // distributed with the sources of this project regarding your rights to use or distribute this\n // software.\n@@ -272,7 +272,7 @@ func TestGroupSigner_SignWithEntity(t *testing.T) {\n \t\t\t\tf:      twoGroups,\n \t\t\t\tid:     1,\n \t\t\t\tods:    []sif.Descriptor{d1},\n-\t\t\t\tmdHash: crypto.SHA1,\n+\t\t\t\tmdHash: crypto.SHA256,\n \t\t\t\tsigConfig: &packet.Config{\n \t\t\t\t\tTime: fixedTime,\n \t\t\t\t},\n@@ -285,7 +285,7 @@ func TestGroupSigner_SignWithEntity(t *testing.T) {\n \t\t\t\tf:      twoGroups,\n \t\t\t\tid:     1,\n \t\t\t\tods:    []sif.Descriptor{d2},\n-\t\t\t\tmdHash: crypto.SHA1,\n+\t\t\t\tmdHash: crypto.SHA256,\n \t\t\t\tsigConfig: &packet.Config{\n \t\t\t\t\tTime: fixedTime,\n \t\t\t\t},\n@@ -298,7 +298,7 @@ func TestGroupSigner_SignWithEntity(t *testing.T) {\n \t\t\t\tf:      twoGroups,\n \t\t\t\tid:     1,\n \t\t\t\tods:    []sif.Descriptor{d1, d2},\n-\t\t\t\tmdHash: crypto.SHA1,\n+\t\t\t\tmdHash: crypto.SHA256,\n \t\t\t\tsigConfig: &packet.Config{\n \t\t\t\t\tTime: fixedTime,\n \t\t\t\t},\n@@ -311,20 +311,34 @@ func TestGroupSigner_SignWithEntity(t *testing.T) {\n \t\t\t\tf:      twoGroups,\n \t\t\t\tid:     2,\n \t\t\t\tods:    []sif.Descriptor{d3},\n-\t\t\t\tmdHash: crypto.SHA1,\n+\t\t\t\tmdHash: crypto.SHA256,\n \t\t\t\tsigConfig: &packet.Config{\n \t\t\t\t\tTime: fixedTime,\n \t\t\t\t},\n \t\t\t},\n \t\t\te: e,\n \t\t},\n+\t\t{\n+\t\t\tname: \"SignatureConfigSHA224\",\n+\t\t\tgs: groupSigner{\n+\t\t\t\tf:      twoGroups,\n+\t\t\t\tid:     1,\n+\t\t\t\tods:    []sif.Descriptor{d1, d2},\n+\t\t\t\tmdHash: crypto.SHA256,\n+\t\t\t\tsigConfig: &packet.Config{\n+\t\t\t\t\tDefaultHash: crypto.SHA224,\n+\t\t\t\t\tTime:        fixedTime,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\te: e,\n+\t\t},\n \t\t{\n \t\t\tname: \"SignatureConfigSHA256\",\n \t\t\tgs: groupSigner{\n \t\t\t\tf:      twoGroups,\n \t\t\t\tid:     1,\n \t\t\t\tods:    []sif.Descriptor{d1, d2},\n-\t\t\t\tmdHash: crypto.SHA1,\n+\t\t\t\tmdHash: crypto.SHA256,\n \t\t\t\tsigConfig: &packet.Config{\n \t\t\t\t\tDefaultHash: crypto.SHA256,\n \t\t\t\t\tTime:        fixedTime,\n@@ -338,7 +352,7 @@ func TestGroupSigner_SignWithEntity(t *testing.T) {\n \t\t\t\tf:      twoGroups,\n \t\t\t\tid:     1,\n \t\t\t\tods:    []sif.Descriptor{d1, d2},\n-\t\t\t\tmdHash: crypto.SHA1,\n+\t\t\t\tmdHash: crypto.SHA256,\n \t\t\t\tsigConfig: &packet.Config{\n \t\t\t\t\tDefaultHash: crypto.SHA384,\n \t\t\t\t\tTime:        fixedTime,\n@@ -352,7 +366,7 @@ func TestGroupSigner_SignWithEntity(t *testing.T) {\n \t\t\t\tf:      twoGroups,\n \t\t\t\tid:     1,\n \t\t\t\tods:    []sif.Descriptor{d1, d2},\n-\t\t\t\tmdHash: crypto.SHA1,\n+\t\t\t\tmdHash: crypto.SHA256,\n \t\t\t\tsigConfig: &packet.Config{\n \t\t\t\t\tDefaultHash: crypto.SHA512,\n \t\t\t\t\tTime:        fixedTime,"
        },
        {
          "filename": "pkg/integrity/testdata/TestDigest_MarshalJSON/SHA1.golden",
          "status": "removed",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -1 +0,0 @@\n-\"sha1:597f6a540010f94c15d71806a99a2c8710e747bd\""
        },
        {
          "filename": "pkg/integrity/testdata/TestDigest_MarshalJSON/SHA512_224.golden",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+\"sha512_224:06001bf08dfb17d2b54925116823be230e98b5c6c278303bc4909a8c\""
        },
        {
          "filename": "pkg/integrity/testdata/TestDigest_MarshalJSON/SHA512_256.golden",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+\"sha512_256:3d37fe58435e0d87323dee4a2c1b339ef954de63716ee79f5747f94d974f913f\""
        },
        {
          "filename": "pkg/integrity/testdata/TestGetHeaderMetadata/SHA1.golden",
          "status": "removed",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -1 +0,0 @@\n-{\"digest\":\"sha1:bd6b562b49ff04470f641ad3c971822303049826\"}"
        },
        {
          "filename": "pkg/integrity/testdata/TestGetHeaderMetadata/SHA512_224.golden",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+{\"digest\":\"sha512_224:d5f9767e096056fcf381b801e2b0b80b33acdc09b7a7e3a1c504231e\"}"
        },
        {
          "filename": "pkg/integrity/testdata/TestGetHeaderMetadata/SHA512_256.golden",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+{\"digest\":\"sha512_256:eb199aeab4047ca6430890372769681045c20b1a0a4a78b595ab62dbdfc9285f\"}"
        },
        {
          "filename": "pkg/integrity/testdata/TestGetImageMetadata/Object1.golden",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1 +1 @@\n-{\"version\":1,\"header\":{\"digest\":\"sha1:86696357e7806b51baf75fc0bf9b8fc677e5cdd0\"},\"objects\":[{\"relativeId\":0,\"descriptorDigest\":\"sha1:1406a1a9c75a332fc50cb8519a9a7f9f2531480e\",\"objectDigest\":\"sha1:15146b9bf4f1f5f9bf176a398d8c4f0321c63064\"}]}\n+{\"version\":1,\"header\":{\"digest\":\"sha256:635fa0a14a8ef0c0351ed3e985799ed1d4f75ce973dea3cc76c99710795cc3f1\"},\"objects\":[{\"relativeId\":0,\"descriptorDigest\":\"sha256:3634ad01db0dd5482ecf685267b53d6201690438ca27c3d7ea91c971a1f41f92\",\"objectDigest\":\"sha256:004dfc8da678c309de28b5386a1e9efd57f536b150c40d29b31506aa0fb17ec2\"}]}"
        },
        {
          "filename": "pkg/integrity/testdata/TestGetImageMetadata/Object2.golden",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1 +1 @@\n-{\"version\":1,\"header\":{\"digest\":\"sha1:86696357e7806b51baf75fc0bf9b8fc677e5cdd0\"},\"objects\":[{\"relativeId\":1,\"descriptorDigest\":\"sha1:076d6ec6e32a6237d838ba20c825c6caa4c78544\",\"objectDigest\":\"sha1:fd526afdbdea7c87d81c33314b0e0dbdfa5ba79f\"}]}\n+{\"version\":1,\"header\":{\"digest\":\"sha256:635fa0a14a8ef0c0351ed3e985799ed1d4f75ce973dea3cc76c99710795cc3f1\"},\"objects\":[{\"relativeId\":1,\"descriptorDigest\":\"sha256:04b5f87c9692a54f80d10fb6af00c779763aeca29d610348854bd97cd8bf66fd\",\"objectDigest\":\"sha256:9f9c4e5e131934969b4ac8f495691c70b8c6c8e3f489c2c9ab5f1af82bce0604\"}]}"
        },
        {
          "filename": "pkg/integrity/testdata/TestGetImageMetadata/SHA1.golden",
          "status": "removed",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -1 +0,0 @@\n-{\"version\":1,\"header\":{\"digest\":\"sha1:86696357e7806b51baf75fc0bf9b8fc677e5cdd0\"},\"objects\":[{\"relativeId\":0,\"descriptorDigest\":\"sha1:1406a1a9c75a332fc50cb8519a9a7f9f2531480e\",\"objectDigest\":\"sha1:15146b9bf4f1f5f9bf176a398d8c4f0321c63064\"},{\"relativeId\":1,\"descriptorDigest\":\"sha1:076d6ec6e32a6237d838ba20c825c6caa4c78544\",\"objectDigest\":\"sha1:fd526afdbdea7c87d81c33314b0e0dbdfa5ba79f\"}]}"
        },
        {
          "filename": "pkg/integrity/testdata/TestGetObjectMetadata/RelativeID.golden",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1 +1 @@\n-{\"relativeId\":1,\"descriptorDigest\":\"sha1:f3681c97de35ea124cd2e3687ed62988c7138f3a\",\"objectDigest\":\"sha1:5bf1fd927dfb8679496a2e6cf00cbe50c1c87145\"}\n+{\"relativeId\":1,\"descriptorDigest\":\"sha256:a1e6ca1d0cce1fbd71b186ac7a5c5a805c833ecc419a78d017558e79c0862790\",\"objectDigest\":\"sha256:8b7df143d91c716ecfa5fc1730022f6b421b05cedee8fd52b1fc65a96030ad52\"}"
        },
        {
          "filename": "pkg/integrity/testdata/TestGetObjectMetadata/SHA1.golden",
          "status": "removed",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -1 +0,0 @@\n-{\"relativeId\":0,\"descriptorDigest\":\"sha1:042874d3fd63a516c5abe45b221ed8db1e5cfd84\",\"objectDigest\":\"sha1:5bf1fd927dfb8679496a2e6cf00cbe50c1c87145\"}"
        },
        {
          "filename": "pkg/integrity/testdata/TestGetObjectMetadata/SHA512_224.golden",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+{\"relativeId\":0,\"descriptorDigest\":\"sha512_224:ba5b52f4337756f9efb0c7d35f16e0365ba5845b0dd9df5e9edfce3a\",\"objectDigest\":\"sha512_224:b1d15ae18bb05265b44e9e0137f08078f53f5b239a78c49c2cfc2c9c\"}"
        },
        {
          "filename": "pkg/integrity/testdata/TestGetObjectMetadata/SHA512_256.golden",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+{\"relativeId\":0,\"descriptorDigest\":\"sha512_256:aef151cf86aaab28a4e086c9e1f9d19c8f85e4eb794336d909a6844ce7fb52ef\",\"objectDigest\":\"sha512_256:9a801762c512490303535d35c221e2dc1d24f5094d038041dc4303ba7ac04f0e\"}"
        },
        {
          "filename": "pkg/integrity/testdata/TestGroupSigner_SignWithEntity/Group1.golden",
          "status": "modified",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "pkg/integrity/testdata/TestGroupSigner_SignWithEntity/Group2.golden",
          "status": "modified",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "pkg/integrity/testdata/TestGroupSigner_SignWithEntity/Object1.golden",
          "status": "modified",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "pkg/integrity/testdata/TestGroupSigner_SignWithEntity/Object2.golden",
          "status": "modified",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "pkg/integrity/testdata/TestGroupSigner_SignWithEntity/SignatureConfigSHA224.golden",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "pkg/integrity/testdata/TestGroupSigner_SignWithEntity/SignatureConfigSHA256.golden",
          "status": "modified",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "pkg/integrity/testdata/TestGroupSigner_SignWithEntity/SignatureConfigSHA384.golden",
          "status": "modified",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "pkg/integrity/testdata/TestGroupSigner_SignWithEntity/SignatureConfigSHA512.golden",
          "status": "modified",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "pkg/integrity/testdata/TestSignAndEncodeJSON/SHA1.golden",
          "status": "removed",
          "additions": 0,
          "deletions": 15,
          "patch": "@@ -1,15 +0,0 @@\n------BEGIN PGP SIGNED MESSAGE-----\n-Hash: SHA1\n-\n-{\"One\":1,\"Two\":2}\n------BEGIN PGP SIGNATURE-----\n-\n-wsBzBAEBAgAnBQJZr0CRCZCiDCfuf/e6hBYhBBIEXIwLEATQWN5L7aIMJ+5/97qE\n-AACQnAf/XWNnfBZfoOffU9YBG4JIGbo1fBuO0NbxlP22zpiS9NM2CViTHmpmqe7K\n-9d53CXsHrpQB1Oc+h5c5QsWjOl3girXO8du9833lygsFGjK3Q9mc0cfrXoEMOw+N\n-B0hMq/JxQVOfdBn0Z5YF6Sfkjkifhm36GpNB8I3QmuIu3kd2nIfa6WLo7h4txKFU\n-0ZPxRZ8IWFTTBEhWwSUrR30cOr5PvQfu0oTZ7xxkeUPudmxNXBad6uunyXyBkhmq\n-m0fMZyCbPeRc5gvUsAnxSDAKU5Ryj6GIUBpBv7c3AXwfusO4HAaOQi+BZDTjMVBF\n-AXJc73L0mvJvX9dOEnmd6D7xylclHQ==\n-=BpCt\n------END PGP SIGNATURE-----\n\\ No newline at end of file"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 4,
        "dependency_files": 0,
        "test_files": 26,
        "unique_directories": 7,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "1aeebfa4905bbc3d5f0d06dd0e5dfa826a6ebfed",
            "date": "2025-01-09T18:22:45Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "1cdd8020c3607239330ab2603f539932f80211de",
            "date": "2025-01-07T19:54:13Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "5d200255072a9c544e1ebd49c0848647cfe7afe2",
            "date": "2024-12-13T21:27:31Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "d9c0d4ec5fa71945639e56997bbda0e33bc70239",
            "date": "2024-12-12T15:16:17Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "d2697c62fec39eb97b317757cc3a5feef2bd5e98",
            "date": "2024-12-03T15:18:08Z",
            "author_login": "tri-adam"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L",
    "cwe_id": "CWE-347",
    "description": "syslabs/sif is the Singularity Image Format (SIF) reference implementation. In versions prior to 2.8.1the `github.com/sylabs/sif/v2/pkg/integrity` package did not verify that the hash algorithm(s) used are cryptographically secure when verifying digital signatures. A patch is available in version >= v2.8.1 of the module. Users are encouraged to upgrade. Users unable to upgrade may independently validate that the hash algorithm(s) used for metadata digest(s) and signature hash are cryptographically secure.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-10-06T18:16:10.160",
    "last_modified": "2024-11-21T07:17:50.937",
    "fix_date": "2022-10-06T11:52:14Z"
  },
  "references": [
    {
      "url": "https://github.com/sylabs/sif/commit/07fb86029a12e3210f6131e065570124605daeaa",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sylabs/sif/security/advisories/GHSA-m5m3-46gj-wch8",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202210-19",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sylabs/sif/commit/07fb86029a12e3210f6131e065570124605daeaa",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sylabs/sif/security/advisories/GHSA-m5m3-46gj-wch8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202210-19",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:41.310819",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "sif",
    "owner": "sylabs",
    "created_at": "2021-05-04T13:41:36Z",
    "updated_at": "2025-01-09T18:22:51Z",
    "pushed_at": "2025-01-09T18:22:54Z",
    "size": 5674,
    "stars": 17,
    "forks": 10,
    "open_issues": 7,
    "watchers": 17,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "oci",
      "v1"
    ],
    "languages": {
      "Go": 346609
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T18:13:48.688786"
  }
}